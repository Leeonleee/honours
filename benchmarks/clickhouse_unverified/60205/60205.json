{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60205,
  "instance_id": "ClickHouse__ClickHouse-60205",
  "issue_numbers": [
    "60685"
  ],
  "base_commit": "2eb7fa297b5e3ab1656bc1560990fe6bf1e66ed6",
  "patch": "diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 0047ea1bc780..62f3d032efc2 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -38,7 +38,6 @@\n #include <Storages/StorageInMemoryMetadata.h>\n #include <Storages/WindowView/StorageWindowView.h>\n #include <Storages/StorageReplicatedMergeTree.h>\n-#include <Storages/BlockNumberColumn.h>\n \n #include <Interpreters/Context.h>\n #include <Interpreters/executeDDLQueryOnCluster.h>\n@@ -894,24 +893,6 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat\n             throw Exception(ErrorCodes::DUPLICATE_COLUMN, \"Column {} already exists\", backQuoteIfNeed(column.name));\n     }\n \n-    /// Check if _row_exists for lightweight delete column in column_lists for merge tree family.\n-    if (create.storage && create.storage->engine && endsWith(create.storage->engine->name, \"MergeTree\"))\n-    {\n-        auto search = all_columns.find(LightweightDeleteDescription::FILTER_COLUMN.name);\n-        if (search != all_columns.end())\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                            \"Cannot create table with column '{}' for *MergeTree engines because it \"\n-                            \"is reserved for lightweight delete feature\",\n-                            LightweightDeleteDescription::FILTER_COLUMN.name);\n-\n-        auto search_block_number = all_columns.find(BlockNumberColumn::name);\n-        if (search_block_number != all_columns.end())\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                            \"Cannot create table with column '{}' for *MergeTree engines because it \"\n-                            \"is reserved for storing block number\",\n-                            BlockNumberColumn::name);\n-    }\n-\n     const auto & settings = getContext()->getSettingsRef();\n \n     /// If it's not attach and not materialized view to existing table,\n@@ -924,9 +905,23 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat\n     }\n }\n \n+void validateVirtualColumns(const IStorage & storage)\n+{\n+    auto virtual_columns = storage.getVirtualsPtr();\n+    for (const auto & storage_column : storage.getInMemoryMetadataPtr()->getColumns())\n+    {\n+        if (virtual_columns->tryGet(storage_column.name, VirtualsKind::Persistent))\n+        {\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                \"Cannot create table with column '{}' for {} engines because it is reserved for persistent virtual column\",\n+                storage_column.name, storage.getName());\n+        }\n+    }\n+}\n+\n namespace\n {\n-    void checkTemporaryTableEngineName(const String& name)\n+    void checkTemporaryTableEngineName(const String & name)\n     {\n         if (name.starts_with(\"Replicated\") || name.starts_with(\"Shared\") || name == \"KeeperMap\")\n             throw Exception(ErrorCodes::INCORRECT_QUERY, \"Temporary tables cannot be created with Replicated, Shared or KeeperMap table engines\");\n@@ -1509,6 +1504,16 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n         addColumnsDescriptionToCreateQueryIfNecessary(query_ptr->as<ASTCreateQuery &>(), res);\n     }\n \n+    validateVirtualColumns(*res);\n+\n+    if (!res->supportsDynamicSubcolumns() && hasDynamicSubcolumns(res->getInMemoryMetadataPtr()->getColumns()))\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+            \"Cannot create table with column of type Object, \"\n+            \"because storage {} doesn't support dynamic subcolumns\",\n+            res->getName());\n+    }\n+\n     if (!create.attach && getContext()->getSettingsRef().database_replicated_allow_only_replicated_engine)\n     {\n         bool is_replicated_storage = typeid_cast<const StorageReplicatedMergeTree *>(res.get()) != nullptr;\n@@ -1558,14 +1563,6 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     /// we can safely destroy the object without a call to \"shutdown\", because there is guarantee\n     /// that no background threads/similar resources remain after exception from \"startup\".\n \n-    if (!res->supportsDynamicSubcolumns() && hasDynamicSubcolumns(res->getInMemoryMetadataPtr()->getColumns()))\n-    {\n-        throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-            \"Cannot create table with column of type Object, \"\n-            \"because storage {} doesn't support dynamic subcolumns\",\n-            res->getName());\n-    }\n-\n     res->startup();\n     return true;\n }\ndiff --git a/src/Interpreters/InterpreterDeleteQuery.cpp b/src/Interpreters/InterpreterDeleteQuery.cpp\nindex 5c13a1145d1c..97ae9649ae8f 100644\n--- a/src/Interpreters/InterpreterDeleteQuery.cpp\n+++ b/src/Interpreters/InterpreterDeleteQuery.cpp\n@@ -15,7 +15,6 @@\n #include <Storages/AlterCommands.h>\n #include <Storages/IStorage.h>\n #include <Storages/MutationCommands.h>\n-#include <Storages/LightweightDeleteDescription.h>\n \n \n namespace DB\ndiff --git a/src/Interpreters/InterpreterDescribeQuery.cpp b/src/Interpreters/InterpreterDescribeQuery.cpp\nindex 1aab72afcc1d..04d44e34fffc 100644\n--- a/src/Interpreters/InterpreterDescribeQuery.cpp\n+++ b/src/Interpreters/InterpreterDescribeQuery.cpp\n@@ -123,28 +123,29 @@ BlockIO InterpreterDescribeQuery::execute()\n \n void InterpreterDescribeQuery::fillColumnsFromSubquery(const ASTTableExpression & table_expression)\n {\n-    NamesAndTypesList names_and_types;\n+    Block sample_block;\n     auto select_query = table_expression.subquery->children.at(0);\n     auto current_context = getContext();\n \n     if (settings.allow_experimental_analyzer)\n     {\n         SelectQueryOptions select_query_options;\n-        names_and_types = InterpreterSelectQueryAnalyzer(select_query, current_context, select_query_options).getSampleBlock().getNamesAndTypesList();\n+        sample_block = InterpreterSelectQueryAnalyzer(select_query, current_context, select_query_options).getSampleBlock();\n     }\n     else\n     {\n-        names_and_types = InterpreterSelectWithUnionQuery::getSampleBlock(select_query, current_context).getNamesAndTypesList();\n+        sample_block = InterpreterSelectWithUnionQuery::getSampleBlock(select_query, current_context);\n     }\n \n-    for (auto && [name, type] : names_and_types)\n-        columns.emplace_back(std::move(name), std::move(type));\n+    for (auto && column : sample_block)\n+        columns.emplace_back(std::move(column.name), std::move(column.type));\n }\n \n void InterpreterDescribeQuery::fillColumnsFromTableFunction(const ASTTableExpression & table_expression)\n {\n     auto current_context = getContext();\n     TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_expression.table_function, current_context);\n+\n     auto column_descriptions = table_function_ptr->getActualTableStructure(getContext(), /*is_insert_query*/ true);\n     for (const auto & column : column_descriptions)\n         columns.emplace_back(column);\n@@ -154,14 +155,16 @@ void InterpreterDescribeQuery::fillColumnsFromTableFunction(const ASTTableExpres\n         auto table = table_function_ptr->execute(table_expression.table_function, getContext(), table_function_ptr->getName());\n         if (table)\n         {\n-            for (const auto & column : table->getVirtuals())\n+            auto virtuals = table->getVirtualsPtr();\n+            for (const auto & column : *virtuals)\n             {\n                 if (!column_descriptions.has(column.name))\n-                    virtual_columns.emplace_back(column.name, column.type);\n+                    virtual_columns.push_back(column);\n             }\n         }\n     }\n }\n+\n void InterpreterDescribeQuery::fillColumnsFromTable(const ASTTableExpression & table_expression)\n {\n     auto table_id = getContext()->resolveStorageID(table_expression.database_and_table_name);\n@@ -176,10 +179,11 @@ void InterpreterDescribeQuery::fillColumnsFromTable(const ASTTableExpression & t\n \n     if (settings.describe_include_virtual_columns)\n     {\n-        for (const auto & column : table->getVirtuals())\n+        auto virtuals = table->getVirtualsPtr();\n+        for (const auto & column : *virtuals)\n         {\n             if (!column_descriptions.has(column.name))\n-                virtual_columns.emplace_back(column.name, column.type);\n+                virtual_columns.push_back(column);\n         }\n     }\n \ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex e27a8bd414ba..fcb173230cf0 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -136,7 +136,7 @@ Block InterpreterInsertQuery::getSampleBlock(\n         if (auto * window_view = dynamic_cast<StorageWindowView *>(table.get()))\n             return window_view->getInputHeader();\n         else if (no_destination)\n-            return metadata_snapshot->getSampleBlockWithVirtuals(table->getVirtuals());\n+            return metadata_snapshot->getSampleBlockWithVirtuals(table->getVirtualsList());\n         else\n             return metadata_snapshot->getSampleBlockNonMaterialized();\n     }\ndiff --git a/src/Interpreters/InterpreterShowColumnsQuery.cpp b/src/Interpreters/InterpreterShowColumnsQuery.cpp\nindex 149ba6d75757..f32ebceaa63e 100644\n--- a/src/Interpreters/InterpreterShowColumnsQuery.cpp\n+++ b/src/Interpreters/InterpreterShowColumnsQuery.cpp\n@@ -107,7 +107,7 @@ SELECT\n     '' AS extra )\";\n \n     // TODO Interpret query.extended. It is supposed to show internal/virtual columns. Need to fetch virtual column names, see\n-    // IStorage::getVirtuals(). We can't easily do that via SQL.\n+    // IStorage::getVirtualsList(). We can't easily do that via SQL.\n \n     if (query.full)\n     {\ndiff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex 9be8bf178a19..496933322800 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -272,7 +272,7 @@ void JoinedTables::makeFakeTable(StoragePtr storage, const StorageMetadataPtr &\n         auto & table = tables_with_columns.back();\n         table.addHiddenColumns(storage_columns.getMaterialized());\n         table.addHiddenColumns(storage_columns.getAliases());\n-        table.addHiddenColumns(storage->getVirtuals());\n+        table.addHiddenColumns(storage->getVirtualsList());\n     }\n     else\n         tables_with_columns.emplace_back(DatabaseAndTableWithAlias{}, source_header.getNamesAndTypesList());\ndiff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex a3d1b84fdc12..3b1a499255b5 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -7,7 +7,7 @@\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Storages/MergeTree/StorageFromMergeTreeDataPart.h>\n #include <Storages/StorageMergeTree.h>\n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Processors/Transforms/FilterTransform.h>\n #include <Processors/Transforms/ExpressionTransform.h>\n #include <Processors/Transforms/CreatingSetsTransform.h>\n@@ -31,7 +31,6 @@\n #include <Processors/QueryPlan/CreatingSetsStep.h>\n #include <DataTypes/NestedUtils.h>\n #include <Interpreters/PreparedSets.h>\n-#include <Storages/LightweightDeleteDescription.h>\n #include <Storages/MergeTree/MergeTreeSequentialSource.h>\n #include <Processors/Sources/ThrowingExceptionSource.h>\n #include <Analyzer/QueryTreeBuilder.h>\n@@ -265,7 +264,7 @@ MutationCommand createCommandToApplyDeletedMask(const MutationCommand & command)\n     alter_command->partition = alter_command->children.emplace_back(command.partition).get();\n \n     auto row_exists_predicate = makeASTFunction(\"equals\",\n-        std::make_shared<ASTIdentifier>(LightweightDeleteDescription::FILTER_COLUMN.name),\n+        std::make_shared<ASTIdentifier>(RowExistsColumn::name),\n         std::make_shared<ASTLiteral>(Field(0)));\n \n     if (command.predicate)\n@@ -350,7 +349,8 @@ bool MutationsInterpreter::Source::isCompactPart() const\n static Names getAvailableColumnsWithVirtuals(StorageMetadataPtr metadata_snapshot, const IStorage & storage)\n {\n     auto all_columns = metadata_snapshot->getColumns().getNamesOfPhysical();\n-    for (const auto & column : storage.getVirtuals())\n+    auto virtuals = storage.getVirtualsPtr();\n+    for (const auto & column : *virtuals)\n         all_columns.push_back(column.name);\n     return all_columns;\n }\n@@ -435,60 +435,54 @@ static NameSet getKeyColumns(const MutationsInterpreter::Source & source, const\n \n static void validateUpdateColumns(\n     const MutationsInterpreter::Source & source,\n-    const StorageMetadataPtr & metadata_snapshot, const NameSet & updated_columns,\n-    const std::unordered_map<String, Names> & column_to_affected_materialized)\n+    const StorageMetadataPtr & metadata_snapshot,\n+    const NameSet & updated_columns,\n+    const std::unordered_map<String, Names> & column_to_affected_materialized,\n+    const ContextPtr & context)\n {\n+    auto storage_snapshot = source.getStorageSnapshot(metadata_snapshot, context);\n     NameSet key_columns = getKeyColumns(source, metadata_snapshot);\n \n-    for (const String & column_name : updated_columns)\n-    {\n-        auto found = false;\n-        for (const auto & col : metadata_snapshot->getColumns().getOrdinary())\n-        {\n-            if (col.name == column_name)\n-            {\n-                found = true;\n-                break;\n-            }\n-        }\n-\n-        /// Allow to override value of lightweight delete filter virtual column\n-        if (!found && column_name == LightweightDeleteDescription::FILTER_COLUMN.name)\n-        {\n-            if (!source.supportsLightweightDelete())\n-                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Lightweight delete is not supported for table\");\n-            found = true;\n-        }\n-\n-        /// Dont allow to override value of block number virtual column\n-        if (!found && column_name == BlockNumberColumn::name)\n-        {\n-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Update is not supported for virtual column {} \", backQuote(column_name));\n-        }\n-\n-        if (!found)\n-        {\n-            for (const auto & col : metadata_snapshot->getColumns().getMaterialized())\n-            {\n-                if (col.name == column_name)\n-                    throw Exception(ErrorCodes::CANNOT_UPDATE_COLUMN, \"Cannot UPDATE materialized column {}\", backQuote(column_name));\n-            }\n-\n-            throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no column {} in table\", backQuote(column_name));\n-        }\n+    const auto & storage_columns = storage_snapshot->metadata->getColumns();\n+    const auto & virtual_columns = *storage_snapshot->virtual_columns;\n \n+    for (const auto & column_name : updated_columns)\n+    {\n         if (key_columns.contains(column_name))\n             throw Exception(ErrorCodes::CANNOT_UPDATE_COLUMN, \"Cannot UPDATE key column {}\", backQuote(column_name));\n \n+        if (storage_columns.tryGetColumn(GetColumnsOptions::Materialized, column_name))\n+            throw Exception(ErrorCodes::CANNOT_UPDATE_COLUMN, \"Cannot UPDATE materialized column {}\", backQuote(column_name));\n+\n         auto materialized_it = column_to_affected_materialized.find(column_name);\n         if (materialized_it != column_to_affected_materialized.end())\n         {\n-            for (const String & materialized : materialized_it->second)\n+            for (const auto & materialized : materialized_it->second)\n             {\n                 if (key_columns.contains(materialized))\n+                {\n                     throw Exception(ErrorCodes::CANNOT_UPDATE_COLUMN,\n                                     \"Updated column {} affects MATERIALIZED column {}, which is a key column. \"\n                                     \"Cannot UPDATE it.\", backQuote(column_name), backQuote(materialized));\n+                }\n+            }\n+        }\n+\n+        if (!storage_columns.tryGetColumn(GetColumnsOptions::Ordinary, column_name))\n+        {\n+            /// Allow to override value of lightweight delete filter virtual column\n+            if (column_name == RowExistsColumn::name)\n+            {\n+                if (!source.supportsLightweightDelete())\n+                    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Lightweight delete is not supported for table\");\n+            }\n+            else if (virtual_columns.tryGet(column_name))\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Update is not supported for virtual column {} \", backQuote(column_name));\n+            }\n+            else\n+            {\n+                throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no column {} in table\", backQuote(column_name));\n             }\n         }\n     }\n@@ -546,8 +540,8 @@ void MutationsInterpreter::prepare(bool dry_run)\n     /// Add _row_exists column if it is physically present in the part\n     if (source.hasLightweightDeleteMask())\n     {\n-        all_columns.push_back({LightweightDeleteDescription::FILTER_COLUMN});\n-        available_columns_set.insert(LightweightDeleteDescription::FILTER_COLUMN.name);\n+        all_columns.emplace_back(RowExistsColumn::name, RowExistsColumn::type);\n+        available_columns_set.insert(RowExistsColumn::name);\n     }\n \n     NameSet updated_columns;\n@@ -563,9 +557,7 @@ void MutationsInterpreter::prepare(bool dry_run)\n \n         for (const auto & [name, _] : command.column_to_update_expression)\n         {\n-            if (!available_columns_set.contains(name)\n-                && name != LightweightDeleteDescription::FILTER_COLUMN.name\n-                && name != BlockNumberColumn::name)\n+            if (!available_columns_set.contains(name) && name != RowExistsColumn::name)\n                 throw Exception(ErrorCodes::THERE_IS_NO_COLUMN,\n                     \"Column {} is updated but not requested to read\", name);\n \n@@ -590,7 +582,7 @@ void MutationsInterpreter::prepare(bool dry_run)\n             }\n         }\n \n-        validateUpdateColumns(source, metadata_snapshot, updated_columns, column_to_affected_materialized);\n+        validateUpdateColumns(source, metadata_snapshot, updated_columns, column_to_affected_materialized, context);\n     }\n \n     StorageInMemoryMetadata::HasDependencyCallback has_dependency =\n@@ -666,15 +658,11 @@ void MutationsInterpreter::prepare(bool dry_run)\n                 {\n                     type = physical_column->type;\n                 }\n-                else if (column_name == LightweightDeleteDescription::FILTER_COLUMN.name)\n+                else if (column_name == RowExistsColumn::name)\n                 {\n-                    type = LightweightDeleteDescription::FILTER_COLUMN.type;\n+                    type = RowExistsColumn::type;\n                     deleted_mask_updated = true;\n                 }\n-                else if (column_name == BlockNumberColumn::name)\n-                {\n-                    type = BlockNumberColumn::type;\n-                }\n                 else\n                 {\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column_name);\n@@ -1028,7 +1016,7 @@ void MutationsInterpreter::prepareMutationStages(std::vector<Stage> & prepared_s\n \n     /// Add _row_exists column if it is present in the part\n     if (source.hasLightweightDeleteMask() || deleted_mask_updated)\n-        all_columns.push_back(LightweightDeleteDescription::FILTER_COLUMN);\n+        all_columns.emplace_back(RowExistsColumn::name, RowExistsColumn::type);\n \n     bool has_filters = false;\n     /// Next, for each stage calculate columns changed by this and previous stages.\n@@ -1038,7 +1026,7 @@ void MutationsInterpreter::prepareMutationStages(std::vector<Stage> & prepared_s\n         {\n             for (const auto & column : all_columns)\n             {\n-                if (column.name == LightweightDeleteDescription::FILTER_COLUMN.name && !deleted_mask_updated)\n+                if (column.name == RowExistsColumn::name && !deleted_mask_updated)\n                     continue;\n \n                 prepared_stages[i].output_columns.insert(column.name);\n@@ -1057,7 +1045,7 @@ void MutationsInterpreter::prepareMutationStages(std::vector<Stage> & prepared_s\n             /// and so it is not in the list of AllPhysical columns.\n             for (const auto & [column_name, _] : prepared_stages[i].column_to_updated)\n             {\n-                if (column_name == LightweightDeleteDescription::FILTER_COLUMN.name && has_filters && !deleted_mask_updated)\n+                if (column_name == RowExistsColumn::name && has_filters && !deleted_mask_updated)\n                     continue;\n \n                 prepared_stages[i].output_columns.insert(column_name);\n@@ -1148,93 +1136,6 @@ void MutationsInterpreter::prepareMutationStages(std::vector<Stage> & prepared_s\n     }\n }\n \n-/// This structure re-implements adding virtual columns while reading from MergeTree part.\n-/// It would be good to unify it with IMergeTreeSelectAlgorithm.\n-struct VirtualColumns\n-{\n-    struct ColumnAndPosition\n-    {\n-        ColumnWithTypeAndName column;\n-        size_t position;\n-    };\n-\n-    using Columns = std::vector<ColumnAndPosition>;\n-\n-    Columns virtuals;\n-    Names columns_to_read;\n-\n-    VirtualColumns(Names required_columns, const MergeTreeData::DataPartPtr & part) : columns_to_read(std::move(required_columns))\n-    {\n-        for (size_t i = 0; i < columns_to_read.size(); ++i)\n-        {\n-            if (columns_to_read[i] == LightweightDeleteDescription::FILTER_COLUMN.name)\n-            {\n-                if (!part->getColumns().contains(LightweightDeleteDescription::FILTER_COLUMN.name))\n-                {\n-                    ColumnWithTypeAndName mask_column;\n-                    mask_column.type = LightweightDeleteDescription::FILTER_COLUMN.type;\n-                    mask_column.column = mask_column.type->createColumnConst(0, 1);\n-                    mask_column.name = std::move(columns_to_read[i]);\n-\n-                    virtuals.emplace_back(ColumnAndPosition{.column = std::move(mask_column), .position = i});\n-                }\n-            }\n-            else if (columns_to_read[i] == \"_partition_id\")\n-            {\n-                ColumnWithTypeAndName column;\n-                column.type = std::make_shared<DataTypeString>();\n-                column.column = column.type->createColumnConst(0, part->info.partition_id);\n-                column.name = std::move(columns_to_read[i]);\n-\n-                virtuals.emplace_back(ColumnAndPosition{.column = std::move(column), .position = i});\n-            }\n-            else if (columns_to_read[i] == BlockNumberColumn::name)\n-            {\n-                if (!part->getColumns().contains(BlockNumberColumn::name))\n-                {\n-                    ColumnWithTypeAndName block_number_column;\n-                    block_number_column.type = BlockNumberColumn::type;\n-                    block_number_column.column = block_number_column.type->createColumnConst(0, part->info.min_block);\n-                    block_number_column.name = std::move(columns_to_read[i]);\n-\n-                    virtuals.emplace_back(ColumnAndPosition{.column = std::move(block_number_column), .position = i});\n-                }\n-            }\n-        }\n-\n-        if (!virtuals.empty())\n-        {\n-            Names columns_no_virtuals;\n-            columns_no_virtuals.reserve(columns_to_read.size());\n-            size_t next_virtual = 0;\n-            for (size_t i = 0; i < columns_to_read.size(); ++i)\n-            {\n-                if (next_virtual < virtuals.size() && i == virtuals[next_virtual].position)\n-                    ++next_virtual;\n-                else\n-                    columns_no_virtuals.emplace_back(std::move(columns_to_read[i]));\n-            }\n-\n-            columns_to_read.swap(columns_no_virtuals);\n-        }\n-    }\n-\n-    void addVirtuals(QueryPlan & plan)\n-    {\n-        auto dag = std::make_unique<ActionsDAG>(plan.getCurrentDataStream().header.getColumnsWithTypeAndName());\n-\n-        for (auto & column : virtuals)\n-        {\n-            const auto & adding_const = dag->addColumn(std::move(column.column));\n-            auto & outputs = dag->getOutputs();\n-            outputs.insert(outputs.begin() + column.position, &adding_const);\n-        }\n-\n-        auto step = std::make_unique<ExpressionStep>(plan.getCurrentDataStream(), std::move(dag));\n-        plan.addStep(std::move(step));\n-    }\n-};\n-\n void MutationsInterpreter::Source::read(\n     Stage & first_stage,\n     QueryPlan & plan,\n@@ -1277,16 +1178,12 @@ void MutationsInterpreter::Source::read(\n             filter = ActionsDAG::buildFilterActionsDAG(nodes);\n         }\n \n-        VirtualColumns virtual_columns(std::move(required_columns), part);\n-\n         createReadFromPartStep(\n             MergeTreeSequentialSourceType::Mutation,\n-            plan, *data, storage_snapshot, part,\n-            std::move(virtual_columns.columns_to_read),\n+            plan, *data, storage_snapshot,\n+            part, required_columns,\n             apply_deleted_mask_, filter, context_,\n             getLogger(\"MutationsInterpreter\"));\n-\n-        virtual_columns.addVirtuals(plan);\n     }\n     else\n     {\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 960fad5dec6c..5588fc55a642 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -56,6 +56,7 @@\n #include <Storages/IStorage.h>\n #include <Storages/StorageJoin.h>\n #include <Common/checkStackSize.h>\n+#include <Storages/MergeTree/MergeTreeData.h>\n #include <Storages/StorageView.h>\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n@@ -990,8 +991,7 @@ void TreeRewriterResult::collectSourceColumns(bool add_special)\n     {\n         auto options = GetColumnsOptions(add_special ? GetColumnsOptions::All : GetColumnsOptions::AllPhysical);\n         options.withExtendedObjects();\n-        if (storage->supportsSubcolumns())\n-            options.withSubcolumns();\n+        options.withSubcolumns(storage->supportsSubcolumns());\n \n         auto columns_from_storage = storage_snapshot->getColumns(options);\n \n@@ -1001,8 +1001,7 @@ void TreeRewriterResult::collectSourceColumns(bool add_special)\n             source_columns.insert(source_columns.end(), columns_from_storage.begin(), columns_from_storage.end());\n \n         auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n-        auto metadata_column_descriptions = metadata_snapshot->getColumns();\n-        source_columns_ordinary = metadata_column_descriptions.getOrdinary();\n+        source_columns_ordinary = metadata_snapshot->getColumns().getOrdinary();\n     }\n \n     source_columns_set = removeDuplicateColumns(source_columns);\n@@ -1109,16 +1108,16 @@ bool TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n         const auto & partition_desc = storage_snapshot->metadata->getPartitionKey();\n         if (partition_desc.expression)\n         {\n-            auto partition_source_columns = partition_desc.expression->getRequiredColumns();\n-            partition_source_columns.push_back(\"_part\");\n-            partition_source_columns.push_back(\"_partition_id\");\n-            partition_source_columns.push_back(\"_part_uuid\");\n-            partition_source_columns.push_back(\"_partition_value\");\n+            auto partition_columns = partition_desc.expression->getRequiredColumns();\n+            NameSet partition_columns_set(partition_columns.begin(), partition_columns.end());\n+\n+            const auto & parititon_virtuals = MergeTreeData::virtuals_useful_for_filter;\n+            partition_columns_set.insert(parititon_virtuals.begin(), parititon_virtuals.end());\n+\n             optimize_trivial_count = true;\n             for (const auto & required_column : required)\n             {\n-                if (std::find(partition_source_columns.begin(), partition_source_columns.end(), required_column)\n-                    == partition_source_columns.end())\n+                if (!partition_columns_set.contains(required_column))\n                 {\n                     optimize_trivial_count = false;\n                     break;\n@@ -1129,7 +1128,7 @@ bool TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n \n     NameSet unknown_required_source_columns = required;\n \n-    for (NamesAndTypesList::iterator it = source_columns.begin(); it != source_columns.end();)\n+    for (auto it = source_columns.begin(); it != source_columns.end();)\n     {\n         const String & column_name = it->name;\n         unknown_required_source_columns.erase(column_name);\n@@ -1143,32 +1142,23 @@ bool TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n     has_virtual_shard_num = false;\n     /// If there are virtual columns among the unknown columns. Remove them from the list of unknown and add\n     /// in columns list, so that when further processing they are also considered.\n-    if (storage)\n+    if (storage_snapshot)\n     {\n-        const auto storage_virtuals = storage->getVirtuals();\n+        const auto & virtuals = storage_snapshot->virtual_columns;\n         for (auto it = unknown_required_source_columns.begin(); it != unknown_required_source_columns.end();)\n         {\n-            auto column = storage_virtuals.tryGetByName(*it);\n-            if (column)\n+            if (auto column = virtuals->tryGet(*it))\n             {\n                 source_columns.push_back(*column);\n                 it = unknown_required_source_columns.erase(it);\n             }\n             else\n-                ++it;\n-        }\n-\n-        if (is_remote_storage)\n-        {\n-            for (const auto & name_type : storage_virtuals)\n             {\n-                if (name_type.name == \"_shard_num\" && storage->isVirtualColumn(\"_shard_num\", storage_snapshot->getMetadataForQuery()))\n-                {\n-                    has_virtual_shard_num = true;\n-                    break;\n-                }\n+                ++it;\n             }\n         }\n+\n+        has_virtual_shard_num = is_remote_storage && storage->isVirtualColumn(\"_shard_num\", storage_snapshot->getMetadataForQuery()) && virtuals->has(\"_shard_num\");\n     }\n \n     /// Collect missed object subcolumns\ndiff --git a/src/Interpreters/getTableExpressions.cpp b/src/Interpreters/getTableExpressions.cpp\nindex 70e38526648f..2853be4c05e0 100644\n--- a/src/Interpreters/getTableExpressions.cpp\n+++ b/src/Interpreters/getTableExpressions.cpp\n@@ -99,7 +99,7 @@ static NamesAndTypesList getColumnsFromTableExpression(\n         names_and_type_list = columns.getOrdinary();\n         materialized = columns.getMaterialized();\n         aliases = columns.getAliases();\n-        virtuals = function_storage->getVirtuals();\n+        virtuals = function_storage->getVirtualsList();\n     }\n     else if (table_expression.database_and_table_name)\n     {\n@@ -110,7 +110,7 @@ static NamesAndTypesList getColumnsFromTableExpression(\n         names_and_type_list = columns.getOrdinary();\n         materialized = columns.getMaterialized();\n         aliases = columns.getAliases();\n-        virtuals = table->getVirtuals();\n+        virtuals = table->getVirtualsList();\n     }\n \n     return names_and_type_list;\ndiff --git a/src/Interpreters/inplaceBlockConversions.cpp b/src/Interpreters/inplaceBlockConversions.cpp\nindex fd8f5b154c43..239cce5b4278 100644\n--- a/src/Interpreters/inplaceBlockConversions.cpp\n+++ b/src/Interpreters/inplaceBlockConversions.cpp\n@@ -20,7 +20,6 @@\n #include <Columns/ColumnArray.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Storages/StorageInMemoryMetadata.h>\n-#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n@@ -280,7 +279,7 @@ void fillMissingColumns(\n     const NamesAndTypesList & requested_columns,\n     const NamesAndTypesList & available_columns,\n     const NameSet & partially_read_columns,\n-    StorageMetadataPtr metadata_snapshot, size_t block_number)\n+    StorageMetadataPtr metadata_snapshot)\n {\n     size_t num_columns = requested_columns.size();\n     if (num_columns != res_columns.size())\n@@ -359,14 +358,9 @@ void fillMissingColumns(\n         }\n         else\n         {\n-            if (requested_column->name == BlockNumberColumn::name)\n-                res_columns[i] = type->createColumnConst(num_rows, block_number)->convertToFullColumnIfConst();\n-            else\n-                /// We must turn a constant column into a full column because the interpreter could infer\n-                /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n-                res_columns[i] = type->createColumnConstWithDefaultValue(num_rows)->convertToFullColumnIfConst();\n-\n-\n+            /// We must turn a constant column into a full column because the interpreter could infer\n+            /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n+            res_columns[i] = type->createColumnConstWithDefaultValue(num_rows)->convertToFullColumnIfConst();\n         }\n     }\n }\ndiff --git a/src/Interpreters/inplaceBlockConversions.h b/src/Interpreters/inplaceBlockConversions.h\nindex 7a13a75ec8b8..bea44bf6db94 100644\n--- a/src/Interpreters/inplaceBlockConversions.h\n+++ b/src/Interpreters/inplaceBlockConversions.h\n@@ -46,6 +46,6 @@ void fillMissingColumns(\n     const NamesAndTypesList & requested_columns,\n     const NamesAndTypesList & available_columns,\n     const NameSet & partially_read_columns,\n-    StorageMetadataPtr metadata_snapshot, size_t block_number = 0);\n+    StorageMetadataPtr metadata_snapshot);\n \n }\ndiff --git a/src/Interpreters/processColumnTransformers.cpp b/src/Interpreters/processColumnTransformers.cpp\nindex 2a704d4a9372..5ef331eb1196 100644\n--- a/src/Interpreters/processColumnTransformers.cpp\n+++ b/src/Interpreters/processColumnTransformers.cpp\n@@ -32,7 +32,7 @@ ASTPtr processColumnTransformers(\n \n     tables_with_columns[0].addHiddenColumns(columns.getMaterialized());\n     tables_with_columns[0].addHiddenColumns(columns.getAliases());\n-    tables_with_columns[0].addHiddenColumns(table->getVirtuals());\n+    tables_with_columns[0].addHiddenColumns(table->getVirtualsList());\n \n     NameSet source_columns_set;\n     for (const auto & identifier : query_columns->children)\ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 845cf5619687..28160b182699 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -12,7 +12,7 @@\n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <IO/WriteHelpers.h>\n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n \n \n namespace DB\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\nindex 28f0f979499f..91f4213ff43b 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n@@ -431,7 +431,7 @@ AggregateProjectionCandidates getAggregateProjectionCandidates(\n {\n     const auto & keys = aggregating.getParams().keys;\n     const auto & aggregates = aggregating.getParams().aggregates;\n-    Block key_virtual_columns = reading.getMergeTreeData().getSampleBlockWithVirtualColumns();\n+    Block key_virtual_columns = reading.getMergeTreeData().getHeaderWithVirtualsForFilter();\n \n     AggregateProjectionCandidates candidates;\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\nindex 73caf70627f5..cac172a856f4 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n@@ -135,7 +135,7 @@ bool optimizeUseNormalProjections(Stack & stack, QueryPlan::Nodes & nodes)\n     std::list<NormalProjectionCandidate> candidates;\n     NormalProjectionCandidate * best_candidate = nullptr;\n \n-    const Names & required_columns = reading->getRealColumnNames();\n+    const Names & required_columns = reading->getAllColumnNames();\n     const auto & parts = reading->getParts();\n     const auto & alter_conversions = reading->getAlterConvertionsForParts();\n     const auto & query_info = reading->getQueryInfo();\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex c7b9eb72d4df..4790d0073730 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -260,30 +260,24 @@ void ReadFromMergeTree::AnalysisResult::checkLimits(const Settings & settings, c\n ReadFromMergeTree::ReadFromMergeTree(\n     MergeTreeData::DataPartsVector parts_,\n     std::vector<AlterConversionsPtr> alter_conversions_,\n-    const Names & column_names_,\n-    Names real_column_names_,\n-    Names virt_column_names_,\n+    Names all_column_names_,\n     const MergeTreeData & data_,\n     const SelectQueryInfo & query_info_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const ContextPtr & context_,\n     size_t max_block_size_,\n     size_t num_streams_,\n-    bool sample_factor_column_queried_,\n     std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read_,\n     LoggerPtr log_,\n     AnalysisResultPtr analyzed_result_ptr_,\n     bool enable_parallel_reading)\n     : SourceStepWithFilter(DataStream{.header = MergeTreeSelectProcessor::transformHeader(\n-        storage_snapshot_->getSampleBlockForColumns(real_column_names_),\n-        query_info_.prewhere_info,\n-        data_.getPartitionValueType(),\n-        virt_column_names_)}, column_names_, query_info_, storage_snapshot_, context_)\n+        storage_snapshot_->getSampleBlockForColumns(all_column_names_),\n+        query_info_.prewhere_info)}, all_column_names_, query_info_, storage_snapshot_, context_)\n     , reader_settings(getMergeTreeReaderSettings(context_, query_info_))\n     , prepared_parts(std::move(parts_))\n     , alter_conversions_for_parts(std::move(alter_conversions_))\n-    , real_column_names(std::move(real_column_names_))\n-    , virt_column_names(std::move(virt_column_names_))\n+    , all_column_names(std::move(all_column_names_))\n     , data(data_)\n     , actions_settings(ExpressionActionsSettings::fromContext(context_))\n     , metadata_for_reading(storage_snapshot->getMetadataForQuery())\n@@ -292,20 +286,11 @@ ReadFromMergeTree::ReadFromMergeTree(\n         .preferred_block_size_bytes = context->getSettingsRef().preferred_block_size_bytes,\n         .preferred_max_column_in_block_size_bytes = context->getSettingsRef().preferred_max_column_in_block_size_bytes}\n     , requested_num_streams(num_streams_)\n-    , sample_factor_column_queried(sample_factor_column_queried_)\n     , max_block_numbers_to_read(std::move(max_block_numbers_to_read_))\n     , log(std::move(log_))\n     , analyzed_result_ptr(analyzed_result_ptr_)\n     , is_parallel_reading_from_replicas(enable_parallel_reading)\n {\n-    if (sample_factor_column_queried)\n-    {\n-        /// Only _sample_factor virtual column is added by ReadFromMergeTree\n-        /// Other virtual columns are added by MergeTreeSelectProcessor.\n-        auto type = std::make_shared<DataTypeFloat64>();\n-        output_stream->header.insert({type->createColumn(), type, \"_sample_factor\"});\n-    }\n-\n     if (is_parallel_reading_from_replicas)\n     {\n         all_ranges_callback = context->getMergeTreeAllRangesCallback();\n@@ -367,12 +352,12 @@ Pipe ReadFromMergeTree::readFromPoolParallelReplicas(\n     auto pool = std::make_shared<MergeTreeReadPoolParallelReplicas>(\n         std::move(extension),\n         std::move(parts_with_range),\n+        shared_virtual_fields,\n         storage_snapshot,\n         prewhere_info,\n         actions_settings,\n         reader_settings,\n         required_columns,\n-        virt_column_names,\n         pool_settings,\n         context);\n \n@@ -386,8 +371,8 @@ Pipe ReadFromMergeTree::readFromPoolParallelReplicas(\n         auto algorithm = std::make_unique<MergeTreeThreadSelectAlgorithm>(i);\n \n         auto processor = std::make_unique<MergeTreeSelectProcessor>(\n-            pool, std::move(algorithm), data, prewhere_info,\n-            actions_settings, block_size_copy, reader_settings, virt_column_names);\n+            pool, std::move(algorithm), storage_snapshot, prewhere_info,\n+            actions_settings, block_size_copy, reader_settings);\n \n         auto source = std::make_shared<MergeTreeSource>(std::move(processor));\n         pipes.emplace_back(std::move(source));\n@@ -448,12 +433,12 @@ Pipe ReadFromMergeTree::readFromPool(\n     {\n         pool = std::make_shared<MergeTreePrefetchedReadPool>(\n             std::move(parts_with_range),\n+            shared_virtual_fields,\n             storage_snapshot,\n             prewhere_info,\n             actions_settings,\n             reader_settings,\n             required_columns,\n-            virt_column_names,\n             pool_settings,\n             context);\n     }\n@@ -461,12 +446,12 @@ Pipe ReadFromMergeTree::readFromPool(\n     {\n         pool = std::make_shared<MergeTreeReadPool>(\n             std::move(parts_with_range),\n+            shared_virtual_fields,\n             storage_snapshot,\n             prewhere_info,\n             actions_settings,\n             reader_settings,\n             required_columns,\n-            virt_column_names,\n             pool_settings,\n             context);\n     }\n@@ -485,8 +470,8 @@ Pipe ReadFromMergeTree::readFromPool(\n         auto algorithm = std::make_unique<MergeTreeThreadSelectAlgorithm>(i);\n \n         auto processor = std::make_unique<MergeTreeSelectProcessor>(\n-            pool, std::move(algorithm), data, prewhere_info,\n-            actions_settings, block_size_copy, reader_settings, virt_column_names);\n+            pool, std::move(algorithm), storage_snapshot, prewhere_info,\n+            actions_settings, block_size_copy, reader_settings);\n \n         auto source = std::make_shared<MergeTreeSource>(std::move(processor));\n \n@@ -537,12 +522,12 @@ Pipe ReadFromMergeTree::readInOrder(\n             std::move(extension),\n             mode,\n             parts_with_ranges,\n+            shared_virtual_fields,\n             storage_snapshot,\n             prewhere_info,\n             actions_settings,\n             reader_settings,\n             required_columns,\n-            virt_column_names,\n             pool_settings,\n             context);\n     }\n@@ -552,12 +537,12 @@ Pipe ReadFromMergeTree::readInOrder(\n             has_limit_below_one_block,\n             read_type,\n             parts_with_ranges,\n+            shared_virtual_fields,\n             storage_snapshot,\n             prewhere_info,\n             actions_settings,\n             reader_settings,\n             required_columns,\n-            virt_column_names,\n             pool_settings,\n             context);\n     }\n@@ -591,8 +576,8 @@ Pipe ReadFromMergeTree::readInOrder(\n             algorithm = std::make_unique<MergeTreeInOrderSelectAlgorithm>(i);\n \n         auto processor = std::make_unique<MergeTreeSelectProcessor>(\n-            pool, std::move(algorithm), data, prewhere_info,\n-            actions_settings, block_size, reader_settings, virt_column_names);\n+            pool, std::move(algorithm), storage_snapshot, prewhere_info,\n+            actions_settings, block_size, reader_settings);\n \n         processor->addPartLevelToChunk(isQueryWithFinal());\n \n@@ -1301,8 +1286,7 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToRead(\n         requested_num_streams,\n         max_block_numbers_to_read,\n         data,\n-        real_column_names,\n-        sample_factor_column_queried,\n+        all_column_names,\n         log,\n         indexes);\n }\n@@ -1469,8 +1453,7 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToRead(\n     size_t num_streams,\n     std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read,\n     const MergeTreeData & data,\n-    const Names & real_column_names,\n-    bool sample_factor_column_queried,\n+    const Names & all_column_names,\n     LoggerPtr log,\n     std::optional<Indexes> & indexes)\n {\n@@ -1483,8 +1466,7 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToRead(\n         num_streams,\n         max_block_numbers_to_read,\n         data,\n-        real_column_names,\n-        sample_factor_column_queried,\n+        all_column_names,\n         log,\n         indexes);\n }\n@@ -1498,8 +1480,7 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToReadImpl(\n     size_t num_streams,\n     std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read,\n     const MergeTreeData & data,\n-    const Names & real_column_names,\n-    bool sample_factor_column_queried,\n+    const Names & all_column_names,\n     LoggerPtr log,\n     std::optional<Indexes> & indexes)\n {\n@@ -1508,7 +1489,7 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToReadImpl(\n \n     size_t total_parts = parts.size();\n \n-    result.column_names_to_read = real_column_names;\n+    result.column_names_to_read = all_column_names;\n \n     /// If there are only virtual columns in the query, you must request at least one non-virtual one.\n     if (result.column_names_to_read.empty())\n@@ -1567,7 +1548,6 @@ ReadFromMergeTree::AnalysisResultPtr ReadFromMergeTree::selectRangesToReadImpl(\n             data,\n             metadata_snapshot,\n             context_,\n-            sample_factor_column_queried,\n             log);\n \n         if (result.sampling.read_nothing)\n@@ -1684,10 +1664,8 @@ void ReadFromMergeTree::updatePrewhereInfo(const PrewhereInfoPtr & prewhere_info\n     prewhere_info = prewhere_info_value;\n \n     output_stream = DataStream{.header = MergeTreeSelectProcessor::transformHeader(\n-        storage_snapshot->getSampleBlockForColumns(real_column_names),\n-        prewhere_info_value,\n-        data.getPartitionValueType(),\n-        virt_column_names)};\n+        storage_snapshot->getSampleBlockForColumns(all_column_names),\n+        prewhere_info_value)};\n \n     updateSortDescriptionForOutputStream(\n         *output_stream,\n@@ -1881,6 +1859,7 @@ void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder & pipeline, cons\n     storage_snapshot->data = std::make_unique<MergeTreeData::SnapshotData>();\n \n     result.checkLimits(context->getSettingsRef(), query_info);\n+    shared_virtual_fields.emplace(\"_sample_factor\", result.sampling.used_sample_factor);\n \n     LOG_DEBUG(\n         log,\n@@ -1965,18 +1944,6 @@ void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder & pipeline, cons\n             result_projection = ActionsDAG::merge(std::move(*result_projection), std::move(*actions));\n     };\n \n-    /// By the way, if a distributed query or query to a Merge table is made, then the `_sample_factor` column can have different values.\n-    if (sample_factor_column_queried)\n-    {\n-        ColumnWithTypeAndName column;\n-        column.name = \"_sample_factor\";\n-        column.type = std::make_shared<DataTypeFloat64>();\n-        column.column = column.type->createColumnConst(0, Field(result.sampling.used_sample_factor));\n-\n-        auto adding_column = ActionsDAG::makeAddingColumnActions(std::move(column));\n-        append_actions(std::move(adding_column));\n-    }\n-\n     if (result_projection)\n         cur_header = result_projection->updateHeader(cur_header);\n \ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h\nindex 8efe5ed7b130..5ed742a9bfdd 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.h\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h\n@@ -110,16 +110,13 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n     ReadFromMergeTree(\n         MergeTreeData::DataPartsVector parts_,\n         std::vector<AlterConversionsPtr> alter_conversions_,\n-        const Names & column_names_,\n-        Names real_column_names_,\n-        Names virt_column_names_,\n+        Names all_column_names_,\n         const MergeTreeData & data_,\n         const SelectQueryInfo & query_info_,\n         const StorageSnapshotPtr & storage_snapshot,\n         const ContextPtr & context_,\n         size_t max_block_size_,\n         size_t num_streams_,\n-        bool sample_factor_column_queried_,\n         std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read_,\n         LoggerPtr log_,\n         AnalysisResultPtr analyzed_result_ptr_,\n@@ -136,8 +133,7 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n     void describeActions(JSONBuilder::JSONMap & map) const override;\n     void describeIndexes(JSONBuilder::JSONMap & map) const override;\n \n-    const Names & getRealColumnNames() const { return real_column_names; }\n-    const Names & getVirtualColumnNames() const { return virt_column_names; }\n+    const Names & getAllColumnNames() const { return all_column_names; }\n \n     StorageID getStorageID() const { return data.getStorageID(); }\n     UInt64 getSelectedParts() const { return selected_parts; }\n@@ -164,8 +160,7 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n         size_t num_streams,\n         std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read,\n         const MergeTreeData & data,\n-        const Names & real_column_names,\n-        bool sample_factor_column_queried,\n+        const Names & all_column_names,\n         LoggerPtr log,\n         std::optional<Indexes> & indexes);\n \n@@ -209,8 +204,7 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n         size_t num_streams,\n         std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read,\n         const MergeTreeData & data,\n-        const Names & real_column_names,\n-        bool sample_factor_column_queried,\n+        const Names & all_column_names,\n         LoggerPtr log,\n         std::optional<Indexes> & indexes);\n \n@@ -227,8 +221,7 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n     MergeTreeData::DataPartsVector prepared_parts;\n     std::vector<AlterConversionsPtr> alter_conversions_for_parts;\n \n-    Names real_column_names;\n-    Names virt_column_names;\n+    Names all_column_names;\n \n     const MergeTreeData & data;\n     ExpressionActionsSettings actions_settings;\n@@ -239,7 +232,6 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n \n     size_t requested_num_streams;\n     size_t output_streams_limit = 0;\n-    const bool sample_factor_column_queried;\n \n     /// Used for aggregation optimization (see DB::QueryPlanOptimizations::tryAggregateEachPartitionIndependently).\n     bool output_each_partition_through_separate_port = false;\n@@ -280,7 +272,9 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n         RangesInDataParts && parts, size_t num_streams, const Names & origin_column_names, const Names & column_names, ActionsDAGPtr & out_projection);\n \n     ReadFromMergeTree::AnalysisResult getAnalysisResult() const;\n+\n     AnalysisResultPtr analyzed_result_ptr;\n+    VirtualFields shared_virtual_fields;\n \n     bool is_parallel_reading_from_replicas;\n     std::optional<MergeTreeAllRangesCallback> all_ranges_callback;\ndiff --git a/src/Processors/Transforms/buildPushingToViewsChain.cpp b/src/Processors/Transforms/buildPushingToViewsChain.cpp\nindex dd07d043599b..aa5a1c0cc1a0 100644\n--- a/src/Processors/Transforms/buildPushingToViewsChain.cpp\n+++ b/src/Processors/Transforms/buildPushingToViewsChain.cpp\n@@ -451,7 +451,7 @@ Chain buildPushingToViewsChain(\n \n     /// If we don't write directly to the destination\n     /// then expect that we're inserting with precalculated virtual columns\n-    auto storage_header = no_destination ? metadata_snapshot->getSampleBlockWithVirtuals(storage->getVirtuals())\n+    auto storage_header = no_destination ? metadata_snapshot->getSampleBlockWithVirtuals(storage->getVirtualsList())\n                                          : metadata_snapshot->getSampleBlock();\n \n     /** TODO This is a very important line. At any insertion into the table one of chains should own lock.\n@@ -597,7 +597,7 @@ static QueryPipeline process(Block block, ViewRuntimeData & view, const ViewsDat\n         views_data.source_storage_id,\n         views_data.source_metadata_snapshot->getColumns(),\n         std::move(block),\n-        views_data.source_storage->getVirtuals()));\n+        *views_data.source_storage->getVirtualsPtr()));\n \n     QueryPipelineBuilder pipeline;\n \ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex b09200f06ff9..eae5e1a8a478 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -31,8 +31,6 @@\n #include <Parsers/queryToString.h>\n #include <Storages/AlterCommands.h>\n #include <Storages/IStorage.h>\n-#include <Storages/LightweightDeleteDescription.h>\n-#include <Storages/BlockNumberColumn.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Common/typeid_cast.h>\n #include <Common/randomSeed.h>\n@@ -965,8 +963,7 @@ bool AlterCommand::isRequireMutationStage(const StorageInMemoryMetadata & metada\n \n     /// Drop alias is metadata alter, in other case mutation is required.\n     if (type == DROP_COLUMN)\n-        return metadata.columns.hasColumnOrNested(GetColumnsOptions::AllPhysical, column_name) ||\n-            column_name == LightweightDeleteDescription::FILTER_COLUMN.name || column_name == BlockNumberColumn::name;\n+        return metadata.columns.hasColumnOrNested(GetColumnsOptions::AllPhysical, column_name);\n \n     if (type != MODIFY_COLUMN || data_type == nullptr)\n         return false;\n@@ -1256,7 +1253,9 @@ void AlterCommands::prepare(const StorageInMemoryMetadata & metadata)\n \n void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n {\n-    const StorageInMemoryMetadata & metadata = table->getInMemoryMetadata();\n+    const auto & metadata = table->getInMemoryMetadata();\n+    auto virtuals = table->getVirtualsPtr();\n+\n     auto all_columns = metadata.columns;\n     /// Default expression for all added/modified columns\n     ASTPtr default_expr_list = std::make_shared<ASTExpressionList>();\n@@ -1292,16 +1291,20 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n             if (command.data_type->hasDynamicSubcolumns())\n                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Adding a new column of a type which has dynamic subcolumns to an existing table is not allowed. It has known bugs\");\n \n-            if (column_name == LightweightDeleteDescription::FILTER_COLUMN.name && std::dynamic_pointer_cast<MergeTreeData>(table))\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot add column {}: \"\n-                                \"this column name is reserved for lightweight delete feature\", backQuote(column_name));\n-\n-            if (column_name == BlockNumberColumn::name && std::dynamic_pointer_cast<MergeTreeData>(table))\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot add column {}: \"\n-                                                            \"this column name is reserved for _block_number persisting feature\", backQuote(column_name));\n+            if (virtuals->tryGet(column_name, VirtualsKind::Persistent))\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                    \"Cannot add column {}: this column name is reserved for persistent virtual column\", backQuote(column_name));\n \n             if (command.codec)\n-                CompressionCodecFactory::instance().validateCodecAndGetPreprocessedAST(command.codec, command.data_type, !context->getSettingsRef().allow_suspicious_codecs, context->getSettingsRef().allow_experimental_codecs, context->getSettingsRef().enable_deflate_qpl_codec, context->getSettingsRef().enable_zstd_qat_codec);\n+            {\n+                const auto & settings = context->getSettingsRef();\n+                CompressionCodecFactory::instance().validateCodecAndGetPreprocessedAST(\n+                    command.codec, command.data_type,\n+                    !settings.allow_suspicious_codecs,\n+                    settings.allow_experimental_codecs,\n+                    settings.enable_deflate_qpl_codec,\n+                    settings.enable_zstd_qat_codec);\n+            }\n \n             all_columns.add(ColumnDescription(column_name, command.data_type));\n         }\n@@ -1415,9 +1418,7 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n         }\n         else if (command.type == AlterCommand::DROP_COLUMN)\n         {\n-            if (all_columns.has(command.column_name) ||\n-                all_columns.hasNested(command.column_name) ||\n-                (command.clear && column_name == LightweightDeleteDescription::FILTER_COLUMN.name))\n+            if (all_columns.has(command.column_name) || all_columns.hasNested(command.column_name))\n             {\n                 if (!command.clear) /// CLEAR column is Ok even if there are dependencies.\n                 {\n@@ -1501,16 +1502,12 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n             }\n \n             if (all_columns.has(command.rename_to))\n-                throw Exception(ErrorCodes::DUPLICATE_COLUMN, \"Cannot rename to {}: \"\n-                                \"column with this name already exists\", backQuote(command.rename_to));\n-\n-            if (command.rename_to == LightweightDeleteDescription::FILTER_COLUMN.name && std::dynamic_pointer_cast<MergeTreeData>(table))\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot rename to {}: \"\n-                                \"this column name is reserved for lightweight delete feature\", backQuote(command.rename_to));\n+                throw Exception(ErrorCodes::DUPLICATE_COLUMN,\n+                    \"Cannot rename to {}: column with this name already exists\", backQuote(command.rename_to));\n \n-            if (command.rename_to == BlockNumberColumn::name && std::dynamic_pointer_cast<MergeTreeData>(table))\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot rename to {}: \"\n-                                                            \"this column name is reserved for _block_number persisting feature\", backQuote(command.rename_to));\n+            if (virtuals->tryGet(command.rename_to, VirtualsKind::Persistent))\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                    \"Cannot rename to {}: this column name is reserved for persistent virtual column\", backQuote(command.rename_to));\n \n             if (modified_columns.contains(column_name))\n                 throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot rename and modify the same column {} \"\ndiff --git a/src/Storages/BlockNumberColumn.cpp b/src/Storages/BlockNumberColumn.cpp\ndeleted file mode 100644\nindex 8c9e1fd902af..000000000000\n--- a/src/Storages/BlockNumberColumn.cpp\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-#include <Storages/BlockNumberColumn.h>\n-#include <Compression/CompressionCodecMultiple.h>\n-\n-namespace DB\n-{\n-\n-CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n-\n-CompressionCodecPtr getCompressionCodecForBlockNumberColumn()\n-{\n-    std::vector <CompressionCodecPtr> codecs;\n-    codecs.reserve(2);\n-    auto data_bytes_size = BlockNumberColumn::type->getSizeOfValueInMemory();\n-    codecs.emplace_back(getCompressionCodecDelta(data_bytes_size));\n-    codecs.emplace_back(CompressionCodecFactory::instance().get(\"LZ4\", {}));\n-    return std::make_shared<CompressionCodecMultiple>(codecs);\n-}\n-\n-const String BlockNumberColumn::name = \"_block_number\";\n-const DataTypePtr BlockNumberColumn::type = std::make_shared<DataTypeUInt64>();\n-const CompressionCodecPtr BlockNumberColumn::compression_codec = getCompressionCodecForBlockNumberColumn();\n-\n-}\ndiff --git a/src/Storages/BlockNumberColumn.h b/src/Storages/BlockNumberColumn.h\ndeleted file mode 100644\nindex fffa68bfd499..000000000000\n--- a/src/Storages/BlockNumberColumn.h\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-#pragma once\n-#include <Core/NamesAndTypes.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <Compression/CompressionFactory.h>\n-\n-namespace DB\n-{\n-\n-struct BlockNumberColumn\n-{\n-    static const String name;\n-    static const DataTypePtr type;\n-    static const CompressionCodecPtr compression_codec;\n-};\n-\n-}\ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex d6a241da0324..e08dac3a332b 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -31,15 +31,11 @@\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n-#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n {\n \n-CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n-\n-\n namespace ErrorCodes\n {\n     extern const int NO_SUCH_COLUMN_IN_TABLE;\n@@ -482,6 +478,10 @@ NamesAndTypesList ColumnsDescription::get(const GetColumnsOptions & options) con\n     NamesAndTypesList res;\n     switch (options.kind)\n     {\n+        case GetColumnsOptions::None:\n+        {\n+            break;\n+        }\n         case GetColumnsOptions::All:\n         {\n             res = getAll();\n@@ -559,6 +559,12 @@ const ColumnDescription & ColumnsDescription::get(const String & column_name) co\n     return *it;\n }\n \n+const ColumnDescription * ColumnsDescription::tryGet(const String & column_name) const\n+{\n+    auto it = columns.get<1>().find(column_name);\n+    return it == columns.get<1>().end() ? nullptr : &(*it);\n+}\n+\n static GetColumnsOptions::Kind defaultKindToGetKind(ColumnDefaultKind kind)\n {\n     switch (kind)\n@@ -572,7 +578,8 @@ static GetColumnsOptions::Kind defaultKindToGetKind(ColumnDefaultKind kind)\n         case ColumnDefaultKind::Ephemeral:\n             return GetColumnsOptions::Ephemeral;\n     }\n-    UNREACHABLE();\n+\n+    return GetColumnsOptions::None;\n }\n \n NamesAndTypesList ColumnsDescription::getByNames(const GetColumnsOptions & options, const Names & names) const\n@@ -784,33 +791,6 @@ bool ColumnsDescription::hasCompressionCodec(const String & column_name) const\n     return it != columns.get<1>().end() && it->codec != nullptr;\n }\n \n-CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n-{\n-    const auto it = columns.get<1>().find(column_name);\n-\n-    if (it == columns.get<1>().end() || !it->codec)\n-        return default_codec;\n-\n-    return CompressionCodecFactory::instance().get(it->codec, it->type, default_codec);\n-}\n-\n-CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_name) const\n-{\n-    assert (column_name != BlockNumberColumn::name);\n-    return getCodecOrDefault(column_name, CompressionCodecFactory::instance().getDefaultCodec());\n-}\n-\n-ASTPtr ColumnsDescription::getCodecDescOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n-{\n-    assert (column_name != BlockNumberColumn::name);\n-    const auto it = columns.get<1>().find(column_name);\n-\n-    if (it == columns.get<1>().end() || !it->codec)\n-        return default_codec->getFullCodecDesc();\n-\n-    return it->codec;\n-}\n-\n ColumnsDescription::ColumnTTLs ColumnsDescription::getColumnTTLs() const\n {\n     ColumnTTLs ret;\ndiff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h\nindex 5ba655ee10d8..82e55e29073e 100644\n--- a/src/Storages/ColumnsDescription.h\n+++ b/src/Storages/ColumnsDescription.h\n@@ -29,10 +29,19 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+enum class VirtualsKind : UInt8\n+{\n+    None = 0,\n+    Ephemeral = 1,\n+    Persistent = 2,\n+    All = Ephemeral | Persistent,\n+};\n+\n struct GetColumnsOptions\n {\n     enum Kind : UInt8\n     {\n+        None = 0,\n         Ordinary = 1,\n         Materialized = 2,\n         Aliases = 4,\n@@ -51,9 +60,9 @@ struct GetColumnsOptions\n         return *this;\n     }\n \n-    GetColumnsOptions & withVirtuals(bool value = true)\n+    GetColumnsOptions & withVirtuals(VirtualsKind value = VirtualsKind::All)\n     {\n-        with_virtuals = value;\n+        virtuals_kind = value;\n         return *this;\n     }\n \n@@ -63,17 +72,11 @@ struct GetColumnsOptions\n         return *this;\n     }\n \n-    GetColumnsOptions & withSystemColumns(bool value = true)\n-    {\n-        with_system_columns = value;\n-        return *this;\n-    }\n-\n     Kind kind;\n+    VirtualsKind virtuals_kind = VirtualsKind::None;\n+\n     bool with_subcolumns = false;\n-    bool with_virtuals = false;\n     bool with_extended_objects = false;\n-    bool with_system_columns = false;\n };\n \n /// Description of a single table column (in CREATE TABLE for example).\n@@ -160,6 +163,7 @@ class ColumnsDescription : public IHints<>\n     bool hasNested(const String & column_name) const;\n     bool hasSubcolumn(const String & column_name) const;\n     const ColumnDescription & get(const String & column_name) const;\n+    const ColumnDescription * tryGet(const String & column_name) const;\n \n     template <typename F>\n     void modify(const String & column_name, F && f)\n@@ -213,9 +217,6 @@ class ColumnsDescription : public IHints<>\n \n     /// Does column has non default specified compression codec\n     bool hasCompressionCodec(const String & column_name) const;\n-    CompressionCodecPtr getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const;\n-    CompressionCodecPtr getCodecOrDefault(const String & column_name) const;\n-    ASTPtr getCodecDescOrDefault(const String & column_name, CompressionCodecPtr default_codec) const;\n \n     String toString() const;\n     static ColumnsDescription parse(const String & str);\n@@ -269,4 +270,5 @@ class ColumnsDescription : public IHints<>\n /// don't have strange constructions in default expression like SELECT query or\n /// arrayJoin function.\n Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context);\n+\n }\ndiff --git a/src/Storages/FileLog/FileLogSource.cpp b/src/Storages/FileLog/FileLogSource.cpp\nindex b1192af4ced6..eb3ff0436a51 100644\n--- a/src/Storages/FileLog/FileLogSource.cpp\n+++ b/src/Storages/FileLog/FileLogSource.cpp\n@@ -31,7 +31,7 @@ FileLogSource::FileLogSource(\n     , max_streams_number(max_streams_number_)\n     , handle_error_mode(handle_error_mode_)\n     , non_virtual_header(storage_snapshot->metadata->getSampleBlockNonMaterialized())\n-    , virtual_header(storage_snapshot->getSampleBlockForColumns(storage.getVirtuals().getNames()))\n+    , virtual_header(storage_snapshot->virtual_columns->getSampleBlock())\n {\n     consumer = std::make_unique<FileLogConsumer>(storage, max_block_size, poll_time_out, context, stream_number_, max_streams_number_);\n \ndiff --git a/src/Storages/FileLog/StorageFileLog.cpp b/src/Storages/FileLog/StorageFileLog.cpp\nindex b0bac081d384..a5f2331a0680 100644\n--- a/src/Storages/FileLog/StorageFileLog.cpp\n+++ b/src/Storages/FileLog/StorageFileLog.cpp\n@@ -147,6 +147,7 @@ StorageFileLog::StorageFileLog(\n     storage_metadata.setColumns(columns_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals(filelog_settings->handle_error_mode));\n \n     if (!fileOrSymlinkPathStartsWith(path, getContext()->getUserFilesPath()))\n     {\n@@ -203,6 +204,22 @@ StorageFileLog::StorageFileLog(\n     }\n }\n \n+VirtualColumnsDescription StorageFileLog::createVirtuals(StreamingHandleErrorMode handle_error_mode)\n+{\n+    VirtualColumnsDescription desc;\n+\n+    desc.addEphemeral(\"_filename\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"\");\n+    desc.addEphemeral(\"_offset\", std::make_shared<DataTypeUInt64>(), \"\");\n+\n+    if (handle_error_mode == StreamingHandleErrorMode::STREAM)\n+    {\n+        desc.addEphemeral(\"_raw_record\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+        desc.addEphemeral(\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+    }\n+\n+    return desc;\n+}\n+\n void StorageFileLog::loadMetaFiles(bool attach)\n {\n     /// Attach table\n@@ -1009,19 +1026,4 @@ bool StorageFileLog::updateFileInfos()\n     return events.empty() || file_infos.file_names.empty();\n }\n \n-NamesAndTypesList StorageFileLog::getVirtuals() const\n-{\n-    auto virtuals = NamesAndTypesList{\n-        {\"_filename\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_offset\", std::make_shared<DataTypeUInt64>()}};\n-\n-    if (filelog_settings->handle_error_mode == StreamingHandleErrorMode::STREAM)\n-    {\n-        virtuals.push_back({\"_raw_record\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-        virtuals.push_back({\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-    }\n-\n-    return virtuals;\n-}\n-\n }\ndiff --git a/src/Storages/FileLog/StorageFileLog.h b/src/Storages/FileLog/StorageFileLog.h\nindex bdcf85ad6e57..91d58540c943 100644\n--- a/src/Storages/FileLog/StorageFileLog.h\n+++ b/src/Storages/FileLog/StorageFileLog.h\n@@ -102,8 +102,6 @@ class StorageFileLog final : public IStorage, WithContext\n     String getFullMetaPath(const String & file_name) const { return std::filesystem::path(metadata_base_path) / file_name; }\n     String getFullDataPath(const String & file_name) const { return std::filesystem::path(root_data_path) / file_name; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     static UInt64 getInode(const String & file_name);\n \n     void openFilesAndSetPos();\n@@ -212,6 +210,8 @@ class StorageFileLog final : public IStorage, WithContext\n         UInt64 inode = 0;\n     };\n     ReadMetadataResult readMetadata(const String & filename) const;\n+\n+    static VirtualColumnsDescription createVirtuals(StreamingHandleErrorMode handle_error_mode);\n };\n \n }\ndiff --git a/src/Storages/HDFS/StorageHDFS.cpp b/src/Storages/HDFS/StorageHDFS.cpp\nindex cd935fa31002..c574f57fc6a2 100644\n--- a/src/Storages/HDFS/StorageHDFS.cpp\n+++ b/src/Storages/HDFS/StorageHDFS.cpp\n@@ -241,8 +241,7 @@ StorageHDFS::StorageHDFS(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n namespace\n@@ -975,7 +974,7 @@ void StorageHDFS::read(\n     size_t max_block_size,\n     size_t num_streams)\n {\n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(context_), virtual_columns);\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(context_));\n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && context_->getSettingsRef().optimize_count_from_files;\n \n@@ -1011,7 +1010,7 @@ void ReadFromHDFS::createIterator(const ActionsDAG::Node * predicate)\n     else if (storage->is_path_with_globs)\n     {\n         /// Iterate through disclosed globs and make a source for each file\n-        auto glob_iterator = std::make_shared<HDFSSource::DisclosedGlobIterator>(storage->uris[0], predicate, storage->virtual_columns, context);\n+        auto glob_iterator = std::make_shared<HDFSSource::DisclosedGlobIterator>(storage->uris[0], predicate, storage->getVirtualsList(), context);\n         iterator_wrapper = std::make_shared<HDFSSource::IteratorWrapper>([glob_iterator]()\n         {\n             return glob_iterator->next();\n@@ -1019,7 +1018,7 @@ void ReadFromHDFS::createIterator(const ActionsDAG::Node * predicate)\n     }\n     else\n     {\n-        auto uris_iterator = std::make_shared<HDFSSource::URISIterator>(storage->uris, predicate, storage->virtual_columns, context);\n+        auto uris_iterator = std::make_shared<HDFSSource::URISIterator>(storage->uris, predicate, storage->getVirtualsList(), context);\n         iterator_wrapper = std::make_shared<HDFSSource::IteratorWrapper>([uris_iterator]()\n         {\n             return uris_iterator->next();\n@@ -1179,16 +1178,6 @@ void registerStorageHDFS(StorageFactory & factory)\n     });\n }\n \n-NamesAndTypesList StorageHDFS::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-Names StorageHDFS::getVirtualColumnNames()\n-{\n-    return VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage({}).getNames();\n-}\n-\n SchemaCache & StorageHDFS::getSchemaCache(const ContextPtr & ctx)\n {\n     static SchemaCache schema_cache(ctx->getConfigRef().getUInt(\"schema_inference_cache_max_elements_for_hdfs\", DEFAULT_SCHEMA_CACHE_ELEMENTS));\ndiff --git a/src/Storages/HDFS/StorageHDFS.h b/src/Storages/HDFS/StorageHDFS.h\nindex b36ff7ea37eb..47e5addccb49 100644\n--- a/src/Storages/HDFS/StorageHDFS.h\n+++ b/src/Storages/HDFS/StorageHDFS.h\n@@ -69,9 +69,6 @@ class StorageHDFS final : public IStorage, WithContext\n         ContextPtr local_context,\n         TableExclusiveLockHolder &) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-    static Names getVirtualColumnNames();\n-\n     bool supportsPartitionBy() const override { return true; }\n \n     /// Check if the format is column-oriented.\n@@ -114,7 +111,6 @@ class StorageHDFS final : public IStorage, WithContext\n     const bool distributed_processing;\n     ASTPtr partition_by;\n     bool is_path_with_globs;\n-    NamesAndTypesList virtual_columns;\n \n     LoggerPtr log = getLogger(\"StorageHDFS\");\n };\ndiff --git a/src/Storages/HDFS/StorageHDFSCluster.cpp b/src/Storages/HDFS/StorageHDFSCluster.cpp\nindex 714d63915438..bde8b84e3497 100644\n--- a/src/Storages/HDFS/StorageHDFSCluster.cpp\n+++ b/src/Storages/HDFS/StorageHDFSCluster.cpp\n@@ -72,8 +72,7 @@ StorageHDFSCluster::StorageHDFSCluster(\n \n     storage_metadata.setConstraints(constraints_);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageHDFSCluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const DB::StorageSnapshotPtr & storage_snapshot, const DB::ContextPtr & context)\n@@ -89,18 +88,11 @@ void StorageHDFSCluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const DB:\n \n RemoteQueryExecutor::Extension StorageHDFSCluster::getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const\n {\n-    auto iterator = std::make_shared<HDFSSource::DisclosedGlobIterator>(uri, predicate, virtual_columns, context);\n+    auto iterator = std::make_shared<HDFSSource::DisclosedGlobIterator>(uri, predicate, getVirtualsList(), context);\n     auto callback = std::make_shared<std::function<String()>>([iter = std::move(iterator)]() mutable -> String { return iter->next().path; });\n     return RemoteQueryExecutor::Extension{.task_iterator = std::move(callback)};\n }\n \n-NamesAndTypesList StorageHDFSCluster::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        {\"_path\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_file\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())}};\n-}\n-\n }\n \n #endif\ndiff --git a/src/Storages/HDFS/StorageHDFSCluster.h b/src/Storages/HDFS/StorageHDFSCluster.h\nindex 40884f989846..26ebc8601ee5 100644\n--- a/src/Storages/HDFS/StorageHDFSCluster.h\n+++ b/src/Storages/HDFS/StorageHDFSCluster.h\n@@ -32,8 +32,6 @@ class StorageHDFSCluster : public IStorageCluster\n \n     std::string getName() const override { return \"HDFSCluster\"; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -45,7 +43,6 @@ class StorageHDFSCluster : public IStorageCluster\n \n     String uri;\n     String format_name;\n-    NamesAndTypesList virtual_columns;\n };\n \n \ndiff --git a/src/Storages/Hive/StorageHive.cpp b/src/Storages/Hive/StorageHive.cpp\nindex 183a4532281f..88ab8e15e767 100644\n--- a/src/Storages/Hive/StorageHive.cpp\n+++ b/src/Storages/Hive/StorageHive.cpp\n@@ -45,6 +45,7 @@\n #include <Storages/MergeTree/KeyCondition.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n+#include <Storages/VirtualColumnUtils.h>\n \n namespace CurrentMetrics\n {\n@@ -444,6 +445,7 @@ StorageHive::StorageHive(\n     storage_metadata.partition_key = KeyDescription::getKeyFromAST(partition_by_ast, storage_metadata.columns, getContext());\n \n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageHive::lazyInitialize()\n@@ -1020,13 +1022,6 @@ SinkToStoragePtr StorageHive::write(const ASTPtr & /*query*/, const StorageMetad\n     throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Method write is not implemented for StorageHive\");\n }\n \n-NamesAndTypesList StorageHive::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        {\"_path\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_file\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())}};\n-}\n-\n std::optional<UInt64> StorageHive::totalRows(const Settings & settings) const\n {\n     /// query_info is not used when prune_level == PruneLevel::None\ndiff --git a/src/Storages/Hive/StorageHive.h b/src/Storages/Hive/StorageHive.h\nindex 07440097f7a2..67ef153af0e4 100644\n--- a/src/Storages/Hive/StorageHive.h\n+++ b/src/Storages/Hive/StorageHive.h\n@@ -54,8 +54,6 @@ class StorageHive final : public IStorage, WithContext\n \n     SinkToStoragePtr write(const ASTPtr & /*query*/, const StorageMetadataPtr & metadata_snapshot, ContextPtr /*context*/, bool async_insert) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     bool supportsSubsetOfColumns() const;\n \n     std::optional<UInt64> totalRows(const Settings & settings) const override;\ndiff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp\nindex 85ef6a0bb350..9852220241f7 100644\n--- a/src/Storages/IStorage.cpp\n+++ b/src/Storages/IStorage.cpp\n@@ -27,10 +27,17 @@ namespace ErrorCodes\n     extern const int CANNOT_RESTORE_TABLE;\n }\n \n+IStorage::IStorage(StorageID storage_id_)\n+    : storage_id(std::move(storage_id_))\n+    , metadata(std::make_unique<StorageInMemoryMetadata>())\n+    , virtuals(std::make_unique<VirtualColumnsDescription>())\n+{\n+}\n+\n bool IStorage::isVirtualColumn(const String & column_name, const StorageMetadataPtr & metadata_snapshot) const\n {\n     /// Virtual column maybe overridden by real column\n-    return !metadata_snapshot->getColumns().has(column_name) && getVirtuals().contains(column_name);\n+    return !metadata_snapshot->getColumns().has(column_name) && virtuals.get()->has(column_name);\n }\n \n RWLockImpl::LockHolder IStorage::tryLockTimed(\n@@ -237,11 +244,6 @@ void IStorage::renameInMemory(const StorageID & new_table_id)\n     storage_id = new_table_id;\n }\n \n-NamesAndTypesList IStorage::getVirtuals() const\n-{\n-    return {};\n-}\n-\n Names IStorage::getAllRegisteredNames() const\n {\n     Names result;\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 4fa6bfdd6178..1108eafc6b67 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -11,6 +11,7 @@\n #include <Storages/IStorage_fwd.h>\n #include <Storages/SelectQueryDescription.h>\n #include <Storages/StorageInMemoryMetadata.h>\n+#include <Storages/VirtualColumnsDescription.h>\n #include <Storages/TableLockHolder.h>\n #include <Storages/StorageSnapshot.h>\n #include <Common/ActionLock.h>\n@@ -98,9 +99,7 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n public:\n     IStorage() = delete;\n     /// Storage metadata can be set separately in setInMemoryMetadata method\n-    explicit IStorage(StorageID storage_id_)\n-        : storage_id(std::move(storage_id_))\n-        , metadata(std::make_unique<StorageInMemoryMetadata>()) {}\n+    explicit IStorage(StorageID storage_id_);\n \n     IStorage(const IStorage &) = delete;\n     IStorage & operator=(const IStorage &) = delete;\n@@ -215,6 +214,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n         metadata.set(std::make_unique<StorageInMemoryMetadata>(metadata_));\n     }\n \n+    void setVirtuals(VirtualColumnsDescription virtuals_)\n+    {\n+        virtuals.set(std::make_unique<VirtualColumnsDescription>(std::move(virtuals_)));\n+    }\n \n     /// Return list of virtual columns (like _part, _table, etc). In the vast\n     /// majority of cases virtual columns are static constant part of Storage\n@@ -226,7 +229,9 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     /// virtual column will be overridden and inaccessible.\n     ///\n     /// By default return empty list of columns.\n-    virtual NamesAndTypesList getVirtuals() const;\n+    VirtualsDescriptionPtr getVirtualsPtr() const { return virtuals.get(); }\n+    NamesAndTypesList getVirtualsList() const { return virtuals.get()->getNamesAndTypesList(); }\n+    Block getVirtualsHeader() const { return virtuals.get()->getSampleBlock(); }\n \n     Names getAllRegisteredNames() const override;\n \n@@ -263,15 +268,16 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     virtual bool supportsTrivialCountOptimization() const { return false; }\n \n private:\n-\n     StorageID storage_id;\n \n     mutable std::mutex id_mutex;\n \n-    /// Multiversion storage metadata. Allows to read/write storage metadata\n-    /// without locks.\n+    /// Multiversion storage metadata. Allows to read/write storage metadata without locks.\n     MultiVersionStorageMetadataPtr metadata;\n \n+    /// Description of virtual columns. Optional, may be set in constructor.\n+    MultiVersionVirtualsDescriptionPtr virtuals;\n+\n protected:\n     RWLockImpl::LockHolder tryLockTimed(\n         const RWLock & rwlock, RWLockImpl::Type type, const String & query_id, const std::chrono::milliseconds & acquire_timeout) const;\ndiff --git a/src/Storages/Kafka/KafkaSource.cpp b/src/Storages/Kafka/KafkaSource.cpp\nindex dc62c13f6332..9c68107872ef 100644\n--- a/src/Storages/Kafka/KafkaSource.cpp\n+++ b/src/Storages/Kafka/KafkaSource.cpp\n@@ -45,7 +45,7 @@ KafkaSource::KafkaSource(\n     , max_block_size(max_block_size_)\n     , commit_in_suffix(commit_in_suffix_)\n     , non_virtual_header(storage_snapshot->metadata->getSampleBlockNonMaterialized())\n-    , virtual_header(storage_snapshot->getSampleBlockForColumns(storage.getVirtualColumnNames()))\n+    , virtual_header(storage.getVirtualsHeader())\n     , handle_error_mode(storage.getStreamingHandleErrorMode())\n {\n }\ndiff --git a/src/Storages/Kafka/StorageKafka.cpp b/src/Storages/Kafka/StorageKafka.cpp\nindex 638f5fe2ef66..e41488189e9a 100644\n--- a/src/Storages/Kafka/StorageKafka.cpp\n+++ b/src/Storages/Kafka/StorageKafka.cpp\n@@ -363,6 +363,8 @@ StorageKafka::StorageKafka(\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals(kafka_settings->kafka_handle_error_mode));\n+\n     auto task_count = thread_per_consumer ? num_consumers : 1;\n     for (size_t i = 0; i < task_count; ++i)\n     {\n@@ -384,6 +386,28 @@ StorageKafka::StorageKafka(\n     });\n }\n \n+VirtualColumnsDescription StorageKafka::createVirtuals(StreamingHandleErrorMode handle_error_mode)\n+{\n+    VirtualColumnsDescription desc;\n+\n+    desc.addEphemeral(\"_topic\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"\");\n+    desc.addEphemeral(\"_key\", std::make_shared<DataTypeString>(), \"\");\n+    desc.addEphemeral(\"_offset\", std::make_shared<DataTypeUInt64>(), \"\");\n+    desc.addEphemeral(\"_partition\", std::make_shared<DataTypeUInt64>(), \"\");\n+    desc.addEphemeral(\"_timestamp\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeDateTime>()), \"\");\n+    desc.addEphemeral(\"_timestamp_ms\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeDateTime64>(3)), \"\");\n+    desc.addEphemeral(\"_headers.name\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>()), \"\");\n+    desc.addEphemeral(\"_headers.value\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>()), \"\");\n+\n+    if (handle_error_mode == StreamingHandleErrorMode::STREAM)\n+    {\n+        desc.addEphemeral(\"_raw_message\", std::make_shared<DataTypeString>(), \"\");\n+        desc.addEphemeral(\"_error\", std::make_shared<DataTypeString>(), \"\");\n+    }\n+\n+    return desc;\n+}\n+\n SettingsChanges StorageKafka::createSettingsAdjustments()\n {\n     SettingsChanges result;\n@@ -1194,43 +1218,4 @@ void registerStorageKafka(StorageFactory & factory)\n     factory.registerStorage(\"Kafka\", creator_fn, StorageFactory::StorageFeatures{ .supports_settings = true, });\n }\n \n-NamesAndTypesList StorageKafka::getVirtuals() const\n-{\n-    auto result = NamesAndTypesList{\n-        {\"_topic\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_key\", std::make_shared<DataTypeString>()},\n-        {\"_offset\", std::make_shared<DataTypeUInt64>()},\n-        {\"_partition\", std::make_shared<DataTypeUInt64>()},\n-        {\"_timestamp\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeDateTime>())},\n-        {\"_timestamp_ms\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeDateTime64>(3))},\n-        {\"_headers.name\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())},\n-        {\"_headers.value\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())}};\n-    if (kafka_settings->kafka_handle_error_mode == StreamingHandleErrorMode::STREAM)\n-    {\n-        result.push_back({\"_raw_message\", std::make_shared<DataTypeString>()});\n-        result.push_back({\"_error\", std::make_shared<DataTypeString>()});\n-    }\n-    return result;\n-}\n-\n-Names StorageKafka::getVirtualColumnNames() const\n-{\n-    auto result = Names {\n-        \"_topic\",\n-        \"_key\",\n-        \"_offset\",\n-        \"_partition\",\n-        \"_timestamp\",\n-        \"_timestamp_ms\",\n-        \"_headers.name\",\n-        \"_headers.value\",\n-    };\n-    if (kafka_settings->kafka_handle_error_mode == StreamingHandleErrorMode::STREAM)\n-    {\n-        result.push_back({\"_raw_message\"});\n-        result.push_back({\"_error\"});\n-    }\n-    return result;\n-}\n-\n }\ndiff --git a/src/Storages/Kafka/StorageKafka.h b/src/Storages/Kafka/StorageKafka.h\nindex d5e319b8974f..3b20e6b23f64 100644\n--- a/src/Storages/Kafka/StorageKafka.h\n+++ b/src/Storages/Kafka/StorageKafka.h\n@@ -74,8 +74,6 @@ class StorageKafka final : public IStorage, WithContext\n \n     const auto & getFormatName() const { return format_name; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-    Names getVirtualColumnNames() const;\n     StreamingHandleErrorMode getStreamingHandleErrorMode() const { return kafka_settings->kafka_handle_error_mode; }\n \n     struct SafeConsumers\n@@ -158,6 +156,8 @@ class StorageKafka final : public IStorage, WithContext\n     bool checkDependencies(const StorageID & table_id);\n \n     void cleanConsumers();\n+\n+    static VirtualColumnsDescription createVirtuals(StreamingHandleErrorMode handle_error_mode);\n };\n \n }\ndiff --git a/src/Storages/LightweightDeleteDescription.cpp b/src/Storages/LightweightDeleteDescription.cpp\ndeleted file mode 100644\nindex ae5e68da9c2d..000000000000\n--- a/src/Storages/LightweightDeleteDescription.cpp\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-#include <Storages/LightweightDeleteDescription.h>\n-#include <DataTypes/DataTypesNumber.h>\n-\n-namespace DB\n-{\n-\n-const NameAndTypePair LightweightDeleteDescription::FILTER_COLUMN {\"_row_exists\", std::make_shared<DataTypeUInt8>()};\n-\n-}\ndiff --git a/src/Storages/LightweightDeleteDescription.h b/src/Storages/LightweightDeleteDescription.h\ndeleted file mode 100644\nindex 45bde59ea715..000000000000\n--- a/src/Storages/LightweightDeleteDescription.h\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-#pragma once\n-#include <Core/NamesAndTypes.h>\n-#include \"Storages/TTLDescription.h\"\n-\n-namespace DB\n-{\n-\n-struct LightweightDeleteDescription\n-{\n-    static const NameAndTypePair FILTER_COLUMN;\n-};\n-\n-}\ndiff --git a/src/Storages/LiveView/StorageLiveView.cpp b/src/Storages/LiveView/StorageLiveView.cpp\nindex 958e0a326cfe..c3aacfd67d3f 100644\n--- a/src/Storages/LiveView/StorageLiveView.cpp\n+++ b/src/Storages/LiveView/StorageLiveView.cpp\n@@ -218,6 +218,10 @@ StorageLiveView::StorageLiveView(\n \n     setInMemoryMetadata(storage_metadata);\n \n+    VirtualColumnsDescription virtuals;\n+    virtuals.addEphemeral(\"_version\", std::make_shared<DataTypeUInt64>(), \"\");\n+    setVirtuals(std::move(virtuals));\n+\n     if (!query.select)\n         throw Exception(ErrorCodes::INCORRECT_QUERY, \"SELECT query is not specified for {}\", getName());\n \n@@ -236,13 +240,6 @@ StorageLiveView::~StorageLiveView()\n     shutdown(false);\n }\n \n-NamesAndTypesList StorageLiveView::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        NameAndTypePair(\"_version\", std::make_shared<DataTypeUInt64>())\n-    };\n-}\n-\n void StorageLiveView::checkTableCanBeDropped([[ maybe_unused ]] ContextPtr query_context) const\n {\n     auto table_id = getStorageID();\ndiff --git a/src/Storages/LiveView/StorageLiveView.h b/src/Storages/LiveView/StorageLiveView.h\nindex bf6b13fc8373..91daac32c7b0 100644\n--- a/src/Storages/LiveView/StorageLiveView.h\n+++ b/src/Storages/LiveView/StorageLiveView.h\n@@ -74,8 +74,6 @@ using MilliSeconds = std::chrono::milliseconds;\n \n     bool supportsFinal() const override { return true; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     void checkTableCanBeDropped([[ maybe_unused ]] ContextPtr query_context) const override;\n \n     void drop() override;\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex a9bdceacef06..526ea542b0e9 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -1451,6 +1451,11 @@ bool IMergeTreeDataPart::supportLightweightDeleteMutate() const\n         parent_part == nullptr && projection_parts.empty();\n }\n \n+bool IMergeTreeDataPart::hasLightweightDelete() const\n+{\n+    return columns.contains(RowExistsColumn::name);\n+}\n+\n void IMergeTreeDataPart::assertHasVersionMetadata(MergeTreeTransaction * txn) const\n {\n     TransactionID expected_tid = txn ? txn->tid : Tx::PrehistoricTID;\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 91c559d30c80..fba1e6ddbb1a 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -1,12 +1,12 @@\n #pragma once\n \n+#include <unordered_map>\n #include <IO/WriteSettings.h>\n #include <Core/Block.h>\n #include <base/types.h>\n #include <base/defines.h>\n #include <Core/NamesAndTypes.h>\n #include <Storages/IStorage.h>\n-#include <Storages/LightweightDeleteDescription.h>\n #include <Storages/MergeTree/AlterConversions.h>\n #include <Storages/MergeTree/IDataPartStorage.h>\n #include <Storages/MergeTree/MergeTreeDataPartState.h>\n@@ -48,6 +48,8 @@ class MarkCache;\n class UncompressedCache;\n class MergeTreeTransaction;\n \n+struct MergeTreeReadTaskInfo;\n+using MergeTreeReadTaskInfoPtr = std::shared_ptr<const MergeTreeReadTaskInfo>;\n \n enum class DataPartRemovalState\n {\n@@ -69,6 +71,7 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n     using Checksums = MergeTreeDataPartChecksums;\n     using Checksum = MergeTreeDataPartChecksums::Checksum;\n     using ValueSizeMap = std::map<std::string, double>;\n+    using VirtualFields = std::unordered_map<String, Field>;\n \n     using MergeTreeReaderPtr = std::unique_ptr<IMergeTreeReader>;\n     using MergeTreeWriterPtr = std::unique_ptr<IMergeTreeDataPartWriter>;\n@@ -95,6 +98,7 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n         const NamesAndTypesList & columns_,\n         const StorageSnapshotPtr & storage_snapshot,\n         const MarkRanges & mark_ranges,\n+        const VirtualFields & virtual_fields,\n         UncompressedCache * uncompressed_cache,\n         MarkCache * mark_cache,\n         const AlterConversionsPtr & alter_conversions,\n@@ -493,7 +497,7 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n     bool supportLightweightDeleteMutate() const;\n \n     /// True if here is lightweight deleted mask file in part.\n-    bool hasLightweightDelete() const { return columns.contains(LightweightDeleteDescription::FILTER_COLUMN.name); }\n+    bool hasLightweightDelete() const;\n \n     void writeChecksums(const MergeTreeDataPartChecksums & checksums_, const WriteSettings & settings);\n \ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.cpp b/src/Storages/MergeTree/IMergeTreeReader.cpp\nindex 63ed8021f58b..4936f1d33c61 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeReader.cpp\n@@ -1,7 +1,8 @@\n #include <Storages/MergeTree/IMergeTreeReader.h>\n+#include <Storages/MergeTree/MergeTreeReadTask.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n+#include <Storages/MergeTree/LoadedMergeTreeDataPartInfoForReader.h>\n #include <DataTypes/NestedUtils.h>\n-#include <DataTypes/DataTypeArray.h>\n-#include <DataTypes/DataTypeNested.h>\n #include <Common/escapeForFileName.h>\n #include <Compression/CachedCompressedReadBuffer.h>\n #include <Columns/ColumnArray.h>\n@@ -19,12 +20,13 @@ namespace\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n-\n IMergeTreeReader::IMergeTreeReader(\n     MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n     const NamesAndTypesList & columns_,\n+    const VirtualFields & virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     UncompressedCache * uncompressed_cache_,\n     MarkCache * mark_cache_,\n@@ -47,6 +49,7 @@ IMergeTreeReader::IMergeTreeReader(\n     , part_columns(data_part_info_for_read->isWidePart()\n         ? data_part_info_for_read->getColumnsDescriptionWithCollectedNested()\n         : data_part_info_for_read->getColumnsDescription())\n+    , virtual_fields(virtual_fields_)\n {\n     columns_to_read.reserve(requested_columns.size());\n     serializations.reserve(requested_columns.size());\n@@ -63,7 +66,49 @@ const IMergeTreeReader::ValueSizeMap & IMergeTreeReader::getAvgValueSizeHints()\n     return avg_value_size_hints;\n }\n \n-void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows, size_t block_number) const\n+void IMergeTreeReader::fillVirtualColumns(Columns & columns, size_t rows) const\n+{\n+    chassert(columns.size() == requested_columns.size());\n+\n+    const auto * loaded_part_info = typeid_cast<const LoadedMergeTreeDataPartInfoForReader *>(data_part_info_for_read.get());\n+    if (!loaded_part_info)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Filling of virtual columns is supported only for LoadedMergeTreeDataPartInfoForReader\");\n+\n+    const auto & data_part = loaded_part_info->getDataPart();\n+    const auto & storage_columns = storage_snapshot->getMetadataForQuery()->getColumns();\n+    const auto & virtual_columns = storage_snapshot->virtual_columns;\n+\n+    auto it = requested_columns.begin();\n+    for (size_t pos = 0; pos < columns.size(); ++pos, ++it)\n+    {\n+        if (columns[pos] || storage_columns.has(it->name))\n+            continue;\n+\n+        auto virtual_column = virtual_columns->tryGet(it->name);\n+        if (!virtual_column)\n+            continue;\n+\n+        if (!it->type->equals(*virtual_column->type))\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                \"Data type for virtual column {} mismatched. Requested type: {}, virtual column type: {}\",\n+                it->name, it->type->getName(), virtual_column->type->getName());\n+        }\n+\n+        if (it->name == \"_part_offset\")\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Virtual column {} must be filled by range reader\", it->name);\n+\n+        Field field;\n+        if (auto field_it = virtual_fields.find(it->name); field_it != virtual_fields.end())\n+            field = field_it->second;\n+        else\n+            field = getFieldForConstVirtualColumn(it->name, *data_part);\n+\n+        columns[pos] = virtual_column->type->createColumnConst(rows, field)->convertToFullColumnIfConst();\n+    }\n+}\n+\n+void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows) const\n {\n     try\n     {\n@@ -72,7 +117,7 @@ void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_e\n             res_columns, num_rows,\n             Nested::convertToSubcolumns(requested_columns),\n             Nested::convertToSubcolumns(available_columns),\n-            partially_read_columns, storage_snapshot->metadata, block_number);\n+            partially_read_columns, storage_snapshot->metadata);\n \n         should_evaluate_missing_defaults = std::any_of(\n             res_columns.begin(), res_columns.end(), [](const auto & column) { return column == nullptr; });\ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.h b/src/Storages/MergeTree/IMergeTreeReader.h\nindex 997be064f280..a5b84eba241f 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.h\n+++ b/src/Storages/MergeTree/IMergeTreeReader.h\n@@ -9,8 +9,6 @@\n namespace DB\n {\n \n-class IDataType;\n-\n /// Reads the data between pairs of marks in the same part. When reading consecutive ranges, avoids unnecessary seeks.\n /// When ranges are almost consecutive, seeks are fast because they are performed inside the buffer.\n /// Avoids loading the marks file if it is not needed (e.g. when reading the whole part).\n@@ -18,11 +16,13 @@ class IMergeTreeReader : private boost::noncopyable\n {\n public:\n     using ValueSizeMap = std::map<std::string, double>;\n+    using VirtualFields = std::unordered_map<String, Field>;\n     using DeserializeBinaryBulkStateMap = std::map<std::string, ISerialization::DeserializeBinaryBulkStatePtr>;\n \n     IMergeTreeReader(\n         MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n         const NamesAndTypesList & columns_,\n+        const VirtualFields & virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         UncompressedCache * uncompressed_cache_,\n         MarkCache * mark_cache_,\n@@ -42,10 +42,13 @@ class IMergeTreeReader : private boost::noncopyable\n \n     const ValueSizeMap & getAvgValueSizeHints() const;\n \n+    /// Add virtual columns that are not present in the block.\n+    void fillVirtualColumns(Columns & columns, size_t rows) const;\n+\n     /// Add columns from ordered_names that are not present in the block.\n     /// Missing columns are added in the order specified by ordered_names.\n     /// num_rows is needed in case if all res_columns are nullptr.\n-    void fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows, size_t block_number = 0) const;\n+    void fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows) const;\n     /// Evaluate defaulted columns if necessary.\n     void evaluateMissingDefaults(Block additional_columns, Columns & res_columns) const;\n \n@@ -113,6 +116,9 @@ class IMergeTreeReader : private boost::noncopyable\n \n     /// Actual columns description in part.\n     const ColumnsDescription & part_columns;\n+\n+    /// Fields of virtual columns that were filled in previous stages.\n+    VirtualFields virtual_fields;\n };\n \n }\ndiff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp\nindex df64ae337134..aa38198334e3 100644\n--- a/src/Storages/MergeTree/MergeTask.cpp\n+++ b/src/Storages/MergeTree/MergeTask.cpp\n@@ -8,7 +8,6 @@\n #include <Common/logger_useful.h>\n #include <Common/ActionBlocker.h>\n #include <Processors/Transforms/CheckSortedTransform.h>\n-#include <Storages/LightweightDeleteDescription.h>\n #include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n \n #include <DataTypes/ObjectUtils.h>\n@@ -1075,14 +1074,18 @@ void MergeTask::ExecuteAndFinalizeHorizontalPart::createMergedStream()\n \n     if (global_ctx->deduplicate)\n     {\n-        /// We don't want to deduplicate by block number column\n-        /// so if deduplicate_by_columns is empty, add all columns except _block_number\n-        if (supportsBlockNumberColumn(global_ctx) && global_ctx->deduplicate_by_columns.empty())\n+        const auto & virtuals = *global_ctx->data->getVirtualsPtr();\n+\n+        /// We don't want to deduplicate by virtual persistent column.\n+        /// If deduplicate_by_columns is empty, add all columns except virtuals.\n+        if (global_ctx->deduplicate_by_columns.empty())\n         {\n-            for (const auto & col : global_ctx->merging_column_names)\n+            for (const auto & column_name : global_ctx->merging_column_names)\n             {\n-                if (col != BlockNumberColumn::name)\n-                    global_ctx->deduplicate_by_columns.emplace_back(col);\n+                if (virtuals.tryGet(column_name, VirtualsKind::Persistent))\n+                    continue;\n+\n+                global_ctx->deduplicate_by_columns.emplace_back(column_name);\n             }\n         }\n \ndiff --git a/src/Storages/MergeTree/MergeTask.h b/src/Storages/MergeTree/MergeTask.h\nindex 7fb4797e4821..1f50e55f8a0c 100644\n--- a/src/Storages/MergeTree/MergeTask.h\n+++ b/src/Storages/MergeTree/MergeTask.h\n@@ -15,7 +15,7 @@\n \n #include <QueryPipeline/QueryPipeline.h>\n \n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Storages/MergeTree/ColumnSizeEstimator.h>\n #include <Storages/MergeTree/FutureMergedMutatedPart.h>\n #include <Storages/MergeTree/IExecutableTask.h>\ndiff --git a/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp b/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\nindex f5f0fa6f726b..67f5e7a53e81 100644\n--- a/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n+++ b/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n@@ -6,6 +6,7 @@\n #include <Core/NamesAndTypes.h>\n #include <Common/checkStackSize.h>\n #include <Common/typeid_cast.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Storages/MergeTree/MergeTreeSelectProcessor.h>\n #include <Columns/ColumnConst.h>\n #include <IO/WriteBufferFromString.h>\n@@ -106,16 +107,14 @@ NameSet injectRequiredColumns(\n \n     auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical)\n         .withExtendedObjects()\n-        .withSystemColumns();\n-\n-    if (with_subcolumns)\n-        options.withSubcolumns();\n+        .withVirtuals()\n+        .withSubcolumns(with_subcolumns);\n \n     for (size_t i = 0; i < columns.size(); ++i)\n     {\n-        /// We are going to fetch only physical columns and system columns\n+        /// We are going to fetch physical columns and system columns first\n         if (!storage_snapshot->tryGetColumn(options, columns[i]))\n-            throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no physical column or subcolumn {} in table\", columns[i]);\n+            throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no column or subcolumn {} in table\", columns[i]);\n \n         have_at_least_one_physical_column |= injectRequiredColumnsRecursively(\n             columns[i], storage_snapshot, alter_conversions,\n@@ -258,11 +257,10 @@ void MergeTreeBlockSizePredictor::update(const Block & sample_block, const Colum\n }\n \n \n-MergeTreeReadTask::Columns getReadTaskColumns(\n+MergeTreeReadTaskColumns getReadTaskColumns(\n     const IMergeTreeDataPartInfoForReader & data_part_info_for_reader,\n     const StorageSnapshotPtr & storage_snapshot,\n     const Names & required_columns,\n-    const Names & system_columns,\n     const PrewhereInfoPtr & prewhere_info,\n     const ExpressionActionsSettings & actions_settings,\n     const MergeTreeReaderSettings & reader_settings,\n@@ -270,28 +268,30 @@ MergeTreeReadTask::Columns getReadTaskColumns(\n {\n     Names column_to_read_after_prewhere = required_columns;\n \n-    /// Read system columns such as lightweight delete mask \"_row_exists\" if it is persisted in the part\n-    for (const auto & name : system_columns)\n-        if (data_part_info_for_reader.getColumns().contains(name))\n-            column_to_read_after_prewhere.push_back(name);\n-\n     /// Inject columns required for defaults evaluation\n     injectRequiredColumns(\n         data_part_info_for_reader, storage_snapshot, with_subcolumns, column_to_read_after_prewhere);\n \n-    MergeTreeReadTask::Columns result;\n+    MergeTreeReadTaskColumns result;\n     auto options = GetColumnsOptions(GetColumnsOptions::All)\n         .withExtendedObjects()\n-        .withSystemColumns();\n+        .withVirtuals()\n+        .withSubcolumns(with_subcolumns);\n \n-    if (with_subcolumns)\n-        options.withSubcolumns();\n+    static const NameSet columns_to_read_at_first_step = {\"_part_offset\"};\n \n     NameSet columns_from_previous_steps;\n     auto add_step = [&](const PrewhereExprStep & step)\n     {\n         Names step_column_names;\n \n+        if (columns_from_previous_steps.empty())\n+        {\n+            for (const auto & required_column : required_columns)\n+                if (columns_to_read_at_first_step.contains(required_column))\n+                    step_column_names.push_back(required_column);\n+        }\n+\n         /// Computation results from previous steps might be used in the current step as well. In such a case these\n         /// computed columns will be present in the current step inputs. They don't need to be read from the disk so\n         /// exclude them from the list of columns to read. This filtering must be done before injecting required\ndiff --git a/src/Storages/MergeTree/MergeTreeBlockReadUtils.h b/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\nindex 9417d47814a3..b19c42c8db85 100644\n--- a/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n+++ b/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n@@ -1,6 +1,5 @@\n #pragma once\n \n-#include <optional>\n #include <Core/NamesAndTypes.h>\n #include <Storages/MergeTree/MergeTreeReadTask.h>\n \n@@ -22,11 +21,10 @@ NameSet injectRequiredColumns(\n     bool with_subcolumns,\n     Names & columns);\n \n-MergeTreeReadTask::Columns getReadTaskColumns(\n+MergeTreeReadTaskColumns getReadTaskColumns(\n     const IMergeTreeDataPartInfoForReader & data_part_info_for_reader,\n     const StorageSnapshotPtr & storage_snapshot,\n     const Names & required_columns,\n-    const Names & system_columns,\n     const PrewhereInfoPtr & prewhere_info,\n     const ExpressionActionsSettings & actions_settings,\n     const MergeTreeReaderSettings & reader_settings,\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 8aa188cfe5ce..9bc360cbcac6 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -67,7 +67,7 @@\n #include <Processors/QueryPlan/QueryIdHolder.h>\n #include <Processors/QueryPlan/ReadFromMergeTree.h>\n #include <Storages/AlterCommands.h>\n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Storages/Freeze.h>\n #include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n #include <Storages/MergeTree/MergeTreeDataPartBuilder.h>\n@@ -430,6 +430,29 @@ MergeTreeData::MergeTreeData(\n     };\n }\n \n+VirtualColumnsDescription MergeTreeData::createVirtuals(const StorageInMemoryMetadata & metadata)\n+{\n+    VirtualColumnsDescription desc;\n+\n+    desc.addEphemeral(\"_part\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"Name of part\");\n+    desc.addEphemeral(\"_part_index\", std::make_shared<DataTypeUInt64>(), \"Sequential index of the part in the query result\");\n+    desc.addEphemeral(\"_part_uuid\", std::make_shared<DataTypeUUID>(), \"Unique part identifier (if enabled MergeTree setting assign_part_uuids)\");\n+    desc.addEphemeral(\"_partition_id\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"Name of partition\");\n+    desc.addEphemeral(\"_sample_factor\", std::make_shared<DataTypeFloat64>(), \"Sample factor (from the query)\");\n+    desc.addEphemeral(\"_part_offset\", std::make_shared<DataTypeUInt64>(), \"Number of row in the part\");\n+\n+    if (metadata.hasPartitionKey())\n+    {\n+        auto partition_types = metadata.partition_key.sample_block.getDataTypes();\n+        desc.addEphemeral(\"_partition_value\", std::make_shared<DataTypeTuple>(std::move(partition_types)), \"Value (a tuple) of a PARTITION BY expression\");\n+    }\n+\n+    desc.addPersistent(RowExistsColumn::name, RowExistsColumn::type, nullptr, \"Persisted mask created by lightweight delete that show whether row exists or is deleted\");\n+    desc.addPersistent(BlockNumberColumn::name, BlockNumberColumn::type, BlockNumberColumn::codec, \"Persisted original number of block that was assigned at insert\");\n+\n+    return desc;\n+}\n+\n StoragePolicyPtr MergeTreeData::getStoragePolicy() const\n {\n     auto settings = getSettings();\n@@ -677,6 +700,7 @@ void MergeTreeData::setProperties(\n {\n     checkProperties(new_metadata, old_metadata, attach, false, allow_nullable_key, local_context);\n     setInMemoryMetadata(new_metadata);\n+    setVirtuals(createVirtuals(new_metadata));\n }\n \n namespace\n@@ -1002,73 +1026,38 @@ void MergeTreeData::MergingParams::check(const StorageInMemoryMetadata & metadat\n     /// TODO Checks for Graphite mode.\n }\n \n+const Names MergeTreeData::virtuals_useful_for_filter = {\"_part\", \"_partition_id\", \"_part_uuid\", \"_partition_value\"};\n \n-DataTypePtr MergeTreeData::getPartitionValueType() const\n+Block MergeTreeData::getHeaderWithVirtualsForFilter() const\n {\n-    DataTypePtr partition_value_type;\n-    auto partition_types = getInMemoryMetadataPtr()->partition_key.sample_block.getDataTypes();\n-    if (partition_types.empty())\n-        partition_value_type = std::make_shared<DataTypeUInt8>();\n-    else\n-        partition_value_type = std::make_shared<DataTypeTuple>(std::move(partition_types));\n-    return partition_value_type;\n+    Block header;\n+    auto virtuals_desc = getVirtualsPtr();\n+    for (const auto & name : virtuals_useful_for_filter)\n+        if (auto column = virtuals_desc->tryGet(name))\n+            header.insert({column->type->createColumn(), column->type, name});\n+    return header;\n }\n \n-\n-Block MergeTreeData::getSampleBlockWithVirtualColumns() const\n-{\n-    DataTypePtr partition_value_type = getPartitionValueType();\n-    return {\n-        ColumnWithTypeAndName(\n-            DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn(),\n-            std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()),\n-            \"_part\"),\n-        ColumnWithTypeAndName(\n-            DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn(),\n-            std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()),\n-            \"_partition_id\"),\n-        ColumnWithTypeAndName(ColumnUUID::create(), std::make_shared<DataTypeUUID>(), \"_part_uuid\"),\n-        ColumnWithTypeAndName(partition_value_type->createColumn(), partition_value_type, \"_partition_value\")};\n-}\n-\n-\n-Block MergeTreeData::getBlockWithVirtualPartColumns(const MergeTreeData::DataPartsVector & parts, bool one_part, bool ignore_empty) const\n+Block MergeTreeData::getBlockWithVirtualsForFilter(const MergeTreeData::DataPartsVector & parts, bool ignore_empty) const\n {\n-    auto block = getSampleBlockWithVirtualColumns();\n-    MutableColumns columns = block.mutateColumns();\n+    auto block = getHeaderWithVirtualsForFilter();\n \n-    auto & part_column = columns[0];\n-    auto & partition_id_column = columns[1];\n-    auto & part_uuid_column = columns[2];\n-    auto & partition_value_column = columns[3];\n-\n-    bool has_partition_value = typeid_cast<const ColumnTuple *>(partition_value_column.get());\n     for (const auto & part_or_projection : parts)\n     {\n         if (ignore_empty && part_or_projection->isEmpty())\n             continue;\n-        const auto * part = part_or_projection->isProjectionPart() ? part_or_projection->getParentPart() : part_or_projection.get();\n-        part_column->insert(part->name);\n-        partition_id_column->insert(part->info.partition_id);\n-        part_uuid_column->insert(part->uuid);\n-        Tuple tuple(part->partition.value.begin(), part->partition.value.end());\n-        if (has_partition_value)\n-            partition_value_column->insert(tuple);\n-\n-        if (one_part)\n-        {\n-            part_column = ColumnConst::create(std::move(part_column), 1);\n-            partition_id_column = ColumnConst::create(std::move(partition_id_column), 1);\n-            part_uuid_column = ColumnConst::create(std::move(part_uuid_column), 1);\n-            if (has_partition_value)\n-                partition_value_column = ColumnConst::create(std::move(partition_value_column), 1);\n-            break;\n+\n+        const auto * part = part_or_projection->isProjectionPart()\n+            ? part_or_projection->getParentPart()\n+            : part_or_projection.get();\n+\n+        for (auto & column : block)\n+        {\n+            auto field = getFieldForConstVirtualColumn(column.name, *part);\n+            column.column->assumeMutableRef().insert(field);\n         }\n     }\n \n-    block.setColumns(std::move(columns));\n-    if (!has_partition_value)\n-        block.erase(\"_partition_value\");\n     return block;\n }\n \n@@ -1077,13 +1066,14 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n     const ActionsDAGPtr & filter_actions_dag, ContextPtr local_context, const DataPartsVector & parts) const\n {\n     if (parts.empty())\n-        return 0u;\n+        return 0;\n+\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n-    Block virtual_columns_block = getBlockWithVirtualPartColumns(parts, true /* one_part */);\n+    auto virtual_columns_block = getBlockWithVirtualsForFilter({parts[0]});\n \n     auto filter_dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_actions_dag->getOutputs().at(0), nullptr);\n \n-    // Generate valid expressions for filtering\n+    /// Generate valid expressions for filtering\n     bool valid = true;\n     for (const auto * input : filter_dag->getInputs())\n         if (!virtual_columns_block.has(input->result_name))\n@@ -1096,7 +1086,7 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n     std::unordered_set<String> part_values;\n     if (valid)\n     {\n-        virtual_columns_block = getBlockWithVirtualPartColumns(parts, false /* one_part */);\n+        virtual_columns_block = getBlockWithVirtualsForFilter(parts);\n         VirtualColumnUtils::filterBlockWithDAG(filter_dag, virtual_columns_block, local_context);\n         part_values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");\n         if (part_values.empty())\n@@ -3658,6 +3648,7 @@ void MergeTreeData::checkPartDynamicColumns(MutableDataPartPtr & part, DataParts\n {\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     const auto & columns = metadata_snapshot->getColumns();\n+    auto virtuals = getVirtualsPtr();\n \n     if (!hasDynamicSubcolumns(columns))\n         return;\n@@ -3665,7 +3656,7 @@ void MergeTreeData::checkPartDynamicColumns(MutableDataPartPtr & part, DataParts\n     const auto & part_columns = part->getColumns();\n     for (const auto & part_column : part_columns)\n     {\n-        if (part_column.name == LightweightDeleteDescription::FILTER_COLUMN.name || part_column.name == BlockNumberColumn::name)\n+        if (virtuals->has(part_column.name))\n             continue;\n \n         auto storage_column = columns.getPhysical(part_column.name);\n@@ -6669,14 +6660,6 @@ Block MergeTreeData::getMinMaxCountProjectionBlock(\n     const auto & primary_key_max_column_name = metadata_snapshot->minmax_count_projection->primary_key_max_column_name;\n     NameSet required_columns_set(required_columns.begin(), required_columns.end());\n \n-    if (required_columns_set.contains(\"_partition_value\") && !typeid_cast<const DataTypeTuple *>(getPartitionValueType().get()))\n-    {\n-        throw Exception(\n-            ErrorCodes::NO_SUCH_COLUMN_IN_TABLE,\n-            \"Missing column `_partition_value` because there is no partition column in table {}\",\n-            getStorageID().getTableName());\n-    }\n-\n     if (!primary_key_max_column_name.empty())\n         need_primary_key_max_column = required_columns_set.contains(primary_key_max_column_name);\n \n@@ -6702,11 +6685,11 @@ Block MergeTreeData::getMinMaxCountProjectionBlock(\n     };\n \n     Block virtual_columns_block;\n-    auto virtual_block = getSampleBlockWithVirtualColumns();\n+    auto virtual_block = getHeaderWithVirtualsForFilter();\n     bool has_virtual_column = std::any_of(required_columns.begin(), required_columns.end(), [&](const auto & name) { return virtual_block.has(name); });\n     if (has_virtual_column || filter_dag)\n     {\n-        virtual_columns_block = getBlockWithVirtualPartColumns(parts, false /* one_part */, true /* ignore_empty */);\n+        virtual_columns_block = getBlockWithVirtualsForFilter(parts, /*ignore_empty=*/ true);\n         if (virtual_columns_block.rows() == 0)\n             return {};\n     }\n@@ -7952,21 +7935,6 @@ AlterConversionsPtr MergeTreeData::getAlterConversionsForPart(MergeTreeDataPartP\n     return result;\n }\n \n-NamesAndTypesList MergeTreeData::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        NameAndTypePair(\"_part\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())),\n-        NameAndTypePair(\"_part_index\", std::make_shared<DataTypeUInt64>()),\n-        NameAndTypePair(\"_part_uuid\", std::make_shared<DataTypeUUID>()),\n-        NameAndTypePair(\"_partition_id\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())),\n-        NameAndTypePair(\"_partition_value\", getPartitionValueType()),\n-        NameAndTypePair(\"_sample_factor\", std::make_shared<DataTypeFloat64>()),\n-        NameAndTypePair(\"_part_offset\", std::make_shared<DataTypeUInt64>()),\n-        LightweightDeleteDescription::FILTER_COLUMN,\n-        NameAndTypePair(BlockNumberColumn::name, BlockNumberColumn::type),\n-    };\n-}\n-\n size_t MergeTreeData::getTotalMergesWithTTLInMergeList() const\n {\n     return getContext()->getMergeList().getMergesWithTTLCount();\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 4475f2b6f12e..dc84505f38fc 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -444,8 +444,6 @@ class MergeTreeData : public IStorage, public WithMutableContext\n \n     bool supportsTrivialCountOptimization() const override { return !hasLightweightDeletedMask(); }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     /// Snapshot for MergeTree contains the current set of data parts\n     /// at the moment of the start of query.\n     struct SnapshotData : public StorageSnapshot::Data\n@@ -988,15 +986,13 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     void removeQueryId(const String & query_id) const;\n     void removeQueryIdNoLock(const String & query_id) const TSA_REQUIRES(query_id_set_mutex);\n \n-    /// Return the partition expression types as a Tuple type. Return DataTypeUInt8 if partition expression is empty.\n-    DataTypePtr getPartitionValueType() const;\n+    static const Names virtuals_useful_for_filter;\n \n     /// Construct a sample block of virtual columns.\n-    Block getSampleBlockWithVirtualColumns() const;\n+    Block getHeaderWithVirtualsForFilter() const;\n \n     /// Construct a block consisting only of possible virtual columns for part pruning.\n-    /// If one_part is true, fill in at most one part.\n-    Block getBlockWithVirtualPartColumns(const MergeTreeData::DataPartsVector & parts, bool one_part, bool ignore_empty = false) const;\n+    Block getBlockWithVirtualsForFilter(const MergeTreeData::DataPartsVector & parts, bool ignore_empty = false) const;\n \n     /// In merge tree we do inserts with several steps. One of them:\n     /// X. write part to temporary directory with some temp name\n@@ -1087,6 +1083,8 @@ class MergeTreeData : public IStorage, public WithMutableContext\n \n     bool initializeDiskOnConfigChange(const std::set<String> & /*new_added_disks*/) override;\n \n+    static VirtualColumnsDescription createVirtuals(const StorageInMemoryMetadata & metadata);\n+\n protected:\n     friend class IMergeTreeDataPart;\n     friend class MergeTreeDataMergerMutator;\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\nindex 0ecd7abe1831..9f201ab3b810 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\n@@ -5,7 +5,6 @@\n #include <Interpreters/Context.h>\n #include <Storages/MergeTree/LoadedMergeTreeDataPartInfoForReader.h>\n #include <Compression/CompressedReadBufferFromFile.h>\n-#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n@@ -33,6 +32,7 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartCompact::getReader(\n     const NamesAndTypesList & columns_to_read,\n     const StorageSnapshotPtr & storage_snapshot,\n     const MarkRanges & mark_ranges,\n+    const VirtualFields & virtual_fields,\n     UncompressedCache * uncompressed_cache,\n     MarkCache * mark_cache,\n     const AlterConversionsPtr & alter_conversions,\n@@ -41,12 +41,21 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartCompact::getReader(\n     const ReadBufferFromFileBase::ProfileCallback & profile_callback) const\n {\n     auto read_info = std::make_shared<LoadedMergeTreeDataPartInfoForReader>(shared_from_this(), alter_conversions);\n-    auto * load_marks_threadpool = reader_settings.read_settings.load_marks_asynchronously ? &read_info->getContext()->getLoadMarksThreadpool() : nullptr;\n+    auto * load_marks_threadpool\n+        = reader_settings.read_settings.load_marks_asynchronously ? &read_info->getContext()->getLoadMarksThreadpool() : nullptr;\n \n     return std::make_unique<MergeTreeReaderCompact>(\n-        read_info, columns_to_read, storage_snapshot, uncompressed_cache,\n-        mark_cache, mark_ranges, reader_settings, load_marks_threadpool,\n-        avg_value_size_hints, profile_callback);\n+        read_info,\n+        columns_to_read,\n+        virtual_fields,\n+        storage_snapshot,\n+        uncompressed_cache,\n+        mark_cache,\n+        mark_ranges,\n+        reader_settings,\n+        load_marks_threadpool,\n+        avg_value_size_hints,\n+        profile_callback);\n }\n \n IMergeTreeDataPart::MergeTreeWriterPtr MergeTreeDataPartCompact::getWriter(\n@@ -66,12 +75,6 @@ IMergeTreeDataPart::MergeTreeWriterPtr MergeTreeDataPartCompact::getWriter(\n     ordered_columns_list.sort([this](const auto & lhs, const auto & rhs)\n         { return *getColumnPosition(lhs.name) < *getColumnPosition(rhs.name); });\n \n-    /// _block_number column is not added by user, but is persisted in a part after merge\n-    /// If _block_number is not present in the parts to be merged, then it won't have a position\n-    /// So check if its not present and add it at the end\n-    if (columns_list.contains(BlockNumberColumn::name) && !ordered_columns_list.contains(BlockNumberColumn::name))\n-        ordered_columns_list.emplace_back(NameAndTypePair{BlockNumberColumn::name, BlockNumberColumn::type});\n-\n     return std::make_unique<MergeTreeDataPartWriterCompact>(\n         shared_from_this(), ordered_columns_list, metadata_snapshot,\n         indices_to_recalc, stats_to_recalc_, getMarksFileExtension(),\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartCompact.h b/src/Storages/MergeTree/MergeTreeDataPartCompact.h\nindex 35a358b3720d..a97d15a08f34 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartCompact.h\n+++ b/src/Storages/MergeTree/MergeTreeDataPartCompact.h\n@@ -32,6 +32,7 @@ class MergeTreeDataPartCompact : public IMergeTreeDataPart\n         const NamesAndTypesList & columns,\n         const StorageSnapshotPtr & storage_snapshot,\n         const MarkRanges & mark_ranges,\n+        const VirtualFields & virtual_fields,\n         UncompressedCache * uncompressed_cache,\n         MarkCache * mark_cache,\n         const AlterConversionsPtr & alter_conversions,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\nindex 2f01dbfe04b5..e023ae9be0e7 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\n@@ -33,6 +33,7 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartInMemory::getReader(\n     const NamesAndTypesList & columns_to_read,\n     const StorageSnapshotPtr & storage_snapshot,\n     const MarkRanges & mark_ranges,\n+    const VirtualFields & virtual_fields,\n     UncompressedCache * /* uncompressed_cache */,\n     MarkCache * /* mark_cache */,\n     const AlterConversionsPtr & alter_conversions,\n@@ -44,7 +45,13 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartInMemory::getReader(\n     auto ptr = std::static_pointer_cast<const MergeTreeDataPartInMemory>(shared_from_this());\n \n     return std::make_unique<MergeTreeReaderInMemory>(\n-        read_info, ptr, columns_to_read, storage_snapshot, mark_ranges, reader_settings);\n+        read_info,\n+        ptr,\n+        columns_to_read,\n+        virtual_fields,\n+        storage_snapshot,\n+        mark_ranges,\n+        reader_settings);\n }\n \n IMergeTreeDataPart::MergeTreeWriterPtr MergeTreeDataPartInMemory::getWriter(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartInMemory.h b/src/Storages/MergeTree/MergeTreeDataPartInMemory.h\nindex 27f8ba4bccb0..90b4b0e34713 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartInMemory.h\n+++ b/src/Storages/MergeTree/MergeTreeDataPartInMemory.h\n@@ -21,6 +21,7 @@ class MergeTreeDataPartInMemory : public IMergeTreeDataPart\n         const NamesAndTypesList & columns,\n         const StorageSnapshotPtr & storage_snapshot,\n         const MarkRanges & mark_ranges,\n+        const VirtualFields & virtual_fields,\n         UncompressedCache * uncompressed_cache,\n         MarkCache * mark_cache,\n         const AlterConversionsPtr & alter_conversions,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWide.cpp\nindex dc6c1f0019d2..018b8a35534b 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWide.cpp\n@@ -31,6 +31,7 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartWide::getReader(\n     const NamesAndTypesList & columns_to_read,\n     const StorageSnapshotPtr & storage_snapshot,\n     const MarkRanges & mark_ranges,\n+    const VirtualFields & virtual_fields,\n     UncompressedCache * uncompressed_cache,\n     MarkCache * mark_cache,\n     const AlterConversionsPtr & alter_conversions,\n@@ -40,10 +41,16 @@ IMergeTreeDataPart::MergeTreeReaderPtr MergeTreeDataPartWide::getReader(\n {\n     auto read_info = std::make_shared<LoadedMergeTreeDataPartInfoForReader>(shared_from_this(), alter_conversions);\n     return std::make_unique<MergeTreeReaderWide>(\n-        read_info, columns_to_read,\n-        storage_snapshot, uncompressed_cache,\n-        mark_cache, mark_ranges, reader_settings,\n-        avg_value_size_hints, profile_callback);\n+        read_info,\n+        columns_to_read,\n+        virtual_fields,\n+        storage_snapshot,\n+        uncompressed_cache,\n+        mark_cache,\n+        mark_ranges,\n+        reader_settings,\n+        avg_value_size_hints,\n+        profile_callback);\n }\n \n IMergeTreeDataPart::MergeTreeWriterPtr MergeTreeDataPartWide::getWriter(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWide.h b/src/Storages/MergeTree/MergeTreeDataPartWide.h\nindex 14147c4ad566..a8710dad679c 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWide.h\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWide.h\n@@ -27,6 +27,7 @@ class MergeTreeDataPartWide : public IMergeTreeDataPart\n         const NamesAndTypesList & columns,\n         const StorageSnapshotPtr & storage_snapshot,\n         const MarkRanges & mark_ranges,\n+        const VirtualFields & virtual_fields,\n         UncompressedCache * uncompressed_cache,\n         MarkCache * mark_cache,\n         const AlterConversionsPtr & alter_conversions,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\nindex b05b4584259c..1721fd15b8d5 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n@@ -1,12 +1,9 @@\n #include <Storages/MergeTree/MergeTreeDataPartWriterCompact.h>\n #include <Storages/MergeTree/MergeTreeDataPartCompact.h>\n-#include <Storages/BlockNumberColumn.h>\n \n namespace DB\n {\n \n-    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n-\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n@@ -55,14 +52,10 @@ MergeTreeDataPartWriterCompact::MergeTreeDataPartWriterCompact(\n         marks_source_hashing = std::make_unique<HashingWriteBuffer>(*marks_compressor);\n     }\n \n-    const auto & storage_columns = metadata_snapshot->getColumns();\n+    auto storage_snapshot = std::make_shared<StorageSnapshot>(data_part->storage, metadata_snapshot);\n     for (const auto & column : columns_list)\n     {\n-        ASTPtr compression;\n-        if (column.name == BlockNumberColumn::name)\n-            compression = BlockNumberColumn::compression_codec->getFullCodecDesc();\n-        else\n-            compression = storage_columns.getCodecDescOrDefault(column.name, default_codec);\n+        auto compression = storage_snapshot->getCodecDescOrDefault(column.name, default_codec);\n         addStreams(column, compression);\n     }\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\nindex 9d373504473d..d79590ded21e 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n@@ -6,12 +6,10 @@\n #include <Common/escapeForFileName.h>\n #include <Columns/ColumnSparse.h>\n #include <Common/logger_useful.h>\n-#include <Storages/BlockNumberColumn.h>\n #include <Storages/ColumnsDescription.h>\n \n namespace DB\n {\n-    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n \n namespace ErrorCodes\n {\n@@ -91,15 +89,11 @@ MergeTreeDataPartWriterWide::MergeTreeDataPartWriterWide(\n            indices_to_recalc_, stats_to_recalc_, marks_file_extension_,\n            default_codec_, settings_, index_granularity_)\n {\n-    const auto & columns = metadata_snapshot->getColumns();\n-    for (const auto & it : columns_list)\n+    auto storage_snapshot = std::make_shared<StorageSnapshot>(data_part->storage, metadata_snapshot);\n+    for (const auto & column : columns_list)\n     {\n-        ASTPtr compression;\n-        if (it.name == BlockNumberColumn::name)\n-            compression = BlockNumberColumn::compression_codec->getFullCodecDesc();\n-        else\n-            compression = columns.getCodecDescOrDefault(it.name, default_codec);\n-        addStreams(it, compression);\n+        auto compression = storage_snapshot->getCodecDescOrDefault(column.name, default_codec);\n+        addStreams(column, compression);\n     }\n }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 00aeac9cef46..428c8f929317 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -46,7 +46,6 @@\n #include <Functions/IFunction.h>\n \n #include <IO/WriteBufferFromOStream.h>\n-#include <Storages/BlockNumberColumn.h>\n #include <Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h>\n \n namespace CurrentMetrics\n@@ -69,7 +68,6 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_TEXT;\n     extern const int TOO_MANY_PARTITIONS;\n     extern const int DUPLICATED_PART_UUIDS;\n-    extern const int NO_SUCH_COLUMN_IN_TABLE;\n }\n \n \n@@ -166,7 +164,6 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n     const MergeTreeData & data,\n     const StorageMetadataPtr & metadata_snapshot,\n     ContextPtr context,\n-    bool sample_factor_column_queried,\n     LoggerPtr log)\n {\n     const Settings & settings = context->getSettingsRef();\n@@ -296,7 +293,7 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n \n     if (sampling.use_sampling)\n     {\n-        if (sample_factor_column_queried && relative_sample_size != RelativeSize(0))\n+        if (relative_sample_size != RelativeSize(0))\n             sampling.used_sample_factor = 1.0 / boost::rational_cast<Float64>(relative_sample_size);\n \n         RelativeSize size_of_universum = 0;\n@@ -483,12 +480,13 @@ std::optional<std::unordered_set<String>> MergeTreeDataSelectExecutor::filterPar\n {\n     if (!filter_dag)\n         return {};\n-    auto sample = data.getSampleBlockWithVirtualColumns();\n+\n+    auto sample = data.getHeaderWithVirtualsForFilter();\n     auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_dag->getOutputs().at(0), &sample);\n     if (!dag)\n         return {};\n \n-    auto virtual_columns_block = data.getBlockWithVirtualPartColumns(parts, false /* one_part */);\n+    auto virtual_columns_block = data.getBlockWithVirtualsForFilter(parts);\n     VirtualColumnUtils::filterBlockWithDAG(dag, virtual_columns_block, context);\n     return VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");\n }\n@@ -868,69 +866,6 @@ std::shared_ptr<QueryIdHolder> MergeTreeDataSelectExecutor::checkLimits(\n     return nullptr;\n }\n \n-static void selectColumnNames(\n-    const Names & column_names_to_return,\n-    const MergeTreeData & data,\n-    Names & real_column_names,\n-    Names & virt_column_names,\n-    bool & sample_factor_column_queried)\n-{\n-    sample_factor_column_queried = false;\n-\n-    for (const String & name : column_names_to_return)\n-    {\n-        if (name == \"_part\")\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_part_index\")\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_partition_id\")\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_part_offset\")\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == LightweightDeleteDescription::FILTER_COLUMN.name)\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == BlockNumberColumn::name)\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_part_uuid\")\n-        {\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_partition_value\")\n-        {\n-            if (!typeid_cast<const DataTypeTuple *>(data.getPartitionValueType().get()))\n-            {\n-                throw Exception(\n-                    ErrorCodes::NO_SUCH_COLUMN_IN_TABLE,\n-                    \"Missing column `_partition_value` because there is no partition column in table {}\",\n-                    data.getStorageID().getTableName());\n-            }\n-\n-            virt_column_names.push_back(name);\n-        }\n-        else if (name == \"_sample_factor\")\n-        {\n-            sample_factor_column_queried = true;\n-            virt_column_names.push_back(name);\n-        }\n-        else\n-        {\n-            real_column_names.push_back(name);\n-        }\n-    }\n-}\n-\n ReadFromMergeTree::AnalysisResultPtr MergeTreeDataSelectExecutor::estimateNumMarksToRead(\n     MergeTreeData::DataPartsVector parts,\n     const Names & column_names_to_return,\n@@ -944,14 +879,6 @@ ReadFromMergeTree::AnalysisResultPtr MergeTreeDataSelectExecutor::estimateNumMar\n     if (total_parts == 0)\n         return std::make_shared<ReadFromMergeTree::AnalysisResult>();\n \n-    Names real_column_names;\n-    Names virt_column_names;\n-    /// If query contains restrictions on the virtual column `_part` or `_part_index`, select only parts suitable for it.\n-    /// The virtual column `_sample_factor` (which is equal to 1 / used sample rate) can be requested in the query.\n-    bool sample_factor_column_queried = false;\n-\n-    selectColumnNames(column_names_to_return, data, real_column_names, virt_column_names, sample_factor_column_queried);\n-\n     std::optional<ReadFromMergeTree::Indexes> indexes;\n     /// NOTE: We don't need alter_conversions because the returned analysis_result is only used for:\n     /// 1. estimate the number of rows to read; 2. projection reading, which doesn't have alter_conversions.\n@@ -964,8 +891,7 @@ ReadFromMergeTree::AnalysisResultPtr MergeTreeDataSelectExecutor::estimateNumMar\n         num_streams,\n         max_block_numbers_to_read,\n         data,\n-        real_column_names,\n-        sample_factor_column_queried,\n+        column_names_to_return,\n         log,\n         indexes);\n }\n@@ -992,27 +918,16 @@ QueryPlanStepPtr MergeTreeDataSelectExecutor::readFromParts(\n     else if (parts.empty())\n         return {};\n \n-    Names real_column_names;\n-    Names virt_column_names;\n-    /// If query contains restrictions on the virtual column `_part` or `_part_index`, select only parts suitable for it.\n-    /// The virtual column `_sample_factor` (which is equal to 1 / used sample rate) can be requested in the query.\n-    bool sample_factor_column_queried = false;\n-\n-    selectColumnNames(column_names_to_return, data, real_column_names, virt_column_names, sample_factor_column_queried);\n-\n     return std::make_unique<ReadFromMergeTree>(\n         std::move(parts),\n         std::move(alter_conversions),\n         column_names_to_return,\n-        real_column_names,\n-        virt_column_names,\n         data,\n         query_info,\n         storage_snapshot,\n         context,\n         max_block_size,\n         num_streams,\n-        sample_factor_column_queried,\n         max_block_numbers_to_read,\n         log,\n         merge_tree_select_result_ptr,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\nindex d61c97ab73b7..b1afd7e66683 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n@@ -213,7 +213,6 @@ class MergeTreeDataSelectExecutor\n         const MergeTreeData & data,\n         const StorageMetadataPtr & metadata_snapshot,\n         ContextPtr context,\n-        bool sample_factor_column_queried,\n         LoggerPtr log);\n \n     /// Check query limits: max_partitions_to_read, max_concurrent_queries.\ndiff --git a/src/Storages/MergeTree/MergeTreePrefetchedReadPool.cpp b/src/Storages/MergeTree/MergeTreePrefetchedReadPool.cpp\nindex 8d8b0f1cc795..c19b4ddd8a23 100644\n--- a/src/Storages/MergeTree/MergeTreePrefetchedReadPool.cpp\n+++ b/src/Storages/MergeTree/MergeTreePrefetchedReadPool.cpp\n@@ -9,6 +9,7 @@\n #include <Storages/MergeTree/MergeTreePrefetchedReadPool.h>\n #include <Storages/MergeTree/MergeTreeRangeReader.h>\n #include <Storages/MergeTree/RangesInDataPart.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <base/getThreadId.h>\n #include <Common/ElapsedTimeProfileEventIncrement.h>\n #include <Common/logger_useful.h>\n@@ -108,22 +109,22 @@ MergeTreeReadTask::Readers MergeTreePrefetchedReadPool::PrefetchedReaders::get()\n \n MergeTreePrefetchedReadPool::MergeTreePrefetchedReadPool(\n     RangesInDataParts && parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & settings_,\n     const ContextPtr & context_)\n     : MergeTreeReadPoolBase(\n         std::move(parts_),\n+        std::move(shared_virtual_fields_),\n         storage_snapshot_,\n         prewhere_info_,\n         actions_settings_,\n         reader_settings_,\n         column_names_,\n-        virtual_column_names_,\n         settings_,\n         context_)\n     , WithContext(context_)\n@@ -375,7 +376,7 @@ void MergeTreePrefetchedReadPool::fillPerPartStatistics()\n             update_stat_for_column(column.name);\n \n         if (reader_settings.apply_deleted_mask && read_info.data_part->hasLightweightDelete())\n-            update_stat_for_column(LightweightDeleteDescription::FILTER_COLUMN.name);\n+            update_stat_for_column(RowExistsColumn::name);\n \n         for (const auto & pre_columns : read_info.task_columns.pre_columns)\n             for (const auto & column : pre_columns)\ndiff --git a/src/Storages/MergeTree/MergeTreePrefetchedReadPool.h b/src/Storages/MergeTree/MergeTreePrefetchedReadPool.h\nindex 378034c5eae5..0c8a6716d407 100644\n--- a/src/Storages/MergeTree/MergeTreePrefetchedReadPool.h\n+++ b/src/Storages/MergeTree/MergeTreePrefetchedReadPool.h\n@@ -18,12 +18,12 @@ class MergeTreePrefetchedReadPool : public MergeTreeReadPoolBase, private WithCo\n public:\n     MergeTreePrefetchedReadPool(\n         RangesInDataParts && parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \n@@ -67,7 +67,7 @@ class MergeTreePrefetchedReadPool : public MergeTreeReadPoolBase, private WithCo\n \n     struct ThreadTask\n     {\n-        using InfoPtr = MergeTreeReadTask::InfoPtr;\n+        using InfoPtr = MergeTreeReadTaskInfoPtr;\n \n         ThreadTask(InfoPtr read_info_, MarkRanges ranges_, Priority priority_)\n             : read_info(std::move(read_info_)), ranges(std::move(ranges_)), priority(priority_)\ndiff --git a/src/Storages/MergeTree/MergeTreeRangeReader.cpp b/src/Storages/MergeTree/MergeTreeRangeReader.cpp\nindex 50d1216cdc28..6932762f58b4 100644\n--- a/src/Storages/MergeTree/MergeTreeRangeReader.cpp\n+++ b/src/Storages/MergeTree/MergeTreeRangeReader.cpp\n@@ -362,7 +362,7 @@ void MergeTreeRangeReader::ReadResult::shrink(Columns & old_columns, const NumRo\n     }\n }\n \n-/// The main invariant of the data in the read result is that he number of rows is\n+/// The main invariant of the data in the read result is that the number of rows is\n /// either equal to total_rows_per_granule (if filter has not been applied) or to the number of\n /// 1s in the filter (if filter has been applied).\n void MergeTreeRangeReader::ReadResult::checkInternalConsistency() const\n@@ -803,8 +803,7 @@ MergeTreeRangeReader::MergeTreeRangeReader(\n     IMergeTreeReader * merge_tree_reader_,\n     MergeTreeRangeReader * prev_reader_,\n     const PrewhereExprStep * prewhere_info_,\n-    bool last_reader_in_chain_,\n-    const Names & non_const_virtual_column_names_)\n+    bool last_reader_in_chain_)\n     : merge_tree_reader(merge_tree_reader_)\n     , index_granularity(&(merge_tree_reader->data_part_info_for_read->getIndexGranularity()))\n     , prev_reader(prev_reader_)\n@@ -821,21 +820,6 @@ MergeTreeRangeReader::MergeTreeRangeReader(\n         result_sample_block.insert({name_and_type.type->createColumn(), name_and_type.type, name_and_type.name});\n     }\n \n-    for (const auto & column_name : non_const_virtual_column_names_)\n-    {\n-        if (result_sample_block.has(column_name))\n-            continue;\n-\n-        non_const_virtual_column_names.push_back(column_name);\n-\n-        if (column_name == \"_part_offset\" && !prev_reader)\n-        {\n-            /// _part_offset column is filled by the first reader.\n-            read_sample_block.insert(ColumnWithTypeAndName(ColumnUInt64::create(), std::make_shared<DataTypeUInt64>(), column_name));\n-            result_sample_block.insert(ColumnWithTypeAndName(ColumnUInt64::create(), std::make_shared<DataTypeUInt64>(), column_name));\n-        }\n-    }\n-\n     if (prewhere_info)\n     {\n         const auto & step = *prewhere_info;\n@@ -1001,6 +985,8 @@ MergeTreeRangeReader::ReadResult MergeTreeRangeReader::read(size_t max_rows, Mar\n             if (num_read_rows == 0)\n                 num_read_rows = read_result.num_rows;\n \n+            merge_tree_reader->fillVirtualColumns(columns, num_read_rows);\n+\n             /// fillMissingColumns() must be called after reading but befoe any filterings because\n             /// some columns (e.g. arrays) might be only partially filled and thus not be valid and\n             /// fillMissingColumns() fixes this.\n@@ -1050,23 +1036,23 @@ MergeTreeRangeReader::ReadResult MergeTreeRangeReader::read(size_t max_rows, Mar\n             return read_result;\n \n         {\n-            /// Physical columns go first and then some virtual columns follow\n-            size_t physical_columns_count = merge_tree_reader->getColumns().size();\n-            Columns physical_columns(read_result.columns.begin(), read_result.columns.begin() + physical_columns_count);\n+            size_t columns_count = merge_tree_reader->getColumns().size();\n+            Columns columns(read_result.columns.begin(), read_result.columns.begin() + columns_count);\n+            merge_tree_reader->fillVirtualColumns(columns, read_result.num_rows);\n \n             bool should_evaluate_missing_defaults;\n-            merge_tree_reader->fillMissingColumns(physical_columns, should_evaluate_missing_defaults, read_result.num_rows);\n+            merge_tree_reader->fillMissingColumns(columns, should_evaluate_missing_defaults, read_result.num_rows);\n \n             /// If some columns absent in part, then evaluate default values\n             if (should_evaluate_missing_defaults)\n-                merge_tree_reader->evaluateMissingDefaults({}, physical_columns);\n+                merge_tree_reader->evaluateMissingDefaults({}, columns);\n \n             /// If result not empty, then apply on-fly alter conversions if any required\n             if (!prewhere_info || prewhere_info->perform_alter_conversions)\n-                merge_tree_reader->performRequiredConversions(physical_columns);\n+                merge_tree_reader->performRequiredConversions(columns);\n \n-            for (size_t i = 0; i < physical_columns.size(); ++i)\n-                read_result.columns[i] = std::move(physical_columns[i]);\n+            for (size_t i = 0; i < columns.size(); ++i)\n+                read_result.columns[i] = std::move(columns[i]);\n         }\n \n         size_t total_bytes = 0;\n@@ -1158,12 +1144,17 @@ MergeTreeRangeReader::ReadResult MergeTreeRangeReader::startReadingChain(size_t\n         result.adjustLastGranule();\n \n     if (read_sample_block.has(\"_part_offset\"))\n-        fillPartOffsetColumn(result, leading_begin_part_offset, leading_end_part_offset);\n+    {\n+        size_t pos = read_sample_block.getPositionByName(\"_part_offset\");\n+        chassert(pos < result.columns.size());\n+        chassert(result.columns[pos] == nullptr);\n+        result.columns[pos] = createPartOffsetColumn(result, leading_begin_part_offset, leading_end_part_offset);\n+    }\n \n     return result;\n }\n \n-void MergeTreeRangeReader::fillPartOffsetColumn(ReadResult & result, UInt64 leading_begin_part_offset, UInt64 leading_end_part_offset)\n+ColumnPtr MergeTreeRangeReader::createPartOffsetColumn(ReadResult & result, UInt64 leading_begin_part_offset, UInt64 leading_end_part_offset)\n {\n     size_t num_rows = result.numReadRows();\n \n@@ -1189,7 +1180,7 @@ void MergeTreeRangeReader::fillPartOffsetColumn(ReadResult & result, UInt64 lead\n             *pos++ = start_part_offset++;\n     }\n \n-    result.columns.emplace_back(std::move(column));\n+    return column;\n }\n \n Columns MergeTreeRangeReader::continueReadingChain(const ReadResult & result, size_t & num_rows)\n@@ -1203,7 +1194,7 @@ Columns MergeTreeRangeReader::continueReadingChain(const ReadResult & result, si\n \n     if (result.rows_per_granule.empty())\n     {\n-        /// If zero rows were read on prev step, than there is no more rows to read.\n+        /// If zero rows were read on prev step, there is no more rows to read.\n         /// Last granule may have less rows than index_granularity, so finish reading manually.\n         stream.finish();\n         return columns;\ndiff --git a/src/Storages/MergeTree/MergeTreeRangeReader.h b/src/Storages/MergeTree/MergeTreeRangeReader.h\nindex 79ed18f4d1f4..688a6b0922b7 100644\n--- a/src/Storages/MergeTree/MergeTreeRangeReader.h\n+++ b/src/Storages/MergeTree/MergeTreeRangeReader.h\n@@ -101,8 +101,7 @@ class MergeTreeRangeReader\n         IMergeTreeReader * merge_tree_reader_,\n         MergeTreeRangeReader * prev_reader_,\n         const PrewhereExprStep * prewhere_info_,\n-        bool last_reader_in_chain_,\n-        const Names & non_const_virtual_column_names);\n+        bool last_reader_in_chain_);\n \n     MergeTreeRangeReader() = default;\n \n@@ -309,7 +308,7 @@ class MergeTreeRangeReader\n     ReadResult startReadingChain(size_t max_rows, MarkRanges & ranges);\n     Columns continueReadingChain(const ReadResult & result, size_t & num_rows);\n     void executePrewhereActionsAndFilterColumns(ReadResult & result) const;\n-    void fillPartOffsetColumn(ReadResult & result, UInt64 leading_begin_part_offset, UInt64 leading_end_part_offset);\n+    ColumnPtr createPartOffsetColumn(ReadResult & result, UInt64 leading_begin_part_offset, UInt64 leading_end_part_offset);\n \n     IMergeTreeReader * merge_tree_reader = nullptr;\n     const MergeTreeIndexGranularity * index_granularity = nullptr;\n@@ -323,7 +322,6 @@ class MergeTreeRangeReader\n \n     bool last_reader_in_chain = false;\n     bool is_initialized = false;\n-    Names non_const_virtual_column_names;\n \n     LoggerPtr log = getLogger(\"MergeTreeRangeReader\");\n };\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPool.cpp b/src/Storages/MergeTree/MergeTreeReadPool.cpp\nindex 68d57bf7b060..e525f7f5f657 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPool.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPool.cpp\n@@ -35,22 +35,22 @@ size_t getApproxSizeOfPart(const IMergeTreeDataPart & part, const Names & column\n \n MergeTreeReadPool::MergeTreeReadPool(\n     RangesInDataParts && parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & settings_,\n     const ContextPtr & context_)\n     : MergeTreeReadPoolBase(\n         std::move(parts_),\n+        std::move(shared_virtual_fields_),\n         storage_snapshot_,\n         prewhere_info_,\n         actions_settings_,\n         reader_settings_,\n         column_names_,\n-        virtual_column_names_,\n         settings_,\n         context_)\n     , min_marks_for_concurrent_read(pool_settings.min_marks_for_concurrent_read)\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPool.h b/src/Storages/MergeTree/MergeTreeReadPool.h\nindex e45ccad912f1..cb0e8a9657fa 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPool.h\n+++ b/src/Storages/MergeTree/MergeTreeReadPool.h\n@@ -26,12 +26,12 @@ class MergeTreeReadPool : public MergeTreeReadPoolBase\n \n     MergeTreeReadPool(\n         RangesInDataParts && parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolBase.cpp b/src/Storages/MergeTree/MergeTreeReadPoolBase.cpp\nindex 94942c4aa0be..0cbb0a86b2f4 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolBase.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolBase.cpp\n@@ -8,21 +8,21 @@ namespace DB\n \n MergeTreeReadPoolBase::MergeTreeReadPoolBase(\n     RangesInDataParts && parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & pool_settings_,\n     const ContextPtr & context_)\n     : parts_ranges(std::move(parts_))\n+    , shared_virtual_fields(std::move(shared_virtual_fields_))\n     , storage_snapshot(storage_snapshot_)\n     , prewhere_info(prewhere_info_)\n     , actions_settings(actions_settings_)\n     , reader_settings(reader_settings_)\n     , column_names(column_names_)\n-    , virtual_column_names(virtual_column_names_)\n     , pool_settings(pool_settings_)\n     , owned_mark_cache(context_->getGlobalContext()->getMarkCache())\n     , owned_uncompressed_cache(pool_settings_.use_uncompressed_cache ? context_->getGlobalContext()->getUncompressedCache() : nullptr)\n@@ -45,7 +45,7 @@ void MergeTreeReadPoolBase::fillPerPartInfos()\n         assertSortedAndNonIntersecting(part_with_ranges.ranges);\n #endif\n \n-        MergeTreeReadTask::Info read_task_info;\n+        MergeTreeReadTaskInfo read_task_info;\n \n         read_task_info.data_part = part_with_ranges.data_part;\n         read_task_info.part_index_in_query = part_with_ranges.part_index_in_query;\n@@ -54,9 +54,16 @@ void MergeTreeReadPoolBase::fillPerPartInfos()\n         LoadedMergeTreeDataPartInfoForReader part_info(part_with_ranges.data_part, part_with_ranges.alter_conversions);\n \n         read_task_info.task_columns = getReadTaskColumns(\n-            part_info, storage_snapshot, column_names, virtual_column_names,\n-            prewhere_info, actions_settings,\n-            reader_settings, /*with_subcolumns=*/ true);\n+            part_info,\n+            storage_snapshot,\n+            column_names,\n+            prewhere_info,\n+            actions_settings,\n+            reader_settings,\n+            /*with_subcolumns=*/true);\n+\n+        read_task_info.const_virtual_fields = shared_virtual_fields;\n+        read_task_info.const_virtual_fields.emplace(\"_part_index\", read_task_info.part_index_in_query);\n \n         if (pool_settings.preferred_block_size_bytes > 0)\n         {\n@@ -76,7 +83,7 @@ void MergeTreeReadPoolBase::fillPerPartInfos()\n         }\n \n         is_part_on_remote_disk.push_back(part_with_ranges.data_part->isStoredOnRemoteDisk());\n-        per_part_infos.push_back(std::make_shared<MergeTreeReadTask::Info>(std::move(read_task_info)));\n+        per_part_infos.push_back(std::make_shared<MergeTreeReadTaskInfo>(std::move(read_task_info)));\n     }\n }\n \n@@ -98,7 +105,7 @@ std::vector<size_t> MergeTreeReadPoolBase::getPerPartSumMarks() const\n }\n \n MergeTreeReadTaskPtr MergeTreeReadPoolBase::createTask(\n-    MergeTreeReadTask::InfoPtr read_info,\n+    MergeTreeReadTaskInfoPtr read_info,\n     MarkRanges ranges,\n     MergeTreeReadTask * previous_task) const\n {\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolBase.h b/src/Storages/MergeTree/MergeTreeReadPoolBase.h\nindex 0081063cd379..1b5bfec58980 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolBase.h\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolBase.h\n@@ -23,12 +23,12 @@ class MergeTreeReadPoolBase : public IMergeTreeReadPool\n \n     MergeTreeReadPoolBase(\n         RangesInDataParts && parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \n@@ -37,12 +37,12 @@ class MergeTreeReadPoolBase : public IMergeTreeReadPool\n protected:\n     /// Initialized in constructor\n     const RangesInDataParts parts_ranges;\n+    const VirtualFields shared_virtual_fields;\n     const StorageSnapshotPtr storage_snapshot;\n     const PrewhereInfoPtr prewhere_info;\n     const ExpressionActionsSettings actions_settings;\n     const MergeTreeReaderSettings reader_settings;\n     const Names column_names;\n-    const Names virtual_column_names;\n     const PoolSettings pool_settings;\n     const MarkCachePtr owned_mark_cache;\n     const UncompressedCachePtr owned_uncompressed_cache;\n@@ -52,13 +52,13 @@ class MergeTreeReadPoolBase : public IMergeTreeReadPool\n     std::vector<size_t> getPerPartSumMarks() const;\n \n     MergeTreeReadTaskPtr createTask(\n-        MergeTreeReadTask::InfoPtr read_info,\n+        MergeTreeReadTaskInfoPtr read_info,\n         MarkRanges ranges,\n         MergeTreeReadTask * previous_task) const;\n \n     MergeTreeReadTask::Extras getExtras() const;\n \n-    std::vector<MergeTreeReadTask::InfoPtr> per_part_infos;\n+    std::vector<MergeTreeReadTaskInfoPtr> per_part_infos;\n     std::vector<bool> is_part_on_remote_disk;\n \n     ReadBufferFromFileBase::ProfileCallback profile_callback;\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolInOrder.cpp b/src/Storages/MergeTree/MergeTreeReadPoolInOrder.cpp\nindex 1b621ad5055d..4c0391ffa571 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolInOrder.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolInOrder.cpp\n@@ -12,22 +12,22 @@ MergeTreeReadPoolInOrder::MergeTreeReadPoolInOrder(\n     bool has_limit_below_one_block_,\n     MergeTreeReadType read_type_,\n     RangesInDataParts parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & settings_,\n     const ContextPtr & context_)\n     : MergeTreeReadPoolBase(\n         std::move(parts_),\n+        std::move(shared_virtual_fields_),\n         storage_snapshot_,\n         prewhere_info_,\n         actions_settings_,\n         reader_settings_,\n         column_names_,\n-        virtual_column_names_,\n         settings_,\n         context_)\n     , has_limit_below_one_block(has_limit_below_one_block_)\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolInOrder.h b/src/Storages/MergeTree/MergeTreeReadPoolInOrder.h\nindex d9cc1ba4984f..9fedf396a6bd 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolInOrder.h\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolInOrder.h\n@@ -11,12 +11,12 @@ class MergeTreeReadPoolInOrder : public MergeTreeReadPoolBase\n         bool has_limit_below_one_block_,\n         MergeTreeReadType read_type_,\n         RangesInDataParts parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.cpp b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.cpp\nindex 47436ed14075..38035d97f567 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.cpp\n@@ -13,22 +13,22 @@ namespace ErrorCodes\n MergeTreeReadPoolParallelReplicas::MergeTreeReadPoolParallelReplicas(\n     ParallelReadingExtension extension_,\n     RangesInDataParts && parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & settings_,\n     const ContextPtr & context_)\n     : MergeTreeReadPoolBase(\n         std::move(parts_),\n+        std::move(shared_virtual_fields_),\n         storage_snapshot_,\n         prewhere_info_,\n         actions_settings_,\n         reader_settings_,\n         column_names_,\n-        virtual_column_names_,\n         settings_,\n         context_)\n     , extension(std::move(extension_))\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.h b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.h\nindex 6a548dffe374..ca159edb91c8 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.h\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.h\n@@ -11,12 +11,12 @@ class MergeTreeReadPoolParallelReplicas : public MergeTreeReadPoolBase\n     MergeTreeReadPoolParallelReplicas(\n         ParallelReadingExtension extension_,\n         RangesInDataParts && parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.cpp b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.cpp\nindex a822a5179337..01c0a9f91be6 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.cpp\n@@ -12,22 +12,22 @@ MergeTreeReadPoolParallelReplicasInOrder::MergeTreeReadPoolParallelReplicasInOrd\n     ParallelReadingExtension extension_,\n     CoordinationMode mode_,\n     RangesInDataParts parts_,\n+    VirtualFields shared_virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReaderSettings & reader_settings_,\n     const Names & column_names_,\n-    const Names & virtual_column_names_,\n     const PoolSettings & settings_,\n     const ContextPtr & context_)\n     : MergeTreeReadPoolBase(\n         std::move(parts_),\n+        std::move(shared_virtual_fields_),\n         storage_snapshot_,\n         prewhere_info_,\n         actions_settings_,\n         reader_settings_,\n         column_names_,\n-        virtual_column_names_,\n         settings_,\n         context_)\n     , extension(std::move(extension_))\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.h b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.h\nindex 3e5f8f5dfba4..4fe3f7a699c8 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.h\n+++ b/src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.h\n@@ -12,12 +12,12 @@ class MergeTreeReadPoolParallelReplicasInOrder : public MergeTreeReadPoolBase\n         ParallelReadingExtension extension_,\n         CoordinationMode mode_,\n         RangesInDataParts parts_,\n+        VirtualFields shared_virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReaderSettings & reader_settings_,\n         const Names & column_names_,\n-        const Names & virtual_column_names_,\n         const PoolSettings & settings_,\n         const ContextPtr & context_);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeReadTask.cpp b/src/Storages/MergeTree/MergeTreeReadTask.cpp\nindex 41c7531b6a66..08b30e445e27 100644\n--- a/src/Storages/MergeTree/MergeTreeReadTask.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadTask.cpp\n@@ -1,5 +1,6 @@\n #include <Storages/MergeTree/MergeTreeReadTask.h>\n #include <Storages/MergeTree/MergeTreeBlockReadUtils.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Common/Exception.h>\n \n namespace DB\n@@ -10,7 +11,7 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-String MergeTreeReadTask::Columns::dump() const\n+String MergeTreeReadTaskColumns::dump() const\n {\n     WriteBufferFromOwnString s;\n     for (size_t i = 0; i < pre_columns.size(); ++i)\n@@ -22,7 +23,7 @@ String MergeTreeReadTask::Columns::dump() const\n }\n \n MergeTreeReadTask::MergeTreeReadTask(\n-    InfoPtr info_,\n+    MergeTreeReadTaskInfoPtr info_,\n     Readers readers_,\n     MarkRanges mark_ranges_,\n     MergeTreeBlockSizePredictorPtr size_predictor_)\n@@ -34,23 +35,30 @@ MergeTreeReadTask::MergeTreeReadTask(\n }\n \n MergeTreeReadTask::Readers MergeTreeReadTask::createReaders(\n-    const InfoPtr & read_info, const Extras & extras, const MarkRanges & ranges)\n+    const MergeTreeReadTaskInfoPtr & read_info, const Extras & extras, const MarkRanges & ranges)\n {\n     Readers new_readers;\n \n     auto create_reader = [&](const NamesAndTypesList & columns_to_read)\n     {\n         return read_info->data_part->getReader(\n-            columns_to_read, extras.storage_snapshot, ranges,\n-            extras.uncompressed_cache, extras.mark_cache,\n-            read_info->alter_conversions, extras.reader_settings, extras.value_size_map, extras.profile_callback);\n+            columns_to_read,\n+            extras.storage_snapshot,\n+            ranges,\n+            read_info->const_virtual_fields,\n+            extras.uncompressed_cache,\n+            extras.mark_cache,\n+            read_info->alter_conversions,\n+            extras.reader_settings,\n+            extras.value_size_map,\n+            extras.profile_callback);\n     };\n \n     new_readers.main = create_reader(read_info->task_columns.columns);\n \n     /// Add lightweight delete filtering step\n     if (extras.reader_settings.apply_deleted_mask && read_info->data_part->hasLightweightDelete())\n-        new_readers.prewhere.push_back(create_reader({LightweightDeleteDescription::FILTER_COLUMN}));\n+        new_readers.prewhere.push_back(create_reader({{RowExistsColumn::name, RowExistsColumn::type}}));\n \n     for (const auto & pre_columns_per_step : read_info->task_columns.pre_columns)\n         new_readers.prewhere.push_back(create_reader(pre_columns_per_step));\n@@ -58,10 +66,8 @@ MergeTreeReadTask::Readers MergeTreeReadTask::createReaders(\n     return new_readers;\n }\n \n-MergeTreeReadTask::RangeReaders MergeTreeReadTask::createRangeReaders(\n-    const Readers & task_readers,\n-    const PrewhereExprInfo & prewhere_actions,\n-    const Names & non_const_virtual_column_names)\n+MergeTreeReadTask::RangeReaders\n+MergeTreeReadTask::createRangeReaders(const Readers & task_readers, const PrewhereExprInfo & prewhere_actions)\n {\n     MergeTreeReadTask::RangeReaders new_range_readers;\n     if (prewhere_actions.steps.size() != task_readers.prewhere.size())\n@@ -77,10 +83,7 @@ MergeTreeReadTask::RangeReaders MergeTreeReadTask::createRangeReaders(\n     {\n         last_reader = task_readers.main->getColumns().empty() && (i + 1 == prewhere_actions.steps.size());\n \n-        MergeTreeRangeReader current_reader(\n-            task_readers.prewhere[i].get(),\n-            prev_reader, prewhere_actions.steps[i].get(),\n-            last_reader, non_const_virtual_column_names);\n+        MergeTreeRangeReader current_reader(task_readers.prewhere[i].get(), prev_reader, prewhere_actions.steps[i].get(), last_reader);\n \n         new_range_readers.prewhere.push_back(std::move(current_reader));\n         prev_reader = &new_range_readers.prewhere.back();\n@@ -88,11 +91,11 @@ MergeTreeReadTask::RangeReaders MergeTreeReadTask::createRangeReaders(\n \n     if (!last_reader)\n     {\n-        new_range_readers.main = MergeTreeRangeReader(task_readers.main.get(), prev_reader, nullptr, true, non_const_virtual_column_names);\n+        new_range_readers.main = MergeTreeRangeReader(task_readers.main.get(), prev_reader, nullptr, true);\n     }\n     else\n     {\n-        /// If all columns are read by prewhere range readers than move last prewhere range reader to main.\n+        /// If all columns are read by prewhere range readers, move last prewhere range reader to main.\n         new_range_readers.main = std::move(new_range_readers.prewhere.back());\n         new_range_readers.prewhere.pop_back();\n     }\n@@ -100,14 +103,12 @@ MergeTreeReadTask::RangeReaders MergeTreeReadTask::createRangeReaders(\n     return new_range_readers;\n }\n \n-void MergeTreeReadTask::initializeRangeReaders(\n-    const PrewhereExprInfo & prewhere_actions,\n-    const Names & non_const_virtual_column_names)\n+void MergeTreeReadTask::initializeRangeReaders(const PrewhereExprInfo & prewhere_actions)\n {\n     if (range_readers.main.isInitialized())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Range reader is already initialized\");\n \n-    range_readers = createRangeReaders(readers, prewhere_actions, non_const_virtual_column_names);\n+    range_readers = createRangeReaders(readers, prewhere_actions);\n }\n \n UInt64 MergeTreeReadTask::estimateNumRows(const BlockSizeParams & params) const\ndiff --git a/src/Storages/MergeTree/MergeTreeReadTask.h b/src/Storages/MergeTree/MergeTreeReadTask.h\nindex 3fe79f1087c1..c8bb501c0e84 100644\n--- a/src/Storages/MergeTree/MergeTreeReadTask.h\n+++ b/src/Storages/MergeTree/MergeTreeReadTask.h\n@@ -20,6 +20,8 @@ using MergeTreeBlockSizePredictorPtr = std::shared_ptr<MergeTreeBlockSizePredict\n class IMergeTreeDataPart;\n using DataPartPtr = std::shared_ptr<const IMergeTreeDataPart>;\n using MergeTreeReaderPtr = std::unique_ptr<IMergeTreeReader>;\n+using VirtualFields = std::unordered_map<String, Field>;\n+\n \n enum class MergeTreeReadType\n {\n@@ -40,36 +42,38 @@ enum class MergeTreeReadType\n     ParallelReplicas,\n };\n \n-/// A batch of work for MergeTreeSelectProcessor\n-struct MergeTreeReadTask : private boost::noncopyable\n+struct MergeTreeReadTaskColumns\n {\n-public:\n-    struct Columns\n-    {\n-        /// Column names to read during WHERE\n-        NamesAndTypesList columns;\n-        /// Column names to read during each PREWHERE step\n-        std::vector<NamesAndTypesList> pre_columns;\n+    /// Column names to read during WHERE\n+    NamesAndTypesList columns;\n+    /// Column names to read during each PREWHERE step\n+    std::vector<NamesAndTypesList> pre_columns;\n \n-        String dump() const;\n-    };\n+    String dump() const;\n+};\n \n-    struct Info\n-    {\n-        /// Data part which should be read while performing this task\n-        DataPartPtr data_part;\n-        /// For virtual `part_index` virtual column\n-        size_t part_index_in_query;\n-        /// Alter converversionss that should be applied on-fly for part.\n-        AlterConversionsPtr alter_conversions;\n-        /// Column names to read during PREWHERE and WHERE\n-        Columns task_columns;\n-        /// Shared initialized size predictor. It is copied for each new task.\n-        MergeTreeBlockSizePredictorPtr shared_size_predictor;\n-    };\n+struct MergeTreeReadTaskInfo\n+{\n+    /// Data part which should be read while performing this task\n+    DataPartPtr data_part;\n+    /// For `part_index` virtual column\n+    size_t part_index_in_query;\n+    /// Alter converversionss that should be applied on-fly for part.\n+    AlterConversionsPtr alter_conversions;\n+    /// Column names to read during PREWHERE and WHERE\n+    MergeTreeReadTaskColumns task_columns;\n+    /// Shared initialized size predictor. It is copied for each new task.\n+    MergeTreeBlockSizePredictorPtr shared_size_predictor;\n+    /// TODO: comment\n+    VirtualFields const_virtual_fields;\n+};\n \n-    using InfoPtr = std::shared_ptr<const Info>;\n+using MergeTreeReadTaskInfoPtr = std::shared_ptr<const MergeTreeReadTaskInfo>;\n \n+/// A batch of work for MergeTreeSelectProcessor\n+struct MergeTreeReadTask : private boost::noncopyable\n+{\n+public:\n     /// Extra params that required for creation of reader.\n     struct Extras\n     {\n@@ -115,27 +119,32 @@ struct MergeTreeReadTask : private boost::noncopyable\n         size_t num_read_bytes = 0;\n     };\n \n-    MergeTreeReadTask(InfoPtr info_, Readers readers_, MarkRanges mark_ranges_, MergeTreeBlockSizePredictorPtr size_predictor_);\n+    MergeTreeReadTask(\n+        MergeTreeReadTaskInfoPtr info_,\n+        Readers readers_,\n+        MarkRanges mark_ranges_,\n+\n+        MergeTreeBlockSizePredictorPtr size_predictor_);\n \n-    void initializeRangeReaders(const PrewhereExprInfo & prewhere_actions, const Names & non_const_virtual_column_names);\n+    void initializeRangeReaders(const PrewhereExprInfo & prewhere_actions);\n \n     BlockAndProgress read(const BlockSizeParams & params);\n     bool isFinished() const { return mark_ranges.empty() && range_readers.main.isCurrentRangeFinished(); }\n \n-    const Info & getInfo() const { return *info; }\n+    const MergeTreeReadTaskInfo & getInfo() const { return *info; }\n     const MergeTreeRangeReader & getMainRangeReader() const { return range_readers.main; }\n     const IMergeTreeReader & getMainReader() const { return *readers.main; }\n \n     Readers releaseReaders() { return std::move(readers); }\n \n-    static Readers createReaders(const InfoPtr & read_info, const Extras & extras, const MarkRanges & ranges);\n-    static RangeReaders createRangeReaders(const Readers & readers, const PrewhereExprInfo & prewhere_actions, const Names & non_const_virtual_column_names);\n+    static Readers createReaders(const MergeTreeReadTaskInfoPtr & read_info, const Extras & extras, const MarkRanges & ranges);\n+    static RangeReaders createRangeReaders(const Readers & readers, const PrewhereExprInfo & prewhere_actions);\n \n private:\n     UInt64 estimateNumRows(const BlockSizeParams & params) const;\n \n     /// Shared information required for reading.\n-    InfoPtr info;\n+    MergeTreeReadTaskInfoPtr info;\n \n     /// Readers for data_part of this task.\n     /// May be reused and released to the next task.\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\nindex 020480092967..638243667226 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n@@ -17,6 +17,7 @@ namespace ErrorCodes\n MergeTreeReaderCompact::MergeTreeReaderCompact(\n     MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n     NamesAndTypesList columns_,\n+    const VirtualFields & virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     UncompressedCache * uncompressed_cache_,\n     MarkCache * mark_cache_,\n@@ -29,6 +30,7 @@ MergeTreeReaderCompact::MergeTreeReaderCompact(\n     : IMergeTreeReader(\n         data_part_info_for_read_,\n         columns_,\n+        virtual_fields_,\n         storage_snapshot_,\n         uncompressed_cache_,\n         mark_cache_,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompact.h b/src/Storages/MergeTree/MergeTreeReaderCompact.h\nindex dace4ec468e3..769e6a08be48 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompact.h\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompact.h\n@@ -21,6 +21,7 @@ class MergeTreeReaderCompact : public IMergeTreeReader\n     MergeTreeReaderCompact(\n         MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n         NamesAndTypesList columns_,\n+        const VirtualFields & virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         UncompressedCache * uncompressed_cache_,\n         MarkCache * mark_cache_,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderInMemory.cpp b/src/Storages/MergeTree/MergeTreeReaderInMemory.cpp\nindex bacd86511f5b..91fc8966a7a9 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderInMemory.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderInMemory.cpp\n@@ -19,12 +19,14 @@ MergeTreeReaderInMemory::MergeTreeReaderInMemory(\n     MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n     DataPartInMemoryPtr data_part_,\n     NamesAndTypesList columns_,\n+    const VirtualFields & virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     MarkRanges mark_ranges_,\n     MergeTreeReaderSettings settings_)\n     : IMergeTreeReader(\n         data_part_info_for_read_,\n         columns_,\n+        virtual_fields_,\n         storage_snapshot_,\n         nullptr,\n         nullptr,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderInMemory.h b/src/Storages/MergeTree/MergeTreeReaderInMemory.h\nindex e26a98f0916d..cc1e2e9e4e28 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderInMemory.h\n+++ b/src/Storages/MergeTree/MergeTreeReaderInMemory.h\n@@ -18,6 +18,7 @@ class MergeTreeReaderInMemory : public IMergeTreeReader\n         MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n         DataPartInMemoryPtr data_part_,\n         NamesAndTypesList columns_,\n+        const VirtualFields & virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         MarkRanges mark_ranges_,\n         MergeTreeReaderSettings settings_);\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderWide.cpp b/src/Storages/MergeTree/MergeTreeReaderWide.cpp\nindex 640432ef755a..d34a58a25b0d 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderWide.cpp\n@@ -24,6 +24,7 @@ namespace\n MergeTreeReaderWide::MergeTreeReaderWide(\n     MergeTreeDataPartInfoForReaderPtr data_part_info_,\n     NamesAndTypesList columns_,\n+    const VirtualFields & virtual_fields_,\n     const StorageSnapshotPtr & storage_snapshot_,\n     UncompressedCache * uncompressed_cache_,\n     MarkCache * mark_cache_,\n@@ -35,6 +36,7 @@ MergeTreeReaderWide::MergeTreeReaderWide(\n     : IMergeTreeReader(\n         data_part_info_,\n         columns_,\n+        virtual_fields_,\n         storage_snapshot_,\n         uncompressed_cache_,\n         mark_cache_,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderWide.h b/src/Storages/MergeTree/MergeTreeReaderWide.h\nindex 2a850cc2814e..a9a5526dd65b 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderWide.h\n+++ b/src/Storages/MergeTree/MergeTreeReaderWide.h\n@@ -17,6 +17,7 @@ class MergeTreeReaderWide : public IMergeTreeReader\n     MergeTreeReaderWide(\n         MergeTreeDataPartInfoForReaderPtr data_part_info_for_read_,\n         NamesAndTypesList columns_,\n+        const VirtualFields & virtual_fields_,\n         const StorageSnapshotPtr & storage_snapshot_,\n         UncompressedCache * uncompressed_cache_,\n         MarkCache * mark_cache_,\ndiff --git a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\nindex 64cec946991c..fce733d47b7e 100644\n--- a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n@@ -12,7 +12,7 @@\n #include <Processors/Chunk.h>\n #include <Processors/QueryPlan/SourceStepWithFilter.h>\n #include <Processors/Transforms/AggregatingTransform.h>\n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <city.h>\n \n namespace DB\n@@ -20,41 +20,26 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int LOGICAL_ERROR;\n     extern const int QUERY_WAS_CANCELLED;\n }\n \n-static void injectNonConstVirtualColumns(\n-    size_t rows,\n-    Block & block,\n-    const Names & virtual_columns,\n-    MergeTreeReadTask * task = nullptr);\n-\n-static void injectPartConstVirtualColumns(\n-    size_t rows,\n-    Block & block,\n-    MergeTreeReadTask * task,\n-    const DataTypePtr & partition_value_type,\n-    const Names & virtual_columns);\n-\n MergeTreeSelectProcessor::MergeTreeSelectProcessor(\n     MergeTreeReadPoolPtr pool_,\n     MergeTreeSelectAlgorithmPtr algorithm_,\n-    const MergeTreeData & storage_,\n+    const StorageSnapshotPtr & storage_snapshot_,\n     const PrewhereInfoPtr & prewhere_info_,\n     const ExpressionActionsSettings & actions_settings_,\n     const MergeTreeReadTask::BlockSizeParams & block_size_params_,\n-    const MergeTreeReaderSettings & reader_settings_,\n-    const Names & virt_column_names_)\n+    const MergeTreeReaderSettings & reader_settings_)\n     : pool(std::move(pool_))\n     , algorithm(std::move(algorithm_))\n+    , storage_snapshot(storage_snapshot_)\n     , prewhere_info(prewhere_info_)\n     , actions_settings(actions_settings_)\n     , prewhere_actions(getPrewhereActions(prewhere_info, actions_settings, reader_settings_.enable_multiple_prewhere_read_steps))\n     , reader_settings(reader_settings_)\n     , block_size_params(block_size_params_)\n-    , virt_column_names(virt_column_names_)\n-    , partition_value_type(storage_.getPartitionValueType())\n+    , result_header(transformHeader(pool->getHeader(), prewhere_info))\n {\n     if (reader_settings.apply_deleted_mask)\n     {\n@@ -62,7 +47,7 @@ MergeTreeSelectProcessor::MergeTreeSelectProcessor(\n         {\n             .type = PrewhereExprStep::Filter,\n             .actions = nullptr,\n-            .filter_column_name = LightweightDeleteDescription::FILTER_COLUMN.name,\n+            .filter_column_name = RowExistsColumn::name,\n             .remove_filter_column = true,\n             .need_filter = true,\n             .perform_alter_conversions = true,\n@@ -71,16 +56,6 @@ MergeTreeSelectProcessor::MergeTreeSelectProcessor(\n         lightweight_delete_filter_step = std::make_shared<PrewhereExprStep>(std::move(step));\n     }\n \n-    header_without_const_virtual_columns = SourceStepWithFilter::applyPrewhereActions(pool->getHeader(), prewhere_info);\n-    size_t non_const_columns_offset = header_without_const_virtual_columns.columns();\n-    injectNonConstVirtualColumns(0, header_without_const_virtual_columns, virt_column_names);\n-\n-    for (size_t col_num = non_const_columns_offset; col_num < header_without_const_virtual_columns.columns(); ++col_num)\n-        non_const_virtual_column_names.emplace_back(header_without_const_virtual_columns.getByPosition(col_num).name);\n-\n-    result_header = header_without_const_virtual_columns;\n-    injectPartConstVirtualColumns(0, result_header, nullptr, partition_value_type, virt_column_names);\n-\n     if (!prewhere_actions.steps.empty())\n         LOG_TRACE(log, \"PREWHERE condition was split into {} steps: {}\", prewhere_actions.steps.size(), prewhere_actions.dumpConditions());\n \n@@ -163,8 +138,6 @@ ChunkAndProgress MergeTreeSelectProcessor::read()\n \n         if (res.row_count)\n         {\n-            injectVirtualColumns(res.block, res.row_count, task.get(), partition_value_type, virt_column_names);\n-\n             /// Reorder the columns according to result_header\n             Columns ordered_columns;\n             ordered_columns.reserve(result_header.columns());\n@@ -198,209 +171,12 @@ void MergeTreeSelectProcessor::initializeRangeReaders()\n     for (const auto & step : prewhere_actions.steps)\n         all_prewhere_actions.steps.push_back(step);\n \n-    task->initializeRangeReaders(all_prewhere_actions, non_const_virtual_column_names);\n-}\n-\n-\n-namespace\n-{\n-    struct VirtualColumnsInserter\n-    {\n-        explicit VirtualColumnsInserter(Block & block_) : block(block_) {}\n-\n-        bool columnExists(const String & name) const { return block.has(name); }\n-\n-        void insertUInt8Column(const ColumnPtr & column, const String & name)\n-        {\n-            block.insert({column, std::make_shared<DataTypeUInt8>(), name});\n-        }\n-\n-        void insertUInt64Column(const ColumnPtr & column, const String & name)\n-        {\n-            block.insert({column, std::make_shared<DataTypeUInt64>(), name});\n-        }\n-\n-        void insertUUIDColumn(const ColumnPtr & column, const String & name)\n-        {\n-            block.insert({column, std::make_shared<DataTypeUUID>(), name});\n-        }\n-\n-        void insertLowCardinalityColumn(const ColumnPtr & column, const String & name)\n-        {\n-            block.insert({column, std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), name});\n-        }\n-\n-        void insertPartitionValueColumn(\n-            size_t rows, const Row & partition_value, const DataTypePtr & partition_value_type, const String & name)\n-        {\n-            ColumnPtr column;\n-            if (rows)\n-                column = partition_value_type->createColumnConst(rows, Tuple(partition_value.begin(), partition_value.end()))\n-                             ->convertToFullColumnIfConst();\n-            else\n-                column = partition_value_type->createColumn();\n-\n-            block.insert({column, partition_value_type, name});\n-        }\n-\n-        Block & block;\n-    };\n-}\n-\n-/// Adds virtual columns that are not const for all rows\n-static void injectNonConstVirtualColumns(\n-    size_t rows,\n-    Block & block,\n-    const Names & virtual_columns,\n-    MergeTreeReadTask * task)\n-{\n-    VirtualColumnsInserter inserter(block);\n-    for (const auto & virtual_column_name : virtual_columns)\n-    {\n-        if (virtual_column_name == \"_part_offset\")\n-        {\n-            if (!rows)\n-            {\n-                inserter.insertUInt64Column(DataTypeUInt64().createColumn(), virtual_column_name);\n-            }\n-            else\n-            {\n-                if (!inserter.columnExists(virtual_column_name))\n-                    throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                        \"Column {} must have been filled part reader\",\n-                        virtual_column_name);\n-            }\n-        }\n-\n-        if (virtual_column_name == LightweightDeleteDescription::FILTER_COLUMN.name)\n-        {\n-                /// If _row_exists column isn't present in the part then fill it here with 1s\n-                ColumnPtr column;\n-                if (rows)\n-                    column = LightweightDeleteDescription::FILTER_COLUMN.type->createColumnConst(rows, 1)->convertToFullColumnIfConst();\n-                else\n-                    column = LightweightDeleteDescription::FILTER_COLUMN.type->createColumn();\n-\n-                inserter.insertUInt8Column(column, virtual_column_name);\n-        }\n-\n-        if (virtual_column_name == BlockNumberColumn::name)\n-        {\n-            ColumnPtr column;\n-            if (rows)\n-            {\n-                size_t value = 0;\n-                if (task)\n-                {\n-                    value = task->getInfo().data_part ? task->getInfo().data_part->info.min_block : 0;\n-                }\n-                column = BlockNumberColumn::type->createColumnConst(rows, value)->convertToFullColumnIfConst();\n-            }\n-            else\n-                column = BlockNumberColumn::type->createColumn();\n-\n-            inserter.insertUInt64Column(column, virtual_column_name);\n-        }\n-    }\n-}\n-\n-/// Adds virtual columns that are const for the whole part\n-static void injectPartConstVirtualColumns(\n-    size_t rows,\n-    Block & block,\n-    MergeTreeReadTask * task,\n-    const DataTypePtr & partition_value_type,\n-    const Names & virtual_columns)\n-{\n-    VirtualColumnsInserter inserter(block);\n-    /// add virtual columns\n-    /// Except _sample_factor, which is added from the outside.\n-    if (!virtual_columns.empty())\n-    {\n-        if (unlikely(rows && !task))\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot insert virtual columns to non-empty chunk without specified task.\");\n-\n-        const IMergeTreeDataPart * part = nullptr;\n-\n-        if (rows)\n-        {\n-            part = task->getInfo().data_part.get();\n-            if (part->isProjectionPart())\n-                part = part->getParentPart();\n-        }\n-\n-        for (const auto & virtual_column_name : virtual_columns)\n-        {\n-            if (virtual_column_name == \"_part\")\n-            {\n-                ColumnPtr column;\n-                if (rows)\n-                    column = DataTypeLowCardinality{std::make_shared<DataTypeString>()}\n-                                 .createColumnConst(rows, part->name)\n-                                 ->convertToFullColumnIfConst();\n-                else\n-                    column = DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn();\n-\n-                inserter.insertLowCardinalityColumn(column, virtual_column_name);\n-            }\n-            else if (virtual_column_name == \"_part_index\")\n-            {\n-                ColumnPtr column;\n-                if (rows)\n-                    column = DataTypeUInt64().createColumnConst(rows, task->getInfo().part_index_in_query)->convertToFullColumnIfConst();\n-                else\n-                    column = DataTypeUInt64().createColumn();\n-\n-                inserter.insertUInt64Column(column, virtual_column_name);\n-            }\n-            else if (virtual_column_name == \"_part_uuid\")\n-            {\n-                ColumnPtr column;\n-                if (rows)\n-                    column = DataTypeUUID().createColumnConst(rows, part->uuid)->convertToFullColumnIfConst();\n-                else\n-                    column = DataTypeUUID().createColumn();\n-\n-                inserter.insertUUIDColumn(column, virtual_column_name);\n-            }\n-            else if (virtual_column_name == \"_partition_id\")\n-            {\n-                ColumnPtr column;\n-                if (rows)\n-                    column = DataTypeLowCardinality{std::make_shared<DataTypeString>()}\n-                                 .createColumnConst(rows, part->info.partition_id)\n-                                 ->convertToFullColumnIfConst();\n-                else\n-                    column = DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn();\n-\n-                inserter.insertLowCardinalityColumn(column, virtual_column_name);\n-            }\n-            else if (virtual_column_name == \"_partition_value\")\n-            {\n-                if (rows)\n-                    inserter.insertPartitionValueColumn(rows, part->partition.value, partition_value_type, virtual_column_name);\n-                else\n-                    inserter.insertPartitionValueColumn(rows, {}, partition_value_type, virtual_column_name);\n-            }\n-        }\n-    }\n-}\n-\n-void MergeTreeSelectProcessor::injectVirtualColumns(\n-    Block & block, size_t row_count, MergeTreeReadTask * task, const DataTypePtr & partition_value_type, const Names & virtual_columns)\n-{\n-    /// First add non-const columns that are filled by the range reader and then const columns that we will fill ourselves.\n-    /// Note that the order is important: virtual columns filled by the range reader must go first\n-    injectNonConstVirtualColumns(row_count, block, virtual_columns,task);\n-    injectPartConstVirtualColumns(row_count, block, task, partition_value_type, virtual_columns);\n+    task->initializeRangeReaders(all_prewhere_actions);\n }\n \n-Block MergeTreeSelectProcessor::transformHeader(\n-    Block block, const PrewhereInfoPtr & prewhere_info, const DataTypePtr & partition_value_type, const Names & virtual_columns)\n+Block MergeTreeSelectProcessor::transformHeader(Block block, const PrewhereInfoPtr & prewhere_info)\n {\n-    injectVirtualColumns(block, 0, nullptr, partition_value_type, virtual_columns);\n-    auto transformed = SourceStepWithFilter::applyPrewhereActions(std::move(block), prewhere_info);\n-    return transformed;\n+    return SourceStepWithFilter::applyPrewhereActions(std::move(block), prewhere_info);\n }\n \n }\ndiff --git a/src/Storages/MergeTree/MergeTreeSelectProcessor.h b/src/Storages/MergeTree/MergeTreeSelectProcessor.h\nindex b1606f983a1b..01bb3851e042 100644\n--- a/src/Storages/MergeTree/MergeTreeSelectProcessor.h\n+++ b/src/Storages/MergeTree/MergeTreeSelectProcessor.h\n@@ -41,21 +41,15 @@ class MergeTreeSelectProcessor : private boost::noncopyable\n     MergeTreeSelectProcessor(\n         MergeTreeReadPoolPtr pool_,\n         MergeTreeSelectAlgorithmPtr algorithm_,\n-        const MergeTreeData & storage_,\n+        const StorageSnapshotPtr & storage_snapshot_,\n         const PrewhereInfoPtr & prewhere_info_,\n         const ExpressionActionsSettings & actions_settings_,\n         const MergeTreeReadTask::BlockSizeParams & block_size_params_,\n-        const MergeTreeReaderSettings & reader_settings_,\n-        const Names & virt_column_names_);\n+        const MergeTreeReaderSettings & reader_settings_);\n \n     String getName() const;\n \n-    static Block transformHeader(\n-        Block block,\n-        const PrewhereInfoPtr & prewhere_info,\n-        const DataTypePtr & partition_value_type,\n-        const Names & virtual_columns);\n-\n+    static Block transformHeader(Block block, const PrewhereInfoPtr & prewhere_info);\n     Block getHeader() const { return result_header; }\n \n     ChunkAndProgress read();\n@@ -81,14 +75,12 @@ class MergeTreeSelectProcessor : private boost::noncopyable\n         size_t num_read_bytes = 0;\n     };\n \n-    /// Used for filling header with no rows as well as block with data\n-    static void injectVirtualColumns(Block & block, size_t row_count, MergeTreeReadTask * task, const DataTypePtr & partition_value_type, const Names & virtual_columns);\n-\n     /// Sets up range readers corresponding to data readers\n     void initializeRangeReaders();\n \n     const MergeTreeReadPoolPtr pool;\n     const MergeTreeSelectAlgorithmPtr algorithm;\n+    const StorageSnapshotPtr storage_snapshot;\n \n     const PrewhereInfoPtr prewhere_info;\n     const ExpressionActionsSettings actions_settings;\n@@ -96,17 +88,11 @@ class MergeTreeSelectProcessor : private boost::noncopyable\n \n     const MergeTreeReaderSettings reader_settings;\n     const MergeTreeReadTask::BlockSizeParams block_size_params;\n-    const Names virt_column_names;\n-    const DataTypePtr partition_value_type;\n \n     /// Current task to read from.\n     MergeTreeReadTaskPtr task;\n     /// This step is added when the part has lightweight delete mask\n     PrewhereExprStepPtr lightweight_delete_filter_step;\n-    /// These columns will be filled by the merge tree range reader\n-    Names non_const_virtual_column_names;\n-    /// This header is used for chunks from readFromPart().\n-    Block header_without_const_virtual_columns;\n     /// A result of getHeader(). A chunk which this header is returned from read().\n     Block result_header;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex d0fbc3160246..e5545a92aea4 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -2,6 +2,7 @@\n #include <Storages/MergeTree/MergeTreeBlockReadUtils.h>\n #include <Storages/MergeTree/LoadedMergeTreeDataPartInfoForReader.h>\n #include <Storages/MergeTree/MergeTreeDataSelectExecutor.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Processors/Transforms/FilterTransform.h>\n #include <Processors/QueryPlan/ISourceStep.h>\n #include <QueryPipeline/QueryPipelineBuilder.h>\n@@ -16,6 +17,7 @@\n \n namespace DB\n {\n+\n namespace ErrorCodes\n {\n     extern const int MEMORY_LIMIT_EXCEEDED;\n@@ -55,7 +57,6 @@ class MergeTreeSequentialSource : public ISource\n     Chunk generate() override;\n \n private:\n-\n     const MergeTreeData & storage;\n     StorageSnapshotPtr storage_snapshot;\n \n@@ -86,7 +87,6 @@ class MergeTreeSequentialSource : public ISource\n     void finish();\n };\n \n-\n MergeTreeSequentialSource::MergeTreeSequentialSource(\n     MergeTreeSequentialSourceType type,\n     const MergeTreeData & storage_,\n@@ -136,10 +136,8 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n     {\n         auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical)\n             .withExtendedObjects()\n-            .withSystemColumns();\n-\n-        if (storage.supportsSubcolumns())\n-            options.withSubcolumns();\n+            .withVirtuals()\n+            .withSubcolumns(storage.supportsSubcolumns());\n \n         columns_for_reader = storage_snapshot->getColumnsByNames(options, columns_to_read);\n     }\n@@ -181,9 +179,37 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n         mark_ranges.emplace(MarkRanges{MarkRange(0, data_part->getMarksCount())});\n \n     reader = data_part->getReader(\n-        columns_for_reader, storage_snapshot,\n-        *mark_ranges, /* uncompressed_cache = */ nullptr,\n-        mark_cache.get(), alter_conversions, reader_settings, {}, {});\n+        columns_for_reader,\n+        storage_snapshot,\n+        *mark_ranges,\n+        /*virtual_fields=*/ {},\n+        /*uncompressed_cache=*/{},\n+        mark_cache.get(),\n+        alter_conversions,\n+        reader_settings,\n+        {},\n+        {});\n+}\n+\n+static void fillBlockNumberColumns(\n+    Columns & res_columns,\n+    const NamesAndTypesList & columns_list,\n+    UInt64 block_number,\n+    UInt64 num_rows)\n+{\n+    chassert(res_columns.size() == columns_list.size());\n+\n+    auto it = columns_list.begin();\n+    for (size_t i = 0; i < res_columns.size(); ++i, ++it)\n+    {\n+        if (res_columns[i])\n+            continue;\n+\n+        if (it->name == BlockNumberColumn::name)\n+        {\n+            res_columns[i] = BlockNumberColumn::type->createColumnConst(num_rows, block_number)->convertToFullColumnIfConst();\n+        }\n+    }\n }\n \n Chunk MergeTreeSequentialSource::generate()\n@@ -204,16 +230,17 @@ try\n \n         if (rows_read)\n         {\n+            fillBlockNumberColumns(columns, sample, data_part->info.min_block, rows_read);\n+            reader->fillVirtualColumns(columns, rows_read);\n+\n             current_row += rows_read;\n             current_mark += (rows_to_read == rows_read);\n \n             bool should_evaluate_missing_defaults = false;\n-            reader->fillMissingColumns(columns, should_evaluate_missing_defaults, rows_read, data_part->info.min_block);\n+            reader->fillMissingColumns(columns, should_evaluate_missing_defaults, rows_read);\n \n             if (should_evaluate_missing_defaults)\n-            {\n                 reader->evaluateMissingDefaults({}, columns);\n-            }\n \n             reader->performRequiredConversions(columns);\n \n@@ -278,14 +305,13 @@ Pipe createMergeTreeSequentialSource(\n     bool quiet,\n     std::shared_ptr<std::atomic<size_t>> filtered_rows_count)\n {\n-    const auto & filter_column = LightweightDeleteDescription::FILTER_COLUMN;\n \n     /// The part might have some rows masked by lightweight deletes\n     const bool need_to_filter_deleted_rows = apply_deleted_mask && data_part->hasLightweightDelete();\n-    const bool has_filter_column = std::ranges::find(columns_to_read, filter_column.name) != columns_to_read.end();\n+    const bool has_filter_column = std::ranges::find(columns_to_read, RowExistsColumn::name) != columns_to_read.end();\n \n     if (need_to_filter_deleted_rows && !has_filter_column)\n-        columns_to_read.emplace_back(filter_column.name);\n+        columns_to_read.emplace_back(RowExistsColumn::name);\n \n     auto column_part_source = std::make_shared<MergeTreeSequentialSource>(type,\n         storage, storage_snapshot, data_part, columns_to_read, std::move(mark_ranges),\n@@ -299,7 +325,7 @@ Pipe createMergeTreeSequentialSource(\n         pipe.addSimpleTransform([filtered_rows_count, has_filter_column](const Block & header)\n         {\n             return std::make_shared<FilterTransform>(\n-                header, nullptr, filter_column.name, !has_filter_column, false, filtered_rows_count);\n+                header, nullptr, RowExistsColumn::name, !has_filter_column, false, filtered_rows_count);\n         });\n     }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeVirtualColumns.cpp b/src/Storages/MergeTree/MergeTreeVirtualColumns.cpp\nnew file mode 100644\nindex 000000000000..b87dccc2b186\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeTreeVirtualColumns.cpp\n@@ -0,0 +1,52 @@\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n+#include <Storages/MergeTree/IMergeTreeDataPart.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NO_SUCH_COLUMN_IN_TABLE;\n+}\n+\n+static ASTPtr getCompressionCodecDeltaLZ4()\n+{\n+    return makeASTFunction(\"CODEC\",\n+        std::make_shared<ASTIdentifier>(\"Delta\"),\n+        std::make_shared<ASTIdentifier>(\"LZ4\"));\n+}\n+\n+const String RowExistsColumn::name = \"_row_exists\";\n+const DataTypePtr RowExistsColumn::type = std::make_shared<DataTypeUInt8>();\n+\n+const String BlockNumberColumn::name = \"_block_number\";\n+const DataTypePtr BlockNumberColumn::type = std::make_shared<DataTypeUInt64>();\n+const ASTPtr BlockNumberColumn::codec = getCompressionCodecDeltaLZ4();\n+\n+Field getFieldForConstVirtualColumn(const String & column_name, const IMergeTreeDataPart & part)\n+{\n+    if (column_name == RowExistsColumn::name)\n+        return 1ULL;\n+\n+    if (column_name == BlockNumberColumn::name)\n+        return part.info.min_block;\n+\n+    if (column_name == \"_part\")\n+        return part.name;\n+\n+    if (column_name == \"_part_uuid\")\n+        return part.uuid;\n+\n+    if (column_name == \"_partition_id\")\n+        return part.info.partition_id;\n+\n+    if (column_name == \"_partition_value\")\n+        return Tuple(part.partition.value.begin(), part.partition.value.end());\n+\n+    throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"Unexpected const virtual column: {}\", column_name);\n+}\n+\n+}\ndiff --git a/src/Storages/MergeTree/MergeTreeVirtualColumns.h b/src/Storages/MergeTree/MergeTreeVirtualColumns.h\nnew file mode 100644\nindex 000000000000..24721bf1ad11\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeTreeVirtualColumns.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+#include <Core/Types.h>\n+#include <DataTypes/IDataType.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+namespace DB\n+{\n+\n+class IMergeTreeDataPart;\n+\n+struct RowExistsColumn\n+{\n+    static const String name;\n+    static const DataTypePtr type;\n+};\n+\n+struct BlockNumberColumn\n+{\n+    static const String name;\n+    static const DataTypePtr type;\n+    static const ASTPtr codec;\n+};\n+\n+Field getFieldForConstVirtualColumn(const String & column_name, const IMergeTreeDataPart & part);\n+\n+}\ndiff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex 1c33f018a5d4..a5b8a2a2a6d5 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -23,7 +23,7 @@\n #include <Storages/MutationCommands.h>\n #include <Storages/MergeTree/MergeTreeDataMergerMutator.h>\n #include <Storages/MergeTree/MergeTreeIndexInverted.h>\n-#include <Storages/BlockNumberColumn.h>\n+#include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeVariant.h>\n #include <boost/algorithm/string/replace.hpp>\n@@ -168,7 +168,7 @@ static void splitAndModifyMutationCommands(\n         {\n             if (!mutated_columns.contains(column.name))\n             {\n-                if (!metadata_snapshot->getColumns().has(column.name) && !part->storage.getVirtuals().contains(column.name))\n+                if (!metadata_snapshot->getColumns().has(column.name) && !part->storage.getVirtualsPtr()->has(column.name))\n                 {\n                     /// We cannot add the column because there's no such column in table.\n                     /// It's okay if the column was dropped. It may also absent in dropped_columns\n@@ -283,7 +283,6 @@ getColumnsForNewDataPart(\n     ColumnsDescription part_columns(source_part->getColumns());\n     NamesAndTypesList system_columns;\n \n-    const auto & deleted_mask_column = LightweightDeleteDescription::FILTER_COLUMN;\n     bool supports_lightweight_deletes = source_part->supportLightweightDeleteMutate();\n \n     bool deleted_mask_updated = false;\n@@ -299,9 +298,9 @@ getColumnsForNewDataPart(\n         {\n             for (const auto & [column_name, _] : command.column_to_update_expression)\n             {\n-                if (column_name == deleted_mask_column.name\n+                if (column_name == RowExistsColumn::name\n                     && supports_lightweight_deletes\n-                    && !storage_columns_set.contains(deleted_mask_column.name))\n+                    && !storage_columns_set.contains(RowExistsColumn::name))\n                     deleted_mask_updated = true;\n             }\n         }\n@@ -323,12 +322,12 @@ getColumnsForNewDataPart(\n         }\n     }\n \n-    if (!storage_columns_set.contains(deleted_mask_column.name))\n+    if (!storage_columns_set.contains(RowExistsColumn::name))\n     {\n-        if (deleted_mask_updated || (part_columns.has(deleted_mask_column.name) && !has_delete_command))\n+        if (deleted_mask_updated || (part_columns.has(RowExistsColumn::name) && !has_delete_command))\n         {\n-            storage_columns.push_back(deleted_mask_column);\n-            storage_columns_set.insert(deleted_mask_column.name);\n+            storage_columns.emplace_back(RowExistsColumn::name, RowExistsColumn::type);\n+            storage_columns_set.insert(RowExistsColumn::name);\n         }\n     }\n \ndiff --git a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\nindex bbb38346f38c..ca8ed9abdb56 100644\n--- a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n@@ -34,6 +34,7 @@ class StorageFromMergeTreeDataPart final : public IStorage\n         , partition_id(part_->info.partition_id)\n     {\n         setInMemoryMetadata(storage.getInMemoryMetadata());\n+        setVirtuals(*storage.getVirtualsPtr());\n     }\n \n     /// Used in queries with projection.\n@@ -90,11 +91,6 @@ class StorageFromMergeTreeDataPart final : public IStorage\n \n     bool supportsSubcolumns() const override { return true; }\n \n-    NamesAndTypesList getVirtuals() const override\n-    {\n-        return storage.getVirtuals();\n-    }\n-\n     String getPartitionId() const\n     {\n         return partition_id;\ndiff --git a/src/Storages/NATS/NATSSource.cpp b/src/Storages/NATS/NATSSource.cpp\nindex 3fc01eacb225..54f479faacca 100644\n--- a/src/Storages/NATS/NATSSource.cpp\n+++ b/src/Storages/NATS/NATSSource.cpp\n@@ -9,10 +9,10 @@\n namespace DB\n {\n \n-static std::pair<Block, Block> getHeaders(StorageNATS & storage, const StorageSnapshotPtr & storage_snapshot)\n+static std::pair<Block, Block> getHeaders(const StorageSnapshotPtr & storage_snapshot)\n {\n     auto non_virtual_header = storage_snapshot->metadata->getSampleBlockNonMaterialized();\n-    auto virtual_header = storage_snapshot->getSampleBlockForColumns(storage.getVirtuals().getNames());\n+    auto virtual_header = storage_snapshot->virtual_columns->getSampleBlock();\n \n     return {non_virtual_header, virtual_header};\n }\n@@ -33,7 +33,7 @@ NATSSource::NATSSource(\n     const Names & columns,\n     size_t max_block_size_,\n     StreamingHandleErrorMode handle_error_mode_)\n-    : NATSSource(storage_, storage_snapshot_, getHeaders(storage_, storage_snapshot_), context_, columns, max_block_size_, handle_error_mode_)\n+    : NATSSource(storage_, storage_snapshot_, getHeaders(storage_snapshot_), context_, columns, max_block_size_, handle_error_mode_)\n {\n }\n \ndiff --git a/src/Storages/NATS/StorageNATS.cpp b/src/Storages/NATS/StorageNATS.cpp\nindex c7a5d0b8d0a5..0b88a9e89297 100644\n--- a/src/Storages/NATS/StorageNATS.cpp\n+++ b/src/Storages/NATS/StorageNATS.cpp\n@@ -88,6 +88,7 @@ StorageNATS::StorageNATS(\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals(nats_settings->nats_handle_error_mode));\n \n     nats_context = addSettings(getContext());\n     nats_context->makeQueryContext();\n@@ -131,6 +132,19 @@ StorageNATS::StorageNATS(\n     connection_task->deactivate();\n }\n \n+VirtualColumnsDescription StorageNATS::createVirtuals(StreamingHandleErrorMode handle_error_mode)\n+{\n+    VirtualColumnsDescription desc;\n+    desc.addEphemeral(\"_subject\", std::make_shared<DataTypeString>(), \"\");\n+\n+    if (handle_error_mode == StreamingHandleErrorMode::STREAM)\n+    {\n+        desc.addEphemeral(\"_raw_message\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+        desc.addEphemeral(\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+    }\n+\n+    return desc;\n+}\n \n Names StorageNATS::parseList(const String & list, char delim)\n {\n@@ -746,20 +760,4 @@ void registerStorageNATS(StorageFactory & factory)\n     factory.registerStorage(\"NATS\", creator_fn, StorageFactory::StorageFeatures{ .supports_settings = true, });\n }\n \n-\n-NamesAndTypesList StorageNATS::getVirtuals() const\n-{\n-    auto virtuals = NamesAndTypesList{\n-            {\"_subject\", std::make_shared<DataTypeString>()}\n-    };\n-\n-    if (nats_settings->nats_handle_error_mode == StreamingHandleErrorMode::STREAM)\n-    {\n-        virtuals.push_back({\"_raw_message\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-        virtuals.push_back({\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-    }\n-\n-    return virtuals;\n-}\n-\n }\ndiff --git a/src/Storages/NATS/StorageNATS.h b/src/Storages/NATS/StorageNATS.h\nindex 94f955ccdae5..41d77acfde6c 100644\n--- a/src/Storages/NATS/StorageNATS.h\n+++ b/src/Storages/NATS/StorageNATS.h\n@@ -61,7 +61,6 @@ class StorageNATS final : public IStorage, WithContext\n     NATSConsumerPtr popConsumer(std::chrono::milliseconds timeout);\n \n     const String & getFormatName() const { return format_name; }\n-    NamesAndTypesList getVirtuals() const override;\n \n     void incrementReader();\n     void decrementReader();\n@@ -137,6 +136,7 @@ class StorageNATS final : public IStorage, WithContext\n \n     static Names parseList(const String & list, char delim);\n     static String getTableBasedName(String name, const StorageID & table_id);\n+    static VirtualColumnsDescription createVirtuals(StreamingHandleErrorMode handle_error_mode);\n \n     ContextMutablePtr addSettings(ContextPtr context) const;\n     size_t getMaxBlockSize() const;\ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\nindex 61d83750c31e..64d329f74b2c 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n@@ -72,6 +72,7 @@ StorageMaterializedPostgreSQL::StorageMaterializedPostgreSQL(\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Storage MaterializedPostgreSQL is allowed only for Atomic database\");\n \n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals());\n \n     replication_settings->materialized_postgresql_tables_list = remote_table_name_;\n \n@@ -127,8 +128,16 @@ StorageMaterializedPostgreSQL::StorageMaterializedPostgreSQL(\n     , nested_table_id(nested_storage_->getStorageID())\n {\n     setInMemoryMetadata(nested_storage_->getInMemoryMetadata());\n+    setVirtuals(*nested_storage_->getVirtualsPtr());\n }\n \n+VirtualColumnsDescription StorageMaterializedPostgreSQL::createVirtuals()\n+{\n+    VirtualColumnsDescription desc;\n+    desc.addEphemeral(\"_sign\", std::make_shared<DataTypeInt8>(), \"\");\n+    desc.addEphemeral(\"_version\", std::make_shared<DataTypeUInt64>(), \"\");\n+    return desc;\n+}\n \n /// A temporary clone table might be created for current table in order to update its schema and reload\n /// all data in the background while current table will still handle read requests.\n@@ -254,15 +263,6 @@ void StorageMaterializedPostgreSQL::dropInnerTableIfAny(bool sync, ContextPtr lo\n }\n \n \n-NamesAndTypesList StorageMaterializedPostgreSQL::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-            {\"_sign\", std::make_shared<DataTypeInt8>()},\n-            {\"_version\", std::make_shared<DataTypeUInt64>()}\n-    };\n-}\n-\n-\n bool StorageMaterializedPostgreSQL::needRewriteQueryWithFinal(const Names & column_names) const\n {\n     return needRewriteQueryWithFinalForStorage(column_names, getNested());\ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\nindex 2d5c1efae7c4..af2f13bb880c 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\n@@ -89,8 +89,6 @@ class StorageMaterializedPostgreSQL final : public IStorage, WithContext\n     /// Used only for single MaterializedPostgreSQL storage.\n     void dropInnerTableIfAny(bool sync, ContextPtr local_context) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     bool needRewriteQueryWithFinal(const Names & column_names) const override;\n \n     void read(\n@@ -138,6 +136,8 @@ class StorageMaterializedPostgreSQL final : public IStorage, WithContext\n     static std::shared_ptr<ASTColumnDeclaration> getMaterializedColumnsDeclaration(\n             String name, String type, UInt64 default_value);\n \n+    static VirtualColumnsDescription createVirtuals();\n+\n     ASTPtr getColumnDeclaration(const DataTypePtr & data_type) const;\n \n     String getNestedTableName() const;\ndiff --git a/src/Storages/RabbitMQ/RabbitMQSource.cpp b/src/Storages/RabbitMQ/RabbitMQSource.cpp\nindex 72196e7dd3ca..4dc257074f33 100644\n--- a/src/Storages/RabbitMQ/RabbitMQSource.cpp\n+++ b/src/Storages/RabbitMQ/RabbitMQSource.cpp\n@@ -11,10 +11,10 @@\n namespace DB\n {\n \n-static std::pair<Block, Block> getHeaders(StorageRabbitMQ & storage_, const StorageSnapshotPtr & storage_snapshot)\n+static std::pair<Block, Block> getHeaders(const StorageSnapshotPtr & storage_snapshot)\n {\n     auto non_virtual_header = storage_snapshot->metadata->getSampleBlockNonMaterialized();\n-    auto virtual_header = storage_snapshot->getSampleBlockForColumns(storage_.getVirtuals().getNames());\n+    auto virtual_header = storage_snapshot->virtual_columns->getSampleBlock();\n \n     return {non_virtual_header, virtual_header};\n }\n@@ -40,7 +40,7 @@ RabbitMQSource::RabbitMQSource(\n     : RabbitMQSource(\n         storage_,\n         storage_snapshot_,\n-        getHeaders(storage_, storage_snapshot_),\n+        getHeaders(storage_snapshot_),\n         context_,\n         columns,\n         max_block_size_,\ndiff --git a/src/Storages/RabbitMQ/StorageRabbitMQ.cpp b/src/Storages/RabbitMQ/StorageRabbitMQ.cpp\nindex e2ef23193c59..980fccd307ef 100644\n--- a/src/Storages/RabbitMQ/StorageRabbitMQ.cpp\n+++ b/src/Storages/RabbitMQ/StorageRabbitMQ.cpp\n@@ -136,6 +136,7 @@ StorageRabbitMQ::StorageRabbitMQ(\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals(rabbitmq_settings->rabbitmq_handle_error_mode));\n \n     rabbitmq_context = addSettings(getContext());\n     rabbitmq_context->makeQueryContext();\n@@ -191,6 +192,26 @@ StorageRabbitMQ::StorageRabbitMQ(\n     init_task->deactivate();\n }\n \n+VirtualColumnsDescription StorageRabbitMQ::createVirtuals(StreamingHandleErrorMode handle_error_mode)\n+{\n+    VirtualColumnsDescription desc;\n+\n+    desc.addEphemeral(\"_exchange_name\", std::make_shared<DataTypeString>(), \"\");\n+    desc.addEphemeral(\"_channel_id\", std::make_shared<DataTypeString>(), \"\");\n+    desc.addEphemeral(\"_delivery_tag\", std::make_shared<DataTypeUInt64>(), \"\");\n+    desc.addEphemeral(\"_redelivered\", std::make_shared<DataTypeUInt8>(), \"\");\n+    desc.addEphemeral(\"_message_id\", std::make_shared<DataTypeString>(), \"\");\n+    desc.addEphemeral(\"_timestamp\", std::make_shared<DataTypeUInt64>(), \"\");\n+\n+\n+    if (handle_error_mode == StreamingHandleErrorMode::STREAM)\n+    {\n+        desc.addEphemeral(\"_raw_message\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+        desc.addEphemeral(\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"\");\n+    }\n+\n+    return desc;\n+}\n \n Names StorageRabbitMQ::parseSettings(String settings_list)\n {\n@@ -1213,25 +1234,4 @@ void registerStorageRabbitMQ(StorageFactory & factory)\n     factory.registerStorage(\"RabbitMQ\", creator_fn, StorageFactory::StorageFeatures{ .supports_settings = true, });\n }\n \n-\n-NamesAndTypesList StorageRabbitMQ::getVirtuals() const\n-{\n-    auto virtuals = NamesAndTypesList{\n-            {\"_exchange_name\", std::make_shared<DataTypeString>()},\n-            {\"_channel_id\", std::make_shared<DataTypeString>()},\n-            {\"_delivery_tag\", std::make_shared<DataTypeUInt64>()},\n-            {\"_redelivered\", std::make_shared<DataTypeUInt8>()},\n-            {\"_message_id\", std::make_shared<DataTypeString>()},\n-            {\"_timestamp\", std::make_shared<DataTypeUInt64>()}\n-    };\n-\n-    if (rabbitmq_settings->rabbitmq_handle_error_mode == StreamingHandleErrorMode::STREAM)\n-    {\n-        virtuals.push_back({\"_raw_message\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-        virtuals.push_back({\"_error\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())});\n-    }\n-\n-    return virtuals;\n-}\n-\n }\ndiff --git a/src/Storages/RabbitMQ/StorageRabbitMQ.h b/src/Storages/RabbitMQ/StorageRabbitMQ.h\nindex b3a0b53cde57..e14741d96360 100644\n--- a/src/Storages/RabbitMQ/StorageRabbitMQ.h\n+++ b/src/Storages/RabbitMQ/StorageRabbitMQ.h\n@@ -68,7 +68,6 @@ class StorageRabbitMQ final: public IStorage, WithContext\n     RabbitMQConsumerPtr popConsumer(std::chrono::milliseconds timeout);\n \n     const String & getFormatName() const { return format_name; }\n-    NamesAndTypesList getVirtuals() const override;\n \n     String getExchange() const { return exchange_name; }\n     void unbindExchange();\n@@ -191,6 +190,8 @@ class StorageRabbitMQ final: public IStorage, WithContext\n     bool tryStreamToViews();\n     bool hasDependencies(const StorageID & table_id);\n \n+    static VirtualColumnsDescription createVirtuals(StreamingHandleErrorMode handle_error_mode);\n+\n     static String getRandomName()\n     {\n         std::uniform_int_distribution<int> distribution('a', 'z');\ndiff --git a/src/Storages/S3Queue/StorageS3Queue.cpp b/src/Storages/S3Queue/StorageS3Queue.cpp\nindex 885049754906..6e7ac2b47b8d 100644\n--- a/src/Storages/S3Queue/StorageS3Queue.cpp\n+++ b/src/Storages/S3Queue/StorageS3Queue.cpp\n@@ -155,8 +155,7 @@ StorageS3Queue::StorageS3Queue(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n \n     LOG_INFO(log, \"Using zookeeper path: {}\", zk_path.string());\n     task = getContext()->getSchedulePool().createTask(\"S3QueueStreamingTask\", [this] { threadFunc(); });\n@@ -315,7 +314,7 @@ void StorageS3Queue::read(\n     }\n \n     auto this_ptr = std::static_pointer_cast<StorageS3Queue>(shared_from_this());\n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context));\n \n     auto reading = std::make_unique<ReadFromS3Queue>(\n         column_names,\n@@ -493,7 +492,7 @@ bool StorageS3Queue::streamToViews()\n     auto block_io = interpreter.execute();\n     auto file_iterator = createFileIterator(s3queue_context, nullptr);\n \n-    auto read_from_format_info = prepareReadingFromFormat(block_io.pipeline.getHeader().getNames(), storage_snapshot, supportsSubsetOfColumns(s3queue_context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(block_io.pipeline.getHeader().getNames(), storage_snapshot, supportsSubsetOfColumns(s3queue_context));\n \n     Pipes pipes;\n     pipes.reserve(s3queue_settings->s3queue_processing_threads_num);\n@@ -602,8 +601,9 @@ void StorageS3Queue::checkTableStructure(const String & zookeeper_prefix, const\n std::shared_ptr<StorageS3Queue::FileIterator> StorageS3Queue::createFileIterator(ContextPtr local_context, const ActionsDAG::Node * predicate)\n {\n     auto glob_iterator = std::make_unique<StorageS3QueueSource::GlobIterator>(\n-        *configuration.client, configuration.url, predicate, virtual_columns, local_context,\n+        *configuration.client, configuration.url, predicate, getVirtualsList(), local_context,\n         /* read_keys */nullptr, configuration.request_settings);\n+\n     return std::make_shared<FileIterator>(files_metadata, std::move(glob_iterator), s3queue_settings->s3queue_current_shard_num, shutdown_called);\n }\n \ndiff --git a/src/Storages/S3Queue/StorageS3Queue.h b/src/Storages/S3Queue/StorageS3Queue.h\nindex fd3b4bb4914c..bdd3ab7b6870 100644\n--- a/src/Storages/S3Queue/StorageS3Queue.h\n+++ b/src/Storages/S3Queue/StorageS3Queue.h\n@@ -51,8 +51,6 @@ class StorageS3Queue : public IStorage, WithContext\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    NamesAndTypesList getVirtuals() const override { return virtual_columns; }\n-\n     const auto & getFormatName() const { return configuration.format; }\n \n     const fs::path & getZooKeeperPath() const { return zk_path; }\n@@ -71,7 +69,6 @@ class StorageS3Queue : public IStorage, WithContext\n     Configuration configuration;\n \n     const std::optional<FormatSettings> format_settings;\n-    NamesAndTypesList virtual_columns;\n \n     BackgroundSchedulePool::TaskHolder task;\n     std::atomic<bool> stream_cancelled{false};\ndiff --git a/src/Storages/StorageAzureBlob.cpp b/src/Storages/StorageAzureBlob.cpp\nindex 1f0fba99f841..bac9aa1cbdfc 100644\n--- a/src/Storages/StorageAzureBlob.cpp\n+++ b/src/Storages/StorageAzureBlob.cpp\n@@ -491,12 +491,11 @@ StorageAzureBlob::StorageAzureBlob(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n \n     StoredObjects objects;\n     for (const auto & key : configuration.blobs_paths)\n         objects.emplace_back(key);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n }\n \n void StorageAzureBlob::truncate(const ASTPtr &, const StorageMetadataPtr &, ContextPtr, TableExclusiveLockHolder &)\n@@ -736,7 +735,7 @@ void StorageAzureBlob::read(\n \n     auto this_ptr = std::static_pointer_cast<StorageAzureBlob>(shared_from_this());\n \n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context));\n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && local_context->getSettingsRef().optimize_count_from_files;\n \n@@ -772,13 +771,13 @@ void ReadFromAzureBlob::createIterator(const ActionsDAG::Node * predicate)\n         /// Iterate through disclosed globs and make a source for each file\n         iterator_wrapper = std::make_shared<StorageAzureBlobSource::GlobIterator>(\n             storage->object_storage.get(), configuration.container, configuration.blob_path,\n-            predicate, storage->virtual_columns, context, nullptr, context->getFileProgressCallback());\n+            predicate, storage->getVirtualsList(), context, nullptr, context->getFileProgressCallback());\n     }\n     else\n     {\n         iterator_wrapper = std::make_shared<StorageAzureBlobSource::KeysIterator>(\n             storage->object_storage.get(), configuration.container, configuration.blobs_paths,\n-            predicate, storage->virtual_columns, context, nullptr, context->getFileProgressCallback());\n+            predicate, storage->getVirtualsList(), context, nullptr, context->getFileProgressCallback());\n     }\n }\n \n@@ -886,16 +885,6 @@ SinkToStoragePtr StorageAzureBlob::write(const ASTPtr & query, const StorageMeta\n     }\n }\n \n-NamesAndTypesList StorageAzureBlob::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-Names StorageAzureBlob::getVirtualColumnNames()\n-{\n-    return VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage({}).getNames();\n-}\n-\n bool StorageAzureBlob::supportsPartitionBy() const\n {\n     return true;\ndiff --git a/src/Storages/StorageAzureBlob.h b/src/Storages/StorageAzureBlob.h\nindex e1d1c3abd333..63fd489dcaf5 100644\n--- a/src/Storages/StorageAzureBlob.h\n+++ b/src/Storages/StorageAzureBlob.h\n@@ -94,9 +94,6 @@ class StorageAzureBlob : public IStorage\n \n     void truncate(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, ContextPtr local_context, TableExclusiveLockHolder &) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-    static Names getVirtualColumnNames();\n-\n     bool supportsPartitionBy() const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -136,7 +133,6 @@ class StorageAzureBlob : public IStorage\n     std::string name;\n     Configuration configuration;\n     std::unique_ptr<AzureObjectStorage> object_storage;\n-    NamesAndTypesList virtual_columns;\n \n     const bool distributed_processing;\n     std::optional<FormatSettings> format_settings;\ndiff --git a/src/Storages/StorageAzureBlobCluster.cpp b/src/Storages/StorageAzureBlobCluster.cpp\nindex 32445556611b..a80d121567a2 100644\n--- a/src/Storages/StorageAzureBlobCluster.cpp\n+++ b/src/Storages/StorageAzureBlobCluster.cpp\n@@ -63,8 +63,7 @@ StorageAzureBlobCluster::StorageAzureBlobCluster(\n \n     storage_metadata.setConstraints(constraints_);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageAzureBlobCluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const DB::StorageSnapshotPtr & storage_snapshot, const DB::ContextPtr & context)\n@@ -81,17 +80,12 @@ RemoteQueryExecutor::Extension StorageAzureBlobCluster::getTaskIteratorExtension\n {\n     auto iterator = std::make_shared<StorageAzureBlobSource::GlobIterator>(\n         object_storage.get(), configuration.container, configuration.blob_path,\n-        predicate, virtual_columns, context, nullptr);\n+        predicate, getVirtualsList(), context, nullptr);\n+\n     auto callback = std::make_shared<std::function<String()>>([iterator]() mutable -> String{ return iterator->next().relative_path; });\n     return RemoteQueryExecutor::Extension{ .task_iterator = std::move(callback) };\n }\n \n-NamesAndTypesList StorageAzureBlobCluster::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-\n }\n \n #endif\ndiff --git a/src/Storages/StorageAzureBlobCluster.h b/src/Storages/StorageAzureBlobCluster.h\nindex 476f21c6742c..545e568a772d 100644\n--- a/src/Storages/StorageAzureBlobCluster.h\n+++ b/src/Storages/StorageAzureBlobCluster.h\n@@ -31,8 +31,6 @@ class StorageAzureBlobCluster : public IStorageCluster\n \n     std::string getName() const override { return \"AzureBlobStorageCluster\"; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -45,7 +43,6 @@ class StorageAzureBlobCluster : public IStorageCluster\n     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;\n \n     StorageAzureBlob::Configuration configuration;\n-    NamesAndTypesList virtual_columns;\n     std::unique_ptr<AzureObjectStorage> object_storage;\n };\n \ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex 92e7dcdf4f25..ce695d5f0095 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -19,6 +19,7 @@\n #include <Storages/checkAndGetLiteralArgument.h>\n #include <Storages/StorageDummy.h>\n #include <Storages/removeGroupingFunctionSpecializations.h>\n+#include <Storages/MergeTree/MergeTreeData.h>\n \n #include <Columns/ColumnConst.h>\n \n@@ -104,11 +105,8 @@\n #include <IO/Operators.h>\n #include <IO/ConnectionTimeouts.h>\n \n-#include <Storages/BlockNumberColumn.h>\n-\n #include <memory>\n #include <filesystem>\n-#include <optional>\n #include <cassert>\n \n \n@@ -290,22 +288,18 @@ size_t getClusterQueriedNodes(const Settings & settings, const ClusterPtr & clus\n StorageDistributed::~StorageDistributed() = default;\n \n \n-NamesAndTypesList StorageDistributed::getVirtuals() const\n+VirtualColumnsDescription StorageDistributed::createVirtuals()\n {\n-    /// NOTE This is weird. Most of these virtual columns are part of MergeTree\n+    /// NOTE: This is weird.\n+    /// Most of these virtual columns are part of MergeTree\n     /// tables info. But Distributed is general-purpose engine.\n-    return NamesAndTypesList{\n-        NameAndTypePair(\"_table\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())),\n-        NameAndTypePair(\"_part\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())),\n-        NameAndTypePair(\"_part_index\", std::make_shared<DataTypeUInt64>()),\n-        NameAndTypePair(\"_part_uuid\", std::make_shared<DataTypeUUID>()),\n-        NameAndTypePair(\"_partition_id\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())),\n-        NameAndTypePair(\"_sample_factor\", std::make_shared<DataTypeFloat64>()),\n-        NameAndTypePair(\"_part_offset\", std::make_shared<DataTypeUInt64>()),\n-        NameAndTypePair(\"_row_exists\", std::make_shared<DataTypeUInt8>()),\n-        NameAndTypePair(BlockNumberColumn::name, BlockNumberColumn::type),\n-        NameAndTypePair(\"_shard_num\", std::make_shared<DataTypeUInt32>()), /// deprecated\n-    };\n+    StorageInMemoryMetadata metadata;\n+    auto desc = MergeTreeData::createVirtuals(metadata);\n+\n+    desc.addEphemeral(\"_table\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"Name of a table\");\n+    desc.addEphemeral(\"_shard_num\", std::make_shared<DataTypeUInt32>(), \"Deprecated. Use function shardNum instead\");\n+\n+    return desc;\n }\n \n StorageDistributed::StorageDistributed(\n@@ -354,6 +348,7 @@ StorageDistributed::StorageDistributed(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals());\n \n     if (sharding_key_)\n     {\ndiff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h\nindex c00dd8cea041..cf5b78305a5f 100644\n--- a/src/Storages/StorageDistributed.h\n+++ b/src/Storages/StorageDistributed.h\n@@ -146,8 +146,6 @@ class StorageDistributed final : public IStorage, WithContext\n \n     ActionLock getActionLock(StorageActionBlockType type) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     /// Used by InterpreterInsertQuery\n     std::string getRemoteDatabaseName() const { return remote_database; }\n     std::string getRemoteTableName() const { return remote_table; }\n@@ -234,6 +232,8 @@ class StorageDistributed final : public IStorage, WithContext\n     std::optional<QueryPipeline> distributedWriteFromClusterStorage(const IStorageCluster & src_storage_cluster, const ASTInsertQuery & query, ContextPtr context) const;\n     std::optional<QueryPipeline> distributedWriteBetweenDistributedTables(const StorageDistributed & src_distributed, const ASTInsertQuery & query, ContextPtr context) const;\n \n+    static VirtualColumnsDescription createVirtuals();\n+\n     String remote_database;\n     String remote_table;\n     ASTPtr remote_table_function_ptr;\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 7ed994461225..0d220f2fd5da 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -1097,8 +1097,7 @@ void StorageFile::setStorageMetadata(CommonArguments args)\n     storage_metadata.setConstraints(args.constraints);\n     storage_metadata.setComment(args.comment);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n \n@@ -1581,7 +1580,7 @@ void StorageFile::read(\n \n     auto this_ptr = std::static_pointer_cast<StorageFile>(shared_from_this());\n \n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(context));\n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && context->getSettingsRef().optimize_count_from_files;\n \n@@ -1609,7 +1608,7 @@ void ReadFromFile::createIterator(const ActionsDAG::Node * predicate)\n         storage->paths,\n         storage->archive_info,\n         predicate,\n-        storage->virtual_columns,\n+        storage->getVirtualsList(),\n         context,\n         storage->distributed_processing);\n }\n@@ -2256,9 +2255,4 @@ StorageFile::ArchiveInfo StorageFile::getArchiveInfo(\n     return archive_info;\n }\n \n-Names StorageFile::getVirtualColumnNames()\n-{\n-    return VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage({}).getNames();\n-}\n-\n }\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex 1db33b72d77b..93c263008a66 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -80,10 +80,6 @@ class StorageFile final : public IStorage\n     bool storesDataOnDisk() const override;\n     Strings getDataPaths() const override;\n \n-    NamesAndTypesList getVirtuals() const override { return virtual_columns; }\n-\n-    static Names getVirtualColumnNames();\n-\n     static Strings getPathsList(const String & table_path, const String & user_files_path, const ContextPtr & context, size_t & total_bytes_to_read);\n \n     /// Check if the format supports reading only some subset of columns.\n@@ -197,8 +193,6 @@ class StorageFile final : public IStorage\n     std::atomic<int32_t> readers_counter = 0;\n     FileRenamer file_renamer;\n     bool was_renamed = false;\n-\n-    NamesAndTypesList virtual_columns;\n     bool distributed_processing = false;\n };\n \ndiff --git a/src/Storages/StorageFileCluster.cpp b/src/Storages/StorageFileCluster.cpp\nindex 0cc18abef5f7..d43e242f70c3 100644\n--- a/src/Storages/StorageFileCluster.cpp\n+++ b/src/Storages/StorageFileCluster.cpp\n@@ -61,8 +61,7 @@ StorageFileCluster::StorageFileCluster(\n \n     storage_metadata.setConstraints(constraints_);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageFileCluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const DB::ContextPtr & context)\n@@ -77,7 +76,7 @@ void StorageFileCluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const Sto\n \n RemoteQueryExecutor::Extension StorageFileCluster::getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const\n {\n-    auto iterator = std::make_shared<StorageFileSource::FilesIterator>(paths, std::nullopt, predicate, virtual_columns, context);\n+    auto iterator = std::make_shared<StorageFileSource::FilesIterator>(paths, std::nullopt, predicate, getVirtualsList(), context);\n     auto callback = std::make_shared<TaskIterator>([iter = std::move(iterator)]() mutable -> String { return iter->next(); });\n     return RemoteQueryExecutor::Extension{.task_iterator = std::move(callback)};\n }\ndiff --git a/src/Storages/StorageFileCluster.h b/src/Storages/StorageFileCluster.h\nindex 2803c8b6e5b6..3acbc71ba7ec 100644\n--- a/src/Storages/StorageFileCluster.h\n+++ b/src/Storages/StorageFileCluster.h\n@@ -28,8 +28,6 @@ class StorageFileCluster : public IStorageCluster\n \n     std::string getName() const override { return \"FileCluster\"; }\n \n-    NamesAndTypesList getVirtuals() const override { return virtual_columns; }\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -42,7 +40,6 @@ class StorageFileCluster : public IStorageCluster\n     Strings paths;\n     String filename;\n     String format_name;\n-    NamesAndTypesList virtual_columns;\n };\n \n }\ndiff --git a/src/Storages/StorageKeeperMap.cpp b/src/Storages/StorageKeeperMap.cpp\nindex 40a4190a4138..b0b7afdfe8d7 100644\n--- a/src/Storages/StorageKeeperMap.cpp\n+++ b/src/Storages/StorageKeeperMap.cpp\n@@ -331,6 +331,10 @@ StorageKeeperMap::StorageKeeperMap(\n \n     setInMemoryMetadata(metadata);\n \n+    VirtualColumnsDescription virtuals;\n+    virtuals.addEphemeral(String(version_column_name), std::make_shared<DataTypeInt32>(), \"\");\n+    setVirtuals(std::move(virtuals));\n+\n     WriteBufferFromOwnString out;\n     out << \"KeeperMap metadata format version: 1\\n\"\n         << \"columns: \" << metadata.columns.toString()\n@@ -634,12 +638,6 @@ void StorageKeeperMap::drop()\n     dropTable(client, metadata_drop_lock);\n }\n \n-NamesAndTypesList StorageKeeperMap::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        {std::string{version_column_name}, std::make_shared<DataTypeInt32>()}};\n-}\n-\n namespace\n {\n \ndiff --git a/src/Storages/StorageKeeperMap.h b/src/Storages/StorageKeeperMap.h\nindex d65548ed4287..d4556792c489 100644\n--- a/src/Storages/StorageKeeperMap.h\n+++ b/src/Storages/StorageKeeperMap.h\n@@ -50,8 +50,6 @@ class StorageKeeperMap final : public IStorage, public IKeyValueEntity, WithCont\n     void truncate(const ASTPtr &, const StorageMetadataPtr &, ContextPtr, TableExclusiveLockHolder &) override;\n     void drop() override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     std::string getName() const override { return \"KeeperMap\"; }\n     Names getPrimaryKey() const override { return {primary_key}; }\n \ndiff --git a/src/Storages/StorageLog.cpp b/src/Storages/StorageLog.cpp\nindex 7459760b0f5e..549cfca1b6c4 100644\n--- a/src/Storages/StorageLog.cpp\n+++ b/src/Storages/StorageLog.cpp\n@@ -35,7 +35,6 @@\n #include <Backups/IBackup.h>\n #include <Backups/RestorerFromBackup.h>\n #include <Disks/TemporaryFileOnDisk.h>\n-#include <Storages/BlockNumberColumn.h>\n \n #include <cassert>\n #include <chrono>\n@@ -48,8 +47,6 @@\n namespace DB\n {\n \n-    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n-\n namespace ErrorCodes\n {\n     extern const int TIMEOUT_EXCEEDED;\n@@ -299,6 +296,7 @@ class LogSink final : public SinkToStorage\n         : SinkToStorage(metadata_snapshot_->getSampleBlock())\n         , storage(storage_)\n         , metadata_snapshot(metadata_snapshot_)\n+        , storage_snapshot(std::make_shared<StorageSnapshot>(storage, metadata_snapshot))\n         , lock(std::move(lock_))\n     {\n         if (!lock)\n@@ -343,6 +341,7 @@ class LogSink final : public SinkToStorage\n private:\n     StorageLog & storage;\n     StorageMetadataPtr metadata_snapshot;\n+    StorageSnapshotPtr storage_snapshot;\n     WriteLock lock;\n     bool done = false;\n \n@@ -476,13 +475,7 @@ void LogSink::writeData(const NameAndTypePair & name_and_type, const IColumn & c\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"No information about file {} in StorageLog\", data_file_name);\n \n             const auto & data_file = *data_file_it->second;\n-            const auto & columns = metadata_snapshot->getColumns();\n-\n-            CompressionCodecPtr compression;\n-            if (name_and_type.name == BlockNumberColumn::name)\n-                compression = BlockNumberColumn::compression_codec;\n-            else\n-                compression = columns.getCodecOrDefault(name_and_type.name);\n+            auto compression = storage_snapshot->getCodecOrDefault(name_and_type.name);\n \n             it = streams.try_emplace(data_file.name, storage.disk, data_file.path,\n                                      storage.file_checker.getFileSize(data_file.path),\ndiff --git a/src/Storages/StorageMaterializedMySQL.cpp b/src/Storages/StorageMaterializedMySQL.cpp\nindex 0dc0b1bff0bb..887c58ff816b 100644\n--- a/src/Storages/StorageMaterializedMySQL.cpp\n+++ b/src/Storages/StorageMaterializedMySQL.cpp\n@@ -22,9 +22,8 @@ namespace DB\n StorageMaterializedMySQL::StorageMaterializedMySQL(const StoragePtr & nested_storage_, const IDatabase * database_)\n     : StorageProxy(nested_storage_->getStorageID()), nested_storage(nested_storage_), database(database_)\n {\n-    StorageInMemoryMetadata in_memory_metadata;\n-    in_memory_metadata = nested_storage->getInMemoryMetadata();\n-    setInMemoryMetadata(in_memory_metadata);\n+    setInMemoryMetadata(nested_storage->getInMemoryMetadata());\n+    setVirtuals(*nested_storage->getVirtualsPtr());\n }\n \n bool StorageMaterializedMySQL::needRewriteQueryWithFinal(const Names & column_names) const\n@@ -49,14 +48,6 @@ void StorageMaterializedMySQL::read(\n             query_info, context, processed_stage, max_block_size, num_streams);\n }\n \n-NamesAndTypesList StorageMaterializedMySQL::getVirtuals() const\n-{\n-    if (const auto * db = typeid_cast<const DatabaseMaterializedMySQL *>(database))\n-        db->rethrowExceptionIfNeeded();\n-\n-    return nested_storage->getVirtuals();\n-}\n-\n IStorage::ColumnSizeByName StorageMaterializedMySQL::getColumnSizes() const\n {\n     auto sizes = nested_storage->getColumnSizes();\ndiff --git a/src/Storages/StorageMaterializedMySQL.h b/src/Storages/StorageMaterializedMySQL.h\nindex 2cd589bfd752..9f5d157ce3b3 100644\n--- a/src/Storages/StorageMaterializedMySQL.h\n+++ b/src/Storages/StorageMaterializedMySQL.h\n@@ -34,7 +34,6 @@ class StorageMaterializedMySQL final : public StorageProxy\n \n     SinkToStoragePtr write(const ASTPtr &, const StorageMetadataPtr &, ContextPtr, bool) override { throwNotAllowed(); }\n \n-    NamesAndTypesList getVirtuals() const override;\n     ColumnSizeByName getColumnSizes() const override;\n \n     StoragePtr getNested() const override { return nested_storage; }\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 1d0898a2f11d..02cba1cf7530 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -171,6 +171,12 @@ QueryProcessingStage::Enum StorageMaterializedView::getQueryProcessingStage(\n     return getTargetTable()->getQueryProcessingStage(local_context, to_stage, getTargetTable()->getStorageSnapshot(target_metadata, local_context), query_info);\n }\n \n+StorageSnapshotPtr StorageMaterializedView::getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr) const\n+{\n+    /// We cannot set virtuals at table creation because target table may not exist at that time.\n+    return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, getTargetTable()->getVirtualsPtr());\n+}\n+\n void StorageMaterializedView::read(\n     QueryPlan & query_plan,\n     const Names & column_names,\n@@ -536,11 +542,6 @@ StoragePtr StorageMaterializedView::tryGetTargetTable() const\n     return DatabaseCatalog::instance().tryGetTable(getTargetTableId(), getContext());\n }\n \n-NamesAndTypesList StorageMaterializedView::getVirtuals() const\n-{\n-    return getTargetTable()->getVirtuals();\n-}\n-\n Strings StorageMaterializedView::getDataPaths() const\n {\n     if (auto table = tryGetTargetTable())\ndiff --git a/src/Storages/StorageMaterializedView.h b/src/Storages/StorageMaterializedView.h\nindex 4d574a821ec6..198b7a642ee3 100644\n--- a/src/Storages/StorageMaterializedView.h\n+++ b/src/Storages/StorageMaterializedView.h\n@@ -75,12 +75,11 @@ class StorageMaterializedView final : public IStorage, WithMutableContext\n     StoragePtr tryGetTargetTable() const;\n     StorageID getTargetTableId() const;\n \n-    /// Get the virtual column of the target table;\n-    NamesAndTypesList getVirtuals() const override;\n-\n     ActionLock getActionLock(StorageActionBlockType type) override;\n     void onActionLockRemove(StorageActionBlockType action_type) override;\n \n+    StorageSnapshotPtr getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr) const override;\n+\n     void read(\n         QueryPlan & query_plan,\n         const Names & column_names,\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex eb45a8fac662..ca602810ebce 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -147,6 +147,7 @@ StorageMerge::StorageMerge(\n     storage_metadata.setColumns(columns_.empty() ? getColumnsDescriptionFromSourceTables() : columns_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals());\n }\n \n StorageMerge::StorageMerge(\n@@ -169,6 +170,7 @@ StorageMerge::StorageMerge(\n     storage_metadata.setColumns(columns_.empty() ? getColumnsDescriptionFromSourceTables() : columns_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals());\n }\n \n StorageMerge::DatabaseTablesIterators StorageMerge::getDatabaseIterators(ContextPtr context_) const\n@@ -321,6 +323,37 @@ QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(\n     return selected_table_size == 1 ? stage_in_source_tables : std::min(stage_in_source_tables, QueryProcessingStage::WithMergeableState);\n }\n \n+VirtualColumnsDescription StorageMerge::createVirtuals()\n+{\n+    VirtualColumnsDescription desc;\n+\n+    desc.addEphemeral(\"_database\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"\");\n+    desc.addEphemeral(\"_table\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), \"\");\n+\n+    return desc;\n+}\n+\n+StorageSnapshotPtr StorageMerge::getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr) const\n+{\n+    static const auto common_virtuals = createVirtuals();\n+\n+    auto virtuals = common_virtuals;\n+    if (auto first_table = getFirstTable([](auto && table) { return table; }))\n+    {\n+        auto table_virtuals = first_table->getVirtualsPtr();\n+        for (const auto & column : *table_virtuals)\n+        {\n+            if (virtuals.has(column.name))\n+                continue;\n+\n+            virtuals.add(column);\n+        }\n+    }\n+\n+    auto virtuals_ptr = std::make_shared<VirtualColumnsDescription>(std::move(virtuals));\n+    return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, std::move(virtuals_ptr));\n+}\n+\n void StorageMerge::read(\n     QueryPlan & query_plan,\n     const Names & column_names,\n@@ -912,7 +945,6 @@ SelectQueryInfo ReadFromMerge::getModifiedQueryInfo(const ContextPtr & modified_\n                     column_node = std::make_shared<ColumnNode>(NameAndTypePair{column, storage_columns.getColumn(get_column_options, column).type }, modified_query_info.table_expression);\n                 }\n \n-\n                 PlannerActionsVisitor actions_visitor(modified_query_info.planner_context, false /*use_column_identifier_as_action_node_name*/);\n                 actions_visitor.visit(filter_actions_dag, column_node);\n             }\n@@ -1390,6 +1422,7 @@ void StorageMerge::alter(\n     params.apply(storage_metadata, local_context);\n     DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, storage_metadata);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(createVirtuals());\n }\n \n void ReadFromMerge::convertAndFilterSourceStream(\n@@ -1649,20 +1682,4 @@ void registerStorageMerge(StorageFactory & factory)\n     });\n }\n \n-NamesAndTypesList StorageMerge::getVirtuals() const\n-{\n-    NamesAndTypesList virtuals{\n-        {\"_database\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_table\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())}};\n-\n-    auto first_table = getFirstTable([](auto && table) { return table; });\n-    if (first_table)\n-    {\n-        auto table_virtuals = first_table->getVirtuals();\n-        virtuals.insert(virtuals.end(), table_virtuals.begin(), table_virtuals.end());\n-    }\n-\n-    return virtuals;\n-}\n-\n }\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 8b062a392d49..556649f622d9 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -55,6 +55,8 @@ class StorageMerge final : public IStorage, WithContext\n     QueryProcessingStage::Enum\n     getQueryProcessingStage(ContextPtr, QueryProcessingStage::Enum, const StorageSnapshotPtr &, SelectQueryInfo &) const override;\n \n+    StorageSnapshotPtr getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr) const override;\n+\n     void read(\n         QueryPlan & query_plan,\n         const Names & column_names,\n@@ -116,11 +118,12 @@ class StorageMerge final : public IStorage, WithContext\n     template <typename F>\n     void forEachTable(F && func) const;\n \n-    NamesAndTypesList getVirtuals() const override;\n     ColumnSizeByName getColumnSizes() const override;\n \n     ColumnsDescription getColumnsDescriptionFromSourceTables() const;\n \n+    static VirtualColumnsDescription createVirtuals();\n+\n     bool tableSupportsPrewhere() const;\n \n     template <typename F>\n@@ -281,6 +284,8 @@ class ReadFromMerge final : public SourceStepWithFilter\n         ContextPtr query_context,\n         bool filter_by_database_virtual_column,\n         bool filter_by_table_virtual_column) const;\n+\n+    // static VirtualColumnsDescription createVirtuals(StoragePtr first_table);\n };\n \n }\ndiff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h\nindex 18a1f9086aed..a8e7fd528ddc 100644\n--- a/src/Storages/StorageProxy.h\n+++ b/src/Storages/StorageProxy.h\n@@ -30,7 +30,6 @@ class StorageProxy : public IStorage\n     bool hasEvenlyDistributedRead() const override { return getNested()->hasEvenlyDistributedRead(); }\n \n     ColumnSizeByName getColumnSizes() const override { return getNested()->getColumnSizes(); }\n-    NamesAndTypesList getVirtuals() const override { return getNested()->getVirtuals(); }\n \n     QueryProcessingStage::Enum getQueryProcessingStage(\n         ContextPtr context,\ndiff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp\nindex b73965b87746..72bbcdd3ea80 100644\n--- a/src/Storages/StorageS3.cpp\n+++ b/src/Storages/StorageS3.cpp\n@@ -161,7 +161,7 @@ class ReadFromStorageS3Step : public SourceStepWithFilter\n         , num_streams(num_streams_)\n     {\n         query_configuration = storage.updateConfigurationAndGetCopy(context);\n-        virtual_columns = storage.getVirtuals();\n+        virtual_columns = storage.getVirtualsList();\n     }\n \n private:\n@@ -1084,8 +1084,7 @@ StorageS3::StorageS3(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n static std::shared_ptr<StorageS3Source::IIterator> createFileIterator(\n@@ -1152,7 +1151,7 @@ void StorageS3::read(\n     size_t max_block_size,\n     size_t num_streams)\n {\n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context), virtual_columns);\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context));\n \n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && local_context->getSettingsRef().optimize_count_from_files;\n@@ -1985,16 +1984,6 @@ void registerStorageOSS(StorageFactory & factory)\n     return registerStorageS3Impl(\"OSS\", factory);\n }\n \n-NamesAndTypesList StorageS3::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-Names StorageS3::getVirtualColumnNames()\n-{\n-    return VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage({}).getNames();\n-}\n-\n bool StorageS3::supportsPartitionBy() const\n {\n     return true;\ndiff --git a/src/Storages/StorageS3.h b/src/Storages/StorageS3.h\nindex 65fb3b51be2e..7c5db76aadf2 100644\n--- a/src/Storages/StorageS3.h\n+++ b/src/Storages/StorageS3.h\n@@ -336,9 +336,6 @@ class StorageS3 : public IStorage\n \n     void truncate(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, ContextPtr local_context, TableExclusiveLockHolder &) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-    static Names getVirtualColumnNames();\n-\n     bool supportsPartitionBy() const override;\n \n     static void processNamedCollectionResult(StorageS3::Configuration & configuration, const NamedCollection & collection);\n@@ -378,7 +375,6 @@ class StorageS3 : public IStorage\n \n     Configuration configuration;\n     std::mutex configuration_update_mutex;\n-    NamesAndTypesList virtual_columns;\n \n     String name;\n     const bool distributed_processing;\ndiff --git a/src/Storages/StorageS3Cluster.cpp b/src/Storages/StorageS3Cluster.cpp\nindex 31c241a5b131..6b22771b38fd 100644\n--- a/src/Storages/StorageS3Cluster.cpp\n+++ b/src/Storages/StorageS3Cluster.cpp\n@@ -67,8 +67,7 @@ StorageS3Cluster::StorageS3Cluster(\n \n     storage_metadata.setConstraints(constraints_);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageS3Cluster::updateQueryToSendIfNeeded(DB::ASTPtr & query, const DB::StorageSnapshotPtr & storage_snapshot, const DB::ContextPtr & context)\n@@ -92,7 +91,7 @@ void StorageS3Cluster::updateConfigurationIfChanged(ContextPtr local_context)\n RemoteQueryExecutor::Extension StorageS3Cluster::getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const\n {\n     auto iterator = std::make_shared<StorageS3Source::DisclosedGlobIterator>(\n-        *s3_configuration.client, s3_configuration.url, predicate, virtual_columns, context, nullptr, s3_configuration.request_settings, context->getFileProgressCallback());\n+        *s3_configuration.client, s3_configuration.url, predicate, getVirtualsList(), context, nullptr, s3_configuration.request_settings, context->getFileProgressCallback());\n \n     auto callback = std::make_shared<std::function<String()>>([iterator]() mutable -> String\n     {\n@@ -103,12 +102,6 @@ RemoteQueryExecutor::Extension StorageS3Cluster::getTaskIteratorExtension(const\n     return RemoteQueryExecutor::Extension{ .task_iterator = std::move(callback) };\n }\n \n-NamesAndTypesList StorageS3Cluster::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-\n }\n \n #endif\ndiff --git a/src/Storages/StorageS3Cluster.h b/src/Storages/StorageS3Cluster.h\nindex 03155b6e707d..6a5b03e682fe 100644\n--- a/src/Storages/StorageS3Cluster.h\n+++ b/src/Storages/StorageS3Cluster.h\n@@ -28,8 +28,6 @@ class StorageS3Cluster : public IStorageCluster\n \n     std::string getName() const override { return \"S3Cluster\"; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -45,7 +43,6 @@ class StorageS3Cluster : public IStorageCluster\n     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;\n \n     StorageS3::Configuration s3_configuration;\n-    NamesAndTypesList virtual_columns;\n };\n \n \ndiff --git a/src/Storages/StorageSnapshot.cpp b/src/Storages/StorageSnapshot.cpp\nindex 34c092c72087..222173fd66b8 100644\n--- a/src/Storages/StorageSnapshot.cpp\n+++ b/src/Storages/StorageSnapshot.cpp\n@@ -1,6 +1,4 @@\n #include <Storages/StorageSnapshot.h>\n-#include <Storages/LightweightDeleteDescription.h>\n-#include <Storages/BlockNumberColumn.h>\n #include <Storages/IStorage.h>\n #include <DataTypes/ObjectUtils.h>\n #include <DataTypes/NestedUtils.h>\n@@ -18,25 +16,57 @@ namespace ErrorCodes\n     extern const int COLUMN_QUERIED_MORE_THAN_ONCE;\n }\n \n-std::shared_ptr<StorageSnapshot> StorageSnapshot::clone(DataPtr data_) const\n+StorageSnapshot::StorageSnapshot(\n+    const IStorage & storage_,\n+    StorageMetadataPtr metadata_)\n+    : storage(storage_)\n+    , metadata(std::move(metadata_))\n+    , virtual_columns(storage_.getVirtualsPtr())\n {\n-    auto res = std::make_shared<StorageSnapshot>(storage, metadata, object_columns);\n+}\n \n-    res->projection = projection;\n-    res->data = std::move(data_);\n+StorageSnapshot::StorageSnapshot(\n+    const IStorage & storage_,\n+    StorageMetadataPtr metadata_,\n+    VirtualsDescriptionPtr virtual_columns_)\n+    : storage(storage_)\n+    , metadata(std::move(metadata_))\n+    , virtual_columns(std::move(virtual_columns_))\n+{\n+}\n \n-    return res;\n+StorageSnapshot::StorageSnapshot(\n+    const IStorage & storage_,\n+    StorageMetadataPtr metadata_,\n+    ColumnsDescription object_columns_)\n+    : storage(storage_)\n+    , metadata(std::move(metadata_))\n+    , virtual_columns(storage_.getVirtualsPtr())\n+    , object_columns(std::move(object_columns_))\n+{\n+}\n+\n+StorageSnapshot::StorageSnapshot(\n+    const IStorage & storage_,\n+    StorageMetadataPtr metadata_,\n+    ColumnsDescription object_columns_,\n+    DataPtr data_)\n+    : storage(storage_)\n+    , metadata(std::move(metadata_))\n+    , virtual_columns(storage_.getVirtualsPtr())\n+    , object_columns(std::move(object_columns_))\n+    , data(std::move(data_))\n+{\n }\n \n-void StorageSnapshot::init()\n+std::shared_ptr<StorageSnapshot> StorageSnapshot::clone(DataPtr data_) const\n {\n-    for (const auto & [name, type] : storage.getVirtuals())\n-        virtual_columns[name] = type;\n+    auto res = std::make_shared<StorageSnapshot>(storage, metadata, object_columns);\n \n-    if (storage.hasLightweightDeletedMask())\n-        system_columns[LightweightDeleteDescription::FILTER_COLUMN.name] = LightweightDeleteDescription::FILTER_COLUMN.type;\n+    res->projection = projection;\n+    res->data = std::move(data_);\n \n-    system_columns[BlockNumberColumn::name] = BlockNumberColumn::type;\n+    return res;\n }\n \n NamesAndTypesList StorageSnapshot::getColumns(const GetColumnsOptions & options) const\n@@ -46,33 +76,20 @@ NamesAndTypesList StorageSnapshot::getColumns(const GetColumnsOptions & options)\n     if (options.with_extended_objects)\n         extendObjectColumns(all_columns, object_columns, options.with_subcolumns);\n \n-    NameSet column_names;\n-    if (options.with_virtuals)\n+    if (options.virtuals_kind != VirtualsKind::None && !virtual_columns->empty())\n     {\n-        /// Virtual columns must be appended after ordinary,\n-        /// because user can override them.\n-        if (!virtual_columns.empty())\n-        {\n-            for (const auto & column : all_columns)\n-                column_names.insert(column.name);\n+        NameSet column_names;\n+        for (const auto & column : all_columns)\n+            column_names.insert(column.name);\n \n-            for (const auto & [name, type] : virtual_columns)\n-                if (!column_names.contains(name))\n-                    all_columns.emplace_back(name, type);\n-        }\n-    }\n-\n-    if (options.with_system_columns)\n-    {\n-        if (!system_columns.empty() && column_names.empty())\n+        auto virtuals_list = virtual_columns->getNamesAndTypesList(options.virtuals_kind);\n+        for (const auto & column : virtuals_list)\n         {\n-            for (const auto & column : all_columns)\n-                column_names.insert(column.name);\n-        }\n+            if (column_names.contains(column.name))\n+                continue;\n \n-        for (const auto & [name, type] : system_columns)\n-            if (!column_names.contains(name))\n-                all_columns.emplace_back(name, type);\n+            all_columns.emplace_back(column.name, column.type);\n+        }\n     }\n \n     return all_columns;\n@@ -100,18 +117,11 @@ std::optional<NameAndTypePair> StorageSnapshot::tryGetColumn(const GetColumnsOpt\n             return object_column;\n     }\n \n-    if (options.with_virtuals)\n-    {\n-        auto it = virtual_columns.find(column_name);\n-        if (it != virtual_columns.end())\n-            return NameAndTypePair(column_name, it->second);\n-    }\n-\n-    if (options.with_system_columns)\n+    if (options.virtuals_kind != VirtualsKind::None)\n     {\n-        auto it = system_columns.find(column_name);\n-        if (it != system_columns.end())\n-            return NameAndTypePair(column_name, it->second);\n+        auto virtual_column = virtual_columns->tryGet(column_name, options.virtuals_kind);\n+        if (virtual_column)\n+            return NameAndTypePair{virtual_column->name, virtual_column->type};\n     }\n \n     return {};\n@@ -126,6 +136,47 @@ NameAndTypePair StorageSnapshot::getColumn(const GetColumnsOptions & options, co\n     return *column;\n }\n \n+CompressionCodecPtr StorageSnapshot::getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n+{\n+    auto get_codec_or_default = [&](const auto & column_desc)\n+    {\n+        return column_desc.codec\n+            ? CompressionCodecFactory::instance().get(column_desc.codec, column_desc.type, default_codec)\n+            : default_codec;\n+    };\n+\n+    const auto & columns = metadata->getColumns();\n+    if (const auto * column_desc = columns.tryGet(column_name))\n+        return get_codec_or_default(*column_desc);\n+\n+    if (const auto * virtual_desc = virtual_columns->tryGetDescription(column_name))\n+        return get_codec_or_default(*virtual_desc);\n+\n+    return default_codec;\n+}\n+\n+CompressionCodecPtr StorageSnapshot::getCodecOrDefault(const String & column_name) const\n+{\n+    return getCodecOrDefault(column_name, CompressionCodecFactory::instance().getDefaultCodec());\n+}\n+\n+ASTPtr StorageSnapshot::getCodecDescOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n+{\n+    auto get_codec_or_default = [&](const auto & column_desc)\n+    {\n+        return column_desc.codec ? column_desc.codec : default_codec->getFullCodecDesc();\n+    };\n+\n+    const auto & columns = metadata->getColumns();\n+    if (const auto * column_desc = columns.tryGet(column_name))\n+        return get_codec_or_default(*column_desc);\n+\n+    if (const auto * virtual_desc = virtual_columns->tryGetDescription(column_name))\n+        return get_codec_or_default(*virtual_desc);\n+\n+    return default_codec->getFullCodecDesc();\n+}\n+\n Block StorageSnapshot::getSampleBlockForColumns(const Names & column_names) const\n {\n     Block res;\n@@ -143,11 +194,11 @@ Block StorageSnapshot::getSampleBlockForColumns(const Names & column_names) cons\n         {\n             res.insert({object_column->type->createColumn(), object_column->type, column_name});\n         }\n-        else if (auto it = virtual_columns.find(column_name); it != virtual_columns.end())\n+        else if (auto virtual_column = virtual_columns->tryGet(column_name))\n         {\n             /// Virtual columns must be appended after ordinary, because user can\n             /// override them.\n-            const auto & type = it->second;\n+            const auto & type = virtual_column->type;\n             res.insert({type->createColumn(), type, column_name});\n         }\n         else\n@@ -175,12 +226,11 @@ ColumnsDescription StorageSnapshot::getDescriptionForColumns(const Names & colum\n         {\n             res.add(*object_column, \"\", false, false);\n         }\n-        else if (auto it = virtual_columns.find(name); it != virtual_columns.end())\n+        else if (auto virtual_column = virtual_columns->tryGet(name))\n         {\n             /// Virtual columns must be appended after ordinary, because user can\n             /// override them.\n-            const auto & type = it->second;\n-            res.add({name, type});\n+            res.add({name, virtual_column->type});\n         }\n         else\n         {\n@@ -216,7 +266,7 @@ void StorageSnapshot::check(const Names & column_names) const\n     {\n         bool has_column = columns.hasColumnOrSubcolumn(GetColumnsOptions::AllPhysical, name)\n             || object_columns.hasColumnOrSubcolumn(GetColumnsOptions::AllPhysical, name)\n-            || virtual_columns.contains(name);\n+            || virtual_columns->has(name);\n \n         if (!has_column)\n         {\ndiff --git a/src/Storages/StorageSnapshot.h b/src/Storages/StorageSnapshot.h\nindex d62e118e1f28..63e4cbd99f66 100644\n--- a/src/Storages/StorageSnapshot.h\n+++ b/src/Storages/StorageSnapshot.h\n@@ -1,10 +1,14 @@\n #pragma once\n #include <Storages/StorageInMemoryMetadata.h>\n+#include <Storages/VirtualColumnsDescription.h>\n \n namespace DB\n {\n \n class IStorage;\n+class ICompressionCodec;\n+\n+using CompressionCodecPtr = std::shared_ptr<ICompressionCodec>;\n \n /// Snapshot of storage that fixes set columns that can be read in query.\n /// There are 3 sources of columns: regular columns from metadata,\n@@ -13,6 +17,7 @@ struct StorageSnapshot\n {\n     const IStorage & storage;\n     const StorageMetadataPtr metadata;\n+    const VirtualsDescriptionPtr virtual_columns;\n     const ColumnsDescription object_columns;\n \n     /// Additional data, on which set of columns may depend.\n@@ -30,35 +35,23 @@ struct StorageSnapshot\n \n     StorageSnapshot(\n         const IStorage & storage_,\n-        StorageMetadataPtr metadata_)\n-        : storage(storage_), metadata(std::move(metadata_))\n-    {\n-        init();\n-    }\n+        StorageMetadataPtr metadata_);\n \n     StorageSnapshot(\n         const IStorage & storage_,\n         StorageMetadataPtr metadata_,\n-        ColumnsDescription object_columns_)\n-        : storage(storage_)\n-        , metadata(std::move(metadata_))\n-        , object_columns(std::move(object_columns_))\n-    {\n-        init();\n-    }\n+        VirtualsDescriptionPtr virtual_columns_);\n+\n+    StorageSnapshot(\n+        const IStorage & storage_,\n+        StorageMetadataPtr metadata_,\n+        ColumnsDescription object_columns_);\n \n     StorageSnapshot(\n         const IStorage & storage_,\n         StorageMetadataPtr metadata_,\n         ColumnsDescription object_columns_,\n-        DataPtr data_)\n-        : storage(storage_)\n-        , metadata(std::move(metadata_))\n-        , object_columns(std::move(object_columns_))\n-        , data(std::move(data_))\n-    {\n-        init();\n-    }\n+        DataPtr data_);\n \n     std::shared_ptr<StorageSnapshot> clone(DataPtr data_) const;\n \n@@ -72,6 +65,10 @@ struct StorageSnapshot\n     std::optional<NameAndTypePair> tryGetColumn(const GetColumnsOptions & options, const String & column_name) const;\n     NameAndTypePair getColumn(const GetColumnsOptions & options, const String & column_name) const;\n \n+    CompressionCodecPtr getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const;\n+    CompressionCodecPtr getCodecOrDefault(const String & column_name) const;\n+    ASTPtr getCodecDescOrDefault(const String & column_name, CompressionCodecPtr default_codec) const;\n+\n     /// Block with ordinary + materialized + aliases + virtuals + subcolumns.\n     Block getSampleBlockForColumns(const Names & column_names) const;\n \n@@ -87,15 +84,6 @@ struct StorageSnapshot\n \n     /// If we have a projection then we should use its metadata.\n     StorageMetadataPtr getMetadataForQuery() const { return projection ? projection->metadata : metadata; }\n-\n-private:\n-    void init();\n-\n-    std::unordered_map<String, DataTypePtr> virtual_columns;\n-\n-    /// System columns are not visible in the schema but might be persisted in the data.\n-    /// One example of such column is lightweight delete mask '_row_exists'.\n-    std::unordered_map<String, DataTypePtr> system_columns;\n };\n \n using StorageSnapshotPtr = std::shared_ptr<StorageSnapshot>;\ndiff --git a/src/Storages/StorageURL.cpp b/src/Storages/StorageURL.cpp\nindex 40acee57e7c5..039be222e7e9 100644\n--- a/src/Storages/StorageURL.cpp\n+++ b/src/Storages/StorageURL.cpp\n@@ -152,8 +152,7 @@ IStorageURLBase::IStorageURLBase(\n     storage_metadata.setConstraints(constraints_);\n     storage_metadata.setComment(comment);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n \n@@ -1059,7 +1058,7 @@ void IStorageURLBase::read(\n     size_t num_streams)\n {\n     auto params = getReadURIParams(column_names, storage_snapshot, query_info, local_context, processed_stage, max_block_size);\n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context));\n \n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && local_context->getSettingsRef().optimize_count_from_files;\n@@ -1127,7 +1126,7 @@ void ReadFromURL::createIterator(const ActionsDAG::Node * predicate)\n     else if (is_url_with_globs)\n     {\n         /// Iterate through disclosed globs and make a source for each file\n-        auto glob_iterator = std::make_shared<StorageURLSource::DisclosedGlobIterator>(storage->uri, max_addresses, predicate, storage->virtual_columns, context);\n+        auto glob_iterator = std::make_shared<StorageURLSource::DisclosedGlobIterator>(storage->uri, max_addresses, predicate, storage->getVirtualsList(), context);\n \n         /// check if we filtered out all the paths\n         if (glob_iterator->size() == 0)\n@@ -1230,7 +1229,7 @@ void StorageURLWithFailover::read(\n     size_t num_streams)\n {\n     auto params = getReadURIParams(column_names, storage_snapshot, query_info, local_context, processed_stage, max_block_size);\n-    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context), getVirtuals());\n+    auto read_from_format_info = prepareReadingFromFormat(column_names, storage_snapshot, supportsSubsetOfColumns(local_context));\n \n     bool need_only_count = (query_info.optimize_trivial_count || read_from_format_info.requested_columns.empty())\n         && local_context->getSettingsRef().optimize_count_from_files;\n@@ -1303,16 +1302,6 @@ SinkToStoragePtr IStorageURLBase::write(const ASTPtr & query, const StorageMetad\n     }\n }\n \n-NamesAndTypesList IStorageURLBase::getVirtuals() const\n-{\n-    return virtual_columns;\n-}\n-\n-Names IStorageURLBase::getVirtualColumnNames()\n-{\n-    return VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage({}).getNames();\n-}\n-\n SchemaCache & IStorageURLBase::getSchemaCache(const ContextPtr & context)\n {\n     static SchemaCache schema_cache(context->getConfigRef().getUInt(\"schema_inference_cache_max_elements_for_url\", DEFAULT_SCHEMA_CACHE_ELEMENTS));\ndiff --git a/src/Storages/StorageURL.h b/src/Storages/StorageURL.h\nindex 480670475ddd..294b1f828bbe 100644\n--- a/src/Storages/StorageURL.h\n+++ b/src/Storages/StorageURL.h\n@@ -48,9 +48,6 @@ class IStorageURLBase : public IStorage\n \n     bool supportsPartitionBy() const override { return true; }\n \n-    NamesAndTypesList getVirtuals() const override;\n-    static Names getVirtualColumnNames();\n-\n     static ColumnsDescription getTableStructureFromData(\n         const String & format,\n         const String & uri,\n@@ -106,8 +103,6 @@ class IStorageURLBase : public IStorage\n     ASTPtr partition_by;\n     bool distributed_processing;\n \n-    NamesAndTypesList virtual_columns;\n-\n     virtual std::string getReadMethod() const;\n \n     virtual std::vector<std::pair<std::string, std::string>> getReadURIParams(\ndiff --git a/src/Storages/StorageURLCluster.cpp b/src/Storages/StorageURLCluster.cpp\nindex d0df74d75219..2e7c63d00975 100644\n--- a/src/Storages/StorageURLCluster.cpp\n+++ b/src/Storages/StorageURLCluster.cpp\n@@ -75,8 +75,7 @@ StorageURLCluster::StorageURLCluster(\n \n     storage_metadata.setConstraints(constraints_);\n     setInMemoryMetadata(storage_metadata);\n-\n-    virtual_columns = VirtualColumnUtils::getPathFileAndSizeVirtualsForStorage(storage_metadata.getSampleBlock().getNamesAndTypesList());\n+    setVirtuals(VirtualColumnUtils::getVirtualsForFileLikeStorage(storage_metadata.getColumns()));\n }\n \n void StorageURLCluster::updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context)\n@@ -91,7 +90,7 @@ void StorageURLCluster::updateQueryToSendIfNeeded(ASTPtr & query, const StorageS\n \n RemoteQueryExecutor::Extension StorageURLCluster::getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const\n {\n-    auto iterator = std::make_shared<StorageURLSource::DisclosedGlobIterator>(uri, context->getSettingsRef().glob_expansion_max_elements, predicate, virtual_columns, context);\n+    auto iterator = std::make_shared<StorageURLSource::DisclosedGlobIterator>(uri, context->getSettingsRef().glob_expansion_max_elements, predicate, getVirtualsList(), context);\n     auto callback = std::make_shared<TaskIterator>([iter = std::move(iterator)]() mutable -> String { return iter->next(); });\n     return RemoteQueryExecutor::Extension{.task_iterator = std::move(callback)};\n }\ndiff --git a/src/Storages/StorageURLCluster.h b/src/Storages/StorageURLCluster.h\nindex f57d262f4343..dce2e0106eae 100644\n--- a/src/Storages/StorageURLCluster.h\n+++ b/src/Storages/StorageURLCluster.h\n@@ -31,8 +31,6 @@ class StorageURLCluster : public IStorageCluster\n \n     std::string getName() const override { return \"URLCluster\"; }\n \n-    NamesAndTypesList getVirtuals() const override { return virtual_columns; }\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n     bool supportsSubcolumns() const override { return true; }\n@@ -44,7 +42,6 @@ class StorageURLCluster : public IStorageCluster\n \n     String uri;\n     String format_name;\n-    NamesAndTypesList virtual_columns;\n };\n \n \ndiff --git a/src/Storages/StorageValues.cpp b/src/Storages/StorageValues.cpp\nindex 300b11b7346e..a930ffd13075 100644\n--- a/src/Storages/StorageValues.cpp\n+++ b/src/Storages/StorageValues.cpp\n@@ -12,12 +12,13 @@ StorageValues::StorageValues(\n     const StorageID & table_id_,\n     const ColumnsDescription & columns_,\n     const Block & res_block_,\n-    const NamesAndTypesList & virtuals_)\n-    : IStorage(table_id_), res_block(res_block_), virtuals(virtuals_)\n+    VirtualColumnsDescription virtuals_)\n+    : IStorage(table_id_), res_block(res_block_)\n {\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n     setInMemoryMetadata(storage_metadata);\n+    setVirtuals(std::move(virtuals_));\n }\n \n Pipe StorageValues::read(\ndiff --git a/src/Storages/StorageValues.h b/src/Storages/StorageValues.h\nindex af1c134077b0..ebb182ab6676 100644\n--- a/src/Storages/StorageValues.h\n+++ b/src/Storages/StorageValues.h\n@@ -11,8 +11,14 @@ namespace DB\n class StorageValues final : public IStorage\n {\n public:\n+    /// Why we may have virtual columns in the storage from a single block?\n+    /// Because it used as tmp storage for pushing blocks into views, and some\n+    /// views may contain virtual columns from original storage.\n     StorageValues(\n-        const StorageID & table_id_, const ColumnsDescription & columns_, const Block & res_block_, const NamesAndTypesList & virtuals_ = {});\n+        const StorageID & table_id_,\n+        const ColumnsDescription & columns_,\n+        const Block & res_block_,\n+        VirtualColumnsDescription virtuals_ = {});\n \n     std::string getName() const override { return \"Values\"; }\n \n@@ -25,13 +31,6 @@ class StorageValues final : public IStorage\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    /// Why we may have virtual columns in the storage from a single block?\n-    /// Because it used as tmp storage for pushing blocks into views, and some\n-    /// views may contain virtual columns from original storage.\n-    NamesAndTypesList getVirtuals() const override\n-    {\n-        return virtuals;\n-    }\n \n     /// FIXME probably it should return false, but StorageValues is used in ExecutingInnerQueryFromViewTransform (whatever it is)\n     bool supportsTransactions() const override { return true; }\n@@ -40,7 +39,6 @@ class StorageValues final : public IStorage\n \n private:\n     Block res_block;\n-    NamesAndTypesList virtuals;\n };\n \n }\ndiff --git a/src/Storages/System/IStorageSystemOneBlock.cpp b/src/Storages/System/IStorageSystemOneBlock.cpp\nindex 20c8f3517eee..53399654c8d4 100644\n--- a/src/Storages/System/IStorageSystemOneBlock.cpp\n+++ b/src/Storages/System/IStorageSystemOneBlock.cpp\n@@ -56,10 +56,9 @@ void IStorageSystemOneBlock::read(\n     QueryProcessingStage::Enum /*processed_stage*/,\n     size_t /*max_block_size*/,\n     size_t /*num_streams*/)\n-\n {\n     storage_snapshot->check(column_names);\n-    Block sample_block = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtuals());\n+    Block sample_block = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtualsList());\n     std::vector<UInt8> columns_mask;\n \n     if (supportsColumnsMask())\ndiff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp\nindex b3a60e16d059..a19741f92d1f 100644\n--- a/src/Storages/System/StorageSystemDictionaries.cpp\n+++ b/src/Storages/System/StorageSystemDictionaries.cpp\n@@ -16,7 +16,6 @@\n #include <Core/Names.h>\n \n #include <base/map.h>\n-#include <mutex>\n \n namespace DB\n {\n@@ -52,6 +51,14 @@ catch (const DB::Exception &)\n \n }\n \n+StorageSystemDictionaries::StorageSystemDictionaries(const StorageID & storage_id_, ColumnsDescription columns_description_)\n+    : IStorageSystemOneBlock(storage_id_, std::move(columns_description_))\n+{\n+    VirtualColumnsDescription virtuals;\n+    virtuals.addEphemeral(\"key\", std::make_shared<DataTypeString>(), \"\");\n+    setVirtuals(std::move(virtuals));\n+}\n+\n ColumnsDescription StorageSystemDictionaries::getColumnsDescription()\n {\n     return ColumnsDescription\n@@ -92,13 +99,6 @@ ColumnsDescription StorageSystemDictionaries::getColumnsDescription()\n     };\n }\n \n-NamesAndTypesList StorageSystemDictionaries::getVirtuals() const\n-{\n-    return {\n-        {\"key\", std::make_shared<DataTypeString>()}\n-    };\n-}\n-\n void StorageSystemDictionaries::fillData(MutableColumns & res_columns, ContextPtr context, const ActionsDAG::Node *, std::vector<UInt8>) const\n {\n     const auto access = context->getAccess();\ndiff --git a/src/Storages/System/StorageSystemDictionaries.h b/src/Storages/System/StorageSystemDictionaries.h\nindex 1a071fda8727..058b8b163d92 100644\n--- a/src/Storages/System/StorageSystemDictionaries.h\n+++ b/src/Storages/System/StorageSystemDictionaries.h\n@@ -12,15 +12,13 @@ class Context;\n class StorageSystemDictionaries final : public IStorageSystemOneBlock\n {\n public:\n+    StorageSystemDictionaries(const StorageID & storage_id_, ColumnsDescription columns_description_);\n+\n     std::string getName() const override { return \"SystemDictionaries\"; }\n \n     static ColumnsDescription getColumnsDescription();\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n protected:\n-    using IStorageSystemOneBlock::IStorageSystemOneBlock;\n-\n     void fillData(MutableColumns & res_columns, ContextPtr context, const ActionsDAG::Node *, std::vector<UInt8>) const override;\n };\n \ndiff --git a/src/Storages/System/StorageSystemJemalloc.cpp b/src/Storages/System/StorageSystemJemalloc.cpp\nindex 15543208dd9e..b55e32c479cd 100644\n--- a/src/Storages/System/StorageSystemJemalloc.cpp\n+++ b/src/Storages/System/StorageSystemJemalloc.cpp\n@@ -115,7 +115,7 @@ Pipe StorageSystemJemallocBins::read(\n {\n     storage_snapshot->check(column_names);\n \n-    auto header = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtuals());\n+    auto header = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtualsList());\n     MutableColumns res_columns = header.cloneEmptyColumns();\n \n     fillJemallocBins(res_columns);\ndiff --git a/src/Storages/System/StorageSystemPartsBase.cpp b/src/Storages/System/StorageSystemPartsBase.cpp\nindex f31dd5a955e7..6bdfdd357e8a 100644\n--- a/src/Storages/System/StorageSystemPartsBase.cpp\n+++ b/src/Storages/System/StorageSystemPartsBase.cpp\n@@ -325,12 +325,10 @@ StorageSystemPartsBase::StorageSystemPartsBase(const StorageID & table_id_, Colu\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns);\n     setInMemoryMetadata(storage_metadata);\n-}\n \n-NamesAndTypesList StorageSystemPartsBase::getVirtuals() const\n-{\n-    return NamesAndTypesList{\n-        NameAndTypePair(\"_state\", std::make_shared<DataTypeString>())\n-    };\n+    VirtualColumnsDescription virtuals;\n+    virtuals.addEphemeral(\"_state\", std::make_shared<DataTypeString>(), \"\");\n+    setVirtuals(std::move(virtuals));\n }\n+\n }\ndiff --git a/src/Storages/System/StorageSystemPartsBase.h b/src/Storages/System/StorageSystemPartsBase.h\nindex b5d4a74e58ba..0527a99b8413 100644\n--- a/src/Storages/System/StorageSystemPartsBase.h\n+++ b/src/Storages/System/StorageSystemPartsBase.h\n@@ -133,8 +133,6 @@ class StorageSystemPartsBase : public IStorage\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    NamesAndTypesList getVirtuals() const override;\n-\n     bool isSystemStorage() const override { return true; }\n \n private:\ndiff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp\nindex 2845e1946144..d1bf86ba8efd 100644\n--- a/src/Storages/System/StorageSystemZooKeeper.cpp\n+++ b/src/Storages/System/StorageSystemZooKeeper.cpp\n@@ -233,9 +233,9 @@ class SystemZooKeeperSource : public ISource\n StorageSystemZooKeeper::StorageSystemZooKeeper(const StorageID & table_id_)\n         : IStorage(table_id_)\n {\n-        StorageInMemoryMetadata storage_metadata;\n-        storage_metadata.setColumns(getColumnsDescription());\n-        setInMemoryMetadata(storage_metadata);\n+    StorageInMemoryMetadata storage_metadata;\n+    storage_metadata.setColumns(getColumnsDescription());\n+    setInMemoryMetadata(storage_metadata);\n }\n \n void StorageSystemZooKeeper::read(\n@@ -248,7 +248,7 @@ void StorageSystemZooKeeper::read(\n     size_t max_block_size,\n     size_t /*num_streams*/)\n {\n-    auto header = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtuals());\n+    auto header = storage_snapshot->metadata->getSampleBlockWithVirtuals(getVirtualsList());\n     auto read_step = std::make_unique<ReadFromSystemZooKeeper>(\n         column_names,\n         query_info,\ndiff --git a/src/Storages/VirtualColumnUtils.cpp b/src/Storages/VirtualColumnUtils.cpp\nindex 386dcd177337..22466b3d4c28 100644\n--- a/src/Storages/VirtualColumnUtils.cpp\n+++ b/src/Storages/VirtualColumnUtils.cpp\n@@ -109,23 +109,28 @@ void filterBlockWithDAG(ActionsDAGPtr dag, Block & block, ContextPtr context)\n     }\n }\n \n-NamesAndTypesList getPathFileAndSizeVirtualsForStorage(NamesAndTypesList storage_columns)\n+NameSet getVirtualNamesForFileLikeStorage()\n {\n-    auto default_virtuals = NamesAndTypesList{\n-        {\"_path\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_file\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n-        {\"_size\", makeNullable(std::make_shared<DataTypeUInt64>())}};\n+    return {\"_path\", \"_file\", \"_size\"};\n+}\n+\n+VirtualColumnsDescription getVirtualsForFileLikeStorage(const ColumnsDescription & storage_columns)\n+{\n+    VirtualColumnsDescription desc;\n+\n+    auto add_virtual = [&](const auto & name, const auto & type)\n+    {\n+        if (storage_columns.has(name))\n+            return;\n \n-    default_virtuals.sort();\n-    storage_columns.sort();\n+        desc.addEphemeral(name, type, \"\");\n+    };\n \n-    NamesAndTypesList result_virtuals;\n-    std::set_difference(\n-        default_virtuals.begin(), default_virtuals.end(), storage_columns.begin(), storage_columns.end(),\n-        std::back_inserter(result_virtuals),\n-        [](const NameAndTypePair & lhs, const NameAndTypePair & rhs){ return lhs.name < rhs.name; });\n+    add_virtual(\"_path\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()));\n+    add_virtual(\"_file\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()));\n+    add_virtual(\"_size\", makeNullable(std::make_shared<DataTypeUInt64>()));\n \n-    return result_virtuals;\n+    return desc;\n }\n \n static void addPathAndFileToVirtualColumns(Block & block, const String & path, size_t idx)\ndiff --git a/src/Storages/VirtualColumnUtils.h b/src/Storages/VirtualColumnUtils.h\nindex 3e7299b4a634..b5526fc5c7fa 100644\n--- a/src/Storages/VirtualColumnUtils.h\n+++ b/src/Storages/VirtualColumnUtils.h\n@@ -4,6 +4,7 @@\n #include <Interpreters/Context_fwd.h>\n #include <Parsers/IAST_fwd.h>\n #include <Storages/SelectQueryInfo.h>\n+#include <Storages/VirtualColumnsDescription.h>\n \n #include <unordered_set>\n \n@@ -39,7 +40,8 @@ auto extractSingleValueFromBlock(const Block & block, const String & name)\n     return res;\n }\n \n-NamesAndTypesList getPathFileAndSizeVirtualsForStorage(NamesAndTypesList storage_columns);\n+NameSet getVirtualNamesForFileLikeStorage();\n+VirtualColumnsDescription getVirtualsForFileLikeStorage(const ColumnsDescription & storage_columns);\n \n ActionsDAGPtr createPathAndFileFilterDAG(const ActionsDAG::Node * predicate, const NamesAndTypesList & virtual_columns);\n \ndiff --git a/src/Storages/VirtualColumnsDescription.cpp b/src/Storages/VirtualColumnsDescription.cpp\nnew file mode 100644\nindex 000000000000..64097224ed94\n--- /dev/null\n+++ b/src/Storages/VirtualColumnsDescription.cpp\n@@ -0,0 +1,94 @@\n+#include <Storages/VirtualColumnsDescription.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int DUPLICATE_COLUMN;\n+    extern const int NO_SUCH_COLUMN_IN_TABLE;\n+}\n+\n+VirtualColumnDescription::VirtualColumnDescription(\n+    String name_, DataTypePtr type_, ASTPtr codec_, String comment_, VirtualsKind kind_)\n+    : ColumnDescription(std::move(name_), std::move(type_), std::move(codec_), std::move(comment_))\n+    , kind(kind_)\n+{\n+}\n+\n+void VirtualColumnsDescription::add(VirtualColumnDescription desc)\n+{\n+    if (container.get<1>().contains(desc.name))\n+        throw Exception(ErrorCodes::DUPLICATE_COLUMN, \"Virtual column {} already exists\", desc.name);\n+\n+    container.get<0>().push_back(std::move(desc));\n+}\n+\n+void VirtualColumnsDescription::addEphemeral(String name, DataTypePtr type, String comment)\n+{\n+    add({std::move(name), std::move(type), nullptr, std::move(comment), VirtualsKind::Ephemeral});\n+}\n+\n+void VirtualColumnsDescription::addPersistent(String name, DataTypePtr type, ASTPtr codec, String comment)\n+{\n+    add({std::move(name), std::move(type), std::move(codec), std::move(comment), VirtualsKind::Persistent});\n+}\n+\n+std::optional<NameAndTypePair> VirtualColumnsDescription::tryGet(const String & name, VirtualsKind kind) const\n+{\n+    auto it = container.get<1>().find(name);\n+    if (it != container.get<1>().end() && (static_cast<UInt8>(it->kind) & static_cast<UInt8>(kind)))\n+        return NameAndTypePair{it->name, it->type};\n+    return {};\n+}\n+\n+NameAndTypePair VirtualColumnsDescription::get(const String & name, VirtualsKind kind) const\n+{\n+    auto column = tryGet(name, kind);\n+    if (!column)\n+        throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no virtual column {}\", name);\n+    return *column;\n+}\n+\n+const VirtualColumnDescription * VirtualColumnsDescription::tryGetDescription(const String & name, VirtualsKind kind) const\n+{\n+    auto it = container.get<1>().find(name);\n+    if (it != container.get<1>().end() && (static_cast<UInt8>(it->kind) & static_cast<UInt8>(kind)))\n+        return &(*it);\n+    return nullptr;\n+}\n+\n+const VirtualColumnDescription & VirtualColumnsDescription::getDescription(const String & name, VirtualsKind kind) const\n+{\n+    const auto * column = tryGetDescription(name, kind);\n+    if (!column)\n+        throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no virtual column {}\", name);\n+    return *column;\n+}\n+\n+Block VirtualColumnsDescription::getSampleBlock() const\n+{\n+    Block result;\n+    for (const auto & desc : container)\n+        result.insert({desc.type->createColumn(), desc.type, desc.name});\n+    return result;\n+}\n+\n+NamesAndTypesList VirtualColumnsDescription::getNamesAndTypesList() const\n+{\n+    NamesAndTypesList result;\n+    for (const auto & desc : container)\n+        result.emplace_back(desc.name, desc.type);\n+    return result;\n+}\n+\n+NamesAndTypesList VirtualColumnsDescription::getNamesAndTypesList(VirtualsKind kind) const\n+{\n+    NamesAndTypesList result;\n+    for (const auto & column : container)\n+        if (static_cast<UInt8>(column.kind) & static_cast<UInt8>(kind))\n+            result.emplace_back(column.name, column.type);\n+    return result;\n+}\n+\n+}\ndiff --git a/src/Storages/VirtualColumnsDescription.h b/src/Storages/VirtualColumnsDescription.h\nnew file mode 100644\nindex 000000000000..e11ba7067184\n--- /dev/null\n+++ b/src/Storages/VirtualColumnsDescription.h\n@@ -0,0 +1,71 @@\n+#pragma once\n+#include <Storages/ColumnsDescription.h>\n+#include <Common/MultiVersion.h>\n+\n+namespace DB\n+{\n+\n+struct VirtualColumnDescription : public ColumnDescription\n+{\n+    using Self = VirtualColumnDescription;\n+    VirtualsKind kind;\n+\n+    VirtualColumnDescription() = default;\n+    VirtualColumnDescription(String name_, DataTypePtr type_, ASTPtr codec_, String comment_, VirtualsKind kind_);\n+\n+    bool isEphemeral() const { return kind == VirtualsKind::Ephemeral; }\n+    bool isPersistent() const { return kind == VirtualsKind::Persistent; }\n+\n+    /// This method is needed for boost::multi_index because field\n+    /// of base class cannot be referenced in boost::multi_index::member.\n+    const String & getName() const { return name; }\n+};\n+\n+class VirtualColumnsDescription\n+{\n+public:\n+    using Container = boost::multi_index_container<\n+        VirtualColumnDescription,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::sequenced<>,\n+            boost::multi_index::ordered_unique<boost::multi_index::const_mem_fun<VirtualColumnDescription, const String &, &VirtualColumnDescription::getName>>>>;\n+\n+    using const_iterator = Container::const_iterator;\n+\n+    const_iterator begin() const { return container.begin(); }\n+    const_iterator end() const { return container.end(); }\n+\n+    VirtualColumnsDescription() = default;\n+\n+    void add(VirtualColumnDescription desc);\n+    void addEphemeral(String name, DataTypePtr type, String comment);\n+    void addPersistent(String name, DataTypePtr type, ASTPtr codec, String comment);\n+\n+    size_t size() const { return container.size(); }\n+    bool empty() const { return container.empty(); }\n+    bool has(const String & name) const { return container.get<1>().contains(name); }\n+\n+    NameAndTypePair get(const String & name, VirtualsKind kind) const;\n+    std::optional<NameAndTypePair> tryGet(const String & name, VirtualsKind kind) const;\n+\n+    NameAndTypePair get(const String & name) const { return get(name, VirtualsKind::All); }\n+    std::optional<NameAndTypePair> tryGet(const String & name) const { return tryGet(name, VirtualsKind::All); }\n+\n+    const VirtualColumnDescription * tryGetDescription(const String & name, VirtualsKind kind) const;\n+    const VirtualColumnDescription & getDescription(const String & name, VirtualsKind kind) const;\n+\n+    const VirtualColumnDescription * tryGetDescription(const String & name) const { return tryGetDescription(name, VirtualsKind::All); }\n+    const VirtualColumnDescription & getDescription(const String & name) const { return getDescription(name, VirtualsKind::All); }\n+\n+    Block getSampleBlock() const;\n+    NamesAndTypesList getNamesAndTypesList() const;\n+    NamesAndTypesList getNamesAndTypesList(VirtualsKind kind) const;\n+\n+private:\n+    Container container;\n+};\n+\n+using VirtualsDescriptionPtr = std::shared_ptr<const VirtualColumnsDescription>;\n+using MultiVersionVirtualsDescriptionPtr = MultiVersion<VirtualColumnsDescription>;\n+\n+}\ndiff --git a/src/Storages/prepareReadingFromFormat.cpp b/src/Storages/prepareReadingFromFormat.cpp\nindex 6be4213ec6b6..406b7f379f90 100644\n--- a/src/Storages/prepareReadingFromFormat.cpp\n+++ b/src/Storages/prepareReadingFromFormat.cpp\n@@ -4,7 +4,7 @@\n namespace DB\n {\n \n-ReadFromFormatInfo prepareReadingFromFormat(const Strings & requested_columns, const StorageSnapshotPtr & storage_snapshot, bool supports_subset_of_columns, const NamesAndTypesList & virtuals)\n+ReadFromFormatInfo prepareReadingFromFormat(const Strings & requested_columns, const StorageSnapshotPtr & storage_snapshot, bool supports_subset_of_columns)\n {\n     ReadFromFormatInfo info;\n     /// Collect requested virtual columns and remove them from requested columns.\n@@ -12,11 +12,11 @@ ReadFromFormatInfo prepareReadingFromFormat(const Strings & requested_columns, c\n     for (const auto & column_name : requested_columns)\n     {\n         bool is_virtual = false;\n-        for (const auto & virtual_column : virtuals)\n+        for (const auto & virtual_column : *storage_snapshot->virtual_columns)\n         {\n             if (column_name == virtual_column.name)\n             {\n-                info.requested_virtual_columns.push_back(virtual_column);\n+                info.requested_virtual_columns.emplace_back(virtual_column.name, virtual_column.type);\n                 is_virtual = true;\n                 break;\n             }\ndiff --git a/src/Storages/prepareReadingFromFormat.h b/src/Storages/prepareReadingFromFormat.h\nindex c5f3959a550d..e4d62c29ec6d 100644\n--- a/src/Storages/prepareReadingFromFormat.h\n+++ b/src/Storages/prepareReadingFromFormat.h\n@@ -22,5 +22,5 @@ namespace DB\n     };\n \n     /// Get all needed information for reading from data in some input format.\n-    ReadFromFormatInfo prepareReadingFromFormat(const Strings & requested_columns, const StorageSnapshotPtr & storage_snapshot, bool supports_subset_of_columns, const NamesAndTypesList & virtuals);\n+    ReadFromFormatInfo prepareReadingFromFormat(const Strings & requested_columns, const StorageSnapshotPtr & storage_snapshot, bool supports_subset_of_columns);\n }\ndiff --git a/src/TableFunctions/ITableFunctionFileLike.cpp b/src/TableFunctions/ITableFunctionFileLike.cpp\nindex b697f3df9251..1a58be4f75b7 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.cpp\n+++ b/src/TableFunctions/ITableFunctionFileLike.cpp\n@@ -7,6 +7,7 @@\n \n #include <Storages/StorageFile.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n+#include <Storages/VirtualColumnUtils.h>\n \n #include <Interpreters/evaluateConstantExpression.h>\n \n@@ -37,6 +38,11 @@ bool ITableFunctionFileLike::supportsReadingSubsetOfColumns(const ContextPtr & c\n     return format != \"auto\" && FormatFactory::instance().checkIfFormatSupportsSubsetOfColumns(format, context);\n }\n \n+NameSet ITableFunctionFileLike::getVirtualsToCheckBeforeUsingStructureHint() const\n+{\n+    return VirtualColumnUtils::getVirtualNamesForFileLikeStorage();\n+}\n+\n void ITableFunctionFileLike::parseArguments(const ASTPtr & ast_function, ContextPtr context)\n {\n     /// Parse args\ndiff --git a/src/TableFunctions/ITableFunctionFileLike.h b/src/TableFunctions/ITableFunctionFileLike.h\nindex c8412905e44a..ba1b7d2bb3fd 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.h\n+++ b/src/TableFunctions/ITableFunctionFileLike.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <TableFunctions/ITableFunction.h>\n+#include \"Core/Names.h\"\n #include \"Parsers/IAST_fwd.h\"\n \n namespace DB\n@@ -29,6 +30,8 @@ class ITableFunctionFileLike : public ITableFunction\n \n     bool supportsReadingSubsetOfColumns(const ContextPtr & context) override;\n \n+    NameSet getVirtualsToCheckBeforeUsingStructureHint() const override;\n+\n     static size_t getMaxNumberOfArguments() { return 4; }\n \n     static void updateStructureAndFormatArgumentsIfNeeded(ASTs & args, const String & structure, const String & format, const ContextPtr &);\ndiff --git a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\nindex 8f558adb09b1..275cd2a9cbbb 100644\n--- a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\n+++ b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\n@@ -16,6 +16,7 @@\n #include <Storages/StorageAzureBlob.h>\n #include <Storages/StorageURL.h>\n #include <Storages/NamedCollectionsHelpers.h>\n+#include <Storages/VirtualColumnUtils.h>\n #include <Formats/FormatFactory.h>\n #include \"registerTableFunctions.h\"\n #include <Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h>\n@@ -348,8 +349,7 @@ bool TableFunctionAzureBlobStorage::supportsReadingSubsetOfColumns(const Context\n \n std::unordered_set<String> TableFunctionAzureBlobStorage::getVirtualsToCheckBeforeUsingStructureHint() const\n {\n-    auto virtual_column_names = StorageAzureBlob::getVirtualColumnNames();\n-    return {virtual_column_names.begin(), virtual_column_names.end()};\n+    return VirtualColumnUtils::getVirtualNamesForFileLikeStorage();\n }\n \n StoragePtr TableFunctionAzureBlobStorage::executeImpl(const ASTPtr & /*ast_function*/, ContextPtr context, const std::string & table_name, ColumnsDescription /*cached_columns*/, bool is_insert_query) const\ndiff --git a/src/TableFunctions/TableFunctionFile.cpp b/src/TableFunctions/TableFunctionFile.cpp\nindex b481076e9b61..28bf72e07fb3 100644\n--- a/src/TableFunctions/TableFunctionFile.cpp\n+++ b/src/TableFunctions/TableFunctionFile.cpp\n@@ -112,12 +112,6 @@ ColumnsDescription TableFunctionFile::getActualTableStructure(ContextPtr context\n     return parseColumnsListFromString(structure, context);\n }\n \n-std::unordered_set<String> TableFunctionFile::getVirtualsToCheckBeforeUsingStructureHint() const\n-{\n-    auto virtual_column_names = StorageFile::getVirtualColumnNames();\n-    return {virtual_column_names.begin(), virtual_column_names.end()};\n-}\n-\n void registerTableFunctionFile(TableFunctionFactory & factory)\n {\n     factory.registerFunction<TableFunctionFile>();\ndiff --git a/src/TableFunctions/TableFunctionFile.h b/src/TableFunctions/TableFunctionFile.h\nindex c1924028b491..aaf5ba8873a5 100644\n--- a/src/TableFunctions/TableFunctionFile.h\n+++ b/src/TableFunctions/TableFunctionFile.h\n@@ -22,8 +22,6 @@ class TableFunctionFile : public ITableFunctionFileLike\n \n     ColumnsDescription getActualTableStructure(ContextPtr context, bool is_insert_query) const override;\n \n-    std::unordered_set<String> getVirtualsToCheckBeforeUsingStructureHint() const override;\n-\n protected:\n     int fd = -1;\n     String path_to_archive;\ndiff --git a/src/TableFunctions/TableFunctionHDFS.cpp b/src/TableFunctions/TableFunctionHDFS.cpp\nindex 2dac4398144b..45829245551d 100644\n--- a/src/TableFunctions/TableFunctionHDFS.cpp\n+++ b/src/TableFunctions/TableFunctionHDFS.cpp\n@@ -41,12 +41,6 @@ ColumnsDescription TableFunctionHDFS::getActualTableStructure(ContextPtr context\n     return parseColumnsListFromString(structure, context);\n }\n \n-std::unordered_set<String> TableFunctionHDFS::getVirtualsToCheckBeforeUsingStructureHint() const\n-{\n-    auto virtual_column_names = StorageHDFS::getVirtualColumnNames();\n-    return {virtual_column_names.begin(), virtual_column_names.end()};\n-}\n-\n void registerTableFunctionHDFS(TableFunctionFactory & factory)\n {\n     factory.registerFunction<TableFunctionHDFS>();\ndiff --git a/src/TableFunctions/TableFunctionHDFS.h b/src/TableFunctions/TableFunctionHDFS.h\nindex 3a719496b264..f1c0b8a7eaeb 100644\n--- a/src/TableFunctions/TableFunctionHDFS.h\n+++ b/src/TableFunctions/TableFunctionHDFS.h\n@@ -36,8 +36,6 @@ class TableFunctionHDFS : public ITableFunctionFileLike\n \n     ColumnsDescription getActualTableStructure(ContextPtr context, bool is_insert_query) const override;\n \n-    std::unordered_set<String> getVirtualsToCheckBeforeUsingStructureHint() const override;\n-\n private:\n     StoragePtr getStorage(\n         const String & source, const String & format_, const ColumnsDescription & columns, ContextPtr global_context,\ndiff --git a/src/TableFunctions/TableFunctionS3.cpp b/src/TableFunctions/TableFunctionS3.cpp\nindex c00b1e2e3e50..a8c100ebd44d 100644\n--- a/src/TableFunctions/TableFunctionS3.cpp\n+++ b/src/TableFunctions/TableFunctionS3.cpp\n@@ -16,6 +16,7 @@\n #include <Storages/StorageS3.h>\n #include <Storages/StorageURL.h>\n #include <Storages/NamedCollectionsHelpers.h>\n+#include <Storages/VirtualColumnUtils.h>\n #include <Formats/FormatFactory.h>\n #include \"registerTableFunctions.h\"\n #include <Analyzer/FunctionNode.h>\n@@ -401,8 +402,7 @@ bool TableFunctionS3::supportsReadingSubsetOfColumns(const ContextPtr & context)\n \n std::unordered_set<String> TableFunctionS3::getVirtualsToCheckBeforeUsingStructureHint() const\n {\n-    auto virtual_column_names = StorageS3::getVirtualColumnNames();\n-    return {virtual_column_names.begin(), virtual_column_names.end()};\n+    return VirtualColumnUtils::getVirtualNamesForFileLikeStorage();\n }\n \n StoragePtr TableFunctionS3::executeImpl(const ASTPtr & /*ast_function*/, ContextPtr context, const std::string & table_name, ColumnsDescription cached_columns, bool /*is_insert_query*/) const\ndiff --git a/src/TableFunctions/TableFunctionURL.cpp b/src/TableFunctions/TableFunctionURL.cpp\nindex a78b2affa9a0..2bdc0b449e0d 100644\n--- a/src/TableFunctions/TableFunctionURL.cpp\n+++ b/src/TableFunctions/TableFunctionURL.cpp\n@@ -159,12 +159,6 @@ ColumnsDescription TableFunctionURL::getActualTableStructure(ContextPtr context,\n     return parseColumnsListFromString(structure, context);\n }\n \n-std::unordered_set<String> TableFunctionURL::getVirtualsToCheckBeforeUsingStructureHint() const\n-{\n-    auto virtual_column_names = StorageURL::getVirtualColumnNames();\n-    return {virtual_column_names.begin(), virtual_column_names.end()};\n-}\n-\n std::optional<String> TableFunctionURL::tryGetFormatFromFirstArgument()\n {\n     return FormatFactory::instance().tryGetFormatFromFileName(Poco::URI(filename).getPath());\ndiff --git a/src/TableFunctions/TableFunctionURL.h b/src/TableFunctions/TableFunctionURL.h\nindex 54e223283ba7..a1efddb84c60 100644\n--- a/src/TableFunctions/TableFunctionURL.h\n+++ b/src/TableFunctions/TableFunctionURL.h\n@@ -36,8 +36,6 @@ class TableFunctionURL : public ITableFunctionFileLike\n \n     static void updateStructureAndFormatArgumentsIfNeeded(ASTs & args, const String & structure_, const String & format_, const ContextPtr & context);\n \n-    std::unordered_set<String> getVirtualsToCheckBeforeUsingStructureHint() const override;\n-\n protected:\n     void parseArguments(const ASTPtr & ast, ContextPtr context) override;\n     void parseArgumentsImpl(ASTs & args, const ContextPtr & context) override;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01848_partition_value_column.sql b/tests/queries/0_stateless/01848_partition_value_column.sql\nindex 28d842af3e9c..de5e766c92cd 100644\n--- a/tests/queries/0_stateless/01848_partition_value_column.sql\n+++ b/tests/queries/0_stateless/01848_partition_value_column.sql\n@@ -14,8 +14,8 @@ select count() from tbl where _partition_value.3 = 4 settings max_rows_to_read =\n \n create table tbl2(i int) engine MergeTree order by i;\n insert into tbl2 values (1);\n-select _partition_value from tbl2; -- { serverError 16 }\n-select _partition_value from tbl2 group by 1; -- { serverError 16 }\n+select _partition_value from tbl2; -- { serverError UNKNOWN_IDENTIFIER }\n+select _partition_value from tbl2 group by 1; -- { serverError UNKNOWN_IDENTIFIER }\n \n drop table tbl;\n drop table tbl2;\ndiff --git a/tests/queries/0_stateless/02235_add_part_offset_virtual_column.reference b/tests/queries/0_stateless/02235_add_part_offset_virtual_column.reference\nindex 2455f50b7f2a..e88abb35ab4d 100644\n--- a/tests/queries/0_stateless/02235_add_part_offset_virtual_column.reference\n+++ b/tests/queries/0_stateless/02235_add_part_offset_virtual_column.reference\n@@ -50,6 +50,8 @@ SOME GRANULES FILTERED OUT\n 100002\tfoo\n PREWHERE\n 301408\t164953047376\t164953047376\n+335872\t166463369216\t166463369216\n+301407\t164952947376\t164952947376\n 42\n 10042\n 20042\ndiff --git a/tests/queries/0_stateless/02235_add_part_offset_virtual_column.sql b/tests/queries/0_stateless/02235_add_part_offset_virtual_column.sql\nindex 73ae6eb499f8..5af6565c03d7 100644\n--- a/tests/queries/0_stateless/02235_add_part_offset_virtual_column.sql\n+++ b/tests/queries/0_stateless/02235_add_part_offset_virtual_column.sql\n@@ -52,7 +52,7 @@ SELECT _part_offset, foo FROM t_1 where granule == 0 AND _part_offset >= 100000\n \n SELECT 'PREWHERE';\n SELECT count(*), sum(_part_offset), sum(order_0) from t_1 prewhere granule == 0 where _part_offset >= 100000;\n-SELECT count(*), sum(_part_offset), sum(order_0) from t_1 prewhere _part != '' where granule == 0; -- { serverError 10, 16 }\n-SELECT count(*), sum(_part_offset), sum(order_0) from t_1 prewhere _part_offset > 100000 where granule == 0; -- { serverError 10, 16 }\n+SELECT count(*), sum(_part_offset), sum(order_0) from t_1 prewhere _part != '' where granule == 0;\n+SELECT count(*), sum(_part_offset), sum(order_0) from t_1 prewhere _part_offset > 100000 where granule == 0;\n SELECT _part_offset FROM t_1 PREWHERE order_0 % 10000 == 42 ORDER BY order_0 LIMIT 3;\n SELECT _part_offset, foo FROM t_1 PREWHERE order_0 % 10000 == 42 ORDER BY order_0 LIMIT 3;\ndiff --git a/tests/queries/0_stateless/02890_describe_table_options.reference b/tests/queries/0_stateless/02890_describe_table_options.reference\nindex 5d99df36bb43..ecbfe5a9f4d6 100644\n--- a/tests/queries/0_stateless/02890_describe_table_options.reference\n+++ b/tests/queries/0_stateless/02890_describe_table_options.reference\n@@ -2,237 +2,201 @@\n \n SET describe_compact_output = 0, describe_include_virtual_columns = 0, describe_include_subcolumns = 0;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\n-\u2502 id   \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502\n-\u2502 arr  \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n-\u2502 t    \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\n+\u2502 id   \u2502 UInt64                    \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502\n+\u2502 arr  \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n+\u2502 t    \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\n-\u2502 id   \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502\n-\u2502 arr  \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n-\u2502 t    \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\n+\u2502 id   \u2502 UInt64                    \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502\n+\u2502 arr  \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n+\u2502 t    \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 0, describe_include_virtual_columns = 0, describe_include_subcolumns = 1;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u2510\n-\u2502 id        \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502\n-\u2502 arr       \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n-\u2502 t         \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n-\u2502 arr.size0 \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502\n-\u2502 t.a       \u2502 String                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n-\u2502 t.b       \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u2510\n+\u2502 id        \u2502 UInt64                    \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502\n+\u2502 arr       \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n+\u2502 t         \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n+\u2502 arr.size0 \u2502 UInt64                    \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502\n+\u2502 t.a       \u2502 String                    \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n+\u2502 t.b       \u2502 UInt64                    \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u2510\n-\u2502 id        \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502\n-\u2502 arr       \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n-\u2502 t         \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n-\u2502 arr.size0 \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502\n-\u2502 t.a       \u2502 String                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n-\u2502 t.b       \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u2510\n+\u2502 id        \u2502 UInt64                    \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502\n+\u2502 arr       \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n+\u2502 t         \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502\n+\u2502 arr.size0 \u2502 UInt64                    \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502\n+\u2502 t.a       \u2502 String                    \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n+\u2502 t.b       \u2502 UInt64                    \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 0, describe_include_virtual_columns = 1, describe_include_subcolumns = 0;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id               \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502          0 \u2502\n-\u2502 arr              \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n-\u2502 t                \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n-\u2502 _part            \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_index      \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_uuid       \u2502 UUID                             \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _partition_id    \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _partition_value \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _sample_factor   \u2502 Float64                          \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_offset     \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _row_exists      \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _block_number    \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502              \u2502                    \u2502 index column                                                                            \u2502                  \u2502                \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of part                                                                            \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502              \u2502                    \u2502 Sequential index of the part in the query result                                        \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502              \u2502                    \u2502 Unique part identifier (if enabled MergeTree setting assign_part_uuids)                 \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of partition                                                                       \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502              \u2502                    \u2502 Sample factor (from the query)                                                          \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502              \u2502                    \u2502 Number of row in the part                                                               \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502              \u2502                    \u2502 Persisted mask created by lightweight delete that show whether row exists or is deleted \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502              \u2502                    \u2502 Persisted original number of block that was assigned at insert                          \u2502 Delta, LZ4       \u2502                \u2502          1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id             \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502          0 \u2502\n-\u2502 arr            \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n-\u2502 t              \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n-\u2502 _table         \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part          \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_index    \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_uuid     \u2502 UUID                             \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _partition_id  \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _sample_factor \u2502 Float64                          \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _part_offset   \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _row_exists    \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _block_number  \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2502 _shard_num     \u2502 UInt32                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502          1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502              \u2502                    \u2502 index column                                                                            \u2502                  \u2502                \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of part                                                                            \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502              \u2502                    \u2502 Sequential index of the part in the query result                                        \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502              \u2502                    \u2502 Unique part identifier (if enabled MergeTree setting assign_part_uuids)                 \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of partition                                                                       \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502              \u2502                    \u2502 Sample factor (from the query)                                                          \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502              \u2502                    \u2502 Number of row in the part                                                               \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502              \u2502                    \u2502 Persisted mask created by lightweight delete that show whether row exists or is deleted \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502              \u2502                    \u2502 Persisted original number of block that was assigned at insert                          \u2502 Delta, LZ4       \u2502                \u2502          1 \u2502\n+\u2502 _table         \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of a table                                                                         \u2502                  \u2502                \u2502          1 \u2502\n+\u2502 _shard_num     \u2502 UInt32                    \u2502              \u2502                    \u2502 Deprecated. Use function shardNum instead                                               \u2502                  \u2502                \u2502          1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 0, describe_include_virtual_columns = 1, describe_include_subcolumns = 1;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id               \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 arr              \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 t                \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 _part            \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_index      \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_uuid       \u2502 UUID                             \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_id    \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_value \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _sample_factor   \u2502 Float64                          \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_offset     \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _row_exists      \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _block_number    \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 arr.size0        \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502          0 \u2502\n-\u2502 t.a              \u2502 String                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n-\u2502 t.b              \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502              \u2502                    \u2502 index column                                                                            \u2502                  \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of part                                                                            \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502              \u2502                    \u2502 Sequential index of the part in the query result                                        \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502              \u2502                    \u2502 Unique part identifier (if enabled MergeTree setting assign_part_uuids)                 \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of partition                                                                       \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502              \u2502                    \u2502 Sample factor (from the query)                                                          \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502              \u2502                    \u2502 Number of row in the part                                                               \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502              \u2502                    \u2502 Persisted mask created by lightweight delete that show whether row exists or is deleted \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502              \u2502                    \u2502 Persisted original number of block that was assigned at insert                          \u2502 Delta, LZ4       \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 arr.size0      \u2502 UInt64                    \u2502              \u2502                    \u2502                                                                                         \u2502                  \u2502                \u2502            1 \u2502          0 \u2502\n+\u2502 t.a            \u2502 String                    \u2502              \u2502                    \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n+\u2502 t.b            \u2502 UInt64                    \u2502              \u2502                    \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id             \u2502 UInt64                           \u2502              \u2502                    \u2502 index column \u2502                  \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 arr            \u2502 Array(UInt64)                    \u2502 DEFAULT      \u2502 [10, 20]           \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 t              \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502              \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n-\u2502 _table         \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part          \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_index    \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_uuid     \u2502 UUID                             \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_id  \u2502 LowCardinality(String)           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _sample_factor \u2502 Float64                          \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _part_offset   \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _row_exists    \u2502 UInt8                            \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _block_number  \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 _shard_num     \u2502 UInt32                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n-\u2502 arr.size0      \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502                  \u2502                \u2502            1 \u2502          0 \u2502\n-\u2502 t.a            \u2502 String                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n-\u2502 t.b            \u2502 UInt64                           \u2502              \u2502                    \u2502              \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502              \u2502                    \u2502 index column                                                                            \u2502                  \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502 DEFAULT      \u2502 [10, 20]           \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502 DEFAULT      \u2502 ('foo', 0)         \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            0 \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of part                                                                            \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502              \u2502                    \u2502 Sequential index of the part in the query result                                        \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502              \u2502                    \u2502 Unique part identifier (if enabled MergeTree setting assign_part_uuids)                 \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of partition                                                                       \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502              \u2502                    \u2502 Sample factor (from the query)                                                          \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502              \u2502                    \u2502 Number of row in the part                                                               \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502              \u2502                    \u2502 Persisted mask created by lightweight delete that show whether row exists or is deleted \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502              \u2502                    \u2502 Persisted original number of block that was assigned at insert                          \u2502 Delta, LZ4       \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _table         \u2502 LowCardinality(String)    \u2502              \u2502                    \u2502 Name of a table                                                                         \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 _shard_num     \u2502 UInt32                    \u2502              \u2502                    \u2502 Deprecated. Use function shardNum instead                                               \u2502                  \u2502                \u2502            0 \u2502          1 \u2502\n+\u2502 arr.size0      \u2502 UInt64                    \u2502              \u2502                    \u2502                                                                                         \u2502                  \u2502                \u2502            1 \u2502          0 \u2502\n+\u2502 t.a            \u2502 String                    \u2502              \u2502                    \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n+\u2502 t.b            \u2502 UInt64                    \u2502              \u2502                    \u2502                                                                                         \u2502 ZSTD(1)          \u2502                \u2502            1 \u2502          0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 1, describe_include_virtual_columns = 0, describe_include_subcolumns = 0;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n-\u2502 id   \u2502 UInt64                           \u2502\n-\u2502 arr  \u2502 Array(UInt64)                    \u2502\n-\u2502 t    \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 id   \u2502 UInt64                    \u2502\n+\u2502 arr  \u2502 Array(UInt64)             \u2502\n+\u2502 t    \u2502 Tuple(a String, b UInt64) \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n-\u2502 id   \u2502 UInt64                           \u2502\n-\u2502 arr  \u2502 Array(UInt64)                    \u2502\n-\u2502 t    \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 id   \u2502 UInt64                    \u2502\n+\u2502 arr  \u2502 Array(UInt64)             \u2502\n+\u2502 t    \u2502 Tuple(a String, b UInt64) \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 1, describe_include_virtual_columns = 0, describe_include_subcolumns = 1;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u2510\n-\u2502 id        \u2502 UInt64                           \u2502            0 \u2502\n-\u2502 arr       \u2502 Array(UInt64)                    \u2502            0 \u2502\n-\u2502 t         \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502            0 \u2502\n-\u2502 arr.size0 \u2502 UInt64                           \u2502            1 \u2502\n-\u2502 t.a       \u2502 String                           \u2502            1 \u2502\n-\u2502 t.b       \u2502 UInt64                           \u2502            1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u2510\n+\u2502 id        \u2502 UInt64                    \u2502            0 \u2502\n+\u2502 arr       \u2502 Array(UInt64)             \u2502            0 \u2502\n+\u2502 t         \u2502 Tuple(a String, b UInt64) \u2502            0 \u2502\n+\u2502 arr.size0 \u2502 UInt64                    \u2502            1 \u2502\n+\u2502 t.a       \u2502 String                    \u2502            1 \u2502\n+\u2502 t.b       \u2502 UInt64                    \u2502            1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u2510\n-\u2502 id        \u2502 UInt64                           \u2502            0 \u2502\n-\u2502 arr       \u2502 Array(UInt64)                    \u2502            0 \u2502\n-\u2502 t         \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502            0 \u2502\n-\u2502 arr.size0 \u2502 UInt64                           \u2502            1 \u2502\n-\u2502 t.a       \u2502 String                           \u2502            1 \u2502\n-\u2502 t.b       \u2502 UInt64                           \u2502            1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u2510\n+\u2502 id        \u2502 UInt64                    \u2502            0 \u2502\n+\u2502 arr       \u2502 Array(UInt64)             \u2502            0 \u2502\n+\u2502 t         \u2502 Tuple(a String, b UInt64) \u2502            0 \u2502\n+\u2502 arr.size0 \u2502 UInt64                    \u2502            1 \u2502\n+\u2502 t.a       \u2502 String                    \u2502            1 \u2502\n+\u2502 t.b       \u2502 UInt64                    \u2502            1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 1, describe_include_virtual_columns = 1, describe_include_subcolumns = 0;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id               \u2502 UInt64                           \u2502          0 \u2502\n-\u2502 arr              \u2502 Array(UInt64)                    \u2502          0 \u2502\n-\u2502 t                \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502          0 \u2502\n-\u2502 _part            \u2502 LowCardinality(String)           \u2502          1 \u2502\n-\u2502 _part_index      \u2502 UInt64                           \u2502          1 \u2502\n-\u2502 _part_uuid       \u2502 UUID                             \u2502          1 \u2502\n-\u2502 _partition_id    \u2502 LowCardinality(String)           \u2502          1 \u2502\n-\u2502 _partition_value \u2502 UInt8                            \u2502          1 \u2502\n-\u2502 _sample_factor   \u2502 Float64                          \u2502          1 \u2502\n-\u2502 _part_offset     \u2502 UInt64                           \u2502          1 \u2502\n-\u2502 _row_exists      \u2502 UInt8                            \u2502          1 \u2502\n-\u2502 _block_number    \u2502 UInt64                           \u2502          1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502          1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id             \u2502 UInt64                           \u2502          0 \u2502\n-\u2502 arr            \u2502 Array(UInt64)                    \u2502          0 \u2502\n-\u2502 t              \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502          0 \u2502\n-\u2502 _table         \u2502 LowCardinality(String)           \u2502          1 \u2502\n-\u2502 _part          \u2502 LowCardinality(String)           \u2502          1 \u2502\n-\u2502 _part_index    \u2502 UInt64                           \u2502          1 \u2502\n-\u2502 _part_uuid     \u2502 UUID                             \u2502          1 \u2502\n-\u2502 _partition_id  \u2502 LowCardinality(String)           \u2502          1 \u2502\n-\u2502 _sample_factor \u2502 Float64                          \u2502          1 \u2502\n-\u2502 _part_offset   \u2502 UInt64                           \u2502          1 \u2502\n-\u2502 _row_exists    \u2502 UInt8                            \u2502          1 \u2502\n-\u2502 _block_number  \u2502 UInt64                           \u2502          1 \u2502\n-\u2502 _shard_num     \u2502 UInt32                           \u2502          1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502          1 \u2502\n+\u2502 _table         \u2502 LowCardinality(String)    \u2502          1 \u2502\n+\u2502 _shard_num     \u2502 UInt32                    \u2502          1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n SET describe_compact_output = 1, describe_include_virtual_columns = 1, describe_include_subcolumns = 1;\n DESCRIBE TABLE t_describe_options FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id               \u2502 UInt64                           \u2502            0 \u2502          0 \u2502\n-\u2502 arr              \u2502 Array(UInt64)                    \u2502            0 \u2502          0 \u2502\n-\u2502 t                \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502            0 \u2502          0 \u2502\n-\u2502 _part            \u2502 LowCardinality(String)           \u2502            0 \u2502          1 \u2502\n-\u2502 _part_index      \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 _part_uuid       \u2502 UUID                             \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_id    \u2502 LowCardinality(String)           \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_value \u2502 UInt8                            \u2502            0 \u2502          1 \u2502\n-\u2502 _sample_factor   \u2502 Float64                          \u2502            0 \u2502          1 \u2502\n-\u2502 _part_offset     \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 _row_exists      \u2502 UInt8                            \u2502            0 \u2502          1 \u2502\n-\u2502 _block_number    \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 arr.size0        \u2502 UInt64                           \u2502            1 \u2502          0 \u2502\n-\u2502 t.a              \u2502 String                           \u2502            1 \u2502          0 \u2502\n-\u2502 t.b              \u2502 UInt64                           \u2502            1 \u2502          0 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502            0 \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502            0 \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502            0 \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502            0 \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502            0 \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502            0 \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502            0 \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502            0 \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 arr.size0      \u2502 UInt64                    \u2502            1 \u2502          0 \u2502\n+\u2502 t.a            \u2502 String                    \u2502            1 \u2502          0 \u2502\n+\u2502 t.b            \u2502 UInt64                    \u2502            1 \u2502          0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n DESCRIBE remote(default, currentDatabase(), t_describe_options) FORMAT PrettyCompactNoEscapes;\n-\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n-\u2502 id             \u2502 UInt64                           \u2502            0 \u2502          0 \u2502\n-\u2502 arr            \u2502 Array(UInt64)                    \u2502            0 \u2502          0 \u2502\n-\u2502 t              \u2502 Tuple(\n-    a String,\n-    b UInt64) \u2502            0 \u2502          0 \u2502\n-\u2502 _table         \u2502 LowCardinality(String)           \u2502            0 \u2502          1 \u2502\n-\u2502 _part          \u2502 LowCardinality(String)           \u2502            0 \u2502          1 \u2502\n-\u2502 _part_index    \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 _part_uuid     \u2502 UUID                             \u2502            0 \u2502          1 \u2502\n-\u2502 _partition_id  \u2502 LowCardinality(String)           \u2502            0 \u2502          1 \u2502\n-\u2502 _sample_factor \u2502 Float64                          \u2502            0 \u2502          1 \u2502\n-\u2502 _part_offset   \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 _row_exists    \u2502 UInt8                            \u2502            0 \u2502          1 \u2502\n-\u2502 _block_number  \u2502 UInt64                           \u2502            0 \u2502          1 \u2502\n-\u2502 _shard_num     \u2502 UInt32                           \u2502            0 \u2502          1 \u2502\n-\u2502 arr.size0      \u2502 UInt64                           \u2502            1 \u2502          0 \u2502\n-\u2502 t.a            \u2502 String                           \u2502            1 \u2502          0 \u2502\n-\u2502 t.b            \u2502 UInt64                           \u2502            1 \u2502          0 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500is_subcolumn\u2500\u252c\u2500is_virtual\u2500\u2510\n+\u2502 id             \u2502 UInt64                    \u2502            0 \u2502          0 \u2502\n+\u2502 arr            \u2502 Array(UInt64)             \u2502            0 \u2502          0 \u2502\n+\u2502 t              \u2502 Tuple(a String, b UInt64) \u2502            0 \u2502          0 \u2502\n+\u2502 _part          \u2502 LowCardinality(String)    \u2502            0 \u2502          1 \u2502\n+\u2502 _part_index    \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 _part_uuid     \u2502 UUID                      \u2502            0 \u2502          1 \u2502\n+\u2502 _partition_id  \u2502 LowCardinality(String)    \u2502            0 \u2502          1 \u2502\n+\u2502 _sample_factor \u2502 Float64                   \u2502            0 \u2502          1 \u2502\n+\u2502 _part_offset   \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 _row_exists    \u2502 UInt8                     \u2502            0 \u2502          1 \u2502\n+\u2502 _block_number  \u2502 UInt64                    \u2502            0 \u2502          1 \u2502\n+\u2502 _table         \u2502 LowCardinality(String)    \u2502            0 \u2502          1 \u2502\n+\u2502 _shard_num     \u2502 UInt32                    \u2502            0 \u2502          1 \u2502\n+\u2502 arr.size0      \u2502 UInt64                    \u2502            1 \u2502          0 \u2502\n+\u2502 t.a            \u2502 String                    \u2502            1 \u2502          0 \u2502\n+\u2502 t.b            \u2502 UInt64                    \u2502            1 \u2502          0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/02890_describe_table_options.sql b/tests/queries/0_stateless/02890_describe_table_options.sql\nindex 236100148ffc..63806c7ee3d2 100644\n--- a/tests/queries/0_stateless/02890_describe_table_options.sql\n+++ b/tests/queries/0_stateless/02890_describe_table_options.sql\n@@ -1,5 +1,7 @@\n DROP TABLE IF EXISTS t_describe_options;\n \n+SET print_pretty_type_names = 0;\n+\n CREATE TABLE t_describe_options (\n     id UInt64 COMMENT 'index column',\n     arr Array(UInt64) DEFAULT [10, 20] CODEC(ZSTD),\ndiff --git a/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.reference b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.reference\nnew file mode 100644\nindex 000000000000..06b63ea6c2f0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.reference\n@@ -0,0 +1,1 @@\n+0\t0\t0\ndiff --git a/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.sql b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.sql\nnew file mode 100644\nindex 000000000000..d57db9151b96\n--- /dev/null\n+++ b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.sql\n@@ -0,0 +1,10 @@\n+drop table if exists x;\n+\n+create table x (i int, j int, k int) engine MergeTree order by tuple() settings index_granularity=8192, index_granularity_bytes = '10Mi',  min_bytes_for_wide_part=0, min_rows_for_wide_part=0, ratio_of_defaults_for_sparse_serialization=1;\n+\n+insert into x select number, number * 2, number * 3 from numbers(100000);\n+\n+-- One granule, (_part_offset (8 bytes) + <one minimal physical column> (4 bytes)) * 8192 + <other two physical columns>(8 bytes) * 1 = 98312\n+select * from x prewhere _part_offset = 0 settings max_bytes_to_read = 98312;\n+\n+drop table x;\n",
  "problem_statement": "Not found column _sample_factor when WHERE is present\n\u00a0\ud83d\udc4b\r\n\r\nI'm getting `NOT_FOUND_COLUMN_IN_BLOCK` error for `_sample_factor` on queries containing a WHERE clause: \r\n\r\n```console\r\n$ docker run -d --rm --ulimit nofile=262144:262144 clickhouse/clickhouse-server:24.2\r\n$ docker exec -ti 4e clickhouse client\r\n```\r\n```sql\r\n4ed07fc7aea4 :) create table demo(a UInt64, b UInt64) engine MergeTree order by (a, b) sample by b;\r\n4ed07fc7aea4 :) insert into demo(a, b) values (1, 2), (3, 4);\r\n\r\n4ed07fc7aea4 :) select uniq(b) * any(_sample_factor) from demo sample 200000;\r\n-- \u250c\u2500multiply(uniq(b), any(_sample_factor))\u2500\u2510\r\n-- \u2502                                      2 \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n4ed07fc7aea4 :) select uniq(b) * any(_sample_factor) from demo sample 200000 where a < -1;\r\n-- Received exception from server (version 24.2.1):\r\n-- Code: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column _sample_factor:  in block a UInt64 UInt64(size = 0), b UInt64 UInt64(size = 0). (NOT_FOUND_COLUMN_IN_BLOCK)\r\n\r\n4ed07fc7aea4 :) select version();\r\n-- \u250c\u2500version()\u2500\u2500\u2500\u2510\r\n-- \u2502 24.2.1.2248 \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n4ed07fc7aea4 :) set allow_experimental_analyzer=1;\r\n\r\n4ed07fc7aea4 :) select uniq(b) * any(_sample_factor) from demo sample 200000 where a < -1;\r\n-- Received exception from server (version 24.2.1):\r\n-- Code: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column _sample_factor:  in block a UInt64 UInt64(size = 0), b UInt64 UInt64(size = 0). (NOT_FOUND_COLUMN_IN_BLOCK)\r\n```\n",
  "hints_text": "",
  "created_at": "2024-02-21T01:52:43Z",
  "modified_files": [
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Interpreters/InterpreterDeleteQuery.cpp",
    "src/Interpreters/InterpreterDescribeQuery.cpp",
    "src/Interpreters/InterpreterInsertQuery.cpp",
    "src/Interpreters/InterpreterShowColumnsQuery.cpp",
    "src/Interpreters/JoinedTables.cpp",
    "src/Interpreters/MutationsInterpreter.cpp",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/getTableExpressions.cpp",
    "src/Interpreters/inplaceBlockConversions.cpp",
    "src/Interpreters/inplaceBlockConversions.h",
    "src/Interpreters/processColumnTransformers.cpp",
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp",
    "src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp",
    "src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.h",
    "src/Processors/Transforms/buildPushingToViewsChain.cpp",
    "src/Storages/AlterCommands.cpp",
    "src/Storages/BlockNumberColumn.cpp",
    "src/Storages/BlockNumberColumn.h",
    "src/Storages/ColumnsDescription.cpp",
    "src/Storages/ColumnsDescription.h",
    "src/Storages/FileLog/FileLogSource.cpp",
    "src/Storages/FileLog/StorageFileLog.cpp",
    "src/Storages/FileLog/StorageFileLog.h",
    "src/Storages/HDFS/StorageHDFS.cpp",
    "src/Storages/HDFS/StorageHDFS.h",
    "src/Storages/HDFS/StorageHDFSCluster.cpp",
    "src/Storages/HDFS/StorageHDFSCluster.h",
    "src/Storages/Hive/StorageHive.cpp",
    "src/Storages/Hive/StorageHive.h",
    "src/Storages/IStorage.cpp",
    "src/Storages/IStorage.h",
    "src/Storages/Kafka/KafkaSource.cpp",
    "src/Storages/Kafka/StorageKafka.cpp",
    "src/Storages/Kafka/StorageKafka.h",
    "src/Storages/LightweightDeleteDescription.cpp",
    "src/Storages/LightweightDeleteDescription.h",
    "src/Storages/LiveView/StorageLiveView.cpp",
    "src/Storages/LiveView/StorageLiveView.h",
    "src/Storages/MergeTree/IMergeTreeDataPart.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.h",
    "src/Storages/MergeTree/IMergeTreeReader.cpp",
    "src/Storages/MergeTree/IMergeTreeReader.h",
    "src/Storages/MergeTree/MergeTask.cpp",
    "src/Storages/MergeTree/MergeTask.h",
    "src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp",
    "src/Storages/MergeTree/MergeTreeBlockReadUtils.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreeDataPartCompact.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartCompact.h",
    "src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartInMemory.h",
    "src/Storages/MergeTree/MergeTreeDataPartWide.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartWide.h",
    "src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.h",
    "src/Storages/MergeTree/MergeTreePrefetchedReadPool.cpp",
    "src/Storages/MergeTree/MergeTreePrefetchedReadPool.h",
    "src/Storages/MergeTree/MergeTreeRangeReader.cpp",
    "src/Storages/MergeTree/MergeTreeRangeReader.h",
    "src/Storages/MergeTree/MergeTreeReadPool.cpp",
    "src/Storages/MergeTree/MergeTreeReadPool.h",
    "src/Storages/MergeTree/MergeTreeReadPoolBase.cpp",
    "src/Storages/MergeTree/MergeTreeReadPoolBase.h",
    "src/Storages/MergeTree/MergeTreeReadPoolInOrder.cpp",
    "src/Storages/MergeTree/MergeTreeReadPoolInOrder.h",
    "src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.cpp",
    "src/Storages/MergeTree/MergeTreeReadPoolParallelReplicas.h",
    "src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.cpp",
    "src/Storages/MergeTree/MergeTreeReadPoolParallelReplicasInOrder.h",
    "src/Storages/MergeTree/MergeTreeReadTask.cpp",
    "src/Storages/MergeTree/MergeTreeReadTask.h",
    "src/Storages/MergeTree/MergeTreeReaderCompact.cpp",
    "src/Storages/MergeTree/MergeTreeReaderCompact.h",
    "src/Storages/MergeTree/MergeTreeReaderInMemory.cpp",
    "src/Storages/MergeTree/MergeTreeReaderInMemory.h",
    "src/Storages/MergeTree/MergeTreeReaderWide.cpp",
    "src/Storages/MergeTree/MergeTreeReaderWide.h",
    "src/Storages/MergeTree/MergeTreeSelectProcessor.cpp",
    "src/Storages/MergeTree/MergeTreeSelectProcessor.h",
    "src/Storages/MergeTree/MergeTreeSequentialSource.cpp",
    "b/src/Storages/MergeTree/MergeTreeVirtualColumns.cpp",
    "b/src/Storages/MergeTree/MergeTreeVirtualColumns.h",
    "src/Storages/MergeTree/MutateTask.cpp",
    "src/Storages/MergeTree/StorageFromMergeTreeDataPart.h",
    "src/Storages/NATS/NATSSource.cpp",
    "src/Storages/NATS/StorageNATS.cpp",
    "src/Storages/NATS/StorageNATS.h",
    "src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp",
    "src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h",
    "src/Storages/RabbitMQ/RabbitMQSource.cpp",
    "src/Storages/RabbitMQ/StorageRabbitMQ.cpp",
    "src/Storages/RabbitMQ/StorageRabbitMQ.h",
    "src/Storages/S3Queue/StorageS3Queue.cpp",
    "src/Storages/S3Queue/StorageS3Queue.h",
    "src/Storages/StorageAzureBlob.cpp",
    "src/Storages/StorageAzureBlob.h",
    "src/Storages/StorageAzureBlobCluster.cpp",
    "src/Storages/StorageAzureBlobCluster.h",
    "src/Storages/StorageDistributed.cpp",
    "src/Storages/StorageDistributed.h",
    "src/Storages/StorageFile.cpp",
    "src/Storages/StorageFile.h",
    "src/Storages/StorageFileCluster.cpp",
    "src/Storages/StorageFileCluster.h",
    "src/Storages/StorageKeeperMap.cpp",
    "src/Storages/StorageKeeperMap.h",
    "src/Storages/StorageLog.cpp",
    "src/Storages/StorageMaterializedMySQL.cpp",
    "src/Storages/StorageMaterializedMySQL.h",
    "src/Storages/StorageMaterializedView.cpp",
    "src/Storages/StorageMaterializedView.h",
    "src/Storages/StorageMerge.cpp",
    "src/Storages/StorageMerge.h",
    "src/Storages/StorageProxy.h",
    "src/Storages/StorageS3.cpp",
    "src/Storages/StorageS3.h",
    "src/Storages/StorageS3Cluster.cpp",
    "src/Storages/StorageS3Cluster.h",
    "src/Storages/StorageSnapshot.cpp",
    "src/Storages/StorageSnapshot.h",
    "src/Storages/StorageURL.cpp",
    "src/Storages/StorageURL.h",
    "src/Storages/StorageURLCluster.cpp",
    "src/Storages/StorageURLCluster.h",
    "src/Storages/StorageValues.cpp",
    "src/Storages/StorageValues.h",
    "src/Storages/System/IStorageSystemOneBlock.cpp",
    "src/Storages/System/StorageSystemDictionaries.cpp",
    "src/Storages/System/StorageSystemDictionaries.h",
    "src/Storages/System/StorageSystemJemalloc.cpp",
    "src/Storages/System/StorageSystemPartsBase.cpp",
    "src/Storages/System/StorageSystemPartsBase.h",
    "src/Storages/System/StorageSystemZooKeeper.cpp",
    "src/Storages/VirtualColumnUtils.cpp",
    "src/Storages/VirtualColumnUtils.h",
    "b/src/Storages/VirtualColumnsDescription.cpp",
    "b/src/Storages/VirtualColumnsDescription.h",
    "src/Storages/prepareReadingFromFormat.cpp",
    "src/Storages/prepareReadingFromFormat.h",
    "src/TableFunctions/ITableFunctionFileLike.cpp",
    "src/TableFunctions/ITableFunctionFileLike.h",
    "src/TableFunctions/TableFunctionAzureBlobStorage.cpp",
    "src/TableFunctions/TableFunctionFile.cpp",
    "src/TableFunctions/TableFunctionFile.h",
    "src/TableFunctions/TableFunctionHDFS.cpp",
    "src/TableFunctions/TableFunctionHDFS.h",
    "src/TableFunctions/TableFunctionS3.cpp",
    "src/TableFunctions/TableFunctionURL.cpp",
    "src/TableFunctions/TableFunctionURL.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01848_partition_value_column.sql",
    "tests/queries/0_stateless/02235_add_part_offset_virtual_column.reference",
    "tests/queries/0_stateless/02235_add_part_offset_virtual_column.sql",
    "tests/queries/0_stateless/02890_describe_table_options.reference",
    "tests/queries/0_stateless/02890_describe_table_options.sql",
    "b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.reference",
    "b/tests/queries/0_stateless/03000_virtual_columns_in_prewhere.sql"
  ]
}