diff --git a/docs/en/operations/server-configuration-parameters/settings.md b/docs/en/operations/server-configuration-parameters/settings.md
index b62384877250..bb40e55133a0 100644
--- a/docs/en/operations/server-configuration-parameters/settings.md
+++ b/docs/en/operations/server-configuration-parameters/settings.md
@@ -2217,6 +2217,39 @@ If the table does not exist, ClickHouse will create it. If the structure of the
 </query_log>
 ```
 
+# query_metric_log {#query_metric_log}
+
+It is disabled by default.
+
+**Enabling**
+
+To manually turn on metrics history collection [`system.query_metric_log`](../../operations/system-tables/query_metric_log.md), create `/etc/clickhouse-server/config.d/query_metric_log.xml` with the following content:
+
+``` xml
+<clickhouse>
+    <query_metric_log>
+        <database>system</database>
+        <table>query_metric_log</table>
+        <flush_interval_milliseconds>7500</flush_interval_milliseconds>
+        <collect_interval_milliseconds>1000</collect_interval_milliseconds>
+        <max_size_rows>1048576</max_size_rows>
+        <reserved_size_rows>8192</reserved_size_rows>
+        <buffer_size_rows_flush_threshold>524288</buffer_size_rows_flush_threshold>
+        <flush_on_crash>false</flush_on_crash>
+    </query_metric_log>
+</clickhouse>
+```
+
+**Disabling**
+
+To disable `query_metric_log` setting, you should create the following file `/etc/clickhouse-server/config.d/disable_query_metric_log.xml` with the following content:
+
+``` xml
+<clickhouse>
+<query_metric_log remove="1" />
+</clickhouse>
+```
+
 ## query_cache {#server_configuration_parameters_query-cache}
 
 [Query cache](../query-cache.md) configuration.
@@ -3109,7 +3142,7 @@ By default, tunneling (i.e, `HTTP CONNECT`) is used to make `HTTPS` requests ove
 
 ### no_proxy
 By default, all requests will go through the proxy. In order to disable it for specific hosts, the `no_proxy` variable must be set.
-It can be set inside the `<proxy>` clause for list and remote resolvers and as an environment variable for environment resolver. 
+It can be set inside the `<proxy>` clause for list and remote resolvers and as an environment variable for environment resolver.
 It supports IP addresses, domains, subdomains and `'*'` wildcard for full bypass. Leading dots are stripped just like curl does.
 
 Example:
diff --git a/docs/en/operations/system-tables/query_metric_log.md b/docs/en/operations/system-tables/query_metric_log.md
new file mode 100644
index 000000000000..38d44c0e19ad
--- /dev/null
+++ b/docs/en/operations/system-tables/query_metric_log.md
@@ -0,0 +1,49 @@
+---
+slug: /en/operations/system-tables/query_metric_log
+---
+# query_metric_log
+
+Contains history of memory and metric values from table `system.events` for individual queries, periodically flushed to disk.
+
+Once a query starts, data is collected at periodic intervals of `query_metric_log_interval` milliseconds (which is set to 1000
+by default). The data is also collected when the query finishes if the query takes longer than `query_metric_log_interval`.
+
+Columns:
+- `query_id` ([String](../../sql-reference/data-types/string.md)) — ID of the query.
+- `hostname` ([LowCardinality(String)](../../sql-reference/data-types/string.md)) — Hostname of the server executing the query.
+- `event_date` ([Date](../../sql-reference/data-types/date.md)) — Event date.
+- `event_time` ([DateTime](../../sql-reference/data-types/datetime.md)) — Event time.
+- `event_time_microseconds` ([DateTime64](../../sql-reference/data-types/datetime64.md)) — Event time with microseconds resolution.
+
+**Example**
+
+``` sql
+SELECT * FROM system.query_metric_log LIMIT 1 FORMAT Vertical;
+```
+
+``` text
+Row 1:
+──────
+query_id:                                                        97c8ba04-b6d4-4bd7-b13e-6201c5c6e49d
+hostname:                                                        clickhouse.eu-central1.internal
+event_date:                                                      2020-09-05
+event_time:                                                      2020-09-05 16:22:33
+event_time_microseconds:                                         2020-09-05 16:22:33.196807
+memory_usage:                                                    313434219
+peak_memory_usage:                                               598951986
+ProfileEvent_Query:                                              0
+ProfileEvent_SelectQuery:                                        0
+ProfileEvent_InsertQuery:                                        0
+ProfileEvent_FailedQuery:                                        0
+ProfileEvent_FailedSelectQuery:                                  0
+...
+```
+
+**See also**
+
+- [query_metric_log setting](../../operations/server-configuration-parameters/settings.md#query_metric_log) — Enabling and disabling the setting.
+- [query_metric_log_interval](../../operations/settings/settings.md#query_metric_log_interval)
+- [system.asynchronous_metrics](../../operations/system-tables/asynchronous_metrics.md) — Contains periodically calculated metrics.
+- [system.events](../../operations/system-tables/events.md#system_tables-events) — Contains a number of events that occurred.
+- [system.metrics](../../operations/system-tables/metrics.md) — Contains instantly calculated metrics.
+- [Monitoring](../../operations/monitoring.md) — Base concepts of ClickHouse monitoring.
diff --git a/programs/server/config.xml b/programs/server/config.xml
index 10ad831465ac..28f1f465c719 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -1195,6 +1195,19 @@
         <flush_on_crash>false</flush_on_crash>
     </error_log>
 
+    <!-- Query metric log contains rows Contains history of memory and metric values from table system.events for individual queries, periodically flushed to disk
+    every "collect_interval_milliseconds" interval-->
+    <query_metric_log>
+        <database>system</database>
+        <table>query_metric_log</table>
+        <flush_interval_milliseconds>7500</flush_interval_milliseconds>
+        <max_size_rows>1048576</max_size_rows>
+        <reserved_size_rows>8192</reserved_size_rows>
+        <buffer_size_rows_flush_threshold>524288</buffer_size_rows_flush_threshold>
+        <collect_interval_milliseconds>1000</collect_interval_milliseconds>
+        <flush_on_crash>false</flush_on_crash>
+    </query_metric_log>
+
     <!--
         Asynchronous metric log contains values of metrics from
         system.asynchronous_metrics.
diff --git a/programs/server/config.yaml.example b/programs/server/config.yaml.example
index 5d5499f876c7..5b0330df5725 100644
--- a/programs/server/config.yaml.example
+++ b/programs/server/config.yaml.example
@@ -743,6 +743,13 @@ error_log:
     flush_interval_milliseconds: 7500
     collect_interval_milliseconds: 1000
 
+# Query metric log contains history of memory and metric values from table system.events for individual queries, periodically flushed to disk.
+query_metric_log:
+    database: system
+    table: query_metric_log
+    flush_interval_milliseconds: 7500
+    collect_interval_milliseconds: 1000
+
 # Asynchronous metric log contains values of metrics from
 # system.asynchronous_metrics.
 asynchronous_metric_log:
diff --git a/src/Common/CurrentMetrics.cpp b/src/Common/CurrentMetrics.cpp
index e9d5e07c9144..c4318fb0fda6 100644
--- a/src/Common/CurrentMetrics.cpp
+++ b/src/Common/CurrentMetrics.cpp
@@ -27,8 +27,8 @@
     M(BackgroundBufferFlushSchedulePoolSize, "Limit on number of tasks in BackgroundBufferFlushSchedulePool") \
     M(BackgroundDistributedSchedulePoolTask, "Number of active tasks in BackgroundDistributedSchedulePool. This pool is used for distributed sends that is done in background.") \
     M(BackgroundDistributedSchedulePoolSize, "Limit on number of tasks in BackgroundDistributedSchedulePool") \
-    M(BackgroundMessageBrokerSchedulePoolTask, "Number of active tasks in BackgroundProcessingPool for message streaming") \
-    M(BackgroundMessageBrokerSchedulePoolSize, "Limit on number of tasks in BackgroundProcessingPool for message streaming") \
+    M(BackgroundMessageBrokerSchedulePoolTask, "Number of active tasks in BackgroundMessageBrokerSchedulePool for message streaming") \
+    M(BackgroundMessageBrokerSchedulePoolSize, "Limit on number of tasks in BackgroundMessageBrokerSchedulePool for message streaming") \
     M(CacheDictionaryUpdateQueueBatches, "Number of 'batches' (a set of keys) in update queue in CacheDictionaries.") \
     M(CacheDictionaryUpdateQueueKeys, "Exact number of keys in update queue in CacheDictionaries.") \
     M(DiskSpaceReservedForMerge, "Disk space reserved for currently running background merges. It is slightly more than the total size of currently merging parts.") \
diff --git a/src/Common/CurrentMetrics.h b/src/Common/CurrentMetrics.h
index 2c64fd29bbb6..1c0de91a0bf4 100644
--- a/src/Common/CurrentMetrics.h
+++ b/src/Common/CurrentMetrics.h
@@ -1,7 +1,6 @@
 #pragma once
 
 #include <cstddef>
-#include <cstdint>
 #include <utility>
 #include <atomic>
 #include <cassert>
diff --git a/src/Common/LockGuard.h b/src/Common/LockGuard.h
new file mode 100644
index 000000000000..8a98c5f553a4
--- /dev/null
+++ b/src/Common/LockGuard.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include <Common/OvercommitTracker.h>
+#include <base/defines.h>
+
+namespace DB
+{
+
+/** LockGuard provides RAII-style locking mechanism for a mutex.
+ ** It's intended to be used like std::unique_ptr but with TSA annotations
+  */
+template <typename Mutex>
+class TSA_SCOPED_LOCKABLE LockGuard
+{
+public:
+    explicit LockGuard(Mutex & mutex_) TSA_ACQUIRE(mutex_) : mutex(mutex_) { mutex.lock(); }
+    ~LockGuard() TSA_RELEASE() { mutex.unlock(); }
+
+private:
+    Mutex & mutex;
+};
+
+template <template<typename> typename TLockGuard, typename Mutex>
+class TSA_SCOPED_LOCKABLE LockAndOverCommitTrackerBlocker
+{
+public:
+    explicit LockAndOverCommitTrackerBlocker(Mutex & mutex_) TSA_ACQUIRE(mutex_) : lock(TLockGuard(mutex_)) {}
+    ~LockAndOverCommitTrackerBlocker() TSA_RELEASE() = default;
+
+    TLockGuard<Mutex> & getUnderlyingLock() { return lock; }
+
+private:
+    TLockGuard<Mutex> lock;
+    OvercommitTrackerBlockerInThread blocker = {};
+};
+
+}
diff --git a/src/Common/OvercommitTracker.cpp b/src/Common/OvercommitTracker.cpp
index 2a453596dab7..751a61b7a41d 100644
--- a/src/Common/OvercommitTracker.cpp
+++ b/src/Common/OvercommitTracker.cpp
@@ -45,7 +45,7 @@ OvercommitResult OvercommitTracker::needToStopQuery(MemoryTracker * tracker, Int
     // method OvercommitTracker::onQueryStop(MemoryTracker *) is
     // always called with already acquired global mutex in
     // ProcessListEntry::~ProcessListEntry().
-    auto global_lock = process_list->unsafeLock();
+    DB::ProcessList::Lock global_lock(process_list->getMutex());
     std::unique_lock<std::mutex> lk(overcommit_m);
 
     size_t id = next_id++;
diff --git a/src/Common/SharedLockGuard.h b/src/Common/SharedLockGuard.h
index 93d2f42e9076..92af93d6b37c 100644
--- a/src/Common/SharedLockGuard.h
+++ b/src/Common/SharedLockGuard.h
@@ -5,7 +5,7 @@
 namespace DB
 {
 
-/** SharedLockGuard provide RAII-style locking mechanism for acquiring shared ownership of the implementation
+/** SharedLockGuard provides RAII-style locking mechanism for acquiring shared ownership of the implementation
   * of the SharedLockable concept (for example std::shared_mutex or ContextSharedMutex) supplied as the
   * constructor argument. Think of it as std::lock_guard which locks shared.
   *
diff --git a/src/Common/SystemLogBase.cpp b/src/Common/SystemLogBase.cpp
index 1bd79999cd7f..656e4fce2c50 100644
--- a/src/Common/SystemLogBase.cpp
+++ b/src/Common/SystemLogBase.cpp
@@ -4,6 +4,7 @@
 #include <Interpreters/MetricLog.h>
 #include <Interpreters/OpenTelemetrySpanLog.h>
 #include <Interpreters/PartLog.h>
+#include <Interpreters/QueryMetricLog.h>
 #include <Interpreters/QueryLog.h>
 #include <Interpreters/QueryThreadLog.h>
 #include <Interpreters/QueryViewsLog.h>
@@ -18,6 +19,7 @@
 #include <Interpreters/TransactionsInfoLog.h>
 #include <Interpreters/AsynchronousInsertLog.h>
 #include <Interpreters/BackupLog.h>
+#include <Interpreters/PeriodicLog.h>
 #include <IO/S3/BlobStorageLogWriter.h>
 
 #include <Common/MemoryTrackerBlockerInThread.h>
@@ -299,8 +301,10 @@ void SystemLogBase<LogElement>::add(LogElement element)
 
 #define INSTANTIATE_SYSTEM_LOG_BASE(ELEMENT) template class SystemLogBase<ELEMENT>;
 SYSTEM_LOG_ELEMENTS(INSTANTIATE_SYSTEM_LOG_BASE)
+SYSTEM_PERIODIC_LOG_ELEMENTS(INSTANTIATE_SYSTEM_LOG_BASE)
 
 #define INSTANTIATE_SYSTEM_LOG_QUEUE(ELEMENT) template class SystemLogQueue<ELEMENT>;
 SYSTEM_LOG_ELEMENTS(INSTANTIATE_SYSTEM_LOG_QUEUE)
+SYSTEM_PERIODIC_LOG_ELEMENTS(INSTANTIATE_SYSTEM_LOG_QUEUE)
 
 }
diff --git a/src/Common/SystemLogBase.h b/src/Common/SystemLogBase.h
index 0942e920a42e..0bf5570f1228 100644
--- a/src/Common/SystemLogBase.h
+++ b/src/Common/SystemLogBase.h
@@ -14,7 +14,6 @@
 #define SYSTEM_LOG_ELEMENTS(M) \
     M(AsynchronousMetricLogElement) \
     M(CrashLogElement) \
-    M(MetricLogElement) \
     M(OpenTelemetrySpanLogElement) \
     M(PartLogElement) \
     M(QueryLogElement) \
@@ -32,7 +31,7 @@
     M(AsynchronousInsertLogElement) \
     M(BackupLogElement) \
     M(BlobStorageLogElement) \
-    M(ErrorLogElement)
+    M(QueryMetricLogElement)
 
 namespace Poco
 {
diff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp
index 925c2b38b4c0..d29f60f692dc 100644
--- a/src/Core/Settings.cpp
+++ b/src/Core/Settings.cpp
@@ -2762,6 +2762,15 @@ SELECT type, query FROM system.query_log WHERE log_comment = 'log_comment test'
 └─────────────┴───────────┘
 ```
 )", 0) \
+    DECLARE(Int64, query_metric_log_interval, -1, R"(
+The interval in milliseconds at which the [query_metric_log](../../operations/system-tables/query_metric_log.md) for individual queries is collected.
+
+If set to any negative value, it will take the value `collect_interval_milliseconds` from the [query_metric_log setting](../../operations/server-configuration-parameters/settings.md#query_metric_log) or default to 1000 if not present.
+
+To disable the collection of a single query, set `query_metric_log_interval` to 0.
+
+Default value: -1
+    )", 0) \
     DECLARE(LogsLevel, send_logs_level, LogsLevel::fatal, R"(
 Send server text logs with specified minimum level to client. Valid values: 'trace', 'debug', 'information', 'warning', 'error', 'fatal', 'none'
 )", 0) \
diff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp
index d958d0919754..88d39d6d3938 100644
--- a/src/Core/SettingsChangesHistory.cpp
+++ b/src/Core/SettingsChangesHistory.cpp
@@ -68,6 +68,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory
     },
     {"24.10",
         {
+            {"query_metric_log_interval", 0, -1, "New setting."},
             {"enforce_strict_identifier_format", false, false, "New setting."},
             {"enable_parsing_to_custom_serialization", false, true, "New setting"},
             {"mongodb_throw_on_unsupported_query", false, true, "New setting."},
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index d0adf2102a14..b8e178e402bd 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -4249,6 +4249,16 @@ std::shared_ptr<QueryLog> Context::getQueryLog() const
     return shared->system_logs->query_log;
 }
 
+std::shared_ptr<QueryMetricLog> Context::getQueryMetricLog() const
+{
+    SharedLockGuard lock(shared->mutex);
+
+    if (!shared->system_logs)
+        return {};
+
+    return shared->system_logs->query_metric_log;
+}
+
 std::shared_ptr<QueryThreadLog> Context::getQueryThreadLog() const
 {
     SharedLockGuard lock(shared->mutex);
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index b3af82bcc54b..c62c16098e5c 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -101,6 +101,7 @@ class Clusters;
 class QueryCache;
 class ISystemLog;
 class QueryLog;
+class QueryMetricLog;
 class QueryThreadLog;
 class QueryViewsLog;
 class PartLog;
@@ -1174,6 +1175,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>
     std::shared_ptr<AsynchronousInsertLog> getAsynchronousInsertLog() const;
     std::shared_ptr<BackupLog> getBackupLog() const;
     std::shared_ptr<BlobStorageLog> getBlobStorageLog() const;
+    std::shared_ptr<QueryMetricLog> getQueryMetricLog() const;
 
     SystemLogs getSystemLogs() const;
 
diff --git a/src/Interpreters/ErrorLog.cpp b/src/Interpreters/ErrorLog.cpp
index 42616f13e24d..efee1c359ad2 100644
--- a/src/Interpreters/ErrorLog.cpp
+++ b/src/Interpreters/ErrorLog.cpp
@@ -1,3 +1,6 @@
+#include <base/getFQDNOrHostName.h>
+#include <Common/DateLUTImpl.h>
+#include <Common/ErrorCodes.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
@@ -5,10 +8,6 @@
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Interpreters/ErrorLog.h>
-#include <base/getFQDNOrHostName.h>
-#include <Common/DateLUTImpl.h>
-#include <Common/ThreadPool.h>
-#include <Common/ErrorCodes.h>
 #include <Parsers/ExpressionElementParsers.h>
 #include <Parsers/parseQuery.h>
 
@@ -114,7 +113,7 @@ void ErrorLog::stepFunction(TimePoint current_time)
                 .value=error.remote.count - previous_values.at(code).remote,
                 .remote=true
             };
-            this->add(std::move(remote_elem));
+            add(std::move(remote_elem));
             previous_values[code].remote = error.remote.count;
         }
     }
diff --git a/src/Interpreters/ErrorLog.h b/src/Interpreters/ErrorLog.h
index 4afe334d4de3..69db549f45e8 100644
--- a/src/Interpreters/ErrorLog.h
+++ b/src/Interpreters/ErrorLog.h
@@ -1,6 +1,5 @@
 #pragma once
 
-#include <Interpreters/SystemLog.h>
 #include <Interpreters/PeriodicLog.h>
 #include <Common/ErrorCodes.h>
 #include <Core/NamesAndTypes.h>
diff --git a/src/Interpreters/MetricLog.cpp b/src/Interpreters/MetricLog.cpp
index 596b0e4f96c9..16a88b976ba1 100644
--- a/src/Interpreters/MetricLog.cpp
+++ b/src/Interpreters/MetricLog.cpp
@@ -1,3 +1,5 @@
+#include <base/getFQDNOrHostName.h>
+#include <Common/DateLUTImpl.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
@@ -5,9 +7,6 @@
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Interpreters/MetricLog.h>
-#include <base/getFQDNOrHostName.h>
-#include <Common/DateLUTImpl.h>
-#include <Common/ThreadPool.h>
 
 
 namespace DB
@@ -81,7 +80,7 @@ void MetricLog::stepFunction(const std::chrono::system_clock::time_point current
         elem.current_metrics[i] = CurrentMetrics::values[i];
     }
 
-    this->add(std::move(elem));
+    add(std::move(elem));
 }
 
 }
diff --git a/src/Interpreters/MetricLog.h b/src/Interpreters/MetricLog.h
index a6fd3ecfcd3d..ffb5464916a2 100644
--- a/src/Interpreters/MetricLog.h
+++ b/src/Interpreters/MetricLog.h
@@ -1,6 +1,5 @@
 #pragma once
 
-#include <Interpreters/SystemLog.h>
 #include <Interpreters/PeriodicLog.h>
 #include <Common/ProfileEvents.h>
 #include <Common/CurrentMetrics.h>
diff --git a/src/Interpreters/PartLog.cpp b/src/Interpreters/PartLog.cpp
index 7a4c563e7024..b7b3a16473f9 100644
--- a/src/Interpreters/PartLog.cpp
+++ b/src/Interpreters/PartLog.cpp
@@ -284,9 +284,9 @@ bool PartLog::addNewParts(
     return true;
 }
 
-bool PartLog::addNewPart(ContextPtr context, const PartLog::PartLogEntry & part, const ExecutionStatus & execution_status)
+bool PartLog::addNewPart(ContextPtr context_, const PartLog::PartLogEntry & part, const ExecutionStatus & execution_status)
 {
-    return addNewParts(context, {part}, execution_status);
+    return addNewParts(context_, {part}, execution_status);
 }
 
 
diff --git a/src/Interpreters/PeriodicLog.cpp b/src/Interpreters/PeriodicLog.cpp
index 22bc14856c47..4222c2f90adc 100644
--- a/src/Interpreters/PeriodicLog.cpp
+++ b/src/Interpreters/PeriodicLog.cpp
@@ -1,16 +1,22 @@
-#include <Interpreters/PeriodicLog.h>
+#include <Common/setThreadName.h>
+#include <Common/SystemLogBase.h>
 #include <Interpreters/ErrorLog.h>
 #include <Interpreters/MetricLog.h>
+#include <Interpreters/PeriodicLog.h>
+#include <Interpreters/QueryMetricLog.h>
 
 namespace DB
 {
 
 template <typename LogElement>
-void PeriodicLog<LogElement>::startCollect(size_t collect_interval_milliseconds_)
+void PeriodicLog<LogElement>::startCollect(const String & thread_name, size_t collect_interval_milliseconds_)
 {
     collect_interval_milliseconds = collect_interval_milliseconds_;
     is_shutdown_metric_thread = false;
-    collecting_thread = std::make_unique<ThreadFromGlobalPool>([this] { threadFunction(); });
+    collecting_thread = std::make_unique<ThreadFromGlobalPool>([this, thread_name] {
+        setThreadName(thread_name.c_str());
+        threadFunction();
+    });
 }
 
 template <typename LogElement>
@@ -56,7 +62,7 @@ void PeriodicLog<LogElement>::threadFunction()
     }
 }
 
-#define INSTANTIATE_SYSTEM_LOG(ELEMENT) template class PeriodicLog<ELEMENT>;
-SYSTEM_PERIODIC_LOG_ELEMENTS(INSTANTIATE_SYSTEM_LOG)
+#define INSTANTIATE_PERIODIC_SYSTEM_LOG(ELEMENT) template class PeriodicLog<ELEMENT>;
+SYSTEM_PERIODIC_LOG_ELEMENTS(INSTANTIATE_PERIODIC_SYSTEM_LOG)
 
 }
diff --git a/src/Interpreters/PeriodicLog.h b/src/Interpreters/PeriodicLog.h
index 8254a02434a0..16faeea8ff69 100644
--- a/src/Interpreters/PeriodicLog.h
+++ b/src/Interpreters/PeriodicLog.h
@@ -22,8 +22,8 @@ class PeriodicLog : public SystemLog<LogElement>
 public:
     using TimePoint = std::chrono::system_clock::time_point;
 
-    /// Launches a background thread to collect metrics with interval
-    void startCollect(size_t collect_interval_milliseconds_);
+    /// Launches a background thread to collect metrics with periodic interval
+    void startCollect(const String & thread_name, size_t collect_interval_milliseconds_);
 
     void shutdown() final;
 
diff --git a/src/Interpreters/ProcessList.cpp b/src/Interpreters/ProcessList.cpp
index 0860e94c45eb..177468f1c8b0 100644
--- a/src/Interpreters/ProcessList.cpp
+++ b/src/Interpreters/ProcessList.cpp
@@ -106,7 +106,8 @@ ProcessList::insert(const String & query_, const IAST * ast, ContextMutablePtr q
     bool is_unlimited_query = isUnlimitedQuery(ast);
 
     {
-        auto [lock, overcommit_blocker] = safeLock(); // To avoid deadlock in case of OOM
+        LockAndOverCommitTrackerBlocker<std::unique_lock, Mutex> locker(mutex); // To avoid deadlock in case of OOM
+        auto & lock = locker.getUnderlyingLock();
         IAST::QueryKind query_kind = ast->getQueryKind();
 
         const auto queue_max_wait_ms = settings[Setting::queue_max_wait_ms].totalMilliseconds();
@@ -333,7 +334,7 @@ ProcessList::insert(const String & query_, const IAST * ast, ContextMutablePtr q
 
 ProcessListEntry::~ProcessListEntry()
 {
-    auto lock = parent.safeLock();
+    LockAndOverCommitTrackerBlocker<std::unique_lock, ProcessList::Mutex> lock(parent.getMutex());
 
     String user = (*it)->getClientInfo().current_user;
     String query_id = (*it)->getClientInfo().current_query_id;
@@ -362,7 +363,7 @@ ProcessListEntry::~ProcessListEntry()
     }
 
     /// Wait for the query if it is in the cancellation right now.
-    parent.cancelled_cv.wait(lock.lock, [&]() { return process_list_element_ptr->is_cancelling == false; });
+    parent.cancelled_cv.wait(lock.getUnderlyingLock(), [&]() { return process_list_element_ptr->is_cancelling == false; });
 
     if (auto query_user = parent.queries_to_user.find(query_id); query_user != parent.queries_to_user.end())
         parent.queries_to_user.erase(query_user);
@@ -588,7 +589,7 @@ CancellationCode ProcessList::sendCancelToQuery(const String & current_query_id,
     /// So here we first set is_cancelling, and later reset it.
     /// The ProcessListEntry cannot be destroy if is_cancelling is true.
     {
-        auto lock = safeLock();
+        LockAndBlocker lock(mutex);
         elem = tryGetProcessListElement(current_query_id, current_user);
         if (!elem)
             return CancellationCode::NotFound;
@@ -598,7 +599,7 @@ CancellationCode ProcessList::sendCancelToQuery(const String & current_query_id,
     SCOPE_EXIT({
         DENY_ALLOCATIONS_IN_SCOPE;
 
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         elem->is_cancelling = false;
         cancelled_cv.notify_all();
     });
@@ -613,14 +614,14 @@ CancellationCode ProcessList::sendCancelToQuery(QueryStatusPtr elem, bool kill)
     /// So here we first set is_cancelling, and later reset it.
     /// The ProcessListEntry cannot be destroy if is_cancelling is true.
     {
-        auto lock = safeLock();
+        LockAndBlocker lock(mutex);
         elem->is_cancelling = true;
     }
 
     SCOPE_EXIT({
         DENY_ALLOCATIONS_IN_SCOPE;
 
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         elem->is_cancelling = false;
         cancelled_cv.notify_all();
     });
@@ -634,14 +635,14 @@ void ProcessList::killAllQueries()
     std::vector<QueryStatusPtr> cancelled_processes;
 
     SCOPE_EXIT({
-        auto lock = safeLock();
+        LockAndBlocker lock(mutex);
         for (auto & cancelled_process : cancelled_processes)
             cancelled_process->is_cancelling = false;
         cancelled_cv.notify_all();
     });
 
     {
-        auto lock = safeLock();
+        LockAndBlocker lock(mutex);
         cancelled_processes.reserve(processes.size());
         for (auto & process : processes)
         {
@@ -707,7 +708,7 @@ ProcessList::Info ProcessList::getInfo(bool get_thread_list, bool get_profile_ev
     std::vector<QueryStatusPtr> processes_copy;
 
     {
-        auto lock = safeLock();
+        LockAndBlocker lock(mutex);
         processes_copy.assign(processes.begin(), processes.end());
     }
 
@@ -719,6 +720,26 @@ ProcessList::Info ProcessList::getInfo(bool get_thread_list, bool get_profile_ev
     return per_query_infos;
 }
 
+QueryStatusPtr ProcessList::getProcessListElement(const String & query_id) const
+{
+    LockAndBlocker lock(mutex);
+    for (const auto & process : processes)
+    {
+        if (process->client_info.current_query_id == query_id)
+            return process;
+    }
+
+    return nullptr;
+}
+
+QueryStatusInfoPtr ProcessList::getQueryInfo(const String & query_id, bool get_thread_list, bool get_profile_events, bool get_settings) const
+{
+    auto process = getProcessListElement(query_id);
+    if (process)
+        return std::make_shared<QueryStatusInfo>(process->getInfo(get_thread_list, get_profile_events, get_settings));
+
+    return nullptr;
+}
 
 ProcessListForUser::ProcessListForUser(ProcessList * global_process_list)
     : ProcessListForUser(nullptr, global_process_list)
@@ -762,7 +783,7 @@ ProcessList::UserInfo ProcessList::getUserInfo(bool get_profile_events) const
 {
     UserInfo per_user_infos;
 
-    auto lock = safeLock();
+    LockAndBlocker lock(mutex);
 
     per_user_infos.reserve(user_to_queries.size());
 
diff --git a/src/Interpreters/ProcessList.h b/src/Interpreters/ProcessList.h
index accb73e12df9..b2583e74d9bf 100644
--- a/src/Interpreters/ProcessList.h
+++ b/src/Interpreters/ProcessList.h
@@ -14,15 +14,16 @@
 #include <Parsers/IAST.h>
 #include <Common/CurrentMetrics.h>
 #include <Common/CurrentThread.h>
+#include <Common/LockGuard.h>
 #include <Common/MemoryTracker.h>
 #include <Common/ProfileEvents.h>
 #include <Common/Stopwatch.h>
 #include <Common/Throttler.h>
 #include <Common/OvercommitTracker.h>
+#include <base/defines.h>
 
 #include <condition_variable>
 #include <list>
-#include <map>
 #include <memory>
 #include <mutex>
 #include <unordered_map>
@@ -69,6 +70,8 @@ struct QueryStatusInfo
     std::string current_database;
 };
 
+using QueryStatusInfoPtr = std::shared_ptr<const QueryStatusInfo>;
+
 /// Query and information about its execution.
 class QueryStatus : public WithContext
 {
@@ -164,7 +167,6 @@ class QueryStatus : public WithContext
     /// This field is unused in this class, but it
     /// increments/decrements metric in constructor/destructor.
     CurrentMetrics::Increment num_queries_increment;
-
 public:
     QueryStatus(
         ContextPtr context_,
@@ -325,30 +327,10 @@ class ProcessListEntry
     QueryStatusPtr getQueryStatus() const { return *it; }
 };
 
-
-class ProcessListBase
-{
-    mutable std::mutex mutex;
-
-protected:
-    using Lock = std::unique_lock<std::mutex>;
-    struct LockAndBlocker
-    {
-        Lock lock;
-        OvercommitTrackerBlockerInThread blocker;
-    };
-
-    // It is forbidden to do allocations/deallocations with acquired mutex and
-    // enabled OvercommitTracker. This leads to deadlock in the case of OOM.
-    LockAndBlocker safeLock() const noexcept { return { std::unique_lock{mutex}, {} }; }
-    Lock unsafeLock() const noexcept { return std::unique_lock{mutex}; }
-};
-
-
 /** List of currently executing queries.
   * Also implements limit on their number.
   */
-class ProcessList : public ProcessListBase
+class ProcessList
 {
 public:
     using Element = QueryStatusPtr;
@@ -367,6 +349,10 @@ class ProcessList : public ProcessListBase
 
     using QueryKindAmounts = std::unordered_map<IAST::QueryKind, QueryAmount>;
 
+    using Mutex = std::mutex;
+    using Lock = std::unique_lock<Mutex>;
+    using LockAndBlocker = LockAndOverCommitTrackerBlocker<LockGuard, Mutex>;
+
 protected:
     friend class ProcessListEntry;
     friend struct ::OvercommitTracker;
@@ -374,6 +360,7 @@ class ProcessList : public ProcessListBase
     friend struct ::GlobalOvercommitTracker;
 
     mutable std::condition_variable have_space;        /// Number of currently running queries has become less than maximum.
+    mutable Mutex mutex;
 
     /// List of queries
     Container processes;
@@ -395,7 +382,10 @@ class ProcessList : public ProcessListBase
     ThrottlerPtr total_network_throttler;
 
     /// Call under lock. Finds process with specified current_user and current_query_id.
-    QueryStatusPtr tryGetProcessListElement(const String & current_query_id, const String & current_user);
+    QueryStatusPtr tryGetProcessListElement(const String & current_query_id, const String & current_user) TSA_REQUIRES(mutex);
+
+    /// Finds process with specified query_id.
+    QueryStatusPtr getProcessListElement(const String & query_id) const;
 
     /// limit for insert. 0 means no limit. Otherwise, when limit exceeded, an exception is thrown.
     size_t max_insert_queries_amount = 0;
@@ -437,42 +427,50 @@ class ProcessList : public ProcessListBase
     /// Get current state of process list.
     Info getInfo(bool get_thread_list = false, bool get_profile_events = false, bool get_settings = false) const;
 
+    // Get current state of a particular process.
+    QueryStatusInfoPtr getQueryInfo(const String & query_id, bool get_thread_list = false, bool get_profile_events = false, bool get_settings = false) const;
+
     /// Get current state of process list per user.
     UserInfo getUserInfo(bool get_profile_events = false) const;
 
+    Mutex & getMutex()
+    {
+        return mutex;
+    }
+
     void setMaxSize(size_t max_size_)
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         max_size = max_size_;
     }
 
     size_t getMaxSize() const
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         return max_size;
     }
 
     void setMaxInsertQueriesAmount(size_t max_insert_queries_amount_)
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         max_insert_queries_amount = max_insert_queries_amount_;
     }
 
     size_t getMaxInsertQueriesAmount() const
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         return max_insert_queries_amount;
     }
 
     void setMaxSelectQueriesAmount(size_t max_select_queries_amount_)
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         max_select_queries_amount = max_select_queries_amount_;
     }
 
     size_t getMaxSelectQueriesAmount() const
     {
-        auto lock = unsafeLock();
+        Lock lock(mutex);
         return max_select_queries_amount;
     }
 
diff --git a/src/Interpreters/QueryMetricLog.cpp b/src/Interpreters/QueryMetricLog.cpp
new file mode 100644
index 000000000000..fea2024d3e4f
--- /dev/null
+++ b/src/Interpreters/QueryMetricLog.cpp
@@ -0,0 +1,200 @@
+#include <base/getFQDNOrHostName.h>
+#include <Common/DateLUT.h>
+#include <Common/DateLUTImpl.h>
+#include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypeLowCardinality.h>
+#include <DataTypes/DataTypeString.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Interpreters/Context.h>
+#include <Interpreters/QueryMetricLog.h>
+#include <Interpreters/PeriodicLog.h>
+#include <Interpreters/ProcessList.h>
+#include <Parsers/ExpressionElementParsers.h>
+#include <Parsers/parseQuery.h>
+
+#include <chrono>
+#include <mutex>
+
+
+namespace DB
+{
+
+static auto logger = getLogger("QueryMetricLog");
+
+ColumnsDescription QueryMetricLogElement::getColumnsDescription()
+{
+    ColumnsDescription result;
+    ParserCodec codec_parser;
+
+    result.add({"query_id",
+                std::make_shared<DataTypeString>(),
+                parseQuery(codec_parser, "(ZSTD(1))", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS),
+                "Query ID."});
+    result.add({"hostname",
+                std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()),
+                parseQuery(codec_parser, "(ZSTD(1))", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS),
+                "Hostname of the server executing the query."});
+    result.add({"event_date",
+                std::make_shared<DataTypeDate>(),
+                parseQuery(codec_parser, "(Delta(2), ZSTD(1))", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS),
+                "Event date."});
+    result.add({"event_time",
+                std::make_shared<DataTypeDateTime>(),
+                parseQuery(codec_parser, "(Delta(4), ZSTD(1))", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS),
+                "Event time."});
+    result.add({"event_time_microseconds",
+                std::make_shared<DataTypeDateTime64>(6),
+                parseQuery(codec_parser, "(Delta(4), ZSTD(1))", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS),
+                "Event time with microseconds resolution."});
+    result.add({"memory_usage",
+                std::make_shared<DataTypeUInt64>(),
+                "Amount of RAM the query uses. It might not include some types of dedicated memory."});
+    result.add({"peak_memory_usage",
+                std::make_shared<DataTypeUInt64>(),
+                "Maximum amount of RAM the query used."});
+
+    for (size_t i = 0, end = ProfileEvents::end(); i < end; ++i)
+    {
+        auto name = fmt::format("ProfileEvent_{}", ProfileEvents::getName(ProfileEvents::Event(i)));
+        const auto * comment = ProfileEvents::getDocumentation(ProfileEvents::Event(i));
+        result.add({std::move(name), std::make_shared<DataTypeUInt64>(), comment});
+    }
+
+    return result;
+}
+
+void QueryMetricLogElement::appendToBlock(MutableColumns & columns) const
+{
+    size_t column_idx = 0;
+
+    columns[column_idx++]->insert(query_id);
+    columns[column_idx++]->insert(getFQDNOrHostName());
+    columns[column_idx++]->insert(DateLUT::instance().toDayNum(event_time).toUnderType());
+    columns[column_idx++]->insert(event_time);
+    columns[column_idx++]->insert(event_time_microseconds);
+    columns[column_idx++]->insert(memory_usage);
+    columns[column_idx++]->insert(peak_memory_usage);
+
+    for (size_t i = 0, end = ProfileEvents::end(); i < end; ++i)
+        columns[column_idx++]->insert(profile_events[i]);
+}
+
+void QueryMetricLog::shutdown()
+{
+    Base::shutdown();
+}
+
+void QueryMetricLog::startQuery(const String & query_id, TimePoint query_start_time, UInt64 interval_milliseconds)
+{
+    QueryMetricLogStatus status;
+    status.interval_milliseconds = interval_milliseconds;
+    status.next_collect_time = query_start_time + std::chrono::milliseconds(interval_milliseconds);
+
+    auto context = getContext();
+    const auto & process_list = context->getProcessList();
+    status.task = context->getSchedulePool().createTask("QueryMetricLog", [this, &process_list, query_id] {
+        auto current_time = std::chrono::system_clock::now();
+        const auto query_info = process_list.getQueryInfo(query_id, false, true, false);
+        if (!query_info)
+        {
+            LOG_TRACE(logger, "Query {} is not running anymore, so we couldn't get its QueryInfo", query_id);
+            return;
+        }
+
+        auto elem = createLogMetricElement(query_id, *query_info, current_time);
+        if (elem)
+            add(std::move(elem.value()));
+        else
+            LOG_TRACE(logger, "Query {} finished already while this collecting task was running", query_id);
+    });
+
+    status.task->scheduleAfter(interval_milliseconds);
+
+    std::lock_guard lock(queries_mutex);
+    queries.emplace(query_id, std::move(status));
+}
+
+void QueryMetricLog::finishQuery(const String & query_id, QueryStatusInfoPtr query_info)
+{
+    std::unique_lock lock(queries_mutex);
+    auto it = queries.find(query_id);
+
+    /// finishQuery may be called from logExceptionBeforeStart when the query has not even started
+    /// yet, so its corresponding startQuery is never called.
+    if (it == queries.end())
+        return;
+
+    if (query_info)
+    {
+        auto elem = createLogMetricElement(query_id, *query_info, std::chrono::system_clock::now(), false);
+        if (elem)
+            add(std::move(elem.value()));
+    }
+
+    /// The task has an `exec_mutex` locked while being executed. This same mutex is locked when
+    /// deactivating the task, which happens automatically on its destructor. Thus, we cannot
+    /// deactivate/destroy the task while it's running. Now, the task locks `queries_mutex` to
+    /// prevent concurrent edition of the queries. In short, the mutex order is: exec_mutex ->
+    /// queries_mutex. Thus, to prevent a deadblock we need to make sure that we always lock them in
+    /// that order.
+    {
+        /// Take ownership of the task so that we can destroy it in this scope after unlocking `queries_lock`.
+        auto task = std::move(it->second.task);
+
+        /// Build an empty task for the old task to make sure it does not lock any mutex on its destruction.
+        it->second.task = {};
+
+        /// Ensure `queries_mutex` is unlocked before calling task's destructor at the end of this
+        /// scope which will lock `exec_mutex`.
+        lock.unlock();
+    }
+
+    lock.lock();
+    queries.erase(query_id);
+}
+
+std::optional<QueryMetricLogElement> QueryMetricLog::createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint current_time, bool schedule_next)
+{
+    LOG_DEBUG(logger, "Collecting query_metric_log for query {}. Schedule next: {}", query_id, schedule_next);
+    std::lock_guard lock(queries_mutex);
+    auto query_status_it = queries.find(query_id);
+
+    /// The query might have finished while the scheduled task is running.
+    if (query_status_it == queries.end())
+        return {};
+
+    QueryMetricLogElement elem;
+    elem.event_time = timeInSeconds(current_time);
+    elem.event_time_microseconds = timeInMicroseconds(current_time);
+    elem.query_id = query_status_it->first;
+    elem.memory_usage = query_info.memory_usage > 0 ? query_info.memory_usage : 0;
+    elem.peak_memory_usage = query_info.peak_memory_usage > 0 ? query_info.peak_memory_usage : 0;
+
+    auto & query_status = query_status_it->second;
+    if (query_info.profile_counters)
+    {
+        for (ProfileEvents::Event i = ProfileEvents::Event(0), end = ProfileEvents::end(); i < end; ++i)
+        {
+            const auto & new_value = (*(query_info.profile_counters))[i];
+            elem.profile_events[i] = new_value - query_status.last_profile_events[i];
+            query_status.last_profile_events[i] = new_value;
+        }
+    }
+    else
+    {
+        elem.profile_events = query_status.last_profile_events;
+    }
+
+    if (query_status.task && schedule_next)
+    {
+        query_status.next_collect_time += std::chrono::milliseconds(query_status.interval_milliseconds);
+        const auto wait_time = std::chrono::duration_cast<std::chrono::milliseconds>(query_status.next_collect_time - std::chrono::system_clock::now()).count();
+        query_status.task->scheduleAfter(wait_time);
+    }
+
+    return elem;
+}
+
+}
diff --git a/src/Interpreters/QueryMetricLog.h b/src/Interpreters/QueryMetricLog.h
new file mode 100644
index 000000000000..d7642bf0ab14
--- /dev/null
+++ b/src/Interpreters/QueryMetricLog.h
@@ -0,0 +1,65 @@
+#pragma once
+
+#include <Common/ProfileEvents.h>
+#include <Common/CurrentMetrics.h>
+#include <Core/BackgroundSchedulePool.h>
+#include <Core/NamesAndTypes.h>
+#include <Core/NamesAndAliases.h>
+#include <Interpreters/PeriodicLog.h>
+#include <Interpreters/ProcessList.h>
+#include <Storages/ColumnsDescription.h>
+
+#include <chrono>
+#include <ctime>
+
+
+namespace DB
+{
+
+/** QueryMetricLogElement is a log of query metric values measured at regular time interval.
+  */
+
+struct QueryMetricLogElement
+{
+    time_t event_time{};
+    Decimal64 event_time_microseconds{};
+    String query_id{};
+    UInt64 memory_usage{};
+    UInt64 peak_memory_usage{};
+    std::vector<ProfileEvents::Count> profile_events = std::vector<ProfileEvents::Count>(ProfileEvents::end());
+
+    static std::string name() { return "QueryMetricLog"; }
+    static ColumnsDescription getColumnsDescription();
+    static NamesAndAliases getNamesAndAliases() { return {}; }
+    void appendToBlock(MutableColumns & columns) const;
+};
+
+struct QueryMetricLogStatus
+{
+    UInt64 interval_milliseconds;
+    std::chrono::system_clock::time_point next_collect_time;
+    std::vector<ProfileEvents::Count> last_profile_events = std::vector<ProfileEvents::Count>(ProfileEvents::end());
+    BackgroundSchedulePool::TaskHolder task;
+};
+
+class QueryMetricLog : public SystemLog<QueryMetricLogElement>
+{
+    using SystemLog<QueryMetricLogElement>::SystemLog;
+    using TimePoint = std::chrono::system_clock::time_point;
+    using Base = SystemLog<QueryMetricLogElement>;
+
+public:
+    void shutdown() final;
+
+    // Both startQuery and finishQuery are called from the thread that executes the query
+    void startQuery(const String & query_id, TimePoint query_start_time, UInt64 interval_milliseconds);
+    void finishQuery(const String & query_id, QueryStatusInfoPtr query_info = nullptr);
+
+private:
+    std::optional<QueryMetricLogElement> createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint current_time, bool schedule_next = true);
+
+    std::recursive_mutex queries_mutex;
+    std::unordered_map<String, QueryMetricLogStatus> queries;
+};
+
+}
diff --git a/src/Interpreters/SystemLog.cpp b/src/Interpreters/SystemLog.cpp
index 7e21caa59c93..bbdeb4567af4 100644
--- a/src/Interpreters/SystemLog.cpp
+++ b/src/Interpreters/SystemLog.cpp
@@ -25,6 +25,7 @@
 #include <Interpreters/PartLog.h>
 #include <Interpreters/ProcessorsProfileLog.h>
 #include <Interpreters/QueryLog.h>
+#include <Interpreters/QueryMetricLog.h>
 #include <Interpreters/QueryThreadLog.h>
 #include <Interpreters/QueryViewsLog.h>
 #include <Interpreters/ObjectStorageQueueLog.h>
@@ -321,14 +322,14 @@ SystemLogs::SystemLogs(ContextPtr global_context, const Poco::Util::AbstractConf
     {
         size_t collect_interval_milliseconds = config.getUInt64("metric_log.collect_interval_milliseconds",
                                                                 DEFAULT_METRIC_LOG_COLLECT_INTERVAL_MILLISECONDS);
-        metric_log->startCollect(collect_interval_milliseconds);
+        metric_log->startCollect("MetricLog", collect_interval_milliseconds);
     }
 
     if (error_log)
     {
         size_t collect_interval_milliseconds = config.getUInt64("error_log.collect_interval_milliseconds",
                                                                 DEFAULT_ERROR_LOG_COLLECT_INTERVAL_MILLISECONDS);
-        error_log->startCollect(collect_interval_milliseconds);
+        error_log->startCollect("ErrorLog", collect_interval_milliseconds);
     }
 
     if (crash_log)
diff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h
index c03f93700680..61e6988e43dc 100644
--- a/src/Interpreters/SystemLog.h
+++ b/src/Interpreters/SystemLog.h
@@ -5,7 +5,6 @@
 #include <Parsers/IAST.h>
 
 #include <boost/noncopyable.hpp>
-#include <vector>
 
 #define LIST_OF_ALL_SYSTEM_LOGS(M) \
     M(QueryLog,              query_log,            "Contains information about executed queries, for example, start time, duration of processing, error messages.") \
@@ -30,6 +29,7 @@
     M(AsynchronousInsertLog, asynchronous_insert_log, "Contains a history for all asynchronous inserts executed on current server.") \
     M(BackupLog,             backup_log,           "Contains logging entries with the information about BACKUP and RESTORE operations.") \
     M(BlobStorageLog,        blob_storage_log,     "Contains logging entries with information about various blob storage operations such as uploads and deletes.") \
+    M(QueryMetricLog,        query_metric_log,     "Contains history of memory and metric values from table system.events for individual queries, periodically flushed to disk.") \
 
 
 namespace DB
@@ -68,7 +68,6 @@ LIST_OF_ALL_SYSTEM_LOGS(FORWARD_DECLARATION)
 #undef FORWARD_DECLARATION
 /// NOLINTEND(bugprone-macro-parentheses)
 
-
 /// System logs should be destroyed in destructor of the last Context and before tables,
 ///  because SystemLog destruction makes insert query while flushing data into underlying tables
 class SystemLogs
@@ -101,7 +100,7 @@ struct SystemLogSettings
 };
 
 template <typename LogElement>
-class SystemLog : public SystemLogBase<LogElement>, private boost::noncopyable, WithContext
+class SystemLog : public SystemLogBase<LogElement>, private boost::noncopyable, public WithContext
 {
 public:
     using Self = SystemLog;
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index 2ce921967ba5..a8fcfff65adc 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -61,6 +61,7 @@
 #include <Interpreters/ProcessList.h>
 #include <Interpreters/ProcessorsProfileLog.h>
 #include <Interpreters/QueryLog.h>
+#include <Interpreters/QueryMetricLog.h>
 #include <Interpreters/ReplaceQueryParameterVisitor.h>
 #include <Interpreters/SelectIntersectExceptQueryVisitor.h>
 #include <Interpreters/SelectQueryOptions.h>
@@ -143,6 +144,7 @@ namespace Setting
     extern const SettingsBool query_cache_squash_partial_results;
     extern const SettingsQueryCacheSystemTableHandling query_cache_system_table_handling;
     extern const SettingsSeconds query_cache_ttl;
+    extern const SettingsInt64 query_metric_log_interval;
     extern const SettingsOverflowMode read_overflow_mode;
     extern const SettingsOverflowMode read_overflow_mode_leaf;
     extern const SettingsOverflowMode result_overflow_mode;
@@ -367,6 +369,15 @@ addStatusInfoToQueryLogElement(QueryLogElement & element, const QueryStatusInfo
     addPrivilegesInfoToQueryLogElement(element, context_ptr);
 }
 
+static UInt64 getQueryMetricLogInterval(ContextPtr context)
+{
+    const auto & settings = context->getSettingsRef();
+    auto interval_milliseconds = settings[Setting::query_metric_log_interval];
+    if (interval_milliseconds < 0)
+        interval_milliseconds = context->getConfigRef().getUInt64("query_metric_log.collect_interval_milliseconds", 1000);
+
+    return interval_milliseconds;
+}
 
 QueryLogElement logQueryStart(
     const std::chrono::time_point<std::chrono::system_clock> & query_start_time,
@@ -439,9 +450,40 @@ QueryLogElement logQueryStart(
         }
     }
 
+    if (auto query_metric_log = context->getQueryMetricLog(); query_metric_log && !internal)
+    {
+        auto interval_milliseconds = getQueryMetricLogInterval(context);
+        if (interval_milliseconds > 0)
+            query_metric_log->startQuery(elem.client_info.current_query_id, query_start_time, interval_milliseconds);
+    }
+
     return elem;
 }
 
+void logQueryMetricLogFinish(ContextPtr context, bool internal, String query_id, QueryStatusInfoPtr info)
+{
+    if (auto query_metric_log = context->getQueryMetricLog(); query_metric_log && !internal)
+    {
+        auto interval_milliseconds = getQueryMetricLogInterval(context);
+        if (info && interval_milliseconds > 0)
+        {
+            /// Only collect data on query finish if the elapsed time exceeds the interval to collect.
+            /// If we don't do this, it's counter-intuitive to have a single entry for every quick query
+            /// where the data is basically a subset of the query_log.
+            /// On the other hand, it's very convenient to have a new entry whenever the query finishes
+            /// so that we can get nice time-series querying only query_metric_log without the need
+            /// to query the final state in query_log.
+            auto collect_on_finish = info->elapsed_microseconds > interval_milliseconds * 1000;
+            auto query_info = collect_on_finish ? info : nullptr;
+            query_metric_log->finishQuery(query_id, query_info);
+        }
+        else
+        {
+            query_metric_log->finishQuery(query_id, nullptr);
+        }
+    }
+}
+
 void logQueryFinish(
     QueryLogElement & elem,
     const ContextMutablePtr & context,
@@ -554,6 +596,8 @@ void logQueryFinish(
                 }
             }
         }
+
+        logQueryMetricLogFinish(context, internal, elem.client_info.current_query_id, std::make_shared<QueryStatusInfo>(info));
     }
 
     if (query_span)
@@ -613,10 +657,11 @@ void logQueryException(
     elem.event_time = timeInSeconds(time_now);
     elem.event_time_microseconds = timeInMicroseconds(time_now);
 
+    QueryStatusInfoPtr info;
     if (process_list_elem)
     {
-        QueryStatusInfo info = process_list_elem->getInfo(true, settings[Setting::log_profile_events], false);
-        addStatusInfoToQueryLogElement(elem, info, query_ast, context);
+        info = std::make_shared<QueryStatusInfo>(process_list_elem->getInfo(true, settings[Setting::log_profile_events], false));
+        addStatusInfoToQueryLogElement(elem, *info, query_ast, context);
     }
     else
     {
@@ -651,6 +696,8 @@ void logQueryException(
         query_span->addAttribute("clickhouse.exception_code", elem.exception_code);
         query_span->finish();
     }
+
+    logQueryMetricLogFinish(context, internal, elem.client_info.current_query_id, info);
 }
 
 void logExceptionBeforeStart(
@@ -748,6 +795,8 @@ void logExceptionBeforeStart(
             ProfileEvents::increment(ProfileEvents::FailedInsertQuery);
         }
     }
+
+    logQueryMetricLogFinish(context, false, elem.client_info.current_query_id, nullptr);
 }
 
 void validateAnalyzerSettings(ASTPtr ast, bool context_value)
diff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp
index 37948cd55e7f..597a6861eeb7 100644
--- a/src/Processors/Transforms/WindowTransform.cpp
+++ b/src/Processors/Transforms/WindowTransform.cpp
@@ -2469,7 +2469,7 @@ struct WindowFunctionNthValue final : public StatelessWindowFunction
         if (offset <= 0)
         {
             throw Exception(ErrorCodes::BAD_ARGUMENTS,
-                "The offset for function {} must be in (0, {}], {} given",
+                "The offset for function {} must be in (1, {}], {} given",
                 getName(), INT64_MAX, offset);
         }
 
diff --git a/utils/check-style/check-style b/utils/check-style/check-style
index e15d4ef92cc3..c3b42be1519e 100755
--- a/utils/check-style/check-style
+++ b/utils/check-style/check-style
@@ -85,6 +85,8 @@ EXTERN_TYPES_EXCLUDES=(
     CurrentMetrics::add
     CurrentMetrics::sub
     CurrentMetrics::get
+    CurrentMetrics::getDocumentation
+    CurrentMetrics::getName
     CurrentMetrics::set
     CurrentMetrics::end
     CurrentMetrics::Increment
@@ -174,7 +176,7 @@ find $ROOT_PATH/tests/queries -iname '*fail*' |
 # NOTE: it is not that accurate, but at least something.
 tests_with_query_log=( $(
     find $ROOT_PATH/tests/queries -iname '*.sql' -or -iname '*.sh' -or -iname '*.py' -or -iname '*.j2' |
-        xargs grep --with-filename -e system.query_log -e system.query_thread_log | cut -d: -f1 | sort -u
+        xargs grep --with-filename -e 'system.query_log\b' -e 'system.query_thread_log\b' | cut -d: -f1 | sort -u
 ) )
 for test_case in "${tests_with_query_log[@]}"; do
     grep -qE current_database.*currentDatabase "$test_case" || {
