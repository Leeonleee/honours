{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21890,
  "instance_id": "ClickHouse__ClickHouse-21890",
  "issue_numbers": [
    "21620"
  ],
  "base_commit": "ed4a184bd4af0b05a5456bd7ff29594de3826a5a",
  "patch": "diff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp\nindex 9cf5b47ac2b0..1d0c75f6bff2 100644\n--- a/src/Dictionaries/PolygonDictionary.cpp\n+++ b/src/Dictionaries/PolygonDictionary.cpp\n@@ -1,4 +1,8 @@\n #include \"PolygonDictionary.h\"\n+\n+#include <numeric>\n+#include <cmath>\n+\n #include \"DictionaryBlockInputStream.h\"\n #include \"DictionaryFactory.h\"\n \n@@ -8,8 +12,6 @@\n #include <Functions/FunctionHelpers.h>\n #include <DataTypes/DataTypesDecimal.h>\n \n-#include <numeric>\n-\n namespace DB\n {\n \n@@ -35,63 +37,9 @@ IPolygonDictionary::IPolygonDictionary(\n         , input_type(input_type_)\n         , point_type(point_type_)\n {\n-    createAttributes();\n+    setup();\n     loadData();\n-}\n-\n-std::string IPolygonDictionary::getTypeName() const\n-{\n-    return \"Polygon\";\n-}\n-\n-std::string IPolygonDictionary::getKeyDescription() const\n-{\n-    return dict_struct.getKeyDescription();\n-}\n-\n-size_t IPolygonDictionary::getBytesAllocated() const\n-{\n-    return bytes_allocated;\n-}\n-\n-size_t IPolygonDictionary::getQueryCount() const\n-{\n-    return query_count.load(std::memory_order_relaxed);\n-}\n-\n-double IPolygonDictionary::getHitRate() const\n-{\n-    return 1.0;\n-}\n-\n-size_t IPolygonDictionary::getElementCount() const\n-{\n-    return element_count;\n-}\n-\n-double IPolygonDictionary::getLoadFactor() const\n-{\n-    return 1.0;\n-}\n-\n-const IDictionarySource * IPolygonDictionary::getSource() const\n-{\n-    return source_ptr.get();\n-}\n-\n-const DictionaryLifetime & IPolygonDictionary::getLifetime() const\n-{\n-    return dict_lifetime;\n-}\n-\n-const DictionaryStructure & IPolygonDictionary::getStructure() const\n-{\n-    return dict_struct;\n-}\n-\n-bool IPolygonDictionary::isInjective(const std::string &) const\n-{\n-    return false;\n+    calculateBytesAllocated();\n }\n \n ColumnPtr IPolygonDictionary::getColumn(\n@@ -101,50 +49,101 @@ ColumnPtr IPolygonDictionary::getColumn(\n     const DataTypes &,\n     const ColumnPtr & default_values_column) const\n {\n-    ColumnPtr result;\n+    const auto requested_key_points = extractPoints(key_columns);\n \n-    const auto index = getAttributeIndex(attribute_name);\n-    const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n+    const auto & attribute = dict_struct.getAttribute(attribute_name, result_type);\n+    bool complex_attribute = attribute.is_nullable || attribute.is_array;\n+    DefaultValueProvider default_value_provider(attribute.null_value, default_values_column);\n \n-    auto keys_size = key_columns.front()->size();\n+    size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    const auto & attribute_values_column = attributes[attribute_index];\n \n-    auto type_call = [&](const auto &dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n+    auto result = attribute_values_column->cloneEmpty();\n+    result->reserve(requested_key_points.size());\n \n-        const auto & null_value = std::get<AttributeType>(null_values[index]);\n-        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(null_value, default_values_column);\n+    Field row_value_to_insert;\n+    size_t polygon_index = 0;\n \n-        auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);\n-\n-        if constexpr (std::is_same_v<AttributeType, String>)\n-        {\n-            auto column_string = ColumnString::create();\n-            auto * out = column.get();\n-\n-            getItemsImpl<String, StringRef>(\n-                index,\n-                key_columns,\n-                [&](const size_t, const StringRef & value) { out->insertData(value.data, value.size); },\n-                default_value_extractor);\n-        }\n-        else\n+    if (unlikely(complex_attribute))\n+    {\n+        for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n         {\n-            auto & out = column->getData();\n+            const auto found = find(requested_key_points[requested_key_index], polygon_index);\n \n-            getItemsImpl<AttributeType, AttributeType>(\n-                index,\n-                key_columns,\n-                [&](const size_t row, const auto value) { return out[row] = value; },\n-                default_value_extractor);\n+            if (found)\n+            {\n+                size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n+                attribute_values_column->get(attribute_values_index, row_value_to_insert);\n+            }\n+            else\n+                row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);\n+\n+            result->insert(row_value_to_insert);\n         }\n+    }\n+    else\n+    {\n+        auto type_call = [&](const auto & dictionary_attribute_type)\n+        {\n+            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+            using AttributeType = typename Type::AttributeType;\n+            using ValueType = DictionaryValueType<AttributeType>;\n+            using ColumnType = std::conditional_t<\n+                std::is_same_v<AttributeType, String>,\n+                ColumnString,\n+                std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<ValueType>, ColumnVector<AttributeType>>>;\n+\n+            const auto attribute_values_column_typed = typeid_cast<const ColumnType *>(attribute_values_column.get());\n+            if (!attribute_values_column_typed)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"An attribute type should be same as dictionary type\");\n+\n+            ColumnType & result_column_typed = static_cast<ColumnType &>(*result);\n+\n+            if constexpr (std::is_same_v<ColumnType, ColumnString>)\n+            {\n+                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n+                {\n+                    const auto found = find(requested_key_points[requested_key_index], polygon_index);\n+\n+                    if (found)\n+                    {\n+                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n+                        auto data_to_insert = attribute_values_column->getDataAt(attribute_values_index);\n+                        result_column_typed.insertData(data_to_insert.data, data_to_insert.size);\n+                    }\n+                    else\n+                        result_column_typed.insert(default_value_provider.getDefaultValue(requested_key_index));\n+                }\n+            }\n+            else\n+            {\n+                auto & attribute_data = attribute_values_column_typed->getData();\n+                auto & result_data = result_column_typed.getData();\n+\n+                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n+                {\n+                    const auto found = find(requested_key_points[requested_key_index], polygon_index);\n+\n+                    if (found)\n+                    {\n+                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n+                        auto & item = attribute_data[attribute_values_index];\n+                        result_data.emplace_back(item);\n+                    }\n+                    else\n+                    {\n+                        row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);\n+                        result_data.emplace_back(row_value_to_insert.template get<NearestFieldType<ValueType>>());\n+                    }\n+                }\n+            }\n+        };\n+\n+        callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n+    }\n \n-        result = std::move(column);\n-    };\n \n-    callOnDictionaryAttributeType(dict_struct.attributes[index].underlying_type, type_call);\n+    query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);\n \n     return result;\n }\n@@ -156,75 +155,16 @@ BlockInputStreamPtr IPolygonDictionary::getBlockInputStream(const Names &, size_\n     throw Exception{\"Reading the dictionary is not allowed\", ErrorCodes::UNSUPPORTED_METHOD};\n }\n \n-template <typename T>\n-void IPolygonDictionary::appendNullValueImpl(const Field & null_value)\n+void IPolygonDictionary::setup()\n {\n-    null_values.emplace_back(T(null_value.get<NearestFieldType<T>>()));\n-}\n-\n-void IPolygonDictionary::appendNullValue(AttributeUnderlyingType type, const Field & null_value)\n-{\n-    switch (type)\n-    {\n-        case AttributeUnderlyingType::utUInt8:\n-            appendNullValueImpl<UInt8>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utUInt16:\n-            appendNullValueImpl<UInt16>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utUInt32:\n-            appendNullValueImpl<UInt32>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utUInt64:\n-            appendNullValueImpl<UInt64>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utUInt128:\n-            appendNullValueImpl<UInt128>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utInt8:\n-            appendNullValueImpl<Int8>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utInt16:\n-            appendNullValueImpl<Int16>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utInt32:\n-            appendNullValueImpl<Int32>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utInt64:\n-            appendNullValueImpl<Int64>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utFloat32:\n-            appendNullValueImpl<Float32>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utFloat64:\n-            appendNullValueImpl<Float64>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utDecimal32:\n-            appendNullValueImpl<Decimal32>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utDecimal64:\n-            appendNullValueImpl<Decimal64>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utDecimal128:\n-            appendNullValueImpl<Decimal128>(null_value);\n-            break;\n-        case AttributeUnderlyingType::utString:\n-            appendNullValueImpl<String>(null_value);\n-            break;\n-    }\n-}\n+    attributes.reserve(dict_struct.attributes.size());\n \n-void IPolygonDictionary::createAttributes()\n-{\n-    attributes.resize(dict_struct.attributes.size());\n-    for (size_t i = 0; i < dict_struct.attributes.size(); ++i)\n+    for (const auto & attribute : dict_struct.attributes)\n     {\n-        const auto & attr = dict_struct.attributes[i];\n-        attribute_index_by_name.emplace(attr.name, i);\n-\n-        appendNullValue(attr.underlying_type, attr.null_value);\n+        auto column = attribute.type->createColumn();\n+        attributes.emplace_back(std::move(column));\n \n-        if (attr.hierarchical)\n+        if (attribute.hierarchical)\n             throw Exception{ErrorCodes::TYPE_MISMATCH,\n                             \"{}: hierarchical attributes not supported for dictionary of polygonal type\",\n                             getDictionaryID().getNameForLogs()};\n@@ -234,22 +174,20 @@ void IPolygonDictionary::createAttributes()\n void IPolygonDictionary::blockToAttributes(const DB::Block & block)\n {\n     const auto rows = block.rows();\n-    element_count += rows;\n+\n+    size_t skip_key_column_offset = 1;\n     for (size_t i = 0; i < attributes.size(); ++i)\n     {\n-        const auto & column = block.safeGetByPosition(i + 1);\n-        if (attributes[i])\n-        {\n-            MutableColumnPtr mutated = IColumn::mutate(std::move(attributes[i]));\n-            mutated->insertRangeFrom(*column.column, 0, column.column->size());\n-            attributes[i] = std::move(mutated);\n-        }\n-        else\n-            attributes[i] = column.column;\n+        const auto & block_column = block.safeGetByPosition(i + skip_key_column_offset);\n+        const auto & column = block_column.column;\n+\n+        attributes[i]->assumeMutable()->insertRangeFrom(*column, 0, column->size());\n     }\n+\n     /** Multi-polygons could cause bigger sizes, but this is better than nothing. */\n     polygons.reserve(polygons.size() + rows);\n-    ids.reserve(ids.size() + rows);\n+    polygon_index_to_attribute_value_index.reserve(polygon_index_to_attribute_value_index.size() + rows);\n+\n     const auto & key = block.safeGetByPosition(0).column;\n     extractPolygons(key);\n }\n@@ -262,114 +200,104 @@ void IPolygonDictionary::loadData()\n         blockToAttributes(block);\n     stream->readSuffix();\n \n-    std::vector<double> areas;\n-    areas.reserve(polygons.size());\n+\n+    /// Correct and sort polygons by area and update polygon_index_to_attribute_value_index after sort\n+    PaddedPODArray<double> areas;\n+    areas.resize_fill(polygons.size());\n \n     std::vector<std::pair<Polygon, size_t>> polygon_ids;\n     polygon_ids.reserve(polygons.size());\n+\n     for (size_t i = 0; i < polygons.size(); ++i)\n     {\n         auto & polygon = polygons[i];\n         bg::correct(polygon);\n-        areas.push_back(bg::area(polygon));\n+\n+        areas[i] = bg::area(polygon);\n         polygon_ids.emplace_back(polygon, i);\n     }\n-    sort(polygon_ids.begin(), polygon_ids.end(), [& areas](const auto & lhs, const auto & rhs)\n+\n+    std::sort(polygon_ids.begin(), polygon_ids.end(), [& areas](const auto & lhs, const auto & rhs)\n     {\n         return areas[lhs.second] < areas[rhs.second];\n     });\n+\n     std::vector<size_t> correct_ids;\n     correct_ids.reserve(polygon_ids.size());\n+\n     for (size_t i = 0; i < polygon_ids.size(); ++i)\n     {\n         auto & polygon = polygon_ids[i];\n-        correct_ids.emplace_back(ids[polygon.second]);\n+        correct_ids.emplace_back(polygon_index_to_attribute_value_index[polygon.second]);\n         polygons[i] = polygon.first;\n     }\n-    ids = correct_ids;\n+\n+    polygon_index_to_attribute_value_index = std::move(correct_ids);\n }\n \n void IPolygonDictionary::calculateBytesAllocated()\n {\n-    // TODO:: Account for key.\n+    /// Index allocated by subclass not counted because it take a small part in relation to attributes and polygons\n+\n     for (const auto & column : attributes)\n         bytes_allocated += column->allocatedBytes();\n+\n+    for (auto & polygon : polygons)\n+        bytes_allocated += bg::num_points(polygon) * sizeof(Point);\n }\n \n std::vector<IPolygonDictionary::Point> IPolygonDictionary::extractPoints(const Columns & key_columns)\n {\n     if (key_columns.size() != 2)\n-        throw Exception{\"Expected two columns of coordinates\", ErrorCodes::BAD_ARGUMENTS};\n+        throw Exception{\"Expected two columns of coordinates with type Float64\", ErrorCodes::BAD_ARGUMENTS};\n+\n     const auto * column_x = typeid_cast<const ColumnVector<Float64>*>(key_columns[0].get());\n     const auto * column_y = typeid_cast<const ColumnVector<Float64>*>(key_columns[1].get());\n+\n     if (!column_x || !column_y)\n         throw Exception{\"Expected columns of Float64\", ErrorCodes::TYPE_MISMATCH};\n+\n     const auto rows = key_columns.front()->size();\n+\n     std::vector<Point> result;\n     result.reserve(rows);\n+\n     for (const auto row : ext::range(0, rows))\n-        result.emplace_back(column_x->getElement(row), column_y->getElement(row));\n-    return result;\n-}\n+    {\n+        auto x = column_x->getElement(row);\n+        auto y = column_y->getElement(row);\n \n-ColumnUInt8::Ptr IPolygonDictionary::hasKeys(const Columns & key_columns, const DataTypes &) const\n-{\n-    auto size = key_columns.front()->size();\n-    auto result = ColumnUInt8::create(size);\n-    auto& out = result->getData();\n+        if (isNaN(x) || isNaN(y))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"PolygonDictionary input point component must not be NaN\");\n \n-    size_t row = 0;\n-    for (const auto & pt : extractPoints(key_columns))\n-    {\n-        size_t trash = 0;\n-        out[row] = find(pt, trash);\n-        ++row;\n-    }\n+        if (isinf(x) || isinf(y))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"PolygonDictionary input point component must not be infinite\");\n \n-    query_count.fetch_add(row, std::memory_order_relaxed);\n+        result.emplace_back(x, y);\n+    }\n \n     return result;\n }\n \n-size_t IPolygonDictionary::getAttributeIndex(const std::string & attribute_name) const\n+ColumnUInt8::Ptr IPolygonDictionary::hasKeys(const Columns & key_columns, const DataTypes &) const\n {\n-    const auto it = attribute_index_by_name.find(attribute_name);\n-    if (it == attribute_index_by_name.end())\n-        throw Exception{\"No such attribute: \" + attribute_name, ErrorCodes::BAD_ARGUMENTS};\n-    return it->second;\n-}\n+    std::vector<IPolygonDictionary::Point> points = extractPoints(key_columns);\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n-void IPolygonDictionary::getItemsImpl(\n-        size_t attribute_ind,\n-        const Columns & key_columns,\n-        ValueSetter && set_value,\n-        DefaultValueExtractor & default_value_extractor) const\n-{\n-    const auto points = extractPoints(key_columns);\n-\n-    using ColVecType = std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<AttributeType>, ColumnVector<AttributeType>>;\n-    using ColType = std::conditional_t<std::is_same<AttributeType, String>::value, ColumnString, ColVecType>;\n-    const auto column = typeid_cast<const ColType *>(attributes[attribute_ind].get());\n-    if (!column)\n-        throw Exception{\"An attribute should be a column of its type\", ErrorCodes::BAD_ARGUMENTS};\n-    for (const auto i : ext::range(0, points.size()))\n+    auto result = ColumnUInt8::create(points.size());\n+    auto& out = result->getData();\n+\n+    for (size_t i = 0; i < points.size(); ++i)\n     {\n-        size_t id = 0;\n-        const auto found = find(points[i], id);\n-        id = ids[id];\n-        if (!found)\n-        {\n-            set_value(i, static_cast<OutputType>(default_value_extractor[i]));\n-            continue;\n-        }\n-        if constexpr (std::is_same<AttributeType, String>::value)\n-            set_value(i, static_cast<OutputType>(column->getDataAt(id)));\n-        else\n-            set_value(i, static_cast<OutputType>(column->getElement(id)));\n+        size_t unused_find_result = 0;\n+        auto & point = points[i];\n+        out[i] = find(point, unused_find_result);\n     }\n \n     query_count.fetch_add(points.size(), std::memory_order_relaxed);\n+\n+    return result;\n }\n \n namespace\n@@ -531,7 +459,7 @@ void handlePointsReprByTuples(const IColumn * column, Data & data, Offset & offs\n \n void IPolygonDictionary::extractPolygons(const ColumnPtr & column)\n {\n-    Data data = {polygons, ids};\n+    Data data = {polygons, polygon_index_to_attribute_value_index};\n     Offset offset;\n \n     const IColumn * points_collection = nullptr;\ndiff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h\nindex 362342c684be..b82a8b2928ff 100644\n--- a/src/Dictionaries/PolygonDictionary.h\n+++ b/src/Dictionaries/PolygonDictionary.h\n@@ -57,27 +57,25 @@ class IPolygonDictionary : public IDictionaryBase\n             InputType input_type_,\n             PointType point_type_);\n \n-    std::string getTypeName() const override;\n+    std::string getTypeName() const override { return \"Polygon\"; }\n \n-    std::string getKeyDescription() const;\n+    size_t getBytesAllocated() const override { return bytes_allocated; }\n \n-    size_t getBytesAllocated() const override;\n+    size_t getQueryCount() const override { return query_count.load(std::memory_order_relaxed); }\n \n-    size_t getQueryCount() const override;\n+    double getHitRate() const override { return 1.0; }\n \n-    double getHitRate() const override;\n+    size_t getElementCount() const override { return attributes.empty() ? 0 : attributes.front()->size(); }\n \n-    size_t getElementCount() const override;\n+    double getLoadFactor() const override { return 1.0; }\n \n-    double getLoadFactor() const override;\n+    const IDictionarySource * getSource() const override { return source_ptr.get(); }\n \n-    const IDictionarySource * getSource() const override;\n+    const DictionaryStructure & getStructure() const override { return dict_struct; }\n \n-    const DictionaryStructure & getStructure() const override;\n+    const DictionaryLifetime  & getLifetime() const override { return dict_lifetime; }\n \n-    const DictionaryLifetime  & getLifetime() const override;\n-\n-    bool isInjective(const std::string & attribute_name) const override;\n+    bool isInjective(const std::string & attribute_name) const override { return dict_struct.getAttribute(attribute_name).injective; }\n \n     DictionaryKeyType getKeyType() const override { return DictionaryKeyType::complex; }\n \n@@ -106,13 +104,9 @@ class IPolygonDictionary : public IDictionaryBase\n      *  If true id is set to the index of a polygon containing the given point.\n      *  Overridden in different implementations of this interface.\n      */\n-    virtual bool find(const Point & point, size_t & id) const = 0;\n+    virtual bool find(const Point & point, size_t & polygon_index) const = 0;\n \n     std::vector<Polygon> polygons;\n-    /** Since the original data may have been in the form of multi-polygons, an id is stored for each single polygon\n-     *  corresponding to the row in which any other attributes for this entry are located.\n-     */\n-    std::vector<size_t> ids;\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n@@ -126,7 +120,7 @@ class IPolygonDictionary : public IDictionaryBase\n      *  The polygons serving as keys are extracted into boost types.\n      *  All other values are stored in one column per attribute.\n      */\n-    void createAttributes();\n+    void setup();\n     void blockToAttributes(const Block & block);\n     void loadData();\n \n@@ -135,13 +129,6 @@ class IPolygonDictionary : public IDictionaryBase\n     /** Checks whether a given attribute exists and returns its index */\n     size_t getAttributeIndex(const std::string & attribute_name) const;\n \n-    /** Helper functions to retrieve and instantiate the provided null value of an attribute.\n-     *  Since a null value is obligatory for every attribute they are simply appended to null_values defined below.\n-     */\n-    template <typename T>\n-    void appendNullValueImpl(const Field & null_value);\n-    void appendNullValue(AttributeUnderlyingType type, const Field & value);\n-\n     /** Helper function for retrieving the value of an attribute by key. */\n     template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n@@ -150,32 +137,16 @@ class IPolygonDictionary : public IDictionaryBase\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    /** A mapping from the names of the attributes to their index in the two vectors defined below. */\n-    std::map<std::string, size_t> attribute_index_by_name;\n-    /** A vector of columns storing the values of each attribute. */\n     Columns attributes;\n-    /** A vector of null values corresponding to each attribute. */\n-    std::vector<std::variant<\n-        UInt8,\n-        UInt16,\n-        UInt32,\n-        UInt64,\n-        UInt128,\n-        Int8,\n-        Int16,\n-        Int32,\n-        Int64,\n-        Decimal32,\n-        Decimal64,\n-        Decimal128,\n-        Float32,\n-        Float64,\n-        String>> null_values;\n \n     size_t bytes_allocated = 0;\n-    size_t element_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n \n+    /** Since the original data may have been in the form of multi-polygons, an id is stored for each single polygon\n+     *  corresponding to the row in which any other attributes for this entry are located.\n+     */\n+    std::vector<size_t> polygon_index_to_attribute_value_index;\n+\n     /** Extracts a list of polygons from a column according to input_type and point_type.\n      *  The polygons are appended to the dictionary with the corresponding ids.\n      */\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.cpp b/src/Dictionaries/PolygonDictionaryImplementations.cpp\nindex 6570b1128538..cb4bd05fd837 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.cpp\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.cpp\n@@ -39,14 +39,14 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionarySimple::clone() const\n             this->point_type);\n }\n \n-bool PolygonDictionarySimple::find(const Point & point, size_t & id) const\n+bool PolygonDictionarySimple::find(const Point & point, size_t & polygon_index) const\n {\n     bool found = false;\n     for (size_t i = 0; i < polygons.size(); ++i)\n     {\n         if (bg::covered_by(point, polygons[i]))\n         {\n-            id = i;\n+            polygon_index = i;\n             found = true;\n             break;\n         }\n@@ -90,7 +90,7 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexEach::clone() con\n             this->max_depth);\n }\n \n-bool PolygonDictionaryIndexEach::find(const Point & point, size_t & id) const\n+bool PolygonDictionaryIndexEach::find(const Point & point, size_t & polygon_index) const\n {\n     const auto * cell = grid.find(point.x(), point.y());\n     if (cell)\n@@ -100,13 +100,13 @@ bool PolygonDictionaryIndexEach::find(const Point & point, size_t & id) const\n             size_t unused;\n             if (buckets[candidate].find(point, unused))\n             {\n-                id = candidate;\n+                polygon_index = candidate;\n                 return true;\n             }\n         }\n         if (cell->first_covered != FinalCell::kNone)\n         {\n-            id = cell->first_covered;\n+            polygon_index = cell->first_covered;\n             return true;\n         }\n     }\n@@ -142,19 +142,19 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexCell::clone() con\n             this->max_depth);\n }\n \n-bool PolygonDictionaryIndexCell::find(const Point & point, size_t & id) const\n+bool PolygonDictionaryIndexCell::find(const Point & point, size_t & polygon_index) const\n {\n     const auto * cell = index.find(point.x(), point.y());\n     if (cell)\n     {\n-        if (!(cell->corresponding_ids).empty() && cell->index.find(point, id))\n+        if (!(cell->corresponding_ids).empty() && cell->index.find(point, polygon_index))\n         {\n-            id = cell->corresponding_ids[id];\n+            polygon_index = cell->corresponding_ids[polygon_index];\n             return true;\n         }\n         if (cell->first_covered != FinalCellWithSlabs::kNone)\n         {\n-            id = cell->first_covered;\n+            polygon_index = cell->first_covered;\n             return true;\n         }\n     }\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.h b/src/Dictionaries/PolygonDictionaryImplementations.h\nindex 24910c234304..b49bf3f4d6cd 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.h\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.h\n@@ -27,7 +27,7 @@ class PolygonDictionarySimple : public IPolygonDictionary\n     std::shared_ptr<const IExternalLoadable> clone() const override;\n \n private:\n-    bool find(const Point & point, size_t & id) const override;\n+    bool find(const Point & point, size_t & polygon_index) const override;\n };\n \n /** A polygon dictionary which generates a recursive grid in order to efficiently cut the number\n@@ -55,7 +55,7 @@ class PolygonDictionaryIndexEach : public IPolygonDictionary\n     static constexpr size_t kMaxDepthDefault = 5;\n \n private:\n-    bool find(const Point & point, size_t & id) const override;\n+    bool find(const Point & point, size_t & polygon_index) const override;\n \n     std::vector<SlabsPolygonIndex> buckets;\n     GridRoot<FinalCell> grid;\n@@ -84,7 +84,7 @@ class PolygonDictionaryIndexCell : public IPolygonDictionary\n     static constexpr size_t kMaxDepthDefault = 5;\n \n private:\n-    bool find(const Point & point, size_t & id) const override;\n+    bool find(const Point & point, size_t & polygon_index) const override;\n \n     GridRoot<FinalCellWithSlabs> index;\n \ndiff --git a/src/Dictionaries/PolygonDictionaryUtils.cpp b/src/Dictionaries/PolygonDictionaryUtils.cpp\nindex e35016aaef29..2575affbb56f 100644\n--- a/src/Dictionaries/PolygonDictionaryUtils.cpp\n+++ b/src/Dictionaries/PolygonDictionaryUtils.cpp\n@@ -90,7 +90,6 @@ std::vector<Coord> SlabsPolygonIndex::uniqueX(const std::vector<Polygon> & polyg\n     std::sort(all_x.begin(), all_x.end());\n     all_x.erase(std::unique(all_x.begin(), all_x.end()), all_x.end());\n \n-    LOG_TRACE(log, \"Found {} unique x coordinates\", all_x.size());\n     return all_x;\n }\n \n@@ -112,8 +111,6 @@ void SlabsPolygonIndex::indexBuild(const std::vector<Polygon> & polygons)\n     /** Total number of edges */\n     size_t m = all_edges.size();\n \n-    LOG_TRACE(log, \"Just sorted {} edges from all {} polygons\", all_edges.size(), polygons.size());\n-\n     /** Using custom comparator for fetching edges in right_point order, like in scanline */\n     auto cmp = [](const Edge & a, const Edge & b)\n     {\n@@ -180,8 +177,6 @@ void SlabsPolygonIndex::indexBuild(const std::vector<Polygon> & polygons)\n             }\n         }\n     }\n-\n-    LOG_TRACE(log, \"Polygon index is built, total_index_edges = {}\", total_index_edges);\n }\n \n void SlabsPolygonIndex::indexAddRing(const Ring & ring, size_t polygon_id)\ndiff --git a/src/Dictionaries/PolygonDictionaryUtils.h b/src/Dictionaries/PolygonDictionaryUtils.h\nindex cd99717f98a7..865d78a7cade 100644\n--- a/src/Dictionaries/PolygonDictionaryUtils.h\n+++ b/src/Dictionaries/PolygonDictionaryUtils.h\n@@ -73,7 +73,7 @@ class SlabsPolygonIndex\n \n private:\n     /** Returns unique x coordinates among all points */\n-    std::vector<Coord> uniqueX(const std::vector<Polygon> & polygons);\n+    static std::vector<Coord> uniqueX(const std::vector<Polygon> & polygons);\n \n     /** Builds index described above */\n     void indexBuild(const std::vector<Polygon> & polygons);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01760_polygon_dictionaries.reference b/tests/queries/0_stateless/01760_polygon_dictionaries.reference\nnew file mode 100644\nindex 000000000000..6b236e980e16\n--- /dev/null\n+++ b/tests/queries/0_stateless/01760_polygon_dictionaries.reference\n@@ -0,0 +1,19 @@\n+dictGet\n+(-0.1,0)\tClick South\t423\t423\n+(0,-1.1)\tClick West\t424\t\\N\n+(0,1.1)\tClick North\t422\t\\N\n+(0.1,0)\tClick East\t421\t421\n+(3,3)\tqqq\t10\t20\n+dictGetOrDefault\n+(-0.1,0)\tClick South\t423\t423\n+(0,-1.1)\tClick West\t424\t\\N\n+(0,1.1)\tClick North\t422\t\\N\n+(0.1,0)\tClick East\t421\t421\n+(3,3)\tDefaultName\t30\t40\n+dictHas\n+(-0.1,0)\t1\t1\t1\n+(0,-1.1)\t1\t1\t1\n+(0,1.1)\t1\t1\t1\n+(0.1,0)\t1\t1\t1\n+(3,3)\t0\t0\t0\n+check NaN or infinite point input\ndiff --git a/tests/queries/0_stateless/01760_polygon_dictionaries.sql b/tests/queries/0_stateless/01760_polygon_dictionaries.sql\nnew file mode 100644\nindex 000000000000..5e26d2fc306e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01760_polygon_dictionaries.sql\n@@ -0,0 +1,67 @@\n+DROP DATABASE IF EXISTS 01760_db;\n+CREATE DATABASE 01760_db;\n+\n+DROP TABLE IF EXISTS 01760_db.polygons;\n+CREATE TABLE 01760_db.polygons (key Array(Array(Array(Tuple(Float64, Float64)))), name String, value UInt64, value_nullable Nullable(UInt64)) ENGINE = Memory;\n+INSERT INTO 01760_db.polygons VALUES ([[[(3, 1), (0, 1), (0, -1), (3, -1)]]], 'Click East', 421, 421);\n+INSERT INTO 01760_db.polygons VALUES ([[[(-1, 1), (1, 1), (1, 3), (-1, 3)]]], 'Click North', 422, NULL);\n+INSERT INTO 01760_db.polygons VALUES ([[[(-3, 1), (-3, -1), (0, -1), (0, 1)]]], 'Click South', 423, 423);\n+INSERT INTO 01760_db.polygons VALUES ([[[(-1, -1), (1, -1), (1, -3), (-1, -3)]]], 'Click West', 424, NULL);\n+\n+DROP TABLE IF EXISTS 01760_db.points;\n+CREATE TABLE 01760_db.points (x Float64, y Float64, def_i UInt64, def_s String) ENGINE = Memory;\n+INSERT INTO 01760_db.points VALUES (0.1, 0.0, 112, 'aax');\n+INSERT INTO 01760_db.points VALUES (-0.1, 0.0, 113, 'aay');\n+INSERT INTO 01760_db.points VALUES (0.0, 1.1, 114, 'aaz');\n+INSERT INTO 01760_db.points VALUES (0.0, -1.1, 115, 'aat');\n+INSERT INTO 01760_db.points VALUES (3.0, 3.0, 22, 'bb');\n+\n+DROP DICTIONARY IF EXISTS 01760_db.dict_array;\n+CREATE DICTIONARY 01760_db.dict_array\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    name String DEFAULT 'qqq',\n+    value UInt64 DEFAULT 10,\n+    value_nullable Nullable(UInt64) DEFAULT 20\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'polygons' DB '01760_db'))\n+LIFETIME(0)\n+LAYOUT(POLYGON());\n+\n+SELECT 'dictGet';\n+\n+SELECT tuple(x, y) as key,\n+    dictGet('01760_db.dict_array', 'name', key),\n+    dictGet('01760_db.dict_array', 'value', key),\n+    dictGet('01760_db.dict_array', 'value_nullable', key)\n+FROM 01760_db.points\n+ORDER BY x, y;\n+\n+SELECT 'dictGetOrDefault';\n+\n+SELECT tuple(x, y) as key,\n+    dictGetOrDefault('01760_db.dict_array', 'name', key, 'DefaultName'),\n+    dictGetOrDefault('01760_db.dict_array', 'value', key, 30),\n+    dictGetOrDefault('01760_db.dict_array', 'value_nullable', key, 40)\n+FROM 01760_db.points\n+ORDER BY x, y;\n+\n+SELECT 'dictHas';\n+\n+SELECT tuple(x, y) as key,\n+    dictHas('01760_db.dict_array', key),\n+    dictHas('01760_db.dict_array', key),\n+    dictHas('01760_db.dict_array', key)\n+FROM 01760_db.points\n+ORDER BY x, y;\n+\n+SELECT 'check NaN or infinite point input';\n+SELECT tuple(nan, inf) as key, dictGet('01760_db.dict_array', 'name', key); --{serverError 36}\n+SELECT tuple(nan, nan) as key, dictGet('01760_db.dict_array', 'name', key); --{serverError 36}\n+SELECT tuple(inf, nan) as key, dictGet('01760_db.dict_array', 'name', key); --{serverError 36}\n+SELECT tuple(inf, inf) as key, dictGet('01760_db.dict_array', 'name', key); --{serverError 36}\n+\n+DROP DICTIONARY 01760_db.dict_array;\n+DROP TABLE 01760_db.points;\n+DROP TABLE 01760_db.polygons;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 436f0257c948..981cf69d6762 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -776,6 +776,7 @@\n         \"01682_cache_dictionary_complex_key\",\n         \"01684_ssd_cache_dictionary_simple_key\",\n         \"01685_ssd_cache_dictionary_complex_key\",\n-        \"01760_system_dictionaries\"\n+        \"01760_system_dictionaries\",\n+        \"01760_polygon_dictionaries\"\n     ]\n }\n",
  "problem_statement": "bytes_allocated for polygon dictionaries is 0, even when loaded\n```\r\nSELECT *\r\nFROM system.dictionaries\r\nWHERE name LIKE 'XXXX%'\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\ndatabase:                    default\r\nname:                        XXXX_dict\r\nuuid:                        00000000-0000-0000-0000-000000000000\r\nstatus:                      LOADED\r\norigin:                      default.XXXX_dict\r\ntype:                        Polygon\r\nkey:                         (Array(Array(Array(Array(Float64)))))\r\nattribute.names:             ['name','id']\r\nattribute.types:             ['String','String']\r\nbytes_allocated:             0\r\nquery_count:                 0\r\nhit_rate:                    1\r\nelement_count:               433731\r\nload_factor:                 1\r\nsource:                      ClickHouse: default.XXXX\r\nlifetime_min:                60\r\nlifetime_max:                1800\r\nloading_start_time:          2021-03-11 00:07:52\r\nlast_successful_update_time: 2021-03-11 00:08:24\r\nloading_duration:            31.595\r\nlast_exception:\r\n```\n",
  "hints_text": "",
  "created_at": "2021-03-18T20:27:15Z",
  "modified_files": [
    "src/Dictionaries/PolygonDictionary.cpp",
    "src/Dictionaries/PolygonDictionary.h",
    "src/Dictionaries/PolygonDictionaryImplementations.cpp",
    "src/Dictionaries/PolygonDictionaryImplementations.h",
    "src/Dictionaries/PolygonDictionaryUtils.cpp",
    "src/Dictionaries/PolygonDictionaryUtils.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01760_polygon_dictionaries.reference",
    "b/tests/queries/0_stateless/01760_polygon_dictionaries.sql",
    "tests/queries/skip_list.json"
  ]
}