{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73682,
  "instance_id": "ClickHouse__ClickHouse-73682",
  "issue_numbers": [
    "72498",
    "73118",
    "73640"
  ],
  "base_commit": "0b06d432faf93baec758cd7b8766e1f4f82a7dfe",
  "patch": "diff --git a/src/Processors/QueryPlan/PartsSplitter.cpp b/src/Processors/QueryPlan/PartsSplitter.cpp\nindex bac910364091..07e3a3cd2c95 100644\n--- a/src/Processors/QueryPlan/PartsSplitter.cpp\n+++ b/src/Processors/QueryPlan/PartsSplitter.cpp\n@@ -897,9 +897,22 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n \n     RangesInDataParts intersecting_parts_ranges = std::move(parts);\n \n+    auto create_merging_pipe = [&](const auto & ranges)\n+    {\n+        auto pipe = in_order_reading_step_getter(ranges);\n+\n+        pipe.addSimpleTransform([sorting_expr](const Block & header)\n+        {\n+            return std::make_shared<ExpressionTransform>(header, sorting_expr);\n+        });\n+\n+        return pipe;\n+    };\n+\n     if (!isSafePrimaryKey(primary_key))\n     {\n-        result.merging_pipes.emplace_back(in_order_reading_step_getter(intersecting_parts_ranges));\n+        if (!intersecting_parts_ranges.empty())\n+            result.merging_pipes.emplace_back(create_merging_pipe(intersecting_parts_ranges));\n         return result;\n     }\n \n@@ -912,7 +925,8 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n \n     if (!split_intersecting_parts_ranges_into_layers)\n     {\n-        result.merging_pipes.emplace_back(in_order_reading_step_getter(intersecting_parts_ranges));\n+        if (!intersecting_parts_ranges.empty())\n+            result.merging_pipes.emplace_back(create_merging_pipe(intersecting_parts_ranges));\n         return result;\n     }\n \n@@ -925,9 +939,7 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n \n     for (size_t i = 0; i < layers.size(); ++i)\n     {\n-        result.merging_pipes[i] = in_order_reading_step_getter(std::move(layers[i]));\n-        result.merging_pipes[i].addSimpleTransform([sorting_expr](const Block & header)\n-                                    { return std::make_shared<ExpressionTransform>(header, sorting_expr); });\n+        result.merging_pipes[i] = create_merging_pipe(layers[i]);\n \n         auto & filter_function = filters[i];\n         if (!filter_function)\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 61b150cc2e80..db7f7ef2369c 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1221,6 +1221,17 @@ static void addMergingFinal(\n                                 { return std::make_shared<SelectByIndicesTransform>(header_); });\n }\n \n+static std::pair<std::shared_ptr<ExpressionActions>, String> createExpressionForPositiveSign(const String & sign_column_name, const Block & header, const ContextPtr & context)\n+{\n+    ASTPtr sign_indentifier = std::make_shared<ASTIdentifier>(sign_column_name);\n+    ASTPtr sign_filter = makeASTFunction(\"greater\", sign_indentifier, std::make_shared<ASTLiteral>(Field{0}));\n+    const auto & sign_column = header.getByName(sign_column_name);\n+\n+    auto syntax_result = TreeRewriter(context).analyze(sign_filter, {{sign_column.name, sign_column.type}});\n+    auto actions = ExpressionAnalyzer(sign_filter, syntax_result, context).getActionsDAG(false);\n+    return {std::make_shared<ExpressionActions>(std::move(actions)), sign_filter->getColumnName()};\n+}\n+\n bool ReadFromMergeTree::doNotMergePartsAcrossPartitionsFinal() const\n {\n     const auto & settings = context->getSettingsRef();\n@@ -1418,7 +1429,29 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsFinal(\n \n     if (!non_intersecting_parts_by_primary_key.empty())\n     {\n-        auto pipe = spreadMarkRangesAmongStreams(std::move(non_intersecting_parts_by_primary_key), num_streams, origin_column_names);\n+        Pipe pipe;\n+\n+        /// Collapsing algorithm doesn't expose non-matched rows with a negative sign in queries with FINAL.\n+        /// To support this logic without merging data, add a filtering by sign column for non-intersecting ranges.\n+        if (data.merging_params.mode == MergeTreeData::MergingParams::Collapsing)\n+        {\n+            auto columns_with_sign = origin_column_names;\n+            if (std::ranges::find(columns_with_sign, data.merging_params.sign_column) == columns_with_sign.end())\n+                columns_with_sign.push_back(data.merging_params.sign_column);\n+\n+            pipe = spreadMarkRangesAmongStreams(std::move(non_intersecting_parts_by_primary_key), num_streams, columns_with_sign);\n+            auto [expression, filter_name] = createExpressionForPositiveSign(data.merging_params.sign_column, pipe.getHeader(), context);\n+\n+            pipe.addSimpleTransform([&](const Block & header)\n+            {\n+                return std::make_shared<FilterTransform>(header, expression, filter_name, true);\n+            });\n+        }\n+        else\n+        {\n+            pipe = spreadMarkRangesAmongStreams(std::move(non_intersecting_parts_by_primary_key), num_streams, origin_column_names);\n+        }\n+\n         no_merging_pipes.emplace_back(std::move(pipe));\n     }\n \n@@ -1950,15 +1983,14 @@ Pipe ReadFromMergeTree::spreadMarkRanges(\n     Names column_names_to_read = result.column_names_to_read;\n     NameSet names(column_names_to_read.begin(), column_names_to_read.end());\n \n-    if (!final && result.sampling.use_sampling)\n+    if (result.sampling.use_sampling)\n     {\n         NameSet sampling_columns;\n \n         /// Add columns needed for `sample_by_ast` to `column_names_to_read`.\n-        /// Skip this if final was used, because such columns were already added from PK.\n         for (const auto & column : result.sampling.filter_expression->getRequiredColumns().getNames())\n         {\n-            if (!names.contains(column))\n+            if (names.emplace(column).second)\n                 column_names_to_read.push_back(column);\n \n             sampling_columns.insert(column);\n@@ -1975,25 +2007,25 @@ Pipe ReadFromMergeTree::spreadMarkRanges(\n         if (output_each_partition_through_separate_port)\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"Optimization isn't supposed to be used for queries with final\");\n \n+        auto original_column_names = column_names_to_read;\n+\n         /// Add columns needed to calculate the sorting expression and the sign.\n         for (const auto & column : storage_snapshot->metadata->getColumnsRequiredForSortingKey())\n         {\n-            if (!names.contains(column))\n-            {\n+            if (names.emplace(column).second)\n                 column_names_to_read.push_back(column);\n-                names.insert(column);\n-            }\n         }\n \n-        if (!data.merging_params.is_deleted_column.empty() && !names.contains(data.merging_params.is_deleted_column))\n+        if (!data.merging_params.is_deleted_column.empty() && names.emplace(data.merging_params.is_deleted_column).second)\n             column_names_to_read.push_back(data.merging_params.is_deleted_column);\n-        if (!data.merging_params.sign_column.empty() && !names.contains(data.merging_params.sign_column))\n+        if (!data.merging_params.sign_column.empty() && names.emplace(data.merging_params.sign_column).second)\n             column_names_to_read.push_back(data.merging_params.sign_column);\n-        if (!data.merging_params.version_column.empty() && !names.contains(data.merging_params.version_column))\n+        if (!data.merging_params.version_column.empty() && names.emplace(data.merging_params.version_column).second)\n             column_names_to_read.push_back(data.merging_params.version_column);\n \n-        return spreadMarkRangesAmongStreamsFinal(std::move(parts_with_ranges), num_streams, result.column_names_to_read, column_names_to_read, result_projection);\n+        return spreadMarkRangesAmongStreamsFinal(std::move(parts_with_ranges), num_streams, original_column_names, column_names_to_read, result_projection);\n     }\n+\n     if (query_info.input_order_info)\n     {\n         return spreadMarkRangesAmongStreamsWithOrder(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 06747bded272..2e2892a35bb9 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -204,14 +204,12 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n     RelativeSize relative_sample_size = 0;\n     RelativeSize relative_sample_offset = 0;\n \n-    bool final = false;\n     std::optional<ASTSampleRatio::Rational> sample_size_ratio;\n     std::optional<ASTSampleRatio::Rational> sample_offset_ratio;\n \n     if (select_query_info.table_expression_modifiers)\n     {\n         const auto & table_expression_modifiers = *select_query_info.table_expression_modifiers;\n-        final = table_expression_modifiers.hasFinal();\n         sample_size_ratio = table_expression_modifiers.getSampleSizeRatio();\n         sample_offset_ratio = table_expression_modifiers.getSampleOffsetRatio();\n     }\n@@ -219,7 +217,6 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n     {\n         auto & select = select_query_info.query->as<ASTSelectQuery &>();\n \n-        final = select.final();\n         auto select_sample_size = select.sampleSize();\n         auto select_sample_offset = select.sampleOffset();\n \n@@ -401,23 +398,8 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n             std::shared_ptr<ASTFunction> lower_function;\n             std::shared_ptr<ASTFunction> upper_function;\n \n-            /// If sample and final are used together no need to calculate sampling expression twice.\n-            /// The first time it was calculated for final, because sample key is a part of the PK.\n-            /// So, assume that we already have calculated column.\n-            ASTPtr sampling_key_ast;\n-\n-            if (final)\n-            {\n-                sampling_key_ast = std::make_shared<ASTIdentifier>(sampling_key.column_names[0]);\n-                /// We do spoil available_real_columns here, but it is not used later.\n-                available_real_columns.emplace_back(sampling_key.column_names[0], std::move(sampling_column_type));\n-            }\n-            else\n-            {\n-                sampling_key_ast = metadata_snapshot->getSamplingKeyAST()->clone();\n-            }\n-\n-            chassert(sampling_key_ast != nullptr);\n+            chassert(metadata_snapshot->getSamplingKeyAST() != nullptr);\n+            ASTPtr sampling_key_ast = metadata_snapshot->getSamplingKeyAST()->clone();\n \n             if (has_lower_limit)\n             {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03290_final_collapsing.reference b/tests/queries/0_stateless/03290_final_collapsing.reference\nnew file mode 100644\nindex 000000000000..0b86b762458d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_collapsing.reference\n@@ -0,0 +1,8 @@\n+0\n+0\n+0\n+0\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/03290_final_collapsing.sql b/tests/queries/0_stateless/03290_final_collapsing.sql\nnew file mode 100644\nindex 000000000000..b73c8441c0cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_collapsing.sql\n@@ -0,0 +1,52 @@\n+DROP TABLE IF EXISTS t_final_collapsing;\n+\n+CREATE TABLE t_final_collapsing\n+(\n+  key Int8,\n+  sign Int8\n+)\n+ENGINE = CollapsingMergeTree(sign) ORDER BY key;\n+\n+INSERT INTO t_final_collapsing VALUES (5, -1);\n+\n+OPTIMIZE TABLE t_final_collapsing FINAL; -- to move part to a level 1, to enable optimizations\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+DROP TABLE t_final_collapsing;\n+\n+CREATE TABLE t_final_collapsing\n+(\n+  key Int8,\n+  sign Int8,\n+  version UInt64\n+)\n+ENGINE = VersionedCollapsingMergeTree(sign, version) ORDER BY key;\n+\n+INSERT INTO t_final_collapsing VALUES (5, -1, 1);\n+\n+OPTIMIZE TABLE t_final_collapsing FINAL; -- to move part to a level 1, to enable optimizations\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_final_collapsing FINAL;\n+\n+DROP TABLE t_final_collapsing;\ndiff --git a/tests/queries/0_stateless/03290_final_replacing.reference b/tests/queries/0_stateless/03290_final_replacing.reference\nnew file mode 100644\nindex 000000000000..5e34014aff49\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_replacing.reference\n@@ -0,0 +1,12 @@\n+1\t2\n+2\t3\n+5\t4\n+1\t2\n+2\t3\n+5\t4\n+1\t2\n+2\t3\n+5\t4\n+1\t2\n+2\t3\n+5\t4\ndiff --git a/tests/queries/0_stateless/03290_final_replacing.sql b/tests/queries/0_stateless/03290_final_replacing.sql\nnew file mode 100644\nindex 000000000000..dd18a0290209\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_replacing.sql\n@@ -0,0 +1,24 @@\n+DROP TABLE IF EXISTS t_final_replacing;\n+\n+CREATE TABLE t_final_replacing (a UInt64, b UInt64) ENGINE = ReplacingMergeTree ORDER BY a SETTINGS index_granularity = 1;\n+\n+INSERT INTO t_final_replacing VALUES (1, 1) (1, 2) (2, 3);\n+INSERT INTO t_final_replacing VALUES (2, 3) (5, 4);\n+\n+OPTIMIZE TABLE t_final_replacing FINAL;\n+\n+SET optimize_read_in_order = 0;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT a, b FROM t_final_replacing FINAL ORDER BY a, b;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT a, b FROM t_final_replacing FINAL ORDER BY a, b;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT a, b FROM t_final_replacing FINAL ORDER BY a, b;\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT a, b FROM t_final_replacing FINAL ORDER BY a, b;\n+\n+DROP TABLE t_final_replacing;\ndiff --git a/tests/queries/0_stateless/03290_final_sample.reference b/tests/queries/0_stateless/03290_final_sample.reference\nnew file mode 100644\nindex 000000000000..e632860fab31\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_sample.reference\n@@ -0,0 +1,8 @@\n+5\n+5\n+5\n+5\n+5\n+5\n+5\n+5\ndiff --git a/tests/queries/0_stateless/03290_final_sample.sql b/tests/queries/0_stateless/03290_final_sample.sql\nnew file mode 100644\nindex 000000000000..9fde622ec51b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03290_final_sample.sql\n@@ -0,0 +1,44 @@\n+DROP TABLE IF EXISTS t_sample_final;\n+\n+CREATE TABLE t_sample_final\n+(\n+    CounterID UInt32,\n+    UserID UInt64,\n+    Version UInt64\n+)\n+ENGINE = ReplacingMergeTree(Version)\n+ORDER BY (CounterID, intHash32(UserID))\n+SAMPLE BY intHash32(UserID)\n+SETTINGS index_granularity = 8192;\n+\n+INSERT INTO t_sample_final SELECT * FROM generateRandom('CounterID UInt32, UserID UInt64, Version UInt64', 1, 10, 2) LIMIT 10;\n+\n+OPTIMIZE TABLE t_sample_final FINAL;\n+\n+set send_logs_level = 'error';\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(CounterID);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(CounterID);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(CounterID);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(CounterID);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(*);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 0, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(*);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 0;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(*);\n+\n+SET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1, split_intersecting_parts_ranges_into_layers_final = 1;\n+SELECT count() FROM t_sample_final FINAL SAMPLE 1 / 2 WHERE NOT ignore(*);\n+\n+DROP TABLE t_sample_final;\n",
  "problem_statement": "DB::Exception: Not found column (NOT_FOUND_COLUMN_IN_BLOCK) for SELECT ...  FINAL SAMPLE \n**Describe the issue**\r\nAfter updating server from 23.3 to 24.3 we started to get an error `NOT_FOUND_COLUMN_IN_BLOCK` for some SELECT queries \r\n(see simplified and reproducible example below).\r\nTurning off `allow_experimental_analyzer` does not help.\r\n\r\nIt looks like the reason in the level of selected parts. If part has level 0 query is working, for parts with level > 0 query starts to throw the exception.\r\n\r\nPay attention on this diff in the log.\r\n* Failed select (part.level > 0)\r\n```\r\n2024.11.26 18:30:01.011306 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Non intersecting ranges in data parts 1 parts: [part all_1_2_1 with ranges [(0, 1)]]\r\n2024.11.26 18:30:01.011312 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Intersecting ranges in data parts 0 parts: []\r\n```\r\n* Working select (part.level = 0)\r\n```\r\n2024.11.26 18:29:42.776688 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Non intersecting ranges in data parts 0 parts: []\r\n2024.11.26 18:29:42.776724 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Intersecting ranges in data parts 2 parts: [part all_1_1_0 with ranges [(0, 1)], part all_2_2_0 with ranges [(0, 1)]]\r\n2024.11.26 18:29:42.776741 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Split intersecting ranges into 1 layers\r\n```\r\n\r\nInstead of `OPTIMIZE ... FINAL` just renaming part `all_1_1_0` to `all_1_1_1` on the disk and restart CH can be done to break the queries\r\n\r\n**How to reproduce**\r\nCH version 24.10.3\r\n```sql\r\ndev-vm.ru-central1.internal :) CREATE TABLE default.test_table03\r\n(\r\n    `CounterID` UInt32,\r\n    `UserID` UInt64,\r\n    `Version` UInt64\r\n)\r\nENGINE = ReplacingMergeTree(Version)\r\nORDER BY (CounterID, intHash32(UserID))\r\nSAMPLE BY intHash32(UserID)\r\nSETTINGS index_granularity = 8192\r\n\r\nCREATE TABLE default.test_table03\r\n(\r\n    `CounterID` UInt32,\r\n    `UserID` UInt64,\r\n    `Version` UInt64\r\n)\r\nENGINE = ReplacingMergeTree(Version)\r\nORDER BY (CounterID, intHash32(UserID))\r\nSAMPLE BY intHash32(UserID)\r\nSETTINGS index_granularity = 8192\r\n\r\nQuery id: 4ea28152-ef93-4c5d-b209-94a168da091a\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.025 sec. \r\n\r\ndev-vm.ru-central1.internal :) insert into test_table03 SELECT * FROM generateRandom('`CounterID` UInt32, `UserID` UInt64, `Version` UInt64', 1, 10, 2) limit 10\r\n\r\nINSERT INTO test_table03 SELECT *\r\nFROM generateRandom('`CounterID` UInt32, `UserID` UInt64, `Version` UInt64', 1, 10, 2)\r\nLIMIT 10\r\n\r\nQuery id: f0e25154-6859-41e4-9798-e0e581a9fd45\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n\r\ndev-vm.ru-central1.internal :) SELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nSELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nQuery id: 64964caf-db03-45da-bcd2-d3d07f9bd290\r\n\r\n   \u250c\u2500\u2500CounterID\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500UserID\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Version\u2500\u2510\r\n1. \u2502  153951766 \u2502 17642005186012218654 \u2502  7244842965196057084 \u2502\r\n2. \u2502  730412674 \u2502  9558594037060121162 \u2502 15539571320073754492 \u2502\r\n3. \u2502 1382038526 \u2502  1355609803008819271 \u2502  7390467479849635722 \u2502\r\n4. \u2502 2319105779 \u2502 18371568619324220532 \u2502 11652964532125973222 \u2502\r\n5. \u2502 4107652264 \u2502  8124171311239967992 \u2502 17267040165663451487 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n5 rows in set. Elapsed: 0.003 sec. \r\n\r\ndev-vm.ru-central1.internal :) insert into test_table03 SELECT * FROM generateRandom('`CounterID` UInt32, `UserID` UInt64, `Version` UInt64', 1, 10, 2) limit 10\r\n\r\nINSERT INTO test_table03 SELECT *\r\nFROM generateRandom('`CounterID` UInt32, `UserID` UInt64, `Version` UInt64', 1, 10, 2)\r\nLIMIT 10\r\n\r\nQuery id: a5a7eb9b-9260-4eb2-be72-d0d1d38e89d8\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec. \r\n\r\ndev-vm.ru-central1.internal :) SELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nSELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nQuery id: 02506f88-178d-4c34-b7f5-9b096cb3fc7e\r\n\r\n   \u250c\u2500\u2500CounterID\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500UserID\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500Version\u2500\u2510\r\n1. \u2502  153951766 \u2502 17642005186012218654 \u2502  7244842965196057084 \u2502\r\n2. \u2502  730412674 \u2502  9558594037060121162 \u2502 15539571320073754492 \u2502\r\n3. \u2502 1382038526 \u2502  1355609803008819271 \u2502  7390467479849635722 \u2502\r\n4. \u2502 2319105779 \u2502 18371568619324220532 \u2502 11652964532125973222 \u2502\r\n5. \u2502 4107652264 \u2502  8124171311239967992 \u2502 17267040165663451487 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n5 rows in set. Elapsed: 0.004 sec. \r\n\r\ndev-vm.ru-central1.internal :) optimize table test_table03 FINAL\r\n\r\nOPTIMIZE TABLE test_table03 FINAL\r\n\r\nQuery id: 9e6b2098-f733-4ed1-b58c-9648c7d0cceb\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n\r\ndev-vm.ru-central1.internal :) SELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nSELECT *\r\nFROM test_table03\r\nFINAL\r\nSAMPLE 1 / 2\r\n\r\nQuery id: c081af83-e0d5-4183-88cc-27911ce8d411\r\n\r\n\r\nElapsed: 0.003 sec. \r\n\r\nReceived exception from server (version 24.10.3):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column intHash32(UserID): in block CounterID UInt32 UInt32(size = 0), UserID UInt64 UInt64(size = 0), Version UInt64 UInt64(size = 0). (NOT_FOUND_COLUMN_IN_BLOCK)\r\n\r\n```\r\n\r\n\r\n**Error message and/or stacktrace**\r\nFailed query (part.level > 0)\r\n```\r\n2024.11.26 18:30:01.010508 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Debug> executeQuery: (from [::1]:59466) SELECT * FROM test_table03 FINAL SAMPLE 1 / 2 (stage: Complete)\r\n2024.11.26 18:30:01.010810 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> Planner: Query to stage Complete\r\n2024.11.26 18:30:01.010938 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> Planner: Query from stage FetchColumns to stage Complete\r\n2024.11.26 18:30:01.011075 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Debug> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Key condition: unknown\r\n2024.11.26 18:30:01.011191 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Filtering marks by primary and secondary keys\r\n2024.11.26 18:30:01.011217 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Used generic exclusion search over index for part all_1_2_1 with 1 steps\r\n2024.11.26 18:30:01.011252 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Debug> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Selected 1/1 parts by partition key, 1 parts by primary key, 1/1 marks by primary key, 1 marks to read from 1 ranges\r\n2024.11.26 18:30:01.011278 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Parts ranges before sort Part index 0 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 0 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\n\r\n2024.11.26 18:30:01.011286 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Parts ranges after sort Part index 0 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 0 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\n\r\n2024.11.26 18:30:01.011306 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Non intersecting ranges in data parts 1 parts: [part all_1_2_1 with ranges [(0, 1)]]\r\n2024.11.26 18:30:01.011312 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Intersecting ranges in data parts 0 parts: []\r\n2024.11.26 18:30:01.011319 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> PartsSplitter: Split intersecting ranges into 0 layers\r\n2024.11.26 18:30:01.011328 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Spreading mark ranges among streams (default reading)\r\n2024.11.26 18:30:01.011355 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Test> MergeTreeReadPoolBase: Will use min_marks_per_task=24\r\n2024.11.26 18:30:01.011364 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Reading 1 ranges in order from part all_1_2_1, approx. 10 rows starting from 0\r\n2024.11.26 18:30:01.011676 [ 1500512 ] {c081af83-e0d5-4183-88cc-27911ce8d411} <Error> executeQuery: Code: 10. DB::Exception: Not found column intHash32(UserID): in block CounterID UInt32 UInt32(size = 0), UserID UInt64 UInt64(size = 0), Version UInt64 UInt64(size = 0). (NOT_FOUND_COLUMN_IN_BLOCK) (version 24.10.3.21 (official build)) (from [::1]:59466) (in query: SELECT * FROM test_table03 FINAL SAMPLE 1 / 2), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000cf7d73b\r\n1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000007ea888c\r\n2. DB::Exception::Exception<String const&>(int, FormatStringHelperImpl<std::type_identity<String const&>::type>, String const&) @ 0x0000000007ec3c8b\r\n3. DB::ActionsDAG::evaluatePartialResult(std::unordered_map<DB::ActionsDAG::Node const*, DB::ColumnWithTypeAndName, std::hash<DB::ActionsDAG::Node const*>, std::equal_to<DB::ActionsDAG::Node const*>, std::allocator<std::pair<DB::ActionsDAG::Node const* const, DB::ColumnWithTypeAndName>>>&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>> const&, unsigned long, bool) @ 0x0000000010af90f4\r\n4. DB::ActionsDAG::updateHeader(DB::Block const&) const @ 0x0000000010af719d\r\n5. DB::FilterTransform::transformHeader(DB::Block const&, DB::ActionsDAG const*, String const&, bool) @ 0x0000000012c38c13\r\n6. DB::FilterTransform::FilterTransform(DB::Block const&, std::shared_ptr<DB::ExpressionActions>, String, bool, bool, std::shared_ptr<std::atomic<unsigned long>>) @ 0x0000000012c3912f\r\n7. std::shared_ptr<DB::IProcessor> std::__function::__policy_invoker<std::shared_ptr<DB::IProcessor> (DB::Block const&)>::__call_impl<std::__function::__default_alloc_func<DB::ReadFromMergeTree::initializePipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&)::$_0, std::shared_ptr<DB::IProcessor> (DB::Block const&)>>(std::__function::__policy_storage const*, DB::Block const&) @ 0x0000000012e15f43\r\n8. DB::Pipe::addSimpleTransform(std::function<std::shared_ptr<DB::IProcessor> (DB::Block const&, DB::Pipe::StreamType)> const&)::$_0::operator()(DB::OutputPort*&, DB::Pipe::StreamType) const @ 0x00000000106c764e\r\n9. DB::Pipe::addSimpleTransform(std::function<std::shared_ptr<DB::IProcessor> (DB::Block const&, DB::Pipe::StreamType)> const&) @ 0x00000000106c746d\r\n10. DB::ReadFromMergeTree::initializePipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&) @ 0x0000000012e095d5\r\n11. DB::ISourceStep::updatePipeline(std::vector<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>, std::allocator<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>>>, DB::BuildQueryPipelineSettings const&) @ 0x0000000012dc18ca\r\n12. DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x0000000012ddfa33\r\n13. DB::InterpreterSelectQueryAnalyzer::buildQueryPipeline() @ 0x00000000113d4b6a\r\n14. DB::InterpreterSelectQueryAnalyzer::execute() @ 0x00000000113d443e\r\n15. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001173b483\r\n16. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x00000000117372ba\r\n17. DB::TCPHandler::runImpl() @ 0x000000001292a1f4\r\n18. DB::TCPHandler::run() @ 0x0000000012945658\r\n19. Poco::Net::TCPServerConnection::start() @ 0x0000000015813427\r\n20. Poco::Net::TCPServerDispatcher::run() @ 0x00000000158138b9\r\n21. Poco::PooledThread::run() @ 0x00000000157e0421\r\n22. Poco::ThreadImpl::runnableEntry(void*) @ 0x00000000157de9dd\r\n23. ? @ 0x00007f20cac51ac3\r\n24. ? @ 0x00007f20cace3850\r\n\r\n```\r\n\r\nWorking query (part.level = 0)\r\n```\r\n2024.11.26 18:29:42.775278 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Debug> executeQuery: (from [::1]:59466) SELECT * FROM test_table03 FINAL SAMPLE 1 / 2 (stage: Complete)\r\n2024.11.26 18:29:42.775563 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> Planner: Query to stage Complete\r\n2024.11.26 18:29:42.775665 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> Planner: Query from stage FetchColumns to stage Complete\r\n2024.11.26 18:29:42.775817 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Debug> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Key condition: unknown\r\n2024.11.26 18:29:42.775939 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Filtering marks by primary and secondary keys\r\n2024.11.26 18:29:42.776361 [ 1501160 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Used generic exclusion search over index for part all_1_1_0 with 1 steps\r\n2024.11.26 18:29:42.776379 [ 1501218 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Used generic exclusion search over index for part all_2_2_0 with 1 steps\r\n2024.11.26 18:29:42.776619 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Debug> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Selected 2/2 parts by partition key, 2 parts by primary key, 2/2 marks by primary key, 2 marks to read from 2 r\r\nanges\r\n2024.11.26 18:29:42.776660 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Parts ranges before sort Part index 0 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 0 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\nPart index 1 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 1 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\n\r\n2024.11.26 18:29:42.776673 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Parts ranges after sort Part index 0 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 1 event Range Start range begin 0 end 1 value (85697048, 2989604029)\r\nPart index 0 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\nPart index 1 event Range End range begin 0 end 1 value (4107652264, 1403130518)\r\n\r\n2024.11.26 18:29:42.776688 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Non intersecting ranges in data parts 0 parts: []\r\n2024.11.26 18:29:42.776724 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Intersecting ranges in data parts 2 parts: [part all_1_1_0 with ranges [(0, 1)], part all_2_2_0 with ranges [(0, 1)]]\r\n2024.11.26 18:29:42.776741 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Split intersecting ranges into 1 layers\r\n2024.11.26 18:29:42.776749 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> PartsSplitter: Layer 0 2 parts: [part all_1_1_0 with ranges [(0, 1)], part all_2_2_0 with ranges [(0, 1)]] filter values in (-inf, +inf])\r\n2024.11.26 18:29:42.776783 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeReadPoolBase: Will use min_marks_per_task=8\r\n2024.11.26 18:29:42.776794 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeReadPoolBase: Will use min_marks_per_task=8\r\n2024.11.26 18:29:42.776806 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Reading 1 ranges in order from part all_1_1_0, approx. 10 rows starting from 0\r\n2024.11.26 18:29:42.776824 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Trace> default.test_table03 (d4db5ca2-d8b3-4917-93c7-dc912115f273) (SelectExecutor): Reading 1 ranges in order from part all_2_2_0, approx. 10 rows starting from 0\r\n2024.11.26 18:29:42.777825 [ 1501200 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeMarksLoader: Loading marks from path data.cmrk3\r\n2024.11.26 18:29:42.777908 [ 1501226 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeRangeReader: First reader returned: num_rows: 10, columns: 3, total_rows_per_granule: 10, no filter, column[0]:  UInt32(size = 10), column[1]:  UInt64(size = 10), column[2]:  UInt64\r\n(size = 10), requested columns: CounterID, UserID, Version\r\n2024.11.26 18:29:42.777944 [ 1501226 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeRangeReader: read() returned num_rows: 10, columns: 3, total_rows_per_granule: 10, no filter, column[0]:  UInt32(size = 10), column[1]:  UInt64(size = 10), column[2]:  UInt64(size =\r\n 10), sample block CounterID, UserID, Version\r\n2024.11.26 18:29:42.778018 [ 1501200 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeRangeReader: First reader returned: num_rows: 10, columns: 3, total_rows_per_granule: 10, no filter, column[0]:  UInt32(size = 10), column[1]:  UInt64(size = 10), column[2]:  UInt64\r\n(size = 10), requested columns: CounterID, UserID, Version\r\n2024.11.26 18:29:42.778039 [ 1501200 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Test> MergeTreeRangeReader: read() returned num_rows: 10, columns: 3, total_rows_per_granule: 10, no filter, column[0]:  UInt32(size = 10), column[1]:  UInt64(size = 10), column[2]:  UInt64(size =\r\n 10), sample block CounterID, UserID, Version\r\n2024.11.26 18:29:42.778602 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Debug> executeQuery: Read 20 rows, 400.00 B in 0.003349 sec., 5971.931919976112 rows/sec., 116.64 KiB/sec.\r\n2024.11.26 18:29:42.778807 [ 1500512 ] {02506f88-178d-4c34-b7f5-9b096cb3fc7e} <Debug> TCPHandler: Processed in 0.004004294 sec.\r\n\r\n```\r\n\r\n\nLogical error: Cannot add transform to empty Pipe in query with `FINAL` and disabled `split_intersecting_parts_ranges_into_layers_final`\n**Describe what's wrong**\r\n\r\n```sql\r\nDROP TABLE IF EXISTS test_final;\r\n\r\nCREATE TABLE test_final (a UInt64, b UInt64) ENGINE = ReplacingMergeTree ORDER BY a SETTINGS index_granularity = 1;\r\n\r\nINSERT INTO test_final VALUES (1, 1) (1, 2) (2, 3);\r\nINSERT INTO test_final VALUES (2, 3) (5, 4);\r\n\r\nOPTIMIZE TABLE test_final FINAL;\r\n\r\nSET split_parts_ranges_into_intersecting_and_non_intersecting_final = 1;\r\nSET split_intersecting_parts_ranges_into_layers_final = 0;\r\n\r\nSELECT a, b FROM test_final FINAL;\r\n\r\n\r\nReceived exception from server (version 24.12.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Cannot add transform to empty Pipe. (LOGICAL_ERROR)\r\n```\r\n\nCollapsingMergeTree and split_intersecting_parts_ranges\n```sql\r\ncreate table test (\r\n  key Int8,\r\n  sign Int8\r\n) engine = CollapsingMergeTree(sign) order by key;\r\n\r\ninsert into test values (5,-1);\r\n \r\noptimize table test  final; -- to move part to a level 1, to enable optimizations\r\n\r\nselect count() from test final \r\nformat Pretty;\r\n\r\n   +---------+\r\n   | count() |\r\n   +---------+\r\n1. |       1 | -- expected 0 (FROM FINAL should not expose sign = -1)\r\n   +---------+\r\n\r\nselect count() from test final \r\nsettings split_intersecting_parts_ranges_into_layers_final=0,   \r\nsplit_parts_ranges_into_intersecting_and_non_intersecting_final=0\r\nformat Pretty;\r\n\r\n   +---------+\r\n   | count() |\r\n   +---------+\r\n1. |       0 |\r\n   +---------+\r\n```\r\n\r\nhttps://fiddle.clickhouse.com/fa56ffdd-1a68-4e2f-8d0d-dd79b50bd557\r\n\r\n------------\r\n\r\nsplit_intersecting_parts_ranges_into_layers_final = 0 \r\nsplit_parts_ranges_into_intersecting_and_non_intersecting_final = 1\r\n\r\nhttps://fiddle.clickhouse.com/63361a4a-ac7d-4543-87a2-f349fa8e14a6\r\n```\r\nselect count() from test final \r\nsettings split_intersecting_parts_ranges_into_layers_final=0,   \r\nsplit_parts_ranges_into_intersecting_and_non_intersecting_final=1\r\nformat Pretty;\r\n\r\nDB::Exception: Not found column sign in block. There are only columns: . (NOT_FOUND_COLUMN_IN_BLOCK)\r\n```\n",
  "hints_text": "Broken in 23.12 https://fiddle.clickhouse.com/bb270e7c-22e7-47b7-bd2d-79f32311a785\nIn my case setting allow_experimental_analyzer=0 or compatibility='24.2' seems to workaround problem\nSetting `split_parts_ranges_into_intersecting_and_non_intersecting_final=0` helps.\r\nBut the setting was added in 24.2\nGot a similar case with BuzzHouse: https://fiddle.clickhouse.com/26b9ffcc-1df0-4cdf-99ba-a86dd7b9e565\n",
  "created_at": "2024-12-20T13:10:13Z",
  "modified_files": [
    "src/Processors/QueryPlan/PartsSplitter.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03290_final_collapsing.reference",
    "b/tests/queries/0_stateless/03290_final_collapsing.sql",
    "b/tests/queries/0_stateless/03290_final_replacing.reference",
    "b/tests/queries/0_stateless/03290_final_replacing.sql",
    "b/tests/queries/0_stateless/03290_final_sample.reference",
    "b/tests/queries/0_stateless/03290_final_sample.sql"
  ]
}