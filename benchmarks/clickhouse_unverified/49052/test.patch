diff --git a/tests/queries/0_stateless/02722_line_as_string_consistency.reference b/tests/queries/0_stateless/02722_line_as_string_consistency.reference
new file mode 100644
index 000000000000..f71e78457a82
--- /dev/null
+++ b/tests/queries/0_stateless/02722_line_as_string_consistency.reference
@@ -0,0 +1,7 @@
+0D48656C6C6F	9999
+0D	1
+48656C6C6F	1
+---
+0D48656C6C6F	9999
+0D	1
+48656C6C6F	1
diff --git a/tests/queries/0_stateless/02722_line_as_string_consistency.sh b/tests/queries/0_stateless/02722_line_as_string_consistency.sh
new file mode 100755
index 000000000000..be1942a9164a
--- /dev/null
+++ b/tests/queries/0_stateless/02722_line_as_string_consistency.sh
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+# Tags: no-fasttest
+
+CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
+# shellcheck source=../shell_config.sh
+. "$CURDIR"/../shell_config.sh
+
+# The LineAsString format reads every line until the newline character (
).
+# The DOS or MacOS Classic line breaks \r
 or 
\r don't have special support.
+
+# While the behavior described above can be changed in future to add the support for DOS or MacOS Classic,
+# the most important is that it should be exactly the same (consistent)
+# regardless whether the parallel parsing enabled or not,
+# and this test checks that.
+
+for _ in {1..10000}; do echo -ne 'Hello
\r'; done | $CLICKHOUSE_LOCAL --min_chunk_bytes_for_parallel_parsing 1 --input_format_parallel_parsing 0 --query "SELECT hex(*), count() FROM table GROUP BY ALL ORDER BY 2 DESC, 1" --input-format LineAsString
+echo '---'
+for _ in {1..10000}; do echo -ne 'Hello
\r'; done | $CLICKHOUSE_LOCAL --min_chunk_bytes_for_parallel_parsing 1 --input_format_parallel_parsing 1 --query "SELECT hex(*), count() FROM table GROUP BY ALL ORDER BY 2 DESC, 1" --input-format LineAsString
