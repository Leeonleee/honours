{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49052,
  "instance_id": "ClickHouse__ClickHouse-49052",
  "issue_numbers": [
    "49039"
  ],
  "base_commit": "6f5945175c60b1b25ac2ee7504079ee288f160ba",
  "patch": "diff --git a/src/Formats/newLineSegmentationEngine.cpp b/src/Formats/newLineSegmentationEngine.cpp\ndeleted file mode 100644\nindex 5135ca1e13e0..000000000000\n--- a/src/Formats/newLineSegmentationEngine.cpp\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-#include <Formats/newLineSegmentationEngine.h>\n-#include <IO/ReadHelpers.h>\n-#include <base/find_symbols.h>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-}\n-\n-std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)\n-{\n-    char * pos = in.position();\n-    bool need_more_data = true;\n-    size_t number_of_rows = 0;\n-\n-    while (loadAtPosition(in, memory, pos) && need_more_data)\n-    {\n-        pos = find_first_symbols<'\\r', '\\n'>(pos, in.buffer().end());\n-        if (pos > in.buffer().end())\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Position in buffer is out of bounds. There must be a bug.\");\n-        else if (pos == in.buffer().end())\n-            continue;\n-\n-        ++number_of_rows;\n-        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))\n-            need_more_data = false;\n-\n-        if (*pos == '\\n')\n-        {\n-            ++pos;\n-            if (loadAtPosition(in, memory, pos) && *pos == '\\r')\n-                ++pos;\n-        }\n-        else if (*pos == '\\r')\n-        {\n-            ++pos;\n-            if (loadAtPosition(in, memory, pos) && *pos == '\\n')\n-                ++pos;\n-        }\n-    }\n-\n-    saveUpToPosition(in, memory, pos);\n-\n-    return {loadAtPosition(in, memory, pos), number_of_rows};\n-}\n-\n-}\ndiff --git a/src/Formats/newLineSegmentationEngine.h b/src/Formats/newLineSegmentationEngine.h\ndeleted file mode 100644\nindex 598f808b7986..000000000000\n--- a/src/Formats/newLineSegmentationEngine.h\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-#pragma once\n-\n-#include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n-\n-namespace DB\n-{\n-    std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows);\n-}\ndiff --git a/src/Functions/array/arrayAUC.cpp b/src/Functions/array/arrayAUC.cpp\nindex 2890ae55886c..ab7799cc68e3 100644\n--- a/src/Functions/array/arrayAUC.cpp\n+++ b/src/Functions/array/arrayAUC.cpp\n@@ -1,5 +1,4 @@\n #include <algorithm>\n-#include <vector>\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/FunctionFactory.h>\n #include \"arrayScalarProduct.h\"\ndiff --git a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\nindex a86d68c17ff7..2fd87540e7df 100644\n--- a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\n@@ -1,5 +1,4 @@\n #include <Processors/Formats/Impl/LineAsStringRowInputFormat.h>\n-#include <Formats/newLineSegmentationEngine.h>\n #include <base/find_symbols.h>\n #include <IO/ReadHelpers.h>\n #include <Columns/ColumnString.h>\n@@ -11,6 +10,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int INCORRECT_QUERY;\n+    extern const int LOGICAL_ERROR;\n }\n \n LineAsStringRowInputFormat::LineAsStringRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_) :\n@@ -63,9 +63,37 @@ void registerInputFormatLineAsString(FormatFactory & factory)\n     });\n }\n \n+\n+static std::pair<bool, size_t> segmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)\n+{\n+    char * pos = in.position();\n+    bool need_more_data = true;\n+    size_t number_of_rows = 0;\n+\n+    while (loadAtPosition(in, memory, pos) && need_more_data)\n+    {\n+        pos = find_first_symbols<'\\n'>(pos, in.buffer().end());\n+        if (pos > in.buffer().end())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Position in buffer is out of bounds. There must be a bug.\");\n+        else if (pos == in.buffer().end())\n+            continue;\n+\n+        ++number_of_rows;\n+        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))\n+            need_more_data = false;\n+\n+        if (*pos == '\\n')\n+            ++pos;\n+    }\n+\n+    saveUpToPosition(in, memory, pos);\n+\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n+}\n+\n void registerFileSegmentationEngineLineAsString(FormatFactory & factory)\n {\n-    factory.registerFileSegmentationEngine(\"LineAsString\", &newLineFileSegmentationEngine);\n+    factory.registerFileSegmentationEngine(\"LineAsString\", &segmentationEngine);\n }\n \n \ndiff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\nindex 74ce7d7f2acc..d902a8be6a79 100644\n--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n@@ -4,7 +4,6 @@\n #include <DataTypes/Serializations/SerializationNullable.h>\n #include <Formats/EscapingRuleUtils.h>\n #include <Formats/SchemaInferenceUtils.h>\n-#include <Formats/newLineSegmentationEngine.h>\n #include <IO/ReadHelpers.h>\n \n namespace DB\n@@ -180,9 +179,46 @@ void registerInputFormatRegexp(FormatFactory & factory)\n     });\n }\n \n+static std::pair<bool, size_t> segmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)\n+{\n+    char * pos = in.position();\n+    bool need_more_data = true;\n+    size_t number_of_rows = 0;\n+\n+    while (loadAtPosition(in, memory, pos) && need_more_data)\n+    {\n+        pos = find_first_symbols<'\\r', '\\n'>(pos, in.buffer().end());\n+        if (pos > in.buffer().end())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Position in buffer is out of bounds. There must be a bug.\");\n+        else if (pos == in.buffer().end())\n+            continue;\n+\n+        ++number_of_rows;\n+        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))\n+            need_more_data = false;\n+\n+        if (*pos == '\\n')\n+        {\n+            ++pos;\n+            if (loadAtPosition(in, memory, pos) && *pos == '\\r')\n+                ++pos;\n+        }\n+        else if (*pos == '\\r')\n+        {\n+            ++pos;\n+            if (loadAtPosition(in, memory, pos) && *pos == '\\n')\n+                ++pos;\n+        }\n+    }\n+\n+    saveUpToPosition(in, memory, pos);\n+\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n+}\n+\n void registerFileSegmentationEngineRegexp(FormatFactory & factory)\n {\n-    factory.registerFileSegmentationEngine(\"Regexp\", &newLineFileSegmentationEngine);\n+    factory.registerFileSegmentationEngine(\"Regexp\", &segmentationEngine);\n }\n \n void registerRegexpSchemaReader(FormatFactory & factory)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02722_line_as_string_consistency.reference b/tests/queries/0_stateless/02722_line_as_string_consistency.reference\nnew file mode 100644\nindex 000000000000..f71e78457a82\n--- /dev/null\n+++ b/tests/queries/0_stateless/02722_line_as_string_consistency.reference\n@@ -0,0 +1,7 @@\n+0D48656C6C6F\t9999\n+0D\t1\n+48656C6C6F\t1\n+---\n+0D48656C6C6F\t9999\n+0D\t1\n+48656C6C6F\t1\ndiff --git a/tests/queries/0_stateless/02722_line_as_string_consistency.sh b/tests/queries/0_stateless/02722_line_as_string_consistency.sh\nnew file mode 100755\nindex 000000000000..be1942a9164a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02722_line_as_string_consistency.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# The LineAsString format reads every line until the newline character (\\n).\n+# The DOS or MacOS Classic line breaks \\r\\n or \\n\\r don't have special support.\n+\n+# While the behavior described above can be changed in future to add the support for DOS or MacOS Classic,\n+# the most important is that it should be exactly the same (consistent)\n+# regardless whether the parallel parsing enabled or not,\n+# and this test checks that.\n+\n+for _ in {1..10000}; do echo -ne 'Hello\\n\\r'; done | $CLICKHOUSE_LOCAL --min_chunk_bytes_for_parallel_parsing 1 --input_format_parallel_parsing 0 --query \"SELECT hex(*), count() FROM table GROUP BY ALL ORDER BY 2 DESC, 1\" --input-format LineAsString\n+echo '---'\n+for _ in {1..10000}; do echo -ne 'Hello\\n\\r'; done | $CLICKHOUSE_LOCAL --min_chunk_bytes_for_parallel_parsing 1 --input_format_parallel_parsing 1 --query \"SELECT hex(*), count() FROM table GROUP BY ALL ORDER BY 2 DESC, 1\" --input-format LineAsString\n",
  "problem_statement": "Regexp and LineAsString are using the same segmentation engine, but the behavior is different with respect to `\\r` characters\n\n",
  "hints_text": "```\r\n$ while true; do echo -ne \"Hello\\n\\r\"; done | clickhouse-local --query \"SELECT DISTINCT hex(*) FROM table\" --input-format LineAsString\r\n0D\r\n48656C6C6F\r\n0D48656C6C6F\r\n```",
  "created_at": "2023-04-23T03:52:05Z",
  "modified_files": [
    "src/Formats/newLineSegmentationEngine.cpp",
    "src/Formats/newLineSegmentationEngine.h",
    "src/Functions/array/arrayAUC.cpp",
    "src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp",
    "src/Processors/Formats/Impl/RegexpRowInputFormat.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02722_line_as_string_consistency.reference",
    "b/tests/queries/0_stateless/02722_line_as_string_consistency.sh"
  ]
}