diff --git a/src/Formats/newLineSegmentationEngine.cpp b/src/Formats/newLineSegmentationEngine.cpp
deleted file mode 100644
index 5135ca1e13e0..000000000000
--- a/src/Formats/newLineSegmentationEngine.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <Formats/newLineSegmentationEngine.h>
-#include <IO/ReadHelpers.h>
-#include <base/find_symbols.h>
-
-namespace DB
-{
-
-namespace ErrorCodes
-{
-    extern const int LOGICAL_ERROR;
-}
-
-std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)
-{
-    char * pos = in.position();
-    bool need_more_data = true;
-    size_t number_of_rows = 0;
-
-    while (loadAtPosition(in, memory, pos) && need_more_data)
-    {
-        pos = find_first_symbols<'\r', '
'>(pos, in.buffer().end());
-        if (pos > in.buffer().end())
-            throw Exception(ErrorCodes::LOGICAL_ERROR, "Position in buffer is out of bounds. There must be a bug.");
-        else if (pos == in.buffer().end())
-            continue;
-
-        ++number_of_rows;
-        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))
-            need_more_data = false;
-
-        if (*pos == '
')
-        {
-            ++pos;
-            if (loadAtPosition(in, memory, pos) && *pos == '\r')
-                ++pos;
-        }
-        else if (*pos == '\r')
-        {
-            ++pos;
-            if (loadAtPosition(in, memory, pos) && *pos == '
')
-                ++pos;
-        }
-    }
-
-    saveUpToPosition(in, memory, pos);
-
-    return {loadAtPosition(in, memory, pos), number_of_rows};
-}
-
-}
diff --git a/src/Formats/newLineSegmentationEngine.h b/src/Formats/newLineSegmentationEngine.h
deleted file mode 100644
index 598f808b7986..000000000000
--- a/src/Formats/newLineSegmentationEngine.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#pragma once
-
-#include <IO/ReadBuffer.h>
-#include <IO/BufferWithOwnMemory.h>
-
-namespace DB
-{
-    std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows);
-}
diff --git a/src/Functions/array/arrayAUC.cpp b/src/Functions/array/arrayAUC.cpp
index 2890ae55886c..ab7799cc68e3 100644
--- a/src/Functions/array/arrayAUC.cpp
+++ b/src/Functions/array/arrayAUC.cpp
@@ -1,5 +1,4 @@
 #include <algorithm>
-#include <vector>
 #include <DataTypes/DataTypesNumber.h>
 #include <Functions/FunctionFactory.h>
 #include "arrayScalarProduct.h"
diff --git a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp
index a86d68c17ff7..2fd87540e7df 100644
--- a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp
@@ -1,5 +1,4 @@
 #include <Processors/Formats/Impl/LineAsStringRowInputFormat.h>
-#include <Formats/newLineSegmentationEngine.h>
 #include <base/find_symbols.h>
 #include <IO/ReadHelpers.h>
 #include <Columns/ColumnString.h>
@@ -11,6 +10,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int INCORRECT_QUERY;
+    extern const int LOGICAL_ERROR;
 }
 
 LineAsStringRowInputFormat::LineAsStringRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_) :
@@ -63,9 +63,37 @@ void registerInputFormatLineAsString(FormatFactory & factory)
     });
 }
 
+
+static std::pair<bool, size_t> segmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)
+{
+    char * pos = in.position();
+    bool need_more_data = true;
+    size_t number_of_rows = 0;
+
+    while (loadAtPosition(in, memory, pos) && need_more_data)
+    {
+        pos = find_first_symbols<'
'>(pos, in.buffer().end());
+        if (pos > in.buffer().end())
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Position in buffer is out of bounds. There must be a bug.");
+        else if (pos == in.buffer().end())
+            continue;
+
+        ++number_of_rows;
+        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))
+            need_more_data = false;
+
+        if (*pos == '
')
+            ++pos;
+    }
+
+    saveUpToPosition(in, memory, pos);
+
+    return {loadAtPosition(in, memory, pos), number_of_rows};
+}
+
 void registerFileSegmentationEngineLineAsString(FormatFactory & factory)
 {
-    factory.registerFileSegmentationEngine("LineAsString", &newLineFileSegmentationEngine);
+    factory.registerFileSegmentationEngine("LineAsString", &segmentationEngine);
 }
 
 
diff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp
index 74ce7d7f2acc..d902a8be6a79 100644
--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp
@@ -4,7 +4,6 @@
 #include <DataTypes/Serializations/SerializationNullable.h>
 #include <Formats/EscapingRuleUtils.h>
 #include <Formats/SchemaInferenceUtils.h>
-#include <Formats/newLineSegmentationEngine.h>
 #include <IO/ReadHelpers.h>
 
 namespace DB
@@ -180,9 +179,46 @@ void registerInputFormatRegexp(FormatFactory & factory)
     });
 }
 
+static std::pair<bool, size_t> segmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)
+{
+    char * pos = in.position();
+    bool need_more_data = true;
+    size_t number_of_rows = 0;
+
+    while (loadAtPosition(in, memory, pos) && need_more_data)
+    {
+        pos = find_first_symbols<'\r', '
'>(pos, in.buffer().end());
+        if (pos > in.buffer().end())
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Position in buffer is out of bounds. There must be a bug.");
+        else if (pos == in.buffer().end())
+            continue;
+
+        ++number_of_rows;
+        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))
+            need_more_data = false;
+
+        if (*pos == '
')
+        {
+            ++pos;
+            if (loadAtPosition(in, memory, pos) && *pos == '\r')
+                ++pos;
+        }
+        else if (*pos == '\r')
+        {
+            ++pos;
+            if (loadAtPosition(in, memory, pos) && *pos == '
')
+                ++pos;
+        }
+    }
+
+    saveUpToPosition(in, memory, pos);
+
+    return {loadAtPosition(in, memory, pos), number_of_rows};
+}
+
 void registerFileSegmentationEngineRegexp(FormatFactory & factory)
 {
-    factory.registerFileSegmentationEngine("Regexp", &newLineFileSegmentationEngine);
+    factory.registerFileSegmentationEngine("Regexp", &segmentationEngine);
 }
 
 void registerRegexpSchemaReader(FormatFactory & factory)
