diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp
index b6e1a66252bf..cc8a76d55ba2 100644
--- a/src/Analyzer/QueryNode.cpp
+++ b/src/Analyzer/QueryNode.cpp
@@ -1,3 +1,4 @@
+#include <memory>
 #include <Analyzer/QueryNode.h>
 
 #include <fmt/core.h>
@@ -34,6 +35,7 @@ namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
     extern const int BAD_ARGUMENTS;
+    extern const int UNSUPPORTED_METHOD;
 }
 
 QueryNode::QueryNode(ContextMutablePtr context_, SettingsChanges settings_changes_)
@@ -135,6 +137,22 @@ void QueryNode::addCorrelatedColumn(const QueryTreeNodePtr & correlated_column)
     correlated_columns.push_back(correlated_column);
 }
 
+DataTypePtr QueryNode::getResultType() const
+{
+    if (isCorrelated())
+    {
+        if (projection_columns.size() == 1)
+        {
+            return projection_columns[0].type;
+        }
+        else
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+                "Method getResultType is supported only for correlated query node with 1 column, but got {}",
+                projection_columns.size());
+    }
+    throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Method getResultType is supported only for correlated query node");
+}
+
 void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const
 {
     buffer << std::string(indent, ' ') << "QUERY id: " << format_state.getNodeId(this);
diff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h
index 15f7aef675ca..77c192bddd35 100644
--- a/src/Analyzer/QueryNode.h
+++ b/src/Analyzer/QueryNode.h
@@ -647,6 +647,10 @@ class QueryNode final : public IQueryTreeNode
 
     void addCorrelatedColumn(const QueryTreeNodePtr & correlated_column);
 
+    /// Returns result type of projection expression if query is correlated
+    /// or throws an exception otherwise.
+    DataTypePtr getResultType() const override;
+
     QueryTreeNodeType getNodeType() const override
     {
         return QueryTreeNodeType::QUERY;
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index d3177ba4af3c..64a649475ffe 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -547,6 +547,11 @@ void QueryAnalyzer::evaluateScalarSubqueryIfNeeded(QueryTreeNodePtr & node, Iden
             node->getNodeTypeName(),
             node->formatASTForErrorMessage());
 
+    bool is_correlated_subquery = (query_node != nullptr && query_node->isCorrelated())
+                                || (union_node != nullptr && union_node->isCorrelated());
+    if (is_correlated_subquery)
+        throw Exception(ErrorCodes::BAD_ARGUMENTS, "Cannot evaluate correlated scalar subquery");
+
     auto & context = scope.context;
 
     Block scalar_block;
@@ -2533,7 +2538,8 @@ ProjectionName QueryAnalyzer::resolveWindow(QueryTreeNodePtr & node, IdentifierR
     auto & window_node = node->as<WindowNode &>();
     window_node.setParentWindowName({});
 
-    ProjectionNames partition_by_projection_names = resolveExpressionNodeList(window_node.getPartitionByNode(),
+    ProjectionNames partition_by_projection_names = resolveExpressionNodeList(
+        window_node.getPartitionByNode(),
         scope,
         false /*allow_lambda_expression*/,
         false /*allow_table_expression*/);
@@ -2743,7 +2749,8 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
 
     /// Resolve function parameters
 
-    auto parameters_projection_names = resolveExpressionNodeList(function_node_ptr->getParametersNode(),
+    auto parameters_projection_names = resolveExpressionNodeList(
+        function_node_ptr->getParametersNode(),
         scope,
         false /*allow_lambda_expression*/,
         false /*allow_table_expression*/);
@@ -2924,7 +2931,8 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
 
     /// Resolve function arguments
     bool allow_table_expressions = is_special_function_in || is_special_function_exists;
-    auto arguments_projection_names = resolveExpressionNodeList(function_node_ptr->getArgumentsNode(),
+    auto arguments_projection_names = resolveExpressionNodeList(
+        function_node_ptr->getArgumentsNode(),
         scope,
         true /*allow_lambda_expression*/,
         allow_table_expressions /*allow_table_expression*/);
@@ -3929,7 +3937,11 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
             else
                 resolveUnion(node, subquery_scope);
 
-            if (!allow_table_expression)
+            bool is_correlated_subquery = node_type == QueryTreeNodeType::QUERY
+                ? node->as<QueryNode>()->isCorrelated()
+                : node->as<UnionNode>()->isCorrelated();
+
+            if (!allow_table_expression && !is_correlated_subquery)
                 evaluateScalarSubqueryIfNeeded(node, subquery_scope);
 
             if (result_projection_names.empty())
@@ -4022,7 +4034,12 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
   * Example: CREATE TABLE test_table (id UInt64, value UInt64) ENGINE=TinyLog; SELECT plus(*) FROM test_table;
   * Example: SELECT *** FROM system.one;
   */
-ProjectionNames QueryAnalyzer::resolveExpressionNodeList(QueryTreeNodePtr & node_list, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression)
+ProjectionNames QueryAnalyzer::resolveExpressionNodeList(
+    QueryTreeNodePtr & node_list,
+    IdentifierResolveScope & scope,
+    bool allow_lambda_expression,
+    bool allow_table_expression
+)
 {
     auto & node_list_typed = node_list->as<ListNode &>();
     size_t node_list_size = node_list_typed.getNodes().size();
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index 113573e23e66..ebbf90e6fb0f 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -5529,10 +5529,10 @@ void Context::setGoogleProtosPath(const String & path)
     shared->google_protos_path = path;
 }
 
-Context::SampleBlockCache & Context::getSampleBlockCache() const
+std::pair<Context::SampleBlockCache *, std::unique_lock<std::mutex>> Context::getSampleBlockCache() const
 {
     assert(hasQueryContext());
-    return getQueryContext()->sample_block_cache;
+    return std::make_pair(&getQueryContext()->sample_block_cache, std::unique_lock(getQueryContext()->sample_block_cache_mutex));
 }
 
 
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index 11e64bf16cf1..7a54d965a885 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -534,6 +534,7 @@ class ContextData
 protected:
     using SampleBlockCache = std::unordered_map<std::string, Block>;
     mutable SampleBlockCache sample_block_cache;
+    mutable std::mutex sample_block_cache_mutex;
 
     PartUUIDsPtr part_uuids; /// set of parts' uuids, is used for query parts deduplication
     PartUUIDsPtr ignored_part_uuids; /// set of parts' uuids are meant to be excluded from query processing
@@ -1405,7 +1406,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>
     String getGoogleProtosPath() const;
     void setGoogleProtosPath(const String & path);
 
-    SampleBlockCache & getSampleBlockCache() const;
+    std::pair<Context::SampleBlockCache *, std::unique_lock<std::mutex>> getSampleBlockCache() const;
 
     /// Query parameters for prepared statements.
     bool hasQueryParameters() const;
diff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
index 0dc5209d670f..3dc0a8736d76 100644
--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
@@ -283,12 +283,12 @@ Block InterpreterSelectWithUnionQuery::getSampleBlock(const ASTPtr & query_ptr_,
         return InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();
     }
 
-    auto & cache = context_->getSampleBlockCache();
     /// Using query string because query_ptr changes for every internal SELECT
     auto key = query_ptr_->formatWithSecretsOneLine();
-    if (cache.find(key) != cache.end())
     {
-        return cache[key];
+        auto [cache, lock] = context_->getSampleBlockCache();
+        if (cache->find(key) != cache->end())
+            return cache->at(key);
     }
 
     SelectQueryOptions options;
@@ -296,7 +296,10 @@ Block InterpreterSelectWithUnionQuery::getSampleBlock(const ASTPtr & query_ptr_,
         options = options.subquery();
     if (is_create_parameterized_view)
         options = options.createParameterizedView();
-    return cache[key] = InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();
+
+    auto sample_block = InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();
+    auto [cache, lock] = context_->getSampleBlockCache();
+    return (*cache)[key] = sample_block;
 }
 
 
diff --git a/src/Interpreters/JoinInfo.cpp b/src/Interpreters/JoinInfo.cpp
index 05ca14b6cb50..44e137057df5 100644
--- a/src/Interpreters/JoinInfo.cpp
+++ b/src/Interpreters/JoinInfo.cpp
@@ -356,6 +356,16 @@ JoinActionRef JoinActionRef::deserialize(ReadBuffer & in, const ActionsDAGRawPtr
     return res;
 }
 
+JoinActionRef JoinActionRef::clone(const ActionsDAG * actions_dag_) const
+{
+    return JoinActionRef{actions_dag_, column_name};
+}
+
+JoinActionRef::JoinActionRef(const ActionsDAG * actions_dag_, const String & column_name_)
+    : actions_dag(actions_dag_)
+    , column_name(column_name_)
+{}
+
 void JoinPredicate::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const
 {
     serializePredicateOperator(op, out);
@@ -435,6 +445,40 @@ JoinCondition JoinCondition::deserialize(ReadBuffer & in, const JoinActionRef::A
     };
 }
 
+JoinCondition JoinCondition::clone(const JoinExpressionActions & expression_actions) const
+{
+    JoinCondition copy;
+
+    copy.predicates.reserve(predicates.size());
+    for (const auto & predicate : predicates)
+    {
+        copy.predicates.emplace_back(
+            predicate.left_node.clone(expression_actions.left_pre_join_actions.get()),
+            predicate.right_node.clone(expression_actions.right_pre_join_actions.get()),
+            predicate.op);
+    }
+
+    copy.left_filter_conditions.reserve(left_filter_conditions.size());
+    for (const auto & condition: left_filter_conditions)
+    {
+        copy.left_filter_conditions.emplace_back(condition.clone(expression_actions.left_pre_join_actions.get()));
+    }
+
+    copy.right_filter_conditions.reserve(right_filter_conditions.size());
+    for (const auto & condition: right_filter_conditions)
+    {
+        copy.right_filter_conditions.emplace_back(condition.clone(expression_actions.right_pre_join_actions.get()));
+    }
+
+    copy.residual_conditions.reserve(residual_conditions.size());
+    for (const auto & condition: residual_conditions)
+    {
+        copy.residual_conditions.emplace_back(condition.clone(expression_actions.post_join_actions.get()));
+    }
+
+    return copy;
+}
+
 void JoinExpression::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const
 {
     UInt8 is_using_flag = is_using ? 1 : 0;
@@ -473,6 +517,20 @@ JoinExpression JoinExpression::deserialize(ReadBuffer & in, const JoinActionRef:
     return {std::move(condition), std::move(disjunctive_conditions), bool(is_using_flag)};
 }
 
+JoinExpression JoinExpression::clone(const JoinExpressionActions & expression_copy) const
+{
+    JoinExpression copy;
+    copy.condition = condition.clone(expression_copy);
+
+    copy.disjunctive_conditions.reserve(disjunctive_conditions.size());
+    for (const auto & disjunctive_condition : disjunctive_conditions)
+        copy.disjunctive_conditions.emplace_back(disjunctive_condition.clone(expression_copy));
+
+    copy.is_using = is_using;
+
+    return copy;
+}
+
 void JoinInfo::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const
 {
     expression.serialize(out, dags);
diff --git a/src/Interpreters/JoinInfo.h b/src/Interpreters/JoinInfo.h
index 6d39893041f4..072c3bf6ac36 100644
--- a/src/Interpreters/JoinInfo.h
+++ b/src/Interpreters/JoinInfo.h
@@ -75,6 +75,20 @@ struct JoinExpressionActions
     {
     }
 
+    JoinExpressionActions clone() const
+    {
+        return  JoinExpressionActions(
+            std::make_unique<ActionsDAG>(left_pre_join_actions->clone()),
+            std::make_unique<ActionsDAG>(right_pre_join_actions->clone()),
+            std::make_unique<ActionsDAG>(post_join_actions->clone())
+        );
+    }
+
+    bool hasCorrelatedExpressions() const noexcept
+    {
+        return left_pre_join_actions->hasCorrelatedColumns() || right_pre_join_actions->hasCorrelatedColumns() || post_join_actions->hasCorrelatedColumns();
+    }
+
     ActionsDAGPtr left_pre_join_actions;
     ActionsDAGPtr right_pre_join_actions;
     ActionsDAGPtr post_join_actions;
@@ -103,7 +117,11 @@ class JoinActionRef
     void serialize(WriteBuffer & out, const ActionsDAGRawPtrs & dags) const;
     static JoinActionRef deserialize(ReadBuffer & in, const ActionsDAGRawPtrs & dags);
 
+    JoinActionRef clone(const ActionsDAG * actions_dag_) const;
+
 private:
+    JoinActionRef(const ActionsDAG * actions_dag_, const String & column_name_);
+
     const ActionsDAG * actions_dag = nullptr;
     String column_name;
 };
@@ -136,6 +154,8 @@ struct JoinCondition
 
     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;
     static JoinCondition deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);
+
+    JoinCondition clone(const JoinExpressionActions & expression_actions) const;
 };
 
 struct JoinExpression
@@ -154,6 +174,8 @@ struct JoinExpression
 
     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;
     static JoinExpression deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);
+
+    JoinExpression clone(const JoinExpressionActions & expression_copy) const;
 };
 
 struct JoinInfo
@@ -170,6 +192,11 @@ struct JoinInfo
     /// The locality of the join (e.g., LOCAL, GLOBAL)
     JoinLocality locality;
 
+    JoinInfo clone(const JoinExpressionActions & expression_actions) const
+    {
+        return JoinInfo{ expression.clone(expression_actions), kind, strictness, locality};
+    }
+
     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;
     static JoinInfo deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);
 };
diff --git a/src/Planner/CollectColumnIdentifiers.cpp b/src/Planner/CollectColumnIdentifiers.cpp
index 373d5797bada..aab77244baff 100644
--- a/src/Planner/CollectColumnIdentifiers.cpp
+++ b/src/Planner/CollectColumnIdentifiers.cpp
@@ -1,7 +1,11 @@
 #include <Planner/CollectColumnIdentifiers.h>
 
-#include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/ColumnNode.h>
+#include <Analyzer/FunctionNode.h>
+#include <Analyzer/InDepthQueryTreeVisitor.h>
+#include <Analyzer/QueryNode.h>
+#include <Analyzer/UnionNode.h>
+#include <Analyzer/Utils.h>
 
 #include <Planner/PlannerContext.h>
 
@@ -35,6 +39,30 @@ class CollectTopLevelColumnIdentifiersVisitor : public ConstInDepthQueryTreeVisi
 
     void visitImpl(const QueryTreeNodePtr & node)
     {
+        if (node->getNodeType() == QueryTreeNodeType::FUNCTION)
+        {
+            auto * function_node = node->as<FunctionNode>();
+            for (const auto & argument : function_node->getArguments().getNodes())
+            {
+                if (!isCorrelatedQueryOrUnionNode(argument))
+                    continue;
+
+                auto * query_node = argument->as<QueryNode>();
+                auto * union_node = argument->as<UnionNode>();
+
+                const auto & correlated_columns = query_node != nullptr ? query_node->getCorrelatedColumns() : union_node->getCorrelatedColumns();
+                for (const auto & column : correlated_columns)
+                {
+                    const auto * column_identifier = planner_context->getColumnNodeIdentifierOrNull(column);
+                    if (!column_identifier)
+                        return;
+
+                    used_identifiers.insert(*column_identifier);
+                }
+            }
+            return;
+        }
+
         if (node->getNodeType() != QueryTreeNodeType::COLUMN)
             return;
 
diff --git a/src/Planner/CollectTableExpressionData.cpp b/src/Planner/CollectTableExpressionData.cpp
index 9218a5b35e20..8c11e17cdcb8 100644
--- a/src/Planner/CollectTableExpressionData.cpp
+++ b/src/Planner/CollectTableExpressionData.cpp
@@ -47,21 +47,25 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co
             return;
         }
 
-        if (isExistsFunction(node))
+        if (auto * function_node = node->as<FunctionNode>())
         {
             /// Add used in correlated subquery columns to the table expression data.
             /// These columns can be used only by correlated subquery, but still they
             /// must be read by query plan for current query.
             ///
             /// Example: SELECT 1 FROM table as t WHERE EXISTS (SELECT * FROM numbers(10) WHERE t.id = number);
-            auto * function_node = node->as<FunctionNode>();
-            const auto & subquery_argument = function_node->getArguments().getNodes().front();
-            auto * query_node = subquery_argument->as<QueryNode>();
-            auto * union_node = subquery_argument->as<UnionNode>();
-            chassert(query_node != nullptr || union_node != nullptr);
-
-            auto & correlated_columns = query_node ? query_node->getCorrelatedColumnsNode() : union_node->getCorrelatedColumnsNode();
-            visit(correlated_columns);
+            for (const auto & argument : function_node->getArguments().getNodes())
+            {
+                if (!isCorrelatedQueryOrUnionNode(argument))
+                    continue;
+
+                auto * query_node = argument->as<QueryNode>();
+                auto * union_node = argument->as<UnionNode>();
+                chassert(query_node != nullptr || union_node != nullptr);
+
+                auto & correlated_columns = query_node ? query_node->getCorrelatedColumnsNode() : union_node->getCorrelatedColumnsNode();
+                visit(correlated_columns);
+            }
             return;
         }
 
@@ -205,11 +209,6 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co
         return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == "indexHint";
     }
 
-    static bool isExistsFunction(const QueryTreeNodePtr & node)
-    {
-        return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == "exists";
-    }
-
     static bool isColumnSourceMergeTree(const ColumnNode & node)
     {
         const auto * source_table = node.getColumnSource()->as<TableNode>();
diff --git a/src/Planner/PlannerActionsVisitor.cpp b/src/Planner/PlannerActionsVisitor.cpp
index 28b3cd477aac..ab068989fee3 100644
--- a/src/Planner/PlannerActionsVisitor.cpp
+++ b/src/Planner/PlannerActionsVisitor.cpp
@@ -15,12 +15,12 @@
 #include <Analyzer/Utils.h>
 #include <Analyzer/WindowNode.h>
 
-#include <DataTypes/FieldToDataType.h>
 #include <DataTypes/DataTypeSet.h>
+#include <DataTypes/DataTypeTuple.h>
+#include <DataTypes/FieldToDataType.h>
 
 #include <Common/FieldVisitorToString.h>
 #include <Common/quoteString.h>
-#include <DataTypes/DataTypeTuple.h>
 
 #include <Columns/ColumnSet.h>
 #include <Columns/ColumnConst.h>
@@ -334,6 +334,18 @@ class ActionNodeNameHelper
                 result = buffer.str();
                 break;
             }
+            case QueryTreeNodeType::QUERY:
+            {
+                auto & query_node = node->as<QueryNode &>();
+                if (query_node.isCorrelated())
+                    result = query_node.getAlias();
+                else
+                    throw Exception(
+                        ErrorCodes::LOGICAL_ERROR,
+                        "Only correlated QueryNode can be used as action query tree node, but got {}",
+                        node->formatASTForErrorMessage());
+                break;
+            }
             default:
             {
                 throw Exception(ErrorCodes::LOGICAL_ERROR, "Invalid action query tree node {}", node->formatASTForErrorMessage());
@@ -661,6 +673,8 @@ class PlannerActionsVisitorImpl
 
     NodeNameAndNodeMinLevel visitFunction(const QueryTreeNodePtr & node);
 
+    NodeNameAndNodeMinLevel visitQuery(const QueryTreeNodePtr & node);
+
     std::vector<ActionsScopeNode> actions_stack;
     std::unordered_map<QueryTreeNodePtr, std::string> node_to_node_name;
     CorrelatedSubtrees correlated_subtrees;
@@ -709,16 +723,21 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi
 {
     auto node_type = node->getNodeType();
 
-    if (node_type == QueryTreeNodeType::COLUMN)
+    switch (node_type)
+    {
+    case QueryTreeNodeType::COLUMN:
         return visitColumn(node);
-    if (node_type == QueryTreeNodeType::CONSTANT)
+    case QueryTreeNodeType::CONSTANT:
         return visitConstant(node);
-    if (node_type == QueryTreeNodeType::FUNCTION)
+    case QueryTreeNodeType::FUNCTION:
         return visitFunction(node);
-
-    throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
-        "Expected column, constant, function. Actual {} with type: {}",
-        node->formatASTForErrorMessage(), node_type);
+    case QueryTreeNodeType::QUERY:
+        return visitQuery(node);
+    default:
+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+            "Expected column, constant, function. Actual {} with type: {}",
+            node->formatASTForErrorMessage(), node_type);
+    }
 }
 
 PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitColumn(const QueryTreeNodePtr & node)
@@ -1138,6 +1157,44 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi
     return {function_node_name, levels};
 }
 
+PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitQuery(const QueryTreeNodePtr & node)
+{
+    auto & query_node = node->as<QueryNode &>();
+    if (!query_node.isCorrelated())
+        throw Exception(
+            ErrorCodes::LOGICAL_ERROR,
+            "Only correlated QueryNode can be used as an action node, but got: {}",
+            node->formatASTForErrorMessage());
+
+    Levels levels(0);
+
+    auto correlated_subquery_name = action_node_name_helper.calculateActionNodeName(node);
+
+    size_t actions_stack_size = actions_stack.size();
+    for (size_t i = 0; i < actions_stack_size; ++i)
+    {
+        auto & actions_stack_node = actions_stack[i];
+        actions_stack_node.addInputColumnIfNecessary(correlated_subquery_name, query_node.getResultType());
+    }
+
+    const auto & correlated_columns = query_node.getCorrelatedColumns().getNodes();
+
+    ColumnIdentifiers correlated_column_identifiers;
+    correlated_column_identifiers.reserve(correlated_columns.size());
+    for (const auto & column : correlated_columns)
+    {
+        correlated_column_identifiers.push_back(action_node_name_helper.calculateActionNodeName(column));
+    }
+
+    correlated_subtrees.subqueries.emplace_back(
+        node,
+        CorrelatedSubqueryKind::SCALAR,
+        correlated_subquery_name,
+        std::move(correlated_column_identifiers));
+
+    return { correlated_subquery_name, levels };
+}
+
 }
 
 PlannerActionsVisitor::PlannerActionsVisitor(
diff --git a/src/Planner/PlannerCorrelatedSubqueries.cpp b/src/Planner/PlannerCorrelatedSubqueries.cpp
index b178e162eed6..53adff4541ca 100644
--- a/src/Planner/PlannerCorrelatedSubqueries.cpp
+++ b/src/Planner/PlannerCorrelatedSubqueries.cpp
@@ -39,6 +39,7 @@ namespace ErrorCodes
 {
 
 extern const int NOT_IMPLEMENTED;
+extern const int LOGICAL_ERROR;
 
 }
 
@@ -99,6 +100,7 @@ CorrelatedPlanStepMap buildCorrelatedPlanStepMap(QueryPlan & correlated_query_pl
 
 struct DecorrelationContext
 {
+    const CorrelatedSubquery & correlated_subquery;
     const PlannerContextPtr & planner_context;
     QueryPlan query_plan; // LHS plan
     QueryPlan correlated_query_plan;
@@ -216,10 +218,73 @@ QueryPlan decorrelateQueryPlan(
 
         return result_plan;
     }
+    if (auto * aggeregating_step = typeid_cast<AggregatingStep *>(node->step.get()))
+    {
+        auto decorrelated_query_plan = decorrelateQueryPlan(context, node->children.front());
+        auto input_header = decorrelated_query_plan.getCurrentHeader();
+
+        if (aggeregating_step->isGroupingSets())
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Decorrelation of GROUP BY GROUPING SETS is not supported yet");
+
+        auto new_aggregator_params = aggeregating_step->getAggregatorParameters();
+
+        for (const auto & correlated_column_identifier : context.correlated_subquery.correlated_column_identifiers)
+        {
+            new_aggregator_params.keys.push_back(correlated_column_identifier);
+        }
+        new_aggregator_params.keys_size = new_aggregator_params.keys.size();
+
+        auto result_step = std::make_unique<AggregatingStep>(
+            std::move(input_header),
+            std::move(new_aggregator_params),
+            aggeregating_step->getGroupingSetsParamsList(),
+            aggeregating_step->getFinal(),
+            aggeregating_step->getMaxBlockSize(),
+            aggeregating_step->getMaxBlockSizeForAggregationInOrder(),
+            aggeregating_step->getMergeThreads(),
+            aggeregating_step->getTemporaryDataMergeThreads(),
+            false /*storage_has_evenly_distributed_read_*/,
+            aggeregating_step->isGroupByUseNulls(),
+            SortDescription{} /*sort_description_for_merging_*/,
+            SortDescription{} /*group_by_sort_description_*/,
+            aggeregating_step->shouldProduceResultsInBucketOrder(),
+            aggeregating_step->usingMemoryBoundMerging(),
+            aggeregating_step->explicitSortingRequired()
+        );
+        result_step->setStepDescription(aggeregating_step->getStepDescription());
+
+        decorrelated_query_plan.addStep(std::move(result_step));
+
+        return decorrelated_query_plan;
+    }
     throw Exception(
         ErrorCodes::NOT_IMPLEMENTED,
         "Cannot decorrelate query, because '{}' step is not supported",
-        node->step->getStepDescription());
+        node->step->getName());
+}
+
+void buildRenamingForScalarSubquery(
+    QueryPlan & query_plan,
+    const CorrelatedSubquery & correlated_subquery
+)
+{
+    ActionsDAG dag(query_plan.getCurrentHeader().getNamesAndTypesList());
+    const auto * result_node = &dag.findInOutputs(correlated_subquery.action_node_name);
+
+    ActionsDAG::NodeRawConstPtrs new_outputs{ result_node };
+    new_outputs.reserve(correlated_subquery.correlated_column_identifiers.size() + 1);
+
+    for (const auto & column_name : correlated_subquery.correlated_column_identifiers)
+    {
+        new_outputs.push_back(&dag.addAlias(dag.findInOutputs(column_name), fmt::format("{}.{}", correlated_subquery.action_node_name, column_name)));
+    }
+    new_outputs.push_back(result_node);
+
+    dag.getOutputs() = std::move(new_outputs);
+
+    auto expression_step = std::make_unique<ExpressionStep>(query_plan.getCurrentHeader(), std::move(dag));
+    expression_step->setStepDescription("Create renaming actions for scalar subquery");
+    query_plan.addStep(std::move(expression_step));
 }
 
 void buildExistsResultExpression(
@@ -364,6 +429,61 @@ QueryPlan buildLogicalJoin(
     return result_plan;
 }
 
+Planner buildPlannerForCorrelatedSubquery(
+    const PlannerContextPtr & planner_context,
+    const CorrelatedSubquery & correlated_subquery,
+    const SelectQueryOptions & select_query_options
+)
+{
+    auto subquery_options = select_query_options.subquery();
+    auto global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});
+    /// Register table expression data for correlated columns sources in the global context.
+    /// Table expression data would be reused because it can't be initialized
+    /// during plan construction for correlated subquery.
+    global_planner_context->collectTableExpressionDataForCorrelatedColumns(correlated_subquery.query_tree, planner_context);
+
+    Planner subquery_planner(
+        correlated_subquery.query_tree,
+        subquery_options,
+        std::move(global_planner_context));
+    subquery_planner.buildQueryPlanIfNeeded();
+
+    return subquery_planner;
+}
+
+void addStepForResultRenaming(
+    const CorrelatedSubquery & correlated_subquery,
+    QueryPlan & correlated_subquery_plan
+)
+{
+    const auto & header = correlated_subquery_plan.getCurrentHeader();
+    const auto & subquery_result_columns = header.getColumnsWithTypeAndName();
+
+    if (subquery_result_columns.size() != 1)
+        throw Exception(
+            ErrorCodes::LOGICAL_ERROR,
+            "Expected to get only 1 result column of correlated subquery, but got {}",
+            subquery_result_columns.size());
+
+    const auto & result_column = subquery_result_columns[0];
+    auto expected_result_type = correlated_subquery.query_tree->getResultType();
+    if (!expected_result_type->equals(*result_column.type))
+        throw Exception(
+            ErrorCodes::LOGICAL_ERROR,
+            "Expected {} as correlated subquery result, but got {}",
+            expected_result_type->getName(),
+            result_column.type->getName());
+
+    ActionsDAG dag(subquery_result_columns);
+
+    const auto * alias_node = &dag.addAlias(*dag.getOutputs()[0], correlated_subquery.action_node_name);
+    dag.getOutputs() = { alias_node };
+
+    auto expression_step = std::make_unique<ExpressionStep>(header, std::move(dag));
+    expression_step->setStepDescription("Create correlated subquery result alias");
+    correlated_subquery_plan.addStep(std::move(expression_step));
+}
+
 }
 
 /* Build query plan for correlated subquery using decorrelation algorithm
@@ -396,23 +516,38 @@ void buildQueryPlanForCorrelatedSubquery(
     {
         case DB::CorrelatedSubqueryKind::SCALAR:
         {
-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Scalar correlated subqueries are not supported");
+            Planner subquery_planner = buildPlannerForCorrelatedSubquery(planner_context, correlated_subquery, select_query_options);
+            /// Logical plan for correlated subquery
+            auto & correlated_query_plan = subquery_planner.getQueryPlan();
+
+            addStepForResultRenaming(correlated_subquery, correlated_query_plan);
+
+            /// Mark all query plan steps if they or their subplans contain usage of correlated subqueries.
+            /// It's needed to identify the moment when dependent join can be replaced by CROSS JOIN.
+            auto correlated_step_map = buildCorrelatedPlanStepMap(correlated_query_plan);
+
+            DecorrelationContext context{
+                .correlated_subquery = correlated_subquery,
+                .planner_context = planner_context,
+                .query_plan = std::move(query_plan),
+                .correlated_query_plan = std::move(subquery_planner).extractQueryPlan(),
+                .correlated_plan_steps = std::move(correlated_step_map)
+            };
+
+            auto decorrelated_plan = decorrelateQueryPlan(context, context.correlated_query_plan.getRootNode());
+            buildRenamingForScalarSubquery(decorrelated_plan, correlated_subquery);
+
+            /// Use LEFT OUTER JOIN to produce the result plan.
+            query_plan = buildLogicalJoin(
+                planner_context,
+                std::move(context.query_plan),
+                std::move(decorrelated_plan),
+                correlated_subquery);
+            break;
         }
         case CorrelatedSubqueryKind::EXISTS:
         {
-            auto subquery_options = select_query_options.subquery();
-            auto global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});
-            /// Register table expression data for correlated columns sources in the global context.
-            /// Table expression data would be reused because it can't be initialized
-            /// during plan construction for correlated subquery.
-            global_planner_context->collectTableExpressionDataForCorrelatedColumns(correlated_subquery.query_tree, planner_context);
-
-            Planner subquery_planner(
-                correlated_subquery.query_tree,
-                subquery_options,
-                global_planner_context);
-            subquery_planner.buildQueryPlanIfNeeded();
-
+            Planner subquery_planner = buildPlannerForCorrelatedSubquery(planner_context, correlated_subquery, select_query_options);
             /// Logical plan for correlated subquery
             auto & correlated_query_plan = subquery_planner.getQueryPlan();
 
@@ -432,6 +567,7 @@ void buildQueryPlanForCorrelatedSubquery(
             auto correlated_step_map = buildCorrelatedPlanStepMap(correlated_query_plan);
 
             DecorrelationContext context{
+                .correlated_subquery = correlated_subquery,
                 .planner_context = planner_context,
                 .query_plan = std::move(query_plan),
                 .correlated_query_plan = std::move(subquery_planner).extractQueryPlan(),
diff --git a/src/Processors/QueryPlan/AggregatingStep.h b/src/Processors/QueryPlan/AggregatingStep.h
index 21b59b62ecd6..c6b68fef9018 100644
--- a/src/Processors/QueryPlan/AggregatingStep.h
+++ b/src/Processors/QueryPlan/AggregatingStep.h
@@ -85,6 +85,19 @@ class AggregatingStep : public ITransformingStep
 
     void enableMemoryBoundMerging() { memory_bound_merging_of_aggregation_results_enabled = true; }
 
+    /// AggregatingStep does not contain any ActionDAGs.
+    /// All the expressions used in the AggregatingStep must be evaluated before that.
+    bool hasCorrelatedExpressions() const override { return false; }
+
+    Aggregator::Params getAggregatorParameters() const { return params; }
+    bool getFinal() const noexcept { return final; }
+    size_t getMaxBlockSize() const noexcept { return max_block_size; }
+    size_t getMaxBlockSizeForAggregationInOrder() const noexcept { return aggregation_in_order_max_block_bytes; }
+    size_t getMergeThreads() const noexcept { return merge_threads; }
+    size_t getTemporaryDataMergeThreads() const noexcept { return temporary_data_merge_threads; }
+    bool shouldProduceResultsInBucketOrder() const noexcept { return should_produce_results_in_order_of_bucket_number; }
+    bool usingMemoryBoundMerging() const noexcept { return memory_bound_merging_of_aggregation_results_enabled; }
+
 private:
     void updateOutputHeader() override;
 
diff --git a/src/Processors/QueryPlan/JoinStepLogical.cpp b/src/Processors/QueryPlan/JoinStepLogical.cpp
index 7ab98dee7801..4026d04b2e76 100644
--- a/src/Processors/QueryPlan/JoinStepLogical.cpp
+++ b/src/Processors/QueryPlan/JoinStepLogical.cpp
@@ -889,6 +889,23 @@ std::unique_ptr<IQueryPlanStep> JoinStepLogical::deserialize(Deserialization & c
         std::move(sort_settings));
 }
 
+QueryPlanStepPtr JoinStepLogical::clone() const
+{
+    auto new_expression_actions = expression_actions.clone();
+    auto new_join_info = join_info.clone(new_expression_actions);
+
+    auto result_step = std::make_unique<JoinStepLogical>(
+        getInputHeaders().front(), getInputHeaders().back(),
+        std::move(new_join_info),
+        std::move(new_expression_actions),
+        required_output_columns,
+        use_nulls,
+        join_settings,
+        sorting_settings);
+    result_step->setStepDescription(getStepDescription());
+    return result_step;
+}
+
 void registerJoinStep(QueryPlanStepRegistry & registry)
 {
     registry.registerStep("Join", JoinStepLogical::deserialize);
diff --git a/src/Processors/QueryPlan/JoinStepLogical.h b/src/Processors/QueryPlan/JoinStepLogical.h
index 1396fa7a2aeb..e71d6e8c3ae1 100644
--- a/src/Processors/QueryPlan/JoinStepLogical.h
+++ b/src/Processors/QueryPlan/JoinStepLogical.h
@@ -109,6 +109,9 @@ class JoinStepLogical final : public IQueryPlanStep
 
     static std::unique_ptr<IQueryPlanStep> deserialize(Deserialization & ctx);
 
+    QueryPlanStepPtr clone() const override;
+    bool hasCorrelatedExpressions() const override { return expression_actions.hasCorrelatedExpressions(); }
+
 protected:
     void updateOutputHeader() override;
 
diff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp
index ed41b8eb10ca..d21a4c28c18e 100644
--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp
+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp
@@ -1,3 +1,4 @@
+#include <memory>
 #include <Processors/QueryPlan/ReadFromSystemNumbersStep.h>
 
 #include <Core/ColumnWithTypeAndName.h>
@@ -463,6 +464,11 @@ void ReadFromSystemNumbersStep::initializePipeline(QueryPipelineBuilder & pipeli
     pipeline.init(std::move(pipe));
 }
 
+QueryPlanStepPtr ReadFromSystemNumbersStep::clone() const
+{
+    return std::make_unique<ReadFromSystemNumbersStep>(column_names, getQueryInfo(), getStorageSnapshot(), getContext(), storage, max_block_size, num_streams);
+}
+
 Pipe ReadFromSystemNumbersStep::makePipe()
 {
     auto & numbers_storage = storage->as<StorageSystemNumbers &>();
diff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h
index 0177b874c931..07417cbacd52 100644
--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h
+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h
@@ -28,6 +28,8 @@ class ReadFromSystemNumbersStep final : public SourceStepWithFilter
 
     void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;
 
+    QueryPlanStepPtr clone() const override;
+
 private:
     /// Fail fast if estimated number of rows to read exceeds the limit
     void checkLimits(size_t rows);
