diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp
index a18d34af9942..bc29a74f4ebd 100644
--- a/src/Core/Block.cpp
+++ b/src/Core/Block.cpp
@@ -181,25 +181,25 @@ const ColumnWithTypeAndName & Block::safeGetByPosition(size_t position) const
 }
 
 
-ColumnWithTypeAndName & Block::getByName(const std::string & name)
+const ColumnWithTypeAndName * Block::findByName(const std::string & name) const
 {
     auto it = index_by_name.find(name);
     if (index_by_name.end() == it)
-        throw Exception("Not found column " + name + " in block. There are only columns: " + dumpNames()
-            , ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);
-
-    return data[it->second];
+    {
+        return nullptr;
+    }
+    return &data[it->second];
 }
 
 
 const ColumnWithTypeAndName & Block::getByName(const std::string & name) const
 {
-    auto it = index_by_name.find(name);
-    if (index_by_name.end() == it)
+    auto * result = findByName(name);
+    if (!result)
         throw Exception("Not found column " + name + " in block. There are only columns: " + dumpNames()
             , ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);
 
-    return data[it->second];
+    return *result;
 }
 
 
diff --git a/src/Core/Block.h b/src/Core/Block.h
index 82b60c83efbc..ce804ddc0b5d 100644
--- a/src/Core/Block.h
+++ b/src/Core/Block.h
@@ -28,7 +28,7 @@ class Block
 {
 private:
     using Container = ColumnsWithTypeAndName;
-    using IndexByName = std::map<String, size_t>;
+    using IndexByName = std::unordered_map<String, size_t>;
 
     Container data;
     IndexByName index_by_name;
@@ -64,7 +64,20 @@ class Block
     ColumnWithTypeAndName & safeGetByPosition(size_t position);
     const ColumnWithTypeAndName & safeGetByPosition(size_t position) const;
 
-    ColumnWithTypeAndName & getByName(const std::string & name);
+    ColumnWithTypeAndName* findByName(const std::string & name)
+    {
+        return const_cast<ColumnWithTypeAndName *>(
+            const_cast<const Block *>(this)->findByName(name));
+    }
+
+    const ColumnWithTypeAndName* findByName(const std::string & name) const;
+
+    ColumnWithTypeAndName & getByName(const std::string & name)
+    {
+        return const_cast<ColumnWithTypeAndName &>(
+            const_cast<const Block *>(this)->getByName(name));
+    }
+
     const ColumnWithTypeAndName & getByName(const std::string & name) const;
 
     Container::iterator begin() { return data.begin(); }
diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index 38656c47765c..b810182eb48a 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -195,14 +195,6 @@ SetPtr makeExplicitSet(
     return set;
 }
 
-static String getUniqueName(const Block & block, const String & prefix)
-{
-    int i = 1;
-    while (block.has(prefix + toString(i)))
-        ++i;
-    return prefix + toString(i);
-}
-
 ScopeStack::ScopeStack(const ExpressionActionsPtr & actions, const Context & context_)
     : context(context_)
 {
@@ -431,7 +423,6 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
     for (size_t arg = 0; arg < node.arguments->children.size(); ++arg)
     {
         auto & child = node.arguments->children[arg];
-        auto child_column_name = child->getColumnName();
 
         const auto * lambda = child->as<ASTFunction>();
         const auto * identifier = child->as<ASTIdentifier>();
@@ -459,9 +450,9 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
             /// If the argument is a set given by an enumeration of values (so, the set was already built), give it a unique name,
             ///  so that sets with the same literal representation do not fuse together (they can have different types).
             if (!prepared_set->empty())
-                column.name = getUniqueName(data.getSampleBlock(), "__set");
+                column.name = data.getUniqueName("__set");
             else
-                column.name = child_column_name;
+                column.name = child->getColumnName();
 
             if (!data.hasColumn(column.name))
             {
@@ -487,7 +478,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
             ColumnWithTypeAndName column(
                 ColumnConst::create(std::move(column_string), 1),
                 std::make_shared<DataTypeString>(),
-                getUniqueName(data.getSampleBlock(), "__joinGet"));
+                data.getUniqueName("__joinGet"));
             data.addAction(ExpressionAction::addColumn(column));
             argument_types.push_back(column.type);
             argument_names.push_back(column.name);
@@ -496,6 +487,18 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
         {
             /// If the argument is not a lambda expression, call it recursively and find out its type.
             visit(child, data);
+
+            // In the above visit() call, if the argument is a literal, we
+            // generated a unique column name for it. Use it instead of a generic
+            // display name.
+            auto child_column_name = child->getColumnName();
+            auto as_literal = child->as<ASTLiteral>();
+            if (as_literal)
+            {
+                assert(!as_literal->unique_column_name.empty());
+                child_column_name = as_literal->unique_column_name;
+            }
+
             if (data.hasColumn(child_column_name))
             {
                 argument_types.push_back(data.getSampleBlock().getByName(child_column_name).type);
@@ -556,7 +559,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
 
                 /// We can not name `getColumnName()`,
                 ///  because it does not uniquely define the expression (the types of arguments can be different).
-                String lambda_name = getUniqueName(data.getSampleBlock(), "__lambda");
+                String lambda_name = data.getUniqueName("__lambda");
 
                 auto function_capture = std::make_unique<FunctionCaptureOverloadResolver>(
                         lambda_actions, captured, lambda_arguments, result_type, result_name);
@@ -587,18 +590,53 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
     }
 }
 
-void ActionsMatcher::visit(const ASTLiteral & literal, const ASTPtr & ast, Data & data)
+void ActionsMatcher::visit(const ASTLiteral & literal, const ASTPtr & /* ast */,
+    Data & data)
 {
-    CachedColumnName column_name;
-    if (data.hasColumn(column_name.get(ast)))
-        return;
-
     DataTypePtr type = applyVisitor(FieldToDataType(), literal.value);
+    const auto value = convertFieldToType(literal.value, *type);
+
+    // FIXME why do we have a second pass with a clean sample block over the same
+    // AST here? Anyway, do not modify the column name if it is set already.
+    if (literal.unique_column_name.empty())
+    {
+        const auto default_name = literal.getColumnName();
+        auto & block = data.getSampleBlock();
+        auto * existing_column = block.findByName(default_name);
+
+        /*
+         * To approximate CSE, bind all identical literals to a single temporary
+         * columns. We try to find the column by its default name, but after that
+         * we have to check that it contains the correct data. This might not be
+         * the case if it is a user-supplied column, or it is from under a join,
+         * etc.
+         * Overall, this is a hack around a generally poor name-based notion of
+         * column identity we currently use.
+         */
+        if (existing_column
+            && existing_column->column
+            && isColumnConst(*existing_column->column)
+            && existing_column->column->size() == 1
+            && existing_column->column->operator[](0) == value)
+        {
+            const_cast<ASTLiteral &>(literal).unique_column_name = default_name;
+        }
+        else
+        {
+            const_cast<ASTLiteral &>(literal).unique_column_name
+                = data.getUniqueName(default_name);
+        }
+    }
+
+    if (data.hasColumn(literal.unique_column_name))
+    {
+        return;
+    }
 
     ColumnWithTypeAndName column;
-    column.column = type->createColumnConst(1, convertFieldToType(literal.value, *type));
+    column.name = literal.unique_column_name;
+    column.column = type->createColumnConst(1, value);
     column.type = type;
-    column.name = column_name.get(ast);
 
     data.addAction(ExpressionAction::addColumn(column));
 }
diff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h
index f6db551ff332..dbcc54c01d65 100644
--- a/src/Interpreters/ActionsVisitor.h
+++ b/src/Interpreters/ActionsVisitor.h
@@ -80,6 +80,13 @@ class ActionsMatcher
         size_t visit_depth;
         ScopeStack actions_stack;
 
+        /*
+         * Remember the last unique column suffix to avoid quadratic behavior
+         * when we add lots of column with same prefix. One counter for all
+         * prefixes is good enough.
+         */
+        int next_unique_suffix;
+
         Data(const Context & context_, SizeLimits set_size_limit_, size_t subquery_depth_,
                 const NamesAndTypesList & source_columns_, const ExpressionActionsPtr & actions,
                 PreparedSets & prepared_sets_, SubqueriesForSets & subqueries_for_sets_,
@@ -95,7 +102,8 @@ class ActionsMatcher
             only_consts(only_consts_),
             no_storage_or_local(no_storage_or_local_),
             visit_depth(0),
-            actions_stack(actions, context)
+            actions_stack(actions, context),
+            next_unique_suffix(actions_stack.getSampleBlock().columns() + 1)
         {}
 
         void updateActions(ExpressionActionsPtr & actions)
@@ -118,6 +126,26 @@ class ActionsMatcher
         {
             return actions_stack.getSampleBlock().has(columnName);
         }
+
+        /*
+         * Generate a column name that is not present in the sample block, using
+         * the given prefix and an optional numeric suffix.
+         */
+        String getUniqueName(const String & prefix)
+        {
+            const auto & block = getSampleBlock();
+            auto result = prefix;
+
+            // First, try the name without any suffix, because it is currently
+            // used both as a display name and a column id.
+            while (block.has(result))
+            {
+                result = prefix + "_" + toString(next_unique_suffix);
+                ++next_unique_suffix;
+            }
+
+            return result;
+        }
     };
 
     static void visit(const ASTPtr & ast, Data & data);
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 9ec32737fdcb..bb33aca76558 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -854,7 +854,34 @@ void SelectQueryExpressionAnalyzer::appendProjectResult(ExpressionActionsChain &
         String result_name = ast->getAliasOrColumnName();
         if (required_result_columns.empty() || required_result_columns.count(result_name))
         {
-            result_columns.emplace_back(ast->getColumnName(), result_name);
+            std::string source_name = ast->getColumnName();
+
+            /*
+             * For temporary columns created by ExpressionAnalyzer for literals,
+             * use the correct source column. Using the default display name
+             * returned by getColumnName is not enough, and we have to use the
+             * column id set by EA. In principle, this logic applies to all kinds
+             * of columns, not only literals. Literals are especially problematic
+             * for two reasons:
+             * 1) confusing different literal columns leads to weird side
+             *    effects (see 01101_literal_columns_clash);
+             * 2) the disambiguation mechanism in SyntaxAnalyzer, that, among
+             *    other things, creates unique aliases for columns with same
+             *    names from different tables, is applied before these temporary
+             *    columns are created by ExpressionAnalyzer.
+             * Similar problems should also manifest for function columns, which
+             * are likewise created at a later stage by EA.
+             * In general, we need to have explicit separation between display
+             * names and identifiers for columns. This code is a workaround for
+             * a particular subclass of problems, and not a proper solution.
+             */
+            if (auto as_literal = ast->as<ASTLiteral>())
+            {
+                source_name = as_literal->unique_column_name;
+                assert(!source_name.empty());
+            }
+
+            result_columns.emplace_back(source_name, result_name);
             step.required_output.push_back(result_columns.back().second);
         }
     }
diff --git a/src/Parsers/ASTLiteral.h b/src/Parsers/ASTLiteral.h
index 552f5da04a2d..18f440a81a4a 100644
--- a/src/Parsers/ASTLiteral.h
+++ b/src/Parsers/ASTLiteral.h
@@ -21,6 +21,17 @@ class ASTLiteral : public ASTWithAlias
     std::optional<TokenIterator> begin;
     std::optional<TokenIterator> end;
 
+    /*
+     * The name of the column corresponding to this literal. Only used to
+     * disambiguate the literal columns with the same display name that are
+     * created at the expression analyzer stage. In the future, we might want to
+     * have a full separation between display names and column identifiers. For
+     * now, this field is effectively just some private EA data.
+     */
+    String unique_column_name;
+
+
+public:
     ASTLiteral(Field && value_) : value(value_) {}
     ASTLiteral(const Field & value_) : value(value_) {}
 
