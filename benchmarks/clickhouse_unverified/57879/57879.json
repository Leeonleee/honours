{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57879,
  "instance_id": "ClickHouse__ClickHouse-57879",
  "issue_numbers": [
    "57458",
    "57816"
  ],
  "base_commit": "b0eb670776c58af040dc488f1428c313f9eea1ab",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex a058e1db6b43..00efa63c9605 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1081,6 +1081,10 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+**See also**\n+\n+- [arrayFold](#arrayfold)\n+\n ## arrayReduceInRanges\n \n Applies an aggregate function to array elements in given ranges and returns an array containing the result corresponding to each range. The function will return the same result as multiple `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.\n@@ -1123,6 +1127,56 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## arrayFold\n+\n+Applies a lambda function to one or more equally-sized arrays and collects the result in an accumulator.\n+\n+**Syntax**\n+\n+``` sql\n+arrayFold(lambda_function, arr1, arr2, ..., accumulator)\n+```\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT arrayFold( acc,x -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500res\u2500\u2510\n+\u2502  23 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Example with the Fibonacci sequence**\n+\n+```sql\n+SELECT arrayFold( acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci\n+FROM numbers(1,10);\n+\n+\u250c\u2500fibonacci\u2500\u2510\n+\u2502         0 \u2502\n+\u2502         1 \u2502\n+\u2502         1 \u2502\n+\u2502         2 \u2502\n+\u2502         3 \u2502\n+\u2502         5 \u2502\n+\u2502         8 \u2502\n+\u2502        13 \u2502\n+\u2502        21 \u2502\n+\u2502        34 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**See also**\n+\n+- [arrayReduce](#arrayreduce)\n+\n ## arrayReverse(arr)\n \n Returns an array of the same size as the original array containing the elements in reverse order.\ndiff --git a/src/Columns/ColumnFunction.cpp b/src/Columns/ColumnFunction.cpp\nindex 7c7b87bf4a6f..d8eea26b7d58 100644\n--- a/src/Columns/ColumnFunction.cpp\n+++ b/src/Columns/ColumnFunction.cpp\n@@ -248,7 +248,7 @@ void ColumnFunction::appendArguments(const ColumnsWithTypeAndName & columns)\n     auto wanna_capture = columns.size();\n \n     if (were_captured + wanna_capture > args)\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot capture {} columns because function {} has {} arguments{}.\",\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot capture {} column(s) because function {} has {} arguments{}.\",\n                         wanna_capture, function->getName(), args,\n                         (were_captured ? \" and \" + toString(were_captured) + \" columns have already been captured\" : \"\"));\n \ndiff --git a/src/Functions/array/arrayFold.cpp b/src/Functions/array/arrayFold.cpp\nnew file mode 100644\nindex 000000000000..44fe95624a6b\n--- /dev/null\n+++ b/src/Functions/array/arrayFold.cpp\n@@ -0,0 +1,290 @@\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnFunction.h>\n+#include <Common/Exception.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeFunction.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int SIZES_OF_ARRAYS_DONT_MATCH;\n+    extern const int TYPE_MISMATCH;\n+}\n+\n+/**\n+ * arrayFold( acc,a1,...,aN->expr, arr1, ..., arrN, acc_initial)\n+ */\n+class FunctionArrayFold : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"arrayFold\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayFold>(); }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    void getLambdaArgumentTypes(DataTypes & arguments) const override\n+    {\n+        if (arguments.size() < 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires as arguments a lambda function, at least one array and an accumulator\", getName());\n+\n+        DataTypes accumulator_and_array_types(arguments.size() - 1);\n+        accumulator_and_array_types[0] = arguments.back();\n+        for (size_t i = 1; i < accumulator_and_array_types.size(); ++i)\n+        {\n+            const auto * array_type = checkAndGetDataType<DataTypeArray>(&*arguments[i]);\n+            if (!array_type)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument {} of function {} must be of type Array, found {} instead\", i + 1, getName(), arguments[i]->getName());\n+            accumulator_and_array_types[i] = recursiveRemoveLowCardinality(array_type->getNestedType());\n+        }\n+\n+        const auto * lambda_function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].get());\n+        if (!lambda_function_type || lambda_function_type->getArgumentTypes().size() != accumulator_and_array_types.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument of function {} must be a lambda function with {} arguments, found {} instead.\",\n+                            getName(), accumulator_and_array_types.size(), arguments[0]->getName());\n+\n+        arguments[0] = std::make_shared<DataTypeFunction>(accumulator_and_array_types);\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() < 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires as arguments a lambda function, at least one array and an accumulator\", getName());\n+\n+        const auto * lambda_function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].type.get());\n+        if (!lambda_function_type)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        auto accumulator_type = arguments.back().type;\n+        auto lambda_type = lambda_function_type->getReturnType();\n+        if (!accumulator_type->equals(*lambda_type))\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                    \"Return type of lambda function must be the same as the accumulator type, inferred return type of lambda: {}, inferred type of accumulator: {}\",\n+                    lambda_type->getName(), accumulator_type->getName());\n+\n+        return accumulator_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & lambda_function_with_type_and_name = arguments[0];\n+\n+        if (!lambda_function_with_type_and_name.column)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        const auto * lambda_function = typeid_cast<const ColumnFunction *>(lambda_function_with_type_and_name.column.get());\n+        if (!lambda_function)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        ColumnPtr first_array_col;\n+        const ColumnArray * first_array_col_concrete = nullptr;\n+        ColumnPtr first_array_col_offsets;\n+\n+        ColumnsWithTypeAndName arrays_data_with_type_and_name; /// for all arrays, the pointers to the internal data column, type and name\n+        arrays_data_with_type_and_name.reserve(arguments.size() - 1);\n+\n+        /// Validate array arguments and set pointers so we can access them more conveniently\n+        for (size_t i = 1; i < arguments.size() - 1; ++i)\n+        {\n+            const auto & array_with_type_and_name = arguments[i];\n+            ColumnPtr array_col = array_with_type_and_name.column;\n+            const auto * array_col_concrete = checkAndGetColumn<ColumnArray>(array_col.get());\n+            if (!array_col_concrete)\n+            {\n+                const ColumnConst * aray_col_concrete_const = checkAndGetColumnConst<ColumnArray>(array_col.get());\n+                if (!aray_col_concrete_const)\n+                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Expected array column, found {}\", array_col->getName());\n+                array_col = recursiveRemoveLowCardinality(aray_col_concrete_const->convertToFullColumn());\n+                array_col_concrete = checkAndGetColumn<ColumnArray>(array_col.get());\n+            }\n+\n+            const DataTypePtr & array_type = array_with_type_and_name.type;\n+            const auto * array_type_concrete = checkAndGetDataType<DataTypeArray>(array_type.get());\n+            if (!array_type_concrete)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Expected array type, found {}\", array_type->getName());\n+\n+            /// Check that the cardinality of the arrays across a row is the same for all array arguments.\n+            /// This simplifies later calculations which can work only with the offsets of the first column.\n+            if (!first_array_col_offsets)\n+                first_array_col_offsets = array_col_concrete->getOffsetsPtr();\n+            else\n+            {\n+                /// It suffices to check that the internal offset columns are equal.\n+                /// The first condition is optimization: skip comparison if the offset pointers are equal.\n+                if (array_col_concrete->getOffsetsPtr() != first_array_col_offsets\n+                    && array_col_concrete->getOffsets() != typeid_cast<const ColumnArray::ColumnOffsets &>(*first_array_col_offsets).getData())\n+                    throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH, \"arrays_data_with_type_and_name passed to {} must have equal size\", getName());\n+            }\n+\n+            if (i == 1)\n+            {\n+                first_array_col = array_col;\n+                first_array_col_concrete = array_col_concrete;\n+            }\n+\n+            ColumnWithTypeAndName data_type_name(array_col_concrete->getDataPtr(), recursiveRemoveLowCardinality(array_type_concrete->getNestedType()), array_with_type_and_name.name);\n+            arrays_data_with_type_and_name.push_back(data_type_name);\n+        }\n+\n+        const ssize_t num_rows = input_rows_count; /// how many rows are processed\n+        const size_t num_array_cols = arrays_data_with_type_and_name.size(); /// number of given array arguments\n+        const ssize_t num_elements_in_array_col = arrays_data_with_type_and_name[0].column->size(); /// total number of array elements in the 1st array argument (the value is the same for other array arguments)\n+\n+        if (num_rows == 0)\n+            return arguments.back().column->convertToFullColumnIfConst()->cloneEmpty();\n+\n+        const auto & offsets = first_array_col_concrete->getOffsets(); /// the internal offsets column of the first array argument (other array arguments have the same offsets)\n+\n+        /// Find the first row which contains a non-empty array\n+        ssize_t first_row_with_non_empty_array = 0;\n+        if (num_elements_in_array_col)\n+            while (offsets[first_row_with_non_empty_array] == 0)\n+                ++first_row_with_non_empty_array;\n+\n+        /// Build a selector which stores for every array element in the first array argument if the array element is the 0th, 1st, ... (horizontal) array element in the current row\n+        /// Better explained by an example:\n+        ///             0        1      <-- horizontal position\n+        ///   row0: ['elem1']\n+        ///   row1: ['elem2', 'elem3']\n+        ///   row2: ['elem4']\n+        ///   --> Selector will contain [0, 0, 1, 0].\n+        IColumn::Selector selector(num_elements_in_array_col);\n+        size_t max_array_size = 0; /// cardinality of the array with the most elements in the first array argument\n+        size_t cur_element_in_cur_array = 0;\n+        for (ssize_t i = 0; i < num_elements_in_array_col; ++i)\n+        {\n+            selector[i] = cur_element_in_cur_array;\n+            ++cur_element_in_cur_array;\n+            if (cur_element_in_cur_array > max_array_size)\n+                max_array_size = cur_element_in_cur_array;\n+            while (first_row_with_non_empty_array < num_rows && cur_element_in_cur_array >= offsets[first_row_with_non_empty_array] - offsets[first_row_with_non_empty_array - 1])\n+            {\n+                ++first_row_with_non_empty_array;\n+                cur_element_in_cur_array = 0;\n+            }\n+        }\n+\n+        /// Based on the selector, scatter elements of the arrays on all rows into vertical slices\n+        /// Example:\n+        ///   row0: ['elem1']\n+        ///   row1: ['elem2', 'elem3']\n+        ///   row2: ['elem4']\n+        ///   --> create two slices based on selector [0, 0, 1, 0]\n+        ///       - slice0: 'elem1', 'elem2', 'elem4''\n+        ///       - slice1: 'elem3'\n+        std::vector<MutableColumns> vertical_slices; /// contains for every array argument, a vertical slice for the 0th array element, a vertical slice for the 1st array element, ...\n+        vertical_slices.resize(num_array_cols);\n+        if (max_array_size > 0)\n+            for (size_t i = 0; i < num_array_cols; ++i)\n+                vertical_slices[i] = arrays_data_with_type_and_name[i].column->scatter(max_array_size, selector);\n+\n+        ColumnPtr accumulator_col = arguments.back().column->convertToFullColumnIfConst();\n+        MutableColumnPtr result_col = accumulator_col->cloneEmpty();\n+        ColumnPtr lambda_col = lambda_function->cloneResized(num_rows);\n+\n+        IColumn::Permutation inverse_permutation(num_rows);\n+        size_t num_inverse_permutations = 0;\n+\n+        /// Iterate the slices. The accumulator value of a row is updated iff the array in the row has at least slice_i-many elements. Since\n+        /// slices become incrementally smaller, fewer and fewer accumulator values are updated in each iteration. Once the calculation for\n+        /// a row is finished (i.e. there are no more slices to process), it is added to the result. Since that happens in random order,\n+        /// we also maintain a mapping to reconstruct the right result order at the end.\n+        size_t unfinished_rows = num_rows; /// number of rows to consider in the current iteration\n+        for (size_t slice = 0; slice < max_array_size; ++slice)\n+        {\n+            IColumn::Selector prev_selector(unfinished_rows); /// 1 for rows which have slice_i-many elements, otherwise 0\n+            size_t prev_index = 0;\n+            for (ssize_t row = 0; row < num_rows; ++row)\n+            {\n+                size_t num_elements = offsets[row] - offsets[row - 1]; /// cardinality of array on the row\n+                if (num_elements > slice)\n+                {\n+                    prev_selector[prev_index] = 1;\n+                    ++prev_index;\n+                }\n+                else if (num_elements == slice)\n+                {\n+                    prev_selector[prev_index] = 0;\n+                    ++prev_index;\n+                    inverse_permutation[num_inverse_permutations] = row;\n+                    ++num_inverse_permutations;\n+                }\n+            }\n+\n+            /// Scatter the accumulator into two columns\n+            /// - one column with accumulator values for rows less than slice-many elements, no further calculation is performed on them\n+            /// - one column with accumulator values for rows with slice-many or more elements, these are updated in this or following iteration\n+            std::vector<IColumn::MutablePtr> finished_unfinished_accumulator_values = accumulator_col->scatter(2, prev_selector);\n+            IColumn::MutablePtr & finished_accumulator_values = finished_unfinished_accumulator_values[0];\n+            IColumn::MutablePtr & unfinished_accumulator_values = finished_unfinished_accumulator_values[1];\n+\n+            /// Copy finished accumulator values into the result\n+            result_col->insertRangeFrom(*finished_accumulator_values, 0, finished_accumulator_values->size());\n+\n+            /// The lambda function can contain statically bound arguments, in particular their row values. We need to filter for the rows\n+            /// we care about.\n+            IColumn::Filter filter(unfinished_rows);\n+            for (size_t i = 0; i < prev_selector.size(); ++i)\n+                filter[i] = prev_selector[i];\n+            ColumnPtr lambda_col_filtered = lambda_col->filter(filter, lambda_col->size());\n+            IColumn::MutablePtr lambda_col_filtered_cloned = lambda_col_filtered->cloneResized(lambda_col_filtered->size()); /// clone so we can bind more arguments\n+            auto * lambda = typeid_cast<ColumnFunction *>(lambda_col_filtered_cloned.get());\n+\n+            /// Bind arguments to lambda function (accumulator + array arguments)\n+            lambda->appendArguments(std::vector({ColumnWithTypeAndName(std::move(unfinished_accumulator_values), arguments.back().type, arguments.back().name)}));\n+            for (size_t array_col = 0; array_col < num_array_cols; ++array_col)\n+                lambda->appendArguments(std::vector({ColumnWithTypeAndName(std::move(vertical_slices[array_col][slice]), arrays_data_with_type_and_name[array_col].type, arrays_data_with_type_and_name[array_col].name)}));\n+\n+            /// Perform the actual calculation and copy the result into the accumulator\n+            ColumnWithTypeAndName res_with_type_and_name = lambda->reduce();\n+            accumulator_col = res_with_type_and_name.column->convertToFullColumnIfConst();\n+\n+            unfinished_rows = accumulator_col->size();\n+            lambda_col = lambda_col_filtered;\n+        }\n+\n+        /// Copy accumulator values of last iteration into result.\n+        result_col->insertRangeFrom(*accumulator_col, 0, accumulator_col->size());\n+\n+        for (ssize_t row = 0; row < num_rows; ++row)\n+        {\n+            size_t num_elements = offsets[row] - offsets[row - 1]; /// cardinality of array on the row\n+            if (num_elements == max_array_size)\n+            {\n+                inverse_permutation[num_inverse_permutations] = row;\n+                ++num_inverse_permutations;\n+            }\n+        }\n+\n+        /// We have result_col containing result for every row and inverse_permutation which contains indexes of rows in input it corresponds to.\n+        /// Now we need to invert inverse_permuation and apply it to result_col to get rows in right order.\n+        IColumn::Permutation perm(num_rows);\n+        for (ssize_t row = 0; row < num_rows; ++row)\n+            perm[inverse_permutation[row]] = row;\n+        return result_col->permute(perm, 0);\n+    }\n+\n+private:\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+};\n+\n+REGISTER_FUNCTION(ArrayFold)\n+{\n+    factory.registerFunction<FunctionArrayFold>(FunctionDocumentation{.description=R\"(\n+        Function arrayFold(acc,a1,...,aN->expr, arr1, ..., arrN, acc_initial) applies a lambda function to each element\n+        in each (equally-sized) array and collects the result in an accumulator.\n+        )\", .examples{{\"sum\", \"SELECT arrayFold(acc,x->acc+x, [1,2,3,4], toInt64(1));\", \"11\"}}, .categories{\"Array\"}});\n+}\n+}\n",
  "test_patch": "diff --git a/tests/performance/array_fold.xml b/tests/performance/array_fold.xml\nnew file mode 100644\nindex 000000000000..32bd45beb1ec\n--- /dev/null\n+++ b/tests/performance/array_fold.xml\n@@ -0,0 +1,5 @@\n+<test>\n+    <query>SELECT arrayFold((acc, x) -> acc + x, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n+    <query>SELECT arrayFold((acc, x) -> acc + 1, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n+    <query>SELECT arrayFold((acc, x) -> acc + x, range(number), toUInt64(0)) from numbers(10000) Format Null</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/02718_array_fold.reference b/tests/queries/0_stateless/02718_array_fold.reference\nnew file mode 100644\nindex 000000000000..e746cd1546c6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02718_array_fold.reference\n@@ -0,0 +1,36 @@\n+-- Negative tests\n+-- Const arrays\n+23\n+3\n+101\n+[1,2,3,4]\n+[4,3,2,1]\n+([4,3,2,1],[1,2,3,4])\n+([1,3,5],[2,4,6])\n+-- Non-const arrays\n+0\n+1\n+3\n+6\n+10\n+[]\n+[0]\n+[1,0]\n+[2,1,0]\n+[3,2,1,0]\n+[]\n+[0]\n+[1,0]\n+[1,0,2]\n+[3,1,0,2]\n+-- Bug 57458\n+abcdef\t['c']\t3\n+ghijkl\t['h','k']\t5\n+mnopqr\t['n']\t2\n+xxx..yyy..\t['xxx','yyy']\t6\n+..........\t[]\t0\n+..xx..yyy.\t['xx','yyy']\t7\n+..........\t[]\t0\n+xxx.......\t['xxx']\t1\n+ -- Bug 57816\n+[]\ndiff --git a/tests/queries/0_stateless/02718_array_fold.sql b/tests/queries/0_stateless/02718_array_fold.sql\nnew file mode 100644\nindex 000000000000..7dee33c4705c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02718_array_fold.sql\n@@ -0,0 +1,60 @@\n+SELECT '-- Negative tests';\n+SELECT arrayFold(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayFold(1); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayFold(1, toUInt64(0)); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayFold(1, emptyArrayUInt64(), toUInt64(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( acc,x -> x,  emptyArrayString(), toInt8(0)); -- { serverError TYPE_MISMATCH }\n+SELECT arrayFold( acc,x -> x,  'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( acc,x,y -> x,  [0, 1], 'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( acc,x -> x,  [0, 1], [2, 3], toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( acc,x,y -> x,  [0, 1], [2, 3, 4], toUInt8(0)); -- { serverError SIZES_OF_ARRAYS_DONT_MATCH }\n+\n+SELECT '-- Const arrays';\n+SELECT arrayFold( acc,x -> acc+x*2,  [1, 2, 3, 4], toInt64(3));\n+SELECT arrayFold( acc,x -> acc+x*2,  emptyArrayInt64(), toInt64(3));\n+SELECT arrayFold( acc,x,y -> acc+x*2+y*3,  [1, 2, 3, 4], [5, 6, 7, 8], toInt64(3));\n+SELECT arrayFold( acc,x -> arrayPushBack(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n+SELECT arrayFold( acc,x -> arrayPushFront(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n+SELECT arrayFold( acc,x -> (arrayPushFront(acc.1, x),arrayPushBack(acc.2, x)),  [1, 2, 3, 4], (emptyArrayInt64(), emptyArrayInt64()));\n+SELECT arrayFold( acc,x -> x%2 ? (arrayPushBack(acc.1, x), acc.2): (acc.1, arrayPushBack(acc.2, x)),  [1, 2, 3, 4, 5, 6], (emptyArrayInt64(), emptyArrayInt64()));\n+\n+SELECT '-- Non-const arrays';\n+SELECT arrayFold( acc,x -> acc+x,  range(number), number) FROM system.numbers LIMIT 5;\n+SELECT arrayFold( acc,x -> arrayPushFront(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n+SELECT arrayFold( acc,x -> x%2 ? arrayPushFront(acc,x) : arrayPushBack(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n+\n+SELECT '-- Bug 57458';\n+\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab (line String, patterns Array(String)) ENGINE = MergeTree ORDER BY line;\n+INSERT INTO tab VALUES ('abcdef', ['c']), ('ghijkl', ['h', 'k']), ('mnopqr', ['n']);\n+\n+SELECT\n+    line,\n+    patterns,\n+    arrayFold(acc, pat -> position(line, pat), patterns, 0::UInt64)\n+FROM tab\n+ORDER BY line;\n+\n+DROP TABLE tab;\n+\n+CREATE TABLE tab (line String) ENGINE = Memory();\n+INSERT INTO tab VALUES ('xxx..yyy..'), ('..........'), ('..xx..yyy.'), ('..........'), ('xxx.......');\n+\n+SELECT\n+    line,\n+    splitByNonAlpha(line),\n+    arrayFold(\n+        (acc, str) -> position(line, str),\n+        splitByNonAlpha(line),\n+        0::UInt64\n+    )\n+FROM\n+    tab;\n+\n+DROP TABLE tab;\n+\n+SELECT ' -- Bug 57816';\n+\n+SELECT arrayFold(acc, x -> arrayIntersect(acc, x), [['qwe', 'asd'], ['qwe','asde']], []);\n",
  "problem_statement": "position function behaves incorrectly when used with arrayFold\n**Describe what's wrong**\r\n\r\n`position` function behaves incorrectly when used with `arrayFold` - fails to search string. I've verified all other intermediate states of `arrayFold` and other functions used are correct.\r\n\r\nhttps://fiddle.clickhouse.com/80adfdb5-f671-4d8a-bb27-49d6fdfdada7\r\n\r\n`position` function seems to fail string search and return 0 (substring not found).\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nConfirmed on 23.10.3.1 on server as well as clickhouse-local\r\n\r\n**How to reproduce**\r\n\r\nrefer to clickhouse fiddle - has a minimal reproducible setup\r\n\r\n**Expected behavior**\r\n\r\nIt should return the correct position of the substring.\r\n\r\n**Additional context**\r\n\r\nI am using the nix version of clickhouse but seeing it's also reproducible on fiddle, I don't think that's relevant to the issue.\r\n\r\n---\r\n*offtopic: I spent multiple hours figuring out why it isn't working. If you're wondering how I found this bug, I was trying to solve this years' advent of code with clickhouse - helps to learn a lot of the cool functions ClickHouse offers! (also I'm slightly deranged).*\r\n\narrayFold of arrayIntersect segfault\nThis little query breaks clickhouse. It works on arm64 macos local, it works on amd64 linux server, it works on fresh installed version.\r\n\r\n```\r\n$ clickhouse local\r\nClickHouse local version 23.12.1.457 (official build).\r\n\r\nair.local :) SELECT arrayFold(acc, x -> arrayIntersect(acc, x), [['qwe', 'asd'], ['qwe','asde']], [])\r\n\r\nSELECT arrayFold((acc, x) -> arrayIntersect(acc, x), [['qwe', 'asd'], ['qwe', 'asde']], [])\r\n\r\nQuery id: 660a9bd1-2975-49b8-ba29-35bcfce5901c\r\n\r\nAbort trap: 6\r\n```\n",
  "hints_text": "Simpler repro: https://fiddle.clickhouse.com/1b5a7741-b441-4a8f-819d-1ea62e79ce38\r\n\r\n@Lirikl There is a problem with `arrayFold()`, added with #49794, maybe you like to have a look?\nVia gdb:\r\n\r\n```\r\n#0  DB::ColumnArray::insertRangeFrom (this=0x70200002f840, src=..., start=0, length=1) at ./build_msan/./src/Columns/ColumnArray.cpp:521\r\n#1  0x000055557469539b in DB::ArrayFold::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const ()\r\n#2  0x000055555d23e598 in DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const\r\n    ()\r\n#3  0x000055558790b598 in DB::IExecutableFunction::executeWithoutLowCardinalityColumns (this=this@entry=0x70200006d800, args=..., result_type=..., input_rows_count=input_rows_count@entry=1, dry_run=false)\r\n    at ./build_msan/./src/Functions/IFunction.cpp:248\r\n#4  0x000055558790d6b1 in DB::IExecutableFunction::executeWithoutSparseColumns (this=this@entry=0x70200006d800, arguments=..., result_type=..., input_rows_count=input_rows_count@entry=1, dry_run=false) at ./build_msan/./src/Functions/IFunction.cpp:303\r\n#5  0x0000555587913d17 in DB::IExecutableFunction::execute (this=0x70200006d800, arguments=..., result_type=..., input_rows_count=1, dry_run=false) at ./build_msan/./src/Functions/IFunction.cpp:378\r\n#6  0x000055558b8c67d8 in DB::executeAction (action=..., execution_context=..., dry_run=false) at ./build_msan/./src/Interpreters/ExpressionActions.cpp:613\r\n#7  DB::ExpressionActions::execute (this=0x7110000ea398, block=..., num_rows=@0x7ffee8772100: 1, dry_run=false) at ./build_msan/./src/Interpreters/ExpressionActions.cpp:730\r\n#8  0x0000555592af616e in DB::ExpressionTransform::transform (this=0x71200021e898, chunk=...) at ./build_msan/./src/Processors/Transforms/ExpressionTransform.cpp:23\r\n#9  0x000055557d4813e1 in DB::ISimpleTransform::transform (this=0x0, input_chunk=..., output_chunk=...) at ./src/Processors/ISimpleTransform.h:32\r\n#10 0x0000555592038f26 in DB::ISimpleTransform::work (this=0x71200021e898) at ./build_msan/./src/Processors/ISimpleTransform.cpp:89\r\n#11 0x00005555920a156e in DB::executeJob (node=0x710000017500, read_progress_callback=0x70a0000370a0) at ./build_msan/./src/Processors/Executors/ExecutionThreadContext.cpp:47\r\n#12 DB::ExecutionThreadContext::executeTask (this=<optimized out>) at ./build_msan/./src/Processors/Executors/ExecutionThreadContext.cpp:95\r\n```\r\n\r\n```\r\n(gdb) p typeid(src)\r\n$9 = {_vptr$type_info = 0x55559d7f3a50 <vtable for __cxxabiv1::__si_class_type_info+16>, __type_name = 0x55555825e064 <typeinfo name for DB::ColumnConst> \"N2DB11ColumnConstE\"}\r\n```\r\n\r\nThe column is `const` not `array`, so the assert fails. If asserts are disabled, it will crash if you are lucky (or corrupt things if not)\r\n\r\ncc @rschu1ze @Lirikl \nThe longer version also works. I mean, I've encountered the bug on real tables with real data.\r\n```\r\n$ clickhouse local\r\nClickHouse local version 23.12.1.116 (official build).\r\n\r\nair.local :) CREATE TABLE q (id UInt32, arr Array(String)) ENGINE GenerateRandom(0, 10, 20)\r\n\r\nCREATE TABLE q\r\n(\r\n    `id` UInt32,\r\n    `arr` Array(String)\r\n)\r\nENGINE = GenerateRandom(0, 10, 20)\r\n\r\nQuery id: 0bbc04b0-9d87-48f3-9264-7d8926db5dc4\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.000 sec.\r\n\r\nair.local :) SELECT id, arrayFold(acc, x -> arrayIntersect(acc, x), groupArray(arr), []) AS u FROM (SELECT * FROM q LIMIT 5) GROUP BY id\r\n\r\nSELECT\r\n    id,\r\n    arrayFold((acc, x) -> arrayIntersect(acc, x), groupArray(arr), []) AS u\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM q\r\n    LIMIT 5\r\n)\r\nGROUP BY id\r\n\r\nQuery id: 84246678-9c81-4078-991d-fc785dac5f07\r\n\r\nAbort trap: 6\r\n```",
  "created_at": "2023-12-14T20:20:52Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "src/Columns/ColumnFunction.cpp",
    "b/src/Functions/array/arrayFold.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/array_fold.xml",
    "b/tests/queries/0_stateless/02718_array_fold.reference",
    "b/tests/queries/0_stateless/02718_array_fold.sql"
  ]
}