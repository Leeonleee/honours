{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52004,
  "instance_id": "ClickHouse__ClickHouse-52004",
  "issue_numbers": [
    "49528"
  ],
  "base_commit": "2b0c423d7d6ee2644151062ce7e0658f3682f1a1",
  "patch": "diff --git a/src/Analyzer/Passes/UniqToCountPass.cpp b/src/Analyzer/Passes/UniqToCountPass.cpp\nnew file mode 100644\nindex 000000000000..7533a99107b2\n--- /dev/null\n+++ b/src/Analyzer/Passes/UniqToCountPass.cpp\n@@ -0,0 +1,198 @@\n+#include \"UniqToCountPass.h\"\n+\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <AggregateFunctions/IAggregateFunction.h>\n+\n+#include <Analyzer/ColumnNode.h>\n+#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/QueryNode.h>\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+bool matchFnUniq(String func_name)\n+{\n+    auto name = Poco::toLower(func_name);\n+    return name == \"uniq\" || name == \"uniqHLL12\" || name == \"uniqExact\" || name == \"uniqTheta\" || name == \"uniqCombined\"\n+        || name == \"uniqCombined64\";\n+}\n+\n+/// Extract the corresponding projection columns for group by node list.\n+/// For example:\n+///     SELECT a as aa, any(b) FROM table group by a;  ->  aa(ColumnNode)\n+NamesAndTypes extractProjectionColumnsForGroupBy(const QueryNode * query_node)\n+{\n+    if (!query_node->hasGroupBy())\n+        return {};\n+\n+    NamesAndTypes result;\n+    for (const auto & group_by_ele : query_node->getGroupByNode()->getChildren())\n+    {\n+        const auto & projection_columns = query_node->getProjectionColumns();\n+        const auto & projection_nodes = query_node->getProjection().getNodes();\n+\n+        assert(projection_columns.size() == projection_nodes.size());\n+\n+        for (size_t i = 0; i < projection_columns.size(); i++)\n+        {\n+            if (projection_nodes[i]->isEqual(*group_by_ele))\n+                result.push_back(projection_columns[i]);\n+        }\n+    }\n+    return result;\n+}\n+\n+/// Whether query_columns equals subquery_columns.\n+///     query_columns: query columns from query\n+///     subquery_columns: projection columns from subquery\n+bool nodeListEquals(const QueryTreeNodes & query_columns, const NamesAndTypes & subquery_columns)\n+{\n+    if (query_columns.size() != subquery_columns.size())\n+        return false;\n+\n+    for (const auto & query_column : query_columns)\n+    {\n+        auto find = std::find_if(\n+            subquery_columns.begin(),\n+            subquery_columns.end(),\n+            [&](const auto & subquery_column) -> bool\n+            {\n+                if (auto * column_node = query_column->as<ColumnNode>())\n+                {\n+                    return subquery_column == column_node->getColumn();\n+                }\n+                return false;\n+            });\n+\n+        if (find == subquery_columns.end())\n+            return false;\n+    }\n+    return true;\n+}\n+\n+/// Whether subquery_columns contains all columns in subquery_columns.\n+///     query_columns: query columns from query\n+///     subquery_columns: projection columns from subquery\n+bool nodeListContainsAll(const QueryTreeNodes & query_columns, const NamesAndTypes & subquery_columns)\n+{\n+    if (query_columns.size() > subquery_columns.size())\n+        return false;\n+\n+    for (const auto & query_column : query_columns)\n+    {\n+        auto find = std::find_if(\n+            subquery_columns.begin(),\n+            subquery_columns.end(),\n+            [&](const auto & subquery_column) -> bool\n+            {\n+                if (auto * column_node = query_column->as<ColumnNode>())\n+                {\n+                    return subquery_column == column_node->getColumn();\n+                }\n+                return false;\n+            });\n+\n+        if (find == subquery_columns.end())\n+            return false;\n+    }\n+    return true;\n+}\n+\n+}\n+\n+class UniqToCountVisitor : public InDepthQueryTreeVisitor<UniqToCountVisitor>\n+{\n+public:\n+    using Base = InDepthQueryTreeVisitor<UniqToCountVisitor>;\n+    using Base::Base;\n+\n+    void visitImpl(QueryTreeNodePtr & node)\n+    {\n+        auto * query_node = node->as<QueryNode>();\n+        if (!query_node)\n+            return;\n+\n+        /// Check that query has only single table expression which is subquery\n+        auto * subquery_node = query_node->getJoinTree()->as<QueryNode>();\n+        if (!subquery_node)\n+            return;\n+\n+        /// Check that query has only single node in projection\n+        auto & projection_nodes = query_node->getProjection().getNodes();\n+        if (projection_nodes.size() != 1)\n+            return;\n+\n+        /// Check that projection_node is a function\n+        auto & projection_node = projection_nodes[0];\n+        auto * function_node = projection_node->as<FunctionNode>();\n+        if (!function_node)\n+            return;\n+\n+        /// Check that query single projection node is `uniq` or its variants\n+        if (!matchFnUniq(function_node->getFunctionName()))\n+            return;\n+\n+        auto & uniq_arguments_nodes = function_node->getArguments().getNodes();\n+\n+        /// Whether query matches 'SELECT uniq(x ...) FROM (SELECT DISTINCT x ...)'\n+        auto match_subquery_with_distinct = [&]() -> bool\n+        {\n+            if (!subquery_node->isDistinct())\n+                return false;\n+\n+            /// uniq expression list == subquery projection columns\n+            if (!nodeListEquals(uniq_arguments_nodes, subquery_node->getProjectionColumns()))\n+                return false;\n+\n+            return true;\n+        };\n+\n+        /// Whether query matches 'SELECT uniq(x ...) FROM (SELECT x ... GROUP BY x ...)'\n+        auto match_subquery_with_group_by = [&]() -> bool\n+        {\n+            if (!subquery_node->hasGroupBy())\n+                return false;\n+\n+            /// uniq argument node list == subquery group by node list\n+            auto group_by_columns = extractProjectionColumnsForGroupBy(subquery_node);\n+\n+            if (!nodeListEquals(uniq_arguments_nodes, group_by_columns))\n+                return false;\n+\n+            /// subquery projection columns must contain all columns in uniq argument node list\n+            if (!nodeListContainsAll(uniq_arguments_nodes, subquery_node->getProjectionColumns()))\n+                return false;\n+\n+            return true;\n+        };\n+\n+        /// Replace uniq of initial query to count\n+        if (match_subquery_with_distinct() || match_subquery_with_group_by())\n+        {\n+            AggregateFunctionProperties properties;\n+            auto aggregate_function = AggregateFunctionFactory::instance().get(\"count\", {}, {}, properties);\n+\n+            function_node->resolveAsAggregateFunction(std::move(aggregate_function));\n+            function_node->getArguments().getNodes().clear();\n+\n+            /// Update projection columns\n+            query_node->resolveProjectionColumns({{\"count()\", function_node->getResultType()}});\n+        }\n+    }\n+};\n+\n+\n+void UniqToCountPass::run(QueryTreeNodePtr query_tree_node, ContextPtr context)\n+{\n+    if (!context->getSettings().optimize_uniq_to_count)\n+        return;\n+\n+    UniqToCountVisitor visitor;\n+    visitor.visit(query_tree_node);\n+}\n+\n+}\ndiff --git a/src/Analyzer/Passes/UniqToCountPass.h b/src/Analyzer/Passes/UniqToCountPass.h\nnew file mode 100644\nindex 000000000000..4992d524e5e7\n--- /dev/null\n+++ b/src/Analyzer/Passes/UniqToCountPass.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <Analyzer/IQueryTreePass.h>\n+\n+namespace DB\n+{\n+\n+/** Optimize `uniq` and its variants(except uniqUpTo) into `count` over subquery.\n+ *     Example: 'SELECT uniq(x ...) FROM (SELECT DISTINCT x ...)' to\n+ *     Result: 'SELECT count() FROM (SELECT DISTINCT x ...)'\n+ *\n+ *     Example: 'SELECT uniq(x ...) FROM (SELECT x ... GROUP BY x ...)' to\n+ *     Result: 'SELECT count() FROM (SELECT x ... GROUP BY x ...)'\n+ *\n+ *     Note that we can rewrite all uniq variants except uniqUpTo.\n+ */\n+class UniqToCountPass final : public IQueryTreePass\n+{\n+public:\n+    String getName() override { return \"UniqToCount\"; }\n+\n+    String getDescription() override\n+    {\n+        return \"Rewrite uniq and its variants(except uniqUpTo) to count if subquery has distinct or group by clause.\";\n+    }\n+\n+    void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;\n+};\n+\n+}\ndiff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp\nindex a6da2a666150..dd75b0f586d8 100644\n--- a/src/Analyzer/QueryTreePassManager.cpp\n+++ b/src/Analyzer/QueryTreePassManager.cpp\n@@ -18,6 +18,7 @@\n #include <Analyzer/Utils.h>\n #include <Analyzer/Passes/QueryAnalysisPass.h>\n #include <Analyzer/Passes/CountDistinctPass.h>\n+#include <Analyzer/Passes/UniqToCountPass.h>\n #include <Analyzer/Passes/FunctionToSubcolumnsPass.h>\n #include <Analyzer/Passes/RewriteAggregateFunctionWithIfPass.h>\n #include <Analyzer/Passes/SumIfToCountIfPass.h>\n@@ -246,6 +247,7 @@ void addQueryTreePasses(QueryTreePassManager & manager)\n     manager.addPass(std::make_unique<ConvertLogicalExpressionToCNFPass>());\n \n     manager.addPass(std::make_unique<CountDistinctPass>());\n+    manager.addPass(std::make_unique<UniqToCountPass>());\n     manager.addPass(std::make_unique<RewriteAggregateFunctionWithIfPass>());\n     manager.addPass(std::make_unique<SumIfToCountIfPass>());\n     manager.addPass(std::make_unique<RewriteArrayExistsToHasPass>());\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 24be644ee550..4ed04b6ea1ea 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -776,6 +776,7 @@ class IColumn;\n     M(Bool, keeper_map_strict_mode, false, \"Enforce additional checks during operations on KeeperMap. E.g. throw an exception on an insert for already existing key\", 0) \\\n     M(UInt64, extract_kvp_max_pairs_per_row, 1000, \"Max number pairs that can be produced by extractKeyValuePairs function. Used to safeguard against consuming too much memory.\", 0) \\\n     M(Timezone, session_timezone, \"\", \"This setting can be removed in the future due to potential caveats. It is experimental and is not suitable for production usage. The default timezone for current session or query. The server default timezone if empty.\", 0) \\\n+    M(Bool, optimize_uniq_to_count, false, \"Rewrite uniq and its variants(except uniqUpTo) to count if subquery has distinct or group by clause.\", 0) \\\n     M(Bool, allow_create_index_without_type, false, \"Allow CREATE INDEX query without TYPE. Query will be ignored. Made for SQL compatibility tests.\", 0)\\\n     // End of COMMON_SETTINGS\n     // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS and move obsolete settings to OBSOLETE_SETTINGS.\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex d07a65215445..5193c489afe5 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -39,6 +39,7 @@\n #include <Interpreters/QueryLog.h>\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n #include <Interpreters/RewriteCountDistinctVisitor.h>\n+#include <Interpreters/RewriteUniqToCountVisitor.h>\n #include <Interpreters/getCustomKeyFilterForParallelReplicas.h>\n \n #include <QueryPipeline/Pipe.h>\n@@ -426,6 +427,12 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n         RewriteCountDistinctFunctionVisitor(data_rewrite_countdistinct).visit(query_ptr);\n     }\n \n+    if (settings.optimize_uniq_to_count)\n+    {\n+        RewriteUniqToCountMatcher::Data data_rewrite_uniq_count;\n+        RewriteUniqToCountVisitor(data_rewrite_uniq_count).visit(query_ptr);\n+    }\n+\n     JoinedTables joined_tables(getSubqueryContext(context), getSelectQuery(), options.with_all_cols, options_.is_create_parameterized_view);\n \n     bool got_storage_from_query = false;\ndiff --git a/src/Interpreters/RewriteUniqToCountVisitor.cpp b/src/Interpreters/RewriteUniqToCountVisitor.cpp\nnew file mode 100644\nindex 000000000000..7445068207ab\n--- /dev/null\n+++ b/src/Interpreters/RewriteUniqToCountVisitor.cpp\n@@ -0,0 +1,163 @@\n+#include <Interpreters/RewriteUniqToCountVisitor.h>\n+\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/parseQuery.h>\n+\n+\n+namespace DB\n+{\n+\n+using Aliases = std::unordered_map<String, ASTPtr>;\n+\n+namespace\n+{\n+\n+bool matchFnUniq(String func_name)\n+{\n+    auto name = Poco::toLower(func_name);\n+    return name == \"uniq\" || name == \"uniqHLL12\" || name == \"uniqExact\" || name == \"uniqTheta\" || name == \"uniqCombined\"\n+        || name == \"uniqCombined64\";\n+}\n+\n+bool expressionEquals(const ASTPtr & lhs, const ASTPtr & rhs, const Aliases & alias)\n+{\n+    if (lhs->getTreeHash() == rhs->getTreeHash())\n+    {\n+        return true;\n+    }\n+    else\n+    {\n+        auto * lhs_idf = lhs->as<ASTIdentifier>();\n+        auto * rhs_idf = rhs->as<ASTIdentifier>();\n+        if (lhs_idf && rhs_idf)\n+        {\n+            /// compound identifiers, such as: <t.name, name>\n+            if (lhs_idf->shortName() == rhs_idf->shortName())\n+                return true;\n+\n+            /// translate alias\n+            if (alias.find(lhs_idf->shortName()) != alias.end())\n+                lhs_idf = alias.find(lhs_idf->shortName())->second->as<ASTIdentifier>();\n+\n+            if (alias.find(rhs_idf->shortName()) != alias.end())\n+                rhs_idf = alias.find(rhs_idf->shortName())->second->as<ASTIdentifier>();\n+\n+            if (lhs_idf->shortName() == rhs_idf->shortName())\n+                return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool expressionListEquals(ASTExpressionList * lhs, ASTExpressionList * rhs, const Aliases & alias)\n+{\n+    if (!lhs || !rhs)\n+        return false;\n+    if (lhs->children.size() != rhs->children.size())\n+        return false;\n+    for (size_t i = 0; i < lhs->children.size(); i++)\n+    {\n+        if (!expressionEquals(lhs->children[i], rhs->children[i], alias))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+/// Test whether lhs contains all expressions in rhs.\n+bool expressionListContainsAll(ASTExpressionList * lhs, ASTExpressionList * rhs, const Aliases & alias)\n+{\n+    if (!lhs || !rhs)\n+        return false;\n+    if (lhs->children.size() < rhs->children.size())\n+        return false;\n+    for (const auto & re : rhs->children)\n+    {\n+        auto predicate = [&re, &alias](ASTPtr & le) { return expressionEquals(le, re, alias); };\n+        if (std::find_if(lhs->children.begin(), lhs->children.end(), predicate) == lhs->children.end())\n+            return false;\n+    }\n+    return true;\n+}\n+\n+}\n+\n+void RewriteUniqToCountMatcher::visit(ASTPtr & ast, Data & /*data*/)\n+{\n+    auto * selectq = ast->as<ASTSelectQuery>();\n+    if (!selectq || !selectq->tables() || selectq->tables()->children.size() != 1)\n+        return;\n+    auto expr_list = selectq->select();\n+    if (!expr_list || expr_list->children.size() != 1)\n+        return;\n+    auto * func = expr_list->children[0]->as<ASTFunction>();\n+    if (!func || !matchFnUniq(func->name))\n+        return;\n+    if (selectq->tables()->as<ASTTablesInSelectQuery>()->children[0]->as<ASTTablesInSelectQueryElement>()->children.size() != 1)\n+        return;\n+    auto * table_expr = selectq->tables()\n+                            ->as<ASTTablesInSelectQuery>()\n+                            ->children[0]\n+                            ->as<ASTTablesInSelectQueryElement>()\n+                            ->children[0]\n+                            ->as<ASTTableExpression>();\n+    if (!table_expr || table_expr->children.size() != 1 || !table_expr->subquery)\n+        return;\n+    auto * subquery = table_expr->subquery->as<ASTSubquery>();\n+    if (!subquery)\n+        return;\n+    auto * sub_selectq = subquery->children[0]\n+                             ->as<ASTSelectWithUnionQuery>()->children[0]\n+                             ->as<ASTExpressionList>()->children[0]\n+                             ->as<ASTSelectQuery>();\n+    if (!sub_selectq)\n+        return;\n+    auto sub_expr_list = sub_selectq->select();\n+    if (!sub_expr_list)\n+        return;\n+\n+    /// collect subquery select expressions alias\n+    Aliases alias;\n+    for (const auto & expr : sub_expr_list->children)\n+    {\n+        if (!expr->tryGetAlias().empty())\n+            alias.insert({expr->tryGetAlias(), expr});\n+    }\n+\n+    /// Whether query matches 'SELECT uniq(x ...) FROM (SELECT DISTINCT x ...)'\n+    auto match_subquery_with_distinct = [&]() -> bool\n+    {\n+        if (!sub_selectq->distinct)\n+            return false;\n+        /// uniq expression list == subquery group by expression list\n+        if (!expressionListEquals(func->children[0]->as<ASTExpressionList>(), sub_expr_list->as<ASTExpressionList>(), alias))\n+            return false;\n+        return true;\n+    };\n+\n+    /// Whether query matches 'SELECT uniq(x ...) FROM (SELECT x ... GROUP BY x ...)'\n+    auto match_subquery_with_group_by = [&]() -> bool\n+    {\n+        auto group_by = sub_selectq->groupBy();\n+        if (!group_by)\n+            return false;\n+        /// uniq expression list == subquery group by expression list\n+        if (!expressionListEquals(func->children[0]->as<ASTExpressionList>(), group_by->as<ASTExpressionList>(), alias))\n+            return false;\n+        /// subquery select expression list must contain all columns in uniq expression list\n+        if (!expressionListContainsAll(sub_expr_list->as<ASTExpressionList>(), func->children[0]->as<ASTExpressionList>(), alias))\n+            return false;\n+        return true;\n+    };\n+\n+    if (match_subquery_with_distinct() || match_subquery_with_group_by())\n+        expr_list->children[0] = makeASTFunction(\"count\");\n+}\n+\n+}\ndiff --git a/src/Interpreters/RewriteUniqToCountVisitor.h b/src/Interpreters/RewriteUniqToCountVisitor.h\nnew file mode 100644\nindex 000000000000..94528ccf2ee3\n--- /dev/null\n+++ b/src/Interpreters/RewriteUniqToCountVisitor.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include \"Interpreters/TreeRewriter.h\"\n+\n+namespace DB\n+{\n+\n+class ASTFunction;\n+\n+/** Optimize `uniq` into `count` over subquery.\n+ *     Example: 'SELECT uniq(x ...) FROM (SELECT DISTINCT x ...)' to\n+ *     Result: 'SELECT count() FROM (SELECT DISTINCT x ...)'\n+ *\n+ *     Example: 'SELECT uniq(x ...) FROM (SELECT x ... GROUP BY x ...)' to\n+ *     Result: 'SELECT count() FROM (SELECT x ... GROUP BY x ...)'\n+ *\n+ *     Note that we can rewrite all uniq variants except uniqUpTo.\n+ */\n+class RewriteUniqToCountMatcher\n+{\n+public:\n+    struct Data {};\n+    static void visit(ASTPtr & ast, Data &);\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }\n+};\n+\n+using RewriteUniqToCountVisitor = InDepthNodeVisitor<RewriteUniqToCountMatcher, true>;\n+}\n",
  "test_patch": "diff --git a/tests/integration/test_rewrite_uniq_to_count/__init__.py b/tests/integration/test_rewrite_uniq_to_count/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_rewrite_uniq_to_count/test.py b/tests/integration/test_rewrite_uniq_to_count/test.py\nnew file mode 100644\nindex 000000000000..e38e57f5cee9\n--- /dev/null\n+++ b/tests/integration/test_rewrite_uniq_to_count/test.py\n@@ -0,0 +1,127 @@\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+node = cluster.add_instance(\"node\")\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        prepare()\n+        yield cluster\n+    finally:\n+        shutdown()\n+        cluster.shutdown()\n+\n+\n+def prepare():\n+    node.query(\n+        \"\"\"\n+        CREATE TABLE IF NOT EXISTS test_rewrite_uniq_to_count\n+        (\n+            `a` UInt8,\n+            `b` UInt8,\n+            `c` UInt8\n+        )\n+        ENGINE = MergeTree\n+        ORDER BY `a`\n+        \"\"\"\n+    )\n+    node.query(\n+        \"INSERT INTO test_rewrite_uniq_to_count values ('1', '1', '1'), ('1', '1', '1')\"\n+    )\n+    node.query(\n+        \"INSERT INTO test_rewrite_uniq_to_count values ('2', '2', '2'), ('2', '2', '2')\"\n+    )\n+    node.query(\n+        \"INSERT INTO test_rewrite_uniq_to_count values ('3', '3', '3'), ('3', '3', '3')\"\n+    )\n+\n+\n+def shutdown():\n+    node.query(\"DROP TABLE IF EXISTS test_rewrite_uniq_to_count SYNC\")\n+\n+\n+def check(query, result):\n+    # old analyzer\n+    query = query + \" settings optimize_uniq_to_count = 1\"\n+    assert node.query(query) == f\"{result}\\n\"\n+    assert \"count()\" in node.query(\"EXPLAIN SYNTAX \" + query)\n+\n+    # new analyzer\n+    query = query + \", allow_experimental_analyzer = 1\"\n+    assert node.query(query) == f\"{result}\\n\"\n+    assert \"count()\" in node.query(\"EXPLAIN QUERY TREE \" + query)\n+\n+\n+def check_by_old_analyzer(query, result):\n+    # only old analyzer\n+    query = query + \" settings optimize_uniq_to_count = 1\"\n+    assert node.query(query) == f\"{result}\\n\"\n+    assert \"count()\" in node.query(\"EXPLAIN SYNTAX \" + query)\n+\n+\n+def test_rewrite_distinct(started_cluster):\n+    # simple test\n+    check(\n+        \"SELECT uniq(a) FROM (SELECT DISTINCT a FROM test_rewrite_uniq_to_count)\",\n+        3,\n+    )\n+\n+    # test subquery alias\n+    check(\n+        \"SELECT uniq(t.a) FROM (SELECT DISTINCT a FROM test_rewrite_uniq_to_count) t\",\n+        3,\n+    )\n+\n+    # test compound column name\n+    check(\n+        \"SELECT uniq(a) FROM (SELECT DISTINCT test_rewrite_uniq_to_count.a FROM test_rewrite_uniq_to_count) t\",\n+        3,\n+    )\n+\n+    # test select expression alias\n+    check(\n+        \"SELECT uniq(alias_of_a) FROM (SELECT DISTINCT test_rewrite_uniq_to_count.a as alias_of_a FROM test_rewrite_uniq_to_count) t\",\n+        3,\n+    )\n+\n+    # test select expression alias\n+    check(\n+        \"SELECT uniq(alias_of_a) FROM (SELECT DISTINCT a as alias_of_a FROM test_rewrite_uniq_to_count) t\",\n+        3,\n+    )\n+\n+\n+def test_rewrite_group_by(started_cluster):\n+    # simple test\n+    check(\n+        \"SELECT uniq(a) FROM (SELECT a, sum(b) FROM test_rewrite_uniq_to_count GROUP BY a)\",\n+        3,\n+    )\n+\n+    # test subquery alias\n+    check(\n+        \"SELECT uniq(t.a) FROM (SELECT a, sum(b) FROM test_rewrite_uniq_to_count GROUP BY a) t\",\n+        3,\n+    )\n+\n+    # test select expression alias\n+    check(\n+        \"SELECT uniq(t.alias_of_a) FROM (SELECT a as alias_of_a, sum(b) FROM test_rewrite_uniq_to_count GROUP BY a) t\",\n+        3,\n+    )\n+\n+    # test select expression alias\n+    check(\n+        \"SELECT uniq(t.alias_of_a) FROM (SELECT a as alias_of_a, sum(b) FROM test_rewrite_uniq_to_count GROUP BY alias_of_a) t\",\n+        3,\n+    )\n+\n+    # test select expression alias\n+    check(\n+        \"SELECT uniq(t.alias_of_a) FROM (SELECT a as alias_of_a, sum(b) FROM test_rewrite_uniq_to_count GROUP BY a) t\",\n+        3,\n+    )\n",
  "problem_statement": "Rewrite `uniq` to `count` if a subquery returns distinct values.\n```\r\nSELECT uniq(x) FROM (SELECT DISTINCT x ...)\r\n```\r\n\r\ncan be rewritten to\r\n\r\n```\r\nSELECT count() FROM (SELECT DISTINCT x ...)\r\n```\r\n\r\nas well as\r\n\r\n```\r\nSELECT uniq() FROM (SELECT x ... GROUP BY x)\r\n```\r\n\r\nIt can apply to all variants of the `uniq` functions except `uniqUpTo`.\r\n\r\nThe optimization could be implemented on a query pipeline basis.\n",
  "hints_text": "@alexey-milovidov Please assign it to me.\n@JackyWoo, thank you, looking forward to a PR!\n@alexey-milovidov Thanks I will start it this week.",
  "created_at": "2023-07-10T09:16:16Z",
  "modified_files": [
    "b/src/Analyzer/Passes/UniqToCountPass.cpp",
    "b/src/Analyzer/Passes/UniqToCountPass.h",
    "src/Analyzer/QueryTreePassManager.cpp",
    "src/Core/Settings.h",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "b/src/Interpreters/RewriteUniqToCountVisitor.cpp",
    "b/src/Interpreters/RewriteUniqToCountVisitor.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_rewrite_uniq_to_count/test.py"
  ]
}