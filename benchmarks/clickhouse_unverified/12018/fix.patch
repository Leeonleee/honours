diff --git a/src/Functions/FunctionDateOrDateTimeAddInterval.h b/src/Functions/FunctionDateOrDateTimeAddInterval.h
index d63c4c2db55c..eaed159c17b6 100644
--- a/src/Functions/FunctionDateOrDateTimeAddInterval.h
+++ b/src/Functions/FunctionDateOrDateTimeAddInterval.h
@@ -324,13 +324,16 @@ struct DateTimeAddIntervalImpl
             const IColumn & delta_column = *block.getByPosition(arguments[1]).column;
 
             if (const auto * delta_const_column = typeid_cast<const ColumnConst *>(&delta_column))
-                op.vectorConstant(sources->getData(), col_to->getData(), delta_const_column->getField().get<Int64>(), time_zone);
+                op.vectorConstant(sources->getData(), col_to->getData(), delta_const_column->getInt(0), time_zone);
             else
                 op.vectorVector(sources->getData(), col_to->getData(), delta_column, time_zone);
         }
         else if (const auto * sources_const = checkAndGetColumnConst<FromColumnType>(source_col.get()))
         {
-            op.constantVector(sources_const->template getValue<FromValueType>(), col_to->getData(), *block.getByPosition(arguments[1]).column, time_zone);
+            op.constantVector(
+                sources_const->template getValue<FromValueType>(),
+                col_to->getData(),
+                *block.getByPosition(arguments[1]).column, time_zone);
         }
         else
         {
@@ -390,6 +393,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
         {
             if (!WhichDataType(arguments[0].type).isDateTime()
                 || !WhichDataType(arguments[2].type).isString())
+            {
                 throw Exception(
                     "Function " + getName() + " supports 2 or 3 arguments. The 1st argument "
                     "must be of type Date or DateTime. The 2nd argument must be number. "
@@ -397,6 +401,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
                     "a constant string with timezone name. The timezone argument is allowed "
                     "only when the 1st argument has the type DateTime",
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            }
         }
 
         switch (arguments[0].type->getTypeId())
@@ -416,7 +421,8 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
         }
     }
 
-    // Helper templates to deduce return type based on argument type, since some overloads may promote or denote types, e.g. addSeconds(Date, 1) => DateTime
+    /// Helper templates to deduce return type based on argument type, since some overloads may promote or denote types,
+    /// e.g. addSeconds(Date, 1) => DateTime
     template <typename FieldType>
     using TransformExecuteReturnType = decltype(std::declval<Transform>().execute(FieldType(), 0, std::declval<DateLUTImpl>()));
 
@@ -463,15 +469,18 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
 
         if (which.isDate())
         {
-            DateTimeAddIntervalImpl<DataTypeDate, TransformResultDataType<DataTypeDate>, Transform>::execute(Transform{}, block, arguments, result);
+            DateTimeAddIntervalImpl<DataTypeDate, TransformResultDataType<DataTypeDate>, Transform>::execute(
+                Transform{}, block, arguments, result);
         }
         else if (which.isDateTime())
         {
-            DateTimeAddIntervalImpl<DataTypeDateTime, TransformResultDataType<DataTypeDateTime>, Transform>::execute(Transform{}, block, arguments, result);
+            DateTimeAddIntervalImpl<DataTypeDateTime, TransformResultDataType<DataTypeDateTime>, Transform>::execute(
+                Transform{}, block, arguments, result);
         }
         else if (const auto * datetime64_type = assert_cast<const DataTypeDateTime64 *>(from_type))
         {
-            DateTimeAddIntervalImpl<DataTypeDateTime64, TransformResultDataType<DataTypeDateTime64>, Transform>::execute(Transform{datetime64_type->getScale()}, block, arguments, result);
+            DateTimeAddIntervalImpl<DataTypeDateTime64, TransformResultDataType<DataTypeDateTime64>, Transform>::execute(
+                Transform{datetime64_type->getScale()}, block, arguments, result);
         }
         else
             throw Exception("Illegal type " + block.getByPosition(arguments[0]).type->getName() + " of first argument of function " + getName(),
diff --git a/src/Functions/FunctionsJSON.h b/src/Functions/FunctionsJSON.h
index 7bd69ea770dc..e574149f2e93 100644
--- a/src/Functions/FunctionsJSON.h
+++ b/src/Functions/FunctionsJSON.h
@@ -221,9 +221,9 @@ class FunctionJSON : public IFunction
                 {
                     const auto & column_const = assert_cast<const ColumnConst &>(*column.column);
                     if (isString(column.type))
-                        moves.emplace_back(MoveType::ConstKey, column_const.getField().get<String>());
+                        moves.emplace_back(MoveType::ConstKey, column_const.getValue<String>());
                     else
-                        moves.emplace_back(MoveType::ConstIndex, column_const.getField().get<Int64>());
+                        moves.emplace_back(MoveType::ConstIndex, column_const.getInt(0));
                 }
                 else
                 {
diff --git a/src/Functions/extractTimeZoneFromFunctionArguments.h b/src/Functions/extractTimeZoneFromFunctionArguments.h
index dea740f0ae52..74539939fa0d 100644
--- a/src/Functions/extractTimeZoneFromFunctionArguments.h
+++ b/src/Functions/extractTimeZoneFromFunctionArguments.h
@@ -13,7 +13,10 @@ namespace DB
 class Block;
 
 /// Determine working timezone either from optional argument with time zone name or from time zone in DateTime type of argument.
-std::string extractTimeZoneNameFromFunctionArguments(const ColumnsWithTypeAndName & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);
-const DateLUTImpl & extractTimeZoneFromFunctionArguments(Block & block, const ColumnNumbers & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);
+std::string extractTimeZoneNameFromFunctionArguments(
+    const ColumnsWithTypeAndName & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);
+
+const DateLUTImpl & extractTimeZoneFromFunctionArguments(
+    Block & block, const ColumnNumbers & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);
 
 }
diff --git a/src/Functions/getScalar.cpp b/src/Functions/getScalar.cpp
index a6e9d00148ee..ef5e7e050298 100644
--- a/src/Functions/getScalar.cpp
+++ b/src/Functions/getScalar.cpp
@@ -43,7 +43,7 @@ class FunctionGetScalar : public IFunction
     {
         if (arguments.size() != 1 || !isString(arguments[0].type) || !arguments[0].column || !isColumnConst(*arguments[0].column))
             throw Exception("Function " + getName() + " accepts one const string argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        auto scalar_name = assert_cast<const ColumnConst &>(*arguments[0].column).getField().get<String>();
+        auto scalar_name = assert_cast<const ColumnConst &>(*arguments[0].column).getValue<String>();
         scalar = context.getScalar(scalar_name).getByPosition(0);
         return scalar.type;
     }
