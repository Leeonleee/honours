diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md
index 4df987b5e2a5..4b6e03563013 100644
--- a/docs/en/sql-reference/functions/string-functions.md
+++ b/docs/en/sql-reference/functions/string-functions.md
@@ -429,7 +429,7 @@ SELECT format('{} {}', 'Hello', 'World')
 
 ## concat
 
-Concatenates the strings listed in the arguments without separator.
+Concatenates the given arguments.
 
 **Syntax**
 
@@ -439,7 +439,9 @@ concat(s1, s2, ...)
 
 **Arguments**
 
-Values of type String or FixedString.
+At least two values of arbitrary type.
+
+Arguments which are not of types [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md) are converted to strings using their default serialization. As this decreases performance, it is not recommended to use non-String/FixedString arguments.
 
 **Returned values**
 
@@ -449,6 +451,8 @@ If any of arguments is `NULL`, the function returns `NULL`.
 
 **Example**
 
+Query:
+
 ``` sql
 SELECT concat('Hello, ', 'World!');
 ```
@@ -461,6 +465,20 @@ Result:
 └─────────────────────────────┘
 ```
 
+Query:
+
+```sql
+SELECT concat(42, 144);
+```
+
+Result:
+
+```result
+┌─concat(42, 144)─┐
+│ 42144           │
+└─────────────────┘
+```
+
 ## concatAssumeInjective
 
 Like [concat](#concat) but assumes that `concat(s1, s2, ...) → sn` is injective. Can be used for optimization of GROUP BY.
@@ -526,6 +544,8 @@ Concatenates the given strings with a given separator.
 concatWithSeparator(sep, expr1, expr2, expr3...)
 ```
 
+Alias: `concat_ws`
+
 **Arguments**
 
 - sep — separator. Const [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).
diff --git a/src/Columns/ColumnStringHelpers.h b/src/Columns/ColumnStringHelpers.h
index 851486e490ad..97b52506ae0e 100644
--- a/src/Columns/ColumnStringHelpers.h
+++ b/src/Columns/ColumnStringHelpers.h
@@ -62,7 +62,7 @@ class WriteHelper
         return buffer;
     }
 
-    inline void rowWritten()
+    void rowWritten()
     {
         if constexpr (std::is_same_v<ColumnType, ColumnFixedString>)
         {
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index e3ec7ebd3201..d7c2c70884b6 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -1247,9 +1247,9 @@ struct ConvertImplGenericToString
 
             FormatSettings format_settings;
             auto serialization = type.getDefaultSerialization();
-            for (size_t i = 0; i < size; ++i)
+            for (size_t row = 0; row < size; ++row)
             {
-                serialization->serializeText(col_from, i, write_buffer, format_settings);
+                serialization->serializeText(col_from, row, write_buffer, format_settings);
                 write_helper.rowWritten();
             }
 
diff --git a/src/Functions/concat.cpp b/src/Functions/concat.cpp
index 9eb222d8c093..f426f662868e 100644
--- a/src/Functions/concat.cpp
+++ b/src/Functions/concat.cpp
@@ -2,14 +2,13 @@
 #include <DataTypes/DataTypeString.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
+#include <Functions/FunctionsConversion.h>
 #include <Functions/GatherUtils/Algorithms.h>
 #include <Functions/GatherUtils/Sinks.h>
-#include <Functions/GatherUtils/Slices.h>
 #include <Functions/GatherUtils/Sources.h>
 #include <Functions/IFunction.h>
 #include <IO/WriteHelpers.h>
 #include <base/map.h>
-#include <base/range.h>
 
 #include "formatString.h"
 
@@ -17,9 +16,7 @@ namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
-    extern const int ILLEGAL_COLUMN;
+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
 }
 
 using namespace GatherUtils;
@@ -32,7 +29,7 @@ class ConcatImpl : public IFunction
 {
 public:
     static constexpr auto name = Name::name;
-    explicit ConcatImpl(ContextPtr context_) : context(context_) {}
+    explicit ConcatImpl(ContextPtr context_) : context(context_) { }
     static FunctionPtr create(ContextPtr context) { return std::make_shared<ConcatImpl>(context); }
 
     String getName() const override { return name; }
@@ -56,18 +53,6 @@ class ConcatImpl : public IFunction
                 getName(),
                 arguments.size());
 
-        for (const auto arg_idx : collections::range(0, arguments.size()))
-        {
-            const auto * arg = arguments[arg_idx].get();
-            if (!isStringOrFixedString(arg))
-                throw Exception(
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Illegal type {} of argument {} of function {}",
-                    arg->getName(),
-                    arg_idx + 1,
-                    getName());
-        }
-
         return std::make_shared<DataTypeString>();
     }
 
@@ -76,11 +61,10 @@ class ConcatImpl : public IFunction
         /// Format function is not proven to be faster for two arguments.
         /// Actually there is overhead of 2 to 5 extra instructions for each string for checking empty strings in FormatImpl.
         /// Though, benchmarks are really close, for most examples we saw executeBinary is slightly faster (0-3%).
-        /// For 3 and more arguments FormatImpl is much faster (up to 50-60%).
+        /// For 3 and more arguments FormatStringImpl is much faster (up to 50-60%).
         if (arguments.size() == 2)
             return executeBinary(arguments, input_rows_count);
-        else
-            return executeFormatImpl(arguments, input_rows_count);
+        return executeFormatImpl(arguments, input_rows_count);
     }
 
 private:
@@ -123,6 +107,7 @@ class ConcatImpl : public IFunction
         std::vector<const ColumnString::Offsets *> offsets(num_arguments);
         std::vector<size_t> fixed_string_sizes(num_arguments);
         std::vector<std::optional<String>> constant_strings(num_arguments);
+        std::vector<ColumnString::MutablePtr> converted_col_ptrs(num_arguments);
         bool has_column_string = false;
         bool has_column_fixed_string = false;
         for (size_t i = 0; i < num_arguments; ++i)
@@ -145,8 +130,29 @@ class ConcatImpl : public IFunction
                 constant_strings[i] = const_col->getValue<String>();
             }
             else
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}",
-                    column->getName(), getName());
+            {
+                /// A non-String/non-FixedString-type argument: use the default serialization to convert it to String
+                auto full_column = column->convertToFullIfNeeded();
+                auto serialization = arguments[i].type->getDefaultSerialization();
+                auto converted_col_str = ColumnString::create();
+                ColumnStringHelpers::WriteHelper write_helper(*converted_col_str, column->size());
+                auto & write_buffer = write_helper.getWriteBuffer();
+                FormatSettings format_settings;
+                for (size_t row = 0; row < column->size(); ++row)
+                {
+                    serialization->serializeText(*full_column, row, write_buffer, format_settings);
+                    write_helper.rowWritten();
+                }
+                write_helper.finalize();
+
+                /// Same as the normal `ColumnString` branch
+                has_column_string = true;
+                data[i] = &converted_col_str->getChars();
+                offsets[i] = &converted_col_str->getOffsets();
+
+                /// Keep the pointer alive
+                converted_col_ptrs[i] = std::move(converted_col_str);
+            }
         }
 
         String pattern;
@@ -155,7 +161,7 @@ class ConcatImpl : public IFunction
         for (size_t i = 0; i < num_arguments; ++i)
             pattern += "{}";
 
-        FormatImpl::formatExecute(
+        FormatStringImpl::formatExecute(
             has_column_string,
             has_column_fixed_string,
             std::move(pattern),
@@ -185,14 +191,15 @@ using FunctionConcat = ConcatImpl<NameConcat, false>;
 using FunctionConcatAssumeInjective = ConcatImpl<NameConcatAssumeInjective, true>;
 
 
-/// Also works with arrays.
+/// Works with arrays via `arrayConcat`, maps via `mapConcat`, and tuples via `tupleConcat`.
+/// Additionally, allows concatenation of arbitrary types that can be cast to string using the corresponding default serialization.
 class ConcatOverloadResolver : public IFunctionOverloadResolver
 {
 public:
     static constexpr auto name = "concat";
     static FunctionOverloadResolverPtr create(ContextPtr context) { return std::make_unique<ConcatOverloadResolver>(context); }
 
-    explicit ConcatOverloadResolver(ContextPtr context_) : context(context_) {}
+    explicit ConcatOverloadResolver(ContextPtr context_) : context(context_) { }
 
     String getName() const override { return name; }
     size_t getNumberOfArguments() const override { return 0; }
@@ -200,29 +207,26 @@ class ConcatOverloadResolver : public IFunctionOverloadResolver
 
     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override
     {
-        if (isArray(arguments.at(0).type))
-        {
+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isArray(elem.type); }))
             return FunctionFactory::instance().getImpl("arrayConcat", context)->build(arguments);
-        }
-        else if (isMap(arguments.at(0).type))
-        {
+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isMap(elem.type); }))
             return FunctionFactory::instance().getImpl("mapConcat", context)->build(arguments);
-        }
-        else if (isTuple(arguments.at(0).type))
-        {
+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isTuple(elem.type); }))
             return FunctionFactory::instance().getImpl("tupleConcat", context)->build(arguments);
-        }
-        else
-            return std::make_unique<FunctionToFunctionBaseAdaptor>(
-                FunctionConcat::create(context), collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }), return_type);
+        return std::make_unique<FunctionToFunctionBaseAdaptor>(
+            FunctionConcat::create(context),
+            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),
+            return_type);
     }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (arguments.size() < 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
                 "Number of arguments for function {} doesn't match: passed {}, should be at least 2.",
-                getName(), arguments.size());
+                getName(),
+                arguments.size());
 
         /// We always return Strings from concat, even if arguments were fixed strings.
         return std::make_shared<DataTypeString>();
diff --git a/src/Functions/concatWithSeparator.cpp b/src/Functions/concatWithSeparator.cpp
index bfd1bc392db1..f295d86943f9 100644
--- a/src/Functions/concatWithSeparator.cpp
+++ b/src/Functions/concatWithSeparator.cpp
@@ -1,5 +1,5 @@
-#include <Columns/ColumnString.h>
 #include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnString.h>
 #include <DataTypes/DataTypeString.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
@@ -14,9 +14,9 @@ namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
-    extern const int ILLEGAL_COLUMN;
+extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+extern const int ILLEGAL_COLUMN;
 }
 
 namespace
@@ -26,7 +26,7 @@ class ConcatWithSeparatorImpl : public IFunction
 {
 public:
     static constexpr auto name = Name::name;
-    explicit ConcatWithSeparatorImpl(ContextPtr context_) : context(context_) {}
+    explicit ConcatWithSeparatorImpl(ContextPtr context_) : context(context_) { }
 
     static FunctionPtr create(ContextPtr context) { return std::make_shared<ConcatWithSeparatorImpl>(context); }
 
@@ -113,8 +113,7 @@ class ConcatWithSeparatorImpl : public IFunction
             else if (const ColumnConst * const_col = checkAndGetColumnConstStringOrFixedString(column.get()))
                 constant_strings[2 * i] = const_col->getValue<String>();
             else
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN,
-                    "Illegal column {} of argument of function {}", column->getName(), getName());
+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}", column->getName(), getName());
         }
 
         String pattern;
@@ -122,7 +121,7 @@ class ConcatWithSeparatorImpl : public IFunction
         for (size_t i = 0; i < num_args; ++i)
             pattern += "{}";
 
-        FormatImpl::formatExecute(
+        FormatStringImpl::formatExecute(
             has_column_string,
             has_column_fixed_string,
             std::move(pattern),
@@ -156,14 +155,14 @@ using FunctionConcatWithSeparatorAssumeInjective = ConcatWithSeparatorImpl<NameC
 REGISTER_FUNCTION(ConcatWithSeparator)
 {
     factory.registerFunction<FunctionConcatWithSeparator>(FunctionDocumentation{
-        .description=R"(
+        .description = R"(
 Returns the concatenation strings separated by string separator. Syntax: concatWithSeparator(sep, expr1, expr2, expr3...)
         )",
         .examples{{"concatWithSeparator", "SELECT concatWithSeparator('a', '1', '2', '3')", ""}},
         .categories{"String"}});
 
     factory.registerFunction<FunctionConcatWithSeparatorAssumeInjective>(FunctionDocumentation{
-        .description=R"(
+        .description = R"(
 Same as concatWithSeparator, the difference is that you need to ensure that concatWithSeparator(sep, expr1, expr2, expr3...) → result is injective, it will be used for optimization of GROUP BY.
 
 The function is named “injective” if it always returns different result for different values of arguments. In other words: different arguments never yield identical result.
@@ -171,7 +170,7 @@ The function is named “injective” if it always returns different result for
         .examples{{"concatWithSeparatorAssumeInjective", "SELECT concatWithSeparatorAssumeInjective('a', '1', '2', '3')", ""}},
         .categories{"String"}});
 
-    /// Compatibility with Spark:
+    /// Compatibility with Spark and MySQL:
     factory.registerAlias("concat_ws", "concatWithSeparator", FunctionFactory::CaseInsensitive);
 }
 
diff --git a/src/Functions/formatString.cpp b/src/Functions/formatString.cpp
index ee6e26b775ad..8e0b3a238cb2 100644
--- a/src/Functions/formatString.cpp
+++ b/src/Functions/formatString.cpp
@@ -110,7 +110,7 @@ class FormatFunction : public IFunction
                     column->getName(), getName());
         }
 
-        FormatImpl::formatExecute(
+        FormatStringImpl::formatExecute(
             has_column_string,
             has_column_fixed_string,
             std::move(pattern),
diff --git a/src/Functions/formatString.h b/src/Functions/formatString.h
index 44fbdac93786..315e5c06227e 100644
--- a/src/Functions/formatString.h
+++ b/src/Functions/formatString.h
@@ -1,24 +1,19 @@
 #pragma once
 
 #include <Columns/ColumnString.h>
-#include <base/types.h>
-#include <Common/Exception.h>
-#include <Common/StringUtils/StringUtils.h>
 #include <Common/format.h>
 #include <Common/memcpySmall.h>
-
+#include <base/types.h>
 
 #include <algorithm>
 #include <optional>
 #include <string>
-#include <utility>
 #include <vector>
 
-
 namespace DB
 {
 
-struct FormatImpl
+struct FormatStringImpl
 {
     static constexpr size_t right_padding = 15;
 
