diff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.cpp b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp
index 17eeba9a152f..dc4a5084c83e 100644
--- a/dbms/src/Compression/CompressionCodecDoubleDelta.cpp
+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp
@@ -26,7 +26,7 @@ extern const int CANNOT_DECOMPRESS;
 namespace
 {
 
-Int64 getMaxValueForByteSize(UInt8 byte_size)
+inline Int64 getMaxValueForByteSize(Int8 byte_size)
 {
     switch (byte_size)
     {
@@ -51,11 +51,56 @@ struct WriteSpec
     const UInt8 data_bits;
 };
 
-const std::array<UInt8, 5> DELTA_SIZES{7, 9, 12, 32, 64};
+// delta size prefix and data lengths based on few high bits peeked from binary stream
+static const WriteSpec WRITE_SPEC_LUT[32] = {
+    // 0b0 - 1-bit prefix, no data to read
+    /* 00000 */ {1, 0b0, 0},
+    /* 00001 */ {1, 0b0, 0},
+    /* 00010 */ {1, 0b0, 0},
+    /* 00011 */ {1, 0b0, 0},
+    /* 00100 */ {1, 0b0, 0},
+    /* 00101 */ {1, 0b0, 0},
+    /* 00110 */ {1, 0b0, 0},
+    /* 00111 */ {1, 0b0, 0},
+    /* 01000 */ {1, 0b0, 0},
+    /* 01001 */ {1, 0b0, 0},
+    /* 01010 */ {1, 0b0, 0},
+    /* 01011 */ {1, 0b0, 0},
+    /* 01100 */ {1, 0b0, 0},
+    /* 01101 */ {1, 0b0, 0},
+    /* 01110 */ {1, 0b0, 0},
+    /* 01111 */ {1, 0b0, 0},
+
+    // 0b10 - 2 bit prefix, 7 bits of data
+    /* 10000 */ {2, 0b10, 7},
+    /* 10001 */ {2, 0b10, 7},
+    /* 10010 */ {2, 0b10, 7},
+    /* 10011 */ {2, 0b10, 7},
+    /* 10100 */ {2, 0b10, 7},
+    /* 10101 */ {2, 0b10, 7},
+    /* 10110 */ {2, 0b10, 7},
+    /* 10111 */ {2, 0b10, 7},
+
+    // 0b110 - 3 bit prefix, 9 bits of data
+    /* 11000 */ {3, 0b110, 9},
+    /* 11001 */ {3, 0b110, 9},
+    /* 11010 */ {3, 0b110, 9},
+    /* 11011 */ {3, 0b110, 9},
+
+    // 0b1110 - 4 bit prefix, 12 bits of data
+    /* 11100 */ {4, 0b1110, 12},
+    /* 11101 */ {4, 0b1110, 12},
+
+    // 5-bit prefixes
+    /* 11110 */ {5, 0b11110, 32},
+    /* 11111 */ {5, 0b11111, 64},
+};
+
 
 template <typename T>
 WriteSpec getDeltaWriteSpec(const T & value)
 {
+    // TODO: to speed up things a bit by counting number of leading zeroes instead of doing lots of comparisons
     if (value > -63 && value < 64)
     {
         return WriteSpec{2, 0b10, 7};
@@ -107,14 +152,15 @@ UInt32 getCompressedDataSize(UInt8 data_bytes_size, UInt32 uncompressed_size)
 template <typename ValueType>
 UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)
 {
-    // Since only unsinged int has granted 2-compliment overflow handling, we are doing math here on unsigned types.
-    // To simplify and booletproof code, we operate enforce ValueType to be unsigned too.
+    // Since only unsinged int has granted 2-complement overflow handling,
+    // we are doing math here only on unsigned types.
+    // To simplify and booletproof code, we enforce ValueType to be unsigned too.
     static_assert(is_unsigned_v<ValueType>, "ValueType must be unsigned.");
     using UnsignedDeltaType = ValueType;
 
     // We use signed delta type to turn huge unsigned values into smaller signed:
     // ffffffff => -1
-    using SignedDeltaType = typename std::make_signed<UnsignedDeltaType>::type;
+    using SignedDeltaType = typename std::make_signed_t<UnsignedDeltaType>;
 
     if (source_size % sizeof(ValueType) != 0)
         throw Exception("Cannot compress, data size " + toString(source_size)
@@ -149,8 +195,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)
         prev_value = curr_value;
     }
 
-    WriteBuffer buffer(dest, getCompressedDataSize(sizeof(ValueType), source_size - sizeof(ValueType)*2));
-    BitWriter writer(buffer);
+    BitWriter writer(dest, getCompressedDataSize(sizeof(ValueType), source_size - sizeof(ValueType)*2));
 
     int item = 2;
     for (; source < source_end; source += sizeof(ValueType), ++item)
@@ -170,7 +215,8 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)
         else
         {
             const SignedDeltaType signed_dd = static_cast<SignedDeltaType>(double_delta);
-            const auto sign = std::signbit(signed_dd);
+            const auto sign = signed_dd < 0;
+
             // -1 shirnks dd down to fit into number of bits, and there can't be 0, so it is OK.
             const auto abs_value = static_cast<UnsignedDeltaType>(std::abs(signed_dd) - 1);
             const auto write_spec = getDeltaWriteSpec(signed_dd);
@@ -183,7 +229,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)
 
     writer.flush();
 
-    return sizeof(items_count) + sizeof(prev_value) + sizeof(prev_delta) + buffer.count();
+    return sizeof(items_count) + sizeof(prev_value) + sizeof(prev_delta) + writer.count() / 8;
 }
 
 template <typename ValueType>
@@ -220,35 +266,28 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest)
         dest += sizeof(prev_value);
     }
 
-    ReadBufferFromMemory buffer(source, source_size - sizeof(prev_value) - sizeof(prev_delta) - sizeof(items_count));
-    BitReader reader(buffer);
+    BitReader reader(source, source_size - sizeof(prev_value) - sizeof(prev_delta) - sizeof(items_count));
 
     // since data is tightly packed, up to 1 bit per value, and last byte is padded with zeroes,
     // we have to keep track of items to avoid reading more that there is.
     for (UInt32 items_read = 2; items_read < items_count && !reader.eof(); ++items_read)
     {
         UnsignedDeltaType double_delta = 0;
-        if (reader.readBit() == 1)
-        {
-            UInt8 i = 0;
-            for (; i < sizeof(DELTA_SIZES) - 1; ++i)
-            {
-                const auto next_bit = reader.readBit();
-                if (next_bit == 0)
-                {
-                    break;
-                }
-            }
 
+        static_assert(sizeof(WRITE_SPEC_LUT)/sizeof(WRITE_SPEC_LUT[0]) == 32); // 5-bit prefix lookup table
+        const auto write_spec = WRITE_SPEC_LUT[reader.peekByte() >> (8 - 5)]; // only 5 high bits of peeked byte value
+
+        reader.skipBufferedBits(write_spec.prefix_bits); // discard the prefix value, since we've already used it
+        if (write_spec.data_bits != 0)
+        {
             const UInt8 sign = reader.readBit();
-            SignedDeltaType signed_dd = static_cast<SignedDeltaType>(reader.readBits(DELTA_SIZES[i] - 1) + 1);
+            SignedDeltaType signed_dd = static_cast<SignedDeltaType>(reader.readBits(write_spec.data_bits - 1) + 1);
             if (sign)
             {
                 signed_dd *= -1;
             }
             double_delta = static_cast<UnsignedDeltaType>(signed_dd);
         }
-        // else if first bit is zero, no need to read more data.
 
         const UnsignedDeltaType delta = double_delta + prev_delta;
         const ValueType curr_value = prev_value + delta;
diff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.h b/dbms/src/Compression/CompressionCodecDoubleDelta.h
index 19c072141155..6e2e3cdc89e3 100644
--- a/dbms/src/Compression/CompressionCodecDoubleDelta.h
+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.h
@@ -5,6 +5,92 @@
 namespace DB
 {
 
+/** DoubleDelta column codec implementation.
+ *
+ * Based on Gorilla paper: http://www.vldb.org/pvldb/vol8/p1816-teller.pdf, which was extended
+ * to support 64bit types. The drawback is 1 extra bit for 32-byte wide deltas: 5-bit prefix
+ * instead of 4-bit prefix.
+ *
+ * This codec is best used against monotonic integer sequences with constant (or almost contant)
+ * stride, like event timestamp for some monitoring application.
+ *
+ * Given input sequence a: [a0, a1, ... an]:
+ *
+ * First, write number of items (sizeof(int32)*8 bits):                n
+ * Then write first item as is (sizeof(a[0])*8 bits):                  a[0]
+ * Second item is written as delta (sizeof(a[0])*8 bits):              a[1] - a[0]
+ * Loop over remaining items and calculate double delta:
+ *   double_delta = a[i] - 2 * a[i - 1] + a[i - 2]
+ *   Write it in compact binary form with `BitWriter`
+ *   if double_delta == 0:
+ *      write 1bit:                                                    0
+ *   else if -63 < double_delta < 64:
+ *      write 2 bit prefix:                                            10
+ *      write sign bit (1 if signed):                                  x
+ *      write 7-1 bits of abs(double_delta - 1):                       xxxxxx
+ *   else if -255 < double_delta < 256:
+ *      write 3 bit prefix:                                            110
+ *      write sign bit (1 if signed):                                  x
+ *      write 9-1 bits of abs(double_delta - 1):                       xxxxxxxx
+ *   else if -2047 < double_delta < 2048:
+ *      write 4 bit prefix:                                            1110
+ *      write sign bit (1 if signed):                                  x
+ *      write 12-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx
+ *   else if double_delta fits into 32-bit int:
+ *      write 5 bit prefix:                                            11110
+ *      write sign bit (1 if signed):                                  x
+ *      write 32-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx...
+ *   else
+ *      write 5 bit prefix:                                            11111
+ *      write sign bit (1 if signed):                                  x
+ *      write 64-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx...
+ *
+ * @example sequence of UInt8 values [1, 2, 3, 4, 5, 6, 7, 8, 9 10] is encoded as (codec header is ommited):
+ *
+ * .- 4-byte little-endian sequence length (10 == 0xa)
+ * |               .- 1 byte (sizeof(UInt8) a[0]                                            : 0x01
+ * |               |   .- 1 byte of delta: a[1] - a[0] = 2 - 1 = 1                          : 0x01
+ * |               |   |   .- 8 zero bits since double delta for remaining 8 elements was 0 : 0x00
+ * v_______________v___v___v___
+ * \x0a\x00\x00\x00\x01\x01\x00
+ *
+ * @example sequence of Int16 values [-10, 10, -20, 20, -40, 40] is encoded as:
+ *
+ * .- 4-byte little endian sequence length = 6                                 : 0x00000006
+ * |                .- 2 bytes (sizeof(Int16) a[0] as UInt16 = -10             : 0xfff6
+ * |                |       .- 2 bytes of delta: a[1] - a[0] = 10 - (-10) = 20 : 0x0014
+ * |                |       |       .- 4 encoded double deltas (see below)
+ * v_______________ v______ v______ v______________________
+ * \x06\x00\x00\x00\xf6\xff\x14\x00\xb8\xe2\x2e\xb1\xe4\x58
+ *
+ * 4 binary encoded double deltas (\xb8\xe2\x2e\xb1\xe4\x58):
+ * double_delta (DD) = -20 - 2 * 10 + (-10) = -50
+ * .- 2-bit prefix                                                         : 0b10
+ * | .- sign-bit                                                           : 0b1
+ * | |.- abs(DD - 1) = 49                                                  : 0b110001
+ * | ||
+ * | ||      DD = 20 - 2 * (-20) + 10 = 70
+ * | ||      .- 3-bit prefix                                               : 0b110
+ * | ||      |  .- sign bit                                                : 0b0
+ * | ||      |  |.- abs(DD - 1) = 69                                       : 0b1000101
+ * | ||      |  ||
+ * | ||      |  ||        DD = -40 - 2 * 20 + (-20) = -100
+ * | ||      |  ||        .- 3-bit prefix                                  : 0b110
+ * | ||      |  ||        |    .- sign-bit                                 : 0b0
+ * | ||      |  ||        |    |.- abs(DD - 1) = 99                        : 0b1100011
+ * | ||      |  ||        |    ||
+ * | ||      |  ||        |    ||       DD = 40 - 2 * (-40) + 20 = 140
+ * | ||      |  ||        |    ||       .- 3-bit prefix                    : 0b110
+ * | ||      |  ||        |    ||       |  .- sign bit                     : 0b0
+ * | ||      |  ||        |    ||       |  |.- abs(DD - 1) = 139           : 0b10001011
+ * | ||      |  ||        |    ||       |  ||
+ * V_vv______V__vv________V____vv_______V__vv________,- padding bits
+ * 10111000 11100010 00101110 10110001 11100100 01011000
+ *
+ * Please also see unit tests for:
+ *   * Examples on what output `BitWriter` produces on predefined input.
+ *   * Compatibility tests solidifying encoded binary output on set of predefined sequences.
+ */
 class CompressionCodecDoubleDelta : public ICompressionCodec
 {
 public:
diff --git a/dbms/src/Compression/CompressionCodecGorilla.cpp b/dbms/src/Compression/CompressionCodecGorilla.cpp
index 574e40b06bf0..62e7a81aae95 100644
--- a/dbms/src/Compression/CompressionCodecGorilla.cpp
+++ b/dbms/src/Compression/CompressionCodecGorilla.cpp
@@ -112,8 +112,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest,
         dest += sizeof(prev_value);
     }
 
-    WriteBuffer buffer(dest, dest_end - dest);
-    BitWriter writer(buffer);
+    BitWriter writer(dest, dest_end - dest);
 
     while (source < source_end)
     {
@@ -148,7 +147,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest,
 
     writer.flush();
 
-    return sizeof(items_count) + sizeof(prev_value) + buffer.count();
+    return sizeof(items_count) + sizeof(prev_value) + writer.count() / 8;
 }
 
 template <typename T>
@@ -174,8 +173,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest)
         dest += sizeof(prev_value);
     }
 
-    ReadBufferFromMemory buffer(source, source_size - sizeof(items_count) - sizeof(prev_value));
-    BitReader reader(buffer);
+    BitReader reader(source, source_size - sizeof(items_count) - sizeof(prev_value));
 
     binary_value_info prev_xored_info{0, 0, 0};
 
diff --git a/dbms/src/Compression/CompressionCodecGorilla.h b/dbms/src/Compression/CompressionCodecGorilla.h
index a3947434ad91..fee473cbe905 100644
--- a/dbms/src/Compression/CompressionCodecGorilla.h
+++ b/dbms/src/Compression/CompressionCodecGorilla.h
@@ -5,6 +5,89 @@
 namespace DB
 {
 
+/** Gorilla column codec implementation.
+ *
+ * Based on Gorilla paper: http://www.vldb.org/pvldb/vol8/p1816-teller.pdf
+ *
+ * This codec is best used against monotonic floating sequences, like CPU usage percentage
+ * or any other gauge.
+ *
+ * Given input sequence a: [a0, a1, ... an]
+ *
+ * First, write number of items (sizeof(int32)*8 bits):                n
+ * Then write first item as is (sizeof(a[0])*8 bits):                  a[0]
+ * Loop over remaining items and calculate xor_diff:
+ *   xor_diff = a[i] ^ a[i - 1] (e.g. 00000011'10110100)
+ *   Write it in compact binary form with `BitWriter`
+ *   if xor_diff == 0:
+ *       write 1 bit:                                                  0
+ *   else:
+ *       calculate leading zero bits (lzb)
+ *       and trailing zero bits (tzb) of xor_diff,
+ *       compare to lzb and tzb of previous xor_diff
+ *       (X = sizeof(a[i]) * 8, e.g. X = 16, lzb = 6, tzb = 2)
+ *       if lzb >= prev_lzb && tzb >= prev_tzb:
+ *           (e.g. prev_lzb=4, prev_tzb=1)
+ *           write 2 bit prefix:                                       0b10
+ *           write xor_diff >> prev_tzb (X - prev_lzb - prev_tzb bits):0b00111011010
+ *           (where X = sizeof(a[i]) * 8, e.g. 16)
+ *       else:
+ *           write 2 bit prefix:                                       0b11
+ *           write 5 bits of lzb:                                      0b00110
+ *           write 6 bits of (X - lzb - tzb)=(16-6-2)=8:               0b001000
+ *           write (X - lzb - tzb) non-zero bits of xor_diff:          0b11101101
+ *           prev_lzb = lzb
+ *           prev_tzb = tzb
+ *
+ * @example sequence of Float32 values [0.1, 0.1, 0.11, 0.2, 0.1] is encoded as:
+ *
+ * .- 4-byte little endian sequence length: 5                                 : 0x00000005
+ * |                .- 4 byte (sizeof(Float32) a[0] as UInt32 : -10           : 0xcdcccc3d
+ * |                |               .- 4 encoded xor diffs (see below)
+ * v_______________ v______________ v__________________________________________________
+ * \x05\x00\x00\x00\xcd\xcc\xcc\x3d\x6a\x5a\xd8\xb6\x3c\xcd\x75\xb1\x6c\x77\x00\x00\x00
+ *
+ * 4 binary encoded xor diffs (\x6a\x5a\xd8\xb6\x3c\xcd\x75\xb1\x6c\x77\x00\x00\x00):
+ *
+ * ...........................................
+ * a[i-1]   = 00111101110011001100110011001101
+ * a[i]     = 00111101110011001100110011001101
+ * xor_diff = 00000000000000000000000000000000
+ * .- 1-bit prefix                                                           : 0b0
+ * |
+ * | ...........................................
+ * | a[i-1]   = 00111101110011001100110011001101
+ * ! a[i]     = 00111101111000010100011110101110
+ * | xor_diff = 00000000001011011000101101100011
+ * | lzb = 10
+ * | tzb = 0
+ * |.- 2-bit prefix                                                          : 0b11
+ * || .- lzb (10)                                                            : 0b1010
+ * || |     .- data length (32-10-0): 22                                     : 0b010110
+ * || |     |     .- data                                                    : 0b1011011000101101100011
+ * || |     |     |
+ * || |     |     |                        ...........................................
+ * || |     |     |                        a[i-1]   = 00111101111000010100011110101110
+ * || |     |     |                        a[i]     = 00111110010011001100110011001101
+ * || |     |     |                        xor_diff = 00000011101011011000101101100011
+ * || |     |     |                        .- 2-bit prefix                            : 0b11
+ * || |     |     |                        | .- lzb = 6                               : 0b00110
+ * || |     |     |                        | |     .- data length = (32 - 6) = 26     : 0b011010
+ * || |     |     |                        | |     |      .- data                     : 0b11101011011000101101100011
+ * || |     |     |                        | |     |      |
+ * || |     |     |                        | |     |      |                            ...........................................
+ * || |     |     |                        | |     |      |                            a[i-1]   = 00111110010011001100110011001101
+ * || |     |     |                        | |     |      |                            a[i]     = 00111101110011001100110011001101
+ * || |     |     |                        | |     |      |                            xor_diff = 00000011100000000000000000000000
+ * || |     |     |                        | |     |      |                            .- 2-bit prefix                            : 0b10
+ * || |     |     |                        | |     |      |                            | .- data                                  : 0b11100000000000000000000000
+ * VV_v____ v_____v________________________V_v_____v______v____________________________V_v_____________________________
+ * 01101010 01011010 11011000 10110110 00111100 11001101 01110101 10110001 01101100 01110111 00000000 00000000 00000000
+ *
+ * Please also see unit tests for:
+ *   * Examples on what output `BitWriter` produces on predefined input.
+ *   * Compatibility tests solidifying encoded binary output on set of predefined sequences.
+ */
 class CompressionCodecGorilla : public ICompressionCodec
 {
 public:
diff --git a/dbms/src/IO/BitHelpers.h b/dbms/src/IO/BitHelpers.h
index 1947d9d99ba2..321fb4d254ee 100644
--- a/dbms/src/IO/BitHelpers.h
+++ b/dbms/src/IO/BitHelpers.h
@@ -1,9 +1,10 @@
 #pragma once
 
-#include <IO/ReadBuffer.h>
-#include <IO/WriteBuffer.h>
 #include <Core/Types.h>
 #include <Common/BitHelpers.h>
+#include <Common/Exception.h>
+
+#include <string.h>
 
 #if defined(__OpenBSD__) || defined(__FreeBSD__)
 #   include <sys/endian.h>
@@ -14,9 +15,16 @@
 #   define be64toh(x) OSSwapBigToHostInt64(x)
 #endif
 
+
 namespace DB
 {
 
+namespace ErrorCodes
+{
+extern const int CANNOT_WRITE_AFTER_END_OF_BUFFER;
+extern const int ATTEMPT_TO_READ_AFTER_EOF;
+}
+
 /** Reads data from underlying ReadBuffer bit by bit, max 64 bits at once.
  *
  * reads MSB bits first, imagine that you have a data:
@@ -34,15 +42,20 @@ namespace DB
 
 class BitReader
 {
-    ReadBuffer & buf;
+    using BufferType = unsigned __int128;
+
+    const char * source_begin;
+    const char * source_current;
+    const char * source_end;
 
-    UInt64 bits_buffer;
+    BufferType bits_buffer;
     UInt8 bits_count;
-    static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;
 
 public:
-    BitReader(ReadBuffer & buf_)
-        : buf(buf_),
+    BitReader(const char * begin, size_t size)
+        : source_begin(begin),
+          source_current(begin),
+          source_end(begin + size),
           bits_buffer(0),
           bits_count(0)
     {}
@@ -50,44 +63,21 @@ class BitReader
     ~BitReader()
     {}
 
-    inline UInt64 readBits(UInt8 bits)
+    // reads bits_to_read high-bits from bits_buffer
+    inline UInt64 readBits(UInt8 bits_to_read)
     {
-        UInt64 result = 0;
-        bits = std::min(static_cast<UInt8>(sizeof(result) * 8), bits);
+        if (bits_to_read > bits_count)
+            fillBitBuffer();
 
-        while (bits != 0)
-        {
-            if (bits_count == 0)
-            {
-                fillBuffer();
-                if (bits_count == 0)
-                {
-                    // EOF.
-                    break;
-                }
-            }
-
-            const auto to_read = std::min(bits, bits_count);
-
-            const UInt64 v = bits_buffer >> (bits_count - to_read);
-            const UInt64 mask = maskLowBits<UInt64>(to_read);
-            const UInt64 value = v & mask;
-            result |= value;
-
-            // unset bits that were read
-            bits_buffer &= ~(mask << (bits_count - to_read));
-            bits_count -= to_read;
-            bits -= to_read;
-
-            result <<= std::min(bits, BIT_BUFFER_SIZE);
-        }
-
-        return result;
+        return getBitsFromBitBuffer<CONSUME>(bits_to_read);
     }
 
-    inline UInt64 peekBits(UInt8 /*bits*/)
+    inline UInt8 peekByte()
     {
-        return 0;
+        if (bits_count < 8)
+            fillBitBuffer();
+
+        return getBitsFromBitBuffer<PEEK>(8);
     }
 
     inline UInt8 readBit()
@@ -95,34 +85,95 @@ class BitReader
         return static_cast<UInt8>(readBits(1));
     }
 
+    // skip bits from bits_buffer
+    inline void skipBufferedBits(UInt8 bits)
+    {
+        bits_buffer <<= bits;
+        bits_count -= bits;
+    }
+
+
     inline bool eof() const
     {
-        return bits_count == 0 && buf.eof();
+        return bits_count == 0 && source_current >= source_end;
+    }
+
+    // number of bits that was already read by clients with readBits()
+    inline UInt64 count() const
+    {
+        return (source_current - source_begin) * 8 - bits_count;
+    }
+
+    inline UInt64 remaining() const
+    {
+        return (source_end - source_current) * 8 + bits_count;
     }
 
 private:
-    void fillBuffer()
+    enum GetBitsMode {CONSUME, PEEK};
+    // read data from internal buffer, if it has not enough bits, result is undefined.
+    template <GetBitsMode mode>
+    inline UInt64 getBitsFromBitBuffer(UInt8 bits_to_read)
     {
-        auto read = buf.read(reinterpret_cast<char *>(&bits_buffer), BIT_BUFFER_SIZE / 8);
-        bits_buffer = be64toh(bits_buffer);
-        bits_buffer >>= BIT_BUFFER_SIZE - read * 8;
+        // push down the high-bits
+        const UInt64 result = static_cast<UInt64>(bits_buffer >> (sizeof(bits_buffer) * 8 - bits_to_read));
+
+        if constexpr (mode == CONSUME)
+        {
+            // 'erase' high-bits that were have read
+            skipBufferedBits(bits_to_read);
+        }
 
-        bits_count = static_cast<UInt8>(read) * 8;
+        return result;
+    }
+
+
+    // Fills internal bits_buffer with data from source, reads at most 64 bits
+    size_t fillBitBuffer()
+    {
+        const size_t available = source_end - source_current;
+        const auto bytes_to_read = std::min<size_t>(64 / 8, available);
+        if (available == 0)
+        {
+            if (bytes_to_read == 0)
+                return 0;
+
+            throw Exception("Buffer is empty, but requested to read "
+                            + std::to_string(bytes_to_read) + " more bytes.",
+                            ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF);
+        }
+
+        UInt64 tmp_buffer = 0;
+        memcpy(&tmp_buffer, source_current, bytes_to_read);
+        source_current += bytes_to_read;
+
+        tmp_buffer = be64toh(tmp_buffer);
+
+        bits_buffer |= BufferType(tmp_buffer) << ((sizeof(BufferType) - sizeof(tmp_buffer)) * 8 - bits_count);
+        bits_count += static_cast<UInt8>(bytes_to_read) * 8;
+
+        return bytes_to_read;
     }
 };
 
 class BitWriter
 {
-    WriteBuffer & buf;
+    using BufferType = unsigned __int128;
 
-    UInt64 bits_buffer;
+    char * dest_begin;
+    char * dest_current;
+    char * dest_end;
+
+    BufferType bits_buffer;
     UInt8 bits_count;
 
     static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;
 
 public:
-    BitWriter(WriteBuffer & buf_)
-        : buf(buf_),
+    BitWriter(char * begin, size_t size)
+        : dest_begin(begin),
+          dest_current(begin),
+          dest_end(begin + size),
           bits_buffer(0),
           bits_count(0)
     {}
@@ -132,54 +183,59 @@ class BitWriter
         flush();
     }
 
-    inline void writeBits(UInt8 bits, UInt64 value)
+    // write `bits_to_write` low-bits of `value` to the buffer
+    inline void writeBits(UInt8 bits_to_write, UInt64 value)
     {
-        bits = std::min(static_cast<UInt8>(sizeof(value) * 8), bits);
-
-        while (bits > 0)
+        UInt32 capacity = BIT_BUFFER_SIZE - bits_count;
+        if (capacity < bits_to_write)
         {
-            auto v = value;
-            auto to_write = bits;
-
-            const UInt8 capacity = BIT_BUFFER_SIZE - bits_count;
-            if (capacity < bits)
-            {
-                v >>= bits - capacity;
-                to_write = capacity;
-            }
-
-            const UInt64 mask = maskLowBits<UInt64>(to_write);
-            v &= mask;
-
-            bits_buffer <<= to_write;
-            bits_buffer |= v;
-            bits_count += to_write;
-
-            if (bits_count < BIT_BUFFER_SIZE)
-                break;
-
             doFlush();
-            bits -= to_write;
+            capacity = BIT_BUFFER_SIZE - bits_count;
         }
+
+//      write low bits of value as high bits of bits_buffer
+        const UInt64 mask = maskLowBits<UInt64>(bits_to_write);
+        BufferType v = value & mask;
+        v <<= capacity - bits_to_write;
+
+        bits_buffer |= v;
+        bits_count += bits_to_write;
     }
 
+    // flush contents of bits_buffer to the dest_current, partial bytes are completed with zeroes.
     inline void flush()
     {
-        if (bits_count != 0)
-        {
-            bits_buffer <<= (BIT_BUFFER_SIZE - bits_count);
+        bits_count = (bits_count + 8 - 1) & ~(8 - 1); // align UP to 8-bytes, so doFlush will write ALL data from bits_buffer
+        while (bits_count != 0)
             doFlush();
-        }
+    }
+
+    inline UInt64 count() const
+    {
+        return (dest_current - dest_begin) * 8 + bits_count;
     }
 
 private:
     void doFlush()
     {
-        bits_buffer = htobe64(bits_buffer);
-        buf.write(reinterpret_cast<const char *>(&bits_buffer), (bits_count + 7) / 8);
+        // write whole bytes to the dest_current, leaving partial bits in bits_buffer
+        const size_t available = dest_end - dest_current;
+        const size_t to_write = std::min<size_t>(sizeof(UInt64), bits_count / 8); // align to 8-bit boundary
+
+        if (available < to_write)
+        {
+            throw Exception("Can not write past end of buffer. Space available "
+                            + std::to_string(available) + " bytes, required to write: "
+                            + std::to_string(to_write) + ".",
+                            ErrorCodes::CANNOT_WRITE_AFTER_END_OF_BUFFER);
+        }
+
+        const auto tmp_buffer = htobe64(static_cast<UInt64>(bits_buffer >> (sizeof(bits_buffer) - sizeof(UInt64)) * 8));
+        memcpy(dest_current, &tmp_buffer, to_write);
+        dest_current += to_write;
 
-        bits_count = 0;
-        bits_buffer = 0;
+        bits_buffer <<= to_write * 8;
+        bits_count -= to_write * 8;
     }
 };
 
