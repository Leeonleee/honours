diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
index 32fff70d5647..95bef3b691e2 100644
--- a/dbms/src/Compression/tests/gtest_compressionCodec.cpp
+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
@@ -1,6 +1,7 @@
 #include <Compression/CompressionFactory.h>
 
 #include <Common/PODArray.h>
+#include <Common/Stopwatch.h>
 #include <Core/Types.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/IDataType.h>
@@ -62,6 +63,32 @@ std::vector<T> operator+(std::vector<T> && left, std::vector<T> && right)
 namespace
 {
 
+template <typename T>
+struct AsHexStringHelper
+{
+    const T & container;
+};
+
+template <typename T>
+std::ostream & operator << (std::ostream & ostr, const AsHexStringHelper<T> & helper)
+{
+    ostr << std::hex;
+    for (const auto & e : helper.container)
+    {
+        ostr << "\\x" << std::setw(2) << std::setfill('0') << (static_cast<unsigned int>(e) & 0xFF);
+    }
+
+    return ostr;
+}
+
+template <typename T>
+AsHexStringHelper<T> AsHexString(const T & container)
+{
+    static_assert (sizeof(container[0]) == 1 && std::is_pod<std::decay_t<decltype(container[0])>>::value, "Only works on containers of byte-size PODs.");
+
+    return AsHexStringHelper<T>{container};
+}
+
 template <typename T>
 std::string bin(const T & value, size_t bits = sizeof(T)*8)
 {
@@ -113,10 +140,71 @@ DataTypePtr makeDataType()
 
 #undef MAKE_DATA_TYPE
 
-    assert(false && "unsupported size");
+    assert(false && "unknown datatype");
     return nullptr;
 }
 
+template <typename T, typename Container>
+class BinaryDataAsSequenceOfValuesIterator
+{
+    const Container & container;
+    const void * data;
+    const void * data_end;
+
+    T current_value;
+
+public:
+    using Self = BinaryDataAsSequenceOfValuesIterator<T, Container>;
+
+    explicit BinaryDataAsSequenceOfValuesIterator(const Container & container_)
+        : container(container_),
+          data(&container[0]),
+          data_end(reinterpret_cast<const char *>(data) + container.size()),
+          current_value(T{})
+    {
+        static_assert(sizeof(container[0]) == 1 && std::is_pod<std::decay_t<decltype(container[0])>>::value, "Only works on containers of byte-size PODs.");
+        read();
+    }
+
+    const T & operator*() const
+    {
+        return current_value;
+    }
+
+    size_t ItemsLeft() const
+    {
+        return reinterpret_cast<const char *>(data_end) - reinterpret_cast<const char *>(data);
+    }
+
+    Self & operator++()
+    {
+        read();
+        return *this;
+    }
+
+    operator bool() const
+    {
+        return ItemsLeft() > 0;
+    }
+
+private:
+    void read()
+    {
+        if (!*this)
+        {
+            throw std::runtime_error("No more data to read");
+        }
+
+        current_value = unalignedLoad<T>(data);
+        data = reinterpret_cast<const char *>(data) + sizeof(T);
+    }
+};
+
+template <typename T, typename Container>
+BinaryDataAsSequenceOfValuesIterator<T, Container> AsSequenceOf(const Container & container)
+{
+    return BinaryDataAsSequenceOfValuesIterator<T, Container>(container);
+}
 
 template <typename T, typename ContainerLeft, typename ContainerRight>
 ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, const ContainerRight & right)
@@ -126,9 +214,6 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con
 
     ::testing::AssertionResult result = ::testing::AssertionSuccess();
 
-    ReadBufferFromMemory left_read_buffer(left.data(), left.size());
-    ReadBufferFromMemory right_read_buffer(right.data(), right.size());
-
     const auto l_size = left.size() / sizeof(T);
     const auto r_size = right.size() / sizeof(T);
     const auto size = std::min(l_size, r_size);
@@ -137,16 +222,25 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con
     {
         result = ::testing::AssertionFailure() << "size mismatch" << " expected: " << l_size << " got:" << r_size;
     }
+    if (l_size == 0 || r_size == 0)
+    {
+        return result;
+    }
+
+    auto l = AsSequenceOf<T>(left);
+    auto r = AsSequenceOf<T>(right);
 
     const auto MAX_MISMATCHING_ITEMS = 5;
     int mismatching_items = 0;
-    for (int i = 0; i < size; ++i)
-    {
-        T left_value{};
-        left_read_buffer.readStrict(reinterpret_cast<char*>(&left_value), sizeof(left_value));
+    size_t i = 0;
 
-        T right_value{};
-        right_read_buffer.readStrict(reinterpret_cast<char*>(&right_value), sizeof(right_value));
+    while (l && r)
+    {
+        const auto left_value = *l;
+        const auto right_value = *r;
+        ++l;
+        ++r;
+        ++i;
 
         if (left_value != right_value)
         {
@@ -157,25 +251,47 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con
 
             if (++mismatching_items <= MAX_MISMATCHING_ITEMS)
             {
-                result << "mismatching " << sizeof(T) << "-byte item #" << i
+                result << "
mismatching " << sizeof(T) << "-byte item #" << i
                    << "
expected: " << bin(left_value) << " (0x" << std::hex << left_value << ")"
-                   << "
got     : " << bin(right_value) << " (0x" << std::hex << right_value << ")"
-                   << std::endl;
+                   << "
got     : " << bin(right_value) << " (0x" << std::hex << right_value << ")";
                 if (mismatching_items == MAX_MISMATCHING_ITEMS)
                 {
-                    result << "..." << std::endl;
+                    result << "
..." << std::endl;
                 }
             }
         }
     }
     if (mismatching_items > 0)
     {
-        result << "
total mismatching items:" << mismatching_items << " of " << size;
+        result << "total mismatching items:" << mismatching_items << " of " << size;
     }
 
     return result;
 }
 
+template <typename ContainerLeft, typename ContainerRight>
+::testing::AssertionResult EqualByteContainers(UInt8 element_size, const ContainerLeft & left, const ContainerRight & right)
+{
+    switch (element_size)
+    {
+        case 1:
+            return EqualByteContainersAs<UInt8>(left, right);
+            break;
+        case 2:
+            return EqualByteContainersAs<UInt16>(left, right);
+            break;
+        case 4:
+            return EqualByteContainersAs<UInt32>(left, right);
+            break;
+        case 8:
+            return EqualByteContainersAs<UInt64>(left, right);
+            break;
+        default:
+            assert(false && "Invalid element_size");
+            return ::testing::AssertionFailure() << "Invalid element_size: " << element_size;
+    }
+}
+
 struct Codec
 {
     std::string codec_statement;
@@ -214,20 +330,23 @@ struct CodecTestSequence
     CodecTestSequence & operator=(const CodecTestSequence &) = default;
     CodecTestSequence(CodecTestSequence &&) = default;
     CodecTestSequence & operator=(CodecTestSequence &&) = default;
-};
 
-CodecTestSequence operator+(CodecTestSequence && left, CodecTestSequence && right)
-{
-    assert(left.data_type->equals(*right.data_type));
+    CodecTestSequence & append(const CodecTestSequence & other)
+    {
+        assert(data_type->equals(*other.data_type));
 
-    std::vector<char> data(std::move(left.serialized_data));
-    data.insert(data.end(), right.serialized_data.begin(), right.serialized_data.end());
+        serialized_data.insert(serialized_data.end(), other.serialized_data.begin(), other.serialized_data.end());
+        if (!name.empty())
+            name += " + ";
+        name += other.name;
 
-    return CodecTestSequence{
-        left.name + " + " + right.name,
-        std::move(data),
-        std::move(left.data_type)
-    };
+        return *this;
+    }
+};
+
+CodecTestSequence operator+(CodecTestSequence && left, const CodecTestSequence & right)
+{
+    return left.append(right);
 }
 
 template <typename T>
@@ -288,17 +407,22 @@ CodecTestSequence makeSeq(Args && ... args)
     };
 }
 
-template <typename T, typename Generator>
-CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin = 0, size_t End = 10000)
+template <typename T, typename Generator, typename B = int, typename E = int>
+CodecTestSequence generateSeq(Generator gen, const char* gen_name, B Begin = 0, E End = 10000)
 {
-    assert (End >= Begin);
-
+    const auto direction = std::signbit(End - Begin) ? -1 : 1;
     std::vector<char> data(sizeof(T) * (End - Begin));
     char * write_pos = data.data();
 
-    for (size_t i = Begin; i < End; ++i)
+    for (auto i = Begin; i < End; i += direction)
     {
         const T v = gen(static_cast<T>(i));
+
+//        if constexpr (debug_log_items)
+//        {
+//            std::cerr << "#" << i << " " << type_name<T>() << "(" << sizeof(T) << " bytes) : " << v << std::endl;
+//        }
+
         unalignedStore<T>(write_pos, v);
         write_pos += sizeof(v);
     }
@@ -310,6 +434,96 @@ CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin
     };
 }
 
+struct NoOpTimer
+{
+    void start() {}
+    void report(const char*) {}
+};
+
+struct StopwatchTimer
+{
+    explicit StopwatchTimer(clockid_t clock_type, size_t estimated_marks = 32)
+        : stopwatch(clock_type)
+    {
+        results.reserve(estimated_marks);
+    }
+
+    void start()
+    {
+        stopwatch.restart();
+    }
+
+    void report(const char * mark)
+    {
+        results.emplace_back(mark, stopwatch.elapsed());
+    }
+
+    void stop()
+    {
+        stopwatch.stop();
+    }
+
+    const std::vector<std::tuple<const char*, UInt64>> & getResults() const
+    {
+        return results;
+    }
+
+private:
+    Stopwatch stopwatch;
+    std::vector<std::tuple<const char*, UInt64>> results;
+};
+
+CompressionCodecPtr makeCodec(const std::string & codec_string, const DataTypePtr data_type)
+{
+    const std::string codec_statement = "(" + codec_string + ")";
+    Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());
+    IParser::Pos token_iterator(tokens);
+
+    Expected expected;
+    ASTPtr codec_ast;
+    ParserCodec parser;
+
+    parser.parse(token_iterator, codec_ast, expected);
+
+    return CompressionCodecFactory::instance().get(codec_ast, data_type);
+}
+
+template <typename Timer>
+void testTranscoding(Timer & timer, ICompressionCodec & codec, const CodecTestSequence & test_sequence, std::optional<double> expected_compression_ratio = std::optional<double>{})
+{
+    const auto & source_data = test_sequence.serialized_data;
+
+    const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());
+    PODArray<char> encoded(encoded_max_size);
+
+    timer.start();
+
+    const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());
+    timer.report("encoding");
+
+    encoded.resize(encoded_size);
+
+    PODArray<char> decoded(source_data.size());
+
+    timer.start();
+    const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());
+    timer.report("decoding");
+
+    decoded.resize(decoded_size);
+
+    ASSERT_TRUE(EqualByteContainers(test_sequence.data_type->getSizeOfValueInMemory(), source_data, decoded));
+
+    const auto header_size = codec.getHeaderSize();
+    const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);
+
+    if (expected_compression_ratio)
+    {
+        ASSERT_LE(compression_ratio, *expected_compression_ratio)
+                << "
\tdecoded size: " << source_data.size()
+                << "
\tencoded size: " << encoded_size
+                << "(no header: " << encoded_size - header_size << ")";
+    }
+}
 
 class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>
 {
@@ -320,67 +534,18 @@ class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSeq
         CODEC_WITHOUT_DATA_TYPE,
     };
 
-    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type) const
+    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type)
     {
         const auto & codec_string = std::get<0>(GetParam()).codec_statement;
         const auto & data_type = with_data_type == CODEC_WITH_DATA_TYPE ? std::get<1>(GetParam()).data_type : nullptr;
 
-        const std::string codec_statement = "(" + codec_string + ")";
-        Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());
-        IParser::Pos token_iterator(tokens);
-
-        Expected expected;
-        ASTPtr codec_ast;
-        ParserCodec parser;
-
-        parser.parse(token_iterator, codec_ast, expected);
-
-        return CompressionCodecFactory::instance().get(codec_ast, data_type);
+        return ::makeCodec(codec_string, data_type);
     }
 
     void testTranscoding(ICompressionCodec & codec)
     {
-        const auto & test_sequence = std::get<1>(GetParam());
-        const auto & source_data = test_sequence.serialized_data;
-
-        const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());
-        PODArray<char> encoded(encoded_max_size);
-
-        const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());
-        encoded.resize(encoded_size);
-
-        PODArray<char> decoded(source_data.size());
-        const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());
-        decoded.resize(decoded_size);
-
-        switch (test_sequence.data_type->getSizeOfValueInMemory())
-        {
-            case 1:
-                ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));
-                break;
-            case 2:
-                ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));
-                break;
-            case 4:
-                ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));
-                break;
-            case 8:
-                ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));
-                break;
-            default:
-                FAIL() << "Invalid test sequence data type: " << test_sequence.data_type->getName();
-        }
-        const auto header_size = codec.getHeaderSize();
-        const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);
-
-        const auto & codec_spec = std::get<0>(GetParam());
-        if (codec_spec.expected_compression_ratio)
-        {
-            ASSERT_LE(compression_ratio, *codec_spec.expected_compression_ratio)
-                    << "
\tdecoded size: " << source_data.size()
-                    << "
\tencoded size: " << encoded_size
-                    << "(no header: " << encoded_size - header_size << ")";
-        }
+        NoOpTimer timer;
+        ::testTranscoding(timer, codec, std::get<1>(GetParam()), std::get<0>(GetParam()).expected_compression_ratio);
     }
 };
 
@@ -396,10 +561,121 @@ TEST_P(CodecTest, TranscodingWithoutDataType)
     testTranscoding(*codec);
 }
 
+// Param is tuple-of-tuple to simplify instantiating with values, since typically group of cases test only one codec.
+class CodecTest_Compatibility : public ::testing::TestWithParam<std::tuple<Codec, std::tuple<CodecTestSequence, std::string>>>
+{};
+
+// Check that iput sequence when encoded matches the encoded string binary.
+TEST_P(CodecTest_Compatibility, Encoding)
+{
+    const auto & codec_spec = std::get<0>(GetParam());
+    const auto & [data_sequence, expected] = std::get<1>(GetParam());
+    const auto codec = makeCodec(codec_spec.codec_statement, data_sequence.data_type);
+
+    const auto & source_data = data_sequence.serialized_data;
+
+    // Just encode the data with codec
+    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());
+    PODArray<char> encoded(encoded_max_size);
+
+    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());
+    encoded.resize(encoded_size);
+    SCOPED_TRACE(::testing::Message("encoded:  ") << AsHexString(encoded));
+
+    ASSERT_TRUE(EqualByteContainersAs<UInt8>(expected, encoded));
+}
+
+// Check that binary string is exactly decoded into input sequence.
+TEST_P(CodecTest_Compatibility, Decoding)
+{
+    const auto & codec_spec = std::get<0>(GetParam());
+    const auto & [expected, encoded_data] = std::get<1>(GetParam());
+    const auto codec = makeCodec(codec_spec.codec_statement, expected.data_type);
+
+    PODArray<char> decoded(expected.serialized_data.size());
+    const UInt32 decoded_size = codec->decompress(encoded_data.c_str(), encoded_data.size(), decoded.data());
+    decoded.resize(decoded_size);
+
+    ASSERT_TRUE(EqualByteContainers(expected.data_type->getSizeOfValueInMemory(), expected.serialized_data, decoded));
+}
+
+class CodecTest_Performance : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>
+{};
+
+TEST_P(CodecTest_Performance, TranscodingWithDataType)
+{
+    const auto & [codec_spec, test_seq] = GetParam();
+    const auto codec = ::makeCodec(codec_spec.codec_statement, test_seq.data_type);
+
+    const auto runs = 10;
+    std::map<std::string, std::vector<UInt64>> results;
+
+    for (size_t i = 0; i < runs; ++i)
+    {
+        StopwatchTimer timer{CLOCK_THREAD_CPUTIME_ID};
+        ::testTranscoding(timer, *codec, test_seq);
+        timer.stop();
+
+        for (const auto & [label, value] : timer.getResults())
+        {
+            results[label].push_back(value);
+        }
+    }
+
+    auto computeMeanAndStdDev = [](const auto & values)
+    {
+        double mean{};
+
+        if (values.size() < 2)
+            return std::make_tuple(mean, double{});
+
+        using ValueType = typename std::decay_t<decltype(values)>::value_type;
+        std::vector<ValueType> tmp_v(std::begin(values), std::end(values));
+        std::sort(tmp_v.begin(), tmp_v.end());
+
+        // remove min and max
+        tmp_v.erase(tmp_v.begin());
+        tmp_v.erase(tmp_v.end() - 1);
+
+        for (const auto & v : tmp_v)
+        {
+            mean += v;
+        }
+
+        mean = mean / tmp_v.size();
+        double std_dev = 0.0;
+        for (const auto & v : tmp_v)
+        {
+            const auto d = (v - mean);
+            std_dev += (d * d);
+        }
+        std_dev = std::sqrt(std_dev / tmp_v.size());
+
+        return std::make_tuple(mean, std_dev);
+    };
+
+    std::cerr << codec_spec.codec_statement
+              << " " << test_seq.data_type->getName()
+              << " (" << test_seq.serialized_data.size() << " bytes, "
+              << std::hex << CityHash_v1_0_2::CityHash64(test_seq.serialized_data.data(), test_seq.serialized_data.size()) << std::dec
+              << ", average of " << runs << " runs, μs)";
+
+    for (const auto & k : {"encoding", "decoding"})
+    {
+        const auto & values = results[k];
+        const auto & [mean, std_dev] = computeMeanAndStdDev(values);
+        // Ensure that Coefficient of variation is reasonably low, otherwise these numbers are meaningless
+        EXPECT_GT(0.05, std_dev / mean);
+        std::cerr << "\t" << std::fixed << std::setprecision(1) << mean / 1000.0;
+    }
+
+    std::cerr << std::endl;
+}
+
 ///////////////////////////////////////////////////////////////////////////////////////////////////
 // Here we use generators to produce test payload for codecs.
 // Generator is a callable that can produce infinite number of values,
-// output value MUST be of the same type input value.
+// output value MUST be of the same type as input value.
 ///////////////////////////////////////////////////////////////////////////////////////////////////
 
 auto SameValueGenerator = [](auto value)
@@ -543,6 +819,23 @@ std::vector<CodecTestSequence> generatePyramidOfSequences(const size_t sequences
     return sequences;
 };
 
+// Just as if all sequences from generatePyramidOfSequences were appended to one-by-one to the first one.
+template <typename T, typename Generator>
+CodecTestSequence generatePyramidSequence(const size_t sequences_count, Generator && generator, const char* generator_name)
+{
+    CodecTestSequence sequence;
+    sequence.data_type = makeDataType<T>();
+    sequence.serialized_data.reserve(sequences_count * sequences_count * sizeof(T));
+
+    for (size_t i = 1; i < sequences_count; ++i)
+    {
+        std::string name = generator_name + std::string(" from 0 to ") + std::to_string(i);
+        sequence.append(generateSeq<T>(std::forward<decltype(generator)>(generator), name.c_str(), 0, i));
+    }
+
+    return sequence;
+};
+
 
 // helper macro to produce human-friendly sequence name from generator
 #define G(generator) generator, #generator
@@ -575,7 +868,7 @@ INSTANTIATE_TEST_CASE_P(SmallSequences,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::ValuesIn(
-                  generatePyramidOfSequences<Int8  >(42, G(SequentialGenerator(1)))
+                  generatePyramidOfSequences<Int8 >(42, G(SequentialGenerator(1)))
                 + generatePyramidOfSequences<Int16 >(42, G(SequentialGenerator(1)))
                 + generatePyramidOfSequences<Int32 >(42, G(SequentialGenerator(1)))
                 + generatePyramidOfSequences<Int64 >(42, G(SequentialGenerator(1)))
@@ -609,7 +902,7 @@ INSTANTIATE_TEST_CASE_P(SameValueInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(SameValueGenerator(1000))),
+            generateSeq<Int8>(G(SameValueGenerator(1000))),
             generateSeq<Int16 >(G(SameValueGenerator(1000))),
             generateSeq<Int32 >(G(SameValueGenerator(1000))),
             generateSeq<Int64 >(G(SameValueGenerator(1000))),
@@ -626,7 +919,7 @@ INSTANTIATE_TEST_CASE_P(SameNegativeValueInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(SameValueGenerator(-1000))),
+            generateSeq<Int8>(G(SameValueGenerator(-1000))),
             generateSeq<Int16 >(G(SameValueGenerator(-1000))),
             generateSeq<Int32 >(G(SameValueGenerator(-1000))),
             generateSeq<Int64 >(G(SameValueGenerator(-1000))),
@@ -671,7 +964,7 @@ INSTANTIATE_TEST_CASE_P(SequentialInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(SequentialGenerator(1))),
+            generateSeq<Int8>(G(SequentialGenerator(1))),
             generateSeq<Int16 >(G(SequentialGenerator(1))),
             generateSeq<Int32 >(G(SequentialGenerator(1))),
             generateSeq<Int64 >(G(SequentialGenerator(1))),
@@ -690,7 +983,7 @@ INSTANTIATE_TEST_CASE_P(SequentialReverseInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(SequentialGenerator(-1))),
+            generateSeq<Int8>(G(SequentialGenerator(-1))),
             generateSeq<Int16 >(G(SequentialGenerator(-1))),
             generateSeq<Int32 >(G(SequentialGenerator(-1))),
             generateSeq<Int64 >(G(SequentialGenerator(-1))),
@@ -735,10 +1028,10 @@ INSTANTIATE_TEST_CASE_P(MonotonicInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(MonotonicGenerator(1, 5))),
-            generateSeq<Int16 >(G(MonotonicGenerator(1, 5))),
-            generateSeq<Int32 >(G(MonotonicGenerator(1, 5))),
-            generateSeq<Int64 >(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int8>(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int16>(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int32>(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int64>(G(MonotonicGenerator(1, 5))),
             generateSeq<UInt8 >(G(MonotonicGenerator(1, 5))),
             generateSeq<UInt16>(G(MonotonicGenerator(1, 5))),
             generateSeq<UInt32>(G(MonotonicGenerator(1, 5))),
@@ -752,11 +1045,11 @@ INSTANTIATE_TEST_CASE_P(MonotonicReverseInt,
     ::testing::Combine(
         DefaultCodecsToTest,
         ::testing::Values(
-            generateSeq<Int8  >(G(MonotonicGenerator(-1, 5))),
-            generateSeq<Int16 >(G(MonotonicGenerator(-1, 5))),
-            generateSeq<Int32 >(G(MonotonicGenerator(-1, 5))),
-            generateSeq<Int64 >(G(MonotonicGenerator(-1, 5))),
-            generateSeq<UInt8 >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int8>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int16>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int32>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int64>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<UInt8>(G(MonotonicGenerator(-1, 5))),
             generateSeq<UInt16>(G(MonotonicGenerator(-1, 5))),
             generateSeq<UInt32>(G(MonotonicGenerator(-1, 5))),
             generateSeq<UInt64>(G(MonotonicGenerator(-1, 5)))
@@ -862,4 +1155,191 @@ INSTANTIATE_TEST_CASE_P(OverflowFloat,
     ),
 );
 
+template <typename ValueType>
+auto DDCompatibilityTestSequence()
+{
+    // Generates sequences with double delta in given range.
+    auto ddGenerator = [prev_delta = static_cast<Int64>(0), prev = static_cast<Int64>(0)](auto dd) mutable
+    {
+        const auto curr = dd + prev + prev_delta;
+        prev = curr;
+        prev_delta = dd + prev_delta;
+        return curr;
+    };
+
+    auto ret = generateSeq<ValueType>(G(SameValueGenerator(42)), 0, 3);
+
+    // These values are from DoubleDelta paper (and implementation) and represent points at which DD encoded length is changed.
+    // DD value less that this point is encoded in shorter binary form (bigger - longer binary).
+    const Int64 dd_corner_points[] = {-63, 64, -255, 256, -2047, 2048, std::numeric_limits<Int32>::min(), std::numeric_limits<Int32>::max()};
+    for (const auto & p : dd_corner_points)
+    {
+        if (std::abs(p) > std::numeric_limits<ValueType>::max())
+        {
+            break;
+        }
+
+        // - 4 is to allow DD value to settle before transitioning through important point,
+        // since DD depends on 2 previous values of data, + 2 is arbitrary.
+        ret.append(generateSeq<ValueType>(G(ddGenerator), p - 4, p + 2));
+    }
+
+    return ret;
+}
+
+#define BIN_STR(x) std::string{x, sizeof(x) - 1}
+
+INSTANTIATE_TEST_CASE_P(DoubleDelta,
+    CodecTest_Compatibility,
+    ::testing::Combine(
+        ::testing::Values(Codec("DoubleDelta")),
+        ::testing::ValuesIn(std::initializer_list<std::tuple<CodecTestSequence, std::string>>{
+            {
+                DDCompatibilityTestSequence<Int8>(),
+                BIN_STR("\x94\x21\x00\x00\x00\x0f\x00\x00\x00\x01\x00\x0f\x00\x00\x00\x2a\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xb1\xaa\xf4\xf6\x7d\x87\xf8\x80")
+            },
+            {
+                DDCompatibilityTestSequence<UInt8>(),
+                BIN_STR("\x94\x27\x00\x00\x00\x15\x00\x00\x00\x01\x00\x15\x00\x00\x00\x2a\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xb1\xaa\xf4\xf6\x7d\x87\xf8\x81\x8e\xd0\xca\x02\x01\x01")
+            },
+            {
+                DDCompatibilityTestSequence<Int16>(),
+                BIN_STR("\x94\x70\x00\x00\x00\x4e\x00\x00\x00\x02\x00\x27\x00\x00\x00\x2a\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x40\x00\x0f\xf2\x78\x00\x01\x7f\x83\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00")
+            },
+            {
+                DDCompatibilityTestSequence<UInt16>(),
+                BIN_STR("\x94\x70\x00\x00\x00\x4e\x00\x00\x00\x02\x00\x27\x00\x00\x00\x2a\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x40\x00\x0f\xf2\x78\x00\x01\x7f\x83\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00")
+            },
+            {
+                DDCompatibilityTestSequence<Int32>(),
+                BIN_STR("\x94\x74\x00\x00\x00\x9c\x00\x00\x00\x04\x00\x27\x00\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x00\x00\x70\x0d\x7a\x00\x02\x80\x7b\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00")
+            },
+            {
+                DDCompatibilityTestSequence<UInt32>(),
+                BIN_STR("\x94\xb5\x00\x00\x00\xcc\x00\x00\x00\x04\x00\x33\x00\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x00\x00\x70\x0d\x7a\x00\x02\x80\x7b\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00\xf3\xff\xf9\x41\xaf\xbf\xff\xd6\x0c\xfc\xff\xff\xff\xfb\xf0\x00\x00\x00\x07\xff\xff\xff\xef\xc0\x00\x00\x00\x3f\xff\xff\xff\xfb\xff\xff\xff\xfa\x69\x74\xf3\xff\xff\xff\xe7\x9f\xff\xff\xff\x7e\x00\x00\x00\x00\xff\xff\xff\xfd\xf8\x00\x00\x00\x07\xff\xff\xff\xf0")
+            },
+            {
+                DDCompatibilityTestSequence<Int64>(),
+                BIN_STR("\x94\xd4\x00\x00\x00\x98\x01\x00\x00\x08\x00\x33\x00\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x00\x00\x70\x0d\x7a\x00\x02\x80\x7b\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00\xfc\x00\x00\x00\x04\x00\x06\xbe\x4f\xbf\xff\xd6\x0c\xff\x00\x00\x00\x01\x00\x00\x00\x03\xf8\x00\x00\x00\x08\x00\x00\x00\x0f\xc0\x00\x00\x00\x3f\xff\xff\xff\xfb\xff\xff\xff\xfb\xe0\x00\x00\x01\xc0\x00\x00\x06\x9f\x80\x00\x00\x0a\x00\x00\x00\x34\xf3\xff\xff\xff\xe7\x9f\xff\xff\xff\x7e\x00\x00\x00\x00\xff\xff\xff\xfd\xf0\x00\x00\x00\x07\xff\xff\xff\xf0")
+            },
+            {
+                DDCompatibilityTestSequence<UInt64>(),
+                BIN_STR("\x94\xd4\x00\x00\x00\x98\x01\x00\x00\x08\x00\x33\x00\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6b\x65\x5f\x50\x34\xff\x4f\xaf\xbc\xe3\x5d\xa3\xd3\xd9\xf6\x1f\xe2\x07\x7c\x47\x20\x67\x48\x07\x47\xff\x47\xf6\xfe\xf8\x00\x00\x70\x6b\xd0\x00\x02\x83\xd9\xfb\x9f\xdc\x1f\xfc\x20\x1e\x80\x00\x22\xc8\xf0\x00\x00\x66\x67\xa0\x00\x02\x00\x3d\x00\x00\x0f\xff\xe8\x00\x00\x7f\xee\xff\xdf\x00\x00\x70\x0d\x7a\x00\x02\x80\x7b\x9f\xf7\x9f\xfb\xc0\x00\x00\xff\xfe\x00\x00\x08\x00\xfc\x00\x00\x00\x04\x00\x06\xbe\x4f\xbf\xff\xd6\x0c\xff\x00\x00\x00\x01\x00\x00\x00\x03\xf8\x00\x00\x00\x08\x00\x00\x00\x0f\xc0\x00\x00\x00\x3f\xff\xff\xff\xfb\xff\xff\xff\xfb\xe0\x00\x00\x01\xc0\x00\x00\x06\x9f\x80\x00\x00\x0a\x00\x00\x00\x34\xf3\xff\xff\xff\xe7\x9f\xff\xff\xff\x7e\x00\x00\x00\x00\xff\xff\xff\xfd\xf0\x00\x00\x00\x07\xff\xff\xff\xf0")
+            },
+        })
+    ),
+);
+
+template <typename ValueType>
+auto DDperformanceTestSequence()
+{
+    const auto times = 100'000;
+    return DDCompatibilityTestSequence<ValueType>() * times // average case
+        + generateSeq<ValueType>(G(MinMaxGenerator()), 0, times) // worst
+        + generateSeq<ValueType>(G(SameValueGenerator(42)), 0, times); // best
+}
+
+// prime numbers in ascending order with some random repitions hit all the cases of Gorilla.
+auto PrimesWithMultiplierGenerator = [](int multiplier = 1)
+{
+    return [multiplier](auto i)
+    {
+        static const int vals[] = {
+             2, 3, 5, 7, 11, 11, 13, 17, 19, 23, 29, 29, 31, 37, 41, 43,
+            47, 47, 53, 59, 61, 61, 67, 71, 73, 79, 83, 89, 89, 97, 101, 103,
+            107, 107, 109, 113, 113, 127, 127, 127
+        };
+        static const size_t count = sizeof(vals)/sizeof(vals[0]);
+
+        using T = decltype(i);
+        return static_cast<T>(vals[i % count] * static_cast<T>(multiplier));
+    };
+};
+
+template <typename ValueType>
+auto GCompatibilityTestSequence()
+{
+    // Also multiply result by some factor to test large values on types that can hold those.
+    return generateSeq<ValueType>(G(PrimesWithMultiplierGenerator(intExp10(sizeof(ValueType)))), 0, 42);
+}
+
+INSTANTIATE_TEST_CASE_P(Gorilla,
+    CodecTest_Compatibility,
+    ::testing::Combine(
+        ::testing::Values(Codec("Gorilla")),
+        ::testing::ValuesIn(std::initializer_list<std::tuple<CodecTestSequence, std::string>>{
+            {
+                GCompatibilityTestSequence<Int8>(),
+                BIN_STR("\x95\x35\x00\x00\x00\x2a\x00\x00\x00\x01\x00\x2a\x00\x00\x00\x14\xe1\xdd\x25\xe5\x7b\x29\x86\xee\x2a\x16\x5a\xc5\x0b\x23\x75\x1b\x3c\xb1\x97\x8b\x5f\xcb\x43\xd9\xc5\x48\xab\x23\xaf\x62\x93\x71\x4a\x73\x0f\xc6\x0a")
+            },
+            {
+                GCompatibilityTestSequence<UInt8>(),
+                BIN_STR("\x95\x35\x00\x00\x00\x2a\x00\x00\x00\x01\x00\x2a\x00\x00\x00\x14\xe1\xdd\x25\xe5\x7b\x29\x86\xee\x2a\x16\x5a\xc5\x0b\x23\x75\x1b\x3c\xb1\x97\x8b\x5f\xcb\x43\xd9\xc5\x48\xab\x23\xaf\x62\x93\x71\x4a\x73\x0f\xc6\x0a")
+            },
+            {
+                GCompatibilityTestSequence<Int16>(),
+                BIN_STR("\x95\x52\x00\x00\x00\x54\x00\x00\x00\x02\x00\x2a\x00\x00\x00\xc8\x00\xdc\xfe\x66\xdb\x1f\x4e\xa7\xde\xdc\xd5\xec\x6e\xf7\x37\x3a\x23\xe7\x63\xf5\x6a\x8e\x99\x37\x34\xf9\xf8\x2e\x76\x35\x2d\x51\xbb\x3b\xc3\x6d\x13\xbf\x86\x53\x9e\x25\xe4\xaf\xaf\x63\xd5\x6a\x6e\x76\x35\x3a\x27\xd3\x0f\x91\xae\x6b\x33\x57\x6e\x64\xcc\x55\x81\xe4")
+            },
+            {
+                GCompatibilityTestSequence<UInt16>(),
+                BIN_STR("\x95\x52\x00\x00\x00\x54\x00\x00\x00\x02\x00\x2a\x00\x00\x00\xc8\x00\xdc\xfe\x66\xdb\x1f\x4e\xa7\xde\xdc\xd5\xec\x6e\xf7\x37\x3a\x23\xe7\x63\xf5\x6a\x8e\x99\x37\x34\xf9\xf8\x2e\x76\x35\x2d\x51\xbb\x3b\xc3\x6d\x13\xbf\x86\x53\x9e\x25\xe4\xaf\xaf\x63\xd5\x6a\x6e\x76\x35\x3a\x27\xd3\x0f\x91\xae\x6b\x33\x57\x6e\x64\xcc\x55\x81\xe4")
+            },
+            {
+                GCompatibilityTestSequence<Int32>(),
+                BIN_STR("\x95\x65\x00\x00\x00\xa8\x00\x00\x00\x04\x00\x2a\x00\x00\x00\x20\x4e\x00\x00\xe4\x57\x63\xc0\xbb\x67\xbc\xce\x91\x97\x99\x15\x9e\xe3\x36\x3f\x89\x5f\x8e\xf2\xec\x8e\xd3\xbf\x75\x43\x58\xc4\x7e\xcf\x93\x43\x38\xc6\x91\x36\x1f\xe7\xb6\x11\x6f\x02\x73\x46\xef\xe0\xec\x50\xfb\x79\xcb\x9c\x14\xfa\x13\xea\x8d\x66\x43\x48\xa0\xde\x3a\xcf\xff\x26\xe0\x5f\x93\xde\x5e\x7f\x6e\x36\x5e\xe6\xb4\x66\x5d\xb0\x0e\xc4")
+            },
+            {
+                GCompatibilityTestSequence<UInt32>(),
+                BIN_STR("\x95\x65\x00\x00\x00\xa8\x00\x00\x00\x04\x00\x2a\x00\x00\x00\x20\x4e\x00\x00\xe4\x57\x63\xc0\xbb\x67\xbc\xce\x91\x97\x99\x15\x9e\xe3\x36\x3f\x89\x5f\x8e\xf2\xec\x8e\xd3\xbf\x75\x43\x58\xc4\x7e\xcf\x93\x43\x38\xc6\x91\x36\x1f\xe7\xb6\x11\x6f\x02\x73\x46\xef\xe0\xec\x50\xfb\x79\xcb\x9c\x14\xfa\x13\xea\x8d\x66\x43\x48\xa0\xde\x3a\xcf\xff\x26\xe0\x5f\x93\xde\x5e\x7f\x6e\x36\x5e\xe6\xb4\x66\x5d\xb0\x0e\xc4")
+            },
+            {
+                GCompatibilityTestSequence<Int64>(),
+                BIN_STR("\x95\x91\x00\x00\x00\x50\x01\x00\x00\x08\x00\x2a\x00\x00\x00\x00\xc2\xeb\x0b\x00\x00\x00\x00\xe3\x2b\xa0\xa6\x19\x85\x98\xdc\x45\x74\x74\x43\xc2\x57\x41\x4c\x6e\x42\x79\xd9\x8f\x88\xa5\x05\xf3\xf1\x94\xa3\x62\x1e\x02\xdf\x05\x10\xf1\x15\x97\x35\x2a\x50\x71\x0f\x09\x6c\x89\xf7\x65\x1d\x11\xb7\xcc\x7d\x0b\x70\xc1\x86\x88\x48\x47\x87\xb6\x32\x26\xa7\x86\x87\x88\xd3\x93\x3d\xfc\x28\x68\x85\x05\x0b\x13\xc6\x5f\xd4\x70\xe1\x5e\x76\xf1\x9f\xf3\x33\x2a\x14\x14\x5e\x40\xc1\x5c\x28\x3f\xec\x43\x03\x05\x11\x91\xe8\xeb\x8e\x0a\x0e\x27\x21\x55\xcb\x39\xbc\x6a\xff\x11\x5d\x81\xa0\xa6\x10")
+            },
+            {
+                GCompatibilityTestSequence<UInt64>(),
+                BIN_STR("\x95\x91\x00\x00\x00\x50\x01\x00\x00\x08\x00\x2a\x00\x00\x00\x00\xc2\xeb\x0b\x00\x00\x00\x00\xe3\x2b\xa0\xa6\x19\x85\x98\xdc\x45\x74\x74\x43\xc2\x57\x41\x4c\x6e\x42\x79\xd9\x8f\x88\xa5\x05\xf3\xf1\x94\xa3\x62\x1e\x02\xdf\x05\x10\xf1\x15\x97\x35\x2a\x50\x71\x0f\x09\x6c\x89\xf7\x65\x1d\x11\xb7\xcc\x7d\x0b\x70\xc1\x86\x88\x48\x47\x87\xb6\x32\x26\xa7\x86\x87\x88\xd3\x93\x3d\xfc\x28\x68\x85\x05\x0b\x13\xc6\x5f\xd4\x70\xe1\x5e\x76\xf1\x9f\xf3\x33\x2a\x14\x14\x5e\x40\xc1\x5c\x28\x3f\xec\x43\x03\x05\x11\x91\xe8\xeb\x8e\x0a\x0e\x27\x21\x55\xcb\x39\xbc\x6a\xff\x11\x5d\x81\xa0\xa6\x10")
+            },
+        })
+    ),
+);
+
+// These 'tests' try to measure performance of encoding and decoding and hence only make sence to be run locally,
+// also they require pretty big data to run agains and generating this data slows down startup of unit test process.
+// So un-comment only at your discretion.
+
+//INSTANTIATE_TEST_CASE_P(DoubleDelta,
+//    CodecTest_Performance,
+//    ::testing::Combine(
+//        ::testing::Values(Codec("DoubleDelta")),
+//        ::testing::Values(
+//            DDperformanceTestSequence<Int8 >(),
+//            DDperformanceTestSequence<UInt8 >(),
+//            DDperformanceTestSequence<Int16 >(),
+//            DDperformanceTestSequence<UInt16>(),
+//            DDperformanceTestSequence<Int32 >(),
+//            DDperformanceTestSequence<UInt32>(),
+//            DDperformanceTestSequence<Int64 >(),
+//            DDperformanceTestSequence<UInt64>()
+//        )
+//    ),
+//);
+
+//INSTANTIATE_TEST_CASE_P(Gorilla,
+//    CodecTest_Performance,
+//    ::testing::Combine(
+//        ::testing::Values(Codec("Gorilla")),
+//        ::testing::Values(
+//            generatePyramidSequence<Int8 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<UInt8 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<Int16 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<UInt16>(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<Int32 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<UInt32>(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<Int64 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,
+//            generatePyramidSequence<UInt64>(42, G(PrimesWithMultiplierGenerator())) * 6'000
+//        )
+//    ),
+//);
+
 }
diff --git a/dbms/src/IO/tests/gtest_bit_io.cpp b/dbms/src/IO/tests/gtest_bit_io.cpp
index 85df25807831..b44a17e02db6 100644
--- a/dbms/src/IO/tests/gtest_bit_io.cpp
+++ b/dbms/src/IO/tests/gtest_bit_io.cpp
@@ -36,11 +36,11 @@ std::string bin(const T & value, size_t bits = sizeof(T)*8)
             .to_string().substr(MAX_BITS - bits, bits);
 }
 
+// gets N low bits of value
 template <typename T>
 T getBits(UInt8 bits, const T & value)
 {
-    const T mask = ((static_cast<T>(1) << static_cast<T>(bits)) - 1);
-    return value & mask;
+    return value & maskLowBits<T>(bits);
 }
 
 template <typename T>
@@ -83,12 +83,36 @@ std::string dumpContents(const T& container,
     return sstr.str();
 }
 
+template <typename ValueLeft, typename ValueRight>
+::testing::AssertionResult BinaryEqual(const ValueLeft & left, const ValueRight & right)
+{
+//    ::testing::AssertionResult result = ::testing::AssertionSuccess();
+    if (sizeof(left) != sizeof(right))
+        return ::testing::AssertionFailure()
+                << "Sizes do not match, expected: " << sizeof(left) << " actual: " << sizeof(right);
+
+    const auto size = std::min(sizeof(left), sizeof(right));
+    if (memcmp(&left, &right, size) != 0)
+    {
+        const auto l_bits = left ? static_cast<size_t>(std::log2(left)) : 0;
+        const auto r_bits = right ? static_cast<size_t>(std::log2(right)) : 0;
+        const size_t bits = std::max(l_bits, r_bits) + 1;
+
+        return ::testing::AssertionFailure()
+                << "Values are binary different,
"
+                << "\texpected: 0b" << bin(left, bits) << " (" << std::hex << left << "),
"
+                << "\tactual  : 0b" << bin(right, bits) << " (" <<std::hex << right << ").";
+    }
+
+    return ::testing::AssertionSuccess();
+}
+
 struct TestCaseParameter
 {
     std::vector<std::pair<UInt8, UInt64>> bits_and_vals;
     std::string expected_buffer_binary;
 
-    explicit TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})
+    TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})
         : bits_and_vals(std::move(vals)),
           expected_buffer_binary(binary)
     {}
@@ -114,8 +138,7 @@ TEST_P(BitIO, WriteAndRead)
     PODArray<char> data(max_buffer_size);
 
     {
-        WriteBuffer write_buffer(data.data(), data.size());
-        BitWriter writer(write_buffer);
+        BitWriter writer(data.data(), data.size());
         for (const auto & bv : bits_and_vals)
         {
             writer.writeBits(bv.first, bv.second);
@@ -133,38 +156,73 @@ TEST_P(BitIO, WriteAndRead)
             ASSERT_EQ(expected_buffer_binary, actual_buffer_binary);
         }
 
-        BitReader reader(read_buffer);
+        BitReader reader(data.data(), data.size());
 
+        int bitpos = 0;
         int item = 0;
         for (const auto & bv : bits_and_vals)
         {
             SCOPED_TRACE(::testing::Message()
-                         << "item #" << item << ", width: " << static_cast<UInt32>(bv.first)
-                         << ", value: " << bin(bv.second)
-                         << ".


Buffer memory:
" << dumpContents(data));
+                         << "item #" << item << " of " << bits_and_vals.size() << ", width: " << static_cast<UInt32>(bv.first)
+                         << ", value: " << bv.second << "(" << bin(bv.second) << ")"
+                         << ", at bit position: " << std::dec << reader.count()
+                         << ".
Buffer memory:
" << dumpContents(data));
 
-            //EXPECT_EQ(getBits(bv.first, bv.second), reader.peekBits(bv.first));
-            EXPECT_EQ(getBits(bv.first, bv.second), reader.readBits(bv.first));
+//            const UInt8 next_byte = getBits(bv.first, bv.second) &
+            ASSERT_TRUE(BinaryEqual(getBits(bv.first, bv.second), reader.readBits(bv.first)));
 
             ++item;
+            bitpos += bv.first;
         }
     }
 }
 
 INSTANTIATE_TEST_CASE_P(Simple,
-        BitIO,
-        ::testing::Values(
-            TestCaseParameter(
-                {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},
-                "11111111 10000000 00111111 11100000 00001111 11111000 "),
-            TestCaseParameter(
-                {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},
-                "01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 "),
-            TestCaseParameter({{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}),
-            TestCaseParameter({{33, BIT_PATTERN}, {33, BIT_PATTERN}}),
-            TestCaseParameter({{24, 0xFFFFFFFF}},
-                "11111111 11111111 11111111 ")
-),);
+    BitIO,
+    ::testing::ValuesIn(std::initializer_list<TestCaseParameter>{
+        {
+            {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},
+            "11111111 10000000 00111111 11100000 00001111 11111000 "
+        },
+        {
+            {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},
+            "01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 "
+        },
+        {
+            {{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}
+        },
+        {
+            {{33, BIT_PATTERN}, {33, BIT_PATTERN}}
+        },
+        {
+            {{24, 0xFFFFFFFF}},
+            "11111111 11111111 11111111 "
+        },
+        {
+            // Note that we take only N lower bits of the number: {3, 0b01011} => 011
+            {{5, 0b01010}, {3, 0b111}, {7, 0b11001100}, {6, 0}, {5, 0b11111111}, {4, 0}, {3, 0b101}, {2, 0}, {1, 0b11111111}},
+            "01010111 10011000 00000111 11000010 10010000 "
+        },
+        {
+            {{64, BIT_PATTERN}, {56, BIT_PATTERN} , {4, 0b1111}, {4, 0}, // 128
+             {8, 0b11111111}, {64, BIT_PATTERN}, {48, BIT_PATTERN}, {8, 0}}, // 256
+            "11101011 11101111 10111010 11101111 10101111 10111010 11101011 10101001 " // 64
+            "11101111 10111010 11101111 10101111 10111010 11101011 10101001 11110000 " // 128
+            "11111111 11101011 11101111 10111010 11101111 10101111 10111010 11101011 " // 192
+            "10101001 10111010 11101111 10101111 10111010 11101011 10101001 00000000 " // 256
+        },
+        {
+            {{64, BIT_PATTERN}, {56, BIT_PATTERN} , {5, 0b11111}, {3, 0}, // 128
+             {8, 0b11111111}, {64, BIT_PATTERN}, {48, BIT_PATTERN}, {8, 0}, //256
+             {32, BIT_PATTERN}, {12, 0xff}, {8, 0}, {12, 0xAEff}},
+            "11101011 11101111 10111010 11101111 10101111 10111010 11101011 10101001 " // 64
+            "11101111 10111010 11101111 10101111 10111010 11101011 10101001 11111000 " // 128
+            "11111111 11101011 11101111 10111010 11101111 10101111 10111010 11101011 " // 192
+            "10101001 10111010 11101111 10101111 10111010 11101011 10101001 00000000 " // 256
+            "10101111 10111010 11101011 10101001 00001111 11110000 00001110 11111111 " // 320
+        }
+    }),
+);
 
 TestCaseParameter primes_case(UInt8 repeat_times, UInt64 pattern)
 {
