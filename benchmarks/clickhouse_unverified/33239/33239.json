{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33239,
  "instance_id": "ClickHouse__ClickHouse-33239",
  "issue_numbers": [
    "32804"
  ],
  "base_commit": "fcdbf8737ac3142730cc43f51b1210a7e28b8f68",
  "patch": "diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 8677cf59d79e..a1f83c81a81e 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -466,7 +466,7 @@ StorageID InterpreterInsertQuery::getDatabaseTable() const\n }\n \n \n-void InterpreterInsertQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr &, ContextPtr context_) const\n+void InterpreterInsertQuery::extendQueryLogElemImpl(QueryLogElement & elem, ContextPtr context_)\n {\n     elem.query_kind = \"Insert\";\n     const auto & insert_table = context_->getInsertionTable();\n@@ -477,4 +477,9 @@ void InterpreterInsertQuery::extendQueryLogElemImpl(QueryLogElement & elem, cons\n     }\n }\n \n+void InterpreterInsertQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr &, ContextPtr context_) const\n+{\n+    extendQueryLogElemImpl(elem, context_);\n+}\n+\n }\ndiff --git a/src/Interpreters/InterpreterInsertQuery.h b/src/Interpreters/InterpreterInsertQuery.h\nindex e5733a8c28b2..93de92a0680d 100644\n--- a/src/Interpreters/InterpreterInsertQuery.h\n+++ b/src/Interpreters/InterpreterInsertQuery.h\n@@ -40,6 +40,7 @@ class InterpreterInsertQuery : public IInterpreter, WithContext\n         ThreadStatus * thread_status = nullptr,\n         std::atomic_uint64_t * elapsed_counter_ms = nullptr);\n \n+    static void extendQueryLogElemImpl(QueryLogElement & elem, ContextPtr context_);\n     void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context_) const override;\n \n     StoragePtr getTable(ASTInsertQuery & query);\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex e177fd8e6b3b..bd3c35c12f6e 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -556,9 +556,14 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n \n         auto * insert_query = ast->as<ASTInsertQuery>();\n \n-        if (insert_query && insert_query->table_id)\n-            /// Resolve database before trying to use async insert feature - to properly hash the query.\n-            insert_query->table_id = context->resolveStorageID(insert_query->table_id);\n+        /// Resolve database before trying to use async insert feature - to properly hash the query.\n+        if (insert_query)\n+        {\n+            if (insert_query->table_id)\n+                insert_query->table_id = context->resolveStorageID(insert_query->table_id);\n+            else if (auto table = insert_query->getTable(); !table.empty())\n+                insert_query->table_id = context->resolveStorageID(StorageID{insert_query->getDatabase(), table});\n+        }\n \n         if (insert_query && insert_query->select)\n         {\n@@ -579,8 +584,14 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             }\n         }\n         else\n+        {\n             /// reset Input callbacks if query is not INSERT SELECT\n             context->resetInputCallbacks();\n+        }\n+\n+        StreamLocalLimits limits;\n+        std::shared_ptr<const EnabledQuota> quota;\n+        std::unique_ptr<IInterpreter> interpreter;\n \n         auto * queue = context->getAsynchronousInsertQueue();\n         const bool async_insert = queue\n@@ -591,65 +602,71 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         {\n             queue->push(ast, context);\n \n-            BlockIO io;\n             if (settings.wait_for_async_insert)\n             {\n                 auto timeout = settings.wait_for_async_insert_timeout.totalMilliseconds();\n                 auto query_id = context->getCurrentQueryId();\n                 auto source = std::make_shared<WaitForAsyncInsertSource>(query_id, timeout, *queue);\n-                io.pipeline = QueryPipeline(Pipe(std::move(source)));\n+                res.pipeline = QueryPipeline(Pipe(std::move(source)));\n             }\n \n-            return std::make_tuple(ast, std::move(io));\n-        }\n-\n-        auto interpreter = InterpreterFactory::get(ast, context, SelectQueryOptions(stage).setInternal(internal));\n-\n-        std::shared_ptr<const EnabledQuota> quota;\n-        if (!interpreter->ignoreQuota())\n-        {\n             quota = context->getQuota();\n             if (quota)\n             {\n-                if (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>())\n-                {\n-                    quota->used(QuotaType::QUERY_SELECTS, 1);\n-                }\n-                else if (ast->as<ASTInsertQuery>())\n-                {\n-                    quota->used(QuotaType::QUERY_INSERTS, 1);\n-                }\n+                quota->used(QuotaType::QUERY_INSERTS, 1);\n                 quota->used(QuotaType::QUERIES, 1);\n-                quota->checkExceeded(QuotaType::ERRORS);\n             }\n-        }\n \n-        StreamLocalLimits limits;\n-        if (!interpreter->ignoreLimits())\n-        {\n-            limits.mode = LimitsMode::LIMITS_CURRENT; //-V1048\n-            limits.size_limits = SizeLimits(settings.max_result_rows, settings.max_result_bytes, settings.result_overflow_mode);\n+            const auto & table_id = insert_query->table_id;\n+            if (!table_id.empty())\n+                context->setInsertionTable(table_id);\n         }\n-\n+        else\n         {\n-            std::unique_ptr<OpenTelemetrySpanHolder> span;\n-            if (context->query_trace_context.trace_id != UUID())\n+            interpreter = InterpreterFactory::get(ast, context, SelectQueryOptions(stage).setInternal(internal));\n+\n+            if (!interpreter->ignoreQuota())\n             {\n-                auto * raw_interpreter_ptr = interpreter.get();\n-                std::string class_name(abi::__cxa_demangle(typeid(*raw_interpreter_ptr).name(), nullptr, nullptr, nullptr));\n-                span = std::make_unique<OpenTelemetrySpanHolder>(class_name + \"::execute()\");\n+                quota = context->getQuota();\n+                if (quota)\n+                {\n+                    if (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>())\n+                    {\n+                        quota->used(QuotaType::QUERY_SELECTS, 1);\n+                    }\n+                    else if (ast->as<ASTInsertQuery>())\n+                    {\n+                        quota->used(QuotaType::QUERY_INSERTS, 1);\n+                    }\n+                    quota->used(QuotaType::QUERIES, 1);\n+                    quota->checkExceeded(QuotaType::ERRORS);\n+                }\n             }\n-            res = interpreter->execute();\n-        }\n \n-        QueryPipeline & pipeline = res.pipeline;\n+            if (!interpreter->ignoreLimits())\n+            {\n+                limits.mode = LimitsMode::LIMITS_CURRENT; //-V1048\n+                limits.size_limits = SizeLimits(settings.max_result_rows, settings.max_result_bytes, settings.result_overflow_mode);\n+            }\n \n-        if (const auto * insert_interpreter = typeid_cast<const InterpreterInsertQuery *>(&*interpreter))\n-        {\n-            /// Save insertion table (not table function). TODO: support remote() table function.\n-            auto table_id = insert_interpreter->getDatabaseTable();\n-            if (!table_id.empty())\n-                context->setInsertionTable(std::move(table_id));\n+            {\n+                std::unique_ptr<OpenTelemetrySpanHolder> span;\n+                if (context->query_trace_context.trace_id != UUID())\n+                {\n+                    auto * raw_interpreter_ptr = interpreter.get();\n+                    std::string class_name(abi::__cxa_demangle(typeid(*raw_interpreter_ptr).name(), nullptr, nullptr, nullptr));\n+                    span = std::make_unique<OpenTelemetrySpanHolder>(class_name + \"::execute()\");\n+                }\n+                res = interpreter->execute();\n+            }\n+\n+            if (const auto * insert_interpreter = typeid_cast<const InterpreterInsertQuery *>(&*interpreter))\n+            {\n+                /// Save insertion table (not table function). TODO: support remote() table function.\n+                auto table_id = insert_interpreter->getDatabaseTable();\n+                if (!table_id.empty())\n+                    context->setInsertionTable(std::move(table_id));\n+            }\n         }\n \n         if (process_list_entry)\n@@ -663,6 +680,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         /// Hold element of process list till end of query execution.\n         res.process_list_entry = process_list_entry;\n \n+        auto & pipeline = res.pipeline;\n+\n         if (pipeline.pulling() || pipeline.completed())\n         {\n             /// Limits on the result, the quota on the result, and also callback for progress.\n@@ -712,7 +731,10 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     elem.query_views = info.views;\n                 }\n \n-                interpreter->extendQueryLogElem(elem, ast, context, query_database, query_table);\n+                if (async_insert)\n+                    InterpreterInsertQuery::extendQueryLogElemImpl(elem, context);\n+                else if (interpreter)\n+                    interpreter->extendQueryLogElem(elem, ast, context, query_database, query_table);\n \n                 if (settings.log_query_settings)\n                     elem.query_settings = std::make_shared<Settings>(context->getSettingsRef());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02156_async_insert_query_log.reference b/tests/queries/0_stateless/02156_async_insert_query_log.reference\nnew file mode 100644\nindex 000000000000..404dbfe753d3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02156_async_insert_query_log.reference\n@@ -0,0 +1,4 @@\n+1\ta\n+2\tb\n+INSERT INTO async_inserts_2156 VALUES \t1\tInsert\t1\t0\n+INSERT INTO async_inserts_2156 VALUES \t1\tInsert\t1\t\ndiff --git a/tests/queries/0_stateless/02156_async_insert_query_log.sh b/tests/queries/0_stateless/02156_async_insert_query_log.sh\nnew file mode 100755\nindex 000000000000..d7177fbe70c1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02156_async_insert_query_log.sh\n@@ -0,0 +1,23 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS async_inserts_2156\"\n+${CLICKHOUSE_CLIENT} -q \"CREATE TABLE async_inserts_2156 (id UInt32, s String) ENGINE = Memory\"\n+\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&async_insert=1&wait_for_async_insert=0\" -d \"INSERT INTO async_inserts_2156 VALUES (1, 'a')\"\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&async_insert=1&wait_for_async_insert=1\" -d \"INSERT INTO async_inserts_2156 VALUES (2, 'b')\"\n+\n+${CLICKHOUSE_CLIENT} -q \"SELECT * FROM async_inserts_2156 ORDER BY id\"\n+\n+${CLICKHOUSE_CLIENT} -q \"SYSTEM FLUSH LOGS\"\n+\n+${CLICKHOUSE_CLIENT} -q \"SELECT query, arrayExists(x -> x LIKE '%async_inserts_2156', tables), \\\n+        query_kind, Settings['async_insert'], Settings['wait_for_async_insert'] FROM system.query_log \\\n+    WHERE event_date >= yesterday() AND current_database = '$CLICKHOUSE_DATABASE' \\\n+    AND query ILIKE 'INSERT INTO async_inserts_2156 VALUES%' AND type = 'QueryFinish' \\\n+    ORDER BY query_start_time_microseconds\"\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE async_inserts_2156\"\n",
  "problem_statement": "No query_log for inserts if async_insert used\nIf we are enabling async_insert, query log missing all insert queries.\r\n\r\nWe are using log for monitoring, too (inserts time, inserts frequency etc), and with  async_insert query_log is empty. Maybe log can be written anyway?\n",
  "hints_text": "Yes, queries with `async_insert` can be written to query log. It's not done by mistake. However, it may slightly decrease performance, but since query log has buffering too, I think, it will be ok.",
  "created_at": "2021-12-27T20:28:21Z",
  "modified_files": [
    "src/Interpreters/InterpreterInsertQuery.cpp",
    "src/Interpreters/InterpreterInsertQuery.h",
    "src/Interpreters/executeQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02156_async_insert_query_log.reference",
    "b/tests/queries/0_stateless/02156_async_insert_query_log.sh"
  ]
}