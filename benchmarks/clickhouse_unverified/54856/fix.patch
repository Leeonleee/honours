diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index a3883cd22ce7..0364a6104041 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -732,14 +732,15 @@ Returns for a given date, the number of days passed since [1 January 0000](https
 **Syntax**
 
 ``` sql
-toDaysSinceYearZero(date)
+toDaysSinceYearZero(date[, time_zone])
 ```
 
 Aliases: `TO_DAYS`
 
-**Arguments**
 
-- `date` — The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md) or [Date32](../../sql-reference/data-types/date32.md).
+**Arguments**
+- `date` — The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).
+- `time_zone` — A String type const value or a expression represent the time zone. [String types](../../sql-reference/data-types/string.md)
 
 **Returned value**
 
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 54cb3d0d5c2e..782dce116a4c 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -371,9 +371,11 @@ struct WhichDataType
 
     constexpr bool isDate() const { return idx == TypeIndex::Date; }
     constexpr bool isDate32() const { return idx == TypeIndex::Date32; }
+    constexpr bool isDateOrDate32() const { return isDate() || isDate32(); }
     constexpr bool isDateTime() const { return idx == TypeIndex::DateTime; }
     constexpr bool isDateTime64() const { return idx == TypeIndex::DateTime64; }
-    constexpr bool isDateOrDate32() const { return isDate() || isDate32(); }
+    constexpr bool isDateTimeOrDateTime64() const { return isDateTime() || isDateTime64(); }
+    constexpr bool isDateOrDate32OrDateTimeOrDateTime64() const { return isDateOrDate32() || isDateTimeOrDateTime64(); }
 
     constexpr bool isString() const { return idx == TypeIndex::String; }
     constexpr bool isFixedString() const { return idx == TypeIndex::FixedString; }
@@ -410,6 +412,10 @@ template <typename T>
 inline bool isDateTime(const T & data_type) { return WhichDataType(data_type).isDateTime(); }
 template <typename T>
 inline bool isDateTime64(const T & data_type) { return WhichDataType(data_type).isDateTime64(); }
+template <typename T>
+inline bool isDateTimeOrDateTime64(const T & data_type) { return WhichDataType(data_type).isDateTimeOrDateTime64(); }
+template <typename T>
+inline bool isDateOrDate32OrDateTimeOrDateTime64(const T & data_type) { return WhichDataType(data_type).isDateOrDate32OrDateTimeOrDateTime64(); }
 
 template <typename T>
 inline bool isEnum(const T & data_type) { return WhichDataType(data_type).isEnum(); }
@@ -433,26 +439,14 @@ template <typename T>
 inline bool isIPv6(const T & data_type) { return WhichDataType(data_type).isIPv6(); }
 
 template <typename T>
-inline bool isObject(const T & data_type) { return WhichDataType(data_type).isObject();
-}
+inline bool isObject(const T & data_type) { return WhichDataType(data_type).isObject(); }
 
 template <typename T>
-inline bool isUInt8(const T & data_type)
-{
-    return WhichDataType(data_type).isUInt8();
-}
-
+inline bool isUInt8(const T & data_type) { return WhichDataType(data_type).isUInt8(); }
 template <typename T>
-inline bool isUInt64(const T & data_type)
-{
-    return WhichDataType(data_type).isUInt64();
-}
-
+inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }
 template <typename T>
-inline bool isUnsignedInteger(const T & data_type)
-{
-    return WhichDataType(data_type).isUInt();
-}
+inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }
 
 template <typename T>
 inline bool isInteger(const T & data_type)
diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h
index a351d7fdf306..a845f63626dd 100644
--- a/src/Functions/DateTimeTransforms.h
+++ b/src/Functions/DateTimeTransforms.h
@@ -928,28 +928,27 @@ struct ToDayOfYearImpl
 struct ToDaysSinceYearZeroImpl
 {
 private:
-    /// Constant calculated from MySQL's TO_DAYS() implementation.
-    /// https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/mysys/my_time.cc#L1042
-    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1900 = 693'961; /// 01 January, each
+    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().
+    static constexpr auto SECONDS_PER_DAY = 60 * 60 * 24;
 
 public:
     static constexpr auto name = "toDaysSinceYearZero";
 
-    static UInt32 execute(Int64, const DateLUTImpl &)
+    static UInt32 execute(Int64 t, const DateLUTImpl & time_zone)
     {
-        throwDateTimeIsNotSupported(name);
+        return DAYS_BETWEEN_YEARS_0_AND_1970 + static_cast<UInt32>(time_zone.toDayNum(t));
     }
-    static UInt32 execute(UInt32, const DateLUTImpl &)
+    static UInt32 execute(UInt32 d, const DateLUTImpl &)
     {
-        throwDateTimeIsNotSupported(name);
+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d / SECONDS_PER_DAY;
     }
     static UInt32 execute(Int32 d, const DateLUTImpl &)
     {
-        return DAYS_BETWEEN_YEARS_0_AND_1900 + d;
+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d;
     }
     static UInt32 execute(UInt16 d, const DateLUTImpl &)
     {
-        return DAYS_BETWEEN_YEARS_0_AND_1900 + d;
+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d;
     }
     static constexpr bool hasPreimage() { return false; }
 
diff --git a/src/Functions/FunctionDateOrDateTimeToSomething.h b/src/Functions/FunctionDateOrDateTimeToSomething.h
index d98b788c7d74..e5e12ec6e92d 100644
--- a/src/Functions/FunctionDateOrDateTimeToSomething.h
+++ b/src/Functions/FunctionDateOrDateTimeToSomething.h
@@ -19,9 +19,10 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        this->checkArguments(arguments, (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>));
+        constexpr bool result_is_date_or_date32 = (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>);
+        this->checkArguments(arguments, result_is_date_or_date32);
 
-        /// For DateTime, if time zone is specified, attach it to type.
+        /// For DateTime results, if time zone is specified, attach it to type.
         /// If the time zone is specified but empty, throw an exception.
         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)
         {
@@ -34,6 +35,7 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo
                     this->getName());
             return std::make_shared<ToDataType>(time_zone);
         }
+
         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)
         {
             Int64 scale = DataTypeDateTime64::default_scale;
@@ -42,17 +44,11 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo
             auto source_scale = scale;
 
             if constexpr (std::is_same_v<ToStartOfMillisecondImpl, Transform>)
-            {
                 scale = std::max(source_scale, static_cast<Int64>(3));
-            }
             else if constexpr (std::is_same_v<ToStartOfMicrosecondImpl, Transform>)
-            {
                 scale = std::max(source_scale, static_cast<Int64>(6));
-            }
             else if constexpr (std::is_same_v<ToStartOfNanosecondImpl, Transform>)
-            {
                 scale = std::max(source_scale, static_cast<Int64>(9));
-            }
 
             return std::make_shared<ToDataType>(scale, extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, false));
         }
@@ -63,18 +59,16 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
         const IDataType * from_type = arguments[0].type.get();
-        WhichDataType which(from_type);
 
-        if (which.isDate())
+        if (isDate(from_type))
             return DateTimeTransformImpl<DataTypeDate, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);
-        else if (which.isDate32())
+        else if (isDate32(from_type))
             return DateTimeTransformImpl<DataTypeDate32, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);
-        else if (which.isDateTime())
+        else if (isDateTime(from_type))
             return DateTimeTransformImpl<DataTypeDateTime, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);
-        else if (which.isDateTime64())
+        else if (isDateTime64(from_type))
         {
             const auto scale = static_cast<const DataTypeDateTime64 *>(from_type)->getScale();
-
             const TransformDateTime64<Transform> transformer(scale);
             return DateTimeTransformImpl<DataTypeDateTime64, ToDataType, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);
         }
diff --git a/src/Functions/IFunctionDateOrDateTime.h b/src/Functions/IFunctionDateOrDateTime.h
index c22754eecd76..762b79bfafc7 100644
--- a/src/Functions/IFunctionDateOrDateTime.h
+++ b/src/Functions/IFunctionDateOrDateTime.h
@@ -110,14 +110,14 @@ class IFunctionDateOrDateTime : public IFunction
     {
         if (arguments.size() == 1)
         {
-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64",
                     arguments[0].type->getName(), getName());
         }
         else if (arguments.size() == 2)
         {
-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64",
                     arguments[0].type->getName(), getName());
diff --git a/src/Functions/toDaysSinceYearZero.cpp b/src/Functions/toDaysSinceYearZero.cpp
index e569c5cb1f30..f6239b2900b3 100644
--- a/src/Functions/toDaysSinceYearZero.cpp
+++ b/src/Functions/toDaysSinceYearZero.cpp
@@ -1,80 +1,23 @@
-#include <Columns/ColumnsNumber.h>
-#include <DataTypes/DataTypeDate.h>
-#include <DataTypes/DataTypeDate32.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Functions/DateTimeTransforms.h>
+#include <Functions/FunctionDateOrDateTimeToSomething.h>
 #include <Functions/FunctionFactory.h>
-#include <Functions/FunctionHelpers.h>
-#include <Functions/IFunction.h>
 
 
 namespace DB
 {
 
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-}
-
-namespace
-{
-
-/** Returns number of days passed since 0000-01-01 */
-class FunctionToDaysSinceYearZero : public IFunction
-{
-    using ResultType = DataTypeUInt32;
-public:
-    static constexpr auto name = "toDaysSinceYearZero";
-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToDaysSinceYearZero>(context); }
-
-    explicit FunctionToDaysSinceYearZero(ContextPtr /*context*/) {}
-
-    String getName() const override { return name; }
-    size_t getNumberOfArguments() const override { return 1; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        FunctionArgumentDescriptors mandatory_args{
-            {"date", &isDateOrDate32<IDataType>, nullptr, "Date or Date32"}
-        };
-
-        validateFunctionArgumentTypes(*this, arguments, mandatory_args);
-
-        return std::make_shared<DataTypeUInt32>();
-    }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        const IDataType * from_type = arguments[0].type.get();
-        WhichDataType which(from_type);
-
-        if (which.isDate())
-            return DateTimeTransformImpl<DataTypeDate, ResultType, ToDaysSinceYearZeroImpl>::execute(arguments, result_type, input_rows_count);
-        else if (which.isDate32())
-            return DateTimeTransformImpl<DataTypeDate32, ResultType, ToDaysSinceYearZeroImpl>::execute(arguments, result_type, input_rows_count);
-
-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-            "Illegal type {} of argument of function {}",
-            arguments[0].type->getName(), this->getName());
-    }
-};
-
-}
+using FunctionToDaysSinceYearZero = FunctionDateOrDateTimeToSomething<DataTypeUInt32, ToDaysSinceYearZeroImpl>;
 
 REGISTER_FUNCTION(ToDaysSinceYearZero)
 {
-    factory.registerFunction<FunctionToDaysSinceYearZero>(
-    FunctionDocumentation{
-    .description=R"(
-Returns for a given date, the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601.
+    factory.registerFunction<FunctionToDaysSinceYearZero>(FunctionDocumentation{
+        .description = R"(
+Returns for a given date or date with time, the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601.
 The calculation is the same as in MySQL's TO_DAYS() function.
 )",
-    .examples{
-        {"typical", "SELECT toDaysSinceYearZero(toDate('2023-09-08'))", "713569"}},
-    .categories{"Dates and Times"}
-    });
+        .examples{{"typical", "SELECT toDaysSinceYearZero(toDate('2023-09-08'))", "713569"}},
+        .categories{"Dates and Times"}});
 
     /// MySQL compatibility alias.
     factory.registerAlias("TO_DAYS", FunctionToDaysSinceYearZero::name, FunctionFactory::CaseInsensitive);
