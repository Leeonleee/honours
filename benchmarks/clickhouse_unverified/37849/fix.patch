diff --git a/src/Core/SortDescription.h b/src/Core/SortDescription.h
index 730a64b77ad8..6c19ce361157 100644
--- a/src/Core/SortDescription.h
+++ b/src/Core/SortDescription.h
@@ -28,7 +28,9 @@ struct FillColumnDescription
     /// All missed values in range [FROM, TO) will be filled
     /// Range [FROM, TO) respects sorting direction
     Field fill_from;        /// Fill value >= FILL_FROM
+    DataTypePtr fill_from_type;
     Field fill_to;          /// Fill value + STEP < FILL_TO
+    DataTypePtr fill_to_type;
     Field fill_step;        /// Default = +1 or -1 according to direction
     std::optional<IntervalKind> step_kind;
 
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index a05d353ac733..9faf91f7a43a 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -825,14 +825,15 @@ Block InterpreterSelectQuery::getSampleBlockImpl()
     return analysis_result.final_projection->getResultColumns();
 }
 
-static Field getWithFillFieldValue(const ASTPtr & node, const ContextPtr & context)
+
+static std::pair<Field, DataTypePtr> getWithFillFieldValue(const ASTPtr & node, ContextPtr context)
 {
-    auto [field, type] = evaluateConstantExpression(node, context);
+    auto field_type = evaluateConstantExpression(node, context);
 
-    if (!isColumnedAsNumber(type))
-        throw Exception("Illegal type " + type->getName() + " of WITH FILL expression, must be numeric type", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);
+    if (!isColumnedAsNumber(field_type.second))
+        throw Exception("Illegal type " + field_type.second->getName() + " of WITH FILL expression, must be numeric type", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);
 
-    return field;
+    return field_type;
 }
 
 static std::pair<Field, std::optional<IntervalKind>> getWithFillStep(const ASTPtr & node, const ContextPtr & context)
@@ -853,9 +854,9 @@ static FillColumnDescription getWithFillDescription(const ASTOrderByElement & or
     FillColumnDescription descr;
 
     if (order_by_elem.fill_from)
-        descr.fill_from = getWithFillFieldValue(order_by_elem.fill_from, context);
+        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.fill_from, context);
     if (order_by_elem.fill_to)
-        descr.fill_to = getWithFillFieldValue(order_by_elem.fill_to, context);
+        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.fill_to, context);
 
     if (order_by_elem.fill_step)
         std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.fill_step, context);
diff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp
index b63e1dda084e..311c88e46e8d 100644
--- a/src/Processors/Transforms/FillingTransform.cpp
+++ b/src/Processors/Transforms/FillingTransform.cpp
@@ -54,6 +54,23 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &
     WhichDataType which(type);
     DataTypePtr to_type;
 
+    /// For Date/DateTime types TO/FROM type should match column type
+    if (descr.fill_from_type)
+    {
+        WhichDataType which_from(descr.fill_from_type);
+        if ((which_from.isDateOrDate32() || which_from.isDateTime() || which_from.isDateTime64()) &&
+            !descr.fill_from_type->equals(*type))
+                return false;
+    }
+
+    if (descr.fill_to_type)
+    {
+        WhichDataType which_to(descr.fill_to_type);
+        if ((which_to.isDateOrDate32() || which_to.isDateTime() || which_to.isDateTime64()) &&
+            !descr.fill_to_type->equals(*type))
+                return false;
+    }
+
     /// TODO Wrong results for big integers.
     if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())
     {
