diff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp
index 371c0a075117..59b3b0366988 100644
--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp
+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp
@@ -250,13 +250,13 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont
 
         if (function_node->getFunctionName() == "and")
         {
-            tryReplaceAndEqualsChainsWithConstant(node);
+            tryOptimizeAndEqualsNotEqualsChain(node);
             return;
         }
     }
 
 private:
-    void tryReplaceAndEqualsChainsWithConstant(QueryTreeNodePtr & node)
+    void tryOptimizeAndEqualsNotEqualsChain(QueryTreeNodePtr & node)
     {
         auto & function_node = node->as<FunctionNode &>();
         assert(function_node.getFunctionName() == "and");
@@ -266,53 +266,132 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont
 
         QueryTreeNodes and_operands;
 
-        QueryTreeNodePtrWithHashMap<const ConstantNode *> node_to_constants;
+        QueryTreeNodePtrWithHashMap<const ConstantNode *> equals_node_to_constants;
+        QueryTreeNodePtrWithHashMap<QueryTreeNodeConstRawPtrWithHashSet> not_equals_node_to_constants;
+        QueryTreeNodePtrWithHashMap<QueryTreeNodes> node_to_not_equals_functions;
 
         for (const auto & argument : function_node.getArguments())
         {
             auto * argument_function = argument->as<FunctionNode>();
-            if (!argument_function || argument_function->getFunctionName() != "equals")
+            const auto valid_functions = std::unordered_set<std::string>{"equals", "notEquals"};
+            if (!argument_function || !valid_functions.contains(argument_function->getFunctionName()))
             {
                 and_operands.push_back(argument);
                 continue;
             }
 
-            const auto & equals_arguments = argument_function->getArguments().getNodes();
-            const auto & lhs = equals_arguments[0];
-            const auto & rhs = equals_arguments[1];
+            const auto function_name = argument_function->getFunctionName();
+            const auto & function_arguments = argument_function->getArguments().getNodes();
+            const auto & lhs = function_arguments[0];
+            const auto & rhs = function_arguments[1];
 
-            const auto has_and_with_different_constant = [&](const QueryTreeNodePtr & expression, const ConstantNode * constant)
+            if (function_name == "equals")
             {
-                if (auto it = node_to_constants.find(expression); it != node_to_constants.end())
+                const auto has_and_with_different_constant = [&](const QueryTreeNodePtr & expression, const ConstantNode * constant)
                 {
-                    if (!it->second->isEqual(*constant))
-                        return true;
-                }
+                    if (auto it = equals_node_to_constants.find(expression); it != equals_node_to_constants.end())
+                    {
+                        if (!it->second->isEqual(*constant))
+                            return true;
+                    }
+                    else
+                    {
+                        equals_node_to_constants.emplace(expression, constant);
+                        and_operands.push_back(argument);
+                    }
+
+                    return false;
+                };
+
+                bool collapse_to_false = false;
+
+                if (const auto * lhs_literal = lhs->as<ConstantNode>())
+                    collapse_to_false = has_and_with_different_constant(rhs, lhs_literal);
+                else if (const auto * rhs_literal = rhs->as<ConstantNode>())
+                    collapse_to_false = has_and_with_different_constant(lhs, rhs_literal);
                 else
-                {
-                    node_to_constants.emplace(expression, constant);
                     and_operands.push_back(argument);
+
+                if (collapse_to_false)
+                {
+                    auto false_value = std::make_shared<ConstantValue>(0u, function_node.getResultType());
+                    auto false_node = std::make_shared<ConstantNode>(std::move(false_value));
+                    node = std::move(false_node);
+                    return;
                 }
+            }
+            else if (function_name == "notEquals")
+            {
+                 /// collect all inequality checks (x <> value)
 
-                return false;
-            };
+                const auto add_not_equals_function_if_not_present = [&](const auto & expression_node, const ConstantNode * constant)
+                {
+                    auto & constant_set = not_equals_node_to_constants[expression_node];
+                    if (!constant_set.contains(constant))
+                    {
+                        constant_set.insert(constant);
+                        node_to_not_equals_functions[expression_node].push_back(argument);
+                    }
+                };
+
+                if (const auto * lhs_literal = lhs->as<ConstantNode>();
+                    lhs_literal && !lhs_literal->getValue().isNull())
+                    add_not_equals_function_if_not_present(rhs, lhs_literal);
+                else if (const auto * rhs_literal = rhs->as<ConstantNode>();
+                        rhs_literal && !rhs_literal->getValue().isNull())
+                    add_not_equals_function_if_not_present(lhs, rhs_literal);
+                else
+                    and_operands.push_back(argument);
+            }
+            else
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected function name: '{}'", function_name);
+        }
 
-            bool collapse_to_false = false;
+        auto not_in_function_resolver = FunctionFactory::instance().get("notIn", getContext());
 
-            if (const auto * lhs_literal = lhs->as<ConstantNode>())
-                collapse_to_false = has_and_with_different_constant(rhs, lhs_literal);
-            else if (const auto * rhs_literal = rhs->as<ConstantNode>())
-                collapse_to_false = has_and_with_different_constant(lhs, rhs_literal);
-            else
-                and_operands.push_back(argument);
+        for (auto & [expression, not_equals_functions] : node_to_not_equals_functions)
+        {
+            const auto & settings = getSettings();
+            if (not_equals_functions.size() < settings.optimize_min_inequality_conjunction_chain_length && !expression.node->getResultType()->lowCardinality())
+            {
+                std::move(not_equals_functions.begin(), not_equals_functions.end(), std::back_inserter(and_operands));
+                continue;
+            }
 
-            if (collapse_to_false)
+            Tuple args;
+            args.reserve(not_equals_functions.size());
+            /// first we create tuple from RHS of notEquals functions
+            for (const auto & not_equals : not_equals_functions)
             {
-                auto false_value = std::make_shared<ConstantValue>(0u, function_node.getResultType());
-                auto false_node = std::make_shared<ConstantNode>(std::move(false_value));
-                node = std::move(false_node);
-                return;
+                const auto * not_equals_function = not_equals->as<FunctionNode>();
+                assert(not_equals_function && not_equals_function->getFunctionName() == "notEquals");
+
+                const auto & not_equals_arguments = not_equals_function->getArguments().getNodes();
+                if (const auto * rhs_literal = not_equals_arguments[1]->as<ConstantNode>())
+                {
+                    args.push_back(rhs_literal->getValue());
+                }
+                else
+                {
+                    const auto * lhs_literal = not_equals_arguments[0]->as<ConstantNode>();
+                    assert(lhs_literal);
+                    args.push_back(lhs_literal->getValue());
+                }
             }
+
+            auto rhs_node = std::make_shared<ConstantNode>(std::move(args));
+
+            auto not_in_function = std::make_shared<FunctionNode>("notIn");
+
+            QueryTreeNodes not_in_arguments;
+            not_in_arguments.reserve(2);
+            not_in_arguments.push_back(expression.node);
+            not_in_arguments.push_back(std::move(rhs_node));
+
+            not_in_function->getArguments().getNodes() = std::move(not_in_arguments);
+            not_in_function->resolveAsFunction(not_in_function_resolver);
+
+            and_operands.push_back(std::move(not_in_function));
         }
 
         if (and_operands.size() == function_node.getArguments().getNodes().size())
@@ -322,9 +401,6 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont
         {
             /// AND operator can have UInt8 or bool as its type.
             /// bool is used if a bool constant is at least one operand.
-            /// Because we reduce the number of operands here by eliminating the same equality checks,
-            /// the only situation we can end up here is we had AND check where all the equality checks are the same so we know the type is UInt8.
-            /// Otherwise, we will have > 1 operands and we don't have to do anything.
 
             auto operand_type = and_operands[0]->getResultType();
             auto function_type = function_node.getResultType();
diff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h
index 80062f38eacd..658f6d767c4e 100644
--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h
+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h
@@ -68,7 +68,25 @@ namespace DB
  * WHERE a = 1 AND b = 'test';
  * -------------------------------
  *
- * 5. Remove unnecessary IS NULL checks in JOIN ON clause
+ * 5. Replaces chains of inequality functions inside an AND with a single NOT IN operator.
+ * The replacement is done if:
+ *  - one of the operands of the inequality function is a constant
+ *  - length of chain is at least 'optimize_min_inequality_conjunction_chain_length' long OR the expression has type of LowCardinality
+ *
+ * E.g. (optimize_min_inequality_conjunction_chain_length = 2)
+ * -------------------------------
+ * SELECT *
+ * FROM table
+ * WHERE a <> 1 AND a <> 2;
+ *
+ * will be transformed into
+ *
+ * SELECT *
+ * FROM TABLE
+ * WHERE a NOT IN (1, 2);
+ * -------------------------------
+ *
+ * 6. Remove unnecessary IS NULL checks in JOIN ON clause
  *   - equality check with explicit IS NULL check replaced with <=> operator
  * -------------------------------
  * SELECT * FROM t1 JOIN t2 ON a = b OR (a IS NULL AND b IS NULL)
@@ -85,7 +103,11 @@ class LogicalExpressionOptimizerPass final : public IQueryTreePass
 public:
     String getName() override { return "LogicalExpressionOptimizer"; }
 
-    String getDescription() override { return "Transform equality chain to a single IN function or a constant if possible"; }
+    String getDescription() override
+    {
+        return "Transforms chains of logical expressions if possible, i.e. "
+            "replace chains of equality functions inside an OR with a single IN operator";
+    }
 
     void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;
 };
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index b75004a33966..2a56fc0cce52 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -219,6 +219,7 @@ class IColumn;
     M(Bool, mysql_map_fixed_string_to_text_in_show_columns, false, "If enabled, FixedString type will be mapped to TEXT in SHOW [FULL] COLUMNS, BLOB otherwise.", 0) \
     \
     M(UInt64, optimize_min_equality_disjunction_chain_length, 3, "The minimum length of the expression `expr = x1 OR ... expr = xN` for optimization ", 0) \
+    M(UInt64, optimize_min_inequality_conjunction_chain_length, 3, "The minimum length of the expression `expr <> x1 AND ... expr <> xN` for optimization ", 0) \
     \
     M(UInt64, min_bytes_to_use_direct_io, 0, "The minimum number of bytes for reading the data with O_DIRECT option during SELECT queries execution. 0 - disabled.", 0) \
     M(UInt64, min_bytes_to_use_mmap_io, 0, "The minimum number of bytes for reading the data with mmap option during SELECT queries execution. 0 - disabled.", 0) \
