{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27629,
  "instance_id": "ClickHouse__ClickHouse-27629",
  "issue_numbers": [
    "22029"
  ],
  "base_commit": "974acb615a75285136bbc4bed9319febc014fc27",
  "patch": "diff --git a/src/Dictionaries/DictionaryHelpers.cpp b/src/Dictionaries/DictionaryHelpers.cpp\nnew file mode 100644\nindex 000000000000..b54b9eabfb64\n--- /dev/null\n+++ b/src/Dictionaries/DictionaryHelpers.cpp\n@@ -0,0 +1,48 @@\n+#include \"DictionaryHelpers.h\"\n+\n+namespace DB\n+{\n+\n+MutableColumns deserializeColumnsFromKeys(\n+    const DictionaryStructure & dictionary_structure,\n+    const PaddedPODArray<StringRef> & keys,\n+    size_t start,\n+    size_t end)\n+{\n+    MutableColumns result_columns;\n+    result_columns.reserve(dictionary_structure.key->size());\n+\n+    for (const DictionaryAttribute & attribute : *dictionary_structure.key)\n+        result_columns.emplace_back(attribute.type->createColumn());\n+\n+    for (size_t index = start; index < end; ++index)\n+    {\n+        const auto & key = keys[index];\n+        const auto * ptr = key.data;\n+\n+        for (auto & result_column : result_columns)\n+            ptr = result_column->deserializeAndInsertFromArena(ptr);\n+    }\n+\n+    return result_columns;\n+}\n+\n+ColumnsWithTypeAndName deserializeColumnsWithTypeAndNameFromKeys(\n+    const DictionaryStructure & dictionary_structure,\n+    const PaddedPODArray<StringRef> & keys,\n+    size_t start,\n+    size_t end)\n+{\n+    ColumnsWithTypeAndName result;\n+    MutableColumns columns = deserializeColumnsFromKeys(dictionary_structure, keys, start, end);\n+\n+    for (size_t i = 0, num_columns = columns.size(); i < num_columns; ++i)\n+    {\n+        const auto & dictionary_attribute = (*dictionary_structure.key)[i];\n+        result.emplace_back(ColumnWithTypeAndName{std::move(columns[i]), dictionary_attribute.type, dictionary_attribute.name});\n+    }\n+\n+    return result;\n+}\n+\n+}\ndiff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex dde41864ddc3..3d077414291e 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -497,6 +497,20 @@ class DictionaryKeysExtractor\n     Arena * complex_key_arena;\n };\n \n+/// Deserialize columns from keys array using dictionary structure\n+MutableColumns deserializeColumnsFromKeys(\n+    const DictionaryStructure & dictionary_structure,\n+    const PaddedPODArray<StringRef> & keys,\n+    size_t start,\n+    size_t end);\n+\n+/// Deserialize columns with type and name from keys array using dictionary structure\n+ColumnsWithTypeAndName deserializeColumnsWithTypeAndNameFromKeys(\n+    const DictionaryStructure & dictionary_structure,\n+    const PaddedPODArray<StringRef> & keys,\n+    size_t start,\n+    size_t end);\n+\n /** Merge block with blocks from stream. If there are duplicate keys in block they are filtered out.\n   * In result block_to_update will be merged with blocks from stream.\n   * Note: readPrefix readImpl readSuffix will be called on stream object during function execution.\ndiff --git a/src/Dictionaries/DictionarySource.cpp b/src/Dictionaries/DictionarySource.cpp\nindex 7ba6ea82ca99..fbb03cb00fa5 100644\n--- a/src/Dictionaries/DictionarySource.cpp\n+++ b/src/Dictionaries/DictionarySource.cpp\n@@ -29,7 +29,7 @@ DictionarySourceData::DictionarySourceData(\n     , key_type(DictionaryInputStreamKeyType::ComplexKey)\n {\n     const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n-    fillKeyColumns(keys, 0, keys.size(), dictionary_structure, key_columns);\n+    key_columns = deserializeColumnsWithTypeAndNameFromKeys(dictionary_structure, keys, 0, keys.size());\n }\n \n DictionarySourceData::DictionarySourceData(\n@@ -158,32 +158,4 @@ Block DictionarySourceData::fillBlock(\n     return Block(block_columns);\n }\n \n-void DictionarySourceData::fillKeyColumns(\n-    const PaddedPODArray<StringRef> & keys,\n-    size_t start,\n-    size_t size,\n-    const DictionaryStructure & dictionary_structure,\n-    ColumnsWithTypeAndName & result)\n-{\n-    MutableColumns columns;\n-    columns.reserve(dictionary_structure.key->size());\n-\n-    for (const DictionaryAttribute & attribute : *dictionary_structure.key)\n-        columns.emplace_back(attribute.type->createColumn());\n-\n-    for (size_t index = start; index < size; ++index)\n-    {\n-        const auto & key = keys[index];\n-        const auto *ptr = key.data;\n-        for (auto & column : columns)\n-            ptr = column->deserializeAndInsertFromArena(ptr);\n-    }\n-\n-    for (size_t i = 0, num_columns = columns.size(); i < num_columns; ++i)\n-    {\n-        const auto & dictionary_attribute = (*dictionary_structure.key)[i];\n-        result.emplace_back(ColumnWithTypeAndName{std::move(columns[i]), dictionary_attribute.type, dictionary_attribute.name});\n-    }\n-}\n-\n }\ndiff --git a/src/Dictionaries/DictionarySource.h b/src/Dictionaries/DictionarySource.h\nindex 195a3c664847..cd4b3120ac09 100644\n--- a/src/Dictionaries/DictionarySource.h\n+++ b/src/Dictionaries/DictionarySource.h\n@@ -51,13 +51,6 @@ class DictionarySourceData\n         const DataTypes & types,\n         ColumnsWithTypeAndName && view) const;\n \n-    static void fillKeyColumns(\n-        const PaddedPODArray<StringRef> & keys,\n-        size_t start,\n-        size_t size,\n-        const DictionaryStructure & dictionary_structure,\n-        ColumnsWithTypeAndName & result);\n-\n     const size_t num_rows;\n     std::shared_ptr<const IDictionary> dictionary;\n     std::unordered_set<std::string> column_names;\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex 9f46addd9125..2fc3a5aa0d05 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -134,42 +134,11 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n         if (id->name.empty())\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"'id' cannot be empty\");\n \n-        const char * range_default_type = \"Date\";\n-        if (config.has(structure_prefix + \".range_min\"))\n-            range_min.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + \".range_min\", range_default_type));\n-\n-        if (config.has(structure_prefix + \".range_max\"))\n-            range_max.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + \".range_max\", range_default_type));\n-\n-        if (range_min.has_value() != range_max.has_value())\n-        {\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Dictionary structure should have both 'range_min' and 'range_max' either specified or not.\");\n-        }\n-\n-        if (range_min && range_max && !range_min->type->equals(*range_max->type))\n-        {\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Dictionary structure 'range_min' and 'range_max' should have same type, \"\n-                \"'range_min' type: {},\"\n-                \"'range_max' type: {}\",\n-                range_min->type->getName(),\n-                range_max->type->getName());\n-        }\n-\n-        if (range_min)\n-        {\n-            if (!range_min->type->isValueRepresentedByInteger())\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum.\"\n-                    \" Actual 'range_min' and 'range_max' type is {}\",\n-                    range_min->type->getName());\n-        }\n-\n-        if (!id->expression.empty() || (range_min && !range_min->expression.empty()) || (range_max && !range_max->expression.empty()))\n+        if (!id->expression.empty())\n             has_expressions = true;\n     }\n \n+    parseRangeConfiguration(config, structure_prefix);\n     attributes = getAttributes(config, structure_prefix, /*complex_key_attributes =*/ false);\n \n     for (size_t i = 0; i < attributes.size(); ++i)\n@@ -439,4 +408,42 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n     return res_attributes;\n }\n \n+void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConfiguration & config, const std::string & structure_prefix)\n+{\n+    const char * range_default_type = \"Date\";\n+    if (config.has(structure_prefix + \".range_min\"))\n+        range_min.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + \".range_min\", range_default_type));\n+\n+    if (config.has(structure_prefix + \".range_max\"))\n+        range_max.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + \".range_max\", range_default_type));\n+\n+    if (range_min.has_value() != range_max.has_value())\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Dictionary structure should have both 'range_min' and 'range_max' either specified or not.\");\n+    }\n+\n+    if (range_min && range_max && !range_min->type->equals(*range_max->type))\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Dictionary structure 'range_min' and 'range_max' should have same type, \"\n+            \"'range_min' type: {},\"\n+            \"'range_max' type: {}\",\n+            range_min->type->getName(),\n+            range_max->type->getName());\n+    }\n+\n+    if (range_min)\n+    {\n+        if (!range_min->type->isValueRepresentedByInteger())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum.\"\n+                \" Actual 'range_min' and 'range_max' type is {}\",\n+                range_min->type->getName());\n+    }\n+\n+    if ((range_min && !range_min->expression.empty()) || (range_max && !range_max->expression.empty()))\n+        has_expressions = true;\n+}\n+\n }\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 3ea640d77e8c..6ab849d1d899 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -67,8 +67,9 @@ using DictionaryLifetime = ExternalLoadableLifetime;\n *    - null_value, used as a default value for non-existent entries in the dictionary,\n *        decimal representation for numeric attributes;\n *    - hierarchical, whether this attribute defines a hierarchy;\n-*    - injective, whether the mapping to parent is injective (can be used for optimization of GROUP BY?)\n-*    - is_object_id, used in mongo dictionary, converts string key to objectid\n+*    - injective, whether the mapping to parent is injective (can be used for optimization of GROUP BY?);\n+*    - is_object_id, used in mongo dictionary, converts string key to objectid;\n+*    - is_nullable, is attribute nullable;\n */\n struct DictionaryAttribute final\n {\n@@ -153,6 +154,10 @@ struct DictionaryStructure final\n         const Poco::Util::AbstractConfiguration & config,\n         const std::string & config_prefix,\n         bool complex_key_attributes);\n+\n+    /// parse range_min and range_max\n+    void parseRangeConfiguration(const Poco::Util::AbstractConfiguration & config, const std::string & structure_prefix);\n+\n };\n \n }\ndiff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp\nindex 10c4f67d8090..9ddaaeb573a1 100644\n--- a/src/Dictionaries/ExternalQueryBuilder.cpp\n+++ b/src/Dictionaries/ExternalQueryBuilder.cpp\n@@ -133,6 +133,29 @@ void ExternalQueryBuilder::composeLoadAllQuery(WriteBuffer & out) const\n \n             writeQuoted(key.name, out);\n         }\n+\n+        if (dict_struct.range_min && dict_struct.range_max)\n+        {\n+            writeString(\", \", out);\n+\n+            if (!dict_struct.range_min->expression.empty())\n+            {\n+                writeParenthesisedString(dict_struct.range_min->expression, out);\n+                writeString(\" AS \", out);\n+            }\n+\n+            writeQuoted(dict_struct.range_min->name, out);\n+\n+            writeString(\", \", out);\n+\n+            if (!dict_struct.range_max->expression.empty())\n+            {\n+                writeParenthesisedString(dict_struct.range_max->expression, out);\n+                writeString(\" AS \", out);\n+            }\n+\n+            writeQuoted(dict_struct.range_max->name, out);\n+        }\n     }\n \n     for (const auto & attr : dict_struct.attributes)\ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex 94946e41ff83..af4b77a6ff80 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -64,7 +64,7 @@ class IPAddressDictionary final : public IDictionary\n \n     bool isInjective(const std::string & attribute_name) const override\n     {\n-        return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n+        return dict_struct.getAttribute(attribute_name).injective;\n     }\n \n     DictionaryKeyType getKeyType() const override { return DictionaryKeyType::complex; }\ndiff --git a/src/Dictionaries/RangeDictionarySource.h b/src/Dictionaries/RangeDictionarySource.h\nindex d4fce32a54f6..252ab97ac748 100644\n--- a/src/Dictionaries/RangeDictionarySource.h\n+++ b/src/Dictionaries/RangeDictionarySource.h\n@@ -14,170 +14,241 @@\n namespace DB\n {\n \n-template <typename RangeType>\n+enum class RangeDictionaryType\n+{\n+    simple,\n+    complex\n+};\n+\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n class RangeDictionarySourceData\n {\n public:\n-    using Key = UInt64;\n+\n+    using KeyType = std::conditional_t<range_dictionary_type == RangeDictionaryType::simple, UInt64, StringRef>;\n \n     RangeDictionarySourceData(\n         std::shared_ptr<const IDictionary> dictionary,\n         const Names & column_names,\n-        PaddedPODArray<Key> && ids_to_fill,\n+        PaddedPODArray<KeyType> && keys,\n         PaddedPODArray<RangeType> && start_dates,\n         PaddedPODArray<RangeType> && end_dates);\n \n     Block getBlock(size_t start, size_t length) const;\n-    size_t getNumRows() const { return ids.size(); }\n+    size_t getNumRows() const { return keys.size(); }\n \n private:\n \n     Block fillBlock(\n-        const PaddedPODArray<Key> & ids_to_fill,\n+        const PaddedPODArray<KeyType> & keys_to_fill,\n         const PaddedPODArray<RangeType> & block_start_dates,\n-        const PaddedPODArray<RangeType> & block_end_dates) const;\n+        const PaddedPODArray<RangeType> & block_end_dates,\n+        size_t start,\n+        size_t end) const;\n \n-    PaddedPODArray<Int64> makeDateKey(\n+    PaddedPODArray<Int64> makeDateKeys(\n         const PaddedPODArray<RangeType> & block_start_dates,\n         const PaddedPODArray<RangeType> & block_end_dates) const;\n \n     std::shared_ptr<const IDictionary> dictionary;\n     NameSet column_names;\n-    PaddedPODArray<Key> ids;\n+    PaddedPODArray<KeyType> keys;\n     PaddedPODArray<RangeType> start_dates;\n     PaddedPODArray<RangeType> end_dates;\n };\n \n \n-template <typename RangeType>\n-RangeDictionarySourceData<RangeType>::RangeDictionarySourceData(\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+RangeDictionarySourceData<range_dictionary_type, RangeType>::RangeDictionarySourceData(\n     std::shared_ptr<const IDictionary> dictionary_,\n     const Names & column_names_,\n-    PaddedPODArray<Key> && ids_,\n+    PaddedPODArray<KeyType> && keys,\n     PaddedPODArray<RangeType> && block_start_dates,\n     PaddedPODArray<RangeType> && block_end_dates)\n     : dictionary(dictionary_)\n     , column_names(column_names_.begin(), column_names_.end())\n-    , ids(std::move(ids_))\n+    , keys(std::move(keys))\n     , start_dates(std::move(block_start_dates))\n     , end_dates(std::move(block_end_dates))\n {\n }\n \n-template <typename RangeType>\n-Block RangeDictionarySourceData<RangeType>::getBlock(size_t start, size_t length) const\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+Block RangeDictionarySourceData<range_dictionary_type, RangeType>::getBlock(size_t start, size_t length) const\n {\n-    PaddedPODArray<Key> block_ids;\n+    PaddedPODArray<KeyType> block_keys;\n     PaddedPODArray<RangeType> block_start_dates;\n     PaddedPODArray<RangeType> block_end_dates;\n-    block_ids.reserve(length);\n+    block_keys.reserve(length);\n     block_start_dates.reserve(length);\n     block_end_dates.reserve(length);\n \n-    for (auto idx : collections::range(start, start + length))\n+    for (size_t index = start; index < start + length; ++index)\n     {\n-        block_ids.push_back(ids[idx]);\n-        block_start_dates.push_back(start_dates[idx]);\n-        block_end_dates.push_back(end_dates[idx]);\n+        block_keys.push_back(keys[index]);\n+        block_start_dates.push_back(start_dates[index]);\n+        block_end_dates.push_back(end_dates[index]);\n     }\n \n-    return fillBlock(block_ids, block_start_dates, block_end_dates);\n+    return fillBlock(block_keys, block_start_dates, block_end_dates, start, start + length);\n }\n \n-template <typename RangeType>\n-PaddedPODArray<Int64> RangeDictionarySourceData<RangeType>::makeDateKey(\n-    const PaddedPODArray<RangeType> & block_start_dates, const PaddedPODArray<RangeType> & block_end_dates) const\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+PaddedPODArray<Int64> RangeDictionarySourceData<range_dictionary_type, RangeType>::makeDateKeys(\n+    const PaddedPODArray<RangeType> & block_start_dates,\n+    const PaddedPODArray<RangeType> & block_end_dates) const\n {\n-    PaddedPODArray<Int64> key(block_start_dates.size());\n-    for (size_t i = 0; i < key.size(); ++i)\n+    PaddedPODArray<Int64> keys(block_start_dates.size());\n+\n+    for (size_t i = 0; i < keys.size(); ++i)\n     {\n-        if (RangeHashedDictionary::Range::isCorrectDate(block_start_dates[i]))\n-            key[i] = block_start_dates[i];\n+        if (Range::isCorrectDate(block_start_dates[i]))\n+            keys[i] = block_start_dates[i];\n         else\n-            key[i] = block_end_dates[i];\n+            keys[i] = block_end_dates[i];\n     }\n \n-    return key;\n+    return keys;\n }\n \n \n-template <typename RangeType>\n-Block RangeDictionarySourceData<RangeType>::fillBlock(\n-    const PaddedPODArray<Key> & ids_to_fill,\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+Block RangeDictionarySourceData<range_dictionary_type, RangeType>::fillBlock(\n+    const PaddedPODArray<KeyType> & keys_to_fill,\n     const PaddedPODArray<RangeType> & block_start_dates,\n-    const PaddedPODArray<RangeType> & block_end_dates) const\n+    const PaddedPODArray<RangeType> & block_end_dates,\n+    size_t start,\n+    size_t end) const\n {\n+    std::cerr << \"RangeDictionarySourceData::fillBlock keys_to_fill \" << keys_to_fill.size() << std::endl;\n+\n+    if constexpr (range_dictionary_type == RangeDictionaryType::simple)\n+    {\n+        for (auto & key : keys_to_fill)\n+        {\n+            std::cerr << key << std::endl;\n+        }\n+    }\n+\n     ColumnsWithTypeAndName columns;\n-    const DictionaryStructure & structure = dictionary->getStructure();\n+    const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n \n-    auto ids_column = getColumnFromPODArray(ids_to_fill);\n-    const std::string & id_column_name = structure.id->name;\n-    if (column_names.find(id_column_name) != column_names.end())\n-        columns.emplace_back(ids_column, std::make_shared<DataTypeUInt64>(), id_column_name);\n+    DataTypes keys_types;\n+    Columns keys_columns;\n+    Strings keys_names = dictionary_structure.getKeysNames();\n+\n+    if constexpr (range_dictionary_type == RangeDictionaryType::simple)\n+    {\n+        keys_columns = {getColumnFromPODArray(keys_to_fill)};\n+        keys_types = {std::make_shared<DataTypeUInt64>()};\n+    }\n+    else\n+    {\n+        for (const auto & attribute : *dictionary_structure.key)\n+            keys_types.emplace_back(attribute.type);\n \n-    auto date_key = makeDateKey(block_start_dates, block_end_dates);\n+        auto deserialized_columns = deserializeColumnsFromKeys(dictionary_structure, keys, start, end);\n+        for (auto & deserialized_column : deserialized_columns)\n+            keys_columns.emplace_back(std::move(deserialized_column));\n+    }\n+\n+    size_t keys_size = keys_names.size();\n+\n+    std::cerr << \"Keys size \" << keys_size << \" key columns size \" << keys_columns.size();\n+    std::cerr << \" keys types size \" << keys_types.size() << std::endl;\n+\n+    assert(keys_columns.size() == keys_size);\n+    assert(keys_types.size() == keys_size);\n+\n+    for (size_t i = 0; i < keys_size; ++i)\n+    {\n+        auto & key_name = keys_names[i];\n+\n+        if (column_names.find(key_name) != column_names.end())\n+           columns.emplace_back(keys_columns[i], keys_types[i], key_name);\n+    }\n+\n+    auto date_key = makeDateKeys(block_start_dates, block_end_dates);\n     auto date_column = getColumnFromPODArray(date_key);\n+    keys_columns.emplace_back(std::move(date_column));\n+    keys_types.emplace_back(std::make_shared<DataTypeInt64>());\n \n-    const std::string & range_min_column_name = structure.range_min->name;\n+    const auto & range_min_column_name = dictionary_structure.range_min->name;\n     if (column_names.find(range_min_column_name) != column_names.end())\n     {\n         auto range_min_column = getColumnFromPODArray(block_start_dates);\n-        columns.emplace_back(range_min_column, structure.range_max->type, range_min_column_name);\n+        columns.emplace_back(range_min_column, dictionary_structure.range_max->type, range_min_column_name);\n     }\n \n-    const std::string & range_max_column_name = structure.range_max->name;\n+    const auto & range_max_column_name = dictionary_structure.range_max->name;\n     if (column_names.find(range_max_column_name) != column_names.end())\n     {\n         auto range_max_column = getColumnFromPODArray(block_end_dates);\n-        columns.emplace_back(range_max_column, structure.range_max->type, range_max_column_name);\n+        columns.emplace_back(range_max_column, dictionary_structure.range_max->type, range_max_column_name);\n     }\n \n-    for (const auto idx : collections::range(0, structure.attributes.size()))\n+    size_t attributes_size = dictionary_structure.attributes.size();\n+    for (size_t attribute_index = 0; attribute_index < attributes_size; ++attribute_index)\n     {\n-        const DictionaryAttribute & attribute = structure.attributes[idx];\n-        if (column_names.find(attribute.name) != column_names.end())\n+        const auto & attribute = dictionary_structure.attributes[attribute_index];\n+        if (column_names.find(attribute.name) == column_names.end())\n+            continue;\n+\n+        auto column = dictionary->getColumn(\n+            attribute.name,\n+            attribute.type,\n+            keys_columns,\n+            keys_types,\n+            nullptr /* default_values_column*/);\n+\n+        columns.emplace_back(std::move(column), attribute.type, attribute.name);\n+    }\n+\n+    auto result = Block(columns);\n+\n+    Field value;\n+    std::cerr << \"RangeDictionarySourceData::fillBlock result\" << std::endl;\n+    for (auto & block_column : result)\n+    {\n+        std::cerr << \"Column name \" << block_column.name << \" type \" << block_column.type->getName() << std::endl;\n+\n+        auto & column = block_column.column;\n+        size_t column_size = column->size();\n+\n+        for (size_t i = 0; i < column_size; ++i)\n         {\n-            ColumnPtr column = dictionary->getColumn(\n-                attribute.name,\n-                attribute.type,\n-                {ids_column, date_column},\n-                {std::make_shared<DataTypeUInt64>(), std::make_shared<DataTypeInt64>()},\n-                nullptr);\n-            columns.emplace_back(column, attribute.type, attribute.name);\n+            column->get(i, value);\n+            std::cerr << \"Index \" << i << \" value \" << value.dump() << std::endl;\n         }\n     }\n+\n     return Block(columns);\n }\n \n-/*\n- * BlockInputStream implementation for external dictionaries\n- * read() returns single block consisting of the in-memory contents of the dictionaries\n- */\n-template <typename RangeType>\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n class RangeDictionarySource : public DictionarySourceBase\n {\n public:\n-    using Key = UInt64;\n \n-    RangeDictionarySource(RangeDictionarySourceData<RangeType> data_, size_t max_block_size);\n+    RangeDictionarySource(RangeDictionarySourceData<range_dictionary_type, RangeType> data_, size_t max_block_size);\n \n     String getName() const override { return \"RangeDictionarySource\"; }\n \n protected:\n     Block getBlock(size_t start, size_t length) const override;\n \n-    RangeDictionarySourceData<RangeType> data;\n+    RangeDictionarySourceData<range_dictionary_type, RangeType> data;\n };\n \n-template <typename RangeType>\n-RangeDictionarySource<RangeType>::RangeDictionarySource(RangeDictionarySourceData<RangeType> data_, size_t max_block_size)\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+RangeDictionarySource<range_dictionary_type, RangeType>::RangeDictionarySource(RangeDictionarySourceData<range_dictionary_type, RangeType> data_, size_t max_block_size)\n     : DictionarySourceBase(data_.getBlock(0, 0), data_.getNumRows(), max_block_size)\n     , data(std::move(data_))\n {\n }\n \n-template <typename RangeType>\n-Block RangeDictionarySource<RangeType>::getBlock(size_t start, size_t length) const\n+template <RangeDictionaryType range_dictionary_type, typename RangeType>\n+Block RangeDictionarySource<range_dictionary_type, RangeType>::getBlock(size_t start, size_t length) const\n {\n     return data.getBlock(start, length);\n }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex bbd70b51437a..50935163a96c 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -10,7 +10,8 @@\n \n namespace\n {\n-using RangeStorageType = DB::RangeHashedDictionary::RangeStorageType;\n+\n+using RangeStorageType = DB::RangeStorageType;\n \n // Null values mean that specified boundary, either min or max is not set on range.\n // To simplify comparison, null value of min bound should be bigger than any other value,\n@@ -25,7 +26,7 @@ RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t i\n         return default_value;\n \n     const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));\n-    if (isDate && !DB::RangeHashedDictionary::Range::isCorrectDate(result))\n+    if (isDate && !DB::Range::isCorrectDate(result))\n         return default_value;\n \n     return result;\n@@ -50,27 +51,26 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n     extern const int BAD_ARGUMENTS;\n     extern const int DICTIONARY_IS_EMPTY;\n-    extern const int TYPE_MISMATCH;\n     extern const int UNSUPPORTED_METHOD;\n }\n \n-bool RangeHashedDictionary::Range::isCorrectDate(const RangeStorageType & date)\n+bool Range::isCorrectDate(const RangeStorageType & date)\n {\n     return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;\n }\n \n-bool RangeHashedDictionary::Range::contains(const RangeStorageType & value) const\n+bool Range::contains(const RangeStorageType & value) const\n {\n     return left <= value && value <= right;\n }\n \n-static bool operator<(const RangeHashedDictionary::Range & left, const RangeHashedDictionary::Range & right)\n+static bool operator<(const Range & left, const Range & right)\n {\n     return std::tie(left.left, left.right) < std::tie(right.left, right.right);\n }\n \n-\n-RangeHashedDictionary::RangeHashedDictionary(\n+template <DictionaryKeyType dictionary_key_type>\n+RangeHashedDictionary<dictionary_key_type>::RangeHashedDictionary(\n     const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n@@ -87,7 +87,8 @@ RangeHashedDictionary::RangeHashedDictionary(\n     calculateBytesAllocated();\n }\n \n-ColumnPtr RangeHashedDictionary::getColumn(\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(\n     const std::string & attribute_name,\n     const DataTypePtr & result_type,\n     const Columns & key_columns,\n@@ -96,20 +97,18 @@ ColumnPtr RangeHashedDictionary::getColumn(\n {\n     ColumnPtr result;\n \n-    const auto & attribute = getAttribute(attribute_name);\n     const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n-\n-    auto keys_size = key_columns.front()->size();\n+    const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    const auto & attribute = attributes[attribute_index];\n \n     /// Cast second column to storage type\n     Columns modified_key_columns = key_columns;\n-\n-    auto range_storage_column = key_columns[1];\n-    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types[1], \"\"};\n-\n+    auto range_storage_column = key_columns.back();\n+    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types.back(), \"\"};\n     auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n-    modified_key_columns[1] = castColumnAccurate(column_to_cast, range_column_storage_type);\n+    modified_key_columns.back() = castColumnAccurate(column_to_cast, range_column_storage_type);\n \n+    size_t keys_size = key_columns.front()->size();\n     bool is_attribute_nullable = attribute.is_nullable;\n \n     ColumnUInt8::MutablePtr col_null_map_to;\n@@ -204,24 +203,26 @@ ColumnPtr RangeHashedDictionary::getColumn(\n     return result;\n }\n \n-ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n {\n-    auto range_storage_column = key_columns[1];\n-    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types[1], \"\"};\n-\n     auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n+    auto range_storage_column = key_columns.back();\n+    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types[1], \"\"};\n     auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);\n-\n-    PaddedPODArray<UInt64> key_backup_storage;\n     PaddedPODArray<RangeStorageType> range_backup_storage;\n-\n-    const PaddedPODArray<UInt64> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n     const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);\n \n-    const auto & attribute = attributes.front();\n+    auto key_columns_copy = key_columns;\n+    key_columns_copy.pop_back();\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());\n+    const size_t keys_size = keys_extractor.getKeysSize();\n \n-    ColumnUInt8::Ptr result;\n+    const auto & attribute = attributes.front();\n \n+    auto result = ColumnUInt8::create(keys_size);\n+    auto & out = result->getData();\n     size_t keys_found = 0;\n \n     auto type_call = [&](const auto & dictionary_attribute_type)\n@@ -229,58 +230,48 @@ ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, con\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n         using ValueType = DictionaryValueType<AttributeType>;\n-        result = hasKeysImpl<ValueType>(attribute, ids, dates, keys_found);\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n \n-    query_count.fetch_add(ids.size(), std::memory_order_relaxed);\n-    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n-\n-    return result;\n-}\n+        const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n \n-template <typename AttributeType>\n-ColumnUInt8::Ptr RangeHashedDictionary::hasKeysImpl(\n-    const Attribute & attribute,\n-    const PaddedPODArray<UInt64> & ids,\n-    const PaddedPODArray<RangeStorageType> & dates,\n-    size_t & keys_found) const\n-{\n-    auto result = ColumnUInt8::create(ids.size());\n-    auto& out = result->getData();\n+        for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+        {\n+            const auto key = keys_extractor.extractCurrentKey();\n+            const auto it = collection.find(key);\n \n-    const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);\n+            if (it)\n+            {\n+                const auto date = dates[key_index];\n+                const auto & ranges_and_values = it->getMapped();\n+                const auto val_it = std::find_if(\n+                    std::begin(ranges_and_values),\n+                    std::end(ranges_and_values),\n+                    [date](const Value<ValueType> & v)\n+                    {\n+                        return v.range.contains(date);\n+                    });\n \n-    keys_found = 0;\n+                out[key_index] = val_it != std::end(ranges_and_values);\n+                keys_found += out[key_index];\n+            }\n+            else\n+            {\n+                out[key_index] = false;\n+            }\n \n-    for (const auto row : collections::range(0, ids.size()))\n-    {\n-        const auto it = attr.find(ids[row]);\n+            keys_extractor.rollbackCurrentKey();\n+        }\n+    };\n \n-        if (it)\n-        {\n-            const auto date = dates[row];\n-            const auto & ranges_and_values = it->getMapped();\n-            const auto val_it = std::find_if(\n-                std::begin(ranges_and_values),\n-                std::end(ranges_and_values),\n-                [date](const Value<AttributeType> & v)\n-                {\n-                    return v.range.contains(date);\n-                });\n+    callOnDictionaryAttributeType(attribute.type, type_call);\n \n-            out[row] = val_it != std::end(ranges_and_values);\n-            keys_found += out[row];\n-        }\n-        else\n-            out[row] = false;\n-    }\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n \n     return result;\n }\n \n-void RangeHashedDictionary::createAttributes()\n+template <DictionaryKeyType dictionary_key_type>\n+void RangeHashedDictionary<dictionary_key_type>::createAttributes()\n {\n     const auto size = dict_struct.attributes.size();\n     attributes.reserve(size);\n@@ -296,7 +287,8 @@ void RangeHashedDictionary::createAttributes()\n     }\n }\n \n-void RangeHashedDictionary::loadData()\n+template <DictionaryKeyType dictionary_key_type>\n+void RangeHashedDictionary<dictionary_key_type>::loadData()\n {\n     QueryPipeline pipeline;\n     pipeline.init(source_ptr->loadAll());\n@@ -305,39 +297,60 @@ void RangeHashedDictionary::loadData()\n     Block block;\n     while (executor.pull(block))\n     {\n-        const auto & id_column = *block.safeGetByPosition(0).column;\n+        size_t skip_keys_size_offset = dict_struct.getKeysSize();\n+\n+        Columns key_columns;\n+        key_columns.reserve(skip_keys_size_offset);\n+\n+        /// Split into keys columns and attribute columns\n+        for (size_t i = 0; i < skip_keys_size_offset; ++i)\n+            key_columns.emplace_back(block.safeGetByPosition(i).column);\n+\n+        DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+        DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, arena_holder.getComplexKeyArena());\n+        const size_t keys_size = keys_extractor.getKeysSize();\n+\n+        element_count += keys_size;\n \n         // Support old behaviour, where invalid date means 'open range'.\n         const bool is_date = isDate(dict_struct.range_min->type);\n \n-        const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(1).column);\n-        const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(2).column);\n+        const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset).column);\n+        const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset + 1).column);\n \n-        element_count += id_column.size();\n+        skip_keys_size_offset += 2;\n \n-        for (const auto attribute_idx : collections::range(0, attributes.size()))\n+        for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n         {\n-            const auto & attribute_column = *block.safeGetByPosition(attribute_idx + 3).column;\n-            auto & attribute = attributes[attribute_idx];\n+            const auto & attribute_column = *block.safeGetByPosition(attribute_index + skip_keys_size_offset).column;\n+            auto & attribute = attributes[attribute_index];\n \n-            for (const auto row_idx : collections::range(0, id_column.size()))\n+            for (size_t key_index = 0; key_index < keys_size; ++key_index)\n             {\n+                auto key = keys_extractor.extractCurrentKey();\n+\n                 RangeStorageType lower_bound;\n                 RangeStorageType upper_bound;\n \n                 if (is_date)\n                 {\n-                    lower_bound = getColumnIntValueOrDefault(min_range_column, row_idx, is_date, 0);\n-                    upper_bound = getColumnIntValueOrDefault(max_range_column, row_idx, is_date, DATE_LUT_MAX_DAY_NUM + 1);\n+                    lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, 0);\n+                    upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, DATE_LUT_MAX_DAY_NUM + 1);\n                 }\n                 else\n                 {\n-                    lower_bound = getColumnIntValueOrDefault(min_range_column, row_idx, is_date, RANGE_MIN_NULL_VALUE);\n-                    upper_bound = getColumnIntValueOrDefault(max_range_column, row_idx, is_date, RANGE_MAX_NULL_VALUE);\n+                    lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, RANGE_MIN_NULL_VALUE);\n+                    upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, RANGE_MAX_NULL_VALUE);\n                 }\n \n-                setAttributeValue(attribute, id_column.getUInt(row_idx), Range{lower_bound, upper_bound}, attribute_column[row_idx]);\n+                if constexpr (std::is_same_v<KeyType, StringRef>)\n+                    key = copyKeyInArena(key);\n+\n+                setAttributeValue(attribute, key, Range{lower_bound, upper_bound}, attribute_column[key_index]);\n+                keys_extractor.rollbackCurrentKey();\n             }\n+\n+            keys_extractor.reset();\n         }\n     }\n \n@@ -346,22 +359,8 @@ void RangeHashedDictionary::loadData()\n             \"{}: dictionary source is empty and 'require_nonempty' property is set.\");\n }\n \n-template <typename T>\n-void RangeHashedDictionary::addAttributeSize(const Attribute & attribute)\n-{\n-    const auto & map_ref = std::get<Ptr<T>>(attribute.maps);\n-    bytes_allocated += sizeof(Collection<T>) + map_ref->getBufferSizeInBytes();\n-    bucket_count = map_ref->getBufferSizeInCells();\n-}\n-\n-template <>\n-void RangeHashedDictionary::addAttributeSize<String>(const Attribute & attribute)\n-{\n-    addAttributeSize<StringRef>(attribute);\n-    bytes_allocated += sizeof(Arena) + attribute.string_arena->size();\n-}\n-\n-void RangeHashedDictionary::calculateBytesAllocated()\n+template <DictionaryKeyType dictionary_key_type>\n+void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()\n {\n     bytes_allocated += attributes.size() * sizeof(attributes.front());\n \n@@ -371,14 +370,25 @@ void RangeHashedDictionary::calculateBytesAllocated()\n         {\n             using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n             using AttributeType = typename Type::AttributeType;\n-            addAttributeSize<AttributeType>(attribute);\n+            using ValueType = DictionaryValueType<AttributeType>;\n+\n+            const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n+            bytes_allocated += sizeof(CollectionType<ValueType>) + collection.getBufferSizeInBytes();\n+            bucket_count = collection.getBufferSizeInCells();\n+\n+            if constexpr (std::is_same_v<ValueType, StringRef>)\n+                bytes_allocated += sizeof(Arena) + attribute.string_arena->size();\n         };\n \n         callOnDictionaryAttributeType(attribute.type, type_call);\n     }\n+\n+    if constexpr (dictionary_key_type == DictionaryKeyType::complex)\n+        bytes_allocated += complex_key_arena.size();\n }\n \n-RangeHashedDictionary::Attribute RangeHashedDictionary::createAttribute(const DictionaryAttribute & dictionary_attribute)\n+template <DictionaryKeyType dictionary_key_type>\n+typename RangeHashedDictionary<dictionary_key_type>::Attribute RangeHashedDictionary<dictionary_key_type>::createAttribute(const DictionaryAttribute & dictionary_attribute)\n {\n     Attribute attribute{dictionary_attribute.underlying_type, dictionary_attribute.is_nullable, {}, {}};\n \n@@ -391,7 +401,7 @@ RangeHashedDictionary::Attribute RangeHashedDictionary::createAttribute(const Di\n         if constexpr (std::is_same_v<AttributeType, String>)\n             attribute.string_arena = std::make_unique<Arena>();\n \n-        attribute.maps = std::make_unique<Collection<ValueType>>();\n+        attribute.maps = CollectionType<ValueType>();\n     };\n \n     callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n@@ -399,29 +409,35 @@ RangeHashedDictionary::Attribute RangeHashedDictionary::createAttribute(const Di\n     return attribute;\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n-void RangeHashedDictionary::getItemsImpl(\n+void RangeHashedDictionary<dictionary_key_type>::getItemsImpl(\n     const Attribute & attribute,\n     const Columns & key_columns,\n     ValueSetter && set_value,\n     DefaultValueExtractor & default_value_extractor) const\n {\n-    PaddedPODArray<UInt64> key_backup_storage;\n-    PaddedPODArray<RangeStorageType> range_backup_storage;\n+    const auto & collection = std::get<CollectionType<AttributeType>>(attribute.maps);\n \n-    const PaddedPODArray<UInt64> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n-    const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, key_columns[1], range_backup_storage);\n+    size_t keys_found = 0;\n \n-    const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);\n+    PaddedPODArray<RangeStorageType> range_backup_storage;\n+    const auto & dates = getColumnVectorData(this, key_columns.back(), range_backup_storage);\n \n-    size_t keys_found = 0;\n+    auto key_columns_copy = key_columns;\n+    key_columns_copy.pop_back();\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());\n+    const size_t keys_size = keys_extractor.getKeysSize();\n \n-    for (const auto row : collections::range(0, ids.size()))\n+    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n     {\n-        const auto it = attr.find(ids[row]);\n+        auto key = keys_extractor.extractCurrentKey();\n+        const auto it = collection.find(key);\n+\n         if (it)\n         {\n-            const auto date = dates[row];\n+            const auto date = dates[key_index];\n             const auto & ranges_and_values = it->getMapped();\n             const auto val_it = std::find_if(\n                 std::begin(ranges_and_values),\n@@ -439,35 +455,38 @@ void RangeHashedDictionary::getItemsImpl(\n                 if constexpr (is_nullable)\n                 {\n                     if (value.has_value())\n-                        set_value(row, *value, false);\n+                        set_value(key_index, *value, false);\n                     else\n-                        set_value(row, default_value_extractor[row], true);\n+                        set_value(key_index, default_value_extractor[key_index], true);\n                 }\n                 else\n                 {\n-                    set_value(row, *value, false);\n+                    set_value(key_index, *value, false);\n                 }\n \n+                keys_extractor.rollbackCurrentKey();\n                 continue;\n             }\n         }\n \n         if constexpr (is_nullable)\n-            set_value(row, default_value_extractor[row], default_value_extractor.isNullAt(row));\n+            set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));\n         else\n-            set_value(row, default_value_extractor[row], false);\n+            set_value(key_index, default_value_extractor[key_index], false);\n+\n+        keys_extractor.rollbackCurrentKey();\n     }\n \n-    query_count.fetch_add(ids.size(), std::memory_order_relaxed);\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n }\n \n-\n+template <DictionaryKeyType dictionary_key_type>\n template <typename T>\n-void RangeHashedDictionary::setAttributeValueImpl(Attribute & attribute, const UInt64 id, const Range & range, const Field & value)\n+void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute & attribute, KeyType key, const Range & range, const Field & value)\n {\n     using ValueType = std::conditional_t<std::is_same_v<T, String>, StringRef, T>;\n-    auto & map = *std::get<Ptr<ValueType>>(attribute.maps);\n+    auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n \n     Value<ValueType> value_to_insert;\n \n@@ -490,61 +509,47 @@ void RangeHashedDictionary::setAttributeValueImpl(Attribute & attribute, const U\n         }\n     }\n \n-    const auto it = map.find(id);\n+    const auto it = collection.find(key);\n \n     if (it)\n     {\n         auto & values = it->getMapped();\n \n-        const auto insert_it\n-            = std::lower_bound(std::begin(values), std::end(values), range, [](const Value<ValueType> & lhs, const Range & rhs_range)\n-              {\n-                  return lhs.range < rhs_range;\n-              });\n+        const auto insert_it = std::lower_bound(\n+            std::begin(values),\n+            std::end(values),\n+            range,\n+            [](const Value<ValueType> & lhs, const Range & rhs_range)\n+            {\n+                return lhs.range < rhs_range;\n+            });\n \n         values.insert(insert_it, std::move(value_to_insert));\n     }\n     else\n-        map.insert({id, Values<ValueType>{std::move(value_to_insert)}});\n+    {\n+        collection.insert({key, Values<ValueType>{std::move(value_to_insert)}});\n+    }\n }\n \n-void RangeHashedDictionary::setAttributeValue(Attribute & attribute, const UInt64 id, const Range & range, const Field & value)\n+template <DictionaryKeyType dictionary_key_type>\n+void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, KeyType key, const Range & range, const Field & value)\n {\n     auto type_call = [&](const auto &dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n \n-        setAttributeValueImpl<AttributeType>(attribute, id, range, value);\n+        setAttributeValueImpl<AttributeType>(attribute, key, range, value);\n     };\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n }\n \n-const RangeHashedDictionary::Attribute & RangeHashedDictionary::getAttribute(const std::string & attribute_name) const\n-{\n-    const auto it = attribute_index_by_name.find(attribute_name);\n-    if (it == std::end(attribute_index_by_name))\n-        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{}: no such attribute '{}'\", full_name, attribute_name);\n-\n-    return attributes[it->second];\n-}\n-\n-const RangeHashedDictionary::Attribute &\n-RangeHashedDictionary::getAttributeWithType(const std::string & attribute_name, const AttributeUnderlyingType type) const\n-{\n-    const auto & attribute = getAttribute(attribute_name);\n-    if (attribute.type != type)\n-        throw Exception(ErrorCodes::TYPE_MISMATCH, \"attribute {} has type {}\",\n-            attribute_name,\n-            toString(attribute.type));\n-\n-    return attribute;\n-}\n-\n+template <DictionaryKeyType dictionary_key_type>\n template <typename RangeType>\n-void RangeHashedDictionary::getIdsAndDates(\n-    PaddedPODArray<UInt64> & ids,\n+void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(\n+    PaddedPODArray<KeyType> & keys,\n     PaddedPODArray<RangeType> & start_dates,\n     PaddedPODArray<RangeType> & end_dates) const\n {\n@@ -556,32 +561,33 @@ void RangeHashedDictionary::getIdsAndDates(\n         using AttributeType = typename Type::AttributeType;\n         using ValueType = DictionaryValueType<AttributeType>;\n \n-        getIdsAndDates<ValueType>(attribute, ids, start_dates, end_dates);\n+        getKeysAndDates<ValueType>(attribute, keys, start_dates, end_dates);\n     };\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n template <typename T, typename RangeType>\n-void RangeHashedDictionary::getIdsAndDates(\n+void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(\n     const Attribute & attribute,\n-    PaddedPODArray<UInt64> & ids,\n+    PaddedPODArray<KeyType> & keys,\n     PaddedPODArray<RangeType> & start_dates,\n     PaddedPODArray<RangeType> & end_dates) const\n {\n-    const HashMap<UInt64, Values<T>> & attr = *std::get<Ptr<T>>(attribute.maps);\n+    const auto & collection = std::get<CollectionType<T>>(attribute.maps);\n \n-    ids.reserve(attr.size());\n-    start_dates.reserve(attr.size());\n-    end_dates.reserve(attr.size());\n+    keys.reserve(collection.size());\n+    start_dates.reserve(collection.size());\n+    end_dates.reserve(collection.size());\n \n     const bool is_date = isDate(dict_struct.range_min->type);\n \n-    for (const auto & key : attr)\n+    for (const auto & key : collection)\n     {\n         for (const auto & value : key.getMapped())\n         {\n-            ids.push_back(key.getKey());\n+            keys.push_back(key.getKey());\n             start_dates.push_back(value.range.left);\n             end_dates.push_back(value.range.right);\n \n@@ -592,33 +598,44 @@ void RangeHashedDictionary::getIdsAndDates(\n     }\n }\n \n-\n+template <DictionaryKeyType dictionary_key_type>\n template <typename RangeType>\n-Pipe RangeHashedDictionary::readImpl(const Names & column_names, size_t max_block_size) const\n+Pipe RangeHashedDictionary<dictionary_key_type>::readImpl(const Names & column_names, size_t max_block_size) const\n {\n-    PaddedPODArray<UInt64> ids;\n+    PaddedPODArray<KeyType> keys;\n     PaddedPODArray<RangeType> start_dates;\n     PaddedPODArray<RangeType> end_dates;\n-    getIdsAndDates(ids, start_dates, end_dates);\n+    getKeysAndDates(keys, start_dates, end_dates);\n \n-    using RangeDictionarySourceType = RangeDictionarySource<RangeType>;\n+    static constexpr RangeDictionaryType range_dictionary_type = (dictionary_key_type == DictionaryKeyType::simple) ? RangeDictionaryType::simple : RangeDictionaryType::complex;\n+    using RangeDictionarySourceType = RangeDictionarySource<range_dictionary_type, RangeType>;\n \n-    auto source = std::make_shared<RangeDictionarySourceType>(\n-        RangeDictionarySourceData<RangeType>(\n-            shared_from_this(),\n-            column_names,\n-            std::move(ids),\n-            std::move(start_dates),\n-            std::move(end_dates)),\n-        max_block_size);\n+    auto source_data = RangeDictionarySourceData<range_dictionary_type, RangeType>(\n+        shared_from_this(),\n+        column_names,\n+        std::move(keys),\n+        std::move(start_dates),\n+        std::move(end_dates));\n+    auto source = std::make_shared<RangeDictionarySourceType>(std::move(source_data), max_block_size);\n \n     return Pipe(source);\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+StringRef RangeHashedDictionary<dictionary_key_type>::copyKeyInArena(StringRef key)\n+{\n+    size_t key_size = key.size;\n+    char * place_for_key = complex_key_arena.alloc(key_size);\n+    memcpy(reinterpret_cast<void *>(place_for_key), reinterpret_cast<const void *>(key.data), key_size);\n+    StringRef updated_key{place_for_key, key_size};\n+    return updated_key;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n struct RangeHashedDictionaryCallGetSourceImpl\n {\n     Pipe pipe;\n-    const RangeHashedDictionary * dict;\n+    const RangeHashedDictionary<dictionary_key_type> * dict;\n     const Names * column_names;\n     size_t max_block_size;\n \n@@ -627,15 +644,16 @@ struct RangeHashedDictionaryCallGetSourceImpl\n     {\n         const auto & type = dict->dict_struct.range_min->type;\n         if (pipe.empty() && dynamic_cast<const DataTypeNumberBase<RangeType> *>(type.get()))\n-            pipe = dict->readImpl<RangeType>(*column_names, max_block_size);\n+            pipe = dict->template readImpl<RangeType>(*column_names, max_block_size);\n     }\n };\n \n-Pipe RangeHashedDictionary::read(const Names & column_names, size_t max_block_size) const\n+template <DictionaryKeyType dictionary_key_type>\n+Pipe RangeHashedDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size) const\n {\n     using ListType = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Int128, Float32, Float64>;\n \n-    RangeHashedDictionaryCallGetSourceImpl callable;\n+    RangeHashedDictionaryCallGetSourceImpl<dictionary_key_type> callable;\n     callable.dict = this;\n     callable.column_names = &column_names;\n     callable.max_block_size = max_block_size;\n@@ -653,7 +671,7 @@ Pipe RangeHashedDictionary::read(const Names & column_names, size_t max_block_si\n \n void registerDictionaryRangeHashed(DictionaryFactory & factory)\n {\n-    auto create_layout = [=](const std::string & full_name,\n+    auto create_layout_simple = [=](const std::string & full_name,\n                              const DictionaryStructure & dict_struct,\n                              const Poco::Util::AbstractConfiguration & config,\n                              const std::string & config_prefix,\n@@ -672,9 +690,32 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)\n         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<RangeHashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::simple>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+    };\n+    factory.registerLayout(\"range_hashed\", create_layout_simple, false);\n+\n+    auto create_layout_complex = [=](const std::string & full_name,\n+                             const DictionaryStructure & dict_struct,\n+                             const Poco::Util::AbstractConfiguration & config,\n+                             const std::string & config_prefix,\n+                             DictionarySourcePtr source_ptr,\n+                             ContextPtr /* context */,\n+                             bool /*created_from_ddl*/) -> DictionaryPtr\n+    {\n+        if (dict_struct.id)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'id' is not supported for dictionary of layout 'complex_key_range_hashed'\");\n+\n+        if (!dict_struct.range_min || !dict_struct.range_max)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"{}: dictionary of layout 'complex_key_range_hashed' requires .structure.range_min and .structure.range_max\",\n+                full_name);\n+\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+        const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n+        const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n+        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::complex>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n     };\n-    factory.registerLayout(\"range_hashed\", create_layout, false);\n+    factory.registerLayout(\"complex_key_range_hashed\", create_layout_complex, true);\n }\n \n }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 13fa6ad570fc..f9b091892651 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -16,9 +16,25 @@\n \n namespace DB\n {\n+\n+using RangeStorageType = Int64;\n+\n+struct Range\n+{\n+    RangeStorageType left;\n+    RangeStorageType right;\n+\n+    static bool isCorrectDate(const RangeStorageType & date);\n+    bool contains(const RangeStorageType & value) const;\n+};\n+\n+template <DictionaryKeyType dictionary_key_type>\n class RangeHashedDictionary final : public IDictionary\n {\n public:\n+    using KeyType = std::conditional_t<dictionary_key_type == DictionaryKeyType::simple, UInt64, StringRef>;\n+    static_assert(dictionary_key_type != DictionaryKeyType::range, \"Range key type is not supported by hashed dictionary\");\n+\n     RangeHashedDictionary(\n         const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n@@ -59,7 +75,7 @@ class RangeHashedDictionary final : public IDictionary\n \n     bool isInjective(const std::string & attribute_name) const override\n     {\n-        return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n+        return dict_struct.getAttribute(attribute_name).injective;\n     }\n \n     DictionaryKeyType getKeyType() const override { return DictionaryKeyType::range; }\n@@ -73,19 +89,8 @@ class RangeHashedDictionary final : public IDictionary\n \n     ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n \n-    using RangeStorageType = Int64;\n-\n     Pipe read(const Names & column_names, size_t max_block_size) const override;\n \n-    struct Range\n-    {\n-        RangeStorageType left;\n-        RangeStorageType right;\n-\n-        static bool isCorrectDate(const RangeStorageType & date);\n-        bool contains(const RangeStorageType & value) const;\n-    };\n-\n private:\n     template <typename T>\n     struct Value final\n@@ -96,10 +101,12 @@ class RangeHashedDictionary final : public IDictionary\n \n     template <typename T>\n     using Values = std::vector<Value<T>>;\n-    template <typename T>\n-    using Collection = HashMap<UInt64, Values<T>>;\n-    template <typename T>\n-    using Ptr = std::unique_ptr<Collection<T>>;\n+\n+    template <typename Value>\n+    using CollectionType = std::conditional_t<\n+        dictionary_key_type == DictionaryKeyType::simple,\n+        HashMap<UInt64, Values<Value>>,\n+        HashMapWithSavedHash<StringRef, Values<Value>, DefaultHash<StringRef>>>;\n \n     struct Attribute final\n     {\n@@ -108,27 +115,27 @@ class RangeHashedDictionary final : public IDictionary\n         bool is_nullable;\n \n         std::variant<\n-            Ptr<UInt8>,\n-            Ptr<UInt16>,\n-            Ptr<UInt32>,\n-            Ptr<UInt64>,\n-            Ptr<UInt128>,\n-            Ptr<UInt256>,\n-            Ptr<Int8>,\n-            Ptr<Int16>,\n-            Ptr<Int32>,\n-            Ptr<Int64>,\n-            Ptr<Int128>,\n-            Ptr<Int256>,\n-            Ptr<Decimal32>,\n-            Ptr<Decimal64>,\n-            Ptr<Decimal128>,\n-            Ptr<Decimal256>,\n-            Ptr<Float32>,\n-            Ptr<Float64>,\n-            Ptr<UUID>,\n-            Ptr<StringRef>,\n-            Ptr<Array>>\n+            CollectionType<UInt8>,\n+            CollectionType<UInt16>,\n+            CollectionType<UInt32>,\n+            CollectionType<UInt64>,\n+            CollectionType<UInt128>,\n+            CollectionType<UInt256>,\n+            CollectionType<Int8>,\n+            CollectionType<Int16>,\n+            CollectionType<Int32>,\n+            CollectionType<Int64>,\n+            CollectionType<Int128>,\n+            CollectionType<Int256>,\n+            CollectionType<Decimal32>,\n+            CollectionType<Decimal64>,\n+            CollectionType<Decimal128>,\n+            CollectionType<Decimal256>,\n+            CollectionType<Float32>,\n+            CollectionType<Float64>,\n+            CollectionType<UUID>,\n+            CollectionType<StringRef>,\n+            CollectionType<Array>>\n             maps;\n         std::unique_ptr<Arena> string_arena;\n     };\n@@ -137,9 +144,6 @@ class RangeHashedDictionary final : public IDictionary\n \n     void loadData();\n \n-    template <typename T>\n-    void addAttributeSize(const Attribute & attribute);\n-\n     void calculateBytesAllocated();\n \n     static Attribute createAttribute(const DictionaryAttribute & dictionary_attribute);\n@@ -151,35 +155,30 @@ class RangeHashedDictionary final : public IDictionary\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    template <typename AttributeType>\n-    ColumnUInt8::Ptr hasKeysImpl(\n-        const Attribute & attribute,\n-        const PaddedPODArray<UInt64> & ids,\n-        const PaddedPODArray<RangeStorageType> & dates,\n-        size_t & keys_found) const;\n-\n     template <typename T>\n-    static void setAttributeValueImpl(Attribute & attribute, const UInt64 id, const Range & range, const Field & value);\n-\n-    static void setAttributeValue(Attribute & attribute, const UInt64 id, const Range & range, const Field & value);\n-\n-    const Attribute & getAttribute(const std::string & attribute_name) const;\n+    static void setAttributeValueImpl(Attribute & attribute, KeyType key, const Range & range, const Field & value);\n \n-    const Attribute & getAttributeWithType(const std::string & name, const AttributeUnderlyingType type) const;\n+    static void setAttributeValue(Attribute & attribute, KeyType key, const Range & range, const Field & value);\n \n     template <typename RangeType>\n-    void getIdsAndDates(PaddedPODArray<UInt64> & ids, PaddedPODArray<RangeType> & start_dates, PaddedPODArray<RangeType> & end_dates) const;\n+    void getKeysAndDates(\n+        PaddedPODArray<KeyType> & keys,\n+        PaddedPODArray<RangeType> & start_dates,\n+        PaddedPODArray<RangeType> & end_dates) const;\n \n     template <typename T, typename RangeType>\n-    void getIdsAndDates(\n+    void getKeysAndDates(\n         const Attribute & attribute,\n-        PaddedPODArray<UInt64> & ids,\n+        PaddedPODArray<KeyType> & keys,\n         PaddedPODArray<RangeType> & start_dates,\n         PaddedPODArray<RangeType> & end_dates) const;\n \n     template <typename RangeType>\n     Pipe readImpl(const Names & column_names, size_t max_block_size) const;\n \n+    StringRef copyKeyInArena(StringRef key);\n+\n+    template <DictionaryKeyType>\n     friend struct RangeHashedDictionaryCallGetSourceImpl;\n \n     const DictionaryStructure dict_struct;\n@@ -189,6 +188,7 @@ class RangeHashedDictionary final : public IDictionary\n \n     std::map<std::string, size_t> attribute_index_by_name;\n     std::vector<Attribute> attributes;\n+    Arena complex_key_arena;\n \n     size_t bytes_allocated = 0;\n     size_t element_count = 0;\ndiff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.h b/src/Dictionaries/getDictionaryConfigurationFromAST.h\nindex de8659e4d7b7..b464fdf1d8c1 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.h\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.h\n@@ -6,6 +6,7 @@\n \n namespace DB\n {\n+\n using DictionaryConfigurationPtr = Poco::AutoPtr<Poco::Util::AbstractConfiguration>;\n \n /// Convert dictionary AST to Poco::AbstractConfiguration\n@@ -13,4 +14,5 @@ using DictionaryConfigurationPtr = Poco::AutoPtr<Poco::Util::AbstractConfigurati\n /// Can throw exception if query is ill-formed\n DictionaryConfigurationPtr\n getDictionaryConfigurationFromAST(const ASTCreateQuery & query, ContextPtr context, const std::string & database_ = \"\");\n+\n }\ndiff --git a/src/Dictionaries/ya.make b/src/Dictionaries/ya.make\nindex 3f287f8bddcb..6498367bb6ac 100644\n--- a/src/Dictionaries/ya.make\n+++ b/src/Dictionaries/ya.make\n@@ -27,6 +27,7 @@ SRCS(\n     CassandraSource.cpp\n     ClickHouseDictionarySource.cpp\n     DictionaryFactory.cpp\n+    DictionaryHelpers.cpp\n     DictionarySource.cpp\n     DictionarySourceBase.cpp\n     DictionarySourceFactory.cpp\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 118855b4bf8e..febb14a7723c 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -250,12 +250,23 @@ class FunctionDictHas final : public IFunction\n         }\n         else\n         {\n-            if (!WhichDataType(key_column_type).isUInt64())\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Second argument of function {} must be UInt64 when dictionary is range. Actual type {}.\",\n-                    getName(),\n-                    key_column_with_type.type->getName());\n+            /// Functions in external dictionaries_loader only support full-value (not constant) columns with keys.\n+            ColumnPtr key_column = key_column_with_type.column->convertToFullColumnIfConst();\n+            DataTypePtr key_column_type = key_column_with_type.type;\n+\n+            Columns key_columns;\n+            DataTypes key_types;\n+\n+            if (isTuple(key_column_type))\n+            {\n+                key_columns = assert_cast<const ColumnTuple &>(*key_column).getColumnsCopy();\n+                key_types = assert_cast<const DataTypeTuple &>(*key_column_type).getElements();\n+            }\n+            else\n+            {\n+                key_columns = {key_column, range_col};\n+                key_types = {std::make_shared<DataTypeUInt64>(), range_col_type};\n+            }\n \n             return dictionary->hasKeys({key_column, range_col}, {std::make_shared<DataTypeUInt64>(), range_col_type});\n         }\n@@ -487,18 +498,32 @@ class FunctionDictGetNoType final : public IFunction\n         }\n         else if (dictionary_key_type == DictionaryKeyType::range)\n         {\n-            if (!WhichDataType(key_col_with_type.type).isUInt64())\n-                 throw Exception(\n-                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                     \"Third argument of function {} must be UInt64 when dictionary is range. Actual type {}.\",\n-                     getName(),\n-                     key_col_with_type.type->getName());\n+            /// Functions in external dictionaries_loader only support full-value (not constant) columns with keys.\n+            ColumnPtr key_column = key_col_with_type.column->convertToFullColumnIfConst();\n+            DataTypePtr key_column_type = key_col_with_type.type;\n+\n+            Columns key_columns;\n+            DataTypes key_types;\n+\n+            if (isTuple(key_column_type))\n+            {\n+                key_columns = assert_cast<const ColumnTuple &>(*key_column).getColumnsCopy();\n+                key_types = assert_cast<const DataTypeTuple &>(*key_column_type).getElements();\n+            }\n+            else\n+            {\n+                key_columns = {key_column};\n+                key_types = {std::make_shared<DataTypeUInt64>()};\n+            }\n+\n+            key_columns.emplace_back(range_col);\n+            key_types.emplace_back(range_col_type);\n \n             result = executeDictionaryRequest(\n                 dictionary,\n                 attribute_names,\n-                {key_column, range_col},\n-                {std::make_shared<DataTypeUInt64>(), range_col_type},\n+                key_columns,\n+                key_types,\n                 result_type,\n                 default_cols);\n         }\ndiff --git a/src/Functions/ya.make b/src/Functions/ya.make\nindex b231866b4fd0..5721505b398b 100644\n--- a/src/Functions/ya.make\n+++ b/src/Functions/ya.make\n@@ -39,6 +39,8 @@ PEERDIR(\n \n SRCS(\n     CRC.cpp\n+    CastOverloadResolver.cpp\n+    DateOrDateTimeFunctionsConvertion.cpp\n     FunctionChar.cpp\n     FunctionFQDN.cpp\n     FunctionFactory.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.reference b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.reference\nnew file mode 100644\nindex 000000000000..41a12f889060\n--- /dev/null\n+++ b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.reference\n@@ -0,0 +1,58 @@\n+Dictionary not nullable\n+dictGet\n+0.33\n+0.42\n+0.46\n+0.2\n+0.4\n+dictHas\n+1\n+1\n+1\n+0\n+select columns from dictionary\n+allColumns\n+2019-05-05\t2019-05-20\t1\t1\t0.33\n+2019-05-21\t2019-05-30\t1\t1\t0.42\n+2019-05-21\t2019-05-30\t2\t2\t0.46\n+noColumns\n+1\n+1\n+1\n+onlySpecificColumns\n+1\t2019-05-05\t0.33\n+1\t2019-05-21\t0.42\n+2\t2019-05-21\t0.46\n+onlySpecificColumn\n+0.33\n+0.42\n+0.46\n+Dictionary nullable\n+dictGet\n+0.33\n+0.42\n+\\N\n+0.2\n+0.4\n+dictHas\n+1\n+1\n+1\n+0\n+select columns from dictionary\n+allColumns\n+2019-05-05\t2019-05-20\t1\t1\t0.33\n+2019-05-21\t2019-05-30\t1\t1\t0.42\n+2019-05-21\t2019-05-30\t2\t2\t\\N\n+noColumns\n+1\n+1\n+1\n+onlySpecificColumns\n+1\t2019-05-05\t0.33\n+1\t2019-05-21\t0.42\n+2\t2019-05-21\t\\N\n+onlySpecificColumn\n+0.33\n+0.42\n+\\N\ndiff --git a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql\nnew file mode 100644\nindex 000000000000..ba6ed30b6092\n--- /dev/null\n+++ b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql\n@@ -0,0 +1,109 @@\n+DROP TABLE IF EXISTS date_table;\n+CREATE TABLE date_table\n+(\n+  CountryID UInt64,\n+  CountryKey String,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Float64\n+)\n+ENGINE = MergeTree()\n+ORDER BY CountryID;\n+\n+INSERT INTO date_table VALUES(1, '1', toDate('2019-05-05'), toDate('2019-05-20'), 0.33);\n+INSERT INTO date_table VALUES(1, '1', toDate('2019-05-21'), toDate('2019-05-30'), 0.42);\n+INSERT INTO date_table VALUES(2, '2', toDate('2019-05-21'), toDate('2019-05-30'), 0.46);\n+\n+DROP DICTIONARY IF EXISTS range_dictionary;\n+CREATE DICTIONARY range_dictionary\n+(\n+  CountryID UInt64,\n+  CountryKey String,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Float64 DEFAULT 0.2\n+)\n+PRIMARY KEY CountryID, CountryKey\n+SOURCE(CLICKHOUSE(TABLE 'date_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_RANGE_HASHED())\n+RANGE(MIN StartDate MAX EndDate);\n+\n+SELECT 'Dictionary not nullable';\n+SELECT 'dictGet';\n+SELECT dictGet('range_dictionary', 'Tax', (toUInt64(1), '1'), toDate('2019-05-15'));\n+SELECT dictGet('range_dictionary', 'Tax', (toUInt64(1), '1'), toDate('2019-05-29'));\n+SELECT dictGet('range_dictionary', 'Tax', (toUInt64(2), '2'), toDate('2019-05-29'));\n+SELECT dictGet('range_dictionary', 'Tax', (toUInt64(2), '2'), toDate('2019-05-31'));\n+SELECT dictGetOrDefault('range_dictionary', 'Tax', (toUInt64(2), '2'), toDate('2019-05-31'), 0.4);\n+SELECT 'dictHas';\n+SELECT dictHas('range_dictionary', (toUInt64(1), '1'), toDate('2019-05-15'));\n+SELECT dictHas('range_dictionary', (toUInt64(1), '1'), toDate('2019-05-29'));\n+SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-29'));\n+SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-31'));\n+SELECT 'select columns from dictionary';\n+SELECT 'allColumns';\n+SELECT * FROM range_dictionary;\n+SELECT 'noColumns';\n+SELECT 1 FROM range_dictionary;\n+SELECT 'onlySpecificColumns';\n+SELECT CountryID, StartDate, Tax FROM range_dictionary;\n+SELECT 'onlySpecificColumn';\n+SELECT Tax FROM range_dictionary;\n+\n+DROP TABLE date_table;\n+DROP DICTIONARY range_dictionary;\n+\n+CREATE TABLE date_table\n+(\n+  CountryID UInt64,\n+  CountryKey String,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Nullable(Float64)\n+)\n+ENGINE = MergeTree()\n+ORDER BY CountryID;\n+\n+INSERT INTO date_table VALUES(1, '1', toDate('2019-05-05'), toDate('2019-05-20'), 0.33);\n+INSERT INTO date_table VALUES(1, '1', toDate('2019-05-21'), toDate('2019-05-30'), 0.42);\n+INSERT INTO date_table VALUES(2, '2', toDate('2019-05-21'), toDate('2019-05-30'), NULL);\n+\n+CREATE DICTIONARY range_dictionary_nullable\n+(\n+  CountryID UInt64,\n+  CountryKey String,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Nullable(Float64) DEFAULT 0.2\n+)\n+PRIMARY KEY CountryID, CountryKey\n+SOURCE(CLICKHOUSE(TABLE 'date_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_RANGE_HASHED())\n+RANGE(MIN StartDate MAX EndDate);\n+\n+SELECT 'Dictionary nullable';\n+SELECT 'dictGet';\n+SELECT dictGet('range_dictionary_nullable', 'Tax', (toUInt64(1), '1'), toDate('2019-05-15'));\n+SELECT dictGet('range_dictionary_nullable', 'Tax', (toUInt64(1), '1'), toDate('2019-05-29'));\n+SELECT dictGet('range_dictionary_nullable', 'Tax', (toUInt64(2), '2'), toDate('2019-05-29'));\n+SELECT dictGet('range_dictionary_nullable', 'Tax', (toUInt64(2), '2'), toDate('2019-05-31'));\n+SELECT dictGetOrDefault('range_dictionary_nullable', 'Tax', (toUInt64(2), '2'), toDate('2019-05-31'), 0.4);\n+SELECT 'dictHas';\n+SELECT dictHas('range_dictionary_nullable', (toUInt64(1), '1'), toDate('2019-05-15'));\n+SELECT dictHas('range_dictionary_nullable', (toUInt64(1), '1'), toDate('2019-05-29'));\n+SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-29'));\n+SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-31'));\n+SELECT 'select columns from dictionary';\n+SELECT 'allColumns';\n+SELECT * FROM range_dictionary_nullable;\n+SELECT 'noColumns';\n+SELECT 1 FROM range_dictionary_nullable;\n+SELECT 'onlySpecificColumns';\n+SELECT CountryID, StartDate, Tax FROM range_dictionary_nullable;\n+SELECT 'onlySpecificColumn';\n+SELECT Tax FROM range_dictionary_nullable;\n+\n+DROP TABLE date_table;\n+DROP DICTIONARY range_dictionary_nullable;\n",
  "problem_statement": "ComplexKey support for RangeHashedDictionary\nAdd support for complex key into range hashed dictionary.\n",
  "hints_text": "Need at least for Distribution Interface in Yandex",
  "created_at": "2021-08-12T21:40:18Z",
  "modified_files": [
    "b/src/Dictionaries/DictionaryHelpers.cpp",
    "src/Dictionaries/DictionaryHelpers.h",
    "src/Dictionaries/DictionarySource.cpp",
    "src/Dictionaries/DictionarySource.h",
    "src/Dictionaries/DictionaryStructure.cpp",
    "src/Dictionaries/DictionaryStructure.h",
    "src/Dictionaries/ExternalQueryBuilder.cpp",
    "src/Dictionaries/IPAddressDictionary.h",
    "src/Dictionaries/RangeDictionarySource.h",
    "src/Dictionaries/RangeHashedDictionary.cpp",
    "src/Dictionaries/RangeHashedDictionary.h",
    "src/Dictionaries/getDictionaryConfigurationFromAST.h",
    "src/Dictionaries/ya.make",
    "src/Functions/FunctionsExternalDictionaries.h",
    "src/Functions/ya.make"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.reference",
    "b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql"
  ]
}