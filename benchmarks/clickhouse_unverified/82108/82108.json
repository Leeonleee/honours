{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 82108,
  "instance_id": "ClickHouse__ClickHouse-82108",
  "issue_numbers": [
    "9887"
  ],
  "base_commit": "b28c690c4dc27e7bf25f3a94b4305cc7c30617cc",
  "patch": "diff --git a/docs/en/sql-reference/window-functions/index.md b/docs/en/sql-reference/window-functions/index.md\nindex 5f9ddbd813d5..661b8f0b5770 100644\n--- a/docs/en/sql-reference/window-functions/index.md\n+++ b/docs/en/sql-reference/window-functions/index.md\n@@ -27,7 +27,7 @@ ClickHouse supports the standard grammar for defining windows and window functio\n | Calculating aggregate functions over a frame (`sum(value) over (order by time)`)   | \u2705 (All aggregate functions are supported)                                                                                                                                                       |\n | `rank()`, `dense_rank()`, `row_number()`                                           | \u2705 <br/>Alias: `denseRank()`                                                                                                                                                                                   |\n | `percent_rank()` | \u2705  Efficiently computes the relative standing of a value within a partition in a dataset. This function effectively replaces the more verbose and computationally intensive manual SQL calculation expressed as `ifNull((rank() OVER(PARTITION BY x ORDER BY y) - 1) / nullif(count(1) OVER(PARTITION BY x) - 1, 0), 0)` <br/>Alias: `percentRank()`| \n-| `lag/lead(value, offset)`                                                          | \u274c <br/> You can use one of the following workarounds:<br/> 1) `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead` <br/> 2) `lagInFrame/leadInFrame`, which are analogous, but respect the window frame. To get behavior identical to `lag/lead`, use `rows between unbounded preceding and unbounded following`                                                                 |\n+| `lag/lead(value, offset)`                                                          | \u2705 <br/> You can also use one of the following workarounds:<br/> 1) `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead` <br/> 2) `lagInFrame/leadInFrame`, which are analogous, but respect the window frame. To get behavior identical to `lag/lead`, use `rows between unbounded preceding and unbounded following`                                                                 |\n | ntile(buckets) | \u2705 <br/> Specify window like, (partition by x order by y rows between unbounded preceding and unbounded following). |\n \n ## ClickHouse-specific Window Functions {#clickhouse-specific-window-functions}\ndiff --git a/docs/en/sql-reference/window-functions/lag.md b/docs/en/sql-reference/window-functions/lag.md\nnew file mode 100644\nindex 000000000000..8849d91b8134\n--- /dev/null\n+++ b/docs/en/sql-reference/window-functions/lag.md\n@@ -0,0 +1,78 @@\n+---\n+description: 'Documentation for the lag window function'\n+sidebar_label: 'lag'\n+sidebar_position: 9\n+slug: /sql-reference/window-functions/lag\n+title: 'lag'\n+---\n+\n+# lag\n+\n+Returns a value evaluated at the row that is at a specified physical offset before the current row within the ordered frame.\n+This function is similar to [`lagInFrame`](./lagInFrame.md), but always uses the `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` frame.\n+\n+**Syntax**\n+\n+```sql\n+lag(x[, offset[, default]])\n+  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]] | [window_name])\n+FROM table_name\n+WINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])\n+```\n+\n+For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).\n+\n+**Parameters**\n+\n+- `x` \u2014 Column name.\n+- `offset` \u2014 Offset to apply. [(U)Int*](../data-types/int-uint.md). (Optional - `1` by default).\n+- `default` \u2014 Value to return if calculated row exceeds the boundaries of the window frame. (Optional - default value of column type when omitted).\n+\n+**Returned value**\n+\n+- Value evaluated at the row that is at a specified physical offset before the current row within the ordered frame.\n+\n+**Example**\n+\n+This example looks at historical data for a specific stock and uses the `lag` function to calculate a day-to-day delta and percentage change in the closing price of the stock.\n+\n+```sql title=\"Query\"\n+CREATE TABLE stock_prices\n+(\n+    `date`   Date,\n+    `open`   Float32, -- opening price\n+    `high`   Float32, -- daily high\n+    `low`    Float32, -- daily low\n+    `close`  Float32, -- closing price\n+    `volume` UInt32   -- trade volume\n+)\n+Engine = Memory;\n+\n+INSERT INTO stock_prices FORMAT Values\n+    ('2024-06-03', 113.62, 115.00, 112.00, 115.00, 438392000),\n+    ('2024-06-04', 115.72, 116.60, 114.04, 116.44, 403324000),\n+    ('2024-06-05', 118.37, 122.45, 117.47, 122.44, 528402000),\n+    ('2024-06-06', 124.05, 125.59, 118.32, 121.00, 664696000),\n+    ('2024-06-07', 119.77, 121.69, 118.02, 120.89, 412386000);\n+```\n+\n+```sql title=\"Query\"\n+SELECT\n+    date,\n+    close,\n+    lag(close, 1, close) OVER (ORDER BY date ASC) AS previous_day_close,\n+    COALESCE(ROUND(close - previous_day_close, 2)) AS delta,\n+    COALESCE(ROUND((delta / previous_day_close) * 100, 2)) AS percent_change\n+FROM stock_prices\n+ORDER BY date DESC\n+```\n+\n+```response title=\"Response\"\n+   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500\u2500close\u2500\u252c\u2500previous_day_close\u2500\u252c\u2500delta\u2500\u252c\u2500percent_change\u2500\u2510\n+1. \u2502 2024-06-07 \u2502 120.89 \u2502                121 \u2502 -0.11 \u2502          -0.09 \u2502\n+2. \u2502 2024-06-06 \u2502    121 \u2502             122.44 \u2502 -1.44 \u2502          -1.18 \u2502\n+3. \u2502 2024-06-05 \u2502 122.44 \u2502             116.44 \u2502     6 \u2502           5.15 \u2502\n+4. \u2502 2024-06-04 \u2502 116.44 \u2502                115 \u2502  1.44 \u2502           1.25 \u2502\n+5. \u2502 2024-06-03 \u2502    115 \u2502                115 \u2502     0 \u2502              0 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/docs/en/sql-reference/window-functions/lead.md b/docs/en/sql-reference/window-functions/lead.md\nnew file mode 100644\nindex 000000000000..883f31de968f\n--- /dev/null\n+++ b/docs/en/sql-reference/window-functions/lead.md\n@@ -0,0 +1,71 @@\n+---\n+description: 'Documentation for the lead window function'\n+sidebar_label: 'lead'\n+sidebar_position: 10\n+slug: /sql-reference/window-functions/lead\n+title: 'lead'\n+---\n+\n+# lead\n+\n+Returns a value evaluated at the row that is offset rows after the current row within the ordered frame.\n+This function is similar to [`leadInFrame`](./leadInFrame.md), but always uses the `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` frame.\n+\n+**Syntax**\n+\n+```sql\n+lead(x[, offset[, default]])\n+  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]] | [window_name])\n+FROM table_name\n+WINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])\n+```\n+\n+For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).\n+\n+**Parameters**\n+\n+- `x` \u2014 Column name.\n+- `offset` \u2014 Offset to apply. [(U)Int*](../data-types/int-uint.md). (Optional - `1` by default).\n+- `default` \u2014 Value to return if calculated row exceeds the boundaries of the window frame. (Optional - default value of column type when omitted).\n+\n+**Returned value**\n+\n+- value evaluated at the row that is offset rows after the current row within the ordered frame.\n+\n+**Example**\n+\n+This example looks at [historical data](https://www.kaggle.com/datasets/sazidthe1/nobel-prize-data) for Nobel Prize winners and uses the `lead` function to return a list of successive winners in the physics category.\n+\n+```sql title=\"Query\"\n+CREATE OR REPLACE VIEW nobel_prize_laureates\n+AS SELECT *\n+FROM file('nobel_laureates_data.csv');\n+```\n+\n+```sql title=\"Query\"\n+SELECT\n+    fullName,\n+    lead(year, 1, year) OVER (PARTITION BY category ORDER BY year ASC\n+      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n+    ) AS year,\n+    category,\n+    motivation\n+FROM nobel_prize_laureates\n+WHERE category = 'physics'\n+ORDER BY year DESC\n+LIMIT 9\n+```\n+\n+```response title=\"Query\"\n+   \u250c\u2500fullName\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500year\u2500\u252c\u2500category\u2500\u252c\u2500motivation\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 Anne L Huillier  \u2502 2023 \u2502 physics  \u2502 for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     \u2502\n+2. \u2502 Pierre Agostini  \u2502 2023 \u2502 physics  \u2502 for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     \u2502\n+3. \u2502 Ferenc Krausz    \u2502 2023 \u2502 physics  \u2502 for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     \u2502\n+4. \u2502 Alain Aspect     \u2502 2022 \u2502 physics  \u2502 for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science \u2502\n+5. \u2502 Anton Zeilinger  \u2502 2022 \u2502 physics  \u2502 for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science \u2502\n+6. \u2502 John Clauser     \u2502 2022 \u2502 physics  \u2502 for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science \u2502\n+7. \u2502 Giorgio Parisi   \u2502 2021 \u2502 physics  \u2502 for the discovery of the interplay of disorder and fluctuations in physical systems from atomic to planetary scales                \u2502\n+8. \u2502 Klaus Hasselmann \u2502 2021 \u2502 physics  \u2502 for the physical modelling of Earths climate quantifying variability and reliably predicting global warming                        \u2502\n+9. \u2502 Syukuro Manabe   \u2502 2021 \u2502 physics  \u2502 for the physical modelling of Earths climate quantifying variability and reliably predicting global warming                        \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex bb3597d7a8a1..2081004f96d2 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -3358,6 +3358,27 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n         bool window_node_is_identifier = function_node.getWindowNode()->getNodeType() == QueryTreeNodeType::IDENTIFIER;\n         ProjectionName window_projection_name = resolveWindow(function_node.getWindowNode(), scope);\n \n+        if (function_name == \"lag\" || function_name == \"lead\")\n+        {\n+            auto & frame = function_node.getWindowNode()->as<WindowNode>()->getWindowFrame();\n+            if (!frame.is_default)\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Window function '{}' does not expect window frame to be explicitly specified. In expression {}\",\n+                    function_name,\n+                    function_node.formatASTForErrorMessage());\n+            }\n+\n+            frame = WindowFrame{\n+                .is_default = false,\n+                .type = WindowFrame::FrameType::ROWS,\n+                .begin_type = WindowFrame::BoundaryType::Unbounded,\n+                .begin_preceding = true,\n+                .end_type = WindowFrame::BoundaryType::Unbounded,\n+                .end_preceding = false,\n+            };\n+        }\n+\n         if (window_node_is_identifier)\n             result_projection_names[0] += \" OVER \" + window_projection_name;\n         else\ndiff --git a/src/Interpreters/GetAggregatesVisitor.h b/src/Interpreters/GetAggregatesVisitor.h\nindex e1d22e4de821..46eb2a9d1303 100644\n--- a/src/Interpreters/GetAggregatesVisitor.h\n+++ b/src/Interpreters/GetAggregatesVisitor.h\n@@ -12,6 +12,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_AGGREGATION;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n class GetAggregatesMatcher\n@@ -80,6 +81,13 @@ class GetAggregatesMatcher\n                 throw Exception(ErrorCodes::ILLEGAL_AGGREGATION, \"Window function {} is found {} in query\",\n                                 node.getColumnName(), String(data.assert_no_windows));\n \n+            if (node.name == \"lag\" || node.name == \"lead\")\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                    \"Window function '{}' is supported only with enabled analyzer\",\n+                    node.formatForErrorMessage());\n+            }\n+\n             String column_name = node.getColumnName();\n             if (data.uniq_names.contains(column_name))\n                 return;\ndiff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp\nindex 98c21a341fdb..522f20feb7e3 100644\n--- a/src/Processors/Transforms/WindowTransform.cpp\n+++ b/src/Processors/Transforms/WindowTransform.cpp\n@@ -2702,6 +2702,13 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)\n                 name, argument_types, parameters);\n         }, properties});\n \n+    factory.registerFunction(\"lag\", {[](const std::string & name,\n+            const DataTypes & argument_types, const Array & parameters, const Settings *)\n+        {\n+            return std::make_shared<WindowFunctionLagLeadInFrame<false>>(\n+                name, argument_types, parameters);\n+        }, properties});\n+\n     factory.registerFunction(\"leadInFrame\", {[](const std::string & name,\n             const DataTypes & argument_types, const Array & parameters, const Settings *)\n         {\n@@ -2709,6 +2716,13 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)\n                 name, argument_types, parameters);\n         }, properties});\n \n+    factory.registerFunction(\"lead\", {[](const std::string & name,\n+            const DataTypes & argument_types, const Array & parameters, const Settings *)\n+        {\n+            return std::make_shared<WindowFunctionLagLeadInFrame<true>>(\n+                name, argument_types, parameters);\n+        }, properties});\n+\n     factory.registerFunction(\"exponentialTimeDecayedSum\", {[](const std::string & name,\n             const DataTypes & argument_types, const Array & parameters, const Settings *)\n         {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.reference b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.reference\nnew file mode 100644\nindex 000000000000..3584257c2410\n--- /dev/null\n+++ b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.reference\n@@ -0,0 +1,13 @@\n+   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   \u2503 number \u2503  lag \u2503 lagASC \u2503 lagDESC \u2503 lead \u2503 leadDESC \u2503 leadASC \u2503\n+   \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n+1. \u2502      0 \u2502 8472 \u2502   8472 \u2502       1 \u2502    1 \u2502     8472 \u2502       1 \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+2. \u2502      1 \u2502    0 \u2502      0 \u2502       2 \u2502    2 \u2502        0 \u2502       2 \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+3. \u2502      2 \u2502    1 \u2502      1 \u2502       3 \u2502    3 \u2502        1 \u2502       3 \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+4. \u2502      3 \u2502    2 \u2502      2 \u2502       4 \u2502    4 \u2502        2 \u2502       4 \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+5. \u2502      4 \u2502    3 \u2502      3 \u2502    8472 \u2502 8472 \u2502        3 \u2502    8472 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.sql b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.sql\nnew file mode 100644\nindex 000000000000..ad9117fbe28f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.sql\n@@ -0,0 +1,38 @@\n+set enable_analyzer = 1;\n+\n+SELECT number\n+    ,lag(number, 1, 8472) OVER () lag\n+    ,lag(number, 1, 8472) OVER (ORDER BY number ASC) lagASC\n+    ,lag(number, 1, 8472) OVER (ORDER BY number DESC) lagDESC\n+    ,lead(number, 1, 8472) OVER () lead\n+    ,lead(number, 1, 8472) OVER (ORDER BY number DESC) leadDESC\n+    ,lead(number, 1, 8472) OVER (ORDER BY number ASC) leadASC\n+FROM numbers(5)\n+ORDER BY number\n+FORMAT Pretty;\n+\n+SELECT number\n+    ,lead(number, 1, 8472) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) lead\n+FROM numbers(5)\n+ORDER BY number\n+FORMAT Pretty; -- { serverError BAD_ARGUMENTS }\n+\n+SELECT number\n+    ,lag(number, 1, 8472) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) lag\n+FROM numbers(5)\n+ORDER BY number\n+FORMAT Pretty; -- { serverError BAD_ARGUMENTS }\n+\n+set enable_analyzer = 0;\n+\n+SELECT number\n+    ,lead(number, 1, 8472) OVER () lead\n+FROM numbers(5)\n+ORDER BY number\n+FORMAT Pretty; -- { serverError NOT_IMPLEMENTED }\n+\n+SELECT number\n+    ,lag(number, 1, 8472) OVER () lag\n+FROM numbers(5)\n+ORDER BY number\n+FORMAT Pretty; -- { serverError NOT_IMPLEMENTED }\n",
  "problem_statement": "TPC-DS compatibility issues\nTPC-DS check list in 20.3+.\n\nMissing features:\n- [x] INTERSECT / EXCEPT operators not implemented **fixed via #24757 in 21.9**\n- [x] [NOT] EXISTS-operator not implemented #6852 **fixed via #29731 in 21.11**\n- [x] Interval syntax like '+ 30 days' is not supported **fixed via #15978 in 20.11**\n- [x] CTE syntax is different from ANSI SQL 99 **fixed via #14771 in 20.10?**\n- [x] CTE returning multiple rows is not supported #2416 **partially fixed via #14771 in 20.10?**\n- [x] Window  functions are not supported (OVER ... PARTITION BY ... ) #1469\n- [x] Missing analytical functions RANK, FIRST, LAST, LAG **the exact syntax is not supported but can be emulated using existing toolset**\n- [x] [GROUPING SETS](https://docs.microsoft.com/en-us/sql/t-sql/functions/grouping-transact-sql?view=sql-server-ver15)  #33631 **22.5**\n- [x] GROUPING specification for ROLLUP, CUBE and GROUPING SETS; #37163 **22.6**\n- [x] Correlated subqueries are not supported (Missing columns: \"x\" while processing query) #6697 #9861\n\nBugs:\n- [x] count(*) is not supported for multiple join queries #9853 **fixed via #10291 in 20.3.8**\n- [x] COMMA to CROSS JOIN rewriter is not enabled or cannot rewrite query #9863 **fixed via #9830 in 20.3.5**\n- [x] Mix of COMMA and other JOINS is not supported #9864 **fixed via #9830 in 20.3.5**\n- [x] illegal type FixedString(x) of argument of function like #9882 **fixed via #9890**\n- [x] Logical error: CROSS JOIN has expressions #9910 **fixed via #10311 in 20.3.7**\n- [x] Multiple JOIN do not support asterisks for complex queries yet #10481 **fixed via #9739 in 20.4**\n- [ ] Aggregate function \"x\" is found inside another aggregate function in query (clash of aliases) #9715\n- [x] Cannot refer column \"x\" to table #9855 \n- [x] Illegal types Float64 and Decimal(9, 2) of arguments of function multiply #9881 \n\nCommon join optimizations:\n- [ ] Use right table as a predicate for the left one #8062\n- [x] AND (cond OR cond) prevents CROSS JOIN to INNER JOIN rewrite #19856 **partially fixed via #20392 in 21.4**\n\nMerge join performance optimizations:\n- [ ] Adaptive bucketing of the left table\n- [ ] Using PK sorting of the left table\n- [ ] Using PK sorting of the right table\n\n\n\n\n",
  "hints_text": "**When can I support this**  \uff1f\uff1f\r\n\r\n CTE syntax is different\r\n CTE returning a table is not supported\r\n Window functions are not supported\r\n RANK OVER is not supported\r\n GROUPING aggregate function not implemented  \n> Missing columns: \"x\" while processing query #9861\r\n\r\nIt's an error for not implemented #6697. So it's a feature too.\n@4ertus2 , agree. Moved to features section\n> @4ertus2 , agree. Moved to features section\r\nreally want these features \uff01\r\n\n> @4ertus2 , agree. Moved to features section\r\n\r\nHope to add in later versions\nWhen can the with statement return multiple lines  \uff1f\uff1f\r\nWindow functions are not supported (OVER ... PARTITION BY ... )  &  analytical functions RANK, FIRST, LAST, LAG    \uff0c Do you have a plan  \uff1f\uff1f\n@leoones , 'WITH' returning multiple lines is hopefully for Q3 and window functions for Q4 earliest. Those are complex projects, and we are looking for contributors and sponsors to get it done.\r\n\r\n\nthis functions are very import to analyse complex query,desire it!\r\n>CTE syntax is different\r\nCTE returning a table is not supported\r\nWindow functions are not supported\r\nRANK OVER is not supported\r\n>MySQL 8.0 has implements windows functions:\r\nhttps://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html\n> Interval syntax like '+ 30 days' is not supported\r\n\r\nThis task has been done in [15978](https://github.com/ClickHouse/ClickHouse/pull/15978) @alex-zaitsev \n@ucasFL \r\nIt's more about not using keyword INTERVAL in queries.\r\n\r\n> Interval syntax like '+ 30 days' is not supported\r\n\r\n```\r\npostgres=# SELECT now() + '30 day';\r\n           ?column?\r\n-------------------------------\r\n 2021-02-19 04:01:01.766836+03\r\n(1 row)\r\npostgres=# SELECT now() + '30 days';\r\n           ?column?\r\n-------------------------------\r\n 2021-02-19 04:04:31.177359+03\r\n(1 row)\r\n\r\nLAPTOP-319G0GMQ.localdomain :) SELECT now() + '30 day'\r\nReceived exception from server (version 21.1.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Illegal types DateTime and String of arguments of function plus: While processing now() + '30 day'.\r\n\r\n```\r\n\nINTERSECT, EXCEPT, ANY, ALL implemented by Kirill Ershov and Ksenia Sumarokova.\nEXISTS https://github.com/ClickHouse/ClickHouse/pull/29731\nGROUPING SETS have been implemented and will be available in 22.1 release.\n@alexey-milovidov \r\n\r\ngrouping function not implemented.\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/issues/19426\nI've updated the description.\nGROUPING SETS will not be available in 22.1 release.\nGROUPING SETS are available in 22.5.\r\nGROUPING function is available in 22.6.",
  "created_at": "2025-06-18T13:21:50Z",
  "modified_files": [
    "docs/en/sql-reference/window-functions/index.md",
    "b/docs/en/sql-reference/window-functions/lag.md",
    "b/docs/en/sql-reference/window-functions/lead.md",
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Interpreters/GetAggregatesVisitor.h",
    "src/Processors/Transforms/WindowTransform.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.reference",
    "b/tests/queries/0_stateless/03538_analyzer_lag_lead_functions.sql"
  ]
}