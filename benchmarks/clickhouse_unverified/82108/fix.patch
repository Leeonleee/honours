diff --git a/docs/en/sql-reference/window-functions/index.md b/docs/en/sql-reference/window-functions/index.md
index 5f9ddbd813d5..661b8f0b5770 100644
--- a/docs/en/sql-reference/window-functions/index.md
+++ b/docs/en/sql-reference/window-functions/index.md
@@ -27,7 +27,7 @@ ClickHouse supports the standard grammar for defining windows and window functio
 | Calculating aggregate functions over a frame (`sum(value) over (order by time)`)   | ✅ (All aggregate functions are supported)                                                                                                                                                       |
 | `rank()`, `dense_rank()`, `row_number()`                                           | ✅ <br/>Alias: `denseRank()`                                                                                                                                                                                   |
 | `percent_rank()` | ✅  Efficiently computes the relative standing of a value within a partition in a dataset. This function effectively replaces the more verbose and computationally intensive manual SQL calculation expressed as `ifNull((rank() OVER(PARTITION BY x ORDER BY y) - 1) / nullif(count(1) OVER(PARTITION BY x) - 1, 0), 0)` <br/>Alias: `percentRank()`| 
-| `lag/lead(value, offset)`                                                          | ❌ <br/> You can use one of the following workarounds:<br/> 1) `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead` <br/> 2) `lagInFrame/leadInFrame`, which are analogous, but respect the window frame. To get behavior identical to `lag/lead`, use `rows between unbounded preceding and unbounded following`                                                                 |
+| `lag/lead(value, offset)`                                                          | ✅ <br/> You can also use one of the following workarounds:<br/> 1) `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead` <br/> 2) `lagInFrame/leadInFrame`, which are analogous, but respect the window frame. To get behavior identical to `lag/lead`, use `rows between unbounded preceding and unbounded following`                                                                 |
 | ntile(buckets) | ✅ <br/> Specify window like, (partition by x order by y rows between unbounded preceding and unbounded following). |
 
 ## ClickHouse-specific Window Functions {#clickhouse-specific-window-functions}
diff --git a/docs/en/sql-reference/window-functions/lag.md b/docs/en/sql-reference/window-functions/lag.md
new file mode 100644
index 000000000000..8849d91b8134
--- /dev/null
+++ b/docs/en/sql-reference/window-functions/lag.md
@@ -0,0 +1,78 @@
+---
+description: 'Documentation for the lag window function'
+sidebar_label: 'lag'
+sidebar_position: 9
+slug: /sql-reference/window-functions/lag
+title: 'lag'
+---
+
+# lag
+
+Returns a value evaluated at the row that is at a specified physical offset before the current row within the ordered frame.
+This function is similar to [`lagInFrame`](./lagInFrame.md), but always uses the `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` frame.
+
+**Syntax**
+
+```sql
+lag(x[, offset[, default]])
+  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]] | [window_name])
+FROM table_name
+WINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])
+```
+
+For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).
+
+**Parameters**
+
+- `x` — Column name.
+- `offset` — Offset to apply. [(U)Int*](../data-types/int-uint.md). (Optional - `1` by default).
+- `default` — Value to return if calculated row exceeds the boundaries of the window frame. (Optional - default value of column type when omitted).
+
+**Returned value**
+
+- Value evaluated at the row that is at a specified physical offset before the current row within the ordered frame.
+
+**Example**
+
+This example looks at historical data for a specific stock and uses the `lag` function to calculate a day-to-day delta and percentage change in the closing price of the stock.
+
+```sql title="Query"
+CREATE TABLE stock_prices
+(
+    `date`   Date,
+    `open`   Float32, -- opening price
+    `high`   Float32, -- daily high
+    `low`    Float32, -- daily low
+    `close`  Float32, -- closing price
+    `volume` UInt32   -- trade volume
+)
+Engine = Memory;
+
+INSERT INTO stock_prices FORMAT Values
+    ('2024-06-03', 113.62, 115.00, 112.00, 115.00, 438392000),
+    ('2024-06-04', 115.72, 116.60, 114.04, 116.44, 403324000),
+    ('2024-06-05', 118.37, 122.45, 117.47, 122.44, 528402000),
+    ('2024-06-06', 124.05, 125.59, 118.32, 121.00, 664696000),
+    ('2024-06-07', 119.77, 121.69, 118.02, 120.89, 412386000);
+```
+
+```sql title="Query"
+SELECT
+    date,
+    close,
+    lag(close, 1, close) OVER (ORDER BY date ASC) AS previous_day_close,
+    COALESCE(ROUND(close - previous_day_close, 2)) AS delta,
+    COALESCE(ROUND((delta / previous_day_close) * 100, 2)) AS percent_change
+FROM stock_prices
+ORDER BY date DESC
+```
+
+```response title="Response"
+   ┌───────date─┬──close─┬─previous_day_close─┬─delta─┬─percent_change─┐
+1. │ 2024-06-07 │ 120.89 │                121 │ -0.11 │          -0.09 │
+2. │ 2024-06-06 │    121 │             122.44 │ -1.44 │          -1.18 │
+3. │ 2024-06-05 │ 122.44 │             116.44 │     6 │           5.15 │
+4. │ 2024-06-04 │ 116.44 │                115 │  1.44 │           1.25 │
+5. │ 2024-06-03 │    115 │                115 │     0 │              0 │
+   └────────────┴────────┴────────────────────┴───────┴────────────────┘
+```
diff --git a/docs/en/sql-reference/window-functions/lead.md b/docs/en/sql-reference/window-functions/lead.md
new file mode 100644
index 000000000000..883f31de968f
--- /dev/null
+++ b/docs/en/sql-reference/window-functions/lead.md
@@ -0,0 +1,71 @@
+---
+description: 'Documentation for the lead window function'
+sidebar_label: 'lead'
+sidebar_position: 10
+slug: /sql-reference/window-functions/lead
+title: 'lead'
+---
+
+# lead
+
+Returns a value evaluated at the row that is offset rows after the current row within the ordered frame.
+This function is similar to [`leadInFrame`](./leadInFrame.md), but always uses the `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` frame.
+
+**Syntax**
+
+```sql
+lead(x[, offset[, default]])
+  OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column]] | [window_name])
+FROM table_name
+WINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])
+```
+
+For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).
+
+**Parameters**
+
+- `x` — Column name.
+- `offset` — Offset to apply. [(U)Int*](../data-types/int-uint.md). (Optional - `1` by default).
+- `default` — Value to return if calculated row exceeds the boundaries of the window frame. (Optional - default value of column type when omitted).
+
+**Returned value**
+
+- value evaluated at the row that is offset rows after the current row within the ordered frame.
+
+**Example**
+
+This example looks at [historical data](https://www.kaggle.com/datasets/sazidthe1/nobel-prize-data) for Nobel Prize winners and uses the `lead` function to return a list of successive winners in the physics category.
+
+```sql title="Query"
+CREATE OR REPLACE VIEW nobel_prize_laureates
+AS SELECT *
+FROM file('nobel_laureates_data.csv');
+```
+
+```sql title="Query"
+SELECT
+    fullName,
+    lead(year, 1, year) OVER (PARTITION BY category ORDER BY year ASC
+      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
+    ) AS year,
+    category,
+    motivation
+FROM nobel_prize_laureates
+WHERE category = 'physics'
+ORDER BY year DESC
+LIMIT 9
+```
+
+```response title="Query"
+   ┌─fullName─────────┬─year─┬─category─┬─motivation─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
+1. │ Anne L Huillier  │ 2023 │ physics  │ for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     │
+2. │ Pierre Agostini  │ 2023 │ physics  │ for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     │
+3. │ Ferenc Krausz    │ 2023 │ physics  │ for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter                     │
+4. │ Alain Aspect     │ 2022 │ physics  │ for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science │
+5. │ Anton Zeilinger  │ 2022 │ physics  │ for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science │
+6. │ John Clauser     │ 2022 │ physics  │ for experiments with entangled photons establishing the violation of Bell inequalities and  pioneering quantum information science │
+7. │ Giorgio Parisi   │ 2021 │ physics  │ for the discovery of the interplay of disorder and fluctuations in physical systems from atomic to planetary scales                │
+8. │ Klaus Hasselmann │ 2021 │ physics  │ for the physical modelling of Earths climate quantifying variability and reliably predicting global warming                        │
+9. │ Syukuro Manabe   │ 2021 │ physics  │ for the physical modelling of Earths climate quantifying variability and reliably predicting global warming                        │
+   └──────────────────┴──────┴──────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
+```
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index bb3597d7a8a1..2081004f96d2 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -3358,6 +3358,27 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
         bool window_node_is_identifier = function_node.getWindowNode()->getNodeType() == QueryTreeNodeType::IDENTIFIER;
         ProjectionName window_projection_name = resolveWindow(function_node.getWindowNode(), scope);
 
+        if (function_name == "lag" || function_name == "lead")
+        {
+            auto & frame = function_node.getWindowNode()->as<WindowNode>()->getWindowFrame();
+            if (!frame.is_default)
+            {
+                throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                    "Window function '{}' does not expect window frame to be explicitly specified. In expression {}",
+                    function_name,
+                    function_node.formatASTForErrorMessage());
+            }
+
+            frame = WindowFrame{
+                .is_default = false,
+                .type = WindowFrame::FrameType::ROWS,
+                .begin_type = WindowFrame::BoundaryType::Unbounded,
+                .begin_preceding = true,
+                .end_type = WindowFrame::BoundaryType::Unbounded,
+                .end_preceding = false,
+            };
+        }
+
         if (window_node_is_identifier)
             result_projection_names[0] += " OVER " + window_projection_name;
         else
diff --git a/src/Interpreters/GetAggregatesVisitor.h b/src/Interpreters/GetAggregatesVisitor.h
index e1d22e4de821..46eb2a9d1303 100644
--- a/src/Interpreters/GetAggregatesVisitor.h
+++ b/src/Interpreters/GetAggregatesVisitor.h
@@ -12,6 +12,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int ILLEGAL_AGGREGATION;
+    extern const int NOT_IMPLEMENTED;
 }
 
 class GetAggregatesMatcher
@@ -80,6 +81,13 @@ class GetAggregatesMatcher
                 throw Exception(ErrorCodes::ILLEGAL_AGGREGATION, "Window function {} is found {} in query",
                                 node.getColumnName(), String(data.assert_no_windows));
 
+            if (node.name == "lag" || node.name == "lead")
+            {
+                throw Exception(ErrorCodes::NOT_IMPLEMENTED,
+                    "Window function '{}' is supported only with enabled analyzer",
+                    node.formatForErrorMessage());
+            }
+
             String column_name = node.getColumnName();
             if (data.uniq_names.contains(column_name))
                 return;
diff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp
index 98c21a341fdb..522f20feb7e3 100644
--- a/src/Processors/Transforms/WindowTransform.cpp
+++ b/src/Processors/Transforms/WindowTransform.cpp
@@ -2702,6 +2702,13 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)
                 name, argument_types, parameters);
         }, properties});
 
+    factory.registerFunction("lag", {[](const std::string & name,
+            const DataTypes & argument_types, const Array & parameters, const Settings *)
+        {
+            return std::make_shared<WindowFunctionLagLeadInFrame<false>>(
+                name, argument_types, parameters);
+        }, properties});
+
     factory.registerFunction("leadInFrame", {[](const std::string & name,
             const DataTypes & argument_types, const Array & parameters, const Settings *)
         {
@@ -2709,6 +2716,13 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)
                 name, argument_types, parameters);
         }, properties});
 
+    factory.registerFunction("lead", {[](const std::string & name,
+            const DataTypes & argument_types, const Array & parameters, const Settings *)
+        {
+            return std::make_shared<WindowFunctionLagLeadInFrame<true>>(
+                name, argument_types, parameters);
+        }, properties});
+
     factory.registerFunction("exponentialTimeDecayedSum", {[](const std::string & name,
             const DataTypes & argument_types, const Array & parameters, const Settings *)
         {
