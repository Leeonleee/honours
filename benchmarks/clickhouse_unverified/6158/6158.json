{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6158,
  "instance_id": "ClickHouse__ClickHouse-6158",
  "issue_numbers": [
    "6041"
  ],
  "base_commit": "1222973cb3fa6e267c6bb7d29c44fef2beafe173",
  "patch": "diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h\nindex ff3c8fb58902..b7db44700bb8 100644\n--- a/dbms/src/Core/Settings.h\n+++ b/dbms/src/Core/Settings.h\n@@ -341,6 +341,7 @@ struct Settings : public SettingsCollection<Settings>\n     \\\n     M(SettingUInt64, max_partitions_per_insert_block, 100, \"Limit maximum number of partitions in single INSERTed block. Zero means unlimited. Throw exception if the block contains too many partitions. This setting is a safety threshold, because using large number of partitions is a common misconception.\") \\\n     M(SettingBool, check_query_single_value_result, true, \"Return check query result as single 1/0 value\") \\\n+    M(SettingBool, allow_drop_detached, false, \"Allow ALTER TABLE ... DROP DETACHED PART[ITION] ... queries\") \\\n     \\\n     M(SettingBool, allow_experimental_live_view, false, \"Enable LIVE VIEW. Not mature enough.\") \\\n     M(SettingSeconds, live_view_heartbeat_interval, DEFAULT_LIVE_VIEW_HEARTBEAT_INTERVAL_SEC, \"The heartbeat interval in seconds to indicate live query is alive.\") \\\ndiff --git a/dbms/src/Interpreters/InterpreterAlterQuery.cpp b/dbms/src/Interpreters/InterpreterAlterQuery.cpp\nindex 61d5e011d37b..a32609bd53d9 100644\n--- a/dbms/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -22,6 +22,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int SUPPORT_IS_DISABLED;\n }\n \n \n@@ -56,7 +57,13 @@ BlockIO InterpreterAlterQuery::execute()\n         if (auto alter_command = AlterCommand::parse(command_ast))\n             alter_commands.emplace_back(std::move(*alter_command));\n         else if (auto partition_command = PartitionCommand::parse(command_ast))\n+        {\n+            if (partition_command->type == PartitionCommand::DROP_DETACHED_PARTITION\n+                && !context.getSettingsRef().allow_drop_detached)\n+                throw DB::Exception(\"Cannot execute query: DROP DETACHED PART is disabled \"\n+                                    \"(see allow_drop_detached setting)\", ErrorCodes::SUPPORT_IS_DISABLED);\n             partition_commands.emplace_back(std::move(*partition_command));\n+        }\n         else if (auto mut_command = MutationCommand::parse(command_ast))\n             mutation_commands.emplace_back(std::move(*mut_command));\n         else if (auto live_view_command = LiveViewCommand::parse(command_ast))\ndiff --git a/dbms/src/Parsers/ASTAlterQuery.cpp b/dbms/src/Parsers/ASTAlterQuery.cpp\nindex 67b72eb75bb5..faec26136078 100644\n--- a/dbms/src/Parsers/ASTAlterQuery.cpp\n+++ b/dbms/src/Parsers/ASTAlterQuery.cpp\n@@ -139,6 +139,12 @@ void ASTAlterCommand::formatImpl(\n                       << (settings.hilite ? hilite_none : \"\");\n         partition->formatImpl(settings, state, frame);\n     }\n+    else if (type == ASTAlterCommand::DROP_DETACHED_PARTITION)\n+    {\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << \"DROP DETACHED\" << (part ? \" PART \" : \" PARTITION \")\n+                      << (settings.hilite ? hilite_none : \"\");\n+        partition->formatImpl(settings, state, frame);\n+    }\n     else if (type == ASTAlterCommand::ATTACH_PARTITION)\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << \"ATTACH \"\ndiff --git a/dbms/src/Parsers/ASTAlterQuery.h b/dbms/src/Parsers/ASTAlterQuery.h\nindex 2edabcdc70d1..68b26b56f3e9 100644\n--- a/dbms/src/Parsers/ASTAlterQuery.h\n+++ b/dbms/src/Parsers/ASTAlterQuery.h\n@@ -43,6 +43,7 @@ class ASTAlterCommand : public IAST\n         MATERIALIZE_INDEX,\n \n         DROP_PARTITION,\n+        DROP_DETACHED_PARTITION,\n         ATTACH_PARTITION,\n         REPLACE_PARTITION,\n         FETCH_PARTITION,\n@@ -115,7 +116,7 @@ class ASTAlterCommand : public IAST\n \n     bool detach = false;        /// true for DETACH PARTITION\n \n-    bool part = false;          /// true for ATTACH PART\n+    bool part = false;          /// true for ATTACH PART and DROP DETACHED PART\n \n     bool clear_column = false;  /// for CLEAR COLUMN (do not drop column from metadata)\n \ndiff --git a/dbms/src/Parsers/ParserAlterQuery.cpp b/dbms/src/Parsers/ParserAlterQuery.cpp\nindex 0045769ca4db..ca6a0d7b6267 100644\n--- a/dbms/src/Parsers/ParserAlterQuery.cpp\n+++ b/dbms/src/Parsers/ParserAlterQuery.cpp\n@@ -44,6 +44,8 @@ bool ParserAlterCommand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n     ParserKeyword s_attach_partition(\"ATTACH PARTITION\");\n     ParserKeyword s_detach_partition(\"DETACH PARTITION\");\n     ParserKeyword s_drop_partition(\"DROP PARTITION\");\n+    ParserKeyword s_drop_detached_partition(\"DROP DETACHED PARTITION\");\n+    ParserKeyword s_drop_detached_part(\"DROP DETACHED PART\");\n     ParserKeyword s_attach_part(\"ATTACH PART\");\n     ParserKeyword s_fetch_partition(\"FETCH PARTITION\");\n     ParserKeyword s_replace_partition(\"REPLACE PARTITION\");\n@@ -155,6 +157,21 @@ bool ParserAlterCommand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n \n             command->type = ASTAlterCommand::DROP_PARTITION;\n         }\n+        else if (s_drop_detached_partition.ignore(pos, expected))\n+        {\n+            if (!parser_partition.parse(pos, command->partition, expected))\n+                return false;\n+\n+            command->type = ASTAlterCommand::DROP_DETACHED_PARTITION;\n+        }\n+        else if (s_drop_detached_part.ignore(pos, expected))\n+        {\n+            if (!parser_string_literal.parse(pos, command->partition, expected))\n+                return false;\n+\n+            command->type = ASTAlterCommand::DROP_DETACHED_PARTITION;\n+            command->part = true;\n+        }\n         else if (s_drop_column.ignore(pos, expected))\n         {\n             if (s_if_exists.ignore(pos, expected))\n@@ -163,8 +180,8 @@ bool ParserAlterCommand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n             if (!parser_name.parse(pos, command->column, expected))\n                 return false;\n \n-        command->type = ASTAlterCommand::DROP_COLUMN;\n-        command->detach = false;\n+            command->type = ASTAlterCommand::DROP_COLUMN;\n+            command->detach = false;\n         }\n         else if (s_clear_column.ignore(pos, expected))\n         {\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeData.cpp b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\nindex db063593652b..a031cf0a8695 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -87,6 +87,8 @@ namespace ErrorCodes\n     extern const int CANNOT_MUNMAP;\n     extern const int CANNOT_MREMAP;\n     extern const int BAD_TTL_EXPRESSION;\n+    extern const int INCORRECT_FILE_NAME;\n+    extern const int BAD_DATA_PART_NAME;\n }\n \n \n@@ -1766,6 +1768,52 @@ MergeTreeData::AlterDataPartTransaction::~AlterDataPartTransaction()\n     }\n }\n \n+void MergeTreeData::PartsTemporaryRename::addPart(const String & old_name, const String & new_name)\n+{\n+    old_and_new_names.push_back({old_name, new_name});\n+}\n+\n+void MergeTreeData::PartsTemporaryRename::tryRenameAll()\n+{\n+    renamed = true;\n+    for (size_t i = 0; i < old_and_new_names.size(); ++i)\n+    {\n+        try\n+        {\n+            const auto & names = old_and_new_names[i];\n+            if (names.first.empty() || names.second.empty())\n+                throw DB::Exception(\"Empty part name. Most likely it's a bug.\", ErrorCodes::INCORRECT_FILE_NAME);\n+            Poco::File(base_dir + names.first).renameTo(base_dir + names.second);\n+        }\n+        catch (...)\n+        {\n+            old_and_new_names.resize(i);\n+            LOG_WARNING(storage.log, \"Cannot rename parts to perform operation on them: \" << getCurrentExceptionMessage(false));\n+            throw;\n+        }\n+    }\n+}\n+\n+MergeTreeData::PartsTemporaryRename::~PartsTemporaryRename()\n+{\n+    // TODO what if server had crashed before this destructor was called?\n+    if (!renamed)\n+        return;\n+    for (const auto & names : old_and_new_names)\n+    {\n+        if (names.first.empty())\n+            continue;\n+        try\n+        {\n+            Poco::File(base_dir + names.second).renameTo(base_dir + names.first);\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+}\n+\n \n MergeTreeData::DataPartsVector MergeTreeData::getActivePartsToReplace(\n     const MergeTreePartInfo & new_part_info,\n@@ -2386,6 +2434,12 @@ MergeTreeData::MutableDataPartPtr MergeTreeData::loadPartAndFixMetadata(const St\n {\n     MutableDataPartPtr part = std::make_shared<DataPart>(*this, Poco::Path(relative_path).getFileName());\n     part->relative_path = relative_path;\n+    loadPartAndFixMetadata(part);\n+    return part;\n+}\n+\n+void MergeTreeData::loadPartAndFixMetadata(MutableDataPartPtr part)\n+{\n     String full_part_path = part->getFullPath();\n \n     /// Earlier the list of columns was written incorrectly. Delete it and re-create.\n@@ -2407,8 +2461,6 @@ MergeTreeData::MutableDataPartPtr MergeTreeData::loadPartAndFixMetadata(const St\n \n         Poco::File(full_part_path + \"checksums.txt.tmp\").renameTo(full_part_path + \"checksums.txt\");\n     }\n-\n-    return part;\n }\n \n \n@@ -2628,24 +2680,122 @@ MergeTreeData::getDetachedParts() const\n         res.emplace_back();\n         auto & part = res.back();\n \n-        /// First, try to parse as <part_name>.\n-        if (MergeTreePartInfo::tryParsePartName(dir_name, &part, format_version))\n-            continue;\n+        DetachedPartInfo::tryParseDetachedPartName(dir_name, part, format_version);\n+    }\n+    return res;\n+}\n \n-        /// Next, as <prefix>_<partname>. Use entire name as prefix if it fails.\n-        part.prefix = dir_name;\n-        const auto first_separator = dir_name.find_first_of('_');\n-        if (first_separator == String::npos)\n-            continue;\n+void MergeTreeData::validateDetachedPartName(const String & name) const\n+{\n+    if (name.find('/') != std::string::npos || name == \".\" || name == \"..\")\n+        throw DB::Exception(\"Invalid part name\", ErrorCodes::INCORRECT_FILE_NAME);\n \n-        const auto part_name = dir_name.substr(first_separator + 1,\n-            dir_name.size() - first_separator - 1);\n-        if (!MergeTreePartInfo::tryParsePartName(part_name, &part, format_version))\n-           continue;\n+    Poco::File detached_part_dir(full_path + \"detached/\" + name);\n+    if (!detached_part_dir.exists())\n+        throw DB::Exception(\"Detached part \\\"\" + name + \"\\\" not found\" , ErrorCodes::BAD_DATA_PART_NAME);\n \n-        part.prefix = dir_name.substr(0, first_separator);\n+    if (startsWith(name, \"attaching_\") || startsWith(name, \"deleting_\"))\n+        throw DB::Exception(\"Cannot drop part \" + name + \": \"\n+                            \"most likely it is used by another DROP or ATTACH query.\",\n+                            ErrorCodes::BAD_DATA_PART_NAME);\n+}\n+\n+void MergeTreeData::dropDetached(const ASTPtr & partition, bool part, const Context & context)\n+{\n+    PartsTemporaryRename renamed_parts(*this, full_path + \"detached/\");\n+\n+    if (part)\n+    {\n+        String part_name = partition->as<ASTLiteral &>().value.safeGet<String>();\n+        validateDetachedPartName(part_name);\n+        renamed_parts.addPart(part_name, \"deleting_\" + part_name);\n     }\n-    return res;\n+    else\n+    {\n+        String partition_id = getPartitionIDFromQuery(partition, context);\n+        DetachedPartsInfo detached_parts = getDetachedParts();\n+        for (const auto & part_info : detached_parts)\n+            if (part_info.valid_name && part_info.partition_id == partition_id\n+                && part_info.prefix != \"attaching\" && part_info.prefix != \"deleting\")\n+                renamed_parts.addPart(part_info.dir_name, \"deleting_\" + part_info.dir_name);\n+    }\n+\n+    LOG_DEBUG(log, \"Will drop \" << renamed_parts.old_and_new_names.size() << \" detached parts.\");\n+\n+    renamed_parts.tryRenameAll();\n+\n+    for (auto & names : renamed_parts.old_and_new_names)\n+    {\n+        Poco::File(renamed_parts.base_dir + names.second).remove(true);\n+        LOG_DEBUG(log, \"Dropped detached part \" << names.first);\n+        names.first.clear();\n+    }\n+}\n+\n+MergeTreeData::MutableDataPartsVector MergeTreeData::tryLoadPartsToAttach(const ASTPtr & partition, bool attach_part,\n+        const Context & context, PartsTemporaryRename & renamed_parts)\n+{\n+    String source_dir = \"detached/\";\n+\n+    /// Let's compose a list of parts that should be added.\n+    if (attach_part)\n+    {\n+        String part_id = partition->as<ASTLiteral &>().value.safeGet<String>();\n+        validateDetachedPartName(part_id);\n+        renamed_parts.addPart(part_id, \"attaching_\" + part_id);\n+    }\n+    else\n+    {\n+        String partition_id = getPartitionIDFromQuery(partition, context);\n+        LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir);\n+        ActiveDataPartSet active_parts(format_version);\n+\n+        std::set<String> part_names;\n+        for (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)\n+        {\n+            String name = it.name();\n+            MergeTreePartInfo part_info;\n+            // TODO what if name contains \"_tryN\" suffix?\n+            /// Parts with prefix in name (e.g. attaching_1_3_3_0, deleting_1_3_3_0) will be ignored\n+            if (!MergeTreePartInfo::tryParsePartName(name, &part_info, format_version))\n+                continue;\n+            if (part_info.partition_id != partition_id)\n+                continue;\n+            LOG_DEBUG(log, \"Found part \" << name);\n+            active_parts.add(name);\n+            part_names.insert(name);\n+        }\n+        LOG_DEBUG(log, active_parts.size() << \" of them are active\");\n+\n+        /// Inactive parts rename so they can not be attached in case of repeated ATTACH.\n+        for (const auto & name : part_names)\n+        {\n+            String containing_part = active_parts.getContainingPart(name);\n+            if (!containing_part.empty() && containing_part != name)\n+                // TODO maybe use PartsTemporaryRename here?\n+                Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name);\n+            else\n+                renamed_parts.addPart(name, \"attaching_\" + name);\n+        }\n+    }\n+\n+    /// Try to rename all parts before attaching to prevent race with DROP DETACHED and another ATTACH.\n+    renamed_parts.tryRenameAll();\n+\n+    /// Synchronously check that added parts exist and are not broken. We will write checksums.txt if it does not exist.\n+    LOG_DEBUG(log, \"Checking parts\");\n+    MutableDataPartsVector loaded_parts;\n+    loaded_parts.reserve(renamed_parts.old_and_new_names.size());\n+    for (const auto & part_names : renamed_parts.old_and_new_names)\n+    {\n+        LOG_DEBUG(log, \"Checking part \" << part_names.second);\n+        MutableDataPartPtr part = std::make_shared<DataPart>(*this, part_names.first);\n+        part->relative_path = source_dir + part_names.second;\n+        loadPartAndFixMetadata(part);\n+        loaded_parts.push_back(part);\n+    }\n+\n+    return loaded_parts;\n }\n \n MergeTreeData::DataParts MergeTreeData::getDataParts(const DataPartStates & affordable_states) const\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeData.h b/dbms/src/Storages/MergeTree/MergeTreeData.h\nindex 8c2217324f21..ada5aa065bb4 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.h\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.h\n@@ -249,6 +249,23 @@ class MergeTreeData : public IStorage\n \n     using AlterDataPartTransactionPtr = std::unique_ptr<AlterDataPartTransaction>;\n \n+    struct PartsTemporaryRename : private boost::noncopyable\n+    {\n+        PartsTemporaryRename(const MergeTreeData & storage_, const String & base_dir_) : storage(storage_), base_dir(base_dir_) {}\n+\n+        void addPart(const String & old_name, const String & new_name);\n+\n+        /// Renames part from old_name to new_name\n+        void tryRenameAll();\n+\n+        /// Renames all added parts from new_name to old_name if old name is not empty\n+        ~PartsTemporaryRename();\n+\n+        const MergeTreeData & storage;\n+        String base_dir;\n+        std::vector<std::pair<String, String>> old_and_new_names;\n+        bool renamed = false;\n+    };\n \n     /// Parameters for various modes.\n     struct MergingParams\n@@ -388,7 +405,14 @@ class MergeTreeData : public IStorage\n     DataPartsVector getAllDataPartsVector(DataPartStateVector * out_states = nullptr) const;\n \n     /// Returns all detached parts\n-    std::vector<DetachedPartInfo> getDetachedParts() const;\n+    DetachedPartsInfo getDetachedParts() const;\n+\n+    void validateDetachedPartName(const String & name) const;\n+\n+    void dropDetached(const ASTPtr & partition, bool part, const Context & context);\n+\n+    MutableDataPartsVector tryLoadPartsToAttach(const ASTPtr & partition, bool attach_part,\n+            const Context & context, PartsTemporaryRename & renamed_parts);\n \n     /// Returns Committed parts\n     DataParts getDataParts() const;\n@@ -536,6 +560,7 @@ class MergeTreeData : public IStorage\n \n     /// Check that the part is not broken and calculate the checksums for it if they are not present.\n     MutableDataPartPtr loadPartAndFixMetadata(const String & relative_path);\n+    void loadPartAndFixMetadata(MutableDataPartPtr part);\n \n     /** Create local backup (snapshot) for parts with specified prefix.\n       * Backup is created in directory clickhouse_dir/shadow/i/, where i - incremental number,\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp\nindex 0b208a13b59e..1f884aa08b32 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp\n@@ -142,10 +142,7 @@ MergeTreeDataPart::MergeTreeDataPart(MergeTreeData & storage_, const String & na\n {\n }\n \n-MergeTreeDataPart::MergeTreeDataPart(\n-    const MergeTreeData & storage_,\n-    const String & name_,\n-    const MergeTreePartInfo & info_)\n+MergeTreeDataPart::MergeTreeDataPart(const MergeTreeData & storage_, const String & name_, const MergeTreePartInfo & info_)\n     : storage(storage_)\n     , name(name_)\n     , info(info_)\n@@ -367,6 +364,8 @@ void MergeTreeDataPart::remove() const\n       * And a race condition can happen that will lead to \"File not found\" error here.\n       */\n \n+    // TODO directory delete_tmp_<name> is never removed if server crashes before returning from this function\n+\n     String from = storage.full_path + relative_path;\n     String to = storage.full_path + \"delete_tmp_\" + name;\n \ndiff --git a/dbms/src/Storages/MergeTree/MergeTreePartInfo.cpp b/dbms/src/Storages/MergeTree/MergeTreePartInfo.cpp\nindex 19f774481100..3ee330b6d1a5 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreePartInfo.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreePartInfo.cpp\n@@ -188,4 +188,30 @@ String MergeTreePartInfo::getPartNameV0(DayNum left_date, DayNum right_date) con\n     return wb.str();\n }\n \n+bool DetachedPartInfo::tryParseDetachedPartName(const String & dir_name, DetachedPartInfo & part_info,\n+                                                MergeTreeDataFormatVersion format_version)\n+{\n+    part_info.dir_name = dir_name;\n+\n+    /// First, try to parse as <part_name>.\n+    // TODO what if tryParsePartName will parse prefix as partition_id? It can happen if dir_name doesn't contain mutation number at the end\n+    if (MergeTreePartInfo::tryParsePartName(dir_name, &part_info, format_version))\n+        return part_info.valid_name = true;\n+\n+    /// Next, as <prefix>_<partname>. Use entire name as prefix if it fails.\n+    part_info.prefix = dir_name;\n+    const auto first_separator = dir_name.find_first_of('_');\n+    if (first_separator == String::npos)\n+        return part_info.valid_name = false;\n+\n+    // TODO what if <prefix> contains '_'?\n+    const auto part_name = dir_name.substr(first_separator + 1,\n+                                           dir_name.size() - first_separator - 1);\n+    if (!MergeTreePartInfo::tryParsePartName(part_name, &part_info, format_version))\n+        return part_info.valid_name = false;\n+\n+    part_info.prefix = dir_name.substr(0, first_separator);\n+    return part_info.valid_name = true;\n+}\n+\n }\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreePartInfo.h b/dbms/src/Storages/MergeTree/MergeTreePartInfo.h\nindex e80664c3dd91..9fe0fbab5331 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreePartInfo.h\n+++ b/dbms/src/Storages/MergeTree/MergeTreePartInfo.h\n@@ -92,7 +92,15 @@ struct MergeTreePartInfo\n /// addition to the above fields.\n struct DetachedPartInfo : public MergeTreePartInfo\n {\n+    String dir_name;\n     String prefix;\n+\n+    /// If false, MergeTreePartInfo is in invalid state (directory name was not successfully parsed).\n+    bool valid_name;\n+\n+    static bool tryParseDetachedPartName(const String & dir_name, DetachedPartInfo & part_info, MergeTreeDataFormatVersion format_version);\n };\n \n+using DetachedPartsInfo = std::vector<DetachedPartInfo>;\n+\n }\ndiff --git a/dbms/src/Storages/PartitionCommands.cpp b/dbms/src/Storages/PartitionCommands.cpp\nindex 028e8170a9f2..086b8237b77c 100644\n--- a/dbms/src/Storages/PartitionCommands.cpp\n+++ b/dbms/src/Storages/PartitionCommands.cpp\n@@ -23,6 +23,14 @@ std::optional<PartitionCommand> PartitionCommand::parse(const ASTAlterCommand *\n         res.detach = command_ast->detach;\n         return res;\n     }\n+    else if (command_ast->type == ASTAlterCommand::DROP_DETACHED_PARTITION)\n+    {\n+        PartitionCommand res;\n+        res.type = DROP_DETACHED_PARTITION;\n+        res.partition = command_ast->partition;\n+        res.part = command_ast->part;\n+        return res;\n+    }\n     else if (command_ast->type == ASTAlterCommand::ATTACH_PARTITION)\n     {\n         PartitionCommand res;\ndiff --git a/dbms/src/Storages/PartitionCommands.h b/dbms/src/Storages/PartitionCommands.h\nindex 8d17d3d38e2f..7c13aa559148 100644\n--- a/dbms/src/Storages/PartitionCommands.h\n+++ b/dbms/src/Storages/PartitionCommands.h\n@@ -22,6 +22,7 @@ struct PartitionCommand\n         CLEAR_COLUMN,\n         CLEAR_INDEX,\n         DROP_PARTITION,\n+        DROP_DETACHED_PARTITION,\n         FETCH_PARTITION,\n         FREEZE_ALL_PARTITIONS,\n         FREEZE_PARTITION,\n@@ -37,7 +38,7 @@ struct PartitionCommand\n     /// true for DETACH PARTITION.\n     bool detach = false;\n \n-    /// true for ATTACH PART (and false for PARTITION)\n+    /// true for ATTACH PART and DROP DETACHED PART (and false for PARTITION)\n     bool part = false;\n \n     /// For ATTACH PARTITION partition FROM db.table\ndiff --git a/dbms/src/Storages/StorageMergeTree.cpp b/dbms/src/Storages/StorageMergeTree.cpp\nindex 6acd470270ba..841d2f455c1b 100644\n--- a/dbms/src/Storages/StorageMergeTree.cpp\n+++ b/dbms/src/Storages/StorageMergeTree.cpp\n@@ -947,6 +947,10 @@ void StorageMergeTree::alterPartition(const ASTPtr & query, const PartitionComma\n                 dropPartition(command.partition, command.detach, context);\n                 break;\n \n+            case PartitionCommand::DROP_DETACHED_PARTITION:\n+                dropDetached(command.partition, command.part, context);\n+                break;\n+\n             case PartitionCommand::ATTACH_PARTITION:\n                 attachPartition(command.partition, command.part, context);\n                 break;\n@@ -1011,6 +1015,7 @@ void StorageMergeTree::dropPartition(const ASTPtr & partition, bool detach, cons\n \n         /// TODO: should we include PreComitted parts like in Replicated case?\n         auto parts_to_remove = getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);\n+        // TODO should we throw an exception if parts_to_remove is empty?\n         removePartsFromWorkingSet(parts_to_remove, true);\n \n         if (detach)\n@@ -1034,51 +1039,14 @@ void StorageMergeTree::attachPartition(const ASTPtr & partition, bool attach_par\n {\n     // TODO: should get some locks to prevent race with 'alter \u2026 modify column'\n \n-    String partition_id;\n-\n-    if (attach_part)\n-        partition_id = partition->as<ASTLiteral &>().value.safeGet<String>();\n-    else\n-        partition_id = getPartitionIDFromQuery(partition, context);\n-\n-    String source_dir = \"detached/\";\n-\n-    /// Let's make a list of parts to add.\n-    Strings parts;\n-    if (attach_part)\n-    {\n-        parts.push_back(partition_id);\n-    }\n-    else\n-    {\n-        LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir);\n-        ActiveDataPartSet active_parts(format_version);\n-        for (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)\n-        {\n-            const String & name = it.name();\n-            MergeTreePartInfo part_info;\n-            if (!MergeTreePartInfo::tryParsePartName(name, &part_info, format_version)\n-                || part_info.partition_id != partition_id)\n-            {\n-                continue;\n-            }\n-            LOG_DEBUG(log, \"Found part \" << name);\n-            active_parts.add(name);\n-        }\n-        LOG_DEBUG(log, active_parts.size() << \" of them are active\");\n-        parts = active_parts.getParts();\n-    }\n+    PartsTemporaryRename renamed_parts(*this, full_path + \"detached/\");\n+    MutableDataPartsVector loaded_parts = tryLoadPartsToAttach(partition, attach_part, context, renamed_parts);\n \n-    for (const auto & source_part_name : parts)\n+    for (size_t i = 0; i < loaded_parts.size(); ++i)\n     {\n-        String source_path = source_dir + source_part_name;\n-\n-        LOG_DEBUG(log, \"Checking data\");\n-        MutableDataPartPtr part = loadPartAndFixMetadata(source_path);\n-\n-        LOG_INFO(log, \"Attaching part \" << source_part_name << \" from \" << source_path);\n-        renameTempPartAndAdd(part, &increment);\n-\n+        LOG_INFO(log, \"Attaching part \" << loaded_parts[i]->name << \" from \" << renamed_parts.old_and_new_names[i].second);\n+        renameTempPartAndAdd(loaded_parts[i], &increment);\n+        renamed_parts.old_and_new_names[i].first.clear();\n         LOG_INFO(log, \"Finished attaching part\");\n     }\n \n@@ -1158,6 +1126,7 @@ void StorageMergeTree::replacePartitionFrom(const StoragePtr & source_table, con\n     }\n }\n \n+\n ActionLock StorageMergeTree::getActionLock(StorageActionBlockType action_type)\n {\n     if (action_type == ActionLocks::PartsMerge)\ndiff --git a/dbms/src/Storages/StorageReplicatedMergeTree.cpp b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\nindex aeb09e44c0d7..367a8fffbf7e 100644\n--- a/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -3408,6 +3408,10 @@ void StorageReplicatedMergeTree::alterPartition(const ASTPtr & query, const Part\n                 dropPartition(query, command.partition, command.detach, query_context);\n                 break;\n \n+            case PartitionCommand::DROP_DETACHED_PARTITION:\n+                dropDetached(command.partition, command.part, query_context);\n+                break;\n+\n             case PartitionCommand::ATTACH_PARTITION:\n                 attachPartition(command.partition, command.part, query_context);\n                 break;\n@@ -3607,66 +3611,16 @@ void StorageReplicatedMergeTree::attachPartition(const ASTPtr & partition, bool\n \n     assertNotReadonly();\n \n-    String partition_id;\n-\n-    if (attach_part)\n-        partition_id = partition->as<ASTLiteral &>().value.safeGet<String>();\n-    else\n-        partition_id = getPartitionIDFromQuery(partition, query_context);\n-\n-    String source_dir = \"detached/\";\n-\n-    /// Let's compose a list of parts that should be added.\n-    Strings parts;\n-    if (attach_part)\n-    {\n-        parts.push_back(partition_id);\n-    }\n-    else\n-    {\n-        LOG_DEBUG(log, \"Looking for parts for partition \" << partition_id << \" in \" << source_dir);\n-        ActiveDataPartSet active_parts(format_version);\n-\n-        std::set<String> part_names;\n-        for (Poco::DirectoryIterator it = Poco::DirectoryIterator(full_path + source_dir); it != Poco::DirectoryIterator(); ++it)\n-        {\n-            String name = it.name();\n-            MergeTreePartInfo part_info;\n-            if (!MergeTreePartInfo::tryParsePartName(name, &part_info, format_version))\n-                continue;\n-            if (part_info.partition_id != partition_id)\n-                continue;\n-            LOG_DEBUG(log, \"Found part \" << name);\n-            active_parts.add(name);\n-            part_names.insert(name);\n-        }\n-        LOG_DEBUG(log, active_parts.size() << \" of them are active\");\n-        parts = active_parts.getParts();\n-\n-        /// Inactive parts rename so they can not be attached in case of repeated ATTACH.\n-        for (const auto & name : part_names)\n-        {\n-            String containing_part = active_parts.getContainingPart(name);\n-            if (!containing_part.empty() && containing_part != name)\n-                Poco::File(full_path + source_dir + name).renameTo(full_path + source_dir + \"inactive_\" + name);\n-        }\n-    }\n-\n-    /// Synchronously check that added parts exist and are not broken. We will write checksums.txt if it does not exist.\n-    LOG_DEBUG(log, \"Checking parts\");\n-    std::vector<MutableDataPartPtr> loaded_parts;\n-    for (const String & part : parts)\n-    {\n-        LOG_DEBUG(log, \"Checking part \" << part);\n-        loaded_parts.push_back(loadPartAndFixMetadata(source_dir + part));\n-    }\n+    PartsTemporaryRename renamed_parts(*this, full_path + \"detached/\");\n+    MutableDataPartsVector loaded_parts = tryLoadPartsToAttach(partition, attach_part, query_context, renamed_parts);\n \n     ReplicatedMergeTreeBlockOutputStream output(*this, 0, 0, 0, false);   /// TODO Allow to use quorum here.\n-    for (auto & part : loaded_parts)\n+    for (size_t i = 0; i < loaded_parts.size(); ++i)\n     {\n-        String old_name = part->name;\n-        output.writeExistingPart(part);\n-        LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << part->name);\n+        String old_name = loaded_parts[i]->name;\n+        output.writeExistingPart(loaded_parts[i]);\n+        renamed_parts.old_and_new_names[i].first.clear();\n+        LOG_DEBUG(log, \"Attached part \" << old_name << \" as \" << loaded_parts[i]->name);\n     }\n }\n \ndiff --git a/dbms/src/Storages/System/StorageSystemDetachedParts.cpp b/dbms/src/Storages/System/StorageSystemDetachedParts.cpp\nindex 617b52d8e5f5..ce1bfc6fc211 100644\n--- a/dbms/src/Storages/System/StorageSystemDetachedParts.cpp\n+++ b/dbms/src/Storages/System/StorageSystemDetachedParts.cpp\n@@ -2,6 +2,7 @@\n \n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <DataStreams/OneBlockInputStream.h>\n #include <ext/shared_ptr_helper.h>\n #include <Storages/IStorage.h>\n@@ -31,12 +32,12 @@ class StorageSystemDetachedParts :\n         setColumns(ColumnsDescription{{\n             {\"database\", std::make_shared<DataTypeString>()},\n             {\"table\", std::make_shared<DataTypeString>()},\n-            {\"partition_id\", std::make_shared<DataTypeString>()},\n+            {\"partition_id\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())},\n             {\"name\", std::make_shared<DataTypeString>()},\n-            {\"reason\", std::make_shared<DataTypeString>()},\n-            {\"min_block_number\", std::make_shared<DataTypeInt64>()},\n-            {\"max_block_number\", std::make_shared<DataTypeInt64>()},\n-            {\"level\", std::make_shared<DataTypeUInt32>()}\n+            {\"reason\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>())},\n+            {\"min_block_number\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeInt64>())},\n+            {\"max_block_number\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeInt64>())},\n+            {\"level\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeUInt32>())}\n         }});\n     }\n \n@@ -62,12 +63,12 @@ class StorageSystemDetachedParts :\n                 size_t i = 0;\n                 new_columns[i++]->insert(info.database);\n                 new_columns[i++]->insert(info.table);\n-                new_columns[i++]->insert(p.partition_id);\n-                new_columns[i++]->insert(p.getPartName());\n-                new_columns[i++]->insert(p.prefix);\n-                new_columns[i++]->insert(p.min_block);\n-                new_columns[i++]->insert(p.max_block);\n-                new_columns[i++]->insert(p.level);\n+                new_columns[i++]->insert(p.valid_name ? p.partition_id : Field());\n+                new_columns[i++]->insert(p.dir_name);\n+                new_columns[i++]->insert(p.valid_name ? p.prefix : Field());\n+                new_columns[i++]->insert(p.valid_name ? p.min_block : Field());\n+                new_columns[i++]->insert(p.valid_name ? p.max_block : Field());\n+                new_columns[i++]->insert(p.valid_name ? p.level : Field());\n             }\n         }\n \ndiff --git a/docs/en/operations/system_tables.md b/docs/en/operations/system_tables.md\nindex 9f246c20725b..0f0917a876c9 100644\n--- a/docs/en/operations/system_tables.md\n+++ b/docs/en/operations/system_tables.md\n@@ -87,10 +87,9 @@ This table contains a single String column called 'name' \u2013 the name of a datab\n Each database that the server knows about has a corresponding entry in the table.\n This system table is used for implementing the `SHOW DATABASES` query.\n \n-## system.detached_parts\n-\n-Contains information about detached parts of [MergeTree](table_engines/mergetree.md) tables. The `reason` column specifies why the part was detached. For user-detached parts, the reason is empty. Such parts can be attached with [ALTER TABLE ATTACH PARTITION|PART](../query_language/query_language/alter/#alter_attach-partition) command. For the description of other columns, see [system.parts](#system_tables-parts).\n+## system.detached_parts {#system_tables-detached_parts}\n \n+Contains information about detached parts of [MergeTree](table_engines/mergetree.md) tables. The `reason` column specifies why the part was detached. For user-detached parts, the reason is empty. Such parts can be attached with [ALTER TABLE ATTACH PARTITION|PART](../query_language/query_language/alter/#alter_attach-partition) command. For the description of other columns, see [system.parts](#system_tables-parts). If part name is invalid, values of some columns may be `NULL`. Such parts can be deleted with [ALTER TABLE DROP DETACHED PART](../query_language/query_language/alter/#alter_drop-detached).\n \n ## system.dictionaries\n \ndiff --git a/docs/en/query_language/alter.md b/docs/en/query_language/alter.md\nindex 102c65528e2d..ec4e00497324 100644\n--- a/docs/en/query_language/alter.md\n+++ b/docs/en/query_language/alter.md\n@@ -211,6 +211,16 @@ Read about setting the partition expression in a section [How to specify the par\n \n The query is replicated \u2013 it deletes data on all replicas.\n \n+#### DROP DETACHED PARTITION|PART {#alter_drop-detached}\n+\n+```sql\n+ALTER TABLE table_name DROP DETACHED PARTITION|PART partition_expr\n+```\n+\n+Removes the specified part or all parts of the specified partition from `detached`.\n+Read more about setting the partition expression in a section [How to specify the partition expression](#alter-how-to-specify-part-expr).\n+\n+\n #### ATTACH PARTITION|PART {#alter_attach-partition}\n \n ``` sql\n@@ -336,7 +346,7 @@ You can specify the partition expression in `ALTER ... PARTITION` queries in dif\n - As a value from the `partition` column of the `system.parts` table. For example, `ALTER TABLE visits DETACH PARTITION 201901`.\n - As the expression from the table column. Constants and constant expressions are supported. For example, `ALTER TABLE visits DETACH PARTITION toYYYYMM(toDate('2019-01-25'))`.\n - Using the partition ID. Partition ID is a string identifier of the partition (human-readable, if possible) that is used as the names of partitions in the file system and in ZooKeeper. The partition ID must be specified in the `PARTITION ID` clause, in a single quotes. For example, `ALTER TABLE visits DETACH PARTITION ID '201901'`.\n-- In the [ALTER ATTACH PART](#alter_attach-partition) query, to specify the name of a part, use a value from the `name` column of the `system.parts` table. For example, `ALTER TABLE visits ATTACH PART 201901_1_1_0`.\n+- In the [ALTER ATTACH PART](#alter_attach-partition) and [DROP DETACHED PART](#alter_drop-detached) query, to specify the name of a part, use string literal with a value from the `name` column of the [system.detached_parts](../operations/system_tables.md#system_tables-detached_parts) table. For example, `ALTER TABLE visits ATTACH PART '201901_1_1_0'`.\n \n Usage of quotes when specifying the partition depends on the type of partition expression. For example, for the `String` type, you have to specify its name in quotes (`'`). For the `Date` and `Int*` types no quotes are needed.\n \ndiff --git a/docs/ru/operations/system_tables.md b/docs/ru/operations/system_tables.md\nindex 707f74c0b220..bcf61a7f0da1 100644\n--- a/docs/ru/operations/system_tables.md\n+++ b/docs/ru/operations/system_tables.md\n@@ -87,6 +87,12 @@ user String \u2014 \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\n \u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445, \u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0437\u043d\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440, \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0430\u044f \u0437\u0430\u043f\u0438\u0441\u044c \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435.\n \u042d\u0442\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 `SHOW DATABASES`.\n \n+## system.detached_parts {#system_tables-detached_parts}\n+\n+\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431 \u043e\u0442\u0441\u043e\u0435\u0434\u0438\u043d\u0451\u043d\u043d\u044b\u0445 \u043a\u0443\u0441\u043a\u0430\u0445 \u0442\u0430\u0431\u043b\u0438\u0446 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432\u0430 [MergeTree](table_engines/mergetree.md). \u0421\u0442\u043e\u043b\u0431\u0435\u0446 `reason` \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u0440\u0438\u0447\u0438\u043d\u0443, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043a\u0443\u0441\u043e\u043a \u0431\u044b\u043b \u043e\u0442\u0441\u043e\u0435\u0434\u0438\u043d\u0451\u043d. \u0414\u043b\u044f \u043a\u0443\u0441\u043e\u0432, \u043e\u0442\u0441\u043e\u0435\u0434\u0438\u043d\u0451\u043d\u043d\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c, `reason` \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443.\n+\u0422\u0430\u043a\u0438\u0435 \u043a\u0443\u0441\u043a\u0438 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0438\u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u044b \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e [ALTER TABLE ATTACH PARTITION|PART](../query_language/query_language/alter/#alter_attach-partition). \u041e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u0431\u0446\u044b \u043e\u043f\u0438\u0441\u0430\u043d\u044b \u0432 [system.parts](#system_tables-parts).\n+\u0415\u0441\u043b\u0438 \u0438\u043c\u044f \u043a\u0443\u0441\u043a\u0430 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c `NULL`. \u0422\u0430\u043a\u0438\u0435 \u043a\u0443\u0441\u043a\u0438 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0443\u0434\u0430\u043b\u0435\u043d\u044b \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e [ALTER TABLE DROP DETACHED PART](../query_language/query_language/alter/#alter_drop-detached).\n+\n ## system.dictionaries\n \n \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0432\u043d\u0435\u0448\u043d\u0438\u0445 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\u0445.\ndiff --git a/docs/ru/query_language/alter.md b/docs/ru/query_language/alter.md\nindex a172134fd165..0ca77408cf66 100644\n--- a/docs/ru/query_language/alter.md\n+++ b/docs/ru/query_language/alter.md\n@@ -210,6 +210,15 @@ ALTER TABLE table_name DROP PARTITION partition_expr\n \n \u0417\u0430\u043f\u0440\u043e\u0441 \u0440\u0435\u043f\u043b\u0438\u0446\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u2014 \u0434\u0430\u043d\u043d\u044b\u0435 \u0431\u0443\u0434\u0443\u0442 \u0443\u0434\u0430\u043b\u0435\u043d\u044b \u043d\u0430 \u0432\u0441\u0435\u0445 \u0440\u0435\u043f\u043b\u0438\u043a\u0430\u0445.\n \n+#### DROP DETACHED PARTITION|PART {#alter_drop-detached}\n+\n+```sql\n+ALTER TABLE table_name DROP DETACHED PARTITION|PART partition_expr\n+```\n+\n+\u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0438\u0437 `detached` \u043a\u0443\u0441\u043e\u043a \u0438\u043b\u0438 \u0432\u0441\u0435 \u043a\u0443\u0441\u043a\u0438, \u043f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0430\u0449\u0438\u0435 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438.\n+\u041f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u043e \u0442\u043e\u043c, \u043a\u0430\u043a \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u0437\u0430\u0434\u0430\u0442\u044c \u0438\u043c\u044f \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438, \u0441\u043c. \u0432 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 [\u041a\u0430\u043a \u0437\u0430\u0434\u0430\u0432\u0430\u0442\u044c \u0438\u043c\u044f \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u0445 ALTER](#alter-how-to-specify-part-expr).\n+\n #### ATTACH PARTITION|PART {#alter_attach-partition}\n \n ```sql\n@@ -337,7 +346,7 @@ ALTER TABLE users ATTACH PARTITION 201902;\n - \u0418\u043c\u044f \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438. \u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0438\u043c\u044f \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u043c\u043e\u0436\u043d\u043e \u0432 \u0441\u0442\u043e\u043b\u0431\u0446\u0435 `partition` \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b [system.parts](../operations/system_tables.md#system_tables-parts). \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, `ALTER TABLE visits DETACH PARTITION 201901`.\n - \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b. \u0422\u0430\u043a\u0436\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b \u0438 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u044b\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, `ALTER TABLE visits DETACH PARTITION toYYYYMM(toDate('2019-01-25'))`.\n - \u0421\u0442\u0440\u043e\u043a\u043e\u0432\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438. \u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u0443\u0441\u043a\u043e\u0432 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u043d\u0430 \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0438 \u0432 ZooKeeper. \u0412 \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u0445 `ALTER` \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u043d\u0443\u0436\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0432 \u0441\u0435\u043a\u0446\u0438\u0438 `PARTITION ID`, \u0432 \u043e\u0434\u0438\u043d\u0430\u0440\u043d\u044b\u0445 \u043a\u0430\u0432\u044b\u0447\u043a\u0430\u0445. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, `ALTER TABLE visits DETACH PARTITION ID '201901'`.\n-- \u0414\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 [ATTACH PART](#alter_attach-partition): \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0434\u0430\u0442\u044c \u0438\u043c\u044f \u043a\u0443\u0441\u043a\u0430 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438\u0437 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 `name` \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b `system.parts`. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, `ALTER TABLE visits ATTACH PART 201901_1_1_0`.\n+- \u0414\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 [ATTACH PART](#alter_attach-partition) \u0438 [DROP DETACHED PART](#alter_drop-detached): \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0434\u0430\u0442\u044c \u0438\u043c\u044f \u043a\u0443\u0441\u043a\u0430 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u043e\u0439 \u043b\u0438\u0442\u0435\u0440\u0430\u043b \u0441\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c \u0438\u0437 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 `name` \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b [system.detached_parts](../operations/system_tables.md#system_tables-detached_parts). \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, `ALTER TABLE visits ATTACH PART '201901_1_1_0'`.\n \n \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u0430\u0432\u044b\u0447\u0435\u043a \u0432 \u0438\u043c\u0435\u043d\u0438 \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0439 \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u0431\u0446\u0430, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0437\u0430\u0434\u0430\u043d\u043e \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u043e\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u043b\u044f \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u0441 \u0442\u0438\u043f\u043e\u043c `String` \u0438\u043c\u044f \u043f\u0430\u0440\u0442\u0438\u0446\u0438\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0432 \u043a\u0430\u0432\u044b\u0447\u043a\u0430\u0445 (\u043e\u0434\u0438\u043d\u0430\u0440\u043d\u044b\u0445). \u0414\u043b\u044f \u0442\u0438\u043f\u043e\u0432 `Date` \u0438 `Int*` \u043a\u0430\u0432\u044b\u0447\u043a\u0438 \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043d\u0435 \u043d\u0443\u0436\u043d\u043e.\n \n",
  "test_patch": "diff --git a/dbms/tests/integration/test_partition/__init__.py b/dbms/tests/integration/test_partition/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/integration/test_partition/test.py b/dbms/tests/integration/test_partition/test.py\nnew file mode 100644\nindex 000000000000..3365343b6fbf\n--- /dev/null\n+++ b/dbms/tests/integration/test_partition/test.py\n@@ -0,0 +1,244 @@\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+from helpers.test_tools import TSV\n+\n+\n+cluster = ClickHouseCluster(__file__)\n+instance = cluster.add_instance('instance')\n+q = instance.query\n+path_to_data = '/var/lib/clickhouse/'\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        q('CREATE DATABASE test')\n+\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+@pytest.fixture\n+def partition_table_simple(started_cluster):\n+    q(\"DROP TABLE IF EXISTS test.partition\")\n+    q(\"CREATE TABLE test.partition (date MATERIALIZED toDate(0), x UInt64, sample_key MATERIALIZED intHash64(x)) \"\n+      \"ENGINE=MergeTree PARTITION BY date SAMPLE BY sample_key ORDER BY (date,x,sample_key) \"\n+      \"SETTINGS index_granularity=8192, index_granularity_bytes=0\")\n+    q(\"INSERT INTO test.partition ( x ) VALUES ( now() )\")\n+    q(\"INSERT INTO test.partition ( x ) VALUES ( now()+1 )\")\n+\n+    yield\n+\n+    q('DROP TABLE test.partition')\n+\n+\n+def test_partition_simple(partition_table_simple):\n+    q(\"ALTER TABLE test.partition DETACH PARTITION 197001\")\n+    q(\"ALTER TABLE test.partition ATTACH PARTITION 197001\")\n+    q(\"OPTIMIZE TABLE test.partition\")\n+\n+\n+def exec_bash(cmd):\n+    cmd = '/bin/bash -c \"{}\"'.format(cmd.replace('\"', '\\\\\"'))\n+    return instance.exec_in_container(cmd)\n+\n+\n+def partition_complex_assert_columns_txt():\n+    path_to_parts = path_to_data + 'data/test/partition/'\n+    parts = TSV(q(\"SELECT name FROM system.parts WHERE database='test' AND table='partition'\"))\n+    for part_name in parts.lines:\n+        path_to_columns = path_to_parts + part_name + '/columns.txt'\n+        # 2 header lines + 3 columns\n+        assert exec_bash('cat {} | wc -l'.format(path_to_columns)) == u'5\\n'\n+\n+\n+def partition_complex_assert_checksums():\n+    # Do `cd` for consistent output for reference\n+    # Do not check increment.txt - it can be changed by other tests with FREEZE\n+    cmd = 'cd ' + path_to_data + \" && find shadow -type f -exec md5sum {} \\\\;\" \\\n+                                 \"  | grep partition\" \\\n+                                 \"  | sed 's!shadow/[0-9]*/data/[a-z0-9_-]*/!shadow/1/data/test/!g'\" \\\n+                                 \"  | sort\" \\\n+                                 \"  | uniq\"\n+\n+    checksums = \"082814b5aa5109160d5c0c5aff10d4df\\tshadow/1/data/test/partition/19700102_2_2_0/k.bin\\n\" \\\n+                \"082814b5aa5109160d5c0c5aff10d4df\\tshadow/1/data/test/partition/19700201_1_1_0/v1.bin\\n\" \\\n+                \"13cae8e658e0ca4f75c56b1fc424e150\\tshadow/1/data/test/partition/19700102_2_2_0/minmax_p.idx\\n\" \\\n+                \"25daad3d9e60b45043a70c4ab7d3b1c6\\tshadow/1/data/test/partition/19700102_2_2_0/partition.dat\\n\" \\\n+                \"3726312af62aec86b64a7708d5751787\\tshadow/1/data/test/partition/19700201_1_1_0/partition.dat\\n\" \\\n+                \"37855b06a39b79a67ea4e86e4a3299aa\\tshadow/1/data/test/partition/19700102_2_2_0/checksums.txt\\n\" \\\n+                \"38e62ff37e1e5064e9a3f605dfe09d13\\tshadow/1/data/test/partition/19700102_2_2_0/v1.bin\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700102_2_2_0/k.mrk\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700102_2_2_0/p.mrk\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700102_2_2_0/v1.mrk\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700201_1_1_0/k.mrk\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700201_1_1_0/p.mrk\\n\" \\\n+                \"4ae71336e44bf9bf79d2752e234818a5\\tshadow/1/data/test/partition/19700201_1_1_0/v1.mrk\\n\" \\\n+                \"55a54008ad1ba589aa210d2629c1df41\\tshadow/1/data/test/partition/19700201_1_1_0/primary.idx\\n\" \\\n+                \"5f087cb3e7071bf9407e095821e2af8f\\tshadow/1/data/test/partition/19700201_1_1_0/checksums.txt\\n\" \\\n+                \"77d5af402ada101574f4da114f242e02\\tshadow/1/data/test/partition/19700102_2_2_0/columns.txt\\n\" \\\n+                \"77d5af402ada101574f4da114f242e02\\tshadow/1/data/test/partition/19700201_1_1_0/columns.txt\\n\" \\\n+                \"88cdc31ded355e7572d68d8cde525d3a\\tshadow/1/data/test/partition/19700201_1_1_0/p.bin\\n\" \\\n+                \"9e688c58a5487b8eaf69c9e1005ad0bf\\tshadow/1/data/test/partition/19700102_2_2_0/primary.idx\\n\" \\\n+                \"c4ca4238a0b923820dcc509a6f75849b\\tshadow/1/data/test/partition/19700102_2_2_0/count.txt\\n\" \\\n+                \"c4ca4238a0b923820dcc509a6f75849b\\tshadow/1/data/test/partition/19700201_1_1_0/count.txt\\n\" \\\n+                \"cfcb770c3ecd0990dcceb1bde129e6c6\\tshadow/1/data/test/partition/19700102_2_2_0/p.bin\\n\" \\\n+                \"e2af3bef1fd129aea73a890ede1e7a30\\tshadow/1/data/test/partition/19700201_1_1_0/k.bin\\n\" \\\n+                \"f2312862cc01adf34a93151377be2ddf\\tshadow/1/data/test/partition/19700201_1_1_0/minmax_p.idx\\n\"\n+\n+    assert TSV(exec_bash(cmd).replace('  ', '\\t')) == TSV(checksums)\n+\n+\n+@pytest.fixture\n+def partition_table_complex(started_cluster):\n+    q(\"DROP TABLE IF EXISTS test.partition\")\n+    q(\"CREATE TABLE test.partition (p Date, k Int8, v1 Int8 MATERIALIZED k + 1) \"\n+      \"ENGINE = MergeTree PARTITION BY p ORDER BY k SETTINGS index_granularity=1, index_granularity_bytes=0\")\n+    q(\"INSERT INTO test.partition (p, k) VALUES(toDate(31), 1)\")\n+    q(\"INSERT INTO test.partition (p, k) VALUES(toDate(1), 2)\")\n+\n+    yield\n+\n+    q(\"DROP TABLE test.partition\")\n+\n+\n+def test_partition_complex(partition_table_complex):\n+\n+    partition_complex_assert_columns_txt()\n+\n+    q(\"ALTER TABLE test.partition FREEZE\")\n+\n+    partition_complex_assert_checksums()\n+\n+    q(\"ALTER TABLE test.partition DETACH PARTITION 197001\")\n+    q(\"ALTER TABLE test.partition ATTACH PARTITION 197001\")\n+\n+    partition_complex_assert_columns_txt()\n+\n+    q(\"ALTER TABLE test.partition MODIFY COLUMN v1 Int8\")\n+\n+    # Check the backup hasn't changed\n+    partition_complex_assert_checksums()\n+\n+    q(\"OPTIMIZE TABLE test.partition\")\n+\n+    expected = TSV('31\\t1\\t2\\n'\n+                   '1\\t2\\t3')\n+    res = q(\"SELECT toUInt16(p), k, v1 FROM test.partition ORDER BY k\")\n+    assert(TSV(res) == expected)\n+\n+\n+@pytest.fixture\n+def cannot_attach_active_part_table(started_cluster):\n+    q(\"DROP TABLE IF EXISTS test.attach_active\")\n+    q(\"CREATE TABLE test.attach_active (n UInt64) ENGINE = MergeTree() PARTITION BY intDiv(n, 4) ORDER BY n\")\n+    q(\"INSERT INTO test.attach_active SELECT number FROM system.numbers LIMIT 16\")\n+\n+    yield\n+\n+    q(\"DROP TABLE test.attach_active\")\n+\n+\n+def test_cannot_attach_active_part(cannot_attach_active_part_table):\n+    error = instance.client.query_and_get_error(\"ALTER TABLE test.attach_active ATTACH PART '../1_2_2_0'\")\n+    print error\n+    assert 0 <= error.find('Invalid part name')\n+\n+    res = q(\"SElECT name FROM system.parts WHERE table='attach_active' AND database='test' ORDER BY name\")\n+    assert TSV(res) == TSV('0_1_1_0\\n1_2_2_0\\n2_3_3_0\\n3_4_4_0')\n+    assert TSV(q(\"SElECT count(), sum(n) FROM test.attach_active\")) == TSV('16\\t120')\n+\n+\n+@pytest.fixture\n+def attach_check_all_parts_table(started_cluster):\n+    q(\"SYSTEM STOP MERGES\")\n+    q(\"DROP TABLE IF EXISTS test.attach_partition\")\n+    q(\"CREATE TABLE test.attach_partition (n UInt64) ENGINE = MergeTree() PARTITION BY intDiv(n, 8) ORDER BY n\")\n+    q(\"INSERT INTO test.attach_partition SELECT number FROM system.numbers WHERE number % 2 = 0 LIMIT 8\")\n+    q(\"INSERT INTO test.attach_partition SELECT number FROM system.numbers WHERE number % 2 = 1 LIMIT 8\")\n+\n+    yield\n+\n+    q(\"DROP TABLE test.attach_partition\")\n+    q(\"SYSTEM START MERGES\")\n+\n+\n+def test_attach_check_all_parts(attach_check_all_parts_table):\n+    q(\"ALTER TABLE test.attach_partition DETACH PARTITION 0\")\n+\n+    path_to_detached = path_to_data + 'data/test/attach_partition/detached/'\n+    exec_bash('mkdir {}'.format(path_to_detached + '0_5_5_0'))\n+    exec_bash('cp -pr {} {}'.format(path_to_detached + '0_1_1_0', path_to_detached + 'attaching_0_6_6_0'))\n+    exec_bash('cp -pr {} {}'.format(path_to_detached + '0_3_3_0', path_to_detached +  'deleting_0_7_7_0'))\n+\n+    error = instance.client.query_and_get_error(\"ALTER TABLE test.attach_partition ATTACH PARTITION 0\")\n+    assert 0 <= error.find('No columns in part 0_5_5_0')\n+\n+    parts = q(\"SElECT name FROM system.parts WHERE table='attach_partition' AND database='test' ORDER BY name\")\n+    assert TSV(parts) == TSV('1_2_2_0\\n1_4_4_0')\n+    detached = q(\"SELECT name FROM system.detached_parts \"\n+                 \"WHERE table='attach_partition' AND database='test' ORDER BY name\")\n+    assert TSV(detached) == TSV('0_1_1_0\\n0_3_3_0\\n0_5_5_0\\nattaching_0_6_6_0\\ndeleting_0_7_7_0')\n+\n+    exec_bash('rm -r {}'.format(path_to_detached + '0_5_5_0'))\n+\n+    q(\"ALTER TABLE test.attach_partition ATTACH PARTITION 0\")\n+    parts = q(\"SElECT name FROM system.parts WHERE table='attach_partition' AND database='test' ORDER BY name\")\n+    expected = '0_5_5_0\\n0_6_6_0\\n1_2_2_0\\n1_4_4_0'\n+    assert TSV(parts) == TSV(expected)\n+    assert TSV(q(\"SElECT count(), sum(n) FROM test.attach_partition\")) == TSV('16\\t120')\n+\n+    detached = q(\"SELECT name FROM system.detached_parts \"\n+                 \"WHERE table='attach_partition' AND database='test' ORDER BY name\")\n+    assert TSV(detached) == TSV('attaching_0_6_6_0\\ndeleting_0_7_7_0')\n+\n+\n+@pytest.fixture\n+def drop_detached_parts_table(started_cluster):\n+    q(\"SYSTEM STOP MERGES\")\n+    q(\"DROP TABLE IF EXISTS test.drop_detached\")\n+    q(\"CREATE TABLE test.drop_detached (n UInt64) ENGINE = MergeTree() PARTITION BY intDiv(n, 8) ORDER BY n\")\n+    q(\"INSERT INTO test.drop_detached SELECT number FROM system.numbers WHERE number % 2 = 0 LIMIT 8\")\n+    q(\"INSERT INTO test.drop_detached SELECT number FROM system.numbers WHERE number % 2 = 1 LIMIT 8\")\n+\n+    yield\n+\n+    q(\"DROP TABLE test.drop_detached\")\n+    q(\"SYSTEM START MERGES\")\n+\n+\n+def test_drop_detached_parts(drop_detached_parts_table):\n+    s = {\"allow_drop_detached\": 1}\n+    q(\"ALTER TABLE test.drop_detached DETACH PARTITION 0\")\n+    q(\"ALTER TABLE test.drop_detached DETACH PARTITION 1\")\n+\n+    path_to_detached = path_to_data + 'data/test/drop_detached/detached/'\n+    exec_bash('mkdir {}'.format(path_to_detached + 'attaching_0_6_6_0'))\n+    exec_bash('mkdir {}'.format(path_to_detached + 'deleting_0_7_7_0'))\n+    exec_bash('mkdir {}'.format(path_to_detached + 'any_other_name'))\n+    exec_bash('mkdir {}'.format(path_to_detached + 'prefix_1_2_2_0_0'))\n+\n+    error = instance.client.query_and_get_error(\"ALTER TABLE test.drop_detached DROP DETACHED PART '../1_2_2_0'\", settings=s)\n+    assert 0 <= error.find('Invalid part name')\n+\n+    q(\"ALTER TABLE test.drop_detached DROP DETACHED PART '0_1_1_0'\", settings=s)\n+\n+    error = instance.client.query_and_get_error(\"ALTER TABLE test.drop_detached DROP DETACHED PART 'attaching_0_6_6_0'\", settings=s)\n+    assert 0 <= error.find('Cannot drop part')\n+\n+    error = instance.client.query_and_get_error(\"ALTER TABLE test.drop_detached DROP DETACHED PART 'deleting_0_7_7_0'\", settings=s)\n+    assert 0 <= error.find('Cannot drop part')\n+\n+    q(\"ALTER TABLE test.drop_detached DROP DETACHED PART 'any_other_name'\", settings=s)\n+\n+    detached = q(\"SElECT name FROM system.detached_parts WHERE table='drop_detached' AND database='test' ORDER BY name\")\n+    assert TSV(detached) == TSV('0_3_3_0\\n1_2_2_0\\n1_4_4_0\\nattaching_0_6_6_0\\ndeleting_0_7_7_0\\nprefix_1_2_2_0_0')\n+\n+    q(\"ALTER TABLE test.drop_detached DROP DETACHED PARTITION 1\", settings=s)\n+    detached = q(\"SElECT name FROM system.detached_parts WHERE table='drop_detached' AND database='test' ORDER BY name\")\n+    assert TSV(detached) == TSV('0_3_3_0\\nattaching_0_6_6_0\\ndeleting_0_7_7_0')\n+\ndiff --git a/dbms/tests/queries/0_stateless/00428_partition.reference b/dbms/tests/queries/0_stateless/00428_partition.reference\ndeleted file mode 100644\nindex c777fd7a5c30..000000000000\n--- a/dbms/tests/queries/0_stateless/00428_partition.reference\n+++ /dev/null\n@@ -1,54 +0,0 @@\n-5\n-5\n-082814b5aa5109160d5c0c5aff10d4df  shadow/1/data/test/partition_428/19700102_2_2_0/k.bin\n-082814b5aa5109160d5c0c5aff10d4df  shadow/1/data/test/partition_428/19700201_1_1_0/v1.bin\n-13cae8e658e0ca4f75c56b1fc424e150  shadow/1/data/test/partition_428/19700102_2_2_0/minmax_p.idx\n-25daad3d9e60b45043a70c4ab7d3b1c6  shadow/1/data/test/partition_428/19700102_2_2_0/partition.dat\n-3726312af62aec86b64a7708d5751787  shadow/1/data/test/partition_428/19700201_1_1_0/partition.dat\n-37855b06a39b79a67ea4e86e4a3299aa  shadow/1/data/test/partition_428/19700102_2_2_0/checksums.txt\n-38e62ff37e1e5064e9a3f605dfe09d13  shadow/1/data/test/partition_428/19700102_2_2_0/v1.bin\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/k.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/p.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/v1.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/k.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/p.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/v1.mrk\n-55a54008ad1ba589aa210d2629c1df41  shadow/1/data/test/partition_428/19700201_1_1_0/primary.idx\n-5f087cb3e7071bf9407e095821e2af8f  shadow/1/data/test/partition_428/19700201_1_1_0/checksums.txt\n-77d5af402ada101574f4da114f242e02  shadow/1/data/test/partition_428/19700102_2_2_0/columns.txt\n-77d5af402ada101574f4da114f242e02  shadow/1/data/test/partition_428/19700201_1_1_0/columns.txt\n-88cdc31ded355e7572d68d8cde525d3a  shadow/1/data/test/partition_428/19700201_1_1_0/p.bin\n-9e688c58a5487b8eaf69c9e1005ad0bf  shadow/1/data/test/partition_428/19700102_2_2_0/primary.idx\n-c4ca4238a0b923820dcc509a6f75849b  shadow/1/data/test/partition_428/19700102_2_2_0/count.txt\n-c4ca4238a0b923820dcc509a6f75849b  shadow/1/data/test/partition_428/19700201_1_1_0/count.txt\n-cfcb770c3ecd0990dcceb1bde129e6c6  shadow/1/data/test/partition_428/19700102_2_2_0/p.bin\n-e2af3bef1fd129aea73a890ede1e7a30  shadow/1/data/test/partition_428/19700201_1_1_0/k.bin\n-f2312862cc01adf34a93151377be2ddf  shadow/1/data/test/partition_428/19700201_1_1_0/minmax_p.idx\n-5\n-5\n-082814b5aa5109160d5c0c5aff10d4df  shadow/1/data/test/partition_428/19700102_2_2_0/k.bin\n-082814b5aa5109160d5c0c5aff10d4df  shadow/1/data/test/partition_428/19700201_1_1_0/v1.bin\n-13cae8e658e0ca4f75c56b1fc424e150  shadow/1/data/test/partition_428/19700102_2_2_0/minmax_p.idx\n-25daad3d9e60b45043a70c4ab7d3b1c6  shadow/1/data/test/partition_428/19700102_2_2_0/partition.dat\n-3726312af62aec86b64a7708d5751787  shadow/1/data/test/partition_428/19700201_1_1_0/partition.dat\n-37855b06a39b79a67ea4e86e4a3299aa  shadow/1/data/test/partition_428/19700102_2_2_0/checksums.txt\n-38e62ff37e1e5064e9a3f605dfe09d13  shadow/1/data/test/partition_428/19700102_2_2_0/v1.bin\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/k.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/p.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700102_2_2_0/v1.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/k.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/p.mrk\n-4ae71336e44bf9bf79d2752e234818a5  shadow/1/data/test/partition_428/19700201_1_1_0/v1.mrk\n-55a54008ad1ba589aa210d2629c1df41  shadow/1/data/test/partition_428/19700201_1_1_0/primary.idx\n-5f087cb3e7071bf9407e095821e2af8f  shadow/1/data/test/partition_428/19700201_1_1_0/checksums.txt\n-77d5af402ada101574f4da114f242e02  shadow/1/data/test/partition_428/19700102_2_2_0/columns.txt\n-77d5af402ada101574f4da114f242e02  shadow/1/data/test/partition_428/19700201_1_1_0/columns.txt\n-88cdc31ded355e7572d68d8cde525d3a  shadow/1/data/test/partition_428/19700201_1_1_0/p.bin\n-9e688c58a5487b8eaf69c9e1005ad0bf  shadow/1/data/test/partition_428/19700102_2_2_0/primary.idx\n-c4ca4238a0b923820dcc509a6f75849b  shadow/1/data/test/partition_428/19700102_2_2_0/count.txt\n-c4ca4238a0b923820dcc509a6f75849b  shadow/1/data/test/partition_428/19700201_1_1_0/count.txt\n-cfcb770c3ecd0990dcceb1bde129e6c6  shadow/1/data/test/partition_428/19700102_2_2_0/p.bin\n-e2af3bef1fd129aea73a890ede1e7a30  shadow/1/data/test/partition_428/19700201_1_1_0/k.bin\n-f2312862cc01adf34a93151377be2ddf  shadow/1/data/test/partition_428/19700201_1_1_0/minmax_p.idx\n-31,1,2\n-1,2,3\ndiff --git a/dbms/tests/queries/0_stateless/00428_partition.sh b/dbms/tests/queries/0_stateless/00428_partition.sh\ndeleted file mode 100755\nindex 033d5e24c135..000000000000\n--- a/dbms/tests/queries/0_stateless/00428_partition.sh\n+++ /dev/null\n@@ -1,60 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -e\n-\n-CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n-. $CURDIR/../shell_config.sh\n-\n-# Not found column date in block. There are only columns: x.\n-\n-# Test 1. Complex test checking columns.txt\n-\n-chl=\"$CLICKHOUSE_CLIENT -q\"\n-ch_dir=`${CLICKHOUSE_EXTRACT_CONFIG} -k path`\n-\n-$chl \"DROP TABLE IF EXISTS test.partition_428\"\n-$chl \"CREATE TABLE test.partition_428 (p Date, k Int8, v1 Int8 MATERIALIZED k + 1) ENGINE = MergeTree PARTITION BY p ORDER BY k SETTINGS index_granularity=1, index_granularity_bytes=0\"\n-$chl \"INSERT INTO test.partition_428 (p, k) VALUES(toDate(31), 1)\"\n-$chl \"INSERT INTO test.partition_428 (p, k) VALUES(toDate(1), 2)\"\n-\n-for part in `$chl \"SELECT name FROM system.parts WHERE database='test' AND table='partition_428'\"`; do\n-    # 2 header lines + 3 columns\n-    (sudo -n cat $ch_dir/data/test/partition_428/$part/columns.txt 2>/dev/null || \\\n-             cat $ch_dir/data/test/partition_428/$part/columns.txt) | wc -l\n-done\n-\n-$chl \"ALTER TABLE test.partition_428 FREEZE\"\n-\n-# Do `cd` for consistent output for reference\n-# Do not check increment.txt - it can be changed by other tests with FREEZE\n-cd $ch_dir && find shadow -type f -exec md5sum {} \\; | grep \"partition_428\" | sed 's!shadow/[0-9]*/data/[a-z0-9_-]*/!shadow/1/data/test/!g' | sort | uniq\n-\n-$chl \"ALTER TABLE test.partition_428 DETACH PARTITION 197001\"\n-$chl \"ALTER TABLE test.partition_428 ATTACH PARTITION 197001\"\n-\n-for part in `$chl \"SELECT name FROM system.parts WHERE database='test' AND table='partition_428'\"`; do\n-    # 2 header lines + 3 columns\n-    (sudo -n cat $ch_dir/data/test/partition_428/$part/columns.txt 2>/dev/null || \\\n-             cat $ch_dir/data/test/partition_428/$part/columns.txt) | wc -l\n-done\n-\n-$chl \"ALTER TABLE test.partition_428 MODIFY COLUMN v1 Int8\"\n-\n-# Check the backup hasn't changed\n-cd $ch_dir && find shadow -type f -exec md5sum {} \\; | grep \"partition_428\" | sed 's!shadow/[0-9]*/data/[a-z0-9_-]*/!shadow/1/data/test/!g' | sort | uniq\n-\n-$chl \"OPTIMIZE TABLE test.partition_428\"\n-\n-$chl \"SELECT toUInt16(p), k, v1 FROM test.partition_428 ORDER BY k FORMAT CSV\"\n-$chl \"DROP TABLE test.partition_428\"\n-\n-# Test 2. Simple test\n-\n-$chl \"drop table if exists test.partition_428\"\n-$chl \"create table test.partition_428 (date MATERIALIZED toDate(0), x UInt64, sample_key MATERIALIZED intHash64(x)) ENGINE=MergeTree PARTITION BY date SAMPLE BY sample_key ORDER BY (date,x,sample_key) SETTINGS index_granularity=8192, index_granularity_bytes=0\"\n-$chl \"insert into test.partition_428 ( x ) VALUES ( now() )\"\n-$chl \"insert into test.partition_428 ( x ) VALUES ( now()+1 )\"\n-$chl \"alter table test.partition_428 detach partition 197001\"\n-$chl \"alter table test.partition_428 attach partition 197001\"\n-$chl \"optimize table test.partition_428\"\n-$chl \"drop table test.partition_428\"\n",
  "problem_statement": "ALTER TABLE DROP DETACHED PART\n\n",
  "hints_text": "And a setting to enable this query, disabled by default.\r\n\r\nUse case: in cloud providers the user has no access to filesystem and has no way to deal with detached parts.\nIt will allow to remove arbitrary directory inside `detached` by its name. But be careful - name must not contain path components (example: `../../../../../data`).",
  "created_at": "2019-07-25T16:45:01Z",
  "modified_files": [
    "dbms/src/Core/Settings.h",
    "dbms/src/Interpreters/InterpreterAlterQuery.cpp",
    "dbms/src/Parsers/ASTAlterQuery.cpp",
    "dbms/src/Parsers/ASTAlterQuery.h",
    "dbms/src/Parsers/ParserAlterQuery.cpp",
    "dbms/src/Storages/MergeTree/MergeTreeData.cpp",
    "dbms/src/Storages/MergeTree/MergeTreeData.h",
    "dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp",
    "dbms/src/Storages/MergeTree/MergeTreePartInfo.cpp",
    "dbms/src/Storages/MergeTree/MergeTreePartInfo.h",
    "dbms/src/Storages/PartitionCommands.cpp",
    "dbms/src/Storages/PartitionCommands.h",
    "dbms/src/Storages/StorageMergeTree.cpp",
    "dbms/src/Storages/StorageReplicatedMergeTree.cpp",
    "dbms/src/Storages/System/StorageSystemDetachedParts.cpp",
    "docs/en/operations/system_tables.md",
    "docs/en/query_language/alter.md",
    "docs/ru/operations/system_tables.md",
    "docs/ru/query_language/alter.md"
  ],
  "modified_test_files": [
    "b/dbms/tests/integration/test_partition/test.py",
    "dbms/tests/queries/0_stateless/00428_partition.reference",
    "dbms/tests/queries/0_stateless/00428_partition.sh"
  ]
}