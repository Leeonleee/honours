diff --git a/docs/en/operations/system-tables/zookeeper.md b/docs/en/operations/system-tables/zookeeper.md
index 059f99001752..8f16e5dcfe8f 100644
--- a/docs/en/operations/system-tables/zookeeper.md
+++ b/docs/en/operations/system-tables/zookeeper.md
@@ -8,8 +8,8 @@ title: 'system.zookeeper'
 
 # system.zookeeper
 
-The table does not exist unless ClickHouse Keeper or ZooKeeper is configured. The `system.zookeeper` table exposes data from the Keeper cluster defined in the config.
-The query must either have a 'path ='   condition or a `path IN`  condition set with the `WHERE` clause as shown below. This corresponds to the path of the children that you want to get data for.
+The table does not exist unless ClickHouse Keeper or ZooKeeper is configured. The `system.zookeeper` table exposes data from the Keeper clusters defined in the config.
+The query must either have a `path =`   condition or a `path IN`  condition set with the `WHERE` clause as shown below. This corresponds to the path of the children that you want to get data for.
 
 The query `SELECT * FROM system.zookeeper WHERE path = '/clickhouse'` outputs data for all children on the `/clickhouse` node.
 To output data for all root nodes, write path = '/'.
@@ -19,11 +19,15 @@ The query `SELECT * FROM system.zookeeper WHERE path IN ('/', '/clickhouse')` ou
 If in the specified 'path' collection has does not exist path, an exception will be thrown.
 It can be used to do a batch of Keeper path queries.
 
+The query `SELECT * FROM system.zookeeper WHERE path = '/clickhouse' AND zookeeperName = 'auxiliary_cluster'` outputs data in `auxiliary_cluster` ZooKeeper cluster.
+If the specified 'auxiliary_cluster' does not exists, an exception will be thrown.
+
 Columns:
 
 - `name` (String) — The name of the node.
 - `path` (String) — The path to the node.
 - `value` (String) — Node value.
+- `zookeeperName` (String) — The name of default or one of auxiliary ZooKeeper cluster.
 - `dataLength` (Int32) — Size of the value.
 - `numChildren` (Int32) — Number of descendants.
 - `czxid` (Int64) — ID of the transaction that created the node.
diff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp
index 0c8f23662e3d..37a01d951842 100644
--- a/src/Storages/System/StorageSystemZooKeeper.cpp
+++ b/src/Storages/System/StorageSystemZooKeeper.cpp
@@ -11,6 +11,7 @@
 #include <Interpreters/Context.h>
 #include <Interpreters/ProcessList.h>
 #include <Interpreters/evaluateConstantExpression.h>
+#include <Common/Exception.h>
 #include <Common/ZooKeeper/ZooKeeper.h>
 #include <Common/ZooKeeper/ZooKeeperRetries.h>
 #include <Common/ZooKeeper/ZooKeeperWithFaultInjection.h>
@@ -217,6 +218,7 @@ class ReadFromSystemZooKeeper final : public SourceStepWithFilter
 private:
     std::shared_ptr<const StorageLimitsList> storage_limits;
     const UInt64 max_block_size;
+    String name;
     Paths paths;
 };
 
@@ -225,12 +227,14 @@ class SystemZooKeeperSource : public ISource
 {
 public:
     SystemZooKeeperSource(
+        String && zookeeper_name_,
         Paths && paths_,
         Block header_,
         UInt64 max_block_size_,
         ContextPtr context_)
         : ISource(header_)
         , max_block_size(max_block_size_)
+        , name(std::move(zookeeper_name_))
         , paths(std::move(paths_))
         , context(std::move(context_))
     {
@@ -243,9 +247,10 @@ class SystemZooKeeperSource : public ISource
 
 private:
     const UInt64 max_block_size;
+    String name;
     Paths paths;
     ContextPtr context;
-    ZooKeeperWithFaultInjection::Ptr zookeeper;
+    std::map<String, ZooKeeperWithFaultInjection::Ptr> zookeepers;
     bool started = false;
     std::unordered_set<String> visited;
 };
@@ -294,6 +299,7 @@ ColumnsDescription StorageSystemZooKeeper::getColumnsDescription()
     {
         {"name",           std::make_shared<DataTypeString>(), "The name of the node."},
         {"value",          std::make_shared<DataTypeString>(), "Node value."},
+        {"zookeeperName",  std::make_shared<DataTypeString>(), "The name of default or one of auxiliary ZooKeeper cluster."},
         {"czxid",          std::make_shared<DataTypeInt64>(), "ID of the transaction that created the node."},
         {"mzxid",          std::make_shared<DataTypeInt64>(), "ID of the transaction that last changed the node."},
         {"ctime",          std::make_shared<DataTypeDateTime>(), "Time of node creation."},
@@ -335,6 +341,14 @@ static String pathCorrected(const String & path)
     return path_corrected;
 }
 
+static bool isNameNode(const ActionsDAG::Node * node)
+{
+    while (node->type == ActionsDAG::ActionType::ALIAS)
+        node = node->children.at(0);
+
+    return node->result_name == "zookeeperName";
+}
+
 static bool isPathNode(const ActionsDAG::Node * node)
 {
     while (node->type == ActionsDAG::ActionType::ALIAS)
@@ -343,6 +357,51 @@ static bool isPathNode(const ActionsDAG::Node * node)
     return node->result_name == "path";
 }
 
+static void extractNameImpl(const ActionsDAG::Node & node, String & res, ContextPtr context)
+{
+    /// Only one name is allowed
+    if (!res.empty())
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                        "SELECT from system.zookeeper table cannot have multiple different filters by zookeeperName.");
+
+    if (node.type != ActionsDAG::ActionType::FUNCTION)
+        return;
+
+    auto function_name = node.function_base->getName();
+    if (function_name == "and")
+    {
+        for (const auto * child : node.children)
+            extractNameImpl(*child, res, context);
+
+        return;
+    }
+
+    if (node.children.size() != 2)
+        return;
+
+    if (function_name == "equals")
+    {
+        const ActionsDAG::Node * value = nullptr;
+
+        if (isNameNode(node.children.at(0)))
+            value = node.children.at(1);
+        else if (isNameNode(node.children.at(1)))
+            value = node.children.at(0);
+
+        if (!value || !value->column)
+            return;
+
+        if (!isString(removeNullable(removeLowCardinality(value->result_type))))
+            return;
+
+        if (value->column->size() != 1)
+            return;
+
+        /// Only inserted if the key doesn't exists already
+        res = value->column->getDataAt(0).toString();
+    }
+}
+
 static void extractPathImpl(const ActionsDAG::Node & node, Paths & res, ContextPtr context, bool allow_unrestricted)
 {
     if (node.type != ActionsDAG::ActionType::FUNCTION)
@@ -465,6 +524,20 @@ static void extractPathImpl(const ActionsDAG::Node & node, Paths & res, ContextP
     }
 }
 
+/** Retrieve from the query a condition of the form `zookeeperName = 'name`, from conjunctions in the WHERE clause.
+  */
+static String extractName(const ActionsDAG::NodeRawConstPtrs & filter_nodes, ContextPtr context)
+{
+    String res;
+    for (const auto * node : filter_nodes)
+        extractNameImpl(*node, res, context);
+
+    if (res.empty())
+        return {String(zkutil::DEFAULT_ZOOKEEPER_NAME)};
+
+    return res;
+}
+
 
 /** Retrieve from the query a condition of the form `path = 'path'`, from conjunctions in the WHERE clause.
   */
@@ -494,12 +567,19 @@ void ReadFromSystemZooKeeper::applyFilters(ActionDAGNodes added_filter_nodes)
 {
     SourceStepWithFilter::applyFilters(added_filter_nodes);
 
+    name = extractName(added_filter_nodes.nodes, context);
     paths = extractPath(added_filter_nodes.nodes, context, context->getSettingsRef()[Setting::allow_unrestricted_reads_from_keeper]);
 }
 
 
 Chunk SystemZooKeeperSource::generate()
 {
+    if (name.empty())
+    {
+        chassert(0); // In fact, it must always have a default value.
+        name = zkutil::DEFAULT_ZOOKEEPER_NAME;
+    }
+
     if (paths.empty())
     {
         if (!started)
@@ -531,16 +611,17 @@ Chunk SystemZooKeeperSource::generate()
     /// Handles reconnects when needed
     auto get_zookeeper = [&] ()
     {
-        if (!zookeeper || zookeeper->expired())
+        auto zookeeper = zookeepers.find(name);
+        if (zookeeper == zookeepers.end() || zookeeper->second->expired())
         {
-            zookeeper = ZooKeeperWithFaultInjection::createInstance(
+            zookeepers[name] = ZooKeeperWithFaultInjection::createInstance(
                 settings[Setting::insert_keeper_fault_injection_probability],
                 settings[Setting::insert_keeper_fault_injection_seed],
-                context->getZooKeeper(),
+                context->getDefaultOrAuxiliaryZooKeeper(name),
                 "",
                 nullptr);
         }
-        return zookeeper;
+        return zookeepers[name];
     };
 
     const Int64 max_inflight_requests = std::max<Int64>(1, context->getSettingsRef()[Setting::max_download_threads].value);
@@ -678,6 +759,7 @@ Chunk SystemZooKeeperSource::generate()
             size_t col_num = 0;
             res_columns[col_num++]->insert(get_task.node);
             res_columns[col_num++]->insert(res.data);
+            res_columns[col_num++]->insert(name);
             res_columns[col_num++]->insert(stat.czxid);
             res_columns[col_num++]->insert(stat.mzxid);
             res_columns[col_num++]->insert(UInt64(stat.ctime / 1000));
@@ -726,7 +808,7 @@ void ReadFromSystemZooKeeper::initializePipeline(QueryPipelineBuilder & pipeline
 {
     const auto & header = getOutputHeader();
 
-    auto source = std::make_shared<SystemZooKeeperSource>(std::move(paths), header, max_block_size, context);
+    auto source = std::make_shared<SystemZooKeeperSource>(std::move(name), std::move(paths), header, max_block_size, context);
     source->setStorageLimits(storage_limits);
     processors.emplace_back(source);
     pipeline.init(Pipe(std::move(source)));
