diff --git a/src/DataStreams/ColumnGathererStream.cpp b/src/DataStreams/ColumnGathererStream.cpp
index 2468ae872a24..683b8012efe0 100644
--- a/src/DataStreams/ColumnGathererStream.cpp
+++ b/src/DataStreams/ColumnGathererStream.cpp
@@ -53,7 +53,7 @@ ColumnGathererStream::ColumnGathererStream(
 Block ColumnGathererStream::readImpl()
 {
     /// Special case: single source and there are no skipped rows
-    if (children.size() == 1 && row_sources_buf.eof())
+    if (children.size() == 1 && row_sources_buf.eof() && !source_to_fully_copy)
         return children[0]->read();
 
     if (!source_to_fully_copy && row_sources_buf.eof())
diff --git a/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp
index 132241844d77..b8c788ed1fca 100644
--- a/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp
+++ b/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp
@@ -93,6 +93,10 @@ IMergingAlgorithm::Status ReplacingSortedAlgorithm::merge()
         }
     }
 
+    /// If have enough rows, return block, because it prohibited to overflow requested number of rows.
+    if (merged_data.hasEnoughRows())
+        return Status(merged_data.pull());
+
     /// We will write the data for the last primary key.
     if (!selected_row.empty())
         insertRow();
