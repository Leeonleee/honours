{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23393,
  "instance_id": "ClickHouse__ClickHouse-23393",
  "issue_numbers": [
    "22384"
  ],
  "base_commit": "022b2e918b6f071ec7d80d6d881f381de86796fa",
  "patch": "diff --git a/docs/en/sql-reference/aggregate-functions/reference/argmax.md b/docs/en/sql-reference/aggregate-functions/reference/argmax.md\nindex 72aa607a7515..0630e2f585eb 100644\n--- a/docs/en/sql-reference/aggregate-functions/reference/argmax.md\n+++ b/docs/en/sql-reference/aggregate-functions/reference/argmax.md\n@@ -6,20 +6,12 @@ toc_priority: 106\n \n Calculates the `arg` value for a maximum `val` value. If there are several different values of `arg` for maximum values of `val`, returns the first of these values encountered.\n \n-Tuple version of this function will return the tuple with the maximum `val` value. It is convenient for use with [SimpleAggregateFunction](../../../sql-reference/data-types/simpleaggregatefunction.md).\n-\n **Syntax**\n \n ``` sql\n argMax(arg, val)\n ```\n \n-or\n-\n-``` sql\n-argMax(tuple(arg, val))\n-```\n-\n **Arguments**\n \n -   `arg` \u2014 Argument.\n@@ -29,13 +21,7 @@ argMax(tuple(arg, val))\n \n -   `arg` value that corresponds to maximum `val` value.\n \n-Type: matches `arg` type. \n-\n-For tuple in the input:\n-\n--   Tuple `(arg, val)`, where `val` is the maximum value and `arg` is a corresponding value.\n-\n-Type: [Tuple](../../../sql-reference/data-types/tuple.md).\n+Type: matches `arg` type.\n \n **Example**\n \n@@ -52,15 +38,13 @@ Input table:\n Query:\n \n ``` sql\n-SELECT argMax(user, salary), argMax(tuple(user, salary), salary), argMax(tuple(user, salary)) FROM salary;\n+SELECT argMax(user, salary) FROM salary;\n ```\n \n Result:\n \n ``` text\n-\u250c\u2500argMax(user, salary)\u2500\u252c\u2500argMax(tuple(user, salary), salary)\u2500\u252c\u2500argMax(tuple(user, salary))\u2500\u2510\n-\u2502 director             \u2502 ('director',5000)                   \u2502 ('director',5000)           \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500argMax(user, salary)\u2500\u2510\n+\u2502 director             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n-\n-[Original article](https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/argmax/) <!--hide-->\ndiff --git a/docs/en/sql-reference/aggregate-functions/reference/argmin.md b/docs/en/sql-reference/aggregate-functions/reference/argmin.md\nindex 7ddc38cd28a1..a259a76b7d74 100644\n--- a/docs/en/sql-reference/aggregate-functions/reference/argmin.md\n+++ b/docs/en/sql-reference/aggregate-functions/reference/argmin.md\n@@ -6,20 +6,12 @@ toc_priority: 105\n \n Calculates the `arg` value for a minimum `val` value. If there are several different values of `arg` for minimum values of `val`, returns the first of these values encountered.\n \n-Tuple version of this function will return the tuple with the minimum `val` value. It is convenient for use with [SimpleAggregateFunction](../../../sql-reference/data-types/simpleaggregatefunction.md).\n-\n **Syntax**\n \n ``` sql\n argMin(arg, val)\n ```\n \n-or\n-\n-``` sql\n-argMin(tuple(arg, val))\n-```\n-\n **Arguments**\n \n -   `arg` \u2014 Argument.\n@@ -29,13 +21,7 @@ argMin(tuple(arg, val))\n \n -   `arg` value that corresponds to minimum `val` value.\n \n-Type: matches `arg` type. \n-\n-For tuple in the input:\n-\n--   Tuple `(arg, val)`, where `val` is the minimum value and `arg` is a corresponding value.\n-\n-Type: [Tuple](../../../sql-reference/data-types/tuple.md).\n+Type: matches `arg` type.\n \n **Example**\n \n@@ -52,15 +38,13 @@ Input table:\n Query:\n \n ``` sql\n-SELECT argMin(user, salary), argMin(tuple(user, salary)) FROM salary;\n+SELECT argMin(user, salary) FROM salary\n ```\n \n Result:\n \n ``` text\n-\u250c\u2500argMin(user, salary)\u2500\u252c\u2500argMin(tuple(user, salary))\u2500\u2510\n-\u2502 worker               \u2502 ('worker',1000)             \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500argMin(user, salary)\u2500\u2510\n+\u2502 worker               \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n-\n-[Original article](https://clickhouse.tech/docs/en/sql-reference/aggregate-functions/reference/argmin/) <!--hide-->\ndiff --git a/docs/en/sql-reference/data-types/simpleaggregatefunction.md b/docs/en/sql-reference/data-types/simpleaggregatefunction.md\nindex 244779c5ca87..d47a7027c28e 100644\n--- a/docs/en/sql-reference/data-types/simpleaggregatefunction.md\n+++ b/docs/en/sql-reference/data-types/simpleaggregatefunction.md\n@@ -18,8 +18,6 @@ The following aggregate functions are supported:\n -   [`sumMap`](../../sql-reference/aggregate-functions/reference/summap.md#agg_functions-summap)\n -   [`minMap`](../../sql-reference/aggregate-functions/reference/minmap.md#agg_functions-minmap)\n -   [`maxMap`](../../sql-reference/aggregate-functions/reference/maxmap.md#agg_functions-maxmap)\n--   [`argMin`](../../sql-reference/aggregate-functions/reference/argmin.md)\n--   [`argMax`](../../sql-reference/aggregate-functions/reference/argmax.md)\n \n \n !!! note \"Note\"\ndiff --git a/src/AggregateFunctions/AggregateFunctionArgMinMax.h b/src/AggregateFunctions/AggregateFunctionArgMinMax.h\nindex 9efc907aed3f..77c710e0587c 100644\n--- a/src/AggregateFunctions/AggregateFunctionArgMinMax.h\n+++ b/src/AggregateFunctions/AggregateFunctionArgMinMax.h\n@@ -1,16 +1,14 @@\n #pragma once\n \n-#include <AggregateFunctions/AggregateFunctionMinMaxAny.h> // SingleValueDataString used in embedded compiler\n-#include <AggregateFunctions/IAggregateFunction.h>\n-#include <Columns/ColumnTuple.h>\n-#include <DataTypes/DataTypeTuple.h>\n-#include <DataTypes/IDataType.h>\n #include <common/StringRef.h>\n-#include \"Columns/IColumn.h\"\n+#include <DataTypes/IDataType.h>\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/AggregateFunctionMinMaxAny.h> // SingleValueDataString used in embedded compiler\n \n \n namespace DB\n {\n+\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n@@ -24,53 +22,47 @@ struct AggregateFunctionArgMinMaxData\n     using ResultData_t = ResultData;\n     using ValueData_t = ValueData;\n \n-    ResultData result; // the argument at which the minimum/maximum value is reached.\n-    ValueData value; // value for which the minimum/maximum is calculated.\n+    ResultData result;  // the argument at which the minimum/maximum value is reached.\n+    ValueData value;    // value for which the minimum/maximum is calculated.\n \n-    static bool allocatesMemoryInArena() { return ResultData::allocatesMemoryInArena() || ValueData::allocatesMemoryInArena(); }\n-\n-    static String name() { return StringRef(ValueData_t::name()) == StringRef(\"min\") ? \"argMin\" : \"argMax\"; }\n+    static bool allocatesMemoryInArena()\n+    {\n+        return ResultData::allocatesMemoryInArena() || ValueData::allocatesMemoryInArena();\n+    }\n };\n \n /// Returns the first arg value found for the minimum/maximum value. Example: argMax(arg, value).\n template <typename Data>\n-class AggregateFunctionArgMinMax final : public IAggregateFunctionTupleArgHelper<Data, AggregateFunctionArgMinMax<Data>, 2>\n+class AggregateFunctionArgMinMax final : public IAggregateFunctionDataHelper<Data, AggregateFunctionArgMinMax<Data>>\n {\n private:\n     const DataTypePtr & type_res;\n     const DataTypePtr & type_val;\n     const SerializationPtr serialization_res;\n     const SerializationPtr serialization_val;\n-    bool tuple_argument;\n \n-    using Base = IAggregateFunctionTupleArgHelper<Data, AggregateFunctionArgMinMax<Data>, 2>;\n+    using Base = IAggregateFunctionDataHelper<Data, AggregateFunctionArgMinMax<Data>>;\n \n public:\n-    AggregateFunctionArgMinMax(const DataTypePtr & type_res_, const DataTypePtr & type_val_, const bool tuple_argument_)\n-        : Base({type_res_, type_val_}, {}, tuple_argument_)\n+    AggregateFunctionArgMinMax(const DataTypePtr & type_res_, const DataTypePtr & type_val_)\n+        : Base({type_res_, type_val_}, {})\n         , type_res(this->argument_types[0])\n         , type_val(this->argument_types[1])\n         , serialization_res(type_res->getDefaultSerialization())\n         , serialization_val(type_val->getDefaultSerialization())\n     {\n         if (!type_val->isComparable())\n-            throw Exception(\n-                \"Illegal type \" + type_val->getName() + \" of second argument of aggregate function \" + getName()\n-                    + \" because the values of that data type are not comparable\",\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        this->tuple_argument = tuple_argument_;\n+            throw Exception(\"Illegal type \" + type_val->getName() + \" of second argument of aggregate function \" + getName()\n+                + \" because the values of that data type are not comparable\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n \n-    String getName() const override { return Data::name(); }\n+    String getName() const override\n+    {\n+        return StringRef(Data::ValueData_t::name()) == StringRef(\"min\") ? \"argMin\" : \"argMax\";\n+    }\n \n     DataTypePtr getReturnType() const override\n     {\n-        if (tuple_argument)\n-        {\n-            return std::make_shared<DataTypeTuple>(DataTypes{this->type_res, this->type_val});\n-        }\n-\n         return type_res;\n     }\n \n@@ -98,21 +90,15 @@ class AggregateFunctionArgMinMax final : public IAggregateFunctionTupleArgHelper\n         this->data(place).value.read(buf, *serialization_val, arena);\n     }\n \n-    bool allocatesMemoryInArena() const override { return Data::allocatesMemoryInArena(); }\n+    bool allocatesMemoryInArena() const override\n+    {\n+        return Data::allocatesMemoryInArena();\n+    }\n \n     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override\n     {\n-        if (tuple_argument)\n-        {\n-            auto & tup = assert_cast<ColumnTuple &>(to);\n-\n-            this->data(place).result.insertResultInto(tup.getColumn(0));\n-            this->data(place).value.insertResultInto(tup.getColumn(1));\n-        }\n-        else\n-            this->data(place).result.insertResultInto(to);\n+        this->data(place).result.insertResultInto(to);\n     }\n };\n \n-\n }\ndiff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h\nindex 2b21b745a0e4..fb727bf98b07 100644\n--- a/src/AggregateFunctions/Helpers.h\n+++ b/src/AggregateFunctions/Helpers.h\n@@ -31,12 +31,6 @@\n     M(Float32) \\\n     M(Float64)\n \n-#define FOR_DECIMAL_TYPES(M) \\\n-    M(Decimal32) \\\n-    M(Decimal64) \\\n-    M(Decimal128)\n-\n-\n namespace DB\n {\n \ndiff --git a/src/AggregateFunctions/HelpersMinMaxAny.h b/src/AggregateFunctions/HelpersMinMaxAny.h\nindex e995f52f4984..dc165f50d8e3 100644\n--- a/src/AggregateFunctions/HelpersMinMaxAny.h\n+++ b/src/AggregateFunctions/HelpersMinMaxAny.h\n@@ -8,14 +8,10 @@\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeString.h>\n-#include <DataTypes/DataTypeTuple.h>\n+\n \n namespace DB\n {\n-namespace ErrorCodes\n-{\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-}\n \n /// min, max, any, anyLast, anyHeavy, etc...\n template <template <typename> class AggregateFunctionTemplate, template <typename> class Data>\n@@ -30,7 +26,6 @@ static IAggregateFunction * createAggregateFunctionSingleValue(const String & na\n #define DISPATCH(TYPE) \\\n     if (which.idx == TypeIndex::TYPE) return new AggregateFunctionTemplate<Data<SingleValueDataFixed<TYPE>>>(argument_type);\n     FOR_NUMERIC_TYPES(DISPATCH)\n-    FOR_DECIMAL_TYPES(DISPATCH)\n #undef DISPATCH\n \n     if (which.idx == TypeIndex::Date)\n@@ -39,6 +34,12 @@ static IAggregateFunction * createAggregateFunctionSingleValue(const String & na\n         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<DataTypeDateTime::FieldType>>>(argument_type);\n     if (which.idx == TypeIndex::DateTime64)\n         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<DateTime64>>>(argument_type);\n+    if (which.idx == TypeIndex::Decimal32)\n+        return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal32>>>(argument_type);\n+    if (which.idx == TypeIndex::Decimal64)\n+        return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal64>>>(argument_type);\n+    if (which.idx == TypeIndex::Decimal128)\n+        return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal128>>>(argument_type);\n     if (which.idx == TypeIndex::String)\n         return new AggregateFunctionTemplate<Data<SingleValueDataString>>(argument_type);\n \n@@ -48,77 +49,66 @@ static IAggregateFunction * createAggregateFunctionSingleValue(const String & na\n \n /// argMin, argMax\n template <template <typename> class MinMaxData, typename ResData>\n-static IAggregateFunction * createAggregateFunctionArgMinMaxSecond(const DataTypePtr & res_type, const DataTypePtr & val_type, bool is_tuple)\n+static IAggregateFunction * createAggregateFunctionArgMinMaxSecond(const DataTypePtr & res_type, const DataTypePtr & val_type)\n {\n     WhichDataType which(val_type);\n \n #define DISPATCH(TYPE) \\\n     if (which.idx == TypeIndex::TYPE) \\\n-        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<TYPE>>>>(res_type, val_type, is_tuple);\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<TYPE>>>>(res_type, val_type);\n     FOR_NUMERIC_TYPES(DISPATCH)\n-    FOR_DECIMAL_TYPES(DISPATCH)\n #undef DISPATCH\n \n     if (which.idx == TypeIndex::Date)\n-        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DataTypeDate::FieldType>>>>(res_type, val_type, is_tuple);\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DataTypeDate::FieldType>>>>(res_type, val_type);\n     if (which.idx == TypeIndex::DateTime)\n-        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DataTypeDateTime::FieldType>>>>(res_type, val_type, is_tuple);\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DataTypeDateTime::FieldType>>>>(res_type, val_type);\n     if (which.idx == TypeIndex::DateTime64)\n-        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DateTime64>>>>(res_type, val_type, is_tuple);\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<DateTime64>>>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal32)\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal32>>>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal64)\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal64>>>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal128)\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal128>>>>(res_type, val_type);\n     if (which.idx == TypeIndex::String)\n-        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataString>>>(res_type, val_type, is_tuple);\n-\n-    return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataGeneric>>>(res_type, val_type, is_tuple);\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataString>>>(res_type, val_type);\n \n+    return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataGeneric>>>(res_type, val_type);\n }\n \n template <template <typename> class MinMaxData>\n static IAggregateFunction * createAggregateFunctionArgMinMax(const String & name, const DataTypes & argument_types, const Array & parameters)\n {\n     assertNoParameters(name, parameters);\n+    assertBinary(name, argument_types);\n \n-    DataTypePtr res_type, val_type;\n-    bool is_tuple = false;\n-\n-    // argMin and argMax could get tuple of two as arguments\n-    if (argument_types.size() == 1 && argument_types[0]->getTypeId() == TypeIndex::Tuple)\n-    {\n-        const auto * tuple_type = assert_cast<const DataTypeTuple *>(argument_types[0].get());\n-\n-        if (tuple_type->getElements().size() != 2)\n-        {\n-            throw Exception(\"Aggregate function \" + name + \" expects two elements in tuple argument\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n-        }\n-\n-        res_type = tuple_type->getElements()[0];\n-        val_type = tuple_type->getElements()[1];\n-        is_tuple = true;\n-     }\n-     else\n-     {\n-        assertBinary(name, argument_types);\n-        res_type = argument_types[0];\n-        val_type = argument_types[1];\n-     }\n+    const DataTypePtr & res_type = argument_types[0];\n+    const DataTypePtr & val_type = argument_types[1];\n \n     WhichDataType which(res_type);\n #define DISPATCH(TYPE) \\\n     if (which.idx == TypeIndex::TYPE) \\\n-        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<TYPE>>(res_type, val_type, is_tuple);\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<TYPE>>(res_type, val_type);\n     FOR_NUMERIC_TYPES(DISPATCH)\n-    FOR_DECIMAL_TYPES(DISPATCH)\n #undef DISPATCH\n \n     if (which.idx == TypeIndex::Date)\n-        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DataTypeDate::FieldType>>(res_type, val_type, is_tuple);\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DataTypeDate::FieldType>>(res_type, val_type);\n     if (which.idx == TypeIndex::DateTime)\n-        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DataTypeDateTime::FieldType>>(res_type, val_type, is_tuple);\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DataTypeDateTime::FieldType>>(res_type, val_type);\n     if (which.idx == TypeIndex::DateTime64)\n-        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DateTime64>>(res_type, val_type, is_tuple);\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<DateTime64>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal32)\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal32>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal64)\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal64>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal128)\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal128>>(res_type, val_type);\n     if (which.idx == TypeIndex::String)\n-        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataString>(res_type, val_type, is_tuple);\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataString>(res_type, val_type);\n \n-    return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataGeneric>(res_type, val_type, is_tuple);\n+    return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataGeneric>(res_type, val_type);\n }\n \n }\ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex dbb0a9f43494..a418cdb55236 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -11,8 +11,8 @@\n \n #include <cstddef>\n #include <memory>\n-#include <type_traits>\n #include <vector>\n+#include <type_traits>\n \n \n namespace DB\n@@ -52,9 +52,7 @@ class IAggregateFunction\n {\n public:\n     IAggregateFunction(const DataTypes & argument_types_, const Array & parameters_)\n-        : argument_types(argument_types_), parameters(parameters_)\n-    {\n-    }\n+        : argument_types(argument_types_), parameters(parameters_) {}\n \n     /// Get main function name.\n     virtual String getName() const = 0;\n@@ -180,8 +178,12 @@ class IAggregateFunction\n       *  \"places\" contains a large number of same values consecutively.\n       */\n     virtual void addBatchArray(\n-        size_t batch_size, AggregateDataPtr * places, size_t place_offset, const IColumn ** columns, const UInt64 * offsets, Arena * arena)\n-        const = 0;\n+        size_t batch_size,\n+        AggregateDataPtr * places,\n+        size_t place_offset,\n+        const IColumn ** columns,\n+        const UInt64 * offsets,\n+        Arena * arena) const = 0;\n \n     /** The case when the aggregation key is UInt8\n       * and pointers to aggregation states are stored in AggregateDataPtr[256] lookup table.\n@@ -202,10 +204,8 @@ class IAggregateFunction\n      *  arguments and params are for nested_function.\n      */\n     virtual AggregateFunctionPtr getOwnNullAdapter(\n-        const AggregateFunctionPtr & /*nested_function*/,\n-        const DataTypes & /*arguments*/,\n-        const Array & /*params*/,\n-        const AggregateFunctionProperties & /*properties*/) const\n+        const AggregateFunctionPtr & /*nested_function*/, const DataTypes & /*arguments*/,\n+        const Array & /*params*/, const AggregateFunctionProperties & /*properties*/) const\n     {\n         return nullptr;\n     }\n@@ -250,9 +250,7 @@ class IAggregateFunctionHelper : public IAggregateFunction\n \n public:\n     IAggregateFunctionHelper(const DataTypes & argument_types_, const Array & parameters_)\n-        : IAggregateFunction(argument_types_, parameters_)\n-    {\n-    }\n+        : IAggregateFunction(argument_types_, parameters_) {}\n \n     AddFunc getAddressOfAddFunction() const override { return &addFree; }\n \n@@ -414,19 +412,32 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n     static constexpr bool DateTime64Supported = true;\n \n     IAggregateFunctionDataHelper(const DataTypes & argument_types_, const Array & parameters_)\n-        : IAggregateFunctionHelper<Derived>(argument_types_, parameters_)\n+        : IAggregateFunctionHelper<Derived>(argument_types_, parameters_) {}\n+\n+    void create(AggregateDataPtr place) const override\n     {\n+        new (place) Data;\n     }\n \n-    void create(AggregateDataPtr __restrict place) const override { new (place) Data; }\n-\n-    void destroy(AggregateDataPtr __restrict place) const noexcept override { data(place).~Data(); }\n+    void destroy(AggregateDataPtr __restrict place) const noexcept override\n+    {\n+        data(place).~Data();\n+    }\n \n-    bool hasTrivialDestructor() const override { return std::is_trivially_destructible_v<Data>; }\n+    bool hasTrivialDestructor() const override\n+    {\n+        return std::is_trivially_destructible_v<Data>;\n+    }\n \n-    size_t sizeOfData() const override { return sizeof(Data); }\n+    size_t sizeOfData() const override\n+    {\n+        return sizeof(Data);\n+    }\n \n-    size_t alignOfData() const override { return alignof(Data); }\n+    size_t alignOfData() const override\n+    {\n+        return alignof(Data);\n+    }\n \n     void addBatchLookupTable8(\n         size_t batch_size,\n@@ -505,142 +516,6 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n     }\n };\n \n-/// Implements tuple argument unwrapper when the tuple just masks arguments\n-template <typename T, typename Derived, size_t args_count>\n-class IAggregateFunctionTupleArgHelper : public IAggregateFunctionDataHelper<T, Derived>\n-{\n-private:\n-    using Base = IAggregateFunctionDataHelper<T, Derived>;\n-\n-    static void addFree(const IAggregateFunction * that, AggregateDataPtr place, const IColumn ** columns_, size_t row_num, Arena * arena)\n-    {\n-        if (const auto * col = checkAndGetColumn<ColumnTuple>(*columns_[0]))\n-        {\n-            const IColumn * columns[args_count];\n-            const auto & tup_columns = col->getColumns();\n-\n-            assert(tup_columns.size() == args_count);\n-            for (size_t i = 0; i < tup_columns.size(); ++i)\n-            {\n-                columns[i] = tup_columns[i].get();\n-            }\n-\n-            static_cast<const Derived &>(*that).add(place, columns, row_num, arena);\n-        }\n-        else\n-            static_cast<const Derived &>(*that).add(place, columns_, row_num, arena);\n-    }\n-\n-protected:\n-    ssize_t extractColumns(const IColumn ** columns, const IColumn ** aggr_columns, ssize_t if_argument_pos) const\n-    {\n-        if (tuple_argument)\n-        {\n-            auto tup_columns = assert_cast<const ColumnTuple *>(aggr_columns[0])->getColumns();\n-            for (size_t i = 0; i < args_count; ++i)\n-                columns[i] = tup_columns[i].get();\n-        }\n-        else\n-        {\n-            for (size_t i = 0; i < args_count; ++i)\n-                columns[i] = aggr_columns[i];\n-        }\n-        if (if_argument_pos >= 0)\n-        {\n-            columns[args_count] = aggr_columns[if_argument_pos];\n-            return args_count;\n-        }\n-        else\n-            return -1;\n-    }\n-\n-    bool tuple_argument;\n-\n-public:\n-    IAggregateFunctionTupleArgHelper(const DataTypes & argument_types_, const Array & parameters_, bool tuple_argument_)\n-        : Base(argument_types_, parameters_)\n-    {\n-        tuple_argument = tuple_argument_;\n-    }\n-\n-    IAggregateFunction::AddFunc getAddressOfAddFunction() const override { return &addFree; }\n-\n-    /*\n-     * We're overriding addBatch* functions just to avoid extracting columns\n-     * in 'add' functions\n-     */\n-    void addBatch(\n-        size_t batch_size,\n-        AggregateDataPtr * places,\n-        size_t place_offset,\n-        const IColumn ** columns,\n-        Arena * arena,\n-        ssize_t if_argument_pos = -1) const override\n-    {\n-        const IColumn * ex_columns[args_count + (if_argument_pos >= 0)];\n-        if_argument_pos = extractColumns(ex_columns, columns, if_argument_pos);\n-\n-        Base::addBatch(batch_size, places, place_offset, ex_columns, arena, if_argument_pos);\n-    }\n-\n-    void addBatchSinglePlace(\n-        size_t batch_size, AggregateDataPtr place, const IColumn ** columns, Arena * arena, ssize_t if_argument_pos = -1) const override\n-    {\n-        const IColumn * ex_columns[args_count + (if_argument_pos >= 0)];\n-        if_argument_pos = extractColumns(ex_columns, columns, if_argument_pos);\n-\n-        Base::addBatchSinglePlace(batch_size, place, ex_columns, arena, if_argument_pos);\n-    }\n-\n-    void addBatchSinglePlaceNotNull(\n-        size_t batch_size,\n-        AggregateDataPtr place,\n-        const IColumn ** columns,\n-        const UInt8 * null_map,\n-        Arena * arena,\n-        ssize_t if_argument_pos = -1) const override\n-    {\n-        const IColumn * ex_columns[args_count + (if_argument_pos >= 0)];\n-        if_argument_pos = extractColumns(ex_columns, columns, if_argument_pos);\n-\n-        Base::addBatchSinglePlaceNotNull(batch_size, place, ex_columns, null_map, arena, if_argument_pos);\n-    }\n-\n-    void addBatchSinglePlaceFromInterval(\n-        size_t batch_begin, size_t batch_end, AggregateDataPtr place, const IColumn ** columns, Arena * arena, ssize_t if_argument_pos = -1)\n-        const override\n-    {\n-        const IColumn * ex_columns[args_count + (if_argument_pos >= 0)];\n-        if_argument_pos = extractColumns(ex_columns, columns, if_argument_pos);\n-\n-        Base::addBatchSinglePlaceFromInterval(batch_begin, batch_end, place, ex_columns, arena, if_argument_pos);\n-    }\n-\n-    void addBatchArray(\n-        size_t batch_size, AggregateDataPtr * places, size_t place_offset, const IColumn ** columns, const UInt64 * offsets, Arena * arena)\n-        const override\n-    {\n-        const IColumn * ex_columns[args_count];\n-        extractColumns(ex_columns, columns, -1);\n-\n-        Base::addBatchArray(batch_size, places, place_offset, ex_columns, offsets, arena);\n-    }\n-\n-    void addBatchLookupTable8(\n-        size_t batch_size,\n-        AggregateDataPtr * map,\n-        size_t place_offset,\n-        std::function<void(AggregateDataPtr &)> init,\n-        const UInt8 * key,\n-        const IColumn ** columns,\n-        Arena * arena) const override\n-    {\n-        const IColumn * ex_columns[args_count];\n-        extractColumns(ex_columns, columns, -1);\n-\n-        Base::addBatchLookupTable8(batch_size, map, place_offset, init, key, ex_columns, arena);\n-    }\n-};\n \n /// Properties of aggregate function that are independent of argument types and parameters.\n struct AggregateFunctionProperties\ndiff --git a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\nindex 3262dd1610a8..6b2f94aa7b5b 100644\n--- a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\n+++ b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\n@@ -29,8 +29,7 @@ void DataTypeCustomSimpleAggregateFunction::checkSupportedFunctions(const Aggreg\n {\n     static const std::vector<String> supported_functions{\"any\", \"anyLast\", \"min\",\n         \"max\", \"sum\", \"sumWithOverflow\", \"groupBitAnd\", \"groupBitOr\", \"groupBitXor\",\n-        \"sumMap\", \"minMap\", \"maxMap\", \"groupArrayArray\", \"groupUniqArrayArray\",\n-        \"argMin\", \"argMax\"};\n+        \"sumMap\", \"minMap\", \"maxMap\", \"groupArrayArray\", \"groupUniqArrayArray\"};\n \n     // check function\n     if (std::find(std::begin(supported_functions), std::end(supported_functions), function->getName()) == std::end(supported_functions))\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00027_argMinMax.reference b/tests/queries/0_stateless/00027_argMinMax.reference\nindex 5ba447dd04bc..101e8c160447 100644\n--- a/tests/queries/0_stateless/00027_argMinMax.reference\n+++ b/tests/queries/0_stateless/00027_argMinMax.reference\n@@ -1,5 +1,5 @@\n-0\t(0,1)\t9\t(9,10)\n-0\t('0',1)\t9\t('9',10)\n-1970-01-01\t('1970-01-01','1970-01-01 00:00:01')\t1970-01-10\t('1970-01-10','1970-01-01 00:00:10')\n-0.00\t(0.00,1.00)\t9.00\t(9.00,10.00)\n+0\t9\n+0\t9\n+1970-01-01\t1970-01-10\n+0.00\t9.00\n 4\t1\ndiff --git a/tests/queries/0_stateless/00027_argMinMax.sql b/tests/queries/0_stateless/00027_argMinMax.sql\nindex 2bb3b507df5e..2b67b99ec770 100644\n--- a/tests/queries/0_stateless/00027_argMinMax.sql\n+++ b/tests/queries/0_stateless/00027_argMinMax.sql\n@@ -1,8 +1,8 @@\n -- types\n-select argMin(x.1, x.2), argMin(x), argMax(x.1, x.2), argMax(x) from (select (number, number + 1) as x from numbers(10));\n-select argMin(x.1, x.2), argMin(x), argMax(x.1, x.2), argMax(x) from (select (toString(number), toInt32(number) + 1) as x from numbers(10));\n-select argMin(x.1, x.2), argMin(x), argMax(x.1, x.2), argMax(x) from (select (toDate(number, 'UTC'), toDateTime(number, 'UTC') + 1) as x from numbers(10));\n-select argMin(x.1, x.2), argMin(x), argMax(x.1, x.2), argMax(x) from (select (toDecimal32(number, 2), toDecimal64(number, 2) + 1) as x from numbers(10));\n+select argMin(x.1, x.2), argMax(x.1, x.2) from (select (number, number + 1) as x from numbers(10));\n+select argMin(x.1, x.2), argMax(x.1, x.2) from (select (toString(number), toInt32(number) + 1) as x from numbers(10));\n+select argMin(x.1, x.2), argMax(x.1, x.2) from (select (toDate(number, 'UTC'), toDateTime(number, 'UTC') + 1) as x from numbers(10));\n+select argMin(x.1, x.2), argMax(x.1, x.2) from (select (toDecimal32(number, 2), toDecimal64(number, 2) + 1) as x from numbers(10));\n \n -- array\n SELECT argMinArray(id, num), argMaxArray(id, num)  FROM (SELECT arrayJoin([[10, 4, 3], [7, 5, 6], [8, 8, 2]]) AS num, arrayJoin([[1, 2, 4], [2, 3, 3]]) AS id);\ndiff --git a/tests/queries/0_stateless/00027_simple_argMinArray.reference b/tests/queries/0_stateless/00027_simple_argMinArray.reference\nnew file mode 100644\nindex 000000000000..4482956b7069\n--- /dev/null\n+++ b/tests/queries/0_stateless/00027_simple_argMinArray.reference\n@@ -0,0 +1,1 @@\n+4\t1\ndiff --git a/tests/queries/0_stateless/00027_simple_argMinArray.sql b/tests/queries/0_stateless/00027_simple_argMinArray.sql\nnew file mode 100644\nindex 000000000000..b681a2c53cf0\n--- /dev/null\n+++ b/tests/queries/0_stateless/00027_simple_argMinArray.sql\n@@ -0,0 +1,1 @@\n+SELECT argMinArray(id, num), argMaxArray(id, num)  FROM (SELECT arrayJoin([[10, 4, 3], [7, 5, 6], [8, 8, 2]]) AS num, arrayJoin([[1, 2, 4], [2, 3, 3]]) AS id)\ndiff --git a/tests/queries/0_stateless/00915_simple_aggregate_function.reference b/tests/queries/0_stateless/00915_simple_aggregate_function.reference\nindex 8d5d8340f176..6bbe9b1e8b35 100644\n--- a/tests/queries/0_stateless/00915_simple_aggregate_function.reference\n+++ b/tests/queries/0_stateless/00915_simple_aggregate_function.reference\n@@ -39,7 +39,7 @@ SimpleAggregateFunction(sum, Float64)\n 7\t14\n 8\t16\n 9\t18\n-1\t1\t2\t2.2.2.2\t3\t([1,2,3],[2,1,1])\t([1,2,3],[1,1,2])\t([1,2,3],[2,1,2])\t[1,2,2,3,4]\t[4,2,1,3]\t(1,1)\t(2,2)\n-10\t2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222\t20\t20.20.20.20\t5\t([2,3,4],[2,1,1])\t([2,3,4],[3,3,4])\t([2,3,4],[4,3,4])\t[]\t[]\t(3,3)\t(4,4)\n-SimpleAggregateFunction(anyLast, Nullable(String))\tSimpleAggregateFunction(anyLast, LowCardinality(Nullable(String)))\tSimpleAggregateFunction(anyLast, IPv4)\tSimpleAggregateFunction(groupBitOr, UInt32)\tSimpleAggregateFunction(sumMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(minMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(maxMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(groupArrayArray, Array(Int32))\tSimpleAggregateFunction(groupUniqArrayArray, Array(Int32))\tSimpleAggregateFunction(argMin, Tuple(Int32, Int64))\tSimpleAggregateFunction(argMax, Tuple(Int32, Int64))\n+1\t1\t2\t2.2.2.2\t3\t([1,2,3],[2,1,1])\t([1,2,3],[1,1,2])\t([1,2,3],[2,1,2])\t[1,2,2,3,4]\t[4,2,1,3]\n+10\t2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222\t20\t20.20.20.20\t5\t([2,3,4],[2,1,1])\t([2,3,4],[3,3,4])\t([2,3,4],[4,3,4])\t[]\t[]\n+SimpleAggregateFunction(anyLast, Nullable(String))\tSimpleAggregateFunction(anyLast, LowCardinality(Nullable(String)))\tSimpleAggregateFunction(anyLast, IPv4)\tSimpleAggregateFunction(groupBitOr, UInt32)\tSimpleAggregateFunction(sumMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(minMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(maxMap, Tuple(Array(Int32), Array(Int64)))\tSimpleAggregateFunction(groupArrayArray, Array(Int32))\tSimpleAggregateFunction(groupUniqArrayArray, Array(Int32))\n with_overflow\t1\t0\ndiff --git a/tests/queries/0_stateless/00915_simple_aggregate_function.sql b/tests/queries/0_stateless/00915_simple_aggregate_function.sql\nindex c669f810312b..82a7aa2152fa 100644\n--- a/tests/queries/0_stateless/00915_simple_aggregate_function.sql\n+++ b/tests/queries/0_stateless/00915_simple_aggregate_function.sql\n@@ -31,22 +31,16 @@ create table simple (\n     tup_min SimpleAggregateFunction(minMap, Tuple(Array(Int32), Array(Int64))),\n     tup_max SimpleAggregateFunction(maxMap, Tuple(Array(Int32), Array(Int64))),\n     arr SimpleAggregateFunction(groupArrayArray, Array(Int32)),\n-    uniq_arr SimpleAggregateFunction(groupUniqArrayArray, Array(Int32)),\n-    arg_min SimpleAggregateFunction(argMin, Tuple(Int32, Int64)),\n-    arg_max SimpleAggregateFunction(argMax, Tuple(Int32, Int64))\n+    uniq_arr SimpleAggregateFunction(groupUniqArrayArray, Array(Int32))\n ) engine=AggregatingMergeTree order by id;\n-\n-insert into simple values(1,'1','1','1.1.1.1', 1, ([1,2], [1,1]), ([1,2], [1,1]), ([1,2], [1,1]), [1,2], [1,2], (1,1), (1,1));\n-insert into simple values(1,null,'2','2.2.2.2', 2, ([1,3], [1,1]), ([1,3], [2,2]), ([1,3], [2,2]), [2,3,4], [2,3,4], (2,2), (2,2));\n+insert into simple values(1,'1','1','1.1.1.1', 1, ([1,2], [1,1]), ([1,2], [1,1]), ([1,2], [1,1]), [1,2], [1,2]);\n+insert into simple values(1,null,'2','2.2.2.2', 2, ([1,3], [1,1]), ([1,3], [2,2]), ([1,3], [2,2]), [2,3,4], [2,3,4]);\n -- String longer then MAX_SMALL_STRING_SIZE (actual string length is 100)\n-insert into simple values(10,'10','10','10.10.10.10', 4, ([2,3], [1,1]), ([2,3], [3,3]), ([2,3], [3,3]), [], [], (3,3), (3,3));\n-insert into simple values(10,'2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222','20','20.20.20.20', 1, ([2, 4], [1,1]), ([2, 4], [4,4]), ([2, 4], [4,4]), [], [], (4,4), (4,4));\n+insert into simple values(10,'10','10','10.10.10.10', 4, ([2,3], [1,1]), ([2,3], [3,3]), ([2,3], [3,3]), [], []);\n+insert into simple values(10,'2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222','20','20.20.20.20', 1, ([2, 4], [1,1]), ([2, 4], [4,4]), ([2, 4], [4,4]), [], []);\n \n select * from simple final order by id;\n-select toTypeName(nullable_str), toTypeName(low_str), toTypeName(ip), toTypeName(status),\n-    toTypeName(tup), toTypeName(tup_min), toTypeName(tup_max), toTypeName(arr),\n-    toTypeName(uniq_arr), toTypeName(arg_min), toTypeName(arg_max)\n-from simple limit 1;\n+select toTypeName(nullable_str),toTypeName(low_str),toTypeName(ip),toTypeName(status), toTypeName(tup), toTypeName(tup_min), toTypeName(tup_max), toTypeName(arr), toTypeName(uniq_arr) from simple limit 1;\n \n optimize table simple final;\n \n",
  "problem_statement": "argMaxSimpleState((1,1)) crash\n**Does it reproduce on recent release?**\r\nYes.\r\n\r\n**How to reproduce**\r\nClickhouse version 21.4.6395 (master), 21.3.4.25\r\n\r\n```\r\nSELECT argMaxSimpleState((1, 1))\r\n\r\nQuery id: 41a50d5e-15f1-4fa7-8171-d1767b061a1d\r\n\r\n2021.03.31 02:16:36.523853 [ 4038 ] <Fatal> BaseDaemon: ########################################\r\n2021.03.31 02:16:36.523912 [ 4038 ] <Fatal> BaseDaemon: (version 21.4.1.6395 (official build), build id: E16FB8B53E687D53215B76D44CF690AF09D9EB98) (from thread 3982) (query_id: 41a50d5e-15f1-4fa7-8171-d1767b061a1d) Received signal Segmentation fault (11)\r\n2021.03.31 02:16:36.523942 [ 4038 ] <Fatal> BaseDaemon: Address: 0x10 Access: read. Address not mapped to object.\r\n2021.03.31 02:16:36.523956 [ 4038 ] <Fatal> BaseDaemon: Stack trace: 0x92d7ca8 0xa40b5e7 0xf5458f1 0xf547118 0x101ad4d6 0x101aab8b 0x100041cd 0x10000e81 0xfffedf6 0x1000c262 0x88d833f 0x88dbdd3 0x7f269aab4609 0x7f269a9db293\r\n2021.03.31 02:16:36.523997 [ 4038 ] <Fatal> BaseDaemon: 1. DB::AggregateFunctionArgMinMax<DB::AggregateFunctionArgMinMaxData<DB::SingleValueDataFixed<char8_t>, DB::AggregateFunctionMaxData<DB::SingleValueDataFixed<char8_t> > > >::add(char*, DB::IColumn const**, unsigned long, DB::Arena*) const @ 0x92d7ca8 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524015 [ 4038 ] <Fatal> BaseDaemon: 2. DB::IAggregateFunctionHelper<DB::AggregateFunctionSimpleState>::addBatchSinglePlace(unsigned long, char*, DB::IColumn const**, DB::Arena*, long) const @ 0xa40b5e7 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524032 [ 4038 ] <Fatal> BaseDaemon: 3. DB::Aggregator::executeWithoutKeyImpl(char*&, unsigned long, DB::Aggregator::AggregateFunctionInstruction*, DB::Arena*) @ 0xf5458f1 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524050 [ 4038 ] <Fatal> BaseDaemon: 4. DB::Aggregator::executeOnBlock(std::__1::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::__1::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn> > >, unsigned long, DB::AggregatedDataVariants&, std::__1::vector<DB::IColumn const*, std::__1::allocator<DB::IColumn const*> >&, std::__1::vector<std::__1::vector<DB::IColumn const*, std::__1::allocator<DB::IColumn const*> >, std::__1::allocator<std::__1::vector<DB::IColumn const*, std::__1::allocator<DB::IColumn const*> > > >&, bool&) @ 0xf547118 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524066 [ 4038 ] <Fatal> BaseDaemon: 5. DB::AggregatingTransform::consume(DB::Chunk) @ 0x101ad4d6 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524076 [ 4038 ] <Fatal> BaseDaemon: 6. DB::AggregatingTransform::work() @ 0x101aab8b in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524089 [ 4038 ] <Fatal> BaseDaemon: 7. ? @ 0x100041cd in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524106 [ 4038 ] <Fatal> BaseDaemon: 8. DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__1::atomic<bool>*) @ 0x10000e81 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524123 [ 4038 ] <Fatal> BaseDaemon: 9. DB::PipelineExecutor::executeImpl(unsigned long) @ 0xfffedf6 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524140 [ 4038 ] <Fatal> BaseDaemon: 10. ? @ 0x1000c262 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524157 [ 4038 ] <Fatal> BaseDaemon: 11. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x88d833f in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524166 [ 4038 ] <Fatal> BaseDaemon: 12. ? @ 0x88dbdd3 in /usr/bin/clickhouse\r\n2021.03.31 02:16:36.524179 [ 4038 ] <Fatal> BaseDaemon: 13. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so\r\n2021.03.31 02:16:36.524192 [ 4038 ] <Fatal> BaseDaemon: 14. __clone @ 0x122293 in /usr/lib/x86_64-linux-gnu/libc-2.31.so\r\n2021.03.31 02:16:36.614300 [ 4038 ] <Fatal> BaseDaemon: Checksum of the binary: F918A5FF180DBD3250D9DE08083C1DDA, integrity check passed.\r\n```\r\n\n",
  "hints_text": "@amosbird We should either fix it or rollback one of #4629 #17359\nWhat's the difference between `argMax((c1, c2))` and `max((c1, c2))` ?  I think we can rollback https://github.com/ClickHouse/ClickHouse/pull/17359 as it introduces too many specifications to aggregators.\nIf I understand, the expectation was that argMax with tuple argument will return tuple.\n@ildus @Avogar Could you please clarify?\n+1 for rollback #17359. It's too easy to do it with simple max/min by putting the second argument at the first position in tuple. \r\n\r\n>  rollback ... #4629\r\n\r\nIt's not funny. It's widely used. \n@alexey-milovidov yes, the expectation is to get tuple if argument is tuple too, so it can be used in SimpleAggregateFunction\nLooks like `argMax` doesn't work with `SimpleState` at all:\r\n```\r\n:) SELECT argMaxSimpleState(1, 1)\r\n\r\nSELECT argMaxSimpleState(1, 1)\r\n\r\nQuery id: d30b6d47-c21b-4989-b58c-a6771207598f\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nReceived exception from server (version 21.4.1):\r\nCode: 42. DB::Exception: Received from localhost:9000. DB::Exception: Aggregate function argMax requires two arguments. \r\n```\r\n\r\n@alexey-milovidov Has this worked before?\nI'm struggling to find the point of `-SimpleState` with argMax for two arguments, since the result value doesn't contain enough data to use it further. I'll look into how to fix that for tuple case.\nI still don't understand why we need `argMax` with tuple arguments. Isn't `max` semantically equivalent?\n@amosbird no, argMax with tuple has same behavior as with two arguments, but it returns a tuple so can be used in SimpleAggregateFunction\n```\r\ncreate temporary table t1 (i int, j String);\r\ninsert into t1 values (1, 'x'), (2, 'y'), (3, 'z');\r\nwith max((j, i)) as m, argMax((i, j)) as am\r\nselect\r\n  (m.2, m.1) max,\r\n  am argmax\r\nfrom t1;\r\n\r\ncreate temporary table t2 (i int, j String);\r\ninsert into t2 values (1, 'c'), (2, 'b'), (3, 'a');\r\nwith max((j, i)) as m, argMax((i, j)) as am\r\nselect\r\n  (m.2, m.1) max,\r\n  am argmax\r\nfrom t2;\r\n```\r\n\r\nHow is it different?\n```\r\nSELECT\r\n    argMax(key_b, key_a) AS arg,\r\n    argMax((key_b, key_a)) AS arg_tiple,\r\n    max((key_a, key_b)) AS mx\r\nFROM\r\n(\r\n    SELECT\r\n        (arrayJoin([(1, 'str'), (2, NULL)]) AS x).1 AS key_a,\r\n        x.2 AS key_b\r\n)\r\n\r\nQuery id: 75ea828b-191c-432f-8f39-b8de99a7cd52\r\n\r\n\u250c\u2500arg\u2500\u252c\u2500arg_tiple\u2500\u252c\u2500mx\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 str \u2502 (NULL,2)  \u2502 (2,NULL) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIf argMax with tuple would act like argMax without tuple it would actually make sense to have support for tuples in it.\n```\r\nWITH\r\n    max((number, rand())) AS mx,\r\n    argMax(rand(), number) AS arg,\r\n    argMax((rand(), number)) AS arg_tuple\r\nSELECT arg\r\nFROM numbers(1000000000)\r\n\r\nQuery id: 1d764dc2-0542-491d-8a6d-09aeec60e37d\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500arg\u2500\u2510\r\n\u2502 3762245095 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 1.545 sec. Processed 1.00 billion rows, 8.00 GB (647.30 million rows/s., 5.18 GB/s.)\r\n\r\nWITH\r\n    max((number, rand())) AS mx,\r\n    argMax(rand(), number) AS arg,\r\n    argMax((rand(), number)) AS arg_tuple\r\nSELECT arg_tuple\r\nFROM numbers(1000000000)\r\n\r\nQuery id: 23fb54cc-a628-4696-ba85-9e2b44d1d515\r\n\r\n\u250c\u2500arg_tuple\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (3503270733,999999999) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 1.568 sec. Processed 1.00 billion rows, 8.00 GB (637.80 million rows/s., 5.10 GB/s.)\r\n\r\nWITH\r\n    max((number, rand())) AS mx,\r\n    argMax(rand(), number) AS arg,\r\n    argMax((rand(), number)) AS arg_tuple\r\nSELECT mx\r\nFROM numbers(1000000000)\r\n\r\nQuery id: e6d7f855-753f-4073-afd0-a900bb63c21a\r\n\r\n\u250c\u2500mx\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (999999999,2712516406) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 116.562 sec. Processed 1.00 billion rows, 8.00 GB (8.58 million rows/s., 68.64 MB/s.)\r\n\r\nSELECT argMax(((number, rand()), number))\r\nFROM numbers(1000000000)\r\n\r\nQuery id: 958e8ff3-3ef8-4fae-9e4f-6f5f6d7d2060\r\n\r\n\u250c\u2500argMax(tuple(tuple(number, rand()), number))\u2500\u2510\r\n\u2502 ((999999999,206382673),999999999)            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 71.488 sec. Processed 1.00 billion rows, 8.00 GB (13.99 million rows/s., 111.91 MB/s.)\r\n\r\n```\r\n\r\nmax is super slow with tuples.\r\n\n@ildus \r\n\r\n> I'm struggling to find the point of -SimpleState with argMax for two arguments, since the result value doesn't contain enough data to use it further. I'll look into how to fix that for tuple case.\r\n\r\n> result value doesn't contain enough data to use it further. I'll look into how to fix that for tuple case.\r\n\r\nBut it can be possible to fix it, so any argMax with -SimpleState would produce tuple as output.\r\n\r\nActually it make sense, because it returning SimpleAggregateFunction datatype.\r\n\r\n```\r\nSELECT toTypeName(maxSimpleState(1))\r\n\r\nQuery id: 4a534197-bb6a-4371-813f-a2bb2801cfcb\r\n\r\n\u250c\u2500toTypeName(maxSimpleState(1))\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 SimpleAggregateFunction(max, UInt8) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSo it would produce correct table schema for MV with inner table.\r\n\n@amosbird  interesting, I guess `max` with reversed arguments could do the same, I don't see any differences on top of my mind.\nand yes, `max` should be slower since it works on the outer tuple column, and `argMax` will work with inner columns directly.\n```\r\nSELECT argMax(number, number) FROM numbers(100000000)\r\n1 rows in set. Elapsed: 0.143 sec. Processed 100.03 million rows, 800.21 MB (697.61 million rows/s., 5.58 GB/s.) \r\n\r\nselect max( tuple(number, number) ) from numbers(100000000);\r\n1 rows in set. Elapsed: 15.552 sec. Processed 100.03 million rows, 800.21 MB (6.43 million rows/s., 51.46 MB/s.) \r\n```\r\n\r\nLooks like \"ClickHouse \u0442\u043e\u0440\u043c\u043e\u0437\u0438\u0442\" :)\n@filimonov to be fair comparison should be between tuples :) \r\n```\r\nSELECT argMax(tuple(number, number)) FROM numbers(100000000)\r\n1 rows in set. Elapsed: 4.440 sec. Processed 100.03 million rows, 800.21 MB (22.53 million rows/s., 180.22 MB/s.)\r\n\r\nselect max( tuple(number, number) ) from numbers(100000000);\r\n1 rows in set. Elapsed: 140.682 sec. Processed 100.03 million rows, 800.21 MB (711.01 thousand rows/s., 5.69 MB/s.)\r\n```",
  "created_at": "2021-04-20T21:25:47Z",
  "modified_files": [
    "docs/en/sql-reference/aggregate-functions/reference/argmax.md",
    "docs/en/sql-reference/aggregate-functions/reference/argmin.md",
    "docs/en/sql-reference/data-types/simpleaggregatefunction.md",
    "src/AggregateFunctions/AggregateFunctionArgMinMax.h",
    "src/AggregateFunctions/Helpers.h",
    "src/AggregateFunctions/HelpersMinMaxAny.h",
    "src/AggregateFunctions/IAggregateFunction.h",
    "src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00027_argMinMax.reference",
    "tests/queries/0_stateless/00027_argMinMax.sql",
    "b/tests/queries/0_stateless/00027_simple_argMinArray.reference",
    "b/tests/queries/0_stateless/00027_simple_argMinArray.sql",
    "tests/queries/0_stateless/00915_simple_aggregate_function.reference",
    "tests/queries/0_stateless/00915_simple_aggregate_function.sql"
  ]
}