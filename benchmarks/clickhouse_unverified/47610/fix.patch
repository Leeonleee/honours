diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 62005c76ce05..f6727bad0e82 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -608,7 +608,8 @@ if (ENABLE_TESTS)
         dbms
         clickhouse_common_config
         clickhouse_common_zookeeper
-        string_utils)
+        string_utils
+        hilite_comparator)
 
     if (TARGET ch_contrib::simdjson)
         target_link_libraries(unit_tests_dbms PRIVATE ch_contrib::simdjson)
diff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp
index e28e863c21ff..196681a8801b 100644
--- a/src/Parsers/ASTCreateQuery.cpp
+++ b/src/Parsers/ASTCreateQuery.cpp
@@ -440,10 +440,10 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
     if (select)
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "") << " AS"
-                      << (comment ? "(" : "")
-                      << settings.nl_or_ws << (settings.hilite ? hilite_none : "");
+                      << settings.nl_or_ws
+                      << (comment ? "(" : "") << (settings.hilite ? hilite_none : "");
         select->formatImpl(settings, state, frame);
-        settings.ostr << (comment ? ")" : "");
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << (comment ? ")" : "") << (settings.hilite ? hilite_none : "");
     }
 
     if (comment)
diff --git a/src/Parsers/ASTDictionary.cpp b/src/Parsers/ASTDictionary.cpp
index 66c1c3791b88..e33a7de6836f 100644
--- a/src/Parsers/ASTDictionary.cpp
+++ b/src/Parsers/ASTDictionary.cpp
@@ -161,8 +161,9 @@ void ASTDictionary::formatImpl(const FormatSettings & settings, FormatState & st
 
     if (source)
     {
-        settings.ostr << (settings.hilite ? hilite_keyword : "") << settings.nl_or_ws << "SOURCE("
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << settings.nl_or_ws << "SOURCE"
             << (settings.hilite ? hilite_none : "");
+        settings.ostr << "(";
         source->formatImpl(settings, state, frame);
         settings.ostr << ")";
     }
diff --git a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp
index 760b96b09271..daf708c9478c 100644
--- a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp
+++ b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp
@@ -56,16 +56,16 @@ void ASTDictionaryAttributeDeclaration::formatImpl(const FormatSettings & settin
     }
 
     if (hierarchical)
-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "HIERARCHICAL";
+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "HIERARCHICAL" << (settings.hilite ? hilite_none : "");
 
     if (bidirectional)
-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "BIDIRECTIONAL";
+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "BIDIRECTIONAL" << (settings.hilite ? hilite_none : "");
 
     if (injective)
-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "INJECTIVE";
+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "INJECTIVE" << (settings.hilite ? hilite_none : "");
 
     if (is_object_id)
-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "IS_OBJECT_ID";
+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "IS_OBJECT_ID" << (settings.hilite ? hilite_none : "");
 }
 
 }
diff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp
index fa4874d89b6a..99c2dbabdd7f 100644
--- a/src/Parsers/ASTFunction.cpp
+++ b/src/Parsers/ASTFunction.cpp
@@ -692,12 +692,15 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format
     {
         std::string nl_or_nothing = settings.one_line ? "" : "
";
         std::string indent_str = settings.one_line ? "" : std::string(4u * frame.indent, ' ');
-        settings.ostr << (settings.hilite ? hilite_function : "") << name << "(" << nl_or_nothing;
+        settings.ostr << (settings.hilite ? hilite_function : "") << name << (settings.hilite ? hilite_none : "");
+        settings.ostr << (settings.hilite ? hilite_function : "") << "(" << (settings.hilite ? hilite_none : "");
+        settings.ostr << nl_or_nothing;
         FormatStateStacked frame_nested = frame;
         frame_nested.need_parens = false;
         ++frame_nested.indent;
         query->formatImpl(settings, state, frame_nested);
-        settings.ostr << nl_or_nothing << indent_str << ")";
+        settings.ostr << nl_or_nothing << indent_str;
+        settings.ostr << (settings.hilite ? hilite_function : "") << ")" << (settings.hilite ? hilite_none : "");
         return;
     }
 
diff --git a/src/Parsers/ASTKillQueryQuery.cpp b/src/Parsers/ASTKillQueryQuery.cpp
index 8bf99312544d..a3c0f48f28aa 100644
--- a/src/Parsers/ASTKillQueryQuery.cpp
+++ b/src/Parsers/ASTKillQueryQuery.cpp
@@ -29,11 +29,13 @@ void ASTKillQueryQuery::formatQueryImpl(const FormatSettings & settings, FormatS
             break;
     }
 
+    settings.ostr << (settings.hilite ? hilite_none : "");
+
     formatOnCluster(settings);
 
     if (where_expression)
     {
-        settings.ostr << " WHERE " << (settings.hilite ? hilite_none : "");
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << " WHERE " << (settings.hilite ? hilite_none : "");
         where_expression->formatImpl(settings, state, frame);
     }
 
diff --git a/src/Parsers/ASTWithAlias.cpp b/src/Parsers/ASTWithAlias.cpp
index 88f6568a7196..1b5397654fd8 100644
--- a/src/Parsers/ASTWithAlias.cpp
+++ b/src/Parsers/ASTWithAlias.cpp
@@ -20,7 +20,9 @@ void ASTWithAlias::formatImpl(const FormatSettings & settings, FormatState & sta
     /// This is needed because the query can become extraordinary large after substitution of aliases.
     if (!alias.empty() && !state.printed_asts_with_alias.emplace(frame.current_select, alias, getTreeHash()).second)
     {
+        settings.ostr << (settings.hilite ? IAST::hilite_identifier : "");
         settings.writeIdentifier(alias);
+        settings.ostr << (settings.hilite ? IAST::hilite_none : "");
     }
     else
     {
diff --git a/src/Parsers/ASTWithElement.cpp b/src/Parsers/ASTWithElement.cpp
index b517509c4bc3..c2cb1177c171 100644
--- a/src/Parsers/ASTWithElement.cpp
+++ b/src/Parsers/ASTWithElement.cpp
@@ -18,7 +18,9 @@ void ASTWithElement::formatImpl(const FormatSettings & settings, FormatState & s
 {
     std::string indent_str = settings.one_line ? "" : std::string(4 * frame.indent, ' ');
 
+    settings.ostr << (settings.hilite ? hilite_alias : "");
     settings.writeIdentifier(name);
+    settings.ostr << (settings.hilite ? hilite_none : "");
     settings.ostr << (settings.hilite ? hilite_keyword : "") << " AS" << (settings.hilite ? hilite_none : "");
     settings.ostr << settings.nl_or_ws << indent_str;
     dynamic_cast<const ASTWithAlias &>(*subquery).formatImplWithoutAlias(settings, state, frame);
diff --git a/src/Parsers/CMakeLists.txt b/src/Parsers/CMakeLists.txt
index 73d46593e042..d5cf2bd47849 100644
--- a/src/Parsers/CMakeLists.txt
+++ b/src/Parsers/CMakeLists.txt
@@ -22,3 +22,7 @@ endif()
 if (ENABLE_FUZZING)
     add_subdirectory(fuzzers)
 endif()
+
+if (ENABLE_TESTS)
+    add_subdirectory(HiliteComparator)
+endif ()
diff --git a/src/Parsers/HiliteComparator/CMakeLists.txt b/src/Parsers/HiliteComparator/CMakeLists.txt
new file mode 100644
index 000000000000..0e68b19be087
--- /dev/null
+++ b/src/Parsers/HiliteComparator/CMakeLists.txt
@@ -0,0 +1,7 @@
+include("${ClickHouse_SOURCE_DIR}/cmake/dbms_glob_sources.cmake")
+
+add_headers_and_sources(hilite_comparator .)
+
+add_library(hilite_comparator ${hilite_comparator_sources})
+
+target_link_libraries(hilite_comparator PRIVATE dbms)
diff --git a/src/Parsers/HiliteComparator/HiliteComparator.cpp b/src/Parsers/HiliteComparator/HiliteComparator.cpp
new file mode 100644
index 000000000000..0c12c6e821cc
--- /dev/null
+++ b/src/Parsers/HiliteComparator/HiliteComparator.cpp
@@ -0,0 +1,98 @@
+#include "HiliteComparator.h"
+
+namespace HiliteComparator
+{
+
+void consume_hilites(const char * & ptr, Hilite * last_hilite)
+{
+    while (true)
+    {
+        bool changed_hilite = false;
+        for (Hilite hilite : hilites)
+        {
+            if (std::string_view(ptr).starts_with(hilite))
+            {
+                ptr += strlen(hilite);
+                changed_hilite = true;
+                if (last_hilite != nullptr)
+                    *last_hilite = hilite;
+            }
+        }
+        if (!changed_hilite)
+            break;
+    }
+}
+
+bool are_equal_with_hilites_removed(std::string_view left, std::string_view right)
+{
+    return remove_hilites(left) == remove_hilites(right);
+}
+
+String remove_hilites(std::string_view string)
+{
+    const char * ptr = string.begin();
+    String string_without_hilites;
+    while (true)
+    {
+        consume_hilites(ptr);
+        if (ptr == string.end())
+            return string_without_hilites;
+        string_without_hilites += *(ptr++);
+    }
+}
+
+/*
+ * Hilited queries cannot be compared symbol-by-symbol, as there's some frivolousness introduced with the hilites. Specifically:
+ * 1. Whitespaces could be hilited with any hilite type.
+ * 2. Hilite could or could be not reset with hilite_none before the next hilite, i.e. the following strings a and b are equal:
+ *      a. hilite_keyword foo hilite_none hilite_operator +
+ *      b. hilite_keyword foo hilite_operator +
+ */
+bool are_equal_with_hilites(std::string_view left, std::string_view right, bool check_end_without_hilite)
+{
+    const char * left_it = left.begin();
+    const char * right_it = right.begin();
+    Hilite left_hilite = DB::IAST::hilite_none;
+    Hilite right_hilite = DB::IAST::hilite_none;
+
+    while (true)
+    {
+        // For each argument, consume all prefix hilites, and update the current hilite to be the last one.
+        consume_hilites(left_it, &left_hilite);
+        consume_hilites(right_it, &right_hilite);
+
+        if (left_it == left.end() && right_it == right.end())
+        {
+            if (left_hilite != right_hilite)
+                return false;
+            if (check_end_without_hilite)
+                if (left_hilite != DB::IAST::hilite_none)
+                    throw std::logic_error("Expected string ends with a hilite");
+            return true;
+        }
+
+        if (left_it == left.end() || right_it == right.end())
+            return false;
+
+        // Lookup one character.
+        // Check characters match.
+        if (*left_it != *right_it)
+            return false;
+
+        // Check hilites match if it's not a whitespace.
+        if (!std::isspace(*left_it) && left_hilite != right_hilite)
+            return false;
+
+        // Consume one character.
+        left_it++;
+        right_it++;
+    }
+}
+
+bool are_equal_with_hilites_and_end_without_hilite(std::string_view left, std::string_view right)
+{
+    return are_equal_with_hilites(left, right, true);
+}
+
+
+}
diff --git a/src/Parsers/HiliteComparator/HiliteComparator.h b/src/Parsers/HiliteComparator/HiliteComparator.h
new file mode 100644
index 000000000000..137c5892b3a7
--- /dev/null
+++ b/src/Parsers/HiliteComparator/HiliteComparator.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include <Parsers/IAST.h>
+#include <string>
+#include <string_view>
+
+
+namespace HiliteComparator
+{
+
+using Hilite = const char *;
+
+static const std::vector<Hilite> hilites = {
+        DB::IAST::hilite_keyword,
+        DB::IAST::hilite_identifier,
+        DB::IAST::hilite_function,
+        DB::IAST::hilite_operator,
+        DB::IAST::hilite_alias,
+        DB::IAST::hilite_substitution,
+        DB::IAST::hilite_none
+    };
+
+/*
+ * Consume all prefix hilites, by moving `ptr` to
+ * If `last_hilite` is not `nullptr`, update the last hilite to be the last hilite of the prefix hilites.
+ */
+void consume_hilites(const char * & ptr, Hilite * last_hilite = nullptr);
+
+String remove_hilites(std::string_view string);
+
+/*
+ * Copies both strings, for the simplicity of the implementation.
+ */
+bool are_equal_with_hilites_removed(std::string_view left, std::string_view right);
+
+/*
+ * Hilited queries cannot be compared symbol-by-symbol, as there's some frivolousness introduced with the hilites. Specifically:
+ * 1. Whitespaces could be hilited with any hilite type.
+ * 2. Hilite could or could be not reset with hilite_none before the next hilite, i.e. the following strings a and b are equal:
+ *      a. hilite_keyword foo hilite_none hilite_operator +
+ *      b. hilite_keyword foo hilite_operator +
+ */
+bool are_equal_with_hilites(std::string_view left, std::string_view right, bool check_end_without_hilite);
+
+// Google tests's ASSERT_PRED_2 doesn't see overloads with default parameter values.
+bool are_equal_with_hilites_and_end_without_hilite(std::string_view left, std::string_view right);
+
+}
