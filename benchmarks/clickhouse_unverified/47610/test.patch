diff --git a/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp b/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp
new file mode 100644
index 000000000000..785e83d09cc8
--- /dev/null
+++ b/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp
@@ -0,0 +1,98 @@
+#include <gtest/gtest.h>
+#include <Parsers/IAST.h>
+#include <Parsers/HiliteComparator/HiliteComparator.h>
+
+using namespace HiliteComparator;
+
+TEST(HiliteComparator, ConsumeHilites)
+{
+    using namespace DB;
+    // The order is different from the order in HILITES on purpose.
+    String s;
+    s += IAST::hilite_keyword;
+    s += IAST::hilite_alias;
+    s += IAST::hilite_identifier;
+    s += IAST::hilite_none;
+    s += IAST::hilite_operator;
+    s += IAST::hilite_substitution;
+    s += IAST::hilite_function;
+    s += "test";
+    s += IAST::hilite_keyword;
+    const char * ptr = s.c_str();
+    const char * expected_ptr = strchr(ptr, 't');
+    const char * last_hilite = nullptr;
+    consume_hilites(ptr, &last_hilite);
+    ASSERT_EQ(expected_ptr, ptr);
+    ASSERT_TRUE(last_hilite != nullptr);
+    ASSERT_EQ(IAST::hilite_function, last_hilite);
+}
+
+TEST(HiliteComparator, RemoveHilites)
+{
+    using namespace DB;
+    String s;
+    s += IAST::hilite_keyword;
+    s += "te";
+    s += IAST::hilite_alias;
+    s += IAST::hilite_identifier;
+    s += "s";
+    s += IAST::hilite_none;
+    s += "t";
+    s += IAST::hilite_operator;
+    s += IAST::hilite_substitution;
+    s += IAST::hilite_function;
+    ASSERT_EQ("test", remove_hilites(s));
+}
+
+TEST(HiliteComparator, AreEqualWithHilites)
+{
+    using namespace DB;
+    String s = IAST::hilite_keyword;
+    ASSERT_THROW(are_equal_with_hilites(s, s, true), std::logic_error);
+    ASSERT_TRUE(are_equal_with_hilites(s, s, false));
+}
+
+TEST(HiliteComparator, AreEqualWithHilitesAndEndWithoutHilite)
+{
+    using namespace DB;
+
+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, "", "");
+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, "", IAST::hilite_none);
+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, IAST::hilite_none, "");
+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, IAST::hilite_none, IAST::hilite_none);
+
+    {
+        String s;
+        s += IAST::hilite_none;
+        s += "select";
+        s += IAST::hilite_none;
+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, s, "select");
+    }
+
+    {
+        String s;
+        s += DB::IAST::hilite_none;
+        s += "
 sel";
+        s += DB::IAST::hilite_none;
+        s += "ect";
+        s += DB::IAST::hilite_none;
+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, s, "
 select");
+    }
+
+    {
+        String left;
+        left += DB::IAST::hilite_keyword;
+        left += "keyword long";
+        left += DB::IAST::hilite_none;
+
+        String right;
+        right += DB::IAST::hilite_keyword;
+        right += "keyword";
+        right += DB::IAST::hilite_none;
+        right += " ";
+        right += DB::IAST::hilite_keyword;
+        right += "long";
+        right += DB::IAST::hilite_none;
+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, left, right);
+    }
+}
diff --git a/src/Parsers/tests/gtest_format_hiliting.cpp b/src/Parsers/tests/gtest_format_hiliting.cpp
new file mode 100644
index 000000000000..d0ce8f2c897e
--- /dev/null
+++ b/src/Parsers/tests/gtest_format_hiliting.cpp
@@ -0,0 +1,133 @@
+#include <unordered_set>
+
+#include <Parsers/IAST.h>
+#include <Parsers/ParserQuery.h>
+#include <Parsers/parseQuery.h>
+#include <Parsers/HiliteComparator/HiliteComparator.h>
+#include <gtest/gtest.h>
+#include <Common/StackTrace.h>
+
+
+String hilite(const String & s, const char * hilite_type)
+{
+    return hilite_type + s + DB::IAST::hilite_none;
+}
+
+String keyword(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_keyword);
+}
+
+String identifier(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_identifier);
+}
+
+String alias(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_alias);
+}
+
+String op(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_operator);
+}
+
+String function(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_function);
+}
+
+String substitution(const String & s)
+{
+    return hilite(s, DB::IAST::hilite_substitution);
+}
+
+
+void compare(const String & expected, const String & query)
+{
+    using namespace DB;
+    ParserQuery parser(query.data() + query.size());
+    ASTPtr ast = parseQuery(parser, query, 0, 0);
+
+    WriteBufferFromOwnString write_buffer;
+    IAST::FormatSettings settings(write_buffer, true);
+    settings.hilite = true;
+    ast->format(settings);
+
+    ASSERT_PRED2(HiliteComparator::are_equal_with_hilites_removed, expected, write_buffer.str());
+    ASSERT_PRED2(HiliteComparator::are_equal_with_hilites_and_end_without_hilite, expected, write_buffer.str());
+}
+
+const std::vector<std::pair<std::string, std::string>> expected_and_query_pairs = {
+    // Simple select
+    {
+        keyword("SELECT ") + "* " + keyword("FROM ") + identifier("table"),
+        "select * from table"
+    },
+
+    // ASTWithElement
+    {
+        keyword("WITH ") + alias("alias ") + keyword("AS ")
+            + "(" + keyword("SELECT ") + "* " + keyword("FROM ") + identifier("table") + ") "
+            + keyword("SELECT ") + "* " + keyword("FROM ") + identifier("table"),
+        "with alias as (select * from table) select * from table"
+    },
+
+    // ASTWithAlias
+    {
+        keyword("SELECT ") + identifier("a ") + op("+ ") + "1 " + keyword("AS ") + alias("b") + ", " + identifier("b"),
+        "select a + 1 as b, b"
+    },
+
+    // ASTFunction
+    {
+        keyword("SELECT ") + "* " + keyword("FROM ")
+            + function("view(") + keyword("SELECT ") + "* " + keyword("FROM ") + identifier("table") + function(")"),
+        "select * from view(select * from table)"
+    },
+
+    // ASTDictionaryAttributeDeclaration
+    {
+        keyword("CREATE DICTIONARY ") + "name "
+            + "(`Name` " + function("ClickHouseDataType ")
+            + keyword("DEFAULT ") + "'' "
+            + keyword("EXPRESSION ") + function("rand64() ")
+            + keyword("IS_OBJECT_ID") + ")",
+        "CREATE DICTIONARY name (`Name` ClickHouseDataType DEFAULT '' EXPRESSION rand64() IS_OBJECT_ID)"
+    },
+
+    // ASTDictionary, SOURCE keyword
+    {
+        keyword("CREATE DICTIONARY ") + "name "
+            + "(`Name` " + function("ClickHouseDataType ")
+            + keyword("DEFAULT ") + "'' "
+            + keyword("EXPRESSION ") + function("rand64() ")
+            + keyword("IS_OBJECT_ID") + ") "
+            + keyword("SOURCE") + "(" + keyword("FILE") + "(" + keyword("PATH ") + "'path'))",
+        "CREATE DICTIONARY name (`Name` ClickHouseDataType DEFAULT '' EXPRESSION rand64() IS_OBJECT_ID) "
+        "SOURCE(FILE(PATH 'path'))"
+    },
+
+    // ASTKillQueryQuery
+    {
+        keyword("KILL QUERY ON CLUSTER ") + "clustername "
+            + keyword("WHERE ") + identifier("user ") + op("= ") + "'username' "
+            + keyword("SYNC"),
+        "KILL QUERY ON CLUSTER clustername WHERE user = 'username' SYNC"
+    },
+
+    // ASTCreateQuery
+    {
+        keyword("CREATE TABLE ") + "name " + keyword("AS (SELECT ") + "*" + keyword(") ")
+            + keyword("COMMENT ") + "'hello'",
+        "CREATE TABLE name AS (SELECT *) COMMENT 'hello'"
+    },
+};
+
+
+TEST(FormatHiliting, Queries)
+{
+    for (const auto & [expected, query] : expected_and_query_pairs)
+        compare(expected, query);
+}
