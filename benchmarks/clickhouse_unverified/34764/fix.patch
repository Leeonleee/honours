diff --git a/src/DataTypes/EnumValues.h b/src/DataTypes/EnumValues.h
index 17c292c5551f..0747cd4aed8c 100644
--- a/src/DataTypes/EnumValues.h
+++ b/src/DataTypes/EnumValues.h
@@ -29,7 +29,7 @@ class EnumValues : public IHints<1, EnumValues<T>>
     void fillMaps();
 
 public:
-    EnumValues(const Values & values_);
+    explicit EnumValues(const Values & values_);
 
     const Values & getValues() const { return values; }
 
diff --git a/src/Interpreters/Aggregator.h b/src/Interpreters/Aggregator.h
index 05c9133cb352..3457e01f98f6 100644
--- a/src/Interpreters/Aggregator.h
+++ b/src/Interpreters/Aggregator.h
@@ -184,7 +184,9 @@ struct AggregationMethodOneNumber
     AggregationMethodOneNumber() = default;
 
     template <typename Other>
-    AggregationMethodOneNumber(const Other & other) : data(other.data) {}
+    explicit AggregationMethodOneNumber(const Other & other) : data(other.data)
+    {
+    }
 
     /// To use one `Method` in different threads, use different `State`.
     using State = ColumnsHashing::HashMethodOneNumber<typename Data::value_type,
@@ -219,7 +221,9 @@ struct AggregationMethodString
     AggregationMethodString() = default;
 
     template <typename Other>
-    AggregationMethodString(const Other & other) : data(other.data) {}
+    explicit AggregationMethodString(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodString<typename Data::value_type, Mapped>;
 
@@ -247,7 +251,9 @@ struct AggregationMethodStringNoCache
     AggregationMethodStringNoCache() = default;
 
     template <typename Other>
-    AggregationMethodStringNoCache(const Other & other) : data(other.data) {}
+    explicit AggregationMethodStringNoCache(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodString<typename Data::value_type, Mapped, true, false>;
 
@@ -275,7 +281,9 @@ struct AggregationMethodFixedString
     AggregationMethodFixedString() = default;
 
     template <typename Other>
-    AggregationMethodFixedString(const Other & other) : data(other.data) {}
+    explicit AggregationMethodFixedString(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodFixedString<typename Data::value_type, Mapped>;
 
@@ -302,7 +310,9 @@ struct AggregationMethodFixedStringNoCache
     AggregationMethodFixedStringNoCache() = default;
 
     template <typename Other>
-    AggregationMethodFixedStringNoCache(const Other & other) : data(other.data) {}
+    explicit AggregationMethodFixedStringNoCache(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodFixedString<typename Data::value_type, Mapped, true, false>;
 
@@ -373,7 +383,9 @@ struct AggregationMethodKeysFixed
     AggregationMethodKeysFixed() = default;
 
     template <typename Other>
-    AggregationMethodKeysFixed(const Other & other) : data(other.data) {}
+    explicit AggregationMethodKeysFixed(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodKeysFixed<
         typename Data::value_type,
@@ -462,7 +474,9 @@ struct AggregationMethodSerialized
     AggregationMethodSerialized() = default;
 
     template <typename Other>
-    AggregationMethodSerialized(const Other & other) : data(other.data) {}
+    explicit AggregationMethodSerialized(const Other & other) : data(other.data)
+    {
+    }
 
     using State = ColumnsHashing::HashMethodSerialized<typename Data::value_type, Mapped>;
 
diff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp
index 90e10abfa927..dd458967fc7b 100644
--- a/src/Storages/AlterCommands.cpp
+++ b/src/Storages/AlterCommands.cpp
@@ -516,8 +516,13 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)
                     });
 
             if (insert_it == metadata.secondary_indices.end())
-                throw Exception("Wrong index name. Cannot find index " + backQuote(after_index_name) + " to insert after.",
-                        ErrorCodes::BAD_ARGUMENTS);
+            {
+                auto hints = metadata.secondary_indices.getHints(after_index_name);
+                auto hints_string = !hints.empty() ? ", may be you meant: " + toString(hints) : "";
+                throw Exception(
+                    "Wrong index name. Cannot find index " + backQuote(after_index_name) + " to insert after" + hints_string,
+                    ErrorCodes::BAD_ARGUMENTS);
+            }
 
             ++insert_it;
         }
@@ -540,7 +545,10 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)
             {
                 if (if_exists)
                     return;
-                throw Exception("Wrong index name. Cannot find index " + backQuote(index_name) + " to drop.", ErrorCodes::BAD_ARGUMENTS);
+                auto hints = metadata.secondary_indices.getHints(index_name);
+                auto hints_string = !hints.empty() ? ", may be you meant: " + toString(hints) : "";
+                throw Exception(
+                    "Wrong index name. Cannot find index " + backQuote(index_name) + " to drop" + hints_string, ErrorCodes::BAD_ARGUMENTS);
             }
 
             metadata.secondary_indices.erase(erase_it);
@@ -582,7 +590,7 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)
         {
             if (if_exists)
                 return;
-            throw Exception("Wrong constraint name. Cannot find constraint `" + constraint_name + "` to drop.",
+            throw Exception("Wrong constraint name. Cannot find constraint `" + constraint_name + "` to drop",
                     ErrorCodes::BAD_ARGUMENTS);
         }
         constraints.erase(erase_it);
diff --git a/src/Storages/ConstraintsDescription.h b/src/Storages/ConstraintsDescription.h
index ad8bd371f38c..a5095a79ccb7 100644
--- a/src/Storages/ConstraintsDescription.h
+++ b/src/Storages/ConstraintsDescription.h
@@ -14,7 +14,7 @@ struct ConstraintsDescription
 {
 public:
     ConstraintsDescription() { update(); }
-    ConstraintsDescription(const ASTs & constraints_);
+    explicit ConstraintsDescription(const ASTs & constraints_);
     ConstraintsDescription(const ConstraintsDescription & other);
     ConstraintsDescription & operator=(const ConstraintsDescription & other);
 
diff --git a/src/Storages/IndicesDescription.cpp b/src/Storages/IndicesDescription.cpp
index 9cdf96951726..a0a1bcbce2dd 100644
--- a/src/Storages/IndicesDescription.cpp
+++ b/src/Storages/IndicesDescription.cpp
@@ -172,4 +172,13 @@ ExpressionActionsPtr IndicesDescription::getSingleExpressionForIndices(const Col
     return ExpressionAnalyzer(combined_expr_list, syntax_result, context).getActions(false);
 }
 
+Names IndicesDescription::getAllRegisteredNames() const
+{
+    Names result;
+    for (const auto & index : *this)
+    {
+        result.emplace_back(index.name);
+    }
+    return result;
+}
 }
diff --git a/src/Storages/IndicesDescription.h b/src/Storages/IndicesDescription.h
index 7071ec89890a..72e0748778f7 100644
--- a/src/Storages/IndicesDescription.h
+++ b/src/Storages/IndicesDescription.h
@@ -8,6 +8,7 @@
 #include <Interpreters/ExpressionActions.h>
 #include <Parsers/IAST_fwd.h>
 #include <Storages/ColumnsDescription.h>
+#include <Common/NamePrompter.h>
 
 namespace DB
 {
@@ -61,7 +62,7 @@ struct IndexDescription
 };
 
 /// All secondary indices in storage
-struct IndicesDescription : public std::vector<IndexDescription>
+struct IndicesDescription : public std::vector<IndexDescription>, IHints<1, IndicesDescription>
 {
     /// Index with name exists
     bool has(const String & name) const;
@@ -72,6 +73,9 @@ struct IndicesDescription : public std::vector<IndexDescription>
 
     /// Return common expression for all stored indices
     ExpressionActionsPtr getSingleExpressionForIndices(const ColumnsDescription & columns, ContextPtr context) const;
+
+public:
+    Names getAllRegisteredNames() const override;
 };
 
 }
