diff --git a/src/Processors/Formats/Impl/BinaryRowInputFormat.cpp b/src/Processors/Formats/Impl/BinaryRowInputFormat.cpp
index 36b57e242d73..2d820a5985f3 100644
--- a/src/Processors/Formats/Impl/BinaryRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/BinaryRowInputFormat.cpp
@@ -28,7 +28,7 @@ bool BinaryRowInputFormat::readRow(MutableColumns & columns, RowReadExtension &)
 
 void BinaryRowInputFormat::readPrefix()
 {
-    /// NOTE The header is completely ignored. This can be easily improved.
+    /// NOTE: The header is completely ignored. This can be easily improved.
 
     UInt64 columns = 0;
     String tmp;
diff --git a/src/Server/HTTP/HTMLForm.cpp b/src/Server/HTTP/HTMLForm.cpp
index 7a87f484b5cb..9e0f74dcc331 100644
--- a/src/Server/HTTP/HTMLForm.cpp
+++ b/src/Server/HTTP/HTMLForm.cpp
@@ -244,7 +244,7 @@ bool HTMLForm::MultipartReadBuffer::skipToNextBoundary()
 
     while (!in.eof())
     {
-        auto line = readLine();
+        auto line = readLine(true);
         if (startsWith(line, boundary))
         {
             set(in.position(), 0);
@@ -256,29 +256,36 @@ bool HTMLForm::MultipartReadBuffer::skipToNextBoundary()
     throw Poco::Net::HTMLFormException("No boundary line found");
 }
 
-std::string HTMLForm::MultipartReadBuffer::readLine(bool strict)
+std::string HTMLForm::MultipartReadBuffer::readLine(bool append_crlf)
 {
     std::string line;
     char ch = 0;  // silence "uninitialized" warning from gcc-*
 
-    while (in.read(ch) && ch != '\r' && ch != '
')
+    /// If we don't append CRLF, it means that we may have to prepend CRLF from previous content line, which wasn't the boundary.
+    if (in.read(ch))
         line += ch;
-
-    if (in.eof())
-    {
-        if (strict)
-            throw Poco::Net::HTMLFormException("Unexpected end of message");
+    if (in.read(ch))
+        line += ch;
+    if (append_crlf && line == "\r
")
         return line;
-    }
-
-    line += ch;
 
-    if (ch == '\r')
+    while (!in.eof())
     {
-        if (!in.read(ch) || ch != '
')
-            throw Poco::Net::HTMLFormException("No CRLF found");
-        else
+        while (in.read(ch) && ch != '\r')
             line += ch;
+
+        if (in.eof()) break;
+
+        assert(ch == '\r');
+
+        if (in.peek(ch) && ch == '
')
+        {
+            in.ignore();
+            if (append_crlf) line += "\r
";
+            break;
+        }
+
+        line += ch;
     }
 
     return line;
@@ -300,19 +307,12 @@ bool HTMLForm::MultipartReadBuffer::nextImpl()
     /// FIXME: there is an extra copy because we cannot traverse PeekableBuffer from checkpoint to position()
     ///        since it may store different data parts in different sub-buffers,
     ///        anyway calling makeContinuousMemoryFromCheckpointToPos() will also make an extra copy.
-    std::string line = readLine(false);
-
     /// According to RFC2046 the preceding CRLF is a part of boundary line.
-    if (line == "\r
")
-    {
-        line = readLine(false);
-        boundary_hit = startsWith(line, boundary);
-        if (!boundary_hit) line = "\r
";
-    }
-    else
-        boundary_hit = startsWith(line, boundary);
+    std::string line = readLine(false);
+    boundary_hit = startsWith(line, "\r
" + boundary);
+    bool has_next = !boundary_hit && !line.empty();
 
-    if (!line.empty())
+    if (has_next)
         /// If we don't make sure that memory is contiguous then situation may happen, when part of the line is inside internal memory
         /// and other part is inside sub-buffer, thus we'll be unable to setup our working buffer properly.
         in.makeContinuousMemoryFromCheckpointToPos();
@@ -323,7 +323,7 @@ bool HTMLForm::MultipartReadBuffer::nextImpl()
     /// Limit readable data to a single line.
     BufferBase::set(in.position(), line.size(), 0);
 
-    return !boundary_hit && !line.empty();
+    return has_next;
 }
 
 }
diff --git a/src/Server/HTTP/HTMLForm.h b/src/Server/HTTP/HTMLForm.h
index 8d8fb0d1719f..ca6bb9048f14 100644
--- a/src/Server/HTTP/HTMLForm.h
+++ b/src/Server/HTTP/HTMLForm.h
@@ -118,7 +118,7 @@ class HTMLForm::MultipartReadBuffer : public ReadBuffer
     const std::string boundary;
     bool boundary_hit = true;
 
-    std::string readLine(bool strict = true);
+    std::string readLine(bool append_crlf);
 
     bool nextImpl() override;
 };
