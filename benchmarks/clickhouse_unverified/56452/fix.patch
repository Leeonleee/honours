diff --git a/src/Processors/QueryPlan/PartsSplitter.cpp b/src/Processors/QueryPlan/PartsSplitter.cpp
index 90f6f49826c7..8bf877cf8b94 100644
--- a/src/Processors/QueryPlan/PartsSplitter.cpp
+++ b/src/Processors/QueryPlan/PartsSplitter.cpp
@@ -241,10 +241,6 @@ ASTs buildFilters(const KeyDescription & primary_key, const std::vector<Values>
         ASTs values_ast;
         for (size_t i = 0; i < values.size(); ++i)
         {
-            /// NULL is treated as a terminator for > comparison.
-            if (values[i].isNull())
-                break;
-
             const auto & type = primary_key.data_types.at(i);
 
             // PK may contain functions of the table columns, so we need the actual PK AST with all expressions it contains.
@@ -255,25 +251,31 @@ ASTs buildFilters(const KeyDescription & primary_key, const std::vector<Values>
             if (type->isNullable())
             {
                 pks_ast.push_back(makeASTFunction("isNull", pk_ast));
-                values_ast.push_back(std::make_shared<ASTLiteral>(0));
+                values_ast.push_back(std::make_shared<ASTLiteral>(values[i].isNull() ? 1 : 0));
                 pk_ast = makeASTFunction("assumeNotNull", pk_ast);
             }
 
-            ASTPtr component_ast = std::make_shared<ASTLiteral>(values[i]);
-            auto decayed_type = removeNullable(removeLowCardinality(primary_key.data_types.at(i)));
-            // Values of some types (e.g. Date, DateTime) are stored in columns as numbers and we get them as just numbers from the index.
-            // So we need an explicit Cast for them.
-            if (isColumnedAsNumber(decayed_type->getTypeId()) && !isNumber(decayed_type->getTypeId()))
-                component_ast = makeASTFunction("cast", std::move(component_ast), std::make_shared<ASTLiteral>(decayed_type->getName()));
+            pks_ast.push_back(pk_ast);
 
-            pks_ast.push_back(std::move(pk_ast));
-            values_ast.push_back(std::move(component_ast));
+            // If value is null, the comparison is already complete by looking at the null mask column.
+            // Here we put the pk_ast as a placeholder: (pk_null_mask, pk_ast_not_null) > (value_is_null?, pk_ast_not_null).
+            if (values[i].isNull())
+            {
+                values_ast.push_back(pk_ast);
+            }
+            else
+            {
+                ASTPtr component_ast = std::make_shared<ASTLiteral>(values[i]);
+                auto decayed_type = removeNullable(removeLowCardinality(primary_key.data_types.at(i)));
+                // Values of some types (e.g. Date, DateTime) are stored in columns as numbers and we get them as just numbers from the index.
+                // So we need an explicit Cast for them.
+                if (isColumnedAsNumber(decayed_type->getTypeId()) && !isNumber(decayed_type->getTypeId()))
+                    component_ast = makeASTFunction("cast", std::move(component_ast), std::make_shared<ASTLiteral>(decayed_type->getName()));
+
+                values_ast.push_back(std::move(component_ast));
+            }
         }
 
-        /// It indicates (pk1, ...) > (NULL, ...), which is an always false predicate.
-        if (pks_ast.empty())
-            return std::make_shared<ASTLiteral>(0u);
-
         ASTPtr pk_columns_as_tuple = makeASTFunction("tuple", pks_ast);
         ASTPtr values_as_tuple = makeASTFunction("tuple", values_ast);
 
