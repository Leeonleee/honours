{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23044,
  "instance_id": "ClickHouse__ClickHouse-23044",
  "issue_numbers": [
    "20272"
  ],
  "base_commit": "97611faad096b7fc355ce24234e64c0aaa4ddebf",
  "patch": "diff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h\nindex e174261d76e6..1a962089d0c6 100644\n--- a/src/Functions/GatherUtils/Algorithms.h\n+++ b/src/Functions/GatherUtils/Algorithms.h\n@@ -82,7 +82,7 @@ inline ALWAYS_INLINE void writeSlice(const GenericArraySlice & slice, GenericArr\n         sink.current_offset += slice.size;\n     }\n     else\n-        throw Exception(\"Function writeSlice expect same column types for GenericArraySlice and GenericArraySink.\",\n+        throw Exception(\"Function writeSlice expects same column types for GenericArraySlice and GenericArraySink.\",\n                         ErrorCodes::LOGICAL_ERROR);\n }\n \n@@ -162,7 +162,7 @@ inline ALWAYS_INLINE void writeSlice(const GenericValueSlice & slice, GenericArr\n         ++sink.current_offset;\n     }\n     else\n-        throw Exception(\"Function writeSlice expect same column types for GenericValueSlice and GenericArraySink.\",\n+        throw Exception(\"Function writeSlice expects same column types for GenericValueSlice and GenericArraySink.\",\n                         ErrorCodes::LOGICAL_ERROR);\n }\n \n@@ -609,7 +609,7 @@ bool sliceHas(const GenericArraySlice & first, const GenericArraySlice & second)\n {\n     /// Generic arrays should have the same type in order to use column.compareAt(...)\n     if (!first.elements->structureEquals(*second.elements))\n-        return false;\n+        throw Exception(\"Function sliceHas expects same column types for slices.\", ErrorCodes::LOGICAL_ERROR);\n \n     auto impl = sliceHasImpl<search_type, GenericArraySlice, GenericArraySlice, sliceEqualElements, insliceEqualElements>;\n     return impl(first, second, nullptr, nullptr);\n@@ -670,7 +670,7 @@ void NO_INLINE arrayAllAny(FirstSource && first, SecondSource && second, ColumnU\n     auto & data = result.getData();\n     for (auto row : ext::range(0, size))\n     {\n-        data[row] = static_cast<UInt8>(sliceHas<search_type>(first.getWhole(), second.getWhole()) ? 1 : 0);\n+        data[row] = static_cast<UInt8>(sliceHas<search_type>(first.getWhole(), second.getWhole()));\n         first.next();\n         second.next();\n     }\ndiff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h\nindex fb9496e634fa..1b58c9418bf6 100644\n--- a/src/Functions/array/arrayIndex.h\n+++ b/src/Functions/array/arrayIndex.h\n@@ -5,6 +5,7 @@\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n@@ -13,9 +14,9 @@\n #include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/memcmpSmall.h>\n #include <Common/assert_cast.h>\n-#include \"Columns/ColumnLowCardinality.h\"\n-#include \"DataTypes/DataTypeLowCardinality.h\"\n-#include \"Interpreters/castColumn.h\"\n+#include <Columns/ColumnLowCardinality.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <Interpreters/castColumn.h>\n \n \n namespace DB\n@@ -373,11 +374,10 @@ class FunctionArrayIndex : public IFunction\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         if (!arguments[1]->onlyNull() && !allowArguments(array_type->getNestedType(), arguments[1]))\n-            throw Exception(\"Types of array and 2nd argument of function \\\"\"\n-                + getName() + \"\\\" must be identical up to nullability, cardinality, \"\n-                \"numeric types, or Enum and numeric type. Passed: \"\n-                + arguments[0]->getName() + \" and \" + arguments[1]->getName() + \".\",\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Types of array and 2nd argument of function `{}` must be identical up to nullability, cardinality, \"\n+                \"numeric types, or Enum and numeric type. Passed: {} and {}.\",\n+                getName(), arguments[0]->getName(), arguments[1]->getName());\n \n         return std::make_shared<DataTypeNumber<ResultType>>();\n     }\n@@ -494,86 +494,13 @@ class FunctionArrayIndex : public IFunction\n         inline void moveResult() { result_column = std::move(result); }\n     };\n \n-    static inline bool allowNested(const DataTypePtr & left, const DataTypePtr & right)\n-    {\n-        return ((isNativeNumber(left) || isEnum(left)) && isNativeNumber(right)) || left->equals(*right);\n-    }\n-\n     static inline bool allowArguments(const DataTypePtr & array_inner_type, const DataTypePtr & arg)\n     {\n-        if (allowNested(array_inner_type, arg))\n-            return true;\n-\n-        /// Nullable\n-\n-        const bool array_is_nullable = array_inner_type->isNullable();\n-        const bool arg_is_nullable = arg->isNullable();\n-\n-        const DataTypePtr arg_or_arg_nullable_nested = arg_is_nullable\n-            ? checkAndGetDataType<DataTypeNullable>(arg.get())->getNestedType()\n-            : arg;\n-\n-        if (array_is_nullable) // comparing Array(Nullable(T)) elem and U\n-        {\n-            const DataTypePtr array_nullable_nested =\n-                checkAndGetDataType<DataTypeNullable>(array_inner_type.get())->getNestedType();\n-\n-            // We also allow Nullable(T) and LC(U) if the Nullable(T) and U are allowed,\n-            // the LC(U) will be converted to U.\n-            return allowNested(\n-                    array_nullable_nested,\n-                    recursiveRemoveLowCardinality(arg_or_arg_nullable_nested));\n-        }\n-        else if (arg_is_nullable) // cannot compare Array(T) elem (namely, T) and Nullable(T)\n-            return false;\n-\n-        /// LowCardinality\n-\n-        const auto * const array_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(array_inner_type.get());\n-        const auto * const arg_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(arg.get());\n-\n-        const DataTypePtr array_lc_inner_type = recursiveRemoveLowCardinality(array_inner_type);\n-        const DataTypePtr arg_lc_inner_type = recursiveRemoveLowCardinality(arg);\n-\n-        const bool array_is_lc = nullptr != array_lc_ptr;\n-        const bool arg_is_lc = nullptr != arg_lc_ptr;\n+        auto inner_type_decayed = removeNullable(removeLowCardinality(array_inner_type));\n+        auto arg_decayed = removeNullable(removeLowCardinality(arg));\n \n-        const bool array_lc_inner_type_is_nullable = array_is_lc && array_lc_inner_type->isNullable();\n-        const bool arg_lc_inner_type_is_nullable = arg_is_lc && arg_lc_inner_type->isNullable();\n-\n-        if (array_is_lc) // comparing LC(T) and U\n-        {\n-            const DataTypePtr array_lc_nested_or_lc_nullable_nested = array_lc_inner_type_is_nullable\n-                ? checkAndGetDataType<DataTypeNullable>(array_lc_inner_type.get())->getNestedType()\n-                : array_lc_inner_type;\n-\n-            if (arg_is_lc) // comparing LC(T) and LC(U)\n-            {\n-                const DataTypePtr arg_lc_nested_or_lc_nullable_nested = arg_lc_inner_type_is_nullable\n-                    ? checkAndGetDataType<DataTypeNullable>(arg_lc_inner_type.get())->getNestedType()\n-                    : arg_lc_inner_type;\n-\n-                return allowNested(\n-                        array_lc_nested_or_lc_nullable_nested,\n-                        arg_lc_nested_or_lc_nullable_nested);\n-            }\n-            else if (arg_is_nullable) // Comparing LC(T) and Nullable(U)\n-            {\n-                if (!array_lc_inner_type_is_nullable)\n-                    return false; // Can't compare Array(LC(U)) elem and Nullable(T);\n-\n-                return allowNested(\n-                        array_lc_nested_or_lc_nullable_nested,\n-                        arg_or_arg_nullable_nested);\n-            }\n-            else // Comparing LC(T) and U (U neither Nullable nor LC)\n-                return allowNested(array_lc_nested_or_lc_nullable_nested, arg);\n-        }\n-\n-        if (arg_is_lc) // Allow T and LC(U) if U and T are allowed (the low cardinality column will be converted).\n-            return allowNested(array_inner_type, arg_lc_inner_type);\n-\n-        return false;\n+        return ((isNativeNumber(inner_type_decayed) || isEnum(inner_type_decayed)) && isNativeNumber(arg_decayed))\n+            || getLeastSupertype({inner_type_decayed, arg_decayed});\n     }\n \n #define INTEGRAL_TPL_PACK UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64\n@@ -1044,33 +971,38 @@ class FunctionArrayIndex : public IFunction\n         if (!col)\n             return nullptr;\n \n-        const IColumn & col_nested = col->getData();\n+        DataTypePtr array_elements_type = assert_cast<const DataTypeArray &>(*arguments[0].type).getNestedType();\n+        const DataTypePtr & index_type = arguments[1].type;\n+\n+        DataTypePtr common_type = getLeastSupertype({array_elements_type, index_type});\n+\n+        ColumnPtr col_nested = castColumn({ col->getDataPtr(), array_elements_type, \"\" }, common_type);\n \n         const ColumnPtr right_ptr = arguments[1].column->convertToFullColumnIfLowCardinality();\n-        const IColumn & item_arg = *right_ptr.get();\n+        ColumnPtr item_arg = castColumn({ right_ptr, removeLowCardinality(index_type), \"\" }, common_type);\n \n         auto col_res = ResultColumnType::create();\n \n         auto [null_map_data, null_map_item] = getNullMaps(arguments);\n \n-        if (item_arg.onlyNull())\n+        if (item_arg->onlyNull())\n             Impl::Null<ConcreteAction>::process(\n                 col->getOffsets(),\n                 col_res->getData(),\n                 null_map_data);\n-        else if (isColumnConst(item_arg))\n+        else if (isColumnConst(*item_arg))\n             Impl::Main<ConcreteAction, true>::vector(\n-                col_nested,\n+                *col_nested,\n                 col->getOffsets(),\n-                typeid_cast<const ColumnConst &>(item_arg).getDataColumn(),\n+                typeid_cast<const ColumnConst &>(*item_arg).getDataColumn(),\n                 col_res->getData(), /// TODO This is wrong.\n                 null_map_data,\n                 nullptr);\n         else\n             Impl::Main<ConcreteAction>::vector(\n-                col_nested,\n+                *col_nested,\n                 col->getOffsets(),\n-                item_arg,\n+                *item_arg,\n                 col_res->getData(),\n                 null_map_data,\n                 null_map_item);\ndiff --git a/src/Functions/array/hasAllAny.h b/src/Functions/array/hasAllAny.h\nindex b35c59966526..1ad1df140209 100644\n--- a/src/Functions/array/hasAllAny.h\n+++ b/src/Functions/array/hasAllAny.h\n@@ -13,6 +13,7 @@\n #include <Interpreters/castColumn.h>\n #include <Common/typeid_cast.h>\n #include <ext/range.h>\n+#include <ext/map.h>\n \n \n namespace DB\n@@ -51,41 +52,13 @@ class FunctionArrayHasAllAny : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        size_t rows = input_rows_count;\n         size_t num_args = arguments.size();\n \n-        DataTypePtr common_type = nullptr;\n-        auto commonType = [&common_type, &arguments]()\n-        {\n-            if (common_type == nullptr)\n-            {\n-                DataTypes data_types;\n-                data_types.reserve(arguments.size());\n-                for (const auto & argument : arguments)\n-                    data_types.push_back(argument.type);\n-\n-                common_type = getLeastSupertype(data_types);\n-            }\n-\n-            return common_type;\n-        };\n+        DataTypePtr common_type = getLeastSupertype(ext::map(arguments, [](auto & arg) { return arg.type; }));\n \n         Columns preprocessed_columns(num_args);\n-\n         for (size_t i = 0; i < num_args; ++i)\n-        {\n-            const auto & argument = arguments[i];\n-            ColumnPtr preprocessed_column = argument.column;\n-\n-            const auto * argument_type = typeid_cast<const DataTypeArray *>(argument.type.get());\n-            const auto & nested_type = argument_type->getNestedType();\n-\n-            /// Converts Array(Nothing) or Array(Nullable(Nothing) to common type. Example: hasAll([Null, 1], [Null]) -> 1\n-            if (typeid_cast<const DataTypeNothing *>(removeNullable(nested_type).get()))\n-                preprocessed_column = castColumn(argument, commonType());\n-\n-            preprocessed_columns[i] = std::move(preprocessed_column);\n-        }\n+            preprocessed_columns[i] = castColumn(arguments[i], common_type);\n \n         std::vector<std::unique_ptr<GatherUtils::IArraySource>> sources;\n \n@@ -100,12 +73,12 @@ class FunctionArrayHasAllAny : public IFunction\n             }\n \n             if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column.get()))\n-                sources.emplace_back(GatherUtils::createArraySource(*argument_column_array, is_const, rows));\n+                sources.emplace_back(GatherUtils::createArraySource(*argument_column_array, is_const, input_rows_count));\n             else\n                 throw Exception{\"Arguments for function \" + getName() + \" must be arrays.\", ErrorCodes::LOGICAL_ERROR};\n         }\n \n-        auto result_column = ColumnUInt8::create(rows);\n+        auto result_column = ColumnUInt8::create(input_rows_count);\n         auto * result_column_ptr = typeid_cast<ColumnUInt8 *>(result_column.get());\n         GatherUtils::sliceHas(*sources[0], *sources[1], search_type, *result_column_ptr);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00555_hasAll_hasAny.reference b/tests/queries/0_stateless/00555_hasAll_hasAny.reference\nindex b33700bfa029..5608f7b970e2 100644\n--- a/tests/queries/0_stateless/00555_hasAll_hasAny.reference\n+++ b/tests/queries/0_stateless/00555_hasAll_hasAny.reference\n@@ -34,10 +34,6 @@\n 1\n 0\n -\n-0\n-0\n-0\n-0\n -\n 0\n 1\ndiff --git a/tests/queries/0_stateless/00555_hasAll_hasAny.sql b/tests/queries/0_stateless/00555_hasAll_hasAny.sql\nindex 9df356dce2e9..c8a6c3cecbd2 100644\n--- a/tests/queries/0_stateless/00555_hasAll_hasAny.sql\n+++ b/tests/queries/0_stateless/00555_hasAll_hasAny.sql\n@@ -39,10 +39,10 @@ select hasAny(['a', 'b'], ['a', 'c']);\n select hasAll(['a', 'b'], ['a', 'c']);\n select '-';\n \n-select hasAny([1], ['a']);\n-select hasAll([1], ['a']);\n-select hasAll([[1, 2], [3, 4]], ['a', 'c']);\n-select hasAny([[1, 2], [3, 4]], ['a', 'c']);\n+select hasAny([1], ['a']); -- { serverError 386 }\n+select hasAll([1], ['a']); -- { serverError 386 }\n+select hasAll([[1, 2], [3, 4]], ['a', 'c']); -- { serverError 386 }\n+select hasAny([[1, 2], [3, 4]], ['a', 'c']); -- { serverError 386 }\n select '-';\n \n select hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]]);\ndiff --git a/tests/queries/0_stateless/00555_hasSubstr.reference b/tests/queries/0_stateless/00555_hasSubstr.reference\nindex 1051fa28d6c4..de97d19c9324 100644\n--- a/tests/queries/0_stateless/00555_hasSubstr.reference\n+++ b/tests/queries/0_stateless/00555_hasSubstr.reference\n@@ -20,8 +20,6 @@\n 0\n 1\n -\n-0\n-0\n 1\n 1\n 0\ndiff --git a/tests/queries/0_stateless/00555_hasSubstr.sql b/tests/queries/0_stateless/00555_hasSubstr.sql\nindex 04c70e4a43b6..5f90a69c546d 100644\n--- a/tests/queries/0_stateless/00555_hasSubstr.sql\n+++ b/tests/queries/0_stateless/00555_hasSubstr.sql\n@@ -25,8 +25,8 @@ select hasSubstr(['a', 'b'], ['a', 'c']);\n select hasSubstr(['a', 'c', 'b'], ['a', 'c']);\n select '-';\n \n-select hasSubstr([1], ['a']);\n-select hasSubstr([[1, 2], [3, 4]], ['a', 'c']);\n+select hasSubstr([1], ['a']); -- { serverError 386 }\n+select hasSubstr([[1, 2], [3, 4]], ['a', 'c']); -- { serverError 386 }\n select hasSubstr([[1, 2], [3, 4], [5, 8]], [[3, 4]]);\n select hasSubstr([[1, 2], [3, 4], [5, 8]], [[3, 4], [5, 8]]);\n select hasSubstr([[1, 2], [3, 4], [5, 8]], [[1, 2], [5, 8]]);\ndiff --git a/tests/queries/0_stateless/00700_decimal_complex_types.reference b/tests/queries/0_stateless/00700_decimal_complex_types.reference\nindex e81dd94513f5..9c7c6fefefdb 100644\n--- a/tests/queries/0_stateless/00700_decimal_complex_types.reference\n+++ b/tests/queries/0_stateless/00700_decimal_complex_types.reference\n@@ -39,9 +39,33 @@ Tuple(Decimal(9, 1), Decimal(18, 1), Decimal(38, 1))\tDecimal(9, 1)\tDecimal(18, 1\n 1\t0\n 1\t0\n 1\t0\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n 1\t0\n 2\t0\n 3\t0\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n [0.100,0.200,0.300,0.400,0.500,0.600]\tArray(Decimal(18, 3))\n [0.100,0.200,0.300,0.700,0.800,0.900]\tArray(Decimal(38, 3))\n [0.400,0.500,0.600,0.700,0.800,0.900]\tArray(Decimal(38, 3))\ndiff --git a/tests/queries/0_stateless/00700_decimal_complex_types.sql b/tests/queries/0_stateless/00700_decimal_complex_types.sql\nindex 2d506b124a2d..f4b29e77be92 100644\n--- a/tests/queries/0_stateless/00700_decimal_complex_types.sql\n+++ b/tests/queries/0_stateless/00700_decimal_complex_types.sql\n@@ -58,35 +58,35 @@ SELECT has(a, toDecimal32(0.1, 3)), has(a, toDecimal32(1.0, 3)) FROM decimal;\n SELECT has(b, toDecimal64(0.4, 3)), has(b, toDecimal64(1.0, 3)) FROM decimal;\n SELECT has(c, toDecimal128(0.7, 3)), has(c, toDecimal128(1.0, 3)) FROM decimal;\n \n-SELECT has(a, toDecimal32(0.1, 2)) FROM decimal; -- { serverError 43 }\n-SELECT has(a, toDecimal32(0.1, 4)) FROM decimal; -- { serverError 43 }\n-SELECT has(a, toDecimal64(0.1, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(a, toDecimal128(0.1, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(b, toDecimal32(0.4, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(b, toDecimal64(0.4, 2)) FROM decimal; -- { serverError 43 }\n-SELECT has(b, toDecimal64(0.4, 4)) FROM decimal; -- { serverError 43 }\n-SELECT has(b, toDecimal128(0.4, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(c, toDecimal32(0.7, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(c, toDecimal64(0.7, 3)) FROM decimal; -- { serverError 43 }\n-SELECT has(c, toDecimal128(0.7, 2)) FROM decimal; -- { serverError 43 }\n-SELECT has(c, toDecimal128(0.7, 4)) FROM decimal; -- { serverError 43 }\n+SELECT has(a, toDecimal32(0.1, 2)) FROM decimal;\n+SELECT has(a, toDecimal32(0.1, 4)) FROM decimal;\n+SELECT has(a, toDecimal64(0.1, 3)) FROM decimal;\n+SELECT has(a, toDecimal128(0.1, 3)) FROM decimal;\n+SELECT has(b, toDecimal32(0.4, 3)) FROM decimal;\n+SELECT has(b, toDecimal64(0.4, 2)) FROM decimal;\n+SELECT has(b, toDecimal64(0.4, 4)) FROM decimal;\n+SELECT has(b, toDecimal128(0.4, 3)) FROM decimal;\n+SELECT has(c, toDecimal32(0.7, 3)) FROM decimal;\n+SELECT has(c, toDecimal64(0.7, 3)) FROM decimal;\n+SELECT has(c, toDecimal128(0.7, 2)) FROM decimal;\n+SELECT has(c, toDecimal128(0.7, 4)) FROM decimal;\n \n SELECT indexOf(a, toDecimal32(0.1, 3)), indexOf(a, toDecimal32(1.0, 3)) FROM decimal;\n SELECT indexOf(b, toDecimal64(0.5, 3)), indexOf(b, toDecimal64(1.0, 3)) FROM decimal;\n SELECT indexOf(c, toDecimal128(0.9, 3)), indexOf(c, toDecimal128(1.0, 3)) FROM decimal;\n \n-SELECT indexOf(a, toDecimal32(0.1, 2)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(a, toDecimal32(0.1, 4)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(a, toDecimal64(0.1, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(a, toDecimal128(0.1, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(b, toDecimal32(0.4, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(b, toDecimal64(0.4, 2)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(b, toDecimal64(0.4, 4)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(b, toDecimal128(0.4, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(c, toDecimal32(0.7, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(c, toDecimal64(0.7, 3)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(c, toDecimal128(0.7, 2)) FROM decimal; -- { serverError 43 }\n-SELECT indexOf(c, toDecimal128(0.7, 4)) FROM decimal; -- { serverError 43 }\n+SELECT indexOf(a, toDecimal32(0.1, 2)) FROM decimal;\n+SELECT indexOf(a, toDecimal32(0.1, 4)) FROM decimal;\n+SELECT indexOf(a, toDecimal64(0.1, 3)) FROM decimal;\n+SELECT indexOf(a, toDecimal128(0.1, 3)) FROM decimal;\n+SELECT indexOf(b, toDecimal32(0.4, 3)) FROM decimal;\n+SELECT indexOf(b, toDecimal64(0.4, 2)) FROM decimal;\n+SELECT indexOf(b, toDecimal64(0.4, 4)) FROM decimal;\n+SELECT indexOf(b, toDecimal128(0.4, 3)) FROM decimal;\n+SELECT indexOf(c, toDecimal32(0.7, 3)) FROM decimal;\n+SELECT indexOf(c, toDecimal64(0.7, 3)) FROM decimal;\n+SELECT indexOf(c, toDecimal128(0.7, 2)) FROM decimal;\n+SELECT indexOf(c, toDecimal128(0.7, 4)) FROM decimal;\n \n SELECT arrayConcat(a, b) AS x, toTypeName(x) FROM decimal;\n SELECT arrayConcat(a, c) AS x, toTypeName(x) FROM decimal;\ndiff --git a/tests/queries/0_stateless/00918_has_unsufficient_type_check.reference b/tests/queries/0_stateless/00918_has_unsufficient_type_check.reference\nindex 7938dcdde861..b261da18d51a 100644\n--- a/tests/queries/0_stateless/00918_has_unsufficient_type_check.reference\n+++ b/tests/queries/0_stateless/00918_has_unsufficient_type_check.reference\n@@ -1,3 +1,2 @@\n-0\n 1\n 0\ndiff --git a/tests/queries/0_stateless/00918_has_unsufficient_type_check.sql b/tests/queries/0_stateless/00918_has_unsufficient_type_check.sql\nindex f76fd446a8ed..c40419e4d566 100644\n--- a/tests/queries/0_stateless/00918_has_unsufficient_type_check.sql\n+++ b/tests/queries/0_stateless/00918_has_unsufficient_type_check.sql\n@@ -1,3 +1,3 @@\n-SELECT hasAny([['Hello, world']], [[[]]]);\n+SELECT hasAny([['Hello, world']], [[[]]]); -- { serverError 386 }\n SELECT hasAny([['Hello, world']], [['Hello', 'world'], ['Hello, world']]);\n SELECT hasAll([['Hello, world']], [['Hello', 'world'], ['Hello, world']]);\ndiff --git a/tests/queries/0_stateless/01812_has_generic.reference b/tests/queries/0_stateless/01812_has_generic.reference\nnew file mode 100644\nindex 000000000000..e8183f05f5db\n--- /dev/null\n+++ b/tests/queries/0_stateless/01812_has_generic.reference\n@@ -0,0 +1,3 @@\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01812_has_generic.sql b/tests/queries/0_stateless/01812_has_generic.sql\nnew file mode 100644\nindex 000000000000..9ab5b655102e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01812_has_generic.sql\n@@ -0,0 +1,3 @@\n+SELECT has([(1, 2), (3, 4)], (toUInt16(3), 4));\n+SELECT hasAny([(1, 2), (3, 4)], [(toUInt16(3), 4)]);\n+SELECT hasAll([(1, 2), (3, 4)], [(toNullable(1), toUInt64(2)), (toUInt16(3), 4)]);\n",
  "problem_statement": "hasAny function return incorrect result with complex datas mixed with constant\n(you don't have to strictly follow this form)\r\n\r\n**Describe the bug**\r\n`hasAny` function return invalid datas when we use a complex datatype like a Tuple with a constant in a left or right operand of the function.\r\n\r\n\r\n**How to reproduce**\r\nTested using clickhouse-server 21.2.2.8\r\n\r\n```\r\nCREATE TABLE a\r\n(\r\n    `foo` UInt8,\r\n    `bar` UInt32\r\n)\r\nENGINE = Memory;\r\n\r\nINSERT INTO a VALUES(1, 5);\r\n\r\nSELECT 1\r\nFROM a\r\nGROUP BY 1\r\nHAVING hasAny([(1, 5)], groupUniqArray((foo, bar)))\r\n\r\nQuery id: ff67aecd-d4a4-44a9-8999-4fb32e430df3\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.006 sec. \r\n\r\nSELECT 1\r\nFROM a\r\nGROUP BY 1\r\nHAVING hasAny([(toUInt8(1), toUInt32(5))], groupUniqArray((foo, bar)))\r\n\r\nQuery id: a37128b5-9476-4a03-83e9-de346e7eb567\r\n\r\n\u250c\u25001\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.007 sec. \r\n```\r\n\r\n**Expected behavior**\r\nClickHouse should return `True` on both query\n",
  "hints_text": "",
  "created_at": "2021-04-13T13:57:50Z",
  "modified_files": [
    "src/Functions/GatherUtils/Algorithms.h",
    "src/Functions/array/arrayIndex.h",
    "src/Functions/array/hasAllAny.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00555_hasAll_hasAny.reference",
    "tests/queries/0_stateless/00555_hasAll_hasAny.sql",
    "tests/queries/0_stateless/00555_hasSubstr.reference",
    "tests/queries/0_stateless/00555_hasSubstr.sql",
    "tests/queries/0_stateless/00700_decimal_complex_types.reference",
    "tests/queries/0_stateless/00700_decimal_complex_types.sql",
    "tests/queries/0_stateless/00918_has_unsufficient_type_check.reference",
    "tests/queries/0_stateless/00918_has_unsufficient_type_check.sql",
    "b/tests/queries/0_stateless/01812_has_generic.reference",
    "b/tests/queries/0_stateless/01812_has_generic.sql"
  ]
}