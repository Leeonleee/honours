{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34424,
  "instance_id": "ClickHouse__ClickHouse-34424",
  "issue_numbers": [
    "9436"
  ],
  "base_commit": "d6cbac1ed368199f09fc9ffd465e337553917762",
  "patch": "diff --git a/docs/en/sql-reference/statements/create/table.md b/docs/en/sql-reference/statements/create/table.md\nindex 7bbbb6f32bd1..409ec422ade3 100644\n--- a/docs/en/sql-reference/statements/create/table.md\n+++ b/docs/en/sql-reference/statements/create/table.md\n@@ -16,8 +16,8 @@ By default, tables are created only on the current server. Distributed DDL queri\n ``` sql\n CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n (\n-    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr1] [compression_codec] [TTL expr1],\n-    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr2] [compression_codec] [TTL expr2],\n+    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1] [compression_codec] [TTL expr1],\n+    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr2] [compression_codec] [TTL expr2],\n     ...\n ) ENGINE = engine\n ```\n@@ -112,6 +112,13 @@ Materialized expression. Such a column can\u2019t be specified for INSERT, because\n For an INSERT without a list of columns, these columns are not considered.\n In addition, this column is not substituted when using an asterisk in a SELECT query. This is to preserve the invariant that the dump obtained using `SELECT *` can be inserted back into the table using INSERT without specifying the list of columns.\n \n+### EPHEMERAL {#ephemeral}\n+\n+`EPHEMERAL expr`\n+\n+Ephemeral column. Such a column isn't stored in the table and cannot be SELECTed, but can be referenced in the defaults of CREATE statement.\n+INSERT without list of columns will skip such column, so SELECT/INSERT invariant is preserved -  the dump obtained using `SELECT *` can be inserted back into the table using INSERT without specifying the list of columns.\n+\n ### ALIAS {#alias}\n \n `ALIAS expr`\ndiff --git a/docs/ru/sql-reference/statements/create/table.md b/docs/ru/sql-reference/statements/create/table.md\nindex 8567a0ff2db9..b9c2a4f0f0b5 100644\n--- a/docs/ru/sql-reference/statements/create/table.md\n+++ b/docs/ru/sql-reference/statements/create/table.md\n@@ -14,8 +14,8 @@ toc_title: \"\u0422\u0430\u0431\u043b\u0438\u0446\u0430\"\n ``` sql\n CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n (\n-    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr1] [compression_codec] [TTL expr1],\n-    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr2] [compression_codec] [TTL expr2],\n+    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1] [compression_codec] [TTL expr1],\n+    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr2] [compression_codec] [TTL expr2],\n     ...\n ) ENGINE = engine\n ```\n@@ -108,6 +108,13 @@ SELECT x, toTypeName(x) FROM t1;\n \u041f\u0440\u0438 INSERT \u0431\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432, \u0442\u0430\u043a\u0438\u0435 \u0441\u0442\u043e\u043b\u0431\u0446\u044b \u043d\u0435 \u0440\u0430\u0441\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u044e\u0442\u0441\u044f.\n \u0422\u0430\u043a\u0436\u0435 \u044d\u0442\u043e\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u043d\u0435 \u043f\u043e\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 \u0437\u0432\u0451\u0437\u0434\u043e\u0447\u043a\u0438 \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0435 SELECT. \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e, \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438\u043d\u0432\u0430\u0440\u0438\u0430\u043d\u0442, \u0447\u0442\u043e \u0434\u0430\u043c\u043f, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043f\u0443\u0442\u0451\u043c `SELECT *`, \u043c\u043e\u0436\u043d\u043e \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0443 INSERT-\u043e\u043c \u0431\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432.\n \n+### EPHEMERAL {#ephemeral}\n+\n+`EPHEMERAL expr`\n+\n+\u042d\u0444\u0435\u043c\u0435\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435. \u0422\u0430\u043a\u043e\u0439 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u043d\u0435 \u0445\u0440\u0430\u043d\u0438\u0442\u0441\u044f \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 \u0438 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0435 SELECT, \u043d\u043e \u043d\u0430 \u043d\u0435\u0433\u043e \u043c\u043e\u0436\u043d\u043e \u0441\u0441\u044b\u043b\u0430\u0442\u044c\u0441\u044f \u0432 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f\u0445 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0437\u0430\u043f\u0440\u043e\u0441\u0430 CREATE.\n+INSERT \u0431\u0435\u0437 \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432 \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442 \u044d\u0442\u043e\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446, \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442\u0441\u044f \u0438\u043d\u0432\u0430\u0440\u0438\u0430\u043d\u0442 - \u0442.\u0435. \u0434\u0430\u043c\u043f, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u043f\u0443\u0442\u0451\u043c `SELECT *`, \u043c\u043e\u0436\u043d\u043e \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0443 INSERT-\u043e\u043c \u0431\u0435\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432.\n+\n ### ALIAS {#alias}\n \n `ALIAS expr`\ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex d340308122fa..f43d108de9e7 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -109,22 +109,31 @@ Block InterpreterInsertQuery::getSampleBlock(\n     const StoragePtr & table,\n     const StorageMetadataPtr & metadata_snapshot) const\n {\n-    Block table_sample = metadata_snapshot->getSampleBlock();\n-    Block table_sample_non_materialized = metadata_snapshot->getSampleBlockNonMaterialized();\n+    Block table_sample_physical = metadata_snapshot->getSampleBlock();\n+    Block table_sample_insertable = metadata_snapshot->getSampleBlockInsertable();\n     Block res;\n     for (const auto & current_name : names)\n     {\n-        /// The table does not have a column with that name\n-        if (!table_sample.has(current_name))\n-            throw Exception(\"No such column \" + current_name + \" in table \" + table->getStorageID().getNameForLogs(),\n-                ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n-\n-        if (!allow_materialized && !table_sample_non_materialized.has(current_name))\n-            throw Exception(\"Cannot insert column \" + current_name + \", because it is MATERIALIZED column.\", ErrorCodes::ILLEGAL_COLUMN);\n         if (res.has(current_name))\n             throw Exception(\"Column \" + current_name + \" specified more than once\", ErrorCodes::DUPLICATE_COLUMN);\n \n-        res.insert(ColumnWithTypeAndName(table_sample.getByName(current_name).type, current_name));\n+        /// Column is not ordinary or ephemeral\n+        if (!table_sample_insertable.has(current_name))\n+        {\n+            /// Column is materialized\n+            if (table_sample_physical.has(current_name))\n+            {\n+                if (!allow_materialized)\n+                    throw Exception(\"Cannot insert column \" + current_name + \", because it is MATERIALIZED column.\",\n+                        ErrorCodes::ILLEGAL_COLUMN);\n+                res.insert(ColumnWithTypeAndName(table_sample_physical.getByName(current_name).type, current_name));\n+            }\n+            else /// The table does not have a column with that name\n+                throw Exception(\"No such column \" + current_name + \" in table \" + table->getStorageID().getNameForLogs(),\n+                    ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+        }\n+        else\n+            res.insert(ColumnWithTypeAndName(table_sample_insertable.getByName(current_name).type, current_name));\n     }\n     return res;\n }\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex c48cea9c4805..a4dbe6356642 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -124,6 +124,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_null{\"NULL\"};\n     ParserKeyword s_not{\"NOT\"};\n     ParserKeyword s_materialized{\"MATERIALIZED\"};\n+    ParserKeyword s_ephemeral{\"EPHEMERAL\"};\n     ParserKeyword s_alias{\"ALIAS\"};\n     ParserKeyword s_comment{\"COMMENT\"};\n     ParserKeyword s_codec{\"CODEC\"};\n@@ -171,6 +172,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n \n     if (!s_default.checkWithoutMoving(pos, expected)\n         && !s_materialized.checkWithoutMoving(pos, expected)\n+        && !s_ephemeral.checkWithoutMoving(pos, expected)\n         && !s_alias.checkWithoutMoving(pos, expected)\n         && (require_type\n             || (!s_comment.checkWithoutMoving(pos, expected)\n@@ -183,7 +185,8 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     }\n \n     Pos pos_before_specifier = pos;\n-    if (s_default.ignore(pos, expected) || s_materialized.ignore(pos, expected) || s_alias.ignore(pos, expected))\n+    if (s_default.ignore(pos, expected) || s_materialized.ignore(pos, expected) ||\n+        s_ephemeral.ignore(pos, expected) || s_alias.ignore(pos, expected))\n     {\n         default_specifier = Poco::toUpper(std::string{pos_before_specifier->begin, pos_before_specifier->end});\n \ndiff --git a/src/Parsers/obfuscateQueries.cpp b/src/Parsers/obfuscateQueries.cpp\nindex c0b57d9b1f58..a4eb54045521 100644\n--- a/src/Parsers/obfuscateQueries.cpp\n+++ b/src/Parsers/obfuscateQueries.cpp\n@@ -26,20 +26,20 @@ namespace\n \n const std::unordered_set<std::string_view> keywords\n {\n-    \"CREATE\",       \"DATABASE\", \"IF\",     \"NOT\",       \"EXISTS\",   \"TEMPORARY\",   \"TABLE\",    \"ON\",          \"CLUSTER\", \"DEFAULT\",\n-    \"MATERIALIZED\", \"ALIAS\",    \"ENGINE\", \"AS\",        \"VIEW\",     \"POPULATE\",    \"SETTINGS\", \"ATTACH\",      \"DETACH\",  \"DROP\",\n-    \"RENAME\",       \"TO\",       \"ALTER\",  \"ADD\",       \"MODIFY\",   \"CLEAR\",       \"COLUMN\",   \"AFTER\",       \"COPY\",    \"PROJECT\",\n-    \"PRIMARY\",      \"KEY\",      \"CHECK\",  \"PARTITION\", \"PART\",     \"FREEZE\",      \"FETCH\",    \"FROM\",        \"SHOW\",    \"INTO\",\n-    \"OUTFILE\",      \"FORMAT\",   \"TABLES\", \"DATABASES\", \"LIKE\",     \"PROCESSLIST\", \"CASE\",     \"WHEN\",        \"THEN\",    \"ELSE\",\n-    \"END\",          \"DESCRIBE\", \"DESC\",   \"USE\",       \"SET\",      \"OPTIMIZE\",    \"FINAL\",    \"DEDUPLICATE\", \"INSERT\",  \"VALUES\",\n-    \"SELECT\",       \"DISTINCT\", \"SAMPLE\", \"ARRAY\",     \"JOIN\",     \"GLOBAL\",      \"LOCAL\",    \"ANY\",         \"ALL\",     \"INNER\",\n-    \"LEFT\",         \"RIGHT\",    \"FULL\",   \"OUTER\",     \"CROSS\",    \"USING\",       \"PREWHERE\", \"WHERE\",       \"GROUP\",   \"BY\",\n-    \"WITH\",         \"TOTALS\",   \"HAVING\", \"ORDER\",     \"COLLATE\",  \"LIMIT\",       \"UNION\",    \"AND\",         \"OR\",      \"ASC\",\n-    \"IN\",           \"KILL\",     \"QUERY\",  \"SYNC\",      \"ASYNC\",    \"TEST\",        \"BETWEEN\",  \"TRUNCATE\",    \"USER\",    \"ROLE\",\n-    \"PROFILE\",      \"QUOTA\",    \"POLICY\", \"ROW\",       \"GRANT\",    \"REVOKE\",      \"OPTION\",   \"ADMIN\",       \"EXCEPT\",  \"REPLACE\",\n-    \"IDENTIFIED\",   \"HOST\",     \"NAME\",   \"READONLY\",  \"WRITABLE\", \"PERMISSIVE\",  \"FOR\",      \"RESTRICTIVE\", \"RANDOMIZED\",\n-    \"INTERVAL\",     \"LIMITS\",   \"ONLY\",   \"TRACKING\",  \"IP\",       \"REGEXP\",      \"ILIKE\",    \"DICTIONARY\",  \"OFFSET\",\n-    \"TRIM\", \"LTRIM\", \"RTRIM\", \"BOTH\", \"LEADING\", \"TRAILING\"\n+    \"CREATE\",       \"DATABASE\",   \"IF\",       \"NOT\",      \"EXISTS\",    \"TEMPORARY\", \"TABLE\",       \"ON\",         \"CLUSTER\",     \"DEFAULT\",\n+    \"MATERIALIZED\", \"EPHEMERAL\",  \"ALIAS\",    \"ENGINE\",   \"AS\",        \"VIEW\",      \"POPULATE\",    \"SETTINGS\",   \"ATTACH\",      \"DETACH\",\n+    \"DROP\",         \"RENAME\",     \"TO\",       \"ALTER\",    \"ADD\",       \"MODIFY\",    \"CLEAR\",       \"COLUMN\",     \"AFTER\",       \"COPY\",\n+    \"PROJECT\",      \"PRIMARY\",    \"KEY\",      \"CHECK\",    \"PARTITION\", \"PART\",      \"FREEZE\",      \"FETCH\",      \"FROM\",        \"SHOW\",\n+    \"INTO\",         \"OUTFILE\",    \"FORMAT\",   \"TABLES\",   \"DATABASES\", \"LIKE\",      \"PROCESSLIST\", \"CASE\",       \"WHEN\",        \"THEN\",\n+    \"ELSE\",         \"END\",        \"DESCRIBE\", \"DESC\",     \"USE\",       \"SET\",       \"OPTIMIZE\",    \"FINAL\",      \"DEDUPLICATE\", \"INSERT\",\n+    \"VALUES\",       \"SELECT\",     \"DISTINCT\", \"SAMPLE\",   \"ARRAY\",     \"JOIN\",      \"GLOBAL\",      \"LOCAL\",      \"ANY\",         \"ALL\",\n+    \"INNER\",        \"LEFT\",       \"RIGHT\",    \"FULL\",     \"OUTER\",     \"CROSS\",     \"USING\",       \"PREWHERE\",   \"WHERE\",       \"GROUP\",\n+    \"BY\",           \"WITH\",       \"TOTALS\",   \"HAVING\",   \"ORDER\",     \"COLLATE\",   \"LIMIT\",       \"UNION\",      \"AND\",         \"OR\",\n+    \"ASC\",          \"IN\",         \"KILL\",     \"QUERY\",    \"SYNC\",      \"ASYNC\",     \"TEST\",        \"BETWEEN\",    \"TRUNCATE\",    \"USER\",\n+    \"ROLE\",         \"PROFILE\",    \"QUOTA\",    \"POLICY\",   \"ROW\",       \"GRANT\",     \"REVOKE\",      \"OPTION\",     \"ADMIN\",       \"EXCEPT\",\n+    \"REPLACE\",      \"IDENTIFIED\", \"HOST\",     \"NAME\",     \"READONLY\",  \"WRITABLE\",  \"PERMISSIVE\",  \"FOR\",        \"RESTRICTIVE\", \"RANDOMIZED\",\n+    \"INTERVAL\",     \"LIMITS\",     \"ONLY\",     \"TRACKING\", \"IP\",        \"REGEXP\",    \"ILIKE\",       \"DICTIONARY\", \"OFFSET\",      \"TRIM\",\n+    \"LTRIM\",        \"RTRIM\",      \"BOTH\",     \"LEADING\",  \"TRAILING\"\n };\n \n const std::unordered_set<std::string_view> keep_words\ndiff --git a/src/Storages/ColumnDefault.cpp b/src/Storages/ColumnDefault.cpp\nindex d35d3c31470b..3cf49ea69fc9 100644\n--- a/src/Storages/ColumnDefault.cpp\n+++ b/src/Storages/ColumnDefault.cpp\n@@ -9,6 +9,7 @@ struct AliasNames\n     static constexpr const char * DEFAULT = \"DEFAULT\";\n     static constexpr const char * MATERIALIZED = \"MATERIALIZED\";\n     static constexpr const char * ALIAS = \"ALIAS\";\n+    static constexpr const char * EPHEMERAL = \"EPHEMERAL\";\n };\n \n }\n@@ -27,7 +28,8 @@ ColumnDefaultKind columnDefaultKindFromString(const std::string & str)\n     static const std::unordered_map<std::string, ColumnDefaultKind> map{\n         { AliasNames::DEFAULT, ColumnDefaultKind::Default },\n         { AliasNames::MATERIALIZED, ColumnDefaultKind::Materialized },\n-        { AliasNames::ALIAS, ColumnDefaultKind::Alias }\n+        { AliasNames::ALIAS, ColumnDefaultKind::Alias },\n+        { AliasNames::EPHEMERAL, ColumnDefaultKind::Ephemeral }\n     };\n \n     const auto it = map.find(str);\n@@ -43,7 +45,8 @@ std::string toString(const ColumnDefaultKind kind)\n     static const std::unordered_map<ColumnDefaultKind, std::string> map{\n         { ColumnDefaultKind::Default, AliasNames::DEFAULT },\n         { ColumnDefaultKind::Materialized, AliasNames::MATERIALIZED },\n-        { ColumnDefaultKind::Alias, AliasNames::ALIAS }\n+        { ColumnDefaultKind::Alias, AliasNames::ALIAS },\n+        { ColumnDefaultKind::Ephemeral, AliasNames::EPHEMERAL }\n     };\n \n     const auto it = map.find(kind);\ndiff --git a/src/Storages/ColumnDefault.h b/src/Storages/ColumnDefault.h\nindex 38b61415a9ad..096a1f177ab1 100644\n--- a/src/Storages/ColumnDefault.h\n+++ b/src/Storages/ColumnDefault.h\n@@ -13,7 +13,8 @@ enum class ColumnDefaultKind\n {\n     Default,\n     Materialized,\n-    Alias\n+    Alias,\n+    Ephemeral\n };\n \n \ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 568257b4fd77..964fad8f4b5e 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -340,6 +340,15 @@ NamesAndTypesList ColumnsDescription::getOrdinary() const\n     return ret;\n }\n \n+NamesAndTypesList ColumnsDescription::getInsertable() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+        if (col.default_desc.kind == ColumnDefaultKind::Default || col.default_desc.kind == ColumnDefaultKind::Ephemeral)\n+            ret.emplace_back(col.name, col.type);\n+    return ret;\n+}\n+\n NamesAndTypesList ColumnsDescription::getMaterialized() const\n {\n     NamesAndTypesList ret;\n@@ -358,6 +367,15 @@ NamesAndTypesList ColumnsDescription::getAliases() const\n     return ret;\n }\n \n+NamesAndTypesList ColumnsDescription::getEphemeral() const\n+{\n+    NamesAndTypesList ret;\n+        for (const auto & col : columns)\n+            if (col.default_desc.kind == ColumnDefaultKind::Ephemeral)\n+                ret.emplace_back(col.name, col.type);\n+    return ret;\n+}\n+\n NamesAndTypesList ColumnsDescription::getAll() const\n {\n     NamesAndTypesList ret;\n@@ -402,6 +420,8 @@ static ColumnsDescription::GetFlags defaultKindToGetFlag(ColumnDefaultKind kind)\n             return ColumnsDescription::Materialized;\n         case ColumnDefaultKind::Alias:\n             return ColumnsDescription::Aliases;\n+        case ColumnDefaultKind::Ephemeral:\n+            return ColumnsDescription::Ephemeral;\n     }\n     __builtin_unreachable();\n }\n@@ -441,7 +461,7 @@ NamesAndTypesList ColumnsDescription::getAllPhysical() const\n {\n     NamesAndTypesList ret;\n     for (const auto & col : columns)\n-        if (col.default_desc.kind != ColumnDefaultKind::Alias)\n+        if (col.default_desc.kind != ColumnDefaultKind::Alias && col.default_desc.kind != ColumnDefaultKind::Ephemeral)\n             ret.emplace_back(col.name, col.type);\n     return ret;\n }\n@@ -450,7 +470,7 @@ Names ColumnsDescription::getNamesOfPhysical() const\n {\n     Names ret;\n     for (const auto & col : columns)\n-        if (col.default_desc.kind != ColumnDefaultKind::Alias)\n+        if (col.default_desc.kind != ColumnDefaultKind::Alias && col.default_desc.kind != ColumnDefaultKind::Ephemeral)\n             ret.emplace_back(col.name);\n     return ret;\n }\n@@ -481,7 +501,8 @@ NameAndTypePair ColumnsDescription::getColumnOrSubcolumn(GetFlags flags, const S\n std::optional<NameAndTypePair> ColumnsDescription::tryGetPhysical(const String & column_name) const\n {\n     auto it = columns.get<1>().find(column_name);\n-    if (it == columns.get<1>().end() || it->default_desc.kind == ColumnDefaultKind::Alias)\n+    if (it == columns.get<1>().end() ||\n+            it->default_desc.kind == ColumnDefaultKind::Alias || it->default_desc.kind == ColumnDefaultKind::Ephemeral)\n         return {};\n \n     return NameAndTypePair(it->name, it->type);\n@@ -500,7 +521,8 @@ NameAndTypePair ColumnsDescription::getPhysical(const String & column_name) cons\n bool ColumnsDescription::hasPhysical(const String & column_name) const\n {\n     auto it = columns.get<1>().find(column_name);\n-    return it != columns.get<1>().end() && it->default_desc.kind != ColumnDefaultKind::Alias;\n+    return it != columns.get<1>().end() &&\n+        it->default_desc.kind != ColumnDefaultKind::Alias && it->default_desc.kind != ColumnDefaultKind::Ephemeral;\n }\n \n bool ColumnsDescription::hasColumnOrSubcolumn(GetFlags flags, const String & column_name) const\ndiff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h\nindex 44f895c89ce3..6cf863c6cb45 100644\n--- a/src/Storages/ColumnsDescription.h\n+++ b/src/Storages/ColumnsDescription.h\n@@ -84,18 +84,21 @@ class ColumnsDescription\n         Ordinary = 1,\n         Materialized = 2,\n         Aliases = 4,\n+        Ephemeral = 8,\n \n         AllPhysical = Ordinary | Materialized,\n-        All = AllPhysical | Aliases,\n+        All = AllPhysical | Aliases | Ephemeral,\n     };\n \n     NamesAndTypesList getByNames(GetFlags flags, const Names & names, bool with_subcolumns) const;\n \n     NamesAndTypesList getOrdinary() const;\n     NamesAndTypesList getMaterialized() const;\n+    NamesAndTypesList getInsertable() const; /// ordinary + ephemeral\n     NamesAndTypesList getAliases() const;\n+    NamesAndTypesList getEphemeral() const;\n     NamesAndTypesList getAllPhysical() const; /// ordinary + materialized.\n-    NamesAndTypesList getAll() const; /// ordinary + materialized + aliases\n+    NamesAndTypesList getAll() const; /// ordinary + materialized + aliases + ephemeral\n     NamesAndTypesList getAllWithSubcolumns() const;\n     NamesAndTypesList getAllPhysicalWithSubcolumns() const;\n \ndiff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp\nindex 061319bc1c0d..8439c721c1fd 100644\n--- a/src/Storages/StorageInMemoryMetadata.cpp\n+++ b/src/Storages/StorageInMemoryMetadata.cpp\n@@ -300,6 +300,16 @@ ColumnDependencies StorageInMemoryMetadata::getColumnDependencies(const NameSet\n \n }\n \n+Block StorageInMemoryMetadata::getSampleBlockInsertable() const\n+{\n+    Block res;\n+\n+    for (const auto & column : getColumns().getInsertable())\n+        res.insert({column.type->createColumn(), column.type, column.name});\n+\n+    return res;\n+}\n+\n Block StorageInMemoryMetadata::getSampleBlockNonMaterialized() const\n {\n     Block res;\ndiff --git a/src/Storages/StorageInMemoryMetadata.h b/src/Storages/StorageInMemoryMetadata.h\nindex a8912d44f2c1..9d6935b609b2 100644\n--- a/src/Storages/StorageInMemoryMetadata.h\n+++ b/src/Storages/StorageInMemoryMetadata.h\n@@ -151,6 +151,9 @@ struct StorageInMemoryMetadata\n     /// Block with ordinary + materialized columns.\n     Block getSampleBlock() const;\n \n+    /// Block with ordinary + ephemeral.\n+    Block getSampleBlockInsertable() const;\n+\n     /// Block with ordinary columns.\n     Block getSampleBlockNonMaterialized() const;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02205_ephemeral_1.reference b/tests/queries/0_stateless/02205_ephemeral_1.reference\nnew file mode 100644\nindex 000000000000..bad56205b46d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02205_ephemeral_1.reference\n@@ -0,0 +1,7 @@\n+x\tUInt32\tDEFAULT\ty\t\t\t\n+y\tUInt32\tEPHEMERAL\t17\t\t\t\n+z\tUInt32\tDEFAULT\t5\t\t\t\n+1\t2\n+17\t5\n+7\t5\n+21\t5\ndiff --git a/tests/queries/0_stateless/02205_ephemeral_1.sql b/tests/queries/0_stateless/02205_ephemeral_1.sql\nnew file mode 100644\nindex 000000000000..60411a925838\n--- /dev/null\n+++ b/tests/queries/0_stateless/02205_ephemeral_1.sql\n@@ -0,0 +1,39 @@\n+DROP TABLE IF EXISTS t_ephemeral_02205_1;\n+\n+CREATE TABLE t_ephemeral_02205_1 (x UInt32 DEFAULT y, y UInt32 EPHEMERAL 17, z UInt32 DEFAULT 5) ENGINE = Memory;\n+\n+DESCRIBE t_ephemeral_02205_1;\n+\n+# Test INSERT without columns list - should participate only ordinary columns (x, z)\n+INSERT INTO t_ephemeral_02205_1 VALUES (1, 2);\n+# SELECT * should only return ordinary columns (x, z) - ephemeral is not stored in the table\n+SELECT * FROM t_ephemeral_02205_1;\n+\n+TRUNCATE TABLE t_ephemeral_02205_1;\n+\n+# Attempt to use ephemeral through default of ordinary column should end up with error 10 -\n+# ephemeral only considered when explicitly mentioned in the columns list\n+INSERT INTO t_ephemeral_02205_1 VALUES (DEFAULT, 2); -- { clientError 10 }\n+\n+# Test INSERT using ephemerals default\n+INSERT INTO t_ephemeral_02205_1 (x, y) VALUES (DEFAULT, DEFAULT);\n+SELECT * FROM t_ephemeral_02205_1;\n+\n+TRUNCATE TABLE t_ephemeral_02205_1;\n+\n+# Test INSERT using explicit ephemerals value\n+INSERT INTO t_ephemeral_02205_1 (x, y) VALUES (DEFAULT, 7);\n+SELECT * FROM t_ephemeral_02205_1;\n+\n+# Test ALTER TABLE DELETE\n+ALTER TABLE t_ephemeral_02205_1 DELETE WHERE x = 7;\n+SELECT * FROM t_ephemeral_02205_1;\n+\n+TRUNCATE TABLE t_ephemeral_02205_1;\n+\n+# Test INSERT into column, defaulted to ephemeral, but explicitly provided with value\n+INSERT INTO t_ephemeral_02205_1 (x, y) VALUES (21, 7);\n+SELECT * FROM t_ephemeral_02205_1;\n+\n+\n+DROP TABLE IF EXISTS t_ephemeral_02205_1;\n",
  "problem_statement": "\"ephemeral\" or \"dematerialized\" columns\nSpecial type of column. This column can be INSERTed and can be referred in default expressions of another columns, but it is not stored in a table and cannot be SELECTed.\r\n\r\n**Use case**\r\nCalculate other columns on top of input data but don't store the source column. Example: extract something from JSON.\r\n\r\n**Alternatives**\r\nYou can use table function `input` for the same result. It is just a little less convenient.\n",
  "hints_text": "I just realize it will be useful for projections.\n@yakov-olkhovskiy is working on this task",
  "created_at": "2022-02-08T16:54:03Z",
  "modified_files": [
    "docs/en/sql-reference/statements/create/table.md",
    "docs/ru/sql-reference/statements/create/table.md",
    "src/Interpreters/InterpreterInsertQuery.cpp",
    "src/Parsers/ParserCreateQuery.h",
    "src/Parsers/obfuscateQueries.cpp",
    "src/Storages/ColumnDefault.cpp",
    "src/Storages/ColumnDefault.h",
    "src/Storages/ColumnsDescription.cpp",
    "src/Storages/ColumnsDescription.h",
    "src/Storages/StorageInMemoryMetadata.cpp",
    "src/Storages/StorageInMemoryMetadata.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02205_ephemeral_1.reference",
    "b/tests/queries/0_stateless/02205_ephemeral_1.sql"
  ]
}