{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61820,
  "instance_id": "ClickHouse__ClickHouse-61820",
  "issue_numbers": [
    "54665"
  ],
  "base_commit": "0d1751fd55c2f14a626dba19b68c35a1a611e239",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 0ca404274ecd..82cc68133da4 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -3132,3 +3132,17 @@ Result:\n \u2502 (616.2931945826209,108.8825,115.6175) \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+## getClientHTTPHeader\n+\n+Get the value of an HTTP header.\n+\n+If there is no such header or the current request is not performed via the HTTP interface, the function returns an empty string.\n+Certain HTTP headers (e.g., `Authentication` and `X-ClickHouse-*`) are restricted.\n+\n+The function requires the setting `allow_get_client_http_header` to be enabled.\n+The setting is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info.\n+\n+HTTP headers are case sensitive for this function.\n+\n+If the function is used in the context of a distributed query, it returns non-empty result only on the initiator node.\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 6fc82be0b071..8daacb781508 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -896,6 +896,7 @@ class IColumn;\n     M(Int64, ignore_cold_parts_seconds, 0, \"Only available in ClickHouse Cloud. Exclude new data parts from SELECT queries until they're either pre-warmed (see cache_populated_by_fetch) or this many seconds old. Only for Replicated-/SharedMergeTree.\", 0) \\\n     M(Int64, prefer_warmed_unmerged_parts_seconds, 0, \"Only available in ClickHouse Cloud. If a merged part is less than this many seconds old and is not pre-warmed (see cache_populated_by_fetch), but all its source parts are available and pre-warmed, SELECT queries will read from those parts instead. Only for ReplicatedMergeTree. Note that this only checks whether CacheWarmer processed the part; if the part was fetched into cache by something else, it'll still be considered cold until CacheWarmer gets to it; if it was warmed, then evicted from cache, it'll still be considered warm.\", 0) \\\n     M(Bool, iceberg_engine_ignore_schema_evolution, false, \"Ignore schema evolution in Iceberg table engine and read all data using latest schema saved on table creation. Note that it can lead to incorrect result\", 0) \\\n+    M(Bool, allow_get_client_http_header, false, \"Allow to use the function `getClientHTTPHeader` which lets to obtain a value of an the current HTTP request's header. It is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info. Note that the `X-ClickHouse-*` and `Authentication` headers are always restricted and cannot be obtained with this function.\", 0) \\\n \n // End of COMMON_SETTINGS\n // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex 76589f70a311..1aa9b354938f 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -106,6 +106,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n               {\"keeper_retry_max_backoff_ms\", 5000, 5000, \"Max backoff timeout for general keeper operations\"},\n               {\"s3queue_allow_experimental_sharded_mode\", false, false, \"Enable experimental sharded mode of S3Queue table engine. It is experimental because it will be rewritten\"},\n               {\"merge_tree_read_split_ranges_into_intersecting_and_non_intersecting_injection_probability\", 0.0, 0.0, \"For testing of `PartsSplitter` - split read ranges into intersecting and non intersecting every time you read from MergeTree with the specified probability.\"},\n+              {\"allow_get_client_http_header\", false, false, \"Introduced a new function.\"},\n               {\"output_format_pretty_row_numbers\", false, true, \"It is better for usability.\"},\n               {\"output_format_pretty_max_value_width_apply_for_single_value\", true, false, \"Single values in Pretty formats won't be cut.\"},\n               {\"output_format_parquet_string_as_string\", false, true, \"ClickHouse allows arbitrary binary data in the String data type, which is typically UTF-8. Parquet/ORC/Arrow Strings only support UTF-8. That's why you can choose which Arrow's data type to use for the ClickHouse String data type - String or Binary. While Binary would be more correct and compatible, using String by default will correspond to user expectations in most cases.\"},\ndiff --git a/src/Functions/getClientHTTPHeader.cpp b/src/Functions/getClientHTTPHeader.cpp\nnew file mode 100644\nindex 000000000000..ebd070a90b99\n--- /dev/null\n+++ b/src/Functions/getClientHTTPHeader.cpp\n@@ -0,0 +1,96 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Columns/ColumnString.h>\n+#include <Interpreters/Context.h>\n+#include <Core/Field.h>\n+\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int FUNCTION_NOT_ALLOWED;\n+}\n+\n+namespace\n+{\n+\n+class FunctionGetClientHTTPHeader : public IFunction, WithContext\n+{\n+public:\n+    explicit FunctionGetClientHTTPHeader(ContextPtr context_)\n+        : WithContext(context_)\n+    {\n+        if (!getContext()->getSettingsRef().allow_get_client_http_header)\n+            throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"The function getClientHTTPHeader requires setting `allow_get_client_http_header` to be enabled.\");\n+    }\n+\n+    String getName() const override { return \"getClientHTTPHeader\"; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override { return false; }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        return 1;\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isString(arguments[0]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The argument of function {} must be String\", getName());\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        const ClientInfo & client_info = getContext()->getClientInfo();\n+\n+        const auto & source = arguments[0].column;\n+        auto result = result_type->createColumn();\n+        result->reserve(input_rows_count);\n+\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            Field header;\n+            source->get(row, header);\n+            if (auto it = client_info.http_headers.find(header.get<String>()); it != client_info.http_headers.end())\n+                result->insert(it->second);\n+            else\n+                result->insertDefault();\n+        }\n+\n+        return result;\n+    }\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(GetClientHTTPHeader)\n+{\n+    factory.registerFunction(\"getClientHTTPHeader\",\n+        [](ContextPtr context) { return std::make_shared<FunctionGetClientHTTPHeader>(context); },\n+        FunctionDocumentation{\n+            .description = R\"(\n+Get the value of an HTTP header.\n+\n+If there is no such header or the current request is not performed via the HTTP interface, the function returns an empty string.\n+Certain HTTP headers (e.g., `Authentication` and `X-ClickHouse-*`) are restricted.\n+\n+The function requires the setting `allow_get_client_http_header` to be enabled.\n+The setting is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info.\n+\n+HTTP headers are case sensitive for this function.\n+\n+If the function is used in the context of a distributed query, it returns non-empty result only on the initiator node.\n+\",\n+            .syntax = \"getClientHTTPHeader(name)\",\n+            .arguments = {{\"name\", \"The HTTP header name (String)\"}},\n+            .returned_value = \"The value of the header (String).\",\n+            .categories{\"Miscellaneous\"}});\n+}\n+\n+}\ndiff --git a/src/Interpreters/ClientInfo.cpp b/src/Interpreters/ClientInfo.cpp\nindex e4778edeb9cb..ce1efb61cc07 100644\n--- a/src/Interpreters/ClientInfo.cpp\n+++ b/src/Interpreters/ClientInfo.cpp\n@@ -5,6 +5,7 @@\n #include <IO/WriteHelpers.h>\n #include <Core/ProtocolDefines.h>\n #include <base/getFQDNOrHostName.h>\n+#include <Poco/Net/HTTPRequest.h>\n #include <unistd.h>\n \n #include <Common/config_version.h>\n@@ -255,7 +256,29 @@ String toString(ClientInfo::Interface interface)\n             return \"TCP_INTERSERVER\";\n     }\n \n-    return std::format(\"Unknown {}!\\n\", static_cast<int>(interface));\n+    return std::format(\"Unknown server interface ({}).\", static_cast<int>(interface));\n+}\n+\n+void ClientInfo::setFromHTTPRequest(const Poco::Net::HTTPRequest & request)\n+{\n+    http_method = ClientInfo::HTTPMethod::UNKNOWN;\n+    if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET)\n+        http_method = ClientInfo::HTTPMethod::GET;\n+    else if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST)\n+        http_method = ClientInfo::HTTPMethod::POST;\n+\n+    http_user_agent = request.get(\"User-Agent\", \"\");\n+    http_referer = request.get(\"Referer\", \"\");\n+    forwarded_for = request.get(\"X-Forwarded-For\", \"\");\n+\n+    for (const auto & header : request)\n+    {\n+        /// These headers can contain authentication info and shouldn't be accessible by the user.\n+        String key_lowercase = Poco::toLower(header.first);\n+        if (key_lowercase.starts_with(\"x-clickhouse\") || key_lowercase == \"authentication\")\n+            continue;\n+        http_headers[header.first] = header.second;\n+    }\n }\n \n }\ndiff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h\nindex 705243330475..c2ed9f7ffa44 100644\n--- a/src/Interpreters/ClientInfo.h\n+++ b/src/Interpreters/ClientInfo.h\n@@ -7,6 +7,12 @@\n #include <Common/VersionNumber.h>\n #include <boost/algorithm/string/trim.hpp>\n \n+\n+namespace Poco::Net\n+{\n+    class HTTPRequest;\n+}\n+\n namespace DB\n {\n \n@@ -93,6 +99,7 @@ class ClientInfo\n     HTTPMethod http_method = HTTPMethod::UNKNOWN;\n     String http_user_agent;\n     String http_referer;\n+    std::unordered_map<String, String> http_headers;\n \n     /// For mysql and postgresql\n     UInt64 connection_id = 0;\n@@ -135,6 +142,9 @@ class ClientInfo\n     /// Initialize parameters on client initiating query.\n     void setInitialQuery();\n \n+    /// Initialize parameters related to HTTP request.\n+    void setFromHTTPRequest(const Poco::Net::HTTPRequest & request);\n+\n     bool clientVersionEquals(const ClientInfo & other, bool compare_patch) const;\n \n     String getVersionStr() const;\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex c6bc10f3d50f..f86cb81c37f9 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -4640,11 +4640,9 @@ void Context::setClientConnectionId(uint32_t connection_id_)\n     client_info.connection_id = connection_id_;\n }\n \n-void Context::setHTTPClientInfo(ClientInfo::HTTPMethod http_method, const String & http_user_agent, const String & http_referer)\n+void Context::setHTTPClientInfo(const Poco::Net::HTTPRequest & request)\n {\n-    client_info.http_method = http_method;\n-    client_info.http_user_agent = http_user_agent;\n-    client_info.http_referer = http_referer;\n+    client_info.setFromHTTPRequest(request);\n     need_recalculate_access = true;\n }\n \ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex f7bf8282d8aa..8601d09621f4 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -642,7 +642,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     void setClientInterface(ClientInfo::Interface interface);\n     void setClientVersion(UInt64 client_version_major, UInt64 client_version_minor, UInt64 client_version_patch, unsigned client_tcp_protocol_version);\n     void setClientConnectionId(uint32_t connection_id);\n-    void setHTTPClientInfo(ClientInfo::HTTPMethod http_method, const String & http_user_agent, const String & http_referer);\n+    void setHTTPClientInfo(const Poco::Net::HTTPRequest & request);\n     void setForwardedFor(const String & forwarded_for);\n     void setQueryKind(ClientInfo::QueryKind query_kind);\n     void setQueryKindInitial();\ndiff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp\nindex b52f8a507e37..9f64380ab436 100644\n--- a/src/Interpreters/Session.cpp\n+++ b/src/Interpreters/Session.cpp\n@@ -429,18 +429,12 @@ void Session::setClientConnectionId(uint32_t connection_id)\n         prepared_client_info->connection_id = connection_id;\n }\n \n-void Session::setHTTPClientInfo(ClientInfo::HTTPMethod http_method, const String & http_user_agent, const String & http_referer)\n+void Session::setHTTPClientInfo(const Poco::Net::HTTPRequest & request)\n {\n     if (session_context)\n-    {\n-        session_context->setHTTPClientInfo(http_method, http_user_agent, http_referer);\n-    }\n+        session_context->setHTTPClientInfo(request);\n     else\n-    {\n-        prepared_client_info->http_method = http_method;\n-        prepared_client_info->http_user_agent = http_user_agent;\n-        prepared_client_info->http_referer = http_referer;\n-    }\n+        prepared_client_info->setFromHTTPRequest(request);\n }\n \n void Session::setForwardedFor(const String & forwarded_for)\ndiff --git a/src/Interpreters/Session.h b/src/Interpreters/Session.h\nindex 334560a33c8c..e6cb7ca20cd6 100644\n--- a/src/Interpreters/Session.h\n+++ b/src/Interpreters/Session.h\n@@ -65,7 +65,7 @@ class Session\n     void setClientInterface(ClientInfo::Interface interface);\n     void setClientVersion(UInt64 client_version_major, UInt64 client_version_minor, UInt64 client_version_patch, unsigned client_tcp_protocol_version);\n     void setClientConnectionId(uint32_t connection_id);\n-    void setHTTPClientInfo(ClientInfo::HTTPMethod http_method, const String & http_user_agent, const String & http_referer);\n+    void setHTTPClientInfo(const Poco::Net::HTTPRequest & request);\n     void setForwardedFor(const String & forwarded_for);\n     void setQuotaClientKey(const String & quota_key);\n     void setConnectionClientVersion(UInt64 client_version_major, UInt64 client_version_minor, UInt64 client_version_patch, unsigned client_tcp_protocol_version);\ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex c112eefec6c3..fd9be9992762 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -490,14 +490,7 @@ bool HTTPHandler::authenticateUser(\n \n     /// Set client info. It will be used for quota accounting parameters in 'setUser' method.\n \n-    ClientInfo::HTTPMethod http_method = ClientInfo::HTTPMethod::UNKNOWN;\n-    if (request.getMethod() == HTTPServerRequest::HTTP_GET)\n-        http_method = ClientInfo::HTTPMethod::GET;\n-    else if (request.getMethod() == HTTPServerRequest::HTTP_POST)\n-        http_method = ClientInfo::HTTPMethod::POST;\n-\n-    session->setHTTPClientInfo(http_method, request.get(\"User-Agent\", \"\"), request.get(\"Referer\", \"\"));\n-    session->setForwardedFor(request.get(\"X-Forwarded-For\", \"\"));\n+    session->setHTTPClientInfo(request);\n     session->setQuotaClientKey(quota_key);\n \n     /// Extract the last entry from comma separated list of forwarded_for addresses.\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex cd0cf3f1288d..ee3ef1ae7950 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1601,6 +1601,7 @@ geohashEncode\n geohashesInBox\n geoip\n geospatial\n+getClientHTTPHeader\n getMacro\n getOSKernelVersion\n getServerPort\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03021_get_client_http_header.reference b/tests/queries/0_stateless/03021_get_client_http_header.reference\nnew file mode 100644\nindex 000000000000..099bf1fa4e37\n--- /dev/null\n+++ b/tests/queries/0_stateless/03021_get_client_http_header.reference\n@@ -0,0 +1,26 @@\n+-- It works.\n+application/x-www-form-urlencoded\n+-- It supports non constant arguments.\n+application/x-www-form-urlencoded\n+*/*\n+-- Empty string for non-existent headers.\n+application/x-www-form-urlencoded\n+\n+-- I can use my own headers.\n+wtf\n+-- Some headers cannot be obtained.\n+\n+\n+-- The setting matters.\n+FUNCTION_NOT_ALLOWED\n+-- The setting is not enabled by default.\n+FUNCTION_NOT_ALLOWED\n+-- Are headers case-sentitive?\n+application/x-www-form-urlencoded\n+\n+-- Using it from non-HTTP does not make sense.\n+\n+\n+-- Does it work for distributed queries? (not yet, but maybe it will be needed later)\n+\n+\ndiff --git a/tests/queries/0_stateless/03021_get_client_http_header.sh b/tests/queries/0_stateless/03021_get_client_http_header.sh\nnew file mode 100755\nindex 000000000000..71486c725b4e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03021_get_client_http_header.sh\n@@ -0,0 +1,37 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+echo \"-- It works.\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader('Content-Type')\"\n+\n+echo \"-- It supports non constant arguments.\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader(arrayJoin(['Content-Type', 'Accept']))\"\n+\n+echo \"-- Empty string for non-existent headers.\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader(arrayJoin(['Content-Type', 'Upyachka']))\"\n+\n+echo \"-- I can use my own headers.\"\n+${CLICKHOUSE_CURL} -H 'Upyachka: wtf' \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader('Upyachka')\"\n+\n+echo \"-- Some headers cannot be obtained.\"\n+${CLICKHOUSE_CURL} -H 'X-ClickHouse-WTF: Secret' \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader('X-ClickHouse-WTF')\"\n+${CLICKHOUSE_CURL} -H 'Authentication: Secret' \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader('Authentication')\"\n+\n+echo \"-- The setting matters.\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=0\" -d \"SELECT getClientHTTPHeader(arrayJoin(['Content-Type', 'Accept']))\" | grep -o -F 'FUNCTION_NOT_ALLOWED'\n+\n+echo \"-- The setting is not enabled by default.\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}\" -d \"SELECT getClientHTTPHeader(arrayJoin(['Content-Type', 'Accept']))\" | grep -o -F 'FUNCTION_NOT_ALLOWED'\n+\n+echo \"-- Are headers case-sentitive?\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=1\" -d \"SELECT getClientHTTPHeader(arrayJoin(['Content-Type', 'content-type']))\"\n+\n+echo \"-- Using it from non-HTTP does not make sense.\"\n+${CLICKHOUSE_CLIENT} --allow_get_client_http_header true --query \"SELECT getClientHTTPHeader('Host')\"\n+${CLICKHOUSE_LOCAL} --allow_get_client_http_header true --query \"SELECT getClientHTTPHeader('Host')\"\n+\n+echo \"-- Does it work for distributed queries? (not yet, but maybe it will be needed later)\"\n+${CLICKHOUSE_CURL} \"${CLICKHOUSE_URL}&allow_get_client_http_header=1&prefer_localhost_replica=0\" -d \"SELECT getClientHTTPHeader(name) FROM clusterAllReplicas('test_cluster_one_shard_two_replicas', view(SELECT 'Content-Type' AS name))\"\n",
  "problem_statement": "A function to get HTTP headers from the current client's HTTP request\n**Use case**\r\n\r\nObtain the relevant data when some application sends the data directly to ClickHouse without a separate backend.\r\n\r\n```\r\nCREATE TABLE test (something String DEFAULT getClientHTTPHeader('X-CloudFlare-WTF')) ...\r\n```\r\n\r\nHeader names are case-insensitive. The function takes a constant String and returns a String.\r\nSome headers such as X-ClickHouse-Password should be restricted.\r\n\r\n**Describe the solution you'd like**\r\n\r\nSave the header's map to ClientInfo, and then get it from the function.\n",
  "hints_text": "Could you let me try this ?\r\n\n@lingtaolf amazing, thank you!",
  "created_at": "2024-03-23T20:50:13Z",
  "modified_files": [
    "docs/en/sql-reference/functions/other-functions.md",
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.h",
    "b/src/Functions/getClientHTTPHeader.cpp",
    "src/Interpreters/ClientInfo.cpp",
    "src/Interpreters/ClientInfo.h",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Interpreters/Session.cpp",
    "src/Interpreters/Session.h",
    "src/Server/HTTPHandler.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03021_get_client_http_header.reference",
    "b/tests/queries/0_stateless/03021_get_client_http_header.sh"
  ]
}