{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73326,
  "instance_id": "ClickHouse__ClickHouse-73326",
  "issue_numbers": [
    "73307"
  ],
  "base_commit": "3a568c0f607431776881c57fbc2b6746c339a82f",
  "patch": "diff --git a/src/Functions/CastOverloadResolver.cpp b/src/Functions/CastOverloadResolver.cpp\nindex 681f43be4668..b0370c354585 100644\n--- a/src/Functions/CastOverloadResolver.cpp\n+++ b/src/Functions/CastOverloadResolver.cpp\n@@ -28,8 +28,8 @@ FunctionBasePtr createFunctionBaseCast(\n     const ColumnsWithTypeAndName & arguments,\n     const DataTypePtr & return_type,\n     std::optional<CastDiagnostic> diagnostic,\n-    CastType cast_type);\n-\n+    CastType cast_type,\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior);\n \n /** CastInternal does not preserve nullability of the data type,\n   * i.e. CastInternal(toNullable(toInt8(1)) as Int32) will be Int32(1).\n@@ -80,7 +80,11 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n             context, cast_type, internal, diagnostic, settings_ref[Setting::cast_keep_nullable], DataTypeValidationSettings(settings_ref));\n     }\n \n-    static FunctionBasePtr createInternalCast(ColumnWithTypeAndName from, DataTypePtr to, CastType cast_type, std::optional<CastDiagnostic> diagnostic)\n+    static FunctionBasePtr createInternalCast(\n+        ColumnWithTypeAndName from,\n+        DataTypePtr to,\n+        CastType cast_type,\n+        std::optional<CastDiagnostic> diagnostic)\n     {\n         if (cast_type == CastType::accurateOrNull && !isVariant(to))\n             to = makeNullable(to);\n@@ -89,13 +93,23 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n         arguments.emplace_back(std::move(from));\n         arguments.emplace_back().type = std::make_unique<DataTypeString>();\n \n-        return createFunctionBaseCast(nullptr, getNameImpl(cast_type, true), arguments, to, diagnostic, cast_type);\n+        /// We consistently use Saturate for internal toDateTime conversion to ensure monotonic so that index analysis is correct.\n+        /// Reference: https://github.com/ClickHouse/ClickHouse/issues/73307\n+        return createFunctionBaseCast(\n+            nullptr, getNameImpl(cast_type, true), arguments, to, diagnostic, cast_type, FormatSettings::DateTimeOverflowBehavior::Saturate);\n     }\n \n protected:\n     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n     {\n-        return createFunctionBaseCast(context, getNameImpl(cast_type, internal), arguments, return_type, diagnostic, cast_type);\n+        return createFunctionBaseCast(\n+            context,\n+            getNameImpl(cast_type, internal),\n+            arguments,\n+            return_type,\n+            diagnostic,\n+            cast_type,\n+            FormatSettings::DateTimeOverflowBehavior::Ignore);\n     }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 93745cfd7a15..08b3542776b0 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -56,7 +56,7 @@ constexpr time_t MAX_DATETIME64_TIMESTAMP = 10413791999LL;    //  1900-01-01 00:\n constexpr time_t MIN_DATETIME64_TIMESTAMP = -2208988800LL;    //  2299-12-31 23:59:59 UTC\n constexpr time_t MAX_DATETIME_TIMESTAMP = 0xFFFFFFFF;\n constexpr time_t MAX_DATE_TIMESTAMP = 5662310399;       // 2149-06-06 23:59:59 UTC\n-constexpr time_t MAX_DATETIME_DAY_NUM =  49710;               // 2106-02-07\n+constexpr time_t MAX_DATETIME_DAY_NUM =  49709;         // 2106-02-06 America/Hermosillo\n \n [[noreturn]] void throwDateIsNotSupported(const char * name);\n [[noreturn]] void throwDate32IsNotSupported(const char * name);\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex 0513be5ea44a..5334008b3219 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -45,7 +45,8 @@ FunctionBasePtr createFunctionBaseCast(\n     const ColumnsWithTypeAndName & arguments,\n     const DataTypePtr & return_type,\n     std::optional<CastDiagnostic> diagnostic,\n-    CastType cast_type)\n+    CastType cast_type,\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior)\n {\n     DataTypes data_types(arguments.size());\n \n@@ -75,7 +76,8 @@ FunctionBasePtr createFunctionBaseCast(\n     {\n     }\n \n-    return std::make_unique<detail::FunctionCast>(context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n+    return std::make_unique<detail::FunctionCast>(\n+        context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type, date_time_overflow_behavior);\n }\n \n }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 99feffa83a7d..324cf081c51b 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -2143,8 +2143,21 @@ class FunctionConvert : public IFunction\n     static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n     static constexpr bool to_decimal = IsDataTypeDecimal<ToDataType> && !to_datetime64;\n \n-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionConvert>(context); }\n-    explicit FunctionConvert(ContextPtr context_) : context(context_) {}\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionConvert>(context, default_date_time_overflow_behavior);\n+    }\n+\n+    static FunctionPtr createWithOverflow(ContextPtr context, FormatSettings::DateTimeOverflowBehavior _datetime_overflow_behavior)\n+    {\n+        return std::make_shared<FunctionConvert>(context, _datetime_overflow_behavior);\n+    }\n+\n+    explicit FunctionConvert(ContextPtr context_, FormatSettings::DateTimeOverflowBehavior _datetime_overflow_behavior)\n+        : context(context_)\n+        , datetime_overflow_behavior(_datetime_overflow_behavior)\n+    {\n+    }\n \n     String getName() const override\n     {\n@@ -2335,6 +2348,7 @@ class FunctionConvert : public IFunction\n \n private:\n     ContextPtr context;\n+    FormatSettings::DateTimeOverflowBehavior datetime_overflow_behavior;\n     mutable bool checked_return_type = false;\n     mutable bool to_nullable = false;\n \n@@ -2349,10 +2363,10 @@ class FunctionConvert : public IFunction\n         const DataTypePtr from_type = removeNullable(arguments[0].type);\n         ColumnPtr result_column;\n \n-        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n+        FormatSettings::DateTimeOverflowBehavior context_datetime_overflow_behavior = datetime_overflow_behavior;\n \n         if (context)\n-            date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior].value;\n+            context_datetime_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior].value;\n \n         if (isDynamic(from_type))\n         {\n@@ -2386,7 +2400,7 @@ class FunctionConvert : public IFunction\n                 const ColumnWithTypeAndName & scale_column = arguments[1];\n                 UInt32 scale = extractToDecimalScale(scale_column);\n \n-                switch (date_time_overflow_behavior)\n+                switch (context_datetime_overflow_behavior)\n                 {\n                     case FormatSettings::DateTimeOverflowBehavior::Throw:\n                         result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, scale);\n@@ -2402,7 +2416,7 @@ class FunctionConvert : public IFunction\n             else if constexpr (IsDataTypeDateOrDateTime<RightDataType> && std::is_same_v<LeftDataType, DataTypeDateTime64>)\n             {\n                 const auto * dt64 = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get());\n-                switch (date_time_overflow_behavior)\n+                switch (context_datetime_overflow_behavior)\n                 {\n                     case FormatSettings::DateTimeOverflowBehavior::Throw:\n                         result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, from_string_tag, dt64->getScale());\n@@ -2423,7 +2437,7 @@ class FunctionConvert : public IFunction\n         result_column = ConvertImpl<LeftDataType, RightDataType, Name, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::execute( \\\n             arguments, result_type, input_rows_count, from_string_tag); \\\n         break;\n-                switch (date_time_overflow_behavior)\n+                switch (context_datetime_overflow_behavior)\n                 {\n                     GENERATE_OVERFLOW_MODE_CASE(Throw)\n                     GENERATE_OVERFLOW_MODE_CASE(Ignore)\n@@ -3077,17 +3091,10 @@ template <> struct FunctionTo<DataTypeBFloat16> { using Type = FunctionToBFloat1\n template <> struct FunctionTo<DataTypeFloat32> { using Type = FunctionToFloat32; };\n template <> struct FunctionTo<DataTypeFloat64> { using Type = FunctionToFloat64; };\n \n-template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n-struct FunctionTo<DataTypeDate, date_time_overflow_behavior> { using Type = FunctionToDate; };\n-\n-template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n-struct FunctionTo<DataTypeDate32, date_time_overflow_behavior> { using Type = FunctionToDate32; };\n-\n-template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n-struct FunctionTo<DataTypeDateTime, date_time_overflow_behavior> { using Type = FunctionToDateTime; };\n-\n-template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n-struct FunctionTo<DataTypeDateTime64, date_time_overflow_behavior> { using Type = FunctionToDateTime64; };\n+template <> struct FunctionTo<DataTypeDate> { using Type = FunctionToDate; };\n+template <> struct FunctionTo<DataTypeDate32> { using Type = FunctionToDate32; };\n+template <> struct FunctionTo<DataTypeDateTime> { using Type = FunctionToDateTime; };\n+template <> struct FunctionTo<DataTypeDateTime64> { using Type = FunctionToDateTime64; };\n \n template <> struct FunctionTo<DataTypeUUID> { using Type = FunctionToUUID; };\n template <> struct FunctionTo<DataTypeIPv4> { using Type = FunctionToIPv4; };\n@@ -3416,11 +3423,13 @@ class FunctionCast final : public IFunctionBase\n             , const DataTypes & argument_types_\n             , const DataTypePtr & return_type_\n             , std::optional<CastDiagnostic> diagnostic_\n-            , CastType cast_type_)\n+            , CastType cast_type_\n+            , FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior)\n         : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n         , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n         , cast_type(cast_type_)\n         , context(context_)\n+        , function_date_time_overflow_behavior(date_time_overflow_behavior)\n     {\n     }\n \n@@ -3467,6 +3476,7 @@ class FunctionCast final : public IFunctionBase\n     std::optional<CastDiagnostic> diagnostic;\n     CastType cast_type;\n     ContextPtr context;\n+    FormatSettings::DateTimeOverflowBehavior function_date_time_overflow_behavior;\n \n     static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)\n     {\n@@ -3498,7 +3508,7 @@ class FunctionCast final : public IFunctionBase\n             && (which.isInt() || which.isUInt() || which.isFloat());\n         can_apply_accurate_cast |= cast_type == CastType::accurate && which.isStringOrFixedString() && to.isNativeInteger();\n \n-        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n+        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = function_date_time_overflow_behavior;\n         if (context)\n             date_time_overflow_behavior = context->getSettingsRef()[Setting::date_time_overflow_behavior];\n \n@@ -3511,8 +3521,16 @@ class FunctionCast final : public IFunctionBase\n         }\n         else if (!can_apply_accurate_cast)\n         {\n-            FunctionPtr function = FunctionTo<ToDataType>::Type::create(context);\n-            return createFunctionAdaptor(function, from_type);\n+            if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n+            {\n+                FunctionPtr function = FunctionTo<DataTypeDateTime>::Type::createWithOverflow(context, date_time_overflow_behavior);\n+                return createFunctionAdaptor(function, from_type);\n+            }\n+            else\n+            {\n+                FunctionPtr function = FunctionTo<ToDataType>::Type::create(context);\n+                return createFunctionAdaptor(function, from_type);\n+            }\n         }\n \n         return [wrapper_cast_type = cast_type, from_type_index, to_type, date_time_overflow_behavior]\n@@ -3681,7 +3699,7 @@ class FunctionCast final : public IFunctionBase\n \n #define GENERATE_INTERVAL_CASE(INTERVAL_KIND) \\\n             case IntervalKind::Kind::INTERVAL_KIND: \\\n-                return createFunctionAdaptor(FunctionConvert<DataTypeInterval, NameToInterval##INTERVAL_KIND, PositiveMonotonicity>::create(context), from_type);\n+                return createFunctionAdaptor(FunctionConvert<DataTypeInterval, NameToInterval##INTERVAL_KIND, PositiveMonotonicity>::createWithOverflow(context, function_date_time_overflow_behavior), from_type);\n \n     WrapperType createIntervalWrapper(const DataTypePtr & from_type, IntervalKind kind) const\n     {\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 34e361a759b3..c4338b253d90 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -52,7 +52,8 @@ namespace DB\n {\n namespace Setting\n {\n-extern const SettingsBool analyze_index_with_space_filling_curves;\n+    extern const SettingsBool analyze_index_with_space_filling_curves;\n+    extern const SettingsDateTimeOverflowBehavior date_time_overflow_behavior;\n }\n \n namespace ErrorCodes\n@@ -855,6 +856,8 @@ KeyCondition::KeyCondition(\n     : key_expr(key_expr_)\n     , key_subexpr_names(getAllSubexpressionNames(*key_expr))\n     , single_point(single_point_)\n+    , date_time_overflow_behavior_ignore(\n+          context->getSettingsRef()[Setting::date_time_overflow_behavior] == FormatSettings::DateTimeOverflowBehavior::Ignore)\n {\n     size_t key_index = 0;\n     for (const auto & name : key_column_names_)\n@@ -1063,6 +1066,24 @@ bool applyFunctionChainToColumn(\n     return true;\n }\n \n+bool KeyCondition::isFunctionReallyMonotonic(const IFunctionBase & func, const IDataType & arg_type) const\n+{\n+    if (date_time_overflow_behavior_ignore && func.getName() == \"toDateTime\")\n+    {\n+        const IDataType * type = &arg_type;\n+        if (const auto * lowcard_type = typeid_cast<const DataTypeLowCardinality *>(type))\n+            type = lowcard_type->getDictionaryType().get();\n+        if (const auto * nullable_type = typeid_cast<const DataTypeNullable *>(type))\n+            type = nullable_type->getNestedType().get();\n+\n+        /// toDateTime(date) may overflow, breaking monotonicity.\n+        if (isDateOrDate32(type))\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n     const RPNBuilderTreeNode & node,\n     size_t & out_key_column_num,\n@@ -1088,11 +1109,14 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n         out_key_column_num,\n         out_key_column_type,\n         transform_functions,\n-        [](const IFunctionBase & func, const IDataType & type)\n+        [this](const IFunctionBase & func, const IDataType & type)\n         {\n             if (!func.hasInformationAboutMonotonicity())\n                 return false;\n \n+            if (!isFunctionReallyMonotonic(func, type))\n+                return false;\n+\n             /// Range is irrelevant in this case.\n             auto monotonicity = func.getMonotonicityForRange(type, Field(), Field());\n             if (!monotonicity.is_always_monotonic)\n@@ -1584,6 +1608,9 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(\n         if (!func || !func->isDeterministicInScopeOfQuery() || (!assume_function_monotonicity && !func->hasInformationAboutMonotonicity()))\n             return false;\n \n+        if (!isFunctionReallyMonotonic(*func, *key_column_type))\n+            return false;\n+\n         key_column_type = func->getResultType();\n         if (kind == FunctionWithOptionalConstArg::Kind::NO_CONST)\n             out_functions_chain.push_back(func);\n@@ -1796,10 +1823,7 @@ bool KeyCondition::extractMonotonicFunctionsChainFromKey(\n                     {\n                         const auto & arg_types = func_base->getArgumentTypes();\n                         if (!arg_types.empty() && isStringOrFixedString(arg_types[0]))\n-                        {\n                             func_name = func_name + \"OrNull\";\n-                        }\n-\n                     }\n \n                     auto func_builder = FunctionFactory::instance().tryGet(func_name, context);\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex 252a1e8a1ce5..ec7126d2d8e2 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -409,6 +409,15 @@ class KeyCondition\n     /// PartitionPruner.\n     bool single_point;\n \n+\n+    /// Determines if a function maintains monotonicity.\n+    /// Currently only does special checks for toDateTime monotonicity.\n+    bool isFunctionReallyMonotonic(const IFunctionBase & func, const IDataType & arg_type) const;\n+\n+    /// Holds the result of (setting.date_time_overflow_behavior == DateTimeOverflowBehavior::Ignore)\n+    /// Used to check toDateTime monotonicity.\n+    bool date_time_overflow_behavior_ignore;\n+\n     /// If true, this key condition is relaxed. When a key condition is relaxed, it\n     /// is considered weakened. This is because keys may not always align perfectly\n     /// with the condition specified in the query, and the aim is to enhance the\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02900_date_time_check_overflow.reference b/tests/queries/0_stateless/02900_date_time_check_overflow.reference\nindex 26bbfc8752f6..e1686f257274 100644\n--- a/tests/queries/0_stateless/02900_date_time_check_overflow.reference\n+++ b/tests/queries/0_stateless/02900_date_time_check_overflow.reference\n@@ -14,8 +14,8 @@ saturate\n 1970-01-01 00:00:00\n 2106-02-07 06:28:15\n 1970-01-01 00:00:00\n-2106-02-07 00:00:00\n-2106-02-07 00:00:00\n+2106-02-06 00:00:00\n+2106-02-06 00:00:00\n 1970-01-01\n 2149-06-06\n 2149-06-06\ndiff --git a/tests/queries/0_stateless/03271_date_to_datetime_saturation.reference b/tests/queries/0_stateless/03271_date_to_datetime_saturation.reference\nnew file mode 100644\nindex 000000000000..7d7a4b6d53df\n--- /dev/null\n+++ b/tests/queries/0_stateless/03271_date_to_datetime_saturation.reference\n@@ -0,0 +1,113 @@\n+-- { echoOn }\n+-- implicit toDateTime (always saturate)\n+select count() from test where stamp >= parseDateTimeBestEffort('2024-11-01');\n+200\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'saturate';\n+200\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'ignore';\n+100\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'throw'; -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+drop table test;\n+create table test (stamp Date) engine MergeTree order by stamp settings index_granularity = 20;\n+insert into test select number from numbers(65536);\n+set session_timezone = 'UTC'; -- The following tests are timezone sensitive\n+set optimize_use_implicit_projections = 0;\n+-- Boundary at UNIX epoch\n+SELECT count() FROM test WHERE stamp >= toDateTime(0) SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(0);\n+65536\n+-- Arbitrary DateTime\n+SELECT count() FROM test WHERE stamp >= toDateTime('2024-10-24 21:30:00') SETTINGS force_primary_key = 1;\n+45515\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2024-10-24 21:30:00');\n+45515\n+-- Extreme value beyond supported range\n+SELECT count() FROM test WHERE stamp >= toDateTime(4294967295) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(4294967295);\n+0\n+-- Negative timestamp\n+SELECT count() FROM test WHERE stamp >= toDateTime(-1) SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(-1);\n+65536\n+-- Pre-Gregorian date\n+SELECT count() FROM test WHERE stamp >= toDateTime('1000-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('1000-01-01 00:00:00');\n+65536\n+-- UNIX epoch\n+SELECT count() FROM test WHERE stamp >= toDateTime('1970-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('1970-01-01 00:00:00');\n+65536\n+-- Modern date within supported range\n+SELECT count() FROM test WHERE stamp >= toDateTime('2023-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+46178\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2023-01-01 00:00:00');\n+46178\n+-- Far future but still valid\n+SELECT count() FROM test WHERE stamp >= toDateTime('2100-12-31 23:59:59') SETTINGS force_primary_key = 1;\n+17689\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2100-12-31 23:59:59');\n+17689\n+-- Maximum 32-bit timestamp\n+SELECT count() FROM test WHERE stamp >= toDateTime(2147483647) SETTINGS force_primary_key = 1;\n+40680\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(2147483647);\n+40680\n+-- Maximum 32-bit unsigned overflow\n+SELECT count() FROM test WHERE stamp >= toDateTime(4294967295) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(4294967295);\n+0\n+-- Minimum Date boundary\n+SELECT count() FROM test WHERE stamp >= toDate('0000-01-01') SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE identity(stamp) >= toDate('0000-01-01');\n+65536\n+-- Maximum Date boundary\n+SELECT count() FROM test WHERE stamp >= toDate('9999-12-31') SETTINGS force_primary_key = 1;\n+1\n+SELECT count() FROM test WHERE identity(stamp) >= toDate('9999-12-31');\n+1\n+-- Convert stamp to Date\n+SELECT count() FROM test WHERE toDate(stamp) >= toDateTime(0) SETTINGS force_primary_key = 1;\n+65536\n+SELECT count() FROM test WHERE toDate(identity(stamp)) >= toDateTime(0);\n+65536\n+-- Convert stamp to DateTime (This will overflow and should not use primary key)\n+SELECT count() FROM test WHERE toDateTime(stamp) >= toDateTime(0) SETTINGS force_primary_key = 1; -- { serverError INDEX_NOT_USED }\n+SELECT count() FROM test WHERE toDateTime(identity(stamp)) >= toDateTime(0);\n+65536\n+-- Exact Date match\n+SELECT count() FROM test WHERE stamp = toDate('2023-01-01') SETTINGS force_primary_key = 1;\n+1\n+SELECT count() FROM test WHERE identity(stamp) = toDate('2023-01-01');\n+1\n+-- Exact DateTime match\n+SELECT count() FROM test WHERE stamp = toDateTime('2023-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+1\n+SELECT count() FROM test WHERE identity(stamp) = toDateTime('2023-01-01 00:00:00');\n+1\n+-- Invalid DateTime (negative)\n+SELECT count() FROM test WHERE stamp < toDateTime(-1) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) < toDateTime(-1);\n+0\n+-- Extremely large DateTime\n+SELECT count() FROM test WHERE stamp > toDateTime(9999999999) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) > toDateTime(9999999999);\n+0\n+-- NULL DateTime\n+SELECT count() FROM test WHERE stamp >= toDateTime(NULL) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(NULL);\n+0\n+-- NULL Date\n+SELECT count() FROM test WHERE stamp <= toDate(NULL) SETTINGS force_primary_key = 1;\n+0\n+SELECT count() FROM test WHERE identity(stamp) <= toDate(NULL);\n+0\ndiff --git a/tests/queries/0_stateless/03271_date_to_datetime_saturation.sql b/tests/queries/0_stateless/03271_date_to_datetime_saturation.sql\nnew file mode 100644\nindex 000000000000..812033490035\n--- /dev/null\n+++ b/tests/queries/0_stateless/03271_date_to_datetime_saturation.sql\n@@ -0,0 +1,106 @@\n+drop table if exists test;\n+\n+create table test (stamp Date) engine MergeTree order by stamp;\n+\n+insert into test select '2024-10-30' from numbers(100);\n+insert into test select '2024-11-19' from numbers(100);\n+insert into test select '2149-06-06' from numbers(100);\n+\n+optimize table test final;\n+\n+-- { echoOn }\n+-- implicit toDateTime (always saturate)\n+select count() from test where stamp >= parseDateTimeBestEffort('2024-11-01');\n+\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'saturate';\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'ignore';\n+select count() from test where toDateTime(stamp) >= parseDateTimeBestEffort('2024-11-01') settings date_time_overflow_behavior = 'throw'; -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+\n+drop table test;\n+\n+create table test (stamp Date) engine MergeTree order by stamp settings index_granularity = 20;\n+\n+insert into test select number from numbers(65536);\n+\n+set session_timezone = 'UTC'; -- The following tests are timezone sensitive\n+set optimize_use_implicit_projections = 0;\n+\n+-- Boundary at UNIX epoch\n+SELECT count() FROM test WHERE stamp >= toDateTime(0) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(0);\n+\n+-- Arbitrary DateTime\n+SELECT count() FROM test WHERE stamp >= toDateTime('2024-10-24 21:30:00') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2024-10-24 21:30:00');\n+\n+-- Extreme value beyond supported range\n+SELECT count() FROM test WHERE stamp >= toDateTime(4294967295) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(4294967295);\n+\n+-- Negative timestamp\n+SELECT count() FROM test WHERE stamp >= toDateTime(-1) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(-1);\n+\n+-- Pre-Gregorian date\n+SELECT count() FROM test WHERE stamp >= toDateTime('1000-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('1000-01-01 00:00:00');\n+\n+-- UNIX epoch\n+SELECT count() FROM test WHERE stamp >= toDateTime('1970-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('1970-01-01 00:00:00');\n+\n+-- Modern date within supported range\n+SELECT count() FROM test WHERE stamp >= toDateTime('2023-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2023-01-01 00:00:00');\n+\n+-- Far future but still valid\n+SELECT count() FROM test WHERE stamp >= toDateTime('2100-12-31 23:59:59') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime('2100-12-31 23:59:59');\n+\n+-- Maximum 32-bit timestamp\n+SELECT count() FROM test WHERE stamp >= toDateTime(2147483647) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(2147483647);\n+\n+-- Maximum 32-bit unsigned overflow\n+SELECT count() FROM test WHERE stamp >= toDateTime(4294967295) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(4294967295);\n+\n+-- Minimum Date boundary\n+SELECT count() FROM test WHERE stamp >= toDate('0000-01-01') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDate('0000-01-01');\n+\n+-- Maximum Date boundary\n+SELECT count() FROM test WHERE stamp >= toDate('9999-12-31') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDate('9999-12-31');\n+\n+-- Convert stamp to Date\n+SELECT count() FROM test WHERE toDate(stamp) >= toDateTime(0) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE toDate(identity(stamp)) >= toDateTime(0);\n+\n+-- Convert stamp to DateTime (This will overflow and should not use primary key)\n+SELECT count() FROM test WHERE toDateTime(stamp) >= toDateTime(0) SETTINGS force_primary_key = 1; -- { serverError INDEX_NOT_USED }\n+SELECT count() FROM test WHERE toDateTime(identity(stamp)) >= toDateTime(0);\n+\n+-- Exact Date match\n+SELECT count() FROM test WHERE stamp = toDate('2023-01-01') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) = toDate('2023-01-01');\n+\n+-- Exact DateTime match\n+SELECT count() FROM test WHERE stamp = toDateTime('2023-01-01 00:00:00') SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) = toDateTime('2023-01-01 00:00:00');\n+\n+-- Invalid DateTime (negative)\n+SELECT count() FROM test WHERE stamp < toDateTime(-1) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) < toDateTime(-1);\n+\n+-- Extremely large DateTime\n+SELECT count() FROM test WHERE stamp > toDateTime(9999999999) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) > toDateTime(9999999999);\n+\n+-- NULL DateTime\n+SELECT count() FROM test WHERE stamp >= toDateTime(NULL) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) >= toDateTime(NULL);\n+\n+-- NULL Date\n+SELECT count() FROM test WHERE stamp <= toDate(NULL) SETTINGS force_primary_key = 1;\n+SELECT count() FROM test WHERE identity(stamp) <= toDate(NULL);\n",
  "problem_statement": "Comparison between Date and Datetime is broken in primary index\n**Company or project name**\r\n\r\nClickHouse inc.\r\n\r\n**Describe what's wrong**\r\n\r\n```\r\nCREATE TABLE test (stamp Date)\r\nENGINE = MergeTree\r\nORDER BY stamp;\r\n\r\nINSERT INTO TABLE test SELECT '2024-10-30' FROM numbers(100);\r\nINSERT INTO TABLE test SELECT '2024-11-19' FROM numbers(100);\r\nINSERT INTO TABLE test SELECT '2149-06-06' FROM numbers(100);\r\n\r\nOPTIMIZE TABLE test FINAL;\r\n\r\nSELECT count()\r\nFROM test\r\nWHERE stamp >= parseDateTimeBestEffort('2024-11-01'); --- 0\r\n\r\nSELECT count()\r\nFROM test\r\nWHERE stamp >= toDate('2024-11-01'); --- 200 (right answer)\r\n```\r\n\r\nhttps://fiddle.clickhouse.com/02714019-3055-43a4-a6a8-93f7de167f9d\r\n\r\n**Does it reproduce on the most recent release?**\r\n\r\nYes, moreover, it almost never worked correctly.\r\n\r\n22.8: broken https://fiddle.clickhouse.com/7638e77a-7c21-4f37-93cb-e148554d26ec, result is 0 200\r\n21.4: broken https://fiddle.clickhouse.com/a58bbc8e-1241-46d7-863d-4017abd3d9a7, result is 0 200\r\n21.3: broken https://fiddle.clickhouse.com/488b9375-5d95-433f-901a-9700f0497f9e, result is 100 100\r\n1.1.54394: broken https://fiddle.clickhouse.com/f2198f60-0797-437e-91d0-da858c94a843, result is 0 100\r\n\r\nRight answer is 200 200.\r\n\r\n\r\nPrevious attempts to fix similar issue: https://github.com/ClickHouse/ClickHouse/issues/17122 CC @amosbird \n",
  "hints_text": "The problem here is that the range of `Date` type (`[1970-01-01, 2149-06-06]`) cannot be represented after conversion to `DateTime` which has range (`[1970-01-01 00:00:00, 2106-02-07 06:28:15]`). We convert both sides of predicate to the common type during index analysis and it becomes wrong in that case.\r\n\r\nActually the result of the first query is not 200, but it depends on the value of `date_time_overflow_behavior ` setting:\r\n\r\n```sql\r\nSELECT count()\r\nFROM test\r\nWHERE identity(toDateTime(stamp)) >= parseDateTimeBestEffort('2024-11-01')\r\nSETTINGS date_time_overflow_behavior = 'ignore';\r\n\r\n   \u250c\u2500count()\u2500\u2510\r\n1. \u2502     100 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT count()\r\nFROM test\r\nWHERE identity(toDateTime(stamp)) >= parseDateTimeBestEffort('2024-11-01')\r\nSETTINGS date_time_overflow_behavior = 'saturate';\r\n\r\n   \u250c\u2500count()\u2500\u2510\r\n1. \u2502     200 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT count()\r\nFROM test\r\nWHERE identity(toDateTime(stamp)) >= parseDateTimeBestEffort('2024-11-01')\r\nSETTINGS date_time_overflow_behavior = 'throw';\r\n\r\nReceived exception from server (version 24.12.1):\r\nCode: 321. DB::Exception: Received from localhost:9000. DB::Exception: Day number 65535 is out of bounds of type DateTime: while executing 'FUNCTION toDateTime(stamp :: 0) -> toDateTime(__table1.stamp) DateTime : 2'. (VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE)\r\n```\r\n\r\nI don't really know a good fix for this issue. There are some options:\r\n\r\n- Return `DateTime64(0)` as a common type for `Date` and `DateTime`. Most likely it will be backward incompatible in a some way. Also it can make the performance worse.\r\n- Use `date_time_overflow_behavior = 'saturate'` for implicit internal conversion because now we don't use context for internal conversions and always choose the default value (`ignore`). For me this transformantion looks valid for index analysis, but I'm not 100% sure. It requires some formal proof.\r\n- Use `date_time_overflow_behavior = 'throw'` during index analysis. Catch the exception and don't use index if we cannot safely convert column. But it looks too ad hoc.\r\n- Do nothing with it.\r\n\r\nI'd choose the second option if it proved to be correct.\r\n\n> It requires some formal proof.\r\n\r\nWhat kind of \"formal proof\" do you refer to? IIUC, it should be consistent as long as the expression used in index analysis behaves the same as the one in pipeline, which seems obvious for internal conversions.",
  "created_at": "2024-12-14T18:20:50Z",
  "modified_files": [
    "src/Functions/CastOverloadResolver.cpp",
    "src/Functions/DateTimeTransforms.h",
    "src/Functions/FunctionsConversion.cpp",
    "src/Functions/FunctionsConversion.h",
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/KeyCondition.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02900_date_time_check_overflow.reference",
    "b/tests/queries/0_stateless/03271_date_to_datetime_saturation.reference",
    "b/tests/queries/0_stateless/03271_date_to_datetime_saturation.sql"
  ]
}