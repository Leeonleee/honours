diff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h
index aef0c8805bb9..2333fc56218d 100644
--- a/src/Analyzer/QueryNode.h
+++ b/src/Analyzer/QueryNode.h
@@ -602,9 +602,21 @@ class QueryNode final : public IQueryTreeNode
         return projection_columns;
     }
 
+    /// Returns true if query node is resolved, false otherwise
+    bool isResolved() const
+    {
+        return !projection_columns.empty();
+    }
+
     /// Resolve query node projection columns
     void resolveProjectionColumns(NamesAndTypes projection_columns_value);
 
+    /// Clear query node projection columns
+    void clearProjectionColumns()
+    {
+        projection_columns.clear();
+    }
+
     /// Remove unused projection columns
     void removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns);
 
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index cb3087af707c..c2eac8d008b7 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -2958,27 +2958,29 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
             /// Replace storage with values storage of insertion block
             if (StoragePtr storage = scope.context->getViewSource())
             {
-                QueryTreeNodePtr table_expression;
+                QueryTreeNodePtr table_expression = in_second_argument;
+
                 /// Process possibly nested sub-selects
-                for (auto * query_node = in_second_argument->as<QueryNode>(); query_node; query_node = table_expression->as<QueryNode>())
-                    table_expression = extractLeftTableExpression(query_node->getJoinTree());
+                while (table_expression)
+                {
+                    if (auto * query_node = table_expression->as<QueryNode>())
+                        table_expression = extractLeftTableExpression(query_node->getJoinTree());
+                    else if (auto * union_node = table_expression->as<UnionNode>())
+                        table_expression = union_node->getQueries().getNodes().at(0);
+                    else
+                        break;
+                }
 
-                if (table_expression)
+                TableNode * table_expression_table_node = table_expression ? table_expression->as<TableNode>() : nullptr;
+
+                if (table_expression_table_node &&
+                    table_expression_table_node->getStorageID().getFullNameNotQuoted() == storage->getStorageID().getFullNameNotQuoted())
                 {
-                    if (auto * query_table_node = table_expression->as<TableNode>())
-                    {
-                        if (query_table_node->getStorageID().getFullNameNotQuoted() == storage->getStorageID().getFullNameNotQuoted())
-                        {
-                            auto replacement_table_expression = std::make_shared<TableNode>(storage, scope.context);
-                            if (std::optional<TableExpressionModifiers> table_expression_modifiers = query_table_node->getTableExpressionModifiers())
-                                replacement_table_expression->setTableExpressionModifiers(*table_expression_modifiers);
-                            in_second_argument = in_second_argument->cloneAndReplace(table_expression, std::move(replacement_table_expression));
-                        }
-                    }
+                    auto replacement_table_expression_table_node = table_expression_table_node->clone();
+                    replacement_table_expression_table_node->as<TableNode &>().updateStorage(storage, scope.context);
+                    in_second_argument = in_second_argument->cloneAndReplace(table_expression, std::move(replacement_table_expression_table_node));
                 }
             }
-
-            resolveExpressionNode(in_second_argument, scope, false /*allow_lambda_expression*/, true /*allow_table_expression*/);
         }
 
         /// Edge case when the first argument of IN is scalar subquery.
@@ -5310,6 +5312,16 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
 
     auto & query_node_typed = query_node->as<QueryNode &>();
 
+    /** It is unsafe to call resolveQuery on already resolved query node, because during identifier resolution process
+      * we replace identifiers with expressions without aliases, also at the end of resolveQuery all aliases from all nodes will be removed.
+      * For subsequent resolveQuery executions it is possible to have wrong projection header, because for nodes
+      * with aliases projection name is alias.
+      *
+      * If for client it is necessary to resolve query node after clone, client must clear projection columns from query node before resolve.
+      */
+    if (query_node_typed.isResolved())
+        return;
+
     if (query_node_typed.isCTE())
         ctes_in_resolve_process.insert(query_node_typed.getCTEName());
 
@@ -5675,6 +5687,9 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier
 {
     auto & union_node_typed = union_node->as<UnionNode &>();
 
+    if (union_node_typed.isResolved())
+        return;
+
     if (union_node_typed.isCTE())
         ctes_in_resolve_process.insert(union_node_typed.getCTEName());
 
diff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp
index 6f70f01e5190..545a6b2195be 100644
--- a/src/Analyzer/UnionNode.cpp
+++ b/src/Analyzer/UnionNode.cpp
@@ -35,6 +35,7 @@ namespace ErrorCodes
 {
     extern const int TYPE_MISMATCH;
     extern const int BAD_ARGUMENTS;
+    extern const int LOGICAL_ERROR;
 }
 
 UnionNode::UnionNode(ContextMutablePtr context_, SelectUnionMode union_mode_)
@@ -50,6 +51,26 @@ UnionNode::UnionNode(ContextMutablePtr context_, SelectUnionMode union_mode_)
     children[queries_child_index] = std::make_shared<ListNode>();
 }
 
+bool UnionNode::isResolved() const
+{
+    for (const auto & query_node : getQueries().getNodes())
+    {
+        bool is_resolved = false;
+
+        if (auto * query_node_typed = query_node->as<QueryNode>())
+            is_resolved = query_node_typed->isResolved();
+        else if (auto * union_node_typed = query_node->as<UnionNode>())
+            is_resolved = union_node_typed->isResolved();
+        else
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected query tree node type in UNION node");
+
+        if (!is_resolved)
+            return false;
+    }
+
+    return true;
+}
+
 NamesAndTypes UnionNode::computeProjectionColumns() const
 {
     if (recursive_cte_table)
diff --git a/src/Analyzer/UnionNode.h b/src/Analyzer/UnionNode.h
index 40baad1ad57c..85d6afb1e478 100644
--- a/src/Analyzer/UnionNode.h
+++ b/src/Analyzer/UnionNode.h
@@ -163,6 +163,9 @@ class UnionNode final : public IQueryTreeNode
         return children[queries_child_index];
     }
 
+    /// Returns true if union node is resolved, false otherwise
+    bool isResolved() const;
+
     /// Compute union node projection columns
     NamesAndTypes computeProjectionColumns() const;
 
