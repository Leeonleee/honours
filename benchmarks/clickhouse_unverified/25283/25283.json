{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25283,
  "instance_id": "ClickHouse__ClickHouse-25283",
  "issue_numbers": [
    "10142",
    "20549"
  ],
  "base_commit": "1c1d141a2a4ecf99ef2125648b0c107e638630b4",
  "patch": "diff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex ec3447ffb816..8b930a73dfb3 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -153,21 +153,6 @@ struct NumIfImpl<Decimal<A>, Decimal<B>, Decimal<R>>\n     }\n };\n \n-template <typename A, typename B>\n-struct NumIfImpl<A, B, NumberTraits::Error>\n-{\n-private:\n-    [[noreturn]] static void throwError()\n-    {\n-        throw Exception(\"Incompatible types of arguments corresponding to two conditional branches\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-    }\n-public:\n-    template <typename... Args> static ColumnPtr vectorVector(Args &&...) { throwError(); }\n-    template <typename... Args> static ColumnPtr vectorConstant(Args &&...) { throwError(); }\n-    template <typename... Args> static ColumnPtr constantVector(Args &&...) { throwError(); }\n-    template <typename... Args> static ColumnPtr constantConstant(Args &&...) { throwError(); }\n-};\n-\n \n class FunctionIf : public FunctionIfBase\n {\n@@ -193,52 +178,66 @@ class FunctionIf : public FunctionIfBase\n \n     template <typename T0, typename T1, typename ColVecT0, typename ColVecT1>\n     ColumnPtr executeRightType(\n-            const ColumnUInt8 * cond_col,\n-            const ColumnsWithTypeAndName & arguments,\n-            const ColVecT0 * col_left) const\n+        [[maybe_unused]] const ColumnUInt8 * cond_col,\n+        [[maybe_unused]] const ColumnsWithTypeAndName & arguments,\n+        [[maybe_unused]] const ColVecT0 * col_left) const\n     {\n         using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n \n-        const IColumn * col_right_untyped = arguments[2].column.get();\n-        UInt32 scale = decimalScale<T0, T1>(arguments);\n-\n-        if (const auto * col_right_vec = checkAndGetColumn<ColVecT1>(col_right_untyped))\n+        if constexpr (std::is_same_v<ResultType, NumberTraits::Error>)\n         {\n-            return NumIfImpl<T0, T1, ResultType>::vectorVector(\n-                cond_col->getData(), col_left->getData(), col_right_vec->getData(), scale);\n+            return nullptr;\n         }\n-        else if (const auto * col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_untyped))\n+        else\n         {\n-            return NumIfImpl<T0, T1, ResultType>::vectorConstant(\n-                cond_col->getData(), col_left->getData(), col_right_const->template getValue<T1>(), scale);\n-        }\n+            const IColumn * col_right_untyped = arguments[2].column.get();\n+            UInt32 scale = decimalScale<T0, T1>(arguments);\n \n-        return nullptr;\n+            if (const auto * col_right_vec = checkAndGetColumn<ColVecT1>(col_right_untyped))\n+            {\n+                return NumIfImpl<T0, T1, ResultType>::vectorVector(\n+                    cond_col->getData(), col_left->getData(), col_right_vec->getData(), scale);\n+            }\n+            else if (const auto * col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_untyped))\n+            {\n+                return NumIfImpl<T0, T1, ResultType>::vectorConstant(\n+                    cond_col->getData(), col_left->getData(), col_right_const->template getValue<T1>(), scale);\n+            }\n+\n+            return nullptr;\n+        }\n     }\n \n     template <typename T0, typename T1, typename ColVecT0, typename ColVecT1>\n     ColumnPtr executeConstRightType(\n-            const ColumnUInt8 * cond_col,\n-            const ColumnsWithTypeAndName & arguments,\n-            const ColumnConst * col_left) const\n+        [[maybe_unused]] const ColumnUInt8 * cond_col,\n+        [[maybe_unused]] const ColumnsWithTypeAndName & arguments,\n+        [[maybe_unused]] const ColumnConst * col_left) const\n     {\n         using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n \n-        const IColumn * col_right_untyped = arguments[2].column.get();\n-        UInt32 scale = decimalScale<T0, T1>(arguments);\n-\n-        if (const auto * col_right_vec = checkAndGetColumn<ColVecT1>(col_right_untyped))\n+        if constexpr (std::is_same_v<ResultType, NumberTraits::Error>)\n         {\n-            return NumIfImpl<T0, T1, ResultType>::constantVector(\n-                cond_col->getData(), col_left->template getValue<T0>(), col_right_vec->getData(), scale);\n+            return nullptr;\n         }\n-        else if (const auto * col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_untyped))\n+        else\n         {\n-            return NumIfImpl<T0, T1, ResultType>::constantConstant(\n-                cond_col->getData(), col_left->template getValue<T0>(), col_right_const->template getValue<T1>(), scale);\n-        }\n+            const IColumn * col_right_untyped = arguments[2].column.get();\n+            UInt32 scale = decimalScale<T0, T1>(arguments);\n \n-        return nullptr;\n+            if (const auto * col_right_vec = checkAndGetColumn<ColVecT1>(col_right_untyped))\n+            {\n+                return NumIfImpl<T0, T1, ResultType>::constantVector(\n+                    cond_col->getData(), col_left->template getValue<T0>(), col_right_vec->getData(), scale);\n+            }\n+            else if (const auto * col_right_const = checkAndGetColumnConst<ColVecT1>(col_right_untyped))\n+            {\n+                return NumIfImpl<T0, T1, ResultType>::constantConstant(\n+                    cond_col->getData(), col_left->template getValue<T0>(), col_right_const->template getValue<T1>(), scale);\n+            }\n+\n+            return nullptr;\n+        }\n     }\n \n     template <typename T0, typename T1, typename ColVecT0, typename ColVecT1>\n@@ -249,12 +248,14 @@ class FunctionIf : public FunctionIfBase\n         [[maybe_unused]] const ColumnArray * col_left_array,\n         [[maybe_unused]] size_t input_rows_count) const\n     {\n-        if constexpr (std::is_same_v<NumberTraits::Error, typename NumberTraits::ResultOfIf<T0, T1>::Type>)\n+        using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n+\n+        if constexpr (std::is_same_v<ResultType, NumberTraits::Error>)\n+        {\n             return nullptr;\n+        }\n         else\n         {\n-            using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n-\n             const IColumn * col_right_untyped = arguments[2].column.get();\n \n             if (const auto * col_right_array = checkAndGetColumn<ColumnArray>(col_right_untyped))\n@@ -291,9 +292,9 @@ class FunctionIf : public FunctionIfBase\n \n                 return res;\n             }\n-        }\n \n-        return nullptr;\n+            return nullptr;\n+        }\n     }\n \n     template <typename T0, typename T1, typename ColVecT0, typename ColVecT1>\n@@ -304,12 +305,14 @@ class FunctionIf : public FunctionIfBase\n         [[maybe_unused]] const ColumnConst * col_left_const_array,\n         [[maybe_unused]] size_t input_rows_count) const\n     {\n-        if constexpr (std::is_same_v<NumberTraits::Error, typename NumberTraits::ResultOfIf<T0, T1>::Type>)\n+        using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n+\n+        if constexpr (std::is_same_v<ResultType, NumberTraits::Error>)\n+        {\n             return nullptr;\n+        }\n         else\n         {\n-            using ResultType = typename NumberTraits::ResultOfIf<T0, T1>::Type;\n-\n             const IColumn * col_right_untyped = arguments[2].column.get();\n \n             if (const auto * col_right_array = checkAndGetColumn<ColumnArray>(col_right_untyped))\n@@ -347,37 +350,34 @@ class FunctionIf : public FunctionIfBase\n \n                 return res;\n             }\n-        }\n \n-        return nullptr;\n+            return nullptr;\n+        }\n     }\n \n     template <typename T0, typename T1>\n-    ColumnPtr executeTyped(const ColumnUInt8 * cond_col, const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n+    ColumnPtr executeTyped(\n+        const ColumnUInt8 * cond_col, const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n     {\n         using ColVecT0 = std::conditional_t<IsDecimalNumber<T0>, ColumnDecimal<T0>, ColumnVector<T0>>;\n         using ColVecT1 = std::conditional_t<IsDecimalNumber<T1>, ColumnDecimal<T1>, ColumnVector<T1>>;\n \n         const IColumn * col_left_untyped = arguments[1].column.get();\n \n-        bool left_ok = false;\n         ColumnPtr right_column = nullptr;\n \n         if (const auto * col_left = checkAndGetColumn<ColVecT0>(col_left_untyped))\n         {\n-            left_ok = true;\n             right_column = executeRightType<T0, T1, ColVecT0, ColVecT1>(cond_col, arguments, col_left);\n         }\n         else if (const auto * col_const_left = checkAndGetColumnConst<ColVecT0>(col_left_untyped))\n         {\n-            left_ok = true;\n             right_column = executeConstRightType<T0, T1, ColVecT0, ColVecT1>(cond_col, arguments, col_const_left);\n         }\n         else if (const auto * col_arr_left = checkAndGetColumn<ColumnArray>(col_left_untyped))\n         {\n             if (auto col_arr_left_elems = checkAndGetColumn<ColVecT0>(&col_arr_left->getData()))\n             {\n-                left_ok = true;\n                 right_column = executeRightTypeArray<T0, T1, ColVecT0, ColVecT1>(\n                     cond_col, arguments, result_type, col_arr_left, input_rows_count);\n             }\n@@ -386,20 +386,11 @@ class FunctionIf : public FunctionIfBase\n         {\n             if (checkColumn<ColVecT0>(&assert_cast<const ColumnArray &>(col_const_arr_left->getDataColumn()).getData()))\n             {\n-                left_ok = true;\n                 right_column = executeConstRightTypeArray<T0, T1, ColVecT0, ColVecT1>(\n                     cond_col, arguments, result_type, col_const_arr_left, input_rows_count);\n             }\n         }\n \n-        if (!left_ok)\n-            return nullptr;\n-\n-        const ColumnWithTypeAndName & right_column_typed = arguments[2];\n-        if (!right_column)\n-            throw Exception(\"Illegal column \" + right_column_typed.column->getName() + \" of third argument of function \" + getName(),\n-                ErrorCodes::ILLEGAL_COLUMN);\n-\n         return right_column;\n     }\n \n@@ -643,7 +634,8 @@ class FunctionIf : public FunctionIfBase\n         return result_column;\n     }\n \n-    ColumnPtr executeForConstAndNullableCondition(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const\n+    ColumnPtr executeForConstAndNullableCondition(\n+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const\n     {\n         const ColumnWithTypeAndName & arg_cond = arguments[0];\n         bool cond_is_null = arg_cond.column->onlyNull();\n@@ -973,7 +965,8 @@ class FunctionIf : public FunctionIfBase\n             using T0 = typename Types::LeftType;\n             using T1 = typename Types::RightType;\n \n-            return (res = executeTyped<T0, T1>(cond_col, arguments, result_type, input_rows_count)) != nullptr;\n+            res = executeTyped<T0, T1>(cond_col, arguments, result_type, input_rows_count);\n+            return res != nullptr;\n         };\n \n         TypeIndex left_id = arg_then.type->getTypeId();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00735_conditional.reference b/tests/queries/0_stateless/00735_long_conditional.reference\nsimilarity index 83%\nrename from tests/queries/0_stateless/00735_conditional.reference\nrename to tests/queries/0_stateless/00735_long_conditional.reference\nindex 6bee974769db..6308a48218b1 100644\n--- a/tests/queries/0_stateless/00735_conditional.reference\n+++ b/tests/queries/0_stateless/00735_long_conditional.reference\n@@ -105,6 +105,9 @@ column vs value\n 0\t1\t1\tInt8\tUInt32\tInt64\n 0\t1\t1\tInt8\tFloat32\tFloat32\n 0\t1\t1\tInt8\tFloat64\tFloat64\n+0\t1\t1\tInt8\tDecimal(9, 0)\tDecimal(9, 0)\n+0\t1\t1\tInt8\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tInt8\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tInt16\tInt8\tInt16\n 0\t1\t1\tInt16\tInt16\tInt16\n 0\t1\t1\tInt16\tInt32\tInt32\n@@ -114,6 +117,9 @@ column vs value\n 0\t1\t1\tInt16\tUInt32\tInt64\n 0\t1\t1\tInt16\tFloat32\tFloat32\n 0\t1\t1\tInt16\tFloat64\tFloat64\n+0\t1\t1\tInt16\tDecimal(9, 0)\tDecimal(9, 0)\n+0\t1\t1\tInt16\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tInt16\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tInt32\tInt8\tInt32\n 0\t1\t1\tInt32\tInt16\tInt32\n 0\t1\t1\tInt32\tInt32\tInt32\n@@ -123,6 +129,9 @@ column vs value\n 0\t1\t1\tInt32\tUInt32\tInt64\n 0\t1\t1\tInt32\tFloat32\tFloat64\n 0\t1\t1\tInt32\tFloat64\tFloat64\n+0\t1\t1\tInt32\tDecimal(9, 0)\tDecimal(9, 0)\n+0\t1\t1\tInt32\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tInt32\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tInt64\tInt8\tInt64\n 0\t1\t1\tInt64\tInt16\tInt64\n 0\t1\t1\tInt64\tInt32\tInt64\n@@ -130,6 +139,9 @@ column vs value\n 0\t1\t1\tInt64\tUInt8\tInt64\n 0\t1\t1\tInt64\tUInt16\tInt64\n 0\t1\t1\tInt64\tUInt32\tInt64\n+0\t1\t1\tInt64\tDecimal(9, 0)\tDecimal(18, 0)\n+0\t1\t1\tInt64\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tInt64\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tUInt8\tInt8\tInt16\n 0\t1\t1\tUInt8\tInt16\tInt16\n 0\t1\t1\tUInt8\tInt32\tInt32\n@@ -140,6 +152,9 @@ column vs value\n 0\t1\t1\tUInt8\tUInt64\tUInt64\n 0\t1\t1\tUInt8\tFloat32\tFloat32\n 0\t1\t1\tUInt8\tFloat64\tFloat64\n+0\t1\t1\tUInt8\tDecimal(9, 0)\tDecimal(9, 0)\n+0\t1\t1\tUInt8\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tUInt8\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tUInt16\tInt8\tInt32\n 0\t1\t1\tUInt16\tInt16\tInt32\n 0\t1\t1\tUInt16\tInt32\tInt32\n@@ -150,6 +165,9 @@ column vs value\n 0\t1\t1\tUInt16\tUInt64\tUInt64\n 0\t1\t1\tUInt16\tFloat32\tFloat32\n 0\t1\t1\tUInt16\tFloat64\tFloat64\n+0\t1\t1\tUInt16\tDecimal(9, 0)\tDecimal(9, 0)\n+0\t1\t1\tUInt16\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tUInt16\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tUInt32\tInt8\tInt64\n 0\t1\t1\tUInt32\tInt16\tInt64\n 0\t1\t1\tUInt32\tInt32\tInt64\n@@ -160,10 +178,16 @@ column vs value\n 0\t1\t1\tUInt32\tUInt64\tUInt64\n 0\t1\t1\tUInt32\tFloat32\tFloat64\n 0\t1\t1\tUInt32\tFloat64\tFloat64\n+0\t1\t1\tUInt32\tDecimal(9, 0)\tDecimal(18, 0)\n+0\t1\t1\tUInt32\tDecimal(18, 0)\tDecimal(18, 0)\n+0\t1\t1\tUInt32\tDecimal(38, 0)\tDecimal(38, 0)\n 0\t1\t1\tUInt64\tUInt8\tUInt64\n 0\t1\t1\tUInt64\tUInt16\tUInt64\n 0\t1\t1\tUInt64\tUInt32\tUInt64\n 0\t1\t1\tUInt64\tUInt64\tUInt64\n+0\t1\t1\tUInt64\tDecimal(9, 0)\tDecimal(38, 0)\n+0\t1\t1\tUInt64\tDecimal(18, 0)\tDecimal(38, 0)\n+0\t1\t1\tUInt64\tDecimal(38, 0)\tDecimal(38, 0)\n 1970-01-01\t1970-01-02\t1970-01-02\tDate\tDate\tDate\n 2000-01-01\t2000-01-01 00:00:01\t2000-01-01 00:00:01\tDate\tDateTime(\\'Europe/Moscow\\')\tDateTime\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\tDateTime(\\'Europe/Moscow\\')\tDate\tDateTime\ndiff --git a/tests/queries/0_stateless/00735_conditional.sql b/tests/queries/0_stateless/00735_long_conditional.sql\nsimilarity index 98%\nrename from tests/queries/0_stateless/00735_conditional.sql\nrename to tests/queries/0_stateless/00735_long_conditional.sql\nindex 04439f4062e4..a247ce003b3c 100644\n--- a/tests/queries/0_stateless/00735_conditional.sql\n+++ b/tests/queries/0_stateless/00735_long_conditional.sql\n@@ -176,9 +176,9 @@ SELECT materialize(toInt8(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z, t\n SELECT materialize(toInt8(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt8(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toInt8(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toInt8(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt8(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt8(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toInt8(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt8(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt8(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toInt16(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt16(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -192,9 +192,9 @@ SELECT materialize(toInt16(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toInt16(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt16(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toInt16(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toInt16(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt16(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt16(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toInt16(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt16(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt16(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toInt32(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt32(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -208,9 +208,9 @@ SELECT materialize(toInt32(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toInt32(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt32(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toInt32(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toInt32(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt32(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt32(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toInt32(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt32(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt32(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toInt64(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toInt64(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -224,9 +224,9 @@ SELECT materialize(toInt64(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toInt64(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n SELECT materialize(toInt64(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toInt64(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toInt64(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt64(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toInt64(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toInt64(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt64(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toInt64(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toUInt8(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt8(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -240,9 +240,9 @@ SELECT materialize(toUInt8(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toUInt8(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt8(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toUInt8(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toUInt8(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt8(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt8(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toUInt8(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt8(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt8(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toUInt16(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt16(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -256,9 +256,9 @@ SELECT materialize(toUInt16(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toUInt16(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt16(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toUInt16(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toUInt16(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt16(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt16(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toUInt16(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt16(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt16(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toUInt32(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt32(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n@@ -272,9 +272,9 @@ SELECT materialize(toUInt32(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toUInt32(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n SELECT materialize(toUInt32(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toUInt32(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toUInt32(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt32(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt32(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toUInt32(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt32(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt32(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toUInt64(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n SELECT materialize(toUInt64(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n@@ -288,9 +288,9 @@ SELECT materialize(toUInt64(0)) AS x, toFloat32(1) AS y, ((x > y) ? x : y) AS z,\n SELECT materialize(toUInt64(0)) AS x, toFloat64(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n SELECT materialize(toUInt64(0)) AS x, toDate(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toUInt64(0)) AS x, toDateTime(1, 'Europe/Moscow') AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 386 }\n-SELECT materialize(toUInt64(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt64(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n-SELECT materialize(toUInt64(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n+SELECT materialize(toUInt64(0)) AS x, toDecimal32(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt64(0)) AS x, toDecimal64(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n+SELECT materialize(toUInt64(0)) AS x, toDecimal128(1, 0) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z);\n \n SELECT materialize(toDate(0)) AS x, toInt8(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\n SELECT materialize(toDate(0)) AS x, toInt16(1) AS y, ((x > y) ? x : y) AS z, toTypeName(x), toTypeName(y), toTypeName(z); -- { serverError 43 }\ndiff --git a/tests/queries/0_stateless/01913_if_int_decimal.reference b/tests/queries/0_stateless/01913_if_int_decimal.reference\nnew file mode 100644\nindex 000000000000..c54e91df3e46\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_if_int_decimal.reference\n@@ -0,0 +1,3 @@\n+2.0000000000\n+1.0000000000\n+2.0000000000\ndiff --git a/tests/queries/0_stateless/01913_if_int_decimal.sql b/tests/queries/0_stateless/01913_if_int_decimal.sql\nnew file mode 100644\nindex 000000000000..83fb4c352c11\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_if_int_decimal.sql\n@@ -0,0 +1,1 @@\n+select number % 2 ? materialize(1)::Decimal(18, 10) : 2 FROM numbers(3);\n",
  "problem_statement": "Conditional function with Decimal and non Decimal.\n```\r\nSELECT ifNull(CAST(null as Nullable(Decimal(38,10))), 0) ;\r\n\r\nDB::Exception: Conditional function with Decimal and non Decimal.\r\n```\r\n\r\nThe intention is quite clear - not to take the responsibility of potentially inaccurate casting from floats to decimals.\r\n\r\nBut casts from int to decimal are safe, and it's not good to force users to use explicit casts everywhere.\nFull join, subqueries and decimal: Incompatible types of arguments corresponding to two conditional branches\nReproduction steps:\r\n```\r\nCREATE TABLE table_left                                                                                                                                                                                              \r\n(                                                                                                                                                                                                                    \r\n    `date` Date,                                                                                                                                                                                                     \r\n    `uid` String                                                                                                                                                                                                     \r\n)                                                                                                                                                                                                                    \r\nENGINE = MergeTree()                                                                                                                                                                                                 \r\nORDER BY (date, uid)          \r\n                                                                                                                                                                                       \r\nCREATE TABLE table_right                                                                                                                                                                                             \r\n(                                                                                                                                                                                                                    \r\n    `date` Date,                                                                                                                                                                                                     \r\n    `value` Decimal(18, 10)                                                                                                                                                                                          \r\n)                                                                                                                                                                                                                    \r\nENGINE = MergeTree()                                                                                                                                                                                                 \r\nORDER BY date\r\n\r\nINSERT INTO table_left values(toDate('2019-10-01'), 'hello');\r\nINSERT INTO table_right values (toDate('2019-10-01'), 1), (toDate('2029-10-01'), 2);\r\n\r\nSET join_use_nulls = 1;\r\n\r\nSELECT ifNull(subquery_right.alias_value, 0)\r\nFROM table_left\r\nFULL OUTER JOIN \r\n(\r\n    SELECT\r\n        date,\r\n        value AS alias_value\r\n    FROM table_right\r\n) AS subquery_right\r\nON table_left.date = subquery_right.date\r\n\r\nReceived exception from server (version 21.3.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Incompatible types of arguments corresponding to two conditional branches: while executing 'FUNCTION ifNull(alias_value :: 0, 0 :: 1) -> ifNull(alias_value, 0) Decimal(18, 10) : 2'. \r\n```\n",
  "hints_text": "Same issue, but it works before last version\n> Same issue, but it works before last version\r\n\r\nWhich version worked? \nHi, maybe this is different problems. In my case query \r\n`SELECT campaign_id,stream_id,sub_stream_id\r\nFROM `hits`\r\nGROUP BY campaign_id, stream_id, sub_stream_id\r\nHAVING SUM(event_date >= toDate('2020-05-05') ? toFloat32(debit) : 0) > 0`\r\nWork in version 19.17.5 but didn't work in last one. Here debit is decimal. With toFloat in last version i have zero here  `SUM(event_date >= toDate('2020-05-05') ? toFloat32(debit) : 0) > 0`, instead of correct value.  And of course if i remove toFloat will be DB::Exception: Conditional function with Decimal and non Decimal.\nIn newer versions the exception message get is worse:\r\n```\r\nSELECT ifNull(CAST(NULL, 'Nullable(Decimal(38, 10))'), 0)\r\n\r\n\r\nReceived exception from server (version 20.4.6):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Invalid types of arguments 2 and 3 of if. \r\n\r\n0 rows in set. Elapsed: 0.004 sec. \r\n\r\n```\nReproduced with\r\n```\r\ncreate table t1 (a Nullable(Decimal(18, 10))) engine = TinyLog;\r\nselect ifNull(a, 0) from t1;\r\n```\nif you use ifNull(a,b),a and b shoule be the same type variable.\r\neg: if a`s type is decimal(18,3) and the b should be toDecimal32(0,3) --> ifnull(a,toDecimal32(0,3))\n```\r\nselect rand() % 2 ? materialize(1)::Decimal(18, 10) : 1\r\n```",
  "created_at": "2021-06-15T03:55:16Z",
  "modified_files": [
    "src/Functions/if.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00735_conditional.reference",
    "tests/queries/0_stateless/00735_conditional.sql",
    "b/tests/queries/0_stateless/01913_if_int_decimal.reference",
    "b/tests/queries/0_stateless/01913_if_int_decimal.sql"
  ]
}