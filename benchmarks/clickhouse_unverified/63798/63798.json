{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63798,
  "instance_id": "ClickHouse__ClickHouse-63798",
  "issue_numbers": [
    "62814"
  ],
  "base_commit": "b9e8b15e46a8c73ead087456de2af6caca21a53a",
  "patch": "diff --git a/docs/en/operations/settings/settings-formats.md b/docs/en/operations/settings/settings-formats.md\nindex f8b40cd81ac1..fcec0afb8d21 100644\n--- a/docs/en/operations/settings/settings-formats.md\n+++ b/docs/en/operations/settings/settings-formats.md\n@@ -194,6 +194,17 @@ If enabled, ClickHouse will try to infer type `DateTime64` from string fields in\n \n Enabled by default.\n \n+## input_format_try_infer_variants {#input_format_try_infer_variants}\n+\n+If enabled, ClickHouse will try to infer type [`Variant`](../../sql-reference/data-types/variant.md) in schema inference for text formats when there is more than one possible type for column/array elements.\n+\n+Possible values:\n+\n+- 0 \u2014 Disabled.\n+- 1 \u2014 Enabled.\n+\n+Default value: `0`.\n+\n ## date_time_input_format {#date_time_input_format}\n \n Allows choosing a parser of the text representation of date and time.\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 0d84ad9022aa..187eda37f278 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -1136,6 +1136,7 @@ class IColumn;\n     M(Bool, input_format_json_defaults_for_missing_elements_in_named_tuple, true, \"Insert default value in named tuple element if it's missing in json object\", 0) \\\n     M(Bool, input_format_json_throw_on_bad_escape_sequence, true, \"Throw an exception if JSON string contains bad escape sequence in JSON input formats. If disabled, bad escape sequences will remain as is in the data\", 0) \\\n     M(Bool, input_format_json_ignore_unnecessary_fields, true, \"Ignore unnecessary fields and not parse them. Enabling this may not throw exceptions on json strings of invalid format or with duplicated fields\", 0) \\\n+    M(Bool, input_format_try_infer_variants, false, \"Try to infer the Variant type in text formats when there is more than one possible type for column/array elements\", 0) \\\n     M(Bool, type_json_skip_duplicated_paths, false, \"When enabled, during parsing JSON object into JSON type duplicated paths will be ignored and only the first one will be inserted instead of an exception\", 0) \\\n     M(UInt64, input_format_json_max_depth, 1000, \"Maximum depth of a field in JSON. This is not a strict limit, it does not have to be applied precisely.\", 0) \\\n     M(Bool, input_format_try_infer_integers, true, \"Try to infer integers instead of floats while schema inference in text formats\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 2415323b4a03..fb59577b0f0a 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -71,6 +71,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n     },\n     {\"24.9\",\n         {\n+            {\"input_format_try_infer_variants\", false, false, \"Try to infer Variant type in text formats when there is more than one possible type for column/array elements\"},\n         }\n     },\n     {\"24.8\",\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 865b6e6f3f17..f1214aac7dc6 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -283,6 +283,7 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se\n     format_settings.max_parser_depth = context->getSettingsRef().max_parser_depth;\n     format_settings.client_protocol_version = context->getClientProtocolVersion();\n     format_settings.date_time_overflow_behavior = settings.date_time_overflow_behavior;\n+    format_settings.try_infer_variant = settings.input_format_try_infer_variants;\n \n     /// Validate avro_schema_registry_url with RemoteHostFilter when non-empty and in Server context\n     if (format_settings.schema.is_server)\ndiff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h\nindex da25da741342..ed178a68b9d1 100644\n--- a/src/Formats/FormatSettings.h\n+++ b/src/Formats/FormatSettings.h\n@@ -35,6 +35,7 @@ struct FormatSettings\n     bool decimal_trailing_zeros = false;\n     bool defaults_for_omitted_fields = true;\n     bool is_writing_to_terminal = false;\n+    bool try_infer_variant = false;\n \n     bool seekable_read = true;\n     UInt64 max_rows_to_read_for_schema_inference = 25000;\ndiff --git a/src/Formats/SchemaInferenceUtils.cpp b/src/Formats/SchemaInferenceUtils.cpp\nindex ed251fa5d554..e8eab3b44535 100644\n--- a/src/Formats/SchemaInferenceUtils.cpp\n+++ b/src/Formats/SchemaInferenceUtils.cpp\n@@ -7,6 +7,7 @@\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypeVariant.h>\n #include <DataTypes/DataTypeMap.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypeNothing.h>\n@@ -306,6 +307,33 @@ namespace\n         type_indexes.erase(TypeIndex::UInt64);\n     }\n \n+    /// if setting 'try_infer_variant' is true then we convert to type variant.\n+    void transformVariant(DataTypes & data_types, TypeIndexesSet & type_indexes)\n+    {\n+        if (checkIfTypesAreEqual(data_types))\n+            return;\n+\n+        DataTypes variant_types;\n+        for (const auto & type : data_types)\n+        {\n+            if (const auto * variant_type = typeid_cast<const DataTypeVariant *>(type.get()))\n+            {\n+                const auto & current_variants = variant_type->getVariants();\n+                variant_types.insert(variant_types.end(), current_variants.begin(), current_variants.end());\n+            }\n+            else\n+            {\n+                variant_types.push_back(type);\n+            }\n+        }\n+\n+        auto variant_type = std::make_shared<DataTypeVariant>(variant_types);\n+\n+        for (auto & type : data_types)\n+            type = variant_type;\n+        type_indexes = {TypeIndex::Variant};\n+    }\n+\n     /// If we have only date/datetimes types (Date/DateTime/DateTime64), convert all of them to the common type,\n     /// otherwise, convert all Date, DateTime and DateTime64 to String.\n     void transformDatesAndDateTimes(DataTypes & data_types, TypeIndexesSet & type_indexes)\n@@ -652,7 +680,11 @@ namespace\n                 transformDatesAndDateTimes(data_types, type_indexes);\n \n             if constexpr (!is_json)\n+            {\n+                if (settings.try_infer_variant)\n+                    transformVariant(data_types, type_indexes);\n                 return;\n+            }\n \n             /// Check settings specific for JSON formats.\n \n@@ -670,6 +702,10 @@ namespace\n \n             if (settings.json.try_infer_objects_as_tuples)\n                 mergeJSONPaths(data_types, type_indexes, settings, json_info);\n+\n+            if (settings.try_infer_variant)\n+                transformVariant(data_types, type_indexes);\n+\n         };\n \n         auto transform_complex_types = [&](DataTypes & data_types, TypeIndexesSet & type_indexes)\n@@ -682,7 +718,11 @@ namespace\n             transformNothingComplexTypes(data_types, type_indexes);\n \n             if constexpr (!is_json)\n+            {\n+                if (settings.try_infer_variant)\n+                    transformVariant(data_types, type_indexes);\n                 return;\n+            }\n \n             /// Convert JSON tuples with same nested types to arrays.\n             transformTuplesWithEqualNestedTypesToArrays(data_types, type_indexes);\n@@ -695,6 +735,9 @@ namespace\n \n             if (json_info && json_info->allow_merging_named_tuples)\n                 mergeNamedTuples(data_types, type_indexes, settings, json_info);\n+\n+            if (settings.try_infer_variant)\n+                transformVariant(data_types, type_indexes);\n         };\n \n         transformTypesRecursively(types, transform_simple_types, transform_complex_types);\n@@ -861,7 +904,6 @@ namespace\n \n             if (checkIfTypesAreEqual(nested_types_copy))\n                 return std::make_shared<DataTypeArray>(nested_types_copy.back());\n-\n             return std::make_shared<DataTypeTuple>(nested_types);\n         }\n         else\n@@ -1456,6 +1498,15 @@ void transformFinalInferredJSONTypeIfNeededImpl(DataTypePtr & data_type, const F\n \n         return;\n     }\n+\n+    if (const auto * variant_type = typeid_cast<const DataTypeVariant *>(data_type.get()))\n+    {\n+        auto nested_types = variant_type->getVariants();\n+        for (auto & nested_type : nested_types)\n+            transformFinalInferredJSONTypeIfNeededImpl(nested_type, settings, json_info, remain_nothing_types);\n+        data_type = std::make_shared<DataTypeVariant>(nested_types);\n+        return;\n+    }\n }\n \n void transformFinalInferredJSONTypeIfNeeded(DataTypePtr & data_type, const FormatSettings & settings, JSONInferenceInfo * json_info)\n@@ -1535,6 +1586,20 @@ DataTypePtr makeNullableRecursively(DataTypePtr type)\n         return nested_type ? std::make_shared<DataTypeArray>(nested_type) : nullptr;\n     }\n \n+    if (which.isVariant())\n+    {\n+        const auto * variant_type = assert_cast<const DataTypeVariant *>(type.get());\n+        DataTypes nested_types;\n+        for (const auto & nested_type: variant_type->getVariants())\n+        {\n+            if (!nested_type->lowCardinality() && nested_type->haveSubtypes())\n+                nested_types.push_back(makeNullableRecursively(nested_type));\n+            else\n+                nested_types.push_back(nested_type);\n+        }\n+        return std::make_shared<DataTypeVariant>(nested_types);\n+    }\n+\n     if (which.isTuple())\n     {\n         const auto * tuple_type = assert_cast<const DataTypeTuple *>(type.get());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03150_infer_type_variant.reference b/tests/queries/0_stateless/03150_infer_type_variant.reference\nnew file mode 100644\nindex 000000000000..a43fa1e1227b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03150_infer_type_variant.reference\n@@ -0,0 +1,31 @@\n+   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   \u2503 arr                \u2503 toTypeName(arr)                                      \u2503\n+   \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n+1. \u2502 ['1','Hello',(32)] \u2502 Array(Variant(String, Tuple(\n+    a Nullable(Int64)))) \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   \u2503 x     \u2503 toTypeName(x)    \u2503\n+   \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n+1. \u2502 42    \u2502 Nullable(String) \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+2. \u2502 Hello \u2502 Nullable(String) \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+   \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   \u2503 x       \u2503 toTypeName(x)                                                 \u2503\n+   \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n+1. \u2502 [1,2,3] \u2502 Variant(Array(Nullable(Int64)), Tuple(\n+    a Nullable(Int64))) \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+2. \u2502 (42)    \u2502 Variant(Array(Nullable(Int64)), Tuple(\n+    a Nullable(Int64))) \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+   \u250f\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   \u2503 c1 \u2503 toTypeName(c1)  \u2503 c2           \u2503 toTypeName(c2)                          \u2503\n+   \u2521\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n+1. \u2502  1 \u2502 Nullable(Int64) \u2502 Hello World! \u2502 Variant(Array(Nullable(Int64)), String) \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+2. \u2502  2 \u2502 Nullable(Int64) \u2502 [1,2,3]      \u2502 Variant(Array(Nullable(Int64)), String) \u2502\n+   \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n+3. \u2502  3 \u2502 Nullable(Int64) \u2502 2020-01-01   \u2502 Variant(Array(Nullable(Int64)), String) \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/03150_infer_type_variant.sql b/tests/queries/0_stateless/03150_infer_type_variant.sql\nnew file mode 100644\nindex 000000000000..45126ccd471a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03150_infer_type_variant.sql\n@@ -0,0 +1,5 @@\n+SET input_format_try_infer_variants=1;\n+SELECT arr, toTypeName(arr) FROM format('JSONEachRow', '{\"arr\" : [1, \"Hello\", {\"a\" : 32}]}') FORMAT Pretty;\n+SELECT x, toTypeName(x) FROM format('JSONEachRow', '{\"x\" : 42}, {\"x\" : \"Hello\"}') FORMAT Pretty;\n+SELECT x, toTypeName(x) FROM format('JSONEachRow', '{\"x\" : [1, 2, 3]}, {\"x\" : {\"a\" : 42}}') FORMAT Pretty;\n+SELECT c1, toTypeName(c1), c2, toTypeName(c2) FROM format('CSV', '1,Hello World!\\n2,\"[1,2,3]\"\\n3,\"2020-01-01\"\\n') FORMAT Pretty;\n\\ No newline at end of file\n",
  "problem_statement": "Add a setting to use Variant data type during schema inference when column/array has values with different types\nExamples:\r\n```\r\n:) select arr, toTypeName(arr) from format('JSONEachRow', '{\"arr\" : [1, \"Hello\", {\"a\" : 32}]}')\r\n   \u250c\u2500arr\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(arr)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n1. \u2502 (1,'Hello',(32)) \u2502 Tuple(Nullable(Int64), Nullable(String), Tuple(a Nullable(Int64))) \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nInstead, it can be `Array(Variant(Int64, String, Tuple(a Nullable(Int64))))`.\r\n\r\n```\r\n:) select x, toTypeName(x) from format('JSONEachRow', '{\"x\" : 42}, {\"x\" : \"Hello\"}')\r\n\r\n   \u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTypeName(x)\u2500\u2500\u2500\u2500\u2510\r\n1. \u2502 42    \u2502 Nullable(String) \u2502\r\n2. \u2502 Hello \u2502 Nullable(String) \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt can be `Variant(Int64, String)`.\r\n\r\n```\r\n:) select x, toTypeName(x) from format('JSONEachRow', '{\"x\" : [1, 2, 3]}, {\"x\" : {\"a\" : 42}}')\r\n\r\nReceived exception:\r\nCode: 636. DB::Exception: The table structure cannot be extracted from a JSONEachRow format file. Error:\r\nCode: 53. DB::Exception: Automatically defined type Tuple(a Int64) for column 'x' in row 1 differs from type defined by previous rows: Array(Int64). You can specify the type for this column using setting schema_inference_hints. (TYPE_MISMATCH) (version 24.4.1.1).\r\nYou can specify the structure manually. (CANNOT_EXTRACT_TABLE_STRUCTURE)\r\n\r\n```\r\n\r\nIt can be `Variant(Array(Int64), Tuple(a Int64))`\r\n\r\n\n",
  "hints_text": "@Avogar I can pick this one up\n@Blargian it will be amazing!\r\nYou can look at files `SchemaInferenceUtils.h/cpp` and especially at functions `transformInferredTypesIfNeeded/transformInferredJSONTypesIfNeeded/...`, they are used to determine the result type for the column from several rows during schema inference. We can add a setting similar to settings `input_format_try_infer_dates/input_format_try_infer_datetimes` (you can also check how they are processed)",
  "created_at": "2024-05-14T19:58:56Z",
  "modified_files": [
    "docs/en/operations/settings/settings-formats.md",
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Formats/FormatFactory.cpp",
    "src/Formats/FormatSettings.h",
    "src/Formats/SchemaInferenceUtils.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03150_infer_type_variant.reference",
    "b/tests/queries/0_stateless/03150_infer_type_variant.sql"
  ]
}