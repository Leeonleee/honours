{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12443,
  "instance_id": "ClickHouse__ClickHouse-12443",
  "issue_numbers": [
    "4172",
    "3470"
  ],
  "base_commit": "9c80f472a2cbfd7ce478075fad8b08463fe097fe",
  "patch": "diff --git a/base/common/DateLUTImpl.h b/base/common/DateLUTImpl.h\nindex 18078299cd99..bc81f81c8ba3 100644\n--- a/base/common/DateLUTImpl.h\n+++ b/base/common/DateLUTImpl.h\n@@ -686,12 +686,17 @@ class DateLUTImpl\n     inline time_t makeDateTime(UInt16 year, UInt8 month, UInt8 day_of_month, UInt8 hour, UInt8 minute, UInt8 second) const\n     {\n         size_t index = makeDayNum(year, month, day_of_month);\n-        time_t time_offset = hour * 3600 + minute * 60 + second;\n+        UInt32 time_offset = hour * 3600 + minute * 60 + second;\n \n         if (time_offset >= lut[index].time_at_offset_change)\n             time_offset -= lut[index].amount_of_offset_change;\n \n-        return lut[index].date + time_offset;\n+        UInt32 res = lut[index].date + time_offset;\n+\n+        if (unlikely(res > DATE_LUT_MAX))\n+            return 0;\n+\n+        return res;\n     }\n \n     inline const Values & getValues(DayNum d) const { return lut[d]; }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.reference b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.sql b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.sql\nnew file mode 100644\nindex 000000000000..2711ab3cceb0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.sql\n@@ -0,0 +1,1 @@\n+SELECT toTimeZone(now(), 'Europe/Moscow') > '1970-01-01 00:00:00';\n",
  "problem_statement": "Datetime condition returns inconsistent result\n```\r\nselect * from reporting_events where device_id = 2 and ts >= '1970-01-01 00:00:00';\r\n\r\nSELECT *\r\nFROM reporting_events \r\nWHERE (device_id = 2) AND (ts >= '1970-01-01 00:00:00')\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n```\r\n\r\nNow, adding 1 day to the string `1970-01-01 00:00:00` and make it `1970-01-02 00:00:00`\r\n\r\n```\r\nselect * from reporting_events where device_id = 2 and ts >= '1970-01-02 00:00:00';\r\n\r\nSELECT *\r\nFROM reporting_events \r\nWHERE (device_id = 2) AND (ts >= '1970-01-02 00:00:00')\r\n\r\n\u250c\u2500id\u2500\u252c\u2500device_id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500event_hashcode\u2500\u252c\u2500type\u2500\u252c\u2500description\u2500\u252c\u2500is_resolved\u2500\u252c\u2500resolved_by\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500resolved_at\u2500\u252c\u2500resolved_comment\u2500\u2510\r\n\u2502 40 \u2502         2 \u2502 2019-01-28 18:17:08 \u2502      613812780 \u2502    4 \u2502             \u2502           0 \u2502             \u2502 0000-00-00 00:00:00 \u2502                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500id\u2500\u252c\u2500device_id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500event_hashcode\u2500\u252c\u2500type\u2500\u252c\u2500description\u2500\u252c\u2500is_resolved\u2500\u252c\u2500resolved_by\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500resolved_at\u2500\u252c\u2500resolved_comment\u2500\u2510\r\n\u2502 39 \u2502         2 \u2502 2019-01-28 18:17:08 \u2502    -1958892973 \u2502    0 \u2502             \u2502           0 \u2502             \u2502 0000-00-00 00:00:00 \u2502                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.005 sec. \r\n```\r\n\r\n```\r\nCREATE TABLE reporting_events (\r\n  id UInt64,\r\n  device_id UInt32,\r\n  ts DateTime DEFAULT now(),\r\n  event_hashcode Int32,\r\n  type UInt8,\r\n  description String,\r\n  is_resolved UInt8,\r\n  resolved_by String,\r\n  resolved_at DateTime,\r\n  resolved_comment String\r\n)\r\nENGINE = MergeTree()\r\nPARTITION BY toYYYYMM(ts)\r\nORDER BY (device_id, ts, event_hashcode, type);\r\n```\r\n\r\nI found a similar issue - https://github.com/yandex/ClickHouse/issues/2596. However, comparison result seems wrong to me. How it should be handled if this is expected?\nSELECT toDateTime('1970-01-01 00:00:00') -> 1970-01-01 06:28:16 for time zone other than UTC\nSelecting when time zone is not UTC shows wrong (1970-01-01 06:28:16) datetime.\r\n\r\n`ClickHouse client version 18.14.10.\r\nConnecting to localhost:9000.\r\nConnected to ClickHouse server version 18.14.10 revision 54409.\r\n\r\nblade8.lab.bulb.hr :) SELECT toDateTime('1970-01-01 00:00:00')\r\n\r\nSELECT toDateTime('1970-01-01 00:00:00')\r\n\r\n\u250c\u2500toDateTime('1970-01-01 00:00:00')\u2500\u2510\r\n\u2502               1970-01-01 06:28:16 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.011 sec.`\r\n\r\n\n",
  "hints_text": "`1970-01-01 00:00:00` is before unix epoch in timezones that have positive UTC offset at that point of time. The reason of this behaviour is that it overflows to 2106.\r\n\r\nThis behaviour has to be fixed.\nthe same:\r\n```\r\nselect toDateTime('1969-12-29 00:00:01') ; -- 1970-01-01 06:28:17\r\nselect toDateTime('1008-02-29 00:00:01') ; -- 1970-01-01 06:28:17\r\n```\r\n\r\nGenerally those dates are out of clickhouse supported range, but probably should be printed as '0000-00-00 00:00:00'\nHow come that 1970-01-01 is not supported? It is zero epoch.\nCaused by the fact that when it was 1970-01-01 in UTC in some other timezones  it still was 1969 which can'be properly processed. Accurate processing of that date is possible but AFIAK it was just simpler to assume that epoch starts a little bit later, and no extra costs on processing border effects of first day of epoch. BTW for that reason documentation usually call minimal day as 'some date in past'.\nI understand what you are telling me, but it would be better to return an error, or 0000-00-00 00:00:00 instead of 1970-01-01 06:28:17 for GMT +1 time zone.\r\nAnyway, thank you for clarification.\n> better to return an error, or 0000-00-00 00:00:00 instead of 1970-01-01 06:28:17\r\n\r\nYes, it's a bug.\nNow it returns `2106-02-07 06:28:16`. Even better.\n> Now it returns `2106-02-07 06:28:16`. Even better.\r\n\r\nI think it is not better, because when use in interval it will produce unexpected results.\r\n\r\n`SELECT \r\n    close_time, \r\n    count(*)\r\nFROM mt4_trade \r\nWHERE close_time <= '1970-01-01 00:00:00'\r\nGROUP BY close_time\r\nORDER BY close_time ASC\r\nLIMIT 10\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500close_time\u2500\u252c\u2500count()\u2500\u2510\r\n\u2502 2014-10-02 20:43:47 \u2502       1 \u2502\r\n\u2502 2014-10-02 21:00:52 \u2502       1 \u2502\r\n\u2502 2014-10-03 15:27:46 \u2502       1 \u2502\r\n\u2502 2014-10-03 15:29:45 \u2502       1 \u2502\r\n\u2502 2014-10-03 15:43:07 \u2502       4 \u2502\r\n\u2502 2014-10-03 15:43:54 \u2502       1 \u2502\r\n\u2502 2014-10-03 15:44:20 \u2502       1 \u2502\r\n\u2502 2014-10-03 15:45:09 \u2502       1 \u2502\r\n\u2502 2014-10-03 16:47:02 \u2502       1 \u2502\r\n\u2502 2014-10-03 17:01:43 \u2502       1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n10 rows in set. Elapsed: 0.473 sec. Processed 11.99 million rows, 47.95 MB (25.34 million rows/s., 101.34 MB/s.) \r\n`",
  "created_at": "2020-07-12T22:51:29Z",
  "modified_files": [
    "base/common/DateLUTImpl.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.reference",
    "b/tests/queries/0_stateless/01396_negative_datetime_saturate_to_zero.sql"
  ]
}