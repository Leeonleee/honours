diff --git a/src/Core/FormatFactorySettings.h b/src/Core/FormatFactorySettings.h
index c432f46bb349..8a8e3940999d 100644
--- a/src/Core/FormatFactorySettings.h
+++ b/src/Core/FormatFactorySettings.h
@@ -1119,6 +1119,20 @@ Print a readable number tip on the right side of the table if the block consists
 )", 0) \
     DECLARE(Bool, output_format_pretty_highlight_trailing_spaces, true, R"(
 If enabled and if output is a terminal, highlight trailing spaces with a gray color and underline.
+)", 0) \
+    DECLARE(Bool, output_format_pretty_multiline_fields, true, R"(
+If enabled, Pretty formats will render multi-line fields inside table cell, so the table's outline will be preserved.
+If not, they will be rendered as is, potentially deforming the table (one upside of keeping it off is that copy-pasting multi-line values will be easier).
+)", 0) \
+    DECLARE(Bool, output_format_pretty_fallback_to_vertical, true, R"(
+If enabled, and the table is wide but short, the Pretty format will output it as the Vertical format does.
+See `output_format_pretty_fallback_to_vertical_max_rows_per_chunk` and `output_format_pretty_fallback_to_vertical_min_table_width` for detailed tuning of this behavior.
+)", 0) \
+    DECLARE(UInt64, output_format_pretty_fallback_to_vertical_max_rows_per_chunk, 100, R"(
+The fallback to Vertical format (see `output_format_pretty_fallback_to_vertical`) will be activated only if the number of records in a chunk is not more than the specified value.
+)", 0) \
+    DECLARE(UInt64, output_format_pretty_fallback_to_vertical_min_table_width, 250, R"(
+The fallback to Vertical format (see `output_format_pretty_fallback_to_vertical`) will be activated only if the sum of lengths of columns in a table is at least the specified value, or if at least one value contains a newline character.
 )", 0) \
     DECLARE(Bool, insert_distributed_one_random_shard, false, R"(
 Enables or disables random shard insertion into a [Distributed](../../engines/table-engines/special/distributed.md/#distributed) table when there is no distributed key.
diff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp
index a4d23332ef75..1b7d70b7543c 100644
--- a/src/Core/SettingsChangesHistory.cpp
+++ b/src/Core/SettingsChangesHistory.cpp
@@ -86,6 +86,10 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()
             {"output_format_pretty_squash_max_wait_ms", 0, 1000, "Add new setting"},
             {"output_format_pretty_max_column_name_width_cut_to", 0, 24, "A new setting"},
             {"output_format_pretty_max_column_name_width_min_chars_to_cut", 0, 4, "A new setting"},
+            {"output_format_pretty_multiline_fields", false, true, "A new setting"},
+            {"output_format_pretty_fallback_to_vertical", false, true, "A new setting"},
+            {"output_format_pretty_fallback_to_vertical_max_rows_per_chunk", 0, 100, "A new setting"},
+            {"output_format_pretty_fallback_to_vertical_min_table_width", 0, 1000, "A new setting"},
             {"max_autoincrement_series", 1000, 1000, "A new setting"},
         });
         addSettingsChanges(settings_changes_history, "24.12",
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index b94b4e3db1d7..90836eef88a6 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -225,6 +225,10 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se
     format_settings.pretty.squash_consecutive_ms = settings[Setting::output_format_pretty_squash_consecutive_ms];
     format_settings.pretty.squash_max_wait_ms = settings[Setting::output_format_pretty_squash_max_wait_ms];
     format_settings.pretty.highlight_trailing_spaces = settings[Setting::output_format_pretty_highlight_trailing_spaces];
+    format_settings.pretty.multiline_fields = settings[Setting::output_format_pretty_multiline_fields];
+    format_settings.pretty.fallback_to_vertical = settings[Setting::output_format_pretty_fallback_to_vertical];
+    format_settings.pretty.fallback_to_vertical_max_rows_per_chunk = settings[Setting::output_format_pretty_fallback_to_vertical_max_rows_per_chunk];
+    format_settings.pretty.fallback_to_vertical_min_table_width = settings[Setting::output_format_pretty_fallback_to_vertical_min_table_width];
     format_settings.protobuf.input_flatten_google_wrappers = settings[Setting::input_format_protobuf_flatten_google_wrappers];
     format_settings.protobuf.output_nullables_with_google_wrappers = settings[Setting::output_format_protobuf_nullables_with_google_wrappers];
     format_settings.protobuf.skip_fields_with_unsupported_types_in_schema_inference = settings[Setting::input_format_protobuf_skip_fields_with_unsupported_types_in_schema_inference];
diff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h
index 50d933cd9268..f92b5c2fc52e 100644
--- a/src/Formats/FormatSettings.h
+++ b/src/Formats/FormatSettings.h
@@ -310,6 +310,7 @@ struct FormatSettings
         UInt64 max_value_width_apply_for_single_value = false;
         bool highlight_digit_groups = true;
         bool highlight_trailing_spaces = true;
+        bool multiline_fields = true;
         /// Set to 2 for auto
         UInt64 color = 2;
 
@@ -321,6 +322,10 @@ struct FormatSettings
         UInt64 squash_consecutive_ms = 50;
         UInt64 squash_max_wait_ms = 1000;
 
+        bool fallback_to_vertical = true;
+        UInt64 fallback_to_vertical_max_rows_per_chunk = 100;
+        UInt64 fallback_to_vertical_min_table_width = 250;
+
         enum class Charset : uint8_t
         {
             UTF8,
diff --git a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
index c8633b4610dd..f96cbb8daa84 100644
--- a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
+++ b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
@@ -1,4 +1,5 @@
 #include <Processors/Formats/Impl/PrettyBlockOutputFormat.h>
+#include <Processors/Formats/Impl/VerticalRowOutputFormat.h>
 #include <Formats/FormatFactory.h>
 #include <Formats/PrettyFormatHelpers.h>
 #include <IO/WriteBuffer.h>
@@ -42,7 +43,7 @@ bool PrettyBlockOutputFormat::cutInTheMiddle(size_t row_num, size_t num_rows, si
 /// Evaluate the visible width of the values and column names.
 /// Note that number of code points is just a rough approximation of visible string width.
 void PrettyBlockOutputFormat::calculateWidths(
-    const Block & header, const Chunk & chunk,
+    const Block & header, const Chunk & chunk, bool split_by_lines, bool & out_has_newlines,
     WidthsPerColumn & widths, Widths & max_padded_widths, Widths & name_widths, Strings & names)
 {
     size_t num_rows = chunk.getNumRows();
@@ -61,13 +62,13 @@ void PrettyBlockOutputFormat::calculateWidths(
 
     /// Calculate the widths of all values.
     String serialized_value;
-    size_t prefix = 2; // Tab character adjustment
+    size_t prefix = row_number_width + (style == Style::Space ? 1 : 2); // Tab character adjustment
     for (size_t i = 0; i < num_columns; ++i)
     {
         const auto & elem = header.getByPosition(i);
         const auto & column = columns[i];
 
-        widths[i].resize(num_displayed_rows);
+        widths[i].resize_fill(num_displayed_rows);
 
         size_t displayed_row = 0;
         for (size_t j = 0; j < num_rows; ++j)
@@ -81,7 +82,7 @@ void PrettyBlockOutputFormat::calculateWidths(
                 serialization->serializeText(*column, j, out_serialize, format_settings);
             }
 
-            /// Avoid calculating width of too long strings by limiting the size in bytes.
+            /// Avoid calculating width of too long strings by limiting their size in bytes.
             /// Note that it is just an estimation. 4 is the maximum size of Unicode code point in bytes in UTF-8.
             /// But it's possible that the string is long in bytes but very short in visible size.
             /// (e.g. non-printable characters, diacritics, combining characters)
@@ -92,10 +93,36 @@ void PrettyBlockOutputFormat::calculateWidths(
                     serialized_value.resize(max_byte_size);
             }
 
-            widths[i][displayed_row] = UTF8::computeWidth(reinterpret_cast<const UInt8 *>(serialized_value.data()), serialized_value.size(), prefix);
-            max_padded_widths[i] = std::max<UInt64>(
-                max_padded_widths[i],
-                std::min<UInt64>({format_settings.pretty.max_column_pad_width, format_settings.pretty.max_value_width, widths[i][displayed_row]}));
+            size_t start_from_offset = 0;
+            size_t next_offset = 0;
+            while (start_from_offset < serialized_value.size())
+            {
+                if (split_by_lines)
+                {
+                    const char * end = serialized_value.data() + serialized_value.size();
+                    const char * next_nl = find_first_symbols<'
'>(serialized_value.data() + start_from_offset, end);
+                    if (next_nl < end)
+                        out_has_newlines = true;
+                    size_t fragment_end_offset = next_nl - serialized_value.data();
+                    next_offset = fragment_end_offset;
+                }
+                else
+                {
+                    next_offset = serialized_value.size();
+                }
+
+                widths[i][displayed_row] = std::max(
+                    widths[i][displayed_row],
+                    UTF8::computeWidth(reinterpret_cast<const UInt8 *>(serialized_value.data() + start_from_offset), next_offset - start_from_offset, prefix));
+
+                max_padded_widths[i] = std::max<UInt64>(
+                    max_padded_widths[i],
+                    std::min<UInt64>({format_settings.pretty.max_column_pad_width, format_settings.pretty.max_value_width, widths[i][displayed_row]}));
+
+                start_from_offset = next_offset;
+                if (start_from_offset < serialized_value.size())
+                    ++start_from_offset;
+            }
 
             ++displayed_row;
         }
@@ -189,7 +216,37 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
     Widths max_widths;
     Widths name_widths;
     Strings names;
-    calculateWidths(header, chunk, widths, max_widths, name_widths, names);
+    bool has_newlines = false;
+    calculateWidths(header, chunk, format_settings.pretty.multiline_fields, has_newlines, widths, max_widths, name_widths, names);
+
+    size_t table_width = 0;
+    for (size_t width : max_widths)
+        table_width += width;
+
+    /// Fallback to Vertical format if:
+    /// enabled by the settings, this is the first chunk (or totals/extremes), the number of rows is small enough,
+    /// either the table width is larger than the max_value_width or any of the values contain a newline.
+    if (format_settings.pretty.fallback_to_vertical
+        && (displayed_rows == 0 || port_kind != PortKind::Main)
+        && num_rows <= format_settings.pretty.fallback_to_vertical_max_rows_per_chunk
+        && (table_width >= format_settings.pretty.fallback_to_vertical_min_table_width || has_newlines))
+    {
+        if (!vertical_format_fallback)
+        {
+            vertical_format_fallback = std::make_unique<VerticalRowOutputFormat>(out, header, format_settings);
+            vertical_format_fallback->writePrefixIfNeeded();
+        }
+
+        for (size_t i = 0; i < num_rows && displayed_rows < format_settings.pretty.max_rows; ++i)
+        {
+            if (i != 0)
+                vertical_format_fallback->writeRowBetweenDelimiter();
+            vertical_format_fallback->writeRow(columns, i);
+            ++displayed_rows;
+        }
+
+        return;
+    }
 
     /// Create separators
 
@@ -297,11 +354,11 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
         for (size_t i = 0; i < num_columns; ++i)
         {
             if (i != 0)
-                rows_end_out        << grid[3][2];
+                rows_end_out << grid[3][2];
             for (size_t j = 0; j < max_widths[i] + 2; ++j)
-                rows_end_out        << grid[3][1];
+                rows_end_out << grid[3][1];
         }
-        rows_end_out        << grid[3][3] << "
";
+        rows_end_out << grid[3][3] << "
";
     }
     else if (style == Style::Space)
     {
@@ -334,7 +391,7 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
     ///    ┃ name ┃
     ///    ┌─name─┐
     ///    └─name─┘
-    ///     name
+    ///      name
     auto write_names = [&](bool is_top) -> void
     {
         writeString(left_blank, out);
@@ -405,6 +462,10 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
 
     bool vertical_filler_written = false;
     size_t displayed_row = 0;
+
+    std::vector<std::optional<String>> serialized_values(num_columns);
+    std::vector<size_t> offsets_inside_serialized_values(num_columns);
+
     for (size_t i = 0; i < num_rows && displayed_rows < format_settings.pretty.max_rows; ++i)
     {
         if (cutInTheMiddle(i, num_rows, format_settings.pretty.max_rows))
@@ -421,46 +482,73 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
             if (i != 0)
                 writeString(rows_separator, out);
 
-            if (format_settings.pretty.row_numbers)
+            /// A value can span multiple lines, and we want to iterate over them.
+            for (size_t j = 0; j < num_columns; ++j)
             {
-                /// Write row number;
-                auto row_num_string = std::to_string(i + 1 + total_rows) + ". ";
-                for (size_t j = 0; j < row_number_width - row_num_string.size(); ++j)
-                    writeChar(' ', out);
-
-                if (color)
-                    out << "\033[90m";
-                writeString(row_num_string, out);
-                if (color)
-                    out << "\033[0m";
+                serialized_values[j].reset();
+                offsets_inside_serialized_values[j] = 0;
             }
 
-            for (size_t j = 0; j < num_columns; ++j)
+            /// As long as there are lines in any of fields, output a line.
+            bool first_line = true;
+            while (true)
             {
+                if (format_settings.pretty.row_numbers)
+                {
+                    if (first_line)
+                    {
+                        /// Write row number;
+                        auto row_num_string = std::to_string(i + 1 + total_rows) + ". ";
+                        for (size_t j = 0; j < row_number_width - row_num_string.size(); ++j)
+                            writeChar(' ', out);
+
+                        if (color)
+                            out << "\033[90m";
+                        writeString(row_num_string, out);
+                        if (color)
+                            out << "\033[0m";
+
+                        first_line = false;
+                    }
+                    else
+                        out << left_blank;
+                }
+
+                bool all_lines_printed = true;
+                for (size_t j = 0; j < num_columns; ++j)
+                {
+                    if (style != Style::Space)
+                        out << vertical_bar;
+                    else if (j != 0)
+                        out << " ";
+
+                    const auto & type = *header.getByPosition(j).type;
+                    writeValueWithPadding(
+                        *columns[j],
+                        *serializations[j],
+                        i,
+                        format_settings.pretty.multiline_fields, serialized_values[j], offsets_inside_serialized_values[j],
+                        widths[j].empty() ? max_widths[j] : widths[j][displayed_row],
+                        max_widths[j],
+                        cut_to_width,
+                        type.shouldAlignRightInPrettyFormats(),
+                        isNumber(type));
+
+                    if (offsets_inside_serialized_values[j] != serialized_values[j]->size())
+                        all_lines_printed = false;
+                }
+
                 if (style != Style::Space)
                     out << vertical_bar;
-                else if (j != 0)
-                    out << " ";
-
-                const auto & type = *header.getByPosition(j).type;
-                writeValueWithPadding(
-                    *columns[j],
-                    *serializations[j],
-                    i,
-                    widths[j].empty() ? max_widths[j] : widths[j][displayed_row],
-                    max_widths[j],
-                    cut_to_width,
-                    type.shouldAlignRightInPrettyFormats(),
-                    isNumber(type));
-            }
 
-            if (style != Style::Space)
-                out << vertical_bar;
+                if (readable_number_tip)
+                    writeReadableNumberTipIfSingleValue(out, chunk, format_settings, color);
 
-            if (readable_number_tip)
-                writeReadableNumberTipIfSingleValue(out, chunk, format_settings, color);
+                out << "
";
+                if (all_lines_printed)
+                    break;
+            }
 
-            out << "
";
             ++displayed_row;
             ++displayed_rows;
         }
@@ -484,38 +572,69 @@ void PrettyBlockOutputFormat::writeChunk(const Chunk & chunk, PortKind port_kind
 
 void PrettyBlockOutputFormat::writeValueWithPadding(
     const IColumn & column, const ISerialization & serialization, size_t row_num,
+    bool split_by_lines, std::optional<String> & serialized_value, size_t & start_from_offset,
     size_t value_width, size_t pad_to_width, size_t cut_to_width, bool align_right, bool is_number)
 {
-    String serialized_value;
+    if (!serialized_value)
     {
-        WriteBufferFromString out_serialize(serialized_value, AppendModeTag());
+        serialized_value = String();
+        start_from_offset = 0;
+        WriteBufferFromString out_serialize(*serialized_value);
         serialization.serializeText(column, row_num, out_serialize, format_settings);
     }
 
+    size_t prefix = row_number_width + (style == Style::Space ? 1 : 2);
+
+    bool is_continuation = start_from_offset > 0 && start_from_offset < serialized_value->size();
+
+    String serialized_fragment;
+    if (start_from_offset == serialized_value->size())
+    {
+        /// Only padding, nothing remains.
+        value_width = 0;
+    }
+    else if (split_by_lines)
+    {
+        const char * end = serialized_value->data() + serialized_value->size();
+        const char * next_nl = find_first_symbols<'
'>(serialized_value->data() + start_from_offset, end);
+        size_t fragment_end_offset = next_nl - serialized_value->data();
+        serialized_fragment = serialized_value->substr(start_from_offset, fragment_end_offset - start_from_offset);
+        value_width = UTF8::computeWidth(reinterpret_cast<const UInt8 *>(serialized_fragment.data()), serialized_fragment.size(), prefix);
+        start_from_offset = fragment_end_offset;
+    }
+    else
+    {
+        serialized_fragment = *serialized_value;
+        start_from_offset = serialized_value->size();
+    }
+
     /// Highlight groups of thousands.
     if (color && is_number && format_settings.pretty.highlight_digit_groups)
-        serialized_value = highlightDigitGroups(serialized_value);
+        serialized_fragment = highlightDigitGroups(serialized_fragment);
 
     /// Highlight trailing spaces.
     if (color && format_settings.pretty.highlight_trailing_spaces)
-        serialized_value = highlightTrailingSpaces(serialized_value);
+        serialized_fragment = highlightTrailingSpaces(serialized_fragment);
+
+    const char * ellipsis = format_settings.pretty.charset == FormatSettings::Pretty::Charset::UTF8 ? "⋯" : "~";
+    const char * line_feed = format_settings.pretty.charset == FormatSettings::Pretty::Charset::UTF8 ? "↴" : "\\";
+    const char * line_continuation = format_settings.pretty.charset == FormatSettings::Pretty::Charset::UTF8 ? "↳" : ">";
 
     bool is_cut = false;
     if (cut_to_width && value_width > cut_to_width)
     {
         is_cut = true;
-        serialized_value.resize(UTF8::computeBytesBeforeWidth(
-            reinterpret_cast<const UInt8 *>(serialized_value.data()), serialized_value.size(), 0, format_settings.pretty.max_value_width));
+        serialized_fragment.resize(UTF8::computeBytesBeforeWidth(
+            reinterpret_cast<const UInt8 *>(serialized_fragment.data()), serialized_fragment.size(), prefix, format_settings.pretty.max_value_width));
 
-        const char * ellipsis = format_settings.pretty.charset == FormatSettings::Pretty::Charset::UTF8 ? "⋯" : "~";
         if (color)
         {
-            serialized_value += "\033[31;1m";
-            serialized_value += ellipsis;
-            serialized_value += "\033[0m";
+            serialized_fragment += "\033[31;1m";
+            serialized_fragment += ellipsis;
+            serialized_fragment += "\033[0m";
         }
         else
-            serialized_value += ellipsis;
+            serialized_fragment += ellipsis;
 
         value_width = format_settings.pretty.max_value_width;
     }
@@ -527,21 +646,41 @@ void PrettyBlockOutputFormat::writeValueWithPadding(
                 writeChar(' ', out);
     };
 
-    out.write(' ');
+    if (is_continuation)
+    {
+        if (color)
+            out << "\033[90m";
+        writeCString(line_continuation, out);
+        if (color)
+            out << "\033[0m";
+    }
+    else
+        out.write(' ');
 
     if (align_right)
     {
         write_padding();
-        out.write(serialized_value.data(), serialized_value.size());
+        out.write(serialized_fragment.data(), serialized_fragment.size());
     }
     else
     {
-        out.write(serialized_value.data(), serialized_value.size());
+        out.write(serialized_fragment.data(), serialized_fragment.size());
         write_padding();
     }
 
-    if (!is_cut)
+    if (start_from_offset != serialized_value->size())
+    {
+        if (color)
+            out << "\033[90m";
+        writeCString(line_feed, out);
+        if (color)
+            out << "\033[0m";
+    }
+    else if (!is_cut)
         out.write(' ');
+
+    if (start_from_offset < serialized_value->size())
+        ++start_from_offset;
 }
 
 
diff --git a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
index 671c09abefc8..c3f05d55e549 100644
--- a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
+++ b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
@@ -54,11 +54,12 @@ class PrettyBlockOutputFormat : public IOutputFormat
     void onRowsReadBeforeUpdate() override { total_rows = getRowsReadBefore(); }
 
     void calculateWidths(
-        const Block & header, const Chunk & chunk,
+        const Block & header, const Chunk & chunk, bool split_by_lines, bool & out_has_newlines,
         WidthsPerColumn & widths, Widths & max_padded_widths, Widths & name_widths, Strings & names);
 
     void writeValueWithPadding(
         const IColumn & column, const ISerialization & serialization, size_t row_num,
+        bool split_by_lines, std::optional<String> & serialized_value, size_t & start_from_offset,
         size_t value_width, size_t pad_to_width, size_t cut_to_width, bool align_right, bool is_number);
 
     void resetFormatterImpl() override
@@ -75,8 +76,13 @@ class PrettyBlockOutputFormat : public IOutputFormat
     Style style;
     bool mono_block;
     bool color;
+
+    /// Fallback to Vertical format for wide but short tables.
+    std::unique_ptr<IRowOutputFormat> vertical_format_fallback;
+
     /// For mono_block == true only
     Chunk mono_chunk;
+
     /// Implements squashing of chunks by time
     std::condition_variable mono_chunk_condvar;
     std::optional<ThreadFromGlobalPool> thread;
