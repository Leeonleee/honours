diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index 3f4dec9dc931..6c427442e498 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -4337,6 +4337,18 @@ Possible values:
 
 Default value: `0`.
 
+
+## function_locate_has_mysql_compatible_argument_order {#function-locate-has-mysql-compatible-argument-order}
+
+Controls the order of arguments in function [locate](../../sql-reference/functions/string-search-functions.md#locate).
+
+Possible values:
+
+- 0 — Function `locate` accepts arguments `(haystack, needle[, start_pos])`.
+- 1 — Function `locate` accepts arguments `(needle, haystack, [, start_pos])` (MySQL-compatible behavior)
+
+Default value: `1`.
+
 ## date_time_overflow_behavior {#date_time_overflow_behavior}
 
 Defines the behavior when [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md) or integers are converted into Date, Date32, DateTime or DateTime64 but the value cannot be represented in the result type.
diff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md
index 22f879c62aee..1b03f220db22 100644
--- a/docs/en/sql-reference/functions/string-search-functions.md
+++ b/docs/en/sql-reference/functions/string-search-functions.md
@@ -30,7 +30,6 @@ position(haystack, needle[, start_pos])
 
 Alias:
 - `position(needle IN haystack)`
-- `locate(haystack, needle[, start_pos])`.
 
 **Arguments**
 
@@ -49,7 +48,7 @@ If substring `needle` is empty, these rules apply:
 - if `start_pos >= 1` and `start_pos <= length(haystack) + 1`: return `start_pos`
 - otherwise: return `0`
 
-The same rules also apply to functions `positionCaseInsensitive`, `positionUTF8` and `positionCaseInsensitiveUTF8`
+The same rules also apply to functions `locate`, `positionCaseInsensitive`, `positionUTF8` and `positionCaseInsensitiveUTF8`.
 
 Type: `Integer`.
 
@@ -114,6 +113,21 @@ SELECT
 └─────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┴────────────────────────┘
 ```
 
+## locate
+
+Like [position](#position) but with arguments `haystack` and `locate` switched.
+
+The behavior of this function depends on the ClickHouse version:
+- in versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`.
+- in versions >= 24.3,, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`. The previous behavior
+  can be restored using setting [function_locate_has_mysql_compatible_argument_order = false](../../operations/settings/settings.md#function-locate-has-mysql-compatible-argument-order);
+
+**Syntax**
+
+``` sql
+locate(needle, haystack[, start_pos])
+```
+
 ## positionCaseInsensitive
 
 Like [position](#position) but searches case-insensitively.
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 48f6b4d621c8..530a5ca3253a 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -175,6 +175,7 @@ class IColumn;
     M(Bool, enable_positional_arguments, true, "Enable positional arguments in ORDER BY, GROUP BY and LIMIT BY", 0) \
     M(Bool, enable_extended_results_for_datetime_functions, false, "Enable date functions like toLastDayOfMonth return Date32 results (instead of Date results) for Date32/DateTime64 arguments.", 0) \
     M(Bool, allow_nonconst_timezone_arguments, false, "Allow non-const timezone arguments in certain time-related functions like toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*()", 0) \
+    M(Bool, function_locate_has_mysql_compatible_argument_order, true, "Function locate() has arguments (needle, haystack[, start_pos]) like in MySQL instead of (haystack, needle[, start_pos]) like function position()", 0) \
     \
     M(Bool, group_by_use_nulls, false, "Treat columns mentioned in ROLLUP, CUBE or GROUPING SETS as Nullable", 0) \
     \
diff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h
index 4914f97a6fb5..7690f5537fdd 100644
--- a/src/Core/SettingsChangesHistory.h
+++ b/src/Core/SettingsChangesHistory.h
@@ -94,6 +94,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett
               {"input_format_json_use_string_type_for_ambiguous_paths_in_named_tuples_inference_from_objects", false, false, "Allow to use String type for ambiguous paths during named tuple inference from JSON objects"},
               {"throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert", false, true, "Deduplication is dependent materialized view cannot work together with async inserts."},
               {"parallel_replicas_allow_in_with_subquery", false, true, "If true, subquery for IN will be executed on every follower replica"},
+              {"function_locate_has_mysql_compatible_argument_order", false, true, "Increase compatibility with MySQL's locate function."},
               {"filesystem_cache_reserve_space_wait_lock_timeout_milliseconds", 1000, 1000, "Wait time to lock cache for sapce reservation in filesystem cache"},
               }},
     {"24.2", {{"allow_suspicious_variant_types", true, false, "Don't allow creating Variant type with suspicious variants by default"},
diff --git a/src/Functions/FunctionsStringSearch.h b/src/Functions/FunctionsStringSearch.h
index 41b476ccc569..53d99198134f 100644
--- a/src/Functions/FunctionsStringSearch.h
+++ b/src/Functions/FunctionsStringSearch.h
@@ -22,13 +22,13 @@ namespace DB
   * positionCaseInsensitive(haystack, needle)
   * positionCaseInsensitiveUTF8(haystack, needle)
   *
-  * like(haystack, pattern)        - search by the regular expression LIKE; Returns 0 or 1. Case-insensitive, but only for Latin.
-  * notLike(haystack, pattern)
+  * like(haystack, needle)        - search by the regular expression LIKE; Returns 0 or 1. Case-insensitive, but only for Latin.
+  * notLike(haystack, needle)
   *
-  * ilike(haystack, pattern) - like 'like' but case-insensitive
-  * notIlike(haystack, pattern)
+  * ilike(haystack, needle) - like 'like' but case-insensitive
+  * notIlike(haystack, needle)
   *
-  * match(haystack, pattern)       - search by regular expression re2; Returns 0 or 1.
+  * match(haystack, needle)       - search by regular expression re2; Returns 0 or 1.
   *
   * countSubstrings(haystack, needle) -- count number of occurrences of needle in haystack.
   * countSubstringsCaseInsensitive(haystack, needle)
@@ -53,7 +53,7 @@ namespace DB
   * - the first subpattern, if the regexp has a subpattern;
   * - the zero subpattern (the match part, otherwise);
   * - if not match - an empty string.
-  * extract(haystack, pattern)
+  * extract(haystack, needle)
   */
 
 namespace ErrorCodes
@@ -69,13 +69,39 @@ enum class ExecutionErrorPolicy
     Throw
 };
 
-template <typename Impl, ExecutionErrorPolicy execution_error_policy = ExecutionErrorPolicy::Throw>
+enum class HaystackNeedleOrderIsConfigurable
+{
+    No,     /// function arguments are always: (haystack, needle[, position])
+    Yes     /// depending on a setting, the function arguments are (haystack, needle[, position]) or (needle, haystack[, position])
+};
+
+template <typename Impl,
+         ExecutionErrorPolicy execution_error_policy = ExecutionErrorPolicy::Throw,
+         HaystackNeedleOrderIsConfigurable haystack_needle_order_is_configurable = HaystackNeedleOrderIsConfigurable::No>
 class FunctionsStringSearch : public IFunction
 {
+private:
+    enum class ArgumentOrder
+    {
+        HaystackNeedle,
+        NeedleHaystack
+    };
+
+    ArgumentOrder argument_order = ArgumentOrder::HaystackNeedle;
+
 public:
     static constexpr auto name = Impl::name;
 
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionsStringSearch>(); }
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionsStringSearch>(context); }
+
+    explicit FunctionsStringSearch([[maybe_unused]] ContextPtr context)
+    {
+        if constexpr (haystack_needle_order_is_configurable == HaystackNeedleOrderIsConfigurable::Yes)
+        {
+            if (context->getSettingsRef().function_locate_has_mysql_compatible_argument_order)
+                argument_order = ArgumentOrder::NeedleHaystack;
+        }
+    }
 
     String getName() const override { return name; }
 
@@ -105,13 +131,16 @@ class FunctionsStringSearch : public IFunction
                 "Number of arguments for function {} doesn't match: passed {}, should be 2 or 3",
                 getName(), arguments.size());
 
-        if (!isStringOrFixedString(arguments[0]))
+        const auto & haystack_type = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[0] : arguments[1];
+        const auto & needle_type = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[1] : arguments[0];
+
+        if (!isStringOrFixedString(haystack_type))
             throw Exception(
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                 "Illegal type {} of argument of function {}",
                 arguments[0]->getName(), getName());
 
-        if (!isString(arguments[1]))
+        if (!isString(needle_type))
             throw Exception(
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                 "Illegal type {} of argument of function {}",
@@ -135,8 +164,8 @@ class FunctionsStringSearch : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override
     {
-        const ColumnPtr & column_haystack = arguments[0].column;
-        const ColumnPtr & column_needle = arguments[1].column;
+        const ColumnPtr & column_haystack = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[0].column : arguments[1].column;
+        const ColumnPtr & column_needle = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[1].column : arguments[0].column;
 
         ColumnPtr column_start_pos = nullptr;
         if (arguments.size() >= 3)
diff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp
index 157f2fa8a262..d92bfcf0bc65 100644
--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp
+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp
@@ -213,6 +213,7 @@ struct MapToSubcolumnAdapter : public MapAdapterBase<MapToSubcolumnAdapter<Name,
 class FunctionMapKeyLike : public IFunction
 {
 public:
+    FunctionMapKeyLike() : impl(/*context*/ nullptr) {} /// nullptr because getting a context here is hard and FunctionLike doesn't need context
     String getName() const override { return "mapKeyLike"; }
     size_t getNumberOfArguments() const override { return 3; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
diff --git a/src/Functions/like.cpp b/src/Functions/like.cpp
index 5a86e37a92d8..de9073802654 100644
--- a/src/Functions/like.cpp
+++ b/src/Functions/like.cpp
@@ -1,5 +1,5 @@
-#include "FunctionFactory.h"
 #include "like.h"
+#include "FunctionFactory.h"
 
 
 namespace DB
diff --git a/src/Functions/locate.cpp b/src/Functions/locate.cpp
new file mode 100644
index 000000000000..9a70fbb2d721
--- /dev/null
+++ b/src/Functions/locate.cpp
@@ -0,0 +1,34 @@
+#include "FunctionsStringSearch.h"
+#include "FunctionFactory.h"
+#include "PositionImpl.h"
+
+
+namespace DB
+{
+namespace
+{
+
+struct NameLocate
+{
+    static constexpr auto name = "locate";
+};
+
+using FunctionLocate = FunctionsStringSearch<PositionImpl<NameLocate, PositionCaseSensitiveASCII>, ExecutionErrorPolicy::Throw, HaystackNeedleOrderIsConfigurable::Yes>;
+
+}
+
+REGISTER_FUNCTION(Locate)
+{
+    FunctionDocumentation::Description doc_description = "Like function `position` but with arguments `haystack` and `locate` switched. The behavior of this function depends on the ClickHouse version: In versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`. In versions >= 24.3,, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`. The previous behaviorcan be restored using setting `function_locate_has_mysql_compatible_argument_order = false`.";
+    FunctionDocumentation::Syntax doc_syntax = "location(needle, haystack[, start_pos])";
+    FunctionDocumentation::Arguments doc_arguments = {{"needle", "Substring to be searched (String)"},
+                                                      {"haystack", "String in which the search is performed (String)."},
+                                                      {"start_pos", "Position (1-based) in `haystack` at which the search starts (UInt*)."}};
+    FunctionDocumentation::ReturnedValue doc_returned_value = "Starting position in bytes and counting from 1, if the substring was found. 0, if the substring was not found.";
+    FunctionDocumentation::Examples doc_examples = {{"Example", "SELECT locate('abcabc', 'ca');", "3"}};
+    FunctionDocumentation::Categories doc_categories = {"String search"};
+
+
+    factory.registerFunction<FunctionLocate>({doc_description, doc_syntax, doc_arguments, doc_returned_value, doc_examples, doc_categories}, FunctionFactory::CaseInsensitive);
+}
+}
diff --git a/src/Functions/position.cpp b/src/Functions/position.cpp
index 409a593b44cc..29a5db2eb24b 100644
--- a/src/Functions/position.cpp
+++ b/src/Functions/position.cpp
@@ -20,6 +20,5 @@ using FunctionPosition = FunctionsStringSearch<PositionImpl<NamePosition, Positi
 REGISTER_FUNCTION(Position)
 {
     factory.registerFunction<FunctionPosition>({}, FunctionFactory::CaseInsensitive);
-    factory.registerAlias("locate", NamePosition::name, FunctionFactory::CaseInsensitive);
 }
 }
