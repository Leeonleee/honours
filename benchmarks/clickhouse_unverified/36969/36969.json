{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36969,
  "instance_id": "ClickHouse__ClickHouse-36969",
  "issue_numbers": [
    "36557"
  ],
  "base_commit": "226931229bdf3c98ccefe10729d7f0943fee0102",
  "patch": "diff --git a/src/Columns/ColumnArray.h b/src/Columns/ColumnArray.h\nindex 4e951ec28b82..5970802f598b 100644\n--- a/src/Columns/ColumnArray.h\n+++ b/src/Columns/ColumnArray.h\n@@ -176,6 +176,9 @@ class ColumnArray final : public COWHelper<IColumn, ColumnArray>\n \n     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;\n \n+    void finalize() override { data->finalize(); }\n+    bool isFinalized() const override { return data->isFinalized(); }\n+\n     bool isCollationSupported() const override { return getData().isCollationSupported(); }\n \n     size_t getNumberOfDimensions() const;\ndiff --git a/src/Columns/ColumnMap.h b/src/Columns/ColumnMap.h\nindex a3e171008fff..1e03633ced70 100644\n--- a/src/Columns/ColumnMap.h\n+++ b/src/Columns/ColumnMap.h\n@@ -93,6 +93,8 @@ class ColumnMap final : public COWHelper<IColumn, ColumnMap>\n     bool structureEquals(const IColumn & rhs) const override;\n     double getRatioOfDefaultRows(double sample_ratio) const override;\n     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;\n+    void finalize() override { nested->finalize(); }\n+    bool isFinalized() const override { return nested->isFinalized(); }\n \n     const ColumnArray & getNestedColumn() const { return assert_cast<const ColumnArray &>(*nested); }\n     ColumnArray & getNestedColumn() { return assert_cast<ColumnArray &>(*nested); }\ndiff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp\nindex 86586559ff7c..bf4630137d5c 100644\n--- a/src/Columns/ColumnObject.cpp\n+++ b/src/Columns/ColumnObject.cpp\n@@ -732,8 +732,8 @@ void ColumnObject::get(size_t n, Field & res) const\n {\n     assert(n < size());\n     res = Object();\n-\n     auto & object = res.get<Object &>();\n+\n     for (const auto & entry : subcolumns)\n     {\n         auto it = object.try_emplace(entry->path.getPath()).first;\n@@ -744,7 +744,6 @@ void ColumnObject::get(size_t n, Field & res) const\n void ColumnObject::insertFrom(const IColumn & src, size_t n)\n {\n     insert(src[n]);\n-    finalize();\n }\n \n void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t length)\n@@ -792,9 +791,8 @@ MutableColumnPtr ColumnObject::applyForSubcolumns(Func && func) const\n {\n     if (!isFinalized())\n     {\n-        auto finalized = IColumn::mutate(getPtr());\n+        auto finalized = cloneFinalized();\n         auto & finalized_object = assert_cast<ColumnObject &>(*finalized);\n-        finalized_object.finalize();\n         return finalized_object.applyForSubcolumns(std::forward<Func>(func));\n     }\n \ndiff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h\nindex f32356fed6e6..8fcf3d41fbad 100644\n--- a/src/Columns/ColumnObject.h\n+++ b/src/Columns/ColumnObject.h\n@@ -198,10 +198,6 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     Subcolumns & getSubcolumns() { return subcolumns; }\n     PathsInData getKeys() const;\n \n-    /// Finalizes all subcolumns.\n-    void finalize();\n-    bool isFinalized() const;\n-\n     /// Part of interface\n \n     const char * getFamilyName() const override { return \"Object\"; }\n@@ -219,12 +215,17 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     void popBack(size_t length) override;\n     Field operator[](size_t n) const override;\n     void get(size_t n, Field & res) const override;\n+\n     ColumnPtr permute(const Permutation & perm, size_t limit) const override;\n     ColumnPtr filter(const Filter & filter, ssize_t result_size_hint) const override;\n     ColumnPtr index(const IColumn & indexes, size_t limit) const override;\n     ColumnPtr replicate(const Offsets & offsets) const override;\n     MutableColumnPtr cloneResized(size_t new_size) const override;\n \n+    /// Finalizes all subcolumns.\n+    void finalize() override;\n+    bool isFinalized() const override;\n+\n     /// Order of rows in ColumnObject is undefined.\n     void getPermutation(PermutationSortDirection, PermutationSortStability, size_t, int, Permutation & res) const override;\n     void compareColumn(const IColumn & rhs, size_t rhs_row_num,\n@@ -264,9 +265,7 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     template <typename Func>\n     MutableColumnPtr applyForSubcolumns(Func && func) const;\n \n-    /// For given subcolumn return subcolumn from the same Nested type.\n     /// It's used to get shared sized of Nested to insert correct default values.\n     const Subcolumns::Node * getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const;\n };\n-\n }\ndiff --git a/src/Columns/ColumnTuple.cpp b/src/Columns/ColumnTuple.cpp\nindex 3577b6dee284..d8a43bf510db 100644\n--- a/src/Columns/ColumnTuple.cpp\n+++ b/src/Columns/ColumnTuple.cpp\n@@ -570,4 +570,15 @@ void ColumnTuple::getIndicesOfNonDefaultRows(Offsets & indices, size_t from, siz\n     return getIndicesOfNonDefaultRowsImpl<ColumnTuple>(indices, from, limit);\n }\n \n+void ColumnTuple::finalize()\n+{\n+    for (auto & column : columns)\n+        column->finalize();\n+}\n+\n+bool ColumnTuple::isFinalized() const\n+{\n+    return std::all_of(columns.begin(), columns.end(), [](const auto & column) { return column->isFinalized(); });\n+}\n+\n }\ndiff --git a/src/Columns/ColumnTuple.h b/src/Columns/ColumnTuple.h\nindex 385de7db1e72..96395d4edfb8 100644\n--- a/src/Columns/ColumnTuple.h\n+++ b/src/Columns/ColumnTuple.h\n@@ -103,6 +103,8 @@ class ColumnTuple final : public COWHelper<IColumn, ColumnTuple>\n     ColumnPtr compress() const override;\n     double getRatioOfDefaultRows(double sample_ratio) const override;\n     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;\n+    void finalize() override;\n+    bool isFinalized() const override;\n \n     size_t tupleSize() const { return columns.size(); }\n \ndiff --git a/src/Columns/IColumn.h b/src/Columns/IColumn.h\nindex 19f3dea4f820..548b2b44f150 100644\n--- a/src/Columns/IColumn.h\n+++ b/src/Columns/IColumn.h\n@@ -453,6 +453,16 @@ class IColumn : public COW<IColumn>\n         return getPtr();\n     }\n \n+    /// Some columns may require finalization before using of other operations.\n+    virtual void finalize() {}\n+    virtual bool isFinalized() const { return true; }\n+\n+    MutablePtr cloneFinalized() const\n+    {\n+        auto finalized = IColumn::mutate(getPtr());\n+        finalized->finalize();\n+        return finalized;\n+    }\n \n     [[nodiscard]] static MutablePtr mutate(Ptr ptr)\n     {\ndiff --git a/src/DataTypes/DataTypeArray.h b/src/DataTypes/DataTypeArray.h\nindex 122ac8e03a3a..033a657c845d 100644\n--- a/src/DataTypes/DataTypeArray.h\n+++ b/src/DataTypes/DataTypeArray.h\n@@ -48,6 +48,7 @@ class DataTypeArray final : public IDataType\n     bool textCanContainOnlyValidUTF8() const override { return nested->textCanContainOnlyValidUTF8(); }\n     bool isComparable() const override { return nested->isComparable(); }\n     bool canBeComparedWithCollation() const override { return nested->canBeComparedWithCollation(); }\n+    bool hasDynamicSubcolumns() const override { return nested->hasDynamicSubcolumns(); }\n \n     bool isValueUnambiguouslyRepresentedInContiguousMemoryRegion() const override\n     {\ndiff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp\nindex 42ec739c33ba..d49c205fc592 100644\n--- a/src/DataTypes/DataTypeMap.cpp\n+++ b/src/DataTypes/DataTypeMap.cpp\n@@ -22,6 +22,27 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+DataTypeMap::DataTypeMap(const DataTypePtr & nested_)\n+    : nested(nested_)\n+{\n+    const auto * type_array = typeid_cast<const DataTypeArray *>(nested.get());\n+    if (!type_array)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Expected Array(Tuple(key, value)) type, got {}\", nested->getName());\n+\n+    const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_array->getNestedType().get());\n+    if (!type_tuple)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Expected Array(Tuple(key, value)) type, got {}\", nested->getName());\n+\n+    if (type_tuple->getElements().size() != 2)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Expected Array(Tuple(key, value)) type, got {}\", nested->getName());\n+\n+    key_type = type_tuple->getElement(0);\n+    value_type = type_tuple->getElement(1);\n+    assertKeyType();\n+}\n \n DataTypeMap::DataTypeMap(const DataTypes & elems_)\n {\ndiff --git a/src/DataTypes/DataTypeMap.h b/src/DataTypes/DataTypeMap.h\nindex 479008031fed..2ab5c602a259 100644\n--- a/src/DataTypes/DataTypeMap.h\n+++ b/src/DataTypes/DataTypeMap.h\n@@ -23,6 +23,7 @@ class DataTypeMap final : public IDataType\n public:\n     static constexpr bool is_parametric = true;\n \n+    explicit DataTypeMap(const DataTypePtr & nested_);\n     explicit DataTypeMap(const DataTypes & elems);\n     DataTypeMap(const DataTypePtr & key_type_, const DataTypePtr & value_type_);\n \n@@ -40,6 +41,7 @@ class DataTypeMap final : public IDataType\n     bool isComparable() const override { return key_type->isComparable() && value_type->isComparable(); }\n     bool isParametric() const override { return true; }\n     bool haveSubtypes() const override { return true; }\n+    bool hasDynamicSubcolumns() const override { return nested->hasDynamicSubcolumns(); }\n \n     const DataTypePtr & getKeyType() const { return key_type; }\n     const DataTypePtr & getValueType() const { return value_type; }\ndiff --git a/src/DataTypes/DataTypeObject.h b/src/DataTypes/DataTypeObject.h\nindex 503947c3738b..2f6ad9615123 100644\n--- a/src/DataTypes/DataTypeObject.h\n+++ b/src/DataTypes/DataTypeObject.h\n@@ -36,6 +36,7 @@ class DataTypeObject : public IDataType\n     bool haveSubtypes() const override { return false; }\n     bool equals(const IDataType & rhs) const override;\n     bool isParametric() const override { return true; }\n+    bool hasDynamicSubcolumns() const override { return true; }\n \n     SerializationPtr doGetDefaultSerialization() const override;\n \ndiff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp\nindex ef05cd440c03..87cbac4cfb2b 100644\n--- a/src/DataTypes/DataTypeTuple.cpp\n+++ b/src/DataTypes/DataTypeTuple.cpp\n@@ -247,6 +247,11 @@ bool DataTypeTuple::haveMaximumSizeOfValue() const\n     return std::all_of(elems.begin(), elems.end(), [](auto && elem) { return elem->haveMaximumSizeOfValue(); });\n }\n \n+bool DataTypeTuple::hasDynamicSubcolumns() const\n+{\n+    return std::any_of(elems.begin(), elems.end(), [](auto && elem) { return elem->hasDynamicSubcolumns(); });\n+}\n+\n bool DataTypeTuple::isComparable() const\n {\n     return std::all_of(elems.begin(), elems.end(), [](auto && elem) { return elem->isComparable(); });\ndiff --git a/src/DataTypes/DataTypeTuple.h b/src/DataTypes/DataTypeTuple.h\nindex 5abec18bd3b5..152f21015f5a 100644\n--- a/src/DataTypes/DataTypeTuple.h\n+++ b/src/DataTypes/DataTypeTuple.h\n@@ -50,6 +50,7 @@ class DataTypeTuple final : public IDataType\n     bool isComparable() const override;\n     bool textCanContainOnlyValidUTF8() const override;\n     bool haveMaximumSizeOfValue() const override;\n+    bool hasDynamicSubcolumns() const override;\n     size_t getMaximumSizeOfValueInMemory() const override;\n     size_t getSizeOfValueInMemory() const override;\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex c93128ced959..4db944c8c3fb 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -291,6 +291,9 @@ class IDataType : private boost::noncopyable, public std::enable_shared_from_thi\n     /// Strings, Numbers, Date, DateTime, Nullable\n     virtual bool canBeInsideLowCardinality() const { return false; }\n \n+    /// Object, Array(Object), Tuple(..., Object, ...)\n+    virtual bool hasDynamicSubcolumns() const { return false; }\n+\n     /// Updates avg_value_size_hint for newly read column. Uses to optimize deserialization. Zero expected for first column.\n     static void updateAvgValueSizeHint(const IColumn & column, double & avg_value_size_hint);\n \ndiff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp\nindex e5d8d05acb56..e711b34ffa9b 100644\n--- a/src/DataTypes/ObjectUtils.cpp\n+++ b/src/DataTypes/ObjectUtils.cpp\n@@ -1,17 +1,19 @@\n-#include <Storages/StorageSnapshot.h>\n #include <DataTypes/ObjectUtils.h>\n #include <DataTypes/DataTypeObject.h>\n #include <DataTypes/DataTypeNothing.h>\n #include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeMap.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeNested.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <DataTypes/NestedUtils.h>\n+#include <Storages/StorageSnapshot.h>\n #include <Columns/ColumnObject.h>\n #include <Columns/ColumnTuple.h>\n #include <Columns/ColumnArray.h>\n+#include <Columns/ColumnMap.h>\n #include <Columns/ColumnNullable.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTExpressionList.h>\n@@ -105,10 +107,11 @@ Array createEmptyArrayField(size_t num_dimensions)\n DataTypePtr getDataTypeByColumn(const IColumn & column)\n {\n     auto idx = column.getDataType();\n-    if (WhichDataType(idx).isSimple())\n+    WhichDataType which(idx);\n+    if (which.isSimple())\n         return DataTypeFactory::instance().get(String(magic_enum::enum_name(idx)));\n \n-    if (WhichDataType(idx).isNothing())\n+    if (which.isNothing())\n         return std::make_shared<DataTypeNothing>();\n \n     if (const auto * column_array = checkAndGetColumn<ColumnArray>(&column))\n@@ -132,41 +135,124 @@ static auto extractVector(const std::vector<Tuple> & vec)\n     return res;\n }\n \n-void convertObjectsToTuples(Block & block, const NamesAndTypesList & extended_storage_columns)\n+static DataTypePtr recreateTupleWithElements(const DataTypeTuple & type_tuple, const DataTypes & elements)\n {\n-    std::unordered_map<String, DataTypePtr> storage_columns_map;\n-    for (const auto & [name, type] : extended_storage_columns)\n-        storage_columns_map[name] = type;\n+    return type_tuple.haveExplicitNames()\n+        ? std::make_shared<DataTypeTuple>(elements, type_tuple.getElementNames())\n+        : std::make_shared<DataTypeTuple>(elements);\n+}\n \n-    for (auto & column : block)\n+static std::pair<ColumnPtr, DataTypePtr> convertObjectColumnToTuple(\n+    const ColumnObject & column_object, const DataTypeObject & type_object)\n+{\n+    if (!column_object.isFinalized())\n     {\n-        if (!isObject(column.type))\n-            continue;\n+        auto finalized = column_object.cloneFinalized();\n+        const auto & finalized_object = assert_cast<const ColumnObject &>(*finalized);\n+        return convertObjectColumnToTuple(finalized_object, type_object);\n+    }\n \n-        const auto & column_object = assert_cast<const ColumnObject &>(*column.column);\n-        if (!column_object.isFinalized())\n-            throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Cannot convert to tuple column '{}' from type {}. Column should be finalized first\",\n-                column.name, column.type->getName());\n+    const auto & subcolumns = column_object.getSubcolumns();\n \n-        std::tie(column.column, column.type) = unflattenObjectToTuple(column_object);\n+    PathsInData tuple_paths;\n+    DataTypes tuple_types;\n+    Columns tuple_columns;\n \n-        auto it = storage_columns_map.find(column.name);\n-        if (it == storage_columns_map.end())\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Column '{}' not found in storage\", column.name);\n+    for (const auto & entry : subcolumns)\n+    {\n+        tuple_paths.emplace_back(entry->path);\n+        tuple_types.emplace_back(entry->data.getLeastCommonType());\n+        tuple_columns.emplace_back(entry->data.getFinalizedColumnPtr());\n+    }\n \n-        /// Check that constructed Tuple type and type in storage are compatible.\n-        getLeastCommonTypeForObject({column.type, it->second}, true);\n+    return unflattenTuple(tuple_paths, tuple_types, tuple_columns);\n+}\n+\n+static std::pair<ColumnPtr, DataTypePtr> recursivlyConvertDynamicColumnToTuple(\n+    const ColumnPtr & column, const DataTypePtr & type)\n+{\n+    if (!type->hasDynamicSubcolumns())\n+        return {column, type};\n+\n+    if (const auto * type_object = typeid_cast<const DataTypeObject *>(type.get()))\n+    {\n+        const auto & column_object = assert_cast<const ColumnObject &>(*column);\n+        return convertObjectColumnToTuple(column_object, *type_object);\n+    }\n+\n+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type.get()))\n+    {\n+        const auto & column_array = assert_cast<const ColumnArray &>(*column);\n+        auto [new_column, new_type] = recursivlyConvertDynamicColumnToTuple(\n+            column_array.getDataPtr(), type_array->getNestedType());\n+\n+        return\n+        {\n+            ColumnArray::create(new_column, column_array.getOffsetsPtr()),\n+            std::make_shared<DataTypeArray>(std::move(new_type)),\n+        };\n+    }\n+\n+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type.get()))\n+    {\n+        const auto & column_map = assert_cast<const ColumnMap &>(*column);\n+        auto [new_column, new_type] = recursivlyConvertDynamicColumnToTuple(\n+            column_map.getNestedColumnPtr(), type_map->getNestedType());\n+\n+        return\n+        {\n+            ColumnMap::create(new_column),\n+            std::make_shared<DataTypeMap>(std::move(new_type)),\n+        };\n     }\n+\n+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type.get()))\n+    {\n+        const auto & tuple_columns = assert_cast<const ColumnTuple &>(*column).getColumns();\n+        const auto & tuple_types = type_tuple->getElements();\n+\n+        assert(tuple_columns.size() == tuple_types.size());\n+        const size_t tuple_size = tuple_types.size();\n+\n+        Columns new_tuple_columns(tuple_size);\n+        DataTypes new_tuple_types(tuple_size);\n+\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            std::tie(new_tuple_columns[i], new_tuple_types[i])\n+                = recursivlyConvertDynamicColumnToTuple(tuple_columns[i], tuple_types[i]);\n+        }\n+\n+        return\n+        {\n+            ColumnTuple::create(new_tuple_columns),\n+            recreateTupleWithElements(*type_tuple, new_tuple_types)\n+        };\n+    }\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Type {} unexpectedly has dynamic columns\", type->getName());\n }\n \n-void deduceTypesOfObjectColumns(const StorageSnapshotPtr & storage_snapshot, Block & block)\n+void convertDynamicColumnsToTuples(Block & block, const StorageSnapshotPtr & storage_snapshot)\n {\n-    if (!storage_snapshot->object_columns.empty())\n+    for (auto & column : block)\n     {\n-        auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();\n-        auto storage_columns = storage_snapshot->getColumns(options);\n-        convertObjectsToTuples(block, storage_columns);\n+        if (!column.type->hasDynamicSubcolumns())\n+            continue;\n+\n+        std::tie(column.column, column.type)\n+            = recursivlyConvertDynamicColumnToTuple(column.column, column.type);\n+\n+        GetColumnsOptions options(GetColumnsOptions::AllPhysical);\n+        auto storage_column = storage_snapshot->tryGetColumn(options, column.name);\n+        if (!storage_column)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Column '{}' not found in storage\", column.name);\n+\n+        auto storage_column_concrete = storage_snapshot->getColumn(options.withExtendedObjects(), column.name);\n+\n+        /// Check that constructed Tuple type and type in storage are compatible.\n+        getLeastCommonTypeForDynamicColumns(\n+            storage_column->type, {column.type, storage_column_concrete.type}, true);\n     }\n }\n \n@@ -217,24 +303,8 @@ void checkObjectHasNoAmbiguosPaths(const PathsInData & paths)\n     }\n }\n \n-DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths)\n+static DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths)\n {\n-    if (types.empty())\n-        return nullptr;\n-\n-    bool all_equal = true;\n-    for (size_t i = 1; i < types.size(); ++i)\n-    {\n-        if (!types[i]->equals(*types[0]))\n-        {\n-            all_equal = false;\n-            break;\n-        }\n-    }\n-\n-    if (all_equal)\n-        return types[0];\n-\n     /// Types of subcolumns by path from all tuples.\n     std::unordered_map<PathInData, DataTypes, PathInData::Hash> subcolumns_types;\n \n@@ -287,19 +357,139 @@ DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambi\n     return unflattenTuple(tuple_paths, tuple_types);\n }\n \n-NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list)\n+static DataTypePtr getLeastCommonTypeForDynamicColumnsImpl(\n+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths);\n+\n+template<typename Type>\n+static DataTypePtr getLeastCommonTypeForColumnWithNestedType(\n+    const Type & type, const DataTypes & concrete_types, bool check_ambiguos_paths)\n {\n-    NameSet res;\n-    for (const auto & [name, type] : columns_list)\n-        if (isObject(type))\n-            res.insert(name);\n+    DataTypes nested_types;\n+    nested_types.reserve(concrete_types.size());\n \n-    return res;\n+    for (const auto & concrete_type : concrete_types)\n+    {\n+        const auto * type_with_nested_conctete = typeid_cast<const Type *>(concrete_type.get());\n+        if (!type_with_nested_conctete)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected {} type, got {}\", demangle(typeid(Type).name()), concrete_type->getName());\n+\n+        nested_types.push_back(type_with_nested_conctete->getNestedType());\n+    }\n+\n+    return std::make_shared<Type>(\n+        getLeastCommonTypeForDynamicColumnsImpl(\n+            type.getNestedType(), nested_types, check_ambiguos_paths));\n }\n \n-bool hasObjectColumns(const ColumnsDescription & columns)\n+static DataTypePtr getLeastCommonTypeForTuple(\n+    const DataTypeTuple & type, const DataTypes & concrete_types, bool check_ambiguos_paths)\n {\n-    return std::any_of(columns.begin(), columns.end(), [](const auto & column) { return isObject(column.type); });\n+    const auto & element_types = type.getElements();\n+    DataTypes new_element_types(element_types.size());\n+\n+    for (size_t i = 0; i < element_types.size(); ++i)\n+    {\n+        DataTypes concrete_element_types;\n+        concrete_element_types.reserve(concrete_types.size());\n+\n+        for (const auto & type_concrete : concrete_types)\n+        {\n+            const auto * type_tuple_conctete = typeid_cast<const DataTypeTuple *>(type_concrete.get());\n+            if (!type_tuple_conctete)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected Tuple type, got {}\", type_concrete->getName());\n+\n+            concrete_element_types.push_back(type_tuple_conctete->getElement(i));\n+        }\n+\n+        new_element_types[i] = getLeastCommonTypeForDynamicColumnsImpl(\n+            element_types[i], concrete_element_types, check_ambiguos_paths);\n+    }\n+\n+    return recreateTupleWithElements(type, new_element_types);\n+}\n+\n+static DataTypePtr getLeastCommonTypeForDynamicColumnsImpl(\n+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths)\n+{\n+    if (!type_in_storage->hasDynamicSubcolumns())\n+        return type_in_storage;\n+\n+    if (isObject(type_in_storage))\n+        return getLeastCommonTypeForObject(concrete_types, check_ambiguos_paths);\n+\n+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type_in_storage.get()))\n+        return getLeastCommonTypeForColumnWithNestedType(*type_array, concrete_types, check_ambiguos_paths);\n+\n+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type_in_storage.get()))\n+        return getLeastCommonTypeForColumnWithNestedType(*type_map, concrete_types, check_ambiguos_paths);\n+\n+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_in_storage.get()))\n+        return getLeastCommonTypeForTuple(*type_tuple, concrete_types, check_ambiguos_paths);\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Type {} unexpectedly has dynamic columns\", type_in_storage->getName());\n+}\n+\n+DataTypePtr getLeastCommonTypeForDynamicColumns(\n+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths)\n+{\n+    if (concrete_types.empty())\n+        return nullptr;\n+\n+    bool all_equal = true;\n+    for (size_t i = 1; i < concrete_types.size(); ++i)\n+    {\n+        if (!concrete_types[i]->equals(*concrete_types[0]))\n+        {\n+            all_equal = false;\n+            break;\n+        }\n+    }\n+\n+    if (all_equal)\n+        return concrete_types[0];\n+\n+    return getLeastCommonTypeForDynamicColumnsImpl(type_in_storage, concrete_types, check_ambiguos_paths);\n+}\n+\n+DataTypePtr createConcreteEmptyDynamicColumn(const DataTypePtr & type_in_storage)\n+{\n+    if (!type_in_storage->hasDynamicSubcolumns())\n+        return type_in_storage;\n+\n+    if (isObject(type_in_storage))\n+        return std::make_shared<DataTypeTuple>(\n+            DataTypes{std::make_shared<DataTypeUInt8>()}, Names{ColumnObject::COLUMN_NAME_DUMMY});\n+\n+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type_in_storage.get()))\n+        return std::make_shared<DataTypeArray>(\n+            createConcreteEmptyDynamicColumn(type_array->getNestedType()));\n+\n+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type_in_storage.get()))\n+        return std::make_shared<DataTypeMap>(\n+            createConcreteEmptyDynamicColumn(type_map->getNestedType()));\n+\n+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_in_storage.get()))\n+    {\n+        const auto & elements = type_tuple->getElements();\n+        DataTypes new_elements;\n+        new_elements.reserve(elements.size());\n+\n+        for (const auto & element : elements)\n+            new_elements.push_back(createConcreteEmptyDynamicColumn(element));\n+\n+        return recreateTupleWithElements(*type_tuple, new_elements);\n+    }\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Type {} unexpectedly has dynamic columns\", type_in_storage->getName());\n+}\n+\n+bool hasDynamicSubcolumns(const ColumnsDescription & columns)\n+{\n+    return std::any_of(columns.begin(), columns.end(),\n+        [](const auto & column)\n+        {\n+            return column.type->hasDynamicSubcolumns();\n+        });\n }\n \n void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescription & object_columns, bool with_subcolumns)\n@@ -320,16 +510,20 @@ void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescript\n     columns_list.splice(columns_list.end(), std::move(subcolumns_list));\n }\n \n-void updateObjectColumns(ColumnsDescription & object_columns, const NamesAndTypesList & new_columns)\n+void updateObjectColumns(\n+    ColumnsDescription & object_columns,\n+    const ColumnsDescription & storage_columns,\n+    const NamesAndTypesList & new_columns)\n {\n     for (const auto & new_column : new_columns)\n     {\n         auto object_column = object_columns.tryGetColumn(GetColumnsOptions::All, new_column.name);\n         if (object_column && !object_column->type->equals(*new_column.type))\n         {\n+            auto storage_column = storage_columns.getColumn(GetColumnsOptions::All, new_column.name);\n             object_columns.modify(new_column.name, [&](auto & column)\n             {\n-                column.type = getLeastCommonTypeForObject({object_column->type, new_column.type});\n+                column.type = getLeastCommonTypeForDynamicColumns(storage_column.type, {object_column->type, new_column.type});\n             });\n         }\n     }\n@@ -745,13 +939,6 @@ void replaceMissedSubcolumnsByConstants(\n             addConstantToWithClause(query, name, type);\n }\n \n-void finalizeObjectColumns(const MutableColumns & columns)\n-{\n-    for (const auto & column : columns)\n-        if (auto * column_object = typeid_cast<ColumnObject *>(column.get()))\n-            column_object->finalize();\n-}\n-\n Field FieldVisitorReplaceScalars::operator()(const Array & x) const\n {\n     if (num_dimensions_to_keep == 0)\n@@ -768,11 +955,13 @@ size_t FieldVisitorToNumberOfDimensions::operator()(const Array & x)\n {\n     const size_t size = x.size();\n     size_t dimensions = 0;\n+\n     for (size_t i = 0; i < size; ++i)\n     {\n         size_t element_dimensions = applyVisitor(*this, x[i]);\n         if (i > 0 && element_dimensions != dimensions)\n             need_fold_dimension = true;\n+\n         dimensions = std::max(dimensions, element_dimensions);\n     }\n \n@@ -783,12 +972,13 @@ Field FieldVisitorFoldDimension::operator()(const Array & x) const\n {\n     if (num_dimensions_to_fold == 0)\n         return x;\n+\n     const size_t size = x.size();\n     Array res(size);\n     for (size_t i = 0; i < size; ++i)\n-    {\n         res[i] = applyVisitor(FieldVisitorFoldDimension(num_dimensions_to_fold - 1), x[i]);\n-    }\n+\n     return res;\n }\n+\n }\ndiff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h\nindex c60d5bec208c..bd15edfe8513 100644\n--- a/src/DataTypes/ObjectUtils.h\n+++ b/src/DataTypes/ObjectUtils.h\n@@ -39,27 +39,31 @@ Array createEmptyArrayField(size_t num_dimensions);\n DataTypePtr getDataTypeByColumn(const IColumn & column);\n \n /// Converts Object types and columns to Tuples in @columns_list and @block\n-/// and checks that types are consistent with types in @extended_storage_columns.\n-void convertObjectsToTuples(Block & block, const NamesAndTypesList & extended_storage_columns);\n-void deduceTypesOfObjectColumns(const StorageSnapshotPtr & storage_snapshot, Block & block);\n+/// and checks that types are consistent with types in @storage_snapshot.\n+void convertDynamicColumnsToTuples(Block & block, const StorageSnapshotPtr & storage_snapshot);\n \n /// Checks that each path is not the prefix of any other path.\n void checkObjectHasNoAmbiguosPaths(const PathsInData & paths);\n \n /// Receives several Tuple types and deduces the least common type among them.\n-DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths = false);\n+DataTypePtr getLeastCommonTypeForDynamicColumns(\n+    const DataTypePtr & type_in_storage, const DataTypes & types, bool check_ambiguos_paths = false);\n+\n+DataTypePtr createConcreteEmptyDynamicColumn(const DataTypePtr & type_in_storage);\n \n /// Converts types of object columns to tuples in @columns_list\n /// according to @object_columns and adds all tuple's subcolumns if needed.\n void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescription & object_columns, bool with_subcolumns);\n \n-NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list);\n-bool hasObjectColumns(const ColumnsDescription & columns);\n-void finalizeObjectColumns(const MutableColumns & columns);\n+/// Checks whether @columns contain any column with dynamic subcolumns.\n+bool hasDynamicSubcolumns(const ColumnsDescription & columns);\n \n /// Updates types of objects in @object_columns inplace\n /// according to types in new_columns.\n-void updateObjectColumns(ColumnsDescription & object_columns, const NamesAndTypesList & new_columns);\n+void updateObjectColumns(\n+    ColumnsDescription & object_columns,\n+    const ColumnsDescription & storage_columns,\n+    const NamesAndTypesList & new_columns);\n \n using DataTypeTuplePtr = std::shared_ptr<DataTypeTuple>;\n \n@@ -142,13 +146,15 @@ class FieldVisitorFoldDimension : public StaticVisitor<Field>\n     {\n         if (num_dimensions_to_fold == 0)\n             return x;\n-        Array res(1,x);\n+\n+        Array res(1, x);\n         for (size_t i = 1; i < num_dimensions_to_fold; ++i)\n         {\n             Array new_res;\n             new_res.push_back(std::move(res));\n             res = std::move(new_res);\n         }\n+\n         return res;\n     }\n \n@@ -163,7 +169,7 @@ class FieldVisitorFoldDimension : public StaticVisitor<Field>\n /// columns-like objects from entry to which Iterator points.\n /// columns-like object should have fields \"name\" and \"type\".\n template <typename Iterator, typename EntryColumnsGetter>\n-ColumnsDescription getObjectColumns(\n+ColumnsDescription getConcreteObjectColumns(\n     Iterator begin, Iterator end,\n     const ColumnsDescription & storage_columns,\n     EntryColumnsGetter && entry_columns_getter)\n@@ -176,14 +182,8 @@ ColumnsDescription getObjectColumns(\n     /// dummy column will be removed.\n     for (const auto & column : storage_columns)\n     {\n-        if (isObject(column.type))\n-        {\n-            auto tuple_type = std::make_shared<DataTypeTuple>(\n-                DataTypes{std::make_shared<DataTypeUInt8>()},\n-                Names{ColumnObject::COLUMN_NAME_DUMMY});\n-\n-            types_in_entries[column.name].push_back(std::move(tuple_type));\n-        }\n+        if (column.type->hasDynamicSubcolumns())\n+            types_in_entries[column.name].push_back(createConcreteEmptyDynamicColumn(column.type));\n     }\n \n     for (auto it = begin; it != end; ++it)\n@@ -192,14 +192,17 @@ ColumnsDescription getObjectColumns(\n         for (const auto & column : entry_columns)\n         {\n             auto storage_column = storage_columns.tryGetPhysical(column.name);\n-            if (storage_column && isObject(storage_column->type))\n+            if (storage_column && storage_column->type->hasDynamicSubcolumns())\n                 types_in_entries[column.name].push_back(column.type);\n         }\n     }\n \n     ColumnsDescription res;\n     for (const auto & [name, types] : types_in_entries)\n-        res.add({name, getLeastCommonTypeForObject(types)});\n+    {\n+        auto storage_column = storage_columns.getPhysical(name);\n+        res.add({name, getLeastCommonTypeForDynamicColumns(storage_column.type, types)});\n+    }\n \n     return res;\n }\ndiff --git a/src/DataTypes/Serializations/ISerialization.h b/src/DataTypes/Serializations/ISerialization.h\nindex 1193c15b9394..d64b41253f5e 100644\n--- a/src/DataTypes/Serializations/ISerialization.h\n+++ b/src/DataTypes/Serializations/ISerialization.h\n@@ -249,7 +249,9 @@ class ISerialization : private boost::noncopyable, public std::enable_shared_fro\n     };\n \n     /// Call before serializeBinaryBulkWithMultipleStreams chain to write something before first mark.\n+    /// Column may be used only to retrieve the structure.\n     virtual void serializeBinaryBulkStatePrefix(\n+        const IColumn & /*column*/,\n         SerializeBinaryBulkSettings & /*settings*/,\n         SerializeBinaryBulkStatePtr & /*state*/) const {}\n \ndiff --git a/src/DataTypes/Serializations/SerializationArray.cpp b/src/DataTypes/Serializations/SerializationArray.cpp\nindex eb93b5049a01..143a32643817 100644\n--- a/src/DataTypes/Serializations/SerializationArray.cpp\n+++ b/src/DataTypes/Serializations/SerializationArray.cpp\n@@ -246,11 +246,13 @@ void SerializationArray::enumerateStreams(\n }\n \n void SerializationArray::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n     settings.path.push_back(Substream::ArrayElements);\n-    nested->serializeBinaryBulkStatePrefix(settings, state);\n+    const auto & column_array = assert_cast<const ColumnArray &>(column);\n+    nested->serializeBinaryBulkStatePrefix(column_array.getData(), settings, state);\n     settings.path.pop_back();\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationArray.h b/src/DataTypes/Serializations/SerializationArray.h\nindex 84e37acbaad8..860461d667f3 100644\n--- a/src/DataTypes/Serializations/SerializationArray.h\n+++ b/src/DataTypes/Serializations/SerializationArray.h\n@@ -41,6 +41,7 @@ class SerializationArray final : public SimpleTextSerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+            const IColumn & column,\n             SerializeBinaryBulkSettings & settings,\n             SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationLowCardinality.cpp b/src/DataTypes/Serializations/SerializationLowCardinality.cpp\nindex 761adf3b765d..c70bb1e14652 100644\n--- a/src/DataTypes/Serializations/SerializationLowCardinality.cpp\n+++ b/src/DataTypes/Serializations/SerializationLowCardinality.cpp\n@@ -221,6 +221,7 @@ struct DeserializeStateLowCardinality : public ISerialization::DeserializeBinary\n };\n \n void SerializationLowCardinality::serializeBinaryBulkStatePrefix(\n+    const IColumn & /*column*/,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\ndiff --git a/src/DataTypes/Serializations/SerializationLowCardinality.h b/src/DataTypes/Serializations/SerializationLowCardinality.h\nindex cc090f2044e9..1d0c3226faf6 100644\n--- a/src/DataTypes/Serializations/SerializationLowCardinality.h\n+++ b/src/DataTypes/Serializations/SerializationLowCardinality.h\n@@ -23,6 +23,7 @@ class SerializationLowCardinality : public ISerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+            const IColumn & column,\n             SerializeBinaryBulkSettings & settings,\n             SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationMap.cpp b/src/DataTypes/Serializations/SerializationMap.cpp\nindex 958e33fbaf48..cd0a99c0c68c 100644\n--- a/src/DataTypes/Serializations/SerializationMap.cpp\n+++ b/src/DataTypes/Serializations/SerializationMap.cpp\n@@ -270,10 +270,11 @@ void SerializationMap::enumerateStreams(\n }\n \n void SerializationMap::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n-    nested->serializeBinaryBulkStatePrefix(settings, state);\n+    nested->serializeBinaryBulkStatePrefix(extractNestedColumn(column), settings, state);\n }\n \n void SerializationMap::serializeBinaryBulkStateSuffix(\ndiff --git a/src/DataTypes/Serializations/SerializationMap.h b/src/DataTypes/Serializations/SerializationMap.h\nindex 42f99ca7991e..864ac1f3a99e 100644\n--- a/src/DataTypes/Serializations/SerializationMap.h\n+++ b/src/DataTypes/Serializations/SerializationMap.h\n@@ -37,6 +37,7 @@ class SerializationMap final : public SimpleTextSerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationNamed.cpp b/src/DataTypes/Serializations/SerializationNamed.cpp\nindex 4dac4b3a922b..ca60948ce687 100644\n--- a/src/DataTypes/Serializations/SerializationNamed.cpp\n+++ b/src/DataTypes/Serializations/SerializationNamed.cpp\n@@ -17,11 +17,12 @@ void SerializationNamed::enumerateStreams(\n }\n \n void SerializationNamed::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n     addToPath(settings.path);\n-    nested_serialization->serializeBinaryBulkStatePrefix(settings, state);\n+    nested_serialization->serializeBinaryBulkStatePrefix(column, settings, state);\n     settings.path.pop_back();\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationNamed.h b/src/DataTypes/Serializations/SerializationNamed.h\nindex 2a2c7c0dfc71..52bbb0394421 100644\n--- a/src/DataTypes/Serializations/SerializationNamed.h\n+++ b/src/DataTypes/Serializations/SerializationNamed.h\n@@ -31,6 +31,7 @@ class SerializationNamed final : public SerializationWrapper\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationNullable.cpp b/src/DataTypes/Serializations/SerializationNullable.cpp\nindex 560b73bc8278..c46fde27ddbb 100644\n--- a/src/DataTypes/Serializations/SerializationNullable.cpp\n+++ b/src/DataTypes/Serializations/SerializationNullable.cpp\n@@ -70,11 +70,13 @@ void SerializationNullable::enumerateStreams(\n }\n \n void SerializationNullable::serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const\n {\n     settings.path.push_back(Substream::NullableElements);\n-    nested->serializeBinaryBulkStatePrefix(settings, state);\n+    const auto & column_nullable = assert_cast<const ColumnNullable &>(column);\n+    nested->serializeBinaryBulkStatePrefix(column_nullable.getNestedColumn(), settings, state);\n     settings.path.pop_back();\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationNullable.h b/src/DataTypes/Serializations/SerializationNullable.h\nindex ea3958065e7f..9aabbe299cc6 100644\n--- a/src/DataTypes/Serializations/SerializationNullable.h\n+++ b/src/DataTypes/Serializations/SerializationNullable.h\n@@ -19,6 +19,7 @@ class SerializationNullable : public ISerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+            const IColumn & column,\n             SerializeBinaryBulkSettings & settings,\n             SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp\nindex b893407e7a53..98a94886f67d 100644\n--- a/src/DataTypes/Serializations/SerializationObject.cpp\n+++ b/src/DataTypes/Serializations/SerializationObject.cpp\n@@ -13,8 +13,6 @@\n #include <Columns/ColumnString.h>\n #include <Functions/FunctionsConversion.h>\n \n-#include <Common/FieldVisitorToString.h>\n-\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n #include <IO/VarInt.h>\n@@ -30,6 +28,7 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n     extern const int INCORRECT_DATA;\n     extern const int CANNOT_READ_ALL_DATA;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int LOGICAL_ERROR;\n }\n \n@@ -141,7 +140,6 @@ void SerializationObject<Parser>::checkSerializationIsSupported(const TSettings\n template <typename Parser>\n struct SerializationObject<Parser>::SerializeStateObject : public ISerialization::SerializeBinaryBulkState\n {\n-    bool is_first = true;\n     DataTypePtr nested_type;\n     SerializationPtr nested_serialization;\n     SerializeBinaryBulkStatePtr nested_state;\n@@ -158,6 +156,7 @@ struct SerializationObject<Parser>::DeserializeStateObject : public ISerializati\n \n template <typename Parser>\n void SerializationObject<Parser>::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n@@ -166,15 +165,34 @@ void SerializationObject<Parser>::serializeBinaryBulkStatePrefix(\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n             \"DataTypeObject doesn't support serialization with non-trivial state\");\n \n+    const auto & column_object = assert_cast<const ColumnObject &>(column);\n+    if (!column_object.isFinalized())\n+    {\n+        auto finalized = column_object.cloneFinalized();\n+        serializeBinaryBulkStatePrefix(*finalized, settings, state);\n+        return;\n+    }\n+\n     settings.path.push_back(Substream::ObjectStructure);\n     auto * stream = settings.getter(settings.path);\n-    settings.path.pop_back();\n \n     if (!stream)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Missing stream for kind of binary serialization\");\n \n+    auto [tuple_column, tuple_type] = unflattenObjectToTuple(column_object);\n+\n     writeIntBinary(static_cast<UInt8>(BinarySerializationKind::TUPLE), *stream);\n-    state = std::make_shared<SerializeStateObject>();\n+    writeStringBinary(tuple_type->getName(), *stream);\n+\n+    auto state_object = std::make_shared<SerializeStateObject>();\n+    state_object->nested_type = tuple_type;\n+    state_object->nested_serialization = tuple_type->getDefaultSerialization();\n+\n+    settings.path.back() = Substream::ObjectData;\n+    state_object->nested_serialization->serializeBinaryBulkStatePrefix(*tuple_column, settings, state_object->nested_state);\n+\n+    state = std::move(state_object);\n+    settings.path.pop_back();\n }\n \n template <typename Parser>\n@@ -261,33 +279,14 @@ void SerializationObject<Parser>::serializeBinaryBulkWithMultipleStreams(\n \n     if (!column_object.isFinalized())\n     {\n-        auto finalized_object = column_object.clone();\n-        assert_cast<ColumnObject &>(*finalized_object).finalize();\n-        serializeBinaryBulkWithMultipleStreams(*finalized_object, offset, limit, settings, state);\n+        auto finalized = column_object.cloneFinalized();\n+        serializeBinaryBulkWithMultipleStreams(*finalized, offset, limit, settings, state);\n         return;\n     }\n \n     auto [tuple_column, tuple_type] = unflattenObjectToTuple(column_object);\n \n-    if (state_object->is_first)\n-    {\n-        /// Actually it's a part of serializeBinaryBulkStatePrefix,\n-        /// but it cannot be done there, because we have to know the\n-        /// structure of column.\n-\n-        settings.path.push_back(Substream::ObjectStructure);\n-        if (auto * stream = settings.getter(settings.path))\n-            writeStringBinary(tuple_type->getName(), *stream);\n-\n-        state_object->nested_type = tuple_type;\n-        state_object->nested_serialization = tuple_type->getDefaultSerialization();\n-        state_object->is_first = false;\n-\n-        settings.path.back() = Substream::ObjectData;\n-        state_object->nested_serialization->serializeBinaryBulkStatePrefix(settings, state_object->nested_state);\n-        settings.path.pop_back();\n-    }\n-    else if (!state_object->nested_type->equals(*tuple_type))\n+    if (!state_object->nested_type->equals(*tuple_type))\n     {\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"Types of internal column of Object mismatched. Expected: {}, Got: {}\",\n@@ -411,18 +410,63 @@ void SerializationObject<Parser>::serializeTextImpl(const IColumn & column, size\n     writeChar('{', ostr);\n     for (auto it = subcolumns.begin(); it != subcolumns.end(); ++it)\n     {\n+        const auto & entry = *it;\n         if (it != subcolumns.begin())\n             writeCString(\",\", ostr);\n \n-        writeDoubleQuoted((*it)->path.getPath(), ostr);\n+        writeDoubleQuoted(entry->path.getPath(), ostr);\n         writeChar(':', ostr);\n-\n-        auto serialization = (*it)->data.getLeastCommonType()->getDefaultSerialization();\n-        serialization->serializeTextJSON((*it)->data.getFinalizedColumn(), row_num, ostr, settings);\n+        serializeTextFromSubcolumn(entry->data, row_num, ostr, settings);\n     }\n     writeChar('}', ostr);\n }\n \n+template <typename Parser>\n+void SerializationObject<Parser>::serializeTextFromSubcolumn(\n+    const ColumnObject::Subcolumn & subcolumn, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n+{\n+    const auto & least_common_type = subcolumn.getLeastCommonType();\n+\n+    if (subcolumn.isFinalized())\n+    {\n+        const auto & finalized_column = subcolumn.getFinalizedColumn();\n+        auto info = least_common_type->getSerializationInfo(finalized_column);\n+        auto serialization = least_common_type->getSerialization(*info);\n+        serialization->serializeTextJSON(finalized_column, row_num, ostr, settings);\n+        return;\n+    }\n+\n+    size_t ind = row_num;\n+    if (ind < subcolumn.getNumberOfDefaultsInPrefix())\n+    {\n+        /// Suboptimal, but it should happen rarely.\n+        auto tmp_column = subcolumn.getLeastCommonType()->createColumn();\n+        tmp_column->insertDefault();\n+\n+        auto info = least_common_type->getSerializationInfo(*tmp_column);\n+        auto serialization = least_common_type->getSerialization(*info);\n+        serialization->serializeTextJSON(*tmp_column, 0, ostr, settings);\n+        return;\n+    }\n+\n+    ind -= subcolumn.getNumberOfDefaultsInPrefix();\n+    for (const auto & part : subcolumn.getData())\n+    {\n+        if (ind < part->size())\n+        {\n+            auto part_type = getDataTypeByColumn(*part);\n+            auto info = part_type->getSerializationInfo(*part);\n+            auto serialization = part_type->getSerialization(*info);\n+            serialization->serializeTextJSON(*part, ind, ostr, settings);\n+            return;\n+        }\n+\n+        ind -= part->size();\n+    }\n+\n+    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Index ({}) for text serialization is out of range\", row_num);\n+}\n+\n template <typename Parser>\n void SerializationObject<Parser>::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n {\ndiff --git a/src/DataTypes/Serializations/SerializationObject.h b/src/DataTypes/Serializations/SerializationObject.h\nindex ff72c84faaa4..47a7127cd1c6 100644\n--- a/src/DataTypes/Serializations/SerializationObject.h\n+++ b/src/DataTypes/Serializations/SerializationObject.h\n@@ -8,7 +8,7 @@ namespace DB\n {\n \n /** Serialization for data type Object.\n-  * Supported only test serialization/deserialization.\n+  * Supported only text serialization/deserialization.\n   * and binary bulk serialization/deserialization without position independent\n   * encoding, i.e. serialization/deserialization into Native format.\n   */\n@@ -31,6 +31,7 @@ class SerializationObject : public ISerialization\n       */\n \n     void serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const override;\n \n@@ -104,6 +105,7 @@ class SerializationObject : public ISerialization\n     void deserializeTextImpl(IColumn & column, Reader && reader) const;\n \n     void serializeTextImpl(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const;\n+    void serializeTextFromSubcolumn(const ColumnObject::Subcolumn & subcolumn, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const;\n \n     /// Pool of parser objects to make SerializationObject thread safe.\n     mutable SimpleObjectPool<Parser> parsers_pool;\ndiff --git a/src/DataTypes/Serializations/SerializationSparse.cpp b/src/DataTypes/Serializations/SerializationSparse.cpp\nindex 855bdfa1b3e6..cd09cd7be5a1 100644\n--- a/src/DataTypes/Serializations/SerializationSparse.cpp\n+++ b/src/DataTypes/Serializations/SerializationSparse.cpp\n@@ -178,11 +178,16 @@ void SerializationSparse::enumerateStreams(\n }\n \n void SerializationSparse::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n     settings.path.push_back(Substream::SparseElements);\n-    nested->serializeBinaryBulkStatePrefix(settings, state);\n+    if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(&column))\n+        nested->serializeBinaryBulkStatePrefix(column_sparse->getValuesColumn(), settings, state);\n+    else\n+        nested->serializeBinaryBulkStatePrefix(column, settings, state);\n+\n     settings.path.pop_back();\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationSparse.h b/src/DataTypes/Serializations/SerializationSparse.h\nindex dc2f63c5a054..c157fe7ce98d 100644\n--- a/src/DataTypes/Serializations/SerializationSparse.h\n+++ b/src/DataTypes/Serializations/SerializationSparse.h\n@@ -33,6 +33,7 @@ class SerializationSparse final : public ISerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationTuple.cpp b/src/DataTypes/Serializations/SerializationTuple.cpp\nindex c2c40cbb5078..8ffb1fe86bcf 100644\n--- a/src/DataTypes/Serializations/SerializationTuple.cpp\n+++ b/src/DataTypes/Serializations/SerializationTuple.cpp\n@@ -314,6 +314,7 @@ struct DeserializeBinaryBulkStateTuple : public ISerialization::DeserializeBinar\n \n \n void SerializationTuple::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n@@ -321,7 +322,7 @@ void SerializationTuple::serializeBinaryBulkStatePrefix(\n     tuple_state->states.resize(elems.size());\n \n     for (size_t i = 0; i < elems.size(); ++i)\n-        elems[i]->serializeBinaryBulkStatePrefix(settings, tuple_state->states[i]);\n+        elems[i]->serializeBinaryBulkStatePrefix(extractElementColumn(column, i), settings, tuple_state->states[i]);\n \n     state = std::move(tuple_state);\n }\ndiff --git a/src/DataTypes/Serializations/SerializationTuple.h b/src/DataTypes/Serializations/SerializationTuple.h\nindex d1caeb73dadb..db0339bc996d 100644\n--- a/src/DataTypes/Serializations/SerializationTuple.h\n+++ b/src/DataTypes/Serializations/SerializationTuple.h\n@@ -39,6 +39,7 @@ class SerializationTuple final : public SimpleTextSerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+            const IColumn & column,\n             SerializeBinaryBulkSettings & settings,\n             SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/DataTypes/Serializations/SerializationWrapper.cpp b/src/DataTypes/Serializations/SerializationWrapper.cpp\nindex 7c50c1c6e26f..c83de6147518 100644\n--- a/src/DataTypes/Serializations/SerializationWrapper.cpp\n+++ b/src/DataTypes/Serializations/SerializationWrapper.cpp\n@@ -13,10 +13,11 @@ void SerializationWrapper::enumerateStreams(\n }\n \n void SerializationWrapper::serializeBinaryBulkStatePrefix(\n+    const IColumn & column,\n     SerializeBinaryBulkSettings & settings,\n     SerializeBinaryBulkStatePtr & state) const\n {\n-    nested_serialization->serializeBinaryBulkStatePrefix(settings, state);\n+    nested_serialization->serializeBinaryBulkStatePrefix(column, settings, state);\n }\n \n void SerializationWrapper::serializeBinaryBulkStateSuffix(\ndiff --git a/src/DataTypes/Serializations/SerializationWrapper.h b/src/DataTypes/Serializations/SerializationWrapper.h\nindex d010c6b53149..46941f150e12 100644\n--- a/src/DataTypes/Serializations/SerializationWrapper.h\n+++ b/src/DataTypes/Serializations/SerializationWrapper.h\n@@ -26,6 +26,7 @@ class SerializationWrapper : public ISerialization\n         const SubstreamData & data) const override;\n \n     void serializeBinaryBulkStatePrefix(\n+        const IColumn & column,\n         SerializeBinaryBulkSettings & settings,\n         SerializeBinaryBulkStatePtr & state) const override;\n \ndiff --git a/src/Formats/NativeWriter.cpp b/src/Formats/NativeWriter.cpp\nindex 0cae2a2e7891..c4dea371afd1 100644\n--- a/src/Formats/NativeWriter.cpp\n+++ b/src/Formats/NativeWriter.cpp\n@@ -58,7 +58,7 @@ static void writeData(const ISerialization & serialization, const ColumnPtr & co\n     settings.low_cardinality_max_dictionary_size = 0; //-V1048\n \n     ISerialization::SerializeBinaryBulkStatePtr state;\n-    serialization.serializeBinaryBulkStatePrefix(settings, state);\n+    serialization.serializeBinaryBulkStatePrefix(*full_column, settings, state);\n     serialization.serializeBinaryBulkWithMultipleStreams(*full_column, offset, limit, settings, state);\n     serialization.serializeBinaryBulkStateSuffix(settings, state);\n }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 3a69ba43642d..dd494d821bfa 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -3360,9 +3360,8 @@ class FunctionCast final : public FunctionCastBase\n         {\n             return [] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)\n             {\n-                auto res = ConvertImplGenericFromString<ColumnString>::execute(arguments, result_type, nullable_source, input_rows_count);\n-                auto & res_object = assert_cast<ColumnObject &>(res->assumeMutableRef());\n-                res_object.finalize();\n+                auto res = ConvertImplGenericFromString<ColumnString>::execute(arguments, result_type, nullable_source, input_rows_count)->assumeMutable();\n+                res->finalize();\n                 return res;\n             };\n         }\ndiff --git a/src/Functions/blockSerializedSize.cpp b/src/Functions/blockSerializedSize.cpp\nindex d406984c51c2..35be65f3fed8 100644\n--- a/src/Functions/blockSerializedSize.cpp\n+++ b/src/Functions/blockSerializedSize.cpp\n@@ -54,7 +54,7 @@ class FunctionBlockSerializedSize : public IFunction\n \n         auto serialization = elem.type->getDefaultSerialization();\n \n-        serialization->serializeBinaryBulkStatePrefix(settings, state);\n+        serialization->serializeBinaryBulkStatePrefix(*full_column, settings, state);\n         serialization->serializeBinaryBulkWithMultipleStreams(*full_column,\n             0 /** offset */, 0 /** limit */,\n             settings, state);\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex f41ae31b2396..4a6ce63eb84f 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -829,7 +829,7 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat\n     {\n         for (const auto & [name, type] : properties.columns.getAllPhysical())\n         {\n-            if (isObject(type))\n+            if (type->hasDynamicSubcolumns())\n             {\n                 throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n                     \"Cannot create table with column '{}' which type is '{}' \"\n@@ -1398,7 +1398,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     /// we can safely destroy the object without a call to \"shutdown\", because there is guarantee\n     /// that no background threads/similar resources remain after exception from \"startup\".\n \n-    if (!res->supportsDynamicSubcolumns() && hasObjectColumns(res->getInMemoryMetadataPtr()->getColumns()))\n+    if (!res->supportsDynamicSubcolumns() && hasDynamicSubcolumns(res->getInMemoryMetadataPtr()->getColumns()))\n     {\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n             \"Cannot create table with column of type Object, \"\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex 524e5d364033..e57016d969a0 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -387,6 +387,9 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n     }\n     else if (isObject(type))\n     {\n+        if (src.getType() == Field::Types::Object)\n+            return src;  /// Already in needed type.\n+\n         const auto * from_type_tuple = typeid_cast<const DataTypeTuple *>(from_type_hint);\n         if (src.getType() == Field::Types::Tuple && from_type_tuple && from_type_tuple->haveExplicitNames())\n         {\ndiff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex abd91ddcf35d..6f153019df5a 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -232,7 +232,9 @@ Chunk IRowInputFormat::generate()\n         return {};\n     }\n \n-    finalizeObjectColumns(columns);\n+    for (const auto & column : columns)\n+        column->finalize();\n+\n     Chunk chunk(std::move(columns), num_rows);\n     return chunk;\n }\ndiff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex 72e89ea00138..108b4203e3ed 100644\n--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -101,7 +101,9 @@ Chunk ValuesBlockInputFormat::generate()\n         return {};\n     }\n \n-    finalizeObjectColumns(columns);\n+    for (const auto & column : columns)\n+        column->finalize();\n+\n     size_t rows_in_block = columns[0]->size();\n     return Chunk{std::move(columns), rows_in_block};\n }\ndiff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp\nindex 98f05ade18d8..0b6fe23e9616 100644\n--- a/src/Storages/MergeTree/MergeTask.cpp\n+++ b/src/Storages/MergeTree/MergeTask.cpp\n@@ -153,7 +153,7 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()\n     global_ctx->all_column_names = global_ctx->metadata_snapshot->getColumns().getNamesOfPhysical();\n     global_ctx->storage_columns = global_ctx->metadata_snapshot->getColumns().getAllPhysical();\n \n-    auto object_columns = MergeTreeData::getObjectColumns(global_ctx->future_part->parts, global_ctx->metadata_snapshot->getColumns());\n+    auto object_columns = MergeTreeData::getConcreteObjectColumns(global_ctx->future_part->parts, global_ctx->metadata_snapshot->getColumns());\n     global_ctx->storage_snapshot = std::make_shared<StorageSnapshot>(*global_ctx->data, global_ctx->metadata_snapshot, object_columns);\n     extendObjectColumns(global_ctx->storage_columns, object_columns, false);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex a9e726f25fdb..83e87a0e462d 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -7124,18 +7124,18 @@ ReservationPtr MergeTreeData::balancedReservation(\n     return reserved_space;\n }\n \n-ColumnsDescription MergeTreeData::getObjectColumns(\n+ColumnsDescription MergeTreeData::getConcreteObjectColumns(\n     const DataPartsVector & parts, const ColumnsDescription & storage_columns)\n {\n-    return DB::getObjectColumns(\n+    return DB::getConcreteObjectColumns(\n         parts.begin(), parts.end(),\n         storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });\n }\n \n-ColumnsDescription MergeTreeData::getObjectColumns(\n+ColumnsDescription MergeTreeData::getConcreteObjectColumns(\n     boost::iterator_range<DataPartIteratorByStateAndInfo> range, const ColumnsDescription & storage_columns)\n {\n-    return DB::getObjectColumns(\n+    return DB::getConcreteObjectColumns(\n         range.begin(), range.end(),\n         storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });\n }\n@@ -7144,21 +7144,21 @@ void MergeTreeData::resetObjectColumnsFromActiveParts(const DataPartsLock & /*lo\n {\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     const auto & columns = metadata_snapshot->getColumns();\n-    if (!hasObjectColumns(columns))\n+    if (!hasDynamicSubcolumns(columns))\n         return;\n \n     auto range = getDataPartsStateRange(DataPartState::Active);\n-    object_columns = getObjectColumns(range, columns);\n+    object_columns = getConcreteObjectColumns(range, columns);\n }\n \n void MergeTreeData::updateObjectColumns(const DataPartPtr & part, const DataPartsLock & /*lock*/)\n {\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     const auto & columns = metadata_snapshot->getColumns();\n-    if (!hasObjectColumns(columns))\n+    if (!hasDynamicSubcolumns(columns))\n         return;\n \n-    DB::updateObjectColumns(object_columns, part->getColumns());\n+    DB::updateObjectColumns(object_columns, columns, part->getColumns());\n }\n \n StorageSnapshotPtr MergeTreeData::getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr query_context) const\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 99ba6991e430..8bd0fc1f2807 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -779,10 +779,10 @@ class MergeTreeData : public IStorage, public WithMutableContext\n         return column_sizes;\n     }\n \n-    const ColumnsDescription & getObjectColumns() const { return object_columns; }\n+    const ColumnsDescription & getConcreteObjectColumns() const { return object_columns; }\n \n     /// Creates description of columns of data type Object from the range of data parts.\n-    static ColumnsDescription getObjectColumns(\n+    static ColumnsDescription getConcreteObjectColumns(\n         const DataPartsVector & parts, const ColumnsDescription & storage_columns);\n \n     IndexSizeByName getSecondaryIndexSizes() const override\n@@ -1151,7 +1151,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     }\n \n     /// Creates description of columns of data type Object from the range of data parts.\n-    static ColumnsDescription getObjectColumns(\n+    static ColumnsDescription getConcreteObjectColumns(\n         boost::iterator_range<DataPartIteratorByStateAndInfo> range, const ColumnsDescription & storage_columns);\n \n     std::optional<UInt64> totalRowsByPartitionPredicateImpl(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\nindex c9f3c3b5101f..020121e59d79 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n@@ -131,7 +131,7 @@ void writeColumnSingleGranule(\n     serialize_settings.position_independent_encoding = true; //-V1048\n     serialize_settings.low_cardinality_max_dictionary_size = 0; //-V1048\n \n-    serialization->serializeBinaryBulkStatePrefix(serialize_settings, state);\n+    serialization->serializeBinaryBulkStatePrefix(*column.column, serialize_settings, state);\n     serialization->serializeBinaryBulkWithMultipleStreams(*column.column, from_row, number_of_rows, serialize_settings, state);\n     serialization->serializeBinaryBulkStateSuffix(serialize_settings, state);\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\nindex f48b350a981b..62917bcb084c 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n@@ -355,7 +355,7 @@ void MergeTreeDataPartWriterWide::writeColumn(\n     {\n         ISerialization::SerializeBinaryBulkSettings serialize_settings;\n         serialize_settings.getter = createStreamGetter(name_and_type, offset_columns);\n-        serialization->serializeBinaryBulkStatePrefix(serialize_settings, it->second);\n+        serialization->serializeBinaryBulkStatePrefix(column, serialize_settings, it->second);\n     }\n \n     const auto & global_settings = storage.getContext()->getSettingsRef();\ndiff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex 55404324b751..b8f9b6cced4e 100644\n--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -288,7 +288,7 @@ MergeTreeDataWriter::TemporaryPart MergeTreeDataWriter::writeTempPart(\n     auto columns = metadata_snapshot->getColumns().getAllPhysical().filter(block.getNames());\n \n     for (auto & column : columns)\n-        if (isObject(column.type))\n+        if (column.type->hasDynamicSubcolumns())\n             column.type = block.getByName(column.name).type;\n \n     static const String TMP_PREFIX = \"tmp_insert_\";\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexSet.cpp b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\nindex 3c31deda8234..0e15f2c4cb62 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n@@ -74,8 +74,9 @@ void MergeTreeIndexGranuleSet::serializeBinary(WriteBuffer & ostr) const\n         auto serialization = type->getDefaultSerialization();\n         ISerialization::SerializeBinaryBulkStatePtr state;\n \n-        serialization->serializeBinaryBulkStatePrefix(settings, state);\n-        serialization->serializeBinaryBulkWithMultipleStreams(*block.getByPosition(i).column, 0, size(), settings, state);\n+        const auto & column = *block.getByPosition(i).column;\n+        serialization->serializeBinaryBulkStatePrefix(column, settings, state);\n+        serialization->serializeBinaryBulkWithMultipleStreams(column, 0, size(), settings, state);\n         serialization->serializeBinaryBulkStateSuffix(settings, state);\n     }\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeSink.cpp b/src/Storages/MergeTree/MergeTreeSink.cpp\nindex a7ddb9d9e1d6..13a72c24c594 100644\n--- a/src/Storages/MergeTree/MergeTreeSink.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSink.cpp\n@@ -1,8 +1,8 @@\n #include <Storages/MergeTree/MergeTreeSink.h>\n #include <Storages/MergeTree/MergeTreeDataPartInMemory.h>\n #include <Storages/StorageMergeTree.h>\n-#include <DataTypes/ObjectUtils.h>\n #include <Interpreters/PartLog.h>\n+#include <DataTypes/ObjectUtils.h>\n \n namespace ProfileEvents\n {\n@@ -56,8 +56,9 @@ struct MergeTreeSink::DelayedChunk\n void MergeTreeSink::consume(Chunk chunk)\n {\n     auto block = getHeader().cloneWithColumns(chunk.detachColumns());\n+    if (!storage_snapshot->object_columns.empty())\n+        convertDynamicColumnsToTuples(block, storage_snapshot);\n \n-    deduceTypesOfObjectColumns(storage_snapshot, block);\n     auto part_blocks = storage.writer.splitBlockIntoParts(block, max_parts_per_block, metadata_snapshot, context);\n \n     using DelayedPartitions = std::vector<MergeTreeSink::DelayedChunk::Partition>;\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\nindex 082228d7ebf9..dbc2bd98e203 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n@@ -1,10 +1,10 @@\n #include <Storages/StorageReplicatedMergeTree.h>\n #include <Storages/MergeTree/ReplicatedMergeTreeQuorumEntry.h>\n #include <Storages/MergeTree/ReplicatedMergeTreeSink.h>\n-#include <DataTypes/ObjectUtils.h>\n #include <Interpreters/PartLog.h>\n #include <Common/SipHash.h>\n #include <Common/ZooKeeper/KeeperException.h>\n+#include <DataTypes/ObjectUtils.h>\n #include <Core/Block.h>\n #include <IO/Operators.h>\n \n@@ -165,7 +165,9 @@ void ReplicatedMergeTreeSink::consume(Chunk chunk)\n       */\n     size_t replicas_num = checkQuorumPrecondition(zookeeper);\n \n-    deduceTypesOfObjectColumns(storage_snapshot, block);\n+    if (!storage_snapshot->object_columns.empty())\n+        convertDynamicColumnsToTuples(block, storage_snapshot);\n+\n     auto part_blocks = storage.writer.splitBlockIntoParts(block, max_parts_per_block, metadata_snapshot, context);\n \n     using DelayedPartitions = std::vector<ReplicatedMergeTreeSink::DelayedChunk::Partition>;\ndiff --git a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\nindex a3d578cf5f2d..7bad9947a886 100644\n--- a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n@@ -47,10 +47,10 @@ class StorageFromMergeTreeDataPart final : public IStorage\n         const StorageMetadataPtr & metadata_snapshot, ContextPtr /*query_context*/) const override\n     {\n         const auto & storage_columns = metadata_snapshot->getColumns();\n-        if (!hasObjectColumns(storage_columns))\n+        if (!hasDynamicSubcolumns(storage_columns))\n             return std::make_shared<StorageSnapshot>(*this, metadata_snapshot);\n \n-        auto object_columns = getObjectColumns(\n+        auto object_columns = getConcreteObjectColumns(\n             parts.begin(), parts.end(),\n             storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });\n \ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex 8e4715db483d..f7f68eba30fb 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -598,7 +598,7 @@ std::optional<QueryProcessingStage::Enum> StorageDistributed::getOptimizedQueryP\n \n static bool requiresObjectColumns(const ColumnsDescription & all_columns, ASTPtr query)\n {\n-    if (!hasObjectColumns(all_columns))\n+    if (!hasDynamicSubcolumns(all_columns))\n         return false;\n \n     if (!query)\n@@ -613,7 +613,7 @@ static bool requiresObjectColumns(const ColumnsDescription & all_columns, ASTPtr\n         auto name_in_storage = Nested::splitName(required_column).first;\n         auto column_in_storage = all_columns.tryGetPhysical(name_in_storage);\n \n-        if (column_in_storage && isObject(column_in_storage->type))\n+        if (column_in_storage && column_in_storage->type->hasDynamicSubcolumns())\n             return true;\n     }\n \n@@ -640,7 +640,7 @@ StorageSnapshotPtr StorageDistributed::getStorageSnapshotForQuery(\n         metadata_snapshot->getColumns(),\n         getContext());\n \n-    auto object_columns = DB::getObjectColumns(\n+    auto object_columns = DB::getConcreteObjectColumns(\n         snapshot_data->objects_by_shard.begin(),\n         snapshot_data->objects_by_shard.end(),\n         metadata_snapshot->getColumns(),\ndiff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp\nindex 66dcc938aefe..a80f21834db2 100644\n--- a/src/Storages/StorageInMemoryMetadata.cpp\n+++ b/src/Storages/StorageInMemoryMetadata.cpp\n@@ -526,7 +526,7 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns)\n \n         const auto * available_type = it->getMapped();\n \n-        if (!isObject(*available_type)\n+        if (!available_type->hasDynamicSubcolumns()\n             && !column.type->equals(*available_type)\n             && !isCompatibleEnumTypes(available_type, column.type.get()))\n             throw Exception(\n@@ -575,7 +575,7 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns,\n         const auto * provided_column_type = it->getMapped();\n         const auto * available_column_type = jt->getMapped();\n \n-        if (!isObject(*provided_column_type)\n+        if (!provided_column_type->hasDynamicSubcolumns()\n             && !provided_column_type->equals(*available_column_type)\n             && !isCompatibleEnumTypes(available_column_type, provided_column_type))\n             throw Exception(\n@@ -619,7 +619,7 @@ void StorageInMemoryMetadata::check(const Block & block, bool need_all) const\n                 listOfColumns(available_columns));\n \n         const auto * available_type = it->getMapped();\n-        if (!isObject(*available_type)\n+        if (!available_type->hasDynamicSubcolumns()\n             && !column.type->equals(*available_type)\n             && !isCompatibleEnumTypes(available_type, column.type.get()))\n             throw Exception(\ndiff --git a/src/Storages/StorageLog.cpp b/src/Storages/StorageLog.cpp\nindex 9909489d901a..8ed33220507c 100644\n--- a/src/Storages/StorageLog.cpp\n+++ b/src/Storages/StorageLog.cpp\n@@ -462,7 +462,7 @@ void LogSink::writeData(const NameAndTypePair & name_and_type, const IColumn & c\n     settings.getter = createStreamGetter(name_and_type);\n \n     if (!serialize_states.contains(name))\n-         serialization->serializeBinaryBulkStatePrefix(settings, serialize_states[name]);\n+         serialization->serializeBinaryBulkStatePrefix(column, settings, serialize_states[name]);\n \n     if (storage.use_marks_file)\n     {\ndiff --git a/src/Storages/StorageMemory.cpp b/src/Storages/StorageMemory.cpp\nindex 957aae450c8b..881cbc18b10f 100644\n--- a/src/Storages/StorageMemory.cpp\n+++ b/src/Storages/StorageMemory.cpp\n@@ -146,7 +146,7 @@ class MemorySink : public SinkToStorage\n             auto extended_storage_columns = storage_snapshot->getColumns(\n                 GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects());\n \n-            convertObjectsToTuples(block, extended_storage_columns);\n+            convertDynamicColumnsToTuples(block, storage_snapshot);\n         }\n \n         if (storage.compress)\n@@ -212,10 +212,10 @@ StorageSnapshotPtr StorageMemory::getStorageSnapshot(const StorageMetadataPtr &\n     auto snapshot_data = std::make_unique<SnapshotData>();\n     snapshot_data->blocks = data.get();\n \n-    if (!hasObjectColumns(metadata_snapshot->getColumns()))\n+    if (!hasDynamicSubcolumns(metadata_snapshot->getColumns()))\n         return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, ColumnsDescription{}, std::move(snapshot_data));\n \n-    auto object_columns = getObjectColumns(\n+    auto object_columns = getConcreteObjectColumns(\n         snapshot_data->blocks->begin(),\n         snapshot_data->blocks->end(),\n         metadata_snapshot->getColumns(),\ndiff --git a/src/Storages/StorageSnapshot.cpp b/src/Storages/StorageSnapshot.cpp\nindex a99fec8c154a..48851f0974dc 100644\n--- a/src/Storages/StorageSnapshot.cpp\n+++ b/src/Storages/StorageSnapshot.cpp\n@@ -76,7 +76,7 @@ std::optional<NameAndTypePair> StorageSnapshot::tryGetColumn(const GetColumnsOpt\n {\n     const auto & columns = getMetadataForQuery()->getColumns();\n     auto column = columns.tryGetColumn(options, column_name);\n-    if (column && (!isObject(column->type) || !options.with_extended_objects))\n+    if (column && (!column->type->hasDynamicSubcolumns() || !options.with_extended_objects))\n         return column;\n \n     if (options.with_extended_objects)\ndiff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp\nindex a93a480adb0d..7bd5e629c399 100644\n--- a/src/Storages/getStructureOfRemoteTable.cpp\n+++ b/src/Storages/getStructureOfRemoteTable.cpp\n@@ -200,7 +200,7 @@ ColumnsDescriptionByShardNum getExtendedObjectsOfRemoteTables(\n                 auto type_name = type_col[i].get<const String &>();\n \n                 auto storage_column = storage_columns.tryGetPhysical(name);\n-                if (storage_column && isObject(storage_column->type))\n+                if (storage_column && storage_column->type->hasDynamicSubcolumns())\n                     res.add(ColumnDescription(std::move(name), DataTypeFactory::instance().get(type_name)));\n             }\n         }\n",
  "test_patch": "diff --git a/src/DataTypes/Serializations/tests/gtest_object_serialization.cpp b/src/DataTypes/Serializations/tests/gtest_object_serialization.cpp\nindex f1fbbe115e21..fc7432d5bf64 100644\n--- a/src/DataTypes/Serializations/tests/gtest_object_serialization.cpp\n+++ b/src/DataTypes/Serializations/tests/gtest_object_serialization.cpp\n@@ -31,7 +31,7 @@ TEST(SerializationObject, FromString)\n         settings.getter = [&out](const auto &) { return &out; };\n \n         writeIntBinary(static_cast<UInt8>(1), out);\n-        serialization->serializeBinaryBulkStatePrefix(settings, state);\n+        serialization->serializeBinaryBulkStatePrefix(*column_string, settings, state);\n         serialization->serializeBinaryBulkWithMultipleStreams(*column_string, 0, column_string->size(), settings, state);\n         serialization->serializeBinaryBulkStateSuffix(settings, state);\n     }\ndiff --git a/tests/queries/0_stateless/01825_type_json_in_array.reference b/tests/queries/0_stateless/01825_type_json_in_array.reference\nnew file mode 100644\nindex 000000000000..c36a22e6951f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01825_type_json_in_array.reference\n@@ -0,0 +1,23 @@\n+{\"id\":1,\"arr\":[{\"k1\":1,\"k2\":{\"k3\":2,\"k4\":3,\"k5\":\"\"}},{\"k1\":2,\"k2\":{\"k3\":0,\"k4\":0,\"k5\":\"foo\"}}]}\n+{\"id\":2,\"arr\":[{\"k1\":3,\"k2\":{\"k3\":4,\"k4\":5,\"k5\":\"\"}}]}\n+1\t[1,2]\t[2,0]\t[3,0]\t['','foo']\n+2\t[3]\t[4]\t[5]\t['']\n+{\"arr\":{\"k1\":1,\"k2\":{\"k3\":2,\"k4\":3,\"k5\":\"\"}}}\n+{\"arr\":{\"k1\":2,\"k2\":{\"k3\":0,\"k4\":0,\"k5\":\"foo\"}}}\n+{\"arr\":{\"k1\":3,\"k2\":{\"k3\":4,\"k4\":5,\"k5\":\"\"}}}\n+Array(Tuple(k1 Int8, k2 Tuple(k3 Int8, k4 Int8, k5 String)))\n+{\"id\":1,\"arr\":[{\"k1\":[{\"k2\":\"aaa\",\"k3\":\"bbb\",\"k4\":0},{\"k2\":\"ccc\",\"k3\":\"\",\"k4\":0}],\"k5\":{\"k6\":\"\"}}]}\n+{\"id\":2,\"arr\":[{\"k1\":[{\"k2\":\"\",\"k3\":\"ddd\",\"k4\":10},{\"k2\":\"\",\"k3\":\"\",\"k4\":20}],\"k5\":{\"k6\":\"foo\"}}]}\n+1\t[['aaa','ccc']]\t[['bbb','']]\t[[0,0]]\t['']\n+2\t[['','']]\t[['ddd','']]\t[[10,20]]\t['foo']\n+{\"k1\":{\"k2\":\"\",\"k3\":\"\",\"k4\":20}}\n+{\"k1\":{\"k2\":\"\",\"k3\":\"ddd\",\"k4\":10}}\n+{\"k1\":{\"k2\":\"aaa\",\"k3\":\"bbb\",\"k4\":0}}\n+{\"k1\":{\"k2\":\"ccc\",\"k3\":\"\",\"k4\":0}}\n+Tuple(k2 String, k3 String, k4 Int8)\n+{\"arr\":[{\"x\":1}]}\n+{\"arr\":{\"x\":{\"y\":1},\"t\":{\"y\":2}}}\n+{\"arr\":[1,{\"y\":1}]}\n+{\"arr\":[2,{\"y\":2}]}\n+{\"arr\":[{\"x\":\"aaa\",\"y\":[1,2,3]}]}\n+{\"arr\":[{\"x\":1}]}\ndiff --git a/tests/queries/0_stateless/01825_type_json_in_array.sql b/tests/queries/0_stateless/01825_type_json_in_array.sql\nnew file mode 100644\nindex 000000000000..e5c20d7ba6b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01825_type_json_in_array.sql\n@@ -0,0 +1,35 @@\n+-- Tags: no-fasttest\n+\n+SET allow_experimental_object_type = 1;\n+DROP TABLE IF EXISTS t_json_array;\n+\n+CREATE TABLE t_json_array (id UInt32, arr Array(JSON)) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_json_array FORMAT JSONEachRow {\"id\": 1, \"arr\": [{\"k1\": 1, \"k2\": {\"k3\": 2, \"k4\": 3}}, {\"k1\": 2, \"k2\": {\"k5\": \"foo\"}}]}\n+INSERT INTO t_json_array FORMAT JSONEachRow {\"id\": 2, \"arr\": [{\"k1\": 3, \"k2\": {\"k3\": 4, \"k4\": 5}}]}\n+\n+SET output_format_json_named_tuples_as_objects = 1;\n+\n+SELECT * FROM t_json_array ORDER BY id FORMAT JSONEachRow;\n+SELECT id, arr.k1, arr.k2.k3, arr.k2.k4, arr.k2.k5 FROM t_json_array ORDER BY id;\n+SELECT arr FROM t_json_array ARRAY JOIN arr ORDER BY arr.k1 FORMAT JSONEachRow;\n+SELECT toTypeName(arr) FROM t_json_array LIMIT 1;\n+\n+TRUNCATE TABLE t_json_array;\n+\n+INSERT INTO t_json_array FORMAT JSONEachRow {\"id\": 1, \"arr\": [{\"k1\": [{\"k2\": \"aaa\", \"k3\": \"bbb\"}, {\"k2\": \"ccc\"}]}]}\n+INSERT INTO t_json_array FORMAT JSONEachRow {\"id\": 2, \"arr\": [{\"k1\": [{\"k3\": \"ddd\", \"k4\": 10}, {\"k4\": 20}], \"k5\": {\"k6\": \"foo\"}}]}\n+\n+SELECT * FROM t_json_array ORDER BY id FORMAT JSONEachRow;\n+SELECT id, arr.k1.k2, arr.k1.k3, arr.k1.k4, arr.k5.k6 FROM t_json_array ORDER BY id;\n+\n+SELECT arrayJoin(arrayJoin(arr.k1)) AS k1 FROM t_json_array ORDER BY k1 FORMAT JSONEachRow;\n+SELECT toTypeName(arrayJoin(arrayJoin(arr.k1))) AS arr FROM t_json_array LIMIT 1;\n+\n+DROP TABLE t_json_array;\n+\n+SELECT * FROM values('arr Array(JSON)', '[\\'{\"x\" : 1}\\']') FORMAT JSONEachRow;\n+SELECT * FROM values('arr Map(String, JSON)', '{\\'x\\' : \\'{\"y\" : 1}\\', \\'t\\' : \\'{\"y\" : 2}\\'}') FORMAT JSONEachRow;\n+SELECT * FROM values('arr Tuple(Int32, JSON)', '(1, \\'{\"y\" : 1}\\')', '(2, \\'{\"y\" : 2}\\')') FORMAT JSONEachRow;\n+SELECT * FROM format(JSONEachRow, '{\"arr\" : [{\"x\" : \"aaa\", \"y\" : [1,2,3]}]}') FORMAT JSONEachRow;\n+SELECT * FROM values('arr Array(JSON)', '[\\'{\"x\" : 1}\\']') FORMAT JSONEachRow;\ndiff --git a/tests/queries/0_stateless/01825_type_json_in_other_types.reference b/tests/queries/0_stateless/01825_type_json_in_other_types.reference\nnew file mode 100644\nindex 000000000000..b94885a65ab4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01825_type_json_in_other_types.reference\n@@ -0,0 +1,17 @@\n+Tuple(String, Map(String, Array(Tuple(k1 Nested(k2 Int8, k3 Int8, k5 String), k4 String))), Tuple(k1 String, k2 Tuple(k3 String, k4 String)))\n+=============\n+{\"id\":1,\"data\":[\"foo\",{\"aa\":[{\"k1\":[{\"k2\":1,\"k3\":2,\"k5\":\"\"},{\"k2\":0,\"k3\":3,\"k5\":\"\"}],\"k4\":\"\"},{\"k1\":[{\"k2\":4,\"k3\":0,\"k5\":\"\"},{\"k2\":0,\"k3\":5,\"k5\":\"\"},{\"k2\":6,\"k3\":0,\"k5\":\"\"}],\"k4\":\"qqq\"}],\"bb\":[{\"k1\":[],\"k4\":\"www\"},{\"k1\":[{\"k2\":7,\"k3\":8,\"k5\":\"\"},{\"k2\":9,\"k3\":10,\"k5\":\"\"},{\"k2\":11,\"k3\":12,\"k5\":\"\"}],\"k4\":\"\"}]},{\"k1\":\"aa\",\"k2\":{\"k3\":\"bb\",\"k4\":\"c\"}}]}\n+{\"id\":2,\"data\":[\"bar\",{\"aa\":[{\"k1\":[{\"k2\":13,\"k3\":14,\"k5\":\"\"},{\"k2\":15,\"k3\":16,\"k5\":\"\"}],\"k4\":\"www\"}]},{\"k1\":\"\",\"k2\":{\"k3\":\"\",\"k4\":\"\"}}]}\n+{\"id\":3,\"data\":[\"some\",{\"aa\":[{\"k1\":[{\"k2\":0,\"k3\":20,\"k5\":\"some\"}],\"k4\":\"\"}]},{\"k1\":\"eee\",\"k2\":{\"k3\":\"\",\"k4\":\"\"}}]}\n+=============\n+{\"aa\":[{\"k1\":[{\"k2\":1,\"k3\":2,\"k5\":\"\"},{\"k2\":0,\"k3\":3,\"k5\":\"\"}],\"k4\":\"\"},{\"k1\":[{\"k2\":4,\"k3\":0,\"k5\":\"\"},{\"k2\":0,\"k3\":5,\"k5\":\"\"},{\"k2\":6,\"k3\":0,\"k5\":\"\"}],\"k4\":\"qqq\"}],\"bb\":[{\"k1\":[],\"k4\":\"www\"},{\"k1\":[{\"k2\":7,\"k3\":8,\"k5\":\"\"},{\"k2\":9,\"k3\":10,\"k5\":\"\"},{\"k2\":11,\"k3\":12,\"k5\":\"\"}],\"k4\":\"\"}]}\n+{\"aa\":[{\"k1\":[{\"k2\":13,\"k3\":14,\"k5\":\"\"},{\"k2\":15,\"k3\":16,\"k5\":\"\"}],\"k4\":\"www\"}],\"bb\":[]}\n+{\"aa\":[{\"k1\":[{\"k2\":0,\"k3\":20,\"k5\":\"some\"}],\"k4\":\"\"}],\"bb\":[]}\n+=============\n+{\"k1\":[[{\"k2\":1,\"k3\":2,\"k5\":\"\"},{\"k2\":0,\"k3\":3,\"k5\":\"\"}],[{\"k2\":4,\"k3\":0,\"k5\":\"\"},{\"k2\":0,\"k3\":5,\"k5\":\"\"},{\"k2\":6,\"k3\":0,\"k5\":\"\"}]],\"k4\":[\"\",\"qqq\"]}\n+{\"k1\":[[{\"k2\":13,\"k3\":14,\"k5\":\"\"},{\"k2\":15,\"k3\":16,\"k5\":\"\"}]],\"k4\":[\"www\"]}\n+{\"k1\":[[{\"k2\":0,\"k3\":20,\"k5\":\"some\"}]],\"k4\":[\"\"]}\n+=============\n+{\"obj\":{\"k1\":\"aa\",\"k2\":{\"k3\":\"bb\",\"k4\":\"c\"}}}\n+{\"obj\":{\"k1\":\"\",\"k2\":{\"k3\":\"\",\"k4\":\"\"}}}\n+{\"obj\":{\"k1\":\"eee\",\"k2\":{\"k3\":\"\",\"k4\":\"\"}}}\ndiff --git a/tests/queries/0_stateless/01825_type_json_in_other_types.sh b/tests/queries/0_stateless/01825_type_json_in_other_types.sh\nnew file mode 100755\nindex 000000000000..e9cf0bcaca12\n--- /dev/null\n+++ b/tests/queries/0_stateless/01825_type_json_in_other_types.sh\n@@ -0,0 +1,91 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CLIENT} -q \"SET allow_experimental_object_type = 1\"\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_json_nested\"\n+\n+${CLICKHOUSE_CLIENT} -q \"\n+    CREATE TABLE t_json_nested\n+    (\n+        id UInt32,\n+        data Tuple(String, Map(String, Array(JSON)), JSON)\n+    )\n+    ENGINE = MergeTree ORDER BY id\" --allow_experimental_object_type 1\n+\n+cat <<EOF | $CLICKHOUSE_CLIENT -q \"INSERT INTO t_json_nested FORMAT JSONEachRow\"\n+{\n+    \"id\": 1,\n+    \"data\":[\n+        \"foo\",\n+        {\n+            \"aa\": [\n+                {\"k1\": [{\"k2\": 1, \"k3\": 2}, {\"k3\": 3}]},\n+                {\"k1\": [{\"k2\": 4}, {\"k3\": 5}, {\"k2\": 6}], \"k4\": \"qqq\"}\n+            ],\n+            \"bb\": [\n+                 {\"k4\": \"www\"},\n+                 {\"k1\": [{\"k2\": 7, \"k3\": 8}, {\"k2\": 9, \"k3\": 10}, {\"k2\": 11, \"k3\": 12}]}\n+            ]\n+        },\n+        {\"k1\": \"aa\", \"k2\": {\"k3\": \"bb\", \"k4\": \"c\"}}\n+    ]\n+}\n+{\n+    \"id\": 2,\n+    \"data\":[\n+        \"bar\",\n+        {\n+            \"aa\": [\n+                {\"k1\": [{\"k2\": 13, \"k3\": 14}, {\"k2\": 15, \"k3\": 16}], \"k4\": \"www\"}\n+            ],\n+        },\n+        {}\n+    ]\n+}\n+EOF\n+\n+cat <<EOF | $CLICKHOUSE_CLIENT -q \"INSERT INTO t_json_nested FORMAT JSONEachRow\"\n+{\n+    \"id\": 3,\n+    \"data\":[\n+        \"some\",\n+        {\n+            \"aa\": [\n+                {\"k1\": [{\"k3\": 20, \"k5\": \"some\"}]},\n+            ],\n+        },\n+        {\"k1\": \"eee\"}\n+    ]\n+}\n+EOF\n+\n+$CLICKHOUSE_CLIENT -q \"SELECT toTypeName(data) FROM t_json_nested LIMIT 1\"\n+\n+echo \"=============\"\n+\n+$CLICKHOUSE_CLIENT -q \"SELECT * FROM t_json_nested ORDER BY id FORMAT JSONEachRow\" --output_format_json_named_tuples_as_objects 1\n+\n+echo \"=============\"\n+\n+$CLICKHOUSE_CLIENT -q \"\n+    SELECT (data.2)['aa'] AS aa, (data.2)['bb'] AS bb\n+    FROM t_json_nested ORDER BY id FORMAT JSONEachRow\" --output_format_json_named_tuples_as_objects 1\n+\n+echo \"=============\"\n+\n+$CLICKHOUSE_CLIENT -q \"\n+    WITH (data.2)['aa'] AS aa, (data.2)['bb'] AS bb\n+    SELECT tupleElement(aa, 'k1') AS k1,\n+           tupleElement(aa, 'k4') AS k4\n+    FROM t_json_nested ORDER BY id FORMAT JSONEachRow\" --output_format_json_named_tuples_as_objects 1\n+\n+echo \"=============\"\n+\n+$CLICKHOUSE_CLIENT -q \"SELECT data.3 AS obj FROM t_json_nested ORDER BY id FORMAT JSONEachRow\" --output_format_json_named_tuples_as_objects 1\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_json_nested\"\n+\n",
  "problem_statement": "Logical errors \"* non-finalized ColumnObject\" when Object is inside Array/Map/Tuple\nQueries to reproduce:\r\n```sql\r\nselect * from values('arr Array(JSON)', '[\\'{\"x\" : 1}\\']')\r\n\r\nSELECT *\r\nFROM values('arr Array(JSON)', '[\\'{\"x\" : 1}\\']')\r\n\r\nQuery id: d68bf81e-14b4-49ee-8c1b-b6b03641da79\r\n\r\nLogical error: 'Received from localhost:9000. DB::Exception: Cannot get Field from non-finalized ColumnObject\r\n```\r\n\r\n```sql\r\nselect * from values('arr Map(String, JSON)', '{\\'x\\' : \\'{\"y\" : 1}\\'}')\r\n\r\nSELECT *\r\nFROM values('arr Map(String, JSON)', '{\\'x\\' : \\'{\"y\" : 1}\\'}')\r\n\r\nQuery id: 2f290269-b953-48e5-b230-a361e1d30055\r\n\r\nLogical error: 'Received from localhost:9000. DB::Exception: Cannot get Field from non-finalized ColumnObject\r\n```\r\n\r\n```sql\r\nselect * from values('arr Tuple(JSON)', '(\\'{\"y\" : 1}\\')')\r\n\r\nSELECT *\r\nFROM values('arr Tuple(JSON)', '(\\'{\"y\" : 1}\\')')\r\n\r\nQuery id: b1c05a00-53ca-419e-81e8-260bb20ae375\r\n\r\nLogical error: 'Received from localhost:9000. DB::Exception: Cannot get Field from non-finalized ColumnObject\r\n```\r\n\r\n```sql\r\nselect * from format(JSONEachRow, '{\"arr\" : [{\"x\" : \"\", \"y\" : [1,2,3]}]}')\r\n\r\nSELECT *\r\nFROM format(JSONEachRow, '{\"arr\" : [{\"x\" : \"\", \"y\" : [1,2,3]}]}')\r\n\r\nQuery id: 5d577125-fe4b-4aa7-836f-627426455f53\r\n\r\nLogical error: 'Received from localhost:9000. DB::Exception: Cannot write non-finalized ColumnObject\r\n```\n",
  "hints_text": "Yes, currently type `JSON` is not working inside another types. It's worth to fix.",
  "created_at": "2022-05-06T14:46:03Z",
  "modified_files": [
    "src/Columns/ColumnArray.h",
    "src/Columns/ColumnMap.h",
    "src/Columns/ColumnObject.cpp",
    "src/Columns/ColumnObject.h",
    "src/Columns/ColumnTuple.cpp",
    "src/Columns/ColumnTuple.h",
    "src/Columns/IColumn.h",
    "src/DataTypes/DataTypeArray.h",
    "src/DataTypes/DataTypeMap.cpp",
    "src/DataTypes/DataTypeMap.h",
    "src/DataTypes/DataTypeObject.h",
    "src/DataTypes/DataTypeTuple.cpp",
    "src/DataTypes/DataTypeTuple.h",
    "src/DataTypes/IDataType.h",
    "src/DataTypes/ObjectUtils.cpp",
    "src/DataTypes/ObjectUtils.h",
    "src/DataTypes/Serializations/ISerialization.h",
    "src/DataTypes/Serializations/SerializationArray.cpp",
    "src/DataTypes/Serializations/SerializationArray.h",
    "src/DataTypes/Serializations/SerializationLowCardinality.cpp",
    "src/DataTypes/Serializations/SerializationLowCardinality.h",
    "src/DataTypes/Serializations/SerializationMap.cpp",
    "src/DataTypes/Serializations/SerializationMap.h",
    "src/DataTypes/Serializations/SerializationNamed.cpp",
    "src/DataTypes/Serializations/SerializationNamed.h",
    "src/DataTypes/Serializations/SerializationNullable.cpp",
    "src/DataTypes/Serializations/SerializationNullable.h",
    "src/DataTypes/Serializations/SerializationObject.cpp",
    "src/DataTypes/Serializations/SerializationObject.h",
    "src/DataTypes/Serializations/SerializationSparse.cpp",
    "src/DataTypes/Serializations/SerializationSparse.h",
    "src/DataTypes/Serializations/SerializationTuple.cpp",
    "src/DataTypes/Serializations/SerializationTuple.h",
    "src/DataTypes/Serializations/SerializationWrapper.cpp",
    "src/DataTypes/Serializations/SerializationWrapper.h",
    "src/Formats/NativeWriter.cpp",
    "src/Functions/FunctionsConversion.h",
    "src/Functions/blockSerializedSize.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Interpreters/convertFieldToType.cpp",
    "src/Processors/Formats/IRowInputFormat.cpp",
    "src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp",
    "src/Storages/MergeTree/MergeTask.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp",
    "src/Storages/MergeTree/MergeTreeDataWriter.cpp",
    "src/Storages/MergeTree/MergeTreeIndexSet.cpp",
    "src/Storages/MergeTree/MergeTreeSink.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp",
    "src/Storages/MergeTree/StorageFromMergeTreeDataPart.h",
    "src/Storages/StorageDistributed.cpp",
    "src/Storages/StorageInMemoryMetadata.cpp",
    "src/Storages/StorageLog.cpp",
    "src/Storages/StorageMemory.cpp",
    "src/Storages/StorageSnapshot.cpp",
    "src/Storages/getStructureOfRemoteTable.cpp"
  ],
  "modified_test_files": [
    "src/DataTypes/Serializations/tests/gtest_object_serialization.cpp",
    "b/tests/queries/0_stateless/01825_type_json_in_array.reference",
    "b/tests/queries/0_stateless/01825_type_json_in_array.sql",
    "b/tests/queries/0_stateless/01825_type_json_in_other_types.reference",
    "b/tests/queries/0_stateless/01825_type_json_in_other_types.sh"
  ]
}