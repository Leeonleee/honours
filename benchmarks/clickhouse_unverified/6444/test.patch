diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
index 0f03070fff3d..bbfe20d88135 100644
--- a/dbms/src/Compression/tests/gtest_compressionCodec.cpp
+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
@@ -1,10 +1,14 @@
-#include <Compression/CompressionCodecDoubleDelta.h>
-#include <Compression/CompressionCodecGorilla.h>
+#include <Compression/CompressionFactory.h>
 
+#include <Common/PODArray.h>
 #include <Core/Types.h>
-#include <IO/WriteHelpers.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/IDataType.h>
 #include <IO/ReadBufferFromMemory.h>
-#include <Common/PODArray.h>
+#include <IO/WriteHelpers.h>
+#include <Parsers/ExpressionElementParsers.h>
+#include <Parsers/IParser.h>
+#include <Parsers/TokenIterator.h>
 
 #include <boost/format.hpp>
 
@@ -24,56 +28,86 @@
 
 using namespace DB;
 
+namespace std
+{
 template <typename T>
-std::string bin(const T & value, size_t bits = sizeof(T)*8)
+std::ostream & operator<<(std::ostream & ostr, const std::optional<T> & opt)
 {
-    static const UInt8 MAX_BITS = sizeof(T)*8;
-    assert(bits <= MAX_BITS);
+    if (!opt)
+    {
+        return ostr << "<empty optional>";
+    }
 
-    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))
-            .to_string().substr(MAX_BITS - bits, bits);
+    return ostr << *opt;
 }
 
 template <typename T>
-const char* type_name()
+std::vector<T> operator+(std::vector<T> && left, std::vector<T> && right)
 {
-    return typeid(T).name();
-}
+    std::vector<T> result(std::move(left));
+    std::move(std::begin(right), std::end(right), std::back_inserter(result));
 
-template <>
-const char* type_name<UInt32>()
-{
-    return "uint32";
+    return result;
 }
 
-template <>
-const char* type_name<Int32>()
-{
-    return "int32";
 }
 
-template <>
-const char* type_name<UInt64>()
+namespace
 {
-    return "uint64";
-}
 
-template <>
-const char* type_name<Int64>()
+template <typename T>
+std::string bin(const T & value, size_t bits = sizeof(T)*8)
 {
-    return "int64";
+    static const UInt8 MAX_BITS = sizeof(T)*8;
+    assert(bits <= MAX_BITS);
+
+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))
+            .to_string().substr(MAX_BITS - bits, bits);
 }
 
-template <>
-const char* type_name<Float32>()
+template <typename T>
+const char* type_name()
 {
-    return "float";
+#define MAKE_TYPE_NAME(TYPE) \
+    if constexpr (std::is_same_v<TYPE, T>) return #TYPE
+
+    MAKE_TYPE_NAME(UInt8);
+    MAKE_TYPE_NAME(UInt16);
+    MAKE_TYPE_NAME(UInt32);
+    MAKE_TYPE_NAME(UInt64);
+    MAKE_TYPE_NAME(Int8);
+    MAKE_TYPE_NAME(Int16);
+    MAKE_TYPE_NAME(Int32);
+    MAKE_TYPE_NAME(Int64);
+    MAKE_TYPE_NAME(Float32);
+    MAKE_TYPE_NAME(Float64);
+
+#undef MAKE_TYPE_NAME
+
+    return typeid(T).name();
 }
 
-template <>
-const char* type_name<Float64>()
+template <typename T>
+DataTypePtr makeDataType()
 {
-    return "double";
+#define MAKE_DATA_TYPE(TYPE) \
+    if constexpr (std::is_same_v<T, TYPE>) return std::make_shared<DataType ## TYPE>()
+
+    MAKE_DATA_TYPE(UInt8);
+    MAKE_DATA_TYPE(UInt16);
+    MAKE_DATA_TYPE(UInt32);
+    MAKE_DATA_TYPE(UInt64);
+    MAKE_DATA_TYPE(Int8);
+    MAKE_DATA_TYPE(Int16);
+    MAKE_DATA_TYPE(Int32);
+    MAKE_DATA_TYPE(Int64);
+    MAKE_DATA_TYPE(Float32);
+    MAKE_DATA_TYPE(Float64);
+
+#undef MAKE_DATA_TYPE
+
+    assert(false && "unsupported size");
+    return nullptr;
 }
 
 
@@ -135,52 +169,105 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con
     return result;
 }
 
-struct CodecTestParam
+struct Codec
 {
-    std::string type_name;
-    std::vector<char> source_data;
-    UInt8 data_byte_size;
-    double min_compression_ratio;
-    std::string case_name;
-
-    // to allow setting ratio after building with complex builder functions.
-    CodecTestParam && setRatio(const double & ratio) &&
-    {
-        this->min_compression_ratio = ratio;
-        return std::move(*this);
-    }
+    std::string codec_statement;
+    std::optional<double> expected_compression_ratio;
+
+    explicit Codec(std::string codec_statement_, std::optional<double> expected_compression_ratio_ = std::nullopt)
+        : codec_statement(std::move(codec_statement_)),
+          expected_compression_ratio(expected_compression_ratio_)
+    {}
+
+    Codec()
+        : Codec(std::string())
+    {}
+
+    Codec(const Codec &) = default;
+    Codec & operator=(const Codec &) = default;
+    Codec(Codec &&) = default;
+    Codec & operator=(Codec &&) = default;
 };
 
-CodecTestParam operator+(CodecTestParam && left, CodecTestParam && right)
+
+struct CodecTestSequence
 {
-    assert(left.type_name == right.type_name);
-    assert(left.data_byte_size == right.data_byte_size);
-
-    std::vector data(std::move(left.source_data));
-    data.insert(data.end(), right.source_data.begin(), right.source_data.end());
-
-    return CodecTestParam{
-                        left.type_name,
-                        std::move(data),
-                        left.data_byte_size,
-                        std::min(left.min_compression_ratio, right.min_compression_ratio),
-                        left.case_name + " + " + right.case_name
+    std::string name;
+    std::vector<char> serialized_data;
+    DataTypePtr data_type;
+
+    CodecTestSequence()
+        : name(),
+          serialized_data(),
+          data_type()
+    {}
+
+    CodecTestSequence(std::string name_, std::vector<char> serialized_data_, DataTypePtr data_type_)
+        : name(name_),
+          serialized_data(serialized_data_),
+          data_type(data_type_)
+    {}
+
+    CodecTestSequence(const CodecTestSequence &) = default;
+    CodecTestSequence & operator=(const CodecTestSequence &) = default;
+    CodecTestSequence(CodecTestSequence &&) = default;
+    CodecTestSequence & operator=(CodecTestSequence &&) = default;
+};
+
+CodecTestSequence operator+(CodecTestSequence && left, CodecTestSequence && right)
+{
+    assert(left.data_type->equals(*right.data_type));
+
+    std::vector<char> data(std::move(left.serialized_data));
+    data.insert(data.end(), right.serialized_data.begin(), right.serialized_data.end());
+
+    return CodecTestSequence{
+        left.name + " + " + right.name,
+        std::move(data),
+        std::move(left.data_type)
     };
 }
 
-std::ostream & operator<<(std::ostream & ostr, const CodecTestParam & param)
+template <typename T>
+CodecTestSequence operator*(CodecTestSequence && left, T times)
 {
-    return ostr << "name: " << param.case_name
-                << "
type name:" << param.type_name
-                << "
byte size: " << static_cast<UInt32>(param.data_byte_size)
-                << "
data size: " << param.source_data.size();
+    std::vector<char> data(std::move(left.serialized_data));
+    const size_t initial_size = data.size();
+    const size_t final_size = initial_size * times;
+
+    data.reserve(final_size);
+
+    for (T i = 0; i < times; ++i)
+    {
+        data.insert(data.end(), data.begin(), data.begin() + initial_size);
+    }
+
+    return CodecTestSequence{
+        left.name + " x " + std::to_string(times),
+        std::move(data),
+        std::move(left.data_type)
+    };
 }
 
-// compression ratio < 1.0 means that codec output is smaller than input.
-const double DEFAULT_MIN_COMPRESSION_RATIO = 1.0;
+std::ostream & operator<<(std::ostream & ostr, const Codec & codec)
+{
+    return ostr << "Codec{"
+                << "name: " << codec.codec_statement
+                << ", expected_compression_ratio: " << codec.expected_compression_ratio
+                << "}";
+}
+
+std::ostream & operator<<(std::ostream & ostr, const CodecTestSequence & seq)
+{
+    return ostr << "CodecTestSequence{"
+                << "name: " << seq.name
+                << ", type name: " << seq.data_type->getName()
+                << ", data size: " << seq.serialized_data.size() << " bytes"
+                << "}";
+}
 
 template <typename T, typename... Args>
-CodecTestParam makeParam(Args && ... args)
+CodecTestSequence makeSeq(Args && ... args)
 {
     std::initializer_list<T> vals{static_cast<T>(args)...};
     std::vector<char> data(sizeof(T) * std::size(vals));
@@ -192,14 +279,17 @@ CodecTestParam makeParam(Args && ... args)
         write_pos += sizeof(v);
     }
 
-    return CodecTestParam{type_name<T>(), std::move(data), sizeof(T), DEFAULT_MIN_COMPRESSION_RATIO,
-                (boost::format("%1% values of %2%") % std::size(vals) % type_name<T>()).str()};
+    return CodecTestSequence{
+            (boost::format("%1% values of %2%") % std::size(vals) % type_name<T>()).str(),
+            std::move(data),
+            makeDataType<T>()
+    };
 }
 
-template <typename T, size_t Begin = 1, size_t End = 10001, typename Generator>
-CodecTestParam generateParam(Generator gen, const char* gen_name)
+template <typename T, typename Generator>
+CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin = 0, size_t End = 10000)
 {
-    static_assert (End >= Begin, "End must be not less than Begin");
+    assert (End >= Begin);
 
     std::vector<char> data(sizeof(T) * (End - Begin));
     char * write_pos = data.data();
@@ -211,89 +301,104 @@ CodecTestParam generateParam(Generator gen, const char* gen_name)
         write_pos += sizeof(v);
     }
 
-    return CodecTestParam{type_name<T>(), std::move(data), sizeof(T), DEFAULT_MIN_COMPRESSION_RATIO,
-                (boost::format("%1% values of %2% from %3%") % (End - Begin) % type_name<T>() % gen_name).str()};
+    return CodecTestSequence{
+            (boost::format("%1% values of %2% from %3%") % (End - Begin) % type_name<T>() % gen_name).str(),
+            std::move(data),
+            makeDataType<T>()
+    };
 }
 
-void TestTranscoding(ICompressionCodec * codec, const CodecTestParam & param)
+
+class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>
 {
-    const auto & source_data = param.source_data;
+public:
+    enum MakeCodecParam
+    {
+        CODEC_WITH_DATA_TYPE,
+        CODEC_WITHOUT_DATA_TYPE,
+    };
 
-    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());
-    PODArray<char> encoded(encoded_max_size);
+    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type) const
+    {
+        const auto & codec_string = std::get<0>(GetParam()).codec_statement;
+        const auto & data_type = with_data_type == CODEC_WITH_DATA_TYPE ? std::get<1>(GetParam()).data_type : nullptr;
 
-    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());
-    encoded.resize(encoded_size);
+        const std::string codec_statement = "(" + codec_string + ")";
+        Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());
+        TokenIterator token_iterator(tokens);
 
-    PODArray<char> decoded(source_data.size());
-    const UInt32 decoded_size = codec->decompress(encoded.data(), encoded.size(), decoded.data());
-    decoded.resize(decoded_size);
+        Expected expected;
+        ASTPtr codec_ast;
+        ParserCodec parser;
 
-    switch (param.data_byte_size)
-    {
-        case 1:
-            ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));
-            break;
-        case 2:
-            ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));
-            break;
-        case 4:
-            ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));
-            break;
-        case 8:
-            ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));
-            break;
-        default:
-            FAIL() << "Invalid data_byte_size: " << param.data_byte_size;
-    }
-    const auto header_size = codec->getHeaderSize();
-    const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);
+        parser.parse(token_iterator, codec_ast, expected);
 
-    ASSERT_LE(compression_ratio, param.min_compression_ratio)
-            << "
\tdecoded size: " << source_data.size()
-            << "
\tencoded size: " << encoded_size
-            << "(no header: " << encoded_size - header_size << ")";
-}
+        return CompressionCodecFactory::instance().get(codec_ast, data_type);
+    }
 
-class CodecTest : public ::testing::TestWithParam<CodecTestParam>
-{
-public:
-    static void SetUpTestCase()
+    void testTranscoding(ICompressionCodec & codec)
     {
-        // To make random predicatble and avoid failing test "out of the blue".
-        srand(0);
+        const auto & test_sequence = std::get<1>(GetParam());
+        const auto & source_data = test_sequence.serialized_data;
+
+        const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());
+        PODArray<char> encoded(encoded_max_size);
+
+        const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());
+        encoded.resize(encoded_size);
+
+        PODArray<char> decoded(source_data.size());
+        const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());
+        decoded.resize(decoded_size);
+
+        switch (test_sequence.data_type->getSizeOfValueInMemory())
+        {
+            case 1:
+                ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));
+                break;
+            case 2:
+                ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));
+                break;
+            case 4:
+                ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));
+                break;
+            case 8:
+                ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));
+                break;
+            default:
+                FAIL() << "Invalid test sequence data type: " << test_sequence.data_type->getName();
+        }
+        const auto header_size = codec.getHeaderSize();
+        const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);
+
+        const auto & codec_spec = std::get<0>(GetParam());
+        if (codec_spec.expected_compression_ratio)
+        {
+            ASSERT_LE(compression_ratio, *codec_spec.expected_compression_ratio)
+                    << "
\tdecoded size: " << source_data.size()
+                    << "
\tencoded size: " << encoded_size
+                    << "(no header: " << encoded_size - header_size << ")";
+        }
     }
 };
 
-TEST_P(CodecTest, DoubleDelta)
+TEST_P(CodecTest, TranscodingWithDataType)
 {
-    auto param = GetParam();
-    auto codec = std::make_unique<CompressionCodecDoubleDelta>(param.data_byte_size);
-    if (param.type_name == type_name<Float32>() || param.type_name == type_name<Float64>())
-    {
-        // dd doesn't work great with many cases of integers and may result in very poor compression rate.
-        param.min_compression_ratio *= 1.5;
-    }
-
-    TestTranscoding(codec.get(), param);
+    const auto codec = makeCodec(CODEC_WITH_DATA_TYPE);
+    testTranscoding(*codec);
 }
 
-TEST_P(CodecTest, Gorilla)
+TEST_P(CodecTest, TranscodingWithoutDataType)
 {
-    auto param = GetParam();
-    auto codec = std::make_unique<CompressionCodecGorilla>(param.data_byte_size);
-    if (param.type_name == type_name<UInt32>() || param.type_name == type_name<Int32>()
-            || param.type_name == type_name<UInt64>() || param.type_name == type_name<Int64>())
-    {
-        // gorilla doesn't work great with many cases of integers and may result in very poor compression rate.
-        param.min_compression_ratio *= 1.5;
-    }
-
-    TestTranscoding(codec.get(), param);
+    const auto codec = makeCodec(CODEC_WITHOUT_DATA_TYPE);
+    testTranscoding(*codec);
 }
 
+///////////////////////////////////////////////////////////////////////////////////////////////////
 // Here we use generators to produce test payload for codecs.
-// Generator is a callable that should produce output value of the same type as input value.
+// Generator is a callable that can produce infinite number of values,
+// output value MUST be of the same type input value.
+///////////////////////////////////////////////////////////////////////////////////////////////////
 
 auto SameValueGenerator = [](auto value)
 {
@@ -332,141 +437,427 @@ auto SequentialGenerator = [](auto stride = 1)
 //};
 
 template <typename T>
+using uniform_distribution =
+typename std::conditional_t<std::is_floating_point_v<T>, std::uniform_real_distribution<T>,
+        typename std::conditional_t<std::is_integral_v<T>, std::uniform_int_distribution<T>, void>>;
+
+
+template <typename T = Int32>
 struct MonotonicGenerator
 {
-    MonotonicGenerator(T stride_ = 1, size_t max_step_ = 10)
+    MonotonicGenerator(T stride_ = 1, T max_step = 10)
         : prev_value(0),
           stride(stride_),
-          max_step(max_step_)
+          random_engine(0),
+          distribution(0, max_step)
     {}
 
     template <typename U>
     U operator()(U)
     {
-        const U result = prev_value + static_cast<T>(stride * (rand() % max_step));
-
-        prev_value = result;
-        return result;
+        prev_value = prev_value + stride * distribution(random_engine);
+        return static_cast<U>(prev_value);
     }
 
+private:
     T prev_value;
     const T stride;
-    const size_t max_step;
-};
-
-auto MinMaxGenerator = [](auto i)
-{
-    if (i % 2 == 0)
-    {
-        return std::numeric_limits<decltype(i)>::min();
-    }
-    else
-    {
-        return std::numeric_limits<decltype(i)>::max();
-    }
+    std::default_random_engine random_engine;
+    uniform_distribution<T> distribution;
 };
 
 template <typename T>
 struct RandomGenerator
 {
-    RandomGenerator(T seed = 0, T value_cap_ = std::numeric_limits<T>::max())
-        : e(seed),
-          value_cap(value_cap_)
+    RandomGenerator(T seed = 0, T value_min = std::numeric_limits<T>::min(), T value_max = std::numeric_limits<T>::max())
+        : random_engine(seed),
+          distribution(value_min, value_max)
     {
     }
 
     template <typename U>
-    U operator()(U i)
+    U operator()(U)
     {
-        return static_cast<decltype(i)>(distribution(e) % value_cap);
+        return static_cast<U>(distribution(random_engine));
     }
 
 private:
-    std::default_random_engine e;
-    std::uniform_int_distribution<T> distribution;
-    const T value_cap;
+    std::default_random_engine random_engine;
+    uniform_distribution<T> distribution;
 };
 
 auto RandomishGenerator = [](auto i)
 {
-    return static_cast<decltype(i)>(sin(static_cast<double>(i) * i) * i);
+    return static_cast<decltype(i)>(sin(static_cast<double>(i * i)) * i);
+};
+
+auto MinMaxGenerator = []()
+{
+    return [step = 0](auto i) mutable
+    {
+        if (step++ % 2 == 0)
+        {
+            return std::numeric_limits<decltype(i)>::min();
+        }
+        else
+        {
+            return std::numeric_limits<decltype(i)>::max();
+        }
+    };
 };
 
-// helper macro to produce human-friendly test case name
+// Fill dest value with 0x00 or 0xFF
+auto FFand0Generator = []()
+{
+    return [step = 0](auto i) mutable
+    {
+        decltype(i) result;
+        if (step++ % 2 == 0)
+        {
+            memset(&result, 0, sizeof(result));
+        }
+        else
+        {
+            memset(&result, 0xFF, sizeof(result));
+        }
+
+        return result;
+    };
+};
+
+
+// Makes many sequences with generator, first sequence length is 1, second is 2... up to `sequences_count`.
+template <typename T, typename Generator>
+std::vector<CodecTestSequence> generatePyramidOfSequences(const size_t sequences_count, Generator && generator, const char* generator_name)
+{
+    std::vector<CodecTestSequence> sequences;
+    sequences.reserve(sequences_count);
+    for (size_t i = 1; i < sequences_count; ++i)
+    {
+        std::string name = generator_name + std::string(" from 0 to ") + std::to_string(i);
+        sequences.push_back(generateSeq<T>(std::forward<decltype(generator)>(generator), name.c_str(), 0, i));
+    }
+
+    return sequences;
+};
+
+
+// helper macro to produce human-friendly sequence name from generator
 #define G(generator) generator, #generator
 
+const auto DefaultCodecsToTest = ::testing::Values(
+    Codec("DoubleDelta"),
+    Codec("DoubleDelta, LZ4"),
+    Codec("DoubleDelta, ZSTD"),
+    Codec("Gorilla"),
+    Codec("Gorilla, LZ4"),
+    Codec("Gorilla, ZSTD")
+);
+
+///////////////////////////////////////////////////////////////////////////////////////////////////
+// test cases
+///////////////////////////////////////////////////////////////////////////////////////////////////
+
+INSTANTIATE_TEST_CASE_P(Simple,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            makeSeq<Float64>(1, 2, 3, 5, 7, 11, 13, 17, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(SmallSequences,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::ValuesIn(
+                  generatePyramidOfSequences<Int8  >(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<Int16 >(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<Int32 >(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<Int64 >(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<UInt8 >(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<UInt16>(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<UInt32>(42, G(SequentialGenerator(1)))
+                + generatePyramidOfSequences<UInt64>(42, G(SequentialGenerator(1)))
+        )
+    ),
+);
+
 INSTANTIATE_TEST_CASE_P(Mixed,
     CodecTest,
-    ::testing::Values(
-        generateParam<Int32,  1, 3>(G(MinMaxGenerator)) + generateParam<Int32,  1, 11>(G(SequentialGenerator(1))).setRatio(1),
-        generateParam<UInt32, 1, 3>(G(MinMaxGenerator)) + generateParam<UInt32, 1, 11>(G(SequentialGenerator(1))).setRatio(1),
-        generateParam<Int64,  1, 3>(G(MinMaxGenerator)) + generateParam<Int64,  1, 11>(G(SequentialGenerator(1))).setRatio(1),
-        generateParam<UInt64, 1, 3>(G(MinMaxGenerator)) + generateParam<UInt64, 1, 11>(G(SequentialGenerator(1))).setRatio(1)
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int8>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<Int16>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int16>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<Int32>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int32>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<Int64>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int64>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<UInt8>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt8>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<UInt16>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt16>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<UInt32>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt32>(G(SequentialGenerator(1)), 1, 1001),
+            generateSeq<UInt64>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt64>(G(SequentialGenerator(1)), 1, 1001)
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Same,
+INSTANTIATE_TEST_CASE_P(SameValueInt,
     CodecTest,
-    ::testing::Values(
-        generateParam<UInt32>(G(SameValueGenerator(1000))),
-        generateParam<Int32>(G(SameValueGenerator(-1000))),
-        generateParam<UInt64>(G(SameValueGenerator(1000))),
-        generateParam<Int64>(G(SameValueGenerator(-1000))),
-        generateParam<Float32>(G(SameValueGenerator(M_E))),
-        generateParam<Float64>(G(SameValueGenerator(M_E)))
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(SameValueGenerator(1000))),
+            generateSeq<Int16 >(G(SameValueGenerator(1000))),
+            generateSeq<Int32 >(G(SameValueGenerator(1000))),
+            generateSeq<Int64 >(G(SameValueGenerator(1000))),
+            generateSeq<UInt8 >(G(SameValueGenerator(1000))),
+            generateSeq<UInt16>(G(SameValueGenerator(1000))),
+            generateSeq<UInt32>(G(SameValueGenerator(1000))),
+            generateSeq<UInt64>(G(SameValueGenerator(1000)))
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Sequential,
+INSTANTIATE_TEST_CASE_P(SameNegativeValueInt,
     CodecTest,
-    ::testing::Values(
-        generateParam<UInt32>(G(SequentialGenerator(1))),
-        generateParam<Int32>(G(SequentialGenerator(-1))),
-        generateParam<UInt64>(G(SequentialGenerator(1))),
-        generateParam<Int64>(G(SequentialGenerator(-1))),
-        generateParam<Float32>(G(SequentialGenerator(M_E))),
-        generateParam<Float64>(G(SequentialGenerator(M_E)))
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(SameValueGenerator(-1000))),
+            generateSeq<Int16 >(G(SameValueGenerator(-1000))),
+            generateSeq<Int32 >(G(SameValueGenerator(-1000))),
+            generateSeq<Int64 >(G(SameValueGenerator(-1000))),
+            generateSeq<UInt8 >(G(SameValueGenerator(-1000))),
+            generateSeq<UInt16>(G(SameValueGenerator(-1000))),
+            generateSeq<UInt32>(G(SameValueGenerator(-1000))),
+            generateSeq<UInt64>(G(SameValueGenerator(-1000)))
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Monotonic,
+INSTANTIATE_TEST_CASE_P(SameValueFloat,
     CodecTest,
-    ::testing::Values(
-        generateParam<UInt32>(G(MonotonicGenerator<UInt32>(1, 5))),
-        generateParam<Int32>(G(MonotonicGenerator<Int32>(-1, 5))),
-        generateParam<UInt64>(G(MonotonicGenerator<UInt64>(1, 5))),
-        generateParam<Int64>(G(MonotonicGenerator<Int64>(-1, 5))),
-        generateParam<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),
-        generateParam<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla"),
+            Codec("Gorilla, LZ4")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(SameValueGenerator(M_E))),
+            generateSeq<Float64>(G(SameValueGenerator(M_E)))
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Random,
+INSTANTIATE_TEST_CASE_P(SameNegativeValueFloat,
     CodecTest,
-    ::testing::Values(
-        generateParam<UInt32>(G(RandomGenerator<UInt32>(0, 1000'000'000))).setRatio(1.2),
-        generateParam<UInt64>(G(RandomGenerator<UInt64>(0, 1000'000'000))).setRatio(1.1)
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla"),
+            Codec("Gorilla, LZ4")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(SameValueGenerator(-1 * M_E))),
+            generateSeq<Float64>(G(SameValueGenerator(-1 * M_E)))
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Randomish,
+INSTANTIATE_TEST_CASE_P(SequentialInt,
     CodecTest,
-    ::testing::Values(
-        generateParam<Int32>(G(RandomishGenerator)).setRatio(1.1),
-        generateParam<Int64>(G(RandomishGenerator)).setRatio(1.1),
-        generateParam<UInt32>(G(RandomishGenerator)).setRatio(1.1),
-        generateParam<UInt64>(G(RandomishGenerator)).setRatio(1.1),
-        generateParam<Float32>(G(RandomishGenerator)).setRatio(1.1),
-        generateParam<Float64>(G(RandomishGenerator)).setRatio(1.1)
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(SequentialGenerator(1))),
+            generateSeq<Int16 >(G(SequentialGenerator(1))),
+            generateSeq<Int32 >(G(SequentialGenerator(1))),
+            generateSeq<Int64 >(G(SequentialGenerator(1))),
+            generateSeq<UInt8 >(G(SequentialGenerator(1))),
+            generateSeq<UInt16>(G(SequentialGenerator(1))),
+            generateSeq<UInt32>(G(SequentialGenerator(1))),
+            generateSeq<UInt64>(G(SequentialGenerator(1)))
+        )
     ),
 );
 
-INSTANTIATE_TEST_CASE_P(Overflow,
+// -1, -2, -3, ... etc for signed
+// 0xFF, 0xFE, 0xFD, ... for unsigned
+INSTANTIATE_TEST_CASE_P(SequentialReverseInt,
     CodecTest,
-    ::testing::Values(
-        generateParam<UInt32>(G(MinMaxGenerator)),
-        generateParam<Int32>(G(MinMaxGenerator)),
-        generateParam<UInt64>(G(MinMaxGenerator)),
-        generateParam<Int64>(G(MinMaxGenerator))
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(SequentialGenerator(-1))),
+            generateSeq<Int16 >(G(SequentialGenerator(-1))),
+            generateSeq<Int32 >(G(SequentialGenerator(-1))),
+            generateSeq<Int64 >(G(SequentialGenerator(-1))),
+            generateSeq<UInt8 >(G(SequentialGenerator(-1))),
+            generateSeq<UInt16>(G(SequentialGenerator(-1))),
+            generateSeq<UInt32>(G(SequentialGenerator(-1))),
+            generateSeq<UInt64>(G(SequentialGenerator(-1)))
+        )
     ),
 );
+
+INSTANTIATE_TEST_CASE_P(SequentialFloat,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla"),
+            Codec("Gorilla, LZ4")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(SequentialGenerator(M_E))),
+            generateSeq<Float64>(G(SequentialGenerator(M_E)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(SequentialReverseFloat,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla"),
+            Codec("Gorilla, LZ4")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(SequentialGenerator(-1 * M_E))),
+            generateSeq<Float64>(G(SequentialGenerator(-1 * M_E)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(MonotonicInt,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int16 >(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int32 >(G(MonotonicGenerator(1, 5))),
+            generateSeq<Int64 >(G(MonotonicGenerator(1, 5))),
+            generateSeq<UInt8 >(G(MonotonicGenerator(1, 5))),
+            generateSeq<UInt16>(G(MonotonicGenerator(1, 5))),
+            generateSeq<UInt32>(G(MonotonicGenerator(1, 5))),
+            generateSeq<UInt64>(G(MonotonicGenerator(1, 5)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(MonotonicReverseInt,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int8  >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int16 >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int32 >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<Int64 >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<UInt8 >(G(MonotonicGenerator(-1, 5))),
+            generateSeq<UInt16>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<UInt32>(G(MonotonicGenerator(-1, 5))),
+            generateSeq<UInt64>(G(MonotonicGenerator(-1, 5)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(MonotonicFloat,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),
+            generateSeq<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(MonotonicReverseFloat,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla")
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(MonotonicGenerator<Float32>(-1 * M_E, 5))),
+            generateSeq<Float64>(G(MonotonicGenerator<Float64>(-1 * M_E, 5)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(RandomInt,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<UInt8 >(G(RandomGenerator<UInt8>(0))),
+            generateSeq<UInt16>(G(RandomGenerator<UInt16>(0))),
+            generateSeq<UInt32>(G(RandomGenerator<UInt32>(0, 0, 1000'000'000))),
+            generateSeq<UInt64>(G(RandomGenerator<UInt64>(0, 0, 1000'000'000)))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(RandomishInt,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Int32>(G(RandomishGenerator)),
+            generateSeq<Int64>(G(RandomishGenerator)),
+            generateSeq<UInt32>(G(RandomishGenerator)),
+            generateSeq<UInt64>(G(RandomishGenerator)),
+            generateSeq<Float32>(G(RandomishGenerator)),
+            generateSeq<Float64>(G(RandomishGenerator))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(RandomishFloat,
+    CodecTest,
+    ::testing::Combine(
+        DefaultCodecsToTest,
+        ::testing::Values(
+            generateSeq<Float32>(G(RandomishGenerator)),
+            generateSeq<Float64>(G(RandomishGenerator))
+        )
+    ),
+);
+
+// Double delta overflow case, deltas are out of bounds for target type
+INSTANTIATE_TEST_CASE_P(OverflowInt,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("DoubleDelta", 1.2),
+            Codec("DoubleDelta, LZ4", 1.0)
+        ),
+        ::testing::Values(
+            generateSeq<UInt32>(G(MinMaxGenerator())),
+            generateSeq<Int32>(G(MinMaxGenerator())),
+            generateSeq<UInt64>(G(MinMaxGenerator())),
+            generateSeq<Int64>(G(MinMaxGenerator()))
+        )
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(OverflowFloat,
+    CodecTest,
+    ::testing::Combine(
+        ::testing::Values(
+            Codec("Gorilla", 1.1),
+            Codec("Gorilla, LZ4", 1.0)
+        ),
+        ::testing::Values(
+            generateSeq<Float32>(G(MinMaxGenerator())),
+            generateSeq<Float64>(G(MinMaxGenerator())),
+            generateSeq<Float32>(G(FFand0Generator())),
+            generateSeq<Float64>(G(FFand0Generator()))
+        )
+    ),
+);
+
+}
