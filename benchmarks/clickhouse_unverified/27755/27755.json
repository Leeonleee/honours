{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27755,
  "instance_id": "ClickHouse__ClickHouse-27755",
  "issue_numbers": [
    "17278"
  ],
  "base_commit": "c0e1c42562c48d122a1dad4fea18b060d4805ae3",
  "patch": "diff --git a/base/daemon/SentryWriter.cpp b/base/daemon/SentryWriter.cpp\nindex 3571c64edd60..470e1deb3624 100644\n--- a/base/daemon/SentryWriter.cpp\n+++ b/base/daemon/SentryWriter.cpp\n@@ -12,6 +12,7 @@\n #include <Common/SymbolIndex.h>\n #include <Common/StackTrace.h>\n #include <Common/getNumberOfPhysicalCPUCores.h>\n+#include <Core/ServerUUID.h>\n \n #if !defined(ARCADIA_BUILD)\n #    include \"Common/config_version.h\"\n@@ -38,6 +39,13 @@ void setExtras()\n     if (!anonymize)\n         sentry_set_extra(\"server_name\", sentry_value_new_string(getFQDNOrHostName().c_str()));\n \n+    DB::UUID server_uuid = DB::ServerUUID::get();\n+    if (server_uuid != DB::UUIDHelpers::Nil)\n+    {\n+        std::string server_uuid_str = DB::toString(server_uuid);\n+        sentry_set_extra(\"server_uuid\", sentry_value_new_string(server_uuid_str.c_str()));\n+    }\n+\n     sentry_set_tag(\"version\", VERSION_STRING);\n     sentry_set_extra(\"version_githash\", sentry_value_new_string(VERSION_GITHASH));\n     sentry_set_extra(\"version_describe\", sentry_value_new_string(VERSION_DESCRIBE));\ndiff --git a/programs/keeper/Keeper.cpp b/programs/keeper/Keeper.cpp\nindex 60695cbfeebd..4d01a5238530 100644\n--- a/programs/keeper/Keeper.cpp\n+++ b/programs/keeper/Keeper.cpp\n@@ -17,6 +17,7 @@\n #include <Poco/Version.h>\n #include <Poco/Environment.h>\n #include <Common/getMultipleKeysFromConfig.h>\n+#include <Core/ServerUUID.h>\n #include <filesystem>\n #include <IO/UseSSL.h>\n \n@@ -326,6 +327,8 @@ int Keeper::main(const std::vector<std::string> & /*args*/)\n         }\n     }\n \n+    DB::ServerUUID::load(path + \"/uuid\", log);\n+\n     const Settings & settings = global_context->getSettingsRef();\n \n     GlobalThreadPool::initialize(config().getUInt(\"max_thread_pool_size\", 100));\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 5520f9208238..c3623eca0077 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -39,6 +39,7 @@\n #include <Common/getMappedArea.h>\n #include <Common/remapExecutable.h>\n #include <Common/TLDListsHolder.h>\n+#include <Core/ServerUUID.h>\n #include <IO/HTTPCommon.h>\n #include <IO/ReadHelpers.h>\n #include <IO/UseSSL.h>\n@@ -79,7 +80,6 @@\n #include <Server/HTTP/HTTPServer.h>\n #include <filesystem>\n \n-\n #if !defined(ARCADIA_BUILD)\n #   include \"config_core.h\"\n #   include \"Common/config_version.h\"\n@@ -146,7 +146,6 @@ static bool jemallocOptionEnabled(const char *name)\n static bool jemallocOptionEnabled(const char *) { return 0; }\n #endif\n \n-\n int mainEntryClickHouseServer(int argc, char ** argv)\n {\n     DB::Server app;\n@@ -667,13 +666,14 @@ if (ThreadFuzzer::instance().isEffective())\n \n     global_context->setRemoteHostFilter(config());\n \n-    std::string path = getCanonicalPath(config().getString(\"path\", DBMS_DEFAULT_PATH));\n+    std::string path_str = getCanonicalPath(config().getString(\"path\", DBMS_DEFAULT_PATH));\n+    fs::path path = path_str;\n     std::string default_database = config().getString(\"default_database\", \"default\");\n \n     /// Check that the process user id matches the owner of the data.\n     const auto effective_user_id = geteuid();\n     struct stat statbuf;\n-    if (stat(path.c_str(), &statbuf) == 0 && effective_user_id != statbuf.st_uid)\n+    if (stat(path_str.c_str(), &statbuf) == 0 && effective_user_id != statbuf.st_uid)\n     {\n         const auto effective_user = getUserName(effective_user_id);\n         const auto data_owner = getUserName(statbuf.st_uid);\n@@ -690,9 +690,11 @@ if (ThreadFuzzer::instance().isEffective())\n         }\n     }\n \n-    global_context->setPath(path);\n+    global_context->setPath(path_str);\n+\n+    StatusFile status{path / \"status\", StatusFile::write_full_info};\n \n-    StatusFile status{path + \"status\", StatusFile::write_full_info};\n+    DB::ServerUUID::load(path / \"uuid\", log);\n \n     /// Try to increase limit on number of open files.\n     {\n@@ -726,7 +728,7 @@ if (ThreadFuzzer::instance().isEffective())\n \n     /// Storage with temporary data for processing of heavy queries.\n     {\n-        std::string tmp_path = config().getString(\"tmp_path\", path + \"tmp/\");\n+        std::string tmp_path = config().getString(\"tmp_path\", path / \"tmp/\");\n         std::string tmp_policy = config().getString(\"tmp_policy\", \"\");\n         const VolumePtr & volume = global_context->setTemporaryStorage(tmp_path, tmp_policy);\n         for (const DiskPtr & disk : volume->getDisks())\n@@ -738,7 +740,7 @@ if (ThreadFuzzer::instance().isEffective())\n       * Examples: do repair of local data; clone all replicated tables from replica.\n       */\n     {\n-        auto flags_path = fs::path(path) / \"flags/\";\n+        auto flags_path = path / \"flags/\";\n         fs::create_directories(flags_path);\n         global_context->setFlagsPath(flags_path);\n     }\n@@ -747,29 +749,29 @@ if (ThreadFuzzer::instance().isEffective())\n       */\n     {\n \n-        std::string user_files_path = config().getString(\"user_files_path\", fs::path(path) / \"user_files/\");\n+        std::string user_files_path = config().getString(\"user_files_path\", path / \"user_files/\");\n         global_context->setUserFilesPath(user_files_path);\n         fs::create_directories(user_files_path);\n     }\n \n     {\n-        std::string dictionaries_lib_path = config().getString(\"dictionaries_lib_path\", fs::path(path) / \"dictionaries_lib/\");\n+        std::string dictionaries_lib_path = config().getString(\"dictionaries_lib_path\", path / \"dictionaries_lib/\");\n         global_context->setDictionariesLibPath(dictionaries_lib_path);\n         fs::create_directories(dictionaries_lib_path);\n     }\n \n     /// top_level_domains_lists\n     {\n-        const std::string & top_level_domains_path = config().getString(\"top_level_domains_path\", fs::path(path) / \"top_level_domains/\");\n+        const std::string & top_level_domains_path = config().getString(\"top_level_domains_path\", path / \"top_level_domains/\");\n         TLDListsHolder::getInstance().parseConfig(fs::path(top_level_domains_path) / \"\", config());\n     }\n \n     {\n-        fs::create_directories(fs::path(path) / \"data/\");\n-        fs::create_directories(fs::path(path) / \"metadata/\");\n+        fs::create_directories(path / \"data/\");\n+        fs::create_directories(path / \"metadata/\");\n \n         /// Directory with metadata of tables, which was marked as dropped by Atomic database\n-        fs::create_directories(fs::path(path) / \"metadata_dropped/\");\n+        fs::create_directories(path / \"metadata_dropped/\");\n     }\n \n     if (config().has(\"interserver_http_port\") && config().has(\"interserver_https_port\"))\n@@ -952,7 +954,7 @@ if (ThreadFuzzer::instance().isEffective())\n #endif\n \n     /// Set path for format schema files\n-    fs::path format_schema_path(config().getString(\"format_schema_path\", fs::path(path) / \"format_schemas/\"));\n+    fs::path format_schema_path(config().getString(\"format_schema_path\", path / \"format_schemas/\"));\n     global_context->setFormatSchemaPath(format_schema_path);\n     fs::create_directories(format_schema_path);\n \n@@ -1088,7 +1090,7 @@ if (ThreadFuzzer::instance().isEffective())\n     /// system logs may copy global context.\n     global_context->setCurrentDatabaseNameInGlobalContext(default_database);\n \n-    LOG_INFO(log, \"Loading metadata from {}\", path);\n+    LOG_INFO(log, \"Loading metadata from {}\", path_str);\n \n     try\n     {\ndiff --git a/src/Core/ServerUUID.cpp b/src/Core/ServerUUID.cpp\nnew file mode 100644\nindex 000000000000..721c406ff5ff\n--- /dev/null\n+++ b/src/Core/ServerUUID.cpp\n@@ -0,0 +1,56 @@\n+#include <Core/ServerUUID.h>\n+#include <IO/ReadBufferFromFile.h>\n+#include <IO/WriteBufferFromFile.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n+#include <common/logger_useful.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_CREATE_FILE;\n+}\n+\n+void ServerUUID::load(const fs::path & server_uuid_file, Poco::Logger * log)\n+{\n+    /// Write a uuid file containing a unique uuid if the file doesn't already exist during server start.\n+\n+    if (fs::exists(server_uuid_file))\n+    {\n+        try\n+        {\n+            UUID uuid;\n+            ReadBufferFromFile in(server_uuid_file);\n+            readUUIDText(uuid, in);\n+            assertEOF(in);\n+            server_uuid = uuid;\n+            return;\n+        }\n+        catch (...)\n+        {\n+            /// As for now it's ok to just overwrite it, because persistency in not essential.\n+            LOG_ERROR(log, \"Cannot read server UUID from file {}: {}. Will overwrite it\",\n+                      server_uuid_file.string(), getCurrentExceptionMessage(true));\n+        }\n+    }\n+\n+    try\n+    {\n+        UUID new_uuid = UUIDHelpers::generateV4();\n+        auto uuid_str = toString(new_uuid);\n+        WriteBufferFromFile out(server_uuid_file);\n+        out.write(uuid_str.data(), uuid_str.size());\n+        out.sync();\n+        out.finalize();\n+        server_uuid = new_uuid;\n+    }\n+    catch (...)\n+    {\n+        throw Exception(ErrorCodes::CANNOT_CREATE_FILE, \"Caught Exception {} while writing the Server UUID file {}\",\n+                        getCurrentExceptionMessage(false), server_uuid_file.string());\n+    }\n+}\n+\n+}\ndiff --git a/src/Core/ServerUUID.h b/src/Core/ServerUUID.h\nnew file mode 100644\nindex 000000000000..36bbf0e63153\n--- /dev/null\n+++ b/src/Core/ServerUUID.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+#include <Core/UUID.h>\n+#include <filesystem>\n+\n+namespace fs = std::filesystem;\n+namespace Poco\n+{\n+    class Logger;\n+}\n+\n+namespace DB\n+{\n+\n+class ServerUUID\n+{\n+    inline static UUID server_uuid = UUIDHelpers::Nil;\n+\n+public:\n+    /// Returns persistent UUID of current clickhouse-server or clickhouse-keeper instance.\n+    static UUID get() { return server_uuid; }\n+\n+    /// Loads server UUID from file or creates new one. Should be called on daemon startup.\n+    static void load(const fs::path & server_uuid_file, Poco::Logger * log);\n+};\n+\n+}\ndiff --git a/src/Functions/registerFunctionsMiscellaneous.cpp b/src/Functions/registerFunctionsMiscellaneous.cpp\nindex 12c54aeeefdc..aed63717155e 100644\n--- a/src/Functions/registerFunctionsMiscellaneous.cpp\n+++ b/src/Functions/registerFunctionsMiscellaneous.cpp\n@@ -78,6 +78,7 @@ void registerFunctionPartitionId(FunctionFactory & factory);\n void registerFunctionIsIPAddressContainedIn(FunctionFactory &);\n void registerFunctionQueryID(FunctionFactory & factory);\n void registerFunctionInitialQueryID(FunctionFactory & factory);\n+void registerFunctionServerUUID(FunctionFactory &);\n \n #if USE_ICU\n void registerFunctionConvertCharset(FunctionFactory &);\n@@ -156,6 +157,7 @@ void registerFunctionsMiscellaneous(FunctionFactory & factory)\n     registerFunctionIsIPAddressContainedIn(factory);\n     registerFunctionQueryID(factory);\n     registerFunctionInitialQueryID(factory);\n+    registerFunctionServerUUID(factory);\n \n #if USE_ICU\n     registerFunctionConvertCharset(factory);\ndiff --git a/src/Functions/serverUUID.cpp b/src/Functions/serverUUID.cpp\nnew file mode 100644\nindex 000000000000..4b70b1576acc\n--- /dev/null\n+++ b/src/Functions/serverUUID.cpp\n@@ -0,0 +1,60 @@\n+#include <Core/ServerUUID.h>\n+#include <DataTypes/DataTypeUUID.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Interpreters/Context.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+class FunctionServerUUID : public IFunction\n+    {\n+    public:\n+        static constexpr auto name = \"serverUUID\";\n+\n+        static FunctionPtr create(ContextPtr context)\n+        {\n+            return std::make_shared<FunctionServerUUID>(context->isDistributed(), ServerUUID::get());\n+        }\n+\n+        explicit FunctionServerUUID(bool is_distributed_, UUID server_uuid_)\n+            : is_distributed(is_distributed_), server_uuid(server_uuid_)\n+        {\n+        }\n+\n+        String getName() const override { return name; }\n+\n+        size_t getNumberOfArguments() const override { return 0; }\n+\n+        DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeUUID>(); }\n+\n+        bool isDeterministic() const override { return false; }\n+\n+        bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n+        bool isSuitableForConstantFolding() const override { return !is_distributed; }\n+\n+        bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override { return false; }\n+\n+        ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override\n+        {\n+            return DataTypeUUID().createColumnConst(input_rows_count, server_uuid);\n+        }\n+\n+    private:\n+        bool is_distributed;\n+        const UUID server_uuid;\n+    };\n+\n+}\n+\n+void registerFunctionServerUUID(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionServerUUID>();\n+}\n+\n+}\n+\n",
  "test_patch": "diff --git a/tests/integration/test_replicated_database/test.py b/tests/integration/test_replicated_database/test.py\nindex 4bcad7de16f7..450caafb9ba3 100644\n--- a/tests/integration/test_replicated_database/test.py\n+++ b/tests/integration/test_replicated_database/test.py\n@@ -305,3 +305,12 @@ def test_startup_without_zk(started_cluster):\n \n     main_node.query(\"EXCHANGE TABLES startup.rmt AND startup.m\")\n     assert main_node.query(\"SELECT (*,).1 FROM startup.m\") == \"42\\n\"\n+\n+\n+def test_server_uuid(started_cluster):\n+    uuid1 = main_node.query(\"select serverUUID()\")\n+    uuid2 = dummy_node.query(\"select serverUUID()\")\n+    assert uuid1 != uuid2\n+    main_node.restart_clickhouse()\n+    uuid1_after_restart = main_node.query(\"select serverUUID()\")\n+    assert uuid1 == uuid1_after_restart\n",
  "problem_statement": "Generate server UUID at first start.\nWrite a file `uuid` in server's data directory that contains random UUID, generated at startup if file does not exist.\r\n\r\nIt will be used for several purposes:\r\n- to anonymously identify server in Sentry (currently Sentry is unusable);\r\n- (possible future usage) to identify server in ensemble.\r\n\r\n@tavplubix comments?\n",
  "hints_text": "why not `FQDN ` with `tcp_port` ?\n> why not `FQDN ` with `tcp_port` ?\r\n\r\nto **anonymously** identify (also fqdn / port can change due some network reconfiguration). \r\n\nBTW: in sentry / collecting anonymous stats context: it can be problematic to use even such anonymous ids without clear user opt-in in some countries (GDPR and similar laws) - using any kind of uniques identifiers / device ids etc. in 'anonimous' statistics is regulated, and should not happen without clear user opt-it. But since sentry is disabled by default i think it's ok - so user need to enable (opt-in) it manually.\nYes, Sentry is opt-in.\r\n\r\nI also first considered using crypto-hash of FQDN, but it can be brute-forced if reverse DNS is available.",
  "created_at": "2021-08-16T18:33:20Z",
  "modified_files": [
    "base/daemon/SentryWriter.cpp",
    "programs/keeper/Keeper.cpp",
    "programs/server/Server.cpp",
    "b/src/Core/ServerUUID.cpp",
    "b/src/Core/ServerUUID.h",
    "src/Functions/registerFunctionsMiscellaneous.cpp",
    "b/src/Functions/serverUUID.cpp"
  ],
  "modified_test_files": [
    "tests/integration/test_replicated_database/test.py"
  ]
}