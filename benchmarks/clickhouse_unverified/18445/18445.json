{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18445,
  "instance_id": "ClickHouse__ClickHouse-18445",
  "issue_numbers": [
    "7673"
  ],
  "base_commit": "b931a153bde323d57c2a84d471101e6d3c04a477",
  "patch": "diff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex 2ef049762f13..ccbccd7105ae 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -162,43 +162,43 @@ template <typename T> class DataTypeNumber;\n template <typename T> class DataTypeDecimal;\n \n \n-template <typename T, typename F>\n-bool callOnIndexAndDataType(TypeIndex number, F && f)\n+template <typename T, typename F, typename... ExtraArgs>\n+bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)\n {\n     switch (number)\n     {\n-        case TypeIndex::UInt8:          return f(TypePair<DataTypeNumber<UInt8>, T>());\n-        case TypeIndex::UInt16:         return f(TypePair<DataTypeNumber<UInt16>, T>());\n-        case TypeIndex::UInt32:         return f(TypePair<DataTypeNumber<UInt32>, T>());\n-        case TypeIndex::UInt64:         return f(TypePair<DataTypeNumber<UInt64>, T>());\n-        case TypeIndex::UInt256:        return f(TypePair<DataTypeNumber<UInt256>, T>());\n-\n-        case TypeIndex::Int8:           return f(TypePair<DataTypeNumber<Int8>, T>());\n-        case TypeIndex::Int16:          return f(TypePair<DataTypeNumber<Int16>, T>());\n-        case TypeIndex::Int32:          return f(TypePair<DataTypeNumber<Int32>, T>());\n-        case TypeIndex::Int64:          return f(TypePair<DataTypeNumber<Int64>, T>());\n-        case TypeIndex::Int128:         return f(TypePair<DataTypeNumber<Int128>, T>());\n-        case TypeIndex::Int256:         return f(TypePair<DataTypeNumber<Int256>, T>());\n-\n-        case TypeIndex::Float32:        return f(TypePair<DataTypeNumber<Float32>, T>());\n-        case TypeIndex::Float64:        return f(TypePair<DataTypeNumber<Float64>, T>());\n-\n-        case TypeIndex::Decimal32:      return f(TypePair<DataTypeDecimal<Decimal32>, T>());\n-        case TypeIndex::Decimal64:      return f(TypePair<DataTypeDecimal<Decimal64>, T>());\n-        case TypeIndex::Decimal128:     return f(TypePair<DataTypeDecimal<Decimal128>, T>());\n-        case TypeIndex::Decimal256:     return f(TypePair<DataTypeDecimal<Decimal256>, T>());\n-\n-        case TypeIndex::Date:           return f(TypePair<DataTypeDate, T>());\n-        case TypeIndex::DateTime:       return f(TypePair<DataTypeDateTime, T>());\n-        case TypeIndex::DateTime64:     return f(TypePair<DataTypeDateTime64, T>());\n-\n-        case TypeIndex::String:         return f(TypePair<DataTypeString, T>());\n-        case TypeIndex::FixedString:    return f(TypePair<DataTypeFixedString, T>());\n-\n-        case TypeIndex::Enum8:          return f(TypePair<DataTypeEnum<Int8>, T>());\n-        case TypeIndex::Enum16:         return f(TypePair<DataTypeEnum<Int16>, T>());\n-\n-        case TypeIndex::UUID:           return f(TypePair<DataTypeUUID, T>());\n+        case TypeIndex::UInt8:          return f(TypePair<DataTypeNumber<UInt8>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::UInt16:         return f(TypePair<DataTypeNumber<UInt16>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::UInt32:         return f(TypePair<DataTypeNumber<UInt32>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::UInt64:         return f(TypePair<DataTypeNumber<UInt64>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::UInt256:        return f(TypePair<DataTypeNumber<UInt256>, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::Int8:           return f(TypePair<DataTypeNumber<Int8>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Int16:          return f(TypePair<DataTypeNumber<Int16>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Int32:          return f(TypePair<DataTypeNumber<Int32>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Int64:          return f(TypePair<DataTypeNumber<Int64>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Int128:         return f(TypePair<DataTypeNumber<Int128>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Int256:         return f(TypePair<DataTypeNumber<Int256>, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::Float32:        return f(TypePair<DataTypeNumber<Float32>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Float64:        return f(TypePair<DataTypeNumber<Float64>, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::Decimal32:      return f(TypePair<DataTypeDecimal<Decimal32>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Decimal64:      return f(TypePair<DataTypeDecimal<Decimal64>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Decimal128:     return f(TypePair<DataTypeDecimal<Decimal128>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Decimal256:     return f(TypePair<DataTypeDecimal<Decimal256>, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::Date:           return f(TypePair<DataTypeDate, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::DateTime:       return f(TypePair<DataTypeDateTime, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::DateTime64:     return f(TypePair<DataTypeDateTime64, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::String:         return f(TypePair<DataTypeString, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::FixedString:    return f(TypePair<DataTypeFixedString, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::Enum8:          return f(TypePair<DataTypeEnum<Int8>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::Enum16:         return f(TypePair<DataTypeEnum<Int16>, T>(), std::forward<ExtraArgs>(args)...);\n+\n+        case TypeIndex::UUID:           return f(TypePair<DataTypeUUID, T>(), std::forward<ExtraArgs>(args)...);\n \n         default:\n             break;\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 92607f718d56..84a41a9c415e 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -108,10 +108,14 @@ struct AccurateOrNullConvertStrategyAdditions\n     UInt32 scale { 0 };\n };\n \n+\n+struct ConvertDefaultBehaviorTag {};\n+struct ConvertReturnNullOnErrorTag {};\n+\n /** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n   *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n   */\n-template <typename FromDataType, typename ToDataType, typename Name>\n+template <typename FromDataType, typename ToDataType, typename Name, typename SpecialTag = ConvertDefaultBehaviorTag>\n struct ConvertImpl\n {\n     using FromFieldType = typename FromDataType::FieldType;\n@@ -279,7 +283,7 @@ struct ConvertImpl\n \n /** Conversion of DateTime to Date: throw off time component.\n   */\n-template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDateTime, DataTypeDate, ToDateImpl> {};\n \n \n@@ -301,7 +305,7 @@ struct ToDateTimeImpl\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDate, DataTypeDateTime, ToDateTimeImpl> {};\n \n /// Implementation of toDate function.\n@@ -357,21 +361,21 @@ struct ToDateTransform8Or16Signed\n   *  when user write toDate(UInt32), expecting conversion of unix timestamp to Date.\n   *  (otherwise such usage would be frequent mistake).\n   */\n-template <typename Name> struct ConvertImpl<DataTypeUInt32, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeUInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeUInt32, DataTypeDate, ToDateTransform32Or64<UInt32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeUInt64, DataTypeDate, ToDateTransform32Or64<UInt64, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeInt8, DataTypeDate, ToDateTransform8Or16Signed<Int8, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeInt16, DataTypeDate, ToDateTransform8Or16Signed<Int16, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeInt32, DataTypeDate, ToDateTransform32Or64Signed<Int32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeInt64, DataTypeDate, ToDateTransform32Or64Signed<Int64, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeFloat32, DataTypeDate, ToDateTransform32Or64Signed<Float32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeFloat64, DataTypeDate, ToDateTransform32Or64Signed<Float64, UInt16>> {};\n \n \n@@ -456,9 +460,9 @@ struct ToDateTime64Transform\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime64, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDate, DataTypeDateTime64, ToDateTime64Transform> {};\n-template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDateTime, DataTypeDateTime64, ToDateTime64Transform> {};\n \n /** Conversion of DateTime64 to Date or DateTime: discards fractional part.\n@@ -481,9 +485,9 @@ struct FromDateTime64Transform\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDate, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate, FromDateTime64Transform<ToDateImpl>> {};\n-template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDateTime, Name>\n+template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag>\n     : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDateTime, FromDateTime64Transform<ToDateTimeImpl>> {};\n \n \n@@ -547,7 +551,7 @@ struct FormatImpl<DataTypeDecimal<FieldType>>\n \n /// DataTypeEnum<T> to DataType<T> free conversion\n template <typename FieldType, typename Name>\n-struct ConvertImpl<DataTypeEnum<FieldType>, DataTypeNumber<FieldType>, Name>\n+struct ConvertImpl<DataTypeEnum<FieldType>, DataTypeNumber<FieldType>, Name, ConvertDefaultBehaviorTag>\n {\n     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/)\n     {\n@@ -557,7 +561,7 @@ struct ConvertImpl<DataTypeEnum<FieldType>, DataTypeNumber<FieldType>, Name>\n \n \n template <typename FromDataType, typename Name>\n-struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType, DataTypeString>, DataTypeString>, Name>\n+struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType, DataTypeString>, DataTypeString>, Name, ConvertDefaultBehaviorTag>\n {\n     using FromFieldType = typename FromDataType::FieldType;\n     using ColVecType = std::conditional_t<IsDecimalNumber<FromFieldType>, ColumnDecimal<FromFieldType>, ColumnVector<FromFieldType>>;\n@@ -974,13 +978,21 @@ struct ConvertThroughParsing\n \n \n template <typename ToDataType, typename Name>\n-struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeString>, DataTypeString>, ToDataType, Name>\n+struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeString>, DataTypeString>, ToDataType, Name, ConvertDefaultBehaviorTag>\n     : ConvertThroughParsing<DataTypeString, ToDataType, Name, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::Normal> {};\n \n template <typename ToDataType, typename Name>\n-struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeFixedString>, DataTypeFixedString>, ToDataType, Name>\n+struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeFixedString>, DataTypeFixedString>, ToDataType, Name, ConvertDefaultBehaviorTag>\n     : ConvertThroughParsing<DataTypeFixedString, ToDataType, Name, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::Normal> {};\n \n+template <typename ToDataType, typename Name>\n+struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeString>, DataTypeString>, ToDataType, Name, ConvertReturnNullOnErrorTag>\n+    : ConvertThroughParsing<DataTypeString, ToDataType, Name, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::Normal> {};\n+\n+template <typename ToDataType, typename Name>\n+struct ConvertImpl<std::enable_if_t<!std::is_same_v<ToDataType, DataTypeFixedString>, DataTypeFixedString>, ToDataType, Name, ConvertReturnNullOnErrorTag>\n+    : ConvertThroughParsing<DataTypeFixedString, ToDataType, Name, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::Normal> {};\n+\n /// Generic conversion of any type from String. Used for complex types: Array and Tuple.\n struct ConvertImplGenericFromString\n {\n@@ -1027,14 +1039,17 @@ struct ConvertImplGenericFromString\n \n \n template <>\n-struct ConvertImpl<DataTypeString, DataTypeUInt32, NameToUnixTimestamp>\n-    : ConvertImpl<DataTypeString, DataTypeDateTime, NameToUnixTimestamp> {};\n+struct ConvertImpl<DataTypeString, DataTypeUInt32, NameToUnixTimestamp, ConvertDefaultBehaviorTag>\n+    : ConvertImpl<DataTypeString, DataTypeDateTime, NameToUnixTimestamp, ConvertDefaultBehaviorTag> {};\n \n+template <>\n+struct ConvertImpl<DataTypeString, DataTypeUInt32, NameToUnixTimestamp, ConvertReturnNullOnErrorTag>\n+    : ConvertImpl<DataTypeString, DataTypeDateTime, NameToUnixTimestamp, ConvertReturnNullOnErrorTag> {};\n \n /** If types are identical, just take reference to column.\n   */\n template <typename T, typename Name>\n-struct ConvertImpl<std::enable_if_t<!T::is_parametric, T>, T, Name>\n+struct ConvertImpl<std::enable_if_t<!T::is_parametric, T>, T, Name, ConvertDefaultBehaviorTag>\n {\n     template <typename Additions = void *>\n     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/,\n@@ -1049,7 +1064,7 @@ struct ConvertImpl<std::enable_if_t<!T::is_parametric, T>, T, Name>\n   * Cutting sequences of zero bytes from end of strings.\n   */\n template <typename Name>\n-struct ConvertImpl<DataTypeFixedString, DataTypeString, Name>\n+struct ConvertImpl<DataTypeFixedString, DataTypeString, Name, ConvertDefaultBehaviorTag>\n {\n     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/)\n     {\n@@ -1153,6 +1168,9 @@ class FunctionConvert : public IFunction\n \n     static constexpr bool to_datetime64 = std::is_same_v<ToDataType, DataTypeDateTime64>;\n \n+    static constexpr bool to_string_or_fixed_string = std::is_same_v<ToDataType, DataTypeFixedString> ||\n+                                                      std::is_same_v<ToDataType, DataTypeString>;\n+\n     static FunctionPtr create(const Context &) { return std::make_shared<FunctionConvert>(); }\n     static FunctionPtr create() { return std::make_shared<FunctionConvert>(); }\n \n@@ -1166,6 +1184,15 @@ class FunctionConvert : public IFunction\n     bool isInjective(const ColumnsWithTypeAndName &) const override { return std::is_same_v<Name, NameToString>; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto getter = [&] (const auto & args) { return getReturnTypeImplRemovedNullable(args); };\n+        auto res = FunctionOverloadResolverAdaptor::getReturnTypeDefaultImplementationForNulls(arguments, getter);\n+        to_nullable = res->isNullable();\n+        checked_return_type = true;\n+        return res;\n+    }\n+\n+    DataTypePtr getReturnTypeImplRemovedNullable(const ColumnsWithTypeAndName & arguments) const\n     {\n         FunctionArgumentDescriptors mandatory_args = {{\"Value\", nullptr, nullptr, nullptr}};\n         FunctionArgumentDescriptors optional_args;\n@@ -1243,6 +1270,11 @@ class FunctionConvert : public IFunction\n         }\n     }\n \n+    /// Function actually uses default implementation for nulls,\n+    /// but we need to know if return type is Nullable or not,\n+    /// so we use checked_return_type only to intercept the first call to getReturnTypeImpl(...).\n+    bool useDefaultImplementationForNulls() const override { return checked_return_type; }\n+\n     bool useDefaultImplementationForConstants() const override { return true; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n     bool canBeExecutedOnDefaultArguments() const override { return false; }\n@@ -1292,6 +1324,9 @@ class FunctionConvert : public IFunction\n     }\n \n private:\n+    mutable bool checked_return_type = false;\n+    mutable bool to_nullable = false;\n+\n     ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n     {\n         if (arguments.empty())\n@@ -1301,11 +1336,12 @@ class FunctionConvert : public IFunction\n         const IDataType * from_type = arguments[0].type.get();\n         ColumnPtr result_column;\n \n-        auto call = [&](const auto & types) -> bool\n+        auto call = [&](const auto & types, const auto & tag) -> bool\n         {\n             using Types = std::decay_t<decltype(types)>;\n             using LeftDataType = typename Types::LeftType;\n             using RightDataType = typename Types::RightType;\n+            using SpecialTag = std::decay_t<decltype(tag)>;\n \n             if constexpr (IsDataTypeDecimal<RightDataType>)\n             {\n@@ -1325,12 +1361,12 @@ class FunctionConvert : public IFunction\n                 const ColumnWithTypeAndName & scale_column = arguments[1];\n                 UInt32 scale = extractToDecimalScale(scale_column);\n \n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count, scale);\n+                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count, scale);\n             }\n             else if constexpr (IsDataTypeDateOrDateTime<RightDataType> && std::is_same_v<LeftDataType, DataTypeDateTime64>)\n             {\n                 const auto * dt64 = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get());\n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n+                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n             }\n             else if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>)\n             {\n@@ -1349,10 +1385,10 @@ class FunctionConvert : public IFunction\n                     throw Exception(\"Wrong UUID conversion\", ErrorCodes::CANNOT_CONVERT_TYPE);\n                 }\n                 else\n-                    result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count);\n+                    result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count);\n             }\n             else\n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name>::execute(arguments, result_type, input_rows_count);\n+                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count);\n \n             return true;\n         };\n@@ -1365,7 +1401,7 @@ class FunctionConvert : public IFunction\n \n             if (to_datetime64 || scale != 0) /// When scale = 0, the data type is DateTime otherwise the data type is DateTime64\n             {\n-                if (!callOnIndexAndDataType<DataTypeDateTime64>(from_type->getTypeId(), call))\n+                if (!callOnIndexAndDataType<DataTypeDateTime64>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{}))\n                     throw Exception(\"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName(),\n                                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n@@ -1373,7 +1409,21 @@ class FunctionConvert : public IFunction\n             }\n         }\n \n-        bool done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call);\n+        bool done;\n+        if constexpr (to_string_or_fixed_string)\n+        {\n+            done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{});\n+        }\n+        else\n+        {\n+            /// We should use ConvertFromStringExceptionMode::Null mode when converting from String (or FixedString)\n+            /// to Nullable type, to avoid 'value is too short' error on attempt to parse empty string from NULL values.\n+            if (to_nullable && WhichDataType(from_type).isStringOrFixedString())\n+                done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertReturnNullOnErrorTag{});\n+            else\n+                done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{});\n+        }\n+\n         if (!done)\n         {\n             /// Generic conversion of any type to String.\ndiff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp\nindex f51c44cf9047..e4a1adb8525a 100644\n--- a/src/Functions/IFunction.cpp\n+++ b/src/Functions/IFunction.cpp\n@@ -465,25 +465,32 @@ void FunctionOverloadResolverAdaptor::checkNumberOfArguments(size_t number_of_ar\n                         ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n }\n \n+\n+DataTypePtr FunctionOverloadResolverAdaptor::getReturnTypeDefaultImplementationForNulls(const ColumnsWithTypeAndName & arguments,\n+                                                                                        const DefaultReturnTypeGetter & getter)\n+{\n+    NullPresence null_presence = getNullPresense(arguments);\n+\n+    if (null_presence.has_null_constant)\n+    {\n+        return makeNullable(std::make_shared<DataTypeNothing>());\n+    }\n+    if (null_presence.has_nullable)\n+    {\n+        Block nested_columns = createBlockWithNestedColumns(arguments);\n+        auto return_type = getter(ColumnsWithTypeAndName(nested_columns.begin(), nested_columns.end()));\n+        return makeNullable(return_type);\n+    }\n+\n+    return getter(arguments);\n+}\n+\n DataTypePtr FunctionOverloadResolverAdaptor::getReturnTypeWithoutLowCardinality(const ColumnsWithTypeAndName & arguments) const\n {\n     checkNumberOfArguments(arguments.size());\n \n     if (!arguments.empty() && impl->useDefaultImplementationForNulls())\n-    {\n-        NullPresence null_presence = getNullPresense(arguments);\n-\n-        if (null_presence.has_null_constant)\n-        {\n-            return makeNullable(std::make_shared<DataTypeNothing>());\n-        }\n-        if (null_presence.has_nullable)\n-        {\n-            Block nested_columns = createBlockWithNestedColumns(arguments);\n-            auto return_type = impl->getReturnType(ColumnsWithTypeAndName(nested_columns.begin(), nested_columns.end()));\n-            return makeNullable(return_type);\n-        }\n-    }\n+        return getReturnTypeDefaultImplementationForNulls(arguments, [&](const auto & args) { return impl->getReturnType(args); });\n \n     return impl->getReturnType(arguments);\n }\ndiff --git a/src/Functions/IFunctionAdaptors.h b/src/Functions/IFunctionAdaptors.h\nindex 737d904f6c91..cbb71c99b1b6 100644\n--- a/src/Functions/IFunctionAdaptors.h\n+++ b/src/Functions/IFunctionAdaptors.h\n@@ -129,6 +129,8 @@ class FunctionOverloadResolverAdaptor final : public IFunctionOverloadResolver\n         return impl->getArgumentsThatDontImplyNullableReturnType(number_of_arguments);\n     }\n \n+    using DefaultReturnTypeGetter = std::function<DataTypePtr(const ColumnsWithTypeAndName &)>;\n+    static DataTypePtr getReturnTypeDefaultImplementationForNulls(const ColumnsWithTypeAndName & arguments, const DefaultReturnTypeGetter & getter);\n private:\n     FunctionOverloadResolverImplPtr impl;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01186_conversion_to_nullable.reference b/tests/queries/0_stateless/01186_conversion_to_nullable.reference\nnew file mode 100644\nindex 000000000000..041466441547\n--- /dev/null\n+++ b/tests/queries/0_stateless/01186_conversion_to_nullable.reference\n@@ -0,0 +1,38 @@\n+42\n+\\N\n+0\n+\\N\n+\\N\n+42\n+\\N\n+0\n+\\N\n+256\n+2020-12-24\n+\\N\n+1970-01-01\n+\\N\n+1970-01-01\n+2020-12-24 01:02:03\n+\\N\n+1970-01-01 03:00:00\n+\\N\n+2020-12-24 01:02:03.00\n+\\N\n+1970-01-01 03:00:00.00\n+1970-01-01 03:00:00.00\n+946721532\n+\\N\n+\\N\n+42.00\n+\\N\n+\\N\n+42.00000000\n+\\N\n+3.14159000\n+42\n+\\N\n+test\n+42\\0\\0\\0\\0\\0\\0\n+\\N\n+test\\0\\0\\0\\0\ndiff --git a/tests/queries/0_stateless/01186_conversion_to_nullable.sql b/tests/queries/0_stateless/01186_conversion_to_nullable.sql\nnew file mode 100644\nindex 000000000000..bf7df6234d22\n--- /dev/null\n+++ b/tests/queries/0_stateless/01186_conversion_to_nullable.sql\n@@ -0,0 +1,13 @@\n+select toUInt8(x) from values('x Nullable(String)', '42', NULL, '0', '', '256');\n+select toInt64(x) from values('x Nullable(String)', '42', NULL, '0', '', '256');\n+\n+select toDate(x) from values('x Nullable(String)', '2020-12-24', NULL, '0000-00-00', '', '9999-01-01');\n+select toDateTime(x) from values('x Nullable(String)', '2020-12-24 01:02:03', NULL, '0000-00-00 00:00:00', '');\n+select toDateTime64(x, 2) from values('x Nullable(String)', '2020-12-24 01:02:03', NULL, '0000-00-00 00:00:00', '');\n+select toUnixTimestamp(x) from values ('x Nullable(String)', '2000-01-01 13:12:12', NULL, '');\n+\n+select toDecimal32(x, 2) from values ('x Nullable(String)', '42', NULL, '3.14159');\n+select toDecimal64(x, 8) from values ('x Nullable(String)', '42', NULL, '3.14159');\n+\n+select toString(x) from values ('x Nullable(String)', '42', NULL, 'test');\n+select toFixedString(x, 8) from values ('x Nullable(String)', '42', NULL, 'test');\n",
  "problem_statement": "toDate(nullif('', '')), toDateTime(nullif('', '')) throws Parsing error\n**Describe the bug or unexpected behaviour**\r\n\r\nWhen casting `nullif('', '')` to `Date`/`DateTime` types using `toDate()`/`toDateTime()` ClickHouse returns exceptions:\r\n\r\n`SQL Error [38]: ClickHouse exception, code: 38, host: *, port: *; Code: 38, e.displayText() = DB::Exception: Cannot parse date: value is too short: Cannot parse Date from String (version 19.15.3.6)`\r\n\r\n`SQL Error [41]: ClickHouse exception, code: 41, host: *, port: *; Code: 41, e.displayText() = DB::Exception: Cannot parse datetime: Cannot parse DateTime from String (version 19.15.3.6)`\r\n\r\n**How to reproduce**\r\n\r\nSome expected results:\r\n\r\n```sql\r\nselect\r\n    toDateTime(NULL)\r\n\r\n\r\ntoDateTime(NULL)\r\n----------------\r\n[NULL]          \r\n```\r\n\r\n```sql    \r\nselect\r\n    toDateTime('')\r\n\r\n\r\nSQL Error [41]: ClickHouse exception, code: 41, host: *, port: *; Code: 41, e.displayText() = DB::Exception: Cannot parse datetime: Cannot parse DateTime from String (version 19.15.3.6)\r\n```\r\n\r\n```sql    \r\nselect\r\n    nullif('', '')\r\n\r\n\r\nnullif('', '')\r\n--------------\r\n[NULL]        \r\n```\r\n    \r\n```sql    \r\nselect\r\n    toDateTime(nullif(1, 1))\r\n\r\n\r\ntoDateTime(nullif(1, 1))\r\n------------------------\r\n                  [NULL]\r\n```\r\n\r\n\r\n```sql        \r\nselect\r\n    toDateTimeOrNull(nullif('', ''))\r\n\r\n\r\ntoDateTimeOrNull(nullif('', ''))\r\n--------------------------------\r\n                          [NULL]\r\n```\r\n\r\nUnexpected behavior:\r\n\r\n```sql    \r\nselect\r\n    toDateTime(nullif('', ''))\r\n\r\n\r\nSQL Error [41]: ClickHouse exception, code: 41, host: *, port: *; Code: 41, e.displayText() = DB::Exception: Cannot parse datetime: Cannot parse DateTime from String (version 19.15.3.6)\r\n```\r\n\r\n```sql                          \r\nselect\r\n    toDate(nullif('', ''))\r\n\r\n\r\nSQL Error [38]: ClickHouse exception, code: 38, host: *, port: *; Code: 38, e.displayText() = DB::Exception: Cannot parse date: value is too short: Cannot parse Date from String (version 19.15.3.6)\r\n```\r\n\r\n**Expected behavior**\r\n\r\n```sql        \r\nselect\r\n    toDateTime(nullif('', ''))\r\n\r\n\r\ntoDateTime(nullif('', ''))\r\n--------------------------------\r\n                          [NULL]\r\n```\r\n\n",
  "hints_text": "Clickhouse calculates both branches (if and else) for PERFORMANCE.\r\n```\r\n\r\nSELECT parseDateTimeBestEffortOrNull(nullIf('', ''))\r\n\r\n\u250c\u2500parseDateTimeBestEffortOrNull(nullIf('', ''))\u2500\u2510\r\n\u2502                                          \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\n@den-crane it's not the case here.\r\nIt looks like it just tries to take String from Nullable(String), ignoring the Nullable.  \r\n\r\n```\r\nSELECT toDateTime(CAST(NULL, 'Nullable(String)'))\r\n\r\nReceived exception from server (version 19.16.1):\r\nCode: 41. DB::Exception: Received from localhost:9000. DB::Exception: Cannot parse datetime: Cannot parse DateTime from String. \r\n\r\nlaptop5591.local :) select toDateTime(CAST(Null, 'Nullable(Nothing)'));\r\n\r\nSELECT toDateTime(CAST(NULL, 'Nullable(Nothing)'))\r\n\r\n\u250c\u2500toDateTime(CAST(NULL, 'Nullable(Nothing)'))\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38                                        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.004 sec. \r\n```\r\n\nThe issue is still there:\r\n```\r\nSELECT toDateTime(CAST(NULL, 'Nullable(String)'))\r\n\r\n\r\nReceived exception from server (version 20.6.1):\r\nCode: 41. DB::Exception: Received from localhost:9000. DB::Exception: Cannot parse datetime: Cannot parse DateTime from String. \r\n\r\n0 rows in set. Elapsed: 0.012 sec. \r\n```\nWorkaround: `toDateTimeOrZero`.\nDepends on #12587.",
  "created_at": "2020-12-23T21:59:03Z",
  "modified_files": [
    "src/Core/callOnTypeIndex.h",
    "src/Functions/FunctionsConversion.h",
    "src/Functions/IFunction.cpp",
    "src/Functions/IFunctionAdaptors.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01186_conversion_to_nullable.reference",
    "b/tests/queries/0_stateless/01186_conversion_to_nullable.sql"
  ]
}