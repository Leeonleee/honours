{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 74482,
  "instance_id": "ClickHouse__ClickHouse-74482",
  "issue_numbers": [
    "63096"
  ],
  "base_commit": "e43c9e53ae103b03fb153e4fdd6381187a25bc51",
  "patch": "diff --git a/docs/en/sql-reference/functions/arithmetic-functions.md b/docs/en/sql-reference/functions/arithmetic-functions.md\nindex e57358c1e363..49ee8448a54a 100644\n--- a/docs/en/sql-reference/functions/arithmetic-functions.md\n+++ b/docs/en/sql-reference/functions/arithmetic-functions.md\n@@ -55,6 +55,8 @@ Calculates the difference of two values `a` and `b`. The result is always signed\n \n Similar to `plus`, it is possible to subtract an integer from a date or date with time.\n \n+Additionally, subtraction between date with time is supported, resulting in the time difference between them.\n+\n **Syntax**\n \n ```sql\ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 1563a18b2fb3..bafa0d52c559 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -1078,6 +1078,20 @@ class FunctionBinaryArithmetic : public IFunction\n         return which0.isAggregateFunction() && which1.isAggregateFunction();\n     }\n \n+    static bool isDateTime64Subtraction(const DataTypePtr & type0, const DataTypePtr & type1)\n+    {\n+        if constexpr (!is_minus)\n+            return false;\n+\n+        WhichDataType which0(type0);\n+        WhichDataType which1(type1);\n+\n+        if (which0.isDateTime64() && which1.isDateTimeOrDateTime64())\n+            return true;\n+\n+        return which1.isDateTime64() && which0.isDateTimeOrDateTime64();\n+    }\n+\n     /// Multiply aggregation state by integer constant: by merging it with itself specified number of times.\n     ColumnPtr executeAggregateMultiply(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const\n     {\n@@ -1176,6 +1190,105 @@ class FunctionBinaryArithmetic : public IFunction\n         return column_to;\n     }\n \n+    ColumnPtr executeDateTime64Subtraction(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n+                                           size_t input_row_count) const\n+    {\n+        using OpImplCheck = DecimalBinaryOperation<Op, Decimal64, /* check_overflow */ true>;\n+        using OpImpl = DecimalBinaryOperation<Op, Decimal64, /* check_overflow */ false>;\n+        using ColumnDateTime64 = DataTypeDateTime64::ColumnType;\n+        using ColumnDateTime = DataTypeDateTime::ColumnType;\n+\n+        struct ColumnInfo\n+        {\n+            explicit ColumnInfo(const ColumnWithTypeAndName & argument_) : argument(argument_), converted_col(nullptr) {}\n+            const ColumnWithTypeAndName & argument;\n+            const ColumnDateTime64 * col;\n+            ColumnPtr converted_col;\n+            UInt64 const_val;\n+            bool is_const;\n+            UInt64 scale;\n+        } cols[2]{ColumnInfo{arguments[0]}, ColumnInfo{arguments[1]}};\n+\n+        const auto * type = checkAndGetDataType<DataTypeDecimal<Decimal64>>(result_type.get());\n+        if (!type)\n+            return nullptr;\n+\n+        /// Process column information for both arguments\n+        auto process = [type] (struct ColumnInfo & to_be_checked, const DataTypePtr & other_type)\n+        {\n+            const auto * col_raw = to_be_checked.argument.column.get();\n+            to_be_checked.is_const = isColumnConst(*col_raw);\n+\n+            if (to_be_checked.is_const)\n+            {\n+                if (WhichDataType(to_be_checked.argument.type).isDateTime())\n+                {\n+                    to_be_checked.const_val = checkAndGetColumnConst<ColumnDateTime>(col_raw)->template getValue<UInt32>();\n+                    /// the output type is the same as the other argument, which is DateTime64\n+                    to_be_checked.scale = type->getScaleMultiplier();\n+                }\n+                else\n+                {\n+                    to_be_checked.const_val = checkAndGetColumnConst<ColumnDateTime64>(col_raw)->template getValue<Decimal64>().value;\n+                    const auto & from_type = *checkAndGetDataType<DataTypeDateTime64>(to_be_checked.argument.type.get());\n+                    to_be_checked.scale = type->scaleFactorFor(from_type, /* is_multiply_or_divisor */ false);\n+                }\n+            }\n+            else\n+            {\n+                if (WhichDataType(to_be_checked.argument.type).isDateTime())\n+                {\n+                    to_be_checked.converted_col = castColumn(to_be_checked.argument, other_type);\n+                    to_be_checked.col = checkAndGetColumn<ColumnDateTime64>(to_be_checked.converted_col.get());\n+                    /// the DateTime argument is already scaled up by calling castColumn\n+                    to_be_checked.scale = 1;\n+                }\n+                else\n+                {\n+                    to_be_checked.col = checkAndGetColumn<ColumnDateTime64>(col_raw);\n+                    const auto & from_type = *checkAndGetDataType<DataTypeDateTime64>(to_be_checked.argument.type.get());\n+                    to_be_checked.scale = type->scaleFactorFor(from_type, /* is_multiply_or_divisor */ false);\n+                }\n+\n+                if (!to_be_checked.col)\n+                    return false;\n+            }\n+            return true;\n+        };\n+\n+        /// Process both columns\n+        if (!process(cols[0], cols[1].argument.type))\n+            return nullptr;\n+        if (!process(cols[1], cols[0].argument.type))\n+            return nullptr;\n+\n+        /// Handle constant values\n+        if (cols[0].is_const && cols[1].is_const)\n+        {\n+            auto res = helperInvokeEither</* left_is_decimal */ true, /* right_is_decimal */ true, OpImpl, OpImplCheck, Decimal64>(\n+                cols[0].const_val, cols[1].const_val, cols[0].scale, cols[1].scale);\n+            return type->createColumnConst(input_row_count, toField(res, type->getScale()));\n+        }\n+\n+        auto col_res = ColumnDecimal<Decimal64>::create(input_row_count, type->getScale());\n+        auto & vec_res = col_res->getData();\n+\n+        auto invoke = [&]<OpCase op_case>(const auto& col0, const auto& col1)\n+        {\n+            helperInvokeEither<op_case, /* left_is_decimal */ true, /* right_is_decimal */ true, OpImpl, OpImplCheck>(\n+                col0, col1, vec_res, cols[0].scale, cols[1].scale, nullptr);\n+        };\n+        /// Process based on whether the column is constant or not\n+        if (cols[0].is_const)\n+            invoke.template operator()<OpCase::LeftConstant>(cols[0].const_val, cols[1].col->getData());\n+        else if (cols[1].is_const)\n+            invoke.template operator()<OpCase::RightConstant>(cols[0].col->getData(), cols[1].const_val);\n+        else\n+            invoke.template operator()<OpCase::Vector>(cols[0].col->getData(), cols[1].col->getData());\n+\n+        return col_res;\n+    }\n+\n     ColumnPtr executeDateTimeIntervalPlusMinus(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n                                                size_t input_rows_count, const FunctionOverloadResolverPtr & function_builder) const\n     {\n@@ -1373,6 +1486,16 @@ class FunctionBinaryArithmetic : public IFunction\n             OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);\n     }\n \n+    template <bool left_decimal, bool right_decimal, typename OpImpl, typename OpImplCheck, typename ResultType, typename A, typename B>\n+    ResultType helperInvokeEither(A a, B b, auto scale_a, auto scale_b) const\n+        requires(!is_decimal<A> && !is_decimal<B>)\n+    {\n+        if (check_decimal_overflow)\n+            return OpImplCheck::template process<left_decimal, right_decimal>(a, b, scale_a, scale_b);\n+        else\n+            return OpImpl::template process<left_decimal, right_decimal>(a, b, scale_a, scale_b);\n+    }\n+\n     template <class LeftDataType, class RightDataType, class ResultDataType>\n     ColumnPtr executeNumericWithDecimal(\n         const auto & left, const auto & right,\n@@ -1432,9 +1555,10 @@ class FunctionBinaryArithmetic : public IFunction\n \n             ResultType res = {};\n             if (!right_nullmap || !(*right_nullmap)[0])\n-                res = check_decimal_overflow\n-                    ? OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)\n-                    : OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b);\n+            {\n+                res = helperInvokeEither<left_is_decimal, right_is_decimal, OpImpl, OpImplCheck, ResultType>(\n+                     const_a, const_b, scale_a, scale_b);\n+            }\n \n             return ResultDataType(type.getPrecision(), type.getScale())\n                 .createColumnConst(col_left_const->size(), toField(res, type.getScale()));\n@@ -1561,6 +1685,24 @@ class FunctionBinaryArithmetic : public IFunction\n             }\n         }\n \n+        /// Special case when the function is minus, both arguments are DateTime64.\n+        if (isDateTime64Subtraction(arguments[0], arguments[1]))\n+        {\n+            UInt32 scale_lhs = 0;\n+            UInt32 scale_rhs = 0;\n+            if (isDateTime64(arguments[0]))\n+            {\n+                const auto *lhs = checkAndGetDataType<DataTypeDateTime64>(arguments[0].get());\n+                scale_lhs = lhs->getScale();\n+            }\n+            if (isDateTime64(arguments[1]))\n+            {\n+                const auto *rhs = checkAndGetDataType<DataTypeDateTime64>(arguments[1].get());\n+                scale_rhs = rhs->getScale();\n+            }\n+            return std::make_shared<DataTypeDecimal64>(DecimalUtils::max_precision<DateTime64>, std::max(scale_lhs, scale_rhs));\n+        }\n+\n         if constexpr (is_multiply || is_division)\n         {\n             if (isArray(arguments[0]) && isNumber(arguments[1]))\n@@ -2228,6 +2370,12 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n             return executeAggregateAddition(arguments, result_type, input_rows_count);\n         }\n \n+        /// Special case when the function is minus, both arguments are DateTime64.\n+        if (isDateTime64Subtraction(arguments[0].type, arguments[1].type))\n+        {\n+            return executeDateTime64Subtraction(arguments, result_type, input_rows_count);\n+        }\n+\n         /// Special case when the function is plus or minus, one of arguments is Date/DateTime/String and another is Interval.\n         if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context))\n         {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\nindex 74b7b2076614..6216837da32f 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n@@ -361,7 +361,7 @@ SELECT formatDateTime(N, \\'%C %d %D %e %F %H %I %j %m %i %p %R %S %T %u %V %w %y\n SELECT N -  N\n \"Int32\",0\n \"Int32\",0\n-Code: 43\n+\"Decimal(18, 3)\",0\n ------------------------------------------\n SELECT N +  N\n Code: 43\n@@ -401,12 +401,12 @@ SELECT N >= N\n SELECT N - DT\n Code: 43\n \"Int32\",0\n-Code: 43\n+\"Decimal(18, 3)\",0.234\n ------------------------------------------\n SELECT DT - N\n Code: 43\n \"Int32\",0\n-Code: 43\n+\"Decimal(18, 3)\",-0.234\n ------------------------------------------\n SELECT N - D\n \"Int32\",0\n@@ -420,13 +420,13 @@ Code: 43\n ------------------------------------------\n SELECT N - DT64\n Code: 43\n-Code: 43\n-Code: 43\n+\"Decimal(18, 3)\",-0.234\n+\"Decimal(18, 3)\",0\n ------------------------------------------\n SELECT DT64 - N\n Code: 43\n-Code: 43\n-Code: 43\n+\"Decimal(18, 3)\",0.234\n+\"Decimal(18, 3)\",0\n ------------------------------------------\n SELECT N != DT\n \"UInt8\",1\ndiff --git a/tests/queries/0_stateless/02156_minus_op_with_datatime64.reference b/tests/queries/0_stateless/02156_minus_op_with_datatime64.reference\nnew file mode 100644\nindex 000000000000..20ff00f9776c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02156_minus_op_with_datatime64.reference\n@@ -0,0 +1,4 @@\n+3600\t3600.123\t90000\t3599.999544\t3600.000456\t3600\t3600\n+3600\t3600.123\t90000\t3599.999544\t3600.000456\t3600\t3600\n+3600\t3600.123\t3600\t3600\n+3600\t3600.123\t3600\t3600\ndiff --git a/tests/queries/0_stateless/02156_minus_op_with_datatime64.sql b/tests/queries/0_stateless/02156_minus_op_with_datatime64.sql\nnew file mode 100644\nindex 000000000000..968593f5d2ee\n--- /dev/null\n+++ b/tests/queries/0_stateless/02156_minus_op_with_datatime64.sql\n@@ -0,0 +1,65 @@\n+-- Test subtraction without materialize()\n+SELECT\n+-- DateTime64 (scale 3) - DateTime\n+toDateTime64('2023-10-01 12:00:00', 3) - toDateTime('2023-10-01 11:00:00') AS result_no_materialize_1,\n+toDateTime64('2023-10-01 12:00:00.123', 3) - toDateTime('2023-10-01 11:00:00') AS result_no_materialize_2,\n+\n+-- DateTime64 (scale 0) - DateTime\n+toDateTime64('2023-10-02 12:00:00', 0) - toDateTime('2023-10-01 11:00:00') AS result_no_materialize_3,\n+\n+-- DateTime64 (scale 3) - DateTime64 (scale 6)\n+toDateTime64('2023-10-01 12:00:00.123', 3) - toDateTime64('2023-10-01 11:00:00.123456', 6) AS result_no_materialize_4,\n+\n+-- DateTime64 (scale 6) - DateTime64 (scale 3)\n+toDateTime64('2023-10-01 12:00:00.123456', 6) - toDateTime64('2023-10-01 11:00:00.123', 3) AS result_no_materialize_5,\n+\n+-- DateTime - DateTime64 (scale 3)\n+toDateTime('2023-10-01 12:00:00') - toDateTime64('2023-10-01 11:00:00', 3) AS result_no_materialize_6,\n+\n+-- DateTime - DateTime64 (scale 6)\n+toDateTime('2023-10-01 12:00:00') - toDateTime64('2023-10-01 11:00:00', 6) AS result_no_materialize_7;\n+\n+-- Test subtraction with materialize() on left side\n+SELECT\n+materialize(toDateTime64('2023-10-01 12:00:00', 3)) - toDateTime('2023-10-01 11:00:00') AS result_left_materialize_1,\n+materialize(toDateTime64('2023-10-01 12:00:00.123', 3)) - toDateTime('2023-10-01 11:00:00') AS result_left_materialize_2,\n+\n+materialize(toDateTime64('2023-10-02 12:00:00', 0)) - toDateTime('2023-10-01 11:00:00') AS result_left_materialize_3,\n+\n+materialize(toDateTime64('2023-10-01 12:00:00.123', 3)) - toDateTime64('2023-10-01 11:00:00.123456', 6) AS result_left_materialize_4,\n+\n+materialize(toDateTime64('2023-10-01 12:00:00.123456', 6)) - toDateTime64('2023-10-01 11:00:00.123', 3) AS result_left_materialize_5,\n+\n+materialize(toDateTime('2023-10-01 12:00:00')) - toDateTime64('2023-10-01 11:00:00', 3) AS result_left_materialize_6,\n+\n+materialize(toDateTime('2023-10-01 12:00:00')) - toDateTime64('2023-10-01 11:00:00', 6) AS result_left_materialize_7;\n+\n+-- Test subtraction with materialize() on right side\n+SELECT\n+toDateTime64('2023-10-01 12:00:00', 3) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_right_materialize_1,\n+toDateTime64('2023-10-01 12:00:00.123', 3) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_right_materialize_2,\n+\n+toDateTime64('2023-10-01 12:00:00', 0) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_right_materialize_3,\n+\n+toDateTime('2023-10-01 12:00:00') - materialize(toDateTime64('2023-10-01 11:00:00', 3)) AS result_right_materialize_4;\n+\n+-- Test subtraction with materialize() on both sides\n+SELECT\n+materialize(toDateTime64('2023-10-01 12:00:00', 3)) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_both_materialize_1,\n+materialize(toDateTime64('2023-10-01 12:00:00.123', 3)) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_both_materialize_2,\n+\n+materialize(toDateTime64('2023-10-01 12:00:00', 0)) - materialize(toDateTime('2023-10-01 11:00:00')) AS result_both_materialize_3,\n+\n+materialize(toDateTime('2023-10-01 12:00:00')) - materialize(toDateTime64('2023-10-01 11:00:00', 3)) AS result_both_materialize_4;\n+\n+-- Test overflow\n+SELECT\n+materialize(toDateTime64('2262-04-11 23:47:16', 9, 'UTC')) - toDateTime64('1900-01-01 00:00:00', 9, 'UTC') FORMAT Null; -- { serverError DECIMAL_OVERFLOW }\n+\n+SELECT\n+materialize(toDateTime64('1900-01-01 00:00:00', 0, 'UTC')) - materialize(toDateTime64('2262-04-11 23:47:16', 9, 'UTC')); -- { serverError DECIMAL_OVERFLOW }\n+\n+SELECT\n+materialize(toDateTime64('2262-04-11 23:47:16', 9, 'UTC')) - toDateTime64('1900-01-01 00:00:00', 9, 'UTC'),\n+materialize(toDateTime64('1900-01-01 00:00:00', 0, 'UTC')) - materialize(toDateTime64('2262-04-11 23:47:16', 9, 'UTC'))\n+SETTINGS decimal_check_overflow=0 FORMAT Null;\n",
  "problem_statement": "Operator `minus` does not work for `DateTime64`\n**Use case**\r\n\r\n```\r\nclickhouse-cloud :) SELECT now() AS a, now() - 1 AS b, a - b\r\n\r\nSELECT\r\n    now() AS a,\r\n    now() - 1 AS b,\r\n    a - b\r\n\r\nQuery id: ed2a7e1f-365c-4c74-8678-ca1e96aa5049\r\n\r\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500b\u2500\u252c\u2500minus(a, b)\u2500\u2510\r\n1. \u2502 2024-04-29 00:23:31 \u2502 2024-04-29 00:23:30 \u2502           1 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.002 sec. \r\n\r\nclickhouse-cloud :) SELECT now64(3) AS a, now64(3) - 1 AS b, a - b\r\n\r\nSELECT\r\n    now64(3) AS a,\r\n    now64(3) - 1 AS b,\r\n    a - b\r\n\r\nQuery id: 78f11218-c578-43d6-a909-5d53b229edf5\r\n\r\n\r\nElapsed: 0.061 sec. \r\n\r\nReceived exception from server (version 24.2.2):\r\nCode: 43. DB::Exception: Received from kvzqttvc2n.eu-west-1.aws.clickhouse-staging.com:9440. DB::Exception: Illegal types DateTime64(3) and DateTime64(3) of arguments of function minus: In scope SELECT now64(3) AS a, now64(3) - 1 AS b, a - b. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\nIt should work and return Decimal64.\n",
  "hints_text": "Hi @alexey-milovidov , I would like to try this issue\n@Eternity-AIBN are you looking at this ? Can I pick this instead ?\n> @Eternity-AIBN are you looking at this ? Can I pick this instead ?\r\n\r\nOh, I've been coding this part for the past two days.\nHey @Eternity-AIBN , would like to get this solved if you are not working on this. Can I pick this? \n@iamskp11, I don't see any activity from @Eternity-AIBN, I will be happy if you can take it!\nHello, is there any activity on this? I am currently a student at the University of Michigan in a software engineering class. The final project is to contribute to an open-source project and report my process.  I would love to try this issue if possible. \n@samuelpwlim, I didn't notice any recent activity. It will be very appreciated if you take this, and we will be happy to help!",
  "created_at": "2025-01-11T17:25:25Z",
  "modified_files": [
    "docs/en/sql-reference/functions/arithmetic-functions.md",
    "src/Functions/FunctionBinaryArithmetic.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00921_datetime64_compatibility_long.reference",
    "b/tests/queries/0_stateless/02156_minus_op_with_datatime64.reference",
    "b/tests/queries/0_stateless/02156_minus_op_with_datatime64.sql"
  ]
}