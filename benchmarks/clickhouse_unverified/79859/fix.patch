diff --git a/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h b/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h
index 125b9ca54f30..adee1a6edccd 100644
--- a/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h
+++ b/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h
@@ -2,11 +2,11 @@
 
 #include <AggregateFunctions/IAggregateFunction.h>
 #include <AggregateFunctions/KeyHolderHelpers.h>
-#include <Common/assert_cast.h>
 #include <DataTypes/DataTypeArray.h>
-#include <Common/HashTable/HashSet.h>
-#include <Common/HashTable/HashMap.h>
 #include <IO/ReadHelpersArena.h>
+#include <Common/HashTable/HashMap.h>
+#include <Common/HashTable/HashSet.h>
+#include <Common/assert_cast.h>
 
 
 namespace DB
@@ -20,37 +20,39 @@ struct AggregateFunctionDistinctSingleNumericData
     /// When creating, the hash table must be small.
     using Set = HashSetWithStackMemory<T, DefaultHash<T>, 4>;
     using Self = AggregateFunctionDistinctSingleNumericData<T>;
-    Set set;
 
-    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena *)
+    /// history will hold all values added so far
+    Set history;
+
+    /// Returns true if the value did not exist in the history before
+    bool add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena *)
     {
         const auto & vec = assert_cast<const ColumnVector<T> &>(*columns[0]).getData();
-        set.insert(vec[row_num]);
+        const T value = vec[row_num];
+        return history.insert(value).second;
     }
 
-    void merge(const Self & rhs, Arena *)
+    /// Pass the new values from rhs to the nested function via argument_columns
+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena *)
     {
-        set.merge(rhs.set);
+        for (const auto & elem : rhs.history)
+        {
+            const auto & value = elem.getValue();
+            bool inserted = history.insert(value).second;
+
+            if (inserted)
+                argument_columns[0]->insert(value);
+        }
     }
 
     void serialize(WriteBuffer & buf) const
     {
-        set.write(buf);
+        history.write(buf);
     }
 
     void deserialize(ReadBuffer & buf, Arena *)
     {
-        set.read(buf);
-    }
-
-    MutableColumns getArguments(const DataTypes & argument_types) const
-    {
-        MutableColumns argument_columns;
-        argument_columns.emplace_back(argument_types[0]->createColumn());
-        for (const auto & elem : set)
-            argument_columns[0]->insert(elem.getValue());
-
-        return argument_columns;
+        history.read(buf);
     }
 };
 
@@ -59,20 +61,13 @@ struct AggregateFunctionDistinctGenericData
     /// When creating, the hash table must be small.
     using Set = HashSetWithSavedHashWithStackMemory<StringRef, StringRefHash, 4>;
     using Self = AggregateFunctionDistinctGenericData;
-    Set set;
 
-    void merge(const Self & rhs, Arena * arena)
-    {
-        Set::LookupResult it;
-        bool inserted;
-        for (const auto & elem : rhs.set)
-            set.emplace(ArenaKeyHolder{elem.getValue(), *arena}, it, inserted);
-    }
+    Set history;
 
     void serialize(WriteBuffer & buf) const
     {
-        writeVarUInt(set.size(), buf);
-        for (const auto & elem : set)
+        writeVarUInt(history.size(), buf);
+        for (const auto & elem : history)
             writeStringBinary(elem.getValue(), buf);
     }
 
@@ -81,35 +76,41 @@ struct AggregateFunctionDistinctGenericData
         size_t size;
         readVarUInt(size, buf);
         for (size_t i = 0; i < size; ++i)
-            set.insert(readStringBinaryInto(*arena, buf));
+            history.insert(readStringBinaryInto(*arena, buf));
     }
 };
 
 template <bool is_plain_column>
 struct AggregateFunctionDistinctSingleGenericData : public AggregateFunctionDistinctGenericData
 {
-    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena * arena)
+    bool add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena * arena)
     {
+        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);
         Set::LookupResult it;
         bool inserted;
-        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);
-        set.emplace(key_holder, it, inserted);
+        history.emplace(key_holder, it, inserted);
+
+        return inserted;
     }
 
-    MutableColumns getArguments(const DataTypes & argument_types) const
+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena * arena)
     {
-        MutableColumns argument_columns;
-        argument_columns.emplace_back(argument_types[0]->createColumn());
-        for (const auto & elem : set)
-            deserializeAndInsert<is_plain_column>(elem.getValue(), *argument_columns[0]);
+        for (const auto & elem : rhs.history)
+        {
+            const auto & value = elem.getValue();
+            Set::LookupResult it;
+            bool inserted;
+            history.emplace(ArenaKeyHolder{value, *arena}, it, inserted);
 
-        return argument_columns;
+            if (inserted)
+                deserializeAndInsert<is_plain_column>(it->getValue(), *argument_columns[0]);
+        }
     }
 };
 
 struct AggregateFunctionDistinctMultipleGenericData : public AggregateFunctionDistinctGenericData
 {
-    void add(const IColumn ** columns, size_t columns_num, size_t row_num, Arena * arena)
+    bool add(const IColumn ** columns, size_t columns_num, size_t row_num, Arena * arena)
     {
         const char * begin = nullptr;
         StringRef value(begin, 0);
@@ -122,24 +123,26 @@ struct AggregateFunctionDistinctMultipleGenericData : public AggregateFunctionDi
 
         Set::LookupResult it;
         bool inserted;
-        auto key_holder = SerializedKeyHolder{value, *arena};
-        set.emplace(key_holder, it, inserted);
+        history.emplace(SerializedKeyHolder{value, *arena}, it, inserted);
+
+        return inserted;
     }
 
-    MutableColumns getArguments(const DataTypes & argument_types) const
+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena * arena)
     {
-        MutableColumns argument_columns(argument_types.size());
-        for (size_t i = 0; i < argument_types.size(); ++i)
-            argument_columns[i] = argument_types[i]->createColumn();
-
-        for (const auto & elem : set)
+        for (const auto & elem : rhs.history)
         {
-            const char * begin = elem.getValue().data;
-            for (auto & column : argument_columns)
-                begin = column->deserializeAndInsertFromArena(begin);
+            const auto & value = elem.getValue();
+            if (!history.contains(value))
+            {
+                Set::LookupResult it;
+                bool inserted;
+                history.emplace(ArenaKeyHolder{value, *arena}, it, inserted);
+                const char * pos = it->getValue().data;
+                for (auto & column : argument_columns)
+                    pos = column->deserializeAndInsertFromArena(pos);
+            }
         }
-
-        return argument_columns;
     }
 };
 
@@ -164,6 +167,31 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data
         return place + prefix_size;
     }
 
+    MutableColumns prepareArgumentColumns() const
+    {
+        MutableColumns argument_columns;
+        argument_columns.reserve(this->argument_types.size());
+        for (const auto & type : this->argument_types)
+            argument_columns.emplace_back(type->createColumn());
+
+        return argument_columns;
+    }
+
+    void addToNested(size_t row_begin, size_t row_end, AggregateDataPtr __restrict place, const IColumn ** columns, Arena * arena) const
+    {
+        nested_func->addBatchSinglePlace(row_begin, row_end, getNestedPlace(place), columns, arena);
+    }
+
+    void addToNested(AggregateDataPtr __restrict place, const MutableColumns & argument_columns, Arena * arena) const
+    {
+        ColumnRawPtrs arguments_raw(argument_columns.size());
+        for (size_t i = 0; i < argument_columns.size(); ++i)
+            arguments_raw[i] = argument_columns[i].get();
+
+        assert(!argument_columns.empty());
+        addToNested(0, argument_columns[0]->size(), place, arguments_raw.data(), arena);
+    }
+
 public:
     AggregateFunctionDistinct(AggregateFunctionPtr nested_func_, const DataTypes & arguments, const Array & params_)
     : IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct>(arguments, params_, nested_func_->getResultType())
@@ -176,12 +204,16 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data
 
     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override
     {
-        this->data(place).add(columns, arguments_num, row_num, arena);
+        bool added = this->data(place).add(columns, arguments_num, row_num, arena);
+        if (added)
+            addToNested(row_num, row_num + 1, place, columns, arena);
     }
 
     void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena * arena) const override
     {
-        this->data(place).merge(this->data(rhs), arena);
+        auto argument_columns = prepareArgumentColumns();
+        this->data(place).merge(this->data(rhs), argument_columns, arena);
+        addToNested(place, argument_columns, arena);
     }
 
     void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override
@@ -194,30 +226,14 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data
         this->data(place).deserialize(buf, arena);
     }
 
-    template <bool MergeResult>
-    void insertResultIntoImpl(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const
-    {
-        auto arguments = this->data(place).getArguments(this->argument_types);
-        ColumnRawPtrs arguments_raw(arguments.size());
-        for (size_t i = 0; i < arguments.size(); ++i)
-            arguments_raw[i] = arguments[i].get();
-
-        assert(!arguments.empty());
-        nested_func->addBatchSinglePlace(0, arguments[0]->size(), getNestedPlace(place), arguments_raw.data(), arena);
-        if constexpr (MergeResult)
-            nested_func->insertMergeResultInto(getNestedPlace(place), to, arena);
-        else
-            nested_func->insertResultInto(getNestedPlace(place), to, arena);
-    }
-
     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const override
     {
-        insertResultIntoImpl<false>(place, to, arena);
+        nested_func->insertResultInto(getNestedPlace(place), to, arena);
     }
 
     void insertMergeResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const override
     {
-        insertResultIntoImpl<true>(place, to, arena);
+        nested_func->insertMergeResultInto(getNestedPlace(place), to, arena);
     }
 
     size_t sizeOfData() const override
diff --git a/src/Functions/toDecimalString.cpp b/src/Functions/toDecimalString.cpp
index eb607127fc5e..8feee5ee604c 100644
--- a/src/Functions/toDecimalString.cpp
+++ b/src/Functions/toDecimalString.cpp
@@ -182,8 +182,8 @@ class FunctionToDecimalString : public IFunction
             writeChar('.', out);
             for (int i = 0; i < precision; ++i)
                 writeChar('0', out);
-            writeChar(0, out);
         }
+        writeChar(0, out);
     }
 
 public:
