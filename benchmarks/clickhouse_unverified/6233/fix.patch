diff --git a/dbms/src/Functions/intDiv.h b/dbms/src/Functions/intDiv.h
index 566a80106391..0cbe612c6e1f 100644
--- a/dbms/src/Functions/intDiv.h
+++ b/dbms/src/Functions/intDiv.h
@@ -55,7 +55,13 @@ struct DivideIntegralImpl
     static inline Result apply(A a, B b)
     {
         throwIfDivisionLeadsToFPE(a, b);
-        return a / b;
+
+        /// Otherwise overflow may occur due to integer promotion. Example: int8_t(-1) / uint64_t(2).
+        /// NOTE: overflow is still possible when dividing large signed number to large unsigned number or vice-versa. But it's less harmful.
+        if constexpr (std::is_integral_v<A> && std::is_integral_v<B> && (std::is_signed_v<A> || std::is_signed_v<B>))
+            return std::make_signed_t<A>(a) / std::make_signed_t<B>(b);
+        else
+            return a / b;
     }
 
 #if USE_EMBEDDED_COMPILER
diff --git a/dbms/src/Functions/intDivOrZero.cpp b/dbms/src/Functions/intDivOrZero.cpp
index da996c9492ef..01c8b9fedfbf 100644
--- a/dbms/src/Functions/intDivOrZero.cpp
+++ b/dbms/src/Functions/intDivOrZero.cpp
@@ -1,6 +1,9 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionBinaryArithmetic.h>
 
+#include "intDiv.h"
+
+
 namespace DB
 {
 
@@ -12,7 +15,10 @@ struct DivideIntegralOrZeroImpl
     template <typename Result = ResultType>
     static inline Result apply(A a, B b)
     {
-        return unlikely(divisionLeadsToFPE(a, b)) ? 0 : a / b;
+        if (unlikely(divisionLeadsToFPE(a, b)))
+            return 0;
+
+        return DivideIntegralImpl<A, B>::template apply<Result>(a, b);
     }
 
 #if USE_EMBEDDED_COMPILER
