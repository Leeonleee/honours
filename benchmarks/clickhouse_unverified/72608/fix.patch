diff --git a/src/Analyzer/ArrayJoinNode.cpp b/src/Analyzer/ArrayJoinNode.cpp
index 0cfb5d80b2a3..b37f35fd84c9 100644
--- a/src/Analyzer/ArrayJoinNode.cpp
+++ b/src/Analyzer/ArrayJoinNode.cpp
@@ -66,10 +66,7 @@ ASTPtr ArrayJoinNode::toASTImpl(const ConvertToASTOptions & options) const
         auto * column_node = array_join_expression->as<ColumnNode>();
         if (column_node && column_node->getExpression())
         {
-            if (const auto * function_node = column_node->getExpression()->as<FunctionNode>(); function_node && function_node->getFunctionName() == "nested")
-                array_join_expression_ast = array_join_expression->toAST(options);
-            else
-                array_join_expression_ast = column_node->getExpression()->toAST(options);
+            array_join_expression_ast = column_node->getExpression()->toAST(options);
         }
         else
             array_join_expression_ast = array_join_expression->toAST(options);
diff --git a/src/Analyzer/Resolve/IdentifierResolveScope.h b/src/Analyzer/Resolve/IdentifierResolveScope.h
index 9a09c645189a..ec46ce4370e1 100644
--- a/src/Analyzer/Resolve/IdentifierResolveScope.h
+++ b/src/Analyzer/Resolve/IdentifierResolveScope.h
@@ -165,6 +165,9 @@ struct IdentifierResolveScope
     /// Table expression node to data
     std::unordered_map<QueryTreeNodePtr, AnalysisTableExpressionData> table_expression_node_to_data;
 
+    /// Table expression nodes that appear in the join tree of the corresponding query
+    std::unordered_set<QueryTreeNodePtr> registered_table_expression_nodes;
+
     QueryTreeNodePtrWithHashIgnoreTypesSet nullable_group_by_keys;
     /// Here we count the number of nullable GROUP BY keys we met resolving expression.
     /// E.g. for a query `SELECT tuple(tuple(number)) FROM numbers(10) GROUP BY (number, tuple(number)) with cube`
diff --git a/src/Analyzer/Resolve/IdentifierResolver.cpp b/src/Analyzer/Resolve/IdentifierResolver.cpp
index 317a02a60f2d..60cff0d62c7b 100644
--- a/src/Analyzer/Resolve/IdentifierResolver.cpp
+++ b/src/Analyzer/Resolve/IdentifierResolver.cpp
@@ -565,7 +565,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromExpressionArguments
 
 bool IdentifierResolver::tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)
 {
-    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr || scope.aliases.array_join_aliases.contains(identifier_lookup.identifier.front());
+    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr;
 }
 
 /** Resolve identifier from table columns.
@@ -680,6 +680,27 @@ bool IdentifierResolver::tryBindIdentifierToTableExpressions(const IdentifierLoo
     return can_bind_identifier_to_table_expression;
 }
 
+bool IdentifierResolver::tryBindIdentifierToArrayJoinExpressions(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)
+{
+    bool result = false;
+
+    for (const auto & table_expression : scope.registered_table_expression_nodes)
+    {
+        auto * array_join_node = table_expression->as<ArrayJoinNode>();
+        if (!array_join_node)
+            continue;
+
+        for (const auto & array_join_expression : array_join_node->getJoinExpressions())
+        {
+            auto array_join_expression_alias = array_join_expression->getAlias();
+            if (identifier_lookup.identifier.front() == array_join_expression_alias)
+                return true;
+        }
+    }
+
+    return result;
+}
+
 QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromStorage(
     const Identifier & identifier,
     const QueryTreeNodePtr & table_expression_node,
@@ -1415,9 +1436,6 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide
 
         IdentifierView identifier_view(identifier_lookup.identifier);
 
-        if (identifier_view.isCompound() && from_array_join_node.hasAlias() && identifier_view.front() == from_array_join_node.getAlias())
-            identifier_view.popFirst();
-
         const auto & alias_or_name = array_join_column_expression_typed.hasAlias()
             ? array_join_column_expression_typed.getAlias()
             : array_join_column_expression_typed.getColumnName();
@@ -1429,18 +1447,16 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide
         else
             continue;
 
+        auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),
+            array_join_column_expression_typed.getColumnSource());
         if (identifier_view.empty())
-        {
-            auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),
-                array_join_column_expression_typed.getColumnSource());
             return array_join_column;
-        }
 
         /// Resolve subcolumns. Example : SELECT x.y.z FROM tab ARRAY JOIN arr AS x
         auto compound_expr = tryResolveIdentifierFromCompoundExpression(
             identifier_lookup.identifier,
             identifier_lookup.identifier.getPartsSize() - identifier_view.getPartsSize() /*identifier_bind_size*/,
-            array_join_column_expression,
+            array_join_column,
             {} /* compound_expression_source */,
             scope,
             true /* can_be_not_found */);
diff --git a/src/Analyzer/Resolve/IdentifierResolver.h b/src/Analyzer/Resolve/IdentifierResolver.h
index cdbd7610b5ee..ea7b940427ae 100644
--- a/src/Analyzer/Resolve/IdentifierResolver.h
+++ b/src/Analyzer/Resolve/IdentifierResolver.h
@@ -109,6 +109,9 @@ class IdentifierResolver
         const QueryTreeNodePtr & table_expression_node,
         const IdentifierResolveScope & scope);
 
+    static bool tryBindIdentifierToArrayJoinExpressions(const IdentifierLookup & identifier_lookup,
+        const IdentifierResolveScope & scope);
+
     QueryTreeNodePtr tryResolveIdentifierFromTableExpression(const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
diff --git a/src/Analyzer/Resolve/QueryAnalysisPass.cpp b/src/Analyzer/Resolve/QueryAnalysisPass.cpp
index 36c747555fcc..896154c63b03 100644
--- a/src/Analyzer/Resolve/QueryAnalysisPass.cpp
+++ b/src/Analyzer/Resolve/QueryAnalysisPass.cpp
@@ -1,6 +1,6 @@
 #include <Analyzer/Passes/QueryAnalysisPass.h>
 #include <Analyzer/Resolve/QueryAnalyzer.h>
-#include <Analyzer/createUniqueTableAliases.h>
+#include <Analyzer/createUniqueAliasesIfNecessary.h>
 
 namespace DB
 {
@@ -16,7 +16,7 @@ void QueryAnalysisPass::run(QueryTreeNodePtr & query_tree_node, ContextPtr conte
 {
     QueryAnalyzer analyzer(only_analyze);
     analyzer.resolve(query_tree_node, table_expression, context);
-    createUniqueTableAliases(query_tree_node, table_expression, context);
+    createUniqueAliasesIfNecessary(query_tree_node, context);
 }
 
 }
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index d118cb281ae7..6c4e2551c6c4 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -1593,7 +1593,7 @@ void QueryAnalyzer::qualifyColumnNodesWithProjectionNames(const QueryTreeNodes &
             if (need_to_qualify)
                 need_to_qualify = IdentifierResolver::tryBindIdentifierToTableExpressions(identifier_lookup, table_expression_node, scope);
 
-            if (IdentifierResolver::tryBindIdentifierToAliases(identifier_lookup, scope))
+            if (IdentifierResolver::tryBindIdentifierToAliases(identifier_lookup, scope) || IdentifierResolver::tryBindIdentifierToArrayJoinExpressions(identifier_lookup, scope))
                 need_to_qualify = true;
 
             if (need_to_qualify)
@@ -4977,6 +4977,16 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif
         throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
             "ARRAY JOIN requires at least single expression");
 
+    /// Register expression aliases in the scope
+    for (const auto & elem : array_join_nodes)
+    {
+        for (auto & child : elem->getChildren())
+        {
+            if (child)
+                expressions_visitor.visit(child);
+        }
+    }
+
     std::vector<QueryTreeNodePtr> array_join_column_expressions;
     array_join_column_expressions.reserve(array_join_nodes_size);
 
@@ -4984,18 +4994,6 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif
     {
         auto array_join_expression_alias = array_join_expression->getAlias();
 
-        for (const auto & elem : array_join_nodes)
-        {
-            if (elem->hasAlias())
-                scope.aliases.array_join_aliases.insert(elem->getAlias());
-
-            for (auto & child : elem->getChildren())
-            {
-                if (child)
-                    expressions_visitor.visit(child);
-            }
-        }
-
         std::string identifier_full_name;
 
         if (auto * identifier_node = array_join_expression->as<IdentifierNode>())
@@ -5368,6 +5366,7 @@ void QueryAnalyzer::resolveQueryJoinTreeNode(QueryTreeNodePtr & join_tree_node,
     };
 
     add_table_expression_alias_into_scope(join_tree_node);
+    scope.registered_table_expression_nodes.insert(join_tree_node);
     scope.table_expressions_in_resolve_process.erase(join_tree_node.get());
 }
 
diff --git a/src/Analyzer/Resolve/ScopeAliases.h b/src/Analyzer/Resolve/ScopeAliases.h
index 830ae72144b8..c67a94ef2348 100644
--- a/src/Analyzer/Resolve/ScopeAliases.h
+++ b/src/Analyzer/Resolve/ScopeAliases.h
@@ -27,10 +27,6 @@ struct ScopeAliases
     std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;
     std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;
 
-    /// Names which are aliases from ARRAY JOIN.
-    /// This is needed to properly qualify columns from matchers and avoid name collision.
-    std::unordered_set<std::string> array_join_aliases;
-
     std::unordered_map<std::string, QueryTreeNodePtr> & getAliasMap(IdentifierLookupContext lookup_context)
     {
         switch (lookup_context)
diff --git a/src/Analyzer/createUniqueTableAliases.cpp b/src/Analyzer/createUniqueAliasesIfNecessary.cpp
similarity index 57%
rename from src/Analyzer/createUniqueTableAliases.cpp
rename to src/Analyzer/createUniqueAliasesIfNecessary.cpp
index 8f850fe8deca..fa2ccb09e438 100644
--- a/src/Analyzer/createUniqueTableAliases.cpp
+++ b/src/Analyzer/createUniqueAliasesIfNecessary.cpp
@@ -1,6 +1,7 @@
-#include <memory>
-#include <unordered_map>
-#include <Analyzer/createUniqueTableAliases.h>
+#include <Analyzer/createUniqueAliasesIfNecessary.h>
+
+#include <Analyzer/ArrayJoinNode.h>
+#include <Analyzer/ColumnNode.h>
 #include <Analyzer/FunctionNode.h>
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/IQueryTreeNode.h>
@@ -48,8 +49,6 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex
             case QueryTreeNodeType::TABLE:
                 [[fallthrough]];
             case QueryTreeNodeType::TABLE_FUNCTION:
-                [[fallthrough]];
-            case QueryTreeNodeType::ARRAY_JOIN:
             {
                 auto & alias = table_expression_to_alias[node];
                 if (alias.empty())
@@ -60,6 +59,12 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex
                 }
                 break;
             }
+            case QueryTreeNodeType::ARRAY_JOIN:
+            {
+                /// Simulate previous behaviour and preserve table naming with previous versions
+                ++next_id;
+                break;
+            }
             default:
                 break;
         }
@@ -130,12 +135,97 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex
     std::unordered_map<QueryTreeNodePtr, String> table_expression_to_alias;
 };
 
-}
+class CreateUniqueArrayJoinAliasesVisitor : public InDepthQueryTreeVisitorWithContext<CreateUniqueArrayJoinAliasesVisitor>
+{
+public:
+    using Base = InDepthQueryTreeVisitorWithContext<CreateUniqueArrayJoinAliasesVisitor>;
+    using Base::Base;
+
+    void enterImpl(QueryTreeNodePtr & node)
+    {
+        if (auto * array_join_typed = node->as<ArrayJoinNode>())
+        {
+            populateRenamingMap(array_join_typed, renaming[array_join_typed]);
+            return;
+        }
+
+        auto * column_node = node->as<ColumnNode>();
+        if (!column_node || replaced_nodes_set.contains(node))
+            return;
+
+        auto column_source = column_node->getColumnSource();
+        auto * array_join = column_source->as<ArrayJoinNode>();
+        if (!array_join)
+            return;
+
+        auto & renaming_map = getRenamingMap(array_join);
+
+        auto new_column = column_node->getColumn();
+        new_column.name = renaming_map[column_node->getColumnName()];
+        auto new_column_node = std::make_shared<ColumnNode>(new_column, column_source);
+
+        node = std::move(new_column_node);
+        replaced_nodes_set.insert(node);
+    }
+
+private:
 
+    using RenamingMap = std::unordered_map<String, String>;
 
-void createUniqueTableAliases(QueryTreeNodePtr & node, const QueryTreeNodePtr &  /*table_expression*/, const ContextPtr & context)
+    void populateRenamingMap(ArrayJoinNode * array_join, RenamingMap & result)
+    {
+        if (result.empty())
+        {
+            for (auto & array_join_expression : array_join->getJoinExpressions())
+            {
+                auto * array_join_column = array_join_expression->as<ColumnNode>();
+                chassert(array_join_column != nullptr);
+
+                String unique_expression_name = fmt::format("__array_join_exp_{}", ++next_id);
+                result.emplace(array_join_column->getColumnName(), unique_expression_name);
+
+                auto replacement_column = array_join_column->getColumn();
+                replacement_column.name = unique_expression_name;
+                auto replacement_column_node = std::make_shared<ColumnNode>(replacement_column, array_join_column->getExpression(), array_join_column->getColumnSource());
+                replacement_column_node->setAlias(unique_expression_name);
+
+                array_join_expression = std::move(replacement_column_node);
+                replaced_nodes_set.insert(array_join_expression);
+            }
+        }
+    }
+
+    RenamingMap & getRenamingMap(ArrayJoinNode * array_join)
+    {
+        auto & result  = renaming[array_join];
+
+        populateRenamingMap(array_join, result);
+
+        return result;
+    }
+
+    size_t next_id = 0;
+
+    std::unordered_map<ArrayJoinNode *, RenamingMap> renaming;
+
+    // TODO: Remove this field when identifier resolution cache removed from analyzer.
+    std::unordered_set<QueryTreeNodePtr> replaced_nodes_set;
+};
+
+}
+
+void createUniqueAliasesIfNecessary(QueryTreeNodePtr & node, const ContextPtr & context)
 {
+    /*
+     * For each table expression in the Query Tree generate and add a unique alias.
+     * If table expression had an alias in initial query tree, override it.
+     */
     CreateUniqueTableAliasesVisitor(context).visit(node);
+
+    /* Generate unique aliases for array join expressions.
+     * It's required to create a valid AST for distributed query.
+     */
+    CreateUniqueArrayJoinAliasesVisitor(context).visit(node);
 }
 
 }
diff --git a/src/Analyzer/createUniqueAliasesIfNecessary.h b/src/Analyzer/createUniqueAliasesIfNecessary.h
new file mode 100644
index 000000000000..078bcada3872
--- /dev/null
+++ b/src/Analyzer/createUniqueAliasesIfNecessary.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include <memory>
+#include <Interpreters/Context_fwd.h>
+
+class IQueryTreeNode;
+using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;
+
+namespace DB
+{
+
+void createUniqueAliasesIfNecessary(QueryTreeNodePtr & node, const ContextPtr & context);
+
+}
diff --git a/src/Analyzer/createUniqueTableAliases.h b/src/Analyzer/createUniqueTableAliases.h
deleted file mode 100644
index d57a198498c7..000000000000
--- a/src/Analyzer/createUniqueTableAliases.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#pragma once
-
-#include <memory>
-#include <Interpreters/Context_fwd.h>
-
-class IQueryTreeNode;
-using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;
-
-namespace DB
-{
-
-/*
- * For each table expression in the Query Tree generate and add a unique alias.
- * If table expression had an alias in initial query tree, override it.
- */
-void createUniqueTableAliases(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, const ContextPtr & context);
-
-}
diff --git a/src/Storages/buildQueryTreeForShard.cpp b/src/Storages/buildQueryTreeForShard.cpp
index bce30260954f..20ceae6a06a9 100644
--- a/src/Storages/buildQueryTreeForShard.cpp
+++ b/src/Storages/buildQueryTreeForShard.cpp
@@ -2,7 +2,7 @@
 #include <Storages/buildQueryTreeForShard.h>
 
 #include <Analyzer/ColumnNode.h>
-#include <Analyzer/createUniqueTableAliases.h>
+#include <Analyzer/createUniqueAliasesIfNecessary.h>
 #include <Analyzer/FunctionNode.h>
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/IQueryTreeNode.h>
@@ -427,7 +427,7 @@ QueryTreeNodePtr buildQueryTreeForShard(const PlannerContextPtr & planner_contex
 
     removeGroupingFunctionSpecializations(query_tree_to_modify);
 
-    createUniqueTableAliases(query_tree_to_modify, nullptr, planner_context->getQueryContext());
+    createUniqueAliasesIfNecessary(query_tree_to_modify, planner_context->getQueryContext());
 
     // Get rid of the settings clause so we don't send them to remote. Thus newly non-important
     // settings won't break any remote parser. It's also more reasonable since the query settings
