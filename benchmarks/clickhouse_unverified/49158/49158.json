{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49158,
  "instance_id": "ClickHouse__ClickHouse-49158",
  "issue_numbers": [
    "49140"
  ],
  "base_commit": "6d6188eb0e385f57df3cc444351fd008e98f0da3",
  "patch": "diff --git a/docs/en/sql-reference/statements/show.md b/docs/en/sql-reference/statements/show.md\nindex 428a04ae030d..45d09c2dec7e 100644\n--- a/docs/en/sql-reference/statements/show.md\n+++ b/docs/en/sql-reference/statements/show.md\n@@ -98,22 +98,6 @@ Result:\n \n - [CREATE DATABASE](https://clickhouse.com/docs/en/sql-reference/statements/create/database/#query-language-create-database)\n \n-## SHOW PROCESSLIST\n-\n-``` sql\n-SHOW PROCESSLIST [INTO OUTFILE filename] [FORMAT format]\n-```\n-\n-Outputs the content of the [system.processes](../../operations/system-tables/processes.md#system_tables-processes) table, that contains a list of queries that is being processed at the moment, excepting `SHOW PROCESSLIST` queries.\n-\n-The `SELECT * FROM system.processes` query returns data about all the current queries.\n-\n-Tip (execute in the console):\n-\n-``` bash\n-$ watch -n1 \"clickhouse-client --query='SHOW PROCESSLIST'\"\n-```\n-\n ## SHOW TABLES\n \n Displays a list of tables.\n@@ -277,6 +261,77 @@ SHOW DICTIONARIES FROM db LIKE '%reg%' LIMIT 2\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## SHOW INDEX\n+\n+Displays a list of primary and data skipping indexes of a table.\n+\n+```sql\n+SHOW [EXTENDED] {INDEX | INDEXES | KEYS } {FROM | IN} <table> [{FROM | IN} <db>] [WHERE <expr>] [INTO OUTFILE <filename>] [FORMAT <format>]\n+```\n+\n+The database and table name can be specified in abbreviated form as `<db>.<table>`, i.e. `FROM tab FROM db` and `FROM db.tab` are\n+equivalent. If no database is specified, the query assumes the current database as database.\n+\n+The optional keyword `EXTENDED` currently has no effect, it only exists for MySQL compatibility.\n+\n+`SHOW INDEX` produces a result table with the following structure:\n+- table - The name of the table (String)\n+- non_unique - 0 if the index can contain duplicates, 1 otherwise (UInt8)\n+- key_name - The name of the index, `PRIMARY` if the index is a primary key index (String)\n+- seq_in_index - Currently unused\n+- column_name - Currently unused\n+- collation - The sorting of the column in the index, `A` if ascending, `D` if descending, `NULL` if unsorted (Nullable(String))\n+- cardinality - Currently unused\n+- sub_part - Currently unused\n+- packed - Currently unused\n+- null - Currently unused\n+- index_type - The index type, e.g. `primary`, `minmax`, `bloom_filter` etc. (String)\n+- comment - Currently unused\n+- index_comment - Currently unused\n+- visible - If the index is visible to the optimizer, always `YES` (String)\n+- expression - The index expression (String)\n+\n+**Examples**\n+\n+Getting information about all indexes in table 'tbl'\n+\n+```sql\n+SHOW INDEX FROM 'tbl'\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500table\u2500\u252c\u2500non_unique\u2500\u252c\u2500key_name\u2500\u252c\u2500seq_in_index\u2500\u252c\u2500column_name\u2500\u252c\u2500collation\u2500\u252c\u2500cardinality\u2500\u252c\u2500sub_part\u2500\u252c\u2500packed\u2500\u252c\u2500null\u2500\u252c\u2500index_type\u2500\u2500\u2500\u252c\u2500comment\u2500\u252c\u2500index_comment\u2500\u252c\u2500visible\u2500\u252c\u2500expression\u2500\u2510\n+\u2502 tbl   \u2502          0 \u2502 blf_idx  \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38     \u2502 \u1d3a\u1d41\u1d38\u1d38   \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 bloom_filter \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 YES     \u2502 d, b       \u2502\n+\u2502 tbl   \u2502          0 \u2502 mm1_idx  \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38     \u2502 \u1d3a\u1d41\u1d38\u1d38   \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 minmax       \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 YES     \u2502 a, c, d    \u2502\n+\u2502 tbl   \u2502          0 \u2502 mm2_idx  \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38     \u2502 \u1d3a\u1d41\u1d38\u1d38   \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 minmax       \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 YES     \u2502 c, d, e    \u2502\n+\u2502 tbl   \u2502          0 \u2502 PRIMARY  \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 A         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38     \u2502 \u1d3a\u1d41\u1d38\u1d38   \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 primary      \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 YES     \u2502 c, a       \u2502\n+\u2502 tbl   \u2502          0 \u2502 set_idx  \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502 \u1d3a\u1d41\u1d38\u1d38        \u2502 \u1d3a\u1d41\u1d38\u1d38     \u2502 \u1d3a\u1d41\u1d38\u1d38   \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 set          \u2502 \u1d3a\u1d41\u1d38\u1d38    \u2502 \u1d3a\u1d41\u1d38\u1d38          \u2502 YES     \u2502 e          \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**See also**\n+\n+- [system.tables](../../operations/system-tables/tables.md)\n+- [system.data_skipping_indices](../../operations/system-tables/data_skipping_indices.md)\n+\n+## SHOW PROCESSLIST\n+\n+``` sql\n+SHOW PROCESSLIST [INTO OUTFILE filename] [FORMAT format]\n+```\n+\n+Outputs the content of the [system.processes](../../operations/system-tables/processes.md#system_tables-processes) table, that contains a list of queries that is being processed at the moment, excepting `SHOW PROCESSLIST` queries.\n+\n+The `SELECT * FROM system.processes` query returns data about all the current queries.\n+\n+Tip (execute in the console):\n+\n+``` bash\n+$ watch -n1 \"clickhouse-client --query='SHOW PROCESSLIST'\"\n+```\n+\n ## SHOW GRANTS\n \n Shows privileges for a user.\ndiff --git a/src/Interpreters/InterpreterFactory.cpp b/src/Interpreters/InterpreterFactory.cpp\nindex 68b22b550f63..eec73fa56e25 100644\n--- a/src/Interpreters/InterpreterFactory.cpp\n+++ b/src/Interpreters/InterpreterFactory.cpp\n@@ -22,6 +22,7 @@\n #include <Parsers/ASTShowProcesslistQuery.h>\n #include <Parsers/ASTShowTablesQuery.h>\n #include <Parsers/ASTShowColumnsQuery.h>\n+#include <Parsers/ASTShowIndexesQuery.h>\n #include <Parsers/ASTUseQuery.h>\n #include <Parsers/ASTWatchQuery.h>\n #include <Parsers/ASTCreateNamedCollectionQuery.h>\n@@ -81,6 +82,7 @@\n #include <Interpreters/InterpreterShowProcesslistQuery.h>\n #include <Interpreters/InterpreterShowTablesQuery.h>\n #include <Interpreters/InterpreterShowColumnsQuery.h>\n+#include <Interpreters/InterpreterShowIndexesQuery.h>\n #include <Interpreters/InterpreterSystemQuery.h>\n #include <Interpreters/InterpreterUseQuery.h>\n #include <Interpreters/InterpreterWatchQuery.h>\n@@ -181,6 +183,10 @@ std::unique_ptr<IInterpreter> InterpreterFactory::get(ASTPtr & query, ContextMut\n     {\n         return std::make_unique<InterpreterShowColumnsQuery>(query, context);\n     }\n+    else if (query->as<ASTShowIndexesQuery>())\n+    {\n+        return std::make_unique<InterpreterShowIndexesQuery>(query, context);\n+    }\n     else if (query->as<ASTShowEnginesQuery>())\n     {\n         return std::make_unique<InterpreterShowEnginesQuery>(query, context);\ndiff --git a/src/Interpreters/InterpreterShowColumnsQuery.cpp b/src/Interpreters/InterpreterShowColumnsQuery.cpp\nindex 4474be21d8b0..c86d3c753c49 100644\n--- a/src/Interpreters/InterpreterShowColumnsQuery.cpp\n+++ b/src/Interpreters/InterpreterShowColumnsQuery.cpp\n@@ -1,12 +1,12 @@\n #include <Interpreters/InterpreterShowColumnsQuery.h>\n \n+#include <Common/quoteString.h>\n+#include <IO/Operators.h>\n #include <IO/WriteBufferFromString.h>\n #include <Parsers/ASTShowColumnsQuery.h>\n #include <Parsers/formatAST.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/executeQuery.h>\n-#include <IO/Operators.h>\n-#include <boost/algorithm/string.hpp>\n \n \n namespace DB\n@@ -24,9 +24,23 @@ String InterpreterShowColumnsQuery::getRewrittenQuery()\n {\n     const auto & query = query_ptr->as<ASTShowColumnsQuery &>();\n \n-    WriteBufferFromOwnString rewritten_query;\n+    WriteBufferFromOwnString buf_database;\n+    String resolved_database = getContext()->resolveDatabase(query.database);\n+    writeEscapedString(resolved_database, buf_database);\n+    String database = buf_database.str();\n+\n+    WriteBufferFromOwnString buf_table;\n+    writeEscapedString(query.table, buf_table);\n+    String table = buf_table.str();\n \n-    rewritten_query << \"SELECT name AS field, type AS type, startsWith(type, 'Nullable') AS null, trim(concatWithSeparator(' ', if(is_in_primary_key, 'PRI', ''), if (is_in_sorting_key, 'SOR', ''))) AS key, if(default_kind IN ('ALIAS', 'DEFAULT', 'MATERIALIZED'), default_expression, NULL) AS default, '' AS extra \";\n+    String rewritten_query = R\"(\n+SELECT\n+    name AS field,\n+    type AS type,\n+    startsWith(type, 'Nullable') AS null,\n+    trim(concatWithSeparator(' ', if (is_in_primary_key, 'PRI', ''), if (is_in_sorting_key, 'SOR', ''))) AS key,\n+    if (default_kind IN ('ALIAS', 'DEFAULT', 'MATERIALIZED'), default_expression, NULL) AS default,\n+    '' AS extra )\";\n \n     // TODO Interpret query.extended. It is supposed to show internal/virtual columns. Need to fetch virtual column names, see\n     // IStorage::getVirtuals(). We can't easily do that via SQL.\n@@ -37,60 +51,41 @@ String InterpreterShowColumnsQuery::getRewrittenQuery()\n         /// - collation: no such thing in ClickHouse\n         /// - comment\n         /// - privileges: <not implemented, TODO ask system.grants>\n-        rewritten_query << \", NULL AS collation, comment, '' AS privileges \";\n+        rewritten_query += R\"(,\n+    NULL AS collation,\n+    comment,\n+    '' AS privileges )\";\n     }\n \n-    rewritten_query << \"FROM system.columns WHERE \";\n+    rewritten_query += fmt::format(R\"(\n+FROM system.columns\n+WHERE\n+    database = '{}'\n+    AND table = '{}' )\", database, table);\n \n-    String database;\n-    String table;\n-    if (query.from_table.contains(\".\"))\n-    {\n-        /// FROM <db>.<table> (abbreviated form)\n-        chassert(query.from_database.empty());\n-        std::vector<String> split;\n-        boost::split(split, query.from_table, boost::is_any_of(\".\"));\n-        chassert(split.size() == 2);\n-        database = split[0];\n-        table = split[1];\n-    }\n-    else if (query.from_database.empty())\n-    {\n-        /// FROM <table>\n-        chassert(!query.from_table.empty());\n-        database = getContext()->getCurrentDatabase();\n-        table = query.from_table;\n-    }\n-    else\n+    if (!query.like.empty())\n     {\n-        /// FROM <database> FROM <table>\n-        chassert(!query.from_database.empty());\n-        chassert(!query.from_table.empty());\n-        database = query.from_database;\n-        table = query.from_table;\n+        rewritten_query += \" AND name \";\n+        if (query.not_like)\n+            rewritten_query += \"NOT \";\n+        if (query.case_insensitive_like)\n+            rewritten_query += \"ILIKE \";\n+        else\n+            rewritten_query += \"LIKE \";\n+        rewritten_query += fmt::format(\"'{}'\", query.like);\n     }\n-    rewritten_query << \"database = \" << DB::quote << database;\n-    rewritten_query << \" AND table = \" << DB::quote << table;\n-\n-    if (!query.like.empty())\n-        rewritten_query\n-            << \" AND name \"\n-            << (query.not_like ? \"NOT \" : \"\")\n-            << (query.case_insensitive_like ? \"ILIKE \" : \"LIKE \")\n-            << DB::quote << query.like;\n     else if (query.where_expression)\n-        rewritten_query << \" AND (\" << query.where_expression << \")\";\n+        rewritten_query += fmt::format(\" AND ({})\", query.where_expression);\n \n     /// Sorting is strictly speaking not necessary but 1. it is convenient for users, 2. SQL currently does not allow to\n     /// sort the output of SHOW COLUMNS otherwise (SELECT * FROM (SHOW COLUMNS ...) ORDER BY ...) is rejected) and 3. some\n     /// SQL tests can take advantage of this.\n-    rewritten_query << \" ORDER BY field, type, null, key, default, extra\";\n+    rewritten_query += \" ORDER BY field, type, null, key, default, extra\";\n \n     if (query.limit_length)\n-        rewritten_query << \" LIMIT \" << query.limit_length;\n-\n-    return rewritten_query.str();\n+        rewritten_query += fmt::format(\" LIMIT {}\", query.limit_length);\n \n+    return rewritten_query;\n }\n \n \ndiff --git a/src/Interpreters/InterpreterShowIndexesQuery.cpp b/src/Interpreters/InterpreterShowIndexesQuery.cpp\nnew file mode 100644\nindex 000000000000..51311c82eebc\n--- /dev/null\n+++ b/src/Interpreters/InterpreterShowIndexesQuery.cpp\n@@ -0,0 +1,100 @@\n+#include <Interpreters/InterpreterShowIndexesQuery.h>\n+\n+#include <Common/quoteString.h>\n+#include <IO/Operators.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <Parsers/ASTShowIndexesQuery.h>\n+#include <Parsers/formatAST.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/executeQuery.h>\n+\n+\n+namespace DB\n+{\n+\n+\n+InterpreterShowIndexesQuery::InterpreterShowIndexesQuery(const ASTPtr & query_ptr_, ContextMutablePtr context_)\n+    : WithMutableContext(context_)\n+    , query_ptr(query_ptr_)\n+{\n+}\n+\n+\n+String InterpreterShowIndexesQuery::getRewrittenQuery()\n+{\n+    const auto & query = query_ptr->as<ASTShowIndexesQuery &>();\n+\n+    WriteBufferFromOwnString buf_table;\n+    writeEscapedString(query.table, buf_table);\n+    String table = buf_table.str();\n+\n+    WriteBufferFromOwnString buf_database;\n+    String resolved_database = getContext()->resolveDatabase(query.database);\n+    writeEscapedString(resolved_database, buf_database);\n+    String database = buf_database.str();\n+\n+    String where_expression = query.where_expression ? fmt::format(\"WHERE ({})\", query.where_expression) : \"\";\n+\n+    String rewritten_query = fmt::format(R\"(\n+SELECT *\n+FROM (\n+        (SELECT\n+            name AS table,\n+            0 AS non_unique,\n+            'PRIMARY' AS key_name,\n+            NULL AS seq_in_index,\n+            NULL AS column_name,\n+            'A' AS collation,\n+            NULL AS cardinality,\n+            NULL AS sub_part,\n+            NULL AS packed,\n+            NULL AS null,\n+            'primary' AS index_type,\n+            NULL AS comment,\n+            NULL AS index_comment,\n+            'YES' AS visible,\n+            primary_key AS expression\n+        FROM system.tables\n+        WHERE\n+            database = '{0}'\n+            AND name = '{1}')\n+    UNION ALL (\n+        SELECT\n+            table AS table,\n+            0 AS non_unique,\n+            name AS key_name,\n+            NULL AS seq_in_index,\n+            NULL AS column_name,\n+            NULL AS collation,\n+            NULL AS cardinality,\n+            NULL AS sub_part,\n+            NULL AS packed,\n+            NULL AS null,\n+            type AS index_type,\n+            NULL AS comment,\n+            NULL AS index_comment,\n+            'YES' AS visible,\n+            expr AS expression\n+        FROM system.data_skipping_indices\n+        WHERE\n+            database = '{0}'\n+            AND table = '{1}'))\n+{2}\n+ORDER BY index_type, expression;)\", database, table, where_expression);\n+\n+    /// Sorting is strictly speaking not necessary but 1. it is convenient for users, 2. SQL currently does not allow to\n+    /// sort the output of SHOW INDEXES otherwise (SELECT * FROM (SHOW INDEXES ...) ORDER BY ...) is rejected) and 3. some\n+    /// SQL tests can take advantage of this.\n+\n+    return rewritten_query;\n+}\n+\n+\n+BlockIO InterpreterShowIndexesQuery::execute()\n+{\n+    return executeQuery(getRewrittenQuery(), getContext(), true);\n+}\n+\n+\n+}\n+\ndiff --git a/src/Interpreters/InterpreterShowIndexesQuery.h b/src/Interpreters/InterpreterShowIndexesQuery.h\nnew file mode 100644\nindex 000000000000..0b4fa591e352\n--- /dev/null\n+++ b/src/Interpreters/InterpreterShowIndexesQuery.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <Interpreters/IInterpreter.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+\n+namespace DB\n+{\n+\n+class Context;\n+\n+\n+/// Returns a list of indexes which meet some conditions.\n+class InterpreterShowIndexesQuery : public IInterpreter, WithMutableContext\n+{\n+public:\n+    InterpreterShowIndexesQuery(const ASTPtr & query_ptr_, ContextMutablePtr context_);\n+\n+    BlockIO execute() override;\n+\n+    /// Ignore quota and limits here because execute() produces a SELECT query which checks quotas/limits by itself.\n+    bool ignoreQuota() const override { return true; }\n+    bool ignoreLimits() const override { return true; }\n+\n+private:\n+    ASTPtr query_ptr;\n+\n+    String getRewrittenQuery();\n+};\n+\n+\n+}\n+\ndiff --git a/src/Parsers/ASTShowColumnsQuery.cpp b/src/Parsers/ASTShowColumnsQuery.cpp\nindex 1cb4b651f0ab..a02dba9c288f 100644\n--- a/src/Parsers/ASTShowColumnsQuery.cpp\n+++ b/src/Parsers/ASTShowColumnsQuery.cpp\n@@ -24,9 +24,9 @@ void ASTShowColumnsQuery::formatQueryImpl(const FormatSettings & settings, Forma\n                   << \"COLUMNS\"\n                   << (settings.hilite ? hilite_none : \"\");\n \n-    settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(from_table);\n-    if (!from_database.empty())\n-        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(from_database);\n+    settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(table);\n+    if (!database.empty())\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(database);\n \n \n     if (!like.empty())\ndiff --git a/src/Parsers/ASTShowColumnsQuery.h b/src/Parsers/ASTShowColumnsQuery.h\nindex 79e8a67b5580..b49d688dcdb9 100644\n--- a/src/Parsers/ASTShowColumnsQuery.h\n+++ b/src/Parsers/ASTShowColumnsQuery.h\n@@ -18,8 +18,8 @@ class ASTShowColumnsQuery : public ASTQueryWithOutput\n     ASTPtr where_expression;\n     ASTPtr limit_length;\n \n-    String from_database;\n-    String from_table;\n+    String database;\n+    String table;\n \n     String like;\n \ndiff --git a/src/Parsers/ASTShowIndexesQuery.cpp b/src/Parsers/ASTShowIndexesQuery.cpp\nnew file mode 100644\nindex 000000000000..df1e242a2393\n--- /dev/null\n+++ b/src/Parsers/ASTShowIndexesQuery.cpp\n@@ -0,0 +1,38 @@\n+#include <Parsers/ASTShowIndexesQuery.h>\n+\n+#include <iomanip>\n+#include <Common/quoteString.h>\n+#include <IO/Operators.h>\n+\n+namespace DB\n+{\n+\n+ASTPtr ASTShowIndexesQuery::clone() const\n+{\n+    auto res = std::make_shared<ASTShowIndexesQuery>(*this);\n+    res->children.clear();\n+    cloneOutputOptions(*res);\n+    return res;\n+}\n+\n+void ASTShowIndexesQuery::formatQueryImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+    settings.ostr << (settings.hilite ? hilite_keyword : \"\")\n+                  << \"SHOW \"\n+                  << (extended ? \"EXTENDED \" : \"\")\n+                  << \"INDEXES\"\n+                  << (settings.hilite ? hilite_none : \"\");\n+\n+    settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(table);\n+    if (!database.empty())\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(database);\n+\n+    if (where_expression)\n+    {\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" WHERE \" << (settings.hilite ? hilite_none : \"\");\n+        where_expression->formatImpl(settings, state, frame);\n+    }\n+}\n+\n+}\n+\ndiff --git a/src/Parsers/ASTShowIndexesQuery.h b/src/Parsers/ASTShowIndexesQuery.h\nnew file mode 100644\nindex 000000000000..ab504bf71dae\n--- /dev/null\n+++ b/src/Parsers/ASTShowIndexesQuery.h\n@@ -0,0 +1,29 @@\n+#pragma once\n+\n+#include <Parsers/IAST_fwd.h>\n+#include <Parsers/ASTQueryWithOutput.h>\n+\n+namespace DB\n+{\n+\n+/// Query SHOW INDEXES\n+class ASTShowIndexesQuery : public ASTQueryWithOutput\n+{\n+public:\n+    bool extended = false;\n+\n+    ASTPtr where_expression;\n+\n+    String database;\n+    String table;\n+\n+    String getID(char) const override { return \"ShowColumns\"; }\n+    ASTPtr clone() const override;\n+    QueryKind getQueryKind() const override { return QueryKind::Show; }\n+\n+protected:\n+    void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\n+};\n+\n+}\n+\ndiff --git a/src/Parsers/ParserQueryWithOutput.cpp b/src/Parsers/ParserQueryWithOutput.cpp\nindex 2fb7c406d74a..22e32fa5c459 100644\n--- a/src/Parsers/ParserQueryWithOutput.cpp\n+++ b/src/Parsers/ParserQueryWithOutput.cpp\n@@ -18,6 +18,7 @@\n #include <Parsers/ParserShowTablesQuery.h>\n #include <Parsers/ParserShowColumnsQuery.h>\n #include <Parsers/ParserShowEngineQuery.h>\n+#include <Parsers/ParserShowIndexesQuery.h>\n #include <Parsers/ParserTablePropertiesQuery.h>\n #include <Parsers/ParserWatchQuery.h>\n #include <Parsers/ParserDescribeCacheQuery.h>\n@@ -39,6 +40,7 @@ bool ParserQueryWithOutput::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n     ParserShowTablesQuery show_tables_p;\n     ParserShowColumnsQuery show_columns_p;\n     ParserShowEnginesQuery show_engine_p;\n+    ParserShowIndexesQuery show_indexes_p;\n     ParserSelectWithUnionQuery select_p;\n     ParserTablePropertiesQuery table_p;\n     ParserDescribeTableQuery describe_table_p;\n@@ -69,6 +71,7 @@ bool ParserQueryWithOutput::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n         || show_tables_p.parse(pos, query, expected)\n         || show_columns_p.parse(pos, query, expected)\n         || show_engine_p.parse(pos, query, expected)\n+        || show_indexes_p.parse(pos, query, expected)\n         || table_p.parse(pos, query, expected)\n         || describe_cache_p.parse(pos, query, expected)\n         || describe_table_p.parse(pos, query, expected)\ndiff --git a/src/Parsers/ParserShowColumnsQuery.cpp b/src/Parsers/ParserShowColumnsQuery.cpp\nindex 03e66e4ae0fa..e5fc5c39701a 100644\n--- a/src/Parsers/ParserShowColumnsQuery.cpp\n+++ b/src/Parsers/ParserShowColumnsQuery.cpp\n@@ -7,14 +7,19 @@\n #include <Parsers/ExpressionElementParsers.h>\n #include <Parsers/ExpressionListParsers.h>\n \n+#include <boost/algorithm/string.hpp>\n+\n namespace DB\n {\n \n bool ParserShowColumnsQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr like;\n-    ASTPtr from_database;\n-    ASTPtr from_table;\n+    ASTPtr from1;\n+    ASTPtr from2;\n+\n+    String from1_str;\n+    String from2_str;\n \n     auto query = std::make_shared<ASTShowColumnsQuery>();\n \n@@ -27,26 +32,38 @@ bool ParserShowColumnsQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     if (ParserKeyword(\"FULL\").ignore(pos, expected))\n         query->full = true;\n \n-    if (!ParserKeyword(\"COLUMNS\").ignore(pos, expected) || ParserKeyword(\"FIELDS\").ignore(pos, expected))\n+    if (!(ParserKeyword(\"COLUMNS\").ignore(pos, expected) || ParserKeyword(\"FIELDS\").ignore(pos, expected)))\n         return false;\n \n     if (ParserKeyword(\"FROM\").ignore(pos, expected) || ParserKeyword(\"IN\").ignore(pos, expected))\n     {\n-        if (!ParserCompoundIdentifier().parse(pos, from_table, expected))\n+        if (!ParserCompoundIdentifier().parse(pos, from1, expected))\n             return false;\n     }\n     else\n         return false;\n \n-    tryGetIdentifierNameInto(from_table, query->from_table);\n-    bool abbreviated_form = query->from_table.contains(\".\"); /// FROM <db>.<table>\n+    tryGetIdentifierNameInto(from1, from1_str);\n \n-    if (!abbreviated_form)\n+    bool abbreviated_form = from1_str.contains(\".\"); // FROM database.table\n+    if (abbreviated_form)\n+    {\n+        std::vector<String> split;\n+        boost::split(split, from1_str, boost::is_any_of(\".\"));\n+        query->database = split[0];\n+        query->table = split[1];\n+    }\n+    else\n+    {\n         if (ParserKeyword(\"FROM\").ignore(pos, expected) || ParserKeyword(\"IN\").ignore(pos, expected))\n-            if (!ParserIdentifier().parse(pos, from_database, expected))\n+            if (!ParserIdentifier().parse(pos, from2, expected))\n                 return false;\n \n-    tryGetIdentifierNameInto(from_database, query->from_database);\n+        tryGetIdentifierNameInto(from2, from2_str);\n+\n+        query->table = from1_str;\n+        query->database = from2_str;\n+    }\n \n     if (ParserKeyword(\"NOT\").ignore(pos, expected))\n         query->not_like = true;\ndiff --git a/src/Parsers/ParserShowColumnsQuery.h b/src/Parsers/ParserShowColumnsQuery.h\nindex 999acf722afa..a2941ca71d11 100644\n--- a/src/Parsers/ParserShowColumnsQuery.h\n+++ b/src/Parsers/ParserShowColumnsQuery.h\n@@ -6,7 +6,7 @@ namespace DB\n {\n \n /** Parses queries of the form\n- * SHOW [EXTENDED] [FULL] COLUMNS (FROM|IN) tbl [(FROM|IN) db] [(([NOT] (LIKE|ILIKE) expr) | (WHERE expr))] [LIMIT n]\n+ * SHOW [EXTENDED] [FULL] COLUMNS FROM|IN tbl [FROM|IN db] [[NOT] LIKE|ILIKE expr | WHERE expr] [LIMIT n]\n  */\n class ParserShowColumnsQuery : public IParserBase\n {\ndiff --git a/src/Parsers/ParserShowIndexesQuery.cpp b/src/Parsers/ParserShowIndexesQuery.cpp\nnew file mode 100644\nindex 000000000000..fe08b4630692\n--- /dev/null\n+++ b/src/Parsers/ParserShowIndexesQuery.cpp\n@@ -0,0 +1,74 @@\n+#include <Parsers/ParserShowIndexesQuery.h>\n+\n+#include <Parsers/ASTIdentifier_fwd.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ASTShowIndexesQuery.h>\n+#include <Parsers/CommonParsers.h>\n+#include <Parsers/ExpressionElementParsers.h>\n+#include <Parsers/ExpressionListParsers.h>\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace DB\n+{\n+\n+bool ParserShowIndexesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr from1;\n+    ASTPtr from2;\n+\n+    String from1_str;\n+    String from2_str;\n+\n+    auto query = std::make_shared<ASTShowIndexesQuery>();\n+\n+    if (!ParserKeyword(\"SHOW\").ignore(pos, expected))\n+        return false;\n+\n+    if (ParserKeyword(\"EXTENDED\").ignore(pos, expected))\n+        query->extended = true;\n+\n+    if (!(ParserKeyword(\"INDEX\").ignore(pos, expected) || ParserKeyword(\"INDEXES\").ignore(pos, expected) || ParserKeyword(\"KEYS\").ignore(pos, expected)))\n+        return false;\n+\n+    if (ParserKeyword(\"FROM\").ignore(pos, expected) || ParserKeyword(\"IN\").ignore(pos, expected))\n+    {\n+        if (!ParserCompoundIdentifier().parse(pos, from1, expected))\n+            return false;\n+    }\n+    else\n+        return false;\n+\n+    tryGetIdentifierNameInto(from1, from1_str);\n+\n+    bool abbreviated_form = from1_str.contains(\".\"); // FROM database.table\n+    if (abbreviated_form)\n+    {\n+        std::vector<String> split;\n+        boost::split(split, from1_str, boost::is_any_of(\".\"));\n+        query->database = split[0];\n+        query->table = split[1];\n+    }\n+    else\n+    {\n+        if (ParserKeyword(\"FROM\").ignore(pos, expected) || ParserKeyword(\"IN\").ignore(pos, expected))\n+            if (!ParserIdentifier().parse(pos, from2, expected))\n+                return false;\n+\n+        tryGetIdentifierNameInto(from2, from2_str);\n+\n+        query->table = from1_str;\n+        query->database = from2_str;\n+    }\n+\n+    if (ParserKeyword(\"WHERE\").ignore(pos, expected))\n+        if (!ParserExpressionWithOptionalAlias(false).parse(pos, query->where_expression, expected))\n+            return false;\n+\n+    node = query;\n+\n+    return true;\n+}\n+\n+}\n+\ndiff --git a/src/Parsers/ParserShowIndexesQuery.h b/src/Parsers/ParserShowIndexesQuery.h\nnew file mode 100644\nindex 000000000000..0ece5e89ef73\n--- /dev/null\n+++ b/src/Parsers/ParserShowIndexesQuery.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+\n+namespace DB\n+{\n+\n+/** Parses queries of the form\n+ * SHOW [EXTENDED] INDEX|INDEXES|KEYS FROM|IN tbl [FROM|IN db] [WHERE expr]\n+ */\n+class ParserShowIndexesQuery : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"SHOW INDEXES query\"; }\n+\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\n+\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02706_show_columns.reference b/tests/queries/0_stateless/02706_show_columns.reference\nindex da967d59cda7..9d7e8485e194 100644\n--- a/tests/queries/0_stateless/02706_show_columns.reference\n+++ b/tests/queries/0_stateless/02706_show_columns.reference\n@@ -1,3 +1,7 @@\n+--- Aliases of SHOW COLUMNS\n+int32\tNullable(Int32)\t1\t\t\\N\t\n+str\tString\t0\tSOR\t\\N\t\n+uint64\tUInt64\t0\tPRI SOR\t\\N\t\n int32\tNullable(Int32)\t1\t\t\\N\t\n str\tString\t0\tSOR\t\\N\t\n uint64\tUInt64\t0\tPRI SOR\t\\N\t\n@@ -24,6 +28,11 @@ int32\tNullable(Int32)\t1\t\t\\N\n uint64\tUInt64\t0\tPRI SOR\t\\N\t\n --- LIMIT\n int32\tNullable(Int32)\t1\t\t\\N\t\n+--- Check with weird table names\n+c\tString\t0\tPRI SOR\t\\N\t\n+c\tString\t0\tPRI SOR\t\\N\t\n+c\tString\t0\tPRI SOR\t\\N\t\n+c\tString\t0\tPRI SOR\t\\N\t\n --- Original table\n int32\tNullable(Int32)\t1\t\t\\N\t\n str\tString\t0\tSOR\t\\N\t\ndiff --git a/tests/queries/0_stateless/02706_show_columns.sql b/tests/queries/0_stateless/02706_show_columns.sql\nindex ce206fedee43..b1a907c5c71c 100644\n--- a/tests/queries/0_stateless/02706_show_columns.sql\n+++ b/tests/queries/0_stateless/02706_show_columns.sql\n@@ -15,7 +15,9 @@ ENGINE = MergeTree\n PRIMARY KEY (uint64)\n ORDER BY (uint64, str);\n \n+SELECT '--- Aliases of SHOW COLUMNS';\n SHOW COLUMNS FROM tab;\n+SHOW FIELDS FROM tab;\n \n SELECT '--- EXTENDED';\n SHOW EXTENDED COLUMNS FROM tab;\n@@ -41,6 +43,26 @@ SHOW COLUMNS FROM tab WHERE field LIKE '%int%';\n SELECT '--- LIMIT';\n SHOW COLUMNS FROM tab LIMIT 1;\n \n+SELECT '--- Check with weird table names';\n+\n+DROP TABLE IF EXISTS `$4@^7`;\n+CREATE TABLE `$4@^7` (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW COLUMNS FROM `$4@^7`;\n+DROP TABLE `$4@^7`;\n+\n+DROP TABLE IF EXISTS NULL;\n+CREATE TABLE NULL (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW COLUMNS FROM NULL;\n+DROP TABLE NULL;\n+\n+DROP DATABASE IF EXISTS `'`;\n+CREATE DATABASE `'`;\n+CREATE TABLE `'`.`'` (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW COLUMNS FROM `'` FROM `'`;\n+SHOW COLUMNS FROM `'`.`'`; -- abbreviated form\n+DROP TABLE `'`.`'`;\n+DROP DATABASE `'`;\n+\n -- Create a table in a different database. Intentionally useing the same table/column names as above so\n -- we notice if something is buggy in the implementation of SHOW COLUMNS.\n DROP DATABASE IF EXISTS database_123456789abcde;\ndiff --git a/tests/queries/0_stateless/02724_show_indexes.reference b/tests/queries/0_stateless/02724_show_indexes.reference\nnew file mode 100644\nindex 000000000000..20af3954fa5c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02724_show_indexes.reference\n@@ -0,0 +1,42 @@\n+--- Aliases of SHOW INDEX\n+tbl\t0\tblf_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tbloom_filter\t\\N\t\\N\tYES\td, b\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc, a\n+tbl\t0\tset_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tset\t\\N\t\\N\tYES\te\n+tbl\t0\tblf_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tbloom_filter\t\\N\t\\N\tYES\td, b\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc, a\n+tbl\t0\tset_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tset\t\\N\t\\N\tYES\te\n+tbl\t0\tblf_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tbloom_filter\t\\N\t\\N\tYES\td, b\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc, a\n+tbl\t0\tset_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tset\t\\N\t\\N\tYES\te\n+--- EXTENDED\n+tbl\t0\tblf_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tbloom_filter\t\\N\t\\N\tYES\td, b\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc, a\n+tbl\t0\tset_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tset\t\\N\t\\N\tYES\te\n+--- WHERE\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+--- Check with weird table names\n+$4@^7\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc\n+NULL\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc\n+\\'\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc\n+\\'\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc\n+--- Original table\n+tbl\t0\tblf_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tbloom_filter\t\\N\t\\N\tYES\td, b\n+tbl\t0\tmm1_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\ta, c, d\n+tbl\t0\tmm2_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tc, d, e\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\tc, a\n+tbl\t0\tset_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tset\t\\N\t\\N\tYES\te\n+--- Equally named table in other database\n+tbl\t0\tmmi_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tb\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\ta\n+--- Short form\n+tbl\t0\tmmi_idx\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\t\\N\tminmax\t\\N\t\\N\tYES\tb\n+tbl\t0\tPRIMARY\t\\N\t\\N\tA\t\\N\t\\N\t\\N\t\\N\tprimary\t\\N\t\\N\tYES\ta\ndiff --git a/tests/queries/0_stateless/02724_show_indexes.sql b/tests/queries/0_stateless/02724_show_indexes.sql\nnew file mode 100644\nindex 000000000000..ce8ed67c5248\n--- /dev/null\n+++ b/tests/queries/0_stateless/02724_show_indexes.sql\n@@ -0,0 +1,79 @@\n+-- Tags: no-parallel\n+-- no-parallel: creates a custom database schema and expects to use it exclusively\n+\n+-- Create a test table and verify that the output of SHOW INDEXES is sane.\n+-- The matching of actual/expected results relies on the fact that the output of SHOW INDEX is sorted.\n+DROP TABLE IF EXISTS tbl;\n+CREATE TABLE tbl\n+(\n+    a UInt64,\n+    b UInt64,\n+    c UInt64,\n+    d UInt64,\n+    e UInt64,\n+    INDEX mm1_idx (a, c, d) TYPE minmax,\n+    INDEX mm2_idx (c, d, e) TYPE minmax,\n+    INDEX set_idx (e)       TYPE set(100),\n+    INDEX blf_idx (d, b)    TYPE bloom_filter(0.8)\n+)\n+ENGINE = MergeTree\n+PRIMARY KEY (c, a);\n+\n+SELECT '--- Aliases of SHOW INDEX';\n+SHOW INDEX FROM tbl;\n+SHOW INDEXES FROM tbl;\n+SHOW KEYS FROM tbl;\n+\n+SELECT '--- EXTENDED';\n+SHOW EXTENDED INDEX FROM tbl;\n+--\n+SELECT '--- WHERE';\n+SHOW INDEX FROM tbl WHERE index_type LIKE '%minmax%';\n+\n+SELECT '--- Check with weird table names';\n+\n+DROP TABLE IF EXISTS `$4@^7`;\n+CREATE TABLE `$4@^7` (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW INDEX FROM `$4@^7`;\n+DROP TABLE `$4@^7`;\n+\n+DROP TABLE IF EXISTS NULL;\n+CREATE TABLE NULL (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW INDEX FROM NULL;\n+DROP TABLE NULL;\n+\n+DROP DATABASE IF EXISTS `'`;\n+CREATE DATABASE `'`;\n+CREATE TABLE `'`.`'` (c String) ENGINE = MergeTree ORDER BY c;\n+SHOW INDEX FROM `'` FROM `'`;\n+SHOW INDEX FROM `'`.`'`; -- abbreviated form\n+DROP TABLE `'`.`'`;\n+DROP DATABASE `'`;\n+\n+-- Create a table in a different database. Intentionally using the same table/column names as above so\n+-- we notice if something is buggy in the implementation of SHOW INDEX.\n+DROP DATABASE IF EXISTS database_123456789abcde;\n+CREATE DATABASE database_123456789abcde; -- pseudo-random database name\n+\n+DROP TABLE IF EXISTS database_123456789abcde.tbl;\n+CREATE TABLE database_123456789abcde.tbl\n+(\n+    a UInt64,\n+    b UInt64,\n+    INDEX mmi_idx b TYPE minmax\n+)\n+ENGINE = MergeTree\n+PRIMARY KEY a;\n+\n+SELECT '--- Original table';\n+SHOW INDEX FROM tbl;\n+\n+SELECT '--- Equally named table in other database';\n+SHOW INDEX FROM tbl FROM database_123456789abcde;\n+\n+SELECT '--- Short form';\n+SHOW INDEX FROM database_123456789abcde.tbl;\n+\n+DROP DATABASE database_123456789abcde;\n+\n+DROP TABLE tbl;\n",
  "problem_statement": "MySQL compatibility: SHOW KEYS\n**Use case**\r\n\r\nSome BI tools like QuickSight want to query indices using the following query:\r\n\r\n```mysql\r\nSHOW KEYS FROM `cell_towers` FROM `default`;\r\n```\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use: the latest main branch version will do. I used the head Docker image from the beginning of April: `23.4.1.170`\r\n* Which interface to use, if it matters: MySQL\r\n* `CREATE TABLE` statements for all tables involved: use [cell towers](https://clickhouse.com/docs/en/getting-started/example-datasets/cell-towers) dataset, then query via MySQL protocol\r\n\r\n**Describe the solution you'd like**\r\n\r\nSHOW KEYS statement is supported.\r\n\n",
  "hints_text": "",
  "created_at": "2023-04-25T20:50:28Z",
  "modified_files": [
    "docs/en/sql-reference/statements/show.md",
    "src/Interpreters/InterpreterFactory.cpp",
    "src/Interpreters/InterpreterShowColumnsQuery.cpp",
    "b/src/Interpreters/InterpreterShowIndexesQuery.cpp",
    "b/src/Interpreters/InterpreterShowIndexesQuery.h",
    "src/Parsers/ASTShowColumnsQuery.cpp",
    "src/Parsers/ASTShowColumnsQuery.h",
    "b/src/Parsers/ASTShowIndexesQuery.cpp",
    "b/src/Parsers/ASTShowIndexesQuery.h",
    "src/Parsers/ParserQueryWithOutput.cpp",
    "src/Parsers/ParserShowColumnsQuery.cpp",
    "src/Parsers/ParserShowColumnsQuery.h",
    "b/src/Parsers/ParserShowIndexesQuery.cpp",
    "b/src/Parsers/ParserShowIndexesQuery.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02706_show_columns.reference",
    "tests/queries/0_stateless/02706_show_columns.sql",
    "b/tests/queries/0_stateless/02724_show_indexes.reference",
    "b/tests/queries/0_stateless/02724_show_indexes.sql"
  ]
}