diff --git a/docs/en/sql-reference/statements/show.md b/docs/en/sql-reference/statements/show.md
index 428a04ae030d..45d09c2dec7e 100644
--- a/docs/en/sql-reference/statements/show.md
+++ b/docs/en/sql-reference/statements/show.md
@@ -98,22 +98,6 @@ Result:
 
 - [CREATE DATABASE](https://clickhouse.com/docs/en/sql-reference/statements/create/database/#query-language-create-database)
 
-## SHOW PROCESSLIST
-
-``` sql
-SHOW PROCESSLIST [INTO OUTFILE filename] [FORMAT format]
-```
-
-Outputs the content of the [system.processes](../../operations/system-tables/processes.md#system_tables-processes) table, that contains a list of queries that is being processed at the moment, excepting `SHOW PROCESSLIST` queries.
-
-The `SELECT * FROM system.processes` query returns data about all the current queries.
-
-Tip (execute in the console):
-
-``` bash
-$ watch -n1 "clickhouse-client --query='SHOW PROCESSLIST'"
-```
-
 ## SHOW TABLES
 
 Displays a list of tables.
@@ -277,6 +261,77 @@ SHOW DICTIONARIES FROM db LIKE '%reg%' LIMIT 2
 └──────────────┘
 ```
 
+## SHOW INDEX
+
+Displays a list of primary and data skipping indexes of a table.
+
+```sql
+SHOW [EXTENDED] {INDEX | INDEXES | KEYS } {FROM | IN} <table> [{FROM | IN} <db>] [WHERE <expr>] [INTO OUTFILE <filename>] [FORMAT <format>]
+```
+
+The database and table name can be specified in abbreviated form as `<db>.<table>`, i.e. `FROM tab FROM db` and `FROM db.tab` are
+equivalent. If no database is specified, the query assumes the current database as database.
+
+The optional keyword `EXTENDED` currently has no effect, it only exists for MySQL compatibility.
+
+`SHOW INDEX` produces a result table with the following structure:
+- table - The name of the table (String)
+- non_unique - 0 if the index can contain duplicates, 1 otherwise (UInt8)
+- key_name - The name of the index, `PRIMARY` if the index is a primary key index (String)
+- seq_in_index - Currently unused
+- column_name - Currently unused
+- collation - The sorting of the column in the index, `A` if ascending, `D` if descending, `NULL` if unsorted (Nullable(String))
+- cardinality - Currently unused
+- sub_part - Currently unused
+- packed - Currently unused
+- null - Currently unused
+- index_type - The index type, e.g. `primary`, `minmax`, `bloom_filter` etc. (String)
+- comment - Currently unused
+- index_comment - Currently unused
+- visible - If the index is visible to the optimizer, always `YES` (String)
+- expression - The index expression (String)
+
+**Examples**
+
+Getting information about all indexes in table 'tbl'
+
+```sql
+SHOW INDEX FROM 'tbl'
+```
+
+Result:
+
+``` text
+┌─table─┬─non_unique─┬─key_name─┬─seq_in_index─┬─column_name─┬─collation─┬─cardinality─┬─sub_part─┬─packed─┬─null─┬─index_type───┬─comment─┬─index_comment─┬─visible─┬─expression─┐
+│ tbl   │          0 │ blf_idx  │ ᴺᵁᴸᴸ         │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ      │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ     │ ᴺᵁᴸᴸ   │ ᴺᵁᴸᴸ │ bloom_filter │ ᴺᵁᴸᴸ    │ ᴺᵁᴸᴸ          │ YES     │ d, b       │
+│ tbl   │          0 │ mm1_idx  │ ᴺᵁᴸᴸ         │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ      │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ     │ ᴺᵁᴸᴸ   │ ᴺᵁᴸᴸ │ minmax       │ ᴺᵁᴸᴸ    │ ᴺᵁᴸᴸ          │ YES     │ a, c, d    │
+│ tbl   │          0 │ mm2_idx  │ ᴺᵁᴸᴸ         │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ      │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ     │ ᴺᵁᴸᴸ   │ ᴺᵁᴸᴸ │ minmax       │ ᴺᵁᴸᴸ    │ ᴺᵁᴸᴸ          │ YES     │ c, d, e    │
+│ tbl   │          0 │ PRIMARY  │ ᴺᵁᴸᴸ         │ ᴺᵁᴸᴸ        │ A         │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ     │ ᴺᵁᴸᴸ   │ ᴺᵁᴸᴸ │ primary      │ ᴺᵁᴸᴸ    │ ᴺᵁᴸᴸ          │ YES     │ c, a       │
+│ tbl   │          0 │ set_idx  │ ᴺᵁᴸᴸ         │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ      │ ᴺᵁᴸᴸ        │ ᴺᵁᴸᴸ     │ ᴺᵁᴸᴸ   │ ᴺᵁᴸᴸ │ set          │ ᴺᵁᴸᴸ    │ ᴺᵁᴸᴸ          │ YES     │ e          │
+└───────┴────────────┴──────────┴──────────────┴─────────────┴───────────┴─────────────┴──────────┴────────┴──────┴──────────────┴─────────┴───────────────┴─────────┴────────────┘
+```
+
+**See also**
+
+- [system.tables](../../operations/system-tables/tables.md)
+- [system.data_skipping_indices](../../operations/system-tables/data_skipping_indices.md)
+
+## SHOW PROCESSLIST
+
+``` sql
+SHOW PROCESSLIST [INTO OUTFILE filename] [FORMAT format]
+```
+
+Outputs the content of the [system.processes](../../operations/system-tables/processes.md#system_tables-processes) table, that contains a list of queries that is being processed at the moment, excepting `SHOW PROCESSLIST` queries.
+
+The `SELECT * FROM system.processes` query returns data about all the current queries.
+
+Tip (execute in the console):
+
+``` bash
+$ watch -n1 "clickhouse-client --query='SHOW PROCESSLIST'"
+```
+
 ## SHOW GRANTS
 
 Shows privileges for a user.
diff --git a/src/Interpreters/InterpreterFactory.cpp b/src/Interpreters/InterpreterFactory.cpp
index 68b22b550f63..eec73fa56e25 100644
--- a/src/Interpreters/InterpreterFactory.cpp
+++ b/src/Interpreters/InterpreterFactory.cpp
@@ -22,6 +22,7 @@
 #include <Parsers/ASTShowProcesslistQuery.h>
 #include <Parsers/ASTShowTablesQuery.h>
 #include <Parsers/ASTShowColumnsQuery.h>
+#include <Parsers/ASTShowIndexesQuery.h>
 #include <Parsers/ASTUseQuery.h>
 #include <Parsers/ASTWatchQuery.h>
 #include <Parsers/ASTCreateNamedCollectionQuery.h>
@@ -81,6 +82,7 @@
 #include <Interpreters/InterpreterShowProcesslistQuery.h>
 #include <Interpreters/InterpreterShowTablesQuery.h>
 #include <Interpreters/InterpreterShowColumnsQuery.h>
+#include <Interpreters/InterpreterShowIndexesQuery.h>
 #include <Interpreters/InterpreterSystemQuery.h>
 #include <Interpreters/InterpreterUseQuery.h>
 #include <Interpreters/InterpreterWatchQuery.h>
@@ -181,6 +183,10 @@ std::unique_ptr<IInterpreter> InterpreterFactory::get(ASTPtr & query, ContextMut
     {
         return std::make_unique<InterpreterShowColumnsQuery>(query, context);
     }
+    else if (query->as<ASTShowIndexesQuery>())
+    {
+        return std::make_unique<InterpreterShowIndexesQuery>(query, context);
+    }
     else if (query->as<ASTShowEnginesQuery>())
     {
         return std::make_unique<InterpreterShowEnginesQuery>(query, context);
diff --git a/src/Interpreters/InterpreterShowColumnsQuery.cpp b/src/Interpreters/InterpreterShowColumnsQuery.cpp
index 4474be21d8b0..c86d3c753c49 100644
--- a/src/Interpreters/InterpreterShowColumnsQuery.cpp
+++ b/src/Interpreters/InterpreterShowColumnsQuery.cpp
@@ -1,12 +1,12 @@
 #include <Interpreters/InterpreterShowColumnsQuery.h>
 
+#include <Common/quoteString.h>
+#include <IO/Operators.h>
 #include <IO/WriteBufferFromString.h>
 #include <Parsers/ASTShowColumnsQuery.h>
 #include <Parsers/formatAST.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/executeQuery.h>
-#include <IO/Operators.h>
-#include <boost/algorithm/string.hpp>
 
 
 namespace DB
@@ -24,9 +24,23 @@ String InterpreterShowColumnsQuery::getRewrittenQuery()
 {
     const auto & query = query_ptr->as<ASTShowColumnsQuery &>();
 
-    WriteBufferFromOwnString rewritten_query;
+    WriteBufferFromOwnString buf_database;
+    String resolved_database = getContext()->resolveDatabase(query.database);
+    writeEscapedString(resolved_database, buf_database);
+    String database = buf_database.str();
+
+    WriteBufferFromOwnString buf_table;
+    writeEscapedString(query.table, buf_table);
+    String table = buf_table.str();
 
-    rewritten_query << "SELECT name AS field, type AS type, startsWith(type, 'Nullable') AS null, trim(concatWithSeparator(' ', if(is_in_primary_key, 'PRI', ''), if (is_in_sorting_key, 'SOR', ''))) AS key, if(default_kind IN ('ALIAS', 'DEFAULT', 'MATERIALIZED'), default_expression, NULL) AS default, '' AS extra ";
+    String rewritten_query = R"(
+SELECT
+    name AS field,
+    type AS type,
+    startsWith(type, 'Nullable') AS null,
+    trim(concatWithSeparator(' ', if (is_in_primary_key, 'PRI', ''), if (is_in_sorting_key, 'SOR', ''))) AS key,
+    if (default_kind IN ('ALIAS', 'DEFAULT', 'MATERIALIZED'), default_expression, NULL) AS default,
+    '' AS extra )";
 
     // TODO Interpret query.extended. It is supposed to show internal/virtual columns. Need to fetch virtual column names, see
     // IStorage::getVirtuals(). We can't easily do that via SQL.
@@ -37,60 +51,41 @@ String InterpreterShowColumnsQuery::getRewrittenQuery()
         /// - collation: no such thing in ClickHouse
         /// - comment
         /// - privileges: <not implemented, TODO ask system.grants>
-        rewritten_query << ", NULL AS collation, comment, '' AS privileges ";
+        rewritten_query += R"(,
+    NULL AS collation,
+    comment,
+    '' AS privileges )";
     }
 
-    rewritten_query << "FROM system.columns WHERE ";
+    rewritten_query += fmt::format(R"(
+FROM system.columns
+WHERE
+    database = '{}'
+    AND table = '{}' )", database, table);
 
-    String database;
-    String table;
-    if (query.from_table.contains("."))
-    {
-        /// FROM <db>.<table> (abbreviated form)
-        chassert(query.from_database.empty());
-        std::vector<String> split;
-        boost::split(split, query.from_table, boost::is_any_of("."));
-        chassert(split.size() == 2);
-        database = split[0];
-        table = split[1];
-    }
-    else if (query.from_database.empty())
-    {
-        /// FROM <table>
-        chassert(!query.from_table.empty());
-        database = getContext()->getCurrentDatabase();
-        table = query.from_table;
-    }
-    else
+    if (!query.like.empty())
     {
-        /// FROM <database> FROM <table>
-        chassert(!query.from_database.empty());
-        chassert(!query.from_table.empty());
-        database = query.from_database;
-        table = query.from_table;
+        rewritten_query += " AND name ";
+        if (query.not_like)
+            rewritten_query += "NOT ";
+        if (query.case_insensitive_like)
+            rewritten_query += "ILIKE ";
+        else
+            rewritten_query += "LIKE ";
+        rewritten_query += fmt::format("'{}'", query.like);
     }
-    rewritten_query << "database = " << DB::quote << database;
-    rewritten_query << " AND table = " << DB::quote << table;
-
-    if (!query.like.empty())
-        rewritten_query
-            << " AND name "
-            << (query.not_like ? "NOT " : "")
-            << (query.case_insensitive_like ? "ILIKE " : "LIKE ")
-            << DB::quote << query.like;
     else if (query.where_expression)
-        rewritten_query << " AND (" << query.where_expression << ")";
+        rewritten_query += fmt::format(" AND ({})", query.where_expression);
 
     /// Sorting is strictly speaking not necessary but 1. it is convenient for users, 2. SQL currently does not allow to
     /// sort the output of SHOW COLUMNS otherwise (SELECT * FROM (SHOW COLUMNS ...) ORDER BY ...) is rejected) and 3. some
     /// SQL tests can take advantage of this.
-    rewritten_query << " ORDER BY field, type, null, key, default, extra";
+    rewritten_query += " ORDER BY field, type, null, key, default, extra";
 
     if (query.limit_length)
-        rewritten_query << " LIMIT " << query.limit_length;
-
-    return rewritten_query.str();
+        rewritten_query += fmt::format(" LIMIT {}", query.limit_length);
 
+    return rewritten_query;
 }
 
 
diff --git a/src/Interpreters/InterpreterShowIndexesQuery.cpp b/src/Interpreters/InterpreterShowIndexesQuery.cpp
new file mode 100644
index 000000000000..51311c82eebc
--- /dev/null
+++ b/src/Interpreters/InterpreterShowIndexesQuery.cpp
@@ -0,0 +1,100 @@
+#include <Interpreters/InterpreterShowIndexesQuery.h>
+
+#include <Common/quoteString.h>
+#include <IO/Operators.h>
+#include <IO/WriteBufferFromString.h>
+#include <Parsers/ASTShowIndexesQuery.h>
+#include <Parsers/formatAST.h>
+#include <Interpreters/Context.h>
+#include <Interpreters/executeQuery.h>
+
+
+namespace DB
+{
+
+
+InterpreterShowIndexesQuery::InterpreterShowIndexesQuery(const ASTPtr & query_ptr_, ContextMutablePtr context_)
+    : WithMutableContext(context_)
+    , query_ptr(query_ptr_)
+{
+}
+
+
+String InterpreterShowIndexesQuery::getRewrittenQuery()
+{
+    const auto & query = query_ptr->as<ASTShowIndexesQuery &>();
+
+    WriteBufferFromOwnString buf_table;
+    writeEscapedString(query.table, buf_table);
+    String table = buf_table.str();
+
+    WriteBufferFromOwnString buf_database;
+    String resolved_database = getContext()->resolveDatabase(query.database);
+    writeEscapedString(resolved_database, buf_database);
+    String database = buf_database.str();
+
+    String where_expression = query.where_expression ? fmt::format("WHERE ({})", query.where_expression) : "";
+
+    String rewritten_query = fmt::format(R"(
+SELECT *
+FROM (
+        (SELECT
+            name AS table,
+            0 AS non_unique,
+            'PRIMARY' AS key_name,
+            NULL AS seq_in_index,
+            NULL AS column_name,
+            'A' AS collation,
+            NULL AS cardinality,
+            NULL AS sub_part,
+            NULL AS packed,
+            NULL AS null,
+            'primary' AS index_type,
+            NULL AS comment,
+            NULL AS index_comment,
+            'YES' AS visible,
+            primary_key AS expression
+        FROM system.tables
+        WHERE
+            database = '{0}'
+            AND name = '{1}')
+    UNION ALL (
+        SELECT
+            table AS table,
+            0 AS non_unique,
+            name AS key_name,
+            NULL AS seq_in_index,
+            NULL AS column_name,
+            NULL AS collation,
+            NULL AS cardinality,
+            NULL AS sub_part,
+            NULL AS packed,
+            NULL AS null,
+            type AS index_type,
+            NULL AS comment,
+            NULL AS index_comment,
+            'YES' AS visible,
+            expr AS expression
+        FROM system.data_skipping_indices
+        WHERE
+            database = '{0}'
+            AND table = '{1}'))
+{2}
+ORDER BY index_type, expression;)", database, table, where_expression);
+
+    /// Sorting is strictly speaking not necessary but 1. it is convenient for users, 2. SQL currently does not allow to
+    /// sort the output of SHOW INDEXES otherwise (SELECT * FROM (SHOW INDEXES ...) ORDER BY ...) is rejected) and 3. some
+    /// SQL tests can take advantage of this.
+
+    return rewritten_query;
+}
+
+
+BlockIO InterpreterShowIndexesQuery::execute()
+{
+    return executeQuery(getRewrittenQuery(), getContext(), true);
+}
+
+
+}
+
diff --git a/src/Interpreters/InterpreterShowIndexesQuery.h b/src/Interpreters/InterpreterShowIndexesQuery.h
new file mode 100644
index 000000000000..0b4fa591e352
--- /dev/null
+++ b/src/Interpreters/InterpreterShowIndexesQuery.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include <Interpreters/IInterpreter.h>
+#include <Parsers/IAST_fwd.h>
+
+
+namespace DB
+{
+
+class Context;
+
+
+/// Returns a list of indexes which meet some conditions.
+class InterpreterShowIndexesQuery : public IInterpreter, WithMutableContext
+{
+public:
+    InterpreterShowIndexesQuery(const ASTPtr & query_ptr_, ContextMutablePtr context_);
+
+    BlockIO execute() override;
+
+    /// Ignore quota and limits here because execute() produces a SELECT query which checks quotas/limits by itself.
+    bool ignoreQuota() const override { return true; }
+    bool ignoreLimits() const override { return true; }
+
+private:
+    ASTPtr query_ptr;
+
+    String getRewrittenQuery();
+};
+
+
+}
+
diff --git a/src/Parsers/ASTShowColumnsQuery.cpp b/src/Parsers/ASTShowColumnsQuery.cpp
index 1cb4b651f0ab..a02dba9c288f 100644
--- a/src/Parsers/ASTShowColumnsQuery.cpp
+++ b/src/Parsers/ASTShowColumnsQuery.cpp
@@ -24,9 +24,9 @@ void ASTShowColumnsQuery::formatQueryImpl(const FormatSettings & settings, Forma
                   << "COLUMNS"
                   << (settings.hilite ? hilite_none : "");
 
-    settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(from_table);
-    if (!from_database.empty())
-        settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(from_database);
+    settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(table);
+    if (!database.empty())
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(database);
 
 
     if (!like.empty())
diff --git a/src/Parsers/ASTShowColumnsQuery.h b/src/Parsers/ASTShowColumnsQuery.h
index 79e8a67b5580..b49d688dcdb9 100644
--- a/src/Parsers/ASTShowColumnsQuery.h
+++ b/src/Parsers/ASTShowColumnsQuery.h
@@ -18,8 +18,8 @@ class ASTShowColumnsQuery : public ASTQueryWithOutput
     ASTPtr where_expression;
     ASTPtr limit_length;
 
-    String from_database;
-    String from_table;
+    String database;
+    String table;
 
     String like;
 
diff --git a/src/Parsers/ASTShowIndexesQuery.cpp b/src/Parsers/ASTShowIndexesQuery.cpp
new file mode 100644
index 000000000000..df1e242a2393
--- /dev/null
+++ b/src/Parsers/ASTShowIndexesQuery.cpp
@@ -0,0 +1,38 @@
+#include <Parsers/ASTShowIndexesQuery.h>
+
+#include <iomanip>
+#include <Common/quoteString.h>
+#include <IO/Operators.h>
+
+namespace DB
+{
+
+ASTPtr ASTShowIndexesQuery::clone() const
+{
+    auto res = std::make_shared<ASTShowIndexesQuery>(*this);
+    res->children.clear();
+    cloneOutputOptions(*res);
+    return res;
+}
+
+void ASTShowIndexesQuery::formatQueryImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
+{
+    settings.ostr << (settings.hilite ? hilite_keyword : "")
+                  << "SHOW "
+                  << (extended ? "EXTENDED " : "")
+                  << "INDEXES"
+                  << (settings.hilite ? hilite_none : "");
+
+    settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(table);
+    if (!database.empty())
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(database);
+
+    if (where_expression)
+    {
+        settings.ostr << (settings.hilite ? hilite_keyword : "") << " WHERE " << (settings.hilite ? hilite_none : "");
+        where_expression->formatImpl(settings, state, frame);
+    }
+}
+
+}
+
diff --git a/src/Parsers/ASTShowIndexesQuery.h b/src/Parsers/ASTShowIndexesQuery.h
new file mode 100644
index 000000000000..ab504bf71dae
--- /dev/null
+++ b/src/Parsers/ASTShowIndexesQuery.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include <Parsers/IAST_fwd.h>
+#include <Parsers/ASTQueryWithOutput.h>
+
+namespace DB
+{
+
+/// Query SHOW INDEXES
+class ASTShowIndexesQuery : public ASTQueryWithOutput
+{
+public:
+    bool extended = false;
+
+    ASTPtr where_expression;
+
+    String database;
+    String table;
+
+    String getID(char) const override { return "ShowColumns"; }
+    ASTPtr clone() const override;
+    QueryKind getQueryKind() const override { return QueryKind::Show; }
+
+protected:
+    void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;
+};
+
+}
+
diff --git a/src/Parsers/ParserQueryWithOutput.cpp b/src/Parsers/ParserQueryWithOutput.cpp
index 2fb7c406d74a..22e32fa5c459 100644
--- a/src/Parsers/ParserQueryWithOutput.cpp
+++ b/src/Parsers/ParserQueryWithOutput.cpp
@@ -18,6 +18,7 @@
 #include <Parsers/ParserShowTablesQuery.h>
 #include <Parsers/ParserShowColumnsQuery.h>
 #include <Parsers/ParserShowEngineQuery.h>
+#include <Parsers/ParserShowIndexesQuery.h>
 #include <Parsers/ParserTablePropertiesQuery.h>
 #include <Parsers/ParserWatchQuery.h>
 #include <Parsers/ParserDescribeCacheQuery.h>
@@ -39,6 +40,7 @@ bool ParserQueryWithOutput::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
     ParserShowTablesQuery show_tables_p;
     ParserShowColumnsQuery show_columns_p;
     ParserShowEnginesQuery show_engine_p;
+    ParserShowIndexesQuery show_indexes_p;
     ParserSelectWithUnionQuery select_p;
     ParserTablePropertiesQuery table_p;
     ParserDescribeTableQuery describe_table_p;
@@ -69,6 +71,7 @@ bool ParserQueryWithOutput::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
         || show_tables_p.parse(pos, query, expected)
         || show_columns_p.parse(pos, query, expected)
         || show_engine_p.parse(pos, query, expected)
+        || show_indexes_p.parse(pos, query, expected)
         || table_p.parse(pos, query, expected)
         || describe_cache_p.parse(pos, query, expected)
         || describe_table_p.parse(pos, query, expected)
diff --git a/src/Parsers/ParserShowColumnsQuery.cpp b/src/Parsers/ParserShowColumnsQuery.cpp
index 03e66e4ae0fa..e5fc5c39701a 100644
--- a/src/Parsers/ParserShowColumnsQuery.cpp
+++ b/src/Parsers/ParserShowColumnsQuery.cpp
@@ -7,14 +7,19 @@
 #include <Parsers/ExpressionElementParsers.h>
 #include <Parsers/ExpressionListParsers.h>
 
+#include <boost/algorithm/string.hpp>
+
 namespace DB
 {
 
 bool ParserShowColumnsQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     ASTPtr like;
-    ASTPtr from_database;
-    ASTPtr from_table;
+    ASTPtr from1;
+    ASTPtr from2;
+
+    String from1_str;
+    String from2_str;
 
     auto query = std::make_shared<ASTShowColumnsQuery>();
 
@@ -27,26 +32,38 @@ bool ParserShowColumnsQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     if (ParserKeyword("FULL").ignore(pos, expected))
         query->full = true;
 
-    if (!ParserKeyword("COLUMNS").ignore(pos, expected) || ParserKeyword("FIELDS").ignore(pos, expected))
+    if (!(ParserKeyword("COLUMNS").ignore(pos, expected) || ParserKeyword("FIELDS").ignore(pos, expected)))
         return false;
 
     if (ParserKeyword("FROM").ignore(pos, expected) || ParserKeyword("IN").ignore(pos, expected))
     {
-        if (!ParserCompoundIdentifier().parse(pos, from_table, expected))
+        if (!ParserCompoundIdentifier().parse(pos, from1, expected))
             return false;
     }
     else
         return false;
 
-    tryGetIdentifierNameInto(from_table, query->from_table);
-    bool abbreviated_form = query->from_table.contains("."); /// FROM <db>.<table>
+    tryGetIdentifierNameInto(from1, from1_str);
 
-    if (!abbreviated_form)
+    bool abbreviated_form = from1_str.contains("."); // FROM database.table
+    if (abbreviated_form)
+    {
+        std::vector<String> split;
+        boost::split(split, from1_str, boost::is_any_of("."));
+        query->database = split[0];
+        query->table = split[1];
+    }
+    else
+    {
         if (ParserKeyword("FROM").ignore(pos, expected) || ParserKeyword("IN").ignore(pos, expected))
-            if (!ParserIdentifier().parse(pos, from_database, expected))
+            if (!ParserIdentifier().parse(pos, from2, expected))
                 return false;
 
-    tryGetIdentifierNameInto(from_database, query->from_database);
+        tryGetIdentifierNameInto(from2, from2_str);
+
+        query->table = from1_str;
+        query->database = from2_str;
+    }
 
     if (ParserKeyword("NOT").ignore(pos, expected))
         query->not_like = true;
diff --git a/src/Parsers/ParserShowColumnsQuery.h b/src/Parsers/ParserShowColumnsQuery.h
index 999acf722afa..a2941ca71d11 100644
--- a/src/Parsers/ParserShowColumnsQuery.h
+++ b/src/Parsers/ParserShowColumnsQuery.h
@@ -6,7 +6,7 @@ namespace DB
 {
 
 /** Parses queries of the form
- * SHOW [EXTENDED] [FULL] COLUMNS (FROM|IN) tbl [(FROM|IN) db] [(([NOT] (LIKE|ILIKE) expr) | (WHERE expr))] [LIMIT n]
+ * SHOW [EXTENDED] [FULL] COLUMNS FROM|IN tbl [FROM|IN db] [[NOT] LIKE|ILIKE expr | WHERE expr] [LIMIT n]
  */
 class ParserShowColumnsQuery : public IParserBase
 {
diff --git a/src/Parsers/ParserShowIndexesQuery.cpp b/src/Parsers/ParserShowIndexesQuery.cpp
new file mode 100644
index 000000000000..fe08b4630692
--- /dev/null
+++ b/src/Parsers/ParserShowIndexesQuery.cpp
@@ -0,0 +1,74 @@
+#include <Parsers/ParserShowIndexesQuery.h>
+
+#include <Parsers/ASTIdentifier_fwd.h>
+#include <Parsers/ASTLiteral.h>
+#include <Parsers/ASTShowIndexesQuery.h>
+#include <Parsers/CommonParsers.h>
+#include <Parsers/ExpressionElementParsers.h>
+#include <Parsers/ExpressionListParsers.h>
+
+#include <boost/algorithm/string.hpp>
+
+namespace DB
+{
+
+bool ParserShowIndexesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ASTPtr from1;
+    ASTPtr from2;
+
+    String from1_str;
+    String from2_str;
+
+    auto query = std::make_shared<ASTShowIndexesQuery>();
+
+    if (!ParserKeyword("SHOW").ignore(pos, expected))
+        return false;
+
+    if (ParserKeyword("EXTENDED").ignore(pos, expected))
+        query->extended = true;
+
+    if (!(ParserKeyword("INDEX").ignore(pos, expected) || ParserKeyword("INDEXES").ignore(pos, expected) || ParserKeyword("KEYS").ignore(pos, expected)))
+        return false;
+
+    if (ParserKeyword("FROM").ignore(pos, expected) || ParserKeyword("IN").ignore(pos, expected))
+    {
+        if (!ParserCompoundIdentifier().parse(pos, from1, expected))
+            return false;
+    }
+    else
+        return false;
+
+    tryGetIdentifierNameInto(from1, from1_str);
+
+    bool abbreviated_form = from1_str.contains("."); // FROM database.table
+    if (abbreviated_form)
+    {
+        std::vector<String> split;
+        boost::split(split, from1_str, boost::is_any_of("."));
+        query->database = split[0];
+        query->table = split[1];
+    }
+    else
+    {
+        if (ParserKeyword("FROM").ignore(pos, expected) || ParserKeyword("IN").ignore(pos, expected))
+            if (!ParserIdentifier().parse(pos, from2, expected))
+                return false;
+
+        tryGetIdentifierNameInto(from2, from2_str);
+
+        query->table = from1_str;
+        query->database = from2_str;
+    }
+
+    if (ParserKeyword("WHERE").ignore(pos, expected))
+        if (!ParserExpressionWithOptionalAlias(false).parse(pos, query->where_expression, expected))
+            return false;
+
+    node = query;
+
+    return true;
+}
+
+}
+
diff --git a/src/Parsers/ParserShowIndexesQuery.h b/src/Parsers/ParserShowIndexesQuery.h
new file mode 100644
index 000000000000..0ece5e89ef73
--- /dev/null
+++ b/src/Parsers/ParserShowIndexesQuery.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <Parsers/IParserBase.h>
+
+namespace DB
+{
+
+/** Parses queries of the form
+ * SHOW [EXTENDED] INDEX|INDEXES|KEYS FROM|IN tbl [FROM|IN db] [WHERE expr]
+ */
+class ParserShowIndexesQuery : public IParserBase
+{
+protected:
+    const char * getName() const override { return "SHOW INDEXES query"; }
+
+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+};
+
+}
+
