{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33927,
  "instance_id": "ClickHouse__ClickHouse-33927",
  "issue_numbers": [
    "29791",
    "28322",
    "21647"
  ],
  "base_commit": "a30c3d17726fc476c17a8cc7a38fd733f8f3ca44",
  "patch": "diff --git a/src/Common/IntervalTree.h b/src/Common/IntervalTree.h\nindex dc2987247d8d..608bd5cf12cb 100644\n--- a/src/Common/IntervalTree.h\n+++ b/src/Common/IntervalTree.h\n@@ -291,6 +291,15 @@ class IntervalTree\n \n     size_t getIntervalsSize() const { return intervals_size; }\n \n+    size_t getSizeInBytes() const\n+    {\n+        size_t nodes_size_in_bytes = nodes.size() * sizeof(Node);\n+        size_t intervals_size_in_bytes = sorted_intervals.size() * sizeof(IntervalWithValue);\n+        size_t result = nodes_size_in_bytes + intervals_size_in_bytes;\n+\n+        return result;\n+    }\n+\n private:\n     struct Node\n     {\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 416f759924c5..5bc089e085fd 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -523,6 +523,7 @@ inline bool isBool(const DataTypePtr & data_type)\n template <typename DataType> constexpr bool IsDataTypeDecimal = false;\n template <typename DataType> constexpr bool IsDataTypeNumber = false;\n template <typename DataType> constexpr bool IsDataTypeDateOrDateTime = false;\n+template <typename DataType> constexpr bool IsDataTypeEnum = false;\n \n template <typename DataType> constexpr bool IsDataTypeDecimalOrNumber = IsDataTypeDecimal<DataType> || IsDataTypeNumber<DataType>;\n \n@@ -547,4 +548,9 @@ template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDate32> = tru\n template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDateTime> = true;\n template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDateTime64> = true;\n \n+template <typename T>\n+class DataTypeEnum;\n+\n+template <typename T> inline constexpr bool IsDataTypeEnum<DataTypeEnum<T>> = true;\n+\n }\ndiff --git a/src/Dictionaries/DictionarySource.cpp b/src/Dictionaries/DictionarySource.cpp\nindex d3058db87f48..526d9fc85cdc 100644\n--- a/src/Dictionaries/DictionarySource.cpp\n+++ b/src/Dictionaries/DictionarySource.cpp\n@@ -60,8 +60,8 @@ class DictionarySource : public SourceWithProgress\n         const auto & attributes_types_to_read = coordinator->getAttributesTypesToRead();\n         const auto & attributes_default_values_columns = coordinator->getAttributesDefaultValuesColumns();\n \n-        const auto & dictionary = coordinator->getDictionary();\n-        auto attributes_columns = dictionary->getColumns(\n+        const auto & read_columns_func = coordinator->getReadColumnsFunc();\n+        auto attributes_columns = read_columns_func(\n             attributes_names_to_read,\n             attributes_types_to_read,\n             key_columns,\ndiff --git a/src/Dictionaries/DictionarySource.h b/src/Dictionaries/DictionarySource.h\nindex 0237e1338dfb..7809c9584198 100644\n--- a/src/Dictionaries/DictionarySource.h\n+++ b/src/Dictionaries/DictionarySource.h\n@@ -19,6 +19,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou\n \n public:\n \n+    using ReadColumnsFunc = std::function<Columns (const Strings &, const DataTypes &, const Columns &, const DataTypes &, const Columns &)>;\n+\n     Pipe read(size_t num_streams);\n \n private:\n@@ -31,6 +33,15 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou\n         : dictionary(std::move(dictionary_))\n         , key_columns_with_type(std::move(key_columns_with_type_))\n         , max_block_size(max_block_size_)\n+        , read_columns_func([this](\n+            const Strings & attribute_names,\n+            const DataTypes & result_types,\n+            const Columns & key_columns,\n+            const DataTypes & key_types,\n+            const Columns & default_values_columns)\n+        {\n+            return dictionary->getColumns(attribute_names, result_types, key_columns, key_types, default_values_columns);\n+        })\n     {\n         initialize(column_names);\n     }\n@@ -45,6 +56,31 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou\n         , key_columns_with_type(std::move(key_columns_with_type_))\n         , data_columns_with_type(std::move(data_columns_with_type_))\n         , max_block_size(max_block_size_)\n+        , read_columns_func([this](\n+            const Strings & attribute_names,\n+            const DataTypes & result_types,\n+            const Columns & key_columns,\n+            const DataTypes & key_types,\n+            const Columns & default_values_columns)\n+        {\n+            return dictionary->getColumns(attribute_names, result_types, key_columns, key_types, default_values_columns);\n+        })\n+    {\n+        initialize(column_names);\n+    }\n+\n+    explicit DictionarySourceCoordinator(\n+        std::shared_ptr<const IDictionary> dictionary_,\n+        const Names & column_names,\n+        ColumnsWithTypeAndName && key_columns_with_type_,\n+        ColumnsWithTypeAndName && data_columns_with_type_,\n+        size_t max_block_size_,\n+        ReadColumnsFunc read_columns_func_)\n+        : dictionary(std::move(dictionary_))\n+        , key_columns_with_type(std::move(key_columns_with_type_))\n+        , data_columns_with_type(std::move(data_columns_with_type_))\n+        , max_block_size(max_block_size_)\n+        , read_columns_func(std::move(read_columns_func_))\n     {\n         initialize(column_names);\n     }\n@@ -61,6 +97,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou\n \n     const std::vector<ColumnPtr> & getAttributesDefaultValuesColumns() const { return attributes_default_values_columns; }\n \n+    const ReadColumnsFunc & getReadColumnsFunc() const { return read_columns_func; }\n+\n     const std::shared_ptr<const IDictionary> & getDictionary() const { return dictionary; }\n \n     void initialize(const Names & column_names);\n@@ -79,6 +117,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou\n     std::vector<ColumnPtr> attributes_default_values_columns;\n \n     const size_t max_block_size;\n+    ReadColumnsFunc read_columns_func;\n+\n     std::atomic<size_t> parallel_read_block_index = 0;\n };\n \ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex 2a0e1279050f..3e29f3efe766 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -382,7 +382,8 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n \n void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConfiguration & config, const std::string & structure_prefix)\n {\n-    const char * range_default_type = \"Date\";\n+    static constexpr auto range_default_type = \"Date\";\n+\n     if (config.has(structure_prefix + \".range_min\"))\n         range_min.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + \".range_min\", range_default_type));\n \n@@ -395,7 +396,10 @@ void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConf\n             \"Dictionary structure should have both 'range_min' and 'range_max' either specified or not.\");\n     }\n \n-    if (range_min && range_max && !range_min->type->equals(*range_max->type))\n+    if (!range_min)\n+        return;\n+\n+    if (!range_min->type->equals(*range_max->type))\n     {\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n             \"Dictionary structure 'range_min' and 'range_max' should have same type, \"\n@@ -405,15 +409,20 @@ void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConf\n             range_max->type->getName());\n     }\n \n-    if (range_min && !range_min->type->isValueRepresentedByInteger())\n+    WhichDataType range_type(range_min->type);\n+\n+    bool valid_range = range_type.isInt() || range_type.isUInt() || range_type.isDecimal() || range_type.isFloat() || range_type.isEnum()\n+        || range_type.isDate() || range_type.isDate32() || range_type.isDateTime() || range_type.isDateTime64();\n+\n+    if (!valid_range)\n     {\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-            \"Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum.\"\n+            \"Dictionary structure type of 'range_min' and 'range_max' should be an Integer, Float, Decimal, Date, Date32, DateTime DateTime64, or Enum.\"\n             \" Actual 'range_min' and 'range_max' type is {}\",\n             range_min->type->getName());\n     }\n \n-    if ((range_min && !range_min->expression.empty()) || (range_max && !range_max->expression.empty()))\n+    if (!range_min->expression.empty() || !range_max->expression.empty())\n         has_expressions = true;\n }\n \ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex 979cfce6ce22..14c8fc7c7493 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -1,56 +1,21 @@\n #include <Dictionaries/RangeHashedDictionary.h>\n \n-#include <Columns/ColumnNullable.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <Interpreters/castColumn.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDate32.h>\n #include <DataTypes/DataTypeDateTime.h>\n-#include <Dictionaries/DictionaryFactory.h>\n-#include <Dictionaries/DictionarySource.h>\n-\n-\n-namespace\n-{\n-\n-using RangeStorageType = DB::RangeStorageType;\n-\n-// Null values mean that specified boundary, either min or max is not set on range.\n-// To simplify comparison, null value of min bound should be bigger than any other value,\n-// and null value of maxbound - less than any value.\n-const RangeStorageType RANGE_MIN_NULL_VALUE = std::numeric_limits<RangeStorageType>::max();\n-const RangeStorageType RANGE_MAX_NULL_VALUE = std::numeric_limits<RangeStorageType>::lowest();\n-\n-bool isCorrectDate(const RangeStorageType & date)\n-{\n-    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;\n-}\n-\n-// Handle both kinds of null values: explicit nulls of NullableColumn and 'implicit' nulls of Date type.\n-RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t index, bool isDate, const RangeStorageType & default_value)\n-{\n-    if (column.isNullAt(index))\n-        return default_value;\n-\n-    const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));\n-    if (isDate && !isCorrectDate(result))\n-        return default_value;\n+#include <DataTypes/DataTypeDateTime64.h>\n \n-    return result;\n-}\n+#include <Columns/ColumnNullable.h>\n \n-const DB::IColumn & unwrapNullableColumn(const DB::IColumn & column)\n-{\n-    if (const auto * m = DB::checkAndGetColumn<DB::ColumnNullable>(&column))\n-    {\n-        return m->getNestedColumn();\n-    }\n+#include <Functions/FunctionHelpers.h>\n+#include <Interpreters/castColumn.h>\n \n-    return column;\n-}\n+#include <Dictionaries/DictionaryFactory.h>\n+#include <Dictionaries/DictionarySource.h>\n \n-}\n \n namespace DB\n {\n@@ -60,22 +25,53 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n     extern const int DICTIONARY_IS_EMPTY;\n     extern const int UNSUPPORTED_METHOD;\n+    extern const int TYPE_MISMATCH;\n }\n \n+namespace\n+{\n+    template <typename F>\n+    void callOnRangeType(const DataTypePtr & range_type, F && func)\n+    {\n+        auto call = [&](const auto & types)\n+        {\n+            using Types = std::decay_t<decltype(types)>;\n+            using DataType = typename Types::LeftType;\n+\n+            if constexpr (IsDataTypeDecimalOrNumber<DataType> || IsDataTypeDateOrDateTime<DataType> || IsDataTypeEnum<DataType>)\n+            {\n+                using ColumnType = typename DataType::ColumnType;\n+                func(TypePair<ColumnType, void>());\n+                return true;\n+            }\n+\n+            return false;\n+        };\n+\n+        auto type_index = range_type->getTypeId();\n+        if (!callOnIndexAndDataType<void>(type_index, call))\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Dictionary structure type of 'range_min' and 'range_max' should be an Integer, Float, Decimal, Date, Date32, DateTime DateTime64, or Enum.\"\n+                \" Actual 'range_min' and 'range_max' type is {}\",\n+                range_type->getName());\n+        }\n+    }\n+}\n \n template <DictionaryKeyType dictionary_key_type>\n RangeHashedDictionary<dictionary_key_type>::RangeHashedDictionary(\n     const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n-    const DictionaryLifetime dict_lifetime_,\n-    bool require_nonempty_,\n+    DictionaryLifetime dict_lifetime_,\n+    RangeHashedDictionaryConfiguration configuration_,\n     BlockPtr update_field_loaded_block_)\n     : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n-    , source_ptr{std::move(source_ptr_)}\n+    , source_ptr(std::move(source_ptr_))\n     , dict_lifetime(dict_lifetime_)\n-    , require_nonempty(require_nonempty_)\n+    , configuration(configuration_)\n     , update_field_loaded_block(std::move(update_field_loaded_block_))\n {\n     createAttributes();\n@@ -104,15 +100,14 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(\n     const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n     const auto & attribute = attributes[attribute_index];\n \n-    /// Cast second column to storage type\n+    /// Cast range column to storage type\n     Columns modified_key_columns = key_columns;\n     auto range_storage_column = key_columns.back();\n     ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types.back(), \"\"};\n-    auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n-    modified_key_columns.back() = castColumnAccurate(column_to_cast, range_column_storage_type);\n+    modified_key_columns.back() = castColumnAccurate(column_to_cast, dict_struct.range_min->type);\n \n     size_t keys_size = key_columns.front()->size();\n-    bool is_attribute_nullable = attribute.is_nullable;\n+    bool is_attribute_nullable = attribute.is_value_nullable.has_value();\n \n     ColumnUInt8::MutablePtr col_null_map_to;\n     ColumnUInt8::Container * vec_null_map_to = nullptr;\n@@ -122,7 +117,7 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(\n         vec_null_map_to = &col_null_map_to->getData();\n     }\n \n-    auto type_call = [&](const auto &dictionary_attribute_type)\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n@@ -206,6 +201,106 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(\n     return result;\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumnInternal(\n+    const std::string & attribute_name,\n+    const DataTypePtr & result_type,\n+    const PaddedPODArray<UInt64> & key_to_index) const\n+{\n+    ColumnPtr result;\n+\n+    const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n+    const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    const auto & attribute = attributes[attribute_index];\n+\n+    size_t keys_size = key_to_index.size();\n+    bool is_attribute_nullable = attribute.is_value_nullable.has_value();\n+\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+    if (is_attribute_nullable)\n+    {\n+        col_null_map_to = ColumnUInt8::create(keys_size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n+\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n+    {\n+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+        using AttributeType = typename Type::AttributeType;\n+        using ValueType = DictionaryValueType<AttributeType>;\n+        using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n+\n+        auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);\n+\n+        if constexpr (std::is_same_v<ValueType, Array>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsInternalImpl<ValueType, false>(\n+                attribute,\n+                key_to_index,\n+                [&](size_t, const Array & value, bool)\n+                {\n+                    out->insert(value);\n+                });\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n+        {\n+            auto * out = column.get();\n+\n+            if (is_attribute_nullable)\n+                getItemsInternalImpl<ValueType, true>(\n+                    attribute,\n+                    key_to_index,\n+                    [&](size_t row, const StringRef value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out->insertData(value.data, value.size);\n+                    });\n+            else\n+                getItemsInternalImpl<ValueType, false>(\n+                    attribute,\n+                    key_to_index,\n+                    [&](size_t, const StringRef value, bool)\n+                    {\n+                        out->insertData(value.data, value.size);\n+                    });\n+        }\n+        else\n+        {\n+            auto & out = column->getData();\n+\n+            if (is_attribute_nullable)\n+                getItemsInternalImpl<ValueType, true>(\n+                    attribute,\n+                    key_to_index,\n+                    [&](size_t row, const auto value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out[row] = value;\n+                    });\n+            else\n+                getItemsInternalImpl<ValueType, false>(\n+                    attribute,\n+                    key_to_index,\n+                    [&](size_t row, const auto value, bool)\n+                    {\n+                        out[row] = value;\n+                    });\n+        }\n+\n+        result = std::move(column);\n+    };\n+\n+    callOnDictionaryAttributeType(attribute.type, type_call);\n+\n+    if (is_attribute_nullable)\n+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n+\n+    return result;\n+}\n+\n template <DictionaryKeyType dictionary_key_type>\n ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n {\n@@ -216,41 +311,45 @@ ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Colum\n         dict_struct.validateKeyTypes(key_types_copy);\n     }\n \n-    auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n+    /// Cast range column to storage type\n     auto range_storage_column = key_columns.back();\n     ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types.back(), \"\"};\n-    auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);\n-    PaddedPODArray<RangeStorageType> range_backup_storage;\n-    const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);\n-\n+    auto range_column_updated = castColumnAccurate(column_to_cast, dict_struct.range_min->type);\n     auto key_columns_copy = key_columns;\n     key_columns_copy.pop_back();\n+\n     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());\n     const size_t keys_size = keys_extractor.getKeysSize();\n \n-    const auto & attribute = attributes.front();\n-\n     auto result = ColumnUInt8::create(keys_size);\n     auto & out = result->getData();\n     size_t keys_found = 0;\n \n-    auto type_call = [&](const auto & dictionary_attribute_type)\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n     {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        using ValueType = DictionaryValueType<AttributeType>;\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        const auto * range_column_typed = typeid_cast<const RangeColumnType *>(range_column_updated.get());\n+        if (!range_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_min->type->getName());\n+        const auto & range_column_data = range_column_typed->getData();\n \n-        const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n+        const auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n \n         for (size_t key_index = 0; key_index < keys_size; ++key_index)\n         {\n             const auto key = keys_extractor.extractCurrentKey();\n-            const auto it = collection.find(key);\n+            const auto it = key_attribute_container.find(key);\n \n             if (it)\n             {\n-                const auto date = dates[key_index];\n+                const auto date = range_column_data[key_index];\n                 const auto & interval_tree = it->getMapped();\n                 out[key_index] = interval_tree.has(date);\n                 keys_found += out[key_index];\n@@ -262,9 +361,7 @@ ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Colum\n \n             keys_extractor.rollbackCurrentKey();\n         }\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n+    });\n \n     query_count.fetch_add(keys_size, std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -286,6 +383,16 @@ void RangeHashedDictionary<dictionary_key_type>::createAttributes()\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Hierarchical attributes not supported by {} dictionary.\",\n                             getDictionaryID().getNameForLogs());\n     }\n+\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n+    {\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        key_attribute.container = KeyAttributeContainerType<RangeStorageType>();\n+        key_attribute.invalid_intervals_container = InvalidIntervalsContainerType<RangeStorageType>();\n+    });\n }\n \n template <DictionaryKeyType dictionary_key_type>\n@@ -294,9 +401,9 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()\n     if (!source_ptr->hasUpdateField())\n     {\n         QueryPipeline pipeline(source_ptr->loadAll());\n-\n         PullingPipelineExecutor executor(pipeline);\n         Block block;\n+\n         while (executor.pull(block))\n         {\n             blockToAttributes(block);\n@@ -307,9 +414,19 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()\n         updateData();\n     }\n \n-    buildAttributeIntervalTrees();\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n+    {\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n+\n+        for (auto & [_, intervals] : key_attribute_container)\n+            intervals.build();\n+    });\n \n-    if (require_nonempty && 0 == element_count)\n+    if (configuration.require_nonempty && 0 == element_count)\n         throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY,\n             \"{}: dictionary source is empty and 'require_nonempty' property is set.\");\n }\n@@ -317,8 +434,22 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()\n template <DictionaryKeyType dictionary_key_type>\n void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()\n {\n-    bytes_allocated += attributes.size() * sizeof(attributes.front());\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n+    {\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n+\n+        bucket_count = key_attribute_container.getBufferSizeInCells();\n+        bytes_allocated += key_attribute_container.getBufferSizeInBytes();\n+\n+        for (auto & [_, intervals] : key_attribute_container)\n+            bytes_allocated += intervals.getSizeInBytes();\n+    });\n \n+    bytes_allocated += attributes.size() * sizeof(attributes.front());\n     for (const auto & attribute : attributes)\n     {\n         auto type_call = [&](const auto & dictionary_attribute_type)\n@@ -327,17 +458,17 @@ void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()\n             using AttributeType = typename Type::AttributeType;\n             using ValueType = DictionaryValueType<AttributeType>;\n \n-            const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n-            bytes_allocated += sizeof(CollectionType<ValueType>) + collection.getBufferSizeInBytes();\n-            bucket_count = collection.getBufferSizeInCells();\n+            const auto & container = std::get<AttributeContainerType<ValueType>>(attribute.container);\n+\n+            bytes_allocated += container.size() * sizeof(ValueType);\n+\n+            if (attribute.is_value_nullable)\n+                bytes_allocated += (*attribute.is_value_nullable).size() * sizeof(bool);\n         };\n \n         callOnDictionaryAttributeType(attribute.type, type_call);\n     }\n \n-    if constexpr (dictionary_key_type == DictionaryKeyType::Complex)\n-        bytes_allocated += complex_key_arena.size();\n-\n     if (update_field_loaded_block)\n         bytes_allocated += update_field_loaded_block->allocatedBytes();\n \n@@ -347,15 +478,20 @@ void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()\n template <DictionaryKeyType dictionary_key_type>\n typename RangeHashedDictionary<dictionary_key_type>::Attribute RangeHashedDictionary<dictionary_key_type>::createAttribute(const DictionaryAttribute & dictionary_attribute)\n {\n-    Attribute attribute{dictionary_attribute.underlying_type, dictionary_attribute.is_nullable, {}};\n+    std::optional<std::vector<bool>> is_value_nullable;\n+\n+    if (dictionary_attribute.is_nullable)\n+        is_value_nullable.emplace(std::vector<bool>());\n+\n+    Attribute attribute{dictionary_attribute.underlying_type, {}, std::move(is_value_nullable)};\n \n-    auto type_call = [&](const auto &dictionary_attribute_type)\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n         using ValueType = DictionaryValueType<AttributeType>;\n \n-        attribute.maps = CollectionType<ValueType>();\n+        attribute.container = AttributeContainerType<ValueType>();\n     };\n \n     callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n@@ -371,78 +507,156 @@ void RangeHashedDictionary<dictionary_key_type>::getItemsImpl(\n     ValueSetter && set_value,\n     DefaultValueExtractor & default_value_extractor) const\n {\n-    const auto & collection = std::get<CollectionType<AttributeType>>(attribute.maps);\n+    const auto & attribute_container = std::get<AttributeContainerType<AttributeType>>(attribute.container);\n \n     size_t keys_found = 0;\n \n-    PaddedPODArray<RangeStorageType> range_backup_storage;\n-    const auto & dates = getColumnVectorData(this, key_columns.back(), range_backup_storage);\n-\n+    auto range_column = key_columns.back();\n     auto key_columns_copy = key_columns;\n     key_columns_copy.pop_back();\n+\n     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());\n     const size_t keys_size = keys_extractor.getKeysSize();\n \n-    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n     {\n-        auto key = keys_extractor.extractCurrentKey();\n-        const auto it = collection.find(key);\n-\n-        if (it)\n-        {\n-            const auto date = dates[key_index];\n-            const auto & interval_tree = it->getMapped();\n-\n-            std::optional<AttributeType> min_value;\n-            std::optional<RangeInterval> min_range;\n-            bool has_interval = false;\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+        using RangeInterval = Interval<RangeStorageType>;\n \n-            interval_tree.find(date, [&](auto & interval, auto & value)\n-            {\n-                has_interval = true;\n+        const auto * range_column_typed = typeid_cast<const RangeColumnType *>(range_column.get());\n+        if (!range_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_min->type->getName());\n \n-                if (min_range && interval < *min_range)\n-                    min_range = interval;\n-                else\n-                    min_range = interval;\n+        const auto & range_column_data = range_column_typed->getData();\n \n-                min_value = value;\n+        const auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n \n-                return true;\n-            });\n+        for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+        {\n+            auto key = keys_extractor.extractCurrentKey();\n+            const auto it = key_attribute_container.find(key);\n \n-            if (has_interval)\n+            if (it)\n             {\n-                ++keys_found;\n+                const auto date = range_column_data[key_index];\n+                const auto & interval_tree = it->getMapped();\n \n-                if constexpr (is_nullable)\n+                size_t value_index = 0;\n+                std::optional<RangeInterval> range;\n+\n+                interval_tree.find(date, [&](auto & interval, auto & interval_value_index)\n                 {\n-                    if (min_value.has_value())\n-                        set_value(key_index, *min_value, false);\n+                    if (range)\n+                    {\n+                        if (likely(configuration.lookup_strategy == RangeHashedDictionaryLookupStrategy::min) && interval < *range)\n+                        {\n+                            range = interval;\n+                            value_index = interval_value_index;\n+                        }\n+                        else if (configuration.lookup_strategy == RangeHashedDictionaryLookupStrategy::max && interval > * range)\n+                        {\n+                            range = interval;\n+                            value_index = interval_value_index;\n+                        }\n+                    }\n                     else\n-                        set_value(key_index, default_value_extractor[key_index], true);\n-                }\n-                else\n+                    {\n+                        range = interval;\n+                        value_index = interval_value_index;\n+                    }\n+\n+                    return true;\n+                });\n+\n+                if (range.has_value())\n                 {\n-                    set_value(key_index, *min_value, false);\n-                }\n+                    ++keys_found;\n \n-                keys_extractor.rollbackCurrentKey();\n-                continue;\n+                    AttributeType value = attribute_container[value_index];\n+\n+                    if constexpr (is_nullable)\n+                    {\n+                        bool is_null = (*attribute.is_value_nullable)[value_index];\n+\n+                        if (!is_null)\n+                            set_value(key_index, value, false);\n+                        else\n+                            set_value(key_index, default_value_extractor[key_index], true);\n+                    }\n+                    else\n+                    {\n+                        set_value(key_index, value, false);\n+                    }\n+\n+                    keys_extractor.rollbackCurrentKey();\n+                    continue;\n+                }\n             }\n+\n+            if constexpr (is_nullable)\n+                set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));\n+            else\n+                set_value(key_index, default_value_extractor[key_index], false);\n+\n+            keys_extractor.rollbackCurrentKey();\n+        }\n+    });\n+\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+template <typename AttributeType, bool is_nullable, typename ValueSetter>\n+void RangeHashedDictionary<dictionary_key_type>::getItemsInternalImpl(\n+        const Attribute & attribute,\n+        const PaddedPODArray<UInt64> & key_to_index,\n+        ValueSetter && set_value) const\n+{\n+    size_t keys_size = key_to_index.size();\n+\n+    const auto & container = std::get<AttributeContainerType<AttributeType>>(attribute.container);\n+    size_t container_size = container.size();\n+\n+    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+    {\n+        UInt64 container_index = key_to_index[key_index];\n+\n+        if (unlikely(container_index >= container_size))\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                \"Dictionary {} expected attribute container index {} must be less than attribute container size {}\",\n+                getFullName(),\n+                container_index,\n+                container_size\n+            );\n         }\n \n+        AttributeType value = container[container_index];\n+\n         if constexpr (is_nullable)\n-            set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));\n-        else\n-            set_value(key_index, default_value_extractor[key_index], false);\n+        {\n+            bool is_null = (*attribute.is_value_nullable)[container_index];\n \n-        keys_extractor.rollbackCurrentKey();\n+            if (!is_null)\n+                set_value(key_index, value, false);\n+            else\n+                set_value(key_index, value, true);\n+        }\n+        else\n+        {\n+            set_value(key_index, value, false);\n+        }\n     }\n \n     query_count.fetch_add(keys_size, std::memory_order_relaxed);\n-    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+    found_count.fetch_add(keys_size, std::memory_order_relaxed);\n }\n \n template <DictionaryKeyType dictionary_key_type>\n@@ -486,282 +700,379 @@ void RangeHashedDictionary<dictionary_key_type>::updateData()\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block & block [[maybe_unused]])\n+void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block & block)\n {\n-    size_t skip_keys_size_offset = dict_struct.getKeysSize();\n+    size_t attributes_size = attributes.size();\n+    size_t dictionary_keys_size = dict_struct.getKeysSize();\n+\n+    static constexpr size_t ranges_size = 2;\n+\n+    size_t block_columns = block.columns();\n+    size_t range_dictionary_attributes_size = attributes_size + dictionary_keys_size + ranges_size;\n+\n+    if (range_dictionary_attributes_size != block.columns())\n+    {\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+            \"Block size mismatch. Actual {}. Expected {}\",\n+            block_columns,\n+            range_dictionary_attributes_size);\n+    }\n \n     Columns key_columns;\n-    key_columns.reserve(skip_keys_size_offset);\n+    key_columns.reserve(dictionary_keys_size);\n \n     /// Split into keys columns and attribute columns\n-    for (size_t i = 0; i < skip_keys_size_offset; ++i)\n-        key_columns.emplace_back(block.safeGetByPosition(i).column);\n+    for (size_t i = 0; i < dictionary_keys_size; ++i)\n+        key_columns.emplace_back(block.getByPosition(i).column);\n \n     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, arena_holder.getComplexKeyArena());\n     const size_t keys_size = keys_extractor.getKeysSize();\n \n-    element_count += keys_size;\n+    size_t block_attributes_skip_offset = dictionary_keys_size;\n+\n+    const auto * min_range_column = block.getByPosition(block_attributes_skip_offset).column.get();\n+    const auto * max_range_column = block.getByPosition(block_attributes_skip_offset + 1).column.get();\n \n-    // Support old behaviour, where invalid date means 'open range'.\n-    const bool is_date = isDate(dict_struct.range_min->type);\n+    const NullMap * min_range_null_map = nullptr;\n+    const NullMap * max_range_null_map = nullptr;\n \n-    const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset).column);\n-    const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset + 1).column);\n+    if (const auto * min_range_column_nullable = checkAndGetColumn<ColumnNullable>(min_range_column))\n+    {\n+        min_range_column = &min_range_column_nullable->getNestedColumn();\n+        min_range_null_map = &min_range_column_nullable->getNullMapColumn().getData();\n+    }\n \n-    skip_keys_size_offset += 2;\n+    if (const auto * max_range_column_nullable = checkAndGetColumn<ColumnNullable>(max_range_column))\n+    {\n+        max_range_column = &max_range_column_nullable->getNestedColumn();\n+        max_range_null_map = &max_range_column_nullable->getNullMapColumn().getData();\n+    }\n \n-    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n     {\n-        const auto & attribute_column = *block.safeGetByPosition(attribute_index + skip_keys_size_offset).column;\n-        auto & attribute = attributes[attribute_index];\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        const auto * min_range_column_typed = typeid_cast<const RangeColumnType *>(min_range_column);\n+        if (!min_range_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range min column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_min->type->getName());\n+\n+        const auto * max_range_column_typed = typeid_cast<const RangeColumnType *>(max_range_column);\n+        if (!max_range_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range max column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_max->type->getName());\n+\n+        const auto & min_range_column_data = min_range_column_typed->getData();\n+        const auto & max_range_column_data = max_range_column_typed->getData();\n+\n+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n+        auto & invalid_intervals_container = std::get<InvalidIntervalsContainerType<RangeStorageType>>(key_attribute.invalid_intervals_container);\n+\n+        block_attributes_skip_offset += 2;\n+\n+        Field column_value;\n \n         for (size_t key_index = 0; key_index < keys_size; ++key_index)\n         {\n             auto key = keys_extractor.extractCurrentKey();\n \n-            RangeStorageType lower_bound;\n-            RangeStorageType upper_bound;\n+            RangeStorageType lower_bound = min_range_column_data[key_index];\n+            RangeStorageType upper_bound = max_range_column_data[key_index];\n+\n+            bool invalid_range = false;\n \n-            if (is_date)\n+            if (unlikely(min_range_null_map && (*min_range_null_map)[key_index]))\n             {\n-                lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, 0);\n-                upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, DATE_LUT_MAX_DAY_NUM + 1);\n+                lower_bound = std::numeric_limits<RangeStorageType>::min();\n+                invalid_range = true;\n             }\n-            else\n+\n+            if (unlikely(max_range_null_map && (*max_range_null_map)[key_index]))\n+            {\n+                upper_bound = std::numeric_limits<RangeStorageType>::max();\n+                invalid_range = true;\n+            }\n+\n+            if (unlikely(!configuration.convert_null_range_bound_to_open && invalid_range))\n             {\n-                lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, RANGE_MIN_NULL_VALUE);\n-                upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, RANGE_MAX_NULL_VALUE);\n+                keys_extractor.rollbackCurrentKey();\n+                continue;\n             }\n \n             if constexpr (std::is_same_v<KeyType, StringRef>)\n                 key = copyStringInArena(string_arena, key);\n \n-            if (likely(lower_bound <= upper_bound))\n-                setAttributeValue(attribute, key, RangeInterval{lower_bound, upper_bound}, attribute_column[key_index]);\n+            for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n+            {\n+                const auto & attribute_column = *block.getByPosition(attribute_index + block_attributes_skip_offset).column;\n+                auto & attribute = attributes[attribute_index];\n+                attribute_column.get(key_index, column_value);\n+\n+                setAttributeValue(attribute, column_value);\n+            }\n+\n+            auto interval = Interval<RangeStorageType>(lower_bound, upper_bound);\n+            auto it = key_attribute_container.find(key);\n+\n+            bool emplaced_in_interval_tree = false;\n+\n+            if (it)\n+            {\n+                auto & intervals = it->getMapped();\n+                emplaced_in_interval_tree = intervals.emplace(interval, element_count);\n+            }\n+            else\n+            {\n+                IntervalMap<RangeStorageType> intervals;\n+                emplaced_in_interval_tree = intervals.emplace(interval, element_count);\n+                key_attribute_container.insert({key, std::move(intervals)});\n+            }\n \n+            if (unlikely(!emplaced_in_interval_tree))\n+            {\n+                InvalidIntervalWithKey<RangeStorageType> invalid_interval{key, interval, element_count};\n+                invalid_intervals_container.emplace_back(invalid_interval);\n+            }\n+\n+            ++element_count;\n             keys_extractor.rollbackCurrentKey();\n         }\n-\n-        keys_extractor.reset();\n-    }\n+    });\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-void RangeHashedDictionary<dictionary_key_type>::buildAttributeIntervalTrees()\n+void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, const Field & value)\n {\n-    for (auto & attribute : attributes)\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n-        auto type_call = [&](const auto & dictionary_attribute_type)\n+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+        using AttributeType = typename Type::AttributeType;\n+        using ValueType = DictionaryValueType<AttributeType>;\n+\n+        auto & container = std::get<AttributeContainerType<ValueType>>(attribute.container);\n+        container.emplace_back();\n+\n+        if (unlikely(attribute.is_value_nullable.has_value()))\n         {\n-            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-            using AttributeType = typename Type::AttributeType;\n-            using ValueType = DictionaryValueType<AttributeType>;\n+            bool value_is_null = value.isNull();\n+            attribute.is_value_nullable->emplace_back(value_is_null);\n \n-            auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n-            for (auto & [_, ranges] : collection)\n-                ranges.build();\n-        };\n+            if (unlikely(value_is_null))\n+                return;\n+        }\n \n-        callOnDictionaryAttributeType(attribute.type, type_call);\n-    }\n+        ValueType value_to_insert;\n+\n+        if constexpr (std::is_same_v<AttributeType, String>)\n+        {\n+            const auto & string = value.get<String>();\n+            StringRef string_ref = copyStringInArena(string_arena, string);\n+            value_to_insert = string_ref;\n+        }\n+        else\n+        {\n+            value_to_insert = value.get<ValueType>();\n+        }\n+\n+        container.back() = value_to_insert;\n+    };\n+\n+    callOnDictionaryAttributeType(attribute.type, type_call);\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-template <typename T>\n-void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)\n+Pipe RangeHashedDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size, size_t num_streams) const\n {\n-    using ValueType = std::conditional_t<std::is_same_v<T, String>, StringRef, T>;\n-    auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n+    auto key_to_index_column = ColumnUInt64::create();\n+    auto range_min_column = dict_struct.range_min->type->createColumn();\n+    auto range_max_column = dict_struct.range_max->type->createColumn();\n \n-    std::optional<ValueType> value_to_insert;\n+    PaddedPODArray<KeyType> keys;\n \n-    if (attribute.is_nullable && value.isNull())\n-    {\n-        value_to_insert = std::nullopt;\n-    }\n-    else\n+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)\n     {\n-        if constexpr (std::is_same_v<T, String>)\n+        using Types = std::decay_t<decltype(types)>;\n+        using RangeColumnType = typename Types::LeftType;\n+        using RangeStorageType = typename RangeColumnType::ValueType;\n+\n+        auto * range_min_column_typed = typeid_cast<RangeColumnType *>(range_min_column.get());\n+        if (!range_min_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range min column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_min->type->getName());\n+\n+        auto * range_max_column_typed = typeid_cast<RangeColumnType *>(range_max_column.get());\n+        if (!range_max_column_typed)\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Dictionary {} range max column type should be equal to {}\",\n+                getFullName(),\n+                dict_struct.range_max->type->getName());\n+\n+        auto & key_to_index_column_data = key_to_index_column->getData();\n+        auto & range_min_column_data = range_min_column_typed->getData();\n+        auto & range_max_column_data = range_max_column_typed->getData();\n+\n+        const auto & container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);\n+        const auto & invalid_intervals_container = std::get<InvalidIntervalsContainerType<RangeStorageType>>(key_attribute.invalid_intervals_container);\n+\n+        keys.reserve(element_count);\n+        key_to_index_column_data.reserve(element_count);\n+        range_min_column_data.reserve(element_count);\n+        range_max_column_data.reserve(element_count);\n+\n+        for (const auto & key : container)\n         {\n-            const auto & string = value.get<String>();\n-            StringRef string_ref = copyStringInArena(string_arena, string);\n-            value_to_insert = { string_ref };\n+            for (const auto & [interval, index] : key.getMapped())\n+            {\n+                keys.emplace_back(key.getKey());\n+                key_to_index_column_data.emplace_back(index);\n+                range_min_column_data.push_back(interval.left);\n+                range_max_column_data.push_back(interval.right);\n+            }\n         }\n-        else\n+\n+        for (const auto & invalid_interval_with_key : invalid_intervals_container)\n         {\n-            value_to_insert = { value.get<ValueType>() };\n+            keys.emplace_back(invalid_interval_with_key.key);\n+            key_to_index_column_data.emplace_back(invalid_interval_with_key.attribute_value_index);\n+            range_min_column_data.push_back(invalid_interval_with_key.interval.left);\n+            range_max_column_data.push_back(invalid_interval_with_key.interval.right);\n         }\n-    }\n+    });\n \n-    const auto it = collection.find(key);\n+    auto range_min_column_with_type = ColumnWithTypeAndName{std::move(range_min_column), dict_struct.range_min->type, dict_struct.range_min->name};\n+    auto range_max_column_with_type = ColumnWithTypeAndName{std::move(range_max_column), dict_struct.range_max->type, dict_struct.range_max->name};\n \n-    if (it)\n+    ColumnsWithTypeAndName key_columns;\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n     {\n-        auto & values = it->getMapped();\n-        values.emplace(interval, std::move(value_to_insert));\n+        auto keys_column = getColumnFromPODArray(std::move(keys));\n+        key_columns = {ColumnWithTypeAndName(std::move(keys_column), std::make_shared<DataTypeUInt64>(), dict_struct.id->name)};\n     }\n     else\n     {\n-        Values<ValueType> values;\n-        values.emplace(interval, value_to_insert);\n-        collection.insert({key, std::move(values)});\n+        key_columns = deserializeColumnsWithTypeAndNameFromKeys(dict_struct, keys, 0, keys.size());\n     }\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)\n-{\n-    auto type_call = [&](const auto &dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n \n-        setAttributeValueImpl<AttributeType>(attribute, key, interval, value);\n-    };\n+    key_columns.emplace_back(ColumnWithTypeAndName{std::move(key_to_index_column), std::make_shared<DataTypeUInt64>(), \"\"});\n \n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-}\n+    ColumnsWithTypeAndName data_columns = {std::move(range_min_column_with_type), std::move(range_max_column_with_type)};\n \n-template <DictionaryKeyType dictionary_key_type>\n-template <typename RangeType>\n-void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(\n-    PaddedPODArray<KeyType> & keys,\n-    PaddedPODArray<RangeType> & start_dates,\n-    PaddedPODArray<RangeType> & end_dates) const\n-{\n-    const auto & attribute = attributes.front();\n+    std::shared_ptr<const IDictionary> dictionary = shared_from_this();\n \n-    auto type_call = [&](const auto & dictionary_attribute_type)\n+    DictionarySourceCoordinator::ReadColumnsFunc read_keys_func = [dictionary_copy = dictionary](\n+        const Strings & attribute_names,\n+        const DataTypes & result_types,\n+        const Columns & key_columns,\n+        const DataTypes,\n+        const Columns &)\n     {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        using ValueType = DictionaryValueType<AttributeType>;\n+        auto range_dictionary_ptr = std::static_pointer_cast<const RangeHashedDictionary<dictionary_key_type>>(dictionary_copy);\n \n-        getKeysAndDates<ValueType>(attribute, keys, start_dates, end_dates);\n-    };\n+        size_t attribute_names_size = attribute_names.size();\n \n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-}\n+        Columns result;\n+        result.reserve(attribute_names_size);\n \n-template <DictionaryKeyType dictionary_key_type>\n-template <typename T, typename RangeType>\n-void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(\n-    const Attribute & attribute,\n-    PaddedPODArray<KeyType> & keys,\n-    PaddedPODArray<RangeType> & start_dates,\n-    PaddedPODArray<RangeType> & end_dates) const\n-{\n-    const auto & collection = std::get<CollectionType<T>>(attribute.maps);\n+        auto key_column = key_columns.back();\n \n-    keys.reserve(collection.size());\n-    start_dates.reserve(collection.size());\n-    end_dates.reserve(collection.size());\n+        const auto * key_to_index_column = typeid_cast<const ColumnUInt64 *>(key_column.get());\n+        if (!key_to_index_column)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                \"Dictionary {} read expect indexes column with type UInt64\",\n+                range_dictionary_ptr->getFullName());\n \n-    const bool is_date = isDate(dict_struct.range_min->type);\n-    (void)(is_date);\n+        const auto & data = key_to_index_column->getData();\n \n-    for (const auto & key : collection)\n-    {\n-        for (const auto & [interval, _] : key.getMapped())\n+        for (size_t i = 0; i < attribute_names_size; ++i)\n         {\n-            keys.push_back(key.getKey());\n-            start_dates.push_back(interval.left);\n-            end_dates.push_back(interval.right);\n+            const auto & attribute_name = attribute_names[i];\n+            const auto & result_type = result_types[i];\n \n-            if constexpr (std::numeric_limits<RangeType>::max() > DATE_LUT_MAX_DAY_NUM) /// Avoid warning about tautological comparison in next line.\n-                if (is_date && static_cast<UInt64>(end_dates.back()) > DATE_LUT_MAX_DAY_NUM)\n-                    end_dates.back() = 0;\n+            result.emplace_back(range_dictionary_ptr->getColumnInternal(attribute_name, result_type, data));\n         }\n-    }\n-}\n \n-template <DictionaryKeyType dictionary_key_type>\n-template <typename RangeType>\n-PaddedPODArray<Int64> RangeHashedDictionary<dictionary_key_type>::makeDateKeys(\n-    const PaddedPODArray<RangeType> & block_start_dates,\n-    const PaddedPODArray<RangeType> & block_end_dates) const\n-{\n-    PaddedPODArray<Int64> keys(block_start_dates.size());\n+        return result;\n+    };\n \n-    for (size_t i = 0; i < keys.size(); ++i)\n-    {\n-        if (isCorrectDate(block_start_dates[i]))\n-            keys[i] = block_start_dates[i]; // NOLINT\n-        else\n-            keys[i] = block_end_dates[i]; // NOLINT\n-    }\n+    auto coordinator = DictionarySourceCoordinator::create(\n+        dictionary,\n+        column_names,\n+        std::move(key_columns),\n+        std::move(data_columns),\n+        max_block_size,\n+        std::move(read_keys_func));\n+    auto result = coordinator->read(num_streams);\n \n-    return keys;\n+    return result;\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-Pipe RangeHashedDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size, size_t num_streams) const\n+static DictionaryPtr createRangeHashedDictionary(const std::string & full_name,\n+                            const DictionaryStructure & dict_struct,\n+                            const Poco::Util::AbstractConfiguration & config,\n+                            const std::string & config_prefix,\n+                            DictionarySourcePtr source_ptr)\n {\n-    auto type = dict_struct.range_min->type;\n-\n-    ColumnsWithTypeAndName key_columns;\n-    ColumnWithTypeAndName range_min_column;\n-    ColumnWithTypeAndName range_max_column;\n+    static constexpr auto layout_name = dictionary_key_type == DictionaryKeyType::Simple ? \"range_hashed\" : \"complex_key_range_hashed\";\n \n-    auto type_call = [&](const auto & types) mutable -> bool\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n     {\n-        using Types = std::decay_t<decltype(types)>;\n-        using LeftDataType = typename Types::LeftType;\n-\n-        if constexpr (IsDataTypeNumber<LeftDataType> ||\n-            std::is_same_v<LeftDataType, DataTypeDate> ||\n-            std::is_same_v<LeftDataType, DataTypeDate32> ||\n-            std::is_same_v<LeftDataType, DataTypeDateTime>)\n-        {\n-            using RangeType = typename LeftDataType::FieldType;\n-\n-            PaddedPODArray<KeyType> keys;\n-            PaddedPODArray<RangeType> range_start;\n-            PaddedPODArray<RangeType> range_end;\n-            getKeysAndDates(keys, range_start, range_end);\n-\n-            auto date_column = getColumnFromPODArray(makeDateKeys(range_start, range_end));\n+        if (dict_struct.key)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'key' is not supported for dictionary of layout 'range_hashed'\");\n+    }\n+    else\n+    {\n+        if (dict_struct.id)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'id' is not supported for dictionary of layout 'complex_key_range_hashed'\");\n+    }\n \n-            auto range_start_column = getColumnFromPODArray(std::move(range_start));\n-            range_min_column = ColumnWithTypeAndName{std::move(range_start_column), dict_struct.range_min->type, dict_struct.range_min->name};\n+    if (!dict_struct.range_min || !dict_struct.range_max)\n+        throw Exception(\n+            ErrorCodes::BAD_ARGUMENTS,\n+            \"{}: dictionary of layout '{}' requires .structure.range_min and .structure.range_max\",\n+            full_name,\n+            layout_name);\n \n-            auto range_end_column = getColumnFromPODArray(std::move(range_end));\n-            range_max_column = ColumnWithTypeAndName{std::move(range_end_column), dict_struct.range_max->type, dict_struct.range_max->name};\n+    const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+    const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n+    const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n \n-            if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n-            {\n-                auto keys_column = getColumnFromPODArray(std::move(keys));\n-                key_columns = {ColumnWithTypeAndName(std::move(keys_column), std::make_shared<DataTypeUInt64>(), dict_struct.id->name)};\n-            }\n-            else\n-            {\n-                key_columns = deserializeColumnsWithTypeAndNameFromKeys(dict_struct, keys, 0, keys.size());\n-            }\n+    String dictionary_layout_prefix = config_prefix + \".layout.\" + layout_name;\n+    const bool convert_null_range_bound_to_open = config.getBool(dictionary_layout_prefix + \".convert_null_range_bound_to_open\", true);\n+    String range_lookup_strategy = config.getString(dictionary_layout_prefix + \".range_lookup_strategy\", \"min\");\n+    RangeHashedDictionaryLookupStrategy lookup_strategy = RangeHashedDictionaryLookupStrategy::min;\n \n-            key_columns.emplace_back(ColumnWithTypeAndName{std::move(date_column), std::make_shared<DataTypeInt64>(), \"\"});\n+    if (range_lookup_strategy == \"min\")\n+        lookup_strategy = RangeHashedDictionaryLookupStrategy::min;\n+    else if (range_lookup_strategy == \"max\")\n+        lookup_strategy = RangeHashedDictionaryLookupStrategy::max;\n \n-            return true;\n-        }\n-        else\n-        {\n-            return false;\n-        }\n+    RangeHashedDictionaryConfiguration configuration\n+    {\n+        .convert_null_range_bound_to_open = convert_null_range_bound_to_open,\n+        .lookup_strategy = lookup_strategy,\n+        .require_nonempty = require_nonempty\n     };\n \n-    if (!callOnIndexAndDataType<void>(type->getTypeId(), type_call))\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"RangeHashedDictionary min max range type should be numeric\");\n-\n-    ColumnsWithTypeAndName data_columns = {std::move(range_min_column), std::move(range_max_column)};\n-\n-    std::shared_ptr<const IDictionary> dictionary = shared_from_this();\n-    auto coordinator = DictionarySourceCoordinator::create(dictionary, column_names, std::move(key_columns), std::move(data_columns), max_block_size);\n-    auto result = coordinator->read(num_streams);\n+    DictionaryPtr result = std::make_unique<RangeHashedDictionary<dictionary_key_type>>(\n+        dict_id,\n+        dict_struct,\n+        std::move(source_ptr),\n+        dict_lifetime,\n+        configuration);\n \n     return result;\n }\n \n-\n void registerDictionaryRangeHashed(DictionaryFactory & factory)\n {\n     auto create_layout_simple = [=](const std::string & full_name,\n@@ -772,22 +1083,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)\n                              ContextPtr /* global_context */,\n                              bool /*created_from_ddl*/) -> DictionaryPtr\n     {\n-        if (dict_struct.key)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'key' is not supported for dictionary of layout 'range_hashed'\");\n-\n-        if (!dict_struct.range_min || !dict_struct.range_max)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"{}: dictionary of layout 'range_hashed' requires .structure.range_min and .structure.range_max\",\n-                full_name);\n-\n-        if (dict_struct.attributes.empty())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Empty attributes are not supported for dictionary of layout 'range_hashed'\");\n-\n-        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n-        const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n-        const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::Simple>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return createRangeHashedDictionary<DictionaryKeyType::Simple>(full_name, dict_struct, config, config_prefix, std::move(source_ptr));\n     };\n+\n     factory.registerLayout(\"range_hashed\", create_layout_simple, false);\n \n     auto create_layout_complex = [=](const std::string & full_name,\n@@ -798,22 +1096,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)\n                              ContextPtr /* context */,\n                              bool /*created_from_ddl*/) -> DictionaryPtr\n     {\n-        if (dict_struct.id)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'id' is not supported for dictionary of layout 'complex_key_range_hashed'\");\n-\n-        if (!dict_struct.range_min || !dict_struct.range_max)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"{}: dictionary of layout 'complex_key_range_hashed' requires .structure.range_min and .structure.range_max\",\n-                full_name);\n-\n-        if (dict_struct.attributes.empty())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Empty attributes are not supported for dictionary of layout 'complex_key_range_hashed'\");\n-\n-        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n-        const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n-        const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::Complex>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return createRangeHashedDictionary<DictionaryKeyType::Complex>(full_name, dict_struct, config, config_prefix, std::move(source_ptr));\n     };\n+\n     factory.registerLayout(\"complex_key_range_hashed\", create_layout_complex, true);\n }\n \ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 91c714d27e68..78d62e9d7de3 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -19,7 +19,18 @@\n namespace DB\n {\n \n-using RangeStorageType = Int64;\n+enum class RangeHashedDictionaryLookupStrategy : uint8_t\n+{\n+    min,\n+    max\n+};\n+\n+struct RangeHashedDictionaryConfiguration\n+{\n+    bool convert_null_range_bound_to_open;\n+    RangeHashedDictionaryLookupStrategy lookup_strategy;\n+    bool require_nonempty;\n+};\n \n template <DictionaryKeyType dictionary_key_type>\n class RangeHashedDictionary final : public IDictionary\n@@ -31,11 +42,17 @@ class RangeHashedDictionary final : public IDictionary\n         const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n-        const DictionaryLifetime dict_lifetime_,\n-        bool require_nonempty_,\n+        DictionaryLifetime dict_lifetime_,\n+        RangeHashedDictionaryConfiguration configuration_,\n         BlockPtr update_field_loaded_block_ = nullptr);\n \n-    std::string getTypeName() const override { return \"RangeHashed\"; }\n+    std::string getTypeName() const override\n+    {\n+        if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+            return \"RangeHashed\";\n+        else\n+            return \"ComplexKeyRangeHashed\";\n+    }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n \n@@ -57,7 +74,15 @@ class RangeHashedDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<RangeHashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, update_field_loaded_block);\n+        auto result = std::make_shared<RangeHashedDictionary>(\n+            getDictionaryID(),\n+            dict_struct,\n+            source_ptr->clone(),\n+            dict_lifetime,\n+            configuration,\n+            update_field_loaded_block);\n+\n+        return result;\n     }\n \n     DictionarySourcePtr getSource() const override { return source_ptr; }\n@@ -76,7 +101,7 @@ class RangeHashedDictionary final : public IDictionary\n     DictionarySpecialKeyType getSpecialKeyType() const override { return DictionarySpecialKeyType::Range;}\n \n     ColumnPtr getColumn(\n-        const std::string& attribute_name,\n+        const std::string & attribute_name,\n         const DataTypePtr & result_type,\n         const Columns & key_columns,\n         const DataTypes & key_types,\n@@ -88,52 +113,90 @@ class RangeHashedDictionary final : public IDictionary\n \n private:\n \n-    using RangeInterval = Interval<RangeStorageType>;\n-\n-    template <typename T>\n-    using Values = IntervalMap<RangeInterval, std::optional<T>>;\n+    template <typename RangeStorageType>\n+    using IntervalMap = IntervalMap<Interval<RangeStorageType>, size_t>;\n \n-    template <typename Value>\n-    using CollectionType = std::conditional_t<\n+    template <typename RangeStorageType>\n+    using KeyAttributeContainerType = std::conditional_t<\n         dictionary_key_type == DictionaryKeyType::Simple,\n-        HashMap<UInt64, Values<Value>, DefaultHash<UInt64>>,\n-        HashMapWithSavedHash<StringRef, Values<Value>, DefaultHash<StringRef>>>;\n+        HashMap<UInt64, IntervalMap<RangeStorageType>, DefaultHash<UInt64>>,\n+        HashMapWithSavedHash<StringRef, IntervalMap<RangeStorageType>, DefaultHash<StringRef>>>;\n \n-    using NoAttributesCollectionType = std::conditional_t<\n-        dictionary_key_type == DictionaryKeyType::Simple,\n-        HashMap<UInt64, IntervalSet<RangeInterval>>,\n-        HashMapWithSavedHash<StringRef, IntervalSet<RangeInterval>>>;\n+    template <typename Value>\n+    using AttributeContainerType = std::conditional_t<std::is_same_v<Value, Array>, std::vector<Value>, PaddedPODArray<Value>>;\n \n     struct Attribute final\n     {\n-    public:\n         AttributeUnderlyingType type;\n-        bool is_nullable;\n \n         std::variant<\n-            CollectionType<UInt8>,\n-            CollectionType<UInt16>,\n-            CollectionType<UInt32>,\n-            CollectionType<UInt64>,\n-            CollectionType<UInt128>,\n-            CollectionType<UInt256>,\n-            CollectionType<Int8>,\n-            CollectionType<Int16>,\n-            CollectionType<Int32>,\n-            CollectionType<Int64>,\n-            CollectionType<Int128>,\n-            CollectionType<Int256>,\n-            CollectionType<Decimal32>,\n-            CollectionType<Decimal64>,\n-            CollectionType<Decimal128>,\n-            CollectionType<Decimal256>,\n-            CollectionType<DateTime64>,\n-            CollectionType<Float32>,\n-            CollectionType<Float64>,\n-            CollectionType<UUID>,\n-            CollectionType<StringRef>,\n-            CollectionType<Array>>\n-            maps;\n+            AttributeContainerType<UInt8>,\n+            AttributeContainerType<UInt16>,\n+            AttributeContainerType<UInt32>,\n+            AttributeContainerType<UInt64>,\n+            AttributeContainerType<UInt128>,\n+            AttributeContainerType<UInt256>,\n+            AttributeContainerType<Int8>,\n+            AttributeContainerType<Int16>,\n+            AttributeContainerType<Int32>,\n+            AttributeContainerType<Int64>,\n+            AttributeContainerType<Int128>,\n+            AttributeContainerType<Int256>,\n+            AttributeContainerType<Decimal32>,\n+            AttributeContainerType<Decimal64>,\n+            AttributeContainerType<Decimal128>,\n+            AttributeContainerType<Decimal256>,\n+            AttributeContainerType<DateTime64>,\n+            AttributeContainerType<Float32>,\n+            AttributeContainerType<Float64>,\n+            AttributeContainerType<UUID>,\n+            AttributeContainerType<StringRef>,\n+            AttributeContainerType<Array>>\n+            container;\n+\n+        std::optional<std::vector<bool>> is_value_nullable;\n+    };\n+\n+    template <typename RangeStorageType>\n+    struct InvalidIntervalWithKey\n+    {\n+        KeyType key;\n+        Interval<RangeStorageType> interval;\n+        size_t attribute_value_index;\n+    };\n+\n+    template <typename RangeStorageType>\n+    using InvalidIntervalsContainerType = PaddedPODArray<InvalidIntervalWithKey<RangeStorageType>>;\n+\n+    template <template<typename> typename ContainerType>\n+    using RangeStorageTypeContainer = std::variant<\n+        ContainerType<UInt8>,\n+        ContainerType<UInt16>,\n+        ContainerType<UInt32>,\n+        ContainerType<UInt64>,\n+        ContainerType<UInt128>,\n+        ContainerType<UInt256>,\n+        ContainerType<Int8>,\n+        ContainerType<Int16>,\n+        ContainerType<Int32>,\n+        ContainerType<Int64>,\n+        ContainerType<Int128>,\n+        ContainerType<Int256>,\n+        ContainerType<Decimal32>,\n+        ContainerType<Decimal64>,\n+        ContainerType<Decimal128>,\n+        ContainerType<Decimal256>,\n+        ContainerType<DateTime64>,\n+        ContainerType<Float32>,\n+        ContainerType<Float64>,\n+        ContainerType<UUID>>;\n+\n+    struct KeyAttribute final\n+    {\n+        RangeStorageTypeContainer<KeyAttributeContainerType> container;\n+\n+        RangeStorageTypeContainer<InvalidIntervalsContainerType> invalid_intervals_container;\n+\n     };\n \n     void createAttributes();\n@@ -151,43 +214,31 @@ class RangeHashedDictionary final : public IDictionary\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    void updateData();\n-\n-    void blockToAttributes(const Block & block);\n-\n-    void buildAttributeIntervalTrees();\n-\n-    template <typename T>\n-    void setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);\n+    ColumnPtr getColumnInternal(\n+        const std::string & attribute_name,\n+        const DataTypePtr & result_type,\n+        const PaddedPODArray<UInt64> & key_to_index) const;\n \n-    void setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);\n+    template <typename AttributeType, bool is_nullable, typename ValueSetter>\n+    void getItemsInternalImpl(\n+        const Attribute & attribute,\n+        const PaddedPODArray<UInt64> & key_to_index,\n+        ValueSetter && set_value) const;\n \n-    template <typename RangeType>\n-    void getKeysAndDates(\n-        PaddedPODArray<KeyType> & keys,\n-        PaddedPODArray<RangeType> & start_dates,\n-        PaddedPODArray<RangeType> & end_dates) const;\n+    void updateData();\n \n-    template <typename T, typename RangeType>\n-    void getKeysAndDates(\n-        const Attribute & attribute,\n-        PaddedPODArray<KeyType> & keys,\n-        PaddedPODArray<RangeType> & start_dates,\n-        PaddedPODArray<RangeType> & end_dates) const;\n+    void blockToAttributes(const Block & block);\n \n-    template <typename RangeType>\n-    PaddedPODArray<Int64> makeDateKeys(\n-        const PaddedPODArray<RangeType> & block_start_dates,\n-        const PaddedPODArray<RangeType> & block_end_dates) const;\n+    void setAttributeValue(Attribute & attribute, const Field & value);\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\n-    const bool require_nonempty;\n+    const RangeHashedDictionaryConfiguration configuration;\n     BlockPtr update_field_loaded_block;\n \n     std::vector<Attribute> attributes;\n-    Arena complex_key_arena;\n+    KeyAttribute key_attribute;\n \n     size_t bytes_allocated = 0;\n     size_t element_count = 0;\n@@ -195,7 +246,6 @@ class RangeHashedDictionary final : public IDictionary\n     mutable std::atomic<size_t> query_count{0};\n     mutable std::atomic<size_t> found_count{0};\n     Arena string_arena;\n-    NoAttributesCollectionType no_attributes_container;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02179_range_hashed_dictionary_invalid_interval.reference b/tests/queries/0_stateless/02179_range_hashed_dictionary_invalid_interval.reference\nindex d77534180871..c1ffcc3bb0f7 100644\n--- a/tests/queries/0_stateless/02179_range_hashed_dictionary_invalid_interval.reference\n+++ b/tests/queries/0_stateless/02179_range_hashed_dictionary_invalid_interval.reference\n@@ -3,3 +3,5 @@ DefaultValue\n 1\n 0\n 0\t15\t20\tValue\n+0\t10\t0\tValue\n+0\t15\t10\tValue\ndiff --git a/tests/queries/0_stateless/02183_dictionary_no_attributes.reference b/tests/queries/0_stateless/02183_dictionary_no_attributes.reference\nindex 972b0c7c671b..cbf3af697cde 100644\n--- a/tests/queries/0_stateless/02183_dictionary_no_attributes.reference\n+++ b/tests/queries/0_stateless/02183_dictionary_no_attributes.reference\n@@ -38,3 +38,7 @@ PolygonDictionary\n 1\n 0\n [[[(0,0),(0,1),(1,1),(1,0)]]]\n+RangeHashedDictionary\n+0\t0\t1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/02183_dictionary_no_attributes.sql b/tests/queries/0_stateless/02183_dictionary_no_attributes.sql\nindex 193b8dc2cdc5..bd3d73594f8e 100644\n--- a/tests/queries/0_stateless/02183_dictionary_no_attributes.sql\n+++ b/tests/queries/0_stateless/02183_dictionary_no_attributes.sql\n@@ -170,7 +170,7 @@ CREATE TABLE 02183_range_dictionary_source_table\n )\n ENGINE = TinyLog;\n \n-INSERT INTO 02183_range_dictionary_source_table VALUES(1, 0, 1);\n+INSERT INTO 02183_range_dictionary_source_table VALUES(0, 0, 1);\n \n DROP DICTIONARY IF EXISTS 02183_range_dictionary;\n CREATE DICTIONARY 02183_range_dictionary\n@@ -185,7 +185,10 @@ LAYOUT(RANGE_HASHED())\n RANGE(MIN start MAX end)\n LIFETIME(0);\n \n-SELECT * FROM 02183_range_dictionary; -- {serverError 1}\n+SELECT 'RangeHashedDictionary';\n+SELECT * FROM 02183_range_dictionary;\n+SELECT dictHas('02183_range_dictionary', 0, 0);\n+SELECT dictHas('02183_range_dictionary', 0, 2);\n \n DROP DICTIONARY 02183_range_dictionary;\n DROP TABLE 02183_range_dictionary_source_table;\ndiff --git a/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.reference b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.reference\nnew file mode 100644\nindex 000000000000..9b43f375e11d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.reference\n@@ -0,0 +1,3 @@\n+1\t0\t18446744073709551615\tvalue0\tvalue1\tvalue2\n+('value0','value1','value2')\n+1\ndiff --git a/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.sql b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.sql\nnew file mode 100644\nindex 000000000000..6e892d9d2467\n--- /dev/null\n+++ b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.sql\n@@ -0,0 +1,36 @@\n+DROP TABLE IF EXISTS 02184_range_dictionary_source_table;\n+CREATE TABLE 02184_range_dictionary_source_table\n+(\n+    id UInt64,\n+    start UInt64,\n+    end UInt64,\n+    value_0 String,\n+    value_1 String,\n+    value_2 String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 02184_range_dictionary_source_table VALUES (1, 0, 18446744073709551615, 'value0', 'value1', 'value2');\n+\n+DROP DICTIONARY IF EXISTS 02184_range_dictionary;\n+CREATE DICTIONARY 02184_range_dictionary\n+(\n+    id UInt64,\n+    start UInt64,\n+    end UInt64,\n+    value_0 String,\n+    value_1 String,\n+    value_2 String\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02184_range_dictionary_source_table'))\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT * FROM 02184_range_dictionary;\n+SELECT dictGet('02184_range_dictionary', ('value_0', 'value_1', 'value_2'), 1, 18446744073709551615);\n+SELECT dictHas('02184_range_dictionary', 1, 18446744073709551615);\n+\n+DROP DICTIONARY 02184_range_dictionary;\n+DROP TABLE 02184_range_dictionary_source_table;\ndiff --git a/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.reference b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.reference\nnew file mode 100644\nindex 000000000000..f8dc47039e93\n--- /dev/null\n+++ b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.reference\n@@ -0,0 +1,22 @@\n+Source table\n+0\t\\N\t5000\tValue0\n+0\t5001\t10000\tValue1\n+0\t10001\t\\N\tValue2\n+Dictionary convert_null_range_bound_to_open = 1\n+0\t5001\t10000\tValue1\n+0\t0\t5000\tValue0\n+0\t10001\t18446744073709551615\tValue2\n+Value0\n+Value1\n+Value2\n+1\n+1\n+1\n+Dictionary convert_null_range_bound_to_open = 0\n+0\t5001\t10000\tValue1\n+DefaultValue\n+Value1\n+DefaultValue\n+0\n+1\n+0\ndiff --git a/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.sql b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.sql\nnew file mode 100644\nindex 000000000000..e6edee2ea18f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.sql\n@@ -0,0 +1,63 @@\n+DROP TABLE IF EXISTS 02185_range_dictionary_source_table;\n+CREATE TABLE 02185_range_dictionary_source_table\n+(\n+    id UInt64,\n+    start Nullable(UInt64),\n+    end Nullable(UInt64),\n+    value String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 02185_range_dictionary_source_table VALUES (0, NULL, 5000, 'Value0'), (0, 5001, 10000, 'Value1'), (0, 10001, NULL, 'Value2');\n+\n+SELECT 'Source table';\n+SELECT * FROM 02185_range_dictionary_source_table;\n+\n+DROP DICTIONARY IF EXISTS 02185_range_dictionary;\n+CREATE DICTIONARY 02185_range_dictionary\n+(\n+    id UInt64,\n+    start UInt64,\n+    end UInt64,\n+    value String DEFAULT 'DefaultValue'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02185_range_dictionary_source_table'))\n+LAYOUT(RANGE_HASHED(convert_null_range_bound_to_open 1))\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT 'Dictionary convert_null_range_bound_to_open = 1';\n+SELECT * FROM 02185_range_dictionary;\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 0);\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 5001);\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 10001);\n+SELECT dictHas('02185_range_dictionary', 0, 0);\n+SELECT dictHas('02185_range_dictionary', 0, 5001);\n+SELECT dictHas('02185_range_dictionary', 0, 10001);\n+\n+DROP DICTIONARY 02185_range_dictionary;\n+\n+CREATE DICTIONARY 02185_range_dictionary\n+(\n+    id UInt64,\n+    start UInt64,\n+    end UInt64,\n+    value String DEFAULT 'DefaultValue'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02185_range_dictionary_source_table'))\n+LAYOUT(RANGE_HASHED(convert_null_range_bound_to_open 0))\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT 'Dictionary convert_null_range_bound_to_open = 0';\n+SELECT * FROM 02185_range_dictionary;\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 0);\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 5001);\n+SELECT dictGet('02185_range_dictionary', 'value', 0, 10001);\n+SELECT dictHas('02185_range_dictionary', 0, 0);\n+SELECT dictHas('02185_range_dictionary', 0, 5001);\n+SELECT dictHas('02185_range_dictionary', 0, 10001);\n+\n+DROP TABLE 02185_range_dictionary_source_table;\ndiff --git a/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.reference b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.reference\nnew file mode 100644\nindex 000000000000..64994150f59e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.reference\n@@ -0,0 +1,18 @@\n+Source table\n+1\t2020-01-01\t2100-01-01\tValue0\n+1\t2020-01-02\t2100-01-01\tValue1\n+1\t2020-01-03\t2100-01-01\tValue2\n+Dictionary .range_lookup_strategy = min\n+1\t2020-01-01\t2100-01-01\tValue0\n+1\t2020-01-02\t2100-01-01\tValue1\n+1\t2020-01-03\t2100-01-01\tValue2\n+Value0\n+Value0\n+Value0\n+Dictionary .range_lookup_strategy = max\n+1\t2020-01-01\t2100-01-01\tValue0\n+1\t2020-01-02\t2100-01-01\tValue1\n+1\t2020-01-03\t2100-01-01\tValue2\n+Value0\n+Value1\n+Value2\ndiff --git a/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.sql b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.sql\nnew file mode 100644\nindex 000000000000..caafc5e76a22\n--- /dev/null\n+++ b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.sql\n@@ -0,0 +1,64 @@\n+DROP TABLE IF EXISTS 02186_range_dictionary_source_table;\n+CREATE TABLE 02186_range_dictionary_source_table\n+(\n+    id UInt64,\n+    start Date,\n+    end Date,\n+    value String\n+)\n+Engine = TinyLog;\n+\n+INSERT INTO 02186_range_dictionary_source_table VALUES (1, '2020-01-01', '2100-01-01', 'Value0');\n+INSERT INTO 02186_range_dictionary_source_table VALUES (1, '2020-01-02', '2100-01-01', 'Value1');\n+INSERT INTO 02186_range_dictionary_source_table VALUES (1, '2020-01-03', '2100-01-01', 'Value2');\n+\n+SELECT 'Source table';\n+SELECT * FROM 02186_range_dictionary_source_table;\n+\n+DROP DICTIONARY IF EXISTS 02186_range_dictionary;\n+CREATE DICTIONARY 02186_range_dictionary\n+(\n+    id UInt64,\n+    start Date,\n+    end Date,\n+    value String\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02186_range_dictionary_source_table'))\n+LAYOUT(RANGE_HASHED(range_lookup_strategy 'min'))\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT 'Dictionary .range_lookup_strategy = min';\n+\n+SELECT * FROM 02186_range_dictionary;\n+\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-01'));\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-02'));\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-03'));\n+\n+DROP DICTIONARY 02186_range_dictionary;\n+\n+CREATE DICTIONARY 02186_range_dictionary\n+(\n+    id UInt64,\n+    start Date,\n+    end Date,\n+    value String\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02186_range_dictionary_source_table'))\n+LAYOUT(RANGE_HASHED(range_lookup_strategy 'max'))\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT 'Dictionary .range_lookup_strategy = max';\n+\n+SELECT * FROM 02186_range_dictionary;\n+\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-01'));\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-02'));\n+select dictGet('02186_range_dictionary', 'value', toUInt64(1), toDate('2020-01-03'));\n+\n+DROP DICTIONARY 02186_range_dictionary;\n+DROP TABLE 02186_range_dictionary_source_table;\n",
  "problem_statement": "range dictionary doesn't work correctly with open range on right side for non Date datatypes.\n**Describe the unexpected behaviour**\r\nrange dictionary produces different result for Date and non Date datatypes, if you try to use open range feature on right side.\r\n\r\n**How to reproduce**\r\nClickHouse 21.10\r\n\r\n```\r\nDROP TABLE IF EXISTS dict_sr;\r\nDROP DICTIONARY IF EXISTS dict_sr_a;\r\n\r\nCREATE TABLE dict_sr\r\n(\r\n    `id` UInt32,\r\n    `id_min` Nullable(UInt16),\r\n    `id_max` Nullable(UInt16),\r\n    `value` Float64\r\n)\r\nENGINE = Log;\r\n\r\n\r\nCREATE DICTIONARY dict_sr_a\r\n(\r\n  id UInt64,\r\n  id_min UInt16,\r\n  id_max UInt16,\r\n  value Float64\r\n)\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 'dict_sr'))\r\nLIFETIME(MIN 1 MAX 1000)\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN id_min MAX id_max);\r\n\r\nINSERT INTO dict_sr VALUES (1,  NULL, 5000, 1), (1, 5001, 10000, 2), (1, 10001, NULL, 3);\r\n\r\nSELECT dictGet('dict_sr_a', 'value', toUInt64(1), 16000) as res;\r\n\r\n\u250c\u2500res\u2500\u2510\r\n\u2502   0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nDROP TABLE IF EXISTS dict_sr;\r\nDROP DICTIONARY IF EXISTS dict_sr_a;\r\n\r\nCREATE TABLE dict_sr\r\n(\r\n    `id` UInt32,\r\n    `id_min` Nullable(Date),\r\n    `id_max` Nullable(Date),\r\n    `value` Float64\r\n)\r\nENGINE = Log;\r\n\r\n\r\nCREATE DICTIONARY dict_sr_a\r\n(\r\n  id UInt64,\r\n  id_min Date,\r\n  id_max Date,\r\n  value Float64\r\n)\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 'dict_sr'))\r\nLIFETIME(MIN 1 MAX 1000)\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN id_min MAX id_max);\r\n\r\nINSERT INTO dict_sr VALUES (1,  NULL, 5000, 1), (1, 5001, 10000, 2), (1, 10001, NULL, 3);\r\n\r\nSELECT dictGet('dict_sr_a', 'value', toUInt64(1), 16000) as res;\r\n\r\n\u250c\u2500res\u2500\u2510\r\n\u2502   3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Expected behavior**\r\nBehavior the same for all data types.\r\n\nRangeHashedDictionary does not support integer values outside of Int64\n> You have to provide the following information whenever possible.\r\n\r\n```\r\nCREATE DICTIONARY analytics.all_ipv6s_lower (\r\n    id UInt64,\r\n    start_addr UInt64,\r\n    end_addr UInt64,\r\n    subnet_mask String,\r\n    isp String,\r\n    province String\r\n)\r\nPRIMARY KEY id\r\nSOURCE(FILE(path '/var/lib/clickhouse/user_files/all_ipv6s_lower.csv' format 'CSV'))\r\nLIFETIME(0)\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN start_addr MAX end_addr)\r\n```\r\n\r\nall_ipv6s_lower.csv\u3002content below\r\n\r\n```\r\n1,0,18446744073709551615,ffff:ffff::,value1,value2,value3\r\n```\r\n\r\nthe we do.\r\n```\r\nselect * from analytics.all_ipv6s_lower\r\n```\r\nonly `id`,`start_addr`,`end_addr` have values\u3002  other column no value.\r\n\r\n> A clear and concise description of what works not as it is supposed to.\r\n\r\nversion\r\n```\r\nClickHouse client version 21.8.4.51 (official build).\r\n```\r\n\r\n**How to reproduce**\r\n\r\nif we change csv content to bellow\r\n```\r\n1,0,1,ffff:ffff::,value1,value2,value3\r\n```\r\n\r\nchange UInt64 max value `18446744073709551615`  to  `1`.\r\n\r\nthis will work. and all column values returned.\r\n\r\n**Expected behavior**\r\n\r\nall_ipv6s_lower.csv :\r\n```\r\n1,0,18446744073709551615,ffff:ffff::,value1,value2,value3\r\n```\r\nall_ipv6s_lower.csv:\r\n```\r\n1,0,1,ffff:ffff::,value1,value2,value3\r\n```\r\nboth work\r\n\r\n**Additional context**\r\n\r\n\nRANGE_HASHED works unnatural with overlapped ranges (open dates)\nImagine we insert rows into a table with open end date. Today currencies, prices, discounts. We don't know the future.\r\n\r\n```\r\ncreate table prices(id UInt64, begin Date, end Date, price Float64) Engine= Memory;\r\n\r\ninsert into prices values(1, '2020-01-01', '2100-01-01', 1.0);\r\ninsert into prices values(1, '2020-01-02', '2100-01-01', 2.0);\r\ninsert into prices values(1, '2020-01-03', '2100-01-01', 3.0);\r\n\r\nselect * from prices\u3000;\r\n\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2020-01-01 \u2502 2100-01-01 \u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2020-01-02 \u2502 2100-01-01 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2020-01-03 \u2502 2100-01-01 \u2502     3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nCREATE DICTIONARY prices_dict\r\n( id UInt64, begin Date, end Date, price Float64 )\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(host 'localhost' port 9000 user 'default' password '' db 'default' table 'prices'\r\n))\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN begin MAX end)\r\nLIFETIME(1);\r\n\r\n\r\nSELECT * FROM prices_dict\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2020-01-01 \u2502 2100-01-01 \u2502     1 \u2502\r\n\u2502  1 \u2502 2020-01-02 \u2502 2100-01-01 \u2502     1 \u2502 ---- I would expect 2\r\n\u2502  1 \u2502 2020-01-03 \u2502 2100-01-01 \u2502     1 \u2502 ---- I would expect 3\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect dictGet('default.prices_dict', 'price', toUInt64(1), toDate('2020-01-02')) x;\r\n\u250c\u2500x\u2500\u2510\r\n\u2502 1 \u2502  --- expected 2\r\n\u2514\u2500\u2500\u2500\u2518\r\n```\r\nIt would be nice to have that behavior. Unfortunately some users can rely on the current behavior. \r\nMaybe you should implement a new layout RANGE_HASHED_2. @alexey-milovidov  ?\r\n\r\n\r\nIT NOT A BUG. It's a feature of the implementation.\r\n\r\n```\r\n-- try to insert NULL dates as an ending\r\ntruncate table prices;\r\ninsert into prices values(1, '2020-01-01', toDate(0), 1.0);\r\ninsert into prices values(1, '2020-01-02', toDate(0), 2.0);\r\ninsert into prices values(1, '2020-01-03', toDate(0), 3.0);\r\nSELECT * FROM prices_dict;\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2020-01-01 \u2502 1970-01-01 \u2502     1 \u2502\r\n\u2502  1 \u2502 2020-01-02 \u2502 1970-01-01 \u2502     1 \u2502\r\n\u2502  1 \u2502 2020-01-03 \u2502 1970-01-01 \u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n-- try to insert NULL dates as a beginning\r\ntruncate table prices; \r\ninsert into prices values(1, toDate(0), '2020-01-01', 1.0);\r\ninsert into prices values(1, toDate(0), '2020-01-02', 2.0);\r\ninsert into prices values(1, toDate(0), '2020-01-03', 3.0);\r\nSELECT * FROM prices_dict;\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 1970-01-01 \u2502 2020-01-01 \u2502     1 \u2502   \r\n\u2502  1 \u2502 1970-01-01 \u2502 2020-01-02 \u2502     2 \u2502\r\n\u2502  1 \u2502 1970-01-01 \u2502 2020-01-03 \u2502     3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n-- try to insert open dates but not Null as a beginning\r\ntruncate table prices; \r\ninsert into prices values(1, '2000-01-01', '2020-01-01', 1.0);\r\ninsert into prices values(1, '2000-01-01', '2020-01-02', 2.0);\r\ninsert into prices values(1, '2000-01-01', '2020-01-03', 3.0);\r\n\r\nSELECT * FROM prices_dict;\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500begin\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500end\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502 2000-01-01 \u2502 2020-01-01 \u2502     1 \u2502    here  \r\n\u2502  1 \u2502 2000-01-01 \u2502 2020-01-02 \u2502     1 \u2502        something\r\n\u2502  1 \u2502 2000-01-01 \u2502 2020-01-03 \u2502     1 \u2502                   unexpected\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\n\n",
  "hints_text": "better to fix it with https://github.com/ClickHouse/ClickHouse/issues/21647\n@pengliaoye could not reproduce on current master, your table has only 6 columns but in TSV there are 7, could you please send actual table structure to reproduce ? Thanks.\r\n\nthis not work:\r\n1,0,18446744073709551615,ffff:ffff::,value1,value2\r\nthis work:\r\n1,0,1,ffff:ffff::,value1,value2\r\n\r\nonly 6 columns value\nActually it is documentation issue. RangeHashedDictionary stores ranges in Int64. Updated #29038.\ncan support UInt64?\n@pengliaoye currently there is no plans to support values that does not fit Int64 type for RangeHashedDictionary.\nprovince: beiging\r\nbegin: 240c:0:0:0:0:0:0:0  \r\nend: 240c:000f:ffff:ffff:ffff:ffff:ffff:ffff\r\n\r\nipv6: 240c:0:0:0:0:0:0:1\r\n\r\nwe want using ipv6, check if in range begin and end. then get the province.   how to use ip_trie layout.   currently the ip_trie only support cidr.  any suggestion?\r\n\n@pengliaoye please for IPTrie create separate issue and I will investigate.\nSo, we need to choose the most precise (narrow) range in case of ambiguity?\nThe most narrow range or just a range with the latest start point?\n```\r\n......++++++++++........\r\n.........+++++++++++++..    <----- the winner\r\n...............+++++++++\r\n            ^\r\n            |\r\n        searched \r\n          point\r\n```\r\n\r\n ",
  "created_at": "2022-01-23T17:30:07Z",
  "modified_files": [
    "src/Common/IntervalTree.h",
    "src/DataTypes/IDataType.h",
    "src/Dictionaries/DictionarySource.cpp",
    "src/Dictionaries/DictionarySource.h",
    "src/Dictionaries/DictionaryStructure.cpp",
    "src/Dictionaries/RangeHashedDictionary.cpp",
    "src/Dictionaries/RangeHashedDictionary.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02179_range_hashed_dictionary_invalid_interval.reference",
    "tests/queries/0_stateless/02183_dictionary_no_attributes.reference",
    "tests/queries/0_stateless/02183_dictionary_no_attributes.sql",
    "b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.reference",
    "b/tests/queries/0_stateless/02184_range_hashed_dictionary_outside_range_values.sql",
    "b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.reference",
    "b/tests/queries/0_stateless/02185_range_hashed_dictionary_open_ranges.sql",
    "b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.reference",
    "b/tests/queries/0_stateless/02186_range_hashed_dictionary_intersecting_intervals.sql"
  ]
}