You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
range dictionary doesn't work correctly with open range on right side for non Date datatypes.
**Describe the unexpected behaviour**
range dictionary produces different result for Date and non Date datatypes, if you try to use open range feature on right side.

**How to reproduce**
ClickHouse 21.10

```
DROP TABLE IF EXISTS dict_sr;
DROP DICTIONARY IF EXISTS dict_sr_a;

CREATE TABLE dict_sr
(
    `id` UInt32,
    `id_min` Nullable(UInt16),
    `id_max` Nullable(UInt16),
    `value` Float64
)
ENGINE = Log;


CREATE DICTIONARY dict_sr_a
(
  id UInt64,
  id_min UInt16,
  id_max UInt16,
  value Float64
)
PRIMARY KEY id
SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 'dict_sr'))
LIFETIME(MIN 1 MAX 1000)
LAYOUT(RANGE_HASHED())
RANGE(MIN id_min MAX id_max);

INSERT INTO dict_sr VALUES (1,  NULL, 5000, 1), (1, 5001, 10000, 2), (1, 10001, NULL, 3);

SELECT dictGet('dict_sr_a', 'value', toUInt64(1), 16000) as res;

┌─res─┐
│   0 │
└─────┘


DROP TABLE IF EXISTS dict_sr;
DROP DICTIONARY IF EXISTS dict_sr_a;

CREATE TABLE dict_sr
(
    `id` UInt32,
    `id_min` Nullable(Date),
    `id_max` Nullable(Date),
    `value` Float64
)
ENGINE = Log;


CREATE DICTIONARY dict_sr_a
(
  id UInt64,
  id_min Date,
  id_max Date,
  value Float64
)
PRIMARY KEY id
SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 'dict_sr'))
LIFETIME(MIN 1 MAX 1000)
LAYOUT(RANGE_HASHED())
RANGE(MIN id_min MAX id_max);

INSERT INTO dict_sr VALUES (1,  NULL, 5000, 1), (1, 5001, 10000, 2), (1, 10001, NULL, 3);

SELECT dictGet('dict_sr_a', 'value', toUInt64(1), 16000) as res;

┌─res─┐
│   3 │
└─────┘
```

**Expected behavior**
Behavior the same for all data types.

RangeHashedDictionary does not support integer values outside of Int64
> You have to provide the following information whenever possible.

```
CREATE DICTIONARY analytics.all_ipv6s_lower (
    id UInt64,
    start_addr UInt64,
    end_addr UInt64,
    subnet_mask String,
    isp String,
    province String
)
PRIMARY KEY id
SOURCE(FILE(path '/var/lib/clickhouse/user_files/all_ipv6s_lower.csv' format 'CSV'))
LIFETIME(0)
LAYOUT(RANGE_HASHED())
RANGE(MIN start_addr MAX end_addr)
```

all_ipv6s_lower.csv。content below

```
1,0,18446744073709551615,ffff:ffff::,value1,value2,value3
```

the we do.
```
select * from analytics.all_ipv6s_lower
```
only `id`,`start_addr`,`end_addr` have values。  other column no value.

> A clear and concise description of what works not as it is supposed to.

version
```
ClickHouse client version 21.8.4.51 (official build).
```

**How to reproduce**

if we change csv content to bellow
```
1,0,1,ffff:ffff::,value1,value2,value3
```

change UInt64 max value `18446744073709551615`  to  `1`.

this will work. and all column values returned.

**Expected behavior**

all_ipv6s_lower.csv :
```
1,0,18446744073709551615,ffff:ffff::,value1,value2,value3
```
all_ipv6s_lower.csv:
```
1,0,1,ffff:ffff::,value1,value2,value3
```
both work

**Additional context**


RANGE_HASHED works unnatural with overlapped ranges (open dates)
Imagine we insert rows into a table with open end date. Today currencies, prices, discounts. We don't know the future.

```
create table prices(id UInt64, begin Date, end Date, price Float64) Engine= Memory;

insert into prices values(1, '2020-01-01', '2100-01-01', 1.0);
insert into prices values(1, '2020-01-02', '2100-01-01', 2.0);
insert into prices values(1, '2020-01-03', '2100-01-01', 3.0);

select * from prices　;

┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2020-01-01 │ 2100-01-01 │     1 │
└────┴────────────┴────────────┴───────┘
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2020-01-02 │ 2100-01-01 │     2 │
└────┴────────────┴────────────┴───────┘
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2020-01-03 │ 2100-01-01 │     3 │
└────┴────────────┴────────────┴───────┘

CREATE DICTIONARY prices_dict
( id UInt64, begin Date, end Date, price Float64 )
PRIMARY KEY id
SOURCE(CLICKHOUSE(host 'localhost' port 9000 user 'default' password '' db 'default' table 'prices'
))
LAYOUT(RANGE_HASHED())
RANGE(MIN begin MAX end)
LIFETIME(1);


SELECT * FROM prices_dict
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2020-01-01 │ 2100-01-01 │     1 │
│  1 │ 2020-01-02 │ 2100-01-01 │     1 │ ---- I would expect 2
│  1 │ 2020-01-03 │ 2100-01-01 │     1 │ ---- I would expect 3
└────┴────────────┴────────────┴───────┘

select dictGet('default.prices_dict', 'price', toUInt64(1), toDate('2020-01-02')) x;
┌─x─┐
│ 1 │  --- expected 2
└───┘
```
It would be nice to have that behavior. Unfortunately some users can rely on the current behavior. 
Maybe you should implement a new layout RANGE_HASHED_2. @alexey-milovidov  ?


IT NOT A BUG. It's a feature of the implementation.

```
-- try to insert NULL dates as an ending
truncate table prices;
insert into prices values(1, '2020-01-01', toDate(0), 1.0);
insert into prices values(1, '2020-01-02', toDate(0), 2.0);
insert into prices values(1, '2020-01-03', toDate(0), 3.0);
SELECT * FROM prices_dict;
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2020-01-01 │ 1970-01-01 │     1 │
│  1 │ 2020-01-02 │ 1970-01-01 │     1 │
│  1 │ 2020-01-03 │ 1970-01-01 │     1 │
└────┴────────────┴────────────┴───────┘

-- try to insert NULL dates as a beginning
truncate table prices; 
insert into prices values(1, toDate(0), '2020-01-01', 1.0);
insert into prices values(1, toDate(0), '2020-01-02', 2.0);
insert into prices values(1, toDate(0), '2020-01-03', 3.0);
SELECT * FROM prices_dict;
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 1970-01-01 │ 2020-01-01 │     1 │   
│  1 │ 1970-01-01 │ 2020-01-02 │     2 │
│  1 │ 1970-01-01 │ 2020-01-03 │     3 │
└────┴────────────┴────────────┴───────┘

-- try to insert open dates but not Null as a beginning
truncate table prices; 
insert into prices values(1, '2000-01-01', '2020-01-01', 1.0);
insert into prices values(1, '2000-01-01', '2020-01-02', 2.0);
insert into prices values(1, '2000-01-01', '2020-01-03', 3.0);

SELECT * FROM prices_dict;
┌─id─┬──────begin─┬────────end─┬─price─┐
│  1 │ 2000-01-01 │ 2020-01-01 │     1 │    here  
│  1 │ 2000-01-01 │ 2020-01-02 │     1 │        something
│  1 │ 2000-01-01 │ 2020-01-03 │     1 │                   unexpected
└────┴────────────┴────────────┴───────┘
```
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
