diff --git a/docker/test/test_runner.sh b/docker/test/test_runner.sh
deleted file mode 100755
index 0c99c8c2b323..000000000000
--- a/docker/test/test_runner.sh
+++ /dev/null
@@ -1,86 +0,0 @@
-#!/bin/sh
-
-set -e -x
-
-# Not sure why shellcheck complains that rc is not assigned before it is referenced.
-# shellcheck disable=SC2154
-trap 'rc=$?; echo EXITED WITH: $rc; exit $rc' EXIT
-
-# CLI option to prevent rebuilding images, just re-run tests with images leftover from previuos time
-readonly NO_REBUILD_FLAG="--no-rebuild"
-
-readonly CLICKHOUSE_DOCKER_DIR="$(realpath "${1}")"
-readonly CLICKHOUSE_PACKAGES_ARG="${2}"
-CLICKHOUSE_SERVER_IMAGE="${3}"
-
-if [ "${CLICKHOUSE_PACKAGES_ARG}" != "${NO_REBUILD_FLAG}" ]; then
-    readonly CLICKHOUSE_PACKAGES_DIR="$(realpath "${2}")" # or --no-rebuild
-fi
-
-
-# In order to allow packages directory to be anywhere, and to reduce amount of context sent to the docker daemon,
-# all images are built in multiple stages:
-# 1. build base image, install dependencies
-# 2. run image with volume mounted, install what needed from those volumes
-# 3. tag container as image
-# 4. [optional] build another image atop of tagged.
-
-# TODO: optionally mount most recent clickhouse-test and queries directory from local machine
-
-if [ "${CLICKHOUSE_PACKAGES_ARG}" != "${NO_REBUILD_FLAG}" ]; then
-    docker build --network=host \
-        -f "${CLICKHOUSE_DOCKER_DIR}/test/stateless/clickhouse-statelest-test-runner.Dockerfile" \
-        --target clickhouse-test-runner-base \
-        -t clickhouse-test-runner-base:preinstall \
-        "${CLICKHOUSE_DOCKER_DIR}/test/stateless"
-
-    docker rm -f clickhouse-test-runner-installing-packages || true
-    docker run  --network=host \
-        -v "${CLICKHOUSE_PACKAGES_DIR}:/packages" \
-        --name clickhouse-test-runner-installing-packages \
-        clickhouse-test-runner-base:preinstall
-    docker commit clickhouse-test-runner-installing-packages clickhouse-statelest-test-runner:local
-    docker rm -f clickhouse-test-runner-installing-packages || true
-fi
-
-# # Create a bind-volume to the clickhouse-test script file
-# docker volume create --driver local --opt type=none --opt device=/home/enmk/proj/ClickHouse_master/tests/clickhouse-test --opt o=bind clickhouse-test-script-volume
-# docker volume create --driver local --opt type=none --opt device=/home/enmk/proj/ClickHouse_master/tests/queries --opt o=bind clickhouse-test-queries-dir-volume
-
-# Build server image (optional) from local packages
-if [ -z "${CLICKHOUSE_SERVER_IMAGE}" ]; then
-    CLICKHOUSE_SERVER_IMAGE="clickhouse/server:local"
-
-    if [ "${CLICKHOUSE_PACKAGES_ARG}" != "${NO_REBUILD_FLAG}" ]; then
-        docker build --network=host \
-            -f "${CLICKHOUSE_DOCKER_DIR}/server/local.Dockerfile" \
-            --target clickhouse-server-base \
-            -t clickhouse-server-base:preinstall \
-            "${CLICKHOUSE_DOCKER_DIR}/server"
-
-        docker rm -f clickhouse_server_base_installing_server || true
-        docker run  --network=host -v "${CLICKHOUSE_PACKAGES_DIR}:/packages" \
-            --name clickhouse_server_base_installing_server \
-            clickhouse-server-base:preinstall
-        docker commit clickhouse_server_base_installing_server clickhouse-server-base:postinstall
-
-        docker build --network=host \
-            -f "${CLICKHOUSE_DOCKER_DIR}/server/local.Dockerfile" \
-            --target clickhouse-server \
-            -t "${CLICKHOUSE_SERVER_IMAGE}" \
-            "${CLICKHOUSE_DOCKER_DIR}/server"
-    fi
-fi
-
-docker rm -f test-runner || true
-docker-compose down
-CLICKHOUSE_SERVER_IMAGE="${CLICKHOUSE_SERVER_IMAGE}" \
-    docker-compose -f "${CLICKHOUSE_DOCKER_DIR}/test/test_runner_docker_compose.yaml" \
-    create \
-    --build --force-recreate
-
-CLICKHOUSE_SERVER_IMAGE="${CLICKHOUSE_SERVER_IMAGE}" \
-    docker-compose -f "${CLICKHOUSE_DOCKER_DIR}/test/test_runner_docker_compose.yaml" \
-    run \
-    --name test-runner \
-    test-runner
diff --git a/docker/test/test_runner_docker_compose.yaml b/docker/test/test_runner_docker_compose.yaml
deleted file mode 100644
index 2aef6a48d77f..000000000000
--- a/docker/test/test_runner_docker_compose.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
-version: "2"
-
-services:
-  clickhouse-server:
-    image: ${CLICKHOUSE_SERVER_IMAGE}
-    expose:
-      - "8123" # HTTP
-      - "9000" # TCP
-      - "9009" # HTTP-interserver
-    restart: "no"
-
-  test-runner:
-    image: clickhouse-statelest-test-runner:local
-
-    restart: "no"
-    depends_on:
-      - clickhouse-server
-    environment:
-      # these are used by clickhouse-test to point clickhouse-client to the right server
-      - CLICKHOUSE_HOST=clickhouse-server
-      - CLICKHOUSE_PORT=9009
-      - CLICKHOUSE_TEST_HOST_EXPOSED_PORT=51234
-    expose:
-      # port for any test to serve data to clickhouse-server on rare occasion (like URL-engine tables in 00646),
-      # should match value of CLICKHOUSE_TEST_HOST_EXPOSED_PORT above
-      - "51234"
-
-    # NOTE: Dev-mode: mount newest versions of the queries and clickhouse-test script into container.
-    # volumes:
-    #   - /home/enmk/proj/ClickHouse_master/tests/queries:/usr/share/clickhouse-test/queries:ro
-    #   - /home/enmk/proj/ClickHouse_master/tests/clickhouse-test:/usr/bin/clickhouse-test:ro
-
-    # String-form instead of list-form to allow multiple arguments in "${CLICKHOUSE_TEST_ARGS}"
-    entrypoint: "clickhouse-test ${CLICKHOUSE_TEST_ARGS}"
diff --git a/tests/ci/build_check.py b/tests/ci/build_check.py
index 2a079a603674..8ef723454d55 100644
--- a/tests/ci/build_check.py
+++ b/tests/ci/build_check.py
@@ -264,7 +264,7 @@ def main():
         version_type = "stable"
         official_flag = True
 
-    update_version_local(REPO_COPY, version, version_type)
+    update_version_local(version, version_type)
 
     logging.info("Updated local files with version")
 
diff --git a/tests/ci/docker_images_check.py b/tests/ci/docker_images_check.py
index 30aebb6aaeb7..43671e3a2f73 100644
--- a/tests/ci/docker_images_check.py
+++ b/tests/ci/docker_images_check.py
@@ -397,17 +397,19 @@ def main():
 
     images_dict = get_images_dict(GITHUB_WORKSPACE, "docker/images.json")
 
+    pr_info = PRInfo()
     if args.all:
-        pr_info = PRInfo()
         pr_info.changed_files = set(images_dict.keys())
     elif args.image_path:
-        pr_info = PRInfo()
         pr_info.changed_files = set(i for i in args.image_path)
     else:
-        pr_info = PRInfo(need_changed_files=True)
+        pr_info.fetch_changed_files()
 
     changed_images = get_changed_docker_images(pr_info, images_dict)
-    logging.info("Has changed images %s", ", ".join([im.path for im in changed_images]))
+    if changed_images:
+        logging.info(
+            "Has changed images: %s", ", ".join([im.path for im in changed_images])
+        )
 
     image_versions, result_version = gen_versions(pr_info, args.suffix)
 
diff --git a/tests/ci/docker_server.py b/tests/ci/docker_server.py
new file mode 100644
index 000000000000..0d22724fcb77
--- /dev/null
+++ b/tests/ci/docker_server.py
@@ -0,0 +1,356 @@
+#!/usr/bin/env python
+
+# here
+import argparse
+import json
+import logging
+import subprocess
+from os import path as p, makedirs
+from typing import List, Tuple
+
+from github import Github
+
+from clickhouse_helper import ClickHouseHelper, prepare_tests_results_for_clickhouse
+from commit_status_helper import post_commit_status
+from docker_images_check import DockerImage
+from env_helper import CI, GITHUB_RUN_URL, RUNNER_TEMP, S3_BUILDS_BUCKET
+from get_robot_token import get_best_robot_token, get_parameter_from_ssm
+from pr_info import PRInfo
+from s3_helper import S3Helper
+from stopwatch import Stopwatch
+from upload_result_helper import upload_results
+from version_helper import (
+    get_tagged_versions,
+    get_version_from_repo,
+    get_version_from_string,
+    validate_version,
+)
+
+TEMP_PATH = p.join(RUNNER_TEMP, "docker_images_check")
+BUCKETS = {"amd64": "package_release", "arm64": "package_aarch64"}
+
+
+class DelOS(argparse.Action):
+    def __call__(self, _, namespace, __, option_string=None):
+        no_build = self.dest[3:] if self.dest.startswith("no_") else self.dest
+        if no_build in namespace.os:
+            namespace.os.remove(no_build)
+
+
+def parse_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(
+        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
+        description="A program to build clickhouse-server image, both alpine and "
+        "ubuntu versions",
+    )
+
+    parser.add_argument(
+        "--version",
+        type=version_arg,
+        default=get_version_from_repo().string,
+        help="a version to build",
+    )
+    parser.add_argument(
+        "--release-type",
+        type=str,
+        choices=("auto", "latest", "major", "minor", "patch", "head"),
+        default="head",
+        help="version part that will be updated when '--version' is set; "
+        "'auto' is a special case, it will get versions from github and detect the "
+        "release type (latest, major, minor or patch) automatically",
+    )
+    parser.add_argument(
+        "--image-path",
+        type=str,
+        default="docker/server",
+        help="a path to docker context directory",
+    )
+    parser.add_argument(
+        "--image-repo",
+        type=str,
+        default="clickhouse/clickhouse-server",
+        help="image name on docker hub",
+    )
+    parser.add_argument(
+        "--bucket-prefix",
+        help="if set, then is used as source for deb and tgz files",
+    )
+    parser.add_argument("--reports", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-reports",
+        action="store_false",
+        dest="reports",
+        default=argparse.SUPPRESS,
+        help="don't push reports to S3 and github",
+    )
+    parser.add_argument("--push", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-push-images",
+        action="store_false",
+        dest="push",
+        default=argparse.SUPPRESS,
+        help="don't push images to docker hub",
+    )
+    parser.add_argument("--os", default=["ubuntu", "alpine"], help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-ubuntu",
+        action=DelOS,
+        nargs=0,
+        default=argparse.SUPPRESS,
+        help="don't build ubuntu image",
+    )
+    parser.add_argument(
+        "--no-alpine",
+        action=DelOS,
+        nargs=0,
+        default=argparse.SUPPRESS,
+        help="don't build alpine image",
+    )
+
+    return parser.parse_args()
+
+
+def version_arg(version: str) -> str:
+    try:
+        validate_version(version)
+        return version
+    except ValueError as e:
+        raise argparse.ArgumentTypeError(e)
+
+
+def auto_release_type(version: str, release_type: str) -> str:
+    if release_type != "auto":
+        return release_type
+    current_version = get_version_from_string(version)
+
+    git_versions = get_tagged_versions()
+    reference_version = git_versions[0]
+    for i in reversed(range(len(git_versions))):
+        if git_versions[i] < current_version:
+            if i == len(git_versions) - 1:
+                return "latest"
+            reference_version = git_versions[i + 1]
+            break
+
+    if current_version.major < reference_version.major:
+        return "major"
+    if current_version.minor < reference_version.minor:
+        return "minor"
+    if current_version.patch < reference_version.patch:
+        return "patch"
+
+    raise ValueError(
+        "Release type 'tweak' is not supported for "
+        f"{current_version.string} < {reference_version.string}"
+    )
+
+
+def gen_tags(version: str, release_type: str) -> List[str]:
+    """
+    22.2.2.2 + latest:
+    - latest
+    - 22
+    - 22.2
+    - 22.2.2
+    - 22.2.2.2
+    22.2.2.2 + major:
+    - 22
+    - 22.2
+    - 22.2.2
+    - 22.2.2.2
+    22.2.2.2 + minor:
+    - 22.2
+    - 22.2.2
+    - 22.2.2.2
+    22.2.2.2 + patch:
+    - 22.2.2
+    - 22.2.2.2
+    22.2.2.2 + head:
+    - head
+    """
+    validate_version(version)
+    parts = version.split(".")
+    tags = []
+    if release_type == "latest":
+        tags.append(release_type)
+        for i in range(len(parts)):
+            tags.append(".".join(parts[: i + 1]))
+    elif release_type == "major":
+        for i in range(len(parts)):
+            tags.append(".".join(parts[: i + 1]))
+    elif release_type == "minor":
+        for i in range(1, len(parts)):
+            tags.append(".".join(parts[: i + 1]))
+    elif release_type == "patch":
+        for i in range(2, len(parts)):
+            tags.append(".".join(parts[: i + 1]))
+    elif release_type == "head":
+        tags.append(release_type)
+    else:
+        raise ValueError(f"{release_type} is not valid release part")
+    return tags
+
+
+def buildx_args(bucket_prefix: str, arch: str) -> List[str]:
+    args = [f"--platform=linux/{arch}", f"--label=build-url={GITHUB_RUN_URL}"]
+    if bucket_prefix:
+        url = p.join(bucket_prefix, BUCKETS[arch])  # to prevent a double //
+        args.append(f"--build-arg=REPOSITORY='{url}'")
+        args.append(f"--build-arg=deb_location_url='{url}'")
+    return args
+
+
+def build_and_push_image(
+    image: DockerImage, push: bool, bucket_prefix: str, os: str, tag: str, version: str
+) -> List[Tuple[str, str]]:
+    result = []
+    if os != "ubuntu":
+        tag += f"-{os}"
+    init_args = ["docker", "buildx", "build"]
+    if push:
+        init_args.append("--push")
+        init_args.append("--output=type=image,push-by-digest=true")
+        init_args.append(f"--tag={image.repo}")
+    else:
+        init_args.append("--output=type=docker")
+
+    # `docker buildx build --load` does not support multiple images currently
+    # images must be built separately and merged together with `docker manifest`
+    digests = []
+    for arch in BUCKETS:
+        arch_tag = f"{tag}-{arch}"
+        metadata_path = p.join(TEMP_PATH, arch_tag)
+        dockerfile = p.join(image.full_path, f"Dockerfile.{os}")
+        cmd_args = list(init_args)
+        cmd_args.extend(buildx_args(bucket_prefix, arch))
+        if not push:
+            cmd_args.append(f"--tag={image.repo}:{arch_tag}")
+        cmd_args.extend(
+            [
+                f"--metadata-file={metadata_path}",
+                f"--build-arg=VERSION='{version}'",
+                "--progress=plain",
+                f"--file={dockerfile}",
+                image.full_path,
+            ]
+        )
+        cmd = " ".join(cmd_args)
+        logging.info("Building image %s:%s for arch %s: %s", image.repo, tag, arch, cmd)
+        with subprocess.Popen(
+            cmd,
+            shell=True,
+            stderr=subprocess.STDOUT,
+            stdout=subprocess.PIPE,
+            universal_newlines=True,
+        ) as process:
+            for line in process.stdout:  # type: ignore
+                print(line, end="")
+            retcode = process.wait()
+            if retcode != 0:
+                result.append((f"{image.repo}:{tag}-{arch}", "FAIL"))
+                return result
+            result.append((f"{image.repo}:{tag}-{arch}", "OK"))
+            with open(metadata_path, "rb") as m:
+                metadata = json.load(m)
+                digests.append(metadata["containerimage.digest"])
+    if push:
+        cmd = (
+            "docker buildx imagetools create "
+            f"--tag {image.repo}:{tag} {' '.join(digests)}"
+        )
+        logging.info("Pushing merged %s:%s image: %s", image.repo, tag, cmd)
+        with subprocess.Popen(
+            cmd,
+            shell=True,
+            stderr=subprocess.STDOUT,
+            stdout=subprocess.PIPE,
+            universal_newlines=True,
+        ) as process:
+            for line in process.stdout:  # type: ignore
+                print(line, end="")
+            retcode = process.wait()
+            if retcode != 0:
+                result.append((f"{image.repo}:{tag}", "FAIL"))
+    else:
+        logging.info(
+            "Merging is available only on push, separate %s images are created",
+            f"{image.repo}:{tag}-$arch",
+        )
+
+    return result
+
+
+def main():
+    logging.basicConfig(level=logging.INFO)
+    stopwatch = Stopwatch()
+    makedirs(TEMP_PATH, exist_ok=True)
+
+    args = parse_args()
+    image = DockerImage(args.image_path, args.image_repo, False)
+    args.release_type = auto_release_type(args.version, args.release_type)
+    tags = gen_tags(args.version, args.release_type)
+    NAME = f"Docker image {image.repo} building check (actions)"
+    pr_info = None
+    if CI:
+        pr_info = PRInfo()
+        args.bucket_prefix = (
+            f"https://s3.amazonaws.com/{S3_BUILDS_BUCKET}/"
+            f"{pr_info.number}/{pr_info.sha}"
+        )
+
+    if args.push:
+        subprocess.check_output(  # pylint: disable=unexpected-keyword-arg
+            "docker login --username 'robotclickhouse' --password-stdin",
+            input=get_parameter_from_ssm("dockerhub_robot_password"),
+            encoding="utf-8",
+            shell=True,
+        )
+        NAME = f"Docker image {image.repo} build and push (actions)"
+
+    logging.info("Following tags will be created: %s", ", ".join(tags))
+    status = "success"
+    test_results = []  # type: List[Tuple[str, str]]
+    for os in args.os:
+        for tag in tags:
+            test_results.extend(
+                build_and_push_image(
+                    image, args.push, args.bucket_prefix, os, tag, args.version
+                )
+            )
+            if test_results[-1][1] != "OK":
+                status = "failure"
+
+    pr_info = pr_info or PRInfo()
+    s3_helper = S3Helper("https://s3.amazonaws.com")
+
+    url = upload_results(s3_helper, pr_info.number, pr_info.sha, test_results, [], NAME)
+
+    print(f"::notice ::Report url: {url}")
+    print(f'::set-output name=url_output::"{url}"')
+
+    if not args.reports:
+        return
+
+    description = f"Processed tags: {', '.join(tags)}"
+
+    if len(description) >= 140:
+        description = description[:136] + "..."
+
+    gh = Github(get_best_robot_token())
+    post_commit_status(gh, pr_info.sha, NAME, description, status, url)
+
+    prepared_events = prepare_tests_results_for_clickhouse(
+        pr_info,
+        test_results,
+        status,
+        stopwatch.duration_seconds,
+        stopwatch.start_time_str,
+        url,
+        NAME,
+    )
+    ch_helper = ClickHouseHelper()
+    ch_helper.insert_events_into(db="default", table="checks", events=prepared_events)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/ci/docker_test.py b/tests/ci/docker_test.py
index 2b864b6b94c6..e2dc8874a7ae 100644
--- a/tests/ci/docker_test.py
+++ b/tests/ci/docker_test.py
@@ -2,12 +2,16 @@
 
 import os
 import unittest
-from unittest.mock import patch
+from unittest.mock import patch, MagicMock
 
 from env_helper import GITHUB_RUN_URL
 from pr_info import PRInfo
 import docker_images_check as di
 
+with patch("git_helper.Git"):
+    from version_helper import get_version_from_string, get_tagged_versions
+    import docker_server as ds
+
 # di.logging.basicConfig(level=di.logging.INFO)
 
 
@@ -221,5 +225,45 @@ def test_process_image_with_parents(self, mock_build):
         self.assertEqual(results, expected)
 
 
+class TestDockerServer(unittest.TestCase):
+    def test_gen_tags(self):
+        cases = (
+            (("22.2.2.2", "latest"), ["latest", "22", "22.2", "22.2.2", "22.2.2.2"]),
+            (("22.2.2.2", "major"), ["22", "22.2", "22.2.2", "22.2.2.2"]),
+            (("22.2.2.2", "minor"), ["22.2", "22.2.2", "22.2.2.2"]),
+            (("22.2.2.2", "patch"), ["22.2.2", "22.2.2.2"]),
+            (("22.2.2.2", "head"), ["head"]),
+        )
+        for case in cases:
+            version, release_type = case[0]
+            self.assertEqual(case[1], ds.gen_tags(version, release_type))
+
+        with self.assertRaises(ValueError):
+            ds.gen_tags("22.2.2.2", "auto")
+
+    @patch("docker_server.get_tagged_versions")
+    def test_auto_release_type(self, mock_tagged_versions: MagicMock):
+        mock_tagged_versions.return_value = [
+            get_version_from_string("1.1.1.1"),
+            get_version_from_string("1.2.1.1"),
+            get_version_from_string("2.1.1.1"),
+            get_version_from_string("2.2.1.1"),
+            get_version_from_string("2.2.2.1"),
+        ]
+        cases = (
+            ("1.0.1.1", "minor"),
+            ("1.1.2.1", "minor"),
+            ("1.3.1.1", "major"),
+            ("2.1.2.1", "minor"),
+            ("2.2.1.3", "patch"),
+            ("2.2.3.1", "latest"),
+            ("2.3.1.1", "latest"),
+        )
+        _ = get_tagged_versions()
+        for case in cases:
+            release = ds.auto_release_type(case[0], "auto")
+            self.assertEqual(case[1], release)
+
+
 if __name__ == "__main__":
     unittest.main()
diff --git a/tests/ci/env_helper.py b/tests/ci/env_helper.py
index c34162ba51ad..242d6bf5e409 100644
--- a/tests/ci/env_helper.py
+++ b/tests/ci/env_helper.py
@@ -1,7 +1,11 @@
 import os
+from os import path as p
+
+module_dir = p.abspath(p.dirname(__file__))
+git_root = p.abspath(p.join(module_dir, "..", ".."))
 
 CI = bool(os.getenv("CI"))
-TEMP_PATH = os.getenv("TEMP_PATH", os.path.abspath("."))
+TEMP_PATH = os.getenv("TEMP_PATH", module_dir)
 
 CACHES_PATH = os.getenv("CACHES_PATH", TEMP_PATH)
 CLOUDFLARE_TOKEN = os.getenv("CLOUDFLARE_TOKEN")
@@ -9,11 +13,11 @@
 GITHUB_REPOSITORY = os.getenv("GITHUB_REPOSITORY", "ClickHouse/ClickHouse")
 GITHUB_RUN_ID = os.getenv("GITHUB_RUN_ID", "0")
 GITHUB_SERVER_URL = os.getenv("GITHUB_SERVER_URL", "https://github.com")
-GITHUB_WORKSPACE = os.getenv("GITHUB_WORKSPACE", os.path.abspath("../../"))
+GITHUB_WORKSPACE = os.getenv("GITHUB_WORKSPACE", git_root)
 GITHUB_RUN_URL = f"{GITHUB_SERVER_URL}/{GITHUB_REPOSITORY}/actions/runs/{GITHUB_RUN_ID}"
 IMAGES_PATH = os.getenv("IMAGES_PATH")
-REPORTS_PATH = os.getenv("REPORTS_PATH", "./reports")
-REPO_COPY = os.getenv("REPO_COPY", os.path.abspath("../../"))
-RUNNER_TEMP = os.getenv("RUNNER_TEMP", os.path.abspath("./tmp"))
+REPORTS_PATH = os.getenv("REPORTS_PATH", p.abspath(p.join(module_dir, "./reports")))
+REPO_COPY = os.getenv("REPO_COPY", git_root)
+RUNNER_TEMP = os.getenv("RUNNER_TEMP", p.abspath(p.join(module_dir, "./tmp")))
 S3_BUILDS_BUCKET = os.getenv("S3_BUILDS_BUCKET", "clickhouse-builds")
 S3_TEST_REPORTS_BUCKET = os.getenv("S3_TEST_REPORTS_BUCKET", "clickhouse-test-reports")
diff --git a/tests/ci/git_helper.py b/tests/ci/git_helper.py
index 2d28c6930877..5c02ea53cf89 100644
--- a/tests/ci/git_helper.py
+++ b/tests/ci/git_helper.py
@@ -3,7 +3,7 @@
 import os.path as p
 import re
 import subprocess
-from typing import Optional
+from typing import List, Optional
 
 # ^ and $ match subline in `multiple
lines`
 # \A and \Z match only start and end of the whole string
@@ -89,7 +89,7 @@ def update(self):
             self.run(f"git rev-list {self.latest_tag}..HEAD --count")
         )
 
-    def _check_tag(self, value: str):
+    def check_tag(self, value: str):
         if value == "":
             return
         if not self._tag_pattern.match(value):
@@ -101,7 +101,7 @@ def latest_tag(self) -> str:
 
     @latest_tag.setter
     def latest_tag(self, value: str):
-        self._check_tag(value)
+        self.check_tag(value)
         self._latest_tag = value
 
     @property
@@ -110,7 +110,7 @@ def new_tag(self) -> str:
 
     @new_tag.setter
     def new_tag(self, value: str):
-        self._check_tag(value)
+        self.check_tag(value)
         self._new_tag = value
 
     @property
@@ -122,3 +122,6 @@ def tweak(self) -> int:
 
         version = self.latest_tag.split("-", maxsplit=1)[0]
         return int(version.split(".")[-1]) + self.commits_since_tag
+
+    def get_tags(self) -> List[str]:
+        return self.run("git tag").split()
diff --git a/tests/ci/version_helper.py b/tests/ci/version_helper.py
index 3bb547333e7f..7db96cfde7cf 100755
--- a/tests/ci/version_helper.py
+++ b/tests/ci/version_helper.py
@@ -1,10 +1,8 @@
 #!/usr/bin/env python3
-import datetime
 import logging
 import os.path as p
-import subprocess
 from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
-from typing import Dict, Tuple, Union
+from typing import Dict, List, Tuple, Union
 
 from git_helper import Git, removeprefix
 
@@ -49,12 +47,16 @@ def __init__(
         patch: Union[int, str],
         revision: Union[int, str],
         git: Git,
+        tweak: str = None,
     ):
         self._major = int(major)
         self._minor = int(minor)
         self._patch = int(patch)
         self._revision = int(revision)
         self._git = git
+        self._tweak = None
+        if tweak is not None:
+            self._tweak = int(tweak)
         self._describe = ""
 
     def update(self, part: str) -> "ClickHouseVersion":
@@ -89,7 +91,7 @@ def patch(self) -> int:
 
     @property
     def tweak(self) -> int:
-        return self._git.tweak
+        return self._tweak or self._git.tweak
 
     @property
     def revision(self) -> int:
@@ -129,6 +131,25 @@ def with_description(self, version_type):
             raise ValueError(f"version type {version_type} not in {VersionType.VALID}")
         self._describe = f"v{self.string}-{version_type}"
 
+    def __eq__(self, other) -> bool:
+        if not isinstance(self, type(other)):
+            return NotImplemented
+        return (
+            self.major == other.major
+            and self.minor == other.minor
+            and self.patch == other.patch
+            and self.tweak == other.tweak
+        )
+
+    def __lt__(self, other: "ClickHouseVersion") -> bool:
+        for part in ("major", "minor", "patch", "tweak"):
+            if getattr(self, part) < getattr(other, part):
+                return True
+            elif getattr(self, part) > getattr(other, part):
+                return False
+
+        return False
+
 
 class VersionType:
     LTS = "lts"
@@ -138,6 +159,14 @@ class VersionType:
     VALID = (TESTING, PRESTABLE, STABLE, LTS)
 
 
+def validate_version(version: str):
+    parts = version.split(".")
+    if len(parts) != 4:
+        raise ValueError(f"{version} does not contain 4 parts")
+    for part in parts:
+        int(part)
+
+
 def get_abs_path(path: str) -> str:
     return p.abspath(p.join(git.root, path))
 
@@ -176,6 +205,29 @@ def get_version_from_repo(
     )
 
 
+def get_version_from_string(version: str) -> ClickHouseVersion:
+    validate_version(version)
+    parts = version.split(".")
+    return ClickHouseVersion(parts[0], parts[1], parts[2], -1, git, parts[3])
+
+
+def get_version_from_tag(tag: str) -> ClickHouseVersion:
+    git.check_tag(tag)
+    tag = tag[1:].split("-")[0]
+    return get_version_from_string(tag)
+
+
+def get_tagged_versions() -> List[ClickHouseVersion]:
+    versions = []
+    for tag in git.get_tags():
+        try:
+            version = get_version_from_tag(tag)
+            versions.append(version)
+        except Exception:
+            continue
+    return sorted(versions)
+
+
 def update_cmake_version(
     version: ClickHouseVersion,
     versions_path: str = FILE_WITH_VERSION_PATH,
@@ -185,22 +237,6 @@ def update_cmake_version(
         f.write(VERSIONS_TEMPLATE.format_map(version.as_dict()))
 
 
-def _update_changelog(repo_path: str, version: ClickHouseVersion):
-    cmd = """sed \
-        -e "s/[@]VERSION_STRING[@]/{version_str}/g" \
-        -e "s/[@]DATE[@]/{date}/g" \
-        -e "s/[@]AUTHOR[@]/clickhouse-release/g" \
-        -e "s/[@]EMAIL[@]/clickhouse-release@yandex-team.ru/g" \
-        < {in_path} > {changelog_path}
-    """.format(
-        version_str=version.string,
-        date=datetime.datetime.now().strftime("%a, %d %b %Y %H:%M:%S") + " +0300",
-        in_path=p.join(repo_path, CHANGELOG_IN_PATH),
-        changelog_path=p.join(repo_path, CHANGELOG_PATH),
-    )
-    subprocess.check_call(cmd, shell=True)
-
-
 def update_contributors(
     relative_contributors_path: str = GENERATED_CONTRIBUTORS, force: bool = False
 ):
@@ -225,22 +261,10 @@ def update_contributors(
         cfd.write(content)
 
 
-def _update_dockerfile(repo_path: str, version: ClickHouseVersion):
-    version_str_for_docker = ".".join(
-        [str(version.major), str(version.minor), str(version.patch), "*"]
-    )
-    cmd = "ls -1 {path}/docker/*/Dockerfile | xargs sed -i -r -e 's/ARG version=.+$/ARG version='{ver}'/'".format(
-        path=repo_path, ver=version_str_for_docker
-    )
-    subprocess.check_call(cmd, shell=True)
-
-
-def update_version_local(repo_path, version, version_type="testing"):
+def update_version_local(version, version_type="testing"):
     update_contributors()
     version.with_description(version_type)
     update_cmake_version(version)
-    _update_changelog(repo_path, version)
-    _update_dockerfile(repo_path, version)
 
 
 def main():
