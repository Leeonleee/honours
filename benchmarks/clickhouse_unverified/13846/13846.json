{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13846,
  "instance_id": "ClickHouse__ClickHouse-13846",
  "issue_numbers": [
    "13630"
  ],
  "base_commit": "f0a65522cc04f7f64e5e19dc05157149795a216d",
  "patch": "diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 381148de04ba..522149d3cfd7 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -390,6 +390,7 @@ void registerOutputFormatProcessorPostgreSQLWire(FormatFactory & factory);\n \n void registerInputFormatProcessorRegexp(FormatFactory & factory);\n void registerInputFormatProcessorJSONAsString(FormatFactory & factory);\n+void registerInputFormatProcessorLineAsString(FormatFactory & factory);\n void registerInputFormatProcessorCapnProto(FormatFactory & factory);\n \n FormatFactory::FormatFactory()\n@@ -454,6 +455,7 @@ FormatFactory::FormatFactory()\n \n     registerInputFormatProcessorRegexp(*this);\n     registerInputFormatProcessorJSONAsString(*this);\n+    registerInputFormatProcessorLineAsString(*this);\n #if !defined(ARCADIA_BUILD)\n     registerInputFormatProcessorCapnProto(*this);\n #endif\ndiff --git a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\nnew file mode 100644\nindex 000000000000..27bc71d764dc\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\n@@ -0,0 +1,88 @@\n+#include <Processors/Formats/Impl/LineAsStringRowInputFormat.h>\n+#include <Formats/JSONEachRowUtils.h>\n+#include <common/find_symbols.h>\n+#include <IO/ReadHelpers.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int INCORRECT_DATA;\n+}\n+\n+LineAsStringRowInputFormat::LineAsStringRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_) :\n+    IRowInputFormat(header_, in_, std::move(params_)), buf(in)\n+{\n+    if (header_.columns() > 1 || header_.getDataTypes()[0]->getTypeId() != TypeIndex::String)\n+    {\n+        throw Exception(\"This input format is only suitable for tables with a single column of type String.\", ErrorCodes::LOGICAL_ERROR);\n+    }\n+}\n+\n+void LineAsStringRowInputFormat::resetParser()\n+{\n+    IRowInputFormat::resetParser();\n+    buf.reset();\n+}\n+\n+void LineAsStringRowInputFormat::readLineObject(IColumn & column)\n+{\n+    PeekableReadBufferCheckpoint checkpoint{buf};\n+    bool newline = true;\n+    bool over = false;\n+\n+    char * pos;\n+\n+    while (newline)\n+    {\n+        pos = find_first_symbols<'\\n', '\\\\'>(buf.position(), buf.buffer().end());\n+        buf.position() = pos;\n+        if (buf.position() == buf.buffer().end())  {\n+            over = true;\n+            break;\n+        }\n+        else if (*buf.position() == '\\n')\n+        {\n+            newline = false;\n+        }\n+        else if (*buf.position() == '\\\\')\n+            {\n+            ++buf.position();\n+            if (!buf.eof())\n+            {\n+            \t++buf.position();\n+            }\n+        }\n+        \n+    }\n+\n+    buf.makeContinuousMemoryFromCheckpointToPos();\n+    char * end = over ? buf.position(): ++buf.position();\n+    buf.rollbackToCheckpoint();\n+    column.insertData(buf.position(), end - (over ? 0 : 1) - buf.position());\n+    buf.position() = end;\n+}\n+\n+bool LineAsStringRowInputFormat::readRow(MutableColumns & columns, RowReadExtension &)\n+{\n+    if (!buf.eof())\n+        readLineObject(*columns[0]);\n+\n+    return !buf.eof();\n+}\n+\n+void registerInputFormatProcessorLineAsString(FormatFactory & factory)\n+{\n+    factory.registerInputFormatProcessor(\"LineAsString\", [](\n+            ReadBuffer & buf,\n+            const Block & sample,\n+            const RowInputFormatParams & params,\n+            const FormatSettings &)\n+    {\n+        return std::make_shared<LineAsStringRowInputFormat>(sample, buf, params);\n+    });\n+}\n+\n+}\ndiff --git a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.h b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.h\nnew file mode 100644\nindex 000000000000..a31dce1cc4a3\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <Processors/Formats/IRowInputFormat.h>\n+#include <Formats/FormatFactory.h>\n+#include <IO/PeekableReadBuffer.h>\n+\n+namespace DB\n+{\n+\n+class ReadBuffer;\n+\n+/// This format parses a sequence of Line objects separated by newlines, spaces and/or comma.\n+/// Each Line object is parsed as a whole to string.\n+/// This format can only parse a table with single field of type String.\n+\n+class LineAsStringRowInputFormat : public IRowInputFormat\n+{\n+public:\n+    LineAsStringRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_);\n+\n+    bool readRow(MutableColumns & columns, RowReadExtension & ext) override;\n+    String getName() const override { return \"LineAsStringRowInputFormat\"; }\n+    void resetParser() override;\n+\n+private:\n+    void readLineObject(IColumn & column);\n+\n+    PeekableReadBuffer buf;\n+};\n+\n+}\ndiff --git a/src/Processors/ya.make b/src/Processors/ya.make\nindex b767350427a5..8fe4e651ade6 100644\n--- a/src/Processors/ya.make\n+++ b/src/Processors/ya.make\n@@ -25,6 +25,7 @@ SRCS(\n     Formats/Impl/ConstantExpressionTemplate.cpp\n     Formats/Impl/CSVRowInputFormat.cpp\n     Formats/Impl/CSVRowOutputFormat.cpp\n+    Formats/Impl/LineAsStringRowInputFormat.cpp\n     Formats/Impl/JSONAsStringRowInputFormat.cpp\n     Formats/Impl/JSONCompactEachRowRowInputFormat.cpp\n     Formats/Impl/JSONCompactEachRowRowOutputFormat.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01460_line_as_string_format.reference b/tests/queries/0_stateless/01460_line_as_string_format.reference\nnew file mode 100644\nindex 000000000000..dec67eb2e0a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01460_line_as_string_format.reference\n@@ -0,0 +1,6 @@\n+\"id\" : 1,\n+\"date\" : \"01.01.2020\",\n+\"string\" : \"123{{{\\\\\"\\\\\\\\\",\n+\"array\" : [1, 2, 3],\n+\n+Finally implement this new feature.\ndiff --git a/tests/queries/0_stateless/01460_line_as_string_format.sh b/tests/queries/0_stateless/01460_line_as_string_format.sh\nnew file mode 100755\nindex 000000000000..a985bc207a81\n--- /dev/null\n+++ b/tests/queries/0_stateless/01460_line_as_string_format.sh\n@@ -0,0 +1,19 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS line_as_string\";\n+\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE line_as_string(field String) ENGINE = Memory\";\n+\n+echo '\"id\" : 1,\n+\"date\" : \"01.01.2020\",\n+\"string\" : \"123{{{\\\"\\\\\",\n+\"array\" : [1, 2, 3],\n+\n+Finally implement this new feature.' | $CLICKHOUSE_CLIENT --query=\"INSERT INTO line_as_string FORMAT LineAsString\";\n+\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM line_as_string\";\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE line_as_string\"\n+\n",
  "problem_statement": "LineAsString format.\nTreat every line of input as a single String field.\r\nSimilar to `JSONAsString`.\n",
  "hints_text": "Hi! I've finished this feature. It currently works as following:\r\n\r\n```\r\nDROP TABLE IF EXISTS line_as_string;\r\nCREATE TABLE line_as_string (field String) ENGINE = Memory;\r\nINSERT INTO line_as_string FORMAT LineAsString \"I love apple\", \"I love banana\", \"I love orange\";\r\n\r\nselect * from line_as_string shows:\r\n\u250c\u2500field\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 I love apple     \u2502\r\n\u2502 I love banana    \u2502\r\n\u2502 I love orange    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nDoes this accomplish the need?\n@hexiaoting It should output:\r\n```\r\n\u250c\u2500field\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 \"I love apple\", \"I love banana\", \"I love orange\" \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSo, it interprets every line of input data as single value.",
  "created_at": "2020-08-18T02:56:23Z",
  "modified_files": [
    "src/Formats/FormatFactory.cpp",
    "b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp",
    "b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.h",
    "src/Processors/ya.make"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01460_line_as_string_format.reference",
    "b/tests/queries/0_stateless/01460_line_as_string_format.sh"
  ]
}