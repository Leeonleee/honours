diff --git a/base/common/DecomposedFloat.h b/base/common/DecomposedFloat.h
index 078ba823c153..21034908fe7b 100644
--- a/base/common/DecomposedFloat.h
+++ b/base/common/DecomposedFloat.h
@@ -91,10 +91,12 @@ struct DecomposedFloat
 
 
     /// Compare float with integer of arbitrary width (both signed and unsigned are supported). Assuming two's complement arithmetic.
+    /// This function is generic, big integers (128, 256 bit) are supported as well.
     /// Infinities are compared correctly. NaNs are treat similarly to infinities, so they can be less than all numbers.
     /// (note that we need total order)
+    /// Returns -1, 0 or 1.
     template <typename Int>
-    int compare(Int rhs)
+    int compare(Int rhs) const
     {
         if (rhs == 0)
             return sign();
@@ -137,10 +139,11 @@ struct DecomposedFloat
         if (normalized_exponent() >= static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))
             return is_negative() ? -1 : 1;
 
-        using UInt = make_unsigned_t<Int>;
+        using UInt = std::conditional_t<(sizeof(Int) > sizeof(typename Traits::UInt)), make_unsigned_t<Int>, typename Traits::UInt>;
         UInt uint_rhs = rhs < 0 ? -rhs : rhs;
 
         /// Smaller octave: abs(rhs) < abs(float)
+        /// FYI, TIL: octave is also called "binade", https://en.wikipedia.org/wiki/Binade
         if (uint_rhs < (static_cast<UInt>(1) << normalized_exponent()))
             return is_negative() ? -1 : 1;
 
@@ -154,11 +157,11 @@ struct DecomposedFloat
 
         bool large_and_always_integer = normalized_exponent() >= static_cast<int16_t>(Traits::mantissa_bits);
 
-        typename Traits::UInt a = large_and_always_integer
-            ? mantissa() << (normalized_exponent() - Traits::mantissa_bits)
-            : mantissa() >> (Traits::mantissa_bits - normalized_exponent());
+        UInt a = large_and_always_integer
+            ? static_cast<UInt>(mantissa()) << (normalized_exponent() - Traits::mantissa_bits)
+            : static_cast<UInt>(mantissa()) >> (Traits::mantissa_bits - normalized_exponent());
 
-        typename Traits::UInt b = uint_rhs - (static_cast<UInt>(1) << normalized_exponent());
+        UInt b = uint_rhs - (static_cast<UInt>(1) << normalized_exponent());
 
         if (a < b)
             return is_negative() ? 1 : -1;
@@ -175,37 +178,37 @@ struct DecomposedFloat
 
 
     template <typename Int>
-    bool equals(Int rhs)
+    bool equals(Int rhs) const
     {
         return compare(rhs) == 0;
     }
 
     template <typename Int>
-    bool notEquals(Int rhs)
+    bool notEquals(Int rhs) const
     {
         return compare(rhs) != 0;
     }
 
     template <typename Int>
-    bool less(Int rhs)
+    bool less(Int rhs) const
     {
         return compare(rhs) < 0;
     }
 
     template <typename Int>
-    bool greater(Int rhs)
+    bool greater(Int rhs) const
     {
         return compare(rhs) > 0;
     }
 
     template <typename Int>
-    bool lessOrEquals(Int rhs)
+    bool lessOrEquals(Int rhs) const
     {
         return compare(rhs) <= 0;
     }
 
     template <typename Int>
-    bool greaterOrEquals(Int rhs)
+    bool greaterOrEquals(Int rhs) const
     {
         return compare(rhs) >= 0;
     }
diff --git a/base/common/wide_integer.h b/base/common/wide_integer.h
index 419b4e4558c6..de3496337232 100644
--- a/base/common/wide_integer.h
+++ b/base/common/wide_integer.h
@@ -109,10 +109,7 @@ class integer
 
     constexpr explicit operator bool() const noexcept;
 
-    template <class T>
-    using _integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;
-
-    template <class T, class = _integral_not_wide_integer_class<T>>
+    template <typename T, typename = std::enable_if_t<std::is_arithmetic_v<T>, T>>
     constexpr operator T() const noexcept;
 
     constexpr operator long double() const noexcept;
diff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h
index 725caec6a3ef..d2ef8b22d65a 100644
--- a/base/common/wide_integer_impl.h
+++ b/base/common/wide_integer_impl.h
@@ -255,13 +255,13 @@ struct integer<Bits, Signed>::_impl
             set_multiplier<double>(self, alpha);
 
         self *= max_int;
-        self += static_cast<uint64_t>(t - alpha * static_cast<T>(max_int)); // += b_i
+        self += static_cast<uint64_t>(t - floor(alpha) * static_cast<T>(max_int)); // += b_i
     }
 
-    constexpr static void wide_integer_from_builtin(integer<Bits, Signed>& self, double rhs) noexcept
+    constexpr static void wide_integer_from_builtin(integer<Bits, Signed> & self, double rhs) noexcept
     {
         constexpr int64_t max_int = std::numeric_limits<int64_t>::max();
-        constexpr int64_t min_int = std::numeric_limits<int64_t>::min();
+        constexpr int64_t min_int = std::numeric_limits<int64_t>::lowest();
 
         /// There are values in int64 that have more than 53 significant bits (in terms of double
         /// representation). Such values, being promoted to double, are rounded up or down. If they are rounded up,
@@ -271,14 +271,14 @@ struct integer<Bits, Signed>::_impl
         /// The necessary check here is that long double has enough significant (mantissa) bits to store the
         /// int64_t max value precisely.
 
-        //TODO Be compatible with Apple aarch64
+        // TODO Be compatible with Apple aarch64
 #if not (defined(__APPLE__) && defined(__aarch64__))
         static_assert(LDBL_MANT_DIG >= 64,
-            "On your system long double has less than 64 precision bits,"
+            "On your system long double has less than 64 precision bits, "
             "which may result in UB when initializing double from int64_t");
 #endif
 
-        if ((rhs > 0 && rhs < static_cast<long double>(max_int)) || (rhs < 0 && rhs > static_cast<long double>(min_int)))
+        if (rhs > static_cast<long double>(min_int) && rhs < static_cast<long double>(max_int))
         {
             self = static_cast<int64_t>(rhs);
             return;
