{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11733,
  "instance_id": "ClickHouse__ClickHouse-11733",
  "issue_numbers": [
    "7119"
  ],
  "base_commit": "7011401cd4eaf594fb463dd4c81e0c7927d44787",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex bba258f1d60c..a4269b929079 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -379,6 +379,7 @@ struct Settings : public SettingsCollection<Settings>\n     \\\n     M(SettingBool, allow_experimental_geo_types, false, \"Allow geo data types such as Point, Ring, Polygon, MultiPolygon\", 0) \\\n     M(SettingBool, data_type_default_nullable, false, \"Data types without NULL or NOT NULL will make Nullable\", 0) \\\n+    M(SettingBool, cast_keep_nullable, false, \"CAST operator keep Nullable for result data type\", 0) \\\n     \\\n     /** Obsolete settings that do nothing but left for compatibility reasons. Remove each one after half a year of obsolescence. */ \\\n     \\\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex 0bd7d1a27e83..bbde6e040698 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -1,10 +1,16 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsConversion.h>\n+#include <Interpreters/Context.h>\n \n \n namespace DB\n {\n \n+FunctionOverloadResolverImplPtr CastOverloadResolver::create(const Context & context)\n+{\n+    return createImpl(context.getSettingsRef().cast_keep_nullable);\n+}\n+\n void registerFunctionsConversion(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionToUInt8>();\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 83417a3229b1..b23cac8c456c 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -2377,10 +2377,13 @@ class CastOverloadResolver : public IFunctionOverloadResolverImpl\n     using MonotonicityForRange = FunctionCast::MonotonicityForRange;\n \n     static constexpr auto name = \"CAST\";\n-    static FunctionOverloadResolverImplPtr create(const Context &) { return createImpl(); }\n-    static FunctionOverloadResolverImplPtr createImpl() { return std::make_unique<CastOverloadResolver>(); }\n \n-    CastOverloadResolver() {}\n+    static FunctionOverloadResolverImplPtr create(const Context & context);\n+    static FunctionOverloadResolverImplPtr createImpl(bool keep_nullable) { return std::make_unique<CastOverloadResolver>(keep_nullable); }\n+\n+    CastOverloadResolver(bool keep_nullable_)\n+        : keep_nullable(keep_nullable_)\n+    {}\n \n     String getName() const override { return name; }\n \n@@ -2415,13 +2418,18 @@ class CastOverloadResolver : public IFunctionOverloadResolverImpl\n                 \" Instead there is a column with the following structure: \" + column->dumpStructure(),\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        return DataTypeFactory::instance().get(type_col->getValue<String>());\n+        DataTypePtr type = DataTypeFactory::instance().get(type_col->getValue<String>());\n+        if (keep_nullable && arguments.front().type->isNullable())\n+            return makeNullable(type);\n+        return type;\n     }\n \n     bool useDefaultImplementationForNulls() const override { return false; }\n     bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n \n private:\n+    bool keep_nullable;\n+\n     template <typename DataType>\n     static auto monotonicityForType(const DataType * const)\n     {\ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex 02c3d938d2b7..c272dc98505c 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -693,11 +693,12 @@ class FunctionIf : public FunctionIfBase</*null_is_false=*/false>\n \n     static ColumnPtr makeNullableColumnIfNot(const ColumnPtr & column)\n     {\n-        if (isColumnNullable(*column))\n-            return column;\n+        auto materialized = materializeColumnIfConst(column);\n \n-        return ColumnNullable::create(\n-            materializeColumnIfConst(column), ColumnUInt8::create(column->size(), 0));\n+        if (isColumnNullable(*materialized))\n+            return materialized;\n+\n+        return ColumnNullable::create(materialized, ColumnUInt8::create(column->size(), 0));\n     }\n \n     static ColumnPtr getNestedColumn(const ColumnPtr & column)\ndiff --git a/src/Interpreters/castColumn.cpp b/src/Interpreters/castColumn.cpp\nindex 2e6604f7df5e..756ccbc6d7ec 100644\n--- a/src/Interpreters/castColumn.cpp\n+++ b/src/Interpreters/castColumn.cpp\n@@ -29,7 +29,8 @@ ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type\n         }\n     };\n \n-    FunctionOverloadResolverPtr func_builder_cast = std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver::createImpl());\n+    FunctionOverloadResolverPtr func_builder_cast =\n+        std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver::createImpl(false));\n \n     ColumnsWithTypeAndName arguments{ temporary_block.getByPosition(0), temporary_block.getByPosition(1) };\n     auto func_cast = func_builder_cast->build(arguments);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01322_cast_keep_nullable.reference b/tests/queries/0_stateless/01322_cast_keep_nullable.reference\nnew file mode 100644\nindex 000000000000..8ad99a101709\n--- /dev/null\n+++ b/tests/queries/0_stateless/01322_cast_keep_nullable.reference\n@@ -0,0 +1,10 @@\n+0\tInt32\n+0\tInt32\n+1\tNullable(Int32)\n+1\tNullable(Int32)\n+2\tNullable(Float32)\n+2\tNullable(UInt8)\n+3\tNullable(Int32)\n+\\N\tNullable(Int32)\n+42\tNullable(Int32)\n+\\N\tNullable(Int32)\ndiff --git a/tests/queries/0_stateless/01322_cast_keep_nullable.sql b/tests/queries/0_stateless/01322_cast_keep_nullable.sql\nnew file mode 100644\nindex 000000000000..109187174693\n--- /dev/null\n+++ b/tests/queries/0_stateless/01322_cast_keep_nullable.sql\n@@ -0,0 +1,19 @@\n+SET cast_keep_nullable = 0;\n+\n+SELECT CAST(toNullable(toInt32(0)) AS Int32) as x, toTypeName(x);\n+SELECT CAST(toNullable(toInt8(0)) AS Int32) as x, toTypeName(x);\n+\n+SET cast_keep_nullable = 1;\n+\n+SELECT CAST(toNullable(toInt32(1)) AS Int32) as x, toTypeName(x);\n+SELECT CAST(toNullable(toInt8(1)) AS Int32) as x, toTypeName(x);\n+\n+SELECT CAST(toNullable(toFloat32(2)), 'Float32') as x, toTypeName(x);\n+SELECT CAST(toNullable(toFloat32(2)), 'UInt8') as x, toTypeName(x);\n+SELECT CAST(toNullable(toFloat32(2)), 'UUID') as x, toTypeName(x); -- { serverError 70 }\n+\n+SELECT CAST(if(1 = 1, toNullable(toInt8(3)), NULL) AS Int32) as x, toTypeName(x);\n+SELECT CAST(if(1 = 0, toNullable(toInt8(3)), NULL) AS Int32) as x, toTypeName(x);\n+\n+SELECT CAST(a, 'Int32') as x, toTypeName(x) FROM (SELECT materialize(CAST(42, 'Nullable(UInt8)')) AS a);\n+SELECT CAST(a, 'Int32') as x, toTypeName(x) FROM (SELECT materialize(CAST(NULL, 'Nullable(UInt8)')) AS a);\n",
  "problem_statement": "Compatibility of CAST operator.\n**Use case**\r\nCAST in ClickHouse work in different way than in other DBMS.\r\n\r\n1. Nullable is the part of data type. When you cast Nullable(UInt8) to String, you will get String.\r\nIn other databases nullability is kept with CAST.\r\n\r\n2. You can specify \"conversion instruction\" instead of a type name inside CAST.\r\nExample: `CAST(x AS UNSIGNED)` will cast Int8 to UInt8, Int16 to UInt16 and so on.\r\n\r\n**Describe the solution you'd like**\r\n1. Implement `cast_keep_nullable` setting.\r\n2. Add a notion of named conversion instructions.\n",
  "hints_text": "@Potya",
  "created_at": "2020-06-17T14:23:48Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Functions/FunctionsConversion.cpp",
    "src/Functions/FunctionsConversion.h",
    "src/Functions/if.cpp",
    "src/Interpreters/castColumn.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01322_cast_keep_nullable.reference",
    "b/tests/queries/0_stateless/01322_cast_keep_nullable.sql"
  ]
}