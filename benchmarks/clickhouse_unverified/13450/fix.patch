diff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp
index 6e957aee67b8..c826d83a0816 100644
--- a/src/Interpreters/DDLWorker.cpp
+++ b/src/Interpreters/DDLWorker.cpp
@@ -863,45 +863,53 @@ bool DDLWorker::tryExecuteQueryOnLeaderReplica(
     String shard_node_name = get_shard_name(task.cluster->getShardsAddresses().at(task.host_shard_num));
     String shard_path = node_path + "/shards/" + shard_node_name;
     String is_executed_path = shard_path + "/executed";
+    String tries_to_execute_path = shard_path + "/tries_to_execute";
     zookeeper->createAncestors(shard_path + "/");
 
-    auto is_already_executed = [&]() -> bool
-    {
-        String executed_by;
-        if (zookeeper->tryGet(is_executed_path, executed_by))
-        {
-            LOG_DEBUG(log, "Task {} has already been executed by leader replica ({}) of the same shard.", task.entry_name, executed_by);
-            return true;
-        }
+    /// Node exists, or we will create or we will get an exception
+    zookeeper->tryCreate(tries_to_execute_path, "0", zkutil::CreateMode::Persistent);
 
-        return false;
-    };
+    static constexpr int MAX_TRIES_TO_EXECUTE = 3;
+
+    String executed_by;
+
+    zkutil::EventPtr event = std::make_shared<Poco::Event>();
+    if (zookeeper->tryGet(is_executed_path, executed_by))
+    {
+        LOG_DEBUG(log, "Task {} has already been executed by replica ({}) of the same shard.", task.entry_name, executed_by);
+        return true;
+    }
 
     pcg64 rng(randomSeed());
 
     auto lock = createSimpleZooKeeperLock(zookeeper, shard_path, "lock", task.host_id_str);
-    static const size_t max_tries = 20;
+
     bool executed_by_leader = false;
-    for (size_t num_tries = 0; num_tries < max_tries; ++num_tries)
+    while (true)
     {
-        if (is_already_executed())
-        {
-            executed_by_leader = true;
-            break;
-        }
-
         StorageReplicatedMergeTree::Status status;
         replicated_storage->getStatus(status);
 
-        /// Leader replica take lock
+        /// Any replica which is leader tries to take lock
         if (status.is_leader && lock->tryLock())
         {
-            if (is_already_executed())
+            /// In replicated merge tree we can have multiple leaders. So we can
+            /// be "leader", but another "leader" replica may already execute
+            /// this task.
+            if (zookeeper->tryGet(is_executed_path, executed_by))
             {
+                LOG_DEBUG(log, "Task {} has already been executed by replica ({}) of the same shard.", task.entry_name, executed_by);
                 executed_by_leader = true;
                 break;
             }
 
+            /// Doing it exclusively
+            size_t counter = parse<int>(zookeeper->get(tries_to_execute_path));
+            if (counter > MAX_TRIES_TO_EXECUTE)
+                break;
+
+            zookeeper->set(tries_to_execute_path, toString(counter + 1));
+
             /// If the leader will unexpectedly changed this method will return false
             /// and on the next iteration new leader will take lock
             if (tryExecuteQuery(rewritten_query, task, task.execution_status))
@@ -910,20 +918,31 @@ bool DDLWorker::tryExecuteQueryOnLeaderReplica(
                 executed_by_leader = true;
                 break;
             }
+
+            lock->unlock();
         }
 
-        /// Does nothing if wasn't previously locked
-        lock->unlock();
-        std::this_thread::sleep_for(std::chrono::milliseconds(std::uniform_int_distribution<int>(0, 1000)(rng)));
+
+        if (event->tryWait(std::uniform_int_distribution<int>(0, 1000)(rng)))
+        {
+            executed_by_leader = true;
+            break;
+        }
+        else if (parse<int>(zookeeper->get(tries_to_execute_path)) > MAX_TRIES_TO_EXECUTE)
+        {
+            /// Nobody will try to execute query again
+            break;
+        }
     }
 
     /// Not executed by leader so was not executed at all
     if (!executed_by_leader)
     {
-        task.execution_status = ExecutionStatus(ErrorCodes::NOT_IMPLEMENTED,
-                                                "Cannot execute replicated DDL query on leader");
+        task.execution_status = ExecutionStatus(ErrorCodes::NOT_IMPLEMENTED, "Cannot execute replicated DDL query");
         return false;
     }
+
+    LOG_DEBUG(log, "Task {} has already been executed by replica ({}) of the same shard.", task.entry_name, zookeeper->get(is_executed_path));
     return true;
 }
 
