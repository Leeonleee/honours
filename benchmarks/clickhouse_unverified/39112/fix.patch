diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index e25a6260787e..b62690b7a3a3 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -963,40 +963,24 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
         // Don't need to do anything more for window functions here -- the
         // resulting column is added in ExpressionAnalyzer, similar to the
         // aggregate functions.
-        if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)
-            data.window_function_in_subtree = true;
         return;
     }
     else if (node.compute_after_window_functions)
     {
-        // In this case we have window function call in subtree
-        // Add this function to actions index only if Data::build_expression_with_window_functions is set.
-        data.window_dependancy_state = WindowDependancyState::MAY_DEPEND;
-        for (const auto & arg : node.arguments->children)
-        {
-            data.window_function_in_subtree = false;
-            visit(arg, data);
-            // There is no point to check value of window_function_in_subtree here,
-            // because after window functions are computed, this variable is always false.
-        }
-        data.window_dependancy_state = WindowDependancyState::NONE;
         if (!data.build_expression_with_window_functions)
-            return;
-    }
-    else if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)
-    {
-        // This function may depend on evaluation of window function.
-        // We need to check it and add it to the index only if Data::build_expression_with_window_functions is set.
-        bool subtree_contains_window_call = false;
-        for (const auto & arg : node.arguments->children)
         {
-            data.window_function_in_subtree = false;
-            visit(arg, data);
-            subtree_contains_window_call = subtree_contains_window_call || data.window_function_in_subtree;
-        }
-        data.window_function_in_subtree = subtree_contains_window_call;
-        if (subtree_contains_window_call && !data.build_expression_with_window_functions)
+            for (const auto & arg : node.arguments->children)
+            {
+                if (auto const * function = arg->as<ASTFunction>();
+                    function && function->name == "lambda")
+                {
+                    // Lambda function is a special case. It shouldn't be visited here.
+                    continue;
+                }
+                visit(arg, data);
+            }
             return;
+        }
     }
 
     // An aggregate function can also be calculated as a window function, but we
diff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h
index afdf2948d473..5b5a3d31da28 100644
--- a/src/Interpreters/ActionsVisitor.h
+++ b/src/Interpreters/ActionsVisitor.h
@@ -121,12 +121,6 @@ class ActionsMatcher
 public:
     using Visitor = ConstInDepthNodeVisitor<ActionsMatcher, true>;
 
-    enum class WindowDependancyState
-    {
-        NONE,
-        MAY_DEPEND,
-    };
-
     struct Data : public WithContext
     {
         SizeLimits set_size_limit;
@@ -150,9 +144,6 @@ class ActionsMatcher
          */
         int next_unique_suffix;
 
-        WindowDependancyState window_dependancy_state = WindowDependancyState::NONE;
-        bool window_function_in_subtree = false;
-
         Data(
             ContextPtr context_,
             SizeLimits set_size_limit_,
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index b79dc9c80e91..483ffad67b72 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -1497,6 +1497,25 @@ void SelectQueryExpressionAnalyzer::appendExpressionsAfterWindowFunctions(Expres
     }
 }
 
+void SelectQueryExpressionAnalyzer::appendSelectSkipWindowExpressions(ExpressionActionsChain::Step & step, ASTPtr const & node)
+{
+    if (auto * function = node->as<ASTFunction>())
+    {
+        // Skip window function columns here -- they are calculated after
+        // other SELECT expressions by a special step.
+        // Also skipping lambda functions because they can't be explicitly evaluated.
+        if (function->is_window_function || function->name == "lambda")
+            return;
+        if (function->compute_after_window_functions)
+        {
+            for (auto & arg : function->arguments->children)
+                appendSelectSkipWindowExpressions(step, arg);
+            return;
+        }
+    }
+    step.addRequiredOutput(node->getColumnName());
+}
+
 bool SelectQueryExpressionAnalyzer::appendHaving(ExpressionActionsChain & chain, bool only_types)
 {
     const auto * select_query = getAggregatingQuery();
@@ -1521,18 +1540,7 @@ void SelectQueryExpressionAnalyzer::appendSelect(ExpressionActionsChain & chain,
     getRootActions(select_query->select(), only_types, step.actions());
 
     for (const auto & child : select_query->select()->children)
-    {
-        if (const auto * function = typeid_cast<const ASTFunction *>(child.get());
-            function
-            && (function->is_window_function || function->compute_after_window_functions))
-        {
-            // Skip window function columns here -- they are calculated after
-            // other SELECT expressions by a special step.
-            continue;
-        }
-
-        step.addRequiredOutput(child->getColumnName());
-    }
+        appendSelectSkipWindowExpressions(step, child);
 }
 
 ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChain & chain, bool only_types, bool optimize_read_in_order,
diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h
index 167c3dfd918d..aae45482a977 100644
--- a/src/Interpreters/ExpressionAnalyzer.h
+++ b/src/Interpreters/ExpressionAnalyzer.h
@@ -410,6 +410,7 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer
     void appendWindowFunctionsArguments(ExpressionActionsChain & chain, bool only_types);
 
     void appendExpressionsAfterWindowFunctions(ExpressionActionsChain & chain, bool only_types);
+    void appendSelectSkipWindowExpressions(ExpressionActionsChain::Step & step, ASTPtr const & node);
 
     /// After aggregation:
     bool appendHaving(ExpressionActionsChain & chain, bool only_types);
diff --git a/src/Interpreters/GetAggregatesVisitor.cpp b/src/Interpreters/GetAggregatesVisitor.cpp
index a9d96a6d15a4..dd958693d899 100644
--- a/src/Interpreters/GetAggregatesVisitor.cpp
+++ b/src/Interpreters/GetAggregatesVisitor.cpp
@@ -17,8 +17,7 @@ struct WindowExpressionsCollectorChildInfo
 // evaluation of window functions. Expression is collected only if
 // it's not a part of another expression.
 //
-// Also all collected AST nodes are marked as dependent on window function.
-// This information is used during ActionsDAG building process.
+// Information about window function dependency is used during ActionsDAG building process.
 struct WindowExpressionsCollectorMatcher
 {
     using ChildInfo = WindowExpressionsCollectorChildInfo;
@@ -63,11 +62,12 @@ struct WindowExpressionsCollectorMatcher
                 result.update(subtree_result);
             }
 
-            // We mark functions only on the top of AST
-            if ((!parent || !parent->as<ASTFunction>()) && result.window_function_in_subtree)
+            // We mark functions if they should be computed after WindowStep
+            if (result.window_function_in_subtree)
             {
-                expressions_with_window_functions.push_back(func);
                 func->compute_after_window_functions = true;
+                if ((!parent || !parent->as<ASTFunction>()))
+                    expressions_with_window_functions.push_back(func);
             }
 
             return result;
