diff --git a/tests/integration/test_storage_s3/s3_mock/mock_s3.py b/tests/integration/test_storage_s3/s3_mocks/mock_s3.py
similarity index 89%
rename from tests/integration/test_storage_s3/s3_mock/mock_s3.py
rename to tests/integration/test_storage_s3/s3_mocks/mock_s3.py
index 088cc883e578..3e876689175d 100644
--- a/tests/integration/test_storage_s3/s3_mock/mock_s3.py
+++ b/tests/integration/test_storage_s3/s3_mocks/mock_s3.py
@@ -1,3 +1,5 @@
+import sys
+
 from bottle import abort, route, run, request, response
 
 
@@ -21,4 +23,4 @@ def ping():
     return 'OK'
 
 
-run(host='0.0.0.0', port=8080)
+run(host='0.0.0.0', port=int(sys.argv[1]))
diff --git a/tests/integration/test_storage_s3/s3_mocks/unstable_server.py b/tests/integration/test_storage_s3/s3_mocks/unstable_server.py
new file mode 100644
index 000000000000..4a27845ff9fe
--- /dev/null
+++ b/tests/integration/test_storage_s3/s3_mocks/unstable_server.py
@@ -0,0 +1,90 @@
+import http.server
+import random
+import re
+import socket
+import struct
+import sys
+
+
+def gen_n_digit_number(n):
+    assert 0 < n < 19
+    return random.randint(10**(n-1), 10**n-1)
+
+
+def gen_line():
+    columns = 4
+
+    row = []
+    def add_number():
+        digits = random.randint(1, 18)
+        row.append(gen_n_digit_number(digits))
+
+    for i in range(columns // 2):
+        add_number()
+    row.append(1)
+    for i in range(columns - 1 - columns // 2):
+        add_number()
+
+    line = ",".join(map(str, row)) + "
"
+    return line.encode()
+
+
+random.seed("Unstable server/1.0")
+lines = b"".join((gen_line() for _ in range(500000)))
+
+
+class RequestHandler(http.server.BaseHTTPRequestHandler):
+    def do_HEAD(self):
+        if self.path == "/root/test.csv":
+            self.from_bytes = 0
+            self.end_bytes = len(lines)
+            self.size = self.end_bytes
+            self.send_block_size = 256
+            self.stop_at = random.randint(900000, 1200000) // self.send_block_size # Block size is 1024**2.
+
+            if "Range" in self.headers:
+                cr = self.headers["Range"]
+                parts = re.split("[ -/=]+", cr)
+                assert parts[0] == "bytes"
+                self.from_bytes = int(parts[1])
+                if parts[2]:
+                    self.end_bytes = int(parts[2])+1
+                self.send_response(206)
+                self.send_header("Content-Range", f"bytes {self.from_bytes}-{self.end_bytes-1}/{self.size}")
+            else:
+                self.send_response(200)
+
+            self.send_header("Accept-Ranges", "bytes")
+            self.send_header("Content-Type", "text/plain")
+            self.send_header("Content-Length", f"{self.end_bytes-self.from_bytes}")
+            self.end_headers()
+
+        elif self.path == "/":
+            self.send_response(200)
+            self.send_header("Content-Type", "text/plain")
+            self.end_headers()
+
+        else:
+            self.send_response(404)
+            self.send_header("Content-Type", "text/plain")
+            self.end_headers()
+
+
+    def do_GET(self):
+        self.do_HEAD()
+        if self.path == "/root/test.csv":
+            for c, i in enumerate(range(self.from_bytes, self.end_bytes, self.send_block_size)):
+                self.wfile.write(lines[i:min(i+self.send_block_size, self.end_bytes)])
+                if (c + 1) % self.stop_at == 0:
+                    #self.wfile._sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack("ii", 0, 0))
+                    #self.wfile._sock.shutdown(socket.SHUT_RDWR)
+                    #self.wfile._sock.close()
+                    print('Dropping connection')
+                    break
+
+        elif self.path == "/":
+            self.wfile.write(b"OK")
+
+
+httpd = http.server.HTTPServer(("0.0.0.0", int(sys.argv[1])), RequestHandler)
+httpd.serve_forever()
diff --git a/tests/integration/test_storage_s3/test.py b/tests/integration/test_storage_s3/test.py
index 9e91aae66b31..c239dc688107 100644
--- a/tests/integration/test_storage_s3/test.py
+++ b/tests/integration/test_storage_s3/test.py
@@ -96,7 +96,7 @@ def cluster():
 
         prepare_s3_bucket(cluster)
         logging.info("S3 bucket created")
-        run_s3_mock(cluster)
+        run_s3_mocks(cluster)
 
         yield cluster
     finally:
@@ -384,26 +384,32 @@ def add_tales(start, end):
     assert run_query(instance, query).splitlines() == ["1001\t1001\t1001\t1001"]
 
 
-def run_s3_mock(cluster):
-    logging.info("Starting s3 mock")
-    container_id = cluster.get_container_id('resolver')
-    current_dir = os.path.dirname(__file__)
-    cluster.copy_file_to_container(container_id, os.path.join(current_dir, "s3_mock", "mock_s3.py"), "mock_s3.py")
-    cluster.exec_in_container(container_id, ["python", "mock_s3.py"], detach=True)
-
-    # Wait for S3 mock start
-    for attempt in range(10):
-        ping_response = cluster.exec_in_container(cluster.get_container_id('resolver'),
-                                                  ["curl", "-s", "http://resolver:8080/"], nothrow=True)
-        if ping_response != 'OK':
-            if attempt == 9:
-                assert ping_response == 'OK', 'Expected "OK", but got "{}"'.format(ping_response)
+def run_s3_mocks(cluster):
+    logging.info("Starting s3 mocks")
+    mocks = (
+        ("mock_s3.py", "resolver", "8080"),
+        ("unstable_server.py", "resolver", "8081"),
+    )
+    for mock_filename, container, port in mocks:
+        container_id = cluster.get_container_id(container)
+        current_dir = os.path.dirname(__file__)
+        cluster.copy_file_to_container(container_id, os.path.join(current_dir, "s3_mocks", mock_filename), mock_filename)
+        cluster.exec_in_container(container_id, ["python", mock_filename, port], detach=True)
+
+    # Wait for S3 mocks to start
+    for mock_filename, container, port in mocks:
+        for attempt in range(10):
+            ping_response = cluster.exec_in_container(cluster.get_container_id(container),
+                                                      ["curl", "-s", f"http://{container}:{port}/"], nothrow=True)
+            if ping_response != 'OK':
+                if attempt == 9:
+                    assert ping_response == 'OK', 'Expected "OK", but got "{}"'.format(ping_response)
+                else:
+                    time.sleep(1)
             else:
-                time.sleep(1)
-        else:
-            break
+                break
 
-    logging.info("S3 mock started")
+    logging.info("S3 mocks started")
 
 
 def replace_config(old, new):
@@ -523,6 +529,15 @@ def test_storage_s3_get_gzip(cluster, extension, method):
         run_query(instance, f"DROP TABLE {name}")
 
 
+def test_storage_s3_get_unstable(cluster):
+    bucket = cluster.minio_bucket
+    instance = cluster.instances["dummy"]
+    table_format = "column1 Int64, column2 Int64, column3 Int64, column4 Int64"
+    get_query = f"SELECT count(), sum(column3) FROM s3('http://resolver:8081/{cluster.minio_bucket}/test.csv', 'CSV', '{table_format}') FORMAT CSV"
+    result = run_query(instance, get_query)
+    assert result.splitlines() == ["500000,500000"]
+
+
 def test_storage_s3_put_uncompressed(cluster):
     bucket = cluster.minio_bucket
     instance = cluster.instances["dummy"]
