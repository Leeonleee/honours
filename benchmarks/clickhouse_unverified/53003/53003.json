{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53003,
  "instance_id": "ClickHouse__ClickHouse-53003",
  "issue_numbers": [
    "51236"
  ],
  "base_commit": "5862c4ec93a9945f4d7a607ba9b917f9e863b11b",
  "patch": "diff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp\nindex 210dab9921e8..837aae6753a2 100644\n--- a/src/DataTypes/FieldToDataType.cpp\n+++ b/src/DataTypes/FieldToDataType.cpp\n@@ -136,8 +136,17 @@ DataTypePtr FieldToDataType<on_error>::operator() (const Array & x) const\n     DataTypes element_types;\n     element_types.reserve(x.size());\n \n+    bool has_signed_int = false;\n+    bool uint64_convert_possible = true;\n     for (const Field & elem : x)\n-        element_types.emplace_back(applyVisitor(*this, elem));\n+    {\n+        DataTypePtr type = applyVisitor(*this, elem);\n+        element_types.emplace_back(type);\n+        checkUInt64ToIn64Conversion(has_signed_int, uint64_convert_possible, type, elem);\n+    }\n+\n+    if (has_signed_int && uint64_convert_possible)\n+        convertUInt64ToInt64IfPossible(element_types);\n \n     return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(element_types));\n }\n@@ -165,14 +174,28 @@ DataTypePtr FieldToDataType<on_error>::operator() (const Map & map) const\n     key_types.reserve(map.size());\n     value_types.reserve(map.size());\n \n+    bool k_has_signed_int = false;\n+    bool k_uint64_convert_possible = true;\n+    bool v_has_signed_int = false;\n+    bool v_uint64_convert_possible = true;\n     for (const auto & elem : map)\n     {\n         const auto & tuple = elem.safeGet<const Tuple &>();\n         assert(tuple.size() == 2);\n-        key_types.push_back(applyVisitor(*this, tuple[0]));\n-        value_types.push_back(applyVisitor(*this, tuple[1]));\n+        DataTypePtr k_type = applyVisitor(*this, tuple[0]);\n+        key_types.push_back(k_type);\n+        checkUInt64ToIn64Conversion(k_has_signed_int, k_uint64_convert_possible, k_type, tuple[0]);\n+        DataTypePtr v_type = applyVisitor(*this, tuple[1]);\n+        value_types.push_back(v_type);\n+        checkUInt64ToIn64Conversion(v_has_signed_int, v_uint64_convert_possible, v_type, tuple[1]);\n     }\n \n+    if (k_has_signed_int && k_uint64_convert_possible)\n+        convertUInt64ToInt64IfPossible(key_types);\n+\n+    if (v_has_signed_int && v_uint64_convert_possible)\n+        convertUInt64ToInt64IfPossible(value_types);\n+\n     return std::make_shared<DataTypeMap>(\n         getLeastSupertype<on_error>(key_types),\n         getLeastSupertype<on_error>(value_types));\n@@ -204,6 +227,28 @@ DataTypePtr FieldToDataType<on_error>::operator()(const bool &) const\n     return DataTypeFactory::instance().get(\"Bool\");\n }\n \n+template <LeastSupertypeOnError on_error>\n+void FieldToDataType<on_error>::checkUInt64ToIn64Conversion(bool & has_signed_int, bool & uint64_convert_possible, const DataTypePtr & type, const Field & elem) const\n+{\n+    if (uint64_convert_possible)\n+    {\n+        bool is_native_int = WhichDataType(type).isNativeInt();\n+\n+        if (is_native_int)\n+            has_signed_int |= is_native_int;\n+        else if (type->getTypeId() == TypeIndex::UInt64)\n+            uint64_convert_possible &= (elem.template get<UInt64>() <= std::numeric_limits<Int64>::max());\n+    }\n+}\n+\n+template <LeastSupertypeOnError on_error>\n+void FieldToDataType<on_error>::convertUInt64ToInt64IfPossible(DataTypes & data_types) const\n+{\n+    for (auto& type : data_types)\n+        if (type->getTypeId() == TypeIndex::UInt64)\n+            type = std::make_shared<DataTypeInt64>();\n+}\n+\n template class FieldToDataType<LeastSupertypeOnError::Throw>;\n template class FieldToDataType<LeastSupertypeOnError::String>;\n template class FieldToDataType<LeastSupertypeOnError::Null>;\ndiff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h\nindex 8febadc1a0d1..d1a3f11e8de6 100644\n--- a/src/DataTypes/FieldToDataType.h\n+++ b/src/DataTypes/FieldToDataType.h\n@@ -45,6 +45,16 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>\n     DataTypePtr operator() (const UInt256 & x) const;\n     DataTypePtr operator() (const Int256 & x) const;\n     DataTypePtr operator() (const bool & x) const;\n+\n+private:\n+    // The conditions for converting UInt64 to Int64 are:\n+    // 1. The existence of Int.\n+    // 2. The existence of UInt64, and the UInt64 value must be <= Int64.max.\n+    void checkUInt64ToIn64Conversion(bool& has_signed_int, bool& uint64_convert_possible, const DataTypePtr & type, const Field & elem) const;\n+\n+    // Convert the UInt64 type to Int64 in order to cover other signed_integer types\n+    // and obtain the least super type of all ints.\n+    void convertUInt64ToInt64IfPossible(DataTypes & data_types) const;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02832_integer_type_inference.reference b/tests/queries/0_stateless/02832_integer_type_inference.reference\nnew file mode 100644\nindex 000000000000..5a01bd4cd11a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02832_integer_type_inference.reference\n@@ -0,0 +1,2 @@\n+[-4741124612489978151,-3236599669630092879,5607475129431807682]\n+[100,-100,5607475129431807682,5607475129431807683]\ndiff --git a/tests/queries/0_stateless/02832_integer_type_inference.sql b/tests/queries/0_stateless/02832_integer_type_inference.sql\nnew file mode 100644\nindex 000000000000..221e929d7051\n--- /dev/null\n+++ b/tests/queries/0_stateless/02832_integer_type_inference.sql\n@@ -0,0 +1,2 @@\n+select [-4741124612489978151, -3236599669630092879, 5607475129431807682];\n+select [100, -100, 5607475129431807682, 5607475129431807683];\n",
  "problem_statement": "Integer type inference seems confusing\nInteger type inference seems incorect incorect\r\n\r\n```sql\r\nselect  [-4741124612489978151, -3236599669630092879, 5607475129431807682]\r\n```\r\n\r\nthow this exception\r\n```\r\nReceived exception from server (version 23.3.2):\r\nCode: 386. DB::Exception: Received from localhost:9101. DB::Exception: There is no supertype for types UInt64, Int64 because some of them are signed integers and some are unsigned integers, but there is no signed integer type, that can exactly represent all required unsigned integer values: While processing transform(commit, [-4741124612489978151, -3236599669630092879, 5607475129431807682], range(toInt64(3))). (NO_COMMON_TYPE)\r\n```\r\n\r\nwhile in fact all value could fit in Int64.\r\nexemple\r\n```sql\r\nSELECT [-4741124612489978151, -3236599669630092879, toInt64(5607475129431807682)]\r\n\r\n\r\n\u250c\u2500array(-4741124612489978151, -3236599669630092879, toInt64(5607475129431807682))\u2500\u2510\r\n\u2502 [-4741124612489978151,-3236599669630092879,5607475129431807682]                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2023-08-03T15:01:32Z",
  "modified_files": [
    "src/DataTypes/FieldToDataType.cpp",
    "src/DataTypes/FieldToDataType.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02832_integer_type_inference.reference",
    "b/tests/queries/0_stateless/02832_integer_type_inference.sql"
  ]
}