diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 028d6dd8caa8..e096811e5b91 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -44,7 +44,6 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int BAD_ARGUMENTS;
-    extern const int LOGICAL_ERROR;
     extern const int NOT_IMPLEMENTED;
     extern const int ILLEGAL_PREWHERE;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
@@ -653,7 +652,7 @@ QueryPipelineBuilderPtr ReadFromMerge::createSources(
 
         /// Subordinary tables could have different but convertible types, like numeric types of different width.
         /// We must return streams with structure equals to structure of Merge table.
-        convertingSourceStream(header, storage_snapshot->metadata, aliases, modified_context, modified_query_info.query, *builder, processed_stage);
+        convertingSourceStream(header, storage_snapshot->metadata, aliases, modified_context, *builder);
     }
 
     return builder;
@@ -829,9 +828,7 @@ void ReadFromMerge::convertingSourceStream(
     const StorageMetadataPtr & metadata_snapshot,
     const Aliases & aliases,
     ContextPtr local_context,
-    ASTPtr & query,
-    QueryPipelineBuilder & builder,
-    QueryProcessingStage::Enum processed_stage)
+    QueryPipelineBuilder & builder)
 {
     Block before_block_header = builder.getHeader();
 
@@ -868,39 +865,6 @@ void ReadFromMerge::convertingSourceStream(
             return std::make_shared<ExpressionTransform>(stream_header, actions);
         });
     }
-
-    auto where_expression = query->as<ASTSelectQuery>()->where();
-
-    if (!where_expression)
-        return;
-
-    if (processed_stage > QueryProcessingStage::FetchColumns)
-    {
-        for (size_t column_index : collections::range(0, header.columns()))
-        {
-            ColumnWithTypeAndName header_column = header.getByPosition(column_index);
-            ColumnWithTypeAndName before_column = before_block_header.getByName(header_column.name);
-            /// If the processed_stage greater than FetchColumns and the block structure between streams is different.
-            /// the where expression maybe invalid because of ConvertingTransform.
-            /// So we need to throw exception.
-            if (!header_column.type->equals(*before_column.type.get()))
-            {
-                NamesAndTypesList source_columns = metadata_snapshot->getSampleBlock().getNamesAndTypesList();
-                auto virtual_column = *storage_merge->getVirtuals().tryGetByName("_table");
-                source_columns.emplace_back(NameAndTypePair{virtual_column.name, virtual_column.type});
-                auto syntax_result = TreeRewriter(local_context).analyze(where_expression, source_columns);
-                ExpressionActionsPtr actions = ExpressionAnalyzer{where_expression, syntax_result, local_context}.getActions(false, false);
-                Names required_columns = actions->getRequiredColumns();
-
-                for (const auto & required_column : required_columns)
-                {
-                    if (required_column == header_column.name)
-                        throw Exception("Block structure mismatch in Merge Storage: different types:
" + before_block_header.dumpStructure()
-                                        + "
" + header.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
-                }
-            }
-        }
-    }
 }
 
 IStorage::ColumnSizeByName StorageMerge::getColumnSizes() const
diff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h
index 54f3999514d0..d296eeea4212 100644
--- a/src/Storages/StorageMerge.h
+++ b/src/Storages/StorageMerge.h
@@ -193,10 +193,10 @@ class ReadFromMerge final : public ISourceStep
         size_t streams_num,
         bool concat_streams = false);
 
-    void convertingSourceStream(
+    static void convertingSourceStream(
         const Block & header, const StorageMetadataPtr & metadata_snapshot, const Aliases & aliases,
-        ContextPtr context, ASTPtr & query,
-        QueryPipelineBuilder & builder, QueryProcessingStage::Enum processed_stage);
+        ContextPtr context,
+        QueryPipelineBuilder & builder);
 };
 
 }
