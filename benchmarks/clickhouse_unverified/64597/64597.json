{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64597,
  "instance_id": "ClickHouse__ClickHouse-64597",
  "issue_numbers": [
    "63998"
  ],
  "base_commit": "741e453510798f050ac560e9f082209c1ab4d3d3",
  "patch": "diff --git a/docs/en/operations/system-tables/query_log.md b/docs/en/operations/system-tables/query_log.md\nindex 75b855966a31..47094eec3f09 100644\n--- a/docs/en/operations/system-tables/query_log.md\n+++ b/docs/en/operations/system-tables/query_log.md\n@@ -113,6 +113,8 @@ Columns:\n - `used_functions` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `functions`, which were used during query execution.\n - `used_storages` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `storages`, which were used during query execution.\n - `used_table_functions` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `table functions`, which were used during query execution.\n+- `used_privileges` ([Array(String)](../../sql-reference/data-types/array.md)) - Privileges which were successfully checked during query execution.\n+- `missing_privileges` ([Array(String)](../../sql-reference/data-types/array.md)) - Privileges that are missing during query execution.\n - `query_cache_usage` ([Enum8](../../sql-reference/data-types/enum.md)) \u2014 Usage of the [query cache](../query-cache.md) during query execution. Values:\n     - `'Unknown'` = Status unknown.\n     - `'None'` = The query result was neither written into nor read from the query cache.\n@@ -194,6 +196,8 @@ used_formats:                          []\n used_functions:                        []\n used_storages:                         []\n used_table_functions:                  []\n+used_privileges:                       []\n+missing_privileges:                    []\n query_cache_usage:                     None\n ```\n \ndiff --git a/src/Access/CachedAccessChecking.cpp b/src/Access/CachedAccessChecking.cpp\nindex aa8ef6073d3c..0d629e7b77a5 100644\n--- a/src/Access/CachedAccessChecking.cpp\n+++ b/src/Access/CachedAccessChecking.cpp\n@@ -4,12 +4,12 @@\n \n namespace DB\n {\n-CachedAccessChecking::CachedAccessChecking(const std::shared_ptr<const ContextAccess> & access_, AccessFlags access_flags_)\n+CachedAccessChecking::CachedAccessChecking(const std::shared_ptr<const ContextAccessWrapper> & access_, AccessFlags access_flags_)\n     : CachedAccessChecking(access_, AccessRightsElement{access_flags_})\n {\n }\n \n-CachedAccessChecking::CachedAccessChecking(const std::shared_ptr<const ContextAccess> & access_, const AccessRightsElement & element_)\n+CachedAccessChecking::CachedAccessChecking(const std::shared_ptr<const ContextAccessWrapper> & access_, const AccessRightsElement & element_)\n     : access(access_), element(element_)\n {\n }\ndiff --git a/src/Access/CachedAccessChecking.h b/src/Access/CachedAccessChecking.h\nindex e87c28dd823c..aaeea6ceddcc 100644\n--- a/src/Access/CachedAccessChecking.h\n+++ b/src/Access/CachedAccessChecking.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Access/Common/AccessRightsElement.h>\n+#include <Access/ContextAccess.h>\n #include <memory>\n \n \n@@ -13,14 +14,14 @@ class ContextAccess;\n class CachedAccessChecking\n {\n public:\n-    CachedAccessChecking(const std::shared_ptr<const ContextAccess> & access_, AccessFlags access_flags_);\n-    CachedAccessChecking(const std::shared_ptr<const ContextAccess> & access_, const AccessRightsElement & element_);\n+    CachedAccessChecking(const std::shared_ptr<const ContextAccessWrapper> & access_, AccessFlags access_flags_);\n+    CachedAccessChecking(const std::shared_ptr<const ContextAccessWrapper> & access_, const AccessRightsElement & element_);\n     ~CachedAccessChecking();\n \n     bool checkAccess(bool throw_if_denied = true);\n \n private:\n-    const std::shared_ptr<const ContextAccess> access;\n+    const std::shared_ptr<const ContextAccessWrapper> access;\n     const AccessRightsElement element;\n     bool checked = false;\n     bool result = false;\ndiff --git a/src/Access/ContextAccess.cpp b/src/Access/ContextAccess.cpp\nindex 28a825de6cf0..a2807ecc5eac 100644\n--- a/src/Access/ContextAccess.cpp\n+++ b/src/Access/ContextAccess.cpp\n@@ -20,6 +20,7 @@\n #include <boost/algorithm/string/join.hpp>\n #include <boost/range/algorithm/set_algorithm.hpp>\n #include <cassert>\n+#include <unordered_set>\n \n \n namespace DB\n@@ -271,7 +272,7 @@ namespace\n \n std::shared_ptr<const ContextAccess> ContextAccess::fromContext(const ContextPtr & context)\n {\n-    return context->getAccess();\n+    return ContextAccessWrapper::fromContext(context)->getAccess();\n }\n \n \n@@ -560,7 +561,7 @@ std::shared_ptr<const AccessRights> ContextAccess::getAccessRightsWithImplicit()\n \n \n template <bool throw_if_denied, bool grant_option, typename... Args>\n-bool ContextAccess::checkAccessImplHelper(AccessFlags flags, const Args &... args) const\n+bool ContextAccess::checkAccessImplHelper(const ContextPtr & context, AccessFlags flags, const Args &... args) const\n {\n     if (user_was_dropped)\n     {\n@@ -573,8 +574,10 @@ bool ContextAccess::checkAccessImplHelper(AccessFlags flags, const Args &... arg\n     if (params.full_access)\n         return true;\n \n-    auto access_granted = []\n+    auto access_granted = [&]\n     {\n+        if constexpr (throw_if_denied)\n+            context->addQueryPrivilegesInfo(AccessRightsElement{flags, args...}.toStringWithoutOptions(), true);\n         return true;\n     };\n \n@@ -583,7 +586,10 @@ bool ContextAccess::checkAccessImplHelper(AccessFlags flags, const Args &... arg\n                                                FmtArgs && ...fmt_args [[maybe_unused]])\n     {\n         if constexpr (throw_if_denied)\n+        {\n+            context->addQueryPrivilegesInfo(AccessRightsElement{flags, args...}.toStringWithoutOptions(), false);\n             throw Exception(error_code, std::move(fmt_string), getUserName(), std::forward<FmtArgs>(fmt_args)...);\n+        }\n         return false;\n     };\n \n@@ -686,102 +692,102 @@ bool ContextAccess::checkAccessImplHelper(AccessFlags flags, const Args &... arg\n }\n \n template <bool throw_if_denied, bool grant_option>\n-bool ContextAccess::checkAccessImpl(const AccessFlags & flags) const\n+bool ContextAccess::checkAccessImpl(const ContextPtr & context, const AccessFlags & flags) const\n {\n-    return checkAccessImplHelper<throw_if_denied, grant_option>(flags);\n+    return checkAccessImplHelper<throw_if_denied, grant_option>(context, flags);\n }\n \n template <bool throw_if_denied, bool grant_option, typename... Args>\n-bool ContextAccess::checkAccessImpl(const AccessFlags & flags, std::string_view database, const Args &... args) const\n+bool ContextAccess::checkAccessImpl(const ContextPtr & context, const AccessFlags & flags, std::string_view database, const Args &... args) const\n {\n-    return checkAccessImplHelper<throw_if_denied, grant_option>(flags, database.empty() ? params.current_database : database, args...);\n+    return checkAccessImplHelper<throw_if_denied, grant_option>(context, flags, database.empty() ? params.current_database : database, args...);\n }\n \n template <bool throw_if_denied, bool grant_option>\n-bool ContextAccess::checkAccessImplHelper(const AccessRightsElement & element) const\n+bool ContextAccess::checkAccessImplHelper(const ContextPtr & context, const AccessRightsElement & element) const\n {\n     assert(!element.grant_option || grant_option);\n     if (element.isGlobalWithParameter())\n     {\n         if (element.any_parameter)\n-            return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags);\n+            return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags);\n         else\n-            return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags, element.parameter);\n+            return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags, element.parameter);\n     }\n     else if (element.any_database)\n-        return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags);\n+        return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags);\n     else if (element.any_table)\n-        return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags, element.database);\n+        return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags, element.database);\n     else if (element.any_column)\n-        return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags, element.database, element.table);\n+        return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags, element.database, element.table);\n     else\n-        return checkAccessImpl<throw_if_denied, grant_option>(element.access_flags, element.database, element.table, element.columns);\n+        return checkAccessImpl<throw_if_denied, grant_option>(context, element.access_flags, element.database, element.table, element.columns);\n }\n \n template <bool throw_if_denied, bool grant_option>\n-bool ContextAccess::checkAccessImpl(const AccessRightsElement & element) const\n+bool ContextAccess::checkAccessImpl(const ContextPtr & context, const AccessRightsElement & element) const\n {\n     if constexpr (grant_option)\n     {\n-        return checkAccessImplHelper<throw_if_denied, true>(element);\n+        return checkAccessImplHelper<throw_if_denied, true>(context, element);\n     }\n     else\n     {\n         if (element.grant_option)\n-            return checkAccessImplHelper<throw_if_denied, true>(element);\n+            return checkAccessImplHelper<throw_if_denied, true>(context, element);\n         else\n-            return checkAccessImplHelper<throw_if_denied, false>(element);\n+            return checkAccessImplHelper<throw_if_denied, false>(context, element);\n     }\n }\n \n template <bool throw_if_denied, bool grant_option>\n-bool ContextAccess::checkAccessImpl(const AccessRightsElements & elements) const\n+bool ContextAccess::checkAccessImpl(const ContextPtr & context, const AccessRightsElements & elements) const\n {\n     for (const auto & element : elements)\n-        if (!checkAccessImpl<throw_if_denied, grant_option>(element))\n+        if (!checkAccessImpl<throw_if_denied, grant_option>(context, element))\n             return false;\n     return true;\n }\n \n-bool ContextAccess::isGranted(const AccessFlags & flags) const { return checkAccessImpl<false, false>(flags); }\n-bool ContextAccess::isGranted(const AccessFlags & flags, std::string_view database) const { return checkAccessImpl<false, false>(flags, database); }\n-bool ContextAccess::isGranted(const AccessFlags & flags, std::string_view database, std::string_view table) const { return checkAccessImpl<false, false>(flags, database, table); }\n-bool ContextAccess::isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return checkAccessImpl<false, false>(flags, database, table, column); }\n-bool ContextAccess::isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return checkAccessImpl<false, false>(flags, database, table, columns); }\n-bool ContextAccess::isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return checkAccessImpl<false, false>(flags, database, table, columns); }\n-bool ContextAccess::isGranted(const AccessRightsElement & element) const { return checkAccessImpl<false, false>(element); }\n-bool ContextAccess::isGranted(const AccessRightsElements & elements) const { return checkAccessImpl<false, false>(elements); }\n-\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags) const { return checkAccessImpl<false, true>(flags); }\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags, std::string_view database) const { return checkAccessImpl<false, true>(flags, database); }\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const { return checkAccessImpl<false, true>(flags, database, table); }\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return checkAccessImpl<false, true>(flags, database, table, column); }\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return checkAccessImpl<false, true>(flags, database, table, columns); }\n-bool ContextAccess::hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return checkAccessImpl<false, true>(flags, database, table, columns); }\n-bool ContextAccess::hasGrantOption(const AccessRightsElement & element) const { return checkAccessImpl<false, true>(element); }\n-bool ContextAccess::hasGrantOption(const AccessRightsElements & elements) const { return checkAccessImpl<false, true>(elements); }\n-\n-void ContextAccess::checkAccess(const AccessFlags & flags) const { checkAccessImpl<true, false>(flags); }\n-void ContextAccess::checkAccess(const AccessFlags & flags, std::string_view database) const { checkAccessImpl<true, false>(flags, database); }\n-void ContextAccess::checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table) const { checkAccessImpl<true, false>(flags, database, table); }\n-void ContextAccess::checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { checkAccessImpl<true, false>(flags, database, table, column); }\n-void ContextAccess::checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { checkAccessImpl<true, false>(flags, database, table, columns); }\n-void ContextAccess::checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { checkAccessImpl<true, false>(flags, database, table, columns); }\n-void ContextAccess::checkAccess(const AccessRightsElement & element) const { checkAccessImpl<true, false>(element); }\n-void ContextAccess::checkAccess(const AccessRightsElements & elements) const { checkAccessImpl<true, false>(elements); }\n-\n-void ContextAccess::checkGrantOption(const AccessFlags & flags) const { checkAccessImpl<true, true>(flags); }\n-void ContextAccess::checkGrantOption(const AccessFlags & flags, std::string_view database) const { checkAccessImpl<true, true>(flags, database); }\n-void ContextAccess::checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const { checkAccessImpl<true, true>(flags, database, table); }\n-void ContextAccess::checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { checkAccessImpl<true, true>(flags, database, table, column); }\n-void ContextAccess::checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { checkAccessImpl<true, true>(flags, database, table, columns); }\n-void ContextAccess::checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { checkAccessImpl<true, true>(flags, database, table, columns); }\n-void ContextAccess::checkGrantOption(const AccessRightsElement & element) const { checkAccessImpl<true, true>(element); }\n-void ContextAccess::checkGrantOption(const AccessRightsElements & elements) const { checkAccessImpl<true, true>(elements); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags) const { return checkAccessImpl<false, false>(context, flags); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const { return checkAccessImpl<false, false>(context, flags, database); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const { return checkAccessImpl<false, false>(context, flags, database, table); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return checkAccessImpl<false, false>(context, flags, database, table, column); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return checkAccessImpl<false, false>(context, flags, database, table, columns); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return checkAccessImpl<false, false>(context, flags, database, table, columns); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessRightsElement & element) const { return checkAccessImpl<false, false>(context, element); }\n+bool ContextAccess::isGranted(const ContextPtr & context, const AccessRightsElements & elements) const { return checkAccessImpl<false, false>(context, elements); }\n+\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags) const { return checkAccessImpl<false, true>(context, flags); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const { return checkAccessImpl<false, true>(context, flags, database); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const { return checkAccessImpl<false, true>(context, flags, database, table); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return checkAccessImpl<false, true>(context, flags, database, table, column); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return checkAccessImpl<false, true>(context, flags, database, table, columns); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return checkAccessImpl<false, true>(context, flags, database, table, columns); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessRightsElement & element) const { return checkAccessImpl<false, true>(context, element); }\n+bool ContextAccess::hasGrantOption(const ContextPtr & context, const AccessRightsElements & elements) const { return checkAccessImpl<false, true>(context, elements); }\n+\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags) const { checkAccessImpl<true, false>(context, flags); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const { checkAccessImpl<true, false>(context, flags, database); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const { checkAccessImpl<true, false>(context, flags, database, table); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { checkAccessImpl<true, false>(context, flags, database, table, column); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { checkAccessImpl<true, false>(context, flags, database, table, columns); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { checkAccessImpl<true, false>(context, flags, database, table, columns); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessRightsElement & element) const { checkAccessImpl<true, false>(context, element); }\n+void ContextAccess::checkAccess(const ContextPtr & context, const AccessRightsElements & elements) const { checkAccessImpl<true, false>(context, elements); }\n+\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags) const { checkAccessImpl<true, true>(context, flags); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const { checkAccessImpl<true, true>(context, flags, database); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const { checkAccessImpl<true, true>(context, flags, database, table); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { checkAccessImpl<true, true>(context, flags, database, table, column); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { checkAccessImpl<true, true>(context, flags, database, table, columns); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { checkAccessImpl<true, true>(context, flags, database, table, columns); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessRightsElement & element) const { checkAccessImpl<true, true>(context, element); }\n+void ContextAccess::checkGrantOption(const ContextPtr & context, const AccessRightsElements & elements) const { checkAccessImpl<true, true>(context, elements); }\n \n \n template <bool throw_if_denied, typename Container, typename GetNameFunction>\n-bool ContextAccess::checkAdminOptionImplHelper(const Container & role_ids, const GetNameFunction & get_name_function) const\n+bool ContextAccess::checkAdminOptionImplHelper(const ContextPtr & context, const Container & role_ids, const GetNameFunction & get_name_function) const\n {\n     auto show_error = []<typename... FmtArgs>(int error_code [[maybe_unused]],\n                                                   FormatStringHelper<FmtArgs...> fmt_string [[maybe_unused]],\n@@ -804,7 +810,7 @@ bool ContextAccess::checkAdminOptionImplHelper(const Container & role_ids, const\n     if (!std::size(role_ids))\n         return true;\n \n-    if (isGranted(AccessType::ROLE_ADMIN))\n+    if (isGranted(context, AccessType::ROLE_ADMIN))\n         return true;\n \n     auto info = getRolesInfo();\n@@ -840,54 +846,54 @@ bool ContextAccess::checkAdminOptionImplHelper(const Container & role_ids, const\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const UUID & role_id) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(to_array(role_id), [this](const UUID & id, size_t) { return access_control->tryReadName(id); });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, to_array(role_id), [this](const UUID & id, size_t) { return access_control->tryReadName(id); });\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const UUID & role_id, const String & role_name) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id, const String & role_name) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(to_array(role_id), [&role_name](const UUID &, size_t) { return std::optional<String>{role_name}; });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, to_array(role_id), [&role_name](const UUID &, size_t) { return std::optional<String>{role_name}; });\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(to_array(role_id), [&names_of_roles](const UUID & id, size_t) { auto it = names_of_roles.find(id); return (it != names_of_roles.end()) ? it->second : std::optional<String>{}; });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, to_array(role_id), [&names_of_roles](const UUID & id, size_t) { auto it = names_of_roles.find(id); return (it != names_of_roles.end()) ? it->second : std::optional<String>{}; });\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const std::vector<UUID> & role_ids) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(role_ids, [this](const UUID & id, size_t) { return access_control->tryReadName(id); });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, role_ids, [this](const UUID & id, size_t) { return access_control->tryReadName(id); });\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(role_ids, [&names_of_roles](const UUID &, size_t i) { return std::optional<String>{names_of_roles[i]}; });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, role_ids, [&names_of_roles](const UUID &, size_t i) { return std::optional<String>{names_of_roles[i]}; });\n }\n \n template <bool throw_if_denied>\n-bool ContextAccess::checkAdminOptionImpl(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const\n+bool ContextAccess::checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const\n {\n-    return checkAdminOptionImplHelper<throw_if_denied>(role_ids, [&names_of_roles](const UUID & id, size_t) { auto it = names_of_roles.find(id); return (it != names_of_roles.end()) ? it->second : std::optional<String>{}; });\n+    return checkAdminOptionImplHelper<throw_if_denied>(context, role_ids, [&names_of_roles](const UUID & id, size_t) { auto it = names_of_roles.find(id); return (it != names_of_roles.end()) ? it->second : std::optional<String>{}; });\n }\n \n-bool ContextAccess::hasAdminOption(const UUID & role_id) const { return checkAdminOptionImpl<false>(role_id); }\n-bool ContextAccess::hasAdminOption(const UUID & role_id, const String & role_name) const { return checkAdminOptionImpl<false>(role_id, role_name); }\n-bool ContextAccess::hasAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { return checkAdminOptionImpl<false>(role_id, names_of_roles); }\n-bool ContextAccess::hasAdminOption(const std::vector<UUID> & role_ids) const { return checkAdminOptionImpl<false>(role_ids); }\n-bool ContextAccess::hasAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { return checkAdminOptionImpl<false>(role_ids, names_of_roles); }\n-bool ContextAccess::hasAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { return checkAdminOptionImpl<false>(role_ids, names_of_roles); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const UUID & role_id) const { return checkAdminOptionImpl<false>(context, role_id); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const UUID & role_id, const String & role_name) const { return checkAdminOptionImpl<false>(context, role_id, role_name); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { return checkAdminOptionImpl<false>(context, role_id, names_of_roles); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids) const { return checkAdminOptionImpl<false>(context, role_ids); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { return checkAdminOptionImpl<false>(context, role_ids, names_of_roles); }\n+bool ContextAccess::hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { return checkAdminOptionImpl<false>(context, role_ids, names_of_roles); }\n \n-void ContextAccess::checkAdminOption(const UUID & role_id) const { checkAdminOptionImpl<true>(role_id); }\n-void ContextAccess::checkAdminOption(const UUID & role_id, const String & role_name) const { checkAdminOptionImpl<true>(role_id, role_name); }\n-void ContextAccess::checkAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { checkAdminOptionImpl<true>(role_id, names_of_roles); }\n-void ContextAccess::checkAdminOption(const std::vector<UUID> & role_ids) const { checkAdminOptionImpl<true>(role_ids); }\n-void ContextAccess::checkAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { checkAdminOptionImpl<true>(role_ids, names_of_roles); }\n-void ContextAccess::checkAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { checkAdminOptionImpl<true>(role_ids, names_of_roles); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const UUID & role_id) const { checkAdminOptionImpl<true>(context, role_id); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const UUID & role_id, const String & role_name) const { checkAdminOptionImpl<true>(context, role_id, role_name); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { checkAdminOptionImpl<true>(context, role_id, names_of_roles); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids) const { checkAdminOptionImpl<true>(context, role_ids); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { checkAdminOptionImpl<true>(context, role_ids, names_of_roles); }\n+void ContextAccess::checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { checkAdminOptionImpl<true>(context, role_ids, names_of_roles); }\n \n \n void ContextAccess::checkGranteeIsAllowed(const UUID & grantee_id, const IAccessEntity & grantee) const\n@@ -919,4 +925,10 @@ void ContextAccess::checkGranteesAreAllowed(const std::vector<UUID> & grantee_id\n     }\n }\n \n+std::shared_ptr<const ContextAccessWrapper> ContextAccessWrapper::fromContext(const ContextPtr & context)\n+{\n+    return context->getAccess();\n+}\n+\n+\n }\ndiff --git a/src/Access/ContextAccess.h b/src/Access/ContextAccess.h\nindex 237c423d2618..465932af1d34 100644\n--- a/src/Access/ContextAccess.h\n+++ b/src/Access/ContextAccess.h\n@@ -4,9 +4,12 @@\n #include <Access/ContextAccessParams.h>\n #include <Access/EnabledRowPolicies.h>\n #include <Interpreters/ClientInfo.h>\n+#include <Access/QuotaUsage.h>\n+#include <Common/SettingsChanges.h>\n #include <Core/UUID.h>\n #include <base/scope_guard.h>\n #include <boost/container/flat_set.hpp>\n+#include <memory>\n #include <mutex>\n #include <optional>\n #include <unordered_map>\n@@ -71,59 +74,59 @@ class ContextAccess : public std::enable_shared_from_this<ContextAccess>\n \n     /// Checks if a specified access is granted, and throws an exception if not.\n     /// Empty database means the current database.\n-    void checkAccess(const AccessFlags & flags) const;\n-    void checkAccess(const AccessFlags & flags, std::string_view database) const;\n-    void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table) const;\n-    void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n-    void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n-    void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n-    void checkAccess(const AccessRightsElement & element) const;\n-    void checkAccess(const AccessRightsElements & elements) const;\n-\n-    void checkGrantOption(const AccessFlags & flags) const;\n-    void checkGrantOption(const AccessFlags & flags, std::string_view database) const;\n-    void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const;\n-    void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n-    void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n-    void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n-    void checkGrantOption(const AccessRightsElement & element) const;\n-    void checkGrantOption(const AccessRightsElements & elements) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n+    void checkAccess(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n+    void checkAccess(const ContextPtr & context, const AccessRightsElement & element) const;\n+    void checkAccess(const ContextPtr & context, const AccessRightsElements & elements) const;\n+\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessRightsElement & element) const;\n+    void checkGrantOption(const ContextPtr & context, const AccessRightsElements & elements) const;\n \n     /// Checks if a specified access is granted, and returns false if not.\n     /// Empty database means the current database.\n-    bool isGranted(const AccessFlags & flags) const;\n-    bool isGranted(const AccessFlags & flags, std::string_view database) const;\n-    bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table) const;\n-    bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n-    bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n-    bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n-    bool isGranted(const AccessRightsElement & element) const;\n-    bool isGranted(const AccessRightsElements & elements) const;\n-\n-    bool hasGrantOption(const AccessFlags & flags) const;\n-    bool hasGrantOption(const AccessFlags & flags, std::string_view database) const;\n-    bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const;\n-    bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n-    bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n-    bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n-    bool hasGrantOption(const AccessRightsElement & element) const;\n-    bool hasGrantOption(const AccessRightsElements & elements) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n+    bool isGranted(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n+    bool isGranted(const ContextPtr & context, const AccessRightsElement & element) const;\n+    bool isGranted(const ContextPtr & context, const AccessRightsElements & elements) const;\n+\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessRightsElement & element) const;\n+    bool hasGrantOption(const ContextPtr & context, const AccessRightsElements & elements) const;\n \n     /// Checks if a specified role is granted with admin option, and throws an exception if not.\n-    void checkAdminOption(const UUID & role_id) const;\n-    void checkAdminOption(const UUID & role_id, const String & role_name) const;\n-    void checkAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n-    void checkAdminOption(const std::vector<UUID> & role_ids) const;\n-    void checkAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n-    void checkAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    void checkAdminOption(const ContextPtr & context, const UUID & role_id) const;\n+    void checkAdminOption(const ContextPtr & context, const UUID & role_id, const String & role_name) const;\n+    void checkAdminOption(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    void checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids) const;\n+    void checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n+    void checkAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n \n     /// Checks if a specified role is granted with admin option, and returns false if not.\n-    bool hasAdminOption(const UUID & role_id) const;\n-    bool hasAdminOption(const UUID & role_id, const String & role_name) const;\n-    bool hasAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n-    bool hasAdminOption(const std::vector<UUID> & role_ids) const;\n-    bool hasAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n-    bool hasAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    bool hasAdminOption(const ContextPtr & context, const UUID & role_id) const;\n+    bool hasAdminOption(const ContextPtr & context, const UUID & role_id, const String & role_name) const;\n+    bool hasAdminOption(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    bool hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids) const;\n+    bool hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n+    bool hasAdminOption(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n \n     /// Checks if a grantee is allowed for the current user, throws an exception if not.\n     void checkGranteeIsAllowed(const UUID & grantee_id, const IAccessEntity & grantee) const;\n@@ -142,43 +145,43 @@ class ContextAccess : public std::enable_shared_from_this<ContextAccess>\n     void calculateAccessRights() const TSA_REQUIRES(mutex);\n \n     template <bool throw_if_denied, bool grant_option>\n-    bool checkAccessImpl(const AccessFlags & flags) const;\n+    bool checkAccessImpl(const ContextPtr & context, const AccessFlags & flags) const;\n \n     template <bool throw_if_denied, bool grant_option, typename... Args>\n-    bool checkAccessImpl(const AccessFlags & flags, std::string_view database, const Args &... args) const;\n+    bool checkAccessImpl(const ContextPtr & context, const AccessFlags & flags, std::string_view database, const Args &... args) const;\n \n     template <bool throw_if_denied, bool grant_option>\n-    bool checkAccessImpl(const AccessRightsElement & element) const;\n+    bool checkAccessImpl(const ContextPtr & context, const AccessRightsElement & element) const;\n \n     template <bool throw_if_denied, bool grant_option>\n-    bool checkAccessImpl(const AccessRightsElements & elements) const;\n+    bool checkAccessImpl(const ContextPtr & context, const AccessRightsElements & elements) const;\n \n     template <bool throw_if_denied, bool grant_option, typename... Args>\n-    bool checkAccessImplHelper(AccessFlags flags, const Args &... args) const;\n+    bool checkAccessImplHelper(const ContextPtr & context, AccessFlags flags, const Args &... args) const;\n \n     template <bool throw_if_denied, bool grant_option>\n-    bool checkAccessImplHelper(const AccessRightsElement & element) const;\n+    bool checkAccessImplHelper(const ContextPtr & context, const AccessRightsElement & element) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const UUID & role_id) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const UUID & role_id, const String & role_name) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id, const String & role_name) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const std::vector<UUID> & role_ids) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids, const Strings & names_of_roles) const;\n \n     template <bool throw_if_denied>\n-    bool checkAdminOptionImpl(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n+    bool checkAdminOptionImpl(const ContextPtr & context, const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const;\n \n     template <bool throw_if_denied, typename Container, typename GetNameFunction>\n-    bool checkAdminOptionImplHelper(const Container & role_ids, const GetNameFunction & get_name_function) const;\n+    bool checkAdminOptionImplHelper(const ContextPtr & context, const Container & role_ids, const GetNameFunction & get_name_function) const;\n \n     const AccessControl * access_control = nullptr;\n     const Params params;\n@@ -203,4 +206,115 @@ class ContextAccess : public std::enable_shared_from_this<ContextAccess>\n     mutable std::shared_ptr<const EnabledSettings> enabled_settings TSA_GUARDED_BY(mutex);\n };\n \n+/// This wrapper was added to be able to pass the current context to the access\n+/// without the need to change the signature and all calls to the ContextAccess itself.\n+/// Right now a context is used to store privileges that are checked for a query,\n+/// and might be useful for something else in the future as well.\n+class ContextAccessWrapper : public std::enable_shared_from_this<ContextAccessWrapper>\n+{\n+public:\n+    using ContextAccessPtr = std::shared_ptr<const ContextAccess>;\n+\n+    ContextAccessWrapper(const ContextAccessPtr & access_, const ContextPtr & context_): access(access_), context(context_) {}\n+    ~ContextAccessWrapper() = default;\n+\n+    static std::shared_ptr<const ContextAccessWrapper> fromContext(const ContextPtr & context);\n+\n+    const ContextAccess::Params & getParams() const { return access->getParams(); }\n+\n+    const ContextAccessPtr & getAccess() const { return access; }\n+\n+    /// Returns the current user. Throws if user is nullptr.\n+    ALWAYS_INLINE UserPtr getUser() const { return access->getUser(); }\n+    /// Same as above, but can return nullptr.\n+    ALWAYS_INLINE UserPtr tryGetUser() const { return access->tryGetUser(); }\n+    ALWAYS_INLINE String getUserName() const { return access->getUserName(); }\n+    ALWAYS_INLINE std::optional<UUID> getUserID() const { return access->getUserID(); }\n+\n+    /// Returns information about current and enabled roles.\n+    ALWAYS_INLINE std::shared_ptr<const EnabledRolesInfo> getRolesInfo() const { return access->getRolesInfo(); }\n+\n+    /// Returns the row policy filter for a specified table.\n+    /// The function returns nullptr if there is no filter to apply.\n+    ALWAYS_INLINE RowPolicyFilterPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const { return access->getRowPolicyFilter(database, table_name, filter_type); }\n+\n+    /// Returns the quota to track resource consumption.\n+    ALWAYS_INLINE std::shared_ptr<const EnabledQuota> getQuota() const { return access->getQuota(); }\n+    ALWAYS_INLINE std::optional<QuotaUsage> getQuotaUsage() const { return access->getQuotaUsage(); }\n+\n+    /// Returns the default settings, i.e. the settings which should be applied on user's login.\n+    ALWAYS_INLINE SettingsChanges getDefaultSettings() const { return access->getDefaultSettings(); }\n+    ALWAYS_INLINE std::shared_ptr<const SettingsProfilesInfo> getDefaultProfileInfo() const { return access->getDefaultProfileInfo(); }\n+\n+    /// Returns the current access rights.\n+    ALWAYS_INLINE std::shared_ptr<const AccessRights> getAccessRights() const { return access->getAccessRights(); }\n+    ALWAYS_INLINE std::shared_ptr<const AccessRights> getAccessRightsWithImplicit() const { return access->getAccessRightsWithImplicit(); }\n+\n+    /// Checks if a specified access is granted, and throws an exception if not.\n+    /// Empty database means the current database.\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags) const { access->checkAccess(context, flags); }\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags, std::string_view database) const { access->checkAccess(context, flags, database); }\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table) const { access->checkAccess(context, flags, database, table); }\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { access->checkAccess(context, flags, database, table, column); }\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { access->checkAccess(context, flags, database, table, columns); }\n+    ALWAYS_INLINE void checkAccess(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { access->checkAccess(context, flags, database, table, columns); }\n+    ALWAYS_INLINE void checkAccess(const AccessRightsElement & element) const { access->checkAccess(context, element); }\n+    ALWAYS_INLINE void checkAccess(const AccessRightsElements & elements) const { access->checkAccess(context, elements); }\n+\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags) const { access->checkGrantOption(context, flags); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags, std::string_view database) const { access->checkGrantOption(context, flags, database); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const { access->checkGrantOption(context, flags, database, table); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { access->checkGrantOption(context, flags, database, table, column); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { access->checkGrantOption(context, flags, database, table, columns); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { access->checkGrantOption(context, flags, database, table, columns); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessRightsElement & element) const { access->checkGrantOption(context, element); }\n+    ALWAYS_INLINE void checkGrantOption(const AccessRightsElements & elements) const { access->checkGrantOption(context, elements); }\n+\n+    /// Checks if a specified access is granted, and returns false if not.\n+    /// Empty database means the current database.\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags) const { return access->isGranted(context, flags); }\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags, std::string_view database) const { return access->isGranted(context, flags, database); }\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table) const { return access->isGranted(context, flags, database, table); }\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return access->isGranted(context, flags, database, table, column); }\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return access->isGranted(context, flags, database, table, columns); }\n+    ALWAYS_INLINE bool isGranted(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return access->isGranted(context, flags, database, table, columns); }\n+    ALWAYS_INLINE bool isGranted(const AccessRightsElement & element) const { return access->isGranted(context, element); }\n+    ALWAYS_INLINE bool isGranted(const AccessRightsElements & elements) const { return access->isGranted(context, elements); }\n+\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags) const { return access->hasGrantOption(context, flags); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags, std::string_view database) const { return access->hasGrantOption(context, flags, database); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table) const { return access->hasGrantOption(context, flags, database, table); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, std::string_view column) const { return access->hasGrantOption(context, flags, database, table, column); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const std::vector<std::string_view> & columns) const { return access->hasGrantOption(context, flags, database, table, columns); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessFlags & flags, std::string_view database, std::string_view table, const Strings & columns) const { return access->hasGrantOption(context, flags, database, table, columns); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessRightsElement & element) const { return access->hasGrantOption(context, element); }\n+    ALWAYS_INLINE bool hasGrantOption(const AccessRightsElements & elements) const { return access->hasGrantOption(context, elements); }\n+\n+    /// Checks if a specified role is granted with admin option, and throws an exception if not.\n+    ALWAYS_INLINE void checkAdminOption(const UUID & role_id) const { access->checkAdminOption(context, role_id); }\n+    ALWAYS_INLINE void checkAdminOption(const UUID & role_id, const String & role_name) const { access->checkAdminOption(context, role_id, role_name); }\n+    ALWAYS_INLINE void checkAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { access->checkAdminOption(context, role_id, names_of_roles); }\n+    ALWAYS_INLINE void checkAdminOption(const std::vector<UUID> & role_ids) const { access->checkAdminOption(context, role_ids); }\n+    ALWAYS_INLINE void checkAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { access->checkAdminOption(context, role_ids, names_of_roles); }\n+    ALWAYS_INLINE void checkAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { access->checkAdminOption(context, role_ids, names_of_roles); }\n+\n+    /// Checks if a specified role is granted with admin option, and returns false if not.\n+    ALWAYS_INLINE bool hasAdminOption(const UUID & role_id) const { return access->hasAdminOption(context, role_id); }\n+    ALWAYS_INLINE bool hasAdminOption(const UUID & role_id, const String & role_name) const { return access->hasAdminOption(context, role_id, role_name); }\n+    ALWAYS_INLINE bool hasAdminOption(const UUID & role_id, const std::unordered_map<UUID, String> & names_of_roles) const { return access->hasAdminOption(context, role_id, names_of_roles); }\n+    ALWAYS_INLINE bool hasAdminOption(const std::vector<UUID> & role_ids) const { return access->hasAdminOption(context, role_ids); }\n+    ALWAYS_INLINE bool hasAdminOption(const std::vector<UUID> & role_ids, const Strings & names_of_roles) const { return access->hasAdminOption(context, role_ids, names_of_roles); }\n+    ALWAYS_INLINE bool hasAdminOption(const std::vector<UUID> & role_ids, const std::unordered_map<UUID, String> & names_of_roles) const { return access->hasAdminOption(context, role_ids, names_of_roles); }\n+\n+    /// Checks if a grantee is allowed for the current user, throws an exception if not.\n+    ALWAYS_INLINE void checkGranteeIsAllowed(const UUID & grantee_id, const IAccessEntity & grantee) const { access->checkGranteeIsAllowed(grantee_id, grantee); }\n+    /// Checks if grantees are allowed for the current user, throws an exception if not.\n+    ALWAYS_INLINE void checkGranteesAreAllowed(const std::vector<UUID> & grantee_ids) const { access->checkGranteesAreAllowed(grantee_ids); }\n+\n+private:\n+    ContextAccessPtr access;\n+    ContextPtr context;\n+};\n+\n+\n }\ndiff --git a/src/Interpreters/Access/InterpreterGrantQuery.cpp b/src/Interpreters/Access/InterpreterGrantQuery.cpp\nindex 6a46ac9c330a..ac3b549a5767 100644\n--- a/src/Interpreters/Access/InterpreterGrantQuery.cpp\n+++ b/src/Interpreters/Access/InterpreterGrantQuery.cpp\n@@ -118,7 +118,7 @@ namespace\n     /// Checks if the current user has enough access rights granted with grant option to grant or revoke specified access rights.\n     void checkGrantOption(\n         const AccessControl & access_control,\n-        const ContextAccess & current_user_access,\n+        const ContextAccessWrapper & current_user_access,\n         const std::vector<UUID> & grantees_from_query,\n         bool & need_check_grantees_are_allowed,\n         const AccessRightsElements & elements_to_grant,\n@@ -200,7 +200,7 @@ namespace\n     /// Checks if the current user has enough roles granted with admin option to grant or revoke specified roles.\n     void checkAdminOption(\n         const AccessControl & access_control,\n-        const ContextAccess & current_user_access,\n+        const ContextAccessWrapper & current_user_access,\n         const std::vector<UUID> & grantees_from_query,\n         bool & need_check_grantees_are_allowed,\n         const std::vector<UUID> & roles_to_grant,\n@@ -277,7 +277,7 @@ namespace\n     /// This function is less accurate than checkAdminOption() because it cannot use any information about\n     /// granted roles the grantees currently have (due to those grantees are located on multiple nodes,\n     /// we just don't have the full information about them).\n-    void checkAdminOptionForExecutingOnCluster(const ContextAccess & current_user_access,\n+    void checkAdminOptionForExecutingOnCluster(const ContextAccessWrapper & current_user_access,\n                                                const std::vector<UUID> roles_to_grant,\n                                                const RolesOrUsersSet & roles_to_revoke)\n     {\n@@ -376,7 +376,7 @@ namespace\n     /// Calculates all available rights to grant with current user intersection.\n     void calculateCurrentGrantRightsWithIntersection(\n         AccessRights & rights,\n-        std::shared_ptr<const ContextAccess> current_user_access,\n+        std::shared_ptr<const ContextAccessWrapper> current_user_access,\n         const AccessRightsElements & elements_to_grant)\n     {\n         AccessRightsElements current_user_grantable_elements;\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 4b0ebc008ea3..2807807b2941 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -835,6 +835,7 @@ ContextMutablePtr Context::createGlobal(ContextSharedPart * shared_part)\n     auto res = std::shared_ptr<Context>(new Context);\n     res->shared = shared_part;\n     res->query_access_info = std::make_shared<QueryAccessInfo>();\n+    res->query_privileges_info = std::make_shared<QueryPrivilegesInfo>();\n     return res;\n }\n \n@@ -1427,7 +1428,7 @@ void Context::checkAccess(const AccessFlags & flags, const StorageID & table_id,\n void Context::checkAccess(const AccessRightsElement & element) const { checkAccessImpl(element); }\n void Context::checkAccess(const AccessRightsElements & elements) const { checkAccessImpl(elements); }\n \n-std::shared_ptr<const ContextAccess> Context::getAccess() const\n+std::shared_ptr<const ContextAccessWrapper> Context::getAccess() const\n {\n     /// A helper function to collect parameters for calculating access rights, called with Context::getLocalSharedLock() acquired.\n     auto get_params = [this]()\n@@ -1444,14 +1445,14 @@ std::shared_ptr<const ContextAccess> Context::getAccess() const\n     {\n         SharedLockGuard lock(mutex);\n         if (access && !need_recalculate_access)\n-            return access; /// No need to recalculate access rights.\n+            return std::make_shared<const ContextAccessWrapper>(access, shared_from_this()); /// No need to recalculate access rights.\n \n         params.emplace(get_params());\n \n         if (access && (access->getParams() == *params))\n         {\n             need_recalculate_access = false;\n-            return access; /// No need to recalculate access rights.\n+            return std::make_shared<const ContextAccessWrapper>(access, shared_from_this()); /// No need to recalculate access rights.\n         }\n     }\n \n@@ -1471,7 +1472,7 @@ std::shared_ptr<const ContextAccess> Context::getAccess() const\n         }\n     }\n \n-    return res;\n+    return std::make_shared<const ContextAccessWrapper>(res, shared_from_this());\n }\n \n RowPolicyFilterPtr Context::getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const\n@@ -1857,6 +1858,15 @@ void Context::addQueryFactoriesInfo(QueryLogFactories factory_type, const String\n     }\n }\n \n+void Context::addQueryPrivilegesInfo(const String & privilege, bool granted) const\n+{\n+    std::lock_guard lock(query_privileges_info->mutex);\n+    if (granted)\n+        query_privileges_info->used_privileges.emplace(privilege);\n+    else\n+        query_privileges_info->missing_privileges.emplace(privilege);\n+}\n+\n static bool findIdentifier(const ASTFunction * function)\n {\n     if (!function || !function->arguments)\n@@ -2538,6 +2548,7 @@ void Context::makeQueryContext()\n     local_read_query_throttler.reset();\n     local_write_query_throttler.reset();\n     backups_query_throttler.reset();\n+    query_privileges_info = std::make_shared<QueryPrivilegesInfo>(*query_privileges_info);\n }\n \n void Context::makeQueryContextForMerge(const MergeTreeSettings & merge_tree_settings)\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex f3073ccc09c4..b3ade94ccdc5 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -50,6 +50,7 @@ class ASTSelectQuery;\n \n struct ContextSharedPart;\n class ContextAccess;\n+class ContextAccessWrapper;\n struct User;\n using UserPtr = std::shared_ptr<const User>;\n struct SettingsProfilesInfo;\n@@ -403,9 +404,31 @@ class ContextData\n         mutable std::mutex mutex;\n     };\n \n+    struct QueryPrivilegesInfo\n+    {\n+        QueryPrivilegesInfo() = default;\n+\n+        QueryPrivilegesInfo(const QueryPrivilegesInfo & rhs)\n+        {\n+            std::lock_guard<std::mutex> lock(rhs.mutex);\n+            used_privileges = rhs.used_privileges;\n+            missing_privileges = rhs.missing_privileges;\n+        }\n+\n+        QueryPrivilegesInfo(QueryPrivilegesInfo && rhs) = delete;\n+\n+        std::unordered_set<std::string> used_privileges TSA_GUARDED_BY(mutex);\n+        std::unordered_set<std::string> missing_privileges TSA_GUARDED_BY(mutex);\n+\n+        mutable std::mutex mutex;\n+    };\n+\n+    using QueryPrivilegesInfoPtr = std::shared_ptr<QueryPrivilegesInfo>;\n+\n protected:\n     /// Needs to be changed while having const context in factories methods\n     mutable QueryFactoriesInfo query_factories_info;\n+    QueryPrivilegesInfoPtr query_privileges_info;\n     /// Query metrics for reading data asynchronously with IAsynchronousReader.\n     mutable std::shared_ptr<AsyncReadCounters> async_read_counters;\n \n@@ -612,7 +635,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     void checkAccess(const AccessRightsElement & element) const;\n     void checkAccess(const AccessRightsElements & elements) const;\n \n-    std::shared_ptr<const ContextAccess> getAccess() const;\n+    std::shared_ptr<const ContextAccessWrapper> getAccess() const;\n \n     RowPolicyFilterPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const;\n \n@@ -741,6 +764,10 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     QueryFactoriesInfo getQueryFactoriesInfo() const;\n     void addQueryFactoriesInfo(QueryLogFactories factory_type, const String & created_object) const;\n \n+    const QueryPrivilegesInfo & getQueryPrivilegesInfo() const { return *getQueryPrivilegesInfoPtr(); }\n+    QueryPrivilegesInfoPtr getQueryPrivilegesInfoPtr() const { return query_privileges_info; }\n+    void addQueryPrivilegesInfo(const String & privilege, bool granted) const;\n+\n     /// For table functions s3/file/url/hdfs/input we can use structure from\n     /// insertion table depending on select expression.\n     StoragePtr executeTableFunction(const ASTPtr & table_expression, const ASTSelectQuery * select_query_hint = nullptr);\ndiff --git a/src/Interpreters/QueryLog.cpp b/src/Interpreters/QueryLog.cpp\nindex 92f8ddae1416..e63a2ae31aab 100644\n--- a/src/Interpreters/QueryLog.cpp\n+++ b/src/Interpreters/QueryLog.cpp\n@@ -136,6 +136,9 @@ ColumnsDescription QueryLogElement::getColumnsDescription()\n \n         {\"used_row_policies\", array_low_cardinality_string, \"The list of row policies names that were used during query execution.\"},\n \n+        {\"used_privileges\", array_low_cardinality_string, \"Privileges which were successfully checked during query execution.\"},\n+        {\"missing_privileges\", array_low_cardinality_string, \"Privileges that are missing during query execution.\"},\n+\n         {\"transaction_id\", getTransactionIDDataType(), \"The identifier of the transaction in scope of which this query was executed.\"},\n \n         {\"query_cache_usage\", std::move(query_cache_usage_datatype), \"Usage of the query cache during query execution. Values: 'Unknown' = Status unknown, 'None' = The query result was neither written into nor read from the query cache, 'Write' = The query result was written into the query cache, 'Read' = The query result was read from the query cache.\"},\n@@ -267,6 +270,8 @@ void QueryLogElement::appendToBlock(MutableColumns & columns) const\n         auto & column_storage_factory_objects = typeid_cast<ColumnArray &>(*columns[i++]);\n         auto & column_table_function_factory_objects = typeid_cast<ColumnArray &>(*columns[i++]);\n         auto & column_row_policies_names = typeid_cast<ColumnArray &>(*columns[i++]);\n+        auto & column_used_privileges = typeid_cast<ColumnArray &>(*columns[i++]);\n+        auto & column_missing_privileges = typeid_cast<ColumnArray &>(*columns[i++]);\n \n         auto fill_column = [](const auto & data, ColumnArray & column)\n         {\n@@ -290,6 +295,8 @@ void QueryLogElement::appendToBlock(MutableColumns & columns) const\n         fill_column(used_storages, column_storage_factory_objects);\n         fill_column(used_table_functions, column_table_function_factory_objects);\n         fill_column(used_row_policies, column_row_policies_names);\n+        fill_column(used_privileges, column_used_privileges);\n+        fill_column(missing_privileges, column_missing_privileges);\n     }\n \n     columns[i++]->insert(Tuple{tid.start_csn, tid.local_tid, tid.host_id});\ndiff --git a/src/Interpreters/QueryLog.h b/src/Interpreters/QueryLog.h\nindex 5072d2201608..bbaa71797574 100644\n--- a/src/Interpreters/QueryLog.h\n+++ b/src/Interpreters/QueryLog.h\n@@ -81,6 +81,8 @@ struct QueryLogElement\n     std::unordered_set<String> used_storages;\n     std::unordered_set<String> used_table_functions;\n     std::set<String> used_row_policies;\n+    std::unordered_set<String> used_privileges;\n+    std::unordered_set<String> missing_privileges;\n \n     Int32 exception_code{}; // because ErrorCodes are int\n     String exception;\ndiff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp\nindex 396562189e07..d73593b7f1c5 100644\n--- a/src/Interpreters/Session.cpp\n+++ b/src/Interpreters/Session.cpp\n@@ -694,7 +694,7 @@ void Session::recordLoginSucess(ContextPtr login_context) const\n         session_log->addLoginSuccess(auth_id,\n                                      named_session ? named_session->key.second : \"\",\n                                      settings,\n-                                     access,\n+                                     access->getAccess(),\n                                      getClientInfo(),\n                                      user);\n     }\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 9c5436517ab9..9f33cbf1c270 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -44,6 +44,7 @@\n #include <Formats/FormatFactory.h>\n #include <Storages/StorageInput.h>\n \n+#include <Access/ContextAccess.h>\n #include <Access/EnabledQuota.h>\n #include <Interpreters/ApplyWithGlobalVisitor.h>\n #include <Interpreters/Context.h>\n@@ -221,6 +222,17 @@ static void logException(ContextPtr context, QueryLogElement & elem, bool log_er\n         LOG_INFO(getLogger(\"executeQuery\"), message);\n }\n \n+static void\n+addPrivilegesInfoToQueryLogElement(QueryLogElement & element, const ContextPtr context_ptr)\n+{\n+    const auto & privileges_info = context_ptr->getQueryPrivilegesInfo();\n+    {\n+        std::lock_guard lock(privileges_info.mutex);\n+        element.used_privileges = privileges_info.used_privileges;\n+        element.missing_privileges = privileges_info.missing_privileges;\n+    }\n+}\n+\n static void\n addStatusInfoToQueryLogElement(QueryLogElement & element, const QueryStatusInfo & info, const ASTPtr query_ast, const ContextPtr context_ptr)\n {\n@@ -286,6 +298,7 @@ addStatusInfoToQueryLogElement(QueryLogElement & element, const QueryStatusInfo\n     }\n \n     element.async_read_counters = context_ptr->getAsyncReadCounters();\n+    addPrivilegesInfoToQueryLogElement(element, context_ptr);\n }\n \n \n@@ -601,6 +614,8 @@ void logExceptionBeforeStart(\n             elem.formatted_query = queryToString(ast);\n     }\n \n+    addPrivilegesInfoToQueryLogElement(elem, context);\n+\n     // We don't calculate databases, tables and columns when the query isn't able to start\n \n     elem.exception_code = getCurrentExceptionCode();\ndiff --git a/src/Storages/System/StorageSystemColumns.cpp b/src/Storages/System/StorageSystemColumns.cpp\nindex 49da1eba9ec2..8dd8d3b6154b 100644\n--- a/src/Storages/System/StorageSystemColumns.cpp\n+++ b/src/Storages/System/StorageSystemColumns.cpp\n@@ -298,7 +298,7 @@ class ColumnsSource : public ISource\n     ClientInfo::Interface client_info_interface;\n     size_t db_table_num = 0;\n     size_t total_tables;\n-    std::shared_ptr<const ContextAccess> access;\n+    std::shared_ptr<const ContextAccessWrapper> access;\n     bool need_to_check_access_for_tables;\n     String query_id;\n     std::chrono::milliseconds lock_acquire_timeout;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03168_query_log_privileges_not_empty.reference b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.reference\nnew file mode 100644\nindex 000000000000..e3ac97f9945a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.reference\n@@ -0,0 +1,5 @@\n+1\n+3168\t8613\n+[]\t['SELECT(a, b) ON default.d_03168_query_log']\n+[]\t[]\n+['SELECT(a, b) ON default.d_03168_query_log']\t[]\ndiff --git a/tests/queries/0_stateless/03168_query_log_privileges_not_empty.sh b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.sh\nnew file mode 100755\nindex 000000000000..9abc635a8741\n--- /dev/null\n+++ b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.sh\n@@ -0,0 +1,32 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+user_name=\"u_03168_query_log\"\n+table_name=\"default.d_03168_query_log\"\n+test_query=\"select a, b from ${table_name}\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --query \"drop user if exists ${user_name}\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"create user ${user_name}\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"drop table if exists ${table_name}\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"create table ${table_name} (a UInt64, b UInt64) order by a\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --query \"insert into table ${table_name} values (3168, 8613)\"\n+\n+error=\"$(${CLICKHOUSE_CLIENT_BINARY} --user ${user_name} --query \"${test_query}\" 2>&1 >/dev/null)\"\n+echo \"${error}\" | grep -Fc \"ACCESS_DENIED\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --query \"grant select(a, b) on ${table_name} to ${user_name}\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --user ${user_name} --query \"${test_query}\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --query \"system flush logs\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"select used_privileges, missing_privileges from system.query_log where query = '${test_query}' and type = 'ExceptionBeforeStart' and current_database = currentDatabase() order by event_time desc limit 1\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"select used_privileges, missing_privileges from system.query_log where query = '${test_query}' and type = 'QueryStart' and current_database = currentDatabase() order by event_time desc limit 1\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"select used_privileges, missing_privileges from system.query_log where query = '${test_query}' and type = 'QueryFinish' and current_database = currentDatabase() order by event_time desc limit 1\"\n+\n+${CLICKHOUSE_CLIENT_BINARY} --query \"drop table ${table_name}\"\n+${CLICKHOUSE_CLIENT_BINARY} --query \"drop user ${user_name}\"\n",
  "problem_statement": "Log down the checked privileges to the system.query_log\n**Use case**\r\n\r\nFor testing purposes we would love to know the set of GRANTs required for the query to be finished successfully (successfully == not receiving ACCESS_DENIED error).\r\n\r\n**Describe the solution you'd like**\r\n\r\nAdd an additional field named `checked_privileges` of type `Array(String)` to the `system.query_log`. It will contain information like `['SELECT ON database.table', 'demangle ON *.*', ...]`.\r\n\r\nP.S. Maybe it is worth to add a field `required_privilege` which will be non-empty in case when the query finished with an error `ACCESS_DENIED`. This is needed mostly not to parse the exception message rather than just executing a simple query. \r\n\n",
  "hints_text": "Keep in mind that the list of columns can be very long, so the data amount for queries over wide tables will increase significantly.",
  "created_at": "2024-05-29T16:20:46Z",
  "modified_files": [
    "docs/en/operations/system-tables/query_log.md",
    "src/Access/CachedAccessChecking.cpp",
    "src/Access/CachedAccessChecking.h",
    "src/Access/ContextAccess.cpp",
    "src/Access/ContextAccess.h",
    "src/Interpreters/Access/InterpreterGrantQuery.cpp",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Interpreters/QueryLog.cpp",
    "src/Interpreters/QueryLog.h",
    "src/Interpreters/Session.cpp",
    "src/Interpreters/executeQuery.cpp",
    "src/Storages/System/StorageSystemColumns.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.reference",
    "b/tests/queries/0_stateless/03168_query_log_privileges_not_empty.sh"
  ]
}