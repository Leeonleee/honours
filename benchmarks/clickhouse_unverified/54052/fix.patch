diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp
index 4260d7bd6603..7a405a2ef783 100644
--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp
+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp
@@ -12,6 +12,7 @@
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypeObject.h>
 #include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeMap.h>
@@ -2426,6 +2427,20 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromCompoundExpression(const
             compound_expression_from_error_message += compound_expression_source;
         }
 
+        if (auto * column = compound_expression->as<ColumnNode>())
+        {
+            const DataTypePtr & column_type = column->getColumn().getTypeInStorage();
+            if (column_type->getTypeId() == TypeIndex::Object)
+            {
+                const auto * object_type = checkAndGetDataType<DataTypeObject>(column_type.get());
+                if (object_type->getSchemaFormat() == "json" && object_type->hasNullableSubcolumns())
+                {
+                    QueryTreeNodePtr constant_node_null = std::make_shared<ConstantNode>(Field());
+                    return constant_node_null;
+                }
+            }
+        }
+
         throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER,
             "Identifier {} nested path {} cannot be resolved from type {}{}. In scope {}{}",
             expression_identifier,
@@ -3036,6 +3051,31 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromJoin(const IdentifierLoo
     JoinKind join_kind = from_join_node.getKind();
     bool join_use_nulls = scope.context->getSettingsRef().join_use_nulls;
 
+    /// If columns from left or right table were missed Object(Nullable('json')) subcolumns, they will be replaced
+    /// to ConstantNode(NULL), which can't be cast to ColumnNode, so we resolve it here.
+    if (left_resolved_identifier && right_resolved_identifier && left_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT
+        && right_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)
+    {
+        auto & left_resolved_column = left_resolved_identifier->as<ConstantNode &>();
+        auto & right_resolved_column = right_resolved_identifier->as<ConstantNode &>();
+        if (left_resolved_column.getValueStringRepresentation() == "NULL" && right_resolved_column.getValueStringRepresentation() == "NULL")
+            return left_resolved_identifier;
+    }
+    else if (left_resolved_identifier && left_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)
+    {
+        resolved_side = JoinTableSide::Left;
+        auto & left_resolved_column = left_resolved_identifier->as<ConstantNode &>();
+        if (left_resolved_column.getValueStringRepresentation() == "NULL")
+            return left_resolved_identifier;
+    }
+    else if (right_resolved_identifier && right_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)
+    {
+        resolved_side = JoinTableSide::Right;
+        auto & right_resolved_column = right_resolved_identifier->as<ConstantNode &>();
+        if (right_resolved_column.getValueStringRepresentation() == "NULL")
+            return right_resolved_identifier;
+    }
+
     if (left_resolved_identifier && right_resolved_identifier)
     {
         auto & left_resolved_column = left_resolved_identifier->as<ColumnNode &>();
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index d87ac1ed4359..67187be962ca 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -30,6 +30,7 @@
 #include <Interpreters/getTableExpressions.h>
 #include <Interpreters/replaceAliasColumnsInQuery.h>
 #include <Interpreters/replaceForPositionalArguments.h>
+#include <Interpreters/replaceMissedSubcolumnsInQuery.h>
 
 #include <Functions/UserDefined/UserDefinedSQLFunctionFactory.h>
 #include <Functions/UserDefined/UserDefinedSQLFunctionVisitor.h>
@@ -48,6 +49,7 @@
 
 #include <DataTypes/NestedUtils.h>
 #include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypeObject.h>
 #include <DataTypes/DataTypeLowCardinality.h>
 
 #include <IO/WriteHelpers.h>
@@ -948,6 +950,10 @@ void TreeRewriterResult::collectSourceColumns(bool add_special)
             source_columns.swap(columns_from_storage);
         else
             source_columns.insert(source_columns.end(), columns_from_storage.begin(), columns_from_storage.end());
+
+        auto metadata_snapshot = storage->getInMemoryMetadataPtr();
+        auto metadata_column_descriptions = metadata_snapshot->getColumns();
+        source_columns_ordinary = metadata_column_descriptions.getOrdinary();
     }
 
     source_columns_set = removeDuplicateColumns(source_columns);
@@ -1117,6 +1123,33 @@ bool TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select
         }
     }
 
+    /// Collect missed object subcolumns
+    if (!unknown_required_source_columns.empty())
+    {
+        for (const NameAndTypePair & pair : source_columns_ordinary)
+        {
+            for (auto it = unknown_required_source_columns.begin(); it != unknown_required_source_columns.end();)
+            {
+                size_t object_pos = it->find('.');
+                if (object_pos != std::string::npos)
+                {
+                    String object_name = it->substr(0, object_pos);
+                    if (pair.name == object_name && pair.type->getTypeId() == TypeIndex::Object)
+                    {
+                        const auto * object_type = typeid_cast<const DataTypeObject *>(pair.type.get());
+                        if (object_type->getSchemaFormat() == "json" && object_type->hasNullableSubcolumns())
+                        {
+                            missed_subcolumns.insert(*it);
+                            it = unknown_required_source_columns.erase(it);
+                            continue;
+                        }
+                    }
+                }
+                ++it;
+            }
+        }
+    }
+
     if (!unknown_required_source_columns.empty())
     {
         constexpr auto format_string = "Missing columns: {} while processing query: '{}', required columns:{}{}";
@@ -1301,6 +1334,13 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(
 
     result.collectUsedColumns(query, true, settings.query_plan_optimize_primary_key);
 
+    if (!result.missed_subcolumns.empty())
+    {
+        for (const String & column_name : result.missed_subcolumns)
+            replaceMissedSubcolumnsInQuery(query, column_name);
+        result.missed_subcolumns.clear();
+    }
+
     result.required_source_columns_before_expanding_alias_columns = result.required_source_columns.getNames();
 
     /// rewrite filters for select query, must go after getArrayJoinedColumns
@@ -1399,6 +1439,14 @@ TreeRewriterResultPtr TreeRewriter::analyze(
     bool is_ok = result.collectUsedColumns(query, false, settings.query_plan_optimize_primary_key, no_throw);
     if (!is_ok)
         return {};
+
+    if (!result.missed_subcolumns.empty())
+    {
+        for (const String & column_name : result.missed_subcolumns)
+            replaceMissedSubcolumnsInQuery(query, column_name);
+        result.missed_subcolumns.clear();
+    }
+
     return std::make_shared<const TreeRewriterResult>(result);
 }
 
diff --git a/src/Interpreters/TreeRewriter.h b/src/Interpreters/TreeRewriter.h
index 60832f49b355..75d8fcf0223e 100644
--- a/src/Interpreters/TreeRewriter.h
+++ b/src/Interpreters/TreeRewriter.h
@@ -36,6 +36,11 @@ struct TreeRewriterResult
     /// Same as above but also record alias columns which are expanded. This is for RBAC access check.
     Names required_source_columns_before_expanding_alias_columns;
 
+    /// Set of columns that object columns are not extended. This is for distinguishing JSON and Tuple type.
+    NamesAndTypesList source_columns_ordinary;
+
+    NameSet missed_subcolumns;
+
     /// Set of alias columns that are expanded to their alias expressions. We still need the original columns to check access permission.
     NameSet expanded_aliases;
 
diff --git a/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp b/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp
new file mode 100644
index 000000000000..f8e628c0a342
--- /dev/null
+++ b/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp
@@ -0,0 +1,70 @@
+#include <Interpreters/replaceMissedSubcolumnsInQuery.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTLiteral.h>
+
+namespace DB
+{
+
+bool replaceMissedSubcolumnsInFunction(ASTPtr & ast, const String & column_name)
+{
+    bool is_replaced = false;
+
+    if (auto * identifier = ast->as<ASTIdentifier>())
+    {
+        if (column_name == identifier->getColumnName())
+        {
+            ast = std::make_shared<ASTLiteral>(Field());
+            return true;
+        }
+    }
+    else if (auto * node = ast->as<ASTFunction>())
+    {
+        if (node->arguments)
+        {
+            size_t num_arguments = node->arguments->children.size();
+            for (size_t arg = 0; arg < num_arguments; ++arg)
+            {
+                auto & child = node->arguments->children[arg];
+                if (replaceMissedSubcolumnsInFunction(child, column_name))
+                    is_replaced = true;
+            }
+        }
+    }
+    else
+    {
+        for (auto & child : ast->children)
+        {
+            if (replaceMissedSubcolumnsInFunction(child, column_name))
+                is_replaced = true;
+        }
+    }
+
+    return is_replaced;
+}
+
+void replaceMissedSubcolumnsInQuery(ASTPtr & ast, const String & column_name)
+{
+    if (auto * identifier = ast->as<ASTIdentifier>())
+    {
+        if (column_name == identifier->getColumnName())
+        {
+            auto literal = std::make_shared<ASTLiteral>(Field());
+            literal->setAlias(identifier->getAliasOrColumnName());
+            ast = literal;
+        }
+    }
+    else if (auto * node = ast->as<ASTFunction>())
+    {
+        String function_alias = node->getAliasOrColumnName();
+        if (replaceMissedSubcolumnsInFunction(ast, column_name))
+            ast->setAlias(function_alias);
+    }
+    else
+    {
+        for (auto & child : ast->children)
+            replaceMissedSubcolumnsInQuery(child, column_name);
+    }
+}
+
+}
diff --git a/src/Interpreters/replaceMissedSubcolumnsInQuery.h b/src/Interpreters/replaceMissedSubcolumnsInQuery.h
new file mode 100644
index 000000000000..7f4b53bbbf2d
--- /dev/null
+++ b/src/Interpreters/replaceMissedSubcolumnsInQuery.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <Core/Names.h>
+#include <Parsers/IAST_fwd.h>
+#include <base/types.h>
+
+namespace DB
+{
+
+/// Replace missed Object(Nullable('json')) subcolumns to NULL in query.
+void replaceMissedSubcolumnsInQuery(ASTPtr & ast, const String & column_name);
+
+/// Return true if the ASTFunction has missed object subcolumns.
+/// Resolving ASTFunction independently is because we may lose the column name of missed object subcolumns.
+/// For example, if `b.d` is a missed object subcolumn, the column name of `b.d * 2 + 3` will be `plus(multiply(NULL, 2), 3)`,
+/// while we want to keep it as `plus(multiply(b.d, 2), 3)`.
+bool replaceMissedSubcolumnsInFunction(ASTPtr & ast, const String & column_name);
+
+}
+
diff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
index 6ba0d4dcfad3..a586997360af 100644
--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
@@ -119,7 +119,11 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(
     addTotalRowsApprox(data_part->rows_count);
 
     /// Add columns because we don't want to read empty blocks
-    injectRequiredColumns(LoadedMergeTreeDataPartInfoForReader(data_part, alter_conversions), storage_snapshot, /*with_subcolumns=*/ false, columns_to_read);
+    injectRequiredColumns(
+        LoadedMergeTreeDataPartInfoForReader(data_part, alter_conversions),
+        storage_snapshot,
+        storage.supportsSubcolumns(),
+        columns_to_read);
 
     NamesAndTypesList columns_for_reader;
     if (take_column_types_from_storage)
@@ -127,6 +131,8 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(
         auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical)
             .withExtendedObjects()
             .withSystemColumns();
+        if (storage.supportsSubcolumns())
+            options.withSubcolumns();
         columns_for_reader = storage_snapshot->getColumnsByNames(options, columns_to_read);
     }
     else
diff --git a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
index 17078d3e73b1..96b211085c10 100644
--- a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
+++ b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
@@ -52,9 +52,10 @@ class StorageFromMergeTreeDataPart final : public IStorage
         if (!hasDynamicSubcolumns(storage_columns))
             return std::make_shared<StorageSnapshot>(*this, metadata_snapshot);
 
+        auto data_parts = storage.getDataPartsVectorForInternalUsage();
+
         auto object_columns = getConcreteObjectColumns(
-            parts.begin(), parts.end(),
-            storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });
+            data_parts.begin(), data_parts.end(), storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });
 
         return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, std::move(object_columns));
     }
@@ -89,6 +90,8 @@ class StorageFromMergeTreeDataPart final : public IStorage
 
     bool supportsDynamicSubcolumns() const override { return true; }
 
+    bool supportsSubcolumns() const override { return true; }
+
     bool mayBenefitFromIndexForIn(
         const ASTPtr & left_in_operand, ContextPtr query_context, const StorageMetadataPtr & metadata_snapshot) const override
     {
