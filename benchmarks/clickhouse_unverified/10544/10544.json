{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10544,
  "instance_id": "ClickHouse__ClickHouse-10544",
  "issue_numbers": [
    "8787"
  ],
  "base_commit": "228dbf475e5a21091bfaa6b631c4df3d39d8c486",
  "patch": "diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 144ddc391de9..7358102456c5 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -29,7 +29,7 @@\n #include <Common/getMultipleKeysFromConfig.h>\n #include <Common/getNumberOfPhysicalCPUCores.h>\n #include <Common/getExecutablePath.h>\n-#include <Common/TaskStatsInfoGetter.h>\n+#include <Common/ThreadProfileEvents.h>\n #include <Common/ThreadStatus.h>\n #include <IO/HTTPCommon.h>\n #include <IO/UseSSL.h>\n@@ -674,11 +674,13 @@ int Server::main(const std::vector<std::string> & /*args*/)\n     }\n \n #if defined(OS_LINUX)\n-    if (!TaskStatsInfoGetter::checkPermissions())\n+    if (!TasksStatsCounters::checkIfAvailable())\n     {\n-        LOG_INFO(log, \"It looks like the process has no CAP_NET_ADMIN capability, 'taskstats' performance statistics will be disabled.\"\n+        LOG_INFO(log, \"It looks like this system does not have procfs mounted at /proc location,\"\n+            \" neither clickhouse-server process has CAP_NET_ADMIN capability.\"\n+            \" 'taskstats' performance statistics will be disabled.\"\n             \" It could happen due to incorrect ClickHouse package installation.\"\n-            \" You could resolve the problem manually with 'sudo setcap cap_net_admin=+ep \" << executable_path << \"'.\"\n+            \" You can try to resolve the problem manually with 'sudo setcap cap_net_admin=+ep \" << executable_path << \"'.\"\n             \" Note that it will not work on 'nosuid' mounted filesystems.\"\n             \" It also doesn't work if you run clickhouse-server inside network namespace as it happens in some containers.\");\n     }\ndiff --git a/src/Common/ProcfsMetricsProvider.cpp b/src/Common/ProcfsMetricsProvider.cpp\nnew file mode 100644\nindex 000000000000..633558a7b67c\n--- /dev/null\n+++ b/src/Common/ProcfsMetricsProvider.cpp\n@@ -0,0 +1,182 @@\n+#include \"ProcfsMetricsProvider.h\"\n+\n+#if defined(__linux__)\n+\n+#include <Common/Exception.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <IO/ReadHelpers.h>\n+\n+#include <common/find_symbols.h>\n+\n+#include <cassert>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <linux/taskstats.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int FILE_DOESNT_EXIST;\n+    extern const int CANNOT_OPEN_FILE;\n+    extern const int CANNOT_READ_FROM_FILE_DESCRIPTOR;\n+}\n+\n+static constexpr auto thread_schedstat = \"/proc/thread-self/schedstat\";\n+static constexpr auto thread_stat = \"/proc/thread-self/stat\";\n+static constexpr auto thread_io = \"/proc/thread-self/io\";\n+\n+\n+namespace\n+{\n+[[noreturn]] inline void throwWithFailedToOpenFile(const std::string & filename)\n+{\n+    throwFromErrno(\n+            \"Cannot open file \" + filename,\n+            errno == ENOENT ? ErrorCodes::FILE_DOESNT_EXIST : ErrorCodes::CANNOT_OPEN_FILE);\n+}\n+\n+ssize_t readFromFD(const int fd, const char * filename, char * buf, size_t buf_size)\n+{\n+    ssize_t res = 0;\n+\n+    do\n+    {\n+        res = ::pread(fd, buf, buf_size, 0);\n+\n+        if (-1 == res)\n+        {\n+            if (errno == EINTR)\n+                continue;\n+\n+            throwFromErrno(\n+                    \"Cannot read from file \" + std::string(filename),\n+                    ErrorCodes::CANNOT_READ_FROM_FILE_DESCRIPTOR);\n+        }\n+\n+        assert(res >= 0);\n+        break;\n+    } while (true);\n+\n+    return res;\n+}\n+}\n+\n+\n+bool ProcfsMetricsProvider::isAvailable() noexcept\n+{\n+    struct stat sb;\n+    int res = ::stat(thread_schedstat, &sb);\n+\n+    /// Verify that procfs is mounted, one of the stats file exists and is a regular file\n+    return res != -1 && (sb.st_mode & S_IFMT) == S_IFREG;\n+}\n+\n+\n+ProcfsMetricsProvider::ProcfsMetricsProvider(const pid_t /*tid*/)\n+{\n+    thread_schedstat_fd = ::open(thread_schedstat, O_RDONLY | O_CLOEXEC);\n+    if (-1 == thread_schedstat_fd)\n+    {\n+        throwWithFailedToOpenFile(thread_schedstat);\n+    }\n+    thread_stat_fd = ::open(thread_stat, O_RDONLY | O_CLOEXEC);\n+    if (-1 == thread_stat_fd)\n+    {\n+        ::close(thread_schedstat_fd);\n+        throwWithFailedToOpenFile(thread_stat);\n+    }\n+    thread_io_fd = ::open(thread_io, O_RDONLY | O_CLOEXEC);\n+    if (-1 != thread_io_fd)\n+    {\n+        stats_version = 3;\n+    }\n+}\n+\n+\n+ProcfsMetricsProvider::~ProcfsMetricsProvider()\n+{\n+    if (stats_version >= 3 && 0 != ::close(thread_io_fd))\n+        tryLogCurrentException(__PRETTY_FUNCTION__);\n+    if (0 != ::close(thread_stat_fd))\n+        tryLogCurrentException(__PRETTY_FUNCTION__);\n+    if (0 != ::close(thread_schedstat_fd))\n+        tryLogCurrentException(__PRETTY_FUNCTION__);\n+}\n+\n+\n+void ProcfsMetricsProvider::getTaskStats(::taskstats & out_stats) const\n+{\n+    constexpr size_t buf_size = 1024;\n+    char buf[buf_size];\n+\n+    out_stats.version = stats_version;\n+\n+    readParseAndSetThreadCPUStat(out_stats, buf, buf_size);\n+    readParseAndSetThreadBlkIOStat(out_stats, buf, buf_size);\n+\n+    if (stats_version >= 3)\n+    {\n+        readParseAndSetThreadIOStat(out_stats, buf, buf_size);\n+    }\n+}\n+\n+\n+void ProcfsMetricsProvider::readParseAndSetThreadCPUStat(::taskstats & out_stats, char * buf, size_t buf_size) const\n+{\n+    ssize_t res = readFromFD(thread_schedstat_fd, thread_schedstat, buf, buf_size);\n+    ReadBufferFromMemory in_schedstat(buf, res);\n+\n+    readIntText(out_stats.cpu_run_virtual_total, in_schedstat);\n+    skipWhitespaceIfAny(in_schedstat);\n+    readIntText(out_stats.cpu_delay_total, in_schedstat);\n+}\n+\n+\n+void ProcfsMetricsProvider::readParseAndSetThreadBlkIOStat(::taskstats & out_stats, char * buf, size_t buf_size) const\n+{\n+    ssize_t res = readFromFD(thread_stat_fd, thread_stat, buf, buf_size - 1);\n+    ReadBufferFromMemory in_stat(buf, res);\n+\n+    /// We need to skip the first 41 fields of the string read from /proc/thread-self/stat.\n+    for (int i = 0; i < 41; ++i)\n+    {\n+        in_stat.position() = find_first_symbols<' ', '\\t'>(in_stat.position(), in_stat.buffer().end());\n+        skipWhitespaceIfAny(in_stat);\n+    }\n+\n+    /// Read field #42 - Aggregated block I/O delays, measured in clock ticks (centiseconds)\n+    readIntText(out_stats.blkio_delay_total, in_stat);\n+    out_stats.blkio_delay_total *= 10000000ul;  /// We need to return time in nanoseconds\n+}\n+\n+\n+void ProcfsMetricsProvider::readParseAndSetThreadIOStat(::taskstats & out_stats, char * buf, size_t buf_size) const\n+{\n+    ssize_t res = readFromFD(thread_io_fd, thread_io, buf, buf_size);\n+    ReadBufferFromMemory in_thread_io(buf, res);\n+\n+    assertString(\"rchar:\", in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    readIntText(out_stats.read_char, in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    assertString(\"wchar:\", in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    readIntText(out_stats.write_char, in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    skipToNextLineOrEOF(in_thread_io);\n+    skipToNextLineOrEOF(in_thread_io);\n+    assertString(\"read_bytes:\", in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    readIntText(out_stats.read_bytes, in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    assertString(\"write_bytes:\", in_thread_io);\n+    skipWhitespaceIfAny(in_thread_io);\n+    readIntText(out_stats.write_bytes, in_thread_io);\n+}\n+}\n+\n+#endif\ndiff --git a/src/Common/ProcfsMetricsProvider.h b/src/Common/ProcfsMetricsProvider.h\nnew file mode 100644\nindex 000000000000..60eb94bfcc55\n--- /dev/null\n+++ b/src/Common/ProcfsMetricsProvider.h\n@@ -0,0 +1,44 @@\n+#pragma once\n+\n+#include <sys/types.h>\n+#include <boost/noncopyable.hpp>\n+\n+\n+#if defined(__linux__)\n+struct taskstats;\n+\n+namespace DB\n+{\n+/// Provides several essential per-task metrics by reading data from Procfs (when available).\n+class ProcfsMetricsProvider : private boost::noncopyable\n+{\n+public:\n+    ProcfsMetricsProvider(const pid_t /*tid*/);\n+    ~ProcfsMetricsProvider();\n+\n+    /// Updates only a part of taskstats struct's fields:\n+    ///  - cpu_run_virtual_total, cpu_delay_total (when /proc/thread-self/schedstat is available)\n+    ///  - blkio_delay_total                      (when /proc/thread-self/stat is available)\n+    ///  - rchar, wchar, read_bytes, write_bytes  (when /prod/thread-self/io is available)\n+    /// See: man procfs\n+    void getTaskStats(::taskstats & out_stats) const;\n+\n+    /// Tells whether this metrics (via Procfs) is provided on the current platform\n+    static bool isAvailable() noexcept;\n+\n+private:\n+    void readParseAndSetThreadCPUStat(::taskstats & out_stats, char *, size_t) const;\n+    void readParseAndSetThreadBlkIOStat(::taskstats & out_stats, char *, size_t) const;\n+    void readParseAndSetThreadIOStat(::taskstats & out_stats, char *, size_t) const;\n+\n+private:\n+    int thread_schedstat_fd = -1;\n+    int thread_stat_fd = -1;\n+    int thread_io_fd = -1;\n+\n+    /// This field is used for compatibility with TasksStatsCounters::incrementProfileEvents()\n+    unsigned short stats_version = 1;\n+};\n+\n+}\n+#endif\ndiff --git a/src/Common/ThreadProfileEvents.cpp b/src/Common/ThreadProfileEvents.cpp\nnew file mode 100644\nindex 000000000000..42452bf590b3\n--- /dev/null\n+++ b/src/Common/ThreadProfileEvents.cpp\n@@ -0,0 +1,109 @@\n+#include \"ThreadProfileEvents.h\"\n+\n+#if defined(__linux__)\n+\n+#include \"TaskStatsInfoGetter.h\"\n+#include \"ProcfsMetricsProvider.h\"\n+\n+#include <optional>\n+\n+\n+namespace DB\n+{\n+\n+bool TasksStatsCounters::checkIfAvailable()\n+{\n+    return findBestAvailableProvider() != MetricsProvider::None;\n+}\n+\n+std::unique_ptr<TasksStatsCounters> TasksStatsCounters::create(const UInt64 tid)\n+{\n+    std::unique_ptr<TasksStatsCounters> instance;\n+    if (checkIfAvailable())\n+        instance.reset(new TasksStatsCounters(tid, findBestAvailableProvider()));\n+    return instance;\n+}\n+\n+TasksStatsCounters::MetricsProvider TasksStatsCounters::findBestAvailableProvider()\n+{\n+    /// This initialization is thread-safe and executed once since C++11\n+    static std::optional<MetricsProvider> provider =\n+        []() -> MetricsProvider\n+        {\n+            if (TaskStatsInfoGetter::checkPermissions())\n+            {\n+                return MetricsProvider::Netlink;\n+            }\n+            else if (ProcfsMetricsProvider::isAvailable())\n+            {\n+                return MetricsProvider::Procfs;\n+            }\n+            return MetricsProvider::None;\n+        }();\n+\n+    return *provider;\n+}\n+\n+\n+TasksStatsCounters::TasksStatsCounters(const UInt64 tid, const MetricsProvider provider)\n+{\n+    switch (provider)\n+    {\n+    case MetricsProvider::Netlink:\n+        stats_getter = [metrics_provider = std::make_shared<TaskStatsInfoGetter>(), tid]()\n+                {\n+                    ::taskstats result;\n+                    metrics_provider->getStat(result, tid);\n+                    return result;\n+                };\n+        break;\n+    case MetricsProvider::Procfs:\n+        stats_getter = [metrics_provider = std::make_shared<ProcfsMetricsProvider>(tid)]()\n+                {\n+                    ::taskstats result;\n+                    metrics_provider->getTaskStats(result);\n+                    return result;\n+                };\n+        break;\n+    case MetricsProvider::None:\n+        ;\n+    }\n+}\n+\n+void TasksStatsCounters::reset()\n+{\n+    if (stats_getter)\n+        stats = stats_getter();\n+}\n+\n+void TasksStatsCounters::updateCounters(ProfileEvents::Counters & profile_events)\n+{\n+    if (!stats_getter)\n+        return;\n+\n+    const auto new_stats = stats_getter();\n+    incrementProfileEvents(stats, new_stats, profile_events);\n+    stats = new_stats;\n+}\n+\n+void TasksStatsCounters::incrementProfileEvents(const ::taskstats & prev, const ::taskstats & curr, ProfileEvents::Counters & profile_events)\n+{\n+    profile_events.increment(ProfileEvents::OSCPUWaitMicroseconds,\n+                             safeDiff(prev.cpu_delay_total, curr.cpu_delay_total) / 1000U);\n+    profile_events.increment(ProfileEvents::OSIOWaitMicroseconds,\n+                             safeDiff(prev.blkio_delay_total, curr.blkio_delay_total) / 1000U);\n+    profile_events.increment(ProfileEvents::OSCPUVirtualTimeMicroseconds,\n+                             safeDiff(prev.cpu_run_virtual_total, curr.cpu_run_virtual_total) / 1000U);\n+\n+    /// Since TASKSTATS_VERSION = 3 extended accounting and IO accounting is available.\n+    if (curr.version < 3)\n+        return;\n+\n+    profile_events.increment(ProfileEvents::OSReadChars, safeDiff(prev.read_char, curr.read_char));\n+    profile_events.increment(ProfileEvents::OSWriteChars, safeDiff(prev.write_char, curr.write_char));\n+    profile_events.increment(ProfileEvents::OSReadBytes, safeDiff(prev.read_bytes, curr.read_bytes));\n+    profile_events.increment(ProfileEvents::OSWriteBytes, safeDiff(prev.write_bytes, curr.write_bytes));\n+}\n+}\n+\n+#endif\ndiff --git a/src/Common/ThreadProfileEvents.h b/src/Common/ThreadProfileEvents.h\nindex e17a4066fe6e..038e04c49553 100644\n--- a/src/Common/ThreadProfileEvents.h\n+++ b/src/Common/ThreadProfileEvents.h\n@@ -6,13 +6,13 @@\n #include <sys/resource.h>\n #include <pthread.h>\n \n+\n #if defined(__linux__)\n #include <linux/taskstats.h>\n #else\n struct taskstats {};\n #endif\n \n-\n /** Implement ProfileEvents with statistics about resource consumption of the current thread.\n   */\n \n@@ -37,7 +37,6 @@ namespace ProfileEvents\n #endif\n }\n \n-\n namespace DB\n {\n \n@@ -117,53 +116,48 @@ struct RUsageCounters\n     }\n };\n \n-\n #if defined(__linux__)\n \n-struct TasksStatsCounters\n+class TasksStatsCounters\n {\n-    ::taskstats stat;\n+public:\n+    static bool checkIfAvailable();\n+    static std::unique_ptr<TasksStatsCounters> create(const UInt64 tid);\n \n-    TasksStatsCounters() = default;\n+    void reset();\n+    void updateCounters(ProfileEvents::Counters & profile_events);\n \n-    static TasksStatsCounters current();\n+private:\n+    ::taskstats stats;  //-V730_NOINIT\n+    std::function<::taskstats()> stats_getter;\n \n-    static void incrementProfileEvents(const TasksStatsCounters & prev, const TasksStatsCounters & curr, ProfileEvents::Counters & profile_events)\n+    enum class MetricsProvider\n     {\n-        profile_events.increment(ProfileEvents::OSCPUWaitMicroseconds,\n-                                 safeDiff(prev.stat.cpu_delay_total, curr.stat.cpu_delay_total) / 1000U);\n-        profile_events.increment(ProfileEvents::OSIOWaitMicroseconds,\n-                                 safeDiff(prev.stat.blkio_delay_total, curr.stat.blkio_delay_total) / 1000U);\n-        profile_events.increment(ProfileEvents::OSCPUVirtualTimeMicroseconds,\n-                                 safeDiff(prev.stat.cpu_run_virtual_total, curr.stat.cpu_run_virtual_total) / 1000U);\n-\n-        /// Since TASKSTATS_VERSION = 3 extended accounting and IO accounting is available.\n-        if (curr.stat.version < 3)\n-            return;\n-\n-        profile_events.increment(ProfileEvents::OSReadChars, safeDiff(prev.stat.read_char, curr.stat.read_char));\n-        profile_events.increment(ProfileEvents::OSWriteChars, safeDiff(prev.stat.write_char, curr.stat.write_char));\n-        profile_events.increment(ProfileEvents::OSReadBytes, safeDiff(prev.stat.read_bytes, curr.stat.read_bytes));\n-        profile_events.increment(ProfileEvents::OSWriteBytes, safeDiff(prev.stat.write_bytes, curr.stat.write_bytes));\n-    }\n+        None,\n+        Procfs,\n+        Netlink\n+    };\n \n-    static void updateProfileEvents(TasksStatsCounters & last_counters, ProfileEvents::Counters & profile_events)\n-    {\n-        auto current_counters = current();\n-        incrementProfileEvents(last_counters, current_counters, profile_events);\n-        last_counters = current_counters;\n-    }\n+private:\n+    explicit TasksStatsCounters(const UInt64 tid, const MetricsProvider provider);\n+\n+    static MetricsProvider findBestAvailableProvider();\n+    static void incrementProfileEvents(const ::taskstats & prev, const ::taskstats & curr, ProfileEvents::Counters & profile_events);\n };\n \n #else\n \n-struct TasksStatsCounters\n+class TasksStatsCounters\n {\n-    ::taskstats stat;\n+public:\n+    static bool checkIfAvailable() { return false; }\n+    static std::unique_ptr<TasksStatsCounters> create(const UInt64 /*tid*/) { return {}; }\n+\n+    void reset() {}\n+    void updateCounters(ProfileEvents::Counters &) {}\n \n-    static TasksStatsCounters current();\n-    static void incrementProfileEvents(const TasksStatsCounters &, const TasksStatsCounters &, ProfileEvents::Counters &) {}\n-    static void updateProfileEvents(TasksStatsCounters &, ProfileEvents::Counters &) {}\n+private:\n+    TasksStatsCounters(const UInt64 /*tid*/) {}\n };\n \n #endif\ndiff --git a/src/Common/ThreadStatus.cpp b/src/Common/ThreadStatus.cpp\nindex 13f27f7e3efd..682a4b0a4126 100644\n--- a/src/Common/ThreadStatus.cpp\n+++ b/src/Common/ThreadStatus.cpp\n@@ -3,7 +3,6 @@\n #include <Common/CurrentThread.h>\n #include <Common/Exception.h>\n #include <Common/ThreadProfileEvents.h>\n-#include <Common/TaskStatsInfoGetter.h>\n #include <Common/QueryProfiler.h>\n #include <Common/ThreadStatus.h>\n \n@@ -24,19 +23,10 @@ namespace ErrorCodes\n thread_local ThreadStatus * current_thread = nullptr;\n \n \n-TasksStatsCounters TasksStatsCounters::current()\n-{\n-    TasksStatsCounters res;\n-    CurrentThread::get().taskstats_getter->getStat(res.stat, CurrentThread::get().thread_id);\n-    return res;\n-}\n-\n ThreadStatus::ThreadStatus()\n+    : thread_id{getThreadId()}\n {\n-    thread_id = getThreadId();\n-\n     last_rusage = std::make_unique<RUsageCounters>();\n-    last_taskstats = std::make_unique<TasksStatsCounters>();\n \n     memory_tracker.setDescription(\"(for thread)\");\n     log = &Poco::Logger::get(\"ThreadStatus\");\n@@ -82,22 +72,19 @@ void ThreadStatus::initPerformanceCounters()\n     ++queries_started;\n \n     *last_rusage = RUsageCounters::current(query_start_time_nanoseconds);\n-\n-    try\n+    if (!taskstats)\n     {\n-        if (TaskStatsInfoGetter::checkPermissions())\n+        try\n         {\n-            if (!taskstats_getter)\n-                taskstats_getter = std::make_unique<TaskStatsInfoGetter>();\n-\n-            *last_taskstats = TasksStatsCounters::current();\n+            taskstats = TasksStatsCounters::create(thread_id);\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(log);\n         }\n     }\n-    catch (...)\n-    {\n-        taskstats_getter.reset();\n-        tryLogCurrentException(__PRETTY_FUNCTION__);\n-    }\n+    if (taskstats)\n+        taskstats->reset();\n }\n \n void ThreadStatus::updatePerformanceCounters()\n@@ -105,8 +92,8 @@ void ThreadStatus::updatePerformanceCounters()\n     try\n     {\n         RUsageCounters::updateProfileEvents(*last_rusage, performance_counters);\n-        if (taskstats_getter)\n-            TasksStatsCounters::updateProfileEvents(*last_taskstats, performance_counters);\n+        if (taskstats)\n+            taskstats->updateCounters(performance_counters);\n     }\n     catch (...)\n     {\ndiff --git a/src/Common/ThreadStatus.h b/src/Common/ThreadStatus.h\nindex 31c1a1f55f2b..3de0d8a4b378 100644\n--- a/src/Common/ThreadStatus.h\n+++ b/src/Common/ThreadStatus.h\n@@ -31,7 +31,7 @@ class ThreadStatus;\n class QueryProfilerReal;\n class QueryProfilerCpu;\n class QueryThreadLog;\n-struct TasksStatsCounters;\n+class TasksStatsCounters;\n struct RUsageCounters;\n class TaskStatsInfoGetter;\n class InternalTextLogsQueue;\n@@ -88,7 +88,7 @@ class ThreadStatus : public boost::noncopyable\n     ~ThreadStatus();\n \n     /// Linux's PID (or TGID) (the same id is shown by ps util)\n-    UInt64 thread_id = 0;\n+    const UInt64 thread_id = 0;\n     /// Also called \"nice\" value. If it was changed to non-zero (when attaching query) - will be reset to zero when query is detached.\n     Int32 os_thread_priority = 0;\n \n@@ -191,14 +191,10 @@ class ThreadStatus : public boost::noncopyable\n     Poco::Logger * log = nullptr;\n \n     friend class CurrentThread;\n-    friend struct TasksStatsCounters;\n \n     /// Use ptr not to add extra dependencies in the header\n     std::unique_ptr<RUsageCounters> last_rusage;\n-    std::unique_ptr<TasksStatsCounters> last_taskstats;\n-\n-    /// Set to non-nullptr only if we have enough capabilities.\n-    std::unique_ptr<TaskStatsInfoGetter> taskstats_getter;\n+    std::unique_ptr<TasksStatsCounters> taskstats;\n \n private:\n     void setupState(const ThreadGroupStatusPtr & thread_group_);\ndiff --git a/src/Common/ya.make b/src/Common/ya.make\nindex 63002d4722a8..c0178f3d3107 100644\n--- a/src/Common/ya.make\n+++ b/src/Common/ya.make\n@@ -73,6 +73,7 @@ SRCS(\n     parseRemoteDescription.cpp\n     PipeFDs.cpp\n     PODArray.cpp\n+    ProcfsMetricsProvider.cpp\n     ProfileEvents.cpp\n     QueryProfiler.cpp\n     quoteString.cpp\n@@ -95,6 +96,7 @@ SRCS(\n     TerminalSize.cpp\n     thread_local_rng.cpp\n     ThreadFuzzer.cpp\n+    ThreadProfileEvents.cpp\n     ThreadPool.cpp\n     ThreadStatus.cpp\n     TraceCollector.cpp\n",
  "test_patch": "diff --git a/src/Common/tests/CMakeLists.txt b/src/Common/tests/CMakeLists.txt\nindex 2ddbee43f5f2..44d43ada3009 100644\n--- a/src/Common/tests/CMakeLists.txt\n+++ b/src/Common/tests/CMakeLists.txt\n@@ -71,3 +71,6 @@ target_link_libraries (chaos_sanitizer PRIVATE clickhouse_common_io)\n \n add_executable (memory_statistics_os_perf memory_statistics_os_perf.cpp)\n target_link_libraries (memory_statistics_os_perf PRIVATE clickhouse_common_io)\n+\n+add_executable (procfs_metrics_provider_perf procfs_metrics_provider_perf.cpp)\n+target_link_libraries (procfs_metrics_provider_perf PRIVATE clickhouse_common_io)\ndiff --git a/src/Common/tests/procfs_metrics_provider_perf.cpp b/src/Common/tests/procfs_metrics_provider_perf.cpp\nnew file mode 100644\nindex 000000000000..022da09b779f\n--- /dev/null\n+++ b/src/Common/tests/procfs_metrics_provider_perf.cpp\n@@ -0,0 +1,41 @@\n+#if defined(__linux__)\n+#include <Common/ProcfsMetricsProvider.h>\n+\n+#include <iostream>\n+#include <linux/taskstats.h>\n+#endif\n+\n+\n+#if defined(__linux__)\n+int main(int argc, char ** argv)\n+{\n+    using namespace DB;\n+\n+    size_t num_iterations = argc >= 2 ? std::stoull(argv[1]) : 1000000;\n+\n+    if (!ProcfsMetricsProvider::isAvailable())\n+    {\n+        std::cerr << \"Procfs statistics is not available on this system\" << std::endl;\n+        return -1;\n+    }\n+\n+    ProcfsMetricsProvider stats_provider(0);\n+\n+    ::taskstats stats;\n+    stats_provider.getTaskStats(stats);\n+\n+    const auto start_cpu_time = stats.cpu_run_virtual_total;\n+    for (size_t i = 0; i < num_iterations; ++i)\n+    {\n+        stats_provider.getTaskStats(stats);\n+    }\n+\n+    if (num_iterations)\n+        std::cerr << stats.cpu_run_virtual_total - start_cpu_time << '\\n';\n+    return 0;\n+}\n+#else\n+int main()\n+{\n+}\n+#endif\ndiff --git a/tests/queries/0_stateless/01268_procfs_metrics.reference b/tests/queries/0_stateless/01268_procfs_metrics.reference\nnew file mode 100644\nindex 000000000000..e9ec4d01307c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01268_procfs_metrics.reference\n@@ -0,0 +1,2 @@\n+1\n+Test OK\ndiff --git a/tests/queries/0_stateless/01268_procfs_metrics.sh b/tests/queries/0_stateless/01268_procfs_metrics.sh\nnew file mode 100755\nindex 000000000000..e258f7faafac\n--- /dev/null\n+++ b/tests/queries/0_stateless/01268_procfs_metrics.sh\n@@ -0,0 +1,41 @@\n+#!/usr/bin/env bash\n+\n+# Sandbox does not provide CAP_NET_ADMIN capability but does have ProcFS mounted at /proc\n+# This ensures that OS metrics can be collected\n+\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+function read_numbers_func()\n+{\n+    $CLICKHOUSE_CLIENT -q \"\n+        SELECT * FROM numbers(600000000) FORMAT Null SETTINGS max_threads = 1\n+    \";\n+}\n+\n+\n+function show_processes_func()\n+{\n+    sleep 0.1;\n+    \n+    # These two system metrics for the generating query above are guaranteed to be nonzero when ProcFS is mounted at /proc\n+    $CLICKHOUSE_CLIENT -q \"\n+        SELECT count() > 0 FROM system.processes\\\n+        WHERE has(ProfileEvents.Names, 'OSCPUVirtualTimeMicroseconds') AND has(ProfileEvents.Names, 'OSReadChars')\\\n+        SETTINGS max_threads = 1\n+    \";\n+}\n+\n+\n+export -f read_numbers_func;\n+export -f show_processes_func;\n+\n+TIMEOUT=3\n+\n+timeout $TIMEOUT bash -c read_numbers_func &\n+timeout $TIMEOUT bash -c show_processes_func &\n+\n+wait\n+\n+echo \"Test OK\"\n",
  "problem_statement": "OS metrics without CAP_NET_ADMIN.\nCAP_NET_ADMIN is theoretically unsafe.\r\n\r\nSuppose hypotetical situation when:\r\n- there is RCE vulnerability in ClickHouse;\r\n- the host has access to two networks: external network and internal company network;\r\n- internal company network is protected by iptables and ClickHouse process cannot use it;\r\n- but the combination of CAP_NET_ADMIN and RCE will allow to modify firewall rules and access company network.\r\n\r\nBut CAP_NET_ADMIN is needed to collect OS kernel metrics via NetLink interface. Look at `TaskStatsInfoGetter`.\r\n\r\nHappy enough, we can also collect these metrics from procfs files inside `/proc/thread-self/`.\r\nExample:\r\n\r\n```\r\ntaskstats.cpu_delay_total : task->se.sum_exec_runtime : /proc/thread-self/schedstat\r\ntaskstats.blkio_delay_total : (\u043a\u0430\u043a \u0441\u043b\u0430\u0433\u0430\u0435\u043c\u043e\u0435) tsk->delays->blkio_delay + tsk->delays->swapin_delay : /proc/thread-self/stat\r\ntaskstats.cpu_run_virtual_total :  task->sched_info.run_delay : /proc/thread-self/schedstat\r\nread_char : /proc/thread-self/io\r\nwrite_char : /proc/thread-self/io\r\nread_bytes : /proc/thread-self/io\r\nwrite_bytes : /proc/thread-self/io\r\n```\r\n\r\n(this example is provided by Maxim Samoylov from Yandex OS kernel development team, also look at `man proc`)\r\n\r\nWe can keep the file descriptor open and obtain these metrics by `pread`.\r\nParsing of text files shouldn't take any significant resources.\r\n\r\nWe can use this option to collect metrics as a fallback if `CAP_NET_ADMIN` is not available.\n",
  "hints_text": "> We can use this option to collect metrics as a fallback if CAP_NET_ADMIN is not available.\r\n\r\nWhy not use it as a default and the only way to collect metrics?\nWe will use it as default if this method will be more efficient or the performance drawback will be neglible.",
  "created_at": "2020-04-27T20:22:57Z",
  "modified_files": [
    "programs/server/Server.cpp",
    "b/src/Common/ProcfsMetricsProvider.cpp",
    "b/src/Common/ProcfsMetricsProvider.h",
    "b/src/Common/ThreadProfileEvents.cpp",
    "src/Common/ThreadProfileEvents.h",
    "src/Common/ThreadStatus.cpp",
    "src/Common/ThreadStatus.h",
    "src/Common/ya.make"
  ],
  "modified_test_files": [
    "src/Common/tests/CMakeLists.txt",
    "b/src/Common/tests/procfs_metrics_provider_perf.cpp",
    "b/tests/queries/0_stateless/01268_procfs_metrics.reference",
    "b/tests/queries/0_stateless/01268_procfs_metrics.sh"
  ]
}