diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h
index 8e538bf780b3..8e80e19a54ea 100644
--- a/src/Functions/FunctionsExternalDictionaries.h
+++ b/src/Functions/FunctionsExternalDictionaries.h
@@ -95,6 +95,10 @@ class FunctionDictHelper
 
     bool isDictGetFunctionInjective(const Block & sample_block)
     {
+        /// Assume non-injective by default
+        if (!sample_block)
+            return false;
+
         if (sample_block.columns() != 3 && sample_block.columns() != 4)
             throw Exception{"Function dictGet... takes 3 or 4 arguments", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};
 
diff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h
index b8873ea26714..9bed7b209bf6 100644
--- a/src/Functions/IFunction.h
+++ b/src/Functions/IFunction.h
@@ -133,6 +133,10 @@ class IFunctionBase
       * But we assume, that it is injective. This could be documented as implementation-specific behaviour.
       *
       * sample_block should contain data types of arguments and values of constants, if relevant.
+      * NOTE: to check is function injective with any arguments, you can pass
+      *       empty block as sample_block (since most of the time function will
+      *       ignore it anyway, and creating arguments just for checking is
+      *       function injective or not is overkill).
       */
     virtual bool isInjective(const Block & /*sample_block*/) const { return false; }
 
diff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp
index 5e83287433b5..1a48b559ecc9 100644
--- a/src/Interpreters/SyntaxAnalyzer.cpp
+++ b/src/Interpreters/SyntaxAnalyzer.cpp
@@ -225,6 +225,7 @@ void executeScalarSubqueries(ASTPtr & query, const Context & context, size_t sub
 
 const std::unordered_set<String> possibly_injective_function_names
 {
+        "dictGet",
         "dictGetString",
         "dictGetUInt8",
         "dictGetUInt16",
@@ -304,10 +305,18 @@ void optimizeGroupBy(ASTSelectQuery * select_query, const NameSet & source_colum
                     continue;
                 }
 
-                const auto & dict_name = function->arguments->children[0]->as<ASTLiteral &>().value.safeGet<String>();
-                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(dict_name);
-                const auto & attr_name = function->arguments->children[1]->as<ASTLiteral &>().value.safeGet<String>();
+                const auto * dict_name_ast = function->arguments->children[0]->as<ASTLiteral>();
+                const auto * attr_name_ast = function->arguments->children[1]->as<ASTLiteral>();
+                if (!dict_name_ast || !attr_name_ast)
+                {
+                    ++i;
+                    continue;
+                }
+
+                const auto & dict_name = dict_name_ast->value.safeGet<String>();
+                const auto & attr_name = attr_name_ast->value.safeGet<String>();
 
+                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(dict_name);
                 if (!dict_ptr->isInjective(attr_name))
                 {
                     ++i;
