{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41095,
  "instance_id": "ClickHouse__ClickHouse-41095",
  "issue_numbers": [
    "41018"
  ],
  "base_commit": "493f6a1c94838099f861a17ef5a999a57044b76f",
  "patch": "diff --git a/src/Parsers/ParserSelectQuery.cpp b/src/Parsers/ParserSelectQuery.cpp\nindex 201cd750af82..107db51f8698 100644\n--- a/src/Parsers/ParserSelectQuery.cpp\n+++ b/src/Parsers/ParserSelectQuery.cpp\n@@ -108,6 +108,13 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         }\n     }\n \n+    /// FROM database.table or FROM table or FROM (subquery) or FROM tableFunction(...)\n+    if (s_from.ignore(pos, expected))\n+    {\n+        if (!ParserTablesInSelectQuery(false).parse(pos, tables, expected))\n+            return false;\n+    }\n+\n     /// SELECT [ALL/DISTINCT [ON (expr_list)]] [TOP N [WITH TIES]] expr_list\n     {\n         bool has_all = false;\n@@ -166,7 +173,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n \n     /// FROM database.table or FROM table or FROM (subquery) or FROM tableFunction(...)\n-    if (s_from.ignore(pos, expected))\n+    if (!tables && s_from.ignore(pos, expected))\n     {\n         if (!ParserTablesInSelectQuery().parse(pos, tables, expected))\n             return false;\ndiff --git a/src/Parsers/ParserTablesInSelectQuery.cpp b/src/Parsers/ParserTablesInSelectQuery.cpp\nindex cff4c959267c..2247167c66ee 100644\n--- a/src/Parsers/ParserTablesInSelectQuery.cpp\n+++ b/src/Parsers/ParserTablesInSelectQuery.cpp\n@@ -21,9 +21,9 @@ bool ParserTableExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n {\n     auto res = std::make_shared<ASTTableExpression>();\n \n-    if (!ParserWithOptionalAlias(std::make_unique<ParserSubquery>(), true).parse(pos, res->subquery, expected)\n-        && !ParserWithOptionalAlias(std::make_unique<ParserFunction>(false, true), true).parse(pos, res->table_function, expected)\n-        && !ParserWithOptionalAlias(std::make_unique<ParserCompoundIdentifier>(true, true), true)\n+    if (!ParserWithOptionalAlias(std::make_unique<ParserSubquery>(), allow_alias_without_as_keyword).parse(pos, res->subquery, expected)\n+        && !ParserWithOptionalAlias(std::make_unique<ParserFunction>(false, true), allow_alias_without_as_keyword).parse(pos, res->table_function, expected)\n+        && !ParserWithOptionalAlias(std::make_unique<ParserCompoundIdentifier>(true, true), allow_alias_without_as_keyword)\n                 .parse(pos, res->database_and_table_name, expected))\n         return false;\n \n@@ -126,7 +126,7 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n \n     if (is_first)\n     {\n-        if (!ParserTableExpression().parse(pos, res->table_expression, expected))\n+        if (!ParserTableExpression(allow_alias_without_as_keyword).parse(pos, res->table_expression, expected))\n             return false;\n     }\n     else if (ParserArrayJoin().parse(pos, res->array_join, expected))\n@@ -200,7 +200,7 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n                 return false;\n         }\n \n-        if (!ParserTableExpression().parse(pos, res->table_expression, expected))\n+        if (!ParserTableExpression(allow_alias_without_as_keyword).parse(pos, res->table_expression, expected))\n             return false;\n \n         if (table_join->kind != JoinKind::Comma\n@@ -261,12 +261,12 @@ bool ParserTablesInSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n \n     ASTPtr child;\n \n-    if (ParserTablesInSelectQueryElement(true).parse(pos, child, expected))\n+    if (ParserTablesInSelectQueryElement(true, allow_alias_without_as_keyword).parse(pos, child, expected))\n         res->children.emplace_back(child);\n     else\n         return false;\n \n-    while (ParserTablesInSelectQueryElement(false).parse(pos, child, expected))\n+    while (ParserTablesInSelectQueryElement(false, allow_alias_without_as_keyword).parse(pos, child, expected))\n         res->children.emplace_back(child);\n \n     node = res;\ndiff --git a/src/Parsers/ParserTablesInSelectQuery.h b/src/Parsers/ParserTablesInSelectQuery.h\nindex 772f1992f4d0..428b14826633 100644\n--- a/src/Parsers/ParserTablesInSelectQuery.h\n+++ b/src/Parsers/ParserTablesInSelectQuery.h\n@@ -12,16 +12,24 @@ struct ASTTableJoin;\n   */\n class ParserTablesInSelectQuery : public IParserBase\n {\n+public:\n+    explicit ParserTablesInSelectQuery(bool allow_alias_without_as_keyword_ = true)\n+        : allow_alias_without_as_keyword(allow_alias_without_as_keyword_) {}\n+\n protected:\n     const char * getName() const override { return \"table, table function, subquery or list of joined tables\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+\n+private:\n+    bool allow_alias_without_as_keyword;\n };\n \n \n class ParserTablesInSelectQueryElement : public IParserBase\n {\n public:\n-    explicit ParserTablesInSelectQueryElement(bool is_first_) : is_first(is_first_) {}\n+    explicit ParserTablesInSelectQueryElement(bool is_first_, bool allow_alias_without_as_keyword_ = true)\n+        : is_first(is_first_), allow_alias_without_as_keyword(allow_alias_without_as_keyword_) {}\n \n protected:\n     const char * getName() const override { return \"table, table function, subquery or list of joined tables\"; }\n@@ -29,6 +37,7 @@ class ParserTablesInSelectQueryElement : public IParserBase\n \n private:\n     bool is_first;\n+    bool allow_alias_without_as_keyword;\n \n     static void parseJoinStrictness(Pos & pos, ASTTableJoin & table_join);\n };\n@@ -36,9 +45,16 @@ class ParserTablesInSelectQueryElement : public IParserBase\n \n class ParserTableExpression : public IParserBase\n {\n+public:\n+    explicit ParserTableExpression(bool allow_alias_without_as_keyword_ = true)\n+        : allow_alias_without_as_keyword(allow_alias_without_as_keyword_) {}\n+\n protected:\n     const char * getName() const override { return \"table or subquery or table function\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+\n+private:\n+    bool allow_alias_without_as_keyword;\n };\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02417_from_select_syntax.reference b/tests/queries/0_stateless/02417_from_select_syntax.reference\nnew file mode 100644\nindex 000000000000..44e0be8e3569\n--- /dev/null\n+++ b/tests/queries/0_stateless/02417_from_select_syntax.reference\n@@ -0,0 +1,4 @@\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02417_from_select_syntax.sql b/tests/queries/0_stateless/02417_from_select_syntax.sql\nnew file mode 100644\nindex 000000000000..ce6cb3a14da1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02417_from_select_syntax.sql\n@@ -0,0 +1,4 @@\n+FROM numbers(1) SELECT number;\n+WITH 1 as n FROM numbers(1) SELECT number * n;\n+FROM (FROM numbers(1) SELECT *) SELECT number;\n+FROM (FROM numbers(1) SELECT *) AS select SELECT number;\n",
  "problem_statement": "FROM table SELECT column\n**Use case**\r\n\r\nWe're building a publicly available CH query interface (like Play UI but with enhanced capabilities like exploring the data and other goodies).\r\nEssentially, it will contain TBs of publicly available blockchain analytics data served over browser and powered by CH.\r\nThousands of users are expected to use the UI and send arbitrary SQL statements to our CH cluster.\r\nFor the best experience, we want to provide fast, intuitive and seamless environment for the users.\r\n\r\nAs you can guess, the product is all about writing ad-hoc queries. \r\nConsidering the number of tables, it becomes really hard to use the mouse to explore the data and to type the table/column names with the keyboard.\r\nThis is why we have implemented autocomplete into our SQL editor.\r\nOne significant problem about the autocomplete is that the system cannot know beforehand the column names of the table unless the table name is provided.\r\n\r\n**Describe the solution you'd like**\r\n\r\nIf somehow users provide the table name first then all the column names would be inferred and could be autocompleted, only if CH supports this:\r\n\r\n```sql\r\nFROM table\r\nSELECT *\r\n```\r\nIt is a simple yet powerfull way to increase the user experience. This project will also lead lots of users to get to know CH and show the world that there is a better DBMS.\r\n\n",
  "hints_text": "I would implement own DSL which is aware about your objects and business domain.\n@den-crane I'd disagree.\r\n\r\nClickHouse may be the only DBMS that you can use to provide raw SQL access to a wide user base and get away with it,\r\nbecause it has good support for query limitations, RBAC, row-level security, out-of-band filters, resource metering, and quotas.\r\n\r\nWhile it cannot even be imagined with MySQL or Postgres, this scenario works perfectly with ClickHouse.\r\n\r\nThe SQL language is way more friendly than in other SQL DBMS.\r\nWe should encourage providing direct ClickHouse SQL querying capabilities to users.\nI don't mind about this feature.\r\nI just see how DSL will simplify and improve everything in this use-case.\nSome related discussions:\r\nhttps://softwareengineering.stackexchange.com/questions/127706/why-is-the-select-before-the-from-in-an-sql-query\r\nhttps://stackoverflow.com/questions/5074044/shouldnt-from-come-before-select-in-sql\r\n\r\nIn MS Linq it's done this way.\r\nhttps://docs.microsoft.com/en-us/dotnet/csharp/linq/query-expression-basics\r\n\r\nI don't have any strong option about that. Changing the dialect just for better intellisense... \r\nI it will be taken - I would prefer to see a good tests coverage for checking complex cases (with subqueries, ctes, aliases, joins, unions etc etc), also checking the behaviour for ambiguis cases (FROM x SELECT a FROM y) etc.",
  "created_at": "2022-09-08T00:32:02Z",
  "modified_files": [
    "src/Parsers/ParserSelectQuery.cpp",
    "src/Parsers/ParserTablesInSelectQuery.cpp",
    "src/Parsers/ParserTablesInSelectQuery.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02417_from_select_syntax.reference",
    "b/tests/queries/0_stateless/02417_from_select_syntax.sql"
  ]
}