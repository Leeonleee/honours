diff --git a/src/Storages/MergeTree/DataPartsExchange.cpp b/src/Storages/MergeTree/DataPartsExchange.cpp
index 4f9c9ffd5961..66f91aa6cd2f 100644
--- a/src/Storages/MergeTree/DataPartsExchange.cpp
+++ b/src/Storages/MergeTree/DataPartsExchange.cpp
@@ -794,8 +794,6 @@ void Fetcher::downloadBasePartOrProjectionPartToDiskRemoteMeta(
                 /// NOTE The is_cancelled flag also makes sense to check every time you read over the network,
                 /// performing a poll with a not very large timeout.
                 /// And now we check it only between read chunks (in the `copyData` function).
-                data_part_storage->removeSharedRecursive(true);
-                data_part_storage->commitTransaction();
                 throw Exception("Fetching of part was cancelled", ErrorCodes::ABORTED);
             }
 
@@ -855,7 +853,6 @@ void Fetcher::downloadBaseOrProjectionPartToDisk(
             /// NOTE The is_cancelled flag also makes sense to check every time you read over the network,
             /// performing a poll with a not very large timeout.
             /// And now we check it only between read chunks (in the `copyData` function).
-            data_part_storage->removeRecursive();
             throw Exception("Fetching of part was cancelled", ErrorCodes::ABORTED);
         }
 
@@ -934,22 +931,36 @@ MergeTreeData::MutableDataPartPtr Fetcher::downloadPartToDisk(
 
     CurrentMetrics::Increment metric_increment{CurrentMetrics::ReplicatedFetch};
 
-    for (size_t i = 0; i < projections; ++i)
+    try
     {
-        String projection_name;
-        readStringBinary(projection_name, in);
-        MergeTreeData::DataPart::Checksums projection_checksum;
+        for (size_t i = 0; i < projections; ++i)
+        {
+            String projection_name;
+            readStringBinary(projection_name, in);
+            MergeTreeData::DataPart::Checksums projection_checksum;
+
+            auto projection_part_storage = data_part_storage->getProjection(projection_name + ".proj");
+            projection_part_storage->createDirectories();
+            downloadBaseOrProjectionPartToDisk(
+                replica_path, projection_part_storage, sync, in, projection_checksum, throttler);
+            checksums.addFile(
+                projection_name + ".proj", projection_checksum.getTotalSizeOnDisk(), projection_checksum.getTotalChecksumUInt128());
+        }
 
-        auto projection_part_storage = data_part_storage->getProjection(projection_name + ".proj");
-        projection_part_storage->createDirectories();
-        downloadBaseOrProjectionPartToDisk(
-            replica_path, projection_part_storage, sync, in, projection_checksum, throttler);
-        checksums.addFile(
-            projection_name + ".proj", projection_checksum.getTotalSizeOnDisk(), projection_checksum.getTotalChecksumUInt128());
+        // Download the base part
+        downloadBaseOrProjectionPartToDisk(replica_path, data_part_storage, sync, in, checksums, throttler);
+    }
+    catch (const Exception & e)
+    {
+        /// Remove the whole part directory if fetch of base
+        /// part or fetch of any projection was stopped.
+        if (e.code() == ErrorCodes::ABORTED)
+        {
+            data_part_storage->removeRecursive();
+            data_part_storage->commitTransaction();
+        }
+        throw;
     }
-
-    // Download the base part
-    downloadBaseOrProjectionPartToDisk(replica_path, data_part_storage, sync, in, checksums, throttler);
 
     assertEOF(in);
     data_part_storage->commitTransaction();
@@ -1007,23 +1018,37 @@ MergeTreeData::MutableDataPartPtr Fetcher::downloadPartToDiskRemoteMeta(
 
     data_part_storage->createDirectories();
 
-    for (size_t i = 0; i < projections; ++i)
+    try
     {
-        String projection_name;
-        readStringBinary(projection_name, in);
-        MergeTreeData::DataPart::Checksums projection_checksum;
+        for (size_t i = 0; i < projections; ++i)
+        {
+            String projection_name;
+            readStringBinary(projection_name, in);
+            MergeTreeData::DataPart::Checksums projection_checksum;
 
-        auto projection_part_storage = data_part_storage->getProjection(projection_name + ".proj");
-        projection_part_storage->createDirectories();
-        downloadBasePartOrProjectionPartToDiskRemoteMeta(
-            replica_path, projection_part_storage, in, projection_checksum, throttler);
+            auto projection_part_storage = data_part_storage->getProjection(projection_name + ".proj");
+            projection_part_storage->createDirectories();
+            downloadBasePartOrProjectionPartToDiskRemoteMeta(
+                replica_path, projection_part_storage, in, projection_checksum, throttler);
 
-        checksums.addFile(
-            projection_name + ".proj", projection_checksum.getTotalSizeOnDisk(), projection_checksum.getTotalChecksumUInt128());
-    }
+            checksums.addFile(
+                projection_name + ".proj", projection_checksum.getTotalSizeOnDisk(), projection_checksum.getTotalChecksumUInt128());
+        }
 
-    downloadBasePartOrProjectionPartToDiskRemoteMeta(
-        replica_path, data_part_storage, in, checksums, throttler);
+        downloadBasePartOrProjectionPartToDiskRemoteMeta(
+            replica_path, data_part_storage, in, checksums, throttler);
+    }
+    catch (const Exception & e)
+    {
+        if (e.code() == ErrorCodes::ABORTED)
+        {
+            /// Remove the whole part directory if fetch of base
+            /// part or fetch of any projection was stopped.
+            data_part_storage->removeSharedRecursive(true);
+            data_part_storage->commitTransaction();
+        }
+        throw;
+    }
 
     assertEOF(in);
     MergeTreeData::MutableDataPartPtr new_data_part;
