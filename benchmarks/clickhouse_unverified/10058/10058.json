{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10058,
  "instance_id": "ClickHouse__ClickHouse-10058",
  "issue_numbers": [
    "1017"
  ],
  "base_commit": "59d3e200ce48bd42f5df5241e749126c33181eea",
  "patch": "diff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 00ccb1fa7cc7..09f4879c3f4a 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -493,8 +493,9 @@ namespace ErrorCodes\n     extern const int ALTER_OF_COLUMN_IS_FORBIDDEN = 524;\n     extern const int INCORRECT_DISK_INDEX = 525;\n     extern const int UNKNOWN_VOLUME_TYPE = 526;\n-    extern const int CASSANDRA_INTERNAL_ERROR = 527;\n-    extern const int NOT_A_LEADER = 528;\n+    extern const int NO_SUITABLE_FUNCTION_IMPLEMENTATION = 527;\n+    extern const int CASSANDRA_INTERNAL_ERROR = 528;\n+    extern const int NOT_A_LEADER = 529;\n \n     extern const int KEEPER_EXCEPTION = 999;\n     extern const int POCO_EXCEPTION = 1000;\ndiff --git a/src/Compression/CompressionFactory.cpp b/src/Compression/CompressionFactory.cpp\nindex 5d5c5c14de69..2598fc07b08c 100644\n--- a/src/Compression/CompressionFactory.cpp\n+++ b/src/Compression/CompressionFactory.cpp\n@@ -120,7 +120,7 @@ void CompressionCodecFactory::registerCompressionCodecWithType(\n \n     if (byte_code)\n         if (!family_code_with_codec.emplace(*byte_code, creator).second)\n-            throw Exception(\"CompressionCodecFactory: the codec family name '\" + family_name + \"' is not unique\", ErrorCodes::LOGICAL_ERROR);\n+            throw Exception(\"CompressionCodecFactory: the codec family code '\" + std::to_string(*byte_code) + \"' is not unique\", ErrorCodes::LOGICAL_ERROR);\n }\n \n void CompressionCodecFactory::registerCompressionCodec(const String & family_name, std::optional<uint8_t> byte_code, Creator creator)\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 6d856eaf88ea..9d2b5db7d331 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -377,6 +377,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, allow_nondeterministic_mutations, false, \"Allow non-deterministic functions in ALTER UPDATE/ALTER DELETE statements\", 0) \\\n     M(SettingSeconds, lock_acquire_timeout, DBMS_DEFAULT_LOCK_ACQUIRE_TIMEOUT_SEC, \"How long locking request should wait before failing\", 0) \\\n     M(SettingBool, materialize_ttl_after_modify, true, \"Apply TTL for old data, after ALTER MODIFY TTL query\", 0) \\\n+    M(SettingString, function_implementation, \"\", \"Choose implementation. If empty enable all of them.\", 0) \\\n     \\\n     M(SettingBool, allow_experimental_geo_types, false, \"Allow geo data types such as Point, Ring, Polygon, MultiPolygon\", 0) \\\n     M(SettingBool, data_type_default_nullable, false, \"Data types without NULL or NOT NULL will make Nullable\", 0) \\\ndiff --git a/src/Core/SettingsCollection.h b/src/Core/SettingsCollection.h\nindex 71a308fb37ed..e85baf82fb6e 100644\n--- a/src/Core/SettingsCollection.h\n+++ b/src/Core/SettingsCollection.h\n@@ -330,7 +330,7 @@ using SettingLogQueriesType = SettingEnum<QueryLogElementType>;\n \n enum class SettingsBinaryFormat\n {\n-    OLD,     /// Part of the settings are serialized as strings, and other part as varints. This is the old behaviour.\n+    OLD,     /// Part of the settings are serialized as strings, and other part as variants. This is the old behaviour.\n     STRINGS, /// All settings are serialized as strings. Before each value the flag `is_ignorable` is serialized.\n     DEFAULT = STRINGS,\n };\ndiff --git a/src/Functions/CMakeLists.txt b/src/Functions/CMakeLists.txt\nindex be78a42d02b3..244d08e104c8 100644\n--- a/src/Functions/CMakeLists.txt\n+++ b/src/Functions/CMakeLists.txt\n@@ -96,6 +96,13 @@ if(USE_RAPIDJSON)\n     target_include_directories(clickhouse_functions SYSTEM PRIVATE ${RAPIDJSON_INCLUDE_DIR})\n endif()\n \n+option(ENABLE_MULTITARGET_CODE \"\" ON)\n+if (ENABLE_MULTITARGET_CODE)\n+    add_definitions(-DENABLE_MULTITARGET_CODE=1)\n+else()\n+    add_definitions(-DENABLE_MULTITARGET_CODE=0)\n+endif()\n+\n add_subdirectory(GatherUtils)\n target_link_libraries(clickhouse_functions PRIVATE clickhouse_functions_gatherutils)\n \ndiff --git a/src/Functions/FunctionStartsEndsWith.h b/src/Functions/FunctionStartsEndsWith.h\nindex 4f56a827f4cd..69627eb2ead6 100644\n--- a/src/Functions/FunctionStartsEndsWith.h\n+++ b/src/Functions/FunctionStartsEndsWith.h\n@@ -1,12 +1,13 @@\n-#include <Functions/IFunctionImpl.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/GatherUtils/GatherUtils.h>\n #include <Functions/GatherUtils/Sources.h>\n+#include <Functions/IFunctionImpl.h>\n+#include <Functions/PerformanceAdaptors.h>\n+#include <Functions/TargetSpecific.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnString.h>\n \n-\n namespace DB\n {\n \n@@ -27,15 +28,13 @@ struct NameEndsWith\n     static constexpr auto name = \"endsWith\";\n };\n \n+DECLARE_MULTITARGET_CODE(\n+\n template <typename Name>\n class FunctionStartsEndsWith : public IFunction\n {\n public:\n     static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &)\n-    {\n-        return std::make_shared<FunctionStartsEndsWith>();\n-    }\n \n     String getName() const override\n     {\n@@ -136,4 +135,41 @@ class FunctionStartsEndsWith : public IFunction\n     }\n };\n \n+) // DECLARE_MULTITARGET_CODE\n+\n+template <typename Name>\n+class FunctionStartsEndsWith : public TargetSpecific::Default::FunctionStartsEndsWith<Name>\n+{\n+public:\n+    explicit FunctionStartsEndsWith(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            TargetSpecific::Default::FunctionStartsEndsWith<Name>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::SSE42,\n+            TargetSpecific::SSE42::FunctionStartsEndsWith<Name>>();\n+        selector.registerImplementation<TargetArch::AVX,\n+            TargetSpecific::AVX::FunctionStartsEndsWith<Name>>();\n+        selector.registerImplementation<TargetArch::AVX2,\n+            TargetSpecific::AVX2::FunctionStartsEndsWith<Name>>();\n+        selector.registerImplementation<TargetArch::AVX512F,\n+            TargetSpecific::AVX512F::FunctionStartsEndsWith<Name>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionStartsEndsWith<Name>>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n }\ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex f647390e1c89..b4c87dd761a2 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -40,6 +40,8 @@\n #include <Columns/ColumnTuple.h>\n #include <Functions/IFunctionImpl.h>\n #include <Functions/FunctionHelpers.h>\n+#include <Functions/TargetSpecific.h>\n+#include <Functions/PerformanceAdaptors.h>\n #include <ext/range.h>\n #include <ext/bit_cast.h>\n \n@@ -573,12 +575,13 @@ class FunctionStringHashFixedString : public IFunction\n };\n \n \n+DECLARE_MULTITARGET_CODE(\n+\n template <typename Impl, typename Name>\n class FunctionIntHash : public IFunction\n {\n public:\n     static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionIntHash>(); }\n \n private:\n     using ToType = typename Impl::ReturnType;\n@@ -646,13 +649,46 @@ class FunctionIntHash : public IFunction\n     }\n };\n \n+) // DECLARE_MULTITARGET_CODE\n+\n+template <typename Impl, typename Name>\n+class FunctionIntHash : public TargetSpecific::Default::FunctionIntHash<Impl, Name>\n+{\n+public:\n+    explicit FunctionIntHash(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            TargetSpecific::Default::FunctionIntHash<Impl, Name>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            TargetSpecific::AVX2::FunctionIntHash<Impl, Name>>();\n+        selector.registerImplementation<TargetArch::AVX512F,\n+            TargetSpecific::AVX512F::FunctionIntHash<Impl, Name>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionIntHash>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n+DECLARE_MULTITARGET_CODE(\n \n template <typename Impl>\n class FunctionAnyHash : public IFunction\n {\n public:\n     static constexpr auto name = Impl::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionAnyHash>(); }\n \n private:\n     using ToType = typename Impl::ReturnType;\n@@ -939,6 +975,39 @@ class FunctionAnyHash : public IFunction\n     }\n };\n \n+) // DECLARE_MULTITARGET_CODE\n+\n+template <typename Impl>\n+class FunctionAnyHash : public TargetSpecific::Default::FunctionAnyHash<Impl>\n+{\n+public:\n+    explicit FunctionAnyHash(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            TargetSpecific::Default::FunctionAnyHash<Impl>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            TargetSpecific::AVX2::FunctionAnyHash<Impl>>();\n+        selector.registerImplementation<TargetArch::AVX512F,\n+            TargetSpecific::AVX512F::FunctionAnyHash<Impl>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionAnyHash>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n \n struct URLHashImpl\n {\ndiff --git a/src/Functions/FunctionsRandom.cpp b/src/Functions/FunctionsRandom.cpp\nindex 19b2f08cdba1..e77bab9c0a57 100644\n--- a/src/Functions/FunctionsRandom.cpp\n+++ b/src/Functions/FunctionsRandom.cpp\n@@ -1,8 +1,12 @@\n-#include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsRandom.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/VectorExtension.h>\n #include <Common/HashTable/Hash.h>\n #include <Common/randomSeed.h>\n #include <common/unaligned.h>\n+#if USE_MULTITARGET_CODE\n+#  include <x86intrin.h>\n+#endif\n \n \n namespace DB\n@@ -37,12 +41,33 @@ namespace\n         }\n     };\n \n-    void seed(LinearCongruentialGenerator & generator, intptr_t additional_seed)\n+    UInt64 calcSeed(UInt64 rand_seed, UInt64 additional_seed)\n+    {\n+        return intHash64(rand_seed ^ intHash64(additional_seed));\n+    }\n+\n+    void seed(LinearCongruentialGenerator & generator, UInt64 rand_seed, intptr_t additional_seed)\n     {\n-        generator.seed(intHash64(randomSeed() ^ intHash64(additional_seed)));\n+        generator.seed(calcSeed(rand_seed, additional_seed));\n     }\n+\n+    /// The array of random numbers from 'head -c8 /dev/urandom | xxd -p'.\n+    /// Can be used for creating seeds for random generators.\n+    constexpr std::array<UInt64, 32> random_numbers = {\n+        0x0c8ff307dabc0c4cULL, 0xf4bce78bf3821c1bULL, 0x4eb628a1e189c21aULL, 0x85ae000d253e0dbcULL,\n+        0xc98073e6480f8a10ULL, 0xb17e9b70a084d570ULL, 0x1361c752b768da8cULL, 0x3d915f60c06d144dULL,\n+        0xd5bc9b7aced79587ULL, 0x66c28000ba8a66cfULL, 0x0fb58da7a48820f5ULL, 0x540ee1b57aa861a1ULL,\n+        0x212f11936ef2db04ULL, 0xa3939cd900edcc58ULL, 0xc676c84420170102ULL, 0xcbdc824e8b4bf3edULL,\n+\n+        0x8296f9d93cc94e3bULL, 0x78a7e826d62085b2ULL, 0xaa30620211fc6c69ULL, 0xbd38de52f0a93677ULL,\n+        0x19983de8d79dcc4eULL, 0x8afe883ef2199e6fULL, 0xb7160f7ed022b60aULL, 0x2ce173d373ddafd4ULL,\n+        0x15762761bb55b9acULL, 0x3e448fc94fdd28e7ULL, 0xa5121232adfbe70aULL, 0xb1e0f6d286112804ULL,\n+        0x6062e96de9554806ULL, 0xcc679b329c28882aULL, 0x5c6d29f45cbc060eULL, 0x1af1325a86ffb162ULL,\n+    };\n }\n \n+DECLARE_DEFAULT_CODE(\n+\n void RandImpl::execute(char * output, size_t size)\n {\n     LinearCongruentialGenerator generator0;\n@@ -50,10 +75,12 @@ void RandImpl::execute(char * output, size_t size)\n     LinearCongruentialGenerator generator2;\n     LinearCongruentialGenerator generator3;\n \n-    seed(generator0, 0xfb4121280b2ab902ULL + reinterpret_cast<intptr_t>(output));\n-    seed(generator1, 0x0121cf76df39c673ULL + reinterpret_cast<intptr_t>(output));\n-    seed(generator2, 0x17ae86e3a19a602fULL + reinterpret_cast<intptr_t>(output));\n-    seed(generator3, 0x8b6e16da7e06d622ULL + reinterpret_cast<intptr_t>(output));\n+    UInt64 rand_seed = randomSeed();\n+\n+    seed(generator0, rand_seed, random_numbers[0] + reinterpret_cast<intptr_t>(output));\n+    seed(generator1, rand_seed, random_numbers[1] + reinterpret_cast<intptr_t>(output));\n+    seed(generator2, rand_seed, random_numbers[2] + reinterpret_cast<intptr_t>(output));\n+    seed(generator3, rand_seed, random_numbers[3] + reinterpret_cast<intptr_t>(output));\n \n     for (const char * end = output + size; output < end; output += 16)\n     {\n@@ -62,8 +89,100 @@ void RandImpl::execute(char * output, size_t size)\n         unalignedStore<UInt32>(output + 8, generator2.next());\n         unalignedStore<UInt32>(output + 12, generator3.next());\n     }\n-\n     /// It is guaranteed (by PaddedPODArray) that we can overwrite up to 15 bytes after end.\n }\n \n+) // DECLARE_DEFAULT_CODE\n+\n+DECLARE_AVX2_SPECIFIC_CODE(\n+\n+using namespace VectorExtension;\n+\n+/* Takes 2 vectors with LinearCongruentialGenerator states and combines them into vector with random values.\n+ * From every rand-state we use only bits 15...47 to generate random vector.\n+ */\n+inline UInt64x4 CombineValues(UInt64x4 a, UInt64x4 b)\n+{\n+    auto xa = reinterpret_cast<__m256i>(a);\n+    auto xb = reinterpret_cast<__m256i>(b);\n+    /// Every state is 8-byte value and we need to use only 4 from the middle.\n+    /// Swap the low half and the high half of every state to move these bytes from the middle to sides.\n+    /// xa = xa[1, 0, 3, 2, 5, 4, 7, 6]\n+    xa = _mm256_shuffle_epi32(xa, 0xb1);\n+    /// Now every 8-byte value in xa is xx....xx and every value in xb is ..xxxx.. where x is random byte we want to use.\n+    /// Just blend them to get the result vector.\n+    /// result = xa[0],xb[1,2],xa[3,4],xb[5,6],xa[7,8],xb[9,10],xa[11,12],xb[13,14],xa[15]\n+    __m256i result = _mm256_blend_epi16(xa, xb, 0x66);\n+    return reinterpret_cast<UInt64x4>(result);\n+}\n+\n+void RandImpl::execute(char * output, size_t size)\n+{\n+    if (size == 0)\n+        return;\n+\n+    char * end = output + size;\n+\n+    constexpr int vec_size = 4;\n+    constexpr int safe_overwrite = 15;\n+    constexpr int bytes_per_write = 4 * sizeof(UInt64x4);\n+\n+    UInt64 rand_seed = randomSeed();\n+\n+    UInt64 a = LinearCongruentialGenerator::a;\n+    // TODO(dakovalkov): try to remove this.\n+    /// Note: GCC likes to expand multiplication by a constant into shifts + additions.\n+    /// In this case a few multiplications become tens of shifts and additions. That leads to a huge slow down.\n+    /// To avoid it we pretend that 'a' is not a constant. Actually we hope that rand_seed is never 0.\n+    if (rand_seed == 0)\n+        a = LinearCongruentialGenerator::a + 2;\n+\n+    constexpr UInt64 c = LinearCongruentialGenerator::c;\n+\n+    UInt64x4 gens1{};\n+    UInt64x4 gens2{};\n+    UInt64x4 gens3{};\n+    UInt64x4 gens4{};\n+\n+    for (int i = 0; i < vec_size; ++i)\n+    {\n+        gens1[i] = calcSeed(rand_seed, random_numbers[i] + reinterpret_cast<intptr_t>(output));\n+        gens2[i] = calcSeed(rand_seed, random_numbers[i + vec_size] + reinterpret_cast<intptr_t>(output));\n+        gens3[i] = calcSeed(rand_seed, random_numbers[i + 2 * vec_size] + reinterpret_cast<intptr_t>(output));\n+        gens4[i] = calcSeed(rand_seed, random_numbers[i + 3 * vec_size] + reinterpret_cast<intptr_t>(output));\n+    }\n+\n+    while ((end - output) + safe_overwrite >= bytes_per_write)\n+    {\n+        gens1 = gens1 * a + c;\n+        gens2 = gens2 * a + c;\n+        unalignedStore<UInt64x4>(output, CombineValues(gens1, gens2));\n+        gens3 = gens3 * a + c;\n+        gens4 = gens4 * a + c;\n+        unalignedStore<UInt64x4>(output + sizeof(UInt64x4), CombineValues(gens3, gens4));\n+        gens1 = gens1 * a + c;\n+        gens2 = gens2 * a + c;\n+        unalignedStore<UInt64x4>(output + 2 * sizeof(UInt64x4), CombineValues(gens1, gens2));\n+        gens3 = gens3 * a + c;\n+        gens4 = gens4 * a + c;\n+        unalignedStore<UInt64x4>(output + 3 * sizeof(UInt64x4), CombineValues(gens3, gens4));\n+        output += bytes_per_write;\n+    }\n+\n+    // Process tail\n+    while ((end - output) > 0)\n+    {\n+        gens1 = gens1 * a + c;\n+        gens2 = gens2 * a + c;\n+        UInt64x4 values = CombineValues(gens1, gens2);\n+        for (int i = 0; i < vec_size && (end - output) > 0; ++i)\n+        {\n+            unalignedStore<UInt64>(output, values[i]);\n+            output += sizeof(UInt64);\n+        }\n+    }\n+}\n+\n+) // DECLARE_AVX2_SPECIFIC_CODE\n+\n }\ndiff --git a/src/Functions/FunctionsRandom.h b/src/Functions/FunctionsRandom.h\nindex 1ac6d24a3561..b80ddb6f59e2 100644\n--- a/src/Functions/FunctionsRandom.h\n+++ b/src/Functions/FunctionsRandom.h\n@@ -3,6 +3,8 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnVector.h>\n #include <Functions/IFunctionImpl.h>\n+#include <Functions/TargetSpecific.h>\n+#include <Functions/PerformanceAdaptors.h>\n #include <IO/WriteHelpers.h>\n \n \n@@ -34,19 +36,21 @@ namespace ErrorCodes\n   * This means that the timer must be of sufficient resolution to give different values to each block.\n   */\n \n+DECLARE_MULTITARGET_CODE(\n+\n struct RandImpl\n {\n     /// Fill memory with random data. The memory region must be 15-bytes padded.\n     static void execute(char * output, size_t size);\n };\n \n+) // DECLARE_MULTITARGET_CODE\n \n-template <typename ToType, typename Name>\n-class FunctionRandom : public IFunction\n+template <typename RandImpl, typename ToType, typename Name>\n+class FunctionRandomImpl : public IFunction\n {\n public:\n     static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionRandom>(); }\n \n     String getName() const override\n     {\n@@ -83,4 +87,33 @@ class FunctionRandom : public IFunction\n     }\n };\n \n+template <typename ToType, typename Name>\n+class FunctionRandom : public FunctionRandomImpl<TargetSpecific::Default::RandImpl, ToType, Name>\n+{\n+public:\n+    explicit FunctionRandom(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            FunctionRandomImpl<TargetSpecific::Default::RandImpl, ToType, Name>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            FunctionRandomImpl<TargetSpecific::AVX2::RandImpl, ToType, Name>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionRandom<ToType, Name>>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n }\ndiff --git a/src/Functions/IFunctionImpl.h b/src/Functions/IFunctionImpl.h\nindex 116363705de4..27e7aec6bd4d 100644\n--- a/src/Functions/IFunctionImpl.h\n+++ b/src/Functions/IFunctionImpl.h\n@@ -5,7 +5,7 @@\n /// In order to implement a new function you can choose one of two options:\n ///  * Implement interface for IFunction (old function interface, which is planned to be removed sometimes)\n ///  * Implement three interfaces for IExecutableFunctionImpl, IFunctionBaseImpl and IFunctionOverloadResolverImpl\n-/// Generally saying, IFunction represents a union of tree new interfaces. However, it can't be used for all cases.\n+/// Generally saying, IFunction represents a union of three new interfaces. However, it can't be used for all cases.\n /// Examples:\n ///  * Function properties may depend on arguments type (e.g. toUInt32(UInt8) is globally monotonic, toUInt32(UInt64) - only on intervals)\n ///  * In implementation of lambda functions DataTypeFunction needs an functional object with known arguments and return type\n@@ -194,7 +194,7 @@ using FunctionOverloadResolverImplPtr = std::unique_ptr<IFunctionOverloadResolve\n \n \n /// Previous function interface.\n-class IFunction : public std::enable_shared_from_this<IFunction>\n+class IFunction\n {\n public:\n     virtual ~IFunction() = default;\ndiff --git a/src/Functions/PerformanceAdaptors.h b/src/Functions/PerformanceAdaptors.h\nnew file mode 100644\nindex 000000000000..bbe50d2e9941\n--- /dev/null\n+++ b/src/Functions/PerformanceAdaptors.h\n@@ -0,0 +1,263 @@\n+#pragma once\n+\n+#include <Functions/TargetSpecific.h>\n+#include <Functions/IFunctionImpl.h>\n+\n+#include <Common/Stopwatch.h>\n+#include <Interpreters/Context.h>\n+\n+#include <mutex>\n+#include <random>\n+\n+/* This file contains helper class ImplementationSelector. It makes easier to combine\n+ * several implementations of IFunction/IExecutableFunctionImpl.\n+ */\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NO_SUITABLE_FUNCTION_IMPLEMENTATION;\n+}\n+\n+namespace detail\n+{\n+    class PerformanceStatistics\n+    {\n+    public:\n+        size_t select(bool considarable)\n+        {\n+            /// We don't need to choose/measure anything if there's only one variant.\n+            if (size() == 1)\n+                return 0;\n+\n+            std::lock_guard guard(lock);\n+\n+            size_t best = 0;\n+            double best_sample = data[0].sample(rng);\n+\n+            for (size_t i = 1; i < data.size(); ++i)\n+            {\n+                double sample = data[i].sample(rng);\n+                if (sample < best_sample)\n+                {\n+                    best_sample = sample;\n+                    best = i;\n+                }\n+            }\n+\n+            if (considarable)\n+                data[best].run();\n+\n+            return best;\n+        }\n+\n+        void complete(size_t id, double seconds, double bytes)\n+        {\n+            if (size() == 1)\n+                return;\n+\n+            std::lock_guard guard(lock);\n+            data[id].complete(seconds, bytes);\n+        }\n+\n+        size_t size() const\n+        {\n+            return data.size();\n+        }\n+\n+        bool empty() const\n+        {\n+            return size() == 0;\n+        }\n+\n+        void emplace_back()\n+        {\n+            data.emplace_back();\n+        }\n+\n+    private:\n+        struct Element\n+        {\n+            int completed_count = 0;\n+            int running_count = 0;\n+            double sum = 0;\n+\n+            int adjustedCount() const\n+            {\n+                return completed_count - NUM_INVOCATIONS_TO_THROW_OFF;\n+            }\n+\n+            double mean() const\n+            {\n+                return sum / adjustedCount();\n+            }\n+\n+            /// For better convergence, we don't use proper estimate of stddev.\n+            /// We want to eventually separate between two algorithms even in case\n+            ///  when there is no statistical significant difference between them.\n+            double sigma() const\n+            {\n+                return mean() / sqrt(adjustedCount());\n+            }\n+\n+            void run()\n+            {\n+                ++running_count;\n+            }\n+\n+            void complete(double seconds, double bytes)\n+            {\n+                --running_count;\n+                ++completed_count;\n+\n+                if (adjustedCount() > 0)\n+                    sum += seconds / bytes;\n+            }\n+\n+            double sample(pcg64 & stat_rng) const\n+            {\n+                /// If there is a variant with not enough statistics, always choose it.\n+                /// And in that case prefer variant with less number of invocations.\n+\n+                if (adjustedCount() < 2)\n+                    return adjustedCount() - 1 + running_count;\n+                return std::normal_distribution<>(mean(), sigma())(stat_rng);\n+            }\n+        };\n+\n+        std::vector<Element> data;\n+        std::mutex lock;\n+        /// It's Ok that generator is not seeded.\n+        pcg64 rng;\n+        /// Cold invocations may be affected by additional memory latencies. Don't take first invocations into account.\n+        static constexpr int NUM_INVOCATIONS_TO_THROW_OFF = 2;\n+    };\n+\n+    template <typename T, class = decltype(T::getImplementationTag())>\n+    std::true_type hasImplementationTagTest(const T&);\n+    std::false_type hasImplementationTagTest(...);\n+\n+    template <typename T>\n+    constexpr bool has_implementation_tag = decltype(hasImplementationTagTest(std::declval<T>()))::value;\n+\n+    /* Implementation tag is used to run specific implementation (for debug/testing purposes).\n+     * It can be specified via static method ::getImplementationTag() in Function (optional).\n+     */\n+    template <typename T>\n+    String getImplementationTag(TargetArch arch)\n+    {\n+        if constexpr (has_implementation_tag<T>)\n+            return ToString(arch) + \"_\" + T::getImplementationTag();\n+        else\n+            return ToString(arch);\n+    }\n+}\n+\n+/* Class which is used to store implementations for the function and to select the best one to run\n+ * based on processor architecture and statistics from previous runs.\n+ * \n+ * FunctionInterface is typically IFunction or IExecutableFunctionImpl, but practically it can be\n+ * any interface that contains \"execute\" method (IFunction is an exception and is supported as well).\n+ * \n+ * Example of usage:\n+ * \n+ * class MyDefaulImpl : public IFunction {...};\n+ * DECLARE_AVX2_SPECIFIC_CODE(\n+ * class MyAVX2Impl : public IFunction {...};\n+ * )\n+ * \n+ * /// All methods but execute/executeImpl are usually not bottleneck, so just use them from\n+ * /// default implementation.\n+ * class MyFunction : public MyDefaultImpl\n+ * {\n+ *     MyFunction(const Context & context) : selector(context) {\n+ *         /// Register all implementations in constructor.\n+ *         /// There could be as many implementation for every target as you want.\n+ *         selector.registerImplementation<TargetArch::Default, MyDefaultImpl>();\n+ *     #if USE_MULTITARGET_CODE\n+ *         selector.registreImplementation<TargetArch::AVX2, TargetSpecific::AVX2::MyAVX2Impl>();\n+ *     #endif\n+ *     }\n+ *\n+ *     void executeImpl(...) override {\n+ *         selector.selectAndExecute(...);\n+ *     }\n+ *\n+ *     static FunctionPtr create(const Context & context) {\n+ *         return std::make_shared<MyFunction>(context);\n+ *     }\n+ * private:\n+ *     ImplementationSelector<IFunction> selector;\n+ * };\n+ */\n+template <typename FunctionInterface>\n+class ImplementationSelector\n+{\n+public:\n+    using ImplementationPtr = std::shared_ptr<FunctionInterface>;\n+\n+    ImplementationSelector(const Context & context_) : context(context_) {}\n+\n+    /* Select the best implementation based on previous runs.\n+     * If FunctionInterface is IFunction, then \"executeImpl\" method of the implementation will be called\n+     * and \"execute\" otherwise.\n+     */\n+    void selectAndExecute(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count)\n+    {\n+        if (implementations.empty())\n+            throw Exception(\"There are no available implementations for function \" \"TODO(dakovalkov): add name\",\n+                            ErrorCodes::NO_SUITABLE_FUNCTION_IMPLEMENTATION);\n+\n+        /// Statistics shouldn't rely on small blocks.\n+        bool considerable = (input_rows_count > 1000);\n+\n+        size_t id = statistics.select(considerable);\n+        Stopwatch watch;\n+\n+        if constexpr (std::is_same_v<FunctionInterface, IFunction>)\n+            implementations[id]->executeImpl(block, arguments, result, input_rows_count);\n+        else\n+            implementations[id]->execute(block, arguments, result, input_rows_count);\n+\n+        watch.stop();\n+\n+        if (considerable)\n+        {\n+            // TODO(dakovalkov): Calculate something more informative than rows count.\n+            statistics.complete(id, watch.elapsedSeconds(), input_rows_count);\n+        }\n+    }\n+\n+    /* Register new implementation for function.\n+     *\n+     * Arch - required instruction set for running the implementation. It's guarantied that no one method would\n+     * be called (even the constructor and static methods) if the processor doesn't support this instruction set.\n+     * \n+     * FunctionImpl - implementation, should be inherited from template argument FunctionInterface.\n+     * \n+     * All function arguments will be forwarded to the implementation constructor.\n+     */\n+    template <TargetArch Arch, typename FunctionImpl, typename ...Args>\n+    void registerImplementation(Args&&... args)\n+    {\n+        if (IsArchSupported(Arch))\n+        {\n+            // TODO(dakovalkov): make this option better.\n+            const auto & choose_impl = context.getSettingsRef().function_implementation.value;\n+            if (choose_impl.empty() || choose_impl == detail::getImplementationTag<FunctionImpl>(Arch))\n+            {\n+                implementations.emplace_back(std::make_shared<FunctionImpl>(std::forward<Args>(args)...));\n+                statistics.emplace_back();\n+            }\n+        }\n+    }\n+\n+private:\n+    const Context & context;\n+    std::vector<ImplementationPtr> implementations;\n+    detail::PerformanceStatistics statistics;\n+};\n+\n+}\ndiff --git a/src/Functions/TargetSpecific.cpp b/src/Functions/TargetSpecific.cpp\nnew file mode 100644\nindex 000000000000..65f8641ee8eb\n--- /dev/null\n+++ b/src/Functions/TargetSpecific.cpp\n@@ -0,0 +1,42 @@\n+#include <Functions/TargetSpecific.h>\n+\n+#include <Common/CpuId.h>\n+\n+namespace DB\n+{\n+\n+UInt32 GetSupportedArches()\n+{\n+    UInt32 result = 0;\n+    if (Cpu::CpuFlagsCache::have_SSE42)\n+        result |= static_cast<UInt32>(TargetArch::SSE42);\n+    if (Cpu::CpuFlagsCache::have_AVX)\n+        result |= static_cast<UInt32>(TargetArch::AVX);\n+    if (Cpu::CpuFlagsCache::have_AVX2)\n+        result |= static_cast<UInt32>(TargetArch::AVX2);\n+    if (Cpu::CpuFlagsCache::have_AVX512F)\n+        result |= static_cast<UInt32>(TargetArch::AVX512F);\n+    return result;\n+}\n+\n+bool IsArchSupported(TargetArch arch)\n+{\n+    static UInt32 arches = GetSupportedArches();\n+    return arch == TargetArch::Default || (arches & static_cast<UInt32>(arch));\n+}\n+\n+String ToString(TargetArch arch)\n+{\n+    switch (arch)\n+    {\n+        case TargetArch::Default: return \"default\";\n+        case TargetArch::SSE42:   return \"sse42\";\n+        case TargetArch::AVX:     return \"avx\";\n+        case TargetArch::AVX2:    return \"avx2\";\n+        case TargetArch::AVX512F: return \"avx512f\";\n+    }\n+\n+    __builtin_unreachable();\n+}\n+\n+}\ndiff --git a/src/Functions/TargetSpecific.h b/src/Functions/TargetSpecific.h\nnew file mode 100644\nindex 000000000000..ed9c0d3c2443\n--- /dev/null\n+++ b/src/Functions/TargetSpecific.h\n@@ -0,0 +1,213 @@\n+#pragma once\n+\n+#include <Core/Types.h>\n+\n+/* This file contains macros and helpers for writing platform-dependent code.\n+ * \n+ * Macros DECLARE_<Arch>_SPECIFIC_CODE will wrap code inside it into the \n+ * namespace TargetSpecific::<Arch> and enable Arch-specific compile options.\n+ * Thus, it's allowed to call functions inside these namespaces only after\n+ * checking platform in runtime (see IsArchSupported() below).\n+ *\n+ * If compiler is not gcc/clang or target isn't x86_64 or ENABLE_MULTITARGET_CODE\n+ * was set to OFF in cmake, all code inside these macroses will be removed and\n+ * USE_MUTLITARGE_CODE will be set to 0. Use #if USE_MUTLITARGE_CODE whenever you\n+ * use anything from this namespaces.\n+ * \n+ * For similarities there is a macros DECLARE_DEFAULT_CODE, which wraps code\n+ * into the namespace TargetSpecific::Default but dosn't specify any additional\n+ * copile options. Functions and classes inside this macros are available regardless\n+ * of USE_MUTLITARGE_CODE.\n+ * \n+ * Example of usage:\n+ * \n+ * DECLARE_DEFAULT_CODE (\n+ * int funcImpl() {\n+ *     return 1;\n+ * }\n+ * ) // DECLARE_DEFAULT_CODE\n+ * \n+ * DECLARE_AVX2_SPECIFIC_CODE (\n+ * int funcImpl() {\n+ *     return 2;\n+ * }\n+ * ) // DECLARE_DEFAULT_CODE\n+ * \n+ * int func() {\n+ * #if USE_MULTITARGET_CODE\n+ *     if (IsArchSupported(TargetArch::AVX2)) \n+ *         return TargetSpecifc::AVX2::funcImpl();\n+ * #endif\n+ *     return TargetSpecifc::Default::funcImpl();\n+ * } \n+ * \n+ * Sometimes code may benefit from compiling with different options.\n+ * For these purposes use DECLARE_MULTITARGET_CODE macros. It will create a copy\n+ * of the code for every supported target and compile it with different options.\n+ * These copies are available via TargetSpecifc namespaces described above.\n+ * \n+ * Inside every TargetSpecific namespace there is a constexpr variable BuildArch, \n+ * which indicates the target platform for current code.\n+ * \n+ * Example:\n+ * \n+ * DECLARE_MULTITARGET_CODE(\n+ * int funcImpl(int size, ...) {\n+ *     int iteration_size = 1;\n+ *     if constexpr (BuildArch == TargetArch::SSE42)\n+ *         iteration_size = 2\n+ *     else if constexpr (BuildArch == TargetArch::AVX || BuildArch == TargetArch::AVX2)\n+ *         iteration_size = 4;\n+ *     for (int i = 0; i < size; i += iteration_size)\n+ *     ...\n+ * }\n+ * ) // DECLARE_MULTITARGET_CODE\n+ *\n+ * // All target-specific and default implementations are available here via\n+ * TargetSpecific::<Arch>::funcImpl. Use runtime detection to choose one.\n+ *\n+ * If you want to write IFunction or IExecutableFuncionImpl with several implementations\n+ * see PerformanceAdaptors.h.\n+ */\n+\n+namespace DB\n+{\n+\n+enum class TargetArch : UInt32\n+{\n+    Default  = 0,         /// Without any additional compiler options.\n+    SSE42    = (1 << 0),  /// SSE4.2\n+    AVX      = (1 << 1),\n+    AVX2     = (1 << 2),\n+    AVX512F  = (1 << 3),\n+};\n+\n+/// Runtime detection.\n+bool IsArchSupported(TargetArch arch);\n+\n+String ToString(TargetArch arch);\n+\n+#if ENABLE_MULTITARGET_CODE && defined(__GNUC__) && defined(__x86_64__)\n+\n+#define USE_MULTITARGET_CODE 1\n+\n+#if defined(__clang__)\n+#   define BEGIN_AVX512F_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f\\\"))),apply_to=function)\")\n+#   define BEGIN_AVX2_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2\\\"))),apply_to=function)\")\n+#   define BEGIN_AVX_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx\\\"))),apply_to=function)\")\n+#   define BEGIN_SSE42_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt\\\"))),apply_to=function)\")\n+#   define END_TARGET_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute pop\")\n+\n+/* Clang shows warning when there aren't any objects to apply pragma.\n+ * To prevent this warning we define this function inside every macros with pragmas.\n+ */\n+#   define DUMMY_FUNCTION_DEFINITION void __dummy_function_definition();\n+#else\n+#   define BEGIN_AVX512F_SPECIFIC_CODE \\\n+        _Pragma(\"GCC push_options\") \\\n+        _Pragma(\"GCC target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,tune=native\\\")\")\n+#   define BEGIN_AVX2_SPECIFIC_CODE \\\n+        _Pragma(\"GCC push_options\") \\\n+        _Pragma(\"GCC target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,tune=native\\\")\")\n+#   define BEGIN_AVX_SPECIFIC_CODE \\\n+        _Pragma(\"GCC push_options\") \\\n+        _Pragma(\"GCC target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,tune=native\\\")\")\n+#   define BEGIN_SSE42_SPECIFIC_CODE \\\n+        _Pragma(\"GCC push_options\") \\\n+        _Pragma(\"GCC target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,tune=native\\\")\")\n+#   define END_TARGET_SPECIFIC_CODE \\\n+        _Pragma(\"GCC pop_options\")\n+\n+/* GCC doesn't show such warning, we don't need to define anything.\n+ */\n+#   define DUMMY_FUNCTION_DEFINITION\n+#endif\n+\n+#define DECLARE_SSE42_SPECIFIC_CODE(...) \\\n+BEGIN_SSE42_SPECIFIC_CODE \\\n+namespace TargetSpecific::SSE42 { \\\n+    DUMMY_FUNCTION_DEFINITION \\\n+    using namespace DB::TargetSpecific::SSE42; \\\n+    __VA_ARGS__ \\\n+} \\\n+END_TARGET_SPECIFIC_CODE\n+\n+#define DECLARE_AVX_SPECIFIC_CODE(...) \\\n+BEGIN_AVX_SPECIFIC_CODE \\\n+namespace TargetSpecific::AVX { \\\n+    DUMMY_FUNCTION_DEFINITION \\\n+    using namespace DB::TargetSpecific::AVX; \\\n+    __VA_ARGS__ \\\n+} \\\n+END_TARGET_SPECIFIC_CODE\n+\n+#define DECLARE_AVX2_SPECIFIC_CODE(...) \\\n+BEGIN_AVX2_SPECIFIC_CODE \\\n+namespace TargetSpecific::AVX2 { \\\n+    DUMMY_FUNCTION_DEFINITION \\\n+    using namespace DB::TargetSpecific::AVX2; \\\n+    __VA_ARGS__ \\\n+} \\\n+END_TARGET_SPECIFIC_CODE\n+\n+#define DECLARE_AVX512F_SPECIFIC_CODE(...) \\\n+BEGIN_AVX512F_SPECIFIC_CODE \\\n+namespace TargetSpecific::AVX512F { \\\n+    DUMMY_FUNCTION_DEFINITION \\\n+    using namespace DB::TargetSpecific::AVX512F; \\\n+    __VA_ARGS__ \\\n+} \\\n+END_TARGET_SPECIFIC_CODE\n+\n+#else\n+\n+#define USE_MULTITARGET_CODE 0\n+\n+/* Multitarget code is disabled, just delete target-specific code.\n+ */\n+#define DECLARE_SSE42_SPECIFIC_CODE(...)\n+#define DECLARE_AVX_SPECIFIC_CODE(...)\n+#define DECLARE_AVX2_SPECIFIC_CODE(...)\n+#define DECLARE_AVX512F_SPECIFIC_CODE(...)\n+\n+#endif\n+\n+#define DECLARE_DEFAULT_CODE(...) \\\n+namespace TargetSpecific::Default { \\\n+    using namespace DB::TargetSpecific::Default; \\\n+    __VA_ARGS__ \\\n+}\n+\n+#define DECLARE_MULTITARGET_CODE(...) \\\n+DECLARE_DEFAULT_CODE         (__VA_ARGS__) \\\n+DECLARE_SSE42_SPECIFIC_CODE  (__VA_ARGS__) \\\n+DECLARE_AVX_SPECIFIC_CODE    (__VA_ARGS__) \\\n+DECLARE_AVX2_SPECIFIC_CODE   (__VA_ARGS__) \\\n+DECLARE_AVX512F_SPECIFIC_CODE(__VA_ARGS__)\n+\n+DECLARE_DEFAULT_CODE(\n+    constexpr auto BuildArch = TargetArch::Default;\n+) // DECLARE_DEFAULT_CODE\n+\n+DECLARE_SSE42_SPECIFIC_CODE(\n+    constexpr auto BuildArch = TargetArch::SSE42;\n+) // DECLARE_SSE42_SPECIFIC_CODE\n+\n+DECLARE_AVX_SPECIFIC_CODE(\n+    constexpr auto BuildArch = TargetArch::AVX;\n+) // DECLARE_AVX_SPECIFIC_CODE\n+\n+DECLARE_AVX2_SPECIFIC_CODE(\n+    constexpr auto BuildArch = TargetArch::AVX2;\n+) // DECLARE_AVX2_SPECIFIC_CODE\n+\n+DECLARE_AVX512F_SPECIFIC_CODE(\n+    constexpr auto BuildArch = TargetArch::AVX512F;\n+) // DECLARE_AVX512F_SPECIFIC_CODE\n+\n+}\ndiff --git a/src/Functions/VectorExtension.h b/src/Functions/VectorExtension.h\nnew file mode 100644\nindex 000000000000..24c2ae9a18f9\n--- /dev/null\n+++ b/src/Functions/VectorExtension.h\n@@ -0,0 +1,78 @@\n+#pragma once\n+\n+#include <Core/Types.h>\n+// Contains types declarations and wrappers for GCC vector extension.\n+\n+namespace DB::VectorExtension\n+{\n+\n+typedef UInt64 UInt64x2  __attribute__ ((vector_size (sizeof(UInt64) * 2)));\n+typedef UInt64 UInt64x4  __attribute__ ((vector_size (sizeof(UInt64) * 4)));\n+typedef UInt64 UInt64x8  __attribute__ ((vector_size (sizeof(UInt64) * 8)));\n+\n+typedef UInt32 UInt32x2  __attribute__ ((vector_size (sizeof(UInt32) * 2)));\n+typedef UInt32 UInt32x4  __attribute__ ((vector_size (sizeof(UInt32) * 4)));\n+typedef UInt32 UInt32x8  __attribute__ ((vector_size (sizeof(UInt32) * 8)));\n+typedef UInt32 UInt32x16 __attribute__ ((vector_size (sizeof(UInt32) * 16)));\n+\n+typedef UInt16 UInt16x2  __attribute__ ((vector_size (sizeof(UInt16) * 2)));\n+typedef UInt16 UInt16x4  __attribute__ ((vector_size (sizeof(UInt16) * 4)));\n+typedef UInt16 UInt16x8  __attribute__ ((vector_size (sizeof(UInt16) * 8)));\n+typedef UInt16 UInt16x16 __attribute__ ((vector_size (sizeof(UInt16) * 16)));\n+typedef UInt16 UInt16x32 __attribute__ ((vector_size (sizeof(UInt16) * 32)));\n+\n+typedef UInt8 UInt8x2   __attribute__ ((vector_size (sizeof(UInt8) * 2)));\n+typedef UInt8 UInt8x4   __attribute__ ((vector_size (sizeof(UInt8) * 4)));\n+typedef UInt8 UInt8x8   __attribute__ ((vector_size (sizeof(UInt8) * 8)));\n+typedef UInt8 UInt8x16  __attribute__ ((vector_size (sizeof(UInt8) * 16)));\n+typedef UInt8 UInt8x32  __attribute__ ((vector_size (sizeof(UInt8) * 32)));\n+typedef UInt8 UInt8x64  __attribute__ ((vector_size (sizeof(UInt8) * 64)));\n+\n+namespace detail\n+{\n+    template <int Size>\n+    struct DummyStruct;\n+\n+    template <>\n+    struct DummyStruct<4>\n+    {\n+        using UInt8Type = UInt8x4;\n+        using UInt16Type = UInt16x4;\n+        using UInt32Type = UInt32x4;\n+        using UInt64Type = UInt64x4;\n+    };\n+    template <>\n+    struct DummyStruct<8>\n+    {\n+        using UInt8Type = UInt8x8;\n+        using UInt16Type = UInt16x8;\n+        using UInt32Type = UInt32x8;\n+        using UInt64Type = UInt64x8;\n+    };\n+    template <>\n+    struct DummyStruct<16>\n+    {\n+        using UInt8Type = UInt8x16;\n+        using UInt16Type = UInt16x16;\n+        using UInt32Type = UInt32x16;\n+    };\n+    template <>\n+    struct DummyStruct<32>\n+    {\n+        using UInt8Type = UInt8x32;\n+        using UInt16Type = UInt16x32;\n+    };\n+\n+}\n+\n+// Same as above via template, e.g. UInt64x<8>\n+template <int Size>\n+using UInt8x = typename detail::DummyStruct<Size>::UInt8Type;\n+template <int Size>\n+using UInt16x = typename detail::DummyStruct<Size>::UInt16Type;\n+template <int Size>\n+using UInt32x = typename detail::DummyStruct<Size>::UInt32Type;\n+template <int Size>\n+using UInt64x = typename detail::DummyStruct<Size>::UInt64Type;\n+\n+}\ndiff --git a/src/Functions/generateUUIDv4.cpp b/src/Functions/generateUUIDv4.cpp\nindex 39013519d2fb..7dbb73c0cf34 100644\n--- a/src/Functions/generateUUIDv4.cpp\n+++ b/src/Functions/generateUUIDv4.cpp\n@@ -5,11 +5,16 @@\n namespace DB\n {\n \n+#define DECLARE_SEVERAL_IMPLEMENTATIONS(...) \\\n+DECLARE_DEFAULT_CODE      (__VA_ARGS__) \\\n+DECLARE_AVX2_SPECIFIC_CODE(__VA_ARGS__)\n+\n+DECLARE_SEVERAL_IMPLEMENTATIONS(\n+\n class FunctionGenerateUUIDv4 : public IFunction\n {\n public:\n     static constexpr auto name = \"generateUUIDv4\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionGenerateUUIDv4>(); }\n \n     String getName() const override\n     {\n@@ -32,6 +37,8 @@ class FunctionGenerateUUIDv4 : public IFunction\n \n         size_t size = input_rows_count;\n         vec_to.resize(size);\n+\n+        /// RandImpl is target-dependent and is not the same in different TargetSpecific namespaces.\n         RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), vec_to.size() * sizeof(UInt128));\n \n         for (UInt128 & uuid: vec_to)\n@@ -46,6 +53,37 @@ class FunctionGenerateUUIDv4 : public IFunction\n     }\n };\n \n+) // DECLARE_SEVERAL_IMPLEMENTATIONS\n+#undef DECLARE_SEVERAL_IMPLEMENTATIONS\n+\n+class FunctionGenerateUUIDv4 : public TargetSpecific::Default::FunctionGenerateUUIDv4\n+{\n+public:\n+    explicit FunctionGenerateUUIDv4(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            TargetSpecific::Default::FunctionGenerateUUIDv4>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            TargetSpecific::AVX2::FunctionGenerateUUIDv4>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionGenerateUUIDv4>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n void registerFunctionGenerateUUIDv4(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionGenerateUUIDv4>();\ndiff --git a/src/Functions/greatCircleDistance.cpp b/src/Functions/greatCircleDistance.cpp\nindex 238499f8def1..bff92d7738d3 100644\n--- a/src/Functions/greatCircleDistance.cpp\n+++ b/src/Functions/greatCircleDistance.cpp\n@@ -6,6 +6,8 @@\n #include <Functions/IFunctionImpl.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/FunctionFactory.h>\n+#include <Functions/TargetSpecific.h>\n+#include <Functions/PerformanceAdaptors.h>\n #include <ext/range.h>\n #include <cmath>\n \n@@ -153,6 +155,12 @@ enum class Method\n     WGS84_METERS,\n };\n \n+}\n+\n+DECLARE_MULTITARGET_CODE(\n+\n+namespace\n+{\n \n template <Method method>\n float distance(float lon1deg, float lat1deg, float lon2deg, float lat2deg)\n@@ -220,7 +228,6 @@ float distance(float lon1deg, float lat1deg, float lon2deg, float lat2deg)\n \n }\n \n-\n template <Method method>\n class FunctionGeoDistance : public IFunction\n {\n@@ -230,8 +237,6 @@ class FunctionGeoDistance : public IFunction\n         : ((method == Method::SPHERE_METERS) ? \"greatCircleDistance\"\n             : \"geoDistance\");\n \n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionGeoDistance<method>>(); }\n-\n private:\n     String getName() const override { return name; }\n     size_t getNumberOfArguments() const override { return 4; }\n@@ -272,6 +277,40 @@ class FunctionGeoDistance : public IFunction\n     }\n };\n \n+) // DECLARE_MULTITARGET_CODE\n+\n+template <Method method>\n+class FunctionGeoDistance : public TargetSpecific::Default::FunctionGeoDistance<method>\n+{\n+public:\n+    explicit FunctionGeoDistance(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            TargetSpecific::Default::FunctionGeoDistance<method>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX,\n+            TargetSpecific::AVX::FunctionGeoDistance<method>>();\n+        selector.registerImplementation<TargetArch::AVX2,\n+            TargetSpecific::AVX2::FunctionGeoDistance<method>>();\n+        selector.registerImplementation<TargetArch::AVX512F,\n+            TargetSpecific::AVX512F::FunctionGeoDistance<method>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionGeoDistance<method>>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n \n void registerFunctionGeoDistance(FunctionFactory & factory)\n {\ndiff --git a/src/Functions/randConstant.cpp b/src/Functions/randConstant.cpp\nindex bad4b199ee2a..ebf2f752b66f 100644\n--- a/src/Functions/randConstant.cpp\n+++ b/src/Functions/randConstant.cpp\n@@ -99,7 +99,8 @@ class RandomConstantOverloadResolver : public IFunctionOverloadResolverImpl\n             argument_types.emplace_back(arguments.back().type);\n \n         typename ColumnVector<ToType>::Container vec_to(1);\n-        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));\n+\n+        TargetSpecific::Default::RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));\n         ToType value = vec_to[0];\n \n         return std::make_unique<FunctionBaseRandomConstant<ToType, Name>>(value, argument_types, return_type);\ndiff --git a/src/Functions/randomFixedString.cpp b/src/Functions/randomFixedString.cpp\nindex 9fb7550346be..669dc0849992 100644\n--- a/src/Functions/randomFixedString.cpp\n+++ b/src/Functions/randomFixedString.cpp\n@@ -3,6 +3,8 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunctionImpl.h>\n+#include <Functions/PerformanceAdaptors.h>\n+#include <Functions/FunctionsRandom.h>\n #include <pcg_random.hpp>\n #include <Common/randomSeed.h>\n #include <common/arithmeticOverflow.h>\n@@ -21,13 +23,12 @@ namespace ErrorCodes\n \n \n /* Generate random fixed string with fully random bytes (including zero). */\n-class FunctionRandomFixedString : public IFunction\n+template <typename RandImpl>\n+class FunctionRandomFixedStringImpl : public IFunction\n {\n public:\n     static constexpr auto name = \"randomFixedString\";\n \n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionRandomFixedString>(); }\n-\n     String getName() const override { return name; }\n \n     bool isVariadic() const override { return false; }\n@@ -68,20 +69,40 @@ class FunctionRandomFixedString : public IFunction\n \n         /// Fill random bytes.\n         data_to.resize(total_size);\n-        pcg64_fast rng(randomSeed()); /// TODO It is inefficient. We should use SIMD PRNG instead.\n-\n-        auto * pos = data_to.data();\n-        auto * end = pos + data_to.size();\n-        while (pos < end)\n-        {\n-            unalignedStore<UInt64>(pos, rng());\n-            pos += sizeof(UInt64); // We have padding in column buffers that we can overwrite.\n-        }\n+        RandImpl::execute(reinterpret_cast<char *>(data_to.data()), total_size);\n \n         block.getByPosition(result).column = std::move(col_to);\n     }\n };\n \n+class FunctionRandomFixedString : public FunctionRandomFixedStringImpl<TargetSpecific::Default::RandImpl>\n+{\n+public:\n+    explicit FunctionRandomFixedString(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            FunctionRandomFixedStringImpl<TargetSpecific::Default::RandImpl>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            FunctionRandomFixedStringImpl<TargetSpecific::AVX2::RandImpl>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionRandomFixedString>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n void registerFunctionRandomFixedString(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionRandomFixedString>();\ndiff --git a/src/Functions/randomString.cpp b/src/Functions/randomString.cpp\nindex 4ea470f0a65e..df3278c38004 100644\n--- a/src/Functions/randomString.cpp\n+++ b/src/Functions/randomString.cpp\n@@ -3,6 +3,8 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunctionImpl.h>\n+#include <Functions/FunctionsRandom.h>\n+#include <Functions/PerformanceAdaptors.h>\n #include <pcg_random.hpp>\n #include <Common/randomSeed.h>\n #include <common/unaligned.h>\n@@ -19,13 +21,12 @@ namespace ErrorCodes\n \n \n /* Generate random string of specified length with fully random bytes (including zero). */\n-class FunctionRandomString : public IFunction\n+template <typename RandImpl>\n+class FunctionRandomStringImpl : public IFunction\n {\n public:\n     static constexpr auto name = \"randomString\";\n \n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionRandomString>(); }\n-\n     String getName() const override { return name; }\n \n     bool isVariadic() const override { return true; }\n@@ -83,18 +84,10 @@ class FunctionRandomString : public IFunction\n \n         /// Fill random bytes.\n         data_to.resize(offsets_to.back());\n-        pcg64_fast rng(randomSeed()); /// TODO It is inefficient. We should use SIMD PRNG instead.\n-\n-        auto * pos = data_to.data();\n-        auto * end = pos + data_to.size();\n-        while (pos < end)\n-        {\n-            unalignedStore<UInt64>(pos, rng());\n-            pos += sizeof(UInt64); // We have padding in column buffers that we can overwrite.\n-        }\n+        RandImpl::execute(reinterpret_cast<char *>(data_to.data()), data_to.size());\n \n         /// Put zero bytes in between.\n-        pos = data_to.data();\n+        auto * pos = data_to.data();\n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n             pos[offsets_to[row_num] - 1] = 0;\n \n@@ -102,6 +95,34 @@ class FunctionRandomString : public IFunction\n     }\n };\n \n+class FunctionRandomString : public FunctionRandomStringImpl<TargetSpecific::Default::RandImpl>\n+{\n+public:\n+    explicit FunctionRandomString(const Context & context) : selector(context)\n+    {\n+        selector.registerImplementation<TargetArch::Default,\n+            FunctionRandomStringImpl<TargetSpecific::Default::RandImpl>>();\n+\n+    #if USE_MULTITARGET_CODE\n+        selector.registerImplementation<TargetArch::AVX2,\n+            FunctionRandomStringImpl<TargetSpecific::AVX2::RandImpl>>();\n+    #endif\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        selector.selectAndExecute(block, arguments, result, input_rows_count);\n+    }\n+\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionRandomString>(context);\n+    }\n+\n+private:\n+    ImplementationSelector<IFunction> selector;\n+};\n+\n void registerFunctionRandomString(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionRandomString>();\n",
  "test_patch": "diff --git a/tests/performance/rand.xml b/tests/performance/rand.xml\nnew file mode 100644\nindex 000000000000..ed629e5a2a76\n--- /dev/null\n+++ b/tests/performance/rand.xml\n@@ -0,0 +1,24 @@\n+<test>\n+    <stop_conditions>\n+        <all_of>\n+            <total_time_ms>10000</total_time_ms>\n+        </all_of>\n+        <any_of>\n+            <total_time_ms>20000</total_time_ms>\n+        </any_of>\n+    </stop_conditions>\n+\n+\n+    <substitutions>\n+        <substitution>\n+           <name>table</name>\n+           <values>\n+               <value>zeros(100000000)</value>\n+           </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>SELECT count() FROM (SELECT rand() FROM {table}) </query>\n+    <query>SELECT count() FROM (SELECT rand64() FROM {table}) </query>\n+    <query>SELECT count() FROM (SELECT generateUUIDv4() FROM {table}) </query>\n+</test>\n",
  "problem_statement": "FR: dynamic dispatch of SIMD algorithms to support AVX2/AVX512\nI dived into the code and addressed some SSE optimizations. Well done guys, I appreciate that you delivered and shared such a greate AP system.\r\n\r\nAnd I found nothing about AVX optimizations, it is on the plan ?\n",
  "hints_text": "Thank you for appreciation!\r\n\r\nWe have AVX optimizations in long list of features to implement. Probably we will introduce them in few single places where it could provide maximum benefit (your suggestions?). This will require dynamic dispatching as long as we still have many hardware without AVX support.\nLook forward to it!\nThis task is assigned to @DimasKovas.\r\nHe will try to port some optimizations to newer instruction sets with dynamic dispatching and perform some experiment for optimizations targeted to ARM NEON.",
  "created_at": "2020-04-06T07:52:26Z",
  "modified_files": [
    "src/Common/ErrorCodes.cpp",
    "src/Compression/CompressionFactory.cpp",
    "src/Core/Settings.h",
    "src/Core/SettingsCollection.h",
    "src/Functions/CMakeLists.txt",
    "src/Functions/FunctionStartsEndsWith.h",
    "src/Functions/FunctionsHashing.h",
    "src/Functions/FunctionsRandom.cpp",
    "src/Functions/FunctionsRandom.h",
    "src/Functions/IFunctionImpl.h",
    "b/src/Functions/PerformanceAdaptors.h",
    "b/src/Functions/TargetSpecific.cpp",
    "b/src/Functions/TargetSpecific.h",
    "b/src/Functions/VectorExtension.h",
    "src/Functions/generateUUIDv4.cpp",
    "src/Functions/greatCircleDistance.cpp",
    "src/Functions/randConstant.cpp",
    "src/Functions/randomFixedString.cpp",
    "src/Functions/randomString.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/rand.xml"
  ]
}