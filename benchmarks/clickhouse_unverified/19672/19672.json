{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19672,
  "instance_id": "ClickHouse__ClickHouse-19672",
  "issue_numbers": [
    "19667"
  ],
  "base_commit": "2892aa39c0be01d74f7584bddf30667ea5f54e0d",
  "patch": "diff --git a/base/common/extended_types.h b/base/common/extended_types.h\nindex ea475163f6a9..2ae70c0f4320 100644\n--- a/base/common/extended_types.h\n+++ b/base/common/extended_types.h\n@@ -104,8 +104,3 @@ template <> struct is_big_int<wUInt256> { static constexpr bool value = true; };\n template <typename T>\n inline constexpr bool is_big_int_v = is_big_int<T>::value;\n \n-template <typename To, typename From>\n-inline To bigint_cast(const From & x [[maybe_unused]])\n-{\n-    return static_cast<To>(x);\n-}\ndiff --git a/src/Columns/ColumnDecimal.cpp b/src/Columns/ColumnDecimal.cpp\nindex 885df0446df1..f6261079287c 100644\n--- a/src/Columns/ColumnDecimal.cpp\n+++ b/src/Columns/ColumnDecimal.cpp\n@@ -4,7 +4,6 @@\n #include <Common/assert_cast.h>\n #include <Common/WeakHash.h>\n #include <Common/HashTable/Hash.h>\n-#include <Core/BigInt.h>\n \n #include <common/unaligned.h>\n #include <common/sort.h>\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex d768757227b9..fcbcc63731a7 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -37,33 +37,16 @@ namespace ErrorCodes\n template <typename T>\n StringRef ColumnVector<T>::serializeValueIntoArena(size_t n, Arena & arena, char const *& begin) const\n {\n-    if constexpr (is_big_int_v<T>)\n-    {\n-        static constexpr size_t bytesize = BigInt<T>::size;\n-        char * pos = arena.allocContinue(bytesize, begin);\n-        return BigInt<T>::serialize(data[n], pos);\n-    }\n-    else\n-    {\n-        auto * pos = arena.allocContinue(sizeof(T), begin);\n-        unalignedStore<T>(pos, data[n]);\n-        return StringRef(pos, sizeof(T));\n-    }\n+    auto * pos = arena.allocContinue(sizeof(T), begin);\n+    unalignedStore<T>(pos, data[n]);\n+    return StringRef(pos, sizeof(T));\n }\n \n template <typename T>\n const char * ColumnVector<T>::deserializeAndInsertFromArena(const char * pos)\n {\n-    if constexpr (is_big_int_v<T>)\n-    {\n-        data.emplace_back(BigInt<T>::deserialize(pos));\n-        return pos + BigInt<T>::size;\n-    }\n-    else\n-    {\n-        data.emplace_back(unalignedLoad<T>(pos));\n-        return pos + sizeof(T);\n-    }\n+    data.emplace_back(unalignedLoad<T>(pos));\n+    return pos + sizeof(T);\n }\n \n template <typename T>\n@@ -299,18 +282,10 @@ MutableColumnPtr ColumnVector<T>::cloneResized(size_t size) const\n         new_col.data.resize(size);\n \n         size_t count = std::min(this->size(), size);\n-        if constexpr (is_POD)\n-        {\n-            memcpy(new_col.data.data(), data.data(), count * sizeof(data[0]));\n+        memcpy(new_col.data.data(), data.data(), count * sizeof(data[0]));\n \n-            if (size > count)\n-                memset(static_cast<void *>(&new_col.data[count]), static_cast<int>(ValueType()), (size - count) * sizeof(ValueType));\n-        }\n-        else\n-        {\n-            for (size_t i = 0; i < count; i++)\n-                new_col.data[i] = data[i];\n-        }\n+        if (size > count)\n+            memset(static_cast<void *>(&new_col.data[count]), static_cast<int>(ValueType()), (size - count) * sizeof(ValueType));\n     }\n \n     return res;\n@@ -348,15 +323,7 @@ void ColumnVector<T>::insertRangeFrom(const IColumn & src, size_t start, size_t\n \n     size_t old_size = data.size();\n     data.resize(old_size + length);\n-    if constexpr (is_POD)\n-    {\n-        memcpy(data.data() + old_size, &src_vec.data[start], length * sizeof(data[0]));\n-    }\n-    else\n-    {\n-        for (size_t i = 0; i < length; i++)\n-            data[old_size + i] = src_vec.data[start + i];\n-    }\n+    memcpy(data.data() + old_size, &src_vec.data[start], length * sizeof(data[0]));\n }\n \n template <typename T>\n@@ -372,70 +339,52 @@ ColumnPtr ColumnVector<T>::filter(const IColumn::Filter & filt, ssize_t result_s\n     if (result_size_hint)\n         res_data.reserve(result_size_hint > 0 ? result_size_hint : size);\n \n-    if constexpr (is_POD)\n-    {\n-        const UInt8 * filt_pos = filt.data();\n-        const UInt8 * filt_end = filt_pos + size;\n-        const T * data_pos = data.data();\n+    const UInt8 * filt_pos = filt.data();\n+    const UInt8 * filt_end = filt_pos + size;\n+    const T * data_pos = data.data();\n \n #ifdef __SSE2__\n-        /** A slightly more optimized version.\n-        * Based on the assumption that often pieces of consecutive values\n-        *  completely pass or do not pass the filter.\n-        * Therefore, we will optimistically check the parts of `SIMD_BYTES` values.\n-        */\n+    /** A slightly more optimized version.\n+    * Based on the assumption that often pieces of consecutive values\n+    *  completely pass or do not pass the filter.\n+    * Therefore, we will optimistically check the parts of `SIMD_BYTES` values.\n+    */\n \n-        static constexpr size_t SIMD_BYTES = 16;\n-        const __m128i zero16 = _mm_setzero_si128();\n-        const UInt8 * filt_end_sse = filt_pos + size / SIMD_BYTES * SIMD_BYTES;\n+    static constexpr size_t SIMD_BYTES = 16;\n+    const __m128i zero16 = _mm_setzero_si128();\n+    const UInt8 * filt_end_sse = filt_pos + size / SIMD_BYTES * SIMD_BYTES;\n \n-        while (filt_pos < filt_end_sse)\n-        {\n-            int mask = _mm_movemask_epi8(_mm_cmpgt_epi8(_mm_loadu_si128(reinterpret_cast<const __m128i *>(filt_pos)), zero16));\n-\n-            if (0 == mask)\n-            {\n-                /// Nothing is inserted.\n-            }\n-            else if (0xFFFF == mask)\n-            {\n-                res_data.insert(data_pos, data_pos + SIMD_BYTES);\n-            }\n-            else\n-            {\n-                for (size_t i = 0; i < SIMD_BYTES; ++i)\n-                    if (filt_pos[i])\n-                        res_data.push_back(data_pos[i]);\n-            }\n+    while (filt_pos < filt_end_sse)\n+    {\n+        int mask = _mm_movemask_epi8(_mm_cmpgt_epi8(_mm_loadu_si128(reinterpret_cast<const __m128i *>(filt_pos)), zero16));\n \n-            filt_pos += SIMD_BYTES;\n-            data_pos += SIMD_BYTES;\n+        if (0 == mask)\n+        {\n+            /// Nothing is inserted.\n         }\n-#endif\n-\n-        while (filt_pos < filt_end)\n+        else if (0xFFFF == mask)\n         {\n-            if (*filt_pos)\n-                res_data.push_back(*data_pos);\n-\n-            ++filt_pos;\n-            ++data_pos;\n+            res_data.insert(data_pos, data_pos + SIMD_BYTES);\n+        }\n+        else\n+        {\n+            for (size_t i = 0; i < SIMD_BYTES; ++i)\n+                if (filt_pos[i])\n+                    res_data.push_back(data_pos[i]);\n         }\n+\n+        filt_pos += SIMD_BYTES;\n+        data_pos += SIMD_BYTES;\n     }\n-    else\n-    {\n-        const auto * filt_pos = filt.begin();\n-        const auto * filt_end = filt.end();\n-        auto data_pos = data.begin();\n+#endif\n \n-        while (filt_pos < filt_end)\n-        {\n-            if (*filt_pos)\n-                res_data.push_back(*data_pos);\n+    while (filt_pos < filt_end)\n+    {\n+        if (*filt_pos)\n+            res_data.push_back(*data_pos);\n \n-            ++filt_pos;\n-            ++data_pos;\n-        }\n+        ++filt_pos;\n+        ++data_pos;\n     }\n \n     return res;\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 59fe567fb9c3..1b13859bdee1 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -6,7 +6,6 @@\n #include <Columns/ColumnVectorHelper.h>\n #include <common/unaligned.h>\n #include <Core/Field.h>\n-#include <Core/BigInt.h>\n #include <Common/assert_cast.h>\n \n \n@@ -107,10 +106,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n \n public:\n     using ValueType = T;\n-    static constexpr bool is_POD = !is_big_int_v<T>;\n-    using Container = std::conditional_t<is_POD,\n-                                         PaddedPODArray<ValueType>,\n-                                         std::vector<ValueType>>;\n+    using Container = PaddedPODArray<ValueType>;\n \n private:\n     ColumnVector() {}\n@@ -136,10 +132,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n \n     void insertData(const char * pos, size_t) override\n     {\n-        if constexpr (is_POD)\n-            data.emplace_back(unalignedLoad<T>(pos));\n-        else\n-            data.emplace_back(BigInt<T>::deserialize(pos));\n+        data.emplace_back(unalignedLoad<T>(pos));\n     }\n \n     void insertDefault() override\n@@ -149,18 +142,12 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n \n     void insertManyDefaults(size_t length) override\n     {\n-        if constexpr (is_POD)\n-            data.resize_fill(data.size() + length, T());\n-        else\n-            data.resize(data.size() + length, T());\n+        data.resize_fill(data.size() + length, T());\n     }\n \n     void popBack(size_t n) override\n     {\n-        if constexpr (is_POD)\n-            data.resize_assume_reserved(data.size() - n);\n-        else\n-            data.resize(data.size() - n);\n+        data.resize_assume_reserved(data.size() - n);\n     }\n \n     StringRef serializeValueIntoArena(size_t n, Arena & arena, char const *& begin) const override;\n@@ -185,16 +172,12 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n \n     size_t allocatedBytes() const override\n     {\n-        if constexpr (is_POD)\n-            return data.allocated_bytes();\n-        else\n-            return data.capacity() * sizeof(data[0]);\n+        return data.allocated_bytes();\n     }\n \n     void protect() override\n     {\n-        if constexpr (is_POD)\n-            data.protect();\n+        data.protect();\n     }\n \n     void insertValue(const T value)\ndiff --git a/src/Common/FieldVisitors.h b/src/Common/FieldVisitors.h\nindex 314609ee1a03..954cd004e846 100644\n--- a/src/Common/FieldVisitors.h\n+++ b/src/Common/FieldVisitors.h\n@@ -235,7 +235,7 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n         else if constexpr (std::is_same_v<T, UInt128>)\n             throw Exception(\"No conversion to old UInt128 from \" + demangle(typeid(U).name()), ErrorCodes::NOT_IMPLEMENTED);\n         else\n-            return bigint_cast<T>(x);\n+            return static_cast<T>(x);\n     }\n };\n \ndiff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h\nindex 3d9cec1bb23c..ef20b70917d1 100644\n--- a/src/Common/HashTable/Hash.h\n+++ b/src/Common/HashTable/Hash.h\n@@ -1,7 +1,6 @@\n #pragma once\n \n #include <common/types.h>\n-#include <Core/BigInt.h>\n #include <Common/UInt128.h>\n #include <common/unaligned.h>\n \ndiff --git a/src/Common/SipHash.h b/src/Common/SipHash.h\nindex f4f869516523..ce7e80a7204a 100644\n--- a/src/Common/SipHash.h\n+++ b/src/Common/SipHash.h\n@@ -18,7 +18,7 @@\n #include <string>\n #include <type_traits>\n #include <Core/Defines.h>\n-#include <Core/BigInt.h>\n+\n \n #define ROTL(x, b) static_cast<UInt64>(((x) << (b)) | ((x) >> (64 - (b))))\n \n@@ -136,23 +136,11 @@ class SipHash\n     }\n \n     template <typename T>\n-    std::enable_if_t<std::has_unique_object_representations_v<T>, void> update(const T & x)\n-    {\n-        update(reinterpret_cast<const char *>(&x), sizeof(x));\n-    }\n-\n-    template <typename T>\n-    std::enable_if_t<(std::is_floating_point_v<T> || std::is_same_v<T, CityHash_v1_0_2::uint128>), void> update(const T & x)\n+    void update(const T & x)\n     {\n         update(reinterpret_cast<const char *>(&x), sizeof(x));\n     }\n \n-    template <typename T>\n-    std::enable_if_t<is_big_int_v<T> && !std::has_unique_object_representations_v<T>, void> update(const T & x)\n-    {\n-        update(DB::BigInt<T>::serialize(x));\n-    }\n-\n     void update(const std::string & x)\n     {\n         update(x.data(), x.length());\n@@ -205,27 +193,13 @@ inline UInt64 sipHash64(const char * data, const size_t size)\n }\n \n template <typename T>\n-std::enable_if_t<std::has_unique_object_representations_v<T>, UInt64> sipHash64(const T & x)\n+UInt64 sipHash64(const T & x)\n {\n     SipHash hash;\n     hash.update(x);\n     return hash.get64();\n }\n \n-template <typename T>\n-std::enable_if_t<(std::is_floating_point_v<T> || (is_big_int_v<T> && !std::has_unique_object_representations_v<T>)), UInt64> sipHash64(const T & x)\n-{\n-    SipHash hash;\n-    hash.update(x);\n-    return hash.get64();\n-}\n-\n-template <typename T>\n-std::enable_if_t<DB::IsDecimalNumber<T>, UInt64> sipHash64(const T & x)\n-{\n-    return sipHash64(x.value);\n-}\n-\n inline UInt64 sipHash64(const std::string & s)\n {\n     return sipHash64(s.data(), s.size());\ndiff --git a/src/Compression/CompressionCodecT64.h b/src/Compression/CompressionCodecT64.h\nindex d930ea353c43..9f8ec7cc4d55 100644\n--- a/src/Compression/CompressionCodecT64.h\n+++ b/src/Compression/CompressionCodecT64.h\n@@ -1,6 +1,6 @@\n #pragma once\n \n-#include <common/types.h>\n+#include <Core/Types.h>\n #include <Compression/ICompressionCodec.h>\n \n \ndiff --git a/src/Core/AccurateComparison.h b/src/Core/AccurateComparison.h\nindex c533cf0c7fbc..8b2f20f0af5f 100644\n--- a/src/Core/AccurateComparison.h\n+++ b/src/Core/AccurateComparison.h\n@@ -93,7 +93,7 @@ using bool_if_gt_int_vs_uint = std::enable_if_t<is_gt_int_vs_uint<TInt, TUInt>,\n template <typename TInt, typename TUInt>\n inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TInt a, TUInt b)\n {\n-    return bigint_cast<TInt>(a) > bigint_cast<TInt>(b);\n+    return static_cast<TInt>(a) > static_cast<TInt>(b);\n }\n \n template <typename TInt, typename TUInt>\n@@ -101,19 +101,19 @@ inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TUInt a, TInt b)\n {\n     using CastA = std::conditional_t<is_big_int_v<TInt> && std::is_same_v<TUInt, DB::UInt128>, DB::UInt256, TInt>;\n \n-    return bigint_cast<CastA>(a) > b;\n+    return static_cast<CastA>(a) > b;\n }\n \n template <typename TInt, typename TUInt>\n inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TInt a, TUInt b)\n {\n-    return bigint_cast<TInt>(a) == bigint_cast<TInt>(b);\n+    return static_cast<TInt>(a) == static_cast<TInt>(b);\n }\n \n template <typename TInt, typename TUInt>\n inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TUInt a, TInt b)\n {\n-    return bigint_cast<TInt>(a) == bigint_cast<TInt>(b);\n+    return static_cast<TInt>(a) == static_cast<TInt>(b);\n }\n \n \n@@ -196,7 +196,7 @@ inline bool_if_safe_conversion<A, B> greaterOp(A a, B b)\n     using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n \n     if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return bigint_cast<CastA>(a) > bigint_cast<CastB>(b);\n+        return static_cast<CastA>(a) > static_cast<CastB>(b);\n     else\n         return a > b;\n }\n@@ -306,7 +306,7 @@ inline bool_if_safe_conversion<A, B> equalsOp(A a, B b)\n {\n     using LargestType = std::conditional_t<(sizeof(A) > sizeof(B)) || ((sizeof(A) == sizeof(B)) && !std::is_same_v<A, DB::UInt128>), A, B>;\n \n-    return bigint_cast<LargestType>(a) == bigint_cast<LargestType>(b);\n+    return static_cast<LargestType>(a) == static_cast<LargestType>(b);\n }\n \n template <>\n@@ -429,7 +429,7 @@ inline bool_if_safe_conversion<A, B> notEqualsOp(A a, B b)\n     using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n \n     if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return bigint_cast<CastA>(a) != bigint_cast<CastB>(b);\n+        return static_cast<CastA>(a) != static_cast<CastB>(b);\n     else\n         return a != b;\n }\n@@ -451,7 +451,7 @@ inline bool_if_safe_conversion<A, B> lessOp(A a, B b)\n     using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n \n     if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return bigint_cast<CastA>(a) < bigint_cast<CastB>(b);\n+        return static_cast<CastA>(a) < static_cast<CastB>(b);\n     else\n         return a < b;\n }\n@@ -475,7 +475,7 @@ inline bool_if_safe_conversion<A, B> lessOrEqualsOp(A a, B b)\n     using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n \n     if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return bigint_cast<CastA>(a) <= bigint_cast<CastB>(b);\n+        return static_cast<CastA>(a) <= static_cast<CastB>(b);\n     else\n         return a <= b;\n }\n@@ -499,7 +499,7 @@ inline bool_if_safe_conversion<A, B> greaterOrEqualsOp(A a, B b)\n     using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n \n     if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return bigint_cast<CastA>(a) >= bigint_cast<CastB>(b);\n+        return static_cast<CastA>(a) >= static_cast<CastB>(b);\n     else\n         return a >= b;\n }\ndiff --git a/src/Core/BigInt.h b/src/Core/BigInt.h\ndeleted file mode 100644\nindex 8ce765fbc209..000000000000\n--- a/src/Core/BigInt.h\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-#pragma once\n-\n-#include <common/StringRef.h>\n-#include <common/unaligned.h>\n-#include <Core/Types.h>\n-\n-\n-namespace DB\n-{\n-\n-template <typename T>\n-struct BigInt\n-{\n-    static_assert(sizeof(T) == 32);\n-    static constexpr size_t size = 32;\n-\n-    static StringRef serialize(const T & x, char * pos)\n-    {\n-        unalignedStore<T>(pos, x);\n-        return StringRef(pos, size);\n-    }\n-\n-    static String serialize(const T & x)\n-    {\n-        String str(size, '\\0');\n-        serialize(x, str.data());\n-        return str;\n-    }\n-\n-    static T deserialize(const char * pos)\n-    {\n-        return unalignedLoad<T>(pos);\n-    }\n-};\n-\n-}\ndiff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h\nindex d1537592e768..aaf471cefd8f 100644\n--- a/src/Core/DecimalComparison.h\n+++ b/src/Core/DecimalComparison.h\n@@ -233,9 +233,9 @@ class DecimalComparison\n             bool overflow = false;\n \n             if constexpr (sizeof(A) > sizeof(CompareInt))\n-                overflow |= (bigint_cast<A>(x) != a);\n+                overflow |= (static_cast<A>(x) != a);\n             if constexpr (sizeof(B) > sizeof(CompareInt))\n-                overflow |= (bigint_cast<B>(y) != b);\n+                overflow |= (static_cast<B>(y) != b);\n             if constexpr (is_unsigned_v<A>)\n                 overflow |= (x < 0);\n             if constexpr (is_unsigned_v<B>)\ndiff --git a/src/Core/Types.h b/src/Core/Types.h\nindex d96506f31ccd..a463455cbe1e 100644\n--- a/src/Core/Types.h\n+++ b/src/Core/Types.h\n@@ -158,7 +158,7 @@ struct Decimal\n             return convertTo<typename U::NativeType>();\n         }\n         else\n-            return bigint_cast<U>(value);\n+            return static_cast<U>(value);\n     }\n \n     const Decimal<T> & operator += (const T & x) { value += x; return *this; }\ndiff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h\nindex 77bd2101f058..3aa00c682749 100644\n--- a/src/DataTypes/NumberTraits.h\n+++ b/src/DataTypes/NumberTraits.h\n@@ -218,7 +218,7 @@ using ResultOfGreatest = std::conditional_t<LeastGreatestSpecialCase<A, B>,\n template <typename T>\n static inline auto littleBits(const T & x)\n {\n-    return bigint_cast<UInt8>(x);\n+    return static_cast<UInt8>(x);\n }\n \n }\ndiff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h\nindex 7a816df70e54..9f9cfc1e72ca 100644\n--- a/src/Functions/DivisionUtils.h\n+++ b/src/Functions/DivisionUtils.h\n@@ -51,9 +51,9 @@ inline auto checkedDivision(A a, B b)\n     throwIfDivisionLeadsToFPE(a, b);\n \n     if constexpr (is_big_int_v<A> && std::is_floating_point_v<B>)\n-        return bigint_cast<B>(a) / b;\n+        return static_cast<B>(a) / b;\n     else if constexpr (is_big_int_v<B> && std::is_floating_point_v<A>)\n-        return a / bigint_cast<A>(b);\n+        return a / static_cast<A>(b);\n     else if constexpr (is_big_int_v<A> && is_big_int_v<B>)\n         return static_cast<A>(a / b);\n     else if constexpr (!is_big_int_v<A> && is_big_int_v<B>)\n@@ -84,10 +84,10 @@ struct DivideIntegralImpl\n             using SignedCastA = make_signed_t<CastA>;\n             using SignedCastB = std::conditional_t<sizeof(A) <= sizeof(B), make_signed_t<CastB>, SignedCastA>;\n \n-            return bigint_cast<Result>(checkedDivision(bigint_cast<SignedCastA>(a), bigint_cast<SignedCastB>(b)));\n+            return static_cast<Result>(checkedDivision(static_cast<SignedCastA>(a), static_cast<SignedCastB>(b)));\n         }\n         else\n-            return bigint_cast<Result>(checkedDivision(CastA(a), CastB(b)));\n+            return static_cast<Result>(checkedDivision(CastA(a), CastB(b)));\n     }\n \n #if USE_EMBEDDED_COMPILER\n@@ -110,7 +110,7 @@ struct ModuloImpl\n         if constexpr (std::is_floating_point_v<ResultType>)\n         {\n             /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.\n-            return bigint_cast<ResultType>(a) - trunc(bigint_cast<ResultType>(a) / bigint_cast<ResultType>(b)) * bigint_cast<ResultType>(b);\n+            return static_cast<ResultType>(a) - trunc(static_cast<ResultType>(a) / static_cast<ResultType>(b)) * static_cast<ResultType>(b);\n         }\n         else\n         {\n@@ -125,9 +125,9 @@ struct ModuloImpl\n                 CastB int_b(b);\n \n                 if constexpr (is_big_int_v<IntegerBType> && sizeof(IntegerAType) <= sizeof(IntegerBType))\n-                    return bigint_cast<Result>(bigint_cast<CastB>(int_a) % int_b);\n+                    return static_cast<Result>(static_cast<CastB>(int_a) % int_b);\n                 else\n-                    return bigint_cast<Result>(int_a % bigint_cast<CastA>(int_b));\n+                    return static_cast<Result>(int_a % static_cast<CastA>(int_b));\n             }\n             else\n                 return IntegerAType(a) % IntegerBType(b);\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 957c7e0ab3e2..bbfa1ea20d8e 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -81,8 +81,8 @@ namespace ErrorCodes\n template <typename A, typename B, typename Op>\n struct NumComparisonImpl\n {\n-    using ContainerA = std::conditional_t<!is_big_int_v<A>, PaddedPODArray<A>, std::vector<A>>;\n-    using ContainerB = std::conditional_t<!is_big_int_v<B>, PaddedPODArray<B>, std::vector<B>>;\n+    using ContainerA = PaddedPODArray<A>;\n+    using ContainerB = PaddedPODArray<B>;\n \n     /// If you don't specify NO_INLINE, the compiler will inline this function, but we don't need this as this function contains tight loop inside.\n     static void NO_INLINE vectorVector(const ContainerA & a, const ContainerB & b, PaddedPODArray<UInt8> & c)\ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex fca27fe2f146..41152660e4f2 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -806,16 +806,7 @@ class FunctionAnyHash : public IFunction\n             size_t size = vec_from.size();\n             for (size_t i = 0; i < size; ++i)\n             {\n-                ToType h;\n-                if constexpr (OverBigInt<FromType>)\n-                {\n-                    using NativeT = typename NativeType<FromType>::Type;\n-\n-                    std::string buffer = BigInt<NativeT>::serialize(vec_from[i]);\n-                    h = Impl::apply(buffer.data(), buffer.size());\n-                }\n-                else\n-                    h = Impl::apply(reinterpret_cast<const char *>(&vec_from[i]), sizeof(vec_from[i]));\n+                ToType h = Impl::apply(reinterpret_cast<const char *>(&vec_from[i]), sizeof(vec_from[i]));\n \n                 if constexpr (first)\n                     vec_to[i] = h;\n@@ -827,16 +818,7 @@ class FunctionAnyHash : public IFunction\n         {\n             auto value = col_from_const->template getValue<FromType>();\n \n-            ToType h;\n-            if constexpr (OverBigInt<FromType>)\n-            {\n-                using NativeT = typename NativeType<FromType>::Type;\n-\n-                std::string buffer = BigInt<NativeT>::serialize(value);\n-                h = Impl::apply(buffer.data(), buffer.size());\n-            }\n-            else\n-                h = Impl::apply(reinterpret_cast<const char *>(&value), sizeof(value));\n+            ToType h = Impl::apply(reinterpret_cast<const char *>(&value), sizeof(value));\n \n             size_t size = vec_to.size();\n             if constexpr (first)\ndiff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h\nindex e8679c4c4009..616257493eb9 100644\n--- a/src/Functions/GatherUtils/Algorithms.h\n+++ b/src/Functions/GatherUtils/Algorithms.h\n@@ -50,9 +50,9 @@ void writeSlice(const NumericArraySlice<T> & slice, NumericArraySink<U> & sink)\n                 throw Exception(\"No conversion between UInt128 and \" + demangle(typeid(T).name()), ErrorCodes::NOT_IMPLEMENTED);\n             }\n             else if constexpr (IsDecimalNumber<T>)\n-                dst = bigint_cast<NativeU>(src.value);\n+                dst = static_cast<NativeU>(src.value);\n             else\n-                dst = bigint_cast<NativeU>(src);\n+                dst = static_cast<NativeU>(src);\n         }\n         else\n             dst = static_cast<NativeU>(src);\ndiff --git a/src/Functions/bitAnd.cpp b/src/Functions/bitAnd.cpp\nindex f02c8fbd4ee0..08fc4699c36a 100644\n--- a/src/Functions/bitAnd.cpp\n+++ b/src/Functions/bitAnd.cpp\n@@ -21,7 +21,7 @@ struct BitAndImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return bigint_cast<Result>(a) & bigint_cast<Result>(b);\n+        return static_cast<Result>(a) & static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\ndiff --git a/src/Functions/bitOr.cpp b/src/Functions/bitOr.cpp\nindex b3559e13e0ee..400c478fcbfa 100644\n--- a/src/Functions/bitOr.cpp\n+++ b/src/Functions/bitOr.cpp\n@@ -20,7 +20,7 @@ struct BitOrImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return bigint_cast<Result>(a) | bigint_cast<Result>(b);\n+        return static_cast<Result>(a) | static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\ndiff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp\nindex 3df3165a8e6b..9f8adf397412 100644\n--- a/src/Functions/bitShiftLeft.cpp\n+++ b/src/Functions/bitShiftLeft.cpp\n@@ -24,7 +24,7 @@ struct BitShiftLeftImpl\n         if constexpr (is_big_int_v<B>)\n             throw Exception(\"BitShiftLeft is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n         else if constexpr (is_big_int_v<A>)\n-            return bigint_cast<Result>(a) << bigint_cast<UInt32>(b);\n+            return static_cast<Result>(a) << static_cast<UInt32>(b);\n         else\n             return static_cast<Result>(a) << static_cast<Result>(b);\n     }\ndiff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp\nindex da3bd16c4c44..bc54d3c8b5d2 100644\n--- a/src/Functions/bitShiftRight.cpp\n+++ b/src/Functions/bitShiftRight.cpp\n@@ -24,7 +24,7 @@ struct BitShiftRightImpl\n         if constexpr (is_big_int_v<B>)\n             throw Exception(\"BitShiftRight is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n         else if constexpr (is_big_int_v<A>)\n-            return bigint_cast<Result>(a) >> bigint_cast<UInt32>(b);\n+            return static_cast<Result>(a) >> static_cast<UInt32>(b);\n         else\n             return static_cast<Result>(a) >> static_cast<Result>(b);\n     }\ndiff --git a/src/Functions/bitXor.cpp b/src/Functions/bitXor.cpp\nindex 9237cb76e590..c5867c8d2caa 100644\n--- a/src/Functions/bitXor.cpp\n+++ b/src/Functions/bitXor.cpp\n@@ -20,7 +20,7 @@ struct BitXorImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return bigint_cast<Result>(a) ^ bigint_cast<Result>(b);\n+        return static_cast<Result>(a) ^ static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex 8b19016f3f72..3be4848f1ff6 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -60,7 +60,7 @@ struct NumIfImpl\n         typename ColVecResult::Container & res = col_res->getData();\n \n         for (size_t i = 0; i < size; ++i)\n-            res[i] = cond[i] ? bigint_cast<ResultType>(a[i]) : bigint_cast<ResultType>(b[i]);\n+            res[i] = cond[i] ? static_cast<ResultType>(a[i]) : static_cast<ResultType>(b[i]);\n         return col_res;\n     }\n \n@@ -71,7 +71,7 @@ struct NumIfImpl\n         typename ColVecResult::Container & res = col_res->getData();\n \n         for (size_t i = 0; i < size; ++i)\n-            res[i] = cond[i] ? bigint_cast<ResultType>(a[i]) : bigint_cast<ResultType>(b);\n+            res[i] = cond[i] ? static_cast<ResultType>(a[i]) : static_cast<ResultType>(b);\n         return col_res;\n     }\n \n@@ -82,7 +82,7 @@ struct NumIfImpl\n         typename ColVecResult::Container & res = col_res->getData();\n \n         for (size_t i = 0; i < size; ++i)\n-            res[i] = cond[i] ? bigint_cast<ResultType>(a) : bigint_cast<ResultType>(b[i]);\n+            res[i] = cond[i] ? static_cast<ResultType>(a) : static_cast<ResultType>(b[i]);\n         return col_res;\n     }\n \n@@ -93,7 +93,7 @@ struct NumIfImpl\n         typename ColVecResult::Container & res = col_res->getData();\n \n         for (size_t i = 0; i < size; ++i)\n-            res[i] = cond[i] ? bigint_cast<ResultType>(a) : bigint_cast<ResultType>(b);\n+            res[i] = cond[i] ? static_cast<ResultType>(a) : static_cast<ResultType>(b);\n         return col_res;\n     }\n };\ndiff --git a/src/Functions/least.cpp b/src/Functions/least.cpp\nindex e84d9bd9e24d..ba87e4bd7e41 100644\n--- a/src/Functions/least.cpp\n+++ b/src/Functions/least.cpp\n@@ -17,7 +17,7 @@ struct LeastBaseImpl\n     static inline Result apply(A a, B b)\n     {\n         /** gcc 4.9.2 successfully vectorizes a loop from this function. */\n-        return bigint_cast<Result>(a) < bigint_cast<Result>(b) ? bigint_cast<Result>(a) : bigint_cast<Result>(b);\n+        return static_cast<Result>(a) < static_cast<Result>(b) ? static_cast<Result>(a) : static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\ndiff --git a/src/Functions/minus.cpp b/src/Functions/minus.cpp\nindex edee792a55a9..0ce90f3544de 100644\n--- a/src/Functions/minus.cpp\n+++ b/src/Functions/minus.cpp\n@@ -19,7 +19,7 @@ struct MinusImpl\n             using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n             using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n \n-            return bigint_cast<Result>(bigint_cast<CastA>(a)) - bigint_cast<Result>(bigint_cast<CastB>(b));\n+            return static_cast<Result>(static_cast<CastA>(a)) - static_cast<Result>(static_cast<CastB>(b));\n         }\n         else\n             return static_cast<Result>(a) - b;\ndiff --git a/src/Functions/multiply.cpp b/src/Functions/multiply.cpp\nindex 54695a1087d7..52ab8decbf75 100644\n--- a/src/Functions/multiply.cpp\n+++ b/src/Functions/multiply.cpp\n@@ -20,7 +20,7 @@ struct MultiplyImpl\n             using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n             using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n \n-            return bigint_cast<Result>(bigint_cast<CastA>(a)) * bigint_cast<Result>(bigint_cast<CastB>(b));\n+            return static_cast<Result>(static_cast<CastA>(a)) * static_cast<Result>(static_cast<CastB>(b));\n         }\n         else\n             return static_cast<Result>(a) * b;\ndiff --git a/src/Functions/plus.cpp b/src/Functions/plus.cpp\nindex 68b364a7abea..0a63741ea3bf 100644\n--- a/src/Functions/plus.cpp\n+++ b/src/Functions/plus.cpp\n@@ -21,7 +21,7 @@ struct PlusImpl\n             using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n             using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n \n-            return bigint_cast<Result>(bigint_cast<CastA>(a)) + bigint_cast<Result>(bigint_cast<CastB>(b));\n+            return static_cast<Result>(static_cast<CastA>(a)) + static_cast<Result>(static_cast<CastB>(b));\n         }\n         else\n             return static_cast<Result>(a) + b;\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex de4e87440a22..4482667f4477 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -17,7 +17,6 @@\n #include <Core/Types.h>\n #include <Core/DecimalFunctions.h>\n #include <Core/UUID.h>\n-#include <Core/BigInt.h>\n \n #include <Common/Exception.h>\n #include <Common/StringUtils/StringUtils.h>\n@@ -121,17 +120,6 @@ inline void readFloatBinary(T & x, ReadBuffer & buf)\n     readPODBinary(x, buf);\n }\n \n-template <typename T>\n-void readBigIntBinary(T & x, ReadBuffer & buf)\n-{\n-    static const constexpr size_t bytesize = BigInt<T>::size;\n-    char bytes[bytesize];\n-\n-    buf.readStrict(bytes, bytesize);\n-\n-    x = BigInt<T>::deserialize(bytes);\n-}\n-\n inline void readStringBinary(std::string & s, ReadBuffer & buf, size_t MAX_STRING_SIZE = DEFAULT_MAX_STRING_SIZE)\n {\n     size_t size = 0;\n@@ -849,11 +837,11 @@ inline void readBinary(DummyUInt256 & x, ReadBuffer & buf) { readPODBinary(x, bu\n inline void readBinary(Decimal32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal64 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n-inline void readBinary(Decimal256 & x, ReadBuffer & buf) { readBigIntBinary(x.value, buf); }\n+inline void readBinary(Decimal256 & x, ReadBuffer & buf) { readPODBinary(x.value, buf); }\n inline void readBinary(LocalDate & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n \n-inline void readBinary(UInt256 & x, ReadBuffer & buf) { readBigIntBinary(x, buf); }\n-inline void readBinary(Int256 & x, ReadBuffer & buf) { readBigIntBinary(x, buf); }\n+inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n+inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n \n template <typename T>\n inline std::enable_if_t<is_arithmetic_v<T> && (sizeof(T) <= 8), void>\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex e6acd0b8880d..9072f306bd96 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -16,7 +16,6 @@\n #include <Core/DecimalFunctions.h>\n #include <Core/Types.h>\n #include <Core/UUID.h>\n-#include <Core/BigInt.h>\n \n #include <Common/Exception.h>\n #include <Common/StringUtils/StringUtils.h>\n@@ -121,17 +120,6 @@ inline void writeStringBinary(const std::string_view & s, WriteBuffer & buf)\n     writeStringBinary(StringRef{s}, buf);\n }\n \n-template <typename T>\n-void writeBigIntBinary(const T & x, WriteBuffer & buf)\n-{\n-    static const constexpr size_t bytesize = BigInt<T>::size;\n-    char bytes[bytesize];\n-\n-    BigInt<T>::serialize(x, bytes);\n-\n-    buf.write(bytes, bytesize);\n-}\n-\n template <typename T>\n void writeVectorBinary(const std::vector<T> & v, WriteBuffer & buf)\n {\n@@ -926,12 +914,12 @@ inline void writeBinary(const DummyUInt256 & x, WriteBuffer & buf) { writePODBin\n inline void writeBinary(const Decimal32 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal64 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-inline void writeBinary(const Decimal256 & x, WriteBuffer & buf) { writeBigIntBinary(x.value, buf); }\n+inline void writeBinary(const Decimal256 & x, WriteBuffer & buf) { writePODBinary(x.value, buf); }\n inline void writeBinary(const LocalDate & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const LocalDateTime & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n \n-inline void writeBinary(const UInt256 & x, WriteBuffer & buf) { writeBigIntBinary(x, buf); }\n-inline void writeBinary(const Int256 & x, WriteBuffer & buf) { writeBigIntBinary(x, buf); }\n+inline void writeBinary(const UInt256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n+inline void writeBinary(const Int256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n \n /// Methods for outputting the value in text form for a tab-separated format.\n template <typename T>\n",
  "test_patch": "diff --git a/src/Functions/greatest.cpp b/src/Functions/greatest.cpp\nindex 39021935111a..56b5630b6bc0 100644\n--- a/src/Functions/greatest.cpp\n+++ b/src/Functions/greatest.cpp\n@@ -16,8 +16,8 @@ struct GreatestBaseImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return bigint_cast<Result>(a) > bigint_cast<Result>(b) ?\n-               bigint_cast<Result>(a) : bigint_cast<Result>(b);\n+        return static_cast<Result>(a) > static_cast<Result>(b) ?\n+               static_cast<Result>(a) : static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\n",
  "problem_statement": "ColumnVector may segfault\nI leaved a comment at https://github.com/clickhouse/clickhouse/pull/13097:\r\nsrc/Columns/ColumnVector.h L115:\r\n```\r\n    using Container = std::conditional_t<is_POD,\r\n                                         PaddedPODArray<ValueType>,\r\n                                         std::vector<ValueType>>;\r\n```\r\nColumnArray::sizeAt(n) may pass -1. It's safe for PaddedPODArray since it always allocate some unused bytes at the begin and end of the array. However it's dangerous for std::vector.\n",
  "hints_text": "That's true, std::vector should not be used there.\nBig integers were rewritten to use the memory layout that corresponds to native integers\r\n(contiguous memory with exactly the corresponding number of bits, little endian, most significant sign bit...)\r\n\r\nThe special case in code becomes irrelevant and I will remove them.",
  "created_at": "2021-01-26T18:39:22Z",
  "modified_files": [
    "base/common/extended_types.h",
    "src/Columns/ColumnDecimal.cpp",
    "src/Columns/ColumnVector.cpp",
    "src/Columns/ColumnVector.h",
    "src/Common/FieldVisitors.h",
    "src/Common/HashTable/Hash.h",
    "src/Common/SipHash.h",
    "src/Compression/CompressionCodecT64.h",
    "src/Core/AccurateComparison.h",
    "src/Core/BigInt.h",
    "src/Core/DecimalComparison.h",
    "src/Core/Types.h",
    "src/DataTypes/NumberTraits.h",
    "src/Functions/DivisionUtils.h",
    "src/Functions/FunctionsComparison.h",
    "src/Functions/FunctionsHashing.h",
    "src/Functions/GatherUtils/Algorithms.h",
    "src/Functions/bitAnd.cpp",
    "src/Functions/bitOr.cpp",
    "src/Functions/bitShiftLeft.cpp",
    "src/Functions/bitShiftRight.cpp",
    "src/Functions/bitXor.cpp",
    "src/Functions/if.cpp",
    "src/Functions/least.cpp",
    "src/Functions/minus.cpp",
    "src/Functions/multiply.cpp",
    "src/Functions/plus.cpp",
    "src/IO/ReadHelpers.h",
    "src/IO/WriteHelpers.h"
  ],
  "modified_test_files": [
    "src/Functions/greatest.cpp"
  ]
}