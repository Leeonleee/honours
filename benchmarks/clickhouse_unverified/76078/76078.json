{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 76078,
  "instance_id": "ClickHouse__ClickHouse-76078",
  "issue_numbers": [
    "72459"
  ],
  "base_commit": "8e294b90c245dd115451154223950036b5d0e111",
  "patch": "diff --git a/src/Analyzer/HashUtils.h b/src/Analyzer/HashUtils.h\nindex 39ace3903415..f58ada303293 100644\n--- a/src/Analyzer/HashUtils.h\n+++ b/src/Analyzer/HashUtils.h\n@@ -54,6 +54,11 @@ using QueryTreeNodeConstRawPtrWithHashSet = std::unordered_set<QueryTreeNodeCons\n template <typename Value>\n using QueryTreeNodePtrWithHashMap = std::unordered_map<QueryTreeNodePtrWithHash, Value>;\n \n+class ColumnNode;\n+using ColumnNodePtr = std::shared_ptr<ColumnNode>;\n+using ColumnNodePtrWithHash = QueryTreeNodeWithHash<ColumnNodePtr>;\n+using ColumnNodePtrWithHashSet = std::unordered_set<ColumnNodePtrWithHash>;\n+\n }\n \n template <typename T, bool compare_aliases, bool compare_types>\ndiff --git a/src/Analyzer/IQueryTreeNode.h b/src/Analyzer/IQueryTreeNode.h\nindex 372c9eaec403..32af021b95f3 100644\n--- a/src/Analyzer/IQueryTreeNode.h\n+++ b/src/Analyzer/IQueryTreeNode.h\n@@ -47,7 +47,7 @@ enum class QueryTreeNodeType : uint8_t\n     ARRAY_JOIN,\n     CROSS_JOIN,\n     JOIN,\n-    UNION\n+    UNION,\n };\n \n /// Convert query tree node type to string\n@@ -91,12 +91,12 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n       */\n     virtual DataTypePtr getResultType() const\n     {\n-        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Method getResultType is not supported for {} query node\", getNodeTypeName());\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Method getResultType is not supported for {} query tree node\", getNodeTypeName());\n     }\n \n     virtual void convertToNullable()\n     {\n-        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Method convertToNullable is not supported for {} query node\", getNodeTypeName());\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Method convertToNullable is not supported for {} query tree node\", getNodeTypeName());\n     }\n \n     struct CompareOptions\ndiff --git a/src/Analyzer/Passes/RemoveUnusedProjectionColumnsPass.cpp b/src/Analyzer/Passes/RemoveUnusedProjectionColumnsPass.cpp\nindex 182ba1a0d2be..c9b60f0d4722 100644\n--- a/src/Analyzer/Passes/RemoveUnusedProjectionColumnsPass.cpp\n+++ b/src/Analyzer/Passes/RemoveUnusedProjectionColumnsPass.cpp\n@@ -2,12 +2,13 @@\n \n #include <Functions/FunctionFactory.h>\n \n-#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/AggregationUtils.h>\n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/QueryNode.h>\n-#include <Analyzer/ColumnNode.h>\n #include <Analyzer/SortNode.h>\n-#include <Analyzer/AggregationUtils.h>\n+#include <Analyzer/UnionNode.h>\n #include <Analyzer/Utils.h>\n \n namespace DB\n@@ -48,6 +49,29 @@ class CollectUsedColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Coll\n             return;\n         }\n \n+        if (node_type == QueryTreeNodeType::FUNCTION)\n+        {\n+            auto & function_node = node->as<FunctionNode &>();\n+\n+            if (function_node.getFunctionName() != \"exists\")\n+                return;\n+\n+            const auto & subquery_argument = function_node.getArguments().getNodes().front();\n+            auto * query_node = subquery_argument->as<QueryNode>();\n+            auto * union_node = subquery_argument->as<UnionNode>();\n+\n+            const auto & correlated_columns = query_node != nullptr ? query_node->getCorrelatedColumns() : union_node->getCorrelatedColumns();\n+            for (const auto & correlated_column : correlated_columns)\n+            {\n+                auto * column_node = correlated_column->as<ColumnNode>();\n+                auto column_source_node = column_node->getColumnSource();\n+                auto column_source_node_type = column_source_node->getNodeType();\n+                if (column_source_node_type == QueryTreeNodeType::QUERY || column_source_node_type == QueryTreeNodeType::UNION)\n+                    query_or_union_node_to_used_columns[column_source_node].insert(column_node->getColumnName());\n+            }\n+            return;\n+        }\n+\n         if (node_type != QueryTreeNodeType::COLUMN)\n             return;\n \n@@ -56,10 +80,15 @@ class CollectUsedColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Coll\n             return;\n \n         auto column_source_node = column_node.getColumnSource();\n-        auto column_source_node_type = column_source_node->getNodeType();\n \n-        if (column_source_node_type == QueryTreeNodeType::QUERY || column_source_node_type == QueryTreeNodeType::UNION)\n-            query_or_union_node_to_used_columns[column_source_node].insert(column_node.getColumnName());\n+        auto it = query_or_union_node_to_used_columns.find(column_source_node);\n+        /// If the source node is not found in the map then:\n+        /// 1. Tt's either not a Query or Union node.\n+        /// 2. It's a correlated column and it comes from the outer scope.\n+        if (it != query_or_union_node_to_used_columns.end())\n+        {\n+            it->second.insert(column_node.getColumnName());\n+        }\n     }\n \n     void reset()\ndiff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex 779a141281d7..8b1cdd2bfc07 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -22,6 +22,7 @@\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSetQuery.h>\n \n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/InterpolateNode.h>\n #include <Analyzer/UnionNode.h>\n #include <Analyzer/Utils.h>\n@@ -46,6 +47,7 @@ QueryNode::QueryNode(ContextMutablePtr context_, SettingsChanges settings_change\n     children[window_child_index] = std::make_shared<ListNode>();\n     children[order_by_child_index] = std::make_shared<ListNode>();\n     children[limit_by_child_index] = std::make_shared<ListNode>();\n+    children[correlated_columns_list_index] = std::make_shared<ListNode>();\n }\n \n QueryNode::QueryNode(ContextMutablePtr context_)\n@@ -108,6 +110,31 @@ void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<size_t> &\n     }\n }\n \n+ColumnNodePtrWithHashSet QueryNode::getCorrelatedColumnsSet() const\n+{\n+    ColumnNodePtrWithHashSet result;\n+\n+    const auto & correlated_columns = getCorrelatedColumns().getNodes();\n+    result.reserve(correlated_columns.size());\n+\n+    for (const auto & column : correlated_columns)\n+    {\n+        result.insert(std::static_pointer_cast<ColumnNode>(column));\n+    }\n+    return result;\n+}\n+\n+void QueryNode::addCorrelatedColumn(ColumnNodePtr correlated_column)\n+{\n+    auto & correlated_columns = getCorrelatedColumns().getNodes();\n+    for (const auto & column : correlated_columns)\n+    {\n+        if (column->isEqual(*correlated_column))\n+            return;\n+    }\n+    correlated_columns.push_back(correlated_column);\n+}\n+\n void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const\n {\n     buffer << std::string(indent, ' ') << \"QUERY id: \" << format_state.getNodeId(this);\n@@ -153,6 +180,12 @@ void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n     if (!cte_name.empty())\n         buffer << \", cte_name: \" << cte_name;\n \n+    if (isCorrelated())\n+    {\n+        buffer << \", is_correlated: 1\\n\" << std::string(indent + 2, ' ') << \"CORRELATED COLUMNS\\n\";\n+        getCorrelatedColumns().dumpTreeImpl(buffer, format_state, indent + 4);\n+    }\n+\n     if (hasWith())\n     {\n         buffer << '\\n' << std::string(indent + 2, ' ') << \"WITH\\n\";\ndiff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex 2ec1b96477c6..1bf10fe082e5 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -5,6 +5,7 @@\n #include <Core/NamesAndTypes.h>\n #include <Core/Field.h>\n \n+#include <Analyzer/HashUtils.h>\n #include <Analyzer/IQueryTreeNode.h>\n #include <Analyzer/ListNode.h>\n #include <Analyzer/TableExpressionModifiers.h>\n@@ -59,6 +60,9 @@ namespace DB\n class QueryNode;\n using QueryNodePtr = std::shared_ptr<QueryNode>;\n \n+class ColumnNode;\n+using ColumnNodePtr = std::shared_ptr<ColumnNode>;\n+\n class QueryNode final : public IQueryTreeNode\n {\n public:\n@@ -619,6 +623,30 @@ class QueryNode final : public IQueryTreeNode\n     /// Remove unused projection columns\n     void removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes);\n \n+    bool isCorrelated() const\n+    {\n+        return !children[correlated_columns_list_index]->as<ListNode>()->getNodes().empty();\n+    }\n+\n+    QueryTreeNodePtr & getCorrelatedColumnsNode()\n+    {\n+        return children[correlated_columns_list_index];\n+    }\n+\n+    ListNode & getCorrelatedColumns()\n+    {\n+        return children[correlated_columns_list_index]->as<ListNode &>();\n+    }\n+\n+    const ListNode & getCorrelatedColumns() const\n+    {\n+        return children[correlated_columns_list_index]->as<ListNode &>();\n+    }\n+\n+    ColumnNodePtrWithHashSet getCorrelatedColumnsSet() const;\n+\n+    void addCorrelatedColumn(ColumnNodePtr correlated_column);\n+\n     QueryTreeNodeType getNodeType() const override\n     {\n         return QueryTreeNodeType::QUERY;\n@@ -675,7 +703,8 @@ class QueryNode final : public IQueryTreeNode\n     static constexpr size_t limit_by_child_index = 13;\n     static constexpr size_t limit_child_index = 14;\n     static constexpr size_t offset_child_index = 15;\n-    static constexpr size_t children_size = offset_child_index + 1;\n+    static constexpr size_t correlated_columns_list_index = 16;\n+    static constexpr size_t children_size = correlated_columns_list_index + 1;\n };\n \n }\ndiff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp\nindex 0005aa6c8bc3..2f24c6c2f60c 100644\n--- a/src/Analyzer/QueryTreePassManager.cpp\n+++ b/src/Analyzer/QueryTreePassManager.cpp\n@@ -107,6 +107,9 @@ class ValidationChecker : public InDepthQueryTreeVisitor<ValidationChecker>\n         if (isNameOfInFunction(function->getFunctionName()))\n             return;\n \n+        if (function->getFunctionName() == \"exists\")\n+            return;\n+\n         const auto & expected_argument_types = function->getArgumentTypes();\n         size_t expected_argument_types_size = expected_argument_types.size();\n         auto actual_argument_columns = function->getArgumentColumns();\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 2712129b1c92..f601cd494046 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -18,6 +18,7 @@\n #include <Functions/IFunctionAdaptors.h>\n #include <Functions/UserDefined/UserDefinedExecutableFunctionFactory.h>\n #include <Functions/UserDefined/UserDefinedSQLFunctionFactory.h>\n+#include <Functions/exists.h>\n #include <Functions/grouping.h>\n \n #include <TableFunctions/TableFunctionFactory.h>\n@@ -113,6 +114,7 @@ namespace Setting\n     extern const SettingsBool allow_suspicious_types_in_order_by;\n     extern const SettingsBool allow_not_comparable_types_in_order_by;\n     extern const SettingsBool use_concurrency_control;\n+    extern const SettingsBool allow_experimental_correlated_subqueries;\n     extern const SettingsString implicit_table_at_top_level;\n }\n \n@@ -1377,12 +1379,14 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const\n     {\n         auto current = nodes_to_process.back();\n         nodes_to_process.pop_back();\n-        if (auto * current_column = current->as<ColumnNode>())\n+        if (ColumnNodePtr current_column = std::dynamic_pointer_cast<ColumnNode>(current))\n         {\n-            if (isDependentColumn(&scope, current_column->getColumnSource()))\n+            auto is_correlated_column = checkCorrelatedColumn(&scope, current_column);\n+            if (is_correlated_column && !scope.context->getSettingsRef()[Setting::allow_experimental_correlated_subqueries])\n             {\n                 throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                    \"Resolved identifier '{}' in parent scope to expression '{}' with correlated column '{}'. In scope {}\",\n+                    \"Resolved identifier '{}' in parent scope to expression '{}' with correlated column '{}'\"\n+                    \" (Enable 'allow_experimental_correlated_subqueries' setting to allow correlated subqueries execution). In scope {}\",\n                     identifier_lookup.identifier.getFullName(),\n                     resolved_identifier->formatASTForErrorMessage(),\n                     current_column->getColumnName(),\n@@ -2845,27 +2849,6 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n         }\n     }\n \n-    if (is_special_function_exists)\n-    {\n-        checkFunctionNodeHasEmptyNullsAction(*function_node_ptr);\n-        /// Rewrite EXISTS (subquery) into 1 IN (SELECT 1 FROM (subquery) LIMIT 1).\n-        auto & exists_subquery_argument = function_node_ptr->getArguments().getNodes().at(0);\n-\n-        auto constant_data_type = std::make_shared<DataTypeUInt64>();\n-\n-        auto in_subquery = std::make_shared<QueryNode>(Context::createCopy(scope.context));\n-        in_subquery->setIsSubquery(true);\n-        in_subquery->getProjection().getNodes().push_back(std::make_shared<ConstantNode>(1UL, constant_data_type));\n-        in_subquery->getJoinTree() = exists_subquery_argument;\n-        in_subquery->getLimit() = std::make_shared<ConstantNode>(1UL, constant_data_type);\n-\n-        function_node_ptr = std::make_shared<FunctionNode>(\"in\");\n-        function_node_ptr->getArguments().getNodes() = {std::make_shared<ConstantNode>(1UL, constant_data_type), in_subquery};\n-        node = function_node_ptr;\n-        function_name = \"in\";\n-        is_special_function_in = true;\n-    }\n-\n     if (is_special_function_if && !function_node_ptr->getArguments().getNodes().empty())\n     {\n         checkFunctionNodeHasEmptyNullsAction(*function_node_ptr);\n@@ -2922,12 +2905,61 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n     }\n \n     /// Resolve function arguments\n-    bool allow_table_expressions = is_special_function_in;\n+    bool allow_table_expressions = is_special_function_in || is_special_function_exists;\n     auto arguments_projection_names = resolveExpressionNodeList(function_node_ptr->getArgumentsNode(),\n         scope,\n         true /*allow_lambda_expression*/,\n         allow_table_expressions /*allow_table_expression*/);\n \n+    if (is_special_function_exists)\n+    {\n+        checkFunctionNodeHasEmptyNullsAction(*function_node_ptr);\n+        /// Rewrite EXISTS (subquery) into 1 IN (SELECT 1 FROM (subquery) LIMIT 1).\n+        auto & exists_subquery_argument = function_node_ptr->getArguments().getNodes().at(0);\n+        bool correlated_exists_subquery = exists_subquery_argument->getNodeType() == QueryTreeNodeType::QUERY\n+            ? exists_subquery_argument->as<QueryNode>()->isCorrelated()\n+            : exists_subquery_argument->as<UnionNode>()->isCorrelated();\n+        if (!correlated_exists_subquery)\n+        {\n+            auto constant_data_type = std::make_shared<DataTypeUInt64>();\n+\n+            auto in_subquery = std::make_shared<QueryNode>(Context::createCopy(scope.context));\n+            in_subquery->setIsSubquery(true);\n+            in_subquery->getProjection().getNodes().push_back(std::make_shared<ConstantNode>(1UL, constant_data_type));\n+            in_subquery->getJoinTree() = exists_subquery_argument;\n+            in_subquery->getLimit() = std::make_shared<ConstantNode>(1UL, constant_data_type);\n+\n+            function_node_ptr = std::make_shared<FunctionNode>(\"in\");\n+            function_node_ptr->getArguments().getNodes() = {\n+                std::make_shared<ConstantNode>(1UL, constant_data_type),\n+                std::move(in_subquery)\n+            };\n+\n+            /// Resolve modified arguments\n+            arguments_projection_names = resolveExpressionNodeList(function_node_ptr->getArgumentsNode(),\n+                scope,\n+                true /*allow_lambda_expression*/,\n+                true /*allow_table_expression*/);\n+\n+            node = function_node_ptr;\n+            function_name = \"in\";\n+            is_special_function_in = true;\n+        }\n+        else\n+        {\n+            /// Subquery is correlated and EXISTS can not be replaced by IN function.\n+            /// EXISTS function will be replated by JOIN during query planning.\n+            auto function_exists = std::make_shared<FunctionExists>();\n+            function_node_ptr->resolveAsFunction(\n+                std::make_shared<FunctionToFunctionBaseAdaptor>(\n+                    function_exists, DataTypes{}, function_exists->getReturnTypeImpl({})\n+                )\n+            );\n+\n+            return { calculateFunctionProjectionName(node, parameters_projection_names, arguments_projection_names) };\n+        }\n+    }\n+\n     /// Mask arguments if needed\n     if (!scope.context->getSettingsRef()[Setting::format_display_secrets_in_show_and_select])\n     {\n@@ -2978,6 +3010,10 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function '{}' expects 2 arguments\", function_name);\n \n         auto & in_second_argument = function_in_arguments_nodes[1];\n+        if (isCorrelatedQueryOrUnionNode(function_in_arguments_nodes[0]) || isCorrelatedQueryOrUnionNode(function_in_arguments_nodes[1]))\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                \"Correlated subqueries are not supported as IN function arguments yet, but found in expression: {}\",\n+                node->formatASTForErrorMessage());\n         auto * table_node = in_second_argument->as<TableNode>();\n         auto * table_function_node = in_second_argument->as<TableFunctionNode>();\n \n@@ -5140,6 +5176,16 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS\n     resolveQueryJoinTreeNode(join_node_typed.getRightTableExpression(), scope, expressions_visitor);\n     validateJoinTableExpressionWithoutAlias(join_node, join_node_typed.getRightTableExpression(), scope);\n \n+    if (isCorrelatedQueryOrUnionNode(join_node_typed.getLeftTableExpression()))\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+            \"Correlated subqueries are not supported in JOINs yet, but found in expression: {}\",\n+            join_node_typed.getLeftTableExpression()->formatASTForErrorMessage());\n+\n+    if (isCorrelatedQueryOrUnionNode(join_node_typed.getRightTableExpression()))\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+            \"Correlated subqueries are not supported in JOINs yet, but found in expression: {}\",\n+            join_node_typed.getRightTableExpression()->formatASTForErrorMessage());\n+\n     if (!join_node_typed.getLeftTableExpression()->hasAlias() && !join_node_typed.getRightTableExpression()->hasAlias())\n         checkDuplicateTableNamesOrAliasForPasteJoin(join_node_typed, scope);\n \ndiff --git a/src/Analyzer/TableNode.cpp b/src/Analyzer/TableNode.cpp\nindex bc8f57ef8e93..7b4a96ff0cbe 100644\n--- a/src/Analyzer/TableNode.cpp\n+++ b/src/Analyzer/TableNode.cpp\n@@ -85,7 +85,10 @@ void TableNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n     }\n     else\n     {\n-        auto full_name = storage_id.getFullNameNotQuoted();\n+        // In case of cross-replication we don't know what database is used for the table.\n+        // `storage_id.hasDatabase()` can return false only on the initiator node.\n+        // Each shard will use the default database (in the case of cross-replication shards may have different defaults).\n+        auto full_name = storage_id.hasDatabase() ? storage_id.getFullNameNotQuoted() : storage_id.getTableName();\n         state.update(full_name.size());\n         state.update(full_name);\n     }\ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex 1d29aed0a610..af9febed0fb2 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -25,6 +25,7 @@\n \n #include <Interpreters/Context.h>\n \n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/QueryNode.h>\n #include <Analyzer/Utils.h>\n \n@@ -49,6 +50,7 @@ UnionNode::UnionNode(ContextMutablePtr context_, SelectUnionMode union_mode_)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"UNION mode {} must be normalized\", toString(union_mode));\n \n     children[queries_child_index] = std::make_shared<ListNode>();\n+    children[correlated_columns_list_index] = std::make_shared<ListNode>();\n }\n \n bool UnionNode::isResolved() const\n@@ -130,6 +132,17 @@ void UnionNode::removeUnusedProjectionColumns(const std::unordered_set<size_t> &\n     }\n }\n \n+void UnionNode::addCorrelatedColumn(ColumnNodePtr correlated_column)\n+{\n+    auto & correlated_columns = getCorrelatedColumns().getNodes();\n+    for (const auto & column : correlated_columns)\n+    {\n+        if (column->isEqual(*correlated_column))\n+            return;\n+    }\n+    correlated_columns.push_back(correlated_column);\n+}\n+\n void UnionNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const\n {\n     buffer << std::string(indent, ' ') << \"UNION id: \" << format_state.getNodeId(this);\n@@ -154,6 +167,12 @@ void UnionNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n \n     buffer << \", union_mode: \" << toString(union_mode);\n \n+    if (isCorrelated())\n+    {\n+        buffer << \", is_correlated: 1\\n\" << std::string(indent + 2, ' ') << \"CORRELATED COLUMNS\\n\";\n+        getCorrelatedColumns().dumpTreeImpl(buffer, format_state, indent + 4);\n+    }\n+\n     buffer << '\\n' << std::string(indent + 2, ' ') << \"QUERIES\\n\";\n     getQueriesNode()->dumpTreeImpl(buffer, format_state, indent + 4);\n }\ndiff --git a/src/Analyzer/UnionNode.h b/src/Analyzer/UnionNode.h\nindex 09018156e2d1..657103663ffc 100644\n--- a/src/Analyzer/UnionNode.h\n+++ b/src/Analyzer/UnionNode.h\n@@ -35,6 +35,9 @@ namespace DB\n class UnionNode;\n using UnionNodePtr = std::shared_ptr<UnionNode>;\n \n+class ColumnNode;\n+using ColumnNodePtr = std::shared_ptr<ColumnNode>;\n+\n class UnionNode final : public IQueryTreeNode\n {\n public:\n@@ -170,6 +173,28 @@ class UnionNode final : public IQueryTreeNode\n     /// Remove unused projection columns\n     void removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes);\n \n+    bool isCorrelated() const\n+    {\n+        return !children[correlated_columns_list_index]->as<ListNode>()->getNodes().empty();\n+    }\n+\n+    QueryTreeNodePtr & getCorrelatedColumnsNode()\n+    {\n+        return children[correlated_columns_list_index];\n+    }\n+\n+    ListNode & getCorrelatedColumns()\n+    {\n+        return children[correlated_columns_list_index]->as<ListNode &>();\n+    }\n+\n+    const ListNode & getCorrelatedColumns() const\n+    {\n+        return children[correlated_columns_list_index]->as<ListNode &>();\n+    }\n+\n+    void addCorrelatedColumn(ColumnNodePtr correlated_column);\n+\n     QueryTreeNodeType getNodeType() const override\n     {\n         return QueryTreeNodeType::UNION;\n@@ -196,7 +221,8 @@ class UnionNode final : public IQueryTreeNode\n     SelectUnionMode union_mode;\n \n     static constexpr size_t queries_child_index = 0;\n-    static constexpr size_t children_size = queries_child_index + 1;\n+    static constexpr size_t correlated_columns_list_index = 1;\n+    static constexpr size_t children_size = correlated_columns_list_index + 1;\n };\n \n }\ndiff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex 22bde64e2747..fc1ab8d7a5a8 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -46,6 +46,7 @@\n #include <Analyzer/TableFunctionNode.h>\n #include <Analyzer/TableNode.h>\n #include <Analyzer/UnionNode.h>\n+\n #include <Analyzer/Resolve/IdentifierResolveScope.h>\n \n #include <ranges>\n@@ -241,8 +242,21 @@ bool isQueryOrUnionNode(const QueryTreeNodePtr & node)\n     return isQueryOrUnionNode(node.get());\n }\n \n-bool isDependentColumn(IdentifierResolveScope * scope_to_check, const QueryTreeNodePtr & column_source)\n+bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node)\n {\n+    auto * query_node = node->as<QueryNode>();\n+    auto * union_node = node->as<UnionNode>();\n+\n+    return (query_node != nullptr && query_node->isCorrelated()) || (union_node != nullptr && union_node->isCorrelated());\n+}\n+\n+bool checkCorrelatedColumn(\n+    IdentifierResolveScope * scope_to_check,\n+    const ColumnNodePtr & column\n+)\n+{\n+    auto column_source = column->getColumnSource();\n+\n     /// The case of lambda argument. Example:\n     /// arrayMap(X -> X + Y, [0])\n     ///\n@@ -251,15 +265,27 @@ bool isDependentColumn(IdentifierResolveScope * scope_to_check, const QueryTreeN\n     if (column_source->getNodeType() == QueryTreeNodeType::LAMBDA)\n         return false;\n \n+    bool is_correlated = false;\n+\n     while (scope_to_check != nullptr)\n     {\n         if (scope_to_check->registered_table_expression_nodes.contains(column_source))\n-            return false;\n+            break;\n+\n         if (isQueryOrUnionNode(scope_to_check->scope_node))\n-            return true;\n+        {\n+            is_correlated = true;\n+            if (auto * query_node = scope_to_check->scope_node->as<QueryNode>())\n+                query_node->addCorrelatedColumn(column);\n+            else if (auto * union_node = scope_to_check->scope_node->as<UnionNode>())\n+                union_node->addCorrelatedColumn(column);\n+        }\n         scope_to_check = scope_to_check->parent_scope;\n     }\n-    return true;\n+    if (!scope_to_check)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot find the original scope of the column\");\n+\n+    return is_correlated;\n }\n \n DataTypePtr getExpressionNodeResultTypeOrNull(const QueryTreeNodePtr & query_tree_node)\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex e1e6da1d36f7..4b07a21483c0 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -15,6 +15,9 @@ namespace DB\n {\n \n class FunctionNode;\n+class ColumnNode;\n+using ColumnNodePtr = std::shared_ptr<ColumnNode>;\n+\n struct IdentifierResolveScope;\n \n struct NameAndTypePair;\n@@ -59,10 +62,18 @@ bool isQueryOrUnionNode(const IQueryTreeNode * node);\n /// Returns true, if node has type QUERY or UNION\n bool isQueryOrUnionNode(const QueryTreeNodePtr & node);\n \n-/* Returns true, if column source is not registered in scopes that appear\n+/// Returns true, if node has type QUERY or UNION and uses any columns from outer scope\n+bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node);\n+\n+/* Checks, if column source is not registered in scopes that appear\n  * before nearest query scope.\n+ * If column appears to be correlated in the scope than it be registered\n+ * in corresponding QueryNode or UnionNode.\n  */\n-bool isDependentColumn(IdentifierResolveScope * scope_to_check, const QueryTreeNodePtr & column_source);\n+bool checkCorrelatedColumn(\n+    IdentifierResolveScope * scope_to_check,\n+    const ColumnNodePtr & column\n+);\n \n DataTypePtr getExpressionNodeResultTypeOrNull(const QueryTreeNodePtr & query_tree_node);\n \ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex c84812dadeb1..e816216c3663 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5066,6 +5066,10 @@ Connect timeout in seconds. Now supported only for MySQL\n     DECLARE(UInt64, external_storage_rw_timeout_sec, DBMS_DEFAULT_RECEIVE_TIMEOUT_SEC, R\"(\n Read/write timeout in seconds. Now supported only for MySQL\n )\", 0)  \\\n+    \\\n+    DECLARE(Bool, allow_experimental_correlated_subqueries, false, R\"(\n+Allow to execute correlated subqueries.\n+)\", EXPERIMENTAL) \\\n     \\\n     DECLARE(SetOperationMode, union_default_mode, SetOperationMode::Unspecified, R\"(\n Sets a mode for combining `SELECT` query results. The setting is only used when shared with [UNION](../../sql-reference/statements/select/union.md) without explicitly specifying the `UNION ALL` or `UNION DISTINCT`.\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex f851a553299f..ec223cea5006 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -80,6 +80,7 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n             {\"query_plan_convert_join_to_in\", false, false, \"New setting\"},\n             {\"enable_hdfs_pread\", true, true, \"New setting.\"},\n             {\"low_priority_query_wait_time_ms\", 1000, 1000, \"New setting.\"},\n+            {\"allow_experimental_correlated_subqueries\", false, false, \"Added new setting to allow correlated subqueries execution.\"},\n             {\"serialize_query_plan\", false, false, \"NewSetting\"},\n             {\"allow_experimental_shared_set_join\", 0, 1, \"A setting for ClickHouse Cloud to enable SharedSet and SharedJoin\"},\n             {\"allow_special_bool_values_inside_variant\", true, false, \"Don't allow special bool values during Variant type parsing\"},\ndiff --git a/src/Databases/enableAllExperimentalSettings.cpp b/src/Databases/enableAllExperimentalSettings.cpp\nindex c6883a83c097..b95fc3cf52ae 100644\n--- a/src/Databases/enableAllExperimentalSettings.cpp\n+++ b/src/Databases/enableAllExperimentalSettings.cpp\n@@ -30,6 +30,7 @@ void enableAllExperimentalSettings(ContextMutablePtr context)\n     context->setSetting(\"allow_experimental_map_type\", 1);\n     context->setSetting(\"allow_experimental_bigint_types\", 1);\n     context->setSetting(\"allow_experimental_bfloat16_type\", 1);\n+    context->setSetting(\"allow_experimental_correlated_subqueries\", 1);\n     context->setSetting(\"allow_deprecated_error_prone_window_functions\", 1);\n \n     context->setSetting(\"allow_suspicious_low_cardinality_types\", 1);\ndiff --git a/src/Functions/exists.h b/src/Functions/exists.h\nnew file mode 100644\nindex 000000000000..4c6ba43f3e81\n--- /dev/null\n+++ b/src/Functions/exists.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+\n+#include <Common/Exception.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/IFunction.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+\n+extern const int LOGICAL_ERROR;\n+\n+}\n+\n+/// This is a helper function for EXISTS expression.\n+/// It's not supposed to be ever executed, because it's argument is a subquery\n+/// and the whole EXISTS expression is either rewritten to '1 IN (SELECT 1 FROM <subquery>)'\n+/// if subquery is not correlated or it's replaced with JOINs during decorrelation.\n+class FunctionExists : public IFunction\n+{\n+public:\n+    String getName() const override { return \"exists\"; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & /*arguments*/, const DataTypePtr & /*result_type*/, size_t  /*input_rows_count*/) const override\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Function 'exists' is not supposed to be executed\");\n+    }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override\n+    {\n+        return false;\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override\n+    {\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        return 1;\n+    }\n+};\n+\n+}\ndiff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 6b3b3efaeed5..d5b63a9bb0e0 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -455,6 +455,17 @@ const ActionsDAG::Node & ActionsDAG::addFunctionImpl(\n     return addNode(std::move(node));\n }\n \n+const ActionsDAG::Node & ActionsDAG::addPlaceholder(std::string name, DataTypePtr type)\n+{\n+    Node node;\n+    node.type = ActionType::PLACEHOLDER;\n+    node.result_type = std::move(type);\n+    node.result_name = std::move(name);\n+    node.column = node.result_type->createColumn();\n+\n+    return addNode(std::move(node));\n+}\n+\n const ActionsDAG::Node & ActionsDAG::findInOutputs(const std::string & name) const\n {\n     if (const auto * node = tryFindInOutputs(name))\n@@ -853,6 +864,11 @@ static ColumnWithTypeAndName executeActionForPartialResult(const ActionsDAG::Nod\n         {\n             break;\n         }\n+\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Trying to execute PLACEHOLDER action\");\n+        }\n     }\n \n     return res_column;\n@@ -961,6 +977,16 @@ ColumnsWithTypeAndName ActionsDAG::evaluatePartialResult(\n \n                     stack.pop();\n \n+                    if (node->type == ActionsDAG::ActionType::PLACEHOLDER)\n+                    {\n+                        /// Maybe move to executeActionForPartialResult\n+                        node_to_column[node] = ColumnWithTypeAndName(\n+                            node->column->cloneResized(input_rows_count),\n+                            node->result_type,\n+                            node->result_name);\n+                        continue;\n+                    }\n+\n                     ColumnsWithTypeAndName arguments(node->children.size());\n                     bool has_all_arguments = true;\n                     for (size_t i = 0; i < arguments.size(); ++i)\n@@ -1436,6 +1462,10 @@ std::string ActionsDAG::dumpDAG() const\n             case ActionsDAG::ActionType::INPUT:\n                 out << \"INPUT \";\n                 break;\n+\n+            case ActionsDAG::ActionType::PLACEHOLDER:\n+                out << \"PLACEHOLDER \";\n+                break;\n         }\n \n         out << \"(\";\n@@ -1468,7 +1498,16 @@ std::string ActionsDAG::dumpDAG() const\n     return out.str();\n }\n \n-bool ActionsDAG::hasArrayJoin() const\n+bool ActionsDAG::hasCorrelatedColumns() const noexcept\n+{\n+    for (const auto & node : nodes)\n+        if (node.type == ActionType::PLACEHOLDER)\n+            return true;\n+\n+    return false;\n+}\n+\n+bool ActionsDAG::hasArrayJoin() const noexcept\n {\n     for (const auto & node : nodes)\n         if (node.type == ActionType::ARRAY_JOIN)\n@@ -1486,7 +1525,7 @@ bool ActionsDAG::hasStatefulFunctions() const\n     return false;\n }\n \n-bool ActionsDAG::trivial() const\n+bool ActionsDAG::trivial() const noexcept\n {\n     for (const auto & node : nodes)\n         if (node.type == ActionType::FUNCTION || node.type == ActionType::ARRAY_JOIN)\n@@ -1511,6 +1550,19 @@ bool ActionsDAG::hasNonDeterministic() const\n     return false;\n }\n \n+void ActionsDAG::decorrelate() noexcept\n+{\n+    for (auto & node : nodes)\n+    {\n+        if (node.type == ActionType::PLACEHOLDER)\n+        {\n+            node.type = ActionType::INPUT;\n+            node.column = nullptr;\n+            inputs.emplace_back(&node);\n+        }\n+    }\n+}\n+\n void ActionsDAG::addMaterializingOutputActions(bool materialize_sparse)\n {\n     for (auto & output_node : outputs)\n@@ -3125,6 +3177,12 @@ std::optional<ActionsDAG> ActionsDAG::buildFilterActionsDAG(\n                     all_const);\n                 break;\n             }\n+            case ActionsDAG::ActionType::PLACEHOLDER:\n+            {\n+                /// TODO: check if it's correct\n+                result_node = &result_dag.addPlaceholder(node->result_name, node->result_type);\n+                break;\n+            }\n         }\n \n         node_to_result_node.emplace(node, result_node);\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex b86d632ef9c5..b561bbf46ebe 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -63,6 +63,8 @@ class ActionsDAG\n         /// Function arrayJoin. Specially separated because it changes the number of rows.\n         ARRAY_JOIN,\n         FUNCTION,\n+        /// Placeholder node for correlated column\n+        PLACEHOLDER,\n     };\n \n     struct Node;\n@@ -154,6 +156,7 @@ class ActionsDAG\n         NodeRawConstPtrs children,\n         std::string result_name);\n     const Node & addCast(const Node & node_to_cast, const DataTypePtr & cast_type, std::string result_name);\n+    const Node & addPlaceholder(std::string name, DataTypePtr type);\n \n     /// Find first column by name in output nodes. This search is linear.\n     const Node & findInOutputs(const std::string & name) const;\n@@ -256,9 +259,10 @@ class ActionsDAG\n         const std::unordered_map<const Node *, const Node *> & new_inputs,\n         const NodeRawConstPtrs & required_outputs);\n \n-    bool hasArrayJoin() const;\n+    bool hasCorrelatedColumns() const noexcept;\n+    bool hasArrayJoin() const noexcept;\n     bool hasStatefulFunctions() const;\n-    bool trivial() const; /// If actions has no functions or array join.\n+    bool trivial() const noexcept; /// If actions has no functions or array join.\n     void assertDeterministic() const; /// Throw if not isDeterministic.\n     bool hasNonDeterministic() const;\n \n@@ -286,6 +290,9 @@ class ActionsDAG\n         size_t input_rows_count,\n         bool throw_on_error);\n \n+    /// Replace all PLACEHOLDER nodes with INPUT nodes\n+    void decorrelate() noexcept;\n+\n     /// For apply materialize() function for every output.\n     /// Also add aliases so the result names remain unchanged.\n     void addMaterializingOutputActions(bool materialize_sparse);\ndiff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex cec9749d244d..905c0694c392 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -514,6 +514,11 @@ std::string ExpressionActions::Action::toString() const\n         case ActionsDAG::ActionType::INPUT:\n             out << \"INPUT \" << arguments.front();\n             break;\n+\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+            out << \"PLACEHOLDER \" << node->result_name;\n+            break;\n+\n     }\n \n     out << \" -> \" << node->result_name\n@@ -731,6 +736,11 @@ static void executeAction(const ExpressionActions::Action & action, ExecutionCon\n \n             break;\n         }\n+\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Trying to execute PLACEHOLDER action\");\n+        }\n     }\n }\n \ndiff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex 5e56a4be2727..792f7f29038f 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -120,7 +120,13 @@ std::optional<EvaluateConstantExpressionResult> evaluateConstantExpressionImpl(c\n         collectSourceColumns(expression, planner_context, false /*keep_alias_columns*/);\n         collectSets(expression, *planner_context);\n \n-        auto actions = buildActionsDAGFromExpressionNode(expression, {}, planner_context);\n+        ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+        auto [actions, correlated_subtrees] = buildActionsDAGFromExpressionNode(\n+            expression,\n+            /*input_columns=*/{},\n+            planner_context,\n+            empty_correlated_columns_set);\n+        correlated_subtrees.assertEmpty(\"in constant expression without query context\");\n \n         if (actions.getOutputs().size() != 1)\n         {\ndiff --git a/src/Planner/CollectTableExpressionData.cpp b/src/Planner/CollectTableExpressionData.cpp\nindex e0150ed5ee86..72cf8f6f8332 100644\n--- a/src/Planner/CollectTableExpressionData.cpp\n+++ b/src/Planner/CollectTableExpressionData.cpp\n@@ -2,16 +2,19 @@\n \n #include <Storages/IStorage.h>\n \n-#include <Analyzer/Utils.h>\n-#include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ColumnNode.h>\n+#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/ListNode.h>\n #include <Analyzer/QueryNode.h>\n-#include <Analyzer/TableNode.h>\n #include <Analyzer/TableFunctionNode.h>\n-#include <Analyzer/ListNode.h>\n-#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/TableNode.h>\n+#include <Analyzer/UnionNode.h>\n+#include <Analyzer/Utils.h>\n \n #include <Planner/PlannerActionsVisitor.h>\n+#include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n \n \n namespace DB\n@@ -44,6 +47,19 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co\n             return;\n         }\n \n+        if (isExistsFunction(node))\n+        {\n+            auto * function_node = node->as<FunctionNode>();\n+            const auto & subquery_argument = function_node->getArguments().getNodes().front();\n+            auto * query_node = subquery_argument->as<QueryNode>();\n+            auto * union_node = subquery_argument->as<UnionNode>();\n+            chassert(query_node != nullptr || union_node != nullptr);\n+\n+            auto & correlated_columns = query_node ? query_node->getCorrelatedColumnsNode() : union_node->getCorrelatedColumnsNode();\n+            visit(correlated_columns);\n+            return;\n+        }\n+\n         auto * column_node = node->as<ColumnNode>();\n         if (!column_node)\n             return;\n@@ -103,11 +119,15 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co\n                 auto column_identifier = planner_context->getGlobalPlannerContext()->createColumnIdentifier(node);\n \n                 ActionsDAG alias_column_actions_dag;\n-                PlannerActionsVisitor actions_visitor(planner_context, false);\n-                auto outputs = actions_visitor.visit(alias_column_actions_dag, column_node->getExpression());\n+                ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+                PlannerActionsVisitor actions_visitor(planner_context, empty_correlated_columns_set, false);\n+                auto [outputs, correlated_subtrees] = actions_visitor.visit(alias_column_actions_dag, column_node->getExpression());\n                 if (outputs.size() != 1)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR,\n                         \"Expected single output in actions dag for alias column {}. Actual {}\", column_node->dumpTree(), outputs.size());\n+                if (correlated_subtrees.notEmpty())\n+                    throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                        \"Correlated subquery in alias column expression {}. Actual {}\", column_node->dumpTree(), outputs.size());\n \n                 auto & alias_node = outputs[0];\n                 const auto & column_name = column_node->getColumnName();\n@@ -180,6 +200,11 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co\n         return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == \"indexHint\";\n     }\n \n+    static bool isExistsFunction(const QueryTreeNodePtr & node)\n+    {\n+        return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == \"exists\";\n+    }\n+\n     static bool isColumnSourceMergeTree(const ColumnNode & node)\n     {\n         const auto * source_table = node.getColumnSource()->as<TableNode>();\n@@ -381,13 +406,18 @@ void collectTableExpressionData(QueryTreeNodePtr & query_node, PlannerContextPtr\n         ActionsDAG prewhere_actions_dag;\n \n         QueryTreeNodePtr query_tree_node = query_node_typed.getPrewhere();\n+        auto correlated_columns_set = query_node_typed.getCorrelatedColumnsSet();\n \n-        PlannerActionsVisitor visitor(planner_context, false /*use_column_identifier_as_action_node_name*/);\n-        auto expression_nodes = visitor.visit(prewhere_actions_dag, query_tree_node);\n+        PlannerActionsVisitor visitor(planner_context, /*correlated_columns_set_=*/correlated_columns_set, false /*use_column_identifier_as_action_node_name*/);\n+        auto [expression_nodes, correlated_subtrees] = visitor.visit(prewhere_actions_dag, query_tree_node);\n         if (expression_nodes.size() != 1)\n             throw Exception(ErrorCodes::ILLEGAL_PREWHERE,\n                 \"Invalid PREWHERE. Expected single boolean expression. In query {}\",\n                 query_node->formatASTForErrorMessage());\n+        if (correlated_subtrees.notEmpty())\n+            throw Exception(ErrorCodes::ILLEGAL_PREWHERE,\n+                \"Correlated subqueries are not allowed in PREWHERE expression. In query {}\",\n+                query_node->formatASTForErrorMessage());\n \n         prewhere_actions_dag.getOutputs().push_back(expression_nodes.back());\n \ndiff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp\nindex 298f14220af6..3354eb53e337 100644\n--- a/src/Planner/Planner.cpp\n+++ b/src/Planner/Planner.cpp\n@@ -69,20 +69,22 @@\n #include <Analyzer/AggregationUtils.h>\n #include <Analyzer/WindowFunctionsUtils.h>\n \n+#include <Planner/CollectColumnIdentifiers.h>\n+#include <Planner/CollectSets.h>\n+#include <Planner/CollectTableExpressionData.h>\n #include <Planner/findQueryForParallelReplicas.h>\n-#include <Planner/Utils.h>\n-#include <Planner/PlannerContext.h>\n #include <Planner/PlannerActionsVisitor.h>\n-#include <Planner/PlannerJoins.h>\n #include <Planner/PlannerAggregation.h>\n-#include <Planner/PlannerSorting.h>\n-#include <Planner/PlannerWindowFunctions.h>\n-#include <Planner/CollectSets.h>\n-#include <Planner/CollectTableExpressionData.h>\n-#include <Planner/PlannerJoinTree.h>\n+#include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n #include <Planner/PlannerExpressionAnalysis.h>\n-#include <Planner/CollectColumnIdentifiers.h>\n+#include <Planner/PlannerJoins.h>\n+#include <Planner/PlannerJoinTree.h>\n #include <Planner/PlannerQueryProcessingInfo.h>\n+#include <Planner/PlannerSorting.h>\n+#include <Planner/PlannerWindowFunctions.h>\n+#include <Planner/Utils.h>\n+\n \n namespace ProfileEvents\n {\n@@ -398,11 +400,19 @@ void addExpressionStep(QueryPlan & query_plan,\n     query_plan.addStep(std::move(expression_step));\n }\n \n-void addFilterStep(QueryPlan & query_plan,\n+void addFilterStep(\n+    const PlannerContextPtr & planner_context,\n+    QueryPlan & query_plan,\n     FilterAnalysisResult & filter_analysis_result,\n+    const SelectQueryOptions & select_query_options,\n     const std::string & step_description,\n     UsefulSets & useful_sets)\n {\n+    for (const auto & correlated_subquery : filter_analysis_result.correlated_subtrees.subqueries)\n+    {\n+        buildQueryPlanForCorrelatedSubquery(planner_context, query_plan, correlated_subquery, select_query_options);\n+    }\n+\n     auto actions = std::move(filter_analysis_result.filter_actions->dag);\n     if (filter_analysis_result.filter_actions->project_input)\n         actions.appendInputsForUnusedColumns(query_plan.getCurrentHeader());\n@@ -798,14 +808,17 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n             {\n                 auto & interpolate_node_typed = interpolate_node->as<InterpolateNode &>();\n \n-                PlannerActionsVisitor planner_actions_visitor(planner_context);\n-                auto expression_to_interpolate_expression_nodes = planner_actions_visitor.visit(interpolate_actions_dag,\n+                ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+                PlannerActionsVisitor planner_actions_visitor(planner_context, empty_correlated_columns_set);\n+                auto [expression_to_interpolate_expression_nodes, expression_to_interpolate_correlated_subtrees] = planner_actions_visitor.visit(interpolate_actions_dag,\n                     interpolate_node_typed.getExpression());\n+                expression_to_interpolate_correlated_subtrees.assertEmpty(\"in expression to interpolate\");\n                 if (expression_to_interpolate_expression_nodes.size() != 1)\n                     throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expression to interpolate expected to have single action node\");\n \n-                auto interpolate_expression_nodes = planner_actions_visitor.visit(interpolate_actions_dag,\n+                auto [interpolate_expression_nodes, interpolate_correlated_subtrees] = planner_actions_visitor.visit(interpolate_actions_dag,\n                     interpolate_node_typed.getInterpolateExpression());\n+                interpolate_correlated_subtrees.assertEmpty(\"in interpolate expression\");\n                 if (interpolate_expression_nodes.size() != 1)\n                     throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Interpolate expression expected to have single action node\");\n \n@@ -1364,23 +1377,7 @@ void Planner::buildPlanForUnionNode()\n     }\n \n     Block union_common_header = buildCommonHeaderForUnion(query_plans_headers, union_mode);\n-\n-    for (size_t i = 0; i < queries_size; ++i)\n-    {\n-        auto & query_node_plan = query_plans[i];\n-        if (blocksHaveEqualStructure(query_node_plan->getCurrentHeader(), union_common_header))\n-            continue;\n-\n-        auto actions_dag = ActionsDAG::makeConvertingActions(\n-            query_node_plan->getCurrentHeader().getColumnsWithTypeAndName(),\n-            union_common_header.getColumnsWithTypeAndName(),\n-            ActionsDAG::MatchColumnsMode::Position);\n-        auto converting_step = std::make_unique<ExpressionStep>(query_node_plan->getCurrentHeader(), std::move(actions_dag));\n-        converting_step->setStepDescription(\"Conversion before UNION\");\n-        query_node_plan->addStep(std::move(converting_step));\n-\n-        query_plans_headers[i] = query_node_plan->getCurrentHeader();\n-    }\n+    addConvertingToCommonHeaderActionsIfNeeded(query_plans, union_common_header, query_plans_headers);\n \n     const auto & query_context = planner_context->getQueryContext();\n     const auto & settings = query_context->getSettingsRef();\n@@ -1619,7 +1616,7 @@ void Planner::buildPlanForQueryNode()\n     if (query_processing_info.isFirstStage())\n     {\n         if (expression_analysis_result.hasWhere())\n-            addFilterStep(query_plan, expression_analysis_result.getWhere(), \"WHERE\", useful_sets);\n+            addFilterStep(planner_context, query_plan, expression_analysis_result.getWhere(), select_query_options, \"WHERE\", useful_sets);\n \n         if (expression_analysis_result.hasAggregation())\n         {\n@@ -1709,7 +1706,7 @@ void Planner::buildPlanForQueryNode()\n             addCubeOrRollupStepIfNeeded(query_plan, aggregation_analysis_result, query_analysis_result, planner_context, select_query_info, query_node);\n \n             if (!having_executed && expression_analysis_result.hasHaving())\n-                addFilterStep(query_plan, expression_analysis_result.getHaving(), \"HAVING\", useful_sets);\n+                addFilterStep(planner_context, query_plan, expression_analysis_result.getHaving(), select_query_options, \"HAVING\", useful_sets);\n         }\n \n         if (query_processing_info.isFromAggregationState())\n@@ -1730,7 +1727,7 @@ void Planner::buildPlanForQueryNode()\n             }\n \n             if (expression_analysis_result.hasQualify())\n-                addFilterStep(query_plan, expression_analysis_result.getQualify(), \"QUALIFY\", useful_sets);\n+                addFilterStep(planner_context, query_plan, expression_analysis_result.getQualify(), select_query_options, \"QUALIFY\", useful_sets);\n \n             auto & projection_analysis_result = expression_analysis_result.getProjection();\n             addExpressionStep(query_plan, projection_analysis_result.projection_actions, \"Projection\", useful_sets);\ndiff --git a/src/Planner/PlannerActionsVisitor.cpp b/src/Planner/PlannerActionsVisitor.cpp\nindex 780e1d9bd08b..28b3cd477aac 100644\n--- a/src/Planner/PlannerActionsVisitor.cpp\n+++ b/src/Planner/PlannerActionsVisitor.cpp\n@@ -1,15 +1,19 @@\n+#include <utility>\n+#include <ranges>\n #include <Planner/PlannerActionsVisitor.h>\n \n #include <AggregateFunctions/WindowFunction.h>\n-#include <Analyzer/Utils.h>\n-#include <Analyzer/SetUtils.h>\n+\n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n-#include <Analyzer/ColumnNode.h>\n #include <Analyzer/LambdaNode.h>\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/SetUtils.h>\n #include <Analyzer/SortNode.h>\n+#include <Analyzer/UnionNode.h>\n+#include <Analyzer/Utils.h>\n #include <Analyzer/WindowNode.h>\n-#include <Analyzer/QueryNode.h>\n \n #include <DataTypes/FieldToDataType.h>\n #include <DataTypes/DataTypeSet.h>\n@@ -30,10 +34,12 @@\n #include <Interpreters/Set.h>\n \n #include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n #include <Planner/TableExpressionData.h>\n #include <Planner/Utils.h>\n \n #include <Core/Settings.h>\n+#include <fmt/format.h>\n \n \n namespace DB\n@@ -187,6 +193,20 @@ class ActionNodeNameHelper\n                         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Function __actionName is internal nad should not be used directly\");\n                     break;\n                 }\n+                else if (function_node.getFunctionName() == \"exists\")\n+                {\n+                    const auto & arguments = function_node.getArguments().getNodes();\n+                    chassert(arguments.size() == 1);\n+\n+                    const auto & exists_argument = arguments.front();\n+                    chassert(exists_argument != nullptr);\n+\n+                    const auto & table_alias = exists_argument->getAlias();\n+                    chassert(!table_alias.empty());\n+\n+                    result = fmt::format(\"exists({})\", table_alias);\n+                    break;\n+                }\n \n                 if (planner_context.getQueryContext()->getSettingsRef()[Setting::enable_named_columns_in_function_tuple])\n                 {\n@@ -441,6 +461,12 @@ class ActionsScopeNode\n             node_name_to_node[node.result_name] = &node;\n     }\n \n+    ActionsScopeNode(const ActionsScopeNode &) = delete;\n+    ActionsScopeNode(ActionsScopeNode &&) = default;\n+\n+    ActionsScopeNode & operator=(const ActionsScopeNode &) = delete;\n+    ActionsScopeNode & operator=(ActionsScopeNode &&) = delete;\n+\n     const QueryTreeNodePtr & getScopeNode() const\n     {\n         return scope_node;\n@@ -493,6 +519,18 @@ class ActionsScopeNode\n         return node;\n     }\n \n+    const ActionsDAG::Node * addPlaceholderColumnIfNecessary(const std::string & node_name, const DataTypePtr & column_type)\n+    {\n+        auto it = node_name_to_node.find(node_name);\n+        if (it != node_name_to_node.end())\n+            return it->second;\n+\n+        const auto * node = &actions_dag.addPlaceholder(node_name, column_type);\n+        node_name_to_node[node->result_name] = node;\n+\n+        return node;\n+    }\n+\n     const ActionsDAG::Node * addInputConstantColumnIfNecessary(const std::string & node_name, const ColumnWithTypeAndName & column)\n     {\n         auto it = node_name_to_node.find(node_name);\n@@ -560,11 +598,13 @@ class ActionsScopeNode\n class PlannerActionsVisitorImpl\n {\n public:\n-    PlannerActionsVisitorImpl(ActionsDAG & actions_dag,\n+    PlannerActionsVisitorImpl(\n+        ActionsDAG & actions_dag,\n         const PlannerContextPtr & planner_context_,\n+        const ColumnNodePtrWithHashSet & correlated_columns_set_,\n         bool use_column_identifier_as_action_node_name_);\n \n-    ActionsDAG::NodeRawConstPtrs visit(QueryTreeNodePtr expression_node);\n+    std::pair<ActionsDAG::NodeRawConstPtrs, CorrelatedSubtrees> visit(QueryTreeNodePtr expression_node);\n \n private:\n \n@@ -607,6 +647,8 @@ class PlannerActionsVisitorImpl\n \n     NodeNameAndNodeMinLevel visitColumn(const QueryTreeNodePtr & node);\n \n+    NodeNameAndNodeMinLevel visitCorrelatedColumn(const ColumnNodePtr & node);\n+\n     NodeNameAndNodeMinLevel visitConstant(const QueryTreeNodePtr & node, const std::string & override_column_name = {});\n \n     NodeNameAndNodeMinLevel visitLambda(const QueryTreeNodePtr & node);\n@@ -615,26 +657,34 @@ class PlannerActionsVisitorImpl\n \n     NodeNameAndNodeMinLevel visitIndexHintFunction(const QueryTreeNodePtr & node);\n \n+    NodeNameAndNodeMinLevel visitExistsFunction(const QueryTreeNodePtr & node);\n+\n     NodeNameAndNodeMinLevel visitFunction(const QueryTreeNodePtr & node);\n \n     std::vector<ActionsScopeNode> actions_stack;\n     std::unordered_map<QueryTreeNodePtr, std::string> node_to_node_name;\n+    CorrelatedSubtrees correlated_subtrees;\n     const PlannerContextPtr planner_context;\n+    const ColumnNodePtrWithHashSet & correlated_columns_set;\n     ActionNodeNameHelper action_node_name_helper;\n     bool use_column_identifier_as_action_node_name;\n };\n \n-PlannerActionsVisitorImpl::PlannerActionsVisitorImpl(ActionsDAG & actions_dag,\n+PlannerActionsVisitorImpl::PlannerActionsVisitorImpl(\n+    ActionsDAG & actions_dag,\n     const PlannerContextPtr & planner_context_,\n-    bool use_column_identifier_as_action_node_name_)\n+    const ColumnNodePtrWithHashSet & correlated_columns_set_,\n+    bool use_column_identifier_as_action_node_name_\n+)\n     : planner_context(planner_context_)\n+    , correlated_columns_set(correlated_columns_set_)\n     , action_node_name_helper(node_to_node_name, *planner_context, use_column_identifier_as_action_node_name_)\n     , use_column_identifier_as_action_node_name(use_column_identifier_as_action_node_name_)\n {\n     actions_stack.emplace_back(actions_dag, nullptr);\n }\n \n-ActionsDAG::NodeRawConstPtrs PlannerActionsVisitorImpl::visit(QueryTreeNodePtr expression_node)\n+std::pair<ActionsDAG::NodeRawConstPtrs, CorrelatedSubtrees> PlannerActionsVisitorImpl::visit(QueryTreeNodePtr expression_node)\n {\n     ActionsDAG::NodeRawConstPtrs result;\n \n@@ -652,7 +702,7 @@ ActionsDAG::NodeRawConstPtrs PlannerActionsVisitorImpl::visit(QueryTreeNodePtr e\n         result.push_back(actions_stack.front().getNodeOrThrow(node_name));\n     }\n \n-    return result;\n+    return std::make_pair(result, correlated_subtrees);\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitImpl(QueryTreeNodePtr node)\n@@ -673,8 +723,13 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitColumn(const QueryTreeNodePtr & node)\n {\n-    auto column_node_name = action_node_name_helper.calculateActionNodeName(node);\n     const auto & column_node = node->as<ColumnNode &>();\n+\n+    const auto & column_node_ptr = static_pointer_cast<ColumnNode>(node);\n+    if (correlated_columns_set.contains(column_node_ptr))\n+        return visitCorrelatedColumn(column_node_ptr);\n+\n+    auto column_node_name = action_node_name_helper.calculateActionNodeName(node);\n     if (column_node.hasExpression())\n     {\n         auto expression = column_node.getExpression();\n@@ -686,6 +741,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n         else if (!use_column_identifier_as_action_node_name)\n             return visitImpl(expression);\n     }\n+\n     Int64 actions_stack_size = static_cast<Int64>(actions_stack.size() - 1);\n     for (Int64 i = actions_stack_size; i >= 0; --i)\n     {\n@@ -703,6 +759,16 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     return {column_node_name, Levels(0)};\n }\n \n+PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitCorrelatedColumn(const ColumnNodePtr & node)\n+{\n+    auto column_node_name = action_node_name_helper.calculateActionNodeName(node);\n+\n+    for (auto & action_scope_node : actions_stack)\n+        action_scope_node.addPlaceholderColumnIfNecessary(column_node_name, node->getColumnType());\n+\n+    return {column_node_name, Levels(0)};\n+}\n+\n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitConstant(const QueryTreeNodePtr & node, const std::string & override_column_name)\n {\n     const auto & constant_node = node->as<ConstantNode &>();\n@@ -913,11 +979,13 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     ActionsDAG index_hint_actions_dag;\n     auto & index_hint_actions_dag_outputs = index_hint_actions_dag.getOutputs();\n     std::unordered_set<std::string_view> index_hint_actions_dag_output_node_names;\n-    PlannerActionsVisitor actions_visitor(planner_context);\n+    ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+    PlannerActionsVisitor actions_visitor(planner_context, empty_correlated_columns_set);\n \n     for (const auto & argument : function_node.getArguments())\n     {\n-        auto index_hint_argument_expression_dag_nodes = actions_visitor.visit(index_hint_actions_dag, argument);\n+        auto [index_hint_argument_expression_dag_nodes, subqueries] = actions_visitor.visit(index_hint_actions_dag, argument);\n+        subqueries.assertEmpty(\"in 'indexHint' function arguments\");\n \n         for (auto & expression_dag_node : index_hint_argument_expression_dag_nodes)\n         {\n@@ -939,12 +1007,44 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     return {function_node_name, Levels(index_hint_function_level)};\n }\n \n+PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitExistsFunction(const QueryTreeNodePtr & node)\n+{\n+    const auto & function_node = node->as<FunctionNode &>();\n+    auto function_node_name = action_node_name_helper.calculateActionNodeName(node);\n+\n+    size_t exists_function_level = actions_stack.size() - 1;\n+    for (auto it = actions_stack.rbegin(); it != actions_stack.rend(); ++it)\n+        it->addInputColumnIfNecessary(function_node_name, function_node.getResultType());\n+\n+    auto subquery_argument = function_node.getArguments().getNodes().front();\n+    auto * query_node = subquery_argument->as<QueryNode>();\n+    auto * union_node = subquery_argument->as<UnionNode>();\n+    chassert(query_node != nullptr || union_node != nullptr);\n+    const QueryTreeNodes & correlated_columns = query_node ? query_node->getCorrelatedColumns().getNodes() : union_node->getCorrelatedColumns().getNodes();\n+\n+    ColumnIdentifiers correlated_column_identifiers;\n+    correlated_column_identifiers.reserve(correlated_columns.size());\n+    for (const auto & column : correlated_columns)\n+    {\n+        correlated_column_identifiers.push_back(action_node_name_helper.calculateActionNodeName(column));\n+    }\n+\n+    correlated_subtrees.subqueries.emplace_back(\n+        function_node.getArguments().getNodes().front(),\n+        CorrelatedSubqueryKind::EXISTS,\n+        function_node_name,\n+        std::move(correlated_column_identifiers));\n+    return { function_node_name, Levels(exists_function_level) };\n+}\n+\n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitFunction(const QueryTreeNodePtr & node)\n {\n     const auto & function_node = node->as<FunctionNode &>();\n \n     if (function_node.getFunctionName() == \"indexHint\")\n         return visitIndexHintFunction(node);\n+    if (function_node.getFunctionName() == \"exists\")\n+        return visitExistsFunction(node);\n \n     std::optional<NodeNameAndNodeMinLevel> in_function_second_argument_node_name_with_level;\n \n@@ -1040,14 +1140,22 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n \n }\n \n-PlannerActionsVisitor::PlannerActionsVisitor(const PlannerContextPtr & planner_context_, bool use_column_identifier_as_action_node_name_)\n+PlannerActionsVisitor::PlannerActionsVisitor(\n+    const PlannerContextPtr & planner_context_,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set_,\n+    bool use_column_identifier_as_action_node_name_)\n     : planner_context(planner_context_)\n+    , correlated_columns_set(correlated_columns_set_)\n     , use_column_identifier_as_action_node_name(use_column_identifier_as_action_node_name_)\n {}\n \n-ActionsDAG::NodeRawConstPtrs PlannerActionsVisitor::visit(ActionsDAG & actions_dag, QueryTreeNodePtr expression_node)\n+std::pair<ActionsDAG::NodeRawConstPtrs, CorrelatedSubtrees> PlannerActionsVisitor::visit(ActionsDAG & actions_dag, QueryTreeNodePtr expression_node)\n {\n-    PlannerActionsVisitorImpl actions_visitor_impl(actions_dag, planner_context, use_column_identifier_as_action_node_name);\n+    PlannerActionsVisitorImpl actions_visitor_impl(\n+        actions_dag,\n+        planner_context,\n+        correlated_columns_set,\n+        use_column_identifier_as_action_node_name);\n     return actions_visitor_impl.visit(expression_node);\n }\n \ndiff --git a/src/Planner/PlannerActionsVisitor.h b/src/Planner/PlannerActionsVisitor.h\nindex 6084f0dbd695..680ae5ef7a15 100644\n--- a/src/Planner/PlannerActionsVisitor.h\n+++ b/src/Planner/PlannerActionsVisitor.h\n@@ -1,13 +1,13 @@\n #pragma once\n \n-#include <optional>\n #include <Core/Names.h>\n #include <Core/NamesAndTypes.h>\n \n #include <Interpreters/Context_fwd.h>\n \n-#include <Analyzer/IQueryTreeNode.h>\n #include <Analyzer/ConstantNode.h>\n+#include <Analyzer/HashUtils.h>\n+#include <Analyzer/IQueryTreeNode.h>\n \n #include <Interpreters/ActionsDAG.h>\n #include <Interpreters/WindowDescription.h>\n@@ -15,9 +15,15 @@\n namespace DB\n {\n \n+struct CorrelatedSubtrees;\n+\n class PlannerContext;\n using PlannerContextPtr = std::shared_ptr<PlannerContext>;\n \n+class ColumnNode;\n+using ColumnNodePtr = std::shared_ptr<ColumnNode>;\n+using ColumnNodes = std::vector<ColumnNodePtr>;\n+\n /** Planner actions visitor is responsible for adding necessary actions to calculate query tree expression node\n   * into actions dag.\n   *\n@@ -34,16 +40,20 @@ using PlannerContextPtr = std::shared_ptr<PlannerContext>;\n class PlannerActionsVisitor\n {\n public:\n-    explicit PlannerActionsVisitor(const PlannerContextPtr & planner_context_, bool use_column_identifier_as_action_node_name_ = true);\n+    explicit PlannerActionsVisitor(\n+      const PlannerContextPtr & planner_context_,\n+      const ColumnNodePtrWithHashSet & correlated_columns_set_,\n+      bool use_column_identifier_as_action_node_name_ = true);\n \n     /** Add actions necessary to calculate expression node into expression dag.\n       * Necessary actions are not added in actions dag output.\n       * Returns query tree expression node actions dag nodes.\n       */\n-    ActionsDAG::NodeRawConstPtrs visit(ActionsDAG & actions_dag, QueryTreeNodePtr expression_node);\n+    std::pair<ActionsDAG::NodeRawConstPtrs, CorrelatedSubtrees> visit(ActionsDAG & actions_dag, QueryTreeNodePtr expression_node);\n \n private:\n     const PlannerContextPtr planner_context;\n+    const ColumnNodePtrWithHashSet & correlated_columns_set;\n     bool use_column_identifier_as_action_node_name = true;\n };\n \ndiff --git a/src/Planner/PlannerContext.cpp b/src/Planner/PlannerContext.cpp\nindex 61b1c5ec33ff..89663d6cce44 100644\n--- a/src/Planner/PlannerContext.cpp\n+++ b/src/Planner/PlannerContext.cpp\n@@ -1,8 +1,10 @@\n #include <Planner/PlannerContext.h>\n \n-#include <Analyzer/TableNode.h>\n #include <Analyzer/ColumnNode.h>\n #include <Analyzer/ConstantNode.h>\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/TableNode.h>\n+#include <Analyzer/UnionNode.h>\n #include <Interpreters/Context.h>\n #include <IO/WriteHelpers.h>\n \n@@ -46,6 +48,23 @@ bool GlobalPlannerContext::hasColumnIdentifier(const ColumnIdentifier & column_i\n     return column_identifiers.contains(column_identifier);\n }\n \n+void GlobalPlannerContext::collectTableExpressionDataForCorrelatedColumns(\n+    const QueryTreeNodePtr & table_expression_node,\n+    const PlannerContextPtr & planner_context)\n+{\n+\n+    auto * query_node = table_expression_node->as<QueryNode>();\n+    auto * union_node = table_expression_node->as<UnionNode>();\n+    chassert(query_node != nullptr && query_node->isCorrelated() || union_node != nullptr && union_node->isCorrelated());\n+\n+    const auto & correlated_columns = query_node ? query_node->getCorrelatedColumns().getNodes() : union_node->getCorrelatedColumns().getNodes();\n+    for (const auto & column : correlated_columns)\n+    {\n+        auto column_source = column->as<ColumnNode>()->getColumnSource();\n+        shared_table_expression_data.emplace(column_source, &planner_context->getTableExpressionDataOrThrow(column_source));\n+    }\n+}\n+\n PlannerContext::PlannerContext(ContextMutablePtr query_context_, GlobalPlannerContextPtr global_planner_context_, const SelectQueryOptions & select_query_options_)\n     : query_context(std::move(query_context_))\n     , global_planner_context(std::move(global_planner_context_))\n@@ -60,6 +79,10 @@ PlannerContext::PlannerContext(ContextMutablePtr query_context_, PlannerContextP\n \n TableExpressionData & PlannerContext::getOrCreateTableExpressionData(const QueryTreeNodePtr & table_expression_node)\n {\n+    auto & shared_table_expression_data = getSharedTableExpressionDataMap();\n+    if (auto it = shared_table_expression_data.find(table_expression_node); it != shared_table_expression_data.end())\n+        return *it->second;\n+\n     auto [it, _] = table_expression_node_to_data.emplace(table_expression_node, TableExpressionData());\n     return it->second;\n }\n@@ -68,9 +91,15 @@ const TableExpressionData & PlannerContext::getTableExpressionDataOrThrow(const\n {\n     auto table_expression_data_it = table_expression_node_to_data.find(table_expression_node);\n     if (table_expression_data_it == table_expression_node_to_data.end())\n+    {\n+        const auto & shared_table_expression_data = getSharedTableExpressionDataMap();\n+        if (auto it = shared_table_expression_data.find(table_expression_node); it != shared_table_expression_data.end())\n+            return *it->second;\n+\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"Table expression {} is not registered in planner context\",\n             table_expression_node->formatASTForErrorMessage());\n+    }\n \n     return table_expression_data_it->second;\n }\n@@ -79,9 +108,17 @@ TableExpressionData & PlannerContext::getTableExpressionDataOrThrow(const QueryT\n {\n     auto table_expression_data_it = table_expression_node_to_data.find(table_expression_node);\n     if (table_expression_data_it == table_expression_node_to_data.end())\n+    {\n+        auto & shared_table_expression_data = getSharedTableExpressionDataMap();\n+\n+        auto it = shared_table_expression_data.find(table_expression_node);\n+        if (it != shared_table_expression_data.end())\n+            return *it->second;\n+\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"Table expression {} is not registered in planner context\",\n             table_expression_node->formatASTForErrorMessage());\n+    }\n \n     return table_expression_data_it->second;\n }\n@@ -90,7 +127,14 @@ const TableExpressionData * PlannerContext::getTableExpressionDataOrNull(const Q\n {\n     auto table_expression_data_it = table_expression_node_to_data.find(table_expression_node);\n     if (table_expression_data_it == table_expression_node_to_data.end())\n+    {\n+        const auto & shared_table_expression_data = getSharedTableExpressionDataMap();\n+\n+        if (auto it = shared_table_expression_data.find(table_expression_node); it != shared_table_expression_data.end())\n+            return it->second;\n+\n         return nullptr;\n+    }\n \n     return &table_expression_data_it->second;\n }\n@@ -99,7 +143,14 @@ TableExpressionData * PlannerContext::getTableExpressionDataOrNull(const QueryTr\n {\n     auto table_expression_data_it = table_expression_node_to_data.find(table_expression_node);\n     if (table_expression_data_it == table_expression_node_to_data.end())\n+    {\n+        auto & shared_table_expression_data = getSharedTableExpressionDataMap();\n+\n+        if (auto it = shared_table_expression_data.find(table_expression_node); it != shared_table_expression_data.end())\n+            return it->second;\n+\n         return nullptr;\n+    }\n \n     return &table_expression_data_it->second;\n }\ndiff --git a/src/Planner/PlannerContext.h b/src/Planner/PlannerContext.h\nindex b098a6270509..92af2687c59b 100644\n--- a/src/Planner/PlannerContext.h\n+++ b/src/Planner/PlannerContext.h\n@@ -28,6 +28,10 @@ struct FiltersForTableExpression\n \n using FiltersForTableExpressionMap = std::map<QueryTreeNodePtr, FiltersForTableExpression>;\n \n+class PlannerContext;\n+using PlannerContextPtr = std::shared_ptr<PlannerContext>;\n+\n+using RawTableExpressionDataMap = std::unordered_map<QueryTreeNodePtr, TableExpressionData *>;\n \n class GlobalPlannerContext\n {\n@@ -57,6 +61,13 @@ class GlobalPlannerContext\n     /// Check if context has column identifier\n     bool hasColumnIdentifier(const ColumnIdentifier & column_identifier);\n \n+    void collectTableExpressionDataForCorrelatedColumns(\n+      const QueryTreeNodePtr & table_expression_node,\n+      const PlannerContextPtr & planner_context);\n+\n+    RawTableExpressionDataMap & getTableExpressionDataMap() noexcept { return shared_table_expression_data; }\n+    const RawTableExpressionDataMap & getTableExpressionDataMap() const noexcept { return shared_table_expression_data; }\n+\n     /// The query which will be executed with parallel replicas.\n     /// In case if only the most inner subquery can be executed with parallel replicas, node is nullptr.\n     const QueryNode * const parallel_replicas_node = nullptr;\n@@ -68,13 +79,13 @@ class GlobalPlannerContext\n \n private:\n     std::unordered_set<ColumnIdentifier> column_identifiers;\n+\n+    /// Table expression node to data map for correlated columns sources\n+    RawTableExpressionDataMap shared_table_expression_data;\n };\n \n using GlobalPlannerContextPtr = std::shared_ptr<GlobalPlannerContext>;\n \n-class PlannerContext;\n-using PlannerContextPtr = std::shared_ptr<PlannerContext>;\n-\n class PlannerContext\n {\n public:\n@@ -176,6 +187,11 @@ class PlannerContext\n     bool isASTLevelOptimizationAllowed() const { return is_ast_level_optimization_allowed; }\n \n private:\n+\n+    RawTableExpressionDataMap & getSharedTableExpressionDataMap() noexcept { return global_planner_context->getTableExpressionDataMap(); }\n+\n+    const RawTableExpressionDataMap & getSharedTableExpressionDataMap() const noexcept { return global_planner_context->getTableExpressionDataMap(); }\n+\n     /// Query context\n     ContextMutablePtr query_context;\n \ndiff --git a/src/Planner/PlannerCorrelatedSubqueries.cpp b/src/Planner/PlannerCorrelatedSubqueries.cpp\nnew file mode 100644\nindex 000000000000..b178e162eed6\n--- /dev/null\n+++ b/src/Planner/PlannerCorrelatedSubqueries.cpp\n@@ -0,0 +1,457 @@\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n+\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/UnionNode.h>\n+\n+#include <Common/Exception.h>\n+#include <Common/typeid_cast.h>\n+\n+#include <Core/Joins.h>\n+#include <Core/Settings.h>\n+\n+#include <DataTypes/DataTypesNumber.h>\n+\n+#include <Interpreters/ActionsDAG.h>\n+#include <Interpreters/JoinInfo.h>\n+\n+#include <Parsers/SelectUnionMode.h>\n+\n+#include <Planner/Planner.h>\n+#include <Planner/PlannerActionsVisitor.h>\n+#include <Planner/PlannerContext.h>\n+#include <Planner/PlannerJoinsLogical.h>\n+#include <Planner/Utils.h>\n+\n+#include <Processors/QueryPlan/AggregatingStep.h>\n+#include <Processors/QueryPlan/ExpressionStep.h>\n+#include <Processors/QueryPlan/FilterStep.h>\n+#include <Processors/QueryPlan/JoinStepLogical.h>\n+#include <Processors/QueryPlan/UnionStep.h>\n+\n+#include <memory>\n+#include <string_view>\n+#include <fmt/format.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+\n+extern const int NOT_IMPLEMENTED;\n+\n+}\n+\n+namespace Setting\n+{\n+\n+extern const SettingsBool join_use_nulls;\n+\n+}\n+\n+void CorrelatedSubtrees::assertEmpty(std::string_view reason) const\n+{\n+    if (notEmpty())\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Correlated subqueries {} are not supported\", reason);\n+}\n+\n+namespace\n+{\n+\n+using CorrelatedPlanStepMap = std::unordered_map<QueryPlan::Node *, bool>;\n+\n+CorrelatedPlanStepMap buildCorrelatedPlanStepMap(QueryPlan & correlated_query_plan)\n+{\n+    CorrelatedPlanStepMap result;\n+\n+    struct State\n+    {\n+        QueryPlan::Node * node;\n+        bool processed_children = false;\n+    };\n+\n+    std::vector<State> nodes_to_process{ { .node = correlated_query_plan.getRootNode() } };\n+    while (!nodes_to_process.empty())\n+    {\n+        size_t current_index = nodes_to_process.size() - 1;\n+        if (nodes_to_process[current_index].processed_children)\n+        {\n+            auto * current = nodes_to_process[current_index].node;\n+\n+            auto & value = result[current];\n+            value = current->step->hasCorrelatedExpressions();\n+\n+            for (auto * child : current->children)\n+                value |= result[child];\n+\n+            nodes_to_process.pop_back();\n+        }\n+        else\n+        {\n+            for (auto * child : nodes_to_process[current_index].node->children)\n+                nodes_to_process.push_back({ .node = child });\n+            nodes_to_process[current_index].processed_children = true;\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+struct DecorrelationContext\n+{\n+    const PlannerContextPtr & planner_context;\n+    QueryPlan query_plan; // LHS plan\n+    QueryPlan correlated_query_plan;\n+    CorrelatedPlanStepMap correlated_plan_steps;\n+};\n+\n+/// Correlated subquery is represented by implicit dependent join operator.\n+/// This function builds a query plan to evaluate correlated subquery by\n+/// pushing dependent join down and replacing it with CROSS JOIN.\n+QueryPlan decorrelateQueryPlan(\n+    DecorrelationContext & context,\n+    QueryPlan::Node * node\n+)\n+{\n+    if (!context.correlated_plan_steps[node])\n+    {\n+        /// The rest of the query plan doesn't use any correlated columns.\n+        auto lhs_plan = context.query_plan.clone();\n+\n+        const auto & settings = context.planner_context->getQueryContext()->getSettingsRef();\n+\n+        auto lhs_plan_header = lhs_plan.getCurrentHeader();\n+        auto decorrelated_plan_header = node->step->getOutputHeader();\n+\n+        ColumnsWithTypeAndName output_columns_and_types;\n+        output_columns_and_types.insert_range(output_columns_and_types.cend(), lhs_plan.getCurrentHeader().getColumnsWithTypeAndName());\n+        output_columns_and_types.insert_range(output_columns_and_types.cend(), node->step->getOutputHeader().getColumnsWithTypeAndName());\n+\n+        JoinExpressionActions join_expression_actions(\n+            lhs_plan_header.getColumnsWithTypeAndName(),\n+            decorrelated_plan_header.getColumnsWithTypeAndName(),\n+            output_columns_and_types);\n+\n+        Names output_columns;\n+        output_columns.insert_range(output_columns.cend(), lhs_plan.getCurrentHeader().getNames());\n+        output_columns.insert_range(output_columns.cend(), node->step->getOutputHeader().getNames());\n+\n+        auto decorrelated_join = std::make_unique<JoinStepLogical>(\n+            lhs_plan_header,\n+            /*right_header_=*/decorrelated_plan_header,\n+            JoinInfo{\n+                .expression = {},\n+                .kind = JoinKind::Cross,\n+                .strictness = JoinStrictness::All,\n+                .locality = JoinLocality::Local\n+            },\n+            std::move(join_expression_actions),\n+            std::move(output_columns),\n+            settings[Setting::join_use_nulls],\n+            JoinSettings(settings),\n+            SortingStep::Settings(settings));\n+        decorrelated_join->setStepDescription(\"JOIN to evaluate correlated expression\");\n+\n+        /// Add CROSS JOIN\n+        QueryPlan result_plan;\n+\n+        std::vector<QueryPlanPtr> plans;\n+        plans.emplace_back(std::make_unique<QueryPlan>(std::move(lhs_plan)));\n+        plans.emplace_back(std::make_unique<QueryPlan>(context.correlated_query_plan.extractSubplan(node)));\n+\n+        result_plan.unitePlans(std::move(decorrelated_join), {std::move(plans)});\n+\n+        return result_plan;\n+    }\n+\n+    if (auto * expression_step = typeid_cast<ExpressionStep *>(node->step.get()))\n+    {\n+        auto decorrelated_query_plan = decorrelateQueryPlan(context, node->children.front());\n+\n+        auto input_header = decorrelated_query_plan.getCurrentHeader();\n+\n+        expression_step->decorrelateActions();\n+        expression_step->getExpression().appendInputsForUnusedColumns(input_header);\n+        for (const auto & column : input_header.getColumnsWithTypeAndName())\n+            expression_step->getExpression().tryRestoreColumn(column.name);\n+\n+        expression_step->updateInputHeader(input_header);\n+\n+        decorrelated_query_plan.addStep(std::move(node->step));\n+        return decorrelated_query_plan;\n+    }\n+    if (auto * filter_step = typeid_cast<FilterStep *>(node->step.get()))\n+    {\n+        auto decorrelated_query_plan = decorrelateQueryPlan(context, node->children.front());\n+        auto input_header = decorrelated_query_plan.getCurrentHeader();\n+\n+        filter_step->decorrelateActions();\n+        filter_step->getExpression().appendInputsForUnusedColumns(input_header);\n+        for (const auto & column : input_header.getColumnsWithTypeAndName())\n+            filter_step->getExpression().tryRestoreColumn(column.name);\n+\n+        node->step->updateInputHeader(input_header);\n+\n+        decorrelated_query_plan.addStep(std::move(node->step));\n+        return decorrelated_query_plan;\n+    }\n+    if (auto * union_step = typeid_cast<UnionStep *>(node->step.get()))\n+    {\n+        auto decorrelated_lhs_plan = decorrelateQueryPlan(context, node->children.front());\n+        auto decorrelated_rhs_plan = decorrelateQueryPlan(context, node->children.back());\n+\n+        Headers query_plans_headers{ decorrelated_lhs_plan.getCurrentHeader(), decorrelated_rhs_plan.getCurrentHeader() };\n+\n+        std::vector<QueryPlanPtr> child_plans;\n+        child_plans.emplace_back(std::make_unique<QueryPlan>(std::move(decorrelated_lhs_plan)));\n+        child_plans.emplace_back(std::make_unique<QueryPlan>(std::move(decorrelated_rhs_plan)));\n+\n+        Block union_common_header = buildCommonHeaderForUnion(query_plans_headers, SelectUnionMode::UNION_ALL); // Union mode doesn't matter here\n+        addConvertingToCommonHeaderActionsIfNeeded(child_plans, union_common_header, query_plans_headers);\n+\n+        union_step->updateInputHeaders(std::move(query_plans_headers));\n+\n+        QueryPlan result_plan;\n+        result_plan.unitePlans(std::move(node->step), std::move(child_plans));\n+\n+        return result_plan;\n+    }\n+    throw Exception(\n+        ErrorCodes::NOT_IMPLEMENTED,\n+        \"Cannot decorrelate query, because '{}' step is not supported\",\n+        node->step->getStepDescription());\n+}\n+\n+void buildExistsResultExpression(\n+    QueryPlan & query_plan,\n+    const CorrelatedSubquery & correlated_subquery,\n+    bool project_only_correlated_columns\n+)\n+{\n+    ActionsDAG dag(query_plan.getCurrentHeader().getNamesAndTypesList());\n+    auto result_type = std::make_shared<DataTypeUInt8>();\n+    auto column = result_type->createColumnConst(1, 1);\n+    const auto * exists_result = &dag.materializeNode(dag.addColumn(ColumnWithTypeAndName(column, result_type, correlated_subquery.action_node_name)));\n+\n+    if (project_only_correlated_columns)\n+    {\n+        ActionsDAG::NodeRawConstPtrs new_outputs;\n+        new_outputs.reserve(correlated_subquery.correlated_column_identifiers.size() + 1);\n+\n+        for (const auto & column_name : correlated_subquery.correlated_column_identifiers)\n+        {\n+            new_outputs.push_back(&dag.addAlias(dag.findInOutputs(column_name), fmt::format(\"{}.{}\", correlated_subquery.action_node_name, column_name)));\n+        }\n+        new_outputs.push_back(exists_result);\n+\n+        dag.getOutputs() = std::move(new_outputs);\n+    }\n+    else\n+    {\n+        dag.addOrReplaceInOutputs(*exists_result);\n+    }\n+\n+    auto expression_step = std::make_unique<ExpressionStep>(query_plan.getCurrentHeader(), std::move(dag));\n+    expression_step->setStepDescription(\"Create result for always true EXISTS expression\");\n+    query_plan.addStep(std::move(expression_step));\n+}\n+\n+/// Remove query plan steps that don't affect the number of rows in the result.\n+/// Returns true if the query always returns at least 1 row.\n+bool optimizeCorrelatedPlanForExists(QueryPlan & correlated_query_plan)\n+{\n+    auto * node = correlated_query_plan.getRootNode();\n+    while (true)\n+    {\n+        if (typeid_cast<ExpressionStep *>(node->step.get()))\n+        {\n+            node = node->children[0];\n+            continue;\n+        }\n+        if (auto * aggregation = typeid_cast<AggregatingStep *>(node->step.get()))\n+        {\n+            const auto & params = aggregation->getParams();\n+            if (params.keys_size == 0 && !params.empty_result_for_aggregation_by_empty_set)\n+            {\n+                /// Subquery will always produce at least one row\n+                return true;\n+            }\n+            node = node->children[0];\n+            continue;\n+        }\n+        break;\n+    }\n+\n+    if (node != correlated_query_plan.getRootNode())\n+    {\n+        correlated_query_plan = correlated_query_plan.extractSubplan(node);\n+    }\n+    return false;\n+}\n+\n+QueryPlan buildLogicalJoin(\n+    const PlannerContextPtr & planner_context,\n+    QueryPlan left_plan,\n+    QueryPlan right_plan,\n+    const CorrelatedSubquery & correlated_subquery\n+)\n+{\n+    const auto & lhs_plan_header = left_plan.getCurrentHeader();\n+    const auto & rhs_plan_header = right_plan.getCurrentHeader();\n+\n+    ColumnsWithTypeAndName output_columns_and_types;\n+    output_columns_and_types.insert_range(output_columns_and_types.cend(), lhs_plan_header.getColumnsWithTypeAndName());\n+    output_columns_and_types.emplace_back(rhs_plan_header.getByName(correlated_subquery.action_node_name));\n+\n+    JoinExpressionActions join_expression_actions(\n+        lhs_plan_header.getColumnsWithTypeAndName(),\n+        rhs_plan_header.getColumnsWithTypeAndName(),\n+        output_columns_and_types);\n+\n+    Names output_columns;\n+    output_columns.insert_range(output_columns.cend(), lhs_plan_header.getNames());\n+    output_columns.push_back(correlated_subquery.action_node_name);\n+\n+    const auto & settings = planner_context->getQueryContext()->getSettingsRef();\n+\n+    std::vector<JoinPredicate> predicates;\n+    for (const auto & column_name : correlated_subquery.correlated_column_identifiers)\n+    {\n+        const auto * left_node = &join_expression_actions.left_pre_join_actions->findInOutputs(column_name);\n+        const auto * right_node = &join_expression_actions.right_pre_join_actions->findInOutputs(fmt::format(\"{}.{}\", correlated_subquery.action_node_name, column_name));\n+\n+        JoinPredicate predicate{\n+            .left_node = JoinActionRef(left_node, join_expression_actions.left_pre_join_actions.get()),\n+            .right_node = JoinActionRef(right_node, join_expression_actions.right_pre_join_actions.get()),\n+            .op = PredicateOperator::Equals\n+        };\n+\n+        predicates.emplace_back(std::move(predicate));\n+    }\n+\n+    /// Add LEFT OUTER JOIN\n+    auto result_join = std::make_unique<JoinStepLogical>(\n+        lhs_plan_header,\n+        rhs_plan_header,\n+        JoinInfo{\n+            .expression = JoinExpression{\n+                .condition = JoinCondition{\n+                    .predicates = std::move(predicates),\n+                    .left_filter_conditions = {},\n+                    .right_filter_conditions = {},\n+                    .residual_conditions = {}\n+                },\n+                .disjunctive_conditions = {}\n+            },\n+            .kind = JoinKind::Left,\n+            .strictness = JoinStrictness::Any,\n+            .locality = JoinLocality::Local\n+        },\n+        std::move(join_expression_actions),\n+        std::move(output_columns),\n+        /*join_use_nulls=*/false,\n+        JoinSettings(settings),\n+        SortingStep::Settings(settings));\n+    result_join->setStepDescription(\"JOIN to generate result stream\");\n+\n+    QueryPlan result_plan;\n+\n+    std::vector<QueryPlanPtr> plans;\n+    plans.emplace_back(std::make_unique<QueryPlan>(std::move(left_plan)));\n+    plans.emplace_back(std::make_unique<QueryPlan>(std::move(right_plan)));\n+\n+    result_plan.unitePlans(std::move(result_join), {std::move(plans)});\n+    return result_plan;\n+}\n+\n+}\n+\n+/* Build query plan for correlated subquery using decorrelation algorithm\n+ * on top of relational algebra operators proposed by TU Munich researchers\n+ * Thomas Neumann and Alfons Kemper.\n+ *\n+ * Original research paper \"Unnesting Arbitrary Queries\": https://cs.emis.de/LNI/Proceedings/Proceedings241/383.pdf\n+ * See also a follow-up paper, \"Improving Unnesting of Complex Queries\": https://dl.gi.de/items/b9df4765-d1b0-4267-a77c-4ce4ab0ee62d\n+ *\n+ * NOTE: ClickHouse does not explicitly build SQL query into relational algebra expression.\n+ * Instead, it produces a query plan where almost every step has an analog from relational algebra.\n+ * This function implements a decorrelation algorithm using the ClickHouse query plan.\n+ *\n+ * TODO: Support scalar correlated subqueries.\n+ * TODO: Support decorrelation of all kinds of query plan steps.\n+ * TODO: Implement left table substitution optimization: T_left DEPENDENT JOIN T_right is a subset of T_right\n+ * if T_right has all the necessary columns of T_left.\n+ */\n+void buildQueryPlanForCorrelatedSubquery(\n+    const PlannerContextPtr & planner_context,\n+    QueryPlan & query_plan,\n+    const CorrelatedSubquery & correlated_subquery,\n+    const SelectQueryOptions & select_query_options)\n+{\n+    auto * query_node = correlated_subquery.query_tree->as<QueryNode>();\n+    auto * union_node = correlated_subquery.query_tree->as<UnionNode>();\n+    chassert(query_node != nullptr && query_node->isCorrelated() || union_node != nullptr && union_node->isCorrelated());\n+\n+    switch (correlated_subquery.kind)\n+    {\n+        case DB::CorrelatedSubqueryKind::SCALAR:\n+        {\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Scalar correlated subqueries are not supported\");\n+        }\n+        case CorrelatedSubqueryKind::EXISTS:\n+        {\n+            auto subquery_options = select_query_options.subquery();\n+            auto global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});\n+            /// Register table expression data for correlated columns sources in the global context.\n+            /// Table expression data would be reused because it can't be initialized\n+            /// during plan construction for correlated subquery.\n+            global_planner_context->collectTableExpressionDataForCorrelatedColumns(correlated_subquery.query_tree, planner_context);\n+\n+            Planner subquery_planner(\n+                correlated_subquery.query_tree,\n+                subquery_options,\n+                global_planner_context);\n+            subquery_planner.buildQueryPlanIfNeeded();\n+\n+            /// Logical plan for correlated subquery\n+            auto & correlated_query_plan = subquery_planner.getQueryPlan();\n+\n+            /// For EXISTS expression we can remove plan steps that doesn't change the number of result rows.\n+            /// It may also result in non-correlated subquery plan\n+            /// Example:\n+            /// SELECT * FROM numbers(1) WHERE EXISTS (SELECT a = number FROM table)\n+            if (optimizeCorrelatedPlanForExists(correlated_query_plan))\n+            {\n+                /// Subquery always produces at least 1 row.\n+                buildExistsResultExpression(query_plan, correlated_subquery, /*project_only_correlated_columns=*/false);\n+                return;\n+            }\n+\n+            /// Mark all query plan steps if they or their subplans contain usage of correlated subqueries.\n+            /// It's needed to identify the moment when dependent join can be replaced by CROSS JOIN.\n+            auto correlated_step_map = buildCorrelatedPlanStepMap(correlated_query_plan);\n+\n+            DecorrelationContext context{\n+                .planner_context = planner_context,\n+                .query_plan = std::move(query_plan),\n+                .correlated_query_plan = std::move(subquery_planner).extractQueryPlan(),\n+                .correlated_plan_steps = std::move(correlated_step_map)\n+            };\n+\n+            auto decorrelated_plan = decorrelateQueryPlan(context, context.correlated_query_plan.getRootNode());\n+            /// Add a 'exists(<table expression id>)' expression that is always true.\n+            buildExistsResultExpression(decorrelated_plan, correlated_subquery, /*project_only_correlated_columns=*/true);\n+\n+            /// Use LEFT OUTER JOIN to produce the result plan.\n+            /// If there's no corresponding rows from the right side, 'exists(<table expression id>)' would be replaced by default value (false).\n+            query_plan = buildLogicalJoin(\n+                planner_context,\n+                std::move(context.query_plan),\n+                std::move(decorrelated_plan),\n+                correlated_subquery);\n+            break;\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/src/Planner/PlannerCorrelatedSubqueries.h b/src/Planner/PlannerCorrelatedSubqueries.h\nnew file mode 100644\nindex 000000000000..8414ec1b0bc5\n--- /dev/null\n+++ b/src/Planner/PlannerCorrelatedSubqueries.h\n@@ -0,0 +1,62 @@\n+#pragma once\n+\n+#include <memory>\n+#include <string_view>\n+#include <vector>\n+\n+#include <Processors/QueryPlan/QueryPlan.h>\n+\n+namespace DB\n+{\n+\n+struct SelectQueryOptions;\n+\n+class IQueryTreeNode;\n+using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;\n+using QueryTreeNodes = std::vector<QueryTreeNodePtr>;\n+\n+class PlannerContext;\n+using PlannerContextPtr = std::shared_ptr<PlannerContext>;\n+\n+using ColumnIdentifier = std::string;\n+using ColumnIdentifiers = std::vector<ColumnIdentifier>;\n+\n+enum class CorrelatedSubqueryKind\n+{\n+    SCALAR,\n+    EXISTS,\n+};\n+\n+struct CorrelatedSubquery\n+{\n+    CorrelatedSubquery(QueryTreeNodePtr query_tree_, CorrelatedSubqueryKind kind_, const String & action_node_name_, ColumnIdentifiers correlated_column_identifiers_)\n+        : query_tree(std::move(query_tree_))\n+        , kind(kind_)\n+        , action_node_name(action_node_name_)\n+        , correlated_column_identifiers(std::move(correlated_column_identifiers_))\n+    {}\n+\n+    QueryTreeNodePtr query_tree;\n+    CorrelatedSubqueryKind kind;\n+    String action_node_name;\n+    ColumnIdentifiers correlated_column_identifiers;\n+};\n+\n+using CorrelatedSubqueries = std::vector<CorrelatedSubquery>;\n+\n+struct CorrelatedSubtrees\n+{\n+    bool notEmpty() const noexcept { return !subqueries.empty(); }\n+\n+    void assertEmpty(std::string_view reason) const;\n+\n+    CorrelatedSubqueries subqueries;\n+};\n+\n+void buildQueryPlanForCorrelatedSubquery(\n+    const PlannerContextPtr & planner_context,\n+    QueryPlan & query_plan,\n+    const CorrelatedSubquery & correlated_subquery,\n+    const SelectQueryOptions & select_query_options);\n+\n+}\ndiff --git a/src/Planner/PlannerExpressionAnalysis.cpp b/src/Planner/PlannerExpressionAnalysis.cpp\nindex 885de50e65c2..caa5ce58afde 100644\n--- a/src/Planner/PlannerExpressionAnalysis.cpp\n+++ b/src/Planner/PlannerExpressionAnalysis.cpp\n@@ -1,3 +1,5 @@\n+#include <memory>\n+#include <optional>\n #include <Planner/PlannerExpressionAnalysis.h>\n \n #include <Columns/ColumnNullable.h>\n@@ -26,6 +28,7 @@\n #include <Planner/Utils.h>\n \n #include <Core/Settings.h>\n+#include \"Analyzer/HashUtils.h\"\n \n namespace DB\n {\n@@ -46,15 +49,20 @@ namespace\n   * Actions before filter are added into into actions chain.\n   * It is client responsibility to update filter analysis result if filter column must be removed after chain is finalized.\n   */\n-std::optional<FilterAnalysisResult> analyzeFilter(const QueryTreeNodePtr & filter_expression_node,\n+std::optional<FilterAnalysisResult> analyzeFilter(\n+    const QueryTreeNodePtr & filter_expression_node,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n     FilterAnalysisResult result;\n \n+    auto [filter_expression_dag, correlated_subtrees] = buildActionsDAGFromExpressionNode(filter_expression_node, input_columns, planner_context, correlated_columns_set);\n+\n     result.filter_actions = std::make_shared<ActionsAndProjectInputsFlag>();\n-    result.filter_actions->dag = buildActionsDAGFromExpressionNode(filter_expression_node, input_columns, planner_context);\n+    result.filter_actions->dag = std::move(filter_expression_dag);\n+    result.correlated_subtrees = std::move(correlated_subtrees);\n \n     const auto * output = result.filter_actions->dag.getOutputs().at(0);\n     if (output->column && ConstantFilterDescription(*output->column).always_true)\n@@ -109,9 +117,11 @@ bool canRemoveConstantFromGroupByKey(const ConstantNode & root)\n /** Construct aggregation analysis result if query tree has GROUP BY or aggregates.\n   * Actions before aggregation are added into actions chain, if result is not null optional.\n   */\n-std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodePtr & query_tree,\n+std::optional<AggregationAnalysisResult> analyzeAggregation(\n+    const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n     auto & query_node = query_tree->as<QueryNode &>();\n@@ -135,7 +145,7 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodeP\n     GroupingSetsParamsList grouping_sets_parameters_list;\n     bool group_by_with_constant_keys = false;\n \n-    PlannerActionsVisitor actions_visitor(planner_context);\n+    PlannerActionsVisitor actions_visitor(planner_context, correlated_columns_set);\n \n     /// Add expressions from GROUP BY\n     bool group_by_use_nulls = planner_context->getQueryContext()->getSettingsRef()[Setting::group_by_use_nulls]\n@@ -163,7 +173,8 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodeP\n                     if (constant_key && !aggregates_descriptions.empty() && (!check_constants_for_group_by_key || canRemoveConstantFromGroupByKey(*constant_key)))\n                         continue;\n \n-                    auto expression_dag_nodes = actions_visitor.visit(before_aggregation_actions->dag, grouping_set_key_node);\n+                    auto [expression_dag_nodes, correlated_subtrees] = actions_visitor.visit(before_aggregation_actions->dag, grouping_set_key_node);\n+                    correlated_subtrees.assertEmpty(\"in aggregation keys\");\n                     aggregation_keys.reserve(expression_dag_nodes.size());\n \n                     for (auto & expression_dag_node : expression_dag_nodes)\n@@ -215,7 +226,8 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodeP\n                 if (constant_key && !aggregates_descriptions.empty() && (!check_constants_for_group_by_key || canRemoveConstantFromGroupByKey(*constant_key)))\n                     continue;\n \n-                auto expression_dag_nodes = actions_visitor.visit(before_aggregation_actions->dag, group_by_key_node);\n+                auto [expression_dag_nodes, correlated_subtrees] = actions_visitor.visit(before_aggregation_actions->dag, group_by_key_node);\n+                correlated_subtrees.assertEmpty(\"in aggregation keys\");\n                 aggregation_keys.reserve(expression_dag_nodes.size());\n \n                 for (auto & expression_dag_node : expression_dag_nodes)\n@@ -242,7 +254,8 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodeP\n         auto & aggregate_function_node_typed = aggregate_function_node->as<FunctionNode &>();\n         for (const auto & aggregate_function_node_argument : aggregate_function_node_typed.getArguments().getNodes())\n         {\n-            auto expression_dag_nodes = actions_visitor.visit(before_aggregation_actions->dag, aggregate_function_node_argument);\n+            auto [expression_dag_nodes, correlated_subtrees] = actions_visitor.visit(before_aggregation_actions->dag, aggregate_function_node_argument);\n+            correlated_subtrees.assertEmpty(\"in aggregate function argument\");\n             for (auto & expression_dag_node : expression_dag_nodes)\n             {\n                 if (before_aggregation_actions_output_node_names.contains(expression_dag_node->result_name))\n@@ -282,9 +295,11 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodeP\n /** Construct window analysis result if query tree has window functions.\n   * Actions before window functions are added into actions chain, if result is not null optional.\n   */\n-std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query_tree,\n+std::optional<WindowAnalysisResult> analyzeWindow(\n+    const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n     auto window_function_nodes = collectWindowFunctionNodes(query_tree);\n@@ -293,7 +308,7 @@ std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query\n \n     auto window_descriptions = extractWindowDescriptions(window_function_nodes, *planner_context);\n \n-    PlannerActionsVisitor actions_visitor(planner_context);\n+    PlannerActionsVisitor actions_visitor(planner_context, correlated_columns_set);\n \n     ActionsAndProjectInputsFlagPtr before_window_actions = std::make_shared<ActionsAndProjectInputsFlag>();\n     before_window_actions->dag = ActionsDAG(input_columns);\n@@ -306,7 +321,8 @@ std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query\n         auto & window_function_node_typed = window_function_node->as<FunctionNode &>();\n         auto & window_node = window_function_node_typed.getWindowNode()->as<WindowNode &>();\n \n-        auto expression_dag_nodes = actions_visitor.visit(before_window_actions->dag, window_function_node_typed.getArgumentsNode());\n+        auto [expression_dag_nodes, correlated_subtrees] = actions_visitor.visit(before_window_actions->dag, window_function_node_typed.getArgumentsNode());\n+        correlated_subtrees.assertEmpty(\"in window function arguments\");\n \n         for (auto & expression_dag_node : expression_dag_nodes)\n         {\n@@ -317,7 +333,8 @@ std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query\n             before_window_actions_output_node_names.insert(expression_dag_node->result_name);\n         }\n \n-        expression_dag_nodes = actions_visitor.visit(before_window_actions->dag, window_node.getPartitionByNode());\n+        std::tie(expression_dag_nodes, correlated_subtrees) = actions_visitor.visit(before_window_actions->dag, window_node.getPartitionByNode());\n+        correlated_subtrees.assertEmpty(\"in window definition\");\n \n         for (auto & expression_dag_node : expression_dag_nodes)\n         {\n@@ -335,7 +352,8 @@ std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query\n         for (auto & sort_node : order_by_node_list.getNodes())\n         {\n             auto & sort_node_typed = sort_node->as<SortNode &>();\n-            expression_dag_nodes = actions_visitor.visit(before_window_actions->dag, sort_node_typed.getExpression());\n+            std::tie(expression_dag_nodes, correlated_subtrees) = actions_visitor.visit(before_window_actions->dag, sort_node_typed.getExpression());\n+            correlated_subtrees.assertEmpty(\"in window order definition\");\n \n             for (auto & expression_dag_node : expression_dag_nodes)\n             {\n@@ -370,13 +388,22 @@ std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query\n   * Projection actions are added into actions chain.\n   * It is client responsibility to update projection analysis result with project names actions after chain is finalized.\n   */\n-ProjectionAnalysisResult analyzeProjection(const QueryNode & query_node,\n+ProjectionAnalysisResult analyzeProjection(\n+    const QueryNode & query_node,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n+    auto [projection_actions_dag, correlated_subtrees] = buildActionsDAGFromExpressionNode(\n+        query_node.getProjectionNode(),\n+        input_columns,\n+        planner_context,\n+        correlated_columns_set);\n+    correlated_subtrees.assertEmpty(\"in projection list\");\n+\n     auto projection_actions = std::make_shared<ActionsAndProjectInputsFlag>();\n-    projection_actions->dag = buildActionsDAGFromExpressionNode(query_node.getProjectionNode(), input_columns, planner_context);\n+    projection_actions->dag = std::move(projection_actions_dag);\n \n     auto projection_columns = query_node.getProjectionColumns();\n     size_t projection_columns_size = projection_columns.size();\n@@ -418,9 +445,11 @@ ProjectionAnalysisResult analyzeProjection(const QueryNode & query_node,\n /** Construct sort analysis result.\n   * Actions before sort are added into actions chain.\n   */\n-SortAnalysisResult analyzeSort(const QueryNode & query_node,\n+SortAnalysisResult analyzeSort(\n+    const QueryNode & query_node,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n     auto before_sort_actions = std::make_shared<ActionsAndProjectInputsFlag>();\n@@ -428,7 +457,7 @@ SortAnalysisResult analyzeSort(const QueryNode & query_node,\n     auto & before_sort_actions_outputs = before_sort_actions->dag.getOutputs();\n     before_sort_actions_outputs.clear();\n \n-    PlannerActionsVisitor actions_visitor(planner_context);\n+    PlannerActionsVisitor actions_visitor(planner_context, correlated_columns_set);\n     bool has_with_fill = false;\n     std::unordered_set<std::string_view> before_sort_actions_dag_output_node_names;\n \n@@ -439,7 +468,8 @@ SortAnalysisResult analyzeSort(const QueryNode & query_node,\n     for (const auto & sort_node : order_by_node_list.getNodes())\n     {\n         auto & sort_node_typed = sort_node->as<SortNode &>();\n-        auto expression_dag_nodes = actions_visitor.visit(before_sort_actions->dag, sort_node_typed.getExpression());\n+        auto [expression_dag_nodes, correlated_subtrees] = actions_visitor.visit(before_sort_actions->dag, sort_node_typed.getExpression());\n+        correlated_subtrees.assertEmpty(\"in ORDER BY\");\n         has_with_fill |= sort_node_typed.withFill();\n \n         for (auto & action_dag_node : expression_dag_nodes)\n@@ -463,7 +493,7 @@ SortAnalysisResult analyzeSort(const QueryNode & query_node,\n     {\n         auto & interpolate_list_node = query_node.getInterpolate()->as<ListNode &>();\n \n-        PlannerActionsVisitor interpolate_actions_visitor(planner_context);\n+        PlannerActionsVisitor interpolate_actions_visitor(planner_context, correlated_columns_set);\n         ActionsDAG interpolate_actions_dag;\n \n         for (auto & interpolate_node : interpolate_list_node.getNodes())\n@@ -512,10 +542,18 @@ LimitByAnalysisResult analyzeLimitBy(const QueryNode & query_node,\n     const ColumnsWithTypeAndName & input_columns,\n     const PlannerContextPtr & planner_context,\n     const NameSet & required_output_nodes_names,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set,\n     ActionsChain & actions_chain)\n {\n+    auto [before_limit_by_actions_dag, correlated_subtrees] = buildActionsDAGFromExpressionNode(\n+        query_node.getLimitByNode(),\n+        input_columns,\n+        planner_context,\n+        correlated_columns_set);\n+    correlated_subtrees.assertEmpty(\"in LIMIT BY expression\");\n+\n     auto before_limit_by_actions = std::make_shared<ActionsAndProjectInputsFlag>();\n-    before_limit_by_actions->dag = buildActionsDAGFromExpressionNode(query_node.getLimitByNode(), input_columns, planner_context);\n+    before_limit_by_actions->dag = std::move(before_limit_by_actions_dag);\n \n     NameSet limit_by_column_names_set;\n     Names limit_by_column_names;\n@@ -550,14 +588,21 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n \n     ActionsChain actions_chain;\n \n+    ColumnsWithTypeAndName current_output_columns = join_tree_input_columns;\n+\n+    auto correlated_columns_set = query_node.getCorrelatedColumnsSet();\n+\n     std::optional<FilterAnalysisResult> where_analysis_result_optional;\n     std::optional<size_t> where_action_step_index_optional;\n \n-    ColumnsWithTypeAndName current_output_columns = join_tree_input_columns;\n-\n     if (query_node.hasWhere())\n     {\n-        where_analysis_result_optional = analyzeFilter(query_node.getWhere(), current_output_columns, planner_context, actions_chain);\n+        where_analysis_result_optional = analyzeFilter(\n+            query_node.getWhere(),\n+            current_output_columns,\n+            planner_context,\n+            correlated_columns_set,\n+            actions_chain);\n         if (where_analysis_result_optional)\n         {\n             where_action_step_index_optional = actions_chain.getLastStepIndex();\n@@ -565,7 +610,12 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n         }\n     }\n \n-    auto aggregation_analysis_result_optional = analyzeAggregation(query_tree, current_output_columns, planner_context, actions_chain);\n+    auto aggregation_analysis_result_optional = analyzeAggregation(\n+        query_tree,\n+        current_output_columns,\n+        planner_context,\n+        correlated_columns_set,\n+        actions_chain);\n     if (aggregation_analysis_result_optional)\n         current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n \n@@ -574,7 +624,12 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n \n     if (query_node.hasHaving())\n     {\n-        having_analysis_result_optional = analyzeFilter(query_node.getHaving(), current_output_columns, planner_context, actions_chain);\n+        having_analysis_result_optional = analyzeFilter(\n+            query_node.getHaving(),\n+            current_output_columns,\n+            planner_context,\n+            correlated_columns_set,\n+            actions_chain);\n         if (having_analysis_result_optional)\n         {\n             having_action_step_index_optional = actions_chain.getLastStepIndex();\n@@ -582,7 +637,12 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n         }\n     }\n \n-    auto window_analysis_result_optional = analyzeWindow(query_tree, current_output_columns, planner_context, actions_chain);\n+    auto window_analysis_result_optional = analyzeWindow(\n+        query_tree,\n+        current_output_columns,\n+        planner_context,\n+        correlated_columns_set,\n+        actions_chain);\n     if (window_analysis_result_optional)\n         current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n \n@@ -591,7 +651,12 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n \n     if (query_node.hasQualify())\n     {\n-        qualify_analysis_result_optional = analyzeFilter(query_node.getQualify(), current_output_columns, planner_context, actions_chain);\n+        qualify_analysis_result_optional = analyzeFilter(\n+            query_node.getQualify(),\n+            current_output_columns,\n+            planner_context,\n+            correlated_columns_set,\n+            actions_chain);\n         if (qualify_analysis_result_optional)\n         {\n             qualify_action_step_index_optional = actions_chain.getLastStepIndex();\n@@ -599,13 +664,23 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n         }\n     }\n \n-    auto projection_analysis_result = analyzeProjection(query_node, current_output_columns, planner_context, actions_chain);\n+    auto projection_analysis_result = analyzeProjection(\n+        query_node,\n+        current_output_columns,\n+        planner_context,\n+        correlated_columns_set,\n+        actions_chain);\n     current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n \n     std::optional<SortAnalysisResult> sort_analysis_result_optional;\n     if (query_node.hasOrderBy())\n     {\n-        sort_analysis_result_optional = analyzeSort(query_node, current_output_columns, planner_context, actions_chain);\n+        sort_analysis_result_optional = analyzeSort(\n+            query_node,\n+            current_output_columns,\n+            planner_context,\n+            correlated_columns_set,\n+            actions_chain);\n         current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n     }\n \n@@ -628,10 +703,12 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n                 required_output_nodes_names.insert(output_node->result_name);\n         }\n \n-        limit_by_analysis_result_optional = analyzeLimitBy(query_node,\n+        limit_by_analysis_result_optional = analyzeLimitBy(\n+            query_node,\n             current_output_columns,\n             planner_context,\n             required_output_nodes_names,\n+            correlated_columns_set,\n             actions_chain);\n         current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n     }\ndiff --git a/src/Planner/PlannerExpressionAnalysis.h b/src/Planner/PlannerExpressionAnalysis.h\nindex 9ae2e672af93..dfa76d256f2f 100644\n--- a/src/Planner/PlannerExpressionAnalysis.h\n+++ b/src/Planner/PlannerExpressionAnalysis.h\n@@ -6,10 +6,11 @@\n \n #include <Interpreters/ActionsDAG.h>\n \n-#include <Planner/PlannerContext.h>\n #include <Planner/PlannerAggregation.h>\n-#include <Planner/PlannerWindowFunctions.h>\n+#include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n #include <Planner/PlannerQueryProcessingInfo.h>\n+#include <Planner/PlannerWindowFunctions.h>\n \n namespace DB\n {\n@@ -25,6 +26,7 @@ struct ProjectionAnalysisResult\n struct FilterAnalysisResult\n {\n     ActionsAndProjectInputsFlagPtr filter_actions;\n+    CorrelatedSubtrees correlated_subtrees;\n     std::string filter_column_name;\n     bool remove_filter_column = false;\n };\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex d20fecf5e6d1..4d6d9d413094 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -2183,7 +2183,8 @@ JoinTreeQueryPlan buildQueryPlanForArrayJoinNode(const QueryTreeNodePtr & array_\n     auto plan_output_columns = plan.getCurrentHeader().getColumnsWithTypeAndName();\n \n     ActionsDAG array_join_action_dag(plan_output_columns);\n-    PlannerActionsVisitor actions_visitor(planner_context);\n+    ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+    PlannerActionsVisitor actions_visitor(planner_context, empty_correlated_columns_set);\n     std::unordered_set<std::string> array_join_expressions_output_nodes;\n \n     Names array_join_column_names;\n@@ -2194,7 +2195,8 @@ JoinTreeQueryPlan buildQueryPlanForArrayJoinNode(const QueryTreeNodePtr & array_\n         array_join_column_names.push_back(array_join_column_identifier);\n \n         auto & array_join_expression_column = array_join_expression->as<ColumnNode &>();\n-        auto expression_dag_index_nodes = actions_visitor.visit(array_join_action_dag, array_join_expression_column.getExpressionOrThrow());\n+        auto [expression_dag_index_nodes, correlated_subtrees] = actions_visitor.visit(array_join_action_dag, array_join_expression_column.getExpressionOrThrow());\n+        correlated_subtrees.assertEmpty(\"in ARRAY JOIN\");\n \n         for (auto & expression_dag_index_node : expression_dag_index_nodes)\n         {\ndiff --git a/src/Planner/PlannerJoins.cpp b/src/Planner/PlannerJoins.cpp\nindex bda27ad57ec2..2836da64256e 100644\n--- a/src/Planner/PlannerJoins.cpp\n+++ b/src/Planner/PlannerJoins.cpp\n@@ -244,8 +244,10 @@ const ActionsDAG::Node * appendExpression(\n     const PlannerContextPtr & planner_context,\n     const JoinNode & join_node)\n {\n-    PlannerActionsVisitor join_expression_visitor(planner_context);\n-    auto join_expression_dag_node_raw_pointers = join_expression_visitor.visit(dag, expression);\n+    ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+    PlannerActionsVisitor join_expression_visitor(planner_context, empty_correlated_columns_set);\n+    auto [join_expression_dag_node_raw_pointers, correlated_subtrees] = join_expression_visitor.visit(dag, expression);\n+    correlated_subtrees.assertEmpty(\"in JOINs\");\n     if (join_expression_dag_node_raw_pointers.size() != 1)\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"JOIN {} ON clause contains multiple expressions\",\n@@ -913,8 +915,10 @@ JoinClausesAndActions buildJoinClausesAndActions(\n         if (result.join_clauses.size() > 1)\n         {\n             ActionsDAG residual_join_expressions_actions(result_relation_columns);\n-            PlannerActionsVisitor join_expression_visitor(planner_context);\n-            auto join_expression_dag_node_raw_pointers = join_expression_visitor.visit(residual_join_expressions_actions, join_expression);\n+            ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+            PlannerActionsVisitor join_expression_visitor(planner_context, empty_correlated_columns_set);\n+            auto [join_expression_dag_node_raw_pointers, correlated_subtrees] = join_expression_visitor.visit(residual_join_expressions_actions, join_expression);\n+            correlated_subtrees.assertEmpty(\"in JOIN condition\");\n             if (join_expression_dag_node_raw_pointers.size() != 1)\n                 throw Exception(\n                     ErrorCodes::LOGICAL_ERROR, \"JOIN {} ON clause contains multiple expressions\", join_node.formatASTForErrorMessage());\ndiff --git a/src/Planner/PlannerJoinsLogical.cpp b/src/Planner/PlannerJoinsLogical.cpp\nindex 871587535a80..76f49a44cd28 100644\n--- a/src/Planner/PlannerJoinsLogical.cpp\n+++ b/src/Planner/PlannerJoinsLogical.cpp\n@@ -40,7 +40,9 @@\n \n #include <Planner/PlannerActionsVisitor.h>\n #include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n #include <Planner/Utils.h>\n+\n #include <Processors/QueryPlan/JoinStepLogical.h>\n \n #include <Core/Settings.h>\n@@ -71,8 +73,11 @@ const ActionsDAG::Node * appendExpression(\n     const QueryTreeNodePtr & expression,\n     const PlannerContextPtr & planner_context)\n {\n-    PlannerActionsVisitor join_expression_visitor(planner_context);\n-    auto join_expression_dag_node_raw_pointers = join_expression_visitor.visit(dag, expression);\n+    ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+    PlannerActionsVisitor join_expression_visitor(planner_context, empty_correlated_columns_set);\n+    auto [join_expression_dag_node_raw_pointers, correlated_subtrees] = join_expression_visitor.visit(dag, expression);\n+    correlated_subtrees.assertEmpty(\"in join expression\");\n+\n     if (join_expression_dag_node_raw_pointers.size() != 1)\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"Expression {} expected be a single node, got {}\",\ndiff --git a/src/Planner/Utils.cpp b/src/Planner/Utils.cpp\nindex 602a5507e73e..c4ec9fecbd72 100644\n--- a/src/Planner/Utils.cpp\n+++ b/src/Planner/Utils.cpp\n@@ -42,9 +42,11 @@\n \n #include <Core/Settings.h>\n \n-#include <Planner/PlannerActionsVisitor.h>\n-#include <Planner/CollectTableExpressionData.h>\n #include <Planner/CollectSets.h>\n+#include <Planner/CollectTableExpressionData.h>\n+#include <Planner/PlannerActionsVisitor.h>\n+\n+#include <Processors/QueryPlan/ExpressionStep.h>\n \n #include <stack>\n \n@@ -136,6 +138,30 @@ Block buildCommonHeaderForUnion(const Blocks & queries_headers, SelectUnionMode\n     return common_header;\n }\n \n+void addConvertingToCommonHeaderActionsIfNeeded(\n+    std::vector<std::unique_ptr<QueryPlan>> & query_plans,\n+    const Block & union_common_header,\n+    Blocks & query_plans_headers)\n+{\n+    size_t queries_size = query_plans.size();\n+    for (size_t i = 0; i < queries_size; ++i)\n+    {\n+        auto & query_node_plan = query_plans[i];\n+        if (blocksHaveEqualStructure(query_node_plan->getCurrentHeader(), union_common_header))\n+            continue;\n+\n+        auto actions_dag = ActionsDAG::makeConvertingActions(\n+            query_node_plan->getCurrentHeader().getColumnsWithTypeAndName(),\n+            union_common_header.getColumnsWithTypeAndName(),\n+            ActionsDAG::MatchColumnsMode::Position);\n+        auto converting_step = std::make_unique<ExpressionStep>(query_node_plan->getCurrentHeader(), std::move(actions_dag));\n+        converting_step->setStepDescription(\"Conversion before UNION\");\n+        query_node_plan->addStep(std::move(converting_step));\n+\n+        query_plans_headers[i] = query_node_plan->getCurrentHeader();\n+    }\n+}\n+\n ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node)\n {\n     auto & query_node_typed = query_node->as<QueryNode &>();\n@@ -243,16 +269,18 @@ StorageLimits buildStorageLimits(const Context & context, const SelectQueryOptio\n     return {limits, leaf_limits};\n }\n \n-ActionsDAG buildActionsDAGFromExpressionNode(const QueryTreeNodePtr & expression_node,\n+std::pair<ActionsDAG, CorrelatedSubtrees> buildActionsDAGFromExpressionNode(\n+    const QueryTreeNodePtr & expression_node,\n     const ColumnsWithTypeAndName & input_columns,\n-    const PlannerContextPtr & planner_context)\n+    const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set)\n {\n     ActionsDAG action_dag(input_columns);\n-    PlannerActionsVisitor actions_visitor(planner_context);\n-    auto expression_dag_index_nodes = actions_visitor.visit(action_dag, expression_node);\n+    PlannerActionsVisitor actions_visitor(planner_context, correlated_columns_set);\n+    auto [expression_dag_index_nodes, correlated_subtrees] = actions_visitor.visit(action_dag, expression_node);\n     action_dag.getOutputs() = std::move(expression_dag_index_nodes);\n \n-    return action_dag;\n+    return std::make_pair(std::move(action_dag), std::move(correlated_subtrees));\n }\n \n bool sortDescriptionIsPrefix(const SortDescription & prefix, const SortDescription & full)\n@@ -492,8 +520,10 @@ FilterDAGInfo buildFilterInfo(QueryTreeNodePtr filter_query_tree,\n \n     ActionsDAG filter_actions_dag;\n \n-    PlannerActionsVisitor actions_visitor(planner_context, false /*use_column_identifier_as_action_node_name*/);\n-    auto expression_nodes = actions_visitor.visit(filter_actions_dag, filter_query_tree);\n+    ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+    PlannerActionsVisitor actions_visitor(planner_context, empty_correlated_columns_set, false /*use_column_identifier_as_action_node_name*/);\n+    auto [expression_nodes, correlated_subtrees] = actions_visitor.visit(filter_actions_dag, filter_query_tree);\n+    correlated_subtrees.assertEmpty(\"in row-policy and additional table filters\");\n     if (expression_nodes.size() != 1)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n             \"Filter actions must return single output node. Actual {}\",\ndiff --git a/src/Planner/Utils.h b/src/Planner/Utils.h\nindex 5f27114f2e1b..bd7be4b1bd86 100644\n--- a/src/Planner/Utils.h\n+++ b/src/Planner/Utils.h\n@@ -9,6 +9,7 @@\n #include <Interpreters/SelectQueryOptions.h>\n #include <Interpreters/ActionsDAG.h>\n \n+#include <Analyzer/HashUtils.h>\n #include <Analyzer/IQueryTreeNode.h>\n \n #include <Processors/QueryPlan/QueryPlan.h>\n@@ -16,6 +17,7 @@\n #include <QueryPipeline/StreamLocalLimits.h>\n \n #include <Planner/PlannerContext.h>\n+#include <Planner/PlannerCorrelatedSubqueries.h>\n \n #include <Storages/SelectQueryInfo.h>\n \n@@ -33,6 +35,12 @@ String dumpQueryPipeline(const QueryPlan & query_plan);\n /// Build common header for UNION query\n Block buildCommonHeaderForUnion(const Blocks & queries_headers, SelectUnionMode union_mode);\n \n+/// Add converting to common header actions if needed for each plan\n+void addConvertingToCommonHeaderActionsIfNeeded(\n+    std::vector<std::unique_ptr<QueryPlan>> & query_plans,\n+    const Block & union_common_header,\n+    Blocks & query_plans_headers);\n+\n /// Convert query node to ASTSelectQuery\n ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node);\n \n@@ -49,9 +57,11 @@ StorageLimits buildStorageLimits(const Context & context, const SelectQueryOptio\n   * Inputs are not used for actions dag outputs.\n   * Only root query tree expression node is used as actions dag output.\n   */\n-ActionsDAG buildActionsDAGFromExpressionNode(const QueryTreeNodePtr & expression_node,\n+std::pair<ActionsDAG, CorrelatedSubtrees> buildActionsDAGFromExpressionNode(\n+    const QueryTreeNodePtr & expression_node,\n     const ColumnsWithTypeAndName & input_columns,\n-    const PlannerContextPtr & planner_context);\n+    const PlannerContextPtr & planner_context,\n+    const ColumnNodePtrWithHashSet & correlated_columns_set);\n \n /// Returns true if prefix sort description is prefix of full sort descriptor, false otherwise\n bool sortDescriptionIsPrefix(const SortDescription & prefix, const SortDescription & full);\ndiff --git a/src/Processors/QueryPlan/ExpressionStep.cpp b/src/Processors/QueryPlan/ExpressionStep.cpp\nindex e7ef789b901f..d0a00e8c4b91 100644\n--- a/src/Processors/QueryPlan/ExpressionStep.cpp\n+++ b/src/Processors/QueryPlan/ExpressionStep.cpp\n@@ -97,6 +97,11 @@ std::unique_ptr<IQueryPlanStep> ExpressionStep::deserialize(Deserialization & ct\n     return std::make_unique<ExpressionStep>(ctx.input_headers.front(), std::move(actions_dag));\n }\n \n+QueryPlanStepPtr ExpressionStep::clone() const\n+{\n+    return std::make_unique<ExpressionStep>(*this);\n+}\n+\n void registerExpressionStep(QueryPlanStepRegistry & registry)\n {\n     registry.registerStep(\"Expression\", ExpressionStep::deserialize);\ndiff --git a/src/Processors/QueryPlan/ExpressionStep.h b/src/Processors/QueryPlan/ExpressionStep.h\nindex cc9cd0956c24..cc6f1535f402 100644\n--- a/src/Processors/QueryPlan/ExpressionStep.h\n+++ b/src/Processors/QueryPlan/ExpressionStep.h\n@@ -13,6 +13,12 @@ class ExpressionStep : public ITransformingStep\n {\n public:\n     explicit ExpressionStep(const Header & input_header_, ActionsDAG actions_dag_);\n+\n+    ExpressionStep(const ExpressionStep & other)\n+        : ITransformingStep(other)\n+        , actions_dag(other.actions_dag.clone())\n+    {}\n+\n     String getName() const override { return \"Expression\"; }\n \n     void transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings) override;\n@@ -27,7 +33,12 @@ class ExpressionStep : public ITransformingStep\n     void serialize(Serialization & ctx) const override;\n     bool isSerializable() const override { return true; }\n \n-    static std::unique_ptr<IQueryPlanStep> deserialize(Deserialization & ctx);\n+    static QueryPlanStepPtr deserialize(Deserialization & ctx);\n+\n+    QueryPlanStepPtr clone() const override;\n+\n+    bool hasCorrelatedExpressions() const override { return actions_dag.hasCorrelatedColumns(); }\n+    void decorrelateActions() { actions_dag.decorrelate(); }\n \n private:\n     void updateOutputHeader() override;\ndiff --git a/src/Processors/QueryPlan/FilterStep.cpp b/src/Processors/QueryPlan/FilterStep.cpp\nindex 9725d7caec3b..a0f3dc855a1e 100644\n--- a/src/Processors/QueryPlan/FilterStep.cpp\n+++ b/src/Processors/QueryPlan/FilterStep.cpp\n@@ -271,7 +271,7 @@ void FilterStep::serialize(Serialization & ctx) const\n     actions_dag.serialize(ctx.out, ctx.registry);\n }\n \n-std::unique_ptr<IQueryPlanStep> FilterStep::deserialize(Deserialization & ctx)\n+QueryPlanStepPtr FilterStep::deserialize(Deserialization & ctx)\n {\n     if (ctx.input_headers.size() != 1)\n         throw Exception(ErrorCodes::INCORRECT_DATA, \"FilterStep must have one input stream\");\n@@ -289,6 +289,11 @@ std::unique_ptr<IQueryPlanStep> FilterStep::deserialize(Deserialization & ctx)\n     return std::make_unique<FilterStep>(ctx.input_headers.front(), std::move(actions_dag), std::move(filter_column_name), remove_filter_column);\n }\n \n+QueryPlanStepPtr FilterStep::clone() const\n+{\n+    return std::make_unique<FilterStep>(*this);\n+}\n+\n void registerFilterStep(QueryPlanStepRegistry & registry)\n {\n     registry.registerStep(\"Filter\", FilterStep::deserialize);\ndiff --git a/src/Processors/QueryPlan/FilterStep.h b/src/Processors/QueryPlan/FilterStep.h\nindex 23d307c4720e..31115504b240 100644\n--- a/src/Processors/QueryPlan/FilterStep.h\n+++ b/src/Processors/QueryPlan/FilterStep.h\n@@ -15,6 +15,14 @@ class FilterStep : public ITransformingStep\n         String filter_column_name_,\n         bool remove_filter_column_);\n \n+    FilterStep(const FilterStep & other)\n+        : ITransformingStep(other)\n+        , actions_dag(other.actions_dag.clone())\n+        , filter_column_name(other.filter_column_name)\n+        , remove_filter_column(other.remove_filter_column)\n+        , condition(other.condition)\n+    {}\n+\n     String getName() const override { return \"Filter\"; }\n     void transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings) override;\n \n@@ -33,7 +41,12 @@ class FilterStep : public ITransformingStep\n     void serialize(Serialization & ctx) const override;\n     bool isSerializable() const override { return true; }\n \n-    static std::unique_ptr<IQueryPlanStep> deserialize(Deserialization & ctx);\n+    static QueryPlanStepPtr deserialize(Deserialization & ctx);\n+\n+    QueryPlanStepPtr clone() const override;\n+\n+    bool hasCorrelatedExpressions() const override { return actions_dag.hasCorrelatedColumns(); }\n+    void decorrelateActions() { actions_dag.decorrelate(); }\n \n private:\n     void updateOutputHeader() override;\ndiff --git a/src/Processors/QueryPlan/IQueryPlanStep.cpp b/src/Processors/QueryPlan/IQueryPlanStep.cpp\nindex 156f26053053..20527c7f49f6 100644\n--- a/src/Processors/QueryPlan/IQueryPlanStep.cpp\n+++ b/src/Processors/QueryPlan/IQueryPlanStep.cpp\n@@ -37,6 +37,11 @@ void IQueryPlanStep::updateInputHeader(Header input_header, size_t idx)\n     updateOutputHeader();\n }\n \n+bool IQueryPlanStep::hasCorrelatedExpressions() const\n+{\n+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot check {} plan step for correlated expressions\", getName());\n+}\n+\n const Header & IQueryPlanStep::getOutputHeader() const\n {\n     if (!hasOutputHeader())\n@@ -45,6 +50,11 @@ const Header & IQueryPlanStep::getOutputHeader() const\n     return *output_header;\n }\n \n+QueryPlanStepPtr IQueryPlanStep::clone() const\n+{\n+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot clone {} plan step\", getName());\n+}\n+\n const SortDescription & IQueryPlanStep::getSortDescription() const\n {\n     static SortDescription empty;\ndiff --git a/src/Processors/QueryPlan/IQueryPlanStep.h b/src/Processors/QueryPlan/IQueryPlanStep.h\nindex af71f44b9259..cafb8ea44e13 100644\n--- a/src/Processors/QueryPlan/IQueryPlanStep.h\n+++ b/src/Processors/QueryPlan/IQueryPlanStep.h\n@@ -29,12 +29,18 @@ using Headers = std::vector<Header>;\n \n struct ExplainPlanOptions;\n \n+class IQueryPlanStep;\n+using QueryPlanStepPtr = std::unique_ptr<IQueryPlanStep>;\n+\n /// Single step of query plan.\n class IQueryPlanStep\n {\n public:\n     IQueryPlanStep();\n \n+    IQueryPlanStep(const IQueryPlanStep &) = default;\n+    IQueryPlanStep(IQueryPlanStep &&) = default;\n+\n     virtual ~IQueryPlanStep() = default;\n \n     virtual String getName() const = 0;\n@@ -64,6 +70,8 @@ class IQueryPlanStep\n     virtual void serialize(Serialization & /*ctx*/) const;\n     virtual bool isSerializable() const { return false; }\n \n+    virtual QueryPlanStepPtr clone() const;\n+\n     virtual const SortDescription & getSortDescription() const;\n \n     struct FormatSettings\n@@ -103,6 +111,8 @@ class IQueryPlanStep\n     void updateInputHeaders(Headers input_headers_);\n     void updateInputHeader(Header input_header, size_t idx = 0);\n \n+    virtual bool hasCorrelatedExpressions() const;\n+\n protected:\n     virtual void updateOutputHeader() = 0;\n \n@@ -122,5 +132,4 @@ class IQueryPlanStep\n     size_t step_index = 0;\n };\n \n-using QueryPlanStepPtr = std::unique_ptr<IQueryPlanStep>;\n }\ndiff --git a/src/Processors/QueryPlan/ISourceStep.h b/src/Processors/QueryPlan/ISourceStep.h\nindex d1aa900bdbe7..815b30f37680 100644\n--- a/src/Processors/QueryPlan/ISourceStep.h\n+++ b/src/Processors/QueryPlan/ISourceStep.h\n@@ -10,12 +10,17 @@ class ISourceStep : public IQueryPlanStep\n public:\n     explicit ISourceStep(Header output_header_);\n \n+    ISourceStep(const ISourceStep &) = default;\n+    ISourceStep(ISourceStep &&) = default;\n+\n     QueryPipelineBuilderPtr updatePipeline(QueryPipelineBuilders pipelines, const BuildQueryPipelineSettings & settings) override;\n \n     virtual void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings) = 0;\n \n     void describePipeline(FormatSettings & settings) const override;\n \n+    bool hasCorrelatedExpressions() const override { return false; }\n+\n protected:\n     void updateOutputHeader() override {}\n };\ndiff --git a/src/Processors/QueryPlan/ITransformingStep.h b/src/Processors/QueryPlan/ITransformingStep.h\nindex 5c7a03ad5756..9e3ef351e002 100644\n--- a/src/Processors/QueryPlan/ITransformingStep.h\n+++ b/src/Processors/QueryPlan/ITransformingStep.h\n@@ -47,6 +47,7 @@ class ITransformingStep : public IQueryPlanStep\n     };\n \n     ITransformingStep(Header input_header, Header output_header, Traits traits, bool collect_processors_ = true);\n+    ITransformingStep(const ITransformingStep &) = default;\n \n     QueryPipelineBuilderPtr updatePipeline(QueryPipelineBuilders pipelines, const BuildQueryPipelineSettings & settings) override;\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/useDataParallelAggregation.cpp b/src/Processors/QueryPlan/Optimizations/useDataParallelAggregation.cpp\nindex 79c7f8545e88..31dc3ffb5538 100644\n--- a/src/Processors/QueryPlan/Optimizations/useDataParallelAggregation.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/useDataParallelAggregation.cpp\n@@ -12,6 +12,13 @@\n \n using namespace DB;\n \n+namespace DB::ErrorCodes\n+{\n+\n+extern const int LOGICAL_ERROR;\n+\n+}\n+\n namespace\n {\n \n@@ -68,6 +75,8 @@ void removeInjectiveFunctionsFromResultsRecursively(const ActionsDAG::Node * nod\n         case ActionsDAG::ActionType::INPUT:\n             irreducible.insert(node);\n             break;\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"PLACEHOLDER action node must be removed before query plan optimization\");\n     }\n }\n \n@@ -120,6 +129,8 @@ bool allOutputsDependsOnlyOnAllowedNodes(\n                 break;\n             case ActionsDAG::ActionType::INPUT:\n                 break;\n+            case ActionsDAG::ActionType::PLACEHOLDER:\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"PLACEHOLDER action node must be removed before query plan optimization\");\n         }\n     }\n     visited[node] = res;\ndiff --git a/src/Processors/QueryPlan/QueryPlan.cpp b/src/Processors/QueryPlan/QueryPlan.cpp\nindex a1565beee6e5..b2e5e56d2be0 100644\n--- a/src/Processors/QueryPlan/QueryPlan.cpp\n+++ b/src/Processors/QueryPlan/QueryPlan.cpp\n@@ -618,4 +618,82 @@ std::pair<QueryPlan::Nodes, QueryPlanResourceHolder> QueryPlan::detachNodesAndRe\n     return {std::move(plan.nodes), std::move(plan.resources)};\n }\n \n+QueryPlan QueryPlan::extractSubplan(Node * subplan_root)\n+{\n+    std::unordered_set<Node *> used;\n+    std::stack<Node *> stack;\n+\n+    stack.push(subplan_root);\n+    used.insert(subplan_root);\n+    while (!stack.empty())\n+    {\n+        const auto * node = stack.top();\n+        stack.pop();\n+\n+        for (auto * child : node->children)\n+        {\n+            used.insert(child);\n+            stack.push(child);\n+        }\n+    }\n+\n+    QueryPlan new_plan;\n+    new_plan.root = subplan_root;\n+\n+    auto it = nodes.begin();\n+    while (it != nodes.end())\n+    {\n+        auto curr = it;\n+        ++it;\n+\n+        if (used.contains(&*curr))\n+            new_plan.nodes.splice(new_plan.nodes.end(), nodes, curr);\n+    }\n+\n+    return new_plan;\n+}\n+\n+QueryPlan QueryPlan::clone() const\n+{\n+    QueryPlan result;\n+\n+    struct Frame\n+    {\n+        Node * node;\n+        Node * clone;\n+        std::vector<Node *> children = {};\n+    };\n+\n+    result.nodes.emplace_back(Node{ .step = {}, .children = {} });\n+    result.root = &result.nodes.back();\n+\n+    std::vector<Frame> nodes_to_process{ Frame{ .node = root, .clone = result.root } };\n+\n+    while (!nodes_to_process.empty())\n+    {\n+        auto & frame = nodes_to_process.back();\n+        if (frame.children.size() == frame.node->children.size())\n+        {\n+            frame.clone->step = frame.node->step->clone();\n+            frame.clone->children = std::move(frame.children);\n+            nodes_to_process.pop_back();\n+        }\n+        else\n+        {\n+            size_t next_child = frame.children.size();\n+            auto * child = frame.node->children[next_child];\n+\n+            result.nodes.emplace_back(Node{ .step = {} });\n+            result.nodes.back().children.reserve(child->children.size());\n+            auto * child_clone = &result.nodes.back();\n+\n+            frame.children.push_back(child_clone);\n+\n+            nodes_to_process.push_back(Frame{ .node = child, .clone = child_clone });\n+        }\n+    }\n+\n+    return result;\n+}\n+\n }\ndiff --git a/src/Processors/QueryPlan/QueryPlan.h b/src/Processors/QueryPlan/QueryPlan.h\nindex 6e473adbfeb8..3f7598bc2fd6 100644\n--- a/src/Processors/QueryPlan/QueryPlan.h\n+++ b/src/Processors/QueryPlan/QueryPlan.h\n@@ -139,6 +139,9 @@ class QueryPlan\n     Node * getRootNode() const { return root; }\n     static std::pair<Nodes, QueryPlanResourceHolder> detachNodesAndResources(QueryPlan && plan);\n \n+    QueryPlan extractSubplan(Node * subplan_root);\n+    QueryPlan clone() const;\n+\n private:\n     struct SerializationFlags;\n \ndiff --git a/src/Processors/QueryPlan/ReadFromMemoryStorageStep.cpp b/src/Processors/QueryPlan/ReadFromMemoryStorageStep.cpp\nindex cb4342b0fa2c..e51020373162 100644\n--- a/src/Processors/QueryPlan/ReadFromMemoryStorageStep.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMemoryStorageStep.cpp\n@@ -135,6 +135,11 @@ void ReadFromMemoryStorageStep::initializePipeline(QueryPipelineBuilder & pipeli\n     pipeline.init(std::move(pipe));\n }\n \n+QueryPlanStepPtr ReadFromMemoryStorageStep::clone() const\n+{\n+    return std::make_unique<ReadFromMemoryStorageStep>(*this);\n+}\n+\n Pipe ReadFromMemoryStorageStep::makePipe()\n {\n     storage_snapshot->check(columns_to_read);\ndiff --git a/src/Processors/QueryPlan/ReadFromMemoryStorageStep.h b/src/Processors/QueryPlan/ReadFromMemoryStorageStep.h\nindex a9c2d2df2c4d..d56bc899a0d3 100644\n--- a/src/Processors/QueryPlan/ReadFromMemoryStorageStep.h\n+++ b/src/Processors/QueryPlan/ReadFromMemoryStorageStep.h\n@@ -25,16 +25,18 @@ class ReadFromMemoryStorageStep final : public SourceStepWithFilter\n         bool delay_read_for_global_sub_queries_);\n \n     ReadFromMemoryStorageStep() = delete;\n-    ReadFromMemoryStorageStep(const ReadFromMemoryStorageStep &) = delete;\n+    ReadFromMemoryStorageStep(const ReadFromMemoryStorageStep &) = default;\n     ReadFromMemoryStorageStep & operator=(const ReadFromMemoryStorageStep &) = delete;\n \n     ReadFromMemoryStorageStep(ReadFromMemoryStorageStep &&) = default;\n-    ReadFromMemoryStorageStep & operator=(ReadFromMemoryStorageStep &&) = default;\n+    ReadFromMemoryStorageStep & operator=(ReadFromMemoryStorageStep &&) = delete;\n \n     String getName() const override { return name; }\n \n     void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;\n \n+    QueryPlanStepPtr clone() const override;\n+\n     const StoragePtr & getStorage() const { return storage; }\n \n private:\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex f1d5e35ce2db..ae28a6964dbb 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -2249,6 +2249,11 @@ Pipe ReadFromMergeTree::groupStreamsByPartition(AnalysisResult & result, std::op\n     return Pipe::unitePipes(std::move(pipes));\n }\n \n+QueryPlanStepPtr ReadFromMergeTree::clone() const\n+{\n+    return std::make_unique<ReadFromMergeTree>(*this);\n+}\n+\n void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n {\n     auto result = getAnalysisResult();\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h\nindex 65f846651dca..08d03362b2c1 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.h\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h\n@@ -131,6 +131,9 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n         std::optional<MergeTreeReadTaskCallback> read_task_callback_ = std::nullopt,\n         std::optional<size_t> number_of_current_replica_ = std::nullopt);\n \n+    ReadFromMergeTree(const ReadFromMergeTree &) = default;\n+    ReadFromMergeTree(ReadFromMergeTree &&) = default;\n+\n     std::unique_ptr<ReadFromMergeTree> createLocalParallelReplicasReadingStep(\n         AnalysisResultPtr analyzed_result_ptr_,\n         MergeTreeAllRangesCallback all_ranges_callback_,\n@@ -140,6 +143,8 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n     static constexpr auto name = \"ReadFromMergeTree\";\n     String getName() const override { return name; }\n \n+    QueryPlanStepPtr clone() const override;\n+\n     void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;\n \n     void describeActions(FormatSettings & format_settings) const override;\ndiff --git a/src/Processors/QueryPlan/SourceStepWithFilter.h b/src/Processors/QueryPlan/SourceStepWithFilter.h\nindex 4718ad78947f..f681c20791ce 100644\n--- a/src/Processors/QueryPlan/SourceStepWithFilter.h\n+++ b/src/Processors/QueryPlan/SourceStepWithFilter.h\n@@ -19,6 +19,27 @@ class SourceStepWithFilterBase : public ISourceStep\n     {\n     }\n \n+    SourceStepWithFilterBase(const SourceStepWithFilterBase & other)\n+        : ISourceStep(other)\n+        , filter_nodes()\n+        , filter_dags()\n+        , limit(other.limit)\n+        , filter_actions_dag()\n+    {\n+        filter_dags.reserve(other.filter_dags.size());\n+        filter_nodes.nodes.reserve(other.filter_dags.size());\n+\n+        for (size_t i = 0; i < other.filter_dags.size(); ++i)\n+        {\n+            filter_dags.push_back(other.filter_dags[i].clone());\n+            filter_nodes.nodes.push_back(&filter_dags.back().findInOutputs(other.filter_nodes.nodes[i]->result_name));\n+        }\n+\n+        if (other.filter_actions_dag)\n+            filter_actions_dag = other.filter_actions_dag->clone();\n+    }\n+    SourceStepWithFilterBase(SourceStepWithFilterBase &&) = default;\n+\n     void addFilter(ActionsDAG filter_dag, std::string column_name)\n     {\n         filter_nodes.nodes.push_back(&filter_dag.findInOutputs(column_name));\n@@ -46,6 +67,13 @@ class SourceStepWithFilterBase : public ISourceStep\n     const std::optional<ActionsDAG> & getFilterActionsDAG() const { return filter_actions_dag; }\n     std::optional<ActionsDAG> detachFilterActionsDAG() { return std::move(filter_actions_dag); }\n \n+    bool hasCorrelatedExpressions() const override\n+    {\n+        if (filter_actions_dag)\n+            return filter_actions_dag->hasCorrelatedColumns();\n+        return false;\n+    }\n+\n private:\n     /// Will be cleared after applyFilters() is called.\n     ActionDAGNodes filter_nodes;\n@@ -81,6 +109,8 @@ class SourceStepWithFilter : public SourceStepWithFilterBase\n     {\n     }\n \n+    SourceStepWithFilter(const SourceStepWithFilter &) = default;\n+\n     const SelectQueryInfo & getQueryInfo() const { return query_info; }\n     PrewhereInfoPtr getPrewhereInfo() const override { return prewhere_info; }\n     ContextPtr getContext() const { return context; }\ndiff --git a/src/Processors/QueryPlan/UnionStep.h b/src/Processors/QueryPlan/UnionStep.h\nindex e3e340ca0166..0c92b4c29fe6 100644\n--- a/src/Processors/QueryPlan/UnionStep.h\n+++ b/src/Processors/QueryPlan/UnionStep.h\n@@ -24,6 +24,8 @@ class UnionStep : public IQueryPlanStep\n \n     static std::unique_ptr<IQueryPlanStep> deserialize(Deserialization & ctx);\n \n+    bool hasCorrelatedExpressions() const override { return false; }\n+\n private:\n     void updateOutputHeader() override;\n \ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 9599f5f9f9bd..625a61ddb315 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -742,6 +742,13 @@ static const ActionsDAG::Node & cloneDAGWithInversionPushDown(\n                     }\n                 }\n             }\n+            break;\n+        }\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+        {\n+            /// I guess it should work as INPUT.\n+            res = &inverted_dag.addPlaceholder(node.result_name, node.result_type);\n+            break;\n         }\n     }\n \ndiff --git a/src/Storages/MergeTree/RPNBuilder.cpp b/src/Storages/MergeTree/RPNBuilder.cpp\nindex 21abfd8c7869..6a63fe332629 100644\n--- a/src/Storages/MergeTree/RPNBuilder.cpp\n+++ b/src/Storages/MergeTree/RPNBuilder.cpp\n@@ -86,7 +86,11 @@ void appendColumnNameWithoutAlias(const ActionsDAG::Node & node, WriteBuffer & o\n                 appendColumnNameWithoutAlias(*arg, out, allow_experimental_analyzer, legacy);\n             }\n             writeChar(')', out);\n+            break;\n         }\n+        case ActionsDAG::ActionType::PLACEHOLDER:\n+            writeString(node.result_name, out);\n+            break;\n     }\n }\n \ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex cad8e2a52efb..e7fcd63fb7c0 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -997,7 +997,8 @@ SelectQueryInfo ReadFromMerge::getModifiedQueryInfo(const ContextMutablePtr & mo\n                     column_node = std::make_shared<ColumnNode>(NameAndTypePair{column, storage_columns.getColumn(get_column_options, column).type }, modified_query_info.table_expression);\n                 }\n \n-                PlannerActionsVisitor actions_visitor(modified_query_info.planner_context, false /*use_column_identifier_as_action_node_name*/);\n+                ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+                PlannerActionsVisitor actions_visitor(modified_query_info.planner_context, empty_correlated_columns_set, false /*use_column_identifier_as_action_node_name*/);\n                 actions_visitor.visit(*filter_actions_dag, column_node);\n             }\n             column_names_as_aliases = filter_actions_dag->getRequiredColumnsNames();\n@@ -1495,8 +1496,9 @@ void ReadFromMerge::convertAndFilterSourceStream(\n             QueryAnalysisPass query_analysis_pass(modified_query_info.table_expression);\n             query_analysis_pass.run(query_tree, local_context);\n \n-            PlannerActionsVisitor actions_visitor(modified_query_info.planner_context, false /*use_column_identifier_as_action_node_name*/);\n-            const auto & nodes = actions_visitor.visit(actions_dag, query_tree);\n+            ColumnNodePtrWithHashSet empty_correlated_columns_set;\n+            PlannerActionsVisitor actions_visitor(modified_query_info.planner_context, empty_correlated_columns_set, false /*use_column_identifier_as_action_node_name*/);\n+            const auto & [nodes, _] = actions_visitor.visit(actions_dag, query_tree);\n \n             if (nodes.size() != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected to have 1 output but got {}\", nodes.size());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.reference b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.reference\nnew file mode 100644\nindex 000000000000..51314d9bc697\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.reference\n@@ -0,0 +1,68 @@\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    number UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: number, result_type: UInt64, source_id: 3\n+  JOIN TREE\n+    TABLE_FUNCTION id: 3, alias: __table1, table_function_name: numbers\n+      ARGUMENTS\n+        LIST id: 4, nodes: 1\n+          CONSTANT id: 5, constant_value: UInt64_2, constant_value_type: UInt8\n+  WHERE\n+    FUNCTION id: 6, function_name: exists, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 7, nodes: 1\n+          QUERY id: 8, alias: __table2, is_subquery: 1, is_correlated: 1\n+            CORRELATED COLUMNS\n+              LIST id: 9, nodes: 1\n+                COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+            PROJECTION COLUMNS\n+              count() UInt64\n+            PROJECTION\n+              LIST id: 11, nodes: 1\n+                FUNCTION id: 12, function_name: count, function_type: aggregate, result_type: UInt64\n+            JOIN TREE\n+              TABLE id: 13, alias: __table3, table_name: system.one\n+            WHERE\n+              FUNCTION id: 14, function_name: equals, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 15, nodes: 2\n+                    COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+                    CONSTANT id: 16, constant_value: UInt64_2, constant_value_type: UInt8\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    number UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: number, result_type: UInt64, source_id: 3\n+  JOIN TREE\n+    TABLE_FUNCTION id: 3, alias: __table1, table_function_name: numbers\n+      ARGUMENTS\n+        LIST id: 4, nodes: 1\n+          CONSTANT id: 5, constant_value: UInt64_2, constant_value_type: UInt8\n+  WHERE\n+    FUNCTION id: 6, function_name: exists, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 7, nodes: 1\n+          QUERY id: 8, alias: __table2, is_subquery: 1, is_correlated: 1\n+            CORRELATED COLUMNS\n+              LIST id: 9, nodes: 1\n+                COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+            PROJECTION COLUMNS\n+              1 UInt8\n+              dummy UInt8\n+              1 UInt8\n+            PROJECTION\n+              LIST id: 11, nodes: 3\n+                CONSTANT id: 12, constant_value: UInt64_1, constant_value_type: UInt8\n+                COLUMN id: 13, column_name: dummy, result_type: UInt8, source_id: 14\n+                CONSTANT id: 15, constant_value: UInt64_1, constant_value_type: UInt8\n+            JOIN TREE\n+              TABLE id: 14, alias: __table3, table_name: system.one\n+            WHERE\n+              FUNCTION id: 16, function_name: equals, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 17, nodes: 2\n+                    COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+                    CONSTANT id: 18, constant_value: UInt64_2, constant_value_type: UInt8\ndiff --git a/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.sql b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.sql\nnew file mode 100644\nindex 000000000000..30ee0a5290d9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.sql\n@@ -0,0 +1,21 @@\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+EXPLAIN QUERY TREE\n+SELECT *\n+FROM numbers(2)\n+WHERE exists((\n+    SELECT count()\n+    WHERE number = 2\n+));\n+\n+EXPLAIN QUERY TREE\n+SELECT *\n+FROM numbers(2)\n+WHERE exists((\n+    SELECT\n+        1,\n+        dummy,\n+        1\n+    WHERE number = 2\n+));\ndiff --git a/tests/queries/0_stateless/03399_analyzer_correlated_subquery.reference b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.reference\nnew file mode 100644\nindex 000000000000..46193b43bc61\n--- /dev/null\n+++ b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.reference\n@@ -0,0 +1,34 @@\n+-- { echoOn }\n+\n+SET allow_experimental_correlated_subqueries = 1;\n+SELECT * FROM users u1\n+WHERE EXISTS (\n+  SELECT * FROM users2 u2\n+  WHERE u1.age = u2.age\n+);\n+1231\tJohn\t33\n+SELECT *\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+))\n+ORDER BY ALL\n+SETTINGS allow_experimental_correlated_subqueries = 1;\n+1231\tJohn\t33\n+8888\tAlice\t50\n+SELECT *\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+    UNION ALL\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age != u2.age\n+))\n+ORDER BY ALL\n+FORMAT Null\n+SETTINGS allow_experimental_correlated_subqueries = 1;\ndiff --git a/tests/queries/0_stateless/03399_analyzer_correlated_subquery.sql b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.sql\nnew file mode 100644\nindex 000000000000..d2855b12efd1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.sql\n@@ -0,0 +1,48 @@\n+set enable_analyzer = 1;\n+\n+DROP TABLE IF EXISTS users;\n+CREATE TABLE users (uid Int16, name String, age Int16) ENGINE=Memory;\n+\n+INSERT INTO users VALUES (1231, 'John', 33);\n+INSERT INTO users VALUES (6666, 'Ksenia', 48);\n+INSERT INTO users VALUES (8888, 'Alice', 50);\n+\n+DROP TABLE IF EXISTS users2;\n+CREATE TABLE users2 (uid Int16, name String, age Int16) ENGINE=Memory;\n+\n+INSERT INTO users2 VALUES (1231, 'John', 33);\n+\n+-- { echoOn }\n+\n+SET allow_experimental_correlated_subqueries = 1;\n+\n+SELECT * FROM users u1\n+WHERE EXISTS (\n+  SELECT * FROM users2 u2\n+  WHERE u1.age = u2.age\n+);\n+\n+SELECT *\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+))\n+ORDER BY ALL\n+SETTINGS allow_experimental_correlated_subqueries = 1;\n+\n+SELECT *\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+    UNION ALL\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age != u2.age\n+))\n+ORDER BY ALL\n+FORMAT Null\n+SETTINGS allow_experimental_correlated_subqueries = 1;\ndiff --git a/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.reference b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.reference\nnew file mode 100644\nindex 000000000000..d28ce75e85a3\n--- /dev/null\n+++ b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.reference\n@@ -0,0 +1,21 @@\n+-- { echoOn }\n+\n+SET allow_experimental_correlated_subqueries = 1;\n+SELECT name FROM users u1\n+WHERE EXISTS (\n+  SELECT * FROM users2 u2\n+  WHERE u1.age = u2.age\n+);\n+John\n+SELECT name\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+))\n+ORDER BY ALL\n+SETTINGS allow_experimental_correlated_subqueries = 1\n+\n+Alice\n+John\ndiff --git a/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.sql b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.sql\nnew file mode 100644\nindex 000000000000..900f340ddd35\n--- /dev/null\n+++ b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.sql\n@@ -0,0 +1,35 @@\n+set enable_analyzer = 1;\n+\n+DROP TABLE IF EXISTS users;\n+CREATE TABLE users (uid Int16, name String, age Int16) ENGINE=MergeTree() ORDER BY uid;\n+\n+INSERT INTO users VALUES (1231, 'John', 33);\n+INSERT INTO users VALUES (6666, 'Ksenia', 48);\n+INSERT INTO users VALUES (8888, 'Alice', 50);\n+\n+DROP TABLE IF EXISTS users2;\n+CREATE TABLE users2 (uid Int16, name String, age Int16) ENGINE=MergeTree() ORDER BY uid;\n+\n+INSERT INTO users2 VALUES (1231, 'John', 33);\n+\n+SET enable_parallel_replicas = 0;\n+\n+-- { echoOn }\n+\n+SET allow_experimental_correlated_subqueries = 1;\n+\n+SELECT name FROM users u1\n+WHERE EXISTS (\n+  SELECT * FROM users2 u2\n+  WHERE u1.age = u2.age\n+);\n+\n+SELECT name\n+FROM users AS u1\n+WHERE (age = 50) OR exists((\n+    SELECT *\n+    FROM users2 AS u2\n+    WHERE u1.age = u2.age\n+))\n+ORDER BY ALL\n+SETTINGS allow_experimental_correlated_subqueries = 1\ndiff --git a/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.reference b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.reference\nnew file mode 100644\nindex 000000000000..2283978aa474\n--- /dev/null\n+++ b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.reference\n@@ -0,0 +1,22 @@\n+-- { echoOn }\n+\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND EXISTS (SELECT * FROM t2 WHERE t1.c1 = t2.c1);\n+0\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND t1.c1 IN (SELECT c1 FROM t2);\n+0\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND NOT EXISTS (SELECT * FROM t2 WHERE t1.c1 = t2.c1);\n+1\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND t1.c1 NOT IN (SELECT c1 FROM t2);\n+1\ndiff --git a/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.sql b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.sql\nnew file mode 100644\nindex 000000000000..14ed06c531a8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.sql\n@@ -0,0 +1,34 @@\n+-- https://github.com/ClickHouse/ClickHouse/issues/72459\n+\n+CREATE TABLE t1 (c1 UInt64, c2 UInt64) ORDER BY c1;\n+CREATE TABLE t2 (c1 UInt64) ORDER BY c1;\n+\n+INSERT INTO t1 SELECT number, number % 100 FROM numbers(100);\n+INSERT INTO t2 SELECT number*number FROM numbers(100);\n+\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+SET enable_parallel_replicas = 0;\n+\n+-- { echoOn }\n+\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND EXISTS (SELECT * FROM t2 WHERE t1.c1 = t2.c1);\n+\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND t1.c1 IN (SELECT c1 FROM t2);\n+\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND NOT EXISTS (SELECT * FROM t2 WHERE t1.c1 = t2.c1);\n+\n+SELECT count(t1.c1) FROM t1\n+WHERE\n+t1.c2 = 10\n+AND t1.c1 NOT IN (SELECT c1 FROM t2);\ndiff --git a/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.reference b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.reference\nnew file mode 100644\nindex 000000000000..94ac2cb54942\n--- /dev/null\n+++ b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.reference\n@@ -0,0 +1,4 @@\n+0\n+--\n+0\n+1\ndiff --git a/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.sql b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.sql\nnew file mode 100644\nindex 000000000000..3dae41c025d1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.sql\n@@ -0,0 +1,32 @@\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+create table mem2 engine = Memory as select number from numbers(2);\n+\n+SELECT number\n+FROM mem2 AS tbl\n+WHERE exists((\n+    SELECT number\n+    FROM numbers(1)\n+    WHERE number >= tbl.number\n+));\n+\n+SELECT '--';\n+\n+SELECT number\n+FROM mem2 AS tbl\n+WHERE exists((\n+    SELECT number\n+    FROM numbers(2)\n+    WHERE number >= tbl.number\n+));\n+\n+SELECT number\n+FROM mem2 AS tbl\n+WHERE length(arrayFilter(x -> (x OR exists((\n+    SELECT number\n+    FROM numbers(1)\n+    WHERE number >= tbl.number\n+))), range(number))) > 0;\n+\n+SELECT number FROM mem2 AS tbl INNER JOIN (SELECT number FROM numbers(1) WHERE tbl.number >= number) AS alias4 ON alias4.number = number; -- { serverError NOT_IMPLEMENTED}\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.reference b/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.sql b/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.sql\nnew file mode 100644\nindex 000000000000..8b4a07805945\n--- /dev/null\n+++ b/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.sql\n@@ -0,0 +1,57 @@\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+SET enable_parallel_replicas = 0;\n+\n+CREATE TABLE orders  (\n+    o_orderkey       Int32,\n+    o_custkey        Int32,\n+    o_orderstatus    String,\n+    o_totalprice     Decimal(15,2),\n+    o_orderdate      Date,\n+    o_orderpriority  String,\n+    o_clerk          String,\n+    o_shippriority   Int32,\n+    o_comment        String)\n+ORDER BY (o_orderkey);\n+\n+INSERT INTO orders SELECT * FROM generateRandom() LIMIT 10;\n+\n+CREATE TABLE lineitem (\n+    l_orderkey       Int32,\n+    l_partkey        Int32,\n+    l_suppkey        Int32,\n+    l_linenumber     Int32,\n+    l_quantity       Decimal(15,2),\n+    l_extendedprice  Decimal(15,2),\n+    l_discount       Decimal(15,2),\n+    l_tax            Decimal(15,2),\n+    l_returnflag     String,\n+    l_linestatus     String,\n+    l_shipdate       Date,\n+    l_commitdate     Date,\n+    l_receiptdate    Date,\n+    l_shipinstruct   String,\n+    l_shipmode       String,\n+    l_comment        String)\n+ORDER BY (l_orderkey, l_linenumber);\n+\n+SELECT\n+    o_orderpriority,\n+    count(*) AS order_count\n+FROM\n+(\n+    SELECT\n+        o_orderpriority,\n+        o_orderkey\n+    FROM orders\n+    WHERE (o_orderdate >= toDate('1993-07-01')) AND (o_orderdate < (toDate('1993-07-01') + toIntervalMonth('3')))\n+)\n+WHERE exists((\n+    SELECT l_orderkey\n+    FROM lineitem\n+    WHERE (l_orderkey = o_orderkey) AND (l_commitdate < l_receiptdate)\n+))\n+GROUP BY o_orderpriority\n+ORDER BY o_orderpriority ASC\n+FORMAT Null;\ndiff --git a/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.reference b/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.sql b/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.sql\nnew file mode 100644\nindex 000000000000..31e728eea06f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.sql\n@@ -0,0 +1,14 @@\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+SELECT count()\n+FROM numbers(3) AS t\n+WHERE 1 IN (\n+    SELECT 1\n+    FROM numbers(3)\n+    WHERE number = t.number\n+); -- { serverError NOT_IMPLEMENTED }\n+\n+SELECT count()\n+FROM numbers(3) AS t\n+WHERE (SELECT count() FROM numbers(3) WHERE number = t.number) IN (1); -- { serverError NOT_IMPLEMENTED }\n",
  "problem_statement": "[Correlated subqueries] (NOT) EXISTS in other table\n## Example schemas\n\n``` sql\nCREATE TABLE t1 (c1 UInt64, c2 UInt64) ORDER BY c1;\nCREATE TABLE t2 (c1 UInt64) ORDER BY c1;\n\nINSERT INTO t1 SELECT number, number % 100 FROM numbers(1_000_000);\nINSERT INTO t2 SELECT number*number FROM numbers(1_000_000);\n```\n\n## EXISTS\n\nQuery to rewrite\n\n``` sql\nSELECT count(t1.c1)\nFROM t1\nWHERE t1.c2 = 10\n    AND EXISTS (\n        SELECT * FROM t2 WHERE t1.c1 = t2.c1)\n```\n\nCan be rewritten via IN + subquery\n\n``` sql\nSELECT count(t1.c1)\nFROM t1\nWHERE t1.c2 = 10 AND t1.c1 IN (SELECT c1 FROM t2)\n```\n\n## NOT EXISTS\n\nSame for NOT EXISTS\n\n``` sql\nSELECT count(t1.c1)\nFROM t1\nWHERE t1.c2 = 10 AND NOT EXISTS (SELECT * FROM t2 WHERE t1.c1 = t2.c1)\n```\n\nCan be rewritten via NOT IN + subquery\n``` sql\nSELECT count(t1.c1)\nFROM t1\nWHERE t1.c2 = 10 AND t1.c1 NOT IN (SELECT c1 FROM t2)\n```\n\nhttps://fiddle.clickhouse.com/70cb2e57-f0ba-430f-823c-418559cc3c1c\n",
  "hints_text": "Related to #6697",
  "created_at": "2025-02-13T15:53:01Z",
  "modified_files": [
    "src/Analyzer/HashUtils.h",
    "src/Analyzer/IQueryTreeNode.h",
    "src/Analyzer/Passes/RemoveUnusedProjectionColumnsPass.cpp",
    "src/Analyzer/QueryNode.cpp",
    "src/Analyzer/QueryNode.h",
    "src/Analyzer/QueryTreePassManager.cpp",
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Analyzer/TableNode.cpp",
    "src/Analyzer/UnionNode.cpp",
    "src/Analyzer/UnionNode.h",
    "src/Analyzer/Utils.cpp",
    "src/Analyzer/Utils.h",
    "src/Core/Settings.cpp",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Databases/enableAllExperimentalSettings.cpp",
    "b/src/Functions/exists.h",
    "src/Interpreters/ActionsDAG.cpp",
    "src/Interpreters/ActionsDAG.h",
    "src/Interpreters/ExpressionActions.cpp",
    "src/Interpreters/evaluateConstantExpression.cpp",
    "src/Planner/CollectTableExpressionData.cpp",
    "src/Planner/Planner.cpp",
    "src/Planner/PlannerActionsVisitor.cpp",
    "src/Planner/PlannerActionsVisitor.h",
    "src/Planner/PlannerContext.cpp",
    "src/Planner/PlannerContext.h",
    "b/src/Planner/PlannerCorrelatedSubqueries.cpp",
    "b/src/Planner/PlannerCorrelatedSubqueries.h",
    "src/Planner/PlannerExpressionAnalysis.cpp",
    "src/Planner/PlannerExpressionAnalysis.h",
    "src/Planner/PlannerJoinTree.cpp",
    "src/Planner/PlannerJoins.cpp",
    "src/Planner/PlannerJoinsLogical.cpp",
    "src/Planner/Utils.cpp",
    "src/Planner/Utils.h",
    "src/Processors/QueryPlan/ExpressionStep.cpp",
    "src/Processors/QueryPlan/ExpressionStep.h",
    "src/Processors/QueryPlan/FilterStep.cpp",
    "src/Processors/QueryPlan/FilterStep.h",
    "src/Processors/QueryPlan/IQueryPlanStep.cpp",
    "src/Processors/QueryPlan/IQueryPlanStep.h",
    "src/Processors/QueryPlan/ISourceStep.h",
    "src/Processors/QueryPlan/ITransformingStep.h",
    "src/Processors/QueryPlan/Optimizations/useDataParallelAggregation.cpp",
    "src/Processors/QueryPlan/QueryPlan.cpp",
    "src/Processors/QueryPlan/QueryPlan.h",
    "src/Processors/QueryPlan/ReadFromMemoryStorageStep.cpp",
    "src/Processors/QueryPlan/ReadFromMemoryStorageStep.h",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.h",
    "src/Processors/QueryPlan/SourceStepWithFilter.h",
    "src/Processors/QueryPlan/UnionStep.h",
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/RPNBuilder.cpp",
    "src/Storages/StorageMerge.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.reference",
    "b/tests/queries/0_stateless/03315_analyzer_correlated_subqueries.sql",
    "b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.reference",
    "b/tests/queries/0_stateless/03399_analyzer_correlated_subquery.sql",
    "b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.reference",
    "b/tests/queries/0_stateless/03400_analyzer_correlated_subquery_unused_column.sql",
    "b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.reference",
    "b/tests/queries/0_stateless/03408_analyzer_correlated_subquery_simple.sql",
    "b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.reference",
    "b/tests/queries/0_stateless/03412_analyzer_correlated_subquery_bug.sql",
    "b/tests/queries/0_stateless/03413_analyzer_correlated_subqueries_bug_2.sql",
    "b/tests/queries/0_stateless/03414_analyzer_correlated_subqueries_in_function.sql"
  ]
}