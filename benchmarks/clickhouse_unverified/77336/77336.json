{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 77336,
  "instance_id": "ClickHouse__ClickHouse-77336",
  "issue_numbers": [
    "67137"
  ],
  "base_commit": "ed29142efe87a4d9eb4aa512d1c97a8070e26c4e",
  "patch": "diff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex 32ce81d1af62..079b12507bc1 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -226,13 +226,16 @@ void HTTPHandler::processQuery(\n     /// The user could specify session identifier and session timeout.\n     /// It allows to modify settings, create temporary tables and reuse them in subsequent requests.\n \n-    SCOPE_EXIT({ session->releaseSessionID(); });\n-\n     String session_id;\n     std::chrono::steady_clock::duration session_timeout;\n     bool session_is_set = params.has(\"session_id\");\n     const auto & config = server.config();\n \n+    /// Close http session (if any) after processing the request\n+    bool close_session = false;\n+    if (params.getParsed<bool>(\"close_session\", false) && server.config().getBool(\"enable_http_close_session\", true))\n+        close_session = true;\n+\n     if (session_is_set)\n     {\n         session_id = params.get(\"session_id\");\n@@ -242,10 +245,20 @@ void HTTPHandler::processQuery(\n     }\n     else\n     {\n+        session_id = \"\";\n         /// We should create it even if we don't have a session_id\n         session->makeSessionContext();\n     }\n \n+    /// We need to have both releasing/closing a session here and below. The problem with having it only as a SCOPE_EXIT\n+    /// is that it will be invoked after finalizing the buffer in the end of processQuery, and that technically means that\n+    /// the client has received all the data, but the session is not released yet. And it can (and sometimes does) happen\n+    /// that we'll try to acquire the same session in another request before releasing the session here, and the session for\n+    /// the following request will be technically locked, while it shouldn't be.\n+    /// Also, SCOPE_EXIT is still needed to release a session in case of any exception. If the exception occurs at some point\n+    /// after releasing the session below, this whole call will be no-op (due to named_session being nullptr already inside a session).\n+    SCOPE_EXIT_SAFE({ releaseOrCloseSession(session_id, close_session); });\n+\n     auto context = session->makeQueryContext();\n \n     /// This parameter is used to tune the behavior of output formats (such as Native) for compatibility.\n@@ -523,7 +536,7 @@ void HTTPHandler::processQuery(\n             response.set(name, value);\n     };\n \n-    auto handle_exception_in_output_format = [&](IOutputFormat & current_output_format,\n+    auto handle_exception_in_output_format = [&, session_id, close_session](IOutputFormat & current_output_format,\n                                                  const String & format_name,\n                                                  const ContextPtr & context_,\n                                                  const std::optional<FormatSettings> & format_settings)\n@@ -537,7 +550,7 @@ void HTTPHandler::processQuery(\n             if (buffer_until_eof)\n             {\n                 auto header = current_output_format.getPort(IOutputFormat::PortKind::Main).getHeader();\n-                used_output.exception_writer = [&, format_name, header, context_, format_settings](WriteBuffer & buf, int code, const String & message)\n+                used_output.exception_writer = [&, format_name, header, context_, format_settings, session_id, close_session](WriteBuffer & buf, int code, const String & message)\n                 {\n                     if (used_output.out_holder->isCanceled())\n                     {\n@@ -551,6 +564,7 @@ void HTTPHandler::processQuery(\n                     auto output_format = FormatFactory::instance().getOutputFormat(format_name, buf, header, context_, format_settings);\n                     output_format->setException(message);\n                     output_format->finalize();\n+                    releaseOrCloseSession(session_id, close_session);\n                     used_output.finalize();\n                     used_output.exception_is_written = true;\n                 };\n@@ -567,6 +581,7 @@ void HTTPHandler::processQuery(\n                 used_output.out_holder->setExceptionCode(status.code);\n                 current_output_format.setException(status.message);\n                 current_output_format.finalize();\n+                releaseOrCloseSession(session_id, close_session);\n                 used_output.finalize();\n                 used_output.exception_is_written = true;\n             }\n@@ -583,7 +598,7 @@ void HTTPHandler::processQuery(\n         {},\n         handle_exception_in_output_format);\n \n-    session->releaseSessionID();\n+    releaseOrCloseSession(session_id, close_session);\n \n     if (used_output.hasDelayed())\n     {\n@@ -666,14 +681,6 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n \n     /// In case of exception, send stack trace to client.\n     bool with_stacktrace = false;\n-    /// Close http session (if any) after processing the request\n-    bool close_session = false;\n-    String session_id;\n-\n-    SCOPE_EXIT_SAFE({\n-        if (close_session && !session_id.empty())\n-            session->closeSession(session_id);\n-    });\n \n     OpenTelemetry::TracingContextHolderPtr thread_trace_context;\n     SCOPE_EXIT({\n@@ -731,12 +738,6 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n         if (params.getParsed<bool>(\"stacktrace\", false) && server.config().getBool(\"enable_http_stacktrace\", true))\n             with_stacktrace = true;\n \n-        if (params.getParsed<bool>(\"close_session\", false) && server.config().getBool(\"enable_http_close_session\", true))\n-            close_session = true;\n-\n-        if (close_session)\n-            session_id = params.get(\"session_id\");\n-\n         /// FIXME: maybe this check is already unnecessary.\n         /// Workaround. Poco does not detect 411 Length Required case.\n         if (request.getMethod() == HTTPRequest::HTTP_POST && !request.getChunkedTransferEncoding() && !request.hasContentLength())\n@@ -773,11 +774,18 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n \n         if (thread_trace_context)\n             thread_trace_context->root_span.addAttribute(status);\n-\n-        return;\n     }\n+}\n \n-    used_output.finalize();\n+void HTTPHandler::releaseOrCloseSession(const String & session_id, bool close_session)\n+{\n+    if (!session_id.empty())\n+    {\n+        if (close_session)\n+            session->closeSession(session_id);\n+        else\n+            session->releaseSessionID();\n+    }\n }\n \n DynamicQueryHandler::DynamicQueryHandler(\ndiff --git a/src/Server/HTTPHandler.h b/src/Server/HTTPHandler.h\nindex ec1322b8d8b8..85a9ad271453 100644\n--- a/src/Server/HTTPHandler.h\n+++ b/src/Server/HTTPHandler.h\n@@ -184,6 +184,8 @@ class HTTPHandler : public HTTPRequestHandler\n         HTTPServerResponse & response,\n         Output & used_output);\n \n+    void releaseOrCloseSession(const String & session_id, bool close_session);\n+\n     static void pushDelayedResults(Output & used_output);\n \n protected:\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.reference b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.reference\nnew file mode 100644\nindex 000000000000..fcc14aba97f6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.reference\n@@ -0,0 +1,4 @@\n+3373\t1\n+0\n+10\t0\n+0\ndiff --git a/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.sh b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.sh\nnew file mode 100755\nindex 000000000000..7cfe9e2c2e01\n--- /dev/null\n+++ b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.sh\n@@ -0,0 +1,35 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+export DATA_FILE=\"$CLICKHOUSE_TMP/03373_session_test.tsv\"\n+export SESSION=\"03373_session_${CLICKHOUSE_DATABASE}\"\n+export TABLE_NAME=\"03373_session_test\"\n+export SESSION_ID=\"${SESSION}_$RANDOM.$RANDOM\"\n+export SETTINGS=\"session_id=$SESSION_ID&session_timeout=3&throw_on_unsupported_query_inside_transaction=0\"\n+\n+$CLICKHOUSE_CLIENT -q 'select * from numbers(1000000) format TSV' > $DATA_FILE\n+$CLICKHOUSE_CLIENT -q \"create table $TABLE_NAME (A Int64) Engine = MergeTree order by sin(A) partition by intDiv(A, 100000)\"\n+\n+# set a setting to distinguish newly created named session from a reused one\n+$CLICKHOUSE_CURL -sS -d 'set http_max_tries=3373' \"$CLICKHOUSE_URL&$SETTINGS\"\n+$CLICKHOUSE_CURL -sS -d \"select value, changed from system.settings where name = 'http_max_tries'\" \"$CLICKHOUSE_URL&$SETTINGS\"\n+\n+$CLICKHOUSE_CURL -sS -d 'begin transaction' \"$CLICKHOUSE_URL&$SETTINGS\"\n+$CLICKHOUSE_CURL -sS -d 'commit' \"$CLICKHOUSE_URL&$SETTINGS&close_session=1\"\n+\n+$CLICKHOUSE_CURL -sS -X POST --data-binary @- \"$CLICKHOUSE_URL&$SETTINGS&session_check=1&query=insert+into+$TABLE_NAME+format+TSV\" < $DATA_FILE 2>&1 | (grep -Faq \"SESSION_NOT_FOUND\" || echo \"Expected SESSION_NOT_FOUND error\")\n+$CLICKHOUSE_CLIENT --implicit_transaction=1 -q \"select throwIf(count() != 0) from $TABLE_NAME\" \\\n+  || $CLICKHOUSE_CLIENT -q \"select name, rows, active, visible, creation_tid, creation_csn from system.parts where database=currentDatabase()\"\n+\n+# sleep a bit more than a session timeout (3) to make sure there's enough time to close it using close time buckets\n+sleep 5\n+\n+$CLICKHOUSE_CURL -sS -d \"select value, changed from system.settings where name = 'http_max_tries'\" \"$CLICKHOUSE_URL&$SETTINGS\"\n+$CLICKHOUSE_CURL -sS -X POST --data-binary @- \"$CLICKHOUSE_URL&$SETTINGS&query=insert+into+$TABLE_NAME+format+TSV\" < $DATA_FILE\n+$CLICKHOUSE_CLIENT --implicit_transaction=1 -q \"select throwIf(count() != 1000000) from $TABLE_NAME\" \\\n+  || $CLICKHOUSE_CLIENT -q \"select name, rows, active, visible, creation_tid, creation_csn from system.parts where database=currentDatabase()\"\n+\n+$CLICKHOUSE_CLIENT -q \"drop table $TABLE_NAME\"\n",
  "problem_statement": "Test `02435_rollback_cancelled_queries` has failed\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/ac514a5103823571168ce21c387d7604c740ae58/stateless_tests__asan__[2_2].html\n",
  "hints_text": "Another one: https://s3.amazonaws.com/clickhouse-test-reports/67941/6061f01dc0fabd8d737a7d5e13b3828f2b9c0ab7/stateless_tests_flaky_check__asan_.html. Same error\nStill occurs from time to time :-(\n\nhttps://play.clickhouse.com/play?user=play#U0VMRUNUIHB1bGxfcmVxdWVzdF9udW1iZXIgYXMgcHIsIGNoZWNrX3N0YXJ0X3RpbWUsIGNoZWNrX25hbWUsIHRlc3RfbmFtZSwgdGVzdF9zdGF0dXMsIHJlcG9ydF91cmwKRlJPTSBjaGVja3MKV0hFUkUgMQogICAgLS0gQU5EIHB1bGxfcmVxdWVzdF9udW1iZXIgPSAwCiAgICBBTkQgdGVzdF9zdGF0dXMgSU4gKCdGQUlMJywgJ0VSUk9SJywgJ0JST0tFTicpCiAgICBBTkQgdG9EYXRlKGNoZWNrX3N0YXJ0X3RpbWUpID4gJzIwMjQtMDYtMDEnCiAgICBBTkQgdGVzdF9uYW1lIGxpa2UgJyUwMjQzNV9yb2xsYmFja19jYW5jZWxsZWRfcXVlcmllcyUnCk9SREVSIEJZIGNoZWNrX3N0YXJ0X3RpbWUgREVTQwoK",
  "created_at": "2025-03-08T00:36:38Z",
  "modified_files": [
    "src/Server/HTTPHandler.cpp",
    "src/Server/HTTPHandler.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.reference",
    "b/tests/queries/0_stateless/03373_named_session_try_recreate_before_timeout.sh"
  ]
}