{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11592,
  "instance_id": "ClickHouse__ClickHouse-11592",
  "issue_numbers": [
    "11432"
  ],
  "base_commit": "cbc08bc393867cc4baec31f240616bed7c26e60a",
  "patch": "diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 1886d0fc5550..364c9d50c485 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -122,7 +122,12 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)\n     return statement_stream.str();\n }\n \n-DatabaseOnDisk::DatabaseOnDisk(const String & name, const String & metadata_path_, const String & data_path_, const String & logger, const Context & context)\n+DatabaseOnDisk::DatabaseOnDisk(\n+    const String & name,\n+    const String & metadata_path_,\n+    const String & data_path_,\n+    const String & logger,\n+    const Context & context)\n     : DatabaseWithOwnTablesBase(name, logger, context)\n     , metadata_path(metadata_path_)\n     , data_path(data_path_)\n@@ -154,7 +159,6 @@ void DatabaseOnDisk::createTable(\n     /// A race condition would be possible if a table with the same name is simultaneously created using CREATE and using ATTACH.\n     /// But there is protection from it - see using DDLGuard in InterpreterCreateQuery.\n \n-\n     if (isDictionaryExist(table_name))\n         throw Exception(\"Dictionary \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" already exists.\",\n             ErrorCodes::DICTIONARY_ALREADY_EXISTS);\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex b399584f4d95..023e67ec3de0 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -152,7 +152,8 @@ MergeTreeData::MergeTreeData(\n \n     if (metadata.sample_by_ast != nullptr)\n     {\n-        StorageMetadataKeyField candidate_sampling_key = StorageMetadataKeyField::getKeyFromAST(metadata.sample_by_ast, getColumns(), global_context);\n+        StorageMetadataKeyField candidate_sampling_key = StorageMetadataKeyField::getKeyFromAST(\n+            metadata.sample_by_ast, getColumns(), global_context);\n \n         const auto & pk_sample_block = getPrimaryKey().sample_block;\n         if (!pk_sample_block.has(candidate_sampling_key.column_names[0]) && !attach\n@@ -1304,6 +1305,24 @@ void MergeTreeData::dropAllData()\n     LOG_TRACE(log, \"dropAllData: done.\");\n }\n \n+void MergeTreeData::dropIfEmpty()\n+{\n+    LOG_TRACE(log, \"dropIfEmpty\");\n+\n+    auto lock = lockParts();\n+\n+    if (!data_parts_by_info.empty())\n+        return;\n+\n+    for (const auto & [path, disk] : getRelativeDataPathsWithDisks())\n+    {\n+        /// Non recursive, exception is thrown if there are more files.\n+        disk->remove(path + \"format_version.txt\");\n+        disk->remove(path + \"detached\");\n+        disk->remove(path);\n+    }\n+}\n+\n namespace\n {\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 6df181e3f98b..217e5000cf61 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -485,6 +485,9 @@ class MergeTreeData : public IStorage\n     /// Deletes the data directory and flushes the uncompressed blocks cache and the marks cache.\n     void dropAllData();\n \n+    /// Drop data directories if they are empty. It is safe to call this method if table creation was unsuccessful.\n+    void dropIfEmpty();\n+\n     /// Moves the entire data directory.\n     /// Flushes the uncompressed blocks cache and the marks cache.\n     /// Must be called with locked lockStructureForAlter().\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex d109fa464b03..bb12bf984811 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -194,15 +194,19 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n         zookeeper_path = \"/\" + zookeeper_path;\n     replica_path = zookeeper_path + \"/replicas/\" + replica_name;\n \n-    queue_updating_task = global_context.getSchedulePool().createTask(getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::queueUpdatingTask)\", [this]{ queueUpdatingTask(); });\n+    queue_updating_task = global_context.getSchedulePool().createTask(\n+        getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::queueUpdatingTask)\", [this]{ queueUpdatingTask(); });\n \n-    mutations_updating_task = global_context.getSchedulePool().createTask(getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mutationsUpdatingTask)\", [this]{ mutationsUpdatingTask(); });\n+    mutations_updating_task = global_context.getSchedulePool().createTask(\n+        getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mutationsUpdatingTask)\", [this]{ mutationsUpdatingTask(); });\n \n-    merge_selecting_task = global_context.getSchedulePool().createTask(getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mergeSelectingTask)\", [this] { mergeSelectingTask(); });\n+    merge_selecting_task = global_context.getSchedulePool().createTask(\n+        getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mergeSelectingTask)\", [this] { mergeSelectingTask(); });\n     /// Will be activated if we win leader election.\n     merge_selecting_task->deactivate();\n \n-    mutations_finalizing_task = global_context.getSchedulePool().createTask(getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mutationsFinalizingTask)\", [this] { mutationsFinalizingTask(); });\n+    mutations_finalizing_task = global_context.getSchedulePool().createTask(\n+        getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::mutationsFinalizingTask)\", [this] { mutationsFinalizingTask(); });\n \n     if (global_context.hasZooKeeper())\n         current_zookeeper = global_context.getZooKeeper();\n@@ -248,20 +252,30 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n         if (!getDataParts().empty())\n             throw Exception(\"Data directory for table already containing data parts - probably it was unclean DROP table or manual intervention. You must either clear directory by hand or use ATTACH TABLE instead of CREATE TABLE if you need to use that parts.\", ErrorCodes::INCORRECT_DATA);\n \n-        createTableIfNotExists();\n+        try\n+        {\n+            bool is_first_replica = createTableIfNotExists();\n \n-        /// We have to check granularity on other replicas. If it's fixed we\n-        /// must create our new replica with fixed granularity and store this\n-        /// information in /replica/metadata.\n-        other_replicas_fixed_granularity = checkFixedGranualrityInZookeeper();\n+            /// We have to check granularity on other replicas. If it's fixed we\n+            /// must create our new replica with fixed granularity and store this\n+            /// information in /replica/metadata.\n+            other_replicas_fixed_granularity = checkFixedGranualrityInZookeeper();\n \n-        checkTableStructure(zookeeper_path);\n+            checkTableStructure(zookeeper_path);\n \n-        Coordination::Stat metadata_stat;\n-        current_zookeeper->get(zookeeper_path + \"/metadata\", &metadata_stat);\n-        metadata_version = metadata_stat.version;\n+            Coordination::Stat metadata_stat;\n+            current_zookeeper->get(zookeeper_path + \"/metadata\", &metadata_stat);\n+            metadata_version = metadata_stat.version;\n \n-        createReplica();\n+            if (!is_first_replica)\n+                createReplica();\n+        }\n+        catch (...)\n+        {\n+            /// If replica was not created, rollback creation of data directory.\n+            dropIfEmpty();\n+            throw;\n+        }\n     }\n     else\n     {\n@@ -403,46 +417,306 @@ void StorageReplicatedMergeTree::createNewZooKeeperNodes()\n }\n \n \n-void StorageReplicatedMergeTree::createTableIfNotExists()\n+bool StorageReplicatedMergeTree::createTableIfNotExists()\n {\n     auto zookeeper = getZooKeeper();\n+    zookeeper->createAncestors(zookeeper_path);\n \n-    if (zookeeper->exists(zookeeper_path))\n-        return;\n+    for (size_t i = 0; i < 1000; ++i)\n+    {\n+        /// Invariant: \"replicas\" does not exist if there is no table or if there are leftovers from incompletely dropped table.\n+        if (zookeeper->exists(zookeeper_path + \"/replicas\"))\n+        {\n+            LOG_DEBUG(log, \"This table {} is already created, will add new replica\", zookeeper_path);\n+            return false;\n+        }\n \n-    LOG_DEBUG(log, \"Creating table {}\", zookeeper_path);\n+        /// There are leftovers from incompletely dropped table.\n+        if (zookeeper->exists(zookeeper_path + \"/dropped\"))\n+        {\n+            /// This condition may happen when the previous drop attempt was not completed\n+            ///  or when table is dropped by another replica right now.\n+            /// This is Ok because another replica is definitely going to drop the table.\n \n-    zookeeper->createAncestors(zookeeper_path);\n+            LOG_WARNING(log, \"Removing leftovers from table {} (this might take several minutes)\", zookeeper_path);\n \n-    /// We write metadata of table so that the replicas can check table parameters with them.\n-    String metadata = ReplicatedMergeTreeTableMetadata(*this).toString();\n+            Strings children;\n+            int32_t code = zookeeper->tryGetChildren(zookeeper_path, children);\n+            if (code == Coordination::ZNONODE)\n+            {\n+                LOG_WARNING(log, \"Table {} is already finished removing by another replica right now\", replica_path);\n+            }\n+            else\n+            {\n+                for (const auto & child : children)\n+                    if (child != \"dropped\")\n+                        zookeeper->tryRemoveRecursive(zookeeper_path + \"/\" + child);\n \n-    Coordination::Requests ops;\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path, \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/metadata\", metadata,\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/columns\", getColumns().toString(),\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log\", \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/blocks\", \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/block_numbers\", \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/nonincrement_block_numbers\", \"\",\n-        zkutil::CreateMode::Persistent)); /// /nonincrement_block_numbers dir is unused, but is created nonetheless for backwards compatibility.\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/leader_election\", \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/temp\", \"\",\n-        zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/replicas\", \"\",\n-        zkutil::CreateMode::Persistent));\n-\n-    Coordination::Responses responses;\n-    auto code = zookeeper->tryMulti(ops, responses);\n-    if (code && code != Coordination::ZNODEEXISTS)\n-        throw Coordination::Exception(code);\n+                Coordination::Requests ops;\n+                Coordination::Responses responses;\n+                ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/dropped\", -1));\n+                ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path, -1));\n+                code = zookeeper->tryMulti(ops, responses);\n+\n+                if (code == Coordination::ZNONODE)\n+                {\n+                    LOG_WARNING(log, \"Table {} is already finished removing by another replica right now\", replica_path);\n+                }\n+                else if (code == Coordination::ZNOTEMPTY)\n+                {\n+                    throw Exception(fmt::format(\n+                        \"The old table was not completely removed from ZooKeeper, {} still exists and may contain some garbage. But it should never happen according to the logic of operations (it's a bug).\", zookeeper_path), ErrorCodes::LOGICAL_ERROR);\n+                }\n+                else if (code != Coordination::ZOK)\n+                {\n+                    /// It is still possible that ZooKeeper session is expired or server is killed in the middle of the delete operation.\n+                    zkutil::KeeperMultiException::check(code, ops, responses);\n+                }\n+                else\n+                {\n+                    LOG_WARNING(log, \"The leftovers from table {} was successfully removed from ZooKeeper\", zookeeper_path);\n+                }\n+            }\n+        }\n+\n+        LOG_DEBUG(log, \"Creating table {}\", zookeeper_path);\n+\n+        /// We write metadata of table so that the replicas can check table parameters with them.\n+        String metadata = ReplicatedMergeTreeTableMetadata(*this).toString();\n+\n+        Coordination::Requests ops;\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path, \"\", zkutil::CreateMode::Persistent));\n+\n+        /// Check that the table is not being dropped right now.\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/dropped\", \"\", zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/dropped\", -1));\n+\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/metadata\", metadata,\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/columns\", getColumns().toString(),\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/blocks\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/block_numbers\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/nonincrement_block_numbers\", \"\",\n+            zkutil::CreateMode::Persistent)); /// /nonincrement_block_numbers dir is unused, but is created nonetheless for backwards compatibility.\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/leader_election\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/temp\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/replicas\", \"last added replica: \" + replica_name,\n+            zkutil::CreateMode::Persistent));\n+\n+        /// And create first replica atomically. See also \"createReplica\" method that is used to create not the first replicas.\n+\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path, \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/host\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/log_pointer\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/queue\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/parts\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/flags\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/is_lost\", \"0\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata\", metadata,\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/columns\", getColumns().toString(),\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata_version\", std::to_string(metadata_version),\n+            zkutil::CreateMode::Persistent));\n+\n+        Coordination::Responses responses;\n+        auto code = zookeeper->tryMulti(ops, responses);\n+        if (code == Coordination::ZNODEEXISTS)\n+        {\n+            LOG_WARNING(log, \"It looks like the table {} was created by another server at the same moment, will retry\", zookeeper_path);\n+            continue;\n+        }\n+        else if (code != Coordination::ZOK)\n+        {\n+            zkutil::KeeperMultiException::check(code, ops, responses);\n+        }\n+\n+        return true;\n+    }\n+\n+    throw Exception(\"Cannot create table, because it is created concurrently every time or because of logical error\", ErrorCodes::LOGICAL_ERROR);\n+}\n+\n+void StorageReplicatedMergeTree::createReplica()\n+{\n+    auto zookeeper = getZooKeeper();\n+\n+    LOG_DEBUG(log, \"Creating replica {}\", replica_path);\n+\n+    int32_t code;\n+\n+    do\n+    {\n+        Coordination::Stat replicas_stat;\n+        String replicas_value;\n+\n+        code = zookeeper->tryGet(zookeeper_path + \"/replicas\", replicas_value, &replicas_stat);\n+        if (code == Coordination::ZNONODE)\n+            throw Exception(fmt::format(\"Cannot create a replica of the table {}, because the last replica of the table was dropped right now\",\n+                zookeeper_path), ErrorCodes::ALL_REPLICAS_LOST);\n+\n+        /// It is not the first replica, we will mark it as \"lost\", to immediately repair (clone) from existing replica.\n+        /// By the way, it's possible that the replica will be first, if all previous replicas were removed concurrently.\n+        String is_lost_value = replicas_stat.numChildren ? \"1\" : \"0\";\n+\n+        Coordination::Requests ops;\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path, \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/host\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/log_pointer\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/queue\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/parts\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/flags\", \"\",\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/is_lost\", is_lost_value,\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata\", ReplicatedMergeTreeTableMetadata(*this).toString(),\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/columns\", getColumns().toString(),\n+            zkutil::CreateMode::Persistent));\n+        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata_version\", std::to_string(metadata_version),\n+            zkutil::CreateMode::Persistent));\n+\n+        /// Check version of /replicas to see if there are any replicas created at the same moment of time.\n+        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/replicas\", \"last added replica: \" + replica_name, replicas_stat.version));\n+\n+        Coordination::Responses responses;\n+        code = zookeeper->tryMulti(ops, responses);\n+        if (code == Coordination::ZNODEEXISTS)\n+        {\n+            throw Exception(\"Replica \" + replica_path + \" already exists.\", ErrorCodes::REPLICA_IS_ALREADY_EXIST);\n+        }\n+        else if (code == Coordination::ZBADVERSION)\n+        {\n+            LOG_ERROR(log, \"Retrying createReplica(), because some other replicas were created at the same time\");\n+        }\n+        else if (code == Coordination::ZNONODE)\n+        {\n+            throw Exception(\"Table \" + zookeeper_path + \" was suddenly removed.\", ErrorCodes::ALL_REPLICAS_LOST);\n+        }\n+        else\n+        {\n+            zkutil::KeeperMultiException::check(code, ops, responses);\n+        }\n+    } while (code == Coordination::ZBADVERSION);\n+}\n+\n+void StorageReplicatedMergeTree::drop()\n+{\n+    {\n+        auto zookeeper = tryGetZooKeeper();\n+\n+        if (is_readonly || !zookeeper)\n+            throw Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY);\n+\n+        shutdown();\n+\n+        if (zookeeper->expired())\n+            throw Exception(\"Table was not dropped because ZooKeeper session has expired.\", ErrorCodes::TABLE_WAS_NOT_DROPPED);\n+\n+        LOG_INFO(log, \"Removing replica {}\", replica_path);\n+        replica_is_active_node = nullptr;\n+        /// It may left some garbage if replica_path subtree are concurently modified\n+        zookeeper->tryRemoveRecursive(replica_path);\n+        if (zookeeper->exists(replica_path))\n+            LOG_ERROR(log, \"Replica was not completely removed from ZooKeeper, {} still exists and may contain some garbage.\", replica_path);\n+\n+        /// Check that `zookeeper_path` exists: it could have been deleted by another replica after execution of previous line.\n+        Strings replicas;\n+        if (Coordination::ZOK == zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) && replicas.empty())\n+        {\n+            LOG_INFO(log, \"{} is the last replica, will remove table\", replica_path);\n+\n+            /** At this moment, another replica can be created and we cannot remove the table.\n+              * Try to remove /replicas node first. If we successfully removed it,\n+              * it guarantees that we are the only replica that proceed to remove the table\n+              * and no new replicas can be created after that moment (it requires the existence of /replicas node).\n+              * and table cannot be recreated with new /replicas node on another servers while we are removing data,\n+              * because table creation is executed in single transaction that will conflict with remaining nodes.\n+              */\n+\n+            Coordination::Requests ops;\n+            Coordination::Responses responses;\n+            ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/replicas\", -1));\n+            ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/dropped\", \"\", zkutil::CreateMode::Persistent));\n+            int32_t code = zookeeper->tryMulti(ops, responses);\n+\n+            if (code == Coordination::ZNONODE || code == Coordination::ZNODEEXISTS)\n+            {\n+                LOG_WARNING(log, \"Table {} is already started to be removing by another replica right now\", replica_path);\n+            }\n+            else if (code == Coordination::ZNOTEMPTY)\n+            {\n+                LOG_WARNING(log, \"Another replica was suddenly created, will keep the table {}\", replica_path);\n+            }\n+            else if (code != Coordination::ZOK)\n+            {\n+                zkutil::KeeperMultiException::check(code, ops, responses);\n+            }\n+            else\n+            {\n+                LOG_INFO(log, \"Removing table {} (this might take several minutes)\", zookeeper_path);\n+\n+                Strings children;\n+                code = zookeeper->tryGetChildren(zookeeper_path, children);\n+                if (code == Coordination::ZNONODE)\n+                {\n+                    LOG_WARNING(log, \"Table {} is already finished removing by another replica right now\", replica_path);\n+                }\n+                else\n+                {\n+                    for (const auto & child : children)\n+                        if (child != \"dropped\")\n+                            zookeeper->tryRemoveRecursive(zookeeper_path + \"/\" + child);\n+\n+                    ops.clear();\n+                    responses.clear();\n+                    ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/dropped\", -1));\n+                    ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path, -1));\n+                    code = zookeeper->tryMulti(ops, responses);\n+\n+                    if (code == Coordination::ZNONODE)\n+                    {\n+                        LOG_WARNING(log, \"Table {} is already finished removing by another replica right now\", replica_path);\n+                    }\n+                    else if (code == Coordination::ZNOTEMPTY)\n+                    {\n+                        LOG_ERROR(log, \"Table was not completely removed from ZooKeeper, {} still exists and may contain some garbage.\",\n+                            zookeeper_path);\n+                    }\n+                    else if (code != Coordination::ZOK)\n+                    {\n+                        /// It is still possible that ZooKeeper session is expired or server is killed in the middle of the delete operation.\n+                        zkutil::KeeperMultiException::check(code, ops, responses);\n+                    }\n+                    else\n+                    {\n+                        LOG_INFO(log, \"Table {} was successfully removed from ZooKeeper\", zookeeper_path);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    dropAllData();\n }\n \n \n@@ -542,48 +816,6 @@ static time_t tryGetPartCreateTime(zkutil::ZooKeeperPtr & zookeeper, const Strin\n }\n \n \n-void StorageReplicatedMergeTree::createReplica()\n-{\n-    auto zookeeper = getZooKeeper();\n-\n-    LOG_DEBUG(log, \"Creating replica {}\", replica_path);\n-\n-    int32_t code;\n-\n-    do\n-    {\n-        Coordination::Stat replicas_stat;\n-        String last_added_replica = zookeeper->get(zookeeper_path + \"/replicas\", &replicas_stat);\n-\n-        /// If it is not the first replica, we will mark it as \"lost\", to immediately repair (clone) from existing replica.\n-        String is_lost_value = last_added_replica.empty() ? \"0\" : \"1\";\n-\n-        Coordination::Requests ops;\n-        Coordination::Responses responses;\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path, \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/host\", \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/log_pointer\", \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/queue\", \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/parts\", \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/flags\", \"\", zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/is_lost\", is_lost_value, zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata\", ReplicatedMergeTreeTableMetadata(*this).toString(), zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/columns\", getColumns().toString(), zkutil::CreateMode::Persistent));\n-        ops.emplace_back(zkutil::makeCreateRequest(replica_path + \"/metadata_version\", std::to_string(metadata_version), zkutil::CreateMode::Persistent));\n-        /// Check version of /replicas to see if there are any replicas created at the same moment of time.\n-        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/replicas\", \"last added replica: \" + replica_name, replicas_stat.version));\n-\n-        code = zookeeper->tryMulti(ops, responses);\n-        if (code == Coordination::Error::ZNODEEXISTS)\n-            throw Exception(\"Replica \" + replica_path + \" already exists.\", ErrorCodes::REPLICA_IS_ALREADY_EXIST);\n-        else if (code == Coordination::Error::ZBADVERSION)\n-            LOG_ERROR(log, \"Retrying createReplica(), because some other replicas were created at the same time\");\n-        else\n-            zkutil::KeeperMultiException::check(code, ops, responses);\n-    } while (code == Coordination::Error::ZBADVERSION);\n-}\n-\n-\n void StorageReplicatedMergeTree::checkParts(bool skip_sanity_checks)\n {\n     auto zookeeper = getZooKeeper();\n@@ -3699,41 +3931,6 @@ void StorageReplicatedMergeTree::checkPartitionCanBeDropped(const ASTPtr & parti\n }\n \n \n-void StorageReplicatedMergeTree::drop()\n-{\n-    {\n-        auto zookeeper = tryGetZooKeeper();\n-\n-        if (is_readonly || !zookeeper)\n-            throw Exception(\"Can't drop readonly replicated table (need to drop data in ZooKeeper as well)\", ErrorCodes::TABLE_IS_READ_ONLY);\n-\n-        shutdown();\n-\n-        if (zookeeper->expired())\n-            throw Exception(\"Table was not dropped because ZooKeeper session has expired.\", ErrorCodes::TABLE_WAS_NOT_DROPPED);\n-\n-        LOG_INFO(log, \"Removing replica {}\", replica_path);\n-        replica_is_active_node = nullptr;\n-        /// It may left some garbage if replica_path subtree are concurently modified\n-        zookeeper->tryRemoveRecursive(replica_path);\n-        if (zookeeper->exists(replica_path))\n-            LOG_ERROR(log, \"Replica was not completely removed from ZooKeeper, {} still exists and may contain some garbage.\", replica_path);\n-\n-        /// Check that `zookeeper_path` exists: it could have been deleted by another replica after execution of previous line.\n-        Strings replicas;\n-        if (zookeeper->tryGetChildren(zookeeper_path + \"/replicas\", replicas) == Coordination::ZOK && replicas.empty())\n-        {\n-            LOG_INFO(log, \"Removing table {} (this might take several minutes)\", zookeeper_path);\n-            zookeeper->tryRemoveRecursive(zookeeper_path);\n-            if (zookeeper->exists(zookeeper_path))\n-                LOG_ERROR(log, \"Table was not completely removed from ZooKeeper, {} still exists and may contain some garbage.\", zookeeper_path);\n-        }\n-    }\n-\n-    dropAllData();\n-}\n-\n-\n void StorageReplicatedMergeTree::rename(const String & new_path_to_table_data, const StorageID & new_table_id)\n {\n     MergeTreeData::rename(new_path_to_table_data, new_table_id);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex b82b387a6234..18c691046d69 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -291,9 +291,10 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n     template <class Func>\n     void foreachCommittedParts(const Func & func) const;\n \n-    /** Creates the minimum set of nodes in ZooKeeper.\n+    /** Creates the minimum set of nodes in ZooKeeper and create first replica.\n+      * Returns true if was created, false if exists.\n       */\n-    void createTableIfNotExists();\n+    bool createTableIfNotExists();\n \n     /** Creates a replica in ZooKeeper and adds to the queue all that it takes to catch up with the rest of the replicas.\n       */\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.reference b/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.sh b/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.sh\nnew file mode 100755\nindex 000000000000..03325d3da133\n--- /dev/null\n+++ b/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.sh\n@@ -0,0 +1,28 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+set -e\n+\n+function thread()\n+{\n+    while true; do\n+        $CLICKHOUSE_CLIENT -n -q \"DROP TABLE IF EXISTS test_table_$1;\n+            CREATE TABLE test_table_$1 (a UInt8) ENGINE = ReplicatedMergeTree('/clickhouse/tables/alter_table', 'r_$1') ORDER BY tuple();\" 2>&1 |\n+                grep -vP '(^$)|(^Received exception from server)|(^\\d+\\. )|because the last replica of the table was dropped right now|is already started to be removing by another replica right now|is already finished removing by another replica right now|Removing leftovers from table|Another replica was suddenly created|was successfully removed from ZooKeeper|was created by another server at the same moment|was suddenly removed'\n+        done\n+}\n+\n+\n+# https://stackoverflow.com/questions/9954794/execute-a-shell-function-with-timeout\n+export -f thread;\n+\n+TIMEOUT=10\n+\n+timeout $TIMEOUT bash -c 'thread 1' &\n+timeout $TIMEOUT bash -c 'thread 2' &\n+\n+wait\n+\n+for i in {1,2}; do $CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS test_table_$i\"; done\n",
  "problem_statement": "Exception: Directory for table data already exists.\nVersion: `20.4.4.18`\r\n\r\nIf table creation failed, second `create` query may throw exception `Directory for table data ... already exists.`\r\n\r\nExamples:\r\n```\r\nCREATE TABLE ...\r\n\r\nCode: 497. DB::Exception: Received from ... DB::Exception: travel-test: Not enough privileges. ...\r\n\r\nCREATE TABLE ...\r\nReceived exception from server (version 20.4.4):\r\nCode: 57. DB::Exception: Received from localhost:9000. DB::Exception: Directory for table data ... already exists. \r\n```\r\n\r\n```\r\nCREATE TABLE ...\r\n\r\nReceived exception from server (version 20.4.4):\r\nCode: 225. DB::Exception: Received from localhost:9000. DB::Exception: Can't create replicated table without ZooKeeper. \r\n\r\n\r\nCREATE TABLE ...\r\nReceived exception from server (version 20.4.4):\r\nCode: 57. DB::Exception: Received from localhost:9000. DB::Exception: Directory for table data ... already exists. \r\n```\r\n\n",
  "hints_text": "It's dangerous to automatically remove a directory in case of failed CREATE query, because we cannot determine if the directory contains garbage or data of some detached table for example. Probably it's better to disable this check and reopen #7005. Or move the directory to some place like `detached/` instead of removing.\r\n\r\nAlso there is workaround:\r\n```\r\n:) CREATE TABLE table ...\r\nCode: 57. DB::Exception: Received from localhost:9000. DB::Exception: Directory for table data ... already exists. \r\n:) ATTACH TABLE table  ...\r\nOk.\r\n```\r\nfor ReplacetedMergeTree and\r\n```\r\n:) CREATE TABLE  table ... ENGINE=ReplicatedMergeTree(...\r\nCode: 57. DB::Exception: Received from localhost:9000. DB::Exception: Directory for table data ... already exists. \r\n:) ATTACH TABLE table ... ENGINE=MergeTree ...\r\nOk.\r\n:) DROP TABLE table\r\nOk.\r\n:) CREATE TABLE  table ... ENGINE=ReplicatedMergeTree(...\r\nOk.\r\n```\r\nfor other tables.",
  "created_at": "2020-06-11T03:26:57Z",
  "modified_files": [
    "src/Databases/DatabaseOnDisk.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01305_replica_create_drop_zookeeper.sh"
  ]
}