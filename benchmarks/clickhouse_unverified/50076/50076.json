{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50076,
  "instance_id": "ClickHouse__ClickHouse-50076",
  "issue_numbers": [
    "48770"
  ],
  "base_commit": "60908ac269a2fa73f0dedd0ab5a844da660211c6",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 7f2b8f3c6055..862ecc42158a 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -996,6 +996,24 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## arrayJaccardIndex\n+\n+Returns the [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) of two arrays.\n+\n+**Example**\n+\n+Query:\n+``` sql\n+SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res\n+```\n+\n+Result:\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 0.3333333333333333 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## arrayReduce\n \n Applies an aggregate function to array elements and returns its result. The name of the aggregation function is passed as a string in single quotes `'max'`, `'sum'`. When using parametric aggregate functions, the parameter is indicated after the function name in parentheses `'uniqUpTo(6)'`.\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex bfc4a71083d9..4adafe5d2129 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -410,21 +410,29 @@ inline bool isDateTime(const T & data_type) { return WhichDataType(data_type).is\n template <typename T>\n inline bool isDateTime64(const T & data_type) { return WhichDataType(data_type).isDateTime64(); }\n \n-inline bool isEnum(const DataTypePtr & data_type) { return WhichDataType(data_type).isEnum(); }\n-inline bool isDecimal(const DataTypePtr & data_type) { return WhichDataType(data_type).isDecimal(); }\n-inline bool isTuple(const DataTypePtr & data_type) { return WhichDataType(data_type).isTuple(); }\n-inline bool isArray(const DataTypePtr & data_type) { return WhichDataType(data_type).isArray(); }\n-inline bool isMap(const DataTypePtr & data_type) {return WhichDataType(data_type).isMap(); }\n-inline bool isInterval(const DataTypePtr & data_type) {return WhichDataType(data_type).isInterval(); }\n-inline bool isNothing(const DataTypePtr & data_type) { return WhichDataType(data_type).isNothing(); }\n-inline bool isUUID(const DataTypePtr & data_type) { return WhichDataType(data_type).isUUID(); }\n-inline bool isIPv4(const DataTypePtr & data_type) { return WhichDataType(data_type).isIPv4(); }\n-inline bool isIPv6(const DataTypePtr & data_type) { return WhichDataType(data_type).isIPv6(); }\n-\n-template <typename T>\n-inline bool isObject(const T & data_type)\n-{\n-    return WhichDataType(data_type).isObject();\n+template <typename T>\n+inline bool isEnum(const T & data_type) { return WhichDataType(data_type).isEnum(); }\n+template <typename T>\n+inline bool isDecimal(const T & data_type) { return WhichDataType(data_type).isDecimal(); }\n+template <typename T>\n+inline bool isTuple(const T & data_type) { return WhichDataType(data_type).isTuple(); }\n+template <typename T>\n+inline bool isArray(const T & data_type) { return WhichDataType(data_type).isArray(); }\n+template <typename T>\n+inline bool isMap(const T & data_type) {return WhichDataType(data_type).isMap(); }\n+template <typename T>\n+inline bool isInterval(const T & data_type) {return WhichDataType(data_type).isInterval(); }\n+template <typename T>\n+inline bool isNothing(const T & data_type) { return WhichDataType(data_type).isNothing(); }\n+template <typename T>\n+inline bool isUUID(const T & data_type) { return WhichDataType(data_type).isUUID(); }\n+template <typename T>\n+inline bool isIPv4(const T & data_type) { return WhichDataType(data_type).isIPv4(); }\n+template <typename T>\n+inline bool isIPv6(const T & data_type) { return WhichDataType(data_type).isIPv6(); }\n+\n+template <typename T>\n+inline bool isObject(const T & data_type) { return WhichDataType(data_type).isObject();\n }\n \n template <typename T>\ndiff --git a/src/Functions/array/arrayJaccardIndex.cpp b/src/Functions/array/arrayJaccardIndex.cpp\nnew file mode 100644\nindex 000000000000..755e0f8278f8\n--- /dev/null\n+++ b/src/Functions/array/arrayJaccardIndex.cpp\n@@ -0,0 +1,161 @@\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/IColumn.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/IDataType.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypeNothing.h>\n+#include <DataTypes/getMostSubtype.h>\n+#include <Core/ColumnsWithTypeAndName.h>\n+#include <Core/ColumnWithTypeAndName.h>\n+#include <Interpreters/Context_fwd.h>\n+#include <base/types.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+class FunctionArrayJaccardIndex : public IFunction\n+{\n+private:\n+    using ResultType = Float64;\n+\n+    struct LeftAndRightSizes\n+    {\n+        size_t left_size;\n+        size_t right_size;\n+    };\n+\n+    template <bool left_is_const, bool right_is_const>\n+    static LeftAndRightSizes getArraySizes(const ColumnArray::Offsets & left_offsets, const ColumnArray::Offsets & right_offsets, size_t i)\n+    {\n+        size_t left_size;\n+        size_t right_size;\n+\n+        if constexpr (left_is_const)\n+            left_size = left_offsets[0];\n+        else\n+            left_size = left_offsets[i] - left_offsets[i - 1];\n+\n+        if constexpr (right_is_const)\n+            right_size = right_offsets[0];\n+        else\n+            right_size = right_offsets[i] - right_offsets[i - 1];\n+\n+        return {left_size, right_size};\n+    }\n+\n+    template <bool left_is_const, bool right_is_const>\n+    static void vector(const ColumnArray::Offsets & intersect_offsets, const ColumnArray::Offsets & left_offsets, const ColumnArray::Offsets & right_offsets, PaddedPODArray<ResultType> & res)\n+    {\n+        for (size_t i = 0; i < res.size(); ++i)\n+        {\n+            LeftAndRightSizes sizes = getArraySizes<left_is_const, right_is_const>(left_offsets, right_offsets, i);\n+            size_t intersect_size = intersect_offsets[i] - intersect_offsets[i - 1];\n+            res[i] = static_cast<ResultType>(intersect_size) / (sizes.left_size + sizes.right_size - intersect_size);\n+        }\n+    }\n+\n+    template <bool left_is_const, bool right_is_const>\n+    static void vectorWithEmptyIntersect(const ColumnArray::Offsets & left_offsets, const ColumnArray::Offsets & right_offsets, PaddedPODArray<ResultType> & res)\n+    {\n+        for (size_t i = 0; i < res.size(); ++i)\n+        {\n+            LeftAndRightSizes sizes = getArraySizes<left_is_const, right_is_const>(left_offsets, right_offsets, i);\n+            if (sizes.left_size == 0 && sizes.right_size == 0)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"array aggregate functions cannot be performed on two empty arrays\");\n+            res[i] = 0;\n+        }\n+    }\n+\n+public:\n+    static constexpr auto name = \"arrayJaccardIndex\";\n+    String getName() const override { return name; }\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionArrayJaccardIndex>(context_); }\n+    explicit FunctionArrayJaccardIndex(ContextPtr context_) : context(context_) {}\n+    size_t getNumberOfArguments() const override { return 2; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"array_1\", &isArray<IDataType>, nullptr, \"Array\"},\n+            {\"array_2\", &isArray<IDataType>, nullptr, \"Array\"},\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n+        return std::make_shared<DataTypeNumber<ResultType>>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto cast_to_array = [&](const ColumnWithTypeAndName & col) -> std::pair<const ColumnArray *, bool>\n+        {\n+            if (const ColumnConst * col_const = typeid_cast<const ColumnConst *>(col.column.get()))\n+            {\n+                const ColumnArray * col_const_array = checkAndGetColumn<ColumnArray>(col_const->getDataColumnPtr().get());\n+                return {col_const_array, true};\n+            }\n+            else if (const ColumnArray * col_non_const_array = checkAndGetColumn<ColumnArray>(col.column.get()))\n+                return {col_non_const_array, false};\n+            else\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Argument for function {} must be array but it has type {}.\", col.column->getName(), getName());\n+        };\n+\n+        const auto & [left_array, left_is_const] = cast_to_array(arguments[0]);\n+        const auto & [right_array, right_is_const] = cast_to_array(arguments[1]);\n+\n+        auto intersect_array = FunctionFactory::instance().get(\"arrayIntersect\", context)->build(arguments);\n+\n+        ColumnWithTypeAndName intersect_column;\n+        intersect_column.type = intersect_array->getResultType();\n+        intersect_column.column = intersect_array->execute(arguments, intersect_column.type, input_rows_count);\n+\n+        const auto * intersect_column_type = checkAndGetDataType<DataTypeArray>(intersect_column.type.get());\n+        if (!intersect_column_type)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected return type for function arrayIntersect\");\n+\n+        auto col_res = ColumnVector<ResultType>::create();\n+        typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();\n+        vec_res.resize(input_rows_count);\n+\n+#define EXECUTE_VECTOR(left_is_const, right_is_const) \\\n+    if (typeid_cast<const DataTypeNothing *>(intersect_column_type->getNestedType().get())) \\\n+        vectorWithEmptyIntersect<left_is_const, right_is_const>(left_array->getOffsets(), right_array->getOffsets(), vec_res); \\\n+    else \\\n+    { \\\n+        const ColumnArray * intersect_column_array = checkAndGetColumn<ColumnArray>(intersect_column.column.get()); \\\n+        vector<left_is_const, right_is_const>(intersect_column_array->getOffsets(), left_array->getOffsets(), right_array->getOffsets(), vec_res); \\\n+    }\n+\n+        if (!left_is_const && !right_is_const)\n+            EXECUTE_VECTOR(false, false)\n+        else if (!left_is_const && right_is_const)\n+            EXECUTE_VECTOR(false, true)\n+        else if (left_is_const && !right_is_const)\n+            EXECUTE_VECTOR(true, false)\n+        else\n+            EXECUTE_VECTOR(true, true)\n+\n+#undef EXECUTE_VECTOR\n+\n+        return col_res;\n+    }\n+\n+private:\n+    ContextPtr context;\n+};\n+\n+REGISTER_FUNCTION(ArrayJaccardIndex)\n+{\n+    factory.registerFunction<FunctionArrayJaccardIndex>();\n+}\n+\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 6ddca6db538a..fe7af73591e2 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1035,6 +1035,7 @@ arrayFirst\n arrayFirstIndex\n arrayFlatten\n arrayIntersect\n+arrayJaccardIndex\n arrayJoin\n arrayLast\n arrayLastIndex\n@@ -1608,6 +1609,7 @@ isNull\n isValidJSON\n isValidUTF\n iteratively\n+jaccard\n javaHash\n javaHashUTF\n jbod\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex b5c133988e6b..5d7c84904b25 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -112,6 +112,7 @@ arrayFirstIndex\n arrayFirstOrNull\n arrayFlatten\n arrayIntersect\n+arrayJaccardIndex\n arrayJoin\n arrayLast\n arrayLastIndex\ndiff --git a/tests/queries/0_stateless/02737_arrayJaccardIndex.reference b/tests/queries/0_stateless/02737_arrayJaccardIndex.reference\nnew file mode 100644\nindex 000000000000..62a51ec0ab24\n--- /dev/null\n+++ b/tests/queries/0_stateless/02737_arrayJaccardIndex.reference\n@@ -0,0 +1,23 @@\n+negative tests\n+const arguments\n+[1,2]\t[1,2,3,4]\t0.5\n+[1,1.1,2.2]\t[2.2,3.3,444]\t0.2\n+[1]\t[1]\t1\n+['a']\t['a','aa','aaa']\t0.33\n+[[1,2],[3,4]]\t[[1,2],[3,5]]\t0.33\n+non-const arguments\n+[1]\t[1,2]\t0.5\n+[1,2]\t[1,2]\t1\n+[1,2,3]\t[1,2]\t0.67\n+[1]\t[]\t0\n+[1,2]\t[]\t0\n+[1,2,3]\t[]\t0\n+[1,2]\t[1]\t0.5\n+[1,2]\t[1,2]\t1\n+[1,2]\t[1,2,3]\t0.67\n+[]\t[1]\t0\n+[]\t[1,2]\t0\n+[]\t[1,2,3]\t0\n+[1]\t[1]\t1\n+[1,2]\t[1,2]\t1\n+[1,2,3]\t[1,2,3]\t1\ndiff --git a/tests/queries/0_stateless/02737_arrayJaccardIndex.sql b/tests/queries/0_stateless/02737_arrayJaccardIndex.sql\nnew file mode 100644\nindex 000000000000..499debd94b76\n--- /dev/null\n+++ b/tests/queries/0_stateless/02737_arrayJaccardIndex.sql\n@@ -0,0 +1,30 @@\n+SELECT 'negative tests';\n+\n+SELECT 'a' AS arr1, 2 AS arr2, round(arrayJaccardIndex(arr1, arr2), 2); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT [] AS arr1, [] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT ['1', '2'] AS arr1, [1,2] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2); -- { serverError NO_COMMON_TYPE }\n+\n+SELECT 'const arguments';\n+\n+SELECT [1,2] AS arr1, [1,2,3,4] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2);\n+SELECT [1, 1.1, 2.2] AS arr1, [2.2, 3.3, 444] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2);\n+SELECT [toUInt16(1)] AS arr1, [toUInt32(1)] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2);\n+SELECT ['a'] AS arr1, ['a', 'aa', 'aaa'] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2);\n+SELECT [[1,2], [3,4]] AS arr1, [[1,2], [3,5]] AS arr2, round(arrayJaccardIndex(arr1, arr2), 2);\n+\n+SELECT 'non-const arguments';\n+\n+DROP TABLE IF EXISTS array_jaccard_index;\n+\n+CREATE TABLE array_jaccard_index (arr Array(UInt8)) engine = MergeTree ORDER BY arr;\n+INSERT INTO array_jaccard_index values ([1,2,3]);\n+INSERT INTO array_jaccard_index values ([1,2]);\n+INSERT INTO array_jaccard_index values ([1]);\n+\n+SELECT arr, [1,2] AS other, round(arrayJaccardIndex(arr, other), 2) FROM array_jaccard_index ORDER BY arr;\n+SELECT arr, [] AS other, round(arrayJaccardIndex(arr, other), 2) FROM array_jaccard_index ORDER BY arr;\n+SELECT [1,2] AS other, arr, round(arrayJaccardIndex(other, arr), 2) FROM array_jaccard_index ORDER BY arr;\n+SELECT [] AS other, arr,  round(arrayJaccardIndex(other, arr), 2) FROM array_jaccard_index ORDER BY arr;\n+SELECT arr, arr, round(arrayJaccardIndex(arr, arr), 2) FROM array_jaccard_index ORDER BY arr;\n+\n+DROP TABLE array_jaccard_index;\n",
  "problem_statement": "Jaccard Similarity of arrays\n**Use case**\r\n\r\nBrute-force similarity search.\r\n\r\n**Describe the solution you'd like**\r\n\r\nSee the implementation of the `arrayIntersect` function.\r\n\r\n**Describe alternatives you've considered**\r\n\r\n```\r\nCREATE FUNCTION arrayJaccardIndex AS (a, b) -> size(arrayIntersect(a, b)) / (size(a) + size(b) - size(arrayIntersect(a, b)))\r\n```\n",
  "hints_text": "I'd like to have a try :)",
  "created_at": "2023-05-22T09:31:49Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "src/DataTypes/IDataType.h",
    "b/src/Functions/array/arrayJaccardIndex.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "b/tests/queries/0_stateless/02737_arrayJaccardIndex.reference",
    "b/tests/queries/0_stateless/02737_arrayJaccardIndex.sql"
  ]
}