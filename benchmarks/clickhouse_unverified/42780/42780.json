{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42780,
  "instance_id": "ClickHouse__ClickHouse-42780",
  "issue_numbers": [
    "42502"
  ],
  "base_commit": "d7eee868272142788beed174570dbe32c4cd10fc",
  "patch": "diff --git a/src/Formats/newLineSegmentationEngine.cpp b/src/Formats/newLineSegmentationEngine.cpp\nnew file mode 100644\nindex 000000000000..a605bba7e5bb\n--- /dev/null\n+++ b/src/Formats/newLineSegmentationEngine.cpp\n@@ -0,0 +1,50 @@\n+#include <Formats/newLineSegmentationEngine.h>\n+#include <IO/ReadHelpers.h>\n+#include <base/find_symbols.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)\n+{\n+    char * pos = in.position();\n+    bool need_more_data = true;\n+    size_t number_of_rows = 0;\n+\n+    while (loadAtPosition(in, memory, pos) && need_more_data)\n+    {\n+        pos = find_first_symbols<'\\r', '\\n'>(pos, in.buffer().end());\n+        if (pos > in.buffer().end())\n+            throw Exception(\"Position in buffer is out of bounds. There must be a bug.\", ErrorCodes::LOGICAL_ERROR);\n+        else if (pos == in.buffer().end())\n+            continue;\n+\n+        ++number_of_rows;\n+        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))\n+            need_more_data = false;\n+\n+        if (*pos == '\\n')\n+        {\n+            ++pos;\n+            if (loadAtPosition(in, memory, pos) && *pos == '\\r')\n+                ++pos;\n+        }\n+        else if (*pos == '\\r')\n+        {\n+            ++pos;\n+            if (loadAtPosition(in, memory, pos) && *pos == '\\n')\n+                ++pos;\n+        }\n+    }\n+\n+    saveUpToPosition(in, memory, pos);\n+\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n+}\n+\n+}\ndiff --git a/src/Formats/newLineSegmentationEngine.h b/src/Formats/newLineSegmentationEngine.h\nnew file mode 100644\nindex 000000000000..598f808b7986\n--- /dev/null\n+++ b/src/Formats/newLineSegmentationEngine.h\n@@ -0,0 +1,9 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/BufferWithOwnMemory.h>\n+\n+namespace DB\n+{\n+    std::pair<bool, size_t> newLineFileSegmentationEngine(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows);\n+}\ndiff --git a/src/Formats/registerFormats.cpp b/src/Formats/registerFormats.cpp\nindex 593e4568be1a..ba40fe442abc 100644\n--- a/src/Formats/registerFormats.cpp\n+++ b/src/Formats/registerFormats.cpp\n@@ -18,6 +18,7 @@ void registerFileSegmentationEngineJSONCompactEachRow(FormatFactory & factory);\n #if USE_HIVE\n void registerFileSegmentationEngineHiveText(FormatFactory & factory);\n #endif\n+void registerFileSegmentationEngineLineAsString(FormatFactory & factory);\n \n /// Formats for both input/output.\n \n@@ -153,6 +154,7 @@ void registerFormats()\n #if USE_HIVE\n     registerFileSegmentationEngineHiveText(factory);\n #endif\n+    registerFileSegmentationEngineLineAsString(factory);\n \n \n     registerInputFormatNative(factory);\ndiff --git a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\nindex 30084804d92c..677f8bb28ec6 100644\n--- a/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp\n@@ -1,5 +1,5 @@\n #include <Processors/Formats/Impl/LineAsStringRowInputFormat.h>\n-#include <Formats/JSONUtils.h>\n+#include <Formats/newLineSegmentationEngine.h>\n #include <base/find_symbols.h>\n #include <IO/ReadHelpers.h>\n #include <Columns/ColumnString.h>\n@@ -63,6 +63,12 @@ void registerInputFormatLineAsString(FormatFactory & factory)\n     });\n }\n \n+void registerFileSegmentationEngineLineAsString(FormatFactory & factory)\n+{\n+    factory.registerFileSegmentationEngine(\"LineAsString\", &newLineFileSegmentationEngine);\n+}\n+\n+\n void registerLineAsStringSchemaReader(FormatFactory & factory)\n {\n     factory.registerExternalSchemaReader(\"LineAsString\", [](\ndiff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\nindex 6eacfe621e1a..2ad2ad6f7a38 100644\n--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n@@ -3,6 +3,7 @@\n #include <Processors/Formats/Impl/RegexpRowInputFormat.h>\n #include <DataTypes/Serializations/SerializationNullable.h>\n #include <Formats/EscapingRuleUtils.h>\n+#include <Formats/newLineSegmentationEngine.h>\n #include <IO/ReadHelpers.h>\n \n namespace DB\n@@ -178,46 +179,9 @@ void registerInputFormatRegexp(FormatFactory & factory)\n     });\n }\n \n-static std::pair<bool, size_t> fileSegmentationEngineRegexpImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_bytes, size_t max_rows)\n-{\n-    char * pos = in.position();\n-    bool need_more_data = true;\n-    size_t number_of_rows = 0;\n-\n-    while (loadAtPosition(in, memory, pos) && need_more_data)\n-    {\n-        pos = find_first_symbols<'\\r', '\\n'>(pos, in.buffer().end());\n-        if (pos > in.buffer().end())\n-            throw Exception(\"Position in buffer is out of bounds. There must be a bug.\", ErrorCodes::LOGICAL_ERROR);\n-        else if (pos == in.buffer().end())\n-            continue;\n-\n-        ++number_of_rows;\n-        if ((memory.size() + static_cast<size_t>(pos - in.position()) >= min_bytes) || (number_of_rows == max_rows))\n-            need_more_data = false;\n-\n-        if (*pos == '\\n')\n-        {\n-            ++pos;\n-            if (loadAtPosition(in, memory, pos) && *pos == '\\r')\n-                ++pos;\n-        }\n-        else if (*pos == '\\r')\n-        {\n-            ++pos;\n-            if (loadAtPosition(in, memory, pos) && *pos == '\\n')\n-                ++pos;\n-        }\n-    }\n-\n-    saveUpToPosition(in, memory, pos);\n-\n-    return {loadAtPosition(in, memory, pos), number_of_rows};\n-}\n-\n void registerFileSegmentationEngineRegexp(FormatFactory & factory)\n {\n-    factory.registerFileSegmentationEngine(\"Regexp\", &fileSegmentationEngineRegexpImpl);\n+    factory.registerFileSegmentationEngine(\"Regexp\", &newLineFileSegmentationEngine);\n }\n \n void registerRegexpSchemaReader(FormatFactory & factory)\n",
  "test_patch": "diff --git a/tests/performance/line_as_string_parsing.xml b/tests/performance/line_as_string_parsing.xml\nnew file mode 100644\nindex 000000000000..d9fa1d4fa6ed\n--- /dev/null\n+++ b/tests/performance/line_as_string_parsing.xml\n@@ -0,0 +1,9 @@\n+<test>\n+    \n+<fill_query>INSERT INTO FUNCTION file(test_line_as_string.tsv) SELECT randomString(1000) FROM numbers(1000000) SETTINGS engine_file_truncate_on_insert=1</fill_query>\n+\n+<query>SELECT * FROM file(test_line_as_string.tsv, LineAsString) FORMAT Null</query>\n+\n+<drop_query>INSERT INTO FUNCTION file(test_line_as_string.tsv) SELECT * FROM numbers(0) SETTINGS engine_file_truncate_on_insert=1</drop_query>\n+\n+</test>\n",
  "problem_statement": "`LineAsString` format can be faster; and it does not support parallel parsing.\n```\r\nyes | clickhouse-local --format LineAsString --structure 'line String' --progress --query \"SELECT * FROM table\" > /dev/null\r\n```\n",
  "hints_text": "",
  "created_at": "2022-10-28T18:40:48Z",
  "modified_files": [
    "b/src/Formats/newLineSegmentationEngine.cpp",
    "b/src/Formats/newLineSegmentationEngine.h",
    "src/Formats/registerFormats.cpp",
    "src/Processors/Formats/Impl/LineAsStringRowInputFormat.cpp",
    "src/Processors/Formats/Impl/RegexpRowInputFormat.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/line_as_string_parsing.xml"
  ]
}