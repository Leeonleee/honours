{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41766,
  "instance_id": "ClickHouse__ClickHouse-41766",
  "issue_numbers": [
    "40621"
  ],
  "base_commit": "fbf891d375ed8df11396b349501d33ed6991e0d9",
  "patch": "diff --git a/contrib/NuRaft b/contrib/NuRaft\nindex 1be805e7cb24..e4e746a24eb5 160000\n--- a/contrib/NuRaft\n+++ b/contrib/NuRaft\n@@ -1,1 +1,1 @@\n-Subproject commit 1be805e7cb2494aa8170015493474379b0362dfc\n+Subproject commit e4e746a24eb56861a86f3672771e3308d8c40722\ndiff --git a/docs/en/operations/clickhouse-keeper.md b/docs/en/operations/clickhouse-keeper.md\nindex aad20da0010f..0324f7429888 100644\n--- a/docs/en/operations/clickhouse-keeper.md\n+++ b/docs/en/operations/clickhouse-keeper.md\n@@ -126,7 +126,7 @@ clickhouse keeper --config /etc/your_path_to_config/config.xml\n \n ClickHouse Keeper also provides 4lw commands which are almost the same with Zookeeper. Each command is composed of four letters such as `mntr`, `stat` etc. There are some more interesting commands: `stat` gives some general information about the server and connected clients, while `srvr` and `cons` give extended details on server and connections respectively.\n \n-The 4lw commands has a white list configuration `four_letter_word_white_list` which has default value `conf,cons,crst,envi,ruok,srst,srvr,stat,wchc,wchs,dirs,mntr,isro`.\n+The 4lw commands has a white list configuration `four_letter_word_white_list` which has default value `conf,cons,crst,envi,ruok,srst,srvr,stat,wchs,dirs,mntr,isro,rcvr,apiv,csnp,lgif`.\n \n You can issue the commands to ClickHouse Keeper via telnet or nc, at the client port.\n \n@@ -309,6 +309,25 @@ Sessions with Ephemerals (1):\n  /clickhouse/task_queue/ddl\n ```\n \n+- `csnp`: Schedule a snapshot creation task. Return the last committed log index of the scheduled snapshot if success or `Failed to schedule snapshot creation task.` if failed. Note that `lgif` command can help you determine whether the snapshot is done.\n+\n+```\n+100\n+```\n+\n+- `lgif`: Keeper log information. `first_log_idx` : my first log index in log store; `first_log_term` : my first log term; `last_log_idx` : my last log index in log store; `last_log_term` : my last log term; `last_committed_log_idx` : my last committed log index in state machine; `leader_committed_log_idx` : leader's committed log index from my perspective; `target_committed_log_idx` : target log index should be committed to; `last_snapshot_idx` : the largest committed log index in last snapshot.\n+\n+```\n+first_log_idx   1\n+first_log_term  1\n+last_log_idx    101\n+last_log_term   1\n+last_committed_log_idx  100\n+leader_committed_log_idx    101\n+target_committed_log_idx    101\n+last_snapshot_idx   50\n+```\n+\n ## Migration from ZooKeeper {#migration-from-zookeeper}\n \n Seamlessly migration from ZooKeeper to ClickHouse Keeper is impossible you have to stop your ZooKeeper cluster, convert data and start ClickHouse Keeper. `clickhouse-keeper-converter` tool allows converting ZooKeeper logs and snapshots to ClickHouse Keeper snapshot. It works only with ZooKeeper > 3.4. Steps for migration:\ndiff --git a/src/Coordination/CoordinationSettings.cpp b/src/Coordination/CoordinationSettings.cpp\nindex 3e03ee0d6f47..08b8668a3abd 100644\n--- a/src/Coordination/CoordinationSettings.cpp\n+++ b/src/Coordination/CoordinationSettings.cpp\n@@ -36,7 +36,7 @@ void CoordinationSettings::loadFromConfig(const String & config_elem, const Poco\n }\n \n \n-const String KeeperConfigurationAndSettings::DEFAULT_FOUR_LETTER_WORD_CMD = \"conf,cons,crst,envi,ruok,srst,srvr,stat,wchs,dirs,mntr,isro,rcvr,apiv\";\n+const String KeeperConfigurationAndSettings::DEFAULT_FOUR_LETTER_WORD_CMD = \"conf,cons,crst,envi,ruok,srst,srvr,stat,wchs,dirs,mntr,isro,rcvr,apiv,csnp,lgif\";\n \n KeeperConfigurationAndSettings::KeeperConfigurationAndSettings()\n     : server_id(NOT_EXIST)\ndiff --git a/src/Coordination/FourLetterCommand.cpp b/src/Coordination/FourLetterCommand.cpp\nindex c33630a913b2..82123dc82187 100644\n--- a/src/Coordination/FourLetterCommand.cpp\n+++ b/src/Coordination/FourLetterCommand.cpp\n@@ -136,6 +136,12 @@ void FourLetterCommandFactory::registerCommands(KeeperDispatcher & keeper_dispat\n         FourLetterCommandPtr api_version_command = std::make_shared<ApiVersionCommand>(keeper_dispatcher);\n         factory.registerCommand(api_version_command);\n \n+        FourLetterCommandPtr create_snapshot_command = std::make_shared<CreateSnapshotCommand>(keeper_dispatcher);\n+        factory.registerCommand(create_snapshot_command);\n+\n+        FourLetterCommandPtr log_info_command = std::make_shared<LogInfoCommand>(keeper_dispatcher);\n+        factory.registerCommand(log_info_command);\n+\n         factory.initializeAllowList(keeper_dispatcher);\n         factory.setInitialize(true);\n     }\n@@ -472,4 +478,33 @@ String ApiVersionCommand::run()\n     return toString(static_cast<uint8_t>(Coordination::current_keeper_api_version));\n }\n \n+String CreateSnapshotCommand::run()\n+{\n+    auto log_index = keeper_dispatcher.createSnapshot();\n+    return log_index > 0 ? std::to_string(log_index) : \"Failed to schedule snapshot creation task.\";\n+}\n+\n+String LogInfoCommand::run()\n+{\n+    KeeperLogInfo log_info = keeper_dispatcher.getKeeperLogInfo();\n+    StringBuffer ret;\n+\n+    auto append = [&ret] (String key, uint64_t value) -> void\n+    {\n+        writeText(key, ret);\n+        writeText('\\t', ret);\n+        writeText(std::to_string(value), ret);\n+        writeText('\\n', ret);\n+    };\n+    append(\"first_log_idx\", log_info.first_log_idx);\n+    append(\"first_log_term\", log_info.first_log_idx);\n+    append(\"last_log_idx\", log_info.last_log_idx);\n+    append(\"last_log_term\", log_info.last_log_term);\n+    append(\"last_committed_log_idx\", log_info.last_committed_log_idx);\n+    append(\"leader_committed_log_idx\", log_info.leader_committed_log_idx);\n+    append(\"target_committed_log_idx\", log_info.target_committed_log_idx);\n+    append(\"last_snapshot_idx\", log_info.last_snapshot_idx);\n+    return ret.str();\n+}\n+\n }\ndiff --git a/src/Coordination/FourLetterCommand.h b/src/Coordination/FourLetterCommand.h\nindex 3374687ad825..a8801474bb0d 100644\n--- a/src/Coordination/FourLetterCommand.h\n+++ b/src/Coordination/FourLetterCommand.h\n@@ -17,6 +17,7 @@ using FourLetterCommandPtr = std::shared_ptr<DB::IFourLetterCommand>;\n /// Just like zookeeper Four Letter Words commands, CH Keeper responds to a small set of commands.\n /// Each command is composed of four letters, these commands are useful to monitor and issue system problems.\n /// The feature is based on Zookeeper 3.5.9, details is in https://zookeeper.apache.org/doc/r3.5.9/zookeeperAdmin.html#sc_zkCommands.\n+/// Also we add some additional commands such as csnp, lgif etc.\n struct IFourLetterCommand\n {\n public:\n@@ -327,4 +328,40 @@ struct ApiVersionCommand : public IFourLetterCommand\n     String run() override;\n     ~ApiVersionCommand() override = default;\n };\n+\n+/// Create snapshot manually\n+struct CreateSnapshotCommand : public IFourLetterCommand\n+{\n+    explicit CreateSnapshotCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"csnp\"; }\n+    String run() override;\n+    ~CreateSnapshotCommand() override = default;\n+};\n+\n+/** Raft log information:\n+ *     first_log_idx 1\n+ *     first_log_term   1\n+ *     last_log_idx 101\n+ *     last_log_term    1\n+ *     last_committed_idx   100\n+ *     leader_committed_log_idx 101\n+ *     target_committed_log_idx 101\n+ *     last_snapshot_idx    50\n+ */\n+struct LogInfoCommand : public IFourLetterCommand\n+{\n+    explicit LogInfoCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"lgif\"; }\n+    String run() override;\n+    ~LogInfoCommand() override = default;\n+};\n+\n }\ndiff --git a/src/Coordination/Keeper4LWInfo.h b/src/Coordination/Keeper4LWInfo.h\nindex 7d90152611e4..105478457cc1 100644\n--- a/src/Coordination/Keeper4LWInfo.h\n+++ b/src/Coordination/Keeper4LWInfo.h\n@@ -47,4 +47,32 @@ struct Keeper4LWInfo\n     }\n };\n \n+/// Keeper log information for 4lw commands\n+struct KeeperLogInfo\n+{\n+    /// My first log index in log store.\n+    uint64_t first_log_idx;\n+\n+    /// My first log term.\n+    uint64_t first_log_term;\n+\n+    /// My last log index in log store.\n+    uint64_t last_log_idx;\n+\n+    /// My last log term.\n+    uint64_t last_log_term;\n+\n+    /// My last committed log index in state machine.\n+    uint64_t last_committed_log_idx;\n+\n+    /// Leader's committed log index from my perspective.\n+    uint64_t leader_committed_log_idx;\n+\n+    /// Target log index should be committed to.\n+    uint64_t target_committed_log_idx;\n+\n+    /// The largest committed log index in last snapshot.\n+    uint64_t last_snapshot_idx;\n+};\n+\n }\ndiff --git a/src/Coordination/KeeperDispatcher.h b/src/Coordination/KeeperDispatcher.h\nindex 0003867adbef..84345ca1ff58 100644\n--- a/src/Coordination/KeeperDispatcher.h\n+++ b/src/Coordination/KeeperDispatcher.h\n@@ -203,6 +203,18 @@ class KeeperDispatcher\n     {\n         keeper_stats.reset();\n     }\n+\n+    /// Create snapshot manually, return the last committed log index in the snapshot\n+    uint64_t createSnapshot()\n+    {\n+        return server->createSnapshot();\n+    }\n+\n+    /// Get Raft information\n+    KeeperLogInfo getKeeperLogInfo()\n+    {\n+        return server->getKeeperLogInfo();\n+    }\n };\n \n }\ndiff --git a/src/Coordination/KeeperServer.cpp b/src/Coordination/KeeperServer.cpp\nindex a097cb57bc62..487d0dc4cc36 100644\n--- a/src/Coordination/KeeperServer.cpp\n+++ b/src/Coordination/KeeperServer.cpp\n@@ -907,4 +907,29 @@ Keeper4LWInfo KeeperServer::getPartiallyFilled4LWInfo() const\n     return result;\n }\n \n+uint64_t KeeperServer::createSnapshot()\n+{\n+    uint64_t log_idx = raft_instance->create_snapshot();\n+    if (log_idx != 0)\n+        LOG_INFO(log, \"Snapshot creation scheduled with last committed log index {}.\", log_idx);\n+    else\n+        LOG_WARNING(log, \"Failed to schedule snapshot creation task.\");\n+    return log_idx;\n+}\n+\n+KeeperLogInfo KeeperServer::getKeeperLogInfo()\n+{\n+    KeeperLogInfo log_info;\n+    auto log_store = state_manager->load_log_store();\n+    log_info.first_log_idx = log_store->start_index();\n+    log_info.first_log_term = log_store->term_at(log_info.first_log_idx);\n+    log_info.last_log_idx = raft_instance->get_last_log_idx();\n+    log_info.last_log_term = raft_instance->get_last_log_term();\n+    log_info.last_committed_log_idx = raft_instance->get_committed_log_idx();\n+    log_info.leader_committed_log_idx = raft_instance->get_leader_committed_log_idx();\n+    log_info.target_committed_log_idx = raft_instance->get_target_committed_log_idx();\n+    log_info.last_snapshot_idx = raft_instance->get_last_snapshot_idx();\n+    return log_info;\n+}\n+\n }\ndiff --git a/src/Coordination/KeeperServer.h b/src/Coordination/KeeperServer.h\nindex a33e29b45405..192c8f470b18 100644\n--- a/src/Coordination/KeeperServer.h\n+++ b/src/Coordination/KeeperServer.h\n@@ -131,6 +131,10 @@ class KeeperServer\n     /// Wait configuration update for action. Used by followers.\n     /// Return true if update was successfully received.\n     bool waitConfigurationUpdate(const ConfigUpdateAction & task);\n+\n+    uint64_t createSnapshot();\n+\n+    KeeperLogInfo getKeeperLogInfo();\n };\n \n }\n",
  "test_patch": "diff --git a/tests/integration/test_keeper_four_word_command/test.py b/tests/integration/test_keeper_four_word_command/test.py\nindex 30abc7422c49..4559904f8b74 100644\n--- a/tests/integration/test_keeper_four_word_command/test.py\n+++ b/tests/integration/test_keeper_four_word_command/test.py\n@@ -596,3 +596,48 @@ def test_cmd_wchp(started_cluster):\n         assert \"/test_4lw_normal_node_1\" in list_data\n     finally:\n         destroy_zk_client(zk)\n+\n+\n+def test_cmd_csnp(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        data = keeper_utils.send_4lw_cmd(cluster, node1, cmd=\"csnp\")\n+        try:\n+            int(data)\n+            assert True\n+        except ValueError:\n+            assert False\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_lgif(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=100)\n+\n+        data = keeper_utils.send_4lw_cmd(cluster, node1, cmd=\"lgif\")\n+        print(data)\n+        reader = csv.reader(data.split(\"\\n\"), delimiter=\"\\t\")\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                result[row[0]] = row[1]\n+\n+        assert int(result[\"first_log_idx\"]) == 1\n+        assert int(result[\"first_log_term\"]) == 1\n+        assert int(result[\"last_log_idx\"]) >= 1\n+        assert int(result[\"last_log_term\"]) == 1\n+        assert int(result[\"last_committed_log_idx\"]) >= 1\n+        assert int(result[\"leader_committed_log_idx\"]) >= 1\n+        assert int(result[\"target_committed_log_idx\"]) >= 1\n+        assert int(result[\"last_snapshot_idx\"]) >= 1\n+    finally:\n+        destroy_zk_client(zk)\n",
  "problem_statement": "Support manually snapshot for Keeper.\n> (you don't have to strictly follow this form)\r\n\r\n**Use case**\r\n\r\nSupport manually snapshot for Keeper.\r\n\r\n**Describe the solution you'd like**\r\n\r\nThrought 4lw commands, such as `csnp`.\r\n\r\n\n",
  "hints_text": "@alesapin @antonio2368 Wether the idea is ok, if not I will close the issue.\n@JackyWoo it makes sense to me.\r\nWhat about the snapshot after it, should it be after `snapshot_distance`, or should the snapshot creation after commits ignore the manually created one?\nThe next snapshot will be created after `snapshot_distance `.\r\n\r\nhttps://github.com/eBay/NuRaft/blob/e1a5fb43443fc9410e5e64d0f64b5eef4500986a/src/handle_commit.cxx#L499-L502",
  "created_at": "2022-09-26T10:33:00Z",
  "modified_files": [
    "contrib/NuRaft",
    "docs/en/operations/clickhouse-keeper.md",
    "src/Coordination/CoordinationSettings.cpp",
    "src/Coordination/FourLetterCommand.cpp",
    "src/Coordination/FourLetterCommand.h",
    "src/Coordination/Keeper4LWInfo.h",
    "src/Coordination/KeeperDispatcher.h",
    "src/Coordination/KeeperServer.cpp",
    "src/Coordination/KeeperServer.h"
  ],
  "modified_test_files": [
    "tests/integration/test_keeper_four_word_command/test.py"
  ]
}