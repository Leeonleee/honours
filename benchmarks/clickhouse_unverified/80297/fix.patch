diff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp
index 99e239cd1d33..385980c43349 100644
--- a/src/Parsers/ASTDropQuery.cpp
+++ b/src/Parsers/ASTDropQuery.cpp
@@ -1,6 +1,7 @@
 #include <Parsers/ASTDropQuery.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTExpressionList.h>
+#include <Parsers/ASTLiteral.h>
 #include <Common/quoteString.h>
 #include <IO/Operators.h>
 
@@ -109,11 +110,16 @@ void ASTDropQuery::formatQueryImpl(WriteBuffer & ostr, const FormatSettings & se
     }
 
     if (!like.empty())
+    {
         ostr << (settings.hilite ? hilite_keyword : "")
-                      << (not_like ? " NOT" : "")
-                      << (case_insensitive_like ? " ILIKE " : " LIKE")
-                      << (settings.hilite ? hilite_none : "")
-                      << DB::quote << like;
+            << (not_like ? " NOT" : "")
+            << (case_insensitive_like ? " ILIKE " : " LIKE")
+            << (settings.hilite ? hilite_none : "");
+        if (settings.hilite)
+            highlightStringWithMetacharacters(quoteString(like), ostr, "%_");
+        else
+            ostr << quoteString(like);
+    }
 
     formatOnCluster(ostr, settings);
 
diff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp
index cb2a0eec9ecc..c5617987bfef 100644
--- a/src/Parsers/ASTFunction.cpp
+++ b/src/Parsers/ASTFunction.cpp
@@ -204,54 +204,6 @@ ASTPtr ASTFunction::toLiteral() const
 }
 
 
-/** A special hack. If it's [I]LIKE or NOT [I]LIKE expression and the right hand side is a string literal,
-  *  we will highlight unescaped metacharacters % and _ in string literal for convenience.
-  * Motivation: most people are unaware that _ is a metacharacter and forgot to properly escape it with two backslashes.
-  * With highlighting we make it clearly obvious.
-  *
-  * Another case is regexp match. Suppose the user types match(URL, 'www.clickhouse.com'). It often means that the user is unaware that . is a metacharacter.
-  */
-static bool highlightStringLiteralWithMetacharacters(const ASTPtr & node, WriteBuffer & ostr, const char * metacharacters)
-{
-    if (const auto * literal = node->as<ASTLiteral>())
-    {
-        if (literal->value.getType() == Field::Types::String)
-        {
-            auto string = applyVisitor(FieldVisitorToString(), literal->value);
-
-            unsigned escaping = 0;
-            for (auto c : string)
-            {
-                if (c == '\\')
-                {
-                    ostr << c;
-                    if (escaping == 2)
-                        escaping = 0;
-                    ++escaping;
-                }
-                else if (nullptr != strchr(metacharacters, c))
-                {
-                    if (escaping == 2)      /// Properly escaped metacharacter
-                        ostr << c;
-                    else                    /// Unescaped metacharacter
-                        ostr << "\033[1;35m" << c << "\033[0m";
-                    escaping = 0;
-                }
-                else
-                {
-                    ostr << c;
-                    escaping = 0;
-                }
-            }
-
-            return true;
-        }
-    }
-
-    return false;
-}
-
-
 ASTSelectWithUnionQuery * ASTFunction::tryGetQueryArgument() const
 {
     if (arguments && arguments->children.size() == 1)
diff --git a/src/Parsers/ASTLiteral.cpp b/src/Parsers/ASTLiteral.cpp
index c457895ba575..8b4b4c631cf9 100644
--- a/src/Parsers/ASTLiteral.cpp
+++ b/src/Parsers/ASTLiteral.cpp
@@ -2,6 +2,7 @@
 #include <Common/SipHash.h>
 #include <Common/FieldVisitorToString.h>
 #include <Common/FieldVisitorHash.h>
+#include <Common/quoteString.h>
 #include <DataTypes/IDataType.h>
 #include <Parsers/ASTLiteral.h>
 #include <IO/WriteHelpers.h>
@@ -162,4 +163,48 @@ void ASTLiteral::formatImplWithoutAlias(WriteBuffer & ostr, const FormatSettings
         ostr << applyVisitor(FieldVisitorToStringPostgreSQL(), value);
 }
 
+
+bool highlightStringLiteralWithMetacharacters(const ASTPtr & node, WriteBuffer & ostr, const char * metacharacters)
+{
+    if (const auto * literal = node->as<ASTLiteral>())
+    {
+        if (literal->value.getType() == Field::Types::String)
+        {
+            auto string = applyVisitor(FieldVisitorToString(), literal->value);
+            highlightStringWithMetacharacters(string, ostr, metacharacters);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void highlightStringWithMetacharacters(const String & string, WriteBuffer & ostr, const char * metacharacters)
+{
+    unsigned escaping = 0;
+    for (auto c : string)
+    {
+        if (c == '\\')
+        {
+            ostr << c;
+            if (escaping == 2)
+                escaping = 0;
+            ++escaping;
+        }
+        else if (nullptr != strchr(metacharacters, c))
+        {
+            if (escaping == 2)      /// Properly escaped metacharacter
+                ostr << c;
+            else                    /// Unescaped metacharacter
+                ostr << "\033[1;35m" << c << "\033[0m";
+            escaping = 0;
+        }
+        else
+        {
+            ostr << c;
+            escaping = 0;
+        }
+    }
+}
+
 }
diff --git a/src/Parsers/ASTLiteral.h b/src/Parsers/ASTLiteral.h
index f36a428352a6..d9c72eec0a21 100644
--- a/src/Parsers/ASTLiteral.h
+++ b/src/Parsers/ASTLiteral.h
@@ -63,4 +63,15 @@ class ASTLiteral : public ASTWithAlias
     void appendColumnNameImplLegacy(WriteBuffer & ostr) const;
 };
 
+
+/** A special UX improvement. If it's [I]LIKE or NOT [I]LIKE expression and the right hand side is a string literal,
+  *  we will highlight unescaped metacharacters % and _ in string literal for convenience.
+  * Motivation: most people are unaware that _ is a metacharacter and forgot to properly escape it with two backslashes.
+  * With highlighting we make it clearly obvious.
+  *
+  * Another case is regexp match. Suppose the user types match(URL, 'www.clickhouse.com'). It often means that the user is unaware that . is a metacharacter.
+  */
+bool highlightStringLiteralWithMetacharacters(const ASTPtr & node, WriteBuffer & ostr, const char * metacharacters);
+void highlightStringWithMetacharacters(const String & string, WriteBuffer & ostr, const char * metacharacters);
+
 }
diff --git a/src/Parsers/ASTShowColumnsQuery.cpp b/src/Parsers/ASTShowColumnsQuery.cpp
index 7c7fd6bbb38c..3dd4d6bcff18 100644
--- a/src/Parsers/ASTShowColumnsQuery.cpp
+++ b/src/Parsers/ASTShowColumnsQuery.cpp
@@ -1,4 +1,5 @@
 #include <Parsers/ASTShowColumnsQuery.h>
+#include <Parsers/ASTLiteral.h>
 
 #include <iomanip>
 #include <Common/quoteString.h>
@@ -30,11 +31,17 @@ void ASTShowColumnsQuery::formatQueryImpl(WriteBuffer & ostr, const FormatSettin
 
 
     if (!like.empty())
-        ostr << (settings.hilite ? hilite_keyword : "")
-                      << (not_like ? " NOT" : "")
-                      << (case_insensitive_like ? " ILIKE " : " LIKE")
-                      << (settings.hilite ? hilite_none : "")
-                      << DB::quote << like;
+    {
+        ostr
+            << (settings.hilite ? hilite_keyword : "")
+            << (not_like ? " NOT" : "")
+            << (case_insensitive_like ? " ILIKE " : " LIKE")
+            << (settings.hilite ? hilite_none : "");
+        if (settings.hilite)
+            highlightStringWithMetacharacters(quoteString(like), ostr, "%_");
+        else
+            ostr << quoteString(like);
+    }
 
     if (where_expression)
     {
diff --git a/src/Parsers/ASTShowFunctionsQuery.cpp b/src/Parsers/ASTShowFunctionsQuery.cpp
index b9e07120c0d3..f1215c14333e 100644
--- a/src/Parsers/ASTShowFunctionsQuery.cpp
+++ b/src/Parsers/ASTShowFunctionsQuery.cpp
@@ -1,4 +1,6 @@
 #include <Parsers/ASTShowFunctionsQuery.h>
+#include <Parsers/ASTLiteral.h>
+#include <Common/quoteString.h>
 
 
 namespace DB
@@ -17,8 +19,14 @@ void ASTShowFunctionsQuery::formatQueryImpl(WriteBuffer & ostr, const FormatSett
     ostr << (settings.hilite ? hilite_keyword : "") << "SHOW FUNCTIONS" << (settings.hilite ? hilite_none : "");
 
     if (!like.empty())
+    {
         ostr << (settings.hilite ? hilite_keyword : "") << (case_insensitive_like ? " ILIKE " : " LIKE ")
-                      << (settings.hilite ? hilite_none : "") << DB::quote << like;
+            << (settings.hilite ? hilite_none : "");
+        if (settings.hilite)
+            highlightStringWithMetacharacters(quoteString(like), ostr, "%_");
+        else
+            ostr << quoteString(like);
+    }
 }
 
 }
diff --git a/src/Parsers/ASTShowTablesQuery.cpp b/src/Parsers/ASTShowTablesQuery.cpp
index 302930805c5f..95c31cee3a9e 100644
--- a/src/Parsers/ASTShowTablesQuery.cpp
+++ b/src/Parsers/ASTShowTablesQuery.cpp
@@ -1,6 +1,7 @@
 #include <iomanip>
 #include <Parsers/ASTIdentifier_fwd.h>
 #include <Parsers/ASTShowTablesQuery.h>
+#include <Parsers/ASTLiteral.h>
 #include <Common/quoteString.h>
 #include <IO/Operators.h>
 
@@ -28,12 +29,18 @@ String ASTShowTablesQuery::getFrom() const
 void ASTShowTablesQuery::formatLike(WriteBuffer & ostr, const FormatSettings & settings) const
 {
     if (!like.empty())
+    {
         ostr
             << (settings.hilite ? hilite_keyword : "")
             << (not_like ? " NOT" : "")
             << (case_insensitive_like ? " ILIKE " : " LIKE ")
-            << (settings.hilite ? hilite_none : "")
-            << DB::quote << like;
+            << (settings.hilite ? hilite_none : "");
+
+        if (settings.hilite)
+            highlightStringWithMetacharacters(quoteString(like), ostr, "%_");
+        else
+            ostr << quoteString(like);
+    }
 }
 
 void ASTShowTablesQuery::formatLimit(WriteBuffer & ostr, const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
