{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13709,
  "instance_id": "ClickHouse__ClickHouse-13709",
  "issue_numbers": [
    "13705"
  ],
  "base_commit": "09a72d0c64ef1efeff54dc47b9943ea61008fb62",
  "patch": "diff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex cb5f6604a931..d9c619809fc7 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -388,13 +388,14 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n         {\n             for (size_t j = 0; j < UNROLL_COUNT; ++j)\n             {\n-                if (has_data[j * 256 + k])\n+                size_t idx = j * 256 + k;\n+                if (has_data[idx])\n                 {\n                     AggregateDataPtr & place = map[k];\n                     if (unlikely(!place))\n                         init(place);\n \n-                    func.merge(place + place_offset, reinterpret_cast<const char *>(&places[256 * j + k]), arena);\n+                    func.merge(place + place_offset, reinterpret_cast<const char *>(&places[idx]), nullptr);\n                 }\n             }\n         }\ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex 9a0ee7fed861..8bfa4801a588 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -449,7 +449,6 @@ void NO_INLINE Aggregator::executeImpl(\n     typename Method::State state(key_columns, key_sizes, aggregation_state_cache);\n \n     if (!no_more_keys)\n-        //executeImplCase<false>(method, state, aggregates_pool, rows, aggregate_instructions, overflow_row);\n         executeImplBatch(method, state, aggregates_pool, rows, aggregate_instructions);\n     else\n         executeImplCase<true>(method, state, aggregates_pool, rows, aggregate_instructions, overflow_row);\n@@ -534,22 +533,36 @@ void NO_INLINE Aggregator::executeImplBatch(\n     /// Optimization for special case when aggregating by 8bit key.\n     if constexpr (std::is_same_v<Method, typename decltype(AggregatedDataVariants::key8)::element_type>)\n     {\n+        /// We use another method if there are aggregate functions with -Array combinator.\n+        bool has_arrays = false;\n         for (AggregateFunctionInstruction * inst = aggregate_instructions; inst->that; ++inst)\n         {\n-            inst->batch_that->addBatchLookupTable8(\n-                rows,\n-                reinterpret_cast<AggregateDataPtr *>(method.data.data()),\n-                inst->state_offset,\n-                [&](AggregateDataPtr & aggregate_data)\n-                {\n-                    aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);\n-                    createAggregateStates(aggregate_data);\n-                },\n-                state.getKeyData(),\n-                inst->batch_arguments,\n-                aggregates_pool);\n+            if (inst->offsets)\n+            {\n+                has_arrays = true;\n+                break;\n+            }\n+        }\n+\n+        if (!has_arrays)\n+        {\n+            for (AggregateFunctionInstruction * inst = aggregate_instructions; inst->that; ++inst)\n+            {\n+                inst->batch_that->addBatchLookupTable8(\n+                    rows,\n+                    reinterpret_cast<AggregateDataPtr *>(method.data.data()),\n+                    inst->state_offset,\n+                    [&](AggregateDataPtr & aggregate_data)\n+                    {\n+                        aggregate_data = aggregates_pool->alignedAlloc(total_size_of_aggregate_states, align_aggregate_states);\n+                        createAggregateStates(aggregate_data);\n+                    },\n+                    state.getKeyData(),\n+                    inst->batch_arguments,\n+                    aggregates_pool);\n+            }\n+            return;\n         }\n-        return;\n     }\n \n     /// Generic case.\n@@ -629,7 +642,7 @@ void NO_INLINE Aggregator::executeOnIntervalWithoutKeyImpl(\n \n \n void Aggregator::prepareAggregateInstructions(Columns columns, AggregateColumns & aggregate_columns, Columns & materialized_columns,\n-                                              AggregateFunctionInstructions & aggregate_functions_instructions, NestedColumnsHolder & nested_columns_holder)\n+    AggregateFunctionInstructions & aggregate_functions_instructions, NestedColumnsHolder & nested_columns_holder)\n {\n     for (size_t i = 0; i < params.aggregates_size; ++i)\n         aggregate_columns[i].resize(params.aggregates[i].arguments.size());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01441_array_combinator.reference b/tests/queries/0_stateless/01441_array_combinator.reference\nnew file mode 100644\nindex 000000000000..7f1bc308d222\n--- /dev/null\n+++ b/tests/queries/0_stateless/01441_array_combinator.reference\n@@ -0,0 +1,10 @@\n+0\t0\n+1\t0\n+2\t0\n+3\t0\n+4\t0\n+5\t0\n+6\t0\n+7\t0\n+8\t0\n+9\t0\ndiff --git a/tests/queries/0_stateless/01441_array_combinator.sql b/tests/queries/0_stateless/01441_array_combinator.sql\nnew file mode 100644\nindex 000000000000..68fd050940de\n--- /dev/null\n+++ b/tests/queries/0_stateless/01441_array_combinator.sql\n@@ -0,0 +1,1 @@\n+SELECT number % 100 AS k, sumArray(emptyArrayUInt8()) AS v FROM numbers(10) GROUP BY k;\n",
  "problem_statement": "A bug in GROUP BY in version 20.7 (unreleased)\n**Describe the bug**\r\n```\r\nSELECT number % 100 AS k, sumArray(emptyArrayUInt8()) AS v FROM numbers(10) GROUP BY k\r\n```\r\nFails under ASan.\r\n\n",
  "hints_text": "",
  "created_at": "2020-08-14T06:53:22Z",
  "modified_files": [
    "src/AggregateFunctions/IAggregateFunction.h",
    "src/Interpreters/Aggregator.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01441_array_combinator.reference",
    "b/tests/queries/0_stateless/01441_array_combinator.sql"
  ]
}