diff --git a/src/Analyzer/QueryTreeBuilder.cpp b/src/Analyzer/QueryTreeBuilder.cpp
index df80f46b3cd1..7f7d7a828854 100644
--- a/src/Analyzer/QueryTreeBuilder.cpp
+++ b/src/Analyzer/QueryTreeBuilder.cpp
@@ -444,8 +444,8 @@ QueryTreeNodePtr QueryTreeBuilder::buildSortList(const ASTPtr & order_by_express
             nulls_sort_direction = order_by_element.nulls_direction == 1 ? SortDirection::ASCENDING : SortDirection::DESCENDING;
 
         std::shared_ptr<Collator> collator;
-        if (order_by_element.collation)
-            collator = std::make_shared<Collator>(order_by_element.collation->as<ASTLiteral &>().value.get<String &>());
+        if (order_by_element.getCollation())
+            collator = std::make_shared<Collator>(order_by_element.getCollation()->as<ASTLiteral &>().value.get<String &>());
 
         const auto & sort_expression_ast = order_by_element.children.at(0);
         auto sort_expression = buildExpression(sort_expression_ast, context);
@@ -455,12 +455,12 @@ QueryTreeNodePtr QueryTreeBuilder::buildSortList(const ASTPtr & order_by_express
             std::move(collator),
             order_by_element.with_fill);
 
-        if (order_by_element.fill_from)
-            sort_node->getFillFrom() = buildExpression(order_by_element.fill_from, context);
-        if (order_by_element.fill_to)
-            sort_node->getFillTo() = buildExpression(order_by_element.fill_to, context);
-        if (order_by_element.fill_step)
-            sort_node->getFillStep() = buildExpression(order_by_element.fill_step, context);
+        if (order_by_element.getFillFrom())
+            sort_node->getFillFrom() = buildExpression(order_by_element.getFillFrom(), context);
+        if (order_by_element.getFillTo())
+            sort_node->getFillTo() = buildExpression(order_by_element.getFillTo(), context);
+        if (order_by_element.getFillStep())
+            sort_node->getFillStep() = buildExpression(order_by_element.getFillStep(), context);
 
         list_node->getNodes().push_back(std::move(sort_node));
     }
diff --git a/src/Analyzer/SortNode.cpp b/src/Analyzer/SortNode.cpp
index 8e9913af442c..b9d93511b84b 100644
--- a/src/Analyzer/SortNode.cpp
+++ b/src/Analyzer/SortNode.cpp
@@ -120,17 +120,18 @@ ASTPtr SortNode::toASTImpl(const ConvertToASTOptions & options) const
 
     result->nulls_direction_was_explicitly_specified = nulls_sort_direction.has_value();
 
-    result->with_fill = with_fill;
-    result->fill_from = hasFillFrom() ? getFillFrom()->toAST(options) : nullptr;
-    result->fill_to = hasFillTo() ? getFillTo()->toAST(options) : nullptr;
-    result->fill_step = hasFillStep() ? getFillStep()->toAST(options) : nullptr;
     result->children.push_back(getExpression()->toAST(options));
 
     if (collator)
-    {
-        result->children.push_back(std::make_shared<ASTLiteral>(Field(collator->getLocale())));
-        result->collation = result->children.back();
-    }
+        result->setCollation(std::make_shared<ASTLiteral>(Field(collator->getLocale())));
+
+    result->with_fill = with_fill;
+    if (hasFillFrom())
+        result->setFillFrom(getFillFrom()->toAST(options));
+    if (hasFillTo())
+        result->setFillTo(getFillTo()->toAST(options));
+    if (hasFillStep())
+        result->setFillStep(getFillStep()->toAST(options));
 
     return result;
 }
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 6bbf03bb1e07..5864b35799e5 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -1165,13 +1165,13 @@ static FillColumnDescription getWithFillDescription(const ASTOrderByElement & or
 {
     FillColumnDescription descr;
 
-    if (order_by_elem.fill_from)
-        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.fill_from, context);
-    if (order_by_elem.fill_to)
-        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.fill_to, context);
+    if (order_by_elem.getFillFrom())
+        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.getFillFrom(), context);
+    if (order_by_elem.getFillTo())
+        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.getFillTo(), context);
 
-    if (order_by_elem.fill_step)
-        std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.fill_step, context);
+    if (order_by_elem.getFillStep())
+        std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.getFillStep(), context);
     else
         descr.fill_step = order_by_elem.direction;
 
@@ -1217,8 +1217,8 @@ SortDescription InterpreterSelectQuery::getSortDescription(const ASTSelectQuery
         const auto & order_by_elem = elem->as<ASTOrderByElement &>();
 
         std::shared_ptr<Collator> collator;
-        if (order_by_elem.collation)
-            collator = std::make_shared<Collator>(order_by_elem.collation->as<ASTLiteral &>().value.get<String>());
+        if (order_by_elem.getCollation())
+            collator = std::make_shared<Collator>(order_by_elem.getCollation()->as<ASTLiteral &>().value.get<String>());
 
         if (order_by_elem.with_fill)
         {
diff --git a/src/Interpreters/RewriteOrderByVisitor.cpp b/src/Interpreters/RewriteOrderByVisitor.cpp
index 694dec84b7a0..26817b70dc05 100644
--- a/src/Interpreters/RewriteOrderByVisitor.cpp
+++ b/src/Interpreters/RewriteOrderByVisitor.cpp
@@ -39,9 +39,8 @@ void RewriteOrderBy::visit(ASTPtr & ast, Data &)
         {
             // clone w/o children
             auto clone = std::make_shared<ASTOrderByElement>(*order_by_elem);
-            clone->children.clear();
 
-            clone->children.emplace_back(identifier);
+            clone->children[0] = identifier;
             new_order_by->children.emplace_back(clone);
         }
         if (!new_order_by->children.empty())
diff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp
index b71a8e3681d9..a341dae32fa1 100644
--- a/src/Interpreters/TreeOptimizer.cpp
+++ b/src/Interpreters/TreeOptimizer.cpp
@@ -277,7 +277,7 @@ void optimizeDuplicatesInOrderBy(const ASTSelectQuery * select_query)
         const auto & order_by_elem = elem->as<ASTOrderByElement &>();
 
         if (order_by_elem.with_fill /// Always keep elements WITH FILL as they affects other.
-            || elems_set.emplace(name, order_by_elem.collation ? order_by_elem.collation->getColumnName() : "").second)
+            || elems_set.emplace(name, order_by_elem.getCollation() ? order_by_elem.getCollation()->getColumnName() : "").second)
             unique_elems.emplace_back(elem);
     }
 
diff --git a/src/Parsers/ASTOrderByElement.cpp b/src/Parsers/ASTOrderByElement.cpp
index 318849812aa5..be0416359a18 100644
--- a/src/Parsers/ASTOrderByElement.cpp
+++ b/src/Parsers/ASTOrderByElement.cpp
@@ -31,7 +31,7 @@ void ASTOrderByElement::formatImpl(const FormatSettings & settings, FormatState
             << (settings.hilite ? hilite_none : "");
     }
 
-    if (collation)
+    if (auto collation = getCollation())
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "") << " COLLATE " << (settings.hilite ? hilite_none : "");
         collation->formatImpl(settings, state, frame);
@@ -40,17 +40,17 @@ void ASTOrderByElement::formatImpl(const FormatSettings & settings, FormatState
     if (with_fill)
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "") << " WITH FILL" << (settings.hilite ? hilite_none : "");
-        if (fill_from)
+        if (auto fill_from = getFillFrom())
         {
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "");
             fill_from->formatImpl(settings, state, frame);
         }
-        if (fill_to)
+        if (auto fill_to = getFillTo())
         {
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " TO " << (settings.hilite ? hilite_none : "");
             fill_to->formatImpl(settings, state, frame);
         }
-        if (fill_step)
+        if (auto fill_step = getFillStep())
         {
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " STEP " << (settings.hilite ? hilite_none : "");
             fill_step->formatImpl(settings, state, frame);
diff --git a/src/Parsers/ASTOrderByElement.h b/src/Parsers/ASTOrderByElement.h
index 4cebc30be31b..6edf84d7bde9 100644
--- a/src/Parsers/ASTOrderByElement.h
+++ b/src/Parsers/ASTOrderByElement.h
@@ -10,18 +10,34 @@ namespace DB
   */
 class ASTOrderByElement : public IAST
 {
+private:
+    enum class Child : uint8_t
+    {
+        EXPRESSION,
+        COLLATION,
+        FILL_FROM,
+        FILL_TO,
+        FILL_STEP,
+    };
+
 public:
     int direction = 0; /// 1 for ASC, -1 for DESC
     int nulls_direction = 0; /// Same as direction for NULLS LAST, opposite for NULLS FIRST.
     bool nulls_direction_was_explicitly_specified = false;
 
+    bool with_fill = false;
+
     /** Collation for locale-specific string comparison. If empty, then sorting done by bytes. */
-    ASTPtr collation;
+    void setCollation(ASTPtr node) { setChild(Child::COLLATION, node); }
+    void setFillFrom(ASTPtr node)  { setChild(Child::FILL_FROM, node); }
+    void setFillTo(ASTPtr node)    { setChild(Child::FILL_TO, node);   }
+    void setFillStep(ASTPtr node)  { setChild(Child::FILL_STEP, node); }
 
-    bool with_fill = false;
-    ASTPtr fill_from;
-    ASTPtr fill_to;
-    ASTPtr fill_step;
+    /** Collation for locale-specific string comparison. If empty, then sorting done by bytes. */
+    ASTPtr getCollation() const { return getChild(Child::COLLATION); }
+    ASTPtr getFillFrom()  const { return getChild(Child::FILL_FROM); }
+    ASTPtr getFillTo()    const { return getChild(Child::FILL_TO);   }
+    ASTPtr getFillStep()  const { return getChild(Child::FILL_STEP); }
 
     String getID(char) const override { return "OrderByElement"; }
 
@@ -36,6 +52,34 @@ class ASTOrderByElement : public IAST
 
 protected:
     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;
+private:
+
+    ASTPtr getChild(Child child) const
+    {
+        auto it = positions.find(child);
+        if (it != positions.end())
+            return children[it->second];
+        return {};
+    }
+
+    void setChild(Child child, ASTPtr node)
+    {
+        if (node == nullptr)
+            return;
+
+        auto it = positions.find(child);
+        if (it != positions.end())
+        {
+            children[it->second] = node;
+        }
+        else
+        {
+            positions[child] = children.size();
+            children.push_back(node);
+        }
+    }
+
+    std::unordered_map<Child, size_t> positions;
 };
 
 }
diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index 67f4a306292d..d4ad210b3151 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -2120,17 +2120,16 @@ bool ParserOrderByElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expect
 
     auto elem = std::make_shared<ASTOrderByElement>();
 
+    elem->children.push_back(expr_elem);
+
     elem->direction = direction;
     elem->nulls_direction = nulls_direction;
     elem->nulls_direction_was_explicitly_specified = nulls_direction_was_explicitly_specified;
-    elem->collation = locale_node;
+    elem->setCollation(locale_node);
     elem->with_fill = has_with_fill;
-    elem->fill_from = fill_from;
-    elem->fill_to = fill_to;
-    elem->fill_step = fill_step;
-    elem->children.push_back(expr_elem);
-    if (locale_node)
-        elem->children.push_back(locale_node);
+    elem->setFillFrom(fill_from);
+    elem->setFillTo(fill_to);
+    elem->setFillStep(fill_step);
 
     node = elem;
 
