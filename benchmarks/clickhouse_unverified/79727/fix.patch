diff --git a/src/Analyzer/Resolve/CorrelatedColumnsCollector.h b/src/Analyzer/Resolve/CorrelatedColumnsCollector.h
new file mode 100644
index 000000000000..f960c859c7ec
--- /dev/null
+++ b/src/Analyzer/Resolve/CorrelatedColumnsCollector.h
@@ -0,0 +1,77 @@
+#pragma once
+
+#include <Analyzer/IQueryTreeNode.h>
+#include <Analyzer/Utils.h>
+
+#include <Analyzer/Resolve/IdentifierResolveScope.h>
+
+#include <unordered_map>
+#include <vector>
+
+namespace DB
+{
+
+class IQueryTreeNode;
+using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;
+using QueryTreeNodes = std::vector<QueryTreeNodePtr>;
+
+struct CorrelatedColumnsCollector
+{
+    explicit CorrelatedColumnsCollector(
+        const QueryTreeNodePtr & expression,
+        const IdentifierResolveScope * current_scope,
+        const std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> & map
+    )
+        : node_to_scope_map(map)
+        , correlated_columns()
+    {
+        visitExpression(expression, current_scope);
+    }
+
+    bool has() const { return !correlated_columns.empty(); }
+
+    const QueryTreeNodes & get() const { return correlated_columns; }
+
+private:
+    void visitExpression(const QueryTreeNodePtr & expression, const IdentifierResolveScope * current_scope)
+    {
+        QueryTreeNodes nodes_to_process = { expression };
+        while (!nodes_to_process.empty())
+        {
+            auto current = nodes_to_process.back();
+            nodes_to_process.pop_back();
+
+            auto current_node_type = current->getNodeType();
+
+            /// Change scope if expression is a QueryNode.
+            /// Columns in these subqueries can appear from table expressions
+            /// that are registered in the child scope.
+            if (current_node_type == QueryTreeNodeType::QUERY)
+            {
+                auto it = node_to_scope_map.find(current);
+                if (it != node_to_scope_map.end() && current != current_scope->scope_node)
+                {
+                    visitExpression(current, &it->second);
+                    continue;
+                }
+            }
+
+            if (current_node_type == QueryTreeNodeType::COLUMN)
+            {
+                if (checkCorrelatedColumn(current_scope, current))
+                    correlated_columns.push_back(current);
+            }
+
+            for (const auto & child : current->getChildren())
+            {
+                if (child)
+                    nodes_to_process.push_back(child);
+            }
+        }
+    }
+
+    const std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> & node_to_scope_map;
+    QueryTreeNodes correlated_columns;
+};
+
+}
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index a018b07903fa..bb3597d7a8a1 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -1,4 +1,3 @@
-#include <Interpreters/ProcessorsProfileLog.h>
 #include <Common/FieldVisitorToString.h>
 
 #include <Columns/ColumnNullable.h>
@@ -20,16 +19,18 @@
 #include <Functions/exists.h>
 #include <Functions/grouping.h>
 
-#include <TableFunctions/TableFunctionFactory.h>
 #include <Formats/FormatFactory.h>
 
+#include <TableFunctions/TableFunctionFactory.h>
+
 #include <Storages/IStorage.h>
 #include <Storages/StorageJoin.h>
 
-#include <Interpreters/misc.h>
 #include <Interpreters/convertFieldToType.h>
+#include <Interpreters/misc.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
 #include <Interpreters/InterpreterSelectQueryAnalyzer.h>
+#include <Interpreters/ProcessorsProfileLog.h>
 
 #include <Processors/Executors/PullingAsyncPipelineExecutor.h>
 
@@ -61,6 +62,7 @@
 #include <Analyzer/FunctionSecretArgumentsFinderTreeNode.h>
 #include <Analyzer/RecursiveCTE.h>
 
+#include <Analyzer/Resolve/CorrelatedColumnsCollector.h>
 #include <Analyzer/Resolve/IdentifierResolveScope.h>
 #include <Analyzer/Resolve/QueryAnalyzer.h>
 #include <Analyzer/Resolve/QueryExpressionsAliasVisitor.h>
@@ -69,10 +71,10 @@
 #include <Analyzer/Resolve/TableFunctionsWithClusterAlternativesVisitor.h>
 #include <Analyzer/Resolve/TypoCorrection.h>
 
-#include <Planner/PlannerActionsVisitor.h>
-
 #include <Core/Settings.h>
 
+#include <ranges>
+
 namespace ProfileEvents
 {
     extern const Event ScalarSubqueriesGlobalCacheHit;
@@ -161,7 +163,7 @@ QueryAnalyzer::~QueryAnalyzer() = default;
 
 void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)
 {
-    IdentifierResolveScope scope(node, nullptr /*parent_scope*/);
+    IdentifierResolveScope & scope = createIdentifierResolveScope(node, /*parent_scope=*/ nullptr);
 
     if (!scope.context)
         scope.context = context;
@@ -231,7 +233,7 @@ void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & ta
 
 void QueryAnalyzer::resolveConstantExpression(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)
 {
-    IdentifierResolveScope scope(node, nullptr /*parent_scope*/);
+    IdentifierResolveScope & scope = createIdentifierResolveScope(node, /*parent_scope=*/ nullptr);
 
     if (!scope.context)
         scope.context = context;
@@ -292,6 +294,12 @@ std::optional<JoinTableSide> QueryAnalyzer::getColumnSideFromJoinTree(const Quer
     return {};
 }
 
+IdentifierResolveScope & QueryAnalyzer::createIdentifierResolveScope(const QueryTreeNodePtr & scope_node, IdentifierResolveScope * parent_scope)
+{
+    auto [it, _] = node_to_scope_map.emplace(scope_node, IdentifierResolveScope{scope_node, parent_scope});
+    return it->second;
+}
+
 ProjectionName QueryAnalyzer::calculateFunctionProjectionName(const QueryTreeNodePtr & function_node, const ProjectionNames & parameters_projection_names,
     const ProjectionNames & arguments_projection_names)
 {
@@ -1383,31 +1391,16 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const
     if (identifier_lookup.isFunctionLookup())
         return resolve_result;
 
-    QueryTreeNodes nodes_to_process = { resolved_identifier };
-    while (!nodes_to_process.empty())
+    CorrelatedColumnsCollector correlated_columns_collector{resolved_identifier, identifier_resolve_context.scope_to_resolve_alias_expression, node_to_scope_map};
+    if (correlated_columns_collector.has() && !scope.context->getSettingsRef()[Setting::allow_experimental_correlated_subqueries])
     {
-        auto current = nodes_to_process.back();
-        nodes_to_process.pop_back();
-        if (current->getNodeType() == QueryTreeNodeType::COLUMN)
-        {
-            auto is_correlated_column = checkCorrelatedColumn(&scope, current);
-            if (is_correlated_column && !scope.context->getSettingsRef()[Setting::allow_experimental_correlated_subqueries])
-            {
-                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
-                    "Resolved identifier '{}' in parent scope to expression '{}' with correlated column '{}'"
-                    " (Enable 'allow_experimental_correlated_subqueries' setting to allow correlated subqueries execution). In scope {}",
-                    identifier_lookup.identifier.getFullName(),
-                    resolved_identifier->formatASTForErrorMessage(),
-                    current->as<ColumnNode>()->getColumnName(),
-                    scope.scope_node->formatASTForErrorMessage());
-            }
-        }
-
-        for (const auto & child : current->getChildren())
-        {
-            if (child)
-                nodes_to_process.push_back(child);
-        }
+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+            "Resolved identifier '{}' in parent scope to expression '{}' with correlated columns '{}'"
+            " (Enable 'allow_experimental_correlated_subqueries' setting to allow correlated subqueries execution). In scope {}",
+            identifier_lookup.identifier.getFullName(),
+            resolved_identifier->formatASTForErrorMessage(),
+            fmt::join(correlated_columns_collector.get() | std::views::transform([](const auto & e) { return e->template as<ColumnNode>()->getColumnName(); }), "', '"),
+            scope.scope_node->formatASTForErrorMessage());
     }
 
     return resolve_result;
@@ -2328,7 +2321,7 @@ ProjectionNames QueryAnalyzer::resolveMatcher(QueryTreeNodePtr & matcher_node, I
                 if (apply_transformer->getApplyTransformerType() == ApplyColumnTransformerType::LAMBDA)
                 {
                     auto lambda_expression_to_resolve = expression_node->clone();
-                    IdentifierResolveScope lambda_scope(expression_node, &scope /*parent_scope*/);
+                    auto & lambda_scope = createIdentifierResolveScope(lambda_expression_to_resolve, /*parent_scope=*/&scope);
                     node_projection_names = resolveLambda(expression_node, lambda_expression_to_resolve, {node}, lambda_scope);
                     auto & lambda_expression_to_resolve_typed = lambda_expression_to_resolve->as<LambdaNode &>();
                     node = lambda_expression_to_resolve_typed.getExpression();
@@ -3122,7 +3115,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
         auto first_argument_type = in_first_argument->getNodeType();
         if (first_argument_type == QueryTreeNodeType::QUERY || first_argument_type == QueryTreeNodeType::UNION)
         {
-            IdentifierResolveScope subquery_scope(in_first_argument, &scope /*parent_scope*/);
+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(in_first_argument, &scope /*parent_scope*/);
             subquery_scope.subquery_depth = scope.subquery_depth + 1;
 
             evaluateScalarSubqueryIfNeeded(in_first_argument, subquery_scope);
@@ -3251,7 +3244,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
 
             auto lambda_expression_clone = lambda_expression_untyped->clone();
 
-            IdentifierResolveScope lambda_scope(lambda_expression_clone, &scope /*parent_scope*/);
+            IdentifierResolveScope & lambda_scope = createIdentifierResolveScope(lambda_expression_clone, &scope /*parent_scope*/);
             ProjectionNames lambda_projection_names = resolveLambda(lambda_expression_untyped, lambda_expression_clone, function_arguments, lambda_scope);
 
             auto & resolved_lambda = lambda_expression_clone->as<LambdaNode &>();
@@ -3499,7 +3492,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
             QueryTreeNodes lambda_arguments;
             lambda_arguments.reserve(lambda_arguments_size);
 
-            IdentifierResolveScope lambda_scope(lambda_to_resolve, &scope /*parent_scope*/);
+            IdentifierResolveScope & lambda_scope = createIdentifierResolveScope(lambda_to_resolve, &scope /*parent_scope*/);
             for (size_t i = 0; i < lambda_arguments_size; ++i)
             {
                 const auto & argument_type = function_data_type_argument_types[i];
@@ -3726,7 +3719,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
         auto node_type = node->getNodeType();
         if (!allow_table_expression && (node_type == QueryTreeNodeType::QUERY || node_type == QueryTreeNodeType::UNION))
         {
-            IdentifierResolveScope subquery_scope(node, &scope /*parent_scope*/);
+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(node, &scope /*parent_scope*/);
             subquery_scope.subquery_depth = scope.subquery_depth + 1;
 
             evaluateScalarSubqueryIfNeeded(node, subquery_scope);
@@ -3801,7 +3794,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
                         else
                             union_node->setIsCTE(false);
 
-                        IdentifierResolveScope subquery_scope(resolved_identifier_node, &scope /*parent_scope*/);
+                        IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(resolved_identifier_node, &scope /*parent_scope*/);
                         subquery_scope.subquery_depth = scope.subquery_depth + 1;
 
                         /// CTE is being resolved, it's required to forbid to resolve to it again
@@ -3938,7 +3931,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
             [[fallthrough]];
         case QueryTreeNodeType::UNION:
         {
-            IdentifierResolveScope subquery_scope(node, &scope /*parent_scope*/);
+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(node, &scope /*parent_scope*/);
             subquery_scope.subquery_depth = scope.subquery_depth + 1;
 
             std::string projection_name = "_subquery_" + std::to_string(subquery_counter);
@@ -4367,7 +4360,7 @@ void QueryAnalyzer::resolveInterpolateColumnsNodeList(QueryTreeNodePtr & interpo
         bool is_column_constant = interpolate_node_typed.getExpression()->getNodeType() == QueryTreeNodeType::CONSTANT;
 
         auto & interpolation_to_resolve = interpolate_node_typed.getInterpolateExpression();
-        IdentifierResolveScope interpolate_scope(interpolation_to_resolve, &scope /*parent_scope*/);
+        IdentifierResolveScope & interpolate_scope = createIdentifierResolveScope(interpolation_to_resolve, &scope /*parent_scope*/);
 
         auto fake_column_node = std::make_shared<ColumnNode>(NameAndTypePair(column_to_interpolate_name, interpolate_node_typed.getExpression()->getResultType()), interpolate_node);
         if (is_column_constant)
@@ -4672,7 +4665,7 @@ void QueryAnalyzer::initializeTableExpressionData(const QueryTreeNodePtr & table
               */
             alias_column_to_resolve = column_name_to_column_node[alias_column_to_resolve_name];
 
-            IdentifierResolveScope alias_column_resolve_scope(alias_column_to_resolve, nullptr /*parent_scope*/);
+            IdentifierResolveScope & alias_column_resolve_scope = createIdentifierResolveScope(alias_column_to_resolve, &scope /*parent_scope*/);
             alias_column_resolve_scope.column_name_to_column_node = std::move(column_name_to_column_node);
             alias_column_resolve_scope.context = scope.context;
 
@@ -5345,7 +5338,7 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS
                         left_subquery->getProjection().getNodes().push_back(projection_node->clone());
                         left_subquery->getJoinTree() = left_table_expression;
 
-                        IdentifierResolveScope left_subquery_scope(left_subquery, nullptr /*parent_scope*/);
+                        IdentifierResolveScope & left_subquery_scope = createIdentifierResolveScope(left_subquery, nullptr /*parent_scope*/);
                         resolveQuery(left_subquery, left_subquery_scope);
 
                         const auto & resolved_nodes = left_subquery->getProjection().getNodes();
@@ -5972,7 +5965,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier
         auto & non_recursive_query_mutable_context = non_recursive_query_is_query_node ? non_recursive_query->as<QueryNode &>().getMutableContext()
             :  non_recursive_query->as<UnionNode &>().getMutableContext();
 
-        IdentifierResolveScope non_recursive_subquery_scope(non_recursive_query, &scope /*parent_scope*/);
+        IdentifierResolveScope & non_recursive_subquery_scope = createIdentifierResolveScope(non_recursive_query, &scope /*parent_scope*/);
         non_recursive_subquery_scope.subquery_depth = scope.subquery_depth + 1;
 
         if (non_recursive_query_is_query_node)
@@ -6003,7 +5996,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier
     {
         auto & query_node = queries_nodes[i];
 
-        IdentifierResolveScope subquery_scope(query_node, &scope /*parent_scope*/);
+        IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(query_node, &scope /*parent_scope*/);
 
         if (recursive_cte_table_node)
             subquery_scope.expression_argument_name_to_node[union_node_typed.getCTEName()] = recursive_cte_table_node;
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.h b/src/Analyzer/Resolve/QueryAnalyzer.h
index 51d5cb7640b7..a5b58eeadf3b 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.h
+++ b/src/Analyzer/Resolve/QueryAnalyzer.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <unordered_map>
 #include <Interpreters/Context_fwd.h>
 #include <Analyzer/HashUtils.h>
 #include <Analyzer/IQueryTreeNode.h>
@@ -124,6 +125,8 @@ class QueryAnalyzer
 private:
     /// Utility functions
 
+    IdentifierResolveScope & createIdentifierResolveScope(const QueryTreeNodePtr & scope_node, IdentifierResolveScope * parent_scope);
+
     static ProjectionName calculateFunctionProjectionName(const QueryTreeNodePtr & function_node,
         const ProjectionNames & parameters_projection_names,
         const ProjectionNames & arguments_projection_names);
@@ -285,6 +288,8 @@ class QueryAnalyzer
     std::unordered_map<QueryTreeNodePtrWithHash, Block> scalar_subquery_to_scalar_value_local;
     std::unordered_map<QueryTreeNodePtrWithHash, Block> scalar_subquery_to_scalar_value_global;
 
+    std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> node_to_scope_map;
+
     const bool only_analyze;
 };
 
diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index d2626e08653e..be68bc3aa42c 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -251,11 +251,11 @@ bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node)
 }
 
 bool checkCorrelatedColumn(
-    IdentifierResolveScope * scope_to_check,
+    const IdentifierResolveScope * scope_to_check,
     const QueryTreeNodePtr & column
 )
 {
-    auto * current_scope = scope_to_check;
+    const auto * current_scope = scope_to_check;
     chassert(column->getNodeType() == QueryTreeNodeType::COLUMN);
     auto * column_node = column->as<ColumnNode>();
     auto column_source = column_node->getColumnSource();
@@ -272,9 +272,15 @@ bool checkCorrelatedColumn(
 
     while (scope_to_check != nullptr)
     {
+        /// Check if column source is in the FROM section of the current scope (query).
         if (scope_to_check->registered_table_expression_nodes.contains(column_source))
             break;
 
+        /// Previous check wouldn't work in the case of resolution of alias columns.
+        /// In that case table expression is not registered yet and table expression data is being computed.
+        if (scope_to_check->table_expressions_in_resolve_process.contains(column_source.get()))
+            break;
+
         if (isQueryOrUnionNode(scope_to_check->scope_node))
         {
             is_correlated = true;
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index e0063d51bd94..8ebd0a186a19 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -71,7 +71,7 @@ bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node);
  * in corresponding QueryNode or UnionNode.
  */
 bool checkCorrelatedColumn(
-    IdentifierResolveScope * scope_to_check,
+    const IdentifierResolveScope * scope_to_check,
     const QueryTreeNodePtr & column
 );
 
