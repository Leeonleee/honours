diff --git a/dbms/src/IO/WriteHelpers.cpp b/dbms/src/IO/WriteHelpers.cpp
index d2605dce9fec..9fe194a70c8c 100644
--- a/dbms/src/IO/WriteHelpers.cpp
+++ b/dbms/src/IO/WriteHelpers.cpp
@@ -62,4 +62,43 @@ void writeException(const Exception & e, WriteBuffer & buf, bool with_stack_trac
     bool has_nested = false;
     writeBinary(has_nested, buf);
 }
+
+
+/// The same, but quotes apply only if there are characters that do not match the identifier without quotes
+template <typename F>
+static inline void writeProbablyQuotedStringImpl(const StringRef & s, WriteBuffer & buf, F && write_quoted_string)
+{
+    if (!s.size || !isValidIdentifierBegin(s.data[0]))
+    {
+        write_quoted_string(s, buf);
+    }
+    else
+    {
+        const char * pos = s.data + 1;
+        const char * end = s.data + s.size;
+        for (; pos < end; ++pos)
+            if (!isWordCharASCII(*pos))
+                break;
+        if (pos != end)
+            write_quoted_string(s, buf);
+        else
+            writeString(s, buf);
+    }
+}
+
+void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf)
+{
+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedString(s_, buf_); });
+}
+
+void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf)
+{
+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeDoubleQuotedString(s_, buf_); });
+}
+
+void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)
+{
+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedStringMySQL(s_, buf_); });
+}
+
 }
diff --git a/dbms/src/IO/WriteHelpers.h b/dbms/src/IO/WriteHelpers.h
index 0c7478c91774..aaba21a008a6 100644
--- a/dbms/src/IO/WriteHelpers.h
+++ b/dbms/src/IO/WriteHelpers.h
@@ -509,40 +509,10 @@ inline void writeBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)
 }
 
 
-/// The same, but quotes apply only if there are characters that do not match the identifier without quotes.
-template <typename F>
-inline void writeProbablyQuotedStringImpl(const StringRef & s, WriteBuffer & buf, F && write_quoted_string)
-{
-    if (!s.size || !isValidIdentifierBegin(s.data[0]))
-        write_quoted_string(s, buf);
-    else
-    {
-        const char * pos = s.data + 1;
-        const char * end = s.data + s.size;
-        for (; pos < end; ++pos)
-            if (!isWordCharASCII(*pos))
-                break;
-        if (pos != end)
-            write_quoted_string(s, buf);
-        else
-            writeString(s, buf);
-    }
-}
-
-inline void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf)
-{
-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedString(s_, buf_); });
-}
-
-inline void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf)
-{
-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeDoubleQuotedString(s_, buf_); });
-}
-
-inline void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)
-{
-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedStringMySQL(s_, buf_); });
-}
+/// Write quoted if the string doesn't look like and identifier.
+void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf);
+void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf);
+void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf);
 
 
 /** Outputs the string in for the CSV format.
diff --git a/dbms/src/Parsers/ExpressionListParsers.cpp b/dbms/src/Parsers/ExpressionListParsers.cpp
index cf755994cd61..f8947262a26c 100644
--- a/dbms/src/Parsers/ExpressionListParsers.cpp
+++ b/dbms/src/Parsers/ExpressionListParsers.cpp
@@ -601,18 +601,26 @@ bool ParserNullityChecking::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
 
 bool ParserIntervalOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
-    /// If no INTERVAL keyword, go to nested parser.
+    auto begin = pos;
+
+    /// If no INTERVAL keyword, go to the nested parser.
     if (!ParserKeyword("INTERVAL").ignore(pos, expected))
         return next_parser.parse(pos, node, expected);
 
     ASTPtr expr;
     /// Any expression can be inside, because operator surrounds it.
     if (!ParserExpressionWithOptionalAlias(false).parse(pos, expr, expected))
-        return false;
+    {
+        pos = begin;
+        return next_parser.parse(pos, node, expected);
+    }
 
     IntervalKind interval_kind;
     if (!parseIntervalKind(pos, expected, interval_kind))
-        return false;
+    {
+        pos = begin;
+        return next_parser.parse(pos, node, expected);
+    }
 
     /// the function corresponding to the operator
     auto function = std::make_shared<ASTFunction>();
