{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9142,
  "instance_id": "ClickHouse__ClickHouse-9142",
  "issue_numbers": [
    "9124"
  ],
  "base_commit": "4629f78da789f0b80640d54ddb66a8ca8c064f14",
  "patch": "diff --git a/dbms/src/IO/WriteHelpers.cpp b/dbms/src/IO/WriteHelpers.cpp\nindex d2605dce9fec..9fe194a70c8c 100644\n--- a/dbms/src/IO/WriteHelpers.cpp\n+++ b/dbms/src/IO/WriteHelpers.cpp\n@@ -62,4 +62,43 @@ void writeException(const Exception & e, WriteBuffer & buf, bool with_stack_trac\n     bool has_nested = false;\n     writeBinary(has_nested, buf);\n }\n+\n+\n+/// The same, but quotes apply only if there are characters that do not match the identifier without quotes\n+template <typename F>\n+static inline void writeProbablyQuotedStringImpl(const StringRef & s, WriteBuffer & buf, F && write_quoted_string)\n+{\n+    if (!s.size || !isValidIdentifierBegin(s.data[0]))\n+    {\n+        write_quoted_string(s, buf);\n+    }\n+    else\n+    {\n+        const char * pos = s.data + 1;\n+        const char * end = s.data + s.size;\n+        for (; pos < end; ++pos)\n+            if (!isWordCharASCII(*pos))\n+                break;\n+        if (pos != end)\n+            write_quoted_string(s, buf);\n+        else\n+            writeString(s, buf);\n+    }\n+}\n+\n+void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf)\n+{\n+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedString(s_, buf_); });\n+}\n+\n+void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf)\n+{\n+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeDoubleQuotedString(s_, buf_); });\n+}\n+\n+void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)\n+{\n+    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedStringMySQL(s_, buf_); });\n+}\n+\n }\ndiff --git a/dbms/src/IO/WriteHelpers.h b/dbms/src/IO/WriteHelpers.h\nindex 0c7478c91774..aaba21a008a6 100644\n--- a/dbms/src/IO/WriteHelpers.h\n+++ b/dbms/src/IO/WriteHelpers.h\n@@ -509,40 +509,10 @@ inline void writeBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)\n }\n \n \n-/// The same, but quotes apply only if there are characters that do not match the identifier without quotes.\n-template <typename F>\n-inline void writeProbablyQuotedStringImpl(const StringRef & s, WriteBuffer & buf, F && write_quoted_string)\n-{\n-    if (!s.size || !isValidIdentifierBegin(s.data[0]))\n-        write_quoted_string(s, buf);\n-    else\n-    {\n-        const char * pos = s.data + 1;\n-        const char * end = s.data + s.size;\n-        for (; pos < end; ++pos)\n-            if (!isWordCharASCII(*pos))\n-                break;\n-        if (pos != end)\n-            write_quoted_string(s, buf);\n-        else\n-            writeString(s, buf);\n-    }\n-}\n-\n-inline void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf)\n-{\n-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedString(s_, buf_); });\n-}\n-\n-inline void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf)\n-{\n-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeDoubleQuotedString(s_, buf_); });\n-}\n-\n-inline void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf)\n-{\n-    writeProbablyQuotedStringImpl(s, buf, [](const StringRef & s_, WriteBuffer & buf_) { return writeBackQuotedStringMySQL(s_, buf_); });\n-}\n+/// Write quoted if the string doesn't look like and identifier.\n+void writeProbablyBackQuotedString(const StringRef & s, WriteBuffer & buf);\n+void writeProbablyDoubleQuotedString(const StringRef & s, WriteBuffer & buf);\n+void writeProbablyBackQuotedStringMySQL(const StringRef & s, WriteBuffer & buf);\n \n \n /** Outputs the string in for the CSV format.\ndiff --git a/dbms/src/Parsers/ExpressionListParsers.cpp b/dbms/src/Parsers/ExpressionListParsers.cpp\nindex cf755994cd61..f8947262a26c 100644\n--- a/dbms/src/Parsers/ExpressionListParsers.cpp\n+++ b/dbms/src/Parsers/ExpressionListParsers.cpp\n@@ -601,18 +601,26 @@ bool ParserNullityChecking::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n \n bool ParserIntervalOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    /// If no INTERVAL keyword, go to nested parser.\n+    auto begin = pos;\n+\n+    /// If no INTERVAL keyword, go to the nested parser.\n     if (!ParserKeyword(\"INTERVAL\").ignore(pos, expected))\n         return next_parser.parse(pos, node, expected);\n \n     ASTPtr expr;\n     /// Any expression can be inside, because operator surrounds it.\n     if (!ParserExpressionWithOptionalAlias(false).parse(pos, expr, expected))\n-        return false;\n+    {\n+        pos = begin;\n+        return next_parser.parse(pos, node, expected);\n+    }\n \n     IntervalKind interval_kind;\n     if (!parseIntervalKind(pos, expected, interval_kind))\n-        return false;\n+    {\n+        pos = begin;\n+        return next_parser.parse(pos, node, expected);\n+    }\n \n     /// the function corresponding to the operator\n     auto function = std::make_shared<ASTFunction>();\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01081_keywords_formatting.reference b/dbms/tests/queries/0_stateless/01081_keywords_formatting.reference\nnew file mode 100644\nindex 000000000000..0cfbf08886fc\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01081_keywords_formatting.reference\n@@ -0,0 +1,1 @@\n+2\ndiff --git a/dbms/tests/queries/0_stateless/01081_keywords_formatting.sql b/dbms/tests/queries/0_stateless/01081_keywords_formatting.sql\nnew file mode 100644\nindex 000000000000..6044f383c107\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01081_keywords_formatting.sql\n@@ -0,0 +1,1 @@\n+SELECT (1 AS `interval`) + `interval`;\n",
  "problem_statement": "Back quotes do not work with analiased subselects\n\r\n```\r\nCREATE DATABASE IF NOT EXISTS temp\r\n\r\nCREATE TABLE temp.keyword_test \r\n   (\r\n       number Int64\r\n   ) \r\nENGINE = Memory;\r\n```\r\n\r\nI try to execute such query:\r\n```\r\nSELECT interval\r\nFROM (\r\n    SELECT\r\n        number AS interval\r\n      FROM (\r\n        SELECT number\r\n        FROM temp.keyword_test\r\n    )\r\n)\r\n```\r\n\r\nBut it throws an exception:\r\n```\r\nCode: 62, e.displayText() = DB::Exception: Syntax error: failed at position 75 (line 4, col 9): number AS interval\r\n      FROM (\r\n        SELECT number\r\n        FROM temp.keyword_test\r\n    )\r\n)\r\n\r\n FORMAT JSON . Expected one of: AND, OR, alias, token, AS, NOT, BETWEEN, LIKE, IS, NOT LIKE, IN, NOT IN, GLOBAL IN, GLOBAL NOT IN, Comma, Dot, Arrow, QuestionMark (version 20.1.4.14 (official build))\r\n```\r\n\r\nbut, rename 'interval' to something else, 'interval1', for example, and it works how expected.\n",
  "hints_text": "It's OK to have special words. They should be masked by back quotes. But there's a bug with one of notation.\r\n\r\n```\r\nSELECT * FROM (SELECT number AS `interval` FROM (SELECT number FROM numbers(1))); -- OK\r\nSELECT s.`interval` FROM (SELECT number AS `interval` FROM (SELECT number FROM numbers(1))) s; -- OK\r\n\r\nSELECT `interval` FROM (SELECT number AS `interval` FROM (SELECT number FROM numbers(1))); -- FAIL\r\n\r\nCode: 62. DB::Exception: Received from localhost:9000. DB::Exception: Syntax error: failed at position 30: number AS interval FROM (SELECT number FROM numbers(1))). Expected one of: LIKE, GLOBAL NOT IN, AS, IS, OR, QuestionMark, BETWEEN, NOT LIKE, AND, Comma, alias, IN, Dot, NOT, Arrow, token, NOT IN, GLOBAL IN.\r\n```\nSELECT number AS interval FROM (SELECT number FROM temp.keyword_test) - ok. But if add one more SELECT FROM - fail. Is it expected behavior? @4ertus2 \nIt's zone of uncertainty should we support aliases that have names of functions or types. Specifically in this case it's an error cause we allow to have alias in one case but disallow in another. But it's probably OK either to disable or to enable it if it has the same behaviour in all cases. It's better to use back quotes in all such cases. It's even better to make all subqueries aliased too.\n@4ertus2  \r\nCould you please clarify, which words are special and should be masked by back quotes?\nINTERVAL is SQL data type and could be parsed in special way in some context. If you make a column or alias with name of a type, e.x. `select x as UInt32` or function `select x as round` you may have troubles without back quotes.",
  "created_at": "2020-02-16T06:45:45Z",
  "modified_files": [
    "dbms/src/IO/WriteHelpers.cpp",
    "dbms/src/IO/WriteHelpers.h",
    "dbms/src/Parsers/ExpressionListParsers.cpp"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01081_keywords_formatting.reference",
    "b/dbms/tests/queries/0_stateless/01081_keywords_formatting.sql"
  ]
}