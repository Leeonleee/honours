{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12666,
  "instance_id": "ClickHouse__ClickHouse-12666",
  "issue_numbers": [
    "11329"
  ],
  "base_commit": "3903dd989049cd97c964981ae8041ff03a83dd72",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeMutationStatus.cpp b/src/Storages/MergeTree/MergeTreeMutationStatus.cpp\nnew file mode 100644\nindex 000000000000..4819cf9b2a93\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeTreeMutationStatus.cpp\n@@ -0,0 +1,34 @@\n+#include <Storages/MergeTree/MergeTreeMutationStatus.h>\n+\n+#include <Common/Exception.h>\n+#include <boost/algorithm/string/join.hpp>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNFINISHED;\n+}\n+\n+void checkMutationStatus(std::optional<MergeTreeMutationStatus> & status, const Strings & mutation_ids)\n+{\n+    if (!status)\n+    {\n+        assert(mutation_ids.size() == 1);\n+        throw Exception(ErrorCodes::UNFINISHED, \"Mutation {} was killed\", mutation_ids[0]);\n+    }\n+    else if (!status->is_done && !status->latest_fail_reason.empty())\n+    {\n+        throw Exception(\n+            ErrorCodes::UNFINISHED,\n+            \"Exception happened during execution of mutation{} '{}' with part '{}' reason: '{}'. This error maybe retryable or not. \"\n+            \"In case of unretryable error, mutation can be killed with KILL MUTATION query\",\n+            mutation_ids.size() > 1 ? \"s\" : \"\",\n+            boost::algorithm::join(mutation_ids, \", \"),\n+            status->latest_failed_part,\n+            status->latest_fail_reason);\n+    }\n+}\n+\n+}\ndiff --git a/src/Storages/MergeTree/MergeTreeMutationStatus.h b/src/Storages/MergeTree/MergeTreeMutationStatus.h\nindex 3a9ecf30eb1d..62d7c1bbbcd2 100644\n--- a/src/Storages/MergeTree/MergeTreeMutationStatus.h\n+++ b/src/Storages/MergeTree/MergeTreeMutationStatus.h\n@@ -1,12 +1,16 @@\n #pragma once\n \n #include <Core/Types.h>\n+#include <Core/Names.h>\n+#include <optional>\n #include <map>\n+#include <ctime>\n \n \n namespace DB\n {\n \n+\n struct MergeTreeMutationStatus\n {\n     String id;\n@@ -25,4 +29,10 @@ struct MergeTreeMutationStatus\n     String latest_fail_reason;\n };\n \n+/// Check mutation status and throw exception in case of error during mutation\n+/// (latest_fail_reason not empty) or if mutation was killed (status empty\n+/// optional). mutation_ids passed separately, because status may be empty and\n+/// we can execute multiple mutations at once\n+void checkMutationStatus(std::optional<MergeTreeMutationStatus> & status, const Strings & mutation_ids);\n+\n }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex 3deb61bf8db9..4ff63f9c2dec 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -1538,6 +1538,43 @@ void ReplicatedMergeTreeQueue::getInsertTimes(time_t & out_min_unprocessed_inser\n }\n \n \n+std::optional<MergeTreeMutationStatus> ReplicatedMergeTreeQueue::getIncompleteMutationsStatus(const String & znode_name, Strings * mutation_ids) const\n+{\n+\n+    std::lock_guard lock(state_mutex);\n+    auto current_mutation_it = mutations_by_znode.find(znode_name);\n+    /// killed\n+    if (current_mutation_it == mutations_by_znode.end())\n+        return {};\n+\n+    const MutationStatus & status = current_mutation_it->second;\n+    MergeTreeMutationStatus result\n+    {\n+        .is_done = status.is_done,\n+        .latest_failed_part = status.latest_failed_part,\n+        .latest_fail_time = status.latest_fail_time,\n+        .latest_fail_reason = status.latest_fail_reason,\n+    };\n+\n+    if (mutation_ids && !status.latest_fail_reason.empty())\n+    {\n+        const auto & latest_failed_part_info = status.latest_failed_part_info;\n+        auto in_partition = mutations_by_partition.find(latest_failed_part_info.partition_id);\n+        if (in_partition != mutations_by_partition.end())\n+        {\n+            const auto & version_to_status = in_partition->second;\n+            auto begin_it = version_to_status.upper_bound(latest_failed_part_info.getDataVersion());\n+            for (auto it = begin_it; it != version_to_status.end(); ++it)\n+            {\n+                /// All mutations with the same failure\n+                if (!it->second->is_done && it->second->latest_fail_reason == status.latest_fail_reason)\n+                    mutation_ids->push_back(it->second->entry->znode_name);\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n std::vector<MergeTreeMutationStatus> ReplicatedMergeTreeQueue::getMutationsStatus() const\n {\n     std::lock_guard lock(state_mutex);\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\nindex cd155214cacb..c330631d9ddd 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n@@ -399,6 +399,13 @@ class ReplicatedMergeTreeQueue\n     /// Get information about the insertion times.\n     void getInsertTimes(time_t & out_min_unprocessed_insert_time, time_t & out_max_processed_insert_time) const;\n \n+\n+    /// Return empty optional if mutation was killed. Otherwise return partially\n+    /// filled mutation status with information about error (latest_fail*) and\n+    /// is_done. mutation_ids filled with all mutations with same errors, because\n+    /// they may be executed simultaneously as one mutation.\n+    std::optional<MergeTreeMutationStatus> getIncompleteMutationsStatus(const String & znode_name, Strings * mutation_ids = nullptr) const;\n+\n     std::vector<MergeTreeMutationStatus> getMutationsStatus() const;\n \n     void removeCurrentPartsFromMutations();\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex eecde28b7bbe..8f58fd0ba4d7 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -134,7 +134,7 @@ void StorageMergeTree::shutdown()\n \n     /// Unlock all waiting mutations\n     {\n-        std::lock_guard<std::mutex> lock(mutation_wait_mutex);\n+        std::lock_guard lock(mutation_wait_mutex);\n         mutation_wait_event.notify_all();\n     }\n \n@@ -284,9 +284,6 @@ struct CurrentlyMergingPartsTagger\n     FutureMergedMutatedPart future_part;\n     ReservationPtr reserved_space;\n \n-    bool is_successful = false;\n-    String exception_message;\n-\n     StorageMergeTree & storage;\n \n public:\n@@ -339,40 +336,6 @@ struct CurrentlyMergingPartsTagger\n             storage.currently_merging_mutating_parts.erase(part);\n         }\n \n-        /// Update the information about failed parts in the system.mutations table.\n-\n-        Int64 sources_data_version = future_part.parts.at(0)->info.getDataVersion();\n-        Int64 result_data_version = future_part.part_info.getDataVersion();\n-        auto mutations_begin_it = storage.current_mutations_by_version.end();\n-        auto mutations_end_it = storage.current_mutations_by_version.end();\n-        if (sources_data_version != result_data_version)\n-        {\n-            mutations_begin_it = storage.current_mutations_by_version.upper_bound(sources_data_version);\n-            mutations_end_it = storage.current_mutations_by_version.upper_bound(result_data_version);\n-        }\n-\n-        for (auto it = mutations_begin_it; it != mutations_end_it; ++it)\n-        {\n-            MergeTreeMutationEntry & entry = it->second;\n-            if (is_successful)\n-            {\n-                if (!entry.latest_failed_part.empty() && future_part.part_info.contains(entry.latest_failed_part_info))\n-                {\n-                    entry.latest_failed_part.clear();\n-                    entry.latest_failed_part_info = MergeTreePartInfo();\n-                    entry.latest_fail_time = 0;\n-                    entry.latest_fail_reason.clear();\n-                }\n-            }\n-            else\n-            {\n-                entry.latest_failed_part = future_part.parts.at(0)->name;\n-                entry.latest_failed_part_info = future_part.parts.at(0)->info;\n-                entry.latest_fail_time = time(nullptr);\n-                entry.latest_fail_reason = exception_message;\n-            }\n-        }\n-\n         storage.currently_processing_in_background_condition.notify_all();\n     }\n };\n@@ -398,12 +361,66 @@ Int64 StorageMergeTree::startMutation(const MutationCommands & commands, String\n     return version;\n }\n \n+\n+void StorageMergeTree::updateMutationEntriesErrors(FutureMergedMutatedPart result_part, bool is_successful, const String & exception_message)\n+{\n+    /// Update the information about failed parts in the system.mutations table.\n+\n+    Int64 sources_data_version = result_part.parts.at(0)->info.getDataVersion();\n+    Int64 result_data_version = result_part.part_info.getDataVersion();\n+    if (sources_data_version != result_data_version)\n+    {\n+        std::lock_guard lock(currently_processing_in_background_mutex);\n+        auto mutations_begin_it = current_mutations_by_version.upper_bound(sources_data_version);\n+        auto mutations_end_it = current_mutations_by_version.upper_bound(result_data_version);\n+\n+        for (auto it = mutations_begin_it; it != mutations_end_it; ++it)\n+        {\n+            MergeTreeMutationEntry & entry = it->second;\n+            if (is_successful)\n+            {\n+                if (!entry.latest_failed_part.empty() && result_part.part_info.contains(entry.latest_failed_part_info))\n+                {\n+                    entry.latest_failed_part.clear();\n+                    entry.latest_failed_part_info = MergeTreePartInfo();\n+                    entry.latest_fail_time = 0;\n+                    entry.latest_fail_reason.clear();\n+                }\n+            }\n+            else\n+            {\n+                entry.latest_failed_part = result_part.parts.at(0)->name;\n+                entry.latest_failed_part_info = result_part.parts.at(0)->info;\n+                entry.latest_fail_time = time(nullptr);\n+                entry.latest_fail_reason = exception_message;\n+            }\n+        }\n+    }\n+\n+    std::unique_lock lock(mutation_wait_mutex);\n+    mutation_wait_event.notify_all();\n+}\n+\n void StorageMergeTree::waitForMutation(Int64 version, const String & file_name)\n {\n     LOG_INFO(log, \"Waiting mutation: {}\", file_name);\n-    auto check = [version, this]() { return shutdown_called || isMutationDone(version); };\n-    std::unique_lock lock(mutation_wait_mutex);\n-    mutation_wait_event.wait(lock, check);\n+    {\n+        auto check = [version, this]()\n+        {\n+            if (shutdown_called)\n+                return true;\n+            auto mutation_status = getIncompleteMutationsStatus(version);\n+            return !mutation_status || mutation_status->is_done || !mutation_status->latest_fail_reason.empty();\n+        };\n+\n+        std::unique_lock lock(mutation_wait_mutex);\n+        mutation_wait_event.wait(lock, check);\n+    }\n+\n+    Strings mutation_ids;\n+    auto mutation_status = getIncompleteMutationsStatus(version, &mutation_ids);\n+    checkMutationStatus(mutation_status, mutation_ids);\n+\n     LOG_INFO(log, \"Mutation {} done\", file_name);\n }\n \n@@ -432,20 +449,50 @@ bool comparator(const PartVersionWithName & f, const PartVersionWithName & s)\n \n }\n \n-\n-bool StorageMergeTree::isMutationDone(Int64 mutation_version) const\n+std::optional<MergeTreeMutationStatus> StorageMergeTree::getIncompleteMutationsStatus(Int64 mutation_version, Strings * mutation_ids) const\n {\n     std::lock_guard lock(currently_processing_in_background_mutex);\n \n+    auto current_mutation_it = current_mutations_by_version.find(mutation_version);\n     /// Killed\n-    if (!current_mutations_by_version.count(mutation_version))\n-        return true;\n+    if (current_mutation_it == current_mutations_by_version.end())\n+        return {};\n+\n+    MergeTreeMutationStatus result{.is_done = false};\n+\n+    const auto & mutation_entry = current_mutation_it->second;\n \n     auto data_parts = getDataPartsVector();\n     for (const auto & data_part : data_parts)\n+    {\n         if (data_part->info.getDataVersion() < mutation_version)\n-            return false;\n-    return true;\n+        {\n+\n+            if (!mutation_entry.latest_fail_reason.empty())\n+            {\n+                result.latest_failed_part = mutation_entry.latest_failed_part;\n+                result.latest_fail_reason = mutation_entry.latest_fail_reason;\n+                result.latest_fail_time = mutation_entry.latest_fail_time;\n+\n+                /// Fill all mutations which failed with the same error\n+                /// (we can execute several mutations together)\n+                if (mutation_ids)\n+                {\n+                    auto mutations_begin_it = current_mutations_by_version.upper_bound(data_part->info.getDataVersion());\n+\n+                    for (auto it = mutations_begin_it; it != current_mutations_by_version.end(); ++it)\n+                        /// All mutations with the same failure\n+                        if (it->second.latest_fail_reason == result.latest_fail_reason)\n+                            mutation_ids->push_back(it->second.file_name);\n+                }\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    result.is_done = true;\n+    return result;\n }\n \n \n@@ -474,7 +521,6 @@ std::vector<MergeTreeMutationStatus> StorageMergeTree::getMutationsStatus() cons\n     std::vector<MergeTreeMutationStatus> result;\n     for (const auto & kv : current_mutations_by_version)\n     {\n-\n         Int64 mutation_version = kv.first;\n         const MergeTreeMutationEntry & entry = kv.second;\n         const PartVersionWithName needle{mutation_version, \"\"};\n@@ -500,7 +546,7 @@ std::vector<MergeTreeMutationStatus> StorageMergeTree::getMutationsStatus() cons\n                 entry.create_time,\n                 block_numbers_map,\n                 parts_to_do_names,\n-                parts_to_do_names.empty(),\n+                /* is_done = */parts_to_do_names.empty(),\n                 entry.latest_failed_part,\n                 entry.latest_fail_time,\n                 entry.latest_fail_reason,\n@@ -686,12 +732,10 @@ bool StorageMergeTree::merge(\n             merging_tagger->reserved_space, deduplicate, force_ttl);\n \n         merger_mutator.renameMergedTemporaryPart(new_part, future_part.parts, nullptr);\n-        merging_tagger->is_successful = true;\n         write_part_log({});\n     }\n     catch (...)\n     {\n-        merging_tagger->exception_message = getCurrentExceptionMessage(false);\n         write_part_log(ExecutionStatus::fromCurrentException());\n         throw;\n     }\n@@ -828,18 +872,12 @@ bool StorageMergeTree::tryMutatePart()\n \n         renameTempPartAndReplace(new_part);\n \n-        tagger->is_successful = true;\n+        updateMutationEntriesErrors(future_part, true, \"\");\n         write_part_log({});\n-\n-        /// Notify all, who wait for this or previous mutations\n-        {\n-            std::lock_guard<std::mutex> lock(mutation_wait_mutex);\n-            mutation_wait_event.notify_all();\n-        }\n     }\n     catch (...)\n     {\n-        tagger->exception_message = getCurrentExceptionMessage(false);\n+        updateMutationEntriesErrors(future_part, false, getCurrentExceptionMessage(false));\n         write_part_log(ExecutionStatus::fromCurrentException());\n         throw;\n     }\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex c80c9f443778..4bc7a1fbd987 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -153,9 +153,16 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,\n     void replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace, const Context & context);\n     void movePartitionToTable(const StoragePtr & dest_table, const ASTPtr & partition, const Context & context);\n     bool partIsAssignedToBackgroundOperation(const DataPartPtr & part) const override;\n-\n-    /// Just checks versions of each active data part\n-    bool isMutationDone(Int64 mutation_version) const;\n+    /// Update mutation entries after part mutation execution. May reset old\n+    /// errors if mutation was successful. Otherwise update last_failed* fields\n+    /// in mutation entries.\n+    void updateMutationEntriesErrors(FutureMergedMutatedPart result_part, bool is_successful, const String & exception_message);\n+\n+    /// Return empty optional if mutation was killed. Otherwise return partially\n+    /// filled mutation status with information about error (latest_fail*) and\n+    /// is_done. mutation_ids filled with mutations with the same errors, because we\n+    /// can execute several mutations at once\n+    std::optional<MergeTreeMutationStatus> getIncompleteMutationsStatus(Int64 mutation_version, Strings * mutation_ids = nullptr) const;\n \n     void startBackgroundMovesIfNeeded() override;\n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex c6dc3e67b807..4a9acdb74c0a 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -348,7 +348,6 @@ void StorageReplicatedMergeTree::waitMutationToFinishOnReplicas(\n     std::set<String> inactive_replicas;\n     for (const String & replica : replicas)\n     {\n-\n         LOG_DEBUG(log, \"Waiting for {} to apply mutation {}\", replica, mutation_id);\n \n         while (!partial_shutdown_called)\n@@ -358,8 +357,7 @@ void StorageReplicatedMergeTree::waitMutationToFinishOnReplicas(\n             Coordination::Stat exists_stat;\n             if (!getZooKeeper()->exists(zookeeper_path + \"/mutations/\" + mutation_id, &exists_stat, wait_event))\n             {\n-                LOG_WARNING(log, \"Mutation {} was killed or manually removed. Nothing to wait.\", mutation_id);\n-                return;\n+                throw Exception(ErrorCodes::UNFINISHED, \"Mutation {} was killed, manually removed or table was dropped\", mutation_id);\n             }\n \n             auto zookeeper = getZooKeeper();\n@@ -387,8 +385,23 @@ void StorageReplicatedMergeTree::waitMutationToFinishOnReplicas(\n             /// Replica can become inactive, so wait with timeout and recheck it\n             if (wait_event->tryWait(1000))\n                 break;\n+\n+            auto mutation_status = queue.getIncompleteMutationsStatus(mutation_id);\n+            if (!mutation_status || !mutation_status->latest_fail_reason.empty())\n+                break;\n         }\n \n+        /// It maybe already removed from zk, but local in-memory mutations\n+        /// state was not update.\n+        if (!getZooKeeper()->exists(zookeeper_path + \"/mutations/\" + mutation_id))\n+        {\n+            throw Exception(ErrorCodes::UNFINISHED, \"Mutation {} was killed, manually removed or table was dropped\", mutation_id);\n+        }\n+\n+        Strings mutation_ids;\n+        auto mutation_status = queue.getIncompleteMutationsStatus(mutation_id, &mutation_ids);\n+        checkMutationStatus(mutation_status, mutation_ids);\n+\n         if (partial_shutdown_called)\n             throw Exception(\"Mutation is not finished because table shutdown was called. It will be done after table restart.\",\n                 ErrorCodes::UNFINISHED);\ndiff --git a/src/Storages/ya.make b/src/Storages/ya.make\nindex 632434e1dfcb..5f5ec87ba915 100644\n--- a/src/Storages/ya.make\n+++ b/src/Storages/ya.make\n@@ -87,6 +87,7 @@ SRCS(\n     MergeTree/MergeTreeDataPartWriterOnDisk.cpp\n     MergeTree/MergeTreeReaderInMemory.cpp\n     MergeTree/MergeTreeWriteAheadLog.cpp\n+    MergeTree/MergeTreeMutationStatus.cpp\n     System/attachSystemTables.cpp\n     System/StorageSystemAggregateFunctionCombinators.cpp\n     System/StorageSystemAsynchronousMetrics.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00834_kill_mutation.reference b/tests/queries/0_stateless/00834_kill_mutation.reference\nindex 1e4a67b66ea1..aa0bbdcdfee1 100644\n--- a/tests/queries/0_stateless/00834_kill_mutation.reference\n+++ b/tests/queries/0_stateless/00834_kill_mutation.reference\n@@ -2,6 +2,7 @@\n 1\n waiting\ttest\tkill_mutation\tmutation_3.txt\tDELETE WHERE toUInt32(s) = 1\n *** Create and kill invalid mutation that blocks another mutation ***\n+happened during execution of mutations 'mutation_4.txt, mutation_5.txt'\n 1\n waiting\ttest\tkill_mutation\tmutation_4.txt\tDELETE WHERE toUInt32(s) = 1\n 2001-01-01\t2\tb\ndiff --git a/tests/queries/0_stateless/00834_kill_mutation.sh b/tests/queries/0_stateless/00834_kill_mutation.sh\nindex a00e52fc23c8..8dbc75be90cf 100755\n--- a/tests/queries/0_stateless/00834_kill_mutation.sh\n+++ b/tests/queries/0_stateless/00834_kill_mutation.sh\n@@ -14,7 +14,7 @@ ${CLICKHOUSE_CLIENT} --query=\"INSERT INTO test.kill_mutation VALUES ('2001-01-01\n \n ${CLICKHOUSE_CLIENT} --query=\"SELECT '*** Create and kill a single invalid mutation ***'\"\n \n-${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation DELETE WHERE toUInt32(s) = 1 SETTINGS mutations_sync = 1\" &\n+${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation DELETE WHERE toUInt32(s) = 1 SETTINGS mutations_sync = 1\" 2>/dev/null &\n \n \n check_query1=\"SELECT count() FROM system.mutations WHERE database = 'test' AND table = 'kill_mutation' AND is_done = 0\"\n@@ -41,7 +41,7 @@ ${CLICKHOUSE_CLIENT} --query=\"SELECT mutation_id FROM system.mutations WHERE dat\n ${CLICKHOUSE_CLIENT} --query=\"SELECT '*** Create and kill invalid mutation that blocks another mutation ***'\"\n \n ${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation DELETE WHERE toUInt32(s) = 1\"\n-${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation DELETE WHERE x = 1 SETTINGS mutations_sync = 1\" &\n+${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation DELETE WHERE x = 1 SETTINGS mutations_sync = 1\" 2>&1 | grep -o \"happened during execution of mutations 'mutation_4.txt, mutation_5.txt'\" | head -n 1 &\n \n check_query2=\"SELECT count() FROM system.mutations WHERE database = 'test' AND table = 'kill_mutation' AND mutation_id = 'mutation_4.txt'\"\n \ndiff --git a/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.reference b/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.reference\nindex d6a82e488367..aaefdaeda560 100644\n--- a/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.reference\n+++ b/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.reference\n@@ -1,6 +1,6 @@\n *** Create and kill a single invalid mutation ***\n+happened during execution of mutation '0000000000'\n 1\n-Mutation 0000000000 was killed\n waiting\ttest\tkill_mutation_r1\t0000000000\tDELETE WHERE toUInt32(s) = 1\n 0\n *** Create and kill invalid mutation that blocks another mutation ***\ndiff --git a/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.sh b/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.sh\nindex 2aea2e7cfb02..4778c7f5889e 100755\n--- a/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.sh\n+++ b/tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.sh\n@@ -18,7 +18,7 @@ ${CLICKHOUSE_CLIENT} --query=\"INSERT INTO test.kill_mutation_r1 VALUES ('2001-01\n ${CLICKHOUSE_CLIENT} --query=\"SELECT '*** Create and kill a single invalid mutation ***'\"\n \n # wrong mutation\n-${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation_r1 DELETE WHERE toUInt32(s) = 1 SETTINGS mutations_sync=2\" 2>&1 | grep -o \"Mutation 0000000000 was killed\" &\n+${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation_r1 DELETE WHERE toUInt32(s) = 1 SETTINGS mutations_sync=2\" 2>&1 | grep -o \"happened during execution of mutation '0000000000'\" | head -n 1\n \n check_query1=\"SELECT count() FROM system.mutations WHERE database = 'test' AND table = 'kill_mutation_r1' AND is_done = 0\"\n \n@@ -51,6 +51,16 @@ ${CLICKHOUSE_CLIENT} --query=\"SELECT * FROM system.replication_queue WHERE table\n \n ${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation_r1 DELETE WHERE toUInt32(s) = 1\"\n \n+check_query1=\"SELECT count() FROM system.mutations WHERE database = 'test' AND table = 'kill_mutation_r1' AND is_done = 0\"\n+\n+query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query1\" 2>&1`\n+\n+while [ \"$query_result\" == \"0\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query1\" 2>&1`\n+    sleep 0.5\n+done\n+\n # good mutation, but blocked with wrong mutation\n ${CLICKHOUSE_CLIENT} --query=\"ALTER TABLE test.kill_mutation_r1 DELETE WHERE x = 1 SETTINGS mutations_sync=2\" &\n \ndiff --git a/tests/queries/0_stateless/01414_mutations_and_errors.reference b/tests/queries/0_stateless/01414_mutations_and_errors.reference\nnew file mode 100644\nindex 000000000000..166a9c6b7b83\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_mutations_and_errors.reference\n@@ -0,0 +1,4 @@\n+42\n+Hello\n+42\n+Hello\ndiff --git a/tests/queries/0_stateless/01414_mutations_and_errors.sql b/tests/queries/0_stateless/01414_mutations_and_errors.sql\nnew file mode 100644\nindex 000000000000..af7eeb8b9ee6\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_mutations_and_errors.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS mutation_table;\n+\n+CREATE TABLE mutation_table\n+(\n+    date Date,\n+    key UInt64,\n+    value String\n+)\n+ENGINE = MergeTree()\n+PARTITION BY date\n+ORDER BY tuple();\n+\n+INSERT INTO mutation_table SELECT toDate('2019-10-01'), number, '42' FROM numbers(100);\n+\n+INSERT INTO mutation_table SELECT toDate('2019-10-02'), number, 'Hello' FROM numbers(100);\n+\n+SELECT distinct(value) FROM mutation_table ORDER BY value;\n+\n+ALTER TABLE mutation_table MODIFY COLUMN value UInt64 SETTINGS mutations_sync = 2; --{serverError 341}\n+\n+SELECT distinct(value) FROM mutation_table ORDER BY value; --{serverError 6}\n+\n+KILL MUTATION where table = 'mutation_table' and database = currentDatabase();\n+\n+ALTER TABLE mutation_table MODIFY COLUMN value String SETTINGS mutations_sync = 2;\n+\n+SELECT distinct(value) FROM mutation_table ORDER BY value;\n+\n+DROP TABLE IF EXISTS mutation_table;\ndiff --git a/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.reference b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.reference\nnew file mode 100644\nindex 000000000000..a55134cbe31c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.reference\n@@ -0,0 +1,5 @@\n+Mutation 0000000000 was killed\n+Cannot parse string 'Hello' as UInt64\n+Cannot parse string 'Hello' as UInt64\n+42\n+Hello\ndiff --git a/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.sh b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.sh\nnew file mode 100755\nindex 000000000000..9881b1f7def6\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.sh\n@@ -0,0 +1,73 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS replicated_mutation_table\"\n+\n+$CLICKHOUSE_CLIENT --query \"\n+    CREATE TABLE replicated_mutation_table(\n+        date Date,\n+        key UInt64,\n+        value String\n+    )\n+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/mutation_table', '1')\n+    ORDER BY tuple()\n+    PARTITION BY date\n+\"\n+\n+$CLICKHOUSE_CLIENT --query \"INSERT INTO replicated_mutation_table SELECT toDate('2019-10-02'), number, '42' FROM numbers(4)\"\n+\n+$CLICKHOUSE_CLIENT --query \"INSERT INTO replicated_mutation_table SELECT toDate('2019-10-02'), number, 'Hello' FROM numbers(4)\"\n+\n+$CLICKHOUSE_CLIENT --query \"ALTER TABLE replicated_mutation_table UPDATE key = key + 1 WHERE sleepEachRow(1) == 0 SETTINGS mutations_sync = 2\" 2>&1 | grep -o 'Mutation 0000000000 was killed' | head -n 1 &\n+\n+check_query=\"SELECT count() FROM system.mutations WHERE table='replicated_mutation_table' and database='$CLICKHOUSE_DATABASE' and mutation_id='0000000000'\"\n+\n+query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+\n+while [ \"$query_result\" != \"1\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+    sleep 0.5\n+done\n+\n+$CLICKHOUSE_CLIENT --query \"KILL MUTATION WHERE table='replicated_mutation_table' and database='$CLICKHOUSE_DATABASE' and mutation_id='0000000000'\" &> /dev/null\n+\n+while [ \"$query_result\" != \"0\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+    sleep 0.5\n+done\n+\n+wait\n+\n+$CLICKHOUSE_CLIENT --query \"ALTER TABLE replicated_mutation_table MODIFY COLUMN value UInt64 SETTINGS replication_alter_partitions_sync = 2\" 2>&1 | grep -o \"Cannot parse string 'Hello' as UInt64\" | head -n 1 &\n+\n+check_query=\"SELECT count() FROM system.mutations WHERE table='replicated_mutation_table' and database='$CLICKHOUSE_DATABASE' and mutation_id='0000000001'\"\n+\n+query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+\n+while [ \"$query_result\" != \"1\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+    sleep 0.5\n+done\n+\n+wait\n+\n+$CLICKHOUSE_CLIENT --query \"KILL MUTATION WHERE table='replicated_mutation_table' and database='$CLICKHOUSE_DATABASE' AND mutation_id='0000000001'\" &> /dev/null\n+\n+while [ \"$query_result\" != \"0\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+    sleep 0.5\n+done\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT distinct(value) FROM replicated_mutation_table ORDER BY value\" 2>&1 | grep -o \"Cannot parse string 'Hello' as UInt64\" | head -n 1\n+\n+$CLICKHOUSE_CLIENT --query \"ALTER TABLE replicated_mutation_table MODIFY COLUMN value String SETTINGS replication_alter_partitions_sync = 2\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT distinct(value) FROM replicated_mutation_table ORDER BY value\"\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS replicated_mutation_table\"\n",
  "problem_statement": "Better diagnostics on mutation failure.\nMutations and alters are completely asynchronous operations. If we start some incorrect `ALTER` query from `clickhouse-client ` it will hang forever (if `mutations_sync=2` or `alter_repliction_partitions_sync=1 or 2` specified). We need to implement the check of `MutationStatus` and if some exception happened, we should rethrow it to the client.\r\n\r\nRelated issues: #11166, #5985.\n",
  "hints_text": "",
  "created_at": "2020-07-22T12:38:08Z",
  "modified_files": [
    "b/src/Storages/MergeTree/MergeTreeMutationStatus.cpp",
    "src/Storages/MergeTree/MergeTreeMutationStatus.h",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageMergeTree.h",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/ya.make"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00834_kill_mutation.reference",
    "tests/queries/0_stateless/00834_kill_mutation.sh",
    "tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.reference",
    "tests/queries/0_stateless/00834_kill_mutation_replicated_zookeeper.sh",
    "b/tests/queries/0_stateless/01414_mutations_and_errors.reference",
    "b/tests/queries/0_stateless/01414_mutations_and_errors.sql",
    "b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.reference",
    "b/tests/queries/0_stateless/01414_mutations_and_errors_zookeeper.sh"
  ]
}