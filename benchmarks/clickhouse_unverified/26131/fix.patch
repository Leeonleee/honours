diff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp
index b4a91170bc47..37650f5caa7e 100644
--- a/src/Interpreters/InterpreterExplainQuery.cpp
+++ b/src/Interpreters/InterpreterExplainQuery.cpp
@@ -78,17 +78,35 @@ BlockIO InterpreterExplainQuery::execute()
 }
 
 
-Block InterpreterExplainQuery::getSampleBlock()
+Block InterpreterExplainQuery::getSampleBlock(const ASTExplainQuery::ExplainKind kind)
 {
-    Block block;
-
-    ColumnWithTypeAndName col;
-    col.name = "explain";
-    col.type = std::make_shared<DataTypeString>();
-    col.column = col.type->createColumn();
-    block.insert(col);
-
-    return block;
+    if (kind == ASTExplainQuery::ExplainKind::QueryEstimates)
+    {
+        auto cols = NamesAndTypes{
+            {"database", std::make_shared<DataTypeString>()},
+            {"table", std::make_shared<DataTypeString>()},
+            {"parts", std::make_shared<DataTypeUInt64>()},
+            {"rows", std::make_shared<DataTypeUInt64>()},
+            {"marks", std::make_shared<DataTypeUInt64>()},
+        };
+        return Block({
+            {cols[0].type->createColumn(), cols[0].type, cols[0].name},
+            {cols[1].type->createColumn(), cols[1].type, cols[1].name},
+            {cols[2].type->createColumn(), cols[2].type, cols[2].name},
+            {cols[3].type->createColumn(), cols[3].type, cols[3].name},
+            {cols[4].type->createColumn(), cols[4].type, cols[4].name},
+        });
+    }
+    else
+    {
+        Block res;
+        ColumnWithTypeAndName col;
+        col.name = "explain";
+        col.type = std::make_shared<DataTypeString>();
+        col.column = col.type->createColumn();
+        res.insert(col);
+        return res;
+    }
 }
 
 /// Split str by line feed and write as separate row to ColumnString.
@@ -223,9 +241,9 @@ ExplainSettings<Settings> checkAndGetSettings(const ASTPtr & ast_settings)
 
 BlockInputStreamPtr InterpreterExplainQuery::executeImpl()
 {
-    const auto & ast = query->as<ASTExplainQuery &>();
+    const auto & ast = query->as<const ASTExplainQuery &>();
 
-    Block sample_block = getSampleBlock();
+    Block sample_block = getSampleBlock(ast.getKind());
     MutableColumns res_columns = sample_block.cloneEmptyColumns();
 
     WriteBufferFromOwnString buf;
@@ -313,11 +331,32 @@ BlockInputStreamPtr InterpreterExplainQuery::executeImpl()
             plan.explainPipeline(buf, settings.query_pipeline_options);
         }
     }
+    else if (ast.getKind() == ASTExplainQuery::QueryEstimates)
+    {
+        if (!dynamic_cast<const ASTSelectWithUnionQuery *>(ast.getExplainedQuery().get()))
+            throw Exception("Only SELECT is supported for EXPLAIN ESTIMATE query", ErrorCodes::INCORRECT_QUERY);
 
-    if (single_line)
-        res_columns[0]->insertData(buf.str().data(), buf.str().size());
-    else
-        fillColumn(*res_columns[0], buf.str());
+        auto settings = checkAndGetSettings<QueryPlanSettings>(ast.getSettings());
+        QueryPlan plan;
+
+        InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), SelectQueryOptions());
+        interpreter.buildQueryPlan(plan);
+        // collect the selected marks, rows, parts during build query pipeline.
+        plan.buildQueryPipeline(
+            QueryPlanOptimizationSettings::fromContext(getContext()),
+            BuildQueryPipelineSettings::fromContext(getContext()));
+
+        if (settings.optimize)
+            plan.optimize(QueryPlanOptimizationSettings::fromContext(getContext()));
+        plan.explainEstimate(res_columns);
+    }
+    if (ast.getKind() != ASTExplainQuery::QueryEstimates)
+    {
+        if (single_line)
+            res_columns[0]->insertData(buf.str().data(), buf.str().size());
+        else
+            fillColumn(*res_columns[0], buf.str());
+    }
 
     return std::make_shared<OneBlockInputStream>(sample_block.cloneWithColumns(std::move(res_columns)));
 }
diff --git a/src/Interpreters/InterpreterExplainQuery.h b/src/Interpreters/InterpreterExplainQuery.h
index f16b1a8f69d2..a7f54a10e3e1 100644
--- a/src/Interpreters/InterpreterExplainQuery.h
+++ b/src/Interpreters/InterpreterExplainQuery.h
@@ -2,7 +2,7 @@
 
 #include <Interpreters/IInterpreter.h>
 #include <Parsers/IAST_fwd.h>
-
+#include <Parsers/ASTExplainQuery.h>
 
 namespace DB
 {
@@ -15,7 +15,7 @@ class InterpreterExplainQuery : public IInterpreter, WithContext
 
     BlockIO execute() override;
 
-    static Block getSampleBlock();
+    static Block getSampleBlock(const ASTExplainQuery::ExplainKind kind);
 
 private:
     ASTPtr query;
diff --git a/src/Parsers/ASTExplainQuery.h b/src/Parsers/ASTExplainQuery.h
index 95a3a362030b..5c50a8cd82e0 100644
--- a/src/Parsers/ASTExplainQuery.h
+++ b/src/Parsers/ASTExplainQuery.h
@@ -17,6 +17,7 @@ class ASTExplainQuery : public ASTQueryWithOutput
         AnalyzedSyntax, /// 'EXPLAIN SYNTAX SELECT ...'
         QueryPlan, /// 'EXPLAIN SELECT ...'
         QueryPipeline, /// 'EXPLAIN PIPELINE ...'
+        QueryEstimates, /// 'EXPLAIN ESTIMATE ...'
     };
 
     explicit ASTExplainQuery(ExplainKind kind_) : kind(kind_) {}
@@ -76,6 +77,7 @@ class ASTExplainQuery : public ASTQueryWithOutput
             case AnalyzedSyntax: return "EXPLAIN SYNTAX";
             case QueryPlan: return "EXPLAIN";
             case QueryPipeline: return "EXPLAIN PIPELINE";
+            case QueryEstimates: return "EXPLAIN ESTIMATE";
         }
 
         __builtin_unreachable();
diff --git a/src/Parsers/ParserExplainQuery.cpp b/src/Parsers/ParserExplainQuery.cpp
index dc5481641570..b4ba0523239c 100644
--- a/src/Parsers/ParserExplainQuery.cpp
+++ b/src/Parsers/ParserExplainQuery.cpp
@@ -19,6 +19,7 @@ bool ParserExplainQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected
     ParserKeyword s_syntax("SYNTAX");
     ParserKeyword s_pipeline("PIPELINE");
     ParserKeyword s_plan("PLAN");
+    ParserKeyword s_estimates("ESTIMATE");
 
     if (s_explain.ignore(pos, expected))
     {
@@ -32,6 +33,8 @@ bool ParserExplainQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected
             kind = ASTExplainQuery::ExplainKind::QueryPipeline;
         else if (s_plan.ignore(pos, expected))
             kind = ASTExplainQuery::ExplainKind::QueryPlan; //-V1048
+        else if (s_estimates.ignore(pos, expected))
+            kind = ASTExplainQuery::ExplainKind::QueryEstimates; //-V1048
     }
     else
         return false;
diff --git a/src/Processors/QueryPlan/QueryPlan.cpp b/src/Processors/QueryPlan/QueryPlan.cpp
index 44c5c48975c5..bc3b8458531e 100644
--- a/src/Processors/QueryPlan/QueryPlan.cpp
+++ b/src/Processors/QueryPlan/QueryPlan.cpp
@@ -9,6 +9,7 @@
 #include <Processors/QueryPlan/Optimizations/Optimizations.h>
 #include <Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h>
 #include <Processors/QueryPlan/BuildQueryPipelineSettings.h>
+#include <Processors/QueryPlan/ReadFromMergeTree.h>
 #include <Common/JSONBuilder.h>
 
 namespace DB
@@ -434,4 +435,59 @@ void QueryPlan::optimize(const QueryPlanOptimizationSettings & optimization_sett
     QueryPlanOptimizations::optimizeTree(optimization_settings, *root, nodes);
 }
 
+void QueryPlan::explainEstimate(MutableColumns & columns)
+{
+    checkInitialized();
+
+    struct EstimateCounters
+    {
+        std::string database_name;
+        std::string table_name;
+        UInt64 parts = 0;
+        UInt64 rows = 0;
+        UInt64 marks = 0;
+
+        EstimateCounters(const std::string & database, const std::string & table) : database_name(database), table_name(table)
+        {
+        }
+    };
+
+    using CountersPtr = std::shared_ptr<EstimateCounters>;
+    std::unordered_map<std::string, CountersPtr> counters;
+    using processNodeFuncType = std::function<void(const Node * node)>;
+    processNodeFuncType process_node = [&counters, &process_node] (const Node * node)
+    {
+        if (!node)
+            return;
+        if (const auto * step = dynamic_cast<ReadFromMergeTree*>(node->step.get()))
+        {
+            const auto & id = step->getStorageID();
+            auto key = id.database_name + "." + id.table_name;
+            auto it = counters.find(key);
+            if (it == counters.end())
+            {
+                it = counters.insert({key, std::make_shared<EstimateCounters>(id.database_name, id.table_name)}).first;
+            }
+            it->second->parts += step->getSelectedParts();
+            it->second->rows += step->getSelectedRows();
+            it->second->marks += step->getSelectedMarks();
+        }
+        for (const auto * child : node->children)
+            process_node(child);
+    };
+    process_node(root);
+
+    for (const auto & counter : counters)
+    {
+        size_t index = 0;
+        const auto & database_name = counter.second->database_name;
+        const auto & table_name = counter.second->table_name;
+        columns[index++]->insertData(database_name.c_str(), database_name.size());
+        columns[index++]->insertData(table_name.c_str(), table_name.size());
+        columns[index++]->insert(counter.second->parts);
+        columns[index++]->insert(counter.second->rows);
+        columns[index++]->insert(counter.second->marks);
+    }
+}
+
 }
diff --git a/src/Processors/QueryPlan/QueryPlan.h b/src/Processors/QueryPlan/QueryPlan.h
index 4c75f00cf4d1..95034d34c9c1 100644
--- a/src/Processors/QueryPlan/QueryPlan.h
+++ b/src/Processors/QueryPlan/QueryPlan.h
@@ -2,6 +2,7 @@
 
 #include <Core/Names.h>
 #include <Interpreters/Context_fwd.h>
+#include <Columns/IColumn.h>
 
 #include <list>
 #include <memory>
@@ -85,6 +86,7 @@ class QueryPlan
     JSONBuilder::ItemPtr explainPlan(const ExplainPlanOptions & options);
     void explainPlan(WriteBuffer & buffer, const ExplainPlanOptions & options);
     void explainPipeline(WriteBuffer & buffer, const ExplainPipelineOptions & options);
+    void explainEstimate(MutableColumns & columns);
 
     /// Set upper limit for the recommend number of threads. Will be applied to the newly-created pipelines.
     /// TODO: make it in a better way.
diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
index 3cf1bdcb4d86..2983663d0ce3 100644
--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp
+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
@@ -47,6 +47,9 @@ struct ReadFromMergeTree::AnalysisResult
     IndexStats index_stats;
     Names column_names_to_read;
     ReadFromMergeTree::ReadType read_type = ReadFromMergeTree::ReadType::Default;
+    UInt64 selected_rows = 0;
+    UInt64 selected_marks = 0;
+    UInt64 selected_parts = 0;
 };
 
 static MergeTreeReaderSettings getMergeTreeReaderSettings(const ContextPtr & context)
@@ -839,13 +842,17 @@ ReadFromMergeTree::AnalysisResult ReadFromMergeTree::selectRangesToRead(MergeTre
 
     size_t sum_marks = 0;
     size_t sum_ranges = 0;
+    size_t sum_rows = 0;
 
     for (const auto & part : result.parts_with_ranges)
     {
         sum_ranges += part.ranges.size();
         sum_marks += part.getMarksCount();
+        sum_rows += part.getRowsCount();
     }
-
+    result.selected_parts = result.parts_with_ranges.size();
+    result.selected_marks = sum_marks;
+    result.selected_rows  = sum_rows;
     LOG_DEBUG(
         log,
         "Selected {}/{} parts by partition key, {} parts by primary key, {}/{} marks by primary key, {} marks to read from {} ranges",
@@ -883,6 +890,9 @@ void ReadFromMergeTree::initializePipeline(QueryPipeline & pipeline, const Build
         return;
     }
 
+    selected_marks = result.selected_marks;
+    selected_rows = result.selected_rows;
+    selected_parts = result.selected_parts;
     /// Projection, that needed to drop columns, which have appeared by execution
     /// of some extra expressions, and to allow execute the same expressions later.
     /// NOTE: It may lead to double computation of expressions.
diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h
index a5184d285934..b82e027420bb 100644
--- a/src/Processors/QueryPlan/ReadFromMergeTree.h
+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h
@@ -80,6 +80,10 @@ class ReadFromMergeTree final : public ISourceStep
     void describeActions(JSONBuilder::JSONMap & map) const override;
     void describeIndexes(JSONBuilder::JSONMap & map) const override;
 
+    const StorageID getStorageID() const { return data.getStorageID(); }
+    UInt64 getSelectedParts() const { return selected_parts; }
+    UInt64 getSelectedRows() const { return selected_rows; }
+    UInt64 getSelectedMarks() const { return selected_marks; }
 private:
     const MergeTreeReaderSettings reader_settings;
 
@@ -106,6 +110,9 @@ class ReadFromMergeTree final : public ISourceStep
     std::shared_ptr<PartitionIdToMaxBlock> max_block_numbers_to_read;
 
     Poco::Logger * log;
+    UInt64 selected_parts = 0;
+    UInt64 selected_rows = 0;
+    UInt64 selected_marks = 0;
 
     Pipe read(RangesInDataParts parts_with_range, Names required_columns, ReadType read_type, size_t max_streams, size_t min_marks_for_concurrent_read, bool use_uncompressed_cache);
     Pipe readFromPool(RangesInDataParts parts_with_ranges, Names required_columns, size_t max_streams, size_t min_marks_for_concurrent_read, bool use_uncompressed_cache);
