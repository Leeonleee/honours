{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 17707,
  "instance_id": "ClickHouse__ClickHouse-17707",
  "issue_numbers": [
    "17268"
  ],
  "base_commit": "65f9fda32832b3a571f5ca8f9252e0421722a8e9",
  "patch": "diff --git a/contrib/boost b/contrib/boost\nindex a04e72c0464f..a7ceabe4747e 160000\n--- a/contrib/boost\n+++ b/contrib/boost\n@@ -1,1 +1,1 @@\n-Subproject commit a04e72c0464f0c31d3384f18f0c0db36a05538e0\n+Subproject commit a7ceabe4747ecc3309dd3dcd9de4b29660dfd298\ndiff --git a/docs/en/sql-reference/statements/create/quota.md b/docs/en/sql-reference/statements/create/quota.md\nindex 29752050b694..20537b98a468 100644\n--- a/docs/en/sql-reference/statements/create/quota.md\n+++ b/docs/en/sql-reference/statements/create/quota.md\n@@ -11,7 +11,7 @@ Syntax:\n \n ``` sql\n CREATE QUOTA [IF NOT EXISTS | OR REPLACE] name [ON CLUSTER cluster_name]\n-    [KEYED BY {'none' | 'user name' | 'ip address' | 'client key' | 'client key or user name' | 'client key or ip address'}]\n+    [KEYED BY {'none' | 'user name' | 'ip address' | 'forwarded ip address' | 'client key' | 'client key or user name' | 'client key or ip address'}]\n     [FOR [RANDOMIZED] INTERVAL number {SECOND | MINUTE | HOUR | DAY | WEEK | MONTH | QUARTER | YEAR}\n         {MAX { {QUERIES | ERRORS | RESULT ROWS | RESULT BYTES | READ ROWS | READ BYTES | EXECUTION TIME} = number } [,...] |\n          NO LIMITS | TRACKING ONLY} [,...]]\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 26339c5ad3fb..ad849f3c6e5a 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -951,7 +951,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 socket.setReceiveTimeout(settings.receive_timeout);\n                 socket.setSendTimeout(settings.send_timeout);\n                 servers.emplace_back(std::make_unique<Poco::Net::TCPServer>(\n-                    new TCPHandlerFactory(*this),\n+                    new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ false),\n                     server_pool,\n                     socket,\n                     new Poco::Net::TCPServerParams));\n@@ -959,6 +959,22 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 LOG_INFO(log, \"Listening for connections with native protocol (tcp): {}\", address.toString());\n             });\n \n+            /// TCP with PROXY protocol, see https://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt\n+            create_server(\"tcp_with_proxy_port\", [&](UInt16 port)\n+            {\n+                Poco::Net::ServerSocket socket;\n+                auto address = socket_bind_listen(socket, listen_host, port);\n+                socket.setReceiveTimeout(settings.receive_timeout);\n+                socket.setSendTimeout(settings.send_timeout);\n+                servers.emplace_back(std::make_unique<Poco::Net::TCPServer>(\n+                    new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ true),\n+                    server_pool,\n+                    socket,\n+                    new Poco::Net::TCPServerParams));\n+\n+                LOG_INFO(log, \"Listening for connections with native protocol (tcp) with PROXY: {}\", address.toString());\n+            });\n+\n             /// TCP with SSL\n             create_server(\"tcp_port_secure\", [&](UInt16 port)\n             {\n@@ -968,7 +984,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 socket.setReceiveTimeout(settings.receive_timeout);\n                 socket.setSendTimeout(settings.send_timeout);\n                 servers.emplace_back(std::make_unique<Poco::Net::TCPServer>(\n-                    new TCPHandlerFactory(*this, /* secure= */ true),\n+                    new TCPHandlerFactory(*this, /* secure */ true, /* proxy protocol */ false),\n                     server_pool,\n                     socket,\n                     new Poco::Net::TCPServerParams));\ndiff --git a/programs/server/config.d/tcp_with_proxy.xml b/programs/server/config.d/tcp_with_proxy.xml\nnew file mode 120000\nindex 000000000000..6dc2b3fd1b93\n--- /dev/null\n+++ b/programs/server/config.d/tcp_with_proxy.xml\n@@ -0,0 +1,1 @@\n+../../../tests/config/config.d/tcp_with_proxy.xml\n\\ No newline at end of file\ndiff --git a/programs/server/config.xml b/programs/server/config.xml\nindex dde3702a44bd..9426ebd6c9ae 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -64,11 +64,18 @@\n     <http_port>8123</http_port>\n     <tcp_port>9000</tcp_port>\n     <mysql_port>9004</mysql_port>\n+\n     <!-- For HTTPS and SSL over native protocol. -->\n     <!--\n     <https_port>8443</https_port>\n     <tcp_port_secure>9440</tcp_port_secure>\n     -->\n+\n+    <!-- TCP with PROXY protocol (PROXY header sent for every connection) -->\n+    <!--\n+    <tcp_with_proxy_port>9010</tcp_with_proxy_port>\n+    -->\n+\n     <!-- Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/ClickHouse-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71 -->\n     <openSSL>\n         <server> <!-- Used for https server AND secure tcp port -->\ndiff --git a/src/Access/AccessControlManager.cpp b/src/Access/AccessControlManager.cpp\nindex a95d65ebb592..e874bda5b696 100644\n--- a/src/Access/AccessControlManager.cpp\n+++ b/src/Access/AccessControlManager.cpp\n@@ -15,6 +15,8 @@\n #include <common/find_symbols.h>\n #include <Poco/ExpireCache.h>\n #include <boost/algorithm/string/join.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/trim.hpp>\n #include <filesystem>\n #include <mutex>\n \n@@ -419,6 +421,18 @@ std::shared_ptr<const ContextAccess> AccessControlManager::getContextAccess(\n     params.http_method = client_info.http_method;\n     params.address = client_info.current_address.host();\n     params.quota_key = client_info.quota_key;\n+\n+    /// Extract the last entry from comma separated list of X-Forwarded-For addresses.\n+    /// Only the last proxy can be trusted (if any).\n+    Strings forwarded_addresses;\n+    boost::split(forwarded_addresses, client_info.forwarded_for, boost::is_any_of(\",\"));\n+    if (!forwarded_addresses.empty())\n+    {\n+        String & last_forwarded_address = forwarded_addresses.back();\n+        boost::trim(last_forwarded_address);\n+        params.forwarded_address = last_forwarded_address;\n+    }\n+\n     return getContextAccess(params);\n }\n \n@@ -444,9 +458,14 @@ std::shared_ptr<const EnabledRowPolicies> AccessControlManager::getEnabledRowPol\n \n \n std::shared_ptr<const EnabledQuota> AccessControlManager::getEnabledQuota(\n-    const UUID & user_id, const String & user_name, const boost::container::flat_set<UUID> & enabled_roles, const Poco::Net::IPAddress & address, const String & custom_quota_key) const\n+    const UUID & user_id,\n+    const String & user_name,\n+    const boost::container::flat_set<UUID> & enabled_roles,\n+    const Poco::Net::IPAddress & address,\n+    const String & forwarded_address,\n+    const String & custom_quota_key) const\n {\n-    return quota_cache->getEnabledQuota(user_id, user_name, enabled_roles, address, custom_quota_key);\n+    return quota_cache->getEnabledQuota(user_id, user_name, enabled_roles, address, forwarded_address, custom_quota_key);\n }\n \n \ndiff --git a/src/Access/AccessControlManager.h b/src/Access/AccessControlManager.h\nindex c960b330ee6a..07edfd934753 100644\n--- a/src/Access/AccessControlManager.h\n+++ b/src/Access/AccessControlManager.h\n@@ -135,6 +135,7 @@ class AccessControlManager : public MultipleAccessStorage\n         const String & user_name,\n         const boost::container::flat_set<UUID> & enabled_roles,\n         const Poco::Net::IPAddress & address,\n+        const String & forwarded_address,\n         const String & custom_quota_key) const;\n \n     std::vector<QuotaUsage> getAllQuotasUsage() const;\ndiff --git a/src/Access/ContextAccess.cpp b/src/Access/ContextAccess.cpp\nindex 0459022cb1ad..0e4f3fe78714 100644\n--- a/src/Access/ContextAccess.cpp\n+++ b/src/Access/ContextAccess.cpp\n@@ -258,9 +258,12 @@ void ContextAccess::setRolesInfo(const std::shared_ptr<const EnabledRolesInfo> &\n {\n     assert(roles_info_);\n     roles_info = roles_info_;\n-    enabled_row_policies = manager->getEnabledRowPolicies(*params.user_id, roles_info->enabled_roles);\n-    enabled_quota = manager->getEnabledQuota(*params.user_id, user_name, roles_info->enabled_roles, params.address, params.quota_key);\n-    enabled_settings = manager->getEnabledSettings(*params.user_id, user->settings, roles_info->enabled_roles, roles_info->settings_from_enabled_roles);\n+    enabled_row_policies = manager->getEnabledRowPolicies(\n+        *params.user_id, roles_info->enabled_roles);\n+    enabled_quota = manager->getEnabledQuota(\n+        *params.user_id, user_name, roles_info->enabled_roles, params.address, params.forwarded_address, params.quota_key);\n+    enabled_settings = manager->getEnabledSettings(\n+        *params.user_id, user->settings, roles_info->enabled_roles, roles_info->settings_from_enabled_roles);\n     calculateAccessRights();\n }\n \ndiff --git a/src/Access/ContextAccess.h b/src/Access/ContextAccess.h\nindex fd7d7c019229..319c8edb0768 100644\n--- a/src/Access/ContextAccess.h\n+++ b/src/Access/ContextAccess.h\n@@ -41,9 +41,16 @@ struct ContextAccessParams\n     ClientInfo::Interface interface = ClientInfo::Interface::TCP;\n     ClientInfo::HTTPMethod http_method = ClientInfo::HTTPMethod::UNKNOWN;\n     Poco::Net::IPAddress address;\n+    String forwarded_address;\n     String quota_key;\n \n-    auto toTuple() const { return std::tie(user_id, current_roles, use_default_roles, readonly, allow_ddl, allow_introspection, current_database, interface, http_method, address, quota_key); }\n+    auto toTuple() const\n+    {\n+        return std::tie(\n+            user_id, current_roles, use_default_roles, readonly, allow_ddl, allow_introspection,\n+            current_database, interface, http_method, address, forwarded_address, quota_key);\n+    }\n+\n     friend bool operator ==(const ContextAccessParams & lhs, const ContextAccessParams & rhs) { return lhs.toTuple() == rhs.toTuple(); }\n     friend bool operator !=(const ContextAccessParams & lhs, const ContextAccessParams & rhs) { return !(lhs == rhs); }\n     friend bool operator <(const ContextAccessParams & lhs, const ContextAccessParams & rhs) { return lhs.toTuple() < rhs.toTuple(); }\ndiff --git a/src/Access/EnabledQuota.h b/src/Access/EnabledQuota.h\nindex 25e804dd0502..7ae107e45e33 100644\n--- a/src/Access/EnabledQuota.h\n+++ b/src/Access/EnabledQuota.h\n@@ -25,9 +25,10 @@ class EnabledQuota : public boost::noncopyable\n         String user_name;\n         boost::container::flat_set<UUID> enabled_roles;\n         Poco::Net::IPAddress client_address;\n+        String forwarded_address;\n         String client_key;\n \n-        auto toTuple() const { return std::tie(user_id, enabled_roles, user_name, client_address, client_key); }\n+        auto toTuple() const { return std::tie(user_id, enabled_roles, user_name, client_address, forwarded_address, client_key); }\n         friend bool operator ==(const Params & lhs, const Params & rhs) { return lhs.toTuple() == rhs.toTuple(); }\n         friend bool operator !=(const Params & lhs, const Params & rhs) { return !(lhs == rhs); }\n         friend bool operator <(const Params & lhs, const Params & rhs) { return lhs.toTuple() < rhs.toTuple(); }\ndiff --git a/src/Access/Quota.h b/src/Access/Quota.h\nindex 5bbea36cfda4..b636e83ec409 100644\n--- a/src/Access/Quota.h\n+++ b/src/Access/Quota.h\n@@ -76,6 +76,7 @@ struct Quota : public IAccessEntity\n         NONE,       /// All users share the same quota.\n         USER_NAME,  /// Connections with the same user name share the same quota.\n         IP_ADDRESS, /// Connections from the same IP share the same quota.\n+        FORWARDED_IP_ADDRESS, /// Use X-Forwarded-For HTTP header instead of IP address.\n         CLIENT_KEY, /// Client should explicitly supply a key to use.\n         CLIENT_KEY_OR_USER_NAME,  /// Same as CLIENT_KEY, but use USER_NAME if the client doesn't supply a key.\n         CLIENT_KEY_OR_IP_ADDRESS, /// Same as CLIENT_KEY, but use IP_ADDRESS if the client doesn't supply a key.\n@@ -205,12 +206,16 @@ inline const Quota::KeyTypeInfo & Quota::KeyTypeInfo::get(KeyType type)\n         if (tokens.size() > 1)\n         {\n             for (const auto & token : tokens)\n+            {\n                 for (auto kt : ext::range(KeyType::MAX))\n+                {\n                     if (KeyTypeInfo::get(kt).name == token)\n                     {\n                         init_base_types.push_back(kt);\n                         break;\n                     }\n+                }\n+            }\n         }\n         return KeyTypeInfo{raw_name_, std::move(init_name), std::move(init_base_types)};\n     };\n@@ -232,6 +237,11 @@ inline const Quota::KeyTypeInfo & Quota::KeyTypeInfo::get(KeyType type)\n             static const auto info = make_info(\"IP_ADDRESS\");\n             return info;\n         }\n+        case KeyType::FORWARDED_IP_ADDRESS:\n+        {\n+            static const auto info = make_info(\"FORWARDED_IP_ADDRESS\");\n+            return info;\n+        }\n         case KeyType::CLIENT_KEY:\n         {\n             static const auto info = make_info(\"CLIENT_KEY\");\ndiff --git a/src/Access/QuotaCache.cpp b/src/Access/QuotaCache.cpp\nindex d3ebca9529c3..0f814bced4e9 100644\n--- a/src/Access/QuotaCache.cpp\n+++ b/src/Access/QuotaCache.cpp\n@@ -48,11 +48,21 @@ String QuotaCache::QuotaInfo::calculateKey(const EnabledQuota & enabled) const\n     switch (quota->key_type)\n     {\n         case KeyType::NONE:\n+        {\n             return \"\";\n+        }\n         case KeyType::USER_NAME:\n+        {\n             return params.user_name;\n+        }\n         case KeyType::IP_ADDRESS:\n+        {\n             return params.client_address.toString();\n+        }\n+        case KeyType::FORWARDED_IP_ADDRESS:\n+        {\n+            return params.forwarded_address;\n+        }\n         case KeyType::CLIENT_KEY:\n         {\n             if (!params.client_key.empty())\n@@ -170,7 +180,7 @@ QuotaCache::QuotaCache(const AccessControlManager & access_control_manager_)\n QuotaCache::~QuotaCache() = default;\n \n \n-std::shared_ptr<const EnabledQuota> QuotaCache::getEnabledQuota(const UUID & user_id, const String & user_name, const boost::container::flat_set<UUID> & enabled_roles, const Poco::Net::IPAddress & client_address, const String & client_key)\n+std::shared_ptr<const EnabledQuota> QuotaCache::getEnabledQuota(const UUID & user_id, const String & user_name, const boost::container::flat_set<UUID> & enabled_roles, const Poco::Net::IPAddress & client_address, const String & forwarded_address, const String & client_key)\n {\n     std::lock_guard lock{mutex};\n     ensureAllQuotasRead();\n@@ -180,6 +190,7 @@ std::shared_ptr<const EnabledQuota> QuotaCache::getEnabledQuota(const UUID & use\n     params.user_name = user_name;\n     params.enabled_roles = enabled_roles;\n     params.client_address = client_address;\n+    params.forwarded_address = forwarded_address;\n     params.client_key = client_key;\n     auto it = enabled_quotas.find(params);\n     if (it != enabled_quotas.end())\ndiff --git a/src/Access/QuotaCache.h b/src/Access/QuotaCache.h\nindex 0bb5c11a82b1..31d274c4ff62 100644\n--- a/src/Access/QuotaCache.h\n+++ b/src/Access/QuotaCache.h\n@@ -20,7 +20,14 @@ class QuotaCache\n     QuotaCache(const AccessControlManager & access_control_manager_);\n     ~QuotaCache();\n \n-    std::shared_ptr<const EnabledQuota> getEnabledQuota(const UUID & user_id, const String & user_name, const boost::container::flat_set<UUID> & enabled_roles, const Poco::Net::IPAddress & address, const String & client_key);\n+    std::shared_ptr<const EnabledQuota> getEnabledQuota(\n+        const UUID & user_id,\n+        const String & user_name,\n+        const boost::container::flat_set<UUID> & enabled_roles,\n+        const Poco::Net::IPAddress & address,\n+        const String & forwarded_address,\n+        const String & client_key);\n+\n     std::vector<QuotaUsage> getAllQuotasUsage() const;\n \n private:\ndiff --git a/src/Access/UsersConfigAccessStorage.cpp b/src/Access/UsersConfigAccessStorage.cpp\nindex eb993d696c6c..b3f151c30308 100644\n--- a/src/Access/UsersConfigAccessStorage.cpp\n+++ b/src/Access/UsersConfigAccessStorage.cpp\n@@ -215,6 +215,8 @@ namespace\n         String quota_config = \"quotas.\" + quota_name;\n         if (config.has(quota_config + \".keyed_by_ip\"))\n             quota->key_type = KeyType::IP_ADDRESS;\n+        else if (config.has(quota_config + \".keyed_by_forwarded_ip\"))\n+            quota->key_type = KeyType::FORWARDED_IP_ADDRESS;\n         else if (config.has(quota_config + \".keyed\"))\n             quota->key_type = KeyType::CLIENT_KEY_OR_USER_NAME;\n         else\ndiff --git a/src/Core/Defines.h b/src/Core/Defines.h\nindex 9b6578092c9a..f1cd1a8a7080 100644\n--- a/src/Core/Defines.h\n+++ b/src/Core/Defines.h\n@@ -73,8 +73,10 @@\n /// Minimum revision supporting interserver secret.\n #define DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET 54441\n \n+#define DBMS_MIN_REVISION_WITH_X_FORWARDED_FOR_IN_CLIENT_INFO 54443\n+\n /// Version of ClickHouse TCP protocol. Increment it manually when you change the protocol.\n-#define DBMS_TCP_PROTOCOL_VERSION 54442\n+#define DBMS_TCP_PROTOCOL_VERSION 54443\n \n /// The boundary on which the blocks for asynchronous file operations should be aligned.\n #define DEFAULT_AIO_FILE_BLOCK_SIZE 4096\ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex 8232ce0b22db..e290da39535c 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -194,12 +194,12 @@ inline void appendToStringOrVector(PODArray<char> & s, ReadBuffer & rb, const ch\n     s.insert(rb.position(), end);\n }\n \n-template <typename Vector>\n-void readStringInto(Vector & s, ReadBuffer & buf)\n+template <char... chars, typename Vector>\n+void readStringUntilCharsInto(Vector & s, ReadBuffer & buf)\n {\n     while (!buf.eof())\n     {\n-        char * next_pos = find_first_symbols<'\\t', '\\n'>(buf.position(), buf.buffer().end());\n+        char * next_pos = find_first_symbols<chars...>(buf.position(), buf.buffer().end());\n \n         appendToStringOrVector(s, buf, next_pos);\n         buf.position() = next_pos;\n@@ -210,21 +210,30 @@ void readStringInto(Vector & s, ReadBuffer & buf)\n }\n \n template <typename Vector>\n-void readNullTerminated(Vector & s, ReadBuffer & buf)\n+void readStringInto(Vector & s, ReadBuffer & buf)\n {\n-    while (!buf.eof())\n-    {\n-        char * next_pos = find_first_symbols<'\\0'>(buf.position(), buf.buffer().end());\n+    readStringUntilCharsInto<'\\t', '\\n'>(s, buf);\n+}\n \n-        appendToStringOrVector(s, buf, next_pos);\n-        buf.position() = next_pos;\n+template <typename Vector>\n+void readStringUntilWhitespaceInto(Vector & s, ReadBuffer & buf)\n+{\n+    readStringUntilCharsInto<' '>(s, buf);\n+}\n \n-        if (buf.hasPendingData())\n-            break;\n-    }\n+template <typename Vector>\n+void readNullTerminated(Vector & s, ReadBuffer & buf)\n+{\n+    readStringUntilCharsInto<'\\0'>(s, buf);\n     buf.ignore();\n }\n \n+void readStringUntilWhitespace(String & s, ReadBuffer & buf)\n+{\n+    s.clear();\n+    readStringUntilWhitespaceInto(s, buf);\n+}\n+\n template void readNullTerminated<PODArray<char>>(PODArray<char> & s, ReadBuffer & buf);\n template void readNullTerminated<String>(String & s, ReadBuffer & buf);\n \ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex a4531ebc24db..39a0d60059f7 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -476,6 +476,9 @@ void readStringUntilEOF(String & s, ReadBuffer & buf);\n // Buffer pointer is left at EOL, don't forget to advance it.\n void readEscapedStringUntilEOL(String & s, ReadBuffer & buf);\n \n+/// Only 0x20 as whitespace character\n+void readStringUntilWhitespace(String & s, ReadBuffer & buf);\n+\n \n /** Read string in CSV format.\n   * Parsing rules:\n@@ -527,6 +530,9 @@ bool tryReadJSONStringInto(Vector & s, ReadBuffer & buf)\n     return readJSONStringInto<Vector, bool>(s, buf);\n }\n \n+template <typename Vector>\n+void readStringUntilWhitespaceInto(Vector & s, ReadBuffer & buf);\n+\n /// This could be used as template parameter for functions above, if you want to just skip data.\n struct NullOutput\n {\ndiff --git a/src/Interpreters/ClientInfo.cpp b/src/Interpreters/ClientInfo.cpp\nindex 4dbec8af3a41..30aa8a0c6920 100644\n--- a/src/Interpreters/ClientInfo.cpp\n+++ b/src/Interpreters/ClientInfo.cpp\n@@ -49,6 +49,9 @@ void ClientInfo::write(WriteBuffer & out, const UInt64 server_protocol_revision)\n     {\n         writeBinary(UInt8(http_method), out);\n         writeBinary(http_user_agent, out);\n+\n+        if (server_protocol_revision >= DBMS_MIN_REVISION_WITH_X_FORWARDED_FOR_IN_CLIENT_INFO)\n+            writeBinary(forwarded_for, out);\n     }\n \n     if (server_protocol_revision >= DBMS_MIN_REVISION_WITH_QUOTA_KEY_IN_CLIENT_INFO)\n@@ -120,6 +123,9 @@ void ClientInfo::read(ReadBuffer & in, const UInt64 client_protocol_revision)\n         http_method = HTTPMethod(read_http_method);\n \n         readBinary(http_user_agent, in);\n+\n+        if (client_protocol_revision >= DBMS_MIN_REVISION_WITH_X_FORWARDED_FOR_IN_CLIENT_INFO)\n+            readBinary(forwarded_for, in);\n     }\n \n     if (client_protocol_revision >= DBMS_MIN_REVISION_WITH_QUOTA_KEY_IN_CLIENT_INFO)\ndiff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h\nindex 36cde339995c..e188420d6075 100644\n--- a/src/Interpreters/ClientInfo.h\n+++ b/src/Interpreters/ClientInfo.h\n@@ -83,6 +83,12 @@ class ClientInfo\n     HTTPMethod http_method = HTTPMethod::UNKNOWN;\n     String http_user_agent;\n \n+    /// Comma separated list of forwarded IP addresses (from X-Forwarded-For for HTTP interface).\n+    /// It's expected that proxy appends the forwarded address to the end of the list.\n+    /// The element can be trusted only if you trust the corresponding proxy.\n+    /// NOTE This field can also be reused in future for TCP interface with PROXY v1/v2 protocols.\n+    String forwarded_for;\n+\n     /// Common\n     String quota_key;\n \ndiff --git a/src/Interpreters/QueryLog.cpp b/src/Interpreters/QueryLog.cpp\nindex c2273a1db2c5..e5d68870f875 100644\n--- a/src/Interpreters/QueryLog.cpp\n+++ b/src/Interpreters/QueryLog.cpp\n@@ -77,6 +77,7 @@ Block QueryLogElement::createBlock()\n         {std::make_shared<DataTypeUInt32>(),                                  \"client_version_patch\"},\n         {std::make_shared<DataTypeUInt8>(),                                   \"http_method\"},\n         {std::make_shared<DataTypeString>(),                                  \"http_user_agent\"},\n+        {std::make_shared<DataTypeString>(),                                  \"forwarded_for\"},\n         {std::make_shared<DataTypeString>(),                                  \"quota_key\"},\n \n         {std::make_shared<DataTypeUInt32>(),                                  \"revision\"},\n@@ -181,6 +182,7 @@ void QueryLogElement::appendClientInfo(const ClientInfo & client_info, MutableCo\n \n     columns[i++]->insert(UInt64(client_info.http_method));\n     columns[i++]->insert(client_info.http_user_agent);\n+    columns[i++]->insert(client_info.forwarded_for);\n \n     columns[i++]->insert(client_info.quota_key);\n }\ndiff --git a/src/Interpreters/QueryThreadLog.cpp b/src/Interpreters/QueryThreadLog.cpp\nindex 8fea360085b8..986bedcfc158 100644\n--- a/src/Interpreters/QueryThreadLog.cpp\n+++ b/src/Interpreters/QueryThreadLog.cpp\n@@ -60,6 +60,7 @@ Block QueryThreadLogElement::createBlock()\n         {std::make_shared<DataTypeUInt32>(),        \"client_version_patch\"},\n         {std::make_shared<DataTypeUInt8>(),         \"http_method\"},\n         {std::make_shared<DataTypeString>(),        \"http_user_agent\"},\n+        {std::make_shared<DataTypeString>(),        \"forwarded_for\"},\n         {std::make_shared<DataTypeString>(),        \"quota_key\"},\n \n         {std::make_shared<DataTypeUInt32>(),        \"revision\"},\ndiff --git a/src/Parsers/ParserCreateQuotaQuery.cpp b/src/Parsers/ParserCreateQuotaQuery.cpp\nindex 324519b9c017..68c53d2fc1d8 100644\n--- a/src/Parsers/ParserCreateQuotaQuery.cpp\n+++ b/src/Parsers/ParserCreateQuotaQuery.cpp\n@@ -63,11 +63,13 @@ namespace\n             boost::replace_all(name, \" \", \"_\");\n \n             for (auto kt : ext::range(Quota::KeyType::MAX))\n+            {\n                 if (KeyTypeInfo::get(kt).name == name)\n                 {\n                     key_type = kt;\n                     return true;\n                 }\n+            }\n \n             String all_types_str;\n             for (auto kt : ext::range(Quota::KeyType::MAX))\ndiff --git a/src/Parsers/ParserCreateQuotaQuery.h b/src/Parsers/ParserCreateQuotaQuery.h\nindex 1f1df0588bd9..b44838225ac0 100644\n--- a/src/Parsers/ParserCreateQuotaQuery.h\n+++ b/src/Parsers/ParserCreateQuotaQuery.h\n@@ -7,7 +7,7 @@ namespace DB\n {\n /** Parses queries like\n   * CREATE QUOTA [IF NOT EXISTS | OR REPLACE] name\n-  *      [KEYED BY {none | user_name | ip_address | client_key | client_key, user_name | client_key, ip_address} | NOT KEYED]\n+  *      [KEYED BY {none | user_name | ip_address | forwarded_ip_address | client_key | client_key, user_name | client_key, ip_address} | NOT KEYED]\n   *      [FOR [RANDOMIZED] INTERVAL number {second | minute | hour | day | week | month | quarter | year}\n   *       {MAX {{queries | errors | result_rows | result_bytes | read_rows | read_bytes | execution_time} = number} [,...] |\n   *        NO LIMITS | TRACKING ONLY} [,...]]\n@@ -15,7 +15,7 @@ namespace DB\n   *\n   * ALTER QUOTA [IF EXISTS] name\n   *      [RENAME TO new_name]\n-  *      [KEYED BY {none | user_name | ip_address | client_key | client_key, user_name | client_key, ip_address} | NOT KEYED]\n+  *      [KEYED BY {none | user_name | ip_address | forwarded_ip_address | client_key | client_key, user_name | client_key, ip_address} | NOT KEYED]\n   *      [FOR [RANDOMIZED] INTERVAL number {second | minute | hour | day | week | month | quarter | year}\n   *       {MAX {{queries | errors | result_rows | result_bytes | read_rows | read_bytes | execution_time} = number} [,...] |\n   *        NO LIMITS | TRACKING ONLY} [,...]]\ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex 34d510e4cb29..ed154ba65f27 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -280,10 +280,31 @@ void HTTPHandler::processQuery(\n         }\n     }\n \n+    /// Set client info. It will be used for quota accounting parameters in 'setUser' method.\n+\n+    ClientInfo & client_info = context.getClientInfo();\n+    client_info.query_kind = ClientInfo::QueryKind::INITIAL_QUERY;\n+    client_info.interface = ClientInfo::Interface::HTTP;\n+\n+    ClientInfo::HTTPMethod http_method = ClientInfo::HTTPMethod::UNKNOWN;\n+    if (request.getMethod() == Poco::Net::HTTPServerRequest::HTTP_GET)\n+        http_method = ClientInfo::HTTPMethod::GET;\n+    else if (request.getMethod() == Poco::Net::HTTPServerRequest::HTTP_POST)\n+        http_method = ClientInfo::HTTPMethod::POST;\n+\n+    client_info.http_method = http_method;\n+    client_info.http_user_agent = request.get(\"User-Agent\", \"\");\n+    client_info.forwarded_for = request.get(\"X-Forwarded-For\", \"\");\n+\n+    /// This will also set client_info.current_user and current_address\n     context.setUser(user, password, request.clientAddress());\n     if (!quota_key.empty())\n         context.setQuotaKey(quota_key);\n \n+    /// Query sent through HTTP interface is initial.\n+    client_info.initial_user = client_info.current_user;\n+    client_info.initial_address = client_info.current_address;\n+\n     /// The user could specify session identifier and session timeout.\n     /// It allows to modify settings, create temporary tables and reuse them in subsequent requests.\n \n@@ -335,6 +356,8 @@ void HTTPHandler::processQuery(\n     context.setCurrentQueryId(params.get(\"query_id\",\n         request.get(\"X-ClickHouse-Query-Id\", \"\")));\n \n+    client_info.initial_query_id = client_info.current_query_id;\n+\n     /// The client can pass a HTTP header indicating supported compression method (gzip or deflate).\n     String http_response_compression_methods = request.get(\"Accept-Encoding\", \"\");\n     CompressionMethod http_response_compression_method = CompressionMethod::None;\n@@ -561,24 +584,6 @@ void HTTPHandler::processQuery(\n     /// Origin header.\n     used_output.out->addHeaderCORS(settings.add_http_cors_header && !request.get(\"Origin\", \"\").empty());\n \n-    ClientInfo & client_info = context.getClientInfo();\n-    client_info.query_kind = ClientInfo::QueryKind::INITIAL_QUERY;\n-    client_info.interface = ClientInfo::Interface::HTTP;\n-\n-    /// Query sent through HTTP interface is initial.\n-    client_info.initial_user = client_info.current_user;\n-    client_info.initial_query_id = client_info.current_query_id;\n-    client_info.initial_address = client_info.current_address;\n-\n-    ClientInfo::HTTPMethod http_method = ClientInfo::HTTPMethod::UNKNOWN;\n-    if (request.getMethod() == Poco::Net::HTTPServerRequest::HTTP_GET)\n-        http_method = ClientInfo::HTTPMethod::GET;\n-    else if (request.getMethod() == Poco::Net::HTTPServerRequest::HTTP_POST)\n-        http_method = ClientInfo::HTTPMethod::POST;\n-\n-    client_info.http_method = http_method;\n-    client_info.http_user_agent = request.get(\"User-Agent\", \"\");\n-\n     auto append_callback = [&context] (ProgressCallback callback)\n     {\n         auto prev = context.getProgressCallback();\ndiff --git a/src/Server/HTTPHandlerFactory.cpp b/src/Server/HTTPHandlerFactory.cpp\nindex 8915ea747ca9..9eac60355d23 100644\n--- a/src/Server/HTTPHandlerFactory.cpp\n+++ b/src/Server/HTTPHandlerFactory.cpp\n@@ -31,10 +31,10 @@ HTTPRequestHandlerFactoryMain::HTTPRequestHandlerFactoryMain(const std::string &\n \n Poco::Net::HTTPRequestHandler * HTTPRequestHandlerFactoryMain::createRequestHandler(const Poco::Net::HTTPServerRequest & request)\n {\n-    LOG_TRACE(log, \"HTTP Request for {}. Method: {}, Address: {}, User-Agent: {}{}, Content Type: {}, Transfer Encoding: {}\",\n-        name, request.getMethod(), request.clientAddress().toString(), request.has(\"User-Agent\") ? request.get(\"User-Agent\") : \"none\",\n+    LOG_TRACE(log, \"HTTP Request for {}. Method: {}, Address: {}, User-Agent: {}{}, Content Type: {}, Transfer Encoding: {}, X-Forwarded-For: {}\",\n+        name, request.getMethod(), request.clientAddress().toString(), request.get(\"User-Agent\", \"(none)\"),\n         (request.hasContentLength() ? (\", Length: \" + std::to_string(request.getContentLength())) : (\"\")),\n-        request.getContentType(), request.getTransferEncoding());\n+        request.getContentType(), request.getTransferEncoding(), request.get(\"X-Forwarded-For\", \"(none)\"));\n \n     for (auto & handler_factory : child_factories)\n     {\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex 1f55a3af6353..e84c89bd1650 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -11,6 +11,7 @@\n #include <Compression/CompressedWriteBuffer.h>\n #include <IO/ReadBufferFromPocoSocket.h>\n #include <IO/WriteBufferFromPocoSocket.h>\n+#include <IO/LimitReadBuffer.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n #include <IO/copyData.h>\n@@ -76,6 +77,10 @@ void TCPHandler::runImpl()\n     in = std::make_shared<ReadBufferFromPocoSocket>(socket());\n     out = std::make_shared<WriteBufferFromPocoSocket>(socket());\n \n+    /// Support for PROXY protocol\n+    if (parse_proxy_protocol && !receiveProxyHeader())\n+        return;\n+\n     if (in->eof())\n     {\n         LOG_WARNING(log, \"Client has not sent any data.\");\n@@ -728,6 +733,78 @@ void TCPHandler::sendExtremes(const Block & extremes)\n }\n \n \n+bool TCPHandler::receiveProxyHeader()\n+{\n+    if (in->eof())\n+    {\n+        LOG_WARNING(log, \"Client has not sent any data.\");\n+        return false;\n+    }\n+\n+    String forwarded_address;\n+\n+    /// Only PROXYv1 is supported.\n+    /// Validation of protocol is not fully performed.\n+\n+    LimitReadBuffer limit_in(*in, 107, true); /// Maximum length from the specs.\n+\n+    assertString(\"PROXY \", limit_in);\n+\n+    if (limit_in.eof())\n+    {\n+        LOG_WARNING(log, \"Incomplete PROXY header is received.\");\n+        return false;\n+    }\n+\n+    /// TCP4 / TCP6 / UNKNOWN\n+    if ('T' == *limit_in.position())\n+    {\n+        assertString(\"TCP\", limit_in);\n+\n+        if (limit_in.eof())\n+        {\n+            LOG_WARNING(log, \"Incomplete PROXY header is received.\");\n+            return false;\n+        }\n+\n+        if ('4' != *limit_in.position() && '6' != *limit_in.position())\n+        {\n+            LOG_WARNING(log, \"Unexpected protocol in PROXY header is received.\");\n+            return false;\n+        }\n+\n+        ++limit_in.position();\n+        assertChar(' ', limit_in);\n+\n+        /// Read the first field and ignore other.\n+        readStringUntilWhitespace(forwarded_address, limit_in);\n+\n+        /// Skip until \\r\\n\n+        while (!limit_in.eof() && *limit_in.position() != '\\r')\n+            ++limit_in.position();\n+        assertString(\"\\r\\n\", limit_in);\n+    }\n+    else if (checkString(\"UNKNOWN\", limit_in))\n+    {\n+        /// This is just a health check, there is no subsequent data in this connection.\n+\n+        while (!limit_in.eof() && *limit_in.position() != '\\r')\n+            ++limit_in.position();\n+        assertString(\"\\r\\n\", limit_in);\n+        return false;\n+    }\n+    else\n+    {\n+        LOG_WARNING(log, \"Unexpected protocol in PROXY header is received.\");\n+        return false;\n+    }\n+\n+    LOG_TRACE(log, \"Forwarded client address from PROXY header: {}\", forwarded_address);\n+    connection_context.getClientInfo().forwarded_for = forwarded_address;\n+    return true;\n+}\n+\n+\n void TCPHandler::receiveHello()\n {\n     /// Receive `hello` packet.\ndiff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h\nindex 2f2bf35e59e0..e12e9bcf4d0f 100644\n--- a/src/Server/TCPHandler.h\n+++ b/src/Server/TCPHandler.h\n@@ -101,9 +101,18 @@ struct LastBlockInputParameters\n class TCPHandler : public Poco::Net::TCPServerConnection\n {\n public:\n-    TCPHandler(IServer & server_, const Poco::Net::StreamSocket & socket_)\n+    /** parse_proxy_protocol_ - if true, expect and parse the header of PROXY protocol in every connection\n+      * and set the information about forwarded address accordingly.\n+      * See https://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt\n+      *\n+      * Note: immediate IP address is always used for access control (accept-list of IP networks),\n+      *  because it allows to check the IP ranges of the trusted proxy.\n+      * Proxy-forwarded (original client) IP address is used for quota accounting if quota is keyed by forwarded IP.\n+      */\n+    TCPHandler(IServer & server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_)\n         : Poco::Net::TCPServerConnection(socket_)\n         , server(server_)\n+        , parse_proxy_protocol(parse_proxy_protocol_)\n         , log(&Poco::Logger::get(\"TCPHandler\"))\n         , connection_context(server.context())\n         , query_context(server.context())\n@@ -118,6 +127,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n \n private:\n     IServer & server;\n+    bool parse_proxy_protocol = false;\n     Poco::Logger * log;\n \n     String client_name;\n@@ -158,6 +168,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n \n     void runImpl();\n \n+    bool receiveProxyHeader();\n     void receiveHello();\n     bool receivePacket();\n     void receiveQuery();\ndiff --git a/src/Server/TCPHandlerFactory.h b/src/Server/TCPHandlerFactory.h\nindex 5ecd427bf8b6..5096983274dd 100644\n--- a/src/Server/TCPHandlerFactory.h\n+++ b/src/Server/TCPHandlerFactory.h\n@@ -15,6 +15,7 @@ class TCPHandlerFactory : public Poco::Net::TCPServerConnectionFactory\n {\n private:\n     IServer & server;\n+    bool parse_proxy_protocol = false;\n     Poco::Logger * log;\n \n     class DummyTCPHandler : public Poco::Net::TCPServerConnection\n@@ -25,8 +26,12 @@ class TCPHandlerFactory : public Poco::Net::TCPServerConnectionFactory\n     };\n \n public:\n-    explicit TCPHandlerFactory(IServer & server_, bool secure_ = false)\n-        : server(server_)\n+    /** parse_proxy_protocol_ - if true, expect and parse the header of PROXY protocol in every connection\n+      * and set the information about forwarded address accordingly.\n+      * See https://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt\n+      */\n+    TCPHandlerFactory(IServer & server_, bool secure_, bool parse_proxy_protocol_)\n+        : server(server_), parse_proxy_protocol(parse_proxy_protocol_)\n         , log(&Poco::Logger::get(std::string(\"TCP\") + (secure_ ? \"S\" : \"\") + \"HandlerFactory\"))\n     {\n     }\n@@ -36,7 +41,7 @@ class TCPHandlerFactory : public Poco::Net::TCPServerConnectionFactory\n         try\n         {\n             LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n-            return new TCPHandler(server, socket);\n+            return new TCPHandler(server, socket, parse_proxy_protocol);\n         }\n         catch (const Poco::Net::NetException &)\n         {\ndiff --git a/src/Storages/System/StorageSystemProcesses.cpp b/src/Storages/System/StorageSystemProcesses.cpp\nindex d899a1708bf7..178eedd9ad71 100644\n--- a/src/Storages/System/StorageSystemProcesses.cpp\n+++ b/src/Storages/System/StorageSystemProcesses.cpp\n@@ -43,6 +43,7 @@ NamesAndTypesList StorageSystemProcesses::getNamesAndTypes()\n \n         {\"http_method\", std::make_shared<DataTypeUInt8>()},\n         {\"http_user_agent\", std::make_shared<DataTypeString>()},\n+        {\"forwarded_for\", std::make_shared<DataTypeString>()},\n \n         {\"quota_key\", std::make_shared<DataTypeString>()},\n \n@@ -98,6 +99,7 @@ void StorageSystemProcesses::fillData(MutableColumns & res_columns, const Contex\n \n         res_columns[i++]->insert(UInt64(process.client_info.http_method));\n         res_columns[i++]->insert(process.client_info.http_user_agent);\n+        res_columns[i++]->insert(process.client_info.forwarded_for);\n \n         res_columns[i++]->insert(process.client_info.quota_key);\n \n",
  "test_patch": "diff --git a/docker/test/fasttest/run.sh b/docker/test/fasttest/run.sh\nindex fb905bdaa5d5..21cd80198d46 100755\n--- a/docker/test/fasttest/run.sh\n+++ b/docker/test/fasttest/run.sh\n@@ -318,6 +318,9 @@ function run_tests\n         01545_system_errors\n         # Checks system.errors\n         01563_distributed_query_finish\n+\n+        # nc - command not found\n+        01601_proxy_protocol\n     )\n \n     time clickhouse-test -j 8 --order=random --no-long --testname --shard --zookeeper --skip \"${TESTS_TO_SKIP[@]}\" -- \"$FASTTEST_FOCUS\" 2>&1 | ts '%Y-%m-%d %H:%M:%S' | tee \"$FASTTEST_OUTPUT/test_log.txt\"\ndiff --git a/tests/config/config.d/tcp_with_proxy.xml b/tests/config/config.d/tcp_with_proxy.xml\nnew file mode 100644\nindex 000000000000..19046054c166\n--- /dev/null\n+++ b/tests/config/config.d/tcp_with_proxy.xml\n@@ -0,0 +1,3 @@\n+<yandex>\n+    <tcp_with_proxy_port>9010</tcp_with_proxy_port>\n+</yandex>\ndiff --git a/tests/config/install.sh b/tests/config/install.sh\nindex c20fb4c8f4e6..d7127a8f690f 100755\n--- a/tests/config/install.sh\n+++ b/tests/config/install.sh\n@@ -29,6 +29,7 @@ ln -sf $SRC_PATH/config.d/graphite.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/database_atomic.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/test_cluster_with_incorrect_pw.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/logging_no_rotate.xml $DEST_SERVER_PATH/config.d/\n+ln -sf $SRC_PATH/config.d/tcp_with_proxy.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/users.d/log_queries.xml $DEST_SERVER_PATH/users.d/\n ln -sf $SRC_PATH/users.d/readonly.xml $DEST_SERVER_PATH/users.d/\n ln -sf $SRC_PATH/users.d/access_management.xml $DEST_SERVER_PATH/users.d/\ndiff --git a/tests/queries/0_stateless/01600_quota_by_forwarded_ip.reference b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.reference\nnew file mode 100644\nindex 000000000000..6f4fa48a62f0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.reference\n@@ -0,0 +1,11 @@\n+--- Test with quota by immediate IP ---\n+10\n+exceeded\n+exceeded\n+--- Test with quota by forwarded IP ---\n+10\n+exceeded\n+10\n+exceeded\n+exceeded\n+10\ndiff --git a/tests/queries/0_stateless/01600_quota_by_forwarded_ip.sh b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.sh\nnew file mode 100755\nindex 000000000000..33f5434dc6c7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.sh\n@@ -0,0 +1,65 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+\n+$CLICKHOUSE_CLIENT -n --query \"\n+DROP USER IF EXISTS quoted_by_ip;\n+DROP USER IF EXISTS quoted_by_forwarded_ip;\n+\n+DROP QUOTA IF EXISTS quota_by_ip;\n+DROP QUOTA IF EXISTS quota_by_forwarded_ip;\n+\n+CREATE USER quoted_by_ip;\n+CREATE USER quoted_by_forwarded_ip;\n+\n+GRANT SELECT, CREATE ON *.* TO quoted_by_ip;\n+GRANT SELECT, CREATE ON *.* TO quoted_by_forwarded_ip;\n+\n+CREATE QUOTA quota_by_ip KEYED BY ip_address FOR RANDOMIZED INTERVAL 1 YEAR MAX QUERIES = 1 TO quoted_by_ip;\n+CREATE QUOTA quota_by_forwarded_ip KEYED BY forwarded_ip_address FOR RANDOMIZED INTERVAL 1 YEAR MAX QUERIES = 1 TO quoted_by_forwarded_ip;\n+\"\n+\n+# Note: the test can be flaky if the randomized interval will end while the loop is run. But with year long interval it's unlikely.\n+# One query is allowed per quota. Actually two queries will execute successfully due to some implementation specific behaviour.\n+\n+echo '--- Test with quota by immediate IP ---'\n+\n+while true; do\n+    $CLICKHOUSE_CLIENT --user quoted_by_ip --query \"SELECT count() FROM numbers(10)\" 2>/dev/null || break\n+done | uniq\n+\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&user=quoted_by_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oF 'exceeded'\n+\n+# X-Forwarded-For is ignored for quota by immediate IP address\n+${CLICKHOUSE_CURL} -H 'X-Forwarded-For: 1.2.3.4' -sS \"${CLICKHOUSE_URL}&user=quoted_by_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oF 'exceeded'\n+\n+\n+echo '--- Test with quota by forwarded IP ---'\n+\n+while true; do\n+    $CLICKHOUSE_CLIENT --user quoted_by_forwarded_ip --query \"SELECT count() FROM numbers(10)\" 2>/dev/null || break\n+done | uniq\n+\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&user=quoted_by_forwarded_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oF 'exceeded'\n+\n+# X-Forwarded-For is respected for quota by forwarded IP address\n+while true; do\n+    ${CLICKHOUSE_CURL} -H 'X-Forwarded-For: 1.2.3.4' -sS \"${CLICKHOUSE_URL}&user=quoted_by_forwarded_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oP '^10$' || break\n+done | uniq\n+\n+${CLICKHOUSE_CURL} -H 'X-Forwarded-For: 1.2.3.4' -sS \"${CLICKHOUSE_URL}&user=quoted_by_forwarded_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oF 'exceeded'\n+\n+# Only the last IP address is trusted\n+${CLICKHOUSE_CURL} -H 'X-Forwarded-For: 5.6.7.8, 1.2.3.4' -sS \"${CLICKHOUSE_URL}&user=quoted_by_forwarded_ip\" -d \"SELECT count() FROM numbers(10)\" | grep -oF 'exceeded'\n+\n+${CLICKHOUSE_CURL} -H 'X-Forwarded-For: 1.2.3.4, 5.6.7.8' -sS \"${CLICKHOUSE_URL}&user=quoted_by_forwarded_ip\" -d \"SELECT count() FROM numbers(10)\"\n+\n+$CLICKHOUSE_CLIENT -n --query \"\n+DROP QUOTA IF EXISTS quota_by_ip;\n+DROP QUOTA IF EXISTS quota_by_forwarded_ip;\n+\n+DROP USER IF EXISTS quoted_by_ip;\n+DROP USER IF EXISTS quoted_by_forwarded_ip;\n+\"\ndiff --git a/tests/queries/0_stateless/01601_proxy_protocol.reference b/tests/queries/0_stateless/01601_proxy_protocol.reference\nnew file mode 100644\nindex 000000000000..a5c196677102\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_proxy_protocol.reference\n@@ -0,0 +1,1 @@\n+Hello, world\ndiff --git a/tests/queries/0_stateless/01601_proxy_protocol.sh b/tests/queries/0_stateless/01601_proxy_protocol.sh\nnew file mode 100755\nindex 000000000000..8a431ba6dae6\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_proxy_protocol.sh\n@@ -0,0 +1,6 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+printf \"PROXY TCP4 255.255.255.255 255.255.255.255 65535 65535\\r\\n\\0\\21ClickHouse client\\24\\r\\253\\251\\3\\0\\7default\\0\\4\\1\\0\\1\\0\\0\\t0.0.0.0:0\\1\\tmilovidov\\21milovidov-desktop\\vClickHouse \\24\\r\\253\\251\\3\\0\\1\\0\\0\\0\\2\\1\\25SELECT 'Hello, world'\\2\\0\\247\\203\\254l\\325\\\\z|\\265\\254F\\275\\333\\206\\342\\24\\202\\24\\0\\0\\0\\n\\0\\0\\0\\240\\1\\0\\2\\377\\377\\377\\377\\0\\0\\0\" | nc \"${CLICKHOUSE_HOST}\" \"${CLICKHOUSE_PORT_TCP_WITH_PROXY}\" | head -c150 | grep --text -o -F 'Hello, world'\ndiff --git a/tests/queries/shell_config.sh b/tests/queries/shell_config.sh\nindex 88ff59c5084d..9e287740c116 100644\n--- a/tests/queries/shell_config.sh\n+++ b/tests/queries/shell_config.sh\n@@ -41,6 +41,8 @@ export CLICKHOUSE_PORT_TCP=${CLICKHOUSE_PORT_TCP:=$(${CLICKHOUSE_EXTRACT_CONFIG}\n export CLICKHOUSE_PORT_TCP=${CLICKHOUSE_PORT_TCP:=\"9000\"}\n export CLICKHOUSE_PORT_TCP_SECURE=${CLICKHOUSE_PORT_TCP_SECURE:=$(${CLICKHOUSE_EXTRACT_CONFIG} --try --key=tcp_port_secure 2>/dev/null)} 2>/dev/null\n export CLICKHOUSE_PORT_TCP_SECURE=${CLICKHOUSE_PORT_TCP_SECURE:=\"9440\"}\n+export CLICKHOUSE_PORT_TCP_WITH_PROXY=${CLICKHOUSE_PORT_TCP_WITH_PROXY:=$(${CLICKHOUSE_EXTRACT_CONFIG} --try --key=tcp_with_proxy_port 2>/dev/null)} 2>/dev/null\n+export CLICKHOUSE_PORT_TCP_WITH_PROXY=${CLICKHOUSE_PORT_TCP_WITH_PROXY:=\"9010\"}\n export CLICKHOUSE_PORT_HTTP=${CLICKHOUSE_PORT_HTTP:=$(${CLICKHOUSE_EXTRACT_CONFIG} --key=http_port 2>/dev/null)}\n export CLICKHOUSE_PORT_HTTP=${CLICKHOUSE_PORT_HTTP:=\"8123\"}\n export CLICKHOUSE_PORT_HTTPS=${CLICKHOUSE_PORT_HTTPS:=$(${CLICKHOUSE_EXTRACT_CONFIG} --try --key=https_port 2>/dev/null)} 2>/dev/null\n",
  "problem_statement": "Support PROXY protocol\nhttps://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt\r\nhttps://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-proxy-protocol.html\r\n\r\n**Use case**\r\nClickHouse is hosted behind the proxy (e.g. CloudFlare Spectrum) but we still want to use `keyed_by_ip` quotas in ClickHouse or use the original IP address for authentication.\r\n\r\n**Implementation**\r\nProvide configuration option to use forwarded IP for quotas and auth. It must be disabled by default.\r\n\r\nThe protocol forbids autodetection:\r\n```\r\nThe receiver MUST be configured to only receive the protocol described in this\r\nspecification and MUST not try to guess whether the protocol header is present\r\nor not. This means that the protocol explicitly prevents port sharing between\r\npublic and private access. Otherwise it would open a major security breach by\r\nallowing untrusted parties to spoof their connection addresses. The receiver\r\nSHOULD ensure proper access filtering so that only trusted proxies are allowed\r\nto use this protocol.\r\n```\r\n\r\nSave both IP addresses in ClientInfo.\r\n\r\n**Additional options**\r\nWe also need similar support for X-Forwarded-For in HTTP.\r\n\r\n**Caveats**\r\nIt's only safe if connections are available only via proxy-server, otherwise IP address can be easily forged.\n",
  "hints_text": "It can be implemented by separate settings in config.xml:\r\n\r\ntcp_with_proxy_port\r\ntcps_with_proxy_port\r\nhttp_with_proxy_port\r\nhttps_with_proxy_port\nhttps://support.cloudflare.com/hc/en-us/articles/200170986-How-does-Cloudflare-handle-HTTP-Request-headers-\nBlocked by #17276\nIt's more complicated: sometimes we need to use immediate IP for access control (to restrict proxy addresses) and forwarded IP for quota accounting (to account users in front of proxy).",
  "created_at": "2020-12-01T21:08:54Z",
  "modified_files": [
    "contrib/boost",
    "docs/en/sql-reference/statements/create/quota.md",
    "programs/server/Server.cpp",
    "b/programs/server/config.d/tcp_with_proxy.xml",
    "programs/server/config.xml",
    "src/Access/AccessControlManager.cpp",
    "src/Access/AccessControlManager.h",
    "src/Access/ContextAccess.cpp",
    "src/Access/ContextAccess.h",
    "src/Access/EnabledQuota.h",
    "src/Access/Quota.h",
    "src/Access/QuotaCache.cpp",
    "src/Access/QuotaCache.h",
    "src/Access/UsersConfigAccessStorage.cpp",
    "src/Core/Defines.h",
    "src/IO/ReadHelpers.cpp",
    "src/IO/ReadHelpers.h",
    "src/Interpreters/ClientInfo.cpp",
    "src/Interpreters/ClientInfo.h",
    "src/Interpreters/QueryLog.cpp",
    "src/Interpreters/QueryThreadLog.cpp",
    "src/Parsers/ParserCreateQuotaQuery.cpp",
    "src/Parsers/ParserCreateQuotaQuery.h",
    "src/Server/HTTPHandler.cpp",
    "src/Server/HTTPHandlerFactory.cpp",
    "src/Server/TCPHandler.cpp",
    "src/Server/TCPHandler.h",
    "src/Server/TCPHandlerFactory.h",
    "src/Storages/System/StorageSystemProcesses.cpp"
  ],
  "modified_test_files": [
    "docker/test/fasttest/run.sh",
    "b/tests/config/config.d/tcp_with_proxy.xml",
    "tests/config/install.sh",
    "b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.reference",
    "b/tests/queries/0_stateless/01600_quota_by_forwarded_ip.sh",
    "b/tests/queries/0_stateless/01601_proxy_protocol.reference",
    "b/tests/queries/0_stateless/01601_proxy_protocol.sh",
    "tests/queries/shell_config.sh"
  ]
}