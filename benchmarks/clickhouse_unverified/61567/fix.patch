diff --git a/src/Analyzer/ConstantNode.h b/src/Analyzer/ConstantNode.h
index b065853e3150..98a8eb782776 100644
--- a/src/Analyzer/ConstantNode.h
+++ b/src/Analyzer/ConstantNode.h
@@ -4,6 +4,7 @@
 
 #include <Analyzer/IQueryTreeNode.h>
 #include <Analyzer/ConstantValue.h>
+#include <DataTypes/DataTypeNullable.h>
 
 namespace DB
 {
@@ -86,6 +87,11 @@ class ConstantNode final : public IQueryTreeNode
         mask_id = id;
     }
 
+    void convertToNullable() override
+    {
+        constant_value = std::make_shared<ConstantValue>(constant_value->getValue(), makeNullableSafe(constant_value->getType()));
+    }
+
     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;
 
 protected:
diff --git a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp
index d881af3a51b3..fd8c3e6ee6cd 100644
--- a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp
+++ b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp
@@ -31,6 +31,12 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon
         if (!getSettings().optimize_group_by_function_keys)
             return;
 
+        /// When group_by_use_nulls = 1 removing keys from GROUP BY can lead
+        /// to unexpected types in some functions.
+        /// See example in https://github.com/ClickHouse/ClickHouse/pull/61567#issuecomment-2018007887
+        if (getSettings().group_by_use_nulls)
+            return;
+
         auto * query = node->as<QueryNode>();
         if (!query)
             return;
@@ -73,12 +79,14 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon
             candidates.push_back({ *it, is_deterministic });
 
         /// Using DFS we traverse function tree and try to find if it uses other keys as function arguments.
+        bool found_at_least_one_usage = false;
         while (!candidates.empty())
         {
             auto [candidate, parents_are_only_deterministic] = candidates.back();
             candidates.pop_back();
 
             bool found = group_by_keys.contains(candidate);
+            found_at_least_one_usage |= found;
 
             switch (candidate->getNodeType())
             {
@@ -111,7 +119,7 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon
             }
         }
 
-        return true;
+        return found_at_least_one_usage;
     }
 
     static void optimizeGroupingSet(QueryTreeNodes & grouping_set)
diff --git a/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp b/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp
index ad649834fb04..618932025253 100644
--- a/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp
+++ b/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp
@@ -43,6 +43,13 @@ class OptimizeGroupByInjectiveFunctionsVisitor : public InDepthQueryTreeVisitorW
         if (!getSettings().optimize_injective_functions_in_group_by)
             return;
 
+        /// Don't optimize injective functions when group_by_use_nulls=true,
+        /// because in this case we make initial group by keys Nullable
+        /// and eliminating some functions can cause issues with arguments Nullability
+        /// during their execution. See examples in https://github.com/ClickHouse/ClickHouse/pull/61567#issuecomment-2008181143
+        if (getSettings().group_by_use_nulls)
+            return;
+
         auto * query = node->as<QueryNode>();
         if (!query)
             return;
diff --git a/src/Functions/materialize.h b/src/Functions/materialize.h
index 73bfdec48abf..41994509745b 100644
--- a/src/Functions/materialize.h
+++ b/src/Functions/materialize.h
@@ -36,6 +36,8 @@ class FunctionMaterialize : public IFunction
 
     bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }
 
+    bool isSuitableForConstantFolding() const override { return false; }
+
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
     size_t getNumberOfArguments() const override
