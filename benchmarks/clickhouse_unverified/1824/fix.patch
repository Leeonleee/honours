diff --git a/dbms/src/Interpreters/InterpreterDropQuery.cpp b/dbms/src/Interpreters/InterpreterDropQuery.cpp
index 303081a54842..29ab35665e40 100644
--- a/dbms/src/Interpreters/InterpreterDropQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterDropQuery.cpp
@@ -46,11 +46,16 @@ BlockIO InterpreterDropQuery::execute()
     }
 
     /// Drop temporary table.
-    if (drop.database.empty())
+    if (drop.database.empty() || drop.temporary)
     {
         StoragePtr table = (context.hasSessionContext() ? context.getSessionContext() : context).tryRemoveExternalTable(drop.table);
         if (table)
         {
+            if (drop.database.empty() && !drop.temporary)
+            {
+                LOG_WARNING((&Logger::get("InterpreterDropQuery")),
+                            "It is recommended to use `DROP TEMPORARY TABLE` to delete temporary tables");
+            }
             table->shutdown();
             /// If table was already dropped by anyone, an exception will be thrown
             auto table_lock = table->lockForAlter(__PRETTY_FUNCTION__);
diff --git a/dbms/src/Interpreters/InterpreterShowTablesQuery.cpp b/dbms/src/Interpreters/InterpreterShowTablesQuery.cpp
index 6010ee217945..c9f07425aa40 100644
--- a/dbms/src/Interpreters/InterpreterShowTablesQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterShowTablesQuery.cpp
@@ -30,6 +30,9 @@ String InterpreterShowTablesQuery::getRewrittenQuery()
     if (query.databases)
         return "SELECT name FROM system.databases";
 
+    if (query.temporary && !query.from.empty())
+        throw Exception("The `FROM` and `TEMPORARY` cannot be used together in `SHOW TABLES`", ErrorCodes::SYNTAX_ERROR);
+
     String database = query.from.empty() ? context.getCurrentDatabase() : query.from;
 
     /** The parameter check_database_access_rights is reset when the SHOW TABLES query is processed,
@@ -39,7 +42,12 @@ String InterpreterShowTablesQuery::getRewrittenQuery()
     context.assertDatabaseExists(database, false);
 
     std::stringstream rewritten_query;
-    rewritten_query << "SELECT name FROM system.tables WHERE database = " << std::quoted(database, '\'');
+    rewritten_query << "SELECT name FROM system.tables WHERE ";
+
+    if (query.temporary)
+        rewritten_query << "is_temporary";
+    else
+        rewritten_query << "database = " << std::quoted(database, '\'');
 
     if (!query.like.empty())
         rewritten_query << " AND name " << (query.not_like ? "NOT " : "") << "LIKE " << std::quoted(query.like, '\'');
diff --git a/dbms/src/Parsers/ASTDropQuery.h b/dbms/src/Parsers/ASTDropQuery.h
index 3f240b7ccf95..3735a58ab66d 100644
--- a/dbms/src/Parsers/ASTDropQuery.h
+++ b/dbms/src/Parsers/ASTDropQuery.h
@@ -15,6 +15,7 @@ class ASTDropQuery : public ASTQueryWithOutput, public ASTQueryWithOnCluster
 public:
     bool detach{false};    /// DETACH query, not DROP.
     bool if_exists{false};
+    bool temporary{false};
     String database;
     String table;
 
diff --git a/dbms/src/Parsers/ASTShowTablesQuery.h b/dbms/src/Parsers/ASTShowTablesQuery.h
index d24ffe006afc..176f9d69697b 100644
--- a/dbms/src/Parsers/ASTShowTablesQuery.h
+++ b/dbms/src/Parsers/ASTShowTablesQuery.h
@@ -15,6 +15,7 @@ class ASTShowTablesQuery : public ASTQueryWithOutput
 {
 public:
     bool databases{false};
+    bool temporary{false};
     String from;
     String like;
     bool not_like{false};
diff --git a/dbms/src/Parsers/ParserDropQuery.cpp b/dbms/src/Parsers/ParserDropQuery.cpp
index 607d37b8c885..0475711a225c 100644
--- a/dbms/src/Parsers/ParserDropQuery.cpp
+++ b/dbms/src/Parsers/ParserDropQuery.cpp
@@ -17,6 +17,7 @@ bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 
     ParserKeyword s_drop("DROP");
     ParserKeyword s_detach("DETACH");
+    ParserKeyword s_temporary("TEMPORARY");
     ParserKeyword s_table("TABLE");
     ParserKeyword s_database("DATABASE");
     ParserToken s_dot(TokenType::Dot);
@@ -28,6 +29,7 @@ bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     String cluster_str;
     bool detach = false;
     bool if_exists = false;
+    bool temporary = false;
 
     if (!s_drop.ignore(pos, expected))
     {
@@ -53,6 +55,9 @@ bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     }
     else
     {
+        if (s_temporary.ignore(pos, expected))
+            temporary = true;
+
         if (!s_table.ignore(pos, expected))
             return false;
 
@@ -81,6 +86,7 @@ bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 
     query->detach = detach;
     query->if_exists = if_exists;
+    query->temporary = temporary;
     if (database)
         query->database = typeid_cast<ASTIdentifier &>(*database).name;
     if (table)
diff --git a/dbms/src/Parsers/ParserShowTablesQuery.cpp b/dbms/src/Parsers/ParserShowTablesQuery.cpp
index 80e5f986c706..5399eeef50ca 100644
--- a/dbms/src/Parsers/ParserShowTablesQuery.cpp
+++ b/dbms/src/Parsers/ParserShowTablesQuery.cpp
@@ -18,6 +18,7 @@ bool ParserShowTablesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
     Pos begin = pos;
 
     ParserKeyword s_show("SHOW");
+    ParserKeyword s_temporary("TEMPORARY");
     ParserKeyword s_tables("TABLES");
     ParserKeyword s_databases("DATABASES");
     ParserKeyword s_from("FROM");
@@ -38,27 +39,33 @@ bool ParserShowTablesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
     {
         query->databases = true;
     }
-    else if (s_tables.ignore(pos, expected))
+    else
     {
-        if (s_from.ignore(pos, expected))
-        {
-            if (!name_p.parse(pos, database, expected))
-                return false;
-        }
+        if (s_temporary.ignore(pos))
+            query->temporary = true;
 
-        if (s_not.ignore(pos, expected))
-            query->not_like = true;
-
-        if (s_like.ignore(pos, expected))
+        if (s_tables.ignore(pos, expected))
         {
-            if (!like_p.parse(pos, like, expected))
+            if (s_from.ignore(pos, expected))
+            {
+                if (!name_p.parse(pos, database, expected))
+                    return false;
+            }
+
+            if (s_not.ignore(pos, expected))
+                query->not_like = true;
+
+            if (s_like.ignore(pos, expected))
+            {
+                if (!like_p.parse(pos, like, expected))
+                    return false;
+            }
+            else if (query->not_like)
                 return false;
         }
-        else if (query->not_like)
+        else
             return false;
     }
-    else
-        return false;
 
     query->range = StringRange(begin, pos);
 
diff --git a/dbms/src/Parsers/ParserShowTablesQuery.h b/dbms/src/Parsers/ParserShowTablesQuery.h
index 0308a0e665d9..e5c2aab55719 100644
--- a/dbms/src/Parsers/ParserShowTablesQuery.h
+++ b/dbms/src/Parsers/ParserShowTablesQuery.h
@@ -14,7 +14,7 @@ namespace DB
 class ParserShowTablesQuery : public IParserBase
 {
 protected:
-    const char * getName() const { return "SHOW TABLES|DATABASES query"; }
+    const char * getName() const { return "SHOW [TEMPORARY] TABLES|DATABASES [[NOT] LIKE 'str']"; }
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected);
 };
 
diff --git a/dbms/src/Storages/System/StorageSystemTables.cpp b/dbms/src/Storages/System/StorageSystemTables.cpp
index b40cf29498f9..0f68f6864036 100644
--- a/dbms/src/Storages/System/StorageSystemTables.cpp
+++ b/dbms/src/Storages/System/StorageSystemTables.cpp
@@ -7,7 +7,7 @@
 #include <Storages/VirtualColumnUtils.h>
 #include <Databases/IDatabase.h>
 #include <Interpreters/Context.h>
-
+#include <DataTypes/DataTypesNumber.h>
 
 namespace DB
 {
@@ -19,7 +19,8 @@ StorageSystemTables::StorageSystemTables(const std::string & name_)
         {"database", std::make_shared<DataTypeString>()},
         {"name", std::make_shared<DataTypeString>()},
         {"engine", std::make_shared<DataTypeString>()},
-        {"metadata_modification_time", std::make_shared<DataTypeDateTime>()}
+        {"metadata_modification_time", std::make_shared<DataTypeDateTime>()},
+        {"is_temporary", std::make_shared<DataTypeUInt8>()}
     };
 }
 
@@ -54,6 +55,7 @@ BlockInputStreams StorageSystemTables::read(
     for (size_t row_number = 0; row_number < filtered_databases_column->size(); ++row_number)
     {
         std::string database_name = filtered_databases_column->getDataAt(row_number).toString();
+
         auto database = context.tryGetDatabase(database_name);
 
         if (!database)
@@ -68,10 +70,28 @@ BlockInputStreams StorageSystemTables::read(
             res_columns[0]->insert(database_name);
             res_columns[1]->insert(table_name);
             res_columns[2]->insert(iterator->table()->getName());
-            res_columns[3]->insert(static_cast<UInt64>(database->getTableMetadataModificationTime(context, table_name)));
+            res_columns[3]->insert(
+                static_cast<UInt64>(database->getTableMetadataModificationTime(context, table_name)));
+            res_columns[4]->insert(UInt64(0));
+        }
+    }
+
+    if (context.hasSessionContext())
+    {
+        Tables external_tables = context.getSessionContext().getExternalTables();
+
+        for (auto table : external_tables)
+        {
+            res_columns[0]->insert(String{});
+            res_columns[1]->insert(table.first);
+            res_columns[2]->insert(table.second->getName());
+            res_columns[3]->insert(UInt64(0));
+            res_columns[4]->insert(UInt64(1));
         }
     }
 
+
+
     return BlockInputStreams(1, std::make_shared<OneBlockInputStream>(getSampleBlock().cloneWithColumns(std::move(res_columns))));
 }
 
