diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 8e54036a21c3..fb410336dcb8 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -357,6 +357,7 @@ inline bool isTuple(const DataTypePtr & data_type) { return WhichDataType(data_t
 inline bool isArray(const DataTypePtr & data_type) { return WhichDataType(data_type).isArray(); }
 inline bool isMap(const DataTypePtr & data_type) { return WhichDataType(data_type).isMap(); }
 inline bool isNothing(const DataTypePtr & data_type) { return WhichDataType(data_type).isNothing(); }
+inline bool isUUID(const DataTypePtr & data_type) { return WhichDataType(data_type).isUUID(); }
 
 template <typename T>
 inline bool isUInt8(const T & data_type)
diff --git a/src/Functions/CRC.cpp b/src/Functions/CRC.cpp
index 6083e5ef16f0..00aa631c85b0 100644
--- a/src/Functions/CRC.cpp
+++ b/src/Functions/CRC.cpp
@@ -110,6 +110,11 @@ struct CRCFunctionWrapper
         throw Exception("Cannot apply function " + std::string(Impl::name) + " to Array argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
 
+    [[noreturn]] static void uuid(const ColumnUUID::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)
+    {
+        throw Exception("Cannot apply function " + std::string(Impl::name) + " to UUID argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
+
 private:
     static ReturnType doCRC(const ColumnString::Chars & buf, size_t offset, size_t size)
     {
diff --git a/src/Functions/EmptyImpl.h b/src/Functions/EmptyImpl.h
index 164441135bd9..c3117e0e52db 100644
--- a/src/Functions/EmptyImpl.h
+++ b/src/Functions/EmptyImpl.h
@@ -54,6 +54,12 @@ struct EmptyImpl
             prev_offset = offsets[i];
         }
     }
+
+    static void uuid(const ColumnUUID::Container & container, size_t n, PaddedPODArray<UInt8> & res)
+    {
+        for (size_t i = 0; i < n; ++i)
+            res[i] = negative ^ (container.data()->toUnderType() == 0);
+    }
 };
 
 }
diff --git a/src/Functions/FunctionStringOrArrayToT.h b/src/Functions/FunctionStringOrArrayToT.h
index 158179fffe99..69f0741a741a 100644
--- a/src/Functions/FunctionStringOrArrayToT.h
+++ b/src/Functions/FunctionStringOrArrayToT.h
@@ -8,6 +8,7 @@
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnMap.h>
+#include <Columns/ColumnsNumber.h>
 
 
 namespace DB
@@ -43,7 +44,9 @@ class FunctionStringOrArrayToT : public IFunction
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isStringOrFixedString(arguments[0])
-            && !isArray(arguments[0]) && !isMap(arguments[0]))
+            && !isArray(arguments[0])
+            && !isMap(arguments[0])
+            && !isUUID(arguments[0]))
             throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return std::make_shared<DataTypeNumber<ResultType>>();
@@ -51,7 +54,7 @@ class FunctionStringOrArrayToT : public IFunction
 
     bool useDefaultImplementationForConstants() const override { return true; }
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
         const ColumnPtr column = arguments[0].column;
         if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))
@@ -104,6 +107,14 @@ class FunctionStringOrArrayToT : public IFunction
             Impl::array(col_nested.getOffsets(), vec_res);
             return col_res;
         }
+        else if (const ColumnUUID * col_uuid = checkAndGetColumn<ColumnUUID>(column.get()))
+        {
+            auto col_res = ColumnVector<ResultType>::create();
+            typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();
+            vec_res.resize(col_uuid->size());
+            Impl::uuid(col_uuid->getData(), input_rows_count, vec_res);
+            return col_res;
+        }
         else
             throw Exception("Illegal column " + arguments[0].column->getName() + " of argument of function " + getName(),
                 ErrorCodes::ILLEGAL_COLUMN);
diff --git a/src/Functions/array/length.cpp b/src/Functions/array/length.cpp
index a7fe2fb0662f..768590c63130 100644
--- a/src/Functions/array/length.cpp
+++ b/src/Functions/array/length.cpp
@@ -5,7 +5,10 @@
 
 namespace DB
 {
-
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
 
 /** Calculates the length of a string in bytes.
   */
@@ -35,6 +38,11 @@ struct LengthImpl
         for (size_t i = 0; i < size; ++i)
             res[i] = offsets[i] - offsets[i - 1];
     }
+
+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt64> &)
+    {
+        throw Exception("Cannot apply function length to UUID argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
 };
 
 
diff --git a/src/Functions/isValidUTF8.cpp b/src/Functions/isValidUTF8.cpp
index e3158bb709cd..abdda53990d6 100644
--- a/src/Functions/isValidUTF8.cpp
+++ b/src/Functions/isValidUTF8.cpp
@@ -317,6 +317,11 @@ SOFTWARE.
     {
         throw Exception("Cannot apply function isValidUTF8 to Array argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
+
+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt8> &)
+    {
+        throw Exception("Cannot apply function isValidUTF8 to UUID argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
 };
 
 struct NameIsValidUTF8
diff --git a/src/Functions/lengthUTF8.cpp b/src/Functions/lengthUTF8.cpp
index c067fd4db3ca..349635160a6f 100644
--- a/src/Functions/lengthUTF8.cpp
+++ b/src/Functions/lengthUTF8.cpp
@@ -53,6 +53,11 @@ struct LengthUTF8Impl
     {
         throw Exception("Cannot apply function lengthUTF8 to Array argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
+
+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt64> &)
+    {
+        throw Exception("Cannot apply function lengthUTF8 to UUID argument", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
 };
 
 struct NameLengthUTF8
