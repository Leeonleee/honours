{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49626,
  "instance_id": "ClickHouse__ClickHouse-49626",
  "issue_numbers": [
    "34207"
  ],
  "base_commit": "473743b49fa7f37ee869d694e9233b4678efbd98",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 5730503a6705..7d2a52c65568 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4284,6 +4284,32 @@ Possible values:\n \n Default value: `false`.\n \n+## rename_files_after_processing\n+\n+- **Type:** String\n+\n+- **Default value:** Empty string\n+\n+This setting allows to specify renaming pattern for files processed by `file` table function. When option is set, all files read by `file` table function will be renamed according to specified pattern with placeholders, only if files processing was successful.\n+\n+### Placeholders\n+\n+- `%f` \u2014 Original filename without extension (e.g., \"sample\").\n+- `%e` \u2014 Original file extension with dot (e.g., \".csv\").\n+- `%t` \u2014 Timestamp (in microseconds).\n+- `%%` \u2014 Percentage sign (\"%\").\n+\n+### Example\n+- Option: `--rename_files_after_processing=\"processed_%f_%t%e\"`\n+\n+- Query: `SELECT * FROM file('sample.csv')`\n+\n+\n+If reading `sample.csv` is successful, file will be renamed to `processed_sample_1683473210851438.csv`\n+\n+\n+\n+\n ## function_json_value_return_type_allow_complex\n \n Control whether allow to return complex type (such as: struct, array, map) for json_value function.\ndiff --git a/docs/en/sql-reference/table-functions/file.md b/docs/en/sql-reference/table-functions/file.md\nindex 28c2dc9f1f32..577e2e6aa1d2 100644\n--- a/docs/en/sql-reference/table-functions/file.md\n+++ b/docs/en/sql-reference/table-functions/file.md\n@@ -40,7 +40,7 @@ VALUES (1, 2, 3), (3, 2, 1), (1, 3, 2)\n As a result, the data is written into the file `test.tsv`:\n \n ```bash\n-# cat /var/lib/clickhouse/user_files/test.tsv \n+# cat /var/lib/clickhouse/user_files/test.tsv\n 1\t2\t3\n 3\t2\t1\n 1\t3\t2\n@@ -163,7 +163,7 @@ Query the number of rows in all files of these two directories:\n SELECT count(*) FROM file('{some,another}_dir/*', 'TSV', 'name String, value UInt32');\n ```\n \n-:::note    \n+:::note\n If your listing of files contains number ranges with leading zeros, use the construction with braces for each digit separately or use `?`.\n :::\n \n@@ -199,3 +199,4 @@ SELECT count(*) FROM file('big_dir/**/file002', 'CSV', 'name String, value UInt3\n **See Also**\n \n - [Virtual columns](/docs/en/engines/table-engines/index.md#table_engines-virtual_columns)\n+- [Rename files after processing](/docs/en/operations/settings/settings.md#rename_files_after_processing)\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex f5c8f06e3ca6..e3da8302fc8a 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -4126,3 +4126,26 @@ SELECT sum(number) FROM numbers(10000000000) SETTINGS partial_result_on_first_ca\n \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f:: `true`, `false`\n \n \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `false`\n+\n+## rename_files_after_processing\n+\n+- **\u0422\u0438\u043f:** \u0421\u0442\u0440\u043e\u043a\u0430\n+\n+- **\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e:** \u041f\u0443\u0441\u0442\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n+\n+\u042d\u0442\u043e\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0437\u0430\u0434\u0430\u0442\u044c \u043f\u0430\u0442\u0442\u0435\u0440\u043d \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u043e\u0432, \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c\u044b\u0445 \u0442\u0430\u0431\u043b\u0438\u0447\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0435\u0439 `file`. \u041a\u043e\u0433\u0434\u0430 \u043e\u043f\u0446\u0438\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0430, \u0432\u0441\u0435 \u0444\u0430\u0439\u043b\u044b, \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u043d\u043d\u044b\u0435 \u0442\u0430\u0431\u043b\u0438\u0447\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0435\u0439 `file`, \u0431\u0443\u0434\u0443\u0442 \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u044b \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u043c \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u043c, \u0435\u0441\u043b\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0438 \u0447\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u043b\u0438\u0441\u044c \u0443\u0441\u043f\u0435\u0448\u043d\u043e.\n+\n+### \u0428\u0430\u0431\u043b\u043e\u043d\n+\u0428\u0430\u0431\u043b\u043e\u043d \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0432\u0438\u0434\u044b \u043f\u043b\u0435\u0439\u0441\u0445\u043e\u043b\u0434\u0435\u0440\u043e\u0432:\n+\n+- `%f` \u2014 \u0418\u0441\u0445\u043e\u0434\u043d\u043e\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0431\u0435\u0437 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u044f (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 \"sample\").\n+- `%e` \u2014 \u041e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0441 \u0442\u043e\u0447\u043a\u043e\u0439 (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 \".csv\").\n+- `%t` \u2014 \u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f (\u0432 \u043c\u0438\u043a\u0440\u043e\u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445).\n+- `%%` \u2014 \u0417\u043d\u0430\u043a \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 (\"%\").\n+\n+### \u041f\u0440\u0438\u043c\u0435\u0440\n+- \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430: `--rename_files_after_processing=\"processed_%f_%t%e\"`\n+\n+- \u0417\u0430\u043f\u0440\u043e\u0441: `SELECT * FROM file('sample.csv')`\n+\n+\u0415\u0441\u043b\u0438 \u0447\u0442\u0435\u043d\u0438\u0435 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 `sample.csv` \u043f\u0440\u043e\u0448\u043b\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e, \u0444\u0430\u0439\u043b \u0431\u0443\u0434\u0435\u0442 \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d \u0432 `processed_sample_1683473210851438.csv`.\ndiff --git a/docs/ru/sql-reference/table-functions/file.md b/docs/ru/sql-reference/table-functions/file.md\nindex 94bc734a8fb2..0983c51d954c 100644\n--- a/docs/ru/sql-reference/table-functions/file.md\n+++ b/docs/ru/sql-reference/table-functions/file.md\n@@ -126,3 +126,4 @@ SELECT count(*) FROM file('big_dir/file{0..9}{0..9}{0..9}', 'CSV', 'name String,\n **\u0421\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0442\u0430\u043a\u0436\u0435**\n \n -   [\u0412\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u0431\u0446\u044b](index.md#table_engines-virtual_columns)\n+-   [\u041f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 \u043f\u043e\u0441\u043b\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438](/docs/ru/operations/settings/settings.md#rename_files_after_processing)\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex b7e4e2b733bb..6f295c110702 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -1364,6 +1364,7 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des\n             columns_description_for_query,\n             ConstraintsDescription{},\n             String{},\n+            {},\n         };\n         StoragePtr storage = std::make_shared<StorageFile>(in_file, global_context->getUserFilesPath(), args);\n         storage->startup();\ndiff --git a/src/Common/FileRenamer.cpp b/src/Common/FileRenamer.cpp\nnew file mode 100644\nindex 000000000000..3473d543c00f\n--- /dev/null\n+++ b/src/Common/FileRenamer.cpp\n@@ -0,0 +1,96 @@\n+#include <Common/FileRenamer.h>\n+\n+#include <Common/DateLUT.h>\n+#include <Common/Exception.h>\n+\n+#include <chrono>\n+#include <filesystem>\n+#include <format>\n+#include <map>\n+#include <re2/re2.h>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n+\n+namespace fs = std::filesystem;\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+FileRenamer::FileRenamer() = default;\n+\n+FileRenamer::FileRenamer(const String & renaming_rule)\n+    : rule(renaming_rule)\n+{\n+    FileRenamer::validateRenamingRule(rule, true);\n+}\n+\n+String FileRenamer::generateNewFilename(const String & filename) const\n+{\n+    // Split filename and extension\n+    String file_base = fs::path(filename).stem();\n+    String file_ext = fs::path(filename).extension();\n+\n+    // Get current timestamp in microseconds\n+    String timestamp;\n+    if (rule.find(\"%t\") != String::npos)\n+    {\n+        auto now = std::chrono::system_clock::now();\n+        timestamp = std::to_string(timeInMicroseconds(now));\n+    }\n+\n+    // Define placeholders and their corresponding values\n+    std::map<String, String> placeholders =\n+    {\n+        {\"%f\", file_base},\n+        {\"%e\", file_ext},\n+        {\"%t\", timestamp},\n+        {\"%%\", \"%\"}\n+    };\n+\n+    // Replace placeholders with their actual values\n+    String new_name = rule;\n+    for (const auto & [placeholder, value] : placeholders)\n+        boost::replace_all(new_name, placeholder, value);\n+\n+    return new_name;\n+}\n+\n+bool FileRenamer::isEmpty() const\n+{\n+    return rule.empty();\n+}\n+\n+bool FileRenamer::validateRenamingRule(const String & rule, bool throw_on_error)\n+{\n+    // Check if the rule contains invalid placeholders\n+    re2::RE2 invalid_placeholder_pattern(\"^([^%]|%[fet%])*$\");\n+    if (!re2::RE2::FullMatch(rule, invalid_placeholder_pattern))\n+    {\n+        if (throw_on_error)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid renaming rule: Allowed placeholders only %f, %e, %t, and %%\");\n+        return false;\n+    }\n+\n+    // Replace valid placeholders with empty strings and count remaining percentage signs.\n+    String replaced_rule = rule;\n+    boost::replace_all(replaced_rule, \"%f\", \"\");\n+    boost::replace_all(replaced_rule, \"%e\", \"\");\n+    boost::replace_all(replaced_rule, \"%t\", \"\");\n+    if (std::count(replaced_rule.begin(), replaced_rule.end(), '%') % 2)\n+    {\n+        if (throw_on_error)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid renaming rule: Odd number of consecutive percentage signs\");\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+\n+} // DB\ndiff --git a/src/Common/FileRenamer.h b/src/Common/FileRenamer.h\nnew file mode 100644\nindex 000000000000..c062978d6f66\n--- /dev/null\n+++ b/src/Common/FileRenamer.h\n@@ -0,0 +1,39 @@\n+#pragma once\n+\n+#include <string>\n+#include <base/types.h>\n+\n+namespace DB\n+{\n+\n+/**\n+  * The FileRenamer class provides functionality for renaming files based on given pattern with placeholders\n+  * The supported placeholders are:\n+  *   %f - Original filename without extension (\"sample\")\n+  *   %e - Original file extension with dot (\".csv\")\n+  *   %t - Timestamp (in microseconds)\n+  *   %% - Percentage sign (\"%\")\n+  *\n+  * Example:\n+  *   Pattern             - \"processed_%f_%t%e\"\n+  *   Original filename   - \"sample.csv\"\n+  *   New filename        - \"processed_sample_1683405960646224.csv\"\n+  */\n+class FileRenamer\n+{\n+public:\n+    FileRenamer();\n+\n+    FileRenamer(const String & renaming_rule);\n+\n+    String generateNewFilename(const String & filename) const;\n+\n+    bool isEmpty() const;\n+\n+    static bool validateRenamingRule(const String & rule, bool throw_on_error = false);\n+\n+private:\n+    String rule;\n+};\n+\n+} // DB\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 6a0833aef60c..93985b1a6def 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -717,6 +717,8 @@ class IColumn;\n     M(String, workload, \"default\", \"Name of workload to be used to access resources\", 0) \\\n     M(Milliseconds, storage_system_stack_trace_pipe_read_timeout_ms, 100, \"Maximum time to read from a pipe for receiving information from the threads when querying the `system.stack_trace` table. This setting is used for testing purposes and not meant to be changed by users.\", 0) \\\n     \\\n+    M(String, rename_files_after_processing, \"\", \"Rename successfully processed files according to the specified pattern; Pattern can include the following placeholders: `%f` (original filename without extension), `%e` (file extension with dot), `%t` (current timestamp in \u00b5s), and `%%` (% sign)\", 0) \\\n+    \\\n     M(Bool, parallelize_output_from_storages, true, \"Parallelize output for reading step from storage. It allows parallelizing query processing right after reading from storage if possible\", 0) \\\n     M(String, insert_deduplication_token, \"\", \"If not empty, used for duplicate detection instead of data digest\", 0) \\\n     M(String, ann_index_select_query_params, \"\", \"Parameters passed to ANN indexes in SELECT queries, the format is 'param1=x, param2=y, ...'\", 0) \\\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 052775aefcac..dfaf3bb7cd83 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -40,6 +40,7 @@\n #include <Common/typeid_cast.h>\n #include <Common/parseGlobs.h>\n #include <Common/filesystemHelpers.h>\n+#include <Common/logger_useful.h>\n #include <Common/ProfileEvents.h>\n \n #include <QueryPipeline/Pipe.h>\n@@ -78,6 +79,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_IDENTIFIER;\n     extern const int INCORRECT_FILE_NAME;\n     extern const int FILE_DOESNT_EXIST;\n+    extern const int FILE_ALREADY_EXISTS;\n     extern const int TIMEOUT_EXCEEDED;\n     extern const int INCOMPATIBLE_COLUMNS;\n     extern const int CANNOT_STAT;\n@@ -462,6 +464,8 @@ StorageFile::StorageFile(const std::string & table_path_, const std::string & us\n     else\n         path_for_partitioned_write = table_path_;\n \n+    file_renamer = FileRenamer(args.rename_after_processing);\n+\n     setStorageMetadata(args);\n }\n \n@@ -595,9 +599,69 @@ class StorageFileSource : public ISource\n             shared_lock = std::shared_lock(storage->rwlock, getLockTimeout(context));\n             if (!shared_lock)\n                 throw Exception(ErrorCodes::TIMEOUT_EXCEEDED, \"Lock timeout exceeded\");\n+            storage->readers_counter.fetch_add(1, std::memory_order_release);\n         }\n     }\n \n+\n+    /**\n+      * If specified option --rename_files_after_processing and files created by TableFunctionFile\n+      * Last reader will rename files according to specified pattern if desctuctor of reader was called without uncaught exceptions\n+      */\n+    void beforeDestroy()\n+    {\n+        if (storage->file_renamer.isEmpty())\n+            return;\n+\n+        int32_t cnt = storage->readers_counter.fetch_sub(1, std::memory_order_acq_rel);\n+\n+        if (std::uncaught_exceptions() == 0 && cnt == 1 && !storage->was_renamed)\n+        {\n+            shared_lock.unlock();\n+            auto exclusive_lock = std::unique_lock{storage->rwlock, getLockTimeout(context)};\n+\n+            if (!exclusive_lock)\n+                return;\n+            if (storage->readers_counter.load(std::memory_order_acquire) != 0 || storage->was_renamed)\n+                return;\n+\n+            for (auto & file_path_ref : storage->paths)\n+            {\n+                try\n+                {\n+                    auto file_path = fs::path(file_path_ref);\n+                    String new_filename = storage->file_renamer.generateNewFilename(file_path.filename().string());\n+                    file_path.replace_filename(new_filename);\n+\n+                    // Normalize new path\n+                    file_path = file_path.lexically_normal();\n+\n+                    // Checking access rights\n+                    checkCreationIsAllowed(context, context->getUserFilesPath(), file_path, true);\n+\n+                    // Checking an existing of new file\n+                    if (fs::exists(file_path))\n+                        throw Exception(ErrorCodes::FILE_ALREADY_EXISTS, \"File {} already exists\", file_path.string());\n+\n+                    fs::rename(fs::path(file_path_ref), file_path);\n+                    file_path_ref = file_path.string();\n+                    storage->was_renamed = true;\n+                }\n+                catch (const std::exception & e)\n+                {\n+                    // Cannot throw exception from destructor, will write only error\n+                    LOG_ERROR(&Poco::Logger::get(\"~StorageFileSource\"), \"Failed to rename file {}: {}\", file_path_ref, e.what());\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    ~StorageFileSource() override\n+    {\n+        beforeDestroy();\n+    }\n+\n     String getName() const override\n     {\n         return storage->getName();\n@@ -1223,6 +1287,7 @@ void registerStorageFile(StorageFactory & factory)\n                 factory_args.columns,\n                 factory_args.constraints,\n                 factory_args.comment,\n+                {},\n             };\n \n             ASTs & engine_args_ast = factory_args.engine_args;\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex 53ce7eeaaf6c..0513864fd0ff 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -2,12 +2,11 @@\n \n #include <Storages/IStorage.h>\n #include <Storages/Cache/SchemaCache.h>\n-\n+#include <Common/FileRenamer.h>\n \n #include <atomic>\n #include <shared_mutex>\n \n-\n namespace DB\n {\n \n@@ -23,6 +22,8 @@ class StorageFile final : public IStorage\n         const ColumnsDescription & columns;\n         const ConstraintsDescription & constraints;\n         const String & comment;\n+\n+        const std::string rename_after_processing;\n     };\n \n     /// From file descriptor\n@@ -139,6 +140,11 @@ class StorageFile final : public IStorage\n     std::unique_ptr<ReadBuffer> read_buffer_from_fd;\n     std::unique_ptr<ReadBuffer> peekable_read_buffer_from_fd;\n     std::atomic<bool> has_peekable_read_buffer_from_fd = false;\n+\n+    // Counts the number of readers\n+    std::atomic<int32_t> readers_counter = 0;\n+    FileRenamer file_renamer;\n+    bool was_renamed = false;\n };\n \n }\ndiff --git a/src/TableFunctions/TableFunctionFile.cpp b/src/TableFunctions/TableFunctionFile.cpp\nindex ff64bb3dc677..0e49f26db40a 100644\n--- a/src/TableFunctions/TableFunctionFile.cpp\n+++ b/src/TableFunctions/TableFunctionFile.cpp\n@@ -75,6 +75,7 @@ StoragePtr TableFunctionFile::getStorage(const String & source,\n         columns,\n         ConstraintsDescription{},\n         String{},\n+        global_context->getSettingsRef().rename_files_after_processing,\n     };\n     if (fd >= 0)\n         return std::make_shared<StorageFile>(fd, args);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02732_rename_after_processing.reference b/tests/queries/0_stateless/02732_rename_after_processing.reference\nnew file mode 100644\nindex 000000000000..39cdb677e090\n--- /dev/null\n+++ b/tests/queries/0_stateless/02732_rename_after_processing.reference\n@@ -0,0 +1,21 @@\n+4\n+processed_tmp1.csv\n+!tmp1.csv\n+10\t10\n+processed_tmp2.csv\n+!tmp2.csv\n+8\n+processed_tmp3_1.csv\n+processed_tmp3_2.csv\n+!tmp3_1.csv\n+!tmp3_2.csv\n+4\n+OK\n+OK\n+tmp5.csv\n+OK\n+tmp5.csv\n+OK\n+tmp5.csv\n+OK\n+tmp5.csv\ndiff --git a/tests/queries/0_stateless/02732_rename_after_processing.sh b/tests/queries/0_stateless/02732_rename_after_processing.sh\nnew file mode 100755\nindex 000000000000..c4f80d3462b9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02732_rename_after_processing.sh\n@@ -0,0 +1,119 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# see 01658_read_file_to_stringcolumn.sh\n+CLICKHOUSE_USER_FILES_PATH=$(clickhouse-client --query \"select _path, _file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+\n+# Prepare data\n+unique_name=${CLICKHOUSE_TEST_UNIQUE_NAME}\n+tmp_dir=${CLICKHOUSE_USER_FILES_PATH}/${unique_name}\n+mkdir -p $tmp_dir\n+rm -rf ${tmp_dir:?}/*\n+\n+chmod 777 ${tmp_dir}\n+\n+echo '\"id\",\"str\",\"int\",\"text\"' > ${tmp_dir}/tmp.csv\n+echo '1,\"abc\",123,\"abacaba\"' >> ${tmp_dir}/tmp.csv\n+echo '2,\"def\",456,\"bacabaa\"' >> ${tmp_dir}/tmp.csv\n+echo '3,\"story\",78912,\"acabaab\"' >> ${tmp_dir}/tmp.csv\n+echo '4,\"history\",21321321,\"cabaaba\"' >> ${tmp_dir}/tmp.csv\n+\n+chmod 777 ${tmp_dir}/tmp.csv\n+\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp1.csv\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp2.csv\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp3_1.csv\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp3_2.csv\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp4.csv\n+cp ${tmp_dir}/tmp.csv ${tmp_dir}/tmp5.csv\n+\n+### Checking that renaming works\n+\n+# simple select\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f%e\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp1.csv')\"\n+if [ -e \"${tmp_dir}/processed_tmp1.csv\" ]; then\n+  echo \"processed_tmp1.csv\"\n+fi\n+if [ ! -e \"${tmp_dir}/tmp1.csv\" ]; then\n+  echo \"!tmp1.csv\"\n+fi\n+\n+# select with multiple file() calls\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f%e\" --multiline -q  \"\"\"\n+SELECT\n+    sum(a.id) as aid,\n+    sum(b.id) as bid\n+FROM file('${unique_name}/tmp2.csv') AS a\n+INNER JOIN file('${unique_name}/tmp2.csv') AS b\n+ON a.text = b.text\n+\"\"\"\n+if [ -e \"${tmp_dir}/processed_tmp2.csv\" ]; then\n+  echo \"processed_tmp2.csv\"\n+fi\n+if [ ! -e \"${tmp_dir}/tmp2.csv\" ]; then\n+    echo \"!tmp2.csv\"\n+fi\n+\n+# rename multiple files\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f%e\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp3*.csv')\"\n+if [ -e \"${tmp_dir}/processed_tmp3_1.csv\" ]; then\n+    echo \"processed_tmp3_1.csv\"\n+fi\n+if [ -e \"${tmp_dir}/processed_tmp3_2.csv\" ]; then\n+    echo \"processed_tmp3_2.csv\"\n+fi\n+if [ ! -e \"${tmp_dir}/tmp3_1.csv\" ]; then\n+    echo \"!tmp3_1.csv\"\n+fi\n+if [ ! -e \"${tmp_dir}/tmp3_2.csv\" ]; then\n+    echo \"!tmp3_2.csv\"\n+fi\n+\n+# check timestamp placeholder\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f_%t.csv\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp4.csv')\"\n+# ls ${tmp_dir} | grep -E \"^processed_tmp4_[0-9]+\\.csv$\" > /dev/null && echo \"OK\"\n+rg=\"processed_tmp4_[0-9]+\\.csv\"\n+for x in \"${tmp_dir}\"/processed*; do\n+    if [[ $x =~ $rg ]]; then\n+        echo \"OK\"\n+        break\n+    fi;\n+done\n+\n+### Checking errors\n+\n+# cannot overwrite an existing file\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"tmp.csv\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp5.csv')\" \\\n+    2>&1| grep \"already exists\" > /dev/null && echo \"OK\"\n+if [ -e \"${tmp_dir}/tmp5.csv\" ]; then\n+    echo \"tmp5.csv\"\n+fi\n+\n+# \u0441annot move file outside user_files\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"../../%f%e\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp5.csv')\" \\\n+    2>&1| grep \"is not inside\" > /dev/null && echo \"OK\"\n+if [ -e \"${tmp_dir}/tmp5.csv\" ]; then\n+    echo \"tmp5.csv\"\n+fi\n+\n+# check invalid placeholders\n+\n+# unknown type of placeholder (%k)\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f_%k\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp5.csv')\" \\\n+    2>&1| grep \"Allowed placeholders only\" > /dev/null && echo \"OK\"\n+if [ -e \"${tmp_dir}/tmp5.csv\" ]; then\n+    echo \"tmp5.csv\"\n+fi\n+\n+# dd number of consecutive percentage signs after replace valid placeholders\n+${CLICKHOUSE_CLIENT} --rename-files-after-processing=\"processed_%f_%%%%e\" -q \"SELECT COUNT(*) FROM file('${unique_name}/tmp5.csv')\" \\\n+    2>&1| grep \"Odd number of consecutive percentage signs\" > /dev/null && echo \"OK\"\n+if [ -e \"${tmp_dir}/tmp5.csv\" ]; then\n+    echo \"tmp5.csv\"\n+fi\n+\n+# Clean\n+rm -rd $tmp_dir\n",
  "problem_statement": "`file` table function: an option to rename processed files\n**Use case**\r\n\r\nI process huge amount of files and want to see what files have been already processed and avoid processing them twice if the operation is restarted.\r\n\r\n**Describe the solution you'd like**\r\n\r\nA setting with some template like `{}.processed` or with regexp and replacement pattern.\r\n\r\nIt should allow moving files to another directory.\r\nThe directories should not be created. Path to destination directory should be checked according to `user_files_path`.\r\n\n",
  "hints_text": "",
  "created_at": "2023-05-07T15:34:14Z",
  "modified_files": [
    "docs/en/operations/settings/settings.md",
    "docs/en/sql-reference/table-functions/file.md",
    "docs/ru/operations/settings/settings.md",
    "docs/ru/sql-reference/table-functions/file.md",
    "src/Client/ClientBase.cpp",
    "b/src/Common/FileRenamer.cpp",
    "b/src/Common/FileRenamer.h",
    "src/Core/Settings.h",
    "src/Storages/StorageFile.cpp",
    "src/Storages/StorageFile.h",
    "src/TableFunctions/TableFunctionFile.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02732_rename_after_processing.reference",
    "b/tests/queries/0_stateless/02732_rename_after_processing.sh"
  ]
}