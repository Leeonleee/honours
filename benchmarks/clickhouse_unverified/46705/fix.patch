diff --git a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
index df96d83316ce..1476a66c8922 100644
--- a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
+++ b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
@@ -102,19 +102,21 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis
         if (!left_argument_constant_node && !right_argument_constant_node)
             return;
 
-        /** If we extract negative constant, aggregate function name must be updated.
+        /** Need reverse max <-> min for:
           *
-          * Example: SELECT min(-1 * id);
-          * Result: SELECT -1 * max(id);
+          * max(-1*value) -> -1*min(value)
+          * max(value/-2) -> min(value)/-2
+          * max(1-value) -> 1-min(value)
           */
-        std::string aggregate_function_name_if_constant_is_negative;
-        if (arithmetic_function_name == "multiply" || arithmetic_function_name == "divide")
+        auto get_reverse_aggregate_function_name = [](const std::string & aggregate_function_name) -> std::string
         {
-            if (lower_aggregate_function_name == "min")
-                aggregate_function_name_if_constant_is_negative = "max";
-            else if (lower_aggregate_function_name == "max")
-                aggregate_function_name_if_constant_is_negative = "min";
-        }
+            if (aggregate_function_name == "min")
+                return "max";
+            else if (aggregate_function_name == "max")
+                return "min";
+            else
+                return aggregate_function_name;
+        };
 
         size_t arithmetic_function_argument_index = 0;
 
@@ -126,11 +128,11 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis
 
             /// Rewrite `aggregate_function(inner_function(constant, argument))` into `inner_function(constant, aggregate_function(argument))`
             const auto & left_argument_constant_value_literal = left_argument_constant_node->getValue();
-            if (!aggregate_function_name_if_constant_is_negative.empty() &&
-                left_argument_constant_value_literal < zeroField(left_argument_constant_value_literal))
-            {
-                lower_aggregate_function_name = aggregate_function_name_if_constant_is_negative;
-            }
+            bool need_reverse = (arithmetic_function_name == "multiply" && left_argument_constant_value_literal < zeroField(left_argument_constant_value_literal))
+                || (arithmetic_function_name == "minus");
+
+            if (need_reverse)
+                lower_aggregate_function_name = get_reverse_aggregate_function_name(lower_aggregate_function_name);
 
             arithmetic_function_argument_index = 1;
         }
@@ -138,11 +140,10 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis
         {
             /// Rewrite `aggregate_function(inner_function(argument, constant))` into `inner_function(aggregate_function(argument), constant)`
             const auto & right_argument_constant_value_literal = right_argument_constant_node->getValue();
-            if (!aggregate_function_name_if_constant_is_negative.empty() &&
-                right_argument_constant_value_literal < zeroField(right_argument_constant_value_literal))
-            {
-                lower_aggregate_function_name = aggregate_function_name_if_constant_is_negative;
-            }
+            bool need_reverse = (arithmetic_function_name == "multiply" || arithmetic_function_name == "divide") && right_argument_constant_value_literal < zeroField(right_argument_constant_value_literal);
+
+            if (need_reverse)
+                lower_aggregate_function_name = get_reverse_aggregate_function_name(lower_aggregate_function_name);
 
             arithmetic_function_argument_index = 0;
         }
diff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
index 66e0813b977e..ef3e6739f8a7 100644
--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
@@ -73,24 +73,6 @@ Field zeroField(const Field & value)
     throw Exception(ErrorCodes::BAD_TYPE_OF_FIELD, "Unexpected literal type in function");
 }
 
-const String & changeNameIfNeeded(const String & func_name, const String & child_name, const ASTLiteral & literal)
-{
-    static const std::unordered_map<String, std::unordered_set<String>> matches = {
-        { "min", { "multiply", "divide" } },
-        { "max", { "multiply", "divide" } }
-    };
-
-    static const std::unordered_map<String, String> swap_to = {
-        { "min", "max" },
-        { "max", "min" }
-    };
-
-    if (literal.value < zeroField(literal.value) && matches.contains(func_name) && matches.find(func_name)->second.contains(child_name))
-        return swap_to.find(func_name)->second;
-
-    return func_name;
-}
-
 ASTPtr tryExchangeFunctions(const ASTFunction & func)
 {
     static const std::unordered_map<String, std::unordered_set<String>> supported
@@ -114,19 +96,42 @@ ASTPtr tryExchangeFunctions(const ASTFunction & func)
 
     ASTPtr optimized_ast;
 
+    /** Need reverse max <-> min for:
+      *
+      * max(-1*value) -> -1*min(value)
+      * max(value/-2) -> min(value)/-2
+      * max(1-value) -> 1-min(value)
+      */
+    auto get_reverse_aggregate_function_name = [](const std::string & aggregate_function_name) -> std::string
+    {
+        if (aggregate_function_name == "min")
+            return "max";
+        else if (aggregate_function_name == "max")
+            return "min";
+        else
+            return aggregate_function_name;
+    };
+
     if (first_literal && !second_literal)
     {
         /// It's possible to rewrite 'sum(1/n)' with 'sum(1) * div(1/n)' but we lose accuracy. Ignored.
         if (child_func->name == "divide")
             return {};
+        bool need_reverse
+            = (child_func->name == "multiply" && first_literal->value < zeroField(first_literal->value)) || child_func->name == "minus";
+        if (need_reverse)
+            lower_name = get_reverse_aggregate_function_name(lower_name);
 
-        const String & new_name = changeNameIfNeeded(lower_name, child_func->name, *first_literal);
-        optimized_ast = exchangeExtractFirstArgument(new_name, *child_func);
+        optimized_ast = exchangeExtractFirstArgument(lower_name, *child_func);
     }
     else if (second_literal) /// second or both are consts
     {
-        const String & new_name = changeNameIfNeeded(lower_name, child_func->name, *second_literal);
-        optimized_ast = exchangeExtractSecondArgument(new_name, *child_func);
+        bool need_reverse
+            = (child_func->name == "multiply" || child_func->name == "divide") && second_literal->value < zeroField(second_literal->value);
+        if (need_reverse)
+            lower_name = get_reverse_aggregate_function_name(lower_name);
+
+        optimized_ast = exchangeExtractSecondArgument(lower_name, *child_func);
     }
 
     if (optimized_ast)
