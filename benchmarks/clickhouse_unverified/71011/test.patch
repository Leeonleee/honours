diff --git a/tests/integration/test_s3_access_headers/__init__.py b/tests/integration/test_s3_access_headers/__init__.py
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/tests/integration/test_s3_access_headers/configs/config.d/named_collections.xml b/tests/integration/test_s3_access_headers/configs/config.d/named_collections.xml
new file mode 100644
index 000000000000..d08d34017789
--- /dev/null
+++ b/tests/integration/test_s3_access_headers/configs/config.d/named_collections.xml
@@ -0,0 +1,9 @@
+<clickhouse>
+  <named_collections>
+    <s3_mock>
+        <url>http://resolver:8081/root/test_named_colections.csv</url>
+        <access_key_id>minio</access_key_id>
+        <secret_access_key>minio123</secret_access_key>
+    </s3_mock>
+  </named_collections>
+</clickhouse>
diff --git a/tests/integration/test_s3_access_headers/configs/config.d/s3_headers.xml b/tests/integration/test_s3_access_headers/configs/config.d/s3_headers.xml
new file mode 100644
index 000000000000..2d2eeb3c7b1d
--- /dev/null
+++ b/tests/integration/test_s3_access_headers/configs/config.d/s3_headers.xml
@@ -0,0 +1,8 @@
+<clickhouse>
+  <s3>
+      <s3_mock>
+          <endpoint>http://resolver:8081/</endpoint>
+          <access_header>custom-auth-token: ValidToken1234</access_header>
+      </s3_mock>
+  </s3>
+</clickhouse>
diff --git a/tests/integration/test_s3_access_headers/configs/users.d/users.xml b/tests/integration/test_s3_access_headers/configs/users.d/users.xml
new file mode 100644
index 000000000000..4b6ba057ecb1
--- /dev/null
+++ b/tests/integration/test_s3_access_headers/configs/users.d/users.xml
@@ -0,0 +1,9 @@
+<clickhouse>
+    <users>
+        <default>
+            <password></password>
+            <profile>default</profile>
+            <named_collection_control>1</named_collection_control>
+        </default>
+    </users>
+</clickhouse>
diff --git a/tests/integration/test_s3_access_headers/s3_mocks/mocker_s3.py b/tests/integration/test_s3_access_headers/s3_mocks/mocker_s3.py
new file mode 100644
index 000000000000..0bbcb2e60e8f
--- /dev/null
+++ b/tests/integration/test_s3_access_headers/s3_mocks/mocker_s3.py
@@ -0,0 +1,97 @@
+import http.client
+import http.server
+import random
+import socketserver
+import sys
+import urllib.parse
+
+UPSTREAM_HOST = "minio1:9001"
+random.seed("No list objects/1.0")
+
+
+def request(command, url, headers={}, data=None):
+    """Mini-requests."""
+
+    class Dummy:
+        pass
+
+    parts = urllib.parse.urlparse(url)
+    c = http.client.HTTPConnection(parts.hostname, parts.port)
+    c.request(
+        command,
+        urllib.parse.urlunparse(parts._replace(scheme="", netloc="")),
+        headers=headers,
+        body=data,
+    )
+    r = c.getresponse()
+    result = Dummy()
+    result.status_code = r.status
+    result.headers = r.headers
+    result.content = r.read()
+    return result
+
+
+CUSTOM_AUTH_TOKEN_HEADER = "custom-auth-token"
+CUSTOM_AUTH_TOKEN_VALID_VALUE = "ValidToken1234"
+
+
+class RequestHandler(http.server.BaseHTTPRequestHandler):
+    def do_GET(self):
+        if self.path == "/":
+            self.send_response(200)
+            self.send_header("Content-Type", "text/plain")
+            self.end_headers()
+            self.wfile.write(b"OK")
+            return
+        self.do_HEAD()
+
+    def do_PUT(self):
+        self.do_HEAD()
+
+    def do_DELETE(self):
+        self.do_HEAD()
+
+    def do_POST(self):
+        self.do_HEAD()
+
+    def do_HEAD(self):
+
+        custom_auth_token = self.headers.get(CUSTOM_AUTH_TOKEN_HEADER)
+        if custom_auth_token and custom_auth_token != CUSTOM_AUTH_TOKEN_VALID_VALUE:
+            self.send_response(403)
+            self.send_header("Content-Type", "application/xml")
+            self.end_headers()
+
+            body = f"""<?xml version="1.0" encoding="UTF-8"?>
+<Error>
+    <Code>AccessDenied</Code>
+    <Message>Access Denied. Custom token was {custom_auth_token}, the correct one: {CUSTOM_AUTH_TOKEN_VALID_VALUE}.</Message>
+    <Resource>RESOURCE</Resource>
+    <RequestId>REQUEST_ID</RequestId>
+</Error>
+"""
+            self.wfile.write(body.encode())
+            return
+
+        content_length = self.headers.get("Content-Length")
+        data = self.rfile.read(int(content_length)) if content_length else None
+        r = request(
+            self.command,
+            f"http://{UPSTREAM_HOST}{self.path}",
+            headers=self.headers,
+            data=data,
+        )
+        self.send_response(r.status_code)
+        for k, v in r.headers.items():
+            self.send_header(k, v)
+        self.end_headers()
+        self.wfile.write(r.content)
+        self.wfile.close()
+
+
+class ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
+    """Handle requests in a separate thread."""
+
+
+httpd = ThreadedHTTPServer(("0.0.0.0", int(sys.argv[1])), RequestHandler)
+httpd.serve_forever()
diff --git a/tests/integration/test_s3_access_headers/test.py b/tests/integration/test_s3_access_headers/test.py
new file mode 100644
index 000000000000..4d4a5b81230e
--- /dev/null
+++ b/tests/integration/test_s3_access_headers/test.py
@@ -0,0 +1,124 @@
+import logging
+import os
+
+import pytest
+
+from helpers.cluster import ClickHouseCluster
+from helpers.mock_servers import start_mock_servers
+from helpers.s3_tools import prepare_s3_bucket
+
+SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
+
+
+def run_s3_mocks(started_cluster):
+    script_dir = os.path.join(os.path.dirname(__file__), "s3_mocks")
+    start_mock_servers(
+        started_cluster,
+        script_dir,
+        [
+            ("mocker_s3.py", "resolver", "8081"),
+        ],
+    )
+
+
+@pytest.fixture(scope="module")
+def started_cluster():
+    cluster = ClickHouseCluster(__file__, with_spark=True)
+    try:
+        cluster.add_instance(
+            "node1",
+            main_configs=[
+                "configs/config.d/named_collections.xml",
+                "configs/config.d/s3_headers.xml",
+            ],
+            user_configs=["configs/users.d/users.xml"],
+            with_minio=True,
+        )
+
+        logging.info("Starting cluster...")
+        cluster.start()
+
+        prepare_s3_bucket(cluster)
+        logging.info("S3 bucket created")
+
+        run_s3_mocks(cluster)
+        yield cluster
+
+    finally:
+        cluster.shutdown()
+
+
+CUSTOM_AUTH_TOKEN = "custom-auth-token"
+CORRECT_TOKEN = "ValidToken1234"
+INCORRECT_TOKEN = "InvalidToken1234"
+
+
+@pytest.mark.parametrize(
+    "table_name, engine, query_with_invalid_token_must_fail",
+    [
+        pytest.param(
+            "test_access_header",
+            "S3('http://resolver:8081/root/test_access_header.csv', 'CSV')",
+            True,
+            id="test_access_over_custom_header",
+        ),
+        pytest.param(
+            "test_static_override",
+            "S3('http://resolver:8081/root/test_static_override.csv', 'minio', 'minio123',  'CSV')",
+            False,
+            id="test_access_key_id_overrides_access_header",
+        ),
+        pytest.param(
+            "test_named_colections",
+            "S3(s3_mock, format='CSV')",
+            False,
+            id="test_named_coll_overrides_access_header",
+        ),
+    ],
+)
+def test_custom_access_header(
+    started_cluster, table_name, engine, query_with_invalid_token_must_fail
+):
+    instance = started_cluster.instances["node1"]
+
+    instance.query(
+        f"""
+        SET s3_truncate_on_insert=1;
+        INSERT INTO FUNCTION s3('http://minio1:9001/root/{table_name}.csv', 'minio', 'minio123','CSV')
+        SELECT number as a, toString(number) as b FROM numbers(3);
+        """
+    )
+    instance.query(
+        f"""
+        DROP TABLE IF EXISTS {table_name};
+        CREATE TABLE {table_name} (name String, value UInt32)
+        ENGINE={engine};
+        """
+    )
+    instance.query("SYSTEM DROP QUERY CACHE")
+
+    assert instance.query(f"SELECT count(*) FROM {table_name}") == "3
"
+
+    config_path = "/etc/clickhouse-server/config.d/s3_headers.xml"
+
+    instance.replace_in_config(
+        config_path,
+        f"<access_header>{CUSTOM_AUTH_TOKEN}: {CORRECT_TOKEN}",
+        f"<access_header>{CUSTOM_AUTH_TOKEN}: {INCORRECT_TOKEN}",
+    )
+    instance.query("SYSTEM RELOAD CONFIG")
+
+    if query_with_invalid_token_must_fail:
+        instance.query_and_get_error(f"SELECT count(*) FROM {table_name}")
+
+    else:
+        assert instance.query(f"SELECT count(*) FROM {table_name}") == "3
"
+
+    instance.replace_in_config(
+        config_path,
+        f"<access_header>{CUSTOM_AUTH_TOKEN}: {INCORRECT_TOKEN}",
+        f"<access_header>{CUSTOM_AUTH_TOKEN}: {CORRECT_TOKEN}",
+    )
+
+    instance.query("SYSTEM RELOAD CONFIG")
+    assert instance.query(f"SELECT count(*) FROM {table_name}") == "3
"
