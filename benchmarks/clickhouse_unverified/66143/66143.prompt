You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
UNSUPPORTED_METHOD for WITH statement with the production analyzer
ClickHouse version 24.4.1.2088

**Describe what's wrong**

WITH statement stopped working with UNSUPPORTED_METHOD. Probably a bug in beta analyzer:

https://fiddle.clickhouse.com/d36accf5-2e87-476f-b9e7-f2f5b7c746fd

**Expected behavior**

The WITH statement should work the same on both analyzers.

**Error message and/or stacktrace**

```
[cac8ec3c560a] 2024.05.01 14:27:23.425533 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Debug> executeQuery: (from 127.0.0.1:38868) WITH Block_Height BETWEEN 1 AND 2 AS block_filter SELECT * FROM test WHERE block_filter AND ( Block_Date IN ( SELECT Block_Date FROM test WHERE block_filter ) ) SETTINGS allow_experimental_analyzer = false; (stage: Complete)
[cac8ec3c560a] 2024.05.01 14:27:23.426251 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Trace> ContextAccess (default): Access granted: SELECT(Block_Height, Block_Date) ON default.test
[cac8ec3c560a] 2024.05.01 14:27:23.426337 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Trace> InterpreterSelectQuery: FetchColumns -> Complete
[cac8ec3c560a] 2024.05.01 14:27:23.426480 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Trace> ContextAccess (default): Access granted: SELECT(a, b, Block_Height, Block_Date) ON default.test
[cac8ec3c560a] 2024.05.01 14:27:23.426538 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Trace> InterpreterSelectQuery: FetchColumns -> Complete
[cac8ec3c560a] 2024.05.01 14:27:23.427962 [ 718 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Trace> CreatingSetsTransform: Creating set, key: __set_15181162166609052100_13383299000571546906
[cac8ec3c560a] 2024.05.01 14:27:23.428024 [ 718 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Debug> CreatingSetsTransform: Subquery has empty result.
[cac8ec3c560a] 2024.05.01 14:27:23.429282 [ 48 ] {a7d2aef8-abdb-4365-8377-6080ae86fcfb} <Debug> TCPHandler: Processed in 0.004043954 sec.
[cac8ec3c560a] 2024.05.01 14:27:23.430255 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Debug> executeQuery: (from 127.0.0.1:38868) SELECT 'THIS WORKS ---'; (stage: Complete)
[cac8ec3c560a] 2024.05.01 14:27:23.430397 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Trace> Planner: Query SELECT 'THIS WORKS ---' AS `'THIS WORKS ---'` FROM system.one AS __table1 to stage Complete
[cac8ec3c560a] 2024.05.01 14:27:23.430426 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Trace> ContextAccess (default): Access granted: SELECT(dummy) ON system.one
[cac8ec3c560a] 2024.05.01 14:27:23.430476 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Trace> Planner: Query SELECT 'THIS WORKS ---' AS `'THIS WORKS ---'` FROM system.one AS __table1 from stage FetchColumns to stage Complete
[cac8ec3c560a] 2024.05.01 14:27:23.430927 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Debug> executeQuery: Read 1 rows, 1.00 B in 0.000681 sec., 1468.4287812041116 rows/sec., 1.43 KiB/sec.
[cac8ec3c560a] 2024.05.01 14:27:23.430971 [ 48 ] {4f56781f-8214-47e0-ba42-391ecba97888} <Debug> TCPHandler: Processed in 0.000912421 sec.
[cac8ec3c560a] 2024.05.01 14:27:23.431756 [ 48 ] {ddea44dc-7fd0-4a42-8f4c-be3f2995af6c} <Debug> executeQuery: (from 127.0.0.1:38868) WITH Block_Height BETWEEN 1 AND 2 AS block_filter SELECT * FROM test WHERE block_filter AND ( Block_Date IN ( SELECT Block_Date FROM test WHERE block_filter ) ); (stage: Complete)
[cac8ec3c560a] 2024.05.01 14:27:23.432705 [ 48 ] {ddea44dc-7fd0-4a42-8f4c-be3f2995af6c} <Error> executeQuery: Code: 1. DB::Exception: Resolve identifier 'block_filter' from parent scope only supported for constants and CTE. Actual (Block_Height >= 1) AND (Block_Height <= 2) AS block_filter node type FUNCTION. In scope (SELECT Block_Date FROM test WHERE block_filter). (UNSUPPORTED_METHOD) (version 24.4.1.2088 (official build)) (from 127.0.0.1:38868) (in query: WITH Block_Height BETWEEN 1 AND 2 AS block_filter SELECT * FROM test WHERE block_filter AND ( Block_Date IN ( SELECT Block_Date FROM test WHERE block_filter ) );), Stack trace (when copying this message, always include the lines below):

0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000c9a449b
1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x000000000780b9ac
2. DB::Exception::Exception<String const&, String, char const*, String>(int, FormatStringHelperImpl<std::type_identity<String const&>::type, std::type_identity<String>::type, std::type_identity<char const*>::type, std::type_identity<String>::type>, String const&, String&&, char const*&&, String&&) @ 0x0000000010ac0e4f
3. DB::(anonymous namespace)::QueryAnalyzer::tryResolveIdentifier(DB::(anonymous namespace)::IdentifierLookup const&, DB::(anonymous namespace)::IdentifierResolveScope&, DB::(anonymous namespace)::IdentifierResolveSettings) @ 0x0000000010a95f53
4. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a84eb8
5. DB::(anonymous namespace)::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010a7a7d6
6. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a84933
7. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a831ed
8. DB::(anonymous namespace)::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010a9d957
9. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a841bc
10. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a831ed
11. DB::(anonymous namespace)::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010a9d957
12. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010a841bc
13. DB::(anonymous namespace)::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010a7a7d6
14. DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x0000000010a780c5
15. DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>) @ 0x0000000010a76983
16. DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) (.llvm.9862110563685019565) @ 0x0000000010d0aafd
17. DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&) @ 0x0000000010d09899
18. std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) (.llvm.9862110563685019565) @ 0x0000000010d0c86c
19. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x0000000010c9ec79
20. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001111a030
21. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x00000000111169ba
22. DB::TCPHandler::runImpl() @ 0x00000000122a59c4
23. DB::TCPHandler::run() @ 0x00000000122c1fb9
24. Poco::Net::TCPServerConnection::start() @ 0x0000000014c105b2
25. Poco::Net::TCPServerDispatcher::run() @ 0x0000000014c113f9
26. Poco::PooledThread::run() @ 0x0000000014d09a61
27. Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000014d07ffd
28. ? @ 0x000077fa4d433609
29. ? @ 0x000077fa4d34e353

Received exception from server (version 24.4.1):
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolve identifier 'block_filter' from parent scope only supported for constants and CTE. Actual (Block_Height >= 1) AND (Block_Height <= 2) AS block_filter node type FUNCTION. In scope (SELECT Block_Date FROM test WHERE block_filter). (UNSUPPORTED_METHOD)
(query: WITH Block_Height BETWEEN 1 AND 2 AS block_filter
SELECT *
FROM test
WHERE block_filter 
AND (
    Block_Date IN (
      SELECT Block_Date FROM test WHERE block_filter
    )
);)
```

Resolve identifier supported for constants and CTE. Actual node type COLUMN with `allow_experimental_analyzer=1, join_use_nulls=1`


> You have to provide the following information whenever possible.

**Describe what's wrong**
24.1 https://fiddle.clickhouse.com/5ada3a58-e2ea-4547-8abf-cd8888cf8cc8
23.3 https://fiddle.clickhouse.com/2672375c-0bda-49b3-865e-6004c004e281 working correctly

```
WITH ws_wh AS
    (
        SELECT
            ws1.ws_order_number
        FROM
        (
            SELECT
                1 AS ws_order_number,
                1 AS ws_warehouse_sk
        ) AS ws1,
        (
            SELECT
                1 AS ws_order_number,
                2 AS ws_warehouse_sk
        ) AS ws2
        WHERE (ws1.ws_order_number = ws2.ws_order_number) AND (ws1.ws_warehouse_sk != ws2.ws_warehouse_sk)
    )
SELECT COUNT()
FROM
(
    SELECT 1 AS ws_order_number
) AS ws1
WHERE (ws1.ws_order_number IN (
    SELECT ws_order_number
    FROM ws_wh
))
SETTINGS allow_experimental_analyzer = 1,join_use_nulls=1

Received exception from server (version 24.1.1):
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolve identifier 'ws_order_number' from parent scope only supported for constants and CTE. Actual ws1.ws_order_number node type COLUMN. In scope (SELECT ws_order_number FROM ws_wh). (UNSUPPORTED_METHOD)

Works for SETTINGS allow_experimental_analyzer = 0,join_use_nulls=1 or SETTINGS allow_experimental_analyzer = 1,join_use_nulls=0
```

**Does it reproduce on recent release?**

Yes

```
Received exception from server (version 24.1.1):
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolve identifier 'ws_order_number' from parent scope only supported for constants and CTE. Actual ws1.ws_order_number node type COLUMN. In scope (SELECT ws_order_number FROM ws_wh). (UNSUPPORTED_METHOD)
(query: with ws_wh as
(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2
 from web_sales ws1,web_sales ws2
 where ws1.ws_order_number = ws2.ws_order_number
   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
 select  
   count(distinct ws_order_number) as "order count"
  ,sum(ws_ext_ship_cost) as "total shipping cost"
  ,sum(ws_net_profit) as "total net profit"
from
   web_sales ws1
  ,date_dim
  ,customer_address
  ,web_site
where
    d_date between '1999-5-01' and 
           (cast('1999-5-01' as date) + INTERVAL 60 day)
and ws1.ws_ship_date_sk = d_date_sk
and ws1.ws_ship_addr_sk = ca_address_sk
and ca_state = 'TX'
and ws1.ws_web_site_sk = web_site_sk
and web_company_name = 'pri'
and ws1.ws_order_number in (select ws_order_number
                            from ws_wh)
and ws1.ws_order_number in (select wr_order_number
                            from web_returns,ws_wh
                            where wr_order_number = ws_wh.ws_order_number)
order by count(distinct ws_order_number)
LIMIT 100;)
```
Code: 47. DB::Exception: Unknown expression or function identifier in scope WITH 
ID Finance

Our solution (under 23.8.2 of clickhouse) contains this feature within WITH clause:

```
create table test
(
    raw_id String,
    columns_n Nested
        (
        col_1 Nullable(String),
        col_2 Nullable(String)
        )
)
    Engine = MergeTree
        order by (raw_id);

insert into test
VALUES('1', ['type_1','type_2','type_1'],['0','0','1']),
      ('2', ['type_3','type_2','type_1'],['0','1','1']),
      ('3', ['type_1','type_2','type_3'],['1','0','1'])
;

**with t like '%_1%' as issue
select  raw_id,
        arrayFilter((t, t2) -> (not issue),
            columns_n.col_1,
            columns_n.col_2
        )
from test;**
```

When we try to use the same feature in clickhouse version 24.5.1 we get the following error:

`Code: 47. DB::Exception: Unknown expression or function identifier 't' in scope WITH t LIKE '%_1%' AS issue SELECT raw_id, arrayFilter((t, t2) -> (NOT issue), columns_n.col_1, columns_n.col_2) FROM test (UNKNOWN_IDENTIFIER) (version 24.5.1.1763 (official build)`

It worked only when I used 

`SETTINGS allow_experimental_analyzer = 0;`

The question is:

Will our solution require additional tweaks when the old analyzer will be deprecated fully (meaning we won't be able to use SETTINGS allow_experimental_analyzer = 0;)

Regards




WITH Clause CTE expressions causes exception when used in CTE subquery on latest version.
**Describe the issue**
A CTE expression used in a CTE subquery causes an exception on latest version.

**How to reproduce**
ClickHouse versions tested:
- Docker Image `clickhouse/clickhouse-server:latest`
- Docker Image `clickhouse/clickhouse-server:24.2`

OS: `Ubuntu 22.04 LTS`

Query in concern:
```sql
WITH
(`database` LIKE 'system') AS `$condition`,
`$main` AS (SELECT DISTINCT table FROM system.tables WHERE `$condition`)
SELECT * FROM `$main`;
```
The above query can be executed perfectly on `clickhouse/clickhouse-server:24.2` using ClickHouse's command line client. 

However, in the latest image, the following exception is received:
```
Received exception from server (version 24.3.2):
Code: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown expression or function identifier 'database' in scope WITH database LIKE 'system' AS `$condition`, `$main` AS (SELECT DISTINCT `table` FROM system.tables WHERE `$condition`) SELECT * FROM `$main`. (UNKNOWN_IDENTIFIER)
```

**Error message and/or stacktrace**
See `clickhouse-server.err.log` below
```
2024.04.25 03:35:28.986946 [ 48 ] {4ec0d7db-bc36-4bcb-8056-bf805f8de9b6} <Error> TCPHandler: Code: 47. DB::Exception: Unknown expression or function identifier 'database' in scope WITH database LIKE 'system' AS `$condition`, `$main` AS (SELECT DISTINCT `table` FROM system.tables WHERE `$condition`) SELECT * FROM `$main`. (UNKNOWN_IDENTIFIER), Stack trace (when copying this message, always include the lines below):

0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000cbcedbb
1. DB::Exception::Exception<char const*, String&, String const&, String, String>(int, FormatStringHelperImpl<std::type_identity<char const*>::type, std::type_identity<String&>::type, std::type_identity<String const&>::type, std::type_identity<String>::type, std::type_identity<String>::type>, char const*&&, String&, String const&, String&&, String&&) @ 0x0000000010c1a54b
2. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010bd3eee
3. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010bcf54d
4. DB::(anonymous namespace)::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010be9237
5. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010bd09a0
6. DB::(anonymous namespace)::QueryAnalyzer::tryResolveIdentifierFromAliases(DB::(anonymous namespace)::IdentifierLookup const&, DB::(anonymous namespace)::IdentifierResolveScope&, DB::(anonymous namespace)::IdentifierResolveSettings) @ 0x0000000010be3f94
7. DB::(anonymous namespace)::QueryAnalyzer::tryResolveIdentifier(DB::(anonymous namespace)::IdentifierLookup const&, DB::(anonymous namespace)::IdentifierResolveScope&, DB::(anonymous namespace)::IdentifierResolveSettings) @ 0x0000000010be0efc
8. DB::(anonymous namespace)::QueryAnalyzer::tryResolveIdentifier(DB::(anonymous namespace)::IdentifierLookup const&, DB::(anonymous namespace)::IdentifierResolveScope&, DB::(anonymous namespace)::IdentifierResolveSettings) @ 0x0000000010be177f
9. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010bd1507
10. DB::(anonymous namespace)::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010bc753c
11. DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x0000000010bd0f6d
12. DB::(anonymous namespace)::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, DB::(anonymous namespace)::QueryExpressionsAliasVisitor&) @ 0x0000000010bd9200
13. DB::(anonymous namespace)::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x0000000010bc7304
14. DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x0000000010bc4d25
15. DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>) @ 0x0000000010bc35e3
16. DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) (.llvm.17547086829861056443) @ 0x0000000010e5421d
17. DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&) @ 0x0000000010e52fb1
18. std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) (.llvm.17547086829861056443) @ 0x0000000010e55f8c
19. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x0000000010de7ef9
20. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001126f9c8
21. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000001126bf9a
22. DB::TCPHandler::runImpl() @ 0x0000000012351d84
23. DB::TCPHandler::run() @ 0x000000001236d099
24. Poco::Net::TCPServerConnection::start() @ 0x0000000014c9bef2
25. Poco::Net::TCPServerDispatcher::run() @ 0x0000000014c9cd39
26. Poco::PooledThread::run() @ 0x0000000014d954a1
27. Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000014d93a3d
28. ? @ 0x0000758715368609
29. ? @ 0x000075871528d353
```

**Additional Information**
The following query is also tested:
```sql
WITH
(`database` LIKE 'system') AS `$cond`
SELECT DISTINCT table FROM system.tables WHERE `$cond`;
```
This query works perfectly on both versions.
Same-named, nested CTEs with the production analyzer enabled error with `UNKNOWN_TABLE`
ClickHouse version: v24.8.2.3

**Describe what's wrong**

With the new analyzer, ClickHouse is unable to execute a query where an nested CTE uses a CTE with the same name as an outer CTE. For example, this query fails with `UNKNOWN_TABLE`:

```sql
with query_1 as (
    with shared_data as (
        select 1 as value
    ), shared_data_2 as (
        select * from shared_data
    )
    select * from shared_data_2
), shared_data as (
    select * from query_1
)
select * from shared_data s -- raises UNKNOWN_TABLE
```

If I disable the new analyzer with `allow_experimental_analyzer=0`, the query returns what I expect and doesn't error.

Link to [play.clickhouse.com](https://play.clickhouse.com/play?user=play#d2l0aCBxdWVyeV8xIGFzICgKICAgIHdpdGggc2hhcmVkX2RhdGEgYXMgKAogICAgICAgIHNlbGVjdCAxIGFzIHZhbHVlCiAgICApLCBzaGFyZWRfZGF0YV8yIGFzICgKICAgICAgICBzZWxlY3QgKiBmcm9tIHNoYXJlZF9kYXRhCiAgICApCiAgICBzZWxlY3QgKiBmcm9tIHNoYXJlZF9kYXRhXzIKKSwgc2hhcmVkX2RhdGEgYXMgKAogICAgc2VsZWN0ICogZnJvbSBxdWVyeV8xCikKc2VsZWN0ICogZnJvbSBzaGFyZWRfZGF0YSBzIAo=) (fiddle isn't working right now)

**Does it reproduce on the most recent release?**

Yes

**How to reproduce**

* Run the above query; see error

**Expected behavior**

I would expect that the query execute and follow the behavior of the old analyzer.

**Error message and/or stacktrace**

```
0. Poco::Exception::Exception(String const&, int) @ 0x000000010d4b0e60
1. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x00000001073bb0e4
2. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000102c48a7c
3. DB::Exception::Exception<String const&, String>(int, FormatStringHelperImpl<std::type_identity<String const&>::type, std::type_identity<String>::type>, String const&, String&&) @ 0x00000001031b5380
4. DB::QueryAnalyzer::initializeQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000010a74eb24
5. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000010a729644
6. DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000010a72e3b0
7. DB::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, DB::QueryExpressionsAliasVisitor&) @ 0x000000010a74f834
8. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000010a729664
9. DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000010a72e3b0
10. DB::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, DB::QueryExpressionsAliasVisitor&) @ 0x000000010a74f834
11. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000010a729664
12. DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000010a72e3b0
13. DB::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, DB::QueryExpressionsAliasVisitor&) @ 0x000000010a74f834
14. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000010a729664
15. DB::QueryAnalyzer::resolve(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::IQueryTreeNode> const&, std::shared_ptr<DB::Context const>) @ 0x000000010a728c28
16. DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x000000010a728540
17. DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>) @ 0x000000010a6a393c
18. DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) @ 0x000000010ac3a080
19. DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x000000010ac382f8
20. std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) @ 0x000000010ac3b884
21. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x000000010abdb13c
22. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000010af12004
23. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000010af0f754
24. DB::LocalConnection::sendQuery(DB::ConnectionTimeouts const&, String const&, std::unordered_map<String, String, std::hash<String>, std::equal_to<String>, std::allocator<std::pair<String const, String>>> const&, String const&, unsigned long long, DB::Settings const*, DB::ClientInfo const*, bool, std::function<void (DB::Progress const&)>) @ 0x000000010be4e9f8
25. DB::ClientBase::processOrdinaryQuery(String const&, std::shared_ptr<DB::IAST>) @ 0x000000010be0df70
26. DB::ClientBase::processParsedSingleQuery(String const&, String const&, std::shared_ptr<DB::IAST>, std::optional<bool>, bool) @ 0x000000010be0cc04
27. DB::ClientBase::executeMultiQuery(String const&) @ 0x000000010be14c80
28. DB::ClientBase::processQueryText(String const&) @ 0x000000010be15978
29. DB::ClientBase::runInteractive() @ 0x000000010be178d0
30. DB::LocalServer::main(std::vector<String, std::allocator<String>> const&) @ 0x0000000107693790
31. Poco::Util::Application::run() @ 0x000000010d58825c


Elapsed: 0.001 sec.

Received exception:
Code: 60. DB::Exception: Unknown table expression identifier 'shared_data' in scope shared_data_2 AS (SELECT * FROM shared_data). (UNKNOWN_TABLE)
```


Analyzer: Expression can not be resolved from parent scope
**Company or project name**

ClickHouse inc.

**Describe what's wrong**

Identifiers from the nested CTE are not evaluated properly. 

https://fiddle.clickhouse.com/a62f1ed0-aa44-44af-888a-5b194d81b5a6

**Does it reproduce on the most recent release?**

Yes.

**How to reproduce**

```
CREATE TABLE test
(
    a UInt64,
    b UInt64,
)
ENGINE = MergeTree
ORDER BY tuple();

SET allow_experimental_analyzer=1;

WITH
   (a > b) as cte,
   query AS
    (
        SELECT count()
        FROM test
        WHERE cte
    )
SELECT *
FROM query;
```


**Error message and/or stacktrace**

```
Received exception from server (version 24.10.1):
Code: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown expression or function identifier `a` in scope WITH a > b AS cte, query AS (SELECT count() FROM test WHERE cte) SELECT * FROM query. (UNKNOWN_IDENTIFIER)
(query: WITH
   (a > b) as cte,
   query AS
    (
        SELECT count()
        FROM test
        WHERE cte
    )
SELECT *
FROM query;)
```

Analyzer: (Almost) constant expression can not be resolved from parent scope
ClickHouse v24.3+ (including latest lts v24.8 and latest in fiddle v24.10)

Exception:
```
with
    arrayMap(x -> x + 1, [0]) as a
select
    1
where
    1 in (select arrayJoin(a))
settings allow_experimental_analyzer = 1;

Received exception from server (version 24.10.1):
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolve identifier 'a' from parent scope only supported for constants and CTE. Actual arrayMap(x -> (x + 1), [0]) AS a node type FUNCTION. In scope (SELECT arrayJoin(a)). (UNSUPPORTED_METHOD)
```
In my mind this can't be a scope issue because this query works fine:
```
with
    [1] as a
select
    1
where
    1 in (select arrayJoin(a))
settings allow_experimental_analyzer = 1;
1
```
And `arrayMap(x -> x + 1, [0]) as a` is constant (known at the time the SQL query is parsed) and works fine with old analyzer:
```
with
    arrayMap(x -> x + 1, [0]) as a
select
    1
where
    1 in (select arrayJoin(a))
settings allow_experimental_analyzer = 0;
1
```

Sample queries:
https://fiddle.clickhouse.com/6a9e9d11-4529-41e2-b7c1-b2c0cbce32dd
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
