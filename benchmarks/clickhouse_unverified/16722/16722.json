{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16722,
  "instance_id": "ClickHouse__ClickHouse-16722",
  "issue_numbers": [
    "15310"
  ],
  "base_commit": "d88a5983dc1519b8e5e7d936c588cfc56d2ab4c4",
  "patch": "diff --git a/src/Interpreters/NullableUtils.cpp b/src/Interpreters/NullableUtils.cpp\nindex d1586bec06b2..ce681b1d5692 100644\n--- a/src/Interpreters/NullableUtils.cpp\n+++ b/src/Interpreters/NullableUtils.cpp\n@@ -5,7 +5,7 @@\n namespace DB\n {\n \n-ColumnPtr extractNestedColumnsAndNullMap(ColumnRawPtrs & key_columns, ConstNullMapPtr & null_map, bool exact_null)\n+ColumnPtr extractNestedColumnsAndNullMap(ColumnRawPtrs & key_columns, ConstNullMapPtr & null_map)\n {\n     ColumnPtr null_map_holder;\n \n@@ -38,12 +38,7 @@ ColumnPtr extractNestedColumnsAndNullMap(ColumnRawPtrs & key_columns, ConstNullM\n                     PaddedPODArray<UInt8> & mutable_null_map = assert_cast<ColumnUInt8 &>(*mutable_null_map_holder).getData();\n                     const PaddedPODArray<UInt8> & other_null_map = column_nullable->getNullMapData();\n                     for (size_t i = 0, size = mutable_null_map.size(); i < size; ++i)\n-                    {\n-                        if (exact_null)\n-                            mutable_null_map[i] &= other_null_map[i];\n-                        else\n-                            mutable_null_map[i] |= other_null_map[i];\n-                    }\n+                        mutable_null_map[i] |= other_null_map[i];\n \n                     null_map_holder = std::move(mutable_null_map_holder);\n                 }\ndiff --git a/src/Interpreters/NullableUtils.h b/src/Interpreters/NullableUtils.h\nindex f8294832c1d9..8750a60f2473 100644\n--- a/src/Interpreters/NullableUtils.h\n+++ b/src/Interpreters/NullableUtils.h\n@@ -9,6 +9,6 @@ namespace DB\n   * In 'null_map' return a map of positions where at least one column was NULL.\n   * @returns ownership column of null_map.\n   */\n-ColumnPtr extractNestedColumnsAndNullMap(ColumnRawPtrs & key_columns, ConstNullMapPtr & null_map, bool exact_null = false);\n+ColumnPtr extractNestedColumnsAndNullMap(ColumnRawPtrs & key_columns, ConstNullMapPtr & null_map);\n \n }\ndiff --git a/src/Interpreters/Set.cpp b/src/Interpreters/Set.cpp\nindex 0f9760661655..13606e1d54cb 100644\n--- a/src/Interpreters/Set.cpp\n+++ b/src/Interpreters/Set.cpp\n@@ -87,8 +87,6 @@ void NO_INLINE Set::insertFromBlockImplCase(\n         {\n             if ((*null_map)[i])\n             {\n-                has_null = true;\n-\n                 if constexpr (build_filter)\n                 {\n                     (*out_filter)[i] = false;\n@@ -140,7 +138,9 @@ void Set::setHeader(const Block & header)\n \n     /// We will insert to the Set only keys, where all components are not NULL.\n     ConstNullMapPtr null_map{};\n-    ColumnPtr null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map, transform_null_in);\n+    ColumnPtr null_map_holder;\n+    if (!transform_null_in)\n+        extractNestedColumnsAndNullMap(key_columns, null_map);\n \n     if (fill_set_elements)\n     {\n@@ -180,7 +180,9 @@ bool Set::insertFromBlock(const Block & block)\n \n     /// We will insert to the Set only keys, where all components are not NULL.\n     ConstNullMapPtr null_map{};\n-    ColumnPtr null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map, transform_null_in);\n+    ColumnPtr null_map_holder;\n+    if (!transform_null_in)\n+         null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map);\n \n     /// Filter to extract distinct values from the block.\n     ColumnUInt8::MutablePtr filter;\n@@ -259,8 +261,9 @@ ColumnPtr Set::execute(const Block & block, bool negative) const\n \n     /// We will check existence in Set only for keys, where all components are not NULL.\n     ConstNullMapPtr null_map{};\n-\n-    ColumnPtr null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map, transform_null_in);\n+    ColumnPtr null_map_holder;\n+    if (!transform_null_in)\n+        null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map);\n \n     executeOrdinary(key_columns, vec_res, negative, null_map);\n \n@@ -303,10 +306,7 @@ void NO_INLINE Set::executeImplCase(\n     {\n         if (has_null_map && (*null_map)[i])\n         {\n-            if (transform_null_in && has_null)\n-                vec_res[i] = !negative;\n-            else\n-                vec_res[i] = negative;\n+            vec_res[i] = negative;\n         }\n         else\n         {\ndiff --git a/src/Interpreters/Set.h b/src/Interpreters/Set.h\nindex faae9c7318ed..d3c9b8f684b0 100644\n--- a/src/Interpreters/Set.h\n+++ b/src/Interpreters/Set.h\n@@ -108,10 +108,9 @@ class Set\n     /// Do we need to additionally store all elements of the set in explicit form for subsequent use for index.\n     bool fill_set_elements;\n \n+    /// If true, insert NULL values to set.\n     bool transform_null_in;\n \n-    bool has_null = false;\n-\n     /// Check if set contains all the data.\n     bool is_created = false;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01558_transform_null_in.reference b/tests/queries/0_stateless/01558_transform_null_in.reference\nnew file mode 100644\nindex 000000000000..7555eedd5d0c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01558_transform_null_in.reference\n@@ -0,0 +1,17 @@\n+4\n+2\n+2\n+1\n+0\n+3\n+==============\n+1\n+1\n+0\n+1\n+1\n+0\n+1\n+1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/01558_transform_null_in.sql b/tests/queries/0_stateless/01558_transform_null_in.sql\nnew file mode 100644\nindex 000000000000..0036c08a6491\n--- /dev/null\n+++ b/tests/queries/0_stateless/01558_transform_null_in.sql\n@@ -0,0 +1,31 @@\n+SET transform_null_in = 1;\n+\n+DROP TABLE IF EXISTS null_in_1;\n+CREATE TABLE null_in_1 (u UInt32, n Nullable(UInt32)) ENGINE = Memory;\n+INSERT INTO null_in_1 VALUES (1, NULL), (2, 2), (3, NULL), (4, 4), (5, NULL);\n+\n+SELECT count() FROM null_in_1 WHERE n IN (1, 2, NULL);\n+SELECT count() FROM null_in_1 WHERE u IN (1, 2, NULL);\n+SELECT count() FROM null_in_1 WHERE (u, n) IN ((1, 2), (1, NULL), (2, 2));\n+SELECT count() FROM null_in_1 WHERE (u, n) IN ((NULL, NULL), (2, 2), (NULL, 2));\n+SELECT count() FROM null_in_1 WHERE (u, n) IN (42, NULL);\n+SELECT count() FROM null_in_1 WHERE (u, n) NOT IN ((3, NULL), (5, NULL));\n+\n+SELECT '==============';\n+DROP TABLE IF EXISTS null_in_1;\n+\n+CREATE TABLE null_in_1 (a Nullable(UInt32), b Nullable(UInt32)) ENGINE = Memory;\n+INSERT INTO null_in_1 VALUES (1, NULL) (0, NULL) (NULL, NULL) (NULL, 1) (NULL, 0) (0, 0) (1, 1);\n+\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (1, NULL);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (0, NULL);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (42, NULL);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (NULL, 0);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (NULL, 1);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (NULL, 42);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (NULL, NULL);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (0, 0);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (1, 1);\n+SELECT count() FROM null_in_1 WHERE (a, b) IN (1, 42);\n+\n+DROP TABLE IF EXISTS null_in_1;\n",
  "problem_statement": "Wrong results of query with setting transform_null_in=1.\n**Describe the bug**\r\nSetting `transform_null_in` works incorrectly with `IN` operator over tuples.\r\n\r\n**How to reproduce**\r\n1.\r\n```\r\nCREATE TABLE null_in_1 (u UInt32, n Nullable(UInt32)) ENGINE = Memory;\r\nINSERT INTO null_in_1 VALUES (1, NULL), (2, 2), (3, NULL), (4, 4), (5, NULL);\r\n```\r\n\r\n```\r\nSET transform_null_in = 1;\r\nSELECT count() FROM null_in_1 WHERE (u, n) IN ((42, NULL));\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt interprets all rows, where `n` is `NULL` as matched, despite the value of `u`.\r\n\r\n\r\n2.\r\n```\r\nCREATE TABLE null_in_1 (a Nullable(UInt32), b Nullable(UInt32)) ENGINE = Memory;\r\nINSERT INTO null_in_1 VALUES (1, NULL) (0, NULL) (NULL, NULL) (NULL, 1) (NULL, 0) (0, 0) (1, 1);\r\n```\r\n\r\n```\r\nSET transform_null_in = 1;\r\nSELECT count() FROM null_in_1 WHERE (a, b) IN (0, NULL);\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT count() FROM null_in_1 WHERE (a, b) IN (NULL, 0);\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT count() FROM null_in_1 WHERE (a, b) IN (0, 0);\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt doesn't see the difference between default value and null value.\r\n\n",
  "hints_text": "",
  "created_at": "2020-11-05T18:17:07Z",
  "modified_files": [
    "src/Interpreters/NullableUtils.cpp",
    "src/Interpreters/NullableUtils.h",
    "src/Interpreters/Set.cpp",
    "src/Interpreters/Set.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01558_transform_null_in.reference",
    "b/tests/queries/0_stateless/01558_transform_null_in.sql"
  ]
}