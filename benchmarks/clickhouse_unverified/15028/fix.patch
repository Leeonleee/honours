diff --git a/src/Common/UnicodeBar.cpp b/src/Common/UnicodeBar.cpp
new file mode 100644
index 000000000000..8ff5e2052c1d
--- /dev/null
+++ b/src/Common/UnicodeBar.cpp
@@ -0,0 +1,70 @@
+#include <cstring>
+#include <cmath>
+#include <string>
+#include <common/types.h>
+#include <common/arithmeticOverflow.h>
+#include <Common/Exception.h>
+#include <Common/UnicodeBar.h>
+
+
+namespace DB
+{
+    namespace ErrorCodes
+    {
+        extern const int PARAMETER_OUT_OF_BOUND;
+    }
+}
+
+
+namespace UnicodeBar
+{
+    double getWidth(Int64 x, Int64 min, Int64 max, double max_width)
+    {
+        if (x <= min)
+            return 0;
+
+        if (x >= max)
+            return max_width;
+
+        /// The case when max - min overflows
+        Int64 max_difference;
+        if (common::subOverflow(max, min, max_difference))
+            throw DB::Exception(DB::ErrorCodes::PARAMETER_OUT_OF_BOUND, "The arguments to render unicode bar will lead to arithmetic overflow");
+
+        return (x - min) * max_width / max_difference;
+    }
+
+    size_t getWidthInBytes(double width)
+    {
+        return ceil(width - 1.0 / 8) * UNICODE_BAR_CHAR_SIZE;
+    }
+
+    void render(double width, char * dst)
+    {
+        size_t floor_width = floor(width);
+
+        for (size_t i = 0; i < floor_width; ++i)
+        {
+            memcpy(dst, "█", UNICODE_BAR_CHAR_SIZE);
+            dst += UNICODE_BAR_CHAR_SIZE;
+        }
+
+        size_t remainder = floor((width - floor_width) * 8);
+
+        if (remainder)
+        {
+            memcpy(dst, &"▏▎▍▌▋▋▊▉"[(remainder - 1) * UNICODE_BAR_CHAR_SIZE], UNICODE_BAR_CHAR_SIZE);
+            dst += UNICODE_BAR_CHAR_SIZE;
+        }
+
+        *dst = 0;
+    }
+
+    std::string render(double width)
+    {
+        std::string res(getWidthInBytes(width), '\0');
+        render(width, res.data());
+        return res;
+    }
+}
+
diff --git a/src/Common/UnicodeBar.h b/src/Common/UnicodeBar.h
index 9a5bcecbd629..0c62bd7e8f73 100644
--- a/src/Common/UnicodeBar.h
+++ b/src/Common/UnicodeBar.h
@@ -1,7 +1,5 @@
 #pragma once
 
-#include <cstring>
-#include <cmath>
 #include <string>
 #include <common/types.h>
 
@@ -10,54 +8,12 @@
 
 /** Allows you to draw a unicode-art bar whose width is displayed with a resolution of 1/8 character.
   */
-
-
 namespace UnicodeBar
 {
-    using DB::Int64;
-
-    inline double getWidth(Int64 x, Int64 min, Int64 max, double max_width)
-    {
-        if (x <= min)
-            return 0;
-
-        if (x >= max)
-            return max_width;
-
-        return (x - min) * max_width / (max - min);
-    }
-
-    inline size_t getWidthInBytes(double width)
-    {
-        return ceil(width - 1.0 / 8) * UNICODE_BAR_CHAR_SIZE;
-    }
+    double getWidth(Int64 x, Int64 min, Int64 max, double max_width);
+    size_t getWidthInBytes(double width);
 
     /// In `dst` there must be a space for barWidthInBytes(width) characters and a trailing zero.
-    inline void render(double width, char * dst)
-    {
-        size_t floor_width = floor(width);
-
-        for (size_t i = 0; i < floor_width; ++i)
-        {
-            memcpy(dst, "█", UNICODE_BAR_CHAR_SIZE);
-            dst += UNICODE_BAR_CHAR_SIZE;
-        }
-
-        size_t remainder = floor((width - floor_width) * 8);
-
-        if (remainder)
-        {
-            memcpy(dst, &"▏▎▍▌▋▋▊▉"[(remainder - 1) * UNICODE_BAR_CHAR_SIZE], UNICODE_BAR_CHAR_SIZE);
-            dst += UNICODE_BAR_CHAR_SIZE;
-        }
-
-        *dst = 0;
-    }
-
-    inline std::string render(double width)
-    {
-        std::string res(getWidthInBytes(width), '\0');
-        render(width, res.data());
-        return res;
-    }
+    void render(double width, char * dst);
+    std::string render(double width);
 }
diff --git a/src/Common/ya.make b/src/Common/ya.make
index 9b671e7b9eed..fb04ecaa1412 100644
--- a/src/Common/ya.make
+++ b/src/Common/ya.make
@@ -99,6 +99,7 @@ SRCS(
     ThreadProfileEvents.cpp
     ThreadStatus.cpp
     TraceCollector.cpp
+    UnicodeBar.cpp
     UTF8Helpers.cpp
     WeakHash.cpp
     ZooKeeper/IKeeper.cpp
