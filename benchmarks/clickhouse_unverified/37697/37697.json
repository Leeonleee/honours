{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37697,
  "instance_id": "ClickHouse__ClickHouse-37697",
  "issue_numbers": [
    "22959"
  ],
  "base_commit": "ab9fc572d536ec9b3b7b2ac8628a3824bdeeda4c",
  "patch": "diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex feacbd085c23..8fe8e2aa23e6 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -908,6 +908,8 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         return ReturnType(false);\n     }\n \n+    int negative_multiplier = 1;\n+\n     DB::DecimalUtils::DecimalComponents<DateTime64> components{static_cast<DateTime64::NativeType>(whole), 0};\n \n     if (!buf.eof() && *buf.position() == '.')\n@@ -934,29 +936,18 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         while (!buf.eof() && isNumericASCII(*buf.position()))\n             ++buf.position();\n \n-        /// Keep sign of fractional part the same with whole part if datetime64 is negative\n-        /// Case1:\n-        ///     1965-12-12 12:12:12.123\n-        ///     => whole = -127914468, fractional = 123(coefficient>0)\n-        ///     => new whole = -127914467, new fractional = 877(coefficient<0)\n-        ///\n-        /// Case2:\n-        ///     1969-12-31 23:59:59.123\n-        ///     => whole = -1, fractional = 123(coefficient>0)\n-        ///     => new whole = 0, new fractional = -877(coefficient>0)\n+        /// Fractional part (subseconds) is treated as positive by users\n+        /// (as DateTime64 itself is a positive, although underlying decimal is negative)\n+        /// setting fractional part to be negative when whole is 0 results in wrong value,\n+        /// so we multiply result by -1.\n         if (components.whole < 0 && components.fractional != 0)\n         {\n             const auto scale_multiplier = DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale);\n             ++components.whole;\n-            if (components.whole)\n-            {\n-                /// whole keep the sign, fractional should be non-negative\n-                components.fractional = scale_multiplier - components.fractional;\n-            }\n-            else\n+            components.fractional = scale_multiplier - components.fractional;\n+            if (!components.whole)\n             {\n-                /// when whole is zero, fractional should keep the sign\n-                components.fractional = components.fractional - scale_multiplier;\n+                negative_multiplier = -1;\n             }\n         }\n     }\n@@ -969,7 +960,7 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         components.whole = components.whole / common::exp10_i32(scale);\n     }\n \n-    datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(components, scale);\n+    datetime64 = negative_multiplier * DecimalUtils::decimalFromComponents<DateTime64>(components, scale);\n \n     return ReturnType(true);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02313_negative_datetime64.reference b/tests/queries/0_stateless/02313_negative_datetime64.reference\nnew file mode 100644\nindex 000000000000..17474c96202e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02313_negative_datetime64.reference\n@@ -0,0 +1,4 @@\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\ndiff --git a/tests/queries/0_stateless/02313_negative_datetime64.sql b/tests/queries/0_stateless/02313_negative_datetime64.sql\nnew file mode 100644\nindex 000000000000..a5728074cf5c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02313_negative_datetime64.sql\n@@ -0,0 +1,39 @@\n+-- Before UNIX epoch\n+WITH\n+    toDateTime64('1959-09-16 19:20:12.999999998', 9, 'UTC') AS dt1,\n+    toDateTime64('1959-09-16 19:20:12.999999999', 9, 'UTC') AS dt2\n+SELECT\n+        dt1 < dt2,\n+        (dt1 + INTERVAL 1 NANOSECOND) = dt2,\n+        (dt1 + INTERVAL 2 NANOSECOND) > dt2,\n+        (dt1 + INTERVAL 3 NANOSECOND) > dt2;\n+\n+-- At UNIX epoch border\n+WITH\n+    toDateTime64('1969-12-31 23:59:59.999999998', 9, 'UTC') AS dt1,\n+    toDateTime64('1969-12-31 23:59:59.999999999', 9, 'UTC') AS dt2\n+SELECT\n+        dt1 < dt2,\n+        (dt1 + INTERVAL 1 NANOSECOND) = dt2,\n+        (dt1 + INTERVAL 2 NANOSECOND) > dt2,\n+        (dt1 + INTERVAL 3 NANOSECOND) > dt2;\n+\n+-- After UNIX epoch\n+WITH\n+    toDateTime64('2001-12-31 23:59:59.999999998', 9, 'UTC') AS dt1,\n+    toDateTime64('2001-12-31 23:59:59.999999999', 9, 'UTC') AS dt2\n+SELECT\n+        dt1 < dt2,\n+        (dt1 + INTERVAL 1 NANOSECOND) = dt2,\n+        (dt1 + INTERVAL 2 NANOSECOND) > dt2,\n+        (dt1 + INTERVAL 3 NANOSECOND) > dt2;\n+\n+-- At upper DT64 bound (DT64 precision is lower here by design)\n+WITH\n+    toDateTime64('2282-12-31 23:59:59.999998', 6, 'UTC') AS dt1,\n+    toDateTime64('2282-12-31 23:59:59.999999', 6, 'UTC') AS dt2\n+SELECT\n+        dt1 < dt2,\n+        (dt1 + INTERVAL 1 MICROSECOND) = dt2,\n+        (dt1 + INTERVAL 2 MICROSECOND) > dt2,\n+        (dt1 + INTERVAL 3 MICROSECOND) > dt2;\n",
  "problem_statement": "DateTime64 mistreats fractional seconds part of negative timestamp\n`toUnixTimestamp64*()` functions treat milli-, micro- and nanoseconds in a wrong way when timestamp is negative, for example:\r\n\r\n```sql\r\nSELECT toUnixTimestamp64Milli(toDateTime64('1927-01-01 00:00:00', 0, 'Europe/Zurich'))\r\n\r\n\u250c\u2500toUnixTimestamp64Milli(toDateTime64('1927-01-01 00:00:00', 0, 'Europe/Zurich'))\u2500\u2510\r\n\u2502                                                                  -1357002000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT toUnixTimestamp64Milli(toDateTime64('1927-01-01 00:00:00.123', 3, 'Europe/Zurich'))\r\n\r\n\u250c\u2500toUnixTimestamp64Milli(toDateTime64('1927-01-01 00:00:00.123', 3, 'Europe/Zurich'))\u2500\u2510\r\n\u2502                                                                      -1357002000123 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n(In the case above, the first timestamp must be less than the second)\r\n\r\nComparison doesn't work properly either:\r\n\r\n```sql\r\nSELECT toDateTime64('1969-12-12 12:12:12.13', 2) > toDateTime64('1969-12-12 12:12:12.12', 2)\r\n\r\n\u250c\u2500greater(toDateTime64('1969-12-12 12:12:12.13', 2), toDateTime64('1969-12-12 12:12:12.12', 2))\u2500\u2510\r\n\u2502                                                                                             0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT toDateTime64('1979-12-12 12:12:12.13', 2) > toDateTime64('1979-12-12 12:12:12.12', 2)\r\n\r\n\u250c\u2500greater(toDateTime64('1979-12-12 12:12:12.13', 2), toDateTime64('1979-12-12 12:12:12.12', 2))\u2500\u2510\r\n\u2502                                                                                             1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nClickHouse version 22.2.2.1\n",
  "hints_text": "@alexey-milovidov assign this to me please, I'll try to fix it in a while",
  "created_at": "2022-05-31T15:21:53Z",
  "modified_files": [
    "src/IO/ReadHelpers.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02313_negative_datetime64.reference",
    "b/tests/queries/0_stateless/02313_negative_datetime64.sql"
  ]
}