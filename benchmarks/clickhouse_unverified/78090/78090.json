{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78090,
  "instance_id": "ClickHouse__ClickHouse-78090",
  "issue_numbers": [
    "77639"
  ],
  "base_commit": "3efb854fb47b115b2babd66a25ca4054836f409c",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex e353fa3293de..bafc4846c2cb 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -219,6 +219,7 @@\n     M(ExternalJoinUncompressedBytes, \"Amount of data (uncompressed, before compression) written for JOIN in external memory.\", ValueType::Bytes) \\\n     \\\n     M(IcebergPartitionPrunnedFiles, \"Number of skipped files during Iceberg partition pruning\", ValueType::Number) \\\n+    M(IcebergTrivialCountOptimizationApplied, \"Trivial count optimization applied while reading from Iceberg\", ValueType::Number) \\\n     M(JoinBuildTableRowCount, \"Total number of rows in the build table for a JOIN operation.\", ValueType::Number) \\\n     M(JoinProbeTableRowCount, \"Total number of rows in the probe table for a JOIN operation.\", ValueType::Number) \\\n     M(JoinResultRowCount, \"Total number of rows in the result of a JOIN operation.\", ValueType::Number) \\\ndiff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp\nindex 6e612438c556..2255a6ea9a53 100644\n--- a/src/Interpreters/InterpreterDropQuery.cpp\n+++ b/src/Interpreters/InterpreterDropQuery.cpp\n@@ -151,7 +151,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(const ContextPtr & context_, AS\n         const auto & settings = getContext()->getSettingsRef();\n         if (query.if_empty)\n         {\n-            if (auto rows = table->totalRows(settings); rows > 0)\n+            if (auto rows = table->totalRows(getContext()); rows > 0)\n                 throw Exception(ErrorCodes::TABLE_NOT_EMPTY, \"Table {} is not empty\", backQuoteIfNeed(table_id.table_name));\n         }\n         checkStorageSupportsTransactionsIfNeeded(table, context_);\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex a21525b13699..7b21e13aed8e 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -2464,7 +2464,7 @@ std::optional<UInt64> InterpreterSelectQuery::getTrivialCount(UInt64 allow_exper\n         /// require reading some data (but much faster than reading columns).\n         /// Set a special flag in query info so the storage will see it and optimize count in read() method.\n         query_info.optimize_trivial_count = optimize_trivial_count;\n-        return storage->totalRows(settings);\n+        return storage->totalRows(context);\n     }\n \n     // It's possible to optimize count() given only partition predicates\ndiff --git a/src/Interpreters/ServerAsynchronousMetrics.cpp b/src/Interpreters/ServerAsynchronousMetrics.cpp\nindex 17294be81f37..6a92e7f6fb6c 100644\n--- a/src/Interpreters/ServerAsynchronousMetrics.cpp\n+++ b/src/Interpreters/ServerAsynchronousMetrics.cpp\n@@ -327,12 +327,10 @@ void ServerAsynchronousMetrics::updateImpl(TimePoint update_time, TimePoint curr\n \n                 if (MergeTreeData * table_merge_tree = dynamic_cast<MergeTreeData *>(table.get()))\n                 {\n-                    const auto & settings = getContext()->getSettingsRef();\n-\n                     calculateMax(max_part_count_for_partition, table_merge_tree->getMaxPartsCountAndSizeForPartition().first);\n \n-                    size_t bytes = table_merge_tree->totalBytes(settings).value();\n-                    size_t rows = table_merge_tree->totalRows(settings).value();\n+                    size_t bytes = table_merge_tree->totalBytes(getContext()).value();\n+                    size_t rows = table_merge_tree->totalRows(getContext()).value();\n                     size_t parts = table_merge_tree->getActivePartsCount();\n \n                     total_number_of_bytes += bytes;\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 76265b9fc953..4c067872c1de 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -333,7 +333,7 @@ bool applyTrivialCountIfPossible(\n     select_query_info.optimize_trivial_count = true;\n \n     /// Get number of rows\n-    std::optional<UInt64> num_rows = storage->totalRows(settings);\n+    std::optional<UInt64> num_rows = storage->totalRows(query_context);\n     if (!num_rows)\n         return false;\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp b/src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp\nindex 2077fe6104c9..8b327b1ec1a0 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp\n@@ -87,7 +87,7 @@ static std::optional<UInt64> estimateReadRowsCount(QueryPlan::Node & node, bool\n     }\n \n     if (const auto * reading = typeid_cast<const ReadFromMemoryStorageStep *>(step))\n-        return reading->getStorage()->totalRows(Settings{});\n+        return reading->getStorage()->totalRows({});\n \n     if (node.children.size() != 1)\n         return {};\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 460e2323faab..4c607628d2dd 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -657,7 +657,7 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     /// - For total_rows column in system.tables\n     ///\n     /// Does takes underlying Storage (if any) into account.\n-    virtual std::optional<UInt64> totalRows(const Settings &) const { return {}; }\n+    virtual std::optional<UInt64> totalRows(ContextPtr) const { return {}; }\n \n     /// Same as above but also take partition predicate into account.\n     virtual std::optional<UInt64> totalRowsByPartitionPredicate(const ActionsDAG &, ContextPtr) const { return {}; }\n@@ -675,7 +675,7 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     /// Memory part should be estimated as a resident memory size.\n     /// In particular, alloctedBytes() is preferable over bytes()\n     /// when considering in-memory blocks.\n-    virtual std::optional<UInt64> totalBytes(const Settings &) const { return {}; }\n+    virtual std::optional<UInt64> totalBytes(ContextPtr) const { return {}; }\n \n     /// If it is possible to quickly determine exact number of uncompressed bytes for the table on storage:\n     /// - disk (uncompressed)\ndiff --git a/src/Storages/ObjectStorage/DataLakes/DataLakeConfiguration.h b/src/Storages/ObjectStorage/DataLakes/DataLakeConfiguration.h\nindex 395d690cb2dc..7c1d82a2a10b 100644\n--- a/src/Storages/ObjectStorage/DataLakes/DataLakeConfiguration.h\n+++ b/src/Storages/ObjectStorage/DataLakes/DataLakeConfiguration.h\n@@ -17,7 +17,6 @@\n \n #include <memory>\n #include <string>\n-#include <unordered_map>\n \n #include <Common/ErrorCodes.h>\n \n@@ -89,6 +88,15 @@ class DataLakeConfiguration : public BaseStorageConfiguration, public std::enabl\n         BaseStorageConfiguration::setPaths(current_metadata->makePartitionPruning(filter_dag));\n     }\n \n+\n+    std::optional<size_t> totalRows() override\n+    {\n+        if (!current_metadata)\n+            return {};\n+\n+        return current_metadata->totalRows();\n+    }\n+\n     std::shared_ptr<NamesAndTypesList> getInitialSchemaByPath(const String & data_path) const override\n     {\n         if (!current_metadata)\ndiff --git a/src/Storages/ObjectStorage/DataLakes/IDataLakeMetadata.h b/src/Storages/ObjectStorage/DataLakes/IDataLakeMetadata.h\nindex 4160220a4679..f2110c7a7b2e 100644\n--- a/src/Storages/ObjectStorage/DataLakes/IDataLakeMetadata.h\n+++ b/src/Storages/ObjectStorage/DataLakes/IDataLakeMetadata.h\n@@ -50,6 +50,8 @@ class IDataLakeMetadata : boost::noncopyable\n     /// Whether schema evolution is supported.\n     virtual bool supportsExternalMetadataChange() const { return false; }\n \n+    virtual std::optional<size_t> totalRows() const { return {}; }\n+    virtual std::optional<size_t> totalBytes() const { return {}; }\n protected:\n     [[noreturn]] void throwNotImplemented(std::string_view method) const\n     {\ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.cpp b/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.cpp\nindex cde44bc0e1df..e5f45afc3530 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.cpp\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.cpp\n@@ -24,10 +24,10 @@\n #include <Common/logger_useful.h>\n #include <Common/ProfileEvents.h>\n \n-\n namespace ProfileEvents\n {\n     extern const Event IcebergPartitionPrunnedFiles;\n+    extern const Event IcebergTrivialCountOptimizationApplied;\n }\n \n namespace DB\n@@ -347,10 +347,24 @@ void IcebergMetadata::updateSnapshot()\n                     \"No manifest list found for snapshot id `{}` for iceberg table `{}`\",\n                     relevant_snapshot_id,\n                     configuration_ptr->getPath());\n+            std::optional<size_t> total_rows;\n+            std::optional<size_t> total_bytes;\n+\n+            if (snapshot->has(\"summary\"))\n+            {\n+                auto summary_object = snapshot->get(\"summary\").extract<Poco::JSON::Object::Ptr>();\n+                if (summary_object->has(\"total-records\"))\n+                    total_rows = summary_object->getValue<Int64>(\"total-records\");\n+\n+                if (summary_object->has(\"total-files-size\"))\n+                    total_bytes = summary_object->getValue<Int64>(\"total-files-size\");\n+            }\n+\n             relevant_snapshot = IcebergSnapshot{\n                 getManifestList(getProperFilePathFromMetadataInfo(\n                     snapshot->getValue<String>(MANIFEST_LIST_PATH_FIELD), configuration_ptr->getPath(), table_location)),\n-                relevant_snapshot_id};\n+                relevant_snapshot_id, total_rows, total_bytes};\n+\n             if (!snapshot->has(\"schema-id\"))\n                 throw Exception(\n                     ErrorCodes::ICEBERG_SPECIFICATION_VIOLATION,\n@@ -592,6 +606,69 @@ Strings IcebergMetadata::makePartitionPruning(const ActionsDAG & filter_dag)\n     }\n     return getDataFilesImpl(&filter_dag);\n }\n+\n+std::optional<size_t> IcebergMetadata::totalRows() const\n+{\n+    auto configuration_ptr = configuration.lock();\n+    if (!configuration_ptr)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Configuration is expired\");\n+\n+    if (!relevant_snapshot)\n+    {\n+        ProfileEvents::increment(ProfileEvents::IcebergTrivialCountOptimizationApplied);\n+        return 0;\n+    }\n+\n+    /// All these \"hints\" with total rows or bytes are optional both in\n+    /// metadata files and in manifest files, so we try all of them one by one\n+    if (relevant_snapshot->total_rows.has_value())\n+    {\n+        ProfileEvents::increment(ProfileEvents::IcebergTrivialCountOptimizationApplied);\n+        return relevant_snapshot->total_rows;\n+    }\n+\n+    Int64 result = 0;\n+    for (const auto & manifest_list_entry : *(relevant_snapshot->manifest_list))\n+    {\n+        auto count = manifest_list_entry->getRowsCountInAllDataFilesExcludingDeleted();\n+        if (!count.has_value())\n+            return {};\n+\n+        result += count.value();\n+    }\n+\n+    ProfileEvents::increment(ProfileEvents::IcebergTrivialCountOptimizationApplied);\n+    return result;\n+}\n+\n+\n+std::optional<size_t> IcebergMetadata::totalBytes() const\n+{\n+    auto configuration_ptr = configuration.lock();\n+    if (!configuration_ptr)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Configuration is expired\");\n+\n+    if (!relevant_snapshot)\n+        return 0;\n+\n+    /// All these \"hints\" with total rows or bytes are optional both in\n+    /// metadata files and in manifest files, so we try all of them one by one\n+    if (relevant_snapshot->total_bytes.has_value())\n+        return relevant_snapshot->total_bytes;\n+\n+    Int64 result = 0;\n+    for (const auto & manifest_list_entry : *(relevant_snapshot->manifest_list))\n+    {\n+        auto count = manifest_list_entry->getBytesCountInAllDataFiles();\n+        if (!count.has_value())\n+            return {};\n+\n+        result += count.value();\n+    }\n+\n+    return result;\n+}\n+\n }\n \n #endif\ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h b/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h\nindex 9d954c53d3e7..0826b86ca035 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h\n@@ -63,7 +63,6 @@ class IcebergMetadata : public IDataLakeMetadata, private WithContext\n         const ConfigurationObserverPtr & configuration,\n         const ContextPtr & local_context);\n \n-\n     std::shared_ptr<NamesAndTypesList> getInitialSchemaByPath(const String & data_path) const override\n     {\n         auto version_if_outdated = getSchemaVersionByFileIfOutdated(data_path);\n@@ -91,6 +90,9 @@ class IcebergMetadata : public IDataLakeMetadata, private WithContext\n \n     bool supportsPartitionPruning() override { return true; }\n \n+    std::optional<size_t> totalRows() const override;\n+    std::optional<size_t> totalBytes() const override;\n+\n private:\n     using ManifestEntryByDataFile = std::unordered_map<String, Iceberg::ManifestFilePtr>;\n     using ManifestFilesStorage = std::unordered_map<String, Iceberg::ManifestFilePtr>;\ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.cpp b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.cpp\nindex 19e6cbb49f0d..b9a968f06db6 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.cpp\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.cpp\n@@ -11,6 +11,7 @@\n #include <Parsers/ASTFunction.h>\n #include <Common/quoteString.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <Common/logger_useful.h>\n \n namespace DB::ErrorCodes\n {\n@@ -30,6 +31,12 @@ constexpr const char * SUBCOLUMN_FILE_PATH_NAME = \"data_file.file_path\";\n constexpr const char * SUBCOLUMN_CONTENT_NAME = \"data_file.content\";\n constexpr const char * SUBCOLUMN_PARTITION_NAME = \"data_file.partition\";\n \n+constexpr const char * SUBCOLUMN_VALUES_COUNT_NAME = \"data_file.value_counts\";\n+constexpr const char * SUBCOLUMN_COLUMN_SIZES_NAME = \"data_file.column_sizes\";\n+constexpr const char * SUBCOLUMN_NULL_VALUE_COUNTS_NAME = \"data_file.null_value_counts\";\n+constexpr const char * SUBCOLUMN_LOWER_BOUNDS_NAME = \"data_file.lower_bounds\";\n+constexpr const char * SUBCOLUMN_UPPER_BOUNDS_NAME = \"data_file.upper_bounds\";\n+\n \n const std::vector<ManifestFileEntry> & ManifestFileContent::getFiles() const\n {\n@@ -136,6 +143,46 @@ ManifestFileContent::ManifestFileContent(\n         for (const auto & value : tuple)\n             partition_key_value.emplace_back(value);\n \n+        std::unordered_map<Int32, ColumnInfo> columns_infos;\n+\n+        for (const auto & path : {SUBCOLUMN_VALUES_COUNT_NAME, SUBCOLUMN_COLUMN_SIZES_NAME, SUBCOLUMN_NULL_VALUE_COUNTS_NAME})\n+        {\n+            if (manifest_file_deserializer.hasPath(path))\n+            {\n+                Field values_count = manifest_file_deserializer.getValueFromRowByName(i, path);\n+                for (const auto & column_stats : values_count.safeGet<Array>())\n+                {\n+                    const auto & column_number_and_count = column_stats.safeGet<Tuple>();\n+                    Int32 number = column_number_and_count[0].safeGet<Int32>();\n+                    Int64 count = column_number_and_count[1].safeGet<Int64>();\n+                    if (path == SUBCOLUMN_VALUES_COUNT_NAME)\n+                        columns_infos[number].rows_count = count;\n+                    else if (path == SUBCOLUMN_COLUMN_SIZES_NAME)\n+                        columns_infos[number].bytes_size = count;\n+                    else\n+                        columns_infos[number].nulls_count = count;\n+                }\n+            }\n+        }\n+\n+        for (const auto & path : {SUBCOLUMN_LOWER_BOUNDS_NAME, SUBCOLUMN_UPPER_BOUNDS_NAME})\n+        {\n+            if (manifest_file_deserializer.hasPath(path))\n+            {\n+                Field bounds = manifest_file_deserializer.getValueFromRowByName(i, path);\n+                for (const auto & column_stats : bounds.safeGet<Array>())\n+                {\n+                    const auto & column_number_and_bound = column_stats.safeGet<Tuple>();\n+                    Int32 number = column_number_and_bound[0].safeGet<Int32>();\n+                    const Field & bound_value = column_number_and_bound[1];\n+                    if (path == SUBCOLUMN_LOWER_BOUNDS_NAME)\n+                        columns_infos[number].lower_bound = bound_value;\n+                    else\n+                        columns_infos[number].upper_bound = bound_value;\n+                }\n+            }\n+        }\n+\n         FileEntry file = FileEntry{DataFileEntry{file_path}};\n \n         Int64 added_sequence_number = 0;\n@@ -162,7 +209,7 @@ ManifestFileContent::ManifestFileContent(\n                     break;\n             }\n         }\n-        this->files.emplace_back(status, added_sequence_number, file, partition_key_value);\n+        this->files.emplace_back(status, added_sequence_number, file, partition_key_value, columns_infos);\n     }\n }\n \n@@ -183,6 +230,54 @@ const std::vector<Int32> & ManifestFileContent::getPartitionKeyColumnIDs() const\n     return partition_column_ids;\n }\n \n+std::optional<Int64> ManifestFileContent::getRowsCountInAllDataFilesExcludingDeleted() const\n+{\n+    Int64 result = 0;\n+    for (const auto & file : files)\n+    {\n+        /// Have at least one column with rows count\n+        bool found = false;\n+        for (const auto & [column, column_info] : file.columns_infos)\n+        {\n+            if (column_info.rows_count.has_value())\n+            {\n+                if (file.status != ManifestEntryStatus::DELETED)\n+                    result += *column_info.rows_count;\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found)\n+            return std::nullopt;\n+    }\n+    return result;\n+}\n+\n+std::optional<Int64> ManifestFileContent::getBytesCountInAllDataFiles() const\n+{\n+    Int64 result = 0;\n+    for (const auto & file : files)\n+    {\n+        /// Have at least one column with bytes count\n+        bool found = false;\n+        for (const auto & [column, column_info] : file.columns_infos)\n+        {\n+            if (column_info.bytes_size.has_value())\n+            {\n+                result += *column_info.bytes_size;\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found)\n+            return std::nullopt;\n+    }\n+    return result;\n+\n+}\n+\n }\n \n #endif\ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.h b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.h\nindex ceb677a597a4..46d4fae5bc77 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.h\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.h\n@@ -36,6 +36,15 @@ struct DataFileEntry\n     String file_name;\n };\n \n+struct ColumnInfo\n+{\n+    std::optional<Int64> rows_count;\n+    std::optional<Int64> bytes_size;\n+    std::optional<Int64> nulls_count;\n+    std::optional<DB::Field> lower_bound;\n+    std::optional<DB::Field> upper_bound;\n+};\n+\n using FileEntry = std::variant<DataFileEntry>; // In the future we will add PositionalDeleteFileEntry and EqualityDeleteFileEntry here\n \n /// Description of Data file in manifest file\n@@ -46,6 +55,7 @@ struct ManifestFileEntry\n \n     FileEntry file;\n     DB::Row partition_key_value;\n+    std::unordered_map<Int32, ColumnInfo> columns_infos;\n };\n \n /**\n@@ -93,6 +103,11 @@ class ManifestFileContent\n     bool hasPartitionKey() const;\n     const DB::KeyDescription & getPartitionKeyDescription() const;\n     const std::vector<Int32> & getPartitionKeyColumnIDs() const;\n+\n+    /// Fields with rows count in manifest files are optional\n+    /// they can be absent.\n+    std::optional<Int64> getRowsCountInAllDataFilesExcludingDeleted() const;\n+    std::optional<Int64> getBytesCountInAllDataFiles() const;\n private:\n \n     Int32 schema_id;\ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/Snapshot.h b/src/Storages/ObjectStorage/DataLakes/Iceberg/Snapshot.h\nindex 355ed135574b..21fc25063bc0 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/Snapshot.h\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/Snapshot.h\n@@ -15,6 +15,8 @@ struct IcebergSnapshot\n {\n     ManifestListPtr manifest_list;\n     Int64 snapshot_id;\n+    std::optional<size_t> total_rows;\n+    std::optional<size_t> total_bytes;\n };\n }\n \ndiff --git a/src/Storages/ObjectStorage/StorageObjectStorage.cpp b/src/Storages/ObjectStorage/StorageObjectStorage.cpp\nindex 229a6e47b545..aa0ab6dd2c67 100644\n--- a/src/Storages/ObjectStorage/StorageObjectStorage.cpp\n+++ b/src/Storages/ObjectStorage/StorageObjectStorage.cpp\n@@ -202,6 +202,18 @@ void StorageObjectStorage::updateExternalDynamicMetadata(ContextPtr context_ptr)\n     setInMemoryMetadata(metadata);\n }\n \n+std::optional<UInt64> StorageObjectStorage::totalRows(ContextPtr query_context) const\n+{\n+    configuration->update(object_storage, query_context);\n+    return configuration->totalRows();\n+}\n+\n+std::optional<UInt64> StorageObjectStorage::totalBytes(ContextPtr query_context) const\n+{\n+    configuration->update(object_storage, query_context);\n+    return configuration->totalBytes();\n+}\n+\n namespace\n {\n class ReadFromObjectStorageStep : public SourceStepWithFilter\n@@ -674,4 +686,5 @@ void StorageObjectStorage::Configuration::assertInitialized() const\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Configuration was not initialized before usage\");\n     }\n }\n+\n }\ndiff --git a/src/Storages/ObjectStorage/StorageObjectStorage.h b/src/Storages/ObjectStorage/StorageObjectStorage.h\nindex 440774d30d5c..0fbeb2df431b 100644\n--- a/src/Storages/ObjectStorage/StorageObjectStorage.h\n+++ b/src/Storages/ObjectStorage/StorageObjectStorage.h\n@@ -139,6 +139,8 @@ class StorageObjectStorage : public IStorage\n \n     void updateExternalDynamicMetadata(ContextPtr) override;\n \n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n protected:\n     String getPathSample(ContextPtr context);\n \n@@ -222,6 +224,9 @@ class StorageObjectStorage::Configuration\n \n     virtual void implementPartitionPruning(const ActionsDAG &) { }\n \n+    virtual std::optional<size_t> totalRows() { return {}; }\n+    virtual std::optional<size_t> totalBytes() { return {}; }\n+\n     virtual bool hasExternalDynamicMetadata() { return false; }\n \n     virtual std::shared_ptr<NamesAndTypesList> getInitialSchemaByPath(const String&) const { return {}; }\ndiff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\nindex 4477716054a2..6a2df5ae5897 100644\n--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n@@ -824,9 +824,9 @@ Chunk StorageEmbeddedRocksDB::getBySerializedKeys(\n     return Chunk(std::move(columns), num_rows);\n }\n \n-std::optional<UInt64> StorageEmbeddedRocksDB::totalRows(const Settings & query_settings) const\n+std::optional<UInt64> StorageEmbeddedRocksDB::totalRows(ContextPtr query_context) const\n {\n-    if (!query_settings[Setting::optimize_trivial_approximate_count_query])\n+    if (!query_context->getSettingsRef()[Setting::optimize_trivial_approximate_count_query])\n         return {};\n     std::shared_lock lock(rocksdb_ptr_mx);\n     if (!rocksdb_ptr)\n@@ -837,7 +837,7 @@ std::optional<UInt64> StorageEmbeddedRocksDB::totalRows(const Settings & query_s\n     return estimated_rows;\n }\n \n-std::optional<UInt64> StorageEmbeddedRocksDB::totalBytes(const Settings & /*settings*/) const\n+std::optional<UInt64> StorageEmbeddedRocksDB::totalBytes(ContextPtr) const\n {\n     std::shared_lock lock(rocksdb_ptr_mx);\n     if (!rocksdb_ptr)\ndiff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\nindex 5b2cef648e40..51a6e907b7d6 100644\n--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\n+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\n@@ -102,9 +102,9 @@ class StorageEmbeddedRocksDB final : public IStorage, public IKeyValueEntity, Wi\n     /// To turn on the optimization optimize_trivial_approximate_count_query=1 should be set for a query.\n     bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n \n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n     void checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const override;\n \ndiff --git a/src/Storages/StorageBuffer.cpp b/src/Storages/StorageBuffer.cpp\nindex 56c921198f0f..96446dbff03a 100644\n--- a/src/Storages/StorageBuffer.cpp\n+++ b/src/Storages/StorageBuffer.cpp\n@@ -1167,16 +1167,16 @@ void StorageBuffer::checkAlterIsPossible(const AlterCommands & commands, Context\n     }\n }\n \n-std::optional<UInt64> StorageBuffer::totalRows(const Settings & settings) const\n+std::optional<UInt64> StorageBuffer::totalRows(ContextPtr query_context) const\n {\n     std::optional<UInt64> underlying_rows;\n     if (auto destination = getDestinationTable())\n-        underlying_rows = destination->totalRows(settings);\n+        underlying_rows = destination->totalRows(query_context);\n \n     return total_writes.rows + underlying_rows.value_or(0);\n }\n \n-std::optional<UInt64> StorageBuffer::totalBytes(const Settings & /*settings*/) const\n+std::optional<UInt64> StorageBuffer::totalBytes(ContextPtr) const\n {\n     return total_writes.bytes;\n }\ndiff --git a/src/Storages/StorageBuffer.h b/src/Storages/StorageBuffer.h\nindex 3341271db4a5..d68fb1ee1a95 100644\n--- a/src/Storages/StorageBuffer.h\n+++ b/src/Storages/StorageBuffer.h\n@@ -116,8 +116,8 @@ friend class BufferSink;\n     /// The structure of the subordinate table is not checked and does not change.\n     void alter(const AlterCommands & params, ContextPtr context, AlterLockHolder & table_lock_holder) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n     std::optional<UInt64> lifetimeRows() const override { return lifetime_writes.rows; }\n     std::optional<UInt64> lifetimeBytes() const override { return lifetime_writes.bytes; }\ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex ca4b7206755d..5934b7875418 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -1513,7 +1513,7 @@ Cluster::Addresses StorageDistributed::parseAddresses(const std::string & name)\n     return addresses;\n }\n \n-std::optional<UInt64> StorageDistributed::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageDistributed::totalBytes(ContextPtr) const\n {\n     UInt64 total_bytes = 0;\n     for (const auto & status : getDirectoryQueueStatuses())\n@@ -1837,7 +1837,7 @@ void StorageDistributed::delayInsertOrThrowIfNeeded() const\n         !(*distributed_settings)[DistributedSetting::bytes_to_delay_insert])\n         return;\n \n-    UInt64 total_bytes = *totalBytes(getContext()->getSettingsRef());\n+    UInt64 total_bytes = *totalBytes(getContext());\n \n     if ((*distributed_settings)[DistributedSetting::bytes_to_throw_insert] && total_bytes > (*distributed_settings)[DistributedSetting::bytes_to_throw_insert])\n     {\n@@ -1858,12 +1858,12 @@ void StorageDistributed::delayInsertOrThrowIfNeeded() const\n         do {\n             delayed_ms += step_ms;\n             std::this_thread::sleep_for(std::chrono::milliseconds(step_ms));\n-        } while (*totalBytes(getContext()->getSettingsRef()) > (*distributed_settings)[DistributedSetting::bytes_to_delay_insert] && delayed_ms < (*distributed_settings)[DistributedSetting::max_delay_to_insert]*1000);\n+        } while (*totalBytes(getContext()) > (*distributed_settings)[DistributedSetting::bytes_to_delay_insert] && delayed_ms < (*distributed_settings)[DistributedSetting::max_delay_to_insert]*1000);\n \n         ProfileEvents::increment(ProfileEvents::DistributedDelayedInserts);\n         ProfileEvents::increment(ProfileEvents::DistributedDelayedInsertsMilliseconds, delayed_ms);\n \n-        UInt64 new_total_bytes = *totalBytes(getContext()->getSettingsRef());\n+        UInt64 new_total_bytes = *totalBytes(getContext());\n         LOG_INFO(log, \"Too many bytes pending for async INSERT: was {}, now {}, INSERT was delayed to {} ms\",\n             formatReadableSizeWithBinarySuffix(total_bytes),\n             formatReadableSizeWithBinarySuffix(new_total_bytes),\ndiff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h\nindex 8bdd5be837f8..58a683e1dee3 100644\n--- a/src/Storages/StorageDistributed.h\n+++ b/src/Storages/StorageDistributed.h\n@@ -109,7 +109,7 @@ class StorageDistributed final : public IStorage, WithContext\n         size_t /*num_streams*/) override;\n \n     bool supportsParallelInsert() const override { return true; }\n-    std::optional<UInt64> totalBytes(const Settings &) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr) const override;\n \n     SinkToStoragePtr write(const ASTPtr & query, const StorageMetadataPtr & /*metadata_snapshot*/, ContextPtr context, bool /*async_insert*/) override;\n \ndiff --git a/src/Storages/StorageJoin.cpp b/src/Storages/StorageJoin.cpp\nindex ba59b06df53e..5eea4c9ef019 100644\n--- a/src/Storages/StorageJoin.cpp\n+++ b/src/Storages/StorageJoin.cpp\n@@ -338,14 +338,16 @@ size_t StorageJoin::getSize(ContextPtr context) const\n     return join->getTotalRowCount();\n }\n \n-std::optional<UInt64> StorageJoin::totalRows(const Settings &settings) const\n+std::optional<UInt64> StorageJoin::totalRows(ContextPtr query_context) const\n {\n+    const auto & settings = query_context->getSettingsRef();\n     TableLockHolder holder = tryLockTimed(rwlock, RWLockImpl::Read, RWLockImpl::NO_QUERY, settings[Setting::lock_acquire_timeout]);\n     return join->getTotalRowCount();\n }\n \n-std::optional<UInt64> StorageJoin::totalBytes(const Settings &settings) const\n+std::optional<UInt64> StorageJoin::totalBytes(ContextPtr query_context) const\n {\n+    const auto & settings = query_context->getSettingsRef();\n     TableLockHolder holder = tryLockTimed(rwlock, RWLockImpl::Read, RWLockImpl::NO_QUERY, settings[Setting::lock_acquire_timeout]);\n     return join->getTotalByteCount();\n }\ndiff --git a/src/Storages/StorageJoin.h b/src/Storages/StorageJoin.h\nindex dd8ef97f8cc5..dab7a21605bc 100644\n--- a/src/Storages/StorageJoin.h\n+++ b/src/Storages/StorageJoin.h\n@@ -83,8 +83,8 @@ class StorageJoin final : public StorageSetOrJoinBase\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n     Block getRightSampleBlock() const\n     {\ndiff --git a/src/Storages/StorageLog.cpp b/src/Storages/StorageLog.cpp\nindex 468856938423..5a3247a63c1e 100644\n--- a/src/Storages/StorageLog.cpp\n+++ b/src/Storages/StorageLog.cpp\n@@ -987,7 +987,7 @@ void StorageLog::updateTotalRows(const WriteLock &)\n         total_rows = 0;\n }\n \n-std::optional<UInt64> StorageLog::totalRows(const Settings &) const\n+std::optional<UInt64> StorageLog::totalRows(ContextPtr) const\n {\n     if (use_marks_file && marks_loaded)\n         return total_rows;\n@@ -998,7 +998,7 @@ std::optional<UInt64> StorageLog::totalRows(const Settings &) const\n     return {};\n }\n \n-std::optional<UInt64> StorageLog::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageLog::totalBytes(ContextPtr) const\n {\n     return total_bytes;\n }\ndiff --git a/src/Storages/StorageLog.h b/src/Storages/StorageLog.h\nindex 882e9cfaa75b..71dd78543d20 100644\n--- a/src/Storages/StorageLog.h\n+++ b/src/Storages/StorageLog.h\n@@ -69,8 +69,8 @@ class StorageLog final : public IStorage, public WithMutableContext\n     bool supportsSubcolumns() const override { return true; }\n     ColumnSizeByName getColumnSizes() const override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr) const override;\n \n     void backupData(BackupEntriesCollector & backup_entries_collector, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\n     void restoreDataFromBackup(RestorerFromBackup & restorer, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex d44220c0b018..87066b47bad3 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -854,22 +854,22 @@ bool StorageMaterializedView::supportsBackupPartition() const\n     return false;\n }\n \n-std::optional<UInt64> StorageMaterializedView::totalRows(const Settings & settings) const\n+std::optional<UInt64> StorageMaterializedView::totalRows(ContextPtr query_context) const\n {\n     if (hasInnerTable())\n     {\n         if (auto table = tryGetTargetTable())\n-            return table->totalRows(settings);\n+            return table->totalRows(query_context);\n     }\n     return {};\n }\n \n-std::optional<UInt64> StorageMaterializedView::totalBytes(const Settings & settings) const\n+std::optional<UInt64> StorageMaterializedView::totalBytes(ContextPtr query_context) const\n {\n     if (hasInnerTable())\n     {\n         if (auto table = tryGetTargetTable())\n-            return table->totalBytes(settings);\n+            return table->totalBytes(query_context);\n     }\n     return {};\n }\ndiff --git a/src/Storages/StorageMaterializedView.h b/src/Storages/StorageMaterializedView.h\nindex a2df36cbb049..5aa5785ac9af 100644\n--- a/src/Storages/StorageMaterializedView.h\n+++ b/src/Storages/StorageMaterializedView.h\n@@ -101,8 +101,8 @@ class StorageMaterializedView final : public IStorage, WithMutableContext\n     void restoreDataFromBackup(RestorerFromBackup & restorer, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\n     bool supportsBackupPartition() const override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n     std::optional<UInt64> totalBytesUncompressed(const Settings & settings) const override;\n \n private:\ndiff --git a/src/Storages/StorageMemory.cpp b/src/Storages/StorageMemory.cpp\nindex da7fb483ef24..2980c7a82156 100644\n--- a/src/Storages/StorageMemory.cpp\n+++ b/src/Storages/StorageMemory.cpp\n@@ -612,14 +612,14 @@ void StorageMemory::checkAlterIsPossible(const AlterCommands & commands, Context\n     }\n }\n \n-std::optional<UInt64> StorageMemory::totalRows(const Settings &) const\n+std::optional<UInt64> StorageMemory::totalRows(ContextPtr) const\n {\n     /// All modifications of these counters are done under mutex which automatically guarantees synchronization/consistency\n     /// When run concurrently we are fine with any value: \"before\" or \"after\"\n     return total_size_rows.load(std::memory_order_relaxed);\n }\n \n-std::optional<UInt64> StorageMemory::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageMemory::totalBytes(ContextPtr) const\n {\n     return total_size_bytes.load(std::memory_order_relaxed);\n }\ndiff --git a/src/Storages/StorageMemory.h b/src/Storages/StorageMemory.h\nindex 07cf86a29737..6b2ae22c8728 100644\n--- a/src/Storages/StorageMemory.h\n+++ b/src/Storages/StorageMemory.h\n@@ -86,8 +86,8 @@ friend class MemorySink;\n     void checkAlterIsPossible(const AlterCommands & commands, ContextPtr local_context) const override;\n     void alter(const AlterCommands & params, ContextPtr context, AlterLockHolder & alter_lock_holder) override;\n \n-    std::optional<UInt64> totalRows(const Settings &) const override;\n-    std::optional<UInt64> totalBytes(const Settings &) const override;\n+    std::optional<UInt64> totalRows(ContextPtr) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr) const override;\n \n     /** Delays initialization of StorageMemory::read() until the first read is actually happen.\n       * Usually, fore code like this:\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 61b8b9f6fd1f..43ce52156040 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -1656,14 +1656,14 @@ bool StorageMerge::supportsTrivialCountOptimization(const StorageSnapshotPtr &,\n     return getFirstTable([&](const auto & table) { return !table->supportsTrivialCountOptimization(nullptr, ctx); }) == nullptr;\n }\n \n-std::optional<UInt64> StorageMerge::totalRows(const Settings & settings) const\n+std::optional<UInt64> StorageMerge::totalRows(ContextPtr query_context) const\n {\n-    return totalRowsOrBytes([&](const auto & table) { return table->totalRows(settings); });\n+    return totalRowsOrBytes([&](const auto & table) { return table->totalRows(query_context); });\n }\n \n-std::optional<UInt64> StorageMerge::totalBytes(const Settings & settings) const\n+std::optional<UInt64> StorageMerge::totalBytes(ContextPtr query_context) const\n {\n-    return totalRowsOrBytes([&](const auto & table) { return table->totalBytes(settings); });\n+    return totalRowsOrBytes([&](const auto & table) { return table->totalBytes(query_context); });\n }\n \n template <typename F>\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 7a8f11204e22..562b3e981e2b 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -81,8 +81,8 @@ class StorageMerge final : public IStorage, WithContext\n \n     bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n     using DatabaseTablesIterators = std::vector<DatabaseTablesIteratorPtr>;\n     DatabaseTablesIterators getDatabaseIterators(ContextPtr context) const;\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex d0cddc609a1a..9cf9f7aaa5dd 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -311,7 +311,7 @@ void StorageMergeTree::read(\n         query_plan = std::move(*plan);\n }\n \n-std::optional<UInt64> StorageMergeTree::totalRows(const Settings &) const\n+std::optional<UInt64> StorageMergeTree::totalRows(ContextPtr) const\n {\n     return getTotalActiveSizeInRows();\n }\n@@ -322,7 +322,7 @@ std::optional<UInt64> StorageMergeTree::totalRowsByPartitionPredicate(const Acti\n     return totalRowsByPartitionPredicateImpl(filter_actions_dag, local_context, parts);\n }\n \n-std::optional<UInt64> StorageMergeTree::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageMergeTree::totalBytes(ContextPtr) const\n {\n     return getTotalActiveSizeInBytes();\n }\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex eed6d1945acd..e0f512b54f9d 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -64,9 +64,9 @@ class StorageMergeTree final : public MergeTreeData\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    std::optional<UInt64> totalRows(const Settings &) const override;\n+    std::optional<UInt64> totalRows(ContextPtr) const override;\n     std::optional<UInt64> totalRowsByPartitionPredicate(const ActionsDAG & filter_actions_dag, ContextPtr) const override;\n-    std::optional<UInt64> totalBytes(const Settings &) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr) const override;\n     std::optional<UInt64> totalBytesUncompressed(const Settings &) const override;\n \n     UInt64 getNumberOnFlyDataMutations() const override;\ndiff --git a/src/Storages/StorageNull.h b/src/Storages/StorageNull.h\nindex 74abf931f8f1..5507b183a834 100644\n--- a/src/Storages/StorageNull.h\n+++ b/src/Storages/StorageNull.h\n@@ -59,11 +59,11 @@ class StorageNull final : public IStorage\n \n     void alter(const AlterCommands & params, ContextPtr context, AlterLockHolder & table_lock_holder) override;\n \n-    std::optional<UInt64> totalRows(const Settings &) const override\n+    std::optional<UInt64> totalRows(ContextPtr) const override\n     {\n         return {0};\n     }\n-    std::optional<UInt64> totalBytes(const Settings &) const override\n+    std::optional<UInt64> totalBytes(ContextPtr) const override\n     {\n         return {0};\n     }\ndiff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h\nindex 5cd86f7ad2c1..ee68b4d4be05 100644\n--- a/src/Storages/StorageProxy.h\n+++ b/src/Storages/StorageProxy.h\n@@ -155,8 +155,8 @@ class StorageProxy : public IStorage\n     bool storesDataOnDisk() const override { return getNested()->storesDataOnDisk(); }\n     Strings getDataPaths() const override { return getNested()->getDataPaths(); }\n     StoragePolicyPtr getStoragePolicy() const override { return getNested()->getStoragePolicy(); }\n-    std::optional<UInt64> totalRows(const Settings & settings) const override { return getNested()->totalRows(settings); }\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override { return getNested()->totalBytes(settings); }\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override { return getNested()->totalRows(query_context); }\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override { return getNested()->totalBytes(query_context); }\n     std::optional<UInt64> lifetimeRows() const override { return getNested()->lifetimeRows(); }\n     std::optional<UInt64> lifetimeBytes() const override { return getNested()->lifetimeBytes(); }\n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 26b1decbcc66..5b1dcee1092e 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -5903,8 +5903,9 @@ void StorageReplicatedMergeTree::foreachActiveParts(Func && func, bool select_se\n     }\n }\n \n-std::optional<UInt64> StorageReplicatedMergeTree::totalRows(const Settings & settings) const\n+std::optional<UInt64> StorageReplicatedMergeTree::totalRows(ContextPtr query_context) const\n {\n+    const auto & settings = query_context->getSettingsRef();\n     UInt64 res = 0;\n     foreachActiveParts([&res](auto & part) { res += part->rows_count; }, settings[Setting::select_sequential_consistency]);\n     return res;\n@@ -5917,8 +5918,9 @@ std::optional<UInt64> StorageReplicatedMergeTree::totalRowsByPartitionPredicate(\n     return totalRowsByPartitionPredicateImpl(filter_actions_dag, local_context, parts);\n }\n \n-std::optional<UInt64> StorageReplicatedMergeTree::totalBytes(const Settings & settings) const\n+std::optional<UInt64> StorageReplicatedMergeTree::totalBytes(ContextPtr query_context) const\n {\n+    const auto & settings = query_context->getSettingsRef();\n     UInt64 res = 0;\n     foreachActiveParts([&res](auto & part) { res += part->getBytesOnDisk(); }, settings[Setting::select_sequential_consistency]);\n     return res;\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex e09f0cd373f2..14f3f4127d07 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -163,9 +163,9 @@ class StorageReplicatedMergeTree final : public MergeTreeData\n         size_t max_block_size,\n         size_t num_streams) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n     std::optional<UInt64> totalRowsByPartitionPredicate(const ActionsDAG & filter_actions_dag, ContextPtr context) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n     std::optional<UInt64> totalBytesUncompressed(const Settings & settings) const override;\n \n     UInt64 getNumberOnFlyDataMutations() const override;\ndiff --git a/src/Storages/StorageSet.cpp b/src/Storages/StorageSet.cpp\nindex 498b09fd490c..e10bd2b5717c 100644\n--- a/src/Storages/StorageSet.cpp\n+++ b/src/Storages/StorageSet.cpp\n@@ -213,7 +213,7 @@ size_t StorageSet::getSize(ContextPtr) const\n     return current_set->getTotalRowCount();\n }\n \n-std::optional<UInt64> StorageSet::totalRows(const Settings &) const\n+std::optional<UInt64> StorageSet::totalRows(ContextPtr) const\n {\n     SetPtr current_set;\n     {\n@@ -223,7 +223,7 @@ std::optional<UInt64> StorageSet::totalRows(const Settings &) const\n     return current_set->getTotalRowCount();\n }\n \n-std::optional<UInt64> StorageSet::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageSet::totalBytes(ContextPtr) const\n {\n     SetPtr current_set;\n     {\ndiff --git a/src/Storages/StorageSet.h b/src/Storages/StorageSet.h\nindex 5b6d899b48db..fb4cc81ffb5e 100644\n--- a/src/Storages/StorageSet.h\n+++ b/src/Storages/StorageSet.h\n@@ -82,8 +82,8 @@ class StorageSet final : public StorageSetOrJoinBase\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr & metadata_snapshot, ContextPtr, TableExclusiveLockHolder &) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n private:\n     /// Allows to concurrently truncate the set and work (read/fill) the existing set.\ndiff --git a/src/Storages/StorageStripeLog.cpp b/src/Storages/StorageStripeLog.cpp\nindex 0db0f67084fc..522833f1f848 100644\n--- a/src/Storages/StorageStripeLog.cpp\n+++ b/src/Storages/StorageStripeLog.cpp\n@@ -538,7 +538,7 @@ void StorageStripeLog::updateTotalRows(const WriteLock &)\n     total_rows = new_total_rows;\n }\n \n-std::optional<UInt64> StorageStripeLog::totalRows(const Settings &) const\n+std::optional<UInt64> StorageStripeLog::totalRows(ContextPtr) const\n {\n     if (indices_loaded)\n         return total_rows;\n@@ -549,7 +549,7 @@ std::optional<UInt64> StorageStripeLog::totalRows(const Settings &) const\n     return {};\n }\n \n-std::optional<UInt64> StorageStripeLog::totalBytes(const Settings &) const\n+std::optional<UInt64> StorageStripeLog::totalBytes(ContextPtr) const\n {\n     return total_bytes;\n }\ndiff --git a/src/Storages/StorageStripeLog.h b/src/Storages/StorageStripeLog.h\nindex dc2f8d8be4a1..66a686670187 100644\n--- a/src/Storages/StorageStripeLog.h\n+++ b/src/Storages/StorageStripeLog.h\n@@ -61,8 +61,8 @@ friend class StripeLogSink;\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr &, ContextPtr, TableExclusiveLockHolder&) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n \n     void backupData(BackupEntriesCollector & backup_entries_collector, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\n     void restoreDataFromBackup(RestorerFromBackup & restorer, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\ndiff --git a/src/Storages/StorageTimeSeries.cpp b/src/Storages/StorageTimeSeries.cpp\nindex b5b0f2fdb952..9ed782a96e11 100644\n--- a/src/Storages/StorageTimeSeries.cpp\n+++ b/src/Storages/StorageTimeSeries.cpp\n@@ -255,7 +255,7 @@ StoragePtr StorageTimeSeries::tryGetTargetTable(ViewTarget::Kind target_kind, co\n }\n \n \n-std::optional<UInt64> StorageTimeSeries::totalRows(const Settings & settings) const\n+std::optional<UInt64> StorageTimeSeries::totalRows(ContextPtr query_context) const\n {\n     UInt64 total_rows = 0;\n     if (has_inner_tables)\n@@ -268,7 +268,7 @@ std::optional<UInt64> StorageTimeSeries::totalRows(const Settings & settings) co\n                 if (!inner_table)\n                     return std::nullopt;\n \n-                auto total_rows_in_inner_table = inner_table->totalRows(settings);\n+                auto total_rows_in_inner_table = inner_table->totalRows(query_context);\n                 if (!total_rows_in_inner_table)\n                     return std::nullopt;\n \n@@ -279,7 +279,7 @@ std::optional<UInt64> StorageTimeSeries::totalRows(const Settings & settings) co\n     return total_rows;\n }\n \n-std::optional<UInt64> StorageTimeSeries::totalBytes(const Settings & settings) const\n+std::optional<UInt64> StorageTimeSeries::totalBytes(ContextPtr query_context) const\n {\n     UInt64 total_bytes = 0;\n     if (has_inner_tables)\n@@ -292,7 +292,7 @@ std::optional<UInt64> StorageTimeSeries::totalBytes(const Settings & settings) c\n                 if (!inner_table)\n                     return std::nullopt;\n \n-                auto total_bytes_in_inner_table = inner_table->totalBytes(settings);\n+                auto total_bytes_in_inner_table = inner_table->totalBytes(query_context);\n                 if (!total_bytes_in_inner_table)\n                     return std::nullopt;\n \ndiff --git a/src/Storages/StorageTimeSeries.h b/src/Storages/StorageTimeSeries.h\nindex 263b2c42bc2e..444f27cdd014 100644\n--- a/src/Storages/StorageTimeSeries.h\n+++ b/src/Storages/StorageTimeSeries.h\n@@ -85,8 +85,8 @@ class StorageTimeSeries final : public IStorage, WithContext\n     void backupData(BackupEntriesCollector & backup_entries_collector, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\n     void restoreDataFromBackup(RestorerFromBackup & restorer, const String & data_path_in_backup, const std::optional<ASTs> & partitions) override;\n \n-    std::optional<UInt64> totalRows(const Settings & settings) const override;\n-    std::optional<UInt64> totalBytes(const Settings & settings) const override;\n+    std::optional<UInt64> totalRows(ContextPtr query_context) const override;\n+    std::optional<UInt64> totalBytes(ContextPtr query_context) const override;\n     std::optional<UInt64> totalBytesUncompressed(const Settings & settings) const override;\n     Strings getDataPaths() const override;\n \ndiff --git a/src/Storages/System/StorageSystemTables.cpp b/src/Storages/System/StorageSystemTables.cpp\nindex 47327ea2dda1..b747019a8959 100644\n--- a/src/Storages/System/StorageSystemTables.cpp\n+++ b/src/Storages/System/StorageSystemTables.cpp\n@@ -377,7 +377,6 @@ class TablesBlockSource : public ISource\n                         if (columns_mask[src_index++])\n                             res_columns[res_index++]->insert(table.second->getName());\n \n-                        const auto & settings = context->getSettingsRef();\n                         while (src_index < columns_mask.size())\n                         {\n                             // total_rows\n@@ -390,7 +389,7 @@ class TablesBlockSource : public ISource\n                             {\n                                 try\n                                 {\n-                                    if (auto total_rows = table.second->totalRows(settings))\n+                                    if (auto total_rows = table.second->totalRows(context))\n                                         res_columns[res_index++]->insert(*total_rows);\n                                     else\n                                         res_columns[res_index++]->insertDefault();\n@@ -407,7 +406,7 @@ class TablesBlockSource : public ISource\n                             {\n                                 try\n                                 {\n-                                    if (auto total_bytes = table.second->totalBytes(settings))\n+                                    if (auto total_bytes = table.second->totalBytes(context))\n                                         res_columns[res_index++]->insert(*total_bytes);\n                                     else\n                                         res_columns[res_index++]->insertDefault();\n@@ -633,13 +632,16 @@ class TablesBlockSource : public ISource\n                         res_columns[res_index++]->insertDefault();\n                 }\n \n-                auto settings = context->getSettingsRef();\n-                settings[Setting::select_sequential_consistency] = 0;\n+                ContextMutablePtr context_copy = Context::createCopy(context);\n+                Settings settings_copy = context_copy->getSettingsCopy();\n+                settings_copy[Setting::select_sequential_consistency] = 0;\n+                context_copy->setSettings(settings_copy);\n+\n                 if (columns_mask[src_index++])\n                 {\n                     try\n                     {\n-                        auto total_rows = table ? table->totalRows(settings) : std::nullopt;\n+                        auto total_rows = table ? table->totalRows(context) : std::nullopt;\n                         if (total_rows)\n                             res_columns[res_index++]->insert(*total_rows);\n                         else\n@@ -657,7 +659,7 @@ class TablesBlockSource : public ISource\n                 {\n                     try\n                     {\n-                        auto total_bytes = table->totalBytes(settings);\n+                        auto total_bytes = table->totalBytes(context_copy);\n                         if (total_bytes)\n                             res_columns[res_index++]->insert(*total_bytes);\n                         else\n@@ -675,7 +677,7 @@ class TablesBlockSource : public ISource\n                 {\n                     try\n                     {\n-                        auto total_bytes_uncompressed = table->totalBytesUncompressed(settings);\n+                        auto total_bytes_uncompressed = table->totalBytesUncompressed(context_copy->getSettingsRef());\n                         if (total_bytes_uncompressed)\n                             res_columns[res_index++]->insert(*total_bytes_uncompressed);\n                         else\n",
  "test_patch": "diff --git a/tests/integration/test_storage_iceberg/test.py b/tests/integration/test_storage_iceberg/test.py\nindex 7a59fec585a3..bc4348609a3a 100644\n--- a/tests/integration/test_storage_iceberg/test.py\n+++ b/tests/integration/test_storage_iceberg/test.py\n@@ -669,7 +669,11 @@ def test_delete_files(started_cluster, format_version, storage_type):\n     )\n     create_iceberg_table(storage_type, instance, TABLE_NAME, started_cluster)\n \n-    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\")) == 100\n+    # Test trivial count with deleted files\n+    query_id = \"test_trivial_count_\" + get_uuid_str()\n+    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\", query_id=query_id)) == 100\n+    instance.query(\"SYSTEM FLUSH LOGS\")\n+    assert instance.query(f\"SELECT ProfileEvents['IcebergTrivialCountOptimizationApplied'] FROM system.query_log where query_id = '{query_id}' and type = 'QueryFinish'\") == \"1\\n\"\n \n     spark.sql(f\"DELETE FROM {TABLE_NAME} WHERE a >= 0\")\n     default_upload_directory(\n@@ -679,7 +683,11 @@ def test_delete_files(started_cluster, format_version, storage_type):\n         \"\",\n     )\n \n-    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\")) == 0\n+    query_id = \"test_trivial_count_\" + get_uuid_str()\n+    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\", query_id=query_id)) == 0\n+\n+    instance.query(\"SYSTEM FLUSH LOGS\")\n+    assert instance.query(f\"SELECT ProfileEvents['IcebergTrivialCountOptimizationApplied'] FROM system.query_log where query_id = '{query_id}' and type = 'QueryFinish'\") == \"1\\n\"\n \n     write_iceberg_from_df(\n         spark,\n@@ -696,7 +704,11 @@ def test_delete_files(started_cluster, format_version, storage_type):\n         \"\",\n     )\n \n-    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\")) == 100\n+    query_id = \"test_trivial_count_\" + get_uuid_str()\n+    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\", query_id=query_id)) == 100\n+\n+    instance.query(\"SYSTEM FLUSH LOGS\")\n+    assert instance.query(f\"SELECT ProfileEvents['IcebergTrivialCountOptimizationApplied'] FROM system.query_log where query_id = '{query_id}' and type = 'QueryFinish'\") == \"1\\n\"\n \n     spark.sql(f\"DELETE FROM {TABLE_NAME} WHERE a >= 150\")\n     default_upload_directory(\n@@ -706,7 +718,11 @@ def test_delete_files(started_cluster, format_version, storage_type):\n         \"\",\n     )\n \n-    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\")) == 50\n+    query_id = \"test_trivial_count_\" + get_uuid_str()\n+    assert int(instance.query(f\"SELECT count() FROM {TABLE_NAME}\", query_id=query_id)) == 50\n+\n+    instance.query(\"SYSTEM FLUSH LOGS\")\n+    assert instance.query(f\"SELECT ProfileEvents['IcebergTrivialCountOptimizationApplied'] FROM system.query_log where query_id = '{query_id}' and type = 'QueryFinish'\") == \"1\\n\"\n \n \n @pytest.mark.parametrize(\"format_version\", [\"1\", \"2\"])\n",
  "problem_statement": "Support Trivial Count Optimization for Iceberg\nInformation about each column size is stored in Manifests List file. We can reuse to implement trivial count optimization: https://iceberg.apache.org/spec/#manifests.\n\n![Image](https://github.com/user-attachments/assets/663cd2f1-4ca8-4bb9-b9c7-362e861ba7b8) \n",
  "hints_text": "",
  "created_at": "2025-03-21T15:57:45Z",
  "modified_files": [
    "src/Common/ProfileEvents.cpp",
    "src/Interpreters/InterpreterDropQuery.cpp",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/ServerAsynchronousMetrics.cpp",
    "src/Planner/PlannerJoinTree.cpp",
    "src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp",
    "src/Storages/IStorage.h",
    "src/Storages/ObjectStorage/DataLakes/DataLakeConfiguration.h",
    "src/Storages/ObjectStorage/DataLakes/IDataLakeMetadata.h",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.cpp",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.cpp",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFile.h",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/Snapshot.h",
    "src/Storages/ObjectStorage/StorageObjectStorage.cpp",
    "src/Storages/ObjectStorage/StorageObjectStorage.h",
    "src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp",
    "src/Storages/RocksDB/StorageEmbeddedRocksDB.h",
    "src/Storages/StorageBuffer.cpp",
    "src/Storages/StorageBuffer.h",
    "src/Storages/StorageDistributed.cpp",
    "src/Storages/StorageDistributed.h",
    "src/Storages/StorageJoin.cpp",
    "src/Storages/StorageJoin.h",
    "src/Storages/StorageLog.cpp",
    "src/Storages/StorageLog.h",
    "src/Storages/StorageMaterializedView.cpp",
    "src/Storages/StorageMaterializedView.h",
    "src/Storages/StorageMemory.cpp",
    "src/Storages/StorageMemory.h",
    "src/Storages/StorageMerge.cpp",
    "src/Storages/StorageMerge.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageMergeTree.h",
    "src/Storages/StorageNull.h",
    "src/Storages/StorageProxy.h",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h",
    "src/Storages/StorageSet.cpp",
    "src/Storages/StorageSet.h",
    "src/Storages/StorageStripeLog.cpp",
    "src/Storages/StorageStripeLog.h",
    "src/Storages/StorageTimeSeries.cpp",
    "src/Storages/StorageTimeSeries.h",
    "src/Storages/System/StorageSystemTables.cpp"
  ],
  "modified_test_files": [
    "tests/integration/test_storage_iceberg/test.py"
  ]
}