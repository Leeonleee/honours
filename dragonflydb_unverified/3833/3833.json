{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3833,
  "instance_id": "dragonflydb__dragonfly-3833",
  "issue_numbers": [
    "3822"
  ],
  "base_commit": "14c94e41d78c03c49e5144df60b056f35a00f2cc",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex b3f76cb6a49e..1e5aa0bcdbcb 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -138,39 +138,74 @@ inline void FreeObjZset(unsigned encoding, void* ptr) {\n   }\n }\n \n+pair<void*, bool> DefragStrMap2(StringMap* sm, float ratio) {\n+  bool realloced = false;\n+\n+  for (auto it = sm->begin(); it != sm->end(); ++it)\n+    realloced |= it.ReallocIfNeeded(ratio);\n+\n+  return {sm, realloced};\n+}\n+\n+pair<void*, bool> DefragListPack(uint8_t* lp, float ratio) {\n+  if (!zmalloc_page_is_underutilized(lp, ratio))\n+    return {lp, false};\n+\n+  size_t lp_bytes = lpBytes(lp);\n+  uint8_t* replacement = lpNew(lpBytes(lp));\n+  memcpy(replacement, lp, lp_bytes);\n+  lpFree(lp);\n+\n+  return {replacement, true};\n+}\n+\n+pair<void*, bool> DefragIntSet(intset* is, float ratio) {\n+  if (!zmalloc_page_is_underutilized(is, ratio))\n+    return {is, false};\n+\n+  const size_t blob_len = intsetBlobLen(is);\n+  intset* replacement = (intset*)zmalloc(blob_len);\n+  memcpy(replacement, is, blob_len);\n+\n+  zfree(is);\n+  return {replacement, true};\n+}\n+\n // Iterates over allocations of internal hash data structures and re-allocates\n // them if their pages are underutilized.\n // Returns pointer to new object ptr and whether any re-allocations happened.\n-pair<void*, bool> DefragHash(MemoryResource* mr, unsigned encoding, void* ptr, float ratio) {\n+pair<void*, bool> DefragHash(unsigned encoding, void* ptr, float ratio) {\n   switch (encoding) {\n     // Listpack is stored as a single contiguous array\n     case kEncodingListPack: {\n-      uint8_t* lp = (uint8_t*)ptr;\n-      if (!zmalloc_page_is_underutilized(lp, ratio))\n-        return {lp, false};\n-\n-      size_t lp_bytes = lpBytes(lp);\n-      uint8_t* replacement = lpNew(lpBytes(lp));\n-      memcpy(replacement, lp, lp_bytes);\n-      lpFree(lp);\n-\n-      return {replacement, true};\n-    };\n+      return DefragListPack((uint8_t*)ptr, ratio);\n+    }\n \n     // StringMap supports re-allocation of it's internal nodes\n     case kEncodingStrMap2: {\n-      bool realloced = false;\n+      return DefragStrMap2((StringMap*)ptr, ratio);\n+    }\n \n-      StringMap* sm = (StringMap*)ptr;\n-      for (auto it = sm->begin(); it != sm->end(); ++it)\n-        realloced |= it.ReallocIfNeeded(ratio);\n+    default:\n+      ABSL_UNREACHABLE();\n+  }\n+}\n+\n+pair<void*, bool> DefragSet(unsigned encoding, void* ptr, float ratio) {\n+  switch (encoding) {\n+    // Int sets have flat storage\n+    case kEncodingIntSet: {\n+      return DefragIntSet((intset*)ptr, ratio);\n+    }\n \n-      return {sm, realloced};\n+    // StringMap supports re-allocation of it's internal nodes\n+    case kEncodingStrMap2: {\n+      return DefragStrMap2((StringMap*)ptr, ratio);\n     }\n \n     default:\n       ABSL_UNREACHABLE();\n-  };\n+  }\n }\n \n inline void FreeObjStream(void* ptr) {\n@@ -391,7 +426,11 @@ bool RobjWrapper::DefragIfNeeded(float ratio) {\n       return true;\n     }\n   } else if (type() == OBJ_HASH) {\n-    auto [new_ptr, realloced] = DefragHash(tl.local_mr, encoding_, inner_obj_, ratio);\n+    auto [new_ptr, realloced] = DefragHash(encoding_, inner_obj_, ratio);\n+    inner_obj_ = new_ptr;\n+    return realloced;\n+  } else if (type() == OBJ_SET) {\n+    auto [new_ptr, realloced] = DefragSet(encoding_, inner_obj_, ratio);\n     inner_obj_ = new_ptr;\n     return realloced;\n   }\n",
  "test_patch": "diff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex d9750bf531a7..33381bc26413 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -9,6 +9,10 @@\n #include \"facade/facade_test.h\"\n #include \"server/command_registry.h\"\n #include \"server/test_utils.h\"\n+extern \"C\" {\n+#include \"redis/intset.h\"\n+#include \"redis/zmalloc.h\"\n+}\n \n using namespace testing;\n using namespace std;\n@@ -349,4 +353,29 @@ TEST_F(SetFamilyTest, SScan) {\n   EXPECT_THAT(vec.size(), 0);\n }\n \n+TEST_F(SetFamilyTest, IntSetMemcpy) {\n+  // This logic is used in CompactObject::DefragIntSet\n+  intset* original = intsetNew();\n+  uint8_t success = 0;\n+  for (int i = 0; i < 250; ++i) {\n+    original = intsetAdd(original, i, &success);\n+    ASSERT_THAT(success, 1);\n+  }\n+  const size_t blob_len = intsetBlobLen(original);\n+  intset* replacement = (intset*)zmalloc(blob_len);\n+  memcpy(replacement, original, blob_len);\n+\n+  ASSERT_THAT(original->encoding, replacement->encoding);\n+  ASSERT_THAT(original->length, replacement->length);\n+\n+  for (int i = 0; i < 250; ++i) {\n+    int64_t value;\n+    ASSERT_THAT(intsetGet(replacement, i, &value), 1);\n+    ASSERT_THAT(value, i);\n+  }\n+\n+  zfree(original);\n+  zfree(replacement);\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Implement defragmentation for OBJ_ZSET and OBJ_SET\nToday we support defrag only for OBJ_STRING and OBJ_HASH see RobjWrapper::DefragIfNeeded\r\nWe want to add support for OBJ_ZSET and OBJ_SET\r\n\r\n- [x] Defrag for ZSet\r\n- [ ] Defrag for Set\r\n\n",
  "hints_text": "",
  "created_at": "2024-09-30T13:57:32Z",
  "modified_files": [
    "src/core/compact_object.cc"
  ],
  "modified_test_files": [
    "src/server/set_family_test.cc"
  ]
}