{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1065,
  "instance_id": "dragonflydb__dragonfly-1065",
  "issue_numbers": [
    "853",
    "811"
  ],
  "base_commit": "a12ddfe108b72a134128d8060b95daa4aed78a30",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex b83d025356d8..82ec6b5809e1 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -10,6 +10,7 @@ extern \"C\" {\n \n #include <absl/strings/match.h>\n #include <absl/strings/str_join.h>\n+#include <absl/strings/str_split.h>\n \n #include <jsoncons/json.hpp>\n #include <jsoncons_ext/jsonpatch/jsonpatch.hpp>\n@@ -35,14 +36,14 @@ using OptLong = optional<long>;\n using OptSizeT = optional<size_t>;\n using OptString = optional<string>;\n using JsonReplaceCb = function<void(const string&, JsonType&)>;\n-using JsonReplaceVerify = std::function<OpStatus()>;\n+using JsonReplaceVerify = std::function<OpStatus(JsonType&)>;\n using CI = CommandId;\n \n static const char DefaultJsonPath[] = \"$\";\n \n namespace {\n \n-inline OpStatus JsonReplaceVerifyNoOp() {\n+inline OpStatus JsonReplaceVerifyNoOp(JsonType&) {\n   return OpStatus::OK;\n }\n \n@@ -148,7 +149,7 @@ OpStatus UpdateEntry(const OpArgs& op_args, std::string_view key, std::string_vi\n   }\n \n   // Make sure that we don't have other internal issue with the operation\n-  OpStatus res = verify_op();\n+  OpStatus res = verify_op(json_entry);\n   if (res == OpStatus::OK) {\n     db_slice.PostUpdate(db_index, entry_it, key);\n   }\n@@ -280,6 +281,39 @@ string ConvertToJsonPointer(string_view json_path) {\n   return result;\n }\n \n+string ConvertExpressionToJsonPointer(string_view json_path) {\n+  if (json_path.empty() || !absl::StartsWith(json_path, \"$.\")) {\n+    VLOG(1) << \"retrieved malformed JSON path expression: \" << json_path;\n+    return {};\n+  }\n+\n+  // remove prefix\n+  json_path.remove_prefix(2);\n+\n+  std::string pointer;\n+  vector<string> splitted = absl::StrSplit(json_path, '.');\n+  for (auto& it : splitted) {\n+    if (it.front() == '[' && it.back() == ']') {\n+      std::string index = it.substr(1, it.size() - 2);\n+      if (index.empty()) {\n+        return {};\n+      }\n+\n+      for (char ch : index) {\n+        if (!std::isdigit(ch)) {\n+          return {};\n+        }\n+      }\n+\n+      pointer += '/' + index;\n+    } else {\n+      pointer += '/' + it;\n+    }\n+  }\n+\n+  return pointer;\n+}\n+\n size_t CountJsonFields(const JsonType& j) {\n   size_t res = 0;\n   json_type type = j.type();\n@@ -487,7 +521,7 @@ OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, stri\n     }\n   };\n \n-  auto verifier = [&is_result_overflow]() {\n+  auto verifier = [&is_result_overflow](JsonType&) {\n     if (is_result_overflow) {\n       return OpStatus::INVALID_NUMERIC_RESULT;\n     }\n@@ -964,7 +998,7 @@ OpResult<vector<JsonType>> OpResp(const OpArgs& op_args, string_view key,\n \n // Returns boolean that represents the result of the operation.\n OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n-                     std::string_view json_str) {\n+                     std::string_view json_str, bool is_nx_condition, bool is_xx_condition) {\n   std::optional<JsonType> parsed_json = JsonFromString(json_str);\n   if (!parsed_json) {\n     LOG(WARNING) << \"got invalid JSON string '\" << json_str << \"' cannot be saved\";\n@@ -976,6 +1010,19 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   // this is regardless of the current key type. In redis if the key exists\n   // and its not JSON, it would return an error.\n   if (path == \".\" || path == \"$\") {\n+    if (is_nx_condition || is_xx_condition) {\n+      OpResult<PrimeIterator> it_res =\n+          op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_JSON);\n+      bool key_exists = (it_res.status() != OpStatus::KEY_NOTFOUND);\n+      if (is_nx_condition && key_exists) {\n+        return false;\n+      }\n+\n+      if (is_xx_condition && !key_exists) {\n+        return false;\n+      }\n+    }\n+\n     SetJson(op_args, key, std::move(parsed_json.value()));\n     return true;\n   }\n@@ -986,17 +1033,46 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   // an array that this expression will match each entry in it\n   // then the assign here is called N times, where N == array.size().\n   bool path_exists = false;\n+  bool operation_result = false;\n   const JsonType& new_json = parsed_json.value();\n   auto cb = [&](const string& path, JsonType& val) {\n     path_exists = true;\n-    val = new_json;\n+    if (!is_nx_condition) {\n+      operation_result = true;\n+      val = new_json;\n+    }\n   };\n \n-  OpStatus status = UpdateEntry(op_args, key, path, cb);\n+  auto inserter = [&](JsonType& json) {\n+    // Set a new value if the path doesn't exist and the nx condition is not set.\n+    if (!path_exists && !is_xx_condition) {\n+      string pointer = ConvertExpressionToJsonPointer(path);\n+      if (pointer.empty()) {\n+        VLOG(1) << \"Failed to convert the following expression path to a valid JSON pointer: \"\n+                << path;\n+        return OpStatus::SYNTAX_ERR;\n+      }\n+\n+      error_code ec;\n+      jsonpointer::add(json, pointer, new_json, ec);\n+      if (ec) {\n+        VLOG(1) << \"Failed to add a JSON value to the following path: \" << path\n+                << \" with the error: \" << ec.message();\n+        return OpStatus::SYNTAX_ERR;\n+      }\n+\n+      operation_result = true;\n+    }\n+\n+    return OpStatus::OK;\n+  };\n+\n+  OpStatus status = UpdateEntry(op_args, key, path, cb, inserter);\n   if (status != OpStatus::OK) {\n     return status;\n   }\n-  return path_exists;\n+\n+  return operation_result;\n }\n \n }  // namespace\n@@ -1005,9 +1081,23 @@ void JsonFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   string_view path = ArgS(args, 1);\n   string_view json_str = ArgS(args, 2);\n+  bool is_nx_condition = false;\n+  bool is_xx_condition = false;\n+  string_view operation_opts;\n+  if (args.size() > 3) {\n+    operation_opts = ArgS(args, 3);\n+    if (absl::EqualsIgnoreCase(operation_opts, \"NX\")) {\n+      is_nx_condition = true;\n+    } else if (absl::EqualsIgnoreCase(operation_opts, \"XX\")) {\n+      is_xx_condition = true;\n+    } else {\n+      (*cntx)->SendError(kSyntaxErr);\n+      return;\n+    }\n+  }\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpSet(t->GetOpArgs(shard), key, path, json_str);\n+    return OpSet(t->GetOpArgs(shard), key, path, json_str, is_nx_condition, is_xx_condition);\n   };\n \n   Transaction* trans = cntx->transaction;\n@@ -1707,7 +1797,7 @@ void JsonFamily::Register(CommandRegistry* registry) {\n   *registry << CI{\"JSON.ARRINDEX\", CO::READONLY | CO::FAST, -4, 1, 1, 1}.HFUNC(ArrIndex);\n   *registry << CI{\"JSON.DEBUG\", CO::READONLY | CO::FAST, -2, 1, 1, 1}.HFUNC(Debug);\n   *registry << CI{\"JSON.RESP\", CO::READONLY | CO::FAST, -2, 1, 1, 1}.HFUNC(Resp);\n-  *registry << CI{\"JSON.SET\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(Set);\n+  *registry << CI{\"JSON.SET\", CO::WRITE | CO::DENYOOM | CO::FAST, -4, 1, 1, 1}.HFUNC(Set);\n }\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex b3e97c7e5c36..b55710f478a2 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -981,6 +981,28 @@ TEST_F(JsonFamilyTest, Set) {\n \n   resp = Run({\"JSON.GET\", \"json2\", \"$\"});\n   EXPECT_EQ(resp, R\"([{\"a\":[0,0,0,0,0]}])\");\n+\n+  json = R\"(\n+    {\"a\": 2}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$\", json});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.b\", \"8\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.c\", \"[1,2,3]\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.z\", \"3\", \"XX\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.b\", \"4\", \"NX\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.GET\", \"json3\", \"$\"});\n+  EXPECT_EQ(resp, R\"([{\"a\":2,\"b\":8,\"c\":[1,2,3]}])\");\n }\n \n }  // namespace dfly\n",
  "problem_statement": "JSON.SET doesn't add a key\n(Please comply with JSON.SET NX | XX options when fixing)\r\n\r\nJSON.SET doc $ '{\"a\":2}'\r\nOK\r\n\r\nJSON.SET doc $.b '8'\r\nEXPECTED: OK\r\nGOT: (nil)\r\n\r\nJSON.GET doc $\r\nEXPECTED: \"[{\\\"a\\\":2,\\\"b\\\":8}]\"\r\nGOT: \"[{\\\"a\\\":2}]\"\njson type not support root path as '.' , so some tools or code may throw error\n`W20230214 08:41:52.302026    11 json_family.cc:1611] path '.': Invalid JSONPath syntax: Expected '$' or function expression`\r\n\r\n![image](https://user-images.githubusercontent.com/8407297/219262407-9924d889-b033-4bd8-98bb-56a02cd198dd.png)\r\n\n",
  "hints_text": "\nCan you please provide the full redis-cli command that triggers this error?\n\nOn Thu, Feb 16, 2023, 05:43 liuzhuoling ***@***.***> wrote:\n\n> W20230214 08:41:52.302026 11 json_family.cc:1611] path '.': Invalid\n> JSONPath syntax: Expected '$' or function expression\n>\n> [image: image]\n> <https://user-images.githubusercontent.com/8407297/219262407-9924d889-b033-4bd8-98bb-56a02cd198dd.png>\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dragonflydb/dragonfly/issues/811>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AA4BFCHMK44DCTGZQXIQW7LWXWO4VANCNFSM6AAAAAAU5UMG2Q>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n\nThe tool is [RedisInsight](https://github.com/RedisInsight/RedisInsight)\r\n\r\nHere is the code:\r\n![image](https://user-images.githubusercontent.com/8407297/219265478-241dccf3-4590-4596-8dd5-c13591b768a1.png)\r\n\n1. The current implementation of `json.get `gets two required arguments `key` and `path`. I suggest adding the `path` argument to be an optional argument and in case it's not supplied the code should query the root key.\r\n2.  `.foo `is not valid enhanced path syntax which is explained here: https://goessner.net/articles/JsonPath/ the syntax that you used is called restricted path syntax and it's not supported by the JSON library that the code is using.\r\n\n@iko1 Thanks for your kind help\r\n1. for redisinsight tool, I find it use 'json.debug memory' command but dragonfly not have, so throw error\r\n2. for jsonpath style, maybe I need change my habits, lol\n@romange Hi, I find the reason why redisinsight cant work\r\n1. [JSON.SET](https://redis.io/commands/json.set/) key path value [NX | XX]   `current version not support [NX | XX] params`\r\n2. [JSON.DEBUG MEMORY](https://redis.io/commands/json.debug-memory/) key [path]     `current version not support memory params`",
  "created_at": "2023-04-10T12:00:29Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}