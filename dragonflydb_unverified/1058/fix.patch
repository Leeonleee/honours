diff --git a/src/server/command_registry.h b/src/server/command_registry.h
index 25c32d7a35cc..6bc1ac7f7c0d 100644
--- a/src/server/command_registry.h
+++ b/src/server/command_registry.h
@@ -22,7 +22,7 @@ enum CommandOpt : uint32_t {
   READONLY = 1U << 0,
   FAST = 1U << 1,
   WRITE = 1U << 2,
-  LOADING = 1U << 3,
+  LOADING = 1U << 3,  // Command allowed during LOADING state.
   DENYOOM = 1U << 4,  // use-memory in redis.
   REVERSE_MAPPING = 1U << 5,
 
diff --git a/src/server/generic_family.cc b/src/server/generic_family.cc
index 501ca59942ce..a7dcc4d195a9 100644
--- a/src/server/generic_family.cc
+++ b/src/server/generic_family.cc
@@ -1442,7 +1442,7 @@ void GenericFamily::Register(CommandRegistry* registry) {
   constexpr auto kSelectOpts = CO::LOADING | CO::FAST | CO::NOSCRIPT;
 
   *registry << CI{"DEL", CO::WRITE, -2, 1, -1, 1}.HFUNC(Del)
-            /* Redis compaitibility:
+            /* Redis compatibility:
              * We don't allow PING during loading since in Redis PING is used as
              * failure detection, and a loading server is considered to be
              * not available. */
diff --git a/src/server/rdb_save.cc b/src/server/rdb_save.cc
index 43f7d61fb733..d2c89486a7c9 100644
--- a/src/server/rdb_save.cc
+++ b/src/server/rdb_save.cc
@@ -1032,7 +1032,7 @@ error_code RdbSaver::Impl::ConsumeChannel(const Cancellation* cll) {
     pushed_bytes += ptr->channel_bytes();
   }
 
-  DCHECK(!channel_.TryPop(*record));
+  DCHECK(!record.has_value() || !channel_.TryPop(*record));
 
   VLOG(1) << "Channel pulled bytes: " << channel_bytes << " pushed bytes: " << pushed_bytes;
 
diff --git a/src/server/replica.cc b/src/server/replica.cc
index 842f5ce66a2c..3765a44224f4 100644
--- a/src/server/replica.cc
+++ b/src/server/replica.cc
@@ -150,55 +150,55 @@ Replica::~Replica() {
 
 static const char kConnErr[] = "could not connect to master: ";
 
-bool Replica::Start(ConnectionContext* cntx) {
+error_code Replica::Start(ConnectionContext* cntx) {
   VLOG(1) << "Starting replication";
   ProactorBase* mythread = ProactorBase::me();
   CHECK(mythread);
 
+  RETURN_ON_ERR(cntx_.SwitchErrorHandler(absl::bind_front(&Replica::DefaultErrorHandler, this)));
+
+  auto check_connection_error = [this, &cntx](const error_code& ec, const char* msg) -> error_code {
+    if (cntx_.IsCancelled()) {
+      (*cntx)->SendError("replication cancelled");
+      return std::make_error_code(errc::operation_canceled);
+    }
+    if (ec) {
+      (*cntx)->SendError(absl::StrCat(msg, ec.message()));
+      cntx_.Cancel();
+      return ec;
+    }
+    return {};
+  };
+
   // 1. Resolve dns.
   VLOG(1) << "Resolving master DNS";
   error_code ec = ResolveMasterDns();
-  if (ec) {
-    (*cntx)->SendError(StrCat("could not resolve master dns", ec.message()));
-    return false;
-  }
+  RETURN_ON_ERR(check_connection_error(ec, "could not resolve master dns"));
+
   // 2. Connect socket.
   VLOG(1) << "Connecting to master";
   ec = ConnectAndAuth(absl::GetFlag(FLAGS_master_connect_timeout_ms) * 1ms);
-  if (ec) {
-    (*cntx)->SendError(StrCat(kConnErr, ec.message()));
-    return false;
-  }
+  RETURN_ON_ERR(check_connection_error(ec, kConnErr));
 
   // 3. Greet.
   VLOG(1) << "Greeting";
-  state_mask_ = R_ENABLED | R_TCP_CONNECTED;
+  state_mask_.store(R_ENABLED | R_TCP_CONNECTED);
   last_io_time_ = mythread->GetMonotonicTimeNs();
   ec = Greet();
-  if (ec) {
-    (*cntx)->SendError(StrCat("could not greet master ", ec.message()));
-    return false;
-  }
-
-  // 4. Init basic context.
-  cntx_.Reset(absl::bind_front(&Replica::DefaultErrorHandler, this));
+  RETURN_ON_ERR(check_connection_error(ec, "could not greet master "));
 
-  // 5. Spawn main coordination fiber.
+  // 4. Spawn main coordination fiber.
   sync_fb_ = MakeFiber(&Replica::MainReplicationFb, this);
 
   (*cntx)->SendOk();
-  return true;
-}
+  return {};
+}  // namespace dfly
 
 void Replica::Stop() {
   VLOG(1) << "Stopping replication";
-  // Mark disabled, prevent from retrying.
-  if (sock_) {
-    sock_->proactor()->Await([this] {
-      state_mask_ = 0;  // Specifically ~R_ENABLED.
-      cntx_.Cancel();   // Context is fully resposible for cleanup.
-    });
-  }
+  // Stops the loop in MainReplicationFb.
+  state_mask_.store(0);  // Specifically ~R_ENABLED.
+  cntx_.Cancel();        // Context is fully resposible for cleanup.
 
   // Make sure the replica fully stopped and did all cleanup,
   // so we can freely release resources (connections).
@@ -217,11 +217,11 @@ void Replica::MainReplicationFb() {
   SetShardStates(true);
 
   error_code ec;
-  while (state_mask_ & R_ENABLED) {
+  while (state_mask_.load() & R_ENABLED) {
     // Discard all previous errors and set default error handler.
     cntx_.Reset(absl::bind_front(&Replica::DefaultErrorHandler, this));
     // 1. Connect socket.
-    if ((state_mask_ & R_TCP_CONNECTED) == 0) {
+    if ((state_mask_.load() & R_TCP_CONNECTED) == 0) {
       ThisFiber::SleepFor(500ms);
       if (is_paused_)
         continue;
@@ -239,22 +239,25 @@ void Replica::MainReplicationFb() {
         continue;
       }
       VLOG(1) << "Replica socket connected";
-      state_mask_ |= R_TCP_CONNECTED;
+      state_mask_.fetch_or(R_TCP_CONNECTED);
+      continue;
     }
 
     // 2. Greet.
-    if ((state_mask_ & R_GREETED) == 0) {
+    if ((state_mask_.load() & R_GREETED) == 0) {
       ec = Greet();
       if (ec) {
         LOG(INFO) << "Error greeting " << master_context_.Description() << " " << ec << " "
                   << ec.message();
-        state_mask_ &= R_ENABLED;
+        state_mask_.fetch_and(R_ENABLED);
         continue;
       }
+      state_mask_.fetch_or(R_GREETED);
+      continue;
     }
 
     // 3. Initiate full sync
-    if ((state_mask_ & R_SYNC_OK) == 0) {
+    if ((state_mask_.load() & R_SYNC_OK) == 0) {
       if (HasDflyMaster())
         ec = InitiateDflySync();
       else
@@ -263,14 +266,15 @@ void Replica::MainReplicationFb() {
       if (ec) {
         LOG(WARNING) << "Error syncing with " << master_context_.Description() << " " << ec << " "
                      << ec.message();
-        state_mask_ &= R_ENABLED;  // reset all flags besides R_ENABLED
+        state_mask_.fetch_and(R_ENABLED);  // reset all flags besides R_ENABLED
         continue;
       }
-      state_mask_ |= R_SYNC_OK;
+      state_mask_.fetch_or(R_SYNC_OK);
+      continue;
     }
 
     // 4. Start stable state sync.
-    DCHECK(state_mask_ & R_SYNC_OK);
+    DCHECK(state_mask_.load() & R_SYNC_OK);
 
     if (HasDflyMaster())
       ec = ConsumeDflyStream();
@@ -279,7 +283,7 @@ void Replica::MainReplicationFb() {
 
     LOG(WARNING) << "Error full sync with " << master_context_.Description() << " " << ec << " "
                  << ec.message();
-    state_mask_ &= R_ENABLED;
+    state_mask_.fetch_and(R_ENABLED);
   }
 
   // Wait for unblocking cleanup to finish.
@@ -307,7 +311,16 @@ error_code Replica::ResolveMasterDns() {
 error_code Replica::ConnectAndAuth(std::chrono::milliseconds connect_timeout_ms) {
   ProactorBase* mythread = ProactorBase::me();
   CHECK(mythread);
-  sock_.reset(mythread->CreateSocket());
+  {
+    unique_lock lk(sock_mu_);
+    // The context closes sock_. So if the context error handler has already
+    // run we must not create a new socket. sock_mu_ syncs between the two
+    // functions.
+    if (!cntx_.IsCancelled())
+      sock_.reset(mythread->CreateSocket());
+    else
+      return cntx_.GetError();
+  }
 
   // We set this timeout because this call blocks other REPLICAOF commands. We don't need it for the
   // rest of the sync.
@@ -440,7 +453,7 @@ error_code Replica::Greet() {
   }
 
   io_buf.ConsumeInput(consumed);
-  state_mask_ |= R_GREETED;
+  state_mask_.fetch_or(R_GREETED);
   return error_code{};
 }
 
@@ -478,7 +491,7 @@ error_code Replica::InitiatePSync() {
   // we get the snapshot size.
   if (snapshot_size || token != nullptr) {  // full sync
     // Start full sync
-    state_mask_ |= R_SYNCING;
+    state_mask_.fetch_or(R_SYNCING);
 
     io::PrefixSource ps{io_buf.InputBuffer(), sock_.get()};
 
@@ -519,8 +532,8 @@ error_code Replica::InitiatePSync() {
     last_io_time_ = sock_thread->GetMonotonicTimeNs();
   }
 
-  state_mask_ &= ~R_SYNCING;
-  state_mask_ |= R_SYNC_OK;
+  state_mask_.fetch_and(~R_SYNCING);
+  state_mask_.fetch_or(R_SYNC_OK);
 
   // There is a data race condition in Redis-master code, where "ACK 0" handler may be
   // triggered before Redis is ready to transition to the streaming state and it silenty ignores
@@ -538,7 +551,7 @@ error_code Replica::InitiateDflySync() {
     // We do the following operations regardless of outcome.
     JoinAllFlows();
     service_.SwitchState(GlobalState::LOADING, GlobalState::ACTIVE);
-    state_mask_ &= ~R_SYNCING;
+    state_mask_.fetch_and(~R_SYNCING);
   };
 
   // Initialize MultiShardExecution.
@@ -575,7 +588,7 @@ error_code Replica::InitiateDflySync() {
   JournalExecutor{&service_}.FlushAll();
 
   // Start full sync flows.
-  state_mask_ |= R_SYNCING;
+  state_mask_.fetch_or(R_SYNCING);
   {
     auto partition = Partition(num_df_flows_);
     auto shard_cb = [&](unsigned index, auto*) {
@@ -722,6 +735,7 @@ error_code Replica::ConsumeDflyStream() {
 }
 
 void Replica::CloseSocket() {
+  unique_lock lk(sock_mu_);
   if (sock_) {
     sock_->proactor()->Await([this] {
       auto ec = sock_->Shutdown(SHUT_RDWR);
@@ -804,7 +818,7 @@ error_code Replica::StartFullSyncFlow(BlockingCounter sb, Context* cntx) {
   }
   leftover_buf_->ConsumeInput(consumed);
 
-  state_mask_ = R_ENABLED | R_TCP_CONNECTED;
+  state_mask_.fetch_or(R_TCP_CONNECTED);
 
   // We can not discard io_buf because it may contain data
   // besides the response we parsed. Therefore we pass it further to ReplicateDFFb.
@@ -1213,8 +1227,8 @@ Replica::Info Replica::GetInfo() const {
     Info res;
     res.host = master_context_.host;
     res.port = master_context_.port;
-    res.master_link_established = (state_mask_ & R_TCP_CONNECTED);
-    res.sync_in_progress = (state_mask_ & R_SYNCING);
+    res.master_link_established = (state_mask_.load() & R_TCP_CONNECTED);
+    res.sync_in_progress = (state_mask_.load() & R_SYNCING);
     res.master_last_io_sec = (ProactorBase::GetMonotonicTimeNs() - last_io_time) / 1000000000UL;
     return res;
   });
diff --git a/src/server/replica.h b/src/server/replica.h
index f2cc40c88635..019b2a73f823 100644
--- a/src/server/replica.h
+++ b/src/server/replica.h
@@ -103,7 +103,7 @@ class Replica {
   // Spawns a fiber that runs until link with master is broken or the replication is stopped.
   // Returns true if initial link with master has been established or
   // false if it has failed.
-  bool Start(ConnectionContext* cntx);
+  std::error_code Start(ConnectionContext* cntx);
 
   void Stop();  // thread-safe
 
@@ -221,6 +221,7 @@ class Replica {
   Service& service_;
   MasterContext master_context_;
   std::unique_ptr<util::LinuxSocketBase> sock_;
+  Mutex sock_mu_;
 
   std::shared_ptr<MultiShardExecution> multi_shard_exe_;
 
@@ -253,7 +254,7 @@ class Replica {
   // ack_offs_ last acknowledged offset.
   size_t repl_offs_ = 0, ack_offs_ = 0;
   uint64_t last_io_time_ = 0;  // in ns, monotonic clock.
-  unsigned state_mask_ = 0;
+  std::atomic<unsigned> state_mask_ = 0;
   unsigned num_df_flows_ = 0;
 
   bool is_paused_ = false;
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index 5d55fd8251cb..7e6a4239629e 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -1822,11 +1822,20 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {
 
   LOG(INFO) << "Replicating " << host << ":" << port_s;
 
-  if (absl::EqualsIgnoreCase(host, "no") && absl::EqualsIgnoreCase(port_s, "one")) {
-    // use this lock as critical section to prevent concurrent replicaof commands running.
-    VLOG(1) << "Acquire replica lock";
-    unique_lock lk(replicaof_mu_);
+  // We lock to protect global state changes that we perform during the replication setup:
+  // The replica_ pointer, GlobalState, and the DB itself (we do a flushall txn before syncing).
+  // The lock is only released during replica_->Start because we want to allow cancellation during
+  // the connection. If another replication command is received during Start() of an old
+  // replication, it will acquire the lock, call Stop() on the old replica_ and wait for Stop() to
+  // complete. So Replica::Stop() must
+  // 1. Be very responsive, as it is called while holding the lock.
+  // 2. Leave the DB in a consistent state after it is done.
+  // We have a relatively involved state machine inside Replica itself which handels cancellation
+  // with those requirements.
+  VLOG(1) << "Acquire replica lock";
+  unique_lock lk(replicaof_mu_);
 
+  if (absl::EqualsIgnoreCase(host, "no") && absl::EqualsIgnoreCase(port_s, "one")) {
     if (!ServerState::tlocal()->is_master) {
       auto repl_ptr = replica_;
       CHECK(repl_ptr);
@@ -1849,8 +1858,6 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {
 
   auto new_replica = make_shared<Replica>(string(host), port, &service_, master_id());
 
-  VLOG(1) << "Acquire replica lock";
-  unique_lock lk(replicaof_mu_);
   if (replica_) {
     replica_->Stop();  // NOTE: consider introducing update API flow.
   } else {
@@ -1858,8 +1865,7 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {
 
     pool.AwaitFiberOnAll([&](util::ProactorBase* pb) { ServerState::tlocal()->is_master = false; });
   }
-
-  replica_.swap(new_replica);
+  replica_ = new_replica;
 
   GlobalState new_state = service_.SwitchState(GlobalState::ACTIVE, GlobalState::LOADING);
   if (new_state != GlobalState::LOADING) {
@@ -1879,14 +1885,22 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {
 
   // Replica sends response in either case. No need to send response in this function.
   // It's a bit confusing but simpler.
-  if (!replica_->Start(cntx)) {
-    service_.SwitchState(GlobalState::LOADING, GlobalState::ACTIVE);
-    replica_.reset();
-  }
+  lk.unlock();
+  error_code ec = new_replica->Start(cntx);
+  VLOG(1) << "Acquire replica lock";
+  lk.lock();
 
-  bool is_master = !replica_;
-  pool.AwaitFiberOnAll(
-      [&](util::ProactorBase* pb) { ServerState::tlocal()->is_master = is_master; });
+  // Since we released the replication lock during Start(..), we need to check if this still the
+  // last replicaof command we got. If it's not, then we were cancelled and just exit.
+  if (replica_ == new_replica) {
+    if (ec) {
+      service_.SwitchState(GlobalState::LOADING, GlobalState::ACTIVE);
+      replica_.reset();
+    }
+    bool is_master = !replica_;
+    pool.AwaitFiberOnAll(
+        [&](util::ProactorBase* pb) { ServerState::tlocal()->is_master = is_master; });
+  }
 }
 
 void ServerFamily::ReplConf(CmdArgList args, ConnectionContext* cntx) {
@@ -2041,7 +2055,7 @@ void ServerFamily::Dfly(CmdArgList args, ConnectionContext* cntx) {
 #define HFUNC(x) SetHandler(HandlerFunc(this, &ServerFamily::x))
 
 void ServerFamily::Register(CommandRegistry* registry) {
-  constexpr auto kReplicaOpts = CO::ADMIN | CO::GLOBAL_TRANS;
+  constexpr auto kReplicaOpts = CO::LOADING | CO::ADMIN | CO::GLOBAL_TRANS;
   constexpr auto kMemOpts = CO::LOADING | CO::READONLY | CO::FAST | CO::NOSCRIPT;
 
   *registry << CI{"AUTH", CO::NOSCRIPT | CO::FAST | CO::LOADING, -2, 0, 0, 0}.HFUNC(Auth)
diff --git a/src/server/snapshot.cc b/src/server/snapshot.cc
index 1c38df3ed7a1..c51bfbdfc5b6 100644
--- a/src/server/snapshot.cc
+++ b/src/server/snapshot.cc
@@ -78,9 +78,12 @@ void SliceSnapshot::Cancel() {
   VLOG(1) << "SliceSnapshot::Cancel";
 
   CloseRecordChannel();
-  if (journal_cb_id_) {
-    db_slice_->shard_owner()->journal()->UnregisterOnChange(journal_cb_id_);
+  // Cancel() might be called multiple times from different fibers of the same thread, but we
+  // should unregister the callback only once.
+  uint32_t cb_id = journal_cb_id_;
+  if (cb_id) {
     journal_cb_id_ = 0;
+    db_slice_->shard_owner()->journal()->UnregisterOnChange(cb_id);
   }
 }
 
