{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 280,
  "instance_id": "dragonflydb__dragonfly-280",
  "issue_numbers": [
    "170"
  ],
  "base_commit": "0fbd1afa36261b3873f90c374b3caae94d9f7fe9",
  "patch": "diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 367423c00be8..21849e476cc7 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -698,6 +698,10 @@ auto Connection::FromArgs(RespVec args, mi_heap_t* heap) -> Request* {\n   return req;\n }\n \n+void Connection::ShutdownSelf() {\n+  util::Connection::Shutdown();\n+}\n+\n void RespToArgList(const RespVec& src, CmdArgVec* dest) {\n   dest->resize(src.size());\n   for (size_t i = 0; i < src.size(); ++i) {\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 5578d5ed85da..f7258af59d36 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -72,6 +72,8 @@ class Connection : public util::Connection {\n   std::string GetClientInfo() const;\n   uint32 GetClientId() const;\n \n+  void ShutdownSelf();\n+\n  protected:\n   void OnShutdown() override;\n   void OnPreMigrateThread() override;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 49f1ad7cde41..a8efec664055 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -721,6 +721,7 @@ void Service::Quit(CmdArgList args, ConnectionContext* cntx) {\n \n   SinkReplyBuilder* builder = cntx->reply_builder();\n   builder->CloseConnection();\n+  cntx->owner()->ShutdownSelf();\n }\n \n void Service::Multi(CmdArgList args, ConnectionContext* cntx) {\n",
  "test_patch": "diff --git a/tests/dragonfly/conftest.py b/tests/dragonfly/conftest.py\nindex 46473b1b1334..08fca369bbc5 100644\n--- a/tests/dragonfly/conftest.py\n+++ b/tests/dragonfly/conftest.py\n@@ -48,7 +48,7 @@ def df_server(request, tmp_dir: Path, test_env):\n     arguments = [arg.format(**test_env) for arg in request.param]\n     dfly_proc = subprocess.Popen([DRAGONFLY_PATH, *arguments],\n                                  env=test_env, cwd=str(tmp_dir))\n-    time.sleep(0.1)\n+    time.sleep(0.3)\n     return_code = dfly_proc.poll()\n     if return_code is not None:\n         dfly_proc.terminate()\n@@ -66,17 +66,19 @@ def df_server(request, tmp_dir: Path, test_env):\n         print(outs)\n         print(errs)\n \n+@pytest.fixture(scope=\"function\")\n+def connection(df_server):\n+    return redis.Connection()\n \n @pytest.fixture(scope=\"class\")\n-def connection(df_server):\n+def raw_client(df_server):\n     \"\"\" Creates the Redis client to interact with the Dragonfly instance \"\"\"\n     pool = redis.ConnectionPool(decode_responses=True)\n     client = redis.Redis(connection_pool=pool)\n     return client\n \n-\n @pytest.fixture\n-def client(connection):\n+def client(raw_client):\n     \"\"\" Flushes all the records, runs before each test. \"\"\"\n-    connection.flushall()\n-    return connection\n+    raw_client.flushall()\n+    return raw_client\ndiff --git a/tests/dragonfly/server_family_test.py b/tests/dragonfly/server_family_test.py\nnew file mode 100644\nindex 000000000000..1d72d2a66410\n--- /dev/null\n+++ b/tests/dragonfly/server_family_test.py\n@@ -0,0 +1,20 @@\n+import pytest\n+import redis\n+\n+def test_quit(connection):\n+    connection.send_command(\"QUIT\")\n+    assert connection.read_response() == b'OK'\n+\n+    with pytest.raises(redis.exceptions.ConnectionError) as e:\n+        connection.read_response()\n+\n+def test_quit_after_sub(connection):\n+    connection = redis.Connection()\n+    connection.send_command(\"SUBSCRIBE\", \"foo\")\n+    connection.read_response()\n+\n+    connection.send_command(\"QUIT\")\n+    assert connection.read_response() == b'OK'\n+\n+    with pytest.raises(redis.exceptions.ConnectionError) as e:\n+        connection.read_response()\n",
  "problem_statement": "QUIT does not disconnect once subscribed\n`QUIT` terminates the connection.\r\n\r\n```\r\n% nc localhost 6379\r\nPING\r\n+PONG\r\nQUIT\r\n+OK\r\n%\r\n```\r\n\r\n`QUIT` does not terminate the connection anymore after a `SUBSCRIBE`. Instead, it waits for another line/command, and then the connection gets terminated.\r\n\r\n```\r\n% nc localhost 6379\r\nPING\r\n+PONG\r\nSUBSCRIBE foo\r\n*3\r\n$9\r\nsubscribe\r\n$3\r\nfoo\r\n:1\r\nQUIT\r\n+OK\r\nPING\r\n%\r\n```\r\n\r\nThe issue was detected with by https://github.com/pascaldekloe/redis/issues/4.\n",
  "hints_text": "@dranikpg it's a very easy bug once you know what to fix and it's very complicated because it requires from you to understand how DF connection management works. It's not urgent and serves more as an education task to learn the code in that area...\nIs it really an easy bug to fix?\r\nSo, what is causing this bug:\r\n1. After subscribe, `IoLoop...ParseRedis()` is choosing the slow path to dispatch `QUIT` via the dispatch fiber\r\n2. The `IoLoop` blocks on `peer->Recv(append_buf);` waiting for more data\r\n3. The dispatch fiber stops after processing QUIT (as expected) by checking the builder error\r\n4. `ConnectionFlow` blocks on `IoLoop`\r\n\r\nIt makes sense for `IoLoop` to block on new data as soon as possible - for faster reading. By the time QUIT is processed, the only way to unblock `IoLoop` is by closing the `peer` manually. \r\n\r\nSo we either:\r\n1. Run QUIT always in sync\r\n2. Close manually (and move cleanup)\r\n3. Invent something else...\r\n",
  "created_at": "2022-09-12T14:29:18Z",
  "modified_files": [
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/conftest.py",
    "b/tests/dragonfly/server_family_test.py"
  ]
}