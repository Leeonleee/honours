diff --git a/src/facade/CMakeLists.txt b/src/facade/CMakeLists.txt
index 67b83a6d65dc..6e8d65fa9e78 100644
--- a/src/facade/CMakeLists.txt
+++ b/src/facade/CMakeLists.txt
@@ -3,7 +3,7 @@ cxx_link(dfly_parser_lib base strings_lib)
 
 add_library(dfly_facade conn_context.cc dragonfly_listener.cc dragonfly_connection.cc facade.cc
             memcache_parser.cc reply_builder.cc op_status.cc service_interface.cc
-            reply_capture.cc cmd_arg_parser.cc tls_error.cc)
+            reply_capture.cc cmd_arg_parser.cc tls_helpers.cc)
 
 if (DF_USE_SSL)
   set(TLS_LIB tls_lib)
diff --git a/src/facade/dragonfly_listener.cc b/src/facade/dragonfly_listener.cc
index ddde92164fda..733f65116dc2 100644
--- a/src/facade/dragonfly_listener.cc
+++ b/src/facade/dragonfly_listener.cc
@@ -1,4 +1,4 @@
-// Copyright 2022, DragonflyDB authors.  All rights reserved.
+// Copyright 2025, DragonflyDB authors.  All rights reserved.
 // See LICENSE for licensing terms.
 //
 
@@ -9,7 +9,7 @@
 #include <memory>
 
 #include "absl/functional/bind_front.h"
-#include "facade/tls_error.h"
+#include "facade/tls_helpers.h"
 
 #ifdef DFLY_USE_SSL
 #include <openssl/ssl.h>
@@ -29,12 +29,11 @@ ABSL_FLAG(bool, conn_use_incoming_cpu, false,
           "If true uses incoming cpu of a socket in order to distribute"
           " incoming connections");
 
-ABSL_FLAG(string, tls_cert_file, "", "cert file for tls connections");
-ABSL_FLAG(string, tls_key_file, "", "key file for tls connections");
-ABSL_FLAG(string, tls_ca_cert_file, "", "ca signed certificate to validate tls connections");
-ABSL_FLAG(string, tls_ca_cert_dir, "",
-          "ca signed certificates directory. Use c_rehash before, read description in "
-          "https://www.openssl.org/docs/man3.0/man1/c_rehash.html");
+ABSL_DECLARE_FLAG(std::string, tls_cert_file);
+ABSL_DECLARE_FLAG(std::string, tls_key_file);
+ABSL_DECLARE_FLAG(std::string, tls_ca_cert_file);
+ABSL_DECLARE_FLAG(std::string, tls_ca_cert_dir);
+
 ABSL_FLAG(uint32_t, tcp_keepalive, 300,
           "the period in seconds of inactivity after which keep-alives are triggerred,"
           "the duration until an inactive connection is terminated is twice the specified time");
@@ -71,61 +70,6 @@ using absl::GetFlag;
 
 namespace {
 
-#ifdef DFLY_USE_SSL
-
-// Creates the TLS context. Returns nullptr if the TLS configuration is invalid.
-// To connect: openssl s_client -state -crlf -connect 127.0.0.1:6380
-SSL_CTX* CreateSslServerCntx() {
-  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);
-  if (tls_key_file.empty()) {
-    LOG(ERROR) << "To use TLS, a server certificate must be provided with the --tls_key_file flag!";
-    return nullptr;
-  }
-
-  SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());
-  unsigned mask = SSL_VERIFY_NONE;
-
-  if (SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM) != 1) {
-    LOG(ERROR) << "Failed to load TLS key";
-    return nullptr;
-  }
-  const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);
-
-  if (!tls_cert_file.empty()) {
-    // TO connect with redis-cli you need both tls-key-file and tls-cert-file
-    // loaded. Use `redis-cli --tls -p 6380 --insecure  PING` to test
-    if (SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()) != 1) {
-      LOG(ERROR) << "Failed to load TLS certificate";
-      return nullptr;
-    }
-  }
-
-  const auto tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);
-  const auto tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);
-  if (!tls_ca_cert_file.empty() || !tls_ca_cert_dir.empty()) {
-    const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();
-    const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();
-    if (SSL_CTX_load_verify_locations(ctx, file, dir) != 1) {
-      LOG(ERROR) << "Failed to load TLS verify locations (CA cert file or CA cert dir)";
-      return nullptr;
-    }
-    mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
-  }
-
-  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, "DEFAULT"));
-
-  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
-
-  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
-
-  SSL_CTX_set_verify(ctx, mask, NULL);
-
-  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));
-
-  return ctx;
-}
-#endif
-
 bool ConfigureKeepAlive(int fd) {
   int val = 1;
   if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) < 0)
@@ -260,7 +204,7 @@ error_code Listener::ConfigureServerSocket(int fd) {
 bool Listener::ReconfigureTLS() {
   SSL_CTX* prev_ctx = ctx_;
   if (GetFlag(FLAGS_tls)) {
-    SSL_CTX* ctx = CreateSslServerCntx();
+    SSL_CTX* ctx = CreateSslCntx(facade::TlsContextRole::SERVER);
     if (!ctx) {
       return false;
     }
diff --git a/src/facade/dragonfly_listener.h b/src/facade/dragonfly_listener.h
index 106884424e81..35e0c21673c9 100644
--- a/src/facade/dragonfly_listener.h
+++ b/src/facade/dragonfly_listener.h
@@ -1,4 +1,4 @@
-// Copyright 2022, DragonflyDB authors.  All rights reserved.
+// Copyright 2025, DragonflyDB authors.  All rights reserved.
 // See LICENSE for licensing terms.
 //
 
diff --git a/src/facade/tls_error.cc b/src/facade/tls_error.cc
deleted file mode 100644
index b8d98c50ad84..000000000000
--- a/src/facade/tls_error.cc
+++ /dev/null
@@ -1,25 +0,0 @@
-#include "facade/tls_error.h"
-
-#include <openssl/err.h>
-
-#include <string_view>
-
-#include "base/logging.h"
-
-#ifdef DFLY_USE_SSL
-
-void facade::PrintSSLError() {
-  ERR_print_errors_cb(
-      [](const char* str, size_t len, void* u) {
-        LOG(ERROR) << std::string_view(str, len);
-        return 1;
-      },
-      nullptr);
-}
-
-#else
-
-void facade::PrintSSLError() {
-}
-
-#endif
diff --git a/src/facade/tls_helpers.cc b/src/facade/tls_helpers.cc
new file mode 100644
index 000000000000..4ecf9e63da7e
--- /dev/null
+++ b/src/facade/tls_helpers.cc
@@ -0,0 +1,98 @@
+// Copyright 2025, DragonflyDB authors.  All rights reserved.
+// See LICENSE for licensing terms.
+//
+#include "tls_helpers.h"
+
+#include <openssl/err.h>
+
+#ifdef DFLY_USE_SSL
+#include <openssl/ssl.h>
+#endif
+
+#include <string>
+
+#include "absl/functional/bind_front.h"
+#include "base/flags.h"
+#include "base/logging.h"
+
+ABSL_FLAG(std::string, tls_cert_file, "", "cert file for tls connections");
+ABSL_FLAG(std::string, tls_key_file, "", "key file for tls connections");
+ABSL_FLAG(std::string, tls_ca_cert_file, "", "ca signed certificate to validate tls connections");
+ABSL_FLAG(std::string, tls_ca_cert_dir, "",
+          "ca signed certificates directory. Use c_rehash before, read description in "
+          "https://www.openssl.org/docs/man3.0/man1/c_rehash.html");
+
+namespace facade {
+
+#ifdef DFLY_USE_SSL
+
+// Creates the TLS context. Returns nullptr if the TLS configuration is invalid.
+// To connect: openssl s_client -state -crlf -connect 127.0.0.1:6380
+SSL_CTX* CreateSslCntx(TlsContextRole role) {
+  using absl::GetFlag;
+  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);
+  if (tls_key_file.empty()) {
+    LOG(ERROR) << "To use TLS, a server certificate must be provided with the --tls_key_file flag!";
+    return nullptr;
+  }
+
+  SSL_CTX* ctx;
+
+  if (role == TlsContextRole::SERVER) {
+    ctx = SSL_CTX_new(TLS_server_method());
+  } else {
+    ctx = SSL_CTX_new(TLS_client_method());
+  }
+  unsigned mask = SSL_VERIFY_NONE;
+
+  if (SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM) != 1) {
+    LOG(ERROR) << "Failed to load TLS key";
+    return nullptr;
+  }
+  const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);
+
+  if (!tls_cert_file.empty()) {
+    // TO connect with redis-cli you need both tls-key-file and tls-cert-file
+    // loaded. Use `redis-cli --tls -p 6380 --insecure  PING` to test
+    if (SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()) != 1) {
+      LOG(ERROR) << "Failed to load TLS certificate";
+      return nullptr;
+    }
+  }
+
+  const auto tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);
+  const auto tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);
+  if (!tls_ca_cert_file.empty() || !tls_ca_cert_dir.empty()) {
+    const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();
+    const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();
+    if (SSL_CTX_load_verify_locations(ctx, file, dir) != 1) {
+      LOG(ERROR) << "Failed to load TLS verify locations (CA cert file or CA cert dir)";
+      return nullptr;
+    }
+    mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+  }
+
+  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, "DEFAULT"));
+
+  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
+
+  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+
+  SSL_CTX_set_verify(ctx, mask, NULL);
+
+  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));
+
+  return ctx;
+}
+
+void PrintSSLError() {
+  ERR_print_errors_cb(
+      [](const char* str, size_t len, void* u) {
+        LOG(ERROR) << std::string_view(str, len);
+        return 1;
+      },
+      nullptr);
+}
+
+#endif
+}  // namespace facade
diff --git a/src/facade/tls_error.h b/src/facade/tls_helpers.h
similarity index 57%
rename from src/facade/tls_error.h
rename to src/facade/tls_helpers.h
index 52164cd11f99..c0ca7d0f1587 100644
--- a/src/facade/tls_error.h
+++ b/src/facade/tls_helpers.h
@@ -1,14 +1,21 @@
-// Copyright 2023, DragonflyDB authors.  All rights reserved.
+// Copyright 2025, DragonflyDB authors.  All rights reserved.
 // See LICENSE for licensing terms.
 //
 
 #pragma once
 
+#ifdef DFLY_USE_SSL
+#include <openssl/ssl.h>
+#endif
+
 namespace facade {
 
-void PrintSSLError();
+#ifdef DFLY_USE_SSL
+enum class TlsContextRole { SERVER, CLIENT };
+
+SSL_CTX* CreateSslCntx(TlsContextRole role);
 
-}
+void PrintSSLError();
 
 #define DFLY_SSL_CHECK(condition)               \
   if (!(condition)) {                           \
@@ -16,3 +23,7 @@ void PrintSSLError();
     PrintSSLError();                            \
     exit(17);                                   \
   }
+
+#endif
+
+}  // namespace facade
diff --git a/src/server/protocol_client.cc b/src/server/protocol_client.cc
index aeb46e69c73e..df6be0dd0b03 100644
--- a/src/server/protocol_client.cc
+++ b/src/server/protocol_client.cc
@@ -3,7 +3,7 @@
 //
 #include "server/protocol_client.h"
 
-#include "facade/tls_error.h"
+#include "facade/tls_helpers.h"
 
 extern "C" {
 #include "redis/rdb.h"
@@ -54,46 +54,6 @@ using absl::StrCat;
 
 namespace {
 
-#ifdef DFLY_USE_SSL
-
-static ProtocolClient::SSL_CTX* CreateSslClientCntx() {
-  ProtocolClient::SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());
-  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);
-  unsigned mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
-
-  // Load client certificate if given.
-  if (!tls_key_file.empty()) {
-    DFLY_SSL_CHECK(1 == SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM));
-    // We checked that the flag is non empty in ValidateClientTlsFlags.
-    const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);
-
-    DFLY_SSL_CHECK(1 == SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()));
-  }
-
-  // Load custom certificate validation if given.
-  const auto& tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);
-  const auto& tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);
-
-  const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();
-  const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();
-  if (file || dir) {
-    DFLY_SSL_CHECK(1 == SSL_CTX_load_verify_locations(ctx, file, dir));
-  } else {
-    DFLY_SSL_CHECK(1 == SSL_CTX_set_default_verify_paths(ctx));
-  }
-
-  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, "DEFAULT"));
-  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);
-
-  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
-
-  SSL_CTX_set_verify(ctx, mask, NULL);
-
-  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));
-  return ctx;
-}
-#endif
-
 error_code Recv(FiberSocketBase* input, base::IoBuf* dest) {
   auto buf = dest->AppendBuffer();
   io::Result<size_t> exp_size = input->Recv(buf);
@@ -136,9 +96,11 @@ void ValidateClientTlsFlags() {
 }
 
 void ProtocolClient::MaybeInitSslCtx() {
+#ifdef DFLY_USE_SSL
   if (absl::GetFlag(FLAGS_tls_replication)) {
-    ssl_ctx_ = CreateSslClientCntx();
+    ssl_ctx_ = CreateSslCntx(facade::TlsContextRole::CLIENT);
   }
+#endif
 }
 
 ProtocolClient::ProtocolClient(string host, uint16_t port) {
