{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4582,
  "instance_id": "dragonflydb__dragonfly-4582",
  "issue_numbers": [
    "3887"
  ],
  "base_commit": "a56b129f69a383023cbe7e4eac6a20fb81d422dd",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 704f1d4cbc5a..5a2d480f7049 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -1087,17 +1087,31 @@ void BZPopMinMax(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n   return rb->SendNullArray();\n }\n \n-vector<ScoredMap> OpFetch(EngineShard* shard, Transaction* t) {\n+OpResult<vector<ScoredMap>> OpFetch(EngineShard* shard, Transaction* t, bool skip_dest_key) {\n   ShardArgs keys = t->GetShardArgs(shard->shard_id());\n   DCHECK(!keys.Empty());\n \n+  ShardArgs::Iterator start = keys.begin(), end = keys.end();\n+\n+  if (skip_dest_key) {\n+    // If destkey is only found on this shard we can return\n+    if (++start == end)\n+      return OpStatus::OK;\n+  }\n+\n   vector<ScoredMap> results;\n-  results.reserve(keys.Size());\n+  results.reserve(keys.Size() - (skip_dest_key ? 1 : 0));\n \n   auto& db_slice = t->GetDbSlice(shard->shard_id());\n-  for (string_view key : keys) {\n-    auto it = db_slice.FindReadOnly(t->GetDbContext(), key, OBJ_ZSET);\n+  for (; start != end; ++start) {\n+    auto it = db_slice.FindReadOnly(t->GetDbContext(), *start, OBJ_ZSET);\n+\n     if (!it) {\n+      // Key has wrong type so return so we can report error back\n+      if (it.status() == OpStatus::WRONG_TYPE) {\n+        return OpStatus::WRONG_TYPE;\n+      }\n+      // Key is not found so treat it as empty set\n       results.push_back({});\n       continue;\n     }\n@@ -2166,31 +2180,25 @@ void ZSetFamily::ZCount(CmdArgList args, const CommandContext& cmd_cntx) {\n   }\n }\n \n-void ZSetFamily::ZDiff(CmdArgList args, const CommandContext& cmd_cntx) {\n-  vector<vector<ScoredMap>> maps(shard_set->size());\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    maps[shard->shard_id()] = OpFetch(shard, t);\n-    return OpStatus::OK;\n-  };\n-\n-  cmd_cntx.tx->ScheduleSingleHop(std::move(cb));\n+/* Calculate difference between key set and all other sets. */\n+vector<ScoredMemberView> ZDiffOp(ShardId key_sid, vector<OpResult<vector<ScoredMap>>> maps,\n+                                 ScoredMap* result) {\n+  auto& key_shard_map = maps[key_sid].value();\n \n-  const string_view key = ArgS(args, 1);\n-  const ShardId sid = Shard(key, maps.size());\n-  auto* rb = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n-  // Extract the ScoredMap of the first key\n-  auto& sm = maps[sid];\n-  if (sm.empty()) {\n-    rb->SendEmptyArray();\n-    return;\n+  // Key set will be first element of shard ScoredMap vector. Scored map for shard containing key\n+  // should have least one - key set. If it is empty we don't need anything and return immediately.\n+  if (key_shard_map[0].empty()) {\n+    return {};\n   }\n-  auto result = std::move(sm[0]);\n-  sm.erase(sm.begin());\n+\n+  // Store key set values in result and remove it from vector for further calculations.\n+  *result = std::move(key_shard_map[0]);\n+  key_shard_map.erase(key_shard_map.begin());\n \n   auto filter = [&result](const auto& key) mutable {\n-    auto it = result.find(key);\n-    if (it != result.end()) {\n-      result.erase(it);\n+    auto it = result->find(key);\n+    if (it != result->end()) {\n+      result->erase(it);\n     }\n   };\n \n@@ -2198,7 +2206,7 @@ void ZSetFamily::ZDiff(CmdArgList args, const CommandContext& cmd_cntx) {\n   // Iterate over the results of each shard\n   for (auto& vsm : maps) {\n     // Iterate over each fetched set\n-    for (auto& sm : vsm) {\n+    for (auto& sm : vsm.value()) {\n       // Iterate over each key in the fetched set and filter\n       for (auto& [key, value] : sm) {\n         filter(key);\n@@ -2207,15 +2215,53 @@ void ZSetFamily::ZDiff(CmdArgList args, const CommandContext& cmd_cntx) {\n   }\n \n   vector<ScoredMemberView> smvec;\n-  for (const auto& elem : result) {\n+  for (const auto& elem : *result) {\n     smvec.emplace_back(elem.second, elem.first);\n   }\n \n   // Total O(KlogK)\n   std::sort(std::begin(smvec), std::end(smvec));\n \n+  return smvec;\n+}\n+\n+void ZSetFamily::ZDiff(CmdArgList args, const CommandContext& cmd_cntx) {\n+  vector<OpResult<vector<ScoredMap>>> maps(shard_set->size(), OpStatus::OK);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    maps[shard->shard_id()] = OpFetch(shard, t, false /* no destination key */);\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->ScheduleSingleHop(std::move(cb));\n+\n+  auto* rb = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n+\n+  // Check shard results for WRONG_TYPE returned\n+  for (auto& sm_map : maps) {\n+    if (sm_map.status() == OpStatus::WRONG_TYPE) {\n+      rb->SendError(sm_map.status());\n+      return;\n+    }\n+  }\n+\n+  const string_view key = ArgS(args, 1);\n+  const ShardId sid = Shard(key, shard_set->size());\n+\n+  // We need to have result stored and not be destructed before function ends because\n+  // we are passing string_view of result members to other functions\n+  ScoredMap result;\n+  // Calculate diff between sets.\n+  vector<ScoredMemberView> smvec = ZDiffOp(sid, std::move(maps), &result);\n+\n+  // Empty result set so return\n+  if (smvec.empty()) {\n+    rb->SendEmptyArray();\n+    return;\n+  }\n+\n   const bool with_scores = ArgS(args, args.size() - 1) == \"WITHSCORES\";\n-  rb->StartArray(result.size() * (with_scores ? 2 : 1));\n+  rb->StartArray(smvec.size() * (with_scores ? 2 : 1));\n   for (const auto& [score, key] : smvec) {\n     rb->SendBulkString(key);\n     if (with_scores) {\n@@ -2224,6 +2270,50 @@ void ZSetFamily::ZDiff(CmdArgList args, const CommandContext& cmd_cntx) {\n   }\n }\n \n+void ZSetFamily::ZDiffStore(CmdArgList args, const CommandContext& cmd_cntx) {\n+  vector<OpResult<vector<ScoredMap>>> maps(shard_set->size(), OpStatus::OK);\n+  const string_view dest_key = ArgS(args, 0);\n+  const ShardId dest_shard = Shard(dest_key, shard_set->size());\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    // We skip destkey if shard id matches\n+    const bool skip_dest_key = shard->shard_id() == dest_shard;\n+    maps[shard->shard_id()] = OpFetch(shard, t, skip_dest_key);\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->Execute(std::move(cb), false);\n+\n+  auto* rb = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n+\n+  // Check shard results for WRONG_TYPE returned\n+  for (auto& sm_map : maps) {\n+    if (sm_map.status() == OpStatus::WRONG_TYPE) {\n+      cmd_cntx.tx->Conclude();\n+      return rb->SendError(sm_map.status());\n+    }\n+  }\n+\n+  const string_view key = ArgS(args, 2);\n+  const ShardId sid = Shard(key, shard_set->size());\n+\n+  // We need to have result stored and not be destructed before function ends because\n+  // we are passing string_view of result members to other functions\n+  ScoredMap result;\n+  // Calculate diff between sets. We stil need to write  destination key even it is empty set\n+  vector<ScoredMemberView> smvec = ZDiffOp(sid, std::move(maps), &result);\n+\n+  auto store_cb = [&](Transaction* t, EngineShard* shard) {\n+    if (shard->shard_id() == dest_shard)\n+      ZSetFamily::OpAdd(t->GetOpArgs(shard), ZSetFamily::ZParams{.override = true}, dest_key,\n+                        smvec);\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->Execute(store_cb, true);\n+  rb->SendLong(smvec.size());\n+}\n+\n void ZSetFamily::ZIncrBy(CmdArgList args, const CommandContext& cmd_cntx) {\n   string_view key = ArgS(args, 0);\n   string_view score_arg = ArgS(args, 1);\n@@ -2638,6 +2728,7 @@ constexpr uint32_t kBZPopMax = WRITE | SORTEDSET | FAST | BLOCKING;\n constexpr uint32_t kZCard = READ | SORTEDSET | FAST;\n constexpr uint32_t kZCount = READ | SORTEDSET | FAST;\n constexpr uint32_t kZDiff = READ | SORTEDSET | SLOW;\n+constexpr uint32_t kZDiffStore = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZIncrBy = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZInterStore = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZInter = READ | SORTEDSET | SLOW;\n@@ -2682,6 +2773,7 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n       << CI{\"ZCARD\", CO::FAST | CO::READONLY, 2, 1, 1, acl::kZCard}.HFUNC(ZCard)\n       << CI{\"ZCOUNT\", CO::FAST | CO::READONLY, 4, 1, 1, acl::kZCount}.HFUNC(ZCount)\n       << CI{\"ZDIFF\", CO::READONLY | CO::VARIADIC_KEYS, -3, 2, 2, acl::kZDiff}.HFUNC(ZDiff)\n+      << CI{\"ZDIFFSTORE\", kStoreMask, -4, 3, 3, acl::kZDiffStore}.HFUNC(ZDiffStore)\n       << CI{\"ZINCRBY\", CO::FAST | CO::WRITE, 4, 1, 1, acl::kZIncrBy}.HFUNC(ZIncrBy)\n       << CI{\"ZINTERSTORE\", kStoreMask, -4, 3, 3, acl::kZInterStore}.HFUNC(ZInterStore)\n       << CI{\"ZINTER\", CO::READONLY | CO::VARIADIC_KEYS, -3, 2, 2, acl::kZInter}.HFUNC(ZInter)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex a2d1bb35d954..11304d5316ba 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -106,6 +106,7 @@ class ZSetFamily {\n   static void ZCard(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZCount(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZDiff(CmdArgList args, const CommandContext& cmd_cntx);\n+  static void ZDiffStore(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZIncrBy(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZInterStore(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZInter(CmdArgList args, const CommandContext& cmd_cntx);\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 2d4695d95706..b42f5f5b1f40 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -967,6 +967,8 @@ TEST_F(ZSetFamilyTest, BlockingIsReleased) {\n   Run({\"ZADD\", \"B\", \"1\", \"x\", \"3\", \"b\"});\n   Run({\"ZADD\", \"C\", \"1\", \"x\", \"10\", \"a\"});\n   Run({\"ZADD\", \"D\", \"1\", \"x\", \"5\", \"c\"});\n+  Run({\"ZADD\", \"E\", \"2\", \"x\", \"1\", \"c\"});\n+  Run({\"ZADD\", \"F\", \"1\", \"c\"});\n \n   vector<string> blocking_keys{\"zset1\", \"zset2\", \"zset3\"};\n   for (const auto& key : blocking_keys) {\n@@ -976,7 +978,7 @@ TEST_F(ZSetFamilyTest, BlockingIsReleased) {\n     unblocking_commands.push_back({\"ZINCRBY\", key, \"2\", \"x\"});\n     unblocking_commands.push_back({\"ZINTERSTORE\", key, \"2\", \"A\", \"B\"});\n     unblocking_commands.push_back({\"ZUNIONSTORE\", key, \"2\", \"C\", \"D\"});\n-    // unblocking_commands.push_back({\"ZDIFFSTORE\", key, \"2\", \"A\", \"B\"}); // unimplemented\n+    unblocking_commands.push_back({\"ZDIFFSTORE\", key, \"2\", \"E\", \"F\"});\n \n     for (auto& cmd : unblocking_commands) {\n       RespExpr resp0;\n@@ -1046,6 +1048,14 @@ TEST_F(ZSetFamilyTest, ZDiffError) {\n \n   resp = Run({\"zdiff\", \"0\", \"z1\", \"z2\"});\n   EXPECT_THAT(resp, ErrArg(\"at least 1 input key is needed\"));\n+\n+  EXPECT_EQ(1, CheckedInt({\"sadd\", \"s1\", \"one\"}));\n+\n+  resp = Run({\"zdiff\", \"2\", \"z1\", \"s1\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+\n+  resp = Run({\"zdiff\", \"2\", \"s1\", \"z2\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n }\n \n TEST_F(ZSetFamilyTest, ZDiff) {\n@@ -1085,6 +1095,67 @@ TEST_F(ZSetFamilyTest, ZDiff) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"two\", \"2\", \"three\", \"3\", \"four\", \"4\"));\n }\n \n+TEST_F(ZSetFamilyTest, ZDiffStoreError) {\n+  RespExpr resp;\n+\n+  resp = Run({\"zdiffstore\", \"key\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"-1\", \"z1\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"0\", \"z1\"});\n+  EXPECT_THAT(resp, ErrArg(\"at least 1 input key is needed\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"0\", \"z1\", \"z2\"});\n+  EXPECT_THAT(resp, ErrArg(\"at least 1 input key is needed\"));\n+\n+  EXPECT_EQ(1, CheckedInt({\"sadd\", \"s1\", \"one\"}));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"2\", \"z1\", \"s1\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"2\", \"s1\", \"z2\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+}\n+\n+TEST_F(ZSetFamilyTest, ZDiffStore) {\n+  RespExpr resp;\n+\n+  EXPECT_EQ(4, CheckedInt({\"zadd\", \"z1\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\", \"4\", \"four\"}));\n+  EXPECT_EQ(2, CheckedInt({\"zadd\", \"z2\", \"1\", \"one\", \"5\", \"five\"}));\n+  EXPECT_EQ(2, CheckedInt({\"zadd\", \"z3\", \"2\", \"two\", \"3\", \"three\"}));\n+  EXPECT_EQ(1, CheckedInt({\"zadd\", \"z4\", \"4\", \"four\"}));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"1\", \"z1\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+  resp = Run({\"zrange\", \"key\", \"0\", \"-1\", \"withscores\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"one\", \"1\", \"two\", \"2\", \"three\", \"3\", \"four\", \"4\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"2\", \"z1\", \"z1\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"zrange\", \"key\", \"0\", \"-1\", \"withscores\"});\n+  EXPECT_THAT(resp.GetVec().empty(), true);\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"4\", \"z1\", \"z2\", \"z3\", \"z4\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"zrange\", \"key\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec().empty(), true);\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"2\", \"z1\", \"doesnt_exist\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+  resp = Run({\"zrange\", \"key\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"one\", \"two\", \"three\", \"four\"));\n+\n+  resp = Run({\"zdiffstore\", \"key\", \"2\", \"doesnt_exits\", \"z1\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"zrange\", \"key\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec().empty(), true);\n+}\n+\n TEST_F(ZSetFamilyTest, Count) {\n   for (int i = 0; i < 129; ++i) {\n     auto resp = Run({\"zadd\", \"key\", absl::StrCat(i), absl::StrCat(\"element:\", i)});\n",
  "problem_statement": "implement ZDIFFSTORE\nFor reference, see https://valkey.io/commands/zdiffstore/\n",
  "hints_text": "@romange is there any implementation of command similar to this that I can refer?\nyes there  are. Check out ZDIFF and ZUNIONSTORE",
  "created_at": "2025-02-10T08:55:09Z",
  "modified_files": [
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}