{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3574,
  "instance_id": "dragonflydb__dragonfly-3574",
  "issue_numbers": [
    "2930"
  ],
  "base_commit": "9c25ca028cf9f54efc3e1b65883cafd93211c903",
  "patch": "diff --git a/src/facade/acl_commands_def.h b/src/facade/acl_commands_def.h\nindex b4aaadd35b81..13bbc63665c9 100644\n--- a/src/facade/acl_commands_def.h\n+++ b/src/facade/acl_commands_def.h\n@@ -21,13 +21,27 @@ using GlobType = std::pair<std::string, KeyOp>;\n \n struct AclKeys {\n   std::vector<GlobType> key_globs;\n+  // The user is allowed to \"touch\" any key. No glob matching required.\n+  // Alias for ~*\n   bool all_keys = false;\n };\n \n+// The second bool denotes if the pattern contains an asterisk and it's\n+// used to pattern match PSUBSCRIBE that requires exact literals\n+using GlobTypePubSub = std::pair<std::string, bool>;\n+\n+struct AclPubSub {\n+  std::vector<GlobTypePubSub> globs;\n+  // The user can execute any variant of pub/sub/psub. No glob matching required.\n+  // Alias for &* just like all_keys for AclKeys above.\n+  bool all_channels = false;\n+};\n+\n struct UserCredentials {\n   uint32_t acl_categories{0};\n   std::vector<uint64_t> acl_commands;\n   AclKeys keys;\n+  AclPubSub pub_sub;\n   std::string ns;\n };\n \ndiff --git a/src/facade/command_id.h b/src/facade/command_id.h\nindex edbc180aab1c..085d88385ddf 100644\n--- a/src/facade/command_id.h\n+++ b/src/facade/command_id.h\n@@ -86,6 +86,16 @@ class CommandId {\n \n   static uint32_t OptCount(uint32_t mask);\n \n+  // PUBLISH/SUBSCRIBE/UNSUBSCRIBE variant\n+  bool IsPubSub() const {\n+    return is_pub_sub_;\n+  }\n+\n+  // PSUBSCRIBE/PUNSUBSCRIBE variant\n+  bool IsPSub() const {\n+    return is_p_sub_;\n+  }\n+\n  protected:\n   std::string name_;\n \n@@ -102,6 +112,9 @@ class CommandId {\n \n   // Whether the command can only be used by admin connections.\n   bool restricted_ = false;\n+\n+  bool is_pub_sub_ = false;\n+  bool is_p_sub_ = false;\n };\n \n }  // namespace facade\ndiff --git a/src/facade/conn_context.h b/src/facade/conn_context.h\nindex 8a71797df087..3dd3b6ac910f 100644\n--- a/src/facade/conn_context.h\n+++ b/src/facade/conn_context.h\n@@ -107,6 +107,8 @@ class ConnectionContext {\n   std::vector<uint64_t> acl_commands;\n   // keys\n   dfly::acl::AclKeys keys{{}, true};\n+  // pub/sub\n+  dfly::acl::AclPubSub pub_sub{{}, true};\n \n  private:\n   Connection* owner_;\ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 8163800382ae..9add861b04ee 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -451,6 +451,7 @@ void Connection::DispatchOperations::operator()(const AclUpdateMessage& msg) {\n     if (msg.username == self->cntx()->authed_username) {\n       self->cntx()->acl_commands = msg.commands;\n       self->cntx()->keys = msg.keys;\n+      self->cntx()->pub_sub = msg.pub_sub;\n     }\n   }\n }\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex e01f1486f00c..3d3067f486b4 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -113,6 +113,7 @@ class Connection : public util::Connection {\n     std::string username;\n     std::vector<uint64_t> commands;\n     dfly::acl::AclKeys keys;\n+    dfly::acl::AclPubSub pub_sub;\n   };\n \n   // Migration request message, the dispatch fiber stops to give way for thread migration.\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex ed401b78dfe1..5d54562f9480 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -130,6 +130,11 @@ CommandId::CommandId(const char* name, uint32_t mask, int8_t arity, int8_t first\n       first_key_(first_key),\n       last_key_(last_key),\n       acl_categories_(acl_categories) {\n+  if (name_ == \"PUBLISH\" || name_ == \"SUBSCRIBE\" || name_ == \"UNSUBSCRIBE\") {\n+    is_pub_sub_ = true;\n+  } else if (name_ == \"PSUBSCRIBE\" || name_ == \"PUNSUBSCRIBE\") {\n+    is_p_sub_ = true;\n+  }\n }\n \n uint32_t CommandId::OptCount(uint32_t mask) {\ndiff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex 8791c875885d..d510bbded698 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -55,6 +55,8 @@ MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames\n                                              std::string_view file_contents);\n \n std::string AclKeysToString(const AclKeys& keys);\n+\n+std::string AclPubSubToString(const AclPubSub& pub_sub);\n }  // namespace\n \n AclFamily::AclFamily(UserRegistry* registry, util::ProactorPool* pool)\n@@ -76,6 +78,9 @@ void AclFamily::List(CmdArgList args, ConnectionContext* cntx) {\n     const std::string password = PasswordsToString(user.Passwords(), user.HasNopass(), false);\n \n     const std::string acl_keys = AclKeysToString(user.Keys());\n+\n+    const std::string acl_pub_sub = AclPubSubToString(user.PubSub());\n+\n     const std::string maybe_space_com = acl_keys.empty() ? \"\" : \" \";\n \n     const std::string acl_cat_and_commands =\n@@ -84,7 +89,7 @@ void AclFamily::List(CmdArgList args, ConnectionContext* cntx) {\n     using namespace std::string_view_literals;\n \n     absl::StrAppend(&buffer, username, \" \", user.IsActive() ? \"on \"sv : \"off \"sv, password,\n-                    acl_keys, maybe_space_com, acl_cat_and_commands);\n+                    acl_keys, maybe_space_com, acl_pub_sub, \" \", acl_cat_and_commands);\n \n     cntx->SendSimpleString(buffer);\n   }\n@@ -92,14 +97,15 @@ void AclFamily::List(CmdArgList args, ConnectionContext* cntx) {\n \n void AclFamily::StreamUpdatesToAllProactorConnections(const std::string& user,\n                                                       const Commands& update_commands,\n-                                                      const AclKeys& update_keys) {\n+                                                      const AclKeys& update_keys,\n+                                                      const AclPubSub& update_pub_sub) {\n   auto update_cb = [&]([[maybe_unused]] size_t id, util::Connection* conn) {\n     DCHECK(conn);\n     auto connection = static_cast<facade::Connection*>(conn);\n     if (connection->protocol() == facade::Protocol::REDIS && !connection->IsHttp() &&\n         connection->cntx()) {\n       connection->SendAclUpdateAsync(\n-          facade::Connection::AclUpdateMessage{user, update_commands, update_keys});\n+          facade::Connection::AclUpdateMessage{user, update_commands, update_keys, update_pub_sub});\n     }\n   };\n \n@@ -128,11 +134,20 @@ void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {\n       user.Update(std::move(default_req), CategoryToIdx(), reverse_cat_table_,\n                   CategoryToCommandsIndex());\n     }\n+    const bool reset_channels = req.reset_channels;\n     user.Update(std::move(req), CategoryToIdx(), reverse_cat_table_, CategoryToCommandsIndex());\n+    // Send ok first because the connection might get evicted\n+    cntx->SendOk();\n     if (exists) {\n-      StreamUpdatesToAllProactorConnections(std::string(username), user.AclCommands(), user.Keys());\n+      if (!reset_channels) {\n+        StreamUpdatesToAllProactorConnections(std::string(username), user.AclCommands(),\n+                                              user.Keys(), user.PubSub());\n+      }\n+      // We evict connections that had their channels reseted\n+      else {\n+        EvictOpenConnectionsOnAllProactors({username});\n+      }\n     }\n-    cntx->SendOk();\n   };\n \n   std::visit(Overloaded{error_case, update_case}, std::move(req));\n@@ -208,15 +223,18 @@ std::string AclFamily::RegistryToString() const {\n     const std::string password = PasswordsToString(user.Passwords(), user.HasNopass(), true);\n \n     const std::string acl_keys = AclKeysToString(user.Keys());\n+\n     const std::string maybe_space = acl_keys.empty() ? \"\" : \" \";\n \n+    const std::string acl_pub_sub = AclPubSubToString(user.PubSub());\n+\n     const std::string acl_cat_and_commands =\n         AclCatAndCommandToString(user.CatChanges(), user.CmdChanges());\n \n     using namespace std::string_view_literals;\n \n     absl::StrAppend(&result, command, username, \" \", user.IsActive() ? \"ON \"sv : \"OFF \"sv, password,\n-                    acl_keys, maybe_space, acl_cat_and_commands, \"\\n\");\n+                    acl_keys, maybe_space, acl_pub_sub, \" \", acl_cat_and_commands, \"\\n\");\n   }\n \n   return result;\n@@ -391,6 +409,8 @@ void AclFamily::Log(CmdArgList args, ConnectionContext* cntx) {\n       reason = \"COMMAND\";\n     } else if (entry.reason == Reason::KEY) {\n       reason = \"KEY\";\n+    } else if (entry.reason == Reason::PUB_SUB) {\n+      reason = \"PUB_SUB\";\n     } else {\n       reason = \"AUTH\";\n     }\n@@ -511,7 +531,7 @@ void AclFamily::GetUser(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   auto* rb = static_cast<facade::RedisReplyBuilder*>(cntx->reply_builder());\n-  rb->StartArray(8);\n+  rb->StartArray(10);\n \n   rb->SendSimpleString(\"flags\");\n   const size_t total_elements = (pass != \"nopass\") ? 1 : 2;\n@@ -541,6 +561,10 @@ void AclFamily::GetUser(CmdArgList args, ConnectionContext* cntx) {\n   } else {\n     rb->SendEmptyArray();\n   }\n+\n+  rb->SendSimpleString(\"channels\");\n+  std::string pub_sub = AclPubSubToString(user.PubSub());\n+  rb->SendSimpleString(pub_sub);\n }\n \n void AclFamily::GenPass(CmdArgList args, ConnectionContext* cntx) {\n@@ -815,6 +839,31 @@ std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command) {\n   return ParseKeyResult{std::string(key), op};\n }\n \n+struct ParsePubSubResult {\n+  std::string glob;\n+  bool has_asterisk{false};\n+  bool all_channels{false};\n+  bool reset_channels{false};\n+};\n+\n+std::optional<ParsePubSubResult> MaybeParseAclPubSub(std::string_view command) {\n+  if (absl::EqualsIgnoreCase(command, \"ALLCHANNELS\") || command == \"&*\") {\n+    return ParsePubSubResult{\"\", false, true, false};\n+  }\n+\n+  if (absl::EqualsIgnoreCase(command, \"RESETCHANNELS\")) {\n+    return ParsePubSubResult{\"\", false, false, true};\n+  }\n+\n+  if (absl::StartsWith(command, \"&\") && command.size() >= 2) {\n+    const auto glob = command.substr(1);\n+    const bool has_asterisk = glob.find('*') != std::string_view::npos;\n+    return ParsePubSubResult{std::string(glob), has_asterisk};\n+  }\n+\n+  return {};\n+}\n+\n std::string PrettyPrintSha(std::string_view pass, bool all) {\n   if (all) {\n     return absl::BytesToHexString(pass);\n@@ -886,6 +935,24 @@ std::string AclKeysToString(const AclKeys& keys) {\n   return result;\n }\n \n+std::string AclPubSubToString(const AclPubSub& pub_sub) {\n+  if (pub_sub.all_channels) {\n+    return \"&*\";\n+  }\n+\n+  std::string result = \"resetchannels \";\n+\n+  for (const auto& [glob, has_asterisk] : pub_sub.globs) {\n+    absl::StrAppend(&result, \"&\", glob, \" \");\n+  }\n+\n+  if (result.back() == ' ') {\n+    result.pop_back();\n+  }\n+\n+  return result;\n+}\n+\n }  // namespace\n \n std::string AclFamily::AclCatAndCommandToString(const User::CategoryChanges& cat,\n@@ -976,7 +1043,7 @@ std::pair<AclFamily::OptCommand, bool> AclFamily::MaybeParseAclCommand(\n using facade::ErrorReply;\n \n std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(\n-    const facade::ArgRange& args, bool hashed, bool has_all_keys) const {\n+    const facade::ArgRange& args, bool hashed, bool has_all_keys, bool has_all_channels) const {\n   User::UpdateRequest req;\n \n   for (std::string_view arg : args) {\n@@ -993,10 +1060,11 @@ std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(\n       auto& [glob, op, all_keys, reset_keys] = *res;\n       if ((has_all_keys && !all_keys && !reset_keys) ||\n           (req.allow_all_keys && !all_keys && !reset_keys)) {\n-        return ErrorReply(\n-            \"Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * pattern (or the \"\n+        return ErrorReply(absl::StrCat(\n+            \"Error in ACL SETUSER modifier \\'\", facade::ToSV(arg),\n+            \"\\': Adding a pattern after the * pattern (or the \"\n             \"'allkeys' flag) is not valid and does not have any effect. Try 'resetkeys' to start \"\n-            \"with an empty list of patterns\");\n+            \"with an empty list of patterns\"));\n       }\n \n       req.allow_all_keys = all_keys;\n@@ -1008,6 +1076,26 @@ std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(\n       continue;\n     }\n \n+    if (auto res = MaybeParseAclPubSub(facade::ToSV(arg)); res) {\n+      auto& [glob, has_asterisk, all_channels, reset_channels] = *res;\n+      if ((has_all_channels && !all_channels && !reset_channels) ||\n+          (req.all_channels && !all_channels && !reset_channels)) {\n+        return ErrorReply(\n+            absl::StrCat(\"ERR Error in ACL SETUSER modifier \\'\", facade::ToSV(arg),\n+                         \"\\': Adding a pattern after the * pattern (or the 'allchannels' flag) is \"\n+                         \"not valid and does not have any effect. Try 'resetchannels' to start \"\n+                         \"with an empty list of channels\"));\n+      }\n+\n+      req.all_channels = all_channels;\n+      req.reset_channels = reset_channels;\n+      if (reset_channels) {\n+        has_all_channels = false;\n+      }\n+      req.pub_sub.push_back({std::move(glob), has_asterisk, all_channels, reset_channels});\n+      continue;\n+    }\n+\n     std::string command = absl::AsciiStrToUpper(arg);\n \n     if (auto status = MaybeParseStatus(command); status) {\ndiff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h\nindex 8ffce0567700..22d05df872aa 100644\n--- a/src/server/acl/acl_family.h\n+++ b/src/server/acl/acl_family.h\n@@ -52,7 +52,8 @@ class AclFamily final {\n   using Commands = std::vector<uint64_t>;\n   void StreamUpdatesToAllProactorConnections(const std::string& user,\n                                              const Commands& update_commands,\n-                                             const AclKeys& update_keys);\n+                                             const AclKeys& update_keys,\n+                                             const AclPubSub& update_pub_sub);\n \n   // Helper function that closes all open connection from the deleted user\n   void EvictOpenConnectionsOnAllProactors(const absl::flat_hash_set<std::string_view>& user);\n@@ -83,7 +84,8 @@ class AclFamily final {\n   std::optional<std::string> MaybeParseNamespace(std::string_view command) const;\n \n   std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(\n-      const facade::ArgRange& args, bool hashed = false, bool has_all_keys = false) const;\n+      const facade::ArgRange& args, bool hashed = false, bool has_all_keys = false,\n+      bool has_all_channels = false) const;\n \n   void BuildIndexers(RevCommandsIndexStore families);\n \ndiff --git a/src/server/acl/acl_log.h b/src/server/acl/acl_log.h\nindex bb206ac9fbc4..158ccc461922 100644\n--- a/src/server/acl/acl_log.h\n+++ b/src/server/acl/acl_log.h\n@@ -18,7 +18,7 @@ class AclLog {\n  public:\n   explicit AclLog();\n \n-  enum class Reason { COMMAND, AUTH, KEY };\n+  enum class Reason { COMMAND, AUTH, KEY, PUB_SUB };\n \n   struct LogEntry {\n     std::string username;\ndiff --git a/src/server/acl/user.cc b/src/server/acl/user.cc\nindex 341e6b5467b0..bc0e5e34b6bc 100644\n--- a/src/server/acl/user.cc\n+++ b/src/server/acl/user.cc\n@@ -76,6 +76,10 @@ void User::Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,\n     SetKeyGlobs(std::move(req.keys));\n   }\n \n+  if (!req.pub_sub.empty()) {\n+    SetPubSub(std::move(req.pub_sub));\n+  }\n+\n   if (req.is_active) {\n     SetIsActive(*req.is_active);\n   }\n@@ -214,6 +218,10 @@ const AclKeys& User::Keys() const {\n   return keys_;\n }\n \n+const AclPubSub& User::PubSub() const {\n+  return pub_sub_;\n+}\n+\n const User::CategoryChanges& User::CatChanges() const {\n   return cat_changes_;\n }\n@@ -236,6 +244,20 @@ void User::SetKeyGlobs(std::vector<UpdateKey> keys) {\n   }\n }\n \n+void User::SetPubSub(std::vector<UpdatePubSub> pub_sub) {\n+  for (auto& pattern : pub_sub) {\n+    if (pattern.all_channels) {\n+      pub_sub_.globs.clear();\n+      pub_sub_.all_channels = true;\n+    } else if (pattern.reset_channels) {\n+      pub_sub_.globs.clear();\n+      pub_sub_.all_channels = false;\n+    } else {\n+      pub_sub_.globs.push_back({std::move(pattern.pattern), pattern.has_asterisk});\n+    }\n+  }\n+}\n+\n void User::SetNopass() {\n   nopass_ = true;\n   password_hashes_.clear();\ndiff --git a/src/server/acl/user.h b/src/server/acl/user.h\nindex 187856728e65..134c8aeb7541 100644\n--- a/src/server/acl/user.h\n+++ b/src/server/acl/user.h\n@@ -40,6 +40,13 @@ class User final {\n     bool is_hashed{false};\n   };\n \n+  struct UpdatePubSub {\n+    std::string pattern;\n+    bool has_asterisk{false};\n+    bool all_channels{false};\n+    bool reset_channels{false};\n+  };\n+\n   struct UpdateRequest {\n     std::vector<UpdatePass> passwords;\n \n@@ -59,6 +66,11 @@ class User final {\n     bool reset_all_keys{false};\n     bool allow_all_keys{false};\n \n+    // pub/sub\n+    std::vector<UpdatePubSub> pub_sub;\n+    bool reset_channels{false};\n+    bool all_channels{false};\n+\n     // TODO allow reset all\n     // bool reset_all{false};\n \n@@ -107,6 +119,8 @@ class User final {\n \n   const AclKeys& Keys() const;\n \n+  const AclPubSub& PubSub() const;\n+\n   const std::string& Namespace() const;\n \n   using CategoryChanges = absl::flat_hash_map<CategoryChange, ChangeMetadata>;\n@@ -140,6 +154,10 @@ class User final {\n \n   // For ACL key globs\n   void SetKeyGlobs(std::vector<UpdateKey> keys);\n+\n+  // For ACL pub/sub\n+  void SetPubSub(std::vector<UpdatePubSub> pub_sub);\n+\n   void SetNamespace(const std::string& ns);\n \n   // Set NOPASS and remove all passwords\n@@ -170,6 +188,9 @@ class User final {\n   // Glob patterns for the keys that a user is allowed to read/write\n   AclKeys keys_;\n \n+  // Glob patterns for pub/sub channels\n+  AclPubSub pub_sub_;\n+\n   // if the user is on/off\n   bool is_active_{false};\n \ndiff --git a/src/server/acl/user_registry.cc b/src/server/acl/user_registry.cc\nindex 6c5d946aff62..309d944f1f29 100644\n--- a/src/server/acl/user_registry.cc\n+++ b/src/server/acl/user_registry.cc\n@@ -35,8 +35,8 @@ UserCredentials UserRegistry::GetCredentials(std::string_view username) const {\n   if (it == registry_.end()) {\n     return {};\n   }\n-  return {it->second.AclCategory(), it->second.AclCommands(), it->second.Keys(),\n-          it->second.Namespace()};\n+  auto& user = it->second;\n+  return {user.AclCategory(), user.AclCommands(), user.Keys(), user.PubSub(), user.Namespace()};\n }\n \n bool UserRegistry::IsUserActive(std::string_view username) const {\n@@ -80,6 +80,7 @@ User::UpdateRequest UserRegistry::DefaultUserUpdateRequest() const {\n   req.is_active = true;\n   req.updates = {std::pair<User::Sign, uint32_t>{User::Sign::PLUS, acl::ALL}};\n   req.keys = {User::UpdateKey{\"~*\", KeyOp::READ_WRITE, true, false}};\n+  req.pub_sub = {User::UpdatePubSub{\"\", false, true, false}};\n   return req;\n }\n \ndiff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc\nindex 9dcb1dba689b..5513ece55ce9 100644\n--- a/src/server/acl/validator.cc\n+++ b/src/server/acl/validator.cc\n@@ -23,8 +23,17 @@ namespace dfly::acl {\n     return true;\n   }\n \n-  const auto [is_authed, reason] =\n-      IsUserAllowedToInvokeCommandGeneric(cntx.acl_commands, cntx.keys, tail_args, id);\n+  std::pair<bool, AclLog::Reason> auth_res;\n+\n+  if (id.IsPubSub()) {\n+    auth_res = IsPubSubCommandAuthorized(false, cntx.acl_commands, cntx.pub_sub, tail_args, id);\n+  } else if (id.IsPSub()) {\n+    auth_res = IsPubSubCommandAuthorized(true, cntx.acl_commands, cntx.pub_sub, tail_args, id);\n+  } else {\n+    auth_res = IsUserAllowedToInvokeCommandGeneric(cntx.acl_commands, cntx.keys, tail_args, id);\n+  }\n+\n+  const auto [is_authed, reason] = auth_res;\n \n   if (!is_authed) {\n     auto& log = ServerState::tlocal()->acl_log;\n@@ -40,16 +49,18 @@ namespace dfly::acl {\n #pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n #endif\n \n-[[nodiscard]] std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n-    const std::vector<uint64_t>& acl_commands, const AclKeys& keys, CmdArgList tail_args,\n-    const CommandId& id) {\n+static bool ValidateCommand(const std::vector<uint64_t>& acl_commands, const CommandId& id) {\n   const size_t index = id.GetFamily();\n   const uint64_t command_mask = id.GetBitIndex();\n   DCHECK_LT(index, acl_commands.size());\n \n-  const bool command = (acl_commands[index] & command_mask) != 0;\n+  return (acl_commands[index] & command_mask) != 0;\n+}\n \n-  if (!command) {\n+[[nodiscard]] std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n+    const std::vector<uint64_t>& acl_commands, const AclKeys& keys, CmdArgList tail_args,\n+    const CommandId& id) {\n+  if (!ValidateCommand(acl_commands, id)) {\n     return {false, AclLog::Reason::COMMAND};\n   }\n \n@@ -86,6 +97,39 @@ namespace dfly::acl {\n   return {keys_allowed, AclLog::Reason::KEY};\n }\n \n+[[nodiscard]] std::pair<bool, AclLog::Reason> IsPubSubCommandAuthorized(\n+    bool literal_match, const std::vector<uint64_t>& acl_commands, const AclPubSub& pub_sub,\n+    CmdArgList tail_args, const CommandId& id) {\n+  if (!ValidateCommand(acl_commands, id)) {\n+    return {false, AclLog::Reason::COMMAND};\n+  }\n+\n+  auto match = [](std::string_view pattern, std::string_view target) {\n+    return stringmatchlen(pattern.data(), pattern.size(), target.data(), target.size(), 0);\n+  };\n+\n+  auto iterate_globs = [&](std::string_view target) {\n+    for (auto& [glob, has_asterisk] : pub_sub.globs) {\n+      if (literal_match && (glob == target)) {\n+        return true;\n+      }\n+      if (!literal_match && match(glob, target)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  };\n+\n+  bool allowed = true;\n+  if (!pub_sub.all_channels) {\n+    for (auto channel : tail_args) {\n+      allowed &= iterate_globs(facade::ToSV(channel));\n+    }\n+  }\n+\n+  return {allowed, AclLog::Reason::PUB_SUB};\n+}\n+\n #pragma GCC diagnostic pop\n \n }  // namespace dfly::acl\ndiff --git a/src/server/acl/validator.h b/src/server/acl/validator.h\nindex 4dd461b1ae35..70d849f97de8 100644\n--- a/src/server/acl/validator.h\n+++ b/src/server/acl/validator.h\n@@ -13,6 +13,7 @@\n namespace dfly::acl {\n \n struct AclKeys;\n+struct AclPubSub;\n \n std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n     const std::vector<uint64_t>& acl_commands, const AclKeys& keys, facade::CmdArgList tail_args,\n@@ -20,4 +21,11 @@ std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n \n bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx, const CommandId& id,\n                                   facade::CmdArgList tail_args);\n+\n+std::pair<bool, AclLog::Reason> IsPubSubCommandAuthorized(bool literal_match,\n+                                                          const std::vector<uint64_t>& acl_commands,\n+                                                          const AclPubSub& pub_sub,\n+                                                          facade::CmdArgList tail_args,\n+                                                          const CommandId& id);\n+\n }  // namespace dfly::acl\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 79bb4bd9f4e6..5f8bfe4ec896 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -89,6 +89,7 @@ ConnectionContext::ConnectionContext(::io::Sink* stream, facade::Connection* own\n   }\n \n   keys = std::move(cred.keys);\n+  pub_sub = std::move(cred.pub_sub);\n   if (cred.acl_commands.empty()) {\n     acl_commands = std::vector<uint64_t>(acl::NumberOfFamilies(), acl::NONE_COMMANDS);\n   } else {\n@@ -102,6 +103,7 @@ ConnectionContext::ConnectionContext(const ConnectionContext* owner, Transaction\n   if (owner) {\n     acl_commands = owner->acl_commands;\n     keys = owner->keys;\n+    pub_sub = owner->pub_sub;\n     skip_acl_validation = owner->skip_acl_validation;\n     ns = owner->ns;\n   } else {\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex ceee2742bebf..d88494f8daee 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1706,6 +1706,7 @@ bool ServerFamily::DoAuth(ConnectionContext* cntx, std::string_view username,\n     auto cred = registry->GetCredentials(username);\n     cntx->acl_commands = cred.acl_commands;\n     cntx->keys = std::move(cred.keys);\n+    cntx->pub_sub = std::move(cred.pub_sub);\n     cntx->ns = &namespaces.GetOrInsert(cred.ns);\n     cntx->authenticated = true;\n   }\n",
  "test_patch": "diff --git a/src/server/acl/acl_family_test.cc b/src/server/acl/acl_family_test.cc\nindex 7c41ed4042fc..c1f2f83e81ac 100644\n--- a/src/server/acl/acl_family_test.cc\n+++ b/src/server/acl/acl_family_test.cc\n@@ -48,15 +48,16 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   EXPECT_THAT(resp, \"OK\");\n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* +@all\", \"user vlad off -@all\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                        \"user vlad off resetchannels -@all\"));\n \n   resp = Run({\"ACL\", \"SETUSER\", \"vlad\", \"+ACL\"});\n   EXPECT_THAT(resp, \"OK\");\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec,\n-              UnorderedElementsAre(\"user default on nopass ~* +@all\", \"user vlad off -@all +acl\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                        \"user vlad off resetchannels -@all +acl\"));\n \n   resp = Run({\"ACL\", \"SETUSER\", \"vlad\", \"on\", \">pass\", \">temp\"});\n   EXPECT_THAT(resp, \"OK\");\n@@ -65,9 +66,11 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   vec = resp.GetVec();\n   EXPECT_THAT(vec.size(), 2);\n   auto contains_vlad = [](const auto& vec) {\n-    const std::string default_user = \"user default on nopass ~* +@all\";\n-    const std::string a_permutation = \"user vlad on #a6864eb339b0e1f #d74ff0ee8da3b98 -@all +acl\";\n-    const std::string b_permutation = \"user vlad on #d74ff0ee8da3b98 #a6864eb339b0e1f -@all +acl\";\n+    const std::string default_user = \"user default on nopass ~* &* +@all\";\n+    const std::string a_permutation =\n+        \"user vlad on #a6864eb339b0e1f #d74ff0ee8da3b98 resetchannels -@all +acl\";\n+    const std::string b_permutation =\n+        \"user vlad on #d74ff0ee8da3b98 #a6864eb339b0e1f resetchannels -@all +acl\";\n     std::string_view other;\n     if (vec[0] == default_user) {\n       other = vec[1].GetView();\n@@ -107,8 +110,8 @@ TEST_F(AclFamilyTest, AclSetUser) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec,\n-              UnorderedElementsAre(\"user default on nopass ~* +@all\", \"user vlad on -@all +acl\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                        \"user vlad on resetchannels -@all +acl\"));\n \n   // +@NONE should not exist anymore. It's not in the spec.\n   resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"+@NONE\"});\n@@ -139,7 +142,7 @@ TEST_F(AclFamilyTest, AclDelUser) {\n   EXPECT_THAT(resp, IntArg(0));\n \n   resp = Run({\"ACL\", \"LIST\"});\n-  EXPECT_THAT(resp.GetString(), \"user default on nopass ~* +@all\");\n+  EXPECT_THAT(resp.GetString(), \"user default on nopass ~* &* +@all\");\n \n   Run({\"ACL\", \"SETUSER\", \"michael\", \"ON\"});\n   Run({\"ACL\", \"SETUSER\", \"kobe\", \"ON\"});\n@@ -160,9 +163,10 @@ TEST_F(AclFamilyTest, AclList) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* +@all\",\n-                                        \"user kostas off #d74ff0ee8da3b98 -@all +@admin\",\n-                                        \"user adi off #d74ff0ee8da3b98 -@all +@fast\"));\n+  EXPECT_THAT(vec,\n+              UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                   \"user kostas off #d74ff0ee8da3b98 resetchannels -@all +@admin\",\n+                                   \"user adi off #d74ff0ee8da3b98 resetchannels -@all +@fast\"));\n }\n \n TEST_F(AclFamilyTest, AclAuth) {\n@@ -210,17 +214,19 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n       EXPECT_THAT(resp, \"OK\");\n \n       resp = Run({\"ACL\", \"LIST\"});\n-      EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"user default on nopass ~* +@all\",\n-                                                      absl::StrCat(\"user kostas off -@all \", \"+@\",\n-                                                                   absl::AsciiStrToLower(cat))));\n+      EXPECT_THAT(resp.GetVec(),\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                       absl::StrCat(\"user kostas off resetchannels -@all \", \"+@\",\n+                                                    absl::AsciiStrToLower(cat))));\n \n       resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-@\", cat)});\n       EXPECT_THAT(resp, \"OK\");\n \n       resp = Run({\"ACL\", \"LIST\"});\n-      EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"user default on nopass ~* +@all\",\n-                                                      absl::StrCat(\"user kostas off -@all \", \"-@\",\n-                                                                   absl::AsciiStrToLower(cat))));\n+      EXPECT_THAT(resp.GetVec(),\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                       absl::StrCat(\"user kostas off resetchannels -@all \", \"-@\",\n+                                                    absl::AsciiStrToLower(cat))));\n \n       resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n       EXPECT_THAT(resp, IntArg(1));\n@@ -259,16 +265,16 @@ TEST_F(AclFamilyTest, TestAllCommands) {\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* +@all\",\n-                                       absl::StrCat(\"user kostas off -@all \", \"+\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                       absl::StrCat(\"user kostas off resetchannels -@all \", \"+\",\n                                                     absl::AsciiStrToLower(command_name))));\n \n       resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-\", command_name)});\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* +@all\",\n-                                       absl::StrCat(\"user kostas off \", \"-@all \", \"-\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                       absl::StrCat(\"user kostas off resetchannels -@all \", \"-\",\n                                                     absl::AsciiStrToLower(command_name))));\n \n       resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n@@ -321,6 +327,8 @@ TEST_F(AclFamilyTest, TestGetUser) {\n   EXPECT_THAT(vec[5], \"+@all\");\n   EXPECT_THAT(vec[6], \"keys\");\n   EXPECT_THAT(vec[7], \"~*\");\n+  EXPECT_THAT(vec[8], \"channels\");\n+  EXPECT_THAT(vec[9], \"&*\");\n \n   resp = Run({\"ACL\", \"SETUSER\", \"kostas\", \"+@STRING\", \"+HSET\"});\n   resp = Run({\"ACL\", \"GETUSER\", \"kostas\"});\n@@ -331,6 +339,10 @@ TEST_F(AclFamilyTest, TestGetUser) {\n   EXPECT_TRUE(kvec[3].GetVec().empty());\n   EXPECT_THAT(kvec[4], \"commands\");\n   EXPECT_THAT(kvec[5], \"-@all +@string +hset\");\n+  EXPECT_THAT(kvec[6], \"keys\");\n+  EXPECT_THAT(kvec[7], RespArray(ElementsAre()));\n+  EXPECT_THAT(kvec[8], \"channels\");\n+  EXPECT_THAT(kvec[9], \"resetchannels\");\n }\n \n TEST_F(AclFamilyTest, TestDryRun) {\n@@ -431,7 +443,7 @@ TEST_F(AclFamilyTest, TestKeys) {\n   EXPECT_THAT(vec[7], \"~foo ~bar*\");\n \n   resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"~*\", \"~foo\"});\n-  EXPECT_THAT(resp, ErrArg(\"ERR Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * \"\n+  EXPECT_THAT(resp, ErrArg(\"ERR Error in ACL SETUSER modifier '~foo': Adding a pattern after the * \"\n                            \"pattern (or the 'allkeys' flag) is not valid and does not have any \"\n                            \"effect. Try 'resetkeys' to start with an empty list of patterns\"));\n \n@@ -439,7 +451,7 @@ TEST_F(AclFamilyTest, TestKeys) {\n   EXPECT_THAT(resp, \"OK\");\n \n   resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"~foo\"});\n-  EXPECT_THAT(resp, ErrArg(\"ERR Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * \"\n+  EXPECT_THAT(resp, ErrArg(\"ERR Error in ACL SETUSER modifier '~foo': Adding a pattern after the * \"\n                            \"pattern (or the 'allkeys' flag) is not valid and does not have any \"\n                            \"effect. Try 'resetkeys' to start with an empty list of patterns\"));\n \n@@ -474,4 +486,37 @@ TEST_F(AclFamilyTest, TestKeys) {\n   EXPECT_THAT(resp, ErrArg(\"ERR Unrecognized parameter %RFOO\"));\n }\n \n+TEST_F(AclFamilyTest, TestPubSub) {\n+  TestInitAclFam();\n+\n+  auto resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"&foo\", \"&b*r\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"ACL\", \"GETUSER\", \"temp\"});\n+  auto vec = resp.GetVec();\n+  EXPECT_THAT(vec[8], \"channels\");\n+  EXPECT_THAT(vec[9], \"resetchannels &foo &b*r\");\n+\n+  resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"allchannels\", \"&bar\"});\n+  EXPECT_THAT(resp, ErrArg(\"ERR Error in ACL SETUSER modifier '&bar': Adding a pattern after the * \"\n+                           \"pattern (or the 'allchannels' flag) is \"\n+                           \"not valid and does not have any effect. Try 'resetchannels' to start \"\n+                           \"with an empty list of channels\"));\n+\n+  resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"allchannels\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"ACL\", \"GETUSER\", \"temp\"});\n+  vec = resp.GetVec();\n+  EXPECT_THAT(vec[8], \"channels\");\n+  EXPECT_THAT(vec[9], \"&*\");\n+\n+  resp = Run({\"ACL\", \"SETUSER\", \"temp\", \"resetchannels\", \"&foo\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"ACL\", \"GETUSER\", \"temp\"});\n+  vec = resp.GetVec();\n+  EXPECT_THAT(vec[8], \"channels\");\n+  EXPECT_THAT(vec[9], \"resetchannels &foo\");\n+}\n }  // namespace dfly\ndiff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex f7ae8ecead3b..81ee14ea61ec 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -7,60 +7,69 @@\n import asyncio\n import os\n from . import dfly_args\n+import async_timeout\n \n \n @pytest.mark.asyncio\n async def test_acl_setuser(async_client):\n     await async_client.execute_command(\"ACL SETUSER kostas\")\n-    result = await async_client.execute_command(\"ACL list\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n     assert 2 == len(result)\n-    assert \"user kostas off -@all\" in result\n+    assert \"user kostas off resetchannels -@all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas ON\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@all\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on resetchannels -@all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas +@list +@string +@admin\")\n-    result = await async_client.execute_command(\"ACL list\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n     # TODO consider printing to lowercase\n-    assert \"user kostas on -@all +@list +@string +@admin\" in result\n+    assert \"user kostas on resetchannels -@all +@list +@string +@admin\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas -@list -@admin\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@all +@string -@list -@admin\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on resetchannels -@all +@string -@list -@admin\" in result\n \n     # mix and match\n     await async_client.execute_command(\"ACL SETUSER kostas +@list -@string\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@all -@admin +@list -@string\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on resetchannels -@all -@admin +@list -@string\" in result\n \n     # mix and match interleaved\n     await async_client.execute_command(\"ACL SETUSER kostas +@set -@set +@set\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@all -@admin +@list -@string +@set\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on resetchannels -@all -@admin +@list -@string +@set\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas +@all\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@admin +@list -@string +@set +@all\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on resetchannels -@admin +@list -@string +@set +@all\" in result\n \n     # commands\n     await async_client.execute_command(\"ACL SETUSER kostas +set +get +hset\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@admin +@list -@string +@set +@all +set +get +hset\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert (\n+        \"user kostas on resetchannels -@admin +@list -@string +@set +@all +set +get +hset\" in result\n+    )\n \n     await async_client.execute_command(\"ACL SETUSER kostas -set -get +hset\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@admin +@list -@string +@set +@all -set -get +hset\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert (\n+        \"user kostas on resetchannels -@admin +@list -@string +@set +@all -set -get +hset\" in result\n+    )\n \n     # interleaved\n     await async_client.execute_command(\"ACL SETUSER kostas -hset +get -get -@all\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@admin +@list -@string +@set -set -hset -get -@all\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert (\n+        \"user kostas on resetchannels -@admin +@list -@string +@set -set -hset -get -@all\" in result\n+    )\n \n     # interleaved with categories\n     await async_client.execute_command(\"ACL SETUSER kostas +@string +get -get +set\")\n-    result = await async_client.execute_command(\"ACL list\")\n-    assert \"user kostas on -@admin +@list +@set -hset -@all +@string -get +set\" in result\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert (\n+        \"user kostas on resetchannels -@admin +@list +@set -hset -@all +@string -get +set\" in result\n+    )\n \n \n @pytest.mark.asyncio\n@@ -324,7 +333,7 @@ async def test_bad_acl_file(df_factory, tmp_dir):\n async def test_good_acl_file(df_factory, tmp_dir):\n     # The hash below is password temp\n     acl = create_temp_file(\n-        \"USER MrFoo ON #a6864eb339b0e1f6e00d75293a8840abf069a2c0fe82e6e53af6ac099793c1d5 >mypass\",\n+        \"USER MrFoo ON #a6864eb339b0e1f6e00d75293a8840abf069a2c0fe82e6e53af6ac099793c1d5 >mypass &bar &r*nd\",\n         tmp_dir,\n     )\n     df = df_factory.create(aclfile=acl)\n@@ -333,13 +342,14 @@ async def test_good_acl_file(df_factory, tmp_dir):\n     client = df.client()\n \n     await client.execute_command(\"ACL LOAD\")\n-    result = await client.execute_command(\"ACL list\")\n+    result = await client.execute_command(\"ACL LIST\")\n     assert 2 == len(result)\n     assert (\n-        \"user MrFoo on #ea71c25a7a60224 #a6864eb339b0e1f -@all\" in result\n-        or \"user MrFoo on #a6864eb339b0e1f #ea71c25a7a60224 -@all\" in result\n+        \"user MrFoo on #ea71c25a7a60224 #a6864eb339b0e1f resetchannels &bar &r*nd -@all\" in result\n+        or \"user MrFoo on #a6864eb339b0e1f #ea71c25a7a60224 resetchannels &bar &r*nd -@all\"\n+        in result\n     )\n-    assert \"user default on nopass ~* +@all\" in result\n+    assert \"user default on nopass ~* &* +@all\" in result\n     await client.execute_command(\"ACL SETUSER MrFoo +@all\")\n     # Check multiple passwords work\n     assert \"OK\" == await client.execute_command(\"AUTH mypass\")\n@@ -351,12 +361,12 @@ async def test_good_acl_file(df_factory, tmp_dir):\n     await client.execute_command(\"ACL SETUSER shahar >mypass +@set\")\n     await client.execute_command(\"ACL SETUSER vlad ~foo ~bar* +@string\")\n \n-    result = await client.execute_command(\"ACL list\")\n+    result = await client.execute_command(\"ACL LIST\")\n     assert 4 == len(result)\n-    assert \"user roy on #ea71c25a7a60224 -@all +@string +hset\" in result\n-    assert \"user shahar off #ea71c25a7a60224 -@all +@set\" in result\n-    assert \"user vlad off ~foo ~bar* -@all +@string\" in result\n-    assert \"user default on nopass ~* +@all\" in result\n+    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset\" in result\n+    assert \"user shahar off #ea71c25a7a60224 resetchannels -@all +@set\" in result\n+    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string\" in result\n+    assert \"user default on nopass ~* &* +@all\" in result\n \n     result = await client.execute_command(\"ACL DELUSER shahar\")\n     assert result == 1\n@@ -365,11 +375,11 @@ async def test_good_acl_file(df_factory, tmp_dir):\n \n     result = await client.execute_command(\"ACL LOAD\")\n \n-    result = await client.execute_command(\"ACL list\")\n+    result = await client.execute_command(\"ACL LIST\")\n     assert 3 == len(result)\n-    assert \"user roy on #ea71c25a7a60224 -@all +@string +hset\" in result\n-    assert \"user vlad off ~foo ~bar* -@all +@string\" in result\n-    assert \"user default on nopass ~* +@all\" in result\n+    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset\" in result\n+    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string\" in result\n+    assert \"user default on nopass ~* &* +@all\" in result\n \n     await client.close()\n \n@@ -483,7 +493,7 @@ async def test_set_acl_file(async_client: aioredis.Redis, tmp_dir):\n \n     await async_client.execute_command(\"ACL LOAD\")\n \n-    result = await async_client.execute_command(\"ACL list\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n     assert 3 == len(result)\n \n     result = await async_client.execute_command(\"AUTH roy mypass\")\n@@ -635,3 +645,83 @@ async def test_auth_resp3_bug(df_factory):\n     }\n \n     await client.close()\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_pub_sub_auth(df_factory):\n+    df = df_factory.create()\n+    df.start()\n+    client = df.client()\n+    await client.execute_command(\"ACL SETUSER kostas on >tmp +subscribe +psubscribe &f*o &bar\")\n+    assert await client.execute_command(\"AUTH kostas tmp\") == \"OK\"\n+\n+    res = await client.execute_command(\"SUBSCRIBE bar\")\n+    assert res == [\"subscribe\", \"bar\", 1]\n+\n+    res = await client.execute_command(\"SUBSCRIBE foo\")\n+    assert res == [\"subscribe\", \"foo\", 2]\n+\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        res = await client.execute_command(\"SUBSCRIBE my_channel\")\n+\n+    # PSUBSCRIBE only matches pure literals, no asterisks\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        res = await client.execute_command(\"PSUBSCRIBE foo\")\n+\n+    # my_channel is not in our list so the command should fail\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        res = await client.execute_command(\"PSUBSCRIBE bar my_channel\")\n+\n+    res = await client.execute_command(\"PSUBSCRIBE bar\")\n+    assert res == [\"psubscribe\", \"bar\", 3]\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_revoke_pub_sub_while_subscribed(df_factory):\n+    df = df_factory.create()\n+    df.start()\n+    publisher = df.client()\n+\n+    async def publish_worker(client):\n+        for i in range(0, 10):\n+            await client.publish(\"channel\", \"message\")\n+\n+    async def subscribe_worker(channel: aioredis.client.PubSub):\n+        total_msgs = 1\n+        async with async_timeout.timeout(10):\n+            while total_msgs != 10:\n+                res = await channel.get_message(ignore_subscribe_messages=True, timeout=5)\n+                if total_msgs is not None:\n+                    total_msgs = total_msgs + 1\n+\n+    await publisher.execute_command(\"ACL SETUSER kostas >tmp ON +@slow +SUBSCRIBE allchannels\")\n+\n+    subscriber = aioredis.Redis(\n+        username=\"kostas\", password=\"tmp\", port=df.port, decode_responses=True\n+    )\n+    subscriber_obj = subscriber.pubsub()\n+    await subscriber_obj.subscribe(\"channel\")\n+\n+    subscribe_task = asyncio.create_task(subscribe_worker(subscriber_obj))\n+    await publish_worker(publisher)\n+    await subscribe_task\n+\n+    subscribe_task = asyncio.create_task(subscribe_worker(subscriber_obj))\n+    # Already subscribed, we should still be able to receive messages on channel\n+    # We should not be able to unsubscribe\n+    await publisher.execute_command(\"ACL SETUSER kostas -SUBSCRIBE -UNSUBSCRIBE\")\n+    await publish_worker(publisher)\n+    await subscribe_task\n+    # unsubscribe is not marked async and it's such a mess that it throws the error\n+    # once we try to resubscribe. Instead I use the raw execute command to check that\n+    # permission changes work\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        await subscriber.execute_command(\"UNSUBSCRIBE channel\")\n+\n+    await publisher.execute_command(\"ACL SETUSER kostas +SUBSCRIBE +UNSUBSCRIBE\")\n+\n+    subscribe_task = asyncio.create_task(subscribe_worker(subscriber_obj))\n+    await publisher.execute_command(\"ACL SETUSER kostas resetchannels\")\n+    await publish_worker(publisher)\n+    with pytest.raises(redis.exceptions.ConnectionError):\n+        await subscribe_task\n",
  "problem_statement": "Add support for Pub/Sub ACLs\n**Did you search GitHub Issues and GitHub Discussions First?**\r\nYes\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nWe are implementing Dragonfly for a multi-tenant application. In order to not have to maintain a separate Dragonfly instance per tenant, we would like all tenants to use one common Dragonfly. ACLs would be used for tenant isolation.\r\n\r\nThe application, however, also uses Pub/Sub, and as stated in the [documentation](https://www.dragonflydb.io/docs/managing-dragonfly/acl) ACLs for pub/sub are not yet implemented, preventing us from using a common Dragonfly.\r\n\r\n**Describe the solution you'd like**\r\nImplement ACLs for Pub/Sub.\r\n\r\n**Describe alternatives you've considered**\r\nCommon Redis instead of Dragonfly\r\n\n",
  "hints_text": "Hi @Balsir , thank you for creating this issue. We are slightly packed atm but we will get back to this soon :) Seems like there is enough traction to pursue this \nThank you @kostasrim :)",
  "created_at": "2024-08-26T15:30:26Z",
  "modified_files": [
    "src/facade/acl_commands_def.h",
    "src/facade/command_id.h",
    "src/facade/conn_context.h",
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/facade/facade.cc",
    "src/server/acl/acl_family.cc",
    "src/server/acl/acl_family.h",
    "src/server/acl/acl_log.h",
    "src/server/acl/user.cc",
    "src/server/acl/user.h",
    "src/server/acl/user_registry.cc",
    "src/server/acl/validator.cc",
    "src/server/acl/validator.h",
    "src/server/conn_context.cc",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "src/server/acl/acl_family_test.cc",
    "tests/dragonfly/acl_family_test.py"
  ]
}