diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc
index ee32e2c7e9b8..289a6a0ab87a 100644
--- a/src/server/zset_family_test.cc
+++ b/src/server/zset_family_test.cc
@@ -4,6 +4,8 @@
 
 #include "server/zset_family.h"
 
+#include <vector>
+
 #include "base/gtest.h"
 #include "base/logging.h"
 #include "facade/facade_test.h"
@@ -906,6 +908,118 @@ TEST_F(ZSetFamilyTest, ZMPop) {
   EXPECT_THAT(resp, RespArray(ElementsAre("y1", "1")));
 }
 
+TEST_F(ZSetFamilyTest, BZMPopInvalidSyntax) {
+  // Not enough arguments.
+  auto resp = Run({"bzmpop", "1", "1", "a"});
+  EXPECT_THAT(resp, ErrArg("wrong number of arguments"));
+
+  // Zero keys.
+  resp = Run({"bzmpop", "1", "0", "MIN", "COUNT", "1"});
+  EXPECT_THAT(resp, ErrArg("at least 1 input key is needed"));
+
+  // Number of keys not uint.
+  resp = Run({"bzmpop", "1", "aa", "a", "MIN"});
+  EXPECT_THAT(resp, ErrArg("value is not an integer or out of range"));
+
+  // Missing MIN/MAX.
+  resp = Run({"bzmpop", "1", "1", "a", "COUNT", "1"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Wrong number of keys.
+  resp = Run({"bzmpop", "1", "1", "a", "b", "MAX"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Count with no number.
+  resp = Run({"bzmpop", "1", "1", "a", "MAX", "COUNT"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Count number is not uint.
+  resp = Run({"bzmpop", "1", "1", "a", "MIN", "COUNT", "boo"});
+  EXPECT_THAT(resp, ErrArg("value is not an integer or out of range"));
+
+  // Too many arguments.
+  resp = Run({"bzmpop", "1", "1", "c", "MAX", "COUNT", "2", "foo"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Negative time argument.
+  resp = Run({"bzmpop", "-1", "1", "a", "MIN"});
+  EXPECT_THAT(resp, ErrArg("timeout is negative"));
+}
+
+TEST_F(ZSetFamilyTest, BZMPop) {
+  // Min operation.
+  auto resp = Run({"zadd", "a", "1", "a1", "2", "a2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"bzmpop", "1", "1", "a", "MIN"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("a", {{"a1", "1"}}));
+
+  resp = Run({"ZRANGE", "a", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("a2", "2")));
+
+  // Max operation.
+  resp = Run({"zadd", "b", "1", "b1", "2", "b2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"bzmpop", "1", "1", "b", "MAX"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("b", {{"b2", "2"}}));
+
+  resp = Run({"ZRANGE", "b", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("b1", "1")));
+
+  // Count > 1.
+  resp = Run({"zadd", "c", "1", "c1", "2", "c2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"bzmpop", "1", "1", "c", "MAX", "COUNT", "2"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("c", {{"c1", "1"}, {"c2", "2"}}));
+
+  resp = Run({"zcard", "c"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  // Count > #elements in set.
+  resp = Run({"zadd", "d", "1", "d1", "2", "d2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"bzmpop", "1", "1", "d", "MAX", "COUNT", "3"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("d", {{"d1", "1"}, {"d2", "2"}}));
+
+  resp = Run({"zcard", "d"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  // First non empty set is not the first set.
+  resp = Run({"zadd", "x", "1", "x1"});
+  EXPECT_THAT(resp, IntArg(1));
+
+  resp = Run({"zadd", "y", "1", "y1"});
+  EXPECT_THAT(resp, IntArg(1));
+
+  resp = Run({"bzmpop", "1", "3", "empty", "x", "y", "MAX"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("x", {{"x1", "1"}}));
+
+  resp = Run({"zcard", "x"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  resp = Run({"ZRANGE", "y", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("y1", "1")));
+}
+
+TEST_F(ZSetFamilyTest, BMPOPBlockingTimeout) {
+  RespExpr resp0;
+
+  auto start = absl::Now();
+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {
+    resp0 = Run({"BZMPOP", "1", "1", "zset1", "MIN"});
+    LOG(INFO) << "BZMPOP";
+  });
+  fb0.Join();
+  auto dur = absl::Now() - start;
+
+  // Check that the timeout duration is not too crazy.
+  EXPECT_LT(AbsDuration(dur - absl::Milliseconds(1000)), absl::Milliseconds(300));
+  EXPECT_THAT(resp0, ArgType(RespExpr::NIL));
+}
+
 TEST_F(ZSetFamilyTest, ZPopMin) {
   auto resp = Run({"zadd", "key", "1", "a", "2", "b", "3", "c", "4", "d", "5", "e", "6", "f"});
   EXPECT_THAT(resp, IntArg(6));
@@ -1016,6 +1130,23 @@ TEST_F(ZSetFamilyTest, BlockingIsReleased) {
 
       Run({"DEL", key});
     }
+
+    // Tests for BZMPOP command
+    for (auto& cmd : unblocking_commands) {
+      RespExpr resp0;
+      auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {
+        resp0 = Run({"BZMPOP", "0", "3", "zset1", "zset2", "zset3", "MIN"});
+        LOG(INFO) << "BZMPOP";
+      });
+
+      pp_->at(1)->Await([&] { return Run({cmd.data(), cmd.size()}); });
+      fb0.Join();
+
+      ASSERT_THAT(resp0, ArrLen(2)) << cmd[0];
+      EXPECT_THAT(resp0, ContainsLabeledScoredArray(key, {{"x", "2"}})) << cmd[0];
+
+      Run({"DEL", key});
+    }
   }
 }
 
diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py
index cb298f1a5a13..2fa0a37be0d7 100644
--- a/tests/dragonfly/replication_test.py
+++ b/tests/dragonfly/replication_test.py
@@ -746,6 +746,24 @@ async def check_expire(key):
             [r"XTRIM k-stream MINID 0", r"SREM k-one-element-set value[12]"],
         )
 
+        # check BZMPOP turns into ZPOPMAX and ZPOPMIN command
+        await c_master.zadd("key", {"a": 1, "b": 2, "c": 3})
+        await skip_cmd()
+        await check("BZMPOP 0 3 key3 key2 key MAX COUNT 3", r"ZPOPMAX key 3")
+
+        await c_master.zadd("key", {"a": 1, "b": 2, "c": 3})
+        await skip_cmd()
+        await check("BZMPOP 0 3 key3 key2 key MIN", r"ZPOPMIN key 1")
+
+        # Check ZMPOP turns into ZPOPMAX and ZPOPMIN commands
+        await c_master.zadd("key", {"a": 1, "b": 2, "c": 3})
+        await skip_cmd()
+        await check("ZMPOP 3 key3 key2 key MIN COUNT 3", r"ZPOPMIN key 3")
+
+        await c_master.zadd("key", {"a": 1, "b": 2, "c": 3})
+        await skip_cmd()
+        await check("ZMPOP 3 key3 key2 key MAX", r"ZPOPMAX key 1")
+
 
 """
 Test automatic replication of expiry.
