{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3599,
  "instance_id": "dragonflydb__dragonfly-3599",
  "issue_numbers": [
    "3471"
  ],
  "base_commit": "79a80a0b06ae5f881dc3bd78373c41fee2efcae3",
  "patch": "diff --git a/src/facade/cmd_arg_parser.cc b/src/facade/cmd_arg_parser.cc\nindex ec6621dfba95..2c6f3cf601e8 100644\n--- a/src/facade/cmd_arg_parser.cc\n+++ b/src/facade/cmd_arg_parser.cc\n@@ -5,7 +5,6 @@\n #include \"facade/cmd_arg_parser.h\"\n \n #include <absl/strings/ascii.h>\n-#include <absl/strings/match.h>\n \n #include \"base/logging.h\"\n #include \"facade/error.h\"\n@@ -17,7 +16,7 @@ CmdArgParser::CheckProxy::operator bool() const {\n     return false;\n \n   std::string_view arg = parser_->SafeSV(idx_);\n-  if ((!ignore_case_ && arg != tag_) || (ignore_case_ && !absl::EqualsIgnoreCase(arg, tag_)))\n+  if (!absl::EqualsIgnoreCase(arg, tag_))\n     return false;\n \n   if (idx_ + expect_tail_ >= parser_->args_.size()) {\n@@ -27,9 +26,6 @@ CmdArgParser::CheckProxy::operator bool() const {\n \n   parser_->cur_i_++;\n \n-  if (size_t uidx = idx_ + expect_tail_ + 1; next_upper_ && uidx < parser_->args_.size())\n-    parser_->ToUpper(uidx);\n-\n   return true;\n }\n \ndiff --git a/src/facade/cmd_arg_parser.h b/src/facade/cmd_arg_parser.h\nindex 5f4fdaad5fa1..78f0ededf86a 100644\n--- a/src/facade/cmd_arg_parser.h\n+++ b/src/facade/cmd_arg_parser.h\n@@ -4,6 +4,7 @@\n \n #pragma once\n \n+#include <absl/strings/match.h>\n #include <absl/strings/numbers.h>\n \n #include <optional>\n@@ -28,17 +29,6 @@ struct CmdArgParser {\n       return *this;\n     }\n \n-    // Call ToUpper on the next value after the flag and its expected tail.\n-    CheckProxy& NextUpper() {\n-      next_upper_ = true;\n-      return *this;\n-    }\n-\n-    CheckProxy& IgnoreCase() {\n-      ignore_case_ = true;\n-      return *this;\n-    }\n-\n    private:\n     friend struct CmdArgParser;\n \n@@ -50,8 +40,6 @@ struct CmdArgParser {\n     std::string_view tag_;\n     size_t idx_;\n     size_t expect_tail_ = 0;\n-    bool next_upper_ = false;\n-    bool ignore_case_ = false;\n   };\n \n   struct ErrorInfo {\n@@ -157,7 +145,7 @@ struct CmdArgParser {\n   template <class T, class... Cases>\n   std::optional<std::decay_t<T>> SwitchImpl(std::string_view arg, std::string_view tag, T&& value,\n                                             Cases&&... cases) {\n-    if (arg == tag)\n+    if (absl::EqualsIgnoreCase(arg, tag))\n       return std::forward<T>(value);\n \n     if constexpr (sizeof...(cases) > 0)\ndiff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex 46c3306e6444..c86a4d16eca7 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -1015,7 +1015,7 @@ nonstd::expected<CommandList, std::string> ParseToCommandList(CmdArgList args, b\n         make_unexpected(\"BITFIELD_RO only supports the GET subcommand\");\n       }\n       using pol = Overflow::Policy;\n-      auto res = parser.ToUpper().Switch(\"SAT\", pol::SAT, \"WRAP\", pol::WRAP, \"FAIL\", pol::FAIL);\n+      auto res = parser.Switch(\"SAT\", pol::SAT, \"WRAP\", pol::WRAP, \"FAIL\", pol::FAIL);\n       if (!parser.HasError()) {\n         result.push_back(Overflow{res});\n         continue;\n@@ -1039,7 +1039,7 @@ nonstd::expected<CommandList, std::string> ParseToCommandList(CmdArgList args, b\n       return make_unexpected(\"BITFIELD_RO only supports the GET subcommand\");\n     }\n \n-    auto value = parser.ToUpper().Next<int64_t>();\n+    auto value = parser.Next<int64_t>();\n     if (parser.HasError()) {\n       parser.Error();\n       return make_unexpected(kSyntaxErr);\ndiff --git a/src/server/dflycmd.cc b/src/server/dflycmd.cc\nindex 98baba656d23..1e6ab3c9ae1b 100644\n--- a/src/server/dflycmd.cc\n+++ b/src/server/dflycmd.cc\n@@ -404,7 +404,7 @@ void DflyCmd::TakeOver(CmdArgList args, ConnectionContext* cntx) {\n     return cntx->SendError(\"timeout is negative\");\n   }\n \n-  bool save_flag = static_cast<bool>(parser.Check(\"SAVE\").IgnoreCase());\n+  bool save_flag = static_cast<bool>(parser.Check(\"SAVE\"));\n \n   string_view sync_id_str = parser.Next<std::string_view>();\n \ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex 93bbd00f2da4..dd22870b4ed1 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -731,7 +731,7 @@ void HSetEx(CmdArgList args, ConnectionContext* cntx) {\n \n   string_view key = parser.Next();\n \n-  bool skip_if_exists = static_cast<bool>(parser.Check(\"NX\"sv).IgnoreCase());\n+  bool skip_if_exists = static_cast<bool>(parser.Check(\"NX\"sv));\n   string_view ttl_str = parser.Next();\n \n   uint32_t ttl_sec;\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex d3a2a5d6baf4..e7609732ab8b 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -1838,15 +1838,15 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n   vector<pair<string_view, WrappedJsonPath>> paths;\n \n   while (parser.HasNext()) {\n-    if (parser.Check(\"SPACE\").IgnoreCase().ExpectTail(1)) {\n+    if (parser.Check(\"SPACE\").ExpectTail(1)) {\n       space = parser.Next();\n       continue;\n     }\n-    if (parser.Check(\"NEWLINE\").IgnoreCase().ExpectTail(1)) {\n+    if (parser.Check(\"NEWLINE\").ExpectTail(1)) {\n       new_line = parser.Next();\n       continue;\n     }\n-    if (parser.Check(\"INDENT\").IgnoreCase().ExpectTail(1)) {\n+    if (parser.Check(\"INDENT\").ExpectTail(1)) {\n       indent = parser.Next();\n       continue;\n     }\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 50f1a1962a51..40cb14da7fd6 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -100,7 +100,6 @@ string ListPop(ListDir dir, quicklist* ql) {\n }\n \n ListDir ParseDir(facade::CmdArgParser* parser) {\n-  parser->ToUpper();\n   return parser->Switch(\"LEFT\", ListDir::LEFT, \"RIGHT\", ListDir::RIGHT);\n }\n \n@@ -902,7 +901,7 @@ void ListFamily::LPos(CmdArgList args, ConnectionContext* cntx) {\n   uint32_t max_len = 0;\n   bool skip_count = true;\n \n-  while (parser.ToUpper().HasNext()) {\n+  while (parser.HasNext()) {\n     if (parser.Check(\"RANK\").ExpectTail(1)) {\n       rank = parser.Next<int>();\n       continue;\n@@ -986,7 +985,7 @@ void ListFamily::LIndex(CmdArgList args, ConnectionContext* cntx) {\n void ListFamily::LInsert(CmdArgList args, ConnectionContext* cntx) {\n   facade::CmdArgParser parser{args};\n   string_view key = parser.Next();\n-  InsertParam where = parser.ToUpper().Switch(\"AFTER\", INSERT_AFTER, \"BEFORE\", INSERT_BEFORE);\n+  InsertParam where = parser.Switch(\"AFTER\", INSERT_AFTER, \"BEFORE\", INSERT_BEFORE);\n   auto [pivot, elem] = parser.Next<string_view, string_view>();\n \n   if (auto err = parser.Error(); err)\ndiff --git a/src/server/search/doc_index.cc b/src/server/search/doc_index.cc\nindex cb7a4e548ec5..00e05ab18cfc 100644\n--- a/src/server/search/doc_index.cc\n+++ b/src/server/search/doc_index.cc\n@@ -49,12 +49,6 @@ void TraverseAllMatching(const DocIndex& index, const OpArgs& op_args, F&& f) {\n   } while (cursor);\n }\n \n-const absl::flat_hash_map<string_view, search::SchemaField::FieldType> kSchemaTypes = {\n-    {\"TAG\"sv, search::SchemaField::TAG},\n-    {\"TEXT\"sv, search::SchemaField::TEXT},\n-    {\"NUMERIC\"sv, search::SchemaField::NUMERIC},\n-    {\"VECTOR\"sv, search::SchemaField::VECTOR}};\n-\n }  // namespace\n \n bool SerializedSearchDoc::operator<(const SerializedSearchDoc& other) const {\n@@ -70,15 +64,17 @@ bool SearchParams::ShouldReturnField(std::string_view field) const {\n   return !return_fields || any_of(return_fields->begin(), return_fields->end(), cb);\n }\n \n-optional<search::SchemaField::FieldType> ParseSearchFieldType(string_view name) {\n-  auto it = kSchemaTypes.find(name);\n-  return it != kSchemaTypes.end() ? make_optional(it->second) : nullopt;\n-}\n-\n string_view SearchFieldTypeToString(search::SchemaField::FieldType type) {\n-  for (auto [it_name, it_type] : kSchemaTypes)\n-    if (it_type == type)\n-      return it_name;\n+  switch (type) {\n+    case search::SchemaField::TAG:\n+      return \"TAG\";\n+    case search::SchemaField::TEXT:\n+      return \"TEXT\";\n+    case search::SchemaField::NUMERIC:\n+      return \"NUMERIC\";\n+    case search::SchemaField::VECTOR:\n+      return \"VECTOR\";\n+  }\n   ABSL_UNREACHABLE();\n   return \"\";\n }\ndiff --git a/src/server/search/doc_index.h b/src/server/search/doc_index.h\nindex f0fd6f421dc4..5df07cd2d930 100644\n--- a/src/server/search/doc_index.h\n+++ b/src/server/search/doc_index.h\n@@ -22,7 +22,6 @@ namespace dfly {\n \n using SearchDocData = absl::flat_hash_map<std::string /*field*/, std::string /*value*/>;\n \n-std::optional<search::SchemaField::FieldType> ParseSearchFieldType(std::string_view name);\n std::string_view SearchFieldTypeToString(search::SchemaField::FieldType);\n \n struct SerializedSearchDoc {\ndiff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex b5163cd6c486..9d1f72cdba17 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -47,20 +47,18 @@ bool IsValidJsonPath(string_view path) {\n search::SchemaField::VectorParams ParseVectorParams(CmdArgParser* parser) {\n   search::SchemaField::VectorParams params{};\n \n-  params.use_hnsw = parser->ToUpper().Switch(\"HNSW\", true, \"FLAT\", false);\n+  params.use_hnsw = parser->Switch(\"HNSW\", true, \"FLAT\", false);\n   size_t num_args = parser->Next<size_t>();\n \n   for (size_t i = 0; i * 2 < num_args; i++) {\n-    parser->ToUpper();\n-\n     if (parser->Check(\"DIM\").ExpectTail(1)) {\n       params.dim = parser->Next<size_t>();\n       continue;\n     }\n \n     if (parser->Check(\"DISTANCE_METRIC\").ExpectTail(1)) {\n-      params.sim = parser->ToUpper().Switch(\"L2\", search::VectorSimilarity::L2, \"COSINE\",\n-                                            search::VectorSimilarity::COSINE);\n+      params.sim = parser->Switch(\"L2\", search::VectorSimilarity::L2, \"COSINE\",\n+                                  search::VectorSimilarity::COSINE);\n       continue;\n     }\n \n@@ -100,13 +98,13 @@ search::SchemaField::VectorParams ParseVectorParams(CmdArgParser* parser) {\n search::SchemaField::TagParams ParseTagParams(CmdArgParser* parser) {\n   search::SchemaField::TagParams params{};\n   while (parser->HasNext()) {\n-    if (parser->Check(\"SEPARATOR\").IgnoreCase().ExpectTail(1)) {\n+    if (parser->Check(\"SEPARATOR\").ExpectTail(1)) {\n       string_view separator = parser->Next();\n       params.separator = separator.front();\n       continue;\n     }\n \n-    if (parser->Check(\"CASESENSITIVE\").IgnoreCase()) {\n+    if (parser->Check(\"CASESENSITIVE\")) {\n       params.case_sensitive = true;\n       continue;\n     }\n@@ -137,26 +135,25 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse\n       return nullopt;\n     }\n \n-    parser.ToUpper();\n-\n     // AS [alias]\n-    if (parser.Check(\"AS\").ExpectTail(1).NextUpper())\n+    if (parser.Check(\"AS\").ExpectTail(1))\n       field_alias = parser.Next();\n \n     // Determine type\n-    string_view type_str = parser.Next();\n-    auto type = ParseSearchFieldType(type_str);\n-    if (!type) {\n-      cntx->SendError(\"Invalid field type: \" + string{type_str});\n+    using search::SchemaField;\n+    auto type = parser.Switch(\"TAG\", SchemaField::TAG, \"TEXT\", SchemaField::TEXT, \"NUMERIC\",\n+                              SchemaField::NUMERIC, \"VECTOR\", SchemaField::VECTOR);\n+    if (auto err = parser.Error(); err) {\n+      cntx->SendError(err->MakeReply());\n       return nullopt;\n     }\n \n     // Tag fields include: [separator char] [casesensitive]\n     // Vector fields include: {algorithm} num_args args...\n     search::SchemaField::ParamsVariant params(monostate{});\n-    if (*type == search::SchemaField::TAG) {\n+    if (type == search::SchemaField::TAG) {\n       params = ParseTagParams(&parser);\n-    } else if (*type == search::SchemaField::VECTOR) {\n+    } else if (type == search::SchemaField::VECTOR) {\n       auto vector_params = ParseVectorParams(&parser);\n       if (parser.HasError()) {\n         auto err = *parser.Error();\n@@ -175,12 +172,12 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse\n     // Flags: check for SORTABLE and NOINDEX\n     uint8_t flags = 0;\n     while (parser.HasNext()) {\n-      if (parser.Check(\"NOINDEX\").IgnoreCase()) {\n+      if (parser.Check(\"NOINDEX\")) {\n         flags |= search::SchemaField::NOINDEX;\n         continue;\n       }\n \n-      if (parser.Check(\"SORTABLE\").IgnoreCase()) {\n+      if (parser.Check(\"SORTABLE\")) {\n         flags |= search::SchemaField::SORTABLE;\n         continue;\n       }\n@@ -192,7 +189,7 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse\n     while (kIgnoredOptions.count(parser.Peek()) > 0)\n       parser.Skip(2);\n \n-    schema.fields[field] = {*type, flags, string{field_alias}, std::move(params)};\n+    schema.fields[field] = {type, flags, string{field_alias}, std::move(params)};\n   }\n \n   // Build field name mapping table\n@@ -224,7 +221,7 @@ search::QueryParams ParseQueryParams(CmdArgParser* parser) {\n optional<SearchParams> ParseSearchParamsOrReply(CmdArgParser parser, ConnectionContext* cntx) {\n   SearchParams params;\n \n-  while (parser.ToUpper().HasNext()) {\n+  while (parser.HasNext()) {\n     // [LIMIT offset total]\n     if (parser.Check(\"LIMIT\").ExpectTail(2)) {\n       params.limit_offset = parser.Next<size_t>();\n@@ -238,7 +235,7 @@ optional<SearchParams> ParseSearchParamsOrReply(CmdArgParser parser, ConnectionC\n       params.return_fields = SearchParams::FieldReturnList{};\n       while (params.return_fields->size() < num_fields) {\n         string_view ident = parser.Next();\n-        string_view alias = parser.Check(\"AS\").IgnoreCase().ExpectTail(1) ? parser.Next() : ident;\n+        string_view alias = parser.Check(\"AS\").ExpectTail(1) ? parser.Next() : ident;\n         params.return_fields->emplace_back(ident, alias);\n       }\n       continue;\n@@ -257,8 +254,7 @@ optional<SearchParams> ParseSearchParamsOrReply(CmdArgParser parser, ConnectionC\n     }\n \n     if (parser.Check(\"SORTBY\").ExpectTail(1)) {\n-      params.sort_option =\n-          search::SortOption{string{parser.Next()}, bool(parser.Check(\"DESC\").IgnoreCase())};\n+      params.sort_option = search::SortOption{string{parser.Next()}, bool(parser.Check(\"DESC\"))};\n       continue;\n     }\n \n@@ -287,7 +283,7 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n   AggregateParams params;\n   tie(params.index, params.query) = parser.Next<string_view, string_view>();\n \n-  while (parser.ToUpper().HasNext()) {\n+  while (parser.HasNext()) {\n     // LOAD count field [field ...]\n     if (parser.Check(\"LOAD\").ExpectTail(1)) {\n       params.load_fields.resize(parser.Next<size_t>());\n@@ -303,7 +299,7 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n         field = parser.Next();\n \n       vector<aggregate::Reducer> reducers;\n-      while (parser.ToUpper().Check(\"REDUCE\").ExpectTail(2)) {\n+      while (parser.Check(\"REDUCE\").ExpectTail(2)) {\n         parser.ToUpper();  // uppercase for func_name\n         auto [func_name, nargs] = parser.Next<string_view, size_t>();\n         auto func = aggregate::FindReducerFunc(func_name);\n@@ -332,7 +328,7 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n     if (parser.Check(\"SORTBY\").ExpectTail(1)) {\n       parser.ExpectTag(\"1\");\n       string_view field = parser.Next();\n-      bool desc = bool(parser.Check(\"DESC\").IgnoreCase());\n+      bool desc = bool(parser.Check(\"DESC\"));\n \n       params.steps.push_back(aggregate::MakeSortStep(field, desc));\n       continue;\n@@ -471,10 +467,10 @@ void SearchFamily::FtCreate(CmdArgList args, ConnectionContext* cntx) {\n   CmdArgParser parser{args};\n   string_view idx_name = parser.Next();\n \n-  while (parser.ToUpper().HasNext()) {\n+  while (parser.HasNext()) {\n     // ON HASH | JSON\n     if (parser.Check(\"ON\").ExpectTail(1)) {\n-      index.type = parser.ToUpper().Switch(\"HASH\"sv, DocIndex::HASH, \"JSON\"sv, DocIndex::JSON);\n+      index.type = parser.Switch(\"HASH\"sv, DocIndex::HASH, \"JSON\"sv, DocIndex::JSON);\n       continue;\n     }\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex bd217862d1f1..a6b6763ecd9a 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -435,7 +435,7 @@ void ClientPauseCmd(CmdArgList args, vector<facade::Listener*> listeners, Connec\n   auto timeout = parser.Next<uint64_t>();\n   ClientPause pause_state = ClientPause::ALL;\n   if (parser.HasNext()) {\n-    pause_state = parser.ToUpper().Switch(\"WRITE\", ClientPause::WRITE, \"ALL\", ClientPause::ALL);\n+    pause_state = parser.Switch(\"WRITE\", ClientPause::WRITE, \"ALL\", ClientPause::ALL);\n   }\n   if (auto err = parser.Error(); err) {\n     return cntx->SendError(err->MakeReply());\n@@ -470,20 +470,20 @@ void ClientTracking(CmdArgList args, ConnectionContext* cntx) {\n   bool is_on = false;\n   using Tracking = ConnectionState::ClientTracking;\n   Tracking::Options option = Tracking::NONE;\n-  if (parser.Check(\"ON\").IgnoreCase()) {\n+  if (parser.Check(\"ON\")) {\n     is_on = true;\n-  } else if (!parser.Check(\"OFF\").IgnoreCase()) {\n+  } else if (!parser.Check(\"OFF\")) {\n     return cntx->SendError(kSyntaxErr);\n   }\n \n   bool noloop = false;\n \n   if (parser.HasNext()) {\n-    if (parser.Check(\"OPTIN\").IgnoreCase()) {\n+    if (parser.Check(\"OPTIN\")) {\n       option = Tracking::OPTIN;\n-    } else if (parser.Check(\"OPTOUT\").IgnoreCase()) {\n+    } else if (parser.Check(\"OPTOUT\")) {\n       option = Tracking::OPTOUT;\n-    } else if (parser.Check(\"NOLOOP\").IgnoreCase()) {\n+    } else if (parser.Check(\"NOLOOP\")) {\n       noloop = true;\n     } else {\n       return cntx->SendError(kSyntaxErr);\n@@ -491,7 +491,7 @@ void ClientTracking(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   if (parser.HasNext()) {\n-    if (!noloop && parser.Check(\"NOLOOP\").IgnoreCase()) {\n+    if (!noloop && parser.Check(\"NOLOOP\")) {\n       noloop = true;\n     } else {\n       return cntx->SendError(kSyntaxErr);\n@@ -520,12 +520,12 @@ void ClientCaching(CmdArgList args, ConnectionContext* cntx) {\n \n   using Tracking = ConnectionState::ClientTracking;\n   CmdArgParser parser{args};\n-  if (parser.Check(\"YES\").IgnoreCase()) {\n+  if (parser.Check(\"YES\")) {\n     if (!cntx->conn_state.tracking_info_.HasOption(Tracking::OPTIN)) {\n       return cntx->SendError(\n           \"ERR CLIENT CACHING YES is only valid when tracking is enabled in OPTIN mode\");\n     }\n-  } else if (parser.Check(\"NO\").IgnoreCase()) {\n+  } else if (parser.Check(\"NO\")) {\n     if (!cntx->conn_state.tracking_info_.HasOption(Tracking::OPTOUT)) {\n       return cntx->SendError(\n           \"ERR CLIENT CACHING NO is only valid when tracking is enabled in OPTOUT mode\");\n@@ -645,7 +645,7 @@ optional<ReplicaOfArgs> ReplicaOfArgs::FromCmdArgs(CmdArgList args, ConnectionCo\n   ReplicaOfArgs replicaof_args;\n   CmdArgParser parser(args);\n \n-  if (parser.Check(\"NO\").IgnoreCase().ExpectTail(1)) {\n+  if (parser.Check(\"NO\").ExpectTail(1)) {\n     parser.ExpectTag(\"ONE\");\n     replicaof_args.port = 0;\n   } else {\n@@ -2705,7 +2705,7 @@ void ServerFamily::ReplTakeOver(CmdArgList args, ConnectionContext* cntx) {\n   CmdArgParser parser{args};\n \n   int timeout_sec = parser.Next<int>();\n-  bool save_flag = static_cast<bool>(parser.Check(\"SAVE\").IgnoreCase());\n+  bool save_flag = static_cast<bool>(parser.Check(\"SAVE\"));\n \n   if (parser.HasNext())\n     return cntx->SendError(absl::StrCat(\"Unsupported option:\", string_view(parser.Next())));\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 10efe3d8d429..82a05687f493 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -2133,7 +2133,7 @@ void ZSetFamily::ZRange(CmdArgList args, ConnectionContext* cntx) {\n \n void ZSetFamily::ZRangeGeneric(CmdArgList args, ConnectionContext* cntx, RangeParams range_params) {\n   facade::CmdArgParser parser{args.subspan(3)};\n-  while (parser.ToUpper().HasNext()) {\n+  while (parser.HasNext()) {\n     if (parser.Check(\"BYSCORE\")) {\n       if (exchange(range_params.interval_type, RangeParams::SCORE) == RangeParams::LEX)\n         return cntx->SendError(\"BYSCORE and BYLEX options are not compatible\");\n@@ -2271,7 +2271,7 @@ void ZSetFamily::ZRandMember(CmdArgList args, ConnectionContext* cntx) {\n   int count = is_count ? parser.Next<int>() : 1;\n \n   ZSetFamily::RangeParams params;\n-  params.with_scores = static_cast<bool>(parser.Check(\"WITHSCORES\").IgnoreCase());\n+  params.with_scores = static_cast<bool>(parser.Check(\"WITHSCORES\"));\n \n   if (parser.HasNext())\n     return cntx->SendError(absl::StrCat(\"Unsupported option:\", string_view(parser.Next())));\n",
  "test_patch": "diff --git a/src/facade/cmd_arg_parser_test.cc b/src/facade/cmd_arg_parser_test.cc\nindex 45113e9ae531..4810354e4d13 100644\n--- a/src/facade/cmd_arg_parser_test.cc\n+++ b/src/facade/cmd_arg_parser_test.cc\n@@ -120,17 +120,15 @@ TEST_F(CmdArgParserTest, Cases) {\n   EXPECT_EQ(err->index, 1);\n }\n \n-TEST_F(CmdArgParserTest, NextUpper) {\n+TEST_F(CmdArgParserTest, IgnoreCase) {\n   auto parser = Make({\"hello\", \"marker\", \"taail\", \"world\"});\n \n-  parser.ToUpper();\n-  EXPECT_EQ(absl::implicit_cast<string_view>(parser.Next()), \"HELLO\"sv);\n+  EXPECT_EQ(absl::implicit_cast<string_view>(parser.Next()), \"hello\"sv);\n \n-  parser.ToUpper();\n-  EXPECT_TRUE(parser.Check(\"MARKER\"sv).ExpectTail(1).NextUpper());\n+  EXPECT_TRUE(parser.Check(\"MARKER\"sv).ExpectTail(1));\n   parser.Skip(1);\n \n-  EXPECT_EQ(absl::implicit_cast<string_view>(parser.Next()), \"WORLD\"sv);\n+  EXPECT_EQ(absl::implicit_cast<string_view>(parser.Next()), \"world\"sv);\n }\n \n }  // namespace facade\n",
  "problem_statement": "CmdArgParser::ToUpper needs to be removed\nCmdArgParser::ToUpper function is useless in most cases because command comparison should be done case insensitive (we need to check this and fix if this isn't done). Also this function semantically can not be part of the parser.\n",
  "hints_text": "",
  "created_at": "2024-08-29T07:06:39Z",
  "modified_files": [
    "src/facade/cmd_arg_parser.cc",
    "src/facade/cmd_arg_parser.h",
    "src/server/bitops_family.cc",
    "src/server/dflycmd.cc",
    "src/server/hset_family.cc",
    "src/server/json_family.cc",
    "src/server/list_family.cc",
    "src/server/search/doc_index.cc",
    "src/server/search/doc_index.h",
    "src/server/search/search_family.cc",
    "src/server/server_family.cc",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/facade/cmd_arg_parser_test.cc"
  ]
}