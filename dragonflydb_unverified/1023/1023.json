{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1023,
  "instance_id": "dragonflydb__dragonfly-1023",
  "issue_numbers": [
    "841"
  ],
  "base_commit": "1b4d3b42a323e56e648957a3e857ae673734ad2c",
  "patch": "diff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex 73584af970c8..39c2b8b67751 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -46,6 +46,12 @@ constexpr uint32_t kMinTieredLen = TieredStorage::kMinBlobLen;\n \n string GetString(EngineShard* shard, const PrimeValue& pv) {\n   string res;\n+  if (pv.ObjType() != OBJ_STRING) {\n+    // An attempt to read a non-string's string value can happen when overriding a non-string value\n+    // with a string value.\n+    return \"\";\n+  }\n+\n   if (pv.IsExternal()) {\n     auto* tiered = shard->tiered_storage();\n     auto [offset, size] = pv.GetExternalSlice();\n@@ -340,24 +346,25 @@ OpStatus OpMSet(const OpArgs& op_args, ArgSlice args) {\n \n   for (size_t i = 0; i < args.size(); i += 2) {\n     DVLOG(1) << \"MSet \" << args[i] << \":\" << args[i + 1];\n-    OpStatus res = sg.Set(params, args[i], args[i + 1]);\n-    if (res != OpStatus::OK) {  // OOM for example.\n-      return res;\n+    OpResult<optional<string>> res = sg.Set(params, args[i], args[i + 1]);\n+    if (res.status() != OpStatus::OK) {  // OOM for example.\n+      return res.status();\n     }\n   }\n \n   return OpStatus::OK;\n }\n \n-OpResult<void> SetGeneric(ConnectionContext* cntx, const SetCmd::SetParams& sparams,\n-                          string_view key, string_view value, bool manual_journal) {\n+// See comment for SetCmd::Set() for when and how OpResult's value (i.e. optional<string>) is set.\n+OpResult<optional<string>> SetGeneric(ConnectionContext* cntx, const SetCmd::SetParams& sparams,\n+                                      string_view key, string_view value, bool manual_journal) {\n   DCHECK(cntx->transaction);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     SetCmd sg(t->GetOpArgs(shard), manual_journal);\n     return sg.Set(sparams, key, value);\n   };\n-  return cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  return cntx->transaction->ScheduleSingleHopT(std::move(cb));\n }\n \n // emission_interval_ms assumed to be positive\n@@ -470,9 +477,37 @@ OpResult<array<int64_t, 5>> OpThrottle(const OpArgs& op_args, const string_view\n   return array<int64_t, 5>{limited ? 1 : 0, limit, remaining, retry_after_ms, reset_after_ms};\n }\n \n+class SetResultBuilder {\n+ public:\n+  explicit SetResultBuilder(bool return_prev_value) : return_prev_value_(return_prev_value) {\n+  }\n+\n+  void CachePrevValueIfNeeded(string_view value) {\n+    if (return_prev_value_) {\n+      prev_value_ = value;\n+    }\n+  }\n+\n+  // Returns either the previous value or `status`, depending on return_prev_value_.\n+  OpResult<optional<string>> Return(OpStatus status) && {\n+    if (return_prev_value_) {\n+      return std::move(prev_value_);\n+    } else {\n+      return status;\n+    }\n+  }\n+\n+ private:\n+  bool return_prev_value_;\n+  std::optional<string> prev_value_;\n+};\n+\n }  // namespace\n \n-OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value) {\n+OpResult<optional<string>> SetCmd::Set(const SetParams& params, string_view key,\n+                                       string_view value) {\n+  SetResultBuilder result_builder(params.flags & SET_GET);\n+\n   EngineShard* shard = op_args_.shard;\n   auto& db_slice = shard->db_slice();\n \n@@ -482,16 +517,20 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n \n   if (params.IsConditionalSet()) {\n     const auto [it, expire_it] = db_slice.FindExt(op_args_.db_cntx, key);\n+    if (IsValid(it)) {\n+      result_builder.CachePrevValueIfNeeded(GetString(shard, it->second));\n+    }\n+\n     // Make sure that we have this key, and only add it if it does exists\n     if (params.flags & SET_IF_EXISTS) {\n       if (IsValid(it)) {\n-        return SetExisting(params, it, expire_it, key, value);\n+        return std::move(result_builder).Return(SetExisting(params, it, expire_it, key, value));\n       } else {\n-        return OpStatus::SKIPPED;\n+        return std::move(result_builder).Return(OpStatus::SKIPPED);\n       }\n     } else {\n       if (IsValid(it)) {  // if the policy is not to overide and have the key, just return\n-        return OpStatus::SKIPPED;\n+        return std::move(result_builder).Return(OpStatus::SKIPPED);\n       }\n     }\n   }\n@@ -507,7 +546,8 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n \n   PrimeIterator it = get<0>(add_res);\n   if (!get<2>(add_res)) {  // Existing.\n-    return SetExisting(params, it, get<1>(add_res), key, value);\n+    result_builder.CachePrevValueIfNeeded(GetString(shard, it->second));\n+    return std::move(result_builder).Return(SetExisting(params, it, get<1>(add_res), key, value));\n   }\n \n   // Adding new value.\n@@ -535,7 +575,7 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n     RecordJournal(params, key, value);\n   }\n \n-  return OpStatus::OK;\n+  return std::move(result_builder).Return(OpStatus::OK);\n }\n \n OpStatus SetCmd::SetExisting(const SetParams& params, PrimeIterator it, ExpireIterator e_it,\n@@ -692,6 +732,16 @@ void StringFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n \n   const auto result{SetGeneric(cntx, sparams, key, value, true)};\n \n+  if (sparams.flags & SetCmd::SET_GET) {\n+    // When SET_GET is used, the reply is not affected by whether anything was set.\n+    if (result->has_value()) {\n+      (*cntx)->SendBulkString(result->value());\n+    } else {\n+      (*cntx)->SendNull();\n+    }\n+    return;\n+  }\n+\n   if (result == OpStatus::OK) {\n     return builder->SendStored();\n   }\n@@ -803,7 +853,7 @@ void StringFamily::GetSet(CmdArgList args, ConnectionContext* cntx) {\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     SetCmd cmd(t->GetOpArgs(shard), false);\n \n-    return cmd.Set(sparams, key, value);\n+    return cmd.Set(sparams, key, value).status();\n   };\n   OpStatus status = cntx->transaction->ScheduleSingleHop(std::move(cb));\n \n@@ -1054,7 +1104,7 @@ void StringFamily::SetExGeneric(bool seconds, CmdArgList args, ConnectionContext\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     SetCmd sg(t->GetOpArgs(shard), true);\n-    return sg.Set(sparams, key, value);\n+    return sg.Set(sparams, key, value).status();\n   };\n \n   OpResult<void> result = cntx->transaction->ScheduleSingleHop(std::move(cb));\ndiff --git a/src/server/string_family.h b/src/server/string_family.h\nindex ec5e5b22249b..4c43ac19535c 100644\n--- a/src/server/string_family.h\n+++ b/src/server/string_family.h\n@@ -45,7 +45,11 @@ class SetCmd {\n     }\n   };\n \n-  OpStatus Set(const SetParams& params, std::string_view key, std::string_view value);\n+  // OpResult's value (i.e. optional<string>) is set in the case `params.flags` has SET_GET bit on,\n+  // in which case the previous value (or nullopt if none) is returned. Otherwise, OpResult only\n+  // contains a status.\n+  OpResult<std::optional<std::string>> Set(const SetParams& params, std::string_view key,\n+                                           std::string_view value);\n \n  private:\n   OpStatus SetExisting(const SetParams& params, PrimeIterator it, ExpireIterator e_it,\n",
  "test_patch": "diff --git a/src/server/string_family_test.cc b/src/server/string_family_test.cc\nindex e61df22ad7f0..5d5d40906f59 100644\n--- a/src/server/string_family_test.cc\n+++ b/src/server/string_family_test.cc\n@@ -673,4 +673,17 @@ TEST_F(StringFamilyTest, SetMGetWithNilResp3) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"val\", ArgType(RespExpr::NIL)));\n }\n \n+TEST_F(StringFamilyTest, SetWithGetParam) {\n+  EXPECT_THAT(Run({\"set\", \"key1\", \"val1\", \"get\"}), ArgType(RespExpr::NIL));\n+  EXPECT_EQ(Run({\"set\", \"key1\", \"val2\", \"get\"}), \"val1\");\n+\n+  EXPECT_THAT(Run({\"set\", \"key2\", \"val2\", \"nx\", \"get\"}), ArgType(RespExpr::NIL));\n+  EXPECT_THAT(Run({\"set\", \"key2\", \"not used\", \"nx\", \"get\"}), \"val2\");\n+  EXPECT_EQ(Run({\"get\", \"key2\"}), \"val2\");\n+\n+  EXPECT_THAT(Run({\"set\", \"key3\", \"not used\", \"xx\", \"get\"}), ArgType(RespExpr::NIL));\n+  EXPECT_THAT(Run({\"set\", \"key2\", \"val3\", \"xx\", \"get\"}), \"val2\");\n+  EXPECT_EQ(Run({\"get\", \"key2\"}), \"val3\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Support GET option for SET command\nIt is possible to supply the `GET` argument when setting a new string value, in order to return the old value (this is equivalent to `GETSET`). Currently Dragonfly supports this (i.e., there is no syntax error), however an \"OK\" is returned instead of the old value.\r\n\r\n**Example**\r\n```shell\r\n> SET k1 \"Hello\"\r\n\"OK\"\r\n> SET k1 \"World\" GET\r\n\"OK\" # expected: \"Hello\"\r\n> GET k1\r\n\"World\"\r\n```\n",
  "hints_text": "#484  is related to this.",
  "created_at": "2023-03-31T21:16:46Z",
  "modified_files": [
    "src/server/string_family.cc",
    "src/server/string_family.h"
  ],
  "modified_test_files": [
    "src/server/string_family_test.cc"
  ]
}