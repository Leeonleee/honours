diff --git a/src/server/rdb_save.cc b/src/server/rdb_save.cc
index 0536f415ac11..427d7ceb9be6 100644
--- a/src/server/rdb_save.cc
+++ b/src/server/rdb_save.cc
@@ -309,6 +309,10 @@ io::Result<uint8_t> RdbSerializer::SaveEntry(const PrimeKey& pk, const PrimeValu
     return make_unexpected(ec);
   }
 
+  // We flush here because if the next element in the bucket we are serializing is a container,
+  // it will first serialize the first entry and then flush the internal buffer, even if
+  // crossed the limit.
+  FlushIfNeeded(FlushState::kFlushEndEntry);
   return rdb_type;
 }
 
@@ -776,6 +780,10 @@ error_code SerializerBase::FlushToSink(io::Sink* sink, SerializerBase::FlushStat
   if (bytes.empty())
     return error_code{};
 
+  if (bytes.size() > serialization_peak_bytes_) {
+    serialization_peak_bytes_ = bytes.size();
+  }
+
   DVLOG(2) << "FlushToSink " << bytes.size() << " bytes";
 
   // interrupt point.
diff --git a/src/server/rdb_save.h b/src/server/rdb_save.h
index a25c4a1d5d2a..fe8728e17f91 100644
--- a/src/server/rdb_save.h
+++ b/src/server/rdb_save.h
@@ -183,6 +183,10 @@ class SerializerBase {
     return SaveString(io::View(io::Bytes{buf, len}));
   }
 
+  uint64_t GetSerializationPeakBytes() const {
+    return serialization_peak_bytes_;
+  }
+
  protected:
   // Prepare internal buffer for flush. Compress it.
   io::Bytes PrepareFlush(FlushState flush_state);
@@ -210,6 +214,8 @@ class SerializerBase {
   base::PODArray<uint8_t> tmp_buf_;
   std::unique_ptr<LZF_HSLOT[]> lzf_;
   size_t number_of_chunks_ = 0;
+
+  uint64_t serialization_peak_bytes_ = 0;
 };
 
 class RdbSerializer : public SerializerBase {
diff --git a/src/server/snapshot.cc b/src/server/snapshot.cc
index cdaf4a205745..d24663ee7c40 100644
--- a/src/server/snapshot.cc
+++ b/src/server/snapshot.cc
@@ -64,7 +64,7 @@ size_t SliceSnapshot::GetThreadLocalMemoryUsage() {
 }
 
 bool SliceSnapshot::IsSnaphotInProgress() {
-  return tl_slice_snapshots.size() > 0;
+  return !tl_slice_snapshots.empty();
 }
 
 void SliceSnapshot::Start(bool stream_journal, SnapshotFlush allow_flush) {
@@ -114,6 +114,7 @@ void SliceSnapshot::Start(bool stream_journal, SnapshotFlush allow_flush) {
       db_slice_->UnregisterOnMoved(moved_cb_id_);
     }
     consumer_->Finalize();
+    VLOG(1) << "Serialization peak bytes: " << serializer_->GetSerializationPeakBytes();
   });
 }
 
