{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4366,
  "instance_id": "dragonflydb__dragonfly-4366",
  "issue_numbers": [
    "4348"
  ],
  "base_commit": "c88c707341e7fe098f92ebb3789815ea8a3d6544",
  "patch": "diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 7102d49e1f01..da7d884fc9ca 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -421,8 +421,8 @@ struct Connection::AsyncOperations {\n   }\n \n   void operator()(const PubMessage& msg);\n-  void operator()(Connection::PipelineMessage& msg);\n-  void operator()(const Connection::MCPipelineMessage& msg);\n+  void operator()(PipelineMessage& msg);\n+  void operator()(const MCPipelineMessage& msg);\n   void operator()(const MonitorMessage& msg);\n   void operator()(const AclUpdateMessage& msg);\n   void operator()(const MigrationRequestMessage& msg);\n@@ -479,7 +479,7 @@ void Connection::AsyncOperations::operator()(Connection::PipelineMessage& msg) {\n   self->skip_next_squashing_ = false;\n }\n \n-void Connection::AsyncOperations::operator()(const Connection::MCPipelineMessage& msg) {\n+void Connection::AsyncOperations::operator()(const MCPipelineMessage& msg) {\n   self->service_->DispatchMC(msg.cmd, msg.value,\n                              static_cast<MCReplyBuilder*>(self->reply_builder_.get()),\n                              self->cc_.get());\ndiff --git a/src/facade/memcache_parser.cc b/src/facade/memcache_parser.cc\nindex 4720b0f67c31..31b63cc7c571 100644\n--- a/src/facade/memcache_parser.cc\n+++ b/src/facade/memcache_parser.cc\n@@ -274,6 +274,9 @@ MP::Result ParseMeta(ArgSlice tokens, MP::Command* res) {\n       case 'h':\n         res->return_hit = true;\n         break;\n+      case 'c':\n+        res->return_version = true;\n+        break;\n       default:\n         LOG(WARNING) << \"unknown meta flag: \" << token;  // not yet implemented\n         return MP::PARSE_ERROR;\n@@ -291,7 +294,7 @@ auto MP::Parse(string_view str, uint32_t* consumed, Command* cmd) -> Result {\n   *consumed = 0;\n   if (pos == string_view::npos) {\n     // We need more data to parse the command. For get/gets commands this line can be very long.\n-    // we limit maxmimum buffer capacity  in the higher levels using max_client_iobuf_len.\n+    // we limit maximum buffer capacity in the higher levels using max_client_iobuf_len.\n     return INPUT_PENDING;\n   }\n \ndiff --git a/src/facade/memcache_parser.h b/src/facade/memcache_parser.h\nindex 65db0f74786c..a16919130830 100644\n--- a/src/facade/memcache_parser.h\n+++ b/src/facade/memcache_parser.h\n@@ -75,6 +75,8 @@ class MemcacheParser {\n     bool return_ttl = false;          // t\n     bool return_access_time = false;  // l\n     bool return_hit = false;          // h\n+    bool return_version = false;      // c\n+\n     // Used internally by meta parsing.\n     std::string blob;\n   };\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex 72e873f8bc1e..9a909b902d12 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -204,27 +204,40 @@ void SinkReplyBuilder::NextVec(std::string_view str) {\n   vecs_.push_back(iovec{const_cast<char*>(str.data()), str.size()});\n }\n \n-MCReplyBuilder::MCReplyBuilder(::io::Sink* sink) : SinkReplyBuilder(sink), noreply_(false) {\n+MCReplyBuilder::MCReplyBuilder(::io::Sink* sink) : SinkReplyBuilder(sink), all_(0) {\n }\n \n void MCReplyBuilder::SendValue(std::string_view key, std::string_view value, uint64_t mc_ver,\n                                uint32_t mc_flag) {\n   ReplyScope scope(this);\n-  WritePieces(\"VALUE \", key, \" \", mc_flag, \" \", value.size());\n-  if (mc_ver)\n-    WritePieces(\" \", mc_ver);\n-\n-  if (value.size() <= kMaxInlineSize) {\n-    WritePieces(kCRLF, value, kCRLF);\n+  if (flag_.meta) {\n+    string flags;\n+    if (flag_.return_mcflag)\n+      absl::StrAppend(&flags, \" f\", mc_flag);\n+    if (flag_.return_version)\n+      absl::StrAppend(&flags, \" c\", mc_ver);\n+    if (flag_.return_value) {\n+      WritePieces(\"VA \", value.size(), flags, kCRLF, value, kCRLF);\n+    } else {\n+      WritePieces(\"HD \", flags, kCRLF);\n+    }\n   } else {\n-    WritePieces(kCRLF);\n-    WriteRef(value);\n-    WritePieces(kCRLF);\n+    WritePieces(\"VALUE \", key, \" \", mc_flag, \" \", value.size());\n+    if (mc_ver)\n+      WritePieces(\" \", mc_ver);\n+\n+    if (value.size() <= kMaxInlineSize) {\n+      WritePieces(kCRLF, value, kCRLF);\n+    } else {\n+      WritePieces(kCRLF);\n+      WriteRef(value);\n+      WritePieces(kCRLF);\n+    }\n   }\n }\n \n void MCReplyBuilder::SendSimpleString(std::string_view str) {\n-  if (noreply_)\n+  if (flag_.noreply)\n     return;\n \n   ReplyScope scope(this);\n@@ -232,7 +245,7 @@ void MCReplyBuilder::SendSimpleString(std::string_view str) {\n }\n \n void MCReplyBuilder::SendStored() {\n-  SendSimpleString(\"STORED\");\n+  SendSimpleString(flag_.meta ? \"HD\" : \"STORED\");\n }\n \n void MCReplyBuilder::SendLong(long val) {\n@@ -253,11 +266,21 @@ void MCReplyBuilder::SendClientError(string_view str) {\n }\n \n void MCReplyBuilder::SendSetSkipped() {\n-  SendSimpleString(\"NOT_STORED\");\n+  SendSimpleString(flag_.meta ? \"NS\" : \"NOT_STORED\");\n }\n \n void MCReplyBuilder::SendNotFound() {\n-  SendSimpleString(\"NOT_FOUND\");\n+  SendSimpleString(flag_.meta ? \"NF\" : \"NOT_FOUND\");\n+}\n+\n+void MCReplyBuilder::SendGetEnd() {\n+  if (!flag_.meta)\n+    SendSimpleString(\"END\");\n+}\n+\n+void MCReplyBuilder::SendMiss() {\n+  if (flag_.meta)\n+    SendSimpleString(\"EN\");\n }\n \n void MCReplyBuilder::SendRaw(std::string_view str) {\ndiff --git a/src/facade/reply_builder.h b/src/facade/reply_builder.h\nindex f148bf97f145..4000558c7fd0 100644\n--- a/src/facade/reply_builder.h\n+++ b/src/facade/reply_builder.h\n@@ -171,6 +171,8 @@ class MCReplyBuilder : public SinkReplyBuilder {\n \n   void SendClientError(std::string_view str);\n   void SendNotFound();\n+  void SendMiss();\n+  void SendGetEnd();\n \n   void SendValue(std::string_view key, std::string_view value, uint64_t mc_ver, uint32_t mc_flag);\n   void SendSimpleString(std::string_view str) final;\n@@ -179,15 +181,45 @@ class MCReplyBuilder : public SinkReplyBuilder {\n   void SendRaw(std::string_view str);\n \n   void SetNoreply(bool noreply) {\n-    noreply_ = noreply;\n+    flag_.noreply = noreply;\n   }\n \n   bool NoReply() const {\n-    return noreply_;\n+    return flag_.noreply;\n+  }\n+\n+  void SetMeta(bool meta) {\n+    flag_.meta = meta;\n+  }\n+\n+  void SetBase64(bool base64) {\n+    flag_.base64 = base64;\n+  }\n+\n+  void SetReturnMCFlag(bool val) {\n+    flag_.return_mcflag = val;\n+  }\n+\n+  void SetReturnValue(bool val) {\n+    flag_.return_value = val;\n+  }\n+\n+  void SetReturnVersion(bool val) {\n+    flag_.return_version = val;\n   }\n \n  private:\n-  bool noreply_ = false;\n+  union {\n+    struct {\n+      uint8_t noreply : 1;\n+      uint8_t meta : 1;\n+      uint8_t base64 : 1;\n+      uint8_t return_value : 1;\n+      uint8_t return_mcflag : 1;\n+      uint8_t return_version : 1;\n+    } flag_;\n+    uint8_t all_;\n+  };\n };\n \n // Redis reply builder interface for sending RESP data.\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 3a1cde50f5e3..df22f6b8ccd3 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1490,6 +1490,13 @@ void Service::DispatchMC(const MemcacheParser::Command& cmd, std::string_view va\n   char ttl_op[] = \"EXAT\";\n \n   mc_builder->SetNoreply(cmd.no_reply);\n+  mc_builder->SetMeta(cmd.meta);\n+  if (cmd.meta) {\n+    mc_builder->SetBase64(cmd.base64);\n+    mc_builder->SetReturnMCFlag(cmd.return_flags);\n+    mc_builder->SetReturnValue(cmd.return_value);\n+    mc_builder->SetReturnVersion(cmd.return_version);\n+  }\n \n   switch (cmd.type) {\n     case MemcacheParser::REPLACE:\n@@ -1533,7 +1540,7 @@ void Service::DispatchMC(const MemcacheParser::Command& cmd, std::string_view va\n       server_family_.StatsMC(cmd.key, mc_builder);\n       return;\n     case MemcacheParser::VERSION:\n-      mc_builder->SendSimpleString(\"VERSION 1.5.0 DF\");\n+      mc_builder->SendSimpleString(\"VERSION 1.6.0 DF\");\n       return;\n     default:\n       mc_builder->SendClientError(\"bad command line format\");\ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex 67a711098ccf..537611c5f39f 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -1360,11 +1360,13 @@ void StringFamily::MGet(CmdArgList args, const CommandContext& cmnd_cntx) {\n     auto* rb = static_cast<MCReplyBuilder*>(builder);\n     DCHECK(dynamic_cast<CapturingReplyBuilder*>(builder) == nullptr);\n     for (const auto& entry : res) {\n-      if (!entry)\n-        continue;\n-      rb->SendValue(entry->key, entry->value, entry->mc_ver, entry->mc_flag);\n+      if (entry) {\n+        rb->SendValue(entry->key, entry->value, entry->mc_ver, entry->mc_flag);\n+      } else {\n+        rb->SendMiss();\n+      }\n     }\n-    rb->SendSimpleString(\"END\");\n+    rb->SendGetEnd();\n   } else {\n     auto* rb = static_cast<RedisReplyBuilder*>(builder);\n     rb->StartArray(res.size());\n",
  "test_patch": "diff --git a/tests/dragonfly/memcache_meta.py b/tests/dragonfly/memcache_meta.py\nindex 3b4cf0b4c4f5..87bbd1fcf648 100644\n--- a/tests/dragonfly/memcache_meta.py\n+++ b/tests/dragonfly/memcache_meta.py\n@@ -6,6 +6,7 @@\n     CacheClient,\n     connection_pool_factory_builder,\n )\n+from meta_memcache.protocol import RequestFlags, Miss, Value, Success\n \n DEFAULT_ARGS = {\"memcached_port\": 11211, \"proactor_threads\": 4}\n \n@@ -16,6 +17,14 @@ def test_basic(df_server: DflyInstance):\n         servers=[\n             ServerAddress(host=\"localhost\", port=DEFAULT_ARGS.get(\"memcached_port\")),\n         ],\n-        connection_pool_factory_fn=connection_pool_factory_builder(),\n+        connection_pool_factory_fn=connection_pool_factory_builder(recv_timeout=5),\n     )\n-    # TODO: to add integration tests\n+\n+    assert pool.set(\"key1\", \"value1\", 100)\n+    assert pool.set(\"key1\", \"value2\", 0)\n+    assert pool.get(\"key1\") == \"value2\"\n+\n+    request_flags = RequestFlags(return_value=False)\n+    response = pool.meta_get(Key(\"key1\"), flags=request_flags)\n+    assert isinstance(response, Success)\n+    assert pool.get(\"key2\") is None\ndiff --git a/tests/dragonfly/pymemcached_test.py b/tests/dragonfly/pymemcached_test.py\nindex a8b405555f23..96263dd7f2ca 100644\n--- a/tests/dragonfly/pymemcached_test.py\n+++ b/tests/dragonfly/pymemcached_test.py\n@@ -137,7 +137,7 @@ def test_version(memcached_client: MCClient):\n     Our real version is being returned in the stats command.\n     Also verified manually that php client parses correctly the version string that ends with \"DF\".\n     \"\"\"\n-    assert b\"1.5.0 DF\" == memcached_client.version()\n+    assert b\"1.6.0 DF\" == memcached_client.version()\n     stats = memcached_client.stats()\n     version = stats[b\"version\"].decode(\"utf-8\")\n     assert version.startswith(\"v\") or version == \"dev\"\n",
  "problem_statement": "Potential incompatibility with ruby memcached client \nUsing dali client set commands times out\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\ninstall ruby and dali\r\nsudo apt update\r\nsudo apt install ruby-full\r\nsudo gem install dalli\r\n\r\ncreate test.rb with the following content \r\n```\r\nrequire 'dalli'\r\n\r\nbegin\r\n  # Create Memcached client with minimal configuration\r\n  memcached = Dalli::Client.new('localhost:11211', {\r\n    socket_timeout: 30,  # Increased timeout\r\n    compress: false,     # Disable compression\r\n    serializer: nil      # Disable serialization to match telnet behavior\r\n  })\r\n\r\n  puts \"Testing connection...\"\r\n\r\n  # Try the same operation that worked in telnet\r\n  result = memcached.set('my_key', 'hello', 900)\r\n  puts \"Set result: #{result}\"\r\n\r\n  value = memcached.get('my_key')\r\n  puts \"Retrieved value: #{value}\"\r\n\r\nrescue => e\r\n  puts \"Error: #{e.class} - #{e.message}\"\r\n  puts e.backtrace\r\nend\r\n\r\n```\r\n\r\nRun dragonfly \r\n`docker run --pull always --network=host --ulimit memlock=-1 docker.dragonflydb.io/dragonflydb/dragonfly:latest --memcached_port 11211\r\n`\r\n\r\nRun ruby script \r\n`ruby test.rb`\r\n\r\n**Expected behavior**\r\nExpect script to print response but it times out instead\r\n\r\nThe following script succeeds \n",
  "hints_text": "Probably same like https://github.com/dragonflydb/dragonfly/issues/3071\r\n\r\nwe do not support memcache binary protocol \nTrying with `protocol: 'meta'` only options are `binary` or ` meta`\r\n```\r\nrequire 'dalli'\r\n\r\nbegin\r\n  # Create Memcached client with minimal configuration\r\n  memcached = Dalli::Client.new('localhost:11211', {\r\n    socket_timeout: 30,  # Increased timeout\r\n    compress: false,     # Disable compression\r\n    protocol: 'meta'\r\n  })\r\n\r\n  puts \"Testing connection...\"\r\n\r\n  # Try the same operation that worked in telnet\r\n  result = memcached.set('my_key', 'hello', 900)\r\n  puts \"Set result: #{result}\"\r\n\r\n  value = memcached.get('my_key')\r\n  puts \"Retrieved value: #{value}\"\r\n\r\nrescue => e\r\n  puts \"Error: #{e.class} - #{e.message}\"\r\n  puts e.backtrace\r\nend\r\n```\r\n\r\ngetting \r\n```\r\nruby test.rb \r\nTesting connection...\r\nError: Dalli::DalliError - Response error: ERROR\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/protocol/meta/response_processor.rb:170:in `error_on_unexpected!'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/protocol/meta/response_processor.rb:54:in `meta_set_with_cas'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/protocol/meta.rb:66:in `set'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/protocol/base.rb:36:in `request'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/options.rb:18:in `block in request'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/options.rb:17:in `synchronize'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/options.rb:17:in `request'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/client.rb:426:in `perform'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/client.rb:208:in `set_cas'\r\n/var/lib/gems/3.0.0/gems/dalli-3.2.8/lib/dalli/client.rb:201:in `set'\r\ntest.rb:14:in `<main>'\r\n```\nyeah, we do not support both meta nor binary. ",
  "created_at": "2024-12-24T13:37:30Z",
  "modified_files": [
    "src/facade/dragonfly_connection.cc",
    "src/facade/memcache_parser.cc",
    "src/facade/memcache_parser.h",
    "src/facade/reply_builder.cc",
    "src/facade/reply_builder.h",
    "src/server/main_service.cc",
    "src/server/string_family.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/memcache_meta.py",
    "tests/dragonfly/pymemcached_test.py"
  ]
}