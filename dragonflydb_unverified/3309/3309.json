{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3309,
  "instance_id": "dragonflydb__dragonfly-3309",
  "issue_numbers": [
    "3287"
  ],
  "base_commit": "bfa5399b888f21bda284e9d62a6d57f43ce13639",
  "patch": "diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex e649f6401f7e..b2f2a5f7b60a 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -59,7 +59,7 @@ add_library(dragonfly_lib bloom_family.cc engine_shard_set.cc\n             cluster/cluster_config.cc cluster/cluster_family.cc cluster/incoming_slot_migration.cc\n             cluster/outgoing_slot_migration.cc cluster/cluster_defs.cc\n             acl/user.cc acl/user_registry.cc acl/acl_family.cc\n-            acl/validator.cc acl/helpers.cc)\n+            acl/validator.cc)\n \n if (DF_ENABLE_MEMORY_TRACKING)\n   target_compile_definitions(dragonfly_lib PRIVATE DFLY_ENABLE_MEMORY_TRACKING)\ndiff --git a/src/server/acl/acl_commands_def.h b/src/server/acl/acl_commands_def.h\nindex c53eb1cb60eb..99b8257c7591 100644\n--- a/src/server/acl/acl_commands_def.h\n+++ b/src/server/acl/acl_commands_def.h\n@@ -47,108 +47,21 @@ enum AclCat {\n   JSON = 1ULL << 31\n };\n \n-// See definitions for NONE and ALL in facade/acl_commands_def.h\n-\n-inline const absl::flat_hash_map<std::string_view, uint32_t> CATEGORY_INDEX_TABLE{\n-    {\"KEYSPACE\", KEYSPACE},\n-    {\"READ\", READ},\n-    {\"WRITE\", WRITE},\n-    {\"SET\", SET},\n-    {\"SORTEDSET\", SORTEDSET},\n-    {\"LIST\", LIST},\n-    {\"HASH\", HASH},\n-    {\"STRING\", STRING},\n-    {\"BITMAP\", BITMAP},\n-    {\"HYPERLOG\", HYPERLOGLOG},\n-    {\"GEO\", GEO},\n-    {\"STREAM\", STREAM},\n-    {\"PUBSUB\", PUBSUB},\n-    {\"ADMIN\", ADMIN},\n-    {\"FAST\", FAST},\n-    {\"SLOW\", SLOW},\n-    {\"BLOCKING\", BLOCKING},\n-    {\"DANGEROUS\", DANGEROUS},\n-    {\"CONNECTION\", CONNECTION},\n-    {\"TRANSACTION\", TRANSACTION},\n-    {\"SCRIPTING\", SCRIPTING},\n-    {\"BLOOM\", BLOOM},\n-    {\"FT_SEARCH\", FT_SEARCH},\n-    {\"THROTTLE\", THROTTLE},\n-    {\"JSON\", JSON},\n-    {\"ALL\", ALL},\n-    {\"NONE\", NONE}};\n-\n-// bit 0 at index 0\n-// bit 1 at index 1\n-// bit n at index n\n-inline const std::vector<std::string> REVERSE_CATEGORY_INDEX_TABLE{\n-    \"KEYSPACE\",  \"READ\",      \"WRITE\",     \"SET\",       \"SORTEDSET\",  \"LIST\",        \"HASH\",\n-    \"STRING\",    \"BITMAP\",    \"HYPERLOG\",  \"GEO\",       \"STREAM\",     \"PUBSUB\",      \"ADMIN\",\n-    \"FAST\",      \"SLOW\",      \"BLOCKING\",  \"DANGEROUS\", \"CONNECTION\", \"TRANSACTION\", \"SCRIPTING\",\n-    \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\",  \"_RESERVED\",   \"_RESERVED\",\n-    \"BLOOM\",     \"FT_SEARCH\", \"THROTTLE\",  \"JSON\"};\n-\n-// bit index to index in the REVERSE_CATEGORY_INDEX_TABLE\n-using CategoryToIdxStore = absl::flat_hash_map<uint32_t, uint32_t>;\n-\n-inline const CategoryToIdxStore& CategoryToIdx(CategoryToIdxStore store = {}) {\n-  static CategoryToIdxStore cat_idx = std::move(store);\n-  return cat_idx;\n-}\n-\n-using RevCommandField = std::vector<std::string>;\n-using RevCommandsIndexStore = std::vector<RevCommandField>;\n-\n constexpr uint64_t ALL_COMMANDS = std::numeric_limits<uint64_t>::max();\n constexpr uint64_t NONE_COMMANDS = std::numeric_limits<uint64_t>::min();\n \n-// A variation of meyers singleton\n-// This is initialized when the constructor of Service is called.\n-// Basically, it calls this functions within the AclFamily::Register\n-// functions which has the number of all the acl families registered\n inline size_t NumberOfFamilies(size_t number = 0) {\n   static size_t number_of_families = number;\n   return number_of_families;\n }\n \n-inline const RevCommandsIndexStore& CommandsRevIndexer(RevCommandsIndexStore store = {}) {\n-  static RevCommandsIndexStore rev_index_store = std::move(store);\n-  return rev_index_store;\n-}\n+using CategoryIndexTable = absl::flat_hash_map<std::string_view, uint32_t>;\n+using ReverseCategoryIndexTable = std::vector<std::string>;\n+// bit index to index in the REVERSE_CATEGORY_INDEX_TABLE\n+using CategoryToIdxStore = absl::flat_hash_map<uint32_t, uint32_t>;\n \n+using RevCommandField = std::vector<std::string>;\n+using RevCommandsIndexStore = std::vector<RevCommandField>;\n using CategoryToCommandsIndexStore = absl::flat_hash_map<std::string, std::vector<uint64_t>>;\n \n-inline const CategoryToCommandsIndexStore& CategoryToCommandsIndex(\n-    CategoryToCommandsIndexStore store = {}) {\n-  static CategoryToCommandsIndexStore index = std::move(store);\n-  return index;\n-}\n-\n-inline void BuildIndexers(RevCommandsIndexStore families, CommandRegistry* cmd_registry) {\n-  acl::NumberOfFamilies(families.size());\n-  acl::CommandsRevIndexer(std::move(families));\n-  CategoryToCommandsIndexStore index;\n-  cmd_registry->Traverse([&](std::string_view name, auto& cid) {\n-    auto cat = cid.acl_categories();\n-    for (size_t i = 0; i < 32; ++i) {\n-      if (cat & (1 << i)) {\n-        std::string_view cat_name = REVERSE_CATEGORY_INDEX_TABLE[i];\n-        if (index[cat_name].empty()) {\n-          index[cat_name].resize(CommandsRevIndexer().size());\n-        }\n-        auto family = cid.GetFamily();\n-        auto bit_index = cid.GetBitIndex();\n-        index[cat_name][family] |= bit_index;\n-      }\n-    }\n-  });\n-\n-  CategoryToCommandsIndex(std::move(index));\n-  CategoryToIdxStore idx_store;\n-  for (size_t i = 0; i < 32; ++i) {\n-    idx_store[1 << i] = i;\n-  }\n-  CategoryToIdx(std::move(idx_store));\n-}\n-\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex d7b18fe0b359..fc7b00a18d62 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -3,8 +3,6 @@\n \n #include \"server/acl/acl_family.h\"\n \n-#include <glog/logging.h>\n-\n #include <algorithm>\n #include <cctype>\n #include <chrono>\n@@ -20,10 +18,11 @@\n \n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/flags/commandlineflag.h\"\n+#include \"absl/strings/escaping.h\"\n #include \"absl/strings/match.h\"\n #include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n-#include \"absl/types/span.h\"\n+#include \"absl/strings/str_split.h\"\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n #include \"core/overloaded.h\"\n@@ -31,10 +30,8 @@\n #include \"facade/facade_types.h\"\n #include \"io/file.h\"\n #include \"io/file_util.h\"\n-#include \"io/io.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/acl/acl_log.h\"\n-#include \"server/acl/helpers.h\"\n #include \"server/acl/validator.h\"\n #include \"server/command_registry.h\"\n #include \"server/common.h\"\n@@ -48,6 +45,18 @@ ABSL_FLAG(std::string, aclfile, \"\", \"Path and name to aclfile\");\n \n namespace dfly::acl {\n \n+namespace {\n+\n+std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,\n+                              bool full_sha);\n+using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;\n+\n+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n+                                             std::string_view file_contents);\n+\n+std::string AclKeysToString(const AclKeys& keys);\n+}  // namespace\n+\n AclFamily::AclFamily(UserRegistry* registry, util::ProactorPool* pool)\n     : registry_(registry), pool_(pool) {\n }\n@@ -107,7 +116,7 @@ void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {\n   const bool exists = reg.registry.contains(username);\n   const bool has_all_keys = exists ? reg.registry.find(username)->second.Keys().all_keys : false;\n \n-  auto req = ParseAclSetUser(args.subspan(1), *cmd_registry_, false, has_all_keys);\n+  auto req = ParseAclSetUser(args.subspan(1), false, has_all_keys);\n \n   auto error_case = [cntx](ErrorReply&& error) { cntx->SendError(error); };\n \n@@ -116,9 +125,10 @@ void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {\n     if (!exists) {\n       User::UpdateRequest default_req;\n       default_req.updates = {User::UpdateRequest::CategoryValueType{User::Sign::MINUS, acl::ALL}};\n-      user.Update(std::move(default_req));\n+      user.Update(std::move(default_req), CategoryToIdx(), reverse_cat_table_,\n+                  CategoryToCommandsIndex());\n     }\n-    user.Update(std::move(req));\n+    user.Update(std::move(req), CategoryToIdx(), reverse_cat_table_, CategoryToCommandsIndex());\n     if (exists) {\n       StreamUpdatesToAllProactorConnections(std::string(username), user.AclCommands(), user.Keys());\n     }\n@@ -278,7 +288,7 @@ GenericError AclFamily::LoadToRegistryFromFile(std::string_view full_path,\n   std::vector<User::UpdateRequest> requests;\n \n   for (auto& cmds : *materialized) {\n-    auto req = ParseAclSetUser(cmds, *cmd_registry_, true);\n+    auto req = ParseAclSetUser(cmds, true);\n     if (std::holds_alternative<ErrorReply>(req)) {\n       auto error = std::move(std::get<ErrorReply>(req));\n       LOG(WARNING) << \"Error while parsing aclfile: \" << error.ToSv();\n@@ -300,13 +310,16 @@ GenericError AclFamily::LoadToRegistryFromFile(std::string_view full_path,\n     User::UpdateRequest default_req;\n     default_req.updates = {User::UpdateRequest::CategoryValueType{User::Sign::MINUS, acl::ALL}};\n     auto& user = registry[usernames[i]];\n-    user.Update(std::move(default_req));\n-    user.Update(std::move(requests[i]));\n+    user.Update(std::move(default_req), CategoryToIdx(), reverse_cat_table_,\n+                CategoryToCommandsIndex());\n+    user.Update(std::move(requests[i]), CategoryToIdx(), reverse_cat_table_,\n+                CategoryToCommandsIndex());\n   }\n \n   if (!registry.contains(\"default\")) {\n     auto& user = registry[\"default\"];\n-    user.Update(registry_->DefaultUserUpdateRequest());\n+    user.Update(registry_->DefaultUserUpdateRequest(), CategoryToIdx(), reverse_cat_table_,\n+                CategoryToCommandsIndex());\n   }\n \n   return {};\n@@ -440,13 +453,13 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {\n   if (args.size() == 1) {\n     ToUpper(&args[0]);\n     std::string_view category = facade::ToSV(args[0]);\n-    if (!CATEGORY_INDEX_TABLE.contains(category)) {\n+    if (!cat_table_.contains(category)) {\n       auto error = absl::StrCat(\"Unkown category: \", category);\n       cntx->SendError(error);\n       return;\n     }\n \n-    const uint32_t cid_mask = CATEGORY_INDEX_TABLE.find(category)->second;\n+    const uint32_t cid_mask = cat_table_.find(category)->second;\n     std::vector<std::string_view> results;\n     // TODO replace this with indexer\n     auto cb = [cid_mask, &results](auto name, auto& cid) {\n@@ -466,7 +479,7 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   size_t total_categories = 0;\n-  for (auto& elem : REVERSE_CATEGORY_INDEX_TABLE) {\n+  for (auto& elem : reverse_cat_table_) {\n     if (elem != \"_RESERVED\") {\n       ++total_categories;\n     }\n@@ -474,7 +487,7 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {\n \n   auto* rb = static_cast<facade::RedisReplyBuilder*>(cntx->reply_builder());\n   rb->StartArray(total_categories);\n-  for (auto& elem : REVERSE_CATEGORY_INDEX_TABLE) {\n+  for (auto& elem : reverse_cat_table_) {\n     if (elem != \"_RESERVED\") {\n       rb->SendSimpleString(elem);\n     }\n@@ -638,6 +651,9 @@ void AclFamily::Register(dfly::CommandRegistry* registry) {\n   *registry << CI{\"ACL GENPASS\", CO::NOSCRIPT | CO::LOADING, -1, 0, 0, acl::kGenPass}.HFUNC(\n       GenPass);\n   cmd_registry_ = registry;\n+\n+  // build indexers\n+  BuildIndexers(cmd_registry_->GetFamilies());\n }\n \n #undef HFUNC\n@@ -655,7 +671,7 @@ void AclFamily::Init(facade::Listener* main_listener, UserRegistry* registry) {\n   if (!acl_file.empty() && Load()) {\n     return;\n   }\n-  registry_->Init();\n+  registry_->Init(&CategoryToIdx(), &reverse_cat_table_, &CategoryToCommandsIndex());\n   config_registry.RegisterMutable(\"aclfile\");\n   config_registry.RegisterMutable(\"acllog_max_len\", [this](const absl::CommandLineFlag& flag) {\n     auto res = flag.TryGet<size_t>();\n@@ -668,4 +684,381 @@ void AclFamily::Init(facade::Listener* main_listener, UserRegistry* registry) {\n   });\n }\n \n+std::string AclFamily::AclCatToString(uint32_t acl_category, User::Sign sign) const {\n+  std::string res = sign == User::Sign::PLUS ? \"+@\" : \"-@\";\n+  if (acl_category == acl::ALL) {\n+    absl::StrAppend(&res, \"all\");\n+    return res;\n+  }\n+\n+  const auto& index = CategoryToIdx().at(acl_category);\n+  absl::StrAppend(&res, absl::AsciiStrToLower(reverse_cat_table_[index]));\n+  return res;\n+}\n+\n+std::string AclFamily::AclCommandToString(size_t family, uint64_t mask, User::Sign sign) const {\n+  // This is constant but can be optimized with an indexer\n+  const auto& rev_index = CommandsRevIndexer();\n+  std::string res;\n+  std::string prefix = (sign == User::Sign::PLUS) ? \"+\" : \"-\";\n+  if (mask == ALL_COMMANDS) {\n+    for (const auto& cmd : rev_index[family]) {\n+      absl::StrAppend(&res, prefix, absl::AsciiStrToLower(cmd), \" \");\n+    }\n+    res.pop_back();\n+    return res;\n+  }\n+\n+  size_t pos = 0;\n+  while (mask != 0) {\n+    ++pos;\n+    mask = mask >> 1;\n+  }\n+  --pos;\n+  absl::StrAppend(&res, prefix, absl::AsciiStrToLower(rev_index[family][pos]));\n+  return res;\n+}\n+\n+namespace {\n+struct CategoryAndMetadata {\n+  User::CategoryChange change;\n+  User::ChangeMetadata metadata;\n+};\n+\n+struct CommandAndMetadata {\n+  User::CommandChange change;\n+  User::ChangeMetadata metadata;\n+};\n+\n+using MergeResult = std::vector<std::variant<CategoryAndMetadata, CommandAndMetadata>>;\n+\n+MergeResult MergeTables(const User::CategoryChanges& categories,\n+                        const User::CommandChanges& commands) {\n+  MergeResult result;\n+  for (auto [cat, meta] : categories) {\n+    result.push_back(CategoryAndMetadata{cat, meta});\n+  }\n+\n+  for (auto [cmd, meta] : commands) {\n+    result.push_back(CommandAndMetadata{cmd, meta});\n+  }\n+\n+  std::sort(result.begin(), result.end(), [](const auto& l, const auto& r) {\n+    auto fetch = [](const auto& l) { return l.metadata.seq_no; };\n+    return std::visit(fetch, l) < std::visit(fetch, r);\n+  });\n+\n+  return result;\n+}\n+\n+using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;\n+\n+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n+                                             std::string_view file_contents) {\n+  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400\n+  // characters per line\n+  std::vector<std::string_view> commands = absl::StrSplit(file_contents, \"\\n\");\n+  std::vector<std::vector<std::string_view>> materialized;\n+  materialized.reserve(commands.size());\n+  usernames->reserve(commands.size());\n+  for (auto& command : commands) {\n+    if (command.empty())\n+      continue;\n+    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');\n+    if (!absl::EqualsIgnoreCase(cmds[0], \"USER\") || cmds.size() < 4) {\n+      return {};\n+    }\n+\n+    usernames->push_back(std::string(cmds[1]));\n+    cmds.erase(cmds.begin(), cmds.begin() + 2);\n+    materialized.push_back(cmds);\n+  }\n+  return materialized;\n+}\n+\n+struct ParseKeyResult {\n+  std::string glob;\n+  KeyOp op;\n+  bool all_keys{false};\n+  bool reset_keys{false};\n+};\n+\n+std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command) {\n+  if (absl::EqualsIgnoreCase(command, \"ALLKEYS\") || command == \"~*\") {\n+    return ParseKeyResult{\"\", {}, true};\n+  }\n+\n+  if (absl::EqualsIgnoreCase(command, \"RESETKEYS\")) {\n+    return ParseKeyResult{\"\", {}, false, true};\n+  }\n+\n+  auto op = KeyOp::READ_WRITE;\n+\n+  if (absl::StartsWith(command, \"%RW\")) {\n+    command = command.substr(3);\n+  } else if (absl::StartsWith(command, \"%R\")) {\n+    op = KeyOp::READ;\n+    command = command.substr(2);\n+  } else if (absl::StartsWith(command, \"%W\")) {\n+    op = KeyOp::WRITE;\n+    command = command.substr(2);\n+  }\n+\n+  if (!absl::StartsWith(command, \"~\")) {\n+    return {};\n+  }\n+\n+  auto key = command.substr(1);\n+  if (key.empty()) {\n+    return {};\n+  }\n+  return ParseKeyResult{std::string(key), op};\n+}\n+\n+std::string PrettyPrintSha(std::string_view pass, bool all) {\n+  if (all) {\n+    return absl::BytesToHexString(pass);\n+  }\n+  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);\n+};\n+\n+std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed) {\n+  using UpPass = User::UpdatePass;\n+  if (command == \"nopass\") {\n+    return UpPass{\"\", false, true};\n+  }\n+\n+  if (command == \"resetpass\") {\n+    return UpPass{\"\", false, false, true};\n+  }\n+\n+  if (command[0] == '>' || (hashed && command[0] == '#')) {\n+    return UpPass{std::string(command.substr(1))};\n+  }\n+\n+  if (command[0] == '<') {\n+    return UpPass{std::string(command.substr(1)), true};\n+  }\n+\n+  return {};\n+}\n+\n+std::optional<bool> MaybeParseStatus(std::string_view command) {\n+  if (command == \"ON\") {\n+    return true;\n+  }\n+  if (command == \"OFF\") {\n+    return false;\n+  }\n+  return {};\n+}\n+\n+std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,\n+                              bool full_sha) {\n+  if (nopass) {\n+    return \"nopass \";\n+  }\n+  std::string result;\n+  for (const auto& pass : passwords) {\n+    absl::StrAppend(&result, \"#\", PrettyPrintSha(pass, full_sha), \" \");\n+  }\n+\n+  return result;\n+}\n+\n+std::string AclKeysToString(const AclKeys& keys) {\n+  if (keys.all_keys) {\n+    return \"~*\";\n+  }\n+  std::string result;\n+  for (auto& [pattern, op] : keys.key_globs) {\n+    if (op == KeyOp::READ_WRITE) {\n+      absl::StrAppend(&result, \"~\", pattern, \" \");\n+      continue;\n+    }\n+    std::string op_str = (op == KeyOp::READ) ? \"R\" : \"W\";\n+    absl::StrAppend(&result, \"%\", op_str, \"~\", pattern, \" \");\n+  }\n+\n+  if (!result.empty()) {\n+    result.pop_back();\n+  }\n+  return result;\n+}\n+\n+}  // namespace\n+\n+std::string AclFamily::AclCatAndCommandToString(const User::CategoryChanges& cat,\n+                                                const User::CommandChanges& cmds) const {\n+  std::string result;\n+\n+  auto tables = MergeTables(cat, cmds);\n+\n+  auto cat_visitor = [&result, this](const CategoryAndMetadata& val) {\n+    const auto& [change, meta] = val;\n+    absl::StrAppend(&result, AclCatToString(change, meta.sign), \" \");\n+  };\n+\n+  auto cmd_visitor = [&result, this](const CommandAndMetadata& val) {\n+    const auto& [change, meta] = val;\n+    const auto [family, bit_index] = change;\n+    absl::StrAppend(&result, AclCommandToString(family, bit_index, meta.sign), \" \");\n+  };\n+\n+  Overloaded visitor{cat_visitor, cmd_visitor};\n+\n+  for (auto change : tables) {\n+    std::visit(visitor, change);\n+  }\n+\n+  if (!result.empty()) {\n+    result.pop_back();\n+  }\n+\n+  return result;\n+}\n+\n+using OptCat = std::optional<uint32_t>;\n+\n+// bool == true if +\n+// bool == false if -\n+std::pair<OptCat, bool> AclFamily::MaybeParseAclCategory(std::string_view command) const {\n+  if (absl::StartsWith(command, \"+@\")) {\n+    auto res = cat_table_.find(command.substr(2));\n+    if (res == cat_table_.end()) {\n+      return {};\n+    }\n+    return {res->second, true};\n+  }\n+\n+  if (absl::StartsWith(command, \"-@\")) {\n+    auto res = cat_table_.find(command.substr(2));\n+    if (res == cat_table_.end()) {\n+      return {};\n+    }\n+    return {res->second, false};\n+  }\n+\n+  return {};\n+}\n+\n+std::pair<AclFamily::OptCommand, bool> AclFamily::MaybeParseAclCommand(\n+    std::string_view command) const {\n+  if (absl::StartsWith(command, \"+\")) {\n+    auto res = cmd_registry_->Find(command.substr(1));\n+    if (!res) {\n+      return {};\n+    }\n+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n+    return {cmd, true};\n+  }\n+\n+  if (absl::StartsWith(command, \"-\")) {\n+    auto res = cmd_registry_->Find(command.substr(1));\n+    if (!res) {\n+      return {};\n+    }\n+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n+    return {cmd, false};\n+  }\n+\n+  return {};\n+}\n+\n+using facade::ErrorReply;\n+\n+std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(\n+    const facade::ArgRange& args, bool hashed, bool has_all_keys) const {\n+  User::UpdateRequest req;\n+\n+  for (std::string_view arg : args) {\n+    if (auto pass = MaybeParsePassword(facade::ToSV(arg), hashed); pass) {\n+      req.passwords.push_back(std::move(*pass));\n+\n+      if (hashed && absl::StartsWith(facade::ToSV(arg), \"#\")) {\n+        req.passwords.back().is_hashed = true;\n+      }\n+      continue;\n+    }\n+\n+    if (auto res = MaybeParseAclKey(facade::ToSV(arg)); res) {\n+      auto& [glob, op, all_keys, reset_keys] = *res;\n+      if ((has_all_keys && !all_keys && !reset_keys) ||\n+          (req.allow_all_keys && !all_keys && !reset_keys)) {\n+        return ErrorReply(\n+            \"Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * pattern (or the \"\n+            \"'allkeys' flag) is not valid and does not have any effect. Try 'resetkeys' to start \"\n+            \"with an empty list of patterns\");\n+      }\n+\n+      req.allow_all_keys = all_keys;\n+      req.reset_all_keys = reset_keys;\n+      if (reset_keys) {\n+        has_all_keys = false;\n+      }\n+      req.keys.push_back({std::move(glob), op, all_keys, reset_keys});\n+      continue;\n+    }\n+\n+    std::string command = absl::AsciiStrToUpper(arg);\n+\n+    if (auto status = MaybeParseStatus(command); status) {\n+      if (req.is_active) {\n+        return ErrorReply(\"Multiple ON/OFF are not allowed\");\n+      }\n+      req.is_active = *status;\n+      continue;\n+    }\n+\n+    auto [cat, add] = MaybeParseAclCategory(command);\n+    if (cat) {\n+      using Sign = User::Sign;\n+      using Val = std::pair<Sign, uint32_t>;\n+      auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};\n+      req.updates.push_back(val);\n+      continue;\n+    }\n+\n+    auto [cmd, sign] = MaybeParseAclCommand(command);\n+    if (!cmd) {\n+      return ErrorReply(absl::StrCat(\"Unrecognized parameter \", command));\n+    }\n+\n+    using Sign = User::Sign;\n+    using Val = User::UpdateRequest::CommandsValueType;\n+    auto [index, bit] = *cmd;\n+    auto val = sign ? Val{Sign::PLUS, index, bit} : Val{Sign::MINUS, index, bit};\n+    req.updates.push_back(val);\n+  }\n+\n+  return req;\n+}\n+\n+void AclFamily::BuildIndexers(RevCommandsIndexStore families) {\n+  acl::NumberOfFamilies(families.size());\n+  CommandsRevIndexer(std::move(families));\n+  CategoryToCommandsIndexStore index;\n+  cmd_registry_->Traverse([&](std::string_view name, auto& cid) {\n+    auto cat = cid.acl_categories();\n+    for (size_t i = 0; i < 32; ++i) {\n+      if (cat & (1 << i)) {\n+        std::string_view cat_name = reverse_cat_table_[i];\n+        if (index[cat_name].empty()) {\n+          index[cat_name].resize(CommandsRevIndexer().size());\n+        }\n+        auto family = cid.GetFamily();\n+        auto bit_index = cid.GetBitIndex();\n+        index[cat_name][family] |= bit_index;\n+      }\n+    }\n+  });\n+\n+  CategoryToCommandsIndex(std::move(index));\n+  CategoryToIdxStore idx_store;\n+  for (size_t i = 0; i < 32; ++i) {\n+    idx_store[1 << i] = i;\n+  }\n+  CategoryToIdx(std::move(idx_store));\n+}\n+\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h\nindex 61439f36d62f..143e29f02d82 100644\n--- a/src/server/acl/acl_family.h\n+++ b/src/server/acl/acl_family.h\n@@ -13,6 +13,7 @@\n #include \"facade/dragonfly_listener.h\"\n #include \"facade/facade_types.h\"\n #include \"helio/util/proactor_pool.h\"\n+#include \"server/acl/acl_commands_def.h\"\n #include \"server/acl/user_registry.h\"\n #include \"server/command_registry.h\"\n #include \"server/common.h\"\n@@ -62,12 +63,107 @@ class AclFamily final {\n   // Helper function that loads the acl state of an acl file into the user registry\n   GenericError LoadToRegistryFromFile(std::string_view full_path, ConnectionContext* init);\n \n+  // Serializes the whole registry into a string\n   std::string RegistryToString() const;\n \n+  std::string AclCatToString(uint32_t acl_category, User::Sign sign) const;\n+\n+  std::string AclCommandToString(size_t family, uint64_t mask, User::Sign sign) const;\n+\n+  // Serializes category and command to string\n+  std::string AclCatAndCommandToString(const User::CategoryChanges& cat,\n+                                       const User::CommandChanges& cmds) const;\n+\n+  using OptCat = std::optional<uint32_t>;\n+  std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) const;\n+\n+  using OptCommand = std::optional<std::pair<size_t, uint64_t>>;\n+  std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command) const;\n+\n+  std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(\n+      const facade::ArgRange& args, bool hashed = false, bool has_all_keys = false) const;\n+\n+  void BuildIndexers(RevCommandsIndexStore families);\n+\n+  // Data members\n+\n   facade::Listener* main_listener_{nullptr};\n   UserRegistry* registry_;\n   CommandRegistry* cmd_registry_;\n   util::ProactorPool* pool_;\n+\n+  // Indexes\n+\n+  // See definitions for NONE and ALL in facade/acl_commands_def.h\n+  const CategoryIndexTable cat_table_{{\"KEYSPACE\", KEYSPACE},\n+                                      {\"READ\", READ},\n+                                      {\"WRITE\", WRITE},\n+                                      {\"SET\", SET},\n+                                      {\"SORTEDSET\", SORTEDSET},\n+                                      {\"LIST\", LIST},\n+                                      {\"HASH\", HASH},\n+                                      {\"STRING\", STRING},\n+                                      {\"BITMAP\", BITMAP},\n+                                      {\"HYPERLOG\", HYPERLOGLOG},\n+                                      {\"GEO\", GEO},\n+                                      {\"STREAM\", STREAM},\n+                                      {\"PUBSUB\", PUBSUB},\n+                                      {\"ADMIN\", ADMIN},\n+                                      {\"FAST\", FAST},\n+                                      {\"SLOW\", SLOW},\n+                                      {\"BLOCKING\", BLOCKING},\n+                                      {\"DANGEROUS\", DANGEROUS},\n+                                      {\"CONNECTION\", CONNECTION},\n+                                      {\"TRANSACTION\", TRANSACTION},\n+                                      {\"SCRIPTING\", SCRIPTING},\n+                                      {\"BLOOM\", BLOOM},\n+                                      {\"FT_SEARCH\", FT_SEARCH},\n+                                      {\"THROTTLE\", THROTTLE},\n+                                      {\"JSON\", JSON},\n+                                      {\"ALL\", ALL},\n+                                      {\"NONE\", NONE}};\n+\n+  // bit 0 at index 0\n+  // bit 1 at index 1\n+  // bit n at index n\n+  const ReverseCategoryIndexTable reverse_cat_table_{\n+      \"KEYSPACE\",  \"READ\",      \"WRITE\",     \"SET\",       \"SORTEDSET\",  \"LIST\",        \"HASH\",\n+      \"STRING\",    \"BITMAP\",    \"HYPERLOG\",  \"GEO\",       \"STREAM\",     \"PUBSUB\",      \"ADMIN\",\n+      \"FAST\",      \"SLOW\",      \"BLOCKING\",  \"DANGEROUS\", \"CONNECTION\", \"TRANSACTION\", \"SCRIPTING\",\n+      \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\",  \"_RESERVED\",   \"_RESERVED\",\n+      \"BLOOM\",     \"FT_SEARCH\", \"THROTTLE\",  \"JSON\"};\n+\n+  // We need this to act as a const member, since the initialization of const data members\n+  // must be done on the constructor. However, these are initialized a little later, when\n+  // we Register the commands\n+  const CategoryToIdxStore& CategoryToIdx(CategoryToIdxStore store = {}) const {\n+    static CategoryToIdxStore cat_idx = std::move(store);\n+    return cat_idx;\n+  }\n+\n+  const RevCommandsIndexStore& CommandsRevIndexer(RevCommandsIndexStore store = {}) const {\n+    static RevCommandsIndexStore rev_index_store = std::move(store);\n+    return rev_index_store;\n+  }\n+\n+  const CategoryToCommandsIndexStore& CategoryToCommandsIndex(\n+      CategoryToCommandsIndexStore store = {}) const {\n+    static CategoryToCommandsIndexStore index = std::move(store);\n+    return index;\n+  }\n+\n+  // Only for testing interface\n+ public:\n+  // Helper accessors for tests. Do not use them directly.\n+  const ReverseCategoryIndexTable& GetRevTable() const {\n+    return reverse_cat_table_;\n+  }\n+\n+  // We could make CommandsRevIndexer public, but I want this to be\n+  // clear that this is for TESTING so do not use this in the codebase\n+  const RevCommandsIndexStore& GetCommandsRevIndexer() const {\n+    return CommandsRevIndexer();\n+  }\n };\n \n }  // namespace acl\ndiff --git a/src/server/acl/helpers.cc b/src/server/acl/helpers.cc\ndeleted file mode 100644\nindex 2471b11bf715..000000000000\n--- a/src/server/acl/helpers.cc\n+++ /dev/null\n@@ -1,368 +0,0 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n-// See LICENSE for licensing terms.\n-//\n-\n-#include \"server/acl/helpers.h\"\n-\n-#include <limits>\n-#include <vector>\n-\n-#include \"absl/strings/ascii.h\"\n-#include \"absl/strings/escaping.h\"\n-#include \"absl/strings/match.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_split.h\"\n-#include \"core/overloaded.h\"\n-#include \"facade/acl_commands_def.h\"\n-#include \"server/acl/acl_commands_def.h\"\n-#include \"server/acl/user.h\"\n-#include \"server/common.h\"\n-\n-namespace dfly::acl {\n-\n-namespace {\n-\n-std::string AclCatToString(uint32_t acl_category, User::Sign sign) {\n-  std::string res = sign == User::Sign::PLUS ? \"+@\" : \"-@\";\n-  if (acl_category == acl::ALL) {\n-    absl::StrAppend(&res, \"all\");\n-    return res;\n-  }\n-\n-  const auto& index = CategoryToIdx().at(acl_category);\n-  absl::StrAppend(&res, absl::AsciiStrToLower(REVERSE_CATEGORY_INDEX_TABLE[index]));\n-  return res;\n-}\n-\n-std::string AclCommandToString(size_t family, uint64_t mask, User::Sign sign) {\n-  // This is constant but can be optimized with an indexer\n-  const auto& rev_index = CommandsRevIndexer();\n-  std::string res;\n-  std::string prefix = (sign == User::Sign::PLUS) ? \"+\" : \"-\";\n-  if (mask == ALL_COMMANDS) {\n-    for (const auto& cmd : rev_index[family]) {\n-      absl::StrAppend(&res, prefix, absl::AsciiStrToLower(cmd), \" \");\n-    }\n-    res.pop_back();\n-    return res;\n-  }\n-\n-  size_t pos = 0;\n-  while (mask != 0) {\n-    ++pos;\n-    mask = mask >> 1;\n-  }\n-  --pos;\n-  absl::StrAppend(&res, prefix, absl::AsciiStrToLower(rev_index[family][pos]));\n-  return res;\n-}\n-\n-struct CategoryAndMetadata {\n-  User::CategoryChange change;\n-  User::ChangeMetadata metadata;\n-};\n-\n-struct CommandAndMetadata {\n-  User::CommandChange change;\n-  User::ChangeMetadata metadata;\n-};\n-\n-using MergeResult = std::vector<std::variant<CategoryAndMetadata, CommandAndMetadata>>;\n-\n-}  // namespace\n-\n-// Merge Category and Command changes and sort them by global order seq_no\n-MergeResult MergeTables(const User::CategoryChanges& categories,\n-                        const User::CommandChanges& commands) {\n-  MergeResult result;\n-  for (auto [cat, meta] : categories) {\n-    result.push_back(CategoryAndMetadata{cat, meta});\n-  }\n-\n-  for (auto [cmd, meta] : commands) {\n-    result.push_back(CommandAndMetadata{cmd, meta});\n-  }\n-\n-  std::sort(result.begin(), result.end(), [](const auto& l, const auto& r) {\n-    auto fetch = [](const auto& l) { return l.metadata.seq_no; };\n-    return std::visit(fetch, l) < std::visit(fetch, r);\n-  });\n-\n-  return result;\n-}\n-\n-std::string AclCatAndCommandToString(const User::CategoryChanges& cat,\n-                                     const User::CommandChanges& cmds) {\n-  std::string result;\n-\n-  auto tables = MergeTables(cat, cmds);\n-\n-  auto cat_visitor = [&result](const CategoryAndMetadata& val) {\n-    const auto& [change, meta] = val;\n-    absl::StrAppend(&result, AclCatToString(change, meta.sign), \" \");\n-  };\n-\n-  auto cmd_visitor = [&result](const CommandAndMetadata& val) {\n-    const auto& [change, meta] = val;\n-    const auto [family, bit_index] = change;\n-    absl::StrAppend(&result, AclCommandToString(family, bit_index, meta.sign), \" \");\n-  };\n-\n-  Overloaded visitor{cat_visitor, cmd_visitor};\n-\n-  for (auto change : tables) {\n-    std::visit(visitor, change);\n-  }\n-\n-  if (!result.empty()) {\n-    result.pop_back();\n-  }\n-\n-  return result;\n-}\n-\n-std::string PrettyPrintSha(std::string_view pass, bool all) {\n-  if (all) {\n-    return absl::BytesToHexString(pass);\n-  }\n-  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);\n-};\n-\n-std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command) {\n-  if (absl::EqualsIgnoreCase(command, \"ALLKEYS\") || command == \"~*\") {\n-    return ParseKeyResult{\"\", {}, true};\n-  }\n-\n-  if (absl::EqualsIgnoreCase(command, \"RESETKEYS\")) {\n-    return ParseKeyResult{\"\", {}, false, true};\n-  }\n-\n-  auto op = KeyOp::READ_WRITE;\n-\n-  if (absl::StartsWith(command, \"%RW\")) {\n-    command = command.substr(3);\n-  } else if (absl::StartsWith(command, \"%R\")) {\n-    op = KeyOp::READ;\n-    command = command.substr(2);\n-  } else if (absl::StartsWith(command, \"%W\")) {\n-    op = KeyOp::WRITE;\n-    command = command.substr(2);\n-  }\n-\n-  if (!absl::StartsWith(command, \"~\")) {\n-    return {};\n-  }\n-\n-  auto key = command.substr(1);\n-  if (key.empty()) {\n-    return {};\n-  }\n-  return ParseKeyResult{std::string(key), op};\n-}\n-\n-std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed) {\n-  using UpPass = User::UpdatePass;\n-  if (command == \"nopass\") {\n-    return UpPass{\"\", false, true};\n-  }\n-\n-  if (command == \"resetpass\") {\n-    return UpPass{\"\", false, false, true};\n-  }\n-\n-  if (command[0] == '>' || (hashed && command[0] == '#')) {\n-    return UpPass{std::string(command.substr(1))};\n-  }\n-\n-  if (command[0] == '<') {\n-    return UpPass{std::string(command.substr(1)), true};\n-  }\n-\n-  return {};\n-}\n-\n-std::optional<bool> MaybeParseStatus(std::string_view command) {\n-  if (command == \"ON\") {\n-    return true;\n-  }\n-  if (command == \"OFF\") {\n-    return false;\n-  }\n-  return {};\n-}\n-\n-using OptCat = std::optional<uint32_t>;\n-\n-// bool == true if +\n-// bool == false if -\n-std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) {\n-  if (absl::StartsWith(command, \"+@\")) {\n-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n-    if (res == CATEGORY_INDEX_TABLE.end()) {\n-      return {};\n-    }\n-    return {res->second, true};\n-  }\n-\n-  if (absl::StartsWith(command, \"-@\")) {\n-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n-    if (res == CATEGORY_INDEX_TABLE.end()) {\n-      return {};\n-    }\n-    return {res->second, false};\n-  }\n-\n-  return {};\n-}\n-\n-std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,\n-                                                 const CommandRegistry& registry) {\n-  if (absl::StartsWith(command, \"+\")) {\n-    auto res = registry.Find(command.substr(1));\n-    if (!res) {\n-      return {};\n-    }\n-    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n-    return {cmd, true};\n-  }\n-\n-  if (absl::StartsWith(command, \"-\")) {\n-    auto res = registry.Find(command.substr(1));\n-    if (!res) {\n-      return {};\n-    }\n-    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n-    return {cmd, false};\n-  }\n-\n-  return {};\n-}\n-\n-MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n-                                             std::string_view file_contents) {\n-  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400\n-  // characters per line\n-  std::vector<std::string_view> commands = absl::StrSplit(file_contents, \"\\n\");\n-  std::vector<std::vector<std::string_view>> materialized;\n-  materialized.reserve(commands.size());\n-  usernames->reserve(commands.size());\n-  for (auto& command : commands) {\n-    if (command.empty())\n-      continue;\n-    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');\n-    if (!absl::EqualsIgnoreCase(cmds[0], \"USER\") || cmds.size() < 4) {\n-      return {};\n-    }\n-\n-    usernames->push_back(std::string(cmds[1]));\n-    cmds.erase(cmds.begin(), cmds.begin() + 2);\n-    materialized.push_back(cmds);\n-  }\n-  return materialized;\n-}\n-\n-using facade::ErrorReply;\n-\n-std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser(facade::ArgRange args,\n-                                                              const CommandRegistry& registry,\n-                                                              bool hashed, bool has_all_keys) {\n-  User::UpdateRequest req;\n-\n-  for (std::string_view arg : args) {\n-    if (auto pass = MaybeParsePassword(facade::ToSV(arg), hashed); pass) {\n-      req.passwords.push_back(std::move(*pass));\n-\n-      if (hashed && absl::StartsWith(facade::ToSV(arg), \"#\")) {\n-        req.passwords.back().is_hashed = true;\n-      }\n-      continue;\n-    }\n-\n-    if (auto res = MaybeParseAclKey(facade::ToSV(arg)); res) {\n-      auto& [glob, op, all_keys, reset_keys] = *res;\n-      if ((has_all_keys && !all_keys && !reset_keys) ||\n-          (req.allow_all_keys && !all_keys && !reset_keys)) {\n-        return ErrorReply(\n-            \"Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * pattern (or the \"\n-            \"'allkeys' flag) is not valid and does not have any effect. Try 'resetkeys' to start \"\n-            \"with an empty list of patterns\");\n-      }\n-\n-      req.allow_all_keys = all_keys;\n-      req.reset_all_keys = reset_keys;\n-      if (reset_keys) {\n-        has_all_keys = false;\n-      }\n-      req.keys.push_back({std::move(glob), op, all_keys, reset_keys});\n-      continue;\n-    }\n-\n-    std::string command = absl::AsciiStrToUpper(arg);\n-\n-    if (auto status = MaybeParseStatus(command); status) {\n-      if (req.is_active) {\n-        return ErrorReply(\"Multiple ON/OFF are not allowed\");\n-      }\n-      req.is_active = *status;\n-      continue;\n-    }\n-\n-    auto [cat, add] = MaybeParseAclCategory(command);\n-    if (cat) {\n-      using Sign = User::Sign;\n-      using Val = std::pair<Sign, uint32_t>;\n-      auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};\n-      req.updates.push_back(val);\n-      continue;\n-    }\n-\n-    auto [cmd, sign] = MaybeParseAclCommand(command, registry);\n-    if (!cmd) {\n-      return ErrorReply(absl::StrCat(\"Unrecognized parameter \", command));\n-    }\n-\n-    using Sign = User::Sign;\n-    using Val = User::UpdateRequest::CommandsValueType;\n-    auto [index, bit] = *cmd;\n-    auto val = sign ? Val{Sign::PLUS, index, bit} : Val{Sign::MINUS, index, bit};\n-    req.updates.push_back(val);\n-  }\n-\n-  return req;\n-}\n-\n-using facade::CmdArgList;\n-\n-std::string AclKeysToString(const AclKeys& keys) {\n-  if (keys.all_keys) {\n-    return \"~*\";\n-  }\n-  std::string result;\n-  for (auto& [pattern, op] : keys.key_globs) {\n-    if (op == KeyOp::READ_WRITE) {\n-      absl::StrAppend(&result, \"~\", pattern, \" \");\n-      continue;\n-    }\n-    std::string op_str = (op == KeyOp::READ) ? \"R\" : \"W\";\n-    absl::StrAppend(&result, \"%\", op_str, \"~\", pattern, \" \");\n-  }\n-\n-  if (!result.empty()) {\n-    result.pop_back();\n-  }\n-  return result;\n-}\n-\n-std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,\n-                              bool full_sha) {\n-  if (nopass) {\n-    return \"nopass \";\n-  }\n-  std::string result;\n-  for (const auto& pass : passwords) {\n-    absl::StrAppend(&result, \"#\", PrettyPrintSha(pass, full_sha), \" \");\n-  }\n-\n-  return result;\n-}\n-}  // namespace dfly::acl\ndiff --git a/src/server/acl/helpers.h b/src/server/acl/helpers.h\ndeleted file mode 100644\nindex 75cbd4d8b491..000000000000\n--- a/src/server/acl/helpers.h\n+++ /dev/null\n@@ -1,63 +0,0 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n-// See LICENSE for licensing terms.\n-//\n-\n-#pragma once\n-\n-#include <cstdint>\n-#include <optional>\n-#include <string>\n-#include <string_view>\n-#include <variant>\n-\n-#include \"absl/container/flat_hash_set.h\"\n-#include \"facade/facade_types.h\"\n-#include \"server/acl/acl_log.h\"\n-#include \"server/acl/user.h\"\n-#include \"server/command_registry.h\"\n-\n-namespace dfly::acl {\n-\n-std::string AclCatAndCommandToString(const User::CategoryChanges& cat,\n-                                     const User::CommandChanges& cmds);\n-\n-std::string PrettyPrintSha(std::string_view pass, bool all = false);\n-\n-// When hashed is true, we allow passwords that start with both # and >\n-std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed = false);\n-\n-std::optional<bool> MaybeParseStatus(std::string_view command);\n-\n-using OptCat = std::optional<uint32_t>;\n-std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command);\n-\n-bool IsIndexAllCommandsFlag(size_t index);\n-\n-using OptCommand = std::optional<std::pair<size_t, uint64_t>>;\n-std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,\n-                                                 const CommandRegistry& registry);\n-\n-std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(\n-    facade::ArgRange args, const CommandRegistry& registry, bool hashed = false,\n-    bool has_all_keys = false);\n-\n-using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;\n-\n-MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n-                                             std::string_view file_contents);\n-\n-struct ParseKeyResult {\n-  std::string glob;\n-  KeyOp op;\n-  bool all_keys{false};\n-  bool reset_keys{false};\n-};\n-\n-std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command);\n-\n-std::string AclKeysToString(const AclKeys& keys);\n-\n-std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,\n-                              bool full_sha);\n-\n-}  // namespace dfly::acl\ndiff --git a/src/server/acl/user.cc b/src/server/acl/user.cc\nindex 37ae93432fc6..fa59c7a25278 100644\n--- a/src/server/acl/user.cc\n+++ b/src/server/acl/user.cc\n@@ -11,7 +11,6 @@\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/strings/escaping.h\"\n #include \"core/overloaded.h\"\n-#include \"server/acl/helpers.h\"\n \n namespace dfly::acl {\n \n@@ -30,7 +29,9 @@ User::User() {\n   commands_ = std::vector<uint64_t>(NumberOfFamilies(), 0);\n }\n \n-void User::Update(UpdateRequest&& req) {\n+void User::Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,\n+                  const ReverseCategoryIndexTable& reverse_cat,\n+                  const CategoryToCommandsIndexStore& cat_to_commands) {\n   for (auto& pass : req.passwords) {\n     if (pass.nopass) {\n       SetNopass();\n@@ -47,13 +48,13 @@ void User::Update(UpdateRequest&& req) {\n     SetPasswordHash(pass.password, pass.is_hashed);\n   }\n \n-  auto cat_visitor = [this](UpdateRequest::CategoryValueType cat) {\n+  auto cat_visitor = [&, this](UpdateRequest::CategoryValueType cat) {\n     auto [sign, category] = cat;\n     if (sign == Sign::PLUS) {\n-      SetAclCategoriesAndIncrSeq(category);\n+      SetAclCategoriesAndIncrSeq(category, cat_to_id, reverse_cat, cat_to_commands);\n       return;\n     }\n-    UnsetAclCategoriesAndIncrSeq(category);\n+    UnsetAclCategoriesAndIncrSeq(category, cat_to_id, reverse_cat, cat_to_commands);\n   };\n \n   auto cmd_visitor = [this](UpdateRequest::CommandsValueType cmd) {\n@@ -100,14 +101,16 @@ bool User::HasPassword(std::string_view password) const {\n   return password_hashes_.contains(StringSHA256(password));\n }\n \n-void User::SetAclCategoriesAndIncrSeq(uint32_t cat) {\n+void User::SetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,\n+                                      const ReverseCategoryIndexTable& reverse_cat,\n+                                      const CategoryToCommandsIndexStore& cat_to_commands) {\n   acl_categories_ |= cat;\n   if (cat == acl::ALL) {\n     SetAclCommands(std::numeric_limits<size_t>::max(), 0);\n   } else {\n-    auto id = CategoryToIdx().at(cat);\n-    std::string_view name = REVERSE_CATEGORY_INDEX_TABLE[id];\n-    const auto& commands_group = CategoryToCommandsIndex().at(name);\n+    auto id = cat_to_id.at(cat);\n+    std::string_view name = reverse_cat[id];\n+    const auto& commands_group = cat_to_commands.at(name);\n     for (size_t fam_id = 0; fam_id < commands_group.size(); ++fam_id) {\n       SetAclCommands(fam_id, commands_group[fam_id]);\n     }\n@@ -117,14 +120,16 @@ void User::SetAclCategoriesAndIncrSeq(uint32_t cat) {\n   cat_changes_[change] = ChangeMetadata{Sign::PLUS, seq_++};\n }\n \n-void User::UnsetAclCategoriesAndIncrSeq(uint32_t cat) {\n+void User::UnsetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,\n+                                        const ReverseCategoryIndexTable& reverse_cat,\n+                                        const CategoryToCommandsIndexStore& cat_to_commands) {\n   acl_categories_ ^= cat;\n   if (cat == acl::ALL) {\n     UnsetAclCommands(std::numeric_limits<size_t>::max(), 0);\n   } else {\n-    auto id = CategoryToIdx().at(cat);\n-    std::string_view name = REVERSE_CATEGORY_INDEX_TABLE[id];\n-    const auto& commands_group = CategoryToCommandsIndex().at(name);\n+    auto id = cat_to_id.at(cat);\n+    std::string_view name = reverse_cat[id];\n+    const auto& commands_group = cat_to_commands.at(name);\n     for (size_t fam_id = 0; fam_id < commands_group.size(); ++fam_id) {\n       UnsetAclCommands(fam_id, commands_group[fam_id]);\n     }\ndiff --git a/src/server/acl/user.h b/src/server/acl/user.h\nindex 0aafdb59994b..d8e44029394f 100644\n--- a/src/server/acl/user.h\n+++ b/src/server/acl/user.h\n@@ -81,7 +81,9 @@ class User final {\n   User(User&&) = default;\n \n   // For single step updates\n-  void Update(UpdateRequest&& req);\n+  void Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,\n+              const ReverseCategoryIndexTable& reverse_cat,\n+              const CategoryToCommandsIndexStore& cat_to_commands);\n \n   bool HasPassword(std::string_view password) const;\n \n@@ -110,8 +112,12 @@ class User final {\n   const CommandChanges& CmdChanges() const;\n \n  private:\n-  void SetAclCategoriesAndIncrSeq(uint32_t cat);\n-  void UnsetAclCategoriesAndIncrSeq(uint32_t cat);\n+  void SetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,\n+                                  const ReverseCategoryIndexTable& reverse_cat,\n+                                  const CategoryToCommandsIndexStore& cat_to_commands);\n+  void UnsetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,\n+                                    const ReverseCategoryIndexTable& reverse_cat,\n+                                    const CategoryToCommandsIndexStore& cat_to_commands);\n \n   // For ACL commands\n   void SetAclCommands(size_t index, uint64_t bit_index);\ndiff --git a/src/server/acl/user_registry.cc b/src/server/acl/user_registry.cc\nindex 9bd9645bff6c..ae252ea3ad91 100644\n--- a/src/server/acl/user_registry.cc\n+++ b/src/server/acl/user_registry.cc\n@@ -21,7 +21,7 @@ namespace dfly::acl {\n void UserRegistry::MaybeAddAndUpdate(std::string_view username, User::UpdateRequest req) {\n   std::unique_lock<fb2::SharedMutex> lock(mu_);\n   auto& user = registry_[username];\n-  user.Update(std::move(req));\n+  user.Update(std::move(req), *cat_to_id_table_, *reverse_cat_table_, *cat_to_commands_table_);\n }\n \n bool UserRegistry::RemoveUser(std::string_view username) {\n@@ -79,11 +79,16 @@ User::UpdateRequest UserRegistry::DefaultUserUpdateRequest() const {\n   return {std::move(pass), true, false, {std::move(acl)}, {std::move(key)}};\n }\n \n-void UserRegistry::Init() {\n+void UserRegistry::Init(const CategoryToIdxStore* cat_to_id_table,\n+                        const ReverseCategoryIndexTable* reverse_cat_table,\n+                        const CategoryToCommandsIndexStore* cat_to_commands_table) {\n   // if there exists an acl file to load from, requirepass\n   // will not overwrite the default's user password loaded from\n   // that file. Loading the default's user password from a file\n   // has higher priority than the deprecated flag\n+  cat_to_id_table_ = cat_to_id_table;\n+  reverse_cat_table_ = reverse_cat_table;\n+  cat_to_commands_table_ = cat_to_commands_table;\n   auto default_user = DefaultUserUpdateRequest();\n   auto maybe_password = absl::GetFlag(FLAGS_requirepass);\n   if (!maybe_password.empty()) {\ndiff --git a/src/server/acl/user_registry.h b/src/server/acl/user_registry.h\nindex fef3fefd8622..034d288228f8 100644\n--- a/src/server/acl/user_registry.h\n+++ b/src/server/acl/user_registry.h\n@@ -12,6 +12,7 @@\n #include <utility>\n #include <vector>\n \n+#include \"server/acl/acl_commands_def.h\"\n #include \"server/acl/user.h\"\n #include \"util/fibers/synchronization.h\"\n \n@@ -27,7 +28,9 @@ class UserRegistry {\n   UserRegistry(const UserRegistry&) = delete;\n   UserRegistry(UserRegistry&&) = delete;\n \n-  void Init();\n+  void Init(const CategoryToIdxStore* cat_to_id_table,\n+            const ReverseCategoryIndexTable* reverse_cat_table,\n+            const CategoryToCommandsIndexStore* cat_to_commands_table);\n \n   using RegistryType = absl::flat_hash_map<std::string, User>;\n \n@@ -88,6 +91,10 @@ class UserRegistry {\n    private:\n     LockT<util::fb2::SharedMutex> registry_lk_;\n   };\n+\n+  const CategoryToIdxStore* cat_to_id_table_;\n+  const ReverseCategoryIndexTable* reverse_cat_table_;\n+  const CategoryToCommandsIndexStore* cat_to_commands_table_;\n };\n \n }  // namespace dfly::acl\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex ed74e83e2fdf..f025b018d4fb 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -2629,8 +2629,9 @@ void Service::RegisterCommands() {\n   server_family_.Register(&registry_);\n   cluster_family_.Register(&registry_);\n \n+  // AclFamily should always be registered last\n+  // If we add a new familly, register that first above and *not* below\n   acl_family_.Register(&registry_);\n-  acl::BuildIndexers(registry_.GetFamilies(), &registry_);\n \n   // Only after all the commands are registered\n   registry_.Init(pp_.size());\n@@ -2658,8 +2659,9 @@ void Service::RegisterCommands() {\n   }\n }\n \n-void Service::TestInit() {\n+const acl::AclFamily* Service::TestInit() {\n   acl_family_.Init(nullptr, &user_registry_);\n+  return &acl_family_;\n }\n \n void SetMaxMemoryFlag(uint64_t value) {\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex 0bc318378d3f..f8cf381a6516 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -125,7 +125,7 @@ class Service : public facade::ServiceInterface {\n \n   // Utility function used in unit tests\n   // Do not use in production, only meant to be used by unit tests\n-  void TestInit();\n+  const acl::AclFamily* TestInit();\n \n  private:\n   static void Quit(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/acl/acl_family_test.cc b/src/server/acl/acl_family_test.cc\nindex cbee4061fe18..6cdd2b5241ad 100644\n--- a/src/server/acl/acl_family_test.cc\n+++ b/src/server/acl/acl_family_test.cc\n@@ -198,8 +198,8 @@ TEST_F(AclFamilyTest, AclWhoAmI) {\n }\n \n TEST_F(AclFamilyTest, TestAllCategories) {\n-  TestInitAclFam();\n-  for (auto& cat : acl::REVERSE_CATEGORY_INDEX_TABLE) {\n+  const auto* fam = TestInitAclFam();\n+  for (auto& cat : fam->GetRevTable()) {\n     if (cat != \"_RESERVED\") {\n       auto resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"+@\", cat)});\n       EXPECT_THAT(resp, \"OK\");\n@@ -222,7 +222,7 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n     }\n   }\n \n-  for (auto& cat : acl::REVERSE_CATEGORY_INDEX_TABLE) {\n+  for (auto& cat : fam->GetRevTable()) {\n     if (cat != \"_RESERVED\") {\n       auto resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"+@\", cat)});\n       EXPECT_THAT(resp, \"OK\");\n@@ -245,8 +245,8 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n }\n \n TEST_F(AclFamilyTest, TestAllCommands) {\n-  TestInitAclFam();\n-  const auto& rev_indexer = acl::CommandsRevIndexer();\n+  const auto* fam = TestInitAclFam();\n+  const auto& rev_indexer = fam->GetCommandsRevIndexer();\n   for (const auto& family : rev_indexer) {\n     for (const auto& command_name : family) {\n       auto resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"+\", command_name)});\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex 39a18dbdf466..3150284ba197 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -5,6 +5,7 @@\n #include \"server/test_utils.h\"\n \n #include \"server/acl/acl_commands_def.h\"\n+#include \"server/acl/acl_family.h\"\n #include \"util/fibers/fibers.h\"\n \n extern \"C\" {\n@@ -702,9 +703,9 @@ void BaseFamilyTest::SetTestFlag(string_view flag_name, string_view new_value) {\n   CHECK(flag->ParseFrom(new_value, &error)) << \"Error: \" << error;\n }\n \n-void BaseFamilyTest::TestInitAclFam() {\n+const acl::AclFamily* BaseFamilyTest::TestInitAclFam() {\n   absl::SetFlag(&FLAGS_acllog_max_len, 0);\n-  service_->TestInit();\n+  return service_->TestInit();\n }\n \n }  // namespace dfly\ndiff --git a/src/server/test_utils.h b/src/server/test_utils.h\nindex 961d15e3d3a0..1c714926933b 100644\n--- a/src/server/test_utils.h\n+++ b/src/server/test_utils.h\n@@ -154,7 +154,7 @@ class BaseFamilyTest : public ::testing::Test {\n \n   static void SetTestFlag(std::string_view flag_name, std::string_view new_value);\n \n-  void TestInitAclFam();\n+  const acl::AclFamily* TestInitAclFam();\n \n   std::unique_ptr<util::ProactorPool> pp_;\n   std::unique_ptr<Service> service_;\n",
  "problem_statement": "get rid of inline tables that use dynamic allocation\n`server/acl/acl_commands_def.h` has bunch of tables allocated before main is even started.\r\n\r\nI do not like it because it forces memory allocator to initialize before we even configure it. \r\nPlease change the initialization code so that it would be called *explicitly* from, say, `Service` c-tor.\r\n\r\nAlso, please refer to the following guidelines regarding global variables:\r\n\r\n[1] https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables\r\n[2] https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Ri-global-init\r\n\r\nOn my development machine, the dragonfly process gets stuck in release mode in the following stack-trace:\r\n```\r\n(gdb) \r\n#0  0x0000555555b01c80 in _mi_malloc_generic (heap=0x5555564bc600 <_mi_heap_main>, size=800, zero=false, huge_alignment=0) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/include/mimalloc/internal.h:397\r\n#1  0x0000555555af7e2f in _mi_heap_malloc_zero_ex (zero=false, huge_alignment=0, size=800, heap=0x555556448b40 <_mi_heap_empty>) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/src/alloc.c:163\r\n#2  _mi_heap_malloc_zero (zero=false, size=800, heap=0x555556448b40 <_mi_heap_empty>) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/src/alloc.c:181\r\n#3  mi_heap_malloc (size=800, heap=0x555556448b40 <_mi_heap_empty>) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/src/alloc.c:185\r\n#4  mi_heap_alloc_new (size=800, heap=0x555556448b40 <_mi_heap_empty>) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/src/alloc.c:511\r\n#5  mi_new (size=800) at /home/roman/project/dragonfly/build-opt/third_party/mimalloc/src/alloc.c:517\r\n#6  0x0000555555682244 in operator new (n=800) at /home/roman/project/dragonfly/src/core/allocation_tracker.h:73\r\n#7  0x00005555556867ad in __gnu_cxx::new_allocator<absl::lts_20240116::container_internal::AlignedType<8ul> >::allocate (this=<synthetic pointer>, __n=<optimized out>) at /usr/include/c++/11/ext/new_allocator.h:127\r\n#8  std::allocator<absl::lts_20240116::container_internal::AlignedType<8ul> >::allocate (__n=<optimized out>, this=<synthetic pointer>) at /usr/include/c++/11/bits/allocator.h:185\r\n#9  std::allocator_traits<std::allocator<absl::lts_20240116::container_internal::AlignedType<8ul> > >::allocate (__n=<optimized out>, __a=<synthetic pointer>...) at /usr/include/c++/11/bits/alloc_traits.h:464\r\n#10 absl::lts_20240116::container_internal::Allocate<8ul, std::allocator<char> > (n=<optimized out>, alloc=<optimized out>) at /home/roman/project/dragonfly/build-opt/_deps/abseil_cpp-src/absl/container/internal/container_memory.h:65\r\n#11 absl::lts_20240116::container_internal::HashSetResizeHelper::InitializeSlots<std::allocator<char>, 24ul, true, 8ul> (this=this@entry=0x7fffffffdd00, c=..., old_slots=old_slots@entry=0x0, alloc=...)\r\n    at /home/roman/project/dragonfly/build-opt/_deps/abseil_cpp-src/absl/container/internal/raw_hash_set.h:1615\r\n#12 0x0000555555689904 in absl::lts_20240116::container_internal::raw_hash_set<absl::lts_20240116::container_internal::FlatHashMapPolicy<std::basic_string_view<char, std::char_traits<char> >, unsigned int>, absl::lts_20240116::container_internal::StringHash, absl::lts_20240116::container_internal::StringEq, std::allocator<std::pair<std::basic_string_view<char, std::char_traits<char> > const, unsigned int> > >::resize (\r\n    this=0x5555564c5300 <dfly::acl::CATEGORY_INDEX_TABLE>, new_capacity=<optimized out>) at /home/roman/project/dragonfly/build-opt/_deps/abseil_cpp-src/absl/container/internal/compressed_tuple.h:92\r\n#13 0x0000555555689ee6 in absl::lts_20240116::container_internal::raw_hash_set<absl::lts_20240116::container_internal::FlatHashMapPolicy<std::basic_string_view<char, std::char_traits<char> >, unsigned int>, absl::lts_20240116::container_internal::StringHash, absl::lts_20240116::container_internal::StringEq, std::allocator<std::pair<std::basic_string_view<char, std::char_traits<char> > const, unsigned int> > >::raw_hash_set<std::pair<std::basic_string_view<char, std::char_traits<char> >, unsigned int> const*> (this=0x5555564c5300 <dfly::acl::CATEGORY_INDEX_TABLE>, first=0x7fffffffde20, last=0x7fffffffe0a8, bucket_count=<optimized out>, hash=..., eq=..., alloc=...)\r\n    at /home/roman/project/dragonfly/build-opt/_deps/abseil_cpp-src/absl/container/internal/raw_hash_set.h:2115\r\n#14 0x000055555565deb2 in absl::lts_20240116::container_internal::raw_hash_set<absl::lts_20240116::container_internal::FlatHashMapPolicy<std::basic_string_view<char, std::char_traits<char> >, unsigned int>, absl::lts_20240116::container_internal::StringHash, absl::lts_20240116::container_internal::StringEq, std::allocator<std::pair<std::basic_string_view<char, std::char_traits<char> > const, unsigned int> > >::raw_hash_set (alloc=..., eq=..., hash=..., bucket_count=0, \r\n    init=..., this=0x5555564c5300 <dfly::acl::CATEGORY_INDEX_TABLE>) at /usr/include/c++/11/initializer_list:75\r\n#15 absl::lts_20240116::container_internal::raw_hash_map<absl::lts_20240116::container_internal::FlatHashMapPolicy<std::basic_string_view<char, std::char_traits<char> >, unsigned int>, absl::lts_20240116::container_internal::StringHash, absl::lts_20240116::container_internal::StringEq, std::allocator<std::pair<std::basic_string_view<char, std::char_traits<char> > const, unsigned int> > >::raw_hash_set (this=0x5555564c5300 <dfly::acl::CATEGORY_INDEX_TABLE>)\r\n    at /home/roman/project/dragonfly/build-opt/_deps/abseil_cpp-src/absl/container/internal/raw_hash_map.h:65\r\n#16 absl::lts_20240116::flat_hash_map<std::basic_string_view<char, std::char_traits<char> >, unsigned int, absl::lts_20240116::container_internal::StringHash, absl::lts_20240116::container_internal::StringEq, std::allocator<std::pair<std::basic_string_view<char, std::char_traits<char> > const, unsigned int> > >::raw_hash_set (this=0x5555564c5300 <dfly::acl::CATEGORY_INDEX_TABLE>)\r\n\r\n``` \n",
  "hints_text": "@romange on it!",
  "created_at": "2024-07-11T09:39:14Z",
  "modified_files": [
    "src/server/CMakeLists.txt",
    "src/server/acl/acl_commands_def.h",
    "src/server/acl/acl_family.cc",
    "src/server/acl/acl_family.h",
    "src/server/acl/helpers.cc",
    "src/server/acl/helpers.h",
    "src/server/acl/user.cc",
    "src/server/acl/user.h",
    "src/server/acl/user_registry.cc",
    "src/server/acl/user_registry.h",
    "src/server/main_service.cc",
    "src/server/main_service.h"
  ],
  "modified_test_files": [
    "src/server/acl/acl_family_test.cc",
    "src/server/test_utils.cc",
    "src/server/test_utils.h"
  ]
}