{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3751,
  "instance_id": "dragonflydb__dragonfly-3751",
  "issue_numbers": [
    "3528"
  ],
  "base_commit": "c9a2334f6d30ab3abcb5f0829bf725df7270be8d",
  "patch": "diff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex 7f3ac4a10ad2..420b40c6dd0d 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -285,11 +285,16 @@ class ElementAccess {\n   EngineShard* shard_ = nullptr;\n   mutable DbSlice::AutoUpdater post_updater_;\n \n+  void SetFields(EngineShard* shard, DbSlice::AddOrFindResult res);\n+\n  public:\n   ElementAccess(std::string_view key, const OpArgs& args) : key_{key}, context_{args.db_cntx} {\n   }\n \n   OpStatus Find(EngineShard* shard);\n+  // Still finds the element even if it's WRONG_TYPE. This is used for blind updates.\n+  // See BITOP operation.\n+  OpStatus FindAllowWrongType(EngineShard* shard);\n \n   bool IsNewEntry() const {\n     CHECK_NOTNULL(shard_);\n@@ -317,6 +322,13 @@ std::optional<bool> ElementAccess::Exists(EngineShard* shard) {\n   return res.status() != OpStatus::KEY_NOTFOUND;\n }\n \n+void ElementAccess::SetFields(EngineShard* shard, DbSlice::AddOrFindResult res) {\n+  element_iter_ = res.it;\n+  added_ = res.is_new;\n+  shard_ = shard;\n+  post_updater_ = std::move(res.post_updater);\n+}\n+\n OpStatus ElementAccess::Find(EngineShard* shard) {\n   auto op_res = context_.GetDbSlice(shard->shard_id()).AddOrFind(context_, key_);\n   RETURN_ON_BAD_STATUS(op_res);\n@@ -325,10 +337,17 @@ OpStatus ElementAccess::Find(EngineShard* shard) {\n   if (!add_res.is_new && add_res.it->second.ObjType() != OBJ_STRING) {\n     return OpStatus::WRONG_TYPE;\n   }\n-  element_iter_ = add_res.it;\n-  added_ = add_res.is_new;\n-  shard_ = shard;\n-  post_updater_ = std::move(add_res.post_updater);\n+\n+  SetFields(shard, std::move(add_res));\n+  return OpStatus::OK;\n+}\n+\n+OpStatus ElementAccess::FindAllowWrongType(EngineShard* shard) {\n+  auto op_res = context_.GetDbSlice(shard->shard_id()).AddOrFind(context_, key_);\n+  RETURN_ON_BAD_STATUS(op_res);\n+  auto& add_res = *op_res;\n+\n+  SetFields(shard, std::move(add_res));\n   return OpStatus::OK;\n }\n \n@@ -343,8 +362,18 @@ std::string ElementAccess::Value() const {\n \n void ElementAccess::Commit(std::string_view new_value) const {\n   if (shard_) {\n-    element_iter_->second.SetString(new_value);\n-    post_updater_.Run();\n+    if (new_value.empty()) {\n+      if (!IsNewEntry()) {\n+        post_updater_.Run();\n+      } else {\n+        // No need to run, it was a new entry and it got removed\n+        post_updater_.Cancel();\n+      }\n+      context_.GetDbSlice(shard_->shard_id()).Del(context_, element_iter_);\n+    } else {\n+      element_iter_->second.SetString(new_value);\n+      post_updater_.Run();\n+    }\n   }\n }\n \n@@ -1159,7 +1188,7 @@ void BitOp(CmdArgList args, ConnectionContext* cntx) {\n   cntx->transaction->Execute(std::move(shard_bitop), false);  // we still have more work to do\n   // All result from each shard\n   const auto joined_results = CombineResultOp(result_set, op);\n-  // Second phase - save to targe key if successful\n+  // Second phase - save to target key if successful\n   if (!joined_results) {\n     cntx->transaction->Conclude();\n     cntx->SendError(joined_results.status());\n@@ -1169,14 +1198,24 @@ void BitOp(CmdArgList args, ConnectionContext* cntx) {\n     auto store_cb = [&](Transaction* t, EngineShard* shard) {\n       if (shard->shard_id() == dest_shard) {\n         ElementAccess operation{dest_key, t->GetOpArgs(shard)};\n-        auto find_res = operation.Find(shard);\n+        auto find_res = operation.FindAllowWrongType(shard);\n \n-        if (find_res == OpStatus::OK) {\n+        // BITOP command acts as a blind update. If the key existed and its type\n+        // was not a string we still want to Commit with the new value.\n+        if (find_res == OpStatus::OK || find_res == OpStatus::WRONG_TYPE) {\n           operation.Commit(op_result);\n-        }\n \n-        if (shard->journal()) {\n-          RecordJournal(t->GetOpArgs(shard), \"SET\", {dest_key, op_result});\n+          if (shard->journal()) {\n+            if (op_result.empty()) {\n+              // We need to delete it if the key exists. If it doesn't, we just\n+              // skip it and do not send it to the replica at all.\n+              if (!operation.IsNewEntry()) {\n+                RecordJournal(t->GetOpArgs(shard), \"DEL\", {dest_key});\n+              }\n+            } else {\n+              RecordJournal(t->GetOpArgs(shard), \"SET\", {dest_key, op_result});\n+            }\n+          }\n         }\n       }\n       return OpStatus::OK;\n",
  "test_patch": "diff --git a/src/server/bitops_family_test.cc b/src/server/bitops_family_test.cc\nindex 18b9b7e9a102..e6ab1820cc82 100644\n--- a/src/server/bitops_family_test.cc\n+++ b/src/server/bitops_family_test.cc\n@@ -410,7 +410,16 @@ TEST_F(BitOpsFamilyTest, BitOpsNot) {\n   // Make sure that this works with none existing key as well\n   EXPECT_EQ(0, CheckedInt({\"bitop\", \"NOT\", \"bit-op-not-none-existing-key-results\",\n                            \"this-key-do-not-exists\"}));\n-  EXPECT_EQ(Run({\"get\", \"bit-op-not-none-existing-key-results\"}), \"\");\n+  ASSERT_THAT(Run({\"get\", \"bit-op-not-none-existing-key-results\"}), ArgType(RespExpr::Type::NIL));\n+\n+  EXPECT_EQ(Run({\"set\", \"foo\", \"bar\"}), \"OK\");\n+  EXPECT_EQ(0, CheckedInt({\"bitop\", \"NOT\", \"foo\", \"this-key-do-not-exists\"}));\n+  ASSERT_THAT(Run({\"get\", \"foo\"}), ArgType(RespExpr::Type::NIL));\n+\n+  // Change the type of foo. Bitops is similar to set command. It's a blind update.\n+  ASSERT_THAT(Run({\"hset\", \"foo\", \"bar\", \"val\"}), IntArg(1));\n+  EXPECT_EQ(0, CheckedInt({\"bitop\", \"NOT\", \"foo\", \"this-key-do-not-exists\"}));\n+  ASSERT_THAT(Run({\"get\", \"foo\"}), ArgType(RespExpr::Type::NIL));\n \n   // test bitop not\n   resp = Run({\"set\", KEY_VALUES_BIT_OP[0].first, KEY_VALUES_BIT_OP[0].second});\ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex e024080a1abf..a3adb5fcef1d 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -673,6 +673,15 @@ async def check_expire(key):\n         await skip_cmd()\n         # Check BITOP turns into SET\n         await check(\"BITOP OR kdest k1 k2\", r\"SET kdest 1100\")\n+        # See gh issue #3528\n+        await c_master.execute_command(f\"HSET foo bar val\")\n+        await skip_cmd()\n+        await check(\"BITOP NOT foo tmp\", r\"DEL foo\")\n+        await c_master.execute_command(f\"HSET foo bar val\")\n+        await skip_cmd()\n+        await c_master.set(\"k3\", \"-\")\n+        await skip_cmd()\n+        await check(\"BITOP NOT foo k3\", r\"SET foo \\\\xd2\")\n \n         # Check there is no rewrite for LMOVE on single shard\n         await c_master.lpush(\"list\", \"v1\", \"v2\", \"v3\", \"v4\")\n",
  "problem_statement": "bitop not tmp1 tmp2 inconsistent result\nStart an empty dragonfly instance and run:\r\n\r\n```\r\nbitop not tmp1 tmp2\r\nget tmp1\r\n```\r\nwill return `\"\"`\r\n\r\nin `Valkey` will return `nil`\n",
  "hints_text": "",
  "created_at": "2024-09-20T14:17:19Z",
  "modified_files": [
    "src/server/bitops_family.cc"
  ],
  "modified_test_files": [
    "src/server/bitops_family_test.cc",
    "tests/dragonfly/replication_test.py"
  ]
}