{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1806,
  "instance_id": "dragonflydb__dragonfly-1806",
  "issue_numbers": [
    "1161"
  ],
  "base_commit": "b8a9d1f093eafa2e9360bf1415345433f558049a",
  "patch": "diff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 3bcfef58cb5d..cf243cff149c 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -9,6 +9,7 @@\n extern \"C\" {\n #include \"redis/object.h\"\n #include \"redis/stream.h\"\n+#include \"redis/zmalloc.h\"\n }\n \n #include \"base/logging.h\"\n@@ -525,6 +526,17 @@ int StreamAppendItem(stream* s, CmdArgList fields, streamID* added_id, streamID*\n   return C_OK;\n }\n \n+/* Create a NACK entry setting the delivery count to 1 and the delivery\n+ * time to the current time or test-hooked time. The NACK consumer will be\n+ * set to the one specified as argument of the function. */\n+streamNACK* StreamCreateNACK(streamConsumer* consumer) {\n+  streamNACK* nack = reinterpret_cast<streamNACK*>(zmalloc(sizeof(*nack)));\n+  nack->delivery_time = GetCurrentTimeMs();\n+  nack->delivery_count = 1;\n+  nack->consumer = consumer;\n+  return nack;\n+}\n+\n int StreamTrim(const AddTrimOpts& opts, stream* s) {\n   if (!opts.limit) {\n     if (opts.trim_strategy == TrimStrategy::kMaxLen) {\n@@ -659,7 +671,7 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeO\n       /* Try to add a new NACK. Most of the time this will work and\n        * will not require extra lookups. We'll fix the problem later\n        * if we find that there is already an entry for this ID. */\n-      streamNACK* nack = streamCreateNACK(opts.consumer);\n+      streamNACK* nack = StreamCreateNACK(opts.consumer);\n       int group_inserted = raxTryInsert(opts.group->pel, buf, sizeof(buf), nack, nullptr);\n       int consumer_inserted = raxTryInsert(opts.consumer->pel, buf, sizeof(buf), nack, nullptr);\n \n@@ -673,7 +685,7 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeO\n         raxRemove(nack->consumer->pel, buf, sizeof(buf), NULL);\n         /* Update the consumer and NACK metadata. */\n         nack->consumer = opts.consumer;\n-        nack->delivery_time = mstime();\n+        nack->delivery_time = GetCurrentTimeMs();\n         nack->delivery_count = 1;\n         /* Add the entry in the new consumer local PEL. */\n         raxInsert(opts.consumer->pel, buf, sizeof(buf), nack, NULL);\n@@ -723,7 +735,7 @@ OpResult<RecordVec> OpRangeFromConsumerPEL(const OpArgs& op_args, string_view ke\n       result.push_back(Record{id, vector<pair<string, string>>()});\n     } else {\n       streamNACK* nack = static_cast<streamNACK*>(ri.data);\n-      nack->delivery_time = mstime();\n+      nack->delivery_time = GetCurrentTimeMs();\n       nack->delivery_count++;\n       result.push_back(std::move(op_result.value()[0]));\n     }\n@@ -1116,6 +1128,147 @@ OpResult<uint32_t> OpDel(const OpArgs& op_args, string_view key, absl::Span<stre\n   return deleted;\n }\n \n+struct PendingOpts {\n+  string_view group_name;\n+  string_view consumer_name;\n+  ParsedStreamId start;\n+  ParsedStreamId end;\n+  int64_t min_idle_time = 0;\n+  int64_t count = -1;\n+};\n+\n+struct PendingReducedResult {\n+  uint64_t count = 0;\n+  streamID start;\n+  streamID end;\n+  vector<pair<string_view, uint64_t /* size of consumer pending list*/>> consumer_list;\n+};\n+\n+struct PendingExtendedResult {\n+  streamID start;\n+  string_view consumer_name;\n+  uint64_t delivery_count;\n+  mstime_t elapsed;\n+};\n+\n+using PendingExtendedResultList = std::vector<PendingExtendedResult>;\n+using PendingResult = std::variant<PendingReducedResult, PendingExtendedResultList>;\n+\n+PendingReducedResult GetPendingReducedResult(streamCG* cg) {\n+  PendingReducedResult result;\n+  result.count = raxSize(cg->pel);\n+  if (!result.count) {\n+    return result;\n+  }\n+\n+  raxIterator ri;\n+\n+  raxStart(&ri, cg->pel);\n+  raxSeek(&ri, \"^\", nullptr, 0);\n+  raxNext(&ri);\n+  streamDecodeID(ri.key, &result.start);\n+\n+  raxSeek(&ri, \"$\", nullptr, 0);\n+  raxNext(&ri);\n+  streamDecodeID(ri.key, &result.end);\n+\n+  raxStart(&ri, cg->consumers);\n+  raxSeek(&ri, \"^\", nullptr, 0);\n+  while (raxNext(&ri)) {\n+    streamConsumer* consumer = static_cast<streamConsumer*>(ri.data);\n+    uint64_t pel_size = raxSize(consumer->pel);\n+    if (!pel_size)\n+      continue;\n+\n+    pair<string_view, uint64_t> item;\n+    item.first = string_view{consumer->name, sdslen(consumer->name)};\n+    item.second = pel_size;\n+    result.consumer_list.push_back(item);\n+  }\n+  raxStop(&ri);\n+  return result;\n+}\n+\n+PendingExtendedResultList GetPendingExtendedResult(streamCG* cg, streamConsumer* consumer,\n+                                                   const PendingOpts& opts) {\n+  PendingExtendedResultList result;\n+  rax* pel = consumer ? consumer->pel : cg->pel;\n+  streamID sstart = opts.start.val, send = opts.end.val;\n+  auto now = GetCurrentTimeMs();\n+  unsigned char start_key[sizeof(streamID)];\n+  unsigned char end_key[sizeof(streamID)];\n+  raxIterator ri;\n+\n+  StreamEncodeID(start_key, &sstart);\n+  StreamEncodeID(end_key, &send);\n+  raxStart(&ri, pel);\n+  raxSeek(&ri, \">=\", start_key, sizeof(start_key));\n+\n+  auto count = opts.count;\n+  while (count && raxNext(&ri)) {\n+    if (memcmp(ri.key, end_key, ri.key_len) > 0) {\n+      break;\n+    }\n+    streamNACK* nack = static_cast<streamNACK*>(ri.data);\n+\n+    if (opts.min_idle_time) {\n+      mstime_t this_idle = now - nack->delivery_time;\n+      if (this_idle < opts.min_idle_time) {\n+        continue;\n+      }\n+    }\n+\n+    count--;\n+\n+    /* Entry ID. */\n+    streamID id;\n+    streamDecodeID(ri.key, &id);\n+\n+    /* Milliseconds elapsed since last delivery. */\n+    mstime_t elapsed = now - nack->delivery_time;\n+    if (elapsed < 0) {\n+      elapsed = 0;\n+    }\n+\n+    PendingExtendedResult item = {.start = id,\n+                                  .consumer_name = nack->consumer->name,\n+                                  .delivery_count = nack->delivery_count,\n+                                  .elapsed = elapsed};\n+    result.push_back(item);\n+  }\n+  raxStop(&ri);\n+  return result;\n+}\n+\n+OpResult<PendingResult> OpPending(const OpArgs& op_args, string_view key, const PendingOpts& opts) {\n+  OpResult<pair<stream*, streamCG*>> cgroup_res = FindGroup(op_args, key, opts.group_name);\n+  if (!cgroup_res) {\n+    return cgroup_res.status();\n+  }\n+\n+  streamCG* cg = cgroup_res->second;\n+  if (cg == nullptr) {\n+    return OpStatus::SKIPPED;\n+  }\n+\n+  auto* shard = op_args.shard;\n+  streamConsumer* consumer = nullptr;\n+  if (!opts.consumer_name.empty()) {\n+    shard->tmp_str1 =\n+        sdscpylen(shard->tmp_str1, opts.consumer_name.data(), opts.consumer_name.size());\n+    consumer = streamLookupConsumer(cg, shard->tmp_str1, SLC_NO_REFRESH);\n+  }\n+\n+  PendingResult result;\n+\n+  if (opts.count == -1) {\n+    result = GetPendingReducedResult(cg);\n+  } else {\n+    result = GetPendingExtendedResult(cg, consumer, opts);\n+  }\n+  return result;\n+}\n+\n void CreateGroup(CmdArgList args, string_view key, ConnectionContext* cntx) {\n   if (args.size() < 2)\n     return (*cntx)->SendError(UnknownSubCmd(\"CREATE\", \"XGROUP\"));\n@@ -1493,6 +1646,119 @@ void StreamFamily::XLen(CmdArgList args, ConnectionContext* cntx) {\n   return (*cntx)->SendError(result.status());\n }\n \n+bool ParseXpendingOptions(CmdArgList& args, PendingOpts& opts, ConnectionContext* cntx) {\n+  size_t id_indx = 0;\n+  ToUpper(&args[id_indx]);\n+  string_view arg = ArgS(args, id_indx);\n+\n+  if (arg == \"IDLE\" && args.size() > 4) {\n+    id_indx++;\n+    if (!absl::SimpleAtoi(ArgS(args, id_indx), &opts.min_idle_time)) {\n+      (*cntx)->SendError(kInvalidIntErr, kSyntaxErrType);\n+      return false;\n+    }\n+    // Ignore negative min_idle_time\n+    opts.min_idle_time = std::max(opts.min_idle_time, static_cast<int64_t>(0));\n+    args.remove_prefix(2);\n+    id_indx = 0;\n+  }\n+  if (args.size() < 3) {\n+    (*cntx)->SendError(WrongNumArgsError(\"XPENDING\"), kSyntaxErrType);\n+    return false;\n+  }\n+\n+  // Parse start and end\n+  RangeId rs, re;\n+  string_view start = ArgS(args, id_indx);\n+  id_indx++;\n+  string_view end = ArgS(args, id_indx);\n+  if (!ParseRangeId(start, &rs) || !ParseRangeId(end, &re)) {\n+    (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n+    return false;\n+  }\n+\n+  if (rs.exclude && streamIncrID(&rs.parsed_id.val) != C_OK) {\n+    (*cntx)->SendError(\"invalid start ID for the interval\", kSyntaxErrType);\n+    return false;\n+  }\n+\n+  if (re.exclude && streamDecrID(&re.parsed_id.val) != C_OK) {\n+    (*cntx)->SendError(\"invalid end ID for the interval\", kSyntaxErrType);\n+    return false;\n+  }\n+  id_indx++;\n+  opts.start = rs.parsed_id;\n+  opts.end = re.parsed_id;\n+\n+  // Parse count\n+  if (!absl::SimpleAtoi(ArgS(args, id_indx), &opts.count)) {\n+    (*cntx)->SendError(kInvalidIntErr, kSyntaxErrType);\n+    return false;\n+  }\n+\n+  // Ignore negative count value\n+  opts.count = std::max(opts.count, static_cast<int64_t>(0));\n+  if (args.size() - id_indx - 1) {\n+    id_indx++;\n+    opts.consumer_name = ArgS(args, id_indx);\n+  }\n+  return true;\n+}\n+\n+void StreamFamily::XPending(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 0);\n+  PendingOpts opts;\n+  opts.group_name = ArgS(args, 1);\n+  args.remove_prefix(2);\n+\n+  if (!args.empty() && !ParseXpendingOptions(args, opts, cntx)) {\n+    return;\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpPending(t->GetOpArgs(shard), key, opts);\n+  };\n+  OpResult<PendingResult> op_result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  if (!op_result) {\n+    if (op_result.status() == OpStatus::SKIPPED)\n+      return (*cntx)->SendError(NoGroupError(key, opts.group_name));\n+    return (*cntx)->SendError(op_result.status());\n+  }\n+  PendingResult result = op_result.value();\n+\n+  if (std::holds_alternative<PendingReducedResult>(result)) {\n+    const auto& res = std::get<PendingReducedResult>(result);\n+    if (!res.count) {\n+      return (*cntx)->SendEmptyArray();\n+    }\n+    (*cntx)->StartArray(4);\n+    (*cntx)->SendLong(res.count);\n+    (*cntx)->SendBulkString(StreamIdRepr(res.start));\n+    (*cntx)->SendBulkString(StreamIdRepr(res.end));\n+    (*cntx)->StartArray(res.consumer_list.size());\n+\n+    for (auto& [consumer_name, count] : res.consumer_list) {\n+      (*cntx)->StartArray(2);\n+      (*cntx)->SendBulkString(consumer_name);\n+      (*cntx)->SendLong(count);\n+    }\n+  } else {\n+    const auto& res = std::get<PendingExtendedResultList>(result);\n+    if (!res.size()) {\n+      return (*cntx)->SendEmptyArray();\n+    }\n+\n+    (*cntx)->StartArray(res.size());\n+    for (auto& item : res) {\n+      (*cntx)->StartArray(4);\n+      (*cntx)->SendBulkString(StreamIdRepr(item.start));\n+      (*cntx)->SendBulkString(item.consumer_name);\n+      (*cntx)->SendLong(item.elapsed);\n+      (*cntx)->SendLong(item.delivery_count);\n+    }\n+  }\n+}\n+\n void StreamFamily::XRange(CmdArgList args, ConnectionContext* cntx) {\n   XRangeGeneric(std::move(args), false, cntx);\n }\n@@ -2012,6 +2278,7 @@ constexpr uint32_t kXDel = WRITE | STREAM | FAST;\n constexpr uint32_t kXGroup = SLOW;\n constexpr uint32_t kXInfo = SLOW;\n constexpr uint32_t kXLen = READ | STREAM | FAST;\n+constexpr uint32_t kXPending = READ | STREAM;\n constexpr uint32_t kXRange = READ | STREAM | SLOW;\n constexpr uint32_t kXRevRange = READ | STREAM | SLOW;\n constexpr uint32_t kXRead = READ | STREAM | SLOW | BLOCKING;\n@@ -2030,6 +2297,7 @@ void StreamFamily::Register(CommandRegistry* registry) {\n       << CI{\"XGROUP\", CO::WRITE | CO::DENYOOM, -3, 2, 2, 1, acl::kXGroup}.HFUNC(XGroup)\n       << CI{\"XINFO\", CO::READONLY | CO::NOSCRIPT, -2, 0, 0, 0, acl::kXInfo}.HFUNC(XInfo)\n       << CI{\"XLEN\", CO::READONLY | CO::FAST, 2, 1, 1, 1, acl::kXLen}.HFUNC(XLen)\n+      << CI{\"XPENDING\", CO::READONLY, -2, 1, 1, 1, acl::kXPending}.HFUNC(XPending)\n       << CI{\"XRANGE\", CO::READONLY, -4, 1, 1, 1, acl::kXRange}.HFUNC(XRange)\n       << CI{\"XREVRANGE\", CO::READONLY, -4, 1, 1, 1, acl::kXRevRange}.HFUNC(XRevRange)\n       << CI{\"XREAD\",    CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 3, 3, 1,\ndiff --git a/src/server/stream_family.h b/src/server/stream_family.h\nindex f964ce766a48..876063407a77 100644\n--- a/src/server/stream_family.h\n+++ b/src/server/stream_family.h\n@@ -21,6 +21,7 @@ class StreamFamily {\n   static void XGroup(CmdArgList args, ConnectionContext* cntx);\n   static void XInfo(CmdArgList args, ConnectionContext* cntx);\n   static void XLen(CmdArgList args, ConnectionContext* cntx);\n+  static void XPending(CmdArgList args, ConnectionContext* cntx);\n   static void XRevRange(CmdArgList args, ConnectionContext* cntx);\n   static void XRange(CmdArgList args, ConnectionContext* cntx);\n   static void XRead(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 2d2944a62229..37bcdab63cb3 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -499,4 +499,70 @@ TEST_F(StreamFamilyTest, XTrimInvalidArgs) {\n   EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n }\n \n+TEST_F(StreamFamilyTest, XPending) {\n+  Run({\"xadd\", \"foo\", \"1-0\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"foo\", \"1-1\", \"k2\", \"v2\"});\n+  Run({\"xadd\", \"foo\", \"1-2\", \"k3\", \"v3\"});\n+\n+  // create a group for foo stream\n+  Run({\"xgroup\", \"create\", \"foo\", \"group\", \"0\"});\n+  // alice consume all the stream entries\n+  Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \">\"});\n+  // bob doesn't have pending entries\n+  Run({\"xgroup\", \"createconsumer\", \"foo\", \"group\", \"bob\"});\n+\n+  // XPending should print 4 entries\n+  auto resp = Run({\"xpending\", \"foo\", \"group\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\n+                        IntArg(3), \"1-0\", \"1-2\",\n+                        RespArray(ElementsAre(RespArray(ElementsAre(\"alice\", IntArg(3))))))));\n+\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"-\", \"+\", \"10\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\n+                  RespArray(ElementsAre(\"1-0\", \"alice\", ArgType(RespExpr::INT64), IntArg(1))),\n+                  RespArray(ElementsAre(\"1-1\", \"alice\", ArgType(RespExpr::INT64), IntArg(1))),\n+                  RespArray(ElementsAre(\"1-2\", \"alice\", ArgType(RespExpr::INT64), IntArg(1))))));\n+\n+  // only return a single entry\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"-\", \"+\", \"1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1-0\", \"alice\", ArgType(RespExpr::INT64), IntArg(1)));\n+\n+  // Bob read a new entry\n+  Run({\"xadd\", \"foo\", \"1-3\", \"k4\", \"v4\"});\n+  Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \">\"});\n+  // Bob now has` an entry in his pending list\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"-\", \"+\", \"10\", \"bob\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1-3\", \"bob\", ArgType(RespExpr::INT64), IntArg(1)));\n+\n+  Run({\"xadd\", \"foo\", \"1-4\", \"k5\", \"v5\"});\n+  TEST_current_time_ms = 100;\n+  Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \">\"});\n+  TEST_current_time_ms += 3000;\n+\n+  // min-idle-time is exceeding the delivery time of last inserted entry\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"IDLE\", \"4000\", \"-\", \"+\", \"10\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+}\n+\n+TEST_F(StreamFamilyTest, XPendingInvalidArgs) {\n+  Run({\"xadd\", \"foo\", \"1-0\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"foo\", \"1-1\", \"k2\", \"v2\"});\n+\n+  auto resp = Run({\"xpending\", \"unknown\", \"group\"});\n+  EXPECT_THAT(resp, ErrArg(\"no such key\"));\n+\n+  // group doesn't exist\n+  resp = Run({\"xpending\", \"foo\", \"group\"});\n+  EXPECT_THAT(resp, ErrArg(\"NOGROUP\"));\n+\n+  Run({\"xgroup\", \"create\", \"foo\", \"group\", \"0\"});\n+  // start end count not provided\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"IDLE\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  // count not provided\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"-\", \"+\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+}\n }  // namespace dfly\n",
  "problem_statement": "implement xpending\n\n",
  "hints_text": "",
  "created_at": "2023-09-05T15:12:23Z",
  "modified_files": [
    "src/server/stream_family.cc",
    "src/server/stream_family.h"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}