{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4913,
  "instance_id": "dragonflydb__dragonfly-4913",
  "issue_numbers": [
    "4911"
  ],
  "base_commit": "287f066d1265fb5d76b13fc05fb390294fd21ccc",
  "patch": "diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex 44a344f63de8..c3273ba88a34 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -50,13 +50,28 @@ void DenseSet::IteratorBase::SetExpiryTime(uint32_t ttl_sec) {\n   DensePtr* ptr = curr_entry_->IsLink() ? curr_entry_->AsLink() : curr_entry_;\n   void* src = ptr->GetObject();\n   if (!HasExpiry()) {\n+    const size_t old_size = owner_->ObjectAllocSize(ptr->Raw());\n     void* new_obj = owner_->ObjectClone(src, false, true);\n     ptr->SetObject(new_obj);\n \n+    const size_t new_size = owner_->ObjectAllocSize(ptr->Raw());\n+\n     // Important: we set the ttl bit on the wrapping pointer.\n     curr_entry_->SetTtl(true);\n     owner_->ObjDelete(src, false);\n     src = new_obj;\n+\n+    // Because setting TTL requires an extra 4 bytes for the key, the allocated size may push the\n+    // object into a different mi-malloc page category (e.g. 16 byte page -> 32 byte page). This\n+    // results in increased reporting in ObjAllocSize.\n+    //\n+    // If this size increase is not accounted for, it will cause an overflow in\n+    // DenseSet::AddOrReplaceObj due to subtracting larger size from smaller and the type of\n+    // obj_malloc_used_ being size_t.\n+    if (old_size != new_size) {\n+      owner_->DecreaseMallocUsed(old_size);\n+      owner_->IncreaseMallocUsed(new_size);\n+    }\n   }\n   owner_->ObjUpdateExpireTime(src, ttl_sec);\n }\n@@ -701,7 +716,9 @@ void* DenseSet::AddOrReplaceObj(void* obj, bool has_ttl) {\n       dptr = dptr->AsLink();\n \n     void* res = dptr->Raw();\n-    obj_malloc_used_ -= ObjectAllocSize(res);\n+    const size_t res_sz = ObjectAllocSize(res);\n+    DCHECK_GE(obj_malloc_used_, res_sz);\n+    obj_malloc_used_ -= res_sz;\n     obj_malloc_used_ += ObjectAllocSize(obj);\n \n     dptr->SetObject(obj);\n",
  "test_patch": "diff --git a/src/core/string_map_test.cc b/src/core/string_map_test.cc\nindex 4f59fa0d3fe8..ee35c071b6dd 100644\n--- a/src/core/string_map_test.cc\n+++ b/src/core/string_map_test.cc\n@@ -230,4 +230,18 @@ TEST_F(StringMapTest, ReallocIfNeeded) {\n     EXPECT_EQ(sm_->Find(build_str(i * 10))->second, build_str(i * 10 + 1));\n }\n \n+TEST_F(StringMapTest, ExpiryChangesSize) {\n+  sm_->AddOrUpdate(\"field\", \"value\");\n+  const size_t old_size = sm_->ObjMallocUsed();\n+\n+  auto it = sm_->Find(\"field\");\n+  it.SetExpiryTime(1);\n+\n+  const size_t new_size = sm_->ObjMallocUsed();\n+  EXPECT_LT(old_size, new_size);\n+\n+  sm_->AddOrUpdate(\"field\", \"value\", 1);\n+  EXPECT_EQ(new_size, sm_->ObjMallocUsed());\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "MEMORY USAGE is different on every iteration of HSET & HEXPIRE/FIELDEXPIRE\nWhen you set a hash field, and set an expiry on the field, and loop it, the memory usage of the key will keep on deducting 16B of key size, until it is fully gone.\n\n**To Reproduce**\n```\nHSET myhash field \"value\"                                    => (integer) 1\nMEMORY USAGE myhash                                          => (integer) 32\n\nHEXPIRE myhash 60 FIELDS 1 field                             => 1) (integer) 1\nMEMORY USAGE myhash                                          => (integer) 136\n\nHSET myhash field \"value\"                                    => (integer) 0\nHEXPIRE myhash 60 FIELDS 1 field                             => 1) (integer) 1\nMEMORY USAGE myhash                                          => (integer) 120\n\nHSET myhash field \"value\"                                    => (integer) 0\nHEXPIRE myhash 60 FIELDS 1 field                             => 1) (integer) 1\nMEMORY USAGE myhash                                          => (integer) 104\n\nHSET myhash field \"value\"                                    => (integer) 0\nHEXPIRE myhash 60 FIELDS 1 field                             => 1) (integer) 1\nMEMORY USAGE myhash                                          => (integer) 88\n```\n**Images:**\n![Image](https://github.com/user-attachments/assets/7bb35c8e-6e46-48a3-95b9-99bb0bd2b6a9)\n\n![Image](https://github.com/user-attachments/assets/67477b22-c874-4dcb-8ecf-7932b3ee25f6)\n\n**Environment:**\n - Containerized:  Docker Compose image using `docker.dragonflydb.io/dragonflydb/dragonfly`\n   - dragonfly v1.28.1-a87fe66d1a7654b8f2ee2b7fe27687d582230888\n   - build time: 2025-03-27 15:04:21\n\n**Additional context**\n\n- I've tested on Redis, behaviour is a constant memory usage, as expected.\n- I've tested Set, behaviour is a constant memory usage, as expected. \n- I've **not** tested on Sets members, as this feature is Experimental and only available on Dragonfly.\n- Running without `HSET` first doesn't cause this bug.\n",
  "hints_text": "Working as intended.\n\n\nDragonfly employs passive fields expiry for hashes and sets. Therefore you wont see memory reduction just because some fields should be expired - dragonfly is not aware of these expirations until the entry is actually accessed.\n> Working as intended.\n> \n> Dragonfly employs passive fields expiry for hashes and sets. Therefore you wont see memory reduction just because some fields should be expired - dragonfly is not aware of these expirations until the entry is actually accessed.\n\nIt's not that I expected memory reduction, but that calling 10 times \n```\nHSET myhash field \"value\" \nHEXPIRE myhash 60 FIELDS 1 field \nMEMORY USAGE myhash\n```\ncauses it to return \n```\nMEMORY USAGE myhash\n(nil)\n```\nas it has deducted `16B` of key size on every iteration until `nil`, while the hash and field still **exist** until the TTL expires.\n\nWouldn't that render `MEMORY USAGE` unreliable for such flow?\nOh, I see - we will take a look!\r\n\r\nOn Wed, Apr 9, 2025, 5:01\u202fPM Kareem Montaser ***@***.***>\r\nwrote:\r\n\r\n> Working as intended.\r\n>\r\n> Dragonfly employs passive fields expiry for hashes and sets. Therefore you\r\n> wont see memory reduction just because some fields should be expired -\r\n> dragonfly is not aware of these expirations until the entry is actually\r\n> accessed.\r\n>\r\n> It's not that I expected memory reduction, but that calling 10 times\r\n>\r\n> HSET myhash field \"value\"\r\n> HEXPIRE myhash 60 FIELDS 1 field\r\n> MEMORY USAGE myhash\r\n>\r\n> causes it to return\r\n>\r\n> MEMORY USAGE myhash\r\n> (nil)\r\n>\r\n> as it has deducted 16B of key size on every iteration until nil, while\r\n> the hash and field still *exist* until the TTL expires.\r\n>\r\n> Wouldn't that render MEMORY USAGE unreliable for such flow?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/dragonflydb/dragonfly/issues/4911#issuecomment-2789844969>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AA4BFCDHMTTLCC5SXQCGDU32YUR4BAVCNFSM6AAAAAB2ZAROF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDOOBZHA2DIOJWHE>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n> *karemont* left a comment (dragonflydb/dragonfly#4911)\r\n> <https://github.com/dragonflydb/dragonfly/issues/4911#issuecomment-2789844969>\r\n>\r\n> Working as intended.\r\n>\r\n> Dragonfly employs passive fields expiry for hashes and sets. Therefore you\r\n> wont see memory reduction just because some fields should be expired -\r\n> dragonfly is not aware of these expirations until the entry is actually\r\n> accessed.\r\n>\r\n> It's not that I expected memory reduction, but that calling 10 times\r\n>\r\n> HSET myhash field \"value\"\r\n> HEXPIRE myhash 60 FIELDS 1 field\r\n> MEMORY USAGE myhash\r\n>\r\n> causes it to return\r\n>\r\n> MEMORY USAGE myhash\r\n> (nil)\r\n>\r\n> as it has deducted 16B of key size on every iteration until nil, while\r\n> the hash and field still *exist* until the TTL expires.\r\n>\r\n> Wouldn't that render MEMORY USAGE unreliable for such flow?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/dragonflydb/dragonfly/issues/4911#issuecomment-2789844969>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AA4BFCDHMTTLCC5SXQCGDU32YUR4BAVCNFSM6AAAAAB2ZAROF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDOOBZHA2DIOJWHE>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n\n@abhijat please check why repeated calls to \"HSET/HEXPIRE\" would result in such inconsistency.\nLooks like we might need to account for size change when setting the expiry time in `DenseSet::IteratorBase::SetExpiryTime`. The object size changes during  clone and we need to update the set size accordingly to avoid an int overflow later. \n\nWill create a PR for it.",
  "created_at": "2025-04-10T03:10:47Z",
  "modified_files": [
    "src/core/dense_set.cc"
  ],
  "modified_test_files": [
    "src/core/string_map_test.cc"
  ]
}