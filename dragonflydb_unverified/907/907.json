{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 907,
  "instance_id": "dragonflydb__dragonfly-907",
  "issue_numbers": [
    "835"
  ],
  "base_commit": "5c57e4efe2eead02b5409f6d1988c5952ffcd4d4",
  "patch": "diff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex 81fd4b5bc93e..e577a81d461e 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -48,6 +48,8 @@ OpResult<std::string> ReadValue(const DbContext& context, std::string_view key,\n OpResult<bool> ReadValueBitsetAt(const OpArgs& op_args, std::string_view key, uint32_t offset);\n OpResult<std::size_t> CountBitsForValue(const OpArgs& op_args, std::string_view key, int64_t start,\n                                         int64_t end, bool bit_value);\n+OpResult<int64_t> FindFirstBitWithValue(const OpArgs& op_args, std::string_view key, bool value,\n+                                        int64_t start, int64_t end, bool as_bit);\n std::string GetString(const PrimeValue& pv, EngineShard* shard);\n bool SetBitValue(uint32_t offset, bool bit_value, std::string* entry);\n std::size_t CountBitSetByByteIndices(std::string_view at, std::size_t start, std::size_t end);\n@@ -58,6 +60,23 @@ std::string RunBitOperationOnValues(std::string_view op, const BitsStrVec& value\n \n // ------------------------------------------------------------------------- //\n \n+// Converts `args[i] to uppercase, then sets `*as_bit` to true if `args[i]` equals \"BIT\", false if\n+// `args[i]` equals \"BYTE\", or returns false if `args[i]` has some other invalid value.\n+bool ToUpperAndGetAsBit(CmdArgList args, size_t i, bool* as_bit) {\n+  CHECK_NOTNULL(as_bit);\n+  ToUpper(&args[i]);\n+  std::string_view arg = ArgS(args, i);\n+  if (arg == \"BIT\") {\n+    *as_bit = true;\n+    return true;\n+  } else if (arg == \"BYTE\") {\n+    *as_bit = false;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n // This function can be used for any case where we allowing out of bound\n // access where the default in this case would be 0 -such as bitop\n uint8_t GetByteAt(std::string_view s, std::size_t at) {\n@@ -184,19 +203,22 @@ std::size_t CountBitSetByBitIndices(std::string_view at, std::size_t start, std:\n   return count;\n }\n \n+// Returns normalized offset of `offset` in `size`. `size` is assumed to be a size of a container,\n+// and as such the returned value is always in the range [0, size]. If `offset` is negative, it is\n+// treated as an offset from the end and is normalized to be a positive offset from the start.\n+int64_t NormalizedOffset(int64_t size, int64_t offset) {\n+  if (offset < 0) {\n+    offset = size + offset;\n+  }\n+  return std::min(std::max(offset, int64_t{0}), size);\n+}\n+\n // General purpose function to count the number of bits that are on.\n // The parameters for start, end and bits are defaulted to the start of the string,\n // end of the string and bits are false.\n // Note that when bits is false, it means that we are looking on byte boundaries.\n std::size_t CountBitSet(std::string_view str, int64_t start, int64_t end, bool bits) {\n-  const int32_t size = bits ? str.size() * OFFSET_FACTOR : str.size();\n-\n-  auto NormalizedOffset = [size](int32_t orig) {\n-    if (orig < 0) {\n-      orig = size + orig;\n-    }\n-    return orig;\n-  };\n+  const int64_t size = bits ? str.size() * OFFSET_FACTOR : str.size();\n \n   if (start > 0 && end > 0 && end < start) {\n     return 0;  // for illegal range with positive we just return 0\n@@ -206,11 +228,11 @@ std::size_t CountBitSet(std::string_view str, int64_t start, int64_t end, bool b\n     return 0;  // for illegal range with negative we just return 0\n   }\n \n-  start = NormalizedOffset(start);\n+  start = NormalizedOffset(size, start);\n   if (end > 0 && end < start) {\n     return 0;\n   }\n-  end = NormalizedOffset(end);\n+  end = NormalizedOffset(size, end);\n   if (start > end) {\n     std::swap(start, end);  // we're going backward\n   }\n@@ -483,7 +505,47 @@ OpStatus NoOpCb(Transaction* t, EngineShard* shard) {\n // ------------------------------------------------------------------------- //\n //  Impl for the command functions\n void BitPos(CmdArgList args, ConnectionContext* cntx) {\n-  (*cntx)->SendLong(0);\n+  // Support for the command BITPOS\n+  // See details at https://redis.io/commands/bitpos/\n+\n+  if (args.size() < 2 || args.size() > 6) {\n+    return (*cntx)->SendError(kSyntaxErr);\n+  }\n+\n+  std::string_view key = ArgS(args, 1);\n+\n+  int32_t value{0};\n+  int64_t start = 0;\n+  int64_t end = std::numeric_limits<int64_t>::max();\n+  bool as_bit = false;\n+\n+  if (!absl::SimpleAtoi(ArgS(args, 2), &value)) {\n+    return (*cntx)->SendError(kInvalidIntErr);\n+  }\n+\n+  if (args.size() >= 4) {\n+    if (!absl::SimpleAtoi(ArgS(args, 3), &start)) {\n+      return (*cntx)->SendError(kInvalidIntErr);\n+    }\n+    if (args.size() >= 5) {\n+      if (!absl::SimpleAtoi(ArgS(args, 4), &end)) {\n+        return (*cntx)->SendError(kInvalidIntErr);\n+      }\n+\n+      if (args.size() >= 6) {\n+        if (!ToUpperAndGetAsBit(args, 5, &as_bit)) {\n+          return (*cntx)->SendError(kSyntaxErr);\n+        }\n+      }\n+    }\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return FindFirstBitWithValue(t->GetOpArgs(shard), key, value, start, end, as_bit);\n+  };\n+  Transaction* trans = cntx->transaction;\n+  OpResult<int64_t> res = trans->ScheduleSingleHopT(std::move(cb));\n+  HandleOpValueResult(res, cntx);\n }\n \n void BitCount(CmdArgList args, ConnectionContext* cntx) {\n@@ -505,8 +567,9 @@ void BitCount(CmdArgList args, ConnectionContext* cntx) {\n       return (*cntx)->SendError(kInvalidIntErr);\n     }\n     if (args.size() == 5) {\n-      ToUpper(&args[4]);\n-      as_bit = ArgS(args, 4) == \"BIT\";\n+      if (!ToUpperAndGetAsBit(args, 4, &as_bit)) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n     }\n   }\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -685,6 +748,88 @@ OpResult<std::size_t> CountBitsForValue(const OpArgs& op_args, std::string_view\n   }\n }\n \n+// Returns the bit position (where MSB is 0, LSB is 7) of the leftmost bit that\n+// equals `value` in `byte`. Returns 8 if not found.\n+std::size_t GetFirstBitWithValueInByte(uint8_t byte, bool value) {\n+  if (value) {\n+    return absl::countl_zero(byte);\n+  } else {\n+    return absl::countl_one(byte);\n+  }\n+}\n+\n+int64_t FindFirstBitWithValueAsBit(std::string_view value_str, bool bit_value, int64_t start,\n+                                   int64_t end) {\n+  for (int64_t i = start; i <= end; ++i) {\n+    if (static_cast<size_t>(GetByteIndex(i)) >= value_str.size()) {\n+      break;\n+    }\n+    const uint8_t current_byte = GetByteValue(value_str, i);\n+    bool current_bit = CheckBitStatus(current_byte, GetNormalizedBitIndex(i));\n+    if (current_bit != bit_value) {\n+      continue;\n+    }\n+\n+    return i;\n+  }\n+\n+  return -1;\n+}\n+\n+int64_t FindFirstBitWithValueAsByte(std::string_view value_str, bool bit_value, int64_t start,\n+                                    int64_t end) {\n+  for (int64_t i = start; i <= end; ++i) {\n+    if (static_cast<size_t>(i) >= value_str.size()) {\n+      break;\n+    }\n+    const uint8_t current_byte = value_str[i];\n+    const uint8_t kNotFoundByte = bit_value ? 0 : std::numeric_limits<uint8_t>::max();\n+    if (current_byte == kNotFoundByte) {\n+      continue;\n+    }\n+\n+    return i * OFFSET_FACTOR + GetFirstBitWithValueInByte(current_byte, bit_value);\n+  }\n+\n+  return -1;\n+}\n+\n+OpResult<int64_t> FindFirstBitWithValue(const OpArgs& op_args, std::string_view key, bool bit_value,\n+                                        int64_t start, int64_t end, bool as_bit) {\n+  OpResult<std::string> value = ReadValue(op_args.db_cntx, key, op_args.shard);\n+\n+  std::string_view value_str;\n+  if (value) {  // non-existent keys are treated as empty strings, per Redis\n+    value_str = value.value();\n+  }\n+\n+  int64_t size = value_str.size();\n+  if (as_bit) {\n+    size *= OFFSET_FACTOR;\n+  }\n+\n+  int64_t normalized_start = NormalizedOffset(size, start);\n+  int64_t normalized_end = NormalizedOffset(size, end);\n+  if (normalized_start > normalized_end) {\n+    return -1;  // Return -1 for negative ranges, per Redis\n+  }\n+\n+  int64_t position;\n+  if (as_bit) {\n+    position = FindFirstBitWithValueAsBit(value_str, bit_value, normalized_start, normalized_end);\n+  } else {\n+    position = FindFirstBitWithValueAsByte(value_str, bit_value, normalized_start, normalized_end);\n+  }\n+\n+  if (position == -1 && !bit_value && static_cast<size_t>(start) < value_str.size() &&\n+      end == std::numeric_limits<int64_t>::max()) {\n+    // Returning bit-size of the value, compatible with Redis (but is a weird API).\n+    return value_str.size() * OFFSET_FACTOR;\n+  } else {\n+    return position;\n+  }\n+}\n+\n }  // namespace\n \n void BitOpsFamily::Register(CommandRegistry* registry) {\n",
  "test_patch": "diff --git a/src/server/bitops_family_test.cc b/src/server/bitops_family_test.cc\nindex 78394a49d18b..bd0cb3b36db7 100644\n--- a/src/server/bitops_family_test.cc\n+++ b/src/server/bitops_family_test.cc\n@@ -420,4 +420,114 @@ TEST_F(BitOpsFamilyTest, BitOpsNot) {\n   EXPECT_EQ(res, NOT_RESULTS);\n }\n \n+TEST_F(BitOpsFamilyTest, BitPos) {\n+  ASSERT_EQ(Run({\"set\", \"a\", \"\\x00\\x00\\x06\\xff\\xf0\"_b}), \"OK\");\n+\n+  // Find clear bits\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\"}));\n+  EXPECT_EQ(8, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\"}));\n+  EXPECT_EQ(16, CheckedInt({\"bitpos\", \"a\", \"0\", \"2\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"103\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"0\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"100\"}));\n+  EXPECT_EQ(8, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"100\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"-3\"}));\n+  EXPECT_EQ(8, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"-2\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"3\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"4\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"-2\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"-2\", \"-1\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"-1\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"-100\"}));\n+\n+  // Find clear bits, explicitly mention \"BYTE\"\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"103\", \"BYTE\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"0\", \"BYTE\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"100\", \"BYTE\"}));\n+  EXPECT_EQ(8, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"100\", \"BYTE\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"-3\", \"BYTE\"}));\n+  EXPECT_EQ(8, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"-2\", \"BYTE\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"-2\", \"-1\", \"BYTE\"}));\n+\n+  // Find clear bits using \"BIT\"\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"103\", \"BIT\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"0\", \"100\", \"0\", \"BIT\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(1, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(2, CheckedInt({\"bitpos\", \"a\", \"0\", \"2\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(16, CheckedInt({\"bitpos\", \"a\", \"0\", \"16\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(23, CheckedInt({\"bitpos\", \"a\", \"0\", \"21\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(36, CheckedInt({\"bitpos\", \"a\", \"0\", \"24\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"a\", \"0\", \"0\", \"-3\", \"BIT\"}));\n+  EXPECT_EQ(1, CheckedInt({\"bitpos\", \"a\", \"0\", \"1\", \"-2\", \"BIT\"}));\n+  EXPECT_EQ(38, CheckedInt({\"bitpos\", \"a\", \"0\", \"-2\", \"-1\", \"BIT\"}));\n+\n+  // Find set bits\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"1\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"2\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"a\", \"1\", \"3\"}));\n+  EXPECT_EQ(32, CheckedInt({\"bitpos\", \"a\", \"1\", \"4\"}));\n+  EXPECT_EQ(32, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"a\", \"1\", \"-2\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"-3\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"-4\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"-5\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"-6\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"-100\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"0\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"1\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"3\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"100\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"2\", \"2\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"2\", \"3\"}));\n+  EXPECT_EQ(32, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\", \"-1\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"a\", \"1\", \"-2\", \"-1\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\", \"-2\"}));\n+\n+  // Find set bits, explicitly mention \"BYTE\"\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"0\", \"BYTE\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"1\", \"BYTE\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"3\", \"BYTE\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"100\", \"BYTE\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"2\", \"2\", \"BYTE\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"2\", \"3\", \"BYTE\"}));\n+  EXPECT_EQ(32, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\", \"-1\", \"BYTE\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"a\", \"1\", \"-2\", \"-1\", \"BYTE\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\", \"-2\", \"BYTE\"}));\n+\n+  // Find set bits using \"BIT\"\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"0\", \"BIT\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"1\", \"BIT\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"21\", \"BIT\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"21\", \"21\", \"BIT\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"21\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(21, CheckedInt({\"bitpos\", \"a\", \"1\", \"0\", \"100\", \"BIT\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"-1\", \"-1\", \"BIT\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"a\", \"1\", \"-4\", \"-1\", \"BIT\"}));\n+  EXPECT_EQ(35, CheckedInt({\"bitpos\", \"a\", \"1\", \"-5\", \"-1\", \"BIT\"}));\n+  EXPECT_EQ(34, CheckedInt({\"bitpos\", \"a\", \"1\", \"-6\", \"-1\", \"BIT\"}));\n+\n+  // Make sure we behave like Redis does when looking for clear bits in an all-set string.\n+  ASSERT_EQ(Run({\"set\", \"b\", \"\\xff\\xff\\xff\"_b}), \"OK\");\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"b\", \"0\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"b\", \"0\", \"0\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"b\", \"0\", \"1\"}));\n+  EXPECT_EQ(24, CheckedInt({\"bitpos\", \"b\", \"0\", \"2\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"b\", \"0\", \"3\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"b\", \"0\", \"0\", \"1\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"b\", \"0\", \"0\", \"1\", \"BYTE\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"b\", \"0\", \"0\", \"3\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"b\", \"0\", \"0\", \"3\", \"BYTE\"}));\n+\n+  ASSERT_EQ(Run({\"set\", \"empty\", \"\"_b}), \"OK\");\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"empty\", \"0\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"empty\", \"0\", \"1\"}));\n+\n+  // Non-existent key should be treated like an empty string.\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"d\", \"0\"}));\n+}\n+\n }  // end of namespace dfly\n",
  "problem_statement": "BITPOS does not work\nCurrently, `BITPOS` has no implementation, in the sense that the command is set to always return zero. \r\n\r\nhttps://github.com/dragonflydb/dragonfly/blob/f1751278378a9b067d0b744512d68c703f99ac38/src/server/bitops_family.cc#L485-L487\r\n\r\n**Example**\r\n```shell\r\n> SET mykey \"\\xff\\x00\"\r\n> BITPOS mykey 0\r\n0\r\n```\r\nwhereas it is expected to return 8.\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2023-03-04T19:53:05Z",
  "modified_files": [
    "src/server/bitops_family.cc"
  ],
  "modified_test_files": [
    "src/server/bitops_family_test.cc"
  ]
}