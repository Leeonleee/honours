diff --git a/src/core/interpreter.cc b/src/core/interpreter.cc
index 478646833ec1..ada7b629ea57 100644
--- a/src/core/interpreter.cc
+++ b/src/core/interpreter.cc
@@ -746,6 +746,7 @@ bool Interpreter::AddInternal(const char* f_id, string_view body, string* error)
   return true;
 }
 
+// Stack is cleaned for us, we can leave it dirty
 bool Interpreter::IsTableSafe() const {
   auto fres = FetchKey(lua_, "err");
   if (fres && *fres == LUA_TSTRING) {
@@ -757,40 +758,35 @@ bool Interpreter::IsTableSafe() const {
     return true;
   }
 
-  vector<pair<unsigned, unsigned>> lens;
-  unsigned len = lua_rawlen(lua_, -1);
-  unsigned i = 0;
-
-  // implement dfs traversal
-  while (true) {
-    while (i < len) {
-      DVLOG(1) << "Stack " << lua_gettop(lua_) << "/" << i << "/" << len;
-      int t = lua_rawgeti(lua_, -1, i + 1);  // push table element
-      if (t == LUA_TTABLE) {
-        if (lens.size() >= 127)  // reached depth 128
-          return false;
-
-        CHECK(lua_checkstack(lua_, 1));
-        lens.emplace_back(i + 1, len);  // save the parent state.
-
-        // reset to iterate on the next table.
-        i = 0;
-        len = lua_rawlen(lua_, -1);
-      } else {
-        lua_pop(lua_, 1);  // pop table element
-        ++i;
-      }
-    }
+  // Copy root table because we remove it upon finishing traversal
+  lua_pushnil(lua_);
+  lua_copy(lua_, -2, -1);
 
-    if (lens.empty())  // exit criteria
-      break;
+  int depth = 1;
+  lua_pushnil(lua_);
 
-    // unwind to the state before we went down the stack.
-    tie(i, len) = lens.back();
-    lens.pop_back();
+  // DFS based on lua stack: [parent-table] [parent-key] [parent-value = table] [key]
+  while (depth > 0) {
+    if (lua_checkstack(lua_, 3) == 0 || depth > 128)
+      return false;
 
-    lua_pop(lua_, 1);
-  };
+    bool descending = false;
+    for (; lua_next(lua_, -2) != 0; lua_pop(lua_, 1)) {
+      if (lua_type(lua_, -1) != LUA_TTABLE)
+        continue;
+
+      // If we descend, keep value as new table and push nil for start key
+      depth++;
+      lua_pushnil(lua_);
+      descending = true;
+      break;
+    }
+
+    if (!descending) {
+      lua_pop(lua_, 1);
+      depth--;
+    }
+  }
 
   return true;
 }
@@ -827,7 +823,29 @@ void Interpreter::SerializeResult(ObjectExplorer* serializer) {
         break;
       }
 
+      fres = FetchKey(lua_, "map");
+      if (fres && *fres == LUA_TTABLE) {
+        // Calculate length of map part, there is sadly no other way
+        unsigned len = 0;
+        for (lua_pushnil(lua_); lua_next(lua_, -2) != 0; lua_pop(lua_, 1))
+          len++;
+
+        serializer->OnMapStart(len);
+        for (lua_pushnil(lua_); lua_next(lua_, -2) != 0;) {
+          // Push key to stack top: key value key
+          lua_pushnil(lua_);
+          lua_copy(lua_, -3, -1);
+          SerializeResult(serializer);  // pops key
+          SerializeResult(serializer);  // pop value
+        }
+        serializer->OnMapEnd();
+
+        lua_pop(lua_, 2);
+        break;
+      }
+
       unsigned len = lua_rawlen(lua_, -1);
+
       serializer->OnArrayStart(len);
       for (unsigned i = 0; i < len; ++i) {
         t = lua_rawgeti(lua_, -1, i + 1);  // push table element
diff --git a/src/core/interpreter.h b/src/core/interpreter.h
index e2d333aba88f..c5fb1bee7893 100644
--- a/src/core/interpreter.h
+++ b/src/core/interpreter.h
@@ -28,6 +28,14 @@ class ObjectExplorer {
   virtual void OnNil() = 0;
   virtual void OnStatus(std::string_view str) = 0;
   virtual void OnError(std::string_view str) = 0;
+
+  virtual void OnMapStart(unsigned len) {
+    OnArrayStart(len * 2);
+  }
+
+  virtual void OnMapEnd() {
+    OnArrayEnd();
+  }
 };
 
 class Interpreter {
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index fcc00b48235f..b949f48918d1 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -26,8 +26,8 @@ extern "C" {
 #include "base/logging.h"
 #include "facade/dragonfly_connection.h"
 #include "facade/error.h"
+#include "facade/reply_builder.h"
 #include "facade/reply_capture.h"
-#include "facade/resp_expr.h"
 #include "server/acl/acl_commands_def.h"
 #include "server/acl/acl_family.h"
 #include "server/acl/user_registry.h"
@@ -291,6 +291,7 @@ class InterpreterReplier : public RedisReplyBuilder {
   unsigned num_elems_ = 0;
 };
 
+// Serialized result of script invocation to Redis protocol
 class EvalSerializer : public ObjectExplorer {
  public:
   EvalSerializer(RedisReplyBuilder* rb) : rb_(rb) {
@@ -328,6 +329,13 @@ class EvalSerializer : public ObjectExplorer {
   void OnArrayEnd() final {
   }
 
+  void OnMapStart(unsigned len) final {
+    rb_->StartCollection(len, RedisReplyBuilder::MAP);
+  }
+
+  void OnMapEnd() final {
+  }
+
   void OnNil() final {
     rb_->SendNull();
   }
