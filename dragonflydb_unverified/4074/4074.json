{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4074,
  "instance_id": "dragonflydb__dragonfly-4074",
  "issue_numbers": [
    "4071"
  ],
  "base_commit": "f8b3fa0d7bf1d95674f80eef826ffd66f5a57659",
  "patch": "diff --git a/src/server/common.cc b/src/server/common.cc\nindex cdaf41ebe2e9..bb78d4e4668f 100644\n--- a/src/server/common.cc\n+++ b/src/server/common.cc\n@@ -18,6 +18,8 @@ extern \"C\" {\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n #include \"core/compact_object.h\"\n+#include \"core/interpreter.h\"\n+#include \"server/conn_context.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/error.h\"\n #include \"server/journal/journal.h\"\n@@ -453,4 +455,29 @@ void ThreadLocalMutex::unlock() {\n   }\n }\n \n+BorrowedInterpreter::BorrowedInterpreter(Transaction* tx, ConnectionState* state) {\n+  // Ensure squashing ignores EVAL. We can't run on a stub context, because it doesn't have our\n+  // preborrowed interpreter (which can't be shared on multiple threads).\n+  CHECK(!state->squashing_info);\n+\n+  if (auto borrowed = state->exec_info.preborrowed_interpreter; borrowed) {\n+    // Ensure a preborrowed interpreter is only set for an already running MULTI transaction.\n+    CHECK_EQ(state->exec_info.state, ConnectionState::ExecInfo::EXEC_RUNNING);\n+\n+    interpreter_ = borrowed;\n+  } else {\n+    // A scheduled transaction occupies a place in the transaction queue and holds locks,\n+    // preventing other transactions from progressing. Blocking below can deadlock!\n+    CHECK(!tx->IsScheduled());\n+\n+    interpreter_ = ServerState::tlocal()->BorrowInterpreter();\n+    owned_ = true;\n+  }\n+}\n+\n+BorrowedInterpreter::~BorrowedInterpreter() {\n+  if (owned_)\n+    ServerState::tlocal()->ReturnInterpreter(interpreter_);\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/common.h b/src/server/common.h\nindex efe66d6ee684..1ab29b27023f 100644\n--- a/src/server/common.h\n+++ b/src/server/common.h\n@@ -47,6 +47,8 @@ using RdbTypeFreqMap = absl::flat_hash_map<unsigned, size_t>;\n class CommandId;\n class Transaction;\n class EngineShard;\n+class ConnectionState;\n+class Interpreter;\n \n struct LockTagOptions {\n   bool enabled = false;\n@@ -353,6 +355,29 @@ template <typename Mutex> class ABSL_SCOPED_LOCKABLE SharedLock {\n   bool is_locked_;\n };\n \n+// Ensures availability of an interpreter for EVAL-like commands and it's automatic release.\n+// If it's part of MULTI, the preborrowed interpreter is returned, otherwise a new is acquired.\n+struct BorrowedInterpreter {\n+  BorrowedInterpreter(Transaction* tx, ConnectionState* state);\n+\n+  ~BorrowedInterpreter();\n+\n+  // Give up ownership of the interpreter, it must be returned manually.\n+  Interpreter* Release() && {\n+    DCHECK(owned_);\n+    owned_ = false;\n+    return interpreter_;\n+  }\n+\n+  operator Interpreter*() {\n+    return interpreter_;\n+  }\n+\n+ private:\n+  Interpreter* interpreter_ = nullptr;\n+  bool owned_ = false;\n+};\n+\n extern size_t serialization_max_chunk_size;\n \n }  // namespace dfly\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 6cdd66f1a12b..40652c34e00d 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -72,6 +72,13 @@ size_t StoredCmd::NumArgs() const {\n   return sizes_.size();\n }\n \n+std::string StoredCmd::FirstArg() const {\n+  if (sizes_.size() == 0) {\n+    return {};\n+  }\n+  return buffer_.substr(0, sizes_[0]);\n+}\n+\n facade::ReplyMode StoredCmd::ReplyMode() const {\n   return reply_mode_;\n }\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex dc8c50442179..58e586e6e789 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -46,6 +46,8 @@ class StoredCmd {\n     Fill(absl::MakeSpan(*dest));\n   }\n \n+  std::string FirstArg() const;\n+\n   const CommandId* Cid() const;\n \n   facade::ReplyMode ReplyMode() const;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex c4183ccc8a40..9072f9b51021 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -684,32 +684,33 @@ void ClusterHtmlPage(const http::QueryArgs& args, HttpContext* send,\n   send->Invoke(std::move(resp));\n }\n \n-enum class ExecEvalState {\n+enum class ExecScriptUse {\n   NONE = 0,\n-  ALL = 1,\n-  SOME = 2,\n+  SCRIPT_LOAD = 1,\n+  SCRIPT_RUN = 2,\n };\n \n-ExecEvalState DetermineEvalPresense(const std::vector<StoredCmd>& body) {\n-  unsigned eval_cnt = 0;\n+ExecScriptUse DetermineScriptPresense(const std::vector<StoredCmd>& body) {\n+  bool script_load = false;\n   for (const auto& scmd : body) {\n     if (CO::IsEvalKind(scmd.Cid()->name())) {\n-      eval_cnt++;\n+      return ExecScriptUse::SCRIPT_RUN;\n     }\n-  }\n \n-  if (eval_cnt == 0)\n-    return ExecEvalState::NONE;\n+    if ((scmd.Cid()->name() == \"SCRIPT\") && (absl::AsciiStrToUpper(scmd.FirstArg()) == \"LOAD\")) {\n+      script_load = true;\n+    }\n+  }\n \n-  if (eval_cnt == body.size())\n-    return ExecEvalState::ALL;\n+  if (script_load)\n+    return ExecScriptUse::SCRIPT_LOAD;\n \n-  return ExecEvalState::SOME;\n+  return ExecScriptUse::NONE;\n }\n \n // Returns the multi mode for that transaction. Returns NOT_DETERMINED if no scheduling\n // is required.\n-Transaction::MultiMode DeduceExecMode(ExecEvalState state,\n+Transaction::MultiMode DeduceExecMode(ExecScriptUse state,\n                                       const ConnectionState::ExecInfo& exec_info,\n                                       const ScriptMgr& script_mgr) {\n   // Check if script most LIKELY has global eval transactions\n@@ -717,7 +718,7 @@ Transaction::MultiMode DeduceExecMode(ExecEvalState state,\n   Transaction::MultiMode multi_mode =\n       static_cast<Transaction::MultiMode>(absl::GetFlag(FLAGS_multi_exec_mode));\n \n-  if (state != ExecEvalState::NONE) {\n+  if (state == ExecScriptUse::SCRIPT_RUN) {\n     contains_global = script_mgr.AreGlobalByDefault();\n   }\n \n@@ -765,50 +766,6 @@ string CreateExecDescriptor(const std::vector<StoredCmd>& stored_cmds, unsigned\n   return result;\n }\n \n-// Ensures availability of an interpreter for EVAL-like commands and it's automatic release.\n-// If it's part of MULTI, the preborrowed interpreter is returned, otherwise a new is acquired.\n-struct BorrowedInterpreter {\n-  BorrowedInterpreter(Transaction* tx, ConnectionContext* cntx) {\n-    // Ensure squashing ignores EVAL. We can't run on a stub context, because it doesn't have our\n-    // preborrowed interpreter (which can't be shared on multiple threads).\n-    CHECK(!cntx->conn_state.squashing_info);\n-\n-    if (auto borrowed = cntx->conn_state.exec_info.preborrowed_interpreter; borrowed) {\n-      // Ensure a preborrowed interpreter is only set for an already running MULTI transaction.\n-      CHECK_EQ(cntx->conn_state.exec_info.state, ConnectionState::ExecInfo::EXEC_RUNNING);\n-\n-      interpreter_ = borrowed;\n-    } else {\n-      // A scheduled transaction occupies a place in the transaction queue and holds locks,\n-      // preventing other transactions from progressing. Blocking below can deadlock!\n-      CHECK(!tx->IsScheduled());\n-\n-      interpreter_ = ServerState::tlocal()->BorrowInterpreter();\n-      owned_ = true;\n-    }\n-  }\n-\n-  ~BorrowedInterpreter() {\n-    if (owned_)\n-      ServerState::tlocal()->ReturnInterpreter(interpreter_);\n-  }\n-\n-  // Give up ownership of the interpreter, it must be returned manually.\n-  Interpreter* Release() && {\n-    DCHECK(owned_);\n-    owned_ = false;\n-    return interpreter_;\n-  }\n-\n-  operator Interpreter*() {\n-    return interpreter_;\n-  }\n-\n- private:\n-  Interpreter* interpreter_ = nullptr;\n-  bool owned_ = false;\n-};\n-\n string ConnectionLogContext(const facade::Connection* conn) {\n   if (conn == nullptr) {\n     return \"(null-conn)\";\n@@ -1873,7 +1830,7 @@ void Service::Eval(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n     return rb->SendNull();\n   }\n \n-  BorrowedInterpreter interpreter{tx, cntx};\n+  BorrowedInterpreter interpreter{tx, &cntx->conn_state};\n   auto res = server_family_.script_mgr()->Insert(body, interpreter);\n   if (!res)\n     return builder->SendError(res.error().Format(), facade::kScriptErrType);\n@@ -1887,7 +1844,7 @@ void Service::EvalSha(CmdArgList args, Transaction* tx, SinkReplyBuilder* builde\n                       ConnectionContext* cntx) {\n   string sha = absl::AsciiStrToLower(ArgS(args, 0));\n \n-  BorrowedInterpreter interpreter{cntx->transaction, cntx};\n+  BorrowedInterpreter interpreter{cntx->transaction, &cntx->conn_state};\n   CallSHA(args, sha, interpreter, builder, cntx);\n }\n \n@@ -2254,12 +2211,13 @@ void Service::Exec(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n \n   cntx->last_command_debug.exec_body_len = exec_info.body.size();\n \n-  // The transaction can contain scripts, determine their presence ahead to customize logic below.\n-  ExecEvalState state = DetermineEvalPresense(exec_info.body);\n+  // The transaction can contain script load script execution, determine their presence ahead to\n+  // customize logic below.\n+  ExecScriptUse state = DetermineScriptPresense(exec_info.body);\n \n-  // We borrow a single interpreter for all the EVALs inside. Returned by MultiCleanup\n-  if (state != ExecEvalState::NONE) {\n-    exec_info.preborrowed_interpreter = BorrowedInterpreter(tx, cntx).Release();\n+  // We borrow a single interpreter for all the EVALs/Script load inside. Returned by MultiCleanup\n+  if (state != ExecScriptUse::NONE) {\n+    exec_info.preborrowed_interpreter = BorrowedInterpreter(tx, &cntx->conn_state).Release();\n   }\n \n   // Determine according multi mode, not only only flag, but based on presence of global commands\n@@ -2293,7 +2251,7 @@ void Service::Exec(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n       ServerState::tlocal()->exec_freq_count[descr]++;\n     }\n \n-    if (absl::GetFlag(FLAGS_multi_exec_squash) && state == ExecEvalState::NONE &&\n+    if (absl::GetFlag(FLAGS_multi_exec_squash) && state != ExecScriptUse::SCRIPT_RUN &&\n         !cntx->conn_state.tracking_info_.IsTrackingOn()) {\n       MultiCommandSquasher::Execute(absl::MakeSpan(exec_info.body), rb, cntx, this);\n     } else {\ndiff --git a/src/server/script_mgr.cc b/src/server/script_mgr.cc\nindex f6bb61a920d7..0053a02f470f 100644\n--- a/src/server/script_mgr.cc\n+++ b/src/server/script_mgr.cc\n@@ -67,7 +67,8 @@ ScriptMgr::ScriptKey::ScriptKey(string_view sha) : array{} {\n   memcpy(data(), sha.data(), size());\n }\n \n-void ScriptMgr::Run(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder) {\n+void ScriptMgr::Run(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n+                    ConnectionContext* cntx) {\n   string subcmd = absl::AsciiStrToUpper(ArgS(args, 0));\n \n   if (subcmd == \"HELP\") {\n@@ -110,7 +111,7 @@ void ScriptMgr::Run(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder)\n     return LatencyCmd(tx, builder);\n \n   if (subcmd == \"LOAD\" && args.size() == 2)\n-    return LoadCmd(args, tx, builder);\n+    return LoadCmd(args, tx, builder, cntx);\n \n   if (subcmd == \"FLAGS\" && args.size() > 2)\n     return ConfigCmd(args, tx, builder);\n@@ -144,7 +145,8 @@ void ScriptMgr::FlushCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* bui\n   return builder->SendOk();\n }\n \n-void ScriptMgr::LoadCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder) {\n+void ScriptMgr::LoadCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n+                        ConnectionContext* cntx) {\n   string_view body = ArgS(args, 1);\n   auto rb = static_cast<RedisReplyBuilder*>(builder);\n   if (body.empty()) {\n@@ -153,9 +155,7 @@ void ScriptMgr::LoadCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* buil\n     return rb->SendBulkString(sha);\n   }\n \n-  ServerState* ss = ServerState::tlocal();\n-  auto interpreter = ss->BorrowInterpreter();\n-  absl::Cleanup clean = [ss, interpreter]() { ss->ReturnInterpreter(interpreter); };\n+  BorrowedInterpreter interpreter{tx, &cntx->conn_state};\n \n   auto res = Insert(body, interpreter);\n   if (!res)\ndiff --git a/src/server/script_mgr.h b/src/server/script_mgr.h\nindex 7cad5ceea02c..63241682b925 100644\n--- a/src/server/script_mgr.h\n+++ b/src/server/script_mgr.h\n@@ -48,7 +48,7 @@ class ScriptMgr {\n \n   ScriptMgr();\n \n-  void Run(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder);\n+  void Run(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder, ConnectionContext* cntx);\n \n   // Insert script and return sha. Get possible error from compilation or parsing script flags.\n   io::Result<std::string, GenericError> Insert(std::string_view body, Interpreter* interpreter);\n@@ -69,7 +69,8 @@ class ScriptMgr {\n  private:\n   void ExistsCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder) const;\n   void FlushCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder);\n-  void LoadCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder);\n+  void LoadCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n+               ConnectionContext* cntx);\n   void ConfigCmd(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder);\n   void ListCmd(Transaction* tx, SinkReplyBuilder* builder) const;\n   void LatencyCmd(Transaction* tx, SinkReplyBuilder* builder) const;\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 03cae22afdd3..83f9ea39e967 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -3008,7 +3008,7 @@ void ServerFamily::Role(CmdArgList args, Transaction* tx, SinkReplyBuilder* buil\n \n void ServerFamily::Script(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\n                           ConnectionContext* cntx) {\n-  script_mgr_->Run(std::move(args), tx, builder);\n+  script_mgr_->Run(std::move(args), tx, builder, cntx);\n }\n \n void ServerFamily::LastSave(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder,\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex cb5935ac4596..3064cd51296a 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -399,10 +399,12 @@ OpStatus Transaction::InitByArgs(Namespace* ns, DbIndex index, CmdArgList args)\n   }\n \n   if ((cid_->opt_mask() & CO::NO_KEY_TRANSACTIONAL) > 0) {\n-    if ((cid_->opt_mask() & CO::NO_KEY_TX_SPAN_ALL) > 0)\n+    if (((cid_->opt_mask() & CO::NO_KEY_TX_SPAN_ALL) > 0)) {\n       EnableAllShards();\n-    else\n+    } else {\n       EnableShard(0);\n+    }\n+\n     return OpStatus::OK;\n   }\n \n@@ -976,7 +978,7 @@ string Transaction::DEBUG_PrintFailState(ShardId sid) const {\n void Transaction::EnableShard(ShardId sid) {\n   unique_shard_cnt_ = 1;\n   unique_shard_id_ = sid;\n-  shard_data_.resize(1);\n+  shard_data_.resize(IsActiveMulti() ? shard_set->size() : 1);\n   shard_data_.front().local_mask |= ACTIVE;\n }\n \n",
  "test_patch": "diff --git a/src/server/multi_test.cc b/src/server/multi_test.cc\nindex a1ed70faea9c..161f291de04e 100644\n--- a/src/server/multi_test.cc\n+++ b/src/server/multi_test.cc\n@@ -1147,6 +1147,29 @@ TEST_F(MultiEvalTest, MultiAndEval) {\n   Run({\"eval\", \"return 'OK';\", \"0\"});\n   auto resp = Run({\"exec\"});\n   EXPECT_EQ(resp, \"OK\");\n+\n+  // We had a bug running script load inside multi\n+  Run({\"multi\"});\n+  Run({\"script\", \"load\", \"return '5'\"});\n+  Run({\"exec\"});\n+\n+  Run({\"multi\"});\n+  Run({\"script\", \"load\", \"return '5'\"});\n+  Run({\"get\", \"x\"});\n+  Run({\"exec\"});\n+\n+  Run({\"multi\"});\n+  Run({\"script\", \"load\", \"return '5'\"});\n+  Run({\"mset\", \"x1\", \"y1\", \"x2\", \"y2\"});\n+  Run({\"exec\"});\n+\n+  Run({\"multi\"});\n+  Run({\"script\", \"load\", \"return '5'\"});\n+  Run({\"eval\", \"return redis.call('set', 'x', 'y')\", \"1\", \"x\"});\n+  Run({\"get\", \"x\"});\n+  Run({\"exec\"});\n+\n+  Run({\"get\", \"x\"});\n }\n \n TEST_F(MultiTest, MultiTypes) {\n",
  "problem_statement": "crash in muti/exec transaction\nTo reproduce:\r\n```\r\n./dragonfly --logtostderr   --proactor_threads=2\r\n```\r\n\r\nand then:\r\n\r\n```\r\nMULTI\r\nSCRIPT LOAD 'return 42'\r\nEXEC\r\n```\n",
  "hints_text": "",
  "created_at": "2024-11-06T13:25:14Z",
  "modified_files": [
    "src/server/common.cc",
    "src/server/common.h",
    "src/server/conn_context.cc",
    "src/server/conn_context.h",
    "src/server/main_service.cc",
    "src/server/script_mgr.cc",
    "src/server/script_mgr.h",
    "src/server/server_family.cc",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "src/server/multi_test.cc"
  ]
}