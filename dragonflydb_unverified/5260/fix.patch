diff --git a/src/facade/cmd_arg_parser.h b/src/facade/cmd_arg_parser.h
index 94e4cb429fea..27922bbcc9c6 100644
--- a/src/facade/cmd_arg_parser.h
+++ b/src/facade/cmd_arg_parser.h
@@ -145,6 +145,7 @@ struct CmdArgParser {
     return *this;
   }
 
+  // Expect no more arguments and return if no error has occured
   bool Finalize() {
     if (HasNext()) {
       Report(UNPROCESSED, cur_i_);
diff --git a/src/server/conn_context.cc b/src/server/conn_context.cc
index 4cd9b0e6e694..fd7f0008a993 100644
--- a/src/server/conn_context.cc
+++ b/src/server/conn_context.cc
@@ -173,11 +173,6 @@ void ConnectionContext::ChangeMonitor(bool start) {
   EnableMonitoring(start);
 }
 
-void ConnectionContext::SwitchTxCmd(const CommandId* cid) {
-  transaction->MultiSwitchCmd(cid);
-  this->cid = cid;
-}
-
 void ConnectionContext::ChangeSubscription(bool to_add, bool to_reply, CmdArgList args,
                                            facade::RedisReplyBuilder* rb) {
   vector<unsigned> result = ChangeSubscriptions(args, false, to_add, to_reply);
diff --git a/src/server/conn_context.h b/src/server/conn_context.h
index 9cd709668827..082d735c0d04 100644
--- a/src/server/conn_context.h
+++ b/src/server/conn_context.h
@@ -310,7 +310,6 @@ class ConnectionContext : public facade::ConnectionContext {
   void UnsubscribeAll(bool to_reply, facade::RedisReplyBuilder* rb);
   void PUnsubscribeAll(bool to_reply, facade::RedisReplyBuilder* rb);
   void ChangeMonitor(bool start);  // either start or stop monitor on a given connection
-  void SwitchTxCmd(const CommandId* cid);
 
   size_t UsedMemory() const override;
 
diff --git a/src/server/debugcmd.cc b/src/server/debugcmd.cc
index 5fad41f04318..9de704bf17f7 100644
--- a/src/server/debugcmd.cc
+++ b/src/server/debugcmd.cc
@@ -1459,7 +1459,7 @@ void DebugCmd::DoPopulateBatch(const PopulateOptions& options, const PopulateBat
         args_view.push_back(arg);
       }
       auto args_span = absl::MakeSpan(args_view);
-      local_cntx.SwitchTxCmd(cid);
+      stub_tx->MultiSwitchCmd(cid);
       crb.SetReplyMode(ReplyMode::NONE);
       stub_tx->InitByArgs(cntx_->ns, local_cntx.conn_state.db_index, args_span);
 
@@ -1481,8 +1481,8 @@ void DebugCmd::DoPopulateBatch(const PopulateOptions& options, const PopulateBat
         args_view.push_back(arg);
       }
       auto args_span = absl::MakeSpan(args_view);
-      local_cntx.SwitchTxCmd(cid);
       crb.SetReplyMode(ReplyMode::NONE);
+      stub_tx->MultiSwitchCmd(cid);
       stub_tx->InitByArgs(cntx_->ns, local_cntx.conn_state.db_index, args_span);
       sf_.service().InvokeCmd(cid, args_span,
                               CommandContext{local_cntx.transaction, &crb, &local_cntx});
diff --git a/src/server/list_family.cc b/src/server/list_family.cc
index 77213ae4c320..f0c4a7930d79 100644
--- a/src/server/list_family.cc
+++ b/src/server/list_family.cc
@@ -1170,47 +1170,6 @@ void BPopGeneric(ListDir dir, CmdArgList args, Transaction* tx, SinkReplyBuilder
   return rb->SendNullArray();
 }
 
-struct LMPopParams {
-  uint32_t num_keys;
-  ListDir dir;
-  int pop_count;
-};
-
-facade::ErrorReply ParseLMPop(CmdArgList args, LMPopParams* params) {
-  CmdArgParser parser{args};
-
-  if (!SimpleAtoi(parser.Next(), &params->num_keys)) {
-    return facade::ErrorReply(kUintErr);
-  }
-
-  if (params->num_keys <= 0 || !parser.HasAtLeast(params->num_keys + 1)) {
-    return facade::ErrorReply(kSyntaxErr);
-  }
-
-  parser.Skip(params->num_keys);
-
-  if (parser.Check("LEFT")) {
-    params->dir = ListDir::LEFT;
-  } else if (parser.Check("RIGHT")) {
-    params->dir = ListDir::RIGHT;
-  } else {
-    return facade::ErrorReply(kSyntaxErr);
-  }
-
-  params->pop_count = 1;
-  if (parser.HasNext()) {
-    if (!parser.Check("COUNT", &params->pop_count)) {
-      return facade::ErrorReply(kSyntaxErr);
-    }
-  }
-
-  if (!parser.Finalize()) {
-    return facade::ErrorReply(parser.Error()->MakeReply());
-  }
-
-  return facade::ErrorReply(OpStatus::OK);
-}
-
 // Returns the first non-empty key found in the shard arguments along with its type validity.
 // Returns a pair of (key, is_valid_type) where is_valid_type is true if the key exists
 // and has the correct type (LIST). If a wrong type is found, returns that key with false.
@@ -1244,13 +1203,16 @@ optional<pair<string_view, bool>> GetFirstNonEmptyKeyFound(EngineShard* shard, T
 void ListFamily::LMPop(CmdArgList args, const CommandContext& cmd_cntx) {
   auto* response_builder = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);
 
-  LMPopParams params;
-  facade::ErrorReply parse_result = ParseLMPop(args, &params);
+  CmdArgParser parser{args};
+  parser.Skip(parser.Next<size_t>());  // skip numkeys and keys
+
+  ListDir dir = parser.MapNext("LEFT", ListDir::LEFT, "RIGHT", ListDir::RIGHT);
+  size_t pop_count = 1;
+  if (parser.Check("COUNT"))
+    pop_count = parser.Next<size_t>();
 
-  if (parse_result.status != OpStatus::OK) {
-    response_builder->SendError(parse_result);
-    return;
-  }
+  if (!parser.Finalize())
+    return response_builder->SendError(parser.Error()->MakeReply());
 
   // Create a vector to store first found key for each shard
   vector<optional<pair<string_view, bool>>> found_keys_per_shard(shard_set->size());
@@ -1301,10 +1263,10 @@ void ListFamily::LMPop(CmdArgList args, const CommandContext& cmd_cntx) {
   optional<ShardId> key_shard = Shard(*key_to_pop, shard_set->size());
   OpResult<StringVec> result;
 
-  auto cb_pop = [&params, key_shard, &result, key = *key_to_pop](Transaction* t,
-                                                                 EngineShard* shard) {
+  auto cb_pop = [dir, pop_count, key_shard, &result, key = *key_to_pop](Transaction* t,
+                                                                        EngineShard* shard) {
     if (*key_shard == shard->shard_id()) {
-      result = OpPop(t->GetOpArgs(shard), key, params.dir, params.pop_count, true, false);
+      result = OpPop(t->GetOpArgs(shard), key, dir, pop_count, true, false);
     }
     return OpStatus::OK;
   };
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index 0dde5bc1aa5a..1905b95834a5 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -1351,6 +1351,7 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args,
   DCHECK(!cid->Validate(tail_args));
 
   ConnectionContext* cntx = cmd_cntx.conn_cntx;
+  cntx->cid = cid;
   auto* builder = cmd_cntx.rb;
   DCHECK(builder);
   DCHECK(cntx);
@@ -2283,13 +2284,10 @@ void Service::Exec(CmdArgList args, const CommandContext& cmd_cntx) {
     } else {
       CmdArgVec arg_vec;
       for (const auto& scmd : exec_info.body) {
-        VLOG(2) << "TX CMD " << scmd.Cid()->name() << " " << scmd.NumArgs();
-
-        cntx->SwitchTxCmd(scmd.Cid());
-
         CmdArgList args = scmd.ArgList(&arg_vec);
 
         if (scmd.Cid()->IsTransactional()) {
+          cmd_cntx.tx->MultiSwitchCmd(scmd.Cid());
           OpStatus st = cmd_cntx.tx->InitByArgs(cntx->ns, cntx->conn_state.db_index, args);
           if (st != OpStatus::OK) {
             rb->SendError(st);
diff --git a/src/server/multi_command_squasher.cc b/src/server/multi_command_squasher.cc
index 36ea3122bacc..8caf9f77ee25 100644
--- a/src/server/multi_command_squasher.cc
+++ b/src/server/multi_command_squasher.cc
@@ -151,10 +151,10 @@ bool MultiCommandSquasher::ExecuteStandalone(RedisReplyBuilder* rb, const Stored
   }
 
   auto* tx = cntx_->transaction;
-  cntx_->SwitchTxCmd(cmd->Cid());
-
-  if (cmd->Cid()->IsTransactional())
+  if (cmd->Cid()->IsTransactional()) {
+    tx->MultiSwitchCmd(cmd->Cid());
     tx->InitByArgs(cntx_->ns, cntx_->conn_state.db_index, args);
+  }
   service_->InvokeCmd(cmd->Cid(), args, CommandContext{tx, rb, cntx_});
 
   return true;
@@ -192,9 +192,9 @@ OpStatus MultiCommandSquasher::SquashedHopCb(EngineShard* es, RespVersion resp_v
       }
     }
 
-    local_cntx.SwitchTxCmd(dispatched.cmd->Cid());
     crb.SetReplyMode(dispatched.cmd->ReplyMode());
 
+    local_tx->MultiSwitchCmd(dispatched.cmd->Cid());
     local_tx->InitByArgs(cntx_->ns, local_cntx.conn_state.db_index, args);
     service_->InvokeCmd(dispatched.cmd->Cid(), args,
                         CommandContext{local_cntx.transaction, &crb, &local_cntx});
diff --git a/src/server/transaction.cc b/src/server/transaction.cc
index 9f5af6f75a01..168a22c30266 100644
--- a/src/server/transaction.cc
+++ b/src/server/transaction.cc
@@ -318,10 +318,9 @@ void Transaction::StoreKeysInArgs(const KeyIndex& key_index) {
 }
 
 void Transaction::InitByKeys(const KeyIndex& key_index) {
-  if (key_index.start == full_args_.size()) {  // eval with 0 keys.
-    CHECK(absl::StartsWith(cid_->name(), "EVAL")) << cid_->name();
+  // Skip initialization for key-dependent transactions without keys
+  if ((key_index.end - key_index.start) + int(bool(key_index.bonus)) == 0)
     return;
-  }
 
   DCHECK_LT(key_index.start, full_args_.size());
 
@@ -1602,7 +1601,7 @@ OpResult<KeyIndex> DetermineKeys(const CommandId* cid, CmdArgList args) {
 
     if (num_custom_keys == 0 &&
         (absl::StartsWith(name, "ZDIFF") || absl::StartsWith(name, "ZUNION") ||
-         absl::StartsWith(name, "ZINTER"))) {
+         absl::StartsWith(name, "ZINTER") || absl::EndsWith(name, "MPOP"))) {
       return OpStatus::AT_LEAST_ONE_KEY;
     }
 
