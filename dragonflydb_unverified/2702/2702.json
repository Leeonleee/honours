{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2702,
  "instance_id": "dragonflydb__dragonfly-2702",
  "issue_numbers": [
    "2642"
  ],
  "base_commit": "292c5bcd7173d4558d80d402c24be9c868bfec00",
  "patch": "diff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 6a119e98cb92..11d8a1eb3b60 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -776,6 +776,8 @@ void ServerFamily::Shutdown() {\n \n   JoinSnapshotSchedule();\n \n+  bg_save_fb_.JoinIfNeeded();\n+\n   if (save_on_shutdown_ && !absl::GetFlag(FLAGS_dbfilename).empty()) {\n     shard_set->pool()->GetNextProactor()->Await([this] {\n       if (GenericError ec = DoSave(); ec) {\n@@ -1297,8 +1299,8 @@ GenericError ServerFamily::DoSave(bool ignore_state) {\n   return DoSave(absl::GetFlag(FLAGS_df_snapshot_format), {}, trans.get(), ignore_state);\n }\n \n-GenericError ServerFamily::DoSave(bool new_version, string_view basename, Transaction* trans,\n-                                  bool ignore_state) {\n+GenericError ServerFamily::DoSaveCheckAndStart(bool new_version, string_view basename,\n+                                               Transaction* trans, bool ignore_state) {\n   if (shard_set->IsTieringEnabled()) {\n     return GenericError{make_error_code(errc::operation_not_permitted),\n                         StrCat(\"Can not save database in tiering mode\")};\n@@ -1309,7 +1311,6 @@ GenericError ServerFamily::DoSave(bool new_version, string_view basename, Transa\n     return GenericError{make_error_code(errc::operation_in_progress),\n                         StrCat(GlobalStateName(state), \" - can not save database\")};\n   }\n-\n   {\n     std::lock_guard lk(save_mu_);\n     if (save_controller_) {\n@@ -1329,7 +1330,10 @@ GenericError ServerFamily::DoSave(bool new_version, string_view basename, Transa\n       return res->error;\n     }\n   }\n+  return {};\n+}\n \n+GenericError ServerFamily::WaitUntilSaveFinished(Transaction* trans, bool ignore_state) {\n   save_controller_->WaitAllSnapshots();\n   detail::SaveInfo save_info;\n \n@@ -1351,6 +1355,15 @@ GenericError ServerFamily::DoSave(bool new_version, string_view basename, Transa\n   return save_info.error;\n }\n \n+GenericError ServerFamily::DoSave(bool new_version, string_view basename, Transaction* trans,\n+                                  bool ignore_state) {\n+  if (auto ec = DoSaveCheckAndStart(new_version, basename, trans, ignore_state); ec) {\n+    return ec;\n+  }\n+\n+  return WaitUntilSaveFinished(trans, ignore_state);\n+}\n+\n bool ServerFamily::TEST_IsSaving() const {\n   std::atomic_bool is_saving{false};\n   shard_set->pool()->AwaitFiberOnAll([&](auto*) {\n@@ -1629,16 +1642,22 @@ void ServerFamily::Memory(CmdArgList args, ConnectionContext* cntx) {\n   return mem_cmd.Run(args);\n }\n \n-// SAVE [DF|RDB] [basename]\n-// Allows saving the snapshot of the dataset on disk, potentially overriding the format\n-// and the snapshot name.\n-void ServerFamily::Save(CmdArgList args, ConnectionContext* cntx) {\n-  string err_detail;\n-  bool new_version = absl::GetFlag(FLAGS_df_snapshot_format);\n+void ServerFamily::BgSaveFb(boost::intrusive_ptr<Transaction> trans) {\n+  GenericError ec = WaitUntilSaveFinished(trans.get());\n+  if (ec) {\n+    LOG(INFO) << \"Error in BgSaveFb: \" << ec.Format();\n+  }\n+}\n+\n+std::optional<ServerFamily::VersionBasename> ServerFamily::GetVersionAndBasename(\n+    CmdArgList args, ConnectionContext* cntx) {\n   if (args.size() > 2) {\n-    return cntx->SendError(kSyntaxErr);\n+    cntx->SendError(kSyntaxErr);\n+    return {};\n   }\n \n+  bool new_version = absl::GetFlag(FLAGS_df_snapshot_format);\n+\n   if (args.size() >= 1) {\n     ToUpper(&args[0]);\n     string_view sub_cmd = ArgS(args, 0);\n@@ -1647,7 +1666,8 @@ void ServerFamily::Save(CmdArgList args, ConnectionContext* cntx) {\n     } else if (sub_cmd == \"RDB\") {\n       new_version = false;\n     } else {\n-      return cntx->SendError(UnknownSubCmd(sub_cmd, \"SAVE\"), kSyntaxErrType);\n+      cntx->SendError(UnknownSubCmd(sub_cmd, \"SAVE\"), kSyntaxErrType);\n+      return {};\n     }\n   }\n \n@@ -1656,7 +1676,41 @@ void ServerFamily::Save(CmdArgList args, ConnectionContext* cntx) {\n     basename = ArgS(args, 1);\n   }\n \n-  GenericError ec = DoSave(new_version, basename, cntx->transaction);\n+  return ServerFamily::VersionBasename{new_version, basename};\n+}\n+\n+// BGSAVE [DF|RDB] [basename]\n+// TODO add missing [SCHEDULE]\n+void ServerFamily::BgSave(CmdArgList args, ConnectionContext* cntx) {\n+  auto maybe_res = GetVersionAndBasename(args, cntx);\n+  if (!maybe_res) {\n+    return;\n+  }\n+\n+  const auto [version, basename] = *maybe_res;\n+\n+  if (auto ec = DoSaveCheckAndStart(version, basename, cntx->transaction); ec) {\n+    cntx->SendError(ec.Format());\n+    return;\n+  }\n+  bg_save_fb_.JoinIfNeeded();\n+  bg_save_fb_ = fb2::Fiber(\"bg_save_fiber\", &ServerFamily::BgSaveFb, this,\n+                           boost::intrusive_ptr<Transaction>(cntx->transaction));\n+  cntx->SendOk();\n+}\n+\n+// SAVE [DF|RDB] [basename]\n+// Allows saving the snapshot of the dataset on disk, potentially overriding the format\n+// and the snapshot name.\n+void ServerFamily::Save(CmdArgList args, ConnectionContext* cntx) {\n+  auto maybe_res = GetVersionAndBasename(args, cntx);\n+  if (!maybe_res) {\n+    return;\n+  }\n+\n+  const auto [version, basename] = *maybe_res;\n+\n+  GenericError ec = DoSave(version, basename, cntx->transaction);\n   if (ec) {\n     cntx->SendError(ec.Format());\n   } else {\n@@ -2634,7 +2688,7 @@ void ServerFamily::Register(CommandRegistry* registry) {\n   registry->StartFamily();\n   *registry\n       << CI{\"AUTH\", CO::NOSCRIPT | CO::FAST | CO::LOADING, -2, 0, 0, acl::kAuth}.HFUNC(Auth)\n-      << CI{\"BGSAVE\", CO::ADMIN | CO::GLOBAL_TRANS, 1, 0, 0, acl::kBGSave}.HFUNC(Save)\n+      << CI{\"BGSAVE\", CO::ADMIN | CO::GLOBAL_TRANS, -1, 0, 0, acl::kBGSave}.HFUNC(BgSave)\n       << CI{\"CLIENT\", CO::NOSCRIPT | CO::LOADING, -2, 0, 0, acl::kClient}.HFUNC(Client)\n       << CI{\"CONFIG\", CO::ADMIN, -2, 0, 0, acl::kConfig}.HFUNC(Config)\n       << CI{\"DBSIZE\", CO::READONLY | CO::FAST | CO::LOADING, 1, 0, 0, acl::kDbSize}.HFUNC(DbSize)\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex 15d1b0a2aa42..1003ec40ef0b 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -242,6 +242,7 @@ class ServerFamily {\n   void ReplConf(CmdArgList args, ConnectionContext* cntx);\n   void Role(CmdArgList args, ConnectionContext* cntx);\n   void Save(CmdArgList args, ConnectionContext* cntx);\n+  void BgSave(CmdArgList args, ConnectionContext* cntx);\n   void Script(CmdArgList args, ConnectionContext* cntx);\n   void SlowLog(CmdArgList args, ConnectionContext* cntx);\n   void Module(CmdArgList args, ConnectionContext* cntx);\n@@ -265,6 +266,18 @@ class ServerFamily {\n \n   void SendInvalidationMessages() const;\n \n+  // Helper function to retrieve version(true if format is dfs rdb), and basename from args.\n+  // In case of an error an empty optional is returned.\n+  using VersionBasename = std::pair<bool, std::string_view>;\n+  std::optional<VersionBasename> GetVersionAndBasename(CmdArgList args, ConnectionContext* cntx);\n+\n+  void BgSaveFb(boost::intrusive_ptr<Transaction> trans);\n+\n+  GenericError DoSaveCheckAndStart(bool new_version, string_view basename, Transaction* trans,\n+                                   bool ignore_state = false);\n+\n+  GenericError WaitUntilSaveFinished(Transaction* trans, bool ignore_state = false);\n+\n   Fiber snapshot_schedule_fb_;\n   util::fb2::Future<GenericError> load_result_;\n \n@@ -297,6 +310,9 @@ class ServerFamily {\n   std::unique_ptr<util::fb2::FiberQueueThreadPool> fq_threadpool_;\n   std::shared_ptr<detail::SnapshotStorage> snapshot_storage_;\n \n+  // protected by save_mu_\n+  util::fb2::Fiber bg_save_fb_;\n+\n   mutable util::fb2::Mutex peak_stats_mu_;\n   mutable PeakStats peak_stats_;\n };\n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 4eb323a1590b..dcd8b58e33a5 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -695,8 +695,10 @@ TEST_F(GenericFamilyTest, Info) {\n   EXPECT_EQ(1, get_rdb_changes_since_last_save(resp.GetString()));\n \n   EXPECT_EQ(Run({\"bgsave\"}), \"OK\");\n-  resp = Run({\"info\", \"persistence\"});\n-  EXPECT_EQ(0, get_rdb_changes_since_last_save(resp.GetString()));\n+  WaitUntilCondition([&]() {\n+    resp = Run({\"info\", \"persistence\"});\n+    return get_rdb_changes_since_last_save(resp.GetString()) == 0;\n+  });\n \n   EXPECT_EQ(Run({\"set\", \"k3\", \"3\"}), \"OK\");\n   resp = Run({\"info\", \"persistence\"});\ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex 13bc9380fbd7..1baa3a235a8c 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -2022,16 +2022,13 @@ async def test_saving_replica(df_local_factory):\n     async def save_replica():\n         await c_replica.execute_command(\"save\")\n \n-    async def is_saving():\n-        return \"saving:1\" in (await c_replica.execute_command(\"INFO PERSISTENCE\"))\n-\n     save_task = asyncio.create_task(save_replica())\n-    while not await is_saving():  # wait for replica start saving\n+    while not await is_saving(c_replica):  # wait for replica start saving\n         asyncio.sleep(0.1)\n     await c_replica.execute_command(\"replicaof no one\")\n-    assert await is_saving()\n+    assert await is_saving(c_replica)\n     await save_task\n-    assert not await is_saving()\n+    assert not await is_saving(c_replica)\n \n     await disconnect_clients(c_master, *[c_replica])\n \n@@ -2052,15 +2049,12 @@ async def test_start_replicating_while_save(df_local_factory):\n     async def save_replica():\n         await c_replica.execute_command(\"save\")\n \n-    async def is_saving():\n-        return \"saving:1\" in (await c_replica.execute_command(\"INFO PERSISTENCE\"))\n-\n     save_task = asyncio.create_task(save_replica())\n-    while not await is_saving():  # wait for server start saving\n+    while not await is_saving(c_replica):  # wait for server start saving\n         asyncio.sleep(0.1)\n     await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\n-    assert await is_saving()\n+    assert await is_saving(c_replica)\n     await save_task\n-    assert not await is_saving()\n+    assert not await is_saving(c_replica)\n \n     await disconnect_clients(c_master, *[c_replica])\ndiff --git a/tests/dragonfly/snapshot_test.py b/tests/dragonfly/snapshot_test.py\nindex ff21835aa5df..d775ea429dd6 100644\n--- a/tests/dragonfly/snapshot_test.py\n+++ b/tests/dragonfly/snapshot_test.py\n@@ -3,12 +3,13 @@\n import glob\n import asyncio\n import async_timeout\n+import redis\n from redis import asyncio as aioredis\n from pathlib import Path\n import boto3\n \n from . import dfly_args\n-from .utility import wait_available_async, chunked\n+from .utility import wait_available_async, chunked, is_saving\n \n from .seeder import StaticSeeder\n \n@@ -356,3 +357,22 @@ async def info_in_loop():\n     await save_task\n     save_finished = True\n     await info_task\n+\n+\n+@dfly_args({**BASIC_ARGS, \"dbfilename\": \"test-bgsave\"})\n+async def test_bgsave_and_save(async_client: aioredis.Redis):\n+    await async_client.execute_command(\"DEBUG POPULATE 20000\")\n+\n+    await async_client.execute_command(\"BGSAVE\")\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"BGSAVE\")\n+\n+    while await is_saving(async_client):\n+        await asyncio.sleep(0.1)\n+    await async_client.execute_command(\"BGSAVE\")\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"SAVE\")\n+\n+    while await is_saving(async_client):\n+        await asyncio.sleep(0.1)\n+    await async_client.execute_command(\"SAVE\")\ndiff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py\nindex b2176dad5bf3..addf9a070be3 100644\n--- a/tests/dragonfly/utility.py\n+++ b/tests/dragonfly/utility.py\n@@ -646,3 +646,7 @@ def __exit__(self, exc_type, exc_value, exc_traceback):\n                 os.environ[k] = self.undo[k]\n             else:\n                 del os.environ[k]\n+\n+\n+async def is_saving(c_client: aioredis.Redis):\n+    return \"saving:1\" in (await c_client.execute_command(\"INFO PERSISTENCE\"))\n",
  "problem_statement": "BGSAVE command don't return OK immediately\n**Describe the bug**\r\nBGSAVE and SAVE commands doesn't return OK until background operation finishes. Redis BGSAVE works this way therefore a management code written for a Redis won't work well with Dragonfly at the moment.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Run BGSAVE ~or SAVE~\r\n2. Client waits to return OK until operation in the background finishes. \r\n\r\n**Expected behavior**\r\nClient must return OK immediately for async nature of the BGSAVE command\r\n\r\n**Environment (please complete the following information):**\r\nOS: Fedora 38\r\nKernel: 6.3.12-200.fc38.x86_64\r\nContainerized?: toolbox\r\nDragonfly Version: 1.14.4\n",
  "hints_text": "@safa-topal you got me here, I wanted to create an issue :stuck_out_tongue: \nIt's indeed a behaviour difference. @safa-topal  is it possible to workaround this issue on the client side by creating an async task that calls \"BGSAVE\"?\n@kostasrim much appreciated \ud83d\ude4f\ud83c\udffb \r\n\r\n@romange yes, a workaround is possible for this (and not that urgent for my use-case because periodic save works fine and it encapsulates majority of the snapshotting logic)\r\n",
  "created_at": "2024-03-08T12:30:54Z",
  "modified_files": [
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc",
    "tests/dragonfly/replication_test.py",
    "tests/dragonfly/snapshot_test.py",
    "tests/dragonfly/utility.py"
  ]
}