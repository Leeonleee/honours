diff --git a/src/facade/facade_test.cc b/src/facade/facade_test.cc
index 78e7c325d152..48a286c4faad 100644
--- a/src/facade/facade_test.cc
+++ b/src/facade/facade_test.cc
@@ -35,6 +35,12 @@ bool RespMatcher::MatchAndExplain(const RespExpr& e, MatchResultListener* listen
       *listener << "
Actual : " << actual << " expected: " << exp_int_;
       return false;
     }
+  } else if (type_ == RespExpr::DOUBLE) {
+    auto actual = get<double>(e.u);
+    if (exp_double_ != actual) {
+      *listener << "
Actual : " << actual << " expected: " << exp_double_;
+      return false;
+    }
   } else if (type_ == RespExpr::ARRAY) {
     size_t len = get<RespVec*>(e.u)->size();
     if (len != size_t(exp_int_)) {
diff --git a/src/facade/facade_test.h b/src/facade/facade_test.h
index c0b5add9d569..929c25079335 100644
--- a/src/facade/facade_test.h
+++ b/src/facade/facade_test.h
@@ -18,6 +18,8 @@ class RespMatcher {
   RespMatcher(int64_t val, RespExpr::Type t = RespExpr::INT64) : type_(t), exp_int_(val) {
   }
 
+  RespMatcher(double_t val, RespExpr::Type t = RespExpr::DOUBLE) : type_(t), exp_double_(val) {
+  }
   using is_gtest_matcher = void;
 
   bool MatchAndExplain(const RespExpr& e, testing::MatchResultListener*) const;
@@ -31,6 +33,7 @@ class RespMatcher {
 
   std::string exp_str_;
   int64_t exp_int_;
+  double_t exp_double_;
 };
 
 class RespTypeMatcher {
@@ -58,8 +61,12 @@ inline ::testing::PolymorphicMatcher<RespMatcher> IntArg(int64_t ival) {
   return ::testing::MakePolymorphicMatcher(RespMatcher(ival));
 }
 
+inline ::testing::PolymorphicMatcher<RespMatcher> DoubleArg(double_t dval) {
+  return ::testing::MakePolymorphicMatcher(RespMatcher(dval));
+}
+
 inline ::testing::PolymorphicMatcher<RespMatcher> ArrLen(size_t len) {
-  return ::testing::MakePolymorphicMatcher(RespMatcher(len, RespExpr::ARRAY));
+  return ::testing::MakePolymorphicMatcher(RespMatcher((int64_t)len, RespExpr::ARRAY));
 }
 
 inline ::testing::PolymorphicMatcher<RespTypeMatcher> ArgType(RespExpr::Type t) {
diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc
index 1f9f74dc448b..58b42d409770 100644
--- a/src/facade/reply_builder_test.cc
+++ b/src/facade/reply_builder_test.cc
@@ -656,4 +656,100 @@ TEST_F(RedisReplyBuilderTest, TestBatchMode) {
                           absl::StrCat(kBulkStringStart, "0"), std::string_view{}));
 }
 
+TEST_F(RedisReplyBuilderTest, TestResp3Double) {
+  builder_->SetResp3(true);
+  builder_->SendDouble(5.5);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(str(), ",5.5\r
");
+}
+
+TEST_F(RedisReplyBuilderTest, TestResp3NullString) {
+  builder_->SetResp3(true);
+  builder_->SendNull();
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "_\r
");
+}
+
+TEST_F(RedisReplyBuilderTest, TestSendStringArrayAsMap) {
+  const std::vector<std::string> map_array{"k1", "v1", "k2", "v2"};
+
+  builder_->SetResp3(false);
+  builder_->SendStringArrayAsMap(map_array);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*4\r
$2\r
k1\r
$2\r
v1\r
$2\r
k2\r
$2\r
v2\r
")
+      << "SendStringArrayAsMap Resp2 Failed.";
+
+  builder_->SetResp3(true);
+  builder_->SendStringArrayAsMap(map_array);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "%2\r
$2\r
k1\r
$2\r
v1\r
$2\r
k2\r
$2\r
v2\r
")
+      << "SendStringArrayAsMap Resp3 Failed.";
+}
+
+TEST_F(RedisReplyBuilderTest, TestSendStringArrayAsSet) {
+  const std::vector<std::string> set_array{"e1", "e2", "e3"};
+
+  builder_->SetResp3(false);
+  builder_->SendStringArrayAsSet(set_array);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*3\r
$2\r
e1\r
$2\r
e2\r
$2\r
e3\r
")
+      << "SendStringArrayAsSet Resp2 Failed.";
+
+  builder_->SetResp3(true);
+  builder_->SendStringArrayAsSet(set_array);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "~3\r
$2\r
e1\r
$2\r
e2\r
$2\r
e3\r
")
+      << "SendStringArrayAsSet Resp3 Failed.";
+}
+
+TEST_F(RedisReplyBuilderTest, TestSendScoredArray) {
+  const std::vector<std::pair<std::string, double>> scored_array{
+      {"e1", 1.1}, {"e2", 2.2}, {"e3", 3.3}};
+
+  builder_->SetResp3(false);
+  builder_->SendScoredArray(scored_array, false);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*3\r
$2\r
e1\r
$2\r
e2\r
$2\r
e3\r
")
+      << "Resp2 WITHOUT scores failed.";
+
+  builder_->SetResp3(true);
+  builder_->SendScoredArray(scored_array, false);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*3\r
$2\r
e1\r
$2\r
e2\r
$2\r
e3\r
")
+      << "Resp3 WITHOUT scores failed.";
+
+  builder_->SetResp3(false);
+  builder_->SendScoredArray(scored_array, true);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(),
+            "*6\r
$2\r
e1\r
$3\r
1.1\r
$2\r
e2\r
$3\r
2.2\r
$2\r
e3\r
$3\r
3.3\r
")
+      << "Resp3 WITHSCORES failed.";
+
+  builder_->SetResp3(true);
+  builder_->SendScoredArray(scored_array, true);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(),
+            "*3\r
*2\r
$2\r
e1\r
,1.1\r
*2\r
$2\r
e2\r
,2.2\r
*2\r
$2\r
e3\r
,3.3\r
")
+      << "Resp3 WITHSCORES failed.";
+}
+
+TEST_F(RedisReplyBuilderTest, TestSendMGetResponse) {
+  std::vector<SinkReplyBuilder::OptResp> mget_res(3);
+  auto& v = mget_res[0].emplace();
+  v.value = "v1";
+  v = mget_res[2].emplace();
+  v.value = "v3";
+
+  builder_->SetResp3(false);
+  builder_->SendMGetResponse(&mget_res[0], 3);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*3\r
$2\r
v3\r
$-1\r
$0\r
\r
")
+      << "Resp2 SendMGetResponse failed.";
+
+  builder_->SetResp3(true);
+  builder_->SendMGetResponse(&mget_res[0], 3);
+  ASSERT_TRUE(builder_->err_count().empty());
+  ASSERT_EQ(TakePayload(), "*3\r
$2\r
v3\r
_\r
$0\r
\r
") << "Resp3 SendMGetResponse failed.";
+}
+
 }  // namespace facade
diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc
index 6b027083d0bb..32a115ff3bce 100644
--- a/src/server/dragonfly_test.cc
+++ b/src/server/dragonfly_test.cc
@@ -228,10 +228,15 @@ TEST_F(DflyEngineTest, Hello) {
                           ArgType(RespExpr::STRING), "proto", IntArg(2), "id",
                           ArgType(RespExpr::INT64), "mode", "standalone", "role", "master"));
 
+  resp = Run({"hello", "3"});
+  ASSERT_THAT(resp, ArrLen(14));
+  EXPECT_THAT(resp.GetVec(),
+              ElementsAre("server", "redis", "version", "6.2.11", "dfly_version",
+                          ArgType(RespExpr::STRING), "proto", IntArg(3), "id",
+                          ArgType(RespExpr::INT64), "mode", "standalone", "role", "master"));
+
   // These are valid arguments to HELLO, however as they are not yet supported the implementation
   // is degraded to 'unknown command'.
-  EXPECT_THAT(Run({"hello", "3"}),
-              ErrArg("ERR unknown command 'HELLO' with args beginning with: `3`"));
   EXPECT_THAT(
       Run({"hello", "2", "AUTH", "uname", "pwd"}),
       ErrArg("ERR unknown command 'HELLO' with args beginning with: `2`, `AUTH`, `uname`, `pwd`"));
diff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc
index 80d0980cac50..e281e58e5306 100644
--- a/src/server/hset_family_test.cc
+++ b/src/server/hset_family_test.cc
@@ -27,6 +27,14 @@ class HSetFamilyTest : public BaseFamilyTest {
  protected:
 };
 
+class HestFamilyTestProtocolVersioned : public HSetFamilyTest,
+                                        public ::testing::WithParamInterface<string> {
+ protected:
+};
+
+INSTANTIATE_TEST_CASE_P(HestFamilyTestProtocolVersioned, HestFamilyTestProtocolVersioned,
+                        ::testing::Values("2", "3"));
+
 TEST_F(HSetFamilyTest, Hash) {
   robj* obj = createHashObject();
   sds field = sdsnew("field");
@@ -70,8 +78,12 @@ TEST_F(HSetFamilyTest, HSet) {
   EXPECT_EQ(1, CheckedInt({"hset", "small", "", "565323349817"}));
 }
 
-TEST_F(HSetFamilyTest, Get) {
-  auto resp = Run({"hset", "x", "a", "1", "b", "2", "c", "3"});
+TEST_P(HestFamilyTestProtocolVersioned, Get) {
+  auto resp = Run({"hello", GetParam()});
+  EXPECT_THAT(resp.GetVec()[6], "proto");
+  EXPECT_THAT(resp.GetVec()[7], IntArg(atoi(GetParam().c_str())));
+
+  resp = Run({"hset", "x", "a", "1", "b", "2", "c", "3"});
   EXPECT_THAT(resp, IntArg(3));
 
   resp = Run({"hmget", "unkwn", "a", "c"});
diff --git a/src/server/string_family_test.cc b/src/server/string_family_test.cc
index d38e4e837997..e61df22ad7f0 100644
--- a/src/server/string_family_test.cc
+++ b/src/server/string_family_test.cc
@@ -663,4 +663,14 @@ TEST_F(StringFamilyTest, ClThrottle) {
   EXPECT_THAT(resp, ErrArg(kInvalidIntErr));
 }
 
+TEST_F(StringFamilyTest, SetMGetWithNilResp3) {
+  Run({"hello", "3"});
+
+  EXPECT_EQ(Run({"set", "key", "val"}), "OK");
+  EXPECT_EQ(Run({"get", "key"}), "val");
+  RespExpr resp = Run({"mget", "key", "nonexist"});
+  ASSERT_EQ(RespExpr::ARRAY, resp.type);
+  EXPECT_THAT(resp.GetVec(), ElementsAre("val", ArgType(RespExpr::NIL)));
+}
+
 }  // namespace dfly
diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc
index 06dbb0fa760c..da6fa0abbdc5 100644
--- a/src/server/zset_family_test.cc
+++ b/src/server/zset_family_test.cc
@@ -477,4 +477,14 @@ TEST_F(ZSetFamilyTest, ZPopMax) {
   resp = Run({"zpopmax", "key", "1"});
   ASSERT_THAT(resp, ArrLen(0));
 }
+
+TEST_F(ZSetFamilyTest, Resp3) {
+  Run({"hello", "3"});
+  Run({"zadd", "x", "1", "a", "2", "b"});
+  auto resp = Run({"zrange", "x", "0", "-1", "WITHSCORES"});
+  ASSERT_THAT(resp, ArrLen(2));
+  ASSERT_THAT(resp.GetVec()[0].GetVec(), ElementsAre("a", DoubleArg(1)));
+  ASSERT_THAT(resp.GetVec()[1].GetVec(), ElementsAre("b", DoubleArg(2)));
+}
+
 }  // namespace dfly
