{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1741,
  "instance_id": "dragonflydb__dragonfly-1741",
  "issue_numbers": [
    "1700"
  ],
  "base_commit": "35a5433aac557e9f7c55f1f26bb243cde4f7573e",
  "patch": "diff --git a/src/facade/conn_context.h b/src/facade/conn_context.h\nindex c530f51d58a3..a6070dcd93c7 100644\n--- a/src/facade/conn_context.h\n+++ b/src/facade/conn_context.h\n@@ -37,6 +37,8 @@ class ConnectionContext {\n   }\n \n   // A convenient proxy for redis interface.\n+  // Use with caution -- should only be used only\n+  // in execution paths that are Redis *only*\n   RedisReplyBuilder* operator->();\n \n   SinkReplyBuilder* reply_builder() {\n@@ -50,6 +52,18 @@ class ConnectionContext {\n     return res;\n   }\n \n+  void SendError(std::string_view str, std::string_view type = std::string_view{}) {\n+    rbuilder_->SendError(str, type);\n+  }\n+\n+  void SendError(ErrorReply&& error) {\n+    rbuilder_->SendError(std::move(error));\n+  }\n+\n+  void SendSimpleString(std::string_view str) {\n+    rbuilder_->SendSimpleString(str);\n+  }\n+\n   // connection state / properties.\n   bool conn_closing : 1;\n   bool req_auth : 1;\ndiff --git a/src/facade/op_status.cc b/src/facade/op_status.cc\nindex 778e4a53be81..6441a2ba797d 100644\n--- a/src/facade/op_status.cc\n+++ b/src/facade/op_status.cc\n@@ -1,3 +1,37 @@\n #include \"facade/op_status.h\"\n \n-namespace facade {}  // namespace facade\n+#include \"base/logging.h\"\n+#include \"facade/error.h\"\n+#include \"facade/resp_expr.h\"\n+\n+namespace facade {\n+\n+std::string_view StatusToMsg(OpStatus status) {\n+  switch (status) {\n+    case OpStatus::OK:\n+      return \"OK\";\n+    case OpStatus::KEY_NOTFOUND:\n+      return kKeyNotFoundErr;\n+    case OpStatus::WRONG_TYPE:\n+      return kWrongTypeErr;\n+    case OpStatus::OUT_OF_RANGE:\n+      return kIndexOutOfRange;\n+    case OpStatus::INVALID_FLOAT:\n+      return kInvalidFloatErr;\n+    case OpStatus::INVALID_INT:\n+      return kInvalidIntErr;\n+    case OpStatus::SYNTAX_ERR:\n+      return kSyntaxErr;\n+    case OpStatus::OUT_OF_MEMORY:\n+      return kOutOfMemory;\n+    case OpStatus::BUSY_GROUP:\n+      return \"-BUSYGROUP Consumer Group name already exists\";\n+    case OpStatus::INVALID_NUMERIC_RESULT:\n+      return kInvalidNumericResult;\n+    default:\n+      LOG(ERROR) << \"Unsupported status \" << status;\n+      return \"Internal error\";\n+  }\n+}\n+\n+}  // namespace facade\ndiff --git a/src/facade/op_status.h b/src/facade/op_status.h\nindex ef9e54814b6a..0f175afc208c 100644\n--- a/src/facade/op_status.h\n+++ b/src/facade/op_status.h\n@@ -124,6 +124,8 @@ inline bool operator==(OpStatus st, const OpResultBase& ob) {\n   return ob.operator==(st);\n }\n \n+std::string_view StatusToMsg(OpStatus status);\n+\n }  // namespace facade\n \n namespace std {\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex ff85248782f5..5ca3955f911f 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -94,6 +94,22 @@ void SinkReplyBuilder::SendRaw(std::string_view raw) {\n   Send(&v, 1);\n }\n \n+void SinkReplyBuilder::SendError(ErrorReply error) {\n+  if (error.status)\n+    return SendError(*error.status);\n+\n+  string_view message_sv = visit([](auto&& str) -> string_view { return str; }, error.message);\n+  SendError(message_sv, error.kind);\n+}\n+\n+void SinkReplyBuilder::SendError(OpStatus status) {\n+  if (status == OpStatus::OK) {\n+    SendOk();\n+  } else {\n+    SendError(StatusToMsg(status));\n+  }\n+}\n+\n void SinkReplyBuilder::SendRawVec(absl::Span<const std::string_view> msg_vec) {\n   absl::FixedArray<iovec, 16> arr(msg_vec.size());\n \n@@ -223,14 +239,6 @@ void RedisReplyBuilder::SendError(string_view str, string_view err_type) {\n   }\n }\n \n-void RedisReplyBuilder::SendError(ErrorReply error) {\n-  if (error.status)\n-    return SendError(*error.status);\n-\n-  string_view message_sv = visit([](auto&& str) -> string_view { return str; }, error.message);\n-  SendError(message_sv, error.kind);\n-}\n-\n void RedisReplyBuilder::SendProtocolError(std::string_view str) {\n   SendError(absl::StrCat(\"-ERR Protocol error: \", str), \"protocol_error\");\n }\n@@ -277,42 +285,6 @@ void RedisReplyBuilder::SendBulkString(std::string_view str) {\n   return Send(v, ABSL_ARRAYSIZE(v));\n }\n \n-std::string_view RedisReplyBuilder::StatusToMsg(OpStatus status) {\n-  switch (status) {\n-    case OpStatus::OK:\n-      return \"OK\";\n-    case OpStatus::KEY_NOTFOUND:\n-      return kKeyNotFoundErr;\n-    case OpStatus::WRONG_TYPE:\n-      return kWrongTypeErr;\n-    case OpStatus::OUT_OF_RANGE:\n-      return kIndexOutOfRange;\n-    case OpStatus::INVALID_FLOAT:\n-      return kInvalidFloatErr;\n-    case OpStatus::INVALID_INT:\n-      return kInvalidIntErr;\n-    case OpStatus::SYNTAX_ERR:\n-      return kSyntaxErr;\n-    case OpStatus::OUT_OF_MEMORY:\n-      return kOutOfMemory;\n-    case OpStatus::BUSY_GROUP:\n-      return \"-BUSYGROUP Consumer Group name already exists\";\n-    case OpStatus::INVALID_NUMERIC_RESULT:\n-      return kInvalidNumericResult;\n-    default:\n-      LOG(ERROR) << \"Unsupported status \" << status;\n-      return \"Internal error\";\n-  }\n-}\n-\n-void RedisReplyBuilder::SendError(OpStatus status) {\n-  if (status == OpStatus::OK) {\n-    SendOk();\n-  } else {\n-    SendError(StatusToMsg(status));\n-  }\n-}\n-\n void RedisReplyBuilder::SendLong(long num) {\n   string str = absl::StrCat(\":\", num, kCRLF);\n   SendRaw(str);\ndiff --git a/src/facade/reply_builder.h b/src/facade/reply_builder.h\nindex dc15172f214a..3634789e109b 100644\n--- a/src/facade/reply_builder.h\n+++ b/src/facade/reply_builder.h\n@@ -42,6 +42,8 @@ class SinkReplyBuilder {\n   }\n \n   virtual void SendError(std::string_view str, std::string_view type = {}) = 0;  // MC and Redis\n+  virtual void SendError(ErrorReply error);\n+  virtual void SendError(OpStatus status);\n \n   virtual void SendStored() = 0;  // Reply for set commands.\n   virtual void SendSetSkipped() = 0;\n@@ -177,13 +179,12 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n   void SetResp3(bool is_resp3);\n \n   void SendError(std::string_view str, std::string_view type = {}) override;\n-  virtual void SendError(ErrorReply error);\n+  using SinkReplyBuilder::SendError;\n \n   void SendMGetResponse(absl::Span<const OptResp>) override;\n \n   void SendStored() override;\n   void SendSetSkipped() override;\n-  virtual void SendError(OpStatus status);\n   void SendProtocolError(std::string_view str) override;\n \n   virtual void SendNullArray();   // Send *-1\n@@ -206,10 +207,6 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n \n   static char* FormatDouble(double val, char* dest, unsigned dest_len);\n \n-  // You normally should not call this - maps the status\n-  // into the string that would be sent\n-  static std::string_view StatusToMsg(OpStatus status);\n-\n  protected:\n   struct WrappedStrSpan : public StrSpan {\n     size_t Size() const;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 1b83f4af21fb..bfd61e0126d5 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -879,7 +879,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n   const auto [cid, args_no_cmd] = FindCmd(args);\n \n   if (cid == nullptr) {\n-    return (*cntx)->SendError(ReportUnknownCmd(ArgS(args, 0)));\n+    return cntx->SendError(ReportUnknownCmd(ArgS(args, 0)));\n   }\n \n   ConnectionContext* dfly_cntx = static_cast<ConnectionContext*>(cntx);\n@@ -899,7 +899,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n     if (auto& exec_info = dfly_cntx->conn_state.exec_info; exec_info.IsCollecting())\n       exec_info.state = ConnectionState::ExecInfo::EXEC_ERROR;\n \n-    (*dfly_cntx)->SendError(std::move(*err));\n+    dfly_cntx->SendError(std::move(*err));\n     return;\n   }\n \n@@ -909,13 +909,13 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n     StoredCmd stored_cmd{cid, args_no_cmd};\n     dfly_cntx->conn_state.exec_info.body.push_back(std::move(stored_cmd));\n \n-    return (*cntx)->SendSimpleString(\"QUEUED\");\n+    return cntx->SendSimpleString(\"QUEUED\");\n   }\n \n   uint64_t start_ns = absl::GetCurrentTimeNanos();\n \n   if (cid->opt_mask() & CO::DENYOOM) {\n-    int64_t used_memory = etl.GetUsedMemory(start_ns);\n+    uint64_t used_memory = etl.GetUsedMemory(start_ns);\n     double oom_deny_ratio = GetFlag(FLAGS_oom_deny_ratio);\n     if (used_memory > (max_memory_limit * oom_deny_ratio)) {\n       return cntx->reply_builder()->SendError(kOutOfMemory);\n",
  "test_patch": "diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc\nindex 8b2b297be84d..95aa045d3326 100644\n--- a/src/facade/reply_builder_test.cc\n+++ b/src/facade/reply_builder_test.cc\n@@ -232,7 +232,7 @@ TEST_F(RedisReplyBuilderTest, ErrorBuiltInMessage) {\n       OpStatus::OUT_OF_MEMORY, OpStatus::INVALID_FLOAT, OpStatus::INVALID_INT,\n       OpStatus::SYNTAX_ERR,    OpStatus::BUSY_GROUP,    OpStatus::INVALID_NUMERIC_RESULT};\n   for (const auto& err : error_codes) {\n-    const std::string_view error_name = RedisReplyBuilder::StatusToMsg(err);\n+    const std::string_view error_name = StatusToMsg(err);\n     const std::string_view error_type = GetErrorType(error_name);\n \n     sink_.Clear();\n@@ -251,6 +251,31 @@ TEST_F(RedisReplyBuilderTest, ErrorBuiltInMessage) {\n   }\n }\n \n+TEST_F(RedisReplyBuilderTest, ErrorReplyBuiltInMessage) {\n+  ErrorReply err{OpStatus::OUT_OF_RANGE};\n+  builder_->SendError(err);\n+  ASSERT_TRUE(absl::StartsWith(str(), kErrorStart));\n+  ASSERT_TRUE(absl::EndsWith(str(), kCRLF));\n+  ASSERT_EQ(builder_->err_count().at(kIndexOutOfRange), 1);\n+  ASSERT_EQ(str(), BuildExpectedErrorString(kIndexOutOfRange));\n+\n+  auto parsing_output = Parse();\n+  ASSERT_TRUE(parsing_output.Verify(SinkSize()));\n+  ASSERT_TRUE(parsing_output.IsError());\n+  sink_.Clear();\n+\n+  err = ErrorReply{\"e1\", \"e2\"};\n+  builder_->SendError(err);\n+  ASSERT_TRUE(absl::StartsWith(str(), kErrorStart));\n+  ASSERT_TRUE(absl::EndsWith(str(), kCRLF));\n+  ASSERT_EQ(builder_->err_count().at(\"e2\"), 1);\n+  ASSERT_EQ(str(), BuildExpectedErrorString(\"e1\"));\n+\n+  parsing_output = Parse();\n+  ASSERT_TRUE(parsing_output.Verify(SinkSize()));\n+  ASSERT_TRUE(parsing_output.IsError());\n+}\n+\n TEST_F(RedisReplyBuilderTest, ErrorNoneBuiltInMessage) {\n   // All these op codes creating the same error message\n   OpStatus none_unique_codes[] = {OpStatus::ENTRIES_ADDED_SMALL, OpStatus::SKIPPED,\n@@ -258,7 +283,7 @@ TEST_F(RedisReplyBuilderTest, ErrorNoneBuiltInMessage) {\n                                   OpStatus::TIMED_OUT,           OpStatus::STREAM_ID_SMALL};\n   uint64_t error_count = 0;\n   for (const auto& err : none_unique_codes) {\n-    const std::string_view error_name = RedisReplyBuilder::StatusToMsg(err);\n+    const std::string_view error_name = StatusToMsg(err);\n     const std::string_view error_type = GetErrorType(error_name);\n \n     sink_.Clear();\ndiff --git a/tests/dragonfly/__init__.py b/tests/dragonfly/__init__.py\nindex 5f4559009f9a..9d1c47c3e88b 100644\n--- a/tests/dragonfly/__init__.py\n+++ b/tests/dragonfly/__init__.py\n@@ -106,7 +106,7 @@ def admin_port(self) -> int:\n     def mc_port(self) -> int:\n         if self.params.existing_mc_port:\n             return self.params.existing_mc_port\n-        return int(self.args.get(\"mc_port\", \"11211\"))\n+        return int(self.args.get(\"memcached_port\", \"11211\"))\n \n     @staticmethod\n     def format_args(args):\ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex eda47b5cb27d..5ce59f229c49 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -7,6 +7,7 @@\n from redis import asyncio as aioredis\n from .utility import *\n from . import DflyInstanceFactory, dfly_args\n+import pymemcache\n import logging\n \n BASE_PORT = 1111\n@@ -1506,3 +1507,37 @@ async def test_replicaof_flag_disconnect(df_local_factory):\n \n     role = await c_replica.role()\n     assert role[0] == b\"master\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_df_crash_on_memcached_error(df_local_factory):\n+    master = df_local_factory.create(\n+        port=BASE_PORT,\n+        memcached_port=11211,\n+        proactor_threads=2,\n+    )\n+\n+    replica = df_local_factory.create(\n+        port=master.port + 1,\n+        memcached_port=master.mc_port + 1,\n+        proactor_threads=2,\n+    )\n+\n+    master.start()\n+    replica.start()\n+\n+    c_master = aioredis.Redis(port=master.port)\n+    await wait_available_async(c_master)\n+\n+    c_replica = aioredis.Redis(port=replica.port)\n+    await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\n+    await wait_available_async(c_replica)\n+    await wait_for_replica_status(c_replica, status=\"up\")\n+    await c_replica.close()\n+\n+    memcached_client = pymemcache.Client(f\"localhost:{replica.mc_port}\")\n+\n+    with pytest.raises(pymemcache.exceptions.MemcacheClientError):\n+        memcached_client.set(b\"key\", b\"data\", noreply=False)\n+\n+    await c_master.close()\n",
  "problem_statement": "config get command support\nDue to the difference from the underlying architecture of redis, some previous config commands may not be fully supported, but can you have a complete display of the configurable items of dragonfly, similar to the function of `config get *`. From the user's point of view, I just don't know which configs can be configured and which ones can't. After all, I have transitioned from redis before, and some usage habits need to be adapted. \r\n\r\nI hope there will be a clear display of our configurable config items.\r\n<img width=\"530\" alt=\"image\" src=\"https://github.com/dragonflydb/dragonfly/assets/8543659/69a69fc8-518c-4e5a-9bae-949c8e1d6ff2\">\n",
  "hints_text": "@boomballa  why did you close it?\n@romange  Thanks for reopening.\r\nI heard it said yesterday that for the monitoring level of dragonfly, the monitoring items should be as streamlined as possible, and some important indicators should be kept. I don't know if there is something wrong with my understanding\r\n,I thought we had no plans to build this, so i closed it first.  \ud83d\ude2c\r\n\r\nIn fact, our current requirement is that if we want to use dragonfly, we need to modify it according to the python script monitored by redis before. If there are some important indicators in config get, it may be relatively troublesome to modify. So if we don't have a plan, we plan to try the grafana way first. The reason why we do not give priority to using grafana to collect monitoring information is that we have our own monitoring system. If we use grafana, there will be two sets of monitoring and alarm systems. The monitoring data collection caliber is not uniform, which will cause this problem.",
  "created_at": "2023-08-25T09:18:49Z",
  "modified_files": [
    "src/facade/conn_context.h",
    "src/facade/op_status.cc",
    "src/facade/op_status.h",
    "src/facade/reply_builder.cc",
    "src/facade/reply_builder.h",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "src/facade/reply_builder_test.cc",
    "tests/dragonfly/__init__.py",
    "tests/dragonfly/replication_test.py"
  ]
}