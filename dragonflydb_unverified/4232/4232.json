{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4232,
  "instance_id": "dragonflydb__dragonfly-4232",
  "issue_numbers": [
    "3631"
  ],
  "base_commit": "01f24da2b68575ab9ca7c2584f44fb05910ad923",
  "patch": "diff --git a/src/server/search/aggregator.cc b/src/server/search/aggregator.cc\nindex 09ccb841eafa..28d943c21499 100644\n--- a/src/server/search/aggregator.cc\n+++ b/src/server/search/aggregator.cc\n@@ -65,9 +65,9 @@ void Aggregator::DoGroup(absl::Span<const std::string> fields, absl::Span<const\n   }\n }\n \n-void Aggregator::DoSort(std::string_view field, bool descending) {\n+void Aggregator::DoSort(const SortParams& sort_params) {\n   /*\n-    Comparator for sorting DocValues by field.\n+    Comparator for sorting DocValues by fields.\n     If some of the fields is not present in the DocValues, comparator returns:\n     1. l_it == l.end() && r_it != r.end()\n       asc -> false\n@@ -80,22 +80,41 @@ void Aggregator::DoSort(std::string_view field, bool descending) {\n       desc -> false\n   */\n   auto comparator = [&](const DocValues& l, const DocValues& r) {\n-    auto l_it = l.find(field);\n-    auto r_it = r.find(field);\n-\n-    // If some of the values is not present\n-    if (l_it == l.end() || r_it == r.end()) {\n-      return l_it != l.end();\n+    for (const auto& [field, order] : sort_params.fields) {\n+      auto l_it = l.find(field);\n+      auto r_it = r.find(field);\n+\n+      // If some of the values is not present\n+      if (l_it == l.end() || r_it == r.end()) {\n+        if (l_it == l.end() && r_it == r.end()) {\n+          continue;\n+        }\n+        return l_it != l.end();\n+      }\n+\n+      const auto& lv = l_it->second;\n+      const auto& rv = r_it->second;\n+      if (lv == rv) {\n+        continue;\n+      }\n+      return order == SortParams::SortOrder::ASC ? lv < rv : lv > rv;\n     }\n-\n-    auto& lv = l_it->second;\n-    auto& rv = r_it->second;\n-    return !descending ? lv < rv : lv > rv;\n+    return false;\n   };\n \n-  std::sort(result.values.begin(), result.values.end(), std::move(comparator));\n+  auto& values = result.values;\n+  if (sort_params.SortAll()) {\n+    std::sort(values.begin(), values.end(), comparator);\n+  } else {\n+    DCHECK_GE(sort_params.max, 0);\n+    const size_t limit = std::min(values.size(), size_t(sort_params.max));\n+    std::partial_sort(values.begin(), values.begin() + limit, values.end(), comparator);\n+    values.resize(limit);\n+  }\n \n-  result.fields_to_print.insert(field);\n+  for (auto& field : sort_params.fields) {\n+    result.fields_to_print.insert(field.first);\n+  }\n }\n \n void Aggregator::DoLimit(size_t offset, size_t num) {\n@@ -152,10 +171,8 @@ AggregationStep MakeGroupStep(std::vector<std::string> fields, std::vector<Reduc\n   };\n }\n \n-AggregationStep MakeSortStep(std::string field, bool descending) {\n-  return [field = std::move(field), descending](Aggregator* aggregator) {\n-    aggregator->DoSort(field, descending);\n-  };\n+AggregationStep MakeSortStep(SortParams sort_params) {\n+  return [params = std::move(sort_params)](Aggregator* aggregator) { aggregator->DoSort(params); };\n }\n \n AggregationStep MakeLimitStep(size_t offset, size_t num) {\ndiff --git a/src/server/search/aggregator.h b/src/server/search/aggregator.h\nindex a298735182f4..fe4dbbfe237a 100644\n--- a/src/server/search/aggregator.h\n+++ b/src/server/search/aggregator.h\n@@ -33,9 +33,27 @@ struct AggregationResult {\n   absl::flat_hash_set<std::string_view> fields_to_print;\n };\n \n+struct SortParams {\n+  enum class SortOrder { ASC, DESC };\n+\n+  constexpr static int64_t kSortAll = -1;\n+\n+  bool SortAll() const {\n+    return max == kSortAll;\n+  }\n+\n+  /* Fields to sort by. If multiple fields are provided, sorting works hierarchically:\n+     - First, the i-th field is compared.\n+     - If the i-th field values are equal, the (i + 1)-th field is compared, and so on. */\n+  absl::InlinedVector<std::pair<std::string, SortOrder>, 2> fields;\n+  /* Max number of elements to include in the sorted result.\n+     If set, only the first [max] elements are fully sorted using partial_sort. */\n+  int64_t max = kSortAll;\n+};\n+\n struct Aggregator {\n   void DoGroup(absl::Span<const std::string> fields, absl::Span<const Reducer> reducers);\n-  void DoSort(std::string_view field, bool descending = false);\n+  void DoSort(const SortParams& sort_params);\n   void DoLimit(size_t offset, size_t num);\n \n   AggregationResult result;\n@@ -94,7 +112,7 @@ Reducer::Func FindReducerFunc(ReducerFunc name);\n AggregationStep MakeGroupStep(std::vector<std::string> fields, std::vector<Reducer> reducers);\n \n // Make `SORTBY field [DESC]` step\n-AggregationStep MakeSortStep(std::string field, bool descending = false);\n+AggregationStep MakeSortStep(SortParams sort_params);\n \n // Make `LIMIT offset num` step\n AggregationStep MakeLimitStep(size_t offset, size_t num);\ndiff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 6547642310f4..f7c9c8de47a4 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -306,6 +306,42 @@ optional<SearchParams> ParseSearchParamsOrReply(CmdArgParser* parser, SinkReplyB\n   return params;\n }\n \n+std::optional<aggregate::SortParams> ParseAggregatorSortParams(CmdArgParser* parser) {\n+  using SordOrder = aggregate::SortParams::SortOrder;\n+\n+  size_t strings_num = parser->Next<size_t>();\n+\n+  aggregate::SortParams sort_params;\n+  sort_params.fields.reserve(strings_num / 2);\n+\n+  while (parser->HasNext() && strings_num > 0) {\n+    // TODO: Throw an error if the field has no '@' sign at the beginning\n+    std::string_view parsed_field = ParseFieldWithAtSign(parser);\n+    strings_num--;\n+\n+    SordOrder sord_order = SordOrder::ASC;\n+    if (strings_num > 0) {\n+      auto order = parser->TryMapNext(\"ASC\", SordOrder::ASC, \"DESC\", SordOrder::DESC);\n+      if (order) {\n+        sord_order = order.value();\n+        strings_num--;\n+      }\n+    }\n+\n+    sort_params.fields.emplace_back(parsed_field, sord_order);\n+  }\n+\n+  if (strings_num) {\n+    return std::nullopt;\n+  }\n+\n+  if (parser->Check(\"MAX\")) {\n+    sort_params.max = parser->Next<size_t>();\n+  }\n+\n+  return sort_params;\n+}\n+\n optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n                                                        SinkReplyBuilder* builder) {\n   AggregateParams params;\n@@ -372,11 +408,13 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n \n     // SORTBY nargs\n     if (parser.Check(\"SORTBY\")) {\n-      parser.ExpectTag(\"1\");\n-      string_view field = parser.Next();\n-      bool desc = bool(parser.Check(\"DESC\"));\n+      auto sort_params = ParseAggregatorSortParams(&parser);\n+      if (!sort_params) {\n+        builder->SendError(\"bad arguments for SORTBY: specified invalid number of strings\");\n+        return nullopt;\n+      }\n \n-      params.steps.push_back(aggregate::MakeSortStep(std::string{field}, desc));\n+      params.steps.push_back(aggregate::MakeSortStep(std::move(sort_params).value()));\n       continue;\n     }\n \n",
  "test_patch": "diff --git a/src/server/search/aggregator_test.cc b/src/server/search/aggregator_test.cc\nindex a9f9544ce3b7..a0adaffee309 100644\n--- a/src/server/search/aggregator_test.cc\n+++ b/src/server/search/aggregator_test.cc\n@@ -18,7 +18,10 @@ TEST(AggregatorTest, Sort) {\n       DocValues{{\"a\", 0.5}},\n       DocValues{{\"a\", 1.5}},\n   };\n-  StepsList steps = {MakeSortStep(\"a\", false)};\n+\n+  SortParams params;\n+  params.fields.emplace_back(\"a\", SortParams::SortOrder::ASC);\n+  StepsList steps = {MakeSortStep(std::move(params))};\n \n   auto result = Process(values, {\"a\"}, steps);\n \ndiff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex 6aefe955a154..b759380d2326 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -1668,4 +1668,149 @@ TEST_F(SearchFamilyTest, AggregateResultFields) {\n                                          IsMap(), IsMap()));\n }\n \n+TEST_F(SearchFamilyTest, AggregateSortByJson) {\n+  Run({\"JSON.SET\", \"j1\", \"$\", R\"({\"name\": \"first\", \"number\": 1200, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j2\", \"$\", R\"({\"name\": \"second\", \"number\": 800, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j3\", \"$\", R\"({\"name\": \"third\", \"number\": 300, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j4\", \"$\", R\"({\"name\": \"fourth\", \"number\": 400, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j5\", \"$\", R\"({\"name\": \"fifth\", \"number\": 900, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j6\", \"$\", R\"({\"name\": \"sixth\", \"number\": 300, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j7\", \"$\", R\"({\"name\": \"seventh\", \"number\": 400, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j8\", \"$\", R\"({\"name\": \"eighth\", \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j9\", \"$\", R\"({\"name\": \"ninth\", \"group\": \"second\"})\"});\n+\n+  Run({\"FT.CREATE\", \"index\", \"ON\", \"JSON\", \"SCHEMA\", \"$.name\", \"AS\", \"name\", \"TEXT\", \"$.number\",\n+       \"AS\", \"number\", \"NUMERIC\", \"$.group\", \"AS\", \"group\", \"TAG\"});\n+\n+  // Test sorting by name (DESC) and number (ASC)\n+  auto resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"4\", \"@name\", \"DESC\", \"@number\", \"ASC\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(\n+                        IsMap(\"name\", \"\\\"third\\\"\", \"number\", \"300\"),\n+                        IsMap(\"name\", \"\\\"sixth\\\"\", \"number\", \"300\"),\n+                        IsMap(\"name\", \"\\\"seventh\\\"\", \"number\", \"400\"),\n+                        IsMap(\"name\", \"\\\"second\\\"\", \"number\", \"800\"), IsMap(\"name\", \"\\\"ninth\\\"\"),\n+                        IsMap(\"name\", \"\\\"fourth\\\"\", \"number\", \"400\"),\n+                        IsMap(\"name\", \"\\\"first\\\"\", \"number\", \"1200\"),\n+                        IsMap(\"name\", \"\\\"fifth\\\"\", \"number\", \"900\"), IsMap(\"name\", \"\\\"eighth\\\"\")));\n+\n+  // Test sorting by name (ASC) and number (DESC)\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"4\", \"@name\", \"ASC\", \"@number\", \"DESC\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(\n+                        IsMap(\"name\", \"\\\"eighth\\\"\"), IsMap(\"name\", \"\\\"fifth\\\"\", \"number\", \"900\"),\n+                        IsMap(\"name\", \"\\\"first\\\"\", \"number\", \"1200\"),\n+                        IsMap(\"name\", \"\\\"fourth\\\"\", \"number\", \"400\"), IsMap(\"name\", \"\\\"ninth\\\"\"),\n+                        IsMap(\"name\", \"\\\"second\\\"\", \"number\", \"800\"),\n+                        IsMap(\"name\", \"\\\"seventh\\\"\", \"number\", \"400\"),\n+                        IsMap(\"name\", \"\\\"sixth\\\"\", \"number\", \"300\"),\n+                        IsMap(\"name\", \"\\\"third\\\"\", \"number\", \"300\")));\n+\n+  // Test sorting by group (ASC), number (DESC), and name\n+  resp = Run(\n+      {\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"5\", \"@group\", \"ASC\", \"@number\", \"DESC\", \"@name\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"number\", \"1200\", \"name\", \"\\\"first\\\"\"),\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"number\", \"800\", \"name\", \"\\\"second\\\"\"),\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"number\", \"300\", \"name\", \"\\\"sixth\\\"\"),\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"number\", \"300\", \"name\", \"\\\"third\\\"\"),\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"name\", \"\\\"eighth\\\"\"),\n+                        IsMap(\"group\", \"\\\"second\\\"\", \"number\", \"900\", \"name\", \"\\\"fifth\\\"\"),\n+                        IsMap(\"group\", \"\\\"second\\\"\", \"number\", \"400\", \"name\", \"\\\"fourth\\\"\"),\n+                        IsMap(\"group\", \"\\\"second\\\"\", \"number\", \"400\", \"name\", \"\\\"seventh\\\"\"),\n+                        IsMap(\"group\", \"\\\"second\\\"\", \"name\", \"\\\"ninth\\\"\")));\n+\n+  // Test sorting by number (ASC), group (DESC), and name\n+  resp = Run(\n+      {\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"5\", \"@number\", \"ASC\", \"@group\", \"DESC\", \"@name\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(\n+                        IsMap(\"number\", \"300\", \"group\", \"\\\"first\\\"\", \"name\", \"\\\"sixth\\\"\"),\n+                        IsMap(\"number\", \"300\", \"group\", \"\\\"first\\\"\", \"name\", \"\\\"third\\\"\"),\n+                        IsMap(\"number\", \"400\", \"group\", \"\\\"second\\\"\", \"name\", \"\\\"fourth\\\"\"),\n+                        IsMap(\"number\", \"400\", \"group\", \"\\\"second\\\"\", \"name\", \"\\\"seventh\\\"\"),\n+                        IsMap(\"number\", \"800\", \"group\", \"\\\"first\\\"\", \"name\", \"\\\"second\\\"\"),\n+                        IsMap(\"number\", \"900\", \"group\", \"\\\"second\\\"\", \"name\", \"\\\"fifth\\\"\"),\n+                        IsMap(\"number\", \"1200\", \"group\", \"\\\"first\\\"\", \"name\", \"\\\"first\\\"\"),\n+                        IsMap(\"group\", \"\\\"second\\\"\", \"name\", \"\\\"ninth\\\"\"),\n+                        IsMap(\"group\", \"\\\"first\\\"\", \"name\", \"\\\"eighth\\\"\")));\n+\n+  // Test sorting with MAX 3\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@number\", \"MAX\", \"3\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"number\", \"300\"), IsMap(\"number\", \"300\"),\n+                                         IsMap(\"number\", \"400\")));\n+\n+  // Test sorting with MAX 3\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"2\", \"@number\", \"DESC\", \"MAX\", \"3\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"number\", \"1200\"), IsMap(\"number\", \"900\"),\n+                                         IsMap(\"number\", \"800\")));\n+\n+  // Test sorting by number (ASC) with MAX 999\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@number\", \"MAX\", \"999\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"number\", \"300\"), IsMap(\"number\", \"300\"),\n+                                         IsMap(\"number\", \"400\"), IsMap(\"number\", \"400\"),\n+                                         IsMap(\"number\", \"800\"), IsMap(\"number\", \"900\"),\n+                                         IsMap(\"number\", \"1200\"), IsMap(), IsMap()));\n+\n+  // Test sorting by name and number (DESC)\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"3\", \"@name\", \"@number\", \"DESC\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(\n+                        IsMap(\"name\", \"\\\"eighth\\\"\"), IsMap(\"name\", \"\\\"fifth\\\"\", \"number\", \"900\"),\n+                        IsMap(\"name\", \"\\\"first\\\"\", \"number\", \"1200\"),\n+                        IsMap(\"name\", \"\\\"fourth\\\"\", \"number\", \"400\"), IsMap(\"name\", \"\\\"ninth\\\"\"),\n+                        IsMap(\"name\", \"\\\"second\\\"\", \"number\", \"800\"),\n+                        IsMap(\"name\", \"\\\"seventh\\\"\", \"number\", \"400\"),\n+                        IsMap(\"name\", \"\\\"sixth\\\"\", \"number\", \"300\"),\n+                        IsMap(\"name\", \"\\\"third\\\"\", \"number\", \"300\")));\n+\n+  // Test SORTBY with MAX, GROUPBY, and REDUCE COUNT\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@name\", \"MAX\", \"3\", \"GROUPBY\", \"1\",\n+              \"@number\", \"REDUCE\", \"COUNT\", \"0\", \"AS\", \"count\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"number\", \"900\", \"count\", \"1\"),\n+                                         IsMap(\"number\", ArgType(RespExpr::NIL), \"count\", \"1\"),\n+                                         IsMap(\"number\", \"1200\", \"count\", \"1\")));\n+\n+  // Test SORTBY with MAX, GROUPBY (0 fields), and REDUCE COUNT\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@name\", \"MAX\", \"3\", \"GROUPBY\", \"0\",\n+              \"REDUCE\", \"COUNT\", \"0\", \"AS\", \"count\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"count\", \"3\")));\n+}\n+\n+TEST_F(SearchFamilyTest, AggregateSortByParsingErrors) {\n+  Run({\"JSON.SET\", \"j1\", \"$\", R\"({\"name\": \"first\", \"number\": 1200, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j2\", \"$\", R\"({\"name\": \"second\", \"number\": 800, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j3\", \"$\", R\"({\"name\": \"third\", \"number\": 300, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j4\", \"$\", R\"({\"name\": \"fourth\", \"number\": 400, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j5\", \"$\", R\"({\"name\": \"fifth\", \"number\": 900, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j6\", \"$\", R\"({\"name\": \"sixth\", \"number\": 300, \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j7\", \"$\", R\"({\"name\": \"seventh\", \"number\": 400, \"group\": \"second\"})\"});\n+  Run({\"JSON.SET\", \"j8\", \"$\", R\"({\"name\": \"eighth\", \"group\": \"first\"})\"});\n+  Run({\"JSON.SET\", \"j9\", \"$\", R\"({\"name\": \"ninth\", \"group\": \"second\"})\"});\n+\n+  Run({\"FT.CREATE\", \"index\", \"ON\", \"JSON\", \"SCHEMA\", \"$.name\", \"AS\", \"name\", \"TEXT\", \"$.number\",\n+       \"AS\", \"number\", \"NUMERIC\", \"$.group\", \"AS\", \"group\", \"TAG\"});\n+\n+  // Test SORTBY with invalid argument count\n+  auto resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"999\", \"@name\", \"@number\", \"DESC\"});\n+  EXPECT_THAT(resp, ErrArg(\"bad arguments for SORTBY: specified invalid number of strings\"));\n+\n+  // Test SORTBY with negative argument count\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"-3\", \"@name\", \"@number\", \"DESC\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Test MAX with invalid value\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@name\", \"MAX\", \"-10\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Test MAX without a value\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@name\", \"MAX\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Test SORTBY with a non-existing field\n+  /* Temporary unsupported\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"1\", \"@nonexistingfield\"});\n+  EXPECT_THAT(resp, ErrArg(\"Property `nonexistingfield` not loaded nor in schema\")); */\n+\n+  // Test SORTBY with an invalid value\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"SORTBY\", \"notvalue\", \"@name\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "FT.AGGREGATE does not fully support the SORTBY option\nDragonfly does not parse the following command:\r\n```\r\nFT.AGGREGATE index \"*\" GROUPBY 0 REDUCE COUNT 0 AS count SORTBY 2 @count DESC MAX 100\r\n```\n",
  "hints_text": "same issue\nany update\n> any update\r\n\r\nHi Vivek, I will push the changes in one/two weeks. The fix should be released in the next version.\nthanks mate waiting for it\nany update mate ?\r\n\nHello @rcl-viveksharma .  no need to ask us for status updates every few days. \nwe are waiting for this aggregate, for a month, thats why\nhai @BagritsevichStepan was this merged",
  "created_at": "2024-11-29T16:48:14Z",
  "modified_files": [
    "src/server/search/aggregator.cc",
    "src/server/search/aggregator.h",
    "src/server/search/search_family.cc"
  ],
  "modified_test_files": [
    "src/server/search/aggregator_test.cc",
    "src/server/search/search_family_test.cc"
  ]
}