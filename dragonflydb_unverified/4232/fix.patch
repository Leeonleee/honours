diff --git a/src/server/search/aggregator.cc b/src/server/search/aggregator.cc
index 09ccb841eafa..28d943c21499 100644
--- a/src/server/search/aggregator.cc
+++ b/src/server/search/aggregator.cc
@@ -65,9 +65,9 @@ void Aggregator::DoGroup(absl::Span<const std::string> fields, absl::Span<const
   }
 }
 
-void Aggregator::DoSort(std::string_view field, bool descending) {
+void Aggregator::DoSort(const SortParams& sort_params) {
   /*
-    Comparator for sorting DocValues by field.
+    Comparator for sorting DocValues by fields.
     If some of the fields is not present in the DocValues, comparator returns:
     1. l_it == l.end() && r_it != r.end()
       asc -> false
@@ -80,22 +80,41 @@ void Aggregator::DoSort(std::string_view field, bool descending) {
       desc -> false
   */
   auto comparator = [&](const DocValues& l, const DocValues& r) {
-    auto l_it = l.find(field);
-    auto r_it = r.find(field);
-
-    // If some of the values is not present
-    if (l_it == l.end() || r_it == r.end()) {
-      return l_it != l.end();
+    for (const auto& [field, order] : sort_params.fields) {
+      auto l_it = l.find(field);
+      auto r_it = r.find(field);
+
+      // If some of the values is not present
+      if (l_it == l.end() || r_it == r.end()) {
+        if (l_it == l.end() && r_it == r.end()) {
+          continue;
+        }
+        return l_it != l.end();
+      }
+
+      const auto& lv = l_it->second;
+      const auto& rv = r_it->second;
+      if (lv == rv) {
+        continue;
+      }
+      return order == SortParams::SortOrder::ASC ? lv < rv : lv > rv;
     }
-
-    auto& lv = l_it->second;
-    auto& rv = r_it->second;
-    return !descending ? lv < rv : lv > rv;
+    return false;
   };
 
-  std::sort(result.values.begin(), result.values.end(), std::move(comparator));
+  auto& values = result.values;
+  if (sort_params.SortAll()) {
+    std::sort(values.begin(), values.end(), comparator);
+  } else {
+    DCHECK_GE(sort_params.max, 0);
+    const size_t limit = std::min(values.size(), size_t(sort_params.max));
+    std::partial_sort(values.begin(), values.begin() + limit, values.end(), comparator);
+    values.resize(limit);
+  }
 
-  result.fields_to_print.insert(field);
+  for (auto& field : sort_params.fields) {
+    result.fields_to_print.insert(field.first);
+  }
 }
 
 void Aggregator::DoLimit(size_t offset, size_t num) {
@@ -152,10 +171,8 @@ AggregationStep MakeGroupStep(std::vector<std::string> fields, std::vector<Reduc
   };
 }
 
-AggregationStep MakeSortStep(std::string field, bool descending) {
-  return [field = std::move(field), descending](Aggregator* aggregator) {
-    aggregator->DoSort(field, descending);
-  };
+AggregationStep MakeSortStep(SortParams sort_params) {
+  return [params = std::move(sort_params)](Aggregator* aggregator) { aggregator->DoSort(params); };
 }
 
 AggregationStep MakeLimitStep(size_t offset, size_t num) {
diff --git a/src/server/search/aggregator.h b/src/server/search/aggregator.h
index a298735182f4..fe4dbbfe237a 100644
--- a/src/server/search/aggregator.h
+++ b/src/server/search/aggregator.h
@@ -33,9 +33,27 @@ struct AggregationResult {
   absl::flat_hash_set<std::string_view> fields_to_print;
 };
 
+struct SortParams {
+  enum class SortOrder { ASC, DESC };
+
+  constexpr static int64_t kSortAll = -1;
+
+  bool SortAll() const {
+    return max == kSortAll;
+  }
+
+  /* Fields to sort by. If multiple fields are provided, sorting works hierarchically:
+     - First, the i-th field is compared.
+     - If the i-th field values are equal, the (i + 1)-th field is compared, and so on. */
+  absl::InlinedVector<std::pair<std::string, SortOrder>, 2> fields;
+  /* Max number of elements to include in the sorted result.
+     If set, only the first [max] elements are fully sorted using partial_sort. */
+  int64_t max = kSortAll;
+};
+
 struct Aggregator {
   void DoGroup(absl::Span<const std::string> fields, absl::Span<const Reducer> reducers);
-  void DoSort(std::string_view field, bool descending = false);
+  void DoSort(const SortParams& sort_params);
   void DoLimit(size_t offset, size_t num);
 
   AggregationResult result;
@@ -94,7 +112,7 @@ Reducer::Func FindReducerFunc(ReducerFunc name);
 AggregationStep MakeGroupStep(std::vector<std::string> fields, std::vector<Reducer> reducers);
 
 // Make `SORTBY field [DESC]` step
-AggregationStep MakeSortStep(std::string field, bool descending = false);
+AggregationStep MakeSortStep(SortParams sort_params);
 
 // Make `LIMIT offset num` step
 AggregationStep MakeLimitStep(size_t offset, size_t num);
diff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc
index 6547642310f4..f7c9c8de47a4 100644
--- a/src/server/search/search_family.cc
+++ b/src/server/search/search_family.cc
@@ -306,6 +306,42 @@ optional<SearchParams> ParseSearchParamsOrReply(CmdArgParser* parser, SinkReplyB
   return params;
 }
 
+std::optional<aggregate::SortParams> ParseAggregatorSortParams(CmdArgParser* parser) {
+  using SordOrder = aggregate::SortParams::SortOrder;
+
+  size_t strings_num = parser->Next<size_t>();
+
+  aggregate::SortParams sort_params;
+  sort_params.fields.reserve(strings_num / 2);
+
+  while (parser->HasNext() && strings_num > 0) {
+    // TODO: Throw an error if the field has no '@' sign at the beginning
+    std::string_view parsed_field = ParseFieldWithAtSign(parser);
+    strings_num--;
+
+    SordOrder sord_order = SordOrder::ASC;
+    if (strings_num > 0) {
+      auto order = parser->TryMapNext("ASC", SordOrder::ASC, "DESC", SordOrder::DESC);
+      if (order) {
+        sord_order = order.value();
+        strings_num--;
+      }
+    }
+
+    sort_params.fields.emplace_back(parsed_field, sord_order);
+  }
+
+  if (strings_num) {
+    return std::nullopt;
+  }
+
+  if (parser->Check("MAX")) {
+    sort_params.max = parser->Next<size_t>();
+  }
+
+  return sort_params;
+}
+
 optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,
                                                        SinkReplyBuilder* builder) {
   AggregateParams params;
@@ -372,11 +408,13 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,
 
     // SORTBY nargs
     if (parser.Check("SORTBY")) {
-      parser.ExpectTag("1");
-      string_view field = parser.Next();
-      bool desc = bool(parser.Check("DESC"));
+      auto sort_params = ParseAggregatorSortParams(&parser);
+      if (!sort_params) {
+        builder->SendError("bad arguments for SORTBY: specified invalid number of strings");
+        return nullopt;
+      }
 
-      params.steps.push_back(aggregate::MakeSortStep(std::string{field}, desc));
+      params.steps.push_back(aggregate::MakeSortStep(std::move(sort_params).value()));
       continue;
     }
 
