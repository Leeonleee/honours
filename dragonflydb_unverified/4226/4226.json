{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4226,
  "instance_id": "dragonflydb__dragonfly-4226",
  "issue_numbers": [
    "3800"
  ],
  "base_commit": "68b7baf6a72bbabd7fca3f4a20d9daaf20a66385",
  "patch": "diff --git a/src/core/qlist.cc b/src/core/qlist.cc\nindex 65773e4b357c..416685cde085 100644\n--- a/src/core/qlist.cc\n+++ b/src/core/qlist.cc\n@@ -60,7 +60,7 @@ namespace dfly {\n \n namespace {\n \n-static_assert(sizeof(QList) == 24);\n+static_assert(sizeof(QList) == 32);\n \n enum IterDir : uint8_t { FWD = 1, REV = 0 };\n \n@@ -171,9 +171,13 @@ quicklistNode* CreateFromSV(int container, string_view value) {\n   return CreateRAW(container, entry, sz);\n }\n \n-inline void NodeSetEntry(quicklistNode* node, uint8_t* entry) {\n+// Returns the relative increase in size.\n+inline ssize_t NodeSetEntry(quicklistNode* node, uint8_t* entry) {\n   node->entry = entry;\n-  node->sz = lpBytes(node->entry);\n+  size_t new_sz = lpBytes(node->entry);\n+  ssize_t diff = new_sz - node->sz;\n+  node->sz = new_sz;\n+  return diff;\n }\n \n /* Compress the listpack in 'node' and update encoding details.\n@@ -195,7 +199,7 @@ bool CompressNode(quicklistNode* node) {\n   if (node->sz < MIN_COMPRESS_BYTES)\n     return false;\n \n-  // ROMAN: we allocate LZF_STATE on heap, piggy-backing on the existing allocation.\n+  // We allocate LZF_STATE on heap, piggy-backing on the existing allocation.\n   char* uptr = (char*)zmalloc(sizeof(quicklistLZF) + node->sz + sizeof(LZF_STATE));\n   quicklistLZF* lzf = (quicklistLZF*)uptr;\n   LZF_HSLOT* sdata = (LZF_HSLOT*)(uptr + sizeof(quicklistLZF) + node->sz);\n@@ -256,14 +260,13 @@ void RecompressOnly(quicklistNode* node) {\n   }\n }\n \n-quicklistNode* SplitNode(quicklistNode* node, int offset, bool after) {\n+quicklistNode* SplitNode(quicklistNode* node, int offset, bool after, ssize_t* diff) {\n   DCHECK(node->container == QUICKLIST_NODE_CONTAINER_PACKED);\n   size_t zl_sz = node->sz;\n   uint8_t* entry = (uint8_t*)zmalloc(zl_sz);\n \n-  /* Copy original listpack so we can split it */\n   memcpy(entry, node->entry, zl_sz);\n-  quicklistNode* new_node = CreateRAW(QUICKLIST_NODE_CONTAINER_PACKED, entry, zl_sz);\n+\n   /* Need positive offset for calculating extent below. */\n   if (offset < 0)\n     offset = node->count + offset;\n@@ -274,11 +277,13 @@ quicklistNode* SplitNode(quicklistNode* node, int offset, bool after) {\n   int new_start = after ? 0 : offset;\n   int new_extent = after ? offset + 1 : -1;\n \n-  NodeSetEntry(node, lpDeleteRange(node->entry, orig_start, orig_extent));\n+  ssize_t diff_existing = NodeSetEntry(node, lpDeleteRange(node->entry, orig_start, orig_extent));\n   node->count = lpLength(node->entry);\n \n-  NodeSetEntry(new_node, lpDeleteRange(new_node->entry, new_start, new_extent));\n+  entry = lpDeleteRange(entry, new_start, new_extent);\n+  quicklistNode* new_node = CreateRAW(QUICKLIST_NODE_CONTAINER_PACKED, entry, lpBytes(entry));\n   new_node->count = lpLength(new_node->entry);\n+  *diff = diff_existing;\n \n   return new_node;\n }\n@@ -340,6 +345,7 @@ void QList::Clear() {\n   }\n   head_ = nullptr;\n   count_ = 0;\n+  malloc_size_ = 0;\n }\n \n void QList::Push(string_view value, Where where) {\n@@ -419,7 +425,6 @@ bool QList::Replace(long index, std::string_view elem) {\n }\n \n size_t QList::MallocUsed(bool slow) const {\n-  // Approximation since does not account for listpacks.\n   size_t node_size = len_ * sizeof(quicklistNode) + znallocx(sizeof(quicklist));\n   if (slow) {\n     for (quicklistNode* node = head_; node; node = node->next) {\n@@ -428,7 +433,7 @@ size_t QList::MallocUsed(bool slow) const {\n     return node_size;\n   }\n \n-  return node_size + count_ * 16;  // we account for each member 16 bytes.\n+  return node_size + malloc_size_;\n }\n \n void QList::Iterate(IterateFunc cb, long start, long end) const {\n@@ -464,8 +469,11 @@ bool QList::PushSentinel(string_view value, Where where) {\n \n   if (ABSL_PREDICT_TRUE(NodeAllowInsert(orig, fill_, sz))) {\n     auto func = (where == HEAD) ? LP_Prepend : LP_Append;\n-    NodeSetEntry(orig, func(orig->entry, value));\n+    malloc_size_ += NodeSetEntry(orig, func(orig->entry, value));\n     orig->count++;\n+    if (len_ == 1) {  // sanity check\n+      DCHECK_EQ(malloc_size_, orig->sz);\n+    }\n     return false;\n   }\n \n@@ -515,6 +523,7 @@ void QList::InsertNode(quicklistNode* old_node, quicklistNode* new_node, InsertO\n \n   /* Update len first, so in Compress we know exactly len */\n   len_++;\n+  malloc_size_ += new_node->sz;\n \n   if (old_node)\n     quicklistCompress(old_node);\n@@ -529,6 +538,7 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n   int full = 0, at_tail = 0, at_head = 0, avail_next = 0, avail_prev = 0;\n   quicklistNode* node = it.current_;\n   size_t sz = elem.size();\n+\n   bool after = insert_opt == AFTER;\n \n   /* Populate accounting flags for easier boolean checks later */\n@@ -555,9 +565,11 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n       InsertPlainNode(node, elem, insert_opt);\n     } else {\n       DecompressNodeIfNeeded(true, node);\n-      quicklistNode* new_node = SplitNode(node, it.offset_, after);\n+      ssize_t diff_existing = 0;\n+      quicklistNode* new_node = SplitNode(node, it.offset_, after, &diff_existing);\n       quicklistNode* entry_node = InsertPlainNode(node, elem, insert_opt);\n       InsertNode(entry_node, new_node, insert_opt);\n+      malloc_size_ += diff_existing;\n     }\n     return;\n   }\n@@ -565,7 +577,8 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n   /* Now determine where and how to insert the new element */\n   if (!full) {\n     DecompressNodeIfNeeded(true, node);\n-    NodeSetEntry(node, LP_Insert(node->entry, elem, it.zi_, after ? LP_AFTER : LP_BEFORE));\n+    uint8_t* new_entry = LP_Insert(node->entry, elem, it.zi_, after ? LP_AFTER : LP_BEFORE);\n+    malloc_size_ += NodeSetEntry(node, new_entry);\n     node->count++;\n     RecompressOnly(node);\n   } else {\n@@ -576,7 +589,7 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n        *   - insert entry at head of next node. */\n       auto* new_node = node->next;\n       DecompressNodeIfNeeded(true, new_node);\n-      NodeSetEntry(new_node, LP_Prepend(new_node->entry, elem));\n+      malloc_size_ += NodeSetEntry(new_node, LP_Prepend(new_node->entry, elem));\n       new_node->count++;\n       RecompressOnly(new_node);\n       RecompressOnly(node);\n@@ -585,7 +598,7 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n        *   - insert entry at tail of previous node. */\n       auto* new_node = node->prev;\n       DecompressNodeIfNeeded(true, new_node);\n-      NodeSetEntry(new_node, LP_Append(new_node->entry, elem));\n+      malloc_size_ += NodeSetEntry(new_node, LP_Append(new_node->entry, elem));\n       new_node->count++;\n       RecompressOnly(new_node);\n       RecompressOnly(node);\n@@ -598,12 +611,14 @@ void QList::Insert(Iterator it, std::string_view elem, InsertOpt insert_opt) {\n       /* else, node is full we need to split it. */\n       /* covers both after and !after cases */\n       DecompressNodeIfNeeded(true, node);\n-      auto* new_node = SplitNode(node, it.offset_, after);\n+      ssize_t diff_existing = 0;\n+      auto* new_node = SplitNode(node, it.offset_, after, &diff_existing);\n       auto func = after ? LP_Prepend : LP_Append;\n-      NodeSetEntry(new_node, func(new_node->entry, elem));\n+      malloc_size_ += NodeSetEntry(new_node, func(new_node->entry, elem));\n       new_node->count++;\n       InsertNode(node, new_node, insert_opt);\n       MergeNodes(node);\n+      malloc_size_ += diff_existing;\n     }\n   }\n   count_++;\n@@ -616,15 +631,15 @@ void QList::Replace(Iterator it, std::string_view elem) {\n \n   if (ABSL_PREDICT_TRUE(!QL_NODE_IS_PLAIN(node) && !IsLargeElement(sz, fill_) &&\n                         (newentry = lpReplace(node->entry, &it.zi_, uint_ptr(elem), sz)) != NULL)) {\n-    NodeSetEntry(node, newentry);\n+    malloc_size_ += NodeSetEntry(node, newentry);\n     /* quicklistNext() and quicklistGetIteratorEntryAtIdx() provide an uncompressed node */\n     quicklistCompress(node);\n   } else if (QL_NODE_IS_PLAIN(node)) {\n     if (IsLargeElement(sz, fill_)) {\n       zfree(node->entry);\n-      node->entry = (uint8_t*)zmalloc(sz);\n-      node->sz = sz;\n-      memcpy(node->entry, elem.data(), sz);\n+      uint8_t* new_entry = (uint8_t*)zmalloc(sz);\n+      memcpy(new_entry, elem.data(), sz);\n+      malloc_size_ += NodeSetEntry(node, new_entry);\n       quicklistCompress(node);\n     } else {\n       Insert(it, elem, AFTER);\n@@ -635,8 +650,11 @@ void QList::Replace(Iterator it, std::string_view elem) {\n     node->dont_compress = 1; /* Prevent compression in InsertNode() */\n \n     /* If the entry is not at the tail, split the node at the entry's offset. */\n-    if (it.offset_ != node->count - 1 && it.offset_ != -1)\n-      split_node = SplitNode(node, it.offset_, 1);\n+    if (it.offset_ != node->count - 1 && it.offset_ != -1) {\n+      ssize_t diff_existing = 0;\n+      split_node = SplitNode(node, it.offset_, 1, &diff_existing);\n+      malloc_size_ += diff_existing;\n+    }\n \n     /* Create a new node and insert it after the original node.\n      * If the original node was split, insert the split node after the new node. */\n@@ -796,7 +814,8 @@ quicklistNode* QList::ListpackMerge(quicklistNode* a, quicklistNode* b) {\n       keep = a;\n     }\n     keep->count = lpLength(keep->entry);\n-    keep->sz = lpBytes(keep->entry);\n+    malloc_size_ += NodeSetEntry(keep, keep->entry);\n+\n     keep->recompress = 0; /* Prevent 'keep' from being recompressed if\n                            * it becomes head or tail after merging. */\n \n@@ -825,6 +844,7 @@ void QList::DelNode(quicklistNode* node) {\n   /* Update len first, so in Compress we know exactly len */\n   len_--;\n   count_ -= node->count;\n+  malloc_size_ -= node->sz;\n \n   /* If we deleted a node within our compress depth, we\n    * now have compressed nodes needing to be decompressed. */\n@@ -850,7 +870,7 @@ bool QList::DelPackedIndex(quicklistNode* node, uint8_t* p) {\n     return true;\n   }\n \n-  NodeSetEntry(node, lpDelete(node->entry, p, NULL));\n+  malloc_size_ += NodeSetEntry(node, lpDelete(node->entry, p, NULL));\n   node->count--;\n   count_--;\n \n@@ -958,6 +978,7 @@ auto QList::Erase(Iterator it) -> Iterator {\n   // Sanity, should be noop in release mode.\n   if (len_ == 1) {\n     DCHECK_EQ(count_, head_->count);\n+    DCHECK_EQ(malloc_size_, head_->sz);\n   }\n \n   /* else if (!deleted_node), no changes needed.\n@@ -1027,7 +1048,7 @@ bool QList::Erase(const long start, unsigned count) {\n       DelNode(node);\n     } else {\n       DecompressNodeIfNeeded(true, node);\n-      NodeSetEntry(node, lpDeleteRange(node->entry, offset, del));\n+      malloc_size_ += NodeSetEntry(node, lpDeleteRange(node->entry, offset, del));\n       node->count -= del;\n       count_ -= del;\n       if (node->count == 0) {\ndiff --git a/src/core/qlist.h b/src/core/qlist.h\nindex 9ae306aecc72..bf6215466138 100644\n--- a/src/core/qlist.h\n+++ b/src/core/qlist.h\n@@ -162,6 +162,9 @@ class QList {\n     return head_ ? head_->prev : nullptr;\n   }\n \n+  void OnPreUpdate(quicklistNode* node);\n+  void OnPostUpdate(quicklistNode* node);\n+\n   // Returns false if used existing sentinel, true if a new sentinel was created.\n   bool PushSentinel(std::string_view value, Where where);\n \n@@ -184,7 +187,7 @@ class QList {\n   bool DelPackedIndex(quicklistNode* node, uint8_t* p);\n \n   quicklistNode* head_ = nullptr;\n-\n+  size_t malloc_size_ = 0;               // size of the quicklist struct\n   uint32_t count_ = 0;                   /* total count of all entries in all listpacks */\n   uint32_t len_ = 0;                     /* number of quicklistNodes */\n   signed int fill_ : QL_FILL_BITS;       /* fill factor for individual nodes */\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex a2f7eb78f1ef..69f293cc257b 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -60,8 +60,8 @@ ABSL_FLAG(int32_t, list_max_listpack_size, -2, \"Maximum listpack size, default i\n  */\n \n ABSL_FLAG(int32_t, list_compress_depth, 0, \"Compress depth of the list. Default is no compression\");\n-ABSL_FLAG(bool, list_experimental_v2, false,\n-          \"Compress depth of the list. Default is no compression\");\n+ABSL_FLAG(bool, list_experimental_v2, true,\n+          \"Enables dragonfly specific implementation of quicklist\");\n \n namespace dfly {\n \n",
  "test_patch": "diff --git a/src/core/qlist_test.cc b/src/core/qlist_test.cc\nindex fdf7185e83f0..9e5d67c07fff 100644\n--- a/src/core/qlist_test.cc\n+++ b/src/core/qlist_test.cc\n@@ -166,6 +166,7 @@ TEST_F(QListTest, Basic) {\n   ql_.Push(\"abc\", QList::HEAD);\n   EXPECT_EQ(1, ql_.Size());\n   EXPECT_TRUE(ql_.Tail() == ql_.Head());\n+  EXPECT_LE(ql_.MallocUsed(false), ql_.MallocUsed(true));\n \n   auto it = ql_.GetIterator(QList::HEAD);\n   ASSERT_TRUE(it.Next());  // Needed to initialize the iterator.\n@@ -176,6 +177,7 @@ TEST_F(QListTest, Basic) {\n \n   ql_.Push(\"def\", QList::TAIL);\n   EXPECT_EQ(2, ql_.Size());\n+  EXPECT_LE(ql_.MallocUsed(false), ql_.MallocUsed(true));\n \n   it = ql_.GetIterator(QList::TAIL);\n   ASSERT_TRUE(it.Next());\n@@ -195,6 +197,7 @@ TEST_F(QListTest, Basic) {\n   vector<string> items = ToItems();\n \n   EXPECT_THAT(items, ElementsAre(\"abc\", \"def\"));\n+  EXPECT_GT(ql_.MallocUsed(false), ql_.MallocUsed(true) * 0.8);\n }\n \n TEST_F(QListTest, ListPack) {\n",
  "problem_statement": "List types memory tracking is inaccurate\nCreate a list with 1,000,000 entries, consuming 1,000 bytes each:\r\n\r\n```\r\ndebug populate 1 l 1000 RAND TYPE list ELEMENTS 100000\r\n```\r\n\r\nThen inspect it:\r\n\r\n```\r\n127.0.0.1:6379> memory usage l:0\r\n(integer) 21000048\r\n```\r\n\r\n(this means each element in the list takes 21 bytes)\r\n\r\nThis is also shown in:\r\n\r\n```\r\n127.0.0.1:6379> info memory\r\n[...]\r\ntype_used_memory_list:21000048\r\n[...]\r\n```\n",
  "hints_text": "Same for strings, this is a duplicate. One sec \nduplicate of  #3723\nI think this bug is better defined than #3723 because it clearly shows how to reproduce it. In fact, even an external contributor can try fixing it.\n>  because it clearly shows how to reproduce it. \r\n\r\nIt reproduces in the test I added as well :smile: Sure let's keep it though\nIt could be nice if we could account for memory usage for lists in O(1) time. \r\nI suggest introducing a `__thread ssize_t cur_list_sz` variable in quick_list.c. Before any operation on the list we will copy `RobjWrapper::sz_` into it, then do the operation and quicklist code will update it with the size changes. \r\nOnce the operation completes we will copy `cur_list_sz` back into `RobjWrapper::sz_`  that will hold the total memory size of `quicklist->entry` data\nSeems that quicklistNodeUpdateSz and __quicklistCompress are places where we should update `cur_list_sz`\nDiscussed with roman and agreed this will require bigger changes than expected, so unassigning myself\n@andydunstall / @romange, can you please elaborate on what you've learned that make this bigger than originally expected? Is it not enough to add accounting in `quick_list.c`? What else is needed?\nIt is enough but I did not feel comfortable to do intrusive changes to quicklist.cc\r\nThere are also other reasons why I preferred to move the code ownership under Dragonfly and then develop the code according to our needs.\n@adiholden  I am assigning  to myself since I am doing changes in that area.",
  "created_at": "2024-11-29T08:53:23Z",
  "modified_files": [
    "src/core/qlist.cc",
    "src/core/qlist.h",
    "src/server/list_family.cc"
  ],
  "modified_test_files": [
    "src/core/qlist_test.cc"
  ]
}