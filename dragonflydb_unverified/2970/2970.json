{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2970,
  "instance_id": "dragonflydb__dragonfly-2970",
  "issue_numbers": [
    "2969"
  ],
  "base_commit": "b3ca27068aa97417628862b4bdaf6372c280f37f",
  "patch": "diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 09a3fbeeaac3..0e5b8ea409cf 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -883,7 +883,6 @@ void Connection::ConnectionFlow(FiberSocketBase* peer) {\n   cc_->conn_closing = true;  // Signal dispatch to close.\n   evc_.notify();\n   phase_ = SHUTTING_DOWN;\n-\n   VLOG(2) << \"Before dispatch_fb.join()\";\n   dispatch_fb_.JoinIfNeeded();\n   VLOG(2) << \"After dispatch_fb.join()\";\n@@ -1119,6 +1118,10 @@ void Connection::HandleMigrateRequest() {\n     }\n   }\n \n+  // This triggers when a pub/sub connection both publish and subscribe to the\n+  // same channel. See #3035 on github for details.\n+  // DCHECK(dispatch_q_.empty());\n+\n   // In case we Yield()ed in Migrate() above, dispatch_fb_ might have been started.\n   LaunchDispatchFiberIfNeeded();\n }\n@@ -1648,16 +1651,6 @@ void Connection::RequestAsyncMigration(util::fb2::ProactorBase* dest) {\n   migration_request_ = dest;\n }\n \n-void Connection::SetClientTrackingSwitch(bool is_on) {\n-  tracking_enabled_ = is_on;\n-  if (tracking_enabled_)\n-    cc_->subscriptions++;\n-}\n-\n-bool Connection::IsTrackingOn() const {\n-  return tracking_enabled_;\n-}\n-\n void Connection::StartTrafficLogging(string_view path) {\n   OpenTrafficLogger(path);\n }\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 929ad5f8b5f0..71d5164e9597 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -298,10 +298,6 @@ class Connection : public util::Connection {\n   // Connections will migrate at most once, and only when the flag --migrate_connections is true.\n   void RequestAsyncMigration(util::fb2::ProactorBase* dest);\n \n-  void SetClientTrackingSwitch(bool is_on);\n-\n-  bool IsTrackingOn() const;\n-\n   // Starts traffic logging in the calling thread. Must be a proactor thread.\n   // Each thread creates its own log file combining requests from all the connections in\n   // that thread. A noop if the thread is already logging.\n@@ -450,8 +446,6 @@ class Connection : public util::Connection {\n   // Per-thread queue backpressure structs.\n   static thread_local QueueBackpressure tl_queue_backpressure_;\n \n-  // a flag indicating whether the client has turned on client tracking.\n-  bool tracking_enabled_ = false;\n   bool skip_next_squashing_ = false;  // Forcefully skip next squashing\n \n   // Connection migration vars, see RequestAsyncMigration() above.\ndiff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 833942dbe4e8..a007a431c311 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -33,8 +33,7 @@ add_library(dfly_transaction db_slice.cc malloc_stats.cc blocking_controller.cc\n             common.cc journal/journal.cc journal/types.cc journal/journal_slice.cc\n             server_state.cc table.cc  top_keys.cc transaction.cc tx_base.cc\n             serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc\n-            ${TX_LINUX_SRCS} acl/acl_log.cc slowlog.cc\n-            )\n+            ${TX_LINUX_SRCS} acl/acl_log.cc slowlog.cc)\n \n SET(SEARCH_FILES search/search_family.cc search/doc_index.cc search/doc_accessors.cc\n     search/aggregator.cc)\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 011793636f48..d223cd592ae3 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -265,4 +265,12 @@ void ConnectionState::ExecInfo::ClearWatched() {\n   watched_existed = 0;\n }\n \n+bool ConnectionState::ClientTracking::ShouldTrackKeys() const {\n+  if (!IsTrackingOn()) {\n+    return false;\n+  }\n+\n+  return !optin_ || (seq_num_ == (1 + caching_seq_num_));\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex 4c007b4e1350..7d57fc2c9a63 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -147,6 +147,87 @@ struct ConnectionState {\n \n   size_t UsedMemory() const;\n \n+  // Client tracking is a per-connection state machine that adheres to the requirements\n+  // of the CLIENT TRACKING command. Note that the semantics described below are enforced\n+  // by the tests in server_family_test. The rules are:\n+  // 1. If CLIENT TRACKING is ON then each READ command must be tracked. Invalidation\n+  //    messages are sent `only once`. Subsequent changes of the same key require the\n+  //    client to re-read the key in order to receive the next invalidation message.\n+  // 2. CLIENT TRACKING ON OPTIN turns on optional tracking. Read commands are not\n+  //    tracked unless the client issues a CLIENT CACHING YES command which conditionally\n+  //    allows the tracking of the command that follows CACHING YES). For example:\n+  //    >> CLIENT TRACKING ON\n+  //    >> CLIENT CACHING YES\n+  //    >> GET foo  <--------------------- From now foo is being tracked\n+  //    However:\n+  //    >> CLIENT TRACKING ON\n+  //    >> CLIENT CACHING YES\n+  //    >> SET foo bar\n+  //    >> GET foo <--------------------- is *NOT* tracked since GET does not succeed CACHING\n+  //    Also, in the context of multi transactions, CLIENT CACHING YES is *STICKY*:\n+  //    >> CLIENT TRACKING ON\n+  //    >> CLIENT CACHING YES\n+  //    >> MULTI\n+  //    >>   GET foo\n+  //    >>   SET foo bar\n+  //    >>   GET brother_foo\n+  //    >> EXEC\n+  //    From this point onwards `foo` and `get` keys are tracked. Same aplies if CACHING YES\n+  //    is used within the MULTI/EXEC block.\n+  //\n+  // The state machine implements the above rules. We need to track:\n+  // 1. If TRACKING is ON and OPTIN\n+  // 2. Stickiness of CACHING as described above\n+  //\n+  // We introduce a monotonic counter called sequence number which we increment only:\n+  // * On InvokeCmd when we are not Collecting (multi)\n+  // We introduce another counter called caching_seq_num which is set to seq_num\n+  // when the users sends a CLIENT CACHING YES command\n+  // If seq_num == caching_seq_num + 1 then we know that we should Track().\n+  class ClientTracking {\n+   public:\n+    // Sets to true when CLIENT TRACKING is ON\n+    void SetClientTracking(bool is_on) {\n+      tracking_enabled_ = is_on;\n+    }\n+\n+    // Increment current sequence number\n+    void IncrementSequenceNumber() {\n+      ++seq_num_;\n+    }\n+\n+    // Set if OPTIN subcommand is used in CLIENT TRACKING\n+    void SetOptin(bool optin) {\n+      optin_ = optin;\n+    }\n+\n+    // Check if the keys should be tracked. Result adheres to the state machine described above.\n+    bool ShouldTrackKeys() const;\n+\n+    // Check only if CLIENT TRACKING is ON\n+    bool IsTrackingOn() const {\n+      return tracking_enabled_;\n+    }\n+\n+    // Called by CLIENT CACHING YES and caches the current seq_num_\n+    void SetCachingSequenceNumber(bool is_multi) {\n+      // We need -1 when we are in multi\n+      caching_seq_num_ = is_multi && seq_num_ != 0 ? seq_num_ - 1 : seq_num_;\n+    }\n+\n+    void ResetCachingSequenceNumber() {\n+      caching_seq_num_ = 0;\n+    }\n+\n+   private:\n+    // a flag indicating whether the client has turned on client tracking.\n+    bool tracking_enabled_ = false;\n+    bool optin_ = false;\n+    // sequence number\n+    size_t seq_num_ = 0;\n+    size_t caching_seq_num_ = 0;\n+  };\n+\n  public:\n   DbIndex db_index = 0;\n \n@@ -161,6 +242,7 @@ struct ConnectionState {\n   std::optional<SquashingInfo> squashing_info;\n   std::unique_ptr<ScriptInfo> script_info;\n   std::unique_ptr<SubscribeInfo> subscribe_info;\n+  ClientTracking tracking_info_;\n };\n \n class ConnectionContext : public facade::ConnectionContext {\n@@ -183,6 +265,7 @@ class ConnectionContext : public facade::ConnectionContext {\n   // TODO: to introduce proper accessors.\n   Transaction* transaction = nullptr;\n   const CommandId* cid = nullptr;\n+\n   ConnectionState conn_state;\n \n   DbIndex db_index() const {\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex efb18e569cb8..73b818e53a8d 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -1423,24 +1423,29 @@ void DbSlice::SendInvalidationTrackingMessage(std::string_view key) {\n     return;\n \n   auto it = client_tracking_map_.find(key);\n-  if (it != client_tracking_map_.end()) {\n-    // notify all the clients.\n-    auto& client_set = it->second;\n-    auto cb = [key, client_set = std::move(client_set)](unsigned idx, util::ProactorBase*) {\n-      for (auto it = client_set.begin(); it != client_set.end(); ++it) {\n-        if ((unsigned int)it->Thread() != idx)\n-          continue;\n-        facade::Connection* conn = it->Get();\n-        if ((conn != nullptr) && conn->IsTrackingOn()) {\n-          std::string key_str = {key.begin(), key.end()};\n-          conn->SendInvalidationMessageAsync({key_str});\n-        }\n-      }\n-    };\n-    shard_set->pool()->DispatchBrief(std::move(cb));\n-    // remove this key from the tracking table as the key no longer exists\n-    client_tracking_map_.erase(key);\n+  if (it == client_tracking_map_.end()) {\n+    return;\n   }\n+  auto& client_set = it->second;\n+  // Notify all the clients. We copy key because we dispatch briefly below and\n+  // we need to preserve its lifetime\n+  // TODO this key is further copied within DispatchFiber. Fix this.\n+  auto cb = [key = std::string(key), client_set = std::move(client_set)](unsigned idx,\n+                                                                         util::ProactorBase*) {\n+    for (auto& client : client_set) {\n+      if (client.IsExpired() || (client.Thread() != idx)) {\n+        continue;\n+      }\n+      auto* conn = client.Get();\n+      auto* cntx = static_cast<ConnectionContext*>(conn->cntx());\n+      if (cntx && cntx->conn_state.tracking_info_.IsTrackingOn()) {\n+        conn->SendInvalidationMessageAsync({key});\n+      }\n+    }\n+  };\n+  shard_set->pool()->DispatchBrief(std::move(cb));\n+  // remove this key from the tracking table as the key no longer exists\n+  client_tracking_map_.erase(key);\n }\n \n void DbSlice::PerformDeletion(PrimeIterator del_it, DbTable* table) {\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 276fc5515a6f..da85f4d5d9ea 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -4,6 +4,8 @@\n \n #include \"server/main_service.h\"\n \n+#include \"facade/resp_expr.h\"\n+\n #ifdef __FreeBSD__\n #include <pthread_np.h>\n #endif\n@@ -1091,7 +1093,13 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n     if (cmd_name == \"SELECT\" || absl::EndsWith(cmd_name, \"SUBSCRIBE\"))\n       return ErrorReply{absl::StrCat(\"Can not call \", cmd_name, \" within a transaction\")};\n \n-    if (cmd_name == \"WATCH\" || cmd_name == \"FLUSHALL\" || cmd_name == \"FLUSHDB\")\n+    // for some reason we get a trailing \\n\\r, and that's why we use StartsWith\n+    bool client_cmd = false;\n+    if (cmd_name == \"CLIENT\") {\n+      DCHECK(!tail_args.empty());\n+      client_cmd = !absl::StartsWith(ToSV(tail_args[0]), \"CACHING\");\n+    }\n+    if (cmd_name == \"WATCH\" || cmd_name == \"FLUSHALL\" || cmd_name == \"FLUSHDB\" || client_cmd)\n       return ErrorReply{absl::StrCat(\"'\", cmd_name, \"' inside MULTI is not allowed\")};\n   }\n \n@@ -1127,28 +1135,6 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n   return VerifyConnectionAclStatus(cid, &dfly_cntx, \"has no ACL permissions\", tail_args);\n }\n \n-OpResult<void> OpTrackKeys(const OpArgs& op_args, const facade::Connection::WeakRef& conn_ref,\n-                           const ShardArgs& args) {\n-  if (conn_ref.IsExpired()) {\n-    DVLOG(2) << \"Connection expired, exiting TrackKey function.\";\n-    return OpStatus::OK;\n-  }\n-\n-  DVLOG(2) << \"Start tracking keys for client ID: \" << conn_ref.GetClientId()\n-           << \" with thread ID: \" << conn_ref.Thread();\n-\n-  DbSlice& db_slice = op_args.shard->db_slice();\n-\n-  // TODO: There is a bug here that we track all arguments instead of tracking only keys.\n-  for (auto key : args) {\n-    DVLOG(2) << \"Inserting client ID \" << conn_ref.GetClientId()\n-             << \" into the tracking client set of key \" << key;\n-    db_slice.TrackKey(conn_ref, key);\n-  }\n-\n-  return OpStatus::OK;\n-}\n-\n void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx) {\n   CHECK(!args.empty());\n   DCHECK_NE(0u, shard_set->size()) << \"Init was not called\";\n@@ -1253,18 +1239,6 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n     dfly_cntx->reply_builder()->CloseConnection();\n   }\n \n-  // if this is a read command, and client tracking has enabled,\n-  // start tracking all the updates to the keys in this read command\n-  if ((cid->opt_mask() & CO::READONLY) && dfly_cntx->conn()->IsTrackingOn() &&\n-      cid->IsTransactional()) {\n-    facade::Connection::WeakRef conn_ref = dfly_cntx->conn()->Borrow();\n-    auto cb = [&, conn_ref](Transaction* t, EngineShard* shard) {\n-      return OpTrackKeys(t->GetOpArgs(shard), conn_ref, t->GetShardArgs(shard->shard_id()));\n-    };\n-    dfly_cntx->transaction->Refurbish();\n-    dfly_cntx->transaction->ScheduleSingleHopT(cb);\n-  }\n-\n   if (!dispatching_in_multi) {\n     dfly_cntx->transaction = nullptr;\n   }\n@@ -1296,6 +1270,27 @@ class ReplyGuard {\n   SinkReplyBuilder* builder_ = nullptr;\n };\n \n+OpResult<void> OpTrackKeys(const OpArgs slice_args, const facade::Connection::WeakRef& conn_ref,\n+                           const ShardArgs& args) {\n+  if (conn_ref.IsExpired()) {\n+    DVLOG(2) << \"Connection expired, exiting TrackKey function.\";\n+    return OpStatus::OK;\n+  }\n+\n+  DVLOG(2) << \"Start tracking keys for client ID: \" << conn_ref.GetClientId()\n+           << \" with thread ID: \" << conn_ref.Thread();\n+\n+  auto& db_slice = slice_args.shard->db_slice();\n+  // TODO: There is a bug here that we track all arguments instead of tracking only keys.\n+  for (auto key : args) {\n+    DVLOG(2) << \"Inserting client ID \" << conn_ref.GetClientId()\n+             << \" into the tracking client set of key \" << key;\n+    db_slice.TrackKey(conn_ref, key);\n+  }\n+\n+  return OpStatus::OK;\n+}\n+\n bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionContext* cntx) {\n   DCHECK(cid);\n   DCHECK(!cid->Validate(tail_args));\n@@ -1320,6 +1315,23 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionCo\n \n   ServerState::tlocal()->RecordCmd();\n \n+  auto& info = cntx->conn_state.tracking_info_;\n+  auto* trans = cntx->transaction;\n+  const bool is_read_only = cid->opt_mask() & CO::READONLY;\n+  if (trans) {\n+    // Reset it, because in multi/exec the transaction pointer is the same and\n+    // we will end up triggerring the callback on the following commands. To avoid this\n+    // we reset it.\n+    trans->SetTrackingCallback({});\n+    if (is_read_only && info.ShouldTrackKeys()) {\n+      auto conn = cntx->conn()->Borrow();\n+      trans->SetTrackingCallback([conn](Transaction* trans) {\n+        auto* shard = EngineShard::tlocal();\n+        OpTrackKeys(trans->GetOpArgs(shard), conn, trans->GetShardArgs(shard->shard_id()));\n+      });\n+    }\n+  }\n+\n #ifndef NDEBUG\n   // Verifies that we reply to the client when needed.\n   ReplyGuard reply_guard(cntx, cid->name());\n@@ -1332,6 +1344,16 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionCo\n     return false;\n   }\n \n+  auto cid_name = cid->name();\n+  if ((!trans && cid_name != \"MULTI\") || (trans && !trans->IsMulti())) {\n+    // Each time we execute a command we need to increase the sequence number in\n+    // order to properly track clients when OPTIN is used.\n+    // We don't do this for `multi/exec` because it would break the\n+    // semantics, i.e, CACHING should stick for all commands following\n+    // the CLIENT CACHING ON within a multi/exec block\n+    cntx->conn_state.tracking_info_.IncrementSequenceNumber();\n+  }\n+\n   // TODO: we should probably discard more commands here,\n   // not just the blocking ones\n   const auto* conn = cntx->conn();\n@@ -1397,6 +1419,10 @@ size_t Service::DispatchManyCommands(absl::Span<CmdArgList> args_list,\n   for (auto args : args_list) {\n     ToUpper(&args[0]);\n     const auto [cid, tail_args] = FindCmd(args);\n+    // is client tracking command\n+    if (cid && cid->name() == \"CLIENT\" && !tail_args.empty() && ToSV(tail_args[0]) == \"TRACKING\") {\n+      break;\n+    }\n \n     // MULTI...EXEC commands need to be collected into a single context, so squashing is not\n     // possible\n@@ -2186,7 +2212,8 @@ void Service::Exec(CmdArgList args, ConnectionContext* cntx) {\n       ServerState::tlocal()->exec_freq_count[descr]++;\n     }\n \n-    if (absl::GetFlag(FLAGS_multi_exec_squash) && state == ExecEvalState::NONE) {\n+    if (absl::GetFlag(FLAGS_multi_exec_squash) && state == ExecEvalState::NONE &&\n+        !cntx->conn_state.tracking_info_.IsTrackingOn()) {\n       MultiCommandSquasher::Execute(absl::MakeSpan(exec_info.body), cntx, this);\n     } else {\n       CmdArgVec arg_vec;\n@@ -2232,7 +2259,6 @@ void Service::Publish(CmdArgList args, ConnectionContext* cntx) {\n   auto* cs = ServerState::tlocal()->channel_store();\n   vector<ChannelStore::Subscriber> subscribers = cs->FetchSubscribers(channel);\n   int num_published = subscribers.size();\n-\n   if (!subscribers.empty()) {\n     // Make sure neither of the threads limits is reached.\n     // This check actually doesn't reserve any memory ahead and doesn't prevent the buffer\n@@ -2559,7 +2585,7 @@ void Service::OnClose(facade::ConnectionContext* cntx) {\n \n   server_family_.OnClose(server_cntx);\n \n-  cntx->conn()->SetClientTrackingSwitch(false);\n+  conn_state.tracking_info_.SetClientTracking(false);\n }\n \n Service::ContextInfo Service::GetContextInfo(facade::ConnectionContext* cntx) const {\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 119020e7f7c2..c1b87f3f1982 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -456,29 +456,62 @@ void ClientPauseCmd(CmdArgList args, vector<facade::Listener*> listeners, Connec\n }\n \n void ClientTracking(CmdArgList args, ConnectionContext* cntx) {\n-  if (args.size() != 1)\n-    return cntx->SendError(kSyntaxErr);\n-\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (!rb->IsResp3())\n     return cntx->SendError(\n         \"Client tracking is currently not supported for RESP2. Please use RESP3.\");\n \n-  ToUpper(&args[0]);\n-  string_view state = ArgS(args, 0);\n-  bool is_on;\n-  if (state == \"ON\") {\n+  CmdArgParser parser{args};\n+  if (!parser.HasAtLeast(1) || args.size() > 2)\n+    return cntx->SendError(kSyntaxErr);\n+\n+  bool is_on = false;\n+  bool optin = false;\n+  if (parser.Check(\"ON\").IgnoreCase()) {\n     is_on = true;\n-  } else if (state == \"OFF\") {\n-    is_on = false;\n-  } else {\n+  } else if (!parser.Check(\"OFF\").IgnoreCase()) {\n     return cntx->SendError(kSyntaxErr);\n   }\n \n-  cntx->conn()->SetClientTrackingSwitch(is_on);\n+  if (parser.HasNext()) {\n+    if (parser.Check(\"OPTIN\").IgnoreCase()) {\n+      optin = true;\n+    } else {\n+      return cntx->SendError(kSyntaxErr);\n+    }\n+  }\n+\n+  if (is_on) {\n+    ++cntx->subscriptions;\n+  }\n+  cntx->conn_state.tracking_info_.SetClientTracking(is_on);\n+  cntx->conn_state.tracking_info_.SetOptin(optin);\n   return cntx->SendOk();\n }\n \n+void ClientCaching(CmdArgList args, ConnectionContext* cntx) {\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  if (!rb->IsResp3())\n+    return cntx->SendError(\n+        \"Client caching is currently not supported for RESP2. Please use RESP3.\");\n+\n+  if (args.size() != 1) {\n+    return cntx->SendError(kSyntaxErr);\n+  }\n+\n+  CmdArgParser parser{args};\n+  if (parser.Check(\"YES\").IgnoreCase()) {\n+    bool is_multi = cntx->transaction && cntx->transaction->IsMulti();\n+    cntx->conn_state.tracking_info_.SetCachingSequenceNumber(is_multi);\n+  } else if (parser.Check(\"NO\").IgnoreCase()) {\n+    cntx->conn_state.tracking_info_.ResetCachingSequenceNumber();\n+  } else {\n+    return cntx->SendError(kSyntaxErr);\n+  }\n+\n+  cntx->SendOk();\n+}\n+\n void ClientKill(CmdArgList args, absl::Span<facade::Listener*> listeners, ConnectionContext* cntx) {\n   std::function<bool(facade::Connection * conn)> evaluator;\n \n@@ -1539,7 +1572,7 @@ void ServerFamily::SendInvalidationMessages() const {\n     facade::ConnectionContext* fc = static_cast<facade::Connection*>(conn)->cntx();\n     if (fc) {\n       ConnectionContext* cntx = static_cast<ConnectionContext*>(fc);\n-      if (cntx->conn()->IsTrackingOn()) {\n+      if (cntx->conn_state.tracking_info_.IsTrackingOn()) {\n         facade::Connection::InvalidationMessage x;\n         x.invalidate_due_to_flush = true;\n         cntx->conn()->SendInvalidationMessageAsync(x);\n@@ -1630,6 +1663,8 @@ void ServerFamily::Client(CmdArgList args, ConnectionContext* cntx) {\n     return ClientTracking(sub_args, cntx);\n   } else if (sub_cmd == \"KILL\") {\n     return ClientKill(sub_args, absl::MakeSpan(listeners_), cntx);\n+  } else if (sub_cmd == \"CACHING\") {\n+    return ClientCaching(sub_args, cntx);\n   }\n \n   if (sub_cmd == \"SETINFO\") {\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 343b0e04a06a..1b4e994b99e0 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -691,8 +691,12 @@ void Transaction::RunCallback(EngineShard* shard) {\n   }\n \n   // Log to journal only once the command finished running\n-  if ((coordinator_state_ & COORD_CONCLUDING) || (multi_ && multi_->concluding))\n+  if ((coordinator_state_ & COORD_CONCLUDING) || (multi_ && multi_->concluding)) {\n     LogAutoJournalOnShard(shard, result);\n+    if (tracking_cb_) {\n+      tracking_cb_(this);\n+    }\n+  }\n }\n \n // TODO: For multi-transactions we should be able to deduce mode() at run-time based\ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex a88ee43cdb7e..ffd8abecde8c 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -363,6 +363,10 @@ class Transaction {\n     return shard_data_[SidToId(sid)].local_mask;\n   }\n \n+  void SetTrackingCallback(std::function<void(Transaction* trans)> f) {\n+    tracking_cb_ = std::move(f);\n+  }\n+\n   // Remove once BZPOP is stabilized\n   std::string DEBUGV18_BlockInfo() {\n     return \"claimed=\" + std::to_string(blocking_barrier_.IsClaimed()) +\n@@ -644,6 +648,8 @@ class Transaction {\n     ShardId coordinator_index = 0;\n   } stats_;\n \n+  std::function<void(Transaction* trans)> tracking_cb_;\n+\n  private:\n   struct TLTmpSpace {\n     std::vector<PerShardCache>& GetShardIndex(unsigned size);\n",
  "test_patch": "diff --git a/src/server/server_family_test.cc b/src/server/server_family_test.cc\nindex 88708f4faca2..2a8f4576cba5 100644\n--- a/src/server/server_family_test.cc\n+++ b/src/server/server_family_test.cc\n@@ -229,6 +229,117 @@ TEST_F(ServerFamilyTest, ClientTrackingReadKey) {\n   EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 0);\n }\n \n+TEST_F(ServerFamilyTest, ClientTrackingOptin) {\n+  Run({\"HELLO\", \"3\"});\n+  Run({\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\"});\n+\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 0);\n+  Run({\"GET\", \"FOO\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 0);\n+\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  // Start tracking once\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"SET\", \"FOO\", \"20\"});\n+  Run({\"GET\", \"FOO\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 1);\n+\n+  Run({\"GET\", \"BAR\"});\n+  Run({\"SET\", \"BAR\", \"20\"});\n+  Run({\"GET\", \"BAR\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 1);\n+\n+  // Start tracking once\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  Run({\"GET\", \"BAR\"});\n+  Run({\"SET\", \"BAR\", \"20\"});\n+  Run({\"GET\", \"BAR\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 2);\n+}\n+\n+TEST_F(ServerFamilyTest, ClientTrackingMulti) {\n+  Run({\"HELLO\", \"3\"});\n+  Run({\"CLIENT\", \"TRACKING\", \"ON\"});\n+  Run({\"MULTI\"});\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  Run({\"GET\", \"FOOBAR\"});\n+  Run({\"EXEC\"});\n+\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  Run({\"SET\", \"FOOBAR\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 2);\n+\n+  Run({\"MULTI\"});\n+  auto resp = Run({\"CLIENT\", \"TRACKING\", \"ON\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::ERROR));\n+  Run({\"DISCARD\"});\n+}\n+\n+TEST_F(ServerFamilyTest, ClientTrackingMultiOptin) {\n+  Run({\"HELLO\", \"3\"});\n+  // Check stickiness\n+  Run({\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\"});\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  Run({\"MULTI\"});\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  Run({\"GET\", \"FOOBAR\"});\n+  Run({\"DISCARD\"});\n+\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 0);\n+\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  Run({\"MULTI\"});\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  Run({\"GET\", \"FOOBAR\"});\n+  Run({\"EXEC\"});\n+\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  Run({\"SET\", \"FOOBAR\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 2);\n+\n+  // CACHING enclosed in MULTI\n+  Run({\"MULTI\"});\n+  Run({\"GET\", \"TMP\"});\n+  Run({\"GET\", \"TMP_TMP\"});\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"GET\", \"FOOBAR\"});\n+  Run({\"EXEC\"});\n+\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 2);\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 2);\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 3);\n+  Run({\"SET\", \"FOOBAR\", \"10\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 4);\n+\n+  // CACHING enclosed in MULTI, ON/OFF\n+  Run({\"MULTI\"});\n+  Run({\"GET\", \"TMP\"});\n+  Run({\"SET\", \"TMP\", \"10\"});\n+  Run({\"CLIENT\", \"CACHING\", \"YES\"});\n+  Run({\"GET\", \"FOO\"});\n+  Run({\"CLIENT\", \"CACHING\", \"NO\"});\n+  Run({\"GET\", \"BAR\"});\n+  Run({\"EXEC\"});\n+\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 4);\n+  Run({\"SET\", \"FOO\", \"10\"});\n+  Run({\"GET\", \"FOO\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 5);\n+  Run({\"SET\", \"BAR\", \"10\"});\n+  Run({\"GET\", \"BAR\"});\n+  EXPECT_EQ(InvalidationMessagesLen(\"IO0\"), 5);\n+}\n+\n TEST_F(ServerFamilyTest, ClientTrackingUpdateKey) {\n   Run({\"HELLO\", \"3\"});\n   Run({\"CLIENT\", \"TRACKING\", \"ON\"});\n",
  "problem_statement": "Add support for CLIENT OPTIN\nThis is sent by rueidis. \n\nAlso fixing this will fix the rueidis failed test `TestSingleClientIntegration`\n",
  "hints_text": "",
  "created_at": "2024-04-29T14:00:13Z",
  "modified_files": [
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/CMakeLists.txt",
    "src/server/conn_context.cc",
    "src/server/conn_context.h",
    "src/server/db_slice.cc",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/transaction.cc",
    "src/server/transaction.h"
  ],
  "modified_test_files": [
    "src/server/server_family_test.cc"
  ]
}