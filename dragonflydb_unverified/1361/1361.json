{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1361,
  "instance_id": "dragonflydb__dragonfly-1361",
  "issue_numbers": [
    "1357"
  ],
  "base_commit": "e646476359113ae5793557b3e90ee2203ecace2a",
  "patch": "diff --git a/src/server/cluster/cluster_config.cc b/src/server/cluster/cluster_config.cc\nindex 13ae9189a85e..69ff52d4cc3f 100644\n--- a/src/server/cluster/cluster_config.cc\n+++ b/src/server/cluster/cluster_config.cc\n@@ -1,3 +1,5 @@\n+#include <optional>\n+\n extern \"C\" {\n #include \"redis/crc16.h\"\n }\n@@ -32,10 +34,6 @@ SlotId ClusterConfig::KeySlot(string_view key) {\n   return crc16(tag.data(), tag.length()) & kMaxSlotNum;\n }\n \n-ClusterConfig::ClusterConfig(string_view my_id) : my_id_(my_id) {\n-  cluster_enabled = true;\n-}\n-\n namespace {\n bool HasValidNodeIds(const ClusterConfig::ClusterShards& new_config) {\n   absl::flat_hash_set<string_view> nodes;\n@@ -60,11 +58,10 @@ bool HasValidNodeIds(const ClusterConfig::ClusterShards& new_config) {\n \n   return true;\n }\n-}  // namespace\n \n-bool ClusterConfig::IsConfigValid(const ClusterShards& new_config) {\n+bool IsConfigValid(const ClusterConfig::ClusterShards& new_config) {\n   // Make sure that all slots are set exactly once.\n-  array<bool, tuple_size<decltype(slots_)>::value> slots_found = {};\n+  array<bool, ClusterConfig::kMaxSlotNum + 1> slots_found = {};\n \n   if (!HasValidNodeIds(new_config)) {\n     return false;\n@@ -103,38 +100,33 @@ bool ClusterConfig::IsConfigValid(const ClusterShards& new_config) {\n \n   return true;\n }\n+}  // namespace\n \n-optional<SlotSet> ClusterConfig::SetConfig(const vector<ClusterShard>& new_config) {\n-  if (!IsConfigValid(new_config)) {\n-    return nullopt;\n+/* static */\n+unique_ptr<ClusterConfig> ClusterConfig::CreateFromConfig(string_view my_id,\n+                                                          const ClusterShards& config) {\n+  if (!IsConfigValid(config)) {\n+    return nullptr;\n   }\n \n-  // When set config is called the first time, deleted_slots will contain all slots which are not\n-  // allocated to this node. This makes sure that if there is data in server that was loaded from\n-  // disk (rdb_load), then after the call to set config the server data will contain only data from\n-  // the node owned slots.\n-  bool is_first_config = !IsConfigured();\n+  unique_ptr<ClusterConfig> result(new ClusterConfig());\n \n-  lock_guard gu(mu_);\n+  result->config_ = config;\n \n-  config_ = new_config;\n-\n-  SlotSet deleted_slots;\n-  for (const auto& shard : config_) {\n-    for (const auto& slot_range : shard.slot_ranges) {\n-      bool owned_by_me =\n-          shard.master.id == my_id_ || any_of(shard.replicas.begin(), shard.replicas.end(),\n-                                              [&](const Node& node) { return node.id == my_id_; });\n-      for (SlotId i = slot_range.start; i <= slot_range.end; ++i) {\n-        if ((slots_[i].owned_by_me || is_first_config) && !owned_by_me) {\n-          deleted_slots.insert(i);\n+  for (const auto& shard : result->config_) {\n+    bool owned_by_me =\n+        shard.master.id == my_id || any_of(shard.replicas.begin(), shard.replicas.end(),\n+                                           [&](const Node& node) { return node.id == my_id; });\n+    if (owned_by_me) {\n+      for (const auto& slot_range : shard.slot_ranges) {\n+        for (SlotId i = slot_range.start; i <= slot_range.end; ++i) {\n+          result->my_slots_.set(i);\n         }\n-        slots_[i] = {.shard = &shard, .owned_by_me = owned_by_me};\n       }\n     }\n   }\n \n-  return deleted_slots;\n+  return result;\n }\n \n namespace {\n@@ -261,43 +253,53 @@ optional<ClusterConfig::ClusterShards> BuildClusterConfigFromJson(const JsonType\n }\n }  // namespace\n \n-optional<SlotSet> ClusterConfig::SetConfig(const JsonType& json) {\n-  optional<ClusterShards> config = BuildClusterConfigFromJson(json);\n+/* static */\n+unique_ptr<ClusterConfig> ClusterConfig::CreateFromConfig(string_view my_id,\n+                                                          const JsonType& json_config) {\n+  optional<ClusterShards> config = BuildClusterConfigFromJson(json_config);\n   if (!config.has_value()) {\n-    return nullopt;\n+    return nullptr;\n   }\n \n-  return SetConfig(config.value());\n+  return CreateFromConfig(my_id, config.value());\n }\n \n bool ClusterConfig::IsMySlot(SlotId id) const {\n-  if (id >= slots_.size()) {\n+  if (id >= my_slots_.size()) {\n     DCHECK(false) << \"Requesting a non-existing slot id \" << id;\n     return false;\n   }\n \n-  shared_lock gu(mu_);\n-  return slots_[id].owned_by_me;\n+  return my_slots_.test(id);\n }\n \n ClusterConfig::Node ClusterConfig::GetMasterNodeForSlot(SlotId id) const {\n-  shared_lock gu(mu_);\n+  CHECK_LT(id, my_slots_.size()) << \"Requesting a non-existing slot id \" << id;\n \n-  CHECK_LT(id, slots_.size()) << \"Requesting a non-existing slot id \" << id;\n-  CHECK_NE(slots_[id].shard, nullptr)\n-      << \"Calling GetMasterNodeForSlot(\" << id << \") before SetConfig()\";\n+  for (const auto& shard : config_) {\n+    for (const auto& range : shard.slot_ranges) {\n+      if (id >= range.start && id <= range.end) {\n+        return shard.master;\n+      }\n+    }\n+  }\n \n-  return slots_[id].shard->master;\n+  DCHECK(false) << \"Can't find master node for slot \" << id;\n+  return {};\n }\n \n ClusterConfig::ClusterShards ClusterConfig::GetConfig() const {\n-  shared_lock gu(mu_);\n   return config_;\n }\n \n-bool ClusterConfig::IsConfigured() const {\n-  shared_lock gu(mu_);\n-  return !config_.empty();\n+SlotSet ClusterConfig::GetOwnedSlots() const {\n+  SlotSet set;\n+  for (SlotId id = 0; id <= kMaxSlotNum; ++id) {\n+    if (IsMySlot(id)) {\n+      set.insert(id);\n+    }\n+  }\n+  return set;\n }\n \n }  // namespace dfly\ndiff --git a/src/server/cluster/cluster_config.h b/src/server/cluster/cluster_config.h\nindex ee97b4f9b8b3..a5d702d96a6a 100644\n--- a/src/server/cluster/cluster_config.h\n+++ b/src/server/cluster/cluster_config.h\n@@ -8,7 +8,8 @@\n #include <absl/container/flat_hash_set.h>\n \n #include <array>\n-#include <optional>\n+#include <bitset>\n+#include <memory>\n #include <string_view>\n #include <vector>\n \n@@ -43,10 +44,14 @@ class ClusterConfig {\n \n   using ClusterShards = std::vector<ClusterShard>;\n \n-  explicit ClusterConfig(std::string_view my_id);\n+  ClusterConfig& operator=(const ClusterConfig&) = default;\n \n   static SlotId KeySlot(std::string_view key);\n \n+  static void EnableCluster() {\n+    cluster_enabled = true;\n+  }\n+\n   static bool IsClusterEnabled() {\n     return cluster_enabled;\n   }\n@@ -54,24 +59,24 @@ class ClusterConfig {\n   // If the key contains the {...} pattern, return only the part between { and }\n   static std::string_view KeyTag(std::string_view key);\n \n+  // Returns an instance with `config` if it is valid.\n+  // Returns heap-allocated object as it is too big for a stack frame.\n+  static std::unique_ptr<ClusterConfig> CreateFromConfig(std::string_view my_id,\n+                                                         const ClusterShards& config);\n+\n+  // Parses `json_config` into `ClusterShards` and calls the above overload.\n+  static std::unique_ptr<ClusterConfig> CreateFromConfig(std::string_view my_id,\n+                                                         const JsonType& json_config);\n+\n   // If key is in my slots ownership return true\n   bool IsMySlot(SlotId id) const;\n \n   // Returns the master configured for `id`.\n-  // Must not be called when IsConfigured() == false.\n   Node GetMasterNodeForSlot(SlotId id) const;\n \n   ClusterShards GetConfig() const;\n \n-  // Returns deleted slot set if `new_config` is valid and internal state was changed. Returns\n-  // nullopt and changes nothing otherwise.\n-  std::optional<SlotSet> SetConfig(const ClusterShards& new_config);\n-\n-  // Parses `json` into `ClusterShards` and calls the above overload.\n-  std::optional<SlotSet> SetConfig(const JsonType& json);\n-\n-  // Returns whether SetConfig() was ever successfully called.\n-  bool IsConfigured() const;\n+  SlotSet GetOwnedSlots() const;\n \n  private:\n   struct SlotEntry {\n@@ -79,18 +84,16 @@ class ClusterConfig {\n     bool owned_by_me = false;\n   };\n \n-  bool IsConfigValid(const ClusterShards& new_config);\n-\n   static bool cluster_enabled;\n \n-  const std::string my_id_;\n+  ClusterConfig() = default;\n \n-  mutable util::SharedMutex mu_;\n+  std::string my_id_;\n \n-  ClusterShards config_ ABSL_GUARDED_BY(mu_);\n+  ClusterShards config_;\n \n-  // This array covers the whole range of possible slots for fast access. It points into `config_`.\n-  std::array<SlotEntry, kMaxSlotNum + 1> slots_ ABSL_GUARDED_BY(mu_) = {};\n+  // True bits in `my_slots_` indicate that this slot is owned by this node.\n+  std::bitset<kMaxSlotNum + 1> my_slots_;\n };\n \n }  // namespace dfly\ndiff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 1d0993c50002..fa6013d818d3 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -5,6 +5,7 @@\n #include \"server/cluster/cluster_family.h\"\n \n #include <jsoncons/json.hpp>\n+#include <memory>\n #include <mutex>\n #include <string>\n \n@@ -17,6 +18,7 @@\n #include \"server/conn_context.h\"\n #include \"server/dflycmd.h\"\n #include \"server/error.h\"\n+#include \"server/main_service.h\"\n #include \"server/replica.h\"\n #include \"server/server_family.h\"\n #include \"server/server_state.h\"\n@@ -43,6 +45,8 @@ constexpr string_view kClusterDisabled =\n     \"Cluster is disabled. Enabled via passing --cluster_mode=emulated|yes\";\n constexpr string_view kDflyClusterCmdPort = \"DflyCluster command allowed only under admin port\";\n \n+thread_local unique_ptr<ClusterConfig> tl_cluster_config;\n+\n }  // namespace\n \n ClusterFamily::ClusterFamily(ServerFamily* server_family) : server_family_(server_family) {\n@@ -52,13 +56,17 @@ ClusterFamily::ClusterFamily(ServerFamily* server_family) : server_family_(serve\n   if (cluster_mode == \"emulated\") {\n     is_emulated_cluster_ = true;\n   } else if (cluster_mode == \"yes\") {\n-    cluster_config_ = std::make_unique<ClusterConfig>(server_family_->master_id());\n+    ClusterConfig::EnableCluster();\n   } else if (!cluster_mode.empty()) {\n     LOG(ERROR) << \"invalid cluster_mode. Exiting...\";\n     exit(1);\n   }\n }\n \n+ClusterConfig* ClusterFamily::cluster_config() {\n+  return tl_cluster_config.get();\n+}\n+\n bool ClusterFamily::IsEnabledOrEmulated() const {\n   return is_emulated_cluster_ || ClusterConfig::IsClusterEnabled();\n }\n@@ -163,8 +171,8 @@ void ClusterShardsImpl(const ClusterShards& config, ConnectionContext* cntx) {\n void ClusterFamily::ClusterShards(ConnectionContext* cntx) {\n   if (is_emulated_cluster_) {\n     return ClusterShardsImpl({GetEmulatedShardInfo(cntx)}, cntx);\n-  } else if (cluster_config_->IsConfigured()) {\n-    return ClusterShardsImpl(cluster_config_->GetConfig(), cntx);\n+  } else if (tl_cluster_config != nullptr) {\n+    return ClusterShardsImpl(tl_cluster_config->GetConfig(), cntx);\n   } else {\n     return (*cntx)->SendError(kClusterNotConfigured);\n   }\n@@ -206,8 +214,8 @@ void ClusterSlotsImpl(const ClusterShards& config, ConnectionContext* cntx) {\n void ClusterFamily::ClusterSlots(ConnectionContext* cntx) {\n   if (is_emulated_cluster_) {\n     return ClusterSlotsImpl({GetEmulatedShardInfo(cntx)}, cntx);\n-  } else if (cluster_config_->IsConfigured()) {\n-    return ClusterSlotsImpl(cluster_config_->GetConfig(), cntx);\n+  } else if (tl_cluster_config != nullptr) {\n+    return ClusterSlotsImpl(tl_cluster_config->GetConfig(), cntx);\n   } else {\n     return (*cntx)->SendError(kClusterNotConfigured);\n   }\n@@ -259,8 +267,8 @@ void ClusterNodesImpl(const ClusterShards& config, string_view my_id, Connection\n void ClusterFamily::ClusterNodes(ConnectionContext* cntx) {\n   if (is_emulated_cluster_) {\n     return ClusterNodesImpl({GetEmulatedShardInfo(cntx)}, server_family_->master_id(), cntx);\n-  } else if (cluster_config_->IsConfigured()) {\n-    return ClusterNodesImpl(cluster_config_->GetConfig(), server_family_->master_id(), cntx);\n+  } else if (tl_cluster_config != nullptr) {\n+    return ClusterNodesImpl(tl_cluster_config->GetConfig(), server_family_->master_id(), cntx);\n   } else {\n     return (*cntx)->SendError(kClusterNotConfigured);\n   }\n@@ -321,8 +329,8 @@ void ClusterInfoImpl(const ClusterShards& config, ConnectionContext* cntx) {\n void ClusterFamily::ClusterInfo(ConnectionContext* cntx) {\n   if (is_emulated_cluster_) {\n     return ClusterInfoImpl({GetEmulatedShardInfo(cntx)}, cntx);\n-  } else if (cluster_config_->IsConfigured()) {\n-    return ClusterInfoImpl(cluster_config_->GetConfig(), cntx);\n+  } else if (tl_cluster_config != nullptr) {\n+    return ClusterInfoImpl(tl_cluster_config->GetConfig(), cntx);\n   } else {\n     return ClusterInfoImpl({}, cntx);\n   }\n@@ -377,8 +385,6 @@ void ClusterFamily::DflyCluster(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendError(kDflyClusterCmdPort);\n   }\n \n-  CHECK(is_emulated_cluster_ || cluster_config_.get() != nullptr);\n-\n   ToUpper(&args[0]);\n   string_view sub_cmd = ArgS(args, 0);\n   if (sub_cmd == \"GETSLOTINFO\") {\n@@ -399,6 +405,21 @@ void ClusterFamily::DflyClusterMyId(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendBulkString(server_family_->master_id());\n }\n \n+namespace {\n+SlotSet GetDeletedSlots(bool is_first_config, const SlotSet& before, const SlotSet& after) {\n+  SlotSet result;\n+  for (SlotId id = 0; id <= ClusterConfig::kMaxSlotNum; ++id) {\n+    if ((before.contains(id) || is_first_config) && !after.contains(id)) {\n+      result.insert(id);\n+    }\n+  }\n+  return result;\n+}\n+\n+// Guards set configuration, so that we won't handle 2 in parallel.\n+Mutex set_config_mu;\n+}  // namespace\n+\n void ClusterFamily::DflyClusterConfig(CmdArgList args, ConnectionContext* cntx) {\n   SinkReplyBuilder* rb = cntx->reply_builder();\n \n@@ -413,19 +434,44 @@ void ClusterFamily::DflyClusterConfig(CmdArgList args, ConnectionContext* cntx)\n     return rb->SendError(\"Invalid JSON cluster config\", kSyntaxErrType);\n   }\n \n-  auto deleted_slot_ids = cluster_config_->SetConfig(json.value());\n-  if (!deleted_slot_ids.has_value()) {\n+  unique_ptr<ClusterConfig> new_config =\n+      ClusterConfig::CreateFromConfig(server_family_->master_id(), json.value());\n+  if (new_config == nullptr) {\n+    LOG(WARNING) << \"Can't set cluster config\";\n     return rb->SendError(\"Invalid cluster configuration.\");\n   }\n \n+  lock_guard gu(set_config_mu);\n+\n+  bool is_first_config = true;\n+  SlotSet before;\n+  if (tl_cluster_config != nullptr) {\n+    is_first_config = false;\n+    before = tl_cluster_config->GetOwnedSlots();\n+  }\n+\n+  auto cb = [&](util::ProactorBase* pb) {\n+    if (tl_cluster_config == nullptr) {\n+      tl_cluster_config = make_unique<ClusterConfig>(*new_config);\n+    } else {\n+      *tl_cluster_config = *new_config;\n+    }\n+  };\n+  server_family_->service().proactor_pool().AwaitFiberOnAll(std::move(cb));\n+\n+  DCHECK(tl_cluster_config != nullptr);\n+\n+  SlotSet after = tl_cluster_config->GetOwnedSlots();\n+\n   // Delete old slots data.\n-  if (!deleted_slot_ids.value().empty()) {\n+  SlotSet deleted_slot_ids = GetDeletedSlots(is_first_config, before, after);\n+  if (!deleted_slot_ids.empty()) {\n     auto cb = [&](auto*) {\n       EngineShard* shard = EngineShard::tlocal();\n       if (shard == nullptr)\n         return;\n \n-      shard->db_slice().FlushSlots(deleted_slot_ids.value());\n+      shard->db_slice().FlushSlots(deleted_slot_ids);\n     };\n     shard_set->pool()->AwaitFiberOnAll(std::move(cb));\n   }\ndiff --git a/src/server/cluster/cluster_family.h b/src/server/cluster/cluster_family.h\nindex 73e85906c051..8716917bfff7 100644\n--- a/src/server/cluster/cluster_family.h\n+++ b/src/server/cluster/cluster_family.h\n@@ -4,7 +4,6 @@\n \n #pragma once\n \n-#include <memory>\n #include <string>\n \n #include \"facade/conn_context.h\"\n@@ -25,9 +24,8 @@ class ClusterFamily {\n \n   bool IsEnabledOrEmulated() const;\n \n-  ClusterConfig* cluster_config() {\n-    return cluster_config_.get();\n-  }\n+  // Returns a thread-local pointer.\n+  ClusterConfig* cluster_config();\n \n  private:\n   // Cluster commands compatible with Redis\n@@ -51,8 +49,6 @@ class ClusterFamily {\n \n   bool is_emulated_cluster_ = false;\n   ServerFamily* server_family_ = nullptr;\n-\n-  std::unique_ptr<ClusterConfig> cluster_config_;\n };\n \n }  // namespace dfly\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex b8cae07227c0..6b768aae57d8 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -628,8 +628,8 @@ bool Service::CheckKeysOwnership(const CommandId* cid, CmdArgList args,\n   }\n \n   // Check keys slot is in my ownership\n-  const auto& cluster_config = cluster_family_.cluster_config();\n-  if (!cluster_config->IsConfigured()) {\n+  const ClusterConfig* cluster_config = cluster_family_.cluster_config();\n+  if (cluster_config == nullptr) {\n     (*dfly_cntx)->SendError(kClusterNotConfigured);\n     return false;\n   }\n",
  "test_patch": "diff --git a/src/server/cluster/cluster_config_test.cc b/src/server/cluster/cluster_config_test.cc\nindex 2d1e3cb4edab..8d17a479f7ec 100644\n--- a/src/server/cluster/cluster_config_test.cc\n+++ b/src/server/cluster/cluster_config_test.cc\n@@ -30,7 +30,6 @@ class ClusterConfigTest : public ::testing::Test {\n   }\n \n   const string kMyId = \"my-id\";\n-  ClusterConfig config_{kMyId};\n };\n \n TEST_F(ClusterConfigTest, KeyTagTest) {\n@@ -50,377 +49,365 @@ TEST_F(ClusterConfigTest, KeyTagTest) {\n   ASSERT_EQ(key, ClusterConfig::KeyTag(key));\n }\n \n-TEST_F(ClusterConfigTest, ConfigEmpty) {\n-  // Test that empty-initialization causes none of the slots to be owned locally.\n-  for (SlotId i : {0, 1, 10, 100, 1'000, 10'000, 16'000, 0x3FFF}) {\n-    EXPECT_FALSE(config_.IsMySlot(i));\n-  }\n-}\n-\n TEST_F(ClusterConfigTest, ConfigSetInvalidEmpty) {\n-  EXPECT_FALSE(config_.SetConfig(ClusterConfig::ClusterShards{}));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ClusterConfig::ClusterShards{}), nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMissingSlots) {\n-  EXPECT_FALSE(config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 16000}},\n-                                   .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n-                                   .replicas = {}}}));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(\n+                kMyId, {{.slot_ranges = {{.start = 0, .end = 16000}},\n+                         .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n+                         .replicas = {}}}),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidDoubleBookedSlot) {\n-  EXPECT_FALSE(config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n-                                   .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n-                                   .replicas = {}},\n-                                  {.slot_ranges = {{.start = 0, .end = 0}},\n-                                   .master = {.id = \"other2\", .ip = \"192.168.0.101\", .port = 7001},\n-                                   .replicas = {}}}));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(\n+                kMyId, {{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n+                         .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n+                         .replicas = {}},\n+                        {.slot_ranges = {{.start = 0, .end = 0}},\n+                         .master = {.id = \"other2\", .ip = \"192.168.0.101\", .port = 7001},\n+                         .replicas = {}}}),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidSlotId) {\n-  EXPECT_FALSE(config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 0x3FFF + 1}},\n-                                   .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n-                                   .replicas = {}}}));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(\n+                kMyId, {{.slot_ranges = {{.start = 0, .end = 0x3FFF + 1}},\n+                         .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n+                         .replicas = {}}}),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetOk) {\n-  EXPECT_TRUE(config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n-                                  .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n-                                  .replicas = {}}}));\n-  EXPECT_THAT(config_.GetMasterNodeForSlot(0),\n+  auto config = ClusterConfig::CreateFromConfig(\n+      kMyId, {{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n+               .master = {.id = \"other\", .ip = \"192.168.0.100\", .port = 7000},\n+               .replicas = {}}});\n+  EXPECT_NE(config, nullptr);\n+  EXPECT_THAT(config->GetMasterNodeForSlot(0),\n               NodeMatches(Node{.id = \"other\", .ip = \"192.168.0.100\", .port = 7000}));\n+  EXPECT_THAT(config->GetOwnedSlots(), UnorderedElementsAre());\n }\n \n TEST_F(ClusterConfigTest, ConfigSetOkWithReplicas) {\n-  EXPECT_TRUE(config_.SetConfig(\n-      {{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n-        .master = {.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000},\n-        .replicas = {{.id = \"other-replica\", .ip = \"192.168.0.101\", .port = 7001}}}}));\n-  EXPECT_THAT(config_.GetMasterNodeForSlot(0),\n+  auto config = ClusterConfig::CreateFromConfig(\n+      kMyId, {{.slot_ranges = {{.start = 0, .end = 0x3FFF}},\n+               .master = {.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000},\n+               .replicas = {{.id = \"other-replica\", .ip = \"192.168.0.101\", .port = 7001}}}});\n+  EXPECT_NE(config, nullptr);\n+  EXPECT_THAT(config->GetMasterNodeForSlot(0),\n               NodeMatches(Node{.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000}));\n }\n \n TEST_F(ClusterConfigTest, ConfigSetMultipleInstances) {\n-  EXPECT_TRUE(config_.SetConfig(\n-      {{.slot_ranges = {{.start = 0, .end = 5'000}},\n-        .master = {.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000},\n-        .replicas = {{.id = \"other-replica\", .ip = \"192.168.0.101\", .port = 7001}}},\n-       {.slot_ranges = {{.start = 5'001, .end = 10'000}},\n-        .master = {.id = kMyId, .ip = \"192.168.0.102\", .port = 7002},\n-        .replicas = {{.id = \"other-replica2\", .ip = \"192.168.0.103\", .port = 7003}}},\n-       {.slot_ranges = {{.start = 10'001, .end = 0x3FFF}},\n-        .master = {.id = \"other-master3\", .ip = \"192.168.0.104\", .port = 7004},\n-        .replicas = {{.id = \"other-replica3\", .ip = \"192.168.0.105\", .port = 7005}}}}));\n+  auto config = ClusterConfig::CreateFromConfig(\n+      kMyId, {{.slot_ranges = {{.start = 0, .end = 5'000}},\n+               .master = {.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000},\n+               .replicas = {{.id = \"other-replica\", .ip = \"192.168.0.101\", .port = 7001}}},\n+              {.slot_ranges = {{.start = 5'001, .end = 10'000}},\n+               .master = {.id = kMyId, .ip = \"192.168.0.102\", .port = 7002},\n+               .replicas = {{.id = \"other-replica2\", .ip = \"192.168.0.103\", .port = 7003}}},\n+              {.slot_ranges = {{.start = 10'001, .end = 0x3FFF}},\n+               .master = {.id = \"other-master3\", .ip = \"192.168.0.104\", .port = 7004},\n+               .replicas = {{.id = \"other-replica3\", .ip = \"192.168.0.105\", .port = 7005}}}});\n+  EXPECT_NE(config, nullptr);\n+  SlotSet owned_slots = config->GetOwnedSlots();\n+  EXPECT_EQ(owned_slots.size(), 5'000);\n+\n   {\n     for (int i = 0; i <= 5'000; ++i) {\n-      EXPECT_THAT(config_.GetMasterNodeForSlot(i),\n+      EXPECT_THAT(config->GetMasterNodeForSlot(i),\n                   NodeMatches(Node{.id = \"other-master\", .ip = \"192.168.0.100\", .port = 7000}));\n-      EXPECT_FALSE(config_.IsMySlot(i));\n+      EXPECT_FALSE(config->IsMySlot(i));\n+      EXPECT_FALSE(owned_slots.contains(i));\n     }\n   }\n   {\n     for (int i = 5'001; i <= 10'000; ++i) {\n-      EXPECT_THAT(config_.GetMasterNodeForSlot(i),\n+      EXPECT_THAT(config->GetMasterNodeForSlot(i),\n                   NodeMatches(Node{.id = kMyId, .ip = \"192.168.0.102\", .port = 7002}));\n-      EXPECT_TRUE(config_.IsMySlot(i));\n+      EXPECT_TRUE(config->IsMySlot(i));\n+      EXPECT_TRUE(owned_slots.contains(i));\n     }\n   }\n   {\n     for (int i = 10'001; i <= 0x3FFF; ++i) {\n-      EXPECT_THAT(config_.GetMasterNodeForSlot(i),\n+      EXPECT_THAT(config->GetMasterNodeForSlot(i),\n                   NodeMatches(Node{.id = \"other-master3\", .ip = \"192.168.0.104\", .port = 7004}));\n-      EXPECT_FALSE(config_.IsMySlot(i));\n+      EXPECT_FALSE(config->IsMySlot(i));\n+      EXPECT_FALSE(owned_slots.contains(i));\n     }\n   }\n }\n \n-TEST_F(ClusterConfigTest, ConfigSetGetDeletedSlots) {\n-  auto ds =\n-      config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 16'380}},\n-                          .master = {.id = kMyId, .ip = \"192.168.0.100\", .port = 7000},\n-                          .replicas = {}},\n-                         {.slot_ranges = {{.start = 16'381, .end = 0x3FFF}},\n-                          .master = {.id = \"other-master2\", .ip = \"192.168.0.104\", .port = 7004},\n-                          .replicas = {}}});\n-\n-  EXPECT_TRUE(ds.has_value());\n-  // On first config non owned slots are returned as deleted\n-  EXPECT_THAT(ds.value(), UnorderedElementsAre(16'381, 16'382, 16'383));\n-\n-  ds = config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 16'381}},\n-                           .master = {.id = kMyId, .ip = \"192.168.0.100\", .port = 7000},\n-                           .replicas = {}},\n-                          {.slot_ranges = {{.start = 16'382, .end = 0x3FFF}},\n-                           .master = {.id = \"other-master2\", .ip = \"192.168.0.104\", .port = 7004},\n-                           .replicas = {}}});\n-\n-  EXPECT_TRUE(ds.has_value());\n-  EXPECT_TRUE(ds.value().empty());  // On second config no slots taken from ownership\n-\n-  ds = config_.SetConfig({{.slot_ranges = {{.start = 0, .end = 16'378}},\n-                           .master = {.id = kMyId, .ip = \"192.168.0.100\", .port = 7000},\n-                           .replicas = {}},\n-                          {.slot_ranges = {{.start = 16'379, .end = 0x3FFF}},\n-                           .master = {.id = \"other-master2\", .ip = \"192.168.0.104\", .port = 7004},\n-                           .replicas = {}}});\n-\n-  EXPECT_TRUE(ds.has_value());\n-  EXPECT_THAT(ds.value(), UnorderedElementsAre(16'379, 16'380, 16'381));\n-}\n-\n TEST_F(ClusterConfigTest, ConfigSetInvalidSlotRanges) {\n   // Note that slot_ranges is not an object\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": \"0,16383\",\n-          \"master\": {\n-            \"id\": \"abcd1234\",\n-            \"ip\": \"10.0.0.1\",\n-            \"port\": 7000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": \"0,16383\",\n+                    \"master\": {\n+                      \"id\": \"abcd1234\",\n+                      \"ip\": \"10.0.0.1\",\n+                      \"port\": 7000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidSlotRangeStart) {\n   // Note that slot_ranges.start is not a number\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": \"0\",\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcd1234\",\n-            \"ip\": \"10.0.0.1\",\n-            \"port\": 7000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": \"0\",\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcd1234\",\n+                      \"ip\": \"10.0.0.1\",\n+                      \"port\": 7000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidSlotRangeEnd) {\n   // Note that slot_ranges.end is not a number\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": \"16383\"\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcd1234\",\n-            \"ip\": \"10.0.0.1\",\n-            \"port\": 7000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": \"16383\"\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcd1234\",\n+                      \"ip\": \"10.0.0.1\",\n+                      \"port\": 7000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMissingMaster) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ]\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ]\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMasterNotObject) {\n   // Note that master is not an object\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": 123,\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": 123,\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMasterMissingId) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMasterMissingIp) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMasterMissingPort) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\"\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\"\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidMissingReplicas) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          }\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    }\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidRepeatingMasterId) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 10000\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": []\n-        },\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 10001,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": []\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 10000\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": []\n+                  },\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 10001,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": []\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidRepeatingReplicaId) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": [\n-            {\n-              \"id\": \"xyz\",\n-              \"ip\": \"10.0.0.1\",\n-              \"port\": 8001\n-            },\n-            {\n-              \"id\": \"xyz\",\n-              \"ip\": \"10.0.0.2\",\n-              \"port\": 8002\n-            }\n-          ]\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": [\n+                      {\n+                        \"id\": \"xyz\",\n+                        \"ip\": \"10.0.0.1\",\n+                        \"port\": 8001\n+                      },\n+                      {\n+                        \"id\": \"xyz\",\n+                        \"ip\": \"10.0.0.2\",\n+                        \"port\": 8002\n+                      }\n+                    ]\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n TEST_F(ClusterConfigTest, ConfigSetInvalidRepeatingMasterAndReplicaId) {\n-  EXPECT_FALSE(config_.SetConfig(ParseJson(R\"json(\n-      [\n-        {\n-          \"slot_ranges\": [\n-            {\n-              \"start\": 0,\n-              \"end\": 16383\n-            }\n-          ],\n-          \"master\": {\n-            \"id\": \"abcdefg\",\n-            \"ip\": \"10.0.0.0\",\n-            \"port\": 8000\n-          },\n-          \"replicas\": [\n-            {\n-              \"id\": \"abcdefg\",\n-              \"ip\": \"10.0.0.1\",\n-              \"port\": 8001\n-            }\n-          ]\n-        }\n-      ])json\")));\n+  EXPECT_EQ(ClusterConfig::CreateFromConfig(kMyId, ParseJson(R\"json(\n+                [\n+                  {\n+                    \"slot_ranges\": [\n+                      {\n+                        \"start\": 0,\n+                        \"end\": 16383\n+                      }\n+                    ],\n+                    \"master\": {\n+                      \"id\": \"abcdefg\",\n+                      \"ip\": \"10.0.0.0\",\n+                      \"port\": 8000\n+                    },\n+                    \"replicas\": [\n+                      {\n+                        \"id\": \"abcdefg\",\n+                        \"ip\": \"10.0.0.1\",\n+                        \"port\": 8001\n+                      }\n+                    ]\n+                  }\n+                ])json\")),\n+            nullptr);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/cluster/cluster_family_test.cc b/src/server/cluster/cluster_family_test.cc\nindex 189ad1690be5..d2151a9470f4 100644\n--- a/src/server/cluster/cluster_family_test.cc\n+++ b/src/server/cluster/cluster_family_test.cc\n@@ -9,7 +9,10 @@\n #include <string>\n #include <string_view>\n \n+#include \"absl/strings/str_replace.h\"\n #include \"absl/strings/substitute.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n #include \"facade/facade_test.h\"\n@@ -29,6 +32,21 @@ class ClusterFamilyTest : public BaseFamilyTest {\n \n  protected:\n   static constexpr string_view kInvalidConfiguration = \"Invalid cluster configuration\";\n+\n+  void ExpectConditionWithinTimeout(const std::function<bool()>& condition,\n+                                    absl::Duration timeout = absl::Seconds(5)) {\n+    absl::Time deadline = absl::Now() + timeout;\n+\n+    while (deadline > absl::Now()) {\n+      if (condition()) {\n+        break;\n+      }\n+      absl::SleepFor(absl::Milliseconds(10));\n+    }\n+\n+    EXPECT_LE(absl::Now(), deadline)\n+        << \"Timeout of \" << timeout << \" reached when expecting condition\";\n+  }\n };\n \n TEST_F(ClusterFamilyTest, DflyClusterOnlyOnAdminPort) {\n@@ -560,7 +578,8 @@ TEST_F(ClusterFamilyTest, ClusterConfigDeleteSlots) {\n \n   config = absl::Substitute(config_template, \"abc\");\n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n-  sleep(1);\n+\n+  ExpectConditionWithinTimeout([&]() { return CheckedInt({\"dbsize\"}) == 0; });\n \n   EXPECT_THAT(\n       RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"1\", \"2\"}),\n@@ -570,6 +589,64 @@ TEST_F(ClusterFamilyTest, ClusterConfigDeleteSlots) {\n                                                   IntArg(0), \"total_writes\", Not(IntArg(0)))))));\n }\n \n+TEST_F(ClusterFamilyTest, ClusterConfigDeleteSomeSlots) {\n+  string config_template = R\"json(\n+      [\n+        {\n+          \"slot_ranges\": [\n+            {\n+              \"start\": 0,\n+              \"end\": 8000\n+            }\n+          ],\n+          \"master\": {\n+            \"id\": \"$0\",\n+            \"ip\": \"10.0.0.1\",\n+            \"port\": 7000\n+          },\n+          \"replicas\": []\n+        },\n+        {\n+          \"slot_ranges\": [\n+            {\n+              \"start\": 8001,\n+              \"end\": 16383\n+            }\n+          ],\n+          \"master\": {\n+            \"id\": \"other\",\n+            \"ip\": \"10.0.0.2\",\n+            \"port\": 7000\n+          },\n+          \"replicas\": []\n+        }\n+      ])json\";\n+  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+\n+  EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n+\n+  Run({\"debug\", \"populate\", \"1\", \"key\", \"4\", \"SLOTS\", \"7999\", \"7999\"});\n+  Run({\"debug\", \"populate\", \"2\", \"key\", \"4\", \"SLOTS\", \"8000\", \"8000\"});\n+\n+  EXPECT_THAT(RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"7999\", \"8000\"}),\n+              RespArray(ElementsAre(\n+                  RespArray(ElementsAre(IntArg(7999), \"key_count\", IntArg(1), _, _, _, _)),\n+                  RespArray(ElementsAre(IntArg(8000), \"key_count\", IntArg(2), _, _, _, _)))));\n+  EXPECT_THAT(Run({\"dbsize\"}), IntArg(3));\n+\n+  // Move ownership over 8000 to other master\n+  config = absl::StrReplaceAll(config, {{\"8000\", \"7999\"}, {\"8001\", \"8000\"}});\n+  EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n+\n+  // Verify that keys for slot 8000 were deleted, while key for slot 7999 was kept\n+  ExpectConditionWithinTimeout([&]() { return CheckedInt({\"dbsize\"}) == 1; });\n+\n+  EXPECT_THAT(RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"7999\", \"8000\"}),\n+              RespArray(ElementsAre(\n+                  RespArray(ElementsAre(IntArg(7999), \"key_count\", IntArg(1), _, _, _, _)),\n+                  RespArray(ElementsAre(IntArg(8000), \"key_count\", IntArg(0), _, _, _, _)))));\n+}\n+\n TEST_F(ClusterFamilyTest, ClusterModeSelectNotAllowed) {\n   EXPECT_THAT(Run({\"select\", \"1\"}), ErrArg(\"SELECT is not allowed in cluster mode\"));\n   EXPECT_EQ(Run({\"select\", \"0\"}), \"OK\");\n@@ -604,15 +681,7 @@ TEST_F(ClusterFamilyTest, ClusterFirstConfigCallDropsEntriesNotOwnedByNode) {\n             \"OK\");\n \n   // Make sure `dbsize` all slots were removed\n-  constexpr absl::Duration kMaxTime = absl::Seconds(5);\n-  absl::Time deadline = absl::Now() + kMaxTime;\n-  while (deadline > absl::Now()) {\n-    if (CheckedInt({\"dbsize\"}) == 0) {\n-      break;\n-    }\n-    sleep(1);\n-  }\n-  EXPECT_LE(absl::Now(), deadline);\n+  ExpectConditionWithinTimeout([&]() { return CheckedInt({\"dbsize\"}) == 0; });\n }\n \n class ClusterFamilyEmulatedTest : public BaseFamilyTest {\n",
  "problem_statement": "Store cluster configuration in thread local storage\nThis will accelerate accessing cluster configuration's data, as it will no longer require shared mutex (which requires atomic operations)\n",
  "hints_text": "",
  "created_at": "2023-06-06T13:15:57Z",
  "modified_files": [
    "src/server/cluster/cluster_config.cc",
    "src/server/cluster/cluster_config.h",
    "src/server/cluster/cluster_family.cc",
    "src/server/cluster/cluster_family.h",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "src/server/cluster/cluster_config_test.cc",
    "src/server/cluster/cluster_family_test.cc"
  ]
}