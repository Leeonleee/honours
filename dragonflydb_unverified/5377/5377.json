{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5377,
  "instance_id": "dragonflydb__dragonfly-5377",
  "issue_numbers": [
    "5374"
  ],
  "base_commit": "f3189d031a949d0e88152bbebcab4b4b8a9c3c81",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex d34022a06cab..26362a9f8754 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -41,10 +41,10 @@ namespace {\n \n using CI = CommandId;\n \n-static const char kNxXxErr[] = \"XX and NX options at the same time are not compatible\";\n-static const char kLexRangeErr[] = \"min or max not valid string range item\";\n-static const char kFloatRangeErr[] = \"min or max is not a float\";\n-static const char kScoreNaN[] = \"resulting score is not a number (NaN)\";\n+const char kNxXxErr[] = \"XX and NX options at the same time are not compatible\";\n+const char kLexRangeErr[] = \"min or max not valid string range item\";\n+const char kFloatRangeErr[] = \"min or max is not a float\";\n+const char kScoreNaN[] = \"resulting score is not a number (NaN)\";\n \n using MScoreResponse = std::vector<std::optional<double>>;\n using ScoredMember = ZSetFamily::ScoredMember;\n@@ -104,9 +104,9 @@ bool IsListPack(const detail::RobjWrapper* robj_wrapper) {\n \n int ZsetDel(detail::RobjWrapper* robj_wrapper, std::string_view ele) {\n   if (IsListPack(robj_wrapper)) {\n-    unsigned char* eptr;\n     uint8_t* lp = (uint8_t*)robj_wrapper->inner_obj();\n-    if ((eptr = detail::ZzlFind(lp, ele, nullptr)) != nullptr) {\n+    unsigned char* eptr = detail::ZzlFind(lp, ele, nullptr);\n+    if (eptr) {\n       lp = lpDeleteRangeWithEntry(lp, &eptr, 2);\n       robj_wrapper->set_inner_obj(lp);\n       return 1;\n@@ -185,7 +185,7 @@ OpResult<DbSlice::ItAndUpdater> FindZEntry(const ZSetFamily::ZParams& zparams,\n   return DbSlice::ItAndUpdater{add_res.it, add_res.exp_it, std::move(add_res.post_updater)};\n }\n \n-enum class Action { RANGE = 0, REMOVE = 1, POP = 2 };\n+enum class Action : uint8_t { RANGE = 0, REMOVE = 1, POP = 2 };\n \n class IntervalVisitor {\n  public:\n@@ -253,8 +253,8 @@ class IntervalVisitor {\n \n void IntervalVisitor::operator()(const ZSetFamily::IndexInterval& ii) {\n   unsigned long llen = robj_wrapper_->Size();\n-  int32_t start = ii.first;\n-  int32_t end = ii.second;\n+  int64_t start = ii.first;\n+  int64_t end = ii.second;\n \n   if (start < 0)\n     start = llen + start;\n@@ -326,6 +326,7 @@ void IntervalVisitor::operator()(ZSetFamily::TopNScored sc) {\n void IntervalVisitor::ActionRange(unsigned start, unsigned end) {\n   if (params_.limit == 0)\n     return;\n+\n   // Calculate new start and end given offset and limit.\n   start += params_.offset;\n   end = static_cast<uint32_t>(min(1ULL * start + params_.limit - 1, 1ULL * end));\n@@ -1343,7 +1344,7 @@ OpResult<unsigned> OpLexCount(const OpArgs& op_args, string_view key,\n   return count;\n }\n \n-OpResult<unsigned> OpRem(const OpArgs& op_args, string_view key, facade::ArgRange members) {\n+OpResult<unsigned> OpRem(const OpArgs& op_args, string_view key, const facade::ArgRange& members) {\n   auto& db_slice = op_args.GetDbSlice();\n   auto res_it = db_slice.FindMutable(op_args.db_cntx, key, OBJ_ZSET);\n   if (!res_it)\n@@ -1365,7 +1366,7 @@ OpResult<unsigned> OpRem(const OpArgs& op_args, string_view key, facade::ArgRang\n }\n \n OpResult<MScoreResponse> OpMScore(const OpArgs& op_args, string_view key,\n-                                  facade::ArgRange members) {\n+                                  const facade::ArgRange& members) {\n   auto res_it = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_ZSET);\n \n   if (res_it.status() == OpStatus::KEY_NOTFOUND) {\n@@ -1395,8 +1396,7 @@ OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t\n   if (!find_res)\n     return find_res.status();\n \n-  auto it = find_res.value();\n-  const PrimeValue& pv = it->second;\n+  const PrimeValue& pv = (*find_res)->second;\n   StringVec res;\n   char buf[128];\n \n@@ -1558,7 +1558,7 @@ void ZBooleanOperation(CmdArgList args, string_view cmd, bool is_union, bool sto\n   }\n }\n \n-enum class FilterShards { NO = 0, YES = 1 };\n+enum class FilterShards : uint8_t { NO = 0, YES = 1 };\n \n OpResult<ScoredArray> ZPopMinMaxInternal(std::string_view key, FilterShards should_filter_shards,\n                                          uint32 count, bool reverse, Transaction* tx) {\n@@ -2470,11 +2470,11 @@ void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n }\n \n void ZSetFamily::ZPopMax(CmdArgList args, const CommandContext& cmd_cntx) {\n-  ZPopMinMaxFromArgs(std::move(args), true, cmd_cntx.tx, cmd_cntx.rb);\n+  ZPopMinMaxFromArgs(args, true, cmd_cntx.tx, cmd_cntx.rb);\n }\n \n void ZSetFamily::ZPopMin(CmdArgList args, const CommandContext& cmd_cntx) {\n-  ZPopMinMaxFromArgs(std::move(args), false, cmd_cntx.tx, cmd_cntx.rb);\n+  ZPopMinMaxFromArgs(args, false, cmd_cntx.tx, cmd_cntx.rb);\n }\n \n void ZSetFamily::ZLexCount(CmdArgList args, const CommandContext& cmd_cntx) {\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 11304d5316ba..2fa35f127391 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -25,7 +25,7 @@ class ZSetFamily {\n  public:\n   static void Register(CommandRegistry* registry);\n \n-  using IndexInterval = std::pair<int32_t, int32_t>;\n+  using IndexInterval = std::pair<int64_t, int64_t>;\n   using MScoreResponse = std::vector<std::optional<double>>;\n \n   struct Bound {\n@@ -37,7 +37,7 @@ class ZSetFamily {\n \n   struct LexBound {\n     std::string_view val;\n-    enum Type { PLUS_INF, MINUS_INF, OPEN, CLOSED } type = CLOSED;\n+    enum Type : uint8_t { PLUS_INF, MINUS_INF, OPEN, CLOSED } type = CLOSED;\n   };\n \n   using LexInterval = std::pair<LexBound, LexBound>;\n@@ -49,7 +49,7 @@ class ZSetFamily {\n     uint32_t limit = UINT32_MAX;\n     bool with_scores = false;\n     bool reverse = false;\n-    enum IntervalType { LEX, RANK, SCORE } interval_type = RANK;\n+    enum IntervalType : uint8_t { LEX, RANK, SCORE } interval_type = RANK;\n     std::optional<std::string_view> store_key = std::nullopt;\n   };\n \n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex bcd02715d4d4..c239f3f21c95 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -305,7 +305,7 @@ TEST_F(ZSetFamilyTest, ZMScoreNonExistentKeys) {\n               ElementsAre(ArgType(RespExpr::NIL), ArgType(RespExpr::NIL), ArgType(RespExpr::NIL)));\n }\n \n-TEST_F(ZSetFamilyTest, ZRangeRank) {\n+TEST_F(ZSetFamilyTest, ByScore) {\n   Run({\"zadd\", \"x\", \"1.1\", \"a\", \"2.1\", \"b\"});\n   EXPECT_THAT(Run({\"zrangebyscore\", \"x\", \"0\", \"(1.1\"}), ArrLen(0));\n   EXPECT_THAT(Run({\"zrangebyscore\", \"x\", \"-inf\", \"1.1\", \"limit\", \"0\", \"10\"}), \"a\");\n@@ -506,6 +506,9 @@ TEST_F(ZSetFamilyTest, ZRange) {\n   resp = Run({\"zrange\", \"key\", \"+\", \"[cool\", \"BYLEX\", \"LIMIT\", \"2\", \"2\", \"REV\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"great\", \"foo\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"5\", \"2147483648\"});\n+  ASSERT_THAT(resp, RespElementsAre(\"foo\", \"great\", \"hill\", \"omega\"));\n }\n \n TEST_F(ZSetFamilyTest, ZRevRange) {\n",
  "problem_statement": "zrange fails when range values have more than 10 significant digits\n**Describe the bug**\nIf the start or stop index value passed to `zrange` has greater than 10 significant digits it will error\n\n\n**To Reproduce**\n```txl\nzadd foobar 11111111111 test1 11111111112 test2\n(integer) 2\n127.0.0.1:6379> zrange foobar 0 11111111111\n(error) ERR value is not an integer or out of range\n```\n\n**Expected behavior**\nIf stop is greater than the last index, it should return all of the elements from start to the end of the set as described in the redis docs. The above code will work with out error in redis\n\n**Screenshots**\nIf applicable, add screenshots to help explain your problem.\n\n**Environment (please complete the following information):**\n - OS: Manjaro / Arch\n - Kernel: `Linux ronin 5.10.235-1-MANJARO #1 SMP PREEMPT Fri Mar 28 09:51:32 UTC 2025 x86_64 GNU/Linux`\n - Containerized?: Containerized / kubernetes\n - Dragonfly Version: 1.31.0\n\n\n\n**Additional context**\nWe use epoc timestamps with millisecond level precision and this causes an error with dragonfly. the same code was working while we were on redis. \n\nAdditionally, the dragonfly documentation indicates that a set can contain 2B elements, but it would appear it would not be possible to read the value after the set has grown past a certain size\n\nWe recognize that the code that exposed the problem is conflating scores via `zadd` and indexes via `zrange` and we should be using `zrangebyscore`. We will change this on our end, but it did not error when we were using stock redis, and would return the data we expected it to return\n",
  "hints_text": "Thanks for reporting it. What do you mean it's not possible to read the\r\nvalue?\r\n\r\nRoman Gershman\r\nCTO\r\n---\r\n*www.dragonflydb.io <http://www.dragonflydb.io>*\r\n\r\nOn Fri, Jun 27, 2025, 9:43\u202fPM Eric Satterwhite ***@***.***>\r\nwrote:\r\n\r\n> *esatterwhite* created an issue (dragonflydb/dragonfly#5374)\r\n> <https://github.com/dragonflydb/dragonfly/issues/5374>\r\n>\r\n> *Describe the bug*\r\n> If the start or stop index value passed to zrange has greater than 10\r\n> significant digits it will error\r\n>\r\n> *To Reproduce*\r\n>\r\n> zadd foobar 11111111111 test1 11111111112 test2\r\n> (integer) 2127.0.0.1:6379> zrange foobar 0 11111111111\r\n> (error) ERR value is not an integer or out of range\r\n>\r\n> *Expected behavior*\r\n> If stop is greater than the last index, it should return all of the\r\n> elements from start to the end of the set as described in the redis docs.\r\n> The above code will work with out error in redis\r\n>\r\n> *Screenshots*\r\n> If applicable, add screenshots to help explain your problem.\r\n>\r\n> *Environment (please complete the following information):*\r\n>\r\n>    - OS: Manjaro / Arch\r\n>    - Kernel: Linux ronin 5.10.235-1-MANJARO #1\r\n>    <https://github.com/dragonflydb/dragonfly/issues/1> SMP PREEMPT Fri\r\n>    Mar 28 09:51:32 UTC 2025 x86_64 GNU/Linux\r\n>    - Containerized?: Containerized / kubernetes\r\n>    - Dragonfly Version: 1.31.0\r\n>\r\n> *Additional context*\r\n> We use epoc timestamps with millisecond level precision and this causes an\r\n> error with dragonfly. the same code was working while we were on redis.\r\n>\r\n> Additionally, the dragonfly documentation indicates that a set can contain\r\n> 2B elements, but it would appear it would not be possible to read the value\r\n> after the set has grown past a certain size\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/dragonflydb/dragonfly/issues/5374>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AA4BFCA7JEOWRC7PZ364FJL3FWGFTAVCNFSM6AAAAACAJWFKQOVHI2DSMVQWIX3LMV43ASLTON2WKOZTGE4DGNZXHAYTCMA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n\nThe value of the index would be well beyond 10 significant digits and you get this error and would  not be able get the data you are trying to access at those indices",
  "created_at": "2025-06-29T06:09:28Z",
  "modified_files": [
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}