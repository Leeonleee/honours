diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index 9ed4840b56d3..84a9d9318acd 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -798,6 +798,7 @@ void Service::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*>
   config_registry.Register("dbnum");  // equivalent to databases in redis.
   config_registry.Register("dir");
   config_registry.RegisterMutable("masterauth");
+  config_registry.RegisterMutable("masteruser");
   config_registry.RegisterMutable("tcp_keepalive");
   config_registry.RegisterMutable("replica_partial_sync");
   config_registry.RegisterMutable("max_eviction_per_heartbeat");
@@ -1131,6 +1132,13 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)
     if (auto& exec_info = dfly_cntx->conn_state.exec_info; exec_info.IsCollecting())
       exec_info.state = ConnectionState::ExecInfo::EXEC_ERROR;
 
+    // We need to skip this because ACK's should not be replied to
+    // Bonus points because this allows to continue replication with ACL users who got
+    // their access revoked and reinstated
+    if (cid->name() == "REPLCONF" && absl::EqualsIgnoreCase(ArgS(args_no_cmd, 0), "ACK")) {
+      LOG(ERROR) << "Tried to reply to REPLCONF";
+      return;
+    }
     dfly_cntx->SendError(std::move(*err));
     return;
   }
@@ -1233,6 +1241,12 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionCo
   DCHECK(!cid->Validate(tail_args));
 
   if (auto err = VerifyCommandExecution(cid, cntx, tail_args); err) {
+    // We need to skip this because ACK's should not be replied to
+    // Bonus points because this allows to continue replication with ACL users who got
+    // their access revoked and reinstated
+    if (cid->name() == "REPLCONF" && absl::EqualsIgnoreCase(ArgS(tail_args, 0), "ACK")) {
+      return true;
+    }
     cntx->SendError(std::move(*err));
     return true;  // return false only for internal error aborts
   }
diff --git a/src/server/protocol_client.cc b/src/server/protocol_client.cc
index 93cf78c282e7..7cbb47ce1d3e 100644
--- a/src/server/protocol_client.cc
+++ b/src/server/protocol_client.cc
@@ -34,6 +34,7 @@ extern "C" {
 #include "util/tls/tls_socket.h"
 #endif
 
+ABSL_FLAG(std::string, masteruser, "", "username for authentication with master");
 ABSL_FLAG(std::string, masterauth, "", "password for authentication with master");
 ABSL_FLAG(bool, tls_replication, false, "Enable TLS on replication");
 
@@ -236,9 +237,12 @@ error_code ProtocolClient::ConnectAndAuth(std::chrono::milliseconds connect_time
    CHECK_EQ(0, setsockopt(sock_->native_handle(), IPPROTO_TCP, TCP_KEEPCNT, &intv, sizeof(intv)));
   */
   auto masterauth = absl::GetFlag(FLAGS_masterauth);
+  auto masteruser = absl::GetFlag(FLAGS_masteruser);
+  ResetParser(false);
   if (!masterauth.empty()) {
-    ResetParser(false);
-    RETURN_ON_ERR(SendCommandAndReadResponse(StrCat("AUTH ", masterauth)));
+    auto cmd = masteruser.empty() ? StrCat("AUTH ", masterauth)
+                                  : StrCat("AUTH ", masteruser, " ", masterauth);
+    RETURN_ON_ERR(SendCommandAndReadResponse(cmd));
     PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply("OK"));
   }
   return error_code{};
diff --git a/src/server/replica.cc b/src/server/replica.cc
index 597f1cbcd51c..ad832a249c40 100644
--- a/src/server/replica.cc
+++ b/src/server/replica.cc
@@ -3,7 +3,10 @@
 //
 #include "server/replica.h"
 
+#include <chrono>
+
 #include "absl/strings/match.h"
+#include "util/fibers/fiber2.h"
 
 extern "C" {
 #include "redis/rdb.h"
@@ -73,6 +76,7 @@ Replica::Replica(string host, uint16_t port, Service* se, std::string_view id)
 Replica::~Replica() {
   sync_fb_.JoinIfNeeded();
   acks_fb_.JoinIfNeeded();
+  acl_check_fb_.JoinIfNeeded();
 }
 
 static const char kConnErr[] = "could not connect to master: ";
@@ -140,12 +144,11 @@ void Replica::Stop() {
     state_mask_.store(0);  // Specifically ~R_ENABLED.
   });
 
-  waker_.notifyAll();
-
   // Make sure the replica fully stopped and did all cleanup,
   // so we can freely release resources (connections).
   sync_fb_.JoinIfNeeded();
   acks_fb_.JoinIfNeeded();
+  acl_check_fb_.JoinIfNeeded();
 }
 
 void Replica::Pause(bool pause) {
@@ -586,20 +589,21 @@ error_code Replica::ConsumeRedisStream() {
 
     io_buf.ConsumeInput(response->left_in_buffer);
     repl_offs_ += response->total_read;
-    waker_.notify();  // Notify to trigger ACKs.
+    replica_waker_.notify();  // Notify to trigger ACKs.
   }
 }
 
 error_code Replica::ConsumeDflyStream() {
   // Set new error handler that closes flow sockets.
   auto err_handler = [this](const auto& ge) {
+    // Trigger acl-checker
+    replica_waker_.notifyAll();
     // Make sure the flows are not in a state transition
     lock_guard lk{flows_op_mu_};
     DefaultErrorHandler(ge);
     for (auto& flow : shard_flows_) {
       flow->Cancel();
     }
-
     multi_shard_exe_->CancelAllBlockingEntities();
   };
   RETURN_ON_ERR(cntx_.SwitchErrorHandler(std::move(err_handler)));
@@ -621,7 +625,13 @@ error_code Replica::ConsumeDflyStream() {
     lock_guard lk{flows_op_mu_};
     shard_set->pool()->AwaitFiberOnAll(std::move(shard_cb));
   }
+
+  if (master_context_.version >= DflyVersion::VER3) {
+    acl_check_fb_ = fb2::Fiber("acl-check", &Replica::AclCheckFb, this);
+  }
+
   JoinDflyFlows();
+  acl_check_fb_.JoinIfNeeded();
 
   last_journal_LSNs_.emplace();
   for (auto& flow : shard_flows_) {
@@ -793,7 +803,7 @@ void DflyShardReplica::StableSyncDflyReadFb(Context* cntx) {
   }
 
   while (!cntx->IsCancelled()) {
-    waker_.await([&]() {
+    shard_replica_waker_.await([&]() {
       return ((trans_data_queue_.size() < kYieldAfterItemsInQueue) || cntx->IsCancelled());
     });
     if (cntx->IsCancelled())
@@ -824,7 +834,7 @@ void DflyShardReplica::StableSyncDflyReadFb(Context* cntx) {
         ExecuteTxWithNoShardSync(std::move(*tx_data), cntx);
       }
     }
-    waker_.notify();
+    shard_replica_waker_.notify();
   }
 }
 
@@ -845,12 +855,59 @@ void Replica::RedisStreamAcksFb() {
     }
     ack_offs_ = repl_offs_;
 
-    waker_.await_until(
+    replica_waker_.await_until(
         [&]() { return repl_offs_ > ack_offs_ + kAckRecordMaxInterval || cntx_.IsCancelled(); },
         next_ack_tp);
   }
 }
 
+class AclCheckerClient : public ProtocolClient {
+ public:
+  AclCheckerClient(ServerContext server, Context* cntx)
+      : ProtocolClient(std::move(server)), cntx_(cntx) {
+    Connect();
+  }
+
+  void CheckAclRoundTrip() {
+    if (auto ec = SendCommandAndReadResponse(StrCat("REPLCONF acl-check ", "0")); ec) {
+      cntx_->Cancel();
+      LOG(INFO) << "Error in REPLCONF acl-check: " << ec.message();
+    } else if (!CheckRespIsSimpleReply("OK")) {
+      cntx_->Cancel();
+      LOG(INFO) << "Error: " << ToSV(LastResponseArgs().front().GetBuf());
+    }
+  }
+
+ private:
+  void Connect() {
+    VLOG(1) << "Connecting with acl client";
+    auto ec = ConnectAndAuth(absl::GetFlag(FLAGS_master_connect_timeout_ms) * 1ms, cntx_);
+    if (ec) {
+      LOG(INFO) << "Failed to connect with acl client " << ec.message();
+      cntx_->Cancel();
+    }
+  }
+
+  Context* cntx_;
+};
+
+void Replica::AclCheckFb() {
+  // We need a new client with a different socket for acl-checks
+  // instead of using the ACK's fiber. This is because acks should
+  // not be replied (which makes them unusable for periodic ACL checks).
+  // Also there are N ACK fibers per replica instance while we only need
+  // one fiber to periodically check for ACL changes. Therefore,
+  // we decouple the logic via AclCheckFb.
+  AclCheckerClient acl_client(server(), &cntx_);
+
+  while (!cntx_.IsCancelled()) {
+    acl_client.CheckAclRoundTrip();
+    // We poll for ACL changes every second
+    replica_waker_.await_until([&]() { return cntx_.IsCancelled(); },
+                               std::chrono::steady_clock::now() + std::chrono::seconds(1));
+  }
+}
+
 void DflyShardReplica::StableSyncDflyAcksFb(Context* cntx) {
   constexpr size_t kAckRecordMaxInterval = 1024;
   std::chrono::duration ack_time_max_interval =
@@ -873,7 +930,7 @@ void DflyShardReplica::StableSyncDflyAcksFb(Context* cntx) {
     }
     ack_offs_ = current_offset;
 
-    waker_.await_until(
+    shard_replica_waker_.await_until(
         [&]() {
           return journal_rec_executed_.load(std::memory_order_relaxed) >
                      ack_offs_ + kAckRecordMaxInterval ||
@@ -922,7 +979,8 @@ void DflyShardReplica::InsertTxDataToShardResource(TransactionData&& tx_data) {
 
 void DflyShardReplica::StableSyncDflyExecFb(Context* cntx) {
   while (!cntx->IsCancelled()) {
-    waker_.await([&]() { return (!trans_data_queue_.empty() || cntx->IsCancelled()); });
+    shard_replica_waker_.await(
+        [&]() { return (!trans_data_queue_.empty() || cntx->IsCancelled()); });
     if (cntx->IsCancelled()) {
       return;
     }
@@ -930,7 +988,7 @@ void DflyShardReplica::StableSyncDflyExecFb(Context* cntx) {
     auto& data = trans_data_queue_.front();
     ExecuteTx(std::move(data.first), data.second, cntx);
     trans_data_queue_.pop();
-    waker_.notify();
+    shard_replica_waker_.notify();
   }
 }
 
@@ -1130,7 +1188,7 @@ void DflyShardReplica::JoinFlow() {
 
 void DflyShardReplica::Cancel() {
   CloseSocket();
-  waker_.notifyAll();
+  shard_replica_waker_.notifyAll();
 }
 
 }  // namespace dfly
diff --git a/src/server/replica.h b/src/server/replica.h
index e19d8070c7bb..f2182dc51710 100644
--- a/src/server/replica.h
+++ b/src/server/replica.h
@@ -102,6 +102,8 @@ class Replica : ProtocolClient {
   // Send DFLY ${kind} to the master instance.
   std::error_code SendNextPhaseRequest(std::string_view kind);
 
+  void AclCheckFb();
+
  private: /* Utility */
   struct PSyncResponse {
     // string - end of sync token (diskless)
@@ -148,7 +150,8 @@ class Replica : ProtocolClient {
   // In redis replication mode.
   util::fb2::Fiber sync_fb_;
   util::fb2::Fiber acks_fb_;
-  util::fb2::EventCount waker_;
+  util::fb2::Fiber acl_check_fb_;
+  util::fb2::EventCount replica_waker_;
 
   std::vector<std::unique_ptr<DflyShardReplica>> shard_flows_;
   // A vector of the last executer LSNs when a replication is interrupted.
@@ -214,7 +217,7 @@ class DflyShardReplica : public ProtocolClient {
 
   std::queue<std::pair<TransactionData, bool>> trans_data_queue_;
   static constexpr size_t kYieldAfterItemsInQueue = 50;
-  util::fb2::EventCount waker_;  // waker for trans_data_queue_
+  util::fb2::EventCount shard_replica_waker_;  // waker for trans_data_queue_
   bool use_multi_shard_exe_sync_;
 
   std::unique_ptr<JournalExecutor> executor_;
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index b3e337f5e7b4..c242146dbd11 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -2480,6 +2480,9 @@ void ServerFamily::ReplConf(CmdArgList args, ConnectionContext* cntx) {
       VLOG(2) << "Received client ACK=" << ack;
       cntx->replication_flow->last_acked_lsn = ack;
       return;
+    } else if (cmd == "ACL-CHECK") {
+      cntx->SendOk();
+      return;
     } else {
       VLOG(1) << "Error " << cmd << " " << arg << " " << args.size();
       goto err;
diff --git a/src/server/version.h b/src/server/version.h
index b975c131b5b0..fbf4e9af5625 100644
--- a/src/server/version.h
+++ b/src/server/version.h
@@ -29,8 +29,12 @@ enum class DflyVersion {
   // Supports limited partial sync
   VER2,
 
+  // 1.15 < ver
+  // ACL with user replication
+  VER3,
+
   // Always points to the latest version
-  CURRENT_VER = VER2,
+  CURRENT_VER = VER3,
 };
 
 }  // namespace dfly
