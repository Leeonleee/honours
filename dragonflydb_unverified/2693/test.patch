diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py
index 1baa3a235a8c..aec109d0da98 100644
--- a/tests/dragonfly/replication_test.py
+++ b/tests/dragonfly/replication_test.py
@@ -2058,3 +2058,41 @@ async def save_replica():
     assert not await is_saving(c_replica)
 
     await disconnect_clients(c_master, *[c_replica])
+
+
+@pytest.mark.asyncio
+async def test_user_acl_replication(df_local_factory):
+    master = df_local_factory.create(proactor_threads=4)
+    replica = df_local_factory.create(proactor_threads=4)
+    df_local_factory.start_all([master, replica])
+
+    c_master = master.client()
+    await c_master.execute_command("ACL SETUSER tmp >tmp ON +ping +dfly +replconf")
+    await c_master.execute_command("SET foo bar")
+    assert 1 == await c_master.execute_command("DBSIZE")
+
+    c_replica = replica.client()
+    await c_replica.execute_command("CONFIG SET masteruser tmp")
+    await c_replica.execute_command("CONFIG SET masterauth tmp")
+    await c_replica.execute_command(f"REPLICAOF localhost {master.port}")
+
+    await wait_available_async(c_replica)
+    assert 1 == await c_replica.execute_command("DBSIZE")
+
+    # revoke acl's from tmp
+    await c_master.execute_command("ACL SETUSER tmp -replconf")
+    async with async_timeout.timeout(5):
+        while True:
+            role = await c_replica.execute_command("INFO REPLICATION")
+            # fancy of way of extracting the field master_link_status
+            is_down = role.split("\r
")[4].split(":")[1]
+            if is_down == "down":
+                break
+            await asyncio.sleep(1)
+
+    await c_master.execute_command("SET bar foo")
+
+    # reinstate and let replication continue
+    await c_master.execute_command("ACL SETUSER tmp +replconf")
+    await check_all_replicas_finished([c_replica], c_master, 5)
+    assert 2 == await c_replica.execute_command("DBSIZE")
