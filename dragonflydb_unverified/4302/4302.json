{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4302,
  "instance_id": "dragonflydb__dragonfly-4302",
  "issue_numbers": [
    "4294"
  ],
  "base_commit": "b37287bf14c2af8a152a8a29c1005596125be940",
  "patch": "diff --git a/src/core/qlist.cc b/src/core/qlist.cc\nindex 0d676069b59a..f8cf6fedec1f 100644\n--- a/src/core/qlist.cc\n+++ b/src/core/qlist.cc\n@@ -371,6 +371,7 @@ string QList::Pop(Where where) {\n \n   /* The head and tail should never be compressed */\n   DCHECK(node->encoding != QUICKLIST_NODE_ENCODING_LZF);\n+  DCHECK(head_->prev->next == nullptr);\n \n   string res;\n   if (ABSL_PREDICT_FALSE(QL_NODE_IS_PLAIN(node))) {\n@@ -390,6 +391,7 @@ string QList::Pop(Where where) {\n     }\n     DelPackedIndex(node, pos);\n   }\n+  DCHECK(head_ == nullptr || head_->prev->next == nullptr);\n   return res;\n }\n \n@@ -479,11 +481,13 @@ bool QList::PushSentinel(string_view value, Where where) {\n     if (len_ == 1) {  // sanity check\n       DCHECK_EQ(malloc_size_, orig->sz);\n     }\n+    DCHECK(head_->prev->next == nullptr);\n     return false;\n   }\n \n   quicklistNode* node = CreateFromSV(QUICKLIST_NODE_CONTAINER_PACKED, value);\n   InsertNode(orig, node, opt);\n+  DCHECK(head_->prev->next == nullptr);\n   return true;\n }\n \n@@ -837,13 +841,15 @@ quicklistNode* QList::ListpackMerge(quicklistNode* a, quicklistNode* b) {\n void QList::DelNode(quicklistNode* node) {\n   if (node->next)\n     node->next->prev = node->prev;\n-  if (node->prev)\n-    node->prev->next = node->next;\n \n   if (node == head_) {\n     head_ = node->next;\n-  } else if (node == head_->prev) {  // tail\n-    head_->prev = node->prev;\n+  } else {\n+    // for non-head nodes, update prev->next to point to node->next\n+    // (If node==head, prev is tail and should always point to NULL).\n+    node->prev->next = node->next;\n+    if (node == head_->prev)  // tail\n+      head_->prev = node->prev;\n   }\n \n   /* Update len first, so in Compress we know exactly len */\n",
  "test_patch": "diff --git a/src/core/qlist_test.cc b/src/core/qlist_test.cc\nindex 9e5d67c07fff..64d1b52788ea 100644\n--- a/src/core/qlist_test.cc\n+++ b/src/core/qlist_test.cc\n@@ -282,6 +282,15 @@ TEST_F(QListTest, CompressionPlain) {\n   EXPECT_EQ(500, i);\n }\n \n+TEST_F(QListTest, LargeValues) {\n+  string val(100000, 'a');\n+  ql_.Push(val, QList::HEAD);\n+  ql_.Push(val, QList::HEAD);\n+  ql_.Pop(QList::HEAD);\n+  auto items = ToItems();\n+  EXPECT_THAT(items, ElementsAre(val));\n+}\n+\n using FillCompress = tuple<int, unsigned>;\n \n class PrintToFillCompress {\ndiff --git a/tests/dragonfly/seeder/script-genlib.lua b/tests/dragonfly/seeder/script-genlib.lua\nindex 45d672a0a199..2203df175f32 100644\n--- a/tests/dragonfly/seeder/script-genlib.lua\n+++ b/tests/dragonfly/seeder/script-genlib.lua\n@@ -56,9 +56,7 @@ end\n \n function LG_funcs.add_list(key, keys)\n     local is_huge = keys[key]\n-    --- TODO -- investigate why second case of replication_test_all fails\n-    --- we somehow create a quicklist that is circular and we deadlock\n-    redis.apcall('LPUSH', key, unpack(randstr_sequence(false)))\n+    redis.apcall('LPUSH', key, unpack(randstr_sequence(is_huge)))\n end\n \n function LG_funcs.mod_list(key, keys)\n",
  "problem_statement": "circular dependency in quicklist nodes causes deadlock\nIt was discovered while pushing huge list entries in one of my PR's. https://github.com/dragonflydb/dragonfly/pull/4262/files#diff-35fc27c757d9b3830899712b367143f5c61f801b8f252b7bfa6e59bfbde6da49R59 \r\n\r\nIt's easy to reproduce in `test_replication_all`  case `(2, 2 * [1], dict(key_target=1_000, huge_value_percentage=2), 500)`\r\n\r\n![Screenshot from 2024-12-11 15-34-03](https://github.com/user-attachments/assets/10409d11-745f-402a-9199-dd5099b15743)\r\n\n",
  "hints_text": "How can I reproduce exactly?\n> How can I reproduce exactly?\r\n\r\nhttps://github.com/dragonflydb/dragonfly/pull/4262/files#diff-f41a28e79426b76916ad0fb750e102f83955a92be0f24dda7ae4fda79d74ca8cR52\r\n\r\nUse the test case above ^^ and https://github.com/dragonflydb/dragonfly/pull/4262/files#diff-35fc27c757d9b3830899712b367143f5c61f801b8f252b7bfa6e59bfbde6da49R61 and change \r\n\r\nfrom `redis.apcall('LPUSH', key, unpack(randstr_sequence(false)))` to\r\n`redis.apcall('LPUSH', key, unpack(randstr_sequence(is_huge))) and it will `deadlock` after a few runs (for me every 3-4).\r\n\r\nThen once it deadlocks `pgrep dragon and then gdb -p port_number`\n@kostasrim so I should use the kpr1 branch?\r\n\nI tried to follow instructions and it does not work for me. Can you please create a branch for me where I can run test_replication_all to reproduce it?\r\n\r\nThanks\n@romange yes yes give me a few minutes though\n@romange https://github.com/dragonflydb/dragonfly/pull/4300\nThank you!\nLet me know if you have any issue, I tried it locally and it failed immediately ",
  "created_at": "2024-12-12T13:00:12Z",
  "modified_files": [
    "src/core/qlist.cc"
  ],
  "modified_test_files": [
    "src/core/qlist_test.cc",
    "tests/dragonfly/seeder/script-genlib.lua"
  ]
}