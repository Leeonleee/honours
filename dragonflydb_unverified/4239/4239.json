{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4239,
  "instance_id": "dragonflydb__dragonfly-4239",
  "issue_numbers": [
    "3830"
  ],
  "base_commit": "91aff49fcde9d12a787d095231a4bd10df28fbe2",
  "patch": "diff --git a/src/redis/t_stream.c b/src/redis/t_stream.c\nindex 90712b09a71b..7c79e919bc54 100644\n--- a/src/redis/t_stream.c\n+++ b/src/redis/t_stream.c\n@@ -274,7 +274,7 @@ void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_i\n         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n         *edge_id = first ? max_id : min_id;\n     }\n-\n+    streamIteratorStop(&si);\n }\n \n /* Trim the stream 's' according to args->trim_strategy, and return the\n@@ -336,7 +336,7 @@ int64_t streamTrim(stream *s, streamAddTrimArgs *args) {\n             streamDecodeID(ri.key, &master_id);\n \n             /* Read last ID. */\n-            streamID last_id;\n+            streamID last_id = {0, 0};\n             lpGetEdgeStreamID(lp, 0, &master_id, &last_id);\n \n             /* We can remove the entire node id its last ID < 'id' */\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 4e846a54aea1..04608d4fa902 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -1568,11 +1568,15 @@ OpResult<ClaimInfo> OpAutoClaim(const OpArgs& op_args, string_view key, const Cl\n     streamDecodeID(ri.key, &id);\n \n     if (!streamEntryExists(stream, &id)) {\n+      // TODO: to propagate this change to replica as XCLAIM command\n+      // - since we delete it from NACK. See streamPropagateXCLAIM call.\n       raxRemove(group->pel, ri.key, ri.key_len, nullptr);\n       raxRemove(nack->consumer->pel, ri.key, ri.key_len, nullptr);\n       streamFreeNACK(nack);\n       result.deleted_ids.push_back(id);\n       raxSeek(&ri, \">=\", ri.key, ri.key_len);\n+\n+      count--; /* Count is a limit of the command response size. */\n       continue;\n     }\n \n@@ -1603,6 +1607,7 @@ OpResult<ClaimInfo> OpAutoClaim(const OpArgs& op_args, string_view key, const Cl\n \n     AppendClaimResultItem(result, stream, id);\n     count--;\n+    // TODO: propagate xclaim to replica\n   }\n \n   raxNext(&ri);\n@@ -3229,8 +3234,8 @@ void StreamFamily::XAutoClaim(CmdArgList args, const CommandContext& cmd_cntx) {\n         if (!absl::SimpleAtoi(arg, &opts.count)) {\n           return rb->SendError(kInvalidIntErr);\n         }\n-        if (opts.count <= 0) {\n-          return rb->SendError(\"COUNT must be > 0\");\n+        if (opts.count <= 0 || opts.count >= (1L << 18)) {\n+          return rb->SendError(\"COUNT must be > 0 and less than 2^18\");\n         }\n         continue;\n       }\n",
  "test_patch": "diff --git a/src/facade/facade_test.h b/src/facade/facade_test.h\nindex 4dfdeb7950a5..94cada6dc3f6 100644\n--- a/src/facade/facade_test.h\n+++ b/src/facade/facade_test.h\n@@ -83,6 +83,10 @@ MATCHER_P(RespArray, value, \"\") {\n       result_listener);\n }\n \n+template <typename... Args> auto RespElementsAre(const Args&... matchers) {\n+  return RespArray(::testing::ElementsAre(matchers...));\n+}\n+\n inline bool operator==(const RespExpr& left, std::string_view s) {\n   return left.type == RespExpr::STRING && ToSV(left.GetBuf()) == s;\n }\ndiff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 3c37f5da2722..3bd43ea876dc 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -1074,6 +1074,94 @@ TEST_F(StreamFamilyTest, XInfoStream) {\n                           \"pel-count\", IntArg(11), \"pending\", ArrLen(11)));\n }\n \n+TEST_F(StreamFamilyTest, AutoClaimPelItemsFromAnotherConsumer) {\n+  auto resp = Run({\"xadd\", \"mystream\", \"*\", \"a\", \"1\"});\n+  string id1 = resp.GetString();\n+  resp = Run({\"xadd\", \"mystream\", \"*\", \"b\", \"2\"});\n+  string id2 = resp.GetString();\n+  resp = Run({\"xadd\", \"mystream\", \"*\", \"c\", \"3\"});\n+  string id3 = resp.GetString();\n+  resp = Run({\"xadd\", \"mystream\", \"*\", \"d\", \"4\"});\n+  string id4 = resp.GetString();\n+\n+  Run({\"XGROUP\", \"CREATE\", \"mystream\", \"mygroup\", \"0\"});\n+\n+  // Consumer 1 reads item 1 from the stream without acknowledgements.\n+  // Consumer 2 then claims pending item 1 from the PEL of consumer 1\n+  resp = Run(\n+      {\"XREADGROUP\", \"GROUP\", \"mygroup\", \"consumer1\", \"COUNT\", \"1\", \"STREAMS\", \"mystream\", \">\"});\n+\n+  auto match_a1 = RespElementsAre(\"a\", \"1\");\n+  ASSERT_THAT(resp, RespElementsAre(\"mystream\", RespElementsAre(RespElementsAre(id1, match_a1))));\n+\n+  AdvanceTime(200);  // Advance time to greater time than the idle time in the autoclaim (10)\n+  resp = Run({\"XAUTOCLAIM\", \"mystream\", \"mygroup\", \"consumer2\", \"10\", \"-\", \"COUNT\", \"1\"});\n+\n+  EXPECT_THAT(resp, RespElementsAre(\"0-0\", ArrLen(1), ArrLen(0)));\n+  EXPECT_THAT(resp.GetVec()[1], RespElementsAre(RespElementsAre(id1, match_a1)));\n+\n+  Run({\"XREADGROUP\", \"GROUP\", \"mygroup\", \"consumer1\", \"COUNT\", \"3\", \"STREAMS\", \"mystream\", \">\"});\n+  AdvanceTime(200);\n+\n+  // Delete item 2 from the stream.Now consumer 1 has PEL that contains\n+  // only item 3. Try to use consumer 2 to claim the deleted item 2\n+  // from the PEL of consumer 1, this should return nil\n+  resp = Run({\"XDEL\", \"mystream\", id2});\n+  ASSERT_THAT(resp, IntArg(1));\n+\n+  // id1 and id3 are self - claimed here but not id2('count' was set to 3)\n+  // we make sure id2 is indeed skipped(the cursor points to id4)\n+  resp = Run({\"XAUTOCLAIM\", \"mystream\", \"mygroup\", \"consumer2\", \"10\", \"-\", \"COUNT\", \"3\"});\n+  auto match_id1_a1 = RespElementsAre(id1, match_a1);\n+  auto match_id3_c3 = RespElementsAre(id3, RespElementsAre(\"c\", \"3\"));\n+  ASSERT_THAT(resp, RespElementsAre(id4, RespElementsAre(match_id1_a1, match_id3_c3),\n+                                    RespElementsAre(id2)));\n+  // Delete item 3 from the stream.Now consumer 1 has PEL that is empty.\n+  // Try to use consumer 2 to claim the deleted item 3 from the PEL\n+  // of consumer 1, this should return nil\n+  AdvanceTime(200);\n+\n+  ASSERT_THAT(Run({\"XDEL\", \"mystream\", id4}), IntArg(1));\n+\n+  // id1 and id3 are self - claimed here but not id2 and id4('count' is default 100)\n+  // we also test the JUSTID modifier here.note that, when using JUSTID,\n+  // deleted entries are returned in reply(consistent with XCLAIM).\n+  resp = Run({\"XAUTOCLAIM\", \"mystream\", \"mygroup\", \"consumer2\", \"10\", \"-\", \"JUSTID\"});\n+  ASSERT_THAT(resp, RespElementsAre(\"0-0\", RespElementsAre(id1, id3), RespElementsAre(id4)));\n+}\n+\n+TEST_F(StreamFamilyTest, AutoClaimDelCount) {\n+  Run({\"xadd\", \"x\", \"1-0\", \"f\", \"v\"});\n+  Run({\"xadd\", \"x\", \"2-0\", \"f\", \"v\"});\n+  Run({\"xadd\", \"x\", \"3-0\", \"f\", \"v\"});\n+  Run({\"XGROUP\", \"CREATE\", \"x\", \"grp\", \"0\"});\n+  auto resp = Run({\"XREADGROUP\", \"GROUP\", \"grp\", \"Alice\", \"STREAMS\", \"x\", \">\"});\n+\n+  auto m1 = RespElementsAre(\"1-0\", _);\n+  auto m2 = RespElementsAre(\"2-0\", _);\n+  auto m3 = RespElementsAre(\"3-0\", _);\n+  EXPECT_THAT(resp, RespElementsAre(\"x\", RespElementsAre(m1, m2, m3)));\n+\n+  EXPECT_THAT(Run({\"XDEL\", \"x\", \"1-0\"}), IntArg(1));\n+  EXPECT_THAT(Run({\"XDEL\", \"x\", \"2-0\"}), IntArg(1));\n+\n+  resp = Run({\"XAUTOCLAIM\", \"x\", \"grp\", \"Bob\", \"0\", \"0-0\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, RespElementsAre(\"2-0\", ArrLen(0), RespElementsAre(\"1-0\")));\n+\n+  resp = Run({\"XAUTOCLAIM\", \"x\", \"grp\", \"Bob\", \"0\", \"2-0\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, RespElementsAre(\"3-0\", ArrLen(0), RespElementsAre(\"2-0\")));\n+\n+  resp = Run({\"XAUTOCLAIM\", \"x\", \"grp\", \"Bob\", \"0\", \"3-0\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, RespElementsAre(\n+                        \"0-0\", RespElementsAre(RespElementsAre(\"3-0\", RespElementsAre(\"f\", \"v\"))),\n+                        ArrLen(0)));\n+  resp = Run({\"xpending\", \"x\", \"grp\", \"-\", \"+\", \"10\", \"Alice\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+\n+  resp = Run({\"XAUTOCLAIM\", \"x\", \"grp\", \"Bob\", \"0\", \"3-0\", \"COUNT\", \"704505322\"});\n+  EXPECT_THAT(resp, ErrArg(\"COUNT\"));\n+}\n+\n TEST_F(StreamFamilyTest, XAddMaxSeq) {\n   Run({\"XADD\", \"x\", \"1-18446744073709551615\", \"f1\", \"v1\"});\n   auto resp = Run({\"XADD\", \"x\", \"1-*\", \"f2\", \"v2\"});\n",
  "problem_statement": "Unpatched Redis Sources (CVE-2022-33105)\nThe master branch of the dragonfly project contains unpatched sources from redis, in which CVE-2022-33105 was reported with high severity. The function `streamGetEdgeID` from `dragonfly/src/redis/t_stream.c` does not include patches and updates available in newer versions of redis, which can cause a memory leak. The fix for CVE can be found in this commit: [redis commit](https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef).\r\n\r\nTo ensure that all patches are applied, I recommend updating the redis files in the dragonfly project to the latest version.\r\n\r\nMy report was primarily based on a static analysis tool developed at [CAST](https://castech.am/), which flagged the potential vulnerability due to similarities in the codebase.\n",
  "hints_text": "Thanks for reporting this, we will sync t_stream with Valkey OSS.\n@adiholden we should schedule this task at some point",
  "created_at": "2024-12-02T09:59:54Z",
  "modified_files": [
    "src/redis/t_stream.c",
    "src/server/stream_family.cc"
  ],
  "modified_test_files": [
    "src/facade/facade_test.h",
    "src/server/stream_family_test.cc"
  ]
}