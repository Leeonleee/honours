diff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py
index f66d6bb058b8..396910ec50de 100644
--- a/tests/dragonfly/cluster_test.py
+++ b/tests/dragonfly/cluster_test.py
@@ -174,6 +174,17 @@ async def test_cluster_nodes(df_server, async_client):
 """
 
 
+@dfly_args({"proactor_threads": 4, "cluster_mode": "yes", "cluster_node_id": "inigo montoya"})
+async def test_cluster_node_id(df_local_factory: DflyInstanceFactory):
+    node = df_local_factory.create(port=BASE_PORT)
+    df_local_factory.start_all([node])
+
+    conn = node.client()
+    assert "inigo montoya" == await get_node_id(conn)
+
+    await close_clients(conn)
+
+
 @dfly_args({"proactor_threads": 4, "cluster_mode": "yes"})
 async def test_cluster_slot_ownership_changes(df_local_factory: DflyInstanceFactory):
     # Start and configure cluster with 2 nodes
@@ -306,7 +317,7 @@ async def test_cluster_slot_ownership_changes(df_local_factory: DflyInstanceFact
 
 # Tests that master commands to the replica are applied regardless of slot ownership
 @dfly_args({"proactor_threads": 4, "cluster_mode": "yes"})
-async def test_cluster_replica_sets_non_owned_keys(df_local_factory):
+async def test_cluster_replica_sets_non_owned_keys(df_local_factory: DflyInstanceFactory):
     # Start and configure cluster with 1 master and 1 replica, both own all slots
     master = df_local_factory.create(admin_port=BASE_PORT + 1000)
     replica = df_local_factory.create(admin_port=BASE_PORT + 1001)
@@ -570,14 +581,20 @@ async def test_cluster_blocking_command(df_server):
     await close_clients(c_master, c_master_admin)
 
 
+@pytest.mark.parametrize("set_cluster_node_id", [True, False])
 @dfly_args({"proactor_threads": 4, "cluster_mode": "yes"})
 async def test_cluster_native_client(
     df_local_factory: DflyInstanceFactory,
     df_seeder_factory: DflySeederFactory,
+    set_cluster_node_id: bool,
 ):
     # Start and configure cluster with 3 masters and 3 replicas
     masters = [
-        df_local_factory.create(port=BASE_PORT + i, admin_port=BASE_PORT + i + 1000)
+        df_local_factory.create(
+            port=BASE_PORT + i,
+            admin_port=BASE_PORT + i + 1000,
+            cluster_node_id=f"master{i}" if set_cluster_node_id else "",
+        )
         for i in range(3)
     ]
     df_local_factory.start_all(masters)
@@ -586,11 +603,17 @@ async def test_cluster_native_client(
     master_ids = await asyncio.gather(*(get_node_id(c) for c in c_masters_admin))
 
     replicas = [
-        df_local_factory.create(port=BASE_PORT + 100 + i, admin_port=BASE_PORT + i + 1100)
+        df_local_factory.create(
+            port=BASE_PORT + 100 + i,
+            admin_port=BASE_PORT + i + 1100,
+            cluster_node_id=f"replica{i}" if set_cluster_node_id else "",
+            replicaof=f"localhost:{BASE_PORT + i}",
+        )
         for i in range(3)
     ]
     df_local_factory.start_all(replicas)
     c_replicas = [replica.client() for replica in replicas]
+    await asyncio.gather(*(wait_available_async(c) for c in c_replicas))
     c_replicas_admin = [replica.admin_client() for replica in replicas]
     replica_ids = await asyncio.gather(*(get_node_id(c) for c in c_replicas_admin))
 
@@ -678,10 +701,12 @@ async def test_random_keys():
     await asyncio.gather(*(wait_available_async(c) for c in c_replicas))
 
     # Make sure that getting a value from a replica works as well.
-    replica_response = await client.execute_command(
-        "get", "key0", target_nodes=aioredis.RedisCluster.REPLICAS
-    )
-    assert "value" in replica_response.values()
+    # We use connections directly to NOT follow 'MOVED' error, as that will redirect to the master.
+    for c in c_replicas:
+        try:
+            assert await c.get("key0")
+        except redis.exceptions.ResponseError as e:
+            assert e.args[0].startswith("MOVED")
 
     # Push new config
     config = f"""
diff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py
index b2176dad5bf3..47c42c91440f 100644
--- a/tests/dragonfly/utility.py
+++ b/tests/dragonfly/utility.py
@@ -46,12 +46,8 @@ async def wait_available_async(client: aioredis.Redis, timeout=10):
     start = time.time()
     while (time.time() - start) < timeout:
         try:
-            await client.get("key")
+            await client.ping()
             return
-        except aioredis.ResponseError as e:
-            if "MOVED" in str(e):
-                # MOVED means we *can* serve traffic, but 'key' does not belong to an owned slot
-                return
         except aioredis.BusyLoadingError as e:
             assert "Dragonfly is loading the dataset in memory" in str(e)
 
