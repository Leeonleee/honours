{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5654,
  "instance_id": "dragonflydb__dragonfly-5654",
  "issue_numbers": [
    "5651"
  ],
  "base_commit": "fbbc16bd4cf1aa792b74b892f3053cca3967a4fe",
  "patch": "diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 76058babaf22..a2d98fdfe3bf 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -81,7 +81,8 @@ add_library(dragonfly_lib\n             cluster/cluster_config.cc cluster/cluster_family.cc cluster/incoming_slot_migration.cc\n             cluster/outgoing_slot_migration.cc cluster/cluster_defs.cc cluster/cluster_utility.cc\n             acl/user.cc acl/user_registry.cc acl/acl_family.cc\n-            acl/validator.cc)\n+            acl/validator.cc\n+            sharding.cc)\n \n if (DF_ENABLE_MEMORY_TRACKING)\n   target_compile_definitions(dragonfly_lib PRIVATE DFLY_ENABLE_MEMORY_TRACKING)\ndiff --git a/src/server/engine_shard.cc b/src/server/engine_shard.cc\nindex 50b6d72c7e8c..82aa2daddcb3 100644\n--- a/src/server/engine_shard.cc\n+++ b/src/server/engine_shard.cc\n@@ -45,12 +45,6 @@ ABSL_FLAG(int32_t, hz, 100,\n           \"Base frequency at which the server performs other background tasks. \"\n           \"Warning: not advised to decrease in production.\");\n \n-ABSL_FLAG(string, shard_round_robin_prefix, \"\",\n-          \"When non-empty, keys which start with this prefix are not distributed across shards \"\n-          \"based on their value but instead via round-robin. Use cautiously! This can efficiently \"\n-          \"support up to a few hundreds of prefixes. Note: prefix is looked inside hash tags when \"\n-          \"cluster mode is enabled.\");\n-\n ABSL_FLAG(string, tiered_prefix, \"\",\n           \"Enables tiered storage if set. \"\n           \"The string denotes the path and prefix of the files \"\n@@ -107,78 +101,6 @@ ShardMemUsage ReadShardMemUsage(float wasted_ratio) {\n   return usage;\n }\n \n-// RoundRobinSharder implements a way to distribute keys that begin with some prefix.\n-// Round-robin is disabled by default. It is not a general use-case optimization, but instead only\n-// reasonable when there are a few highly contended keys, which we'd like to spread between the\n-// shards evenly.\n-// When enabled, the distribution is done via hash table: the hash of the key is used to look into\n-// a pre-allocated vector. This means that collisions are possible, but are very unlikely if only\n-// a few keys are used.\n-// Thread safe.\n-class RoundRobinSharder {\n- public:\n-  static void Init() {\n-    round_robin_prefix_ = absl::GetFlag(FLAGS_shard_round_robin_prefix);\n-\n-    if (IsEnabled()) {\n-      // ~100k entries will consume 200kb per thread, and will allow 100 keys with < 2.5% collision\n-      // probability. Since this has a considerable footprint, we only allocate when enabled. We're\n-      // using a prime number close to 100k for better utilization.\n-      constexpr size_t kRoundRobinSize = 100'003;\n-      round_robin_shards_tl_cache_.resize(kRoundRobinSize);\n-      std::fill(round_robin_shards_tl_cache_.begin(), round_robin_shards_tl_cache_.end(),\n-                kInvalidSid);\n-\n-      util::fb2::LockGuard guard(mutex_);\n-      if (round_robin_shards_.empty()) {\n-        round_robin_shards_ = round_robin_shards_tl_cache_;\n-      }\n-    }\n-  }\n-\n-  static void Destroy() ABSL_LOCKS_EXCLUDED(mutex_) {\n-    round_robin_shards_tl_cache_.clear();\n-\n-    util::fb2::LockGuard guard(mutex_);\n-    round_robin_shards_.clear();\n-  }\n-\n-  static bool IsEnabled() {\n-    return !round_robin_prefix_.empty();\n-  }\n-\n-  static optional<ShardId> TryGetShardId(string_view key, XXH64_hash_t key_hash) {\n-    DCHECK(!round_robin_shards_tl_cache_.empty());\n-\n-    if (!absl::StartsWith(key, round_robin_prefix_)) {\n-      return nullopt;\n-    }\n-\n-    size_t index = key_hash % round_robin_shards_tl_cache_.size();\n-    ShardId sid = round_robin_shards_tl_cache_[index];\n-\n-    if (sid == kInvalidSid) {\n-      util::fb2::LockGuard guard(mutex_);\n-      sid = round_robin_shards_[index];\n-      if (sid == kInvalidSid) {\n-        sid = next_shard_;\n-        round_robin_shards_[index] = sid;\n-        next_shard_ = (next_shard_ + 1) % shard_set->size();\n-      }\n-      round_robin_shards_tl_cache_[index] = sid;\n-    }\n-\n-    return sid;\n-  }\n-\n- private:\n-  static thread_local string round_robin_prefix_;\n-  static thread_local vector<ShardId> round_robin_shards_tl_cache_;\n-  static vector<ShardId> round_robin_shards_ ABSL_GUARDED_BY(mutex_);\n-  static ShardId next_shard_ ABSL_GUARDED_BY(mutex_);\n-  static fb2::Mutex mutex_;\n-};\n-\n bool HasContendedLocks(ShardId shard_id, Transaction* trx, const DbTable* table) {\n   auto is_contended = [table](LockFp fp) { return table->trans_locks.Find(fp)->IsContended(); };\n \n@@ -199,12 +121,6 @@ bool HasContendedLocks(ShardId shard_id, Transaction* trx, const DbTable* table)\n   return false;\n }\n \n-thread_local string RoundRobinSharder::round_robin_prefix_;\n-thread_local vector<ShardId> RoundRobinSharder::round_robin_shards_tl_cache_;\n-vector<ShardId> RoundRobinSharder::round_robin_shards_;\n-ShardId RoundRobinSharder::next_shard_;\n-fb2::Mutex RoundRobinSharder::mutex_;\n-\n constexpr size_t kQueueLen = 64;\n \n optional<uint32_t> GetPeriodicCycleMs() {\n@@ -274,34 +190,6 @@ size_t CalculateEvictionBytes() {\n __thread EngineShard* EngineShard::shard_ = nullptr;\n uint64_t TEST_current_time_ms = 0;\n \n-ShardId Shard(string_view v, ShardId shard_num) {\n-  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.\n-  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and\n-  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.\n-  // Yes, SlotId function does not have great distribution properties.\n-  // On the other side, slot based sharding may help with pipeline squashing optimizations,\n-  // because they rely on commands being single-sharded.\n-  // TODO: once we improve our squashing logic, we can remove this.\n-  if (IsClusterShardedBySlot()) {\n-    return KeySlot(v) % shard_num;\n-  }\n-\n-  if (IsClusterShardedByTag()) {\n-    v = LockTagOptions::instance().Tag(v);\n-  }\n-\n-  XXH64_hash_t hash = XXH64(v.data(), v.size(), 120577240643ULL);\n-\n-  if (RoundRobinSharder::IsEnabled()) {\n-    auto round_robin = RoundRobinSharder::TryGetShardId(v, hash);\n-    if (round_robin.has_value()) {\n-      return *round_robin;\n-    }\n-  }\n-\n-  return hash % shard_num;\n-}\n-\n string EngineShard::TxQueueInfo::Format() const {\n   string res;\n \n@@ -583,8 +471,6 @@ void EngineShard::InitThreadLocal(ProactorBase* pb) {\n   CompactObj::InitThreadLocal(shard_->memory_resource());\n   SmallString::InitThreadLocal(data_heap);\n \n-  RoundRobinSharder::Init();\n-\n   shard_->shard_search_indices_ = std::make_unique<ShardDocIndices>();\n }\n \n@@ -616,7 +502,6 @@ void EngineShard::DestroyThreadLocal() {\n   shard_ = nullptr;\n   CompactObj::InitThreadLocal(nullptr);\n   mi_heap_delete(tlh);\n-  RoundRobinSharder::Destroy();\n   VLOG(1) << \"Shard reset \" << shard_id;\n }\n \ndiff --git a/src/server/engine_shard.h b/src/server/engine_shard.h\nindex a0e1955ce449..d381fea3a9e0 100644\n--- a/src/server/engine_shard.h\n+++ b/src/server/engine_shard.h\n@@ -10,6 +10,7 @@\n #include \"core/task_queue.h\"\n #include \"core/tx_queue.h\"\n #include \"server/common.h\"\n+#include \"server/sharding.h\"\n #include \"server/tx_base.h\"\n #include \"util/sliding_counter.h\"\n \ndiff --git a/src/server/engine_shard_set.h b/src/server/engine_shard_set.h\nindex cc6123d0bb19..b712dedb6d1f 100644\n--- a/src/server/engine_shard_set.h\n+++ b/src/server/engine_shard_set.h\n@@ -10,7 +10,6 @@ extern \"C\" {\n \n #include <absl/container/btree_map.h>\n #include <absl/container/flat_hash_map.h>\n-#include <xxhash.h>\n \n #include \"core/mi_memory_resource.h\"\n #include \"server/db_slice.h\"\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 020d38066a2b..dc0c48ac5f51 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1016,6 +1016,9 @@ void Service::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*>\n     server_family_.GetDflyCmd()->BreakStalledFlowsInShard();\n     server_family_.UpdateMemoryGlobalStats();\n   });\n+  // InitThreadLocals might block\n+  pp_.AwaitFiberOnAll(\n+      [&](uint32_t index, ProactorBase* pb) { sharding::InitThreadLocals(shard_set->size()); });\n   Transaction::Init(shard_num);\n \n   UpdateServerState (&ServerState::rss_oom_deny_ratio)(absl::GetFlag(FLAGS_rss_oom_deny_ratio));\ndiff --git a/src/server/sharding.cc b/src/server/sharding.cc\nnew file mode 100644\nindex 000000000000..7040d9dd6b95\n--- /dev/null\n+++ b/src/server/sharding.cc\n@@ -0,0 +1,133 @@\n+// Copyright 2024, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/sharding.h\"\n+\n+#include <xxhash.h>\n+\n+#include \"absl/strings/match.h\"\n+#include \"base/flags.h\"\n+#include \"base/logging.h\"\n+#include \"server/cluster_support.h\"\n+#include \"server/common.h\"\n+#include \"util/fibers/synchronization.h\"\n+\n+using namespace std;\n+\n+ABSL_FLAG(string, shard_round_robin_prefix, \"\", \"Deprecated -- will be removed\");\n+\n+namespace dfly {\n+namespace {\n+// RoundRobinSharder implements a way to distribute keys that begin with some prefix.\n+// Round-robin is disabled by default. It is not a general use-case optimization, but instead only\n+// reasonable when there are a few highly contended keys, which we'd like to spread between the\n+// shards evenly.\n+// When enabled, the distribution is done via hash table: the hash of the key is used to look into\n+// a pre-allocated vector. This means that collisions are possible, but are very unlikely if only\n+// a few keys are used.\n+// Thread safe.\n+class RoundRobinSharder {\n+ public:\n+  static void Init(uint32_t shard_set_size) {\n+    round_robin_prefix_ = absl::GetFlag(FLAGS_shard_round_robin_prefix);\n+    shard_set_size_ = shard_set_size;\n+\n+    if (IsEnabled()) {\n+      LOG(WARNING) << \"shard_round_robin_prefix is deprecated and will be removed in new versions\";\n+      // ~100k entries will consume 200kb per thread, and will allow 100 keys with < 2.5% collision\n+      // probability. Since this has a considerable footprint, we only allocate when enabled. We're\n+      // using a prime number close to 100k for better utilization.\n+      constexpr size_t kRoundRobinSize = 100'003;\n+      round_robin_shards_tl_cache_.resize(kRoundRobinSize);\n+      std::fill(round_robin_shards_tl_cache_.begin(), round_robin_shards_tl_cache_.end(),\n+                kInvalidSid);\n+\n+      util::fb2::LockGuard guard(mutex_);\n+      if (round_robin_shards_.empty()) {\n+        round_robin_shards_ = round_robin_shards_tl_cache_;\n+      }\n+    }\n+  }\n+\n+  static bool IsEnabled() {\n+    return !round_robin_prefix_.empty();\n+  }\n+\n+  static optional<ShardId> TryGetShardId(string_view key, XXH64_hash_t key_hash) {\n+    DCHECK(!round_robin_shards_tl_cache_.empty());\n+\n+    if (!absl::StartsWith(key, round_robin_prefix_)) {\n+      return nullopt;\n+    }\n+\n+    size_t index = key_hash % round_robin_shards_tl_cache_.size();\n+    ShardId sid = round_robin_shards_tl_cache_[index];\n+\n+    if (sid == kInvalidSid) {\n+      util::fb2::LockGuard guard(mutex_);\n+      sid = round_robin_shards_[index];\n+      if (sid == kInvalidSid) {\n+        sid = next_shard_;\n+        round_robin_shards_[index] = sid;\n+        next_shard_ = (next_shard_ + 1) % shard_set_size_;\n+      }\n+      round_robin_shards_tl_cache_[index] = sid;\n+    }\n+\n+    return sid;\n+  }\n+\n+ private:\n+  static thread_local string round_robin_prefix_;\n+  static thread_local vector<ShardId> round_robin_shards_tl_cache_;\n+  static thread_local uint32_t shard_set_size_;\n+  static vector<ShardId> round_robin_shards_ ABSL_GUARDED_BY(mutex_);\n+  static ShardId next_shard_ ABSL_GUARDED_BY(mutex_);\n+  static util::fb2::Mutex mutex_;\n+};\n+\n+}  // namespace\n+\n+thread_local string RoundRobinSharder::round_robin_prefix_;\n+thread_local uint32_t RoundRobinSharder::shard_set_size_;\n+thread_local vector<ShardId> RoundRobinSharder::round_robin_shards_tl_cache_;\n+vector<ShardId> RoundRobinSharder::round_robin_shards_;\n+ShardId RoundRobinSharder::next_shard_;\n+util::fb2::Mutex RoundRobinSharder::mutex_;\n+\n+ShardId Shard(string_view v, ShardId shard_num) {\n+  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.\n+  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and\n+  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.\n+  // Yes, SlotId function does not have great distribution properties.\n+  // On the other side, slot based sharding may help with pipeline squashing optimizations,\n+  // because they rely on commands being single-sharded.\n+  // TODO: once we improve our squashing logic, we can remove this.\n+  if (IsClusterShardedBySlot()) {\n+    return KeySlot(v) % shard_num;\n+  }\n+\n+  if (IsClusterShardedByTag()) {\n+    v = LockTagOptions::instance().Tag(v);\n+  }\n+\n+  XXH64_hash_t hash = XXH64(v.data(), v.size(), 120577240643ULL);\n+\n+  if (RoundRobinSharder::IsEnabled()) {\n+    auto round_robin = RoundRobinSharder::TryGetShardId(v, hash);\n+    if (round_robin.has_value()) {\n+      return *round_robin;\n+    }\n+  }\n+\n+  return hash % shard_num;\n+}\n+\n+namespace sharding {\n+void InitThreadLocals(uint32_t shard_set_size) {\n+  RoundRobinSharder::Init(shard_set_size);\n+}\n+}  // namespace sharding\n+\n+}  // namespace dfly\ndiff --git a/src/server/sharding.h b/src/server/sharding.h\nnew file mode 100644\nindex 000000000000..2ed6de047f82\n--- /dev/null\n+++ b/src/server/sharding.h\n@@ -0,0 +1,19 @@\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#pragma once\n+\n+#include <string_view>\n+\n+#include \"tx_base.h\"\n+\n+namespace dfly {\n+\n+ShardId Shard(std::string_view v, ShardId shard_num);\n+\n+namespace sharding {\n+void InitThreadLocals(uint32_t shard_set_size);\n+}\n+\n+}  // namespace dfly\ndiff --git a/src/server/tx_base.cc b/src/server/tx_base.cc\nindex 14ce4bc764bd..086a5a383164 100644\n--- a/src/server/tx_base.cc\n+++ b/src/server/tx_base.cc\n@@ -4,6 +4,8 @@\n \n #include \"server/tx_base.h\"\n \n+#include <xxhash.h>\n+\n #include \"base/logging.h\"\n #include \"facade/facade_types.h\"\n #include \"server/cluster/cluster_defs.h\"\n",
  "test_patch": "diff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex cf1e57f74edd..b3002d4d6c94 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -444,10 +444,8 @@ TEST_F(SetFamilyTest, CheckSetLinkExpiryTransfer) {\n \n TEST_F(SetFamilyTest, SetInter_5590) {\n   absl::FlagSaver fs;\n-  // Default break num_shards=2 and threads=3\n-  // TODO(#5651) fix it\n-  SetTestFlag(\"num_shards\", \"4\");\n-  num_threads_ = 4;\n+  SetTestFlag(\"num_shards\", \"2\");\n+  num_threads_ = 3;\n   SetTestFlag(\"shard_round_robin_prefix\", \"prefix-\");\n   ResetService();\n \n",
  "problem_statement": "RoundRobinSharder should be thread local to each proactor\nWe initialize `RoundRobinSharder` per shard thread yet we can call `Shard()` on any thread. This means, that a call to `Shard()` from a non shard thread will read empty values for the thread locals (since they only got initialized for shard threads).\n",
  "hints_text": "",
  "created_at": "2025-08-11T13:03:45Z",
  "modified_files": [
    "src/server/CMakeLists.txt",
    "src/server/engine_shard.cc",
    "src/server/engine_shard.h",
    "src/server/engine_shard_set.h",
    "src/server/main_service.cc",
    "b/src/server/sharding.cc",
    "b/src/server/sharding.h",
    "src/server/tx_base.cc"
  ],
  "modified_test_files": [
    "src/server/set_family_test.cc"
  ]
}