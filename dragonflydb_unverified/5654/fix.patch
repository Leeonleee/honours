diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
index 76058babaf22..a2d98fdfe3bf 100644
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -81,7 +81,8 @@ add_library(dragonfly_lib
             cluster/cluster_config.cc cluster/cluster_family.cc cluster/incoming_slot_migration.cc
             cluster/outgoing_slot_migration.cc cluster/cluster_defs.cc cluster/cluster_utility.cc
             acl/user.cc acl/user_registry.cc acl/acl_family.cc
-            acl/validator.cc)
+            acl/validator.cc
+            sharding.cc)
 
 if (DF_ENABLE_MEMORY_TRACKING)
   target_compile_definitions(dragonfly_lib PRIVATE DFLY_ENABLE_MEMORY_TRACKING)
diff --git a/src/server/engine_shard.cc b/src/server/engine_shard.cc
index 50b6d72c7e8c..82aa2daddcb3 100644
--- a/src/server/engine_shard.cc
+++ b/src/server/engine_shard.cc
@@ -45,12 +45,6 @@ ABSL_FLAG(int32_t, hz, 100,
           "Base frequency at which the server performs other background tasks. "
           "Warning: not advised to decrease in production.");
 
-ABSL_FLAG(string, shard_round_robin_prefix, "",
-          "When non-empty, keys which start with this prefix are not distributed across shards "
-          "based on their value but instead via round-robin. Use cautiously! This can efficiently "
-          "support up to a few hundreds of prefixes. Note: prefix is looked inside hash tags when "
-          "cluster mode is enabled.");
-
 ABSL_FLAG(string, tiered_prefix, "",
           "Enables tiered storage if set. "
           "The string denotes the path and prefix of the files "
@@ -107,78 +101,6 @@ ShardMemUsage ReadShardMemUsage(float wasted_ratio) {
   return usage;
 }
 
-// RoundRobinSharder implements a way to distribute keys that begin with some prefix.
-// Round-robin is disabled by default. It is not a general use-case optimization, but instead only
-// reasonable when there are a few highly contended keys, which we'd like to spread between the
-// shards evenly.
-// When enabled, the distribution is done via hash table: the hash of the key is used to look into
-// a pre-allocated vector. This means that collisions are possible, but are very unlikely if only
-// a few keys are used.
-// Thread safe.
-class RoundRobinSharder {
- public:
-  static void Init() {
-    round_robin_prefix_ = absl::GetFlag(FLAGS_shard_round_robin_prefix);
-
-    if (IsEnabled()) {
-      // ~100k entries will consume 200kb per thread, and will allow 100 keys with < 2.5% collision
-      // probability. Since this has a considerable footprint, we only allocate when enabled. We're
-      // using a prime number close to 100k for better utilization.
-      constexpr size_t kRoundRobinSize = 100'003;
-      round_robin_shards_tl_cache_.resize(kRoundRobinSize);
-      std::fill(round_robin_shards_tl_cache_.begin(), round_robin_shards_tl_cache_.end(),
-                kInvalidSid);
-
-      util::fb2::LockGuard guard(mutex_);
-      if (round_robin_shards_.empty()) {
-        round_robin_shards_ = round_robin_shards_tl_cache_;
-      }
-    }
-  }
-
-  static void Destroy() ABSL_LOCKS_EXCLUDED(mutex_) {
-    round_robin_shards_tl_cache_.clear();
-
-    util::fb2::LockGuard guard(mutex_);
-    round_robin_shards_.clear();
-  }
-
-  static bool IsEnabled() {
-    return !round_robin_prefix_.empty();
-  }
-
-  static optional<ShardId> TryGetShardId(string_view key, XXH64_hash_t key_hash) {
-    DCHECK(!round_robin_shards_tl_cache_.empty());
-
-    if (!absl::StartsWith(key, round_robin_prefix_)) {
-      return nullopt;
-    }
-
-    size_t index = key_hash % round_robin_shards_tl_cache_.size();
-    ShardId sid = round_robin_shards_tl_cache_[index];
-
-    if (sid == kInvalidSid) {
-      util::fb2::LockGuard guard(mutex_);
-      sid = round_robin_shards_[index];
-      if (sid == kInvalidSid) {
-        sid = next_shard_;
-        round_robin_shards_[index] = sid;
-        next_shard_ = (next_shard_ + 1) % shard_set->size();
-      }
-      round_robin_shards_tl_cache_[index] = sid;
-    }
-
-    return sid;
-  }
-
- private:
-  static thread_local string round_robin_prefix_;
-  static thread_local vector<ShardId> round_robin_shards_tl_cache_;
-  static vector<ShardId> round_robin_shards_ ABSL_GUARDED_BY(mutex_);
-  static ShardId next_shard_ ABSL_GUARDED_BY(mutex_);
-  static fb2::Mutex mutex_;
-};
-
 bool HasContendedLocks(ShardId shard_id, Transaction* trx, const DbTable* table) {
   auto is_contended = [table](LockFp fp) { return table->trans_locks.Find(fp)->IsContended(); };
 
@@ -199,12 +121,6 @@ bool HasContendedLocks(ShardId shard_id, Transaction* trx, const DbTable* table)
   return false;
 }
 
-thread_local string RoundRobinSharder::round_robin_prefix_;
-thread_local vector<ShardId> RoundRobinSharder::round_robin_shards_tl_cache_;
-vector<ShardId> RoundRobinSharder::round_robin_shards_;
-ShardId RoundRobinSharder::next_shard_;
-fb2::Mutex RoundRobinSharder::mutex_;
-
 constexpr size_t kQueueLen = 64;
 
 optional<uint32_t> GetPeriodicCycleMs() {
@@ -274,34 +190,6 @@ size_t CalculateEvictionBytes() {
 __thread EngineShard* EngineShard::shard_ = nullptr;
 uint64_t TEST_current_time_ms = 0;
 
-ShardId Shard(string_view v, ShardId shard_num) {
-  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.
-  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and
-  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.
-  // Yes, SlotId function does not have great distribution properties.
-  // On the other side, slot based sharding may help with pipeline squashing optimizations,
-  // because they rely on commands being single-sharded.
-  // TODO: once we improve our squashing logic, we can remove this.
-  if (IsClusterShardedBySlot()) {
-    return KeySlot(v) % shard_num;
-  }
-
-  if (IsClusterShardedByTag()) {
-    v = LockTagOptions::instance().Tag(v);
-  }
-
-  XXH64_hash_t hash = XXH64(v.data(), v.size(), 120577240643ULL);
-
-  if (RoundRobinSharder::IsEnabled()) {
-    auto round_robin = RoundRobinSharder::TryGetShardId(v, hash);
-    if (round_robin.has_value()) {
-      return *round_robin;
-    }
-  }
-
-  return hash % shard_num;
-}
-
 string EngineShard::TxQueueInfo::Format() const {
   string res;
 
@@ -583,8 +471,6 @@ void EngineShard::InitThreadLocal(ProactorBase* pb) {
   CompactObj::InitThreadLocal(shard_->memory_resource());
   SmallString::InitThreadLocal(data_heap);
 
-  RoundRobinSharder::Init();
-
   shard_->shard_search_indices_ = std::make_unique<ShardDocIndices>();
 }
 
@@ -616,7 +502,6 @@ void EngineShard::DestroyThreadLocal() {
   shard_ = nullptr;
   CompactObj::InitThreadLocal(nullptr);
   mi_heap_delete(tlh);
-  RoundRobinSharder::Destroy();
   VLOG(1) << "Shard reset " << shard_id;
 }
 
diff --git a/src/server/engine_shard.h b/src/server/engine_shard.h
index a0e1955ce449..d381fea3a9e0 100644
--- a/src/server/engine_shard.h
+++ b/src/server/engine_shard.h
@@ -10,6 +10,7 @@
 #include "core/task_queue.h"
 #include "core/tx_queue.h"
 #include "server/common.h"
+#include "server/sharding.h"
 #include "server/tx_base.h"
 #include "util/sliding_counter.h"
 
diff --git a/src/server/engine_shard_set.h b/src/server/engine_shard_set.h
index cc6123d0bb19..b712dedb6d1f 100644
--- a/src/server/engine_shard_set.h
+++ b/src/server/engine_shard_set.h
@@ -10,7 +10,6 @@ extern "C" {
 
 #include <absl/container/btree_map.h>
 #include <absl/container/flat_hash_map.h>
-#include <xxhash.h>
 
 #include "core/mi_memory_resource.h"
 #include "server/db_slice.h"
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index 020d38066a2b..dc0c48ac5f51 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -1016,6 +1016,9 @@ void Service::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*>
     server_family_.GetDflyCmd()->BreakStalledFlowsInShard();
     server_family_.UpdateMemoryGlobalStats();
   });
+  // InitThreadLocals might block
+  pp_.AwaitFiberOnAll(
+      [&](uint32_t index, ProactorBase* pb) { sharding::InitThreadLocals(shard_set->size()); });
   Transaction::Init(shard_num);
 
   UpdateServerState (&ServerState::rss_oom_deny_ratio)(absl::GetFlag(FLAGS_rss_oom_deny_ratio));
diff --git a/src/server/sharding.cc b/src/server/sharding.cc
new file mode 100644
index 000000000000..7040d9dd6b95
--- /dev/null
+++ b/src/server/sharding.cc
@@ -0,0 +1,133 @@
+// Copyright 2024, DragonflyDB authors.  All rights reserved.
+// See LICENSE for licensing terms.
+//
+
+#include "server/sharding.h"
+
+#include <xxhash.h>
+
+#include "absl/strings/match.h"
+#include "base/flags.h"
+#include "base/logging.h"
+#include "server/cluster_support.h"
+#include "server/common.h"
+#include "util/fibers/synchronization.h"
+
+using namespace std;
+
+ABSL_FLAG(string, shard_round_robin_prefix, "", "Deprecated -- will be removed");
+
+namespace dfly {
+namespace {
+// RoundRobinSharder implements a way to distribute keys that begin with some prefix.
+// Round-robin is disabled by default. It is not a general use-case optimization, but instead only
+// reasonable when there are a few highly contended keys, which we'd like to spread between the
+// shards evenly.
+// When enabled, the distribution is done via hash table: the hash of the key is used to look into
+// a pre-allocated vector. This means that collisions are possible, but are very unlikely if only
+// a few keys are used.
+// Thread safe.
+class RoundRobinSharder {
+ public:
+  static void Init(uint32_t shard_set_size) {
+    round_robin_prefix_ = absl::GetFlag(FLAGS_shard_round_robin_prefix);
+    shard_set_size_ = shard_set_size;
+
+    if (IsEnabled()) {
+      LOG(WARNING) << "shard_round_robin_prefix is deprecated and will be removed in new versions";
+      // ~100k entries will consume 200kb per thread, and will allow 100 keys with < 2.5% collision
+      // probability. Since this has a considerable footprint, we only allocate when enabled. We're
+      // using a prime number close to 100k for better utilization.
+      constexpr size_t kRoundRobinSize = 100'003;
+      round_robin_shards_tl_cache_.resize(kRoundRobinSize);
+      std::fill(round_robin_shards_tl_cache_.begin(), round_robin_shards_tl_cache_.end(),
+                kInvalidSid);
+
+      util::fb2::LockGuard guard(mutex_);
+      if (round_robin_shards_.empty()) {
+        round_robin_shards_ = round_robin_shards_tl_cache_;
+      }
+    }
+  }
+
+  static bool IsEnabled() {
+    return !round_robin_prefix_.empty();
+  }
+
+  static optional<ShardId> TryGetShardId(string_view key, XXH64_hash_t key_hash) {
+    DCHECK(!round_robin_shards_tl_cache_.empty());
+
+    if (!absl::StartsWith(key, round_robin_prefix_)) {
+      return nullopt;
+    }
+
+    size_t index = key_hash % round_robin_shards_tl_cache_.size();
+    ShardId sid = round_robin_shards_tl_cache_[index];
+
+    if (sid == kInvalidSid) {
+      util::fb2::LockGuard guard(mutex_);
+      sid = round_robin_shards_[index];
+      if (sid == kInvalidSid) {
+        sid = next_shard_;
+        round_robin_shards_[index] = sid;
+        next_shard_ = (next_shard_ + 1) % shard_set_size_;
+      }
+      round_robin_shards_tl_cache_[index] = sid;
+    }
+
+    return sid;
+  }
+
+ private:
+  static thread_local string round_robin_prefix_;
+  static thread_local vector<ShardId> round_robin_shards_tl_cache_;
+  static thread_local uint32_t shard_set_size_;
+  static vector<ShardId> round_robin_shards_ ABSL_GUARDED_BY(mutex_);
+  static ShardId next_shard_ ABSL_GUARDED_BY(mutex_);
+  static util::fb2::Mutex mutex_;
+};
+
+}  // namespace
+
+thread_local string RoundRobinSharder::round_robin_prefix_;
+thread_local uint32_t RoundRobinSharder::shard_set_size_;
+thread_local vector<ShardId> RoundRobinSharder::round_robin_shards_tl_cache_;
+vector<ShardId> RoundRobinSharder::round_robin_shards_;
+ShardId RoundRobinSharder::next_shard_;
+util::fb2::Mutex RoundRobinSharder::mutex_;
+
+ShardId Shard(string_view v, ShardId shard_num) {
+  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.
+  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and
+  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.
+  // Yes, SlotId function does not have great distribution properties.
+  // On the other side, slot based sharding may help with pipeline squashing optimizations,
+  // because they rely on commands being single-sharded.
+  // TODO: once we improve our squashing logic, we can remove this.
+  if (IsClusterShardedBySlot()) {
+    return KeySlot(v) % shard_num;
+  }
+
+  if (IsClusterShardedByTag()) {
+    v = LockTagOptions::instance().Tag(v);
+  }
+
+  XXH64_hash_t hash = XXH64(v.data(), v.size(), 120577240643ULL);
+
+  if (RoundRobinSharder::IsEnabled()) {
+    auto round_robin = RoundRobinSharder::TryGetShardId(v, hash);
+    if (round_robin.has_value()) {
+      return *round_robin;
+    }
+  }
+
+  return hash % shard_num;
+}
+
+namespace sharding {
+void InitThreadLocals(uint32_t shard_set_size) {
+  RoundRobinSharder::Init(shard_set_size);
+}
+}  // namespace sharding
+
+}  // namespace dfly
diff --git a/src/server/sharding.h b/src/server/sharding.h
new file mode 100644
index 000000000000..2ed6de047f82
--- /dev/null
+++ b/src/server/sharding.h
@@ -0,0 +1,19 @@
+// Copyright 2025, DragonflyDB authors.  All rights reserved.
+// See LICENSE for licensing terms.
+//
+
+#pragma once
+
+#include <string_view>
+
+#include "tx_base.h"
+
+namespace dfly {
+
+ShardId Shard(std::string_view v, ShardId shard_num);
+
+namespace sharding {
+void InitThreadLocals(uint32_t shard_set_size);
+}
+
+}  // namespace dfly
diff --git a/src/server/tx_base.cc b/src/server/tx_base.cc
index 14ce4bc764bd..086a5a383164 100644
--- a/src/server/tx_base.cc
+++ b/src/server/tx_base.cc
@@ -4,6 +4,8 @@
 
 #include "server/tx_base.h"
 
+#include <xxhash.h>
+
 #include "base/logging.h"
 #include "facade/facade_types.h"
 #include "server/cluster/cluster_defs.h"
