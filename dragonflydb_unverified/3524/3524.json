{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3524,
  "instance_id": "dragonflydb__dragonfly-3524",
  "issue_numbers": [
    "3450"
  ],
  "base_commit": "1f36c9952dd5537fb004d408ffebc977bc4cce8b",
  "patch": "diff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 6e948a45636d..b15058b30a41 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -1300,6 +1300,38 @@ void GenericFamily::RenameNx(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void GenericFamily::ExpireTime(CmdArgList args, ConnectionContext* cntx) {\n+  ExpireTimeGeneric(args, cntx, TimeUnit::SEC);\n+}\n+\n+void GenericFamily::PExpireTime(CmdArgList args, ConnectionContext* cntx) {\n+  ExpireTimeGeneric(args, cntx, TimeUnit::MSEC);\n+}\n+\n+void GenericFamily::ExpireTimeGeneric(CmdArgList args, ConnectionContext* cntx, TimeUnit unit) {\n+  string_view key = ArgS(args, 0);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) { return OpExpireTime(t, shard, key); };\n+  OpResult<uint64_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+\n+  if (result) {\n+    long ttl = (unit == TimeUnit::SEC) ? (result.value() + 500) / 1000 : result.value();\n+    cntx->SendLong(ttl);\n+    return;\n+  }\n+\n+  switch (result.status()) {\n+    case OpStatus::KEY_NOTFOUND:\n+      cntx->SendLong(-2);\n+      break;\n+    default:\n+      LOG_IF(ERROR, result.status() != OpStatus::SKIPPED)\n+          << \"Unexpected status \" << result.status();\n+      cntx->SendLong(-1);\n+      break;\n+  }\n+}\n+\n void GenericFamily::Ttl(CmdArgList args, ConnectionContext* cntx) {\n   TtlGeneric(args, cntx, TimeUnit::SEC);\n }\n@@ -1462,7 +1494,8 @@ void GenericFamily::Scan(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-OpResult<uint64_t> GenericFamily::OpTtl(Transaction* t, EngineShard* shard, string_view key) {\n+OpResult<uint64_t> GenericFamily::OpExpireTime(Transaction* t, EngineShard* shard,\n+                                               string_view key) {\n   auto& db_slice = t->GetDbSlice(shard->shard_id());\n   auto [it, expire_it] = db_slice.FindReadOnly(t->GetDbContext(), key);\n   if (!IsValid(it))\n@@ -1471,11 +1504,23 @@ OpResult<uint64_t> GenericFamily::OpTtl(Transaction* t, EngineShard* shard, stri\n   if (!IsValid(expire_it))\n     return OpStatus::SKIPPED;\n \n-  int64_t ttl_ms = db_slice.ExpireTime(expire_it) - t->GetDbContext().time_now_ms;\n+  int64_t ttl_ms = db_slice.ExpireTime(expire_it);\n   DCHECK_GT(ttl_ms, 0);  // Otherwise FindReadOnly would return null.\n   return ttl_ms;\n }\n \n+OpResult<uint64_t> GenericFamily::OpTtl(Transaction* t, EngineShard* shard, string_view key) {\n+  auto opExpireTimeResult = OpExpireTime(t, shard, key);\n+\n+  if (opExpireTimeResult) {\n+    int64_t ttl_ms = opExpireTimeResult.value() - t->GetDbContext().time_now_ms;\n+    DCHECK_GT(ttl_ms, 0);  // Otherwise FindReadOnly would return null.\n+    return ttl_ms;\n+  } else {\n+    return opExpireTimeResult;\n+  }\n+}\n+\n OpResult<uint32_t> GenericFamily::OpExists(const OpArgs& op_args, const ShardArgs& keys) {\n   DVLOG(1) << \"Exists: \" << keys.Front();\n   auto& db_slice = op_args.GetDbSlice();\n@@ -1672,6 +1717,8 @@ constexpr uint32_t kStick = KEYSPACE | WRITE | FAST;\n constexpr uint32_t kSort = WRITE | SET | SORTEDSET | LIST | SLOW | DANGEROUS;\n constexpr uint32_t kMove = KEYSPACE | WRITE | FAST;\n constexpr uint32_t kRestore = KEYSPACE | WRITE | SLOW | DANGEROUS;\n+constexpr uint32_t kExpireTime = KEYSPACE | READ | FAST;\n+constexpr uint32_t kPExpireTime = KEYSPACE | READ | FAST;\n }  // namespace acl\n \n void GenericFamily::Register(CommandRegistry* registry) {\n@@ -1713,7 +1760,9 @@ void GenericFamily::Register(CommandRegistry* registry) {\n       << CI{\"MOVE\", CO::WRITE | CO::GLOBAL_TRANS | CO::NO_AUTOJOURNAL, 3, 1, 1, acl::kMove}.HFUNC(\n              Move)\n       << CI{\"RESTORE\", CO::WRITE, -4, 1, 1, acl::kRestore}.HFUNC(Restore)\n-      << CI{\"RANDOMKEY\", CO::READONLY, 1, 0, 0, 0}.HFUNC(RandomKey);\n+      << CI{\"RANDOMKEY\", CO::READONLY, 1, 0, 0, 0}.HFUNC(RandomKey)\n+      << CI{\"EXPIRETIME\", CO::READONLY | CO::FAST, 2, 1, 1, acl::kExpireTime}.HFUNC(ExpireTime)\n+      << CI{\"PEXPIRETIME\", CO::READONLY | CO::FAST, 2, 1, 1, acl::kPExpireTime}.HFUNC(PExpireTime);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex 411cc2535e2f..207d68009146 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -56,6 +56,8 @@ class GenericFamily {\n \n   static void Rename(CmdArgList args, ConnectionContext* cntx);\n   static void RenameNx(CmdArgList args, ConnectionContext* cntx);\n+  static void ExpireTime(CmdArgList args, ConnectionContext* cntx);\n+  static void PExpireTime(CmdArgList args, ConnectionContext* cntx);\n   static void Ttl(CmdArgList args, ConnectionContext* cntx);\n   static void Pttl(CmdArgList args, ConnectionContext* cntx);\n \n@@ -71,8 +73,11 @@ class GenericFamily {\n \n   static ErrorReply RenameGeneric(CmdArgList args, bool destination_should_not_exist,\n                                   ConnectionContext* cntx);\n+\n+  static void ExpireTimeGeneric(CmdArgList args, ConnectionContext* cntx, TimeUnit unit);\n   static void TtlGeneric(CmdArgList args, ConnectionContext* cntx, TimeUnit unit);\n \n+  static OpResult<uint64_t> OpExpireTime(Transaction* t, EngineShard* shard, std::string_view key);\n   static OpResult<uint64_t> OpTtl(Transaction* t, EngineShard* shard, std::string_view key);\n   static OpResult<void> OpRen(const OpArgs& op_args, std::string_view from, std::string_view to,\n                               bool destination_should_not_exist);\n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 0916e4908e2f..1a5fbc1121af 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -762,4 +762,19 @@ TEST_F(GenericFamilyTest, JsonType) {\n   ASSERT_THAT(vec, ElementsAre(\"json\"));\n }\n \n+TEST_F(GenericFamilyTest, ExpireTime) {\n+  EXPECT_EQ(-2, CheckedInt({\"EXPIRETIME\", \"foo\"}));\n+  EXPECT_EQ(-2, CheckedInt({\"PEXPIRETIME\", \"foo\"}));\n+  Run({\"set\", \"foo\", \"bar\"});\n+  EXPECT_EQ(-1, CheckedInt({\"EXPIRETIME\", \"foo\"}));\n+  EXPECT_EQ(-1, CheckedInt({\"PEXPIRETIME\", \"foo\"}));\n+\n+  // set expiry\n+  uint64_t expire_time_in_ms = TEST_current_time_ms + 5000;\n+  uint64_t expire_time_in_seconds = (expire_time_in_ms + 500) / 1000;\n+  Run({\"pexpireat\", \"foo\", absl::StrCat(expire_time_in_ms)});\n+  EXPECT_EQ(expire_time_in_seconds, CheckedInt({\"EXPIRETIME\", \"foo\"}));\n+  EXPECT_EQ(expire_time_in_ms, CheckedInt({\"PEXPIRETIME\", \"foo\"}));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Support `PEXPIRETIME`\n**Is your feature request related to a problem? Please describe.**\r\nLooking into alternatives to Redis, we tested [our server](https://github.com/Kuadrant/limitador/) with Dragonfly... Which worked well, other than the lack of support for `PEXPIRETIME`, which lets us be more aggressive wrt caching. As such support for it would be real beneficial to our usecase. \r\n\r\n**Describe the solution you'd like**\r\nSupport for `PEXPIRETIME` as per [redis 7.x](https://redis.io/docs/latest/commands/pexpiretime/)\r\n\r\n**Describe alternatives you've considered**\r\nWithout it, we need to keep \"two sources\" of time and do diff across these, based of `PTTL`. \r\n\n",
  "hints_text": "Hey @alexsnaps, thanks for filing this!\r\n\r\nIndeed, this is something we should fix.\r\n\r\nIf you're into C++, this might be a relatively easy contribution. I've also added \"help wanted\" and \"good first issue\" labels for other contributors to, perhaps, help.\nFor those who consider contributing: implementing `PEXPIRETIME` (and while at it, `EXPIRETIME`) commands should be very similar to the existing implementation of `PTTL` (and `TTL`), so you could start with that.\nYeah, if I read [this right](https://github.com/dragonflydb/dragonfly/blob/ff716bb8b0a65834830dc3523e2ab30c45d9048c/src/server/generic_family.cc#L1470-L1481) we'd need a `OpExpireTime` based of that `OpTtl`, that \"just\" avoids doing [the math](https://github.com/dragonflydb/dragonfly/blob/ff716bb8b0a65834830dc3523e2ab30c45d9048c/src/server/generic_family.cc#L1479) and return the expiry time as a `uint64_t` directly. Then have a `GenericFamily::ExpireTimeGeneric` do the unit conversion and write the result back.  \n@alexsnaps generally yes, although I'd keep only one version (without \"the math\") and do the subtraction only for `TTL`/`PTTL`.\r\nAnd also - we need unit tests (in `generic_family_test.cc`)\r\n\r\nBut yeah, that sounds like a plan to me! :)\nHey all, new to this repo. \r\nI'd be glad to take a stab at this :)\nSure go ahead, send a PR :)\r\nsee https://github.com/dragonflydb/dragonfly/blob/main/CONTRIBUTING.md on how to setup the dev environment and how to build dragonfly from source",
  "created_at": "2024-08-18T03:31:07Z",
  "modified_files": [
    "src/server/generic_family.cc",
    "src/server/generic_family.h"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc"
  ]
}