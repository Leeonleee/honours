{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2476,
  "instance_id": "dragonflydb__dragonfly-2476",
  "issue_numbers": [
    "2441"
  ],
  "base_commit": "f69f2ec0ca97e0c4ef069544b650fbd0e32f4868",
  "patch": "diff --git a/src/core/interpreter.cc b/src/core/interpreter.cc\nindex 26564f1e07b8..54f464bbac64 100644\n--- a/src/core/interpreter.cc\n+++ b/src/core/interpreter.cc\n@@ -351,6 +351,14 @@ int RedisStatusReplyCommand(lua_State* lua) {\n   return SingleFieldTable(lua, \"ok\");\n }\n \n+// no-op\n+int RedisLogCommand(lua_State* lua) {\n+  // if the arguments passed to redis.log are incorrect\n+  // we still do not log the error. Therefore, even if\n+  // for the no-op case we don't need to parse the arguments\n+  return 0;\n+}\n+\n // See https://www.lua.org/manual/5.3/manual.html#lua_Alloc\n void* mimalloc_glue(void* ud, void* ptr, size_t osize, size_t nsize) {\n   (void)ud;\n@@ -408,6 +416,10 @@ Interpreter::Interpreter() {\n   lua_pushcfunction(lua_, RedisStatusReplyCommand);\n   lua_settable(lua_, -3);\n \n+  lua_pushstring(lua_, \"log\");\n+  lua_pushcfunction(lua_, RedisLogCommand);\n+  lua_settable(lua_, -3);\n+\n   /* Finally set the table as 'redis' global var. */\n   lua_setglobal(lua_, \"redis\");\n   CHECK(lua_checkstack(lua_, 64));\n",
  "test_patch": "diff --git a/tests/dragonfly/eval_test.py b/tests/dragonfly/eval_test.py\nindex f687a16e40f9..acc89142006c 100644\n--- a/tests/dragonfly/eval_test.py\n+++ b/tests/dragonfly/eval_test.py\n@@ -264,3 +264,12 @@ async def test_lua_auto_async(async_client: aioredis.Redis):\n \n     flushes = (await async_client.info(\"transaction\"))[\"eval_squashed_flushes\"]\n     assert 1 <= flushes <= 3  # all 100 commands are executed in at most 3 batches\n+\n+\n+@dfly_args({\"proactor_threads\": 4, \"lua_auto_async\": None})\n+async def test_lua_redis_log_noop(async_client: aioredis.Redis):\n+    res = await async_client.eval(\"redis.log('nonsense', 'nonsense')\", 0)\n+    assert res == None\n+\n+    res = await async_client.eval(\"redis.log(redis.LOG_WARNING, 'warn')\", 0)\n+    assert res == None\n",
  "problem_statement": "redis.log is not supported by dragonfly lua engine\nSidekiq Enterprise uses Lua to provide a rate limiting API. There are points in this code where it uses `redis.log` to emit warnings or errors to the logfile, as below. It does not appear that DragonflyDB provides this logger by default as I get a nil warning.\r\n\r\n```lua\r\nredis.log(redis.LOG_WARNING, \"[sidekiq] Reclaiming \" .. count .. \" expired locks for \" .. KEYS[1])\r\nredis.call('hincrby', KEYS[3], \"reclaimed\", count)\r\n```\r\n\r\nWhat should I do with this code? \"Comment it out\" is a valid suggestion, as the logging isn't really necessary.\n",
  "hints_text": "We can provide this function as a noop as a first step. It won't go into v1.14 but we can do it for the next version. \r\nI feel uncomfortable letting server users to write directly into server logs as it can be a potential security and reliability risk.\nIf the server user/api callers do not sanitize key/value after user input and before calling redis/dragonfly api, where the logging happens, I think log security concern is very low on the exploit path. \r\n\r\n> I feel uncomfortable letting server users to write directly into server logs as it can be a potential security and reliability risk.\r\n\r\n",
  "created_at": "2024-01-25T11:13:23Z",
  "modified_files": [
    "src/core/interpreter.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/eval_test.py"
  ]
}