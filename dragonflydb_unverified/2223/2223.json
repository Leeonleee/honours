{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2223,
  "instance_id": "dragonflydb__dragonfly-2223",
  "issue_numbers": [
    "2052"
  ],
  "base_commit": "3f7e42b099f8ba0361502da66bd7b9712de1559e",
  "patch": "diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex 080045c32962..ef228158816a 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -28,7 +28,12 @@ constexpr bool kAllowDisplacements = true;\n DenseSet::IteratorBase::IteratorBase(const DenseSet* owner, bool is_end)\n     : owner_(const_cast<DenseSet*>(owner)), curr_entry_(nullptr) {\n   curr_list_ = is_end ? owner_->entries_.end() : owner_->entries_.begin();\n-  if (curr_list_ != owner->entries_.end()) {\n+\n+  // Even if `is_end` is `false`, the list can be empty.\n+  if (curr_list_ == owner->entries_.end()) {\n+    curr_entry_ = nullptr;\n+    owner_ = nullptr;\n+  } else {\n     curr_entry_ = &(*curr_list_);\n     owner->ExpireIfNeeded(nullptr, curr_entry_);\n \n@@ -86,8 +91,10 @@ size_t DenseSet::PushFront(DenseSet::ChainVectorIterator it, void* data, bool ha\n     it->SetLink(NewLink(data, *it));\n   }\n \n-  if (has_ttl)\n+  if (has_ttl) {\n     it->SetTtl(true);\n+    expiration_used_ = true;\n+  }\n   return ObjectAllocSize(data);\n }\n \n@@ -97,8 +104,10 @@ void DenseSet::PushFront(DenseSet::ChainVectorIterator it, DenseSet::DensePtr pt\n \n   if (it->IsEmpty()) {\n     it->SetObject(ptr.GetObject());\n-    if (ptr.HasTtl())\n+    if (ptr.HasTtl()) {\n       it->SetTtl(true);\n+      expiration_used_ = true;\n+    }\n     if (ptr.IsLink()) {\n       FreeLink(ptr.AsLink());\n     }\n@@ -112,8 +121,10 @@ void DenseSet::PushFront(DenseSet::ChainVectorIterator it, DenseSet::DensePtr pt\n \n     // allocate a new link if needed and copy the pointer to the new link\n     it->SetLink(NewLink(ptr.Raw(), *it));\n-    if (ptr.HasTtl())\n+    if (ptr.HasTtl()) {\n       it->SetTtl(true);\n+      expiration_used_ = true;\n+    }\n     DCHECK(!it->AsLink()->next.IsEmpty());\n   }\n }\n@@ -175,6 +186,7 @@ void DenseSet::ClearInternal() {\n   num_used_buckets_ = 0;\n   num_chain_entries_ = 0;\n   size_ = 0;\n+  expiration_used_ = false;\n }\n \n bool DenseSet::Equal(DensePtr dptr, const void* ptr, uint32_t cookie) const {\n@@ -401,8 +413,10 @@ void DenseSet::AddUnique(void* obj, bool has_ttl, uint64_t hashcode) {\n    */\n \n   DensePtr to_insert(obj);\n-  if (has_ttl)\n+  if (has_ttl) {\n     to_insert.SetTtl(true);\n+    expiration_used_ = true;\n+  }\n \n   while (!entries_[bucket_id].IsEmpty() && entries_[bucket_id].IsDisplaced()) {\n     DensePtr unlinked = PopPtrFront(entries_.begin() + bucket_id);\ndiff --git a/src/core/dense_set.h b/src/core/dense_set.h\nindex 6b077c2dfd58..0c55287b7399 100644\n--- a/src/core/dense_set.h\n+++ b/src/core/dense_set.h\n@@ -258,6 +258,10 @@ class DenseSet {\n     return time_now_;\n   }\n \n+  bool ExpirationUsed() const {\n+    return expiration_used_;\n+  }\n+\n  protected:\n   // Virtual functions to be implemented for generic data\n   virtual uint64_t Hash(const void* obj, uint32_t cookie) const = 0;\n@@ -397,6 +401,8 @@ class DenseSet {\n   unsigned capacity_log_ = 0;\n \n   uint32_t time_now_ = 0;\n+\n+  mutable bool expiration_used_ = false;\n };\n \n inline void* DenseSet::FindInternal(const void* obj, uint64_t hashcode, uint32_t cookie) const {\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 9f3b17bb9248..a16c411c6e84 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -456,9 +456,7 @@ OpResult<std::string> OpDump(const OpArgs& op_args, string_view key) {\n     // According to Redis code we need to\n     // 1. Save the value itself - without the key\n     // 2. Save footer: this include the RDB version and the CRC value for the message\n-    unsigned obj_type = it->second.ObjType();\n-    unsigned encoding = it->second.Encoding();\n-    auto type = RdbObjectType(obj_type, encoding);\n+    auto type = RdbObjectType(it->second);\n     DVLOG(1) << \"We are going to dump object type: \" << type;\n     std::error_code ec = serializer.WriteOpcode(type);\n     CHECK(!ec);\ndiff --git a/src/server/rdb_extensions.h b/src/server/rdb_extensions.h\nindex 2fc936213e7a..50104eeb961a 100644\n--- a/src/server/rdb_extensions.h\n+++ b/src/server/rdb_extensions.h\n@@ -11,9 +11,12 @@ extern \"C\" {\n //  Custom types: Range 30-35 is used by DF RDB types.\n constexpr uint8_t RDB_TYPE_JSON_OLD = 20;\n constexpr uint8_t RDB_TYPE_JSON = 30;\n+constexpr uint8_t RDB_TYPE_HASH_WITH_EXPIRY = 31;\n+constexpr uint8_t RDB_TYPE_SET_WITH_EXPIRY = 32;\n \n constexpr bool rdbIsObjectTypeDF(uint8_t type) {\n-  return __rdbIsObjectType(type) || (type == RDB_TYPE_JSON);\n+  return __rdbIsObjectType(type) || (type == RDB_TYPE_JSON) ||\n+         (type == RDB_TYPE_HASH_WITH_EXPIRY) || (type == RDB_TYPE_SET_WITH_EXPIRY);\n }\n \n //  Opcodes: Range 200-240 is used by DF extensions.\ndiff --git a/src/server/rdb_load.cc b/src/server/rdb_load.cc\nindex 20136bb0cc9c..086902ab07a8 100644\n--- a/src/server/rdb_load.cc\n+++ b/src/server/rdb_load.cc\n@@ -439,9 +439,11 @@ void RdbLoaderBase::OpaqueObjLoader::operator()(const LzfString& lzfstr) {\n void RdbLoaderBase::OpaqueObjLoader::operator()(const unique_ptr<LoadTrace>& ptr) {\n   switch (rdb_type_) {\n     case RDB_TYPE_SET:\n+    case RDB_TYPE_SET_WITH_EXPIRY:\n       CreateSet(ptr.get());\n       break;\n     case RDB_TYPE_HASH:\n+    case RDB_TYPE_HASH_WITH_EXPIRY:\n       CreateHMap(ptr.get());\n       break;\n     case RDB_TYPE_LIST_QUICKLIST:\n@@ -468,7 +470,7 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {\n   size_t len = ltrace->blob_count();\n \n   bool is_intset = true;\n-  if (len <= SetFamily::MaxIntsetEntries()) {\n+  if (rdb_type_ == RDB_TYPE_HASH && ltrace->blob_count() <= SetFamily::MaxIntsetEntries()) {\n     Iterate(*ltrace, [&](const LoadBlob& blob) {\n       if (!holds_alternative<long long>(blob.rdb_var)) {\n         is_intset = false;\n@@ -506,12 +508,22 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {\n     });\n   } else {\n     bool use_set2 = GetFlag(FLAGS_use_set2);\n+\n     if (use_set2) {\n       StringSet* set = new StringSet{CompactObj::memory_resource()};\n+      set->set_time(MemberTimeSeconds(GetCurrentTimeMs()));\n       res = createObject(OBJ_SET, set);\n       res->encoding = OBJ_ENCODING_HT;\n     } else {\n       res = createSetObject();\n+\n+      if (rdb_type_ == RDB_TYPE_SET_WITH_EXPIRY) {\n+        LOG(ERROR) << \"Detected set with key expiration, but use_set2 is disabled. Unable to load \"\n+                      \"set - key will be ignored.\";\n+        pv_->ImportRObj(res);\n+        std::move(cleanup).Cancel();\n+        return;\n+      }\n     }\n \n     // TODO: to move this logic to set_family similarly to ConvertToStrSet.\n@@ -525,18 +537,41 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {\n     }\n \n     if (use_set2) {\n-      Iterate(*ltrace, [&](const LoadBlob& blob) {\n-        sdsele = ToSds(blob.rdb_var);\n-        if (!sdsele)\n-          return false;\n+      size_t increment = 1;\n+      if (rdb_type_ == RDB_TYPE_SET_WITH_EXPIRY) {\n+        increment = 2;\n+      }\n \n-        if (!((StringSet*)res->ptr)->AddSds(sdsele)) {\n-          LOG(ERROR) << \"Duplicate set members detected\";\n-          ec_ = RdbError(errc::duplicate_key);\n-          return false;\n+      auto set = (StringSet*)res->ptr;\n+      for (const auto& seg : ltrace->arr) {\n+        for (size_t i = 0; i < seg.size(); i += increment) {\n+          string_view element = ToSV(seg[i].rdb_var);\n+\n+          uint32_t ttl_sec = UINT32_MAX;\n+          if (increment == 2) {\n+            int64_t ttl_time = -1;\n+            string_view ttl_str = ToSV(seg[i + 1].rdb_var);\n+            if (!absl::SimpleAtoi(ttl_str, &ttl_time)) {\n+              LOG(ERROR) << \"Can't parse set TTL \" << ttl_str;\n+              ec_ = RdbError(errc::rdb_file_corrupted);\n+              return;\n+            }\n+\n+            if (ttl_time != -1) {\n+              if (ttl_time < set->time_now()) {\n+                continue;\n+              }\n+\n+              ttl_sec = ttl_time - set->time_now();\n+            }\n+          }\n+          if (!set->Add(element, ttl_sec)) {\n+            LOG(ERROR) << \"Duplicate set members detected\";\n+            ec_ = RdbError(errc::duplicate_key);\n+            return;\n+          }\n         }\n-        return true;\n-      });\n+      }\n     } else {\n       Iterate(*ltrace, [&](const LoadBlob& blob) {\n         sdsele = ToSds(blob.rdb_var);\n@@ -560,10 +595,14 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {\n }\n \n void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {\n-  size_t len = ltrace->blob_count() / 2;\n+  size_t increment = 2;\n+  if (rdb_type_ == RDB_TYPE_HASH_WITH_EXPIRY)\n+    increment = 3;\n+\n+  size_t len = ltrace->blob_count() / increment;\n \n   /* Too many entries? Use a hash table right from the start. */\n-  bool keep_lp = (len <= 64);\n+  bool keep_lp = (len <= 64) && (rdb_type_ != RDB_TYPE_HASH_WITH_EXPIRY);\n \n   size_t lp_size = 0;\n   if (keep_lp) {\n@@ -603,12 +642,13 @@ void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {\n     pv_->InitRobj(OBJ_HASH, kEncodingListPack, lp);\n   } else {\n     StringMap* string_map = new StringMap;\n+    string_map->set_time(MemberTimeSeconds(GetCurrentTimeMs()));\n \n     auto cleanup = absl::MakeCleanup([&] { delete string_map; });\n     std::string key;\n     string_map->Reserve(len);\n     for (const auto& seg : ltrace->arr) {\n-      for (size_t i = 0; i < seg.size(); i += 2) {\n+      for (size_t i = 0; i < seg.size(); i += increment) {\n         // ToSV may reference an internal buffer, therefore we can use only before the\n         // next call to ToSV. To workaround, copy the key locally.\n         key = ToSV(seg[i].rdb_var);\n@@ -617,7 +657,27 @@ void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {\n         if (ec_)\n           return;\n \n-        if (!string_map->AddOrSkip(key, val)) {\n+        uint32_t ttl_sec = UINT32_MAX;\n+        if (increment == 3) {\n+          int64_t ttl_time = -1;\n+          string_view ttl_str = ToSV(seg[i + 2].rdb_var);\n+          if (!absl::SimpleAtoi(ttl_str, &ttl_time)) {\n+            LOG(ERROR) << \"Can't parse hashmap TTL for \" << key << \", val=\" << val\n+                       << \", ttl=\" << ttl_str;\n+            ec_ = RdbError(errc::rdb_file_corrupted);\n+            return;\n+          }\n+\n+          if (ttl_time != -1) {\n+            if (ttl_time < string_map->time_now()) {\n+              continue;\n+            }\n+\n+            ttl_sec = ttl_time - string_map->time_now();\n+          }\n+        }\n+\n+        if (!string_map->AddOrSkip(key, val, ttl_sec)) {\n           LOG(ERROR) << \"Duplicate hash fields detected for field \" << key;\n           ec_ = RdbError(errc::rdb_file_corrupted);\n           return;\n@@ -1310,7 +1370,8 @@ error_code RdbLoaderBase::ReadObj(int rdbtype, OpaqueObj* dest) {\n       return ReadStringObj(&dest->obj);\n     }\n     case RDB_TYPE_SET:\n-      iores = ReadSet();\n+    case RDB_TYPE_SET_WITH_EXPIRY:\n+      iores = ReadSet(rdbtype);\n       break;\n     case RDB_TYPE_SET_INTSET:\n       iores = ReadIntSet();\n@@ -1321,7 +1382,8 @@ error_code RdbLoaderBase::ReadObj(int rdbtype, OpaqueObj* dest) {\n       iores = ReadGeneric(rdbtype);\n       break;\n     case RDB_TYPE_HASH:\n-      iores = ReadHMap();\n+    case RDB_TYPE_HASH_WITH_EXPIRY:\n+      iores = ReadHMap(rdbtype);\n       break;\n     case RDB_TYPE_ZSET:\n     case RDB_TYPE_ZSET_2:\n@@ -1439,12 +1501,13 @@ auto RdbLoaderBase::ReadLzf() -> io::Result<LzfString> {\n   return res;\n }\n \n-auto RdbLoaderBase::ReadSet() -> io::Result<OpaqueObj> {\n+auto RdbLoaderBase::ReadSet(int rdbtype) -> io::Result<OpaqueObj> {\n   size_t len;\n   SET_OR_UNEXPECT(LoadLen(NULL), len);\n \n-  if (len == 0)\n-    return Unexpected(errc::empty_key);\n+  if (rdbtype == RDB_TYPE_SET_WITH_EXPIRY) {\n+    len *= 2;\n+  }\n \n   unique_ptr<LoadTrace> load_trace(new LoadTrace);\n   load_trace->arr.resize((len + kMaxBlobLen - 1) / kMaxBlobLen);\n@@ -1459,7 +1522,7 @@ auto RdbLoaderBase::ReadSet() -> io::Result<OpaqueObj> {\n     }\n   }\n \n-  return OpaqueObj{std::move(load_trace), RDB_TYPE_SET};\n+  return OpaqueObj{std::move(load_trace), rdbtype};\n }\n \n auto RdbLoaderBase::ReadIntSet() -> io::Result<OpaqueObj> {\n@@ -1498,16 +1561,19 @@ auto RdbLoaderBase::ReadGeneric(int rdbtype) -> io::Result<OpaqueObj> {\n   return OpaqueObj{std::move(str_obj), rdbtype};\n }\n \n-auto RdbLoaderBase::ReadHMap() -> io::Result<OpaqueObj> {\n+auto RdbLoaderBase::ReadHMap(int rdbtype) -> io::Result<OpaqueObj> {\n   size_t len;\n   SET_OR_UNEXPECT(LoadLen(nullptr), len);\n \n-  if (len == 0)\n-    return Unexpected(errc::empty_key);\n-\n   unique_ptr<LoadTrace> load_trace(new LoadTrace);\n \n-  len *= 2;\n+  if (rdbtype == RDB_TYPE_HASH) {\n+    len *= 2;\n+  } else {\n+    DCHECK_EQ(rdbtype, RDB_TYPE_HASH_WITH_EXPIRY);\n+    len *= 3;\n+  }\n+\n   load_trace->arr.resize((len + kMaxBlobLen - 1) / kMaxBlobLen);\n   for (size_t i = 0; i < load_trace->arr.size(); ++i) {\n     size_t n = std::min<size_t>(len, kMaxBlobLen);\n@@ -1520,7 +1586,7 @@ auto RdbLoaderBase::ReadHMap() -> io::Result<OpaqueObj> {\n     len -= n;\n   }\n \n-  return OpaqueObj{std::move(load_trace), RDB_TYPE_HASH};\n+  return OpaqueObj{std::move(load_trace), rdbtype};\n }\n \n auto RdbLoaderBase::ReadZSet(int rdbtype) -> io::Result<OpaqueObj> {\ndiff --git a/src/server/rdb_load.h b/src/server/rdb_load.h\nindex 59159ccfb818..8b14c795a3a0 100644\n--- a/src/server/rdb_load.h\n+++ b/src/server/rdb_load.h\n@@ -124,10 +124,10 @@ class RdbLoaderBase {\n   ::io::Result<long long> ReadIntObj(int encoding);\n   ::io::Result<LzfString> ReadLzf();\n \n-  ::io::Result<OpaqueObj> ReadSet();\n+  ::io::Result<OpaqueObj> ReadSet(int rdbtype);\n   ::io::Result<OpaqueObj> ReadIntSet();\n   ::io::Result<OpaqueObj> ReadGeneric(int rdbtype);\n-  ::io::Result<OpaqueObj> ReadHMap();\n+  ::io::Result<OpaqueObj> ReadHMap(int rdbtype);\n   ::io::Result<OpaqueObj> ReadZSet(int rdbtype);\n   ::io::Result<OpaqueObj> ReadZSetZL();\n   ::io::Result<OpaqueObj> ReadListQuicklist(int rdbtype);\ndiff --git a/src/server/rdb_save.cc b/src/server/rdb_save.cc\nindex fd03238f3f66..c485484b8cac 100644\n--- a/src/server/rdb_save.cc\n+++ b/src/server/rdb_save.cc\n@@ -109,7 +109,9 @@ constexpr size_t kAmask = 4_KB - 1;\n \n }  // namespace\n \n-uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {\n+uint8_t RdbObjectType(const PrimeValue& pv) {\n+  unsigned type = pv.ObjType();\n+  unsigned compact_enc = pv.Encoding();\n   switch (type) {\n     case OBJ_STRING:\n       return RDB_TYPE_STRING;\n@@ -120,8 +122,12 @@ uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {\n     case OBJ_SET:\n       if (compact_enc == kEncodingIntSet)\n         return RDB_TYPE_SET_INTSET;\n-      else if (compact_enc == kEncodingStrMap || compact_enc == kEncodingStrMap2)\n-        return RDB_TYPE_SET;\n+      else if (compact_enc == kEncodingStrMap || compact_enc == kEncodingStrMap2) {\n+        if (((StringSet*)pv.RObjPtr())->ExpirationUsed())\n+          return RDB_TYPE_SET_WITH_EXPIRY;\n+        else\n+          return RDB_TYPE_SET;\n+      }\n       break;\n     case OBJ_ZSET:\n       if (compact_enc == OBJ_ENCODING_LISTPACK)\n@@ -132,8 +138,12 @@ uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {\n     case OBJ_HASH:\n       if (compact_enc == kEncodingListPack)\n         return RDB_TYPE_HASH_ZIPLIST;\n-      else if (compact_enc == kEncodingStrMap2)\n-        return RDB_TYPE_HASH;\n+      else if (compact_enc == kEncodingStrMap2) {\n+        if (((StringMap*)pv.RObjPtr())->ExpirationUsed())\n+          return RDB_TYPE_HASH_WITH_EXPIRY;  // Incompatible with Redis\n+        else\n+          return RDB_TYPE_HASH;\n+      }\n       break;\n     case OBJ_STREAM:\n       return RDB_TYPE_STREAM_LISTPACKS;\n@@ -293,9 +303,7 @@ io::Result<uint8_t> RdbSerializer::SaveEntry(const PrimeKey& pk, const PrimeValu\n   }\n \n   string_view key = pk.GetSlice(&tmp_str_);\n-  unsigned obj_type = pv.ObjType();\n-  unsigned encoding = pv.Encoding();\n-  uint8_t rdb_type = RdbObjectType(obj_type, encoding);\n+  uint8_t rdb_type = RdbObjectType(pv);\n \n   DVLOG(3) << ((void*)this) << \": Saving key/val start \" << key << \" in dbid=\" << dbid;\n \n@@ -416,8 +424,14 @@ error_code RdbSerializer::SaveSetObject(const PrimeValue& obj) {\n \n     RETURN_ON_ERR(SaveLen(set->SizeSlow()));\n \n-    for (sds ele : *set) {\n-      RETURN_ON_ERR(SaveString(string_view{ele, sdslen(ele)}));\n+    for (auto it = set->begin(); it != set->end(); ++it) {\n+      RETURN_ON_ERR(SaveString(string_view{*it, sdslen(*it)}));\n+      if (set->ExpirationUsed()) {\n+        int64_t expiry = -1;\n+        if (it.HasExpiry())\n+          expiry = it.ExpiryTime();\n+        RETURN_ON_ERR(SaveLongLongAsString(expiry));\n+      }\n     }\n   } else {\n     CHECK_EQ(obj.Encoding(), kEncodingIntSet);\n@@ -438,9 +452,16 @@ error_code RdbSerializer::SaveHSetObject(const PrimeValue& pv) {\n \n     RETURN_ON_ERR(SaveLen(string_map->SizeSlow()));\n \n-    for (const auto& k_v : *string_map) {\n-      RETURN_ON_ERR(SaveString(string_view{k_v.first, sdslen(k_v.first)}));\n-      RETURN_ON_ERR(SaveString(string_view{k_v.second, sdslen(k_v.second)}));\n+    for (auto it = string_map->begin(); it != string_map->end(); ++it) {\n+      const auto& [k, v] = *it;\n+      RETURN_ON_ERR(SaveString(string_view{k, sdslen(k)}));\n+      RETURN_ON_ERR(SaveString(string_view{v, sdslen(v)}));\n+      if (string_map->ExpirationUsed()) {\n+        int64_t expiry = -1;\n+        if (it.HasExpiry())\n+          expiry = it.ExpiryTime();\n+        RETURN_ON_ERR(SaveLongLongAsString(expiry));\n+      }\n     }\n   } else {\n     CHECK_EQ(kEncodingListPack, pv.Encoding());\ndiff --git a/src/server/rdb_save.h b/src/server/rdb_save.h\nindex cafc0380a7e1..507e923b9e54 100644\n--- a/src/server/rdb_save.h\n+++ b/src/server/rdb_save.h\n@@ -25,7 +25,7 @@ typedef struct streamCG streamCG;\n \n namespace dfly {\n \n-uint8_t RdbObjectType(unsigned type, unsigned encoding);\n+uint8_t RdbObjectType(const PrimeValue& pv);\n \n class EngineShard;\n class Service;\n",
  "test_patch": "diff --git a/src/core/string_set_test.cc b/src/core/string_set_test.cc\nindex 3d2f4b138c19..58e3ba656a60 100644\n--- a/src/core/string_set_test.cc\n+++ b/src/core/string_set_test.cc\n@@ -448,4 +448,11 @@ TEST_F(StringSetTest, Reserve) {\n   }\n }\n \n+TEST_F(StringSetTest, IterateEmpty) {\n+  for (const auto& s : *ss_) {\n+    // We're iterating to make sure there is no crash. However, if we got here, it's a bug\n+    CHECK(false) << \"Found entry \" << s << \" in empty set\";\n+  }\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/rdb_test.cc b/src/server/rdb_test.cc\nindex 69f266c7378f..cc6c7259a0be 100644\n--- a/src/server/rdb_test.cc\n+++ b/src/server/rdb_test.cc\n@@ -257,6 +257,55 @@ TEST_F(RdbTest, ReloadExpired) {\n   ASSERT_THAT(resp, ArgType(RespExpr::NIL));\n }\n \n+TEST_F(RdbTest, HashmapExpiry) {\n+  // Add non-expiring elements\n+  Run({\"hset\", \"key\", \"key1\", \"val1\", \"key2\", \"val2\"});\n+  Run({\"debug\", \"reload\"});\n+  EXPECT_THAT(Run({\"hgetall\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"val1\", \"key2\", \"val2\")));\n+\n+  // Add expiring elements\n+  Run({\"hsetex\", \"key\", \"5\", \"key3\", \"val3\", \"key4\", \"val4\"});\n+  Run({\"debug\", \"reload\"});  // Reload before expiration\n+  EXPECT_THAT(Run({\"hgetall\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"val1\", \"key2\", \"val2\", \"key3\", \"val3\", \"key4\",\n+                                             \"val4\")));\n+  AdvanceTime(10'000);\n+  EXPECT_THAT(Run({\"hgetall\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"val1\", \"key2\", \"val2\")));\n+\n+  Run({\"hsetex\", \"key\", \"5\", \"key5\", \"val5\", \"key6\", \"val6\"});\n+  EXPECT_THAT(Run({\"hgetall\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"val1\", \"key2\", \"val2\", \"key5\", \"val5\", \"key6\",\n+                                             \"val6\")));\n+  AdvanceTime(10'000);\n+  Run({\"debug\", \"reload\"});  // Reload after expiration\n+  EXPECT_THAT(Run({\"hgetall\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"val1\", \"key2\", \"val2\")));\n+}\n+\n+TEST_F(RdbTest, SetExpiry) {\n+  // Add non-expiring elements\n+  Run({\"sadd\", \"key\", \"key1\", \"key2\"});\n+  Run({\"debug\", \"reload\"});\n+  EXPECT_THAT(Run({\"smembers\", \"key\"}), RespArray(UnorderedElementsAre(\"key1\", \"key2\")));\n+\n+  // Add expiring elements\n+  Run({\"saddex\", \"key\", \"5\", \"key3\", \"key4\"});\n+  Run({\"debug\", \"reload\"});  // Reload before expiration\n+  EXPECT_THAT(Run({\"smembers\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"key2\", \"key3\", \"key4\")));\n+  AdvanceTime(10'000);\n+  EXPECT_THAT(Run({\"smembers\", \"key\"}), RespArray(UnorderedElementsAre(\"key1\", \"key2\")));\n+\n+  Run({\"saddex\", \"key\", \"5\", \"key5\", \"key6\"});\n+  EXPECT_THAT(Run({\"smembers\", \"key\"}),\n+              RespArray(UnorderedElementsAre(\"key1\", \"key2\", \"key5\", \"key6\")));\n+  AdvanceTime(10'000);\n+  Run({\"debug\", \"reload\"});  // Reload after expiration\n+  EXPECT_THAT(Run({\"smembers\", \"key\"}), RespArray(UnorderedElementsAre(\"key1\", \"key2\")));\n+}\n+\n TEST_F(RdbTest, SaveFlush) {\n   Run({\"debug\", \"populate\", \"500000\"});\n \n",
  "problem_statement": "Set and hash field expirations are not persisted after restart\n**Describe the bug**\r\nWhen using Dragonfly-specific functionality that enables setting expiration for fields, i.e HSETEX and SADDEX, the expiration is not persisted after restarting Dragonfly.\r\n\r\n\r\n**To Reproduce**\r\n```\r\nHSETEX myhash 30 foo bar\r\n\r\nrestart Dragonfly\r\nsleep 30;\r\nHGET myhash foo\r\nbar  < --- field foo still exists\r\n```\r\n\r\n**Expected behavior**\r\n```\r\nHSETEX myhash 30 foo bar\r\n\r\nrestart Dragonfly\r\nsleep 30;\r\nHGET myhash foo\r\n(nil)\r\n```\r\n\r\n\r\n**Environment (please complete the following information):**\r\n - Dragonfly Version: Dragonfly HEAD\r\n\n",
  "hints_text": "This bug also affects replication in (at least?) 2 ways:\r\n\r\n1. Replica which connects _after_ a key with element expiry was set will never remove the expired element (it will simply not know about the expiration)\r\n2. Replica which connects _before_ a key was set (i.e. that it gets the original command `HSETEX` command) will remove the items on its own, instead of waiting for expiration removal event coming from the master\nAnd fixing this is not trivial as it:\r\n1. Will break compatibility with Redis RDB format\r\n2. Will break compatibility with old Dragonfly replicas\r\n3. Will break compatibility with old Dragonfly servers trying to load new RDB files\r\n\r\nAll of these can and should be resolved, but I'm trying to say that it's not an easy solution and we need to be careful here.",
  "created_at": "2023-11-27T12:29:41Z",
  "modified_files": [
    "src/core/dense_set.cc",
    "src/core/dense_set.h",
    "src/server/generic_family.cc",
    "src/server/rdb_extensions.h",
    "src/server/rdb_load.cc",
    "src/server/rdb_load.h",
    "src/server/rdb_save.cc",
    "src/server/rdb_save.h"
  ],
  "modified_test_files": [
    "src/core/string_set_test.cc",
    "src/server/rdb_test.cc"
  ]
}