{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1533,
  "instance_id": "dragonflydb__dragonfly-1533",
  "issue_numbers": [
    "1517"
  ],
  "base_commit": "ee68f1bcccd157023c6086f103daa51f5ec51b67",
  "patch": "diff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex a4705240ea41..d8fd57e87beb 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -73,13 +73,48 @@ struct AddTrimOpts {\n   bool no_mkstream = false;\n };\n \n+struct NACKInfo {\n+  streamID pel_id;\n+  string consumer_name;\n+  size_t delivery_time;\n+  size_t delivery_count;\n+};\n+\n+struct ConsumerInfo {\n+  string name;\n+  size_t seen_time;\n+  size_t pel_count;\n+  vector<NACKInfo> pending;\n+  size_t idle;\n+};\n+\n struct GroupInfo {\n   string name;\n   size_t consumer_size;\n   size_t pending_size;\n   streamID last_id;\n+  size_t pel_count;\n   int64_t entries_read;\n   int64_t lag;\n+  vector<NACKInfo> stream_nack_vec;\n+  vector<ConsumerInfo> consumer_info_vec;\n+};\n+\n+using GroupInfoVec = vector<GroupInfo>;\n+\n+struct StreamInfo {\n+  size_t length;\n+  size_t radix_tree_keys;\n+  size_t radix_tree_nodes;\n+  size_t groups;\n+  streamID recorded_first_entry_id;\n+  streamID last_generated_id;\n+  streamID max_deleted_entry_id;\n+  size_t entries_added;\n+  Record first_entry;\n+  Record last_entry;\n+  vector<Record> entries;\n+  GroupInfoVec cgroups;\n };\n \n struct RangeOpts {\n@@ -876,6 +911,204 @@ OpResult<vector<GroupInfo>> OpListGroups(const DbContext& db_cntx, string_view k\n   return result;\n }\n \n+vector<Record> GetStreamRecords(stream* s, streamID start, streamID end, bool reverse,\n+                                size_t count) {\n+  streamIterator si;\n+  int64_t numfields;\n+  streamID id;\n+  size_t arraylen = 0;\n+  vector<Record> records;\n+\n+  streamIteratorStart(&si, s, &start, &end, reverse);\n+  while (streamIteratorGetID(&si, &id, &numfields)) {\n+    Record rec;\n+    rec.id = id;\n+    rec.kv_arr.reserve(numfields);\n+\n+    while (numfields--) {\n+      unsigned char *key, *value;\n+      int64_t key_len, value_len;\n+      streamIteratorGetField(&si, &key, &value, &key_len, &value_len);\n+      string skey(reinterpret_cast<char*>(key), key_len);\n+      string sval(reinterpret_cast<char*>(value), value_len);\n+\n+      rec.kv_arr.emplace_back(move(skey), move(sval));\n+    }\n+    records.push_back(std::move(rec));\n+    arraylen++;\n+    if (count && count == arraylen)\n+      break;\n+  }\n+\n+  streamIteratorStop(&si);\n+\n+  return records;\n+}\n+\n+void GetGroupPEL(stream* s, streamCG* cg, long long count, GroupInfo* ginfo) {\n+  vector<NACKInfo> nack_info_vec;\n+  long long arraylen_cg_pel = 0;\n+  raxIterator ri_cg_pel;\n+  raxStart(&ri_cg_pel, cg->pel);\n+  raxSeek(&ri_cg_pel, \"^\", NULL, 0);\n+  while (raxNext(&ri_cg_pel) && (!count || arraylen_cg_pel < count)) {\n+    streamNACK* nack = static_cast<streamNACK*>(ri_cg_pel.data);\n+    NACKInfo nack_info;\n+\n+    streamID id;\n+    streamDecodeID(ri_cg_pel.key, &id);\n+    nack_info.pel_id = id;\n+    nack_info.consumer_name = nack->consumer->name;\n+    nack_info.delivery_time = nack->delivery_time;\n+    nack_info.delivery_count = nack->delivery_count;\n+\n+    nack_info_vec.push_back(nack_info);\n+    arraylen_cg_pel++;\n+  }\n+  raxStop(&ri_cg_pel);\n+  ginfo->stream_nack_vec = std::move(nack_info_vec);\n+}\n+\n+void GetConsumers(stream* s, streamCG* cg, long long count, GroupInfo* ginfo) {\n+  vector<ConsumerInfo> consumer_info_vec;\n+  raxIterator ri_consumers;\n+  raxStart(&ri_consumers, cg->consumers);\n+  raxSeek(&ri_consumers, \"^\", NULL, 0);\n+  while (raxNext(&ri_consumers)) {\n+    ConsumerInfo consumer_info;\n+    streamConsumer* consumer = static_cast<streamConsumer*>(ri_consumers.data);\n+\n+    consumer_info.name = consumer->name;\n+    consumer_info.seen_time = consumer->seen_time;\n+    consumer_info.pel_count = raxSize(consumer->pel);\n+\n+    /* Consumer PEL */\n+    long long arraylen_cpel = 0;\n+    raxIterator ri_cpel;\n+    raxStart(&ri_cpel, consumer->pel);\n+    raxSeek(&ri_cpel, \"^\", NULL, 0);\n+    vector<NACKInfo> consumer_pel_vec;\n+    while (raxNext(&ri_cpel) && (!count || arraylen_cpel < count)) {\n+      NACKInfo nack_info;\n+      streamNACK* nack = static_cast<streamNACK*>(ri_cpel.data);\n+\n+      streamID id;\n+      streamDecodeID(ri_cpel.key, &id);\n+      nack_info.pel_id = id;\n+      nack_info.delivery_time = nack->delivery_time;\n+      nack_info.delivery_count = nack->delivery_count;\n+\n+      consumer_pel_vec.push_back(nack_info);\n+      arraylen_cpel++;\n+    }\n+    consumer_info.pending = consumer_pel_vec;\n+    consumer_info_vec.push_back(consumer_info);\n+    raxStop(&ri_cpel);\n+  }\n+  raxStop(&ri_consumers);\n+  ginfo->consumer_info_vec = std::move(consumer_info_vec);\n+}\n+\n+OpResult<StreamInfo> OpStreams(const DbContext& db_cntx, string_view key, EngineShard* shard,\n+                               int full, size_t count) {\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(db_cntx, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  vector<StreamInfo> result;\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* s = (stream*)cobj.RObjPtr();\n+\n+  StreamInfo sinfo;\n+  sinfo.length = s->length;\n+\n+  sinfo.radix_tree_keys = raxSize(s->rax_tree);\n+  sinfo.radix_tree_nodes = s->rax_tree->numnodes;\n+  sinfo.last_generated_id = s->last_id;\n+  sinfo.max_deleted_entry_id = s->max_deleted_entry_id;\n+  sinfo.entries_added = s->entries_added;\n+  sinfo.recorded_first_entry_id = s->first_id;\n+  sinfo.groups = s->cgroups ? raxSize(s->cgroups) : 0;\n+  sinfo.entries = GetStreamRecords(s, s->first_id, s->last_id, false, count);\n+\n+  if (full) {\n+    if (s->cgroups) {\n+      GroupInfoVec group_info_vec;\n+\n+      raxIterator ri_cgroups;\n+      raxStart(&ri_cgroups, s->cgroups);\n+      raxSeek(&ri_cgroups, \"^\", NULL, 0);\n+      while (raxNext(&ri_cgroups)) {\n+        streamCG* cg = (streamCG*)ri_cgroups.data;\n+        GroupInfo ginfo;\n+        ginfo.name.assign(reinterpret_cast<char*>(ri_cgroups.key), ri_cgroups.key_len);\n+        ginfo.last_id = cg->last_id;\n+        ginfo.consumer_size = raxSize(cg->consumers);\n+        ginfo.pending_size = raxSize(cg->pel);\n+        ginfo.entries_read = cg->entries_read;\n+        ginfo.lag = streamCGLag(s, cg);\n+        ginfo.pel_count = raxSize(cg->pel);\n+        GetGroupPEL(s, cg, count, &ginfo);\n+        GetConsumers(s, cg, count, &ginfo);\n+\n+        group_info_vec.push_back(ginfo);\n+      }\n+      raxStop(&ri_cgroups);\n+\n+      sinfo.cgroups = group_info_vec;\n+    }\n+  } else {\n+    vector<Record> first_entry_vector = GetStreamRecords(s, s->first_id, s->last_id, false, 1);\n+    if (first_entry_vector.size() != 0) {\n+      sinfo.first_entry = first_entry_vector.at(0);\n+    }\n+    vector<Record> last_entry_vector = GetStreamRecords(s, s->first_id, s->last_id, true, 1);\n+    if (last_entry_vector.size() != 0) {\n+      sinfo.last_entry = last_entry_vector.at(0);\n+    }\n+  }\n+\n+  return sinfo;\n+}\n+\n+OpResult<vector<ConsumerInfo>> OpConsumers(const DbContext& db_cntx, EngineShard* shard,\n+                                           string_view stream_name, string_view group_name) {\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(db_cntx, stream_name, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  vector<ConsumerInfo> result;\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* s = (stream*)cobj.RObjPtr();\n+  shard->tmp_str1 = sdscpylen(shard->tmp_str1, group_name.data(), group_name.length());\n+  streamCG* cg = streamLookupCG(s, shard->tmp_str1);\n+  if (cg == NULL) {\n+    return OpStatus::INVALID_VALUE;\n+  }\n+  result.reserve(raxSize(s->cgroups));\n+\n+  raxIterator ri;\n+  raxStart(&ri, cg->consumers);\n+  raxSeek(&ri, \"^\", NULL, 0);\n+  mstime_t now = mstime();\n+  while (raxNext(&ri)) {\n+    ConsumerInfo consumer_info;\n+    streamConsumer* consumer = (streamConsumer*)ri.data;\n+    mstime_t idle = now - consumer->seen_time;\n+    if (idle < 0)\n+      idle = 0;\n+\n+    consumer_info.name = consumer->name;\n+    consumer_info.pel_count = raxSize(consumer->pel);\n+    consumer_info.idle = idle;\n+    result.push_back(std::move(consumer_info));\n+  }\n+  raxStop(&ri);\n+  return result;\n+}\n+\n constexpr uint8_t kCreateOptMkstream = 1 << 0;\n \n struct CreateOpts {\n@@ -1906,14 +2139,14 @@ void StreamFamily::XInfo(CmdArgList args, ConnectionContext* cntx) {\n   ToUpper(&args[0]);\n   string_view sub_cmd = ArgS(args, 0);\n   if (sub_cmd == \"HELP\") {\n-    string_view help_arr[] = {\n-        \"CONSUMERS <key> <groupname>\",\n-        \"    Show consumers of <groupname>.\",\n-        \"GROUPS <key>\",\n-        \"    Show the stream consumer groups.\",\n-        \"STREAM <key> [FULL [COUNT <count>]\",\n-        \"    Show information about the stream.\",\n-    };\n+    string_view help_arr[] = {\"CONSUMERS <key> <groupname>\",\n+                              \"    Show consumers of <groupname>.\",\n+                              \"GROUPS <key>\",\n+                              \"    Show the stream consumer groups.\",\n+                              \"STREAM <key> [FULL [COUNT <count>]\",\n+                              \"    Show information about the stream.\",\n+                              \"HELP\",\n+                              \"    Prints this help.\"};\n     return (*cntx)->SendSimpleStrArr(help_arr);\n   }\n \n@@ -1960,6 +2193,212 @@ void StreamFamily::XInfo(CmdArgList args, ConnectionContext* cntx) {\n         return;\n       }\n       return (*cntx)->SendError(result.status());\n+    } else if (sub_cmd == \"STREAM\") {\n+      int full = 0;\n+      size_t count = 10;  // default count for xinfo streams\n+\n+      if (args.size() == 4 || args.size() > 5) {\n+        return (*cntx)->SendError(\n+            \"unknown subcommand or wrong number of arguments for 'STREAM'. Try XINFO HELP.\");\n+      }\n+\n+      if (args.size() >= 3) {\n+        full = 1;\n+        ToUpper(&args[2]);\n+        string_view full_arg = ArgS(args, 2);\n+        if (full_arg != \"FULL\") {\n+          return (*cntx)->SendError(\n+              \"unknown subcommand or wrong number of arguments for 'STREAM'. Try XINFO HELP.\");\n+        }\n+        if (args.size() > 3) {\n+          ToUpper(&args[3]);\n+          string_view count_arg = ArgS(args, 3);\n+          string_view count_value_arg = ArgS(args, 4);\n+          if (count_arg != \"COUNT\") {\n+            return (*cntx)->SendError(\n+                \"unknown subcommand or wrong number of arguments for 'STREAM'. Try XINFO HELP.\");\n+          }\n+\n+          if (!absl::SimpleAtoi(count_value_arg, &count)) {\n+            return (*cntx)->SendError(kInvalidIntErr);\n+          }\n+        }\n+      }\n+\n+      auto cb = [&]() {\n+        EngineShard* shard = EngineShard::tlocal();\n+        DbContext db_context{.db_index = cntx->db_index(), .time_now_ms = GetCurrentTimeMs()};\n+        return OpStreams(db_context, key, shard, full, count);\n+      };\n+\n+      OpResult<StreamInfo> sinfo = shard_set->Await(sid, std::move(cb));\n+      if (sinfo) {\n+        if (full) {\n+          (*cntx)->StartCollection(9, RedisReplyBuilder::MAP);\n+        } else {\n+          (*cntx)->StartCollection(10, RedisReplyBuilder::MAP);\n+        }\n+\n+        (*cntx)->SendBulkString(\"length\");\n+        (*cntx)->SendLong(sinfo->length);\n+\n+        (*cntx)->SendBulkString(\"radix-tree-keys\");\n+        (*cntx)->SendLong(sinfo->radix_tree_keys);\n+\n+        (*cntx)->SendBulkString(\"radix-tree-nodes\");\n+        (*cntx)->SendLong(sinfo->radix_tree_nodes);\n+\n+        (*cntx)->SendBulkString(\"last-generated-id\");\n+        (*cntx)->SendBulkString(StreamIdRepr(sinfo->last_generated_id));\n+\n+        (*cntx)->SendBulkString(\"max-deleted-entry-id\");\n+        (*cntx)->SendBulkString(StreamIdRepr(sinfo->max_deleted_entry_id));\n+\n+        (*cntx)->SendBulkString(\"entries-added\");\n+        (*cntx)->SendLong(sinfo->entries_added);\n+\n+        (*cntx)->SendBulkString(\"recorded-first-entry-id\");\n+        (*cntx)->SendBulkString(StreamIdRepr(sinfo->recorded_first_entry_id));\n+\n+        if (full) {\n+          (*cntx)->SendBulkString(\"entries\");\n+          (*cntx)->StartArray(sinfo->entries.size());\n+          for (const auto& entry : sinfo->entries) {\n+            (*cntx)->StartArray(2);\n+            (*cntx)->SendBulkString(StreamIdRepr(entry.id));\n+            (*cntx)->StartArray(2);\n+            for (const auto& k_v : entry.kv_arr) {\n+              (*cntx)->SendBulkString(k_v.first);\n+              (*cntx)->SendBulkString(k_v.second);\n+            }\n+          }\n+\n+          (*cntx)->SendBulkString(\"groups\");\n+          (*cntx)->StartArray(sinfo->cgroups.size());\n+          for (const auto& ginfo : sinfo->cgroups) {\n+            (*cntx)->StartCollection(7, RedisReplyBuilder::MAP);\n+\n+            (*cntx)->SendBulkString(\"name\");\n+            (*cntx)->SendBulkString(ginfo.name);\n+\n+            (*cntx)->SendBulkString(\"last-delivered-id\");\n+            (*cntx)->SendBulkString(StreamIdRepr(ginfo.last_id));\n+\n+            (*cntx)->SendBulkString(\"entries-read\");\n+            if (ginfo.entries_read != SCG_INVALID_ENTRIES_READ) {\n+              (*cntx)->SendLong(ginfo.entries_read);\n+            } else {\n+              (*cntx)->SendNull();\n+            }\n+            (*cntx)->SendBulkString(\"lag\");\n+            if (ginfo.lag != SCG_INVALID_LAG) {\n+              (*cntx)->SendLong(ginfo.lag);\n+            } else {\n+              (*cntx)->SendNull();\n+            }\n+\n+            (*cntx)->SendBulkString(\"pel-count\");\n+            (*cntx)->SendLong(ginfo.pel_count);\n+\n+            (*cntx)->SendBulkString(\"pending\");\n+            (*cntx)->StartArray(ginfo.stream_nack_vec.size());\n+            for (const auto& pending_info : ginfo.stream_nack_vec) {\n+              (*cntx)->StartArray(4);\n+              (*cntx)->SendBulkString(StreamIdRepr(pending_info.pel_id));\n+              (*cntx)->SendBulkString(pending_info.consumer_name);\n+              (*cntx)->SendLong(pending_info.delivery_time);\n+              (*cntx)->SendLong(pending_info.delivery_count);\n+            }\n+\n+            (*cntx)->SendBulkString(\"consumers\");\n+            (*cntx)->StartArray(ginfo.consumer_info_vec.size());\n+            for (const auto& consumer_info : ginfo.consumer_info_vec) {\n+              (*cntx)->StartCollection(4, RedisReplyBuilder::MAP);\n+\n+              (*cntx)->SendBulkString(\"name\");\n+              (*cntx)->SendBulkString(consumer_info.name);\n+\n+              (*cntx)->SendBulkString(\"seen-time\");\n+              (*cntx)->SendLong(consumer_info.seen_time);\n+\n+              (*cntx)->SendBulkString(\"pel-count\");\n+              (*cntx)->SendLong(consumer_info.pel_count);\n+\n+              (*cntx)->SendBulkString(\"pending\");\n+              if (consumer_info.pending.size() == 0) {\n+                (*cntx)->SendEmptyArray();\n+              } else {\n+                (*cntx)->StartArray(consumer_info.pending.size());\n+              }\n+              for (const auto& pending : consumer_info.pending) {\n+                (*cntx)->StartArray(3);\n+\n+                (*cntx)->SendBulkString(StreamIdRepr(pending.pel_id));\n+                (*cntx)->SendLong(pending.delivery_time);\n+                (*cntx)->SendLong(pending.delivery_count);\n+              }\n+            }\n+          }\n+        } else {\n+          (*cntx)->SendBulkString(\"groups\");\n+          (*cntx)->SendLong(sinfo->groups);\n+\n+          (*cntx)->SendBulkString(\"first-entry\");\n+          if (sinfo->first_entry.kv_arr.size() != 0) {\n+            (*cntx)->StartArray(2);\n+            (*cntx)->SendBulkString(StreamIdRepr(sinfo->first_entry.id));\n+            (*cntx)->StartArray(sinfo->first_entry.kv_arr.size() * 2);\n+            for (pair<string, string> k_v : sinfo->first_entry.kv_arr) {\n+              (*cntx)->SendBulkString(k_v.first);\n+              (*cntx)->SendBulkString(k_v.second);\n+            }\n+          } else {\n+            (*cntx)->SendNullArray();\n+          }\n+\n+          (*cntx)->SendBulkString(\"last-entry\");\n+          if (sinfo->last_entry.kv_arr.size() != 0) {\n+            (*cntx)->StartArray(2);\n+            (*cntx)->SendBulkString(StreamIdRepr(sinfo->last_entry.id));\n+            (*cntx)->StartArray(sinfo->last_entry.kv_arr.size() * 2);\n+            for (pair<string, string> k_v : sinfo->last_entry.kv_arr) {\n+              (*cntx)->SendBulkString(k_v.first);\n+              (*cntx)->SendBulkString(k_v.second);\n+            }\n+          } else {\n+            (*cntx)->SendNullArray();\n+          }\n+        }\n+        return;\n+      }\n+      return (*cntx)->SendError(sinfo.status());\n+    } else if (sub_cmd == \"CONSUMERS\") {\n+      string_view stream_name = ArgS(args, 1);\n+      string_view group_name = ArgS(args, 2);\n+      auto cb = [&]() {\n+        EngineShard* shard = EngineShard::tlocal();\n+        DbContext db_context{.db_index = cntx->db_index(), .time_now_ms = GetCurrentTimeMs()};\n+        return OpConsumers(db_context, shard, stream_name, group_name);\n+      };\n+\n+      OpResult<vector<ConsumerInfo>> result = shard_set->Await(sid, std::move(cb));\n+      if (result) {\n+        (*cntx)->StartArray(result->size());\n+        for (const auto& consumer_info : *result) {\n+          (*cntx)->StartCollection(3, RedisReplyBuilder::MAP);\n+          (*cntx)->SendBulkString(\"name\");\n+          (*cntx)->SendBulkString(consumer_info.name);\n+          (*cntx)->SendBulkString(\"pending\");\n+          (*cntx)->SendLong(consumer_info.pel_count);\n+          (*cntx)->SendBulkString(\"idle\");\n+          (*cntx)->SendLong(consumer_info.idle);\n+        }\n+        return;\n+      }\n+      if (result.status() == OpStatus::INVALID_VALUE) {\n+        return (*cntx)->SendError(NoGroupError(stream_name, group_name));\n+      }\n+      return (*cntx)->SendError(result.status());\n     }\n   }\n   return (*cntx)->SendError(UnknownSubCmd(sub_cmd, \"XINFO\"));\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 49ca58648936..1833a9da88e8 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -604,7 +604,6 @@ TEST_F(StreamFamilyTest, XTrimInvalidArgs) {\n   resp = Run({\"xtrim\", \"foo\", \"maxlen\", \"~\", \"2\", \"limit\", \"nan\"});\n   EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n }\n-\n TEST_F(StreamFamilyTest, XPending) {\n   Run({\"xadd\", \"foo\", \"1-0\", \"k1\", \"v1\"});\n   Run({\"xadd\", \"foo\", \"1-1\", \"k2\", \"v2\"});\n@@ -736,12 +735,210 @@ TEST_F(StreamFamilyTest, XAck) {\n   EXPECT_THAT(resp, ArrLen(0));\n }\n \n-TEST_F(StreamFamilyTest, XInfo) {\n-  Run({\"xgroup\", \"create\", \"foo\", \"cgroup\", \"0\", \"mkstream\"});\n-  auto resp = Run({\"xinfo\", \"groups\", \"foo\"});\n-  EXPECT_THAT(resp, RespArray(ElementsAre(\"name\", \"cgroup\", \"consumers\", IntArg(0), \"pending\",\n-                                          IntArg(0), \"last-delivered-id\", \"0-0\", \"entries-read\",\n-                                          ArgType(RespExpr::NIL), \"lag\", IntArg(0))));\n+TEST_F(StreamFamilyTest, XInfoGroups) {\n+  Run({\"del\", \"mystream\"});\n+  Run({\"xgroup\", \"create\", \"mystream\", \"mygroup\", \"$\", \"MKSTREAM\"});\n+\n+  // non-existent-stream\n+  auto resp = Run({\"xinfo\", \"groups\", \"non-existent-stream\"});\n+  EXPECT_THAT(resp, ErrArg(\"no such key\"));\n+\n+  // group with no consumers\n+  resp = Run({\"xinfo\", \"groups\", \"mystream\"});\n+  EXPECT_THAT(resp, ArrLen(12));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"name\", \"mygroup\", \"consumers\", IntArg(0), \"pending\",\n+                                         IntArg(0), \"last-delivered-id\", \"0-0\", \"entries-read\",\n+                                         ArgType(RespExpr::NIL), \"lag\", IntArg(0)));\n+\n+  // group with multiple consumers\n+  Run({\"xgroup\", \"createconsumer\", \"mystream\", \"mygroup\", \"consumer1\"});\n+  Run({\"xgroup\", \"createconsumer\", \"mystream\", \"mygroup\", \"consumer2\"});\n+  resp = Run({\"xinfo\", \"groups\", \"mystream\"});\n+  EXPECT_THAT(resp, ArrLen(12));\n+  EXPECT_THAT(resp.GetVec()[3], IntArg(2));\n+\n+  // group with lag\n+  Run({\"xadd\", \"mystream\", \"1-0\", \"test-field-1\", \"test-value-1\"});\n+  Run({\"xadd\", \"mystream\", \"2-0\", \"test-field-2\", \"test-value-2\"});\n+  resp = Run({\"xinfo\", \"groups\", \"mystream\"});\n+  EXPECT_THAT(resp.GetVec()[11], IntArg(2));\n+  EXPECT_THAT(resp.GetVec()[7], \"0-0\");\n+\n+  // group with no lag, before ack\n+  Run({\"xreadgroup\", \"group\", \"mygroup\", \"consumer1\", \"STREAMS\", \"mystream\", \">\"});\n+  resp = Run({\"xinfo\", \"groups\", \"mystream\"});\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"name\", \"mygroup\", \"consumers\", IntArg(2), \"pending\", IntArg(2),\n+                          \"last-delivered-id\", \"2-0\", \"entries-read\", IntArg(2), \"lag\", IntArg(0)));\n+\n+  // after ack\n+  Run({\"xack\", \"mystream\", \"mygroup\", \"1-0\"});\n+  Run({\"xack\", \"mystream\", \"mygroup\", \"2-0\"});\n+  resp = Run({\"xinfo\", \"groups\", \"mystream\"});\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"name\", \"mygroup\", \"consumers\", IntArg(2), \"pending\", IntArg(0),\n+                          \"last-delivered-id\", \"2-0\", \"entries-read\", IntArg(2), \"lag\", IntArg(0)));\n+}\n+\n+TEST_F(StreamFamilyTest, XInfoConsumers) {\n+  Run({\"del\", \"mystream\"});\n+  Run({\"xgroup\", \"create\", \"mystream\", \"mygroup\", \"$\", \"MKSTREAM\"});\n+\n+  // no consumer\n+  auto resp = Run({\"xinfo\", \"consumers\", \"mystream\", \"mygroup\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+\n+  // invalid key\n+  resp = Run({\"xinfo\", \"consumers\", \"non-existent-stream\", \"mygroup\"});\n+  EXPECT_THAT(resp, ErrArg(\"no such key\"));\n+\n+  // invalid group\n+  resp = Run({\"xinfo\", \"consumers\", \"mystream\", \"non-existent-group\"});\n+  EXPECT_THAT(resp, ErrArg(\"NOGROUP\"));\n+\n+  Run({\"xgroup\", \"createconsumer\", \"mystream\", \"mygroup\", \"first-consumer\"});\n+  Run({\"xgroup\", \"createconsumer\", \"mystream\", \"mygroup\", \"second-consumer\"});\n+  resp = Run({\"xinfo\", \"consumers\", \"mystream\", \"mygroup\"});\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec()[0], ArrLen(6));\n+  EXPECT_THAT(resp.GetVec()[1], ArrLen(6));\n+  EXPECT_THAT(resp.GetVec()[0].GetVec()[1], \"first-consumer\");\n+  EXPECT_THAT(resp.GetVec()[1].GetVec()[1], \"second-consumer\");\n+\n+  Run({\"xadd\", \"mystream\", \"1-0\", \"test-field-1\", \"test-value-1\"});\n+  Run({\"xreadgroup\", \"group\", \"mygroup\", \"consumer1\", \"STREAMS\", \"mystream\", \">\"});\n+  resp = Run({\"xinfo\", \"consumers\", \"mystream\", \"mygroup\"});\n+  // pending for first-consumer\n+  EXPECT_THAT(resp.GetVec()[0].GetVec()[3], IntArg(1));\n+  // pending for second-consumer\n+  EXPECT_THAT(resp.GetVec()[1].GetVec()[3], IntArg(0));\n }\n \n+TEST_F(StreamFamilyTest, XInfoStream) {\n+  Run({\"del\", \"mystream\"});\n+  Run({\"xgroup\", \"create\", \"mystream\", \"mygroup\", \"$\", \"MKSTREAM\"});\n+  Run({\"xgroup\", \"createconsumer\", \"mystream\", \"mygroup\", \"first-consumer\"});\n+\n+  // invalid key\n+  auto resp = Run({\"xinfo\", \"stream\", \"non-existent-stream\"});\n+  EXPECT_THAT(resp, ErrArg(\"no such key\"));\n+\n+  // invalid args\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"extra-arg\"});\n+  EXPECT_THAT(\n+      resp,\n+      ErrArg(\"unknown subcommand or wrong number of arguments for 'STREAM'. Try XINFO HELP.\"));\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\"});\n+  EXPECT_THAT(\n+      resp,\n+      ErrArg(\"unknown subcommand or wrong number of arguments for 'STREAM'. Try XINFO HELP.\"));\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // no message in stream\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\"});\n+  EXPECT_THAT(resp, ArrLen(20));\n+  EXPECT_THAT(\n+      resp.GetVec(),\n+      ElementsAre(\"length\", IntArg(0), \"radix-tree-keys\", IntArg(0), \"radix-tree-nodes\", IntArg(1),\n+                  \"last-generated-id\", \"0-0\", \"max-deleted-entry-id\", \"0-0\", \"entries-added\",\n+                  IntArg(0), \"recorded-first-entry-id\", \"0-0\", \"groups\", IntArg(1), \"first-entry\",\n+                  ArgType(RespExpr::NIL_ARRAY), \"last-entry\", ArgType(RespExpr::NIL_ARRAY)));\n+\n+  Run({\"xadd\", \"mystream\", \"1-1\", \"message\", \"one\"});\n+  Run({\"xadd\", \"mystream\", \"2-1\", \"message\", \"two\"});\n+  Run({\"xadd\", \"mystream\", \"3-1\", \"message\", \"three\"});\n+  Run({\"xadd\", \"mystream\", \"4-1\", \"message\", \"four\"});\n+  Run({\"xadd\", \"mystream\", \"5-1\", \"message\", \"five\"});\n+  Run({\"xadd\", \"mystream\", \"6-1\", \"message\", \"six\"});\n+  Run({\"xadd\", \"mystream\", \"7-1\", \"message\", \"seven\"});\n+  Run({\"xadd\", \"mystream\", \"8-1\", \"message\", \"eight\"});\n+  Run({\"xadd\", \"mystream\", \"9-1\", \"message\", \"nine\"});\n+  Run({\"xadd\", \"mystream\", \"10-1\", \"message\", \"ten\"});\n+  Run({\"xadd\", \"mystream\", \"11-1\", \"message\", \"eleven\"});\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\"});\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"length\", IntArg(11), \"radix-tree-keys\", IntArg(1), \"radix-tree-nodes\",\n+                          IntArg(2), \"last-generated-id\", \"11-1\", \"max-deleted-entry-id\", \"0-0\",\n+                          \"entries-added\", IntArg(11), \"recorded-first-entry-id\", \"1-1\", \"groups\",\n+                          IntArg(1), \"first-entry\", ArrLen(2), \"last-entry\", ArrLen(2)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0], \"1-1\");\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[1].GetVec(), ElementsAre(\"message\", \"one\"));\n+  EXPECT_THAT(resp.GetVec()[19].GetVec()[0], \"11-1\");\n+  EXPECT_THAT(resp.GetVec()[19].GetVec()[1].GetVec(), ElementsAre(\"message\", \"eleven\"));\n+\n+  // full - default\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\"});\n+  EXPECT_THAT(resp, ArrLen(18));\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(10));\n+  EXPECT_THAT(resp.GetVec()[17], ArrLen(1));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0], ArrLen(14));\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"length\", IntArg(11), \"radix-tree-keys\", IntArg(1), \"radix-tree-nodes\",\n+                          IntArg(2), \"last-generated-id\", \"11-1\", \"max-deleted-entry-id\", \"0-0\",\n+                          \"entries-added\", IntArg(11), \"recorded-first-entry-id\", \"1-1\", \"entries\",\n+                          ArrLen(10), \"groups\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec(),\n+              ElementsAre(\"name\", \"mygroup\", \"last-delivered-id\", \"0-0\", \"entries-read\",\n+                          ArgType(RespExpr::NIL), \"lag\", IntArg(11), \"pel-count\", IntArg(0),\n+                          \"pending\", ArrLen(0), \"consumers\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[13].GetVec()[0].GetVec(),\n+              ElementsAre(\"name\", \"first-consumer\", \"seen-time\", ArgType(RespExpr::INT64),\n+                          \"pel-count\", IntArg(0), \"pending\", ArrLen(0)));\n+\n+  // full with count less than number of messages in stream\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"5\"});\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(5));\n+\n+  // full with count exceeding number of messages in stream\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"12\"});\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(11));\n+\n+  // full - all messages\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(11));\n+\n+  // read message\n+  Run({\"xreadgroup\", \"group\", \"mygroup\", \"first-consumer\", \"STREAMS\", \"mystream\", \">\"});\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(11));\n+  // group\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[5], IntArg(11));   // entries-read\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[7], IntArg(0));    // lag\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[9], IntArg(11));   // pel-count\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[11], ArrLen(11));  // pending list\n+  // consumer\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[13].GetVec()[0].GetVec()[5],\n+              IntArg(11));  // pel-count\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[13].GetVec()[0].GetVec()[7],\n+              ArrLen(11));  // pending list\n+\n+  // delete message\n+  Run({\"xdel\", \"mystream\", \"1-1\"});\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\"});\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"length\", IntArg(10), \"radix-tree-keys\", IntArg(1), \"radix-tree-nodes\",\n+                          IntArg(2), \"last-generated-id\", \"11-1\", \"max-deleted-entry-id\", \"1-1\",\n+                          \"entries-added\", IntArg(11), \"recorded-first-entry-id\", \"2-1\", \"groups\",\n+                          IntArg(1), \"first-entry\", ArrLen(2), \"last-entry\", ArrLen(2)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0], \"2-1\");\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[1].GetVec(), ElementsAre(\"message\", \"two\"));\n+  EXPECT_THAT(resp.GetVec()[19].GetVec()[0], \"11-1\");\n+  EXPECT_THAT(resp.GetVec()[19].GetVec()[1].GetVec(), ElementsAre(\"message\", \"eleven\"));\n+\n+  resp = Run({\"xinfo\", \"stream\", \"mystream\", \"full\", \"count\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[15], ArrLen(10));\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"length\", IntArg(10), \"radix-tree-keys\", IntArg(1), \"radix-tree-nodes\",\n+                          IntArg(2), \"last-generated-id\", \"11-1\", \"max-deleted-entry-id\", \"1-1\",\n+                          \"entries-added\", IntArg(11), \"recorded-first-entry-id\", \"2-1\", \"entries\",\n+                          ArrLen(10), \"groups\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec(),\n+              ElementsAre(\"name\", \"mygroup\", \"last-delivered-id\", \"11-1\", \"entries-read\",\n+                          IntArg(11), \"lag\", IntArg(0), \"pel-count\", IntArg(11), \"pending\",\n+                          ArrLen(11), \"consumers\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[17].GetVec()[0].GetVec()[13].GetVec()[0].GetVec(),\n+              ElementsAre(\"name\", \"first-consumer\", \"seen-time\", ArgType(RespExpr::INT64),\n+                          \"pel-count\", IntArg(11), \"pending\", ArrLen(11)));\n+}\n }  // namespace dfly\n",
  "problem_statement": "Add support for XINFO STREAM stream_name\nhttps://redis.io/commands/xinfo-stream/ \n",
  "hints_text": "@kostasrim \r\nI would like to take this up. Can you assign this to me ?",
  "created_at": "2023-07-11T06:17:53Z",
  "modified_files": [
    "src/server/stream_family.cc"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}