{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5008,
  "instance_id": "dragonflydb__dragonfly-5008",
  "issue_numbers": [
    "5004"
  ],
  "base_commit": "d5c375235f2bc29ca8973fa4628a895b7efe390c",
  "patch": "diff --git a/src/server/hll_family.cc b/src/server/hll_family.cc\nindex d0c1f6d33c4f..a16afd43060a 100644\n--- a/src/server/hll_family.cc\n+++ b/src/server/hll_family.cc\n@@ -255,14 +255,14 @@ OpResult<int> PFMergeInternal(CmdArgList args, Transaction* tx, SinkReplyBuilder\n     if (result.ok()) {\n       hlls[sid] = std::move(result.value());\n     } else {\n-      success = false;\n+      success.store(false, memory_order_relaxed);\n     }\n-    return result.status();\n+    return OpStatus::OK;\n   };\n \n   tx->Execute(std::move(cb), false);\n \n-  if (!success) {\n+  if (!success.load(memory_order_relaxed)) {\n     tx->Conclude();\n     return OpStatus::INVALID_VALUE;\n   }\n",
  "test_patch": "diff --git a/src/server/hll_family_test.cc b/src/server/hll_family_test.cc\nindex 4b52924daa54..752c640ca4b5 100644\n--- a/src/server/hll_family_test.cc\n+++ b/src/server/hll_family_test.cc\n@@ -194,11 +194,12 @@ TEST_F(HllFamilyTest, MergeOverlapping) {\n }\n \n TEST_F(HllFamilyTest, MergeInvalid) {\n-  GTEST_SKIP() << \"TBD: MergeInvalid test fails with multi-shard runs, see #5004\";\n+  Run({\"exists\", \"key1\", \"key4\"});\n+  ASSERT_EQ(GetDebugInfo().shards_count, 2);  // ensure 2 shards\n \n   EXPECT_EQ(CheckedInt({\"pfadd\", \"key1\", \"1\", \"2\", \"3\"}), 1);\n-  EXPECT_EQ(Run({\"set\", \"key2\", \"...\"}), \"OK\");\n-  EXPECT_THAT(Run({\"pfmerge\", \"key1\", \"key2\"}), ErrArg(HllFamily::kInvalidHllErr));\n+  EXPECT_EQ(Run({\"set\", \"key4\", \"...\"}), \"OK\");\n+  EXPECT_THAT(Run({\"pfmerge\", \"key1\", \"key4\"}), ErrArg(HllFamily::kInvalidHllErr));\n   EXPECT_EQ(CheckedInt({\"pfcount\", \"key1\"}), 3);\n }\n \n",
  "problem_statement": "HllFamilyTest.MergeInvalid check fails with multiple shards\nThe reason for this is that the transaction callback in PFMergeInternal returns status via the transactional framework. This convenience interface is allowed only for single shard commands and does not work for multi-shard ones that may return inconsistent status from each shard thread. \n\nThe solution would be to always return Status::OK and pass the error code externally outside of the transaction framework like we do with other multi key operations.\n\n```\nF20250426 08:55:33.082108  9330 transaction.cc:686] Check failed: OpStatus::OK == result (0 vs. 5) \n*** Check failure stack trace: ***\n    @     0x5ba7a27634ed  google::LogMessage::Fail()\n    @     0x5ba7a2763433  google::LogMessage::SendToLog()\n    @     0x5ba7a2762be6  google::LogMessage::Flush()\n    @     0x5ba7a2766cde  google::LogMessageFatal::~LogMessageFatal()\n    @     0x5ba7a21f9b35  dfly::Transaction::RunCallback()\n    @     0x5ba7a21f8d4e  dfly::Transaction::RunInShard()\n```\n",
  "hints_text": "",
  "created_at": "2025-04-27T08:06:00Z",
  "modified_files": [
    "src/server/hll_family.cc"
  ],
  "modified_test_files": [
    "src/server/hll_family_test.cc"
  ]
}