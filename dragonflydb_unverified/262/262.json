{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 262,
  "instance_id": "dragonflydb__dragonfly-262",
  "issue_numbers": [
    "239"
  ],
  "base_commit": "b81634c25f4826b28c447d60d47ea4a5ed16616a",
  "patch": "diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md\nindex 4f2f1fe5d4e0..9a0b0fb5daac 100644\n--- a/CONTRIBUTORS.md\n+++ b/CONTRIBUTORS.md\n@@ -1,5 +1,6 @@\n # Contributors (alphabetical by surname)\n \n+* **[Amir Alperin](https://github.com/iko1)**\n * **[Philipp Born](https://github.com/tamcore)**\n   * Helm Chart\n * **[Braydn Moore](https://github.com/braydnm)**\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 28ac2d5615c0..a880bc33116c 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -11,7 +11,9 @@ extern \"C\" {\n #include <absl/strings/str_join.h>\n \n #include <jsoncons/json.hpp>\n+#include <jsoncons_ext/jsonpatch/jsonpatch.hpp>\n #include <jsoncons_ext/jsonpath/jsonpath.hpp>\n+#include <jsoncons_ext/jsonpointer/jsonpointer.hpp>\n \n #include \"base/logging.h\"\n #include \"server/command_registry.h\"\n@@ -58,6 +60,7 @@ inline void RecordJournal(const OpArgs& op_args, const PrimeKey& pkey, const Pri\n void SetString(const OpArgs& op_args, string_view key, const string& value) {\n   auto& db_slice = op_args.shard->db_slice();\n   auto [it_output, added] = db_slice.AddOrFind(op_args.db_ind, key);\n+  db_slice.PreUpdate(op_args.db_ind, it_output);\n   it_output->second.SetString(value);\n   db_slice.PostUpdate(op_args.db_ind, it_output, key);\n   RecordJournal(op_args, it_output->first, it_output->second);\n@@ -157,6 +160,119 @@ OpResult<json> GetJson(const OpArgs& op_args, string_view key) {\n   return decoder.get_result();\n }\n \n+// Returns the index of the next right bracket\n+optional<size_t> GetNextIndex(string_view str) {\n+  size_t current_idx = 0;\n+  while (current_idx + 1 < str.size()) {\n+    // ignore escaped character after the backslash (e.g. \\').\n+    if (str[current_idx] == '\\\\') {\n+      current_idx += 2;\n+    } else if (str[current_idx] == '\\'' && str[current_idx + 1] == ']') {\n+      return current_idx;\n+    } else {\n+      current_idx++;\n+    }\n+  }\n+\n+  return nullopt;\n+}\n+\n+// Encodes special characters when appending token to JSONPointer\n+struct JsonPointerFormatter {\n+  void operator()(std::string* out, string_view token) const {\n+    for (size_t i = 0; i < token.size(); i++) {\n+      char ch = token[i];\n+      if (ch == '~') {\n+        out->append(\"~0\");\n+      } else if (ch == '/') {\n+        out->append(\"~1\");\n+      } else if (ch == '\\\\') {\n+        // backslash for encoded another character should remove.\n+        if (i + 1 < token.size() && token[i + 1] == '\\\\') {\n+          out->append(1, '\\\\');\n+          i++;\n+        }\n+      } else {\n+        out->append(1, ch);\n+      }\n+    }\n+  }\n+};\n+\n+// Returns the JsonPointer of a JsonPath\n+// e.g. $[a][b][0] -> /a/b/0\n+string ConvertToJsonPointer(string_view json_path) {\n+  if (json_path.empty() || json_path[0] != '$') {\n+    LOG(FATAL) << \"Unexpected JSONPath syntax: \" << json_path;\n+  }\n+\n+  // remove prefix\n+  json_path.remove_prefix(1);\n+\n+  // except the supplied string is compatible with JSONPath syntax.\n+  // Each item in the string is a left bracket followed by\n+  // numeric or '<key>' and then a right bracket.\n+  vector<string_view> parts;\n+  bool invalid_syntax = false;\n+  while (json_path.size() > 0) {\n+    bool is_array = false;\n+    bool is_object = false;\n+\n+    // check string size is sufficient enough for at least one item.\n+    if (2 >= json_path.size()) {\n+      invalid_syntax = true;\n+      break;\n+    }\n+\n+    if (json_path[0] == '[') {\n+      if (json_path[1] == '\\'') {\n+        is_object = true;\n+        json_path.remove_prefix(2);\n+      } else if (isdigit(json_path[1])) {\n+        is_array = true;\n+        json_path.remove_prefix(1);\n+      } else {\n+        invalid_syntax = true;\n+        break;\n+      }\n+    } else {\n+      invalid_syntax = true;\n+      break;\n+    }\n+\n+    if (is_array) {\n+      size_t end_val_idx = json_path.find(']');\n+      if (end_val_idx == string::npos) {\n+        invalid_syntax = true;\n+        break;\n+      }\n+\n+      parts.emplace_back(json_path.substr(0, end_val_idx));\n+      json_path.remove_prefix(end_val_idx + 1);\n+    } else if (is_object) {\n+      optional<size_t> end_val_idx = GetNextIndex(json_path);\n+      if (!end_val_idx) {\n+        invalid_syntax = true;\n+        break;\n+      }\n+\n+      parts.emplace_back(json_path.substr(0, *end_val_idx));\n+      json_path.remove_prefix(*end_val_idx + 2);\n+    } else {\n+      invalid_syntax = true;\n+      break;\n+    }\n+  }\n+\n+  if (invalid_syntax) {\n+    LOG(FATAL) << \"Unexpected JSONPath syntax: \" << json_path;\n+  }\n+\n+  string result{\"/\"};  // initialize with a leading slash\n+  result += absl::StrJoin(parts, \"/\", JsonPointerFormatter());\n+  return result;\n+}\n+\n OpResult<string> OpGet(const OpArgs& op_args, string_view key,\n                        vector<pair<string_view, JsonExpression>> expressions) {\n   OpResult<json> result = GetJson(op_args, key);\n@@ -326,8 +442,71 @@ OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, stri\n   return output.as_string();\n }\n \n+OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path) {\n+  long total_deletions = 0;\n+  if (path.empty()) {\n+    auto& db_slice = op_args.shard->db_slice();\n+    auto [it, _] = db_slice.FindExt(op_args.db_ind, key);\n+    total_deletions += long(db_slice.Del(op_args.db_ind, it));\n+    return total_deletions;\n+  }\n+\n+  OpResult<json> result = GetJson(op_args, key);\n+  if (!result) {\n+    return total_deletions;\n+  }\n+\n+  vector<string> deletion_items;\n+  auto cb = [&](const string& path, json& val) { deletion_items.emplace_back(path); };\n+\n+  json j = result.value();\n+  error_code ec = JsonReplace(j, path, cb);\n+  if (ec) {\n+    VLOG(1) << \"Failed to evaulate expression on json with error: \" << ec.message();\n+    return total_deletions;\n+  }\n+\n+  if (deletion_items.empty()) {\n+    return total_deletions;\n+  }\n+\n+  json patch(json_array_arg, {});\n+  reverse(deletion_items.begin(), deletion_items.end());  // deletion should finish at root keys.\n+  for (const auto& item : deletion_items) {\n+    string pointer = ConvertToJsonPointer(item);\n+    total_deletions++;\n+    json patch_item(json_object_arg, {{\"op\", \"remove\"}, {\"path\", pointer}});\n+    patch.emplace_back(patch_item);\n+  }\n+\n+  jsonpatch::apply_patch(j, patch, ec);\n+  if (ec) {\n+    VLOG(1) << \"Failed to apply patch on json with error: \" << ec.message();\n+    return 0;\n+  }\n+\n+  SetString(op_args, key, j.as_string());\n+  return total_deletions;\n+}\n+\n }  // namespace\n \n+void JsonFamily::Del(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view path;\n+  if (args.size() > 2) {\n+    path = ArgS(args, 2);\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpDel(t->GetOpArgs(shard), key, path);\n+  };\n+\n+  Transaction* trans = cntx->transaction;\n+  OpResult<long> result = trans->ScheduleSingleHopT(move(cb));\n+  (*cntx)->SendLong(*result);\n+}\n+\n void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   string_view path = ArgS(args, 2);\n@@ -343,12 +522,10 @@ void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {\n     return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, plus<double>{});\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<string> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.NUMINCRBY \" << trans->DebugId() << \": \" << key;\n     (*cntx)->SendSimpleString(*result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -370,12 +547,10 @@ void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {\n     return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, multiplies<double>{});\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<string> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.NUMMULTBY \" << trans->DebugId() << \": \" << key;\n     (*cntx)->SendSimpleString(*result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -390,12 +565,10 @@ void JsonFamily::Toggle(CmdArgList args, ConnectionContext* cntx) {\n     return OpToggle(t->GetOpArgs(shard), key, path);\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<vector<OptBool>> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.TOGGLE \" << trans->DebugId() << \": \" << key;\n     PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -419,12 +592,10 @@ void JsonFamily::Type(CmdArgList args, ConnectionContext* cntx) {\n     return OpType(t->GetOpArgs(shard), key, move(expression));\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<vector<string>> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.TYPE \" << trans->DebugId() << \": \" << key;\n     if (result->empty()) {\n       // When vector is empty, the path doesn't exist in the corresponding json.\n       (*cntx)->SendNull();\n@@ -457,12 +628,10 @@ void JsonFamily::ArrLen(CmdArgList args, ConnectionContext* cntx) {\n     return OpArrLen(t->GetOpArgs(shard), key, move(expression));\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.ARRLEN \" << trans->DebugId() << \": \" << key;\n     PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -486,12 +655,10 @@ void JsonFamily::ObjLen(CmdArgList args, ConnectionContext* cntx) {\n     return OpObjLen(t->GetOpArgs(shard), key, move(expression));\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.OBJLEN \" << trans->DebugId() << \": \" << key;\n     PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -515,12 +682,10 @@ void JsonFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {\n     return OpStrLen(t->GetOpArgs(shard), key, move(expression));\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.STRLEN \" << trans->DebugId() << \": \" << key;\n     PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -551,12 +716,10 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n     return OpGet(t->GetOpArgs(shard), key, move(expressions));\n   };\n \n-  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n   Transaction* trans = cntx->transaction;\n   OpResult<string> result = trans->ScheduleSingleHopT(move(cb));\n \n   if (result) {\n-    DVLOG(1) << \"JSON.GET \" << trans->DebugId() << \": \" << key << \" \" << result.value();\n     (*cntx)->SendBulkString(*result);\n   } else {\n     (*cntx)->SendError(result.status());\n@@ -576,6 +739,7 @@ void JsonFamily::Register(CommandRegistry* registry) {\n       NumIncrBy);\n   *registry << CI{\"JSON.NUMMULTBY\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(\n       NumMultBy);\n+  *registry << CI{\"JSON.DEL\", CO::WRITE, -2, 1, 1, 1}.HFUNC(Del);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/json_family.h b/src/server/json_family.h\nindex adba4db76567..7d571dd789f3 100644\n--- a/src/server/json_family.h\n+++ b/src/server/json_family.h\n@@ -28,6 +28,7 @@ class JsonFamily {\n   static void Toggle(CmdArgList args, ConnectionContext* cntx);\n   static void NumIncrBy(CmdArgList args, ConnectionContext* cntx);\n   static void NumMultBy(CmdArgList args, ConnectionContext* cntx);\n+  static void Del(CmdArgList args, ConnectionContext* cntx);\n };\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 83eb278f7108..ce82acb2f68b 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -456,4 +456,62 @@ TEST_F(JsonFamilyTest, NumMultBy) {\n   EXPECT_EQ(resp, R\"([{\"a\":\"a\"},{\"a\":\"a\",\"b\":2},{\"a\":\"a\",\"b\":\"b\"},{\"a\":2,\"b\":\"b\",\"c\":6}])\");\n }\n \n+TEST_F(JsonFamilyTest, Del) {\n+  string json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}, \"e\": [1,2,3,4,5]}}\n+  )\";\n+\n+  auto resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$.d.*\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":1},\"c\":{\"a\":1,\"b\":2},\"d\":{},\"e\":[1,2,3,4,5]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$.e[*]\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":1},\"c\":{\"a\":1,\"b\":2},\"d\":{},\"e\":[]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$..*\"});\n+  EXPECT_THAT(resp, IntArg(8));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  json = R\"(\n+    {\"a\":[{\"b\": [1,2,3]}], \"b\": [{\"c\": 2}], \"c']\":[1,2,3]}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$.a[0].b[0]\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[{\"b\":[2,3]}],\"b\":[{\"c\":2}],\"c']\":[1,2,3]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$.b[0].c\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[{\"b\":[2,3]}],\"b\":[{}],\"c']\":[1,2,3]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"$.*\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "implement json.del command\nit's a tricky command to implement because jsoncons lib does not support it out of the box.\r\nSpec: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/json-del.html\r\n\n",
  "hints_text": "",
  "created_at": "2022-08-29T14:47:28Z",
  "modified_files": [
    "CONTRIBUTORS.md",
    "src/server/json_family.cc",
    "src/server/json_family.h"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}