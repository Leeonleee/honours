{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2639,
  "instance_id": "dragonflydb__dragonfly-2639",
  "issue_numbers": [
    "443"
  ],
  "base_commit": "91c299b33e1a9ca975cea0fa5bb2dbb25cb214ae",
  "patch": "diff --git a/src/core/dash.h b/src/core/dash.h\nindex bd3d4c3c6042..4328b5b4fd5b 100644\n--- a/src/core/dash.h\n+++ b/src/core/dash.h\n@@ -5,6 +5,7 @@\n \n #include <vector>\n \n+#include \"absl/random/random.h\"\n #include \"base/pmr/memory_resource.h\"\n #include \"core/dash_internal.h\"\n \n@@ -225,6 +226,10 @@ class DashTable : public detail::DashTableBase {\n     return double(size()) / (SegmentType::capacity() * unique_segments());\n   }\n \n+  // Gets a random cursor based on the available segments and buckets.\n+  // Returns: cursor with a random position\n+  Cursor GetRandomCursor(absl::BitGen* bitgen);\n+\n   // Traverses over a single bucket in table and calls cb(iterator) 0 or more\n   // times. if cursor=0 starts traversing from the beginning, otherwise continues from where it\n   // stopped. returns 0 if the supplied cursor reached end of traversal. Traverse iterates at bucket\n@@ -916,6 +921,14 @@ auto DashTable<_Key, _Value, Policy>::TraverseBySegmentOrder(Cursor curs, Cb&& c\n   return Cursor{global_depth_, sid, bid};\n }\n \n+template <typename _Key, typename _Value, typename Policy>\n+auto DashTable<_Key, _Value, Policy>::GetRandomCursor(absl::BitGen* bitgen) -> Cursor {\n+  uint32_t sid = absl::Uniform<uint32_t>(*bitgen, 0, segment_.size());\n+  uint8_t bid = absl::Uniform<uint8_t>(*bitgen, 0, kLogicalBucketNum);\n+\n+  return Cursor{global_depth_, sid, bid};\n+}\n+\n template <typename _Key, typename _Value, typename Policy>\n template <typename Cb>\n auto DashTable<_Key, _Value, Policy>::Traverse(Cursor curs, Cb&& cb) -> Cursor {\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 8303cf057131..8a7d45343374 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -4,6 +4,10 @@\n \n #include \"server/generic_family.h\"\n \n+#include <optional>\n+\n+#include \"facade/reply_builder.h\"\n+\n extern \"C\" {\n #include \"redis/crc64.h\"\n #include \"redis/util.h\"\n@@ -1509,6 +1513,54 @@ OpStatus GenericFamily::OpMove(const OpArgs& op_args, string_view key, DbIndex t\n   return OpStatus::OK;\n }\n \n+void GenericFamily::RandomKey(CmdArgList args, ConnectionContext* cntx) {\n+  const static size_t kMaxAttempts = 3;\n+\n+  absl::BitGen bitgen;\n+  atomic_size_t candidates_counter{0};\n+  DbContext db_cntx{.db_index = cntx->conn_state.db_index};\n+  ScanOpts scan_opts;\n+  scan_opts.limit = 3;  // number of entries per shard\n+  std::vector<StringVec> candidates_collection(shard_set->size());\n+\n+  shard_set->RunBriefInParallel(\n+      [&](EngineShard* shard) {\n+        auto [prime_table, expire_table] = shard->db_slice().GetTables(db_cntx.db_index);\n+        if (prime_table->size() == 0) {\n+          return;\n+        }\n+\n+        StringVec* candidates = &candidates_collection[shard->shard_id()];\n+\n+        for (size_t i = 0; i <= kMaxAttempts; ++i) {\n+          if (!candidates->empty()) {\n+            break;\n+          }\n+          uint64_t cursor = 0;  // scans from the start of the shard after reaching kMaxAttemps\n+          if (i < kMaxAttempts) {\n+            cursor = prime_table->GetRandomCursor(&bitgen).value();\n+          }\n+          OpScan({shard, 0u, db_cntx}, scan_opts, &cursor, candidates);\n+        }\n+\n+        candidates_counter.fetch_add(candidates->size(), memory_order_relaxed);\n+      },\n+      [&](ShardId) { return true; });\n+\n+  auto candidates_count = candidates_counter.load(memory_order_relaxed);\n+  std::optional<string> random_key = std::nullopt;\n+  auto random_idx = absl::Uniform<size_t>(bitgen, 0, candidates_count);\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  for (const auto& candidate : candidates_collection) {\n+    if (random_idx >= candidate.size()) {\n+      random_idx -= candidate.size();\n+    } else {\n+      return rb->SendBulkString(candidate[random_idx]);\n+    }\n+  }\n+  rb->SendNull();\n+}\n+\n using CI = CommandId;\n \n #define HFUNC(x) SetHandler(&GenericFamily::x)\n@@ -1580,7 +1632,8 @@ void GenericFamily::Register(CommandRegistry* registry) {\n       << CI{\"SORT\", CO::READONLY, -2, 1, 1, acl::kSort}.HFUNC(Sort)\n       << CI{\"MOVE\", CO::WRITE | CO::GLOBAL_TRANS | CO::NO_AUTOJOURNAL, 3, 1, 1, acl::kMove}.HFUNC(\n              Move)\n-      << CI{\"RESTORE\", CO::WRITE, -4, 1, 1, acl::kRestore}.HFUNC(Restore);\n+      << CI{\"RESTORE\", CO::WRITE, -4, 1, 1, acl::kRestore}.HFUNC(Restore)\n+      << CI{\"RANDOMKEY\", CO::READONLY, 1, 0, 0, 0}.HFUNC(RandomKey);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex e5581cebaebd..f7e888c6707b 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -68,6 +68,7 @@ class GenericFamily {\n   static void Type(CmdArgList args, ConnectionContext* cntx);\n   static void Dump(CmdArgList args, ConnectionContext* cntx);\n   static void Restore(CmdArgList args, ConnectionContext* cntx);\n+  static void RandomKey(CmdArgList args, ConnectionContext* cntx);\n   static void FieldTtl(CmdArgList args, ConnectionContext* cntx);\n \n   static OpResult<void> RenameGeneric(CmdArgList args, bool skip_exist_dest,\n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 966958015b1c..4eb323a1590b 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -734,4 +734,12 @@ TEST_F(GenericFamilyTest, FieldTtl) {\n   EXPECT_EQ(-3, CheckedInt({\"fieldttl\", \"k2\", \"f4\"}));\n }\n \n+TEST_F(GenericFamilyTest, RandomKey) {\n+  auto resp = Run({\"randomkey\"});\n+  EXPECT_EQ(resp.type, RespExpr::NIL);\n+\n+  resp = Run({\"set\", \"k1\", \"1\"});\n+  EXPECT_EQ(Run({\"randomkey\"}), \"k1\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Support RANDOMKEY command from redis API\nThis command is not supported currently, but i feel like it would be easy to add. This command is rly handy when it comes to debugging whats inside.\r\n\n",
  "hints_text": "`scan 0` is a good workaround, right?",
  "created_at": "2024-02-21T18:07:25Z",
  "modified_files": [
    "src/core/dash.h",
    "src/server/generic_family.cc",
    "src/server/generic_family.h"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc"
  ]
}