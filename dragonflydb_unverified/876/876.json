{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 876,
  "instance_id": "dragonflydb__dragonfly-876",
  "issue_numbers": [
    "849"
  ],
  "base_commit": "4a5d2f2a9accbcbd0a4f2d74da56ed62523b69a5",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 5f8bf0ec7be0..8e45fd447bee 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -884,33 +884,50 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key,\n }\n \n // Returns string vector that represents the query result of each supplied key.\n-OpResult<vector<OptString>> OpMGet(const OpArgs& op_args, const vector<string_view>& keys,\n-                                   JsonExpression expression) {\n-  vector<OptString> vec;\n-  for (auto& it : keys) {\n-    // OpResult<JsonType> result = GetJson(op_args, it);\n-    OpResult<JsonType*> result = GetJson(op_args, it);\n-    if (!result) {\n-      vec.emplace_back();\n+vector<OptString> OpMGet(JsonExpression expression, const Transaction* t, EngineShard* shard) {\n+  auto args = t->GetShardArgs(shard->shard_id());\n+  DCHECK(!args.empty());\n+  vector<OptString> response(args.size());\n+\n+  auto& db_slice = shard->db_slice();\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    OpResult<PrimeIterator> it_res = db_slice.Find(t->GetDbContext(), args[i], OBJ_JSON);\n+    if (!it_res.ok())\n       continue;\n-    }\n \n-    auto cb = [&vec](const string_view& path, const JsonType& val) {\n-      string str;\n-      error_code ec;\n-      val.dump(str, {}, ec);\n-      if (ec) {\n-        VLOG(1) << \"Failed to dump JSON to string with the error: \" << ec.message();\n-        return;\n-      }\n+    auto& dest = response[i].emplace();\n+    JsonType* json_val = it_res.value()->second.GetJson();\n+    DCHECK(json_val) << \"should have a valid JSON object for key \" << args[i];\n \n-      vec.push_back(move(str));\n+    vector<JsonType> query_result;\n+    auto cb = [&query_result](const string_view& path, const JsonType& val) {\n+      query_result.push_back(val);\n     };\n-    const JsonType& json_entry = *(result.value());\n+\n+    const JsonType& json_entry = *(json_val);\n     expression.evaluate(json_entry, cb);\n+\n+    if (query_result.empty()) {\n+      continue;\n+    }\n+\n+    JsonType arr(json_array_arg);\n+    arr.reserve(query_result.size());\n+    for (auto& s : query_result) {\n+      arr.push_back(s);\n+    }\n+\n+    string str;\n+    error_code ec;\n+    arr.dump(str, {}, ec);\n+    if (ec) {\n+      VLOG(1) << \"Failed to dump JSON array to string with the error: \" << ec.message();\n+    }\n+\n+    dest = move(str);\n   }\n \n-  return vec;\n+  return response;\n }\n \n // Returns numeric vector that represents the number of fields of JSON value at each path.\n@@ -1091,6 +1108,8 @@ void JsonFamily::Debug(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n+  DCHECK_GE(args.size(), 2U);\n+\n   error_code ec;\n   string_view path = ArgS(args, args.size() - 1);\n   JsonExpression expression = jsonpath::make_expression<JsonType>(path, ec);\n@@ -1101,29 +1120,46 @@ void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  vector<string_view> vec;\n-  for (auto i = 1U; i < args.size() - 1; i++) {\n-    vec.emplace_back(ArgS(args, i));\n-  }\n+  Transaction* transaction = cntx->transaction;\n+  unsigned shard_count = shard_set->size();\n+  std::vector<vector<OptString>> mget_resp(shard_count);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpMGet(t->GetOpArgs(shard), vec, move(expression));\n+    ShardId sid = shard->shard_id();\n+    mget_resp[sid] = OpMGet(jsonpath::make_expression<JsonType>(path, ec), t, shard);\n+    return OpStatus::OK;\n   };\n \n-  Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptString>> result = trans->ScheduleSingleHopT(move(cb));\n+  OpStatus result = transaction->ScheduleSingleHop(std::move(cb));\n+  CHECK_EQ(OpStatus::OK, result);\n \n-  if (result) {\n-    (*cntx)->StartArray(result->size());\n-    for (auto& it : *result) {\n-      if (!it) {\n-        (*cntx)->SendNull();\n-      } else {\n-        (*cntx)->SendSimpleString(*it);\n-      }\n+  std::vector<OptString> results(args.size() - 2);\n+  for (ShardId sid = 0; sid < shard_count; ++sid) {\n+    if (!transaction->IsActive(sid))\n+      continue;\n+\n+    vector<OptString>& res = mget_resp[sid];\n+    ArgSlice slice = transaction->GetShardArgs(sid);\n+\n+    DCHECK(!slice.empty());\n+    DCHECK_EQ(slice.size(), res.size());\n+\n+    for (size_t j = 0; j < slice.size(); ++j) {\n+      if (!res[j])\n+        continue;\n+\n+      uint32_t indx = transaction->ReverseArgIndex(sid, j);\n+      results[indx] = move(res[j]);\n+    }\n+  }\n+\n+  (*cntx)->StartArray(results.size());\n+  for (auto& it : results) {\n+    if (!it) {\n+      (*cntx)->SendNull();\n+    } else {\n+      (*cntx)->SendBulkString(*it);\n     }\n-  } else {\n-    (*cntx)->SendError(result.status());\n   }\n }\n \n@@ -1645,7 +1681,8 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n \n void JsonFamily::Register(CommandRegistry* registry) {\n   *registry << CI{\"JSON.GET\", CO::READONLY | CO::FAST, -2, 1, 1, 1}.HFUNC(Get);\n-  *registry << CI{\"JSON.MGET\", CO::READONLY | CO::FAST, -3, 1, 1, 1}.HFUNC(MGet);\n+  *registry << CI{\"JSON.MGET\", CO::READONLY | CO::FAST | CO::REVERSE_MAPPING, -3, 1, -2, 1}.HFUNC(\n+      MGet);\n   *registry << CI{\"JSON.TYPE\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(Type);\n   *registry << CI{\"JSON.STRLEN\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(StrLen);\n   *registry << CI{\"JSON.OBJLEN\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ObjLen);\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex cccf301966cc..8e851c70e999 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -864,6 +864,12 @@ TEST_F(JsonFamilyTest, MGet) {\n   )\",\n       R\"(\n     {\"address\":{\"street\":\"Oranienburger Str. 27\",\"city\":\"Berlin\",\"country\":\"Germany\",\"zipcode\":\"10117\"}}\n+  )\",\n+      R\"(\n+    {\"a\":1, \"b\": 2, \"nested\": {\"a\": 3}, \"c\": null}\n+  )\",\n+      R\"(\n+    {\"a\":4, \"b\": 5, \"nested\": {\"a\": 6}, \"c\": null}\n   )\"};\n \n   auto resp = Run({\"JSON.SET\", \"json1\", \".\", json[0]});\n@@ -874,7 +880,18 @@ TEST_F(JsonFamilyTest, MGet) {\n \n   resp = Run({\"JSON.MGET\", \"json1\", \"json2\", \"json3\", \"$.address.country\"});\n   ASSERT_EQ(RespExpr::ARRAY, resp.type);\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(R\"(\"Israel\")\", R\"(\"Germany\")\", ArgType(RespExpr::NIL)));\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(R\"([\"Israel\"])\", R\"([\"Germany\"])\", ArgType(RespExpr::NIL)));\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \".\", json[2]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json4\", \".\", json[3]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.MGET\", \"json3\", \"json4\", \"$..a\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(R\"([1,3])\", R\"([4,6])\"));\n }\n \n TEST_F(JsonFamilyTest, DebugFields) {\n",
  "problem_statement": "JSON.MGET not working as intended \n**Describe the bug**\r\nJSON.MGET not working as intended \r\n\r\n**To Reproduce**\r\ndragonfly> JSON.SET doc1 $ '{\"a\":1, \"b\": 2, \"nested\": {\"a\": 3}, \"c\": null}'\r\nOK\r\ndragonfly> JSON.SET doc2 $ '{\"a\":4, \"b\": 5, \"nested\": {\"a\": 6}, \"c\": null}'\r\nOK\r\n\r\ndragonfly> JSON.MGET doc1 doc2 $..a\r\nEXPECTED:\r\n1) \"[1,3]\"\r\n2) \"[4,6]\"\r\nGOT:\r\n1\r\n3\r\n\n",
  "hints_text": "",
  "created_at": "2023-02-25T16:25:43Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}