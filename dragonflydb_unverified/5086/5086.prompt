You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
add huffman encoding support for CompactObject
## Motivation

Analysis of workload key spaces reveals that they are often well compressible using Huffman encoding, achieving a 30-45% reduction in size. This is primarily because these keys are typically ASCII text with low entropy.

Instead of using generic compression libraries, which introduce significant metadata and apply run-length encoding (RLE), we should use a low-level Huffman coding solution. Given that most keys are short and require independent processing, a standard Huffman coding approach with a global table per shard (across all keys) is likely the most efficient. I've checked it with "DEBUG COMPRESSION" on several workloads.

## This task

1.  **Implement Huffman Encoding in `CompactObject`:**
    * Currently, `ASCII1_ENC_BIT` and `ASCII2_ENC_BIT` represent three states: not encoded, ASCII1, and ASCII2.
    * We can repurpose these bits as a 2-bit enum to include a fourth state: `huff_encoded`.
2.  **Maintain Transparent Decoding:**
    * Ensure decoding is transparent to callers by storing the Huffman table locally within the `TL` structure defined in `compact_object.cc`.
3.  **Utilize Existing Huffman Utilities:**
    * Leverage the Huffman utilities exposed via `huff/huf.h`, as demonstrated in `debugcmd.cc`.
4.  **Restrict Huffman Encoding to Keys:**
    * Limit this feature to keys by adding a `bool huffman_allowed` argument to `CompactObj::SetString`, prohibiting Huffman encoding for other string types.
5.  **Manage Huffman Data Structures within `TL`:**
    * Ensure Huffman data structures within `TL` are immutable.
    * The table should either exist with pre-calculated weights or not exist at all.
    * Prevent modifications to the table if string objects have already been encoded using it.
6. encoding stats should be tracked under TL (attempts, successes, raw size, compressed size)
7. Do not attempt encode short strings (inline). Do not attempt encode huge strings (above certain length).
    Note that some strings after encoding may become inline, so the decoding code GetSlice should be able to handle it.

## Encoded Format

Huffman encoding can result in bit sequences that do not align with byte boundaries, as it translates each byte into one or more bits.

To address the ambiguity of decoding an encoded string of size *k* into the original string:

* Use the first byte to indicate the length of the "unused" suffix (the number of unused bits in the last byte).
* Since we need at least one extra byte to store the suffix length, apply Huffman encoding only if it reduces the data size by at least two bytes.

This task does not introduce a new functionality for Dragonfly and should be contained within the `compact_object*` code.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
