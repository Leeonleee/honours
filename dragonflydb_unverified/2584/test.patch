diff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py
index 601e5b064cbd..33389e116f00 100755
--- a/tests/dragonfly/connection_test.py
+++ b/tests/dragonfly/connection_test.py
@@ -1,4 +1,5 @@
 import random
+import string
 import pytest
 import asyncio
 import time
@@ -737,3 +738,55 @@ async def do_write():
     await asyncio.sleep(0.0)
     assert p3.done()
     await p3
+
+
+@pytest.mark.asyncio
+async def test_blocking_command_client_pause(async_client: aioredis.Redis):
+    """
+    1. Check client pause success when blocking transaction is running
+    2. lpush is paused after running client puase
+    3. once puased is finished lpush will run and blpop will pop the pushed value
+    """
+
+    async def blocking_command():
+        res = await async_client.execute_command("blpop key 2")
+        assert res == ["key", "value"]
+
+    async def lpush_command():
+        await async_client.execute_command("lpush key value")
+
+    blocking = asyncio.create_task(blocking_command())
+    await asyncio.sleep(0.1)
+
+    res = await async_client.execute_command("client pause 1000")
+    assert res == "OK"
+
+    lpush = asyncio.create_task(lpush_command())
+    assert not lpush.done()
+
+    await lpush
+    await blocking
+
+
+@pytest.mark.asyncio
+async def test_multiple_blocking_commands_client_pause(async_client: aioredis.Redis):
+    """
+    Check running client pause command simultaneously with running multiple blocking command
+    from multiple connections
+    """
+
+    async def just_blpop():
+        key = "".join(random.choices(string.ascii_letters, k=3))
+        await async_client.execute_command(f"blpop {key} 2")
+
+    async def client_pause():
+        res = await async_client.execute_command("client pause 1000")
+        assert res == "OK"
+
+    tasks = [just_blpop() for _ in range(20)]
+    tasks.append(client_pause())
+
+    all = asyncio.gather(*tasks)
+
+    assert not all.done()
+    await all
