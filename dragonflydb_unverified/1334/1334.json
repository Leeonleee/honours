{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1334,
  "instance_id": "dragonflydb__dragonfly-1334",
  "issue_numbers": [
    "1319"
  ],
  "base_commit": "dcfd9262a729c88925c9631ba85b405a8afbe5d3",
  "patch": "diff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 018f70b66dec..9a96ca8a80ee 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -593,6 +593,11 @@ void Service::Shutdown() {\n \n bool Service::CheckKeysOwnership(const CommandId* cid, CmdArgList args,\n                                  ConnectionContext* dfly_cntx) {\n+  if (dfly_cntx->is_replicating) {\n+    // Always allow commands on the replication port, as it might be for future-owned keys.\n+    return true;\n+  }\n+\n   if (cid->first_key_pos() == 0) {\n     return true;  // No key command.\n   }\n",
  "test_patch": "diff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex c1c5136dae35..db2e23e975c0 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -1,8 +1,11 @@\n import pytest\n+import re\n import redis\n from redis import asyncio as aioredis\n import asyncio\n \n+from .utility import *\n+from .replication_test import check_all_replicas_finished\n from . import dfly_args\n \n BASE_PORT = 30001\n@@ -284,3 +287,112 @@ async def test_cluster_slot_ownership_changes(df_local_factory):\n     assert await c_nodes[0].execute_command(\"DBSIZE\") == 1\n     assert (await c_nodes[0].get(\"KEY0\")).decode() == \"value\"\n     assert await c_nodes[1].execute_command(\"DBSIZE\") == 0\n+\n+\n+# Tests that master commands to the replica are applied regardless of slot ownership\n+@dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n+async def test_cluster_replica_sets_non_owned_keys(df_local_factory):\n+    # Start and configure cluster with 1 master and 1 replica, both own all slots\n+    master = df_local_factory.create(port=BASE_PORT, admin_port=BASE_PORT+1000)\n+    replica = df_local_factory.create(port=BASE_PORT+1, admin_port=BASE_PORT+1001)\n+    df_local_factory.start_all([master, replica])\n+\n+    c_master = aioredis.Redis(port=master.port)\n+    c_master_admin = aioredis.Redis(port=master.admin_port)\n+    master_id = await get_node_id(c_master_admin)\n+\n+    c_replica = aioredis.Redis(port=replica.port)\n+    c_replica_admin = aioredis.Redis(port=replica.admin_port)\n+    replica_id = await get_node_id(c_replica_admin)\n+\n+    config = f\"\"\"\n+      [\n+        {{\n+          \"slot_ranges\": [\n+            {{\n+              \"start\": 0,\n+              \"end\": 16383\n+            }}\n+          ],\n+          \"master\": {{\n+            \"id\": \"{master_id}\",\n+            \"ip\": \"localhost\",\n+            \"port\": {master.port}\n+          }},\n+          \"replicas\": [\n+            {{\n+              \"id\": \"{replica_id}\",\n+              \"ip\": \"localhost\",\n+              \"port\": {replica.port}\n+            }}\n+          ]\n+        }}\n+      ]\n+    \"\"\"\n+    await push_config(config, [c_master_admin, c_replica_admin])\n+\n+    # Setup replication and make sure that it works properly.\n+    await c_master.set(\"key\", \"value\");\n+    await c_replica.execute_command(\"REPLICAOF\", \"localhost\", master.port)\n+    await check_all_replicas_finished([c_replica], c_master)\n+    assert (await c_replica.get(\"key\")).decode() == \"value\"\n+    assert await c_replica.execute_command(\"dbsize\") == 1\n+\n+    # Tell the replica that it and the master no longer own any data, but don't tell that to the\n+    # master. This will allow us to set keys on the master and make sure that they are set in the\n+    # replica.\n+\n+    replica_config = f\"\"\"\n+      [\n+        {{\n+          \"slot_ranges\": [],\n+          \"master\": {{\n+            \"id\": \"{master_id}\",\n+            \"ip\": \"localhost\",\n+            \"port\": {master.port}\n+          }},\n+          \"replicas\": [\n+            {{\n+              \"id\": \"{replica_id}\",\n+              \"ip\": \"localhost\",\n+              \"port\": {replica.port}\n+            }}\n+          ]\n+        }},\n+        {{\n+          \"slot_ranges\": [\n+            {{\n+              \"start\": 0,\n+              \"end\": 16383\n+            }}\n+          ],\n+          \"master\": {{\n+            \"id\": \"non-existing-master\",\n+            \"ip\": \"localhost\",\n+            \"port\": 1111\n+          }},\n+          \"replicas\": []\n+        }}\n+      ]\n+    \"\"\"\n+\n+    await push_config(replica_config, [c_replica_admin])\n+\n+    # The replica should have deleted the key.\n+    # Note: this is not the long-term intended behavior. It will change after we fix #1320.\n+    assert await c_replica.execute_command(\"dbsize\") == 0\n+\n+    # Set another key on the master, which it owns but the replica does not own.\n+    await c_master.set(\"key2\", \"value\");\n+    await check_all_replicas_finished([c_replica], c_master)\n+\n+    # See that the key exists in both replica and master\n+    assert await c_master.execute_command(\"dbsize\") == 2\n+    assert await c_replica.execute_command(\"dbsize\") == 1\n+\n+    # The replica should still reply with MOVED, despite having that key.\n+    try:\n+        await c_replica.get(\"key2\")\n+        assert False, \"Should not be able to get key on non-owner cluster node\"\n+    except redis.exceptions.ResponseError as e:\n+        assert re.match(r\"MOVED \\d+ localhost:1111\", e.args[0])\n",
  "problem_statement": "Replica should insert keys not in its ownership when received from master\n\n",
  "hints_text": "Here's a related question: do we really want replicas to delete keys upon `SetConfig()`?\r\nToday the replicas do that, and the masters do not send such deletions as replication commands. However, this is somewhat brittle.\nBrittleness example: the snapshot (to be deleted) may not be identical in the master and in the replica upon receiving the `DFLYCLUSTER CONFIG` command.\nErrr, please ignore, that's exactly https://github.com/dragonflydb/dragonfly/issues/1320",
  "created_at": "2023-06-01T12:02:37Z",
  "modified_files": [
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/cluster_test.py"
  ]
}