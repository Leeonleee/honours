{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2846,
  "instance_id": "dragonflydb__dragonfly-2846",
  "issue_numbers": [
    "1275"
  ],
  "base_commit": "b994f934d3311925d4dc48dcb87f5c560d478b27",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex abaff4a7d9f7..a907dac8f463 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -1051,7 +1051,7 @@ size_t CompactObj::MallocUsed() const {\n   }\n \n   if (taglen_ == SBF_TAG) {\n-    return 0;  // TODO: to track SBF memory utilization.\n+    return u_.sbf->MallocUsed();\n   }\n   LOG(DFATAL) << \"should not reach\";\n   return 0;\ndiff --git a/src/server/rdb_extensions.h b/src/server/rdb_extensions.h\nindex 50104eeb961a..e50d4a5e2a45 100644\n--- a/src/server/rdb_extensions.h\n+++ b/src/server/rdb_extensions.h\n@@ -13,10 +13,12 @@ constexpr uint8_t RDB_TYPE_JSON_OLD = 20;\n constexpr uint8_t RDB_TYPE_JSON = 30;\n constexpr uint8_t RDB_TYPE_HASH_WITH_EXPIRY = 31;\n constexpr uint8_t RDB_TYPE_SET_WITH_EXPIRY = 32;\n+constexpr uint8_t RDB_TYPE_SBF = 33;\n \n constexpr bool rdbIsObjectTypeDF(uint8_t type) {\n   return __rdbIsObjectType(type) || (type == RDB_TYPE_JSON) ||\n-         (type == RDB_TYPE_HASH_WITH_EXPIRY) || (type == RDB_TYPE_SET_WITH_EXPIRY);\n+         (type == RDB_TYPE_HASH_WITH_EXPIRY) || (type == RDB_TYPE_SET_WITH_EXPIRY) ||\n+         (type == RDB_TYPE_SBF);\n }\n \n //  Opcodes: Range 200-240 is used by DF extensions.\ndiff --git a/src/server/rdb_load.cc b/src/server/rdb_load.cc\nindex de2046b0cc9e..8f2277bb58c7 100644\n--- a/src/server/rdb_load.cc\n+++ b/src/server/rdb_load.cc\n@@ -29,6 +29,7 @@ extern \"C\" {\n #include \"base/endian.h\"\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n+#include \"core/bloom.h\"\n #include \"core/json/json_object.h\"\n #include \"core/sorted_map.h\"\n #include \"core/string_map.h\"\n@@ -382,6 +383,7 @@ class RdbLoaderBase::OpaqueObjLoader {\n   void operator()(const base::PODArray<char>& str);\n   void operator()(const LzfString& lzfstr);\n   void operator()(const unique_ptr<LoadTrace>& ptr);\n+  void operator()(const RdbSBF& src);\n \n   std::error_code ec() const {\n     return ec_;\n@@ -466,6 +468,16 @@ void RdbLoaderBase::OpaqueObjLoader::operator()(const unique_ptr<LoadTrace>& ptr\n   }\n }\n \n+void RdbLoaderBase::OpaqueObjLoader::operator()(const RdbSBF& src) {\n+  SBF* sbf =\n+      CompactObj::AllocateMR<SBF>(src.grow_factor, src.fp_prob, src.max_capacity, src.prev_size,\n+                                  src.current_size, CompactObj::memory_resource());\n+  for (unsigned i = 0; i < src.filters.size(); ++i) {\n+    sbf->AddFilter(src.filters[i].blob, src.filters[i].hash_cnt);\n+  }\n+  pv_->SetSBF(sbf);\n+}\n+\n void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {\n   size_t len = ltrace->blob_count();\n \n@@ -1367,6 +1379,9 @@ error_code RdbLoaderBase::ReadObj(int rdbtype, OpaqueObj* dest) {\n     case RDB_TYPE_MODULE_2:\n       iores = ReadRedisJson();\n       break;\n+    case RDB_TYPE_SBF:\n+      iores = ReadSBF();\n+      break;\n     default:\n       LOG(ERROR) << \"Unsupported rdb type \" << rdbtype;\n \n@@ -1827,6 +1842,39 @@ auto RdbLoaderBase::ReadJson() -> io::Result<OpaqueObj> {\n   return OpaqueObj{std::move(dest), RDB_TYPE_JSON};\n }\n \n+auto RdbLoaderBase::ReadSBF() -> io::Result<OpaqueObj> {\n+  RdbSBF res;\n+  uint64_t options;\n+  SET_OR_UNEXPECT(LoadLen(nullptr), options);\n+  if (options != 0)\n+    return Unexpected(errc::rdb_file_corrupted);\n+  SET_OR_UNEXPECT(FetchBinaryDouble(), res.grow_factor);\n+  SET_OR_UNEXPECT(FetchBinaryDouble(), res.fp_prob);\n+  if (res.fp_prob <= 0 || res.fp_prob > 0.5) {\n+    return Unexpected(errc::rdb_file_corrupted);\n+  }\n+  SET_OR_UNEXPECT(LoadLen(nullptr), res.prev_size);\n+  SET_OR_UNEXPECT(LoadLen(nullptr), res.current_size);\n+  SET_OR_UNEXPECT(LoadLen(nullptr), res.max_capacity);\n+\n+  unsigned num_filters = 0;\n+  SET_OR_UNEXPECT(LoadLen(nullptr), num_filters);\n+  auto is_power2 = [](size_t n) { return (n & (n - 1)) == 0; };\n+\n+  for (unsigned i = 0; i < num_filters; ++i) {\n+    unsigned hash_cnt;\n+    string filter_data;\n+    SET_OR_UNEXPECT(LoadLen(nullptr), hash_cnt);\n+    SET_OR_UNEXPECT(FetchGenericString(), filter_data);\n+    size_t bit_len = filter_data.size() * 8;\n+    if (!is_power2(bit_len)) {  // must be power of two\n+      return Unexpected(errc::rdb_file_corrupted);\n+    }\n+    res.filters.emplace_back(hash_cnt, std::move(filter_data));\n+  }\n+  return OpaqueObj{std::move(res), RDB_TYPE_SBF};\n+}\n+\n template <typename T> io::Result<T> RdbLoaderBase::FetchInt() {\n   auto ec = EnsureRead(sizeof(T));\n   if (ec)\ndiff --git a/src/server/rdb_load.h b/src/server/rdb_load.h\nindex 871c375335f9..c2e332279ebc 100644\n--- a/src/server/rdb_load.h\n+++ b/src/server/rdb_load.h\n@@ -38,8 +38,22 @@ class RdbLoaderBase {\n     uint64_t uncompressed_len;\n   };\n \n+  struct RdbSBF {\n+    double grow_factor, fp_prob;\n+    size_t prev_size, current_size;\n+    size_t max_capacity;\n+\n+    struct Filter {\n+      unsigned hash_cnt;\n+      std::string blob;\n+      Filter(unsigned h, std::string b) : hash_cnt(h), blob(std::move(b)) {\n+      }\n+    };\n+    std::vector<Filter> filters;\n+  };\n+\n   using RdbVariant =\n-      std::variant<long long, base::PODArray<char>, LzfString, std::unique_ptr<LoadTrace>>;\n+      std::variant<long long, base::PODArray<char>, LzfString, std::unique_ptr<LoadTrace>, RdbSBF>;\n \n   struct OpaqueObj {\n     RdbVariant obj;\n@@ -131,6 +145,7 @@ class RdbLoaderBase {\n   ::io::Result<OpaqueObj> ReadStreams();\n   ::io::Result<OpaqueObj> ReadRedisJson();\n   ::io::Result<OpaqueObj> ReadJson();\n+  ::io::Result<OpaqueObj> ReadSBF();\n \n   std::error_code SkipModuleData();\n   std::error_code HandleCompressedBlob(int op_type);\ndiff --git a/src/server/rdb_save.cc b/src/server/rdb_save.cc\nindex d1fd03c68179..a5ba2df2e6f0 100644\n--- a/src/server/rdb_save.cc\n+++ b/src/server/rdb_save.cc\n@@ -27,6 +27,7 @@ extern \"C\" {\n \n #include \"base/flags.h\"\n #include \"base/logging.h\"\n+#include \"core/bloom.h\"\n #include \"core/json/json_object.h\"\n #include \"core/sorted_map.h\"\n #include \"core/string_map.h\"\n@@ -194,6 +195,8 @@ uint8_t RdbObjectType(const PrimeValue& pv) {\n     case OBJ_JSON:\n       return RDB_TYPE_JSON;  // save with RDB_TYPE_JSON, deprecate RDB_TYPE_JSON_OLD after July\n                              // 2024.\n+    case OBJ_SBF:\n+      return RDB_TYPE_SBF;\n   }\n   LOG(FATAL) << \"Unknown encoding \" << compact_enc << \" for type \" << type;\n   return 0; /* avoid warning */\n@@ -395,6 +398,10 @@ error_code RdbSerializer::SaveObject(const PrimeValue& pv) {\n     return SaveJsonObject(pv);\n   }\n \n+  if (obj_type == OBJ_SBF) {\n+    return SaveSBFObject(pv);\n+  }\n+\n   LOG(ERROR) << \"Not implemented \" << obj_type;\n   return make_error_code(errc::function_not_supported);\n }\n@@ -620,6 +627,28 @@ error_code RdbSerializer::SaveJsonObject(const PrimeValue& pv) {\n   return SaveString(json_string);\n }\n \n+std::error_code RdbSerializer::SaveSBFObject(const PrimeValue& pv) {\n+  SBF* sbf = pv.GetSBF();\n+\n+  // options to allow format mutations in the future.\n+  RETURN_ON_ERR(SaveLen(0));  // options - reserved\n+  RETURN_ON_ERR(SaveBinaryDouble(sbf->grow_factor()));\n+  RETURN_ON_ERR(SaveBinaryDouble(sbf->fp_probability()));\n+  RETURN_ON_ERR(SaveLen(sbf->prev_size()));\n+  RETURN_ON_ERR(SaveLen(sbf->current_size()));\n+  RETURN_ON_ERR(SaveLen(sbf->max_capacity()));\n+  RETURN_ON_ERR(SaveLen(sbf->num_filters()));\n+\n+  for (unsigned i = 0; i < sbf->num_filters(); ++i) {\n+    RETURN_ON_ERR(SaveLen(sbf->hashfunc_cnt(i)));\n+\n+    string_view blob = sbf->data(i);\n+    RETURN_ON_ERR(SaveString(blob));\n+  }\n+\n+  return {};\n+}\n+\n /* Save a long long value as either an encoded string or a string. */\n error_code RdbSerializer::SaveLongLongAsString(int64_t value) {\n   uint8_t buf[32];\ndiff --git a/src/server/rdb_save.h b/src/server/rdb_save.h\nindex 8cb89e325646..d956b74e79e6 100644\n--- a/src/server/rdb_save.h\n+++ b/src/server/rdb_save.h\n@@ -230,6 +230,7 @@ class RdbSerializer : public SerializerBase {\n   std::error_code SaveZSetObject(const PrimeValue& pv);\n   std::error_code SaveStreamObject(const PrimeValue& obj);\n   std::error_code SaveJsonObject(const PrimeValue& pv);\n+  std::error_code SaveSBFObject(const PrimeValue& pv);\n \n   std::error_code SaveLongLongAsString(int64_t value);\n   std::error_code SaveBinaryDouble(double val);\n",
  "test_patch": "diff --git a/src/core/compact_object_test.cc b/src/core/compact_object_test.cc\nindex 18d94daf4d7b..fbe5be07b103 100644\n--- a/src/core/compact_object_test.cc\n+++ b/src/core/compact_object_test.cc\n@@ -369,7 +369,7 @@ TEST_F(CompactObjectTest, Hash) {\n TEST_F(CompactObjectTest, SBF) {\n   cobj_.SetSBF(1000, 0.001, 2);\n   EXPECT_EQ(cobj_.ObjType(), OBJ_SBF);\n-  EXPECT_EQ(0, cobj_.MallocUsed());\n+  EXPECT_GT(cobj_.MallocUsed(), 0);\n }\n \n TEST_F(CompactObjectTest, MimallocUnderutilzation) {\ndiff --git a/src/server/rdb_test.cc b/src/server/rdb_test.cc\nindex 0dbb75d7b1e3..8a828c96774f 100644\n--- a/src/server/rdb_test.cc\n+++ b/src/server/rdb_test.cc\n@@ -534,4 +534,12 @@ TEST_F(RdbTest, RedisJson) {\n             \"{\\\"company\\\":\\\"DragonflyDB\\\",\\\"product\\\":\\\"Dragonfly\\\",\\\"website\\\":\\\"https://\"\n             \"dragondlydb.io\\\",\\\"years-active\\\":[2021,2022,2023,2024,\\\"and more!\\\"]}\");\n }\n+\n+TEST_F(RdbTest, SBF) {\n+  EXPECT_THAT(Run({\"BF.ADD\", \"k\", \"1\"}), IntArg(1));\n+  Run({\"debug\", \"reload\"});\n+  EXPECT_EQ(Run({\"type\", \"k\"}), \"MBbloom--\");\n+  EXPECT_THAT(Run({\"BF.EXISTS\", \"k\", \"1\"}), IntArg(1));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Add bloom/cuckoo filter support\n**Is your feature request related to a problem? Please describe.**\r\nThe redis bloom module is very popular. Probabilistic data structures are required for many problems.\r\n\r\n**Describe the solution you'd like**\r\nBasic bloom / counting bloom support at minimum. Ideally full compatibility with redis bloom module.\r\n\r\n**Describe alternatives you've considered**\r\nCould do lua bitfields, but bitfield isn't supported either and would be slower.\r\n\n",
  "hints_text": "@romange any plans on this?\ncould you provide some context how you use this functionality and why you prefer using Dragonfly with this over Redis?\n> could you provide some context how you use this functionality and why you prefer using Dragonfly with this over Redis?\r\n\r\nBecause sharding redis is inefficient in scenarios where scale-up would suffice.\r\n\r\nIf you're trying to be compatible with Redis, you'll need to either support modules or build the most popular ones into core. Probabilistic data structures have thousands of applications.\nOur architecture is entirely different that of Redis, so we can not support Redis Modules.\r\nSupporting Redis Bloom filter is currently a low priority and not scheduled for 2023.\nOK, thanks for letting us know. Sounds like dragonfly is not going to be a great fit for many use cases this year.\nI would like to see bloom filter support in dragonflydb as well. Can we reopen this?\n@romange FYI.\nThe Bloom filter library is pretty big. Do you have specific APIs/commands in mind?\n> The Bloom filter library is pretty big. Do you have specific APIs/commands in mind?\r\n\r\n@romange  Supporting basic Bloom commands would be a good start:\r\n`BF.RESERVE, BF.ADD, BF.EXISTS, BF.MADD, BF.MEXISTS`\r\n\r\nI'd suggest adding a modern [counting cuckoo filter](https://arxiv.org/abs/2003.03801) as well:\r\n\r\n`CCF.RESERVE, CCF.ADD, CCF.DELETE, CCF.EXISTS, CCF.COUNT, CCF.MADD, CCF.MDELETE, CCF.MEXISTS, CCF.MCOUNT`\r\n\r\nThese two together would cover 99% of use cases.\r\n\r\nBloom conformity test:\r\n\r\n```\r\n> BF.RESERVE bikes:models 0.001 1000000\r\nOK\r\n> BF.ADD bikes:models \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> BF.EXISTS bikes:models \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> BF.MADD bikes:models \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\"\r\n1) (integer) 1\r\n2) (integer) 1\r\n3) (integer) 1\r\n> BF.MEXISTS bikes:models \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\"\r\n1) (integer) 1\r\n2) (integer) 1\r\n3) (integer) 1\r\n```\r\n\r\nCounting cuckoo conformity test:\r\n\r\n```\r\n> CCF.RESERVE bikes:inventory 1000000\r\nOK\r\n> CCF.ADD bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.EXISTS bikes:inventory \"Smoky Mountain Striker\" \r\n(integer) 1\r\n> CCF.COUNT bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.ADD bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.COUNT bikes:inventory \"Smoky Mountain Striker\" \r\n(integer) 2\r\n> CCF.DELETE bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.EXISTS bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.COUNT bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.DELETE bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 1\r\n> CCF.EXISTS bikes:inventory \"Smoky Mountain Striker\"\r\n(integer) 0\r\n> CCF.MADD bikes:inventory \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\"\r\n1) (integer) 1\r\n2) (integer) 1\r\n3) (integer) 1\r\n> CCF.MEXISTS bikes:inventory \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\"\r\n1) (integer) 1\r\n2) (integer) 1 \r\n3) (integer) 1\r\n> CCF.MCOUNT bikes:inventory \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\"\r\n1) (integer) 1\r\n2) (integer) 1\r\n3) (integer) 1\r\n> CCF.MDELETE bikes:inventory \"Rocky Mountain Racer\" \"Cloudy City Cruiser\"\r\n1) (integer) 1\r\n2) (integer) 1\r\n> CCF.MEXISTS bikes:inventory \"Rocky Mountain Racer\" \"Cloudy City Cruiser\" \"Windy City Wippet\" \r\n1) (integer) 0\r\n2) (integer) 0\r\n3) (integer) 1\r\n```\nbf.* are supported in v1.16.0. persistence support is coming for the next version",
  "created_at": "2024-04-05T08:40:40Z",
  "modified_files": [
    "src/core/compact_object.cc",
    "src/server/rdb_extensions.h",
    "src/server/rdb_load.cc",
    "src/server/rdb_load.h",
    "src/server/rdb_save.cc",
    "src/server/rdb_save.h"
  ],
  "modified_test_files": [
    "src/core/compact_object_test.cc",
    "src/server/rdb_test.cc"
  ]
}