{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4873,
  "instance_id": "dragonflydb__dragonfly-4873",
  "issue_numbers": [
    "4856"
  ],
  "base_commit": "ca0cdf8c40ff8780cfddfcfe3fd9d86a8fa71d3c",
  "patch": "diff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex 15993d084e3f..77871054dffa 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -166,7 +166,7 @@ OpStatus IncrementValue(optional<string_view> prev_val, IncrByParam* param) {\n   param->emplace<int64_t>(new_val);\n \n   return OpStatus::OK;\n-};\n+}\n \n OpStatus OpIncrBy(const OpArgs& op_args, string_view key, string_view field, IncrByParam* param) {\n   auto& db_slice = op_args.GetDbSlice();\n@@ -264,6 +264,62 @@ OpStatus OpIncrBy(const OpArgs& op_args, string_view key, string_view field, Inc\n   return OpStatus::OK;\n }\n \n+struct KeyCleanup {\n+  using CleanupFuncT = std::function<void(std::string_view)>;\n+  explicit KeyCleanup(CleanupFuncT func, const std::string_view key_view)\n+      : f{std::move(func)}, key{key_view} {\n+  }\n+  ~KeyCleanup() {\n+    if (armed) {\n+      f(key);\n+    }\n+  }\n+\n+  void arm() {\n+    armed = true;\n+  }\n+\n+  CleanupFuncT f;\n+  std::string key;\n+  bool armed{false};\n+};\n+\n+void DeleteKey(DbSlice& db_slice, const OpArgs& op_args, std::string_view key) {\n+  if (auto del_it = db_slice.FindMutable(op_args.db_cntx, key, OBJ_HASH); del_it) {\n+    del_it->post_updater.Run();\n+    db_slice.Del(op_args.db_cntx, del_it->it);\n+    if (op_args.shard->journal()) {\n+      RecordJournal(op_args, \"DEL\"sv, {key});\n+    }\n+  }\n+}\n+\n+std::pair<OpResult<DbSlice::ConstIterator>, KeyCleanup> FindReadOnly(DbSlice& db_slice,\n+                                                                     const OpArgs& op_args,\n+                                                                     std::string_view key) {\n+  return std::pair{db_slice.FindReadOnly(op_args.db_cntx, key, OBJ_HASH),\n+                   KeyCleanup{[&](const auto& k) { DeleteKey(db_slice, op_args, k); }, key}};\n+}\n+\n+// The find and contains functions perform the usual search on string maps, with the added argument\n+// KeyCleanup. This object is armed if the string map becomes empty during search due to keys being\n+// expired. An armed object on destruction removes the key which has just become empty.\n+StringMap::iterator Find(StringMap* sm, const std::string_view field, KeyCleanup& defer_cleanup) {\n+  auto it = sm->Find(field);\n+  if (sm->Empty()) {\n+    defer_cleanup.arm();\n+  }\n+  return it;\n+}\n+\n+bool Contains(StringMap* sm, const std::string_view field, KeyCleanup& defer_cleanup) {\n+  auto result = sm->Contains(field);\n+  if (sm->Empty()) {\n+    defer_cleanup.arm();\n+  }\n+  return result;\n+}\n+\n OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t* cursor,\n                            const ScanOpts& scan_op) {\n   constexpr size_t HASH_TABLE_ENTRIES_FACTOR = 2;  // return key/value\n@@ -274,7 +330,8 @@ OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t\n    * of returning no or very few elements. (taken from redis code at db.c line 904 */\n   constexpr size_t INTERATION_FACTOR = 10;\n \n-  auto find_res = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_HASH);\n+  DbSlice& db_slice = op_args.GetDbSlice();\n+  auto [find_res, defer_cleanup] = FindReadOnly(db_slice, op_args, key);\n \n   if (!find_res) {\n     DVLOG(1) << \"ScanOp: find failed: \" << find_res << \", baling out\";\n@@ -328,6 +385,10 @@ OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t\n     do {\n       *cursor = sm->Scan(*cursor, scanCb);\n     } while (*cursor && max_iterations-- && res.size() < count);\n+\n+    if (sm->Empty()) {\n+      defer_cleanup.arm();\n+    }\n   }\n \n   return res;\n@@ -368,13 +429,15 @@ OpResult<uint32_t> OpDel(const OpArgs& op_args, string_view key, CmdArgList valu\n     StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n \n     for (auto s : values) {\n-      bool res = sm->Erase(ToSV(s));\n-      if (res) {\n+      if (sm->Erase(ToSV(s))) {\n         ++deleted;\n-        if (sm->UpperBoundSize() == 0) {\n-          key_remove = true;\n-          break;\n-        }\n+      }\n+\n+      // Even if the previous Erase op did not erase anything, it can remove expired fields as a\n+      // side effect.\n+      if (sm->Empty()) {\n+        key_remove = true;\n+        break;\n       }\n     }\n   }\n@@ -395,7 +458,7 @@ OpResult<vector<OptStr>> OpHMGet(const OpArgs& op_args, std::string_view key, Cm\n   DCHECK(!fields.empty());\n \n   auto& db_slice = op_args.GetDbSlice();\n-  auto it_res = db_slice.FindReadOnly(op_args.db_cntx, key, OBJ_HASH);\n+  auto [it_res, defer_cleanup] = FindReadOnly(db_slice, op_args, key);\n \n   if (!it_res)\n     return it_res.status();\n@@ -443,8 +506,7 @@ OpResult<vector<OptStr>> OpHMGet(const OpArgs& op_args, std::string_view key, Cm\n     StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n \n     for (size_t i = 0; i < fields.size(); ++i) {\n-      auto it = sm->Find(ToSV(fields[i]));\n-      if (it != sm->end()) {\n+      if (auto it = Find(sm, ToSV(fields[i]), defer_cleanup); it != sm->end()) {\n         result[i].emplace(it->second, sdslen(it->second));\n       }\n     }\n@@ -468,7 +530,7 @@ OpResult<uint32_t> OpLen(const OpArgs& op_args, string_view key) {\n \n OpResult<int> OpExist(const OpArgs& op_args, string_view key, string_view field) {\n   auto& db_slice = op_args.GetDbSlice();\n-  auto it_res = db_slice.FindReadOnly(op_args.db_cntx, key, OBJ_HASH);\n+  auto [it_res, defer_cleanup] = FindReadOnly(db_slice, op_args, key);\n \n   if (!it_res) {\n     if (it_res.status() == OpStatus::KEY_NOTFOUND)\n@@ -486,13 +548,13 @@ OpResult<int> OpExist(const OpArgs& op_args, string_view key, string_view field)\n \n   DCHECK_EQ(kEncodingStrMap2, pv.Encoding());\n   StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n-\n-  return sm->Contains(field) ? 1 : 0;\n+  return Contains(sm, field, defer_cleanup) ? 1 : 0;\n };\n \n OpResult<string> OpGet(const OpArgs& op_args, string_view key, string_view field) {\n   auto& db_slice = op_args.GetDbSlice();\n-  auto it_res = db_slice.FindReadOnly(op_args.db_cntx, key, OBJ_HASH);\n+  auto [it_res, defer_cleanup] = FindReadOnly(db_slice, op_args, key);\n+\n   if (!it_res)\n     return it_res.status();\n \n@@ -510,12 +572,11 @@ OpResult<string> OpGet(const OpArgs& op_args, string_view key, string_view field\n \n   DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n   StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n-  auto it = sm->Find(field);\n-\n-  if (it == sm->end())\n-    return OpStatus::KEY_NOTFOUND;\n+  if (const auto it = Find(sm, field, defer_cleanup); it != sm->end()) {\n+    return string(it->second, sdslen(it->second));\n+  }\n \n-  return string(it->second, sdslen(it->second));\n+  return OpStatus::KEY_NOTFOUND;\n }\n \n OpResult<vector<string>> OpGetAll(const OpArgs& op_args, string_view key, uint8_t mask) {\n@@ -570,10 +631,7 @@ OpResult<vector<string>> OpGetAll(const OpArgs& op_args, string_view key, uint8_\n   // and the enconding is guaranteed to be a DenseSet since we only support expiring\n   // value with that enconding.\n   if (res.empty()) {\n-    // post_updater will run immediately\n-    auto it = db_slice.FindMutable(op_args.db_cntx, key).it;\n-\n-    db_slice.Del(op_args.db_cntx, it);\n+    DeleteKey(db_slice, op_args, key);\n   }\n \n   return res;\n@@ -581,7 +639,7 @@ OpResult<vector<string>> OpGetAll(const OpArgs& op_args, string_view key, uint8_\n \n OpResult<size_t> OpStrLen(const OpArgs& op_args, string_view key, string_view field) {\n   auto& db_slice = op_args.GetDbSlice();\n-  auto it_res = db_slice.FindReadOnly(op_args.db_cntx, key, OBJ_HASH);\n+  auto [it_res, defer_cleanup] = FindReadOnly(db_slice, op_args, key);\n \n   if (!it_res) {\n     if (it_res.status() == OpStatus::KEY_NOTFOUND)\n@@ -601,7 +659,7 @@ OpResult<size_t> OpStrLen(const OpArgs& op_args, string_view key, string_view fi\n   DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n   StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n \n-  auto it = sm->Find(field);\n+  auto it = Find(sm, field, defer_cleanup);\n   return it != sm->end() ? sdslen(it->second) : 0;\n }\n \n",
  "test_patch": "diff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc\nindex bd21fa7a9baa..12497dba2a63 100644\n--- a/src/server/hset_family_test.cc\n+++ b/src/server/hset_family_test.cc\n@@ -521,4 +521,24 @@ TEST_F(HSetFamilyTest, ScanAfterExpireSet) {\n   EXPECT_THAT(vec, Contains(\"avalue\").Times(1));\n }\n \n+TEST_F(HSetFamilyTest, KeyRemovedWhenEmpty) {\n+  auto test_cmd = [&](const std::function<void()>& f, const std::string_view tag) {\n+    EXPECT_THAT(Run({\"HSET\", \"a\", \"afield\", \"avalue\"}), IntArg(1));\n+    EXPECT_THAT(Run({\"HEXPIRE\", \"a\", \"1\", \"FIELDS\", \"1\", \"afield\"}), IntArg(1));\n+    AdvanceTime(1000);\n+\n+    EXPECT_THAT(Run({\"EXISTS\", \"a\"}), IntArg(1));\n+    f();\n+    EXPECT_THAT(Run({\"EXISTS\", \"a\"}), IntArg(0)) << \"failed when testing \" << tag;\n+  };\n+\n+  test_cmd([&] { EXPECT_THAT(Run({\"HGET\", \"a\", \"afield\"}), ArgType(RespExpr::NIL)); }, \"HGET\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HGETALL\", \"a\"}), RespArray(ElementsAre())); }, \"HGETALL\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HDEL\", \"a\", \"afield\"}), IntArg(0)); }, \"HDEL\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HSCAN\", \"a\", \"0\"}).GetVec()[0], \"0\"); }, \"HSCAN\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HMGET\", \"a\", \"afield\"}), ArgType(RespExpr::NIL)); }, \"HMGET\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HEXISTS\", \"a\", \"afield\"}), IntArg(0)); }, \"HEXISTS\");\n+  test_cmd([&] { EXPECT_THAT(Run({\"HSTRLEN\", \"a\", \"afield\"}), IntArg(0)); }, \"HSTRLEN\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Save empty key fatal error on empty hash\n**Describe the bug**\nWhen we delete expired fields from hashset from the flow of `hexists key filed` the hashset may become empty.\nWhen snapshotting if we see empty key from type hashset we print dfatal\nSaveEntry skipped empty PrimeValue with key: <key> with tag\n\n**To Reproduce**\nSteps to reproduce the behavior:\n1. Insert records using `hsetex key 1 f v`\n2. Query records using `hexists key f`\n3. Start save using `save df`\n4. See error\n\n\n-  We should delete the key if invoking hexists makes the hset empty (as we do in hget)\n- Find if we have other command flows that expire hashset and make sure we delete the keys in this flows as well\n- Fix the error print of \"SaveEntry skipped empty PrimeValue with key: <key> with tag\" , the type is not actually printed to log\n\n",
  "hints_text": "From some testing it looks like this behavior of removing empty keys lazily does not happen for `HGET` but it does happen for `HGETALL` and `HDEL`. Below is current behavior\n\n```\nTEST_F(HSetFamilyTest, KeyRemovedWhenEmpty) {\n  EXPECT_THAT(Run({\"HSET\", \"aset\", \"afield\", \"avalue\"}), IntArg(1));\n  EXPECT_THAT(Run({\"HEXPIRE\", \"aset\", \"1\", \"FIELDS\", \"1\", \"afield\"}), IntArg(1));\n  AdvanceTime(1000);\n\n  EXPECT_THAT(Run({\"HGET\", \"aset\", \"afield\"}), ArgType(RespExpr::NIL));\n  // still exists\n  EXPECT_THAT(Run({\"EXISTS\", \"aset\"}), IntArg(1));\n\n  EXPECT_THAT(Run({\"HGETALL\", \"aset\"}), RespArray(ElementsAre()));\n  // removed\n  EXPECT_THAT(Run({\"EXISTS\", \"aset\"}), IntArg(0));\n\n  EXPECT_THAT(Run({\"HSET\", \"aset\", \"field2\", \"avalue\"}), IntArg(1));\n  EXPECT_THAT(Run({\"HDEL\", \"aset\", \"field2\"}), IntArg(1));\n  // removed\n  EXPECT_THAT(Run({\"EXISTS\", \"aset\"}), IntArg(0));\n}\n```\n\nSo we should implement removal for `HGET` and `HEXISTS`. \n\nFor `HDEL` we only remove the key if the deletion succeeded for a field and all fields were removed. Should we also remove the key if the field was not found in the key, but the key is empty? eg\n\n```\nHSET k v 1\n... expire v ...\nHDEL k some-non-existent\n```\n\nShould `k` be removed as a side effect of `HDEL` in the above sequence, given that it is now empty, although the deletion of `some-non-existent` failed?\nwe dont have background process to expire fields in hash. We expire when we access the item.\nDo we delete v filed in the flow of `HDEL k some-non-existent` in your example? If the answer is yes than we should delete the key\n\n> Do we delete v filed in the flow of `HDEL k some-non-existent` in your example?\n\nYes, since delete goes through the same `DenseSet::Find2` code path as other hset commands, it ends up deleting `v` even though `HDEL` did not have `v` as argument. This was confirmed with a test.\n\nSo to sum up, we should always delete the key if it is empty at the end of all `hset` operations, is that correct?\nyes\n> Yes, since delete goes through the same `DenseSet::Find2` code path as other hset commands, it ends up deleting `v` even though `HDEL` did not have `v` as argument. This was confirmed with a test.\n> \n\nAfter some more testing and going through the code, it looks like it is not guaranteed that expired entries will be removed during `HDEL`. Those are only removed if their bucket ends up being examined by `DenseSet::Find2` and `ExpireIfNeeded` is called on it. \nyes, we preserve `O(1)` complexity and we do not guarantee full expiry. That's ok",
  "created_at": "2025-04-01T09:13:14Z",
  "modified_files": [
    "src/server/hset_family.cc"
  ],
  "modified_test_files": [
    "src/server/hset_family_test.cc"
  ]
}