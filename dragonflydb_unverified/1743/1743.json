{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1743,
  "instance_id": "dragonflydb__dragonfly-1743",
  "issue_numbers": [
    "1680",
    "1700"
  ],
  "base_commit": "b9a8dabb5063fee79a47a6c8ce9b551759b11836",
  "patch": "diff --git a/src/core/overloaded.h b/src/core/overloaded.h\nindex 9db0c50a2ae1..0a1ccc572dd9 100644\n--- a/src/core/overloaded.h\n+++ b/src/core/overloaded.h\n@@ -3,6 +3,8 @@\n //\n //\n \n+#pragma once\n+\n template <class... Ts> struct Overloaded : Ts... { using Ts::operator()...; };\n \n template <class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;\ndiff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 89452b486ca8..5ad14245b8bb 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -25,7 +25,8 @@ add_library(dragonfly_lib channel_store.cc command_registry.cc\n             zset_family.cc version.cc bitops_family.cc container_utils.cc io_utils.cc\n             serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc\n             top_keys.cc multi_command_squasher.cc hll_family.cc cluster/cluster_config.cc\n-            cluster/cluster_family.cc acl/user.cc acl/user_registry.cc acl/acl_family.cc)\n+            cluster/cluster_family.cc acl/user.cc acl/user_registry.cc acl/acl_family.cc\n+            acl/validator.cc)\n \n \n cxx_link(dragonfly_lib dfly_transaction dfly_facade redis_lib aws_lib strings_lib html_lib\ndiff --git a/src/server/acl/user.h b/src/server/acl/user.h\nindex e40ee04e7b6f..4f09950d2bc7 100644\n--- a/src/server/acl/user.h\n+++ b/src/server/acl/user.h\n@@ -16,10 +16,6 @@\n \n namespace dfly::acl {\n \n-// TODO implement these\n-//#bool CheckIfCommandAllowed(uint64_t command_id, const CommandId& command);\n-//#bool CheckIfAclCategoryAllowed(uint64_t command_id, const CommandId& command);\n-\n class User final {\n  public:\n   struct UpdateRequest {\ndiff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc\nnew file mode 100644\nindex 000000000000..bcc7edba99c0\n--- /dev/null\n+++ b/src/server/acl/validator.cc\n@@ -0,0 +1,19 @@\n+// Copyright 2023, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/acl/validator.h\"\n+\n+#include \"server/server_state.h\"\n+\n+namespace dfly::acl {\n+\n+[[nodiscard]] bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx,\n+                                                const facade::CommandId& id) {\n+  auto& registry = *ServerState::tlocal()->user_registry;\n+  auto credentials = registry.GetCredentials(cntx.authed_username);\n+  auto command_credentials = id.acl_categories();\n+  return (credentials.acl_categories & command_credentials) != 0;\n+}\n+\n+}  // namespace dfly::acl\ndiff --git a/src/server/acl/validator.h b/src/server/acl/validator.h\nnew file mode 100644\nindex 000000000000..67a78b6e953e\n--- /dev/null\n+++ b/src/server/acl/validator.h\n@@ -0,0 +1,16 @@\n+// Copyright 2023, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#pragma once\n+\n+#include <string_view>\n+\n+#include \"facade/command_id.h\"\n+#include \"server/conn_context.h\"\n+\n+namespace dfly::acl {\n+\n+bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx, const facade::CommandId& id);\n+\n+}\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex 319228f815cd..d377c84d0f3c 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -196,7 +196,7 @@ class ConnectionContext : public facade::ConnectionContext {\n   // Reference to a FlowInfo for this connection if from a master to a replica.\n   FlowInfo* replication_flow;\n \n-  std::optional<std::string> authed_username;\n+  std::string authed_username{\"default\"};\n \n  private:\n   void EnableMonitoring(bool enable) {\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex bfd61e0126d5..cdee899a9461 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -27,6 +27,7 @@ extern \"C\" {\n #include \"facade/reply_capture.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/acl/acl_family.h\"\n+#include \"server/acl/validator.h\"\n #include \"server/bitops_family.h\"\n #include \"server/cluster/cluster_family.h\"\n #include \"server/conn_context.h\"\n@@ -784,11 +785,27 @@ OpStatus CheckKeysDeclared(const ConnectionState::ScriptInfo& eval_info, const C\n   return OpStatus::OK;\n }\n \n-optional<ErrorReply> Service::VerifyCommandExecution(const CommandId* cid) {\n-  // TODO: Move OOM check here\n+static optional<ErrorReply> VerifyConnectionAclStatus(const CommandId* cid,\n+                                                      const ConnectionContext* cntx,\n+                                                      string_view error_msg) {\n+  // If we are on a squashed context we need to use the owner, because the\n+  // context we are operating on is a stub and the acl username is not copied\n+  // See: MultiCommandSquasher::SquashedHopCb\n+  if (cntx->conn_state.squashing_info)\n+    cntx = cntx->conn_state.squashing_info->owner;\n+\n+  if (!acl::IsUserAllowedToInvokeCommand(*cntx, *cid)) {\n+    return ErrorReply(absl::StrCat(\"NOPERM: \", cntx->authed_username, \" \", error_msg));\n+  }\n   return nullopt;\n }\n \n+optional<ErrorReply> Service::VerifyCommandExecution(const CommandId* cid,\n+                                                     const ConnectionContext* cntx) {\n+  // TODO: Move OOM check here\n+  return VerifyConnectionAclStatus(cid, cntx, \"ACL rules changed between the MULTI and EXEC\");\n+}\n+\n std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdArgList tail_args,\n                                                       const ConnectionContext& dfly_cntx) {\n   DCHECK(cid);\n@@ -866,7 +883,7 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n       return ErrorReply{status};\n   }\n \n-  return nullopt;\n+  return VerifyConnectionAclStatus(cid, &dfly_cntx, \"has no ACL permissions\");\n }\n \n void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx) {\n@@ -980,7 +997,7 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionCo\n   DCHECK(cid);\n   DCHECK(!cid->Validate(tail_args));\n \n-  if (auto err = VerifyCommandExecution(cid); err) {\n+  if (auto err = VerifyCommandExecution(cid, cntx); err) {\n     (*cntx)->SendError(std::move(*err));\n     return true;  // return false only for internal error aborts\n   }\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex 11b8deeabf83..1854a81b105a 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -55,7 +55,8 @@ class Service : public facade::ServiceInterface {\n \n   // Verify command can be executed now (check out of memory), always called immediately before\n   // execution\n-  std::optional<facade::ErrorReply> VerifyCommandExecution(const CommandId* cid);\n+  std::optional<facade::ErrorReply> VerifyCommandExecution(const CommandId* cid,\n+                                                           const ConnectionContext* cntx);\n \n   // Verify command prepares excution in correct state.\n   // It's usually called before command execution. Only for multi/exec transactions it's checked\n",
  "test_patch": "diff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex ec8333af60e8..9e52a3388eee 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -59,21 +59,133 @@ async def test_acl_setuser(async_client):\n \n @pytest.mark.asyncio\n async def test_acl_auth(async_client):\n-    await async_client.execute_command(\"ACL SETUSER kostas >mypass\")\n+    await async_client.execute_command(\"ACL SETUSER shahar >mypass\")\n \n     with pytest.raises(redis.exceptions.ResponseError):\n-        await async_client.execute_command(\"AUTH kostas wrong_pass\")\n+        await async_client.execute_command(\"AUTH shahar wrong_pass\")\n \n     # This should fail because user is inactive\n     with pytest.raises(redis.exceptions.ResponseError):\n-        await async_client.execute_command(\"AUTH kostas mypass\")\n+        await async_client.execute_command(\"AUTH shahar mypass\")\n \n     # Activate user\n-    await async_client.execute_command(\"ACL SETUSER kostas ON\")\n+    await async_client.execute_command(\"ACL SETUSER shahar ON +@fast\")\n \n-    result = await async_client.execute_command(\"AUTH kostas mypass\")\n-    result == \"ok\"\n+    result = await async_client.execute_command(\"AUTH shahar mypass\")\n+    assert result == \"OK\"\n \n     # Let's also try default\n     result = await async_client.execute_command(\"AUTH default nopass\")\n-    result == \"ok\"\n+    assert result == \"OK\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_categories(async_client):\n+    await async_client.execute_command(\"ACL SETUSER vlad ON >mypass +@string +@list +@connection\")\n+\n+    result = await async_client.execute_command(\"AUTH vlad mypass\")\n+    assert result == \"OK\"\n+\n+    result = await async_client.execute_command(\"SET foo bar\")\n+    assert result == \"OK\"\n+\n+    result = await async_client.execute_command(\"LPUSH mykey space_monkey\")\n+    assert result == 1\n+\n+    # This should fail, vlad does not have @admin\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"ACL SETUSER vlad ON >mypass\")\n+\n+    # This should fail, vlad does not have @sortedset\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"ZADD myset 1 two\")\n+\n+    result = await async_client.execute_command(\"AUTH default nopass\")\n+    assert result == \"OK\"\n+\n+    # Make vlad an admin\n+    await async_client.execute_command(\"ACL SETUSER vlad -@string\")\n+    assert result == \"OK\"\n+\n+    result = await async_client.execute_command(\"AUTH vlad mypass\")\n+    assert result == \"OK\"\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"GET foo\")\n+\n+    result = await async_client.execute_command(\"AUTH default nopass\")\n+    assert result == \"OK\"\n+\n+    # Vlad goes rogue starts giving admin stats to random users\n+    await async_client.execute_command(\"ACL SETUSER adi >adi +@admin\")\n+    assert result == \"OK\"\n+\n+    # Vlad can now execute everything\n+    await async_client.execute_command(\"ACL SETUSER vlad +@all\")\n+    assert result == \"OK\"\n+\n+    await async_client.execute_command(\"ZADD myset 1 two\")\n+    assert result == \"OK\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_categories_multi_exec_squash(df_local_factory):\n+    df = df_local_factory.create(multi_exec_squash=True, port=1111)\n+\n+    df.start()\n+\n+    client = aioredis.Redis(port=df.port)\n+    res = await client.execute_command(\"ACL SETUSER kk ON >kk +@transaction +@string\")\n+    assert res == b\"OK\"\n+\n+    res = await client.execute_command(\"AUTH kk kk\")\n+    assert res == b\"OK\"\n+\n+    await client.execute_command(\"MULTI\")\n+    assert res == b\"OK\"\n+    for x in range(33):\n+        await client.execute_command(f\"SET x{x} {x}\")\n+    await client.execute_command(\"EXEC\")\n+\n+    client = aioredis.Redis(port=df.port)\n+    await client.close()\n+\n+    # NOPERM while executing multi\n+    await client.execute_command(\"ACL SETUSER kk -@string\")\n+    assert res == b\"OK\"\n+    await client.execute_command(\"AUTH kk kk\")\n+    assert res == b\"OK\"\n+    await client.execute_command(\"MULTI\")\n+    assert res == b\"OK\"\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await client.execute_command(f\"SET x{x} {x}\")\n+    await client.close()\n+\n+    # NOPERM between multi and exec\n+    admin_client = aioredis.Redis(port=df.port)\n+    res = await client.execute_command(\"ACL SETUSER kk +@string\")\n+    assert res == b\"OK\"\n+\n+    client = aioredis.Redis(port=df.port)\n+    res = await client.execute_command(\"AUTH kk kk\")\n+    assert res == b\"OK\"\n+    # CLIENT has permissions, starts MULTI and issues a bunch of SET commands\n+    await client.execute_command(\"MULTI\")\n+    assert res == b\"OK\"\n+    for x in range(33):\n+        await client.execute_command(f\"SET x{x} {x}\")\n+\n+    # ADMIN revokes permissions\n+    res = await admin_client.execute_command(\"ACL SETUSER kk -@string\")\n+    assert res == b\"OK\"\n+\n+    res = await client.execute_command(\"EXEC\")\n+    # TODO(we need to fix this, basiscally SQUASHED/MULTI transaction commands\n+    # return multiple errors for each command failed. Since the nature of the error\n+    # is the same, that a rule has changed we should squash those error messages into\n+    # one.\n+    assert res[0].args[0] == \"NOPERM: kk ACL rules changed between the MULTI and EXEC\"\n+\n+    await admin_client.close()\n+    await client.close()\n",
  "problem_statement": "replicating redis 7.0.2 cause a sync loop\n**Describe the bug**\r\nSetting dragonfly as a replicaof a redis 7.0.2 instance cause a sync loop\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Start redis 7.0.2 server\r\n2. Start dragonfly v1.8.0\r\n3. running on dragonfly command `replicaof host port` (redis address)\r\n\r\n**Expected behavior**\r\nFull sync with redis db\r\n\r\n**Environment (please complete the following information):**\r\n - Dragonfly container: docker.dragonflydb.io/dragonflydb/dragonfly:v1.8.0\r\n - Containerized?: Kubernetes\r\n - Dragonfly Version: 1.8.0\r\n - Redis Docker image: redis:7-alpine\r\n\r\n**Additional context**\r\nDragonfly logs:\r\n```\r\nserver_family.cc:2008] Replicating 10.42.6.106:6379\r\nI20230809 14:14:36.637770 10 protocol_client.cc:219] Resetting endpoint! 10.42.6.106, 6379\r\nI20230809 14:14:36.754384 10 replica.cc:331] Starting full sync\r\nW20230809 14:15:42.008188 10 rdb_load.cc:2226] Unrecognized RDB AUX field: 'aof-base'\r\nI20230809 14:21:38.797895 10 replica.cc:511] Transitioned into stable sync\r\nE20230809 14:21:38.798534 10 protocol_client.cc:291] Could not shutdown socket system:107\r\nE20230809 14:21:38.976694 10 protocol_client.cc:321] Socket error system:103\r\nW20230809 14:21:38.976796 10 replica.cc:220] Error stable sync with 10.42.6.106:6379 system:103 Software caused connection abort\r\nI20230809 14:21:39.476967 10 protocol_client.cc:219] Resetting endpoint! 10.42.6.106, 6379\r\nI20230809 14:21:41.242125 10 replica.cc:331] Starting full sync\r\nW20230809 14:22:55.181116 10 rdb_load.cc:2226] Unrecognized RDB AUX field: 'aof-base'\r\nI20230809 14:27:31.509820 10 replica.cc:511] Transitioned into stable sync\r\nE20230809 14:27:31.510350 10 protocol_client.cc:291] Could not shutdown socket system:107\r\nE20230809 14:27:32.164361 10 protocol_client.cc:321] Socket error system:103\r\nW20230809 14:27:32.164419 10 replica.cc:220] Error stable sync with 10.42.6.106:6379 system:103 Software caused connection abort\r\nI20230809 14:27:32.664480 10 protocol_client.cc:219] Resetting endpoint! 10.42.6.106, 6379\r\nI20230809 14:27:32.759276 10 replica.cc:331] Starting full sync\r\nW20230809 14:28:44.290982 10 rdb_load.cc:2226] Unrecognized RDB AUX field: 'aof-base'\r\nI20230809 14:33:20.009881 10 replica.cc:511] Transitioned into stable sync\r\nE20230809 14:33:20.010550 10 protocol_client.cc:291] Could not shutdown socket system:107\r\nE20230809 14:33:20.337633 10 protocol_client.cc:321] Socket error system:103\r\nW20230809 14:33:20.337699 10 replica.cc:220] Error stable sync with 10.42.6.106:6379 system:103 Software caused connection abort\r\nI20230809 14:33:20.839649 10 protocol_client.cc:219] Resetting endpoint! 10.42.6.106, 6379\r\nI20230809 14:33:26.584765 10 replica.cc:331] Starting full sync\r\n```\r\n\nconfig get command support\nDue to the difference from the underlying architecture of redis, some previous config commands may not be fully supported, but can you have a complete display of the configurable items of dragonfly, similar to the function of `config get *`. From the user's point of view, I just don't know which configs can be configured and which ones can't. After all, I have transitioned from redis before, and some usage habits need to be adapted. \r\n\r\nI hope there will be a clear display of our configurable config items.\r\n<img width=\"530\" alt=\"image\" src=\"https://github.com/dragonflydb/dragonfly/assets/8543659/69a69fc8-518c-4e5a-9bae-949c8e1d6ff2\">\n",
  "hints_text": "looks like that this field is set by redis to \"0\" for a regular (non aof) case: https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/src/rdb.c#L3156 \r\n\n```\r\n            /* AUX: generic string-string fields. Use to add state to RDB\r\n             * which is backward compatible. Implementations of RDB loading\r\n             * are required to skip AUX fields they don't understand.\r\n```\r\nSo it appears we aren't doing that :) Do you think we should?\nseems like we should :)\nOops, we ARE correctly ignoring this field. When running locally I get the same messages:\r\n\r\n```\r\nI20230814 13:46:53.659343  5182 server_family.cc:2027] Replicating localhost:6379\r\nI20230814 13:46:53.697757  5182 protocol_client.cc:219] Resetting endpoint! 127.0.0.1, 6379\r\nI20230814 13:46:53.699290  5182 replica.cc:331] Starting full sync\r\nW20230814 13:46:58.237557  5182 rdb_load.cc:2226] Unrecognized RDB AUX field: 'aof-base'\r\nI20230814 13:46:58.288884  5182 replica.cc:511] Transitioned into stable sync\r\n```\r\n\r\nBut no reconnection loop. @cecchigl, would you mind posting your redis configuration check the redis server's logs? To me it looks like the connection might have been closed from redis' side for some reason.\n",
  "created_at": "2023-08-25T17:00:08Z",
  "modified_files": [
    "src/core/overloaded.h",
    "src/server/CMakeLists.txt",
    "src/server/acl/user.h",
    "b/src/server/acl/validator.cc",
    "b/src/server/acl/validator.h",
    "src/server/conn_context.h",
    "src/server/main_service.cc",
    "src/server/main_service.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/acl_family_test.py"
  ]
}