diff --git a/helio b/helio
index fd878df26816..875cedd2a0cd 160000
--- a/helio
+++ b/helio
@@ -1,1 +1,1 @@
-Subproject commit fd878df26816efc6ead76105b2f2d51e9a828b60
+Subproject commit 875cedd2a0cd084fd15a3d5dbfe20150e19ffcef
diff --git a/src/core/compact_object.h b/src/core/compact_object.h
index 1d9187a0799f..fe1a3b336e09 100644
--- a/src/core/compact_object.h
+++ b/src/core/compact_object.h
@@ -355,12 +355,16 @@ class CompactObj {
     return taglen_ == EXTERNAL_TAG;
   }
 
+  // returns true if the value is stored in the cooling storage. Cooling storage has an item both
+  // on disk and in memory.
   bool IsCool() const {
     assert(IsExternal());
     return u_.ext_ptr.is_cool;
   }
 
   void SetExternal(size_t offset, uint32_t sz);
+
+  // Assigns a cooling record to the object together with its external slice.
   void SetCool(size_t offset, uint32_t serialized_size, detail::TieredColdRecord* record);
 
   struct CoolItem {
@@ -368,6 +372,9 @@ class CompactObj {
     size_t serialized_size;
     detail::TieredColdRecord* record;
   };
+
+  // Prerequisite: IsCool() is true.
+  // Returns the external data of the object incuding its ColdRecord.
   CoolItem GetCool() const;
 
   void ImportExternal(const CompactObj& src);
diff --git a/src/server/tiered_storage.cc b/src/server/tiered_storage.cc
index 181320825057..2ecbc586f2d9 100644
--- a/src/server/tiered_storage.cc
+++ b/src/server/tiered_storage.cc
@@ -407,10 +407,10 @@ bool TieredStorage::TryStash(DbIndex dbid, string_view key, PrimeValue* value) {
   error_code ec;
   if (OccupiesWholePages(value->Size())) {  // large enough for own page
     id = KeyRef(dbid, key);
-    ec = op_manager_->Stash(id, raw_string.view(), {});
-  } else if (auto bin = bins_->Stash(dbid, key, raw_string.view(), {}); bin) {
+    ec = op_manager_->Stash(id, raw_string.view());
+  } else if (auto bin = bins_->Stash(dbid, key, raw_string.view()); bin) {
     id = bin->first;
-    ec = op_manager_->Stash(id, bin->second, {});
+    ec = op_manager_->Stash(id, bin->second);
   }
 
   if (ec) {
diff --git a/src/server/tiering/disk_storage.cc b/src/server/tiering/disk_storage.cc
index 265050e2fc95..51f0336e9460 100644
--- a/src/server/tiering/disk_storage.cc
+++ b/src/server/tiering/disk_storage.cc
@@ -136,10 +136,10 @@ void DiskStorage::MarkAsFree(DiskSegment segment) {
   alloc_.Free(segment.offset, segment.length);
 }
 
-std::error_code DiskStorage::Stash(io::Bytes bytes, io::Bytes footer, StashCb cb) {
+std::error_code DiskStorage::Stash(io::Bytes bytes, StashCb cb) {
   DCHECK_GT(bytes.length(), 0u);
 
-  size_t len = bytes.size() + footer.size();
+  size_t len = bytes.size();
   int64_t offset = alloc_.Malloc(len);
 
   // If we've run out of space, block and grow as much as needed
@@ -158,8 +158,6 @@ std::error_code DiskStorage::Stash(io::Bytes bytes, io::Bytes footer, StashCb cb
 
   UringBuf buf = PrepareBuf(len);
   memcpy(buf.bytes.data(), bytes.data(), bytes.length());
-  if (!footer.empty())
-    memcpy(buf.bytes.data() + bytes.length(), footer.data(), footer.length());
 
   auto io_cb = [this, cb, offset, buf, len](int io_res) {
     if (io_res < 0) {
diff --git a/src/server/tiering/disk_storage.h b/src/server/tiering/disk_storage.h
index 8d47e37e0a05..768b708d676f 100644
--- a/src/server/tiering/disk_storage.h
+++ b/src/server/tiering/disk_storage.h
@@ -15,6 +15,8 @@
 namespace dfly::tiering {
 
 // Disk storage controlled by asynchronous operations.
+// Provides Random Access Read/Stash asynchronous interface around low level linux file.
+// Handles ranges management and file growth via underlying ExternalAllocator.
 class DiskStorage {
  public:
   struct Stats {
@@ -44,7 +46,7 @@ class DiskStorage {
   // grow backing file. Returns error code if operation failed  immediately (most likely it failed
   // to grow the backing file) or passes an empty segment if the final write operation failed.
   // Bytes are copied and can be dropped before cb is resolved
-  std::error_code Stash(io::Bytes bytes, io::Bytes footer, StashCb cb);
+  std::error_code Stash(io::Bytes bytes, StashCb cb);
 
   Stats GetStats() const;
 
diff --git a/src/server/tiering/op_manager.cc b/src/server/tiering/op_manager.cc
index 5e727d67cf0b..ee3f740746b1 100644
--- a/src/server/tiering/op_manager.cc
+++ b/src/server/tiering/op_manager.cc
@@ -86,7 +86,7 @@ void OpManager::DeleteOffloaded(DiskSegment segment) {
   }
 }
 
-std::error_code OpManager::Stash(EntryId id_ref, std::string_view value, io::Bytes footer) {
+std::error_code OpManager::Stash(EntryId id_ref, std::string_view value) {
   auto id = ToOwned(id_ref);
   unsigned version = pending_stash_ver_[id] = ++pending_stash_counter_;
 
@@ -96,7 +96,7 @@ std::error_code OpManager::Stash(EntryId id_ref, std::string_view value, io::Byt
   };
 
   // May block due to blocking call to Grow.
-  auto ec = storage_.Stash(buf_view, footer, std::move(io_cb));
+  auto ec = storage_.Stash(buf_view, std::move(io_cb));
   if (ec)
     pending_stash_ver_.erase(ToOwned(id_ref));
   return ec;
diff --git a/src/server/tiering/op_manager.h b/src/server/tiering/op_manager.h
index f78f14b898ec..9b43fc3f13a3 100644
--- a/src/server/tiering/op_manager.h
+++ b/src/server/tiering/op_manager.h
@@ -66,8 +66,8 @@ class OpManager {
   // Delete offloaded entry located at the segment.
   void DeleteOffloaded(DiskSegment segment);
 
-  // Stash (value, footer) to be offloaded. Both arguments are opaque to OpManager.
-  std::error_code Stash(EntryId id, std::string_view value, io::Bytes footer);
+  // Stash value to be offloaded. It is opaque to OpManager.
+  std::error_code Stash(EntryId id, std::string_view value);
 
   Stats GetStats() const;
 
diff --git a/src/server/tiering/small_bins.cc b/src/server/tiering/small_bins.cc
index 18009cbf1544..50a800186985 100644
--- a/src/server/tiering/small_bins.cc
+++ b/src/server/tiering/small_bins.cc
@@ -13,7 +13,6 @@
 #include "core/compact_object.h"
 #include "server/tiering/common.h"
 #include "server/tiering/disk_storage.h"
-#include "server/tx_base.h"
 
 namespace dfly::tiering {
 using namespace std;
@@ -28,10 +27,10 @@ size_t StashedValueSize(string_view value) {
 }  // namespace
 
 std::optional<SmallBins::FilledBin> SmallBins::Stash(DbIndex dbid, std::string_view key,
-                                                     std::string_view value, io::Bytes footer) {
+                                                     std::string_view value) {
   DCHECK_LT(value.size(), 2_KB);
 
-  size_t value_bytes = StashedValueSize(value) + footer.size();
+  size_t value_bytes = StashedValueSize(value);
 
   std::optional<FilledBin> filled_bin;
   if (2 /* num entries */ + current_bin_bytes_ + value_bytes >= kPageSize) {
@@ -39,11 +38,7 @@ std::optional<SmallBins::FilledBin> SmallBins::Stash(DbIndex dbid, std::string_v
   }
 
   current_bin_bytes_ += value_bytes;
-  string blob;
-  blob.reserve(value.size() + footer.size());
-  blob.append(value);
-  blob.append(io::View(footer));
-  auto [it, inserted] = current_bin_.emplace(std::make_pair(dbid, key), std::move(blob));
+  auto [it, inserted] = current_bin_.emplace(std::make_pair(dbid, key), string(value));
   CHECK(inserted);
 
   DVLOG(2) << "current_bin_bytes: " << current_bin_bytes_
diff --git a/src/server/tiering/small_bins.h b/src/server/tiering/small_bins.h
index 1cdfb84b8471..d2f198f6e491 100644
--- a/src/server/tiering/small_bins.h
+++ b/src/server/tiering/small_bins.h
@@ -8,14 +8,14 @@
 
 #include <optional>
 #include <string>
-#include <unordered_map>
 #include <vector>
 
 #include "server/tiering/disk_storage.h"
-#include "server/tx_base.h"
 
 namespace dfly::tiering {
 
+using DbIndex = uint16_t;
+
 // Small bins accumulate small values into larger bins that fill up 4kb pages.
 // SIMPLEST VERSION for now.
 class SmallBins {
@@ -49,8 +49,7 @@ class SmallBins {
   }
 
   // Enqueue key/value pair for stash. Returns page to be stashed if it filled up.
-  std::optional<FilledBin> Stash(DbIndex dbid, std::string_view key, std::string_view value,
-                                 io::Bytes footer);
+  std::optional<FilledBin> Stash(DbIndex dbid, std::string_view key, std::string_view value);
 
   // Report that a stash succeeeded. Returns list of stored keys with calculated value locations.
   KeySegmentList ReportStashed(BinId id, DiskSegment segment);
