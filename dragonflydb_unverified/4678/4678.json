{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4678,
  "instance_id": "dragonflydb__dragonfly-4678",
  "issue_numbers": [
    "4204",
    "4677"
  ],
  "base_commit": "680e1e26c3e8dc47c141574dcd847368c8a23b7f",
  "patch": "diff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 247c52e0499a..08c5e5484cab 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -192,6 +192,10 @@ ParseResult<bool> ParseStopwords(CmdArgParser* parser, DocIndex* index) {\n ParseResult<bool> ParseSchema(CmdArgParser* parser, DocIndex* index) {\n   auto& schema = index->schema;\n \n+  if (!parser->HasNext()) {\n+    return CreateSyntaxError(\"Fields arguments are missing\"sv);\n+  }\n+\n   while (parser->HasNext()) {\n     string_view field = parser->Next();\n     string_view field_alias = field;\n@@ -204,10 +208,20 @@ ParseResult<bool> ParseSchema(CmdArgParser* parser, DocIndex* index) {\n     // AS [alias]\n     parser->Check(\"AS\", &field_alias);\n \n+    if (schema.field_names.contains(field_alias)) {\n+      return CreateSyntaxError(absl::StrCat(\"Duplicate field in schema - \"sv, field_alias));\n+    }\n+\n     // Determine type\n     using search::SchemaField;\n-    auto parsed_params = parser->MapNext(\"TAG\"sv, &ParseTag, \"TEXT\"sv, &ParseText, \"NUMERIC\"sv,\n-                                         &ParseNumeric, \"VECTOR\"sv, &ParseVector)(parser);\n+    auto params_parser = parser->TryMapNext(\"TAG\"sv, &ParseTag, \"TEXT\"sv, &ParseText, \"NUMERIC\"sv,\n+                                            &ParseNumeric, \"VECTOR\"sv, &ParseVector);\n+    if (!params_parser) {\n+      return CreateSyntaxError(\n+          absl::StrCat(\"Field type \"sv, parser->Next(), \" is not supported\"sv));\n+    }\n+\n+    auto parsed_params = params_parser.value()(parser);\n     if (!parsed_params) {\n       return make_unexpected(parsed_params.error());\n     }\n@@ -231,12 +245,9 @@ ParseResult<bool> ParseSchema(CmdArgParser* parser, DocIndex* index) {\n       parser->Skip(2);\n \n     schema.fields[field] = {field_type, flags, string{field_alias}, params};\n+    schema.field_names[field_alias] = field;\n   }\n \n-  // Build field name mapping table\n-  for (const auto& [field_ident, field_info] : schema.fields)\n-    schema.field_names[field_info.short_name] = field_ident;\n-\n   return false;\n }\n \n",
  "test_patch": "diff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex 904f81844517..1744e63ecfc7 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -1983,4 +1983,35 @@ TEST_F(SearchFamilyTest, InvalidAggregateOptions) {\n   EXPECT_THAT(resp, ErrArg(kInvalidIntErr));\n }\n \n+TEST_F(SearchFamilyTest, InvalidCreateOptions) {\n+  // Test with a duplicate field in the schema\n+  auto resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"SCHEMA\", \"title\", \"TEXT\", \"title\", \"TEXT\"});\n+  EXPECT_THAT(resp, ErrArg(\"Duplicate field in schema - title\"));\n+\n+  // Test with no fields in the schema\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"SCHEMA\"});\n+  EXPECT_THAT(resp, ErrArg(\"Fields arguments are missing\"));\n+\n+  // Test with an invalid field type\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"SCHEMA\", \"title\", \"UNKNOWN_TYPE\"});\n+  EXPECT_THAT(resp, ErrArg(\"Field type UNKNOWN_TYPE is not supported\"));\n+\n+  // Test with an invalid STOPWORDS argument\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"STOPWORDS\", \"10\", \"the\", \"and\", \"of\", \"SCHEMA\",\n+              \"title\", \"TEXT\"});\n+  EXPECT_THAT(resp, ErrArg(kSyntaxErr));\n+\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"STOPWORDS\", \"99999999999999999999\", \"the\", \"and\",\n+              \"of\", \"SCHEMA\", \"title\", \"TEXT\"});\n+  EXPECT_THAT(resp, ErrArg(kInvalidIntErr));\n+\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"STOPWORDS\", \"-1\", \"the\", \"and\", \"of\", \"SCHEMA\",\n+              \"title\", \"TEXT\"});\n+  EXPECT_THAT(resp, ErrArg(kInvalidIntErr));\n+\n+  resp = Run({\"FT.CREATE\", \"index\", \"ON\", \"HASH\", \"STOPWORDS\", \"not_a_number\", \"the\", \"and\", \"of\",\n+              \"SCHEMA\", \"title\", \"TEXT\"});\n+  EXPECT_THAT(resp, ErrArg(kInvalidIntErr));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Add tests for the SEARCH commands\nWe should not crash during parsing different options in `FT.*` commands. For example: (empty separator in FT.CREATE)\n```\n127.0.0.1:6379> ft.create index on json schema $.sometag AS sometag TAG SEPARATOR\nError: Server closed the connection\n```\n\nSo we should add parsing tests for all `FT.*` commands, especially for the `FT.CREATE`, `FT.SEARCH` and `FT.AGGREGATE` commands.\n\n- [x] #4208\n- [x] Add tests for different options in the `FT.CREATE` command. Fixed by #4678\n- [x] Add tests for different options in the `FT.SEARCH` command. Fixed by #4478\n- [x] Add tests for different options in the `FT.AGGREGATE` command. Fixed by #4479\n- [ ] Test all other FT.* commands\n\nCrash during parsing of the FT.CREATE command\nThe crash occurs when attempting to create an index with an unknown field type:\n```\nFT.CREATE index ON HASH PREFIX 1 doc: SCHEMA title UNKNOWN_TYPE\n```\n",
  "hints_text": "\n",
  "created_at": "2025-03-02T11:10:13Z",
  "modified_files": [
    "src/server/search/search_family.cc"
  ],
  "modified_test_files": [
    "src/server/search/search_family_test.cc"
  ]
}