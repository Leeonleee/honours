{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2033,
  "instance_id": "dragonflydb__dragonfly-2033",
  "issue_numbers": [
    "2030"
  ],
  "base_commit": "4b387cebe26a99d2f0c329bde7b994b59b6179c0",
  "patch": "diff --git a/helio b/helio\nindex 2d447ea39da7..3586e6b03fd1 160000\n--- a/helio\n+++ b/helio\n@@ -1,1 +1,1 @@\n-Subproject commit 2d447ea39da78d0ec0003e812c306f2846e8e727\n+Subproject commit 3586e6b03fd10893bc0980104d8d5ebf03cd5c88\ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 4488aad9de0e..7681bf8352c6 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -336,12 +336,13 @@ void Connection::UnregisterShutdownHook(ShutdownHandle id) {\n void Connection::HandleRequests() {\n   ThisFiber::SetName(\"DflyConnection\");\n \n-  if (absl::GetFlag(FLAGS_tcp_nodelay)) {\n+  if (absl::GetFlag(FLAGS_tcp_nodelay) && !socket_->IsUDS()) {\n     int val = 1;\n-    CHECK_EQ(0, setsockopt(socket_->native_handle(), IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)));\n+    int res = setsockopt(socket_->native_handle(), IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val));\n+    DCHECK_EQ(res, 0);\n   }\n \n-  auto remote_ep = socket_->RemoteEndpoint();\n+  auto remote_ep = RemoteEndpointStr();\n \n   FiberSocketBase* peer = socket_.get();\n #ifdef DFLY_USE_SSL\n@@ -402,18 +403,13 @@ void Connection::RegisterBreakHook(BreakerCb breaker_cb) {\n   breaker_cb_ = breaker_cb;\n }\n \n-std::string Connection::LocalBindAddress() const {\n-  auto le = socket_->LocalEndpoint();\n-  return le.address().to_string();\n-}\n-\n std::pair<std::string, std::string> Connection::GetClientInfoBeforeAfterTid() const {\n   CHECK(service_ && socket_);\n   CHECK_LT(unsigned(phase_), NUM_PHASES);\n \n   string before;\n-  auto le = socket_->LocalEndpoint();\n-  auto re = socket_->RemoteEndpoint();\n+  auto le = LocalBindStr();\n+  auto re = RemoteEndpointStr();\n   time_t now = time(nullptr);\n \n   int cpu = 0;\n@@ -429,8 +425,7 @@ std::pair<std::string, std::string> Connection::GetClientInfoBeforeAfterTid() co\n   static constexpr string_view PHASE_NAMES[] = {\"setup\", \"readsock\", \"process\"};\n   static_assert(PHASE_NAMES[PROCESS] == \"process\");\n \n-  absl::StrAppend(&before, \"id=\", id_, \" addr=\", re.address().to_string(), \":\", re.port());\n-  absl::StrAppend(&before, \" laddr=\", le.address().to_string(), \":\", le.port());\n+  absl::StrAppend(&before, \"id=\", id_, \" addr=\", re, \" laddr=\", le);\n   absl::StrAppend(&before, \" fd=\", socket_->native_handle(), \" name=\", name_);\n \n   string after;\n@@ -1096,16 +1091,34 @@ void Connection::EnsureAsyncMemoryBudget() {\n   queue_backpressure_->EnsureBelowLimit();\n }\n \n+std::string Connection::LocalBindStr() const {\n+  if (socket_->IsUDS())\n+    return \"unix-domain-socket\";\n+\n+  auto le = socket_->LocalEndpoint();\n+  return absl::StrCat(le.address().to_string(), \":\", le.port());\n+}\n+\n+std::string Connection::LocalBindAddress() const {\n+  if (socket_->IsUDS())\n+    return \"unix-domain-socket\";\n+\n+  auto le = socket_->LocalEndpoint();\n+  return le.address().to_string();\n+}\n+\n std::string Connection::RemoteEndpointStr() const {\n-  const bool unix_socket = socket_->IsUDS();\n-  std::string connection_str = unix_socket ? \"unix:\" : std::string{};\n+  if (socket_->IsUDS())\n+    return \"unix-domain-socket\";\n \n   auto re = socket_->RemoteEndpoint();\n-  absl::StrAppend(&connection_str, re.address().to_string(), \":\", re.port());\n-  return connection_str;\n+  return absl::StrCat(re.address().to_string(), \":\", re.port());\n }\n \n std::string Connection::RemoteEndpointAddress() const {\n+  if (socket_->IsUDS())\n+    return \"unix-domain-socket\";\n+\n   auto re = socket_->RemoteEndpoint();\n   return re.address().to_string();\n }\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 98e7bc892b9b..bfc3b7a74021 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -157,13 +157,16 @@ class Connection : public util::Connection {\n \n   std::string GetClientInfo(unsigned thread_id) const;\n   std::string GetClientInfo() const;\n-  virtual std::string RemoteEndpointStr() const;\n+\n+  virtual std::string RemoteEndpointStr() const;  // virtual because overwritten in test_utils\n   std::string RemoteEndpointAddress() const;\n+\n+  std::string LocalBindStr() const;\n   std::string LocalBindAddress() const;\n \n   uint32_t GetClientId() const;\n-  // Virtual because behavior is overridden in test_utils.\n-  virtual bool IsPrivileged() const;\n+\n+  virtual bool IsPrivileged() const;  // virtual because overwritten in test_utils\n \n   bool IsMain() const;\n \n",
  "test_patch": "diff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py\nindex 882da52d7f61..3c1014cd147e 100644\n--- a/tests/dragonfly/connection_test.py\n+++ b/tests/dragonfly/connection_test.py\n@@ -536,3 +536,14 @@ async def test_memcached_large_request(df_local_factory):\n     memcached_client = pymemcache.Client((\"localhost\", server.mc_port), default_noreply=False)\n \n     assert memcached_client.set(b\"key\", b\"d\" * 4096, noreply=False)\n+\n+\n+@pytest.mark.asyncio\n+async def test_unix_domain_socket(df_local_factory, tmp_dir):\n+    server = df_local_factory.create(proactor_threads=1, port=BASE_PORT, unixsocket=\"./df.sock\")\n+    server.start()\n+\n+    await asyncio.sleep(0.5)\n+\n+    r = aioredis.Redis(unix_socket_path=tmp_dir / \"df.sock\")\n+    assert await r.ping()\n",
  "problem_statement": "Fix tcp_nodelay option on unix sockets\nFrom discord:\r\n\r\n>after updating to v1.11.0, dragonfly is refusing connections over unix sockets\r\nerrors in logs are attached\r\n\r\n[message.txt](https://github.com/dragonflydb/dragonfly/files/12927108/message.txt)\r\n\n",
  "hints_text": "",
  "created_at": "2023-10-17T12:07:56Z",
  "modified_files": [
    "helio",
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/connection_test.py"
  ]
}