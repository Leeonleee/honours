{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1994,
  "instance_id": "dragonflydb__dragonfly-1994",
  "issue_numbers": [
    "1099"
  ],
  "base_commit": "ec87114f669e6363e128b9c3a1b1ed7ddb5a284f",
  "patch": "diff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex 8d517c4a2874..79f6a67e559e 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -462,7 +462,8 @@ ResultSetView DiffResultVec(const ResultStringVec& result_vec, ShardId src_shard\n   return uniques;\n }\n \n-OpResult<SvArray> InterResultVec(const ResultStringVec& result_vec, unsigned required_shard_cnt) {\n+OpResult<SvArray> InterResultVec(const ResultStringVec& result_vec, unsigned required_shard_cnt,\n+                                 unsigned limit = 0) {\n   absl::flat_hash_map<std::string_view, unsigned> uniques;\n \n   for (const auto& res : result_vec) {\n@@ -504,6 +505,8 @@ OpResult<SvArray> InterResultVec(const ResultStringVec& result_vec, unsigned req\n \n   for (const auto& k_v : uniques) {\n     if (k_v.second == required_shard_cnt) {\n+      if (limit != 0 && result.size() >= limit)\n+        return result;\n       result.push_back(k_v.first);\n     }\n   }\n@@ -1378,6 +1381,31 @@ void SInterStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(result->size());\n }\n \n+void SInterCard(CmdArgList args, ConnectionContext* cntx) {\n+  unsigned num_keys;\n+  if (!absl::SimpleAtoi(ArgS(args, 0), &num_keys))\n+    return (*cntx)->SendError(kSyntaxErr);\n+\n+  unsigned limit = 0;\n+  if (args.size() == (num_keys + 3) && ArgS(args, 1 + num_keys) == \"LIMIT\") {\n+    if (!absl::SimpleAtoi(ArgS(args, num_keys + 2), &limit))\n+      return (*cntx)->SendError(\"limit can't be negative\");\n+  } else if (args.size() > (num_keys + 1))\n+    return (*cntx)->SendError(kSyntaxErr);\n+\n+  ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    result_set[shard->shard_id()] = OpInter(t, shard, false);\n+    return OpStatus::OK;\n+  };\n+\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  OpResult<SvArray> result =\n+      InterResultVec(result_set, cntx->transaction->GetUniqueShardCnt(), limit);\n+\n+  return (*cntx)->SendLong(result->size());\n+}\n+\n void SUnion(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size());\n \n@@ -1567,6 +1595,7 @@ constexpr uint32_t kSDiff = READ | SET | SLOW;\n constexpr uint32_t kSDiffStore = WRITE | SET | SLOW;\n constexpr uint32_t kSInter = READ | SET | SLOW;\n constexpr uint32_t kSInterStore = WRITE | SET | SLOW;\n+constexpr uint32_t kSInterCard = READ | SET | SLOW;\n constexpr uint32_t kSMembers = READ | SET | SLOW;\n constexpr uint32_t kSIsMember = READ | SET | SLOW;\n constexpr uint32_t kSMIsMember = READ | SET | FAST;\n@@ -1591,6 +1620,9 @@ void SetFamily::Register(CommandRegistry* registry) {\n       << CI{\"SINTERSTORE\",    CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL, -3, 1, -1, 1,\n             acl::kSInterStore}\n              .HFUNC(SInterStore)\n+      << CI{\"SINTERCARD\",    CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1,\n+            acl::kSInterCard}\n+             .HFUNC(SInterCard)\n       << CI{\"SMEMBERS\", CO::READONLY, 2, 1, 1, 1, acl::kSMembers}.HFUNC(SMembers)\n       << CI{\"SISMEMBER\", CO::FAST | CO::READONLY, 3, 1, 1, 1, acl::kSIsMember}.HFUNC(SIsMember)\n       << CI{\"SMISMEMBER\", CO::READONLY, -3, 1, 1, 1, acl::kSMIsMember}.HFUNC(SMIsMember)\n",
  "test_patch": "diff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex 4260ee0501a3..0b24429bf33e 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -94,6 +94,31 @@ TEST_F(SetFamilyTest, SInter) {\n   EXPECT_THAT(resp, IntArg(0));\n }\n \n+TEST_F(SetFamilyTest, SInterCard) {\n+  Run({\"sadd\", \"s1\", \"2\", \"b\", \"1\", \"a\"});\n+  Run({\"sadd\", \"s2\", \"3\", \"c\", \"2\", \"b\"});\n+  Run({\"sadd\", \"s3\", \"2\", \"b\", \"3\", \"c\"});\n+\n+  EXPECT_EQ(2, CheckedInt({\"sintercard\", \"2\", \"s1\", \"s2\"}));\n+  EXPECT_EQ(0, CheckedInt({\"sintercard\", \"2\", \"s1\", \"s4\"}));\n+  EXPECT_EQ(2, CheckedInt({\"sintercard\", \"2\", \"s2\", \"s3\", \"LIMIT\", \"2\"}));\n+  EXPECT_EQ(4, CheckedInt({\"sintercard\", \"1\", \"s1\"}));\n+\n+  auto resp = Run({\"sintercard\", \"a\", \"s1\", \"s2\"});\n+  // redis does not throw this message, but SimpleAtoi does\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+  resp = Run({\"sintercard\", \"2\", \"s1\", \"s2\", \"LIMIT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+  resp = Run({\"sintercard\", \"2\", \"s1\", \"s2\", \"LIMIT\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"limit can't be negative\"));\n+  resp = Run({\"sintercard\", \"2\", \"s1\", \"s2\", \"LIMIT\", \"-1\"});\n+  EXPECT_THAT(resp, ErrArg(\"limit can't be negative\"));\n+  resp = Run({\"sintercard\", \"2\", \"s1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+  resp = Run({\"sintercard\", \"-1\", \"s1\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+}\n+\n TEST_F(SetFamilyTest, SMove) {\n   auto resp = Run({\"sadd\", \"a\", \"1\", \"2\", \"3\", \"4\"});\n   Run({\"sadd\", \"b\", \"3\", \"5\", \"6\", \"2\"});\n",
  "problem_statement": "Missing SINTERCARD command\n\n",
  "hints_text": "Yeah, we do not support redis 7.0 API yet. Why do you need it?\nMy app maintains a list of users who are currently online, and this list can potentially reach millions in number. In addition, the app has several group chats, each with thousands of members.\r\n\r\nMy plan was to store the active users in a sorted set (which gets cleaned up the set every few minutes.), \r\nand the group members for each chat in regular set.\r\n\r\nAnd the cardinality of the intersected set would give me the number of active users in a specific group chat.\nI see. So you need to intersect a sorted set with a regular set?\r\n\nYes, and I need the cardinality of the intersected set. One way is that I can first ZINTERSTORE and then get the cardinality of the new set, and clean up the new set after that, but a single command to do that will be much simple and better. \nHi @romange,\r\n\r\nDo you have any timeline for possibly implementing SINTERCARD in DragonflyDB? \r\n\r\nAny rough estimate or roadmap would be helpful for me to plan my usage of DragonflyDB accordingly.\nThis quarter :)\n@0xManjeet  btw, given your description you need to use ZINTERCARD and not SINTERCARD because you want to intersect a sorted set with set. Please confirm\nYou're right, I'll need ZINTERCARD for my specific use case.",
  "created_at": "2023-10-06T02:59:10Z",
  "modified_files": [
    "src/server/set_family.cc"
  ],
  "modified_test_files": [
    "src/server/set_family_test.cc"
  ]
}