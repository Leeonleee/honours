diff --git a/src/core/dash_test.cc b/src/core/dash_test.cc
index 6cd1177b5d02..8435fb434f5f 100644
--- a/src/core/dash_test.cc
+++ b/src/core/dash_test.cc
@@ -75,6 +75,12 @@ struct UInt64Policy : public BasicDashPolicy {
   }
 };
 
+struct RelaxedBumpPolicy {
+  bool CanBumpDown(uint64_t key) const {
+    return true;
+  }
+};
+
 class CappedResource final : public std::pmr::memory_resource {
  public:
   explicit CappedResource(size_t cap) : cap_(cap) {
@@ -350,7 +356,7 @@ TEST_F(DashTest, BumpUp) {
   EXPECT_EQ(touched_bid[0], 1);
 
   // Bump up
-  segment_.BumpUp(kFirstStashId, 5, hash);
+  segment_.BumpUp(kFirstStashId, 5, hash, RelaxedBumpPolicy{});
 
   // expect the key to move
   EXPECT_TRUE(segment_.GetBucket(1).IsFull());
@@ -365,13 +371,40 @@ TEST_F(DashTest, BumpUp) {
   EXPECT_EQ(1, segment_.CVCOnBump(2, kSecondStashId, 9, hash, touched_bid));
   EXPECT_EQ(touched_bid[0], kSecondStashId);
 
-  segment_.BumpUp(kSecondStashId, 9, hash);
+  segment_.BumpUp(kSecondStashId, 9, hash, RelaxedBumpPolicy{});
   ASSERT_TRUE(key == segment_.Key(0, kNumSlots - 1) || key == segment_.Key(1, kNumSlots - 1));
   EXPECT_TRUE(segment_.GetBucket(kSecondStashId).IsFull());
   EXPECT_TRUE(Contains(key));
   EXPECT_TRUE(segment_.Key(kSecondStashId, 9));
 }
 
+TEST_F(DashTest, BumpPolicy) {
+  struct RestrictedBumpPolicy {
+    bool CanBumpDown(uint64_t key) const {
+      return false;
+    }
+  };
+
+  set<Segment::Key_t> keys = FillSegment(0);
+  constexpr unsigned kFirstStashId = Segment::kNumBuckets;
+
+  EXPECT_TRUE(segment_.GetBucket(0).IsFull());
+  EXPECT_TRUE(segment_.GetBucket(1).IsFull());
+  EXPECT_TRUE(segment_.GetBucket(kFirstStashId).IsFull());
+
+  // check items are immovable in bucket
+  Segment::Key_t key = segment_.Key(1, 2);
+  uint64_t hash = dt_.DoHash(key);
+  segment_.BumpUp(1, 2, hash, RestrictedBumpPolicy{});
+  EXPECT_EQ(key, segment_.Key(1, 2));
+
+  // check items don't swap from stash
+  key = segment_.Key(kFirstStashId, 2);
+  hash = dt_.DoHash(key);
+  segment_.BumpUp(kFirstStashId, 2, hash, RestrictedBumpPolicy{});
+  EXPECT_EQ(key, segment_.Key(kFirstStashId, 2));
+}
+
 TEST_F(DashTest, Insert2) {
   uint64_t k = 1191;
   ASSERT_EQ(2019837007031366716, UInt64Policy::HashFn(k));
@@ -954,7 +987,7 @@ TEST_P(EvictionPolicyTest, HitRateZipf) {
                << it.slot_id();
     } else {
       if (use_bumps)
-        dt_.BumpUp(it);
+        dt_.BumpUp(it, RelaxedBumpPolicy{});
       ++hits;
     }
   }
@@ -984,7 +1017,7 @@ TEST_P(EvictionPolicyTest, HitRateZipfShr) {
         }
       } else {
         if (use_bumps) {
-          dt_.BumpUp(it);
+          dt_.BumpUp(it, RelaxedBumpPolicy{});
           DVLOG(1) << "Bump up key " << key << " " << it.bucket_id() << " slot " << it.slot_id();
         } else {
           DVLOG(1) << "Hit on key " << key;
diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc
index c4148efb22a2..0dd6e978c06b 100644
--- a/src/server/dragonfly_test.cc
+++ b/src/server/dragonfly_test.cc
@@ -499,6 +499,32 @@ TEST_F(DflyEngineTest, Bug207) {
   }
 }
 
+TEST_F(DflyEngineTest, StickyEviction) {
+  shard_set->TEST_EnableHeartBeat();
+  shard_set->TEST_EnableCacheMode();
+  max_memory_limit = 0;
+
+  string tmp_val(100, '.');
+
+  ssize_t failed = -1;
+  for (ssize_t i = 0; i < 5000; ++i) {
+    auto set_resp = Run({"set", StrCat("key", i), tmp_val});
+    auto stick_resp = Run({"stick", StrCat("key", i)});
+
+    if (set_resp != "OK") {
+      failed = i;
+      break;
+    }
+    ASSERT_THAT(stick_resp, IntArg(1));
+  }
+
+  ASSERT_GE(failed, 0);
+  // Make sure neither of the sticky values was evicted
+  for (ssize_t i = 0; i < failed; ++i) {
+    ASSERT_THAT(Run({"exists", StrCat("key", i)}), IntArg(1));
+  }
+}
+
 TEST_F(DflyEngineTest, PSubscribe) {
   single_response_ = false;
   auto resp = pp_->at(1)->Await([&] { return Run({"psubscribe", "a*", "b*"}); });
diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc
index 9f5bcea64693..b9d5343e65a8 100644
--- a/src/server/generic_family_test.cc
+++ b/src/server/generic_family_test.cc
@@ -165,6 +165,42 @@ TEST_F(GenericFamilyTest, RenameNx) {
   ASSERT_EQ(Run({"get", "y"}), x_val);
 }
 
+TEST_F(GenericFamilyTest, Stick) {
+  // check stick returns zero on non-existent keys
+  ASSERT_THAT(Run({"stick", "a", "b"}), IntArg(0));
+
+  for (auto key: {"a", "b", "c", "d"}) {
+    Run({"set", key, "."});
+  }
+
+  // check stick is applied only once
+  ASSERT_THAT(Run({"stick", "a", "b"}), IntArg(2));
+  ASSERT_THAT(Run({"stick", "a", "b"}), IntArg(0));
+  ASSERT_THAT(Run({"stick", "a", "c"}), IntArg(1));
+  ASSERT_THAT(Run({"stick", "b", "d"}), IntArg(1));
+  ASSERT_THAT(Run({"stick", "c", "d"}), IntArg(0));
+
+  // check stickyness presists during writes
+  Run({"set", "a", "new"});
+  ASSERT_THAT(Run({"stick", "a"}), IntArg(0));
+  Run({"append", "a", "-value"});
+  ASSERT_THAT(Run({"stick", "a"}), IntArg(0));
+
+  // check rename persists stickyness
+  Run({"rename", "a", "k"});
+  ASSERT_THAT(Run({"stick", "k"}), IntArg(0));
+
+  // check rename perists stickyness on multiple shards
+  Run({"del", "b"});
+  string b_val(32, 'b');
+  string x_val(32, 'x');
+  Run({"mset", "b", b_val, "x", x_val});
+  ASSERT_EQ(2, last_cmd_dbg_info_.shards_count);
+  Run({"stick", "x"});
+  Run({"rename", "x", "b"});
+  ASSERT_THAT(Run({"stick", "b"}), IntArg(0));
+}
+
 
 using testing::AnyOf;
 using testing::Each;
