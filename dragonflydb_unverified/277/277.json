{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 277,
  "instance_id": "dragonflydb__dragonfly-277",
  "issue_numbers": [
    "279"
  ],
  "base_commit": "d3359f1a0a448addfe55fa5824021e371741d78c",
  "patch": "diff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex def9ae96cce4..8cf326b0ea3c 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -212,6 +212,12 @@ void ConnectionContext::SendSubscriptionChangedResponse(string_view action,\n }\n \n void ConnectionContext::OnClose() {\n+  if (!conn_state.exec_info.watched_keys.empty()) {\n+    shard_set->RunBriefInParallel([this](EngineShard* shard) {\n+      return shard->db_slice().UnregisterConnectionWatches(&conn_state.exec_info);\n+    });\n+  }\n+\n   if (!conn_state.subscribe_info)\n     return;\n \n@@ -244,4 +250,16 @@ string ConnectionContext::GetContextInfo() const {\n   return index ? absl::StrCat(\"flags:\", buf) : string();\n }\n \n+void ConnectionState::ExecInfo::Clear() {\n+  state = EXEC_INACTIVE;\n+  body.clear();\n+  ClearWatched();\n+}\n+\n+void ConnectionState::ExecInfo::ClearWatched() {\n+  watched_keys.clear();\n+  watched_dirty.store(false, memory_order_relaxed);\n+  watched_existed = 0;\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex 7aa31ae0146d..80d046f5a06d 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -23,40 +23,41 @@ struct StoredCmd {\n };\n \n struct ConnectionState {\n-  DbIndex db_index = 0;\n-\n-  enum ExecState { EXEC_INACTIVE, EXEC_COLLECT, EXEC_ERROR };\n-\n-  ExecState exec_state = EXEC_INACTIVE;\n-  std::vector<StoredCmd> exec_body;\n-\n-  enum MCGetMask {\n-    FETCH_CAS_VER = 1,\n+  // MULTI-EXEC transaction related data.\n+  struct ExecInfo {\n+    enum ExecState { EXEC_INACTIVE, EXEC_COLLECT, EXEC_ERROR };\n+\n+    ExecInfo() = default;\n+    // ExecInfo is immovable due to being referenced from DbSlice.\n+    ExecInfo(ExecInfo&&) = delete;\n+\n+    // Return true if ExecInfo is active (after MULTI)\n+    bool IsActive() { return state != EXEC_INACTIVE; }\n+\n+    // Resets to blank state after EXEC or DISCARD\n+    void Clear();\n+\n+    // Resets local watched keys info. Does not unregister the keys from DbSlices.\n+    void ClearWatched();\n+\n+    ExecState state = EXEC_INACTIVE;\n+    std::vector<StoredCmd> body;\n+    // List of keys registered with WATCH\n+    std::vector<std::pair<DbIndex, std::string>> watched_keys;\n+    // Set if a watched key was changed before EXEC\n+    std::atomic_bool watched_dirty = false;\n+    // Number of times watch was called on an existing key.\n+    uint32_t watched_existed = 0;\n   };\n \n-  // used for memcache set/get commands.\n-  // For set op - it's the flag value we are storing along with the value.\n-  // For get op - we use it as a mask of MCGetMask values.\n-  uint32_t memcache_flag = 0;\n-\n-  // If it's a replication client - then it holds positive sync session id.\n-  uint32_t sync_session_id = 0;\n-\n   // Lua-script related data.\n-  struct Script {\n+  struct ScriptInfo {\n     bool is_write = true;\n-\n     absl::flat_hash_set<std::string_view> keys;\n   };\n-  std::optional<Script> script_info;\n \n+  // PUB-SUB messaging related data.\n   struct SubscribeInfo {\n-    // TODO: to provide unique_strings across service. This will allow us to use string_view here.\n-    absl::flat_hash_set<std::string> channels;\n-    absl::flat_hash_set<std::string> patterns;\n-\n-    util::fibers_ext::BlockingCounter borrow_token;\n-\n     bool IsEmpty() const {\n       return channels.empty() && patterns.empty();\n     }\n@@ -65,10 +66,28 @@ struct ConnectionState {\n       return channels.size() + patterns.size();\n     }\n \n-    SubscribeInfo() : borrow_token(0) {\n-    }\n+    // TODO: to provide unique_strings across service. This will allow us to use string_view here.\n+    absl::flat_hash_set<std::string> channels;\n+    absl::flat_hash_set<std::string> patterns;\n+\n+    util::fibers_ext::BlockingCounter borrow_token{0};\n+  };\n+\n+  enum MCGetMask {\n+    FETCH_CAS_VER = 1,\n   };\n \n+  DbIndex db_index = 0;\n+\n+  // used for memcache set/get commands.\n+  // For set op - it's the flag value we are storing along with the value.\n+  // For get op - we use it as a mask of MCGetMask values.\n+  uint32_t memcache_flag = 0;\n+  // If it's a replication client - then it holds positive sync session id.\n+  uint32_t sync_session_id = 0;\n+\n+  ExecInfo exec_info;\n+  std::optional<ScriptInfo> script_info;\n   std::unique_ptr<SubscribeInfo> subscribe_info;\n };\n \ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex f4bb779d813a..f3e5b59771d7 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -460,6 +460,10 @@ void DbSlice::FlushDb(DbIndex db_ind) {\n \n   if (db_ind != kDbAll) {\n     auto& db = db_arr_[db_ind];\n+    if (db) {\n+      InvalidateDbWatches(db_ind);\n+    }\n+\n     auto db_ptr = std::move(db);\n     DCHECK(!db);\n     CreateDb(db_ind);\n@@ -470,6 +474,12 @@ void DbSlice::FlushDb(DbIndex db_ind) {\n     return;\n   }\n \n+  for (size_t i = 0; i < db_arr_.size(); i++) {\n+    if (db_arr_[i]) {\n+      InvalidateDbWatches(i);\n+    }\n+  }\n+\n   auto all_dbs = std::move(db_arr_);\n   db_arr_.resize(all_dbs.size());\n   for (size_t i = 0; i < db_arr_.size(); ++i) {\n@@ -545,7 +555,7 @@ pair<PrimeIterator, bool> DbSlice::AddEntry(DbIndex db_ind, string_view key, Pri\n   auto& it = res.first;\n \n   it->second = std::move(obj);\n-  PostUpdate(db_ind, it, false);\n+  PostUpdate(db_ind, it, key, false);\n \n   if (expire_at_ms) {\n     it->second.SetExpire(true);\n@@ -651,7 +661,7 @@ void DbSlice::PreUpdate(DbIndex db_ind, PrimeIterator it) {\n   it.SetVersion(NextVersion());\n }\n \n-void DbSlice::PostUpdate(DbIndex db_ind, PrimeIterator it, bool existing) {\n+void DbSlice::PostUpdate(DbIndex db_ind, PrimeIterator it, std::string_view key, bool existing) {\n   DbTableStats* stats = MutableStats(db_ind);\n \n   size_t value_heap_size = it->second.MallocUsed();\n@@ -660,6 +670,18 @@ void DbSlice::PostUpdate(DbIndex db_ind, PrimeIterator it, bool existing) {\n     stats->strval_memory_usage += value_heap_size;\n   if (existing)\n     stats->update_value_amount += value_heap_size;\n+\n+  auto& watched_keys = db_arr_[db_ind]->watched_keys;\n+  if (!watched_keys.empty()) {\n+    // Check if the key is watched.\n+    if (auto wit = watched_keys.find(key); wit != watched_keys.end()) {\n+      for (auto conn_ptr : wit->second) {\n+        conn_ptr->watched_dirty.store(true, memory_order_relaxed);\n+      }\n+      // No connections need to watch it anymore.\n+      watched_keys.erase(wit);\n+    }\n+  }\n }\n \n pair<PrimeIterator, ExpireIterator> DbSlice::ExpireIfNeeded(DbIndex db_ind,\n@@ -830,4 +852,28 @@ size_t DbSlice::EvictObjects(size_t memory_to_free, PrimeIterator it, DbTable* t\n   return freed_memory_fun();\n };\n \n+void DbSlice::RegisterWatchedKey(DbIndex db_indx, std::string_view key, ConnectionState::ExecInfo* exec_info) {\n+  db_arr_[db_indx]->watched_keys[key].push_back(exec_info);\n+}\n+\n+void DbSlice::UnregisterConnectionWatches(ConnectionState::ExecInfo* exec_info) {\n+  for (const auto& [db_indx, key] : exec_info->watched_keys) {\n+    auto& watched_keys = db_arr_[db_indx]->watched_keys;\n+    if (auto it = watched_keys.find(key); it != watched_keys.end()) {\n+      it->second.erase(std::remove(it->second.begin(), it->second.end(), exec_info),\n+                       it->second.end());\n+      if (it->second.empty())\n+        watched_keys.erase(it);\n+    }\n+  }\n+}\n+\n+void DbSlice::InvalidateDbWatches(DbIndex db_indx) {\n+  for (const auto& [key, conn_list] : db_arr_[db_indx]->watched_keys) {\n+    for (auto conn_ptr : conn_list) {\n+      conn_ptr->watched_dirty.store(true, memory_order_relaxed);\n+    }\n+  }\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/db_slice.h b/src/server/db_slice.h\nindex 10587d7b1f54..fa0f8ba92aa0 100644\n--- a/src/server/db_slice.h\n+++ b/src/server/db_slice.h\n@@ -9,6 +9,7 @@\n #include \"facade/op_status.h\"\n #include \"server/common.h\"\n #include \"server/table.h\"\n+#include \"server/conn_context.h\"\n \n namespace util {\n class ProactorBase;\n@@ -217,7 +218,7 @@ class DbSlice {\n \n   // Callback functions called upon writing to the existing key.\n   void PreUpdate(DbIndex db_ind, PrimeIterator it);\n-  void PostUpdate(DbIndex db_ind, PrimeIterator it, bool existing_entry = true);\n+  void PostUpdate(DbIndex db_ind, PrimeIterator it, std::string_view key, bool existing_entry = true);\n \n   DbTableStats* MutableStats(DbIndex db_ind) {\n     return &db_arr_[db_ind]->stats;\n@@ -261,6 +262,14 @@ class DbSlice {\n     caching_mode_ = 1;\n   }\n \n+  void RegisterWatchedKey(DbIndex db_indx, std::string_view key, ConnectionState::ExecInfo* exec_info);\n+\n+  // Unregisted all watched key entries for connection.\n+  void UnregisterConnectionWatches(ConnectionState::ExecInfo* exec_info);\n+\n+  // Invalidate all watched keys in database. Used on FLUSH.\n+  void InvalidateDbWatches(DbIndex db_indx);\n+\n  private:\n   void CreateDb(DbIndex index);\n   size_t EvictObjects(size_t memory_to_free, PrimeIterator it, DbTable* table);\n@@ -269,6 +278,7 @@ class DbSlice {\n     return version_++;\n   }\n \n+ private:\n   ShardId shard_id_;\n   uint8_t caching_mode_ : 1;\n \ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex 1ace67908947..50c43a8bb1b9 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -28,6 +28,9 @@ class GenericFamily {\n \n   static void Register(CommandRegistry* registry);\n \n+  // Accessed by Service::Exec and Service::Watch as an utility.\n+  static OpResult<uint32_t> OpExists(const OpArgs& op_args, ArgSlice keys);\n+\n  private:\n   enum TimeUnit { SEC, MSEC };\n \n@@ -65,7 +68,6 @@ class GenericFamily {\n \n   static OpResult<uint64_t> OpTtl(Transaction* t, EngineShard* shard, std::string_view key);\n   static OpResult<uint32_t> OpDel(const OpArgs& op_args, ArgSlice keys);\n-  static OpResult<uint32_t> OpExists(const OpArgs& op_args, ArgSlice keys);\n   static OpResult<void> OpRen(const OpArgs& op_args, std::string_view from, std::string_view to,\n                               bool skip_exists);\n   static OpResult<uint32_t> OpStick(const OpArgs& op_args, ArgSlice keys);\ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex 38a54a818ed9..aaf92bca0895 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -509,7 +509,7 @@ OpResult<uint32_t> HSetFamily::OpSet(const OpArgs& op_args, string_view key, Cmd\n     }\n   }\n   it->second.SyncRObj();\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   return created;\n }\n@@ -548,7 +548,7 @@ OpResult<uint32_t> HSetFamily::OpDel(const OpArgs& op_args, string_view key, Cmd\n \n   co.SyncRObj();\n \n-  db_slice.PostUpdate(op_args.db_ind, *it_res);\n+  db_slice.PostUpdate(op_args.db_ind, *it_res, key);\n   if (key_remove) {\n     if (hset->encoding == OBJ_ENCODING_LISTPACK) {\n       stats->listpack_blob_cnt--;\n@@ -874,7 +874,7 @@ OpStatus HSetFamily::OpIncrBy(const OpArgs& op_args, string_view key, string_vie\n   }\n \n   it->second.SyncRObj();\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   return OpStatus::OK;\n }\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex f5c62029a989..d2a12af08c04 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -59,7 +59,7 @@ void SetString(const OpArgs& op_args, string_view key, const string& value) {\n   auto& db_slice = op_args.shard->db_slice();\n   auto [it_output, added] = db_slice.AddOrFind(op_args.db_ind, key);\n   it_output->second.SetString(value);\n-  db_slice.PostUpdate(op_args.db_ind, it_output);\n+  db_slice.PostUpdate(op_args.db_ind, it_output, key);\n   RecordJournal(op_args, it_output->first, it_output->second);\n }\n \ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 3a5d8411f9ad..4759b9893d0a 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -277,7 +277,7 @@ OpStatus BPopper::Pop(Transaction* t, EngineShard* shard) {\n \n     db_slice.PreUpdate(t->db_index(), it);\n     value_ = ListPop(dir_, ql);\n-    db_slice.PostUpdate(t->db_index(), it);\n+    db_slice.PostUpdate(t->db_index(), it, key_);\n     if (quicklistCount(ql) == 0) {\n       CHECK(shard->db_slice().Del(t->db_index(), it));\n     }\n@@ -300,7 +300,7 @@ OpResult<string> OpRPopLPushSingleShard(const OpArgs& op_args, string_view src,\n     string val = ListPop(ListDir::RIGHT, src_ql);\n \n     quicklistPushHead(src_ql, val.data(), val.size());\n-    db_slice.PostUpdate(op_args.db_ind, src_it);\n+    db_slice.PostUpdate(op_args.db_ind, src_it, src);\n \n     return val;\n   }\n@@ -336,8 +336,8 @@ OpResult<string> OpRPopLPushSingleShard(const OpArgs& op_args, string_view src,\n   string val = ListPop(ListDir::RIGHT, src_ql);\n   quicklistPushHead(dest_ql, val.data(), val.size());\n \n-  db_slice.PostUpdate(op_args.db_ind, src_it);\n-  db_slice.PostUpdate(op_args.db_ind, dest_it, !new_key);\n+  db_slice.PostUpdate(op_args.db_ind, src_it, src);\n+  db_slice.PostUpdate(op_args.db_ind, dest_it, dest, !new_key);\n \n   if (quicklistCount(src_ql) == 0) {\n     CHECK(db_slice.Del(op_args.db_ind, src_it));\n@@ -418,7 +418,7 @@ OpResult<uint32_t> OpPush(const OpArgs& op_args, std::string_view key, ListDir d\n       es->blocking_controller()->AwakeWatched(op_args.db_ind, key);\n     }\n   } else {\n-    es->db_slice().PostUpdate(op_args.db_ind, it, true);\n+    es->db_slice().PostUpdate(op_args.db_ind, it, key, true);\n   }\n \n   return quicklistCount(ql);\n@@ -451,7 +451,7 @@ OpResult<StringVec> OpPop(const OpArgs& op_args, string_view key, ListDir dir, u\n     }\n   }\n \n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   if (quicklistCount(ql) == 0) {\n     CHECK(db_slice.Del(op_args.db_ind, it));\n@@ -891,7 +891,7 @@ OpResult<int> ListFamily::OpInsert(const OpArgs& op_args, string_view key, strin\n       DCHECK_EQ(LIST_HEAD, insert_param);\n       quicklistInsertBefore(qiter, &entry, elem.data(), elem.size());\n     }\n-    db_slice.PostUpdate(op_args.db_ind, *it_res);\n+    db_slice.PostUpdate(op_args.db_ind, *it_res, key);\n     res = quicklistCount(ql);\n   }\n   quicklistReleaseIterator(qiter);\n@@ -931,7 +931,7 @@ OpResult<uint32_t> ListFamily::OpRem(const OpArgs& op_args, string_view key, str\n         break;\n     }\n   }\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   quicklistReleaseIterator(qiter);\n \n@@ -954,7 +954,7 @@ OpStatus ListFamily::OpSet(const OpArgs& op_args, string_view key, string_view e\n \n   db_slice.PreUpdate(op_args.db_ind, it);\n   int replaced = quicklistReplaceAtIndex(ql, index, elem.data(), elem.size());\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   if (!replaced) {\n     return OpStatus::OUT_OF_RANGE;\n@@ -998,7 +998,7 @@ OpStatus ListFamily::OpTrim(const OpArgs& op_args, string_view key, long start,\n   db_slice.PreUpdate(op_args.db_ind, it);\n   quicklistDelRange(ql, 0, ltrim);\n   quicklistDelRange(ql, -rtrim, rtrim);\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n \n   if (quicklistCount(ql) == 0) {\n     CHECK(db_slice.Del(op_args.db_ind, it));\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex a8efec664055..d3cf0db4dcc9 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -20,7 +20,6 @@ extern \"C\" {\n #include \"base/logging.h\"\n #include \"facade/dragonfly_connection.h\"\n #include \"facade/error.h\"\n-#include \"server/conn_context.h\"\n #include \"server/error.h\"\n #include \"server/generic_family.h\"\n #include \"server/hset_family.h\"\n@@ -395,8 +394,8 @@ void Service::Shutdown() {\n }\n \n static void MultiSetError(ConnectionContext* cntx) {\n-  if (cntx->conn_state.exec_state != ConnectionState::EXEC_INACTIVE) {\n-    cntx->conn_state.exec_state = ConnectionState::EXEC_ERROR;\n+  if (cntx->conn_state.exec_info.IsActive()) {\n+    cntx->conn_state.exec_info.state = ConnectionState::ExecInfo::EXEC_ERROR;\n   }\n }\n \n@@ -450,8 +449,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n \n   bool is_write_cmd = (cid->opt_mask() & CO::WRITE) ||\n                       (under_script && dfly_cntx->conn_state.script_info->is_write);\n-  bool under_multi =\n-      dfly_cntx->conn_state.exec_state != ConnectionState::EXEC_INACTIVE && !is_trans_cmd;\n+  bool under_multi = dfly_cntx->conn_state.exec_info.IsActive() && !is_trans_cmd;\n \n   if (!etl.is_master && is_write_cmd && !dfly_cntx->is_replicating) {\n     (*cntx)->SendError(\"-READONLY You can't write against a read only replica.\");\n@@ -482,20 +480,25 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n       (*cntx)->SendError(\"Can not call SELECT within a transaction\");\n       return;\n     }\n+\n+    if (cmd_name == \"WATCH\") {\n+      (*cntx)->SendError(\"WATCH inside MULTI is not allowed\");\n+      return;\n+    }\n   }\n \n   std::move(multi_error).Cancel();\n \n   etl.connection_stats.cmd_count_map[cmd_name]++;\n \n-  if (dfly_cntx->conn_state.exec_state != ConnectionState::EXEC_INACTIVE && !is_trans_cmd) {\n+  if (dfly_cntx->conn_state.exec_info.IsActive() && !is_trans_cmd) {\n     // TODO: protect against aggregating huge transactions.\n     StoredCmd stored_cmd{cid};\n     stored_cmd.cmd.reserve(args.size());\n     for (size_t i = 0; i < args.size(); ++i) {\n       stored_cmd.cmd.emplace_back(ArgS(args, i));\n     }\n-    dfly_cntx->conn_state.exec_body.push_back(std::move(stored_cmd));\n+    dfly_cntx->conn_state.exec_info.body.push_back(std::move(stored_cmd));\n \n     return (*cntx)->SendSimpleString(\"QUEUED\");\n   }\n@@ -725,14 +728,62 @@ void Service::Quit(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void Service::Multi(CmdArgList args, ConnectionContext* cntx) {\n-  if (cntx->conn_state.exec_state != ConnectionState::EXEC_INACTIVE) {\n+  if (cntx->conn_state.exec_info.IsActive()) {\n     return (*cntx)->SendError(\"MULTI calls can not be nested\");\n   }\n-  cntx->conn_state.exec_state = ConnectionState::EXEC_COLLECT;\n+  cntx->conn_state.exec_info.state = ConnectionState::ExecInfo::EXEC_COLLECT;\n   // TODO: to protect against huge exec transactions.\n   return (*cntx)->SendOk();\n }\n \n+void Service::Watch(CmdArgList args, ConnectionContext* cntx) {\n+  auto& exec_info = cntx->conn_state.exec_info;\n+\n+  // Skip if EXEC will already fail due previous WATCH.\n+  if (exec_info.watched_dirty.load(memory_order_relaxed)) {\n+    return (*cntx)->SendOk();\n+  }\n+\n+  atomic_uint32_t keys_existed = 0;\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    ArgSlice largs = t->ShardArgsInShard(shard->shard_id());\n+    for (auto k : largs) {\n+      shard->db_slice().RegisterWatchedKey(cntx->db_index(), k, &exec_info);\n+    }\n+\n+    auto res = GenericFamily::OpExists(t->GetOpArgs(shard), largs);\n+    keys_existed.fetch_add(res.value_or(0), memory_order_relaxed);\n+    return OpStatus::OK;\n+  };\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n+\n+  // Duplicate keys are stored to keep correct count.\n+  exec_info.watched_existed += keys_existed.load(memory_order_relaxed);\n+  for (size_t i = 1; i < args.size(); i++) {\n+    exec_info.watched_keys.emplace_back(cntx->db_index(), ArgS(args, i));\n+  }\n+\n+  return (*cntx)->SendOk();\n+}\n+\n+// Unwatch all keys for a connection and unregister from DbSlices.\n+// Used by UNWATCH, DICARD and EXEC.\n+void UnwatchAllKeys(ConnectionContext* cntx) {\n+  auto& exec_info = cntx->conn_state.exec_info;\n+  if (!exec_info.watched_keys.empty()) {\n+    auto cb = [&](EngineShard* shard) {\n+      shard->db_slice().UnregisterConnectionWatches(&exec_info);\n+    };\n+    shard_set->RunBriefInParallel(std::move(cb));\n+  }\n+  exec_info.ClearWatched();\n+}\n+\n+void Service::Unwatch(CmdArgList args, ConnectionContext* cntx) {\n+  UnwatchAllKeys(cntx);\n+  return (*cntx)->SendOk();\n+}\n+\n void Service::CallFromScript(CmdArgList args, ObjectExplorer* reply, ConnectionContext* cntx) {\n   DCHECK(cntx->transaction);\n   InterpreterReplier replier(reply);\n@@ -836,7 +887,7 @@ void Service::EvalInternal(const EvalArgs& eval_args, Interpreter* interpreter,\n   // TODO: to determine whether the script is RO by scanning all \"redis.p?call\" calls\n   // and checking whether all invocations consist of RO commands.\n   // we can do it once during script insertion into script mgr.\n-  cntx->conn_state.script_info.emplace(ConnectionState::Script{});\n+  cntx->conn_state.script_info.emplace(ConnectionState::ScriptInfo{});\n   for (size_t i = 0; i < eval_args.keys.size(); ++i) {\n     cntx->conn_state.script_info->keys.insert(ArgS(eval_args.keys, i));\n   }\n@@ -880,35 +931,96 @@ void Service::EvalInternal(const EvalArgs& eval_args, Interpreter* interpreter,\n void Service::Discard(CmdArgList args, ConnectionContext* cntx) {\n   RedisReplyBuilder* rb = (*cntx).operator->();\n \n-  if (cntx->conn_state.exec_state == ConnectionState::EXEC_INACTIVE) {\n+  if (!cntx->conn_state.exec_info.IsActive()) {\n     return rb->SendError(\"DISCARD without MULTI\");\n   }\n \n-  cntx->conn_state.exec_state = ConnectionState::EXEC_INACTIVE;\n-  cntx->conn_state.exec_body.clear();\n-\n+  UnwatchAllKeys(cntx);\n+  cntx->conn_state.exec_info.Clear();\n   rb->SendOk();\n }\n \n+// Return true if non of the connections watched keys expired.\n+bool CheckWatchedKeyExpiry(ConnectionContext* cntx, const CommandRegistry& registry) {\n+  static char EXISTS[] = \"EXISTS\";\n+  auto& exec_info = cntx->conn_state.exec_info;\n+\n+  CmdArgVec str_list(exec_info.watched_keys.size() + 1);\n+  str_list[0] = MutableSlice{EXISTS, strlen(EXISTS)};\n+  for (size_t i = 1; i < str_list.size(); i++) {\n+    auto& [db, s] = exec_info.watched_keys[i - 1];\n+    str_list[i] = MutableSlice{s.data(), s.size()};\n+  }\n+\n+  atomic_uint32_t watch_exist_count{0};\n+  auto cb = [&watch_exist_count, &exec_info](Transaction* t, EngineShard* shard) {\n+    ArgSlice args = t->ShardArgsInShard(shard->shard_id());\n+    auto res = GenericFamily::OpExists(t->GetOpArgs(shard), args);\n+    watch_exist_count.fetch_add(res.value_or(0), memory_order_relaxed);\n+    return OpStatus::OK;\n+  };\n+\n+  VLOG(1) << \"Checking expired watch keys\";\n+\n+  cntx->transaction->SetExecCmd(registry.Find(EXISTS));\n+  cntx->transaction->InitByArgs(cntx->conn_state.db_index,\n+                                CmdArgList{str_list.data(), str_list.size()});\n+  OpStatus status = cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  CHECK_EQ(OpStatus::OK, status);\n+\n+  // The comparison can still be true even if a key expired due to another one being created.\n+  // So we have to check the watched_dirty flag, which is set if a key expired.\n+  return watch_exist_count.load() == exec_info.watched_existed && !exec_info.watched_dirty.load(memory_order_relaxed);\n+}\n+\n+// Check if exec_info watches keys on dbs other than db_indx.\n+bool IsWatchingOtherDbs(DbIndex db_indx, const ConnectionState::ExecInfo& exec_info) {\n+  for (const auto& [key_db, _] : exec_info.watched_keys) {\n+    if (key_db != db_indx) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n void Service::Exec(CmdArgList args, ConnectionContext* cntx) {\n   RedisReplyBuilder* rb = (*cntx).operator->();\n \n-  if (cntx->conn_state.exec_state == ConnectionState::EXEC_INACTIVE) {\n+  if (!cntx->conn_state.exec_info.IsActive()) {\n     return rb->SendError(\"EXEC without MULTI\");\n   }\n \n-  if (cntx->conn_state.exec_state == ConnectionState::EXEC_ERROR) {\n-    cntx->conn_state.exec_state = ConnectionState::EXEC_INACTIVE;\n-    cntx->conn_state.exec_body.clear();\n+  auto& exec_info = cntx->conn_state.exec_info;\n+  absl::Cleanup exec_clear = [&cntx, &exec_info] {\n+    UnwatchAllKeys(cntx);\n+    exec_info.Clear();\n+  };\n+\n+  if (IsWatchingOtherDbs(cntx->db_index(), exec_info)) {\n+    return rb->SendError(\"Dragonfly does not allow WATCH and EXEC on different databases\");\n+  }\n+\n+  if (exec_info.state == ConnectionState::ExecInfo::EXEC_ERROR) {\n     return rb->SendError(\"-EXECABORT Transaction discarded because of previous errors\");\n   }\n \n-  VLOG(1) << \"StartExec \" << cntx->conn_state.exec_body.size();\n-  rb->StartArray(cntx->conn_state.exec_body.size());\n-  if (!cntx->conn_state.exec_body.empty()) {\n+  if (exec_info.watched_dirty.load(memory_order_relaxed)) {\n+    return rb->SendNull();\n+  }\n+\n+  // EXEC should not run if any of the watched keys expired.\n+  if (!exec_info.watched_keys.empty() && !CheckWatchedKeyExpiry(cntx, registry_)) {\n+    cntx->transaction->UnlockMulti();\n+    return rb->SendNull();\n+  }\n+\n+  VLOG(1) << \"StartExec \" << exec_info.body.size();\n+  rb->StartArray(exec_info.body.size());\n+\n+  if (!exec_info.body.empty()) {\n     CmdArgVec str_list;\n \n-    for (auto& scmd : cntx->conn_state.exec_body) {\n+    for (auto& scmd : exec_info.body) {\n       str_list.resize(scmd.cmd.size());\n       for (size_t i = 0; i < scmd.cmd.size(); ++i) {\n         string& s = scmd.cmd[i];\n@@ -929,12 +1041,10 @@ void Service::Exec(CmdArgList args, ConnectionContext* cntx) {\n         break;\n     }\n \n-    VLOG(1) << \"Exec unlocking \" << cntx->conn_state.exec_body.size() << \" commands\";\n+    VLOG(1) << \"Exec unlocking \" << exec_info.body.size() << \" commands\";\n     cntx->transaction->UnlockMulti();\n   }\n \n-  cntx->conn_state.exec_state = ConnectionState::EXEC_INACTIVE;\n-  cntx->conn_state.exec_body.clear();\n   VLOG(1) << \"Exec completed\";\n }\n \n@@ -1150,6 +1260,8 @@ void Service::RegisterCommands() {\n   registry_\n       << CI{\"QUIT\", CO::READONLY | CO::FAST, 1, 0, 0, 0}.HFUNC(Quit)\n       << CI{\"MULTI\", CO::NOSCRIPT | CO::FAST | CO::LOADING, 1, 0, 0, 0}.HFUNC(Multi)\n+      << CI{\"WATCH\", CO::LOADING, -2, 1, -1, 1}.HFUNC(Watch)\n+      << CI{\"UNWATCH\", CO::LOADING, 1, 0, 0, 0}.HFUNC(Unwatch)\n       << CI{\"DISCARD\", CO::NOSCRIPT | CO::FAST | CO::LOADING, 1, 0, 0, 0}.MFUNC(Discard)\n       << CI{\"EVAL\", CO::NOSCRIPT | CO::VARIADIC_KEYS, -3, 3, 3, 1}.MFUNC(Eval).SetValidator(\n              &EvalValidator)\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex cff25ddfdc1f..ffaaebb45276 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -87,6 +87,9 @@ class Service : public facade::ServiceInterface {\n   static void Quit(CmdArgList args, ConnectionContext* cntx);\n   static void Multi(CmdArgList args, ConnectionContext* cntx);\n \n+  static void Watch(CmdArgList args, ConnectionContext* cntx);\n+  static void Unwatch(CmdArgList args, ConnectionContext* cntx);\n+\n   void Discard(CmdArgList args, ConnectionContext* cntx);\n   void Eval(CmdArgList args, ConnectionContext* cntx);\n   void EvalSha(CmdArgList args, ConnectionContext* cntx);\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex 52935cd0e011..cd98e2c10700 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -442,7 +442,7 @@ OpResult<uint32_t> OpAdd(const OpArgs& op_args, std::string_view key, ArgSlice v\n     res = AddStrSet(std::move(vals), &co);\n   }\n \n-  db_slice.PostUpdate(op_args.db_ind, it, !new_key);\n+  db_slice.PostUpdate(op_args.db_ind, it, key, !new_key);\n \n   return res;\n }\n@@ -460,7 +460,7 @@ OpResult<uint32_t> OpRem(const OpArgs& op_args, std::string_view key, const ArgS\n   CompactObj& co = find_res.value()->second;\n   auto [removed, isempty] = RemoveSet(vals, &co);\n \n-  db_slice.PostUpdate(op_args.db_ind, *find_res);\n+  db_slice.PostUpdate(op_args.db_ind, *find_res, key);\n \n   if (isempty) {\n     CHECK(db_slice.Del(op_args.db_ind, find_res.value()));\n@@ -1157,7 +1157,7 @@ OpResult<StringVec> SetFamily::OpPop(const OpArgs& op_args, std::string_view key\n     } else {\n       result = PopStrSet(count, st);\n     }\n-    db_slice.PostUpdate(op_args.db_ind, it);\n+    db_slice.PostUpdate(op_args.db_ind, it, key);\n   }\n   return result;\n }\ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex b2f999d804b8..45b348169c5a 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -100,7 +100,7 @@ OpResult<uint32_t> OpSetRange(const OpArgs& op_args, string_view key, size_t sta\n \n   memcpy(s.data() + start, value.data(), value.size());\n   it->second.SetString(s);\n-  db_slice.PostUpdate(op_args.db_ind, it, !added);\n+  db_slice.PostUpdate(op_args.db_ind, it, key, !added);\n   RecordJournal(op_args, it->first, it->second);\n \n   return it->second.Size();\n@@ -138,7 +138,7 @@ OpResult<string> OpGetRange(const OpArgs& op_args, string_view key, int32_t star\n   return string(slice.substr(start, end - start + 1));\n };\n \n-size_t ExtendExisting(const OpArgs& op_args, PrimeIterator it, string_view val, bool prepend) {\n+size_t ExtendExisting(const OpArgs& op_args, PrimeIterator it, string_view key, string_view val, bool prepend) {\n   string tmp, new_val;\n   auto* shard = op_args.shard;\n   string_view slice = GetSlice(shard, it->second, &tmp);\n@@ -150,7 +150,7 @@ size_t ExtendExisting(const OpArgs& op_args, PrimeIterator it, string_view val,\n   auto& db_slice = shard->db_slice();\n   db_slice.PreUpdate(op_args.db_ind, it);\n   it->second.SetString(new_val);\n-  db_slice.PostUpdate(op_args.db_ind, it, true);\n+  db_slice.PostUpdate(op_args.db_ind, it, key, true);\n   RecordJournal(op_args, it->first, it->second);\n \n   return new_val.size();\n@@ -164,7 +164,7 @@ OpResult<uint32_t> ExtendOrSet(const OpArgs& op_args, string_view key, string_vi\n   auto [it, inserted] = db_slice.AddOrFind(op_args.db_ind, key);\n   if (inserted) {\n     it->second.SetString(val);\n-    db_slice.PostUpdate(op_args.db_ind, it, false);\n+    db_slice.PostUpdate(op_args.db_ind, it, key, false);\n     RecordJournal(op_args, it->first, it->second);\n \n     return val.size();\n@@ -173,7 +173,7 @@ OpResult<uint32_t> ExtendOrSet(const OpArgs& op_args, string_view key, string_vi\n   if (it->second.ObjType() != OBJ_STRING)\n     return OpStatus::WRONG_TYPE;\n \n-  return ExtendExisting(op_args, it, val, prepend);\n+  return ExtendExisting(op_args, it, key, val, prepend);\n }\n \n OpResult<bool> ExtendOrSkip(const OpArgs& op_args, std::string_view key, std::string_view val,\n@@ -184,7 +184,7 @@ OpResult<bool> ExtendOrSkip(const OpArgs& op_args, std::string_view key, std::st\n     return false;\n   }\n \n-  return ExtendExisting(op_args, *it_res, val, prepend);\n+  return ExtendExisting(op_args, *it_res, key, val, prepend);\n }\n \n OpResult<string> OpGet(const OpArgs& op_args, string_view key) {\n@@ -206,7 +206,7 @@ OpResult<double> OpIncrFloat(const OpArgs& op_args, std::string_view key, double\n   if (inserted) {\n     char* str = RedisReplyBuilder::FormatDouble(val, buf, sizeof(buf));\n     it->second.SetString(str);\n-    db_slice.PostUpdate(op_args.db_ind, it, false);\n+    db_slice.PostUpdate(op_args.db_ind, it, key, false);\n     RecordJournal(op_args, it->first, it->second);\n \n     return val;\n@@ -238,7 +238,7 @@ OpResult<double> OpIncrFloat(const OpArgs& op_args, std::string_view key, double\n \n   db_slice.PreUpdate(op_args.db_ind, it);\n   it->second.SetString(str);\n-  db_slice.PostUpdate(op_args.db_ind, it, true);\n+  db_slice.PostUpdate(op_args.db_ind, it, key, true);\n   RecordJournal(op_args, it->first, it->second);\n \n   return base;\n@@ -290,7 +290,7 @@ OpResult<int64_t> OpIncrBy(const OpArgs& op_args, std::string_view key, int64_t\n   DCHECK(!it->second.IsExternal());\n   db_slice.PreUpdate(op_args.db_ind, it);\n   it->second.SetInt(new_val);\n-  db_slice.PostUpdate(op_args.db_ind, it);\n+  db_slice.PostUpdate(op_args.db_ind, it, key);\n   RecordJournal(op_args, it->first, it->second);\n \n   return new_val;\n@@ -330,7 +330,7 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n     // Make sure that we have this key, and only add it if it does exists\n     if (params.how == SET_IF_EXISTS) {\n       if (IsValid(it)) {\n-        return SetExisting(params, it, expire_it, value);\n+        return SetExisting(params, it, expire_it, key, value);\n       } else {\n         return OpStatus::SKIPPED;\n       }\n@@ -352,14 +352,14 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n \n   PrimeIterator it = get<0>(add_res);\n   if (!get<2>(add_res)) {  // Existing.\n-    return SetExisting(params, it, get<1>(add_res), value);\n+    return SetExisting(params, it, get<1>(add_res), key, value);\n   }\n   //\n   // Adding new value.\n   PrimeValue tvalue{value};\n   tvalue.SetFlag(params.memcache_flags != 0);\n   it->second = std::move(tvalue);\n-  db_slice.PostUpdate(params.db_index, it, false);\n+  db_slice.PostUpdate(params.db_index, it, key, false);\n \n   if (params.expire_after_ms) {\n     db_slice.UpdateExpire(params.db_index, it, params.expire_after_ms + db_slice.Now());\n@@ -381,7 +381,7 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n }\n \n OpStatus SetCmd::SetExisting(const SetParams& params, PrimeIterator it, ExpireIterator e_it,\n-                             string_view value) {\n+                             string_view key, string_view value) {\n   if (params.how == SET_IF_NOTEXIST)\n     return OpStatus::SKIPPED;\n \n@@ -429,7 +429,7 @@ OpStatus SetCmd::SetExisting(const SetParams& params, PrimeIterator it, ExpireIt\n     }\n   }\n \n-  db_slice.PostUpdate(params.db_index, it);\n+  db_slice.PostUpdate(params.db_index, it, key);\n   RecordJournal(op_args_, it->first, it->second);\n \n   return OpStatus::OK;\ndiff --git a/src/server/string_family.h b/src/server/string_family.h\nindex dbfc0b5fb3e1..6fc56629c61c 100644\n--- a/src/server/string_family.h\n+++ b/src/server/string_family.h\n@@ -46,7 +46,7 @@ class SetCmd {\n \n  private:\n   OpStatus SetExisting(const SetParams& params, PrimeIterator it, ExpireIterator e_it,\n-                       std::string_view value);\n+                       std::string_view key, std::string_view value);\n };\n \n class StringFamily {\ndiff --git a/src/server/table.h b/src/server/table.h\nindex 898a649d2c4b..d231f8649ca2 100644\n--- a/src/server/table.h\n+++ b/src/server/table.h\n@@ -11,6 +11,7 @@\n \n #include \"core/expire_period.h\"\n #include \"core/intent_lock.h\"\n+#include \"server/conn_context.h\"\n #include \"server/detail/table.h\"\n \n namespace dfly {\n@@ -64,6 +65,9 @@ struct DbTable : boost::intrusive_ref_counter<DbTable, boost::thread_unsafe_coun\n   // Contains transaction locks\n   LockTable trans_locks;\n \n+  // Stores a list of dependant connections for each watched key.\n+  absl::flat_hash_map<std::string, std::vector<ConnectionState::ExecInfo*>> watched_keys;\n+\n   mutable DbTableStats stats;\n   ExpireTable::Cursor expire_cursor;\n   PrimeTable::Cursor prime_cursor;\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 4e88f08eda48..58d549ab1da3 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -812,7 +812,7 @@ OpResult<AddResult> OpAdd(const OpArgs& op_args, const ZParams& zparams, string_\n   DVLOG(2) << \"ZAdd \" << zobj->ptr;\n \n   res_it.value()->second.SyncRObj();\n-  op_args.shard->db_slice().PostUpdate(op_args.db_ind, *res_it);\n+  op_args.shard->db_slice().PostUpdate(op_args.db_ind, *res_it, key);\n \n   if (zparams.flags & ZADD_IN_INCR) {\n     aresult.new_score = new_score;\n@@ -1627,7 +1627,7 @@ OpResult<unsigned> ZSetFamily::OpRem(const OpArgs& op_args, string_view key, Arg\n   }\n   auto zlen = zsetLength(zobj);\n   res_it.value()->second.SyncRObj();\n-  db_slice.PostUpdate(op_args.db_ind, *res_it);\n+  db_slice.PostUpdate(op_args.db_ind, *res_it, key);\n \n   if (zlen == 0) {\n     CHECK(op_args.shard->db_slice().Del(op_args.db_ind, res_it.value()));\n@@ -1681,7 +1681,7 @@ OpResult<unsigned> ZSetFamily::OpRemRange(const OpArgs& op_args, string_view key\n   std::visit(iv, range_spec.interval);\n \n   res_it.value()->second.SyncRObj();\n-  db_slice.PostUpdate(op_args.db_ind, *res_it);\n+  db_slice.PostUpdate(op_args.db_ind, *res_it, key);\n \n   auto zlen = zsetLength(zobj);\n   if (zlen == 0) {\n",
  "test_patch": "diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc\nindex 7caefa3a05b4..b766e085ba7a 100644\n--- a/src/server/dragonfly_test.cc\n+++ b/src/server/dragonfly_test.cc\n@@ -581,6 +581,92 @@ TEST_F(DflyEngineTest, PUnsubscribe) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"punsubscribe\", \"b*\", IntArg(0)));\n }\n \n+TEST_F(DflyEngineTest, Watch) {\n+  auto kExecFail = ArgType(RespExpr::NIL);\n+  auto kExecSuccess = ArgType(RespExpr::ARRAY);\n+\n+  // Check watch doesn't run in multi.\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"watch\", \"a\"}), ErrArg(\"WATCH inside MULTI is not allowed\"));\n+  Run({\"discard\"});\n+\n+  // Check watch on existing key.\n+  Run({\"set\", \"a\", \"1\"});\n+  EXPECT_EQ(Run({\"watch\", \"a\"}), \"OK\");\n+  Run({\"set\", \"a\", \"2\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check watch data cleared after EXEC.\n+  Run({\"set\", \"a\", \"1\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecSuccess);\n+\n+  // Check watch on non-existent key.\n+  Run({\"del\", \"b\"});\n+  EXPECT_EQ(Run({\"watch\", \"b\"}), \"OK\"); // didn't exist yet\n+  Run({\"set\", \"b\", \"1\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check EXEC doesn't miss watched key expiration.\n+  Run({\"watch\", \"a\"});\n+  Run({\"expire\", \"a\", \"1\"});\n+  UpdateTime(expire_now_ + 1000);\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check unwatch.\n+  Run({\"watch\", \"a\"});\n+  Run({\"unwatch\"});\n+  Run({\"set\", \"a\", \"3\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecSuccess);\n+\n+  // Check double expire\n+  Run({\"watch\", \"a\", \"b\"});\n+  Run({\"set\", \"a\", \"2\"});\n+  Run({\"set\", \"b\", \"2\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check EXPIRE + new key.\n+  Run({\"set\", \"a\", \"1\"});\n+  Run({\"del\", \"c\"});\n+  Run({\"watch\", \"c\"}); // didn't exist yet\n+  Run({\"watch\", \"a\"});\n+  Run({\"set\", \"c\", \"1\"});\n+  Run({\"expire\", \"a\", \"1\"}); // a existed\n+  UpdateTime(expire_now_ + 1000);\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check FLUSHDB touches watched keys\n+  Run({\"select\", \"1\"});\n+  Run({\"set\", \"a\", \"1\"});\n+  Run({\"watch\", \"a\"});\n+  Run({\"flushdb\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecFail);\n+\n+  // Check multi db watches are not supported.\n+  Run({\"select\", \"1\"});\n+  Run({\"set\", \"a\", \"1\"});\n+  Run({\"watch\", \"a\"});\n+  Run({\"select\", \"0\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), ArgType(RespExpr::ERROR));\n+\n+  // Check watch keys are isolated between databases.\n+  Run({\"set\", \"a\", \"1\"});\n+  Run({\"watch\", \"a\"});\n+  Run({\"select\", \"1\"});\n+  Run({\"set\", \"a\", \"2\"}); // changing a on db 1\n+  Run({\"select\", \"0\"});\n+  Run({\"multi\"});\n+  ASSERT_THAT(Run({\"exec\"}), kExecSuccess);\n+}\n+\n // TODO: to test transactions with a single shard since then all transactions become local.\n // To consider having a parameter in dragonfly engine controlling number of shards\n // unconditionally from number of cpus. TO TEST BLPOP under multi for single/multi argument case.\n",
  "problem_statement": "Add WATCH and UNWATCH commands\nPart of #91 task.\r\n\n",
  "hints_text": "",
  "created_at": "2022-09-09T19:06:13Z",
  "modified_files": [
    "src/server/conn_context.cc",
    "src/server/conn_context.h",
    "src/server/db_slice.cc",
    "src/server/db_slice.h",
    "src/server/generic_family.h",
    "src/server/hset_family.cc",
    "src/server/json_family.cc",
    "src/server/list_family.cc",
    "src/server/main_service.cc",
    "src/server/main_service.h",
    "src/server/set_family.cc",
    "src/server/string_family.cc",
    "src/server/string_family.h",
    "src/server/table.h",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/dragonfly_test.cc"
  ]
}