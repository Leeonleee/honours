diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc
index 2d7219f42f90..aa15589359f5 100644
--- a/src/server/dragonfly_test.cc
+++ b/src/server/dragonfly_test.cc
@@ -514,8 +514,8 @@ TEST_F(DflyEngineTest, PSubscribe) {
   ASSERT_EQ(1, SubscriberMessagesLen("IO1"));
 
   const auto& msg = GetPublishedMessage("IO1", 0);
-  EXPECT_EQ("foo", msg.Message());
-  EXPECT_EQ("ab", msg.Channel());
+  EXPECT_EQ("foo", msg.message);
+  EXPECT_EQ("ab", msg.channel);
   EXPECT_EQ("a*", msg.pattern);
 }
 
diff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py
index 9eaf81af20c7..cda6d6d32af4 100755
--- a/tests/dragonfly/connection_test.py
+++ b/tests/dragonfly/connection_test.py
@@ -410,6 +410,32 @@ async def subscribe_worker():
     await async_pool.disconnect()
 
 
+@dfly_args({"notify_keyspace_events": "Ex"})
+async def test_keyspace_events(async_client: aioredis.Redis):
+    pclient = async_client.pubsub()
+    await pclient.subscribe("__keyevent@0__:expired")
+
+    keys = []
+    for i in range(10, 50):
+        keys.append(f"k{i}")
+        await async_client.set(keys[-1], "X", px=200 + i * 10)
+
+    # We don't support immediate expiration:
+    # keys += ['immediate']
+    # await async_client.set(keys[-1], 'Y', exat=123) # expired 50 years ago
+
+    events = []
+    async for message in pclient.listen():
+        if message["type"] == "subscribe":
+            continue
+
+        events.append(message)
+        if len(events) >= len(keys):
+            break
+
+    assert set(ev["data"] for ev in events) == set(keys)
+
+
 async def test_big_command(df_server, size=8 * 1024):
     reader, writer = await asyncio.open_connection("127.0.0.1", df_server.port)
 
