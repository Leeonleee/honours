{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5075,
  "instance_id": "dragonflydb__dragonfly-5075",
  "issue_numbers": [
    "5055"
  ],
  "base_commit": "8b05854a06240079ecdb3db2b109239bb6e862a9",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex e20d1e0adb69..873545d8471b 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -54,34 +54,6 @@ using CI = CommandId;\n \n namespace {\n \n-class JsonMemTracker {\n- public:\n-  JsonMemTracker() {\n-    start_size_ = static_cast<MiMemoryResource*>(CompactObj::memory_resource())->used();\n-  }\n-\n-  void SetJsonSize(PrimeValue& pv, bool is_op_set) {\n-    const size_t current = static_cast<MiMemoryResource*>(CompactObj::memory_resource())->used();\n-    int64_t diff = static_cast<int64_t>(current) - static_cast<int64_t>(start_size_);\n-    // If the diff is 0 it means the object use the same memory as before. No action needed.\n-    if (diff == 0) {\n-      return;\n-    }\n-    // If op_set_ it means we JSON.SET or JSON.MSET was called. This is a blind update,\n-    // and because the operation sets the size to 0 we also need to include the size of\n-    // the pointer.\n-    if (is_op_set) {\n-      diff += static_cast<int64_t>(mi_usable_size(pv.GetJson()));\n-    }\n-    pv.SetJsonSize(diff);\n-    // Under any flow we must not end up with this special value.\n-    DCHECK(pv.MallocUsed() != 0);\n-  }\n-\n- private:\n-  size_t start_size_{0};\n-};\n-\n /* Helper class which must be initialized before any mutate operations on json.\n   It will track the memory usage of the json object and update the size in the CompactObj.\n   It also contains indexes updates, post update operations on the iterator. */\n@@ -107,6 +79,8 @@ class JsonAutoUpdater {\n   void SetJsonSize() {\n     set_size_was_called_ = true;\n \n+    ShrinkJsonIfNeeded();\n+\n     const size_t current = GetMemoryUsage();\n     int64_t diff = static_cast<int64_t>(current) - static_cast<int64_t>(start_size_);\n \n@@ -145,6 +119,16 @@ class JsonAutoUpdater {\n     return static_cast<MiMemoryResource*>(CompactObj::memory_resource())->used();\n   }\n \n+  /* Shrinks the json object to fit its current size.\n+     Sometimes after mutating the json object, it may have more capacity than needed.\n+     This method will reduce the capacity to fit the current size. */\n+  void ShrinkJsonIfNeeded() {\n+    auto json = GetJson();\n+    if (json->size() * 2 < json->capacity()) {\n+      json->shrink_to_fit();\n+    }\n+  }\n+\n  private:\n   const OpArgs& op_args_;\n   string_view key_;\n@@ -1060,29 +1044,24 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,\n     return 0;\n   }\n \n-  PrimeValue& pv = it_res->it->second;\n-  JsonType* json_val = pv.GetJson();\n-\n-  JsonMemTracker tracker;\n-  absl::Cleanup update_size_on_exit([tracker, &pv]() mutable { tracker.SetJsonSize(pv, false); });\n-\n   if (json_path.HoldsJsonPath()) {\n+    JsonAutoUpdater updater(op_args, key, *std::move(it_res), true);\n     const json::Path& path = json_path.AsJsonPath();\n     long deletions = json::MutatePath(\n-        path, [](optional<string_view>, JsonType* val) { return true; }, json_val);\n+        path, [](optional<string_view>, JsonType* val) { return true; }, updater.GetJson());\n     return deletions;\n   }\n \n+  // Allocates memory for the deletion_items.\n+  // So we need to initialize JsonAutoUpdater after this callback\n   vector<string> deletion_items;\n-  auto cb = [&](std::optional<std::string_view> path, JsonType* val) -> MutateCallbackResult<> {\n-    deletion_items.emplace_back(*path);\n+  auto cb = [&deletion_items](string_view path, const JsonType& val) -> Nothing {\n+    deletion_items.emplace_back(path);\n     return {};\n   };\n \n-  auto res = json_path.ExecuteMutateCallback<Nothing>(\n-      json_val, std::move(cb), CallbackResultOptions::DefaultMutateOptions());\n-  RETURN_ON_BAD_STATUS(res);\n-\n+  auto res = json_path.ExecuteReadOnlyCallback<Nothing>(\n+      it_res->it->second.GetJson(), cb, CallbackResultOptions::DefaultReadOnlyOptions());\n   if (deletion_items.empty()) {\n     return 0;\n   }\n@@ -1097,13 +1076,17 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,\n     patch.emplace_back(patch_item);\n   }\n \n+  JsonAutoUpdater updater(op_args, key, *std::move(it_res));\n+\n   std::error_code ec;\n-  jsoncons::jsonpatch::apply_patch(*json_val, patch, ec);\n+  jsoncons::jsonpatch::apply_patch(*updater.GetJson(), patch, ec);\n   if (ec) {\n     VLOG(1) << \"Failed to apply patch on json with error: \" << ec.message();\n     return 0;\n   }\n \n+  updater.SetJsonSize();\n+\n   // SetString(op_args, key, j.as_string());\n   return total_deletions;\n }\n",
  "test_patch": "diff --git a/src/server/json_family_memory_test.cc b/src/server/json_family_memory_test.cc\nindex e414a3fd9182..95e6d3ad2d0b 100644\n--- a/src/server/json_family_memory_test.cc\n+++ b/src/server/json_family_memory_test.cc\n@@ -105,4 +105,108 @@ TEST_F(JsonFamilyMemoryTest, PartialSet) {\n   EXPECT_THAT(resp, IntArg(start_size));\n }\n \n+/* Tests how works memory usage after deleting json object in jsoncons */\n+TEST_F(JsonFamilyMemoryTest, JsonConsDelTest) {\n+  std::string_view start_json = R\"({\"a\":\"some text\", \"b\":\" \"})\";\n+\n+  size_t start = GetMemoryUsage();\n+\n+  auto json = dfly::JsonFromString(start_json, JsonFamilyMemoryTest::GetMemoryResource());\n+  void* ptr =\n+      JsonFamilyMemoryTest::GetMemoryResource()->allocate(sizeof(JsonType), alignof(JsonType));\n+  JsonType* json_on_heap = new (ptr) JsonType(std::move(json).value());\n+\n+  size_t memory_usage_before_erase = GetMemoryUsage() - start;\n+\n+  json_on_heap->erase(\"a\");\n+  /* To deallocate memory we should use shrink_to_fit */\n+  json_on_heap->shrink_to_fit();\n+\n+  size_t memory_usage_after_erase = GetMemoryUsage() - start;\n+\n+  EXPECT_GT(memory_usage_before_erase, memory_usage_after_erase);\n+  EXPECT_EQ(memory_usage_after_erase, GetJsonMemoryUsageFromString(R\"({\"b\":\" \"})\"));\n+}\n+\n+TEST_F(JsonFamilyMemoryTest, SimpleDel) {\n+  std::string_view start_json = R\"({\"a\":\"some text\", \"b\":\" \"})\";\n+  size_t start_size = GetJsonMemoryUsageFromString(start_json);\n+\n+  auto resp = Run({\"JSON.SET\", \"j1\", \"$\", start_json});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+  EXPECT_THAT(resp, IntArg(start_size));\n+\n+  std::string_view json_after_del = R\"({\"b\":\" \"})\";\n+  size_t size_after_del = GetJsonMemoryUsageFromString(json_after_del);\n+\n+  // Test that raw memory usage is correct\n+  resp = Run({\"JSON.SET\", \"j2\", \"$\", json_after_del});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = GetJsonMemoryUsageFromDb(\"j2\");\n+  EXPECT_THAT(resp, IntArg(size_after_del));\n+\n+  // Test that after deletion memory usage is correct\n+  resp = Run({\"JSON.DEL\", \"j1\", \"$.a\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"JSON.GET\", \"j1\"});\n+  EXPECT_EQ(resp, json_after_del);\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+\n+  /* We still expect the initial size here, because after deletion we do not call shrink_to_fit on\n+     the JSON object. As a result, the memory will not be deallocated. Check\n+     JsonFamilyMemoryTest::JsonConsDelTest for example. */\n+  EXPECT_THAT(resp, IntArg(start_size));\n+\n+  // Again set start json\n+  resp = Run({\"JSON.SET\", \"j1\", \"$.a\", \"\\\"some text\\\"\"});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+  EXPECT_THAT(resp, IntArg(start_size));\n+}\n+\n+TEST_F(JsonFamilyMemoryTest, JsonShrinking) {\n+  std::string_view start_json = R\"({\"a\":\"some text\",\"b\":\"some another text\",\"c\":\" \"})\";\n+  size_t start_size = GetJsonMemoryUsageFromString(start_json);\n+\n+  auto resp = Run({\"JSON.SET\", \"j1\", \"$\", start_json});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+  EXPECT_THAT(resp, IntArg(start_size));\n+\n+  std::string_view json_after_del = R\"({\"c\":\" \"})\";\n+  size_t size_after_del = GetJsonMemoryUsageFromString(json_after_del);\n+\n+  // Test that raw memory usage is correct\n+  resp = Run({\"JSON.SET\", \"j2\", \"$\", json_after_del});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = GetJsonMemoryUsageFromDb(\"j2\");\n+  EXPECT_THAT(resp, IntArg(size_after_del));\n+\n+  // Test that after deletion memory usage decreases\n+  resp = Run({\"JSON.DEL\", \"j1\", \"$.a\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"JSON.DEL\", \"j1\", \"$.b\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"JSON.GET\", \"j1\"});\n+  EXPECT_EQ(resp, json_after_del);\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+  // Now we expect the size to be smaller, because shrink_to_fit was called\n+  EXPECT_THAT(resp, IntArg(size_after_del));\n+\n+  // Again set start json\n+  resp = Run({\"JSON.SET\", \"j1\", \"$.a\", \"\\\"some text\\\"\"});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.SET\", \"j1\", \"$.b\", \"\\\"some another text\\\"\"});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.GET\", \"j1\"});\n+  EXPECT_EQ(resp, start_json);\n+  resp = GetJsonMemoryUsageFromDb(\"j1\");\n+\n+  // Jsoncons will allocate more memory for the new json that needed.\n+  // This is totally fine, because we will not call shrink_to_fit.\n+  EXPECT_THAT(resp, IntArg(368));\n+  EXPECT_GT(368, start_size);\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex c0b09780070c..642d0a44e2c5 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -2801,4 +2801,19 @@ TEST_F(SearchFamilyTest, IgnoredOptionsInFtCreate) {\n   resp = Run({\"FT.SEARCH\", \"idx\", \"*\"});\n   EXPECT_THAT(resp, AreDocIds(\"doc:1\"));\n }\n+\n+TEST_F(SearchFamilyTest, JsonDelIndexesBug) {\n+  auto resp = Run({\"JSON.SET\", \"j1\", \"$\", R\"({\"text\":\"some text\"})\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run(\n+      {\"FT.CREATE\", \"index\", \"ON\", \"json\", \"SCHEMA\", \"$.text\", \"AS\", \"text\", \"TEXT\", \"SORTABLE\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"j1\", \"$.text\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"GROUPBY\", \"1\", \"@text\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"text\", ArgType(RespExpr::NIL))));\n+}\n }  // namespace dfly\n",
  "problem_statement": "JSON value is not updated in the indexes after the JSON.DEL command\nThe JSON value is not updated in the indexes after the `JSON.DEL` command.\n\nDragonflyDb:\n```\n127.0.0.1:6379> json.set j1 $ '{\"text\":\"some text\"}'                                                                                                                                                        \nOK\n127.0.0.1:6379> ft.create index on json schema $.text AS text TEXT SORTABLE\nOK                                                                                                                                                                                                       \n127.0.0.1:6379> json.del j1 $.text                                                                                                                                                                          \n(integer) 1                                                                                                                                                                                                 \n127.0.0.1:6379> ft.aggregate index \"*\" GROUPBY 1 @text SORTBY 1 @text                                                                                                                                       \n1) (integer) 1                                                                                                                                                                                              \n2) 1) \"text\"                                                                                                                                                                                                \n   2) \"some text\"\n```\n\nExpected behavior from Redis:\n```\n127.0.0.1:6379> json.set j1 $ '{\"text\":\"some text\"}'\nOK\n127.0.0.1:6379> ft.create index on json schema $.text AS text TEXT SORTABLE\nOK\n127.0.0.1:6379> json.del j1 $.text\n(integer) 1\n127.0.0.1:6379> ft.aggregate index \"*\" GROUPBY 1 @text\n1) (integer) 1\n2) 1) \"text\"\n   2) (nil)\n```\n",
  "hints_text": "",
  "created_at": "2025-05-06T15:35:42Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_memory_test.cc",
    "src/server/search/search_family_test.cc"
  ]
}