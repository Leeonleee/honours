{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 753,
  "instance_id": "dragonflydb__dragonfly-753",
  "issue_numbers": [
    "751"
  ],
  "base_commit": "d30ebc5b0d2fec556b527b7916b1c0b039ae0696",
  "patch": "diff --git a/docs/api_status.md b/docs/api_status.md\nindex 4f40f0fb0958..5de962ee385d 100644\n--- a/docs/api_status.md\n+++ b/docs/api_status.md\n@@ -111,7 +111,7 @@ with respect to Memcached and Redis APIs.\n - [X] List Family\n   - [X] BLPOP\n   - [X] BRPOP\n-  - [ ] BRPOPLPUSH\n+  - [X] BRPOPLPUSH\n   - [X] LINSERT\n   - [X] LPUSHX\n   - [X] RPUSHX\n@@ -250,12 +250,13 @@ with respect to Memcached and Redis APIs.\n - [X] List Family\n   - [X] LMOVE\n   - [X] LPOS\n+  - [X] BLMOVE\n \n - [ ] Stream Family\n   - [ ] XAUTOCLAIM\n \n-- [ ] Sorted Set Family\n-  - [ ] ZUNION\n+- [X] Sorted Set Family\n+  - [X] ZUNION\n \n ## Notes\n Some commands were implemented as decorators along the way:\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 5332b7d543b6..e5ff2c8d8d57 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -97,6 +97,27 @@ string ListPop(ListDir dir, quicklist* ql) {\n   return res;\n }\n \n+optional<ListDir> ParseDir(string_view arg) {\n+  if (arg == \"LEFT\") {\n+    return ListDir::LEFT;\n+  }\n+  if (arg == \"RIGHT\") {\n+    return ListDir::RIGHT;\n+  }\n+\n+  return nullopt;\n+}\n+\n+string_view DirToSv(ListDir dir) {\n+  switch (dir) {\n+    case ListDir::LEFT:\n+      return \"LEFT\"sv;\n+    case ListDir::RIGHT:\n+      return \"RIGHT\"sv;\n+  }\n+  return \"\"sv;\n+}\n+\n bool ElemCompare(const quicklistEntry& entry, string_view elem) {\n   if (entry.value) {\n     return entry.sz == elem.size() &&\n@@ -867,6 +888,47 @@ void BRPopLPush(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void BLMove(CmdArgList args, ConnectionContext* cntx) {\n+  string_view src = ArgS(args, 1);\n+  string_view dest = ArgS(args, 2);\n+  string_view timeout_str = ArgS(args, 5);\n+\n+  float timeout;\n+  if (!absl::SimpleAtof(timeout_str, &timeout)) {\n+    return (*cntx)->SendError(\"timeout is not a float or out of range\");\n+  }\n+\n+  if (timeout < 0) {\n+    return (*cntx)->SendError(\"timeout is negative\");\n+  }\n+\n+  ToUpper(&args[3]);\n+  ToUpper(&args[4]);\n+\n+  optional<ListDir> src_dir = ParseDir(ArgS(args, 3));\n+  optional<ListDir> dest_dir = ParseDir(ArgS(args, 4));\n+  if (!src_dir || !dest_dir) {\n+    return (*cntx)->SendError(kSyntaxErr);\n+  }\n+\n+  BPopPusher bpop_pusher(src, dest, *src_dir, *dest_dir);\n+  OpResult<string> op_res = bpop_pusher.Run(cntx->transaction, unsigned(timeout * 1000));\n+\n+  if (op_res) {\n+    return (*cntx)->SendBulkString(*op_res);\n+  }\n+\n+  switch (op_res.status()) {\n+    case OpStatus::TIMED_OUT:\n+      return (*cntx)->SendNull();\n+      break;\n+\n+    default:\n+      return (*cntx)->SendError(op_res.status());\n+      break;\n+  }\n+}\n+\n BPopPusher::BPopPusher(string_view pop_key, string_view push_key, ListDir popdir, ListDir pushdir)\n     : pop_key_(pop_key), push_key_(push_key), popdir_(popdir), pushdir_(pushdir) {\n }\n@@ -890,10 +952,9 @@ OpResult<string> BPopPusher::RunSingle(Transaction* t, time_point tp) {\n   auto cb_move = [&](Transaction* t, EngineShard* shard) {\n     OpArgs op_args = t->GetOpArgs(shard);\n     op_res = OpMoveSingleShard(op_args, pop_key_, push_key_, popdir_, pushdir_);\n-    if (op_res) {\n-      if (op_args.shard->journal()) {\n-        RecordJournal(op_args, \"RPOPLPUSH\", ArgSlice{pop_key_, push_key_}, 1);\n-      }\n+    if (op_res && op_args.shard->journal()) {\n+      ArgSlice args{pop_key_, push_key_, DirToSv(popdir_), DirToSv(pushdir_)};\n+      RecordJournal(op_args, \"LMOVE\", args, 1);\n     }\n     return OpStatus::OK;\n   };\n@@ -1207,24 +1268,13 @@ void ListFamily::LMove(CmdArgList args, ConnectionContext* cntx) {\n   ToUpper(&args[3]);\n   ToUpper(&args[4]);\n \n-  ListDir src_dir;\n-  ListDir dest_dir;\n-  if (src_dir_str == \"LEFT\") {\n-    src_dir = ListDir::LEFT;\n-  } else if (src_dir_str == \"RIGHT\") {\n-    src_dir = ListDir::RIGHT;\n-  } else {\n-    return (*cntx)->SendError(kSyntaxErr);\n-  }\n-  if (dest_dir_str == \"LEFT\") {\n-    dest_dir = ListDir::LEFT;\n-  } else if (dest_dir_str == \"RIGHT\") {\n-    dest_dir = ListDir::RIGHT;\n-  } else {\n+  optional<ListDir> src_dir = ParseDir(src_dir_str);\n+  optional<ListDir> dest_dir = ParseDir(dest_dir_str);\n+  if (!src_dir || !dest_dir) {\n     return (*cntx)->SendError(kSyntaxErr);\n   }\n \n-  MoveGeneric(cntx, src, dest, src_dir, dest_dir);\n+  MoveGeneric(cntx, src, dest, *src_dir, *dest_dir);\n }\n \n void ListFamily::BPopGeneric(ListDir dir, CmdArgList args, ConnectionContext* cntx) {\n@@ -1364,7 +1414,9 @@ void ListFamily::Register(CommandRegistry* registry) {\n       << CI{\"LSET\", CO::WRITE | CO::DENYOOM, 4, 1, 1, 1}.HFUNC(LSet)\n       << CI{\"LTRIM\", CO::WRITE, 4, 1, 1, 1}.HFUNC(LTrim)\n       << CI{\"LREM\", CO::WRITE, 4, 1, 1, 1}.HFUNC(LRem)\n-      << CI{\"LMOVE\", CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL, 5, 1, 2, 1}.HFUNC(LMove);\n+      << CI{\"LMOVE\", CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL, 5, 1, 2, 1}.HFUNC(LMove)\n+      << CI{\"BLMOVE\", CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL | CO::BLOCKING, 6, 1, 2, 1}\n+             .SetHandler(BLMove);\n }\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex e643abeb082b..c7827dd60d9a 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -759,4 +759,17 @@ TEST_F(ListFamilyTest, BRPopLPushTwoShards) {\n   // the atomicity and causes the first bug as well.\n }\n \n+TEST_F(ListFamilyTest, BLMove) {\n+  EXPECT_THAT(Run({\"blmove\", \"x\", \"y\", \"right\", \"right\", \"0.05\"}), ArgType(RespExpr::NIL));\n+  ASSERT_EQ(0, NumWatched());\n+\n+  EXPECT_THAT(Run({\"lpush\", \"x\", \"val1\"}), IntArg(1));\n+  EXPECT_THAT(Run({\"lpush\", \"y\", \"val2\"}), IntArg(1));\n+\n+  EXPECT_EQ(Run({\"blmove\", \"x\", \"y\", \"right\", \"left\", \"0.01\"}), \"val1\");\n+  auto resp = Run({\"lrange\", \"y\", \"0\", \"-1\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"val1\", \"val2\"));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "BLMOVE as a successor of BRPOPLPUSH\nBRPOPLPUSH is deprecated in Redis in favor of BLMOVE\r\n\r\nWill you implement BLMOVE?\n",
  "hints_text": "I will.",
  "created_at": "2023-02-05T06:29:48Z",
  "modified_files": [
    "docs/api_status.md",
    "src/server/list_family.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}