{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3144,
  "instance_id": "dragonflydb__dragonfly-3144",
  "issue_numbers": [
    "3141"
  ],
  "base_commit": "66a524a026938b0b66042a1595bd777b096f9127",
  "patch": "diff --git a/src/core/search/indices.cc b/src/core/search/indices.cc\nindex 37d46dc82afe..13d28048431b 100644\n--- a/src/core/search/indices.cc\n+++ b/src/core/search/indices.cc\n@@ -34,6 +34,10 @@ bool IsAllAscii(string_view sv) {\n   return all_of(sv.begin(), sv.end(), [](unsigned char c) { return isascii(c); });\n }\n \n+string ToLower(string_view word) {\n+  return IsAllAscii(word) ? absl::AsciiStrToLower(word) : una::cases::to_lowercase_utf8(word);\n+}\n+\n // Get all words from text as matched by the ICU library\n absl::flat_hash_set<std::string> TokenizeWords(std::string_view text) {\n   absl::flat_hash_set<std::string> words;\n@@ -43,12 +47,17 @@ absl::flat_hash_set<std::string> TokenizeWords(std::string_view text) {\n }\n \n // Split taglist, remove duplicates and convert all to lowercase\n-absl::flat_hash_set<string> NormalizeTags(string_view taglist) {\n+// TODO: introduce unicode support if needed\n+absl::flat_hash_set<string> NormalizeTags(string_view taglist, bool case_sensitive,\n+                                          char separator) {\n+  LOG_IF(WARNING, !IsAllAscii(taglist)) << \"Non ascii tag usage\";\n+\n   string tmp;\n   absl::flat_hash_set<string> tags;\n-  for (string_view tag : absl::StrSplit(taglist, ',')) {\n+  for (string_view tag : absl::StrSplit(taglist, separator, absl::SkipEmpty())) {\n     tmp = absl::StripAsciiWhitespace(tag);\n-    absl::AsciiStrToLower(&tmp);\n+    if (!case_sensitive)\n+      absl::AsciiStrToLower(&tmp);\n     tags.insert(std::move(tmp));\n   }\n   return tags;\n@@ -89,20 +98,21 @@ vector<DocId> NumericIndex::Range(double l, double r) const {\n }\n \n template <typename C>\n-BaseStringIndex<C>::BaseStringIndex(PMR_NS::memory_resource* mr) : entries_{mr} {\n+BaseStringIndex<C>::BaseStringIndex(PMR_NS::memory_resource* mr, bool case_sensitive)\n+    : case_sensitive_{case_sensitive}, entries_{mr} {\n }\n \n template <typename C>\n const typename BaseStringIndex<C>::Container* BaseStringIndex<C>::Matching(string_view str) const {\n   str = absl::StripAsciiWhitespace(str);\n \n-  string word;\n-  if (IsAllAscii(str))\n-    word = absl::AsciiStrToLower(str);\n-  else\n-    word = una::cases::to_lowercase_utf8(str);\n+  string tmp;\n+  if (!case_sensitive_) {\n+    tmp = ToLower(str);\n+    str = tmp;\n+  }\n \n-  auto it = entries_.find(word);\n+  auto it = entries_.find(str);\n   return (it != entries_.end()) ? &it->second : nullptr;\n }\n \n@@ -147,7 +157,7 @@ absl::flat_hash_set<std::string> TextIndex::Tokenize(std::string_view value) con\n }\n \n absl::flat_hash_set<std::string> TagIndex::Tokenize(std::string_view value) const {\n-  return NormalizeTags(value);\n+  return NormalizeTags(value, case_sensitive_, separator_);\n }\n \n BaseVectorIndex::BaseVectorIndex(size_t dim, VectorSimilarity sim) : dim_{dim}, sim_{sim} {\ndiff --git a/src/core/search/indices.h b/src/core/search/indices.h\nindex a1d02fe1b497..4d20333460ba 100644\n--- a/src/core/search/indices.h\n+++ b/src/core/search/indices.h\n@@ -40,7 +40,7 @@ struct NumericIndex : public BaseIndex {\n template <typename C> struct BaseStringIndex : public BaseIndex {\n   using Container = BlockList<C>;\n \n-  BaseStringIndex(PMR_NS::memory_resource* mr);\n+  BaseStringIndex(PMR_NS::memory_resource* mr, bool case_sensitive);\n \n   void Add(DocId id, DocumentAccessor* doc, std::string_view field) override;\n   void Remove(DocId id, DocumentAccessor* doc, std::string_view field) override;\n@@ -74,6 +74,8 @@ template <typename C> struct BaseStringIndex : public BaseIndex {\n     }\n   };\n \n+  bool case_sensitive_ = false;\n+\n   absl::flat_hash_map<PMR_NS::string, Container, PmrHash, PmrEqual,\n                       PMR_NS::polymorphic_allocator<std::pair<PMR_NS::string, Container>>>\n       entries_;\n@@ -82,7 +84,7 @@ template <typename C> struct BaseStringIndex : public BaseIndex {\n // Index for text fields.\n // Hashmap based lookup per word.\n struct TextIndex : public BaseStringIndex<CompressedSortedSet> {\n-  TextIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr) {\n+  TextIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr, false) {\n   }\n \n   absl::flat_hash_set<std::string> Tokenize(std::string_view value) const override;\n@@ -91,10 +93,14 @@ struct TextIndex : public BaseStringIndex<CompressedSortedSet> {\n // Index for text fields.\n // Hashmap based lookup per word.\n struct TagIndex : public BaseStringIndex<SortedVector> {\n-  TagIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr) {\n+  TagIndex(PMR_NS::memory_resource* mr, SchemaField::TagParams params)\n+      : BaseStringIndex(mr, params.case_sensitive), separator_{params.separator} {\n   }\n \n   absl::flat_hash_set<std::string> Tokenize(std::string_view value) const override;\n+\n+ private:\n+  char separator_;\n };\n \n struct BaseVectorIndex : public BaseIndex {\ndiff --git a/src/core/search/search.cc b/src/core/search/search.cc\nindex 05bb204c2b58..525a06dce8a1 100644\n--- a/src/core/search/search.cc\n+++ b/src/core/search/search.cc\n@@ -465,16 +465,18 @@ void FieldIndices::CreateIndices(PMR_NS::memory_resource* mr) {\n       continue;\n \n     switch (field_info.type) {\n-      case SchemaField::TAG:\n-        indices_[field_ident] = make_unique<TagIndex>(mr);\n-        break;\n       case SchemaField::TEXT:\n         indices_[field_ident] = make_unique<TextIndex>(mr);\n         break;\n       case SchemaField::NUMERIC:\n         indices_[field_ident] = make_unique<NumericIndex>(mr);\n         break;\n-      case SchemaField::VECTOR:\n+      case SchemaField::TAG: {\n+        const auto& tparams = std::get<SchemaField::TagParams>(field_info.special_params);\n+        indices_[field_ident] = make_unique<TagIndex>(mr, tparams);\n+        break;\n+      }\n+      case SchemaField::VECTOR: {\n         unique_ptr<BaseVectorIndex> vector_index;\n \n         DCHECK(holds_alternative<SchemaField::VectorParams>(field_info.special_params));\n@@ -487,6 +489,7 @@ void FieldIndices::CreateIndices(PMR_NS::memory_resource* mr) {\n \n         indices_[field_ident] = std::move(vector_index);\n         break;\n+      }\n     }\n   }\n }\ndiff --git a/src/core/search/search.h b/src/core/search/search.h\nindex 3202e0e9c86b..4a84831eb915 100644\n--- a/src/core/search/search.h\n+++ b/src/core/search/search.h\n@@ -36,7 +36,12 @@ struct SchemaField {\n     size_t hnsw_m = 16;\n   };\n \n-  using ParamsVariant = std::variant<std::monostate, VectorParams>;\n+  struct TagParams {\n+    char separator = ',';\n+    bool case_sensitive = false;\n+  };\n+\n+  using ParamsVariant = std::variant<std::monostate, VectorParams, TagParams>;\n \n   FieldType type;\n   uint8_t flags;\ndiff --git a/src/server/search/doc_index.cc b/src/server/search/doc_index.cc\nindex b277b53feed1..ff34a4ce6101 100644\n--- a/src/server/search/doc_index.cc\n+++ b/src/server/search/doc_index.cc\n@@ -111,6 +111,11 @@ string DocIndexInfo::BuildRestoreCommand() const {\n           absl::StrAppend(out, \" \", params.use_hnsw ? \"HNSW\" : \"FLAT\", \" 6 \", \"DIM \", params.dim,\n                           \" DISTANCE_METRIC \", sim, \" INITIAL_CAP \", params.capacity);\n         },\n+        [out = &out](const search::SchemaField::TagParams& params) {\n+          absl::StrAppend(out, \" \", \"SEPARATOR\", \" \", string{params.separator});\n+          if (params.case_sensitive)\n+            absl::StrAppend(out, \" \", \"CASESENSITIVE\");\n+        },\n     };\n     visit(info, finfo.special_params);\n   }\ndiff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 7b190c10458d..e14627cad32f 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -80,6 +80,32 @@ search::SchemaField::VectorParams ParseVectorParams(CmdArgParser* parser) {\n   return params;\n }\n \n+search::SchemaField::TagParams ParseTagParams(CmdArgParser* parser) {\n+  search::SchemaField::TagParams params{};\n+  while (parser->HasNext()) {\n+    if (parser->Check(\"SEPARATOR\").IgnoreCase().ExpectTail(1)) {\n+      string_view separator = parser->Next();\n+      params.separator = separator.front();\n+      continue;\n+    }\n+\n+    if (parser->Check(\"CASESENSITIVE\").IgnoreCase()) {\n+      params.case_sensitive = true;\n+      continue;\n+    }\n+\n+    break;\n+  }\n+\n+  return params;\n+}\n+\n+// breaks on ParamsVariant initialization\n+#ifndef __clang__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+#endif\n+\n optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParser parser,\n                                             ConnectionContext* cntx) {\n   search::Schema schema;\n@@ -108,15 +134,18 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse\n       return nullopt;\n     }\n \n+    // Tag fields include: [separator char] [casesensitive]\n     // Vector fields include: {algorithm} num_args args...\n-    search::SchemaField::ParamsVariant params = std::monostate{};\n-    if (*type == search::SchemaField::VECTOR) {\n+    search::SchemaField::ParamsVariant params(monostate{});\n+    if (*type == search::SchemaField::TAG) {\n+      params = ParseTagParams(&parser);\n+    } else if (*type == search::SchemaField::VECTOR) {\n       auto vector_params = ParseVectorParams(&parser);\n       if (!parser.HasError() && vector_params.dim == 0) {\n         cntx->SendError(\"Knn vector dimension cannot be zero\");\n         return nullopt;\n       }\n-      params = std::move(vector_params);\n+      params = vector_params;\n     }\n \n     // Flags: check for SORTABLE and NOINDEX\n@@ -154,6 +183,10 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse\n   return schema;\n }\n \n+#ifndef __clang__\n+#pragma GCC diagnostic pop\n+#endif\n+\n search::QueryParams ParseQueryParams(CmdArgParser* parser) {\n   search::QueryParams params;\n   size_t num_args = parser->Next<size_t>();\n",
  "test_patch": "diff --git a/src/core/search/search_test.cc b/src/core/search/search_test.cc\nindex b903027a6c49..19fd62a48103 100644\n--- a/src/core/search/search_test.cc\n+++ b/src/core/search/search_test.cc\n@@ -70,6 +70,8 @@ Schema MakeSimpleSchema(initializer_list<pair<string_view, SchemaField::FieldTyp\n   Schema schema;\n   for (auto [name, type] : ilist) {\n     schema.fields[name] = {type, 0, string{name}};\n+    if (type == SchemaField::TAG)\n+      schema.fields[name].special_params = SchemaField::TagParams{};\n   }\n   return schema;\n }\ndiff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex 31a750905f5f..17f5469e181f 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -307,6 +307,21 @@ TEST_F(SearchFamilyTest, Tags) {\n               AreDocIds(\"d:1\", \"d:2\", \"d:3\", \"d:5\", \"d:6\"));\n }\n \n+TEST_F(SearchFamilyTest, TagOptions) {\n+  Run({\"hset\", \"d:1\", \"color\", \"    red/   green // bLUe   \"});\n+  Run({\"hset\", \"d:2\", \"color\", \"blue   /// GReeN   \"});\n+  Run({\"hset\", \"d:3\", \"color\", \"grEEn // yellow   //\"});\n+  Run({\"hset\", \"d:4\", \"color\", \"  /blue/green/  \"});\n+\n+  EXPECT_EQ(Run({\"ft.create\", \"i1\", \"on\", \"hash\", \"schema\", \"color\", \"tag\", \"casesensitive\",\n+                 \"separator\", \"/\"}),\n+            \"OK\");\n+\n+  EXPECT_THAT(Run({\"ft.search\", \"i1\", \"@color:{green}\"}), AreDocIds(\"d:1\", \"d:4\"));\n+  EXPECT_THAT(Run({\"ft.search\", \"i1\", \"@color:{GReeN}\"}), AreDocIds(\"d:2\"));\n+  EXPECT_THAT(Run({\"ft.search\", \"i1\", \"@color:{blue}\"}), AreDocIds(\"d:2\", \"d:4\"));\n+}\n+\n TEST_F(SearchFamilyTest, Numbers) {\n   for (unsigned i = 0; i <= 10; i++) {\n     for (unsigned j = 0; j <= 10; j++) {\ndiff --git a/tests/dragonfly/search_test.py b/tests/dragonfly/search_test.py\nindex a65c31ab8664..9d08e0f8582e 100644\n--- a/tests/dragonfly/search_test.py\n+++ b/tests/dragonfly/search_test.py\n@@ -378,7 +378,7 @@ async def test_index_persistence(df_server):\n     SCHEMA_2 = [\n         TextField(\"name\"),\n         NumericField(\"age\", sortable=True),\n-        TagField(\"job\"),\n+        TagField(\"job\", separator=\":\", case_sensitive=True),\n         VectorField(\n             \"pos\",\n             algorithm=\"HNSW\",\n@@ -461,6 +461,7 @@ def build_fields_set(info):\n \n     assert (await i2.search(\"@job:{writer}\")).total == 100\n     assert (await i2.search(\"@job:{writer} @age:[100 200]\")).total == 50\n+    assert (await i2.search(\"@job:{wRiTeR}\")).total == 0\n \n     # Check fields are sortable\n     assert (await i1.search(Query(\"*\").sort_by(\"views\", asc=True).paging(0, 1))).docs[0][\n",
  "problem_statement": "Search: Custom delimiter for tags\nAdd option to change tag delimiter `TAG [SEPARATOR {sep}] [CASESENSITIVE]`\n",
  "hints_text": "",
  "created_at": "2024-06-06T12:11:39Z",
  "modified_files": [
    "src/core/search/indices.cc",
    "src/core/search/indices.h",
    "src/core/search/search.cc",
    "src/core/search/search.h",
    "src/server/search/doc_index.cc",
    "src/server/search/search_family.cc"
  ],
  "modified_test_files": [
    "src/core/search/search_test.cc",
    "src/server/search/search_family_test.cc",
    "tests/dragonfly/search_test.py"
  ]
}