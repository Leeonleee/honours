diff --git a/src/core/search/indices.cc b/src/core/search/indices.cc
index 37d46dc82afe..13d28048431b 100644
--- a/src/core/search/indices.cc
+++ b/src/core/search/indices.cc
@@ -34,6 +34,10 @@ bool IsAllAscii(string_view sv) {
   return all_of(sv.begin(), sv.end(), [](unsigned char c) { return isascii(c); });
 }
 
+string ToLower(string_view word) {
+  return IsAllAscii(word) ? absl::AsciiStrToLower(word) : una::cases::to_lowercase_utf8(word);
+}
+
 // Get all words from text as matched by the ICU library
 absl::flat_hash_set<std::string> TokenizeWords(std::string_view text) {
   absl::flat_hash_set<std::string> words;
@@ -43,12 +47,17 @@ absl::flat_hash_set<std::string> TokenizeWords(std::string_view text) {
 }
 
 // Split taglist, remove duplicates and convert all to lowercase
-absl::flat_hash_set<string> NormalizeTags(string_view taglist) {
+// TODO: introduce unicode support if needed
+absl::flat_hash_set<string> NormalizeTags(string_view taglist, bool case_sensitive,
+                                          char separator) {
+  LOG_IF(WARNING, !IsAllAscii(taglist)) << "Non ascii tag usage";
+
   string tmp;
   absl::flat_hash_set<string> tags;
-  for (string_view tag : absl::StrSplit(taglist, ',')) {
+  for (string_view tag : absl::StrSplit(taglist, separator, absl::SkipEmpty())) {
     tmp = absl::StripAsciiWhitespace(tag);
-    absl::AsciiStrToLower(&tmp);
+    if (!case_sensitive)
+      absl::AsciiStrToLower(&tmp);
     tags.insert(std::move(tmp));
   }
   return tags;
@@ -89,20 +98,21 @@ vector<DocId> NumericIndex::Range(double l, double r) const {
 }
 
 template <typename C>
-BaseStringIndex<C>::BaseStringIndex(PMR_NS::memory_resource* mr) : entries_{mr} {
+BaseStringIndex<C>::BaseStringIndex(PMR_NS::memory_resource* mr, bool case_sensitive)
+    : case_sensitive_{case_sensitive}, entries_{mr} {
 }
 
 template <typename C>
 const typename BaseStringIndex<C>::Container* BaseStringIndex<C>::Matching(string_view str) const {
   str = absl::StripAsciiWhitespace(str);
 
-  string word;
-  if (IsAllAscii(str))
-    word = absl::AsciiStrToLower(str);
-  else
-    word = una::cases::to_lowercase_utf8(str);
+  string tmp;
+  if (!case_sensitive_) {
+    tmp = ToLower(str);
+    str = tmp;
+  }
 
-  auto it = entries_.find(word);
+  auto it = entries_.find(str);
   return (it != entries_.end()) ? &it->second : nullptr;
 }
 
@@ -147,7 +157,7 @@ absl::flat_hash_set<std::string> TextIndex::Tokenize(std::string_view value) con
 }
 
 absl::flat_hash_set<std::string> TagIndex::Tokenize(std::string_view value) const {
-  return NormalizeTags(value);
+  return NormalizeTags(value, case_sensitive_, separator_);
 }
 
 BaseVectorIndex::BaseVectorIndex(size_t dim, VectorSimilarity sim) : dim_{dim}, sim_{sim} {
diff --git a/src/core/search/indices.h b/src/core/search/indices.h
index a1d02fe1b497..4d20333460ba 100644
--- a/src/core/search/indices.h
+++ b/src/core/search/indices.h
@@ -40,7 +40,7 @@ struct NumericIndex : public BaseIndex {
 template <typename C> struct BaseStringIndex : public BaseIndex {
   using Container = BlockList<C>;
 
-  BaseStringIndex(PMR_NS::memory_resource* mr);
+  BaseStringIndex(PMR_NS::memory_resource* mr, bool case_sensitive);
 
   void Add(DocId id, DocumentAccessor* doc, std::string_view field) override;
   void Remove(DocId id, DocumentAccessor* doc, std::string_view field) override;
@@ -74,6 +74,8 @@ template <typename C> struct BaseStringIndex : public BaseIndex {
     }
   };
 
+  bool case_sensitive_ = false;
+
   absl::flat_hash_map<PMR_NS::string, Container, PmrHash, PmrEqual,
                       PMR_NS::polymorphic_allocator<std::pair<PMR_NS::string, Container>>>
       entries_;
@@ -82,7 +84,7 @@ template <typename C> struct BaseStringIndex : public BaseIndex {
 // Index for text fields.
 // Hashmap based lookup per word.
 struct TextIndex : public BaseStringIndex<CompressedSortedSet> {
-  TextIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr) {
+  TextIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr, false) {
   }
 
   absl::flat_hash_set<std::string> Tokenize(std::string_view value) const override;
@@ -91,10 +93,14 @@ struct TextIndex : public BaseStringIndex<CompressedSortedSet> {
 // Index for text fields.
 // Hashmap based lookup per word.
 struct TagIndex : public BaseStringIndex<SortedVector> {
-  TagIndex(PMR_NS::memory_resource* mr) : BaseStringIndex(mr) {
+  TagIndex(PMR_NS::memory_resource* mr, SchemaField::TagParams params)
+      : BaseStringIndex(mr, params.case_sensitive), separator_{params.separator} {
   }
 
   absl::flat_hash_set<std::string> Tokenize(std::string_view value) const override;
+
+ private:
+  char separator_;
 };
 
 struct BaseVectorIndex : public BaseIndex {
diff --git a/src/core/search/search.cc b/src/core/search/search.cc
index 05bb204c2b58..525a06dce8a1 100644
--- a/src/core/search/search.cc
+++ b/src/core/search/search.cc
@@ -465,16 +465,18 @@ void FieldIndices::CreateIndices(PMR_NS::memory_resource* mr) {
       continue;
 
     switch (field_info.type) {
-      case SchemaField::TAG:
-        indices_[field_ident] = make_unique<TagIndex>(mr);
-        break;
       case SchemaField::TEXT:
         indices_[field_ident] = make_unique<TextIndex>(mr);
         break;
       case SchemaField::NUMERIC:
         indices_[field_ident] = make_unique<NumericIndex>(mr);
         break;
-      case SchemaField::VECTOR:
+      case SchemaField::TAG: {
+        const auto& tparams = std::get<SchemaField::TagParams>(field_info.special_params);
+        indices_[field_ident] = make_unique<TagIndex>(mr, tparams);
+        break;
+      }
+      case SchemaField::VECTOR: {
         unique_ptr<BaseVectorIndex> vector_index;
 
         DCHECK(holds_alternative<SchemaField::VectorParams>(field_info.special_params));
@@ -487,6 +489,7 @@ void FieldIndices::CreateIndices(PMR_NS::memory_resource* mr) {
 
         indices_[field_ident] = std::move(vector_index);
         break;
+      }
     }
   }
 }
diff --git a/src/core/search/search.h b/src/core/search/search.h
index 3202e0e9c86b..4a84831eb915 100644
--- a/src/core/search/search.h
+++ b/src/core/search/search.h
@@ -36,7 +36,12 @@ struct SchemaField {
     size_t hnsw_m = 16;
   };
 
-  using ParamsVariant = std::variant<std::monostate, VectorParams>;
+  struct TagParams {
+    char separator = ',';
+    bool case_sensitive = false;
+  };
+
+  using ParamsVariant = std::variant<std::monostate, VectorParams, TagParams>;
 
   FieldType type;
   uint8_t flags;
diff --git a/src/server/search/doc_index.cc b/src/server/search/doc_index.cc
index b277b53feed1..ff34a4ce6101 100644
--- a/src/server/search/doc_index.cc
+++ b/src/server/search/doc_index.cc
@@ -111,6 +111,11 @@ string DocIndexInfo::BuildRestoreCommand() const {
           absl::StrAppend(out, " ", params.use_hnsw ? "HNSW" : "FLAT", " 6 ", "DIM ", params.dim,
                           " DISTANCE_METRIC ", sim, " INITIAL_CAP ", params.capacity);
         },
+        [out = &out](const search::SchemaField::TagParams& params) {
+          absl::StrAppend(out, " ", "SEPARATOR", " ", string{params.separator});
+          if (params.case_sensitive)
+            absl::StrAppend(out, " ", "CASESENSITIVE");
+        },
     };
     visit(info, finfo.special_params);
   }
diff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc
index 7b190c10458d..e14627cad32f 100644
--- a/src/server/search/search_family.cc
+++ b/src/server/search/search_family.cc
@@ -80,6 +80,32 @@ search::SchemaField::VectorParams ParseVectorParams(CmdArgParser* parser) {
   return params;
 }
 
+search::SchemaField::TagParams ParseTagParams(CmdArgParser* parser) {
+  search::SchemaField::TagParams params{};
+  while (parser->HasNext()) {
+    if (parser->Check("SEPARATOR").IgnoreCase().ExpectTail(1)) {
+      string_view separator = parser->Next();
+      params.separator = separator.front();
+      continue;
+    }
+
+    if (parser->Check("CASESENSITIVE").IgnoreCase()) {
+      params.case_sensitive = true;
+      continue;
+    }
+
+    break;
+  }
+
+  return params;
+}
+
+// breaks on ParamsVariant initialization
+#ifndef __clang__
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+#endif
+
 optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParser parser,
                                             ConnectionContext* cntx) {
   search::Schema schema;
@@ -108,15 +134,18 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse
       return nullopt;
     }
 
+    // Tag fields include: [separator char] [casesensitive]
     // Vector fields include: {algorithm} num_args args...
-    search::SchemaField::ParamsVariant params = std::monostate{};
-    if (*type == search::SchemaField::VECTOR) {
+    search::SchemaField::ParamsVariant params(monostate{});
+    if (*type == search::SchemaField::TAG) {
+      params = ParseTagParams(&parser);
+    } else if (*type == search::SchemaField::VECTOR) {
       auto vector_params = ParseVectorParams(&parser);
       if (!parser.HasError() && vector_params.dim == 0) {
         cntx->SendError("Knn vector dimension cannot be zero");
         return nullopt;
       }
-      params = std::move(vector_params);
+      params = vector_params;
     }
 
     // Flags: check for SORTABLE and NOINDEX
@@ -154,6 +183,10 @@ optional<search::Schema> ParseSchemaOrReply(DocIndex::DataType type, CmdArgParse
   return schema;
 }
 
+#ifndef __clang__
+#pragma GCC diagnostic pop
+#endif
+
 search::QueryParams ParseQueryParams(CmdArgParser* parser) {
   search::QueryParams params;
   size_t num_args = parser->Next<size_t>();
