{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 298,
  "instance_id": "dragonflydb__dragonfly-298",
  "issue_numbers": [
    "286"
  ],
  "base_commit": "f3ab64e645c7fc2fe9bd14fc4e9b06cf71bfafef",
  "patch": "diff --git a/docs/api_status.md b/docs/api_status.md\nindex 6fd2af08a685..01386a9916e5 100644\n--- a/docs/api_status.md\n+++ b/docs/api_status.md\n@@ -40,6 +40,7 @@ with respect to Memcached and Redis APIs.\n   - [X] EXPIRE\n   - [X] EXPIREAT\n   - [X] KEYS\n+  - [X] MOVE\n   - [X] PING\n   - [X] RENAME\n   - [X] RENAMENX\n@@ -105,7 +106,6 @@ with respect to Memcached and Redis APIs.\n   - [ ] BGREWRITEAOF\n   - [ ] MONITOR\n   - [ ] RANDOMKEY\n-  - [ ] MOVE\n \n ### API 2\n - [X] List Family\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex c772598947b5..60550bbeba39 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -463,6 +463,38 @@ void GenericFamily::Stick(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(match_cnt);\n }\n \n+void GenericFamily::Move(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  int64_t target_db;\n+\n+  if (!absl::SimpleAtoi(ArgS(args, 2), &target_db)) {\n+    return (*cntx)->SendError(kInvalidIntErr);\n+  }\n+\n+  if (target_db < 0 || target_db >= absl::GetFlag(FLAGS_dbnum)) {\n+    return (*cntx)->SendError(kDbIndOutOfRangeErr);\n+  }\n+\n+  if (target_db == cntx->db_index()) {\n+    return (*cntx)->SendError(\"source and destination objects are the same\");\n+  }\n+\n+  OpStatus res = OpStatus::SKIPPED;\n+  ShardId target_shard = Shard(key, shard_set->size());\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    // MOVE runs as a global transaction and is therefore scheduled on every shard.\n+    if (target_shard == shard->shard_id()) {\n+      res = OpMove(t->GetOpArgs(shard), key, target_db);\n+    }\n+    return OpStatus::OK;\n+  };\n+\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  // Exactly one shard will call OpMove.\n+  DCHECK(res != OpStatus::SKIPPED);\n+  (*cntx)->SendLong(res == OpStatus::OK);\n+}\n+\n void GenericFamily::Rename(CmdArgList args, ConnectionContext* cntx) {\n   OpResult<void> st = RenameGeneric(args, false, cntx);\n   (*cntx)->SendError(st.status());\n@@ -771,6 +803,43 @@ OpResult<uint32_t> GenericFamily::OpStick(const OpArgs& op_args, ArgSlice keys)\n   return res;\n }\n \n+// OpMove touches multiple databases (op_args.db_idx, target_db), so it assumes it runs\n+// as a global transaction.\n+// TODO: Allow running OpMove without a global transaction.\n+OpStatus GenericFamily::OpMove(const OpArgs& op_args, string_view key, DbIndex target_db) {\n+  auto& db_slice = op_args.shard->db_slice();\n+\n+  // Fetch value at key in current db.\n+  auto [from_it, from_expire] = db_slice.FindExt(op_args.db_ind, key);\n+  if (!IsValid(from_it))\n+    return OpStatus::KEY_NOTFOUND;\n+\n+  // Fetch value at key in target db.\n+  auto [to_it, _] = db_slice.FindExt(target_db, key);\n+  if (IsValid(to_it))\n+    return OpStatus::KEY_EXISTS;\n+\n+  // Ensure target database exists.\n+  db_slice.ActivateDb(target_db);\n+\n+  bool sticky = from_it->first.IsSticky();\n+  uint64_t exp_ts = db_slice.ExpireTime(from_expire);\n+  PrimeValue from_obj = std::move(from_it->second);\n+\n+  // Restore expire flag after std::move.\n+  from_it->second.SetExpire(IsValid(from_expire));\n+\n+  CHECK(db_slice.Del(op_args.db_ind, from_it));\n+  to_it = db_slice.AddNew(target_db, key, std::move(from_obj), exp_ts);\n+  to_it->first.SetSticky(sticky);\n+\n+  if (to_it->second.ObjType() == OBJ_LIST && op_args.shard->blocking_controller()) {\n+    op_args.shard->blocking_controller()->AwakeWatched(target_db, key);\n+  }\n+\n+  return OpStatus::OK;\n+}\n+\n using CI = CommandId;\n \n #define HFUNC(x) SetHandler(&GenericFamily::x)\n@@ -798,7 +867,8 @@ void GenericFamily::Register(CommandRegistry* registry) {\n             << CI{\"PTTL\", CO::READONLY | CO::FAST, 2, 1, 1, 1}.HFUNC(Pttl)\n             << CI{\"TYPE\", CO::READONLY | CO::FAST | CO::LOADING, 2, 1, 1, 1}.HFUNC(Type)\n             << CI{\"UNLINK\", CO::WRITE, -2, 1, -1, 1}.HFUNC(Del)\n-            << CI{\"STICK\", CO::WRITE, -2, 1, -1, 1}.HFUNC(Stick);\n+            << CI{\"STICK\", CO::WRITE, -2, 1, -1, 1}.HFUNC(Stick)\n+            << CI{\"MOVE\", CO::WRITE | CO::GLOBAL_TRANS, 3, 1, 1, 1}.HFUNC(Move);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex 50c43a8bb1b9..470e754fe8a0 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -49,6 +49,7 @@ class GenericFamily {\n   static void Keys(CmdArgList args, ConnectionContext* cntx);\n   static void PexpireAt(CmdArgList args, ConnectionContext* cntx);\n   static void Stick(CmdArgList args, ConnectionContext* cntx);\n+  static void Move(CmdArgList args, ConnectionContext* cntx);\n \n   static void Rename(CmdArgList args, ConnectionContext* cntx);\n   static void RenameNx(CmdArgList args, ConnectionContext* cntx);\n@@ -71,6 +72,7 @@ class GenericFamily {\n   static OpResult<void> OpRen(const OpArgs& op_args, std::string_view from, std::string_view to,\n                               bool skip_exists);\n   static OpResult<uint32_t> OpStick(const OpArgs& op_args, ArgSlice keys);\n+  static OpStatus OpMove(const OpArgs& op_args, std::string_view key, DbIndex target_db);\n };\n \n }  // namespace dfly\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 09881009a09a..c792d1e4a86c 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -398,13 +398,14 @@ bool Transaction::RunInShard(EngineShard* shard) {\n         }\n       }\n       sd.local_mask &= ~OUT_OF_ORDER;\n-\n-      // It has 2 responsibilities.\n-      // 1: to go over potential wakened keys, verify them and activate watch queues.\n-      // 2: if this transaction was notified and finished running - to remove it from the head\n-      //    of the queue and notify the next one.\n-      if (shard->blocking_controller())\n-        shard->blocking_controller()->RunStep(awaked_prerun ? this : nullptr);\n+    }\n+    // It has 2 responsibilities.\n+    // 1: to go over potential wakened keys, verify them and activate watch queues.\n+    // 2: if this transaction was notified and finished running - to remove it from the head\n+    //    of the queue and notify the next one.\n+    // RunStep is also called for global transactions because of commands like MOVE.\n+    if (shard->blocking_controller()) {\n+      shard->blocking_controller()->RunStep(awaked_prerun ? this : nullptr);\n     }\n   }\n \n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 1fff6a855f69..e008d0893676 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -201,6 +201,51 @@ TEST_F(GenericFamilyTest, Stick) {\n   ASSERT_THAT(Run({\"stick\", \"b\"}), IntArg(0));\n }\n \n+TEST_F(GenericFamilyTest, Move) {\n+  // Check MOVE returns 0 on non-existent keys\n+  ASSERT_THAT(Run({\"move\", \"a\", \"1\"}), IntArg(0));\n+\n+  // Check MOVE catches non-existent database indices\n+  ASSERT_THAT(Run({\"move\", \"a\", \"-1\"}), ArgType(RespExpr::ERROR));\n+  ASSERT_THAT(Run({\"move\", \"a\", \"100500\"}), ArgType(RespExpr::ERROR));\n+\n+  // Check MOVE moves value & expiry & stickyness\n+  Run({\"set\", \"a\", \"test\"});\n+  Run({\"expire\", \"a\", \"1000\"});\n+  Run({\"stick\", \"a\"});\n+  ASSERT_THAT(Run({\"move\", \"a\", \"1\"}), IntArg(1));\n+  Run({\"select\", \"1\"});\n+  ASSERT_THAT(Run({\"get\", \"a\"}), \"test\");\n+  ASSERT_THAT(Run({\"ttl\", \"a\"}), testing::Not(IntArg(-1)));\n+  ASSERT_THAT(Run({\"stick\", \"a\"}), IntArg(0));\n+\n+  // Check MOVE doesn't move if key exists\n+  Run({\"select\", \"1\"});\n+  Run({\"set\", \"a\", \"test\"});\n+  Run({\"select\", \"0\"});\n+  Run({\"set\", \"a\", \"another test\"});\n+  ASSERT_THAT(Run({\"move\", \"a\", \"1\"}), IntArg(0));  // exists from test case above\n+  Run({\"select\", \"1\"});\n+  ASSERT_THAT(Run({\"get\", \"a\"}), \"test\");\n+\n+  // Check MOVE awakes blocking operations\n+  auto fb_blpop = pp_->at(0)->LaunchFiber(fibers::launch::dispatch, [&] {\n+    Run({\"select\", \"1\"});\n+    auto resp = Run({\"blpop\", \"l\", \"0\"});\n+    ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+    EXPECT_THAT(resp.GetVec(), ElementsAre(\"l\", \"TestItem\"));\n+  });\n+\n+  WaitUntilLocked(1, \"l\");\n+\n+  pp_->at(1)->Await([&] {\n+    Run({\"select\", \"0\"});\n+    Run({\"lpush\", \"l\", \"TestItem\"});\n+    Run({\"move\", \"l\", \"1\"});\n+  });\n+\n+  fb_blpop.join();\n+}\n \n using testing::AnyOf;\n using testing::Each;\ndiff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex ba09b888b975..83206304a16b 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -30,12 +30,6 @@ class ListFamilyTest : public BaseFamilyTest {\n   ListFamilyTest() {\n     num_threads_ = 4;\n   }\n-\n-  void WaitForLocked(string_view key) {\n-    do {\n-      this_fiber::sleep_for(30us);\n-    } while (!IsLocked(0, key));\n-  }\n };\n \n const char kKey1[] = \"x\";\n@@ -187,7 +181,7 @@ TEST_F(ListFamilyTest, BLPopMultiPush) {\n     blpop_resp = Run({\"blpop\", kKey1, kKey2, kKey3, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   auto p1_fb = pp_->at(1)->LaunchFiber([&] {\n     for (unsigned i = 0; i < 100; ++i) {\n@@ -225,7 +219,7 @@ TEST_F(ListFamilyTest, BLPopSerialize) {\n     blpop_resp = Run({\"blpop\", kKey1, kKey2, kKey3, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   LOG(INFO) << \"Starting multi\";\n \n@@ -295,7 +289,7 @@ TEST_F(ListFamilyTest, WrongTypeDoesNotWake) {\n     blpop_resp = Run({\"blpop\", kKey1, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   auto p1_fb = pp_->at(1)->LaunchFiber([&] {\n     Run({\"multi\"});\n@@ -324,7 +318,7 @@ TEST_F(ListFamilyTest, BPopSameKeyTwice) {\n     ASSERT_THAT(watched, ArrLen(0));\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   pp_->at(1)->Await([&] { EXPECT_EQ(1, CheckedInt({\"lpush\", kKey1, \"bar\"})); });\n   pop_fb.join();\n@@ -336,7 +330,7 @@ TEST_F(ListFamilyTest, BPopSameKeyTwice) {\n     blpop_resp = Run({\"blpop\", kKey1, kKey2, kKey2, kKey1, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   pp_->at(1)->Await([&] { EXPECT_EQ(1, CheckedInt({\"lpush\", kKey2, \"bar\"})); });\n   pop_fb.join();\n@@ -358,7 +352,7 @@ TEST_F(ListFamilyTest, BPopTwoKeysSameShard) {\n     ASSERT_THAT(watched, ArrLen(0));\n   });\n \n-  WaitForLocked(\"x\");\n+  WaitUntilLocked(0, \"x\");\n \n   pp_->at(1)->Await([&] { EXPECT_EQ(1, CheckedInt({\"lpush\", \"x\", \"bar\"})); });\n   pop_fb.join();\n@@ -377,7 +371,7 @@ TEST_F(ListFamilyTest, BPopRename) {\n     blpop_resp = Run({\"blpop\", kKey1, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   pp_->at(1)->Await([&] {\n     EXPECT_EQ(1, CheckedInt({\"lpush\", \"a\", \"bar\"}));\n@@ -395,7 +389,7 @@ TEST_F(ListFamilyTest, BPopFlush) {\n     blpop_resp = Run({\"blpop\", kKey1, \"0\"});\n   });\n \n-  WaitForLocked(kKey1);\n+  WaitUntilLocked(0, kKey1);\n \n   pp_->at(1)->Await([&] {\n     Run({\"flushdb\"});\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex df234dafbd9f..f88ce5e53ef7 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -157,6 +157,16 @@ void BaseFamilyTest::UpdateTime(uint64_t ms) {\n   shard_set->RunBriefInParallel(cb);\n }\n \n+void BaseFamilyTest::WaitUntilLocked(DbIndex db_index, string_view key, double timeout) {\n+  auto step = 50us;\n+  auto timeout_micro = chrono::duration_cast<chrono::microseconds> (1000ms * timeout);\n+  int64_t steps = timeout_micro.count() / step.count();\n+  do {\n+    ::boost::this_fiber::sleep_for(step);\n+  } while (!IsLocked(db_index, key) && --steps > 0);\n+  CHECK(IsLocked(db_index, key));\n+}\n+\n RespExpr BaseFamilyTest::Run(ArgSlice list) {\n   if (!ProactorBase::IsProactorThread()) {\n     return pp_->at(0)->Await([&] { return this->Run(list); });\ndiff --git a/src/server/test_utils.h b/src/server/test_utils.h\nindex d10ba9f711a6..bb963c42a0d6 100644\n--- a/src/server/test_utils.h\n+++ b/src/server/test_utils.h\n@@ -71,6 +71,9 @@ class BaseFamilyTest : public ::testing::Test {\n   // ts is ms\n   void UpdateTime(uint64_t ms);\n \n+  // Wait for a locked key to unlock. Aborts after timeout seconds passed.\n+  void WaitUntilLocked(DbIndex db_index, std::string_view key, double timeout = 3);\n+\n   std::string GetId() const;\n   size_t SubscriberMessagesLen(std::string_view conn_id) const;\n \n",
  "problem_statement": "Support MOVE command\nPart of #91\n",
  "hints_text": "",
  "created_at": "2022-09-14T19:21:26Z",
  "modified_files": [
    "docs/api_status.md",
    "src/server/generic_family.cc",
    "src/server/generic_family.h",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc",
    "src/server/list_family_test.cc",
    "src/server/test_utils.cc",
    "src/server/test_utils.h"
  ]
}