{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1108,
  "instance_id": "dragonflydb__dragonfly-1108",
  "issue_numbers": [
    "1106"
  ],
  "base_commit": "1382ed1c373d42dca22e239aea3ff438b6f31dcf",
  "patch": "diff --git a/src/core/interpreter.cc b/src/core/interpreter.cc\nindex 1ae36ded83b6..79882f304162 100644\n--- a/src/core/interpreter.cc\n+++ b/src/core/interpreter.cc\n@@ -44,6 +44,27 @@ int EVPDigest(const void* data, size_t datalen, unsigned char* md, size_t* mdlen\n   return ret;\n }\n \n+/* This function is used in order to push an error on the Lua stack in the\n+ * format used by redis.pcall to return errors, which is a lua table\n+ * with a single \"err\" field set to the error string. Note that this\n+ * table is never a valid reply by proper commands, since the returned\n+ * tables are otherwise always indexed by integers, never by strings. */\n+void PushError(lua_State* lua, string_view error, bool trace = true) {\n+  lua_Debug dbg;\n+\n+  lua_newtable(lua);\n+  lua_pushstring(lua, \"err\");\n+\n+  /* Attempt to figure out where this function was called, if possible */\n+  if (trace && lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, \"nSl\", &dbg)) {\n+    string msg = absl::StrCat(dbg.source, \": \", dbg.currentline, \": \", error);\n+    lua_pushlstring(lua, msg.c_str(), msg.size());\n+  } else {\n+    lua_pushlstring(lua, error.data(), error.size());\n+  }\n+  lua_settable(lua, -3);\n+}\n+\n class RedisTranslator : public ObjectExplorer {\n  public:\n   RedisTranslator(lua_State* lua) : lua_(lua) {\n@@ -58,6 +79,8 @@ class RedisTranslator : public ObjectExplorer {\n   void OnStatus(std::string_view str) final;\n   void OnError(std::string_view str) final;\n \n+  bool HasError();\n+\n  private:\n   void ArrayPre() {\n   }\n@@ -68,8 +91,9 @@ class RedisTranslator : public ObjectExplorer {\n     }\n   }\n \n-  vector<unsigned> array_index_;\n   lua_State* lua_;\n+  bool has_error_{false};\n+  vector<unsigned> array_index_{};\n };\n \n void RedisTranslator::OnBool(bool b) {\n@@ -123,11 +147,8 @@ void RedisTranslator::OnStatus(std::string_view str) {\n }\n \n void RedisTranslator::OnError(std::string_view str) {\n-  CHECK(array_index_.empty()) << \"unexpected error\";\n-  lua_newtable(lua_);\n-  lua_pushstring(lua_, \"err\");\n-  lua_pushlstring(lua_, str.data(), str.size());\n-  lua_settable(lua_, -3);\n+  has_error_ = true;\n+  PushError(lua_, str, false);\n }\n \n void RedisTranslator::OnArrayStart(unsigned len) {\n@@ -144,6 +165,10 @@ void RedisTranslator::OnArrayEnd() {\n   ArrayPost();\n }\n \n+bool RedisTranslator::HasError() {\n+  return has_error_;\n+}\n+\n void RunSafe(lua_State* lua, string_view buf, const char* name) {\n   CHECK_EQ(0, luaL_loadbuffer(lua, buf.data(), buf.size(), name));\n   int err = lua_pcall(lua, 0, 0, 0);\n@@ -181,27 +206,6 @@ void SetGlobalArrayInternal(lua_State* lua, const char* name, MutSliceSpan args)\n   lua_setglobal(lua, name);\n }\n \n-/* This function is used in order to push an error on the Lua stack in the\n- * format used by redis.pcall to return errors, which is a lua table\n- * with a single \"err\" field set to the error string. Note that this\n- * table is never a valid reply by proper commands, since the returned\n- * tables are otherwise always indexed by integers, never by strings. */\n-void PushError(lua_State* lua, const char* error) {\n-  lua_Debug dbg;\n-\n-  lua_newtable(lua);\n-  lua_pushstring(lua, \"err\");\n-\n-  /* Attempt to figure out where this function was called, if possible */\n-  if (lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, \"nSl\", &dbg)) {\n-    string msg = absl::StrCat(dbg.source, \": \", dbg.currentline, \": \", error);\n-    lua_pushstring(lua, msg.c_str());\n-  } else {\n-    lua_pushstring(lua, error);\n-  }\n-  lua_settable(lua, -3);\n-}\n-\n /* In case the error set into the Lua stack by PushError() was generated\n  * by the non-error-trapping version of redis.pcall(), which is redis.call(),\n  * this function will raise the Lua error so that the execution of the\n@@ -717,12 +721,17 @@ int Interpreter::RedisGenericCommand(bool raise_error, bool async) {\n   lua_pop(lua_, argc);\n   RedisTranslator translator(lua_);\n   redis_func_(CallArgs{MutSliceSpan{args}, &buffer, &translator, async});\n+  cmd_depth_--;\n+\n+  // Raise error for regular 'call' command if needed.\n+  if (raise_error && translator.HasError()) {\n+    // error is already on top of stack\n+    return RaiseError(lua_);\n+  }\n \n   if (!async)\n     DCHECK_EQ(1, lua_gettop(lua_));\n \n-  cmd_depth_--;\n-\n   return 1;\n }\n \n",
  "test_patch": "diff --git a/src/core/interpreter_test.cc b/src/core/interpreter_test.cc\nindex 57bba3a446a9..13250117afa6 100644\n--- a/src/core/interpreter_test.cc\n+++ b/src/core/interpreter_test.cc\n@@ -276,19 +276,19 @@ TEST_F(InterpreterTest, Call) {\n   };\n \n   intptr_.SetRedisFunc(cb);\n-  ASSERT_TRUE(Execute(\"local var = redis.call('string'); return {type(var), var}\"));\n+  ASSERT_TRUE(Execute(\"local var = redis.pcall('string'); return {type(var), var}\"));\n   EXPECT_EQ(\"[str(string) str(foo)]\", ser_.res);\n \n-  EXPECT_TRUE(Execute(\"local var = redis.call('double'); return {type(var), var}\"));\n+  EXPECT_TRUE(Execute(\"local var = redis.pcall('double'); return {type(var), var}\"));\n   EXPECT_EQ(\"[str(number) d(3.1415)]\", ser_.res);\n \n-  EXPECT_TRUE(Execute(\"local var = redis.call('int'); return {type(var), var}\"));\n+  EXPECT_TRUE(Execute(\"local var = redis.pcall('int'); return {type(var), var}\"));\n   EXPECT_EQ(\"[str(number) i(42)]\", ser_.res);\n \n-  EXPECT_TRUE(Execute(\"local var = redis.call('err'); return {type(var), var}\"));\n+  EXPECT_TRUE(Execute(\"local var = redis.pcall('err'); return {type(var), var}\"));\n   EXPECT_EQ(\"[str(table) err(myerr)]\", ser_.res);\n \n-  EXPECT_TRUE(Execute(\"local var = redis.call('status'); return {type(var), var}\"));\n+  EXPECT_TRUE(Execute(\"local var = redis.pcall('status'); return {type(var), var}\"));\n   EXPECT_EQ(\"[str(table) status(mystatus)]\", ser_.res);\n }\n \ndiff --git a/tests/dragonfly/eval_test.py b/tests/dragonfly/eval_test.py\nindex c1d09544a42b..941e67ed2fa0 100644\n--- a/tests/dragonfly/eval_test.py\n+++ b/tests/dragonfly/eval_test.py\n@@ -201,3 +201,21 @@ async def dequeue_worker():\n \n     for job in jobs:\n         await job\n+\n+ERROR_CALL_SCRIPT = \"\"\"\n+redis.call('ECHO', 'I', 'want', 'an', 'error')\n+\"\"\"\n+\n+ERROR_PCALL_SCRIPT = \"\"\"\n+redis.pcall('ECHO', 'I', 'want', 'an', 'error')\n+\"\"\"\n+\n+@pytest.mark.asyncio\n+async def test_eval_error_propagation(async_client):\n+    assert await async_client.eval(ERROR_PCALL_SCRIPT, 0) is None\n+\n+    try:\n+        await async_client.eval(ERROR_CALL_SCRIPT, 0)\n+        assert False, \"Eval must have thrown an error\"\n+    except aioredis.RedisError as e:\n+        pass\n",
  "problem_statement": "Errors are not progapated in lua scripts\nDragonfly currently has no differentiation between call and pcall.\r\n\r\n```lua\r\nredis.call('ECHO', 'I', 'want', 'an', 'error')\r\n```\r\n\r\nthrows an error with Redis and none with DF.\n",
  "hints_text": "",
  "created_at": "2023-04-18T11:29:31Z",
  "modified_files": [
    "src/core/interpreter.cc"
  ],
  "modified_test_files": [
    "src/core/interpreter_test.cc",
    "tests/dragonfly/eval_test.py"
  ]
}