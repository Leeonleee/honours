{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3493,
  "instance_id": "dragonflydb__dragonfly-3493",
  "issue_numbers": [
    "3491"
  ],
  "base_commit": "e79f3fb206df625e13f9c76d1063e57ff5055c90",
  "patch": "diff --git a/src/core/search/indices.cc b/src/core/search/indices.cc\nindex 6eb9f0d67746..538d844b8759 100644\n--- a/src/core/search/indices.cc\n+++ b/src/core/search/indices.cc\n@@ -149,6 +149,15 @@ void BaseStringIndex<C>::Remove(DocId id, DocumentAccessor* doc, string_view fie\n   }\n }\n \n+template <typename C> vector<string> BaseStringIndex<C>::GetTerms() const {\n+  vector<string> res;\n+  res.reserve(entries_.size());\n+  for (const auto& [term, _] : entries_) {\n+    res.push_back(string{term});\n+  }\n+  return res;\n+}\n+\n template struct BaseStringIndex<CompressedSortedSet>;\n template struct BaseStringIndex<SortedVector>;\n \ndiff --git a/src/core/search/indices.h b/src/core/search/indices.h\nindex c94944a2143c..e8b070e618a2 100644\n--- a/src/core/search/indices.h\n+++ b/src/core/search/indices.h\n@@ -51,6 +51,9 @@ template <typename C> struct BaseStringIndex : public BaseIndex {\n   // Pointer is valid as long as index is not mutated. Nullptr if not found\n   const Container* Matching(std::string_view str) const;\n \n+  // Returns all the terms that appear as keys in the reverse index.\n+  std::vector<std::string> GetTerms() const;\n+\n  protected:\n   Container* GetOrCreate(std::string_view word);\n \ndiff --git a/src/facade/error.h b/src/facade/error.h\nindex d973b9d334ac..d46b4e71bf8a 100644\n--- a/src/facade/error.h\n+++ b/src/facade/error.h\n@@ -39,5 +39,6 @@ extern const char kInvalidDumpValueErr[];\n extern const char kSyntaxErrType[];\n extern const char kScriptErrType[];\n extern const char kConfigErrType[];\n+extern const char kSearchErrType[];\n \n }  // namespace facade\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex 041df090a874..01596a4b07d9 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -101,6 +101,7 @@ const char kInvalidDumpValueErr[] = \"DUMP payload version or checksum are wrong\"\n const char kSyntaxErrType[] = \"syntax_error\";\n const char kScriptErrType[] = \"script_error\";\n const char kConfigErrType[] = \"config_error\";\n+const char kSearchErrType[] = \"search_error\";\n \n const char* RespExpr::TypeName(Type t) {\n   switch (t) {\ndiff --git a/src/server/search/doc_index.cc b/src/server/search/doc_index.cc\nindex 7daf0cca8942..fd98d3c83743 100644\n--- a/src/server/search/doc_index.cc\n+++ b/src/server/search/doc_index.cc\n@@ -10,6 +10,7 @@\n \n #include \"base/logging.h\"\n #include \"core/overloaded.h\"\n+#include \"core/search/indices.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/search/doc_accessors.h\"\n #include \"server/server_state.h\"\n@@ -17,6 +18,8 @@\n namespace dfly {\n \n using namespace std;\n+using facade::ErrorReply;\n+using nonstd::make_unexpected;\n \n namespace {\n \n@@ -269,6 +272,20 @@ DocIndexInfo ShardDocIndex::GetInfo() const {\n   return {*base_, key_index_.Size()};\n }\n \n+io::Result<StringVec, ErrorReply> ShardDocIndex::GetTagVals(string_view field) const {\n+  search::BaseIndex* base_index = indices_.GetIndex(field);\n+  if (base_index == nullptr) {\n+    return make_unexpected(ErrorReply{\"-No such field\"});\n+  }\n+\n+  search::TagIndex* tag_index = dynamic_cast<search::TagIndex*>(base_index);\n+  if (tag_index == nullptr) {\n+    return make_unexpected(ErrorReply{\"-Not a tag field\"});\n+  }\n+\n+  return tag_index->GetTerms();\n+}\n+\n ShardDocIndices::ShardDocIndices() : local_mr_{ServerState::tlocal()->data_heap()} {\n }\n \ndiff --git a/src/server/search/doc_index.h b/src/server/search/doc_index.h\nindex ebc689c4a8b5..8aef2b63eb4f 100644\n--- a/src/server/search/doc_index.h\n+++ b/src/server/search/doc_index.h\n@@ -138,6 +138,8 @@ class ShardDocIndex {\n \n   DocIndexInfo GetInfo() const;\n \n+  io::Result<StringVec, facade::ErrorReply> GetTagVals(std::string_view field) const;\n+\n  private:\n   // Clears internal data. Traverses all matching documents and assigns ids.\n   void Rebuild(const OpArgs& op_args, PMR_NS::memory_resource* mr);\ndiff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 95331ce3335c..37df03b2b45f 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -798,6 +798,41 @@ void SearchFamily::FtProfile(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void SearchFamily::FtTagVals(CmdArgList args, ConnectionContext* cntx) {\n+  string_view index_name = ArgS(args, 0);\n+  string_view field_name = ArgS(args, 1);\n+  VLOG(1) << \"FtTagVals: \" << index_name << \" \" << field_name;\n+\n+  vector<io::Result<StringVec, ErrorReply>> shard_results(shard_set->size(), StringVec{});\n+\n+  cntx->transaction->ScheduleSingleHop([&](Transaction* t, EngineShard* es) {\n+    if (auto* index = es->search_indices()->GetIndex(index_name); index)\n+      shard_results[es->shard_id()] = index->GetTagVals(field_name);\n+    else\n+      shard_results[es->shard_id()] = nonstd::make_unexpected(ErrorReply(\"-Unknown Index name\"));\n+\n+    return OpStatus::OK;\n+  });\n+\n+  absl::flat_hash_set<string> result_set;\n+\n+  // Check first if either shard had errors. Also merge the results into a single set.\n+  for (auto& res : shard_results) {\n+    if (res) {\n+      result_set.insert(make_move_iterator(res->begin()), make_move_iterator(res->end()));\n+    } else {\n+      res.error().kind = facade::kSearchErrType;\n+      return cntx->SendError(res.error());\n+    }\n+  }\n+\n+  shard_results.clear();\n+  vector<string> vec(result_set.begin(), result_set.end());\n+\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  rb->SendStringArr(vec, RedisReplyBuilder::SET);\n+}\n+\n void SearchFamily::FtAggregate(CmdArgList args, ConnectionContext* cntx) {\n   const auto params = ParseAggregatorParamsOrReply(args, cntx);\n   if (!params)\n@@ -871,7 +906,8 @@ void SearchFamily::Register(CommandRegistry* registry) {\n             << CI{\"FT._LIST\", kReadOnlyMask, 1, 0, 0, acl::FT_SEARCH}.HFUNC(FtList)\n             << CI{\"FT.SEARCH\", kReadOnlyMask, -3, 0, 0, acl::FT_SEARCH}.HFUNC(FtSearch)\n             << CI{\"FT.AGGREGATE\", kReadOnlyMask, -3, 0, 0, acl::FT_SEARCH}.HFUNC(FtAggregate)\n-            << CI{\"FT.PROFILE\", kReadOnlyMask, -4, 0, 0, acl::FT_SEARCH}.HFUNC(FtProfile);\n+            << CI{\"FT.PROFILE\", kReadOnlyMask, -4, 0, 0, acl::FT_SEARCH}.HFUNC(FtProfile)\n+            << CI{\"FT.TAGVALS\", kReadOnlyMask, 3, 0, 0, acl::FT_SEARCH}.HFUNC(FtTagVals);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/search/search_family.h b/src/server/search/search_family.h\nindex 5abe1c42b416..f3b453eb9488 100644\n--- a/src/server/search/search_family.h\n+++ b/src/server/search/search_family.h\n@@ -22,6 +22,7 @@ class SearchFamily {\n   static void FtSearch(CmdArgList args, ConnectionContext* cntx);\n   static void FtProfile(CmdArgList args, ConnectionContext* cntx);\n   static void FtAggregate(CmdArgList args, ConnectionContext* cntx);\n+  static void FtTagVals(CmdArgList args, ConnectionContext* cntx);\n \n  public:\n   static void Register(CommandRegistry* registry);\n",
  "test_patch": "diff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex ff8067127184..e11869dd7d3c 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -310,7 +310,13 @@ TEST_F(SearchFamilyTest, Tags) {\n   Run({\"hset\", \"d:5\", \"color\", \"green\"});\n   Run({\"hset\", \"d:6\", \"color\", \"blue\"});\n \n-  EXPECT_EQ(Run({\"ft.create\", \"i1\", \"on\", \"hash\", \"schema\", \"color\", \"tag\"}), \"OK\");\n+  EXPECT_EQ(Run({\"ft.create\", \"i1\", \"on\", \"hash\", \"schema\", \"color\", \"tag\", \"dummy\", \"numeric\"}),\n+            \"OK\");\n+  EXPECT_THAT(Run({\"ft.tagvals\", \"i2\", \"color\"}), ErrArg(\"Unknown Index name\"));\n+  EXPECT_THAT(Run({\"ft.tagvals\", \"i1\", \"foo\"}), ErrArg(\"No such field\"));\n+  EXPECT_THAT(Run({\"ft.tagvals\", \"i1\", \"dummy\"}), ErrArg(\"Not a tag field\"));\n+  auto resp = Run({\"ft.tagvals\", \"i1\", \"color\"});\n+  ASSERT_THAT(resp, IsUnordArray(\"red\", \"blue\", \"green\"));\n \n   // Tags don't participate in full text search\n   EXPECT_THAT(Run({\"ft.search\", \"i1\", \"red\"}), kNoResults);\n@@ -323,6 +329,14 @@ TEST_F(SearchFamilyTest, Tags) {\n               AreDocIds(\"d:1\", \"d:2\", \"d:3\", \"d:4\", \"d:5\"));\n   EXPECT_THAT(Run({\"ft.search\", \"i1\", \"@color:{blue | green}\"}),\n               AreDocIds(\"d:1\", \"d:2\", \"d:3\", \"d:5\", \"d:6\"));\n+\n+  EXPECT_EQ(Run({\"ft.create\", \"i2\", \"on\", \"hash\", \"schema\", \"c1\", \"as\", \"c2\", \"tag\"}), \"OK\");\n+\n+  // TODO: there is a discrepancy here between redis stack and Dragonfly,\n+  // we accept the original field when it has alias, while redis stack does not.\n+  //\n+  // EXPECT_THAT(Run({\"ft.tagvals\", \"i2\", \"c1\"}), ErrArg(\"No such field\"));\n+  EXPECT_THAT(Run({\"ft.tagvals\", \"i2\", \"c2\"}), ArrLen(0));\n }\n \n TEST_F(SearchFamilyTest, TagOptions) {\n",
  "problem_statement": "implement FT.TAGVALS\n\n",
  "hints_text": "",
  "created_at": "2024-08-10T17:42:00Z",
  "modified_files": [
    "src/core/search/indices.cc",
    "src/core/search/indices.h",
    "src/facade/error.h",
    "src/facade/facade.cc",
    "src/server/search/doc_index.cc",
    "src/server/search/doc_index.h",
    "src/server/search/search_family.cc",
    "src/server/search/search_family.h"
  ],
  "modified_test_files": [
    "src/server/search/search_family_test.cc"
  ]
}