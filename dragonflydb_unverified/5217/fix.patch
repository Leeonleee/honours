diff --git a/.clang-tidy b/.clang-tidy
index 17e45ba8bd06..000490c9a8b9 100644
--- a/.clang-tidy
+++ b/.clang-tidy
@@ -8,11 +8,13 @@ Checks: >
   -bugprone-easily-swappable-parameters,
   -bugprone-branch-clone,
   -bugprone-implicit-widening-of-multiplication-result,
+  -bugprone-too-small-loop-variable,
+  -bugprone-reserved-identifier,
   boost-use-to-string,
   performance*,
-  cert*,
   -cert-err58-cpp,
   -cert-dcl58-cpp,  # Ignore std changes
+  -cert-dcl51-cpp,  # bugprone-reserved-identifier
   # Doesn't work with abseil flags
   clang-analyzer*,
   google-*,
diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc
index d8ca3e455340..2b48a260226f 100644
--- a/src/facade/dragonfly_connection.cc
+++ b/src/facade/dragonfly_connection.cc
@@ -1809,8 +1809,9 @@ void Connection::SendAsync(MessageHandle msg) {
   DCHECK_EQ(ProactorBase::me(), socket_->proactor());
 
   // "Closing" connections might be still processing commands, as we don't interrupt them.
-  // So we still want to deliver control messages to them (like checkpoints).
-  if (cc_->conn_closing && !msg.IsControl())
+  // So we still want to deliver control messages to them (like checkpoints) if
+  // async_fb_ is running (joinable).
+  if (cc_->conn_closing && (!msg.IsControl() || !async_fb_.IsJoinable()))
     return;
 
   // If we launch while closing, it won't be awaited. Control messages will be processed on cleanup.
diff --git a/src/server/transaction.cc b/src/server/transaction.cc
index efdf09b3dc7e..74d87b0b4c09 100644
--- a/src/server/transaction.cc
+++ b/src/server/transaction.cc
@@ -512,6 +512,7 @@ void Transaction::MultiSwitchCmd(const CommandId* cid) {
 
   for (auto& sd : shard_data_) {
     sd.slice_count = sd.slice_start = 0;
+    sd.fp_start = sd.fp_count = 0;  // Reset fingerprints span as kv_fp_ was cleared above.
 
     if (multi_->mode == NON_ATOMIC) {
       sd.local_mask = 0;  // Non atomic transactions schedule each time, so remove all flags
@@ -1325,7 +1326,7 @@ OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeys wkeys, KeyReady
 
   // If we don't follow up with an "action" hop, we must clean up manually on all shards.
   if (result != OpStatus::OK)
-    ExpireBlocking(std::move(wkeys));
+    ExpireBlocking(wkeys);
 
   return result;
 }
@@ -1515,7 +1516,7 @@ void Transaction::ReviveAutoJournal() {
   re_enabled_auto_journal_ = true;
 }
 
-void Transaction::CancelBlocking(std::function<OpStatus(ArgSlice)> status_cb) {
+void Transaction::CancelBlocking(const std::function<OpStatus(ArgSlice)>& status_cb) {
   // We're on the owning thread of this transaction, so we can safely access it's data below.
   // First, check if it makes sense to proceed.
   if (blocking_barrier_.IsClaimed() || cid_ == nullptr || (cid_->opt_mask() & CO::BLOCKING) == 0)
@@ -1610,7 +1611,7 @@ OpResult<KeyIndex> DetermineKeys(const CommandId* cid, CmdArgList args) {
 
   if (cid->first_key_pos() > 0) {
     start = cid->first_key_pos() - 1;
-    int last = cid->last_key_pos();
+    int8_t last = cid->last_key_pos();
 
     if (num_custom_keys >= 0) {
       end = start + num_custom_keys;
diff --git a/src/server/transaction.h b/src/server/transaction.h
index aed8593be450..6d50b9f08e5f 100644
--- a/src/server/transaction.h
+++ b/src/server/transaction.h
@@ -225,7 +225,7 @@ class Transaction {
 
   // Cancel all blocking watches. Set COORD_CANCELLED.
   // Must be called from coordinator thread.
-  void CancelBlocking(std::function<OpStatus(ArgSlice)>);
+  void CancelBlocking(const std::function<OpStatus(ArgSlice)>&);
 
   // Prepare a squashed hop on given shards.
   // Only compatible with multi modes that acquire all locks ahead - global and lock_ahead.
