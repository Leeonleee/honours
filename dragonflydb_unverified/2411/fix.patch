diff --git a/src/server/hll_family.cc b/src/server/hll_family.cc
index d67859a25c5d..0afd565afd92 100644
--- a/src/server/hll_family.cc
+++ b/src/server/hll_family.cc
@@ -258,7 +258,12 @@ OpResult<int> PFMergeInternal(CmdArgList args, ConnectionContext* cntx) {
     string_view key = ArgS(args, 0);
     const OpArgs& op_args = t->GetOpArgs(shard);
     auto& db_slice = op_args.shard->db_slice();
-    auto res = db_slice.AddOrFind(t->GetDbContext(), key);
+    DbSlice::AddOrFindResult res;
+    try {
+      res = db_slice.AddOrFind(t->GetDbContext(), key);
+    } catch (const bad_alloc& e) {
+      return OpStatus::OUT_OF_MEMORY;
+    }
     res.it->second.SetString(hll);
     return OpStatus::OK;
   };
diff --git a/src/server/hset_family.cc b/src/server/hset_family.cc
index d6a069e84974..9e2d7d8bb3ac 100644
--- a/src/server/hset_family.cc
+++ b/src/server/hset_family.cc
@@ -168,7 +168,12 @@ OpStatus IncrementValue(optional<string_view> prev_val, IncrByParam* param) {
 
 OpStatus OpIncrBy(const OpArgs& op_args, string_view key, string_view field, IncrByParam* param) {
   auto& db_slice = op_args.shard->db_slice();
-  auto add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  DbSlice::AddOrFindResult add_res;
+  try {
+    add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  } catch (const bad_alloc& e) {
+    return OpStatus::OUT_OF_MEMORY;
+  }
 
   DbTableStats* stats = db_slice.MutableStats(op_args.db_cntx.db_index);
 
diff --git a/src/server/json_family.cc b/src/server/json_family.cc
index f9f0b1617a31..7e320f3e65ec 100644
--- a/src/server/json_family.cc
+++ b/src/server/json_family.cc
@@ -1076,7 +1076,12 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
       }
     }
 
-    SetJson(op_args, key, std::move(parsed_json.value()));
+    try {
+      SetJson(op_args, key, std::move(parsed_json.value()));
+
+    } catch (const bad_alloc& e) {
+      return OpStatus::OUT_OF_MEMORY;
+    }
     return true;
   }
 
@@ -1154,7 +1159,9 @@ void JsonFamily::Set(CmdArgList args, ConnectionContext* cntx) {
   };
 
   Transaction* trans = cntx->transaction;
+
   OpResult<bool> result = trans->ScheduleSingleHopT(std::move(cb));
+
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
   if (result) {
     if (*result) {
diff --git a/src/server/string_family.cc b/src/server/string_family.cc
index c04189f36574..dcee11858e27 100644
--- a/src/server/string_family.cc
+++ b/src/server/string_family.cc
@@ -88,24 +88,29 @@ OpResult<uint32_t> OpSetRange(const OpArgs& op_args, string_view key, size_t sta
     }
   }
 
-  auto res = db_slice.AddOrFind(op_args.db_cntx, key);
+  DbSlice::AddOrFindResult res;
 
-  string s;
+  try {
+    res = db_slice.AddOrFind(op_args.db_cntx, key);
 
-  if (res.is_new) {
-    s.resize(range_len);
-  } else {
-    if (res.it->second.ObjType() != OBJ_STRING)
-      return OpStatus::WRONG_TYPE;
+    string s;
 
-    s = GetString(op_args.shard, res.it->second);
-    if (s.size() < range_len)
+    if (res.is_new) {
       s.resize(range_len);
-  }
+    } else {
+      if (res.it->second.ObjType() != OBJ_STRING)
+        return OpStatus::WRONG_TYPE;
 
-  memcpy(s.data() + start, value.data(), value.size());
-  res.it->second.SetString(s);
+      s = GetString(op_args.shard, res.it->second);
+      if (s.size() < range_len)
+        s.resize(range_len);
+    }
 
+    memcpy(s.data() + start, value.data(), value.size());
+    res.it->second.SetString(s);
+  } catch (const std::bad_alloc& e) {
+    return OpStatus::OUT_OF_MEMORY;
+  }
   return res.it->second.Size();
 }
 
@@ -161,7 +166,12 @@ OpResult<uint32_t> ExtendOrSet(const OpArgs& op_args, string_view key, string_vi
                                bool prepend) {
   auto* shard = op_args.shard;
   auto& db_slice = shard->db_slice();
-  auto add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  DbSlice::AddOrFindResult add_res;
+  try {
+    add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  } catch (const std::bad_alloc& e) {
+    return OpStatus::OUT_OF_MEMORY;
+  }
   if (add_res.is_new) {
     add_res.it->second.SetString(val);
     return val.size();
@@ -224,7 +234,12 @@ OpResult<string> OpMutableGet(const OpArgs& op_args, string_view key, bool del_h
 
 OpResult<double> OpIncrFloat(const OpArgs& op_args, string_view key, double val) {
   auto& db_slice = op_args.shard->db_slice();
-  auto add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  DbSlice::AddOrFindResult add_res;
+  try {
+    add_res = db_slice.AddOrFind(op_args.db_cntx, key);
+  } catch (const std::bad_alloc& e) {
+    return OpStatus::OUT_OF_MEMORY;
+  }
 
   char buf[128];
 
@@ -1351,7 +1366,7 @@ void StringFamily::SetRange(CmdArgList args, ConnectionContext* cntx) {
   Transaction* trans = cntx->transaction;
   OpResult<uint32_t> result = trans->ScheduleSingleHopT(std::move(cb));
 
-  if (result.status() == OpStatus::WRONG_TYPE) {
+  if (!result.ok()) {
     cntx->SendError(result.status());
   } else {
     cntx->SendLong(result.value());
