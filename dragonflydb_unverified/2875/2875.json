{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2875,
  "instance_id": "dragonflydb__dragonfly-2875",
  "issue_numbers": [
    "2857"
  ],
  "base_commit": "dd437693f66b1a14b30516cc3d305344fe7a2d73",
  "patch": "diff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 9b1354ca356c..10a0115de75a 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -850,10 +850,20 @@ OpResult<string> BPopPusher::RunSingle(ConnectionContext* cntx, time_point tp) {\n   auto cb_move = [&](Transaction* t, EngineShard* shard) {\n     OpArgs op_args = t->GetOpArgs(shard);\n     op_res = OpMoveSingleShard(op_args, pop_key_, push_key_, popdir_, pushdir_);\n-    if (op_res && op_args.shard->journal()) {\n-      std::array<string_view, 4> arr = {pop_key_, push_key_, DirToSv(popdir_), DirToSv(pushdir_)};\n-      RecordJournal(op_args, \"LMOVE\", arr, 1);\n+    if (op_res) {\n+      if (op_args.shard->journal()) {\n+        std::array<string_view, 4> arr = {pop_key_, push_key_, DirToSv(popdir_), DirToSv(pushdir_)};\n+        RecordJournal(op_args, \"LMOVE\", arr, 1);\n+      }\n+      if (shard->blocking_controller()) {\n+        string tmp;\n+\n+        shard->blocking_controller()->AwakeWatched(op_args.db_cntx.db_index, push_key_);\n+        absl::StrAppend(debugMessages.Next(), \"OpPush AwakeWatched: \", push_key_, \" by \",\n+                        op_args.tx->DebugId());\n+      }\n     }\n+\n     return OpStatus::OK;\n   };\n   t->Execute(cb_move, false);\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex 3284ead5ea2b..817b54256b74 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -642,6 +642,23 @@ TEST_F(ListFamilyTest, BRPopLPushSingleShard) {\n   ASSERT_EQ(0, NumWatched());\n }\n \n+TEST_F(ListFamilyTest, BRPopLPushSingleShardBug2857) {\n+  Run({\"lpush\", \"src\", \"val1\"});\n+  RespExpr resp;\n+  auto blpop = [&]() { resp = Run(\"id\", {\"blpop\", \"dest\", \"4\"}); };\n+  auto f = pp_->at(1)->LaunchFiber(Launch::dispatch, blpop);\n+  EXPECT_THAT(Run({\"brpoplpush\", \"src\", \"dest\", \"1\"}), \"val1\");\n+  f.Join();\n+  EXPECT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"dest\", \"val1\"));\n+\n+  // Timeout\n+  f = pp_->at(1)->LaunchFiber(Launch::dispatch, blpop);\n+  EXPECT_THAT(Run({\"brpoplpush\", \"src\", \"dest\", \"1\"}), ArgType(RespExpr::NIL));\n+  f.Join();\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+}\n+\n TEST_F(ListFamilyTest, BRPopLPushSingleShardBlocking) {\n   RespExpr resp;\n \n",
  "problem_statement": "brpoplpush does not wakes blocked transactions waiting on key after pushing to key\nThe behavior is reproduced only when brpoplpush source and dest key are on the same shard.\r\nTo reproduce run on dragonfly with 4 proactor threads (just to make sure brpoplpush runs on single shard):\r\n1. `blpop dest7 10`\r\n2. `brpoplpush src dest7 5`\r\n3. `lpush src value`\r\n\r\nexpected behaviour:\r\nblpop return with \r\n1) \"dest7\"\r\n2) \"value\"\r\n\r\nNow blpop returns nil after waiting 10 seconds and timeout\r\n\r\n\n",
  "hints_text": "oh wow, nice one.",
  "created_at": "2024-04-09T15:52:18Z",
  "modified_files": [
    "src/server/list_family.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}