diff --git a/src/server/debugcmd.cc b/src/server/debugcmd.cc
index 9268f5a830ad..435a0de5057e 100644
--- a/src/server/debugcmd.cc
+++ b/src/server/debugcmd.cc
@@ -783,6 +783,8 @@ void DebugCmd::Populate(CmdArgList args, facade::SinkReplyBuilder* builder) {
   if (!options.has_value()) {
     return;
   }
+  DCHECK(sf_.AreAllReplicasInStableSync());
+
   ProactorPool& pp = sf_.service().proactor_pool();
   size_t runners_count = pp.size();
   vector<pair<uint64_t, uint64_t>> ranges(runners_count - 1);
@@ -808,6 +810,8 @@ void DebugCmd::Populate(CmdArgList args, facade::SinkReplyBuilder* builder) {
     fb.Join();
 
   builder->SendOk();
+
+  DCHECK(sf_.AreAllReplicasInStableSync());
 }
 
 void DebugCmd::PopulateRangeFiber(uint64_t from, uint64_t num_of_keys,
diff --git a/src/server/dflycmd.cc b/src/server/dflycmd.cc
index 57f092124e8d..139b7dd966ba 100644
--- a/src/server/dflycmd.cc
+++ b/src/server/dflycmd.cc
@@ -44,20 +44,6 @@ using namespace util;
 using std::string;
 using util::ProactorBase;
 
-namespace {
-const char kBadMasterId[] = "bad master id";
-const char kIdNotFound[] = "syncid not found";
-const char kInvalidSyncId[] = "bad sync id";
-const char kInvalidState[] = "invalid state";
-
-bool ToSyncId(string_view str, uint32_t* num) {
-  if (!absl::StartsWith(str, "SYNC"))
-    return false;
-  str.remove_prefix(4);
-
-  return absl::SimpleAtoi(str, num);
-}
-
 std::string_view SyncStateName(DflyCmd::SyncState sync_state) {
   switch (sync_state) {
     case DflyCmd::SyncState::PREPARATION:
@@ -73,6 +59,20 @@ std::string_view SyncStateName(DflyCmd::SyncState sync_state) {
   return "unsupported";
 }
 
+namespace {
+const char kBadMasterId[] = "bad master id";
+const char kIdNotFound[] = "syncid not found";
+const char kInvalidSyncId[] = "bad sync id";
+const char kInvalidState[] = "invalid state";
+
+bool ToSyncId(string_view str, uint32_t* num) {
+  if (!absl::StartsWith(str, "SYNC"))
+    return false;
+  str.remove_prefix(4);
+
+  return absl::SimpleAtoi(str, num);
+}
+
 bool WaitReplicaFlowToCatchup(absl::Time end_time, const DflyCmd::ReplicaInfo* replica,
                               EngineShard* shard) {
   // We don't want any writes to the journal after we send the `PING`,
diff --git a/src/server/dflycmd.h b/src/server/dflycmd.h
index 8230c0ca67e2..c4715bef637a 100644
--- a/src/server/dflycmd.h
+++ b/src/server/dflycmd.h
@@ -143,7 +143,7 @@ class DflyCmd {
   // Create new sync session. Returns (session_id, number of flows)
   std::pair<uint32_t, unsigned> CreateSyncSession(ConnectionState* state) ABSL_LOCKS_EXCLUDED(mu_);
 
-  // Master side acces method to replication info of that connection.
+  // Master side access method to replication info of that connection.
   std::shared_ptr<ReplicaInfo> GetReplicaInfoFromConnection(ConnectionState* state);
 
   // Master-side command. Provides Replica info.
@@ -235,4 +235,6 @@ class DflyCmd {
   mutable util::fb2::Mutex mu_;  // Guard global operations. See header top for locking levels.
 };
 
+std::string_view SyncStateName(DflyCmd::SyncState sync_state);
+
 }  // namespace dfly
diff --git a/src/server/multi_command_squasher.cc b/src/server/multi_command_squasher.cc
index df109fecaef3..604340a65bbd 100644
--- a/src/server/multi_command_squasher.cc
+++ b/src/server/multi_command_squasher.cc
@@ -168,8 +168,7 @@ bool MultiCommandSquasher::ExecuteStandalone(facade::RedisReplyBuilder* rb, Stor
   return true;
 }
 
-OpStatus MultiCommandSquasher::SquashedHopCb(Transaction* parent_tx, EngineShard* es,
-                                             RespVersion resp_v) {
+OpStatus MultiCommandSquasher::SquashedHopCb(EngineShard* es, RespVersion resp_v) {
   auto& sinfo = sharded_[es->shard_id()];
   DCHECK(!sinfo.cmds.empty());
 
@@ -242,14 +241,13 @@ bool MultiCommandSquasher::ExecuteSquashed(facade::RedisReplyBuilder* rb) {
     auto cb = [this](ShardId sid) { return !sharded_[sid].cmds.empty(); };
     tx->PrepareSquashedMultiHop(base_cid_, cb);
     tx->ScheduleSingleHop(
-        [this, rb](auto* tx, auto* es) { return SquashedHopCb(tx, es, rb->GetRespVersion()); });
+        [this, rb](auto* tx, auto* es) { return SquashedHopCb(es, rb->GetRespVersion()); });
   } else {
-#if 1
     fb2::BlockingCounter bc(num_shards);
     DVLOG(1) << "Squashing " << num_shards << " " << tx->DebugId();
 
     auto cb = [this, tx, bc, rb]() mutable {
-      this->SquashedHopCb(tx, EngineShard::tlocal(), rb->GetRespVersion());
+      this->SquashedHopCb(EngineShard::tlocal(), rb->GetRespVersion());
       bc->Dec();
     };
 
@@ -258,11 +256,6 @@ bool MultiCommandSquasher::ExecuteSquashed(facade::RedisReplyBuilder* rb) {
         shard_set->AddL2(i, cb);
     }
     bc->Wait();
-#else
-    shard_set->RunBlockingInParallel(
-        [this, tx, rb](auto* es) { SquashedHopCb(tx, es, rb->GetRespVersion()); },
-        [this](auto sid) { return !sharded_[sid].cmds.empty(); });
-#endif
   }
 
   uint64_t after_hop = proactor->GetMonotonicTimeNs();
diff --git a/src/server/multi_command_squasher.h b/src/server/multi_command_squasher.h
index 3230b66e460b..dc4158dd00b5 100644
--- a/src/server/multi_command_squasher.h
+++ b/src/server/multi_command_squasher.h
@@ -61,8 +61,7 @@ class MultiCommandSquasher {
   bool ExecuteStandalone(facade::RedisReplyBuilder* rb, StoredCmd* cmd);
 
   // Callback that runs on shards during squashed hop.
-  facade::OpStatus SquashedHopCb(Transaction* parent_tx, EngineShard* es,
-                                 facade::RespVersion resp_v);
+  facade::OpStatus SquashedHopCb(EngineShard* es, facade::RespVersion resp_v);
 
   // Execute all currently squashed commands. Return false if aborting on error.
   bool ExecuteSquashed(facade::RedisReplyBuilder* rb);
diff --git a/src/server/server_family.h b/src/server/server_family.h
index 092622701c35..5e43ed9c5db9 100644
--- a/src/server/server_family.h
+++ b/src/server/server_family.h
@@ -266,6 +266,18 @@ class ServerFamily {
 
   void UpdateMemoryGlobalStats();
 
+  // Return true if no replicas are registered or if all replicas reached stable sync
+  // Used in debug populate to DCHECK insocsistent flows that violate transaction gurantees
+  bool AreAllReplicasInStableSync() const {
+    auto roles = dfly_cmd_->GetReplicasRoleInfo();
+    if (roles.empty()) {
+      return true;
+    }
+    auto match = SyncStateName(DflyCmd::SyncState::STABLE_SYNC);
+    return std::all_of(roles.begin(), roles.end(),
+                       [&match](auto& elem) { return elem.state == match; });
+  }
+
  private:
   bool HasPrivilegedInterface();
   void JoinSnapshotSchedule();
diff --git a/src/server/transaction.cc b/src/server/transaction.cc
index cb631e3780fc..a956ae962c90 100644
--- a/src/server/transaction.cc
+++ b/src/server/transaction.cc
@@ -1114,11 +1114,11 @@ bool Transaction::ScheduleInShard(EngineShard* shard, bool execute_optimistic) {
   // Acquire intent locks. Intent locks are always acquired, even if already locked by others.
   if (!IsGlobal()) {
     lock_args = GetLockArgs(shard->shard_id());
-    bool shard_unlocked = shard->shard_lock()->Check(mode);
+    const bool shard_unlocked = shard->shard_lock()->Check(mode);
 
     // We need to acquire the fp locks because the executing callback
     // within RunCallback below might preempt.
-    bool keys_unlocked = GetDbSlice(shard->shard_id()).Acquire(mode, lock_args);
+    const bool keys_unlocked = GetDbSlice(shard->shard_id()).Acquire(mode, lock_args);
     lock_granted = shard_unlocked && keys_unlocked;
 
     sd.local_mask |= KEYLOCK_ACQUIRED;
@@ -1129,7 +1129,7 @@ bool Transaction::ScheduleInShard(EngineShard* shard, bool execute_optimistic) {
     DVLOG(3) << "Lock granted " << lock_granted << " for trans " << DebugId();
 
     // Check if we can run immediately
-    if (shard_unlocked && execute_optimistic && lock_granted) {
+    if (lock_granted && execute_optimistic) {
       sd.local_mask |= OPTIMISTIC_EXECUTION;
       shard->stats().tx_optimistic_total++;
 
