{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 252,
  "instance_id": "dragonflydb__dragonfly-252",
  "issue_numbers": [
    "240"
  ],
  "base_commit": "55963f764b41e6edcb81e37f36767c8f77294e0e",
  "patch": "diff --git a/src/facade/error.h b/src/facade/error.h\nindex 51913f72927a..4efda1e2a37b 100644\n--- a/src/facade/error.h\n+++ b/src/facade/error.h\n@@ -30,5 +30,6 @@ extern const char kSyntaxErrType[];\n extern const char kScriptErrType[];\n extern const char kIndexOutOfRange[];\n extern const char kOutOfMemory[];\n+extern const char kInvalidNumericResult[];\n \n }  // namespace dfly\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex d75f4aeed96b..3a9ec19f72c9 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -80,6 +80,7 @@ const char kSyntaxErrType[] = \"syntax_error\";\n const char kScriptErrType[] = \"script_error\";\n const char kIndexOutOfRange[] = \"index out of range\";\n const char kOutOfMemory[] = \"Out of memory\";\n+const char kInvalidNumericResult[] = \"result is not a number\";\n \n const char* RespExpr::TypeName(Type t) {\n   switch (t) {\ndiff --git a/src/facade/op_status.h b/src/facade/op_status.h\nindex 84b0c9630298..3d4c7c72d6bf 100644\n--- a/src/facade/op_status.h\n+++ b/src/facade/op_status.h\n@@ -24,6 +24,7 @@ enum class OpStatus : uint16_t {\n   BUSY_GROUP,\n   STREAM_ID_SMALL,\n   ENTRIES_ADDED_SMALL,\n+  INVALID_NUMERIC_RESULT,\n };\n \n class OpResultBase {\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex 08fc0820ee19..1213a6f29e40 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -247,6 +247,9 @@ void RedisReplyBuilder::SendError(OpStatus status) {\n     case OpStatus::BUSY_GROUP:\n       SendError(\"-BUSYGROUP Consumer Group name already exists\");\n       break;\n+    case OpStatus::INVALID_NUMERIC_RESULT:\n+      SendError(kInvalidNumericResult);\n+      break;\n     default:\n       LOG(ERROR) << \"Unsupported status \" << status;\n       SendError(\"Internal error\");\n@@ -340,7 +343,6 @@ void RedisReplyBuilder::SendStringArr(StrPtr str_ptr, uint32_t len) {\n   unsigned vec_indx = 1;\n   string_view src;\n   for (unsigned i = 0; i < len; ++i) {\n-\n     if (holds_alternative<const string_view*>(str_ptr)) {\n       src = get<const string_view*>(str_ptr)[i];\n     } else {\ndiff --git a/src/server/common.cc b/src/server/common.cc\nindex 55dfcc5dd871..91638c00de15 100644\n--- a/src/server/common.cc\n+++ b/src/server/common.cc\n@@ -4,6 +4,7 @@\n \n #include \"server/common.h\"\n \n+#include <absl/strings/charconv.h>\n #include <absl/strings/str_cat.h>\n #include <mimalloc.h>\n \n@@ -163,6 +164,22 @@ bool ParseHumanReadableBytes(std::string_view str, int64_t* num_bytes) {\n   return true;\n }\n \n+bool ParseDouble(string_view src, double* value) {\n+  if (src.empty())\n+    return false;\n+\n+  if (src == \"-inf\") {\n+    *value = -HUGE_VAL;\n+  } else if (src == \"+inf\") {\n+    *value = HUGE_VAL;\n+  } else {\n+    absl::from_chars_result result = absl::from_chars(src.data(), src.end(), *value);\n+    if (int(result.ec) != 0 || result.ptr != src.end() || isnan(*value))\n+      return false;\n+  }\n+  return true;\n+}\n+\n #define ADD(x) (x) += o.x\n \n TieredStats& TieredStats::operator+=(const TieredStats& o) {\ndiff --git a/src/server/common.h b/src/server/common.h\nindex 0194e667a52f..2ac515a1da52 100644\n--- a/src/server/common.h\n+++ b/src/server/common.h\n@@ -112,6 +112,7 @@ inline void ToLower(const MutableSlice* val) {\n }\n \n bool ParseHumanReadableBytes(std::string_view str, int64_t* num_bytes);\n+bool ParseDouble(std::string_view src, double* value);\n const char* ObjTypeName(int type);\n \n const char* RdbTypeName(unsigned type);\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 3d8932ce97aa..f5c62029a989 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -6,7 +6,6 @@\n \n extern \"C\" {\n #include \"redis/object.h\"\n-#include \"redis/util.h\"\n }\n \n #include <absl/strings/str_join.h>\n@@ -29,7 +28,7 @@ using namespace jsoncons;\n using JsonExpression = jsonpath::jsonpath_expression<json>;\n using OptBool = optional<bool>;\n using OptSizeT = optional<size_t>;\n-using JsonReplaceCb = std::function<void(const string&, json&)>;\n+using JsonReplaceCb = function<void(const string&, json&)>;\n using CI = CommandId;\n \n namespace {\n@@ -84,6 +83,27 @@ string JsonType(const json& val) {\n   return \"\";\n }\n \n+template <typename T>\n+void PrintOptVec(ConnectionContext* cntx, const OpResult<vector<optional<T>>>& result) {\n+  if (result->empty()) {\n+    (*cntx)->SendNullArray();\n+  } else {\n+    (*cntx)->StartArray(result->size());\n+    for (auto& it : *result) {\n+      if (it.has_value()) {\n+        if constexpr (is_floating_point_v<T>) {\n+          (*cntx)->SendDouble(*it);\n+        } else {\n+          static_assert(is_integral_v<T>, \"Integral required.\");\n+          (*cntx)->SendLong(*it);\n+        }\n+      } else {\n+        (*cntx)->SendNull();\n+      }\n+    }\n+  }\n+}\n+\n error_code JsonReplace(json& instance, string_view& path, JsonReplaceCb callback) {\n   using evaluator_t = jsoncons::jsonpath::detail::jsonpath_evaluator<json, json&>;\n   using value_type = evaluator_t::value_type;\n@@ -259,8 +279,109 @@ OpResult<vector<OptBool>> OpToggle(const OpArgs& op_args, string_view key, strin\n   return vec;\n }\n \n+template <typename Op>\n+OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, string_view path,\n+                                    double num, Op arithmetic_op) {\n+  OpResult<json> result = GetJson(op_args, key);\n+  if (!result) {\n+    return result.status();\n+  }\n+\n+  bool is_result_overflow = false;\n+  double int_part;\n+  bool has_fractional_part = (modf(num, &int_part) != 0);\n+  json output(json_array_arg);\n+\n+  auto cb = [&](const string& path, json& val) {\n+    if (val.is_number()) {\n+      double result = arithmetic_op(val.as<double>(), num);\n+      if (isinf(result)) {\n+        is_result_overflow = true;\n+        return;\n+      }\n+\n+      if (val.is_double() || has_fractional_part) {\n+        val = result;\n+      } else {\n+        val = (uint64_t)result;\n+      }\n+      output.push_back(val);\n+    } else {\n+      output.push_back(json::null());\n+    }\n+  };\n+\n+  json j = result.value();\n+  error_code ec = JsonReplace(j, path, cb);\n+  if (ec) {\n+    VLOG(1) << \"Failed to evaulate expression on json with error: \" << ec.message();\n+    return OpStatus::SYNTAX_ERR;\n+  }\n+\n+  if (is_result_overflow) {\n+    return OpStatus::INVALID_NUMERIC_RESULT;\n+  }\n+\n+  SetString(op_args, key, j.as_string());\n+  return output.as_string();\n+}\n+\n }  // namespace\n \n+void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view path = ArgS(args, 2);\n+  string_view num = ArgS(args, 3);\n+\n+  double dnum;\n+  if (!ParseDouble(num, &dnum)) {\n+    (*cntx)->SendError(kWrongTypeErr);\n+    return;\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, plus<double>{});\n+  };\n+\n+  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n+  Transaction* trans = cntx->transaction;\n+  OpResult<string> result = trans->ScheduleSingleHopT(move(cb));\n+\n+  if (result) {\n+    DVLOG(1) << \"JSON.NUMINCRBY \" << trans->DebugId() << \": \" << key;\n+    (*cntx)->SendSimpleString(*result);\n+  } else {\n+    (*cntx)->SendError(result.status());\n+  }\n+}\n+\n+void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view path = ArgS(args, 2);\n+  string_view num = ArgS(args, 3);\n+\n+  double dnum;\n+  if (!ParseDouble(num, &dnum)) {\n+    (*cntx)->SendError(kWrongTypeErr);\n+    return;\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, multiplies<double>{});\n+  };\n+\n+  DVLOG(1) << \"Before Get::ScheduleSingleHopT \" << key;\n+  Transaction* trans = cntx->transaction;\n+  OpResult<string> result = trans->ScheduleSingleHopT(move(cb));\n+\n+  if (result) {\n+    DVLOG(1) << \"JSON.NUMMULTBY \" << trans->DebugId() << \": \" << key;\n+    (*cntx)->SendSimpleString(*result);\n+  } else {\n+    (*cntx)->SendError(result.status());\n+  }\n+}\n+\n void JsonFamily::Toggle(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   string_view path = ArgS(args, 2);\n@@ -275,18 +396,7 @@ void JsonFamily::Toggle(CmdArgList args, ConnectionContext* cntx) {\n \n   if (result) {\n     DVLOG(1) << \"JSON.TOGGLE \" << trans->DebugId() << \": \" << key;\n-    if (result->empty()) {\n-      (*cntx)->SendNullArray();\n-    } else {\n-      (*cntx)->StartArray(result->size());\n-      for (auto& it : *result) {\n-        if (it.has_value()) {\n-          (*cntx)->SendLong(*it);\n-        } else {\n-          (*cntx)->SendNull();\n-        }\n-      }\n-    }\n+    PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -353,18 +463,7 @@ void JsonFamily::ArrLen(CmdArgList args, ConnectionContext* cntx) {\n \n   if (result) {\n     DVLOG(1) << \"JSON.ARRLEN \" << trans->DebugId() << \": \" << key;\n-    if (result->empty()) {\n-      (*cntx)->SendNullArray();\n-    } else {\n-      (*cntx)->StartArray(result->size());\n-      for (auto& it : *result) {\n-        if (it.has_value()) {\n-          (*cntx)->SendLong(*it);\n-        } else {\n-          (*cntx)->SendNull();\n-        }\n-      }\n-    }\n+    PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -393,18 +492,7 @@ void JsonFamily::ObjLen(CmdArgList args, ConnectionContext* cntx) {\n \n   if (result) {\n     DVLOG(1) << \"JSON.OBJLEN \" << trans->DebugId() << \": \" << key;\n-    if (result->empty()) {\n-      (*cntx)->SendNullArray();\n-    } else {\n-      (*cntx)->StartArray(result->size());\n-      for (auto& it : *result) {\n-        if (it.has_value()) {\n-          (*cntx)->SendLong(*it);\n-        } else {\n-          (*cntx)->SendNull();\n-        }\n-      }\n-    }\n+    PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -433,18 +521,7 @@ void JsonFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {\n \n   if (result) {\n     DVLOG(1) << \"JSON.STRLEN \" << trans->DebugId() << \": \" << key;\n-    if (result->empty()) {\n-      (*cntx)->SendNullArray();\n-    } else {\n-      (*cntx)->StartArray(result->size());\n-      for (auto& it : *result) {\n-        if (it.has_value()) {\n-          (*cntx)->SendLong(*it);\n-        } else {\n-          (*cntx)->SendNull();\n-        }\n-      }\n-    }\n+    PrintOptVec(cntx, result);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -495,6 +572,10 @@ void JsonFamily::Register(CommandRegistry* registry) {\n   *registry << CI{\"JSON.OBJLEN\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ObjLen);\n   *registry << CI{\"JSON.ARRLEN\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ArrLen);\n   *registry << CI{\"JSON.TOGGLE\", CO::WRITE | CO::DENYOOM | CO::FAST, 3, 1, 1, 1}.HFUNC(Toggle);\n+  *registry << CI{\"JSON.NUMINCRBY\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(\n+      NumIncrBy);\n+  *registry << CI{\"JSON.NUMMULTBY\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(\n+      NumMultBy);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/json_family.h b/src/server/json_family.h\nindex 57565fb971bd..adba4db76567 100644\n--- a/src/server/json_family.h\n+++ b/src/server/json_family.h\n@@ -13,6 +13,7 @@ class ConnectionContext;\n class CommandRegistry;\n using facade::OpResult;\n using facade::OpStatus;\n+using facade::RedisReplyBuilder;\n \n class JsonFamily {\n  public:\n@@ -25,6 +26,8 @@ class JsonFamily {\n   static void ObjLen(CmdArgList args, ConnectionContext* cntx);\n   static void ArrLen(CmdArgList args, ConnectionContext* cntx);\n   static void Toggle(CmdArgList args, ConnectionContext* cntx);\n+  static void NumIncrBy(CmdArgList args, ConnectionContext* cntx);\n+  static void NumMultBy(CmdArgList args, ConnectionContext* cntx);\n };\n \n }  // namespace dfly\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex c4e6320fb1b5..4e88f08eda48 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -11,8 +11,6 @@ extern \"C\" {\n #include \"redis/zset.h\"\n }\n \n-#include <absl/strings/charconv.h>\n-\n #include \"base/logging.h\"\n #include \"base/stl_util.h\"\n #include \"facade/error.h\"\n@@ -531,22 +529,6 @@ void IntervalVisitor::AddResult(const uint8_t* vstr, unsigned vlen, long long vl\n   }\n }\n \n-bool ParseScore(string_view src, double* score) {\n-  if (src.empty())\n-    return false;\n-\n-  if (src == \"-inf\") {\n-    *score = -HUGE_VAL;\n-  } else if (src == \"+inf\") {\n-    *score = HUGE_VAL;\n-  } else {\n-    absl::from_chars_result result = absl::from_chars(src.data(), src.end(), *score);\n-    if (int(result.ec) != 0 || result.ptr != src.end() || isnan(*score))\n-      return false;\n-  }\n-  return true;\n-};\n-\n bool ParseBound(string_view src, ZSetFamily::Bound* bound) {\n   if (src.empty())\n     return false;\n@@ -556,7 +538,7 @@ bool ParseBound(string_view src, ZSetFamily::Bound* bound) {\n     src.remove_prefix(1);\n   }\n \n-  return ParseScore(src, &bound->val);\n+  return ParseDouble(src, &bound->val);\n }\n \n bool ParseLexBound(string_view src, ZSetFamily::LexBound* bound) {\n@@ -956,7 +938,7 @@ void ZSetFamily::ZAdd(CmdArgList args, ConnectionContext* cntx) {\n     string_view cur_arg = ArgS(args, i);\n     double val = 0;\n \n-    if (!ParseScore(cur_arg, &val)) {\n+    if (!ParseDouble(cur_arg, &val)) {\n       VLOG(1) << \"Bad score:\" << cur_arg << \"|\";\n       return (*cntx)->SendError(kInvalidFloatErr);\n     }\n@@ -1135,8 +1117,7 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n     if (shard->shard_id() == dest_shard) {\n       ZParams zparams;\n       zparams.override = true;\n-      add_result =\n-          OpAdd(t->GetOpArgs(shard), zparams, dest_key, ScoredMemberSpan{smvec}).value();\n+      add_result = OpAdd(t->GetOpArgs(shard), zparams, dest_key, ScoredMemberSpan{smvec}).value();\n     }\n     return OpStatus::OK;\n   };\n@@ -1419,8 +1400,7 @@ void ZSetFamily::ZUnionStore(CmdArgList args, ConnectionContext* cntx) {\n     if (shard->shard_id() == dest_shard) {\n       ZParams zparams;\n       zparams.override = true;\n-      add_result =\n-          OpAdd(t->GetOpArgs(shard), zparams, dest_key, ScoredMemberSpan{smvec}).value();\n+      add_result = OpAdd(t->GetOpArgs(shard), zparams, dest_key, ScoredMemberSpan{smvec}).value();\n     }\n     return OpStatus::OK;\n   };\n@@ -1534,7 +1514,6 @@ void ZSetFamily::ZRankGeneric(CmdArgList args, bool reverse, ConnectionContext*\n   string_view member = ArgS(args, 2);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-\n     return OpRank(t->GetOpArgs(shard), key, member, reverse);\n   };\n \n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex edab27060e4c..83eb278f7108 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -262,4 +262,198 @@ TEST_F(JsonFamilyTest, Toggle) {\n   EXPECT_EQ(resp, R\"([true,false,1,null,\"foo\",[],{}])\");\n }\n \n+TEST_F(JsonFamilyTest, NumIncrBy) {\n+  string json = R\"(\n+    {\"e\":1.5,\"a\":1}\n+  )\";\n+\n+  auto resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.a\", \"1.1\"});\n+  EXPECT_EQ(resp, \"[2.1]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.e\", \"1\"});\n+  EXPECT_EQ(resp, \"[2.5]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.e\", \"inf\"});\n+  EXPECT_THAT(resp, ErrArg(\"ERR result is not a number\"));\n+\n+  json = R\"(\n+    {\"e\":1.5,\"a\":1}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.e\", \"1.7e308\"});\n+  EXPECT_EQ(resp, \"[1.7e+308]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.e\", \"1.7e308\"});\n+  EXPECT_THAT(resp, ErrArg(\"ERR result is not a number\"));\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([1,1.7e+308])\");\n+\n+  json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d[*]\", \"10\"});\n+  EXPECT_EQ(resp, \"[11,12,13]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n+  EXPECT_EQ(resp, \"[11,12,13]\");\n+\n+  json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.a[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.b[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.c[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"[2,3]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"[2,3,4]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([[],[2],[2,3],[2,3,4]])\");\n+\n+  json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.a.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.b.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.c.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[2,3]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[2,3,4]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([{},{\"a\":2},{\"a\":2,\"b\":3},{\"a\":2,\"b\":3,\"c\":4}])\");\n+\n+  json = R\"(\n+    {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.a.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[null]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.b.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[null,2]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.c.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[null,null]\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d.*\", \"1\"});\n+  EXPECT_EQ(resp, \"[2,null,4]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([{\"a\":\"a\"},{\"a\":\"a\",\"b\":2},{\"a\":\"a\",\"b\":\"b\"},{\"a\":2,\"b\":\"b\",\"c\":4}])\");\n+}\n+\n+TEST_F(JsonFamilyTest, NumMultBy) {\n+  string json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  auto resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n+  EXPECT_EQ(resp, R\"([2,4,6])\");\n+\n+  json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([[],[2],[2,4],[2,4,6]])\");\n+\n+  json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([{},{\"a\":2},{\"a\":2,\"b\":4},{\"a\":2,\"b\":4,\"c\":6}])\");\n+\n+  json = R\"(\n+    {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"set\", \"json\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[null]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[null,2]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[null,null]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,null,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([{\"a\":\"a\"},{\"a\":\"a\",\"b\":2},{\"a\":\"a\",\"b\":\"b\"},{\"a\":2,\"b\":\"b\",\"c\":6}])\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "implement json.numincrby\nimplement json.numincrby \r\nspec: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/json-numincrby.html\r\n\r\nspecifically:\r\n```\r\njson.set foo $ '{ \"e\": 1.5 , \"a\": 1 }' \r\njson.NUMINCRBY foo $.a 1.1\r\n```\r\nreturns `\"[2.1]\"`\r\n\r\nand `json.NUMINCRBY foo $.e 1` returns  `\"[2.5]\"`\r\nand `json.NUMINCRBY foo $.e 1e10` returns  `\"[1e+10]\"`\r\n\r\nmoreover,\r\n`json.NUMINCRBY foo $.e inf` returns `(error) OVERFLOW Addition would overflow`\r\n\n",
  "hints_text": "```\r\njson.set foo $ '{ \"e\": 1.5 , \"a\": 1 }' \r\njson.NUMINCRBY foo $.e 1.7e308\r\n```\r\nreturns `\"[1.7e+308]\"`\r\nbut then if we call `json.NUMINCRBY foo $.e 1.7e308` again we get \r\n`(error) OVERFLOW Addition would overflow` because max double is ~ `1.8e308`",
  "created_at": "2022-08-23T07:09:47Z"
}