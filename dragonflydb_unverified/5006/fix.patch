diff --git a/src/server/cluster_support.cc b/src/server/cluster_support.cc
index aea847ed015d..47754287da01 100644
--- a/src/server/cluster_support.cc
+++ b/src/server/cluster_support.cc
@@ -17,6 +17,10 @@ ABSL_FLAG(string, cluster_mode, "",
           "Cluster mode supported. Possible values are "
           "'emulated', 'yes' or ''");
 
+ABSL_FLAG(bool, experimental_cluster_shard_by_slot, false,
+          "If true, cluster mode is enabled and sharding is done by slot. "
+          "Otherwise, sharding is done by hash tag.");
+
 namespace dfly {
 
 void UniqueSlotChecker::Add(std::string_view key) {
@@ -43,16 +47,13 @@ optional<SlotId> UniqueSlotChecker::GetUniqueSlotId() const {
   return slot_id_ > kMaxSlotNum ? optional<SlotId>() : slot_id_;
 }
 
-namespace {
-enum class ClusterMode {
-  kUninitialized,
-  kNoCluster,
-  kEmulatedCluster,
-  kRealCluster,
-};
-
+namespace detail {
 ClusterMode cluster_mode = ClusterMode::kUninitialized;
-}  // namespace
+bool cluster_shard_by_slot = false;
+
+}  // namespace detail
+
+using namespace detail;
 
 void InitializeCluster() {
   string cluster_mode_str = absl::GetFlag(FLAGS_cluster_mode);
@@ -67,14 +68,10 @@ void InitializeCluster() {
     LOG(ERROR) << "Invalid value for flag --cluster_mode. Exiting...";
     exit(1);
   }
-}
 
-bool IsClusterEnabled() {
-  return cluster_mode == ClusterMode::kRealCluster;
-}
-
-bool IsClusterEmulated() {
-  return cluster_mode == ClusterMode::kEmulatedCluster;
+  if (cluster_mode != ClusterMode::kNoCluster) {
+    cluster_shard_by_slot = absl::GetFlag(FLAGS_experimental_cluster_shard_by_slot);
+  }
 }
 
 SlotId KeySlot(std::string_view key) {
@@ -82,10 +79,6 @@ SlotId KeySlot(std::string_view key) {
   return crc16(tag.data(), tag.length()) & kMaxSlotNum;
 }
 
-bool IsClusterEnabledOrEmulated() {
-  return IsClusterEnabled() || IsClusterEmulated();
-}
-
 bool IsClusterShardedByTag() {
   return IsClusterEnabledOrEmulated() || LockTagOptions::instance().enabled;
 }
diff --git a/src/server/cluster_support.h b/src/server/cluster_support.h
index 48de740cfd37..01a230531b68 100644
--- a/src/server/cluster_support.h
+++ b/src/server/cluster_support.h
@@ -10,6 +10,20 @@
 
 namespace dfly {
 
+namespace detail {
+
+enum class ClusterMode {
+  kUninitialized,
+  kNoCluster,
+  kEmulatedCluster,
+  kRealCluster,
+};
+
+extern ClusterMode cluster_mode;
+extern bool cluster_shard_by_slot;
+
+};  // namespace detail
+
 using SlotId = std::uint16_t;
 constexpr SlotId kMaxSlotNum = 0x3FFF;
 
@@ -42,9 +56,23 @@ class UniqueSlotChecker {
 SlotId KeySlot(std::string_view key);
 
 void InitializeCluster();
-bool IsClusterEnabled();
-bool IsClusterEmulated();
-bool IsClusterEnabledOrEmulated();
+
+inline bool IsClusterEnabled() {
+  return detail::cluster_mode == detail::ClusterMode::kRealCluster;
+}
+
+inline bool IsClusterEmulated() {
+  return detail::cluster_mode == detail::ClusterMode::kEmulatedCluster;
+}
+
+inline bool IsClusterEnabledOrEmulated() {
+  return IsClusterEnabled() || IsClusterEmulated();
+}
+
+inline bool IsClusterShardedBySlot() {
+  return detail::cluster_shard_by_slot;
+}
+
 bool IsClusterShardedByTag();
 
 }  // namespace dfly
diff --git a/src/server/engine_shard.cc b/src/server/engine_shard.cc
index 6a36458c75bc..be401c45e4fa 100644
--- a/src/server/engine_shard.cc
+++ b/src/server/engine_shard.cc
@@ -261,6 +261,17 @@ __thread EngineShard* EngineShard::shard_ = nullptr;
 uint64_t TEST_current_time_ms = 0;
 
 ShardId Shard(string_view v, ShardId shard_num) {
+  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.
+  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and
+  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.
+  // Yes, SlotId function does not have great distribution properties.
+  // On the other side, slot based sharding may help with pipeline squashing optimizations,
+  // because they rely on commands being single-sharded.
+  // TODO: once we improve our squashing logic, we can remove this.
+  if (IsClusterShardedBySlot()) {
+    return KeySlot(v) % shard_num;
+  }
+
   if (IsClusterShardedByTag()) {
     v = LockTagOptions::instance().Tag(v);
   }
