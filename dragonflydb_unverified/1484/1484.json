{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1484,
  "instance_id": "dragonflydb__dragonfly-1484",
  "issue_numbers": [
    "1320"
  ],
  "base_commit": "3ebfdb1e1997425455070e47ee968fb74207133c",
  "patch": "diff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 6ccb056d43c3..c1c6732ec325 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -18,6 +18,7 @@\n #include \"server/conn_context.h\"\n #include \"server/dflycmd.h\"\n #include \"server/error.h\"\n+#include \"server/journal/journal.h\"\n #include \"server/main_service.h\"\n #include \"server/replica.h\"\n #include \"server/server_family.h\"\n@@ -392,7 +393,7 @@ void ClusterFamily::DflyCluster(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendError(kClusterDisabled);\n   }\n \n-  if (!cntx->owner()->IsAdmin()) {\n+  if (cntx->owner() && !cntx->owner()->IsAdmin()) {\n     return (*cntx)->SendError(kDflyClusterCmdPort);\n   }\n \n@@ -404,6 +405,8 @@ void ClusterFamily::DflyCluster(CmdArgList args, ConnectionContext* cntx) {\n     return DflyClusterConfig(args, cntx);\n   } else if (sub_cmd == \"MYID\") {\n     return DflyClusterMyId(args, cntx);\n+  } else if (sub_cmd == \"FLUSHSLOTS\") {\n+    return DflyClusterFlushSlots(args, cntx);\n   }\n \n   return (*cntx)->SendError(UnknownSubCmd(sub_cmd, \"DFLYCLUSTER\"), kSyntaxErrType);\n@@ -429,6 +432,59 @@ SlotSet GetDeletedSlots(bool is_first_config, const SlotSet& before, const SlotS\n \n // Guards set configuration, so that we won't handle 2 in parallel.\n Mutex set_config_mu;\n+\n+void DeleteSlots(const SlotSet& slots) {\n+  if (slots.empty()) {\n+    return;\n+  }\n+\n+  auto cb = [&](auto*) {\n+    EngineShard* shard = EngineShard::tlocal();\n+    if (shard == nullptr)\n+      return;\n+\n+    shard->db_slice().FlushSlots(slots);\n+  };\n+  shard_set->pool()->AwaitFiberOnAll(std::move(cb));\n+}\n+\n+void WriteFlushSlotsToJournal(const SlotSet& slots) {\n+  if (slots.empty()) {\n+    return;\n+  }\n+\n+  // Build args\n+  vector<string> args;\n+  args.reserve(slots.size() + 1);\n+  args.push_back(\"FLUSHSLOTS\");\n+  for (const SlotId slot : slots) {\n+    args.push_back(absl::StrCat(slot));\n+  }\n+\n+  // Build view\n+  vector<string_view> args_view(args.size());\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    args_view[i] = args[i];\n+  }\n+\n+  auto cb = [&](auto*) {\n+    EngineShard* shard = EngineShard::tlocal();\n+    if (shard == nullptr) {\n+      return;\n+    }\n+\n+    auto journal = EngineShard::tlocal()->journal();\n+    if (journal == nullptr) {\n+      return;\n+    }\n+\n+    // Send journal entry\n+    journal->RecordEntry(/* txid= */ 0, journal::Op::COMMAND, /* dbid= */ 0,\n+                         /* shard_cnt= */ shard_set->size(), make_pair(\"DFLYCLUSTER\", args_view),\n+                         false);\n+  };\n+  shard_set->pool()->AwaitFiberOnAll(std::move(cb));\n+}\n }  // namespace\n \n void ClusterFamily::DflyClusterConfig(CmdArgList args, ConnectionContext* cntx) {\n@@ -468,17 +524,10 @@ void ClusterFamily::DflyClusterConfig(CmdArgList args, ConnectionContext* cntx)\n \n   SlotSet after = tl_cluster_config->GetOwnedSlots();\n \n-  // Delete old slots data.\n-  SlotSet deleted_slot_ids = GetDeletedSlots(is_first_config, before, after);\n-  if (!deleted_slot_ids.empty()) {\n-    auto cb = [&](auto*) {\n-      EngineShard* shard = EngineShard::tlocal();\n-      if (shard == nullptr)\n-        return;\n-\n-      shard->db_slice().FlushSlots(deleted_slot_ids);\n-    };\n-    shard_set->pool()->AwaitFiberOnAll(std::move(cb));\n+  if (ServerState::tlocal()->is_master) {\n+    auto deleted_slots = GetDeletedSlots(is_first_config, before, after);\n+    DeleteSlots(deleted_slots);\n+    WriteFlushSlotsToJournal(deleted_slots);\n   }\n \n   return rb->SendOk();\n@@ -537,6 +586,26 @@ void ClusterFamily::DflyClusterGetSlotInfo(CmdArgList args, ConnectionContext* c\n   }\n }\n \n+void ClusterFamily::DflyClusterFlushSlots(CmdArgList args, ConnectionContext* cntx) {\n+  SinkReplyBuilder* rb = cntx->reply_builder();\n+\n+  args.remove_prefix(1);  // Removes \"FLUSHSLOTS\" subcmd string\n+\n+  SlotSet slots;\n+  slots.reserve(args.size());\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    unsigned slot;\n+    if (!absl::SimpleAtoi(ArgS(args, i), &slot) || (slot > ClusterConfig::kMaxSlotNum)) {\n+      return rb->SendError(kSyntaxErrType);\n+    }\n+    slots.insert(static_cast<SlotId>(slot));\n+  }\n+\n+  DeleteSlots(slots);\n+\n+  return rb->SendOk();\n+}\n+\n using EngineFunc = void (ClusterFamily::*)(CmdArgList args, ConnectionContext* cntx);\n \n inline CommandId::Handler HandlerFunc(ClusterFamily* se, EngineFunc f) {\ndiff --git a/src/server/cluster/cluster_family.h b/src/server/cluster/cluster_family.h\nindex 49538379aca1..a8b9d4816458 100644\n--- a/src/server/cluster/cluster_family.h\n+++ b/src/server/cluster/cluster_family.h\n@@ -46,6 +46,7 @@ class ClusterFamily {\n   void DflyClusterConfig(CmdArgList args, ConnectionContext* cntx);\n   void DflyClusterGetSlotInfo(CmdArgList args, ConnectionContext* cntx);\n   void DflyClusterMyId(CmdArgList args, ConnectionContext* cntx);\n+  void DflyClusterFlushSlots(CmdArgList args, ConnectionContext* cntx);\n \n   ClusterConfig::ClusterShard GetEmulatedShardInfo(ConnectionContext* cntx) const;\n \ndiff --git a/src/server/replica.cc b/src/server/replica.cc\nindex 5923f9d68865..10ed2a9e7c1f 100644\n--- a/src/server/replica.cc\n+++ b/src/server/replica.cc\n@@ -3,6 +3,8 @@\n //\n #include \"server/replica.h\"\n \n+#include \"absl/strings/match.h\"\n+\n extern \"C\" {\n #include \"redis/rdb.h\"\n }\n@@ -1348,7 +1350,24 @@ bool Replica::TransactionData::AddEntry(journal::ParsedEntry&& entry) {\n }\n \n bool Replica::TransactionData::IsGlobalCmd() const {\n-  return commands.size() == 1 && commands.front().cmd_args.size() == 1;\n+  if (commands.size() > 1) {\n+    return false;\n+  }\n+\n+  auto& command = commands.front();\n+  if (command.cmd_args.empty()) {\n+    return false;\n+  }\n+\n+  auto& args = command.cmd_args;\n+  if (absl::EqualsIgnoreCase(ToSV(args[0]), \"FLUSHDB\"sv) ||\n+      absl::EqualsIgnoreCase(ToSV(args[0]), \"FLUSHALL\"sv) ||\n+      (absl::EqualsIgnoreCase(ToSV(args[0]), \"DFLYCLUSTER\"sv) &&\n+       absl::EqualsIgnoreCase(ToSV(args[1]), \"FLUSHSLOTS\"sv))) {\n+    return true;\n+  }\n+\n+  return false;\n }\n \n Replica::TransactionData Replica::TransactionData::FromSingle(journal::ParsedEntry&& entry) {\n",
  "test_patch": "diff --git a/src/server/cluster/cluster_family_test.cc b/src/server/cluster/cluster_family_test.cc\nindex 92c886e767a6..11aaf10ae1f2 100644\n--- a/src/server/cluster/cluster_family_test.cc\n+++ b/src/server/cluster/cluster_family_test.cc\n@@ -47,6 +47,10 @@ class ClusterFamilyTest : public BaseFamilyTest {\n     EXPECT_LE(absl::Now(), deadline)\n         << \"Timeout of \" << timeout << \" reached when expecting condition\";\n   }\n+\n+  string GetMyId() {\n+    return RunAdmin({\"dflycluster\", \"myid\"}).GetString();\n+  }\n };\n \n TEST_F(ClusterFamilyTest, DflyClusterOnlyOnAdminPort) {\n@@ -474,7 +478,7 @@ TEST_F(ClusterFamilyTest, ClusterGetSlotInfo) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n \n@@ -528,7 +532,7 @@ TEST_F(ClusterFamilyTest, ClusterSlotsPopulate) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n \n@@ -563,7 +567,7 @@ TEST_F(ClusterFamilyTest, ClusterConfigDeleteSlots) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n \n@@ -608,7 +612,7 @@ TEST_F(ClusterFamilyTest, ClusterConfigDeleteSlotsNoCrashOnShutdown) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n \n@@ -659,7 +663,7 @@ TEST_F(ClusterFamilyTest, ClusterConfigDeleteSomeSlots) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n \n@@ -733,6 +737,34 @@ TEST_F(ClusterFamilyTest, Keyslot) {\n             CheckedInt({\"cluster\", \"keyslot\", \"123{def}456\"}));\n }\n \n+TEST_F(ClusterFamilyTest, FlushSlots) {\n+  EXPECT_EQ(Run({\"debug\", \"populate\", \"100\", \"key\", \"4\", \"slots\", \"0\", \"1\"}), \"OK\");\n+\n+  EXPECT_THAT(RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"0\", \"1\"}),\n+              RespArray(ElementsAre(RespArray(ElementsAre(IntArg(0), \"key_count\", Not(IntArg(0)),\n+                                                          \"total_reads\", _, \"total_writes\", _)),\n+                                    RespArray(ElementsAre(IntArg(1), \"key_count\", Not(IntArg(0)),\n+                                                          \"total_reads\", _, \"total_writes\", _)))));\n+\n+  ExpectConditionWithinTimeout([&]() {\n+    return RunAdmin({\"dflycluster\", \"flushslots\", \"0\"}) == \"OK\";\n+  });\n+\n+  EXPECT_THAT(RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"0\", \"1\"}),\n+              RespArray(ElementsAre(RespArray(ElementsAre(IntArg(0), \"key_count\", IntArg(0),\n+                                                          \"total_reads\", _, \"total_writes\", _)),\n+                                    RespArray(ElementsAre(IntArg(1), \"key_count\", Not(IntArg(0)),\n+                                                          \"total_reads\", _, \"total_writes\", _)))));\n+\n+  EXPECT_EQ(RunAdmin({\"dflycluster\", \"flushslots\", \"0\", \"1\"}), \"OK\");\n+\n+  EXPECT_THAT(RunAdmin({\"dflycluster\", \"getslotinfo\", \"slots\", \"0\", \"1\"}),\n+              RespArray(ElementsAre(RespArray(ElementsAre(IntArg(0), \"key_count\", IntArg(0),\n+                                                          \"total_reads\", _, \"total_writes\", _)),\n+                                    RespArray(ElementsAre(IntArg(1), \"key_count\", IntArg(0),\n+                                                          \"total_reads\", _, \"total_writes\", _)))));\n+}\n+\n TEST_F(ClusterFamilyTest, ClusterCrossSlot) {\n   string config_template = R\"json(\n       [\n@@ -751,7 +783,7 @@ TEST_F(ClusterFamilyTest, ClusterCrossSlot) {\n           \"replicas\": []\n         }\n       ])json\";\n-  string config = absl::Substitute(config_template, RunAdmin({\"dflycluster\", \"myid\"}).GetString());\n+  string config = absl::Substitute(config_template, GetMyId());\n \n   EXPECT_EQ(RunAdmin({\"dflycluster\", \"config\", config}), \"OK\");\n   EXPECT_EQ(Run({\"SET\", \"key\", \"value\"}), \"OK\");\n@@ -767,7 +799,7 @@ TEST_F(ClusterFamilyTest, ClusterCrossSlot) {\n   EXPECT_THAT(Run({\"MGET\", \"key{tag}\", \"key2{tag}\"}), RespArray(ElementsAre(\"value\", \"value2\")));\n }\n \n-class ClusterFamilyEmulatedTest : public BaseFamilyTest {\n+class ClusterFamilyEmulatedTest : public ClusterFamilyTest {\n  public:\n   ClusterFamilyEmulatedTest() {\n     SetTestFlag(\"cluster_mode\", \"emulated\");\n@@ -786,17 +818,17 @@ TEST_F(ClusterFamilyEmulatedTest, ClusterInfo) {\n \n TEST_F(ClusterFamilyEmulatedTest, ClusterShards) {\n   EXPECT_THAT(Run({\"cluster\", \"shards\"}),\n-              RespArray(ElementsAre(\"slots\",                                                      //\n-                                    RespArray(ElementsAre(IntArg(0), IntArg(16383))),             //\n-                                    \"nodes\",                                                      //\n-                                    RespArray(ElementsAre(                                        //\n-                                        RespArray(ElementsAre(                                    //\n-                                            \"id\", RunAdmin({\"dflycluster\", \"myid\"}).GetString(),  //\n-                                            \"endpoint\", \"fake-host\",                              //\n-                                            \"ip\", \"fake-host\",                                    //\n-                                            \"port\", IntArg(6379),                                 //\n-                                            \"role\", \"master\",                                     //\n-                                            \"replication-offset\", IntArg(0),                      //\n+              RespArray(ElementsAre(\"slots\",                                           //\n+                                    RespArray(ElementsAre(IntArg(0), IntArg(16383))),  //\n+                                    \"nodes\",                                           //\n+                                    RespArray(ElementsAre(                             //\n+                                        RespArray(ElementsAre(                         //\n+                                            \"id\", GetMyId(),                           //\n+                                            \"endpoint\", \"fake-host\",                   //\n+                                            \"ip\", \"fake-host\",                         //\n+                                            \"port\", IntArg(6379),                      //\n+                                            \"role\", \"master\",                          //\n+                                            \"replication-offset\", IntArg(0),           //\n                                             \"health\", \"online\")))))));\n }\n \n@@ -807,13 +839,12 @@ TEST_F(ClusterFamilyEmulatedTest, ClusterSlots) {\n                                     RespArray(ElementsAre(  //\n                                         \"fake-host\",        //\n                                         IntArg(6379),       //\n-                                        RunAdmin({\"dflycluster\", \"myid\"}).GetString())))));\n+                                        GetMyId())))));\n }\n \n TEST_F(ClusterFamilyEmulatedTest, ClusterNodes) {\n   EXPECT_THAT(Run({\"cluster\", \"nodes\"}),\n-              RunAdmin({\"dflycluster\", \"myid\"}).GetString() +\n-                  \" fake-host:6379@6379 myself,master - 0 0 0 connected 0-16383\\r\\n\");\n+              GetMyId() + \" fake-host:6379@6379 myself,master - 0 0 0 connected 0-16383\\r\\n\");\n }\n \n }  // namespace\ndiff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex 5d49e1238a03..dfbae7be0c54 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -378,9 +378,8 @@ async def test_cluster_replica_sets_non_owned_keys(df_local_factory):\n \n     await push_config(replica_config, [c_replica_admin])\n \n-    # The replica should have deleted the key.\n-    # Note: this is not the long-term intended behavior. It will change after we fix #1320.\n-    assert await c_replica.execute_command(\"dbsize\") == 0\n+    # The replica should *not* have deleted the key.\n+    assert await c_replica.execute_command(\"dbsize\") == 1\n \n     # Set another key on the master, which it owns but the replica does not own.\n     await c_master.set(\"key2\", \"value\");\n@@ -388,7 +387,7 @@ async def test_cluster_replica_sets_non_owned_keys(df_local_factory):\n \n     # See that the key exists in both replica and master\n     assert await c_master.execute_command(\"dbsize\") == 2\n-    assert await c_replica.execute_command(\"dbsize\") == 1\n+    assert await c_replica.execute_command(\"dbsize\") == 2\n \n     # The replica should still reply with MOVED, despite having that key.\n     try:\n@@ -397,6 +396,118 @@ async def test_cluster_replica_sets_non_owned_keys(df_local_factory):\n     except redis.exceptions.ResponseError as e:\n         assert re.match(r\"MOVED \\d+ localhost:1111\", e.args[0])\n \n+    await push_config(replica_config, [c_master_admin])\n+    await asyncio.sleep(0.5)\n+    assert await c_master.execute_command(\"dbsize\") == 0\n+    assert await c_replica.execute_command(\"dbsize\") == 0\n+\n+\n+@dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n+async def test_cluster_flush_slots_after_config_change(df_local_factory):\n+    # Start and configure cluster with 1 master and 1 replica, both own all slots\n+    master = df_local_factory.create(port=BASE_PORT, admin_port=BASE_PORT+1000)\n+    replica = df_local_factory.create(port=BASE_PORT+1, admin_port=BASE_PORT+1001)\n+    df_local_factory.start_all([master, replica])\n+\n+    c_master = aioredis.Redis(port=master.port)\n+    c_master_admin = aioredis.Redis(port=master.admin_port)\n+    master_id = await get_node_id(c_master_admin)\n+\n+    c_replica = aioredis.Redis(port=replica.port)\n+    c_replica_admin = aioredis.Redis(port=replica.admin_port)\n+    replica_id = await get_node_id(c_replica_admin)\n+\n+    config = f\"\"\"\n+      [\n+        {{\n+          \"slot_ranges\": [\n+            {{\n+              \"start\": 0,\n+              \"end\": 16383\n+            }}\n+          ],\n+          \"master\": {{\n+            \"id\": \"{master_id}\",\n+            \"ip\": \"localhost\",\n+            \"port\": {master.port}\n+          }},\n+          \"replicas\": [\n+            {{\n+              \"id\": \"{replica_id}\",\n+              \"ip\": \"localhost\",\n+              \"port\": {replica.port}\n+            }}\n+          ]\n+        }}\n+      ]\n+    \"\"\"\n+    await push_config(config, [c_master_admin, c_replica_admin])\n+\n+    await c_master.execute_command(\"debug\", \"populate\", \"100000\");\n+    assert await c_master.execute_command(\"dbsize\") == 100_000\n+\n+    # Setup replication and make sure that it works properly.\n+    await c_replica.execute_command(\"REPLICAOF\", \"localhost\", master.port)\n+    await check_all_replicas_finished([c_replica], c_master)\n+    assert await c_replica.execute_command(\"dbsize\") == 100_000\n+\n+    resp = await c_master_admin.execute_command(\"dflycluster\", \"getslotinfo\", \"slots\", \"0\")\n+    assert resp[0][0] == 0\n+    slot_0_size = resp[0][2]\n+    print(f'Slot 0 size = {slot_0_size}')\n+    assert slot_0_size > 0\n+\n+    config = f\"\"\"\n+      [\n+        {{\n+          \"slot_ranges\": [\n+            {{\n+              \"start\": 1,\n+              \"end\": 16383\n+            }}\n+          ],\n+          \"master\": {{\n+            \"id\": \"{master_id}\",\n+            \"ip\": \"localhost\",\n+            \"port\": {master.port}\n+          }},\n+          \"replicas\": [\n+            {{\n+              \"id\": \"{replica_id}\",\n+              \"ip\": \"localhost\",\n+              \"port\": {replica.port}\n+            }}\n+          ]\n+        }},\n+        {{\n+          \"slot_ranges\": [\n+            {{\n+              \"start\": 0,\n+              \"end\": 0\n+            }}\n+          ],\n+          \"master\": {{\n+            \"id\": \"other-master\",\n+            \"ip\": \"localhost\",\n+            \"port\": 9000\n+          }},\n+          \"replicas\": [\n+            {{\n+              \"id\": \"other-replica\",\n+              \"ip\": \"localhost\",\n+              \"port\": 9001\n+            }}\n+          ]\n+        }}\n+      ]\n+    \"\"\"\n+    await push_config(config, [c_master_admin, c_replica_admin])\n+\n+    await asyncio.sleep(0.5)\n+\n+    assert await c_master.execute_command(\"dbsize\") == (100_000 - slot_0_size)\n+    assert await c_replica.execute_command(\"dbsize\") == (100_000 - slot_0_size)\n+\n \n @dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n async def test_cluster_native_client(df_local_factory):\n",
  "problem_statement": "Handle remove slot from ownership with replica\nWhen executing `DFLYCLUSTER CONFIG` we check for slots that are removed from node ownership and start a fiber to delete this slots data from server. When starting to delete the data we create a new db version, which only entries with version < new version are deleted. The reason for this is that we could get another config update to add the slots to the node ownership, so we want to delete slots data that was inserted before the new config update.\nOn replica when executing `DFLYCLUSTER CONFIG`  we should not delete slots data for slots that are removed from ownership. This is because the update config might arrive to replica in delay from master and this might cause deleting entries which should not be deleted.\nFor example:\nmaster\nt1: config - slot 1,2\nt2: config - slot 1\nstart delete slot 2 entries\nt3: config - slot 1,2\nt4: set x y (x is in slot 2)\n\nreplica:\nt1: config - slot 1,2\nt3: config - slot 1\nt4: set x y (replicated from master)\nt5: config - slot 1,2\n\nIn this example if we deleted slot 2 entries after receiving t3 config we will delete x key entry.\n\nTo handle slot deleting on replica, we will send to replica \"replica flushslots  [slot ids]\" command. This command will be send from master on the config command when slots are removed from ownership. It will be sent on all shards, same as flushall. On replica side we will wait for all replica flushslots commands, as we do on flushall, and execute it once.\n",
  "hints_text": "An easier solution, which on one hand is less error prone with fewer edge cases and easier to program, but on the other hand is definitely more resource consuming, is to just replicate the deletion commands from the master, as if they were regular deletions.\r\nI'm not saying we should definitely go for it, but it is a simpler solution that might be a good middle-ground, at least initially.",
  "created_at": "2023-06-27T10:22:43Z",
  "modified_files": [
    "src/server/cluster/cluster_family.cc",
    "src/server/cluster/cluster_family.h",
    "src/server/replica.cc"
  ],
  "modified_test_files": [
    "src/server/cluster/cluster_family_test.cc",
    "tests/dragonfly/cluster_test.py"
  ]
}