{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3993,
  "instance_id": "dragonflydb__dragonfly-3993",
  "issue_numbers": [
    "3963"
  ],
  "base_commit": "4859077122025d29a81430efd37fece1ba6e9c18",
  "patch": "diff --git a/src/core/bptree_set.h b/src/core/bptree_set.h\nindex ae5240b742db..930187cabbb4 100644\n--- a/src/core/bptree_set.h\n+++ b/src/core/bptree_set.h\n@@ -104,6 +104,10 @@ template <typename T, typename Policy = BPTreePolicy<T>> class BPTree {\n   /// @param path\n   void Delete(BPTreePath path);\n \n+  /// @brief Forces an update to the key. Assumes key has the same value.\n+  /// Replaces old with new_obj.\n+  void ForceUpdate(KeyT old, KeyT new_obj);\n+\n  private:\n   BPTreeNode* CreateNode(bool leaf);\n \n@@ -589,4 +593,15 @@ template <typename T, typename Policy> void BPTree<T, Policy>::DestroyNode(BPTre\n   num_nodes_--;\n }\n \n+template <typename T, typename Policy> void BPTree<T, Policy>::ForceUpdate(KeyT old, KeyT new_obj) {\n+  BPTreePath path;\n+  [[maybe_unused]] bool found = Locate(old, &path);\n+\n+  assert(path.Depth() > 0u);\n+  assert(found);\n+\n+  BPTreeNode* node = path.Last().first;\n+  node->SetKey(path.Last().second, new_obj);\n+}\n+\n }  // namespace dfly\ndiff --git a/src/core/score_map.cc b/src/core/score_map.cc\nindex a905f752172e..fa5fc4f39106 100644\n--- a/src/core/score_map.cc\n+++ b/src/core/score_map.cc\n@@ -148,7 +148,7 @@ detail::SdsScorePair ScoreMap::iterator::BreakToPair(void* obj) {\n \n namespace {\n // Does not Release obj. Callers must do so explicitly if a `Reallocation` happened\n-pair<sds, bool> ReallocIfNeededGeneric(void* obj, float ratio) {\n+pair<sds, bool> DuplicateEntryIfFragmented(void* obj, float ratio) {\n   sds key = (sds)obj;\n   size_t key_len = sdslen(key);\n \n@@ -167,15 +167,15 @@ bool ScoreMap::iterator::ReallocIfNeeded(float ratio, std::function<void(sds, sd\n   bool reallocated = false;\n   auto body = [ratio, &cb, &reallocated](auto* ptr) {\n     auto* obj = ptr->GetObject();\n-    auto [new_obj, realloc] = ReallocIfNeededGeneric(obj, ratio);\n-    if (realloc) {\n+    auto [new_obj, duplicate] = DuplicateEntryIfFragmented(obj, ratio);\n+    if (duplicate) {\n       if (cb) {\n         cb((sds)obj, (sds)new_obj);\n       }\n       sdsfree((sds)obj);\n       ptr->SetObject(new_obj);\n     }\n-    reallocated |= realloc;\n+    reallocated |= duplicate;\n   };\n \n   TraverseApply(curr_entry_, body);\ndiff --git a/src/core/sorted_map.cc b/src/core/sorted_map.cc\nindex 497565525291..60cd43e5c75c 100644\n--- a/src/core/sorted_map.cc\n+++ b/src/core/sorted_map.cc\n@@ -770,10 +770,7 @@ SortedMap* SortedMap::FromListPack(PMR_NS::memory_resource* res, const uint8_t*\n }\n \n bool SortedMap::DefragIfNeeded(float ratio) {\n-  auto cb = [this](sds old_obj, sds new_obj) {\n-    score_tree->Delete(old_obj);\n-    score_tree->Insert(new_obj);\n-  };\n+  auto cb = [this](sds old_obj, sds new_obj) { score_tree->ForceUpdate(old_obj, new_obj); };\n   bool reallocated = false;\n \n   for (auto it = score_map->begin(); it != score_map->end(); ++it) {\n",
  "test_patch": "diff --git a/src/core/bptree_set_test.cc b/src/core/bptree_set_test.cc\nindex 1e4576c348e7..1700a44cf534 100644\n--- a/src/core/bptree_set_test.cc\n+++ b/src/core/bptree_set_test.cc\n@@ -470,4 +470,49 @@ void RegisterBPTreeBench() {\n \n REGISTER_MODULE_INITIALIZER(Bptree, RegisterBPTreeBench());\n \n+TEST_F(BPTreeSetTest, ForceUpdate) {\n+  struct Policy {\n+    // Similar to how it's used in SortedMap just a little simpler.\n+    using KeyT = int*;\n+\n+    struct KeyCompareTo {\n+      int operator()(KeyT a, KeyT b) const {\n+        if (*a < *b)\n+          return -1;\n+        if (*a > *b)\n+          return 1;\n+        return 0;\n+      }\n+    };\n+  };\n+\n+  auto gen_vector = []() {\n+    std::vector<std::unique_ptr<int>> tmp;\n+    for (size_t i = 0; i < 1000; ++i) {\n+      tmp.push_back(std::make_unique<int>(i));\n+    }\n+    return tmp;\n+  };\n+\n+  std::vector<std::unique_ptr<int>> original = gen_vector();\n+  std::vector<std::unique_ptr<int>> modified = gen_vector();\n+\n+  BPTree<int*, Policy> bptree;\n+  for (auto& item : original) {\n+    bptree.Insert(item.get());\n+  }\n+\n+  for (auto& item : modified) {\n+    bptree.ForceUpdate(item.get(), item.get());\n+  }\n+\n+  original.clear();\n+  size_t index = 0;\n+  bptree.Iterate(0, 1000, [&](int* ptr) {\n+    EXPECT_EQ(modified[index].get(), ptr);\n+    ++index;\n+    return true;\n+  });\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Add ForceUpdate(Key) in BPTree to force update pointers in SortedMap\nCurrently, for Defrag logic we use `insert and delete` the node. Since the contents of the node are the same we can just update the pointer directly.\r\n\r\nhttps://github.com/dragonflydb/dragonfly/pull/3836#discussion_r1806503086 \n",
  "hints_text": "",
  "created_at": "2024-10-25T08:15:32Z",
  "modified_files": [
    "src/core/bptree_set.h",
    "src/core/score_map.cc",
    "src/core/sorted_map.cc"
  ],
  "modified_test_files": [
    "src/core/bptree_set_test.cc"
  ]
}