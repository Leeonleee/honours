{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5315,
  "instance_id": "dragonflydb__dragonfly-5315",
  "issue_numbers": [
    "5311"
  ],
  "base_commit": "cdd1dac394e6f7f80203118e4877ae08bb32ab37",
  "patch": "diff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex fd5d8a4e40a3..b7b9c5b3227e 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -451,8 +451,14 @@ DbSlice::AutoUpdater::~AutoUpdater() {\n   Run();\n }\n \n+void DbSlice::AutoUpdater::ReduceHeapUsage() {\n+  AccountObjectMemory(fields_.key, fields_.it->second.ObjType(), -fields_.orig_heap_size,\n+                      fields_.db_slice->GetDBTable(fields_.db_ind));\n+  fields_.orig_heap_size = 0;  // Reset to avoid double accounting.\n+}\n+\n void DbSlice::AutoUpdater::Run() {\n-  if (fields_.action == DestructorAction::kDoNothing) {\n+  if (fields_.db_slice == nullptr) {\n     return;\n   }\n \n@@ -461,7 +467,6 @@ void DbSlice::AutoUpdater::Run() {\n   // updater in scope. You'll probably want to call Run() (or Cancel() - but be careful).\n   DCHECK(IsValid(fields_.db_slice->db_arr_[fields_.db_ind]->prime.Find(fields_.key)));\n \n-  DCHECK(fields_.action == DestructorAction::kRun);\n   CHECK_NE(fields_.db_slice, nullptr);\n \n   ssize_t delta = static_cast<int64_t>(fields_.it->second.MallocUsed()) -\n@@ -478,8 +483,7 @@ void DbSlice::AutoUpdater::Cancel() {\n \n DbSlice::AutoUpdater::AutoUpdater(DbIndex db_ind, std::string_view key, const Iterator& it,\n                                   DbSlice* db_slice)\n-    : fields_{.action = DestructorAction::kRun,\n-              .db_slice = db_slice,\n+    : fields_{.db_slice = db_slice,\n               .db_ind = db_ind,\n               .it = it,\n               .key = key,\ndiff --git a/src/server/db_slice.h b/src/server/db_slice.h\nindex d94ebf9c22dd..62b55fc998b1 100644\n--- a/src/server/db_slice.h\n+++ b/src/server/db_slice.h\n@@ -156,19 +156,16 @@ class DbSlice {\n     AutoUpdater& operator=(AutoUpdater&& o);\n     ~AutoUpdater();\n \n+    // Removes the memory usage attributed to the iterator and resets orig_heap_size.\n+    // Used when the existing object is overridden by a new one.\n+    void ReduceHeapUsage();\n+\n     void Run();\n     void Cancel();\n \n    private:\n-    enum class DestructorAction : uint8_t {\n-      kDoNothing,\n-      kRun,\n-    };\n-\n     // Wrap members in a struct to auto generate operator=\n     struct Fields {\n-      DestructorAction action = DestructorAction::kDoNothing;\n-\n       DbSlice* db_slice = nullptr;\n       DbIndex db_ind = 0;\n \ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 54001845d0cf..ff533770af8f 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -894,6 +894,7 @@ OpResult<void> OpRen(const OpArgs& op_args, string_view from_key, string_view to\n \n   bool sticky = from_res.it->first.IsSticky();\n   uint64_t exp_ts = db_slice.ExpireTime(from_res.exp_it);\n+  from_res.post_updater.ReduceHeapUsage();\n \n   // we keep the value we want to move.\n   PrimeValue from_obj = std::move(from_res.it->second);\n@@ -902,6 +903,7 @@ OpResult<void> OpRen(const OpArgs& op_args, string_view from_key, string_view to\n   from_res.it->second.SetExpire(IsValid(from_res.exp_it));\n \n   if (IsValid(to_res.it)) {\n+    to_res.post_updater.ReduceHeapUsage();\n     to_res.it->second = std::move(from_obj);\n     to_res.it->second.SetExpire(IsValid(to_res.exp_it));  // keep the expire flag on 'to'.\n \ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex 9254bae3e5c1..5fb5524534f1 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -112,10 +112,10 @@ class SetCmd {\n   OpStatus Set(const SetParams& params, std::string_view key, std::string_view value);\n \n  private:\n-  OpStatus SetExisting(const SetParams& params, DbSlice::Iterator it, DbSlice::ExpIterator e_it,\n-                       std::string_view key, std::string_view value);\n+  OpStatus SetExisting(const SetParams& params, std::string_view value,\n+                       DbSlice::ItAndUpdater* it_upd);\n \n-  void AddNew(const SetParams& params, DbSlice::Iterator it, std::string_view key,\n+  void AddNew(const SetParams& params, const DbSlice::Iterator& it, std::string_view key,\n               std::string_view value);\n \n   // Called at the end of AddNew of SetExisting\n@@ -832,7 +832,7 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n \n     if (params.flags & SET_IF_EXISTS) {\n       if (IsValid(find_res.it)) {\n-        return SetExisting(params, find_res.it, find_res.exp_it, key, value);\n+        return SetExisting(params, value, &find_res);\n       } else {\n         return OpStatus::SKIPPED;\n       }\n@@ -851,18 +851,19 @@ OpStatus SetCmd::Set(const SetParams& params, string_view key, string_view value\n     if (auto status = CachePrevIfNeeded(params, op_res->it); status != OpStatus::OK)\n       return status;\n \n-    return SetExisting(params, op_res->it, op_res->exp_it, key, value);\n+    return SetExisting(params, value, &(*op_res));\n   } else {\n     AddNew(params, op_res->it, key, value);\n     return OpStatus::OK;\n   }\n }\n \n-OpStatus SetCmd::SetExisting(const SetParams& params, DbSlice::Iterator it,\n-                             DbSlice::ExpIterator e_it, string_view key, string_view value) {\n+OpStatus SetCmd::SetExisting(const SetParams& params, string_view value,\n+                             DbSlice::ItAndUpdater* it_upd) {\n   DCHECK_EQ(params.flags & SET_IF_NOTEXIST, 0);\n \n-  PrimeValue& prime_value = it->second;\n+  PrimeKey& key = it_upd->it->first;\n+  PrimeValue& prime_value = it_upd->it->second;\n   EngineShard* shard = op_args_.shard;\n \n   auto& db_slice = op_args_.GetDbSlice();\n@@ -871,30 +872,32 @@ OpStatus SetCmd::SetExisting(const SetParams& params, DbSlice::Iterator it,\n \n   if (!(params.flags & SET_KEEP_EXPIRE)) {\n     if (at_ms) {  // Command has an expiry paramater.\n-      if (IsValid(e_it)) {\n+      if (IsValid(it_upd->exp_it)) {\n         // Updated existing expiry information.\n-        e_it->second = db_slice.FromAbsoluteTime(at_ms);\n+        it_upd->exp_it->second = db_slice.FromAbsoluteTime(at_ms);\n       } else {\n         // Add new expiry information.\n-        db_slice.AddExpire(op_args_.db_cntx.db_index, it, at_ms);\n+        db_slice.AddExpire(op_args_.db_cntx.db_index, it_upd->it, at_ms);\n       }\n     } else {\n-      db_slice.RemoveExpire(op_args_.db_cntx.db_index, it);\n+      db_slice.RemoveExpire(op_args_.db_cntx.db_index, it_upd->it);\n     }\n   }\n \n   if (params.flags & SET_STICK) {\n-    it->first.SetSticky(true);\n+    key.SetSticky(true);\n   }\n \n   bool has_expire = prime_value.HasExpire();\n \n+  it_upd->post_updater.ReduceHeapUsage();\n+\n   // Update flags\n   prime_value.SetFlag(params.memcache_flags != 0);\n-  db_slice.SetMCFlag(op_args_.db_cntx.db_index, it->first.AsRef(), params.memcache_flags);\n+  db_slice.SetMCFlag(op_args_.db_cntx.db_index, key.AsRef(), params.memcache_flags);\n \n   // We need to remove the key from search indices, because we are overwriting it to OBJ_STRING\n-  shard->search_indices()->RemoveDoc(key, op_args_.db_cntx, prime_value);\n+  shard->search_indices()->RemoveDoc(it_upd->it.key(), op_args_.db_cntx, prime_value);\n \n   // If value is external, mark it as deleted\n   if (prime_value.IsExternal()) {\n@@ -906,11 +909,11 @@ OpStatus SetCmd::SetExisting(const SetParams& params, DbSlice::Iterator it,\n \n   DCHECK_EQ(has_expire, prime_value.HasExpire());\n \n-  PostEdit(params, key, value, &prime_value);\n+  PostEdit(params, it_upd->it.key(), value, &prime_value);\n   return OpStatus::OK;\n }\n \n-void SetCmd::AddNew(const SetParams& params, DbSlice::Iterator it, std::string_view key,\n+void SetCmd::AddNew(const SetParams& params, const DbSlice::Iterator& it, std::string_view key,\n                     std::string_view value) {\n   auto& db_slice = op_args_.GetDbSlice();\n \n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 1951dd33d61d..32fbd1c8e1c6 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -21,7 +21,6 @@ extern \"C\" {\n using namespace testing;\n using namespace std;\n using namespace util;\n-using namespace boost;\n using absl::StrCat;\n \n namespace dfly {\n@@ -453,14 +452,33 @@ TEST_F(GenericFamilyTest, Rename) {\n   ren_fb.Join();\n }\n \n-TEST_F(GenericFamilyTest, RenameNonString) {\n-  EXPECT_EQ(1, CheckedInt({\"lpush\", \"x\", \"elem\"}));\n-  auto resp = Run({\"rename\", \"x\", \"b\"});\n-  ASSERT_EQ(resp, \"OK\");\n-  ASSERT_EQ(2, last_cmd_dbg_info_.shards_count);\n+TEST_F(GenericFamilyTest, RenameList) {\n+  for (string_view dest : {\"b\", \"y\", \"z\"}) {\n+    EXPECT_EQ(1, CheckedInt({\"lpush\", \"x\", \"elem\"}));\n+    Metrics metrics = GetMetrics();\n+\n+    size_t list_usage = metrics.db_stats[0].memory_usage_by_type[OBJ_LIST];\n+    size_t string_usage = metrics.db_stats[0].memory_usage_by_type[OBJ_STRING];\n+    ASSERT_GT(list_usage, 0);\n+    ASSERT_EQ(string_usage, 0);\n+\n+    auto resp = Run({\"rename\", \"x\", dest});\n+    ASSERT_EQ(resp, \"OK\");\n+    if (dest == \"b\") {\n+      ASSERT_EQ(2, last_cmd_dbg_info_.shards_count);\n+    } else {\n+      ASSERT_EQ(1, last_cmd_dbg_info_.shards_count);\n+    }\n \n-  EXPECT_EQ(0, CheckedInt({\"del\", \"x\"}));\n-  EXPECT_EQ(1, CheckedInt({\"del\", \"b\"}));\n+    metrics = GetMetrics();\n+    size_t list_usage_after = metrics.db_stats[0].memory_usage_by_type[OBJ_LIST];\n+    string_usage = metrics.db_stats[0].memory_usage_by_type[OBJ_STRING];\n+    ASSERT_EQ(list_usage_after, list_usage);\n+    ASSERT_EQ(string_usage, 0);\n+\n+    EXPECT_EQ(0, CheckedInt({\"del\", \"x\"}));\n+    EXPECT_EQ(1, CheckedInt({\"del\", dest}));\n+  }\n }\n \n TEST_F(GenericFamilyTest, RenameBinary) {\ndiff --git a/src/server/string_family_test.cc b/src/server/string_family_test.cc\nindex d546644cfd12..bee1ca298392 100644\n--- a/src/server/string_family_test.cc\n+++ b/src/server/string_family_test.cc\n@@ -810,6 +810,18 @@ TEST_F(StringFamilyTest, SetMGetWithNilResp3) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"val\", ArgType(RespExpr::NIL)));\n }\n \n+TEST_F(StringFamilyTest, OverrideOther) {\n+  Run({\"lpush\", \"a\", \"fooo\"});\n+  Run({\"set\", \"a\", string(100, 'b')});\n+  Metrics metrics = GetMetrics();\n+\n+  size_t list_usage = metrics.db_stats[0].memory_usage_by_type[OBJ_LIST];\n+  size_t string_usage = metrics.db_stats[0].memory_usage_by_type[OBJ_STRING];\n+  EXPECT_EQ(list_usage, 0);\n+  EXPECT_GT(string_usage, 0);\n+  EXPECT_LT(string_usage, 100);\n+}\n+\n TEST_F(StringFamilyTest, SetWithGetParam) {\n   EXPECT_THAT(Run({\"set\", \"key1\", \"val1\", \"get\"}), ArgType(RespExpr::NIL));\n   EXPECT_EQ(Run({\"set\", \"key1\", \"val2\", \"get\"}), \"val1\");\n",
  "problem_statement": "Memory accounting is broken for single shard RENAME  or blind writes\nto reproduce:\n1. run dragonfly with `--proactor_threads=1` though it can be shown for any number of threads.\n2. `lpush a foo` and then `info memory` to see how memory by type is updated correctly \n3. `rename a b`  and then `info memory` to see how memory for strings and lists is completely off.\n\n\nThe same happens for any blind write operations cc @BagritsevichStepan for example\n1. `lpush a foo` and then `info memory` to see how memory by type is updated correctly \n2. `set a barrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr` and then `info memory` to see how memory by type is completely off.\n\n\n\n\n\n",
  "hints_text": "I see",
  "created_at": "2025-06-16T14:43:55Z",
  "modified_files": [
    "src/server/db_slice.cc",
    "src/server/db_slice.h",
    "src/server/generic_family.cc",
    "src/server/string_family.cc"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc",
    "src/server/string_family_test.cc"
  ]
}