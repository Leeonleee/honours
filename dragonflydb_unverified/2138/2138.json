{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2138,
  "instance_id": "dragonflydb__dragonfly-2138",
  "issue_numbers": [
    "2134"
  ],
  "base_commit": "b7cbdca79954ba8cae3a2817fc93629076e12236",
  "patch": "diff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 393598425c6c..9c4dadb1ebe8 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -966,6 +966,7 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n   bool is_write_cmd = cid->opt_mask() & CO::WRITE;\n   bool under_multi = dfly_cntx.conn_state.exec_info.IsCollecting() && !is_trans_cmd;\n \n+  // Check if the command is allowed to execute under this global state\n   bool allowed_by_state = true;\n   switch (etl.gstate()) {\n     case GlobalState::LOADING:\n@@ -999,9 +1000,6 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n   if (dfly_cntx.monitor && (cmd_name != \"RESET\" && cmd_name != \"QUIT\"))\n     return ErrorReply{\"Replica can't interact with the keyspace\"};\n \n-  if (under_script && (cid->opt_mask() & CO::NOSCRIPT))\n-    return ErrorReply{\"This Redis command is not allowed from script\"};\n-\n   if (!etl.is_master && is_write_cmd && !dfly_cntx.is_replicating)\n     return ErrorReply{\"-READONLY You can't write against a read only replica.\"};\n \n@@ -1018,6 +1016,19 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n       return err;\n   }\n \n+  if (under_script && (cid->opt_mask() & CO::NOSCRIPT))\n+    return ErrorReply{\"This Redis command is not allowed from script\"};\n+\n+  if (under_script) {\n+    DCHECK(dfly_cntx.transaction);\n+    // The following commands access shards arbitrarily without having keys, so they can only be run\n+    // non atomically or globally.\n+    Transaction::MultiMode mode = dfly_cntx.transaction->GetMultiMode();\n+    bool shard_access = (cid->opt_mask()) & (CO::GLOBAL_TRANS | CO::NO_KEY_TRANSACTIONAL);\n+    if (shard_access && (mode != Transaction::GLOBAL && mode != Transaction::NON_ATOMIC))\n+      return ErrorReply(\"This Redis command is not allowed from script\");\n+  }\n+\n   if (under_script && cid->IsTransactional()) {\n     OpStatus status =\n         CheckKeysDeclared(*dfly_cntx.conn_state.script_info, cid, tail_args, dfly_cntx.transaction);\n@@ -1529,6 +1540,7 @@ void Service::CallFromScript(ConnectionContext* cntx, Interpreter::CallArgs& ca)\n   if (ca.async) {\n     auto& info = cntx->conn_state.script_info;\n     ToUpper(&ca.args[0]);\n+\n     // Full command verification happens during squashed execution\n     if (auto* cid = registry_.Find(ArgS(ca.args, 0)); cid != nullptr) {\n       auto replies = ca.error_abort ? ReplyMode::ONLY_ERR : ReplyMode::NONE;\n",
  "test_patch": "diff --git a/src/server/multi_test.cc b/src/server/multi_test.cc\nindex 75b6dc28e11e..f1591bf95fe0 100644\n--- a/src/server/multi_test.cc\n+++ b/src/server/multi_test.cc\n@@ -686,6 +686,29 @@ TEST_F(MultiTest, ScriptFlagsEmbedded) {\n   EXPECT_THAT(Run({\"eval\", s2, \"0\"}), ErrArg(\"Invalid flag: this-is-an-error\"));\n }\n \n+TEST_F(MultiTest, ScriptBadCommand) {\n+  const char* s1 = \"redis.call('FLUSHALL')\";\n+  const char* s2 = \"redis.call('FLUSHALL'); redis.set(KEYS[1], ARGS[1]);\";\n+  const char* s3 = \"redis.acall('FLUSHALL'); redis.set(KEYS[1], ARGS[1]);\";\n+  const char* s4 = R\"(\n+    #!lua flags=disable-atomicity\n+    redis.call('FLUSHALL');\n+    return \"OK\";\n+  )\";\n+\n+  auto resp = Run({\"eval\", s1, \"0\"});  // tx won't be scheduled at all\n+  EXPECT_THAT(resp, ErrArg(\"This Redis command is not allowed from script\"));\n+\n+  resp = Run({\"eval\", s2, \"1\", \"works\", \"false\"});  // will be scheduled as lock ahead\n+  EXPECT_THAT(resp, ErrArg(\"This Redis command is not allowed from script\"));\n+\n+  resp = Run({\"eval\", s3, \"1\", \"works\", \"false\"});  // also async call will happen\n+  EXPECT_THAT(resp, ErrArg(\"This Redis command is not allowed from script\"));\n+\n+  resp = Run({\"eval\", s4, \"0\"});\n+  EXPECT_EQ(resp, \"OK\");\n+}\n+\n TEST_F(MultiTest, MultiEvalModeConflict) {\n   if (auto mode = absl::GetFlag(FLAGS_multi_exec_mode); mode == Transaction::GLOBAL) {\n     GTEST_SKIP() << \"Skipped MultiEvalModeConflict test because multi_exec_mode is global\";\n",
  "problem_statement": "Scripts should return error on non-conventional (global, nokey) commands\n```\r\nredis.call('FLUSHALL')\r\n```\r\n\r\ncrashes DF in the regular mode, it should return an error instead, that any of those two should be used:\r\n\r\n\r\n```\r\n#!lua flags=disable-atomicity\r\nredis.call('FLUSHALL')\r\n```\r\n\r\n```\r\n#!lua flags=allow-undeclared-keys\r\nredis.call('FLUSHALL')\r\n```\r\n\r\nor even add a new flag...? like management which implicitly means = allow-undeclared-keys?\n",
  "hints_text": "lets reject it from lua scripts as a first step.\n> lets reject it from lua scripts as a first step.\r\n\r\nThat's what I mean by returning an error \ud83d\ude42 ",
  "created_at": "2023-11-06T17:12:28Z",
  "modified_files": [
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "src/server/multi_test.cc"
  ]
}