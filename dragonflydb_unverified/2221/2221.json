{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2221,
  "instance_id": "dragonflydb__dragonfly-2221",
  "issue_numbers": [
    "213"
  ],
  "base_commit": "bfb1b3b624e45c8b9ace34b499588eb6c4b20178",
  "patch": "diff --git a/src/facade/cmd_arg_parser.h b/src/facade/cmd_arg_parser.h\nindex 833ce20e8a94..3741872200d4 100644\n--- a/src/facade/cmd_arg_parser.h\n+++ b/src/facade/cmd_arg_parser.h\n@@ -143,6 +143,10 @@ struct CmdArgParser {\n     return std::exchange(error_, {});\n   }\n \n+  bool HasAtLeast(size_t i) const {\n+    return cur_i_ + i <= args_.size() && !error_;\n+  }\n+\n  private:\n   template <class T, class... Cases>\n   std::optional<std::decay_t<T>> SwitchImpl(std::string_view arg, std::string_view tag, T&& value,\ndiff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex bd4757c08605..90a8157a0030 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -6,11 +6,16 @@\n \n #include <bitset>\n \n+#include \"base/expected.hpp\"\n+#include \"facade/op_status.h\"\n+\n extern \"C\" {\n #include \"redis/object.h\"\n }\n \n+#include \"absl/strings/match.h\"\n #include \"base/logging.h\"\n+#include \"facade/cmd_arg_parser.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/command_registry.h\"\n #include \"server/common.h\"\n@@ -19,6 +24,7 @@ extern \"C\" {\n #include \"server/error.h\"\n #include \"server/tiered_storage.h\"\n #include \"server/transaction.h\"\n+#include \"src/core/overloaded.h\"\n #include \"util/varz.h\"\n \n namespace dfly {\n@@ -260,7 +266,7 @@ constexpr uint8_t TurnBitOn(uint8_t on, uint32_t offset) {\n   return on |= 1 << offset;\n }\n \n-constexpr uint8_t TunBitOff(uint8_t on, uint32_t offset) {\n+constexpr uint8_t TurnBitOff(uint8_t on, uint32_t offset) {\n   return on &= ~(1 << offset);\n }\n \n@@ -268,9 +274,8 @@ bool SetBitValue(uint32_t offset, bool bit_value, std::string* entry) {\n   // we need to return the old value after setting the value for offset\n   const auto old_value{GetBitValue(*entry, offset)};  // save this as the return value\n   auto byte{GetByteValue(*entry, offset)};\n-  std::bitset<8> bits{byte};\n   const auto bit_index{GetNormalizedBitIndex(offset)};\n-  byte = bit_value ? TurnBitOn(byte, bit_index) : TunBitOff(byte, bit_index);\n+  byte = bit_value ? TurnBitOn(byte, bit_index) : TurnBitOff(byte, bit_index);\n   (*entry)[GetByteIndex(offset)] = byte;\n   return old_value;\n }\n@@ -302,8 +307,20 @@ class ElementAccess {\n   std::string Value() const;\n \n   void Commit(std::string_view new_value) const;\n+\n+  // return nullopt when key exists but it's not encoded as string\n+  // return true if key exists and false if it doesn't\n+  std::optional<bool> Exists(EngineShard* shard);\n };\n \n+std::optional<bool> ElementAccess::Exists(EngineShard* shard) {\n+  auto res = shard->db_slice().Find(context_, key_, OBJ_STRING);\n+  if (res.status() == OpStatus::WRONG_TYPE) {\n+    return {};\n+  }\n+  return res.status() != OpStatus::KEY_NOTFOUND;\n+}\n+\n OpStatus ElementAccess::Find(EngineShard* shard) {\n   try {\n     std::pair<PrimeIterator, bool> add_res = shard->db_slice().AddOrFind(context_, key_);\n@@ -553,7 +570,7 @@ void BitCount(CmdArgList args, ConnectionContext* cntx) {\n   if (args.size() == 2 || args.size() > 4) {\n     return (*cntx)->SendError(kSyntaxErr);\n   }\n-  // return (*cntx)->SendLong(0);\n+\n   std::string_view key = ArgS(args, 0);\n   bool as_bit = false;\n   int64_t start = 0;\n@@ -577,14 +594,528 @@ void BitCount(CmdArgList args, ConnectionContext* cntx) {\n   HandleOpValueResult(res, cntx);\n }\n \n+// GCC yields a wrong warning about uninitialized optional use\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+\n+enum class EncodingType { UINT, INT, NILL };\n+\n+struct CommonAttributes {\n+  EncodingType type;\n+  size_t encoding_bit_size;\n+  size_t offset;\n+};\n+\n+// We either return the result of the subcommand (int64_t) or nullopt\n+// to represent overflow/underflow failures\n+using ResultType = std::optional<int64_t>;\n+\n+struct Overflow {\n+  enum Policy { WRAP, SAT, FAIL };\n+\n+  // Used to check for unsigned overflow/underflow.\n+  // If incr is non zero, we check for overflows in the expression incr + *value\n+  // If incr is zero, we check for overflows in the expression *value\n+  // If the overflow fails because of Policy::FAIL, it returns false. Otherwise, true.\n+  // The result of handling the overflow is stored in the pointer value\n+  bool UIntOverflow(int64_t incr, size_t total_bits, int64_t* value) const;\n+\n+  // Used to check for signed overflow/underflow.\n+  // If incr is non zero, we check for overflows in the expression incr + *value\n+  // If incr is zero, we check for overflows in the expression *value\n+  // If the overflow fails because of Policy::FAIL, it returns false. Otherwise, true.\n+  // The result of handling the overflow is stored in the pointer value\n+  bool IntOverflow(size_t total_bits, int64_t incr, bool add, int64_t* value) const;\n+\n+  Policy type = WRAP;\n+};\n+\n+bool Overflow::UIntOverflow(int64_t incr, size_t total_bits, int64_t* value) const {\n+  // total up to 63 bits -- we do not support 64 bit unsigned\n+  const uint64_t max = (1UL << total_bits) - 1;\n+\n+  uint64_t incr_value = incr;\n+  if (incr_value + *value > max) {\n+    switch (type) {\n+      case Overflow::WRAP:\n+        // safe to do, won't overflow, both incr and value are <= than 2^63 - 1\n+        *value = (incr_value + *value) % max;\n+        break;\n+      case Overflow::SAT:\n+        *value = max;\n+        break;\n+      case Overflow::FAIL:\n+        *value = 0;\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  *value = incr_value + *value;\n+  return true;\n+}\n+\n+bool Overflow::IntOverflow(size_t total_bits, int64_t incr, bool add, int64_t* value) const {\n+  // This is exactly how redis handles signed overflow and we use the exact same chore\n+  const int64_t int_max = std::numeric_limits<int64_t>::max();\n+  const int64_t max = (total_bits == 64) ? int_max : ((1L << (total_bits - 1)) - 1);\n+  const int64_t min = (-max) - 1;\n+  auto switch_overflow = [&](int64_t wrap_case, int64_t sat_case, int64_t i) {\n+    switch (type) {\n+      case Overflow::WRAP: {\n+        uint64_t msb = 1UL << (total_bits - 1);\n+        uint64_t a = *value, b = incr;\n+        // Perform addition as unsigned so that's defined\n+        uint64_t c = a + b;\n+        if (total_bits < 64) {\n+          uint64_t mask = static_cast<uint64_t>(-1) << total_bits;\n+          if (c & msb) {\n+            c |= mask;\n+          } else {\n+            c &= ~mask;\n+          }\n+        }\n+        *value = c;\n+        break;\n+      }\n+      case Overflow::SAT:\n+        *value = sat_case;\n+        break;\n+      case Overflow::FAIL:\n+        *value = 0;\n+        return false;\n+    }\n+    return true;\n+  };\n+\n+  // maxincr/minincr can overflow but it won't be an issue because we only use them\n+  // after checking 'value' range, so when they are used no overflow\n+  // happens. 'uint64_t' cast is there just to prevent undefined behavior on\n+  // overflow */\n+  int64_t maxincr = static_cast<uint64_t>(max) - *value;\n+  int64_t minincr = min - *value;\n+\n+  // overflow\n+  if (*value > max || (total_bits != 64 && incr > maxincr) ||\n+      (*value >= 0 && incr > 0 && incr > maxincr)) {\n+    return switch_overflow(min, max, 1);\n+  }\n+\n+  // underflow\n+  if (*value < min || (total_bits != 64 && incr < minincr) ||\n+      (*value < 0 && incr < 0 && incr < minincr)) {\n+    return switch_overflow(max, min, -1);\n+  }\n+\n+  *value = *value + incr;\n+\n+  return true;\n+}\n+\n+class Get {\n+ public:\n+  explicit Get(CommonAttributes attr) : attr_(attr) {\n+  }\n+\n+  // Apply the GET subcommand to the bitfield bytes.\n+  // Return either the subcommand result (int64_t) or empty optional if failed because of\n+  // Policy:FAIL\n+  ResultType ApplyTo(Overflow ov, const std::string* bitfield);\n+\n+ private:\n+  CommonAttributes attr_;\n+};\n+\n+ResultType Get::ApplyTo(Overflow ov, const std::string* bitfield) {\n+  const auto& bytes = *bitfield;\n+  const int32_t total_bytes = static_cast<int32_t>(bytes.size());\n+  const size_t offset = attr_.offset;\n+  auto last_byte_offset = GetByteIndex(attr_.offset + attr_.encoding_bit_size - 1);\n+\n+  uint32_t lsb = attr_.offset + attr_.encoding_bit_size - 1;\n+  if (last_byte_offset > total_bytes) {\n+    return {};\n+  }\n+\n+  const bool is_negative =\n+      CheckBitStatus(GetByteValue(bytes, offset), GetNormalizedBitIndex(offset));\n+\n+  int64_t result = 0;\n+  for (size_t i = 0; i < attr_.encoding_bit_size; ++i) {\n+    uint8_t byte{GetByteValue(bytes, lsb)};\n+    int32_t index = GetNormalizedBitIndex(lsb);\n+    int64_t old_bit = CheckBitStatus(byte, index);\n+    result |= old_bit << i;\n+    --lsb;\n+  }\n+\n+  if (is_negative && attr_.type == EncodingType::INT && result > 0) {\n+    result |= -1L ^ ((1L << attr_.encoding_bit_size) - 1);\n+  }\n+\n+  return result;\n+}\n+\n+class Set {\n+ public:\n+  explicit Set(CommonAttributes attr, int64_t value) : attr_(attr), set_value_(value) {\n+  }\n+\n+  // Apply the SET subcommand to the bitfield value.\n+  // Return either the subcommand result (int64_t) or empty optional if failed because of\n+  // Policy:FAIL Updates the bitfield to contain the new value\n+  ResultType ApplyTo(Overflow ov, std::string* bitfield);\n+\n+ private:\n+  // Helper function that delegates overflow checking to the Overflow object\n+  bool HandleOverflow(Overflow ov);\n+\n+  CommonAttributes attr_;\n+  int64_t set_value_;\n+};\n+\n+ResultType Set::ApplyTo(Overflow ov, std::string* bitfield) {\n+  std::string& bytes = *bitfield;\n+  const int32_t total_bytes = static_cast<int32_t>(bytes.size());\n+  auto last_byte_offset = GetByteIndex(attr_.offset + attr_.encoding_bit_size - 1) + 1;\n+  if (last_byte_offset > total_bytes) {\n+    bytes.resize(last_byte_offset, 0);\n+  }\n+\n+  if (!HandleOverflow(ov)) {\n+    return {};\n+  }\n+\n+  uint32_t lsb = attr_.offset + attr_.encoding_bit_size - 1;\n+  int64_t old_value = 0;\n+\n+  for (size_t i = 0; i < attr_.encoding_bit_size; ++i) {\n+    bool bit_value = (set_value_ >> i) & 0x01;\n+    uint8_t byte{GetByteValue(bytes, lsb)};\n+    int32_t index = GetNormalizedBitIndex(lsb);\n+    int64_t old_bit = CheckBitStatus(byte, index);\n+    byte = bit_value ? TurnBitOn(byte, index) : TurnBitOff(byte, index);\n+    bytes[GetByteIndex(lsb)] = byte;\n+    old_value |= old_bit << i;\n+    --lsb;\n+  }\n+\n+  return old_value;\n+}\n+\n+bool Set::HandleOverflow(Overflow ov) {\n+  size_t total_bits = attr_.encoding_bit_size;\n+  if (attr_.type == EncodingType::UINT) {\n+    return ov.UIntOverflow(0, attr_.encoding_bit_size, &set_value_);\n+  }\n+\n+  return ov.IntOverflow(total_bits, 0, false, &set_value_);\n+}\n+\n+class IncrBy {\n+ public:\n+  explicit IncrBy(CommonAttributes attr, int64_t val) : attr_(attr), incr_value_(val) {\n+  }\n+\n+  // Apply the INCRBY subcommand to the bitfield value.\n+  // Return either the subcommand result (int64_t) or empty optional if failed because of\n+  // Policy:FAIL Updates the bitfield to contain the new incremented value\n+  ResultType ApplyTo(Overflow ov, std::string* bitfield);\n+\n+ private:\n+  // Helper function that delegates overflow checking to the Overflow object\n+  bool HandleOverflow(Overflow ov, int64_t* previous);\n+\n+  CommonAttributes attr_;\n+  int64_t incr_value_;\n+};\n+\n+ResultType IncrBy::ApplyTo(Overflow ov, std::string* bitfield) {\n+  std::string& bytes = *bitfield;\n+  Get get(attr_);\n+  auto res = get.ApplyTo(ov, &bytes);\n+\n+  if (!res) {\n+    Set set(attr_, incr_value_);\n+    return set.ApplyTo(ov, &bytes);\n+  }\n+\n+  if (!HandleOverflow(ov, &*res)) {\n+    return {};\n+  }\n+\n+  Set set(attr_, *res);\n+  set.ApplyTo(ov, &bytes);\n+  return *res;\n+}\n+\n+bool IncrBy::HandleOverflow(Overflow ov, int64_t* previous) {\n+  if (attr_.type == EncodingType::UINT) {\n+    return ov.UIntOverflow(incr_value_, attr_.encoding_bit_size, previous);\n+  }\n+\n+  const size_t total_bits = attr_.encoding_bit_size;\n+  return ov.IntOverflow(total_bits, incr_value_, true, previous);\n+}\n+\n+// Subcommand types for each of the subcommands of the BITFIELD command\n+using Command = std::variant<Get, Set, Overflow, IncrBy>;\n+\n+using Result = std::optional<ResultType>;\n+\n+// Visitor for all the subcommand variants. Calls ApplyTo, to execute the subcommand\n+class CommandApplyVisitor {\n+ public:\n+  explicit CommandApplyVisitor(std::string bitfield) : bitfield_(std::move(bitfield)) {\n+  }\n+\n+  Result operator()(Get get) {\n+    return get.ApplyTo(overflow_, &bitfield_);\n+  }\n+\n+  template <typename T> Result operator()(T update) {\n+    should_commit_ = true;\n+    return update.ApplyTo(overflow_, &bitfield_);\n+  }\n+\n+  Result operator()(Overflow overflow) {\n+    overflow_ = overflow;\n+    return {};\n+  }\n+\n+  std::string_view Bitfield() const {\n+    return bitfield_;\n+  }\n+\n+  bool ShouldCommit() const {\n+    return should_commit_;\n+  }\n+\n+ private:\n+  // Most recent overflow object encountered. We cache it to make the overflow\n+  // policy changes stick among different subcommands\n+  Overflow overflow_;\n+  // This will be commited if it was updated\n+  std::string bitfield_;\n+  // If either of the subcommands SET|INCRBY is used we should persist the changes.\n+  // Otherwise, we only used a read only subcommand (GET)\n+  bool should_commit_ = false;\n+};\n+\n+// A lit of subcommands used in BITFIELD command\n+using CommandList = std::vector<Command>;\n+\n+// Helper class used in the shard cb that abstracts away the iteration and execution of subcommands\n+class StateExecutor {\n+ public:\n+  StateExecutor(ElementAccess access, EngineShard* shard) : access_{access}, shard_(shard) {\n+  }\n+\n+  //  Iterates over all of the parsed subcommands and executes them one by one. At the end,\n+  //  if an update subcommand SET|INCRBY was used, commit back the changes via the ElementAccess\n+  //  object\n+  OpResult<std::vector<ResultType>> Execute(const CommandList& commands);\n+\n+ private:\n+  ElementAccess access_;\n+  EngineShard* shard_;\n+};\n+\n+OpResult<std::vector<ResultType>> StateExecutor::Execute(const CommandList& commands) {\n+  auto res = access_.Exists(shard_);\n+  if (!res) {\n+    return {OpStatus::WRONG_TYPE};\n+  }\n+  std::string value;\n+  if (*res) {\n+    access_.Find(shard_);\n+    value = access_.Value();\n+  }\n+\n+  std::vector<ResultType> results;\n+  CommandApplyVisitor visitor(std::move(value));\n+  for (auto& command : commands) {\n+    auto res = std::visit(visitor, command);\n+    if (res) {\n+      results.push_back(*res);\n+    }\n+  }\n+\n+  if (visitor.ShouldCommit()) {\n+    access_.Find(shard_);\n+    access_.Commit(visitor.Bitfield());\n+  }\n+\n+  return results;\n+}\n+\n+nonstd::expected<CommonAttributes, std::string> ParseCommonAttr(CmdArgParser* prser) {\n+  CmdArgParser& parser = *prser;\n+  CommonAttributes parsed;\n+  using nonstd::make_unexpected;\n+  if (!parser.HasAtLeast(2)) {\n+    return make_unexpected(kSyntaxErr);\n+  }\n+\n+  auto encoding = parser.ToUpper().Next();\n+  if (absl::StartsWith(encoding, \"U\")) {\n+    parsed.type = EncodingType::UINT;\n+  } else if (absl::StartsWith(encoding, \"I\")) {\n+    parsed.type = EncodingType::INT;\n+  } else {\n+    return make_unexpected(kSyntaxErr);\n+  }\n+\n+  std::string_view bits = encoding;\n+  bits = bits.substr(1);\n+\n+  if (!absl::SimpleAtoi(bits, &parsed.encoding_bit_size)) {\n+    return make_unexpected(kSyntaxErr);\n+  }\n+\n+  if (parsed.encoding_bit_size <= 0 || parsed.encoding_bit_size > 64) {\n+    return make_unexpected(\n+        \"invalid bitfield type. use something like i16 u8. note that u64 is not supported but i64 \"\n+        \"is.\");\n+  }\n+\n+  if (parsed.encoding_bit_size == 64 && parsed.type == EncodingType::UINT) {\n+    return make_unexpected(\n+        \"invalid bitfield type. use something like i16 u8. note that u64 is not supported but i64 \"\n+        \"is.\");\n+  }\n+\n+  std::string_view offset_str = parser.Next();\n+  bool is_proxy = false;\n+  if (absl::StartsWith(offset_str, \"#\")) {\n+    offset_str = offset_str.substr(1);\n+    is_proxy = true;\n+  }\n+  if (!absl::SimpleAtoi(offset_str, &parsed.offset)) {\n+    return make_unexpected(kSyntaxErr);\n+  }\n+  if (is_proxy) {\n+    parsed.offset = parsed.offset * parsed.encoding_bit_size;\n+  }\n+  return parsed;\n+}\n+\n+// Parses a list of arguments (without key) to a CommandList.\n+// Returns the CommandList if the parsing completed succefully or std::string\n+// to indicate an error\n+nonstd::expected<CommandList, std::string> ParseToCommandList(CmdArgList args) {\n+  CommandList result;\n+\n+  using nonstd::make_unexpected;\n+\n+  CmdArgParser parser(args);\n+  while (parser.HasNext()) {\n+    if (!parser.HasAtLeast(2)) {\n+      return make_unexpected(kSyntaxErr);\n+    }\n+\n+    auto op = parser.ToUpper().Next();\n+\n+    using namespace std::string_view_literals;\n+    if (op == \"OVERFLOW\"sv) {\n+      using pol = Overflow::Policy;\n+      auto res = parser.ToUpper().Switch(\"SAT\", pol::SAT, \"WRAP\", pol::WRAP, \"FAIL\", pol::FAIL);\n+      if (!parser.HasError()) {\n+        result.push_back(Overflow{res});\n+        continue;\n+      }\n+      parser.Error();\n+      return make_unexpected(kSyntaxErr);\n+    }\n+\n+    auto maybe_attr = ParseCommonAttr(&parser);\n+    if (!maybe_attr.has_value()) {\n+      return make_unexpected(std::move(maybe_attr.error()));\n+    }\n+\n+    auto attr = maybe_attr.value();\n+    if (op == \"GET\"sv) {\n+      result.push_back(Command(Get(attr)));\n+      continue;\n+    }\n+\n+    auto value = parser.ToUpper().Next<int64_t>();\n+    if (parser.HasError()) {\n+      parser.Error();\n+      return make_unexpected(kSyntaxErr);\n+    }\n+\n+    if (op == \"SET\"sv) {\n+      result.push_back(Command(Set(attr, value)));\n+      continue;\n+    }\n+\n+    if (op == \"INCRBY\"sv) {\n+      result.push_back(Command(IncrBy(attr, value)));\n+      continue;\n+    }\n+    return make_unexpected(kSyntaxErr);\n+  }\n+\n+  return result;\n+}\n+\n+void SendResults(const std::vector<ResultType>& results, ConnectionContext* cntx) {\n+  const size_t total = results.size();\n+  if (total == 0) {\n+    (*cntx)->SendNullArray();\n+    return;\n+  }\n+\n+  (*cntx)->StartArray(total);\n+  for (const auto& elem : results) {\n+    if (elem) {\n+      (*cntx)->SendLong(*elem);\n+      continue;\n+    }\n+\n+    (*cntx)->SendNull();\n+  }\n+}\n+\n void BitField(CmdArgList args, ConnectionContext* cntx) {\n-  (*cntx)->SendLong(0);\n+  if (args.size() == 1) {\n+    (*cntx)->SendNullArray();\n+    return;\n+  }\n+  auto key = ArgS(args, 0);\n+  auto maybe_ops_list = ParseToCommandList(args.subspan(1));\n+\n+  if (!maybe_ops_list.has_value()) {\n+    cntx->SendError(maybe_ops_list.error());\n+    return;\n+  }\n+  CommandList cmd_list = std::move(maybe_ops_list.value());\n+\n+  auto cb = [&cmd_list, &key](Transaction* t,\n+                              EngineShard* shard) -> OpResult<std::vector<ResultType>> {\n+    StateExecutor executor(ElementAccess(key, t->GetOpArgs(shard)), shard);\n+    return executor.Execute(cmd_list);\n+  };\n+\n+  Transaction* trans = cntx->transaction;\n+  OpResult<std::vector<ResultType>> res = trans->ScheduleSingleHopT(std::move(cb));\n+\n+  if (res == OpStatus::WRONG_TYPE) {\n+    cntx->SendError(kWrongTypeErr);\n+    return;\n+  }\n+\n+  SendResults(*res, cntx);\n }\n \n void BitFieldRo(CmdArgList args, ConnectionContext* cntx) {\n-  (*cntx)->SendLong(0);\n+  cntx->SendError(\"Not Yet Implemented\");\n+  // return BitField(args, cntx);\n }\n \n+#pragma GCC diagnostic pop\n+\n void BitOp(CmdArgList args, ConnectionContext* cntx) {\n   static const std::array<std::string_view, 4> BITOP_OP_NAMES{OR_OP_NAME, XOR_OP_NAME, AND_OP_NAME,\n                                                               NOT_OP_NAME};\n",
  "test_patch": "diff --git a/src/server/bitops_family_test.cc b/src/server/bitops_family_test.cc\nindex bd0cb3b36db7..439fbc3cb957 100644\n--- a/src/server/bitops_family_test.cc\n+++ b/src/server/bitops_family_test.cc\n@@ -7,9 +7,11 @@\n #include <bitset>\n #include <iomanip>\n #include <iostream>\n+#include <limits>\n #include <string>\n #include <string_view>\n \n+#include \"absl/strings/str_cat.h\"\n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n #include \"facade/facade_test.h\"\n@@ -530,4 +532,239 @@ TEST_F(BitOpsFamilyTest, BitPos) {\n   EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"d\", \"0\"}));\n }\n \n+TEST_F(BitOpsFamilyTest, BitFieldParsing) {\n+  const auto syntax_error = ErrArg(\"ERR syntax error\");\n+  // Parsing Errors\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"0\", \"55\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"0\", \"get\", \"u1\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u1\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u1\", \"0\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"0\", \"15\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"0\", \"set\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\"}), syntax_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"nonsense\"}), syntax_error);\n+\n+  // Range errors\n+  auto expected_error = ErrArg(\n+      \"ERR invalid bitfield type. use something like i16 u8. note that u64 is not supported but \"\n+      \"i64 is.\");\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u0\", \"0\", \"0\"}), expected_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u0\", \"0\", \"0\"}), expected_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u64\", \"0\", \"0\"}), expected_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u65\", \"0\", \"0\"}), expected_error);\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i65\", \"0\", \"0\"}), expected_error);\n+}\n+\n+TEST_F(BitOpsFamilyTest, BitFieldCreate) {\n+  // check that SET, INCR create the key when it does not exist\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"0\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u1\", \"1\", \"1\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"1\"}), IntArg(1));\n+}\n+\n+TEST_F(BitOpsFamilyTest, BitFieldOverflowUnderflow) {\n+  Run({\"bitfield\", \"foo\", \"set\", \"u2\", \"0\", \"2\"});\n+\n+  // unsigned 1bit\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"2\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"0\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u1\", \"1\", \"2\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"1\"}), IntArg(0));\n+\n+  // unsigned 63bit\n+  int64_t max = std::numeric_limits<int64_t>::max();\n+  Run({\"bitfield\", \"foo\", \"set\", \"i64\", \"0\", absl::StrCat(max)});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i64\", \"0\", \"1\"}), IntArg(-max - 1));\n+\n+  // signed 1 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"i1\", \"0\", \"-2\"});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i1\", \"0\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i1\", \"0\", \"-1\"}), IntArg(-1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i1\", \"0\", \"-1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i1\", \"0\", \"-3\"}), IntArg(-1));\n+\n+  int64_t min = std::numeric_limits<int64_t>::min();\n+  Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"0\", absl::StrCat(min)});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"0\"}), IntArg(0));\n+\n+  // signed 64 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"i64\", \"0\", absl::StrCat(min)});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i64\", \"0\", \"-1\"}), IntArg(max));\n+\n+  // overflow sat\n+  // unsigned 8 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"0\"});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"u8\", \"0\", \"300\"}), IntArg(255));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"u8\", \"0\", \"10\"}), IntArg(255));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"0\"}), IntArg(255));\n+\n+  // unsigned 63 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"u63\", \"0\", \"0\"});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"set\", \"u63\", \"0\", absl::StrCat(max)}),\n+              IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"u63\", \"0\", \"10\"}), IntArg(max));\n+\n+  // signed 8 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"0\", \"0\"});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"set\", \"i8\", \"0\", \"300\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"i8\", \"0\", \"-127\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"i8\", \"0\", \"-255\"}),\n+              IntArg(-128));\n+\n+  // signed 64 bit\n+  Run({\"bitfield\", \"foo\", \"set\", \"i64\", \"0\", \"0\"});\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"set\", \"i64\", \"0\", absl::StrCat(max)}),\n+              IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"i64\", \"0\", \"100\"}),\n+              IntArg(max));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i64\", \"0\"}), IntArg(max));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"set\", \"i64\", \"0\", absl::StrCat(min)}),\n+              IntArg(max));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"sat\", \"incrby\", \"i64\", \"0\", \"-100\"}),\n+              IntArg(min));\n+\n+  // overflow fail\n+  // unsigned\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"set\", \"u8\", \"0\", \"300\"}),\n+              ArgType(RespExpr::Type::NIL));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"incrby\", \"u1\", \"0\", \"10\"}),\n+              ArgType(RespExpr::Type::NIL));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"incrby\", \"u1\", \"0\", \"-10\"}),\n+              ArgType(RespExpr::Type::NIL));\n+\n+  // signed\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"incrby\", \"i8\", \"0\", \"300\"}),\n+              ArgType(RespExpr::Type::NIL));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"incrby\", \"i1\", \"0\", \"10\"}),\n+              ArgType(RespExpr::Type::NIL));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"incrby\", \"i1\", \"0\", \"-10\"}),\n+              ArgType(RespExpr::Type::NIL));\n+\n+  // stickiness of overflow among operations in a chain\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"overflow\", \"fail\", \"set\", \"u8\", \"0\", \"300\", \"set\", \"u1\", \"0\",\n+                   \"400\"}),\n+              RespArray(ElementsAre(ArgType(RespExpr::NIL), ArgType(RespExpr::NIL))));\n+}\n+\n+TEST_F(BitOpsFamilyTest, BitFieldOperations) {\n+  // alligned offset reads/writes unsigned\n+  Run({\"bitfield\", \"foo\", \"set\", \"u32\", \"0\", \"0\"});\n+  // Set the bit battern 01111000 00000001 00000001 00001010\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"0\", \"120\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"0\"}), IntArg(120));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"8\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"8\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"16\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"16\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"24\", \"10\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"24\"}), IntArg(10));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u32\", \"0\"}), IntArg(2013331722));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u8\", \"0\", \"120\"}), IntArg(240));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"0\"}), IntArg(240));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"u16\", \"0\", \"120\"}), IntArg(61561));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u16\", \"0\"}), IntArg(61561));\n+\n+  // alligned offset reads/writes signed\n+  Run({\"bitfield\", \"foo\", \"set\", \"u32\", \"0\", \"0\"});\n+  // Set the bit battern 10001000 11111111 11111111 11110110\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"0\", \"-120\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"0\"}), IntArg(-120));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"8\", \"-1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"8\"}), IntArg(-1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"16\", \"-1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"16\"}), IntArg(-1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"24\", \"-10\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"24\"}), IntArg(-10));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i32\", \"0\"}), IntArg(-1996488714));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"incrby\", \"i8\", \"0\", \"-8\"}), IntArg(-128));\n+\n+  // nonalligned offset reads/writes unsigned\n+  Run({\"bitfield\", \"foo\", \"set\", \"i64\", \"0\", \"0\"});\n+  // Set the bit battern 00000000 10000000 10000000 10000000 10000000\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"1\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"1\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"9\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"9\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"17\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"17\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"25\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"25\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"0\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"8\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"16\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"24\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"32\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u33\", \"0\"}), IntArg(16843009));\n+\n+  // nonalligned offset reads/writes signed\n+  Run({\"bitfield\", \"foo\", \"set\", \"i64\", \"0\", \"0\"});\n+  // Set the bit battern 1111111 11111111 0000000 000000001\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"1\", \"-1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"1\"}), IntArg(-1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"9\", \"-1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"9\"}), IntArg(-1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"17\", \"0\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"17\"}), IntArg(0));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"set\", \"i8\", \"25\", \"1\"}), IntArg(0));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i8\", \"25\"}), IntArg(1));\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"i32\", \"1\"}), IntArg(-65535));\n+\n+  // chaining\n+  Run({\n+      \"bitfield\", \"foo\", \"set\", \"u1\", \"0\", \"1\", \"set\", \"u1\", \"1\", \"1\", \"set\", \"u1\",\n+      \"2\",        \"1\",   \"set\", \"u1\", \"3\", \"1\", \"set\", \"u1\", \"4\", \"1\", \"set\", \"u1\",\n+      \"5\",        \"1\",   \"set\", \"u1\", \"6\", \"1\", \"set\", \"u1\", \"7\", \"1\",\n+  });\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u8\", \"0\"}), IntArg(255));\n+\n+  ASSERT_THAT(Run({\n+                  \"bitfield\",\n+                  \"foo\",\n+                  \"set\",\n+                  \"u1\",\n+                  \"0\",\n+                  \"0\",\n+                  \"incrby\",\n+                  \"u1\",\n+                  \"0\",\n+                  \"1\",\n+                  \"get\",\n+                  \"u1\",\n+                  \"0\",\n+              }),\n+              RespArray(ElementsAre(IntArg(1), IntArg(1), IntArg(1))));\n+\n+  // check for positional offsets\n+  Run({\"bitfield\", \"foo\", \"set\", \"u8\", \"#0\", \"1\", \"set\", \"u8\", \"#1\", \"1\", \"set\", \"u8\", \"#2\", \"1\"});\n+\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"7\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"bitfield\", \"foo\", \"get\", \"u1\", \"15\"}), IntArg(1));\n+}\n+\n }  // end of namespace dfly\n",
  "problem_statement": "support BITFIELD command\n### Discussed in https://github.com/dragonflydb/dragonfly/discussions/212\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **koron** July 20, 2022</sup>\r\nAre there any plans to support the [BITMAP commands group](https://redis.io/commands/?group=bitmap)?\r\n\r\n</div>\r\n\r\n### Summary\r\n\r\nI want to use [`BITFIELD` command](https://redis.io/commands/bitfield/) for specifalized bloom filter [koron/java-vbf](https://github.com/koron/java-vbf). It uses `BITFIELD` to get/set partial bits of a string, with combining transaction (`MULTI` / `EXEC`).\r\n\r\n### How can you test with java-vbf\r\n\r\n1. Install JDK 8 or higher (ex. [OpenJDK 18](https://jdk.java.net/18/))\r\n2. Install [gradle](https://gradle.org/install/)\r\n3. Run redis (or dragonfly) on `localhost:6379`\r\n4. Checkout https://github.com/koron/java-vbf\r\n    ```console\r\n    $ git clone https://github.com/koron/java-vbf.git\r\n    ```\r\n5. Run tests with gradle wrapper\r\n    ```console\r\n    $ ./gradlew test --tests '*.vbf3.*'\r\n    ```\r\n    It will take about 20 seconds.\r\n    It will pass with redis, but fail with dragonfly, because dragonfly doesn't support `BITFIELD` command yet.\r\n\r\n### More details\r\n\r\nAs you can see in https://redis.io/commands/bitfield/, BITFIELD command is a bit complex. But java-vbf uses in two usecases.\r\n\r\n1. Get multiple partial (u8) values from a key ([code](https://github.com/koron/java-vbf/blob/b007e91e63df72924f09ffbc085faa24381f19ae/src/main/java/net/kaoriya/vbf3/RedisVBF3.java#L246-L264))\r\n    Example command:\r\n    ```\r\n    BITFIELD somekey GET u8 0 GET u8 32 GET u8 48\r\n    ```\r\n2. Set multiple partial (u8) values for a key ([code](https://github.com/koron/java-vbf/blob/b007e91e63df72924f09ffbc085faa24381f19ae/src/main/java/net/kaoriya/vbf3/RedisVBF3.java#L283-L291))\r\n\r\n    Example command:\r\n    ```\r\n    BITFIELD somekey SET u8 0 111 SET u8 32 222 SET u8 48 333\r\n    ```\r\n\r\nPlease keep in mind that java-vbf does not require all of BITFILED's functionality to run.\n",
  "hints_text": "",
  "created_at": "2023-11-27T11:07:58Z",
  "modified_files": [
    "src/facade/cmd_arg_parser.h",
    "src/server/bitops_family.cc"
  ],
  "modified_test_files": [
    "src/server/bitops_family_test.cc"
  ]
}