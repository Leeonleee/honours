diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py
index 265f0ea96050..7b9196158e5d 100644
--- a/tests/dragonfly/replication_test.py
+++ b/tests/dragonfly/replication_test.py
@@ -26,14 +26,6 @@
 M_NOT_EPOLL = [pytest.mark.exclude_epoll]
 
 
-async def wait_for_replicas_state(*clients, state="online", node_role="slave", timeout=0.05):
-    """Wait until all clients (replicas) reach passed state"""
-    while len(clients) > 0:
-        await asyncio.sleep(timeout)
-        roles = await asyncio.gather(*(c.role() for c in clients))
-        clients = [c for c, role in zip(clients, roles) if role[0] != node_role or role[3] != state]
-
-
 """
 Test full replication pipeline. Test full sync with streaming changes and stable state streaming.
 """
diff --git a/tests/dragonfly/tiering_test.py b/tests/dragonfly/tiering_test.py
index 45b74ec17daf..2384d20a86b8 100644
--- a/tests/dragonfly/tiering_test.py
+++ b/tests/dragonfly/tiering_test.py
@@ -1,14 +1,15 @@
 import async_timeout
 import asyncio
 import itertools
+import logging
 import pytest
 import random
 import redis.asyncio as aioredis
 
 from . import dfly_args
 from .seeder import DebugPopulateSeeder
-from .utility import info_tick_timer
-
+from .utility import info_tick_timer, wait_for_replicas_state
+from .instance import DflyInstanceFactory
 
 BASIC_ARGS = {"port": 6379, "proactor_threads": 4, "tiered_prefix": "/tmp/tiered/backing"}
 
@@ -87,3 +88,35 @@ async def run(sub_ops):
     res = await p.execute()
 
     assert res == [10 * k for k in key_range]
+
+
+@pytest.mark.exclude_epoll
+@pytest.mark.opt_only
+@dfly_args(
+    {
+        "proactor_threads": 2,
+        "tiered_prefix": "/tmp/tiered/backing_master",
+        "maxmemory": "4G",
+        "cache_mode": True,
+        "tiered_offload_threshold": "0.2",
+        "tiered_storage_write_depth": 100,
+    }
+)
+async def test_full_sync(async_client: aioredis.Redis, df_factory: DflyInstanceFactory):
+    replica = df_factory.create(
+        proactor_threads=2,
+        cache_mode=True,
+        maxmemory="4G",
+        tiered_prefix="/tmp/tiered/backing_replica",
+        tiered_offload_threshold="0.2",
+        tiered_storage_write_depth=1000,
+    )
+    replica.start()
+    replica_client = replica.client()
+    await async_client.execute_command("debug", "populate", "3000000", "key", "2000")
+    await replica_client.replicaof(
+        "localhost", async_client.connection_pool.connection_kwargs["port"]
+    )
+    logging.info("Waiting for replica to sync")
+    async with async_timeout.timeout(120):
+        await wait_for_replicas_state(replica_client)
diff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py
index 5e6fe38c6d01..36f28c763af6 100644
--- a/tests/dragonfly/utility.py
+++ b/tests/dragonfly/utility.py
@@ -848,3 +848,11 @@ def extract_int_after_prefix(prefix, line):
     match = re.search(prefix + "(\\d+)", line)
     assert match
     return int(match.group(1))
+
+
+async def wait_for_replicas_state(*clients, state="online", node_role="slave", timeout=0.05):
+    """Wait until all clients (replicas) reach passed state"""
+    while len(clients) > 0:
+        await asyncio.sleep(timeout)
+        roles = await asyncio.gather(*(c.role() for c in clients))
+        clients = [c for c, role in zip(clients, roles) if role[0] != node_role or role[3] != state]
