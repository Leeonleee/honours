{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1670,
  "instance_id": "dragonflydb__dragonfly-1670",
  "issue_numbers": [
    "1496"
  ],
  "base_commit": "116934b0088bf6525c7dde6152a84b4e076795e5",
  "patch": "diff --git a/helio b/helio\nindex c8ccbbdf9113..963304405500 160000\n--- a/helio\n+++ b/helio\n@@ -1,1 +1,1 @@\n-Subproject commit c8ccbbdf9113e5d3f1dc16c6cb96396ac7e3694d\n+Subproject commit 96330440550013c69da14ae173049bf80e1e9257\ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex f415b09698c8..5ce02265f09c 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -11,6 +11,7 @@\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n #include \"facade/conn_context.h\"\n+#include \"facade/dragonfly_listener.h\"\n #include \"facade/memcache_parser.h\"\n #include \"facade/redis_parser.h\"\n #include \"facade/service_interface.h\"\n@@ -399,8 +400,7 @@ uint32_t Connection::GetClientId() const {\n }\n \n bool Connection::IsAdmin() const {\n-  uint16_t admin_port = absl::GetFlag(FLAGS_admin_port);\n-  return socket_->LocalEndpoint().port() == admin_port;\n+  return static_cast<Listener*>(owner())->IsAdminInterface();\n }\n \n io::Result<bool> Connection::CheckForHttpProto(FiberSocketBase* peer) {\ndiff --git a/src/facade/dragonfly_listener.cc b/src/facade/dragonfly_listener.cc\nindex 05e681de1f21..1f2b7f0a412d 100644\n--- a/src/facade/dragonfly_listener.cc\n+++ b/src/facade/dragonfly_listener.cc\n@@ -202,6 +202,14 @@ bool Listener::AwaitDispatches(absl::Duration timeout,\n   return false;\n }\n \n+bool Listener::IsAdminInterface() const {\n+  return is_admin_;\n+}\n+\n+void Listener::SetAdminInterface(bool is_admin) {\n+  is_admin_ = is_admin;\n+}\n+\n void Listener::PreShutdown() {\n   // Iterate on all connections and allow them to finish their commands for\n   // a short period.\n@@ -267,6 +275,10 @@ void Listener::OnConnectionClose(util::Connection* conn) {\n   }\n }\n \n+void Listener::OnMaxConnectionsReached(util::FiberSocketBase* sock) {\n+  sock->Write(io::Buffer(\"-ERR max number of clients reached\\r\\n\"));\n+}\n+\n // We can limit number of threads handling dragonfly connections.\n ProactorBase* Listener::PickConnectionProactor(util::FiberSocketBase* sock) {\n   util::ProactorPool* pp = pool();\ndiff --git a/src/facade/dragonfly_listener.h b/src/facade/dragonfly_listener.h\nindex d81832241870..b5a4041437f4 100644\n--- a/src/facade/dragonfly_listener.h\n+++ b/src/facade/dragonfly_listener.h\n@@ -35,12 +35,16 @@ class Listener : public util::ListenerInterface {\n   bool AwaitDispatches(absl::Duration timeout,\n                        const std::function<bool(util::Connection*)>& filter);\n \n+  bool IsAdminInterface() const;\n+  void SetAdminInterface(bool is_admin = true);\n+\n  private:\n   util::Connection* NewConnection(ProactorBase* proactor) final;\n   ProactorBase* PickConnectionProactor(util::FiberSocketBase* sock) final;\n \n   void OnConnectionStart(util::Connection* conn) final;\n   void OnConnectionClose(util::Connection* conn) final;\n+  void OnMaxConnectionsReached(util::FiberSocketBase* sock) final;\n   void PreAcceptLoop(ProactorBase* pb) final;\n \n   void PreShutdown() final;\n@@ -58,6 +62,8 @@ class Listener : public util::ListenerInterface {\n \n   std::atomic_uint32_t next_id_{0};\n \n+  bool is_admin_ = false;\n+\n   uint32_t conn_cnt_{0};\n   uint32_t min_cnt_thread_id_{0};\n   int32_t min_cnt_{0};\ndiff --git a/src/server/config_registry.cc b/src/server/config_registry.cc\nindex c805614badb4..2f99a211355c 100644\n--- a/src/server/config_registry.cc\n+++ b/src/server/config_registry.cc\n@@ -39,6 +39,17 @@ bool ConfigRegistry::Set(std::string_view config_name, std::string_view value) {\n   return cb(*flag);\n }\n \n+std::optional<std::string> ConfigRegistry::Get(std::string_view config_name) {\n+  unique_lock lk(mu_);\n+  if (!registry_.contains(config_name))\n+    return std::nullopt;\n+  lk.unlock();\n+\n+  absl::CommandLineFlag* flag = absl::FindCommandLineFlag(config_name);\n+  CHECK(flag);\n+  return flag->CurrentValue();\n+}\n+\n void ConfigRegistry::Reset() {\n   unique_lock lk(mu_);\n   registry_.clear();\ndiff --git a/src/server/config_registry.h b/src/server/config_registry.h\nindex 92eb4d1a568f..ae7c8eacff9b 100644\n--- a/src/server/config_registry.h\n+++ b/src/server/config_registry.h\n@@ -19,6 +19,8 @@ class ConfigRegistry {\n   // Returns true if the value was updated.\n   bool Set(std::string_view config_name, std::string_view value);\n \n+  std::optional<std::string> Get(std::string_view config_name);\n+\n   void Reset();\n \n  private:\ndiff --git a/src/server/dfly_main.cc b/src/server/dfly_main.cc\nindex 829666d08608..4dab9d6a10ea 100644\n--- a/src/server/dfly_main.cc\n+++ b/src/server/dfly_main.cc\n@@ -388,6 +388,7 @@ bool RunEngine(ProactorPool* pool, AcceptServer* acceptor) {\n     const std::string printable_addr =\n         absl::StrCat(\"admin socket \", interface_addr ? interface_addr : \"any\", \":\", admin_port);\n     Listener* admin_listener = new Listener{Protocol::REDIS, &service};\n+    admin_listener->SetAdminInterface();\n     error_code ec = acceptor->AddListener(interface_addr, admin_port, admin_listener);\n \n     if (ec) {\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 146b73b6ae77..1fc83089faa9 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -59,6 +59,8 @@ ABSL_FLAG(string, dbfilename, \"dump-{timestamp}\", \"the filename to save/load the\n ABSL_FLAG(string, requirepass, \"\",\n           \"password for AUTH authentication. \"\n           \"If empty can also be set with DFLY_PASSWORD environment variable.\");\n+ABSL_FLAG(uint32_t, maxclients, 64000, \"Maximum number of concurrent clients allowed.\");\n+\n ABSL_FLAG(string, save_schedule, \"\",\n           \"glob spec for the UTC time to save a snapshot which matches HH:MM 24h time\");\n ABSL_FLAG(string, snapshot_cron, \"\",\n@@ -563,12 +565,28 @@ ServerFamily::ServerFamily(Service* service) : service_(*service) {\n ServerFamily::~ServerFamily() {\n }\n \n+void SetMaxClients(std::vector<facade::Listener*>& listeners, uint32_t maxclients) {\n+  for (auto* listener : listeners) {\n+    if (!listener->IsAdminInterface()) {\n+      listener->SetMaxClients(maxclients);\n+    }\n+  }\n+}\n+\n void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*> listeners) {\n   CHECK(acceptor_ == nullptr);\n   acceptor_ = acceptor;\n   listeners_ = std::move(listeners);\n   dfly_cmd_ = make_unique<DflyCmd>(this);\n \n+  SetMaxClients(listeners_, absl::GetFlag(FLAGS_maxclients));\n+  config_registry.Register(\"maxclients\", [this](const absl::CommandLineFlag& flag) {\n+    auto res = flag.TryGet<uint32_t>();\n+    if (res.has_value())\n+      SetMaxClients(listeners_, res.value());\n+    return res.has_value();\n+  });\n+\n   pb_task_ = shard_set->pool()->GetNextProactor();\n   if (pb_task_->GetKind() == ProactorBase::EPOLL) {\n     fq_threadpool_.reset(new FiberQueueThreadPool(absl::GetFlag(FLAGS_epoll_file_threads)));\n@@ -1514,9 +1532,10 @@ void ServerFamily::Config(CmdArgList args, ConnectionContext* cntx) {\n     if (param == \"databases\") {\n       res.emplace_back(param);\n       res.push_back(absl::StrCat(absl::GetFlag(FLAGS_dbnum)));\n-    } else if (param == \"maxmemory\") {\n+    } else if (auto value_from_registry = config_registry.Get(param);\n+               value_from_registry.has_value()) {\n       res.emplace_back(param);\n-      res.push_back(absl::StrCat(max_memory_limit));\n+      res.push_back(*value_from_registry);\n     }\n \n     return (*cntx)->SendStringArr(res, RedisReplyBuilder::MAP);\n",
  "test_patch": "diff --git a/tests/dragonfly/config_test.py b/tests/dragonfly/config_test.py\nnew file mode 100644\nindex 000000000000..903e7e535495\n--- /dev/null\n+++ b/tests/dragonfly/config_test.py\n@@ -0,0 +1,27 @@\n+import pytest\n+import redis\n+from redis.asyncio import Redis as RedisClient\n+from .utility import *\n+from . import DflyStartException\n+\n+\n+async def test_maxclients(df_factory):\n+    # Needs some authentication\n+    server = df_factory.create(port=1111, maxclients=1, admin_port=1112)\n+    server.start()\n+\n+    async with server.client() as client1:\n+        assert [b\"maxclients\", b\"1\"] == await client1.execute_command(\"CONFIG GET maxclients\")\n+\n+        with pytest.raises(redis.exceptions.ConnectionError):\n+            async with server.client() as client2:\n+                await client2.get(\"test\")\n+\n+        # Check that admin connections are not limited.\n+        async with RedisClient(port=server.admin_port) as admin_client:\n+            await admin_client.get(\"test\")\n+\n+        await client1.execute_command(\"CONFIG SET maxclients 3\")\n+        assert [b\"maxclients\", b\"3\"] == await client1.execute_command(\"CONFIG GET maxclients\")\n+        async with server.client() as client2:\n+            await client2.get(\"test\")\n",
  "problem_statement": "introduce maxclients flag\nDragonflyDB should be able to protect itself from opening too many connections on the primary port. Otherwise, it will risk reaching max number of open files. \r\n\r\nDragonfly can support a high number by default, I would say 64k is ok as a default for the flag.\r\nRedis sets it as 1000: https://github.com/redis/redis/blob/6bf9b144ef722fb301c065125a6bf6cd385841bf/src/config.c#L3188 \r\n\r\nAlso, we should provide a friendly warning on startup if max files ulimit is lower than `maxclients` - see https://github.com/redis/redis/blob/6bf9b144ef722fb301c065125a6bf6cd385841bf/src/server.c#L2278 and \r\nhttps://github.com/redis/redis/blob/6bf9b144ef722fb301c065125a6bf6cd385841bf/src/config.c#L2539 for example\n",
  "hints_text": "@ashotland @Pothulapati  I suggest tracking connection count metrics in our monitoring dashboards.\r\nAlso, pls create a follow-up issue - we should configure dragonfly by setting this TBD flag according to the instance memory. \nConnection count is already part of the dashboard.\r\n\r\nCreated controlplane issue. \n@royjacobson Note: We will need to support setting this flag from config set command",
  "created_at": "2023-08-08T21:00:20Z",
  "modified_files": [
    "helio",
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_listener.cc",
    "src/facade/dragonfly_listener.h",
    "src/server/config_registry.cc",
    "src/server/config_registry.h",
    "src/server/dfly_main.cc",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "b/tests/dragonfly/config_test.py"
  ]
}