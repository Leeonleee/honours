diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc
index 028d594eef9f..8560bcde5ee0 100644
--- a/src/facade/reply_builder_test.cc
+++ b/src/facade/reply_builder_test.cc
@@ -775,6 +775,27 @@ TEST_F(RedisReplyBuilderTest, SendScoredArray) {
       << "Resp3 WITHSCORES failed.";
 }
 
+TEST_F(RedisReplyBuilderTest, SendLabeledScoredArray) {
+  const std::vector<std::pair<std::string, double>> scored_array{
+      {"e1", 1.1}, {"e2", 2.2}, {"e3", 3.3}};
+
+  builder_->SetResp3(false);
+  builder_->SendLabeledScoredArray("foobar", scored_array);
+  ASSERT_TRUE(NoErrors());
+  ASSERT_EQ(TakePayload(),
+            "*2\r
$6\r
foobar\r
*3\r
*2\r
$2\r
e1\r
$3\r
1.1\r
*2\r
$2\r
e2\r
$3\r
2."
+            "2\r
*2\r
$2\r
e3\r
$3\r
3.3\r
")
+      << "Resp3 failed.
";
+
+  builder_->SetResp3(true);
+  builder_->SendLabeledScoredArray("foobar", scored_array);
+  ASSERT_TRUE(NoErrors());
+  ASSERT_EQ(TakePayload(),
+            "*2\r
$6\r
foobar\r
*3\r
*2\r
$2\r
e1\r
,1.1\r
*2\r
$2\r
e2\r
,2.2\r
*"
+            "2\r
$2\r
e3\r
,3.3\r
")
+      << "Resp3 failed.";
+}
+
 TEST_F(RedisReplyBuilderTest, BasicCapture) {
   GTEST_SKIP() << "Unmark when CaptuingReplyBuilder is updated";
 
diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc
index 140488741de7..e38a364fbabf 100644
--- a/src/server/zset_family_test.cc
+++ b/src/server/zset_family_test.cc
@@ -81,6 +81,32 @@ MATCHER_P(UnorderedScoredElementsAreMatcher, elements_list, "") {
                              elements_list.end());
 }
 
+MATCHER_P2(ContainsLabeledScoredArrayMatcher, label, elements, "") {
+  auto label_vec = arg.GetVec();
+  if (label_vec.size() != 2) {
+    *result_listener << "Labeled Scored Array does no contain two elements.";
+    return false;
+  }
+
+  if (!ExplainMatchResult(Eq(label), label_vec[0].GetString(), result_listener)) {
+    return false;
+  }
+
+  auto value_pairs_vec = label_vec[1].GetVec();
+  std::set<std::pair<std::string, std::string>> actual_elements;
+  for (const auto& scored_element : value_pairs_vec) {
+    actual_elements.insert(std::make_pair(scored_element.GetVec()[0].GetString(),
+                                          scored_element.GetVec()[1].GetString()));
+  }
+  if (actual_elements != elements) {
+    *result_listener << "Scored elements do not match: ";
+    ExplainMatchResult(ElementsAreArray(elements), actual_elements, result_listener);
+    return false;
+  }
+
+  return true;
+}
+
 auto ConsistsOf(std::initializer_list<std::string> elements) {
   return ConsistsOfMatcher(std::unordered_set<std::string>{elements});
 }
@@ -98,6 +124,12 @@ auto UnorderedScoredElementsAre(
   return UnorderedScoredElementsAreMatcher(elements);
 }
 
+auto ContainsLabeledScoredArray(
+    std::string_view label, std::initializer_list<std::pair<std::string, std::string>> elements) {
+  return ContainsLabeledScoredArrayMatcher(label,
+                                           std::set<std::pair<std::string, std::string>>{elements});
+}
+
 TEST_F(ZSetFamilyTest, Add) {
   auto resp = Run({"zadd", "x", "1.1", "a"});
   EXPECT_THAT(resp, IntArg(1));
@@ -757,6 +789,102 @@ TEST_F(ZSetFamilyTest, ZAddBug148) {
   EXPECT_THAT(resp, IntArg(1));
 }
 
+TEST_F(ZSetFamilyTest, ZMPopInvalidSyntax) {
+  // Not enough arguments.
+  auto resp = Run({"zmpop", "1", "a"});
+  EXPECT_THAT(resp, ErrArg("wrong number of arguments"));
+
+  // Zero keys.
+  resp = Run({"zmpop", "0", "MIN", "COUNT", "1"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Number of keys not uint.
+  resp = Run({"zmpop", "aa", "a", "MIN"});
+  EXPECT_THAT(resp, ErrArg("value is not an integer or out of range"));
+
+  // Missing MIN/MAX.
+  resp = Run({"zmpop", "1", "a", "COUNT", "1"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Wrong number of keys.
+  resp = Run({"zmpop", "1", "a", "b", "MAX"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Count with no number.
+  resp = Run({"zmpop", "1", "a", "MAX", "COUNT"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+
+  // Count number is not uint.
+  resp = Run({"zmpop", "1", "a", "MIN", "COUNT", "boo"});
+  EXPECT_THAT(resp, ErrArg("value is not an integer or out of range"));
+
+  // Too many arguments.
+  resp = Run({"zmpop", "1", "c", "MAX", "COUNT", "2", "foo"});
+  EXPECT_THAT(resp, ErrArg("syntax error"));
+}
+
+TEST_F(ZSetFamilyTest, ZMPop) {
+  // All sets are empty.
+  auto resp = Run({"zmpop", "1", "e", "MIN"});
+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));
+
+  // Min operation.
+  resp = Run({"zadd", "a", "1", "a1", "2", "a2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"zmpop", "1", "a", "MIN"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("a", {{"a1", "1"}}));
+
+  resp = Run({"ZRANGE", "a", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("a2", "2")));
+
+  // Max operation.
+  resp = Run({"zadd", "b", "1", "b1", "2", "b2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"zmpop", "1", "b", "MAX"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("b", {{"b2", "2"}}));
+
+  resp = Run({"ZRANGE", "b", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("b1", "1")));
+
+  // Count > 1.
+  resp = Run({"zadd", "c", "1", "c1", "2", "c2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"zmpop", "1", "c", "MAX", "COUNT", "2"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("c", {{"c1", "1"}, {"c2", "2"}}));
+
+  resp = Run({"zcard", "c"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  // Count > #elements in set.
+  resp = Run({"zadd", "d", "1", "d1", "2", "d2"});
+  EXPECT_THAT(resp, IntArg(2));
+
+  resp = Run({"zmpop", "1", "d", "MAX", "COUNT", "3"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("d", {{"d1", "1"}, {"d2", "2"}}));
+
+  resp = Run({"zcard", "d"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  // First non empty set is not the first set.
+  resp = Run({"zadd", "x", "1", "x1"});
+  EXPECT_THAT(resp, IntArg(1));
+
+  resp = Run({"zadd", "y", "1", "y1"});
+  EXPECT_THAT(resp, IntArg(1));
+
+  resp = Run({"zmpop", "3", "empty", "x", "y", "MAX"});
+  EXPECT_THAT(resp, ContainsLabeledScoredArray("x", {{"x1", "1"}}));
+
+  resp = Run({"zcard", "x"});
+  EXPECT_THAT(resp, IntArg(0));
+
+  resp = Run({"ZRANGE", "y", "0", "-1", "WITHSCORES"});
+  EXPECT_THAT(resp, RespArray(ElementsAre("y1", "1")));
+}
+
 TEST_F(ZSetFamilyTest, ZPopMin) {
   auto resp = Run({"zadd", "key", "1", "a", "2", "b", "3", "c", "4", "d", "5", "e", "6", "f"});
   EXPECT_THAT(resp, IntArg(6));
