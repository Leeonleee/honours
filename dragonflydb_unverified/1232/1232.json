{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1232,
  "instance_id": "dragonflydb__dragonfly-1232",
  "issue_numbers": [
    "1200"
  ],
  "base_commit": "f80afca9c23e2f30373437520a162c591eaa2005",
  "patch": "diff --git a/src/server/blocking_controller.cc b/src/server/blocking_controller.cc\nindex b6b082b729ac..b543081a5d56 100644\n--- a/src/server/blocking_controller.cc\n+++ b/src/server/blocking_controller.cc\n@@ -212,7 +212,9 @@ void BlockingController::NotifyPending() {\n \n       // Double verify we still got the item.\n       auto [it, exp_it] = owner_->db_slice().FindExt(context, sv_key);\n-      if (!IsValid(it) || it->second.ObjType() != OBJ_LIST)  // Only LIST is allowed to block.\n+      if (!IsValid(it) ||\n+          !(it->second.ObjType() == OBJ_LIST ||\n+            it->second.ObjType() == OBJ_ZSET))  // Only LIST and ZSET are allowed to block.\n         continue;\n \n       NotifyWatchQueue(sv_key, &wt.queue_map);\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex 007672aa021a..91d23f41e97a 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -20,7 +20,7 @@ namespace CO {\n \n enum CommandOpt : uint32_t {\n   READONLY = 1U << 0,\n-  FAST = 1U << 1,\n+  FAST = 1U << 1,  // Unused?\n   WRITE = 1U << 2,\n   LOADING = 1U << 3,  // Command allowed during LOADING state.\n   DENYOOM = 1U << 4,  // use-memory in redis.\ndiff --git a/src/server/container_utils.cc b/src/server/container_utils.cc\nindex 234000792c8c..1ad726a60676 100644\n--- a/src/server/container_utils.cc\n+++ b/src/server/container_utils.cc\n@@ -6,6 +6,10 @@\n #include \"base/logging.h\"\n #include \"core/string_map.h\"\n #include \"core/string_set.h\"\n+#include \"server/engine_shard_set.h\"\n+#include \"server/server_state.h\"\n+#include \"server/transaction.h\"\n+#include \"src/facade/op_status.h\"\n \n extern \"C\" {\n #include \"redis/intset.h\"\n@@ -188,4 +192,126 @@ string_view LpGetView(uint8_t* lp_it, uint8_t int_buf[]) {\n   return std::string_view{reinterpret_cast<char*>(elem), size_t(ele_len)};\n }\n \n+OpResult<ShardFFResult> FindFirstNonEmptyKey(Transaction* trans, int req_obj_type) {\n+  using FFResult = std::pair<PrimeKey, unsigned>;  // key, argument index.\n+  VLOG(2) << \"FindFirst::Find \" << trans->DebugId();\n+\n+  // Holds Find results: (iterator to a found key, and its index in the passed arguments).\n+  // See DbSlice::FindFirst for more details.\n+  // spans all the shards for now.\n+  std::vector<OpResult<FFResult>> find_res(shard_set->size());\n+  std::fill(find_res.begin(), find_res.end(), OpStatus::KEY_NOTFOUND);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    auto args = t->GetShardArgs(shard->shard_id());\n+    OpResult<std::pair<PrimeIterator, unsigned>> ff_res =\n+        shard->db_slice().FindFirst(t->GetDbContext(), args, req_obj_type);\n+\n+    if (ff_res) {\n+      FFResult ff_result(ff_res->first->first.AsRef(), ff_res->second);\n+      find_res[shard->shard_id()] = std::move(ff_result);\n+    } else {\n+      find_res[shard->shard_id()] = ff_res.status();\n+    }\n+\n+    return OpStatus::OK;\n+  };\n+\n+  trans->Execute(std::move(cb), false);\n+\n+  uint32_t min_arg_indx = UINT32_MAX;\n+  ShardFFResult shard_result;\n+\n+  // We iterate over all results to find the key with the minimal arg_index\n+  // after reversing the arg indexing permutation.\n+  for (size_t sid = 0; sid < find_res.size(); ++sid) {\n+    const auto& fr = find_res[sid];\n+    auto status = fr.status();\n+    if (status == OpStatus::KEY_NOTFOUND)\n+      continue;\n+    if (status == OpStatus::WRONG_TYPE) {\n+      return status;\n+    }\n+    CHECK(fr);\n+\n+    const auto& it_pos = fr.value();\n+\n+    size_t arg_indx = trans->ReverseArgIndex(sid, it_pos.second);\n+    if (arg_indx < min_arg_indx) {\n+      min_arg_indx = arg_indx;\n+      shard_result.sid = sid;\n+\n+      // we do not dereference the key, do not extract the string value, so it it\n+      // ok to just move it. We can not dereference it due to limitations of SmallString\n+      // that rely on thread-local data-structure for pointer translation.\n+      shard_result.key = it_pos.first.AsRef();\n+    }\n+  }\n+\n+  if (shard_result.sid == kInvalidSid) {\n+    return OpStatus::KEY_NOTFOUND;\n+  }\n+\n+  return OpResult<ShardFFResult>{std::move(shard_result)};\n+}\n+\n+// If OK is returned then cb was called on the first non empty key and `out_key` is set to the key.\n+facade::OpStatus RunCbOnFirstNonEmptyBlocking(BlockingResultCb&& func, std::string* out_key,\n+                                              Transaction* trans, int req_obj_type,\n+                                              unsigned limit_ms) {\n+  auto limit_tp = limit_ms ? std::chrono::steady_clock::now() + std::chrono::milliseconds(limit_ms)\n+                           : Transaction::time_point::max();\n+  bool is_multi = trans->IsMulti();\n+  trans->Schedule();\n+\n+  ShardFFResult ff_result;\n+  OpResult<ShardFFResult> result = FindFirstNonEmptyKey(trans, req_obj_type);\n+\n+  if (result.ok()) {\n+    ff_result = std::move(result.value());\n+  } else if (result.status() == OpStatus::KEY_NOTFOUND) {\n+    // Close transaction and return.\n+    if (is_multi) {\n+      auto cb = [](Transaction* t, EngineShard* shard) { return OpStatus::OK; };\n+      trans->Execute(std::move(cb), true);\n+      return OpStatus::TIMED_OUT;\n+    }\n+\n+    auto wcb = [](Transaction* t, EngineShard* shard) {\n+      return t->GetShardArgs(shard->shard_id());\n+    };\n+\n+    VLOG(1) << \"Blocking BLPOP \" << trans->DebugId();\n+    auto* stats = ServerState::tl_connection_stats();\n+    ++stats->num_blocked_clients;\n+    bool wait_succeeded = trans->WaitOnWatch(limit_tp, std::move(wcb));\n+    --stats->num_blocked_clients;\n+\n+    if (!wait_succeeded)\n+      return OpStatus::TIMED_OUT;\n+  } else {\n+    // Could be the wrong-type error.\n+    // cleanups, locks removal etc.\n+    auto cb = [](Transaction* t, EngineShard* shard) { return OpStatus::OK; };\n+    trans->Execute(std::move(cb), true);\n+\n+    DCHECK_NE(result.status(), OpStatus::KEY_NOTFOUND);\n+    return result.status();\n+  }\n+\n+  auto cb = [&func, &ff_result, out_key](Transaction* t, EngineShard* shard) {\n+    if (auto wake_key = t->GetWakeKey(shard->shard_id()); wake_key) {\n+      *out_key = *wake_key;\n+      func(t, shard, *out_key);\n+    } else if (shard->shard_id() == ff_result.sid) {\n+      ff_result.key.GetString(out_key);\n+      func(t, shard, *out_key);\n+    }\n+    return OpStatus::OK;\n+  };\n+  trans->Execute(std::move(cb), true);\n+\n+  return OpStatus::OK;\n+}\n+\n }  // namespace dfly::container_utils\ndiff --git a/src/server/container_utils.h b/src/server/container_utils.h\nindex c6ad8a0a7ffa..917d5f13ae19 100644\n--- a/src/server/container_utils.h\n+++ b/src/server/container_utils.h\n@@ -81,6 +81,18 @@ std::string_view LpGetView(uint8_t* lp_it, uint8_t int_buf[]);\n // Find value by key and return stringview to it, otherwise nullopt.\n std::optional<std::string_view> LpFind(uint8_t* lp, std::string_view key, uint8_t int_buf[]);\n \n+struct ShardFFResult {\n+  PrimeKey key;\n+  ShardId sid = kInvalidSid;\n+};\n+\n+OpResult<ShardFFResult> FindFirstNonEmptyKey(Transaction* trans, int req_obj_type);\n+\n+using BlockingResultCb = std::function<void(Transaction*, EngineShard*, std::string_view)>;\n+facade::OpStatus RunCbOnFirstNonEmptyBlocking(BlockingResultCb&& cb, std::string* out_key,\n+                                              Transaction* trans, int req_obj_type,\n+                                              unsigned limit_ms);\n+\n };  // namespace container_utils\n \n }  // namespace dfly\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 5d23533947ac..8eb8cfe5326c 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -341,12 +341,13 @@ pair<PrimeIterator, ExpireIterator> DbSlice::FindExt(const Context& cntx, string\n   return res;\n }\n \n-OpResult<pair<PrimeIterator, unsigned>> DbSlice::FindFirst(const Context& cntx, ArgSlice args) {\n+OpResult<pair<PrimeIterator, unsigned>> DbSlice::FindFirst(const Context& cntx, ArgSlice args,\n+                                                           int req_obj_type) {\n   DCHECK(!args.empty());\n \n   for (unsigned i = 0; i < args.size(); ++i) {\n     string_view s = args[i];\n-    OpResult<PrimeIterator> res = Find(cntx, s, OBJ_LIST);\n+    OpResult<PrimeIterator> res = Find(cntx, s, req_obj_type);\n     if (res)\n       return make_pair(res.value(), i);\n     if (res.status() != OpStatus::KEY_NOTFOUND)\ndiff --git a/src/server/db_slice.h b/src/server/db_slice.h\nindex c02a66ebda2e..b5849b3f66b1 100644\n--- a/src/server/db_slice.h\n+++ b/src/server/db_slice.h\n@@ -149,7 +149,8 @@ class DbSlice {\n \n   // Returns (iterator, args-index) if found, KEY_NOTFOUND otherwise.\n   // If multiple keys are found, returns the first index in the ArgSlice.\n-  OpResult<std::pair<PrimeIterator, unsigned>> FindFirst(const Context& cntx, ArgSlice args);\n+  OpResult<std::pair<PrimeIterator, unsigned>> FindFirst(const Context& cntx, ArgSlice args,\n+                                                         int req_obj_type);\n \n   // Return .second=true if insertion occurred, false if we return the existing key.\n   // throws: bad_alloc is insertion could not happen due to out of memory.\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex d536cdd3e9db..6eb1bc4965ad 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -128,110 +128,13 @@ bool ElemCompare(const quicklistEntry& entry, string_view elem) {\n   return elem == an.Piece();\n }\n \n-using FFResult = pair<PrimeKey, unsigned>;  // key, argument index.\n-\n-struct ShardFFResult {\n-  PrimeKey key;\n-  ShardId sid = kInvalidSid;\n-};\n-\n-// Used by bpopper.\n-OpResult<ShardFFResult> FindFirst(Transaction* trans) {\n-  VLOG(2) << \"FindFirst::Find \" << trans->DebugId();\n-\n-  // Holds Find results: (iterator to a found key, and its index in the passed arguments).\n-  // See DbSlice::FindFirst for more details.\n-  // spans all the shards for now.\n-  std::vector<OpResult<FFResult>> find_res(shard_set->size());\n-  fill(find_res.begin(), find_res.end(), OpStatus::KEY_NOTFOUND);\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    auto args = t->GetShardArgs(shard->shard_id());\n-\n-    OpResult<pair<PrimeIterator, unsigned>> ff_res =\n-        shard->db_slice().FindFirst(t->GetDbContext(), args);\n-\n-    if (ff_res) {\n-      FFResult ff_result(ff_res->first->first.AsRef(), ff_res->second);\n-      find_res[shard->shard_id()] = move(ff_result);\n-    } else {\n-      find_res[shard->shard_id()] = ff_res.status();\n-    }\n-\n-    return OpStatus::OK;\n-  };\n-\n-  trans->Execute(move(cb), false);\n-\n-  uint32_t min_arg_indx = UINT32_MAX;\n-\n-  ShardFFResult shard_result;\n-\n-  for (size_t sid = 0; sid < find_res.size(); ++sid) {\n-    const auto& fr = find_res[sid];\n-    auto status = fr.status();\n-    if (status == OpStatus::KEY_NOTFOUND)\n-      continue;\n-\n-    if (status == OpStatus::WRONG_TYPE) {\n-      return status;\n-    }\n-\n-    CHECK(fr);\n-\n-    const auto& it_pos = fr.value();\n-\n-    size_t arg_indx = trans->ReverseArgIndex(sid, it_pos.second);\n-    if (arg_indx < min_arg_indx) {\n-      min_arg_indx = arg_indx;\n-      shard_result.sid = sid;\n-\n-      // we do not dereference the key, do not extract the string value, so it it\n-      // ok to just move it. We can not dereference it due to limitations of SmallString\n-      // that rely on thread-local data-structure for pointer translation.\n-      shard_result.key = it_pos.first.AsRef();\n-    }\n-  }\n-\n-  if (shard_result.sid == kInvalidSid) {\n-    return OpStatus::KEY_NOTFOUND;\n-  }\n-\n-  return OpResult<ShardFFResult>{move(shard_result)};\n-}\n-\n-class BPopper {\n- public:\n-  explicit BPopper(ListDir dir);\n-\n-  // Returns WRONG_TYPE, OK.\n-  // If OK is returned then use result() to fetch the value.\n-  OpStatus Run(Transaction* t, unsigned msec);\n-\n-  // returns (key, value) pair.\n-  auto result() const {\n-    return make_pair<string_view, string_view>(key_, value_);\n-  }\n-\n- private:\n-  void Pop(Transaction* t, EngineShard* shard);\n-  void OpPop(Transaction* t, EngineShard* shard);\n-\n-  ListDir dir_;\n-\n-  ShardFFResult ff_result_;\n-\n-  string key_;\n-  string value_;\n-};\n-\n class BPopPusher {\n  public:\n   BPopPusher(string_view pop_key, string_view push_key, ListDir popdir, ListDir pushdir);\n \n   // Returns WRONG_TYPE, OK.\n   // If OK is returned then use result() to fetch the value.\n-  OpResult<string> Run(Transaction* t, unsigned msec);\n+  OpResult<string> Run(Transaction* t, unsigned limit_ms);\n \n  private:\n   OpResult<string> RunSingle(Transaction* t, time_point tp);\n@@ -241,90 +144,30 @@ class BPopPusher {\n   ListDir popdir_, pushdir_;\n };\n \n-BPopper::BPopper(ListDir dir) : dir_(dir) {\n-}\n-\n-OpStatus BPopper::Run(Transaction* trans, unsigned msec) {\n-  auto tp = msec ? chrono::steady_clock::now() + chrono::milliseconds(msec) : time_point::max();\n-  bool is_multi = trans->IsMulti();\n-\n-  trans->Schedule();\n-\n-  auto* stats = ServerState::tl_connection_stats();\n-\n-  OpResult<ShardFFResult> result = FindFirst(trans);\n-\n-  if (result.ok()) {\n-    ff_result_ = move(result.value());\n-  } else if (result.status() == OpStatus::KEY_NOTFOUND) {\n-    // Close transaction and return.\n-    if (is_multi) {\n-      auto cb = [](Transaction* t, EngineShard* shard) { return OpStatus::OK; };\n-      trans->Execute(std::move(cb), true);\n-      return OpStatus::TIMED_OUT;\n-    }\n-\n-    auto wcb = [](Transaction* t, EngineShard* shard) {\n-      return t->GetShardArgs(shard->shard_id());\n-    };\n-\n-    VLOG(1) << \"Blocking BLPOP \" << trans->DebugId();\n-    ++stats->num_blocked_clients;\n-    bool wait_succeeded = trans->WaitOnWatch(tp, std::move(wcb));\n-    --stats->num_blocked_clients;\n-\n-    if (!wait_succeeded)\n-      return OpStatus::TIMED_OUT;\n-  } else {\n-    // Could be the wrong-type error.\n-    // cleanups, locks removal etc.\n-    auto cb = [](Transaction* t, EngineShard* shard) { return OpStatus::OK; };\n-    trans->Execute(std::move(cb), true);\n-\n-    DCHECK_NE(result.status(), OpStatus::KEY_NOTFOUND);\n-    return result.status();\n-  }\n-\n-  auto cb = [this](Transaction* t, EngineShard* shard) {\n-    Pop(t, shard);\n-    return OpStatus::OK;\n-  };\n-  trans->Execute(std::move(cb), true);\n-\n-  return OpStatus::OK;\n-}\n-\n-void BPopper::Pop(Transaction* t, EngineShard* shard) {\n-  if (auto wake_key = t->GetWakeKey(shard->shard_id()); wake_key) {\n-    key_ = *wake_key;\n-    OpPop(t, shard);\n-  } else if (shard->shard_id() == ff_result_.sid) {\n-    ff_result_.key.GetString(&key_);\n-    OpPop(t, shard);\n-  }\n-}\n-\n-void BPopper::OpPop(Transaction* t, EngineShard* shard) {\n+// Called as a callback from MKBlocking after we've determined which key to pop.\n+std::string OpBPop(Transaction* t, EngineShard* shard, std::string_view key, ListDir dir) {\n   auto& db_slice = shard->db_slice();\n-  auto it_res = db_slice.Find(t->GetDbContext(), key_, OBJ_LIST);\n-  CHECK(it_res) << t->DebugId() << \" \" << key_;  // must exist and must be ok.\n+  auto it_res = db_slice.Find(t->GetDbContext(), key, OBJ_LIST);\n+  CHECK(it_res) << t->DebugId() << \" \" << key;  // must exist and must be ok.\n   PrimeIterator it = *it_res;\n \n   quicklist* ql = GetQL(it->second);\n \n-  DVLOG(2) << \"popping from \" << key_ << \" \" << t->DebugId();\n+  DVLOG(2) << \"popping from \" << key << \" \" << t->DebugId();\n   db_slice.PreUpdate(t->GetDbIndex(), it);\n-  value_ = ListPop(dir_, ql);\n-  db_slice.PostUpdate(t->GetDbIndex(), it, key_);\n+  std::string value = ListPop(dir, ql);\n+  db_slice.PostUpdate(t->GetDbIndex(), it, key);\n   if (quicklistCount(ql) == 0) {\n-    DVLOG(1) << \"deleting key \" << key_ << \" \" << t->DebugId();\n+    DVLOG(1) << \"deleting key \" << key << \" \" << t->DebugId();\n     CHECK(shard->db_slice().Del(t->GetDbIndex(), it));\n   }\n   OpArgs op_args = t->GetOpArgs(shard);\n   if (op_args.shard->journal()) {\n-    string command = dir_ == ListDir::LEFT ? \"LPOP\" : \"RPOP\";\n-    RecordJournal(op_args, command, ArgSlice{key_}, 1);\n+    string command = dir == ListDir::LEFT ? \"LPOP\" : \"RPOP\";\n+    RecordJournal(op_args, command, ArgSlice{key}, 1);\n   }\n+\n+  return value;\n }\n \n OpResult<string> OpMoveSingleShard(const OpArgs& op_args, string_view src, string_view dest,\n@@ -951,9 +794,9 @@ BPopPusher::BPopPusher(string_view pop_key, string_view push_key, ListDir popdir\n     : pop_key_(pop_key), push_key_(push_key), popdir_(popdir), pushdir_(pushdir) {\n }\n \n-OpResult<string> BPopPusher::Run(Transaction* t, unsigned msec) {\n+OpResult<string> BPopPusher::Run(Transaction* t, unsigned limit_ms) {\n   time_point tp =\n-      msec ? chrono::steady_clock::now() + chrono::milliseconds(msec) : time_point::max();\n+      limit_ms ? chrono::steady_clock::now() + chrono::milliseconds(limit_ms) : time_point::max();\n \n   t->Schedule();\n \n@@ -1308,16 +1151,17 @@ void ListFamily::BPopGeneric(ListDir dir, CmdArgList args, ConnectionContext* cn\n   VLOG(1) << \"BPop timeout(\" << timeout << \")\";\n \n   Transaction* transaction = cntx->transaction;\n-  BPopper popper(dir);\n-  OpStatus result = popper.Run(transaction, unsigned(timeout * 1000));\n+  std::string popped_key;\n+  std::string popped_value;\n+  OpStatus result = container_utils::RunCbOnFirstNonEmptyBlocking(\n+      [dir, &popped_value](Transaction* t, EngineShard* shard, std::string_view key) {\n+        popped_value = OpBPop(t, shard, key, dir);\n+      },\n+      &popped_key, transaction, OBJ_LIST, unsigned(timeout * 1000));\n \n   if (result == OpStatus::OK) {\n-    auto res = popper.result();\n-\n-    DVLOG(1) << \"BPop \" << transaction->DebugId() << \" popped from key \" << res.first;  // key.\n-\n-    std::string_view str_arr[2] = {res.first, res.second};\n-\n+    DVLOG(1) << \"BPop \" << transaction->DebugId() << \" popped from key \" << popped_key;  // key.\n+    std::string_view str_arr[2] = {popped_key, popped_value};\n     return (*cntx)->SendStringArr(str_arr);\n   }\n \ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 2e3b48c9b99d..82bbae7c5e83 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -14,6 +14,7 @@ extern \"C\" {\n #include \"base/logging.h\"\n #include \"base/stl_util.h\"\n #include \"facade/error.h\"\n+#include \"server/blocking_controller.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n #include \"server/container_utils.h\"\n@@ -119,6 +120,12 @@ OpResult<PrimeIterator> FindZEntry(const ZParams& zparams, const OpArgs& op_args\n     db_slice.PreUpdate(op_args.db_cntx.db_index, it);\n   }\n \n+  if (add_res.second && op_args.shard->blocking_controller()) {\n+    string tmp;\n+    string_view key = it->first.GetSlice(&tmp);\n+    op_args.shard->blocking_controller()->AwakeWatched(op_args.db_cntx.db_index, key);\n+  }\n+\n   return it;\n }\n \n@@ -1111,8 +1118,99 @@ bool ParseLimit(string_view offset_str, string_view limit_str, ZSetFamily::Range\n   return true;\n }\n \n+ZSetFamily::ScoredArray OpBZPop(Transaction* t, EngineShard* shard, std::string_view key,\n+                                bool is_max) {\n+  auto& db_slice = shard->db_slice();\n+  auto it_res = db_slice.Find(t->GetDbContext(), key, OBJ_ZSET);\n+  CHECK(it_res) << t->DebugId() << \" \" << key;  // must exist and must be ok.\n+  PrimeIterator it = *it_res;\n+\n+  ZSetFamily::RangeParams range_params;\n+  range_params.reverse = is_max;\n+  range_params.with_scores = true;\n+  ZSetFamily::ZRangeSpec range_spec;\n+  range_spec.params = range_params;\n+  range_spec.interval = ZSetFamily::TopNScored(1);\n+\n+  DVLOG(2) << \"popping from \" << key << \" \" << t->DebugId();\n+  db_slice.PreUpdate(t->GetDbIndex(), it);\n+  robj* zobj = it_res.value()->second.AsRObj();\n+\n+  IntervalVisitor iv{Action::POP, range_spec.params, zobj};\n+  std::visit(iv, range_spec.interval);\n+\n+  it_res.value()->second.SyncRObj();\n+  db_slice.PostUpdate(t->GetDbIndex(), *it_res, key);\n+\n+  auto zlen = zsetLength(zobj);\n+  if (zlen == 0) {\n+    DVLOG(1) << \"deleting key \" << key << \" \" << t->DebugId();\n+    CHECK(db_slice.Del(t->GetDbIndex(), *it_res));\n+  }\n+\n+  OpArgs op_args = t->GetOpArgs(shard);\n+  if (op_args.shard->journal()) {\n+    string command = is_max ? \"ZPOPMAX\" : \"ZPOPMIN\";\n+    RecordJournal(op_args, command, ArgSlice{key}, 1);\n+  }\n+\n+  return iv.PopResult();\n+}\n+\n+void BZPopMinMax(CmdArgList args, ConnectionContext* cntx, bool is_max) {\n+  DCHECK_GE(args.size(), 2u);\n+\n+  float timeout;\n+  auto timeout_str = ArgS(args, args.size() - 1);\n+  if (!absl::SimpleAtof(timeout_str, &timeout)) {\n+    return (*cntx)->SendError(\"timeout is not a float or out of range\");\n+  }\n+  if (timeout < 0) {\n+    return (*cntx)->SendError(\"timeout is negative\");\n+  }\n+  VLOG(1) << \"BZPop timeout(\" << timeout << \")\";\n+\n+  Transaction* transaction = cntx->transaction;\n+  std::string popped_key;\n+  OpResult<ZSetFamily::ScoredArray> popped_array;\n+  OpStatus result = container_utils::RunCbOnFirstNonEmptyBlocking(\n+      [is_max, &popped_array](Transaction* t, EngineShard* shard, std::string_view key) {\n+        popped_array = OpBZPop(t, shard, key, is_max);\n+      },\n+      &popped_key, transaction, OBJ_ZSET, unsigned(timeout * 1000));\n+\n+  if (result == OpStatus::OK) {\n+    DVLOG(1) << \"BZPop \" << transaction->DebugId() << \" popped from key \" << popped_key;  // key.\n+    CHECK(popped_array->size() == 1);\n+    (*cntx)->StartArray(3);\n+    (*cntx)->SendBulkString(popped_key);\n+    (*cntx)->SendBulkString(popped_array->front().first);\n+    return (*cntx)->SendDouble(popped_array->front().second);\n+  }\n+\n+  DVLOG(1) << \"result for \" << transaction->DebugId() << \" is \" << result;\n+\n+  switch (result) {\n+    case OpStatus::WRONG_TYPE:\n+      return (*cntx)->SendError(kWrongTypeErr);\n+    case OpStatus::TIMED_OUT:\n+      return (*cntx)->SendNullArray();\n+    default:\n+      LOG(ERROR) << \"Unexpected error \" << result;\n+  }\n+  return (*cntx)->SendNullArray();\n+}\n+\n }  // namespace\n \n+void ZSetFamily::BZPopMin(CmdArgList args, ConnectionContext* cntx) {\n+  BZPopMinMax(args, cntx, false);\n+}\n+\n+void ZSetFamily::BZPopMax(CmdArgList args, ConnectionContext* cntx) {\n+  BZPopMinMax(args, cntx, true);\n+}\n+\n void ZSetFamily::ZAdd(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n \n@@ -2195,34 +2293,39 @@ OpResult<unsigned> ZSetFamily::OpLexCount(const OpArgs& op_args, string_view key\n void ZSetFamily::Register(CommandRegistry* registry) {\n   constexpr uint32_t kStoreMask = CO::WRITE | CO::VARIADIC_KEYS | CO::REVERSE_MAPPING;\n \n-  *registry << CI{\"ZADD\", CO::FAST | CO::WRITE | CO::DENYOOM, -4, 1, 1, 1}.HFUNC(ZAdd)\n-            << CI{\"ZCARD\", CO::FAST | CO::READONLY, 2, 1, 1, 1}.HFUNC(ZCard)\n-            << CI{\"ZCOUNT\", CO::FAST | CO::READONLY, 4, 1, 1, 1}.HFUNC(ZCount)\n-            << CI{\"ZINCRBY\", CO::FAST | CO::WRITE | CO::DENYOOM, 4, 1, 1, 1}.HFUNC(ZIncrBy)\n-            << CI{\"ZINTERSTORE\", kStoreMask, -4, 3, 3, 1}.HFUNC(ZInterStore)\n-            << CI{\"ZINTERCARD\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1}\n-                   .HFUNC(ZInterCard)\n-            << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, 1}.HFUNC(ZLexCount)\n-            << CI{\"ZPOPMAX\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMax)\n-            << CI{\"ZPOPMIN\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMin)\n-            << CI{\"ZREM\", CO::FAST | CO::WRITE, -3, 1, 1, 1}.HFUNC(ZRem)\n-            << CI{\"ZRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRange)\n-            << CI{\"ZRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRank)\n-            << CI{\"ZRANGEBYLEX\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRangeByLex)\n-            << CI{\"ZRANGEBYSCORE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRangeByScore)\n-            << CI{\"ZSCORE\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZScore)\n-            << CI{\"ZMSCORE\", CO::READONLY | CO::FAST, -3, 1, 1, 1}.HFUNC(ZMScore)\n-            << CI{\"ZREMRANGEBYRANK\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByRank)\n-            << CI{\"ZREMRANGEBYSCORE\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByScore)\n-            << CI{\"ZREMRANGEBYLEX\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByLex)\n-            << CI{\"ZREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRange)\n-            << CI{\"ZREVRANGEBYLEX\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByLex)\n-            << CI{\"ZREVRANGEBYSCORE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByScore)\n-            << CI{\"ZREVRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRevRank)\n-            << CI{\"ZSCAN\", CO::READONLY, -3, 1, 1, 1}.HFUNC(ZScan)\n-            << CI{\"ZUNION\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1}\n-                   .HFUNC(ZUnion)\n-            << CI{\"ZUNIONSTORE\", kStoreMask, -4, 3, 3, 1}.HFUNC(ZUnionStore);\n+  *registry\n+      << CI{\"ZADD\", CO::FAST | CO::WRITE | CO::DENYOOM, -4, 1, 1, 1}.HFUNC(ZAdd)\n+      << CI{\"BZPOPMIN\", CO::WRITE | CO::NOSCRIPT | CO::BLOCKING | CO::NO_AUTOJOURNAL, -3, 1, -2, 1}\n+             .HFUNC(BZPopMin)\n+      << CI{\"BZPOPMAX\", CO::WRITE | CO::NOSCRIPT | CO::BLOCKING | CO::NO_AUTOJOURNAL, -3, 1, -2, 1}\n+             .HFUNC(BZPopMax)\n+      << CI{\"ZCARD\", CO::FAST | CO::READONLY, 2, 1, 1, 1}.HFUNC(ZCard)\n+      << CI{\"ZCOUNT\", CO::FAST | CO::READONLY, 4, 1, 1, 1}.HFUNC(ZCount)\n+      << CI{\"ZINCRBY\", CO::FAST | CO::WRITE | CO::DENYOOM, 4, 1, 1, 1}.HFUNC(ZIncrBy)\n+      << CI{\"ZINTERSTORE\", kStoreMask, -4, 3, 3, 1}.HFUNC(ZInterStore)\n+      << CI{\"ZINTERCARD\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1}\n+             .HFUNC(ZInterCard)\n+      << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, 1}.HFUNC(ZLexCount)\n+      << CI{\"ZPOPMAX\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMax)\n+      << CI{\"ZPOPMIN\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMin)\n+      << CI{\"ZREM\", CO::FAST | CO::WRITE, -3, 1, 1, 1}.HFUNC(ZRem)\n+      << CI{\"ZRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRange)\n+      << CI{\"ZRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRank)\n+      << CI{\"ZRANGEBYLEX\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRangeByLex)\n+      << CI{\"ZRANGEBYSCORE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRangeByScore)\n+      << CI{\"ZSCORE\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZScore)\n+      << CI{\"ZMSCORE\", CO::READONLY | CO::FAST, -3, 1, 1, 1}.HFUNC(ZMScore)\n+      << CI{\"ZREMRANGEBYRANK\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByRank)\n+      << CI{\"ZREMRANGEBYSCORE\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByScore)\n+      << CI{\"ZREMRANGEBYLEX\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByLex)\n+      << CI{\"ZREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRange)\n+      << CI{\"ZREVRANGEBYLEX\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByLex)\n+      << CI{\"ZREVRANGEBYSCORE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByScore)\n+      << CI{\"ZREVRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRevRank)\n+      << CI{\"ZSCAN\", CO::READONLY, -3, 1, 1, 1}.HFUNC(ZScan)\n+      << CI{\"ZUNION\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1}.HFUNC(\n+             ZUnion)\n+      << CI{\"ZUNIONSTORE\", kStoreMask, -4, 3, 3, 1}.HFUNC(ZUnionStore);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 48e497957f54..36b8deb528af 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -55,6 +55,9 @@ class ZSetFamily {\n  private:\n   template <typename T> using OpResult = facade::OpResult<T>;\n \n+  static void BZPopMin(CmdArgList args, ConnectionContext* cntx);\n+  static void BZPopMax(CmdArgList args, ConnectionContext* cntx);\n+\n   static void ZAdd(CmdArgList args, ConnectionContext* cntx);\n   static void ZCard(CmdArgList args, ConnectionContext* cntx);\n   static void ZCount(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex e205bb0a5ff1..7b77967a160d 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -527,4 +527,55 @@ TEST_F(ZSetFamilyTest, Resp3) {\n   ASSERT_THAT(resp.GetVec()[1].GetVec(), ElementsAre(\"b\", DoubleArg(2)));\n }\n \n+TEST_F(ZSetFamilyTest, BlockingIsReleased) {\n+  // Inputs for ZSET store commands.\n+  Run({\"ZADD\", \"A\", \"1\", \"x\", \"2\", \"b\"});\n+  Run({\"ZADD\", \"B\", \"1\", \"x\", \"3\", \"b\"});\n+  Run({\"ZADD\", \"C\", \"1\", \"x\", \"10\", \"a\"});\n+  Run({\"ZADD\", \"D\", \"1\", \"x\", \"5\", \"c\"});\n+\n+  vector<string> blocking_keys{\"zset1\", \"zset2\", \"zset3\"};\n+  for (const auto& key : blocking_keys) {\n+    vector<vector<string>> unblocking_commands;\n+    // All commands output the same set {2,x}.\n+    unblocking_commands.push_back({\"ZADD\", key, \"2\", \"x\", \"10\", \"y\"});\n+    unblocking_commands.push_back({\"ZINCRBY\", key, \"2\", \"x\"});\n+    unblocking_commands.push_back({\"ZINTERSTORE\", key, \"2\", \"A\", \"B\"});\n+    unblocking_commands.push_back({\"ZUNIONSTORE\", key, \"2\", \"C\", \"D\"});\n+    // unblocking_commands.push_back({\"ZDIFFSTORE\", key, \"2\", \"A\", \"B\"}); // unimplemented\n+\n+    for (auto& cmd : unblocking_commands) {\n+      RespExpr resp0;\n+      auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+        resp0 = Run({\"BZPOPMIN\", \"zset1\", \"zset2\", \"zset3\", \"0\"});\n+        LOG(INFO) << \"BZPOPMIN\";\n+      });\n+\n+      pp_->at(1)->Await([&] { return Run({cmd.data(), cmd.size()}); });\n+      fb0.Join();\n+\n+      ASSERT_THAT(resp0, ArrLen(3)) << cmd[0];\n+      EXPECT_THAT(resp0.GetVec(), ElementsAre(key, \"x\", \"2\")) << cmd[0];\n+\n+      Run({\"DEL\", key});\n+    }\n+  }\n+}\n+\n+TEST_F(ZSetFamilyTest, BlockingTimeout) {\n+  RespExpr resp0;\n+\n+  auto start = absl::Now();\n+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+    resp0 = Run({\"BZPOPMIN\", \"zset1\", \"1\"});\n+    LOG(INFO) << \"BZPOPMIN\";\n+  });\n+  fb0.Join();\n+  auto dur = absl::Now() - start;\n+\n+  // Check that the timeout duration is not too crazy.\n+  EXPECT_LT(AbsDuration(dur - absl::Milliseconds(1000)), absl::Milliseconds(300));\n+  EXPECT_THAT(resp0, ArgType(RespExpr::NIL_ARRAY));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Implement BZPOPMIN/BZPOPMAX\n\n",
  "hints_text": "",
  "created_at": "2023-05-17T11:44:38Z",
  "modified_files": [
    "src/server/blocking_controller.cc",
    "src/server/command_registry.h",
    "src/server/container_utils.cc",
    "src/server/container_utils.h",
    "src/server/db_slice.cc",
    "src/server/db_slice.h",
    "src/server/list_family.cc",
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}