{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2101,
  "instance_id": "dragonflydb__dragonfly-2101",
  "issue_numbers": [
    "1762"
  ],
  "base_commit": "ecb2703626950039b52ba3b82548dd5659d1982e",
  "patch": "diff --git a/src/server/config_registry.cc b/src/server/config_registry.cc\nindex 7eda2a5a45ea..5a8041589f58 100644\n--- a/src/server/config_registry.cc\n+++ b/src/server/config_registry.cc\n@@ -28,9 +28,10 @@ auto ConfigRegistry::Set(std::string_view config_name, std::string_view value) -\n \n   absl::CommandLineFlag* flag = absl::FindCommandLineFlag(config_name);\n   CHECK(flag);\n-  string error;\n-  if (!flag->ParseFrom(value, &error))\n+  if (string error; !flag->ParseFrom(value, &error)) {\n+    LOG(WARNING) << error;\n     return SetResult::INVALID;\n+  }\n \n   bool success = !cb || cb(*flag);\n   return success ? SetResult::OK : SetResult::INVALID;\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 6420961197b5..67bb2dd5b7a4 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -71,6 +71,14 @@ struct ReplicaOfFlag {\n static bool AbslParseFlag(std::string_view in, ReplicaOfFlag* flag, std::string* err);\n static std::string AbslUnparseFlag(const ReplicaOfFlag& flag);\n \n+struct CronExprFlag {\n+  static constexpr std::string_view kCronPrefix = \"0 \"sv;\n+  std::optional<cron::cronexpr> value;\n+};\n+\n+static bool AbslParseFlag(std::string_view in, CronExprFlag* flag, std::string* err);\n+static std::string AbslUnparseFlag(const CronExprFlag& flag);\n+\n ABSL_FLAG(string, dir, \"\", \"working directory\");\n ABSL_FLAG(string, dbfilename, \"dump-{timestamp}\", \"the filename to save/load the DB\");\n ABSL_FLAG(string, requirepass, \"\",\n@@ -78,9 +86,8 @@ ABSL_FLAG(string, requirepass, \"\",\n           \"If empty can also be set with DFLY_PASSWORD environment variable.\");\n ABSL_FLAG(uint32_t, maxclients, 64000, \"Maximum number of concurrent clients allowed.\");\n \n-ABSL_FLAG(string, save_schedule, \"\",\n-          \"glob spec for the UTC time to save a snapshot which matches HH:MM 24h time\");\n-ABSL_FLAG(string, snapshot_cron, \"\",\n+ABSL_FLAG(string, save_schedule, \"\", \"the flag is deprecated, please use snapshot_cron instead\");\n+ABSL_FLAG(CronExprFlag, snapshot_cron, {},\n           \"cron expression for the time to save a snapshot, crontab style\");\n ABSL_FLAG(bool, df_snapshot_format, true,\n           \"if true, save in dragonfly-specific snapshotting format\");\n@@ -161,6 +168,37 @@ std::string AbslUnparseFlag(const ReplicaOfFlag& flag) {\n   return (flag.has_value()) ? absl::StrCat(flag.host, \":\", flag.port) : \"\";\n }\n \n+bool AbslParseFlag(std::string_view in, CronExprFlag* flag, std::string* err) {\n+  if (in.empty()) {\n+    flag->value = std::nullopt;\n+    return true;\n+  }\n+  if (absl::StartsWith(in, \"\\\"\")) {\n+    *err = absl::StrCat(\"Could it be that you put quotes in the flagfile?\");\n+\n+    return false;\n+  }\n+\n+  std::string raw_cron_expr = absl::StrCat(CronExprFlag::kCronPrefix, in);\n+  try {\n+    VLOG(1) << \"creating cron from: '\" << raw_cron_expr << \"'\";\n+    flag->value = cron::make_cron(raw_cron_expr);\n+    return true;\n+  } catch (const cron::bad_cronexpr& ex) {\n+    *err = ex.what();\n+  }\n+  return false;\n+}\n+\n+std::string AbslUnparseFlag(const CronExprFlag& flag) {\n+  if (flag.value) {\n+    auto str_expr = to_cronstr(*flag.value);\n+    DCHECK(absl::StartsWith(str_expr, CronExprFlag::kCronPrefix));\n+    return str_expr.substr(CronExprFlag::kCronPrefix.size());\n+  }\n+  return \"\";\n+}\n+\n void SlowLogGet(dfly::CmdArgList args, dfly::ConnectionContext* cntx, dfly::Service& service,\n                 std::string_view sub_cmd) {\n   size_t requested_slow_log_length = UINT32_MAX;\n@@ -403,39 +441,30 @@ bool DoesTimeMatchSpecifier(const SnapshotSpec& spec, time_t now) {\n \n std::optional<cron::cronexpr> InferSnapshotCronExpr() {\n   string save_time = GetFlag(FLAGS_save_schedule);\n-  string snapshot_cron_exp = GetFlag(FLAGS_snapshot_cron);\n+  auto cron_expr = GetFlag(FLAGS_snapshot_cron);\n \n-  if (!snapshot_cron_exp.empty() && !save_time.empty()) {\n-    LOG(ERROR) << \"snapshot_cron and save_schedule flags should not be set simultaneously\";\n-    exit(1);\n+  if (cron_expr.value) {\n+    if (!save_time.empty()) {\n+      LOG(ERROR) << \"snapshot_cron and save_schedule flags should not be set simultaneously\";\n+      exit(1);\n+    }\n+    return std::move(cron_expr.value);\n   }\n \n-  string raw_cron_expr;\n   if (!save_time.empty()) {\n-    std::optional<SnapshotSpec> spec = ParseSaveSchedule(save_time);\n-\n-    if (spec) {\n+    if (std::optional<SnapshotSpec> spec = ParseSaveSchedule(save_time); spec) {\n       // Setting snapshot to HH:mm everyday, as specified by `save_schedule` flag\n-      raw_cron_expr = \"0 \" + spec.value().minute_spec + \" \" + spec.value().hour_spec + \" * * *\";\n+      string raw_cron_expr = absl::StrCat(CronExprFlag::kCronPrefix, spec.value().minute_spec, \" \",\n+                                          spec.value().hour_spec, \" * * *\");\n+      try {\n+        VLOG(1) << \"creating cron from: `\" << raw_cron_expr << \"`\";\n+        return cron::make_cron(raw_cron_expr);\n+      } catch (const cron::bad_cronexpr& ex) {\n+        LOG(WARNING) << \"Invalid cron expression: \" << raw_cron_expr;\n+      }\n     } else {\n       LOG(WARNING) << \"Invalid snapshot time specifier \" << save_time;\n     }\n-  } else if (!snapshot_cron_exp.empty()) {\n-    if (absl::StartsWith(snapshot_cron_exp, \"\\\"\")) {\n-      LOG(WARNING) << \"Invalid snapshot cron expression `\" << snapshot_cron_exp\n-                   << \"`, could it be that you put quotes in the flagfile?\";\n-      return nullopt;\n-    }\n-    raw_cron_expr = \"0 \" + snapshot_cron_exp;\n-  }\n-\n-  if (!raw_cron_expr.empty()) {\n-    try {\n-      VLOG(1) << \"creating cron from: `\" << raw_cron_expr << \"`\";\n-      return std::optional<cron::cronexpr>(cron::make_cron(raw_cron_expr));\n-    } catch (const cron::bad_cronexpr& ex) {\n-      LOG(WARNING) << \"Invalid cron expression: \" << raw_cron_expr;\n-    }\n   }\n   return std::nullopt;\n }\n@@ -576,8 +605,24 @@ void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listen\n     }\n   }\n \n-  snapshot_schedule_fb_ =\n-      service_.proactor_pool().GetNextProactor()->LaunchFiber([this] { SnapshotScheduling(); });\n+  const auto create_snapshot_schedule_fb = [this] {\n+    snapshot_schedule_fb_ =\n+        service_.proactor_pool().GetNextProactor()->LaunchFiber([this] { SnapshotScheduling(); });\n+  };\n+  config_registry.RegisterMutable(\n+      \"snapshot_cron\", [this, create_snapshot_schedule_fb](const absl::CommandLineFlag& flag) {\n+        JoinSnapshotSchedule();\n+        create_snapshot_schedule_fb();\n+        return true;\n+      });\n+\n+  create_snapshot_schedule_fb();\n+}\n+\n+void ServerFamily::JoinSnapshotSchedule() {\n+  schedule_done_.Notify();\n+  snapshot_schedule_fb_.JoinIfNeeded();\n+  schedule_done_.Reset();\n }\n \n void ServerFamily::Shutdown() {\n@@ -586,10 +631,7 @@ void ServerFamily::Shutdown() {\n   if (load_result_.valid())\n     load_result_.wait();\n \n-  schedule_done_.Notify();\n-  if (snapshot_schedule_fb_.IsJoinable()) {\n-    snapshot_schedule_fb_.Join();\n-  }\n+  JoinSnapshotSchedule();\n \n   if (save_on_shutdown_ && !absl::GetFlag(FLAGS_dbfilename).empty()) {\n     shard_set->pool()->GetNextProactor()->Await([this] {\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex a79c0e9e4c91..c168b0878253 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -189,6 +189,8 @@ class ServerFamily {\n   void Replicate(std::string_view host, std::string_view port);\n \n  private:\n+  void JoinSnapshotSchedule();\n+\n   uint32_t shard_count() const {\n     return shard_set->size();\n   }\n",
  "test_patch": "diff --git a/tests/dragonfly/snapshot_test.py b/tests/dragonfly/snapshot_test.py\nindex e626e6f23355..c0bc3ac039b1 100644\n--- a/tests/dragonfly/snapshot_test.py\n+++ b/tests/dragonfly/snapshot_test.py\n@@ -192,6 +192,29 @@ async def test_snapshot(self, df_seeder_factory, df_server):\n         assert super().get_main_file(\"test-cron-summary.dfs\")\n \n \n+@dfly_args({**BASIC_ARGS, \"dbfilename\": \"test-set-snapshot_cron\"})\n+class TestSetsnapshot_cron(SnapshotTestBase):\n+    \"\"\"Test set snapshot_cron flag\"\"\"\n+\n+    @pytest.fixture(autouse=True)\n+    def setup(self, tmp_dir: Path):\n+        super().setup(tmp_dir)\n+\n+    @pytest.mark.asyncio\n+    @pytest.mark.slow\n+    async def test_snapshot(self, df_seeder_factory, async_client, df_server):\n+        seeder = df_seeder_factory.create(\n+            port=df_server.port, keys=10, multi_transaction_probability=0\n+        )\n+        await seeder.run(target_deviation=0.5)\n+\n+        await async_client.execute_command(\"CONFIG\", \"SET\", \"snapshot_cron\", \"* * * * *\")\n+\n+        await super().wait_for_save(\"test-set-snapshot_cron-summary.dfs\")\n+\n+        assert super().get_main_file(\"test-set-snapshot_cron-summary.dfs\")\n+\n+\n @dfly_args({**BASIC_ARGS})\n class TestPathEscapes(SnapshotTestBase):\n     \"\"\"Test that we don't allow path escapes. We just check that df_server.start()\n",
  "problem_statement": "snapshot_cron can not be changed at runtime\nDefinition of done: `config set snapshot_cron \"...\"` works.\r\n\r\nPlease note the current code inside `ServerFamily::SnapshotScheduling()` is currently structured  in such way that \r\nit reads the flag only on startup.\r\n\n",
  "hints_text": "it's community feature, not needed by our management plane",
  "created_at": "2023-11-01T13:38:41Z",
  "modified_files": [
    "src/server/config_registry.cc",
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/snapshot_test.py"
  ]
}