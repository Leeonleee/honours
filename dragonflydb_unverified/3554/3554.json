{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3554,
  "instance_id": "dragonflydb__dragonfly-3554",
  "issue_numbers": [
    "3553"
  ],
  "base_commit": "80c357959659b632c6f06f4c6ebaa59e3d980bee",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex a9961eb98d34..87ca46143866 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -737,6 +737,15 @@ ScoredMap FromObject(const CompactObj& co, double weight) {\n   return res;\n }\n \n+ScoredMap ScoreMapFromSet(const PrimeValue& pv, double weight) {\n+  ScoredMap result;\n+  container_utils::IterateSet(pv, [&result, weight](container_utils::ContainerEntry ce) {\n+    result.emplace(ce.ToString(), weight);\n+    return true;\n+  });\n+  return result;\n+}\n+\n double Aggregate(double v1, double v2, AggType atype) {\n   switch (atype) {\n     case AggType::SUM:\n@@ -797,12 +806,18 @@ using KeyIterWeightVec = vector<pair<DbSlice::ConstIterator, double>>;\n \n ScoredMap UnionShardKeysWithScore(const KeyIterWeightVec& key_iter_weight_vec, AggType agg_type) {\n   ScoredMap result;\n-  for (const auto& key_iter_weight : key_iter_weight_vec) {\n-    if (key_iter_weight.first.is_done()) {\n+  for (const auto& [it, weight] : key_iter_weight_vec) {\n+    if (it.is_done()) {\n       continue;\n     }\n \n-    ScoredMap sm = FromObject(key_iter_weight.first->second, key_iter_weight.second);\n+    ScoredMap sm;\n+    if (it->second.ObjType() == OBJ_ZSET)\n+      sm = FromObject(it->second, weight);\n+    else {\n+      DCHECK_EQ(it->second.ObjType(), OBJ_SET);\n+      sm = ScoreMapFromSet(it->second, weight);\n+    }\n     if (result.empty()) {\n       result.swap(sm);\n     } else {\n@@ -812,23 +827,22 @@ ScoredMap UnionShardKeysWithScore(const KeyIterWeightVec& key_iter_weight_vec, A\n   return result;\n }\n \n-double GetKeyWeight(Transaction* t, ShardId shard_id, const vector<double>& weights,\n-                    unsigned key_index, unsigned cmdargs_keys_offset) {\n+double GetKeyWeight(const vector<double>& weights, unsigned windex) {\n   if (weights.empty()) {\n     return 1;\n   }\n \n-  unsigned windex = key_index - cmdargs_keys_offset;\n   DCHECK_LT(windex, weights.size());\n   return weights[windex];\n }\n \n-OpResult<ScoredMap> OpUnion(EngineShard* shard, Transaction* t, string_view dest, AggType agg_type,\n-                            const vector<double>& weights, bool store) {\n-  ShardArgs keys = t->GetShardArgs(shard->shard_id());\n+OpResult<KeyIterWeightVec> PrepareWeightedSets(const Transaction& trans, bool store,\n+                                               string_view dest, const vector<double>& weights,\n+                                               EngineShard* shard) {\n+  ShardArgs keys = trans.GetShardArgs(shard->shard_id());\n   DCHECK(!keys.Empty());\n \n-  unsigned cmdargs_keys_offset = 1;  // after {numkeys} for ZUNION\n+  unsigned cmdargs_keys_offset = 1;  // after {numkeys} for ZUNION/ZINTER\n   unsigned removed_keys = 0;\n \n   ShardArgs::Iterator start = keys.begin(), end = keys.end();\n@@ -848,92 +862,66 @@ OpResult<ScoredMap> OpUnion(EngineShard* shard, Transaction* t, string_view dest\n     }\n   }\n \n-  auto& db_slice = t->GetDbSlice(shard->shard_id());\n+  auto& db_slice = trans.GetDbSlice(shard->shard_id());\n   KeyIterWeightVec key_weight_vec(keys.Size() - removed_keys);\n   unsigned index = 0;\n+  DCHECK_GE(start.index(), cmdargs_keys_offset);\n+\n   for (; start != end; ++start) {\n-    auto it_res = db_slice.FindReadOnly(t->GetDbContext(), *start, OBJ_ZSET);\n-    if (it_res == OpStatus::WRONG_TYPE)  // TODO: support SET type with default score 1.\n-      return it_res.status();\n-    if (!it_res) {\n+    auto it_res = db_slice.FindReadOnly(trans.GetDbContext(), *start);\n+\n+    if (!IsValid(it_res.it)) {\n       ++index;\n       continue;\n     }\n-    key_weight_vec[index] = {\n-        *it_res, GetKeyWeight(t, shard->shard_id(), weights, start.index(), cmdargs_keys_offset)};\n+\n+    auto obj_type = it_res.it->second.ObjType();\n+    if (obj_type != OBJ_ZSET && obj_type != OBJ_SET)\n+      return OpStatus::WRONG_TYPE;\n+\n+    key_weight_vec[index] = {it_res.it, GetKeyWeight(weights, start.index() - cmdargs_keys_offset)};\n     ++index;\n   }\n \n-  return UnionShardKeysWithScore(key_weight_vec, agg_type);\n+  return key_weight_vec;\n }\n \n-ScoredMap ZSetFromSet(const PrimeValue& pv, double weight) {\n-  ScoredMap result;\n-  container_utils::IterateSet(pv, [&result, weight](container_utils::ContainerEntry ce) {\n-    result.emplace(ce.ToString(), weight);\n-    return true;\n-  });\n-  return result;\n-}\n-\n-OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest, AggType agg_type,\n+OpResult<ScoredMap> OpUnion(EngineShard* shard, Transaction* t, string_view dest, AggType agg_type,\n                             const vector<double>& weights, bool store) {\n-  ShardArgs keys = t->GetShardArgs(shard->shard_id());\n-  DCHECK(!keys.Empty());\n+  OpResult<KeyIterWeightVec> key_vec_res = PrepareWeightedSets(*t, store, dest, weights, shard);\n+  if (!key_vec_res)\n+    return key_vec_res.status();\n \n-  unsigned removed_keys = 0;\n-  unsigned cmdargs_keys_offset = 1;\n-  ShardArgs::Iterator start = keys.begin(), end = keys.end();\n-\n-  if (store) {\n-    // first global index is 2 after {destkey, numkeys}.\n-    ++cmdargs_keys_offset;\n-\n-    if (*start == dest) {\n-      ++start;\n-      ++removed_keys;\n-\n-      // In case ONLY the destination key is hosted in this shard no work on this shard should be\n-      // done in this step\n-      if (start == end) {\n-        return OpStatus::SKIPPED;\n-      }\n-    }\n-  }\n-\n-  auto& db_slice = t->GetDbSlice(shard->shard_id());\n-  vector<pair<DbSlice::ItAndUpdater, double>> it_arr(keys.Size() - removed_keys);\n+  // Only dest is hosted on this shard.\n+  if (key_vec_res->empty())\n+    return OpStatus::OK;\n \n-  unsigned index = 0;\n-  for (; start != end; ++start) {\n-    auto it_res = db_slice.FindMutable(t->GetDbContext(), *start);\n-    if (!IsValid(it_res.it)) {\n-      ++index;\n-      continue;  // we exit in the next loop\n-    }\n+  return UnionShardKeysWithScore(*key_vec_res, agg_type);\n+}\n \n-    // sets are supported for ZINTER* commands:\n-    auto obj_type = it_res.it->second.ObjType();\n-    if (obj_type != OBJ_ZSET && obj_type != OBJ_SET)\n-      return OpStatus::WRONG_TYPE;\n+OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest, AggType agg_type,\n+                            const vector<double>& weights, bool store) {\n+  OpResult<KeyIterWeightVec> key_vec_res = PrepareWeightedSets(*t, store, dest, weights, shard);\n+  if (!key_vec_res)\n+    return key_vec_res.status();\n \n-    it_arr[index] = {std::move(it_res), GetKeyWeight(t, shard->shard_id(), weights,\n-                                                     index + removed_keys, cmdargs_keys_offset)};\n-    ++index;\n-  }\n+  // Only dest is hosted on this shard.\n+  if (key_vec_res->empty())\n+    return OpStatus::SKIPPED;\n \n   ScoredMap result;\n-  for (auto it = it_arr.begin(); it != it_arr.end(); ++it) {\n-    if (it->first.it.is_done()) {\n+  for (const auto& [it, weight] : *key_vec_res) {\n+    if (it.is_done()) {\n       return ScoredMap{};\n     }\n \n     ScoredMap sm;\n-    if (it->first.it->second.ObjType() == OBJ_ZSET)\n-      sm = FromObject(it->first.it->second, it->second);\n-    else\n-      sm = ZSetFromSet(it->first.it->second, it->second);\n-\n+    if (it->second.ObjType() == OBJ_ZSET)\n+      sm = FromObject(it->second, weight);\n+    else {\n+      DCHECK_EQ(it->second.ObjType(), OBJ_SET);\n+      sm = ScoreMapFromSet(it->second, weight);\n+    }\n     if (result.empty())\n       result.swap(sm);\n     else\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 5deae35eb7a0..a32371014da4 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -536,6 +536,11 @@ TEST_F(ZSetFamilyTest, ZUnion) {\n   resp = Run({\"zunion\", \"3\", \"z1\", \"z2\", \"z3\", \"weights\", \"1\", \"1\", \"2\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"d\", \"b\", \"c\"));\n \n+  // Cover union of sets and zsets\n+  EXPECT_EQ(2, CheckedInt({\"sadd\", \"s2\", \"b\", \"c\"}));\n+  resp = Run({\"zunion\", \"2\", \"z1\", \"s2\", \"weights\", \"1\", \"2\", \"withscores\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1\", \"c\", \"2\", \"b\", \"5\"));\n+\n   resp = Run({\"zunion\", \"3\", \"z1\", \"z2\", \"z3\", \"weights\", \"1\", \"1\", \"2\", \"withscores\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1\", \"d\", \"2\", \"b\", \"5\", \"c\", \"5\"));\n \n@@ -642,6 +647,11 @@ TEST_F(ZSetFamilyTest, ZInterStore) {\n   EXPECT_EQ(1, CheckedInt({\"zinterstore\", \"b\", \"2\", \"z1\", \"s2\"}));\n   resp = Run({\"zrange\", \"b\", \"0\", \"-1\", \"withscores\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"b\", \"3\"));\n+\n+  Run({\"ZADD\", \"foo\", \"10\", \"a\"});\n+  EXPECT_EQ(1, CheckedInt({\"ZINTERSTORE\", \"bar\", \"1\", \"foo\", \"weights\", \"2\"}));\n+  resp = Run({\"zrange\", \"bar\", \"0\", \"-1\", \"withscores\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"20\"));\n }\n \n TEST_F(ZSetFamilyTest, ZInter) {\n",
  "problem_statement": "ZINTERSTORE with weights crashes the server\n```\r\n\"ZADD\" foo \"0.0\" \"a\"\r\nZINTERSTORE bar 1 foo  \"weights\" 1 \r\n```\n",
  "hints_text": "",
  "created_at": "2024-08-24T05:49:06Z",
  "modified_files": [
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}