{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1197,
  "instance_id": "dragonflydb__dragonfly-1197",
  "issue_numbers": [
    "832",
    "1188"
  ],
  "base_commit": "eec09a13c75649519f23bc0a2bc77fdcd5edbb6c",
  "patch": "diff --git a/.vscode/launch.json b/.vscode/launch.json\nnew file mode 100644\nindex 000000000000..b2e4a716009f\n--- /dev/null\n+++ b/.vscode/launch.json\n@@ -0,0 +1,31 @@\n+{\n+  \"version\": \"0.2.0\",\n+  \"configurations\": [\n+    {\n+      \"name\": \"Dragonfly GDB\",\n+      \"type\": \"cppdbg\",\n+      \"request\": \"launch\",\n+      \"program\": \"${workspaceFolder}/build-dbg/dragonfly\",\n+      \"args\": [\n+        \"--alsologtostderr\"\n+      ],\n+      \"stopAtEntry\": false,\n+      \"cwd\": \"${workspaceFolder}/build-dbg\",\n+      \"environment\": [],\n+      \"externalConsole\": false,\n+      \"MIMode\": \"gdb\",\n+      \"setupCommands\": [\n+        {\n+          \"description\": \"Enable pretty-printing for gdb\",\n+          \"text\": \"-enable-pretty-printing\",\n+          \"ignoreFailures\": true\n+        },\n+        {\n+          \"description\": \"Set Disassembly Flavor to Intel\",\n+          \"text\": \"-gdb-set disassembly-flavor intel\",\n+          \"ignoreFailures\": true\n+        }\n+      ]\n+    }\n+  ]\n+}\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 85fe7fa1dd63..2e3b48c9b99d 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -620,7 +620,7 @@ void SendAtLeastOneKeyError(ConnectionContext* cntx) {\n   (*cntx)->SendError(absl::StrCat(\"at least 1 input key is needed for \", name));\n }\n \n-enum class AggType : uint8_t { SUM, MIN, MAX };\n+enum class AggType : uint8_t { SUM, MIN, MAX, NOOP };\n using ScoredMap = absl::flat_hash_map<std::string, double>;\n \n ScoredMap FromObject(const CompactObj& co, double weight) {\n@@ -650,6 +650,8 @@ double Aggregate(double v1, double v2, AggType atype) {\n       return max(v1, v2);\n     case AggType::MIN:\n       return min(v1, v2);\n+    case AggType::NOOP:\n+      return 0;\n   }\n   return 0;\n }\n@@ -766,6 +768,15 @@ OpResult<ScoredMap> OpUnion(EngineShard* shard, Transaction* t, string_view dest\n   return UnionShardKeysWithScore(key_weight_vec, agg_type);\n }\n \n+ScoredMap ZSetFromSet(const PrimeValue& pv, double weight) {\n+  ScoredMap result;\n+  container_utils::IterateSet(pv, [&result, weight](container_utils::ContainerEntry ce) {\n+    result.emplace(ce.ToString(), weight);\n+    return true;\n+  });\n+  return result;\n+}\n+\n OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest, AggType agg_type,\n                             const vector<double>& weights, bool store) {\n   ArgSlice keys = t->GetShardArgs(shard->shard_id());\n@@ -787,7 +798,7 @@ OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest\n     // In case ONLY the destination key is hosted in this shard no work on this shard should be\n     // done in this step\n     if (keys.empty()) {\n-      return OpStatus::OK;\n+      return OpStatus::SKIPPED;\n     }\n   }\n \n@@ -797,15 +808,17 @@ OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest\n     return OpStatus::SKIPPED;  // return noop\n \n   for (unsigned j = 0; j < keys.size(); ++j) {\n-    auto it_res = db_slice.Find(t->GetDbContext(), keys[j], OBJ_ZSET);\n-    if (it_res == OpStatus::WRONG_TYPE)  // TODO: support sets with default score 1.\n-      return it_res.status();\n-\n-    if (!it_res)\n+    auto it_res = db_slice.FindExt(t->GetDbContext(), keys[j]).first;\n+    if (!IsValid(it_res))\n       continue;  // we exit in the next loop\n \n-    it_arr[j] = {*it_res, GetKeyWeight(t, shard->shard_id(), weights, j + removed_keys,\n-                                       cmdargs_keys_offset)};\n+    // sets are supported for ZINTER* commands:\n+    auto obj_type = it_res->second.ObjType();\n+    if (obj_type != OBJ_ZSET && obj_type != OBJ_SET)\n+      return OpStatus::WRONG_TYPE;\n+\n+    it_arr[j] = {\n+        it_res, GetKeyWeight(t, shard->shard_id(), weights, j + removed_keys, cmdargs_keys_offset)};\n   }\n \n   ScoredMap result;\n@@ -814,7 +827,12 @@ OpResult<ScoredMap> OpInter(EngineShard* shard, Transaction* t, string_view dest\n       return ScoredMap{};\n     }\n \n-    ScoredMap sm = FromObject(it->first->second, it->second);\n+    ScoredMap sm;\n+    if (it->first->second.ObjType() == OBJ_ZSET)\n+      sm = FromObject(it->first->second, it->second);\n+    else\n+      sm = ZSetFromSet(it->first->second, it->second);\n+\n     if (result.empty())\n       result.swap(sm);\n     else\n@@ -1340,6 +1358,54 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(smvec.size());\n }\n \n+void ZSetFamily::ZInterCard(CmdArgList args, ConnectionContext* cntx) {\n+  unsigned num_keys;\n+  if (!absl::SimpleAtoi(ArgS(args, 0), &num_keys)) {\n+    return (*cntx)->SendError(OpStatus::SYNTAX_ERR);\n+  }\n+\n+  uint64_t limit = 0;\n+  if (args.size() == (1 + num_keys + 2) && ArgS(args, 1 + num_keys) == \"LIMIT\") {\n+    if (!absl::SimpleAtoi(ArgS(args, 1 + num_keys + 1), &limit)) {\n+      return (*cntx)->SendError(\"limit value is not a positive integer\", kSyntaxErrType);\n+    }\n+  } else if (args.size() != 1 + num_keys) {\n+    return (*cntx)->SendError(kSyntaxErr);\n+  }\n+\n+  vector<OpResult<ScoredMap>> maps(shard_set->size(), OpStatus::SKIPPED);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    maps[shard->shard_id()] = OpInter(shard, t, \"\", AggType::NOOP, {}, false);\n+    return OpStatus::OK;\n+  };\n+\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n+\n+  ScoredMap result;\n+  for (auto& op_res : maps) {\n+    if (op_res.status() == OpStatus::SKIPPED)\n+      continue;\n+\n+    if (!op_res)\n+      return (*cntx)->SendError(op_res.status());\n+\n+    if (result.empty()) {\n+      result.swap(op_res.value());\n+    } else {\n+      InterScoredMap(&result, &op_res.value(), AggType::NOOP);\n+    }\n+\n+    if (result.empty())\n+      break;\n+  }\n+\n+  if (0 < limit && limit < result.size()) {\n+    return (*cntx)->SendLong(limit);\n+  }\n+  (*cntx)->SendLong(result.size());\n+}\n+\n void ZSetFamily::ZPopMax(CmdArgList args, ConnectionContext* cntx) {\n   ZPopMinMax(std::move(args), true, cntx);\n }\n@@ -2134,6 +2200,8 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n             << CI{\"ZCOUNT\", CO::FAST | CO::READONLY, 4, 1, 1, 1}.HFUNC(ZCount)\n             << CI{\"ZINCRBY\", CO::FAST | CO::WRITE | CO::DENYOOM, 4, 1, 1, 1}.HFUNC(ZIncrBy)\n             << CI{\"ZINTERSTORE\", kStoreMask, -4, 3, 3, 1}.HFUNC(ZInterStore)\n+            << CI{\"ZINTERCARD\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2, 1}\n+                   .HFUNC(ZInterCard)\n             << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, 1}.HFUNC(ZLexCount)\n             << CI{\"ZPOPMAX\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMax)\n             << CI{\"ZPOPMIN\", CO::FAST | CO::WRITE, -2, 1, 1, 1}.HFUNC(ZPopMin)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 765262498b94..48e497957f54 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -60,6 +60,7 @@ class ZSetFamily {\n   static void ZCount(CmdArgList args, ConnectionContext* cntx);\n   static void ZIncrBy(CmdArgList args, ConnectionContext* cntx);\n   static void ZInterStore(CmdArgList args, ConnectionContext* cntx);\n+  static void ZInterCard(CmdArgList args, ConnectionContext* cntx);\n   static void ZLexCount(CmdArgList args, ConnectionContext* cntx);\n   static void ZPopMax(CmdArgList args, ConnectionContext* cntx);\n   static void ZPopMin(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex a17ca5be9bc8..e205bb0a5ff1 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -421,6 +421,32 @@ TEST_F(ZSetFamilyTest, ZInterStore) {\n   EXPECT_EQ(1, CheckedInt({\"zinterstore\", \"a\", \"2\", \"z1\", \"z2\"}));\n   resp = Run({\"zrange\", \"a\", \"0\", \"-1\", \"withscores\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"b\", \"4\"));\n+\n+  // support for sets\n+  EXPECT_EQ(2, CheckedInt({\"sadd\", \"s2\", \"b\", \"c\"}));\n+  EXPECT_EQ(1, CheckedInt({\"zinterstore\", \"b\", \"2\", \"z1\", \"s2\"}));\n+  resp = Run({\"zrange\", \"b\", \"0\", \"-1\", \"withscores\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"b\", \"3\"));\n+}\n+\n+TEST_F(ZSetFamilyTest, ZInterCard) {\n+  EXPECT_EQ(3, CheckedInt({\"zadd\", \"z1\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\"}));\n+  EXPECT_EQ(3, CheckedInt({\"zadd\", \"z2\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\"}));\n+  RespExpr resp;\n+\n+  EXPECT_EQ(2, CheckedInt({\"zintercard\", \"2\", \"z1\", \"z2\"}));\n+  EXPECT_EQ(1, CheckedInt({\"zintercard\", \"2\", \"z1\", \"z2\", \"LIMIT\", \"1\"}));\n+\n+  resp = Run({\"zintercard\", \"2\", \"z1\", \"z2\", \"LIM\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+  resp = Run({\"zintercard\", \"2\", \"z1\", \"z2\", \"LIMIT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+  resp = Run({\"zintercard\", \"2\", \"z1\", \"z2\", \"LIMIT\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"limit value is not a positive integer\"));\n+\n+  // support for sets\n+  EXPECT_EQ(3, CheckedInt({\"sadd\", \"s2\", \"b\", \"c\", \"d\"}));\n+  EXPECT_EQ(2, CheckedInt({\"zintercard\", \"2\", \"z1\", \"s2\"}));\n }\n \n TEST_F(ZSetFamilyTest, ZAddBug148) {\n",
  "problem_statement": "ZINTERSTORE doesn't work as expected\n(Please also review the command reference documentation when fixing)\r\n\r\n**Describe the bug**\r\nZINTERSTORE doesn't work as expected\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Insert records using `command`\r\n2. Query records using `command`\r\n3. Scroll down to '....'\r\n4. See error\r\n\r\n**Expected behavior**\r\ndragonfly> ZADD zset1 1 \"one\"\r\n(integer) 1\r\ndragonfly> ZADD zset1 1 \"one\"\r\n(integer) 1\r\ndragonfly> ZADD zset2 1 \"one\"\r\n(integer) 1\r\ndragonfly> ZADD zset2 2 \"two\"\r\n(integer) 1\r\ndragonfly> ZADD zset2 3 \"three\"\r\n(integer) 1\r\n\r\ndragonfly> ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3\r\nEXPECTED: (integer) 2\r\nGOT: (integer) 0\r\ndragonfly> ZRANGE out 0 -1 WITHSCORES\r\nEXPECTED:\r\n1) \"one\"\r\n2) \"5\"\r\n3) \"two\"\r\n4) \"10\"\r\nGOT: (empty array)\r\n\nimplement ZINTERCARD \nPlease see https://redis.io/commands/zintercard/\r\n\r\nThere is undocumented feature for ZINTERCARD - it can intersect a regular set (SADD) with sorted set (ZADD).\r\n\r\n1. It should be able to intersect multiple zsets and provide the final cardinality number.\r\n2. It should be able to intersect sets and zsets, in fact it can intersect sets without zsets.\r\n\r\n\n",
  "hints_text": "\nrelated to https://github.com/dragonflydb/dragonfly/issues/1099\nHi!\r\nIs there a similar undocumented feature for regular sets in ZINTER? (e.g. with a default score of 1)\r\nIf so, should ZINTER\u2019s behavior change as well to allow this?\nYes, I checked it manually:\r\n```\r\n127.0.0.1:6379> sadd s1 a b c\r\n(integer) 3\r\n127.0.0.1:6379> zadd z1 1 a 2 b\r\n(integer) 2\r\n\r\n127.0.0.1:6379> zinter 1 z1\r\n1) \"a\"\r\n2) \"b\"\r\n127.0.0.1:6379> zinter 2 z1 s1\r\n1) \"a\"\r\n2) \"b\"\r\n\r\n127.0.0.1:6379> zinter 1 s1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n```\r\n\nIs this smth i can try to implement or might be too tough for now? \nIt's being in development right now. I will look for something soon :)\nOk, thanks a lot! ",
  "created_at": "2023-05-09T20:01:46Z",
  "modified_files": [
    "b/.vscode/launch.json",
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}