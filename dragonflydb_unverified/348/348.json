{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 348,
  "instance_id": "dragonflydb__dragonfly-348",
  "issue_numbers": [
    "335"
  ],
  "base_commit": "cf779c08a4ccb4da56bebc60cfddecee52590337",
  "patch": "diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex 8118611c07ef..0862129bcb01 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -492,21 +492,35 @@ uint32_t DenseSet::Scan(uint32_t cursor, const ItemCb& cb) const {\n \n   uint32_t entries_idx = cursor >> (32 - capacity_log_);\n \n+  auto& entries = const_cast<DenseSet*>(this)->entries_;\n+\n   // skip empty entries\n-  while (entries_idx < entries_.size() && entries_[entries_idx].IsEmpty()) {\n-    ++entries_idx;\n-  }\n+  do {\n+    while (entries_idx < entries_.size() && entries_[entries_idx].IsEmpty()) {\n+      ++entries_idx;\n+    }\n \n-  if (entries_idx == entries_.size()) {\n-    return 0;\n-  }\n+    if (entries_idx == entries_.size()) {\n+      return 0;\n+    }\n \n-  const DensePtr* curr = &entries_[entries_idx];\n+    ExpireIfNeeded(nullptr, &entries[entries_idx]);\n+  } while (entries_[entries_idx].IsEmpty());\n+\n+  DensePtr* curr = &entries[entries_idx];\n \n   // when scanning add all entries in a given chain\n-  while (curr != nullptr && !curr->IsEmpty()) {\n+  while (true) {\n     cb(curr->GetObject());\n-    curr = curr->Next();\n+    if (!curr->IsLink())\n+      break;\n+\n+    DensePtr* mcurr = const_cast<DensePtr*>(curr);\n+\n+    if (ExpireIfNeeded(mcurr, &mcurr->AsLink()->next) && !mcurr->IsLink()) {\n+      break;\n+    }\n+    curr = &curr->AsLink()->next;\n   }\n \n   // move to the next index for the next scan and check if we are done\n@@ -515,6 +529,14 @@ uint32_t DenseSet::Scan(uint32_t cursor, const ItemCb& cb) const {\n     return 0;\n   }\n \n+  // In case of displacement, we want to fully cover the bucket we traversed, therefore\n+  // we check if the bucket on the right belongs to the home bucket.\n+  ExpireIfNeeded(nullptr, &entries[entries_idx]);\n+\n+  if (entries[entries_idx].GetDisplacedDirection() == 1) { // right of the home bucket\n+    cb(entries[entries_idx].GetObject());\n+  }\n+\n   return entries_idx << (32 - capacity_log_);\n }\n \ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex 903ecd4b6a6d..a643319a5c0e 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -17,12 +17,11 @@ extern \"C\" {\n #include \"core/string_set.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n+#include \"server/container_utils.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/error.h\"\n #include \"server/transaction.h\"\n \n-#include \"server/container_utils.h\"\n-\n ABSL_DECLARE_FLAG(bool, use_set2);\n \n namespace dfly {\n@@ -30,7 +29,7 @@ namespace dfly {\n using namespace std;\n using absl::GetFlag;\n \n-using ResultStringVec = vector<OpResult<vector<string>>>;\n+using ResultStringVec = vector<OpResult<StringVec>>;\n using ResultSetView = OpResult<absl::flat_hash_set<std::string_view>>;\n using SvArray = vector<std::string_view>;\n \n@@ -38,6 +37,13 @@ namespace {\n \n constexpr uint32_t kMaxIntSetEntries = 256;\n \n+// I use relative time from Oct 1, 2022\n+constexpr uint64_t kNowBase = 1664582400ULL;\n+\n+uint32_t TimeNowSecRel(uint64_t now_ms) {\n+  return (now_ms / 1000) - kNowBase;\n+}\n+\n intset* IntsetAddSafe(string_view val, intset* is, bool* success, bool* added) {\n   long long llval;\n   *added = false;\n@@ -80,14 +86,15 @@ bool dictContains(const dict* d, string_view key) {\n   return false;\n }\n \n-pair<unsigned, bool> RemoveStrSet(ArgSlice vals, CompactObj* set) {\n+pair<unsigned, bool> RemoveStrSet(uint32_t now_sec, ArgSlice vals, CompactObj* set) {\n   unsigned removed = 0;\n   bool isempty = false;\n   auto* shard = EngineShard::tlocal();\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(set->Encoding(), kEncodingStrMap2);\n+  if (set->Encoding() == kEncodingStrMap2) {\n     StringSet* ss = ((StringSet*)set->RObjPtr());\n+    ss->set_time(now_sec);\n+\n     for (auto member : vals) {\n       removed += ss->Erase(member);\n     }\n@@ -108,17 +115,17 @@ pair<unsigned, bool> RemoveStrSet(ArgSlice vals, CompactObj* set) {\n   return make_pair(removed, isempty);\n }\n \n-unsigned AddStrSet(ArgSlice vals, CompactObj* dest) {\n+unsigned AddStrSet(const DbContext& db_context, ArgSlice vals, uint32_t ttl_sec, CompactObj* dest) {\n   unsigned res = 0;\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(dest->Encoding(), kEncodingStrMap2);\n+  if (dest->Encoding() == kEncodingStrMap2) {\n     StringSet* ss = (StringSet*)dest->RObjPtr();\n+    uint32_t time_now = TimeNowSecRel(db_context.time_now_ms);\n+\n+    ss->set_time(time_now);\n+\n     for (auto member : vals) {\n-      // the temporary variable in the engine shard is not used here since the\n-      // SDS pointer allocated is stored in the set and will outlive this function\n-      // call\n-      res += ss->Add(member);\n+      res += ss->Add(member, ttl_sec);\n     }\n   } else {\n     DCHECK_EQ(dest->Encoding(), kEncodingStrMap);\n@@ -134,6 +141,7 @@ unsigned AddStrSet(ArgSlice vals, CompactObj* dest) {\n       }\n     }\n   }\n+\n   return res;\n }\n \n@@ -148,7 +156,7 @@ void InitStrSet(CompactObj* set) {\n }\n \n // returns (removed, isempty)\n-pair<unsigned, bool> RemoveSet(ArgSlice vals, CompactObj* set) {\n+pair<unsigned, bool> RemoveSet(const DbContext& db_context, ArgSlice vals, CompactObj* set) {\n   bool isempty = false;\n   unsigned removed = 0;\n \n@@ -168,7 +176,7 @@ pair<unsigned, bool> RemoveSet(ArgSlice vals, CompactObj* set) {\n     isempty = (intsetLen(is) == 0);\n     set->SetRObjPtr(is);\n   } else {\n-    return RemoveStrSet(vals, set);\n+    return RemoveStrSet(TimeNowSecRel(db_context.time_now_ms), vals, set);\n   }\n   return make_pair(removed, isempty);\n }\n@@ -198,12 +206,14 @@ void ScanCallback(void* privdata, const dictEntry* de) {\n   sv->push_back(string(key, sdslen(key)));\n }\n \n-uint64_t ScanStrSet(const CompactObj& co, uint64_t curs, unsigned count, StringVec* res) {\n+uint64_t ScanStrSet(const DbContext& db_context, const CompactObj& co, uint64_t curs,\n+                    unsigned count, StringVec* res) {\n   long maxiterations = count * 10;\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(co.Encoding(), kEncodingStrMap2);\n+  if (co.Encoding() == kEncodingStrMap2) {\n     StringSet* set = (StringSet*)co.RObjPtr();\n+    set->set_time(TimeNowSecRel(db_context.time_now_ms));\n+\n     do {\n       curs = set->Scan(curs, [&](const sds ptr) { res->push_back(std::string(ptr, sdslen(ptr))); });\n     } while (curs && maxiterations-- && res->size() < count);\n@@ -220,37 +230,40 @@ uint64_t ScanStrSet(const CompactObj& co, uint64_t curs, unsigned count, StringV\n \n using SetType = pair<void*, unsigned>;\n \n-uint32_t SetTypeLen(const SetType& set) {\n+uint32_t SetTypeLen(const DbContext& db_context, const SetType& set) {\n   if (set.second == kEncodingIntSet) {\n     return intsetLen((const intset*)set.first);\n   }\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(set.second, kEncodingStrMap2);\n-    return ((StringSet*)set.first)->Size();\n-  } else {\n-    DCHECK_EQ(set.second, kEncodingStrMap);\n-    return dictSize((const dict*)set.first);\n+  if (set.second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)set.first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    return ss->Size();\n   }\n+\n+  DCHECK_EQ(set.second, kEncodingStrMap);\n+  return dictSize((const dict*)set.first);\n }\n \n-bool IsInSet(const SetType& st, int64_t val) {\n+bool IsInSet(const DbContext& db_context, const SetType& st, int64_t val) {\n   if (st.second == kEncodingIntSet)\n     return intsetFind((intset*)st.first, val);\n \n   char buf[32];\n   char* next = absl::numbers_internal::FastIntToBuffer(val, buf);\n   string_view str{buf, size_t(next - buf)};\n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(st.second, kEncodingStrMap2);\n-    return ((StringSet*)st.first)->Contains(str);\n-  } else {\n-    DCHECK_EQ(st.second, kEncodingStrMap);\n-    return dictContains((dict*)st.first, str);\n+\n+  if (st.second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)st.first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    return ss->Contains(str);\n   }\n+\n+  DCHECK_EQ(st.second, kEncodingStrMap);\n+  return dictContains((dict*)st.first, str);\n }\n \n-bool IsInSet(const SetType& st, string_view member) {\n+bool IsInSet(const DbContext& db_context, const SetType& st, string_view member) {\n   if (st.second == kEncodingIntSet) {\n     long long llval;\n     if (!string2ll(member.data(), member.size(), &llval))\n@@ -259,9 +272,11 @@ bool IsInSet(const SetType& st, string_view member) {\n     return intsetFind((intset*)st.first, llval);\n   }\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(st.second, kEncodingStrMap2);\n-    return ((StringSet*)st.first)->Contains(member);\n+  if (st.second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)st.first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+\n+    return ss->Contains(member);\n   } else {\n     DCHECK_EQ(st.second, kEncodingStrMap);\n     return dictContains((dict*)st.first, member);\n@@ -269,10 +284,12 @@ bool IsInSet(const SetType& st, string_view member) {\n }\n \n // Removes arg from result.\n-void DiffStrSet(const SetType& st, absl::flat_hash_set<string>* result) {\n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(st.second, kEncodingStrMap2);\n-    for (const sds ptr : *(StringSet*)st.first) {\n+void DiffStrSet(const DbContext& db_context, const SetType& st,\n+                absl::flat_hash_set<string>* result) {\n+  if (st.second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)st.first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    for (sds ptr : *ss) {\n       result->erase(string_view{ptr, sdslen(ptr)});\n     }\n   } else {\n@@ -288,15 +305,15 @@ void DiffStrSet(const SetType& st, absl::flat_hash_set<string>* result) {\n   }\n }\n \n-void InterStrSet(const vector<SetType>& vec, StringVec* result) {\n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(vec.front().second, kEncodingStrMap2);\n-    StringSet* set = (StringSet*)vec.front().first;\n-    for (const sds ptr : *set) {\n+void InterStrSet(const DbContext& db_context, const vector<SetType>& vec, StringVec* result) {\n+  if (vec.front().second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)vec.front().first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    for (const sds ptr : *ss) {\n       std::string_view str{ptr, sdslen(ptr)};\n       size_t j = 1;\n       for (j = 1; j < vec.size(); ++j) {\n-        if (vec[j].first != set && !IsInSet(vec[j], str)) {\n+        if (vec[j].first != ss && !IsInSet(db_context, vec[j], str)) {\n           break;\n         }\n       }\n@@ -316,7 +333,7 @@ void InterStrSet(const vector<SetType>& vec, StringVec* result) {\n       string_view member{key, sdslen(key)};\n \n       for (j = 1; j < vec.size(); j++) {\n-        if (vec[j].first != ds && !IsInSet(vec[j], member))\n+        if (vec[j].first != ds && !IsInSet(db_context, vec[j], member))\n           break;\n       }\n \n@@ -329,14 +346,16 @@ void InterStrSet(const vector<SetType>& vec, StringVec* result) {\n   }\n }\n \n-StringVec PopStrSet(unsigned count, const SetType& st) {\n+StringVec PopStrSet(const DbContext& db_context, unsigned count, const SetType& st) {\n   StringVec result;\n \n-  if (GetFlag(FLAGS_use_set2)) {\n-    DCHECK_EQ(st.second, kEncodingStrMap2);\n-    StringSet* set = (StringSet*)st.first;\n-    for (unsigned i = 0; i < count && !set->Empty(); ++i) {\n-      result.push_back(set->Pop().value());\n+  if (st.second == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)st.first;\n+    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+\n+    // TODO: this loop is inefficient because Pop searches again and again an occupied bucket.\n+    for (unsigned i = 0; i < count && !ss->Empty(); ++i) {\n+      result.push_back(ss->Pop().value());\n     }\n   } else {\n     DCHECK_EQ(st.second, kEncodingStrMap);\n@@ -534,6 +553,7 @@ OpResult<uint32_t> OpAdd(const OpArgs& op_args, std::string_view key, ArgSlice v\n         if (!SetFamily::ConvertToStrSet(is, intsetLen(is), &tmp)) {\n           return OpStatus::OUT_OF_MEMORY;\n         }\n+\n         // frees 'is' on a way.\n         if (GetFlag(FLAGS_use_set2)) {\n           co.InitRobj(OBJ_SET, kEncodingStrMap2, tmp.ptr);\n@@ -551,15 +571,60 @@ OpResult<uint32_t> OpAdd(const OpArgs& op_args, std::string_view key, ArgSlice v\n   }\n \n   if (co.Encoding() != kEncodingIntSet) {\n-    res = AddStrSet(std::move(vals), &co);\n+    res = AddStrSet(op_args.db_cntx, std::move(vals), UINT32_MAX, &co);\n+  }\n+\n+  db_slice.PostUpdate(op_args.db_cntx.db_index, it, key, !new_key);\n+\n+  return res;\n+}\n+\n+OpResult<uint32_t> OpAddEx(const OpArgs& op_args, string_view key, uint32_t ttl_sec,\n+                           ArgSlice vals) {\n+  auto* es = op_args.shard;\n+  auto& db_slice = es->db_slice();\n+\n+  PrimeIterator it;\n+  bool new_key = false;\n+\n+  try {\n+    tie(it, new_key) = db_slice.AddOrFind(op_args.db_cntx, key);\n+  } catch (bad_alloc& e) {\n+    return OpStatus::OUT_OF_MEMORY;\n+  }\n+\n+  CompactObj& co = it->second;\n+\n+  if (new_key) {\n+    CHECK(absl::GetFlag(FLAGS_use_set2));\n+    InitStrSet(&co);\n+  } else {\n+    // for non-overwrite case it must be set.\n+    if (co.ObjType() != OBJ_SET)\n+      return OpStatus::WRONG_TYPE;\n+\n+    // Update stats and trigger any handle the old value if needed.\n+    db_slice.PreUpdate(op_args.db_cntx.db_index, it);\n+    if (co.Encoding() == kEncodingIntSet) {\n+      intset* is = (intset*)co.RObjPtr();\n+      robj tmp;\n+      if (!SetFamily::ConvertToStrSet(is, intsetLen(is), &tmp)) {\n+        return OpStatus::OUT_OF_MEMORY;\n+      }\n+      co.InitRobj(OBJ_SET, kEncodingStrMap2, tmp.ptr);\n+    }\n+\n+    CHECK(co.Encoding() == kEncodingStrMap2);\n   }\n \n+  uint32_t res = AddStrSet(op_args.db_cntx, std::move(vals), ttl_sec, &co);\n+\n   db_slice.PostUpdate(op_args.db_cntx.db_index, it, key, !new_key);\n \n   return res;\n }\n \n-OpResult<uint32_t> OpRem(const OpArgs& op_args, std::string_view key, const ArgSlice& vals) {\n+OpResult<uint32_t> OpRem(const OpArgs& op_args, string_view key, const ArgSlice& vals) {\n   auto* es = op_args.shard;\n   auto& db_slice = es->db_slice();\n   OpResult<PrimeIterator> find_res = db_slice.Find(op_args.db_cntx, key, OBJ_SET);\n@@ -570,7 +635,7 @@ OpResult<uint32_t> OpRem(const OpArgs& op_args, std::string_view key, const ArgS\n   db_slice.PreUpdate(op_args.db_cntx.db_index, *find_res);\n \n   CompactObj& co = find_res.value()->second;\n-  auto [removed, isempty] = RemoveSet(vals, &co);\n+  auto [removed, isempty] = RemoveSet(op_args.db_cntx, vals, &co);\n \n   db_slice.PostUpdate(op_args.db_cntx.db_index, *find_res, key);\n \n@@ -586,7 +651,7 @@ OpResult<uint32_t> OpRem(const OpArgs& op_args, std::string_view key, const ArgS\n // and reports the result.\n class Mover {\n  public:\n-  Mover(std::string_view src, std::string_view dest, std::string_view member)\n+  Mover(string_view src, string_view dest, string_view member)\n       : src_(src), dest_(dest), member_(member) {\n   }\n \n@@ -597,7 +662,7 @@ class Mover {\n   OpStatus OpFind(Transaction* t, EngineShard* es);\n   OpStatus OpMutate(Transaction* t, EngineShard* es);\n \n-  std::string_view src_, dest_, member_;\n+  string_view src_, dest_, member_;\n   OpResult<bool> found_[2];\n };\n \n@@ -614,7 +679,7 @@ OpStatus Mover::OpFind(Transaction* t, EngineShard* es) {\n       DCHECK(!res->is_done());\n       const CompactObj& val = res.value()->second;\n       SetType st{val.RObjPtr(), val.Encoding()};\n-      found_[0] = IsInSet(st, member_);\n+      found_[0] = IsInSet(t->db_context(), st, member_);\n     } else {\n       found_[index] = res.status();\n     }\n@@ -674,10 +739,16 @@ OpResult<StringVec> OpUnion(const OpArgs& op_args, ArgSlice keys) {\n   DCHECK(!keys.empty());\n   absl::flat_hash_set<string> uniques;\n \n-  for (std::string_view key : keys) {\n-    OpResult<PrimeIterator> find_res = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_SET);\n+  for (string_view key : keys) {\n+    OpResult<PrimeIterator> find_res =\n+        op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_SET);\n     if (find_res) {\n-      container_utils::IterateSet(find_res.value()->second, [&uniques](container_utils::ContainerEntry ce){\n+      PrimeValue& pv = find_res.value()->second;\n+      if (pv.Encoding() == kEncodingStrMap2) {\n+        StringSet* ss = (StringSet*)pv.RObjPtr();\n+        ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+      }\n+      container_utils::IterateSet(pv, [&uniques](container_utils::ContainerEntry ce) {\n         uniques.emplace(ce.ToString());\n         return true;\n       });\n@@ -704,7 +775,13 @@ OpResult<StringVec> OpDiff(const OpArgs& op_args, ArgSlice keys) {\n   }\n \n   absl::flat_hash_set<string> uniques;\n-  container_utils::IterateSet(find_res.value()->second, [&uniques](container_utils::ContainerEntry ce) {\n+  PrimeValue& pv = find_res.value()->second;\n+  if (pv.Encoding() == kEncodingStrMap2) {\n+    StringSet* ss = (StringSet*)pv.RObjPtr();\n+    ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+  }\n+\n+  container_utils::IterateSet(pv, [&uniques](container_utils::ContainerEntry ce) {\n     uniques.emplace(ce.ToString());\n     return true;\n   });\n@@ -732,7 +809,7 @@ OpResult<StringVec> OpDiff(const OpArgs& op_args, ArgSlice keys) {\n         uniques.erase(string_view{buf, size_t(next - buf)});\n       }\n     } else {\n-      DiffStrSet(st2, &uniques);\n+      DiffStrSet(op_args.db_cntx, st2, &uniques);\n     }\n   }\n \n@@ -753,10 +830,17 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n     if (!find_res)\n       return find_res.status();\n \n-    container_utils::IterateSet(find_res.value()->second, [&result](container_utils::ContainerEntry ce) {\n-      result.push_back(ce.ToString());\n-      return true;\n-    });\n+    PrimeValue& pv = find_res.value()->second;\n+    if (pv.Encoding() == kEncodingStrMap2) {\n+      StringSet* ss = (StringSet*)pv.RObjPtr();\n+      ss->set_time(TimeNowSecRel(t->db_context().time_now_ms));\n+    }\n+\n+    container_utils::IterateSet(find_res.value()->second,\n+                                [&result](container_utils::ContainerEntry ce) {\n+                                  result.push_back(ce.ToString());\n+                                  return true;\n+                                });\n     return result;\n   }\n \n@@ -782,8 +866,8 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n   if (status != OpStatus::OK)\n     return status;\n \n-  auto comp = [](const SetType& left, const SetType& right) {\n-    return SetTypeLen(left) < SetTypeLen(right);\n+  auto comp = [db_contx = t->db_context()](const SetType& left, const SetType& right) {\n+    return SetTypeLen(db_contx, left) < SetTypeLen(db_contx, right);\n   };\n \n   std::sort(sets.begin(), sets.end(), comp);\n@@ -797,7 +881,7 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n     while (intsetGet(is, ii++, &intele)) {\n       size_t j = 1;\n       for (j = 1; j < sets.size(); j++) {\n-        if (sets[j].first != is && !IsInSet(sets[j], intele))\n+        if (sets[j].first != is && !IsInSet(t->db_context(), sets[j], intele))\n           break;\n       }\n \n@@ -807,17 +891,94 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n       }\n     }\n   } else {\n-    InterStrSet(sets, &result);\n+    InterStrSet(t->db_context(), sets, &result);\n   }\n \n   return result;\n }\n \n-}  // namespace\n+// count - how many elements to pop.\n+OpResult<StringVec> OpPop(const OpArgs& op_args, string_view key, unsigned count) {\n+  auto& db_slice = op_args.shard->db_slice();\n+  OpResult<PrimeIterator> find_res = db_slice.Find(op_args.db_cntx, key, OBJ_SET);\n+  if (!find_res)\n+    return find_res.status();\n+\n+  StringVec result;\n+  if (count == 0)\n+    return result;\n+\n+  PrimeIterator it = find_res.value();\n+  size_t slen = it->second.Size();\n+\n+  /* CASE 1:\n+   * The number of requested elements is greater than or equal to\n+   * the number of elements inside the set: simply return the whole set. */\n+  if (count >= slen) {\n+    PrimeValue& pv = it->second;\n+    if (pv.Encoding() == kEncodingStrMap2) {\n+      StringSet* ss = (StringSet*)pv.RObjPtr();\n+      ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+    }\n+\n+    container_utils::IterateSet(it->second, [&result](container_utils::ContainerEntry ce) {\n+      result.push_back(ce.ToString());\n+      return true;\n+    });\n+\n+    /* Delete the set as it is now empty */\n+    CHECK(db_slice.Del(op_args.db_cntx.db_index, it));\n+  } else {\n+    SetType st{it->second.RObjPtr(), it->second.Encoding()};\n+    db_slice.PreUpdate(op_args.db_cntx.db_index, it);\n+    if (st.second == kEncodingIntSet) {\n+      intset* is = (intset*)st.first;\n+      int64_t val = 0;\n+\n+      // copy last count values.\n+      for (uint32_t i = slen - count; i < slen; ++i) {\n+        intsetGet(is, i, &val);\n+        result.push_back(absl::StrCat(val));\n+      }\n+\n+      is = intsetTrimTail(is, count);  // now remove last count items\n+      it->second.SetRObjPtr(is);\n+    } else {\n+      result = PopStrSet(op_args.db_cntx, count, st);\n+    }\n+    db_slice.PostUpdate(op_args.db_cntx.db_index, it, key);\n+  }\n+  return result;\n+}\n+\n+OpResult<StringVec> OpScan(const OpArgs& op_args, string_view key, uint64_t* cursor) {\n+  OpResult<PrimeIterator> find_res = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_SET);\n+\n+  if (!find_res)\n+    return find_res.status();\n+\n+  PrimeIterator it = find_res.value();\n+  StringVec res;\n+  uint32_t count = 10;\n+\n+  if (it->second.Encoding() == kEncodingIntSet) {\n+    intset* is = (intset*)it->second.RObjPtr();\n+    int64_t intele;\n+    uint32_t pos = 0;\n+    while (intsetGet(is, pos++, &intele)) {\n+      res.push_back(absl::StrCat(intele));\n+    }\n+    *cursor = 0;\n+  } else {\n+    *cursor = ScanStrSet(op_args.db_cntx, it->second, *cursor, count, &res);\n+  }\n \n-void SetFamily::SAdd(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n-  vector<std::string_view> vals(args.size() - 2);\n+  return res;\n+}\n+\n+void SAdd(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  vector<string_view> vals(args.size() - 2);\n   for (size_t i = 2; i < args.size(); ++i) {\n     vals[i - 2] = ArgS(args, i);\n   }\n@@ -835,16 +996,16 @@ void SetFamily::SAdd(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendError(result.status());\n }\n \n-void SetFamily::SIsMember(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n-  std::string_view val = ArgS(args, 2);\n+void SIsMember(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view val = ArgS(args, 2);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     OpResult<PrimeIterator> find_res = shard->db_slice().Find(t->db_context(), key, OBJ_SET);\n \n     if (find_res) {\n       SetType st{find_res.value()->second.RObjPtr(), find_res.value()->second.Encoding()};\n-      return IsInSet(st, val) ? OpStatus::OK : OpStatus::KEY_NOTFOUND;\n+      return IsInSet(t->db_context(), st, val) ? OpStatus::OK : OpStatus::KEY_NOTFOUND;\n     }\n \n     return find_res.status();\n@@ -859,10 +1020,10 @@ void SetFamily::SIsMember(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SMove(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view src = ArgS(args, 1);\n-  std::string_view dest = ArgS(args, 2);\n-  std::string_view member = ArgS(args, 3);\n+void SMove(CmdArgList args, ConnectionContext* cntx) {\n+  string_view src = ArgS(args, 1);\n+  string_view dest = ArgS(args, 2);\n+  string_view member = ArgS(args, 3);\n \n   Mover mover{src, dest, member};\n   cntx->transaction->Schedule();\n@@ -878,9 +1039,9 @@ void SetFamily::SMove(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(result.value());\n }\n \n-void SetFamily::SRem(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n-  vector<std::string_view> vals(args.size() - 2);\n+void SRem(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  vector<string_view> vals(args.size() - 2);\n   for (size_t i = 2; i < args.size(); ++i) {\n     vals[i - 2] = ArgS(args, i);\n   }\n@@ -901,8 +1062,8 @@ void SetFamily::SRem(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SCard(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n+void SCard(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) -> OpResult<uint32_t> {\n     OpResult<PrimeIterator> find_res = shard->db_slice().Find(t->db_context(), key, OBJ_SET);\n@@ -925,11 +1086,11 @@ void SetFamily::SCard(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SPop(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n+void SPop(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n   unsigned count = 1;\n   if (args.size() > 2) {\n-    std::string_view arg = ArgS(args, 2);\n+    string_view arg = ArgS(args, 2);\n     if (!absl::SimpleAtoi(arg, &count)) {\n       (*cntx)->SendError(kInvalidIntErr);\n       return;\n@@ -958,9 +1119,9 @@ void SetFamily::SPop(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendError(result.status());\n }\n \n-void SetFamily::SDiff(CmdArgList args, ConnectionContext* cntx) {\n+void SDiff(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n-  std::string_view src_key = ArgS(args, 1);\n+  string_view src_key = ArgS(args, 1);\n   ShardId src_shard = Shard(src_key, result_set.size());\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -989,11 +1150,11 @@ void SetFamily::SDiff(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendStringArr(arr);\n }\n \n-void SetFamily::SDiffStore(CmdArgList args, ConnectionContext* cntx) {\n+void SDiffStore(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n-  std::string_view dest_key = ArgS(args, 1);\n+  string_view dest_key = ArgS(args, 1);\n   ShardId dest_shard = Shard(dest_key, result_set.size());\n-  std::string_view src_key = ArgS(args, 2);\n+  string_view src_key = ArgS(args, 2);\n   ShardId src_shard = Shard(src_key, result_set.size());\n \n   VLOG(1) << \"SDiffStore \" << src_key << \" \" << src_shard;\n@@ -1043,7 +1204,7 @@ void SetFamily::SDiffStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(result.size());\n }\n \n-void SetFamily::SMembers(CmdArgList args, ConnectionContext* cntx) {\n+void SMembers(CmdArgList args, ConnectionContext* cntx) {\n   auto cb = [](Transaction* t, EngineShard* shard) { return OpInter(t, shard, false); };\n \n   OpResult<StringVec> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n@@ -1060,7 +1221,7 @@ void SetFamily::SMembers(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SInter(CmdArgList args, ConnectionContext* cntx) {\n+void SInter(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -1082,9 +1243,9 @@ void SetFamily::SInter(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SInterStore(CmdArgList args, ConnectionContext* cntx) {\n+void SInterStore(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n-  std::string_view dest_key = ArgS(args, 1);\n+  string_view dest_key = ArgS(args, 1);\n   ShardId dest_shard = Shard(dest_key, result_set.size());\n   atomic_uint32_t inter_shard_cnt{0};\n \n@@ -1122,7 +1283,7 @@ void SetFamily::SInterStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(result->size());\n }\n \n-void SetFamily::SUnion(CmdArgList args, ConnectionContext* cntx) {\n+void SUnion(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size());\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -1145,9 +1306,9 @@ void SetFamily::SUnion(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-void SetFamily::SUnionStore(CmdArgList args, ConnectionContext* cntx) {\n+void SUnionStore(CmdArgList args, ConnectionContext* cntx) {\n   ResultStringVec result_set(shard_set->size(), OpStatus::SKIPPED);\n-  std::string_view dest_key = ArgS(args, 1);\n+  string_view dest_key = ArgS(args, 1);\n   ShardId dest_shard = Shard(dest_key, result_set.size());\n \n   auto union_cb = [&](Transaction* t, EngineShard* shard) {\n@@ -1186,9 +1347,9 @@ void SetFamily::SUnionStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(result.size());\n }\n \n-void SetFamily::SScan(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view key = ArgS(args, 1);\n-  std::string_view token = ArgS(args, 2);\n+void SScan(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view token = ArgS(args, 2);\n \n   uint64_t cursor = 0;\n \n@@ -1217,79 +1378,38 @@ void SetFamily::SScan(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n-OpResult<StringVec> SetFamily::OpPop(const OpArgs& op_args, std::string_view key, unsigned count) {\n-  auto& db_slice = op_args.shard->db_slice();\n-  OpResult<PrimeIterator> find_res = db_slice.Find(op_args.db_cntx, key, OBJ_SET);\n-  if (!find_res)\n-    return find_res.status();\n-\n-  StringVec result;\n-  if (count == 0)\n-    return result;\n-\n-  PrimeIterator it = find_res.value();\n-  size_t slen = it->second.Size();\n-\n-  /* CASE 1:\n-   * The number of requested elements is greater than or equal to\n-   * the number of elements inside the set: simply return the whole set. */\n-  if (count >= slen) {\n-    container_utils::IterateSet(it->second, [&result](container_utils::ContainerEntry ce) {\n-      result.push_back(ce.ToString());\n-      return true;\n-    });\n-\n-    /* Delete the set as it is now empty */\n-    CHECK(db_slice.Del(op_args.db_cntx.db_index, it));\n-  } else {\n-    SetType st{it->second.RObjPtr(), it->second.Encoding()};\n-    db_slice.PreUpdate(op_args.db_cntx.db_index, it);\n-    if (st.second == kEncodingIntSet) {\n-      intset* is = (intset*)st.first;\n-      int64_t val = 0;\n-\n-      // copy last count values.\n-      for (uint32_t i = slen - count; i < slen; ++i) {\n-        intsetGet(is, i, &val);\n-        result.push_back(absl::StrCat(val));\n-      }\n+// Syntax: saddex key ttl_sec member [member...]\n+void SAddEx(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view ttl_str = ArgS(args, 2);\n+  uint32_t ttl_sec;\n+  constexpr uint32_t kMaxTtl = (1UL << 26);\n \n-      is = intsetTrimTail(is, count);  // now remove last count items\n-      it->second.SetRObjPtr(is);\n-    } else {\n-      result = PopStrSet(count, st);\n-    }\n-    db_slice.PostUpdate(op_args.db_cntx.db_index, it, key);\n+  if (!absl::SimpleAtoi(ttl_str, &ttl_sec) || ttl_sec == 0 || ttl_sec > kMaxTtl) {\n+    return (*cntx)->SendError(kInvalidIntErr);\n   }\n-  return result;\n-}\n \n-OpResult<StringVec> SetFamily::OpScan(const OpArgs& op_args, std::string_view key,\n-                                      uint64_t* cursor) {\n-  OpResult<PrimeIterator> find_res = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_SET);\n+  vector<string_view> vals(args.size() - 3);\n+  for (size_t i = 3; i < args.size(); ++i) {\n+    vals[i - 3] = ArgS(args, i);\n+  }\n \n-  if (!find_res)\n-    return find_res.status();\n+  ArgSlice arg_slice{vals.data(), vals.size()};\n \n-  PrimeIterator it = find_res.value();\n-  StringVec res;\n-  uint32_t count = 10;\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpAddEx(t->GetOpArgs(shard), key, ttl_sec, arg_slice);\n+  };\n \n-  if (it->second.Encoding() == kEncodingIntSet) {\n-    intset* is = (intset*)it->second.RObjPtr();\n-    int64_t intele;\n-    uint32_t pos = 0;\n-    while (intsetGet(is, pos++, &intele)) {\n-      res.push_back(absl::StrCat(intele));\n-    }\n-    *cursor = 0;\n-  } else {\n-    *cursor = ScanStrSet(it->second, *cursor, count, &res);\n+  OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  if (result) {\n+    return (*cntx)->SendLong(result.value());\n   }\n \n-  return res;\n+  (*cntx)->SendError(result.status());\n }\n \n+}  // namespace\n+\n bool SetFamily::ConvertToStrSet(const intset* is, size_t expected_len, robj* dest) {\n   int64_t intele;\n   char buf[32];\n@@ -1334,7 +1454,7 @@ bool SetFamily::ConvertToStrSet(const intset* is, size_t expected_len, robj* des\n \n using CI = CommandId;\n \n-#define HFUNC(x) SetHandler(&SetFamily::x)\n+#define HFUNC(x) SetHandler(&x)\n \n void SetFamily::Register(CommandRegistry* registry) {\n   *registry << CI{\"SADD\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, 1}.HFUNC(SAdd)\n@@ -1351,6 +1471,10 @@ void SetFamily::Register(CommandRegistry* registry) {\n             << CI{\"SUNION\", CO::READONLY, -2, 1, -1, 1}.HFUNC(SUnion)\n             << CI{\"SUNIONSTORE\", CO::WRITE | CO::DENYOOM, -3, 1, -1, 1}.HFUNC(SUnionStore)\n             << CI{\"SSCAN\", CO::READONLY, -3, 1, 1, 1}.HFUNC(SScan);\n+\n+  if (absl::GetFlag(FLAGS_use_set2)) {\n+    *registry << CI{\"SADDEX\", CO::WRITE | CO::FAST | CO::DENYOOM, -4, 1, 1, 1}.HFUNC(SAddEx);\n+  }\n }\n \n uint32_t SetFamily::MaxIntsetEntries() {\ndiff --git a/src/server/set_family.h b/src/server/set_family.h\nindex 847014719a5f..d406982b81d9 100644\n--- a/src/server/set_family.h\n+++ b/src/server/set_family.h\n@@ -32,25 +32,6 @@ class SetFamily {\n   static bool ConvertToStrSet(const intset* is, size_t expected_len, robj* dest);\n \n  private:\n-  static void SAdd(CmdArgList args,  ConnectionContext* cntx);\n-  static void SIsMember(CmdArgList args,  ConnectionContext* cntx);\n-  static void SRem(CmdArgList args,  ConnectionContext* cntx);\n-  static void SCard(CmdArgList args,  ConnectionContext* cntx);\n-  static void SPop(CmdArgList args,  ConnectionContext* cntx);\n-  static void SUnion(CmdArgList args,  ConnectionContext* cntx);\n-  static void SUnionStore(CmdArgList args,  ConnectionContext* cntx);\n-  static void SDiff(CmdArgList args,  ConnectionContext* cntx);\n-  static void SDiffStore(CmdArgList args,  ConnectionContext* cntx);\n-  static void SMembers(CmdArgList args,  ConnectionContext* cntx);\n-  static void SMove(CmdArgList args,  ConnectionContext* cntx);\n-  static void SInter(CmdArgList args,  ConnectionContext* cntx);\n-  static void SInterStore(CmdArgList args,  ConnectionContext* cntx);\n-  static void SScan(CmdArgList args,  ConnectionContext* cntx);\n-\n-  // count - how many elements to pop.\n-  static OpResult<StringVec> OpPop(const OpArgs& op_args, std::string_view key, unsigned count);\n-  static OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t* cursor);\n-\n };\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/core/string_set_test.cc b/src/core/string_set_test.cc\nindex d1b44e5196ef..08a2e126c3bd 100644\n--- a/src/core/string_set_test.cc\n+++ b/src/core/string_set_test.cc\n@@ -263,9 +263,8 @@ TEST_F(StringSetTest, IntOnly) {\n \n   size_t expected_seen = 0;\n   auto scan_callback = [&](const sds ptr) {\n-    sds s = (sds)ptr;\n-    string_view str{s, sdslen(s)};\n-    EXPECT_FALSE(removed.count(string(str)));\n+    string str{ptr, sdslen(ptr)};\n+    EXPECT_FALSE(removed.count(str));\n \n     if (numbers.count(atoi(str.data()))) {\n       ++expected_seen;\n@@ -281,7 +280,7 @@ TEST_F(StringSetTest, IntOnly) {\n     ss_->Add(to_string(val));\n   } while (cursor != 0);\n \n-  EXPECT_TRUE(expected_seen + removed.size() == num_ints);\n+  EXPECT_GE(expected_seen + removed.size(), num_ints);\n }\n \n TEST_F(StringSetTest, XtremeScanGrow) {\n",
  "problem_statement": "TTL for messages in SET\n**Did you search GitHub Issues and GitHub Discussions First?**\r\nYes\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nYes, There is no way to set TTL for messages in a KEY\r\n\r\n**Describe the solution you'd like**\r\nWe should be able to set a message TTL for collections such as SET, LIST etc.\r\nThis message TTL will not expire the KEY rather it expires messages\r\n\r\n**Describe alternatives you've considered**\r\n\r\n1. One dirty workaround is to use separate KEYs for each messages in a pattern (to achieve functionality similar to collections)\r\n\r\nExample:\r\n```\r\n@00:00:00 SET mycollection:1 value1\r\n@00:00:01 EXPIRE mycollection:1 60\r\n@00:01:00 SET mycollection:2 value 2\r\n@00:01:01 EXPIRE mycollection:1 60\r\n@00:01:02 KEYS mycollection:*\r\n# returns\r\n1) mycollection:2\r\n```\r\n2. Using sorted SETs\r\n```\r\nUse sorted sets, and use a timestamp as the score. It's then trivial to delete items by score range,\r\nwhich could be done periodically, or only on every write, with reads always ignoring the out of range elements,\r\nby reading only a range of scores.\r\n```\r\nSource - https://groups.google.com/g/redis-db/c/rXXMCLNkNSs\r\n\n",
  "hints_text": "A question in SO related to this\r\n\r\nhttps://stackoverflow.com/questions/7577923/redis-possible-to-expire-an-element-in-an-array-or-sorted-set\r\n\nWe can start with sets because we laid out our own implementation for this data-structure.\r\n\r\nWe can introduce a command `SADDEX  key ttl member member member`.\r\nThis command will set a TTL in seconds for each of the members.\r\nThe next SADDEX command for the same key must have the same TTL, otherwise the error will be returned. Similarly, calling SADDEX on an existing key that was created with SADD will also return an error.\r\n\r\nsubsequently, `SADD key member ...` will work on keys with TTL for members by using the TTL already set by previous SADDEX call. Of course, if SADD was used to create a set then no TTL is set.  \r\n\r\nwill it work for your case?\r\n\r\nOne note though - SCARD will return approximate results because it can not know which members are expired without iterating on all of them.\n```\r\nWe can start with sets because we laid out our own implementation for this data-structure.\r\n```\r\nOkay, that's fine.\r\n\r\nThe proposed solution should work.\r\n\r\n> SCARD will return approximate results because it can not know which members are expired without iterating on all of them.\r\n\r\nWhy do you think that it would return approx results ? Once a message is expired, it automatically gets removed from the SET. In that case `SCARD` should return correct result, right ?\n> command will set a TTL in seconds for each of the members.\r\nThe next SADDEX command for the same key must have the same TTL, otherwise the error will be returned. Similarly, calling SADDEX on an existing key that was created with SADD will also return an error.\r\n\r\nConsidering these issues, can we consider creating a new data type based on SET with expiry feature ?\nsomething needs to actually check and expire it. if we do lazy expiry, SCARD will be approximate. If we apply exact expiry then the CPU and memory usage will be much higher.\n> > command will set a TTL in seconds for each of the members.\r\n> > The next SADDEX command for the same key must have the same TTL, otherwise the error will be returned. Similarly, calling SADDEX on an existing key that was created with SADD will also return an error.\r\n> \r\n> Considering these issues, can we consider creating a new data type based on SET with expiry feature ?\r\n\r\nI do not think that this warrants an introduction of a new data type. SADD will work as expected as long as you do not use SADDEX so it is backward compatible with the existing type.\nThere is no meaning for having the same TTL for all members of the set if the TTL is set with every SADDEX.\r\nI suggest to allow any set to mix between TTL members and non expired members.\r\nSADDEX will add memebers to the set with TTL\r\nSADD will add members to the set with +INF TTL.\r\n\r\nIn this implementation errors are not required. \r\n\nKeyDB has got similar feature, see [here](https://docs.keydb.dev/docs/commands/#expiremember)\r\n\r\n## EXPIREMEMBER\r\n\r\n#### Syntax:\r\n\r\n```EXPIREMEMBER <key> <subkey> <timeout-in-seconds> <OPTIONAL:unit-time-format>```\r\n\r\n#### Description:\r\n\r\nSets a timeout on a subkey (individual member of a set).\r\n\r\nAfter the timeout has expired, the subkey will automatically be deleted. This \r\ncommand is similar to the EXPIRE command but is associated to individual members\r\nof a set. \r\n\r\nIf a subkey has an expiration set and is later moved or deleted before expiry, \r\nthen the expiration behavior is undefined. Examples of this may include `SMOVE and SADD`.\r\n\r\nThe timeout can also be cleared, turning the subkey back into a persistent subkey,\r\nusing the `PERSIST` command.\r\n\r\nTTL (time to live) is by default set in seconds, however you can optionally specify the unit to milleseconds \r\nThe command format is `EXPIREMEMBER key subkey delay [Unit: s,ms]`. This time similar to EXPIRE can be queried with TTL and PTTL\r\n\r\n#### Refreshing expires\r\n\r\nIt is possible to call `EXPIREMEMBER` using as argument a subkey that already has an\r\nexisting expire set.\r\nIn this case the time to live of a subkey is _updated_ to the new value.\r\n\r\n#### Return:\r\n\r\nInteger Reply, specifically:\r\n\r\n* `1` if the timeout was set.\r\n* `0` if `key` does not exist.\r\n\r\n#### Examples:\r\n\r\n```\r\nkeydb-cli> SADD key member1 member2 member3\r\n(integer) 3\r\nkeydb-cli> SMEMBERS key\r\n1) \"member1\"\r\n2) \"member2\"\r\n3) \"member3\"\r\nkeydb-cli> EXPIREMEMBER key member1 10\r\n(integer) 1\r\nkeydb-cli> TTL key member1\r\n(integer) 10\r\nkeydb-cli> EXPIREMEMBER key member1 10000 ms\r\n(integer) 1\r\nkeydb-cli> TTL key member1\r\n(integer) 10\r\n```\r\n*10 seconds later...*\r\n```\r\nkeydb-cli> SMEMBERS key\r\n1) \"member2\"\r\n2) \"member3\"\r\nkeydb-cli> EXPIREMEMBER key member1 10\r\n(error) ERR subkey does not exist\r\n```\r\n",
  "created_at": "2022-10-03T09:46:39Z",
  "modified_files": [
    "src/core/dense_set.cc",
    "src/server/set_family.cc",
    "src/server/set_family.h"
  ],
  "modified_test_files": [
    "src/core/string_set_test.cc"
  ]
}