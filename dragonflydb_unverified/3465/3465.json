{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3465,
  "instance_id": "dragonflydb__dragonfly-3465",
  "issue_numbers": [
    "2442"
  ],
  "base_commit": "75452a7108fecb83bda341648d452740a41020e5",
  "patch": "diff --git a/src/server/script_mgr.cc b/src/server/script_mgr.cc\nindex 1c950c149c34..1881685e9b73 100644\n--- a/src/server/script_mgr.cc\n+++ b/src/server/script_mgr.cc\n@@ -38,6 +38,15 @@ ABSL_FLAG(bool, lua_allow_undeclared_auto_correct, false,\n           \"access undeclared keys, automaticaly set the script flag to be able to run with \"\n           \"undeclared key.\");\n \n+ABSL_FLAG(\n+    std::vector<std::string>, lua_undeclared_keys_shas,\n+    std::vector<std::string>({\n+        \"351130589c64523cb98978dc32c64173a31244f3\",  // Sidekiq, see #2442\n+        \"6ae15ef4678593dc61f991c9953722d67d822776\",  // Sidekiq, see #2442\n+    }),\n+    \"Comma-separated list of Lua script SHAs which are allowed to access undeclared keys. SHAs are \"\n+    \"only looked at when loading the script, and new values do not affect already-loaded script.\");\n+\n namespace dfly {\n using namespace std;\n using namespace facade;\n@@ -262,6 +271,11 @@ io::Result<string, GenericError> ScriptMgr::Insert(string_view body, Interpreter\n     return params_opt.get_unexpected();\n   auto params = params_opt->value_or(default_params_);\n \n+  auto undeclared_shas = absl::GetFlag(FLAGS_lua_undeclared_keys_shas);\n+  if (find(undeclared_shas.begin(), undeclared_shas.end(), sha) != undeclared_shas.end()) {\n+    params.undeclared_keys = true;\n+  }\n+\n   // If the script is atomic, check for possible squashing optimizations.\n   // For non atomic modes, squashing increases the time locks are held, which\n   // can decrease throughput with frequently accessed keys.\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 52cb052dcfd3..78b6642ad592 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -824,6 +824,7 @@ void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listen\n   config_registry.RegisterMutable(\"tls_ca_cert_file\");\n   config_registry.RegisterMutable(\"tls_ca_cert_dir\");\n   config_registry.RegisterMutable(\"replica_priority\");\n+  config_registry.RegisterMutable(\"lua_undeclared_keys_shas\");\n \n   pb_task_ = shard_set->pool()->GetNextProactor();\n   if (pb_task_->GetKind() == ProactorBase::EPOLL) {\n",
  "test_patch": "diff --git a/src/server/multi_test.cc b/src/server/multi_test.cc\nindex 9a9bea3b2b89..1d0ba7687fe0 100644\n--- a/src/server/multi_test.cc\n+++ b/src/server/multi_test.cc\n@@ -380,6 +380,7 @@ TEST_F(MultiTest, Eval) {\n     GTEST_SKIP() << \"Skipped Eval test because default_lua_flags is set\";\n     return;\n   }\n+  absl::FlagSaver saver;\n   absl::SetFlag(&FLAGS_lua_allow_undeclared_auto_correct, true);\n \n   RespExpr resp;\n@@ -762,6 +763,37 @@ TEST_F(MultiTest, ScriptFlagsEmbedded) {\n   EXPECT_THAT(Run({\"eval\", s2, \"0\"}), ErrArg(\"Invalid flag: this-is-an-error\"));\n }\n \n+TEST_F(MultiTest, UndeclaredKeyFlag) {\n+  if (auto mode = absl::GetFlag(FLAGS_multi_exec_mode); mode != Transaction::LOCK_AHEAD) {\n+    GTEST_SKIP() << \"Skipped test because multi_exec_mode is not default\";\n+    return;\n+  }\n+\n+  absl::FlagSaver fs;  // lua_undeclared_keys_shas changed via CONFIG cmd below\n+\n+  const char* script = \"return redis.call('GET', 'random-key');\";\n+  Run({\"set\", \"random-key\", \"works\"});\n+\n+  // Get SHA for script in a persistent way\n+  string sha = Run({\"script\", \"load\", script}).GetString();\n+\n+  // Make sure we can't run the script before setting the flag\n+  EXPECT_THAT(Run({\"evalsha\", sha, \"0\"}), ErrArg(\"undeclared\"));\n+  EXPECT_THAT(Run({\"eval\", script, \"0\"}), ErrArg(\"undeclared\"));\n+\n+  // Clear all Lua scripts so we can configure the cache\n+  EXPECT_THAT(Run({\"script\", \"flush\"}), \"OK\");\n+  EXPECT_THAT(Run({\"script\", \"exists\", sha}), IntArg(0));\n+\n+  EXPECT_THAT(\n+      Run({\"config\", \"set\", \"lua_undeclared_keys_shas\", absl::StrCat(sha, \",NON-EXISTING-HASH\")}),\n+      \"OK\");\n+\n+  // Check eval finds script flags.\n+  EXPECT_EQ(Run({\"eval\", script, \"0\"}), \"works\");\n+  EXPECT_EQ(Run({\"evalsha\", sha, \"0\"}), \"works\");\n+}\n+\n // todo: ASAN fails heres on arm\n #ifndef SANITIZERS\n TEST_F(MultiTest, ScriptBadCommand) {\n",
  "problem_statement": "support Sidekiq Pro's reliable scheduler script by marking it with allow-undeclared-keys\nRedis Lua requires the user to define all keys touched by a Lua script when invoking that script in order to run correctly in Redis Cluster.\r\n\r\nThe problem is that Sidekiq Pro's reliable scheduler does not know which queue (list) it will touch next when invoked. And Redis allows us to violate that requirement since Sidekiq does not support Redis Cluster.\r\n\r\nThe Lua scheduler is a simple loop:\r\n\r\n- Take the first job off ZSet \"scheduled\" where score is < Time.now.to_f.\r\n- Parse the JSON to get the `queue` element.\r\n- Push the job onto that named queue.\r\n\r\nAs you can see, we know the Lua script will touch `scheduled` but we don't know the name of the queue because the scheduled set holds future jobs for all queues and the job data itself tells us which queue to mutate.\r\n\r\nUnfortunately it looks like DragonflyDB enforces this Lua requirement, making Sidekiq Pro's reliable scheduler feature incompatible. Redis does allow it as long as it is not running in Cluster mode.\n",
  "hints_text": "@mperham  Unfortunately, atomicity requirements do not allow Dragonfly to parallelize arbitrary lua code efficiently.\r\nWe provide compatibility flags that allow running lua script with undeclared variables but this would kill performance of Dragonfly, since such lua script would run under Global Lock.\r\n\r\nCan you please explain semantics of reliable scheduler? Why is there a global \"scheduled\" set if its items are distributed into different queues anyway? Why not have \"scheduled\" per queue, for example?\nThe use of a single, global `scheduled` zset is simply one of legacy. That's how it was originally written 10+ years ago before we even had the SCAN commands and it has never changed. There are 4-5 global structures which have proven a pain to scale because they don't have a Cluster-friendly data model.\n@mperham Is atomicity required for this script? From your description of the script if the script is not executed from different clients I believe there is no atomicity requirement and if this is the case dragonfly can run a script in non atomic mode which will allow you to not declare the keys in advance.\n@adiholden consider the following scenario:\r\n1. worker A removes  a job from \"scheduled\" with score 1, then it non-atomically tries to add it to Q1.\r\n2. worker B removes a job from  \"scheduled\" with score 2, then it also non-atomically tries to add it to Q1. \r\n3. Worker B succeeds first and now the first job in Q1 has score 2, and the next one has score 1.\n@romange If this script runs by multiple clients (as in your example different workers), the atomicity is important \n@adiholden found this comment https://github.com/sidekiq/sidekiq/blob/80f5f73f8e74a5775866a016fe42446dfc1b861e/docs/internals.md?plain=1#L31 \r\n\r\n@mperham  can you confirm that sidekiq-pro maintains at most one thread that calls this script?  \n> can you confirm that sidekiq-pro maintains at most one thread that calls this script?\r\n\r\nOne thread **per process**. You can have many Sidekiq processes, all calling the script concurrently. That's why it's written in Lua.\nThe workaround that seemed to work for us `script flags 351130589c64523cb98978dc32c64173a31244f3 allow-undeclared-keys`\r\n\r\nWe should do it automatically within Dragonfly. No reason not to do it.\n@romange Ideally we could add a `#!lua flags=allow-undeclared-keys` to SideKiq Pro's scripts directly. This will be future proof for changes in SHAs. Downside is that we'll need to get @mperham's approval, and wait for their next release.\nI can do that. I was planning a patch release soon anyways. \n> I can do that. I was planning a patch release soon anyways.\r\n\r\nI synced with @romange offline. If you could do that, for all scripts that (may) access undeclared keys (are there any other than what's discussed here?), that's be great. I'm happy to review if that'd be helpful.\r\n\r\nOn our side, we'll add the ability to specify SHAs for which we'll use `allow-undeclared-keys`, mainly to support users until they upgrade their Sidekiq version",
  "created_at": "2024-08-07T07:58:30Z",
  "modified_files": [
    "src/server/script_mgr.cc",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "src/server/multi_test.cc"
  ]
}