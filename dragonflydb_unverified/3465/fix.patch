diff --git a/src/server/script_mgr.cc b/src/server/script_mgr.cc
index 1c950c149c34..1881685e9b73 100644
--- a/src/server/script_mgr.cc
+++ b/src/server/script_mgr.cc
@@ -38,6 +38,15 @@ ABSL_FLAG(bool, lua_allow_undeclared_auto_correct, false,
           "access undeclared keys, automaticaly set the script flag to be able to run with "
           "undeclared key.");
 
+ABSL_FLAG(
+    std::vector<std::string>, lua_undeclared_keys_shas,
+    std::vector<std::string>({
+        "351130589c64523cb98978dc32c64173a31244f3",  // Sidekiq, see #2442
+        "6ae15ef4678593dc61f991c9953722d67d822776",  // Sidekiq, see #2442
+    }),
+    "Comma-separated list of Lua script SHAs which are allowed to access undeclared keys. SHAs are "
+    "only looked at when loading the script, and new values do not affect already-loaded script.");
+
 namespace dfly {
 using namespace std;
 using namespace facade;
@@ -262,6 +271,11 @@ io::Result<string, GenericError> ScriptMgr::Insert(string_view body, Interpreter
     return params_opt.get_unexpected();
   auto params = params_opt->value_or(default_params_);
 
+  auto undeclared_shas = absl::GetFlag(FLAGS_lua_undeclared_keys_shas);
+  if (find(undeclared_shas.begin(), undeclared_shas.end(), sha) != undeclared_shas.end()) {
+    params.undeclared_keys = true;
+  }
+
   // If the script is atomic, check for possible squashing optimizations.
   // For non atomic modes, squashing increases the time locks are held, which
   // can decrease throughput with frequently accessed keys.
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index 52cb052dcfd3..78b6642ad592 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -824,6 +824,7 @@ void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listen
   config_registry.RegisterMutable("tls_ca_cert_file");
   config_registry.RegisterMutable("tls_ca_cert_dir");
   config_registry.RegisterMutable("replica_priority");
+  config_registry.RegisterMutable("lua_undeclared_keys_shas");
 
   pb_task_ = shard_set->pool()->GetNextProactor();
   if (pb_task_->GetKind() == ProactorBase::EPOLL) {
