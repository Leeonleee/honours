{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1514,
  "instance_id": "dragonflydb__dragonfly-1514",
  "issue_numbers": [
    "1458"
  ],
  "base_commit": "3c36a17ce2ae2943d585767e534dc82dcb40003d",
  "patch": "diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 606a63faca1e..eb288cd7ab4d 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -915,4 +915,8 @@ std::string Connection::RemoteEndpointAddress() const {\n   return re.address().to_string();\n }\n \n+ConnectionContext* Connection::cntx() {\n+  return cc_.get();\n+}\n+\n }  // namespace facade\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 3913aaec7013..9bbd59d6fba3 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -163,6 +163,8 @@ class Connection : public util::Connection {\n     return name_;\n   }\n \n+  ConnectionContext* cntx();\n+\n  protected:\n   void OnShutdown() override;\n   void OnPreMigrateThread() override;\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 2e04cd7ba6b0..51c124772a65 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -9,6 +9,7 @@\n #include \"server/engine_shard_set.h\"\n #include \"server/server_family.h\"\n #include \"server/server_state.h\"\n+#include \"server/transaction.h\"\n #include \"src/facade/dragonfly_connection.h\"\n \n namespace dfly {\n@@ -93,6 +94,12 @@ void ConnectionContext::ChangeMonitor(bool start) {\n   EnableMonitoring(start);\n }\n \n+void ConnectionContext::CancelBlocking() {\n+  if (transaction) {\n+    transaction->CancelBlocking();\n+  }\n+}\n+\n vector<unsigned> ChangeSubscriptions(bool pattern, CmdArgList args, bool to_add, bool to_reply,\n                                      ConnectionContext* conn) {\n   vector<unsigned> result(to_reply ? args.size() : 0, 0);\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex e768bd960a4d..e2cabc401e07 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -175,6 +175,7 @@ class ConnectionContext : public facade::ConnectionContext {\n   void UnsubscribeAll(bool to_reply);\n   void PUnsubscribeAll(bool to_reply);\n   void ChangeMonitor(bool start);  // either start or stop monitor on a given connection\n+  void CancelBlocking(); // Cancel an ongoing blocking transaction if there is one.\n \n   // Whether this connection is a connection from a replica to its master.\n   // This flag is true only on replica side, where we need to setup a special ConnectionContext\ndiff --git a/src/server/dflycmd.cc b/src/server/dflycmd.cc\nindex c7fe6d25fd34..15573e021deb 100644\n--- a/src/server/dflycmd.cc\n+++ b/src/server/dflycmd.cc\n@@ -377,8 +377,9 @@ void DflyCmd::TakeOver(CmdArgList args, ConnectionContext* cntx) {\n   absl::Time start = absl::Now();\n   AggregateStatus status;\n \n-  // TODO: We should cancel blocking commands before awaiting all\n-  // dispatches to finish.\n+  // We need to await for all dispatches to finish: Otherwise a transaction might be scheduled\n+  // after this function exits but before the actual shutdown.\n+  sf_->CancelBlockingCommands();\n   if (!sf_->AwaitDispatches(timeout_dur, [self = cntx->owner()](util::Connection* conn) {\n         // The only command that is currently dispatching should be the takeover command -\n         // so we wait until this is true.\n@@ -387,7 +388,12 @@ void DflyCmd::TakeOver(CmdArgList args, ConnectionContext* cntx) {\n     LOG(WARNING) << \"Couldn't wait for commands to finish dispatching. \" << timeout_dur;\n     status = OpStatus::TIMED_OUT;\n   }\n+  VLOG(1) << \"AwaitDispatches done\";\n \n+  // We have this guard to disable expirations: We don't want any writes to the journal after\n+  // we send the `PING`, and expirations could ruin that.\n+  // TODO: Decouple disabling expirations from TransactionGuard because we don't\n+  // really need TransactionGuard here.\n   TransactionGuard tg{cntx->transaction, /*disable_expirations=*/true};\n \n   if (*status == OpStatus::OK) {\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 6ba768ea87cb..1d7195731f25 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1028,9 +1028,7 @@ facade::ConnectionContext* Service::CreateContext(util::FiberSocketBase* peer,\n   // a bit of a hack. I set up breaker callback here for the owner.\n   // Should work though it's confusing to have it here.\n   owner->RegisterBreakHook([res, this](uint32_t) {\n-    if (res->transaction) {\n-      res->transaction->BreakOnShutdown();\n-    }\n+    res->CancelBlocking();\n     this->server_family().BreakOnShutdown();\n   });\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex bff4ce65bf30..1c7859692000 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1260,6 +1260,19 @@ void ServerFamily::BreakOnShutdown() {\n   dfly_cmd_->BreakOnShutdown();\n }\n \n+void ServerFamily::CancelBlockingCommands() {\n+  auto cb = [](unsigned thread_index, util::Connection* conn) {\n+    facade::ConnectionContext* fc = static_cast<facade::Connection*>(conn)->cntx();\n+    if (fc) {\n+      ConnectionContext* cntx = static_cast<ConnectionContext*>(fc);\n+      cntx->CancelBlocking();\n+    }\n+  };\n+  for (auto* listener : listeners_) {\n+    listener->TraverseConnections(cb);\n+  }\n+}\n+\n bool ServerFamily::AwaitDispatches(absl::Duration timeout,\n                                    const std::function<bool(util::Connection*)>& filter) {\n   auto start = absl::Now();\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex a56148b64bd3..5216848b53a4 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -156,6 +156,8 @@ class ServerFamily {\n \n   void BreakOnShutdown();\n \n+  void CancelBlockingCommands();\n+\n   bool AwaitDispatches(absl::Duration timeout,\n                        const std::function<bool(util::Connection*)>& filter);\n \ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 4d7bdd8540d9..5b8c1fa286d8 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1385,7 +1385,7 @@ void Transaction::FinishLogJournalOnShard(EngineShard* shard, uint32_t shard_cnt\n   journal->RecordEntry(txid_, journal::Op::EXEC, db_index_, shard_cnt, {}, false);\n }\n \n-void Transaction::BreakOnShutdown() {\n+void Transaction::CancelBlocking() {\n   if (coordinator_state_ & COORD_BLOCKED) {\n     coordinator_state_ |= COORD_CANCELLED;\n     blocking_ec_.notify();\ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex 3d171d95c86f..bfb260a382e6 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -182,8 +182,9 @@ class Transaction {\n   // blocking queue.\n   bool NotifySuspended(TxId committed_ts, ShardId sid, std::string_view key);\n \n-  // Cancel all blocking watches on shutdown. Set COORD_CANCELLED.\n-  void BreakOnShutdown();\n+  // Cancel all blocking watches. Set COORD_CANCELLED.\n+  // Must be called from coordinator thread.\n+  void CancelBlocking();\n \n   // In some cases for non auto-journaling commands we want to enable the auto journal flow.\n   void RenableAutoJournal() {\n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex 0730682d433d..9992be187aac 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -1120,12 +1120,11 @@ async def counter(key):\n \n         async def block_during_takeover():\n             \"Add a blocking command during takeover to make sure it doesn't block it.\"\n-            # TODO: We need to make takeover interrupt blocking commands.\n-            return\n-            try:\n-                await c_blocking.execute_command(\"BLPOP BLOCKING_KEY1 BLOCKING_KEY2 10\")\n-            except redis.exceptions.ConnectionError:\n-                pass\n+            start = time.time()\n+            # The command should just be canceled\n+            assert await c_blocking.execute_command(\"BLPOP BLOCKING_KEY1 BLOCKING_KEY2 100\") is None\n+            # And it should happen in reasonable amount of time.\n+            assert time.time() - start < 10\n \n         async def delayed_takeover():\n             await asyncio.sleep(1)\n",
  "problem_statement": "Handle blocking commands during replica takeover\n\n",
  "hints_text": "",
  "created_at": "2023-07-03T14:55:20Z",
  "modified_files": [
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/conn_context.cc",
    "src/server/conn_context.h",
    "src/server/dflycmd.cc",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/server_family.h",
    "src/server/transaction.cc",
    "src/server/transaction.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}