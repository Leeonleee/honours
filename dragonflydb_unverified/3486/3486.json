{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3486,
  "instance_id": "dragonflydb__dragonfly-3486",
  "issue_numbers": [
    "3476"
  ],
  "base_commit": "19fb7aa158a385f41066466495e4ddf1e6669e80",
  "patch": "diff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 527cef6e3301..32eb7cca66e8 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1626,6 +1626,22 @@ void ServerFamily::FlushAll(CmdArgList args, ConnectionContext* cntx) {\n   cntx->SendOk();\n }\n \n+bool ServerFamily::DoAuth(ConnectionContext* cntx, std::string_view username,\n+                          std::string_view password) const {\n+  const auto* registry = ServerState::tlocal()->user_registry;\n+  CHECK(registry);\n+  const bool is_authorized = registry->AuthUser(username, password);\n+  if (is_authorized) {\n+    cntx->authed_username = username;\n+    auto cred = registry->GetCredentials(username);\n+    cntx->acl_commands = cred.acl_commands;\n+    cntx->keys = std::move(cred.keys);\n+    cntx->ns = &namespaces.GetOrInsert(cred.ns);\n+    cntx->authenticated = true;\n+  }\n+  return is_authorized;\n+}\n+\n void ServerFamily::Auth(CmdArgList args, ConnectionContext* cntx) {\n   if (args.size() > 2) {\n     return cntx->SendError(kSyntaxErr);\n@@ -1633,19 +1649,11 @@ void ServerFamily::Auth(CmdArgList args, ConnectionContext* cntx) {\n \n   // non admin port auth\n   if (!cntx->conn()->IsPrivileged()) {\n-    const auto* registry = ServerState::tlocal()->user_registry;\n     const bool one_arg = args.size() == 1;\n     std::string_view username = one_arg ? \"default\" : facade::ToSV(args[0]);\n     const size_t index = one_arg ? 0 : 1;\n     std::string_view password = facade::ToSV(args[index]);\n-    auto is_authorized = registry->AuthUser(username, password);\n-    if (is_authorized) {\n-      cntx->authed_username = username;\n-      auto cred = registry->GetCredentials(username);\n-      cntx->acl_commands = cred.acl_commands;\n-      cntx->keys = std::move(cred.keys);\n-      cntx->ns = &namespaces.GetOrInsert(cred.ns);\n-      cntx->authenticated = true;\n+    if (DoAuth(cntx, username, password)) {\n       return cntx->SendOk();\n     }\n     auto& log = ServerState::tlocal()->acl_log;\n@@ -2417,13 +2425,8 @@ void ServerFamily::Hello(CmdArgList args, ConnectionContext* cntx) {\n     }\n   }\n \n-  if (has_auth) {\n-    if (username == \"default\" && password == GetPassword()) {\n-      cntx->authenticated = true;\n-    } else {\n-      cntx->SendError(facade::kAuthRejected);\n-      return;\n-    }\n+  if (has_auth && !DoAuth(cntx, username, password)) {\n+    return cntx->SendError(facade::kAuthRejected);\n   }\n \n   if (cntx->req_auth && !cntx->authenticated) {\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex dbba0f4f39db..5c38bc4406fd 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -298,6 +298,8 @@ class ServerFamily {\n   GenericError WaitUntilSaveFinished(Transaction* trans, bool ignore_state = false);\n   void StopAllClusterReplicas();\n \n+  bool DoAuth(ConnectionContext* cntx, std::string_view username, std::string_view password) const;\n+\n   util::fb2::Fiber snapshot_schedule_fb_;\n   std::optional<util::fb2::Future<GenericError>> load_result_;\n \n",
  "test_patch": "diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc\nindex 2e229ee1f405..63c083e930ba 100644\n--- a/src/server/dragonfly_test.cc\n+++ b/src/server/dragonfly_test.cc\n@@ -63,6 +63,14 @@ class DflyEngineTest : public BaseFamilyTest {\n   }\n };\n \n+class DflyEngineTestWithRegistry : public BaseFamilyTest {\n+ protected:\n+  DflyEngineTestWithRegistry() : BaseFamilyTest() {\n+    num_threads_ = kPoolThreadCount;\n+    ResetService();\n+  }\n+};\n+\n class SingleThreadDflyEngineTest : public BaseFamilyTest {\n  protected:\n   SingleThreadDflyEngineTest() : BaseFamilyTest() {\n@@ -289,7 +297,7 @@ TEST_F(DflyEngineTest, ScriptFlush) {\n   EXPECT_THAT(1, resp.GetInt());\n }\n \n-TEST_F(DflyEngineTest, Hello) {\n+TEST_F(DflyEngineTestWithRegistry, Hello) {\n   auto resp = Run({\"hello\"});\n   ASSERT_THAT(resp, ArrLen(14));\n   resp = Run({\"hello\", \"2\"});\n@@ -316,9 +324,14 @@ TEST_F(DflyEngineTest, Hello) {\n               ErrArg(\"WRONGPASS invalid username-password pair or user is disabled.\"));\n \n   resp = Run({\"hello\", \"3\", \"AUTH\", \"default\", \"\"});\n+  ASSERT_THAT(resp, ErrArg(\"WRONGPASS invalid username-password pair or user is disabled.\"));\n+\n+  TestInitAclFam();\n+\n+  resp = Run({\"hello\", \"3\", \"AUTH\", \"default\", \"tmp\"});\n   ASSERT_THAT(resp, ArrLen(14));\n \n-  resp = Run({\"hello\", \"3\", \"AUTH\", \"default\", \"\", \"SETNAME\", \"myname\"});\n+  resp = Run({\"hello\", \"3\", \"AUTH\", \"default\", \"tmp\", \"SETNAME\", \"myname\"});\n   ASSERT_THAT(resp, ArrLen(14));\n }\n \ndiff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex 1138cba28e83..be2efe36e76e 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -135,51 +135,51 @@ async def test_acl_cat_commands_multi_exec_squash(df_factory):\n     df.start()\n \n     # Testing acl categories\n-    client = aioredis.Redis(port=df.port)\n+    client = aioredis.Redis(port=df.port, decode_responses=True)\n     res = await client.execute_command(\"ACL SETUSER kk ON >kk +@transaction +@string ~*\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"AUTH kk kk\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     await client.execute_command(\"MULTI\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     for x in range(33):\n         await client.execute_command(f\"SET x{x} {x}\")\n     await client.execute_command(\"EXEC\")\n \n-    client = aioredis.Redis(port=df.port)\n     await client.close()\n+    client = aioredis.Redis(port=df.port, decode_responses=True)\n \n     # NOPERM while executing multi\n     await client.execute_command(\"ACL SETUSER kk -@string\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     await client.execute_command(\"AUTH kk kk\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     await client.execute_command(\"MULTI\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     with pytest.raises(redis.exceptions.NoPermissionError):\n         await client.execute_command(f\"SET x{x} {x}\")\n     await client.close()\n \n     # NOPERM between multi and exec\n-    admin_client = aioredis.Redis(port=df.port)\n+    admin_client = aioredis.Redis(port=df.port, decode_responses=True)\n     res = await client.execute_command(\"ACL SETUSER kk +@string\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n-    client = aioredis.Redis(port=df.port)\n+    client = aioredis.Redis(port=df.port, decode_responses=True)\n     res = await client.execute_command(\"AUTH kk kk\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     # CLIENT has permissions, starts MULTI and issues a bunch of SET commands\n     await client.execute_command(\"MULTI\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     for x in range(33):\n         await client.execute_command(f\"SET x{x} {x}\")\n \n     # admin revokes permissions\n     res = await admin_client.execute_command(\"ACL SETUSER kk -@string\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"EXEC\")\n     # TODO(we need to fix this, basiscally SQUASHED/MULTI transaction commands\n@@ -192,23 +192,23 @@ async def test_acl_cat_commands_multi_exec_squash(df_factory):\n     await client.close()\n \n     # Testing acl commands\n-    client = aioredis.Redis(port=df.port)\n+    client = aioredis.Redis(port=df.port, decode_responses=True)\n     res = await client.execute_command(\"ACL SETUSER myuser ON >kk +@transaction +set ~*\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"AUTH myuser kk\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     await client.execute_command(\"MULTI\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n     for x in range(33):\n         await client.execute_command(f\"SET x{x} {x}\")\n     await client.execute_command(\"EXEC\")\n \n     # NOPERM between multi and exec\n-    admin_client = aioredis.Redis(port=df.port)\n+    admin_client = aioredis.Redis(port=df.port, decode_responses=True)\n     res = await admin_client.execute_command(\"ACL SETUSER myuser -set\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     # NOPERM while executing multi\n     await client.execute_command(\"MULTI\")\n@@ -223,18 +223,18 @@ async def test_acl_cat_commands_multi_exec_squash(df_factory):\n @pytest.mark.skip(\"Skip because it fails on arm release\")\n @pytest.mark.asyncio\n async def test_acl_deluser(df_server):\n-    client = aioredis.Redis(port=df_server.port)\n+    client = df_server.client()\n \n     res = await client.execute_command(\"ACL SETUSER george ON >pass +@transaction +@string\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"AUTH george pass\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     await client.execute_command(\"MULTI\")\n     await client.execute_command(\"SET key 44\")\n \n-    admin_client = aioredis.Redis(port=df_server.port)\n+    admin_client = df_server.client()\n     await admin_client.execute_command(\"ACL DELUSER george\")\n \n     with pytest.raises(redis.exceptions.ConnectionError):\n@@ -259,7 +259,7 @@ async def test_acl_del_user_while_running_lua_script(df_server):\n     client = aioredis.Redis(port=df_server.port)\n     await client.execute_command(\"ACL SETUSER kostas ON >kk +@string +@scripting\")\n     await client.execute_command(\"AUTH kostas kk\")\n-    admin_client = aioredis.Redis(port=df_server.port)\n+    admin_client = aioredis.Redis(port=df_server.port, decode_responses=True)\n \n     with pytest.raises(redis.exceptions.ConnectionError):\n         await asyncio.gather(\n@@ -269,7 +269,7 @@ async def test_acl_del_user_while_running_lua_script(df_server):\n \n     for i in range(1, 4):\n         res = await admin_client.get(f\"key{i}\")\n-        assert res == b\"100000\"\n+        assert res == \"100000\"\n \n     await admin_client.close()\n \n@@ -280,7 +280,7 @@ async def test_acl_with_long_running_script(df_server):\n     client = aioredis.Redis(port=df_server.port)\n     await client.execute_command(\"ACL SETUSER roman ON >yoman +@string +@scripting\")\n     await client.execute_command(\"AUTH roman yoman\")\n-    admin_client = aioredis.Redis(port=df_server.port)\n+    admin_client = aioredis.Redis(port=df_server.port, decode_responses=True)\n \n     await asyncio.gather(\n         client.eval(script, 4, \"key\", \"key1\", \"key2\", \"key3\"),\n@@ -289,7 +289,7 @@ async def test_acl_with_long_running_script(df_server):\n \n     for i in range(1, 4):\n         res = await admin_client.get(f\"key{i}\")\n-        assert res == b\"100000\"\n+        assert res == \"100000\"\n \n     await client.close()\n     await admin_client.close()\n@@ -437,22 +437,22 @@ async def test_require_pass(df_factory):\n     with pytest.raises(redis.exceptions.AuthenticationError):\n         await client.execute_command(\"AUTH default wrongpass\")\n \n-    client = aioredis.Redis(password=\"mypass\", port=df.port)\n+    client = aioredis.Redis(password=\"mypass\", port=df.port, decode_responses=True)\n \n     res = await client.execute_command(\"AUTH default mypass\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"CONFIG SET requirepass newpass\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n     res = await client.execute_command(\"AUTH default newpass\")\n-    assert res == b\"OK\"\n+    assert res == \"OK\"\n \n-    client = aioredis.Redis(password=\"newpass\", port=df.admin_port)\n+    client = aioredis.Redis(password=\"newpass\", port=df.admin_port, decode_responses=True)\n \n     await client.execute_command(\"SET foo 44\")\n     res = await client.execute_command(\"GET foo\")\n-    assert res == b\"44\"\n+    assert res == \"44\"\n \n     await client.close()\n \n@@ -568,54 +568,71 @@ async def test_acl_keys(async_client):\n \n \n @pytest.mark.asyncio\n-async def test_namespaces(df_factory):\n-    df = df_factory.create()\n-    df.start()\n-\n-    admin = aioredis.Redis(port=df.port)\n-    assert await admin.execute_command(\"SET foo admin\") == b\"OK\"\n-    assert await admin.execute_command(\"GET foo\") == b\"admin\"\n+async def test_namespaces(df_server):\n+    admin = df_server.client()\n+    assert await admin.execute_command(\"SET foo admin\") == \"OK\"\n+    assert await admin.execute_command(\"GET foo\") == \"admin\"\n \n     # Create ns space named 'ns1'\n     await admin.execute_command(\"ACL SETUSER adi NAMESPACE:ns1 ON >adi_pass +@all ~*\")\n \n-    adi = aioredis.Redis(port=df.port)\n-    assert await adi.execute_command(\"AUTH adi adi_pass\") == b\"OK\"\n-    assert await adi.execute_command(\"SET foo bar\") == b\"OK\"\n-    assert await adi.execute_command(\"GET foo\") == b\"bar\"\n-    assert await admin.execute_command(\"GET foo\") == b\"admin\"\n+    adi = df_server.client()\n+    assert await adi.execute_command(\"AUTH adi adi_pass\") == \"OK\"\n+    assert await adi.execute_command(\"SET foo bar\") == \"OK\"\n+    assert await adi.execute_command(\"GET foo\") == \"bar\"\n+    assert await admin.execute_command(\"GET foo\") == \"admin\"\n \n     # Adi and Shahar are on the same team\n     await admin.execute_command(\"ACL SETUSER shahar NAMESPACE:ns1 ON >shahar_pass +@all ~*\")\n \n-    shahar = aioredis.Redis(port=df.port)\n-    assert await shahar.execute_command(\"AUTH shahar shahar_pass\") == b\"OK\"\n-    assert await shahar.execute_command(\"GET foo\") == b\"bar\"\n-    assert await shahar.execute_command(\"SET foo bar2\") == b\"OK\"\n-    assert await adi.execute_command(\"GET foo\") == b\"bar2\"\n+    shahar = df_server.client()\n+    assert await shahar.execute_command(\"AUTH shahar shahar_pass\") == \"OK\"\n+    assert await shahar.execute_command(\"GET foo\") == \"bar\"\n+    assert await shahar.execute_command(\"SET foo bar2\") == \"OK\"\n+    assert await adi.execute_command(\"GET foo\") == \"bar2\"\n \n     # Roman is a CTO, he has his own private space\n     await admin.execute_command(\"ACL SETUSER roman NAMESPACE:ns2 ON >roman_pass +@all ~*\")\n \n-    roman = aioredis.Redis(port=df.port)\n-    assert await roman.execute_command(\"AUTH roman roman_pass\") == b\"OK\"\n+    roman = df_server.client()\n+    assert await roman.execute_command(\"AUTH roman roman_pass\") == \"OK\"\n     assert await roman.execute_command(\"GET foo\") == None\n \n     await close_clients(admin, adi, shahar, roman)\n \n \n @pytest.mark.asyncio\n-async def default_user_bug(df_factory):\n-    df.start()\n-\n-    client = aioredis.Redis(port=df.port)\n+async def test_default_user_bug(df_server):\n+    client = df_server.client()\n \n-    await async_client.execute_command(\"ACL SETUSER default -@all\")\n+    await client.execute_command(\"ACL SETUSER default -@all\")\n     await client.close()\n \n-    client = aioredis.Redis(port=df.port)\n+    client = df_server.client()\n \n     with pytest.raises(redis.exceptions.ResponseError):\n         await client.execute_command(\"SET foo bar\")\n \n     await client.close()\n+\n+\n+@pytest.mark.asyncio\n+async def test_auth_resp3_bug(df_factory):\n+    df = df_factory.create()\n+    df.start()\n+\n+    client = aioredis.Redis(port=df.port, protocol=3, decode_responses=True)\n+\n+    await client.execute_command(\"ACL SETUSER kostas +@all ON >tmp\")\n+    res = await client.execute_command(\"HELLO 3 AUTH kostas tmp\")\n+    assert res == {\n+        \"server\": \"redis\",\n+        \"version\": \"6.2.11\",\n+        \"dragonfly_version\": \"df-dev\",\n+        \"proto\": 3,\n+        \"id\": 1,\n+        \"mode\": \"standalone\",\n+        \"role\": \"master\",\n+    }\n+\n+    await client.close()\ndiff --git a/tests/dragonfly/requirements.txt b/tests/dragonfly/requirements.txt\nindex 185537b9b5c9..58e9861d3d1f 100644\n--- a/tests/dragonfly/requirements.txt\n+++ b/tests/dragonfly/requirements.txt\n@@ -7,7 +7,7 @@ pluggy==1.0.0\n py==1.11.0\n pyparsing==3.0.9\n pytest==7.1.2\n-redis==4.6.0\n+redis==5.0.0\n tomli==2.0.1\n wrapt==1.14.1\n pytest-asyncio==0.20.1\ndiff --git a/tests/dragonfly/tls_conf_test.py b/tests/dragonfly/tls_conf_test.py\nindex 86cd2da02f6f..e7eba74b41db 100644\n--- a/tests/dragonfly/tls_conf_test.py\n+++ b/tests/dragonfly/tls_conf_test.py\n@@ -141,7 +141,7 @@ async def test_config_enable_tls(\n             await client.ping()\n \n         # Connecting without TLS should fail.\n-        with pytest.raises(redis.exceptions.ResponseError):\n+        with pytest.raises(redis.exceptions.ConnectionError):\n             async with server.client() as client_unauth:\n                 await client_unauth.ping()\n \n",
  "problem_statement": "Inability to Authorize Non-Default User with RESP3 Protocol by `HELLO 3 AUTH non_default_user some_pass`\n**Describe the bug**\r\nWhen attempting to connect using a non-default user and the RESP3 protocol `HELLO 3 AUTH non_default_user some_pass`, an error message is returned: \"WRONGPASS invalid username-password pair or user is disabled.\" However, the authorization succeeds when using the `AUTH` command directly without the RESP3 protocol by `AUTH non_default_user some_pass` but then using RESP2.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\nAttempt to connect as a non-default user with the RESP3 protocol\r\n```\r\n> HELLO 3 AUTH non_default_user some_pass\r\n> (error) WRONGPASS invalid username-password pair or user is disabled.\r\n```\r\n\r\nAttempt to authenticate using the non-default user without the RESP3 protocol:\r\n```\r\n> AUTH non_default_user some_pass\r\n> OK\r\n```\r\n\r\nAttempt to connect using the RESP3 protocol with the default user:\r\n```\r\n> HELLO 3 AUTH default some_default_pass\r\n> 1# \"server\" => \"redis\"\r\n...\r\n```\r\n\r\n**Expected behavior**\r\nThe non-default user should be authorized when connecting with the RESP3 protocol without encountering the WRONGPASS error as `HELLO 3 AUTH non_default_user some_pass`.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: 22.04.1-Ubuntu SMP\r\n - Kernel: 6.5.0-14-generic \r\n - Containerized: Docker (docker.dragonflydb.io/dragonflydb/dragonfly:1.21.0)\r\n - Dragonfly Version: df-v1.21.0\r\n\r\n**Reproducible Code Snippet**\r\n```\r\n# Attempt to connect with RESP3 protocol and non-default user\r\nHELLO 3 AUTH non_default_user some_pass\r\n```\r\n\r\n**Additional context**\r\nIn the source code, when using AUTH with a non-default user, the following error is sent: SendError(facade::kAuthRejected).\r\nReference: https://github.com/dragonflydb/dragonfly/blob/7b9bbc19d7df29a7b8651ed9060eb11ef883d5e0/src/server/server_family.cc#L2421\r\nIt's unclear why this behavior occurs and why documentation doesn't mention this limitation.\r\n\n",
  "hints_text": "Thanks, we will take a look\nHi @0x12th ,\r\n\r\nthank you for reporting this, I will take a look",
  "created_at": "2024-08-09T13:11:04Z",
  "modified_files": [
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "src/server/dragonfly_test.cc",
    "tests/dragonfly/acl_family_test.py",
    "tests/dragonfly/requirements.txt",
    "tests/dragonfly/tls_conf_test.py"
  ]
}