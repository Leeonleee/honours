You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
INTERVAL type missing in ListVector::Search
#### What happens?
Attempting to do a look up in a MAP using an INTERVAL value causes an exception to be thrown.
(within ListVector::Search there is no case to handle PhysicalType::INTERVAL)

#### To Reproduce
```sql
statement ok
create table interval_key as select MAP_FROM_ENTRIES(ARRAY[(('2022-01-02 01:00:00'::TIMESTAMP - '2022-01-01'::TIMESTAMP), 'x'), (('2022-01-02 01:00:00'::TIMESTAMP - '2021-01-01'::TIMESTAMP), 'y')]) col;

query I
select * from interval_key;
----
{1 day 01:00:00=x, 366 days 01:00:00=y}

query I
select col[('2022-01-02 01:00:00'::TIMESTAMP - '2022-01-01'::TIMESTAMP)] from interval_key;
----
[x]
```

The last query causes the error:
```
Actual result:
Invalid type Error: Invalid Type [LIST]: Invalid type for List Vector Search
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/common/types/vector.cpp]
1: #include "duckdb/common/types/vector.hpp"
2: 
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/assert.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/operator/comparison_operators.hpp"
7: #include "duckdb/common/pair.hpp"
8: #include "duckdb/common/printer.hpp"
9: #include "duckdb/common/serializer.hpp"
10: #include "duckdb/common/types/null_value.hpp"
11: #include "duckdb/common/types/sel_cache.hpp"
12: #include "duckdb/common/types/vector_cache.hpp"
13: #include "duckdb/common/vector_operations/vector_operations.hpp"
14: #include "duckdb/storage/buffer/buffer_handle.hpp"
15: #include "duckdb/function/scalar/nested_functions.hpp"
16: #include "duckdb/storage/string_uncompressed.hpp"
17: #include "duckdb/common/types/value.hpp"
18: #include "duckdb/common/fsst.hpp"
19: #include "fsst.h"
20: 
21: #include <cstring> // strlen() on Solaris
22: 
23: namespace duckdb {
24: 
25: Vector::Vector(LogicalType type_p, bool create_data, bool zero_data, idx_t capacity)
26:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(nullptr) {
27: 	if (create_data) {
28: 		Initialize(zero_data, capacity);
29: 	}
30: }
31: 
32: Vector::Vector(LogicalType type_p, idx_t capacity) : Vector(move(type_p), true, false, capacity) {
33: }
34: 
35: Vector::Vector(LogicalType type_p, data_ptr_t dataptr)
36:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(dataptr) {
37: 	if (dataptr && !type.IsValid()) {
38: 		throw InternalException("Cannot create a vector of type INVALID!");
39: 	}
40: }
41: 
42: Vector::Vector(const VectorCache &cache) : type(cache.GetType()) {
43: 	ResetFromCache(cache);
44: }
45: 
46: Vector::Vector(Vector &other) : type(other.type) {
47: 	Reference(other);
48: }
49: 
50: Vector::Vector(Vector &other, const SelectionVector &sel, idx_t count) : type(other.type) {
51: 	Slice(other, sel, count);
52: }
53: 
54: Vector::Vector(Vector &other, idx_t offset, idx_t end) : type(other.type) {
55: 	Slice(other, offset, end);
56: }
57: 
58: Vector::Vector(const Value &value) : type(value.type()) {
59: 	Reference(value);
60: }
61: 
62: Vector::Vector(Vector &&other) noexcept
63:     : vector_type(other.vector_type), type(move(other.type)), data(other.data), validity(move(other.validity)),
64:       buffer(move(other.buffer)), auxiliary(move(other.auxiliary)) {
65: }
66: 
67: void Vector::Reference(const Value &value) {
68: 	D_ASSERT(GetType().id() == value.type().id());
69: 	this->vector_type = VectorType::CONSTANT_VECTOR;
70: 	buffer = VectorBuffer::CreateConstantVector(value.type());
71: 	auto internal_type = value.type().InternalType();
72: 	if (internal_type == PhysicalType::STRUCT) {
73: 		auto struct_buffer = make_unique<VectorStructBuffer>();
74: 		auto &child_types = StructType::GetChildTypes(value.type());
75: 		auto &child_vectors = struct_buffer->GetChildren();
76: 		auto &value_children = StructValue::GetChildren(value);
77: 		for (idx_t i = 0; i < child_types.size(); i++) {
78: 			auto vector = make_unique<Vector>(value.IsNull() ? Value(child_types[i].second) : value_children[i]);
79: 			child_vectors.push_back(move(vector));
80: 		}
81: 		auxiliary = move(struct_buffer);
82: 		if (value.IsNull()) {
83: 			SetValue(0, value);
84: 		}
85: 	} else if (internal_type == PhysicalType::LIST) {
86: 		auto list_buffer = make_unique<VectorListBuffer>(value.type());
87: 		auxiliary = move(list_buffer);
88: 		data = buffer->GetData();
89: 		SetValue(0, value);
90: 	} else {
91: 		auxiliary.reset();
92: 		data = buffer->GetData();
93: 		SetValue(0, value);
94: 	}
95: }
96: 
97: void Vector::Reference(Vector &other) {
98: 	D_ASSERT(other.GetType() == GetType());
99: 	Reinterpret(other);
100: }
101: 
102: void Vector::ReferenceAndSetType(Vector &other) {
103: 	type = other.GetType();
104: 	Reference(other);
105: }
106: 
107: void Vector::Reinterpret(Vector &other) {
108: 	vector_type = other.vector_type;
109: 	AssignSharedPointer(buffer, other.buffer);
110: 	AssignSharedPointer(auxiliary, other.auxiliary);
111: 	data = other.data;
112: 	validity = other.validity;
113: }
114: 
115: void Vector::ResetFromCache(const VectorCache &cache) {
116: 	cache.ResetFromCache(*this);
117: }
118: 
119: void Vector::Slice(Vector &other, idx_t offset, idx_t end) {
120: 	if (other.GetVectorType() == VectorType::CONSTANT_VECTOR) {
121: 		Reference(other);
122: 		return;
123: 	}
124: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR);
125: 
126: 	auto internal_type = GetType().InternalType();
127: 	if (internal_type == PhysicalType::STRUCT) {
128: 		Vector new_vector(GetType());
129: 		auto &entries = StructVector::GetEntries(new_vector);
130: 		auto &other_entries = StructVector::GetEntries(other);
131: 		D_ASSERT(entries.size() == other_entries.size());
132: 		for (idx_t i = 0; i < entries.size(); i++) {
133: 			entries[i]->Slice(*other_entries[i], offset, end);
134: 		}
135: 		if (offset > 0) {
136: 			new_vector.validity.Slice(other.validity, offset, end);
137: 		} else {
138: 			new_vector.validity = other.validity;
139: 		}
140: 		Reference(new_vector);
141: 	} else {
142: 		Reference(other);
143: 		if (offset > 0) {
144: 			data = data + GetTypeIdSize(internal_type) * offset;
145: 			validity.Slice(other.validity, offset, end);
146: 		}
147: 	}
148: }
149: 
150: void Vector::Slice(Vector &other, const SelectionVector &sel, idx_t count) {
151: 	Reference(other);
152: 	Slice(sel, count);
153: }
154: 
155: void Vector::Slice(const SelectionVector &sel, idx_t count) {
156: 	if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
157: 		// dictionary on a constant is just a constant
158: 		return;
159: 	}
160: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
161: 		// already a dictionary, slice the current dictionary
162: 		auto &current_sel = DictionaryVector::SelVector(*this);
163: 		auto sliced_dictionary = current_sel.Slice(sel, count);
164: 		buffer = make_buffer<DictionaryBuffer>(move(sliced_dictionary));
165: 		if (GetType().InternalType() == PhysicalType::STRUCT) {
166: 			auto &child_vector = DictionaryVector::Child(*this);
167: 
168: 			Vector new_child(child_vector);
169: 			new_child.auxiliary = make_buffer<VectorStructBuffer>(new_child, sel, count);
170: 			auxiliary = make_buffer<VectorChildBuffer>(move(new_child));
171: 		}
172: 		return;
173: 	}
174: 
175: 	if (GetVectorType() == VectorType::FSST_VECTOR) {
176: 		Flatten(sel, count);
177: 		return;
178: 	}
179: 
180: 	Vector child_vector(*this);
181: 	auto internal_type = GetType().InternalType();
182: 	if (internal_type == PhysicalType::STRUCT) {
183: 		child_vector.auxiliary = make_buffer<VectorStructBuffer>(*this, sel, count);
184: 	}
185: 	auto child_ref = make_buffer<VectorChildBuffer>(move(child_vector));
186: 	auto dict_buffer = make_buffer<DictionaryBuffer>(sel);
187: 	vector_type = VectorType::DICTIONARY_VECTOR;
188: 	buffer = move(dict_buffer);
189: 	auxiliary = move(child_ref);
190: }
191: 
192: void Vector::Slice(const SelectionVector &sel, idx_t count, SelCache &cache) {
193: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR && GetType().InternalType() != PhysicalType::STRUCT) {
194: 		// dictionary vector: need to merge dictionaries
195: 		// check if we have a cached entry
196: 		auto &current_sel = DictionaryVector::SelVector(*this);
197: 		auto target_data = current_sel.data();
198: 		auto entry = cache.cache.find(target_data);
199: 		if (entry != cache.cache.end()) {
200: 			// cached entry exists: use that
201: 			this->buffer = make_buffer<DictionaryBuffer>(((DictionaryBuffer &)*entry->second).GetSelVector());
202: 			vector_type = VectorType::DICTIONARY_VECTOR;
203: 		} else {
204: 			Slice(sel, count);
205: 			cache.cache[target_data] = this->buffer;
206: 		}
207: 	} else {
208: 		Slice(sel, count);
209: 	}
210: }
211: 
212: void Vector::Initialize(bool zero_data, idx_t capacity) {
213: 	auxiliary.reset();
214: 	validity.Reset();
215: 	auto &type = GetType();
216: 	auto internal_type = type.InternalType();
217: 	if (internal_type == PhysicalType::STRUCT) {
218: 		auto struct_buffer = make_unique<VectorStructBuffer>(type, capacity);
219: 		auxiliary = move(struct_buffer);
220: 	} else if (internal_type == PhysicalType::LIST) {
221: 		auto list_buffer = make_unique<VectorListBuffer>(type, capacity);
222: 		auxiliary = move(list_buffer);
223: 	}
224: 	auto type_size = GetTypeIdSize(internal_type);
225: 	if (type_size > 0) {
226: 		buffer = VectorBuffer::CreateStandardVector(type, capacity);
227: 		data = buffer->GetData();
228: 		if (zero_data) {
229: 			memset(data, 0, capacity * type_size);
230: 		}
231: 	}
232: 	if (capacity > STANDARD_VECTOR_SIZE) {
233: 		validity.Resize(STANDARD_VECTOR_SIZE, capacity);
234: 	}
235: }
236: 
237: struct DataArrays {
238: 	Vector &vec;
239: 	data_ptr_t data;
240: 	VectorBuffer *buffer;
241: 	idx_t type_size;
242: 	bool is_nested;
243: 	DataArrays(Vector &vec, data_ptr_t data, VectorBuffer *buffer, idx_t type_size, bool is_nested)
244: 	    : vec(vec), data(data), buffer(buffer), type_size(type_size), is_nested(is_nested) {};
245: };
246: 
247: void FindChildren(std::vector<DataArrays> &to_resize, VectorBuffer &auxiliary) {
248: 	if (auxiliary.GetBufferType() == VectorBufferType::LIST_BUFFER) {
249: 		auto &buffer = (VectorListBuffer &)auxiliary;
250: 		auto &child = buffer.GetChild();
251: 		auto data = child.GetData();
252: 		if (!data) {
253: 			//! Nested type
254: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
255: 			                  true);
256: 			to_resize.emplace_back(arrays);
257: 			FindChildren(to_resize, *child.GetAuxiliary());
258: 		} else {
259: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
260: 			                  false);
261: 			to_resize.emplace_back(arrays);
262: 		}
263: 	} else if (auxiliary.GetBufferType() == VectorBufferType::STRUCT_BUFFER) {
264: 		auto &buffer = (VectorStructBuffer &)auxiliary;
265: 		auto &children = buffer.GetChildren();
266: 		for (auto &child : children) {
267: 			auto data = child->GetData();
268: 			if (!data) {
269: 				//! Nested type
270: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
271: 				                  GetTypeIdSize(child->GetType().InternalType()), true);
272: 				to_resize.emplace_back(arrays);
273: 				FindChildren(to_resize, *child->GetAuxiliary());
274: 			} else {
275: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
276: 				                  GetTypeIdSize(child->GetType().InternalType()), false);
277: 				to_resize.emplace_back(arrays);
278: 			}
279: 		}
280: 	}
281: }
282: void Vector::Resize(idx_t cur_size, idx_t new_size) {
283: 	std::vector<DataArrays> to_resize;
284: 	if (!buffer) {
285: 		buffer = make_unique<VectorBuffer>(0);
286: 	}
287: 	if (!data) {
288: 		//! this is a nested structure
289: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), true);
290: 		to_resize.emplace_back(arrays);
291: 		FindChildren(to_resize, *auxiliary);
292: 	} else {
293: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), false);
294: 		to_resize.emplace_back(arrays);
295: 	}
296: 	for (auto &data_to_resize : to_resize) {
297: 		if (!data_to_resize.is_nested) {
298: 			auto new_data = unique_ptr<data_t[]>(new data_t[new_size * data_to_resize.type_size]);
299: 			memcpy(new_data.get(), data_to_resize.data, cur_size * data_to_resize.type_size * sizeof(data_t));
300: 			data_to_resize.buffer->SetData(move(new_data));
301: 			data_to_resize.vec.data = data_to_resize.buffer->GetData();
302: 		}
303: 		data_to_resize.vec.validity.Resize(cur_size, new_size);
304: 	}
305: }
306: 
307: void Vector::SetValue(idx_t index, const Value &val) {
308: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
309: 		// dictionary: apply dictionary and forward to child
310: 		auto &sel_vector = DictionaryVector::SelVector(*this);
311: 		auto &child = DictionaryVector::Child(*this);
312: 		return child.SetValue(sel_vector.get_index(index), val);
313: 	}
314: 	if (val.type() != GetType()) {
315: 		SetValue(index, val.DefaultCastAs(GetType()));
316: 		return;
317: 	}
318: 	D_ASSERT(val.type().InternalType() == GetType().InternalType());
319: 
320: 	validity.EnsureWritable();
321: 	validity.Set(index, !val.IsNull());
322: 	if (val.IsNull() && GetType().InternalType() != PhysicalType::STRUCT) {
323: 		// for structs we still need to set the child-entries to NULL
324: 		// so we do not bail out yet
325: 		return;
326: 	}
327: 
328: 	switch (GetType().InternalType()) {
329: 	case PhysicalType::BOOL:
330: 		((bool *)data)[index] = val.GetValueUnsafe<bool>();
331: 		break;
332: 	case PhysicalType::INT8:
333: 		((int8_t *)data)[index] = val.GetValueUnsafe<int8_t>();
334: 		break;
335: 	case PhysicalType::INT16:
336: 		((int16_t *)data)[index] = val.GetValueUnsafe<int16_t>();
337: 		break;
338: 	case PhysicalType::INT32:
339: 		((int32_t *)data)[index] = val.GetValueUnsafe<int32_t>();
340: 		break;
341: 	case PhysicalType::INT64:
342: 		((int64_t *)data)[index] = val.GetValueUnsafe<int64_t>();
343: 		break;
344: 	case PhysicalType::INT128:
345: 		((hugeint_t *)data)[index] = val.GetValueUnsafe<hugeint_t>();
346: 		break;
347: 	case PhysicalType::UINT8:
348: 		((uint8_t *)data)[index] = val.GetValueUnsafe<uint8_t>();
349: 		break;
350: 	case PhysicalType::UINT16:
351: 		((uint16_t *)data)[index] = val.GetValueUnsafe<uint16_t>();
352: 		break;
353: 	case PhysicalType::UINT32:
354: 		((uint32_t *)data)[index] = val.GetValueUnsafe<uint32_t>();
355: 		break;
356: 	case PhysicalType::UINT64:
357: 		((uint64_t *)data)[index] = val.GetValueUnsafe<uint64_t>();
358: 		break;
359: 	case PhysicalType::FLOAT:
360: 		((float *)data)[index] = val.GetValueUnsafe<float>();
361: 		break;
362: 	case PhysicalType::DOUBLE:
363: 		((double *)data)[index] = val.GetValueUnsafe<double>();
364: 		break;
365: 	case PhysicalType::INTERVAL:
366: 		((interval_t *)data)[index] = val.GetValueUnsafe<interval_t>();
367: 		break;
368: 	case PhysicalType::VARCHAR:
369: 		((string_t *)data)[index] = StringVector::AddStringOrBlob(*this, StringValue::Get(val));
370: 		break;
371: 	case PhysicalType::STRUCT: {
372: 		D_ASSERT(GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR);
373: 
374: 		auto &children = StructVector::GetEntries(*this);
375: 		auto &val_children = StructValue::GetChildren(val);
376: 		D_ASSERT(val.IsNull() || children.size() == val_children.size());
377: 		for (size_t i = 0; i < children.size(); i++) {
378: 			auto &vec_child = children[i];
379: 			if (!val.IsNull()) {
380: 				auto &struct_child = val_children[i];
381: 				vec_child->SetValue(index, struct_child);
382: 			} else {
383: 				vec_child->SetValue(index, Value());
384: 			}
385: 		}
386: 		break;
387: 	}
388: 	case PhysicalType::LIST: {
389: 		auto offset = ListVector::GetListSize(*this);
390: 		auto &val_children = ListValue::GetChildren(val);
391: 		if (!val_children.empty()) {
392: 			for (idx_t i = 0; i < val_children.size(); i++) {
393: 				ListVector::PushBack(*this, val_children[i]);
394: 			}
395: 		}
396: 		//! now set the pointer
397: 		auto &entry = ((list_entry_t *)data)[index];
398: 		entry.length = val_children.size();
399: 		entry.offset = offset;
400: 		break;
401: 	}
402: 	default:
403: 		throw InternalException("Unimplemented type for Vector::SetValue");
404: 	}
405: }
406: 
407: Value Vector::GetValueInternal(const Vector &v_p, idx_t index_p) {
408: 	const Vector *vector = &v_p;
409: 	idx_t index = index_p;
410: 	bool finished = false;
411: 	while (!finished) {
412: 		switch (vector->GetVectorType()) {
413: 		case VectorType::CONSTANT_VECTOR:
414: 			index = 0;
415: 			finished = true;
416: 			break;
417: 		case VectorType::FLAT_VECTOR:
418: 			finished = true;
419: 			break;
420: 		case VectorType::FSST_VECTOR:
421: 			finished = true;
422: 			break;
423: 		// dictionary: apply dictionary and forward to child
424: 		case VectorType::DICTIONARY_VECTOR: {
425: 			auto &sel_vector = DictionaryVector::SelVector(*vector);
426: 			auto &child = DictionaryVector::Child(*vector);
427: 			vector = &child;
428: 			index = sel_vector.get_index(index);
429: 			break;
430: 		}
431: 		case VectorType::SEQUENCE_VECTOR: {
432: 			int64_t start, increment;
433: 			SequenceVector::GetSequence(*vector, start, increment);
434: 			return Value::Numeric(vector->GetType(), start + increment * index);
435: 		}
436: 		default:
437: 			throw InternalException("Unimplemented vector type for Vector::GetValue");
438: 		}
439: 	}
440: 	auto data = vector->data;
441: 	auto &validity = vector->validity;
442: 	auto &type = vector->GetType();
443: 
444: 	if (!validity.RowIsValid(index)) {
445: 		return Value(vector->GetType());
446: 	}
447: 
448: 	if (vector->GetVectorType() == VectorType::FSST_VECTOR) {
449: 		if (vector->GetType().InternalType() != PhysicalType::VARCHAR) {
450: 			throw InternalException("FSST Vector with non-string datatype found!");
451: 		}
452: 		auto str_compressed = ((string_t *)data)[index];
453: 		Value result =
454: 		    FSSTPrimitives::DecompressValue(FSSTVector::GetDecoder(const_cast<Vector &>(*vector)),
455: 		                                    (unsigned char *)str_compressed.GetDataUnsafe(), str_compressed.GetSize());
456: 		return result;
457: 	}
458: 
459: 	switch (vector->GetType().id()) {
460: 	case LogicalTypeId::BOOLEAN:
461: 		return Value::BOOLEAN(((bool *)data)[index]);
462: 	case LogicalTypeId::TINYINT:
463: 		return Value::TINYINT(((int8_t *)data)[index]);
464: 	case LogicalTypeId::SMALLINT:
465: 		return Value::SMALLINT(((int16_t *)data)[index]);
466: 	case LogicalTypeId::INTEGER:
467: 		return Value::INTEGER(((int32_t *)data)[index]);
468: 	case LogicalTypeId::DATE:
469: 		return Value::DATE(((date_t *)data)[index]);
470: 	case LogicalTypeId::TIME:
471: 		return Value::TIME(((dtime_t *)data)[index]);
472: 	case LogicalTypeId::TIME_TZ:
473: 		return Value::TIMETZ(((dtime_t *)data)[index]);
474: 	case LogicalTypeId::BIGINT:
475: 		return Value::BIGINT(((int64_t *)data)[index]);
476: 	case LogicalTypeId::UTINYINT:
477: 		return Value::UTINYINT(((uint8_t *)data)[index]);
478: 	case LogicalTypeId::USMALLINT:
479: 		return Value::USMALLINT(((uint16_t *)data)[index]);
480: 	case LogicalTypeId::UINTEGER:
481: 		return Value::UINTEGER(((uint32_t *)data)[index]);
482: 	case LogicalTypeId::UBIGINT:
483: 		return Value::UBIGINT(((uint64_t *)data)[index]);
484: 	case LogicalTypeId::TIMESTAMP:
485: 		return Value::TIMESTAMP(((timestamp_t *)data)[index]);
486: 	case LogicalTypeId::TIMESTAMP_NS:
487: 		return Value::TIMESTAMPNS(((timestamp_t *)data)[index]);
488: 	case LogicalTypeId::TIMESTAMP_MS:
489: 		return Value::TIMESTAMPMS(((timestamp_t *)data)[index]);
490: 	case LogicalTypeId::TIMESTAMP_SEC:
491: 		return Value::TIMESTAMPSEC(((timestamp_t *)data)[index]);
492: 	case LogicalTypeId::TIMESTAMP_TZ:
493: 		return Value::TIMESTAMPTZ(((timestamp_t *)data)[index]);
494: 	case LogicalTypeId::HUGEINT:
495: 		return Value::HUGEINT(((hugeint_t *)data)[index]);
496: 	case LogicalTypeId::UUID:
497: 		return Value::UUID(((hugeint_t *)data)[index]);
498: 	case LogicalTypeId::DECIMAL: {
499: 		auto width = DecimalType::GetWidth(type);
500: 		auto scale = DecimalType::GetScale(type);
501: 		switch (type.InternalType()) {
502: 		case PhysicalType::INT16:
503: 			return Value::DECIMAL(((int16_t *)data)[index], width, scale);
504: 		case PhysicalType::INT32:
505: 			return Value::DECIMAL(((int32_t *)data)[index], width, scale);
506: 		case PhysicalType::INT64:
507: 			return Value::DECIMAL(((int64_t *)data)[index], width, scale);
508: 		case PhysicalType::INT128:
509: 			return Value::DECIMAL(((hugeint_t *)data)[index], width, scale);
510: 		default:
511: 			throw InternalException("Physical type '%s' has a width bigger than 38, which is not supported",
512: 			                        TypeIdToString(type.InternalType()));
513: 		}
514: 	}
515: 	case LogicalTypeId::ENUM: {
516: 		switch (type.InternalType()) {
517: 		case PhysicalType::UINT8:
518: 			return Value::ENUM(((uint8_t *)data)[index], type);
519: 		case PhysicalType::UINT16:
520: 			return Value::ENUM(((uint16_t *)data)[index], type);
521: 		case PhysicalType::UINT32:
522: 			return Value::ENUM(((uint32_t *)data)[index], type);
523: 		default:
524: 			throw InternalException("ENUM can only have unsigned integers as physical types");
525: 		}
526: 	}
527: 	case LogicalTypeId::POINTER:
528: 		return Value::POINTER(((uintptr_t *)data)[index]);
529: 	case LogicalTypeId::FLOAT:
530: 		return Value::FLOAT(((float *)data)[index]);
531: 	case LogicalTypeId::DOUBLE:
532: 		return Value::DOUBLE(((double *)data)[index]);
533: 	case LogicalTypeId::INTERVAL:
534: 		return Value::INTERVAL(((interval_t *)data)[index]);
535: 	case LogicalTypeId::VARCHAR: {
536: 		auto str = ((string_t *)data)[index];
537: 		return Value(str.GetString());
538: 	}
539: 	case LogicalTypeId::JSON: {
540: 		auto str = ((string_t *)data)[index];
541: 		return Value::JSON(str.GetString());
542: 	}
543: 	case LogicalTypeId::AGGREGATE_STATE:
544: 	case LogicalTypeId::BLOB: {
545: 		auto str = ((string_t *)data)[index];
546: 		return Value::BLOB((const_data_ptr_t)str.GetDataUnsafe(), str.GetSize());
547: 	}
548: 	case LogicalTypeId::MAP: {
549: 		auto &child_entries = StructVector::GetEntries(*vector);
550: 		Value key = child_entries[0]->GetValue(index);
551: 		Value value = child_entries[1]->GetValue(index);
552: 		return Value::MAP(move(key), move(value));
553: 	}
554: 	case LogicalTypeId::UNION: {
555: 		auto tag = UnionVector::GetTag(*vector, index);
556: 		auto value = UnionVector::GetMember(*vector, tag).GetValue(index);
557: 		auto members = UnionType::CopyMemberTypes(type);
558: 		return Value::UNION(members, tag, move(value));
559: 	}
560: 	case LogicalTypeId::STRUCT: {
561: 		// we can derive the value schema from the vector schema
562: 		auto &child_entries = StructVector::GetEntries(*vector);
563: 		child_list_t<Value> children;
564: 		for (idx_t child_idx = 0; child_idx < child_entries.size(); child_idx++) {
565: 			auto &struct_child = child_entries[child_idx];
566: 			children.push_back(make_pair(StructType::GetChildName(type, child_idx), struct_child->GetValue(index_p)));
567: 		}
568: 		return Value::STRUCT(move(children));
569: 	}
570: 	case LogicalTypeId::LIST: {
571: 		auto offlen = ((list_entry_t *)data)[index];
572: 		auto &child_vec = ListVector::GetEntry(*vector);
573: 		std::vector<Value> children;
574: 		for (idx_t i = offlen.offset; i < offlen.offset + offlen.length; i++) {
575: 			children.push_back(child_vec.GetValue(i));
576: 		}
577: 		return Value::LIST(ListType::GetChildType(type), move(children));
578: 	}
579: 	default:
580: 		throw InternalException("Unimplemented type for value access");
581: 	}
582: }
583: 
584: Value Vector::GetValue(const Vector &v_p, idx_t index_p) {
585: 	auto value = GetValueInternal(v_p, index_p);
586: 	// set the alias of the type to the correct value, if there is a type alias
587: 	if (v_p.GetType().HasAlias()) {
588: 		value.type().CopyAuxInfo(v_p.GetType());
589: 	}
590: 	if (v_p.GetType().id() != LogicalTypeId::AGGREGATE_STATE && value.type().id() != LogicalTypeId::AGGREGATE_STATE) {
591: 		D_ASSERT(v_p.GetType() == value.type());
592: 	}
593: 	return value;
594: }
595: 
596: Value Vector::GetValue(idx_t index) const {
597: 	return GetValue(*this, index);
598: }
599: 
600: // LCOV_EXCL_START
601: string VectorTypeToString(VectorType type) {
602: 	switch (type) {
603: 	case VectorType::FLAT_VECTOR:
604: 		return "FLAT";
605: 	case VectorType::FSST_VECTOR:
606: 		return "FSST";
607: 	case VectorType::SEQUENCE_VECTOR:
608: 		return "SEQUENCE";
609: 	case VectorType::DICTIONARY_VECTOR:
610: 		return "DICTIONARY";
611: 	case VectorType::CONSTANT_VECTOR:
612: 		return "CONSTANT";
613: 	default:
614: 		return "UNKNOWN";
615: 	}
616: }
617: 
618: string Vector::ToString(idx_t count) const {
619: 	string retval =
620: 	    VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": " + to_string(count) + " = [ ";
621: 	switch (GetVectorType()) {
622: 	case VectorType::FLAT_VECTOR:
623: 	case VectorType::DICTIONARY_VECTOR:
624: 		for (idx_t i = 0; i < count; i++) {
625: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
626: 		}
627: 		break;
628: 	case VectorType::FSST_VECTOR: {
629: 		for (idx_t i = 0; i < count; i++) {
630: 			string_t compressed_string = ((string_t *)data)[i];
631: 			Value val = FSSTPrimitives::DecompressValue(FSSTVector::GetDecoder(const_cast<Vector &>(*this)),
632: 			                                            (unsigned char *)compressed_string.GetDataUnsafe(),
633: 			                                            compressed_string.GetSize());
634: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
635: 		}
636: 	} break;
637: 	case VectorType::CONSTANT_VECTOR:
638: 		retval += GetValue(0).ToString();
639: 		break;
640: 	case VectorType::SEQUENCE_VECTOR: {
641: 		int64_t start, increment;
642: 		SequenceVector::GetSequence(*this, start, increment);
643: 		for (idx_t i = 0; i < count; i++) {
644: 			retval += to_string(start + increment * i) + (i == count - 1 ? "" : ", ");
645: 		}
646: 		break;
647: 	}
648: 	default:
649: 		retval += "UNKNOWN VECTOR TYPE";
650: 		break;
651: 	}
652: 	retval += "]";
653: 	return retval;
654: }
655: 
656: void Vector::Print(idx_t count) {
657: 	Printer::Print(ToString(count));
658: }
659: 
660: string Vector::ToString() const {
661: 	string retval = VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": (UNKNOWN COUNT) [ ";
662: 	switch (GetVectorType()) {
663: 	case VectorType::FLAT_VECTOR:
664: 	case VectorType::DICTIONARY_VECTOR:
665: 		break;
666: 	case VectorType::CONSTANT_VECTOR:
667: 		retval += GetValue(0).ToString();
668: 		break;
669: 	case VectorType::SEQUENCE_VECTOR: {
670: 		break;
671: 	}
672: 	default:
673: 		retval += "UNKNOWN VECTOR TYPE";
674: 		break;
675: 	}
676: 	retval += "]";
677: 	return retval;
678: }
679: 
680: void Vector::Print() {
681: 	Printer::Print(ToString());
682: }
683: // LCOV_EXCL_STOP
684: 
685: template <class T>
686: static void TemplatedFlattenConstantVector(data_ptr_t data, data_ptr_t old_data, idx_t count) {
687: 	auto constant = Load<T>(old_data);
688: 	auto output = (T *)data;
689: 	for (idx_t i = 0; i < count; i++) {
690: 		output[i] = constant;
691: 	}
692: }
693: 
694: void Vector::Flatten(idx_t count) {
695: 	switch (GetVectorType()) {
696: 	case VectorType::FLAT_VECTOR:
697: 		// already a flat vector
698: 		break;
699: 	case VectorType::FSST_VECTOR: {
700: 		// Even though count may only be a part of the vector, we need to flatten the whole thing due to the way
701: 		// ToUnifiedFormat uses flatten
702: 		idx_t total_count = FSSTVector::GetCount(*this);
703: 		// create vector to decompress into
704: 		Vector other(GetType(), total_count);
705: 		// now copy the data of this vector to the other vector, decompressing the strings in the process
706: 		VectorOperations::Copy(*this, other, total_count, 0, 0);
707: 		// create a reference to the data in the other vector
708: 		this->Reference(other);
709: 		break;
710: 	}
711: 	case VectorType::DICTIONARY_VECTOR: {
712: 		// create a new flat vector of this type
713: 		Vector other(GetType(), count);
714: 		// now copy the data of this vector to the other vector, removing the selection vector in the process
715: 		VectorOperations::Copy(*this, other, count, 0, 0);
716: 		// create a reference to the data in the other vector
717: 		this->Reference(other);
718: 		break;
719: 	}
720: 	case VectorType::CONSTANT_VECTOR: {
721: 		bool is_null = ConstantVector::IsNull(*this);
722: 		// allocate a new buffer for the vector
723: 		auto old_buffer = move(buffer);
724: 		auto old_data = data;
725: 		buffer = VectorBuffer::CreateStandardVector(type, MaxValue<idx_t>(STANDARD_VECTOR_SIZE, count));
726: 		data = buffer->GetData();
727: 		vector_type = VectorType::FLAT_VECTOR;
728: 		if (is_null) {
729: 			// constant NULL, set nullmask
730: 			validity.EnsureWritable();
731: 			validity.SetAllInvalid(count);
732: 			return;
733: 		}
734: 		// non-null constant: have to repeat the constant
735: 		switch (GetType().InternalType()) {
736: 		case PhysicalType::BOOL:
737: 			TemplatedFlattenConstantVector<bool>(data, old_data, count);
738: 			break;
739: 		case PhysicalType::INT8:
740: 			TemplatedFlattenConstantVector<int8_t>(data, old_data, count);
741: 			break;
742: 		case PhysicalType::INT16:
743: 			TemplatedFlattenConstantVector<int16_t>(data, old_data, count);
744: 			break;
745: 		case PhysicalType::INT32:
746: 			TemplatedFlattenConstantVector<int32_t>(data, old_data, count);
747: 			break;
748: 		case PhysicalType::INT64:
749: 			TemplatedFlattenConstantVector<int64_t>(data, old_data, count);
750: 			break;
751: 		case PhysicalType::UINT8:
752: 			TemplatedFlattenConstantVector<uint8_t>(data, old_data, count);
753: 			break;
754: 		case PhysicalType::UINT16:
755: 			TemplatedFlattenConstantVector<uint16_t>(data, old_data, count);
756: 			break;
757: 		case PhysicalType::UINT32:
758: 			TemplatedFlattenConstantVector<uint32_t>(data, old_data, count);
759: 			break;
760: 		case PhysicalType::UINT64:
761: 			TemplatedFlattenConstantVector<uint64_t>(data, old_data, count);
762: 			break;
763: 		case PhysicalType::INT128:
764: 			TemplatedFlattenConstantVector<hugeint_t>(data, old_data, count);
765: 			break;
766: 		case PhysicalType::FLOAT:
767: 			TemplatedFlattenConstantVector<float>(data, old_data, count);
768: 			break;
769: 		case PhysicalType::DOUBLE:
770: 			TemplatedFlattenConstantVector<double>(data, old_data, count);
771: 			break;
772: 		case PhysicalType::INTERVAL:
773: 			TemplatedFlattenConstantVector<interval_t>(data, old_data, count);
774: 			break;
775: 		case PhysicalType::VARCHAR:
776: 			TemplatedFlattenConstantVector<string_t>(data, old_data, count);
777: 			break;
778: 		case PhysicalType::LIST: {
779: 			TemplatedFlattenConstantVector<list_entry_t>(data, old_data, count);
780: 			break;
781: 		}
782: 		case PhysicalType::STRUCT: {
783: 			auto normalified_buffer = make_unique<VectorStructBuffer>();
784: 
785: 			auto &new_children = normalified_buffer->GetChildren();
786: 
787: 			auto &child_entries = StructVector::GetEntries(*this);
788: 			for (auto &child : child_entries) {
789: 				D_ASSERT(child->GetVectorType() == VectorType::CONSTANT_VECTOR);
790: 				auto vector = make_unique<Vector>(*child);
791: 				vector->Flatten(count);
792: 				new_children.push_back(move(vector));
793: 			}
794: 			auxiliary = move(normalified_buffer);
795: 		} break;
796: 		default:
797: 			throw InternalException("Unimplemented type for VectorOperations::Flatten");
798: 		}
799: 		break;
800: 	}
801: 	case VectorType::SEQUENCE_VECTOR: {
802: 		int64_t start, increment, sequence_count;
803: 		SequenceVector::GetSequence(*this, start, increment, sequence_count);
804: 
805: 		buffer = VectorBuffer::CreateStandardVector(GetType());
806: 		data = buffer->GetData();
807: 		VectorOperations::GenerateSequence(*this, sequence_count, start, increment);
808: 		break;
809: 	}
810: 	default:
811: 		throw InternalException("Unimplemented type for normalify");
812: 	}
813: }
814: 
815: void Vector::Flatten(const SelectionVector &sel, idx_t count) {
816: 	switch (GetVectorType()) {
817: 	case VectorType::FLAT_VECTOR:
818: 		// already a flat vector
819: 		break;
820: 	case VectorType::FSST_VECTOR: {
821: 		// create a new flat vector of this type
822: 		Vector other(GetType());
823: 		// copy the data of this vector to the other vector, removing compression and selection vector in the process
824: 		VectorOperations::Copy(*this, other, sel, count, 0, 0);
825: 		// create a reference to the data in the other vector
826: 		this->Reference(other);
827: 		break;
828: 	}
829: 	case VectorType::SEQUENCE_VECTOR: {
830: 		int64_t start, increment;
831: 		SequenceVector::GetSequence(*this, start, increment);
832: 
833: 		buffer = VectorBuffer::CreateStandardVector(GetType());
834: 		data = buffer->GetData();
835: 		VectorOperations::GenerateSequence(*this, count, sel, start, increment);
836: 		break;
837: 	}
838: 	default:
839: 		throw InternalException("Unimplemented type for normalify with selection vector");
840: 	}
841: }
842: 
843: void Vector::ToUnifiedFormat(idx_t count, UnifiedVectorFormat &data) {
844: 	switch (GetVectorType()) {
845: 	case VectorType::DICTIONARY_VECTOR: {
846: 		auto &sel = DictionaryVector::SelVector(*this);
847: 		auto &child = DictionaryVector::Child(*this);
848: 		if (child.GetVectorType() == VectorType::FLAT_VECTOR) {
849: 			data.sel = &sel;
850: 			data.data = FlatVector::GetData(child);
851: 			data.validity = FlatVector::Validity(child);
852: 		} else {
853: 			// dictionary with non-flat child: create a new reference to the child and normalify it
854: 			Vector child_vector(child);
855: 			child_vector.Flatten(sel, count);
856: 			auto new_aux = make_buffer<VectorChildBuffer>(move(child_vector));
857: 
858: 			data.sel = &sel;
859: 			data.data = FlatVector::GetData(new_aux->data);
860: 			data.validity = FlatVector::Validity(new_aux->data);
861: 			this->auxiliary = move(new_aux);
862: 		}
863: 		break;
864: 	}
865: 	case VectorType::CONSTANT_VECTOR:
866: 		data.sel = ConstantVector::ZeroSelectionVector(count, data.owned_sel);
867: 		data.data = ConstantVector::GetData(*this);
868: 		data.validity = ConstantVector::Validity(*this);
869: 		break;
870: 	default:
871: 		Flatten(count);
872: 		data.sel = FlatVector::IncrementalSelectionVector();
873: 		data.data = FlatVector::GetData(*this);
874: 		data.validity = FlatVector::Validity(*this);
875: 		break;
876: 	}
877: }
878: 
879: void Vector::Sequence(int64_t start, int64_t increment, idx_t count) {
880: 	this->vector_type = VectorType::SEQUENCE_VECTOR;
881: 	this->buffer = make_buffer<VectorBuffer>(sizeof(int64_t) * 3);
882: 	auto data = (int64_t *)buffer->GetData();
883: 	data[0] = start;
884: 	data[1] = increment;
885: 	data[2] = int64_t(count);
886: 	validity.Reset();
887: 	auxiliary.reset();
888: }
889: 
890: void Vector::Serialize(idx_t count, Serializer &serializer) {
891: 	auto &type = GetType();
892: 
893: 	UnifiedVectorFormat vdata;
894: 	ToUnifiedFormat(count, vdata);
895: 
896: 	const auto write_validity = (count > 0) && !vdata.validity.AllValid();
897: 	serializer.Write<bool>(write_validity);
898: 	if (write_validity) {
899: 		ValidityMask flat_mask(count);
900: 		for (idx_t i = 0; i < count; ++i) {
901: 			auto row_idx = vdata.sel->get_index(i);
902: 			flat_mask.Set(i, vdata.validity.RowIsValid(row_idx));
903: 		}
904: 		serializer.WriteData((const_data_ptr_t)flat_mask.GetData(), flat_mask.ValidityMaskSize(count));
905: 	}
906: 	if (TypeIsConstantSize(type.InternalType())) {
907: 		// constant size type: simple copy
908: 		idx_t write_size = GetTypeIdSize(type.InternalType()) * count;
909: 		auto ptr = unique_ptr<data_t[]>(new data_t[write_size]);
910: 		VectorOperations::WriteToStorage(*this, count, ptr.get());
911: 		serializer.WriteData(ptr.get(), write_size);
912: 	} else {
913: 		switch (type.InternalType()) {
914: 		case PhysicalType::VARCHAR: {
915: 			auto strings = (string_t *)vdata.data;
916: 			for (idx_t i = 0; i < count; i++) {
917: 				auto idx = vdata.sel->get_index(i);
918: 				auto source = !vdata.validity.RowIsValid(idx) ? NullValue<string_t>() : strings[idx];
919: 				serializer.WriteStringLen((const_data_ptr_t)source.GetDataUnsafe(), source.GetSize());
920: 			}
921: 			break;
922: 		}
923: 		case PhysicalType::STRUCT: {
924: 			Flatten(count);
925: 			auto &entries = StructVector::GetEntries(*this);
926: 			for (auto &entry : entries) {
927: 				entry->Serialize(count, serializer);
928: 			}
929: 			break;
930: 		}
931: 		case PhysicalType::LIST: {
932: 			auto &child = ListVector::GetEntry(*this);
933: 			auto list_size = ListVector::GetListSize(*this);
934: 
935: 			// serialize the list entries in a flat array
936: 			auto data = unique_ptr<list_entry_t[]>(new list_entry_t[count]);
937: 			auto source_array = (list_entry_t *)vdata.data;
938: 			for (idx_t i = 0; i < count; i++) {
939: 				auto idx = vdata.sel->get_index(i);
940: 				auto source = source_array[idx];
941: 				data[i].offset = source.offset;
942: 				data[i].length = source.length;
943: 			}
944: 
945: 			// write the list size
946: 			serializer.Write<idx_t>(list_size);
947: 			serializer.WriteData((data_ptr_t)data.get(), count * sizeof(list_entry_t));
948: 
949: 			child.Serialize(list_size, serializer);
950: 			break;
951: 		}
952: 		default:
953: 			throw InternalException("Unimplemented variable width type for Vector::Serialize!");
954: 		}
955: 	}
956: }
957: 
958: void Vector::Deserialize(idx_t count, Deserializer &source) {
959: 	auto &type = GetType();
960: 
961: 	auto &validity = FlatVector::Validity(*this);
962: 	validity.Reset();
963: 	const auto has_validity = source.Read<bool>();
964: 	if (has_validity) {
965: 		validity.Initialize(count);
966: 		source.ReadData((data_ptr_t)validity.GetData(), validity.ValidityMaskSize(count));
967: 	}
968: 
969: 	if (TypeIsConstantSize(type.InternalType())) {
970: 		// constant size type: read fixed amount of data from
971: 		auto column_size = GetTypeIdSize(type.InternalType()) * count;
972: 		auto ptr = unique_ptr<data_t[]>(new data_t[column_size]);
973: 		source.ReadData(ptr.get(), column_size);
974: 
975: 		VectorOperations::ReadFromStorage(ptr.get(), count, *this);
976: 	} else {
977: 		switch (type.InternalType()) {
978: 		case PhysicalType::VARCHAR: {
979: 			auto strings = FlatVector::GetData<string_t>(*this);
980: 			for (idx_t i = 0; i < count; i++) {
981: 				// read the strings
982: 				auto str = source.Read<string>();
983: 				// now add the string to the StringHeap of the vector
984: 				// and write the pointer into the vector
985: 				if (validity.RowIsValid(i)) {
986: 					strings[i] = StringVector::AddStringOrBlob(*this, str);
987: 				}
988: 			}
989: 			break;
990: 		}
991: 		case PhysicalType::STRUCT: {
992: 			auto &entries = StructVector::GetEntries(*this);
993: 			for (auto &entry : entries) {
994: 				entry->Deserialize(count, source);
995: 			}
996: 			break;
997: 		}
998: 		case PhysicalType::LIST: {
999: 			// read the list size
1000: 			auto list_size = source.Read<idx_t>();
1001: 			ListVector::Reserve(*this, list_size);
1002: 			ListVector::SetListSize(*this, list_size);
1003: 
1004: 			// read the list entry
1005: 			auto list_entries = FlatVector::GetData(*this);
1006: 			source.ReadData(list_entries, count * sizeof(list_entry_t));
1007: 
1008: 			// deserialize the child vector
1009: 			auto &child = ListVector::GetEntry(*this);
1010: 			child.Deserialize(list_size, source);
1011: 
1012: 			break;
1013: 		}
1014: 		default:
1015: 			throw InternalException("Unimplemented variable width type for Vector::Deserialize!");
1016: 		}
1017: 	}
1018: }
1019: 
1020: void Vector::SetVectorType(VectorType vector_type_p) {
1021: 	this->vector_type = vector_type_p;
1022: 	if (TypeIsConstantSize(GetType().InternalType()) &&
1023: 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
1024: 		auxiliary.reset();
1025: 	}
1026: 	if (vector_type == VectorType::CONSTANT_VECTOR && GetType().InternalType() == PhysicalType::STRUCT) {
1027: 		auto &entries = StructVector::GetEntries(*this);
1028: 		for (auto &entry : entries) {
1029: 			entry->SetVectorType(vector_type);
1030: 		}
1031: 	}
1032: }
1033: 
1034: void Vector::UTFVerify(const SelectionVector &sel, idx_t count) {
1035: #ifdef DEBUG
1036: 	if (count == 0) {
1037: 		return;
1038: 	}
1039: 	if (GetType().InternalType() == PhysicalType::VARCHAR) {
1040: 		// we just touch all the strings and let the sanitizer figure out if any
1041: 		// of them are deallocated/corrupt
1042: 		switch (GetVectorType()) {
1043: 		case VectorType::CONSTANT_VECTOR: {
1044: 			auto string = ConstantVector::GetData<string_t>(*this);
1045: 			if (!ConstantVector::IsNull(*this)) {
1046: 				string->Verify();
1047: 			}
1048: 			break;
1049: 		}
1050: 		case VectorType::FLAT_VECTOR: {
1051: 			auto strings = FlatVector::GetData<string_t>(*this);
1052: 			for (idx_t i = 0; i < count; i++) {
1053: 				auto oidx = sel.get_index(i);
1054: 				if (validity.RowIsValid(oidx)) {
1055: 					strings[oidx].Verify();
1056: 				}
1057: 			}
1058: 			break;
1059: 		}
1060: 		default:
1061: 			break;
1062: 		}
1063: 	}
1064: #endif
1065: }
1066: 
1067: void Vector::UTFVerify(idx_t count) {
1068: 	auto flat_sel = FlatVector::IncrementalSelectionVector();
1069: 
1070: 	UTFVerify(*flat_sel, count);
1071: }
1072: 
1073: void Vector::VerifyMap(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1074: #ifdef DEBUG
1075: 	D_ASSERT(vector_p.GetType().id() == LogicalTypeId::MAP);
1076: 	auto valid_check = CheckMapValidity(vector_p, count, sel_p);
1077: 	D_ASSERT(valid_check == MapInvalidReason::VALID);
1078: #endif // DEBUG
1079: }
1080: 
1081: void Vector::VerifyUnion(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1082: #ifdef DEBUG
1083: 	D_ASSERT(vector_p.GetType().id() == LogicalTypeId::UNION);
1084: 	auto valid_check = CheckUnionValidity(vector_p, count, sel_p);
1085: 	D_ASSERT(valid_check == UnionInvalidReason::VALID);
1086: #endif // DEBUG
1087: }
1088: 
1089: void Vector::Verify(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1090: #ifdef DEBUG
1091: 	if (count == 0) {
1092: 		return;
1093: 	}
1094: 	Vector *vector = &vector_p;
1095: 	const SelectionVector *sel = &sel_p;
1096: 	SelectionVector owned_sel;
1097: 	auto &type = vector->GetType();
1098: 	auto vtype = vector->GetVectorType();
1099: 	if (vector->GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1100: 		auto &child = DictionaryVector::Child(*vector);
1101: 		D_ASSERT(child.GetVectorType() != VectorType::DICTIONARY_VECTOR);
1102: 		auto &dict_sel = DictionaryVector::SelVector(*vector);
1103: 		// merge the selection vectors and verify the child
1104: 		auto new_buffer = dict_sel.Slice(*sel, count);
1105: 		owned_sel.Initialize(new_buffer);
1106: 		sel = &owned_sel;
1107: 		vector = &child;
1108: 		vtype = vector->GetVectorType();
1109: 	}
1110: 	if (TypeIsConstantSize(type.InternalType()) &&
1111: 	    (vtype == VectorType::CONSTANT_VECTOR || vtype == VectorType::FLAT_VECTOR)) {
1112: 		D_ASSERT(!vector->auxiliary);
1113: 	}
1114: 	if (type.id() == LogicalTypeId::VARCHAR || type.id() == LogicalTypeId::JSON) {
1115: 		// verify that the string is correct unicode
1116: 		switch (vtype) {
1117: 		case VectorType::FLAT_VECTOR: {
1118: 			auto &validity = FlatVector::Validity(*vector);
1119: 			auto strings = FlatVector::GetData<string_t>(*vector);
1120: 			for (idx_t i = 0; i < count; i++) {
1121: 				auto oidx = sel->get_index(i);
1122: 				if (validity.RowIsValid(oidx)) {
1123: 					strings[oidx].Verify();
1124: 				}
1125: 			}
1126: 			break;
1127: 		}
1128: 		default:
1129: 			break;
1130: 		}
1131: 	}
1132: 
1133: 	if (type.InternalType() == PhysicalType::STRUCT) {
1134: 		auto &child_types = StructType::GetChildTypes(type);
1135: 		D_ASSERT(!child_types.empty());
1136: 		// create a selection vector of the non-null entries of the struct vector
1137: 		auto &children = StructVector::GetEntries(*vector);
1138: 		D_ASSERT(child_types.size() == children.size());
1139: 		for (idx_t child_idx = 0; child_idx < children.size(); child_idx++) {
1140: 			D_ASSERT(children[child_idx]->GetType() == child_types[child_idx].second);
1141: 			Vector::Verify(*children[child_idx], sel_p, count);
1142: 			if (vtype == VectorType::CONSTANT_VECTOR) {
1143: 				D_ASSERT(children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR);
1144: 				if (ConstantVector::IsNull(*vector)) {
1145: 					D_ASSERT(ConstantVector::IsNull(*children[child_idx]));
1146: 				}
1147: 			}
1148: 			if (vtype != VectorType::FLAT_VECTOR) {
1149: 				continue;
1150: 			}
1151: 			ValidityMask *child_validity;
1152: 			SelectionVector owned_child_sel;
1153: 			const SelectionVector *child_sel = &owned_child_sel;
1154: 			if (children[child_idx]->GetVectorType() == VectorType::FLAT_VECTOR) {
1155: 				child_sel = FlatVector::IncrementalSelectionVector();
1156: 				child_validity = &FlatVector::Validity(*children[child_idx]);
1157: 			} else if (children[child_idx]->GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1158: 				auto &child = DictionaryVector::Child(*children[child_idx]);
1159: 				if (child.GetVectorType() != VectorType::FLAT_VECTOR) {
1160: 					continue;
1161: 				}
1162: 				child_validity = &FlatVector::Validity(child);
1163: 				child_sel = &DictionaryVector::SelVector(*children[child_idx]);
1164: 			} else if (children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR) {
1165: 				child_sel = ConstantVector::ZeroSelectionVector(count, owned_child_sel);
1166: 				child_validity = &ConstantVector::Validity(*children[child_idx]);
1167: 			} else {
1168: 				continue;
1169: 			}
1170: 			// for any NULL entry in the struct, the child should be NULL as well
1171: 			auto &validity = FlatVector::Validity(*vector);
1172: 			for (idx_t i = 0; i < count; i++) {
1173: 				auto index = sel->get_index(i);
1174: 				if (!validity.RowIsValid(index)) {
1175: 					auto child_index = child_sel->get_index(sel_p.get_index(i));
1176: 					D_ASSERT(!child_validity->RowIsValid(child_index));
1177: 				}
1178: 			}
1179: 		}
1180: 		if (vector->GetType().id() == LogicalTypeId::MAP) {
1181: 			VerifyMap(*vector, *sel, count);
1182: 		}
1183: 
1184: 		if (vector->GetType().id() == LogicalTypeId::UNION) {
1185: 			VerifyUnion(*vector, *sel, count);
1186: 		}
1187: 	}
1188: 
1189: 	if (type.InternalType() == PhysicalType::LIST) {
1190: 		if (vtype == VectorType::CONSTANT_VECTOR) {
1191: 			if (!ConstantVector::IsNull(*vector)) {
1192: 				auto &child = ListVector::GetEntry(*vector);
1193: 				SelectionVector child_sel(ListVector::GetListSize(*vector));
1194: 				idx_t child_count = 0;
1195: 				auto le = ConstantVector::GetData<list_entry_t>(*vector);
1196: 				D_ASSERT(le->offset + le->length <= ListVector::GetListSize(*vector));
1197: 				for (idx_t k = 0; k < le->length; k++) {
1198: 					child_sel.set_index(child_count++, le->offset + k);
1199: 				}
1200: 				Vector::Verify(child, child_sel, child_count);
1201: 			}
1202: 		} else if (vtype == VectorType::FLAT_VECTOR) {
1203: 			auto &validity = FlatVector::Validity(*vector);
1204: 			auto &child = ListVector::GetEntry(*vector);
1205: 			auto child_size = ListVector::GetListSize(*vector);
1206: 			auto list_data = FlatVector::GetData<list_entry_t>(*vector);
1207: 			idx_t total_size = 0;
1208: 			for (idx_t i = 0; i < count; i++) {
1209: 				auto idx = sel->get_index(i);
1210: 				auto &le = list_data[idx];
1211: 				if (validity.RowIsValid(idx)) {
1212: 					D_ASSERT(le.offset + le.length <= child_size);
1213: 					total_size += le.length;
1214: 				}
1215: 			}
1216: 			SelectionVector child_sel(total_size);
1217: 			idx_t child_count = 0;
1218: 			for (idx_t i = 0; i < count; i++) {
1219: 				auto idx = sel->get_index(i);
1220: 				auto &le = list_data[idx];
1221: 				if (validity.RowIsValid(idx)) {
1222: 					D_ASSERT(le.offset + le.length <= child_size);
1223: 					for (idx_t k = 0; k < le.length; k++) {
1224: 						child_sel.set_index(child_count++, le.offset + k);
1225: 					}
1226: 				}
1227: 			}
1228: 			Vector::Verify(child, child_sel, child_count);
1229: 		}
1230: 	}
1231: #endif
1232: }
1233: 
1234: void Vector::Verify(idx_t count) {
1235: 	auto flat_sel = FlatVector::IncrementalSelectionVector();
1236: 	Verify(*this, *flat_sel, count);
1237: }
1238: 
1239: void FlatVector::SetNull(Vector &vector, idx_t idx, bool is_null) {
1240: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
1241: 	vector.validity.Set(idx, !is_null);
1242: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1243: 		// set all child entries to null as well
1244: 		auto &entries = StructVector::GetEntries(vector);
1245: 		for (auto &entry : entries) {
1246: 			FlatVector::SetNull(*entry, idx, is_null);
1247: 		}
1248: 	}
1249: }
1250: 
1251: void ConstantVector::SetNull(Vector &vector, bool is_null) {
1252: 	D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1253: 	vector.validity.Set(0, !is_null);
1254: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1255: 		// set all child entries to null as well
1256: 		auto &entries = StructVector::GetEntries(vector);
1257: 		for (auto &entry : entries) {
1258: 			entry->SetVectorType(VectorType::CONSTANT_VECTOR);
1259: 			ConstantVector::SetNull(*entry, is_null);
1260: 		}
1261: 	}
1262: }
1263: 
1264: const SelectionVector *ConstantVector::ZeroSelectionVector(idx_t count, SelectionVector &owned_sel) {
1265: 	if (count <= STANDARD_VECTOR_SIZE) {
1266: 		return ConstantVector::ZeroSelectionVector();
1267: 	}
1268: 	owned_sel.Initialize(count);
1269: 	for (idx_t i = 0; i < count; i++) {
1270: 		owned_sel.set_index(i, 0);
1271: 	}
1272: 	return &owned_sel;
1273: }
1274: 
1275: void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, idx_t count) {
1276: 	auto &source_type = source.GetType();
1277: 	switch (source_type.InternalType()) {
1278: 	case PhysicalType::LIST: {
1279: 		// retrieve the list entry from the source vector
1280: 		UnifiedVectorFormat vdata;
1281: 		source.ToUnifiedFormat(count, vdata);
1282: 
1283: 		auto list_index = vdata.sel->get_index(position);
1284: 		if (!vdata.validity.RowIsValid(list_index)) {
1285: 			// list is null: create null value
1286: 			Value null_value(source_type);
1287: 			vector.Reference(null_value);
1288: 			break;
1289: 		}
1290: 
1291: 		auto list_data = (list_entry_t *)vdata.data;
1292: 		auto list_entry = list_data[list_index];
1293: 
1294: 		// add the list entry as the first element of "vector"
1295: 		// FIXME: we only need to allocate space for 1 tuple here
1296: 		auto target_data = FlatVector::GetData<list_entry_t>(vector);
1297: 		target_data[0] = list_entry;
1298: 
1299: 		// create a reference to the child list of the source vector
1300: 		auto &child = ListVector::GetEntry(vector);
1301: 		child.Reference(ListVector::GetEntry(source));
1302: 
1303: 		ListVector::SetListSize(vector, ListVector::GetListSize(source));
1304: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1305: 		break;
1306: 	}
1307: 	case PhysicalType::STRUCT: {
1308: 		UnifiedVectorFormat vdata;
1309: 		source.ToUnifiedFormat(count, vdata);
1310: 
1311: 		auto struct_index = vdata.sel->get_index(position);
1312: 		if (!vdata.validity.RowIsValid(struct_index)) {
1313: 			// null struct: create null value
1314: 			Value null_value(source_type);
1315: 			vector.Reference(null_value);
1316: 			break;
1317: 		}
1318: 
1319: 		// struct: pass constant reference into child entries
1320: 		auto &source_entries = StructVector::GetEntries(source);
1321: 		auto &target_entries = StructVector::GetEntries(vector);
1322: 		for (idx_t i = 0; i < source_entries.size(); i++) {
1323: 			ConstantVector::Reference(*target_entries[i], *source_entries[i], position, count);
1324: 		}
1325: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1326: 		break;
1327: 	}
1328: 	default:
1329: 		// default behavior: get a value from the vector and reference it
1330: 		// this is not that expensive for scalar types
1331: 		auto value = source.GetValue(position);
1332: 		vector.Reference(value);
1333: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1334: 		break;
1335: 	}
1336: }
1337: 
1338: string_t StringVector::AddString(Vector &vector, const char *data, idx_t len) {
1339: 	return StringVector::AddString(vector, string_t(data, len));
1340: }
1341: 
1342: string_t StringVector::AddStringOrBlob(Vector &vector, const char *data, idx_t len) {
1343: 	return StringVector::AddStringOrBlob(vector, string_t(data, len));
1344: }
1345: 
1346: string_t StringVector::AddString(Vector &vector, const char *data) {
1347: 	return StringVector::AddString(vector, string_t(data, strlen(data)));
1348: }
1349: 
1350: string_t StringVector::AddString(Vector &vector, const string &data) {
1351: 	return StringVector::AddString(vector, string_t(data.c_str(), data.size()));
1352: }
1353: 
1354: string_t StringVector::AddString(Vector &vector, string_t data) {
1355: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR || vector.GetType().id() == LogicalTypeId::JSON);
1356: 	if (data.IsInlined()) {
1357: 		// string will be inlined: no need to store in string heap
1358: 		return data;
1359: 	}
1360: 	if (!vector.auxiliary) {
1361: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1362: 	}
1363: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1364: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1365: 	return string_buffer.AddString(data);
1366: }
1367: 
1368: string_t StringVector::AddStringOrBlob(Vector &vector, string_t data) {
1369: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1370: 	if (data.IsInlined()) {
1371: 		// string will be inlined: no need to store in string heap
1372: 		return data;
1373: 	}
1374: 	if (!vector.auxiliary) {
1375: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1376: 	}
1377: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1378: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1379: 	return string_buffer.AddBlob(data);
1380: }
1381: 
1382: string_t StringVector::EmptyString(Vector &vector, idx_t len) {
1383: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1384: 	if (len < string_t::INLINE_LENGTH) {
1385: 		return string_t(len);
1386: 	}
1387: 	if (!vector.auxiliary) {
1388: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1389: 	}
1390: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1391: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1392: 	return string_buffer.EmptyString(len);
1393: }
1394: 
1395: void StringVector::AddHandle(Vector &vector, BufferHandle handle) {
1396: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1397: 	if (!vector.auxiliary) {
1398: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1399: 	}
1400: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1401: 	string_buffer.AddHeapReference(make_buffer<ManagedVectorBuffer>(move(handle)));
1402: }
1403: 
1404: void StringVector::AddBuffer(Vector &vector, buffer_ptr<VectorBuffer> buffer) {
1405: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1406: 	D_ASSERT(buffer.get() != vector.auxiliary.get());
1407: 	if (!vector.auxiliary) {
1408: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1409: 	}
1410: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1411: 	string_buffer.AddHeapReference(move(buffer));
1412: }
1413: 
1414: void StringVector::AddHeapReference(Vector &vector, Vector &other) {
1415: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1416: 	D_ASSERT(other.GetType().InternalType() == PhysicalType::VARCHAR);
1417: 
1418: 	if (other.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1419: 		StringVector::AddHeapReference(vector, DictionaryVector::Child(other));
1420: 		return;
1421: 	}
1422: 	if (!other.auxiliary) {
1423: 		return;
1424: 	}
1425: 	StringVector::AddBuffer(vector, other.auxiliary);
1426: }
1427: 
1428: string_t FSSTVector::AddCompressedString(Vector &vector, const char *data, idx_t len) {
1429: 	return FSSTVector::AddCompressedString(vector, string_t(data, len));
1430: }
1431: 
1432: string_t FSSTVector::AddCompressedString(Vector &vector, string_t data) {
1433: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1434: 	if (data.IsInlined()) {
1435: 		// string will be inlined: no need to store in string heap
1436: 		return data;
1437: 	}
1438: 	if (!vector.auxiliary) {
1439: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1440: 	}
1441: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1442: 	auto &fsst_string_buffer = (VectorFSSTStringBuffer &)*vector.auxiliary;
1443: 	return fsst_string_buffer.AddBlob(data);
1444: }
1445: 
1446: void *FSSTVector::GetDecoder(const Vector &vector) {
1447: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1448: 	if (!vector.auxiliary) {
1449: 		throw InternalException("GetDecoder called on FSST Vector without registered buffer");
1450: 	}
1451: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1452: 	auto &fsst_string_buffer = (VectorFSSTStringBuffer &)*vector.auxiliary;
1453: 	return (duckdb_fsst_decoder_t *)fsst_string_buffer.GetDecoder();
1454: }
1455: 
1456: void FSSTVector::RegisterDecoder(Vector &vector, buffer_ptr<void> &duckdb_fsst_decoder) {
1457: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1458: 
1459: 	if (!vector.auxiliary) {
1460: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1461: 	}
1462: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1463: 
1464: 	auto &fsst_string_buffer = (VectorFSSTStringBuffer &)*vector.auxiliary;
1465: 	fsst_string_buffer.AddDecoder(duckdb_fsst_decoder);
1466: }
1467: 
1468: void FSSTVector::SetCount(Vector &vector, idx_t count) {
1469: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1470: 
1471: 	if (!vector.auxiliary) {
1472: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1473: 	}
1474: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1475: 
1476: 	auto &fsst_string_buffer = (VectorFSSTStringBuffer &)*vector.auxiliary;
1477: 	fsst_string_buffer.SetCount(count);
1478: }
1479: 
1480: idx_t FSSTVector::GetCount(Vector &vector) {
1481: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1482: 
1483: 	if (!vector.auxiliary) {
1484: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1485: 	}
1486: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1487: 
1488: 	auto &fsst_string_buffer = (VectorFSSTStringBuffer &)*vector.auxiliary;
1489: 	return fsst_string_buffer.GetCount();
1490: }
1491: 
1492: void FSSTVector::DecompressVector(const Vector &src, Vector &dst, idx_t src_offset, idx_t dst_offset, idx_t copy_count,
1493:                                   const SelectionVector *sel) {
1494: 	D_ASSERT(src.GetVectorType() == VectorType::FSST_VECTOR);
1495: 	D_ASSERT(dst.GetVectorType() == VectorType::FLAT_VECTOR);
1496: 	auto dst_mask = FlatVector::Validity(dst);
1497: 	auto ldata = FSSTVector::GetCompressedData<string_t>(src);
1498: 	auto tdata = FlatVector::GetData<string_t>(dst);
1499: 	for (idx_t i = 0; i < copy_count; i++) {
1500: 		auto source_idx = sel->get_index(src_offset + i);
1501: 		auto target_idx = dst_offset + i;
1502: 		string_t compressed_string = ldata[source_idx];
1503: 		if (dst_mask.RowIsValid(target_idx) && compressed_string.GetSize() > 0) {
1504: 			tdata[target_idx] = FSSTPrimitives::DecompressValue(FSSTVector::GetDecoder(src), dst,
1505: 			                                                    (unsigned char *)compressed_string.GetDataUnsafe(),
1506: 			                                                    compressed_string.GetSize());
1507: 		} else {
1508: 			tdata[target_idx] = string_t(nullptr, 0);
1509: 		}
1510: 	}
1511: }
1512: 
1513: Vector &MapVector::GetKeys(Vector &vector) {
1514: 	auto &entries = StructVector::GetEntries(vector);
1515: 	D_ASSERT(entries.size() == 2);
1516: 	return *entries[0];
1517: }
1518: Vector &MapVector::GetValues(Vector &vector) {
1519: 	auto &entries = StructVector::GetEntries(vector);
1520: 	D_ASSERT(entries.size() == 2);
1521: 	return *entries[1];
1522: }
1523: 
1524: const Vector &MapVector::GetKeys(const Vector &vector) {
1525: 	return GetKeys((Vector &)vector);
1526: }
1527: const Vector &MapVector::GetValues(const Vector &vector) {
1528: 	return GetValues((Vector &)vector);
1529: }
1530: 
1531: vector<unique_ptr<Vector>> &StructVector::GetEntries(Vector &vector) {
1532: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::STRUCT || vector.GetType().id() == LogicalTypeId::MAP ||
1533: 	         vector.GetType().id() == LogicalTypeId::UNION);
1534: 
1535: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1536: 		auto &child = DictionaryVector::Child(vector);
1537: 		return StructVector::GetEntries(child);
1538: 	}
1539: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1540: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1541: 	D_ASSERT(vector.auxiliary);
1542: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRUCT_BUFFER);
1543: 	return ((VectorStructBuffer *)vector.auxiliary.get())->GetChildren();
1544: }
1545: 
1546: const vector<unique_ptr<Vector>> &StructVector::GetEntries(const Vector &vector) {
1547: 	return GetEntries((Vector &)vector);
1548: }
1549: 
1550: const Vector &ListVector::GetEntry(const Vector &vector) {
1551: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1552: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1553: 		auto &child = DictionaryVector::Child(vector);
1554: 		return ListVector::GetEntry(child);
1555: 	}
1556: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1557: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1558: 	D_ASSERT(vector.auxiliary);
1559: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1560: 	return ((VectorListBuffer *)vector.auxiliary.get())->GetChild();
1561: }
1562: 
1563: Vector &ListVector::GetEntry(Vector &vector) {
1564: 	const Vector &cvector = vector;
1565: 	return const_cast<Vector &>(ListVector::GetEntry(cvector));
1566: }
1567: 
1568: void ListVector::Reserve(Vector &vector, idx_t required_capacity) {
1569: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1570: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1571: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1572: 	D_ASSERT(vector.auxiliary);
1573: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1574: 	auto &child_buffer = *((VectorListBuffer *)vector.auxiliary.get());
1575: 	child_buffer.Reserve(required_capacity);
1576: }
1577: 
1578: template <class T>
1579: void TemplatedSearchInMap(Vector &list, T key, vector<idx_t> &offsets, bool is_key_null, idx_t offset, idx_t length) {
1580: 	auto &list_vector = ListVector::GetEntry(list);
1581: 	UnifiedVectorFormat vector_data;
1582: 	list_vector.ToUnifiedFormat(ListVector::GetListSize(list), vector_data);
1583: 	auto data = (T *)vector_data.data;
1584: 	auto validity_mask = vector_data.validity;
1585: 
1586: 	if (is_key_null) {
1587: 		for (idx_t i = offset; i < offset + length; i++) {
1588: 			if (!validity_mask.RowIsValid(i)) {
1589: 				offsets.push_back(i);
1590: 			}
1591: 		}
1592: 	} else {
1593: 		for (idx_t i = offset; i < offset + length; i++) {
1594: 			if (!validity_mask.RowIsValid(i)) {
1595: 				continue;
1596: 			}
1597: 			if (key == data[i]) {
1598: 				offsets.push_back(i);
1599: 			}
1600: 		}
1601: 	}
1602: }
1603: 
1604: template <class T>
1605: void TemplatedSearchInMap(Vector &list, const Value &key, vector<idx_t> &offsets, bool is_key_null, idx_t offset,
1606:                           idx_t length) {
1607: 	TemplatedSearchInMap<T>(list, key.template GetValueUnsafe<T>(), offsets, is_key_null, offset, length);
1608: }
1609: 
1610: void SearchStringInMap(Vector &list, const string &key, vector<idx_t> &offsets, bool is_key_null, idx_t offset,
1611:                        idx_t length) {
1612: 	auto &list_vector = ListVector::GetEntry(list);
1613: 	UnifiedVectorFormat vector_data;
1614: 	list_vector.ToUnifiedFormat(ListVector::GetListSize(list), vector_data);
1615: 	auto data = (string_t *)vector_data.data;
1616: 	auto validity_mask = vector_data.validity;
1617: 	if (is_key_null) {
1618: 		for (idx_t i = offset; i < offset + length; i++) {
1619: 			if (!validity_mask.RowIsValid(i)) {
1620: 				offsets.push_back(i);
1621: 			}
1622: 		}
1623: 	} else {
1624: 		string_t key_str_t(key);
1625: 		for (idx_t i = offset; i < offset + length; i++) {
1626: 			if (!validity_mask.RowIsValid(i)) {
1627: 				continue;
1628: 			}
1629: 			if (Equals::Operation<string_t>(data[i], key_str_t)) {
1630: 				offsets.push_back(i);
1631: 			}
1632: 		}
1633: 	}
1634: }
1635: 
1636: vector<idx_t> ListVector::Search(Vector &list, const Value &key, idx_t row) {
1637: 	vector<idx_t> offsets;
1638: 
1639: 	auto &list_vector = ListVector::GetEntry(list);
1640: 	auto &entry = ListVector::GetData(list)[row];
1641: 
1642: 	switch (list_vector.GetType().InternalType()) {
1643: 	case PhysicalType::BOOL:
1644: 	case PhysicalType::INT8:
1645: 		TemplatedSearchInMap<int8_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1646: 		break;
1647: 	case PhysicalType::INT16:
1648: 		TemplatedSearchInMap<int16_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1649: 		break;
1650: 	case PhysicalType::INT32:
1651: 		TemplatedSearchInMap<int32_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1652: 		break;
1653: 	case PhysicalType::INT64:
1654: 		TemplatedSearchInMap<int64_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1655: 		break;
1656: 	case PhysicalType::INT128:
1657: 		TemplatedSearchInMap<hugeint_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1658: 		break;
1659: 	case PhysicalType::UINT8:
1660: 		TemplatedSearchInMap<uint8_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1661: 		break;
1662: 	case PhysicalType::UINT16:
1663: 		TemplatedSearchInMap<uint16_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1664: 		break;
1665: 	case PhysicalType::UINT32:
1666: 		TemplatedSearchInMap<uint32_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1667: 		break;
1668: 	case PhysicalType::UINT64:
1669: 		TemplatedSearchInMap<uint64_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1670: 		break;
1671: 	case PhysicalType::FLOAT:
1672: 		TemplatedSearchInMap<float>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1673: 		break;
1674: 	case PhysicalType::DOUBLE:
1675: 		TemplatedSearchInMap<double>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1676: 		break;
1677: 	case PhysicalType::VARCHAR:
1678: 		SearchStringInMap(list, StringValue::Get(key), offsets, key.IsNull(), entry.offset, entry.length);
1679: 		break;
1680: 	default:
1681: 		throw InvalidTypeException(list.GetType().id(), "Invalid type for List Vector Search");
1682: 	}
1683: 	return offsets;
1684: }
1685: 
1686: Value ListVector::GetValuesFromOffsets(Vector &list, vector<idx_t> &offsets) {
1687: 	auto &child_vec = ListVector::GetEntry(list);
1688: 	vector<Value> list_values;
1689: 	list_values.reserve(offsets.size());
1690: 	for (auto &offset : offsets) {
1691: 		list_values.push_back(child_vec.GetValue(offset));
1692: 	}
1693: 	return Value::LIST(ListType::GetChildType(list.GetType()), move(list_values));
1694: }
1695: 
1696: idx_t ListVector::GetListSize(const Vector &vec) {
1697: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1698: 		auto &child = DictionaryVector::Child(vec);
1699: 		return ListVector::GetListSize(child);
1700: 	}
1701: 	D_ASSERT(vec.auxiliary);
1702: 	return ((VectorListBuffer &)*vec.auxiliary).size;
1703: }
1704: 
1705: idx_t ListVector::GetListCapacity(const Vector &vec) {
1706: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1707: 		auto &child = DictionaryVector::Child(vec);
1708: 		return ListVector::GetListSize(child);
1709: 	}
1710: 	D_ASSERT(vec.auxiliary);
1711: 	return ((VectorListBuffer &)*vec.auxiliary).capacity;
1712: }
1713: 
1714: void ListVector::ReferenceEntry(Vector &vector, Vector &other) {
1715: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1716: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1717: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1718: 	D_ASSERT(other.GetType().id() == LogicalTypeId::LIST);
1719: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR || other.GetVectorType() == VectorType::CONSTANT_VECTOR);
1720: 	vector.auxiliary = other.auxiliary;
1721: }
1722: 
1723: void ListVector::SetListSize(Vector &vec, idx_t size) {
1724: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1725: 		auto &child = DictionaryVector::Child(vec);
1726: 		ListVector::SetListSize(child, size);
1727: 	}
1728: 	((VectorListBuffer &)*vec.auxiliary).size = size;
1729: }
1730: 
1731: void ListVector::Append(Vector &target, const Vector &source, idx_t source_size, idx_t source_offset) {
1732: 	if (source_size - source_offset == 0) {
1733: 		//! Nothing to add
1734: 		return;
1735: 	}
1736: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1737: 	target_buffer.Append(source, source_size, source_offset);
1738: }
1739: 
1740: void ListVector::Append(Vector &target, const Vector &source, const SelectionVector &sel, idx_t source_size,
1741:                         idx_t source_offset) {
1742: 	if (source_size - source_offset == 0) {
1743: 		//! Nothing to add
1744: 		return;
1745: 	}
1746: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1747: 	target_buffer.Append(source, sel, source_size, source_offset);
1748: }
1749: 
1750: void ListVector::PushBack(Vector &target, const Value &insert) {
1751: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1752: 	target_buffer.PushBack(insert);
1753: }
1754: 
1755: // Union vector
1756: const Vector &UnionVector::GetMember(const Vector &vector, idx_t member_index) {
1757: 	D_ASSERT(member_index < UnionType::GetMemberCount(vector.GetType()));
1758: 	auto &entries = StructVector::GetEntries(vector);
1759: 	return *entries[member_index + 1]; // skip the "tag" entry
1760: }
1761: 
1762: Vector &UnionVector::GetMember(Vector &vector, idx_t member_index) {
1763: 	D_ASSERT(member_index < UnionType::GetMemberCount(vector.GetType()));
1764: 	auto &entries = StructVector::GetEntries(vector);
1765: 	return *entries[member_index + 1]; // skip the "tag" entry
1766: }
1767: 
1768: const Vector &UnionVector::GetTags(const Vector &vector) {
1769: 	// the tag vector is always the first struct child.
1770: 	return *StructVector::GetEntries(vector)[0];
1771: }
1772: 
1773: Vector &UnionVector::GetTags(Vector &vector) {
1774: 	// the tag vector is always the first struct child.
1775: 	return *StructVector::GetEntries(vector)[0];
1776: }
1777: 
1778: void UnionVector::SetToMember(Vector &union_vector, union_tag_t tag, Vector &member_vector, idx_t count,
1779:                               bool keep_tags_for_null) {
1780: 	D_ASSERT(union_vector.GetType().id() == LogicalTypeId::UNION);
1781: 	D_ASSERT(tag < UnionType::GetMemberCount(union_vector.GetType()));
1782: 
1783: 	// Set the union member to the specified vector
1784: 	UnionVector::GetMember(union_vector, tag).Reference(member_vector);
1785: 	auto &tag_vector = UnionVector::GetTags(union_vector);
1786: 
1787: 	if (member_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
1788: 		// if the member vector is constant, we can set the union to constant as well
1789: 		union_vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1790: 		ConstantVector::GetData<union_tag_t>(tag_vector)[0] = tag;
1791: 		ConstantVector::SetNull(union_vector, ConstantVector::IsNull(member_vector));
1792: 
1793: 	} else {
1794: 		// otherwise flatten and set to flatvector
1795: 		member_vector.Flatten(count);
1796: 		union_vector.SetVectorType(VectorType::FLAT_VECTOR);
1797: 
1798: 		if (member_vector.validity.AllValid()) {
1799: 			// if the member vector is all valid, we can set the tag to constant
1800: 			tag_vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1801: 			auto tag_data = ConstantVector::GetData<union_tag_t>(tag_vector);
1802: 			*tag_data = tag;
1803: 		} else {
1804: 			tag_vector.SetVectorType(VectorType::FLAT_VECTOR);
1805: 			if (keep_tags_for_null) {
1806: 				FlatVector::Validity(tag_vector).SetAllValid(count);
1807: 				FlatVector::Validity(union_vector).SetAllValid(count);
1808: 			} else {
1809: 				// ensure the tags have the same validity as the member
1810: 				FlatVector::Validity(union_vector) = FlatVector::Validity(member_vector);
1811: 				FlatVector::Validity(tag_vector) = FlatVector::Validity(member_vector);
1812: 			}
1813: 
1814: 			auto tag_data = FlatVector::GetData<union_tag_t>(tag_vector);
1815: 			memset(tag_data, tag, count);
1816: 		}
1817: 	}
1818: 
1819: 	// Set the non-selected members to constant null vectors
1820: 	for (idx_t i = 0; i < UnionType::GetMemberCount(union_vector.GetType()); i++) {
1821: 		if (i != tag) {
1822: 			auto &member = UnionVector::GetMember(union_vector, i);
1823: 			member.SetVectorType(VectorType::CONSTANT_VECTOR);
1824: 			ConstantVector::SetNull(member, true);
1825: 		}
1826: 	}
1827: }
1828: 
1829: union_tag_t UnionVector::GetTag(const Vector &vector, idx_t index) {
1830: 	// the tag vector is always the first struct child.
1831: 	auto &tag_vector = *StructVector::GetEntries(vector)[0];
1832: 	if (tag_vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1833: 		auto &child = DictionaryVector::Child(tag_vector);
1834: 		return FlatVector::GetData<union_tag_t>(child)[index];
1835: 	}
1836: 	if (tag_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
1837: 		return ConstantVector::GetData<union_tag_t>(tag_vector)[0];
1838: 	}
1839: 	return FlatVector::GetData<union_tag_t>(tag_vector)[index];
1840: }
1841: 
1842: } // namespace duckdb
[end of src/common/types/vector.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: