--- a/src/catalog/default/default_views.cpp
+++ b/src/catalog/default/default_views.cpp
@@
-	{"information_schema", "referential_constraints", "SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, f.constraint_name constraint_name, c.database_name unique_constraint_catalog, c.schema_name unique_constraint_schema, c.constraint_name unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c, duckdb_constraints() f WHERE f.constraint_type = 'FOREIGN KEY' AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY') AND f.database_oid = c.database_oid AND f.schema_oid = c.schema_oid AND lower(f.referenced_table) = lower(c.table_name) AND [lower(x) for x in f.referenced_column_names] = [lower(x) for x in c.constraint_column_names]"},
-	{"information_schema", "key_column_usage", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, UNNEST(constraint_column_names) column_name, UNNEST(generate_series(1, len(constraint_column_names))) ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';"},
-	{"information_schema", "table_constraints", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';"},
+	{"information_schema", "referential_constraints", "SELECT f.database_name AS constraint_catalog, f.schema_name AS constraint_schema, f.constraint_name, r.database_name AS unique_constraint_catalog, r.schema_name AS unique_constraint_schema, r.constraint_name AS unique_constraint_name, 'NONE' AS match_option, 'NO ACTION' AS update_rule, 'NO ACTION' AS delete_rule FROM duckdb_constraints() f JOIN duckdb_constraints() r ON r.database_oid = f.database_oid AND r.schema_oid = f.schema_oid AND lower(r.table_name) = lower(f.referenced_table) WHERE f.constraint_type = 'FOREIGN KEY' AND r.constraint_type IN ('UNIQUE', 'PRIMARY KEY')"},
+	{"information_schema", "key_column_usage", "SELECT c.database_name AS constraint_catalog, c.schema_name AS constraint_schema, c.constraint_name, c.database_name AS table_catalog, c.schema_name AS table_schema, c.table_name, cols.column_name, list_position(c.constraint_column_names, cols.column_name) AS ordinal_position, CASE WHEN c.constraint_type = 'FOREIGN KEY' THEN list_position(c.constraint_column_names, cols.column_name) ELSE NULL END AS position_in_unique_constraint FROM duckdb_constraints() c, UNNEST(c.constraint_column_names) AS cols(column_name) WHERE c.constraint_type IN ('FOREIGN KEY', 'PRIMARY KEY', 'UNIQUE')"},
+	{"information_schema", "table_constraints", "SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, database_name AS table_catalog, schema_name AS table_schema, table_name, CASE WHEN constraint_type = 'NOT NULL' THEN 'CHECK' ELSE constraint_type END AS constraint_type, 'NO' AS is_deferrable, 'NO' AS initially_deferred, 'YES' AS enforced, 'YES' AS nulls_distinct FROM duckdb_constraints() WHERE constraint_type IN ('PRIMARY KEY', 'FOREIGN KEY', 'UNIQUE', 'CHECK', 'NOT NULL')"},
+	{"information_schema", "constraint_column_usage", "SELECT c.database_name AS table_catalog, c.schema_name AS table_schema, c.table_name, cols.column_name, c.database_name AS constraint_catalog, c.schema_name AS constraint_schema, c.constraint_name FROM duckdb_constraints() c, UNNEST(c.constraint_column_names) AS cols(column_name) WHERE c.constraint_type IN ('PRIMARY KEY', 'UNIQUE', 'FOREIGN KEY')"},
+	{"information_schema", "constraint_table_usage", "SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name FROM duckdb_constraints() WHERE constraint_type IN ('PRIMARY KEY', 'UNIQUE', 'FOREIGN KEY', 'CHECK', 'NOT NULL')"},
+	{"information_schema", "check_constraints", "SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, expression AS check_clause FROM duckdb_constraints() WHERE constraint_type IN ('CHECK', 'NOT NULL')"},
     {nullptr, nullptr, nullptr}};
