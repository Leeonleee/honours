{
  "repo": "duckdb/duckdb",
  "pull_number": 4131,
  "instance_id": "duckdb__duckdb-4131",
  "issue_numbers": [
    "3043"
  ],
  "base_commit": "eba10adcd5725079bad6e44845484d7510eaea63",
  "patch": "diff --git a/src/include/duckdb/common/enum_class_hash.hpp b/src/include/duckdb/common/enum_class_hash.hpp\nnew file mode 100644\nindex 000000000000..1de2c811f3d2\n--- /dev/null\n+++ b/src/include/duckdb/common/enum_class_hash.hpp\n@@ -0,0 +1,22 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/enum_class_hash.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include <cstddef>\n+\n+namespace duckdb {\n+/* For compatibility with older C++ STL, an explicit hash class\n+   is required for enums with C++ sets and maps */\n+struct EnumClassHash {\n+\ttemplate <typename T>\n+\tstd::size_t operator()(T t) const {\n+\t\treturn static_cast<std::size_t>(t);\n+\t}\n+};\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\nindex 1e8345667f40..f24ff0d174a9 100644\n--- a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\n@@ -13,6 +13,21 @@\n \n namespace duckdb {\n \n+enum class SequenceInfo : uint8_t {\n+\t// Sequence start\n+\tSEQ_START,\n+\t// Sequence increment\n+\tSEQ_INC,\n+\t// Sequence minimum value\n+\tSEQ_MIN,\n+\t// Sequence maximum value\n+\tSEQ_MAX,\n+\t// Sequence cycle option\n+\tSEQ_CYCLE,\n+\t// Sequence owner table\n+\tSEQ_OWN\n+};\n+\n struct CreateSequenceInfo : public CreateInfo {\n \tCreateSequenceInfo()\n \t    : CreateInfo(CatalogType::SEQUENCE_ENTRY, INVALID_SCHEMA), name(string()), usage_count(0), increment(1),\ndiff --git a/src/parser/transform/statement/transform_alter_sequence.cpp b/src/parser/transform/statement/transform_alter_sequence.cpp\nindex c9f3bfa0584c..e8d360245aba 100644\n--- a/src/parser/transform/statement/transform_alter_sequence.cpp\n+++ b/src/parser/transform/statement/transform_alter_sequence.cpp\n@@ -1,6 +1,9 @@\n #include \"duckdb/parser/transformer.hpp\"\n #include \"duckdb/parser/statement/alter_statement.hpp\"\n #include \"duckdb/parser/parsed_data/alter_table_info.hpp\"\n+#include \"duckdb/parser/parsed_data/create_sequence_info.hpp\"\n+#include \"duckdb/common/enum_class_hash.hpp\"\n+#include \"duckdb/common/unordered_set.hpp\"\n \n namespace duckdb {\n \n@@ -17,12 +20,18 @@ unique_ptr<AlterStatement> Transformer::TransformAlterSequence(duckdb_libpgquery\n \t\tthrow InternalException(\"Expected an argument for ALTER SEQUENCE.\");\n \t}\n \n+\tunordered_set<SequenceInfo, EnumClassHash> used;\n \tduckdb_libpgquery::PGListCell *cell = nullptr;\n \tfor_each_cell(cell, stmt->options->head) {\n \t\tauto *def_elem = reinterpret_cast<duckdb_libpgquery::PGDefElem *>(cell->data.ptr_value);\n \t\tstring opt_name = string(def_elem->defname);\n \n \t\tif (opt_name == \"owned_by\") {\n+\t\t\tif (used.find(SequenceInfo::SEQ_OWN) != used.end()) {\n+\t\t\t\tthrow ParserException(\"Owned by value should be passed as most once\");\n+\t\t\t}\n+\t\t\tused.insert(SequenceInfo::SEQ_OWN);\n+\n \t\t\tauto val = (duckdb_libpgquery::PGValue *)def_elem->arg;\n \t\t\tif (!val) {\n \t\t\t\tthrow InternalException(\"Expected an argument for option %s\", opt_name);\ndiff --git a/src/parser/transform/statement/transform_alter_table.cpp b/src/parser/transform/statement/transform_alter_table.cpp\nindex a82fa8723984..83403bb05a5f 100644\n--- a/src/parser/transform/statement/transform_alter_table.cpp\n+++ b/src/parser/transform/statement/transform_alter_table.cpp\n@@ -11,8 +11,11 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode\n \tD_ASSERT(stmt);\n \tD_ASSERT(stmt->relation);\n \n-\tauto result = make_unique<AlterStatement>();\n+\tif (stmt->cmds->length != 1) {\n+\t\tthrow ParserException(\"Only one ALTER command per statement is supported\");\n+\t}\n \n+\tauto result = make_unique<AlterStatement>();\n \tauto qname = TransformQualifiedName(stmt->relation);\n \n \t// first we check the type of ALTER\n@@ -22,6 +25,10 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode\n \t\tswitch (command->subtype) {\n \t\tcase duckdb_libpgquery::PG_AT_AddColumn: {\n \t\t\tauto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;\n+\n+\t\t\tif (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {\n+\t\t\t\tthrow ParserException(\"Adding columns is only supported for tables\");\n+\t\t\t}\n \t\t\tif (cdef->category == duckdb_libpgquery::COL_GENERATED) {\n \t\t\t\tthrow ParserException(\"Adding generated columns after table creation is not supported yet\");\n \t\t\t}\n@@ -41,20 +48,31 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode\n \t\t}\n \t\tcase duckdb_libpgquery::PG_AT_DropColumn: {\n \t\t\tbool cascade = command->behavior == duckdb_libpgquery::PG_DROP_CASCADE;\n+\n+\t\t\tif (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {\n+\t\t\t\tthrow ParserException(\"Dropping columns is only supported for tables\");\n+\t\t\t}\n \t\t\tresult->info =\n \t\t\t    make_unique<RemoveColumnInfo>(qname.schema, qname.name, command->name, command->missing_ok, cascade);\n \t\t\tbreak;\n \t\t}\n \t\tcase duckdb_libpgquery::PG_AT_ColumnDefault: {\n \t\t\tauto expr = TransformExpression(command->def);\n+\n+\t\t\tif (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {\n+\t\t\t\tthrow ParserException(\"Alter column's default is only supported for tables\");\n+\t\t\t}\n \t\t\tresult->info = make_unique<SetDefaultInfo>(qname.schema, qname.name, command->name, move(expr));\n \t\t\tbreak;\n \t\t}\n \t\tcase duckdb_libpgquery::PG_AT_AlterColumnType: {\n \t\t\tauto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;\n \t\t\tauto column_definition = TransformColumnDefinition(cdef);\n-\n \t\t\tunique_ptr<ParsedExpression> expr;\n+\n+\t\t\tif (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {\n+\t\t\t\tthrow ParserException(\"Alter column's type is only supported for tables\");\n+\t\t\t}\n \t\t\tif (cdef->raw_default) {\n \t\t\t\texpr = TransformExpression(cdef->raw_default);\n \t\t\t} else {\ndiff --git a/src/parser/transform/statement/transform_create_sequence.cpp b/src/parser/transform/statement/transform_create_sequence.cpp\nindex 1adb20bce4f0..ed1e87c0b881 100644\n--- a/src/parser/transform/statement/transform_create_sequence.cpp\n+++ b/src/parser/transform/statement/transform_create_sequence.cpp\n@@ -1,6 +1,8 @@\n #include \"duckdb/parser/statement/create_statement.hpp\"\n #include \"duckdb/parser/parsed_data/create_sequence_info.hpp\"\n #include \"duckdb/parser/transformer.hpp\"\n+#include \"duckdb/common/enum_class_hash.hpp\"\n+#include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/common/operator/cast_operators.hpp\"\n \n namespace duckdb {\n@@ -16,27 +18,35 @@ unique_ptr<CreateStatement> Transformer::TransformCreateSequence(duckdb_libpgque\n \tinfo->name = qname.name;\n \n \tif (stmt->options) {\n+\t\tunordered_set<SequenceInfo, EnumClassHash> used;\n \t\tduckdb_libpgquery::PGListCell *cell = nullptr;\n \t\tfor_each_cell(cell, stmt->options->head) {\n \t\t\tauto *def_elem = reinterpret_cast<duckdb_libpgquery::PGDefElem *>(cell->data.ptr_value);\n \t\t\tstring opt_name = string(def_elem->defname);\n-\n \t\t\tauto val = (duckdb_libpgquery::PGValue *)def_elem->arg;\n-\t\t\tif (def_elem->defaction == duckdb_libpgquery::PG_DEFELEM_UNSPEC && !val) { // e.g. NO MINVALUE\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tD_ASSERT(val);\n-\t\t\tint64_t opt_value;\n-\t\t\tif (val->type == duckdb_libpgquery::T_PGInteger) {\n-\t\t\t\topt_value = val->val.ival;\n-\t\t\t} else if (val->type == duckdb_libpgquery::T_PGFloat) {\n-\t\t\t\tif (!TryCast::Operation<string_t, int64_t>(string_t(val->val.str), opt_value, true)) {\n+\t\t\tbool nodef = def_elem->defaction == duckdb_libpgquery::PG_DEFELEM_UNSPEC && !val; // e.g. NO MINVALUE\n+\t\t\tint64_t opt_value = 0;\n+\n+\t\t\tif (val) {\n+\t\t\t\tif (val->type == duckdb_libpgquery::T_PGInteger) {\n+\t\t\t\t\topt_value = val->val.ival;\n+\t\t\t\t} else if (val->type == duckdb_libpgquery::T_PGFloat) {\n+\t\t\t\t\tif (!TryCast::Operation<string_t, int64_t>(string_t(val->val.str), opt_value, true)) {\n+\t\t\t\t\t\tthrow ParserException(\"Expected an integer argument for option %s\", opt_name);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n \t\t\t\t\tthrow ParserException(\"Expected an integer argument for option %s\", opt_name);\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tthrow ParserException(\"Expected an integer argument for option %s\", opt_name);\n \t\t\t}\n \t\t\tif (opt_name == \"increment\") {\n+\t\t\t\tif (used.find(SequenceInfo::SEQ_INC) != used.end()) {\n+\t\t\t\t\tthrow ParserException(\"Increment value should be passed as most once\");\n+\t\t\t\t}\n+\t\t\t\tused.insert(SequenceInfo::SEQ_INC);\n+\t\t\t\tif (nodef) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tinfo->increment = opt_value;\n \t\t\t\tif (info->increment == 0) {\n \t\t\t\t\tthrow ParserException(\"Increment must not be zero\");\n@@ -49,18 +59,50 @@ unique_ptr<CreateStatement> Transformer::TransformCreateSequence(duckdb_libpgque\n \t\t\t\t\tinfo->max_value = NumericLimits<int64_t>::Maximum();\n \t\t\t\t}\n \t\t\t} else if (opt_name == \"minvalue\") {\n+\t\t\t\tif (used.find(SequenceInfo::SEQ_MIN) != used.end()) {\n+\t\t\t\t\tthrow ParserException(\"Minvalue should be passed as most once\");\n+\t\t\t\t}\n+\t\t\t\tused.insert(SequenceInfo::SEQ_MIN);\n+\t\t\t\tif (nodef) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tinfo->min_value = opt_value;\n \t\t\t\tif (info->increment > 0) {\n \t\t\t\t\tinfo->start_value = info->min_value;\n \t\t\t\t}\n \t\t\t} else if (opt_name == \"maxvalue\") {\n+\t\t\t\tif (used.find(SequenceInfo::SEQ_MAX) != used.end()) {\n+\t\t\t\t\tthrow ParserException(\"Maxvalue should be passed as most once\");\n+\t\t\t\t}\n+\t\t\t\tused.insert(SequenceInfo::SEQ_MAX);\n+\t\t\t\tif (nodef) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tinfo->max_value = opt_value;\n \t\t\t\tif (info->increment < 0) {\n \t\t\t\t\tinfo->start_value = info->max_value;\n \t\t\t\t}\n \t\t\t} else if (opt_name == \"start\") {\n+\t\t\t\tif (used.find(SequenceInfo::SEQ_START) != used.end()) {\n+\t\t\t\t\tthrow ParserException(\"Start value should be passed as most once\");\n+\t\t\t\t}\n+\t\t\t\tused.insert(SequenceInfo::SEQ_START);\n+\t\t\t\tif (nodef) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tinfo->start_value = opt_value;\n \t\t\t} else if (opt_name == \"cycle\") {\n+\t\t\t\tif (used.find(SequenceInfo::SEQ_CYCLE) != used.end()) {\n+\t\t\t\t\tthrow ParserException(\"Cycle value should be passed as most once\");\n+\t\t\t\t}\n+\t\t\t\tused.insert(SequenceInfo::SEQ_CYCLE);\n+\t\t\t\tif (nodef) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tinfo->cycle = opt_value > 0;\n \t\t\t} else {\n \t\t\t\tthrow ParserException(\"Unrecognized option \\\"%s\\\" for CREATE SEQUENCE\", opt_name);\ndiff --git a/src/parser/transform/statement/transform_rename.cpp b/src/parser/transform/statement/transform_rename.cpp\nindex 5e3e45e1fd25..30e9e5982681 100644\n--- a/src/parser/transform/statement/transform_rename.cpp\n+++ b/src/parser/transform/statement/transform_rename.cpp\n@@ -71,6 +71,7 @@ unique_ptr<AlterStatement> Transformer::TransformRename(duckdb_libpgquery::PGNod\n \t\tthrow NotImplementedException(\"Schema element not supported yet!\");\n \t}\n \tD_ASSERT(info);\n+\tinfo->if_exists = stmt->missing_ok;\n \n \tauto result = make_unique<AlterStatement>();\n \tresult->info = move(info);\ndiff --git a/src/parser/transform/tableref/transform_subquery.cpp b/src/parser/transform/tableref/transform_subquery.cpp\nindex 0dab25a43419..bb0d86fb89de 100644\n--- a/src/parser/transform/tableref/transform_subquery.cpp\n+++ b/src/parser/transform/tableref/transform_subquery.cpp\n@@ -9,6 +9,9 @@ unique_ptr<TableRef> Transformer::TransformRangeSubselect(duckdb_libpgquery::PGR\n \tif (!subquery) {\n \t\treturn nullptr;\n \t}\n+\tif (root->lateral) {\n+\t\tthrow NotImplementedException(\"LATERAL not implemented\");\n+\t}\n \tauto result = make_unique<SubqueryRef>(move(subquery));\n \tresult->alias = TransformAlias(root->alias, result->column_name_alias);\n \tif (root->sample) {\ndiff --git a/tools/odbc/include/odbc_diagnostic.hpp b/tools/odbc/include/odbc_diagnostic.hpp\nindex d1381f0a4c25..e521a1862308 100644\n--- a/tools/odbc/include/odbc_diagnostic.hpp\n+++ b/tools/odbc/include/odbc_diagnostic.hpp\n@@ -3,6 +3,7 @@\n \n #include \"duckdb.hpp\"\n #include \"duckdb/common/windows.hpp\"\n+#include \"duckdb/common/enum_class_hash.hpp\"\n \n #include \"sqlext.h\"\n #include \"sqltypes.h\"\n@@ -154,13 +155,6 @@ struct SQLState {\n \tstd::string erro_msg;\n };\n \n-struct EnumClassHash {\n-\ttemplate <typename T>\n-\tstd::size_t operator()(T t) const {\n-\t\treturn static_cast<std::size_t>(t);\n-\t}\n-};\n-\n struct DiagRecord {\n public:\n \texplicit DiagRecord(const std::string &msg, const SQLStateType &sqlstate_type, const std::string &server_name = \"\",\n@@ -207,7 +201,7 @@ class OdbcDiagnostic {\n \tstd::vector<SQLSMALLINT> vec_record_idx;\n \tstatic const std::unordered_map<SQLINTEGER, std::string> MAP_DYNAMIC_FUNCTION;\n \tstatic const std::set<std::string> SET_ODBC3_SUBCLASS_ORIGIN;\n-\tstatic const std::unordered_map<SQLStateType, SQLState, EnumClassHash> MAP_ODBC_SQL_STATES;\n+\tstatic const std::unordered_map<SQLStateType, SQLState, duckdb::EnumClassHash> MAP_ODBC_SQL_STATES;\n \n public:\n \tstatic bool IsDiagRecordField(SQLSMALLINT diag_identifier);\n",
  "test_patch": "diff --git a/test/sql/alter/add_col/test_add_col_incorrect.test b/test/sql/alter/add_col/test_add_col_incorrect.test\nindex bd14e14b7672..5d6bc423b889 100644\n--- a/test/sql/alter/add_col/test_add_col_incorrect.test\n+++ b/test/sql/alter/add_col/test_add_col_incorrect.test\n@@ -11,3 +11,13 @@ INSERT INTO test VALUES (1, 1), (2, 2)\n statement error\n ALTER TABLE test ADD COLUMN i INTEGER\n \n+statement ok\n+CREATE VIEW x(x) AS (SELECT 1)\n+\n+# Cannot add columns to views\n+statement error\n+ALTER VIEW x ADD COLUMN i INTEGER\n+\n+# Multiple alter per statement not supported yet\n+statement error\n+ALTER TABLE i ADD COLUMN j INT, ADD COLUMN k INT\ndiff --git a/test/sql/catalog/dependencies/test_alter_dependency_ownership.test b/test/sql/catalog/dependencies/test_alter_dependency_ownership.test\nindex 66a4f1ec8b81..70afad7621f5 100644\n--- a/test/sql/catalog/dependencies/test_alter_dependency_ownership.test\n+++ b/test/sql/catalog/dependencies/test_alter_dependency_ownership.test\n@@ -91,6 +91,10 @@ CREATE TABLE tablename2 (\n     colname integer\n );\n \n+# owned by specified more than once\n+statement error\n+ALTER SEQUENCE sequence1 OWNED BY tablename OWNED BY tablename2;\n+\n statement ok\n ALTER SEQUENCE sequence1 OWNED BY tablename;\n \ndiff --git a/test/sql/catalog/sequence/test_sequence.test b/test/sql/catalog/sequence/test_sequence.test\nindex a7cfa5f61967..e447905610ed 100644\n--- a/test/sql/catalog/sequence/test_sequence.test\n+++ b/test/sql/catalog/sequence/test_sequence.test\n@@ -489,3 +489,23 @@ select nextval(1 + 1);\n \n statement error\n select currval(true);\n+\n+# max value specified more than once\n+statement error\n+CREATE SEQUENCE wrongseq NO MAXVALUE MAXVALUE 2;\n+\n+# min value specified more than once\n+statement error\n+CREATE SEQUENCE wrongseq MINVALUE 10 MINVALUE 2;\n+\n+# start value specified more than once\n+statement error\n+CREATE SEQUENCE wrongseq START 13 START WITH 3;\n+\n+# cycle value specified more than once\n+statement error\n+CREATE SEQUENCE wrongseq CYCLE MAXVALUE 2 MINVALUE 1 NO CYCLE;\n+\n+# increment value specified more than once\n+statement error\n+CREATE SEQUENCE wrongseq INCREMENT 2 INCREMENT BY -1;\n",
  "problem_statement": "Lateral join issue?\n#### What happens?\r\nHello Duckies! While fuzzing lateral joins in MonetDB, ie got some crashes there :) I see LATERAL join queries are not working how they should be despite being accepted by the parser. I guess this happens because DuckDB is using PostgreSQL parser.\r\n\r\nHere's an example:\r\n`CREATE TABLE rt0 (c0 INT);`\r\n`INSERT INTO rt0 VALUES (1), (2), (3), (NULL);`\r\n`SELECT rt0.c0 FROM rt0 JOIN LATERAL (select rt0.c0 from (select 1) y(y)) AS x(x) ON TRUE;`\r\n\r\nIt should output the rows 1,2,3,NULL\r\n\r\nThis query gives the error: Error: Binder Error: Referenced table \"rt0\" not found!\r\nHowever because it's a lateral join, rt0.c0 can be seen in the joined query.\r\n\r\nEither LATERAL should be disabled, or could be implemented. I guess it shouldn't be difficult. Sadly at the moment I don't have time to make a pull request :(\r\n\r\n#### To Reproduce\r\nCheck the example in the description.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: compiled from tip of master branch.\r\n - DuckDB Client: Shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "If I could upvote the implementation of `LATERAL` twice, I would do it.  Availability of `LATERAL` would turn DuckDB into a *most-promising backend* for our work on the compilation of PL/SQL, recursive UDFs, etc.\r\n\r\nPlease consider it, Duckies!\nLATERAL joins are indeed not yet supported, but definitely \"on the menu\" to be added in a later release. The issue here seems to be that the `LATERAL` flag is ignored rather than throwing an error in the parser as should be the case right now.",
  "created_at": "2022-07-15T10:15:49Z",
  "modified_files": [
    "b/src/include/duckdb/common/enum_class_hash.hpp",
    "src/include/duckdb/parser/parsed_data/create_sequence_info.hpp",
    "src/parser/transform/statement/transform_alter_sequence.cpp",
    "src/parser/transform/statement/transform_alter_table.cpp",
    "src/parser/transform/statement/transform_create_sequence.cpp",
    "src/parser/transform/statement/transform_rename.cpp",
    "src/parser/transform/tableref/transform_subquery.cpp",
    "tools/odbc/include/odbc_diagnostic.hpp"
  ],
  "modified_test_files": [
    "test/sql/alter/add_col/test_add_col_incorrect.test",
    "test/sql/catalog/dependencies/test_alter_dependency_ownership.test",
    "test/sql/catalog/sequence/test_sequence.test"
  ]
}