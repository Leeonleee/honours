{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14229,
  "instance_id": "ClickHouse__ClickHouse-14229",
  "issue_numbers": [
    "14142",
    "14141"
  ],
  "base_commit": "d304d522ccb10b71187bd684caa921ef9ff68a02",
  "patch": "diff --git a/base/common/arithmeticOverflow.h b/base/common/arithmeticOverflow.h\nindex 3dfbdbc1346c..e228af287e21 100644\n--- a/base/common/arithmeticOverflow.h\n+++ b/base/common/arithmeticOverflow.h\n@@ -38,18 +38,18 @@ namespace common\n     }\n \n     template <>\n-    inline bool addOverflow(bInt256 x, bInt256 y, bInt256 & res)\n+    inline bool addOverflow(wInt256 x, wInt256 y, wInt256 & res)\n     {\n         res = x + y;\n-        return (y > 0 && x > std::numeric_limits<bInt256>::max() - y) ||\n-            (y < 0 && x < std::numeric_limits<bInt256>::min() - y);\n+        return (y > 0 && x > std::numeric_limits<wInt256>::max() - y) ||\n+            (y < 0 && x < std::numeric_limits<wInt256>::min() - y);\n     }\n \n     template <>\n-    inline bool addOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)\n+    inline bool addOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n     {\n         res = x + y;\n-        return x > std::numeric_limits<bUInt256>::max() - y;\n+        return x > std::numeric_limits<wUInt256>::max() - y;\n     }\n \n     template <typename T>\n@@ -86,15 +86,15 @@ namespace common\n     }\n \n     template <>\n-    inline bool subOverflow(bInt256 x, bInt256 y, bInt256 & res)\n+    inline bool subOverflow(wInt256 x, wInt256 y, wInt256 & res)\n     {\n         res = x - y;\n-        return (y < 0 && x > std::numeric_limits<bInt256>::max() + y) ||\n-            (y > 0 && x < std::numeric_limits<bInt256>::min() + y);\n+        return (y < 0 && x > std::numeric_limits<wInt256>::max() + y) ||\n+            (y > 0 && x < std::numeric_limits<wInt256>::min() + y);\n     }\n \n     template <>\n-    inline bool subOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)\n+    inline bool subOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n     {\n         res = x - y;\n         return x < y;\n@@ -137,19 +137,19 @@ namespace common\n     }\n \n     template <>\n-    inline bool mulOverflow(bInt256 x, bInt256 y, bInt256 & res)\n+    inline bool mulOverflow(wInt256 x, wInt256 y, wInt256 & res)\n     {\n         res = x * y;\n         if (!x || !y)\n             return false;\n \n-        bInt256 a = (x > 0) ? x : -x;\n-        bInt256 b = (y > 0) ? y : -y;\n+        wInt256 a = (x > 0) ? x : -x;\n+        wInt256 b = (y > 0) ? y : -y;\n         return (a * b) / b != a;\n     }\n \n     template <>\n-    inline bool mulOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)\n+    inline bool mulOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n     {\n         res = x * y;\n         if (!x || !y)\ndiff --git a/base/common/types.h b/base/common/types.h\nindex 0a394de9f5ce..682fe94366cc 100644\n--- a/base/common/types.h\n+++ b/base/common/types.h\n@@ -6,7 +6,7 @@\n #include <string>\n #include <type_traits>\n \n-#include <boost/multiprecision/cpp_int.hpp>\n+#include <common/wide_integer.h>\n \n using Int8 = int8_t;\n using Int16 = int16_t;\n@@ -25,12 +25,11 @@ using UInt64 = uint64_t;\n \n using Int128 = __int128;\n \n-/// We have to use 127 and 255 bit integers to safe a bit for a sign serialization\n-//using bInt256 = boost::multiprecision::int256_t;\n-using bInt256 = boost::multiprecision::number<boost::multiprecision::cpp_int_backend<\n-    255, 255, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >;\n-using bUInt256 = boost::multiprecision::uint256_t;\n+using wInt256 = std::wide_integer<256, signed>;\n+using wUInt256 = std::wide_integer<256, unsigned>;\n \n+static_assert(sizeof(wInt256) == 32);\n+static_assert(sizeof(wUInt256) == 32);\n \n using String = std::string;\n \n@@ -44,7 +43,7 @@ struct is_signed\n };\n \n template <> struct is_signed<Int128> { static constexpr bool value = true; };\n-template <> struct is_signed<bInt256> { static constexpr bool value = true; };\n+template <> struct is_signed<wInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_signed_v = is_signed<T>::value;\n@@ -55,7 +54,7 @@ struct is_unsigned\n     static constexpr bool value = std::is_unsigned_v<T>;\n };\n \n-template <> struct is_unsigned<bUInt256> { static constexpr bool value = true; };\n+template <> struct is_unsigned<wUInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_unsigned_v = is_unsigned<T>::value;\n@@ -69,8 +68,8 @@ struct is_integer\n };\n \n template <> struct is_integer<Int128> { static constexpr bool value = true; };\n-template <> struct is_integer<bInt256> { static constexpr bool value = true; };\n-template <> struct is_integer<bUInt256> { static constexpr bool value = true; };\n+template <> struct is_integer<wInt256> { static constexpr bool value = true; };\n+template <> struct is_integer<wUInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_integer_v = is_integer<T>::value;\n@@ -93,9 +92,9 @@ struct make_unsigned\n     typedef std::make_unsigned_t<T> type;\n };\n \n-template <> struct make_unsigned<__int128> { using type = unsigned __int128; };\n-template <> struct make_unsigned<bInt256>  { using type = bUInt256; };\n-template <> struct make_unsigned<bUInt256> { using type = bUInt256; };\n+template <> struct make_unsigned<Int128> { using type = unsigned __int128; };\n+template <> struct make_unsigned<wInt256>  { using type = wUInt256; };\n+template <> struct make_unsigned<wUInt256> { using type = wUInt256; };\n \n template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;\n \n@@ -105,8 +104,8 @@ struct make_signed\n     typedef std::make_signed_t<T> type;\n };\n \n-template <> struct make_signed<bInt256>  { typedef bInt256 type; };\n-template <> struct make_signed<bUInt256> { typedef bInt256 type; };\n+template <> struct make_signed<wInt256>  { using type = wInt256; };\n+template <> struct make_signed<wUInt256> { using type = wInt256; };\n \n template <typename T> using make_signed_t = typename make_signed<T>::type;\n \n@@ -116,8 +115,8 @@ struct is_big_int\n     static constexpr bool value = false;\n };\n \n-template <> struct is_big_int<bUInt256> { static constexpr bool value = true; };\n-template <> struct is_big_int<bInt256> { static constexpr bool value = true; };\n+template <> struct is_big_int<wInt256> { static constexpr bool value = true; };\n+template <> struct is_big_int<wUInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_big_int_v = is_big_int<T>::value;\n@@ -125,14 +124,11 @@ inline constexpr bool is_big_int_v = is_big_int<T>::value;\n template <typename T>\n inline std::string bigintToString(const T & x)\n {\n-    return x.str();\n+    return to_string(x);\n }\n \n template <typename To, typename From>\n inline To bigint_cast(const From & x [[maybe_unused]])\n {\n-    if constexpr ((is_big_int_v<From> && std::is_same_v<To, UInt8>) || (is_big_int_v<To> && std::is_same_v<From, UInt8>))\n-        return static_cast<uint8_t>(x);\n-    else\n-        return static_cast<To>(x);\n+    return static_cast<To>(x);\n }\ndiff --git a/base/common/wide_integer.h b/base/common/wide_integer.h\nnew file mode 100644\nindex 000000000000..67d0b3f04da1\n--- /dev/null\n+++ b/base/common/wide_integer.h\n@@ -0,0 +1,249 @@\n+#pragma once\n+\n+///////////////////////////////////////////////////////////////\n+//  Distributed under the Boost Software License, Version 1.0.\n+//  (See at http://www.boost.org/LICENSE_1_0.txt)\n+///////////////////////////////////////////////////////////////\n+\n+/*  Divide and multiply\n+ *\n+ *\n+ * Copyright (c) 2008\n+ * Evan Teran\n+ *\n+ * Permission to use, copy, modify, and distribute this software and its\n+ * documentation for any purpose and without fee is hereby granted, provided\n+ * that the above copyright notice appears in all copies and that both the\n+ * copyright notice and this permission notice appear in supporting\n+ * documentation, and that the same name not be used in advertising or\n+ * publicity pertaining to distribution of the software without specific,\n+ * written prior permission. We make no representations about the\n+ * suitability this software for any purpose. It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include <climits> // CHAR_BIT\n+#include <cmath>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+namespace std\n+{\n+template <size_t Bits, typename Signed>\n+class wide_integer;\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+struct common_type<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>;\n+\n+template <size_t Bits, typename Signed, typename Arithmetic>\n+struct common_type<wide_integer<Bits, Signed>, Arithmetic>;\n+\n+template <typename Arithmetic, size_t Bits, typename Signed>\n+struct common_type<Arithmetic, wide_integer<Bits, Signed>>;\n+\n+template <size_t Bits, typename Signed>\n+class wide_integer\n+{\n+public:\n+    using base_type = uint8_t;\n+    using signed_base_type = int8_t;\n+\n+    // ctors\n+    wide_integer() = default;\n+\n+    template <typename T>\n+    constexpr wide_integer(T rhs) noexcept;\n+    template <typename T>\n+    constexpr wide_integer(std::initializer_list<T> il) noexcept;\n+\n+    // assignment\n+    template <size_t Bits2, typename Signed2>\n+    constexpr wide_integer<Bits, Signed> & operator=(const wide_integer<Bits2, Signed2> & rhs) noexcept;\n+\n+    template <typename Arithmetic>\n+    constexpr wide_integer<Bits, Signed> & operator=(Arithmetic rhs) noexcept;\n+\n+    template <typename Arithmetic>\n+    constexpr wide_integer<Bits, Signed> & operator*=(const Arithmetic & rhs);\n+\n+    template <typename Arithmetic>\n+    constexpr wide_integer<Bits, Signed> & operator/=(const Arithmetic & rhs);\n+\n+    template <typename Arithmetic>\n+    constexpr wide_integer<Bits, Signed> & operator+=(const Arithmetic & rhs) noexcept(is_same<Signed, unsigned>::value);\n+\n+    template <typename Arithmetic>\n+    constexpr wide_integer<Bits, Signed> & operator-=(const Arithmetic & rhs) noexcept(is_same<Signed, unsigned>::value);\n+\n+    template <typename Integral>\n+    constexpr wide_integer<Bits, Signed> & operator%=(const Integral & rhs);\n+\n+    template <typename Integral>\n+    constexpr wide_integer<Bits, Signed> & operator&=(const Integral & rhs) noexcept;\n+\n+    template <typename Integral>\n+    constexpr wide_integer<Bits, Signed> & operator|=(const Integral & rhs) noexcept;\n+\n+    template <typename Integral>\n+    constexpr wide_integer<Bits, Signed> & operator^=(const Integral & rhs) noexcept;\n+\n+    constexpr wide_integer<Bits, Signed> & operator<<=(int n);\n+    constexpr wide_integer<Bits, Signed> & operator>>=(int n) noexcept;\n+\n+    constexpr wide_integer<Bits, Signed> & operator++() noexcept(is_same<Signed, unsigned>::value);\n+    constexpr wide_integer<Bits, Signed> operator++(int) noexcept(is_same<Signed, unsigned>::value);\n+    constexpr wide_integer<Bits, Signed> & operator--() noexcept(is_same<Signed, unsigned>::value);\n+    constexpr wide_integer<Bits, Signed> operator--(int) noexcept(is_same<Signed, unsigned>::value);\n+\n+    // observers\n+\n+    constexpr explicit operator bool() const noexcept;\n+\n+    template <class T>\n+    using __integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;\n+\n+    template <class T, class = __integral_not_wide_integer_class<T>>\n+    constexpr operator T() const noexcept;\n+\n+    constexpr operator long double() const noexcept;\n+    constexpr operator double() const noexcept;\n+    constexpr operator float() const noexcept;\n+\n+    struct _impl;\n+\n+private:\n+    template <size_t Bits2, typename Signed2>\n+    friend class wide_integer;\n+\n+    friend class numeric_limits<wide_integer<Bits, signed>>;\n+    friend class numeric_limits<wide_integer<Bits, unsigned>>;\n+\n+    base_type m_arr[_impl::arr_size];\n+};\n+\n+template <typename T>\n+static constexpr bool ArithmeticConcept() noexcept;\n+template <class T1, class T2>\n+using __only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;\n+\n+template <typename T>\n+static constexpr bool IntegralConcept() noexcept;\n+template <class T, class T2>\n+using __only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;\n+\n+// Unary operators\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator~(const wide_integer<Bits, Signed> & lhs) noexcept;\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator-(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value);\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator+(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value);\n+\n+// Binary operators\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator*(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator/(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator+(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator-(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator%(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & rhs, const Integral2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator&(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & rhs, const Integral2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator|(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & rhs, const Integral2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator^(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & rhs, const Integral2 & lhs);\n+\n+// TODO: Integral\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, int n) noexcept;\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, int n) noexcept;\n+\n+template <size_t Bits, typename Signed, typename Int, typename = std::enable_if_t<!std::is_same_v<Int, int>>>\n+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, Int n) noexcept\n+{\n+    return lhs << int(n);\n+}\n+template <size_t Bits, typename Signed, typename Int, typename = std::enable_if_t<!std::is_same_v<Int, int>>>\n+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, Int n) noexcept\n+{\n+    return lhs >> int(n);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator<(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator<(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator>(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator>(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator<=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator<=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator>=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator>=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator==(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator==(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator!=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);\n+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+constexpr bool operator!=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n+\n+template <size_t Bits, typename Signed>\n+std::string to_string(const wide_integer<Bits, Signed> & n);\n+\n+template <size_t Bits, typename Signed>\n+struct hash<wide_integer<Bits, Signed>>;\n+\n+}\n+\n+#include \"wide_integer_impl.h\"\ndiff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h\nnew file mode 100644\nindex 000000000000..c77a9120a55a\n--- /dev/null\n+++ b/base/common/wide_integer_impl.h\n@@ -0,0 +1,1301 @@\n+/// Original is here https://github.com/cerevra/int\n+#pragma once\n+\n+#include \"wide_integer.h\"\n+\n+#include <array>\n+#include <cstring>\n+\n+namespace std\n+{\n+#define CT(x) \\\n+    std::common_type_t<std::decay_t<decltype(rhs)>, std::decay_t<decltype(lhs)>> { x }\n+\n+// numeric limits\n+template <size_t Bits, typename Signed>\n+class numeric_limits<wide_integer<Bits, Signed>>\n+{\n+public:\n+    static constexpr bool is_specialized = true;\n+    static constexpr bool is_signed = is_same<Signed, signed>::value;\n+    static constexpr bool is_integer = true;\n+    static constexpr bool is_exact = true;\n+    static constexpr bool has_infinity = false;\n+    static constexpr bool has_quiet_NaN = false;\n+    static constexpr bool has_signaling_NaN = true;\n+    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;\n+    static constexpr bool has_denorm_loss = false;\n+    static constexpr std::float_round_style round_style = std::round_toward_zero;\n+    static constexpr bool is_iec559 = false;\n+    static constexpr bool is_bounded = true;\n+    static constexpr bool is_modulo = true;\n+    static constexpr int digits = Bits - (is_same<Signed, signed>::value ? 1 : 0);\n+    static constexpr int digits10 = digits * 0.30103 /*std::log10(2)*/;\n+    static constexpr int max_digits10 = 0;\n+    static constexpr int radix = 2;\n+    static constexpr int min_exponent = 0;\n+    static constexpr int min_exponent10 = 0;\n+    static constexpr int max_exponent = 0;\n+    static constexpr int max_exponent10 = 0;\n+    static constexpr bool traps = true;\n+    static constexpr bool tinyness_before = false;\n+\n+    static constexpr wide_integer<Bits, Signed> min() noexcept\n+    {\n+        if (is_same<Signed, signed>::value)\n+        {\n+            using T = wide_integer<Bits, signed>;\n+            T res{};\n+            res.m_arr[T::_impl::big(0)] = std::numeric_limits<typename wide_integer<Bits, Signed>::signed_base_type>::min();\n+            return res;\n+        }\n+        return 0;\n+    }\n+\n+    static constexpr wide_integer<Bits, Signed> max() noexcept\n+    {\n+        using T = wide_integer<Bits, Signed>;\n+        T res{};\n+        res.m_arr[T::_impl::big(0)] = is_same<Signed, signed>::value\n+            ? std::numeric_limits<typename wide_integer<Bits, Signed>::signed_base_type>::max()\n+            : std::numeric_limits<typename wide_integer<Bits, Signed>::base_type>::max();\n+        for (int i = 1; i < wide_integer<Bits, Signed>::_impl::arr_size; ++i)\n+        {\n+            res.m_arr[T::_impl::big(i)] = std::numeric_limits<typename wide_integer<Bits, Signed>::base_type>::max();\n+        }\n+        return res;\n+    }\n+\n+    static constexpr wide_integer<Bits, Signed> lowest() noexcept { return min(); }\n+    static constexpr wide_integer<Bits, Signed> epsilon() noexcept { return 0; }\n+    static constexpr wide_integer<Bits, Signed> round_error() noexcept { return 0; }\n+    static constexpr wide_integer<Bits, Signed> infinity() noexcept { return 0; }\n+    static constexpr wide_integer<Bits, Signed> quiet_NaN() noexcept { return 0; }\n+    static constexpr wide_integer<Bits, Signed> signaling_NaN() noexcept { return 0; }\n+    static constexpr wide_integer<Bits, Signed> denorm_min() noexcept { return 0; }\n+};\n+\n+template <typename T>\n+struct IsWideInteger\n+{\n+    static const constexpr bool value = false;\n+};\n+\n+template <size_t Bits, typename Signed>\n+struct IsWideInteger<wide_integer<Bits, Signed>>\n+{\n+    static const constexpr bool value = true;\n+};\n+\n+template <typename T>\n+static constexpr bool ArithmeticConcept() noexcept\n+{\n+    return std::is_arithmetic_v<T> || IsWideInteger<T>::value;\n+}\n+\n+template <typename T>\n+static constexpr bool IntegralConcept() noexcept\n+{\n+    return std::is_integral_v<T> || IsWideInteger<T>::value;\n+}\n+\n+// type traits\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+struct common_type<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>\n+{\n+    using type = std::conditional_t < Bits == Bits2,\n+          wide_integer<\n+              Bits,\n+              std::conditional_t<(std::is_same<Signed, Signed2>::value && std::is_same<Signed2, signed>::value), signed, unsigned>>,\n+          std::conditional_t<Bits2<Bits, wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>>;\n+};\n+\n+template <size_t Bits, typename Signed, typename Arithmetic>\n+struct common_type<wide_integer<Bits, Signed>, Arithmetic>\n+{\n+    static_assert(ArithmeticConcept<Arithmetic>(), \"\");\n+\n+    using type = std::conditional_t<\n+        std::is_floating_point<Arithmetic>::value,\n+        Arithmetic,\n+        std::conditional_t<\n+            sizeof(Arithmetic) < Bits * sizeof(long),\n+            wide_integer<Bits, Signed>,\n+            std::conditional_t<\n+                Bits * sizeof(long) < sizeof(Arithmetic),\n+                Arithmetic,\n+                std::conditional_t<\n+                    Bits * sizeof(long) == sizeof(Arithmetic) && (is_same<Signed, signed>::value || std::is_signed<Arithmetic>::value),\n+                    Arithmetic,\n+                    wide_integer<Bits, Signed>>>>>;\n+};\n+\n+template <typename Arithmetic, size_t Bits, typename Signed>\n+struct common_type<Arithmetic, wide_integer<Bits, Signed>> : std::common_type<wide_integer<Bits, Signed>, Arithmetic>\n+{\n+};\n+\n+template <size_t Bits, typename Signed>\n+struct wide_integer<Bits, Signed>::_impl\n+{\n+    static_assert(Bits % CHAR_BIT == 0, \"=)\");\n+\n+    // utils\n+    static const int base_bits = sizeof(base_type) * CHAR_BIT;\n+    static const int arr_size = Bits / base_bits;\n+    static constexpr size_t _Bits = Bits;\n+    static constexpr bool _is_wide_integer = true;\n+\n+    // The original implementation is big-endian. We need little one.\n+    static constexpr unsigned little(unsigned idx) { return idx; }\n+    static constexpr unsigned big(unsigned idx) { return arr_size - 1 - idx; }\n+    static constexpr unsigned any(unsigned idx) { return idx; }\n+\n+    template <size_t B, class T>\n+    constexpr static bool is_negative(const wide_integer<B, T> & n) noexcept\n+    {\n+        if constexpr (std::is_same_v<T, signed>)\n+            return static_cast<signed_base_type>(n.m_arr[big(0)]) < 0;\n+        else\n+            return false;\n+    }\n+\n+    template <size_t B, class S>\n+    constexpr static wide_integer<B, S> make_positive(const wide_integer<B, S> & n) noexcept\n+    {\n+        return is_negative(n) ? operator_unary_minus(n) : n;\n+    }\n+\n+    template <typename T>\n+    constexpr static auto to_Integral(T f) noexcept\n+    {\n+        if constexpr (std::is_same_v<T, __int128>)\n+            return f;\n+        else if constexpr (std::is_signed_v<T>)\n+            return static_cast<int64_t>(f);\n+        else\n+            return static_cast<uint64_t>(f);\n+    }\n+\n+    template <typename Integral>\n+    constexpr static void wide_integer_from_bultin(wide_integer<Bits, Signed> & self, Integral rhs) noexcept\n+    {\n+        auto r = _impl::to_Integral(rhs);\n+\n+        int r_idx = 0;\n+        for (; static_cast<size_t>(r_idx) < sizeof(Integral) && r_idx < arr_size; ++r_idx)\n+        {\n+            base_type & curr = self.m_arr[little(r_idx)];\n+            base_type curr_rhs = (r >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();\n+            curr = curr_rhs;\n+        }\n+\n+        for (; r_idx < arr_size; ++r_idx)\n+        {\n+            base_type & curr = self.m_arr[little(r_idx)];\n+            curr = r < 0 ? std::numeric_limits<base_type>::max() : 0;\n+        }\n+    }\n+\n+    constexpr static void wide_integer_from_bultin(wide_integer<Bits, Signed> & self, double rhs) noexcept\n+    {\n+        if ((rhs > 0 && rhs < std::numeric_limits<uint64_t>::max()) || (rhs < 0 && rhs > std::numeric_limits<int64_t>::min()))\n+        {\n+            self = to_Integral(rhs);\n+            return;\n+        }\n+\n+        long double r = rhs;\n+        if (r < 0)\n+            r = -r;\n+\n+        size_t count = r / std::numeric_limits<uint64_t>::max();\n+        self = count;\n+        self *= std::numeric_limits<uint64_t>::max();\n+        long double to_diff = count;\n+        to_diff *= std::numeric_limits<uint64_t>::max();\n+\n+        self += to_Integral(r - to_diff);\n+\n+        if (rhs < 0)\n+            self = -self;\n+    }\n+\n+    template <size_t Bits2, typename Signed2>\n+    constexpr static void\n+    wide_integer_from_wide_integer(wide_integer<Bits, Signed> & self, const wide_integer<Bits2, Signed2> & rhs) noexcept\n+    {\n+        //        int Bits_to_copy = std::min(arr_size, rhs.arr_size);\n+        auto rhs_arr_size = wide_integer<Bits2, Signed2>::_impl::arr_size;\n+        int base_elems_to_copy = _impl::arr_size < rhs_arr_size ? _impl::arr_size : rhs_arr_size;\n+        for (int i = 0; i < base_elems_to_copy; ++i)\n+        {\n+            self.m_arr[little(i)] = rhs.m_arr[little(i)];\n+        }\n+        for (int i = 0; i < arr_size - base_elems_to_copy; ++i)\n+        {\n+            self.m_arr[big(i)] = is_negative(rhs) ? std::numeric_limits<base_type>::max() : 0;\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static bool should_keep_size()\n+    {\n+        return sizeof(T) * CHAR_BIT <= Bits;\n+    }\n+\n+    constexpr static wide_integer<Bits, unsigned> shift_left(const wide_integer<Bits, unsigned> & rhs, int n)\n+    {\n+        if (static_cast<size_t>(n) >= base_bits * arr_size)\n+            return 0;\n+        if (n <= 0)\n+            return rhs;\n+\n+        wide_integer<Bits, Signed> lhs = rhs;\n+        int bit_shift = n % base_bits;\n+        unsigned n_bytes = n / base_bits;\n+        if (bit_shift)\n+        {\n+            lhs.m_arr[big(0)] <<= bit_shift;\n+            for (int i = 1; i < arr_size; ++i)\n+            {\n+                lhs.m_arr[big(i - 1)] |= lhs.m_arr[big(i)] >> (base_bits - bit_shift);\n+                lhs.m_arr[big(i)] <<= bit_shift;\n+            }\n+        }\n+        if (n_bytes)\n+        {\n+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)\n+            {\n+                lhs.m_arr[big(i)] = lhs.m_arr[big(i + n_bytes)];\n+            }\n+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)\n+                lhs.m_arr[big(i)] = 0;\n+        }\n+        return lhs;\n+    }\n+\n+    constexpr static wide_integer<Bits, signed> shift_left(const wide_integer<Bits, signed> & rhs, int n)\n+    {\n+        // static_assert(is_negative(rhs), \"shift left for negative lhsbers is underfined!\");\n+        if (is_negative(rhs))\n+            throw std::runtime_error(\"shift left for negative lhsbers is underfined!\");\n+\n+        return wide_integer<Bits, signed>(shift_left(wide_integer<Bits, unsigned>(rhs), n));\n+    }\n+\n+    constexpr static wide_integer<Bits, unsigned> shift_right(const wide_integer<Bits, unsigned> & rhs, int n) noexcept\n+    {\n+        if (static_cast<size_t>(n) >= base_bits * arr_size)\n+            return 0;\n+        if (n <= 0)\n+            return rhs;\n+\n+        wide_integer<Bits, Signed> lhs = rhs;\n+        int bit_shift = n % base_bits;\n+        unsigned n_bytes = n / base_bits;\n+        if (bit_shift)\n+        {\n+            lhs.m_arr[little(0)] >>= bit_shift;\n+            for (int i = 1; i < arr_size; ++i)\n+            {\n+                lhs.m_arr[little(i - 1)] |= lhs.m_arr[little(i)] << (base_bits - bit_shift);\n+                lhs.m_arr[little(i)] >>= bit_shift;\n+            }\n+        }\n+        if (n_bytes)\n+        {\n+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)\n+            {\n+                lhs.m_arr[little(i)] = lhs.m_arr[little(i + n_bytes)];\n+            }\n+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)\n+                lhs.m_arr[little(i)] = 0;\n+        }\n+        return lhs;\n+    }\n+\n+    constexpr static wide_integer<Bits, signed> shift_right(const wide_integer<Bits, signed> & rhs, int n) noexcept\n+    {\n+        if (static_cast<size_t>(n) >= base_bits * arr_size)\n+            return 0;\n+        if (n <= 0)\n+            return rhs;\n+\n+        bool is_neg = is_negative(rhs);\n+        if (!is_neg)\n+            return shift_right(wide_integer<Bits, unsigned>(rhs), n);\n+\n+        wide_integer<Bits, Signed> lhs = rhs;\n+        int bit_shift = n % base_bits;\n+        unsigned n_bytes = n / base_bits;\n+        if (bit_shift)\n+        {\n+            lhs = shift_right(wide_integer<Bits, unsigned>(lhs), bit_shift);\n+            lhs.m_arr[big(0)] |= std::numeric_limits<base_type>::max() << (base_bits - bit_shift);\n+        }\n+        if (n_bytes)\n+        {\n+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)\n+            {\n+                lhs.m_arr[little(i)] = lhs.m_arr[little(i + n_bytes)];\n+            }\n+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)\n+            {\n+                lhs.m_arr[little(i)] = std::numeric_limits<base_type>::max();\n+            }\n+        }\n+        return lhs;\n+    }\n+\n+    template <typename T>\n+    constexpr static wide_integer<Bits, Signed>\n+    operator_plus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        if (rhs < 0)\n+            return _operator_minus_T(lhs, -rhs);\n+        else\n+            return _operator_plus_T(lhs, rhs);\n+    }\n+\n+private:\n+    template <typename T>\n+    constexpr static wide_integer<Bits, Signed>\n+    _operator_minus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        wide_integer<Bits, Signed> res = lhs;\n+\n+        bool is_underflow = false;\n+        int r_idx = 0;\n+        for (; static_cast<size_t>(r_idx) < sizeof(T) && r_idx < arr_size; ++r_idx)\n+        {\n+            base_type & res_i = res.m_arr[little(r_idx)];\n+            base_type curr_rhs = (rhs >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();\n+\n+            if (is_underflow)\n+            {\n+                --res_i;\n+                is_underflow = res_i == std::numeric_limits<base_type>::max();\n+            }\n+\n+            if (res_i < curr_rhs)\n+                is_underflow = true;\n+            res_i -= curr_rhs;\n+        }\n+\n+        if (is_underflow && r_idx < arr_size)\n+        {\n+            --res.m_arr[little(r_idx)];\n+            for (int i = arr_size - 1 - r_idx - 1; i >= 0; --i)\n+            {\n+                if (res.m_arr[big(i + 1)] == std::numeric_limits<base_type>::max())\n+                    --res.m_arr[big(i)];\n+                else\n+                    break;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    template <typename T>\n+    constexpr static wide_integer<Bits, Signed>\n+    _operator_plus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        wide_integer<Bits, Signed> res = lhs;\n+\n+        bool is_overflow = false;\n+        int r_idx = 0;\n+        for (; static_cast<size_t>(r_idx) < sizeof(T) && r_idx < arr_size; ++r_idx)\n+        {\n+            base_type & res_i = res.m_arr[little(r_idx)];\n+            base_type curr_rhs = (rhs >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();\n+\n+            if (is_overflow)\n+            {\n+                ++res_i;\n+                is_overflow = res_i == 0;\n+            }\n+\n+            res_i += curr_rhs;\n+            if (res_i < curr_rhs)\n+                is_overflow = true;\n+        }\n+\n+        if (is_overflow && r_idx < arr_size)\n+        {\n+            ++res.m_arr[little(r_idx)];\n+            for (int i = arr_size - 1 - r_idx - 1; i >= 0; --i)\n+            {\n+                if (res.m_arr[big(i + 1)] == 0)\n+                    ++res.m_arr[big(i)];\n+                else\n+                    break;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+public:\n+    constexpr static wide_integer<Bits, Signed> operator_unary_tilda(const wide_integer<Bits, Signed> & lhs) noexcept\n+    {\n+        wide_integer<Bits, Signed> res{};\n+\n+        for (int i = 0; i < arr_size; ++i)\n+            res.m_arr[any(i)] = ~lhs.m_arr[any(i)];\n+        return res;\n+    }\n+\n+    constexpr static wide_integer<Bits, Signed>\n+    operator_unary_minus(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        return operator_plus_T(operator_unary_tilda(lhs), 1);\n+    }\n+\n+    template <typename T>\n+    constexpr static auto operator_plus(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t = rhs;\n+            if (is_negative(t))\n+                return _operator_minus_wide_integer(lhs, operator_unary_minus(t));\n+            else\n+                return _operator_plus_wide_integer(lhs, t);\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::_impl::operator_plus(\n+                wide_integer<T::_impl::_Bits, Signed>(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static auto operator_minus(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t = rhs;\n+            if (is_negative(t))\n+                return _operator_plus_wide_integer(lhs, operator_unary_minus(t));\n+            else\n+                return _operator_minus_wide_integer(lhs, t);\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::_impl::operator_minus(\n+                wide_integer<T::_impl::_Bits, Signed>(lhs), rhs);\n+        }\n+    }\n+\n+private:\n+    constexpr static wide_integer<Bits, Signed> _operator_minus_wide_integer(\n+        const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits, Signed> & rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        wide_integer<Bits, Signed> res = lhs;\n+\n+        bool is_underflow = false;\n+        for (int idx = 0; idx < arr_size; ++idx)\n+        {\n+            base_type & res_i = res.m_arr[little(idx)];\n+            const base_type rhs_i = rhs.m_arr[little(idx)];\n+\n+            if (is_underflow)\n+            {\n+                --res_i;\n+                is_underflow = res_i == std::numeric_limits<base_type>::max();\n+            }\n+\n+            if (res_i < rhs_i)\n+                is_underflow = true;\n+\n+            res_i -= rhs_i;\n+        }\n+\n+        return res;\n+    }\n+\n+    constexpr static wide_integer<Bits, Signed> _operator_plus_wide_integer(\n+        const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits, Signed> & rhs) noexcept(is_same<Signed, unsigned>::value)\n+    {\n+        wide_integer<Bits, Signed> res = lhs;\n+\n+        bool is_overflow = false;\n+        for (int idx = 0; idx < arr_size; ++idx)\n+        {\n+            base_type & res_i = res.m_arr[little(idx)];\n+            const base_type rhs_i = rhs.m_arr[little(idx)];\n+\n+            if (is_overflow)\n+            {\n+                ++res_i;\n+                is_overflow = res_i == 0;\n+            }\n+\n+            res_i += rhs_i;\n+\n+            if (res_i < rhs_i)\n+                is_overflow = true;\n+        }\n+\n+        return res;\n+    }\n+\n+public:\n+    template <typename T>\n+    constexpr static auto operator_star(const wide_integer<Bits, Signed> & lhs, const T & rhs)\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            const wide_integer<Bits, unsigned> a = make_positive(lhs);\n+            wide_integer<Bits, unsigned> t = make_positive(wide_integer<Bits, Signed>(rhs));\n+\n+            wide_integer<Bits, Signed> res = 0;\n+\n+            for (size_t i = 0; i < arr_size * base_bits; ++i)\n+            {\n+                if (t.m_arr[little(0)] & 1)\n+                    res = operator_plus(res, shift_left(a, i));\n+\n+                t = shift_right(t, 1);\n+            }\n+\n+            if (is_same<Signed, signed>::value && is_negative(wide_integer<Bits, Signed>(rhs)) != is_negative(lhs))\n+                res = operator_unary_minus(res);\n+\n+            return res;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_star(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static bool operator_more(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            // static_assert(Signed == std::is_signed<T>::value,\n+            //               \"warning: operator_more: comparison of integers of different signs\");\n+\n+            wide_integer<Bits, Signed> t = rhs;\n+\n+            if (std::numeric_limits<T>::is_signed && (is_negative(lhs) != is_negative(t)))\n+                return is_negative(t);\n+\n+            for (int i = 0; i < arr_size; ++i)\n+            {\n+                if (lhs.m_arr[big(i)] != t.m_arr[big(i)])\n+                    return lhs.m_arr[big(i)] > t.m_arr[big(i)];\n+            }\n+\n+            return false;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_more(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static bool operator_less(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            // static_assert(Signed == std::is_signed<T>::value,\n+            //               \"warning: operator_less: comparison of integers of different signs\");\n+\n+            wide_integer<Bits, Signed> t = rhs;\n+\n+            if (std::numeric_limits<T>::is_signed && (is_negative(lhs) != is_negative(t)))\n+                return is_negative(lhs);\n+\n+            for (int i = 0; i < arr_size; ++i)\n+                if (lhs.m_arr[big(i)] != t.m_arr[big(i)])\n+                    return lhs.m_arr[big(i)] < t.m_arr[big(i)];\n+\n+            return false;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_less(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static bool operator_eq(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t = rhs;\n+\n+            for (int i = 0; i < arr_size; ++i)\n+                if (lhs.m_arr[any(i)] != t.m_arr[any(i)])\n+                    return false;\n+\n+            return true;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_eq(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static auto operator_pipe(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t = rhs;\n+            wide_integer<Bits, Signed> res = lhs;\n+\n+            for (int i = 0; i < arr_size; ++i)\n+                res.m_arr[any(i)] |= t.m_arr[any(i)];\n+            return res;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_pipe(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static auto operator_amp(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t = rhs;\n+            wide_integer<Bits, Signed> res = lhs;\n+\n+            for (int i = 0; i < arr_size; ++i)\n+                res.m_arr[any(i)] &= t.m_arr[any(i)];\n+            return res;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_amp(T(lhs), rhs);\n+        }\n+    }\n+\n+private:\n+    template <typename T>\n+    constexpr static void divide(const T & lhserator, const T & denominator, T & quotient, T & remainder)\n+    {\n+        bool is_zero = true;\n+        for (auto c : denominator.m_arr)\n+        {\n+            if (c != 0)\n+            {\n+                is_zero = false;\n+                break;\n+            }\n+        }\n+\n+        if (is_zero)\n+            throw std::domain_error(\"divide by zero\");\n+\n+        T n = lhserator;\n+        T d = denominator;\n+        T x = 1;\n+        T answer = 0;\n+\n+        while (!operator_more(d, n) && operator_eq(operator_amp(shift_right(d, base_bits * arr_size - 1), 1), 0))\n+        {\n+            x = shift_left(x, 1);\n+            d = shift_left(d, 1);\n+        }\n+\n+        while (!operator_eq(x, 0))\n+        {\n+            if (!operator_more(d, n))\n+            {\n+                n = operator_minus(n, d);\n+                answer = operator_pipe(answer, x);\n+            }\n+\n+            x = shift_right(x, 1);\n+            d = shift_right(d, 1);\n+        }\n+\n+        quotient = answer;\n+        remainder = n;\n+    }\n+\n+public:\n+    template <typename T>\n+    constexpr static auto operator_slash(const wide_integer<Bits, Signed> & lhs, const T & rhs)\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> o = rhs;\n+            wide_integer<Bits, Signed> quotient{}, remainder{};\n+            divide(make_positive(lhs), make_positive(o), quotient, remainder);\n+\n+            if (is_same<Signed, signed>::value && is_negative(o) != is_negative(lhs))\n+                quotient = operator_unary_minus(quotient);\n+\n+            return quotient;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::operator_slash(T(lhs), rhs);\n+        }\n+    }\n+\n+    template <typename T>\n+    constexpr static auto operator_percent(const wide_integer<Bits, Signed> & lhs, const T & rhs)\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> o = rhs;\n+            wide_integer<Bits, Signed> quotient{}, remainder{};\n+            divide(make_positive(lhs), make_positive(o), quotient, remainder);\n+\n+            if (is_same<Signed, signed>::value && is_negative(lhs))\n+                remainder = operator_unary_minus(remainder);\n+\n+            return remainder;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::operator_percent(T(lhs), rhs);\n+        }\n+    }\n+\n+    // ^\n+    template <typename T>\n+    constexpr static auto operator_circumflex(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    {\n+        if constexpr (should_keep_size<T>())\n+        {\n+            wide_integer<Bits, Signed> t(rhs);\n+            wide_integer<Bits, Signed> res = lhs;\n+\n+            for (int i = 0; i < arr_size; ++i)\n+                res.m_arr[any(i)] ^= t.m_arr[any(i)];\n+            return res;\n+        }\n+        else\n+        {\n+            static_assert(T::_impl::_is_wide_integer, \"\");\n+            return T::operator_circumflex(T(lhs), rhs);\n+        }\n+    }\n+\n+    constexpr static wide_integer<Bits, Signed> from_str(const char * c)\n+    {\n+        wide_integer<Bits, Signed> res = 0;\n+\n+        bool is_neg = is_same<Signed, signed>::value && *c == '-';\n+        if (is_neg)\n+            ++c;\n+\n+        if (*c == '0' && (*(c + 1) == 'x' || *(c + 1) == 'X'))\n+        { // hex\n+            ++c;\n+            ++c;\n+            while (*c)\n+            {\n+                if (*c >= '0' && *c <= '9')\n+                {\n+                    res = operator_star(res, 16U);\n+                    res = operator_plus_T(res, *c - '0');\n+                    ++c;\n+                }\n+                else if (*c >= 'a' && *c <= 'f')\n+                {\n+                    res = operator_star(res, 16U);\n+                    res = operator_plus_T(res, *c - 'a' + 10U);\n+                    ++c;\n+                }\n+                else if (*c >= 'A' && *c <= 'F')\n+                { // tolower must be used, but it is not constexpr\n+                    res = operator_star(res, 16U);\n+                    res = operator_plus_T(res, *c - 'A' + 10U);\n+                    ++c;\n+                }\n+                else\n+                    throw std::runtime_error(\"invalid char from\");\n+            }\n+        }\n+        else\n+        { // dec\n+            while (*c)\n+            {\n+                if (*c < '0' || *c > '9')\n+                    throw std::runtime_error(\"invalid char from\");\n+\n+                res = operator_star(res, 10U);\n+                res = operator_plus_T(res, *c - '0');\n+                ++c;\n+            }\n+        }\n+\n+        if (is_neg)\n+            res = operator_unary_minus(res);\n+\n+        return res;\n+    }\n+};\n+\n+// Members\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed>::wide_integer(T rhs) noexcept\n+    : m_arr{}\n+{\n+    if constexpr (IsWideInteger<T>::value)\n+        _impl::wide_integer_from_wide_integer(*this, rhs);\n+    else\n+        _impl::wide_integer_from_bultin(*this, rhs);\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed>::wide_integer(std::initializer_list<T> il) noexcept\n+    : m_arr{}\n+{\n+    if (il.size() == 1)\n+    {\n+        if constexpr (IsWideInteger<T>::value)\n+            _impl::wide_integer_from_wide_integer(*this, *il.begin());\n+        else\n+            _impl::wide_integer_from_bultin(*this, *il.begin());\n+    }\n+    else\n+        _impl::wide_integer_from_bultin(*this, 0);\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <size_t Bits2, typename Signed2>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator=(const wide_integer<Bits2, Signed2> & rhs) noexcept\n+{\n+    _impl::wide_integer_from_wide_integer(*this, rhs);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator=(T rhs) noexcept\n+{\n+    _impl::wide_integer_from_bultin(*this, rhs);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator*=(const T & rhs)\n+{\n+    *this = *this * rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator/=(const T & rhs)\n+{\n+    *this = *this / rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator+=(const T & rhs) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    *this = *this + rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator-=(const T & rhs) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    *this = *this - rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator%=(const T & rhs)\n+{\n+    *this = *this % rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator&=(const T & rhs) noexcept\n+{\n+    *this = *this & rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator|=(const T & rhs) noexcept\n+{\n+    *this = *this | rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <typename T>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator^=(const T & rhs) noexcept\n+{\n+    *this = *this ^ rhs;\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator<<=(int n)\n+{\n+    *this = _impl::shift_left(*this, n);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator>>=(int n) noexcept\n+{\n+    *this = _impl::shift_right(*this, n);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator++() noexcept(is_same<Signed, unsigned>::value)\n+{\n+    *this = _impl::operator_plus(*this, 1);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> wide_integer<Bits, Signed>::operator++(int) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    auto tmp = *this;\n+    *this = _impl::operator_plus(*this, 1);\n+    return tmp;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator--() noexcept(is_same<Signed, unsigned>::value)\n+{\n+    *this = _impl::operator_minus(*this, 1);\n+    return *this;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> wide_integer<Bits, Signed>::operator--(int) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    auto tmp = *this;\n+    *this = _impl::operator_minus(*this, 1);\n+    return tmp;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed>::operator bool() const noexcept\n+{\n+    return !_impl::operator_eq(*this, 0);\n+}\n+\n+template <size_t Bits, typename Signed>\n+template <class T, class>\n+constexpr wide_integer<Bits, Signed>::operator T() const noexcept\n+{\n+    static_assert(std::numeric_limits<T>::is_integer, \"\");\n+    T res = 0;\n+    for (size_t r_idx = 0; r_idx < _impl::arr_size && r_idx < sizeof(T); ++r_idx)\n+    {\n+        res |= (T(m_arr[_impl::little(r_idx)]) << (_impl::base_bits * r_idx));\n+    }\n+    return res;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed>::operator long double() const noexcept\n+{\n+    if (_impl::operator_eq(*this, 0))\n+        return 0;\n+\n+    wide_integer<Bits, Signed> tmp = *this;\n+    if (_impl::is_negative(*this))\n+        tmp = -tmp;\n+\n+    long double res = 0;\n+    for (size_t idx = 0; idx < _impl::arr_size; ++idx)\n+    {\n+        long double t = res;\n+        res *= std::numeric_limits<base_type>::max();\n+        res += t;\n+        res += tmp.m_arr[_impl::big(idx)];\n+    }\n+\n+    if (_impl::is_negative(*this))\n+        res = -res;\n+\n+    return res;\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed>::operator double() const noexcept\n+{\n+    return static_cast<long double>(*this);\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed>::operator float() const noexcept\n+{\n+    return static_cast<long double>(*this);\n+}\n+\n+// Unary operators\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator~(const wide_integer<Bits, Signed> & lhs) noexcept\n+{\n+    return wide_integer<Bits, Signed>::_impl::operator_unary_tilda(lhs);\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator-(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    return wide_integer<Bits, Signed>::_impl::operator_unary_minus(lhs);\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator+(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)\n+{\n+    return lhs;\n+}\n+\n+// Binary operators\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator*(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_star(lhs, rhs);\n+}\n+\n+template <typename Arithmetic, typename Arithmetic2, class>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) * CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator/(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_slash(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) / CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator+(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_plus(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) + CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator-(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_minus(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) - CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator%(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_percent(lhs, rhs);\n+}\n+template <typename Integral, typename Integral2, class>\n+std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & lhs, const Integral2 & rhs)\n+{\n+    return CT(lhs) % CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator&(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_amp(lhs, rhs);\n+}\n+template <typename Integral, typename Integral2, class>\n+std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & lhs, const Integral2 & rhs)\n+{\n+    return CT(lhs) & CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator|(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_pipe(lhs, rhs);\n+}\n+template <typename Integral, typename Integral2, class>\n+std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & lhs, const Integral2 & rhs)\n+{\n+    return CT(lhs) | CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr\n+operator^(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_circumflex(lhs, rhs);\n+}\n+template <typename Integral, typename Integral2, class>\n+std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & lhs, const Integral2 & rhs)\n+{\n+    return CT(lhs) ^ CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, int n) noexcept\n+{\n+    return wide_integer<Bits, Signed>::_impl::shift_left(lhs, n);\n+}\n+template <size_t Bits, typename Signed>\n+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, int n) noexcept\n+{\n+    return wide_integer<Bits, Signed>::_impl::shift_right(lhs, n);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator<(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_less(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator<(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) < CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator>(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator>(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) > CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator<=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_less(lhs, rhs)\n+        || std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator<=(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) <= CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator>=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs)\n+        || std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator>=(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) >= CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator==(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator==(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) == CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n+constexpr bool operator!=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)\n+{\n+    return !std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);\n+}\n+template <typename Arithmetic, typename Arithmetic2, class>\n+constexpr bool operator!=(const Arithmetic & lhs, const Arithmetic2 & rhs)\n+{\n+    return CT(lhs) != CT(rhs);\n+}\n+\n+template <size_t Bits, typename Signed>\n+inline std::string to_string(const wide_integer<Bits, Signed> & n)\n+{\n+    std::string res;\n+    if (wide_integer<Bits, Signed>::_impl::operator_eq(n, 0U))\n+        return \"0\";\n+\n+    wide_integer<Bits, unsigned> t;\n+    bool is_neg = wide_integer<Bits, Signed>::_impl::is_negative(n);\n+    if (is_neg)\n+        t = wide_integer<Bits, Signed>::_impl::operator_unary_minus(n);\n+    else\n+        t = n;\n+\n+    while (!wide_integer<Bits, unsigned>::_impl::operator_eq(t, 0U))\n+    {\n+        res.insert(res.begin(), '0' + char(wide_integer<Bits, unsigned>::_impl::operator_percent(t, 10U)));\n+        t = wide_integer<Bits, unsigned>::_impl::operator_slash(t, 10U);\n+    }\n+\n+    if (is_neg)\n+        res.insert(res.begin(), '-');\n+    return res;\n+}\n+\n+template <size_t Bits, typename Signed>\n+struct hash<wide_integer<Bits, Signed>>\n+{\n+    std::size_t operator()(const wide_integer<Bits, Signed> & lhs) const\n+    {\n+        static_assert(Bits % (sizeof(size_t) * 8) == 0);\n+\n+        const auto * ptr = reinterpret_cast<const size_t *>(lhs.m_arr);\n+        unsigned count = Bits / (sizeof(size_t) * 8);\n+\n+        size_t res = 0;\n+        for (unsigned i = 0; i < count; ++i)\n+            res ^= ptr[i];\n+        return hash<size_t>()(res);\n+    }\n+};\n+\n+#undef CT\n+}\ndiff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex 11ab294c1a3e..c33ab34b541a 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -126,7 +126,7 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T\n \n     bool isNumeric() const override { return false; }\n     bool canBeInsideNullable() const override { return true; }\n-    bool isFixedAndContiguous() const override { return is_POD; }\n+    bool isFixedAndContiguous() const override { return true; }\n     size_t sizeOfValueIfFixed() const override { return sizeof(T); }\n \n     size_t size() const override { return data.size(); }\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex d2c4846193ca..1090de556a09 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -12,11 +12,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int NOT_IMPLEMENTED;\n-}\n-\n /** Stuff for comparing numbers.\n   * Integer values are compared as usual.\n   * Floating-point numbers are compared this way that NaNs always end up at the end\n@@ -298,23 +293,17 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n     void gather(ColumnGathererStream & gatherer_stream) override;\n \n     bool canBeInsideNullable() const override { return true; }\n-    bool isFixedAndContiguous() const override { return is_POD; }\n+    bool isFixedAndContiguous() const override { return true; }\n     size_t sizeOfValueIfFixed() const override { return sizeof(T); }\n \n     StringRef getRawData() const override\n     {\n-        if constexpr (is_POD)\n-            return StringRef(reinterpret_cast<const char*>(data.data()), byteSize());\n-        else\n-            throw Exception(\"getRawData() is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n+        return StringRef(reinterpret_cast<const char*>(data.data()), byteSize());\n     }\n \n     StringRef getDataAt(size_t n) const override\n     {\n-        if constexpr (is_POD)\n-            return StringRef(reinterpret_cast<const char *>(&data[n]), sizeof(data[n]));\n-        else\n-            throw Exception(\"getDataAt() is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n+        return StringRef(reinterpret_cast<const char *>(&data[n]), sizeof(data[n]));\n     }\n \n     bool structureEquals(const IColumn & rhs) const override\ndiff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h\nindex 1d850ab2d327..c561933ab809 100644\n--- a/src/Common/HashTable/Hash.h\n+++ b/src/Common/HashTable/Hash.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Core/Types.h>\n+#include <Core/BigInt.h>\n #include <Common/UInt128.h>\n #include <common/unaligned.h>\n \n@@ -89,8 +90,7 @@ template <typename T>\n inline typename std::enable_if<is_big_int_v<T>, DB::UInt64>::type\n intHashCRC32(const T & x, DB::UInt64 updated_value)\n {\n-    std::vector<UInt64> parts;\n-    export_bits(x, std::back_inserter(parts), sizeof(UInt64), false);\n+    std::vector<UInt64> parts = DB::BigInt<T>::toIntArray(x);\n     for (const auto & part : parts)\n         updated_value = intHashCRC32(part, updated_value);\n \n@@ -199,7 +199,7 @@ inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> ke\n     {\n         return intHash64(key.low ^ key.high);\n     }\n-    else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)\n+    else if constexpr (is_big_int_v<T> && sizeof(T) == 32)\n     {\n         return intHash64(static_cast<UInt64>(key) ^\n             static_cast<UInt64>(key >> 64) ^\n@@ -256,7 +256,7 @@ inline size_t hashCRC32(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> key)\n     {\n         return intHashCRC32(key.low ^ key.high);\n     }\n-    else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)\n+    else if constexpr (is_big_int_v<T> && sizeof(T) == 32)\n     {\n         return intHashCRC32(static_cast<UInt64>(key) ^\n             static_cast<UInt64>(key >> 64) ^\n@@ -358,7 +358,7 @@ struct IntHash32\n         {\n             return intHash32<salt>(key.low ^ key.high);\n         }\n-        else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)\n+        else if constexpr (is_big_int_v<T> && sizeof(T) == 32)\n         {\n             return intHash32<salt>(static_cast<UInt64>(key) ^\n                 static_cast<UInt64>(key >> 64) ^\ndiff --git a/src/Common/SipHash.h b/src/Common/SipHash.h\nindex df4c09da6d9e..f4f869516523 100644\n--- a/src/Common/SipHash.h\n+++ b/src/Common/SipHash.h\n@@ -148,7 +148,7 @@ class SipHash\n     }\n \n     template <typename T>\n-    std::enable_if_t<is_big_int_v<T>, void> update(const T & x)\n+    std::enable_if_t<is_big_int_v<T> && !std::has_unique_object_representations_v<T>, void> update(const T & x)\n     {\n         update(DB::BigInt<T>::serialize(x));\n     }\n@@ -213,7 +213,7 @@ std::enable_if_t<std::has_unique_object_representations_v<T>, UInt64> sipHash64(\n }\n \n template <typename T>\n-std::enable_if_t<(std::is_floating_point_v<T> || is_big_int_v<T>), UInt64> sipHash64(const T & x)\n+std::enable_if_t<(std::is_floating_point_v<T> || (is_big_int_v<T> && !std::has_unique_object_representations_v<T>)), UInt64> sipHash64(const T & x)\n {\n     SipHash hash;\n     hash.update(x);\ndiff --git a/src/Common/UInt128.h b/src/Common/UInt128.h\nindex 2b1177e970c5..3944d8073c26 100644\n--- a/src/Common/UInt128.h\n+++ b/src/Common/UInt128.h\n@@ -67,6 +67,11 @@ struct UInt128\n     bool inline operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }\n     bool inline operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }\n \n+    bool inline operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }\n+    bool inline operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }\n+    bool inline operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }\n+    bool inline operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }\n+\n     template <typename T> bool inline operator== (const T rhs) const { return *this == UInt128(rhs); }\n     template <typename T> bool inline operator!= (const T rhs) const { return *this != UInt128(rhs); }\n     template <typename T> bool inline operator>= (const T rhs) const { return *this >= UInt128(rhs); }\ndiff --git a/src/Common/intExp.h b/src/Common/intExp.h\nindex d585eaa9c675..8a52015c54a5 100644\n--- a/src/Common/intExp.h\n+++ b/src/Common/intExp.h\n@@ -138,9 +138,9 @@ constexpr inline Int128 exp10_i128(int x)\n }\n \n \n-inline bInt256 exp10_i256(int x)\n+inline wInt256 exp10_i256(int x)\n {\n-    using Int256 = bInt256;\n+    using Int256 = wInt256;\n     static constexpr Int256 i10e18{1000000000000000000ll};\n     static const Int256 values[] = {\n         static_cast<Int256>(1ll),\ndiff --git a/src/Core/BigInt.h b/src/Core/BigInt.h\nindex f1da96d330a2..5abd71100629 100644\n--- a/src/Core/BigInt.h\n+++ b/src/Core/BigInt.h\n@@ -7,46 +7,15 @@ namespace DB\n {\n \n template <typename T>\n-struct BigIntPayload\n+struct BigInt\n {\n-    static_assert(!is_big_int_v<T>);\n-    static constexpr size_t size = 0;\n-};\n-\n-template <> struct BigIntPayload<bUInt256> { static constexpr size_t size = 32; };\n-\n-template <> struct BigIntPayload<bInt256>\n-{\n-    using UnsingedType = bUInt256;\n+    static_assert(sizeof(T) == 32);\n     static constexpr size_t size = 32;\n-};\n-\n-template <typename T>\n-struct BigInt : BigIntPayload<T>\n-{\n-    using BigIntPayload<T>::size;\n-\n-    static constexpr size_t lastBit()\n-    {\n-        return size * 8 - 1;\n-    }\n \n     static StringRef serialize(const T & x, char * pos)\n     {\n-        if constexpr (is_signed_v<T>)\n-        {\n-            using UnsignedT = typename BigIntPayload<T>::UnsingedType;\n-\n-            if (x < 0)\n-            {\n-                UnsignedT unsigned_x = UnsignedT{0} - static_cast<UnsignedT>(-x);\n-                export_bits(unsigned_x, pos, 8, false);\n-            }\n-            else\n-                export_bits(x, pos, 8, false);\n-        }\n-        else\n-            export_bits(x, pos, 8, false);\n+        //unalignedStore<T>(pos, x);\n+        memcpy(pos, &x, size);\n         return StringRef(pos, size);\n     }\n \n@@ -59,24 +28,20 @@ struct BigInt : BigIntPayload<T>\n \n     static T deserialize(const char * pos)\n     {\n-        if constexpr (is_signed_v<T>)\n-        {\n-            using UnsignedT = typename BigIntPayload<T>::UnsingedType;\n-\n-            UnsignedT unsigned_x;\n-            import_bits(unsigned_x, pos, pos + size, false);\n+        //return unalignedLoad<T>(pos);\n+        T res;\n+        memcpy(&res, pos, size);\n+        return res;\n+    }\n \n-            bool is_negative = bit_test(unsigned_x, lastBit());\n-            if (is_negative)\n-                unsigned_x = UnsignedT{0} - unsigned_x;\n-            return static_cast<T>(unsigned_x);\n-        }\n-        else\n-        {\n-            T x;\n-            import_bits(x, pos, pos + size, false);\n-            return x;\n-        }\n+    static std::vector<UInt64> toIntArray(const T & x)\n+    {\n+        std::vector<UInt64> parts(4, 0);\n+        parts[0] = UInt64(x);\n+        parts[1] = UInt64(x >> 64);\n+        parts[2] = UInt64(x >> 128);\n+        parts[4] = UInt64(x >> 192);\n+        return parts;\n     }\n };\n \ndiff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h\nindex a43ce8d803cb..939920296347 100644\n--- a/src/Core/DecimalComparison.h\n+++ b/src/Core/DecimalComparison.h\n@@ -226,25 +226,25 @@ class DecimalComparison\n     static NO_INLINE UInt8 apply(A a, B b, CompareInt scale [[maybe_unused]])\n     {\n         CompareInt x;\n-        if constexpr (is_big_int_v<CompareInt> && IsDecimalNumber<A>)\n+        if constexpr (IsDecimalNumber<A>)\n             x = a.value;\n         else\n-            x = bigint_cast<CompareInt>(a);\n+            x = a;\n \n         CompareInt y;\n-        if constexpr (is_big_int_v<CompareInt> && IsDecimalNumber<B>)\n+        if constexpr (IsDecimalNumber<B>)\n             y = b.value;\n         else\n-            y = bigint_cast<CompareInt>(b);\n+            y = b;\n \n         if constexpr (_check_overflow)\n         {\n             bool overflow = false;\n \n             if constexpr (sizeof(A) > sizeof(CompareInt))\n-                overflow |= (A(x) != a);\n+                overflow |= (bigint_cast<A>(x) != a);\n             if constexpr (sizeof(B) > sizeof(CompareInt))\n-                overflow |= (B(y) != b);\n+                overflow |= (bigint_cast<B>(y) != b);\n             if constexpr (is_unsigned_v<A>)\n                 overflow |= (x < 0);\n             if constexpr (is_unsigned_v<B>)\ndiff --git a/src/Core/Types.h b/src/Core/Types.h\nindex 39c152ce48b7..c23ac4a13795 100644\n--- a/src/Core/Types.h\n+++ b/src/Core/Types.h\n@@ -58,14 +58,14 @@ using UInt8 = ::UInt8;\n using UInt16 = ::UInt16;\n using UInt32 = ::UInt32;\n using UInt64 = ::UInt64;\n-using UInt256 = ::bUInt256;\n+using UInt256 = ::wUInt256;\n \n using Int8 = ::Int8;\n using Int16 = ::Int16;\n using Int32 = ::Int32;\n using Int64 = ::Int64;\n using Int128 = ::Int128;\n-using Int256 = ::bInt256;\n+using Int256 = ::wInt256;\n \n using Float32 = float;\n using Float64 = double;\ndiff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h\nindex 8c70306ba5d6..603449150dba 100644\n--- a/src/DataTypes/NumberTraits.h\n+++ b/src/DataTypes/NumberTraits.h\n@@ -28,21 +28,13 @@ constexpr size_t min(size_t x, size_t y)\n     return x < y ? x : y;\n }\n \n+/// @note There's no auto scale to larger big integer, only for integral ones.\n+/// It's cause of (U)Int64 backward compatibilty and very big performance penalties.\n constexpr size_t nextSize(size_t size)\n {\n-    return min(size * 2, 8);\n-}\n-\n-template <bool is_signed>\n-constexpr size_t nextSize2(size_t size)\n-{\n-    // old way for built-in integers\n-    if (size <= 8) return nextSize(size);\n-\n-    if constexpr (is_signed)\n-        return size <= 32 ? 32 : 48;\n-    else\n-        return size <= 32 ? 16 : 48;\n+    if (size < 8)\n+        return size * 2;\n+    return size;\n }\n \n template <bool is_signed, bool is_floating, size_t size>\n@@ -55,9 +47,8 @@ template <> struct Construct<false, false, 1> { using Type = UInt8; };\n template <> struct Construct<false, false, 2> { using Type = UInt16; };\n template <> struct Construct<false, false, 4> { using Type = UInt32; };\n template <> struct Construct<false, false, 8> { using Type = UInt64; };\n-template <> struct Construct<false, false, 16> { using Type = UInt256; };\n+template <> struct Construct<false, false, 16> { using Type = UInt256; }; /// TODO: we cannot use our UInt128 here\n template <> struct Construct<false, false, 32> { using Type = UInt256; };\n-template <> struct Construct<false, false, 48> { using Type = UInt256; };\n template <> struct Construct<false, true, 1> { using Type = Float32; };\n template <> struct Construct<false, true, 2> { using Type = Float32; };\n template <> struct Construct<false, true, 4> { using Type = Float32; };\n@@ -67,8 +58,7 @@ template <> struct Construct<true, false, 2> { using Type = Int16; };\n template <> struct Construct<true, false, 4> { using Type = Int32; };\n template <> struct Construct<true, false, 8> { using Type = Int64; };\n template <> struct Construct<true, false, 16> { using Type = Int128; };\n-template <> struct Construct<true, false, 32> { using Type = Int128; };\n-template <> struct Construct<true, false, 48> { using Type = Int256; };\n+template <> struct Construct<true, false, 32> { using Type = Int256; };\n template <> struct Construct<true, true, 1> { using Type = Float32; };\n template <> struct Construct<true, true, 2> { using Type = Float32; };\n template <> struct Construct<true, true, 4> { using Type = Float32; };\n@@ -86,7 +76,7 @@ template <typename A, typename B> struct ResultOfAdditionMultiplication\n     using Type = typename Construct<\n         is_signed_v<A> || is_signed_v<B>,\n         std::is_floating_point_v<A> || std::is_floating_point_v<B>,\n-        nextSize2< is_signed_v<A> || is_signed_v<B> >(max(sizeof(A), sizeof(B)))>::Type;\n+        nextSize(max(sizeof(A), sizeof(B)))>::Type;\n };\n \n template <typename A, typename B> struct ResultOfSubtraction\n@@ -94,7 +84,7 @@ template <typename A, typename B> struct ResultOfSubtraction\n     using Type = typename Construct<\n         true,\n         std::is_floating_point_v<A> || std::is_floating_point_v<B>,\n-        nextSize2< is_signed_v<A> || is_signed_v<B> >(max(sizeof(A), sizeof(B)))>::Type;\n+        nextSize(max(sizeof(A), sizeof(B)))>::Type;\n };\n \n /** When dividing, you always get a floating-point number.\n@@ -127,7 +117,7 @@ template <typename A> struct ResultOfNegate\n     using Type = typename Construct<\n         true,\n         std::is_floating_point_v<A>,\n-        is_signed_v<A> ? sizeof(A) : nextSize2<true>(sizeof(A))>::Type;\n+        is_signed_v<A> ? sizeof(A) : nextSize(sizeof(A))>::Type;\n };\n \n template <typename A> struct ResultOfAbs\ndiff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h\nindex 99fd7795bb8a..7a816df70e54 100644\n--- a/src/Functions/DivisionUtils.h\n+++ b/src/Functions/DivisionUtils.h\n@@ -81,8 +81,10 @@ struct DivideIntegralImpl\n         /// NOTE: overflow is still possible when dividing large signed number to large unsigned number or vice-versa. But it's less harmful.\n         if constexpr (is_integer_v<A> && is_integer_v<B> && (is_signed_v<A> || is_signed_v<B>))\n         {\n-            return checkedDivision(make_signed_t<CastA>(a),\n-                sizeof(A) > sizeof(B) ? make_signed_t<A>(CastB(b)) : make_signed_t<CastB>(b));\n+            using SignedCastA = make_signed_t<CastA>;\n+            using SignedCastB = std::conditional_t<sizeof(A) <= sizeof(B), make_signed_t<CastB>, SignedCastA>;\n+\n+            return bigint_cast<Result>(checkedDivision(bigint_cast<SignedCastA>(a), bigint_cast<SignedCastB>(b)));\n         }\n         else\n             return bigint_cast<Result>(checkedDivision(CastA(a), CastB(b)));\n@@ -108,7 +110,7 @@ struct ModuloImpl\n         if constexpr (std::is_floating_point_v<ResultType>)\n         {\n             /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.\n-            return ResultType(a) - trunc(ResultType(a) / ResultType(b)) * ResultType(b);\n+            return bigint_cast<ResultType>(a) - trunc(bigint_cast<ResultType>(a) / bigint_cast<ResultType>(b)) * bigint_cast<ResultType>(b);\n         }\n         else\n         {\n@@ -125,7 +127,7 @@ struct ModuloImpl\n                 if constexpr (is_big_int_v<IntegerBType> && sizeof(IntegerAType) <= sizeof(IntegerBType))\n                     return bigint_cast<Result>(bigint_cast<CastB>(int_a) % int_b);\n                 else\n-                    return bigint_cast<Result>(int_a % int_b);\n+                    return bigint_cast<Result>(int_a % bigint_cast<CastA>(int_b));\n             }\n             else\n                 return IntegerAType(a) % IntegerBType(b);\ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 241f7b2fae09..2a467451684a 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -361,12 +361,8 @@ struct DecimalBinaryOperation\n                 return apply(a.value, b);\n             else if constexpr (IsDecimalNumber<U>)\n                 return apply(a, b.value);\n-            else if constexpr (std::is_same_v<T, UInt8>)\n-                return apply(UInt16(a), b);\n-            else if constexpr (std::is_same_v<U, UInt8>)\n-                return apply(a, UInt16(b));\n             else\n-                return applyNative(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b));\n+                return applyNative(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b));\n         }\n         else\n             return applyNative(a, b);\n@@ -381,12 +377,8 @@ struct DecimalBinaryOperation\n                 return applyScaled<scale_left>(a.value, b, scale);\n             else if constexpr (IsDecimalNumber<U>)\n                 return applyScaled<scale_left>(a, b.value, scale);\n-            else if constexpr (std::is_same_v<T, UInt8>)\n-                return applyScaled<scale_left>(UInt16(a), b, scale);\n-            else if constexpr (std::is_same_v<U, UInt8>)\n-                return applyScaled<scale_left>(a, UInt16(b), scale);\n             else\n-                return applyNativeScaled<scale_left>(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b), scale);\n+                return applyNativeScaled<scale_left>(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b), scale);\n         }\n         else\n             return applyNativeScaled<scale_left>(a, b, scale);\n@@ -401,12 +393,8 @@ struct DecimalBinaryOperation\n                 return applyScaledDiv(a.value, b, scale);\n             else if constexpr (IsDecimalNumber<U>)\n                 return applyScaledDiv(a, b.value, scale);\n-            else if constexpr (std::is_same_v<T, UInt8>)\n-                return applyScaledDiv(UInt16(a), b, scale);\n-            else if constexpr (std::is_same_v<U, UInt8>)\n-                return applyScaledDiv(a, UInt16(b), scale);\n             else\n-                return applyNativeScaledDiv(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b), scale);\n+                return applyNativeScaledDiv(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b), scale);\n         }\n         else\n             return applyNativeScaledDiv(a, b, scale);\ndiff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h\nindex bf13de0c594c..e54538c76b3c 100644\n--- a/src/Functions/GatherUtils/Algorithms.h\n+++ b/src/Functions/GatherUtils/Algorithms.h\n@@ -558,7 +558,7 @@ bool sliceEqualElements(const NumericArraySlice<T> & first [[maybe_unused]],\n {\n     /// TODO: Decimal scale\n     if constexpr (IsDecimalNumber<T> && IsDecimalNumber<U>)\n-        return accurate::equalsOp(typename T::NativeType(first.data[first_ind]), typename U::NativeType(second.data[second_ind]));\n+        return accurate::equalsOp(first.data[first_ind].value, second.data[second_ind].value);\n     else if constexpr (IsDecimalNumber<T> || IsDecimalNumber<U>)\n         return false;\n     else\n@@ -588,7 +588,7 @@ bool insliceEqualElements(const NumericArraySlice<T> & first [[maybe_unused]],\n                           size_t second_ind [[maybe_unused]])\n {\n     if constexpr (IsDecimalNumber<T>)\n-        return accurate::equalsOp(typename T::NativeType(first.data[first_ind]), typename T::NativeType(first.data[second_ind]));\n+        return accurate::equalsOp(first.data[first_ind].value, first.data[second_ind].value);\n     else\n         return accurate::equalsOp(first.data[first_ind], first.data[second_ind]);\n }\ndiff --git a/src/Functions/abs.cpp b/src/Functions/abs.cpp\nindex a7d31f4e0309..f0c530e0e8f1 100644\n--- a/src/Functions/abs.cpp\n+++ b/src/Functions/abs.cpp\n@@ -16,11 +16,10 @@ struct AbsImpl\n     {\n         if constexpr (IsDecimalNumber<A>)\n             return a < A(0) ? A(-a) : a;\n-        else if constexpr (is_big_int_v<A>)\n-            // from boost/multiprecision/number.hpp\n-            return static_cast<ResultType>(abs(a));\n+        else if constexpr (is_big_int_v<A> && is_signed_v<A>)\n+            return (a < 0) ? -a : a;\n         else if constexpr (is_integer_v<A> && is_signed_v<A>)\n-            return a < 0 ? static_cast<ResultType>(~a) + 1 : a;\n+            return a < 0 ? static_cast<ResultType>(~a) + 1 : static_cast<ResultType>(a);\n         else if constexpr (is_integer_v<A> && is_unsigned_v<A>)\n             return static_cast<ResultType>(a);\n         else if constexpr (std::is_floating_point_v<A>)\ndiff --git a/src/Functions/bitRotateLeft.cpp b/src/Functions/bitRotateLeft.cpp\nindex 3bef0bb5ff32..a6975468c1eb 100644\n--- a/src/Functions/bitRotateLeft.cpp\n+++ b/src/Functions/bitRotateLeft.cpp\n@@ -18,7 +18,7 @@ struct BitRotateLeftImpl\n     template <typename Result = ResultType>\n     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n-        if constexpr (is_big_int_v<ResultType>)\n+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n             throw Exception(\"Bit rotate is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n         else\n             return (static_cast<Result>(a) << static_cast<Result>(b))\ndiff --git a/src/Functions/bitRotateRight.cpp b/src/Functions/bitRotateRight.cpp\nindex e94e13a8e604..71d7385bbdf4 100644\n--- a/src/Functions/bitRotateRight.cpp\n+++ b/src/Functions/bitRotateRight.cpp\n@@ -18,7 +18,7 @@ struct BitRotateRightImpl\n     template <typename Result = ResultType>\n     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n-        if constexpr (is_big_int_v<ResultType>)\n+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n             throw Exception(\"Bit rotate is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n         else\n             return (static_cast<Result>(a) >> static_cast<Result>(b))\ndiff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp\nindex 1ea69af73e91..d42082d77782 100644\n--- a/src/Functions/bitShiftLeft.cpp\n+++ b/src/Functions/bitShiftLeft.cpp\n@@ -19,9 +19,9 @@ struct BitShiftLeftImpl\n     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n         if constexpr (is_big_int_v<B>)\n-            throw Exception(\"BitShiftLeftImpl is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n+            throw Exception(\"BitShiftLeft is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n         else if constexpr (is_big_int_v<A>)\n-            return static_cast<Result>(a) << bigint_cast<UInt32>(b);\n+            return bigint_cast<Result>(a) << bigint_cast<UInt32>(b);\n         else\n             return static_cast<Result>(a) << static_cast<Result>(b);\n     }\ndiff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp\nindex 25eb86bf353a..249a86d6961b 100644\n--- a/src/Functions/bitShiftRight.cpp\n+++ b/src/Functions/bitShiftRight.cpp\n@@ -19,9 +19,9 @@ struct BitShiftRightImpl\n     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n         if constexpr (is_big_int_v<B>)\n-            throw Exception(\"BitRotate is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n+            throw Exception(\"BitShiftRight is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n         else if constexpr (is_big_int_v<A>)\n-            return static_cast<Result>(a) >> bigint_cast<UInt32>(b);\n+            return bigint_cast<Result>(a) >> bigint_cast<UInt32>(b);\n         else\n             return static_cast<Result>(a) >> static_cast<Result>(b);\n     }\ndiff --git a/src/Functions/bitTest.cpp b/src/Functions/bitTest.cpp\nindex 19afa1da84b4..f34e300d6756 100644\n--- a/src/Functions/bitTest.cpp\n+++ b/src/Functions/bitTest.cpp\n@@ -19,10 +19,8 @@ struct BitTestImpl\n     template <typename Result = ResultType>\n     NO_SANITIZE_UNDEFINED static inline Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n-        if constexpr (is_big_int_v<B>)\n+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n             throw Exception(\"bitTest is not implemented for big integers as second argument\", ErrorCodes::NOT_IMPLEMENTED);\n-        else if constexpr (is_big_int_v<A>)\n-            return bit_test(a, static_cast<UInt32>(b));\n         else\n             return (typename NumberTraits::ToInteger<A>::Type(a) >> typename NumberTraits::ToInteger<B>::Type(b)) & 1;\n     }\ndiff --git a/src/Functions/gcd.cpp b/src/Functions/gcd.cpp\nindex 4ee39f3f2fd6..b5d1ed6e92c9 100644\n--- a/src/Functions/gcd.cpp\n+++ b/src/Functions/gcd.cpp\n@@ -20,7 +20,7 @@ struct GCDImpl\n     template <typename Result = ResultType>\n     static inline Result apply([[maybe_unused]] A a, [[maybe_unused]] B b)\n     {\n-        if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n+        if constexpr (is_big_int_v<A> || is_big_int_v<B> || is_big_int_v<Result>)\n             throw Exception(\"GCD is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n         else\n         {\ndiff --git a/src/Functions/lcm.cpp b/src/Functions/lcm.cpp\nindex c61337c75ad1..ceca495ddce9 100644\n--- a/src/Functions/lcm.cpp\n+++ b/src/Functions/lcm.cpp\n@@ -40,14 +40,14 @@ struct LCMImpl\n     static const constexpr bool allow_fixed_string = false;\n \n     template <typename Result = ResultType>\n-    static inline std::enable_if_t<is_big_int_v<A> || is_big_int_v<B>, Result>\n+    static inline std::enable_if_t<is_big_int_v<A> || is_big_int_v<B> || is_big_int_v<Result>, Result>\n     apply([[maybe_unused]] A a, [[maybe_unused]] B b)\n     {\n         throw Exception(\"LCM is not implemented for big integers\", ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n     template <typename Result = ResultType>\n-    static inline std::enable_if_t<!is_big_int_v<A> && !is_big_int_v<B>, Result>\n+    static inline std::enable_if_t<!is_big_int_v<A> && !is_big_int_v<B> && !is_big_int_v<Result>, Result>\n     apply([[maybe_unused]] A a, [[maybe_unused]] B b)\n     {\n         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));\ndiff --git a/src/Functions/roundToExp2.cpp b/src/Functions/roundToExp2.cpp\nindex 12856a7930e4..c6b6f672c66b 100644\n--- a/src/Functions/roundToExp2.cpp\n+++ b/src/Functions/roundToExp2.cpp\n@@ -6,6 +6,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n template <typename T>\n inline std::enable_if_t<std::is_integral_v<T> && (sizeof(T) <= sizeof(UInt32)), T>\n roundDownToPowerOfTwo(T x)\n@@ -48,10 +53,9 @@ roundDownToPowerOfTwo(T x)\n \n template <typename T>\n inline std::enable_if_t<is_big_int_v<T>, T>\n-roundDownToPowerOfTwo(T x)\n+roundDownToPowerOfTwo(T)\n {\n-    // extention from boost/multiprecision/number.hpp\n-    return T(1) << msb(x);\n+    throw Exception(\"roundToExp2() for big integers is not implemented\", ErrorCodes::NOT_IMPLEMENTED);\n }\n \n /** For integer data types:\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex fb7c4e0cd80a..3b9eced09bd2 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -831,6 +831,7 @@ template <> inline void writeText<bool>(const bool & x, WriteBuffer & buf) { wri\n inline void writeText(const char * x, WriteBuffer & buf) { writeEscapedString(x, strlen(x), buf); }\n inline void writeText(const char * x, size_t size, WriteBuffer & buf) { writeEscapedString(x, size, buf); }\n \n+inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(LocalDate(x), buf); }\n inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }\n inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }\n inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }\ndiff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h\nindex c69a56dd83e3..727dd67c3893 100644\n--- a/src/IO/readDecimalText.h\n+++ b/src/IO/readDecimalText.h\n@@ -160,7 +160,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_\n             \" Expected to read decimal with scale {} and precision {}\";\n \n         if constexpr (is_big_int_v<typename T::NativeType>)\n-            throw Exception(fmt::format(pattern, digits, x.value.str(), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+            throw Exception(fmt::format(pattern, digits, bigintToString(x.value), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n         else\n             throw Exception(fmt::format(pattern, digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n     }\n@@ -180,7 +180,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_\n         {\n             /// Too many digits after point. Just cut off excessive digits.\n             auto divisor = intExp10OfSize<typename T::NativeType>(divisor_exp);\n-            assert(divisor > T(0)); /// This is for Clang Static Analyzer. It is not smart enough to infer it automatically.\n+            assert(divisor > 0); /// This is for Clang Static Analyzer. It is not smart enough to infer it automatically.\n             x.value /= divisor;\n             scale = 0;\n             return;\ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex c011aac13497..86a33dccb530 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -362,7 +362,9 @@ AggregatedDataVariants::Type Aggregator::chooseAggregationMethod()\n             return AggregatedDataVariants::Type::key64;\n         if (size_of_field == 16)\n             return AggregatedDataVariants::Type::keys128;\n-        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.\", ErrorCodes::LOGICAL_ERROR);\n+        if (size_of_field == 32)\n+            return AggregatedDataVariants::Type::keys256;\n+        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.\", ErrorCodes::LOGICAL_ERROR);\n     }\n \n     /// If all keys fits in N bits, will use hash table with all keys packed (placed contiguously) to single N-bit key.\ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex e3f265af004f..9818f89d13ce 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -221,7 +221,9 @@ HashJoin::Type HashJoin::chooseMethod(const ColumnRawPtrs & key_columns, Sizes &\n             return Type::key64;\n         if (size_of_field == 16)\n             return Type::keys128;\n-        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.\", ErrorCodes::LOGICAL_ERROR);\n+        if (size_of_field == 32)\n+            return Type::keys256;\n+        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.\", ErrorCodes::LOGICAL_ERROR);\n     }\n \n     /// If the keys fit in N bits, we will use a hash table for N-bit-packed keys\ndiff --git a/src/Interpreters/SetVariants.cpp b/src/Interpreters/SetVariants.cpp\nindex b026ce567056..eb21333e3ecf 100644\n--- a/src/Interpreters/SetVariants.cpp\n+++ b/src/Interpreters/SetVariants.cpp\n@@ -110,9 +110,8 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose\n             size_t size_of_field = nested_key_columns[0]->sizeOfValueIfFixed();\n             if ((size_of_field == 1) || (size_of_field == 2) || (size_of_field == 4) || (size_of_field == 8))\n                 return Type::nullable_keys128;\n-            else\n-                throw Exception{\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8.\",\n-                    ErrorCodes::LOGICAL_ERROR};\n+\n+            /// Pass to more generic method\n         }\n \n         if (all_fixed)\n@@ -145,7 +144,9 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose\n             return Type::key64;\n         if (size_of_field == 16)\n             return Type::keys128;\n-        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.\", ErrorCodes::LOGICAL_ERROR);\n+        if (size_of_field == 32)\n+            return Type::keys256;\n+        throw Exception(\"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.\", ErrorCodes::LOGICAL_ERROR);\n     }\n \n     /// If the keys fit in N bits, we will use a hash table for N-bit-packed keys\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01440_big_int_shift.reference b/tests/queries/0_stateless/01440_big_int_shift.reference\nnew file mode 100644\nindex 000000000000..392a24aa7bc1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01440_big_int_shift.reference\n@@ -0,0 +1,638 @@\n+1\t1\tInt128\tInt128\n+2\t1\tInt128\tInt128\n+4\t1\tInt128\tInt128\n+8\t1\tInt128\tInt128\n+16\t1\tInt128\tInt128\n+32\t1\tInt128\tInt128\n+64\t1\tInt128\tInt128\n+128\t1\tInt128\tInt128\n+256\t1\tInt128\tInt128\n+512\t1\tInt128\tInt128\n+1024\t1\tInt128\tInt128\n+2048\t1\tInt128\tInt128\n+4096\t1\tInt128\tInt128\n+8192\t1\tInt128\tInt128\n+16384\t1\tInt128\tInt128\n+32768\t1\tInt128\tInt128\n+65536\t1\tInt128\tInt128\n+131072\t1\tInt128\tInt128\n+262144\t1\tInt128\tInt128\n+524288\t1\tInt128\tInt128\n+1048576\t1\tInt128\tInt128\n+2097152\t1\tInt128\tInt128\n+4194304\t1\tInt128\tInt128\n+8388608\t1\tInt128\tInt128\n+16777216\t1\tInt128\tInt128\n+33554432\t1\tInt128\tInt128\n+67108864\t1\tInt128\tInt128\n+134217728\t1\tInt128\tInt128\n+268435456\t1\tInt128\tInt128\n+536870912\t1\tInt128\tInt128\n+1073741824\t1\tInt128\tInt128\n+2147483648\t1\tInt128\tInt128\n+4294967296\t1\tInt128\tInt128\n+8589934592\t1\tInt128\tInt128\n+17179869184\t1\tInt128\tInt128\n+34359738368\t1\tInt128\tInt128\n+68719476736\t1\tInt128\tInt128\n+137438953472\t1\tInt128\tInt128\n+274877906944\t1\tInt128\tInt128\n+549755813888\t1\tInt128\tInt128\n+1099511627776\t1\tInt128\tInt128\n+2199023255552\t1\tInt128\tInt128\n+4398046511104\t1\tInt128\tInt128\n+8796093022208\t1\tInt128\tInt128\n+17592186044416\t1\tInt128\tInt128\n+35184372088832\t1\tInt128\tInt128\n+70368744177664\t1\tInt128\tInt128\n+140737488355328\t1\tInt128\tInt128\n+281474976710656\t1\tInt128\tInt128\n+562949953421312\t1\tInt128\tInt128\n+1125899906842624\t1\tInt128\tInt128\n+2251799813685248\t1\tInt128\tInt128\n+4503599627370496\t1\tInt128\tInt128\n+9007199254740992\t1\tInt128\tInt128\n+18014398509481984\t1\tInt128\tInt128\n+36028797018963968\t1\tInt128\tInt128\n+72057594037927936\t1\tInt128\tInt128\n+144115188075855872\t1\tInt128\tInt128\n+288230376151711744\t1\tInt128\tInt128\n+576460752303423488\t1\tInt128\tInt128\n+1152921504606846976\t1\tInt128\tInt128\n+2305843009213693952\t1\tInt128\tInt128\n+4611686018427387904\t1\tInt128\tInt128\n+9223372036854775808\t1\tInt128\tInt128\n+18446744073709551616\t1\tInt128\tInt128\n+36893488147419103232\t1\tInt128\tInt128\n+73786976294838206464\t1\tInt128\tInt128\n+147573952589676412928\t1\tInt128\tInt128\n+295147905179352825856\t1\tInt128\tInt128\n+590295810358705651712\t1\tInt128\tInt128\n+1180591620717411303424\t1\tInt128\tInt128\n+2361183241434822606848\t1\tInt128\tInt128\n+4722366482869645213696\t1\tInt128\tInt128\n+9444732965739290427392\t1\tInt128\tInt128\n+18889465931478580854784\t1\tInt128\tInt128\n+37778931862957161709568\t1\tInt128\tInt128\n+75557863725914323419136\t1\tInt128\tInt128\n+151115727451828646838272\t1\tInt128\tInt128\n+302231454903657293676544\t1\tInt128\tInt128\n+604462909807314587353088\t1\tInt128\tInt128\n+1208925819614629174706176\t1\tInt128\tInt128\n+2417851639229258349412352\t1\tInt128\tInt128\n+4835703278458516698824704\t1\tInt128\tInt128\n+9671406556917033397649408\t1\tInt128\tInt128\n+19342813113834066795298816\t1\tInt128\tInt128\n+38685626227668133590597632\t1\tInt128\tInt128\n+77371252455336267181195264\t1\tInt128\tInt128\n+154742504910672534362390528\t1\tInt128\tInt128\n+309485009821345068724781056\t1\tInt128\tInt128\n+618970019642690137449562112\t1\tInt128\tInt128\n+1237940039285380274899124224\t1\tInt128\tInt128\n+2475880078570760549798248448\t1\tInt128\tInt128\n+4951760157141521099596496896\t1\tInt128\tInt128\n+9903520314283042199192993792\t1\tInt128\tInt128\n+19807040628566084398385987584\t1\tInt128\tInt128\n+39614081257132168796771975168\t1\tInt128\tInt128\n+79228162514264337593543950336\t1\tInt128\tInt128\n+158456325028528675187087900672\t1\tInt128\tInt128\n+316912650057057350374175801344\t1\tInt128\tInt128\n+633825300114114700748351602688\t1\tInt128\tInt128\n+1267650600228229401496703205376\t1\tInt128\tInt128\n+2535301200456458802993406410752\t1\tInt128\tInt128\n+5070602400912917605986812821504\t1\tInt128\tInt128\n+10141204801825835211973625643008\t1\tInt128\tInt128\n+20282409603651670423947251286016\t1\tInt128\tInt128\n+40564819207303340847894502572032\t1\tInt128\tInt128\n+81129638414606681695789005144064\t1\tInt128\tInt128\n+162259276829213363391578010288128\t1\tInt128\tInt128\n+324518553658426726783156020576256\t1\tInt128\tInt128\n+649037107316853453566312041152512\t1\tInt128\tInt128\n+1298074214633706907132624082305024\t1\tInt128\tInt128\n+2596148429267413814265248164610048\t1\tInt128\tInt128\n+5192296858534827628530496329220096\t1\tInt128\tInt128\n+10384593717069655257060992658440192\t1\tInt128\tInt128\n+20769187434139310514121985316880384\t1\tInt128\tInt128\n+41538374868278621028243970633760768\t1\tInt128\tInt128\n+83076749736557242056487941267521536\t1\tInt128\tInt128\n+166153499473114484112975882535043072\t1\tInt128\tInt128\n+332306998946228968225951765070086144\t1\tInt128\tInt128\n+664613997892457936451903530140172288\t1\tInt128\tInt128\n+1329227995784915872903807060280344576\t1\tInt128\tInt128\n+2658455991569831745807614120560689152\t1\tInt128\tInt128\n+5316911983139663491615228241121378304\t1\tInt128\tInt128\n+10633823966279326983230456482242756608\t1\tInt128\tInt128\n+21267647932558653966460912964485513216\t1\tInt128\tInt128\n+42535295865117307932921825928971026432\t1\tInt128\tInt128\n+85070591730234615865843651857942052864\t1\tInt128\tInt128\n+1\t1\tInt256\tInt256\n+2\t1\tInt256\tInt256\n+4\t1\tInt256\tInt256\n+8\t1\tInt256\tInt256\n+16\t1\tInt256\tInt256\n+32\t1\tInt256\tInt256\n+64\t1\tInt256\tInt256\n+128\t1\tInt256\tInt256\n+256\t1\tInt256\tInt256\n+512\t1\tInt256\tInt256\n+1024\t1\tInt256\tInt256\n+2048\t1\tInt256\tInt256\n+4096\t1\tInt256\tInt256\n+8192\t1\tInt256\tInt256\n+16384\t1\tInt256\tInt256\n+32768\t1\tInt256\tInt256\n+65536\t1\tInt256\tInt256\n+131072\t1\tInt256\tInt256\n+262144\t1\tInt256\tInt256\n+524288\t1\tInt256\tInt256\n+1048576\t1\tInt256\tInt256\n+2097152\t1\tInt256\tInt256\n+4194304\t1\tInt256\tInt256\n+8388608\t1\tInt256\tInt256\n+16777216\t1\tInt256\tInt256\n+33554432\t1\tInt256\tInt256\n+67108864\t1\tInt256\tInt256\n+134217728\t1\tInt256\tInt256\n+268435456\t1\tInt256\tInt256\n+536870912\t1\tInt256\tInt256\n+1073741824\t1\tInt256\tInt256\n+2147483648\t1\tInt256\tInt256\n+4294967296\t1\tInt256\tInt256\n+8589934592\t1\tInt256\tInt256\n+17179869184\t1\tInt256\tInt256\n+34359738368\t1\tInt256\tInt256\n+68719476736\t1\tInt256\tInt256\n+137438953472\t1\tInt256\tInt256\n+274877906944\t1\tInt256\tInt256\n+549755813888\t1\tInt256\tInt256\n+1099511627776\t1\tInt256\tInt256\n+2199023255552\t1\tInt256\tInt256\n+4398046511104\t1\tInt256\tInt256\n+8796093022208\t1\tInt256\tInt256\n+17592186044416\t1\tInt256\tInt256\n+35184372088832\t1\tInt256\tInt256\n+70368744177664\t1\tInt256\tInt256\n+140737488355328\t1\tInt256\tInt256\n+281474976710656\t1\tInt256\tInt256\n+562949953421312\t1\tInt256\tInt256\n+1125899906842624\t1\tInt256\tInt256\n+2251799813685248\t1\tInt256\tInt256\n+4503599627370496\t1\tInt256\tInt256\n+9007199254740992\t1\tInt256\tInt256\n+18014398509481984\t1\tInt256\tInt256\n+36028797018963968\t1\tInt256\tInt256\n+72057594037927936\t1\tInt256\tInt256\n+144115188075855872\t1\tInt256\tInt256\n+288230376151711744\t1\tInt256\tInt256\n+576460752303423488\t1\tInt256\tInt256\n+1152921504606846976\t1\tInt256\tInt256\n+2305843009213693952\t1\tInt256\tInt256\n+4611686018427387904\t1\tInt256\tInt256\n+9223372036854775808\t1\tInt256\tInt256\n+18446744073709551616\t1\tInt256\tInt256\n+36893488147419103232\t1\tInt256\tInt256\n+73786976294838206464\t1\tInt256\tInt256\n+147573952589676412928\t1\tInt256\tInt256\n+295147905179352825856\t1\tInt256\tInt256\n+590295810358705651712\t1\tInt256\tInt256\n+1180591620717411303424\t1\tInt256\tInt256\n+2361183241434822606848\t1\tInt256\tInt256\n+4722366482869645213696\t1\tInt256\tInt256\n+9444732965739290427392\t1\tInt256\tInt256\n+18889465931478580854784\t1\tInt256\tInt256\n+37778931862957161709568\t1\tInt256\tInt256\n+75557863725914323419136\t1\tInt256\tInt256\n+151115727451828646838272\t1\tInt256\tInt256\n+302231454903657293676544\t1\tInt256\tInt256\n+604462909807314587353088\t1\tInt256\tInt256\n+1208925819614629174706176\t1\tInt256\tInt256\n+2417851639229258349412352\t1\tInt256\tInt256\n+4835703278458516698824704\t1\tInt256\tInt256\n+9671406556917033397649408\t1\tInt256\tInt256\n+19342813113834066795298816\t1\tInt256\tInt256\n+38685626227668133590597632\t1\tInt256\tInt256\n+77371252455336267181195264\t1\tInt256\tInt256\n+154742504910672534362390528\t1\tInt256\tInt256\n+309485009821345068724781056\t1\tInt256\tInt256\n+618970019642690137449562112\t1\tInt256\tInt256\n+1237940039285380274899124224\t1\tInt256\tInt256\n+2475880078570760549798248448\t1\tInt256\tInt256\n+4951760157141521099596496896\t1\tInt256\tInt256\n+9903520314283042199192993792\t1\tInt256\tInt256\n+19807040628566084398385987584\t1\tInt256\tInt256\n+39614081257132168796771975168\t1\tInt256\tInt256\n+79228162514264337593543950336\t1\tInt256\tInt256\n+158456325028528675187087900672\t1\tInt256\tInt256\n+316912650057057350374175801344\t1\tInt256\tInt256\n+633825300114114700748351602688\t1\tInt256\tInt256\n+1267650600228229401496703205376\t1\tInt256\tInt256\n+2535301200456458802993406410752\t1\tInt256\tInt256\n+5070602400912917605986812821504\t1\tInt256\tInt256\n+10141204801825835211973625643008\t1\tInt256\tInt256\n+20282409603651670423947251286016\t1\tInt256\tInt256\n+40564819207303340847894502572032\t1\tInt256\tInt256\n+81129638414606681695789005144064\t1\tInt256\tInt256\n+162259276829213363391578010288128\t1\tInt256\tInt256\n+324518553658426726783156020576256\t1\tInt256\tInt256\n+649037107316853453566312041152512\t1\tInt256\tInt256\n+1298074214633706907132624082305024\t1\tInt256\tInt256\n+2596148429267413814265248164610048\t1\tInt256\tInt256\n+5192296858534827628530496329220096\t1\tInt256\tInt256\n+10384593717069655257060992658440192\t1\tInt256\tInt256\n+20769187434139310514121985316880384\t1\tInt256\tInt256\n+41538374868278621028243970633760768\t1\tInt256\tInt256\n+83076749736557242056487941267521536\t1\tInt256\tInt256\n+166153499473114484112975882535043072\t1\tInt256\tInt256\n+332306998946228968225951765070086144\t1\tInt256\tInt256\n+664613997892457936451903530140172288\t1\tInt256\tInt256\n+1329227995784915872903807060280344576\t1\tInt256\tInt256\n+2658455991569831745807614120560689152\t1\tInt256\tInt256\n+5316911983139663491615228241121378304\t1\tInt256\tInt256\n+10633823966279326983230456482242756608\t1\tInt256\tInt256\n+21267647932558653966460912964485513216\t1\tInt256\tInt256\n+42535295865117307932921825928971026432\t1\tInt256\tInt256\n+85070591730234615865843651857942052864\t1\tInt256\tInt256\n+170141183460469231731687303715884105728\t1\tInt256\tInt256\n+340282366920938463463374607431768211456\t1\tInt256\tInt256\n+680564733841876926926749214863536422912\t1\tInt256\tInt256\n+1361129467683753853853498429727072845824\t1\tInt256\tInt256\n+2722258935367507707706996859454145691648\t1\tInt256\tInt256\n+5444517870735015415413993718908291383296\t1\tInt256\tInt256\n+10889035741470030830827987437816582766592\t1\tInt256\tInt256\n+21778071482940061661655974875633165533184\t1\tInt256\tInt256\n+43556142965880123323311949751266331066368\t1\tInt256\tInt256\n+87112285931760246646623899502532662132736\t1\tInt256\tInt256\n+174224571863520493293247799005065324265472\t1\tInt256\tInt256\n+348449143727040986586495598010130648530944\t1\tInt256\tInt256\n+696898287454081973172991196020261297061888\t1\tInt256\tInt256\n+1393796574908163946345982392040522594123776\t1\tInt256\tInt256\n+2787593149816327892691964784081045188247552\t1\tInt256\tInt256\n+5575186299632655785383929568162090376495104\t1\tInt256\tInt256\n+11150372599265311570767859136324180752990208\t1\tInt256\tInt256\n+22300745198530623141535718272648361505980416\t1\tInt256\tInt256\n+44601490397061246283071436545296723011960832\t1\tInt256\tInt256\n+89202980794122492566142873090593446023921664\t1\tInt256\tInt256\n+178405961588244985132285746181186892047843328\t1\tInt256\tInt256\n+356811923176489970264571492362373784095686656\t1\tInt256\tInt256\n+713623846352979940529142984724747568191373312\t1\tInt256\tInt256\n+1427247692705959881058285969449495136382746624\t1\tInt256\tInt256\n+2854495385411919762116571938898990272765493248\t1\tInt256\tInt256\n+5708990770823839524233143877797980545530986496\t1\tInt256\tInt256\n+11417981541647679048466287755595961091061972992\t1\tInt256\tInt256\n+22835963083295358096932575511191922182123945984\t1\tInt256\tInt256\n+45671926166590716193865151022383844364247891968\t1\tInt256\tInt256\n+91343852333181432387730302044767688728495783936\t1\tInt256\tInt256\n+182687704666362864775460604089535377456991567872\t1\tInt256\tInt256\n+365375409332725729550921208179070754913983135744\t1\tInt256\tInt256\n+730750818665451459101842416358141509827966271488\t1\tInt256\tInt256\n+1461501637330902918203684832716283019655932542976\t1\tInt256\tInt256\n+2923003274661805836407369665432566039311865085952\t1\tInt256\tInt256\n+5846006549323611672814739330865132078623730171904\t1\tInt256\tInt256\n+11692013098647223345629478661730264157247460343808\t1\tInt256\tInt256\n+23384026197294446691258957323460528314494920687616\t1\tInt256\tInt256\n+46768052394588893382517914646921056628989841375232\t1\tInt256\tInt256\n+93536104789177786765035829293842113257979682750464\t1\tInt256\tInt256\n+187072209578355573530071658587684226515959365500928\t1\tInt256\tInt256\n+374144419156711147060143317175368453031918731001856\t1\tInt256\tInt256\n+748288838313422294120286634350736906063837462003712\t1\tInt256\tInt256\n+1496577676626844588240573268701473812127674924007424\t1\tInt256\tInt256\n+2993155353253689176481146537402947624255349848014848\t1\tInt256\tInt256\n+5986310706507378352962293074805895248510699696029696\t1\tInt256\tInt256\n+11972621413014756705924586149611790497021399392059392\t1\tInt256\tInt256\n+23945242826029513411849172299223580994042798784118784\t1\tInt256\tInt256\n+47890485652059026823698344598447161988085597568237568\t1\tInt256\tInt256\n+95780971304118053647396689196894323976171195136475136\t1\tInt256\tInt256\n+191561942608236107294793378393788647952342390272950272\t1\tInt256\tInt256\n+383123885216472214589586756787577295904684780545900544\t1\tInt256\tInt256\n+766247770432944429179173513575154591809369561091801088\t1\tInt256\tInt256\n+1532495540865888858358347027150309183618739122183602176\t1\tInt256\tInt256\n+3064991081731777716716694054300618367237478244367204352\t1\tInt256\tInt256\n+6129982163463555433433388108601236734474956488734408704\t1\tInt256\tInt256\n+12259964326927110866866776217202473468949912977468817408\t1\tInt256\tInt256\n+24519928653854221733733552434404946937899825954937634816\t1\tInt256\tInt256\n+49039857307708443467467104868809893875799651909875269632\t1\tInt256\tInt256\n+98079714615416886934934209737619787751599303819750539264\t1\tInt256\tInt256\n+196159429230833773869868419475239575503198607639501078528\t1\tInt256\tInt256\n+392318858461667547739736838950479151006397215279002157056\t1\tInt256\tInt256\n+784637716923335095479473677900958302012794430558004314112\t1\tInt256\tInt256\n+1569275433846670190958947355801916604025588861116008628224\t1\tInt256\tInt256\n+3138550867693340381917894711603833208051177722232017256448\t1\tInt256\tInt256\n+6277101735386680763835789423207666416102355444464034512896\t1\tInt256\tInt256\n+12554203470773361527671578846415332832204710888928069025792\t1\tInt256\tInt256\n+25108406941546723055343157692830665664409421777856138051584\t1\tInt256\tInt256\n+50216813883093446110686315385661331328818843555712276103168\t1\tInt256\tInt256\n+100433627766186892221372630771322662657637687111424552206336\t1\tInt256\tInt256\n+200867255532373784442745261542645325315275374222849104412672\t1\tInt256\tInt256\n+401734511064747568885490523085290650630550748445698208825344\t1\tInt256\tInt256\n+803469022129495137770981046170581301261101496891396417650688\t1\tInt256\tInt256\n+1606938044258990275541962092341162602522202993782792835301376\t1\tInt256\tInt256\n+3213876088517980551083924184682325205044405987565585670602752\t1\tInt256\tInt256\n+6427752177035961102167848369364650410088811975131171341205504\t1\tInt256\tInt256\n+12855504354071922204335696738729300820177623950262342682411008\t1\tInt256\tInt256\n+25711008708143844408671393477458601640355247900524685364822016\t1\tInt256\tInt256\n+51422017416287688817342786954917203280710495801049370729644032\t1\tInt256\tInt256\n+102844034832575377634685573909834406561420991602098741459288064\t1\tInt256\tInt256\n+205688069665150755269371147819668813122841983204197482918576128\t1\tInt256\tInt256\n+411376139330301510538742295639337626245683966408394965837152256\t1\tInt256\tInt256\n+822752278660603021077484591278675252491367932816789931674304512\t1\tInt256\tInt256\n+1645504557321206042154969182557350504982735865633579863348609024\t1\tInt256\tInt256\n+3291009114642412084309938365114701009965471731267159726697218048\t1\tInt256\tInt256\n+6582018229284824168619876730229402019930943462534319453394436096\t1\tInt256\tInt256\n+13164036458569648337239753460458804039861886925068638906788872192\t1\tInt256\tInt256\n+26328072917139296674479506920917608079723773850137277813577744384\t1\tInt256\tInt256\n+52656145834278593348959013841835216159447547700274555627155488768\t1\tInt256\tInt256\n+105312291668557186697918027683670432318895095400549111254310977536\t1\tInt256\tInt256\n+210624583337114373395836055367340864637790190801098222508621955072\t1\tInt256\tInt256\n+421249166674228746791672110734681729275580381602196445017243910144\t1\tInt256\tInt256\n+842498333348457493583344221469363458551160763204392890034487820288\t1\tInt256\tInt256\n+1684996666696914987166688442938726917102321526408785780068975640576\t1\tInt256\tInt256\n+3369993333393829974333376885877453834204643052817571560137951281152\t1\tInt256\tInt256\n+6739986666787659948666753771754907668409286105635143120275902562304\t1\tInt256\tInt256\n+13479973333575319897333507543509815336818572211270286240551805124608\t1\tInt256\tInt256\n+26959946667150639794667015087019630673637144422540572481103610249216\t1\tInt256\tInt256\n+53919893334301279589334030174039261347274288845081144962207220498432\t1\tInt256\tInt256\n+107839786668602559178668060348078522694548577690162289924414440996864\t1\tInt256\tInt256\n+215679573337205118357336120696157045389097155380324579848828881993728\t1\tInt256\tInt256\n+431359146674410236714672241392314090778194310760649159697657763987456\t1\tInt256\tInt256\n+862718293348820473429344482784628181556388621521298319395315527974912\t1\tInt256\tInt256\n+1725436586697640946858688965569256363112777243042596638790631055949824\t1\tInt256\tInt256\n+3450873173395281893717377931138512726225554486085193277581262111899648\t1\tInt256\tInt256\n+6901746346790563787434755862277025452451108972170386555162524223799296\t1\tInt256\tInt256\n+13803492693581127574869511724554050904902217944340773110325048447598592\t1\tInt256\tInt256\n+27606985387162255149739023449108101809804435888681546220650096895197184\t1\tInt256\tInt256\n+55213970774324510299478046898216203619608871777363092441300193790394368\t1\tInt256\tInt256\n+110427941548649020598956093796432407239217743554726184882600387580788736\t1\tInt256\tInt256\n+220855883097298041197912187592864814478435487109452369765200775161577472\t1\tInt256\tInt256\n+441711766194596082395824375185729628956870974218904739530401550323154944\t1\tInt256\tInt256\n+883423532389192164791648750371459257913741948437809479060803100646309888\t1\tInt256\tInt256\n+1766847064778384329583297500742918515827483896875618958121606201292619776\t1\tInt256\tInt256\n+3533694129556768659166595001485837031654967793751237916243212402585239552\t1\tInt256\tInt256\n+7067388259113537318333190002971674063309935587502475832486424805170479104\t1\tInt256\tInt256\n+14134776518227074636666380005943348126619871175004951664972849610340958208\t1\tInt256\tInt256\n+28269553036454149273332760011886696253239742350009903329945699220681916416\t1\tInt256\tInt256\n+56539106072908298546665520023773392506479484700019806659891398441363832832\t1\tInt256\tInt256\n+113078212145816597093331040047546785012958969400039613319782796882727665664\t1\tInt256\tInt256\n+226156424291633194186662080095093570025917938800079226639565593765455331328\t1\tInt256\tInt256\n+452312848583266388373324160190187140051835877600158453279131187530910662656\t1\tInt256\tInt256\n+904625697166532776746648320380374280103671755200316906558262375061821325312\t1\tInt256\tInt256\n+1809251394333065553493296640760748560207343510400633813116524750123642650624\t1\tInt256\tInt256\n+3618502788666131106986593281521497120414687020801267626233049500247285301248\t1\tInt256\tInt256\n+7237005577332262213973186563042994240829374041602535252466099000494570602496\t1\tInt256\tInt256\n+14474011154664524427946373126085988481658748083205070504932198000989141204992\t1\tInt256\tInt256\n+28948022309329048855892746252171976963317496166410141009864396001978282409984\t1\tInt256\tInt256\n+1\t1\tUInt256\tUInt256\n+2\t1\tUInt256\tUInt256\n+4\t1\tUInt256\tUInt256\n+8\t1\tUInt256\tUInt256\n+16\t1\tUInt256\tUInt256\n+32\t1\tUInt256\tUInt256\n+64\t1\tUInt256\tUInt256\n+128\t1\tUInt256\tUInt256\n+256\t1\tUInt256\tUInt256\n+512\t1\tUInt256\tUInt256\n+1024\t1\tUInt256\tUInt256\n+2048\t1\tUInt256\tUInt256\n+4096\t1\tUInt256\tUInt256\n+8192\t1\tUInt256\tUInt256\n+16384\t1\tUInt256\tUInt256\n+32768\t1\tUInt256\tUInt256\n+65536\t1\tUInt256\tUInt256\n+131072\t1\tUInt256\tUInt256\n+262144\t1\tUInt256\tUInt256\n+524288\t1\tUInt256\tUInt256\n+1048576\t1\tUInt256\tUInt256\n+2097152\t1\tUInt256\tUInt256\n+4194304\t1\tUInt256\tUInt256\n+8388608\t1\tUInt256\tUInt256\n+16777216\t1\tUInt256\tUInt256\n+33554432\t1\tUInt256\tUInt256\n+67108864\t1\tUInt256\tUInt256\n+134217728\t1\tUInt256\tUInt256\n+268435456\t1\tUInt256\tUInt256\n+536870912\t1\tUInt256\tUInt256\n+1073741824\t1\tUInt256\tUInt256\n+2147483648\t1\tUInt256\tUInt256\n+4294967296\t1\tUInt256\tUInt256\n+8589934592\t1\tUInt256\tUInt256\n+17179869184\t1\tUInt256\tUInt256\n+34359738368\t1\tUInt256\tUInt256\n+68719476736\t1\tUInt256\tUInt256\n+137438953472\t1\tUInt256\tUInt256\n+274877906944\t1\tUInt256\tUInt256\n+549755813888\t1\tUInt256\tUInt256\n+1099511627776\t1\tUInt256\tUInt256\n+2199023255552\t1\tUInt256\tUInt256\n+4398046511104\t1\tUInt256\tUInt256\n+8796093022208\t1\tUInt256\tUInt256\n+17592186044416\t1\tUInt256\tUInt256\n+35184372088832\t1\tUInt256\tUInt256\n+70368744177664\t1\tUInt256\tUInt256\n+140737488355328\t1\tUInt256\tUInt256\n+281474976710656\t1\tUInt256\tUInt256\n+562949953421312\t1\tUInt256\tUInt256\n+1125899906842624\t1\tUInt256\tUInt256\n+2251799813685248\t1\tUInt256\tUInt256\n+4503599627370496\t1\tUInt256\tUInt256\n+9007199254740992\t1\tUInt256\tUInt256\n+18014398509481984\t1\tUInt256\tUInt256\n+36028797018963968\t1\tUInt256\tUInt256\n+72057594037927936\t1\tUInt256\tUInt256\n+144115188075855872\t1\tUInt256\tUInt256\n+288230376151711744\t1\tUInt256\tUInt256\n+576460752303423488\t1\tUInt256\tUInt256\n+1152921504606846976\t1\tUInt256\tUInt256\n+2305843009213693952\t1\tUInt256\tUInt256\n+4611686018427387904\t1\tUInt256\tUInt256\n+9223372036854775808\t1\tUInt256\tUInt256\n+18446744073709551616\t1\tUInt256\tUInt256\n+36893488147419103232\t1\tUInt256\tUInt256\n+73786976294838206464\t1\tUInt256\tUInt256\n+147573952589676412928\t1\tUInt256\tUInt256\n+295147905179352825856\t1\tUInt256\tUInt256\n+590295810358705651712\t1\tUInt256\tUInt256\n+1180591620717411303424\t1\tUInt256\tUInt256\n+2361183241434822606848\t1\tUInt256\tUInt256\n+4722366482869645213696\t1\tUInt256\tUInt256\n+9444732965739290427392\t1\tUInt256\tUInt256\n+18889465931478580854784\t1\tUInt256\tUInt256\n+37778931862957161709568\t1\tUInt256\tUInt256\n+75557863725914323419136\t1\tUInt256\tUInt256\n+151115727451828646838272\t1\tUInt256\tUInt256\n+302231454903657293676544\t1\tUInt256\tUInt256\n+604462909807314587353088\t1\tUInt256\tUInt256\n+1208925819614629174706176\t1\tUInt256\tUInt256\n+2417851639229258349412352\t1\tUInt256\tUInt256\n+4835703278458516698824704\t1\tUInt256\tUInt256\n+9671406556917033397649408\t1\tUInt256\tUInt256\n+19342813113834066795298816\t1\tUInt256\tUInt256\n+38685626227668133590597632\t1\tUInt256\tUInt256\n+77371252455336267181195264\t1\tUInt256\tUInt256\n+154742504910672534362390528\t1\tUInt256\tUInt256\n+309485009821345068724781056\t1\tUInt256\tUInt256\n+618970019642690137449562112\t1\tUInt256\tUInt256\n+1237940039285380274899124224\t1\tUInt256\tUInt256\n+2475880078570760549798248448\t1\tUInt256\tUInt256\n+4951760157141521099596496896\t1\tUInt256\tUInt256\n+9903520314283042199192993792\t1\tUInt256\tUInt256\n+19807040628566084398385987584\t1\tUInt256\tUInt256\n+39614081257132168796771975168\t1\tUInt256\tUInt256\n+79228162514264337593543950336\t1\tUInt256\tUInt256\n+158456325028528675187087900672\t1\tUInt256\tUInt256\n+316912650057057350374175801344\t1\tUInt256\tUInt256\n+633825300114114700748351602688\t1\tUInt256\tUInt256\n+1267650600228229401496703205376\t1\tUInt256\tUInt256\n+2535301200456458802993406410752\t1\tUInt256\tUInt256\n+5070602400912917605986812821504\t1\tUInt256\tUInt256\n+10141204801825835211973625643008\t1\tUInt256\tUInt256\n+20282409603651670423947251286016\t1\tUInt256\tUInt256\n+40564819207303340847894502572032\t1\tUInt256\tUInt256\n+81129638414606681695789005144064\t1\tUInt256\tUInt256\n+162259276829213363391578010288128\t1\tUInt256\tUInt256\n+324518553658426726783156020576256\t1\tUInt256\tUInt256\n+649037107316853453566312041152512\t1\tUInt256\tUInt256\n+1298074214633706907132624082305024\t1\tUInt256\tUInt256\n+2596148429267413814265248164610048\t1\tUInt256\tUInt256\n+5192296858534827628530496329220096\t1\tUInt256\tUInt256\n+10384593717069655257060992658440192\t1\tUInt256\tUInt256\n+20769187434139310514121985316880384\t1\tUInt256\tUInt256\n+41538374868278621028243970633760768\t1\tUInt256\tUInt256\n+83076749736557242056487941267521536\t1\tUInt256\tUInt256\n+166153499473114484112975882535043072\t1\tUInt256\tUInt256\n+332306998946228968225951765070086144\t1\tUInt256\tUInt256\n+664613997892457936451903530140172288\t1\tUInt256\tUInt256\n+1329227995784915872903807060280344576\t1\tUInt256\tUInt256\n+2658455991569831745807614120560689152\t1\tUInt256\tUInt256\n+5316911983139663491615228241121378304\t1\tUInt256\tUInt256\n+10633823966279326983230456482242756608\t1\tUInt256\tUInt256\n+21267647932558653966460912964485513216\t1\tUInt256\tUInt256\n+42535295865117307932921825928971026432\t1\tUInt256\tUInt256\n+85070591730234615865843651857942052864\t1\tUInt256\tUInt256\n+170141183460469231731687303715884105728\t1\tUInt256\tUInt256\n+340282366920938463463374607431768211456\t1\tUInt256\tUInt256\n+680564733841876926926749214863536422912\t1\tUInt256\tUInt256\n+1361129467683753853853498429727072845824\t1\tUInt256\tUInt256\n+2722258935367507707706996859454145691648\t1\tUInt256\tUInt256\n+5444517870735015415413993718908291383296\t1\tUInt256\tUInt256\n+10889035741470030830827987437816582766592\t1\tUInt256\tUInt256\n+21778071482940061661655974875633165533184\t1\tUInt256\tUInt256\n+43556142965880123323311949751266331066368\t1\tUInt256\tUInt256\n+87112285931760246646623899502532662132736\t1\tUInt256\tUInt256\n+174224571863520493293247799005065324265472\t1\tUInt256\tUInt256\n+348449143727040986586495598010130648530944\t1\tUInt256\tUInt256\n+696898287454081973172991196020261297061888\t1\tUInt256\tUInt256\n+1393796574908163946345982392040522594123776\t1\tUInt256\tUInt256\n+2787593149816327892691964784081045188247552\t1\tUInt256\tUInt256\n+5575186299632655785383929568162090376495104\t1\tUInt256\tUInt256\n+11150372599265311570767859136324180752990208\t1\tUInt256\tUInt256\n+22300745198530623141535718272648361505980416\t1\tUInt256\tUInt256\n+44601490397061246283071436545296723011960832\t1\tUInt256\tUInt256\n+89202980794122492566142873090593446023921664\t1\tUInt256\tUInt256\n+178405961588244985132285746181186892047843328\t1\tUInt256\tUInt256\n+356811923176489970264571492362373784095686656\t1\tUInt256\tUInt256\n+713623846352979940529142984724747568191373312\t1\tUInt256\tUInt256\n+1427247692705959881058285969449495136382746624\t1\tUInt256\tUInt256\n+2854495385411919762116571938898990272765493248\t1\tUInt256\tUInt256\n+5708990770823839524233143877797980545530986496\t1\tUInt256\tUInt256\n+11417981541647679048466287755595961091061972992\t1\tUInt256\tUInt256\n+22835963083295358096932575511191922182123945984\t1\tUInt256\tUInt256\n+45671926166590716193865151022383844364247891968\t1\tUInt256\tUInt256\n+91343852333181432387730302044767688728495783936\t1\tUInt256\tUInt256\n+182687704666362864775460604089535377456991567872\t1\tUInt256\tUInt256\n+365375409332725729550921208179070754913983135744\t1\tUInt256\tUInt256\n+730750818665451459101842416358141509827966271488\t1\tUInt256\tUInt256\n+1461501637330902918203684832716283019655932542976\t1\tUInt256\tUInt256\n+2923003274661805836407369665432566039311865085952\t1\tUInt256\tUInt256\n+5846006549323611672814739330865132078623730171904\t1\tUInt256\tUInt256\n+11692013098647223345629478661730264157247460343808\t1\tUInt256\tUInt256\n+23384026197294446691258957323460528314494920687616\t1\tUInt256\tUInt256\n+46768052394588893382517914646921056628989841375232\t1\tUInt256\tUInt256\n+93536104789177786765035829293842113257979682750464\t1\tUInt256\tUInt256\n+187072209578355573530071658587684226515959365500928\t1\tUInt256\tUInt256\n+374144419156711147060143317175368453031918731001856\t1\tUInt256\tUInt256\n+748288838313422294120286634350736906063837462003712\t1\tUInt256\tUInt256\n+1496577676626844588240573268701473812127674924007424\t1\tUInt256\tUInt256\n+2993155353253689176481146537402947624255349848014848\t1\tUInt256\tUInt256\n+5986310706507378352962293074805895248510699696029696\t1\tUInt256\tUInt256\n+11972621413014756705924586149611790497021399392059392\t1\tUInt256\tUInt256\n+23945242826029513411849172299223580994042798784118784\t1\tUInt256\tUInt256\n+47890485652059026823698344598447161988085597568237568\t1\tUInt256\tUInt256\n+95780971304118053647396689196894323976171195136475136\t1\tUInt256\tUInt256\n+191561942608236107294793378393788647952342390272950272\t1\tUInt256\tUInt256\n+383123885216472214589586756787577295904684780545900544\t1\tUInt256\tUInt256\n+766247770432944429179173513575154591809369561091801088\t1\tUInt256\tUInt256\n+1532495540865888858358347027150309183618739122183602176\t1\tUInt256\tUInt256\n+3064991081731777716716694054300618367237478244367204352\t1\tUInt256\tUInt256\n+6129982163463555433433388108601236734474956488734408704\t1\tUInt256\tUInt256\n+12259964326927110866866776217202473468949912977468817408\t1\tUInt256\tUInt256\n+24519928653854221733733552434404946937899825954937634816\t1\tUInt256\tUInt256\n+49039857307708443467467104868809893875799651909875269632\t1\tUInt256\tUInt256\n+98079714615416886934934209737619787751599303819750539264\t1\tUInt256\tUInt256\n+196159429230833773869868419475239575503198607639501078528\t1\tUInt256\tUInt256\n+392318858461667547739736838950479151006397215279002157056\t1\tUInt256\tUInt256\n+784637716923335095479473677900958302012794430558004314112\t1\tUInt256\tUInt256\n+1569275433846670190958947355801916604025588861116008628224\t1\tUInt256\tUInt256\n+3138550867693340381917894711603833208051177722232017256448\t1\tUInt256\tUInt256\n+6277101735386680763835789423207666416102355444464034512896\t1\tUInt256\tUInt256\n+12554203470773361527671578846415332832204710888928069025792\t1\tUInt256\tUInt256\n+25108406941546723055343157692830665664409421777856138051584\t1\tUInt256\tUInt256\n+50216813883093446110686315385661331328818843555712276103168\t1\tUInt256\tUInt256\n+100433627766186892221372630771322662657637687111424552206336\t1\tUInt256\tUInt256\n+200867255532373784442745261542645325315275374222849104412672\t1\tUInt256\tUInt256\n+401734511064747568885490523085290650630550748445698208825344\t1\tUInt256\tUInt256\n+803469022129495137770981046170581301261101496891396417650688\t1\tUInt256\tUInt256\n+1606938044258990275541962092341162602522202993782792835301376\t1\tUInt256\tUInt256\n+3213876088517980551083924184682325205044405987565585670602752\t1\tUInt256\tUInt256\n+6427752177035961102167848369364650410088811975131171341205504\t1\tUInt256\tUInt256\n+12855504354071922204335696738729300820177623950262342682411008\t1\tUInt256\tUInt256\n+25711008708143844408671393477458601640355247900524685364822016\t1\tUInt256\tUInt256\n+51422017416287688817342786954917203280710495801049370729644032\t1\tUInt256\tUInt256\n+102844034832575377634685573909834406561420991602098741459288064\t1\tUInt256\tUInt256\n+205688069665150755269371147819668813122841983204197482918576128\t1\tUInt256\tUInt256\n+411376139330301510538742295639337626245683966408394965837152256\t1\tUInt256\tUInt256\n+822752278660603021077484591278675252491367932816789931674304512\t1\tUInt256\tUInt256\n+1645504557321206042154969182557350504982735865633579863348609024\t1\tUInt256\tUInt256\n+3291009114642412084309938365114701009965471731267159726697218048\t1\tUInt256\tUInt256\n+6582018229284824168619876730229402019930943462534319453394436096\t1\tUInt256\tUInt256\n+13164036458569648337239753460458804039861886925068638906788872192\t1\tUInt256\tUInt256\n+26328072917139296674479506920917608079723773850137277813577744384\t1\tUInt256\tUInt256\n+52656145834278593348959013841835216159447547700274555627155488768\t1\tUInt256\tUInt256\n+105312291668557186697918027683670432318895095400549111254310977536\t1\tUInt256\tUInt256\n+210624583337114373395836055367340864637790190801098222508621955072\t1\tUInt256\tUInt256\n+421249166674228746791672110734681729275580381602196445017243910144\t1\tUInt256\tUInt256\n+842498333348457493583344221469363458551160763204392890034487820288\t1\tUInt256\tUInt256\n+1684996666696914987166688442938726917102321526408785780068975640576\t1\tUInt256\tUInt256\n+3369993333393829974333376885877453834204643052817571560137951281152\t1\tUInt256\tUInt256\n+6739986666787659948666753771754907668409286105635143120275902562304\t1\tUInt256\tUInt256\n+13479973333575319897333507543509815336818572211270286240551805124608\t1\tUInt256\tUInt256\n+26959946667150639794667015087019630673637144422540572481103610249216\t1\tUInt256\tUInt256\n+53919893334301279589334030174039261347274288845081144962207220498432\t1\tUInt256\tUInt256\n+107839786668602559178668060348078522694548577690162289924414440996864\t1\tUInt256\tUInt256\n+215679573337205118357336120696157045389097155380324579848828881993728\t1\tUInt256\tUInt256\n+431359146674410236714672241392314090778194310760649159697657763987456\t1\tUInt256\tUInt256\n+862718293348820473429344482784628181556388621521298319395315527974912\t1\tUInt256\tUInt256\n+1725436586697640946858688965569256363112777243042596638790631055949824\t1\tUInt256\tUInt256\n+3450873173395281893717377931138512726225554486085193277581262111899648\t1\tUInt256\tUInt256\n+6901746346790563787434755862277025452451108972170386555162524223799296\t1\tUInt256\tUInt256\n+13803492693581127574869511724554050904902217944340773110325048447598592\t1\tUInt256\tUInt256\n+27606985387162255149739023449108101809804435888681546220650096895197184\t1\tUInt256\tUInt256\n+55213970774324510299478046898216203619608871777363092441300193790394368\t1\tUInt256\tUInt256\n+110427941548649020598956093796432407239217743554726184882600387580788736\t1\tUInt256\tUInt256\n+220855883097298041197912187592864814478435487109452369765200775161577472\t1\tUInt256\tUInt256\n+441711766194596082395824375185729628956870974218904739530401550323154944\t1\tUInt256\tUInt256\n+883423532389192164791648750371459257913741948437809479060803100646309888\t1\tUInt256\tUInt256\n+1766847064778384329583297500742918515827483896875618958121606201292619776\t1\tUInt256\tUInt256\n+3533694129556768659166595001485837031654967793751237916243212402585239552\t1\tUInt256\tUInt256\n+7067388259113537318333190002971674063309935587502475832486424805170479104\t1\tUInt256\tUInt256\n+14134776518227074636666380005943348126619871175004951664972849610340958208\t1\tUInt256\tUInt256\n+28269553036454149273332760011886696253239742350009903329945699220681916416\t1\tUInt256\tUInt256\n+56539106072908298546665520023773392506479484700019806659891398441363832832\t1\tUInt256\tUInt256\n+113078212145816597093331040047546785012958969400039613319782796882727665664\t1\tUInt256\tUInt256\n+226156424291633194186662080095093570025917938800079226639565593765455331328\t1\tUInt256\tUInt256\n+452312848583266388373324160190187140051835877600158453279131187530910662656\t1\tUInt256\tUInt256\n+904625697166532776746648320380374280103671755200316906558262375061821325312\t1\tUInt256\tUInt256\n+1809251394333065553493296640760748560207343510400633813116524750123642650624\t1\tUInt256\tUInt256\n+3618502788666131106986593281521497120414687020801267626233049500247285301248\t1\tUInt256\tUInt256\n+7237005577332262213973186563042994240829374041602535252466099000494570602496\t1\tUInt256\tUInt256\n+14474011154664524427946373126085988481658748083205070504932198000989141204992\t1\tUInt256\tUInt256\n+28948022309329048855892746252171976963317496166410141009864396001978282409984\t1\tUInt256\tUInt256\n+57896044618658097711785492504343953926634992332820282019728792003956564819968\t1\tUInt256\tUInt256\ndiff --git a/tests/queries/0_stateless/01440_big_int_shift.sql b/tests/queries/0_stateless/01440_big_int_shift.sql\nnew file mode 100644\nindex 000000000000..e24ae1ba9118\n--- /dev/null\n+++ b/tests/queries/0_stateless/01440_big_int_shift.sql\n@@ -0,0 +1,3 @@\n+SELECT bitShiftLeft(toInt128(1), number) x, bitShiftRight(x, number) y, toTypeName(x), toTypeName(y) FROM numbers(127) ORDER BY number;\n+SELECT bitShiftLeft(toInt256(1), number) x, bitShiftRight(x, number) y, toTypeName(x), toTypeName(y) FROM numbers(255) ORDER BY number;\n+SELECT bitShiftLeft(toUInt256(1), number) x, bitShiftRight(x, number) y, toTypeName(x), toTypeName(y) FROM numbers(256) ORDER BY number;\ndiff --git a/tests/queries/0_stateless/01457_int256_hashing.reference b/tests/queries/0_stateless/01457_int256_hashing.reference\nnew file mode 100644\nindex 000000000000..e1a6a2ad3412\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_int256_hashing.reference\n@@ -0,0 +1,24 @@\n+0\n+123\n+123\n+[1,1,2]\n+0\n+123\n+123\n+[1,1,2]\n+0\n+123\n+123\n+[1,1,2]\n+0\n+321\n+321\n+[1,1,2]\n+0\n+321\n+321\n+[1,1,2]\n+0\n+321\n+321\n+[1,1,2]\ndiff --git a/tests/queries/0_stateless/01457_int256_hashing.sql b/tests/queries/0_stateless/01457_int256_hashing.sql\nnew file mode 100644\nindex 000000000000..d6d655e80f3d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_int256_hashing.sql\n@@ -0,0 +1,39 @@\n+SELECT toUInt256(123) IN (NULL);\n+SELECT toUInt256(123) AS k GROUP BY k;\n+SELECT toUInt256(123) AS k FROM system.one INNER JOIN (SELECT toUInt256(123) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toUInt256(123), toUInt256(456), toUInt256(123)]);\n+\n+SELECT toInt256(123) IN (NULL);\n+SELECT toInt256(123) AS k GROUP BY k;\n+SELECT toInt256(123) AS k FROM system.one INNER JOIN (SELECT toInt256(123) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toInt256(123), toInt256(456), toInt256(123)]);\n+\n+-- SELECT toUInt128(123) IN (NULL);\n+-- SELECT toUInt128(123) AS k GROUP BY k;\n+-- SELECT toUInt128(123) AS k FROM system.one INNER JOIN (SELECT toUInt128(123) AS k) t USING k;\n+-- SELECT arrayEnumerateUniq([toUInt128(123), toUInt128(456), toUInt128(123)]);\n+\n+SELECT toInt128(123) IN (NULL);\n+SELECT toInt128(123) AS k GROUP BY k;\n+SELECT toInt128(123) AS k FROM system.one INNER JOIN (SELECT toInt128(123) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toInt128(123), toInt128(456), toInt128(123)]);\n+\n+SELECT toNullable(toUInt256(321)) IN (NULL);\n+SELECT toNullable(toUInt256(321)) AS k GROUP BY k;\n+SELECT toNullable(toUInt256(321)) AS k FROM system.one INNER JOIN (SELECT toUInt256(321) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toNullable(toUInt256(321)), toNullable(toUInt256(456)), toNullable(toUInt256(321))]);\n+\n+SELECT toNullable(toInt256(321)) IN (NULL);\n+SELECT toNullable(toInt256(321)) AS k GROUP BY k;\n+SELECT toNullable(toInt256(321)) AS k FROM system.one INNER JOIN (SELECT toInt256(321) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toNullable(toInt256(321)), toNullable(toInt256(456)), toNullable(toInt256(321))]);\n+\n+-- SELECT toNullable(toUInt128(321)) IN (NULL);\n+-- SELECT toNullable(toUInt128(321)) AS k GROUP BY k;\n+-- SELECT toNullable(toUInt128(321)) AS k FROM system.one INNER JOIN (SELECT toUInt128(321) AS k) t USING k;\n+-- SELECT arrayEnumerateUniq([toNullable(toUInt128(321)), toNullable(toUInt128(456)), toNullable(toUInt128(321))]);\n+\n+SELECT toNullable(toInt128(321)) IN (NULL);\n+SELECT toNullable(toInt128(321)) AS k GROUP BY k;\n+SELECT toNullable(toInt128(321)) AS k FROM system.one INNER JOIN (SELECT toInt128(321) AS k) t USING k;\n+SELECT arrayEnumerateUniq([toNullable(toInt128(321)), toNullable(toInt128(456)), toNullable(toInt128(321))]);\n",
  "problem_statement": "Highlight a bug in extented integers/decimals\nChangelog category (leave one):\r\n- Not For Changelog\r\n\r\nhttps://clickhouse-test-reports.s3.yandex.net/12413/ad4934d7fb24987656679b305e6cd7b69d3b3f09/fuzzer/fuzzer.log#fail1\r\nhttps://github.com/ClickHouse/ClickHouse/pull/12413\r\n\r\n@4ertus2 Could you please continue in this branch?\nGROUP BY Nullable(UInt256): wrong result\nNot released yet.\r\n\r\n```\r\nSELECT toNullable(toUInt256(123)) AS k\r\nGROUP BY k\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500k\u2500\u2510\r\n\u2502 26050106480830410844870090986039688399620648588929830570151859191848 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "\n",
  "created_at": "2020-08-28T21:02:31Z"
}