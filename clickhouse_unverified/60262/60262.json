{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60262,
  "instance_id": "ClickHouse__ClickHouse-60262",
  "issue_numbers": [
    "60122"
  ],
  "base_commit": "d4146c1e26b8eba2f7dca45a9b478957d746a408",
  "patch": "diff --git a/src/Common/LRUResourceCache.h b/src/Common/LRUResourceCache.h\nindex 4ccaa272346d..60b4053bff53 100644\n--- a/src/Common/LRUResourceCache.h\n+++ b/src/Common/LRUResourceCache.h\n@@ -221,7 +221,7 @@ class LRUResourceCache\n         {\n             std::lock_guard lock(mutex);\n             auto it = cells.find(key);\n-            if (it != cells.end() && !it->second.expired)\n+            if (it != cells.end())\n             {\n                 if (!it->second.expired)\n                 {\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_lru_resource_cache.cpp b/src/Common/tests/gtest_lru_resource_cache.cpp\nindex bc037824ff88..94490d1e86da 100644\n--- a/src/Common/tests/gtest_lru_resource_cache.cpp\n+++ b/src/Common/tests/gtest_lru_resource_cache.cpp\n@@ -45,6 +45,33 @@ struct MyWeight\n     size_t operator()(const int & x) const { return static_cast<size_t>(x); }\n };\n \n+TEST(LRUResourceCache, remove2)\n+{\n+    using MyCache = DB::LRUResourceCache<int, int, MyWeight>;\n+    auto mcache = MyCache(10, 10);\n+    for (int i = 1; i < 5; ++i)\n+    {\n+        auto load_int = [&] { return std::make_shared<int>(i); };\n+        mcache.getOrSet(i, load_int);\n+    }\n+\n+    auto n = mcache.size();\n+    ASSERT_EQ(n, 4);\n+    auto w = mcache.weight();\n+    ASSERT_EQ(w, 10);\n+    auto holder4 = mcache.get(4);\n+    ASSERT_TRUE(holder4 != nullptr);\n+    mcache.tryRemove(4);\n+    auto holder_reget_4 = mcache.get(4);\n+    ASSERT_TRUE(holder_reget_4 == nullptr);\n+    mcache.getOrSet(4, [&]() { return std::make_shared<int>(4); });\n+    holder4.reset();\n+    auto holder1 = mcache.getOrSet(1, [&]() { return std::make_shared<int>(1); });\n+    ASSERT_TRUE(holder1 != nullptr);\n+    auto holder7 = mcache.getOrSet(7, [&] { return std::make_shared<int>(7); });\n+    ASSERT_TRUE(holder7 != nullptr);\n+}\n+\n TEST(LRUResourceCache, evictOnWweight)\n {\n     using MyCache = DB::LRUResourceCache<int, int, MyWeight>;\n",
  "problem_statement": "Fatal error occurs when reusing the LRUResource Cache\nHello, I am currently working on secondary development based on ClickHouse. During the development process, I reused the LRUResource Cache. Unexpectedly, I encountered a Fatal error during usage.\r\n\r\n```Bash\r\n[ 272 ] {} <Error> LRUResourceCache: LRUResourceCache became inconsistent. There must be a bug in it.\r\n[ 552 ] {} <Fatal> BaseDaemon: ########################################\r\n[ 552 ] {} <Fatal> BaseDaemon: (version 23.3.2.1, build id: 52E0E50941B9FC4B3DD14160980076B127C3AB6E) (from thread 272) (no query) Received signal Aborted (6)\r\n[ 552 ] {} <Fatal> BaseDaemon: \r\n[ 552 ] {} <Fatal> BaseDaemon: Stack trace: 0x7fe924d3e00b 0x7fe924d1d859 0x18343b0a 0x183404df 0x17bdb16d 0x17b9f4a3 0x17b9d94d 0x17d390df 0x179bfd9b 0x179bfa0a 0x1191286e 0x1191247c 0x1190ebed 0x1190e76e 0x7fe924ef5609 0x7fe924e1a133\r\n[ 552 ] {} <Fatal> BaseDaemon: 3. raise @ 0x7fe924d3e00b in ?\r\n[ 552 ] {} <Fatal> BaseDaemon: 4. abort @ 0x7fe924d1d859 in ?\r\n[ 552 ] {} <Fatal> BaseDaemon: 5.1. inlined from ./build/./contrib/llvm-project/libcxx/include/string:1624: String::__zero[abi:v15000]()\r\n[ 552 ] {} <Fatal> BaseDaemon: 5.2. inlined from ./build/./contrib/llvm-project/libcxx/include/string:1515: String::__default_init[abi:v15000]()\r\n[ 552 ] {} <Fatal> BaseDaemon: 5.3. inlined from ./build/./contrib/llvm-project/libcxx/include/string:1902: basic_string\r\n[ 552 ] {} <Fatal> BaseDaemon: 5. ./build/./src/Common/LRUResourceCache.h:367: DB::LRUResourceCache<VectorIndex::CacheKey, VectorIndex::IndexWithMeta, VectorIndex::IndexWithMetaWeightFunc, VectorIndex::IndexWithMetaReleaseFunction, std::hash<VectorIndex::CacheKey>>::set(VectorIndex::CacheKey const&, std::shared_ptr<VectorIndex::IndexWithMeta>) @ 0x18343b0a in /usr/bin/clickhouse\r\n[ 552 ] {} <Fatal> BaseDaemon: 6.1. inlined from ./build/./src/Common/LRUResourceCache.h:0: std::shared_ptr<VectorIndex::IndexWithMeta> DB::LRUResourceCache<VectorIndex::CacheKey, VectorIndex::IndexWithMeta, VectorIndex::IndexWithMetaWeightFunc, VectorIndex::IndexWithMetaReleaseFunction, std::hash<VectorIndex::CacheKey>>::getImpl<VectorIndex::CacheManager::put(VectorIndex::CacheKey const&, std::shared_ptr<VectorIndex::IndexWithMeta>)::$_0&>(VectorIndex::CacheKey const&, VectorIndex::CacheManager::put(VectorIndex::CacheKey const&, std::shared_ptr<VectorIndex::IndexWithMeta>)::$_0&)\r\n[ 552 ] {} <Fatal> BaseDaemon: 6.2. inlined from ./build/./src/Common/LRUResourceCache.h:83: std::unique_ptr<DB::LRUResourceCache<VectorIndex::CacheKey, VectorIndex::IndexWithMeta, VectorIndex::IndexWithMetaWeightFunc, VectorIndex::IndexWithMetaReleaseFunction, std::hash<VectorIndex::CacheKey>>::MappedHolder, std::default_delete<DB::LRUResourceCache<VectorIndex::CacheKey, VectorIndex::IndexWithMeta, VectorIndex::IndexWithMetaWeightFunc, VectorIndex::IndexWithMetaReleaseFunction, std::hash<VectorIndex::CacheKey>>::MappedHolder>> DB::LRUResourceCache<VectorIndex::CacheKey, VectorIndex::IndexWithMeta, VectorIndex::IndexWithMetaWeightFunc, VectorIndex::IndexWithMetaReleaseFunction, std::hash<VectorIndex::CacheKey>>::getOrSet<VectorIndex::CacheManager::put(VectorIndex::CacheKey const&, std::shared_ptr<VectorIndex::IndexWithMeta>)::$_0>(VectorIndex::CacheKey const&, VectorIndex::CacheManager::put(VectorIndex::CacheKey const&, std::shared_ptr<VectorIndex::IndexWithMeta>)::$_0&&)\r\n```\r\n\r\nThe corresponding code is as follows:\r\n\r\n```c++\r\n// key mustn't be in the cache\r\nCell * set(const Key & insert_key, MappedPtr value)\r\n{\r\n\r\n    ...\r\n\r\n    while (is_overflow() && queue_size > 1 && key_it != queue.end())\r\n    {\r\n        const Key & key = *key_it;\r\n\r\n        auto cell_it = cells.find(key);\r\n        if (cell_it == cells.end())\r\n        {\r\n            LOG_ERROR(&Poco::Logger::get(\"LRUResourceCache\"), \"LRUResourceCache became inconsistent. There must be a bug in it.\");\r\n            abort();\r\n        }\r\n\r\n        auto & cell = cell_it->second;\r\n        if (cell.reference_count == 0)\r\n        {\r\n            loss_weight += cell.weight;\r\n            queue_size--;\r\n            to_release_keys.insert(key);\r\n        }\r\n\r\n        ++key_it;\r\n    }\r\n\r\n    ...\r\n}\r\n```\r\n\r\nAfter investigation, I found that a cache key exists in the queue but not in the cells. Upon further investigation, I discovered that in my code, I mistakenly executed the tryRemove operation on this cache key, causing the corresponding cache to become expired. Subsequently, I reloaded the cache item corresponding to this cache key using the getOrSet operation. At this point, the expired cache item still existed in the cells. When the LRUResourceCache::set method was eventually executed:\r\n\r\n```c++\r\nCell * set(const Key & insert_key, MappedPtr value)\r\n{\r\n\t...\r\n\r\n\tcurrent_weight = current_weight + weight - loss_weight;\r\n\t\t\r\n\tauto & new_cell = cells[insert_key];\r\n\tnew_cell.value = value;\r\n\tnew_cell.weight = weight;\r\n\tnew_cell.queue_iterator = queue.insert(queue.end(), insert_key);\r\n\treturn &new_cell;\r\n}\r\n```\r\n\r\nThe expired cache item corresponding to the insert_key in `auto & new_cell = cells[insert_key]` still existed. This resulted in the insertion of duplicate cache keys into the queue, ultimately leading to the problem of not finding the corresponding item when cleaning up items in cells based on cache keys in the queue (because the corresponding cache item had already been cleaned up by the previous duplicate cache key).\r\n\r\nCurrently, this behavior is caused by my incorrect use of the tryRemove operation. However, I believe that this behavior should not result in an abort. If this behavior is indeed abnormal, I am willing to submit a PR to fix it.\r\n\n",
  "hints_text": "The LRUResource Cache code is based on the version at https://github.com/ClickHouse/ClickHouse/blob/6bf29cb6103ff3a33d6e2fc6cbc5360b7e3f0be0/src/Common/LRUResourceCache.h\nI attempted to simulate the above scenario locally using gtest.\r\nAdd the following code to `gtest_lru_resource_cache.cpp`:\r\n\r\n```c++\r\nTEST(LRUResourceCache, abortTest)\r\n{\r\n    using MyCache = DB::LRUResourceCache<int, int, MyWeight>;\r\n    auto mcache = MyCache(11, 10);\r\n    for (int i = 1; i < 5; ++i)\r\n    {\r\n        auto load_int = [&] { return std::make_shared<int>(i); };\r\n        mcache.getOrSet(i, load_int);\r\n    }\r\n\r\n    auto holder4 = mcache.get(4);\r\n    mcache.tryRemove(4);\r\n\r\n    for (int i = 1; i < 5; ++i)\r\n    {\r\n        auto load_int = [&] { return std::make_shared<int>(i); };\r\n        mcache.getOrSet(i, load_int);\r\n    }\r\n\r\n    holder4.reset();\r\n\r\n    for (int i = 1; i < 5; ++i)\r\n    {\r\n        auto load_int = [&] { return std::make_shared<int>(i); };\r\n        mcache.getOrSet(i, load_int);\r\n    }\r\n}\r\n```\r\nExecuted the test case that was just added:\r\n\r\n```bash\r\n./unit_tests_dbms --gtest_filter=\"LRUResourceCache*\"`\r\n```\r\nEncountered a core dump:\r\n\r\n```bash\r\n> ./unit_tests_dbms --gtest_filter=\"LRUResourceCache*\"\r\nNote: Google Test filter = LRUResourceCache*\r\n[==========] Running 11 tests from 1 test suite.\r\n[----------] Global test environment set-up.\r\n[----------] 11 tests from LRUResourceCache\r\n[ RUN      ] LRUResourceCache.get\r\n[       OK ] LRUResourceCache.get (0 ms)\r\n[ RUN      ] LRUResourceCache.remove\r\n[       OK ] LRUResourceCache.remove (0 ms)\r\n[ RUN      ] LRUResourceCache.abortTest\r\nLRUResourceCache became inconsistent. There must be a bug in it.\r\n[1]    689045 abort (core dumped)  ./unit_tests_dbms --gtest_filter=\"LRUResourceCache*\"\r\n```\r\n\r\n\r\n",
  "created_at": "2024-02-22T03:01:57Z"
}