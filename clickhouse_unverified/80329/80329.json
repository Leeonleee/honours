{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80329,
  "instance_id": "ClickHouse__ClickHouse-80329",
  "issue_numbers": [
    "40273"
  ],
  "base_commit": "14e1ccabc66c3828e9e3c0d4322fe3b217678dd9",
  "patch": "diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex d5b63a9bb0e0..e39a9fb5750f 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -2357,7 +2357,7 @@ struct ConjunctionNodes\n /// Assuming predicate is a conjunction (probably, trivial).\n /// Find separate conjunctions nodes. Split nodes into allowed and rejected sets.\n /// Allowed predicate is a predicate which can be calculated using only nodes from the allowed_nodes set.\n-ConjunctionNodes getConjunctionNodes(ActionsDAG::Node * predicate, std::unordered_set<const ActionsDAG::Node *> allowed_nodes)\n+ConjunctionNodes getConjunctionNodes(ActionsDAG::Node * predicate, std::unordered_set<const ActionsDAG::Node *> allowed_nodes, bool allow_non_deterministic_functions)\n {\n     ConjunctionNodes conjunction;\n     std::unordered_set<const ActionsDAG::Node *> allowed;\n@@ -2428,7 +2428,13 @@ ConjunctionNodes getConjunctionNodes(ActionsDAG::Node * predicate, std::unordere\n         {\n             if (cur.num_allowed_children == cur.node->children.size())\n             {\n-                if (cur.node->type != ActionsDAG::ActionType::ARRAY_JOIN && cur.node->type != ActionsDAG::ActionType::INPUT)\n+                bool is_deprecated_function = !allow_non_deterministic_functions\n+                    && cur.node->type == ActionsDAG::ActionType::FUNCTION\n+                    && !cur.node->function_base->isDeterministicInScopeOfQuery();\n+\n+                if (cur.node->type != ActionsDAG::ActionType::ARRAY_JOIN\n+                    && cur.node->type != ActionsDAG::ActionType::INPUT\n+                    && !is_deprecated_function)\n                     allowed_nodes.emplace(cur.node);\n             }\n \n@@ -2578,7 +2584,8 @@ std::optional<ActionsDAG> ActionsDAG::splitActionsForFilterPushDown(\n     const std::string & filter_name,\n     bool removes_filter,\n     const Names & available_inputs,\n-    const ColumnsWithTypeAndName & all_inputs)\n+    const ColumnsWithTypeAndName & all_inputs,\n+    bool allow_non_deterministic_functions)\n {\n     Node * predicate = const_cast<Node *>(tryFindInOutputs(filter_name));\n     if (!predicate)\n@@ -2611,7 +2618,7 @@ std::optional<ActionsDAG> ActionsDAG::splitActionsForFilterPushDown(\n         }\n     }\n \n-    auto conjunction = getConjunctionNodes(predicate, allowed_nodes);\n+    auto conjunction = getConjunctionNodes(predicate, allowed_nodes, allow_non_deterministic_functions);\n \n     if (conjunction.allowed.empty())\n         return {};\n@@ -2688,9 +2695,9 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu\n     auto right_stream_allowed_nodes = get_input_nodes(right_stream_available_columns_to_push_down);\n     auto both_streams_allowed_nodes = get_input_nodes(equivalent_columns_to_push_down);\n \n-    auto left_stream_push_down_conjunctions = getConjunctionNodes(predicate, left_stream_allowed_nodes);\n-    auto right_stream_push_down_conjunctions = getConjunctionNodes(predicate, right_stream_allowed_nodes);\n-    auto both_streams_push_down_conjunctions = getConjunctionNodes(predicate, both_streams_allowed_nodes);\n+    auto left_stream_push_down_conjunctions = getConjunctionNodes(predicate, left_stream_allowed_nodes, false);\n+    auto right_stream_push_down_conjunctions = getConjunctionNodes(predicate, right_stream_allowed_nodes, false);\n+    auto both_streams_push_down_conjunctions = getConjunctionNodes(predicate, both_streams_allowed_nodes, false);\n \n     NodeRawConstPtrs left_stream_allowed_conjunctions = std::move(left_stream_push_down_conjunctions.allowed);\n     NodeRawConstPtrs right_stream_allowed_conjunctions = std::move(right_stream_push_down_conjunctions.allowed);\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex b561bbf46ebe..9e2e94c173fe 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -390,7 +390,8 @@ class ActionsDAG\n         const std::string & filter_name,\n         bool removes_filter,\n         const Names & available_inputs,\n-        const ColumnsWithTypeAndName & all_inputs);\n+        const ColumnsWithTypeAndName & all_inputs,\n+        bool allow_non_deterministic_functions);\n \n     struct ActionsForJOINFilterPushDown;\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp b/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp\nindex 5796ef5a610b..61859de1d79c 100644\n--- a/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp\n@@ -104,7 +104,7 @@ static NameSet findIdentifiersOfNode(const ActionsDAG::Node * node)\n     return res;\n }\n \n-static std::optional<ActionsDAG> splitFilter(QueryPlan::Node * parent_node, const Names & available_inputs, size_t child_idx = 0)\n+static std::optional<ActionsDAG> splitFilter(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, const Names & available_inputs, size_t child_idx = 0)\n {\n     QueryPlan::Node * child_node = parent_node->children.front();\n     checkChildrenSize(child_node, child_idx + 1);\n@@ -118,7 +118,8 @@ static std::optional<ActionsDAG> splitFilter(QueryPlan::Node * parent_node, cons\n     bool removes_filter = filter->removesFilterColumn();\n \n     const auto & all_inputs = child->getInputHeaders()[child_idx].getColumnsWithTypeAndName();\n-    return expression.splitActionsForFilterPushDown(filter_column_name, removes_filter, available_inputs, all_inputs);\n+    bool allow_deterministic_functions = !step_changes_the_number_of_rows;\n+    return expression.splitActionsForFilterPushDown(filter_column_name, removes_filter, available_inputs, all_inputs, allow_deterministic_functions);\n }\n \n static size_t\n@@ -186,10 +187,10 @@ addNewFilterStepOrThrow(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes,\n }\n \n static size_t\n-tryAddNewFilterStep(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes, const Names & allowed_inputs,\n+tryAddNewFilterStep(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, QueryPlan::Nodes & nodes, const Names & allowed_inputs,\n                     bool can_remove_filter = true, size_t child_idx = 0)\n {\n-    if (auto split_filter = splitFilter(parent_node, allowed_inputs, child_idx))\n+    if (auto split_filter = splitFilter(parent_node, step_changes_the_number_of_rows, allowed_inputs, child_idx))\n         return addNewFilterStepOrThrow(parent_node, nodes, std::move(*split_filter), can_remove_filter, child_idx);\n     return 0;\n }\n@@ -197,12 +198,12 @@ tryAddNewFilterStep(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes, con\n \n /// Push down filter through specified type of step\n template <typename Step>\n-static size_t simplePushDownOverStep(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes, QueryPlanStepPtr & child)\n+static size_t simplePushDownOverStep(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, QueryPlan::Nodes & nodes, QueryPlanStepPtr & child)\n {\n     if (typeid_cast<Step *>(child.get()))\n     {\n         Names allowed_inputs = child->getOutputHeader().getNames();\n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, allowed_inputs))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, step_changes_the_number_of_rows, nodes, allowed_inputs))\n             return updated_steps;\n     }\n     return 0;\n@@ -507,7 +508,7 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes\n         bool filter_is_not_among_aggregates_arguments = merging_aggregated || filterColumnIsNotAmongAggregatesArguments(params.aggregates, filter->getFilterColumnName());\n         const bool can_remove_filter = filter_column_is_not_among_aggregation_keys && filter_is_not_among_aggregates_arguments;\n \n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, keys, can_remove_filter))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, keys, can_remove_filter))\n             return updated_steps;\n     }\n \n@@ -568,7 +569,7 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes\n         ///    ) group by y with totals) where y != 2`\n         /// Optimization will replace totals row `y, sum(x)` from `(0, 45)` to `(0, 37)`.\n         /// It is expected to ok, cause AST optimization `enable_optimize_predicate_expression = 1` also brakes it.\n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, keys))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, keys))\n             return updated_steps;\n     }\n \n@@ -584,11 +585,11 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes\n             if (!keys_set.contains(column.name))\n                 allowed_inputs.push_back(column.name);\n \n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, allowed_inputs))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, allowed_inputs))\n             return updated_steps;\n     }\n \n-    if (auto updated_steps = simplePushDownOverStep<DistinctStep>(parent_node, nodes, child))\n+    if (auto updated_steps = simplePushDownOverStep<DistinctStep>(parent_node, true, nodes, child))\n         return updated_steps;\n \n     if (auto updated_steps = tryPushDownOverJoinStep(parent_node, nodes, child))\n@@ -619,14 +620,14 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes\n         bool can_remove_filter = sort_description_it == sort_description.end();\n \n         Names allowed_inputs = child->getOutputHeader().getNames();\n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, allowed_inputs, can_remove_filter))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs, can_remove_filter))\n             return updated_steps;\n     }\n \n     if (typeid_cast<CustomMetricLogViewStep *>(child.get()))\n     {\n         Names allowed_inputs = {\"event_date\", \"event_time\", \"hostname\"};\n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, allowed_inputs, true))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, allowed_inputs, true))\n             return updated_steps;\n     }\n \n@@ -636,7 +637,7 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes\n         bool can_remove_filter = !join_filter_set_step->isColumnPartOfSetKey(filter_column_name);\n \n         Names allowed_inputs = child->getOutputHeader().getNames();\n-        if (auto updated_steps = tryAddNewFilterStep(parent_node, nodes, allowed_inputs, can_remove_filter))\n+        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs, can_remove_filter))\n             return updated_steps;\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03513_filter_push_down_rand_bug.reference b/tests/queries/0_stateless/03513_filter_push_down_rand_bug.reference\nnew file mode 100644\nindex 000000000000..573541ac9702\n--- /dev/null\n+++ b/tests/queries/0_stateless/03513_filter_push_down_rand_bug.reference\n@@ -0,0 +1,1 @@\n+0\ndiff --git a/tests/queries/0_stateless/03513_filter_push_down_rand_bug.sql b/tests/queries/0_stateless/03513_filter_push_down_rand_bug.sql\nnew file mode 100644\nindex 000000000000..972160b5c81c\n--- /dev/null\n+++ b/tests/queries/0_stateless/03513_filter_push_down_rand_bug.sql\n@@ -0,0 +1,21 @@\n+drop table if exists users_items;\n+CREATE TABLE users_items (user_id UInt64) ENGINE = Log;\n+INSERT INTO users_items SELECT bitAnd(number, 15) from numbers(64);\n+\n+SELECT sum(in_sample)\n+FROM\n+(\n+    WITH RandomUsers AS\n+        (\n+            SELECT\n+                user_id,\n+                rand() % 2 AS in_sample\n+            FROM users_items\n+            GROUP BY user_id\n+        )\n+    SELECT\n+        user_id,\n+        in_sample\n+    FROM RandomUsers\n+    WHERE in_sample = 0\n+);\n",
  "problem_statement": "WHERE clause returns incorrect results on RAND() on GROUP BY passed on from WITH clause or subquery\nIf for example you have a table `users_items`,  that has `user_id`, `item_id` as columns, such that `user_id` can be associated with multiple `item_id`(s) and vice versa. \r\n\r\nAnd you want to assign a random value to each unique user via a `GROUP BY` and `RAND()` as the following:\r\n\r\n```sql\r\nWITH RandomUsers AS \r\n    (SELECT \r\n        user_id,\r\n        rand() % 2 AS in_sample\r\n    FROM users_items\r\n    GROUP BY user_id)\r\nSELECT user_id, in_sample\r\nFROM RandomUsers\r\nWHERE in_sample = 1\r\n```\r\nAll rows are returned and not just those with `in_sample = 1`\r\n\r\n**Does it reproduce on recent release?**\r\n\r\n22.8.1 revision 54460\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nWITH RandomUsers AS \r\n    (SELECT \r\n        user_id,\r\n        rand() % 2 AS in_sample\r\n    FROM users_items\r\n    GROUP BY user_id)\r\nSELECT user_id, in_sample\r\nFROM RandomUsers\r\nWHERE in_sample = 1\r\n```\r\n\r\nThe `WHERE` CLAUSE does not work and all rows are returned irrespective of the condition. If however, you do a `GROUP BY` instead, the rows are aggregated correctly together. \r\n\r\n```sql\r\nWITH RandomUsers AS \r\n    (SELECT \r\n        user_id,\r\n        rand() % 2 AS in_sample\r\n    FROM users_items\r\n    GROUP BY user_id)\r\nSELECT in_sample, count() \r\nFROM RandomUsers \r\nGROUP BY in_sample\r\n```\r\nThe same issue occurs when using a subquery instead of a WITH.\r\n\r\nTo recreate the issue, one can follow the steps below:\r\n\r\n**Create table**\r\n\r\n```sql \r\nCREATE TABLE default.users_items\r\n(\r\n    `user_id` Int32,\r\n    `item_id` Int32\r\n)\r\nENGINE = Memory\r\n```\r\n\r\n**Example data**\r\n\r\n[user_items_data.csv](https://github.com/ClickHouse/ClickHouse/files/9351609/user_items_data.csv)\r\n\r\n**Expected behavior**\r\n\r\nIf the where clause specifies `in_sample = 1` then it should return only the rows where `in_sample` is `1` and not both. Same applies for when `in_sample = 0`.\n",
  "hints_text": "How to reproduce: https://pastila.nl/?00640a57/a6fdfc517968ba8d3b57ca896fa669f6#t6CZyoed3DEjGuJJpcEoKA==\nWorkaround: `SET query_plan_filter_push_down = 0`\n\nThe cause: the expression with rand is calculated after GROUP BY, but the push-down optimization also adds the same expression into WHERE before GROUP BY. Then the expression is calculated twice, with different results.",
  "created_at": "2025-05-16T10:47:01Z"
}