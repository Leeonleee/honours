{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56064,
  "instance_id": "ClickHouse__ClickHouse-56064",
  "issue_numbers": [
    "55576"
  ],
  "base_commit": "c1c7218d53cc00f493280ae8d9ee3208301d6de2",
  "patch": "diff --git a/programs/library-bridge/LibraryBridgeHandlers.cpp b/programs/library-bridge/LibraryBridgeHandlers.cpp\nindex 9642dd7ee634..7c77e633a446 100644\n--- a/programs/library-bridge/LibraryBridgeHandlers.cpp\n+++ b/programs/library-bridge/LibraryBridgeHandlers.cpp\n@@ -2,6 +2,7 @@\n \n #include \"CatBoostLibraryHandler.h\"\n #include \"CatBoostLibraryHandlerFactory.h\"\n+#include \"Common/ProfileEvents.h\"\n #include \"ExternalDictionaryLibraryHandler.h\"\n #include \"ExternalDictionaryLibraryHandlerFactory.h\"\n \n@@ -44,7 +45,7 @@ namespace\n         response.setStatusAndReason(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n \n         if (!response.sent())\n-            *response.send() << message << std::endl;\n+            *response.send() << message << '\\n';\n \n         LOG_WARNING(&Poco::Logger::get(\"LibraryBridge\"), fmt::runtime(message));\n     }\n@@ -96,7 +97,7 @@ ExternalDictionaryLibraryBridgeRequestHandler::ExternalDictionaryLibraryBridgeRe\n }\n \n \n-void ExternalDictionaryLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void ExternalDictionaryLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n     HTMLForm params(getContext()->getSettingsRef(), request);\n@@ -384,7 +385,7 @@ ExternalDictionaryLibraryBridgeExistsHandler::ExternalDictionaryLibraryBridgeExi\n }\n \n \n-void ExternalDictionaryLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void ExternalDictionaryLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\n@@ -423,7 +424,7 @@ CatBoostLibraryBridgeRequestHandler::CatBoostLibraryBridgeRequestHandler(\n }\n \n \n-void CatBoostLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void CatBoostLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n     HTMLForm params(getContext()->getSettingsRef(), request);\n@@ -621,7 +622,7 @@ CatBoostLibraryBridgeExistsHandler::CatBoostLibraryBridgeExistsHandler(size_t ke\n }\n \n \n-void CatBoostLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void CatBoostLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\ndiff --git a/programs/library-bridge/LibraryBridgeHandlers.h b/programs/library-bridge/LibraryBridgeHandlers.h\nindex 16815e847232..4f08d7a60840 100644\n--- a/programs/library-bridge/LibraryBridgeHandlers.h\n+++ b/programs/library-bridge/LibraryBridgeHandlers.h\n@@ -20,7 +20,7 @@ class ExternalDictionaryLibraryBridgeRequestHandler : public HTTPRequestHandler,\n public:\n     ExternalDictionaryLibraryBridgeRequestHandler(size_t keep_alive_timeout_, ContextPtr context_);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     static constexpr inline auto FORMAT = \"RowBinary\";\n@@ -36,7 +36,7 @@ class ExternalDictionaryLibraryBridgeExistsHandler : public HTTPRequestHandler,\n public:\n     ExternalDictionaryLibraryBridgeExistsHandler(size_t keep_alive_timeout_, ContextPtr context_);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     const size_t keep_alive_timeout;\n@@ -65,7 +65,7 @@ class CatBoostLibraryBridgeRequestHandler : public HTTPRequestHandler, WithConte\n public:\n     CatBoostLibraryBridgeRequestHandler(size_t keep_alive_timeout_, ContextPtr context_);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     const size_t keep_alive_timeout;\n@@ -79,7 +79,7 @@ class CatBoostLibraryBridgeExistsHandler : public HTTPRequestHandler, WithContex\n public:\n     CatBoostLibraryBridgeExistsHandler(size_t keep_alive_timeout_, ContextPtr context_);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     const size_t keep_alive_timeout;\ndiff --git a/programs/odbc-bridge/ColumnInfoHandler.cpp b/programs/odbc-bridge/ColumnInfoHandler.cpp\nindex 434abf0bf14c..774883657b71 100644\n--- a/programs/odbc-bridge/ColumnInfoHandler.cpp\n+++ b/programs/odbc-bridge/ColumnInfoHandler.cpp\n@@ -69,7 +69,7 @@ namespace\n }\n \n \n-void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n@@ -78,7 +78,7 @@ void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServ\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n         if (!response.sent())\n-            *response.send() << message << std::endl;\n+            *response.send() << message << '\\n';\n         LOG_WARNING(log, fmt::runtime(message));\n     };\n \ndiff --git a/programs/odbc-bridge/ColumnInfoHandler.h b/programs/odbc-bridge/ColumnInfoHandler.h\nindex 3ba8b182ba60..e3087701182c 100644\n--- a/programs/odbc-bridge/ColumnInfoHandler.h\n+++ b/programs/odbc-bridge/ColumnInfoHandler.h\n@@ -23,7 +23,7 @@ class ODBCColumnsInfoHandler : public HTTPRequestHandler, WithContext\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     Poco::Logger * log;\ndiff --git a/programs/odbc-bridge/IdentifierQuoteHandler.cpp b/programs/odbc-bridge/IdentifierQuoteHandler.cpp\nindex f622995bf154..a23efb112de4 100644\n--- a/programs/odbc-bridge/IdentifierQuoteHandler.cpp\n+++ b/programs/odbc-bridge/IdentifierQuoteHandler.cpp\n@@ -21,7 +21,7 @@\n \n namespace DB\n {\n-void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n@@ -30,7 +30,7 @@ void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServ\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n         if (!response.sent())\n-            *response.send() << message << std::endl;\n+            response.send()->writeln(message);\n         LOG_WARNING(log, fmt::runtime(message));\n     };\n \ndiff --git a/programs/odbc-bridge/IdentifierQuoteHandler.h b/programs/odbc-bridge/IdentifierQuoteHandler.h\nindex d57bbc0ca8ad..ff5c02ca07b3 100644\n--- a/programs/odbc-bridge/IdentifierQuoteHandler.h\n+++ b/programs/odbc-bridge/IdentifierQuoteHandler.h\n@@ -21,7 +21,7 @@ class IdentifierQuoteHandler : public HTTPRequestHandler, WithContext\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     Poco::Logger * log;\ndiff --git a/programs/odbc-bridge/MainHandler.cpp b/programs/odbc-bridge/MainHandler.cpp\nindex 9130b3e0f47b..e350afa2b103 100644\n--- a/programs/odbc-bridge/MainHandler.cpp\n+++ b/programs/odbc-bridge/MainHandler.cpp\n@@ -46,12 +46,12 @@ void ODBCHandler::processError(HTTPServerResponse & response, const std::string\n {\n     response.setStatusAndReason(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n     if (!response.sent())\n-        *response.send() << message << std::endl;\n+        *response.send() << message << '\\n';\n     LOG_WARNING(log, fmt::runtime(message));\n }\n \n \n-void ODBCHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void ODBCHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     HTMLForm params(getContext()->getSettingsRef(), request);\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\ndiff --git a/programs/odbc-bridge/MainHandler.h b/programs/odbc-bridge/MainHandler.h\nindex bc0fca8b9a51..7977245ff821 100644\n--- a/programs/odbc-bridge/MainHandler.h\n+++ b/programs/odbc-bridge/MainHandler.h\n@@ -30,7 +30,7 @@ class ODBCHandler : public HTTPRequestHandler, WithContext\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     Poco::Logger * log;\ndiff --git a/programs/odbc-bridge/PingHandler.cpp b/programs/odbc-bridge/PingHandler.cpp\nindex e3ab5e5cd00f..80d0e2bf4a9f 100644\n--- a/programs/odbc-bridge/PingHandler.cpp\n+++ b/programs/odbc-bridge/PingHandler.cpp\n@@ -6,7 +6,7 @@\n \n namespace DB\n {\n-void PingHandler::handleRequest(HTTPServerRequest & /* request */, HTTPServerResponse & response)\n+void PingHandler::handleRequest(HTTPServerRequest & /* request */, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\ndiff --git a/programs/odbc-bridge/PingHandler.h b/programs/odbc-bridge/PingHandler.h\nindex c969ec55af76..c5447107e0ce 100644\n--- a/programs/odbc-bridge/PingHandler.h\n+++ b/programs/odbc-bridge/PingHandler.h\n@@ -10,7 +10,7 @@ class PingHandler : public HTTPRequestHandler\n {\n public:\n     explicit PingHandler(size_t keep_alive_timeout_) : keep_alive_timeout(keep_alive_timeout_) {}\n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     size_t keep_alive_timeout;\ndiff --git a/programs/odbc-bridge/SchemaAllowedHandler.cpp b/programs/odbc-bridge/SchemaAllowedHandler.cpp\nindex 020359f51fd7..c7025ca43115 100644\n--- a/programs/odbc-bridge/SchemaAllowedHandler.cpp\n+++ b/programs/odbc-bridge/SchemaAllowedHandler.cpp\n@@ -29,7 +29,7 @@ namespace\n }\n \n \n-void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n@@ -38,7 +38,7 @@ void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServer\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n         if (!response.sent())\n-            *response.send() << message << std::endl;\n+            *response.send() << message << '\\n';\n         LOG_WARNING(log, fmt::runtime(message));\n     };\n \ndiff --git a/programs/odbc-bridge/SchemaAllowedHandler.h b/programs/odbc-bridge/SchemaAllowedHandler.h\nindex cb71a6fb5a2f..aa0b04b1d314 100644\n--- a/programs/odbc-bridge/SchemaAllowedHandler.h\n+++ b/programs/odbc-bridge/SchemaAllowedHandler.h\n@@ -24,7 +24,7 @@ class SchemaAllowedHandler : public HTTPRequestHandler, WithContext\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     Poco::Logger * log;\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 481510d681fb..5d52baf182b5 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -151,6 +151,18 @@ namespace ProfileEvents\n {\n     extern const Event MainConfigLoads;\n     extern const Event ServerStartupMilliseconds;\n+    extern const Event InterfaceNativeSendBytes;\n+    extern const Event InterfaceNativeReceiveBytes;\n+    extern const Event InterfaceHTTPSendBytes;\n+    extern const Event InterfaceHTTPReceiveBytes;\n+    extern const Event InterfacePrometheusSendBytes;\n+    extern const Event InterfacePrometheusReceiveBytes;\n+    extern const Event InterfaceInterserverSendBytes;\n+    extern const Event InterfaceInterserverReceiveBytes;\n+    extern const Event InterfaceMySQLSendBytes;\n+    extern const Event InterfaceMySQLReceiveBytes;\n+    extern const Event InterfacePostgreSQLSendBytes;\n+    extern const Event InterfacePostgreSQLReceiveBytes;\n }\n \n namespace fs = std::filesystem;\n@@ -2045,7 +2057,7 @@ std::unique_ptr<TCPProtocolStackFactory> Server::buildProtocolStackFromConfig(\n     auto create_factory = [&](const std::string & type, const std::string & conf_name) -> TCPServerConnectionFactory::Ptr\n     {\n         if (type == \"tcp\")\n-            return TCPServerConnectionFactory::Ptr(new TCPHandlerFactory(*this, false, false));\n+            return TCPServerConnectionFactory::Ptr(new TCPHandlerFactory(*this, false, false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes));\n \n         if (type == \"tls\")\n #if USE_SSL\n@@ -2057,20 +2069,20 @@ std::unique_ptr<TCPProtocolStackFactory> Server::buildProtocolStackFromConfig(\n         if (type == \"proxy1\")\n             return TCPServerConnectionFactory::Ptr(new ProxyV1HandlerFactory(*this, conf_name));\n         if (type == \"mysql\")\n-            return TCPServerConnectionFactory::Ptr(new MySQLHandlerFactory(*this));\n+            return TCPServerConnectionFactory::Ptr(new MySQLHandlerFactory(*this, ProfileEvents::InterfaceMySQLReceiveBytes, ProfileEvents::InterfaceMySQLSendBytes));\n         if (type == \"postgres\")\n-            return TCPServerConnectionFactory::Ptr(new PostgreSQLHandlerFactory(*this));\n+            return TCPServerConnectionFactory::Ptr(new PostgreSQLHandlerFactory(*this, ProfileEvents::InterfacePostgreSQLReceiveBytes, ProfileEvents::InterfacePostgreSQLSendBytes));\n         if (type == \"http\")\n             return TCPServerConnectionFactory::Ptr(\n-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"HTTPHandler-factory\"))\n+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"HTTPHandler-factory\"), ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes)\n             );\n         if (type == \"prometheus\")\n             return TCPServerConnectionFactory::Ptr(\n-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"PrometheusHandler-factory\"))\n+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"PrometheusHandler-factory\"), ProfileEvents::InterfacePrometheusReceiveBytes, ProfileEvents::InterfacePrometheusSendBytes)\n             );\n         if (type == \"interserver\")\n             return TCPServerConnectionFactory::Ptr(\n-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"InterserverIOHTTPHandler-factory\"))\n+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, \"InterserverIOHTTPHandler-factory\"), ProfileEvents::InterfaceInterserverReceiveBytes, ProfileEvents::InterfaceInterserverSendBytes)\n             );\n \n         throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol configuration error, unknown protocol name '{}'\", type);\n@@ -2203,7 +2215,7 @@ void Server::createServers(\n                     port_name,\n                     \"http://\" + address.toString(),\n                     std::make_unique<HTTPServer>(\n-                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"HTTPHandler-factory\"), server_pool, socket, http_params));\n+                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"HTTPHandler-factory\"), server_pool, socket, http_params, ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes));\n             });\n         }\n \n@@ -2223,7 +2235,7 @@ void Server::createServers(\n                     port_name,\n                     \"https://\" + address.toString(),\n                     std::make_unique<HTTPServer>(\n-                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"HTTPSHandler-factory\"), server_pool, socket, http_params));\n+                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"HTTPSHandler-factory\"), server_pool, socket, http_params, ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes));\n #else\n                 UNUSED(port);\n                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"HTTPS protocol is disabled because Poco library was built without NetSSL support.\");\n@@ -2246,7 +2258,7 @@ void Server::createServers(\n                     port_name,\n                     \"native protocol (tcp): \" + address.toString(),\n                     std::make_unique<TCPServer>(\n-                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ false),\n+                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),\n                         server_pool,\n                         socket,\n                         new Poco::Net::TCPServerParams));\n@@ -2268,7 +2280,7 @@ void Server::createServers(\n                     port_name,\n                     \"native protocol (tcp) with PROXY: \" + address.toString(),\n                     std::make_unique<TCPServer>(\n-                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ true),\n+                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ true, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),\n                         server_pool,\n                         socket,\n                         new Poco::Net::TCPServerParams));\n@@ -2291,7 +2303,7 @@ void Server::createServers(\n                     port_name,\n                     \"secure native protocol (tcp_secure): \" + address.toString(),\n                     std::make_unique<TCPServer>(\n-                        new TCPHandlerFactory(*this, /* secure */ true, /* proxy protocol */ false),\n+                        new TCPHandlerFactory(*this, /* secure */ true, /* proxy protocol */ false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),\n                         server_pool,\n                         socket,\n                         new Poco::Net::TCPServerParams));\n@@ -2315,7 +2327,7 @@ void Server::createServers(\n                     listen_host,\n                     port_name,\n                     \"MySQL compatibility protocol: \" + address.toString(),\n-                    std::make_unique<TCPServer>(new MySQLHandlerFactory(*this), server_pool, socket, new Poco::Net::TCPServerParams));\n+                    std::make_unique<TCPServer>(new MySQLHandlerFactory(*this, ProfileEvents::InterfaceMySQLReceiveBytes, ProfileEvents::InterfaceMySQLSendBytes), server_pool, socket, new Poco::Net::TCPServerParams));\n             });\n         }\n \n@@ -2332,7 +2344,7 @@ void Server::createServers(\n                     listen_host,\n                     port_name,\n                     \"PostgreSQL compatibility protocol: \" + address.toString(),\n-                    std::make_unique<TCPServer>(new PostgreSQLHandlerFactory(*this), server_pool, socket, new Poco::Net::TCPServerParams));\n+                    std::make_unique<TCPServer>(new PostgreSQLHandlerFactory(*this, ProfileEvents::InterfacePostgreSQLReceiveBytes, ProfileEvents::InterfacePostgreSQLSendBytes), server_pool, socket, new Poco::Net::TCPServerParams));\n             });\n         }\n \n@@ -2366,7 +2378,7 @@ void Server::createServers(\n                     port_name,\n                     \"Prometheus: http://\" + address.toString(),\n                     std::make_unique<HTTPServer>(\n-                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"PrometheusHandler-factory\"), server_pool, socket, http_params));\n+                        httpContext(), createHandlerFactory(*this, config, async_metrics, \"PrometheusHandler-factory\"), server_pool, socket, http_params, ProfileEvents::InterfacePrometheusReceiveBytes, ProfileEvents::InterfacePrometheusSendBytes));\n             });\n         }\n     }\n@@ -2412,7 +2424,9 @@ void Server::createInterserverServers(\n                         createHandlerFactory(*this, config, async_metrics, \"InterserverIOHTTPHandler-factory\"),\n                         server_pool,\n                         socket,\n-                        http_params));\n+                        http_params,\n+                        ProfileEvents::InterfaceInterserverReceiveBytes,\n+                        ProfileEvents::InterfaceInterserverSendBytes));\n             });\n         }\n \n@@ -2435,7 +2449,9 @@ void Server::createInterserverServers(\n                         createHandlerFactory(*this, config, async_metrics, \"InterserverIOHTTPSHandler-factory\"),\n                         server_pool,\n                         socket,\n-                        http_params));\n+                        http_params,\n+                        ProfileEvents::InterfaceInterserverReceiveBytes,\n+                        ProfileEvents::InterfaceInterserverSendBytes));\n #else\n                 UNUSED(port);\n                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"SSL support for TCP protocol is disabled because Poco library was built without NetSSL support.\");\ndiff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex 4bdf6288a1cf..d6e5a77b64a3 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -587,6 +587,19 @@ The server successfully detected this situation and will download merged part fr\n     M(LogError, \"Number of log messages with level Error\") \\\n     M(LogFatal, \"Number of log messages with level Fatal\") \\\n     \\\n+    M(InterfaceHTTPSendBytes, \"Number of bytes sent through HTTP interfaces\") \\\n+    M(InterfaceHTTPReceiveBytes, \"Number of bytes received through HTTP interfaces\") \\\n+    M(InterfaceNativeSendBytes, \"Number of bytes sent through native interfaces\") \\\n+    M(InterfaceNativeReceiveBytes, \"Number of bytes received through native interfaces\") \\\n+    M(InterfacePrometheusSendBytes, \"Number of bytes sent through Prometheus interfaces\") \\\n+    M(InterfacePrometheusReceiveBytes, \"Number of bytes received through Prometheus interfaces\") \\\n+    M(InterfaceInterserverSendBytes, \"Number of bytes sent through interserver interfaces\") \\\n+    M(InterfaceInterserverReceiveBytes, \"Number of bytes received through interserver interfaces\") \\\n+    M(InterfaceMySQLSendBytes, \"Number of bytes sent through MySQL interfaces\") \\\n+    M(InterfaceMySQLReceiveBytes, \"Number of bytes received through MySQL interfaces\") \\\n+    M(InterfacePostgreSQLSendBytes, \"Number of bytes sent through PostgreSQL interfaces\") \\\n+    M(InterfacePostgreSQLReceiveBytes, \"Number of bytes received through PostgreSQL interfaces\") \\\n+    \\\n     M(ParallelReplicasUsedCount, \"Number of replicas used to execute a query with task-based parallel replicas\") \\\n \n #ifdef APPLY_FOR_EXTERNAL_EVENTS\ndiff --git a/src/IO/BrotliWriteBuffer.cpp b/src/IO/BrotliWriteBuffer.cpp\nindex a19c6770dad2..a497b78a6c25 100644\n--- a/src/IO/BrotliWriteBuffer.cpp\n+++ b/src/IO/BrotliWriteBuffer.cpp\n@@ -13,33 +13,14 @@ namespace ErrorCodes\n }\n \n \n-class BrotliWriteBuffer::BrotliStateWrapper\n+BrotliWriteBuffer::BrotliStateWrapper::BrotliStateWrapper()\n+: state(BrotliEncoderCreateInstance(nullptr, nullptr, nullptr))\n {\n-public:\n-    BrotliStateWrapper()\n-    : state(BrotliEncoderCreateInstance(nullptr, nullptr, nullptr))\n-    {\n-    }\n-\n-    ~BrotliStateWrapper()\n-    {\n-        BrotliEncoderDestroyInstance(state);\n-    }\n-\n-    BrotliEncoderState * state;\n-};\n+}\n \n-BrotliWriteBuffer::BrotliWriteBuffer(std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n-    , brotli(std::make_unique<BrotliStateWrapper>())\n-    , in_available(0)\n-    , in_data(nullptr)\n-    , out_capacity(0)\n-    , out_data(nullptr)\n+BrotliWriteBuffer::BrotliStateWrapper::~BrotliStateWrapper()\n {\n-    BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_QUALITY, static_cast<uint32_t>(compression_level));\n-    // Set LZ77 window size. According to brotli sources default value is 24 (c/tools/brotli.c:81)\n-    BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_LGWIN, 24);\n+    BrotliEncoderDestroyInstance(state);\n }\n \n BrotliWriteBuffer::~BrotliWriteBuffer() = default;\n@@ -58,18 +39,20 @@ void BrotliWriteBuffer::nextImpl()\n     {\n         do\n         {\n+            const auto * in_data_ptr = in_data;\n             out->nextIfAtEnd();\n             out_data = reinterpret_cast<unsigned char *>(out->position());\n             out_capacity = out->buffer().end() - out->position();\n \n             int result = BrotliEncoderCompressStream(\n                     brotli->state,\n-                    in_available ? BROTLI_OPERATION_PROCESS : BROTLI_OPERATION_FINISH,\n+                    BROTLI_OPERATION_PROCESS,\n                     &in_available,\n                     &in_data,\n                     &out_capacity,\n                     &out_data,\n                     nullptr);\n+            total_in += in_data - in_data_ptr;\n \n             out->position() = out->buffer().end() - out_capacity;\n \n@@ -92,6 +75,10 @@ void BrotliWriteBuffer::finalizeBefore()\n {\n     next();\n \n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && total_in == 0)\n+        return;\n+\n     while (true)\n     {\n         out->nextIfAtEnd();\ndiff --git a/src/IO/BrotliWriteBuffer.h b/src/IO/BrotliWriteBuffer.h\nindex 8cbc78bd9e7a..d4cda7b270cc 100644\n--- a/src/IO/BrotliWriteBuffer.h\n+++ b/src/IO/BrotliWriteBuffer.h\n@@ -4,18 +4,38 @@\n #include <IO/BufferWithOwnMemory.h>\n #include <IO/WriteBufferDecorator.h>\n \n+#include \"config.h\"\n+\n+#if USE_BROTLI\n+#    include <brotli/encode.h>\n+\n namespace DB\n {\n \n+\n class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     BrotliWriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n+        WriteBufferT && out_,\n         int compression_level,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n+    , brotli(std::make_unique<BrotliStateWrapper>())\n+    , in_available(0)\n+    , in_data(nullptr)\n+    , out_capacity(0)\n+    , out_data(nullptr)\n+    , compress_empty(compress_empty_)\n+    {\n+        BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_QUALITY, static_cast<uint32_t>(compression_level));\n+        // Set LZ77 window size. According to brotli sources default value is 24 (c/tools/brotli.c:81)\n+        BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_LGWIN, 24);\n+    }\n \n     ~BrotliWriteBuffer() override;\n \n@@ -24,7 +44,15 @@ class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n \n     void finalizeBefore() override;\n \n-    class BrotliStateWrapper;\n+    class BrotliStateWrapper\n+    {\n+    public:\n+        BrotliStateWrapper();\n+        ~BrotliStateWrapper();\n+\n+        BrotliEncoderState * state;\n+    };\n+\n     std::unique_ptr<BrotliStateWrapper> brotli;\n \n \n@@ -33,6 +61,12 @@ class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n \n     size_t out_capacity;\n     uint8_t * out_data;\n+\n+protected:\n+    UInt64 total_in = 0;\n+    bool compress_empty = true;\n };\n \n }\n+\n+#endif\ndiff --git a/src/IO/BufferBase.h b/src/IO/BufferBase.h\nindex 7a59687fa564..4c0a467b155a 100644\n--- a/src/IO/BufferBase.h\n+++ b/src/IO/BufferBase.h\n@@ -2,6 +2,7 @@\n \n #include <Core/Defines.h>\n #include <algorithm>\n+#include <memory>\n \n \n namespace DB\ndiff --git a/src/IO/Bzip2WriteBuffer.cpp b/src/IO/Bzip2WriteBuffer.cpp\nindex b84cbdd1e415..3421b4c3985d 100644\n--- a/src/IO/Bzip2WriteBuffer.cpp\n+++ b/src/IO/Bzip2WriteBuffer.cpp\n@@ -15,34 +15,22 @@ namespace ErrorCodes\n }\n \n \n-class Bzip2WriteBuffer::Bzip2StateWrapper\n+Bzip2WriteBuffer::Bzip2StateWrapper::Bzip2StateWrapper(int compression_level)\n {\n-public:\n-    explicit Bzip2StateWrapper(int compression_level)\n-    {\n-        memset(&stream, 0, sizeof(stream));\n-\n-        int ret = BZ2_bzCompressInit(&stream, compression_level, 0, 0);\n+    memset(&stream, 0, sizeof(stream));\n \n-        if (ret != BZ_OK)\n-            throw Exception(\n-                ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,\n-                \"bzip2 stream encoder init failed: error code: {}\",\n-                ret);\n-    }\n+    int ret = BZ2_bzCompressInit(&stream, compression_level, 0, 0);\n \n-    ~Bzip2StateWrapper()\n-    {\n-        BZ2_bzCompressEnd(&stream);\n-    }\n-\n-    bz_stream stream;\n-};\n+    if (ret != BZ_OK)\n+        throw Exception(\n+            ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,\n+            \"bzip2 stream encoder init failed: error code: {}\",\n+            ret);\n+}\n \n-Bzip2WriteBuffer::Bzip2WriteBuffer(std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n-    , bz(std::make_unique<Bzip2StateWrapper>(compression_level))\n+Bzip2WriteBuffer::Bzip2StateWrapper::~Bzip2StateWrapper()\n {\n+    BZ2_bzCompressEnd(&stream);\n }\n \n Bzip2WriteBuffer::~Bzip2WriteBuffer() = default;\n@@ -77,6 +65,8 @@ void Bzip2WriteBuffer::nextImpl()\n \n         }\n         while (bz->stream.avail_in > 0);\n+\n+        total_in += offset();\n     }\n     catch (...)\n     {\n@@ -90,6 +80,10 @@ void Bzip2WriteBuffer::finalizeBefore()\n {\n     next();\n \n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && total_in == 0)\n+        return;\n+\n     out->nextIfAtEnd();\n     bz->stream.next_out = out->position();\n     bz->stream.avail_out = static_cast<unsigned>(out->buffer().end() - out->position());\ndiff --git a/src/IO/Bzip2WriteBuffer.h b/src/IO/Bzip2WriteBuffer.h\nindex d03719034878..63c67461c6ab 100644\n--- a/src/IO/Bzip2WriteBuffer.h\n+++ b/src/IO/Bzip2WriteBuffer.h\n@@ -4,18 +4,29 @@\n #include <IO/BufferWithOwnMemory.h>\n #include <IO/WriteBufferDecorator.h>\n \n+#include \"config.h\"\n+\n+#if USE_BZIP2\n+#    include <bzlib.h>\n+\n namespace DB\n {\n \n class Bzip2WriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     Bzip2WriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n+        WriteBufferT && out_,\n         int compression_level,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), bz(std::make_unique<Bzip2StateWrapper>(compression_level))\n+    , compress_empty(compress_empty_)\n+    {\n+    }\n \n     ~Bzip2WriteBuffer() override;\n \n@@ -24,8 +35,20 @@ class Bzip2WriteBuffer : public WriteBufferWithOwnMemoryDecorator\n \n     void finalizeBefore() override;\n \n-    class Bzip2StateWrapper;\n+    class Bzip2StateWrapper\n+    {\n+    public:\n+        explicit Bzip2StateWrapper(int compression_level);\n+        ~Bzip2StateWrapper();\n+\n+        bz_stream stream;\n+    };\n+\n     std::unique_ptr<Bzip2StateWrapper> bz;\n+    bool compress_empty = true;\n+    UInt64 total_in = 0;\n };\n \n }\n+\n+#endif\ndiff --git a/src/IO/CompressionMethod.cpp b/src/IO/CompressionMethod.cpp\nindex 13e1adbb7024..90453e169619 100644\n--- a/src/IO/CompressionMethod.cpp\n+++ b/src/IO/CompressionMethod.cpp\n@@ -169,37 +169,66 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n     return createCompressedWrapper(std::move(nested), method, buf_size, existing_memory, alignment, zstd_window_log_max);\n }\n \n-std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n-    std::unique_ptr<WriteBuffer> nested, CompressionMethod method, int level, size_t buf_size, char * existing_memory, size_t alignment)\n+\n+template<typename WriteBufferT>\n+std::unique_ptr<WriteBuffer> createWriteCompressedWrapper(\n+    WriteBufferT && nested, CompressionMethod method, int level, size_t buf_size, char * existing_memory, size_t alignment, bool compress_empty)\n {\n     if (method == DB::CompressionMethod::Gzip || method == CompressionMethod::Zlib)\n-        return std::make_unique<ZlibDeflatingWriteBuffer>(std::move(nested), method, level, buf_size, existing_memory, alignment);\n+        return std::make_unique<ZlibDeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), method, level, buf_size, existing_memory, alignment, compress_empty);\n \n #if USE_BROTLI\n     if (method == DB::CompressionMethod::Brotli)\n-        return std::make_unique<BrotliWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+        return std::make_unique<BrotliWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);\n #endif\n     if (method == CompressionMethod::Xz)\n-        return std::make_unique<LZMADeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+        return std::make_unique<LZMADeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);\n \n     if (method == CompressionMethod::Zstd)\n-        return std::make_unique<ZstdDeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+        return std::make_unique<ZstdDeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);\n \n     if (method == CompressionMethod::Lz4)\n-        return std::make_unique<Lz4DeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+        return std::make_unique<Lz4DeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);\n \n #if USE_BZIP2\n     if (method == CompressionMethod::Bzip2)\n-        return std::make_unique<Bzip2WriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+        return std::make_unique<Bzip2WriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);\n #endif\n #if USE_SNAPPY\n     if (method == CompressionMethod::Snappy)\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Unsupported compression method\");\n #endif\n+\n+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Unsupported compression method\");\n+}\n+\n+\n+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n+    std::unique_ptr<WriteBuffer> nested,\n+    CompressionMethod method,\n+    int level,\n+    size_t buf_size,\n+    char * existing_memory,\n+    size_t alignment,\n+    bool compress_empty)\n+{\n     if (method == CompressionMethod::None)\n         return nested;\n+    return createWriteCompressedWrapper(nested, method, level, buf_size, existing_memory, alignment, compress_empty);\n+}\n \n-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Unsupported compression method\");\n+\n+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n+    WriteBuffer * nested,\n+    CompressionMethod method,\n+    int level,\n+    size_t buf_size,\n+    char * existing_memory,\n+    size_t alignment,\n+    bool compress_empty)\n+{\n+    assert(method != CompressionMethod::None);\n+    return createWriteCompressedWrapper(nested, method, level, buf_size, existing_memory, alignment, compress_empty);\n }\n \n }\ndiff --git a/src/IO/CompressionMethod.h b/src/IO/CompressionMethod.h\nindex c142531cd05f..d218e4c5882d 100644\n--- a/src/IO/CompressionMethod.h\n+++ b/src/IO/CompressionMethod.h\n@@ -61,13 +61,22 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n     char * existing_memory = nullptr,\n     size_t alignment = 0);\n \n-\n std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n     std::unique_ptr<WriteBuffer> nested,\n     CompressionMethod method,\n     int level,\n     size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n     char * existing_memory = nullptr,\n-    size_t alignment = 0);\n+    size_t alignment = 0,\n+    bool compress_empty = true);\n+\n+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n+    WriteBuffer * nested,\n+    CompressionMethod method,\n+    int level,\n+    size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n+    char * existing_memory = nullptr,\n+    size_t alignment = 0,\n+    bool compress_empty = true);\n \n }\ndiff --git a/src/IO/LZMADeflatingWriteBuffer.cpp b/src/IO/LZMADeflatingWriteBuffer.cpp\nindex a77b2bb7b397..db8f8c95fe60 100644\n--- a/src/IO/LZMADeflatingWriteBuffer.cpp\n+++ b/src/IO/LZMADeflatingWriteBuffer.cpp\n@@ -7,9 +7,7 @@ namespace ErrorCodes\n     extern const int LZMA_STREAM_ENCODER_FAILED;\n }\n \n-LZMADeflatingWriteBuffer::LZMADeflatingWriteBuffer(\n-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n+void LZMADeflatingWriteBuffer::initialize(int compression_level)\n {\n \n     lstr = LZMA_STREAM_INIT;\n@@ -94,6 +92,10 @@ void LZMADeflatingWriteBuffer::finalizeBefore()\n {\n     next();\n \n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && lstr.total_out == 0)\n+        return;\n+\n     do\n     {\n         out->nextIfAtEnd();\ndiff --git a/src/IO/LZMADeflatingWriteBuffer.h b/src/IO/LZMADeflatingWriteBuffer.h\nindex 2e135455e006..797b85cd400a 100644\n--- a/src/IO/LZMADeflatingWriteBuffer.h\n+++ b/src/IO/LZMADeflatingWriteBuffer.h\n@@ -14,22 +14,32 @@ namespace DB\n class LZMADeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     LZMADeflatingWriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n+        WriteBufferT && out_,\n         int compression_level,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)\n+    {\n+        initialize(compression_level);\n+    }\n \n     ~LZMADeflatingWriteBuffer() override;\n \n private:\n+    void initialize(int compression_level);\n+\n     void nextImpl() override;\n \n     void finalizeBefore() override;\n     void finalizeAfter() override;\n \n     lzma_stream lstr;\n+\n+    bool compress_empty = true;\n };\n \n }\ndiff --git a/src/IO/Lz4DeflatingWriteBuffer.cpp b/src/IO/Lz4DeflatingWriteBuffer.cpp\nindex 8241bfd4f3cb..a8cac823b50a 100644\n--- a/src/IO/Lz4DeflatingWriteBuffer.cpp\n+++ b/src/IO/Lz4DeflatingWriteBuffer.cpp\n@@ -63,11 +63,8 @@ namespace ErrorCodes\n     extern const int LZ4_ENCODER_FAILED;\n }\n \n-Lz4DeflatingWriteBuffer::Lz4DeflatingWriteBuffer(\n-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n-    , tmp_memory(buf_size)\n \n+void Lz4DeflatingWriteBuffer::initialize(int compression_level)\n {\n     kPrefs = {\n         {LZ4F_max256KB,\n@@ -105,7 +102,7 @@ void Lz4DeflatingWriteBuffer::nextImpl()\n \n     if (first_time)\n     {\n-        auto sink = SinkToOut(out.get(), tmp_memory, LZ4F_HEADER_SIZE_MAX);\n+        auto sink = SinkToOut(out, tmp_memory, LZ4F_HEADER_SIZE_MAX);\n         chassert(sink.getCapacity() >= LZ4F_HEADER_SIZE_MAX);\n \n         /// write frame header and check for errors\n@@ -131,7 +128,7 @@ void Lz4DeflatingWriteBuffer::nextImpl()\n         /// Ensure that there is enough space for compressed block of minimal size\n         size_t min_compressed_block_size = LZ4F_compressBound(1, &kPrefs);\n \n-        auto sink = SinkToOut(out.get(), tmp_memory, min_compressed_block_size);\n+        auto sink = SinkToOut(out, tmp_memory, min_compressed_block_size);\n         chassert(sink.getCapacity() >= min_compressed_block_size);\n \n         /// LZ4F_compressUpdate compresses whole input buffer at once so we need to shink it manually\n@@ -163,8 +160,12 @@ void Lz4DeflatingWriteBuffer::finalizeBefore()\n {\n     next();\n \n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && first_time)\n+        return;\n+\n     auto suffix_size = LZ4F_compressBound(0, &kPrefs);\n-    auto sink = SinkToOut(out.get(), tmp_memory, suffix_size);\n+    auto sink = SinkToOut(out, tmp_memory, suffix_size);\n     chassert(sink.getCapacity() >= suffix_size);\n \n     /// compression end\ndiff --git a/src/IO/Lz4DeflatingWriteBuffer.h b/src/IO/Lz4DeflatingWriteBuffer.h\nindex 7bb8a5e6c0ec..b37d61fa7326 100644\n--- a/src/IO/Lz4DeflatingWriteBuffer.h\n+++ b/src/IO/Lz4DeflatingWriteBuffer.h\n@@ -14,16 +14,26 @@ namespace DB\n class Lz4DeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     Lz4DeflatingWriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n+        WriteBufferT && out_,\n         int compression_level,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n+    , tmp_memory(buf_size)\n+    , compress_empty(compress_empty_)\n+    {\n+        initialize(compression_level);\n+    }\n \n     ~Lz4DeflatingWriteBuffer() override;\n \n private:\n+    void initialize(int compression_level);\n+\n     void nextImpl() override;\n \n     void finalizeBefore() override;\n@@ -35,5 +45,6 @@ class Lz4DeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n     Memory<> tmp_memory;\n \n     bool first_time = true;\n+    bool compress_empty = true;\n };\n }\ndiff --git a/src/IO/ReadBufferFromPocoSocket.cpp b/src/IO/ReadBufferFromPocoSocket.cpp\nindex ff72dc5386c1..d399721d0603 100644\n--- a/src/IO/ReadBufferFromPocoSocket.cpp\n+++ b/src/IO/ReadBufferFromPocoSocket.cpp\n@@ -99,6 +99,9 @@ bool ReadBufferFromPocoSocket::nextImpl()\n     if (bytes_read < 0)\n         throw NetException(ErrorCodes::CANNOT_READ_FROM_SOCKET, \"Cannot read from socket ({})\", peer_address.toString());\n \n+    if (read_event != ProfileEvents::end())\n+        ProfileEvents::increment(read_event, bytes_read);\n+\n     if (bytes_read)\n         working_buffer.resize(bytes_read);\n     else\n@@ -111,10 +114,17 @@ ReadBufferFromPocoSocket::ReadBufferFromPocoSocket(Poco::Net::Socket & socket_,\n     : BufferWithOwnMemory<ReadBuffer>(buf_size)\n     , socket(socket_)\n     , peer_address(socket.peerAddress())\n+    , read_event(ProfileEvents::end())\n     , socket_description(\"socket (\" + peer_address.toString() + \")\")\n {\n }\n \n+ReadBufferFromPocoSocket::ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & read_event_, size_t buf_size)\n+    : ReadBufferFromPocoSocket(socket_, buf_size)\n+{\n+    read_event = read_event_;\n+}\n+\n bool ReadBufferFromPocoSocket::poll(size_t timeout_microseconds) const\n {\n     if (available())\ndiff --git a/src/IO/ReadBufferFromPocoSocket.h b/src/IO/ReadBufferFromPocoSocket.h\nindex dab4ac86295c..76156612764b 100644\n--- a/src/IO/ReadBufferFromPocoSocket.h\n+++ b/src/IO/ReadBufferFromPocoSocket.h\n@@ -20,10 +20,13 @@ class ReadBufferFromPocoSocket : public BufferWithOwnMemory<ReadBuffer>\n       */\n     Poco::Net::SocketAddress peer_address;\n \n+    ProfileEvents::Event read_event;\n+\n     bool nextImpl() override;\n \n public:\n     explicit ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);\n+    explicit ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & read_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);\n \n     bool poll(size_t timeout_microseconds) const;\n \ndiff --git a/src/IO/WriteBufferDecorator.h b/src/IO/WriteBufferDecorator.h\nindex 7c984eeea8db..ee47834b7aff 100644\n--- a/src/IO/WriteBufferDecorator.h\n+++ b/src/IO/WriteBufferDecorator.h\n@@ -12,13 +12,21 @@ class WriteBuffer;\n \n /// WriteBuffer that decorates data and delegates it to underlying buffer.\n /// It's used for writing compressed and encrypted data\n+/// This class can own or not own underlying buffer - constructor will differentiate\n+/// std::unique_ptr<WriteBuffer> for owning and WriteBuffer* for not owning.\n template <class Base>\n class WriteBufferDecorator : public Base\n {\n public:\n     template <class ... BaseArgs>\n     explicit WriteBufferDecorator(std::unique_ptr<WriteBuffer> out_, BaseArgs && ... args)\n-        : Base(std::forward<BaseArgs>(args)...), out(std::move(out_))\n+        : Base(std::forward<BaseArgs>(args)...), owning_holder(std::move(out_)), out(owning_holder.get())\n+    {\n+    }\n+\n+    template <class ... BaseArgs>\n+    explicit WriteBufferDecorator(WriteBuffer * out_, BaseArgs && ... args)\n+        : Base(std::forward<BaseArgs>(args)...), out(out_)\n     {\n     }\n \n@@ -38,7 +46,7 @@ class WriteBufferDecorator : public Base\n         }\n     }\n \n-    WriteBuffer * getNestedBuffer() { return out.get(); }\n+    WriteBuffer * getNestedBuffer() { return out; }\n \n protected:\n     /// Do some finalization before finalization of underlying buffer.\n@@ -47,7 +55,8 @@ class WriteBufferDecorator : public Base\n     /// Do some finalization after finalization of underlying buffer.\n     virtual void finalizeAfter() {}\n \n-    std::unique_ptr<WriteBuffer> out;\n+    std::unique_ptr<WriteBuffer> owning_holder;\n+    WriteBuffer * out;\n };\n \n using WriteBufferWithOwnMemoryDecorator = WriteBufferDecorator<BufferWithOwnMemory<WriteBuffer>>;\ndiff --git a/src/IO/WriteBufferFromEncryptedFile.h b/src/IO/WriteBufferFromEncryptedFile.h\nindex 25dd54ca9d52..f8f864d00a6e 100644\n--- a/src/IO/WriteBufferFromEncryptedFile.h\n+++ b/src/IO/WriteBufferFromEncryptedFile.h\n@@ -28,7 +28,7 @@ class WriteBufferFromEncryptedFile : public WriteBufferDecorator<WriteBufferFrom\n \n     void sync() override;\n \n-    std::string getFileName() const override { return assert_cast<WriteBufferFromFileBase *>(out.get())->getFileName(); }\n+    std::string getFileName() const override { return assert_cast<WriteBufferFromFileBase *>(out)->getFileName(); }\n \n private:\n     void nextImpl() override;\ndiff --git a/src/IO/WriteBufferFromPocoSocket.cpp b/src/IO/WriteBufferFromPocoSocket.cpp\nindex 171e7f1ce691..10d9fd131cdc 100644\n--- a/src/IO/WriteBufferFromPocoSocket.cpp\n+++ b/src/IO/WriteBufferFromPocoSocket.cpp\n@@ -34,6 +34,97 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+ssize_t WriteBufferFromPocoSocket::socketSendBytesImpl(const char * ptr, size_t size)\n+{\n+    ssize_t res = 0;\n+\n+    /// If async_callback is specified, set socket to non-blocking mode\n+    /// and try to write data to it, if socket is not ready for writing,\n+    /// run async_callback and try again later.\n+    /// It is expected that file descriptor may be polled externally.\n+    /// Note that send timeout is not checked here. External code should check it while polling.\n+    if (async_callback)\n+    {\n+        socket.setBlocking(false);\n+        /// Set socket to blocking mode at the end.\n+        SCOPE_EXIT(socket.setBlocking(true));\n+        bool secure = socket.secure();\n+        res = socket.impl()->sendBytes(ptr, static_cast<int>(size));\n+\n+        /// Check EAGAIN and ERR_SSL_WANT_WRITE/ERR_SSL_WANT_READ for secure socket (writing to secure socket can read too).\n+        while (res < 0 && (errno == EAGAIN || (secure && (checkSSLWantRead(res) || checkSSLWantWrite(res)))))\n+        {\n+            /// In case of ERR_SSL_WANT_READ we should wait for socket to be ready for reading, otherwise - for writing.\n+            if (secure && checkSSLWantRead(res))\n+                async_callback(socket.impl()->sockfd(), socket.getReceiveTimeout(), AsyncEventTimeoutType::RECEIVE, socket_description, AsyncTaskExecutor::Event::READ | AsyncTaskExecutor::Event::ERROR);\n+            else\n+                async_callback(socket.impl()->sockfd(), socket.getSendTimeout(), AsyncEventTimeoutType::SEND, socket_description, AsyncTaskExecutor::Event::WRITE | AsyncTaskExecutor::Event::ERROR);\n+\n+            /// Try to write again.\n+            res = socket.impl()->sendBytes(ptr, static_cast<int>(size));\n+        }\n+    }\n+    else\n+    {\n+        res = socket.impl()->sendBytes(ptr, static_cast<int>(size));\n+    }\n+\n+    return res;\n+}\n+\n+void WriteBufferFromPocoSocket::socketSendBytes(const char * ptr, size_t size)\n+{\n+    if (!size)\n+        return;\n+\n+    Stopwatch watch;\n+    size_t bytes_written = 0;\n+\n+    SCOPE_EXIT({\n+        ProfileEvents::increment(ProfileEvents::NetworkSendElapsedMicroseconds, watch.elapsedMicroseconds());\n+        ProfileEvents::increment(ProfileEvents::NetworkSendBytes, bytes_written);\n+        if (write_event != ProfileEvents::end())\n+            ProfileEvents::increment(write_event, bytes_written);\n+    });\n+\n+    while (bytes_written < size)\n+    {\n+        ssize_t res = 0;\n+\n+        /// Add more details to exceptions.\n+        try\n+        {\n+            CurrentMetrics::Increment metric_increment(CurrentMetrics::NetworkSend);\n+            if (size > INT_MAX)\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Buffer overflow\");\n+\n+            res = socketSendBytesImpl(ptr + bytes_written, size - bytes_written);\n+        }\n+        catch (const Poco::Net::NetException & e)\n+        {\n+            throw NetException(ErrorCodes::NETWORK_ERROR, \"{}, while writing to socket ({} -> {})\", e.displayText(),\n+                               our_address.toString(), peer_address.toString());\n+        }\n+        catch (const Poco::TimeoutException &)\n+        {\n+            throw NetException(ErrorCodes::SOCKET_TIMEOUT, \"Timeout exceeded while writing to socket ({}, {} ms)\",\n+                peer_address.toString(),\n+                socket.impl()->getSendTimeout().totalMilliseconds());\n+        }\n+        catch (const Poco::IOException & e)\n+        {\n+            throw NetException(ErrorCodes::NETWORK_ERROR, \"{}, while writing to socket ({} -> {})\", e.displayText(),\n+                               our_address.toString(), peer_address.toString());\n+        }\n+\n+        if (res < 0)\n+            throw NetException(ErrorCodes::CANNOT_WRITE_TO_SOCKET, \"Cannot write to socket ({} -> {})\",\n+                               our_address.toString(), peer_address.toString());\n+\n+        bytes_written += res;\n+    }\n+}\n+\n void WriteBufferFromPocoSocket::nextImpl()\n {\n     if (!offset())\n@@ -60,36 +151,7 @@ void WriteBufferFromPocoSocket::nextImpl()\n             if (size > INT_MAX)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Buffer overflow\");\n \n-            /// If async_callback is specified, set socket to non-blocking mode\n-            /// and try to write data to it, if socket is not ready for writing,\n-            /// run async_callback and try again later.\n-            /// It is expected that file descriptor may be polled externally.\n-            /// Note that send timeout is not checked here. External code should check it while polling.\n-            if (async_callback)\n-            {\n-                socket.setBlocking(false);\n-                /// Set socket to blocking mode at the end.\n-                SCOPE_EXIT(socket.setBlocking(true));\n-                bool secure = socket.secure();\n-                res = socket.impl()->sendBytes(pos, static_cast<int>(size));\n-\n-                /// Check EAGAIN and ERR_SSL_WANT_WRITE/ERR_SSL_WANT_READ for secure socket (writing to secure socket can read too).\n-                while (res < 0 && (errno == EAGAIN || (secure && (checkSSLWantRead(res) || checkSSLWantWrite(res)))))\n-                {\n-                    /// In case of ERR_SSL_WANT_READ we should wait for socket to be ready for reading, otherwise - for writing.\n-                    if (secure && checkSSLWantRead(res))\n-                        async_callback(socket.impl()->sockfd(), socket.getReceiveTimeout(), AsyncEventTimeoutType::RECEIVE, socket_description, AsyncTaskExecutor::Event::READ | AsyncTaskExecutor::Event::ERROR);\n-                    else\n-                        async_callback(socket.impl()->sockfd(), socket.getSendTimeout(), AsyncEventTimeoutType::SEND, socket_description, AsyncTaskExecutor::Event::WRITE | AsyncTaskExecutor::Event::ERROR);\n-\n-                    /// Try to write again.\n-                    res = socket.impl()->sendBytes(pos, static_cast<int>(size));\n-                }\n-            }\n-            else\n-            {\n-                res = socket.impl()->sendBytes(pos, static_cast<int>(size));\n-            }\n+            res = socketSendBytesImpl(pos, size);\n         }\n         catch (const Poco::Net::NetException & e)\n         {\n@@ -125,6 +187,12 @@ WriteBufferFromPocoSocket::WriteBufferFromPocoSocket(Poco::Net::Socket & socket_\n {\n }\n \n+WriteBufferFromPocoSocket::WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size)\n+    : WriteBufferFromPocoSocket(socket_, buf_size)\n+{\n+    write_event = write_event_;\n+}\n+\n WriteBufferFromPocoSocket::~WriteBufferFromPocoSocket()\n {\n     try\ndiff --git a/src/IO/WriteBufferFromPocoSocket.h b/src/IO/WriteBufferFromPocoSocket.h\nindex ecb610203573..9c5509aebd18 100644\n--- a/src/IO/WriteBufferFromPocoSocket.h\n+++ b/src/IO/WriteBufferFromPocoSocket.h\n@@ -17,14 +17,33 @@ class WriteBufferFromPocoSocket : public BufferWithOwnMemory<WriteBuffer>\n {\n public:\n     explicit WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);\n+    explicit WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);\n \n     ~WriteBufferFromPocoSocket() override;\n \n     void setAsyncCallback(AsyncCallback async_callback_) { async_callback = std::move(async_callback_); }\n \n+    using WriteBuffer::write;\n+    void write(const std::string & str) { WriteBuffer::write(str.c_str(), str.size()); }\n+    void write(std::string_view str) { WriteBuffer::write(str.data(), str.size()); }\n+    void write(const char * str) { WriteBuffer::write(str, strlen(str)); }\n+    void writeln(const std::string & str) { write(str); WriteBuffer::write(\"\\n\", 1); }\n+    void writeln(std::string_view str) { write(str); WriteBuffer::write(\"\\n\", 1); }\n+    void writeln(const char * str) { write(str); WriteBuffer::write(\"\\n\", 1); }\n+\n protected:\n     void nextImpl() override;\n \n+    void socketSendBytes(const char * ptr, size_t size);\n+    void socketSendStr(const std::string & str)\n+    {\n+        return socketSendBytes(str.data(), str.size());\n+    }\n+    void socketSendStr(const char * ptr)\n+    {\n+        return socketSendBytes(ptr, strlen(ptr));\n+    }\n+\n     Poco::Net::Socket & socket;\n \n     /** For error messages. It is necessary to receive this address in advance, because,\n@@ -34,9 +53,13 @@ class WriteBufferFromPocoSocket : public BufferWithOwnMemory<WriteBuffer>\n     Poco::Net::SocketAddress peer_address;\n     Poco::Net::SocketAddress our_address;\n \n+    ProfileEvents::Event write_event;\n+\n private:\n     AsyncCallback async_callback;\n     std::string socket_description;\n+\n+    ssize_t socketSendBytesImpl(const char * ptr, size_t size);\n };\n \n }\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 094352638e6e..b4f8b476b110 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -63,9 +63,7 @@ namespace ErrorCodes\n \n inline void writeChar(char x, WriteBuffer & buf)\n {\n-    buf.nextIfAtEnd();\n-    *buf.position() = x;\n-    ++buf.position();\n+    buf.write(x);\n }\n \n /// Write the same character n times.\ndiff --git a/src/IO/ZlibDeflatingWriteBuffer.cpp b/src/IO/ZlibDeflatingWriteBuffer.cpp\nindex 6e4ab7424137..ab6763fe6a65 100644\n--- a/src/IO/ZlibDeflatingWriteBuffer.cpp\n+++ b/src/IO/ZlibDeflatingWriteBuffer.cpp\n@@ -10,36 +10,6 @@ namespace ErrorCodes\n     extern const int ZLIB_DEFLATE_FAILED;\n }\n \n-\n-ZlibDeflatingWriteBuffer::ZlibDeflatingWriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n-        CompressionMethod compression_method,\n-        int compression_level,\n-        size_t buf_size,\n-        char * existing_memory,\n-        size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n-{\n-    zstr.zalloc = nullptr;\n-    zstr.zfree = nullptr;\n-    zstr.opaque = nullptr;\n-    zstr.next_in = nullptr;\n-    zstr.avail_in = 0;\n-    zstr.next_out = nullptr;\n-    zstr.avail_out = 0;\n-\n-    int window_bits = 15;\n-    if (compression_method == CompressionMethod::Gzip)\n-    {\n-        window_bits += 16;\n-    }\n-\n-    int rc = deflateInit2(&zstr, compression_level, Z_DEFLATED, window_bits, 8, Z_DEFAULT_STRATEGY);\n-\n-    if (rc != Z_OK)\n-        throw Exception(ErrorCodes::ZLIB_DEFLATE_FAILED, \"deflateInit2 failed: {}; zlib version: {}\", zError(rc), ZLIB_VERSION);\n-}\n-\n void ZlibDeflatingWriteBuffer::nextImpl()\n {\n     if (!offset())\n@@ -82,6 +52,10 @@ void ZlibDeflatingWriteBuffer::finalizeBefore()\n {\n     next();\n \n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && zstr.total_out == 0)\n+        return;\n+\n     /// https://github.com/zlib-ng/zlib-ng/issues/494\n     do\n     {\ndiff --git a/src/IO/ZlibDeflatingWriteBuffer.h b/src/IO/ZlibDeflatingWriteBuffer.h\nindex 58e709b54e64..f01c41c7d13c 100644\n--- a/src/IO/ZlibDeflatingWriteBuffer.h\n+++ b/src/IO/ZlibDeflatingWriteBuffer.h\n@@ -12,17 +12,45 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int ZLIB_DEFLATE_FAILED;\n+}\n+\n /// Performs compression using zlib library and writes compressed data to out_ WriteBuffer.\n class ZlibDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     ZlibDeflatingWriteBuffer(\n-            std::unique_ptr<WriteBuffer> out_,\n+            WriteBufferT && out_,\n             CompressionMethod compression_method,\n             int compression_level,\n             size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n             char * existing_memory = nullptr,\n-            size_t alignment = 0);\n+            size_t alignment = 0,\n+            bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)\n+    {\n+        zstr.zalloc = nullptr;\n+        zstr.zfree = nullptr;\n+        zstr.opaque = nullptr;\n+        zstr.next_in = nullptr;\n+        zstr.avail_in = 0;\n+        zstr.next_out = nullptr;\n+        zstr.avail_out = 0;\n+\n+        int window_bits = 15;\n+        if (compression_method == CompressionMethod::Gzip)\n+        {\n+            window_bits += 16;\n+        }\n+\n+        int rc = deflateInit2(&zstr, compression_level, Z_DEFLATED, window_bits, 8, Z_DEFAULT_STRATEGY);\n+\n+        if (rc != Z_OK)\n+            throw Exception(ErrorCodes::ZLIB_DEFLATE_FAILED, \"deflateInit2 failed: {}; zlib version: {}\", zError(rc), ZLIB_VERSION);\n+    }\n \n     ~ZlibDeflatingWriteBuffer() override;\n \n@@ -36,6 +64,7 @@ class ZlibDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n     virtual void finalizeAfter() override;\n \n     z_stream zstr;\n+    bool compress_empty = true;\n };\n \n }\ndiff --git a/src/IO/ZstdDeflatingWriteBuffer.cpp b/src/IO/ZstdDeflatingWriteBuffer.cpp\nindex 949d65926b37..bad6e733cf1c 100644\n--- a/src/IO/ZstdDeflatingWriteBuffer.cpp\n+++ b/src/IO/ZstdDeflatingWriteBuffer.cpp\n@@ -8,9 +8,7 @@ namespace ErrorCodes\n     extern const int ZSTD_ENCODER_FAILED;\n }\n \n-ZstdDeflatingWriteBuffer::ZstdDeflatingWriteBuffer(\n-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)\n+void ZstdDeflatingWriteBuffer::initialize(int compression_level)\n {\n     cctx = ZSTD_createCCtx();\n     if (cctx == nullptr)\n@@ -44,6 +42,7 @@ void ZstdDeflatingWriteBuffer::flush(ZSTD_EndDirective mode)\n \n     try\n     {\n+        size_t out_offset = out->offset();\n         bool ended = false;\n         do\n         {\n@@ -67,6 +66,8 @@ void ZstdDeflatingWriteBuffer::flush(ZSTD_EndDirective mode)\n \n             ended = everything_was_compressed && everything_was_flushed;\n         } while (!ended);\n+\n+        total_out += out->offset() - out_offset;\n     }\n     catch (...)\n     {\n@@ -84,6 +85,9 @@ void ZstdDeflatingWriteBuffer::nextImpl()\n \n void ZstdDeflatingWriteBuffer::finalizeBefore()\n {\n+    /// Don't write out if no data was ever compressed\n+    if (!compress_empty && total_out == 0)\n+        return;\n     flush(ZSTD_e_end);\n }\n \ndiff --git a/src/IO/ZstdDeflatingWriteBuffer.h b/src/IO/ZstdDeflatingWriteBuffer.h\nindex a66d6085a747..d25db515d28f 100644\n--- a/src/IO/ZstdDeflatingWriteBuffer.h\n+++ b/src/IO/ZstdDeflatingWriteBuffer.h\n@@ -14,12 +14,18 @@ namespace DB\n class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n {\n public:\n+    template<typename WriteBufferT>\n     ZstdDeflatingWriteBuffer(\n-        std::unique_ptr<WriteBuffer> out_,\n+        WriteBufferT && out_,\n         int compression_level,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        bool compress_empty_ = true)\n+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)\n+    {\n+        initialize(compression_level);\n+    }\n \n     ~ZstdDeflatingWriteBuffer() override;\n \n@@ -29,6 +35,8 @@ class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n     }\n \n private:\n+    void initialize(int compression_level);\n+\n     void nextImpl() override;\n \n     /// Flush all pending data and write zstd footer to the underlying buffer.\n@@ -42,6 +50,9 @@ class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator\n     ZSTD_CCtx * cctx;\n     ZSTD_inBuffer input;\n     ZSTD_outBuffer output;\n+\n+    size_t total_out = 0;\n+    bool compress_empty = true;\n };\n \n }\ndiff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp\nindex 162772061b58..d2f9fe8b325e 100644\n--- a/src/Interpreters/Session.cpp\n+++ b/src/Interpreters/Session.cpp\n@@ -112,8 +112,7 @@ class NamedSessionsStorage\n                 throw Exception(ErrorCodes::SESSION_NOT_FOUND, \"Session {} not found\", session_id);\n \n             /// Create a new session from current context.\n-            auto context = Context::createCopy(global_context);\n-            it = sessions.insert(std::make_pair(key, std::make_shared<NamedSessionData>(key, context, timeout, *this))).first;\n+            it = sessions.insert(std::make_pair(key, std::make_shared<NamedSessionData>(key, global_context, timeout, *this))).first;\n             const auto & session = it->second;\n \n             if (!thread.joinable())\n@@ -128,7 +127,7 @@ class NamedSessionsStorage\n             /// Use existing session.\n             const auto & session = it->second;\n \n-            LOG_TEST(log, \"Reuse session from storage with session_id: {}, user_id: {}\", key.second, key.first);\n+            LOG_TRACE(log, \"Reuse session from storage with session_id: {}, user_id: {}\", key.second, key.first);\n \n             if (!session.unique())\n                 throw Exception(ErrorCodes::SESSION_IS_LOCKED, \"Session {} is locked by a concurrent client\", session_id);\n@@ -703,6 +702,10 @@ void Session::releaseSessionID()\n {\n     if (!named_session)\n         return;\n+\n+    prepared_client_info = getClientInfo();\n+    session_context.reset();\n+\n     named_session->release();\n     named_session = nullptr;\n }\ndiff --git a/src/Interpreters/Session.h b/src/Interpreters/Session.h\nindex 2249d8fbb2f9..75e1414b8cba 100644\n--- a/src/Interpreters/Session.h\n+++ b/src/Interpreters/Session.h\n@@ -8,6 +8,7 @@\n \n #include <chrono>\n #include <memory>\n+#include <mutex>\n #include <optional>\n \n namespace Poco::Net { class SocketAddress; }\ndiff --git a/src/Server/HTTP/HTTPRequestHandler.h b/src/Server/HTTP/HTTPRequestHandler.h\nindex 19340866bb7d..7902e86e3ed6 100644\n--- a/src/Server/HTTP/HTTPRequestHandler.h\n+++ b/src/Server/HTTP/HTTPRequestHandler.h\n@@ -13,7 +13,8 @@ class HTTPRequestHandler : private boost::noncopyable\n public:\n     virtual ~HTTPRequestHandler() = default;\n \n-    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) = 0;\n+    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) = 0;\n+    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) { handleRequest(request, response, ProfileEvents::end()); }\n };\n \n }\ndiff --git a/src/Server/HTTP/HTTPServer.cpp b/src/Server/HTTP/HTTPServer.cpp\nindex 46734933263d..90bdebf6451d 100644\n--- a/src/Server/HTTP/HTTPServer.cpp\n+++ b/src/Server/HTTP/HTTPServer.cpp\n@@ -10,8 +10,10 @@ HTTPServer::HTTPServer(\n     HTTPRequestHandlerFactoryPtr factory_,\n     Poco::ThreadPool & thread_pool,\n     Poco::Net::ServerSocket & socket_,\n-    Poco::Net::HTTPServerParams::Ptr params)\n-    : TCPServer(new HTTPServerConnectionFactory(context, params, factory_), thread_pool, socket_, params), factory(factory_)\n+    Poco::Net::HTTPServerParams::Ptr params,\n+    const ProfileEvents::Event & read_event,\n+    const ProfileEvents::Event & write_event)\n+    : TCPServer(new HTTPServerConnectionFactory(context, params, factory_, read_event, write_event), thread_pool, socket_, params), factory(factory_)\n {\n }\n \ndiff --git a/src/Server/HTTP/HTTPServer.h b/src/Server/HTTP/HTTPServer.h\nindex adfb21e7c621..9911cde1b930 100644\n--- a/src/Server/HTTP/HTTPServer.h\n+++ b/src/Server/HTTP/HTTPServer.h\n@@ -20,7 +20,9 @@ class HTTPServer : public TCPServer\n         HTTPRequestHandlerFactoryPtr factory,\n         Poco::ThreadPool & thread_pool,\n         Poco::Net::ServerSocket & socket,\n-        Poco::Net::HTTPServerParams::Ptr params);\n+        Poco::Net::HTTPServerParams::Ptr params,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     ~HTTPServer() override;\n \ndiff --git a/src/Server/HTTP/HTTPServerConnection.cpp b/src/Server/HTTP/HTTPServerConnection.cpp\nindex 042f5e2e5dfa..047db0145602 100644\n--- a/src/Server/HTTP/HTTPServerConnection.cpp\n+++ b/src/Server/HTTP/HTTPServerConnection.cpp\n@@ -11,8 +11,10 @@ HTTPServerConnection::HTTPServerConnection(\n     TCPServer & tcp_server_,\n     const Poco::Net::StreamSocket & socket,\n     Poco::Net::HTTPServerParams::Ptr params_,\n-    HTTPRequestHandlerFactoryPtr factory_)\n-    : TCPServerConnection(socket), context(std::move(context_)), tcp_server(tcp_server_), params(params_), factory(factory_), stopped(false)\n+    HTTPRequestHandlerFactoryPtr factory_,\n+    const ProfileEvents::Event & read_event_,\n+    const ProfileEvents::Event & write_event_)\n+    : TCPServerConnection(socket), context(std::move(context_)), tcp_server(tcp_server_), params(params_), factory(factory_), read_event(read_event_), write_event(write_event_), stopped(false)\n {\n     poco_check_ptr(factory);\n }\n@@ -30,7 +32,7 @@ void HTTPServerConnection::run()\n             if (!stopped && tcp_server.isOpen() && session.connected())\n             {\n                 HTTPServerResponse response(session);\n-                HTTPServerRequest request(context, response, session);\n+                HTTPServerRequest request(context, response, session, read_event);\n \n                 Poco::Timestamp now;\n \n@@ -65,7 +67,7 @@ void HTTPServerConnection::run()\n                         if (request.getExpectContinue() && response.getStatus() == Poco::Net::HTTPResponse::HTTP_OK)\n                             response.sendContinue();\n \n-                        handler->handleRequest(request, response);\n+                        handler->handleRequest(request, response, write_event);\n                         session.setKeepAlive(params->getKeepAlive() && response.getKeepAlive() && session.canKeepAlive());\n                     }\n                     else\ndiff --git a/src/Server/HTTP/HTTPServerConnection.h b/src/Server/HTTP/HTTPServerConnection.h\nindex 7087f8d5a216..c6b1dc1ba255 100644\n--- a/src/Server/HTTP/HTTPServerConnection.h\n+++ b/src/Server/HTTP/HTTPServerConnection.h\n@@ -19,7 +19,9 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection\n         TCPServer & tcp_server,\n         const Poco::Net::StreamSocket & socket,\n         Poco::Net::HTTPServerParams::Ptr params,\n-        HTTPRequestHandlerFactoryPtr factory);\n+        HTTPRequestHandlerFactoryPtr factory,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     HTTPServerConnection(\n         HTTPContextPtr context_,\n@@ -27,8 +29,10 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection\n         const Poco::Net::StreamSocket & socket_,\n         Poco::Net::HTTPServerParams::Ptr params_,\n         HTTPRequestHandlerFactoryPtr factory_,\n-        const String & forwarded_for_)\n-    : HTTPServerConnection(context_, tcp_server_, socket_, params_, factory_)\n+        const String & forwarded_for_,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end())\n+    : HTTPServerConnection(context_, tcp_server_, socket_, params_, factory_, read_event_, write_event_)\n     {\n         forwarded_for = forwarded_for_;\n     }\n@@ -44,6 +48,8 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection\n     Poco::Net::HTTPServerParams::Ptr params;\n     HTTPRequestHandlerFactoryPtr factory;\n     String forwarded_for;\n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n     bool stopped;\n     std::mutex mutex;  // guards the |factory| with assumption that creating handlers is not thread-safe.\n };\ndiff --git a/src/Server/HTTP/HTTPServerConnectionFactory.cpp b/src/Server/HTTP/HTTPServerConnectionFactory.cpp\nindex 2c9ac0cda2ab..16e5160fe3f0 100644\n--- a/src/Server/HTTP/HTTPServerConnectionFactory.cpp\n+++ b/src/Server/HTTP/HTTPServerConnectionFactory.cpp\n@@ -5,20 +5,20 @@\n namespace DB\n {\n HTTPServerConnectionFactory::HTTPServerConnectionFactory(\n-    HTTPContextPtr context_, Poco::Net::HTTPServerParams::Ptr params_, HTTPRequestHandlerFactoryPtr factory_)\n-    : context(std::move(context_)), params(params_), factory(factory_)\n+    HTTPContextPtr context_, Poco::Net::HTTPServerParams::Ptr params_, HTTPRequestHandlerFactoryPtr factory_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)\n+    : context(std::move(context_)), params(params_), factory(factory_), read_event(read_event_), write_event(write_event_)\n {\n     poco_check_ptr(factory);\n }\n \n Poco::Net::TCPServerConnection * HTTPServerConnectionFactory::createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server)\n {\n-    return new HTTPServerConnection(context, tcp_server, socket, params, factory);\n+    return new HTTPServerConnection(context, tcp_server, socket, params, factory, read_event, write_event);\n }\n \n Poco::Net::TCPServerConnection * HTTPServerConnectionFactory::createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData & stack_data)\n {\n-    return new HTTPServerConnection(context, tcp_server, socket, params, factory, stack_data.forwarded_for);\n+    return new HTTPServerConnection(context, tcp_server, socket, params, factory, stack_data.forwarded_for, read_event, write_event);\n }\n \n }\ndiff --git a/src/Server/HTTP/HTTPServerConnectionFactory.h b/src/Server/HTTP/HTTPServerConnectionFactory.h\nindex e18249da4ded..4b785e31744b 100644\n--- a/src/Server/HTTP/HTTPServerConnectionFactory.h\n+++ b/src/Server/HTTP/HTTPServerConnectionFactory.h\n@@ -12,7 +12,7 @@ namespace DB\n class HTTPServerConnectionFactory : public TCPServerConnectionFactory\n {\n public:\n-    HTTPServerConnectionFactory(HTTPContextPtr context, Poco::Net::HTTPServerParams::Ptr params, HTTPRequestHandlerFactoryPtr factory);\n+    HTTPServerConnectionFactory(HTTPContextPtr context, Poco::Net::HTTPServerParams::Ptr params, HTTPRequestHandlerFactoryPtr factory, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) override;\n     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData & stack_data) override;\n@@ -21,6 +21,8 @@ class HTTPServerConnectionFactory : public TCPServerConnectionFactory\n     HTTPContextPtr context;\n     Poco::Net::HTTPServerParams::Ptr params;\n     HTTPRequestHandlerFactoryPtr factory;\n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n };\n \n }\ndiff --git a/src/Server/HTTP/HTTPServerRequest.cpp b/src/Server/HTTP/HTTPServerRequest.cpp\nindex de5dde3c4aa6..4a6e85ba0fba 100644\n--- a/src/Server/HTTP/HTTPServerRequest.cpp\n+++ b/src/Server/HTTP/HTTPServerRequest.cpp\n@@ -22,7 +22,7 @@\n \n namespace DB\n {\n-HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session)\n+HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & read_event)\n     : max_uri_size(context->getMaxUriSize())\n     , max_fields_number(context->getMaxFields())\n     , max_field_name_size(context->getMaxFieldNameSize())\n@@ -41,7 +41,7 @@ HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse\n     session.socket().setReceiveTimeout(receive_timeout);\n     session.socket().setSendTimeout(send_timeout);\n \n-    auto in = std::make_unique<ReadBufferFromPocoSocket>(session.socket());\n+    auto in = std::make_unique<ReadBufferFromPocoSocket>(session.socket(), read_event);\n     socket = session.socket().impl();\n \n     readRequest(*in);  /// Try parse according to RFC7230\ndiff --git a/src/Server/HTTP/HTTPServerRequest.h b/src/Server/HTTP/HTTPServerRequest.h\nindex 1f38334c7453..aaec89ab7571 100644\n--- a/src/Server/HTTP/HTTPServerRequest.h\n+++ b/src/Server/HTTP/HTTPServerRequest.h\n@@ -4,6 +4,7 @@\n #include <IO/ReadBuffer.h>\n #include <Server/HTTP/HTTPRequest.h>\n #include <Server/HTTP/HTTPContext.h>\n+#include <Common/ProfileEvents.h>\n #include \"config.h\"\n \n #include <Poco/Net/HTTPServerSession.h>\n@@ -19,7 +20,7 @@ class ReadBufferFromPocoSocket;\n class HTTPServerRequest : public HTTPRequest\n {\n public:\n-    HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session);\n+    HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & read_event = ProfileEvents::end());\n \n     /// FIXME: it's a little bit inconvenient interface. The rationale is that all other ReadBuffer's wrap each other\n     ///        via unique_ptr - but we can't inherit HTTPServerRequest from ReadBuffer and pass it around,\ndiff --git a/src/Server/HTTP/HTTPServerResponse.cpp b/src/Server/HTTP/HTTPServerResponse.cpp\nindex 25e7604a515e..3c2d54a67dfc 100644\n--- a/src/Server/HTTP/HTTPServerResponse.cpp\n+++ b/src/Server/HTTP/HTTPServerResponse.cpp\n@@ -9,12 +9,15 @@\n #include <Poco/Net/HTTPHeaderStream.h>\n #include <Poco/Net/HTTPStream.h>\n #include <Poco/StreamCopier.h>\n+#include <sstream>\n \n \n namespace DB\n {\n \n-HTTPServerResponse::HTTPServerResponse(Poco::Net::HTTPServerSession & session_) : session(session_)\n+HTTPServerResponse::HTTPServerResponse(Poco::Net::HTTPServerSession & session_, const ProfileEvents::Event & write_event_)\n+    : session(session_)\n+    , write_event(write_event_)\n {\n }\n \n@@ -24,42 +27,45 @@ void HTTPServerResponse::sendContinue()\n     hs << getVersion() << \" 100 Continue\\r\\n\\r\\n\";\n }\n \n-std::shared_ptr<std::ostream> HTTPServerResponse::send()\n+std::shared_ptr<WriteBufferFromPocoSocket> HTTPServerResponse::send()\n {\n     poco_assert(!stream);\n \n     if ((request && request->getMethod() == HTTPRequest::HTTP_HEAD) || getStatus() < 200 || getStatus() == HTTPResponse::HTTP_NO_CONTENT\n         || getStatus() == HTTPResponse::HTTP_NOT_MODIFIED)\n     {\n-        Poco::CountingOutputStream cs;\n-        write(cs);\n-        stream = std::make_shared<Poco::Net::HTTPFixedLengthOutputStream>(session, cs.chars());\n-        write(*stream);\n+        // Send header\n+        Poco::Net::HTTPHeaderOutputStream hs(session);\n+        write(hs);\n+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);\n     }\n     else if (getChunkedTransferEncoding())\n     {\n+        // Send header\n         Poco::Net::HTTPHeaderOutputStream hs(session);\n         write(hs);\n-        stream = std::make_shared<Poco::Net::HTTPChunkedOutputStream>(session);\n+        stream = std::make_shared<HTTPWriteBufferChunked>(session.socket(), write_event);\n     }\n     else if (hasContentLength())\n     {\n-        Poco::CountingOutputStream cs;\n-        write(cs);\n-        stream = std::make_shared<Poco::Net::HTTPFixedLengthOutputStream>(session, getContentLength64() + cs.chars());\n-        write(*stream);\n+        // Send header\n+        Poco::Net::HTTPHeaderOutputStream hs(session);\n+        write(hs);\n+        stream = std::make_shared<HTTPWriteBufferFixedLength>(session.socket(), getContentLength(), write_event);\n     }\n     else\n     {\n-        stream = std::make_shared<Poco::Net::HTTPOutputStream>(session);\n         setKeepAlive(false);\n-        write(*stream);\n+        // Send header\n+        Poco::Net::HTTPHeaderOutputStream hs(session);\n+        write(hs);\n+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);\n     }\n \n     return stream;\n }\n \n-std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> HTTPServerResponse::beginSend()\n+std::pair<std::shared_ptr<WriteBufferFromPocoSocket>, std::shared_ptr<WriteBufferFromPocoSocket>> HTTPServerResponse::beginSend()\n {\n     poco_assert(!stream);\n     poco_assert(!header_stream);\n@@ -71,40 +77,39 @@ std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> HTTPServ\n     {\n         throw Poco::Exception(\"HTTPServerResponse::beginSend is invalid for HEAD request\");\n     }\n-    else if (getChunkedTransferEncoding())\n-    {\n-        header_stream = std::make_shared<Poco::Net::HTTPHeaderOutputStream>(session);\n-        beginWrite(*header_stream);\n-        stream = std::make_shared<Poco::Net::HTTPChunkedOutputStream>(session);\n-    }\n-    else if (hasContentLength())\n+\n+    if (hasContentLength())\n     {\n         throw Poco::Exception(\"HTTPServerResponse::beginSend is invalid for response with Content-Length header\");\n     }\n+\n+    // Write header to buffer\n+    std::stringstream header; //STYLE_CHECK_ALLOW_STD_STRING_STREAM\n+    beginWrite(header);\n+    // Send header\n+    auto str = header.str();\n+    header_stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event, str.size());\n+    header_stream->write(str);\n+\n+    if (getChunkedTransferEncoding())\n+        stream = std::make_shared<HTTPWriteBufferChunked>(session.socket(), write_event);\n     else\n-    {\n-        stream = std::make_shared<Poco::Net::HTTPOutputStream>(session);\n-        header_stream = stream;\n-        setKeepAlive(false);\n-        beginWrite(*stream);\n-    }\n+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);\n \n     return std::make_pair(header_stream, stream);\n }\n \n void HTTPServerResponse::sendBuffer(const void * buffer, std::size_t length)\n {\n-    poco_assert(!stream);\n-\n     setContentLength(static_cast<int>(length));\n     setChunkedTransferEncoding(false);\n+    // Send header\n+    Poco::Net::HTTPHeaderOutputStream hs(session);\n+    write(hs);\n+    hs.flush();\n \n-    stream = std::make_shared<Poco::Net::HTTPHeaderOutputStream>(session);\n-    write(*stream);\n     if (request && request->getMethod() != HTTPRequest::HTTP_HEAD)\n-    {\n-        stream->write(static_cast<const char *>(buffer), static_cast<std::streamsize>(length));\n-    }\n+        WriteBufferFromPocoSocket(session.socket(), write_event).write(static_cast<const char *>(buffer), length);\n }\n \n void HTTPServerResponse::requireAuthentication(const std::string & realm)\ndiff --git a/src/Server/HTTP/HTTPServerResponse.h b/src/Server/HTTP/HTTPServerResponse.h\nindex 236a56e2323f..6efe48667ebf 100644\n--- a/src/Server/HTTP/HTTPServerResponse.h\n+++ b/src/Server/HTTP/HTTPServerResponse.h\n@@ -1,9 +1,12 @@\n #pragma once\n \n+#include <IO/WriteBufferFromPocoSocket.h>\n #include <Server/HTTP/HTTPResponse.h>\n \n #include <Poco/Net/HTTPServerSession.h>\n #include <Poco/Net/HTTPResponse.h>\n+#include <Poco/Net/StreamSocket.h>\n+#include <Poco/NumberFormatter.h>\n \n #include <memory>\n \n@@ -11,12 +14,182 @@\n namespace DB\n {\n \n+\n+class HTTPWriteBufferChunked : public WriteBufferFromPocoSocket\n+{\n+    using WriteBufferFromPocoSocket::WriteBufferFromPocoSocket;\n+protected:\n+    void nextImpl() override\n+    {\n+        if (offset() == 0)\n+            return;\n+\n+        std::string chunk_header;\n+        Poco::NumberFormatter::appendHex(chunk_header, offset());\n+        chunk_header.append(\"\\r\\n\", 2);\n+        socketSendBytes(chunk_header.data(), static_cast<int>(chunk_header.size()));\n+        WriteBufferFromPocoSocket::nextImpl();\n+        socketSendBytes(\"\\r\\n\", 2);\n+    }\n+\n+    void finalizeImpl() override\n+    {\n+        WriteBufferFromPocoSocket::finalizeImpl();\n+        socketSendBytes(\"0\\r\\n\\r\\n\", 5);\n+    }\n+};\n+\n+class HTTPWriteBufferFixedLength : public WriteBufferFromPocoSocket\n+{\n+public:\n+    explicit HTTPWriteBufferFixedLength(Poco::Net::Socket & socket_, size_t fixed_length_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+        : WriteBufferFromPocoSocket(socket_, buf_size)\n+    {\n+        fixed_length = fixed_length_;\n+    }\n+    explicit HTTPWriteBufferFixedLength(Poco::Net::Socket & socket_, size_t fixed_length_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+        : WriteBufferFromPocoSocket(socket_, write_event_, buf_size)\n+    {\n+        fixed_length = fixed_length_;\n+    }\n+protected:\n+    void nextImpl() override\n+    {\n+        if (count_length >= fixed_length || offset() == 0)\n+            return;\n+\n+        if (count_length + offset() > fixed_length)\n+            pos -= offset() - (fixed_length - count_length);\n+\n+        count_length += offset();\n+\n+        WriteBufferFromPocoSocket::nextImpl();\n+    }\n+private:\n+    size_t fixed_length;\n+    size_t count_length = 0;\n+};\n+\n+/// Universal HTTP buffer, can be switched for different Transfer-Encoding/Content-Length on the fly\n+/// so it can be used to output HTTP header and then switched to appropriate mode for body\n+class HTTPWriteBuffer : public WriteBufferFromPocoSocket\n+{\n+public:\n+    explicit HTTPWriteBuffer(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+        : WriteBufferFromPocoSocket(socket_, buf_size)\n+    {\n+    }\n+    explicit HTTPWriteBuffer(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+        : WriteBufferFromPocoSocket(socket_, write_event_, buf_size)\n+    {\n+    }\n+\n+    void setChunked(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+    {\n+        chunked = true;\n+        resizeIfNeeded(buf_size);\n+    }\n+\n+    bool isChunked()\n+    {\n+        return chunked;\n+    }\n+\n+    void setFixedLength(size_t length)\n+    {\n+        chunked = false;\n+        fixed_length = length;\n+        count_length = 0;\n+        resizeIfNeeded(length);\n+    }\n+\n+    size_t isFixedLength()\n+    {\n+        return chunked ? 0 : fixed_length;\n+    }\n+\n+    void setPlain(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+    {\n+        chunked = false;\n+        fixed_length = 0;\n+        count_length = 0;\n+        resizeIfNeeded(buf_size);\n+    }\n+\n+    bool isPlain()\n+    {\n+        return !(isChunked() || isFixedLength());\n+    }\n+\n+protected:\n+    void finalizeImpl() override\n+    {\n+        WriteBufferFromPocoSocket::finalizeImpl();\n+        if (chunked)\n+            socketSendBytes(\"0\\r\\n\\r\\n\", 5);\n+    }\n+\n+    void nextImpl() override\n+    {\n+        if (chunked)\n+            return nextImplChunked();\n+\n+        if (fixed_length)\n+            return nextImplFixedLength();\n+\n+        WriteBufferFromPocoSocket::nextImpl();\n+    }\n+\n+    void nextImplFixedLength()\n+    {\n+        if (count_length >= fixed_length || offset() == 0)\n+            return;\n+\n+        if (count_length + offset() > fixed_length)\n+            pos -= offset() - (fixed_length - count_length);\n+\n+        count_length += offset();\n+\n+        WriteBufferFromPocoSocket::nextImpl();\n+    }\n+\n+    void nextImplChunked()\n+    {\n+        if (offset() == 0)\n+            return;\n+\n+        std::string chunk_header;\n+        Poco::NumberFormatter::appendHex(chunk_header, offset());\n+        chunk_header.append(\"\\r\\n\", 2);\n+        socketSendBytes(chunk_header.data(), static_cast<int>(chunk_header.size()));\n+        WriteBufferFromPocoSocket::nextImpl();\n+        socketSendBytes(\"\\r\\n\", 2);\n+    }\n+\n+    void resizeIfNeeded(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)\n+    {\n+        if (!buf_size)\n+            return;\n+\n+        auto data_size = offset();\n+        assert(data_size <= buf_size);\n+\n+        memory.resize(buf_size);\n+        set(memory.data(), memory.size(), data_size);\n+    }\n+private:\n+    bool chunked = false;\n+    size_t fixed_length = 0;\n+    size_t count_length = 0;\n+};\n+\n+\n class HTTPServerRequest;\n \n class HTTPServerResponse : public HTTPResponse\n {\n public:\n-    explicit HTTPServerResponse(Poco::Net::HTTPServerSession & session);\n+    explicit HTTPServerResponse(Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     void sendContinue(); /// Sends a 100 Continue response to the client.\n \n@@ -26,7 +199,7 @@ class HTTPServerResponse : public HTTPResponse\n     ///\n     /// Must not be called after beginSend(), sendFile(), sendBuffer()\n     /// or redirect() has been called.\n-    std::shared_ptr<std::ostream> send(); /// TODO: use some WriteBuffer implementation here.\n+    std::shared_ptr<WriteBufferFromPocoSocket> send();\n \n     /// Sends the response headers to the client\n     /// but do not finish headers with \\r\\n,\n@@ -34,7 +207,7 @@ class HTTPServerResponse : public HTTPResponse\n     ///\n     /// Must not be called after send(), sendFile(), sendBuffer()\n     /// or redirect() has been called.\n-    std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> beginSend(); /// TODO: use some WriteBuffer implementation here.\n+    std::pair<std::shared_ptr<WriteBufferFromPocoSocket>, std::shared_ptr<WriteBufferFromPocoSocket>> beginSend();\n \n     /// Sends the response header to the client, followed\n     /// by the contents of the given buffer.\n@@ -58,13 +231,16 @@ class HTTPServerResponse : public HTTPResponse\n     /// Returns true if the response (header) has been sent.\n     bool sent() const { return !!stream; }\n \n+    Poco::Net::StreamSocket & getSocket() { return session.socket(); }\n+\n     void attachRequest(HTTPServerRequest * request_) { request = request_; }\n \n private:\n     Poco::Net::HTTPServerSession & session;\n     HTTPServerRequest * request = nullptr;\n-    std::shared_ptr<std::ostream> stream;\n-    std::shared_ptr<std::ostream> header_stream;\n+    ProfileEvents::Event write_event;\n+    std::shared_ptr<WriteBufferFromPocoSocket> stream;\n+    std::shared_ptr<WriteBufferFromPocoSocket> header_stream;\n };\n \n }\ndiff --git a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp\nindex 1a12c09a8c7b..07b87c3ae969 100644\n--- a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp\n+++ b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp\n@@ -1,17 +1,15 @@\n #include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>\n-\n #include <IO/HTTPCommon.h>\n #include <IO/Progress.h>\n #include <IO/WriteBufferFromString.h>\n #include <IO/WriteHelpers.h>\n+#include <memory>\n+#include <sstream>\n+#include <string>\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-}\n-\n \n void WriteBufferFromHTTPServerResponse::startSendHeaders()\n {\n@@ -19,27 +17,33 @@ void WriteBufferFromHTTPServerResponse::startSendHeaders()\n     {\n         headers_started_sending = true;\n \n+        if (response.getChunkedTransferEncoding())\n+            setChunked();\n+\n         if (add_cors_header)\n             response.set(\"Access-Control-Allow-Origin\", \"*\");\n \n         setResponseDefaultHeaders(response, keep_alive_timeout);\n \n-        if (!is_http_method_head)\n-            std::tie(response_header_ostr, response_body_ostr) = response.beginSend();\n+        std::stringstream header; //STYLE_CHECK_ALLOW_STD_STRING_STREAM\n+        response.beginWrite(header);\n+        auto header_str = header.str();\n+        socketSendBytes(header_str.data(), header_str.size());\n     }\n }\n \n void WriteBufferFromHTTPServerResponse::writeHeaderProgressImpl(const char * header_name)\n {\n-    if (headers_finished_sending)\n+    if (is_http_method_head || headers_finished_sending || !headers_started_sending)\n         return;\n \n     WriteBufferFromOwnString progress_string_writer;\n \n     accumulated_progress.writeJSON(progress_string_writer);\n \n-    if (response_header_ostr)\n-        *response_header_ostr << header_name << progress_string_writer.str() << \"\\r\\n\" << std::flush;\n+    socketSendBytes(header_name, strlen(header_name));\n+    socketSendBytes(progress_string_writer.str().data(), progress_string_writer.str().size());\n+    socketSendBytes(\"\\r\\n\", 2);\n }\n \n void WriteBufferFromHTTPServerResponse::writeHeaderSummary()\n@@ -57,30 +61,30 @@ void WriteBufferFromHTTPServerResponse::writeExceptionCode()\n {\n     if (headers_finished_sending || !exception_code)\n         return;\n-    if (response_header_ostr)\n-        *response_header_ostr << \"X-ClickHouse-Exception-Code: \" << exception_code << \"\\r\\n\" << std::flush;\n+    if (headers_started_sending)\n+    {\n+        socketSendBytes(\"X-ClickHouse-Exception-Code: \", sizeof(\"X-ClickHouse-Exception-Code: \") - 1);\n+        auto str_code = std::to_string(exception_code);\n+        socketSendBytes(str_code.data(), str_code.size());\n+        socketSendBytes(\"\\r\\n\", 2);\n+    }\n }\n \n void WriteBufferFromHTTPServerResponse::finishSendHeaders()\n {\n-    if (!headers_finished_sending)\n-    {\n-        writeHeaderSummary();\n-        writeExceptionCode();\n-        headers_finished_sending = true;\n-\n-        if (!is_http_method_head)\n-        {\n-            /// Send end of headers delimiter.\n-            if (response_header_ostr)\n-                *response_header_ostr << \"\\r\\n\" << std::flush;\n-        }\n-        else\n-        {\n-            if (!response_body_ostr)\n-                response_body_ostr = response.send();\n-        }\n-    }\n+    if (headers_finished_sending)\n+        return;\n+\n+    if (!headers_started_sending)\n+        startSendHeaders();\n+\n+    writeHeaderSummary();\n+    writeExceptionCode();\n+\n+    headers_finished_sending = true;\n+\n+    /// Send end of headers delimiter.\n+    socketSendBytes(\"\\r\\n\", 2);\n }\n \n \n@@ -89,47 +93,19 @@ void WriteBufferFromHTTPServerResponse::nextImpl()\n     if (!initialized)\n     {\n         std::lock_guard lock(mutex);\n-\n         /// Initialize as early as possible since if the code throws,\n         /// next() should not be called anymore.\n         initialized = true;\n \n-        startSendHeaders();\n-\n-        if (!out && !is_http_method_head)\n-        {\n-            if (compress)\n-            {\n-                auto content_encoding_name = toContentEncodingName(compression_method);\n-\n-                *response_header_ostr << \"Content-Encoding: \" << content_encoding_name << \"\\r\\n\";\n-            }\n-\n-            /// We reuse our buffer in \"out\" to avoid extra allocations and copies.\n-\n-            if (compress)\n-                out = wrapWriteBufferWithCompressionMethod(\n-                    std::make_unique<WriteBufferFromOStream>(*response_body_ostr),\n-                    compress ? compression_method : CompressionMethod::None,\n-                    compression_level,\n-                    working_buffer.size(),\n-                    working_buffer.begin());\n-            else\n-                out = std::make_unique<WriteBufferFromOStream>(\n-                    *response_body_ostr,\n-                    working_buffer.size(),\n-                    working_buffer.begin());\n-        }\n+        if (compression_method != CompressionMethod::None)\n+            response.set(\"Content-Encoding\", toContentEncodingName(compression_method));\n \n+        startSendHeaders();\n         finishSendHeaders();\n     }\n \n-    if (out)\n-    {\n-        out->buffer() = buffer();\n-        out->position() = position();\n-        out->next();\n-    }\n+    if (!is_http_method_head)\n+        HTTPWriteBuffer::nextImpl();\n }\n \n \n@@ -137,14 +113,11 @@ WriteBufferFromHTTPServerResponse::WriteBufferFromHTTPServerResponse(\n     HTTPServerResponse & response_,\n     bool is_http_method_head_,\n     UInt64 keep_alive_timeout_,\n-    bool compress_,\n-    CompressionMethod compression_method_)\n-    : BufferWithOwnMemory<WriteBuffer>(DBMS_DEFAULT_BUFFER_SIZE)\n+    const ProfileEvents::Event & write_event_)\n+    : HTTPWriteBuffer(response_.getSocket(), write_event_)\n     , response(response_)\n     , is_http_method_head(is_http_method_head_)\n     , keep_alive_timeout(keep_alive_timeout_)\n-    , compress(compress_)\n-    , compression_method(compression_method_)\n {\n }\n \n@@ -169,6 +142,15 @@ void WriteBufferFromHTTPServerResponse::onProgress(const Progress & progress)\n     }\n }\n \n+void WriteBufferFromHTTPServerResponse::setExceptionCode(int exception_code_)\n+{\n+    std::lock_guard lock(mutex);\n+    if (headers_started_sending)\n+        exception_code = exception_code_;\n+    else\n+        response.set(\"X-ClickHouse-Exception-Code\", toString<int>(exception_code_));\n+}\n+\n WriteBufferFromHTTPServerResponse::~WriteBufferFromHTTPServerResponse()\n {\n     finalize();\n@@ -176,30 +158,20 @@ WriteBufferFromHTTPServerResponse::~WriteBufferFromHTTPServerResponse()\n \n void WriteBufferFromHTTPServerResponse::finalizeImpl()\n {\n-    try\n-    {\n-        next();\n-        if (out)\n-            out->finalize();\n-        out.reset();\n-        /// Catch write-after-finalize bugs.\n-        set(nullptr, 0);\n-    }\n-    catch (...)\n-    {\n-        /// Avoid calling WriteBufferFromOStream::next() from dtor\n-        /// (via WriteBufferFromHTTPServerResponse::next())\n-        out.reset();\n-        throw;\n-    }\n-\n-    if (!offset())\n+    if (!headers_finished_sending)\n     {\n-        /// If no remaining data, just send headers.\n         std::lock_guard lock(mutex);\n+        /// If no body data just send header\n         startSendHeaders();\n+\n+        if (!initialized && offset() && compression_method != CompressionMethod::None)\n+            socketSendStr(\"Content-Encoding: \" + toContentEncodingName(compression_method) + \"\\r\\n\");\n+\n         finishSendHeaders();\n     }\n+\n+    if (!is_http_method_head)\n+        HTTPWriteBuffer::finalizeImpl();\n }\n \n \ndiff --git a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h\nindex 38345f279526..a3952b7c5538 100644\n--- a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h\n+++ b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h\n@@ -5,8 +5,8 @@\n #include <IO/HTTPCommon.h>\n #include <IO/Progress.h>\n #include <IO/WriteBuffer.h>\n-#include <IO/WriteBufferFromOStream.h>\n #include <Server/HTTP/HTTPServerResponse.h>\n+#include <Poco/Net/StreamSocket.h>\n #include <Common/NetException.h>\n #include <Common/Stopwatch.h>\n \n@@ -17,48 +17,26 @@\n namespace DB\n {\n \n-/// The difference from WriteBufferFromOStream is that this buffer gets the underlying std::ostream\n-/// (using response.send()) only after data is flushed for the first time. This is needed in HTTP\n-/// servers to change some HTTP headers (e.g. response code) before any data is sent to the client\n-/// (headers can't be changed after response.send() is called).\n-///\n-/// In short, it allows delaying the call to response.send().\n-///\n-/// Additionally, supports HTTP response compression (in this case corresponding Content-Encoding\n-/// header will be set).\n+/// Postpone sending HTTP header until first data is flushed. This is needed in HTTP servers\n+///  to change some HTTP headers (e.g. response code) before any data is sent to the client.\n ///\n /// Also this class write and flush special X-ClickHouse-Progress HTTP headers\n ///  if no data was sent at the time of progress notification.\n /// This allows to implement progress bar in HTTP clients.\n-class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<WriteBuffer>\n+class WriteBufferFromHTTPServerResponse final : public HTTPWriteBuffer\n {\n public:\n     WriteBufferFromHTTPServerResponse(\n         HTTPServerResponse & response_,\n         bool is_http_method_head_,\n         UInt64 keep_alive_timeout_,\n-        bool compress_ = false,        /// If true - set Content-Encoding header and compress the result.\n-        CompressionMethod compression_method_ = CompressionMethod::None);\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     ~WriteBufferFromHTTPServerResponse() override;\n \n     /// Writes progress in repeating HTTP headers.\n     void onProgress(const Progress & progress);\n \n-    /// Turn compression on or off.\n-    /// The setting has any effect only if HTTP headers haven't been sent yet.\n-    void setCompression(bool enable_compression)\n-    {\n-        compress = enable_compression;\n-    }\n-\n-    /// Set compression level if the compression is turned on.\n-    /// The setting has any effect only if HTTP headers haven't been sent yet.\n-    void setCompressionLevel(int level)\n-    {\n-        compression_level = level;\n-    }\n-\n     /// Turn CORS on or off.\n     /// The setting has any effect only if HTTP headers haven't been sent yet.\n     void addHeaderCORS(bool enable_cors)\n@@ -75,7 +53,13 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write\n         send_progress_interval_ms = send_progress_interval_ms_;\n     }\n \n-    void setExceptionCode(int exception_code_) { exception_code = exception_code_; }\n+    /// Content-Encoding header will be set on first data package\n+    void setCompressionMethodHeader(const CompressionMethod & compression_method_)\n+    {\n+        compression_method = compression_method_;\n+    }\n+\n+    void setExceptionCode(int exception_code_);\n \n private:\n     /// Send at least HTTP headers if no data has been sent yet.\n@@ -108,14 +92,7 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write\n     bool is_http_method_head;\n     bool add_cors_header = false;\n     size_t keep_alive_timeout = 0;\n-    bool compress = false;\n-    CompressionMethod compression_method;\n-    int compression_level = 1;\n-\n-    std::shared_ptr<std::ostream> response_body_ostr;\n-    std::shared_ptr<std::ostream> response_header_ostr;\n \n-    std::unique_ptr<WriteBuffer> out;\n     bool initialized = false;\n \n     bool headers_started_sending = false;\n@@ -126,6 +103,8 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write\n     size_t send_progress_interval_ms = 100;\n     Stopwatch progress_watch;\n \n+    CompressionMethod compression_method = CompressionMethod::None;\n+\n     int exception_code = 0;\n \n     std::mutex mutex;    /// progress callback could be called from different threads.\ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex f53c0094ef76..224cc3030769 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -46,7 +46,9 @@\n #include <Poco/String.h>\n #include <Poco/Net/SocketAddress.h>\n \n+#include <algorithm>\n #include <chrono>\n+#include <memory>\n #include <sstream>\n \n #ifdef __clang__\n@@ -301,7 +303,7 @@ void HTTPHandler::pushDelayedResults(Output & used_output)\n     std::vector<WriteBufferPtr> write_buffers;\n     ConcatReadBuffer::Buffers read_buffers;\n \n-    auto * cascade_buffer = typeid_cast<CascadeWriteBuffer *>(used_output.out_maybe_delayed_and_compressed.get());\n+    auto * cascade_buffer = typeid_cast<CascadeWriteBuffer *>(used_output.out_maybe_delayed_and_compressed);\n     if (!cascade_buffer)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected CascadeWriteBuffer\");\n \n@@ -553,7 +555,8 @@ void HTTPHandler::processQuery(\n     HTMLForm & params,\n     HTTPServerResponse & response,\n     Output & used_output,\n-    std::optional<CurrentThread::QueryScope> & query_scope)\n+    std::optional<CurrentThread::QueryScope> & query_scope,\n+    const ProfileEvents::Event & write_event)\n {\n     using namespace Poco::Net;\n \n@@ -564,6 +567,9 @@ void HTTPHandler::processQuery(\n \n     /// The user could specify session identifier and session timeout.\n     /// It allows to modify settings, create temporary tables and reuse them in subsequent requests.\n+\n+    SCOPE_EXIT({ session->releaseSessionID(); });\n+\n     String session_id;\n     std::chrono::steady_clock::duration session_timeout;\n     bool session_is_set = params.has(\"session_id\");\n@@ -616,15 +622,35 @@ void HTTPHandler::processQuery(\n     size_t buffer_size_http = DBMS_DEFAULT_BUFFER_SIZE;\n     size_t buffer_size_memory = (buffer_size_total > buffer_size_http) ? buffer_size_total : 0;\n \n-    used_output.out = std::make_shared<WriteBufferFromHTTPServerResponse>(\n-        response,\n-        request.getMethod() == HTTPRequest::HTTP_HEAD,\n-        context->getServerSettings().keep_alive_timeout.totalSeconds(),\n-        client_supports_http_compression,\n-        http_response_compression_method);\n+    bool enable_http_compression = params.getParsed<bool>(\"enable_http_compression\", context->getSettingsRef().enable_http_compression);\n+    Int64 http_zlib_compression_level = params.getParsed<Int64>(\"http_zlib_compression_level\", context->getSettingsRef().http_zlib_compression_level);\n+\n+    used_output.out_holder =\n+        std::make_shared<WriteBufferFromHTTPServerResponse>(\n+            response,\n+            request.getMethod() == HTTPRequest::HTTP_HEAD,\n+            context->getServerSettings().keep_alive_timeout.totalSeconds(),\n+            write_event);\n+    used_output.out = used_output.out_holder;\n+    used_output.out_maybe_compressed = used_output.out_holder;\n+\n+    if (client_supports_http_compression && enable_http_compression)\n+    {\n+        used_output.out_holder->setCompressionMethodHeader(http_response_compression_method);\n+        used_output.wrap_compressed_holder =\n+            wrapWriteBufferWithCompressionMethod(\n+                used_output.out_holder.get(),\n+                http_response_compression_method,\n+                static_cast<int>(http_zlib_compression_level),\n+                DBMS_DEFAULT_BUFFER_SIZE, nullptr, 0, false);\n+        used_output.out = used_output.wrap_compressed_holder;\n+    }\n \n     if (internal_compression)\n-        used_output.out_maybe_compressed = std::make_shared<CompressedWriteBuffer>(*used_output.out);\n+    {\n+        used_output.out_compressed_holder = std::make_shared<CompressedWriteBuffer>(*used_output.out);\n+        used_output.out_maybe_compressed = used_output.out_compressed_holder;\n+    }\n     else\n         used_output.out_maybe_compressed = used_output.out;\n \n@@ -664,12 +690,12 @@ void HTTPHandler::processQuery(\n             cascade_buffer2.emplace_back(push_memory_buffer_and_continue);\n         }\n \n-        used_output.out_maybe_delayed_and_compressed = std::make_shared<CascadeWriteBuffer>(\n-            std::move(cascade_buffer1), std::move(cascade_buffer2));\n+        used_output.out_delayed_and_compressed_holder = std::make_unique<CascadeWriteBuffer>(std::move(cascade_buffer1), std::move(cascade_buffer2));\n+        used_output.out_maybe_delayed_and_compressed = used_output.out_delayed_and_compressed_holder.get();\n     }\n     else\n     {\n-        used_output.out_maybe_delayed_and_compressed = used_output.out_maybe_compressed;\n+        used_output.out_maybe_delayed_and_compressed = used_output.out_maybe_compressed.get();\n     }\n \n     /// Request body can be compressed using algorithm specified in the Content-Encoding header.\n@@ -798,14 +824,8 @@ void HTTPHandler::processQuery(\n     const auto & query = getQuery(request, params, context);\n     std::unique_ptr<ReadBuffer> in_param = std::make_unique<ReadBufferFromString>(query);\n \n-    /// HTTP response compression is turned on only if the client signalled that they support it\n-    /// (using Accept-Encoding header) and 'enable_http_compression' setting is turned on.\n-    used_output.out->setCompression(client_supports_http_compression && settings.enable_http_compression);\n-    if (client_supports_http_compression)\n-        used_output.out->setCompressionLevel(static_cast<int>(settings.http_zlib_compression_level));\n-\n-    used_output.out->setSendProgress(settings.send_progress_in_http_headers);\n-    used_output.out->setSendProgressInterval(settings.http_headers_progress_interval_ms);\n+    used_output.out_holder->setSendProgress(settings.send_progress_in_http_headers);\n+    used_output.out_holder->setSendProgressInterval(settings.http_headers_progress_interval_ms);\n \n     /// If 'http_native_compression_disable_checksumming_on_decompress' setting is turned on,\n     /// checksums of client data compressed with internal algorithm are not checked.\n@@ -816,7 +836,7 @@ void HTTPHandler::processQuery(\n     /// Note that whether the header is added is determined by the settings, and we can only get the user settings after authentication.\n     /// Once the authentication fails, the header can't be added.\n     if (settings.add_http_cors_header && !request.get(\"Origin\", \"\").empty() && !config.has(\"http_options_response\"))\n-        used_output.out->addHeaderCORS(true);\n+        used_output.out_holder->addHeaderCORS(true);\n \n     auto append_callback = [my_context = context] (ProgressCallback callback)\n     {\n@@ -835,7 +855,7 @@ void HTTPHandler::processQuery(\n     /// Note that we add it unconditionally so the progress is available for `X-ClickHouse-Summary`\n     append_callback([&used_output](const Progress & progress)\n     {\n-        used_output.out->onProgress(progress);\n+        used_output.out_holder->onProgress(progress);\n     });\n \n     if (settings.readonly > 0 && settings.cancel_http_readonly_queries_on_client_close)\n@@ -888,6 +908,8 @@ void HTTPHandler::processQuery(\n         {},\n         handle_exception_in_output_format);\n \n+    session->releaseSessionID();\n+\n     if (used_output.hasDelayed())\n     {\n         /// TODO: set Content-Length if possible\n@@ -902,10 +924,8 @@ void HTTPHandler::trySendExceptionToClient(\n     const std::string & s, int exception_code, HTTPServerRequest & request, HTTPServerResponse & response, Output & used_output)\n try\n {\n-    /// In case data has already been sent, like progress headers, try using the output buffer to\n-    /// set the exception code since it will be able to append it if it hasn't finished writing headers\n-    if (response.sent() && used_output.out)\n-        used_output.out->setExceptionCode(exception_code);\n+    if (used_output.out_holder)\n+        used_output.out_holder->setExceptionCode(exception_code);\n     else\n         response.set(\"X-ClickHouse-Exception-Code\", toString<int>(exception_code));\n \n@@ -930,10 +950,10 @@ try\n         response.setStatusAndReason(exceptionCodeToHTTPStatus(exception_code));\n     }\n \n-    if (!response.sent() && !used_output.out_maybe_compressed && !used_output.exception_is_written)\n+    if (!used_output.out_holder && !used_output.exception_is_written)\n     {\n         /// If nothing was sent yet and we don't even know if we must compress the response.\n-        *response.send() << s << std::endl;\n+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, DEFAULT_HTTP_KEEP_ALIVE_TIMEOUT).writeln(s);\n     }\n     else if (used_output.out_maybe_compressed)\n     {\n@@ -943,7 +963,8 @@ try\n             /// do not call finalize here for CascadeWriteBuffer used_output.out_maybe_delayed_and_compressed,\n             /// exception is written into used_output.out_maybe_compressed later\n             /// HTTPHandler::trySendExceptionToClient is called with exception context, it is Ok to destroy buffers\n-            used_output.out_maybe_delayed_and_compressed.reset();\n+            used_output.out_delayed_and_compressed_holder.reset();\n+            used_output.out_maybe_delayed_and_compressed = nullptr;\n         }\n \n         if (!used_output.exception_is_written)\n@@ -953,12 +974,12 @@ try\n             /// Also HTTP code 200 could have already been sent.\n \n             /// If buffer has data, and that data wasn't sent yet, then no need to send that data\n-            bool data_sent = used_output.out->count() != used_output.out->offset();\n+            bool data_sent = used_output.out_holder->count() != used_output.out_holder->offset();\n \n             if (!data_sent)\n             {\n                 used_output.out_maybe_compressed->position() = used_output.out_maybe_compressed->buffer().begin();\n-                used_output.out->position() = used_output.out->buffer().begin();\n+                used_output.out_holder->position() = used_output.out_holder->buffer().begin();\n             }\n \n             writeString(s, *used_output.out_maybe_compressed);\n@@ -989,7 +1010,7 @@ catch (...)\n }\n \n \n-void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)\n {\n     setThreadName(\"HTTPHandler\");\n     ThreadStatus thread_status;\n@@ -1078,7 +1099,7 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n                             \"is no Content-Length header for POST request\");\n         }\n \n-        processQuery(request, params, response, used_output, query_scope);\n+        processQuery(request, params, response, used_output, query_scope, write_event);\n         if (request_credentials)\n             LOG_DEBUG(log, \"Authentication in progress...\");\n         else\ndiff --git a/src/Server/HTTPHandler.h b/src/Server/HTTPHandler.h\nindex 6ec56cb09c16..18cf3c7c0f5e 100644\n--- a/src/Server/HTTPHandler.h\n+++ b/src/Server/HTTPHandler.h\n@@ -6,6 +6,8 @@\n #include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>\n #include <Common/CurrentMetrics.h>\n #include <Common/CurrentThread.h>\n+#include <IO/CascadeWriteBuffer.h>\n+#include <Compression/CompressedWriteBuffer.h>\n \n #ifdef __clang__\n #  pragma clang diagnostic push\n@@ -40,7 +42,7 @@ class HTTPHandler : public HTTPRequestHandler\n     HTTPHandler(IServer & server_, const std::string & name, const std::optional<String> & content_type_override_);\n     virtual ~HTTPHandler() override;\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n     /// This method is called right before the query execution.\n     virtual void customizeContext(HTTPServerRequest & /* request */, ContextMutablePtr /* context */, ReadBuffer & /* body */) {}\n@@ -61,11 +63,22 @@ class HTTPHandler : public HTTPRequestHandler\n          * WriteBufferFromHTTPServerResponse out\n          */\n \n-        std::shared_ptr<WriteBufferFromHTTPServerResponse> out;\n-        /// Points to 'out' or to CompressedWriteBuffer(*out), depending on settings.\n+        /// Holds original response buffer\n+        std::shared_ptr<WriteBufferFromHTTPServerResponse> out_holder;\n+        /// If HTTP compression is enabled holds compression wrapper over original response buffer\n+        std::shared_ptr<WriteBuffer> wrap_compressed_holder;\n+        /// Points either to out_holder or to wrap_compressed_holder\n+        std::shared_ptr<WriteBuffer> out;\n+\n+        /// If internal compression is enabled holds compression wrapper over out buffer\n+        std::shared_ptr<CompressedWriteBuffer> out_compressed_holder;\n+        /// Points to 'out' or to CompressedWriteBuffer(*out)\n         std::shared_ptr<WriteBuffer> out_maybe_compressed;\n-        /// Points to 'out' or to CompressedWriteBuffer(*out) or to CascadeWriteBuffer.\n-        std::shared_ptr<WriteBuffer> out_maybe_delayed_and_compressed;\n+\n+        /// If output should be delayed holds cascade buffer\n+        std::unique_ptr<CascadeWriteBuffer> out_delayed_and_compressed_holder;\n+        /// Points to out_maybe_compressed or to CascadeWriteBuffer.\n+        WriteBuffer * out_maybe_delayed_and_compressed = nullptr;\n \n         bool finalized = false;\n \n@@ -73,7 +86,7 @@ class HTTPHandler : public HTTPRequestHandler\n \n         inline bool hasDelayed() const\n         {\n-            return out_maybe_delayed_and_compressed != out_maybe_compressed;\n+            return out_maybe_delayed_and_compressed != out_maybe_compressed.get();\n         }\n \n         inline void finalize()\n@@ -82,11 +95,9 @@ class HTTPHandler : public HTTPRequestHandler\n                 return;\n             finalized = true;\n \n-            if (out_maybe_delayed_and_compressed)\n-                out_maybe_delayed_and_compressed->finalize();\n             if (out_maybe_compressed)\n                 out_maybe_compressed->finalize();\n-            if (out)\n+            else if (out)\n                 out->finalize();\n         }\n \n@@ -135,7 +146,8 @@ class HTTPHandler : public HTTPRequestHandler\n         HTMLForm & params,\n         HTTPServerResponse & response,\n         Output & used_output,\n-        std::optional<CurrentThread::QueryScope> & query_scope);\n+        std::optional<CurrentThread::QueryScope> & query_scope,\n+        const ProfileEvents::Event & write_event);\n \n     void trySendExceptionToClient(\n         const std::string & s,\ndiff --git a/src/Server/InterserverIOHTTPHandler.cpp b/src/Server/InterserverIOHTTPHandler.cpp\nindex 53773a83b40c..c41d68bab021 100644\n--- a/src/Server/InterserverIOHTTPHandler.cpp\n+++ b/src/Server/InterserverIOHTTPHandler.cpp\n@@ -77,7 +77,7 @@ void InterserverIOHTTPHandler::processQuery(HTTPServerRequest & request, HTTPSer\n }\n \n \n-void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)\n {\n     setThreadName(\"IntersrvHandler\");\n     ThreadStatus thread_status;\n@@ -89,7 +89,7 @@ void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPSe\n     Output used_output;\n     const auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();\n     used_output.out = std::make_shared<WriteBufferFromHTTPServerResponse>(\n-        response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout);\n+        response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout, write_event);\n \n     auto write_response = [&](const std::string & message)\n     {\ndiff --git a/src/Server/InterserverIOHTTPHandler.h b/src/Server/InterserverIOHTTPHandler.h\nindex da5b286b9e5e..66042ad3d1df 100644\n--- a/src/Server/InterserverIOHTTPHandler.h\n+++ b/src/Server/InterserverIOHTTPHandler.h\n@@ -30,7 +30,7 @@ class InterserverIOHTTPHandler : public HTTPRequestHandler\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n \n private:\n     struct Output\ndiff --git a/src/Server/KeeperReadinessHandler.cpp b/src/Server/KeeperReadinessHandler.cpp\nindex ed972055aeec..de6edd199d74 100644\n--- a/src/Server/KeeperReadinessHandler.cpp\n+++ b/src/Server/KeeperReadinessHandler.cpp\n@@ -19,7 +19,7 @@\n namespace DB\n {\n \n-void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTPServerResponse & response)\n+void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\n@@ -58,7 +58,7 @@ void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTP\n             if (!response.sent())\n             {\n                 /// We have not sent anything yet and we don't even know if we need to compress response.\n-                *response.send() << getCurrentExceptionMessage(false) << std::endl;\n+                *response.send() << getCurrentExceptionMessage(false) << '\\n';\n             }\n         }\n         catch (...)\ndiff --git a/src/Server/KeeperReadinessHandler.h b/src/Server/KeeperReadinessHandler.h\nindex 00b51b886f9d..a16aa9f8021f 100644\n--- a/src/Server/KeeperReadinessHandler.h\n+++ b/src/Server/KeeperReadinessHandler.h\n@@ -22,7 +22,7 @@ class KeeperReadinessHandler : public HTTPRequestHandler, WithContext\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n };\n \n HTTPRequestHandlerFactoryPtr\ndiff --git a/src/Server/MySQLHandler.cpp b/src/Server/MySQLHandler.cpp\nindex 10b520ca97ae..b3e07e37f305 100644\n--- a/src/Server/MySQLHandler.cpp\n+++ b/src/Server/MySQLHandler.cpp\n@@ -70,13 +70,17 @@ MySQLHandler::MySQLHandler(\n     IServer & server_,\n     TCPServer & tcp_server_,\n     const Poco::Net::StreamSocket & socket_,\n-    bool ssl_enabled, uint32_t connection_id_)\n+    bool ssl_enabled, uint32_t connection_id_,\n+    const ProfileEvents::Event & read_event_,\n+    const ProfileEvents::Event & write_event_)\n     : Poco::Net::TCPServerConnection(socket_)\n     , server(server_)\n     , tcp_server(tcp_server_)\n     , log(&Poco::Logger::get(\"MySQLHandler\"))\n     , connection_id(connection_id_)\n     , auth_plugin(new MySQLProtocol::Authentication::Native41())\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n {\n     server_capabilities = CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_PLUGIN_AUTH | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA | CLIENT_CONNECT_WITH_DB | CLIENT_DEPRECATE_EOF;\n     if (ssl_enabled)\n@@ -98,8 +102,8 @@ void MySQLHandler::run()\n \n     session->setClientConnectionId(connection_id);\n \n-    in = std::make_shared<ReadBufferFromPocoSocket>(socket());\n-    out = std::make_shared<WriteBufferFromPocoSocket>(socket());\n+    in = std::make_shared<ReadBufferFromPocoSocket>(socket(), read_event);\n+    out = std::make_shared<WriteBufferFromPocoSocket>(socket(), write_event);\n     packet_endpoint = std::make_shared<MySQLProtocol::PacketEndpoint>(*in, *out, sequence_id);\n \n     try\n@@ -489,8 +493,10 @@ MySQLHandlerSSL::MySQLHandlerSSL(\n     bool ssl_enabled,\n     uint32_t connection_id_,\n     RSA & public_key_,\n-    RSA & private_key_)\n-    : MySQLHandler(server_, tcp_server_, socket_, ssl_enabled, connection_id_)\n+    RSA & private_key_,\n+    const ProfileEvents::Event & read_event_,\n+    const ProfileEvents::Event & write_event_)\n+    : MySQLHandler(server_, tcp_server_, socket_, ssl_enabled, connection_id_, read_event_, write_event_)\n     , public_key(public_key_)\n     , private_key(private_key_)\n {}\ndiff --git a/src/Server/MySQLHandler.h b/src/Server/MySQLHandler.h\nindex 194b18bdc39f..36d63ebca849 100644\n--- a/src/Server/MySQLHandler.h\n+++ b/src/Server/MySQLHandler.h\n@@ -42,7 +42,9 @@ class MySQLHandler : public Poco::Net::TCPServerConnection\n         TCPServer & tcp_server_,\n         const Poco::Net::StreamSocket & socket_,\n         bool ssl_enabled,\n-        uint32_t connection_id_);\n+        uint32_t connection_id_,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     void run() final;\n \n@@ -102,6 +104,9 @@ class MySQLHandler : public Poco::Net::TCPServerConnection\n     std::shared_ptr<ReadBufferFromPocoSocket> in;\n     std::shared_ptr<WriteBuffer> out;\n     bool secure_connection = false;\n+\n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n };\n \n #if USE_SSL\n@@ -115,7 +120,9 @@ class MySQLHandlerSSL : public MySQLHandler\n         bool ssl_enabled,\n         uint32_t connection_id_,\n         RSA & public_key_,\n-        RSA & private_key_);\n+        RSA & private_key_,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n private:\n     void authPluginSSL() override;\ndiff --git a/src/Server/MySQLHandlerFactory.cpp b/src/Server/MySQLHandlerFactory.cpp\nindex f74f57926f97..79234c647aa6 100644\n--- a/src/Server/MySQLHandlerFactory.cpp\n+++ b/src/Server/MySQLHandlerFactory.cpp\n@@ -21,9 +21,11 @@ namespace ErrorCodes\n     extern const int OPENSSL_ERROR;\n }\n \n-MySQLHandlerFactory::MySQLHandlerFactory(IServer & server_)\n+MySQLHandlerFactory::MySQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)\n     : server(server_)\n     , log(&Poco::Logger::get(\"MySQLHandlerFactory\"))\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n {\n #if USE_SSL\n     try\ndiff --git a/src/Server/MySQLHandlerFactory.h b/src/Server/MySQLHandlerFactory.h\nindex fa4ce93f7655..307ee3b2f0de 100644\n--- a/src/Server/MySQLHandlerFactory.h\n+++ b/src/Server/MySQLHandlerFactory.h\n@@ -4,6 +4,7 @@\n #include <memory>\n #include <Server/IServer.h>\n #include <Server/TCPServerConnectionFactory.h>\n+#include <Common/ProfileEvents.h>\n \n #include \"config.h\"\n \n@@ -37,8 +38,11 @@ class MySQLHandlerFactory : public TCPServerConnectionFactory\n #endif\n \n     std::atomic<unsigned> last_connection_id = 0;\n+\n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n public:\n-    explicit MySQLHandlerFactory(IServer & server_);\n+    explicit MySQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     void readRSAKeys();\n \ndiff --git a/src/Server/NotFoundHandler.cpp b/src/Server/NotFoundHandler.cpp\nindex 5b1db5085515..38f56921c893 100644\n--- a/src/Server/NotFoundHandler.cpp\n+++ b/src/Server/NotFoundHandler.cpp\n@@ -5,7 +5,7 @@\n \n namespace DB\n {\n-void NotFoundHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void NotFoundHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\ndiff --git a/src/Server/NotFoundHandler.h b/src/Server/NotFoundHandler.h\nindex 1cbfcd57f8f1..a484d2377714 100644\n--- a/src/Server/NotFoundHandler.h\n+++ b/src/Server/NotFoundHandler.h\n@@ -10,7 +10,7 @@ class NotFoundHandler : public HTTPRequestHandler\n {\n public:\n     NotFoundHandler(std::vector<std::string> hints_) : hints(std::move(hints_)) {}\n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n private:\n     std::vector<std::string> hints;\n };\ndiff --git a/src/Server/PostgreSQLHandler.cpp b/src/Server/PostgreSQLHandler.cpp\nindex eeb3784c1df1..c62dc8109ea2 100644\n--- a/src/Server/PostgreSQLHandler.cpp\n+++ b/src/Server/PostgreSQLHandler.cpp\n@@ -32,12 +32,16 @@ PostgreSQLHandler::PostgreSQLHandler(\n     TCPServer & tcp_server_,\n     bool ssl_enabled_,\n     Int32 connection_id_,\n-    std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_)\n+    std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_,\n+    const ProfileEvents::Event & read_event_,\n+    const ProfileEvents::Event & write_event_)\n     : Poco::Net::TCPServerConnection(socket_)\n     , server(server_)\n     , tcp_server(tcp_server_)\n     , ssl_enabled(ssl_enabled_)\n     , connection_id(connection_id_)\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n     , authentication_manager(auth_methods_)\n {\n     changeIO(socket());\n@@ -45,8 +49,8 @@ PostgreSQLHandler::PostgreSQLHandler(\n \n void PostgreSQLHandler::changeIO(Poco::Net::StreamSocket & socket)\n {\n-    in = std::make_shared<ReadBufferFromPocoSocket>(socket);\n-    out = std::make_shared<WriteBufferFromPocoSocket>(socket);\n+    in = std::make_shared<ReadBufferFromPocoSocket>(socket, read_event);\n+    out = std::make_shared<WriteBufferFromPocoSocket>(socket, write_event);\n     message_transport = std::make_shared<PostgreSQLProtocol::Messaging::MessageTransport>(in.get(), out.get());\n }\n \ndiff --git a/src/Server/PostgreSQLHandler.h b/src/Server/PostgreSQLHandler.h\nindex f20af3df02cf..57b91a0ad044 100644\n--- a/src/Server/PostgreSQLHandler.h\n+++ b/src/Server/PostgreSQLHandler.h\n@@ -33,7 +33,9 @@ class PostgreSQLHandler : public Poco::Net::TCPServerConnection\n         TCPServer & tcp_server_,\n         bool ssl_enabled_,\n         Int32 connection_id_,\n-        std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_);\n+        std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_,\n+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),\n+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     void run() final;\n \n@@ -51,6 +53,9 @@ class PostgreSQLHandler : public Poco::Net::TCPServerConnection\n     std::shared_ptr<WriteBuffer> out;\n     std::shared_ptr<PostgreSQLProtocol::Messaging::MessageTransport> message_transport;\n \n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n+\n #if USE_SSL\n     std::shared_ptr<Poco::Net::SecureStreamSocket> ss;\n #endif\ndiff --git a/src/Server/PostgreSQLHandlerFactory.cpp b/src/Server/PostgreSQLHandlerFactory.cpp\nindex 6f2124861e7e..096bbbdcda9a 100644\n--- a/src/Server/PostgreSQLHandlerFactory.cpp\n+++ b/src/Server/PostgreSQLHandlerFactory.cpp\n@@ -5,9 +5,11 @@\n namespace DB\n {\n \n-PostgreSQLHandlerFactory::PostgreSQLHandlerFactory(IServer & server_)\n+PostgreSQLHandlerFactory::PostgreSQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)\n     : server(server_)\n     , log(&Poco::Logger::get(\"PostgreSQLHandlerFactory\"))\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n {\n     auth_methods =\n     {\n@@ -20,7 +22,7 @@ Poco::Net::TCPServerConnection * PostgreSQLHandlerFactory::createConnection(cons\n {\n     Int32 connection_id = last_connection_id++;\n     LOG_TRACE(log, \"PostgreSQL connection. Id: {}. Address: {}\", connection_id, socket.peerAddress().toString());\n-    return new PostgreSQLHandler(socket, server, tcp_server, ssl_enabled, connection_id, auth_methods);\n+    return new PostgreSQLHandler(socket, server, tcp_server, ssl_enabled, connection_id, auth_methods, read_event, write_event);\n }\n \n }\ndiff --git a/src/Server/PostgreSQLHandlerFactory.h b/src/Server/PostgreSQLHandlerFactory.h\nindex 35046325386b..e5f762fca6d7 100644\n--- a/src/Server/PostgreSQLHandlerFactory.h\n+++ b/src/Server/PostgreSQLHandlerFactory.h\n@@ -15,6 +15,8 @@ class PostgreSQLHandlerFactory : public TCPServerConnectionFactory\n private:\n     IServer & server;\n     Poco::Logger * log;\n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n \n #if USE_SSL\n     bool ssl_enabled = true;\n@@ -26,7 +28,7 @@ class PostgreSQLHandlerFactory : public TCPServerConnectionFactory\n     std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> auth_methods;\n \n public:\n-    explicit PostgreSQLHandlerFactory(IServer & server_);\n+    explicit PostgreSQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n \n     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & server) override;\n };\ndiff --git a/src/Server/PrometheusRequestHandler.cpp b/src/Server/PrometheusRequestHandler.cpp\nindex 127ed843cb6c..6e0b138f4e07 100644\n--- a/src/Server/PrometheusRequestHandler.cpp\n+++ b/src/Server/PrometheusRequestHandler.cpp\n@@ -13,7 +13,7 @@\n \n namespace DB\n {\n-void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)\n {\n     try\n     {\n@@ -27,7 +27,7 @@ void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPSe\n \n         response.setContentType(\"text/plain; version=0.0.4; charset=UTF-8\");\n \n-        WriteBufferFromHTTPServerResponse wb(response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout);\n+        WriteBufferFromHTTPServerResponse wb(response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout, write_event);\n         try\n         {\n             metrics_writer.write(wb);\ndiff --git a/src/Server/PrometheusRequestHandler.h b/src/Server/PrometheusRequestHandler.h\nindex 1fb3d9f0f595..e366041bc6c5 100644\n--- a/src/Server/PrometheusRequestHandler.h\n+++ b/src/Server/PrometheusRequestHandler.h\n@@ -22,7 +22,7 @@ class PrometheusRequestHandler : public HTTPRequestHandler\n     {\n     }\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n };\n \n }\ndiff --git a/src/Server/ReplicasStatusHandler.cpp b/src/Server/ReplicasStatusHandler.cpp\nindex c30c3ebaa770..07f3b67b6a7e 100644\n--- a/src/Server/ReplicasStatusHandler.cpp\n+++ b/src/Server/ReplicasStatusHandler.cpp\n@@ -22,7 +22,7 @@ ReplicasStatusHandler::ReplicasStatusHandler(IServer & server) : WithContext(ser\n {\n }\n \n-void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     try\n     {\n@@ -113,7 +113,7 @@ void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServe\n             if (!response.sent())\n             {\n                 /// We have not sent anything yet and we don't even know if we need to compress response.\n-                *response.send() << getCurrentExceptionMessage(false) << std::endl;\n+                *response.send() << getCurrentExceptionMessage(false) << '\\n';\n             }\n         }\n         catch (...)\ndiff --git a/src/Server/ReplicasStatusHandler.h b/src/Server/ReplicasStatusHandler.h\nindex 1a5388aa2abf..08fd757b0d61 100644\n--- a/src/Server/ReplicasStatusHandler.h\n+++ b/src/Server/ReplicasStatusHandler.h\n@@ -14,7 +14,7 @@ class ReplicasStatusHandler : public HTTPRequestHandler, WithContext\n public:\n     explicit ReplicasStatusHandler(IServer & server_);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n };\n \n \ndiff --git a/src/Server/StaticRequestHandler.cpp b/src/Server/StaticRequestHandler.cpp\nindex 34cb5d2d1698..67bf3875de48 100644\n--- a/src/Server/StaticRequestHandler.cpp\n+++ b/src/Server/StaticRequestHandler.cpp\n@@ -33,9 +33,11 @@ namespace ErrorCodes\n     extern const int INVALID_CONFIG_PARAMETER;\n }\n \n-static inline WriteBufferPtr\n+static inline std::unique_ptr<WriteBuffer>\n responseWriteBuffer(HTTPServerRequest & request, HTTPServerResponse & response, UInt64 keep_alive_timeout)\n {\n+    auto buf = std::unique_ptr<WriteBuffer>(new WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout));\n+\n     /// The client can pass a HTTP header indicating supported compression method (gzip or deflate).\n     String http_response_compression_methods = request.get(\"Accept-Encoding\", \"\");\n     CompressionMethod http_response_compression_method = CompressionMethod::None;\n@@ -43,14 +45,11 @@ responseWriteBuffer(HTTPServerRequest & request, HTTPServerResponse & response,\n     if (!http_response_compression_methods.empty())\n         http_response_compression_method = chooseHTTPCompressionMethod(http_response_compression_methods);\n \n-    bool client_supports_http_compression = http_response_compression_method != CompressionMethod::None;\n+    if (http_response_compression_method == CompressionMethod::None)\n+        return buf;\n \n-    return std::make_shared<WriteBufferFromHTTPServerResponse>(\n-        response,\n-        request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD,\n-        keep_alive_timeout,\n-        client_supports_http_compression,\n-        http_response_compression_method);\n+    response.set(\"Content-Encoding\", toContentEncodingName(http_response_compression_method));\n+    return wrapWriteBufferWithCompressionMethod(std::move(buf), http_response_compression_method, 1);\n }\n \n static inline void trySendExceptionToClient(\n@@ -69,7 +68,7 @@ static inline void trySendExceptionToClient(\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n \n         if (!response.sent())\n-            *response.send() << s << std::endl;\n+            *response.send() << s << '\\n';\n         else\n         {\n             if (out.count() != out.offset())\n@@ -88,10 +87,10 @@ static inline void trySendExceptionToClient(\n     }\n }\n \n-void StaticRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void StaticRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();\n-    const auto & out = responseWriteBuffer(request, response, keep_alive_timeout);\n+    auto out = responseWriteBuffer(request, response, keep_alive_timeout);\n \n     try\n     {\ndiff --git a/src/Server/StaticRequestHandler.h b/src/Server/StaticRequestHandler.h\nindex df9374d44096..38d774bb0aad 100644\n--- a/src/Server/StaticRequestHandler.h\n+++ b/src/Server/StaticRequestHandler.h\n@@ -29,7 +29,7 @@ class StaticRequestHandler : public HTTPRequestHandler\n \n     void writeResponse(WriteBuffer & out);\n \n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n };\n \n }\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex a563e0e00047..b56df48a1215 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -184,23 +184,27 @@ void validateClientInfo(const ClientInfo & session_client_info, const ClientInfo\n namespace DB\n {\n \n-TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_)\n+TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)\n     : Poco::Net::TCPServerConnection(socket_)\n     , server(server_)\n     , tcp_server(tcp_server_)\n     , parse_proxy_protocol(parse_proxy_protocol_)\n     , log(&Poco::Logger::get(\"TCPHandler\"))\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n     , server_display_name(std::move(server_display_name_))\n {\n }\n \n-TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_)\n+TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)\n : Poco::Net::TCPServerConnection(socket_)\n     , server(server_)\n     , tcp_server(tcp_server_)\n     , log(&Poco::Logger::get(\"TCPHandler\"))\n     , forwarded_for(stack_data.forwarded_for)\n     , certificate(stack_data.certificate)\n+    , read_event(read_event_)\n+    , write_event(write_event_)\n     , default_database(stack_data.default_database)\n     , server_display_name(std::move(server_display_name_))\n {\n@@ -233,8 +237,8 @@ void TCPHandler::runImpl()\n     socket().setSendTimeout(send_timeout);\n     socket().setNoDelay(true);\n \n-    in = std::make_shared<ReadBufferFromPocoSocket>(socket());\n-    out = std::make_shared<WriteBufferFromPocoSocket>(socket());\n+    in = std::make_shared<ReadBufferFromPocoSocket>(socket(), read_event);\n+    out = std::make_shared<WriteBufferFromPocoSocket>(socket(), write_event);\n \n     /// Support for PROXY protocol\n     if (parse_proxy_protocol && !receiveProxyHeader())\ndiff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h\nindex 45c10b1c27d1..4eb84ee5eee5 100644\n--- a/src/Server/TCPHandler.h\n+++ b/src/Server/TCPHandler.h\n@@ -147,8 +147,8 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n       *  because it allows to check the IP ranges of the trusted proxy.\n       * Proxy-forwarded (original client) IP address is used for quota accounting if quota is keyed by forwarded IP.\n       */\n-    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_);\n-    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_);\n+    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n+    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());\n     ~TCPHandler() override;\n \n     void run() override;\n@@ -191,6 +191,9 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n     std::shared_ptr<ReadBuffer> in;\n     std::shared_ptr<WriteBuffer> out;\n \n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n+\n     /// Time after the last check to stop the request and send the progress.\n     Stopwatch after_check_cancelled;\n     Stopwatch after_send_progress;\ndiff --git a/src/Server/TCPHandlerFactory.h b/src/Server/TCPHandlerFactory.h\nindex fde04c6e0ab4..3eb032f4250b 100644\n--- a/src/Server/TCPHandlerFactory.h\n+++ b/src/Server/TCPHandlerFactory.h\n@@ -21,6 +21,9 @@ class TCPHandlerFactory : public TCPServerConnectionFactory\n     Poco::Logger * log;\n     std::string server_display_name;\n \n+    ProfileEvents::Event read_event;\n+    ProfileEvents::Event write_event;\n+\n     class DummyTCPHandler : public Poco::Net::TCPServerConnection\n     {\n     public:\n@@ -33,9 +36,11 @@ class TCPHandlerFactory : public TCPServerConnectionFactory\n       * and set the information about forwarded address accordingly.\n       * See https://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt\n       */\n-    TCPHandlerFactory(IServer & server_, bool secure_, bool parse_proxy_protocol_)\n+    TCPHandlerFactory(IServer & server_, bool secure_, bool parse_proxy_protocol_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end())\n         : server(server_), parse_proxy_protocol(parse_proxy_protocol_)\n         , log(&Poco::Logger::get(std::string(\"TCP\") + (secure_ ? \"S\" : \"\") + \"HandlerFactory\"))\n+        , read_event(read_event_)\n+        , write_event(write_event_)\n     {\n         server_display_name = server.config().getString(\"display_name\", getFQDNOrHostName());\n     }\n@@ -45,8 +50,7 @@ class TCPHandlerFactory : public TCPServerConnectionFactory\n         try\n         {\n             LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n-\n-            return new TCPHandler(server, tcp_server, socket, parse_proxy_protocol, server_display_name);\n+            return new TCPHandler(server, tcp_server, socket, parse_proxy_protocol, server_display_name, read_event, write_event);\n         }\n         catch (const Poco::Net::NetException &)\n         {\n@@ -60,8 +64,7 @@ class TCPHandlerFactory : public TCPServerConnectionFactory\n         try\n         {\n             LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n-\n-            return new TCPHandler(server, tcp_server, socket, stack_data, server_display_name);\n+            return new TCPHandler(server, tcp_server, socket, stack_data, server_display_name, read_event, write_event);\n         }\n         catch (const Poco::Net::NetException &)\n         {\ndiff --git a/src/Server/WebUIRequestHandler.cpp b/src/Server/WebUIRequestHandler.cpp\nindex ad48b38b91ab..f9b77909df96 100644\n--- a/src/Server/WebUIRequestHandler.cpp\n+++ b/src/Server/WebUIRequestHandler.cpp\n@@ -1,5 +1,6 @@\n #include \"WebUIRequestHandler.h\"\n #include \"IServer.h\"\n+#include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>\n \n #include <Poco/Net/HTTPServerResponse.h>\n #include <Poco/Util/LayeredConfiguration.h>\n@@ -36,7 +37,7 @@ WebUIRequestHandler::WebUIRequestHandler(IServer & server_)\n }\n \n \n-void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n+void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)\n {\n     auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();\n \n@@ -50,7 +51,7 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR\n     if (request.getURI().starts_with(\"/play\"))\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_play_htmlData), gresource_play_htmlSize);\n+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_play_htmlData), gresource_play_htmlSize);\n     }\n     else if (request.getURI().starts_with(\"/dashboard\"))\n     {\n@@ -66,17 +67,17 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR\n         static re2::RE2 uplot_url = R\"(https://[^\\s\"'`]+u[Pp]lot[^\\s\"'`]*\\.js)\";\n         RE2::Replace(&html, uplot_url, \"/js/uplot.js\");\n \n-        *response.send() << html;\n+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(html);\n     }\n     else if (request.getURI().starts_with(\"/binary\"))\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_binary_htmlData), gresource_binary_htmlSize);\n+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_binary_htmlData), gresource_binary_htmlSize);\n     }\n     else if (request.getURI() == \"/js/uplot.js\")\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_uplot_jsData), gresource_uplot_jsSize);\n+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_uplot_jsData), gresource_uplot_jsSize);\n     }\n     else\n     {\ndiff --git a/src/Server/WebUIRequestHandler.h b/src/Server/WebUIRequestHandler.h\nindex 09fe62d41c3d..c52946e20899 100644\n--- a/src/Server/WebUIRequestHandler.h\n+++ b/src/Server/WebUIRequestHandler.h\n@@ -16,7 +16,7 @@ class WebUIRequestHandler : public HTTPRequestHandler\n \n public:\n     WebUIRequestHandler(IServer & server_);\n-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;\n+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02293_http_header_full_summary_without_progress.sh b/tests/queries/0_stateless/02293_http_header_full_summary_without_progress.sh\nindex 8f08bd6f84b6..a08928a773cc 100755\n--- a/tests/queries/0_stateless/02293_http_header_full_summary_without_progress.sh\n+++ b/tests/queries/0_stateless/02293_http_header_full_summary_without_progress.sh\n@@ -7,7 +7,7 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n \n \n CURL_OUTPUT=$(echo 'SELECT 1 + sleepEachRow(0.00002) FROM numbers(100000)' | \\\n-  ${CLICKHOUSE_CURL_COMMAND} -v \"${CLICKHOUSE_URL}&wait_end_of_query=1&send_progress_in_http_headers=0&max_execution_time=1\" --data-binary @- 2>&1)\n+  ${CLICKHOUSE_CURL_COMMAND} -vsS \"${CLICKHOUSE_URL}&wait_end_of_query=1&send_progress_in_http_headers=0&max_execution_time=1\" --data-binary @- 2>&1)\n \n READ_ROWS=$(echo \"${CURL_OUTPUT}\" | \\\n   grep 'X-ClickHouse-Summary' | \\\ndiff --git a/tests/queries/0_stateless/02373_progress_contain_result.sh b/tests/queries/0_stateless/02373_progress_contain_result.sh\nindex c87a5ec76158..fd343df10131 100755\n--- a/tests/queries/0_stateless/02373_progress_contain_result.sh\n+++ b/tests/queries/0_stateless/02373_progress_contain_result.sh\n@@ -5,5 +5,5 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n . \"$CURDIR\"/../shell_config.sh\n \n echo 'SELECT 1 FROM numbers(100)' |\n-  ${CLICKHOUSE_CURL_COMMAND} -v \"${CLICKHOUSE_URL}&wait_end_of_query=1&send_progress_in_http_headers=0\" --data-binary @- 2>&1 |\n+  ${CLICKHOUSE_CURL_COMMAND} -vsS \"${CLICKHOUSE_URL}&wait_end_of_query=1&send_progress_in_http_headers=0\" --data-binary @- 2>&1 |\n   grep 'X-ClickHouse-Summary' | sed 's/,\\\"elapsed_ns[^}]*//'\n",
  "problem_statement": "ProfileEvents for the traffic (bytes) transmitted over server interfaces\nThe amount of data sent and received through TCP(s), HTTP(s), MySQL, PostgreSQL, GRPC, Prometheus, Interserver, Keeper clients, Keeper RAFT.\r\n\n",
  "hints_text": "I was fiddling with this since Friday and apparently the easiest way to implement this is to fix that issue with HTTPServerResponse using std stream by replacing it with our buffer. So I'll try to do it in the same PR...",
  "created_at": "2023-10-27T02:43:38Z"
}