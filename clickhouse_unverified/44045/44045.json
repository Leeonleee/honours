{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44045,
  "instance_id": "ClickHouse__ClickHouse-44045",
  "issue_numbers": [
    "44037"
  ],
  "base_commit": "b068119d2772c6a52a425e08da3286167f349f21",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex e4e718e7ebc3..25ba56fa0465 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -531,6 +531,11 @@ void increment(Event event, Count amount)\n     DB::CurrentThread::getProfileEvents().increment(event, amount);\n }\n \n+void incrementNoTrace(Event event, Count amount)\n+{\n+    DB::CurrentThread::getProfileEvents().incrementNoTrace(event, amount);\n+}\n+\n void Counters::increment(Event event, Count amount)\n {\n     Counters * current = this;\n@@ -547,6 +552,16 @@ void Counters::increment(Event event, Count amount)\n         DB::TraceSender::send(DB::TraceType::ProfileEvent, StackTrace(), {.event = event, .increment = amount});\n }\n \n+void Counters::incrementNoTrace(Event event, Count amount)\n+{\n+    Counters * current = this;\n+    do\n+    {\n+        current->counters[event].fetch_add(amount, std::memory_order_relaxed);\n+        current = current->parent;\n+    } while (current != nullptr);\n+}\n+\n CountersIncrement::CountersIncrement(Counters::Snapshot const & snapshot)\n {\n     init();\ndiff --git a/src/Common/ProfileEvents.h b/src/Common/ProfileEvents.h\nindex 256a17cc0804..867b5b551c62 100644\n--- a/src/Common/ProfileEvents.h\n+++ b/src/Common/ProfileEvents.h\n@@ -54,6 +54,7 @@ namespace ProfileEvents\n         }\n \n         void increment(Event event, Count amount = 1);\n+        void incrementNoTrace(Event event, Count amount = 1);\n \n         struct Snapshot\n         {\n@@ -105,6 +106,10 @@ namespace ProfileEvents\n     /// Increment a counter for event. Thread-safe.\n     void increment(Event event, Count amount = 1);\n \n+    /// The same as above but ignores value of setting 'trace_profile_events'\n+    /// and never sends profile event to trace log.\n+    void incrementNoTrace(Event event, Count amount = 1);\n+\n     /// Get name of event by identifier. Returns statically allocated string.\n     const char * getName(Event event);\n \ndiff --git a/src/Common/QueryProfiler.cpp b/src/Common/QueryProfiler.cpp\nindex 14a6a06088cd..e0a59405a62f 100644\n--- a/src/Common/QueryProfiler.cpp\n+++ b/src/Common/QueryProfiler.cpp\n@@ -50,11 +50,11 @@ namespace\n                 /// But pass with some frequency to avoid drop of all traces.\n                 if (overrun_count > 0 && write_trace_iteration % (overrun_count + 1) == 0)\n                 {\n-                    ProfileEvents::increment(ProfileEvents::QueryProfilerSignalOverruns, overrun_count);\n+                    ProfileEvents::incrementNoTrace(ProfileEvents::QueryProfilerSignalOverruns, overrun_count);\n                 }\n                 else\n                 {\n-                    ProfileEvents::increment(ProfileEvents::QueryProfilerSignalOverruns, std::max(0, overrun_count) + 1);\n+                    ProfileEvents::incrementNoTrace(ProfileEvents::QueryProfilerSignalOverruns, std::max(0, overrun_count) + 1);\n                     return;\n                 }\n             }\n@@ -67,7 +67,7 @@ namespace\n         const StackTrace stack_trace(signal_context);\n \n         TraceSender::send(trace_type, stack_trace, {});\n-        ProfileEvents::increment(ProfileEvents::QueryProfilerRuns);\n+        ProfileEvents::incrementNoTrace(ProfileEvents::QueryProfilerRuns);\n \n         errno = saved_errno;\n     }\ndiff --git a/src/IO/WriteBufferFromFileDescriptorDiscardOnFailure.cpp b/src/IO/WriteBufferFromFileDescriptorDiscardOnFailure.cpp\nindex 3d9c70f03965..69be24f0fae8 100644\n--- a/src/IO/WriteBufferFromFileDescriptorDiscardOnFailure.cpp\n+++ b/src/IO/WriteBufferFromFileDescriptorDiscardOnFailure.cpp\n@@ -17,7 +17,10 @@ void WriteBufferFromFileDescriptorDiscardOnFailure::nextImpl()\n \n         if ((-1 == res || 0 == res) && errno != EINTR)\n         {\n-            ProfileEvents::increment(ProfileEvents::CannotWriteToWriteBufferDiscard);\n+            /// Never send this profile event to trace log because it may cause another\n+            /// write into the same fd and likely will trigger the same error\n+            /// and will lead to infinite recursion.\n+            ProfileEvents::incrementNoTrace(ProfileEvents::CannotWriteToWriteBufferDiscard);\n             break;  /// Discard\n         }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02497_trace_events_stress_long.reference b/tests/queries/0_stateless/02497_trace_events_stress_long.reference\nnew file mode 100644\nindex 000000000000..573541ac9702\n--- /dev/null\n+++ b/tests/queries/0_stateless/02497_trace_events_stress_long.reference\n@@ -0,0 +1,1 @@\n+0\ndiff --git a/tests/queries/0_stateless/02497_trace_events_stress_long.sh b/tests/queries/0_stateless/02497_trace_events_stress_long.sh\nnew file mode 100755\nindex 000000000000..547aa3b89a2f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02497_trace_events_stress_long.sh\n@@ -0,0 +1,47 @@\n+#!/usr/bin/env bash\n+# Tags: long, no-parallel, no-tsan, no-asan, no-debug, no-s3-storage, no-fasttest, no-replicated-database\n+\n+set -e\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+function thread1()\n+{\n+    query_id=\"$RANDOM-$CLICKHOUSE_DATABASE\"\n+\n+    while true; do\n+        $CLICKHOUSE_CLIENT --query_id=$query_id --query \"\n+            SELECT count() FROM numbers_mt(100000) SETTINGS\n+                trace_profile_events = 1,\n+                query_profiler_real_time_period_ns = 10000000,\n+                query_profiler_cpu_time_period_ns =  10000000,\n+                memory_profiler_step = 1024,\n+                memory_profiler_sample_probability = 0.9\n+            \"\n+    done\n+}\n+\n+function thread2()\n+{\n+    while true; do\n+        $CLICKHOUSE_CLIENT -q \"SYSTEM FLUSH LOGS\"\n+    done\n+}\n+\n+export -f thread1\n+export -f thread2\n+\n+TIMEOUT=10\n+\n+timeout $TIMEOUT bash -c thread1 >/dev/null &\n+timeout $TIMEOUT bash -c thread1 >/dev/null &\n+timeout $TIMEOUT bash -c thread1 >/dev/null &\n+timeout $TIMEOUT bash -c thread1 >/dev/null &\n+timeout $TIMEOUT bash -c thread2 >/dev/null &\n+\n+wait\n+\n+$CLICKHOUSE_CLIENT -q \"KILL QUERY WHERE query_id = '$query_id' SYNC\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count() FROM system.processes WHERE query_id = '$query_id'\"\n",
  "problem_statement": "Segmentation fault while sending trace_type = 'ProfileEvent' to trace log\nhttps://s3.amazonaws.com/clickhouse-test-reports/43987/3725cf4aa7a9aa022b11d08b2f8e4f7f0dd70283/stress_test__ubsan_/gdb.log\n",
  "hints_text": "cc @CurtizJ \nCan be related to https://github.com/ClickHouse/ClickHouse/pull/43639\nAh, quite stupid stackoverflow.",
  "created_at": "2022-12-08T15:15:28Z",
  "modified_files": [
    "src/Common/ProfileEvents.cpp",
    "src/Common/ProfileEvents.h",
    "src/Common/QueryProfiler.cpp",
    "src/IO/WriteBufferFromFileDescriptorDiscardOnFailure.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02497_trace_events_stress_long.reference",
    "b/tests/queries/0_stateless/02497_trace_events_stress_long.sh"
  ]
}