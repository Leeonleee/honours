{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42411,
  "instance_id": "ClickHouse__ClickHouse-42411",
  "issue_numbers": [
    "21834"
  ],
  "base_commit": "0d8a814d80f715f9eeb9efad18337fb4836593cd",
  "patch": "diff --git a/src/Functions/randDistribution.cpp b/src/Functions/randDistribution.cpp\nnew file mode 100644\nindex 000000000000..94dad4fdc899\n--- /dev/null\n+++ b/src/Functions/randDistribution.cpp\n@@ -0,0 +1,472 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/FunctionFactory.h>\n+#include \"Common/Exception.h\"\n+#include <Common/NaNUtils.h>\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Common/FieldVisitorConvertToNumber.h>\n+#include <Common/ProfileEvents.h>\n+#include <Common/assert_cast.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context_fwd.h>\n+\n+#include <random>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+namespace\n+{\n+struct UniformDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randUniform\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(Float64 min, Float64 max, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::uniform_real_distribution<>(min, max);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct NormalDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randNormal\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(Float64 mean, Float64 variance, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::normal_distribution<>(mean, variance);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct LogNormalDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randLogNormal\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(Float64 mean, Float64 variance, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::lognormal_distribution<>(mean, variance);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct ExponentialDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randExponential\"; }\n+    static constexpr size_t getNumberOfArguments() { return 1; }\n+\n+    static void generate(Float64 lambda, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::exponential_distribution<>(lambda);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct ChiSquaredDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randChiSquared\"; }\n+    static constexpr size_t getNumberOfArguments() { return 1; }\n+\n+    static void generate(Float64 degree_of_freedom, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::chi_squared_distribution<>(degree_of_freedom);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct StudentTDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randStudentT\"; }\n+    static constexpr size_t getNumberOfArguments() { return 1; }\n+\n+    static void generate(Float64 degree_of_freedom, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::student_t_distribution<>(degree_of_freedom);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct FisherFDistribution\n+{\n+    using ReturnType = DataTypeFloat64;\n+    static constexpr const char * getName() { return \"randFisherF\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(Float64 d1, Float64 d2, ColumnFloat64::Container & container)\n+    {\n+        auto distribution = std::fisher_f_distribution<>(d1, d2);\n+        for (auto & elem : container)\n+            elem = distribution(thread_local_rng);\n+    }\n+};\n+\n+struct BernoulliDistribution\n+{\n+    using ReturnType = DataTypeUInt8;\n+    static constexpr const char * getName() { return \"randBernoulli\"; }\n+    static constexpr size_t getNumberOfArguments() { return 1; }\n+\n+    static void generate(Float64 p, ColumnUInt8::Container & container)\n+    {\n+        if (p < 0.0f || p > 1.0f)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument of function {} should be inside [0, 1] because it is a probability\", getName());\n+\n+        auto distribution = std::bernoulli_distribution(p);\n+        for (auto & elem : container)\n+            elem = static_cast<UInt8>(distribution(thread_local_rng));\n+    }\n+};\n+\n+struct BinomialDistribution\n+{\n+    using ReturnType = DataTypeUInt64;\n+    static constexpr const char * getName() { return \"randBinomial\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(UInt64 t, Float64 p, ColumnUInt64::Container & container)\n+    {\n+        if (p < 0.0f || p > 1.0f)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument of function {} should be inside [0, 1] because it is a probability\", getName());\n+\n+        auto distribution = std::binomial_distribution(t, p);\n+        for (auto & elem : container)\n+            elem = static_cast<UInt64>(distribution(thread_local_rng));\n+    }\n+};\n+\n+struct NegativeBinomialDistribution\n+{\n+    using ReturnType = DataTypeUInt64;\n+    static constexpr const char * getName() { return \"randNegativeBinomial\"; }\n+    static constexpr size_t getNumberOfArguments() { return 2; }\n+\n+    static void generate(UInt64 t, Float64 p, ColumnUInt64::Container & container)\n+    {\n+        if (p < 0.0f || p > 1.0f)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument of function {} should be inside [0, 1] because it is a probability\", getName());\n+\n+        auto distribution = std::negative_binomial_distribution(t, p);\n+        for (auto & elem : container)\n+            elem = static_cast<UInt64>(distribution(thread_local_rng));\n+    }\n+};\n+\n+struct PoissonDistribution\n+{\n+    using ReturnType = DataTypeUInt64;\n+    static constexpr const char * getName() { return \"randPoisson\"; }\n+    static constexpr size_t getNumberOfArguments() { return 1; }\n+\n+    static void generate(UInt64 n, ColumnUInt64::Container & container)\n+    {\n+        auto distribution = std::poisson_distribution(n);\n+        for (auto & elem : container)\n+            elem = static_cast<UInt64>(distribution(thread_local_rng));\n+    }\n+};\n+\n+}\n+\n+/** Function which will generate values according to the specified distribution\n+  * Accepts only constant arguments\n+  * Similar to the functions rand and rand64 an additional 'tag' argument could be added to the\n+  * end of arguments list (this argument will be ignored) which will guarantee that functions are not sticked together\n+  * during optimisations.\n+  * Example: SELECT randNormal(0, 1, 1), randNormal(0, 1, 2) FROM numbers(10)\n+  * This query will return two different columns\n+  */\n+template <typename Distribution>\n+class FunctionRandomDistribution : public IFunction\n+{\n+private:\n+\n+    template <typename ResultType>\n+    ResultType getParameterFromConstColumn(size_t parameter_number, const ColumnsWithTypeAndName & arguments) const\n+    {\n+        if (parameter_number >= arguments.size())\n+            throw Exception(\n+                ErrorCodes::LOGICAL_ERROR, \"Parameter number ({}) is greater than the size of arguments ({}). This is a bug\", parameter_number, arguments.size());\n+\n+        const IColumn * col = arguments[parameter_number].column.get();\n+\n+        if (!isColumnConst(*col))\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Parameter number {} of function must be constant.\", parameter_number, getName());\n+\n+        auto parameter = applyVisitor(FieldVisitorConvertToNumber<ResultType>(), assert_cast<const ColumnConst &>(*col).getField());\n+\n+        if (isNaN(parameter) || !std::isfinite(parameter))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Parameter number {} of function {} cannot be NaN of infinite\", parameter_number, getName());\n+\n+        return parameter;\n+    }\n+\n+public:\n+    static FunctionPtr create(ContextPtr)\n+    {\n+        return std::make_shared<FunctionRandomDistribution<Distribution>>();\n+    }\n+\n+    static constexpr auto name = Distribution::getName();\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return Distribution::getNumberOfArguments(); }\n+    bool isVariadic() const override { return true; }\n+    bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return false; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto desired = Distribution::getNumberOfArguments();\n+        if (arguments.size() != desired && arguments.size() != desired + 1)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Wrong number of arguments for function {}. Should be {} or {}\", getName(), desired, desired + 1);\n+\n+        for (size_t i = 0; i < Distribution::getNumberOfArguments(); ++i)\n+        {\n+            const auto & type = arguments[i];\n+            WhichDataType which(type);\n+            if (!which.isFloat() && !which.isNativeUInt())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type {} of argument of function {}, expected Float64 or integer\", type->getName(), getName());\n+        }\n+\n+        return std::make_shared<typename Distribution::ReturnType>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t input_rows_count) const override\n+    {\n+        if constexpr (std::is_same_v<Distribution, BernoulliDistribution>)\n+        {\n+            auto res_column = ColumnUInt8::create(input_rows_count);\n+            auto & res_data = res_column->getData();\n+            Distribution::generate(getParameterFromConstColumn<Float64>(0, arguments), res_data);\n+            return res_column;\n+        }\n+        else if constexpr (std::is_same_v<Distribution, BinomialDistribution> || std::is_same_v<Distribution, NegativeBinomialDistribution>)\n+        {\n+            auto res_column = ColumnUInt64::create(input_rows_count);\n+            auto & res_data = res_column->getData();\n+            Distribution::generate(getParameterFromConstColumn<UInt64>(0, arguments), getParameterFromConstColumn<Float64>(1, arguments), res_data);\n+            return res_column;\n+        }\n+        else if constexpr (std::is_same_v<Distribution, PoissonDistribution>)\n+        {\n+            auto res_column = ColumnUInt64::create(input_rows_count);\n+            auto & res_data = res_column->getData();\n+            Distribution::generate(getParameterFromConstColumn<UInt64>(0, arguments), res_data);\n+            return res_column;\n+        }\n+        else\n+        {\n+            auto res_column = ColumnFloat64::create(input_rows_count);\n+            auto & res_data = res_column->getData();\n+            if constexpr (Distribution::getNumberOfArguments() == 1)\n+            {\n+                Distribution::generate(getParameterFromConstColumn<Float64>(0, arguments), res_data);\n+            }\n+            else if constexpr (Distribution::getNumberOfArguments() == 2)\n+            {\n+                Distribution::generate(getParameterFromConstColumn<Float64>(0, arguments), getParameterFromConstColumn<Float64>(1, arguments), res_data);\n+            }\n+            else\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"More than two argument specified for function {}\", getName());\n+            }\n+\n+            return res_column;\n+        }\n+    }\n+};\n+\n+\n+REGISTER_FUNCTION(Distribution)\n+{\n+    factory.registerFunction<FunctionRandomDistribution<UniformDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the uniform distribution in the specified range.\n+Accepts two parameters - minimum bound and maximum bound.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randUniform(0, 1) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+    factory.registerFunction<FunctionRandomDistribution<NormalDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the normal distribution.\n+Accepts two parameters - mean and variance.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randNormal(0, 5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<LogNormalDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the lognormal distribution (a distribution of a random variable whose logarithm is normally distributed).\n+Accepts two parameters - mean and variance.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randLogNormal(0, 5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<ExponentialDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the exponential distribution.\n+Accepts one parameter.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randExponential(0, 5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<ChiSquaredDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the chi-squared distribution (a distribution of a sum of the squares of k independent standard normal random variables).\n+Accepts one parameter - degree of freedom.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randChiSquared(5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+    factory.registerFunction<FunctionRandomDistribution<StudentTDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the t-distribution.\n+Accepts one parameter - degree of freedom.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randStudentT(5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<FisherFDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the f-distribution.\n+The F-distribution is the distribution of X = (S1 / d1) / (S2 / d2) where d1 and d2 are degrees of freedom.\n+Accepts two parameters - degrees of freedom.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randFisherF(5) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<BernoulliDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the Bernoulli distribution.\n+Accepts two parameters - probability of success.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randBernoulli(0.1) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<BinomialDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the binomial distribution.\n+Accepts two parameters - number of experiments and probability of success in each experiment.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randBinomial(10, 0.1) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<NegativeBinomialDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the negative binomial distribution.\n+Accepts two parameters - number of experiments and probability of success in each experiment.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randNegativeBinomial(10, 0.1) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+\n+\n+    factory.registerFunction<FunctionRandomDistribution<PoissonDistribution>>(\n+    {\n+    R\"(\n+Returns a random number from the poisson distribution.\n+Accepts two parameters - the mean number of occurrences.\n+\n+Typical usage:\n+[example:typical]\n+)\",\n+    Documentation::Examples{\n+        {\"typical\", \"SELECT randPoisson(3) FROM numbers(100000);\"}},\n+    Documentation::Categories{\"Distribution\"}\n+    });\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02462_distributions.reference b/tests/queries/0_stateless/02462_distributions.reference\nnew file mode 100644\nindex 000000000000..56b04bcb856b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02462_distributions.reference\n@@ -0,0 +1,12 @@\n+Ok\n+Ok\n+Ok\n+Ok\n+Ok\n+Ok\n+Ok\n+0\n+1\n+Ok\n+Ok\n+Ok\ndiff --git a/tests/queries/0_stateless/02462_distributions.sql b/tests/queries/0_stateless/02462_distributions.sql\nnew file mode 100644\nindex 000000000000..b45dc897f2ae\n--- /dev/null\n+++ b/tests/queries/0_stateless/02462_distributions.sql\n@@ -0,0 +1,24 @@\n+# Values should be between 0 and 1\n+SELECT DISTINCT if (a >= toFloat64(0) AND a <= toFloat64(1), 'Ok', 'Fail') FROM (SELECT randUniform(0, 1) AS a FROM numbers(100000));\n+# Mean should be around 0\n+SELECT DISTINCT if (m >= toFloat64(-0.2) AND m <= toFloat64(0.2), 'Ok', 'Fail') FROM (SELECT avg(a) as m FROM (SELECT randNormal(0, 5) AS a FROM numbers(100000)));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randLogNormal(0, 5) AS a FROM numbers(100000));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randExponential(15) AS a FROM numbers(100000));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randChiSquared(3) AS a FROM numbers(100000));\n+# Mean should be around 0\n+SELECT DISTINCT if (m > toFloat64(-0.2) AND m < toFloat64(0.2), 'Ok', 'Fail') FROM (SELECT avg(a) as m FROM (SELECT randStudentT(5) AS a FROM numbers(100000)));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randFisherF(3, 4) AS a FROM numbers(100000));\n+# There should be only 0s and 1s\n+SELECT a FROM (SELECT DISTINCT randBernoulli(0.5) AS a FROM numbers(100000)) ORDER BY a;\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randBinomial(3, 0.5) AS a FROM numbers(100000));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randNegativeBinomial(3, 0.5) AS a FROM numbers(100000));\n+# Values should be >= 0\n+SELECT DISTINCT if (a >= toFloat64(0), 'Ok', 'Fail') FROM (SELECT randPoisson(44) AS a FROM numbers(100000));\n+# No errors\n+SELECT randUniform(1, 2, 1), randNormal(0, 1, 'abacaba'), randLogNormal(0, 10, 'b'), randChiSquared(1, 1), randStudentT(7, '8'), randFisherF(23, 42, 100), randBernoulli(0.5, 2), randBinomial(3, 0.5, 1), randNegativeBinomial(3, 0.5, 2), randPoisson(44, 44) FORMAT Null;\n",
  "problem_statement": "Generate random data with boundaries\n\r\n**Use case**\r\nIt could be useful to generate random data with boundaries.\r\nCurrently, both generateRandom functions and engine, allow to define a table like:\r\n\r\n```sql\r\nCREATE TABLE randomt\r\n(\r\n    `value` Decimal(5,2),\r\n    `date` Date,\r\n    `zone_id` UInt64,\r\n    `type` Enum8('blue' = 0, 'green' = 1, 'red' = 2),\r\n    `interests` Array(String)\r\n)\r\nENGINE = GenerateRandom(123, 5, 3)\r\n```\r\n```sql\r\nSELECT *\r\nFROM randomt\r\nLIMIT 5\r\n```\r\n\r\n```shell\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500value\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500zone_id\u2500\u252c\u2500type\u2500\u2500\u252c\u2500interests\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  17418655.70 \u2502 2018-08-16 \u2502  9921422126199728620 \u2502 green \u2502 ['(nX']        \u2502\r\n\u2502  -2712197.83 \u2502 1992-12-19 \u2502  1576572515264284063 \u2502 blue  \u2502 ['','8NM','I'] \u2502\r\n\u2502  15070040.36 \u2502 2102-11-15 \u2502   688226268395004343 \u2502 blue  \u2502 ['b7<ZU','m*'] \u2502\r\n\u2502 -16219929.50 \u2502 2033-01-18 \u2502 12076865034075318107 \u2502 red   \u2502 ['3']          \u2502\r\n\u2502   2771016.64 \u2502 2051-03-21 \u2502  8931155881545802352 \u2502 blue  \u2502 ['oU',';!>V']  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt works great for fuzzing test and some other things, but I'm thinking in the use case of generated 'mock' data with limits for each column.\r\n\r\nFor some fields (date and enum), the behaviour is correct (in the sense of mock data).\r\n\r\n```sql\r\nSELECT *\r\nFROM randomt\r\nWHERE (date = toDate('2020-10-20')) AND (type = 'blue')\r\nLIMIT 5\r\n```\r\n\r\n```shell\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500value\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500zone_id\u2500\u252c\u2500type\u2500\u252c\u2500interests\u2500\u2510\r\n\u2502  -459221.48 \u2502 2020-10-20 \u2502 16696499279086187682 \u2502 blue \u2502 ['R']     \u2502\r\n\u2502 -5533672.64 \u2502 2020-10-20 \u2502  5903887098779430673 \u2502 blue \u2502 []        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500value\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500zone_id\u2500\u252c\u2500type\u2500\u252c\u2500interests\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  7419336.56 \u2502 2020-10-20 \u2502  4113108383613272096 \u2502 blue \u2502 ['A','~5^H+','\"X@']   \u2502\r\n\u2502 -2742208.19 \u2502 2020-10-20 \u2502 17036311104628448725 \u2502 blue \u2502 [' 4 5:','Nd?0','f9'] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500value\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500zone_id\u2500\u252c\u2500type\u2500\u252c\u2500interests\u2500\u2510\r\n\u2502 3702796.40 \u2502 2020-10-20 \u2502 18297471488954938545 \u2502 blue \u2502 []        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut when selecting others like:\r\n\r\n```sql\r\nselect * from randomt where date=toDate('2020-10-20') and type='blue' and zone_id in (array(1,2,3)) limit 5\r\n```\r\n\r\nThe query hangs out.\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nWhat if is possible something like:\r\n```sql\r\nCREATE TABLE randomt\r\n(\r\n    `value` Decimal(5,2) [min=0, max=100]\r\n    `date` Date, [min=toDate('2020-10-01', max=toDate('2021,03-03')\r\n    `zone_id` UInt64, [min=0, max=2000]\r\n    `type` Enum8('blue' = 0, 'green' = 1, 'red' = 2),\r\n    `interests` Array(String) (select interest in another_table)\r\n)\r\nENGINE = GenerateRandom(123, 5, 3)\r\n```\r\nThe syntax could be other, of course, it just as an example to illustrate.\r\nFor strings, min and max probably hasn't make sense, so something like a list of values could be useful.\r\n\r\n\r\n**Describe alternatives you've considered**\r\nclickhouse-obfuscated, but it would take too much disk space for the use case.\r\n\r\n\r\n**Additional context**\r\n\r\nIf it doesn't make sense, or there are currently better alternatives, just say it :)\r\n\r\n\n",
  "hints_text": "It makes sense.\r\n\r\nMaybe we can define the boundaries with CONSTRAINTs in a table.\r\nIf all the constraints are in form of comparison, e.g. `column >= const`, we can analyze them for the boundaries of data to generate.\r\n\nCC @qoega \nI thought about similar things but met several obstacles and left it as it is. \n1) we can transform data after generation in select query. This is the way how I used to generate smaller time ranges to allow insert in partitioned tables. Otherwise we will have more parts in one insert.\n2) currently data generation uniformity is not guaranteed. As well as other distributions are not supported. We have best effort behavior there\n3) limits and distributions in schema syntax will be very complex. I think every use case will be quite different and we will have to add more features in syntax for every new case.\n4) I used enums to generate LowCardinality Strings and similar columns.\n\nYou are welcome to contribute if you know how to improve this place, but probably you can solve your case using current features. ",
  "created_at": "2022-10-17T19:10:28Z"
}