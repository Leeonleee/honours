{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21370,
  "instance_id": "ClickHouse__ClickHouse-21370",
  "issue_numbers": [
    "18368",
    "22226"
  ],
  "base_commit": "8f23d39f2604e788c417148136bbc24aeaa313be",
  "patch": "diff --git a/src/Interpreters/CrossToInnerJoinVisitor.cpp b/src/Interpreters/CrossToInnerJoinVisitor.cpp\nindex 2fcd75b1f23e..b6f977cd9b59 100644\n--- a/src/Interpreters/CrossToInnerJoinVisitor.cpp\n+++ b/src/Interpreters/CrossToInnerJoinVisitor.cpp\n@@ -81,86 +81,6 @@ struct JoinedElement\n     ASTTableJoin * join = nullptr;\n };\n \n-/// Collect all identifiers from ast\n-class IdentifiersCollector\n-{\n-public:\n-    using ASTIdentPtr = const ASTIdentifier *;\n-    using ASTIdentifiers = std::vector<ASTIdentPtr>;\n-    struct Data\n-    {\n-        ASTIdentifiers idents;\n-    };\n-\n-    static void visit(const ASTPtr & node, Data & data)\n-    {\n-        if (const auto * ident = node->as<ASTIdentifier>())\n-            data.idents.push_back(ident);\n-    }\n-\n-    static bool needChildVisit(const ASTPtr &, const ASTPtr &)\n-    {\n-        return true;\n-    }\n-\n-    static ASTIdentifiers collect(const ASTPtr & node)\n-    {\n-        IdentifiersCollector::Data ident_data;\n-        ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);\n-        ident_visitor.visit(node);\n-        return ident_data.idents;\n-    }\n-};\n-\n-/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`\n-void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)\n-{\n-    if (const auto * func = node->as<ASTFunction>(); func && func->name == NameAnd::name)\n-    {\n-        for (const auto & child : func->arguments->children)\n-            collectConjunctions(child, members);\n-        return;\n-    }\n-    members.push_back(node);\n-}\n-\n-std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)\n-{\n-    std::vector<ASTPtr> members;\n-    collectConjunctions(node, members);\n-    return members;\n-}\n-\n-std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)\n-{\n-    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);\n-    if (table_pos)\n-        return table_pos;\n-    return IdentifierSemantic::chooseTableColumnMatch(ident, tables, true);\n-}\n-\n-std::optional<size_t> getIdentsMembership(const ASTPtr ast,\n-                                          const std::vector<TableWithColumnNamesAndTypes> & tables,\n-                                          const Aliases & aliases)\n-{\n-    auto idents = IdentifiersCollector::collect(ast);\n-\n-    std::optional<size_t> result;\n-    for (const auto * ident : idents)\n-    {\n-        /// Moving expressions that use column aliases is not supported.\n-        if (ident->isShort() && aliases.count(ident->shortName()))\n-            return {};\n-        const auto pos = getIdentMembership(*ident, tables);\n-        if (!pos)\n-            return {};\n-        if (result && *pos != *result)\n-            return {};\n-        result = pos;\n-    }\n-    return result;\n-}\n-\n bool isAllowedToRewriteCrossJoin(const ASTPtr & node, const Aliases & aliases)\n {\n     if (node->as<ASTFunction>())\n@@ -193,8 +113,8 @@ std::map<size_t, std::vector<ASTPtr>> moveExpressionToJoinOn(\n \n             /// Check if the identifiers are from different joined tables.\n             /// If it's a self joint, tables should have aliases.\n-            auto left_table_pos = getIdentsMembership(func->arguments->children[0], tables, aliases);\n-            auto right_table_pos = getIdentsMembership(func->arguments->children[1], tables, aliases);\n+            auto left_table_pos = IdentifierSemantic::getIdentsMembership(func->arguments->children[0], tables, aliases);\n+            auto right_table_pos = IdentifierSemantic::getIdentsMembership(func->arguments->children[1], tables, aliases);\n \n             /// Identifiers from different table move to JOIN ON\n             if (left_table_pos && right_table_pos && *left_table_pos != *right_table_pos)\ndiff --git a/src/Interpreters/IdentifierSemantic.cpp b/src/Interpreters/IdentifierSemantic.cpp\nindex a1fc533eb7fa..ff1fbbc8e2da 100644\n--- a/src/Interpreters/IdentifierSemantic.cpp\n+++ b/src/Interpreters/IdentifierSemantic.cpp\n@@ -3,6 +3,8 @@\n #include <Interpreters/IdentifierSemantic.h>\n #include <Interpreters/StorageID.h>\n \n+#include <Parsers/ASTFunction.h>\n+\n namespace DB\n {\n \n@@ -249,4 +251,86 @@ void IdentifierSemantic::setColumnLongName(ASTIdentifier & identifier, const Dat\n     }\n }\n \n+std::optional<size_t> IdentifierSemantic::getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)\n+{\n+    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);\n+    if (table_pos)\n+        return table_pos;\n+    return IdentifierSemantic::chooseTableColumnMatch(ident, tables, true);\n+}\n+\n+std::optional<size_t>\n+IdentifierSemantic::getIdentsMembership(ASTPtr ast, const std::vector<TableWithColumnNamesAndTypes> & tables, const Aliases & aliases)\n+{\n+    auto idents = IdentifiersCollector::collect(ast);\n+\n+    std::optional<size_t> result;\n+    for (const auto * ident : idents)\n+    {\n+        /// short name clashes with alias, ambiguous\n+        if (ident->isShort() && aliases.count(ident->shortName()))\n+            return {};\n+        const auto pos = getIdentMembership(*ident, tables);\n+        if (!pos)\n+            return {};\n+        /// identifiers from different tables\n+        if (result && *pos != *result)\n+            return {};\n+        result = pos;\n+    }\n+    return result;\n+}\n+\n+IdentifiersCollector::ASTIdentifiers IdentifiersCollector::collect(const ASTPtr & node)\n+{\n+    IdentifiersCollector::Data ident_data;\n+    ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);\n+    ident_visitor.visit(node);\n+    return ident_data.idents;\n+}\n+\n+bool IdentifiersCollector::needChildVisit(const ASTPtr &, const ASTPtr &)\n+{\n+    return true;\n+}\n+\n+void IdentifiersCollector::visit(const ASTPtr & node, IdentifiersCollector::Data & data)\n+{\n+    if (const auto * ident = node->as<ASTIdentifier>())\n+        data.idents.push_back(ident);\n+}\n+\n+\n+IdentifierMembershipCollector::IdentifierMembershipCollector(const ASTSelectQuery & select, const Context & context)\n+{\n+    if (ASTPtr with = select.with())\n+        QueryAliasesNoSubqueriesVisitor(aliases).visit(with);\n+    QueryAliasesNoSubqueriesVisitor(aliases).visit(select.select());\n+\n+    tables = getDatabaseAndTablesWithColumns(getTableExpressions(select), context);\n+}\n+\n+std::optional<size_t> IdentifierMembershipCollector::getIdentsMembership(ASTPtr ast) const\n+{\n+    return IdentifierSemantic::getIdentsMembership(ast, tables, aliases);\n+}\n+\n+static void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)\n+{\n+    if (const auto * func = node->as<ASTFunction>(); func && func->name == \"and\")\n+    {\n+        for (const auto & child : func->arguments->children)\n+            collectConjunctions(child, members);\n+        return;\n+    }\n+    members.push_back(node);\n+}\n+\n+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)\n+{\n+    std::vector<ASTPtr> members;\n+    collectConjunctions(node, members);\n+    return members;\n+}\n+\n }\ndiff --git a/src/Interpreters/IdentifierSemantic.h b/src/Interpreters/IdentifierSemantic.h\nindex 80b55ba0537d..9f11d8bdb9d7 100644\n--- a/src/Interpreters/IdentifierSemantic.h\n+++ b/src/Interpreters/IdentifierSemantic.h\n@@ -2,8 +2,15 @@\n \n #include <optional>\n \n-#include <Parsers/ASTIdentifier.h>\n+#include <Interpreters/Aliases.h>\n #include <Interpreters/DatabaseAndTableWithAlias.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <Interpreters/QueryAliasesVisitor.h>\n+#include <Interpreters/getHeaderForProcessingStage.h>\n+#include <Interpreters/getTableExpressions.h>\n+\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTSelectQuery.h>\n \n namespace DB\n {\n@@ -59,9 +66,48 @@ struct IdentifierSemantic\n     static std::optional<size_t> chooseTableColumnMatch(const ASTIdentifier &, const TablesWithColumns & tables,\n                             bool allow_ambiguous = false);\n \n+    static std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables);\n+\n+    /// Collect common table membership for identifiers in expression\n+    /// If membership cannot be established or there are several identifies from different tables, return empty optional\n+    static std::optional<size_t>\n+    getIdentsMembership(ASTPtr ast, const std::vector<TableWithColumnNamesAndTypes> & tables, const Aliases & aliases);\n+\n private:\n     static bool doesIdentifierBelongTo(const ASTIdentifier & identifier, const String & database, const String & table);\n     static bool doesIdentifierBelongTo(const ASTIdentifier & identifier, const String & table);\n };\n \n+\n+/// Collect all identifies from AST recursively\n+class IdentifiersCollector\n+{\n+public:\n+    using ASTIdentPtr = const ASTIdentifier *;\n+    using ASTIdentifiers = std::vector<ASTIdentPtr>;\n+    struct Data\n+    {\n+        ASTIdentifiers idents;\n+    };\n+\n+    static void visit(const ASTPtr & node, Data & data);\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &);\n+    static ASTIdentifiers collect(const ASTPtr & node);\n+};\n+\n+/// Collect identifier table membership considering aliases\n+class IdentifierMembershipCollector\n+{\n+public:\n+    IdentifierMembershipCollector(const ASTSelectQuery & select, const Context & context);\n+    std::optional<size_t> getIdentsMembership(ASTPtr ast) const;\n+\n+private:\n+    std::vector<TableWithColumnNamesAndTypes> tables;\n+    Aliases aliases;\n+};\n+\n+/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`\n+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node);\n+\n }\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex f88fd16045a4..73d7d3d004c8 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -408,7 +408,7 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & sele\n                           const TablesWithColumns & tables, const Aliases & aliases, ASTPtr & new_where_conditions)\n {\n     const ASTTablesInSelectQueryElement * node = select_query.join();\n-    if (!node)\n+    if (!node || tables.size() < 2)\n         return;\n \n     auto & table_join = node->table_join->as<ASTTableJoin &>();\ndiff --git a/src/Interpreters/getHeaderForProcessingStage.cpp b/src/Interpreters/getHeaderForProcessingStage.cpp\nindex b56b90cdf3fb..4de636007e0e 100644\n--- a/src/Interpreters/getHeaderForProcessingStage.cpp\n+++ b/src/Interpreters/getHeaderForProcessingStage.cpp\n@@ -12,21 +12,27 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-/// Rewrite original query removing joined tables from it\n-bool removeJoin(ASTSelectQuery & select)\n+bool hasJoin(const ASTSelectQuery & select)\n {\n     const auto & tables = select.tables();\n     if (!tables || tables->children.size() < 2)\n         return false;\n \n     const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();\n-    if (!joined_table.table_join)\n-        return false;\n+    return joined_table.table_join != nullptr;\n+}\n \n-    /// The most simple temporary solution: leave only the first table in query.\n-    /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n-    tables->children.resize(1);\n-    return true;\n+/// Rewrite original query removing joined tables from it\n+bool removeJoin(ASTSelectQuery & select)\n+{\n+    if (hasJoin(select))\n+    {\n+        /// The most simple temporary solution: leave only the first table in query.\n+        /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n+        select.tables()->children.resize(1);\n+        return true;\n+    }\n+    return false;\n }\n \n Block getHeaderForProcessingStage(\ndiff --git a/src/Interpreters/getHeaderForProcessingStage.h b/src/Interpreters/getHeaderForProcessingStage.h\nindex ec238edf7747..e06d22f6b763 100644\n--- a/src/Interpreters/getHeaderForProcessingStage.h\n+++ b/src/Interpreters/getHeaderForProcessingStage.h\n@@ -14,6 +14,7 @@ struct SelectQueryInfo;\n class Context;\n class ASTSelectQuery;\n \n+bool hasJoin(const ASTSelectQuery & select);\n bool removeJoin(ASTSelectQuery & select);\n \n Block getHeaderForProcessingStage(\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex b8aaa52f92cf..7730ef98c937 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -9,6 +9,7 @@\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/IdentifierSemantic.h>\n #include <Interpreters/getHeaderForProcessingStage.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTLiteral.h>\n@@ -43,12 +44,15 @@ namespace ErrorCodes\n namespace\n {\n \n-void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result)\n+TreeRewriterResult modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result, const Context & context)\n {\n+\n+    TreeRewriterResult new_rewriter_result = rewriter_result;\n     if (removeJoin(select))\n     {\n         /// Also remove GROUP BY cause ExpressionAnalyzer would check if it has all aggregate columns but joined columns would be missed.\n         select.setExpression(ASTSelectQuery::Expression::GROUP_BY, {});\n+        new_rewriter_result.aggregates.clear();\n \n         /// Replace select list to remove joined columns\n         auto select_list = std::make_shared<ASTExpressionList>();\n@@ -57,12 +61,40 @@ void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_r\n \n         select.setExpression(ASTSelectQuery::Expression::SELECT, select_list);\n \n-        /// TODO: keep WHERE/PREWHERE. We have to remove joined columns and their expressions but keep others.\n-        select.setExpression(ASTSelectQuery::Expression::WHERE, {});\n-        select.setExpression(ASTSelectQuery::Expression::PREWHERE, {});\n+        const DB::IdentifierMembershipCollector membership_collector{select, context};\n+\n+        /// Remove unknown identifiers from where, leave only ones from left table\n+        auto replace_where = [&membership_collector](ASTSelectQuery & query, ASTSelectQuery::Expression expr)\n+        {\n+            auto where = query.getExpression(expr, false);\n+            if (!where)\n+                return;\n+\n+            const size_t left_table_pos = 0;\n+            /// Test each argument of `and` function and select ones related to only left table\n+            std::shared_ptr<ASTFunction> new_conj = makeASTFunction(\"and\");\n+            for (const auto & node : collectConjunctions(where))\n+            {\n+                if (membership_collector.getIdentsMembership(node) == left_table_pos)\n+                    new_conj->arguments->children.push_back(std::move(node));\n+            }\n+\n+            if (new_conj->arguments->children.empty())\n+                /// No identifiers from left table\n+                query.setExpression(expr, {});\n+            else if (new_conj->arguments->children.size() == 1)\n+                /// Only one expression, lift from `and`\n+                query.setExpression(expr, std::move(new_conj->arguments->children[0]));\n+            else\n+                /// Set new expression\n+                query.setExpression(expr, std::move(new_conj));\n+        };\n+        replace_where(select,ASTSelectQuery::Expression::WHERE);\n+        replace_where(select,ASTSelectQuery::Expression::PREWHERE);\n         select.setExpression(ASTSelectQuery::Expression::HAVING, {});\n         select.setExpression(ASTSelectQuery::Expression::ORDER_BY, {});\n     }\n+    return new_rewriter_result;\n }\n \n }\n@@ -150,8 +182,6 @@ bool StorageMerge::mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, cons\n \n QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(const Context & context, QueryProcessingStage::Enum to_stage, SelectQueryInfo & query_info) const\n {\n-    ASTPtr modified_query = query_info.query->clone();\n-    auto & modified_select = modified_query->as<ASTSelectQuery &>();\n     /// In case of JOIN the first stage (which includes JOIN)\n     /// should be done on the initiator always.\n     ///\n@@ -159,7 +189,7 @@ QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(const Context &\n     /// (see modifySelect()/removeJoin())\n     ///\n     /// And for this we need to return FetchColumns.\n-    if (removeJoin(modified_select))\n+    if (const auto * select = query_info.query->as<ASTSelectQuery>(); select && hasJoin(*select))\n         return QueryProcessingStage::FetchColumns;\n \n     auto stage_in_source_tables = QueryProcessingStage::FetchColumns;\n@@ -304,7 +334,8 @@ Pipe StorageMerge::createSources(\n \n     /// Original query could contain JOIN but we need only the first joined table and its columns.\n     auto & modified_select = modified_query_info.query->as<ASTSelectQuery &>();\n-    modifySelect(modified_select, *query_info.syntax_analyzer_result);\n+    auto new_analyzer_res = modifySelect(modified_select, *query_info.syntax_analyzer_result, *modified_context);\n+    modified_query_info.syntax_analyzer_result = std::make_shared<TreeRewriterResult>(std::move(new_analyzer_res));\n \n     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, \"_table\", table_name);\n \n@@ -328,7 +359,6 @@ Pipe StorageMerge::createSources(\n         if (real_column_names.empty())\n             real_column_names.push_back(ExpressionActions::getSmallestColumn(metadata_snapshot->getColumns().getAllPhysical()));\n \n-\n         pipe = storage->read(real_column_names, metadata_snapshot, modified_query_info, *modified_context, processed_stage, max_block_size, UInt32(streams_num));\n     }\n     else if (processed_stage > storage_stage)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference\nindex b2c3ea56b7f7..4261ccd8a1f8 100644\n--- a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference\n+++ b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference\n@@ -5,3 +5,5 @@\n 1\n 0\t1\n 0\t1\n+1\t0\n+1\ndiff --git a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql\nindex a6678ca9040e..68b4e7d4015a 100644\n--- a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql\n+++ b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql\n@@ -17,6 +17,9 @@ SELECT ID FROM m INNER JOIN b USING(key) GROUP BY ID;\n SELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 HAVING ID = 1 ORDER BY ID;\n SELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 GROUP BY ID, key HAVING ID = 1 ORDER BY ID;\n \n+SELECT sum(b.ID), sum(m.key) FROM m FULL JOIN b ON (m.key == b.key) GROUP BY key;\n+SELECT sum(b.ID + m.key) FROM m FULL JOIN b ON (m.key == b.key) GROUP BY key;\n+\n DROP TABLE IF EXISTS a;\n DROP TABLE IF EXISTS b;\n DROP TABLE IF EXISTS m;\ndiff --git a/tests/queries/0_stateless/01783_merge_engine_join_key_condition.reference b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.reference\nnew file mode 100644\nindex 000000000000..4068a6e00ddd\n--- /dev/null\n+++ b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.reference\n@@ -0,0 +1,5 @@\n+3\t3\n+1\t4\n+1\t4\n+1\t4\n+1\t4\ndiff --git a/tests/queries/0_stateless/01783_merge_engine_join_key_condition.sql b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.sql\nnew file mode 100644\nindex 000000000000..115ee42fe116\n--- /dev/null\n+++ b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.sql\n@@ -0,0 +1,23 @@\n+DROP TABLE IF EXISTS foo;\n+DROP TABLE IF EXISTS foo_merge;\n+DROP TABLE IF EXISTS t2;\n+\n+CREATE TABLE foo(Id Int32, Val Int32) Engine=MergeTree PARTITION BY Val ORDER BY Id;\n+INSERT INTO foo SELECT number, number%5 FROM numbers(100000);\n+\n+CREATE TABLE foo_merge as foo ENGINE=Merge(currentDatabase(), '^foo');\n+\n+CREATE TABLE t2 (Id Int32, Val Int32, X Int32) Engine=Memory;\n+INSERT INTO t2 values (4, 3, 4);\n+\n+SET force_primary_key = 1;\n+\n+SELECT * FROM foo_merge WHERE Val = 3 AND Id = 3;\n+SELECT count(), X FROM foo_merge JOIN t2 USING Val WHERE Val = 3 AND Id = 3 AND t2.X == 4 GROUP BY X;\n+SELECT count(), X FROM foo_merge JOIN t2 USING Val WHERE Val = 3 AND (Id = 3 AND t2.X == 4) GROUP BY X;\n+SELECT count(), X FROM foo_merge JOIN t2 USING Val WHERE Val = 3 AND Id = 3 GROUP BY X;\n+SELECT count(), X FROM (SELECT * FROM foo_merge) f JOIN t2 USING Val WHERE Val = 3 AND Id = 3 GROUP BY X;\n+\n+DROP TABLE IF EXISTS foo;\n+DROP TABLE IF EXISTS foo_merge;\n+DROP TABLE IF EXISTS t2;\n",
  "problem_statement": "Cannot access the joined table's columns after `GROUP BY` in case first table's engine is Merge\n**Describe the bug**\r\nCannot aggregate data after joining Merge table with MergeTree (with results of subquery execution in our case actually) table. \"DB::Exception: Not found column ...\" error occurs. See details below.\r\n\r\nThere is similar issue #11755 which has been already closed by #16993. Unfortunately that pull request doesn't fix this particular problem. \r\n\r\nWe are using 20.8 LTS. Can we expect that the problem would be fixed in that version (it seems that #16993 hasn't been backported in 20.8 for some reason)?\r\n\r\n\r\n**How to reproduce**\r\nIt was tested on **20.8.5.45** and **20.12.3.3**\r\n\r\nCreate tables an fill data:\r\n```sql\r\nCREATE TABLE test_table (Id Int32, Foo Int32) ENGINE = MergeTree ORDER BY Id;\r\n\r\nCREATE TABLE test_table_merge AS test_table ENGINE = Merge(currentDatabase(), 'test_table');\r\n\r\nINSERT INTO test_table (Id, Foo) VALUES (1, 1);\r\n```\r\n\r\nTests on **20.8.5.45**:\r\n```sql\r\n-- Left table has Merge engine\r\nSELECT any(t2.Foo)\r\nFROM test_table_merge AS t1\r\nLEFT JOIN test_table AS t2 ON t1.Id = t2.Id\r\nGROUP BY t1.Id\r\n\r\n/*\r\nReceived exception from server (version 20.8.5):\r\nCode: 10. DB::Exception: Received from clickhouse-server:9000. DB::Exception: Not found column t2.Foo in block. There are only columns: Id.\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n*/\r\n\r\n-- Left table hasn't Merge engine\r\nSELECT any(t2.Foo)\r\nFROM test_table AS t1\r\nLEFT JOIN test_table AS t2 ON t1.Id = t2.Id\r\nGROUP BY t1.Id\r\n\r\n/*\r\n\u250c\u2500any(t2.Foo)\u2500\u2510\r\n\u2502           1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.016 sec.\r\n*/\r\n```\r\n\r\nTests on **20.12.3.3**:\r\n```sql\r\n-- Left table has Merge engine\r\nSELECT any(t2.Foo)\r\nFROM test_table_merge AS t1\r\nLEFT JOIN test_table AS t2 ON t1.Id = t2.Id\r\nGROUP BY t1.Id\r\n\r\n/*\r\nReceived exception from server (version 20.12.3):\r\nCode: 47. DB::Exception: Received from clickhouse-server:9000. DB::Exception: Unknown identifier (in aggregate function 'any'): t2.Foo.\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n*/\r\n\r\n-- Left table hasn't Merge engine\r\nSELECT any(t2.Foo)\r\nFROM test_table AS t1\r\nLEFT JOIN test_table AS t2 ON t1.Id = t2.Id\r\nGROUP BY t1.Id\r\n\r\n/*\r\n\u250c\u2500any(t2.Foo)\u2500\u2510\r\n\u2502           1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.013 sec.\r\n*/\r\n```\r\n\r\n**Expected behavior**\r\nCan access the joined table's columns after `GROUP BY`.\nEngine Merge with Join does not use partition key / primary key\n20.8.14.4 \r\naffected all versions after https://github.com/ClickHouse/ClickHouse/issues/15228 https://github.com/ClickHouse/ClickHouse/pull/15242\r\n\r\n```sql\r\ncreate table foo(A Int64, V Int64, S String) Engine=MergeTree partition by V order by A;\r\ninsert into foo select number, number%5, '' from numbers(100000);\r\ncreate table foo_merge as foo ENGINE=Merge(currentDatabase(), '^foo');\r\n\r\nselect count(), B from foo_merge join \r\n   (select materialize('') as S, 5 B) x using S \r\nwhere V = 4 \r\ngroup by B\r\n\r\nKey condition: unknown\r\nMinMax index condition: unknown\r\nSelected 5 parts by date, 5 parts by key, 15 marks by primary key, 15 marks to read from 5 ranges\r\n\r\nProcessed 100.00 thousand rows\r\n\r\nselect count(), B from foo_merge join \r\n   (select materialize('') as S, 5 B) x using S \r\nwhere V = 4 and A = 4 \r\ngroup by B \r\n\r\nKey condition: unknown\r\nMinMax index condition: unknown\r\nSelected 5 parts by date, 5 parts by key, 15 marks by primary key, 15 marks to read from 5 ranges\r\n\r\nProcessed 100.00 thousand rows\r\n\r\n```\r\n\r\nwithout merge\r\n```sql\r\nselect count(), B from foo join \r\n   (select materialize('') as S, 5 B) x using S \r\nwhere V = 4 and A = 4 \r\ngroup by B \r\n\r\nKey condition: unknown, (column 0 in [4, 4]), and\r\nMinMax index condition: (column 0 in [4, 4]), unknown, and\r\nSelected 1 parts by date, 1 parts by key, 1 marks by primary key, 1 marks to read from 1 ranges\r\nProcessed 8.19 thousand rows\r\n```\r\n\r\nWA (subquery):\r\n\r\n```sql\r\nselect count(), B from (select * from foo_merge) f join \r\n   (select materialize('') as S, 5 B) x using S \r\nwhere V = 4 and A = 4 \r\ngroup by B \r\n\r\nKey condition: (column 0 in [4, 4]), unknown, and\r\nMinMax index condition: unknown, (column 0 in [4, 4]), and\r\nSelected 1 parts by date, 1 parts by key, 1 marks by primary key, 1 marks to read from 1 ranges\r\nProcessed 8.19 thousand rows\r\n\r\n```\n",
  "hints_text": "19.13.7.57\r\n```\r\n\r\nSELECT any(t2.Foo)\r\nFROM test_table_merge AS t1\r\nLEFT JOIN test_table AS t2 ON t1.Id = t2.Id\r\nGROUP BY t1.Id\r\n\r\n\u250c\u2500any(t2.Foo)\u2500\u2510\r\n\u2502           1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nCould you tell me if there are updates for this issue?\n```\r\nCREATE TABLE test_table (Id Int32, Foo Int32) ENGINE = MergeTree ORDER BY Id;\r\nCREATE TABLE test_table_merge AS test_table ENGINE = Merge(currentDatabase(), 'test_table');\r\nINSERT INTO test_table (Id, Foo) VALUES (1, 1);\r\nSELECT any(t2.Foo) FROM test_table_merge AS t1 LEFT JOIN test_table AS t2 ON t1.Id = t2.Id GROUP BY t1.Id;\r\n``` \r\n\r\n20.3.16.165 and older: pass \r\n20.3.17.173 and newer: fails\r\n\r\nIt's the fix of another bug that introduced the regression, see #13679\r\n\r\nThere were already similar regression reported in #15228 , and fixed in #15242\r\n\r\nBut that is different (column is used inside agg function) and happens on all versions since 20.3.17 to the current master (21.3).\n@vdimir ^^\n",
  "created_at": "2021-03-02T12:32:09Z",
  "modified_files": [
    "src/Interpreters/CrossToInnerJoinVisitor.cpp",
    "src/Interpreters/IdentifierSemantic.cpp",
    "src/Interpreters/IdentifierSemantic.h",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/getHeaderForProcessingStage.cpp",
    "src/Interpreters/getHeaderForProcessingStage.h",
    "src/Storages/StorageMerge.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference",
    "tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql",
    "b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.reference",
    "b/tests/queries/0_stateless/01783_merge_engine_join_key_condition.sql"
  ]
}