diff --git a/src/Interpreters/CrossToInnerJoinVisitor.cpp b/src/Interpreters/CrossToInnerJoinVisitor.cpp
index 2fcd75b1f23e..b6f977cd9b59 100644
--- a/src/Interpreters/CrossToInnerJoinVisitor.cpp
+++ b/src/Interpreters/CrossToInnerJoinVisitor.cpp
@@ -81,86 +81,6 @@ struct JoinedElement
     ASTTableJoin * join = nullptr;
 };
 
-/// Collect all identifiers from ast
-class IdentifiersCollector
-{
-public:
-    using ASTIdentPtr = const ASTIdentifier *;
-    using ASTIdentifiers = std::vector<ASTIdentPtr>;
-    struct Data
-    {
-        ASTIdentifiers idents;
-    };
-
-    static void visit(const ASTPtr & node, Data & data)
-    {
-        if (const auto * ident = node->as<ASTIdentifier>())
-            data.idents.push_back(ident);
-    }
-
-    static bool needChildVisit(const ASTPtr &, const ASTPtr &)
-    {
-        return true;
-    }
-
-    static ASTIdentifiers collect(const ASTPtr & node)
-    {
-        IdentifiersCollector::Data ident_data;
-        ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);
-        ident_visitor.visit(node);
-        return ident_data.idents;
-    }
-};
-
-/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`
-void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)
-{
-    if (const auto * func = node->as<ASTFunction>(); func && func->name == NameAnd::name)
-    {
-        for (const auto & child : func->arguments->children)
-            collectConjunctions(child, members);
-        return;
-    }
-    members.push_back(node);
-}
-
-std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)
-{
-    std::vector<ASTPtr> members;
-    collectConjunctions(node, members);
-    return members;
-}
-
-std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)
-{
-    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);
-    if (table_pos)
-        return table_pos;
-    return IdentifierSemantic::chooseTableColumnMatch(ident, tables, true);
-}
-
-std::optional<size_t> getIdentsMembership(const ASTPtr ast,
-                                          const std::vector<TableWithColumnNamesAndTypes> & tables,
-                                          const Aliases & aliases)
-{
-    auto idents = IdentifiersCollector::collect(ast);
-
-    std::optional<size_t> result;
-    for (const auto * ident : idents)
-    {
-        /// Moving expressions that use column aliases is not supported.
-        if (ident->isShort() && aliases.count(ident->shortName()))
-            return {};
-        const auto pos = getIdentMembership(*ident, tables);
-        if (!pos)
-            return {};
-        if (result && *pos != *result)
-            return {};
-        result = pos;
-    }
-    return result;
-}
-
 bool isAllowedToRewriteCrossJoin(const ASTPtr & node, const Aliases & aliases)
 {
     if (node->as<ASTFunction>())
@@ -193,8 +113,8 @@ std::map<size_t, std::vector<ASTPtr>> moveExpressionToJoinOn(
 
             /// Check if the identifiers are from different joined tables.
             /// If it's a self joint, tables should have aliases.
-            auto left_table_pos = getIdentsMembership(func->arguments->children[0], tables, aliases);
-            auto right_table_pos = getIdentsMembership(func->arguments->children[1], tables, aliases);
+            auto left_table_pos = IdentifierSemantic::getIdentsMembership(func->arguments->children[0], tables, aliases);
+            auto right_table_pos = IdentifierSemantic::getIdentsMembership(func->arguments->children[1], tables, aliases);
 
             /// Identifiers from different table move to JOIN ON
             if (left_table_pos && right_table_pos && *left_table_pos != *right_table_pos)
diff --git a/src/Interpreters/IdentifierSemantic.cpp b/src/Interpreters/IdentifierSemantic.cpp
index a1fc533eb7fa..ff1fbbc8e2da 100644
--- a/src/Interpreters/IdentifierSemantic.cpp
+++ b/src/Interpreters/IdentifierSemantic.cpp
@@ -3,6 +3,8 @@
 #include <Interpreters/IdentifierSemantic.h>
 #include <Interpreters/StorageID.h>
 
+#include <Parsers/ASTFunction.h>
+
 namespace DB
 {
 
@@ -249,4 +251,86 @@ void IdentifierSemantic::setColumnLongName(ASTIdentifier & identifier, const Dat
     }
 }
 
+std::optional<size_t> IdentifierSemantic::getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)
+{
+    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);
+    if (table_pos)
+        return table_pos;
+    return IdentifierSemantic::chooseTableColumnMatch(ident, tables, true);
+}
+
+std::optional<size_t>
+IdentifierSemantic::getIdentsMembership(ASTPtr ast, const std::vector<TableWithColumnNamesAndTypes> & tables, const Aliases & aliases)
+{
+    auto idents = IdentifiersCollector::collect(ast);
+
+    std::optional<size_t> result;
+    for (const auto * ident : idents)
+    {
+        /// short name clashes with alias, ambiguous
+        if (ident->isShort() && aliases.count(ident->shortName()))
+            return {};
+        const auto pos = getIdentMembership(*ident, tables);
+        if (!pos)
+            return {};
+        /// identifiers from different tables
+        if (result && *pos != *result)
+            return {};
+        result = pos;
+    }
+    return result;
+}
+
+IdentifiersCollector::ASTIdentifiers IdentifiersCollector::collect(const ASTPtr & node)
+{
+    IdentifiersCollector::Data ident_data;
+    ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);
+    ident_visitor.visit(node);
+    return ident_data.idents;
+}
+
+bool IdentifiersCollector::needChildVisit(const ASTPtr &, const ASTPtr &)
+{
+    return true;
+}
+
+void IdentifiersCollector::visit(const ASTPtr & node, IdentifiersCollector::Data & data)
+{
+    if (const auto * ident = node->as<ASTIdentifier>())
+        data.idents.push_back(ident);
+}
+
+
+IdentifierMembershipCollector::IdentifierMembershipCollector(const ASTSelectQuery & select, const Context & context)
+{
+    if (ASTPtr with = select.with())
+        QueryAliasesNoSubqueriesVisitor(aliases).visit(with);
+    QueryAliasesNoSubqueriesVisitor(aliases).visit(select.select());
+
+    tables = getDatabaseAndTablesWithColumns(getTableExpressions(select), context);
+}
+
+std::optional<size_t> IdentifierMembershipCollector::getIdentsMembership(ASTPtr ast) const
+{
+    return IdentifierSemantic::getIdentsMembership(ast, tables, aliases);
+}
+
+static void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)
+{
+    if (const auto * func = node->as<ASTFunction>(); func && func->name == "and")
+    {
+        for (const auto & child : func->arguments->children)
+            collectConjunctions(child, members);
+        return;
+    }
+    members.push_back(node);
+}
+
+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)
+{
+    std::vector<ASTPtr> members;
+    collectConjunctions(node, members);
+    return members;
+}
+
 }
diff --git a/src/Interpreters/IdentifierSemantic.h b/src/Interpreters/IdentifierSemantic.h
index 80b55ba0537d..9f11d8bdb9d7 100644
--- a/src/Interpreters/IdentifierSemantic.h
+++ b/src/Interpreters/IdentifierSemantic.h
@@ -2,8 +2,15 @@
 
 #include <optional>
 
-#include <Parsers/ASTIdentifier.h>
+#include <Interpreters/Aliases.h>
 #include <Interpreters/DatabaseAndTableWithAlias.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+#include <Interpreters/QueryAliasesVisitor.h>
+#include <Interpreters/getHeaderForProcessingStage.h>
+#include <Interpreters/getTableExpressions.h>
+
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTSelectQuery.h>
 
 namespace DB
 {
@@ -59,9 +66,48 @@ struct IdentifierSemantic
     static std::optional<size_t> chooseTableColumnMatch(const ASTIdentifier &, const TablesWithColumns & tables,
                             bool allow_ambiguous = false);
 
+    static std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables);
+
+    /// Collect common table membership for identifiers in expression
+    /// If membership cannot be established or there are several identifies from different tables, return empty optional
+    static std::optional<size_t>
+    getIdentsMembership(ASTPtr ast, const std::vector<TableWithColumnNamesAndTypes> & tables, const Aliases & aliases);
+
 private:
     static bool doesIdentifierBelongTo(const ASTIdentifier & identifier, const String & database, const String & table);
     static bool doesIdentifierBelongTo(const ASTIdentifier & identifier, const String & table);
 };
 
+
+/// Collect all identifies from AST recursively
+class IdentifiersCollector
+{
+public:
+    using ASTIdentPtr = const ASTIdentifier *;
+    using ASTIdentifiers = std::vector<ASTIdentPtr>;
+    struct Data
+    {
+        ASTIdentifiers idents;
+    };
+
+    static void visit(const ASTPtr & node, Data & data);
+    static bool needChildVisit(const ASTPtr &, const ASTPtr &);
+    static ASTIdentifiers collect(const ASTPtr & node);
+};
+
+/// Collect identifier table membership considering aliases
+class IdentifierMembershipCollector
+{
+public:
+    IdentifierMembershipCollector(const ASTSelectQuery & select, const Context & context);
+    std::optional<size_t> getIdentsMembership(ASTPtr ast) const;
+
+private:
+    std::vector<TableWithColumnNamesAndTypes> tables;
+    Aliases aliases;
+};
+
+/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`
+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node);
+
 }
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index f88fd16045a4..73d7d3d004c8 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -408,7 +408,7 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & sele
                           const TablesWithColumns & tables, const Aliases & aliases, ASTPtr & new_where_conditions)
 {
     const ASTTablesInSelectQueryElement * node = select_query.join();
-    if (!node)
+    if (!node || tables.size() < 2)
         return;
 
     auto & table_join = node->table_join->as<ASTTableJoin &>();
diff --git a/src/Interpreters/getHeaderForProcessingStage.cpp b/src/Interpreters/getHeaderForProcessingStage.cpp
index b56b90cdf3fb..4de636007e0e 100644
--- a/src/Interpreters/getHeaderForProcessingStage.cpp
+++ b/src/Interpreters/getHeaderForProcessingStage.cpp
@@ -12,21 +12,27 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
-/// Rewrite original query removing joined tables from it
-bool removeJoin(ASTSelectQuery & select)
+bool hasJoin(const ASTSelectQuery & select)
 {
     const auto & tables = select.tables();
     if (!tables || tables->children.size() < 2)
         return false;
 
     const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();
-    if (!joined_table.table_join)
-        return false;
+    return joined_table.table_join != nullptr;
+}
 
-    /// The most simple temporary solution: leave only the first table in query.
-    /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).
-    tables->children.resize(1);
-    return true;
+/// Rewrite original query removing joined tables from it
+bool removeJoin(ASTSelectQuery & select)
+{
+    if (hasJoin(select))
+    {
+        /// The most simple temporary solution: leave only the first table in query.
+        /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).
+        select.tables()->children.resize(1);
+        return true;
+    }
+    return false;
 }
 
 Block getHeaderForProcessingStage(
diff --git a/src/Interpreters/getHeaderForProcessingStage.h b/src/Interpreters/getHeaderForProcessingStage.h
index ec238edf7747..e06d22f6b763 100644
--- a/src/Interpreters/getHeaderForProcessingStage.h
+++ b/src/Interpreters/getHeaderForProcessingStage.h
@@ -14,6 +14,7 @@ struct SelectQueryInfo;
 class Context;
 class ASTSelectQuery;
 
+bool hasJoin(const ASTSelectQuery & select);
 bool removeJoin(ASTSelectQuery & select);
 
 Block getHeaderForProcessingStage(
diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index b8aaa52f92cf..7730ef98c937 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -9,6 +9,7 @@
 #include <Interpreters/ExpressionActions.h>
 #include <Interpreters/evaluateConstantExpression.h>
 #include <Interpreters/InterpreterSelectQuery.h>
+#include <Interpreters/IdentifierSemantic.h>
 #include <Interpreters/getHeaderForProcessingStage.h>
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/ASTLiteral.h>
@@ -43,12 +44,15 @@ namespace ErrorCodes
 namespace
 {
 
-void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result)
+TreeRewriterResult modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result, const Context & context)
 {
+
+    TreeRewriterResult new_rewriter_result = rewriter_result;
     if (removeJoin(select))
     {
         /// Also remove GROUP BY cause ExpressionAnalyzer would check if it has all aggregate columns but joined columns would be missed.
         select.setExpression(ASTSelectQuery::Expression::GROUP_BY, {});
+        new_rewriter_result.aggregates.clear();
 
         /// Replace select list to remove joined columns
         auto select_list = std::make_shared<ASTExpressionList>();
@@ -57,12 +61,40 @@ void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_r
 
         select.setExpression(ASTSelectQuery::Expression::SELECT, select_list);
 
-        /// TODO: keep WHERE/PREWHERE. We have to remove joined columns and their expressions but keep others.
-        select.setExpression(ASTSelectQuery::Expression::WHERE, {});
-        select.setExpression(ASTSelectQuery::Expression::PREWHERE, {});
+        const DB::IdentifierMembershipCollector membership_collector{select, context};
+
+        /// Remove unknown identifiers from where, leave only ones from left table
+        auto replace_where = [&membership_collector](ASTSelectQuery & query, ASTSelectQuery::Expression expr)
+        {
+            auto where = query.getExpression(expr, false);
+            if (!where)
+                return;
+
+            const size_t left_table_pos = 0;
+            /// Test each argument of `and` function and select ones related to only left table
+            std::shared_ptr<ASTFunction> new_conj = makeASTFunction("and");
+            for (const auto & node : collectConjunctions(where))
+            {
+                if (membership_collector.getIdentsMembership(node) == left_table_pos)
+                    new_conj->arguments->children.push_back(std::move(node));
+            }
+
+            if (new_conj->arguments->children.empty())
+                /// No identifiers from left table
+                query.setExpression(expr, {});
+            else if (new_conj->arguments->children.size() == 1)
+                /// Only one expression, lift from `and`
+                query.setExpression(expr, std::move(new_conj->arguments->children[0]));
+            else
+                /// Set new expression
+                query.setExpression(expr, std::move(new_conj));
+        };
+        replace_where(select,ASTSelectQuery::Expression::WHERE);
+        replace_where(select,ASTSelectQuery::Expression::PREWHERE);
         select.setExpression(ASTSelectQuery::Expression::HAVING, {});
         select.setExpression(ASTSelectQuery::Expression::ORDER_BY, {});
     }
+    return new_rewriter_result;
 }
 
 }
@@ -150,8 +182,6 @@ bool StorageMerge::mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, cons
 
 QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(const Context & context, QueryProcessingStage::Enum to_stage, SelectQueryInfo & query_info) const
 {
-    ASTPtr modified_query = query_info.query->clone();
-    auto & modified_select = modified_query->as<ASTSelectQuery &>();
     /// In case of JOIN the first stage (which includes JOIN)
     /// should be done on the initiator always.
     ///
@@ -159,7 +189,7 @@ QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(const Context &
     /// (see modifySelect()/removeJoin())
     ///
     /// And for this we need to return FetchColumns.
-    if (removeJoin(modified_select))
+    if (const auto * select = query_info.query->as<ASTSelectQuery>(); select && hasJoin(*select))
         return QueryProcessingStage::FetchColumns;
 
     auto stage_in_source_tables = QueryProcessingStage::FetchColumns;
@@ -304,7 +334,8 @@ Pipe StorageMerge::createSources(
 
     /// Original query could contain JOIN but we need only the first joined table and its columns.
     auto & modified_select = modified_query_info.query->as<ASTSelectQuery &>();
-    modifySelect(modified_select, *query_info.syntax_analyzer_result);
+    auto new_analyzer_res = modifySelect(modified_select, *query_info.syntax_analyzer_result, *modified_context);
+    modified_query_info.syntax_analyzer_result = std::make_shared<TreeRewriterResult>(std::move(new_analyzer_res));
 
     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, "_table", table_name);
 
@@ -328,7 +359,6 @@ Pipe StorageMerge::createSources(
         if (real_column_names.empty())
             real_column_names.push_back(ExpressionActions::getSmallestColumn(metadata_snapshot->getColumns().getAllPhysical()));
 
-
         pipe = storage->read(real_column_names, metadata_snapshot, modified_query_info, *modified_context, processed_stage, max_block_size, UInt32(streams_num));
     }
     else if (processed_stage > storage_stage)
