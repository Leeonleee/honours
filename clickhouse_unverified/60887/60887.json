{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60887,
  "instance_id": "ClickHouse__ClickHouse-60887",
  "issue_numbers": [
    "60884"
  ],
  "base_commit": "da365ef84d21115d95ce91b2ed36652e46733212",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex b4313d9af561..f80bf1e4e3e3 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -1006,6 +1006,7 @@ class IColumn;\n     M(Bool, input_format_tsv_empty_as_default, false, \"Treat empty fields in TSV input as default values.\", 0) \\\n     M(Bool, input_format_tsv_enum_as_number, false, \"Treat inserted enum values in TSV formats as enum indices.\", 0) \\\n     M(Bool, input_format_null_as_default, true, \"Initialize null fields with default values if the data type of this field is not nullable and it is supported by the input format\", 0) \\\n+    M(Bool, input_format_force_null_for_omitted_fields, false, \"Force initialize omitted fields with null values\", 0) \\\n     M(Bool, input_format_arrow_case_insensitive_column_matching, false, \"Ignore case when matching Arrow columns with CH columns.\", 0) \\\n     M(Int64, input_format_orc_row_batch_size, 100'000, \"Batch size when reading ORC stripes.\", 0) \\\n     M(Bool, input_format_orc_case_insensitive_column_matching, false, \"Ignore case when matching ORC columns with CH columns.\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex cd1cd341c294..5ea99aa01920 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -91,6 +91,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n               {\"cross_join_min_rows_to_compress\", 0, 10000000, \"A new setting.\"},\n               {\"cross_join_min_bytes_to_compress\", 0, 1_GiB, \"A new setting.\"},\n               {\"prefer_external_sort_block_bytes\", 0, DEFAULT_BLOCK_SIZE * 256, \"Prefer maximum block bytes for external sort, reduce the memory usage during merging.\"},\n+              {\"input_format_force_null_for_omitted_fields\", false, false, \"Disable type-defaults for omitted fields when needed\"},\n               }},\n     {\"24.4\", {{\"input_format_json_throw_on_bad_escape_sequence\", true, true, \"Allow to save JSON strings with bad escape sequences\"},\n               {\"max_parsing_threads\", 0, 0, \"Add a separate setting to control number of threads in parallel parsing from files\"},\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex b7e9899da46d..3199445864d9 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -146,6 +146,7 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se\n     format_settings.json.throw_on_bad_escape_sequence = settings.input_format_json_throw_on_bad_escape_sequence;\n     format_settings.json.ignore_unnecessary_fields = settings.input_format_json_ignore_unnecessary_fields;\n     format_settings.null_as_default = settings.input_format_null_as_default;\n+    format_settings.force_null_for_omitted_fields = settings.input_format_force_null_for_omitted_fields;\n     format_settings.decimal_trailing_zeros = settings.output_format_decimal_trailing_zeros;\n     format_settings.parquet.row_group_rows = settings.output_format_parquet_row_group_size;\n     format_settings.parquet.row_group_bytes = settings.output_format_parquet_row_group_size_bytes;\ndiff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h\nindex da225a39ec9b..83b5c5342973 100644\n--- a/src/Formats/FormatSettings.h\n+++ b/src/Formats/FormatSettings.h\n@@ -32,6 +32,7 @@ struct FormatSettings\n     bool write_statistics = true;\n     bool import_nested_json = false;\n     bool null_as_default = true;\n+    bool force_null_for_omitted_fields = false;\n     bool decimal_trailing_zeros = false;\n     bool defaults_for_omitted_fields = true;\n     bool is_writing_to_terminal = false;\ndiff --git a/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp b/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp\nindex 340bcc8aae5c..6a3475a1830b 100644\n--- a/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp\n@@ -39,6 +39,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n     extern const int TOO_LARGE_STRING_SIZE;\n     extern const int UNKNOWN_TYPE;\n+    extern const int TYPE_MISMATCH;\n }\n \n namespace\n@@ -820,7 +821,13 @@ bool BSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi\n     /// Fill non-visited columns with the default values.\n     for (size_t i = 0; i < num_columns; ++i)\n         if (!seen_columns[i])\n-            header.getByPosition(i).type->insertDefaultInto(*columns[i]);\n+        {\n+            const auto & type = header.getByPosition(i).type;\n+            if (format_settings.force_null_for_omitted_fields && !isNullableOrLowCardinalityNullable(type))\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot insert NULL value into a column of type '{}' at index {}\", type->getName(), i);\n+            else\n+                type->insertDefaultInto(*columns[i]);\n+        }\n \n     if (format_settings.defaults_for_omitted_fields)\n         ext.read_columns = read_columns;\ndiff --git a/src/Processors/Formats/Impl/JSONColumnsBlockInputFormatBase.cpp b/src/Processors/Formats/Impl/JSONColumnsBlockInputFormatBase.cpp\nindex faa4f36bbb04..e61e55efc8e4 100644\n--- a/src/Processors/Formats/Impl/JSONColumnsBlockInputFormatBase.cpp\n+++ b/src/Processors/Formats/Impl/JSONColumnsBlockInputFormatBase.cpp\n@@ -13,6 +13,7 @@ namespace ErrorCodes\n {\n     extern const int INCORRECT_DATA;\n     extern const int EMPTY_DATA_PASSED;\n+    extern const int TYPE_MISMATCH;\n }\n \n \n@@ -194,6 +195,8 @@ Chunk JSONColumnsBlockInputFormatBase::read()\n     {\n         if (!seen_columns[i])\n         {\n+            if (format_settings.force_null_for_omitted_fields && !isNullableOrLowCardinalityNullable(fields[i].type))\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot insert NULL value into a column `{}` of type '{}'\", fields[i].name, fields[i].type->getName());\n             columns[i]->insertManyDefaults(rows);\n             if (format_settings.defaults_for_omitted_fields)\n                 block_missing_values.setBits(i, rows);\ndiff --git a/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp b/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\nindex a78d8d016cd9..8855a1bc28d7 100644\n--- a/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n@@ -18,6 +18,7 @@ namespace ErrorCodes\n     extern const int INCORRECT_DATA;\n     extern const int CANNOT_READ_ALL_DATA;\n     extern const int LOGICAL_ERROR;\n+    extern const int TYPE_MISMATCH;\n }\n \n namespace\n@@ -233,7 +234,14 @@ bool JSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi\n     /// Fill non-visited columns with the default values.\n     for (size_t i = 0; i < num_columns; ++i)\n         if (!seen_columns[i])\n-            header.getByPosition(i).type->insertDefaultInto(*columns[i]);\n+        {\n+            const auto & type = header.getByPosition(i).type;\n+            if (format_settings.force_null_for_omitted_fields && !isNullableOrLowCardinalityNullable(type))\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot insert NULL value into a column `{}` of type '{}'\", columnName(i), type->getName());\n+            else\n+                type->insertDefaultInto(*columns[i]);\n+        }\n+\n \n     /// Return info about defaults set.\n     /// If defaults_for_omitted_fields is set to 0, we should just leave already inserted defaults.\ndiff --git a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\nindex 29bc0012dc0a..5382527fcdcc 100644\n--- a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n@@ -15,6 +15,7 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_ESCAPE_SEQUENCE;\n     extern const int CANNOT_READ_ALL_DATA;\n     extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n+    extern const int TYPE_MISMATCH;\n }\n \n \n@@ -190,7 +191,16 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n     /// Fill in the not met columns with default values.\n     for (size_t i = 0; i < num_columns; ++i)\n         if (!seen_columns[i])\n-            header.getByPosition(i).type->insertDefaultInto(*columns[i]);\n+        {\n+            const auto & type = header.getByPosition(i).type;\n+            if (format_settings.force_null_for_omitted_fields && !isNullableOrLowCardinalityNullable(type))\n+                throw Exception(\n+                    ErrorCodes::TYPE_MISMATCH,\n+                    \"Cannot insert NULL value into a column `{}` of type '{}'\",\n+                    header.getByPosition(i).name,\n+                    type->getName());\n+            type->insertDefaultInto(*columns[i]);\n+        }\n \n     /// return info about defaults set\n     if (format_settings.defaults_for_omitted_fields)\ndiff --git a/src/Processors/Formats/RowInputFormatWithNamesAndTypes.cpp b/src/Processors/Formats/RowInputFormatWithNamesAndTypes.cpp\nindex 2ad6a825c8fb..ae30d741c2f6 100644\n--- a/src/Processors/Formats/RowInputFormatWithNamesAndTypes.cpp\n+++ b/src/Processors/Formats/RowInputFormatWithNamesAndTypes.cpp\n@@ -18,6 +18,7 @@ namespace ErrorCodes\n {\n     extern const int INCORRECT_DATA;\n     extern const int LOGICAL_ERROR;\n+    extern const int TYPE_MISMATCH;\n }\n \n namespace\n@@ -124,6 +125,17 @@ void RowInputFormatWithNamesAndTypes::readPrefix()\n             }\n         }\n     }\n+\n+    if (format_settings.force_null_for_omitted_fields)\n+    {\n+        for (auto index : column_mapping->not_presented_columns)\n+            if (!isNullableOrLowCardinalityNullable(data_types[index]))\n+                throw Exception(\n+                    ErrorCodes::TYPE_MISMATCH,\n+                    \"Cannot insert NULL value into a column type '{}' at index {}\",\n+                    data_types[index]->getName(),\n+                    index);\n+    }\n }\n \n void RowInputFormatWithNamesAndTypes::tryDetectHeader(std::vector<String> & column_names_out, std::vector<String> & type_names_out)\n@@ -217,7 +229,15 @@ bool RowInputFormatWithNamesAndTypes::readRow(MutableColumns & columns, RowReadE\n             {\n                 const auto & rem_column_index = column_mapping->column_indexes_for_input_fields[file_column];\n                 if (rem_column_index)\n+                {\n+                    if (format_settings.force_null_for_omitted_fields && !isNullableOrLowCardinalityNullable(data_types[*rem_column_index]))\n+                        throw Exception(\n+                            ErrorCodes::TYPE_MISMATCH,\n+                            \"Cannot insert NULL value into a column type '{}' at index {}\",\n+                            data_types[*rem_column_index]->getName(),\n+                            *rem_column_index);\n                     columns[*rem_column_index]->insertDefault();\n+                }\n                 ++file_column;\n             }\n             break;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03004_force_null_for_omitted.reference b/tests/queries/0_stateless/03004_force_null_for_omitted.reference\nnew file mode 100644\nindex 000000000000..a4c928aae8cb\n--- /dev/null\n+++ b/tests/queries/0_stateless/03004_force_null_for_omitted.reference\n@@ -0,0 +1,44 @@\n+0\t0\n+0\t0\n+2\t0\n+0\t0\n+4\t0\n+0\t\\N\n+0\t\\N\n+2\t\\N\n+0\t\\N\n+4\t\\N\n+0\t\\N\n+0\t\\N\n+2\t\\N\n+0\t\\N\n+4\t\\N\n+0\t\\N\n+0\t\\N\n+2\t\\N\n+0\t\\N\n+4\t\\N\n+0\t\\N\n+0\t\\N\n+2\t\\N\n+0\t\\N\n+4\t\\N\n+0\n+0\t\\N\n+1\t\\N\n+1\t\\N\n+1\t\\N\n+1\t\\N\n+1\t0\n+1\t\\N\n+1\t\\N\n+1\t2\n+3\t0\n+1\t0\n+1\t\\N\n+1\t\\N\n+1\t2\n+3\t0\n+1\t0\n+1\t\\N\n+1\t\\N\ndiff --git a/tests/queries/0_stateless/03004_force_null_for_omitted.sql b/tests/queries/0_stateless/03004_force_null_for_omitted.sql\nnew file mode 100644\nindex 000000000000..43ba2568acb7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03004_force_null_for_omitted.sql\n@@ -0,0 +1,36 @@\n+set allow_suspicious_low_cardinality_types = 1;\n+insert into function file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null Nullable(UInt32)') select number % 2 ? NULL : number from numbers(5) settings engine_file_truncate_on_insert=1;\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo UInt32');\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo UInt32') settings input_format_force_null_for_omitted_fields = 1; -- { serverError TYPE_MISMATCH }\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo Nullable(UInt32)');\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo Nullable(UInt32)') settings input_format_force_null_for_omitted_fields = 1;\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo LowCardinality(Nullable(UInt32))');\n+select * from file(concat(currentDatabase(), '.03004_data.bsonEachRow'), auto, 'null UInt32, foo LowCardinality(Nullable(UInt32))') settings input_format_force_null_for_omitted_fields = 1;\n+\n+select * from format(JSONEachRow, 'foo UInt32', '{}');\n+select * from format(JSONEachRow, 'foo UInt32', '{}') settings input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+select * from format(JSONEachRow, 'foo UInt32, bar Nullable(UInt32)', '{}');\n+select * from format(JSONEachRow, 'foo UInt32, bar Nullable(UInt32)', '{\\\"foo\\\":1}');\n+select * from format(JSONEachRow, 'foo UInt32, bar Nullable(UInt32)', '{}') settings input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+select * from format(JSONEachRow, 'foo UInt32, bar Nullable(UInt32)', '{\\\"foo\\\":1}') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(JSONEachRow, 'foo UInt32, bar LowCardinality(Nullable(UInt32))', '{\\\"foo\\\":1}');\n+select * from format(JSONEachRow, 'foo UInt32, bar LowCardinality(Nullable(UInt32))', '{\\\"foo\\\":1}') settings input_format_force_null_for_omitted_fields = 1;\n+\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\nUInt32\\n1');\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar Nullable(UInt32)', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar LowCardinality(Nullable(UInt32))', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo,bar\\nUInt32,UInt32\\n1,2\\n3\\n') settings input_format_csv_allow_variable_number_of_columns = 1;\n+select * from format(CSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo,bar\\nUInt32,UInt32\\n1,2\\n3\\n') settings input_format_csv_allow_variable_number_of_columns = 1, input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\nUInt32\\n1');\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar Nullable(UInt32)', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar LowCardinality(Nullable(UInt32))', 'foo\\nUInt32\\n1') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\tbar\\nUInt32\\tUInt32\\n1\\t2\\n3\\n') settings input_format_tsv_allow_variable_number_of_columns = 1;\n+select * from format(TSVWithNamesAndTypes, 'foo UInt32, bar UInt32', 'foo\\tbar\\nUInt32\\tUInt32\\n1\\t2\\n3\\n') settings input_format_tsv_allow_variable_number_of_columns = 1, input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+\n+select * from format(TSKV, 'foo UInt32, bar UInt32', 'foo=1\\n');\n+select * from format(TSKV, 'foo UInt32, bar UInt32', 'foo=1\\n') settings input_format_force_null_for_omitted_fields = 1;  -- { serverError TYPE_MISMATCH }\n+select * from format(TSKV, 'foo UInt32, bar Nullable(UInt32)', 'foo=1\\n') settings input_format_force_null_for_omitted_fields = 1;\n+select * from format(TSKV, 'foo UInt32, bar LowCardinality(Nullable(UInt32))', 'foo=1\\n') settings input_format_force_null_for_omitted_fields = 1;\n",
  "problem_statement": "there is no way to invalidate wrong input data for omitted fields in \"row\" formats\nExample:\r\n```\r\nCREATE TABLE t1 (ts DateTime, value String) engine = Memory()\r\nINSERT INTO t1 SETTINGS input_format_null_as_default = 0 FORMAT JSONEachRow {\"value\":\"foo\"}\r\nSELECT * FROM t1\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500value\u2500\u2510\r\n\u2502 1969-12-31 19:00:00 \u2502 foo   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\nI really don't think that inserting a default when the data was not present at the ingested row is optimal.\r\nFor example in most use cases where people who send data to ClickHouse are not the same as who manages the database the errors will be made and data will be FUBAR completely for no reason.\r\nMoreover there is currently no way to prevent a \"default\" to be inserted in an omitted field.\r\nEven constraints will not help, as we cannot differentiate between valid and invalid input at constraint check time.\r\n\r\nThere are issues which confused the users already #33113 https://github.com/ClickHouse/clickhouse-java/issues/1355\r\n\r\nI propose to add another input setting for `JSONEachRow`, `BSONEachRow` and `Values` formats: `input_format_force_null_for_omitted_fields`\r\nWhich will fail to insert into a non-nullable column if flied is omitted\r\n\r\nThis will fail:\r\n```\r\nCREATE TABLE t1 (ts DateTime, value String) engine = Memory()\r\nINSERT INTO t1 SETTINGS input_format_force_null_for_omitted_fields = 1 FORMAT JSONEachRow {\"value\":\"foo\"}\r\n```\r\nThis will succeed:\r\n```\r\nCREATE TABLE t1 (Nullabe(ts) DateTime, value String) engine = Memory()\r\nINSERT INTO t1 SETTINGS input_format_force_null_for_omitted_fields = 1 FORMAT JSONEachRow {\"value\":\"foo\"}\r\n```\r\nPR is essentially ready, will add it soon.\n",
  "hints_text": "",
  "created_at": "2024-03-05T19:31:27Z"
}