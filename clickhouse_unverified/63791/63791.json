{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63791,
  "instance_id": "ClickHouse__ClickHouse-63791",
  "issue_numbers": [
    "63320"
  ],
  "base_commit": "53383396a3bf90c189b1c71e7d37d39868d28f8c",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex b50b132978e0..ef3224c45d24 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -769,6 +769,7 @@ struct IdentifierResolveScope\n \n     /// Nodes with duplicated aliases\n     std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;\n+    std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;\n \n     /// Current scope expression in resolve process stack\n     ExpressionsStack expressions_in_resolve_process_stack;\n@@ -1031,6 +1032,14 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress\n         return true;\n     }\n private:\n+    void addDuplicatingAlias(const QueryTreeNodePtr & node)\n+    {\n+        scope.nodes_with_duplicated_aliases.emplace(node);\n+        auto cloned_node = node->clone();\n+        scope.cloned_nodes_with_duplicated_aliases.emplace_back(cloned_node);\n+        scope.nodes_with_duplicated_aliases.emplace(cloned_node);\n+    }\n+\n     void updateAliasesIfNeeded(const QueryTreeNodePtr & node, bool is_lambda_node)\n     {\n         if (!node->hasAlias())\n@@ -1045,21 +1054,21 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress\n         if (is_lambda_node)\n         {\n             if (scope.alias_name_to_expression_node->contains(alias))\n-                scope.nodes_with_duplicated_aliases.insert(node);\n+                addDuplicatingAlias(node);\n \n             auto [_, inserted] = scope.alias_name_to_lambda_node.insert(std::make_pair(alias, node));\n             if (!inserted)\n-                scope.nodes_with_duplicated_aliases.insert(node);\n+             addDuplicatingAlias(node);\n \n             return;\n         }\n \n         if (scope.alias_name_to_lambda_node.contains(alias))\n-            scope.nodes_with_duplicated_aliases.insert(node);\n+         addDuplicatingAlias(node);\n \n         auto [_, inserted] = scope.alias_name_to_expression_node->insert(std::make_pair(alias, node));\n         if (!inserted)\n-            scope.nodes_with_duplicated_aliases.insert(node);\n+         addDuplicatingAlias(node);\n \n         /// If node is identifier put it also in scope alias name to lambda node map\n         if (node->getNodeType() == QueryTreeNodeType::IDENTIFIER)\n@@ -6254,6 +6263,10 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n         result_projection_names.push_back(node_alias);\n     }\n \n+    bool is_duplicated_alias = scope.nodes_with_duplicated_aliases.contains(node);\n+    if (is_duplicated_alias)\n+        scope.non_cached_identifier_lookups_during_expression_resolve.insert({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});\n+\n     /** Do not use alias table if node has alias same as some other node.\n       * Example: WITH x -> x + 1 AS lambda SELECT 1 AS lambda;\n       * During 1 AS lambda resolve if we use alias table we replace node with x -> x + 1 AS lambda.\n@@ -6264,7 +6277,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n       * alias table because in alias table subquery could be evaluated as scalar.\n       */\n     bool use_alias_table = true;\n-    if (scope.nodes_with_duplicated_aliases.contains(node) || (allow_table_expression && isSubqueryNodeType(node->getNodeType())))\n+    if (is_duplicated_alias || (allow_table_expression && isSubqueryNodeType(node->getNodeType())))\n         use_alias_table = false;\n \n     if (!node_alias.empty() && use_alias_table)\n@@ -6568,6 +6581,9 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n         }\n     }\n \n+    if (is_duplicated_alias)\n+        scope.non_cached_identifier_lookups_during_expression_resolve.erase({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});\n+\n     resolved_expressions.emplace(node, result_projection_names);\n \n     scope.popExpressionNode();\n@@ -6600,7 +6616,6 @@ ProjectionNames QueryAnalyzer::resolveExpressionNodeList(QueryTreeNodePtr & node\n     {\n         auto node_to_resolve = node;\n         auto expression_node_projection_names = resolveExpressionNode(node_to_resolve, scope, allow_lambda_expression, allow_table_expression);\n-\n         size_t expected_projection_names_size = 1;\n         if (auto * expression_list = node_to_resolve->as<ListNode>())\n         {\n@@ -8208,10 +8223,13 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n       * After scope nodes are resolved, we can compare node with duplicate alias with\n       * node from scope alias table.\n       */\n-    for (const auto & node_with_duplicated_alias : scope.nodes_with_duplicated_aliases)\n+    for (const auto & node_with_duplicated_alias : scope.cloned_nodes_with_duplicated_aliases)\n     {\n         auto node = node_with_duplicated_alias;\n         auto node_alias = node->getAlias();\n+\n+        /// Add current alias to non cached set, because in case of cyclic alias identifier should not be substituted from cache.\n+        /// See 02896_cyclic_aliases_crash.\n         resolveExpressionNode(node, scope, true /*allow_lambda_expression*/, false /*allow_table_expression*/);\n \n         bool has_node_in_alias_table = false;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02896_cyclic_aliases_crash.reference b/tests/queries/0_stateless/02896_cyclic_aliases_crash.reference\nindex d43017edcc57..caf11f5c15a6 100644\n--- a/tests/queries/0_stateless/02896_cyclic_aliases_crash.reference\n+++ b/tests/queries/0_stateless/02896_cyclic_aliases_crash.reference\n@@ -1,1 +1,2 @@\n 1\t2\t3\n+1\t5\ndiff --git a/tests/queries/0_stateless/02896_cyclic_aliases_crash.sql b/tests/queries/0_stateless/02896_cyclic_aliases_crash.sql\nindex 76eff95cf314..5fb628eeb67c 100644\n--- a/tests/queries/0_stateless/02896_cyclic_aliases_crash.sql\n+++ b/tests/queries/0_stateless/02896_cyclic_aliases_crash.sql\n@@ -15,3 +15,18 @@ SELECT\n     val + prev as val2\n FROM ( SELECT 1 as val )\n ;\n+\n+select number % 2 as number, count() from numbers(10) where number != 0 group by number % 2 as number;\n+\n+CREATE TABLE test_table (time_stamp_utc DateTime, impressions UInt32, clicks UInt32, revenue Float32) ENGINE = MergeTree ORDER BY time_stamp_utc;\n+\n+SELECT\n+    toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc,\n+    sum(impressions) AS Impressions,\n+    sum(clicks) AS Clicks,\n+    sum(revenue) AS Revenue\n+FROM test_table\n+WHERE (time_stamp_utc >= toDateTime('2024-04-25 00:00:00')) AND (time_stamp_utc < toDateTime('2024-05-02 00:00:00'))\n+GROUP BY time_stamp_utc\n+ORDER BY Impressions DESC\n+LIMIT 1000;\n",
  "problem_statement": "Error in ClickHouse query: Multiple expressions for alias.\nWhen executing the following query in ClickHouse version 24.4.1.2088:\r\n```\r\nSELECT toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc,\r\nsum(impressions) AS Impressions,\r\nsum(clicks) AS Clicks,\r\nsum(revenue) AS Revenue\r\nFROM test_table\r\nWHERE time_stamp_utc >= toDateTime('2024-04-25 00:00:00')\r\nAND time_stamp_utc < toDateTime('2024-05-02 00:00:00')\r\nGROUP BY toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc\r\nORDER BY Impressions DESC\r\nLIMIT 1000;\r\n```\r\n\r\nI encountered the following error:\r\n```\r\nCode: 179. DB::Exception: Received from localhost:9000. DB::Exception: \r\nMultiple expressions toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc and toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc for alias time_stamp_utc.\r\nIn scope SELECT toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc, sum(impressions) AS Impressions, sum(clicks) AS Clicks, sum(revenue) AS Revenue FROM test_table WHERE (time_stamp_utc >= toDateTime('2024-04-25 00:00:00')) AND (time_stamp_utc < toDateTime('2024-05-02 00:00:00')) GROUP BY time_stamp_utc ORDER BY Impressions DESC LIMIT 1000. \r\n(MULTIPLE_EXPRESSIONS_FOR_ALIAS)\r\n```\r\n\r\n### Additional Information\r\n- This query works as expected in ClickHouse version 24.2.3.70 but fails with the described error in version 24.4.1.2088.\r\n\r\n### Table Schema\r\n```\r\nCREATE TABLE test_table(\r\n    time_stamp_utc DateTime,\r\n    impressions UInt32,\r\n    clicks UInt32,\r\n    revenue Float32,\r\n) ENGINE = MergeTree\r\nORDER BY time_stamp_utc;\r\n```\r\n\n",
  "hints_text": "Can you please post a reproducer, with table schema, so we don't have to guess? Thank you\n> Can you please post a reproducer, with table schema, so we don't have to guess? Thank you\r\n\r\nEdited description.\nThis is a behaviour change in the new analyzer, but I don't know if it's a bug or not.\r\n\r\nThere are 2 identical aliases, and it's not clear to me what the behaviour of the second alias (`GROUP BY toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc`) should be as it uses the aliased column `time_stamp_utc`: Does it reference `test_table.time_stamp_utc` or does it reference the alias declared in the select projection (`SELECT toStartOfDay(toDateTime(time_stamp_utc)) AS time_stamp_utc,`).\r\n\r\nMaybe @KochetovNicolai or somebody else from the team can answer\r\n\r\n\r\n\r\n\nBTW, in the meantime you can disable the new analyzer (`allow_experimental_analyzer = 0`)\n```\r\nselect number % 2 as number, count() from numbers(10) where number != 0 group by number % 2 as number\r\n```",
  "created_at": "2024-05-14T17:55:00Z"
}