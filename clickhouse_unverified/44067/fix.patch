diff --git a/src/AggregateFunctions/AggregateFunctionQuantile.h b/src/AggregateFunctions/AggregateFunctionQuantile.h
index 6e7f88d3f8c1..39a9e09dc640 100644
--- a/src/AggregateFunctions/AggregateFunctionQuantile.h
+++ b/src/AggregateFunctions/AggregateFunctionQuantile.h
@@ -170,7 +170,7 @@ class AggregateFunctionQuantile final
             {
                 auto & data_to = assert_cast<ColumnVector<FloatReturnType> &>(arr_to.getData()).getData();
                 size_t old_size = data_to.size();
-                data_to.resize(data_to.size() + size);
+                data_to.resize(old_size + size);
 
                 data.getManyFloat(levels.levels.data(), levels.permutation.data(), size, data_to.data() + old_size);
             }
@@ -178,7 +178,7 @@ class AggregateFunctionQuantile final
             {
                 auto & data_to = static_cast<ColVecType &>(arr_to.getData()).getData();
                 size_t old_size = data_to.size();
-                data_to.resize(data_to.size() + size);
+                data_to.resize(old_size + size);
 
                 data.getMany(levels.levels.data(), levels.permutation.data(), size, data_to.data() + old_size);
             }
diff --git a/src/AggregateFunctions/QuantileReservoirSampler.h b/src/AggregateFunctions/QuantileReservoirSampler.h
index 4d36943cd7c9..70127bcb8658 100644
--- a/src/AggregateFunctions/QuantileReservoirSampler.h
+++ b/src/AggregateFunctions/QuantileReservoirSampler.h
@@ -55,6 +55,9 @@ struct QuantileReservoirSampler
     /// Get the value of the `level` quantile. The level must be between 0 and 1.
     Value get(Float64 level)
     {
+        if (data.empty())
+            return {};
+
         if constexpr (is_decimal<Value>)
             return Value(static_cast<typename Value::NativeType>(data.quantileInterpolated(level)));
         else
@@ -65,11 +68,22 @@ struct QuantileReservoirSampler
     /// indices - an array of index levels such that the corresponding elements will go in ascending order.
     void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)
     {
+        bool is_empty = data.empty();
+
         for (size_t i = 0; i < size; ++i)
-            if constexpr (is_decimal<Value>)
-                result[indices[i]] = Value(static_cast<typename Value::NativeType>(data.quantileInterpolated(levels[indices[i]])));
+        {
+            if (is_empty)
+            {
+                result[i] = Value{};
+            }
             else
-                result[indices[i]] = Value(data.quantileInterpolated(levels[indices[i]]));
+            {
+                if constexpr (is_decimal<Value>)
+                    result[indices[i]] = Value(static_cast<typename Value::NativeType>(data.quantileInterpolated(levels[indices[i]])));
+                else
+                    result[indices[i]] = Value(data.quantileInterpolated(levels[indices[i]]));
+            }
+        }
     }
 
     /// The same, but in the case of an empty state, NaN is returned.
diff --git a/src/AggregateFunctions/QuantileReservoirSamplerDeterministic.h b/src/AggregateFunctions/QuantileReservoirSamplerDeterministic.h
index c74ab49c4ba6..b8938fcaeca7 100644
--- a/src/AggregateFunctions/QuantileReservoirSamplerDeterministic.h
+++ b/src/AggregateFunctions/QuantileReservoirSamplerDeterministic.h
@@ -55,6 +55,9 @@ struct QuantileReservoirSamplerDeterministic
     /// Get the value of the `level` quantile. The level must be between 0 and 1.
     Value get(Float64 level)
     {
+        if (data.empty())
+            return {};
+
         if constexpr (is_decimal<Value>)
             return static_cast<typename Value::NativeType>(data.quantileInterpolated(level));
         else
@@ -65,11 +68,22 @@ struct QuantileReservoirSamplerDeterministic
     /// indices - an array of index levels such that the corresponding elements will go in ascending order.
     void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)
     {
+        bool is_empty = data.empty();
+
         for (size_t i = 0; i < size; ++i)
-            if constexpr (is_decimal<Value>)
-                result[indices[i]] = static_cast<typename Value::NativeType>(data.quantileInterpolated(levels[indices[i]]));
+        {
+            if (is_empty)
+            {
+                result[i] = Value{};
+            }
             else
-                result[indices[i]] = static_cast<Value>(data.quantileInterpolated(levels[indices[i]]));
+            {
+                if constexpr (is_decimal<Value>)
+                    result[indices[i]] = static_cast<typename Value::NativeType>(data.quantileInterpolated(levels[indices[i]]));
+                else
+                    result[indices[i]] = static_cast<Value>(data.quantileInterpolated(levels[indices[i]]));
+            }
+        }
     }
 
     /// The same, but in the case of an empty state, NaN is returned.
diff --git a/src/AggregateFunctions/ReservoirSampler.h b/src/AggregateFunctions/ReservoirSampler.h
index 487cc4167f01..b59f75b377e7 100644
--- a/src/AggregateFunctions/ReservoirSampler.h
+++ b/src/AggregateFunctions/ReservoirSampler.h
@@ -103,6 +103,11 @@ class ReservoirSampler
         return total_values;
     }
 
+    bool empty() const
+    {
+        return samples.empty();
+    }
+
     T quantileNearest(double level)
     {
         if (samples.empty())
diff --git a/src/AggregateFunctions/ReservoirSamplerDeterministic.h b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
index 557fd93a3a90..39c962242f97 100644
--- a/src/AggregateFunctions/ReservoirSamplerDeterministic.h
+++ b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
@@ -95,6 +95,11 @@ class ReservoirSamplerDeterministic
         return total_values;
     }
 
+    bool empty() const
+    {
+        return samples.empty();
+    }
+
     T quantileNearest(double level)
     {
         if (samples.empty())
diff --git a/src/Daemon/BaseDaemon.cpp b/src/Daemon/BaseDaemon.cpp
index 7283973007b1..57a4da4b68ef 100644
--- a/src/Daemon/BaseDaemon.cpp
+++ b/src/Daemon/BaseDaemon.cpp
@@ -311,19 +311,29 @@ class SignalListener : public Poco::Runnable
                 DB::CurrentThread::attachInternalTextLogsQueue(logs_queue, DB::LogsLevel::trace);
         }
 
+        std::string signal_description = "Unknown signal";
+
+        /// Some of these are not really signals, but our own indications on failure reason.
+        if (sig == StdTerminate)
+            signal_description = "std::terminate";
+        else if (sig == SanitizerTrap)
+            signal_description = "sanitizer trap";
+        else if (sig >= 0)
+            signal_description = strsignal(sig); // NOLINT(concurrency-mt-unsafe) // it is not thread-safe but ok in this context
+
         LOG_FATAL(log, "########################################");
 
         if (query_id.empty())
         {
             LOG_FATAL(log, "(version {}{}, build id: {}) (from thread {}) (no query) Received signal {} ({})",
                 VERSION_STRING, VERSION_OFFICIAL, daemon.build_id,
-                thread_num, strsignal(sig), sig); // NOLINT(concurrency-mt-unsafe) // it is not thread-safe but ok in this context
+                thread_num, signal_description, sig);
         }
         else
         {
             LOG_FATAL(log, "(version {}{}, build id: {}) (from thread {}) (query_id: {}) (query: {}) Received signal {} ({})",
                 VERSION_STRING, VERSION_OFFICIAL, daemon.build_id,
-                thread_num, query_id, query, strsignal(sig), sig); // NOLINT(concurrency-mt-unsafe) // it is not thread-safe but ok in this context)
+                thread_num, query_id, query, signal_description, sig);
         }
 
         String error_message;
