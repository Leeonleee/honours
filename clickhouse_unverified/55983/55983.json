{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55983,
  "instance_id": "ClickHouse__ClickHouse-55983",
  "issue_numbers": [
    "42966"
  ],
  "base_commit": "010cc6918acb81bfaa9b2839fa022f14c05e549b",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 0df72b5818c8..f9c829209c5a 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -1982,12 +1982,12 @@ Result:\n \n ## snowflakeToDateTime\n \n-Extracts time from [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as [DateTime](/docs/en/sql-reference/data-types/datetime.md) format.\n+Extracts the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) in [DateTime](/docs/en/sql-reference/data-types/datetime.md) format.\n \n **Syntax**\n \n ``` sql\n-snowflakeToDateTime(value [, time_zone])\n+snowflakeToDateTime(value[, time_zone])\n ```\n \n **Parameters**\n@@ -1997,7 +1997,7 @@ snowflakeToDateTime(value [, time_zone])\n \n **Returned value**\n \n-- Input value converted to the [DateTime](/docs/en/sql-reference/data-types/datetime.md) data type.\n+- The timestamp component of `value` as a [DateTime](/docs/en/sql-reference/data-types/datetime.md) value.\n \n **Example**\n \n@@ -2018,12 +2018,12 @@ Result:\n \n ## snowflakeToDateTime64\n \n-Extracts time from [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) format.\n+Extracts the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) in [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) format.\n \n **Syntax**\n \n ``` sql\n-snowflakeToDateTime64(value [, time_zone])\n+snowflakeToDateTime64(value[, time_zone])\n ```\n \n **Parameters**\n@@ -2033,7 +2033,7 @@ snowflakeToDateTime64(value [, time_zone])\n \n **Returned value**\n \n-- Input value converted to the [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) data type.\n+- The timestamp component of `value` as a [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) with scale = 3, i.e. millisecond precision.\n \n **Example**\n \n@@ -2054,7 +2054,7 @@ Result:\n \n ## dateTimeToSnowflake\n \n-Converts [DateTime](/docs/en/sql-reference/data-types/datetime.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.\n+Converts a [DateTime](/docs/en/sql-reference/data-types/datetime.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.\n \n **Syntax**\n \n@@ -2064,7 +2064,7 @@ dateTimeToSnowflake(value)\n \n **Parameters**\n \n-- `value` \u2014 Date and time. [DateTime](/docs/en/sql-reference/data-types/datetime.md).\n+- `value` \u2014 Date with time. [DateTime](/docs/en/sql-reference/data-types/datetime.md).\n \n **Returned value**\n \n@@ -2088,7 +2088,7 @@ Result:\n \n ## dateTime64ToSnowflake\n \n-Convert [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.\n+Convert a [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.\n \n **Syntax**\n \n@@ -2098,7 +2098,7 @@ dateTime64ToSnowflake(value)\n \n **Parameters**\n \n-- `value` \u2014 Date and time. [DateTime64](/docs/en/sql-reference/data-types/datetime64.md).\n+- `value` \u2014 Date with time. [DateTime64](/docs/en/sql-reference/data-types/datetime64.md).\n \n **Returned value**\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex fb0a015821db..7f5cd88fa2bd 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -452,10 +452,25 @@ inline bool isObject(const T & data_type) { return WhichDataType(data_type).isOb\n template <typename T>\n inline bool isUInt8(const T & data_type) { return WhichDataType(data_type).isUInt8(); }\n template <typename T>\n+inline bool isUInt16(const T & data_type) { return WhichDataType(data_type).isUInt16(); }\n+template <typename T>\n+inline bool isUInt32(const T & data_type) { return WhichDataType(data_type).isUInt32(); }\n+template <typename T>\n inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }\n template <typename T>\n inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }\n \n+template <typename T>\n+inline bool isInt8(const T & data_type) { return WhichDataType(data_type).isInt8(); }\n+template <typename T>\n+inline bool isInt16(const T & data_type) { return WhichDataType(data_type).isInt16(); }\n+template <typename T>\n+inline bool isInt32(const T & data_type) { return WhichDataType(data_type).isInt32(); }\n+template <typename T>\n+inline bool isInt64(const T & data_type) { return WhichDataType(data_type).isInt64(); }\n+template <typename T>\n+inline bool isInt(const T & data_type) { return WhichDataType(data_type).isInt(); }\n+\n template <typename T>\n inline bool isInteger(const T & data_type)\n {\ndiff --git a/src/Functions/FunctionSnowflake.h b/src/Functions/FunctionSnowflake.h\nindex b57e21e9a506..26c8138633ba 100644\n--- a/src/Functions/FunctionSnowflake.h\n+++ b/src/Functions/FunctionSnowflake.h\n@@ -4,10 +4,12 @@\n #include <Functions/IFunction.h>\n #include <Functions/FunctionHelpers.h>\n #include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnsDateTime.h>\n #include <Columns/ColumnsNumber.h>\n+#include <Core/DecimalFunctions.h>\n #include <Interpreters/Context.h>\n \n #include <base/arithmeticOverflow.h>\n@@ -17,7 +19,6 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n@@ -40,14 +41,15 @@ class FunctionDateTimeToSnowflake : public IFunction\n \n     String getName() const override { return name; }\n     size_t getNumberOfArguments() const override { return 1; }\n-    bool isVariadic() const override { return false; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (!isDateTime(arguments[0].type))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be DateTime\", name);\n+        FunctionArgumentDescriptors args{\n+            {\"value\", &isDateTime<IDataType>, nullptr, \"DateTime\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n \n         return std::make_shared<DataTypeInt64>();\n     }\n@@ -88,13 +90,15 @@ class FunctionSnowflakeToDateTime : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.empty() || arguments.size() > 2)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} takes one or two arguments\", name);\n-\n-        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument for function {} must be Int64\", name);\n-\n-        std::string timezone;\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"value\", &isInt64<IDataType>, nullptr, \"Int64\"}\n+        };\n+        FunctionArgumentDescriptors optional_args{\n+            {\"time_zone\", &isString<IDataType>, nullptr, \"String\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n+\n+        String timezone;\n         if (arguments.size() == 2)\n             timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, allow_nonconst_timezone_arguments);\n \n@@ -141,14 +145,15 @@ class FunctionDateTime64ToSnowflake : public IFunction\n \n     String getName() const override { return name; }\n     size_t getNumberOfArguments() const override { return 1; }\n-    bool isVariadic() const override { return false; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (!isDateTime64(arguments[0].type))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be DateTime64\", name);\n+        FunctionArgumentDescriptors args{\n+            {\"value\", &isDateTime64<IDataType>, nullptr, \"DateTime64\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n \n         return std::make_shared<DataTypeInt64>();\n     }\n@@ -156,14 +161,21 @@ class FunctionDateTime64ToSnowflake : public IFunction\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n         const auto & src = arguments[0];\n-        const auto & src_column = *src.column;\n \n+        const auto & src_column = *src.column;\n         auto res_column = ColumnInt64::create(input_rows_count);\n         auto & res_data = res_column->getData();\n \n         const auto & src_data = typeid_cast<const ColumnDecimal<DateTime64> &>(src_column).getData();\n+\n+        /// timestamps in snowflake-ids are millisecond-based, convert input to milliseconds\n+        UInt32 src_scale = getDecimalScale(*arguments[0].type);\n+        Int64 multiplier_msec = DecimalUtils::scaleMultiplier<DateTime64>(3);\n+        Int64 multiplier_src = DecimalUtils::scaleMultiplier<DateTime64>(src_scale);\n+        auto factor = multiplier_msec / static_cast<double>(multiplier_src);\n+\n         for (size_t i = 0; i < input_rows_count; ++i)\n-            res_data[i] = (src_data[i] - snowflake_epoch) << time_shift;\n+            res_data[i] = static_cast<Int64>(src_data[i] * factor - snowflake_epoch) << time_shift;\n \n         return res_column;\n     }\n@@ -190,13 +202,15 @@ class FunctionSnowflakeToDateTime64 : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.empty() || arguments.size() > 2)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} takes one or two arguments\", name);\n-\n-        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument for function {} must be Int64\", name);\n-\n-        std::string timezone;\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"value\", &isInt64<IDataType>, nullptr, \"Int64\"}\n+        };\n+        FunctionArgumentDescriptors optional_args{\n+            {\"time_zone\", &isString<IDataType>, nullptr, \"String\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n+\n+        String timezone;\n         if (arguments.size() == 2)\n             timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, allow_nonconst_timezone_arguments);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference b/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference\nindex dfca3a10eeb3..abc27beb5f7e 100644\n--- a/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference\n+++ b/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference\n@@ -1,6 +1,7 @@\n-const column\n-2021-08-15 18:57:56\t1426860702823350272\n-2021-08-15 18:57:56.492\t1426860704886947840\n-non-const column\n-2021-08-15 18:57:56\t1426860702823350272\n-2021-08-15 18:57:56.492\t1426860704886947840\n+-- const / non-const inputs\n+2021-08-15 18:57:56\t1426860702823350272\t1426860702823350272\n+2021-08-15 18:57:56.492\t1426860704886947840\t1426860704886947840\n+-- different DateTime64 scales\n+1426981498778550272\t1426981500456271872\t1426981500833759232\t1426981500842147840\t1426981500842147840\n+1\t1\t1\t1\n+2023-11-11 11:11:11.1231\t2023-11-11 11:11:11.123\ndiff --git a/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql b/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql\nindex 047d8be7be5d..1090179bb67e 100644\n--- a/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql\n+++ b/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql\n@@ -1,23 +1,45 @@\n+SET session_timezone = 'Africa/Juba';\n+\n -- Error cases\n-SELECT dateTimeToSnowflake();  -- {serverError 42}\n-SELECT dateTime64ToSnowflake();  -- {serverError 42}\n+SELECT dateTimeToSnowflake();  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+SELECT dateTime64ToSnowflake();  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+\n+SELECT dateTimeToSnowflake('abc');  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT dateTime64ToSnowflake('abc');  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n \n-SELECT dateTimeToSnowflake('abc');  -- {serverError 43}\n-SELECT dateTime64ToSnowflake('abc');  -- {serverError 43}\n+SELECT dateTimeToSnowflake('abc', 123);  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+SELECT dateTime64ToSnowflake('abc', 123);  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n \n-SELECT dateTimeToSnowflake('abc', 123);  -- {serverError 42}\n-SELECT dateTime64ToSnowflake('abc', 123);  -- {serverError 42}\n+SELECT '-- const / non-const inputs';\n \n-SELECT 'const column';\n WITH toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai') AS dt\n-SELECT dt, dateTimeToSnowflake(dt);\n+SELECT dt, dateTimeToSnowflake(dt), materialize(dateTimeToSnowflake(dt));\n \n WITH toDateTime64('2021-08-15 18:57:56.492', 3, 'Asia/Shanghai') AS dt64\n-SELECT dt64, dateTime64ToSnowflake(dt64);\n+SELECT dt64, dateTime64ToSnowflake(dt64), materialize(dateTime64ToSnowflake(dt64));\n+\n+SELECT '-- different DateTime64 scales';\n+\n+WITH toDateTime64('2021-08-15 18:57:56.492', 0, 'UTC') AS dt64_0,\n+     toDateTime64('2021-08-15 18:57:56.492', 1, 'UTC') AS dt64_1,\n+     toDateTime64('2021-08-15 18:57:56.492', 2, 'UTC') AS dt64_2,\n+     toDateTime64('2021-08-15 18:57:56.492', 3, 'UTC') AS dt64_3,\n+     toDateTime64('2021-08-15 18:57:56.492', 4, 'UTC') AS dt64_4\n+SELECT dateTime64ToSnowflake(dt64_0),\n+       dateTime64ToSnowflake(dt64_1),\n+       dateTime64ToSnowflake(dt64_2),\n+       dateTime64ToSnowflake(dt64_3),\n+       dateTime64ToSnowflake(dt64_4);\n \n-SELECT 'non-const column';\n-WITH toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai') AS x\n-SELECT materialize(x) as dt, dateTimeToSnowflake(dt);;\n+-- DateTime64-to-Snowflake-to-DateTime64 is idempotent *if* the scale is <=3 (millisecond precision)\n+WITH now64(0, 'UTC') AS dt64_0,\n+     now64(1, 'UTC') AS dt64_1,\n+     now64(2, 'UTC') AS dt64_2,\n+     now64(3, 'UTC') AS dt64_3\n+SELECT snowflakeToDateTime64(dateTime64ToSnowflake(dt64_0), 'UTC') == dt64_0,\n+       snowflakeToDateTime64(dateTime64ToSnowflake(dt64_1), 'UTC') == dt64_1,\n+       snowflakeToDateTime64(dateTime64ToSnowflake(dt64_2), 'UTC') == dt64_2,\n+       snowflakeToDateTime64(dateTime64ToSnowflake(dt64_3), 'UTC') == dt64_3;\n \n-WITH toDateTime64('2021-08-15 18:57:56.492', 3, 'Asia/Shanghai') AS x\n-SELECT materialize(x) as dt64, dateTime64ToSnowflake(dt64);\n+WITH toDateTime64('2023-11-11 11:11:11.1231', 4, 'UTC') AS dt64_4\n+SELECT dt64_4, snowflakeToDateTime64(dateTime64ToSnowflake(dt64_4), 'UTC'); -- not idempotent\ndiff --git a/tests/queries/0_stateless/01942_snowflakeToDateTime.sql b/tests/queries/0_stateless/01942_snowflakeToDateTime.sql\nindex 0092eca848c6..f1a50dd370da 100644\n--- a/tests/queries/0_stateless/01942_snowflakeToDateTime.sql\n+++ b/tests/queries/0_stateless/01942_snowflakeToDateTime.sql\n@@ -1,12 +1,12 @@\n -- -- Error cases\n-SELECT snowflakeToDateTime();  -- {serverError 42}\n-SELECT snowflakeToDateTime64();  -- {serverError 42}\n+SELECT snowflakeToDateTime();  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+SELECT snowflakeToDateTime64();  -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n \n-SELECT snowflakeToDateTime('abc');  -- {serverError 43}\n-SELECT snowflakeToDateTime64('abc');  -- {serverError 43}\n+SELECT snowflakeToDateTime('abc');  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT snowflakeToDateTime64('abc');  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n \n-SELECT snowflakeToDateTime('abc', 123);  -- {serverError 43}\n-SELECT snowflakeToDateTime64('abc', 123);  -- {serverError 43}\n+SELECT snowflakeToDateTime('abc', 123);  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT snowflakeToDateTime64('abc', 123);  -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n \n SELECT 'const column';\n WITH\n",
  "problem_statement": "snowflakeToDateTime64 creates wrong timestamp with precision '6'\nThe following query creates wrong results when using `snowflakeToDateTime64`/`dateTime64ToSnowflake` and `DateTime64` with _precision_ 6:\r\n\r\n ```sql\r\nSELECT\r\n    now64(6) AS ts,\r\n    snowflakeToDateTime64(dateTime64ToSnowflake(ts)) AS sf\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500sf\u2500\u2510\r\n\u2502 2022-11-04 13:40:06.308513 \u2502 1992-05-16 03:10:00.097 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nFor other `DateTime64` precisions it works fine:\r\n\r\n```sql\r\nSELECT\r\n    now64() AS ts,\r\n    snowflakeToDateTime64(dateTime64ToSnowflake(ts)) AS sf\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500sf\u2500\u2510\r\n\u2502 2022-11-04 13:39:48.927 \u2502 2022-11-04 13:39:48.927 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT\r\n    now64(3) AS ts,\r\n    snowflakeToDateTime64(dateTime64ToSnowflake(ts)) AS sf\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500sf\u2500\u2510\r\n\u2502 2022-11-04 13:40:02.500 \u2502 2022-11-04 13:40:02.500 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT\r\n    now64(9) AS ts,\r\n    snowflakeToDateTime64(dateTime64ToSnowflake(ts)) AS sf\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500sf\u2500\u2510\r\n\u2502 2022-11-04 13:40:10.999929289 \u2502 2042-10-02 10:02:16.649 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nClickhouse version: 22.10.2.11\n",
  "hints_text": "Ref: https://github.com/ClickHouse/ClickHouse/pull/27704\r\ncc: @jasine, @kssenii \n@ifoo according to the design of snowflake, the time precession is `milliseconds` (https://en.wikipedia.org/wiki/Snowflake_ID), so  now64(6) and now64(9) will lose precession , maybe throw an error is better. \nBut currently it does not just lose precision, it returns absolutely incorrect result. ",
  "created_at": "2023-10-24T15:28:22Z"
}