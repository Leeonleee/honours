diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md
index 0df72b5818c8..f9c829209c5a 100644
--- a/docs/en/sql-reference/functions/type-conversion-functions.md
+++ b/docs/en/sql-reference/functions/type-conversion-functions.md
@@ -1982,12 +1982,12 @@ Result:
 
 ## snowflakeToDateTime
 
-Extracts time from [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as [DateTime](/docs/en/sql-reference/data-types/datetime.md) format.
+Extracts the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) in [DateTime](/docs/en/sql-reference/data-types/datetime.md) format.
 
 **Syntax**
 
 ``` sql
-snowflakeToDateTime(value [, time_zone])
+snowflakeToDateTime(value[, time_zone])
 ```
 
 **Parameters**
@@ -1997,7 +1997,7 @@ snowflakeToDateTime(value [, time_zone])
 
 **Returned value**
 
-- Input value converted to the [DateTime](/docs/en/sql-reference/data-types/datetime.md) data type.
+- The timestamp component of `value` as a [DateTime](/docs/en/sql-reference/data-types/datetime.md) value.
 
 **Example**
 
@@ -2018,12 +2018,12 @@ Result:
 
 ## snowflakeToDateTime64
 
-Extracts time from [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) as [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) format.
+Extracts the timestamp component of a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) in [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) format.
 
 **Syntax**
 
 ``` sql
-snowflakeToDateTime64(value [, time_zone])
+snowflakeToDateTime64(value[, time_zone])
 ```
 
 **Parameters**
@@ -2033,7 +2033,7 @@ snowflakeToDateTime64(value [, time_zone])
 
 **Returned value**
 
-- Input value converted to the [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) data type.
+- The timestamp component of `value` as a [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) with scale = 3, i.e. millisecond precision.
 
 **Example**
 
@@ -2054,7 +2054,7 @@ Result:
 
 ## dateTimeToSnowflake
 
-Converts [DateTime](/docs/en/sql-reference/data-types/datetime.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.
+Converts a [DateTime](/docs/en/sql-reference/data-types/datetime.md) value to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.
 
 **Syntax**
 
@@ -2064,7 +2064,7 @@ dateTimeToSnowflake(value)
 
 **Parameters**
 
-- `value` — Date and time. [DateTime](/docs/en/sql-reference/data-types/datetime.md).
+- `value` — Date with time. [DateTime](/docs/en/sql-reference/data-types/datetime.md).
 
 **Returned value**
 
@@ -2088,7 +2088,7 @@ Result:
 
 ## dateTime64ToSnowflake
 
-Convert [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.
+Convert a [DateTime64](/docs/en/sql-reference/data-types/datetime64.md) to the first [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) at the giving time.
 
 **Syntax**
 
@@ -2098,7 +2098,7 @@ dateTime64ToSnowflake(value)
 
 **Parameters**
 
-- `value` — Date and time. [DateTime64](/docs/en/sql-reference/data-types/datetime64.md).
+- `value` — Date with time. [DateTime64](/docs/en/sql-reference/data-types/datetime64.md).
 
 **Returned value**
 
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index fb0a015821db..7f5cd88fa2bd 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -452,10 +452,25 @@ inline bool isObject(const T & data_type) { return WhichDataType(data_type).isOb
 template <typename T>
 inline bool isUInt8(const T & data_type) { return WhichDataType(data_type).isUInt8(); }
 template <typename T>
+inline bool isUInt16(const T & data_type) { return WhichDataType(data_type).isUInt16(); }
+template <typename T>
+inline bool isUInt32(const T & data_type) { return WhichDataType(data_type).isUInt32(); }
+template <typename T>
 inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }
 template <typename T>
 inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }
 
+template <typename T>
+inline bool isInt8(const T & data_type) { return WhichDataType(data_type).isInt8(); }
+template <typename T>
+inline bool isInt16(const T & data_type) { return WhichDataType(data_type).isInt16(); }
+template <typename T>
+inline bool isInt32(const T & data_type) { return WhichDataType(data_type).isInt32(); }
+template <typename T>
+inline bool isInt64(const T & data_type) { return WhichDataType(data_type).isInt64(); }
+template <typename T>
+inline bool isInt(const T & data_type) { return WhichDataType(data_type).isInt(); }
+
 template <typename T>
 inline bool isInteger(const T & data_type)
 {
diff --git a/src/Functions/FunctionSnowflake.h b/src/Functions/FunctionSnowflake.h
index b57e21e9a506..26c8138633ba 100644
--- a/src/Functions/FunctionSnowflake.h
+++ b/src/Functions/FunctionSnowflake.h
@@ -4,10 +4,12 @@
 #include <Functions/IFunction.h>
 #include <Functions/FunctionHelpers.h>
 #include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypesDecimal.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Columns/ColumnConst.h>
 #include <Columns/ColumnsDateTime.h>
 #include <Columns/ColumnsNumber.h>
+#include <Core/DecimalFunctions.h>
 #include <Interpreters/Context.h>
 
 #include <base/arithmeticOverflow.h>
@@ -17,7 +19,6 @@ namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
@@ -40,14 +41,15 @@ class FunctionDateTimeToSnowflake : public IFunction
 
     String getName() const override { return name; }
     size_t getNumberOfArguments() const override { return 1; }
-    bool isVariadic() const override { return false; }
     bool useDefaultImplementationForConstants() const override { return true; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (!isDateTime(arguments[0].type))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The only argument for function {} must be DateTime", name);
+        FunctionArgumentDescriptors args{
+            {"value", &isDateTime<IDataType>, nullptr, "DateTime"}
+        };
+        validateFunctionArgumentTypes(*this, arguments, args);
 
         return std::make_shared<DataTypeInt64>();
     }
@@ -88,13 +90,15 @@ class FunctionSnowflakeToDateTime : public IFunction
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (arguments.empty() || arguments.size() > 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} takes one or two arguments", name);
-
-        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The first argument for function {} must be Int64", name);
-
-        std::string timezone;
+        FunctionArgumentDescriptors mandatory_args{
+            {"value", &isInt64<IDataType>, nullptr, "Int64"}
+        };
+        FunctionArgumentDescriptors optional_args{
+            {"time_zone", &isString<IDataType>, nullptr, "String"}
+        };
+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);
+
+        String timezone;
         if (arguments.size() == 2)
             timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, allow_nonconst_timezone_arguments);
 
@@ -141,14 +145,15 @@ class FunctionDateTime64ToSnowflake : public IFunction
 
     String getName() const override { return name; }
     size_t getNumberOfArguments() const override { return 1; }
-    bool isVariadic() const override { return false; }
     bool useDefaultImplementationForConstants() const override { return true; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (!isDateTime64(arguments[0].type))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The only argument for function {} must be DateTime64", name);
+        FunctionArgumentDescriptors args{
+            {"value", &isDateTime64<IDataType>, nullptr, "DateTime64"}
+        };
+        validateFunctionArgumentTypes(*this, arguments, args);
 
         return std::make_shared<DataTypeInt64>();
     }
@@ -156,14 +161,21 @@ class FunctionDateTime64ToSnowflake : public IFunction
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
         const auto & src = arguments[0];
-        const auto & src_column = *src.column;
 
+        const auto & src_column = *src.column;
         auto res_column = ColumnInt64::create(input_rows_count);
         auto & res_data = res_column->getData();
 
         const auto & src_data = typeid_cast<const ColumnDecimal<DateTime64> &>(src_column).getData();
+
+        /// timestamps in snowflake-ids are millisecond-based, convert input to milliseconds
+        UInt32 src_scale = getDecimalScale(*arguments[0].type);
+        Int64 multiplier_msec = DecimalUtils::scaleMultiplier<DateTime64>(3);
+        Int64 multiplier_src = DecimalUtils::scaleMultiplier<DateTime64>(src_scale);
+        auto factor = multiplier_msec / static_cast<double>(multiplier_src);
+
         for (size_t i = 0; i < input_rows_count; ++i)
-            res_data[i] = (src_data[i] - snowflake_epoch) << time_shift;
+            res_data[i] = static_cast<Int64>(src_data[i] * factor - snowflake_epoch) << time_shift;
 
         return res_column;
     }
@@ -190,13 +202,15 @@ class FunctionSnowflakeToDateTime64 : public IFunction
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (arguments.empty() || arguments.size() > 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} takes one or two arguments", name);
-
-        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The first argument for function {} must be Int64", name);
-
-        std::string timezone;
+        FunctionArgumentDescriptors mandatory_args{
+            {"value", &isInt64<IDataType>, nullptr, "Int64"}
+        };
+        FunctionArgumentDescriptors optional_args{
+            {"time_zone", &isString<IDataType>, nullptr, "String"}
+        };
+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);
+
+        String timezone;
         if (arguments.size() == 2)
             timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, allow_nonconst_timezone_arguments);
 
