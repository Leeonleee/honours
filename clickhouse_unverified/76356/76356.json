{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 76356,
  "instance_id": "ClickHouse__ClickHouse-76356",
  "issue_numbers": [
    "75956"
  ],
  "base_commit": "9a480c974e760fb62957f478c97a0820f23631e6",
  "patch": "diff --git a/src/Interpreters/ApplyWithSubqueryVisitor.cpp b/src/Interpreters/ApplyWithSubqueryVisitor.cpp\nindex 2e6048ee0574..38c9ef89adc4 100644\n--- a/src/Interpreters/ApplyWithSubqueryVisitor.cpp\n+++ b/src/Interpreters/ApplyWithSubqueryVisitor.cpp\n@@ -11,6 +11,7 @@\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n #include <Parsers/ASTWithElement.h>\n+#include <Parsers/ASTLiteral.h>\n #include <Common/checkStackSize.h>\n \n \n@@ -62,11 +63,16 @@ void ApplyWithSubqueryVisitor::visit(ASTSelectQuery & ast, const Data & data)\n         for (auto & child : with->children)\n         {\n             visit(child, new_data ? *new_data : data);\n-            if (auto * ast_with_elem = child->as<ASTWithElement>())\n+            auto * ast_with_elem = child->as<ASTWithElement>();\n+            auto * ast_literal = child->as<ASTLiteral>();\n+            if (ast_with_elem || ast_literal)\n             {\n                 if (!new_data)\n                     new_data = data;\n-                new_data->subqueries[ast_with_elem->name] = ast_with_elem->subquery;\n+                if (ast_with_elem)\n+                    new_data->subqueries[ast_with_elem->name] = ast_with_elem->subquery;\n+                else\n+                    new_data->literals[ast_literal->alias] = child;\n             }\n         }\n     }\n@@ -120,15 +126,27 @@ void ApplyWithSubqueryVisitor::visit(ASTFunction & func, const Data & data)\n             {\n                 /// Clang-tidy is wrong on this line, because `func.arguments->children.at(1)` gets replaced before last use of `name`.\n                 auto name = identifier->shortName();  // NOLINT\n+\n                 auto subquery_it = data.subqueries.find(name);\n                 if (subquery_it != data.subqueries.end())\n                 {\n                     auto old_alias = func.arguments->children[1]->tryGetAlias();\n                     func.arguments->children[1] = subquery_it->second->clone();\n-                    func.arguments->children[1]->as<ASTSubquery &>().cte_name = name;\n+                    func.arguments->children[1]->as<ASTSubquery>()->cte_name = name;\n                     if (!old_alias.empty())\n                         func.arguments->children[1]->setAlias(old_alias);\n                 }\n+                else\n+                {\n+                    auto literal_it = data.literals.find(name);\n+                    if (literal_it != data.literals.end())\n+                    {\n+                        auto old_alias = func.arguments->children[1]->tryGetAlias();\n+                        func.arguments->children[1] = literal_it->second->clone();\n+                        if (!old_alias.empty())\n+                            func.arguments->children[1]->setAlias(old_alias);\n+                    }\n+                }\n             }\n         }\n     }\ndiff --git a/src/Interpreters/ApplyWithSubqueryVisitor.h b/src/Interpreters/ApplyWithSubqueryVisitor.h\nindex b1f7e9a7ff06..00537b0575ee 100644\n--- a/src/Interpreters/ApplyWithSubqueryVisitor.h\n+++ b/src/Interpreters/ApplyWithSubqueryVisitor.h\n@@ -21,6 +21,7 @@ class ApplyWithSubqueryVisitor\n     struct Data\n     {\n         std::map<String, ASTPtr> subqueries;\n+        std::map<String, ASTPtr> literals;\n     };\n \n     void visit(ASTPtr & ast) { visit(ast, {}); }\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 9804f2d21f31..0c3b712384e9 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -1112,7 +1112,7 @@ void InterpreterCreateQuery::validateMaterializedViewColumnsAndEngine(const ASTC\n                 /// We should treat SELECT as an initial query in order to properly analyze it.\n                 auto context = Context::createCopy(getContext());\n                 context->setQueryKindInitial();\n-                input_block = InterpreterSelectQueryAnalyzer::getSampleBlock(create.select->clone(), context, SelectQueryOptions{}.createView());\n+                input_block = InterpreterSelectQueryAnalyzer::getSampleBlock(create.select->clone(), context, SelectQueryOptions{}.analyze().createView());\n             }\n             else\n             {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.reference b/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.sql b/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.sql\nnew file mode 100644\nindex 000000000000..3f8bc96df2f0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.sql\n@@ -0,0 +1,13 @@\n+CREATE TABLE mydestination\n+(\n+    `object` String\n+)\n+ENGINE = MergeTree\n+ORDER BY object;\n+\n+CREATE MATERIALIZED VIEW myview TO mydestination\n+AS WITH ('foo', 'bar') AS objects\n+SELECT 'foo' AS object\n+WHERE object IN (objects);\n+\n+SELECT * FROM myview;\n",
  "problem_statement": "UNKNOWN_IDENTIFIER when using expression aliases in CREATE MATERIALIZED VIEW AS\n\n### Describe what's wrong\n\nWhen performing a CREATE VIEW or CREATE MATERIALIZED VIEW statement, if the `AS ...` clause contains an expression-alias style CTE and that alias is later referenced, ClickHouse complains of an UNKNOWN_IDENTIFIER (because it treats the identifer as a table reference).\n\n```\nCREATE MATERIALIZED VIEW myview\nTO mydestination\nAS WITH\n    ('foo','bar') AS objects\nSELECT\n  'foo' as object\nWHERE object IN objects\n```\n\nyields\n\n```\nReceived exception from server (version 25.1.3):\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown expression or table expression identifier `default.objects` in scope WITH ('foo', 'bar') AS objects SELECT 'foo' AS object WHERE object IN (default.objects). (UNKNOWN_IDENTIFIER)\n(query: CREATE MATERIALIZED VIEW myview\nTO mydestination\nAS WITH\n    ('foo','bar') AS objects\nSELECT\n  'foo' as object\nWHERE object IN objects)\n```\n\nhttps://fiddle.clickhouse.com/68df16cb-5328-4ca6-9a4f-41d0fea4d81d (25.1.3.23)\n\nThis is true at HEAD as well\n\nhttps://fiddle.clickhouse.com/cd3c0561-acc9-489b-a111-91590ff973ad\n\n### Does it reproduce on the most recent release?\n\nYes\n",
  "hints_text": "The problem is that QueryAnalyzer receives a wrong query AST. It has `WHERE object IN (default.objects)` instead of `WHERE object IN objects`.\nHere we use `AddDefaultDatabaseVisitor` in the case of `CREATE VIEW` and it leads to the bug I mentioned above making the query invalid.\nhttps://github.com/ClickHouse/ClickHouse/blob/ca8fe1b692dde8005b7869088aaffdb2d48cdb45/src/Interpreters/InterpreterCreateQuery.cpp#L1627",
  "created_at": "2025-02-18T15:59:30Z",
  "modified_files": [
    "src/Interpreters/ApplyWithSubqueryVisitor.cpp",
    "src/Interpreters/ApplyWithSubqueryVisitor.h",
    "src/Interpreters/InterpreterCreateQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03359_analyzer_rewrite_view_query.sql"
  ]
}