{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27377,
  "instance_id": "ClickHouse__ClickHouse-27377",
  "issue_numbers": [
    "22428"
  ],
  "base_commit": "e1927118cd1d020099bbd564a8b23cf4c5bc5c40",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex 43c878427ec5..37b22527eb46 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -243,3 +243,6 @@\n [submodule \"contrib/s2geometry\"]\n \tpath = contrib/s2geometry\n \turl = https://github.com/ClickHouse-Extras/s2geometry.git\n+[submodule \"contrib/bzip2\"]\n+\tpath = contrib/bzip2\n+\turl = https://github.com/ClickHouse-Extras/bzip2.git\ndiff --git a/CMakeLists.txt b/CMakeLists.txt\nindex 24022c256ec3..d3cb5f70c830 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -543,6 +543,7 @@ include (cmake/find/nuraft.cmake)\n include (cmake/find/yaml-cpp.cmake)\n include (cmake/find/s2geometry.cmake)\n include (cmake/find/nlp.cmake)\n+include (cmake/find/bzip2.cmake)\n \n if(NOT USE_INTERNAL_PARQUET_LIBRARY)\n     set (ENABLE_ORC OFF CACHE INTERNAL \"\")\ndiff --git a/cmake/find/bzip2.cmake b/cmake/find/bzip2.cmake\nnew file mode 100644\nindex 000000000000..15532a67c005\n--- /dev/null\n+++ b/cmake/find/bzip2.cmake\n@@ -0,0 +1,19 @@\n+option(ENABLE_BZIP2 \"Enable bzip2 compression support\" ${ENABLE_LIBRARIES})\n+\n+if (NOT ENABLE_BZIP2)\n+    message (STATUS \"bzip2 compression disabled\")\n+    return()\n+endif()\n+\n+if (NOT EXISTS \"${ClickHouse_SOURCE_DIR}/contrib/bzip2/bzlib.h\")\n+    message (WARNING \"submodule contrib/bzip2 is missing. to fix try run: \\n git submodule update --init --recursive\")\n+    message (${RECONFIGURE_MESSAGE_LEVEL} \"Can't find internal bzip2 library\")\n+    set (USE_NLP 0)\n+    return()\n+endif ()\n+\n+set (USE_BZIP2 1)\n+set (BZIP2_INCLUDE_DIR \"${ClickHouse_SOURCE_DIR}/contrib/bzip2\")\n+set (BZIP2_LIBRARY bzip2)\n+\n+message (STATUS \"Using bzip2=${USE_BZIP2}: ${BZIP2_INCLUDE_DIR} : ${BZIP2_LIBRARY}\")\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 82cddb0ace07..e6e098a05b39 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -334,6 +334,10 @@ if (USE_NLP)\n     add_subdirectory(lemmagen-c-cmake)\n endif()\n \n+if (USE_BZIP2)\n+    add_subdirectory(bzip2-cmake)\n+endif()\n+\n if (USE_SQLITE)\n     add_subdirectory(sqlite-cmake)\n endif()\ndiff --git a/contrib/bzip2 b/contrib/bzip2\nnew file mode 160000\nindex 000000000000..bf905ea22511\n--- /dev/null\n+++ b/contrib/bzip2\n@@ -0,0 +1,1 @@\n+Subproject commit bf905ea2251191ff9911ae7ec0cfc35d41f9f7f6\ndiff --git a/contrib/bzip2-cmake/CMakeLists.txt b/contrib/bzip2-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..a9d2efa43c15\n--- /dev/null\n+++ b/contrib/bzip2-cmake/CMakeLists.txt\n@@ -0,0 +1,23 @@\n+set(BZIP2_SOURCE_DIR \"${ClickHouse_SOURCE_DIR}/contrib/bzip2\")\n+set(BZIP2_BINARY_DIR \"${ClickHouse_BINARY_DIR}/contrib/bzip2\")\n+\n+set(SRCS\n+    \"${BZIP2_SOURCE_DIR}/blocksort.c\"\n+    \"${BZIP2_SOURCE_DIR}/huffman.c\"\n+    \"${BZIP2_SOURCE_DIR}/crctable.c\"\n+    \"${BZIP2_SOURCE_DIR}/randtable.c\"\n+    \"${BZIP2_SOURCE_DIR}/compress.c\"\n+    \"${BZIP2_SOURCE_DIR}/decompress.c\"\n+    \"${BZIP2_SOURCE_DIR}/bzlib.c\"\n+)\n+\n+# From bzip2/CMakeLists.txt \n+set(BZ_VERSION \"1.0.7\")\n+configure_file (\n+    \"${BZIP2_SOURCE_DIR}/bz_version.h.in\"\n+    \"${BZIP2_BINARY_DIR}/bz_version.h\"\n+)\n+\n+add_library(bzip2 ${SRCS})\n+\n+target_include_directories(bzip2 PUBLIC \"${BZIP2_SOURCE_DIR}\" \"${BZIP2_BINARY_DIR}\")\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex a99201e4aaa5..2853a2e1a811 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -479,6 +479,11 @@ if (USE_NLP)\n     dbms_target_link_libraries (PUBLIC lemmagen)\n endif()\n \n+if (USE_BZIP2)\n+    target_link_libraries (clickhouse_common_io PRIVATE ${BZIP2_LIBRARY})\n+    target_include_directories (clickhouse_common_io SYSTEM BEFORE PRIVATE ${BZIP2_INCLUDE_DIR})\n+endif()\n+\n include (\"${ClickHouse_SOURCE_DIR}/cmake/add_check.cmake\")\n \n if (ENABLE_TESTS AND USE_GTEST)\ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 7904d0ac61dd..04f10fb536a4 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -561,6 +561,8 @@\n     M(591, SQLITE_ENGINE_ERROR) \\\n     M(592, DATA_ENCRYPTION_ERROR) \\\n     M(593, ZERO_COPY_REPLICATION_ERROR) \\\n+    M(594, BZIP2_STREAM_DECODER_FAILED) \\\n+    M(595, BZIP2_STREAM_ENCODER_FAILED) \\\n     \\\n     M(998, POSTGRESQL_CONNECTION_FAILURE) \\\n     M(999, KEEPER_EXCEPTION) \\\ndiff --git a/src/Common/config.h.in b/src/Common/config.h.in\nindex 0665b1717edb..bf118e2507fc 100644\n--- a/src/Common/config.h.in\n+++ b/src/Common/config.h.in\n@@ -19,3 +19,4 @@\n #cmakedefine01 USE_DATASKETCHES\n #cmakedefine01 USE_YAML_CPP\n #cmakedefine01 CLICKHOUSE_SPLIT_BINARY\n+#cmakedefine01 USE_BZIP2\ndiff --git a/src/IO/Bzip2ReadBuffer.cpp b/src/IO/Bzip2ReadBuffer.cpp\nnew file mode 100644\nindex 000000000000..e264ce75444c\n--- /dev/null\n+++ b/src/IO/Bzip2ReadBuffer.cpp\n@@ -0,0 +1,97 @@\n+#if !defined(ARCADIA_BUILD)\n+#    include <Common/config.h>\n+#endif\n+\n+#if USE_BZIP2\n+#    include <IO/Bzip2ReadBuffer.h>\n+#    include <bzlib.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BZIP2_STREAM_DECODER_FAILED;\n+}\n+\n+\n+class Bzip2ReadBuffer::Bzip2StateWrapper\n+{\n+public:\n+    Bzip2StateWrapper()\n+    {\n+        memset(&stream, 0, sizeof(stream));\n+\n+        int ret = BZ2_bzDecompressInit(&stream, 0, 0);\n+\n+        if (ret != BZ_OK)\n+            throw Exception(\n+                ErrorCodes::BZIP2_STREAM_DECODER_FAILED,\n+                \"bzip2 stream encoder init failed: error code: {}\",\n+                ret);\n+    }\n+\n+    ~Bzip2StateWrapper()\n+    {\n+        BZ2_bzDecompressEnd(&stream);\n+    }\n+\n+    bz_stream stream;\n+};\n+\n+Bzip2ReadBuffer::Bzip2ReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char *existing_memory, size_t alignment)\n+        : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n+        , in(std::move(in_))\n+        , bz(std::make_unique<Bzip2StateWrapper>())\n+        , eof(false)\n+{\n+}\n+\n+Bzip2ReadBuffer::~Bzip2ReadBuffer() = default;\n+\n+bool Bzip2ReadBuffer::nextImpl()\n+{\n+    if (eof)\n+        return false;\n+\n+    if (!bz->stream.avail_in)\n+    {\n+        in->nextIfAtEnd();\n+        bz->stream.avail_in = in->buffer().end() - in->position();\n+        bz->stream.next_in = in->position();\n+    }\n+\n+    bz->stream.avail_out = internal_buffer.size();\n+    bz->stream.next_out = internal_buffer.begin();\n+\n+    int ret = BZ2_bzDecompress(&bz->stream);\n+\n+    in->position() = in->buffer().end() - bz->stream.avail_in;\n+    working_buffer.resize(internal_buffer.size() - bz->stream.avail_out);\n+\n+    if (ret == BZ_STREAM_END)\n+    {\n+        if (in->eof())\n+        {\n+            eof = true;\n+            return !working_buffer.empty();\n+        }\n+        else\n+        {\n+            throw Exception(\n+                ErrorCodes::BZIP2_STREAM_DECODER_FAILED,\n+                \"bzip2 decoder finished, but input stream has not exceeded: error code: {}\", ret);\n+        }\n+    }\n+\n+    if (ret != BZ_OK)\n+        throw Exception(\n+            ErrorCodes::BZIP2_STREAM_DECODER_FAILED,\n+            \"bzip2 stream decoder failed: error code: {}\",\n+            ret);\n+\n+    return true;\n+}\n+}\n+\n+#endif\ndiff --git a/src/IO/Bzip2ReadBuffer.h b/src/IO/Bzip2ReadBuffer.h\nnew file mode 100644\nindex 000000000000..dc113800683e\n--- /dev/null\n+++ b/src/IO/Bzip2ReadBuffer.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/BufferWithOwnMemory.h>\n+\n+\n+namespace DB\n+{\n+\n+class Bzip2ReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+{\n+public:\n+    Bzip2ReadBuffer(\n+            std::unique_ptr<ReadBuffer> in_,\n+            size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n+            char * existing_memory = nullptr,\n+            size_t alignment = 0);\n+\n+    ~Bzip2ReadBuffer() override;\n+\n+private:\n+    bool nextImpl() override;\n+\n+    std::unique_ptr<ReadBuffer> in;\n+\n+    class Bzip2StateWrapper;\n+    std::unique_ptr<Bzip2StateWrapper> bz;\n+\n+    bool eof;\n+};\n+\n+}\n+\ndiff --git a/src/IO/Bzip2WriteBuffer.cpp b/src/IO/Bzip2WriteBuffer.cpp\nnew file mode 100644\nindex 000000000000..41cb972966ca\n--- /dev/null\n+++ b/src/IO/Bzip2WriteBuffer.cpp\n@@ -0,0 +1,138 @@\n+#if !defined(ARCADIA_BUILD)\n+#    include <Common/config.h>\n+#endif\n+\n+#if USE_BROTLI\n+#    include <IO/Bzip2WriteBuffer.h>\n+#    include <bzlib.h>\n+\n+#include <Common/MemoryTracker.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BZIP2_STREAM_ENCODER_FAILED;\n+}\n+\n+\n+class Bzip2WriteBuffer::Bzip2StateWrapper\n+{\n+public:\n+    explicit Bzip2StateWrapper(int compression_level)\n+    {\n+        memset(&stream, 0, sizeof(stream));\n+\n+        int ret = BZ2_bzCompressInit(&stream, compression_level, 0, 0);\n+\n+        if (ret != BZ_OK)\n+            throw Exception(\n+                ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,\n+                \"bzip2 stream encoder init failed: error code: {}\",\n+                ret);\n+    }\n+\n+    ~Bzip2StateWrapper()\n+    {\n+        BZ2_bzCompressEnd(&stream);\n+    }\n+\n+    bz_stream stream;\n+};\n+\n+Bzip2WriteBuffer::Bzip2WriteBuffer(std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)\n+    : BufferWithOwnMemory<WriteBuffer>(buf_size, existing_memory, alignment)\n+    , bz(std::make_unique<Bzip2StateWrapper>(compression_level))\n+    , out(std::move(out_))\n+{\n+}\n+\n+Bzip2WriteBuffer::~Bzip2WriteBuffer()\n+{\n+    /// FIXME move final flush into the caller\n+    MemoryTracker::LockExceptionInThread lock(VariableContext::Global);\n+    finish();\n+}\n+\n+void Bzip2WriteBuffer::nextImpl()\n+{\n+    if (!offset())\n+    {\n+        return;\n+    }\n+\n+    bz->stream.next_in = working_buffer.begin();\n+    bz->stream.avail_in = offset();\n+\n+    try\n+    {\n+        do\n+        {\n+            out->nextIfAtEnd();\n+            bz->stream.next_out = out->position();\n+            bz->stream.avail_out = out->buffer().end() - out->position();\n+\n+            int ret = BZ2_bzCompress(&bz->stream, BZ_RUN);\n+\n+            out->position() = out->buffer().end() - bz->stream.avail_out;\n+\n+            if (ret != BZ_RUN_OK)\n+                throw Exception(\n+                    ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,\n+                    \"bzip2 stream encoder failed: error code: {}\",\n+                    ret);\n+\n+        }\n+        while (bz->stream.avail_in > 0);\n+    }\n+    catch (...)\n+    {\n+        /// Do not try to write next time after exception.\n+        out->position() = out->buffer().begin();\n+        throw;\n+    }\n+}\n+\n+void Bzip2WriteBuffer::finish()\n+{\n+    if (finished)\n+        return;\n+\n+    try\n+    {\n+        finishImpl();\n+        out->finalize();\n+        finished = true;\n+    }\n+    catch (...)\n+    {\n+        /// Do not try to flush next time after exception.\n+        out->position() = out->buffer().begin();\n+        finished = true;\n+        throw;\n+    }\n+}\n+\n+void Bzip2WriteBuffer::finishImpl()\n+{\n+    next();\n+\n+    out->nextIfAtEnd();\n+    bz->stream.next_out = out->position();\n+    bz->stream.avail_out = out->buffer().end() - out->position();\n+\n+    int ret = BZ2_bzCompress(&bz->stream, BZ_FINISH);\n+\n+    out->position() = out->buffer().end() - bz->stream.avail_out;\n+\n+    if (ret != BZ_STREAM_END && ret != BZ_FINISH_OK)\n+        throw Exception(\n+            ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,\n+            \"bzip2 stream encoder failed: error code: {}\",\n+            ret);\n+}\n+\n+}\n+\n+#endif\ndiff --git a/src/IO/Bzip2WriteBuffer.h b/src/IO/Bzip2WriteBuffer.h\nnew file mode 100644\nindex 000000000000..72f14a344e3d\n--- /dev/null\n+++ b/src/IO/Bzip2WriteBuffer.h\n@@ -0,0 +1,37 @@\n+#pragma once\n+\n+#include <IO/WriteBuffer.h>\n+#include <IO/BufferWithOwnMemory.h>\n+\n+namespace DB\n+{\n+\n+class Bzip2WriteBuffer : public BufferWithOwnMemory<WriteBuffer>\n+{\n+public:\n+    Bzip2WriteBuffer(\n+        std::unique_ptr<WriteBuffer> out_,\n+        int compression_level,\n+        size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n+        char * existing_memory = nullptr,\n+        size_t alignment = 0);\n+\n+    ~Bzip2WriteBuffer() override;\n+\n+    void finalize() override { finish(); }\n+\n+private:\n+    void nextImpl() override;\n+\n+    void finish();\n+    void finishImpl();\n+\n+    class Bzip2StateWrapper;\n+    std::unique_ptr<Bzip2StateWrapper> bz;\n+\n+    std::unique_ptr<WriteBuffer> out;\n+\n+    bool finished = false;\n+};\n+\n+}\ndiff --git a/src/IO/CompressionMethod.cpp b/src/IO/CompressionMethod.cpp\nindex c6bb5232c0ca..e02475c1d834 100644\n--- a/src/IO/CompressionMethod.cpp\n+++ b/src/IO/CompressionMethod.cpp\n@@ -10,6 +10,8 @@\n #include <IO/ZlibInflatingReadBuffer.h>\n #include <IO/ZstdDeflatingWriteBuffer.h>\n #include <IO/ZstdInflatingReadBuffer.h>\n+#include <IO/Bzip2ReadBuffer.h>\n+#include <IO/Bzip2WriteBuffer.h>\n \n #if !defined(ARCADIA_BUILD)\n #    include <Common/config.h>\n@@ -40,6 +42,8 @@ std::string toContentEncodingName(CompressionMethod method)\n             return \"xz\";\n         case CompressionMethod::Zstd:\n             return \"zstd\";\n+        case CompressionMethod::Bzip2:\n+            return \"bz2\";\n         case CompressionMethod::None:\n             return \"\";\n     }\n@@ -69,11 +73,13 @@ CompressionMethod chooseCompressionMethod(const std::string & path, const std::s\n         return CompressionMethod::Xz;\n     if (method_str == \"zstd\" || method_str == \"zst\")\n         return CompressionMethod::Zstd;\n+    if (method_str == \"bz2\")\n+        return CompressionMethod::Bzip2;\n     if (hint.empty() || hint == \"auto\" || hint == \"none\")\n         return CompressionMethod::None;\n \n     throw Exception(\n-        \"Unknown compression method \" + hint + \". Only 'auto', 'none', 'gzip', 'deflate', 'br', 'xz', 'zstd' are supported as compression methods\",\n+        \"Unknown compression method \" + hint + \". Only 'auto', 'none', 'gzip', 'deflate', 'br', 'xz', 'zstd', 'bz2' are supported as compression methods\",\n         ErrorCodes::NOT_IMPLEMENTED);\n }\n \n@@ -91,7 +97,10 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n         return std::make_unique<LZMAInflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n     if (method == CompressionMethod::Zstd)\n         return std::make_unique<ZstdInflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n-\n+#if USE_BZIP2\n+    if (method == CompressionMethod::Bzip2)\n+        return std::make_unique<Bzip2ReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n+#endif\n     if (method == CompressionMethod::None)\n         return nested;\n \n@@ -114,7 +123,10 @@ std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n \n     if (method == CompressionMethod::Zstd)\n         return std::make_unique<ZstdDeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n-\n+#if USE_BZIP2\n+    if (method == CompressionMethod::Bzip2)\n+        return std::make_unique<Bzip2WriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);\n+#endif\n     if (method == CompressionMethod::None)\n         return nested;\n \ndiff --git a/src/IO/CompressionMethod.h b/src/IO/CompressionMethod.h\nindex 6f2d87b45cf4..cf034229f77b 100644\n--- a/src/IO/CompressionMethod.h\n+++ b/src/IO/CompressionMethod.h\n@@ -31,7 +31,8 @@ enum class CompressionMethod\n     /// Zstd compressor\n     ///  This option corresponds to HTTP Content-Encoding: zstd\n     Zstd,\n-    Brotli\n+    Brotli,\n+    Bzip2\n };\n \n /// How the compression method is named in HTTP.\ndiff --git a/src/IO/ya.make b/src/IO/ya.make\nindex 9e35a062a962..7723464be6f7 100644\n--- a/src/IO/ya.make\n+++ b/src/IO/ya.make\n@@ -23,6 +23,8 @@ SRCS(\n     AIOContextPool.cpp\n     BrotliReadBuffer.cpp\n     BrotliWriteBuffer.cpp\n+    Bzip2ReadBuffer.cpp\n+    Bzip2WriteBuffer.cpp\n     CascadeWriteBuffer.cpp\n     CompressionMethod.cpp\n     DoubleConverter.cpp\ndiff --git a/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in b/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in\nindex 8fe574da643c..6bb97355151d 100644\n--- a/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in\n+++ b/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in\n@@ -50,6 +50,7 @@ const char * auto_config_build[]\n     \"USE_LDAP\", \"@USE_LDAP@\",\n     \"TZDATA_VERSION\", \"@TZDATA_VERSION@\",\n     \"USE_KRB5\", \"@USE_KRB5@\",\n+    \"USE_BZIP2\", \"@USE_BZIP2@\",\n \n     nullptr, nullptr\n };\n",
  "test_patch": "diff --git a/docker/test/fasttest/run.sh b/docker/test/fasttest/run.sh\nindex 6419ea3659c4..a0dcf07c41dd 100755\n--- a/docker/test/fasttest/run.sh\n+++ b/docker/test/fasttest/run.sh\n@@ -312,6 +312,7 @@ function run_tests\n         01798_uniq_theta_sketch\n         01799_long_uniq_theta_sketch\n         01890_stem                               # depends on libstemmer_c\n+        02003_compress_bz2                       # depends on bzip2\n         collate\n         collation\n         _orc_\ndiff --git a/tests/queries/0_stateless/02003_compress_bz2.reference b/tests/queries/0_stateless/02003_compress_bz2.reference\nnew file mode 100644\nindex 000000000000..8ab686eafeb1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02003_compress_bz2.reference\n@@ -0,0 +1,1 @@\n+Hello, World!\ndiff --git a/tests/queries/0_stateless/02003_compress_bz2.sh b/tests/queries/0_stateless/02003_compress_bz2.sh\nnew file mode 100755\nindex 000000000000..b65ce2f233b9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02003_compress_bz2.sh\n@@ -0,0 +1,17 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+USER_FILES_PATH=$(clickhouse-client --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+WORKING_FOLDER_02003=\"${USER_FILES_PATH}/${CLICKHOUSE_DATABASE}\"\n+\n+rm -rf \"${WORKING_FOLDER_02003}\"\n+mkdir \"${WORKING_FOLDER_02003}\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM (SELECT 'Hello, World!' as String) INTO OUTFILE '${WORKING_FOLDER_02003}/bz2_compression.bz2'\"\n+bzip2 -t ${WORKING_FOLDER_02003}/bz2_compression.bz2\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM file('${WORKING_FOLDER_02003}/bz2_compression.bz2', 'TabSeparated', 'col String')\"\n+\n+rm -rf \"${WORKING_FOLDER_02003}\"\n",
  "problem_statement": "General compression methods: support for bz2.\n**Use case**\r\nImport and export of `bz2` files directly.\r\n\r\n**Additional context**\r\nIt's extremely slow. But the use case is when there is already files in bz2 format and you have to deal with it.\n",
  "hints_text": "Which library should use to implement this?\nThe original library is ok: https://gitlab.com/federicomenaquintero/bzip2",
  "created_at": "2021-08-07T00:02:00Z"
}