{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12343,
  "instance_id": "ClickHouse__ClickHouse-12343",
  "issue_numbers": [
    "12135"
  ],
  "base_commit": "cf49a839806290c41a3a1ccd5808687d7ccaca78",
  "patch": "diff --git a/src/Common/Macros.cpp b/src/Common/Macros.cpp\nindex cb257cf95a48..7b5a896015b0 100644\n--- a/src/Common/Macros.cpp\n+++ b/src/Common/Macros.cpp\n@@ -22,7 +22,11 @@ Macros::Macros(const Poco::Util::AbstractConfiguration & config, const String &\n     }\n }\n \n-String Macros::expand(const String & s, size_t level, const String & database_name, const String & table_name) const\n+String Macros::expand(const String & s,\n+                      size_t level,\n+                      const String & database_name,\n+                      const String & table_name,\n+                      const UUID & uuid) const\n {\n     if (s.find('{') == String::npos)\n         return s;\n@@ -64,10 +68,12 @@ String Macros::expand(const String & s, size_t level, const String & database_na\n             res += database_name;\n         else if (macro_name == \"table\" && !table_name.empty())\n             res += table_name;\n+        else if (macro_name == \"uuid\" && uuid != UUIDHelpers::Nil)\n+            res += toString(uuid);\n         else\n             throw Exception(\"No macro '\" + macro_name +\n-                \"' in config while processing substitutions in '\" + s + \"' at \"\n-                + toString(begin), ErrorCodes::SYNTAX_ERROR);\n+                \"' in config while processing substitutions in '\" + s + \"' at '\"\n+                + toString(begin) + \"' or macro is not supported here\", ErrorCodes::SYNTAX_ERROR);\n \n         pos = end + 1;\n     }\n@@ -82,9 +88,9 @@ String Macros::getValue(const String & key) const\n     throw Exception(\"No macro \" + key + \" in config\", ErrorCodes::SYNTAX_ERROR);\n }\n \n-String Macros::expand(const String & s, const String & database_name, const String & table_name) const\n+String Macros::expand(const String & s, const StorageID & table_id, bool allow_uuid) const\n {\n-    return expand(s, 0, database_name, table_name);\n+    return expand(s, 0, table_id.database_name, table_id.table_name, allow_uuid ? table_id.uuid : UUIDHelpers::Nil);\n }\n \n Names Macros::expand(const Names & source_names, size_t level) const\ndiff --git a/src/Common/Macros.h b/src/Common/Macros.h\nindex 3409cf542b84..cee133b0ccb8 100644\n--- a/src/Common/Macros.h\n+++ b/src/Common/Macros.h\n@@ -2,6 +2,7 @@\n \n #include <Core/Types.h>\n #include <Core/Names.h>\n+#include <Interpreters/StorageID.h>\n \n #include <map>\n \n@@ -30,9 +31,13 @@ class Macros\n       * If {database} and {table} macros aren`t defined explicitly, expand them as database_name and table_name respectively.\n       * level - the level of recursion.\n       */\n-    String expand(const String & s, size_t level = 0, const String & database_name = \"\", const String & table_name = \"\") const;\n+    String expand(const String & s,\n+                  size_t level = 0,\n+                  const String & database_name = \"\",\n+                  const String & table_name = \"\",\n+                  const UUID & uuid = UUIDHelpers::Nil) const;\n \n-    String expand(const String & s, const String & database_name, const String & table_name) const;\n+    String expand(const String & s, const StorageID & table_id, bool allow_uuid) const;\n \n \n     /** Apply expand for the list.\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 07fdeaabf22f..ff137a54381d 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -347,8 +347,8 @@ class IColumn;\n     M(UInt64, min_free_disk_space_for_temporary_data, 0, \"The minimum disk space to keep while writing temporary data used in external sorting and aggregation.\", 0) \\\n     \\\n     M(DefaultDatabaseEngine, default_database_engine, DefaultDatabaseEngine::Ordinary, \"Default database engine.\", 0) \\\n-    M(Bool, allow_experimental_database_atomic, false, \"Allow to create database with Engine=Atomic.\", 0) \\\n-    M(Bool, show_table_uuid_in_table_create_query_if_not_nil, true, \"For tables in databases with Engine=Atomic show UUID of the table in its CREATE query.\", 0) \\\n+    M(Bool, allow_experimental_database_atomic, true, \"Allow to create database with Engine=Atomic.\", 0) \\\n+    M(Bool, show_table_uuid_in_table_create_query_if_not_nil, false, \"For tables in databases with Engine=Atomic show UUID of the table in its CREATE query.\", 0) \\\n     M(Bool, enable_scalar_subquery_optimization, true, \"If it is set to true, prevent scalar subqueries from (de)serializing large scalar values and possibly avoid running the same subquery more than once.\", 0) \\\n     M(Bool, optimize_trivial_count_query, true, \"Process trivial 'SELECT count() FROM table' query from metadata.\", 0) \\\n     M(UInt64, mutations_sync, 0, \"Wait for synchronous execution of ALTER TABLE UPDATE/DELETE queries (mutations). 0 - execute asynchronously. 1 - wait current server. 2 - wait all replicas if they exist.\", 0) \\\ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex ff30b95d139f..1223f9a1d56d 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -8,6 +8,7 @@\n #include <Common/renameat2.h>\n #include <Storages/StorageMaterializedView.h>\n #include <Interpreters/Context.h>\n+#include <Interpreters/ExternalDictionariesLoader.h>\n #include <filesystem>\n \n \n@@ -16,10 +17,13 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int UNKNOWN_TABLE;\n+    extern const int UNKNOWN_DATABASE;\n     extern const int TABLE_ALREADY_EXISTS;\n     extern const int CANNOT_ASSIGN_ALTER;\n     extern const int DATABASE_NOT_EMPTY;\n     extern const int NOT_IMPLEMENTED;\n+    extern const int FILE_ALREADY_EXISTS;\n+    extern const int INCORRECT_QUERY;\n }\n \n class AtomicDatabaseTablesSnapshotIterator final : public DatabaseTablesSnapshotIterator\n@@ -31,13 +35,15 @@ class AtomicDatabaseTablesSnapshotIterator final : public DatabaseTablesSnapshot\n };\n \n \n-DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, Context & context_)\n+DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, Context & context_)\n     : DatabaseOrdinary(name_, std::move(metadata_path_), \"store/\", \"DatabaseAtomic (\" + name_ + \")\", context_)\n-    , path_to_table_symlinks(context_.getPath() + \"data/\" + escapeForFileName(name_) + \"/\")\n+    , path_to_table_symlinks(global_context.getPath() + \"data/\" + escapeForFileName(name_) + \"/\")\n+    , path_to_metadata_symlink(global_context.getPath() + \"metadata/\" + escapeForFileName(name_))\n+    , db_uuid(uuid)\n {\n-    /// Symlinks in data/db_name/ directory are not used by ClickHouse,\n-    /// it's needed only for convenient introspection.\n+    assert(db_uuid != UUIDHelpers::Nil);\n     Poco::File(path_to_table_symlinks).createDirectories();\n+    tryCreateMetadataSymlink();\n }\n \n String DatabaseAtomic::getTableDataPath(const String & table_name) const\n@@ -45,7 +51,7 @@ String DatabaseAtomic::getTableDataPath(const String & table_name) const\n     std::lock_guard lock(mutex);\n     auto it = table_name_to_path.find(table_name);\n     if (it == table_name_to_path.end())\n-        throw Exception(\"Table \" + table_name + \" not found in database \" + getDatabaseName(), ErrorCodes::UNKNOWN_TABLE);\n+        throw Exception(\"Table \" + table_name + \" not found in database \" + database_name, ErrorCodes::UNKNOWN_TABLE);\n     assert(it->second != data_path && !it->second.empty());\n     return it->second;\n }\n@@ -59,7 +65,15 @@ String DatabaseAtomic::getTableDataPath(const ASTCreateQuery & query) const\n \n void DatabaseAtomic::drop(const Context &)\n {\n-    Poco::File(path_to_table_symlinks).remove(true);\n+    try\n+    {\n+        Poco::File(path_to_metadata_symlink).remove();\n+        Poco::File(path_to_table_symlinks).remove(true);\n+    }\n+    catch (...)\n+    {\n+        LOG_WARNING(log, getCurrentExceptionMessage(true));\n+    }\n     Poco::File(getMetadataPath()).remove(true);\n }\n \n@@ -69,10 +83,10 @@ void DatabaseAtomic::attachTable(const String & name, const StoragePtr & table,\n     DetachedTables not_in_use;\n     std::unique_lock lock(mutex);\n     not_in_use = cleenupDetachedTables();\n-    assertDetachedTableNotInUse(table->getStorageID().uuid);\n+    auto table_id = table->getStorageID();\n+    assertDetachedTableNotInUse(table_id.uuid);\n     DatabaseWithDictionaries::attachTableUnlocked(name, table, lock);\n     table_name_to_path.emplace(std::make_pair(name, relative_table_path));\n-    tryCreateSymlink(name, relative_table_path);\n }\n \n StoragePtr DatabaseAtomic::detachTable(const String & name)\n@@ -83,7 +97,6 @@ StoragePtr DatabaseAtomic::detachTable(const String & name)\n     table_name_to_path.erase(name);\n     detached_tables.emplace(table->getStorageID().uuid, table);\n     not_in_use = cleenupDetachedTables();\n-    tryRemoveSymlink(name);\n     return table;\n }\n \n@@ -107,16 +120,20 @@ void DatabaseAtomic::dropTable(const Context &, const String & table_name, bool\n }\n \n void DatabaseAtomic::renameTable(const Context & context, const String & table_name, IDatabase & to_database,\n-                                 const String & to_table_name, bool exchange)\n+                                 const String & to_table_name, bool exchange, bool dictionary)\n {\n     if (typeid(*this) != typeid(to_database))\n     {\n         if (!typeid_cast<DatabaseOrdinary *>(&to_database))\n             throw Exception(\"Moving tables between databases of different engines is not supported\", ErrorCodes::NOT_IMPLEMENTED);\n         /// Allow moving tables between Atomic and Ordinary (with table lock)\n-        DatabaseOnDisk::renameTable(context, table_name, to_database, to_table_name, exchange);\n+        DatabaseOnDisk::renameTable(context, table_name, to_database, to_table_name, exchange, dictionary);\n         return;\n     }\n+\n+    if (exchange && dictionary)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot exchange dictionaries\");\n+\n     auto & other_db = dynamic_cast<DatabaseAtomic &>(to_database);\n     bool inside_database = this == &other_db;\n \n@@ -125,16 +142,24 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n \n     auto detach = [](DatabaseAtomic & db, const String & table_name_)\n     {\n-        auto table_data_path_saved = db.table_name_to_path.find(table_name_)->second;\n+        auto it = db.table_name_to_path.find(table_name_);\n+        String table_data_path_saved;\n+        /// Path can be not set for DDL dictionaries, but it does not matter for StorageDictionary.\n+        if (it != db.table_name_to_path.end())\n+            table_data_path_saved = it->second;\n+        assert(!table_data_path_saved.empty() || db.dictionaries.find(table_name_) != db.dictionaries.end());\n         db.tables.erase(table_name_);\n         db.table_name_to_path.erase(table_name_);\n-        db.tryRemoveSymlink(table_name_);\n+        if (!table_data_path_saved.empty())\n+            db.tryRemoveSymlink(table_name_);\n         return table_data_path_saved;\n     };\n \n     auto attach = [](DatabaseAtomic & db, const String & table_name_, const String & table_data_path_, const StoragePtr & table_)\n     {\n         db.tables.emplace(table_name_, table_);\n+        if (table_data_path_.empty())\n+            return;\n         db.table_name_to_path.emplace(table_name_, table_data_path_);\n         db.tryCreateSymlink(table_name_, table_data_path_);\n     };\n@@ -169,6 +194,17 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n         db_lock = std::unique_lock{mutex};\n     }\n \n+    bool is_dictionary = dictionaries.find(table_name) != dictionaries.end();\n+    if (exchange && other_db.dictionaries.find(to_table_name) != other_db.dictionaries.end())\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot exchange dictionaries\");\n+\n+    if (dictionary != is_dictionary)\n+        throw Exception(ErrorCodes::INCORRECT_QUERY,\n+                        \"Use RENAME DICTIONARY for dictionaries and RENAME TABLE for tables.\");\n+\n+    if (is_dictionary && !inside_database)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot move dictionary to other database\");\n+\n     StoragePtr table = getTableUnlocked(table_name, db_lock);\n     assert_can_move_mat_view(table);\n     StoragePtr other_table;\n@@ -189,13 +225,15 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n     if (exchange)\n         other_table_data_path = detach(other_db, to_table_name);\n \n-    table->renameInMemory({other_db.getDatabaseName(), to_table_name, table->getStorageID().uuid});\n+    auto old_table_id = table->getStorageID();\n+\n+    table->renameInMemory({other_db.database_name, to_table_name, old_table_id.uuid});\n     if (exchange)\n-        other_table->renameInMemory({getDatabaseName(), table_name, other_table->getStorageID().uuid});\n+        other_table->renameInMemory({database_name, table_name, other_table->getStorageID().uuid});\n \n     if (!inside_database)\n     {\n-        DatabaseCatalog::instance().updateUUIDMapping(table->getStorageID().uuid, other_db.shared_from_this(), table);\n+        DatabaseCatalog::instance().updateUUIDMapping(old_table_id.uuid, other_db.shared_from_this(), table);\n         if (exchange)\n             DatabaseCatalog::instance().updateUUIDMapping(other_table->getStorageID().uuid, shared_from_this(), other_table);\n     }\n@@ -203,6 +241,12 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n     attach(other_db, to_table_name, table_data_path, table);\n     if (exchange)\n         attach(*this, table_name, other_table_data_path, other_table);\n+\n+    if (is_dictionary)\n+    {\n+        auto new_table_id = StorageID(other_db.database_name, to_table_name, old_table_id.uuid);\n+        renameDictionaryInMemoryUnlocked(old_table_id, new_table_id);\n+    }\n }\n \n void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const StoragePtr & table,\n@@ -213,6 +257,9 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n     try\n     {\n         std::unique_lock lock{mutex};\n+        if (query.database != database_name)\n+            throw Exception(ErrorCodes::UNKNOWN_DATABASE, \"Database was renamed to `{}`, cannot create table in `{}`\",\n+                            database_name, query.database);\n         not_in_use = cleenupDetachedTables();\n         assertDetachedTableNotInUse(query.uuid);\n         renameNoReplace(table_metadata_tmp_path, table_metadata_path);\n@@ -229,7 +276,8 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n \n void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path)\n {\n-    SCOPE_EXIT({ std::error_code code; std::filesystem::remove(table_metadata_tmp_path, code); });\n+    bool check_file_exists = supportsRenameat2();\n+    SCOPE_EXIT({ std::error_code code; if (check_file_exists) std::filesystem::remove(table_metadata_tmp_path, code); });\n \n     std::unique_lock lock{mutex};\n     auto actual_table_id = getTableUnlocked(table_id.table_name, lock)->getStorageID();\n@@ -237,7 +285,10 @@ void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String &\n     if (table_id.uuid != actual_table_id.uuid)\n         throw Exception(\"Cannot alter table because it was renamed\", ErrorCodes::CANNOT_ASSIGN_ALTER);\n \n-    renameExchange(table_metadata_tmp_path, table_metadata_path);\n+    if (check_file_exists)\n+        renameExchange(table_metadata_tmp_path, table_metadata_path);\n+    else\n+        std::filesystem::rename(table_metadata_tmp_path, table_metadata_path);\n }\n \n void DatabaseAtomic::assertDetachedTableNotInUse(const UUID & uuid)\n@@ -330,7 +381,7 @@ void DatabaseAtomic::tryCreateSymlink(const String & table_name, const String &\n     }\n     catch (...)\n     {\n-        tryLogCurrentException(log);\n+        LOG_WARNING(log, getCurrentExceptionMessage(true));\n     }\n }\n \n@@ -343,9 +394,108 @@ void DatabaseAtomic::tryRemoveSymlink(const String & table_name)\n     }\n     catch (...)\n     {\n-        tryLogCurrentException(log);\n+        LOG_WARNING(log, getCurrentExceptionMessage(true));\n     }\n }\n \n+void DatabaseAtomic::tryCreateMetadataSymlink()\n+{\n+    /// Symlinks in data/db_name/ directory and metadata/db_name/ are not used by ClickHouse,\n+    /// it's needed only for convenient introspection.\n+    assert(path_to_metadata_symlink != metadata_path);\n+    Poco::File metadata_symlink(path_to_metadata_symlink);\n+    if (metadata_symlink.exists())\n+    {\n+        if (!metadata_symlink.isLink())\n+            throw Exception(ErrorCodes::FILE_ALREADY_EXISTS, \"Directory {} exists\", path_to_metadata_symlink);\n+    }\n+    else\n+    {\n+        try\n+        {\n+            Poco::File{metadata_path}.linkTo(path_to_metadata_symlink, Poco::File::LINK_SYMBOLIC);\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(log);\n+        }\n+    }\n+}\n+\n+void DatabaseAtomic::renameDatabase(const String & new_name)\n+{\n+    /// CREATE, ATTACH, DROP, DETACH and RENAME DATABASE must hold DDLGuard\n+    try\n+    {\n+        Poco::File(path_to_metadata_symlink).remove();\n+    }\n+    catch (...)\n+    {\n+        LOG_WARNING(log, getCurrentExceptionMessage(true));\n+    }\n+\n+    auto new_name_escaped = escapeForFileName(new_name);\n+    auto old_database_metadata_path = global_context.getPath() + \"metadata/\" + escapeForFileName(getDatabaseName()) + \".sql\";\n+    auto new_database_metadata_path = global_context.getPath() + \"metadata/\" + new_name_escaped + \".sql\";\n+    renameNoReplace(old_database_metadata_path, new_database_metadata_path);\n+\n+    String old_path_to_table_symlinks;\n+\n+    {\n+        std::lock_guard lock(mutex);\n+        DatabaseCatalog::instance().updateDatabaseName(database_name, new_name);\n+        database_name = new_name;\n+\n+        for (auto & table : tables)\n+        {\n+            auto table_id = table.second->getStorageID();\n+            table_id.database_name = database_name;\n+            table.second->renameInMemory(table_id);\n+        }\n+\n+        for (auto & dict : dictionaries)\n+        {\n+            auto old_name = StorageID(dict.second.create_query);\n+            auto name = old_name;\n+            name.database_name = database_name;\n+            renameDictionaryInMemoryUnlocked(old_name, name);\n+        }\n+\n+        path_to_metadata_symlink = global_context.getPath() + \"metadata/\" + new_name_escaped;\n+        old_path_to_table_symlinks = path_to_table_symlinks;\n+        path_to_table_symlinks = global_context.getPath() + \"data/\" + new_name_escaped + \"/\";\n+    }\n+\n+    Poco::File(old_path_to_table_symlinks).renameTo(path_to_table_symlinks);\n+    tryCreateMetadataSymlink();\n+}\n+\n+void DatabaseAtomic::renameDictionaryInMemoryUnlocked(const StorageID & old_name, const StorageID & new_name)\n+{\n+    auto it = dictionaries.find(old_name.table_name);\n+    assert(it != dictionaries.end());\n+    assert(it->second.config->getString(\"dictionary.uuid\") == toString(old_name.uuid));\n+    assert(old_name.uuid == new_name.uuid);\n+    it->second.config->setString(\"dictionary.database\", new_name.database_name);\n+    it->second.config->setString(\"dictionary.name\", new_name.table_name);\n+    auto & create = it->second.create_query->as<ASTCreateQuery &>();\n+    create.database = new_name.database_name;\n+    create.table = new_name.table_name;\n+    assert(create.uuid == new_name.uuid);\n+\n+    if (old_name.table_name != new_name.table_name)\n+    {\n+        auto attach_info = std::move(it->second);\n+        dictionaries.erase(it);\n+        dictionaries.emplace(new_name.table_name, std::move(attach_info));\n+    }\n+\n+    auto result = external_loader.getLoadResult(toString(old_name.uuid));\n+    if (!result.object)\n+        return;\n+    const auto & dict = dynamic_cast<const IDictionaryBase &>(*result.object);\n+    dict.updateDictionaryName(new_name);\n+}\n+\n }\n \ndiff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h\nindex 71428fdb4201..f809fcefef3d 100644\n--- a/src/Databases/DatabaseAtomic.h\n+++ b/src/Databases/DatabaseAtomic.h\n@@ -21,16 +21,20 @@ class DatabaseAtomic : public DatabaseOrdinary\n {\n public:\n \n-    DatabaseAtomic(String name_, String metadata_path_, Context & context_);\n+    DatabaseAtomic(String name_, String metadata_path_, UUID uuid, Context & context_);\n \n     String getEngineName() const override { return \"Atomic\"; }\n+    UUID getUUID() const override { return db_uuid; }\n+\n+    void renameDatabase(const String & new_name) override;\n \n     void renameTable(\n             const Context & context,\n             const String & table_name,\n             IDatabase & to_database,\n             const String & to_table_name,\n-            bool exchange) override;\n+            bool exchange,\n+            bool dictionary) override;\n \n     void dropTable(const Context & context, const String & table_name, bool no_delay) override;\n \n@@ -51,6 +55,9 @@ class DatabaseAtomic : public DatabaseOrdinary\n \n     UUID tryGetTableUUID(const String & table_name) const override;\n \n+    void tryCreateSymlink(const String & table_name, const String & actual_data_path);\n+    void tryRemoveSymlink(const String & table_name);\n+\n private:\n     void commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path) override;\n     void commitCreateTable(const ASTCreateQuery & query, const StoragePtr & table,\n@@ -60,15 +67,18 @@ class DatabaseAtomic : public DatabaseOrdinary\n     typedef std::unordered_map<UUID, StoragePtr> DetachedTables;\n     [[nodiscard]] DetachedTables cleenupDetachedTables();\n \n-    void tryCreateSymlink(const String & table_name, const String & actual_data_path);\n-    void tryRemoveSymlink(const String & table_name);\n+    void tryCreateMetadataSymlink();\n+\n+    void renameDictionaryInMemoryUnlocked(const StorageID & old_name, const StorageID & new_name);\n \n     //TODO store path in DatabaseWithOwnTables::tables\n     typedef std::unordered_map<String, String> NameToPathMap;\n     NameToPathMap table_name_to_path;\n \n     DetachedTables detached_tables;\n-    const String path_to_table_symlinks;\n+    String path_to_table_symlinks;\n+    String path_to_metadata_symlink;\n+    const UUID db_uuid;\n };\n \n }\ndiff --git a/src/Databases/DatabaseDictionary.cpp b/src/Databases/DatabaseDictionary.cpp\nindex 986e36de8cf6..3732139c66a1 100644\n--- a/src/Databases/DatabaseDictionary.cpp\n+++ b/src/Databases/DatabaseDictionary.cpp\n@@ -55,9 +55,10 @@ Tables DatabaseDictionary::listTables(const FilterByNameFunction & filter_by_nam\n {\n     Tables tables;\n     auto load_results = global_context.getExternalDictionariesLoader().getLoadResults(filter_by_name);\n+    String db_name = getDatabaseName();\n     for (auto & load_result : load_results)\n     {\n-        auto storage = createStorageDictionary(getDatabaseName(), load_result);\n+        auto storage = createStorageDictionary(db_name, load_result);\n         if (storage)\n             tables.emplace(storage->getStorageID().table_name, storage);\n     }\n@@ -77,7 +78,7 @@ StoragePtr DatabaseDictionary::tryGetTable(const String & table_name, const Cont\n \n DatabaseTablesIteratorPtr DatabaseDictionary::getTablesIterator(const Context &, const FilterByNameFunction & filter_by_table_name)\n {\n-    return std::make_unique<DatabaseTablesSnapshotIterator>(listTables(filter_by_table_name));\n+    return std::make_unique<DatabaseTablesSnapshotIterator>(listTables(filter_by_table_name), getDatabaseName());\n }\n \n bool DatabaseDictionary::empty() const\n@@ -100,7 +101,7 @@ ASTPtr DatabaseDictionary::getCreateTableQueryImpl(const String & table_name, co\n         }\n \n         auto names_and_types = StorageDictionary::getNamesAndTypes(ExternalDictionariesLoader::getDictionaryStructure(*load_result.config));\n-        buffer << \"CREATE TABLE \" << backQuoteIfNeed(database_name) << '.' << backQuoteIfNeed(table_name) << \" (\";\n+        buffer << \"CREATE TABLE \" << backQuoteIfNeed(getDatabaseName()) << '.' << backQuoteIfNeed(table_name) << \" (\";\n         buffer << StorageDictionary::generateNamesAndTypesDescription(names_and_types);\n         buffer << \") Engine = Dictionary(\" << backQuoteIfNeed(table_name) << \")\";\n     }\n@@ -123,7 +124,7 @@ ASTPtr DatabaseDictionary::getCreateDatabaseQuery() const\n     String query;\n     {\n         WriteBufferFromString buffer(query);\n-        buffer << \"CREATE DATABASE \" << backQuoteIfNeed(database_name) << \" ENGINE = Dictionary\";\n+        buffer << \"CREATE DATABASE \" << backQuoteIfNeed(getDatabaseName()) << \" ENGINE = Dictionary\";\n     }\n     auto settings = global_context.getSettingsRef();\n     ParserCreateQuery parser;\ndiff --git a/src/Databases/DatabaseDictionary.h b/src/Databases/DatabaseDictionary.h\nindex b61c85033e83..c3c6a53a894e 100644\n--- a/src/Databases/DatabaseDictionary.h\n+++ b/src/Databases/DatabaseDictionary.h\n@@ -47,8 +47,6 @@ class DatabaseDictionary final : public IDatabase\n     ASTPtr getCreateTableQueryImpl(const String & table_name, const Context & context, bool throw_on_error) const override;\n \n private:\n-    mutable std::mutex mutex;\n-\n     Poco::Logger * log;\n     const Context & global_context;\n \ndiff --git a/src/Databases/DatabaseFactory.cpp b/src/Databases/DatabaseFactory.cpp\nindex f27bc509ebea..3b84dfa8949e 100644\n--- a/src/Databases/DatabaseFactory.cpp\n+++ b/src/Databases/DatabaseFactory.cpp\n@@ -12,6 +12,7 @@\n #include <Common/parseAddress.h>\n #include \"DatabaseFactory.h\"\n #include <Poco/File.h>\n+#include <Poco/Path.h>\n \n #if !defined(ARCADIA_BUILD)\n #    include \"config_core.h\"\n@@ -34,15 +35,19 @@ namespace ErrorCodes\n     extern const int CANNOT_CREATE_DATABASE;\n }\n \n-DatabasePtr DatabaseFactory::get(\n-    const String & database_name, const String & metadata_path, const ASTStorage * engine_define, Context & context)\n+DatabasePtr DatabaseFactory::get(const ASTCreateQuery & create, const String & metadata_path, Context & context)\n {\n     bool created = false;\n \n     try\n     {\n+        /// Creates store/xxx/ for Atomic\n+        Poco::File(Poco::Path(metadata_path).makeParent()).createDirectories();\n+        /// Before 20.7 it's possible that .sql metadata file does not exist for some old database.\n+        /// In this case Ordinary database is created on server startup if the corresponding metadata directory exists.\n+        /// So we should remove metadata directory if database creation failed.\n         created = Poco::File(metadata_path).createDirectory();\n-        return getImpl(database_name, metadata_path, engine_define, context);\n+        return getImpl(create, metadata_path, context);\n     }\n     catch (...)\n     {\n@@ -64,10 +69,12 @@ static inline ValueType safeGetLiteralValue(const ASTPtr &ast, const String &eng\n     return ast->as<ASTLiteral>()->value.safeGet<ValueType>();\n }\n \n-DatabasePtr DatabaseFactory::getImpl(\n-    const String & database_name, const String & metadata_path, const ASTStorage * engine_define, Context & context)\n+DatabasePtr DatabaseFactory::getImpl(const ASTCreateQuery & create, const String & metadata_path, Context & context)\n {\n-    String engine_name = engine_define->engine->name;\n+    const auto * engine_define = create.storage;\n+    const String & database_name = create.database;\n+    const String & engine_name = engine_define->engine->name;\n+    const UUID & uuid = create.uuid;\n \n     if (engine_name != \"MySQL\" && engine_name != \"Lazy\" && engine_define->engine->arguments)\n         throw Exception(\"Database engine \" + engine_name + \" cannot have arguments\", ErrorCodes::BAD_ARGUMENTS);\n@@ -80,7 +87,7 @@ DatabasePtr DatabaseFactory::getImpl(\n     if (engine_name == \"Ordinary\")\n         return std::make_shared<DatabaseOrdinary>(database_name, metadata_path, context);\n     else if (engine_name == \"Atomic\")\n-        return std::make_shared<DatabaseAtomic>(database_name, metadata_path, context);\n+        return std::make_shared<DatabaseAtomic>(database_name, metadata_path, uuid, context);\n     else if (engine_name == \"Memory\")\n         return std::make_shared<DatabaseMemory>(database_name, context);\n     else if (engine_name == \"Dictionary\")\ndiff --git a/src/Databases/DatabaseFactory.h b/src/Databases/DatabaseFactory.h\nindex 7df8ee8ada05..88d33dc1cd5f 100644\n--- a/src/Databases/DatabaseFactory.h\n+++ b/src/Databases/DatabaseFactory.h\n@@ -6,14 +6,14 @@\n namespace DB\n {\n \n-class ASTStorage;\n+class ASTCreateQuery;\n \n class DatabaseFactory\n {\n public:\n-    static DatabasePtr get(const String & database_name, const String & metadata_path, const ASTStorage * engine_define, Context & context);\n+    static DatabasePtr get(const ASTCreateQuery & create, const String & metadata_path, Context & context);\n \n-    static DatabasePtr getImpl(const String & database_name, const String & metadata_path, const ASTStorage * engine_define, Context & context);\n+    static DatabasePtr getImpl(const ASTCreateQuery & create, const String & metadata_path, Context & context);\n };\n \n }\ndiff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp\nindex 11e5272110eb..a4be82690e4e 100644\n--- a/src/Databases/DatabaseLazy.cpp\n+++ b/src/Databases/DatabaseLazy.cpp\n@@ -78,10 +78,11 @@ void DatabaseLazy::renameTable(\n     const String & table_name,\n     IDatabase & to_database,\n     const String & to_table_name,\n-    bool exchange)\n+    bool exchange,\n+    bool dictionary)\n {\n     SCOPE_EXIT({ clearExpiredTables(); });\n-    DatabaseOnDisk::renameTable(context, table_name, to_database, to_table_name, exchange);\n+    DatabaseOnDisk::renameTable(context, table_name, to_database, to_table_name, exchange, dictionary);\n }\n \n \n@@ -91,7 +92,7 @@ time_t DatabaseLazy::getObjectMetadataModificationTime(const String & table_name\n     auto it = tables_cache.find(table_name);\n     if (it != tables_cache.end())\n         return it->second.metadata_modification_time;\n-    throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+    throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n }\n \n void DatabaseLazy::alterTable(\n@@ -160,7 +161,7 @@ void DatabaseLazy::attachTable(const String & table_name, const StoragePtr & tab\n                               std::forward_as_tuple(table_name),\n                               std::forward_as_tuple(table, current_time, DatabaseOnDisk::getObjectMetadataModificationTime(table_name)));\n     if (!inserted)\n-        throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n+        throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n \n     it->second.expiration_iterator = cache_expiration_queue.emplace(cache_expiration_queue.end(), current_time, table_name);\n }\n@@ -173,7 +174,7 @@ StoragePtr DatabaseLazy::detachTable(const String & table_name)\n         std::lock_guard lock(mutex);\n         auto it = tables_cache.find(table_name);\n         if (it == tables_cache.end())\n-            throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+            throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n         res = it->second.table;\n         if (it->second.expiration_iterator != cache_expiration_queue.end())\n             cache_expiration_queue.erase(it->second.expiration_iterator);\n@@ -230,7 +231,7 @@ StoragePtr DatabaseLazy::loadTable(const String & table_name) const\n         {\n             const auto & ast_create = ast->as<const ASTCreateQuery &>();\n             String table_data_path_relative = getTableDataPath(ast_create);\n-            table = createTableFromAST(ast_create, database_name, table_data_path_relative, context_copy, false).second;\n+            table = createTableFromAST(ast_create, getDatabaseName(), table_data_path_relative, context_copy, false).second;\n         }\n \n         if (!ast || !endsWith(table->getName(), \"Log\"))\n@@ -239,7 +240,7 @@ StoragePtr DatabaseLazy::loadTable(const String & table_name) const\n             std::lock_guard lock(mutex);\n             auto it = tables_cache.find(table_name);\n             if (it == tables_cache.end())\n-                throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+                throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n \n             if (it->second.expiration_iterator != cache_expiration_queue.end())\n                 cache_expiration_queue.erase(it->second.expiration_iterator);\n@@ -299,6 +300,7 @@ DatabaseLazyIterator::DatabaseLazyIterator(DatabaseLazy & database_, Strings &&\n     , iterator(table_names.begin())\n     , current_storage(nullptr)\n {\n+    database_name = database.database_name;\n }\n \n void DatabaseLazyIterator::next()\ndiff --git a/src/Databases/DatabaseLazy.h b/src/Databases/DatabaseLazy.h\nindex 2e24b687be58..3d3e5a8aed69 100644\n--- a/src/Databases/DatabaseLazy.h\n+++ b/src/Databases/DatabaseLazy.h\n@@ -42,7 +42,8 @@ class DatabaseLazy final : public DatabaseOnDisk\n         const String & table_name,\n         IDatabase & to_database,\n         const String & to_table_name,\n-        bool exchange) override;\n+        bool exchange,\n+        bool dictionary) override;\n \n     void alterTable(\n         const Context & context,\ndiff --git a/src/Databases/DatabaseMemory.cpp b/src/Databases/DatabaseMemory.cpp\nindex cd5591721976..221e54ce741a 100644\n--- a/src/Databases/DatabaseMemory.cpp\n+++ b/src/Databases/DatabaseMemory.cpp\n@@ -58,7 +58,7 @@ void DatabaseMemory::dropTable(\n ASTPtr DatabaseMemory::getCreateDatabaseQuery() const\n {\n     auto create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = database_name;\n+    create_query->database = getDatabaseName();\n     create_query->set(create_query->storage, std::make_shared<ASTStorage>());\n     create_query->storage->set(create_query->storage->engine, makeASTFunction(getEngineName()));\n     return create_query;\ndiff --git a/src/Databases/DatabaseMySQL.cpp b/src/Databases/DatabaseMySQL.cpp\nindex 56cd5c8088d5..3b026bf94685 100644\n--- a/src/Databases/DatabaseMySQL.cpp\n+++ b/src/Databases/DatabaseMySQL.cpp\n@@ -99,7 +99,7 @@ DatabaseTablesIteratorPtr DatabaseMySQL::getTablesIterator(const Context &, cons\n         if (!remove_or_detach_tables.count(table_name) && (!filter_by_table_name || filter_by_table_name(table_name)))\n             tables[table_name] = modify_time_and_storage.second;\n \n-    return std::make_unique<DatabaseTablesSnapshotIterator>(tables);\n+    return std::make_unique<DatabaseTablesSnapshotIterator>(tables, database_name);\n }\n \n bool DatabaseMySQL::isTableExist(const String & name, const Context &) const\n@@ -187,7 +187,7 @@ time_t DatabaseMySQL::getObjectMetadataModificationTime(const String & table_nam\n ASTPtr DatabaseMySQL::getCreateDatabaseQuery() const\n {\n     const auto & create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = database_name;\n+    create_query->database = getDatabaseName();\n     create_query->set(create_query->storage, database_engine_define);\n     return create_query;\n }\n@@ -378,11 +378,11 @@ void DatabaseMySQL::attachTable(const String & table_name, const StoragePtr & st\n     std::lock_guard<std::mutex> lock{mutex};\n \n     if (!local_tables_cache.count(table_name))\n-        throw Exception(\"Cannot attach table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) +\n+        throw Exception(\"Cannot attach table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) +\n             \" because it does not exist.\", ErrorCodes::UNKNOWN_TABLE);\n \n     if (!remove_or_detach_tables.count(table_name))\n-        throw Exception(\"Cannot attach table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) +\n+        throw Exception(\"Cannot attach table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) +\n             \" because it already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n \n     /// We use the new storage to replace the original storage, because the original storage may have been dropped\n@@ -401,11 +401,11 @@ StoragePtr DatabaseMySQL::detachTable(const String & table_name)\n     std::lock_guard<std::mutex> lock{mutex};\n \n     if (remove_or_detach_tables.count(table_name))\n-        throw Exception(\"Table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) + \" is dropped\",\n+        throw Exception(\"Table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) + \" is dropped\",\n             ErrorCodes::TABLE_IS_DROPPED);\n \n     if (!local_tables_cache.count(table_name))\n-        throw Exception(\"Table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) + \" doesn't exist.\",\n+        throw Exception(\"Table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) + \" doesn't exist.\",\n             ErrorCodes::UNKNOWN_TABLE);\n \n     remove_or_detach_tables.emplace(table_name);\n@@ -441,16 +441,16 @@ void DatabaseMySQL::dropTable(const Context &, const String & table_name, bool /\n     Poco::File remove_flag(getMetadataPath() + '/' + escapeForFileName(table_name) + suffix);\n \n     if (remove_or_detach_tables.count(table_name))\n-        throw Exception(\"Table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) + \" is dropped\",\n+        throw Exception(\"Table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) + \" is dropped\",\n             ErrorCodes::TABLE_IS_DROPPED);\n \n     if (remove_flag.exists())\n-        throw Exception(\"The remove flag file already exists but the \" + backQuoteIfNeed(getDatabaseName()) +\n+        throw Exception(\"The remove flag file already exists but the \" + backQuoteIfNeed(database_name) +\n             \".\" + backQuoteIfNeed(table_name) + \" does not exists remove tables, it is bug.\", ErrorCodes::LOGICAL_ERROR);\n \n     auto table_iter = local_tables_cache.find(table_name);\n     if (table_iter == local_tables_cache.end())\n-        throw Exception(\"Table \" + backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name) + \" doesn't exist.\",\n+        throw Exception(\"Table \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(table_name) + \" doesn't exist.\",\n             ErrorCodes::UNKNOWN_TABLE);\n \n     remove_or_detach_tables.emplace(table_name);\ndiff --git a/src/Databases/DatabaseMySQL.h b/src/Databases/DatabaseMySQL.h\nindex 70d8dc81e0f2..5f45713537c8 100644\n--- a/src/Databases/DatabaseMySQL.h\n+++ b/src/Databases/DatabaseMySQL.h\n@@ -67,7 +67,6 @@ class DatabaseMySQL final : public IDatabase\n     ASTPtr database_engine_define;\n     String database_name_in_mysql;\n \n-    mutable std::mutex mutex;\n     std::atomic<bool> quit{false};\n     std::condition_variable cond;\n \ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 799ed041bef2..4e829357508f 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -20,6 +20,7 @@\n \n #include <Databases/DatabaseOrdinary.h>\n #include <Databases/DatabaseAtomic.h>\n+#include <Common/assert_cast.h>\n \n \n namespace DB\n@@ -145,7 +146,7 @@ void DatabaseOnDisk::createTable(\n {\n     const auto & settings = context.getSettingsRef();\n     const auto & create = query->as<ASTCreateQuery &>();\n-    assert(getDatabaseName() == create.database && table_name == create.table);\n+    assert(table_name == create.table);\n \n     /// Create a file with metadata if necessary - if the query is not ATTACH.\n     /// Write the query of `ATTACH table` to it.\n@@ -216,7 +217,8 @@ void DatabaseOnDisk::dropTable(const Context & context, const String & table_nam\n     String table_metadata_path = getObjectMetadataPath(table_name);\n     String table_metadata_path_drop = table_metadata_path + drop_suffix;\n     String table_data_path_relative = getTableDataPath(table_name);\n-    assert(!table_data_path_relative.empty());\n+    if (table_data_path_relative.empty())\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Path is empty\");\n \n     StoragePtr table = detachTable(table_name);\n     bool renamed = false;\n@@ -248,10 +250,13 @@ void DatabaseOnDisk::renameTable(\n         const String & table_name,\n         IDatabase & to_database,\n         const String & to_table_name,\n-        bool exchange)\n+        bool exchange,\n+        bool dictionary)\n {\n     if (exchange)\n         throw Exception(\"Tables can be exchanged only in Atomic databases\", ErrorCodes::NOT_IMPLEMENTED);\n+    if (dictionary)\n+        throw Exception(\"Dictionaries can be renamed only in Atomic databases\", ErrorCodes::NOT_IMPLEMENTED);\n \n     bool from_ordinary_to_atomic = false;\n     bool from_atomic_to_ordinary = false;\n@@ -305,6 +310,14 @@ void DatabaseOnDisk::renameTable(\n     to_database.createTable(context, to_table_name, table, attach_query);\n \n     Poco::File(table_metadata_path).remove();\n+\n+    /// Special case: usually no actions with symlinks are required when detaching/attaching table,\n+    /// but not when moving from Atomic database to Ordinary\n+    if (from_atomic_to_ordinary)\n+    {\n+        auto & atomic_db = assert_cast<DatabaseAtomic &>(*this);\n+        atomic_db.tryRemoveSymlink(table_name);\n+    }\n }\n \n ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const String & table_name, const Context &, bool throw_on_error) const\n@@ -332,9 +345,14 @@ ASTPtr DatabaseOnDisk::getCreateDatabaseQuery() const\n     ASTPtr ast;\n \n     auto settings = global_context.getSettingsRef();\n-    auto metadata_dir_path = getMetadataPath();\n-    auto database_metadata_path = metadata_dir_path.substr(0, metadata_dir_path.size() - 1) + \".sql\";\n-    ast = getCreateQueryFromMetadata(database_metadata_path, true);\n+    {\n+        std::lock_guard lock(mutex);\n+        auto database_metadata_path = global_context.getPath() + \"metadata/\" + escapeForFileName(database_name) + \".sql\";\n+        ast = parseQueryFromMetadata(log, global_context, database_metadata_path, true);\n+        auto & ast_create_query = ast->as<ASTCreateQuery &>();\n+        ast_create_query.attach = false;\n+        ast_create_query.database = database_name;\n+    }\n     if (!ast)\n     {\n         /// Handle databases (such as default) for which there are no database.sql files.\n@@ -462,7 +480,8 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(Poco::Logger * logger, const Conte\n       */\n     if (remove_empty && query.empty())\n     {\n-        LOG_ERROR(logger, \"File {} is empty. Removing.\", metadata_file_path);\n+        if (logger)\n+            LOG_ERROR(logger, \"File {} is empty. Removing.\", metadata_file_path);\n         Poco::File(metadata_file_path).remove();\n         return nullptr;\n     }\n@@ -480,12 +499,12 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(Poco::Logger * logger, const Conte\n         return nullptr;\n \n     auto & create = ast->as<ASTCreateQuery &>();\n-    if (create.uuid != UUIDHelpers::Nil)\n+    if (!create.table.empty() && create.uuid != UUIDHelpers::Nil)\n     {\n         String table_name = Poco::Path(metadata_file_path).makeFile().getBaseName();\n         table_name = unescapeForFileName(table_name);\n \n-        if (create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER)\n+        if (create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER && logger)\n             LOG_WARNING(logger, \"File {} contains both UUID and table name. Will use name `{}` instead of `{}`\", metadata_file_path, table_name, create.table);\n         create.table = table_name;\n     }\n@@ -501,7 +520,7 @@ ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const String & database_metada\n     {\n         auto & ast_create_query = ast->as<ASTCreateQuery &>();\n         ast_create_query.attach = false;\n-        ast_create_query.database = database_name;\n+        ast_create_query.database = getDatabaseName();\n     }\n \n     return ast;\ndiff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h\nindex d4fb9b2aa174..586491d4d29d 100644\n--- a/src/Databases/DatabaseOnDisk.h\n+++ b/src/Databases/DatabaseOnDisk.h\n@@ -49,7 +49,8 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n         const String & table_name,\n         IDatabase & to_database,\n         const String & to_table_name,\n-        bool exchange) override;\n+        bool exchange,\n+        bool dictionary) override;\n \n     ASTPtr getCreateDatabaseQuery() const override;\n \ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex 1e82420298be..45a7c1d2c66f 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -129,6 +129,7 @@ void DatabaseOrdinary::loadStoredObjects(Context & context, bool has_force_resto\n             if (ast)\n             {\n                 auto * create_query = ast->as<ASTCreateQuery>();\n+                create_query->database = database_name;\n                 std::lock_guard lock{file_names_mutex};\n                 file_names[file_name] = ast;\n                 total_dictionaries += create_query->is_dictionary;\n@@ -165,7 +166,7 @@ void DatabaseOrdinary::loadStoredObjects(Context & context, bool has_force_resto\n                     context,\n                     create_query,\n                     *this,\n-                    getDatabaseName(),\n+                    database_name,\n                     getMetadataPath() + name_with_query.first,\n                     has_force_restore_data_flag);\n \ndiff --git a/src/Databases/DatabaseWithDictionaries.cpp b/src/Databases/DatabaseWithDictionaries.cpp\nindex 9be7e4d8b3e1..f724faac637e 100644\n--- a/src/Databases/DatabaseWithDictionaries.cpp\n+++ b/src/Databases/DatabaseWithDictionaries.cpp\n@@ -34,21 +34,30 @@ namespace ErrorCodes\n \n void DatabaseWithDictionaries::attachDictionary(const String & dictionary_name, const DictionaryAttachInfo & attach_info)\n {\n-    String full_name = getDatabaseName() + \".\" + dictionary_name;\n+    auto dict_id = StorageID(attach_info.create_query);\n+    String internal_name = dict_id.getInternalDictionaryName();\n+    assert(attach_info.create_query->as<const ASTCreateQuery &>().table == dictionary_name);\n+    assert(!dict_id.database_name.empty());\n     {\n         std::unique_lock lock(mutex);\n         auto [it, inserted] = dictionaries.emplace(dictionary_name, attach_info);\n         if (!inserted)\n-            throw Exception(\"Dictionary \" + full_name + \" already exists.\", ErrorCodes::DICTIONARY_ALREADY_EXISTS);\n+            throw Exception(ErrorCodes::DICTIONARY_ALREADY_EXISTS,\n+                            \"Dictionary {} already exists.\", dict_id.getNameForLogs());\n \n         /// Attach the dictionary as table too.\n         try\n         {\n+            /// TODO Make StorageDictionary an owner of IDictionaryBase objects.\n+            /// All DDL operations with dictionaries will work with StorageDictionary table,\n+            /// and StorageDictionary will be responsible for loading of DDL dictionaries.\n+            /// ExternalLoaderDatabaseConfigRepository and other hacks related to ExternalLoader\n+            /// will not be longer required.\n             attachTableUnlocked(\n                 dictionary_name,\n                 StorageDictionary::create(\n-                    StorageID(getDatabaseName(), dictionary_name),\n-                    full_name,\n+                    dict_id,\n+                    internal_name,\n                     ExternalDictionariesLoader::getDictionaryStructure(*attach_info.config),\n                     StorageDictionary::Location::SameDatabaseAndNameAsDictionary),\n                 lock);\n@@ -60,11 +69,11 @@ void DatabaseWithDictionaries::attachDictionary(const String & dictionary_name,\n         }\n     }\n \n-    CurrentStatusInfo::set(CurrentStatusInfo::DictionaryStatus, full_name, static_cast<Int8>(ExternalLoaderStatus::NOT_LOADED));\n+    CurrentStatusInfo::set(CurrentStatusInfo::DictionaryStatus, internal_name, static_cast<Int8>(ExternalLoaderStatus::NOT_LOADED));\n \n     /// We want ExternalLoader::reloadConfig() to find out that the dictionary's config\n     /// has been added and in case `dictionaries_lazy_load == false` to load the dictionary.\n-    reloadDictionaryConfig(full_name);\n+    reloadDictionaryConfig(internal_name);\n }\n \n void DatabaseWithDictionaries::detachDictionary(const String & dictionary_name)\n@@ -75,20 +84,28 @@ void DatabaseWithDictionaries::detachDictionary(const String & dictionary_name)\n \n void DatabaseWithDictionaries::detachDictionaryImpl(const String & dictionary_name, DictionaryAttachInfo & attach_info)\n {\n-    String full_name = getDatabaseName() + \".\" + dictionary_name;\n+    auto dict_id = StorageID::createEmpty();\n+    String internal_name;\n \n     {\n         std::unique_lock lock(mutex);\n         auto it = dictionaries.find(dictionary_name);\n         if (it == dictionaries.end())\n-            throw Exception(\"Dictionary \" + full_name + \" doesn't exist.\", ErrorCodes::UNKNOWN_DICTIONARY);\n+            throw Exception(ErrorCodes::UNKNOWN_DICTIONARY,\n+                            \"Dictionary {}.{} doesn't exist.\", database_name, dictionary_name);\n+        dict_id = StorageID(it->second.create_query);\n+        internal_name = dict_id.getInternalDictionaryName();\n+        assert(dict_id.table_name == dictionary_name);\n+        assert(!dict_id.database_name.empty());\n+\n         attach_info = std::move(it->second);\n         dictionaries.erase(it);\n \n         /// Detach the dictionary as table too.\n         try\n         {\n-            detachTableUnlocked(dictionary_name, lock);\n+            if (!dict_id.hasUUID())\n+                detachTableUnlocked(dictionary_name, lock);\n         }\n         catch (...)\n         {\n@@ -97,11 +114,14 @@ void DatabaseWithDictionaries::detachDictionaryImpl(const String & dictionary_na\n         }\n     }\n \n-    CurrentStatusInfo::unset(CurrentStatusInfo::DictionaryStatus, full_name);\n+    CurrentStatusInfo::unset(CurrentStatusInfo::DictionaryStatus, internal_name);\n \n     /// We want ExternalLoader::reloadConfig() to find out that the dictionary's config\n     /// has been removed and to unload the dictionary.\n-    reloadDictionaryConfig(full_name);\n+    reloadDictionaryConfig(internal_name);\n+\n+    if (dict_id.hasUUID())\n+        detachTable(dictionary_name);\n }\n \n void DatabaseWithDictionaries::createDictionary(const Context & context, const String & dictionary_name, const ASTPtr & query)\n@@ -116,20 +136,22 @@ void DatabaseWithDictionaries::createDictionary(const Context & context, const S\n       * - rename .sql.tmp to .sql.\n       */\n \n+    auto dict_id = StorageID(query);\n+    assert(query->as<const ASTCreateQuery &>().table == dictionary_name);\n+    assert(!dict_id.database_name.empty());\n+\n     /// A race condition would be possible if a dictionary with the same name is simultaneously created using CREATE and using ATTACH.\n     /// But there is protection from it - see using DDLGuard in InterpreterCreateQuery.\n     if (isDictionaryExist(dictionary_name))\n-        throw Exception(\"Dictionary \" + backQuote(getDatabaseName()) + \".\" + backQuote(dictionary_name) + \" already exists.\", ErrorCodes::DICTIONARY_ALREADY_EXISTS);\n+        throw Exception(ErrorCodes::DICTIONARY_ALREADY_EXISTS, \"Dictionary {} already exists.\", dict_id.getFullTableName());\n \n     /// A dictionary with the same full name could be defined in *.xml config files.\n-    String full_name = getDatabaseName() + \".\" + dictionary_name;\n-    if (external_loader.getCurrentStatus(full_name) != ExternalLoader::Status::NOT_EXIST)\n-        throw Exception(\n-                \"Dictionary \" + backQuote(getDatabaseName()) + \".\" + backQuote(dictionary_name) + \" already exists.\",\n-                ErrorCodes::DICTIONARY_ALREADY_EXISTS);\n+    if (external_loader.getCurrentStatus(dict_id.getFullNameNotQuoted()) != ExternalLoader::Status::NOT_EXIST)\n+        throw Exception(ErrorCodes::DICTIONARY_ALREADY_EXISTS,\n+                        \"Dictionary {} already exists.\", dict_id.getFullNameNotQuoted());\n \n     if (isTableExist(dictionary_name, global_context))\n-        throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(dictionary_name) + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n+        throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {} already exists.\", dict_id.getFullTableName());\n \n \n     String dictionary_metadata_path = getObjectMetadataPath(dictionary_name);\n@@ -162,7 +184,7 @@ void DatabaseWithDictionaries::createDictionary(const Context & context, const S\n     {\n         /// load() is called here to force loading the dictionary, wait until the loading is finished,\n         /// and throw an exception if the loading is failed.\n-        external_loader.load(full_name);\n+        external_loader.load(dict_id.getInternalDictionaryName());\n     }\n \n     auto config = getDictionaryConfigurationFromAST(query->as<const ASTCreateQuery &>());\n@@ -178,7 +200,7 @@ void DatabaseWithDictionaries::createDictionary(const Context & context, const S\n \n     /// ExternalDictionariesLoader doesn't know we renamed the metadata path.\n     /// That's why we have to call ExternalLoader::reloadConfig() here.\n-    reloadDictionaryConfig(full_name);\n+    reloadDictionaryConfig(dict_id.getInternalDictionaryName());\n \n     /// Everything's ok.\n     succeeded = true;\n@@ -193,7 +215,8 @@ void DatabaseWithDictionaries::removeDictionary(const Context &, const String &\n     {\n         String dictionary_metadata_path = getObjectMetadataPath(dictionary_name);\n         Poco::File(dictionary_metadata_path).remove();\n-        CurrentStatusInfo::unset(CurrentStatusInfo::DictionaryStatus, getDatabaseName() + \".\" + dictionary_name);\n+        CurrentStatusInfo::unset(CurrentStatusInfo::DictionaryStatus,\n+                                 StorageID(attach_info.create_query).getInternalDictionaryName());\n     }\n     catch (...)\n     {\n@@ -206,14 +229,16 @@ void DatabaseWithDictionaries::removeDictionary(const Context &, const String &\n DatabaseDictionariesIteratorPtr DatabaseWithDictionaries::getDictionariesIterator(const FilterByNameFunction & filter_by_dictionary_name)\n {\n     std::lock_guard lock(mutex);\n-    if (!filter_by_dictionary_name)\n-        return std::make_unique<DatabaseDictionariesSnapshotIterator>(dictionaries);\n-\n-    Dictionaries filtered_dictionaries;\n-    for (const auto & dictionary_name : dictionaries | boost::adaptors::map_keys)\n-        if (filter_by_dictionary_name(dictionary_name))\n-            filtered_dictionaries.emplace_back(dictionary_name);\n-    return std::make_unique<DatabaseDictionariesSnapshotIterator>(std::move(filtered_dictionaries));\n+    DictionariesWithID filtered_dictionaries;\n+    for (const auto & dictionary : dictionaries)\n+    {\n+        if (filter_by_dictionary_name && !filter_by_dictionary_name(dictionary.first))\n+            continue;\n+        filtered_dictionaries.emplace_back();\n+        filtered_dictionaries.back().first = dictionary.first;\n+        filtered_dictionaries.back().second = dictionary.second.create_query->as<const ASTCreateQuery &>().uuid;\n+    }\n+    return std::make_unique<DatabaseDictionariesSnapshotIterator>(std::move(filtered_dictionaries), database_name);\n }\n \n bool DatabaseWithDictionaries::isDictionaryExist(const String & dictionary_name) const\n@@ -235,7 +260,7 @@ ASTPtr DatabaseWithDictionaries::getCreateDictionaryQueryImpl(\n             ASTPtr ast = it->second.create_query->clone();\n             auto & create_query = ast->as<ASTCreateQuery &>();\n             create_query.attach = false;\n-            create_query.database = getDatabaseName();\n+            create_query.database = database_name;\n             return ast;\n         }\n     }\n@@ -296,8 +321,11 @@ void DatabaseWithDictionaries::reloadDictionaryConfig(const String & full_name)\n {\n     /// Ensure that this database is attached to ExternalLoader as a config repository.\n     if (!database_as_config_repo_for_external_loader.load())\n-        database_as_config_repo_for_external_loader = boost::make_shared<ext::scope_guard>(\n-            external_loader.addConfigRepository(std::make_unique<ExternalLoaderDatabaseConfigRepository>(*this)));\n+    {\n+        auto repository = std::make_unique<ExternalLoaderDatabaseConfigRepository>(*this, global_context);\n+        auto remove_repository_callback = external_loader.addConfigRepository(std::move(repository));\n+        database_as_config_repo_for_external_loader = boost::make_shared<ext::scope_guard>(std::move(remove_repository_callback));\n+    }\n \n     external_loader.reloadConfig(getDatabaseName(), full_name);\n }\ndiff --git a/src/Databases/DatabaseWithDictionaries.h b/src/Databases/DatabaseWithDictionaries.h\nindex eb9e105e31d8..7f59b5028c47 100644\n--- a/src/Databases/DatabaseWithDictionaries.h\n+++ b/src/Databases/DatabaseWithDictionaries.h\n@@ -42,12 +42,12 @@ class DatabaseWithDictionaries : public DatabaseOnDisk\n     ASTPtr getCreateDictionaryQueryImpl(const String & dictionary_name, bool throw_on_error) const override;\n \n     std::unordered_map<String, DictionaryAttachInfo> dictionaries;\n+    const ExternalDictionariesLoader & external_loader;\n \n private:\n     void detachDictionaryImpl(const String & dictionary_name, DictionaryAttachInfo & attach_info);\n     void reloadDictionaryConfig(const String & full_name);\n \n-    const ExternalDictionariesLoader & external_loader;\n     boost::atomic_shared_ptr<ext::scope_guard> database_as_config_repo_for_external_loader;\n };\n \ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex 47c54fae8003..eadfa5f53c60 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -17,6 +17,7 @@ namespace ErrorCodes\n {\n     extern const int TABLE_ALREADY_EXISTS;\n     extern const int UNKNOWN_TABLE;\n+    extern const int UNKNOWN_DATABASE;\n }\n \n DatabaseWithOwnTablesBase::DatabaseWithOwnTablesBase(const String & name_, const String & logger, const Context & context)\n@@ -43,14 +44,14 @@ DatabaseTablesIteratorPtr DatabaseWithOwnTablesBase::getTablesIterator(const Con\n {\n     std::lock_guard lock(mutex);\n     if (!filter_by_table_name)\n-        return std::make_unique<DatabaseTablesSnapshotIterator>(tables);\n+        return std::make_unique<DatabaseTablesSnapshotIterator>(tables, database_name);\n \n     Tables filtered_tables;\n     for (const auto & [table_name, storage] : tables)\n         if (filter_by_table_name(table_name))\n             filtered_tables.emplace(table_name, storage);\n \n-    return std::make_unique<DatabaseTablesSnapshotIterator>(std::move(filtered_tables));\n+    return std::make_unique<DatabaseTablesSnapshotIterator>(std::move(filtered_tables), database_name);\n }\n \n bool DatabaseWithOwnTablesBase::empty() const\n@@ -71,14 +72,15 @@ StoragePtr DatabaseWithOwnTablesBase::detachTableUnlocked(const String & table_n\n \n     auto it = tables.find(table_name);\n     if (it == tables.end())\n-        throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+        throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist.\",\n+                        backQuote(database_name), backQuote(table_name));\n     res = it->second;\n     tables.erase(it);\n \n     auto table_id = res->getStorageID();\n     if (table_id.hasUUID())\n     {\n-        assert(getDatabaseName() == DatabaseCatalog::TEMPORARY_DATABASE || getEngineName() == \"Atomic\");\n+        assert(database_name == DatabaseCatalog::TEMPORARY_DATABASE || getEngineName() == \"Atomic\");\n         DatabaseCatalog::instance().removeUUIDMapping(table_id.uuid);\n     }\n \n@@ -93,12 +95,17 @@ void DatabaseWithOwnTablesBase::attachTable(const String & table_name, const Sto\n \n void DatabaseWithOwnTablesBase::attachTableUnlocked(const String & table_name, const StoragePtr & table, std::unique_lock<std::mutex> &)\n {\n-    if (!tables.emplace(table_name, table).second)\n-        throw Exception(\"Table \" + database_name + \".\" + table_name + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n     auto table_id = table->getStorageID();\n+    if (table_id.database_name != database_name)\n+        throw Exception(ErrorCodes::UNKNOWN_DATABASE, \"Database was renamed to `{}`, cannot create table in `{}`\",\n+                        database_name, table_id.database_name);\n+\n+    if (!tables.emplace(table_name, table).second)\n+        throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {} already exists.\", table_id.getFullTableName());\n+\n     if (table_id.hasUUID())\n     {\n-        assert(getDatabaseName() == DatabaseCatalog::TEMPORARY_DATABASE || getEngineName() == \"Atomic\");\n+        assert(database_name == DatabaseCatalog::TEMPORARY_DATABASE || getEngineName() == \"Atomic\");\n         DatabaseCatalog::instance().addUUIDMapping(table_id.uuid, shared_from_this(), table);\n     }\n }\n@@ -146,7 +153,8 @@ StoragePtr DatabaseWithOwnTablesBase::getTableUnlocked(const String & table_name\n     auto it = tables.find(table_name);\n     if (it != tables.end())\n         return it->second;\n-    throw Exception(\"Table \" + backQuote(database_name) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+    throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist.\",\n+                    backQuote(database_name), backQuote(table_name));\n }\n \n }\ndiff --git a/src/Databases/DatabasesCommon.h b/src/Databases/DatabasesCommon.h\nindex 4238fd30137a..4c7ec1ec637a 100644\n--- a/src/Databases/DatabasesCommon.h\n+++ b/src/Databases/DatabasesCommon.h\n@@ -36,7 +36,6 @@ class DatabaseWithOwnTablesBase : public IDatabase\n     ~DatabaseWithOwnTablesBase() override;\n \n protected:\n-    mutable std::mutex mutex;\n     Tables tables;\n     Poco::Logger * log;\n     const Context & global_context;\ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex 26b27045be6a..34bcb93c5d8c 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -23,7 +23,7 @@ struct Settings;\n struct ConstraintsDescription;\n struct IndicesDescription;\n class ASTCreateQuery;\n-using Dictionaries = std::vector<String>;\n+using DictionariesWithID = std::vector<std::pair<String, UUID>>;\n \n namespace ErrorCodes\n {\n@@ -48,6 +48,11 @@ class IDatabaseTablesIterator\n     virtual ~IDatabaseTablesIterator() = default;\n \n     virtual UUID uuid() const { return UUIDHelpers::Nil; }\n+\n+    const String & databaseName() const { assert(!database_name.empty()); return database_name; }\n+\n+protected:\n+    String database_name;\n };\n \n /// Copies list of tables and iterates through such snapshot.\n@@ -65,12 +70,21 @@ class DatabaseTablesSnapshotIterator : public IDatabaseTablesIterator\n         other.it = other.tables.end();\n         it = tables.begin();\n         std::advance(it, idx);\n+        database_name = std::move(other.database_name);\n     }\n \n public:\n-    DatabaseTablesSnapshotIterator(Tables & tables_) : tables(tables_), it(tables.begin()) {}\n+    DatabaseTablesSnapshotIterator(const Tables & tables_, const String & database_name_)\n+    : tables(tables_), it(tables.begin())\n+    {\n+        database_name = database_name_;\n+    }\n \n-    DatabaseTablesSnapshotIterator(Tables && tables_) : tables(tables_), it(tables.begin()) {}\n+    DatabaseTablesSnapshotIterator(Tables && tables_, String && database_name_)\n+    : tables(std::move(tables_)), it(tables.begin())\n+    {\n+        database_name = std::move(database_name_);\n+    }\n \n     void next() override { ++it; }\n \n@@ -85,25 +99,30 @@ class DatabaseTablesSnapshotIterator : public IDatabaseTablesIterator\n class DatabaseDictionariesSnapshotIterator\n {\n private:\n-    Dictionaries dictionaries;\n-    Dictionaries::iterator it;\n+    DictionariesWithID dictionaries;\n+    DictionariesWithID::iterator it;\n+    String database_name;\n \n public:\n     DatabaseDictionariesSnapshotIterator() = default;\n-    DatabaseDictionariesSnapshotIterator(Dictionaries & dictionaries_) : dictionaries(dictionaries_), it(dictionaries.begin()) {}\n-    DatabaseDictionariesSnapshotIterator(Dictionaries && dictionaries_) : dictionaries(dictionaries_), it(dictionaries.begin()) {}\n-\n-    DatabaseDictionariesSnapshotIterator(const std::unordered_map<String, DictionaryAttachInfo> & dictionaries_)\n+    DatabaseDictionariesSnapshotIterator(DictionariesWithID & dictionaries_, const String & database_name_)\n+    : dictionaries(dictionaries_), it(dictionaries.begin()), database_name(database_name_)\n+    {\n+    }\n+    DatabaseDictionariesSnapshotIterator(DictionariesWithID && dictionaries_, const String & database_name_)\n+    : dictionaries(dictionaries_), it(dictionaries.begin()), database_name(database_name_)\n     {\n-        boost::range::copy(dictionaries_ | boost::adaptors::map_keys, std::back_inserter(dictionaries));\n-        it = dictionaries.begin();\n     }\n \n     void next() { ++it; }\n \n     bool isValid() const { return !dictionaries.empty() && it != dictionaries.end(); }\n \n-    const String & name() const { return *it; }\n+    const String & name() const { return it->first; }\n+\n+    const UUID & uuid() const { return it->second; }\n+\n+    const String & databaseName() const { assert(!database_name.empty()); return database_name; }\n };\n \n using DatabaseTablesIteratorPtr = std::unique_ptr<IDatabaseTablesIterator>;\n@@ -228,7 +247,8 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n         const String & /*name*/,\n         IDatabase & /*to_database*/,\n         const String & /*to_name*/,\n-        bool /*exchange*/)\n+        bool /*exchange*/,\n+        bool /*dictionary*/)\n     {\n         throw Exception(getEngineName() + \": renameTable() is not supported\", ErrorCodes::NOT_IMPLEMENTED);\n     }\n@@ -282,7 +302,19 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n     virtual ASTPtr getCreateDatabaseQuery() const = 0;\n \n     /// Get name of database.\n-    String getDatabaseName() const { return database_name; }\n+    String getDatabaseName() const\n+    {\n+        std::lock_guard lock{mutex};\n+        return database_name;\n+    }\n+    /// Get UUID of database.\n+    virtual UUID getUUID() const { return UUIDHelpers::Nil; }\n+\n+    virtual void renameDatabase(const String & /*new_name*/)\n+    {\n+        throw Exception(getEngineName() + \": RENAME DATABASE is not supported\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n     /// Returns path for persistent data storage if the database supports it, empty string otherwise\n     virtual String getDataPath() const { return {}; }\n \n@@ -321,6 +353,7 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n         return nullptr;\n     }\n \n+    mutable std::mutex mutex;\n     String database_name;\n };\n \ndiff --git a/src/Dictionaries/CacheDictionary.cpp b/src/Dictionaries/CacheDictionary.cpp\nindex 2f2be695a8fe..6fb14251ae59 100644\n--- a/src/Dictionaries/CacheDictionary.cpp\n+++ b/src/Dictionaries/CacheDictionary.cpp\n@@ -60,8 +60,7 @@ inline size_t CacheDictionary::getCellIdx(const Key id) const\n \n \n CacheDictionary::CacheDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     DictionaryLifetime dict_lifetime_,\n@@ -72,9 +71,7 @@ CacheDictionary::CacheDictionary(\n     size_t update_queue_push_timeout_milliseconds_,\n     size_t query_wait_timeout_milliseconds_,\n     size_t max_threads_for_updates_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -238,7 +235,7 @@ void CacheDictionary::isInConstantVector(const Key child_id, const PaddedPODArra\n void CacheDictionary::getString(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ColumnString * out) const\n {\n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto null_value = StringRef{std::get<String>(attribute.null_values)};\n \n@@ -249,7 +246,7 @@ void CacheDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const ColumnString * const def, ColumnString * const out) const\n {\n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsString(attribute, ids, out, [&](const size_t row) { return def->getDataAt(row); });\n }\n@@ -258,7 +255,7 @@ void CacheDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const String & def, ColumnString * const out) const\n {\n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsString(attribute, ids, out, [&](const size_t) { return StringRef{def}; });\n }\n@@ -702,8 +699,7 @@ void registerDictionaryCache(DictionaryFactory & factory)\n             throw Exception{full_name + \": dictionary of layout 'cache' cannot have 'require_nonempty' attribute set\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n \n         const size_t strict_max_lifetime_seconds =\n@@ -712,7 +708,7 @@ void registerDictionaryCache(DictionaryFactory & factory)\n         const size_t max_update_queue_size =\n                 config.getUInt64(layout_prefix + \".cache.max_update_queue_size\", 100000);\n         if (max_update_queue_size == 0)\n-            throw Exception{name + \": dictionary of layout 'cache' cannot have empty update queue of size 0\",\n+            throw Exception{full_name + \": dictionary of layout 'cache' cannot have empty update queue of size 0\",\n                             ErrorCodes::TOO_SMALL_BUFFER_SIZE};\n \n         const bool allow_read_expired_keys =\n@@ -721,7 +717,7 @@ void registerDictionaryCache(DictionaryFactory & factory)\n         const size_t update_queue_push_timeout_milliseconds =\n                 config.getUInt64(layout_prefix + \".cache.update_queue_push_timeout_milliseconds\", 10);\n         if (update_queue_push_timeout_milliseconds < 10)\n-            throw Exception{name + \": dictionary of layout 'cache' have too little update_queue_push_timeout\",\n+            throw Exception{full_name + \": dictionary of layout 'cache' have too little update_queue_push_timeout\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n         const size_t query_wait_timeout_milliseconds =\n@@ -730,12 +726,11 @@ void registerDictionaryCache(DictionaryFactory & factory)\n         const size_t max_threads_for_updates =\n                 config.getUInt64(layout_prefix + \".max_threads_for_updates\", 4);\n         if (max_threads_for_updates == 0)\n-            throw Exception{name + \": dictionary of layout 'cache' cannot have zero threads for updates.\",\n+            throw Exception{full_name + \": dictionary of layout 'cache' cannot have zero threads for updates.\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n         return std::make_unique<CacheDictionary>(\n-                database,\n-                name,\n+                dict_id,\n                 dict_struct,\n                 std::move(source_ptr),\n                 dict_lifetime,\n@@ -829,9 +824,9 @@ void CacheDictionary::waitForCurrentUpdateFinish(UpdateUnitPtr & update_unit_ptr\n          * intended to do a synchronous update. AsyncUpdate thread can touch deallocated memory and explode.\n          * */\n         update_unit_ptr->can_use_callback = false;\n-        throw DB::Exception(\n-            \"Dictionary \" + getName() + \" source seems unavailable, because \" +\n-                toString(timeout_for_wait) + \" timeout exceeded.\", ErrorCodes::TIMEOUT_EXCEEDED);\n+        throw DB::Exception(ErrorCodes::TIMEOUT_EXCEEDED,\n+                            \"Dictionary {} source seems unavailable, because {} timeout exceeded.\",\n+                            getDictionaryID().getNameForLogs(), toString(timeout_for_wait));\n     }\n \n \n@@ -842,10 +837,11 @@ void CacheDictionary::waitForCurrentUpdateFinish(UpdateUnitPtr & update_unit_ptr\n void CacheDictionary::tryPushToUpdateQueueOrThrow(UpdateUnitPtr & update_unit_ptr) const\n {\n     if (!update_queue.tryPush(update_unit_ptr, update_queue_push_timeout_milliseconds))\n-        throw DB::Exception(\n-                \"Cannot push to internal update queue in dictionary \" + getFullName() + \". Timelimit of \" +\n-                std::to_string(update_queue_push_timeout_milliseconds) + \" ms. exceeded. Current queue size is \" +\n-                std::to_string(update_queue.size()), ErrorCodes::CACHE_DICTIONARY_UPDATE_FAIL);\n+        throw DB::Exception(ErrorCodes::CACHE_DICTIONARY_UPDATE_FAIL,\n+                \"Cannot push to internal update queue in dictionary {}. \"\n+                \"Timelimit of {} ms. exceeded. Current queue size is {}\",\n+                getDictionaryID().getNameForLogs(), std::to_string(update_queue_push_timeout_milliseconds),\n+                std::to_string(update_queue.size()));\n }\n \n void CacheDictionary::update(BunchUpdateUnit & bunch_update_unit) const\n@@ -880,7 +876,8 @@ void CacheDictionary::update(BunchUpdateUnit & bunch_update_unit) const\n \n                 const auto * id_column = typeid_cast<const ColumnUInt64 *>(block.safeGetByPosition(0).column.get());\n                 if (!id_column)\n-                    throw Exception{name + \": id column has type different from UInt64.\", ErrorCodes::TYPE_MISMATCH};\n+                    throw Exception{ErrorCodes::TYPE_MISMATCH,\n+                                    \"{}: id column has type different from UInt64.\", getDictionaryID().getNameForLogs()};\n \n                 const auto & ids = id_column->getData();\n \n@@ -945,8 +942,9 @@ void CacheDictionary::update(BunchUpdateUnit & bunch_update_unit) const\n             last_exception = std::current_exception();\n             backoff_end_time = now + std::chrono::seconds(calculateDurationWithBackoff(rnd_engine, error_count));\n \n-            tryLogException(last_exception, log, \"Could not update cache dictionary '\" + getFullName() +\n-                                                 \"', next update is scheduled at \" + ext::to_string(backoff_end_time.load()));\n+            tryLogException(last_exception, log,\n+                            \"Could not update cache dictionary '\" + getDictionaryID().getNameForLogs() +\n+                            \"', next update is scheduled at \" + ext::to_string(backoff_end_time.load()));\n         }\n     }\n \ndiff --git a/src/Dictionaries/CacheDictionary.h b/src/Dictionaries/CacheDictionary.h\nindex 7e2fc0441d31..218de240b63f 100644\n--- a/src/Dictionaries/CacheDictionary.h\n+++ b/src/Dictionaries/CacheDictionary.h\n@@ -50,8 +50,7 @@ class CacheDictionary final : public IDictionary\n {\n public:\n     CacheDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         DictionaryLifetime dict_lifetime_,\n@@ -65,10 +64,6 @@ class CacheDictionary final : public IDictionary\n \n     ~CacheDictionary() override;\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"Cache\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated + (string_arena ? string_arena->size() : 0); }\n@@ -89,8 +84,7 @@ class CacheDictionary final : public IDictionary\n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n         return std::make_shared<CacheDictionary>(\n-                database,\n-                name,\n+                getDictionaryID(),\n                 dict_struct,\n                 getSourceAndUpdateIfNeeded()->clone(),\n                 dict_lifetime,\n@@ -321,9 +315,6 @@ class CacheDictionary final : public IDictionary\n     template <typename AncestorType>\n     void isInImpl(const PaddedPODArray<Key> & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n \n     /// Dictionary source should be used with mutex\ndiff --git a/src/Dictionaries/CacheDictionary_generate1.cpp b/src/Dictionaries/CacheDictionary_generate1.cpp\nindex edb4b89d5505..a041f50ea268 100644\n--- a/src/Dictionaries/CacheDictionary_generate1.cpp\n+++ b/src/Dictionaries/CacheDictionary_generate1.cpp\n@@ -8,7 +8,7 @@ namespace DB\n         const \\\n     { \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, ids, out, [&](const size_t) { return null_value; }); \\\n     }\ndiff --git a/src/Dictionaries/CacheDictionary_generate2.cpp b/src/Dictionaries/CacheDictionary_generate2.cpp\nindex 97fa9e1a365f..be28a6302c20 100644\n--- a/src/Dictionaries/CacheDictionary_generate2.cpp\n+++ b/src/Dictionaries/CacheDictionary_generate2.cpp\n@@ -11,7 +11,7 @@ namespace DB\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, ids, out, [&](const size_t row) { return def[row]; }); \\\n     }\n \ndiff --git a/src/Dictionaries/CacheDictionary_generate3.cpp b/src/Dictionaries/CacheDictionary_generate3.cpp\nindex 8a94ca6bc203..36195f166dbc 100644\n--- a/src/Dictionaries/CacheDictionary_generate3.cpp\n+++ b/src/Dictionaries/CacheDictionary_generate3.cpp\n@@ -8,7 +8,7 @@ namespace DB\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const TYPE def, ResultArrayType<TYPE> & out) const \\\n     { \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, ids, out, [&](const size_t) { return def; }); \\\n     }\n \ndiff --git a/src/Dictionaries/ComplexKeyCacheDictionary.cpp b/src/Dictionaries/ComplexKeyCacheDictionary.cpp\nindex d6a74191a79d..0c5176992723 100644\n--- a/src/Dictionaries/ComplexKeyCacheDictionary.cpp\n+++ b/src/Dictionaries/ComplexKeyCacheDictionary.cpp\n@@ -51,15 +51,12 @@ inline UInt64 ComplexKeyCacheDictionary::getCellIdx(const StringRef key) const\n \n \n ComplexKeyCacheDictionary::ComplexKeyCacheDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     const size_t size_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -80,7 +77,7 @@ void ComplexKeyCacheDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto null_value = StringRef{std::get<String>(attribute.null_values)};\n \n@@ -97,7 +94,7 @@ void ComplexKeyCacheDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsString(attribute, key_columns, out, [&](const size_t row) { return def->getDataAt(row); });\n }\n@@ -112,7 +109,7 @@ void ComplexKeyCacheDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsString(attribute, key_columns, out, [&](const size_t) { return StringRef{def}; });\n }\n@@ -415,10 +412,9 @@ void registerDictionaryComplexKeyCache(DictionaryFactory & factory)\n             throw Exception{full_name + \": dictionary of layout 'cache' cannot have 'require_nonempty' attribute set\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n-        return std::make_unique<ComplexKeyCacheDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, size);\n+        return std::make_unique<ComplexKeyCacheDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, size);\n     };\n     factory.registerLayout(\"complex_key_cache\", create_layout, true);\n }\ndiff --git a/src/Dictionaries/ComplexKeyCacheDictionary.h b/src/Dictionaries/ComplexKeyCacheDictionary.h\nindex 3d6284c448ff..7c9cf6e3c8e8 100644\n--- a/src/Dictionaries/ComplexKeyCacheDictionary.h\n+++ b/src/Dictionaries/ComplexKeyCacheDictionary.h\n@@ -42,8 +42,7 @@ class ComplexKeyCacheDictionary final : public IDictionaryBase\n {\n public:\n     ComplexKeyCacheDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n@@ -51,10 +50,6 @@ class ComplexKeyCacheDictionary final : public IDictionaryBase\n \n     std::string getKeyDescription() const { return key_description; }\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"ComplexKeyCache\"; }\n \n     size_t getBytesAllocated() const override\n@@ -78,7 +73,7 @@ class ComplexKeyCacheDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<ComplexKeyCacheDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, size);\n+        return std::make_shared<ComplexKeyCacheDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, size);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -671,9 +666,6 @@ class ComplexKeyCacheDictionary final : public IDictionaryBase\n \n     bool isEmptyCell(const UInt64 idx) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/ComplexKeyCacheDictionary_generate1.cpp b/src/Dictionaries/ComplexKeyCacheDictionary_generate1.cpp\nindex 6f9761cd064f..01d39722d331 100644\n--- a/src/Dictionaries/ComplexKeyCacheDictionary_generate1.cpp\n+++ b/src/Dictionaries/ComplexKeyCacheDictionary_generate1.cpp\n@@ -8,7 +8,7 @@ namespace DB\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, key_columns, out, [&](const size_t) { return null_value; }); \\\n     }\ndiff --git a/src/Dictionaries/ComplexKeyCacheDictionary_generate2.cpp b/src/Dictionaries/ComplexKeyCacheDictionary_generate2.cpp\nindex 297da2c91a0e..deb34706f542 100644\n--- a/src/Dictionaries/ComplexKeyCacheDictionary_generate2.cpp\n+++ b/src/Dictionaries/ComplexKeyCacheDictionary_generate2.cpp\n@@ -12,7 +12,7 @@ namespace DB\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, key_columns, out, [&](const size_t row) { return def[row]; }); \\\n     }\n \ndiff --git a/src/Dictionaries/ComplexKeyCacheDictionary_generate3.cpp b/src/Dictionaries/ComplexKeyCacheDictionary_generate3.cpp\nindex 222e9c8ee775..2a84fdc89f6d 100644\n--- a/src/Dictionaries/ComplexKeyCacheDictionary_generate3.cpp\n+++ b/src/Dictionaries/ComplexKeyCacheDictionary_generate3.cpp\n@@ -12,7 +12,7 @@ namespace DB\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(attribute, key_columns, out, [&](const size_t) { return def; }); \\\n     }\n \ndiff --git a/src/Dictionaries/ComplexKeyDirectDictionary.cpp b/src/Dictionaries/ComplexKeyDirectDictionary.cpp\nindex 81058f28ff43..814a9f2f504d 100644\n--- a/src/Dictionaries/ComplexKeyDirectDictionary.cpp\n+++ b/src/Dictionaries/ComplexKeyDirectDictionary.cpp\n@@ -15,14 +15,11 @@ namespace ErrorCodes\n \n \n ComplexKeyDirectDictionary::ComplexKeyDirectDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     BlockPtr saved_block_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , saved_block{std::move(saved_block_)}\n@@ -39,7 +36,7 @@ ComplexKeyDirectDictionary::ComplexKeyDirectDictionary(\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -67,7 +64,7 @@ void ComplexKeyDirectDictionary::getString(\n {\n     dict_struct.validateKeyTypes(key_types);\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = std::get<StringRef>(attribute.null_values);\n     getItemsStringImpl<StringRef, StringRef>(\n@@ -87,7 +84,7 @@ void ComplexKeyDirectDictionary::getString(\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, key_columns, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t row) { return def[row]; }); \\\n@@ -114,7 +111,7 @@ void ComplexKeyDirectDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl<StringRef, StringRef>(\n         attribute,\n@@ -129,7 +126,7 @@ void ComplexKeyDirectDictionary::getString(\n     { \\\n         dict_struct.validateKeyTypes(key_types); \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, key_columns, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -156,7 +153,7 @@ void ComplexKeyDirectDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     ComplexKeyDirectDictionary::getItemsStringImpl<StringRef, StringRef>(\n         attribute,\n@@ -588,14 +585,13 @@ void registerDictionaryComplexKeyDirect(DictionaryFactory & factory)\n                                   \"for a dictionary of layout 'range_hashed'\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n \n         if (config.has(config_prefix + \".lifetime.min\") || config.has(config_prefix + \".lifetime.max\"))\n             throw Exception{\"'lifetime' parameter is redundant for the dictionary' of layout 'direct'\", ErrorCodes::BAD_ARGUMENTS};\n \n \n-        return std::make_unique<ComplexKeyDirectDictionary>(database, name, dict_struct, std::move(source_ptr));\n+        return std::make_unique<ComplexKeyDirectDictionary>(dict_id, dict_struct, std::move(source_ptr));\n     };\n     factory.registerLayout(\"complex_key_direct\", create_layout, false);\n }\ndiff --git a/src/Dictionaries/ComplexKeyDirectDictionary.h b/src/Dictionaries/ComplexKeyDirectDictionary.h\nindex e814c5dde825..dc602be103f0 100644\n--- a/src/Dictionaries/ComplexKeyDirectDictionary.h\n+++ b/src/Dictionaries/ComplexKeyDirectDictionary.h\n@@ -25,16 +25,11 @@ class ComplexKeyDirectDictionary final : public IDictionaryBase\n {\n public:\n     ComplexKeyDirectDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         BlockPtr saved_block_ = nullptr);\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"ComplexKeyDirect\"; }\n \n     size_t getBytesAllocated() const override { return 0; }\n@@ -51,7 +46,7 @@ class ComplexKeyDirectDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<ComplexKeyDirectDictionary>(database, name, dict_struct, source_ptr->clone(), saved_block);\n+        return std::make_shared<ComplexKeyDirectDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -205,9 +200,6 @@ class ComplexKeyDirectDictionary final : public IDictionaryBase\n     template <typename T>\n     void has(const Attribute & attribute, const Columns & key_columns, PaddedPODArray<UInt8> & out) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/ComplexKeyHashedDictionary.cpp b/src/Dictionaries/ComplexKeyHashedDictionary.cpp\nindex fc857254df44..676196fabd2b 100644\n--- a/src/Dictionaries/ComplexKeyHashedDictionary.cpp\n+++ b/src/Dictionaries/ComplexKeyHashedDictionary.cpp\n@@ -14,16 +14,13 @@ namespace ErrorCodes\n }\n \n ComplexKeyHashedDictionary::ComplexKeyHashedDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_,\n     BlockPtr saved_block_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -42,7 +39,7 @@ ComplexKeyHashedDictionary::ComplexKeyHashedDictionary(\n         dict_struct.validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -74,7 +71,7 @@ void ComplexKeyHashedDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = StringRef{std::get<String>(attribute.null_values)};\n \n@@ -96,7 +93,7 @@ void ComplexKeyHashedDictionary::getString(\n         dict_struct.validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, \\\n@@ -130,7 +127,7 @@ void ComplexKeyHashedDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -150,7 +147,7 @@ void ComplexKeyHashedDictionary::getString(\n         dict_struct.validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, key_columns, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -181,7 +178,7 @@ void ComplexKeyHashedDictionary::getString(\n     dict_struct.validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -753,11 +750,10 @@ void registerDictionaryComplexKeyHashed(DictionaryFactory & factory)\n         if (!dict_struct.key)\n             throw Exception{\"'key' is required for dictionary of layout 'complex_key_hashed'\", ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<ComplexKeyHashedDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<ComplexKeyHashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n     };\n     factory.registerLayout(\"complex_key_hashed\", create_layout, true);\n }\ndiff --git a/src/Dictionaries/ComplexKeyHashedDictionary.h b/src/Dictionaries/ComplexKeyHashedDictionary.h\nindex 82b2a93b0108..baf6628eebd6 100644\n--- a/src/Dictionaries/ComplexKeyHashedDictionary.h\n+++ b/src/Dictionaries/ComplexKeyHashedDictionary.h\n@@ -23,8 +23,7 @@ class ComplexKeyHashedDictionary final : public IDictionaryBase\n {\n public:\n     ComplexKeyHashedDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n@@ -33,10 +32,6 @@ class ComplexKeyHashedDictionary final : public IDictionaryBase\n \n     std::string getKeyDescription() const { return key_description; }\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"ComplexKeyHashed\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n@@ -51,7 +46,7 @@ class ComplexKeyHashedDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<ComplexKeyHashedDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n+        return std::make_shared<ComplexKeyHashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -236,9 +231,6 @@ class ComplexKeyHashedDictionary final : public IDictionaryBase\n     template <typename T>\n     std::vector<StringRef> getKeys(const Attribute & attribute) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 5a9fa7979c35..08885bc4d1bb 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -15,11 +15,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int TYPE_MISMATCH;\n-}\n-\n enum class AttributeUnderlyingType\n {\n     utUInt8,\n@@ -44,15 +39,6 @@ AttributeUnderlyingType getAttributeUnderlyingType(const std::string & type);\n \n std::string toString(const AttributeUnderlyingType type);\n \n-/// Implicit conversions in dictGet functions is disabled.\n-inline void checkAttributeType(const std::string & dict_name, const std::string & attribute_name,\n-                               AttributeUnderlyingType attribute_type, AttributeUnderlyingType to)\n-{\n-    if (attribute_type != to)\n-        throw Exception{dict_name + \": type mismatch: attribute \" + attribute_name + \" has type \" + toString(attribute_type)\n-            + \", expected \" + toString(to), ErrorCodes::TYPE_MISMATCH};\n-}\n-\n /// Min and max lifetimes for a dictionary or it's entry\n using DictionaryLifetime = ExternalLoadableLifetime;\n \ndiff --git a/src/Dictionaries/DirectDictionary.cpp b/src/Dictionaries/DirectDictionary.cpp\nindex 61d8e21341b7..1fbfcc072150 100644\n--- a/src/Dictionaries/DirectDictionary.cpp\n+++ b/src/Dictionaries/DirectDictionary.cpp\n@@ -16,14 +16,11 @@ namespace ErrorCodes\n \n \n DirectDictionary::DirectDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     BlockPtr saved_block_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , saved_block{std::move(saved_block_)}\n@@ -136,7 +133,7 @@ void DirectDictionary::isInConstantVector(const Key child_id, const PaddedPODArr\n     void DirectDictionary::get##TYPE(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -162,7 +159,7 @@ DECLARE(Decimal128)\n void DirectDictionary::getString(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ColumnString * out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = std::get<StringRef>(attribute.null_values);\n     getItemsStringImpl<StringRef, StringRef>(\n@@ -180,7 +177,7 @@ void DirectDictionary::getString(const std::string & attribute_name, const Padde\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t row) { return def[row]; }); \\\n@@ -205,7 +202,7 @@ void DirectDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const ColumnString * const def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl<StringRef, StringRef>(\n         attribute,\n@@ -219,7 +216,7 @@ void DirectDictionary::getString(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const TYPE def, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -244,7 +241,7 @@ void DirectDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const String & def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     DirectDictionary::getItemsStringImpl<StringRef, StringRef>(\n         attribute,\n@@ -577,14 +574,13 @@ void registerDictionaryDirect(DictionaryFactory & factory)\n                                   \"for a dictionary of layout 'range_hashed'\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n \n         if (config.has(config_prefix + \".lifetime.min\") || config.has(config_prefix + \".lifetime.max\"))\n             throw Exception{\"'lifetime' parameter is redundant for the dictionary' of layout 'direct'\", ErrorCodes::BAD_ARGUMENTS};\n \n \n-        return std::make_unique<DirectDictionary>(database, name, dict_struct, std::move(source_ptr));\n+        return std::make_unique<DirectDictionary>(dict_id, dict_struct, std::move(source_ptr));\n     };\n     factory.registerLayout(\"direct\", create_layout, false);\n }\ndiff --git a/src/Dictionaries/DirectDictionary.h b/src/Dictionaries/DirectDictionary.h\nindex 3c0fb375624c..18ef5224a8a5 100644\n--- a/src/Dictionaries/DirectDictionary.h\n+++ b/src/Dictionaries/DirectDictionary.h\n@@ -23,16 +23,11 @@ class DirectDictionary final : public IDictionary\n {\n public:\n     DirectDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         BlockPtr saved_block_ = nullptr);\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"Direct\"; }\n \n     size_t getBytesAllocated() const override { return 0; }\n@@ -47,7 +42,7 @@ class DirectDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<DirectDictionary>(database, name, dict_struct, source_ptr->clone(), saved_block);\n+        return std::make_shared<DirectDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -206,9 +201,6 @@ class DirectDictionary final : public IDictionary\n     template <typename ChildType, typename AncestorType>\n     void isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex b6396d20f3ad..47ffdaeb5bd2 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -21,16 +21,13 @@ static const auto max_array_size = 500000;\n \n \n FlatDictionary::FlatDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_,\n     BlockPtr saved_block_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -110,7 +107,7 @@ void FlatDictionary::isInConstantVector(const Key child_id, const PaddedPODArray\n     void FlatDictionary::get##TYPE(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -136,7 +133,7 @@ DECLARE(Decimal128)\n void FlatDictionary::getString(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ColumnString * out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = std::get<StringRef>(attribute.null_values);\n \n@@ -155,7 +152,7 @@ void FlatDictionary::getString(const std::string & attribute_name, const PaddedP\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t row) { return def[row]; }); \\\n@@ -180,7 +177,7 @@ void FlatDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const ColumnString * const def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -194,7 +191,7 @@ void FlatDictionary::getString(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const TYPE def, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -219,7 +216,7 @@ void FlatDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const String & def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     FlatDictionary::getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -724,11 +721,10 @@ void registerDictionaryFlat(DictionaryFactory & factory)\n                                   \"for a dictionary of layout 'range_hashed'\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<FlatDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<FlatDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n     };\n     factory.registerLayout(\"flat\", create_layout, false);\n }\ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex 636c7b9d092e..2f51c1f5c1b8 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -22,18 +22,13 @@ class FlatDictionary final : public IDictionary\n {\n public:\n     FlatDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n         bool require_nonempty_,\n         BlockPtr saved_block_ = nullptr);\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"Flat\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n@@ -48,7 +43,7 @@ class FlatDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<FlatDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n+        return std::make_shared<FlatDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -225,9 +220,6 @@ class FlatDictionary final : public IDictionary\n \n     PaddedPODArray<Key> getIds() const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex 62fa52acfe80..85456e8c61c1 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -32,17 +32,14 @@ namespace ErrorCodes\n \n \n HashedDictionary::HashedDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_,\n     bool sparse_,\n     BlockPtr saved_block_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -133,7 +130,7 @@ void HashedDictionary::isInConstantVector(const Key child_id, const PaddedPODArr\n         const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -159,7 +156,7 @@ DECLARE(Decimal128)\n void HashedDictionary::getString(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ColumnString * out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = StringRef{std::get<String>(attribute.null_values)};\n \n@@ -178,7 +175,7 @@ void HashedDictionary::getString(const std::string & attribute_name, const Padde\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t row) { return def[row]; }); \\\n@@ -203,7 +200,7 @@ void HashedDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const ColumnString * const def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -217,7 +214,7 @@ void HashedDictionary::getString(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const TYPE & def, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, ids, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -242,7 +239,7 @@ void HashedDictionary::getString(\n     const std::string & attribute_name, const PaddedPODArray<Key> & ids, const String & def, ColumnString * const out) const\n {\n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -788,11 +785,10 @@ void registerDictionaryHashed(DictionaryFactory & factory)\n                                   \"for a dictionary of layout 'range_hashed'\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<HashedDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty, sparse);\n+        return std::make_unique<HashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty, sparse);\n     };\n     using namespace std::placeholders;\n     factory.registerLayout(\"hashed\",\ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex a361352a8bdb..fd6b93b6d5cf 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -26,8 +26,7 @@ class HashedDictionary final : public IDictionary\n {\n public:\n     HashedDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n@@ -35,10 +34,6 @@ class HashedDictionary final : public IDictionary\n         bool sparse_,\n         BlockPtr saved_block_ = nullptr);\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return sparse ? \"SparseHashed\" : \"Hashed\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n@@ -53,7 +48,7 @@ class HashedDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<HashedDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, sparse, saved_block);\n+        return std::make_shared<HashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, sparse, saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -271,9 +266,6 @@ class HashedDictionary final : public IDictionary\n     template <typename ChildType, typename AncestorType>\n     void isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/IDictionary.h b/src/Dictionaries/IDictionary.h\nindex 485940bdb803..6bc8d32295a4 100644\n--- a/src/Dictionaries/IDictionary.h\n+++ b/src/Dictionaries/IDictionary.h\n@@ -4,19 +4,23 @@\n #include <Core/Names.h>\n #include <DataStreams/IBlockStream_fwd.h>\n #include <Interpreters/IExternalLoadable.h>\n+#include <Interpreters/StorageID.h>\n #include <Poco/Util/XMLConfiguration.h>\n #include <Common/PODArray.h>\n #include <common/StringRef.h>\n #include \"IDictionarySource.h\"\n+#include <Dictionaries/DictionaryStructure.h>\n \n #include <chrono>\n #include <memory>\n+#include <mutex>\n \n namespace DB\n {\n namespace ErrorCodes\n {\n     extern const int NOT_IMPLEMENTED;\n+    extern const int TYPE_MISMATCH;\n }\n \n struct IDictionaryBase;\n@@ -29,22 +33,37 @@ struct IDictionaryBase : public IExternalLoadable\n {\n     using Key = UInt64;\n \n-    virtual const std::string & getDatabase() const = 0;\n-    virtual const std::string & getName() const = 0;\n-    virtual const std::string & getFullName() const = 0;\n+    IDictionaryBase(const StorageID & dict_id_)\n+    : dict_id(dict_id_)\n+    , full_name(dict_id.getInternalDictionaryName())\n+    {\n+    }\n+\n+    const std::string & getFullName() const{ return full_name; }\n+    StorageID getDictionaryID() const\n+    {\n+        std::lock_guard lock{name_mutex};\n+        return dict_id;\n+    }\n+\n+    void updateDictionaryName(const StorageID & new_name) const\n+    {\n+        std::lock_guard lock{name_mutex};\n+        assert(new_name.uuid == dict_id.uuid && dict_id.uuid != UUIDHelpers::Nil);\n+        dict_id = new_name;\n+    }\n \n-    const std::string & getLoadableName() const override { return getFullName(); }\n+    const std::string & getLoadableName() const override final { return getFullName(); }\n \n     /// Specifies that no database is used.\n     /// Sometimes we cannot simply use an empty string for that because an empty string is\n     /// usually replaced with the current database.\n     static constexpr char NO_DATABASE_TAG[] = \"<no_database>\";\n \n-    std::string_view getDatabaseOrNoDatabaseTag() const\n+    std::string getDatabaseOrNoDatabaseTag() const\n     {\n-        const std::string & database = getDatabase();\n-        if (!database.empty())\n-            return database;\n+        if (!dict_id.database_name.empty())\n+            return dict_id.database_name;\n         return NO_DATABASE_TAG;\n     }\n \n@@ -87,11 +106,20 @@ struct IDictionaryBase : public IExternalLoadable\n     {\n         return std::static_pointer_cast<const IDictionaryBase>(IExternalLoadable::shared_from_this());\n     }\n+\n+private:\n+    mutable std::mutex name_mutex;\n+    mutable StorageID dict_id;\n+\n+protected:\n+    const String full_name;\n };\n \n \n struct IDictionary : IDictionaryBase\n {\n+    IDictionary(const StorageID & dict_id_) : IDictionaryBase(dict_id_) {}\n+\n     virtual bool hasHierarchy() const = 0;\n \n     virtual void toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const = 0;\n@@ -103,19 +131,22 @@ struct IDictionary : IDictionaryBase\n     virtual void isInVectorVector(\n         const PaddedPODArray<Key> & /*child_ids*/, const PaddedPODArray<Key> & /*ancestor_ids*/, PaddedPODArray<UInt8> & /*out*/) const\n     {\n-        throw Exception(\"Hierarchy is not supported for \" + getName() + \" dictionary.\", ErrorCodes::NOT_IMPLEMENTED);\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n     }\n \n     virtual void\n     isInVectorConstant(const PaddedPODArray<Key> & /*child_ids*/, const Key /*ancestor_id*/, PaddedPODArray<UInt8> & /*out*/) const\n     {\n-        throw Exception(\"Hierarchy is not supported for \" + getName() + \" dictionary.\", ErrorCodes::NOT_IMPLEMENTED);\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n     }\n \n     virtual void\n     isInConstantVector(const Key /*child_id*/, const PaddedPODArray<Key> & /*ancestor_ids*/, PaddedPODArray<UInt8> & /*out*/) const\n     {\n-        throw Exception(\"Hierarchy is not supported for \" + getName() + \" dictionary.\", ErrorCodes::NOT_IMPLEMENTED);\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n     }\n \n     void isInConstantConstant(const Key child_id, const Key ancestor_id, UInt8 & out) const\n@@ -126,4 +157,14 @@ struct IDictionary : IDictionaryBase\n     }\n };\n \n+/// Implicit conversions in dictGet functions is disabled.\n+inline void checkAttributeType(const IDictionaryBase * dictionary, const std::string & attribute_name,\n+                               AttributeUnderlyingType attribute_type, AttributeUnderlyingType to)\n+{\n+    if (attribute_type != to)\n+        throw Exception{ErrorCodes::TYPE_MISMATCH, \"{}: type mismatch: attribute {} has type {}, expected {}\",\n+                        dictionary->getDictionaryID().getNameForLogs(),\n+                        attribute_name, toString(attribute_type), toString(to)};\n+}\n+\n }\ndiff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp\nindex eb6f0c6387c8..04eadbfc0ce5 100644\n--- a/src/Dictionaries/PolygonDictionary.cpp\n+++ b/src/Dictionaries/PolygonDictionary.cpp\n@@ -20,16 +20,13 @@ namespace ErrorCodes\n \n \n IPolygonDictionary::IPolygonDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n         InputType input_type_,\n         PointType point_type_)\n-        : database(database_)\n-        , name(name_)\n-        , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+        : IDictionaryBase(dict_id_)\n         , dict_struct(dict_struct_)\n         , source_ptr(std::move(source_ptr_))\n         , dict_lifetime(dict_lifetime_)\n@@ -40,21 +37,6 @@ IPolygonDictionary::IPolygonDictionary(\n     loadData();\n }\n \n-const std::string & IPolygonDictionary::getDatabase() const\n-{\n-    return database;\n-}\n-\n-const std::string & IPolygonDictionary::getName() const\n-{\n-    return name;\n-}\n-\n-const std::string & IPolygonDictionary::getFullName() const\n-{\n-    return full_name;\n-}\n-\n std::string IPolygonDictionary::getTypeName() const\n {\n     return \"Polygon\";\n@@ -186,7 +168,9 @@ void IPolygonDictionary::createAttributes()\n         appendNullValue(attr.underlying_type, attr.null_value);\n \n         if (attr.hierarchical)\n-            throw Exception{name + \": hierarchical attributes not supported for dictionary of polygonal type\", ErrorCodes::TYPE_MISMATCH};\n+            throw Exception{ErrorCodes::TYPE_MISMATCH,\n+                            \"{}: hierarchical attributes not supported for dictionary of polygonal type\",\n+                            getDictionaryID().getNameForLogs()};\n     }\n }\n \n@@ -297,7 +281,7 @@ size_t IPolygonDictionary::getAttributeIndex(const std::string & attribute_name)\n         const std::string & attribute_name, const Columns & key_columns, const DataTypes &, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto ind = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(null_values[ind]); \\\n \\\n@@ -327,7 +311,7 @@ void IPolygonDictionary::getString(\n         const std::string & attribute_name, const Columns & key_columns, const DataTypes &, ColumnString * out) const\n {\n     const auto ind = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = StringRef{std::get<String>(null_values[ind])};\n \n@@ -347,7 +331,7 @@ void IPolygonDictionary::getString(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto ind = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             ind, \\\n@@ -379,7 +363,7 @@ void IPolygonDictionary::getString(\n         ColumnString * const out) const\n {\n     const auto ind = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<String, StringRef>(\n             ind,\n@@ -397,7 +381,7 @@ void IPolygonDictionary::getString(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto ind = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             ind, key_columns, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -426,7 +410,7 @@ void IPolygonDictionary::getString(\n         ColumnString * const out) const\n {\n     const auto ind = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[ind].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<String, StringRef>(\n             ind,\ndiff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h\nindex ce420463605d..75114cff435a 100644\n--- a/src/Dictionaries/PolygonDictionary.h\n+++ b/src/Dictionaries/PolygonDictionary.h\n@@ -49,18 +49,13 @@ class IPolygonDictionary : public IDictionaryBase\n         Tuple,\n     };\n     IPolygonDictionary(\n-            const std::string & database_,\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n             InputType input_type_,\n             PointType point_type_);\n \n-    const std::string & getDatabase() const override;\n-    const std::string & getName() const override;\n-    const std::string & getFullName() const override;\n-\n     std::string getTypeName() const override;\n \n     std::string getKeyDescription() const;\n@@ -200,9 +195,6 @@ class IPolygonDictionary : public IDictionaryBase\n      */\n     std::vector<size_t> ids;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.cpp b/src/Dictionaries/PolygonDictionaryImplementations.cpp\nindex 4dd42ac8b6ef..6570b1128538 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.cpp\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.cpp\n@@ -18,22 +18,20 @@ namespace ErrorCodes\n }\n \n PolygonDictionarySimple::PolygonDictionarySimple(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n         InputType input_type_,\n         PointType point_type_):\n-        IPolygonDictionary(database_, name_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_)\n+        IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_)\n {\n }\n \n std::shared_ptr<const IExternalLoadable> PolygonDictionarySimple::clone() const\n {\n     return std::make_shared<PolygonDictionarySimple>(\n-            this->database,\n-            this->name,\n+            this->getDictionaryID(),\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n@@ -57,8 +55,7 @@ bool PolygonDictionarySimple::find(const Point & point, size_t & id) const\n }\n \n PolygonDictionaryIndexEach::PolygonDictionaryIndexEach(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n@@ -66,7 +63,7 @@ PolygonDictionaryIndexEach::PolygonDictionaryIndexEach(\n         PointType point_type_,\n         int min_intersections_,\n         int max_depth_)\n-        : IPolygonDictionary(database_, name_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n+        : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n           grid(min_intersections_, max_depth_, polygons),\n           min_intersections(min_intersections_),\n           max_depth(max_depth_)\n@@ -83,8 +80,7 @@ PolygonDictionaryIndexEach::PolygonDictionaryIndexEach(\n std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexEach::clone() const\n {\n     return std::make_shared<PolygonDictionaryIndexEach>(\n-            this->database,\n-            this->name,\n+            this->getDictionaryID(),\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n@@ -118,8 +114,7 @@ bool PolygonDictionaryIndexEach::find(const Point & point, size_t & id) const\n }\n \n PolygonDictionaryIndexCell::PolygonDictionaryIndexCell(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n@@ -127,7 +122,7 @@ PolygonDictionaryIndexCell::PolygonDictionaryIndexCell(\n     PointType point_type_,\n     size_t min_intersections_,\n     size_t max_depth_)\n-    : IPolygonDictionary(database_, name_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n+    : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n       index(min_intersections_, max_depth_, polygons),\n       min_intersections(min_intersections_),\n       max_depth(max_depth_)\n@@ -137,8 +132,7 @@ PolygonDictionaryIndexCell::PolygonDictionaryIndexCell(\n std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexCell::clone() const\n {\n     return std::make_shared<PolygonDictionaryIndexCell>(\n-            this->database,\n-            this->name,\n+            this->getDictionaryID(),\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n@@ -228,6 +222,8 @@ DictionaryPtr createLayout(const std::string & ,\n \n     const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n \n+    const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+\n     if constexpr (std::is_same_v<PolygonDictionary, PolygonDictionaryIndexEach> || std::is_same_v<PolygonDictionary, PolygonDictionaryIndexCell>)\n     {\n         const auto & layout_prefix = config_prefix + \".layout\";\n@@ -236,10 +232,10 @@ DictionaryPtr createLayout(const std::string & ,\n         const auto & dict_prefix = layout_prefix + \".\" + keys.front();\n         size_t max_depth = config.getUInt(dict_prefix + \".max_depth\", PolygonDictionary::kMaxDepthDefault);\n         size_t min_intersections = config.getUInt(dict_prefix + \".min_intersections\", PolygonDictionary::kMinIntersectionsDefault);\n-        return std::make_unique<PolygonDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type, min_intersections, max_depth);\n+        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type, min_intersections, max_depth);\n     }\n     else\n-        return std::make_unique<PolygonDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type);\n+        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type);\n }\n \n void registerDictionaryPolygon(DictionaryFactory & factory)\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.h b/src/Dictionaries/PolygonDictionaryImplementations.h\nindex 285569b6829a..24910c234304 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.h\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.h\n@@ -10,15 +10,14 @@ namespace DB\n \n /** Simple implementation of the polygon dictionary. Doesn't generate anything during its construction.\n   * Iterates over all stored polygons for each query, checking each of them in linear time.\n-  * Retrieves the polygon with the smallest area containing the given point. \n+  * Retrieves the polygon with the smallest area containing the given point.\n   * If there is more than one any such polygon may be returned.\n   */\n class PolygonDictionarySimple : public IPolygonDictionary\n {\n public:\n     PolygonDictionarySimple(\n-            const std::string & database_,\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n@@ -32,17 +31,16 @@ class PolygonDictionarySimple : public IPolygonDictionary\n };\n \n /** A polygon dictionary which generates a recursive grid in order to efficiently cut the number\n-  * of polygons to be checked for a given point. \n+  * of polygons to be checked for a given point.\n   * For more detail see the GridRoot and FinalCell classes.\n-  * Separately, a slab index is built for each individual polygon. This allows to check the \n-  * candidates more efficiently. \n+  * Separately, a slab index is built for each individual polygon. This allows to check the\n+  * candidates more efficiently.\n   */\n class PolygonDictionaryIndexEach : public IPolygonDictionary\n {\n public:\n     PolygonDictionaryIndexEach(\n-            const std::string & database_,\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n@@ -71,8 +69,7 @@ class PolygonDictionaryIndexCell : public IPolygonDictionary\n {\n public:\n     PolygonDictionaryIndexCell(\n-            const std::string & database_,\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex eed5815333ad..eeed581c6f46 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -69,15 +69,12 @@ static bool operator<(const RangeHashedDictionary::Range & left, const RangeHash\n \n \n RangeHashedDictionary::RangeHashedDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -160,8 +157,8 @@ void RangeHashedDictionary::createAttributes()\n         attributes.push_back(createAttributeWithType(attribute.underlying_type, attribute.null_value));\n \n         if (attribute.hierarchical)\n-            throw Exception{full_name + \": hierarchical attributes not supported by \" + getName() + \" dictionary.\",\n-                            ErrorCodes::BAD_ARGUMENTS};\n+            throw Exception{ErrorCodes::BAD_ARGUMENTS, \"Hierarchical attributes not supported by {} dictionary.\",\n+                            getDictionaryID().getNameForLogs()};\n     }\n }\n \n@@ -689,11 +686,10 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)\n             throw Exception{full_name + \": dictionary of layout 'range_hashed' requires .structure.range_min and .structure.range_max\",\n                             ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<RangeHashedDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<RangeHashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n     };\n     factory.registerLayout(\"range_hashed\", create_layout, false);\n }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex eba10bbbdbb1..46ae0390b6ab 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -18,17 +18,12 @@ class RangeHashedDictionary final : public IDictionaryBase\n {\n public:\n     RangeHashedDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n         bool require_nonempty_);\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"RangeHashed\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n@@ -43,7 +38,7 @@ class RangeHashedDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<RangeHashedDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);\n+        return std::make_shared<RangeHashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -211,9 +206,6 @@ class RangeHashedDictionary final : public IDictionaryBase\n \n     friend struct RangeHashedDIctionaryCallGetBlockInputStreamImpl;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/SSDCacheDictionary.cpp b/src/Dictionaries/SSDCacheDictionary.cpp\nindex 6c789b255d3e..1ed9bbf21d07 100644\n--- a/src/Dictionaries/SSDCacheDictionary.cpp\n+++ b/src/Dictionaries/SSDCacheDictionary.cpp\n@@ -1276,7 +1276,7 @@ void SSDCacheStorage::collectGarbage()\n }\n \n SSDCacheDictionary::SSDCacheDictionary(\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n@@ -1287,7 +1287,7 @@ SSDCacheDictionary::SSDCacheDictionary(\n     const size_t read_buffer_size_,\n     const size_t write_buffer_size_,\n     const size_t max_stored_keys_)\n-    : name(name_)\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr(std::move(source_ptr_))\n     , dict_lifetime(dict_lifetime_)\n@@ -1314,7 +1314,7 @@ SSDCacheDictionary::SSDCacheDictionary(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         const auto null_value = std::get<TYPE>(null_values[index]); /* NOLINT */ \\\n         getItemsNumberImpl<TYPE, TYPE>(index, ids, out, [&](const size_t) { return null_value; }); /* NOLINT */ \\\n     }\n@@ -1343,7 +1343,7 @@ SSDCacheDictionary::SSDCacheDictionary(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>( \\\n             index, \\\n             ids, \\\n@@ -1374,7 +1374,7 @@ SSDCacheDictionary::SSDCacheDictionary(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>( \\\n             index, \\\n             ids, \\\n@@ -1430,7 +1430,7 @@ void SSDCacheDictionary::getItemsNumberImpl(\n void SSDCacheDictionary::getString(const std::string & attribute_name, const PaddedPODArray<Key> & ids, ColumnString * out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     const auto null_value = StringRef{std::get<String>(null_values[index])};\n \n@@ -1441,7 +1441,7 @@ void SSDCacheDictionary::getString(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const ColumnString * const def, ColumnString * const out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl(index, ids, out, [&](const size_t row) { return def->getDataAt(row); });\n }\n@@ -1450,7 +1450,7 @@ void SSDCacheDictionary::getString(\n         const std::string & attribute_name, const PaddedPODArray<Key> & ids, const String & def, ColumnString * const out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl(index, ids, out, [&](const size_t) { return StringRef{def}; });\n }\n@@ -1640,6 +1640,8 @@ void registerDictionarySSDCache(DictionaryFactory & factory)\n         if (dict_struct.key)\n             throw Exception{\"'key' is not supported for dictionary of layout 'cache'\", ErrorCodes::UNSUPPORTED_METHOD};\n \n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+\n         if (dict_struct.range_min || dict_struct.range_max)\n             throw Exception{name\n                             + \": elements .structure.range_min and .structure.range_max should be defined only \"\n@@ -1686,7 +1688,7 @@ void registerDictionarySSDCache(DictionaryFactory & factory)\n \n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         return std::make_unique<SSDCacheDictionary>(\n-                name, dict_struct, std::move(source_ptr), dict_lifetime, path,\n+                dict_id, dict_struct, std::move(source_ptr), dict_lifetime, path,\n                 max_partitions_count, file_size / block_size, block_size,\n                 read_buffer_size / block_size, write_buffer_size / block_size,\n                 max_stored_keys);\ndiff --git a/src/Dictionaries/SSDCacheDictionary.h b/src/Dictionaries/SSDCacheDictionary.h\nindex 5574503c2378..7199f0386fbd 100644\n--- a/src/Dictionaries/SSDCacheDictionary.h\n+++ b/src/Dictionaries/SSDCacheDictionary.h\n@@ -300,7 +300,7 @@ class SSDCacheDictionary final : public IDictionary\n {\n public:\n     SSDCacheDictionary(\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n@@ -312,10 +312,6 @@ class SSDCacheDictionary final : public IDictionary\n             size_t write_buffer_size_,\n             size_t max_stored_keys_);\n \n-    const std::string & getDatabase() const override { return name; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return getName(); }\n-\n     std::string getTypeName() const override { return \"SSDCache\"; }\n \n     size_t getBytesAllocated() const override { return storage.getBytesAllocated(); }\n@@ -335,8 +331,8 @@ class SSDCacheDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<SSDCacheDictionary>(name, dict_struct, source_ptr->clone(), dict_lifetime, path,\n-                max_partitions_count, file_size, block_size, read_buffer_size, write_buffer_size, max_stored_keys);\n+        return std::make_shared<SSDCacheDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime,\n+                path, max_partitions_count, file_size, block_size, read_buffer_size, write_buffer_size, max_stored_keys);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\ndiff --git a/src/Dictionaries/SSDComplexKeyCacheDictionary.cpp b/src/Dictionaries/SSDComplexKeyCacheDictionary.cpp\nindex 21fd4140f70d..826a61f73129 100644\n--- a/src/Dictionaries/SSDComplexKeyCacheDictionary.cpp\n+++ b/src/Dictionaries/SSDComplexKeyCacheDictionary.cpp\n@@ -1323,7 +1323,7 @@ void SSDComplexKeyCacheStorage::collectGarbage()\n }\n \n SSDComplexKeyCacheDictionary::SSDComplexKeyCacheDictionary(\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n@@ -1334,7 +1334,7 @@ SSDComplexKeyCacheDictionary::SSDComplexKeyCacheDictionary(\n     const size_t read_buffer_size_,\n     const size_t write_buffer_size_,\n     const size_t max_stored_keys_)\n-    : name(name_)\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr(std::move(source_ptr_))\n     , dict_lifetime(dict_lifetime_)\n@@ -1364,7 +1364,7 @@ SSDComplexKeyCacheDictionary::SSDComplexKeyCacheDictionary(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         const auto null_value = std::get<TYPE>(null_values[index]); /* NOLINT */ \\\n         getItemsNumberImpl<TYPE, TYPE>(index, key_columns, key_types, out, [&](const size_t) { return null_value; }); /* NOLINT */ \\\n     }\n@@ -1394,7 +1394,7 @@ SSDComplexKeyCacheDictionary::SSDComplexKeyCacheDictionary(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(index, key_columns, key_types, out, [&](const size_t row) { return def[row]; }); /* NOLINT */ \\\n     }\n     DECLARE(UInt8)\n@@ -1422,7 +1422,7 @@ SSDComplexKeyCacheDictionary::SSDComplexKeyCacheDictionary(\n         ResultArrayType<TYPE> & out) const \\\n     { \\\n         const auto index = getAttributeIndex(attribute_name); \\\n-        checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::ut##TYPE); \\\n         getItemsNumberImpl<TYPE, TYPE>(index, key_columns, key_types, out, [&](const size_t) { return def; }); /* NOLINT */ \\\n     }\n     DECLARE(UInt8)\n@@ -1488,7 +1488,7 @@ void SSDComplexKeyCacheDictionary::getString(\n     const Columns & key_columns, const DataTypes & key_types, ColumnString * out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     const auto null_value = StringRef{std::get<String>(null_values[index])};\n \n@@ -1501,7 +1501,7 @@ void SSDComplexKeyCacheDictionary::getString(\n         const ColumnString * const def, ColumnString * const out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl(index, key_columns, key_types, out, [&](const size_t row) { return def->getDataAt(row); });\n }\n@@ -1514,7 +1514,7 @@ void SSDComplexKeyCacheDictionary::getString(\n         ColumnString * const out) const\n {\n     const auto index = getAttributeIndex(attribute_name);\n-    checkAttributeType(name, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, dict_struct.attributes[index].underlying_type, AttributeUnderlyingType::utString);\n \n     getItemsStringImpl(index, key_columns, key_types, out, [&](const size_t) { return StringRef{def}; });\n }\n@@ -1736,6 +1736,8 @@ void registerDictionarySSDComplexKeyCache(DictionaryFactory & factory)\n                              const std::string & config_prefix,\n                              DictionarySourcePtr source_ptr) -> DictionaryPtr\n     {\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+\n         if (dict_struct.id)\n             throw Exception{\"'id' is not supported for dictionary of layout 'complex_key_cache'\", ErrorCodes::UNSUPPORTED_METHOD};\n \n@@ -1785,7 +1787,7 @@ void registerDictionarySSDComplexKeyCache(DictionaryFactory & factory)\n \n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         return std::make_unique<SSDComplexKeyCacheDictionary>(\n-                name, dict_struct, std::move(source_ptr), dict_lifetime, path,\n+                dict_id, dict_struct, std::move(source_ptr), dict_lifetime, path,\n                 max_partitions_count, file_size / block_size, block_size,\n                 read_buffer_size / block_size, write_buffer_size / block_size,\n                 max_stored_keys);\ndiff --git a/src/Dictionaries/SSDComplexKeyCacheDictionary.h b/src/Dictionaries/SSDComplexKeyCacheDictionary.h\nindex b9a8466d8c9a..89e88982eee8 100644\n--- a/src/Dictionaries/SSDComplexKeyCacheDictionary.h\n+++ b/src/Dictionaries/SSDComplexKeyCacheDictionary.h\n@@ -522,7 +522,7 @@ class SSDComplexKeyCacheDictionary final : public IDictionaryBase\n {\n public:\n     SSDComplexKeyCacheDictionary(\n-            const std::string & name_,\n+            const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             const DictionaryLifetime dict_lifetime_,\n@@ -534,10 +534,6 @@ class SSDComplexKeyCacheDictionary final : public IDictionaryBase\n             const size_t write_buffer_size_,\n             const size_t max_stored_keys_);\n \n-    const std::string & getDatabase() const override { return name; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return getName(); }\n-\n     std::string getKeyDescription() const { return dict_struct.getKeyDescription(); }\n \n     std::string getTypeName() const override { return \"SSDComplexKeyCache\"; }\n@@ -559,7 +555,7 @@ class SSDComplexKeyCacheDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<SSDComplexKeyCacheDictionary>(name, dict_struct, source_ptr->clone(), dict_lifetime, path,\n+        return std::make_shared<SSDComplexKeyCacheDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, path,\n                 max_partitions_count, file_size, block_size, read_buffer_size, write_buffer_size, max_stored_keys);\n     }\n \ndiff --git a/src/Dictionaries/TrieDictionary.cpp b/src/Dictionaries/TrieDictionary.cpp\nindex 4da52b1cd5a4..d8267047b92d 100644\n--- a/src/Dictionaries/TrieDictionary.cpp\n+++ b/src/Dictionaries/TrieDictionary.cpp\n@@ -47,15 +47,12 @@ static void validateKeyTypes(const DataTypes & key_types)\n \n \n TrieDictionary::TrieDictionary(\n-    const std::string & database_,\n-    const std::string & name_,\n+    const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_)\n-    : database(database_)\n-    , name(name_)\n-    , full_name{database_.empty() ? name_ : (database_ + \".\" + name_)}\n+    : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -80,7 +77,7 @@ TrieDictionary::~TrieDictionary()\n         validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         const auto null_value = std::get<TYPE>(attribute.null_values); \\\n \\\n@@ -112,7 +109,7 @@ void TrieDictionary::getString(\n     validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     const auto & null_value = StringRef{std::get<String>(attribute.null_values)};\n \n@@ -134,7 +131,7 @@ void TrieDictionary::getString(\n         validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, \\\n@@ -168,7 +165,7 @@ void TrieDictionary::getString(\n     validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -188,7 +185,7 @@ void TrieDictionary::getString(\n         validateKeyTypes(key_types); \\\n \\\n         const auto & attribute = getAttribute(attribute_name); \\\n-        checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n+        checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::ut##TYPE); \\\n \\\n         getItemsImpl<TYPE, TYPE>( \\\n             attribute, key_columns, [&](const size_t row, const auto value) { out[row] = value; }, [&](const size_t) { return def; }); \\\n@@ -219,7 +216,7 @@ void TrieDictionary::getString(\n     validateKeyTypes(key_types);\n \n     const auto & attribute = getAttribute(attribute_name);\n-    checkAttributeType(full_name, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n+    checkAttributeType(this, attribute_name, attribute.type, AttributeUnderlyingType::utString);\n \n     getItemsImpl<StringRef, StringRef>(\n         attribute,\n@@ -770,12 +767,11 @@ void registerDictionaryTrie(DictionaryFactory & factory)\n         if (!dict_struct.key)\n             throw Exception{\"'key' is required for dictionary of layout 'ip_trie'\", ErrorCodes::BAD_ARGUMENTS};\n \n-        const String database = config.getString(config_prefix + \".database\", \"\");\n-        const String name = config.getString(config_prefix + \".name\");\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n         // This is specialised trie for storing IPv4 and IPv6 prefixes.\n-        return std::make_unique<TrieDictionary>(database, name, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<TrieDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n     };\n     factory.registerLayout(\"ip_trie\", create_layout, true);\n }\ndiff --git a/src/Dictionaries/TrieDictionary.h b/src/Dictionaries/TrieDictionary.h\nindex 063a73b03464..1849f1619351 100644\n--- a/src/Dictionaries/TrieDictionary.h\n+++ b/src/Dictionaries/TrieDictionary.h\n@@ -23,8 +23,7 @@ class TrieDictionary final : public IDictionaryBase\n {\n public:\n     TrieDictionary(\n-        const std::string & database_,\n-        const std::string & name_,\n+        const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n@@ -34,10 +33,6 @@ class TrieDictionary final : public IDictionaryBase\n \n     std::string getKeyDescription() const { return key_description; }\n \n-    const std::string & getDatabase() const override { return database; }\n-    const std::string & getName() const override { return name; }\n-    const std::string & getFullName() const override { return full_name; }\n-\n     std::string getTypeName() const override { return \"Trie\"; }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n@@ -52,7 +47,7 @@ class TrieDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<TrieDictionary>(database, name, dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);\n+        return std::make_shared<TrieDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -230,9 +225,6 @@ class TrieDictionary final : public IDictionaryBase\n \n     Columns getKeyColumns() const;\n \n-    const std::string database;\n-    const std::string name;\n-    const std::string full_name;\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\ndiff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\nindex 30e0ac8bdc73..c194123f0473 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n@@ -469,6 +469,14 @@ DictionaryConfigurationPtr getDictionaryConfigurationFromAST(const ASTCreateQuer\n     AutoPtr<Text> database(xml_document->createTextNode(!database_.empty() ? database_ : query.database));\n     database_element->appendChild(database);\n \n+    if (query.uuid != UUIDHelpers::Nil)\n+    {\n+        AutoPtr<Poco::XML::Element> uuid_element(xml_document->createElement(\"uuid\"));\n+        current_dictionary->appendChild(uuid_element);\n+        AutoPtr<Text> uuid(xml_document->createTextNode(toString(query.uuid)));\n+        uuid_element->appendChild(uuid);\n+    }\n+\n     AutoPtr<Element> structure_element(xml_document->createElement(\"structure\"));\n     current_dictionary->appendChild(structure_element);\n     Names pk_attrs = getPrimaryKeyColumns(query.dictionary->primary_key);\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex e2cdc6d5e57d..609c247ce428 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -85,8 +85,9 @@ class FunctionDictHelper\n         auto dict = std::atomic_load(&dictionary);\n         if (dict)\n             return dict;\n-        dict = external_loader.getDictionary(dictionary_name);\n-        context.checkAccess(AccessType::dictGet, dict->getDatabaseOrNoDatabaseTag(), dict->getName());\n+        String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n+        dict = external_loader.getDictionary(resolved_name);\n+        context.checkAccess(AccessType::dictGet, dict->getDatabaseOrNoDatabaseTag(), dict->getDictionaryID().getTableName());\n         std::atomic_store(&dictionary, dict);\n         return dict;\n     }\ndiff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp\nindex 49b79ad0314c..28a21dd09296 100644\n--- a/src/Interpreters/DatabaseCatalog.cpp\n+++ b/src/Interpreters/DatabaseCatalog.cpp\n@@ -12,6 +12,7 @@\n #include <Parsers/formatAST.h>\n #include <IO/ReadHelpers.h>\n #include <Poco/DirectoryIterator.h>\n+#include <Common/renameat2.h>\n \n #include <filesystem>\n \n@@ -144,9 +145,12 @@ void DatabaseCatalog::shutdownImpl()\n     for (auto & database : current_databases)\n         database.second->shutdown();\n \n+    tables_marked_dropped.clear();\n+\n     std::lock_guard lock(databases_mutex);\n     assert(std::find_if_not(uuid_map.begin(), uuid_map.end(), [](const auto & elem) { return elem.map.empty(); }) == uuid_map.end());\n     databases.clear();\n+    db_uuid_map.clear();\n     view_dependencies.clear();\n }\n \n@@ -215,6 +219,8 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n     auto table = database->tryGetTable(table_id.table_name, context);\n     if (!table && exception)\n             exception->emplace(\"Table \" + table_id.getNameForLogs() + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+    if (!table)\n+        database = nullptr;\n \n     return {database, table};\n }\n@@ -250,7 +256,11 @@ void DatabaseCatalog::attachDatabase(const String & database_name, const Databas\n {\n     std::lock_guard lock{databases_mutex};\n     assertDatabaseDoesntExistUnlocked(database_name);\n-    databases[database_name] = database;\n+    databases.emplace(database_name, database);\n+    UUID db_uuid = database->getUUID();\n+    assert((db_uuid != UUIDHelpers::Nil) ^ (dynamic_cast<DatabaseAtomic *>(database.get()) == nullptr));\n+    if (db_uuid != UUIDHelpers::Nil)\n+        db_uuid_map.emplace(db_uuid, database);\n }\n \n \n@@ -259,13 +269,18 @@ DatabasePtr DatabaseCatalog::detachDatabase(const String & database_name, bool d\n     if (database_name == TEMPORARY_DATABASE)\n         throw Exception(\"Cannot detach database with temporary tables.\", ErrorCodes::DATABASE_ACCESS_DENIED);\n \n-    std::shared_ptr<IDatabase> db;\n+    DatabasePtr db;\n     {\n         std::lock_guard lock{databases_mutex};\n         assertDatabaseExistsUnlocked(database_name);\n         db = databases.find(database_name)->second;\n+        db_uuid_map.erase(db->getUUID());\n+        databases.erase(database_name);\n+    }\n \n-        if (check_empty)\n+    if (check_empty)\n+    {\n+        try\n         {\n             if (!db->empty())\n                 throw Exception(\"New table appeared in database being dropped or detached. Try again.\",\n@@ -274,8 +289,11 @@ DatabasePtr DatabaseCatalog::detachDatabase(const String & database_name, bool d\n             if (!drop && database_atomic)\n                 database_atomic->assertCanBeDetached(false);\n         }\n-\n-        databases.erase(database_name);\n+        catch (...)\n+        {\n+            attachDatabase(database_name, db);\n+            throw;\n+        }\n     }\n \n     db->shutdown();\n@@ -295,6 +313,17 @@ DatabasePtr DatabaseCatalog::detachDatabase(const String & database_name, bool d\n     return db;\n }\n \n+void DatabaseCatalog::updateDatabaseName(const String & old_name, const String & new_name)\n+{\n+    std::lock_guard lock{databases_mutex};\n+    assert(databases.find(new_name) == databases.end());\n+    auto it = databases.find(old_name);\n+    assert(it != databases.end());\n+    auto db = it->second;\n+    databases.erase(it);\n+    databases.emplace(new_name, db);\n+}\n+\n DatabasePtr DatabaseCatalog::getDatabase(const String & database_name) const\n {\n     std::lock_guard lock{databases_mutex};\n@@ -312,6 +341,25 @@ DatabasePtr DatabaseCatalog::tryGetDatabase(const String & database_name) const\n     return it->second;\n }\n \n+DatabasePtr DatabaseCatalog::getDatabase(const UUID & uuid) const\n+{\n+    std::lock_guard lock{databases_mutex};\n+    auto it = db_uuid_map.find(uuid);\n+    if (it == db_uuid_map.end())\n+        throw Exception(ErrorCodes::UNKNOWN_DATABASE, \"Database UUID {} does not exist\", toString(uuid));\n+    return it->second;\n+}\n+\n+DatabasePtr DatabaseCatalog::tryGetDatabase(const UUID & uuid) const\n+{\n+    assert(uuid != UUIDHelpers::Nil);\n+    std::lock_guard lock{databases_mutex};\n+    auto it = db_uuid_map.find(uuid);\n+    if (it == db_uuid_map.end())\n+        return {};\n+    return it->second;\n+}\n+\n bool DatabaseCatalog::isDatabaseExist(const String & database_name) const\n {\n     assert(!database_name.empty());\n@@ -717,6 +765,31 @@ String DatabaseCatalog::getPathForUUID(const UUID & uuid)\n     return toString(uuid).substr(0, uuid_prefix_len) + '/' + toString(uuid) + '/';\n }\n \n+String DatabaseCatalog::resolveDictionaryName(const String & name) const\n+{\n+    /// If it's dictionary from Atomic database, then we need to convert qualified name to UUID.\n+    /// Try to split name and get id from associated StorageDictionary.\n+    /// If something went wrong, return name as is.\n+\n+    /// TODO support dot in name for dictionaries in Atomic databases\n+    auto pos = name.find('.');\n+    if (pos == std::string::npos || name.find('.', pos + 1) != std::string::npos)\n+        return name;\n+    String maybe_database_name = name.substr(0, pos);\n+    String maybe_table_name = name.substr(pos + 1);\n+\n+    auto db_and_table = tryGetDatabaseAndTable({maybe_database_name, maybe_table_name}, *global_context);\n+    if (!db_and_table.first)\n+        return name;\n+    assert(db_and_table.second);\n+    if (db_and_table.first->getUUID() == UUIDHelpers::Nil)\n+        return name;\n+    if (db_and_table.second->getName() != \"Dictionary\")\n+        return name;\n+\n+    return toString(db_and_table.second->getStorageID().uuid);\n+}\n+\n \n DDLGuard::DDLGuard(Map & map_, std::unique_lock<std::mutex> guards_lock_, const String & elem)\n         : map(map_), guards_lock(std::move(guards_lock_))\ndiff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h\nindex 540568927ccc..ad90fcc30f26 100644\n--- a/src/Interpreters/DatabaseCatalog.h\n+++ b/src/Interpreters/DatabaseCatalog.h\n@@ -123,10 +123,13 @@ class DatabaseCatalog : boost::noncopyable\n \n     void attachDatabase(const String & database_name, const DatabasePtr & database);\n     DatabasePtr detachDatabase(const String & database_name, bool drop = false, bool check_empty = true);\n+    void updateDatabaseName(const String & old_name, const String & new_name);\n \n     /// database_name must be not empty\n     DatabasePtr getDatabase(const String & database_name) const;\n     DatabasePtr tryGetDatabase(const String & database_name) const;\n+    DatabasePtr getDatabase(const UUID & uuid) const;\n+    DatabasePtr tryGetDatabase(const UUID & uuid) const;\n     bool isDatabaseExist(const String & database_name) const;\n     Databases getDatabases() const;\n \n@@ -168,6 +171,9 @@ class DatabaseCatalog : boost::noncopyable\n     String getPathForDroppedMetadata(const StorageID & table_id) const;\n     void enqueueDroppedTableCleanup(StorageID table_id, StoragePtr table, String dropped_metadata_path, bool ignore_delay = false);\n \n+    /// Try convert qualified dictionary name to persistent UUID\n+    String resolveDictionaryName(const String & name) const;\n+\n private:\n     // The global instance of database catalog. unique_ptr is to allow\n     // deferred initialization. Thought I'd use std::optional, but I can't\n@@ -211,6 +217,8 @@ class DatabaseCatalog : boost::noncopyable\n     static constexpr size_t reschedule_time_ms = 100;\n \n private:\n+    using UUIDToDatabaseMap = std::unordered_map<UUID, DatabasePtr>;\n+\n     /// For some reason Context is required to get Storage from Database object\n     Context * global_context;\n     mutable std::mutex databases_mutex;\n@@ -218,6 +226,7 @@ class DatabaseCatalog : boost::noncopyable\n     ViewDependencies view_dependencies;\n \n     Databases databases;\n+    UUIDToDatabaseMap db_uuid_map;\n     UUIDToStorageMap uuid_map;\n \n     Poco::Logger * log;\ndiff --git a/src/Interpreters/ExternalDictionariesLoader.cpp b/src/Interpreters/ExternalDictionariesLoader.cpp\nindex ebbac4c54710..c735dd76911b 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.cpp\n+++ b/src/Interpreters/ExternalDictionariesLoader.cpp\n@@ -18,7 +18,7 @@ ExternalDictionariesLoader::ExternalDictionariesLoader(Context & context_)\n     : ExternalLoader(\"external dictionary\", &Poco::Logger::get(\"ExternalDictionariesLoader\"))\n     , context(context_)\n {\n-    setConfigSettings({\"dictionary\", \"name\", \"database\"});\n+    setConfigSettings({\"dictionary\", \"name\", \"database\", \"uuid\"});\n     enableAsyncLoading(true);\n     enablePeriodicUpdates(true);\n }\ndiff --git a/src/Interpreters/ExternalLoader.cpp b/src/Interpreters/ExternalLoader.cpp\nindex cd46845e2edc..e8df205760a6 100644\n--- a/src/Interpreters/ExternalLoader.cpp\n+++ b/src/Interpreters/ExternalLoader.cpp\n@@ -290,18 +290,27 @@ class ExternalLoader::LoadablesConfigReader : private boost::noncopyable\n                     continue;\n                 }\n \n-                String object_name = file_contents.getString(key + \".\" + settings.external_name);\n+                /// Use uuid as name if possible\n+                String object_uuid = file_contents.getString(key + \".\" + settings.external_uuid, \"\");\n+                String object_name;\n+                if (object_uuid.empty())\n+                    object_name = file_contents.getString(key + \".\" + settings.external_name);\n+                else\n+                    object_name = object_uuid;\n                 if (object_name.empty())\n                 {\n                     LOG_WARNING(log, \"{}: node '{}' defines {} with an empty name. It's not allowed\", path, key, type_name);\n                     continue;\n                 }\n \n-                String database;\n-                if (!settings.external_database.empty())\n-                    database = file_contents.getString(key + \".\" + settings.external_database, \"\");\n-                if (!database.empty())\n-                    object_name = database + \".\" + object_name;\n+                if (object_uuid.empty())\n+                {\n+                    String database;\n+                    if (!settings.external_database.empty())\n+                        database = file_contents.getString(key + \".\" + settings.external_database, \"\");\n+                    if (!database.empty())\n+                        object_name = database + \".\" + object_name;\n+                }\n \n                 objects.emplace(object_name, key);\n             }\ndiff --git a/src/Interpreters/ExternalLoader.h b/src/Interpreters/ExternalLoader.h\nindex 542a40e6cb22..57b711d7f21d 100644\n--- a/src/Interpreters/ExternalLoader.h\n+++ b/src/Interpreters/ExternalLoader.h\n@@ -27,6 +27,7 @@ struct ExternalLoaderConfigSettings\n     std::string external_config;\n     std::string external_name;\n     std::string external_database;\n+    std::string external_uuid;\n };\n \n /** Interface for manage user-defined objects.\ndiff --git a/src/Interpreters/ExternalLoaderDatabaseConfigRepository.cpp b/src/Interpreters/ExternalLoaderDatabaseConfigRepository.cpp\nindex 5f8f6f7c4316..bd29bfb89700 100644\n--- a/src/Interpreters/ExternalLoaderDatabaseConfigRepository.cpp\n+++ b/src/Interpreters/ExternalLoaderDatabaseConfigRepository.cpp\n@@ -1,5 +1,9 @@\n #include <Interpreters/ExternalLoaderDatabaseConfigRepository.h>\n+#include <Interpreters/Context.h>\n+#include <Storages/IStorage.h>\n #include <Common/StringUtils/StringUtils.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n \n \n namespace DB\n@@ -12,11 +16,25 @@ namespace ErrorCodes\n \n namespace\n {\n-    String trimDatabaseName(const std::string & loadable_definition_name, const String & database_name)\n+    String trimDatabaseName(const std::string & loadable_definition_name, const String & database_name,\n+                            const IDatabase & database, const Context & global_context)\n     {\n+        bool is_atomic_database = database.getUUID() != UUIDHelpers::Nil;\n+        if (is_atomic_database)\n+        {\n+            /// We do not know actual database and dictionary names here\n+            auto dict_id = StorageID::createEmpty();\n+            dict_id.uuid = parseFromString<UUID>(loadable_definition_name);\n+            assert(dict_id.uuid != UUIDHelpers::Nil);\n+            /// Get associated StorageDictionary by UUID\n+            auto table = DatabaseCatalog::instance().getTable(dict_id, global_context);\n+            auto dict_id_with_names = table->getStorageID();\n+            return dict_id_with_names.table_name;\n+        }\n+\n         if (!startsWith(loadable_definition_name, database_name))\n-            throw Exception(\n-                \"Loadable '\" + loadable_definition_name + \"' is not from database '\" + database_name, ErrorCodes::UNKNOWN_DICTIONARY);\n+            throw Exception(ErrorCodes::UNKNOWN_DICTIONARY,\n+                            \"Loadable '{}' is not from database '{}'\", loadable_definition_name, database_name);\n         ///    dbname.loadable_name\n         ///--> remove <---\n         return loadable_definition_name.substr(database_name.length() + 1);\n@@ -24,34 +42,45 @@ namespace\n }\n \n \n-ExternalLoaderDatabaseConfigRepository::ExternalLoaderDatabaseConfigRepository(IDatabase & database_)\n-    : database_name(database_.getDatabaseName())\n+ExternalLoaderDatabaseConfigRepository::ExternalLoaderDatabaseConfigRepository(IDatabase & database_, const Context & global_context_)\n+    : global_context(global_context_.getGlobalContext())\n+    , database_name(database_.getDatabaseName())\n     , database(database_)\n {\n }\n \n LoadablesConfigurationPtr ExternalLoaderDatabaseConfigRepository::load(const std::string & loadable_definition_name)\n {\n-    return database.getDictionaryConfiguration(trimDatabaseName(loadable_definition_name, database_name));\n+    auto dict_name = trimDatabaseName(loadable_definition_name, database_name, database, global_context);\n+    return database.getDictionaryConfiguration(dict_name);\n }\n \n bool ExternalLoaderDatabaseConfigRepository::exists(const std::string & loadable_definition_name)\n {\n-    return database.isDictionaryExist(trimDatabaseName(loadable_definition_name, database_name));\n+    auto dict_name = trimDatabaseName(loadable_definition_name, database_name, database, global_context);\n+    return database.isDictionaryExist(dict_name);\n }\n \n Poco::Timestamp ExternalLoaderDatabaseConfigRepository::getUpdateTime(const std::string & loadable_definition_name)\n {\n-    return database.getObjectMetadataModificationTime(trimDatabaseName(loadable_definition_name, database_name));\n+    auto dict_name = trimDatabaseName(loadable_definition_name, database_name, database, global_context);\n+    return database.getObjectMetadataModificationTime(dict_name);\n }\n \n std::set<std::string> ExternalLoaderDatabaseConfigRepository::getAllLoadablesDefinitionNames()\n {\n     std::set<std::string> result;\n     auto itr = database.getDictionariesIterator();\n+    bool is_atomic_database = database.getUUID() != UUIDHelpers::Nil;\n     while (itr && itr->isValid())\n     {\n-        result.insert(database_name + \".\" + itr->name());\n+        if (is_atomic_database)\n+        {\n+            assert(itr->uuid() != UUIDHelpers::Nil);\n+            result.insert(toString(itr->uuid()));\n+        }\n+        else\n+            result.insert(database_name + \".\" + itr->name());\n         itr->next();\n     }\n     return result;\ndiff --git a/src/Interpreters/ExternalLoaderDatabaseConfigRepository.h b/src/Interpreters/ExternalLoaderDatabaseConfigRepository.h\nindex d800db7a8e1c..79bd0009b03d 100644\n--- a/src/Interpreters/ExternalLoaderDatabaseConfigRepository.h\n+++ b/src/Interpreters/ExternalLoaderDatabaseConfigRepository.h\n@@ -12,7 +12,7 @@ namespace DB\n class ExternalLoaderDatabaseConfigRepository : public IExternalLoaderConfigRepository\n {\n public:\n-    ExternalLoaderDatabaseConfigRepository(IDatabase & database_);\n+    ExternalLoaderDatabaseConfigRepository(IDatabase & database_, const Context & global_context_);\n \n     const std::string & getName() const override { return database_name; }\n \n@@ -25,6 +25,7 @@ class ExternalLoaderDatabaseConfigRepository : public IExternalLoaderConfigRepos\n     LoadablesConfigurationPtr load(const std::string & loadable_definition_name) override;\n \n private:\n+    const Context & global_context;\n     const String database_name;\n     IDatabase & database;\n };\ndiff --git a/src/Interpreters/ExternalModelsLoader.cpp b/src/Interpreters/ExternalModelsLoader.cpp\nindex 0300bd449491..4e9ddb782411 100644\n--- a/src/Interpreters/ExternalModelsLoader.cpp\n+++ b/src/Interpreters/ExternalModelsLoader.cpp\n@@ -14,7 +14,7 @@ ExternalModelsLoader::ExternalModelsLoader(Context & context_)\n     : ExternalLoader(\"external model\", &Poco::Logger::get(\"ExternalModelsLoader\"))\n     , context(context_)\n {\n-    setConfigSettings({\"model\", \"name\", {}});\n+    setConfigSettings({\"model\", \"name\", {}, {}});\n     enablePeriodicUpdates(true);\n }\n \ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex ebd6c1e8de43..cd2e45323d1b 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -1,6 +1,6 @@\n #include <memory>\n \n-#include <Poco/File.h>\n+#include <filesystem>\n \n #include <Common/StringUtils/StringUtils.h>\n #include <Common/escapeForFileName.h>\n@@ -47,6 +47,7 @@\n \n #include <Databases/DatabaseFactory.h>\n #include <Databases/IDatabase.h>\n+#include <Databases/DatabaseOnDisk.h>\n \n #include <Dictionaries/getDictionaryConfigurationFromAST.h>\n \n@@ -76,6 +77,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n+namespace fs = std::filesystem;\n \n InterpreterCreateQuery::InterpreterCreateQuery(const ASTPtr & query_ptr_, Context & context_)\n     : query_ptr(query_ptr_), context(context_)\n@@ -98,7 +100,27 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n             throw Exception(\"Database \" + database_name + \" already exists.\", ErrorCodes::DATABASE_ALREADY_EXISTS);\n     }\n \n-    if (!create.storage)\n+\n+    /// Will write file with database metadata, if needed.\n+    String database_name_escaped = escapeForFileName(database_name);\n+    fs::path metadata_path = fs::canonical(context.getPath());\n+    fs::path metadata_file_tmp_path = metadata_path / \"metadata\" / (database_name_escaped + \".sql.tmp\");\n+    fs::path metadata_file_path = metadata_path / \"metadata\" / (database_name_escaped + \".sql\");\n+\n+    if (!create.storage && create.attach)\n+    {\n+        if (!fs::exists(metadata_file_path))\n+            throw Exception(\"Database engine must be specified for ATTACH DATABASE query\", ErrorCodes::UNKNOWN_DATABASE_ENGINE);\n+        /// Short syntax: try read database definition from file\n+        auto ast = DatabaseOnDisk::parseQueryFromMetadata(nullptr, context, metadata_file_path);\n+        create = ast->as<ASTCreateQuery &>();\n+        if (!create.table.empty() || !create.storage)\n+            throw Exception(ErrorCodes::INCORRECT_QUERY, \"Metadata file {} contains incorrect CREATE DATABASE query\", metadata_file_path);\n+        create.attach = true;\n+        create.attach_short_syntax = true;\n+        create.database = database_name;\n+    }\n+    else if (!create.storage)\n     {\n         /// For new-style databases engine is explicitly specified in .sql\n         /// When attaching old-style database during server startup, we must always use Ordinary engine\n@@ -119,20 +141,39 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n         throw Exception(\"Unknown database engine: \" + ostr.str(), ErrorCodes::UNKNOWN_DATABASE_ENGINE);\n     }\n \n-    if (create.storage->engine->name == \"Atomic\" && !context.getSettingsRef().allow_experimental_database_atomic && !internal)\n-        throw Exception(\"Atomic is an experimental database engine. Enable allow_experimental_database_atomic to use it.\",\n-                        ErrorCodes::UNKNOWN_DATABASE_ENGINE);\n+    if (create.storage->engine->name == \"Atomic\")\n+    {\n+        if (!context.getSettingsRef().allow_experimental_database_atomic && !internal)\n+            throw Exception(\"Atomic is an experimental database engine. \"\n+                            \"Enable allow_experimental_database_atomic to use it.\", ErrorCodes::UNKNOWN_DATABASE_ENGINE);\n \n-    String database_name_escaped = escapeForFileName(database_name);\n-    String path = context.getPath();\n-    String metadata_path = path + \"metadata/\" + database_name_escaped + \"/\";\n-    DatabasePtr database = DatabaseFactory::get(database_name, metadata_path, create.storage, context);\n+        if (create.attach && create.uuid == UUIDHelpers::Nil)\n+            throw Exception(\"UUID must be specified for ATTACH\", ErrorCodes::INCORRECT_QUERY);\n+        else if (create.uuid == UUIDHelpers::Nil)\n+            create.uuid = UUIDHelpers::generateV4();\n \n-    /// Will write file with database metadata, if needed.\n-    String metadata_file_tmp_path = path + \"metadata/\" + database_name_escaped + \".sql.tmp\";\n-    String metadata_file_path = path + \"metadata/\" + database_name_escaped + \".sql\";\n+        metadata_path = metadata_path / \"store\" / DatabaseCatalog::getPathForUUID(create.uuid);\n+\n+        if (!create.attach && fs::exists(metadata_path))\n+            throw Exception(ErrorCodes::DATABASE_ALREADY_EXISTS, \"Metadata directory {} already exists\", metadata_path);\n+    }\n+    else\n+    {\n+        bool is_on_cluster = context.getClientInfo().query_kind == ClientInfo::QueryKind::SECONDARY_QUERY;\n+        if (create.uuid != UUIDHelpers::Nil && !is_on_cluster)\n+            throw Exception(\"Ordinary database engine does not support UUID\", ErrorCodes::INCORRECT_QUERY);\n \n-    bool need_write_metadata = !create.attach;\n+        /// Ignore UUID if it's ON CLUSTER query\n+        create.uuid = UUIDHelpers::Nil;\n+        metadata_path = metadata_path / \"metadata\" / database_name_escaped;\n+    }\n+\n+    DatabasePtr database = DatabaseFactory::get(create, metadata_path / \"\", context);\n+\n+    if (create.uuid != UUIDHelpers::Nil)\n+        create.database = TABLE_WITH_UUID_NAME_PLACEHOLDER;\n+\n+    bool need_write_metadata = !create.attach || !fs::exists(metadata_file_path);\n \n     if (need_write_metadata)\n     {\n@@ -164,7 +205,7 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n \n         if (need_write_metadata)\n         {\n-            Poco::File(metadata_file_tmp_path).renameTo(metadata_file_path);\n+            fs::rename(metadata_file_tmp_path, metadata_file_path);\n             renamed = true;\n         }\n \n@@ -173,7 +214,10 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n     catch (...)\n     {\n         if (renamed)\n-            Poco::File(metadata_file_tmp_path).remove();\n+        {\n+            [[maybe_unused]] bool removed = fs::remove(metadata_file_tmp_path);\n+            assert(removed);\n+        }\n         if (added)\n             DatabaseCatalog::instance().detachDatabase(database_name, false, false);\n \n@@ -561,6 +605,32 @@ void InterpreterCreateQuery::setEngine(ASTCreateQuery & create) const\n     }\n }\n \n+void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const DatabasePtr & database) const\n+{\n+    const auto * kind = create.is_dictionary ? \"Dictionary\" : \"Table\";\n+    const auto * kind_upper = create.is_dictionary ? \"DICTIONARY\" : \"TABLE\";\n+\n+    if (database->getEngineName() == \"Atomic\")\n+    {\n+        if (create.attach && create.uuid == UUIDHelpers::Nil)\n+            throw Exception(ErrorCodes::INCORRECT_QUERY,\n+                            \"UUID must be specified in ATTACH {} query for Atomic database engine\",\n+                            kind_upper);\n+        if (!create.attach && create.uuid == UUIDHelpers::Nil)\n+            create.uuid = UUIDHelpers::generateV4();\n+    }\n+    else\n+    {\n+        bool is_on_cluster = context.getClientInfo().query_kind == ClientInfo::QueryKind::SECONDARY_QUERY;\n+        if (create.uuid != UUIDHelpers::Nil && !is_on_cluster)\n+            throw Exception(ErrorCodes::INCORRECT_QUERY,\n+                            \"{} UUID specified, but engine of database {} is not Atomic\", kind, create.database);\n+\n+        /// Ignore UUID if it's ON CLUSTER query\n+        create.uuid = UUIDHelpers::Nil;\n+    }\n+}\n+\n \n BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n {\n@@ -621,19 +691,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     if (need_add_to_database)\n     {\n         database = DatabaseCatalog::instance().getDatabase(create.database);\n-        if (database->getEngineName() == \"Atomic\")\n-        {\n-            /// TODO implement ATTACH FROM 'path/to/data': generate UUID and move table data to store/\n-            if (create.attach && create.uuid == UUIDHelpers::Nil)\n-                throw Exception(\"UUID must be specified in ATTACH TABLE query for Atomic database engine\", ErrorCodes::INCORRECT_QUERY);\n-            if (!create.attach && create.uuid == UUIDHelpers::Nil)\n-                create.uuid = UUIDHelpers::generateV4();\n-        }\n-        else\n-        {\n-            if (create.uuid != UUIDHelpers::Nil)\n-                throw Exception(\"Table UUID specified, but engine of database \" + create.database + \" is not Atomic\", ErrorCodes::INCORRECT_QUERY);\n-        }\n+        assertOrSetUUID(create, database);\n \n         /** If the request specifies IF NOT EXISTS, we allow concurrent CREATE queries (which do nothing).\n           * If table doesnt exist, one thread is creating table, while others wait in DDLGuard.\n@@ -662,7 +720,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n         }\n \n         data_path = database->getTableDataPath(create);\n-        if (!create.attach && !data_path.empty() && Poco::File(context.getPath() + data_path).exists())\n+        if (!create.attach && !data_path.empty() && fs::exists(fs::path{context.getPath()} / data_path))\n             throw Exception(\"Directory for table data \" + data_path + \" already exists\", ErrorCodes::TABLE_ALREADY_EXISTS);\n     }\n     else\n@@ -760,6 +818,12 @@ BlockIO InterpreterCreateQuery::createDictionary(ASTCreateQuery & create)\n         auto query = DatabaseCatalog::instance().getDatabase(database_name)->getCreateDictionaryQuery(dictionary_name);\n         create = query->as<ASTCreateQuery &>();\n         create.attach = true;\n+    }\n+\n+    assertOrSetUUID(create, database);\n+\n+    if (create.attach)\n+    {\n         auto config = getDictionaryConfigurationFromAST(create);\n         auto modification_time = database->getObjectMetadataModificationTime(dictionary_name);\n         database->attachDictionary(dictionary_name, DictionaryAttachInfo{query_ptr, config, modification_time});\n@@ -775,8 +839,12 @@ BlockIO InterpreterCreateQuery::execute()\n     auto & create = query_ptr->as<ASTCreateQuery &>();\n     if (!create.cluster.empty())\n     {\n-        /// NOTE: if it's CREATE query and create.database is DatabaseAtomic, different UUIDs will be generated on all servers.\n-        /// However, it allows to use UUID as replica name.\n+        /// Allows to execute ON CLUSTER queries during version upgrade\n+        bool force_backward_compatibility = !context.getSettingsRef().show_table_uuid_in_table_create_query_if_not_nil;\n+        /// For CREATE query generate UUID on initiator, so it will be the same on all hosts.\n+        /// It will be ignored if database does not support UUIDs.\n+        if (!force_backward_compatibility && !create.attach && create.uuid == UUIDHelpers::Nil)\n+            create.uuid = UUIDHelpers::generateV4();\n         return executeDDLQueryOnCluster(query_ptr, context, getRequiredAccess());\n     }\n \ndiff --git a/src/Interpreters/InterpreterCreateQuery.h b/src/Interpreters/InterpreterCreateQuery.h\nindex 30f18aa41345..bb7d70975e49 100644\n--- a/src/Interpreters/InterpreterCreateQuery.h\n+++ b/src/Interpreters/InterpreterCreateQuery.h\n@@ -73,6 +73,8 @@ class InterpreterCreateQuery : public IInterpreter\n     /// Inserts data in created table if it's CREATE ... SELECT\n     BlockIO fillTableIfNeeded(const ASTCreateQuery & create);\n \n+    void assertOrSetUUID(ASTCreateQuery & create, const DatabasePtr & database) const;\n+\n     ASTPtr query_ptr;\n     Context & context;\n \ndiff --git a/src/Interpreters/InterpreterRenameQuery.cpp b/src/Interpreters/InterpreterRenameQuery.cpp\nindex de2b6bb0c1cf..00f6e9b96f80 100644\n--- a/src/Interpreters/InterpreterRenameQuery.cpp\n+++ b/src/Interpreters/InterpreterRenameQuery.cpp\n@@ -5,7 +5,6 @@\n #include <Storages/IStorage.h>\n #include <Interpreters/DDLWorker.h>\n #include <Access/AccessRightsElement.h>\n-#include <Common/typeid_cast.h>\n \n \n namespace DB\n@@ -18,23 +17,6 @@ InterpreterRenameQuery::InterpreterRenameQuery(const ASTPtr & query_ptr_, Contex\n }\n \n \n-struct RenameDescription\n-{\n-    RenameDescription(const ASTRenameQuery::Element & elem, const String & current_database) :\n-        from_database_name(elem.from.database.empty() ? current_database : elem.from.database),\n-        from_table_name(elem.from.table),\n-        to_database_name(elem.to.database.empty() ? current_database : elem.to.database),\n-        to_table_name(elem.to.table)\n-    {}\n-\n-    String from_database_name;\n-    String from_table_name;\n-\n-    String to_database_name;\n-    String to_table_name;\n-};\n-\n-\n BlockIO InterpreterRenameQuery::execute()\n {\n     const auto & rename = query_ptr->as<const ASTRenameQuery &>();\n@@ -51,7 +33,7 @@ BlockIO InterpreterRenameQuery::execute()\n       *  or we will be in inconsistent state. (It is worth to be fixed.)\n       */\n \n-    std::vector<RenameDescription> descriptions;\n+    RenameDescriptions descriptions;\n     descriptions.reserve(rename.elements.size());\n \n     /// Don't allow to drop tables (that we are renaming); don't allow to create tables in places where tables will be renamed.\n@@ -75,22 +57,49 @@ BlockIO InterpreterRenameQuery::execute()\n     for (auto & table_guard : table_guards)\n         table_guard.second = database_catalog.getDDLGuard(table_guard.first.database_name, table_guard.first.table_name);\n \n-    for (auto & elem : descriptions)\n+    if (rename.database)\n+        return executeToDatabase(rename, descriptions);\n+    else\n+        return executeToTables(rename, descriptions);\n+}\n+\n+BlockIO InterpreterRenameQuery::executeToTables(const ASTRenameQuery & rename, const RenameDescriptions & descriptions)\n+{\n+    auto & database_catalog = DatabaseCatalog::instance();\n+\n+    for (const auto & elem : descriptions)\n     {\n         if (!rename.exchange)\n             database_catalog.assertTableDoesntExist(StorageID(elem.to_database_name, elem.to_table_name), context);\n \n         database_catalog.getDatabase(elem.from_database_name)->renameTable(\n-            context,\n-            elem.from_table_name,\n-            *database_catalog.getDatabase(elem.to_database_name),\n-            elem.to_table_name,\n-            rename.exchange);\n+                context,\n+                elem.from_table_name,\n+                *database_catalog.getDatabase(elem.to_database_name),\n+                elem.to_table_name,\n+                rename.exchange,\n+                rename.dictionary);\n     }\n \n     return {};\n }\n \n+BlockIO InterpreterRenameQuery::executeToDatabase(const ASTRenameQuery &, const RenameDescriptions & descriptions)\n+{\n+    assert(descriptions.size() == 1);\n+    assert(descriptions.front().from_table_name.empty());\n+    assert(descriptions.front().to_table_name.empty());\n+\n+    const auto & old_name = descriptions.front().from_database_name;\n+    const auto & new_name = descriptions.back().to_database_name;\n+    auto & catalog = DatabaseCatalog::instance();\n+\n+    auto db = catalog.getDatabase(old_name);\n+    catalog.assertDatabaseDoesntExist(new_name);\n+    db->renameDatabase(new_name);\n+    return {};\n+}\n+\n AccessRightsElements InterpreterRenameQuery::getRequiredAccess() const\n {\n     AccessRightsElements required_access;\n@@ -99,6 +108,11 @@ AccessRightsElements InterpreterRenameQuery::getRequiredAccess() const\n     {\n         required_access.emplace_back(AccessType::SELECT | AccessType::DROP_TABLE, elem.from.database, elem.from.table);\n         required_access.emplace_back(AccessType::CREATE_TABLE | AccessType::INSERT, elem.to.database, elem.to.table);\n+        if (rename.exchange)\n+        {\n+            required_access.emplace_back(AccessType::CREATE_TABLE | AccessType::INSERT, elem.from.database, elem.from.table);\n+            required_access.emplace_back(AccessType::SELECT | AccessType::DROP_TABLE, elem.to.database, elem.to.table);\n+        }\n     }\n     return required_access;\n }\ndiff --git a/src/Interpreters/InterpreterRenameQuery.h b/src/Interpreters/InterpreterRenameQuery.h\nindex 070601e39d8b..f2c08f22602d 100644\n--- a/src/Interpreters/InterpreterRenameQuery.h\n+++ b/src/Interpreters/InterpreterRenameQuery.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <Interpreters/IInterpreter.h>\n-#include <Parsers/IAST_fwd.h>\n+#include <Parsers/ASTRenameQuery.h>\n \n \n namespace DB\n@@ -25,6 +25,24 @@ struct UniqueTableName\n     }\n };\n \n+struct RenameDescription\n+{\n+    RenameDescription(const ASTRenameQuery::Element & elem, const String & current_database) :\n+            from_database_name(elem.from.database.empty() ? current_database : elem.from.database),\n+            from_table_name(elem.from.table),\n+            to_database_name(elem.to.database.empty() ? current_database : elem.to.database),\n+            to_table_name(elem.to.table)\n+    {}\n+\n+    String from_database_name;\n+    String from_table_name;\n+\n+    String to_database_name;\n+    String to_table_name;\n+};\n+\n+using RenameDescriptions = std::vector<RenameDescription>;\n+\n using TableGuards = std::map<UniqueTableName, std::unique_ptr<DDLGuard>>;\n \n /** Rename one table\n@@ -37,6 +55,9 @@ class InterpreterRenameQuery : public IInterpreter\n     BlockIO execute() override;\n \n private:\n+    BlockIO executeToTables(const ASTRenameQuery & rename, const RenameDescriptions & descriptions);\n+    static BlockIO executeToDatabase(const ASTRenameQuery & rename, const RenameDescriptions & descriptions);\n+\n     AccessRightsElements getRequiredAccess() const;\n \n     ASTPtr query_ptr;\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 7c80b6811142..4bfa84090c2c 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -233,7 +233,8 @@ BlockIO InterpreterSystemQuery::execute()\n #endif\n         case Type::RELOAD_DICTIONARY:\n             context.checkAccess(AccessType::SYSTEM_RELOAD_DICTIONARY);\n-            system_context.getExternalDictionariesLoader().loadOrReload(query.target_dictionary);\n+            system_context.getExternalDictionariesLoader().loadOrReload(\n+                    DatabaseCatalog::instance().resolveDictionaryName(query.target_dictionary));\n             ExternalDictionariesLoader::resetAll();\n             break;\n         case Type::RELOAD_DICTIONARIES:\n@@ -392,7 +393,7 @@ void InterpreterSystemQuery::restartReplicas(Context & system_context)\n             if (auto table = iterator->table())\n             {\n                 if (dynamic_cast<const StorageReplicatedMergeTree *>(table.get()))\n-                    replica_names.emplace_back(StorageID{database->getDatabaseName(), iterator->name()});\n+                    replica_names.emplace_back(StorageID{iterator->databaseName(), iterator->name()});\n             }\n         }\n     }\ndiff --git a/src/Interpreters/StorageID.cpp b/src/Interpreters/StorageID.cpp\nindex 9bf9047a2dd6..96d7b59088dc 100644\n--- a/src/Interpreters/StorageID.cpp\n+++ b/src/Interpreters/StorageID.cpp\n@@ -3,7 +3,9 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Common/quoteString.h>\n #include <IO/WriteHelpers.h>\n+#include <IO/ReadHelpers.h>\n #include <Interpreters/DatabaseAndTableWithAlias.h>\n+#include <Poco/Util/AbstractConfiguration.h>\n \n namespace DB\n {\n@@ -82,4 +84,31 @@ String StorageID::getFullTableName() const\n     return backQuoteIfNeed(getDatabaseName()) + \".\" + backQuoteIfNeed(table_name);\n }\n \n+String StorageID::getFullNameNotQuoted() const\n+{\n+    return getDatabaseName() + \".\" + table_name;\n+}\n+\n+StorageID StorageID::fromDictionaryConfig(const Poco::Util::AbstractConfiguration & config,\n+                                          const String & config_prefix)\n+{\n+    StorageID res = StorageID::createEmpty();\n+    res.database_name = config.getString(config_prefix + \".database\", \"\");\n+    res.table_name = config.getString(config_prefix + \".name\");\n+    const String uuid_str = config.getString(config_prefix + \".uuid\", \"\");\n+    if (!uuid_str.empty())\n+        res.uuid = parseFromString<UUID>(uuid_str);\n+    return res;\n+}\n+\n+String StorageID::getInternalDictionaryName() const\n+{\n+    assertNotEmpty();\n+    if (hasUUID())\n+        return toString(uuid);\n+    if (database_name.empty())\n+        return table_name;\n+    return database_name + \".\" + table_name;\n+}\n+\n }\ndiff --git a/src/Interpreters/StorageID.h b/src/Interpreters/StorageID.h\nindex acbc27a50917..36265b2a2b02 100644\n--- a/src/Interpreters/StorageID.h\n+++ b/src/Interpreters/StorageID.h\n@@ -6,13 +6,20 @@\n #include <Core/QualifiedTableName.h>\n #include <Common/Exception.h>\n \n+namespace Poco\n+{\n+namespace Util\n+{\n+class AbstractConfiguration;\n+}\n+}\n+\n namespace DB\n {\n \n namespace ErrorCodes\n {\n-    extern const int BAD_ARGUMENTS;\n-    extern const int LOGICAL_ERROR;\n+    extern const int UNKNOWN_TABLE;\n }\n \n static constexpr char const * TABLE_WITH_UUID_NAME_PLACEHOLDER = \"_\";\n@@ -42,6 +49,7 @@ struct StorageID\n     String getTableName() const;\n \n     String getFullTableName() const;\n+    String getFullNameNotQuoted() const;\n \n     String getNameForLogs() const;\n \n@@ -66,15 +74,9 @@ struct StorageID\n     {\n         // Can be triggered by user input, e.g. SELECT joinGetOrNull('', 'num', 500)\n         if (empty())\n-            throw Exception(\"Table name cannot be empty. Please specify a valid table name or UUID\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        // This can also be triggered by user input, but we haven't decided what\n-        // to do about it: create table \"_\"(a int) engine Log;\n-        if (table_name == TABLE_WITH_UUID_NAME_PLACEHOLDER && !hasUUID())\n-            throw Exception(\"Table name was replaced with placeholder, but UUID is Nil\", ErrorCodes::LOGICAL_ERROR);\n-\n+            throw Exception(\"Both table name and UUID are empty\", ErrorCodes::UNKNOWN_TABLE);\n         if (table_name.empty() && !database_name.empty())\n-            throw Exception(\"Table name is empty, but database name is not\", ErrorCodes::LOGICAL_ERROR);\n+            throw Exception(\"Table name is empty, but database name is not\", ErrorCodes::UNKNOWN_TABLE);\n     }\n \n     /// Avoid implicit construction of empty StorageID. However, it's needed for deferred initialization.\n@@ -82,6 +84,13 @@ struct StorageID\n \n     QualifiedTableName getQualifiedName() const { return {database_name, getTableName()}; }\n \n+    static StorageID fromDictionaryConfig(const Poco::Util::AbstractConfiguration & config,\n+                                          const String & config_prefix);\n+\n+    /// If dictionary has UUID, then use it as dictionary name in ExternalLoader to allow dictionary renaming.\n+    /// DatabaseCatalog::resolveDictionaryName(...) should be used to access such dictionaries by name.\n+    String getInternalDictionaryName() const;\n+\n private:\n     StorageID() = default;\n };\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 99eaf6e67368..3fdefb3d773e 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -131,7 +131,8 @@ void optimizeGroupBy(ASTSelectQuery * select_query, const NameSet & source_colum\n                 const auto & dict_name = dict_name_ast->value.safeGet<String>();\n                 const auto & attr_name = attr_name_ast->value.safeGet<String>();\n \n-                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(dict_name);\n+                String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dict_name);\n+                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(resolved_name);\n                 if (!dict_ptr->isInjective(attr_name))\n                 {\n                     ++i;\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 3c8238bc1237..991742575b80 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -229,7 +229,6 @@ void executeScalarSubqueries(ASTPtr & query, const Context & context, size_t sub\n     ExecuteScalarSubqueriesVisitor(visitor_data, log.stream()).visit(query);\n }\n \n-\n void getArrayJoinedColumns(ASTPtr & query, TreeRewriterResult & result, const ASTSelectQuery * select_query,\n                            const NamesAndTypesList & source_columns, const NameSet & source_columns_set)\n {\ndiff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp\nindex bf5701e1be4d..0bd972520907 100644\n--- a/src/Interpreters/loadMetadata.cpp\n+++ b/src/Interpreters/loadMetadata.cpp\n@@ -17,6 +17,7 @@\n #include <Common/escapeForFileName.h>\n \n #include <Common/typeid_cast.h>\n+#include <Common/StringUtils/StringUtils.h>\n \n \n namespace DB\n@@ -94,8 +95,19 @@ void loadMetadata(Context & context, const String & default_database_name)\n     Poco::DirectoryIterator dir_end;\n     for (Poco::DirectoryIterator it(path); it != dir_end; ++it)\n     {\n+        if (it->isLink())\n+            continue;\n+\n         if (!it->isDirectory())\n+        {\n+            if (endsWith(it.name(), \".sql\"))\n+            {\n+                String db_name = it.name().substr(0, it.name().size() - 4);\n+                if (db_name != SYSTEM_DATABASE)\n+                    databases.emplace(unescapeForFileName(db_name), path + \"/\" + db_name);\n+            }\n             continue;\n+        }\n \n         /// For '.svn', '.gitignore' directory and similar.\n         if (it.name().at(0) == '.')\ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex 201e2e455286..0df3d17846ce 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -205,6 +205,13 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n             << (if_not_exists ? \"IF NOT EXISTS \" : \"\")\n             << (settings.hilite ? hilite_none : \"\")\n             << backQuoteIfNeed(database);\n+\n+        if (uuid != UUIDHelpers::Nil)\n+        {\n+            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" UUID \" << (settings.hilite ? hilite_none : \"\")\n+                          << quoteString(toString(uuid));\n+        }\n+\n         formatOnCluster(settings);\n \n         if (storage)\n@@ -247,6 +254,9 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << (attach ? \"ATTACH \" : \"CREATE \") << \"DICTIONARY \"\n                       << (if_not_exists ? \"IF NOT EXISTS \" : \"\") << (settings.hilite ? hilite_none : \"\")\n                       << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+        if (uuid != UUIDHelpers::Nil)\n+            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" UUID \" << (settings.hilite ? hilite_none : \"\")\n+                          << quoteString(toString(uuid));\n         formatOnCluster(settings);\n     }\n \ndiff --git a/src/Parsers/ASTRenameQuery.h b/src/Parsers/ASTRenameQuery.h\nindex 9f91faffa509..951abbe44194 100644\n--- a/src/Parsers/ASTRenameQuery.h\n+++ b/src/Parsers/ASTRenameQuery.h\n@@ -30,6 +30,8 @@ class ASTRenameQuery : public ASTQueryWithOutput, public ASTQueryWithOnCluster\n     Elements elements;\n \n     bool exchange{false};   /// For EXCHANGE TABLES\n+    bool database{false};   /// For RENAME DATABASE\n+    bool dictionary{false};   /// For RENAME DICTIONARY\n \n     /** Get the text that identifies this element. */\n     String getID(char) const override { return \"Rename\"; }\n@@ -61,8 +63,24 @@ class ASTRenameQuery : public ASTQueryWithOutput, public ASTQueryWithOnCluster\n protected:\n     void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override\n     {\n-        settings.ostr << (settings.hilite ? hilite_keyword : \"\")\n-            << (exchange ? \"EXCHANGE TABLES \" : \"RENAME TABLE \") << (settings.hilite ? hilite_none : \"\");\n+        if (database)\n+        {\n+            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"RENAME DATABASE \" << (settings.hilite ? hilite_none : \"\");\n+            settings.ostr << backQuoteIfNeed(elements.at(0).from.database);\n+            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" TO \" << (settings.hilite ? hilite_none : \"\");\n+            settings.ostr << backQuoteIfNeed(elements.at(0).to.database);\n+            formatOnCluster(settings);\n+            return;\n+        }\n+\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\");\n+        if (exchange)\n+            settings.ostr << \"EXCHANGE TABLES \";\n+        else if (dictionary)\n+            settings.ostr << \"RENAME DICTIONARY \";\n+        else\n+            settings.ostr << \"RENAME TABLE \";\n+        settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n         for (auto it = elements.cbegin(); it != elements.cend(); ++it)\n         {\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 10874db5a5e9..463d2ae8f341 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -13,6 +13,7 @@\n #include <Parsers/ASTConstraintDeclaration.h>\n #include <Parsers/ParserDictionary.h>\n #include <Parsers/ParserDictionaryAttributeDeclaration.h>\n+#include <IO/ReadHelpers.h>\n \n \n namespace DB\n@@ -595,6 +596,7 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n \n     ASTPtr database;\n     ASTPtr storage;\n+    UUID uuid = UUIDHelpers::Nil;\n \n     String cluster_str;\n     bool attach = false;\n@@ -617,6 +619,15 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     if (!name_p.parse(pos, database, expected))\n         return false;\n \n+    if (ParserKeyword(\"UUID\").ignore(pos, expected))\n+    {\n+        ParserStringLiteral uuid_p;\n+        ASTPtr ast_uuid;\n+        if (!uuid_p.parse(pos, ast_uuid, expected))\n+            return false;\n+        uuid = parseFromString<UUID>(ast_uuid->as<ASTLiteral>()->value.get<String>());\n+    }\n+\n     if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n     {\n         if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n@@ -633,6 +644,7 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     query->if_not_exists = if_not_exists;\n \n     tryGetIdentifierNameInto(database, query->database);\n+    query->uuid = uuid;\n     query->cluster = cluster_str;\n \n     query->set(query->storage, storage);\n@@ -784,7 +796,7 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     ParserKeyword s_dictionary(\"DICTIONARY\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n     ParserKeyword s_on(\"ON\");\n-    ParserIdentifier name_p;\n+    ParserCompoundIdentifier dict_name_p(true);\n     ParserToken s_left_paren(TokenType::OpeningRoundBracket);\n     ParserToken s_right_paren(TokenType::ClosingRoundBracket);\n     ParserToken s_dot(TokenType::Dot);\n@@ -793,7 +805,6 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n \n     bool if_not_exists = false;\n \n-    ASTPtr database;\n     ASTPtr name;\n     ASTPtr attributes;\n     ASTPtr dictionary;\n@@ -814,16 +825,9 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     if (s_if_not_exists.ignore(pos, expected))\n         if_not_exists = true;\n \n-    if (!name_p.parse(pos, name, expected))\n+    if (!dict_name_p.parse(pos, name, expected))\n         return false;\n \n-    if (s_dot.ignore(pos))\n-    {\n-        database = name;\n-        if (!name_p.parse(pos, name, expected))\n-            return false;\n-    }\n-\n     if (s_on.ignore(pos, expected))\n     {\n         if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n@@ -850,8 +854,10 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     query->is_dictionary = true;\n     query->attach = attach;\n \n-    tryGetIdentifierNameInto(database, query->database);\n-    tryGetIdentifierNameInto(name, query->table);\n+    StorageID dict_id = getTableIdentifier(name);\n+    query->database = dict_id.database_name;\n+    query->table = dict_id.table_name;\n+    query->uuid = dict_id.uuid;\n \n     query->if_not_exists = if_not_exists;\n     query->set(query->dictionary_attributes_list, attributes);\ndiff --git a/src/Parsers/ParserRenameQuery.cpp b/src/Parsers/ParserRenameQuery.cpp\nindex abb08b503cd6..7fa4e6e5408c 100644\n--- a/src/Parsers/ParserRenameQuery.cpp\n+++ b/src/Parsers/ParserRenameQuery.cpp\n@@ -40,20 +40,52 @@ static bool parseDatabaseAndTable(\n bool ParserRenameQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserKeyword s_rename_table(\"RENAME TABLE\");\n-    ParserKeyword s_to(\"TO\");\n     ParserKeyword s_exchange_tables(\"EXCHANGE TABLES\");\n+    ParserKeyword s_rename_dictionary(\"RENAME DICTIONARY\");\n+    ParserKeyword s_rename_database(\"RENAME DATABASE\");\n+    ParserKeyword s_to(\"TO\");\n     ParserKeyword s_and(\"AND\");\n     ParserToken s_comma(TokenType::Comma);\n \n     bool exchange = false;\n-\n-    if (!s_rename_table.ignore(pos, expected))\n+    bool dictionary = false;\n+\n+    if (s_rename_table.ignore(pos, expected))\n+        ;\n+    else if (s_exchange_tables.ignore(pos, expected))\n+        exchange = true;\n+    else if (s_rename_dictionary.ignore(pos, expected))\n+        dictionary = true;\n+    else if (s_rename_database.ignore(pos, expected))\n     {\n-        if (s_exchange_tables.ignore(pos, expected))\n-            exchange = true;\n-        else\n+        ASTPtr from_db;\n+        ASTPtr to_db;\n+        ParserIdentifier db_name_p;\n+        if (!db_name_p.parse(pos, from_db, expected))\n+            return false;\n+        if (!s_to.ignore(pos, expected))\n             return false;\n+        if (!db_name_p.parse(pos, to_db, expected))\n+            return false;\n+\n+        String cluster_str;\n+        if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+        {\n+            if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n+                return false;\n+        }\n+\n+        auto query = std::make_shared<ASTRenameQuery>();\n+        query->database = true;\n+        query->elements.emplace({});\n+        tryGetIdentifierNameInto(from_db, query->elements.front().from.database);\n+        tryGetIdentifierNameInto(to_db, query->elements.front().to.database);\n+        query->cluster = cluster_str;\n+        node = query;\n+        return true;\n     }\n+    else\n+        return false;\n \n     ASTRenameQuery::Elements elements;\n \n@@ -88,6 +120,7 @@ bool ParserRenameQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n     query->elements = elements;\n     query->exchange = exchange;\n+    query->dictionary = dictionary;\n     return true;\n }\n \ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex aa9d405130f8..b78816945655 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -7,6 +7,7 @@\n \n #include <Common/typeid_cast.h>\n #include <Common/OptimizedRegularExpression.h>\n+#include <Common/Macros.h>\n \n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTIdentifier.h>\n@@ -32,6 +33,7 @@ namespace ErrorCodes\n     extern const int NO_ELEMENTS_IN_CONFIG;\n     extern const int UNKNOWN_STORAGE;\n     extern const int NO_REPLICA_NAME_GIVEN;\n+    extern const int LOGICAL_ERROR;\n }\n \n \n@@ -324,8 +326,16 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n     if (replicated)\n     {\n-        add_mandatory_param(\"path in ZooKeeper\");\n-        add_mandatory_param(\"replica name\");\n+        if (is_extended_storage_def)\n+        {\n+            add_optional_param(\"path in ZooKeeper\");\n+            add_optional_param(\"replica name\");\n+        }\n+        else\n+        {\n+            add_mandatory_param(\"path in ZooKeeper\");\n+            add_mandatory_param(\"replica name\");\n+        }\n     }\n \n     if (!is_extended_storage_def)\n@@ -394,28 +404,50 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n     if (replicated)\n     {\n-        const auto * ast = engine_args[arg_num]->as<ASTLiteral>();\n-        if (ast && ast->value.getType() == Field::Types::String)\n-            zookeeper_path = safeGet<String>(ast->value);\n-        else\n-            throw Exception(\n-                \"Path in ZooKeeper must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n-                ErrorCodes::BAD_ARGUMENTS);\n-        ++arg_num;\n+        bool has_arguments = arg_num + 2 <= arg_cnt\n+                          && engine_args[arg_num]->as<ASTLiteral>()\n+                          && engine_args[arg_num + 1]->as<ASTLiteral>();\n+\n+        if (has_arguments)\n+        {\n+            const auto * ast = engine_args[arg_num]->as<ASTLiteral>();\n+            if (ast && ast->value.getType() == Field::Types::String)\n+                zookeeper_path = safeGet<String>(ast->value);\n+            else\n+                throw Exception(\n+                        \"Path in ZooKeeper must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n+                        ErrorCodes::BAD_ARGUMENTS);\n+            ++arg_num;\n \n-        ast = engine_args[arg_num]->as<ASTLiteral>();\n-        if (ast && ast->value.getType() == Field::Types::String)\n-            replica_name = safeGet<String>(ast->value);\n+            ast = engine_args[arg_num]->as<ASTLiteral>();\n+            if (ast && ast->value.getType() == Field::Types::String)\n+                replica_name = safeGet<String>(ast->value);\n+            else\n+                throw Exception(\n+                        \"Replica name must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n+                        ErrorCodes::BAD_ARGUMENTS);\n+\n+            if (replica_name.empty())\n+                throw Exception(\n+                        \"No replica name in config\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n+                        ErrorCodes::NO_REPLICA_NAME_GIVEN);\n+            ++arg_num;\n+        }\n+        else if (is_extended_storage_def)\n+        {\n+            /// Try use default values if arguments are not specified.\n+            /// It works for ON CLUSTER queries when database engine is Atomic and there are {shard} and {replica} in config.\n+            zookeeper_path = \"/clickhouse/tables/{uuid}/{shard}\";\n+            replica_name = \"{replica}\";     /// TODO maybe use hostname if {replica} is not defined?\n+        }\n         else\n-            throw Exception(\n-                \"Replica name must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n-                ErrorCodes::BAD_ARGUMENTS);\n+            throw Exception(\"Expected zookeper_path and replica_name arguments\", ErrorCodes::LOGICAL_ERROR);\n \n-        if (replica_name.empty())\n-            throw Exception(\n-                \"No replica name in config\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n-                ErrorCodes::NO_REPLICA_NAME_GIVEN);\n-        ++arg_num;\n+        /// Allow implicit {uuid} macros only for zookeeper_path in ON CLUSTER queries\n+        bool is_on_cluster = args.local_context.getClientInfo().query_kind == ClientInfo::QueryKind::SECONDARY_QUERY;\n+        bool allow_uuid_macro = is_on_cluster || args.query.attach;\n+        zookeeper_path = args.context.getMacros()->expand(zookeeper_path, args.table_id, allow_uuid_macro);\n+        replica_name = args.context.getMacros()->expand(replica_name, args.table_id, false);\n     }\n \n     /// This merging param maybe used as part of sorting key\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex a88d2d4af4d7..59e3ca4cdc81 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -187,8 +187,8 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n                     true,                   /// require_part_metadata\n                     attach,\n                     [this] (const std::string & name) { enqueuePartForCheck(name); })\n-    , zookeeper_path(normalizeZooKeeperPath(global_context.getMacros()->expand(zookeeper_path_, table_id_.database_name, table_id_.table_name)))\n-    , replica_name(global_context.getMacros()->expand(replica_name_, table_id_.database_name, table_id_.table_name))\n+    , zookeeper_path(normalizeZooKeeperPath(zookeeper_path_))\n+    , replica_name(replica_name_)\n     , replica_path(zookeeper_path + \"/replicas/\" + replica_name)\n     , reader(*this)\n     , writer(*this)\ndiff --git a/src/Storages/System/StorageSystemDatabases.cpp b/src/Storages/System/StorageSystemDatabases.cpp\nindex 5a35e079a5b5..2a89bf341869 100644\n--- a/src/Storages/System/StorageSystemDatabases.cpp\n+++ b/src/Storages/System/StorageSystemDatabases.cpp\n@@ -1,5 +1,6 @@\n #include <Databases/IDatabase.h>\n #include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypeUUID.h>\n #include <Interpreters/Context.h>\n #include <Access/ContextAccess.h>\n #include <Storages/System/StorageSystemDatabases.h>\n@@ -15,6 +16,7 @@ NamesAndTypesList StorageSystemDatabases::getNamesAndTypes()\n         {\"engine\", std::make_shared<DataTypeString>()},\n         {\"data_path\", std::make_shared<DataTypeString>()},\n         {\"metadata_path\", std::make_shared<DataTypeString>()},\n+        {\"uuid\", std::make_shared<DataTypeUUID>()},\n     };\n }\n \n@@ -33,6 +35,7 @@ void StorageSystemDatabases::fillData(MutableColumns & res_columns, const Contex\n         res_columns[1]->insert(database.second->getEngineName());\n         res_columns[2]->insert(context.getPath() + database.second->getDataPath());\n         res_columns[3]->insert(database.second->getMetadataPath());\n+        res_columns[4]->insert(database.second->getUUID());\n    }\n }\n \ndiff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp\nindex 4c54353c44da..6661f51b02f4 100644\n--- a/src/Storages/System/StorageSystemDictionaries.cpp\n+++ b/src/Storages/System/StorageSystemDictionaries.cpp\n@@ -3,6 +3,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeEnum.h>\n+#include <DataTypes/DataTypeUUID.h>\n #include <Dictionaries/IDictionary.h>\n #include <Dictionaries/IDictionarySource.h>\n #include <Dictionaries/DictionaryStructure.h>\n@@ -25,6 +26,7 @@ NamesAndTypesList StorageSystemDictionaries::getNamesAndTypes()\n     return {\n         {\"database\", std::make_shared<DataTypeString>()},\n         {\"name\", std::make_shared<DataTypeString>()},\n+        {\"uuid\", std::make_shared<DataTypeUUID>()},\n         {\"status\", std::make_shared<DataTypeEnum8>(getStatusEnumAllPossibleValues())},\n         {\"origin\", std::make_shared<DataTypeString>()},\n         {\"type\", std::make_shared<DataTypeString>()},\n@@ -57,30 +59,23 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, const Con\n     {\n         const auto dict_ptr = std::dynamic_pointer_cast<const IDictionaryBase>(load_result.object);\n \n-        String database, short_name;\n+        StorageID dict_id = StorageID::createEmpty();\n         if (dict_ptr)\n-        {\n-            database = dict_ptr->getDatabase();\n-            short_name = dict_ptr->getName();\n-        }\n+            dict_id = dict_ptr->getDictionaryID();\n+        else if (load_result.config)\n+            dict_id = StorageID::fromDictionaryConfig(*load_result.config->config, load_result.config->key_in_config);\n         else\n-        {\n-            short_name = load_result.name;\n-            String repository_name = load_result.config ? load_result.config->repository_name : \"\";\n-            if (!repository_name.empty() && startsWith(short_name, repository_name + \".\"))\n-            {\n-                database = repository_name;\n-                short_name = short_name.substr(database.length() + 1);\n-            }\n-        }\n+            dict_id.table_name = load_result.name;\n \n+        String db_or_tag = dict_id.database_name.empty() ? IDictionary::NO_DATABASE_TAG : dict_id.database_name;\n         if (check_access_for_dictionaries\n-            && !access->isGranted(AccessType::SHOW_DICTIONARIES, database.empty() ? IDictionary::NO_DATABASE_TAG : database, short_name))\n+            && !access->isGranted(AccessType::SHOW_DICTIONARIES, db_or_tag, dict_id.table_name))\n             continue;\n \n         size_t i = 0;\n-        res_columns[i++]->insert(database);\n-        res_columns[i++]->insert(short_name);\n+        res_columns[i++]->insert(dict_id.database_name);\n+        res_columns[i++]->insert(dict_id.table_name);\n+        res_columns[i++]->insert(dict_id.uuid);\n         res_columns[i++]->insert(static_cast<Int8>(load_result.status));\n         res_columns[i++]->insert(load_result.config ? load_result.config->path : \"\");\n \n",
  "test_patch": "diff --git a/tests/config/macros.xml b/tests/config/macros.xml\nindex 1f86f5f9efdd..97c3065471f7 100644\n--- a/tests/config/macros.xml\n+++ b/tests/config/macros.xml\n@@ -1,5 +1,7 @@\n <yandex>\n     <macros>\n         <test>Hello, world!</test>\n+        <shard>s1</shard>\n+        <replica>r1</replica>\n     </macros>\n </yandex>\ndiff --git a/tests/integration/test_cluster_copier/test.py b/tests/integration/test_cluster_copier/test.py\nindex 9c2bcc22ef7b..983cac596dce 100644\n--- a/tests/integration/test_cluster_copier/test.py\n+++ b/tests/integration/test_cluster_copier/test.py\n@@ -78,7 +78,7 @@ def start(self):\n \n         for cluster_num in [\"0\", \"1\"]:\n             ddl_check_query(instance, \"DROP DATABASE IF EXISTS default ON CLUSTER cluster{}\".format(cluster_num))\n-            ddl_check_query(instance, \"CREATE DATABASE IF NOT EXISTS default ON CLUSTER cluster{}\".format(cluster_num))\n+            ddl_check_query(instance, \"CREATE DATABASE IF NOT EXISTS default ON CLUSTER cluster{} ENGINE=Ordinary\".format(cluster_num))\n \n         ddl_check_query(instance, \"CREATE TABLE hits ON CLUSTER cluster0 (d UInt64, d1 UInt64 MATERIALIZED d+1) \" +\n                                   \"ENGINE=ReplicatedMergeTree('/clickhouse/tables/cluster_{cluster}/{shard}/hits', '{replica}') \" +\n@@ -115,7 +115,7 @@ def start(self):\n \n         for cluster_num in [\"0\", \"1\"]:\n             ddl_check_query(instance, \"DROP DATABASE IF EXISTS default ON CLUSTER cluster{}\".format(cluster_num))\n-            ddl_check_query(instance, \"CREATE DATABASE IF NOT EXISTS default ON CLUSTER cluster{}\".format(cluster_num))\n+            ddl_check_query(instance, \"CREATE DATABASE IF NOT EXISTS default ON CLUSTER cluster{} ENGINE=Ordinary\".format(cluster_num))\n \n         ddl_check_query(instance, \"CREATE TABLE a ON CLUSTER cluster0 (date Date, d UInt64, d1 UInt64 ALIAS d+1) ENGINE=ReplicatedMergeTree('/clickhouse/tables/cluster_{cluster}/{shard}/a', '{replica}', date, intHash64(d), (date, intHash64(d)), 8192)\")\n         ddl_check_query(instance, \"CREATE TABLE a_all ON CLUSTER cluster0 (date Date, d UInt64) ENGINE=Distributed(cluster0, default, a, d)\")\ndiff --git a/tests/integration/test_cluster_copier/trivial_test.py b/tests/integration/test_cluster_copier/trivial_test.py\nindex c0966f77deb7..70c66653cb27 100644\n--- a/tests/integration/test_cluster_copier/trivial_test.py\n+++ b/tests/integration/test_cluster_copier/trivial_test.py\n@@ -62,7 +62,7 @@ def start(self):\n \n         for node in [source, destination]:\n             node.query(\"DROP DATABASE IF EXISTS default\")\n-            node.query(\"CREATE DATABASE IF NOT EXISTS default\")\n+            node.query(\"CREATE DATABASE IF NOT EXISTS default ENGINE=Ordinary\")\n \n         source.query(\"CREATE TABLE trivial (d UInt64, d1 UInt64 MATERIALIZED d+1) \"\n                      \"ENGINE=ReplicatedMergeTree('/clickhouse/tables/source_trivial_cluster/1/trivial', '1') \"\n@@ -181,4 +181,4 @@ def test_trivial_copy_with_move_fault(started_cluster, use_sample_offset):\n     with contextmanager(started_cluster)() as cluster:\n         for name, instance in cluster.instances.items():\n             print name, instance.ip_address\n-        raw_input(\"Cluster created, press any key to destroy...\")\n\\ No newline at end of file\n+        raw_input(\"Cluster created, press any key to destroy...\")\ndiff --git a/tests/integration/test_distributed_ddl/cluster.py b/tests/integration/test_distributed_ddl/cluster.py\nindex 280713815861..082a76cd88d7 100644\n--- a/tests/integration/test_distributed_ddl/cluster.py\n+++ b/tests/integration/test_distributed_ddl/cluster.py\n@@ -68,8 +68,8 @@ def check_all_hosts_successfully_executed(self, tsv_content, num_hosts=None):\n         assert len(set(codes)) == 1, \"\\n\" + tsv_content\n         assert codes[0] == \"0\", \"\\n\" + tsv_content\n \n-    def ddl_check_query(self, instance, query, num_hosts=None):\n-        contents = instance.query(query)\n+    def ddl_check_query(self, instance, query, num_hosts=None, settings=None):\n+        contents = instance.query(query, settings=settings)\n         self.check_all_hosts_successfully_executed(contents, num_hosts)\n         return contents\n \ndiff --git a/tests/integration/test_distributed_ddl/test.py b/tests/integration/test_distributed_ddl/test.py\nindex 8ef6f1892c52..f5dbe0ef8d29 100755\n--- a/tests/integration/test_distributed_ddl/test.py\n+++ b/tests/integration/test_distributed_ddl/test.py\n@@ -295,6 +295,22 @@ def test_socket_timeout(test_cluster):\n     for i in range(0, 100):\n         instance.query(\"select hostName() as host, count() from cluster('cluster', 'system', 'settings') group by host\")\n \n+def test_replicated_without_arguments(test_cluster):\n+    rules = test_cluster.pm_random_drops.pop_rules()\n+    instance = test_cluster.instances['ch1']\n+    test_cluster.ddl_check_query(instance, \"CREATE DATABASE test_atomic ON CLUSTER cluster ENGINE=Atomic\",\n+                                 settings={'show_table_uuid_in_table_create_query_if_not_nil': 1})\n+    test_cluster.ddl_check_query(instance, \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\",\n+                                 settings={'show_table_uuid_in_table_create_query_if_not_nil': 1})\n+    test_cluster.ddl_check_query(instance, \"DROP TABLE test_atomic.rmt ON CLUSTER cluster\")\n+    test_cluster.ddl_check_query(instance, \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\",\n+                                 settings={'show_table_uuid_in_table_create_query_if_not_nil': 1})\n+    test_cluster.ddl_check_query(instance, \"RENAME TABLE test_atomic.rmt TO test_atomic.rmt_renamed ON CLUSTER cluster\")\n+    test_cluster.ddl_check_query(instance, \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\",\n+                                 settings={'show_table_uuid_in_table_create_query_if_not_nil': 1})\n+    test_cluster.ddl_check_query(instance, \"EXCHANGE TABLES test_atomic.rmt AND test_atomic.rmt_renamed ON CLUSTER cluster\")\n+    test_cluster.pm_random_drops.push_rules(rules)\n+\n if __name__ == '__main__':\n     with contextmanager(test_cluster)() as ctx_cluster:\n        for name, instance in ctx_cluster.instances.items():\ndiff --git a/tests/integration/test_ttl_move/test.py b/tests/integration/test_ttl_move/test.py\nindex 1894f88029ed..eedcb01ee3aa 100644\n--- a/tests/integration/test_ttl_move/test.py\n+++ b/tests/integration/test_ttl_move/test.py\n@@ -97,7 +97,7 @@ def get_command(x, policy):\n         with pytest.raises(QueryRuntimeException):\n             node1.query(get_command(\"TTL d1 TO DISK 'unknown'\", \"small_jbod_with_external\"))\n \n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n         if alter:\n             node1.query(get_command(None, \"small_jbod_with_external\"))\n@@ -105,7 +105,7 @@ def get_command(x, policy):\n         with pytest.raises(QueryRuntimeException):\n             node1.query(get_command(\"TTL d1 TO VOLUME 'unknown'\", \"small_jbod_with_external\"))\n \n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n         if alter:\n             node1.query(get_command(None, \"only_jbod2\"))\n@@ -113,7 +113,7 @@ def get_command(x, policy):\n         with pytest.raises(QueryRuntimeException):\n             node1.query(get_command(\"TTL d1 TO DISK 'jbod1'\", \"only_jbod2\"))\n \n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n         if alter:\n             node1.query(get_command(None, \"only_jbod2\"))\n@@ -122,7 +122,7 @@ def get_command(x, policy):\n             node1.query(get_command(\"TTL d1 TO VOLUME 'external'\", \"only_jbod2\"))\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -155,7 +155,7 @@ def test_inserts_to_disk_work(started_cluster, name, engine, positive):\n \n     finally:\n         try:\n-            node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+            node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n         except:\n             pass\n \n@@ -204,7 +204,7 @@ def test_moves_work_after_storage_policy_change(started_cluster, name, engine):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -250,7 +250,7 @@ def test_moves_to_disk_work(started_cluster, name, engine, positive):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine\", [\n@@ -296,7 +296,7 @@ def test_moves_to_volume_work(started_cluster, name, engine):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -334,7 +334,7 @@ def test_inserts_to_volume_work(started_cluster, name, engine, positive):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"20\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine\", [\n@@ -379,7 +379,7 @@ def test_moves_to_disk_eventually_work(started_cluster, name, engine):\n         used_disks = get_used_disks_for_table(node1, name)\n         assert set(used_disks) == {\"jbod1\"}\n \n-        node1.query(\"DROP TABLE {}\".format(name_temp))\n+        node1.query(\"DROP TABLE {} NO DELAY\".format(name_temp))\n \n         time.sleep(2)\n         used_disks = get_used_disks_for_table(node1, name)\n@@ -388,8 +388,8 @@ def test_moves_to_disk_eventually_work(started_cluster, name, engine):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name_temp))\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name_temp))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n def test_replicated_download_ttl_info(started_cluster):\n@@ -420,7 +420,7 @@ def test_replicated_download_ttl_info(started_cluster):\n     finally:\n         for node in (node1, node2):\n             try:\n-                node.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+                node.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n             except:\n                 continue\n \n@@ -479,7 +479,7 @@ def test_merges_to_disk_work(started_cluster, name, engine, positive):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"16\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine\", [\n@@ -544,8 +544,8 @@ def test_merges_with_full_disk_work(started_cluster, name, engine):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"12\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name_temp))\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name_temp))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -597,7 +597,7 @@ def test_moves_after_merges_work(started_cluster, name, engine, positive):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"14\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive,bar\", [\n@@ -640,7 +640,7 @@ def test_ttls_do_not_work_after_alter(started_cluster, name, engine, positive, b\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine\", [\n@@ -702,7 +702,7 @@ def test_materialize_ttl_in_partition(started_cluster, name, engine):\n         assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == str(len(data))\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {}\".format(name))\n+        node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -799,7 +799,7 @@ def test_alter_multiple_ttls(started_cluster, name, engine, positive):\n             assert rows_count == 3\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+        node1.query(\"DROP TABLE IF EXISTS {name} NO DELAY\".format(name=name))\n \n \n @pytest.mark.parametrize(\"name,engine\", [\n@@ -897,7 +897,7 @@ def optimize_table(num):\n         assert node1.query(\"SELECT 1\") == \"1\\n\"\n         assert node1.query(\"SELECT COUNT() FROM {}\".format(name)) == \"500\\n\"\n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+        node1.query(\"DROP TABLE IF EXISTS {name} NO DELAY\".format(name=name))\n \n @pytest.mark.skip(reason=\"Flacky test\")\n @pytest.mark.parametrize(\"name,positive\", [\n@@ -950,7 +950,7 @@ def long_select():\n         assert node1.query(\"SELECT n FROM {name} ORDER BY n\".format(name=name)).splitlines() == [\"1\", \"2\", \"3\", \"4\"]\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+        node1.query(\"DROP TABLE IF EXISTS {name} NO DELAY\".format(name=name))\n \n \n @pytest.mark.parametrize(\"name,engine,positive\", [\n@@ -1040,4 +1040,4 @@ def optimize_table(num):\n             assert node1.query(\"SELECT count() FROM {name}\".format(name=name)) == \"6\\n\"\n \n     finally:\n-        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+        node1.query(\"DROP TABLE IF EXISTS {name} NO DELAY\".format(name=name))\ndiff --git a/tests/queries/0_stateless/01045_dictionaries_restrictions.sql b/tests/queries/0_stateless/01045_dictionaries_restrictions.sql\nindex 67a1d76e95b2..909e2fe8ad41 100644\n--- a/tests/queries/0_stateless/01045_dictionaries_restrictions.sql\n+++ b/tests/queries/0_stateless/01045_dictionaries_restrictions.sql\n@@ -1,6 +1,6 @@\n DROP DATABASE IF EXISTS dictdb;\n \n-CREATE DATABASE dictdb ENGINE=Ordinary;\n+CREATE DATABASE dictdb;\n \n CREATE DICTIONARY dictdb.restricted_dict (\n   key UInt64,\ndiff --git a/tests/queries/0_stateless/01107_atomic_db_detach_attach.sh b/tests/queries/0_stateless/01107_atomic_db_detach_attach.sh\nindex 59fe28ae244f..18d74a1817cf 100755\n--- a/tests/queries/0_stateless/01107_atomic_db_detach_attach.sh\n+++ b/tests/queries/0_stateless/01107_atomic_db_detach_attach.sh\n@@ -18,7 +18,7 @@ wait\n $CLICKHOUSE_CLIENT -q \"ATTACH TABLE test_01107.mt\"\n $CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01107.mt\"\n $CLICKHOUSE_CLIENT -q \"DETACH DATABASE test_01107\"\n-$CLICKHOUSE_CLIENT --allow_experimental_database_atomic=1 -q \"ATTACH DATABASE test_01107 ENGINE=Atomic\"\n+$CLICKHOUSE_CLIENT --allow_experimental_database_atomic=1 -q \"ATTACH DATABASE test_01107\"\n $CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01107.mt\"\n \n $CLICKHOUSE_CLIENT -q \"INSERT INTO test_01107.mt SELECT number + sleepEachRow(1) FROM numbers(5)\" && echo \"end\" &\ndiff --git a/tests/queries/0_stateless/01114_database_atomic.reference b/tests/queries/0_stateless/01114_database_atomic.reference\nindex dece5bd9b8bf..7980819f9af4 100644\n--- a/tests/queries/0_stateless/01114_database_atomic.reference\n+++ b/tests/queries/0_stateless/01114_database_atomic.reference\n@@ -1,9 +1,9 @@\n CREATE DATABASE test_01114_1\\nENGINE = Atomic\n CREATE DATABASE test_01114_2\\nENGINE = Atomic\n CREATE DATABASE test_01114_3\\nENGINE = Ordinary\n-test_01114_1\tAtomic\tstore\tmetadata\ttest_01114_1\n-test_01114_2\tAtomic\tstore\tmetadata\ttest_01114_2\n-test_01114_3\tOrdinary\ttest_01114_3\tmetadata\ttest_01114_3\n+test_01114_1\tAtomic\tstore\t00001114-1000-4000-8000-000000000001\t1\n+test_01114_2\tAtomic\tstore\t00001114-1000-4000-8000-000000000002\t1\n+test_01114_3\tOrdinary\ttest_01114_3\ttest_01114_3\t1\n 20\n 100\n CREATE TABLE test_01114_2.mt UUID \\'00001114-0000-4000-8000-000000000002\\'\\n(\\n    `n` UInt64\\n)\\nENGINE = MergeTree()\\nPARTITION BY n % 5\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\ndiff --git a/tests/queries/0_stateless/01114_database_atomic.sh b/tests/queries/0_stateless/01114_database_atomic.sh\nindex 0a56f551252f..c7862bf5314a 100755\n--- a/tests/queries/0_stateless/01114_database_atomic.sh\n+++ b/tests/queries/0_stateless/01114_database_atomic.sh\n@@ -12,10 +12,17 @@ $CLICKHOUSE_CLIENT --allow_experimental_database_atomic=1 -q \"CREATE DATABASE te\n $CLICKHOUSE_CLIENT --default_database_engine=Atomic --allow_experimental_database_atomic=1 -q \"CREATE DATABASE test_01114_2\"\n $CLICKHOUSE_CLIENT --default_database_engine=Ordinary -q \"CREATE DATABASE test_01114_3\"\n \n-$CLICKHOUSE_CLIENT -q \"SHOW CREATE DATABASE test_01114_1\"\n-$CLICKHOUSE_CLIENT -q \"SHOW CREATE DATABASE test_01114_2\"\n+$CLICKHOUSE_CLIENT --show_table_uuid_in_table_create_query_if_not_nil=0 -q \"SHOW CREATE DATABASE test_01114_1\"\n+$CLICKHOUSE_CLIENT --show_table_uuid_in_table_create_query_if_not_nil=0 -q \"SHOW CREATE DATABASE test_01114_2\"\n $CLICKHOUSE_CLIENT -q \"SHOW CREATE DATABASE test_01114_3\"\n-$CLICKHOUSE_CLIENT -q \"SELECT name, engine, splitByChar('/', data_path)[-2], splitByChar('/', metadata_path)[-3], splitByChar('/', metadata_path)[-2] FROM system.databases WHERE name LIKE 'test_01114_%'\"\n+\n+uuid_db_1=`$CLICKHOUSE_CLIENT -q \"SELECT uuid FROM system.databases WHERE name='test_01114_1'\"`\n+uuid_db_2=`$CLICKHOUSE_CLIENT -q \"SELECT uuid FROM system.databases WHERE name='test_01114_2'\"`\n+$CLICKHOUSE_CLIENT -q \"SELECT name,\n+                              engine,\n+                              splitByChar('/', data_path)[-2],\n+                              splitByChar('/', metadata_path)[-2] as uuid_path, ((splitByChar('/', metadata_path)[-3] as metadata) = substr(uuid_path, 1, 3)) OR metadata='metadata'\n+                              FROM system.databases WHERE name LIKE 'test_01114_%'\" | sed \"s/$uuid_db_1/00001114-1000-4000-8000-000000000001/g\" | sed \"s/$uuid_db_2/00001114-1000-4000-8000-000000000002/g\"\n \n $CLICKHOUSE_CLIENT -q \"CREATE TABLE test_01114_1.mt_tmp (n UInt64) ENGINE=MergeTree() ORDER BY tuple()\"\n $CLICKHOUSE_CLIENT -q \"INSERT INTO test_01114_1.mt_tmp SELECT * FROM numbers(100)\"\ndiff --git a/tests/queries/0_stateless/01191_rename_dictionary.reference b/tests/queries/0_stateless/01191_rename_dictionary.reference\nnew file mode 100644\nindex 000000000000..7b6ac0526888\n--- /dev/null\n+++ b/tests/queries/0_stateless/01191_rename_dictionary.reference\n@@ -0,0 +1,11 @@\n+dict\tNOT_LOADED\n+_\tMemory\n+dict\tDictionary\n+dict1\tNOT_LOADED\n+_\tMemory\n+dict1\tDictionary\n+test\n+dict2\tLOADED\n+_\tMemory\n+dict2\tDictionary\n+test\ndiff --git a/tests/queries/0_stateless/01191_rename_dictionary.sql b/tests/queries/0_stateless/01191_rename_dictionary.sql\nnew file mode 100644\nindex 000000000000..1a2440ee28bc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01191_rename_dictionary.sql\n@@ -0,0 +1,34 @@\n+DROP DATABASE IF EXISTS test_01191;\n+CREATE DATABASE test_01191 ENGINE=Atomic;\n+\n+CREATE TABLE test_01191._ (n UInt64, s String) ENGINE = Memory();\n+\n+CREATE DICTIONARY test_01191.dict (n UInt64, s String)\n+PRIMARY KEY n\n+LAYOUT(DIRECT())\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE '_' DB 'test_01191'));\n+\n+INSERT INTO test_01191._ VALUES (42, 'test');\n+\n+SELECT name, status FROM system.dictionaries WHERE database='test_01191';\n+SELECT name, engine FROM system.tables WHERE database='test_01191' ORDER BY name;\n+\n+RENAME DICTIONARY test_01191.table TO test_01191.table1; -- {serverError 80}\n+EXCHANGE TABLES test_01191.table AND test_01191.dict; -- {serverError 48}\n+EXCHANGE TABLES test_01191.dict AND test_01191.table; -- {serverError 80}\n+RENAME TABLE test_01191.dict TO test_01191.dict1; -- {serverError 80}\n+RENAME DICTIONARY test_01191.dict TO default.dict1; -- {serverError 48}\n+\n+RENAME DICTIONARY test_01191.dict TO test_01191.dict1;\n+\n+SELECT name, status FROM system.dictionaries WHERE database='test_01191';\n+SELECT name, engine FROM system.tables WHERE database='test_01191' ORDER BY name;\n+SELECT dictGet(test_01191.dict1, 's', toUInt64(42));\n+\n+RENAME DICTIONARY test_01191.dict1 TO test_01191.dict2;\n+\n+SELECT name, status FROM system.dictionaries WHERE database='test_01191';\n+SELECT name, engine FROM system.tables WHERE database='test_01191' ORDER BY name;\n+SELECT dictGet(test_01191.dict2, 's', toUInt64(42));\n+\n+DROP DATABASE test_01191;\ndiff --git a/tests/queries/0_stateless/01192_rename_database.reference b/tests/queries/0_stateless/01192_rename_database.reference\nnew file mode 100644\nindex 000000000000..13f2a780e0bc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01192_rename_database.reference\n@@ -0,0 +1,29 @@\n+ok\n+CREATE DATABASE test_01192 UUID \\'00001192-0000-4000-8000-000000000001\\'\\nENGINE = Atomic\n+Atomic\tstore\t00001192-0000-4000-8000-000000000001\t00001192-0000-4000-8000-000000000001\n+ok\n+ok\n+renamed\n+inserted\n+CREATE DATABASE test_01192_renamed UUID \\'00001192-0000-4000-8000-000000000001\\'\\nENGINE = Atomic\n+Atomic\tstore\t00001192-0000-4000-8000-000000000001\t00001192-0000-4000-8000-000000000001\n+CREATE DATABASE test_01192_renamed\\nENGINE = Atomic\n+10\t45\n+inserted\n+renamed\n+10\t45\n+10\t45\n+ok\n+CREATE DICTIONARY test_01192_atomic.dict UUID \\'00001192-0000-4000-8000-000000000002\\'\\n(\\n    `n` UInt64,\\n    `_part` String DEFAULT \\'no\\'\\n)\\nPRIMARY KEY n\\nSOURCE(CLICKHOUSE(HOST \\'localhost\\' PORT 9000 USER \\'default\\' TABLE \\'mt\\' DB \\'test_01192\\'))\\nLAYOUT(DIRECT())\n+test_01192_atomic\tdict\tNOT_LOADED\t00001192-0000-4000-8000-000000000002\n+no\n+ok\n+renamed\n+inserted\n+20\t190\n+10\t45\n+10\t45\n+test_01192\tdict\tLOADED\t00001192-0000-4000-8000-000000000002\n+all_1_1_0\n+all_2_2_0\n+test_01192\tdict\tLOADED\t00001192-0000-4000-8000-000000000002\ndiff --git a/tests/queries/0_stateless/01192_rename_database.sh b/tests/queries/0_stateless/01192_rename_database.sh\nnew file mode 100755\nindex 000000000000..3d4223d09d5e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01192_rename_database.sh\n@@ -0,0 +1,81 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+\n+# 1. init\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01192\"\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01192_renamed\"\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01192_atomic\"\n+\n+$CLICKHOUSE_CLIENT --default_database_engine=Ordinary -q \"CREATE DATABASE test_01192 UUID '00001192-0000-4000-8000-000000000001'\" 2>&1| grep -F \"does not support\" > /dev/null && echo \"ok\"\n+$CLICKHOUSE_CLIENT --allow_experimental_database_atomic=1 --default_database_engine=Atomic -q \"CREATE DATABASE test_01192 UUID '00001192-0000-4000-8000-000000000001'\"\n+\n+# 2. check metadata\n+$CLICKHOUSE_CLIENT --show_table_uuid_in_table_create_query_if_not_nil=1 -q \"SHOW CREATE DATABASE test_01192\"\n+$CLICKHOUSE_CLIENT -q \"SELECT engine, splitByChar('/', data_path)[-2], uuid, splitByChar('/', metadata_path)[-2] FROM system.databases WHERE name='test_01192'\"\n+\n+# 3. check RENAME don't wait for INSERT\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE test_01192.mt (n UInt64) ENGINE=MergeTree ORDER BY n\"\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO test_01192.mt SELECT number + sleepEachRow(1.5) FROM numbers(10)\" && echo \"inserted\" &\n+sleep 1\n+\n+$CLICKHOUSE_CLIENT -q \"RENAME DATABASE test_01192 TO default\" 2>&1| grep -F \"already exists\" > /dev/null && echo \"ok\"\n+$CLICKHOUSE_CLIENT -q \"RENAME DATABASE test_01192_notexisting TO test_01192_renamed\" 2>&1| grep -F \"doesn't exist\" > /dev/null && echo \"ok\"\n+$CLICKHOUSE_CLIENT -q \"RENAME DATABASE test_01192 TO test_01192_renamed\" && echo \"renamed\"\n+wait\n+\n+# 4. check metadata after RENAME\n+$CLICKHOUSE_CLIENT --show_table_uuid_in_table_create_query_if_not_nil=1 -q \"SHOW CREATE DATABASE test_01192_renamed\"\n+$CLICKHOUSE_CLIENT -q \"SELECT engine, splitByChar('/', data_path)[-2], uuid, splitByChar('/', metadata_path)[-2] FROM system.databases WHERE name='test_01192_renamed'\"\n+$CLICKHOUSE_CLIENT -q \"SHOW CREATE DATABASE test_01192_renamed\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192_renamed.mt\"\n+\n+# 5. check moving tables from Ordinary to Atomic (can be used to \"alter\" database engine)\n+$CLICKHOUSE_CLIENT --default_database_engine=Ordinary -q \"CREATE DATABASE test_01192\"\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE test_01192.mt AS test_01192_renamed.mt ENGINE=MergeTree ORDER BY n\"\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE test_01192.rmt AS test_01192_renamed.mt ENGINE=ReplicatedMergeTree('/test/01192/', '1') ORDER BY n\"\n+$CLICKHOUSE_CLIENT -q \"CREATE MATERIALIZED VIEW test_01192.mv TO test_01192.rmt AS SELECT * FROM test_01192.mt\"\n+\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO test_01192.mt SELECT number FROM numbers(10)\" && echo \"inserted\"\n+\n+$CLICKHOUSE_CLIENT --allow_experimental_database_atomic=1 --default_database_engine=Atomic -q \"CREATE DATABASE test_01192_atomic\"\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE test_01192_renamed\"\n+# it's blocking\n+$CLICKHOUSE_CLIENT -q \"RENAME TABLE test_01192.mt TO test_01192_atomic.mt, test_01192.rmt TO test_01192_atomic.rmt, test_01192.mv TO test_01192_atomic.mv\" && echo \"renamed\"\n+\n+# 6. check data after RENAME\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192_atomic.mt\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192_atomic.rmt\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192_atomic.mv\" 2>&1| grep -F \"doesn't exist\" > /dev/null && echo \"ok\"\n+\n+# 7. create dictionary and check it\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE test_01192.mt (n UInt64, _part String) ENGINE=Memory\" # mock\n+$CLICKHOUSE_CLIENT -q \"CREATE DICTIONARY test_01192_atomic.dict UUID '00001192-0000-4000-8000-000000000002' (n UInt64, _part String DEFAULT 'no') PRIMARY KEY n LAYOUT(DIRECT()) SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 'mt' DB 'test_01192'))\"\n+$CLICKHOUSE_CLIENT --show_table_uuid_in_table_create_query_if_not_nil=1 -q \"SHOW CREATE DICTIONARY test_01192_atomic.dict\"\n+$CLICKHOUSE_CLIENT -q \"SELECT database, name, status, origin FROM system.dictionaries WHERE uuid='00001192-0000-4000-8000-000000000002'\"\n+$CLICKHOUSE_CLIENT -q \"SELECT dictGet('test_01192_atomic.dict', '_part', toUInt64(1))\"\n+\n+# 8. check RENAME don't wait for INSERT\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO test_01192_atomic.mt SELECT number + sleepEachRow(1) + 10 FROM numbers(10)\" && echo \"inserted\" &\n+sleep 1\n+\n+$CLICKHOUSE_CLIENT -q \"RENAME DATABASE test_01192 TO test_01192_renamed\" 2>&1| grep -F \"not supported\" > /dev/null && echo \"ok\"\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE test_01192\"\n+$CLICKHOUSE_CLIENT -q \"RENAME DATABASE test_01192_atomic TO test_01192\" && echo \"renamed\"\n+wait\n+\n+# 9. check data after RENAME\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192.mt\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192.rmt\"\n+$CLICKHOUSE_CLIENT -q \"SELECT count(n), sum(n) FROM test_01192.mv\"\n+$CLICKHOUSE_CLIENT -q \"SELECT database, name, status, origin FROM system.dictionaries WHERE uuid='00001192-0000-4000-8000-000000000002'\"\n+$CLICKHOUSE_CLIENT -q \"SELECT dictGet('test_01192.dict', '_part', toUInt64(1))\"\n+$CLICKHOUSE_CLIENT -q \"SYSTEM RELOAD DICTIONARY test_01192.dict\"\n+$CLICKHOUSE_CLIENT -q \"SELECT dictGet('test_01192.dict', '_part', toUInt64(10))\"\n+$CLICKHOUSE_CLIENT -q \"SELECT database, name, status, origin FROM system.dictionaries WHERE uuid='00001192-0000-4000-8000-000000000002'\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE test_01192\"\n+\n+$CLICKHOUSE_CLIENT -q \"SELECT database, name, status, origin FROM system.dictionaries WHERE uuid='00001192-0000-4000-8000-000000000002'\" # 0 rows\ndiff --git a/tests/queries/0_stateless/01193_metadata_loading.sh b/tests/queries/0_stateless/01193_metadata_loading.sh\nindex 38da0fbd92df..c16726209a38 100755\n--- a/tests/queries/0_stateless/01193_metadata_loading.sh\n+++ b/tests/queries/0_stateless/01193_metadata_loading.sh\n@@ -41,12 +41,10 @@ wait\n $CLICKHOUSE_CLIENT -q \"CREATE TABLE $db.table_merge (i UInt64, d Date, s String, n Nested(i UInt8, f Float32)) ENGINE=Merge('$db', '^table_')\"\n $CLICKHOUSE_CLIENT -q \"SELECT count() * $count_multiplier, i, d, s, n.i, n.f FROM $db.table_merge GROUP BY i, d, s, n.i, n.f ORDER BY i\"\n \n-db_engine=$($CLICKHOUSE_CLIENT -q \"SELECT engine FROM system.databases WHERE name='$db'\")\n-\n $CLICKHOUSE_CLIENT -q \"DETACH DATABASE $db\"\n \n # get real time, grep seconds, remove point, remove leading zeros\n-elapsed_ms=$({ time $CLICKHOUSE_CLIENT -q \"ATTACH DATABASE $db ENGINE=$db_engine\"; } 2>&1 | grep real | grep -Po \"0m\\K[0-9\\.]*\" | tr -d '.' | sed \"s/^0*//\")\n+elapsed_ms=$({ time $CLICKHOUSE_CLIENT -q \"ATTACH DATABASE $db\"; } 2>&1 | grep real | grep -Po \"0m\\K[0-9\\.]*\" | tr -d '.' | sed \"s/^0*//\")\n $CLICKHOUSE_CLIENT -q \"SELECT '01193_metadata_loading', $elapsed_ms FORMAT Null\" # it will be printed to server log\n \n if [[ $elapsed_ms -le $max_time_ms ]]; then echo ok; fi\ndiff --git a/tests/queries/0_stateless/01254_dict_load_after_detach_attach.sql b/tests/queries/0_stateless/01254_dict_load_after_detach_attach.sql\nindex ed419f1857a3..5a5f694d28f5 100644\n--- a/tests/queries/0_stateless/01254_dict_load_after_detach_attach.sql\n+++ b/tests/queries/0_stateless/01254_dict_load_after_detach_attach.sql\n@@ -1,5 +1,5 @@\n DROP DATABASE IF EXISTS dict_db_01254;\n-CREATE DATABASE dict_db_01254 ENGINE=Ordinary;\n+CREATE DATABASE dict_db_01254;\n \n CREATE TABLE dict_db_01254.dict_data (key UInt64, val UInt64) Engine=Memory();\n CREATE DICTIONARY dict_db_01254.dict\n@@ -13,7 +13,7 @@ LIFETIME(MIN 0 MAX 0)\n LAYOUT(FLAT());\n \n DETACH DATABASE dict_db_01254;\n-ATTACH DATABASE dict_db_01254 ENGINE=Ordinary;\n+ATTACH DATABASE dict_db_01254;\n \n SELECT query_count, status FROM system.dictionaries WHERE database = 'dict_db_01254' AND name = 'dict';\n SYSTEM RELOAD DICTIONARY dict_db_01254.dict;\ndiff --git a/tests/queries/0_stateless/01376_GROUP_BY_injective_elimination_dictGet.sql b/tests/queries/0_stateless/01376_GROUP_BY_injective_elimination_dictGet.sql\nindex 1c7a4d16f054..5982864bd978 100644\n--- a/tests/queries/0_stateless/01376_GROUP_BY_injective_elimination_dictGet.sql\n+++ b/tests/queries/0_stateless/01376_GROUP_BY_injective_elimination_dictGet.sql\n@@ -7,7 +7,7 @@ DROP TABLE IF EXISTS dictdb_01376.table_for_dict;\n DROP DICTIONARY IF EXISTS dictdb_01376.dict_exists;\n DROP DATABASE IF EXISTS dictdb_01376;\n \n-CREATE DATABASE dictdb_01376 ENGINE = Ordinary;\n+CREATE DATABASE dictdb_01376;\n \n CREATE TABLE dictdb_01376.table_for_dict\n (\ndiff --git a/tests/queries/0_stateless/01378_alter_rename_with_ttl_zookeeper.sql b/tests/queries/0_stateless/01378_alter_rename_with_ttl_zookeeper.sql\nindex 98f295383800..0cd6feb9da15 100644\n--- a/tests/queries/0_stateless/01378_alter_rename_with_ttl_zookeeper.sql\n+++ b/tests/queries/0_stateless/01378_alter_rename_with_ttl_zookeeper.sql\n@@ -5,7 +5,7 @@ CREATE TABLE table_rename_with_ttl\n   date1 Date,\n   value1 String\n )\n-ENGINE = ReplicatedMergeTree('/clickhouse/test/table_rename_with_ttl', '1')\n+ENGINE = ReplicatedMergeTree('/clickhouse/test/table_rename_with_ttl_01378', '1')\n ORDER BY tuple();\n \n INSERT INTO table_rename_with_ttl SELECT toDate('2018-10-01') + number % 3, toString(number) from numbers(9);\ndiff --git a/tests/queries/0_stateless/arcadia_skip_list.txt b/tests/queries/0_stateless/arcadia_skip_list.txt\nindex ea2944c25ccd..0c3ce88b439f 100644\n--- a/tests/queries/0_stateless/arcadia_skip_list.txt\n+++ b/tests/queries/0_stateless/arcadia_skip_list.txt\n@@ -87,6 +87,7 @@\n 01125_dict_ddl_cannot_add_column\n 01129_dict_get_join_lose_constness\n 01138_join_on_distributed_and_tmp\n+01191_rename_dictionary\n 01200_mutations_memory_consumption\n 01211_optimize_skip_unused_shards_type_mismatch\n 01213_optimize_skip_unused_shards_DISTINCT\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 955c67b0b960..c40da4c8e50a 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -107,8 +107,9 @@\n         \"00992_system_parts_race_condition_zookeeper\",\n         \"01320_create_sync_race_condition\",\n         \"01305_replica_create_drop_zookeeper\",\n-        \"01193_metadata_loading\",\n-        \"01130_in_memory_parts_partitons\"\n+        \"01130_in_memory_parts_partitons\",\n+        \"01225_show_create_table_from_dictionary\",\n+        \"01224_no_superfluous_dict_reload\"\n     ],\n     \"polymorphic-parts\": [\n         \"avx\",\n",
  "problem_statement": "ReplicatedMergeTree in Atomic database\nWhat is the proper way to create replicated table in database with Atomic engine?\r\nShould I use some template or it's a bug?\r\n\r\nUPD: I found out that after about 8-9 minutes I can recreate table.\r\n```\r\ncreate database db1 engine=Atomic;\r\n\r\ncreate table db1.test \r\n(i1 Int32) \r\nengine=ReplicatedMergeTree('/clickhouse/tables/db1/test', '{replica}') \r\norder by i1;\r\n\r\ndrop table db1.test;\r\n\r\ncreate table db1.test \r\n(i1 Int32) \r\nengine=ReplicatedMergeTree('/clickhouse/tables/db1/test', '{replica}') \r\norder by i1;\r\n```\r\n\r\nWhen executing last CREATE query I got \r\n>2020.07.04 23:14:10.409366 [ 85 ] {} <Error> DynamicQueryHandler: Code: 253, e.displayText() = DB::Exception: Replica /clickhouse/tables/db1/test/replicas/1A already exists., Stack trace (when copying this message, always include the lines below):\r\n>0. Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x103fa390 in /usr/bin/clickhouse\r\n>1. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x900b8ad in /usr/bin/clickhouse\r\n>2. ? @ 0xd749a87 in /usr/bin/clickhouse\r\n>3. DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::StorageInMemoryMetadata const&, DB::Context&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings> >, bool) @ 0xd720d9c in /usr/bin/clickhouse\r\n>4. ? @ 0xda63dca in /usr/bin/clickhouse\r\n>5. std::__1::__function::__func<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&), std::__1::allocator<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&)>, std::__1::shared_ptr<DB::IStorage> (DB::StorageFactory::Arguments const&)>::operator()(DB::StorageFactory::Arguments const&) @ 0xda67447 in /usr/bin/clickhouse\r\n>6. DB::StorageFactory::get(DB::ASTCreateQuery const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, DB::Context&, DB::ColumnsDescription const&, DB::ConstraintsDescription const&, bool) const @ 0xd66797d in /usr/bin/clickhouse\r\n>7. DB::InterpreterCreateQuery::doCreateTable(DB::ASTCreateQuery&, DB::InterpreterCreateQuery::TableProperties const&) @ 0xd157429 in /usr/bin/clickhouse\r\n>8. DB::InterpreterCreateQuery::createTable(DB::ASTCreateQuery&) @ 0xd15798d in /usr/bin/clickhouse\r\n>9. DB::InterpreterCreateQuery::execute() @ 0xd158ea1 in /usr/bin/clickhouse\r\n>10. ? @ 0xd52ecc9 in /usr/bin/clickhouse\r\n>11. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)>) @ 0xd532700 in /usr/bin/clickhouse\r\n>12. DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&) @ 0x90efb4c in /usr/bin/clickhouse\r\n>13. DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&) @ 0x90f35a6 in /usr/bin/clickhouse\r\n>14. Poco::Net::HTTPServerConnection::run() @ 0x102aad43 in /usr/bin/clickhouse\r\n>15. Poco::Net::TCPServerConnection::start() @ 0x102e610b in /usr/bin/clickhouse\r\n>16. Poco::Net::TCPServerDispatcher::run() @ 0x102e659b in /usr/bin/clickhouse\r\n>17. Poco::PooledThread::run() @ 0x10494166 in /usr/bin/clickhouse\r\n>18. Poco::ThreadImpl::runnableEntry(void*) @ 0x1048f420 in /usr/bin/clickhouse\r\nv19. start_thread @ 0x7ea5 in /usr/lib64/libpthread-2.17.so\r\n>20. __clone @ 0xfe8dd in /usr/lib64/libc-2.17.so\r\n (version 20.4.5.36 (official build))\n",
  "hints_text": "",
  "created_at": "2020-07-09T17:56:48Z"
}