diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md
index 6b01ee31501f..6597cd2d6bfa 100644
--- a/docs/en/sql-reference/functions/other-functions.md
+++ b/docs/en/sql-reference/functions/other-functions.md
@@ -1822,10 +1822,13 @@ Result:
 Evaluate external model.
 Accepts a model name and model arguments. Returns Float64.
 
-## throwIf(x\[, custom_message\])
+## throwIf(x\[, message\[, error_code\]\])
 
 Throw an exception if the argument is non zero.
-custom_message - is an optional parameter: a constant string, provides an error message
+`message` - is an optional parameter: a constant string providing a custom error message
+`error_code` - is an optional parameter: a constant integer providing a custom error code
+
+To use the `error_code` argument, configuration parameter `allow_custom_error_code_in_throwif` must be enabled.
 
 ``` sql
 SELECT throwIf(number = 3, 'Too many') FROM numbers(10);
diff --git a/docs/ru/sql-reference/functions/other-functions.md b/docs/ru/sql-reference/functions/other-functions.md
index 30343c85c5a3..bfe0d3d463b4 100644
--- a/docs/ru/sql-reference/functions/other-functions.md
+++ b/docs/ru/sql-reference/functions/other-functions.md
@@ -1727,10 +1727,13 @@ SELECT joinGet(db_test.id_val,'val',toUInt32(number)) from numbers(4) SETTINGS j
 
 Принимает на вход имя и аргументы модели. Возвращает Float64.
 
-## throwIf(x\[, custom_message\]) {#throwifx-custom-message}
+## throwIf(x\[, message\[, error_code\]\]) {#throwifx-custom-message}
 
 Бросает исключение, если аргумент не равен нулю.
-custom_message - необязательный параметр, константная строка, задает текст сообщения об ошибке.
+`custom_message` - необязательный параметр, константная строка, задает текст сообщения об ошибке.
+`error_code` - необязательный параметр, константное число, задает код ошибки.
+
+Чтобы использовать аргумент `error_code`, должен быть включен параметр конфигурации `allow_custom_error_code_in_throwif`.
 
 ``` sql
 SELECT throwIf(number = 3, 'Too many') FROM numbers(10);
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 08a3df0a3e37..d10cf4d077b9 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -408,6 +408,7 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(UInt64, low_cardinality_max_dictionary_size, 8192, "Maximum size (in rows) of shared global dictionary for LowCardinality type.", 0) \
     M(Bool, low_cardinality_use_single_dictionary_for_part, false, "LowCardinality type serialization setting. If is true, than will use additional keys when global dictionary overflows. Otherwise, will create several shared dictionaries.", 0) \
     M(Bool, decimal_check_overflow, true, "Check overflow of decimal arithmetic/comparison operations", 0) \
+    M(Bool, allow_custom_error_code_in_throwif, false, "Enable custom error code in function throwIf(). If true, thrown exceptions may have unexpected error codes.", 0) \
     \
     M(Bool, prefer_localhost_replica, true, "If it's true then queries will be always sent to local replica (if it exists). If it's false then replica to send a query will be chosen between local and remote ones according to load_balancing", 0) \
     M(UInt64, max_fetch_partition_retries_count, 5, "Amount of retries while fetching partition from another host.", 0) \
diff --git a/src/Functions/FunctionDateOrDateTimeAddInterval.h b/src/Functions/FunctionDateOrDateTimeAddInterval.h
index fbfc9e9bc1fb..c0c000452fca 100644
--- a/src/Functions/FunctionDateOrDateTimeAddInterval.h
+++ b/src/Functions/FunctionDateOrDateTimeAddInterval.h
@@ -611,7 +611,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
         if (!isNativeNumber(arguments[1].type))
-            throw Exception("Second argument for function " + getName() + " (delta) must be number",
+            throw Exception("Second argument for function " + getName() + " (delta) must be a number",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         if (arguments.size() == 2)
@@ -627,7 +627,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
             {
                 throw Exception(
                     "Function " + getName() + " supports 2 or 3 arguments. The 1st argument "
-                    "must be of type Date or DateTime. The 2nd argument must be number. "
+                    "must be of type Date or DateTime. The 2nd argument must be a number. "
                     "The 3rd argument (optional) must be "
                     "a constant string with timezone name. The timezone argument is allowed "
                     "only when the 1st argument has the type DateTime",
diff --git a/src/Functions/FunctionNumericPredicate.h b/src/Functions/FunctionNumericPredicate.h
index 9d98f0c929d3..496564b0b55f 100644
--- a/src/Functions/FunctionNumericPredicate.h
+++ b/src/Functions/FunctionNumericPredicate.h
@@ -46,7 +46,7 @@ class FunctionNumericPredicate : public IFunction
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isNativeNumber(arguments.front()))
-            throw Exception{"Argument for function " + getName() + " must be number", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
+            throw Exception{"Argument for function " + getName() + " must be a number", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
 
         return std::make_shared<DataTypeUInt8>();
     }
diff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp
index 5b04ed05a3ce..34c681736f0e 100644
--- a/src/Functions/makeDate.cpp
+++ b/src/Functions/makeDate.cpp
@@ -62,7 +62,7 @@ class FunctionWithNumericParamsBase : public IFunction
             DataTypePtr argument_type = arguments[i].type;
             if (!isNumber(argument_type))
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Argument '{}' for function {} must be number", std::string(argument_names[i]), getName());
+                    "Argument '{}' for function {} must be a number", std::string(argument_names[i]), getName());
         }
     }
 
@@ -322,7 +322,7 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
             const auto& fraction_argument = arguments[argument_names.size()];
             if (!isNumber(fraction_argument.type))
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Argument 'fraction' for function {} must be number", getName());
+                    "Argument 'fraction' for function {} must be a number", getName());
         }
 
         /// Optional precision argument
diff --git a/src/Functions/throwIf.cpp b/src/Functions/throwIf.cpp
index bda8426150e3..692faf1883ce 100644
--- a/src/Functions/throwIf.cpp
+++ b/src/Functions/throwIf.cpp
@@ -4,9 +4,10 @@
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnsNumber.h>
 #include <Columns/ColumnsCommon.h>
+#include <Common/ErrorCodes.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <IO/WriteHelpers.h>
-
+#include <Interpreters/Context.h>
 
 namespace DB
 {
@@ -21,55 +22,56 @@ namespace ErrorCodes
 namespace
 {
 
+/// The regex-based code style check script in CI complains when it sees "ErrorCodes:: ErrorCode" (space added to avoid another match).
+/// Because this expression is only used in this file, don't add some suppression mechanism to the already complex style checker, instead
+/// work around by creating a namespace alias.
+namespace ErrorCodeAlias = ErrorCodes;
+
 /// Throw an exception if the argument is non zero.
 class FunctionThrowIf : public IFunction
 {
 public:
     static constexpr auto name = "throwIf";
-    static FunctionPtr create(ContextPtr)
-    {
-        return std::make_shared<FunctionThrowIf>();
-    }
 
-    String getName() const override
-    {
-        return name;
-    }
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionThrowIf>(context); }
 
+    explicit FunctionThrowIf(ContextPtr context_) : allow_custom_error_code_argument(context_->getSettingsRef().allow_custom_error_code_in_throwif) {}
+    String getName() const override { return name; }
     bool isVariadic() const override { return true; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    size_t getNumberOfArguments() const override
-    {
-        return 0;
-    }
+    size_t getNumberOfArguments() const override { return 0; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         const size_t number_of_arguments = arguments.size();
 
-        if (number_of_arguments < 1 || number_of_arguments > 2)
+        if (number_of_arguments < 1 || number_of_arguments > (allow_custom_error_code_argument ? 3 : 2))
             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                "Number of arguments for function {} doesn't match: passed {}, should be 1 or 2",
-                getName(),
-                toString(number_of_arguments));
+                "Number of arguments for function {} doesn't match: passed {}, should be {}",
+                getName(), toString(number_of_arguments), allow_custom_error_code_argument ? "1 or 2 or 3" : "1 or 2");
 
         if (!isNativeNumber(arguments[0]))
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                "Argument for function {} must be number",
-                getName());
+                "First argument of function {} must be a number (passed: {})", getName(), arguments[0]->getName());
 
         if (number_of_arguments > 1 && !isString(arguments[1]))
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                "Illegal type {} of argument of function {}",
-                arguments[1]->getName(),
-                getName());
+                "Second argument of function {} must be a string (passed: {})", getName(), arguments[1]->getName());
+
+        if (allow_custom_error_code_argument && number_of_arguments > 2)
+        {
+            WhichDataType which(arguments[2]);
+            if (!(which.isInt8() || which.isInt16() || which.isInt32()))
+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Third argument of function {} must be Int8, Int16 or Int32 (passed: {})", getName(), arguments[2]->getName());
+        }
 
 
         return std::make_shared<DataTypeUInt8>();
     }
 
     bool useDefaultImplementationForConstants() const override { return false; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
 
     /** Prevent constant folding for FunctionThrowIf because for short circuit evaluation
       * it is unsafe to evaluate this function during DAG analysis.
@@ -86,36 +88,44 @@ class FunctionThrowIf : public IFunction
         {
             const auto * message_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());
             if (!message_column)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN,
-                    "Second argument for function {} must be constant String",
-                    getName());
+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Second argument for function {} must be constant String", getName());
 
             custom_message = message_column->getValue<String>();
         }
 
+        std::optional<ErrorCodeAlias::ErrorCode> custom_error_code;
+        if (allow_custom_error_code_argument && arguments.size() == 3)
+        {
+            if (!isColumnConst(*(arguments[2].column)))
+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Third argument for function {} must be constant number", getName());
+
+            custom_error_code = arguments[2].column->getInt(0);
+        }
+
         auto first_argument_column = arguments.front().column;
         const auto * in = first_argument_column.get();
 
         ColumnPtr res;
-        if (!((res = execute<UInt8>(in, custom_message))
-            || (res = execute<UInt16>(in, custom_message))
-            || (res = execute<UInt32>(in, custom_message))
-            || (res = execute<UInt64>(in, custom_message))
-            || (res = execute<Int8>(in, custom_message))
-            || (res = execute<Int16>(in, custom_message))
-            || (res = execute<Int32>(in, custom_message))
-            || (res = execute<Int64>(in, custom_message))
-            || (res = execute<Float32>(in, custom_message))
-            || (res = execute<Float64>(in, custom_message))))
+        if (!((res = execute<UInt8>(in, custom_message, custom_error_code))
+            || (res = execute<UInt16>(in, custom_message, custom_error_code))
+            || (res = execute<UInt32>(in, custom_message, custom_error_code))
+            || (res = execute<UInt64>(in, custom_message, custom_error_code))
+            || (res = execute<Int8>(in, custom_message, custom_error_code))
+            || (res = execute<Int16>(in, custom_message, custom_error_code))
+            || (res = execute<Int32>(in, custom_message, custom_error_code))
+            || (res = execute<Int64>(in, custom_message, custom_error_code))
+            || (res = execute<Float32>(in, custom_message, custom_error_code))
+            || (res = execute<Float64>(in, custom_message, custom_error_code))))
         {
-            throw Exception{"Illegal column " + in->getName() + " of first argument of function " + getName(), ErrorCodes::ILLEGAL_COLUMN};
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
         }
 
         return res;
     }
 
+private:
     template <typename T>
-    ColumnPtr execute(const IColumn * in_untyped, const std::optional<String> & message) const
+    ColumnPtr execute(const IColumn * in_untyped, const std::optional<String> & message, const std::optional<ErrorCodeAlias::ErrorCode> & error_code) const
     {
         const auto * in = checkAndGetColumn<ColumnVector<T>>(in_untyped);
 
@@ -127,8 +137,9 @@ class FunctionThrowIf : public IFunction
             const auto & in_data = in->getData();
             if (!memoryIsZero(in_data.data(), 0, in_data.size() * sizeof(in_data[0])))
             {
-                throw Exception(ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO,
-                    message.value_or("Value passed to '" + getName() + "' function is non zero"));
+                throw Exception(
+                    error_code.value_or(ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO),
+                    message.value_or("Value passed to '" + getName() + "' function is non-zero"));
             }
 
             size_t result_size = in_untyped->size();
@@ -139,6 +150,8 @@ class FunctionThrowIf : public IFunction
 
         return nullptr;
     }
+
+    bool allow_custom_error_code_argument;
 };
 
 }
