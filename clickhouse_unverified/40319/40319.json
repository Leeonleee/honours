{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40319,
  "instance_id": "ClickHouse__ClickHouse-40319",
  "issue_numbers": [
    "39793"
  ],
  "base_commit": "ce89660432f633cb95f225356e68851fa68b0998",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 6b01ee31501f..6597cd2d6bfa 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -1822,10 +1822,13 @@ Result:\n Evaluate external model.\n Accepts a model name and model arguments. Returns Float64.\n \n-## throwIf(x\\[, custom_message\\])\n+## throwIf(x\\[, message\\[, error_code\\]\\])\n \n Throw an exception if the argument is non zero.\n-custom_message - is an optional parameter: a constant string, provides an error message\n+`message` - is an optional parameter: a constant string providing a custom error message\n+`error_code` - is an optional parameter: a constant integer providing a custom error code\n+\n+To use the `error_code` argument, configuration parameter `allow_custom_error_code_in_throwif` must be enabled.\n \n ``` sql\n SELECT throwIf(number = 3, 'Too many') FROM numbers(10);\ndiff --git a/docs/ru/sql-reference/functions/other-functions.md b/docs/ru/sql-reference/functions/other-functions.md\nindex 30343c85c5a3..bfe0d3d463b4 100644\n--- a/docs/ru/sql-reference/functions/other-functions.md\n+++ b/docs/ru/sql-reference/functions/other-functions.md\n@@ -1727,10 +1727,13 @@ SELECT joinGet(db_test.id_val,'val',toUInt32(number)) from numbers(4) SETTINGS j\n \n \u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0438\u043c\u044f \u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u043c\u043e\u0434\u0435\u043b\u0438. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 Float64.\n \n-## throwIf(x\\[, custom_message\\]) {#throwifx-custom-message}\n+## throwIf(x\\[, message\\[, error_code\\]\\]) {#throwifx-custom-message}\n \n \u0411\u0440\u043e\u0441\u0430\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435, \u0435\u0441\u043b\u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u0440\u0430\u0432\u0435\u043d \u043d\u0443\u043b\u044e.\n-custom_message - \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430, \u0437\u0430\u0434\u0430\u0435\u0442 \u0442\u0435\u043a\u0441\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435.\n+`custom_message` - \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430, \u0437\u0430\u0434\u0430\u0435\u0442 \u0442\u0435\u043a\u0441\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435.\n+`error_code` - \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u0437\u0430\u0434\u0430\u0435\u0442 \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438.\n+\n+\u0427\u0442\u043e\u0431\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 `error_code`, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 `allow_custom_error_code_in_throwif`.\n \n ``` sql\n SELECT throwIf(number = 3, 'Too many') FROM numbers(10);\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 08a3df0a3e37..d10cf4d077b9 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -408,6 +408,7 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     M(UInt64, low_cardinality_max_dictionary_size, 8192, \"Maximum size (in rows) of shared global dictionary for LowCardinality type.\", 0) \\\n     M(Bool, low_cardinality_use_single_dictionary_for_part, false, \"LowCardinality type serialization setting. If is true, than will use additional keys when global dictionary overflows. Otherwise, will create several shared dictionaries.\", 0) \\\n     M(Bool, decimal_check_overflow, true, \"Check overflow of decimal arithmetic/comparison operations\", 0) \\\n+    M(Bool, allow_custom_error_code_in_throwif, false, \"Enable custom error code in function throwIf(). If true, thrown exceptions may have unexpected error codes.\", 0) \\\n     \\\n     M(Bool, prefer_localhost_replica, true, \"If it's true then queries will be always sent to local replica (if it exists). If it's false then replica to send a query will be chosen between local and remote ones according to load_balancing\", 0) \\\n     M(UInt64, max_fetch_partition_retries_count, 5, \"Amount of retries while fetching partition from another host.\", 0) \\\ndiff --git a/src/Functions/FunctionDateOrDateTimeAddInterval.h b/src/Functions/FunctionDateOrDateTimeAddInterval.h\nindex fbfc9e9bc1fb..c0c000452fca 100644\n--- a/src/Functions/FunctionDateOrDateTimeAddInterval.h\n+++ b/src/Functions/FunctionDateOrDateTimeAddInterval.h\n@@ -611,7 +611,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n         if (!isNativeNumber(arguments[1].type))\n-            throw Exception(\"Second argument for function \" + getName() + \" (delta) must be number\",\n+            throw Exception(\"Second argument for function \" + getName() + \" (delta) must be a number\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         if (arguments.size() == 2)\n@@ -627,7 +627,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n             {\n                 throw Exception(\n                     \"Function \" + getName() + \" supports 2 or 3 arguments. The 1st argument \"\n-                    \"must be of type Date or DateTime. The 2nd argument must be number. \"\n+                    \"must be of type Date or DateTime. The 2nd argument must be a number. \"\n                     \"The 3rd argument (optional) must be \"\n                     \"a constant string with timezone name. The timezone argument is allowed \"\n                     \"only when the 1st argument has the type DateTime\",\ndiff --git a/src/Functions/FunctionNumericPredicate.h b/src/Functions/FunctionNumericPredicate.h\nindex 9d98f0c929d3..496564b0b55f 100644\n--- a/src/Functions/FunctionNumericPredicate.h\n+++ b/src/Functions/FunctionNumericPredicate.h\n@@ -46,7 +46,7 @@ class FunctionNumericPredicate : public IFunction\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isNativeNumber(arguments.front()))\n-            throw Exception{\"Argument for function \" + getName() + \" must be number\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception{\"Argument for function \" + getName() + \" must be a number\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n \n         return std::make_shared<DataTypeUInt8>();\n     }\ndiff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp\nindex 5b04ed05a3ce..34c681736f0e 100644\n--- a/src/Functions/makeDate.cpp\n+++ b/src/Functions/makeDate.cpp\n@@ -62,7 +62,7 @@ class FunctionWithNumericParamsBase : public IFunction\n             DataTypePtr argument_type = arguments[i].type;\n             if (!isNumber(argument_type))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Argument '{}' for function {} must be number\", std::string(argument_names[i]), getName());\n+                    \"Argument '{}' for function {} must be a number\", std::string(argument_names[i]), getName());\n         }\n     }\n \n@@ -322,7 +322,7 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n             const auto& fraction_argument = arguments[argument_names.size()];\n             if (!isNumber(fraction_argument.type))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Argument 'fraction' for function {} must be number\", getName());\n+                    \"Argument 'fraction' for function {} must be a number\", getName());\n         }\n \n         /// Optional precision argument\ndiff --git a/src/Functions/throwIf.cpp b/src/Functions/throwIf.cpp\nindex bda8426150e3..692faf1883ce 100644\n--- a/src/Functions/throwIf.cpp\n+++ b/src/Functions/throwIf.cpp\n@@ -4,9 +4,10 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnsCommon.h>\n+#include <Common/ErrorCodes.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <IO/WriteHelpers.h>\n-\n+#include <Interpreters/Context.h>\n \n namespace DB\n {\n@@ -21,55 +22,56 @@ namespace ErrorCodes\n namespace\n {\n \n+/// The regex-based code style check script in CI complains when it sees \"ErrorCodes:: ErrorCode\" (space added to avoid another match).\n+/// Because this expression is only used in this file, don't add some suppression mechanism to the already complex style checker, instead\n+/// work around by creating a namespace alias.\n+namespace ErrorCodeAlias = ErrorCodes;\n+\n /// Throw an exception if the argument is non zero.\n class FunctionThrowIf : public IFunction\n {\n public:\n     static constexpr auto name = \"throwIf\";\n-    static FunctionPtr create(ContextPtr)\n-    {\n-        return std::make_shared<FunctionThrowIf>();\n-    }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionThrowIf>(context); }\n \n+    explicit FunctionThrowIf(ContextPtr context_) : allow_custom_error_code_argument(context_->getSettingsRef().allow_custom_error_code_in_throwif) {}\n+    String getName() const override { return name; }\n     bool isVariadic() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    size_t getNumberOfArguments() const override\n-    {\n-        return 0;\n-    }\n+    size_t getNumberOfArguments() const override { return 0; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         const size_t number_of_arguments = arguments.size();\n \n-        if (number_of_arguments < 1 || number_of_arguments > 2)\n+        if (number_of_arguments < 1 || number_of_arguments > (allow_custom_error_code_argument ? 3 : 2))\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2\",\n-                getName(),\n-                toString(number_of_arguments));\n+                \"Number of arguments for function {} doesn't match: passed {}, should be {}\",\n+                getName(), toString(number_of_arguments), allow_custom_error_code_argument ? \"1 or 2 or 3\" : \"1 or 2\");\n \n         if (!isNativeNumber(arguments[0]))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Argument for function {} must be number\",\n-                getName());\n+                \"First argument of function {} must be a number (passed: {})\", getName(), arguments[0]->getName());\n \n         if (number_of_arguments > 1 && !isString(arguments[1]))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type {} of argument of function {}\",\n-                arguments[1]->getName(),\n-                getName());\n+                \"Second argument of function {} must be a string (passed: {})\", getName(), arguments[1]->getName());\n+\n+        if (allow_custom_error_code_argument && number_of_arguments > 2)\n+        {\n+            WhichDataType which(arguments[2]);\n+            if (!(which.isInt8() || which.isInt16() || which.isInt32()))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Third argument of function {} must be Int8, Int16 or Int32 (passed: {})\", getName(), arguments[2]->getName());\n+        }\n \n \n         return std::make_shared<DataTypeUInt8>();\n     }\n \n     bool useDefaultImplementationForConstants() const override { return false; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n \n     /** Prevent constant folding for FunctionThrowIf because for short circuit evaluation\n       * it is unsafe to evaluate this function during DAG analysis.\n@@ -86,36 +88,44 @@ class FunctionThrowIf : public IFunction\n         {\n             const auto * message_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());\n             if (!message_column)\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                    \"Second argument for function {} must be constant String\",\n-                    getName());\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Second argument for function {} must be constant String\", getName());\n \n             custom_message = message_column->getValue<String>();\n         }\n \n+        std::optional<ErrorCodeAlias::ErrorCode> custom_error_code;\n+        if (allow_custom_error_code_argument && arguments.size() == 3)\n+        {\n+            if (!isColumnConst(*(arguments[2].column)))\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Third argument for function {} must be constant number\", getName());\n+\n+            custom_error_code = arguments[2].column->getInt(0);\n+        }\n+\n         auto first_argument_column = arguments.front().column;\n         const auto * in = first_argument_column.get();\n \n         ColumnPtr res;\n-        if (!((res = execute<UInt8>(in, custom_message))\n-            || (res = execute<UInt16>(in, custom_message))\n-            || (res = execute<UInt32>(in, custom_message))\n-            || (res = execute<UInt64>(in, custom_message))\n-            || (res = execute<Int8>(in, custom_message))\n-            || (res = execute<Int16>(in, custom_message))\n-            || (res = execute<Int32>(in, custom_message))\n-            || (res = execute<Int64>(in, custom_message))\n-            || (res = execute<Float32>(in, custom_message))\n-            || (res = execute<Float64>(in, custom_message))))\n+        if (!((res = execute<UInt8>(in, custom_message, custom_error_code))\n+            || (res = execute<UInt16>(in, custom_message, custom_error_code))\n+            || (res = execute<UInt32>(in, custom_message, custom_error_code))\n+            || (res = execute<UInt64>(in, custom_message, custom_error_code))\n+            || (res = execute<Int8>(in, custom_message, custom_error_code))\n+            || (res = execute<Int16>(in, custom_message, custom_error_code))\n+            || (res = execute<Int32>(in, custom_message, custom_error_code))\n+            || (res = execute<Int64>(in, custom_message, custom_error_code))\n+            || (res = execute<Float32>(in, custom_message, custom_error_code))\n+            || (res = execute<Float64>(in, custom_message, custom_error_code))))\n         {\n-            throw Exception{\"Illegal column \" + in->getName() + \" of first argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n         }\n \n         return res;\n     }\n \n+private:\n     template <typename T>\n-    ColumnPtr execute(const IColumn * in_untyped, const std::optional<String> & message) const\n+    ColumnPtr execute(const IColumn * in_untyped, const std::optional<String> & message, const std::optional<ErrorCodeAlias::ErrorCode> & error_code) const\n     {\n         const auto * in = checkAndGetColumn<ColumnVector<T>>(in_untyped);\n \n@@ -127,8 +137,9 @@ class FunctionThrowIf : public IFunction\n             const auto & in_data = in->getData();\n             if (!memoryIsZero(in_data.data(), 0, in_data.size() * sizeof(in_data[0])))\n             {\n-                throw Exception(ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO,\n-                    message.value_or(\"Value passed to '\" + getName() + \"' function is non zero\"));\n+                throw Exception(\n+                    error_code.value_or(ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO),\n+                    message.value_or(\"Value passed to '\" + getName() + \"' function is non-zero\"));\n             }\n \n             size_t result_size = in_untyped->size();\n@@ -139,6 +150,8 @@ class FunctionThrowIf : public IFunction\n \n         return nullptr;\n     }\n+\n+    bool allow_custom_error_code_argument;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00602_throw_if.reference b/tests/queries/0_stateless/00602_throw_if.reference\nindex ad5aaee89a8e..de9ff2dd6252 100644\n--- a/tests/queries/0_stateless/00602_throw_if.reference\n+++ b/tests/queries/0_stateless/00602_throw_if.reference\n@@ -1,3 +1,13 @@\n 1\n 1\n-1000000\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1000\ndiff --git a/tests/queries/0_stateless/00602_throw_if.sh b/tests/queries/0_stateless/00602_throw_if.sh\nindex 1e8850028c4a..7d948fa6816b 100755\n--- a/tests/queries/0_stateless/00602_throw_if.sh\n+++ b/tests/queries/0_stateless/00602_throw_if.sh\n@@ -4,9 +4,43 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n # shellcheck source=../shell_config.sh\n . \"$CURDIR\"/../shell_config.sh\n \n-default_exception_message=\"Value passed to 'throwIf' function is non zero\"\n-custom_exception_message=\"Number equals 1000000\"\n \n-${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000000) FROM system.numbers\" 2>&1 | grep -cF \"$default_exception_message\"\n-${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000000, '$custom_exception_message') FROM system.numbers\" 2>&1 | grep -v '^(query: ' | grep -cF \"$custom_exception_message\"\n-${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT sum(x = 0) FROM (SELECT throwIf(number = 1000000) AS x FROM numbers(1000000))\" 2>&1\n+default_exception_message=\"Value passed to 'throwIf' function is non-zero\"\n+custom_exception_message=\"Number equals 1000\"\n+\n+${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000) FROM system.numbers\" 2>&1 \\\n+    | grep -cF \"$default_exception_message\"\n+\n+${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000, '$custom_exception_message') FROM system.numbers\" 2>&1 \\\n+    | grep -v '^(query: ' | grep -cF \"$custom_exception_message\"\n+\n+\n+# Custom error code arguments are not enabled via configuration.\n+${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000, '$custom_exception_message', 1) FROM system.numbers\" 2>&1 \\\n+    | grep -v '^(query: ' | grep -c \"Number of arguments for function throwIf doesn't match: passed 3, should be 1 or 2\"\n+\n+# Custom error code argument enabled but using the wrong type.\n+${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000, '$custom_exception_message', 1) FROM system.numbers SETTINGS allow_custom_error_code_in_throwif=true\" 2>&1 \\\n+    | grep -v '^(query: ' | grep -c \"Third argument of function throwIf must be Int8, Int16 or Int32 (passed: UInt8)\"\n+\n+\n+# Normal error code + some weird ones.\n+# Internal error codes use the upper half of 32-bit int.\n+custom_error_codes=(\n+    \"42\"\n+    \"0\"       # OK\n+    \"101\"     # UNEXPECTED_PACKET_FROM_CLIENT (interpreted by client)\n+    \"102\"     # UNEXPECTED_PACKET_FROM_SERVER (interpreted by client)\n+    \"1001\"    # STD_EXCEPTION\n+    \"1002\"    # UNKNOWN_EXCEPTION\n+    \"999999\"  # Unused error code.\n+    \"-1\")     # Also unused. Weird but we should allow throwing negative errors.\n+\n+for ec in \"${custom_error_codes[@]}\"\n+do\n+    ${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT throwIf(number = 1000, '$custom_exception_message', toInt32($ec)) FROM system.numbers SETTINGS allow_custom_error_code_in_throwif=true\" 2>&1 \\\n+        | grep -v '^(query: ' | grep -c \"Code: $ec.*$custom_exception_message\"\n+done\n+\n+\n+${CLICKHOUSE_CLIENT} --server_logs_file /dev/null --query=\"SELECT sum(x = 0) FROM (SELECT throwIf(number = 1000) AS x FROM numbers(1000))\" 2>&1\ndiff --git a/tests/queries/0_stateless/00995_exception_while_insert.sh b/tests/queries/0_stateless/00995_exception_while_insert.sh\nindex 28351078df3d..e0cd264a2b7d 100755\n--- a/tests/queries/0_stateless/00995_exception_while_insert.sh\n+++ b/tests/queries/0_stateless/00995_exception_while_insert.sh\n@@ -10,6 +10,6 @@ $CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS check;\"\n \n $CLICKHOUSE_CLIENT --query=\"CREATE TABLE check (x UInt64, y UInt64 DEFAULT throwIf(x > 1500000)) ENGINE = Memory;\"\n \n-seq 1 2000000 | $CLICKHOUSE_CLIENT --query=\"INSERT INTO check(x) FORMAT TSV\" 2>&1 | grep -q \"Value passed to 'throwIf' function is non zero.\" && echo 'OK' || echo 'FAIL' ||:\n+seq 1 2000000 | $CLICKHOUSE_CLIENT --query=\"INSERT INTO check(x) FORMAT TSV\" 2>&1 | grep -q \"Value passed to 'throwIf' function is non-zero.\" && echo 'OK' || echo 'FAIL' ||:\n \n $CLICKHOUSE_CLIENT --query=\"DROP TABLE check;\"\n",
  "problem_statement": "New function: throwError\nIs there any way to manually make CH throw a specific error?\r\n\r\nSomething like this:\r\n```sql\r\nSELECT throwError(999);\r\n\r\nReceived exception from server (version 22.2.2):\r\nCode: 999. DB::Exception: KEEPER_EXCEPTION ...\r\n```\r\n\r\nPS:\r\n*Although there is a similar function (`throwIf`), it only returns code=395 (FUNCTION_THROW_IF_VALUE_IS_NON_ZERO).*\r\n\r\n**Use case**\r\n\r\nWe're looking something like this so we can simulate errors and take relevant actions agains some errors.\r\n\n",
  "hints_text": "> We're looking something like this so we can simulate errors and take relevant actions agains some errors.\r\n\r\nIs it needed for building / debugging some client library? \r\n\r\nMaybe for some subset of error you can just create a scenario in clickhouse leading to that error? \r\nOr use some mock WS which will return needed data?\nI find this useful as well to test exceptions on an application built on top of ClickHouse; for example, verify the behaviour when you reach `TOO_MANY_PARTS`.\r\n\r\nIt can be done through mocking, or by forcing CH to trigger the exception by normal means, but something like this could be a simpler way to inject errors. Maybe there are better ways though.\r\n\n@filimonov \r\n> Is it needed for building / debugging some client library?\r\n\r\nWe'll be using it for testing purposes. \r\n* To react against some specific errors (e.g. retry insert, only if it is failed because of error code X)\r\n* To use different alert levels for some specific error codes.\r\n* To see how our software reacts to different errors.\r\n\r\n> Maybe for some subset of error you can just create a scenario in clickhouse leading to that error?\r\n\r\nIt is practically impossible to create a scenario for each and every error. Even for a subset of errors, it is not feasible to make it happen because it takes too much time and resource (e.g. Too Many Parts, Keeper Exception, Memory Limit Exceeded, ...)\nOk. It can be an extension for `throwIf` with an additional argument.\r\nBut it should be disabled by default and enabled only with a special configuration.\r\n\r\nBecause we don't want to have \"fake errors\" in normal environments.",
  "created_at": "2022-08-17T21:16:56Z"
}