{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25634,
  "instance_id": "ClickHouse__ClickHouse-25634",
  "issue_numbers": [
    "13274"
  ],
  "base_commit": "1b4d2cbc6da217f0f89ba791f40fec3ca05d464e",
  "patch": "diff --git a/src/Interpreters/DatabaseAndTableWithAlias.h b/src/Interpreters/DatabaseAndTableWithAlias.h\nindex b53cadce460d..e43481025a0f 100644\n--- a/src/Interpreters/DatabaseAndTableWithAlias.h\n+++ b/src/Interpreters/DatabaseAndTableWithAlias.h\n@@ -61,7 +61,7 @@ struct TableWithColumnNamesAndTypes\n             names.insert(col.name);\n     }\n \n-    bool hasColumn(const String & name) const { return names.count(name); }\n+    bool hasColumn(const String & name) const { return names.contains(name); }\n \n     void addHiddenColumns(const NamesAndTypesList & addition)\n     {\n@@ -86,8 +86,6 @@ struct TableWithColumnNamesAndTypes\n             names.insert(col.name);\n     }\n \n-\n-private:\n     NameSet names;\n };\n \ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 0897efe08fbc..1496ea3dc61f 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -11,7 +11,6 @@\n #include <Parsers/DumpASTNode.h>\n \n #include <DataTypes/DataTypeNullable.h>\n-#include <DataTypes/DataTypesNumber.h>\n #include <Columns/IColumn.h>\n \n #include <Interpreters/ArrayJoinAction.h>\n@@ -813,7 +812,8 @@ JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain\n     }\n \n     ExpressionActionsChain::Step & step = chain.lastStep(columns_after_array_join);\n-    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(syntax->analyzed_join, table_join, step.getResultColumns()));\n+    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(\n+        syntax->analyzed_join, table_join, step.getResultColumns()));\n     chain.addStep();\n     return table_join;\n }\n@@ -906,8 +906,8 @@ JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(\n             *   in the subquery_for_set object this subquery is exposed as source and the temporary table _data1 as the `table`.\n             * - this function shows the expression JOIN _data1.\n             */\n-        auto interpreter = interpretSubquery(join_element.table_expression, getContext(), original_right_columns, query_options);\n-\n+        auto interpreter = interpretSubquery(\n+            join_element.table_expression, getContext(), original_right_columns, query_options.copy().setWithAllColumns());\n         {\n             joined_plan = std::make_unique<QueryPlan>();\n             interpreter->buildQueryPlan(*joined_plan);\ndiff --git a/src/Interpreters/IdentifierSemantic.cpp b/src/Interpreters/IdentifierSemantic.cpp\nindex 0198a92f78b2..098bf0333991 100644\n--- a/src/Interpreters/IdentifierSemantic.cpp\n+++ b/src/Interpreters/IdentifierSemantic.cpp\n@@ -1,6 +1,8 @@\n+#include <Interpreters/IdentifierSemantic.h>\n+\n #include <Common/typeid_cast.h>\n \n-#include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/Context.h>\n #include <Interpreters/StorageID.h>\n \n #include <Parsers/ASTFunction.h>\n@@ -280,7 +282,10 @@ IdentifierMembershipCollector::IdentifierMembershipCollector(const ASTSelectQuer\n         QueryAliasesNoSubqueriesVisitor(aliases).visit(with);\n     QueryAliasesNoSubqueriesVisitor(aliases).visit(select.select());\n \n-    tables = getDatabaseAndTablesWithColumns(getTableExpressions(select), context);\n+    const auto & settings = context->getSettingsRef();\n+    tables = getDatabaseAndTablesWithColumns(getTableExpressions(select), context,\n+                                             settings.asterisk_include_alias_columns,\n+                                             settings.asterisk_include_materialized_columns);\n }\n \n std::optional<size_t> IdentifierMembershipCollector::getIdentsMembership(ASTPtr ast) const\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 46622a8697dd..d820cbbae45b 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -30,7 +30,6 @@\n #include <Interpreters/JoinToSubqueryTransformVisitor.h>\n #include <Interpreters/CrossToInnerJoinVisitor.h>\n #include <Interpreters/TableJoin.h>\n-#include <Interpreters/JoinSwitcher.h>\n #include <Interpreters/JoinedTables.h>\n #include <Interpreters/OpenTelemetrySpanLog.h>\n #include <Interpreters/QueryAliasesVisitor.h>\n@@ -68,7 +67,6 @@\n #include <Processors/Transforms/AggregatingTransform.h>\n #include <Processors/Transforms/ExpressionTransform.h>\n #include <Processors/Transforms/FilterTransform.h>\n-#include <Processors/Transforms/JoiningTransform.h>\n \n #include <Storages/MergeTree/MergeTreeWhereOptimizer.h>\n #include <Storages/IStorage.h>\n@@ -313,7 +311,7 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n         ApplyWithSubqueryVisitor().visit(query_ptr);\n     }\n \n-    JoinedTables joined_tables(getSubqueryContext(context), getSelectQuery());\n+    JoinedTables joined_tables(getSubqueryContext(context), getSelectQuery(), options.with_all_cols);\n \n     bool got_storage_from_query = false;\n     if (!has_input && !storage)\ndiff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex 7647b60458a6..099fb5c2f445 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -161,9 +161,10 @@ using RenameQualifiedIdentifiersVisitor = InDepthNodeVisitor<RenameQualifiedIden\n \n }\n \n-JoinedTables::JoinedTables(ContextPtr context_, const ASTSelectQuery & select_query)\n+JoinedTables::JoinedTables(ContextPtr context_, const ASTSelectQuery & select_query, bool include_all_columns_)\n     : context(context_)\n     , table_expressions(getTableExpressions(select_query))\n+    , include_all_columns(include_all_columns_)\n     , left_table_expression(extractTableExpression(select_query, 0))\n     , left_db_and_table(getDatabaseAndTable(select_query, 0))\n {}\n@@ -220,11 +221,13 @@ StoragePtr JoinedTables::getLeftTableStorage()\n \n bool JoinedTables::resolveTables()\n {\n-    tables_with_columns = getDatabaseAndTablesWithColumns(table_expressions, context);\n+    const auto & settings = context->getSettingsRef();\n+    bool include_alias_cols = include_all_columns || settings.asterisk_include_alias_columns;\n+    bool include_materialized_cols = include_all_columns || settings.asterisk_include_materialized_columns;\n+    tables_with_columns = getDatabaseAndTablesWithColumns(table_expressions, context, include_alias_cols, include_materialized_cols);\n     if (tables_with_columns.size() != table_expressions.size())\n         throw Exception(\"Unexpected tables count\", ErrorCodes::LOGICAL_ERROR);\n \n-    const auto & settings = context->getSettingsRef();\n     if (settings.joined_subquery_requires_alias && tables_with_columns.size() > 1)\n     {\n         for (size_t i = 0; i < tables_with_columns.size(); ++i)\n@@ -312,4 +315,11 @@ std::shared_ptr<TableJoin> JoinedTables::makeTableJoin(const ASTSelectQuery & se\n     return table_join;\n }\n \n+void JoinedTables::reset(const ASTSelectQuery & select_query)\n+{\n+    table_expressions = getTableExpressions(select_query);\n+    left_table_expression = extractTableExpression(select_query, 0);\n+    left_db_and_table = getDatabaseAndTable(select_query, 0);\n+}\n+\n }\ndiff --git a/src/Interpreters/JoinedTables.h b/src/Interpreters/JoinedTables.h\nindex 52eb71e419d2..9d01c081e9f5 100644\n--- a/src/Interpreters/JoinedTables.h\n+++ b/src/Interpreters/JoinedTables.h\n@@ -22,12 +22,9 @@ using StorageMetadataPtr = std::shared_ptr<const StorageInMemoryMetadata>;\n class JoinedTables\n {\n public:\n-    JoinedTables(ContextPtr context, const ASTSelectQuery & select_query);\n+    JoinedTables(ContextPtr context, const ASTSelectQuery & select_query, bool include_all_columns_ = false);\n \n-    void reset(const ASTSelectQuery & select_query)\n-    {\n-        *this = JoinedTables(Context::createCopy(context), select_query);\n-    }\n+    void reset(const ASTSelectQuery & select_query);\n \n     StoragePtr getLeftTableStorage();\n     bool resolveTables();\n@@ -37,7 +34,6 @@ class JoinedTables\n     std::shared_ptr<TableJoin> makeTableJoin(const ASTSelectQuery & select_query);\n \n     const TablesWithColumns & tablesWithColumns() const { return tables_with_columns; }\n-    TablesWithColumns moveTablesWithColumns() { return std::move(tables_with_columns); }\n \n     bool isLeftTableSubquery() const;\n     bool isLeftTableFunction() const;\n@@ -51,6 +47,7 @@ class JoinedTables\n     ContextPtr context;\n     std::vector<const ASTTableExpression *> table_expressions;\n     TablesWithColumns tables_with_columns;\n+    const bool include_all_columns;\n \n     /// Legacy (duplicated left table values)\n     ASTPtr left_table_expression;\ndiff --git a/src/Interpreters/SelectQueryOptions.h b/src/Interpreters/SelectQueryOptions.h\nindex d723dbf4ff68..1a1f0267ab05 100644\n--- a/src/Interpreters/SelectQueryOptions.h\n+++ b/src/Interpreters/SelectQueryOptions.h\n@@ -42,11 +42,14 @@ struct SelectQueryOptions\n     bool ignore_alias = false;\n     bool is_internal = false;\n     bool is_subquery = false; // non-subquery can also have subquery_depth > 0, e.g. insert select\n+    bool with_all_cols = false; /// asterisk include materialized and aliased columns\n \n-    SelectQueryOptions(QueryProcessingStage::Enum stage = QueryProcessingStage::Complete, size_t depth = 0, bool is_subquery_ = false)\n+    SelectQueryOptions(\n+        QueryProcessingStage::Enum stage = QueryProcessingStage::Complete,\n+        size_t depth = 0,\n+        bool is_subquery_ = false)\n         : to_stage(stage), subquery_depth(depth), is_subquery(is_subquery_)\n-    {\n-    }\n+    {}\n \n     SelectQueryOptions copy() const { return *this; }\n \n@@ -114,6 +117,12 @@ struct SelectQueryOptions\n         is_internal = value;\n         return *this;\n     }\n+\n+    SelectQueryOptions & setWithAllColumns(bool value = true)\n+    {\n+        with_all_cols = value;\n+        return *this;\n+    }\n };\n \n }\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex fabd2cc5ef68..2bdad8b698fd 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -1,5 +1,4 @@\n #include <Core/Settings.h>\n-#include <Core/Defines.h>\n #include <Core/NamesAndTypes.h>\n \n #include <Interpreters/TreeRewriter.h>\n@@ -32,7 +31,6 @@\n #include <DataTypes/DataTypeNullable.h>\n \n #include <IO/WriteHelpers.h>\n-#include <IO/WriteBufferFromOStream.h>\n #include <Storages/IStorage.h>\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n@@ -510,14 +508,10 @@ void setJoinStrictness(ASTSelectQuery & select_query, JoinStrictness join_defaul\n }\n \n /// Find the columns that are obtained by JOIN.\n-void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & select_query,\n+void collectJoinedColumns(TableJoin & analyzed_join, const ASTTableJoin & table_join,\n                           const TablesWithColumns & tables, const Aliases & aliases)\n {\n-    const ASTTablesInSelectQueryElement * node = select_query.join();\n-    if (!node || tables.size() < 2)\n-        return;\n-\n-    const auto & table_join = node->table_join->as<ASTTableJoin &>();\n+    assert(tables.size() >= 2);\n \n     if (table_join.using_expression_list)\n     {\n@@ -896,9 +890,15 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n \n     if (tables_with_columns.size() > 1)\n     {\n-        result.analyzed_join->columns_from_joined_table = tables_with_columns[1].columns;\n+        const auto & right_table = tables_with_columns[1];\n+        auto & cols_from_joined = result.analyzed_join->columns_from_joined_table;\n+        cols_from_joined = right_table.columns;\n+        /// query can use materialized or aliased columns from right joined table,\n+        /// we want to request it for right table\n+        cols_from_joined.insert(cols_from_joined.end(), right_table.hidden_columns.begin(), right_table.hidden_columns.end());\n+\n         result.analyzed_join->deduplicateAndQualifyColumnNames(\n-            source_columns_set, tables_with_columns[1].table.getQualifiedNamePrefix());\n+            source_columns_set, right_table.table.getQualifiedNamePrefix());\n     }\n \n     translateQualifiedNames(query, *select_query, source_columns_set, tables_with_columns);\n@@ -932,7 +932,16 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     setJoinStrictness(\n         *select_query, settings.join_default_strictness, settings.any_join_distinct_right_table_keys, result.analyzed_join->table_join);\n \n-    collectJoinedColumns(*result.analyzed_join, *select_query, tables_with_columns, result.aliases);\n+    if (const auto * join_ast = select_query->join(); join_ast && tables_with_columns.size() >= 2)\n+    {\n+        auto & table_join_ast = join_ast->table_join->as<ASTTableJoin &>();\n+        if (table_join_ast.using_expression_list && result.metadata_snapshot)\n+            replaceAliasColumnsInQuery(table_join_ast.using_expression_list, result.metadata_snapshot->getColumns(), result.array_join_result_to_source, getContext());\n+        if (table_join_ast.on_expression && result.metadata_snapshot)\n+            replaceAliasColumnsInQuery(table_join_ast.on_expression, result.metadata_snapshot->getColumns(), result.array_join_result_to_source, getContext());\n+\n+        collectJoinedColumns(*result.analyzed_join, table_join_ast, tables_with_columns, result.aliases);\n+    }\n \n     result.aggregates = getAggregates(query, *select_query);\n     result.window_function_asts = getWindowFunctions(query, *select_query);\ndiff --git a/src/Interpreters/getTableExpressions.cpp b/src/Interpreters/getTableExpressions.cpp\nindex 22eb307071cc..d82c7fc13322 100644\n--- a/src/Interpreters/getTableExpressions.cpp\n+++ b/src/Interpreters/getTableExpressions.cpp\n@@ -113,50 +113,42 @@ static NamesAndTypesList getColumnsFromTableExpression(\n     return names_and_type_list;\n }\n \n-NamesAndTypesList getColumnsFromTableExpression(const ASTTableExpression & table_expression, ContextPtr context)\n-{\n-    NamesAndTypesList materialized;\n-    NamesAndTypesList aliases;\n-    NamesAndTypesList virtuals;\n-    return getColumnsFromTableExpression(table_expression, context, materialized, aliases, virtuals);\n-}\n-\n-TablesWithColumns getDatabaseAndTablesWithColumns(const std::vector<const ASTTableExpression *> & table_expressions, ContextPtr context)\n+TablesWithColumns getDatabaseAndTablesWithColumns(\n+        const ASTTableExprConstPtrs & table_expressions,\n+        ContextPtr context,\n+        bool include_alias_cols,\n+        bool include_materialized_cols)\n {\n     TablesWithColumns tables_with_columns;\n \n-    if (!table_expressions.empty())\n+    String current_database = context->getCurrentDatabase();\n+\n+    for (const ASTTableExpression * table_expression : table_expressions)\n     {\n-        String current_database = context->getCurrentDatabase();\n-        bool include_alias_cols = context->getSettingsRef().asterisk_include_alias_columns;\n-        bool include_materialized_cols = context->getSettingsRef().asterisk_include_materialized_columns;\n+        NamesAndTypesList materialized;\n+        NamesAndTypesList aliases;\n+        NamesAndTypesList virtuals;\n+        NamesAndTypesList names_and_types = getColumnsFromTableExpression(\n+            *table_expression, context, materialized, aliases, virtuals);\n+\n+        removeDuplicateColumns(names_and_types);\n+\n+        tables_with_columns.emplace_back(\n+            DatabaseAndTableWithAlias(*table_expression, current_database), names_and_types);\n+\n+        auto & table = tables_with_columns.back();\n+        table.addHiddenColumns(materialized);\n+        table.addHiddenColumns(aliases);\n+        table.addHiddenColumns(virtuals);\n+\n+        if (include_alias_cols)\n+        {\n+            table.addAliasColumns(aliases);\n+        }\n \n-        for (const ASTTableExpression * table_expression : table_expressions)\n+        if (include_materialized_cols)\n         {\n-            NamesAndTypesList materialized;\n-            NamesAndTypesList aliases;\n-            NamesAndTypesList virtuals;\n-            NamesAndTypesList names_and_types = getColumnsFromTableExpression(*table_expression, context, materialized, aliases, virtuals);\n-\n-            removeDuplicateColumns(names_and_types);\n-\n-            tables_with_columns.emplace_back(\n-                DatabaseAndTableWithAlias(*table_expression, current_database), names_and_types);\n-\n-            auto & table = tables_with_columns.back();\n-            table.addHiddenColumns(materialized);\n-            table.addHiddenColumns(aliases);\n-            table.addHiddenColumns(virtuals);\n-\n-            if (include_alias_cols)\n-            {\n-                table.addAliasColumns(aliases);\n-            }\n-\n-            if (include_materialized_cols)\n-            {\n-                table.addMaterializedColumns(materialized);\n-            }\n+            table.addMaterializedColumns(materialized);\n         }\n     }\n \ndiff --git a/src/Interpreters/getTableExpressions.h b/src/Interpreters/getTableExpressions.h\nindex 961176437b5f..c4ca01ee3c36 100644\n--- a/src/Interpreters/getTableExpressions.h\n+++ b/src/Interpreters/getTableExpressions.h\n@@ -10,13 +10,17 @@ namespace DB\n struct ASTTableExpression;\n class ASTSelectQuery;\n \n+using ASTTableExprConstPtrs = std::vector<const ASTTableExpression *>;\n+\n NameSet removeDuplicateColumns(NamesAndTypesList & columns);\n \n-std::vector<const ASTTableExpression *> getTableExpressions(const ASTSelectQuery & select_query);\n+ASTTableExprConstPtrs getTableExpressions(const ASTSelectQuery & select_query);\n+\n const ASTTableExpression * getTableExpression(const ASTSelectQuery & select, size_t table_number);\n+\n ASTPtr extractTableExpression(const ASTSelectQuery & select, size_t table_number);\n \n-NamesAndTypesList getColumnsFromTableExpression(const ASTTableExpression & table_expression, ContextPtr context);\n-TablesWithColumns getDatabaseAndTablesWithColumns(const std::vector<const ASTTableExpression *> & table_expressions, ContextPtr context);\n+TablesWithColumns getDatabaseAndTablesWithColumns(\n+    const ASTTableExprConstPtrs & table_expressions, ContextPtr context, bool include_alias_cols, bool include_materialized_cols);\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01925_join_materialized_columns.reference b/tests/queries/0_stateless/01925_join_materialized_columns.reference\nnew file mode 100644\nindex 000000000000..1dfda3c769b1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01925_join_materialized_columns.reference\n@@ -0,0 +1,24 @@\n+2020-02-02 13:00:00\tfact2\tt1_val2\t2020-02-05 13:00:00\tfact2\tt1_val2\n+-\n+2020-02-02 13:00:00\tfact2\tt1_val2\t2020-02-02\t2020-02-05 13:00:00\tfact2\tt1_val2\t2020-02-05\n+-\n+2020-01-01\t2020-01-01\n+2020-02-02\t2020-02-05\n+-\n+2020-01-01 12:00:00\tfact1\tt1_val1\t2020-01-01 12:00:00\tfact1\tt2_val2\n+2020-01-01 13:00:00\tfact3\tt1_val3\t2020-01-01 12:00:00\tfact1\tt2_val2\n+-\n+2020-01-01 12:00:00\tfact1\tt1_val1\t2020-01-01 12:00:00\tfact1\tt2_val2\n+2020-01-01 13:00:00\tfact3\tt1_val3\t2020-01-01 12:00:00\tfact1\tt2_val2\n+-\n+2020-01-01 12:00:00\tfact1\tt1_val1\t2019-01-01 12:00:00\tfact4\tt2_val2\n+2020-01-01 12:00:00\tfact1\tt1_val1\t2020-01-01 12:00:00\tfact1\tt2_val2\n+2020-01-01 13:00:00\tfact3\tt1_val3\t2019-01-01 12:00:00\tfact4\tt2_val2\n+2020-01-01 13:00:00\tfact3\tt1_val3\t2020-01-01 12:00:00\tfact1\tt2_val2\n+-\n+2020-02-02 13:00:00\tfact2\tt1_val2\t2020-02-05 13:00:00\tfact2\tt1_val2\n+-\n+fact1t1_val1\tfact1t2_val2\n+fact2t1_val2\tfact2t1_val2\n+-\n+2020-02-02 13:00:00\t2020-02-05 13:00:00\ndiff --git a/tests/queries/0_stateless/01925_join_materialized_columns.sql b/tests/queries/0_stateless/01925_join_materialized_columns.sql\nnew file mode 100644\nindex 000000000000..6a34fef96ab5\n--- /dev/null\n+++ b/tests/queries/0_stateless/01925_join_materialized_columns.sql\n@@ -0,0 +1,37 @@\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+\n+CREATE TABLE t1 (\n+    time DateTime, foo String, dimension_1 String,\n+    dt Date MATERIALIZED toDate(time),\n+    dt1 Date MATERIALIZED toDayOfYear(time),\n+    aliascol1 ALIAS foo || dimension_1\n+) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, foo);\n+\n+CREATE TABLE t2 (\n+    time DateTime, bar String, dimension_2 String, \n+    dt Date MATERIALIZED toDate(time),\n+    dt2 Date MATERIALIZED toDayOfYear(time),\n+    aliascol2 ALIAS bar || dimension_2\n+) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, bar);\n+\n+INSERT INTO t1 VALUES ('2020-01-01 12:00:00', 'fact1', 't1_val1'), ('2020-02-02 13:00:00', 'fact2', 't1_val2'), ('2020-01-01 13:00:00', 'fact3', 't1_val3');\n+INSERT INTO t2 VALUES ('2020-01-01 12:00:00', 'fact1', 't2_val2'), ('2020-02-05 13:00:00', 'fact2', 't1_val2'), ('2019-01-01 12:00:00', 'fact4', 't2_val2');\n+\n+SELECT * FROM t1 JOIN t2 ON t1.foo = t2.bar WHERE t2.dt >= '2020-02-01';\n+SELECT '-';\n+SELECT t1.*, t1.dt, t2.*, t2.dt FROM t1 JOIN t2 ON t1.foo = t2.bar WHERE t2.dt >= '2020-02-01';\n+SELECT '-';\n+SELECT t1.dt, t2.dt FROM t1 JOIN t2 ON t1.foo = t2.bar ORDER BY t1.dt;\n+SELECT '-';\n+SELECT * FROM t1 ALL JOIN t2 ON t1.dt = t2.dt ORDER BY t1.time, t2.time;\n+SELECT '-';\n+SELECT * FROM t1 ALL JOIN t2 USING (dt) ORDER BY t1.time, t2.time;\n+SELECT '-';\n+SELECT * FROM t1 JOIN t2 ON t1.dt1 = t2.dt2 ORDER BY t1.time, t2.time;\n+SELECT '-';\n+SELECT * FROM t1 JOIN t2 ON t1.foo = t2.bar WHERE t2.aliascol2 == 'fact2t1_val2';\n+SELECT '-';\n+SELECT t1.aliascol1, t2.aliascol2 FROM t1 JOIN t2 ON t1.foo = t2.bar ORDER BY t1.time, t2.time;\n+SELECT '-';\n+SELECT t1.time, t2.time FROM t1 JOIN t2 ON t1.aliascol1 = t2.aliascol2 ORDER BY t1.time, t2.time;\n",
  "problem_statement": "Unexpected behavior with materialized columns filtering in joins\nIs there a way to make filtering by right table materialized columns on join?\r\n\r\n**How to reproduce**\r\nLatest lts version\r\n```\r\nClickHouse client version 20.3.15.133 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 20.3.15 revision 54433.\r\n```\r\n\r\nQueries for reproduce\r\n\r\n```\r\nCREATE TABLE test1 (time DateTime, foo String, dimension_1 String, dt Date MATERIALIZED toDate(time)) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, foo);\r\nCREATE TABLE test2 (time DateTime, bar String, dimension_2 String, dt Date MATERIALIZED toDate(time)) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, bar);\r\nINSERT INTO test1 VALUES ('2020-01-01 12:00:00', 'fact1', 'test1_val1'), ('2020-01-01 13:00:00', 'fact2', 'test1_val2');\r\nINSERT INTO test2 VALUES ('2020-01-01 12:00:00', 'fact1', 'test2_val2'), ('2019-01-01 12:00:00', 'fact3', 'test2_val2');\r\n```\r\n\r\nFollowing works\r\n```\r\nSELECT *\r\nFROM test1\r\nFULL OUTER JOIN test2 ON test1.foo = test2.bar\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500time\u2500\u252c\u2500foo\u2500\u2500\u2500\u252c\u2500dimension_1\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500test2.time\u2500\u252c\u2500bar\u2500\u2500\u2500\u252c\u2500dimension_2\u2500\u2510\r\n\u2502 2020-01-01 12:00:00 \u2502 fact1 \u2502 test1_val1  \u2502 2020-01-01 12:00:00 \u2502 fact1 \u2502 test2_val2  \u2502\r\n\u2502 2020-01-01 13:00:00 \u2502 fact2 \u2502 test1_val2  \u2502 0000-00-00 00:00:00 \u2502       \u2502             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500time\u2500\u252c\u2500foo\u2500\u252c\u2500dimension_1\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500test2.time\u2500\u252c\u2500bar\u2500\u2500\u2500\u252c\u2500dimension_2\u2500\u2510\r\n\u2502 0000-00-00 00:00:00 \u2502     \u2502             \u2502 2019-01-01 12:00:00 \u2502 fact3 \u2502 test2_val2  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut when I try to filter on `test2.dt` server throws an exception\r\n```\r\nSELECT *\r\nFROM test1\r\nFULL OUTER JOIN test2 ON test1.foo = test2.bar\r\nWHERE test2.dt >= '2020-01-01'\r\n\r\n\r\nReceived exception from server (version 20.3.15):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'test2.dt' while processing query: 'SELECT time, foo, dimension_1, test2.time, bar, dimension_2 FROM test1 ALL FULL OUTER JOIN (SELECT * FROM test2) AS test2 ON foo = bar WHERE test2.dt >= '2020-01-01'', required columns: 'time' 'foo' 'test2.dt' 'test2.time' 'dimension_1' 'bar' 'dimension_2', source columns: 'dt' 'dimension_1' 'foo' 'time', joined columns: 'test2.time' 'bar' 'dimension_2'. \r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n```\r\n\r\nI understand that joins works other way than in traditional SQL and I have option to move where clause and do separate select like following. \r\n```\r\nSELECT *\r\nFROM test1\r\nFULL OUTER JOIN \r\n(\r\n    SELECT *\r\n    FROM test2\r\n    WHERE dt >= '2020-01-01'\r\n) AS test2 ON test1.foo = test2.bar\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500time\u2500\u252c\u2500foo\u2500\u2500\u2500\u252c\u2500dimension_1\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500test2.time\u2500\u252c\u2500bar\u2500\u2500\u2500\u252c\u2500dimension_2\u2500\u2510\r\n\u2502 2020-01-01 12:00:00 \u2502 fact1 \u2502 test1_val1  \u2502 2020-01-01 12:00:00 \u2502 fact1 \u2502 test2_val2  \u2502\r\n\u2502 2020-01-01 13:00:00 \u2502 fact2 \u2502 test1_val2  \u2502 0000-00-00 00:00:00 \u2502       \u2502             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nBut what if main query contains some complicated where clause with `condition_from_left OR condition_from_right_materialized`, then I have no way to reduce right table to store less in memory and need to  do something like \r\n```\r\nSELECT *\r\nFROM test1\r\nFULL OUTER JOIN \r\n(\r\n    SELECT *, dt\r\n    FROM test2\r\n) AS test2 ON test1.foo = test2.bar\r\nWHERE test2.dt >= '2020-01-01'\r\n```\r\nwhich may load bunch of unnecessary data into RAM \r\n\n",
  "hints_text": "Hello \r\n\r\nI've encountered what I think is a related issue to the above.   I have two tables `table_a` and `table_b` that have materialized columns `column_a` and `column_b` respectively.     When I try to write a query that joins the tables and uses those columns:\r\n\r\n```\r\nSELECT column_a, column_b\r\nFROM table_a a \r\nALL LEFT OUTER JOIN table_b on a.id = b.id\r\n\r\n```\r\nI get an error that looks like this:\r\n\r\n`DB::Exception: Missing columns: 'b.column_b' while processing query: 'SELECT...`\r\n\r\nIf I select from table_b and join on table_a I get the same error for column_a\r\n\r\nThe work around is to do the following:\r\n```\r\nSELECT * \r\nFROM \r\n\t(SELECT column_a FROM table_a ) a\r\n\tALL LEFT OUTER JOIN\r\n\t(SELECT *, column_b FROM table_b ) b\r\n\tON a.id = b.id \r\n```\r\n\r\nThanks",
  "created_at": "2021-06-23T14:04:59Z",
  "modified_files": [
    "src/Interpreters/DatabaseAndTableWithAlias.h",
    "src/Interpreters/ExpressionAnalyzer.cpp",
    "src/Interpreters/IdentifierSemantic.cpp",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/JoinedTables.cpp",
    "src/Interpreters/JoinedTables.h",
    "src/Interpreters/SelectQueryOptions.h",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/getTableExpressions.cpp",
    "src/Interpreters/getTableExpressions.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01925_join_materialized_columns.reference",
    "b/tests/queries/0_stateless/01925_join_materialized_columns.sql"
  ]
}