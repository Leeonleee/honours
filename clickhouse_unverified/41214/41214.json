{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41214,
  "instance_id": "ClickHouse__ClickHouse-41214",
  "issue_numbers": [
    "38435"
  ],
  "base_commit": "b26cc5a1ba791df03e56117c6207aec97b25b58b",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 3869168becd7..dde40acb91a5 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -3145,6 +3145,17 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## enable_extended_results_for_datetime_functions {#enable-extended-results-for-datetime-functions}\n+\n+Enables or disables returning results of type `Date32` with extended range (compared to type `Date`) for functions [toStartOfYear](../../sql-reference/functions/date-time-functions.md#tostartofyear), [toStartOfISOYear](../../sql-reference/functions/date-time-functions.md#tostartofisoyear), [toStartOfQuarter](../../sql-reference/functions/date-time-functions.md#tostartofquarter), [toStartOfMonth](../../sql-reference/functions/date-time-functions.md#tostartofmonth), [toStartOfWeek](../../sql-reference/functions/date-time-functions.md#tostartofweek), [toMonday](../../sql-reference/functions/date-time-functions.md#tomonday) and [toLastDayOfMonth](../../sql-reference/functions/date-time-functions.md#tolastdayofmonth).\n+\n+Possible values:\n+\n+-   0 \u2014 Functions return `Date` for all types of arguments.\n+-   1 \u2014 Functions return `Date32` for `Date32` or `DateTime64` arguments and `Date` otherwise.\n+\n+Default value: `0`.\n+\n ## optimize_move_to_prewhere {#optimize_move_to_prewhere}\n \n Enables or disables automatic [PREWHERE](../../sql-reference/statements/select/prewhere.md) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries.\n@@ -3530,8 +3541,8 @@ desc format(JSONEachRow, '{\"x\" : 1, \"y\" : \"String\", \"z\" : \"0.0.0.0\" }') settings\n \n Result:\n ```sql\n-x\tUInt8\t\t\t\t\t\n-y\tNullable(String)\t\t\t\t\t\n+x\tUInt8\n+y\tNullable(String)\n z\tIPv4\n ```\n \ndiff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 8688f3eb3a06..001c78224338 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -268,13 +268,15 @@ Result:\n ```\n \n :::note\n-The return type of `toStartOf*`, `toLastDayOfMonth`, `toMonday` functions described below is `Date` or `DateTime`.\n-Though these functions can take values of the extended types `Date32` and `DateTime64` as an argument, passing them a time outside the normal range (year 1970 to 2149 for `Date` / 2106 for `DateTime`) will produce wrong results.\n-In case argument is out of normal range:\n+The return type of `toStartOf*`, `toLastDayOfMonth`, `toMonday` functions described below is determined by the configuration parameter [enable_extended_results_for_datetime_functions](../../operations/settings/settings#enable-extended-results-for-datetime-functions) which is `0` by default.\n+\n+Behavior for\n+* `enable_extended_results_for_datetime_functions = 0`: Functions `toStartOf*`, `toLastDayOfMonth`, `toMonday` return `Date` or `DateTime`. Though these functions can take values of the extended types `Date32` and `DateTime64` as an argument, passing them a time outside the normal range (year 1970 to 2149 for `Date` / 2106 for `DateTime`) will produce wrong results. In case argument is out of normal range:\n   * If the argument is smaller than 1970, the result will be calculated from the argument `1970-01-01 (00:00:00)` instead.\n   * If the return type is `DateTime` and the argument is larger than `2106-02-07 08:28:15`, the result will be calculated from the argument `2106-02-07 08:28:15` instead.\n   * If the return type is `Date` and the argument is larger than `2149-06-06`, the result will be calculated from the argument `2149-06-06` instead.\n   *  If `toLastDayOfMonth` is called with an argument greater then `2149-05-31`, the result will be calculated from the argument `2149-05-31` instead.\n+* `enable_extended_results_for_datetime_functions = 1`: Functions `toStartOfYear`, `toStartOfISOYear`, `toStartOfQuarter`, `toStartOfMonth`, `toStartOfWeek`, `toLastDayOfMonth`, `toMonday` return `Date` or `DateTime` if their argument is a `Date` or `DateTime`, and they return `Date32` or `DateTime64` if their argument is a `Date32` or `DateTime64`.\n :::\n \n ## toStartOfYear\n@@ -303,6 +305,8 @@ Returns the date.\n Rounds up a date or date with time to the last day of the month.\n Returns the date.\n \n+If `toLastDayOfMonth` is called with an argument of type `Date` greater then 2149-05-31, the result will be calculated from the argument 2149-05-31 instead.\n+\n ## toMonday\n \n Rounds down a date or date with time to the nearest Monday.\n@@ -640,7 +644,7 @@ Result:\n \n ## date\\_diff\n \n-Returns the difference between two dates or dates with time values. \n+Returns the difference between two dates or dates with time values.\n The difference is calculated using relative units, e.g. the difference between `2022-01-01` and `2021-12-29` is 3 days for day unit (see [toRelativeDayNum](#torelativedaynum)), 1 month for month unit (see [toRelativeMonthNum](#torelativemonthnum)), 1 year for year unit (see [toRelativeYearNum](#torelativeyearnum)).\n \n **Syntax**\n@@ -1059,9 +1063,9 @@ SELECT\n \n ## timeSlots(StartTime, Duration,\\[, Size\\])\n \n-For a time interval starting at \u2018StartTime\u2019 and continuing for \u2018Duration\u2019 seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the \u2018Size\u2019 in seconds. \u2018Size\u2019 is an optional parameter set to 1800 (30 minutes) by default.  \n-This is necessary, for example, when searching for pageviews in the corresponding session.  \n-Accepts DateTime and DateTime64 as \u2019StartTime\u2019 argument. For DateTime, \u2019Duration\u2019 and \u2019Size\u2019 arguments must be `UInt32`. For \u2019DateTime64\u2019 they must be `Decimal64`.  \n+For a time interval starting at \u2018StartTime\u2019 and continuing for \u2018Duration\u2019 seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the \u2018Size\u2019 in seconds. \u2018Size\u2019 is an optional parameter set to 1800 (30 minutes) by default.\n+This is necessary, for example, when searching for pageviews in the corresponding session.\n+Accepts DateTime and DateTime64 as \u2019StartTime\u2019 argument. For DateTime, \u2019Duration\u2019 and \u2019Size\u2019 arguments must be `UInt32`. For \u2019DateTime64\u2019 they must be `Decimal64`.\n Returns an array of DateTime/DateTime64 (return type matches the type of \u2019StartTime\u2019). For DateTime64, the return value's scale can differ from the scale of \u2019StartTime\u2019 --- the highest scale among all given arguments is taken.\n \n Example:\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex 5ddc684ce2a4..0d4f0c632107 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -3799,6 +3799,17 @@ Exception: Total regexp lengths too large.\n \n \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `1`.\n \n+## enable_extended_results_for_datetime_functions {#enable-extended-results-for-datetime-functions}\n+\n+\u0412\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0442\u0438\u043f\u0430 `Date32` \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u043c \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u043e\u043c (\u043f\u043e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044e \u0441 \u0442\u0438\u043f\u043e\u043c `Date`) \u0434\u043b\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0439 [toStartOfYear](../../sql-reference/functions/date-time-functions.md#tostartofyear), [toStartOfISOYear](../../sql-reference/functions/date-time-functions.md#tostartofisoyear), [toStartOfQuarter](../../sql-reference/functions/date-time-functions.md#tostartofquarter), [toStartOfMonth](../../sql-reference/functions/date-time-functions.md#tostartofmonth), [toStartOfWeek](../../sql-reference/functions/date-time-functions.md#tostartofweek), [toMonday](../../sql-reference/functions/date-time-functions.md#tomonday) \u0438 [toLastDayOfMonth](../../sql-reference/functions/date-time-functions.md#tolastdayofmonth).\n+\n+\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f:\n+\n+-   0 \u2014 \u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0442\u0438\u043f\u0430 `Date` \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0442\u0438\u043f\u043e\u0432 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432.\n+-   1 \u2014 \u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0442\u0438\u043f\u0430 `Date32` \u0434\u043b\u044f \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0442\u0438\u043f\u0430 `Date32` \u0438\u043b\u0438 `DateTime64` \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 `Date` \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445.\n+\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `0`.\n+\n **\u041f\u0440\u0438\u043c\u0435\u0440**\n \n \u0417\u0430\u043f\u0440\u043e\u0441:\ndiff --git a/docs/ru/sql-reference/functions/date-time-functions.md b/docs/ru/sql-reference/functions/date-time-functions.md\nindex 1c623cd1dabd..27689426cbe0 100644\n--- a/docs/ru/sql-reference/functions/date-time-functions.md\n+++ b/docs/ru/sql-reference/functions/date-time-functions.md\n@@ -268,24 +268,18 @@ SELECT toUnixTimestamp('2017-11-05 08:07:47', 'Asia/Tokyo') AS unix_timestamp;\n ```\n \n :::note\n-\u0422\u0438\u043f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0433\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u043c\u0438 \u0434\u0430\u043b\u0435\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c\u0438 `toStartOf*`, `toMonday` \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f - `Date` \u0438\u043b\u0438 `DateTime`.\n-\u0425\u043e\u0442\u044f \u044d\u0442\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 `Date32` \u0438\u043b\u0438 `DateTime64` \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 (`1970` - `2148` \u0434\u043b\u044f `Date` \u0438 `1970-01-01 00:00:00`-`2106-02-07 08:28:15` \u0434\u043b\u044f `DateTime`) \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442.\n-\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430:\n-* `1970-01-01 (00:00:00)` \u0431\u0443\u0434\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0451\u043d \u0434\u043b\u044f \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0434\u043e 1970 \u0433\u043e\u0434\u0430,\n-* `2106-02-07 08:28:15` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `DateTime`,\n-* `2149-06-06` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `Date`,\n-* `2149-05-31` \u0431\u0443\u0434\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u0438 `toLastDayOfMonth` \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 `2149-05-31`.\n+\u0422\u0438\u043f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u043c\u0438 \u0434\u0430\u043b\u0435\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c\u0438 `toStartOf*`, `toLastDayOfMonth`, `toMonday` \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u043c [enable_extended_results_for_datetime_functions](../../operations/settings/settings#enable-extended-results-for-datetime-functions) \u0438\u043c\u0435\u044e\u0449\u0438\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `0`.\n+\n+\u041f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0434\u043b\u044f\n+* `enable_extended_results_for_datetime_functions = 0`: \u0424\u0443\u043d\u043a\u0446\u0438\u0438 `toStartOf*`, `toLastDayOfMonth`, `toMonday` \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 `Date` \u0438\u043b\u0438 `DateTime`. \u0425\u043e\u0442\u044f \u044d\u0442\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 `Date32` \u0438\u043b\u0438 `DateTime64` \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 (`1970` - `2148` \u0434\u043b\u044f `Date` \u0438 `1970-01-01 00:00:00`-`2106-02-07 08:28:15` \u0434\u043b\u044f `DateTime`) \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442.\n+\u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0435\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430:\n+    * `1970-01-01 (00:00:00)` \u0431\u0443\u0434\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0451\u043d \u0434\u043b\u044f \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0434\u043e 1970 \u0433\u043e\u0434\u0430,\n+    * `2106-02-07 08:28:15` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `DateTime`,\n+    * `2149-06-06` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `Date`,\n+    * `2149-05-31` \u0431\u0443\u0434\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u0438 `toLastDayOfMonth` \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 `2149-05-31`.\n+* `enable_extended_results_for_datetime_functions = 1`: \u0424\u0443\u043d\u043a\u0446\u0438\u0438 `toStartOfYear`, `toStartOfISOYear`, `toStartOfQuarter`, `toStartOfMonth`, `toStartOfWeek`, `toLastDayOfMonth`, `toMonday` \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 `Date` \u0438\u043b\u0438 `DateTime` \u0435\u0441\u043b\u0438 \u0438\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 `Date` \u0438\u043b\u0438 `DateTime` \u0438 \u043e\u043d\u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 `Date32` \u0438\u043b\u0438 `DateTime64` \u0435\u0441\u043b\u0438 \u0438\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 `Date32` \u0438\u043b\u0438 `DateTime64`.\n :::\n \n-:::note\n-\u0422\u0438\u043f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0433\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u043c\u0438 \u0434\u0430\u043b\u0435\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c\u0438 `toStartOf*`, `toLastDayOfMonth`, `toMonday` \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f - `Date` \u0438\u043b\u0438 `DateTime`.\n-\u0425\u043e\u0442\u044f \u044d\u0442\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 `Date32` \u0438\u043b\u0438 `DateTime64` \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u043f\u0440\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 (`1970` - `2148` \u0434\u043b\u044f `Date` \u0438 `1970-01-01 00:00:00`-`2106-02-07 08:28:15` \u0434\u043b\u044f `DateTime`) \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442.\n-\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0432\u043d\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430:\n-* `1970-01-01 (00:00:00)` \u0431\u0443\u0434\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0451\u043d \u0434\u043b\u044f \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0434\u043e 1970 \u0433\u043e\u0434\u0430,\n-* `2106-02-07 08:28:15` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `DateTime`,\n-* `2149-06-06` \u0431\u0443\u0434\u0435\u0442 \u0432\u0437\u044f\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u0438\u0442 \u0434\u0430\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f - `Date`.\n-  :::\n-*\n ## toStartOfYear {#tostartofyear}\n \n \u041e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442 \u0434\u0430\u0442\u0443 \u0438\u043b\u0438 \u0434\u0430\u0442\u0443-\u0441-\u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0432\u043d\u0438\u0437 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0434\u043d\u044f \u0433\u043e\u0434\u0430.\n@@ -324,6 +318,8 @@ SELECT toStartOfISOYear(toDate('2017-01-01')) AS ISOYear20170101;\n \u041e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442 \u0434\u0430\u0442\u0443 \u0438\u043b\u0438 \u0434\u0430\u0442\u0443-\u0441-\u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0434\u043e \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u043c\u0435\u0441\u044f\u0446\u0430.\n \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u0434\u0430\u0442\u0430.\n \n+\u0415\u0441\u043b\u0438 `toLastDayOfMonth` \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0441 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c \u0442\u0438\u043f\u0430 `Date` \u0431\u043e\u043b\u044c\u0448\u0438\u043c \u0447\u0435\u043c 2149-05-31, \u0442\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d \u043e\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 2149-05-31.\n+\n ## toMonday {#tomonday}\n \n \u041e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442 \u0434\u0430\u0442\u0443 \u0438\u043b\u0438 \u0434\u0430\u0442\u0443-\u0441-\u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0432\u043d\u0438\u0437 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0433\u043e \u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a\u0430.\n@@ -977,7 +973,7 @@ SELECT now('Europe/Moscow');\n ## timeSlots(StartTime, Duration,\\[, Size\\]) {#timeslotsstarttime-duration-size}\n \u0414\u043b\u044f \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430, \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0449\u0435\u0433\u043e\u0441\u044f \u0432 `StartTime` \u0438 \u0434\u043b\u044f\u0449\u0435\u0433\u043e\u0441\u044f `Duration` \u0441\u0435\u043a\u0443\u043d\u0434, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043c\u0430\u0441\u0441\u0438\u0432 \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u043a\u0440\u0430\u0442\u043d\u044b\u0445 `Size`. \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 `Size` \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u043e\u043d \u0440\u0430\u0432\u0435\u043d 1800 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\u043c (30 \u043c\u0438\u043d\u0443\u0442\u0430\u043c) - \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440.\n \u0414\u0430\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043c\u043e\u0436\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0434\u043b\u044f \u0430\u043d\u0430\u043b\u0438\u0437\u0430 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u043e\u0432 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b \u0437\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0443\u044e \u0441\u0435\u0441\u0441\u0438\u044e.\n-\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442 `StartTime` \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f `DateTime` \u0438\u043b\u0438 `DateTime64`. \u0412 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f `DateTime`, \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b `Duration` \u0438 `Size` \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f `UInt32`; \u0414\u043b\u044f DateTime64 \u043e\u043d\u0438 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0442\u0438\u043f\u0430 `Decimal64`.  \n+\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442 `StartTime` \u043c\u043e\u0436\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f `DateTime` \u0438\u043b\u0438 `DateTime64`. \u0412 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f `DateTime`, \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b `Duration` \u0438 `Size` \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f `UInt32`; \u0414\u043b\u044f DateTime64 \u043e\u043d\u0438 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0442\u0438\u043f\u0430 `Decimal64`.\n \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043c\u0430\u0441\u0441\u0438\u0432 DateTime/DateTime64 (\u0442\u0438\u043f \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u0442\u044c \u0441 \u0442\u0438\u043f\u043e\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u2019StartTime\u2019). \u0414\u043b\u044f DateTime64 \u043c\u0430\u0441\u0448\u0442\u0430\u0431(scale) \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0439 \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u044b \u043c\u043e\u0436\u0435\u0442 \u043e\u0442\u043b\u0438\u0447\u0430\u0442\u044c\u0441\u044f \u043e\u0442 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0430 \u0444\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u2019StartTime\u2019 --- \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0438\u0439 \u043c\u0430\u0441\u0448\u0442\u0430\u0431 \u0441\u0440\u0435\u0434\u0438 \u0432\u0441\u0435\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432.\n \n \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f:\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 8793bbb30112..d677c7900bc2 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -136,6 +136,7 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     M(Bool, distributed_aggregation_memory_efficient, true, \"Is the memory-saving mode of distributed aggregation enabled.\", 0) \\\n     M(UInt64, aggregation_memory_efficient_merge_threads, 0, \"Number of threads to use for merge intermediate aggregation results in memory efficient mode. When bigger, then more memory is consumed. 0 means - same as 'max_threads'.\", 0) \\\n     M(Bool, enable_positional_arguments, true, \"Enable positional arguments in ORDER BY, GROUP BY and LIMIT BY\", 0) \\\n+    M(Bool, enable_extended_results_for_datetime_functions, false, \"Enable date functions like toLastDayOfMonth return Date32 results (instead of Date results) for Date32/DateTime64 arguments.\", 0) \\\n     \\\n     M(Bool, group_by_use_nulls, false, \"Treat columns mentioned in ROLLUP, CUBE or GROUPING SETS as Nullable\", 0) \\\n     \\\ndiff --git a/src/Functions/CustomWeekTransforms.h b/src/Functions/CustomWeekTransforms.h\nindex 3378aec02d5b..5fa51d5f5e0b 100644\n--- a/src/Functions/CustomWeekTransforms.h\n+++ b/src/Functions/CustomWeekTransforms.h\n@@ -82,6 +82,14 @@ struct ToStartOfWeekImpl\n     {\n         return time_zone.toFirstDayNumOfWeek(DayNum(d), week_mode);\n     }\n+    static inline Int64 execute_extended_result(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);\n+    }\n \n     using FactorTransform = ZeroTransform;\n };\n@@ -115,7 +123,7 @@ struct ToWeekImpl\n     using FactorTransform = ToStartOfYearImpl;\n };\n \n-template <typename FromType, typename ToType, typename Transform>\n+template <typename FromType, typename ToType, typename Transform, bool is_extended_result = false>\n struct WeekTransformer\n {\n     explicit WeekTransformer(Transform transform_)\n@@ -130,7 +138,10 @@ struct WeekTransformer\n         vec_to.resize(size);\n \n         for (size_t i = 0; i < size; ++i)\n-            vec_to[i] = transform.execute(vec_from[i], week_mode, time_zone);\n+            if constexpr (is_extended_result)\n+                vec_to[i] = transform.execute_extended_result(vec_from[i], week_mode, time_zone);\n+            else\n+                vec_to[i] = transform.execute(vec_from[i], week_mode, time_zone);\n     }\n \n private:\n@@ -138,13 +149,13 @@ struct WeekTransformer\n };\n \n \n-template <typename FromDataType, typename ToDataType>\n+template <typename FromDataType, typename ToDataType, bool is_extended_result = false>\n struct CustomWeekTransformImpl\n {\n     template <typename Transform>\n     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/, Transform transform = {})\n     {\n-        const auto op = WeekTransformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>{std::move(transform)};\n+        const auto op = WeekTransformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform, is_extended_result>{std::move(transform)};\n \n         UInt8 week_mode = DEFAULT_WEEK_MODE;\n         if (arguments.size() > 1)\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 66d57f2463f6..fbe8e4bfcfee 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -161,7 +161,14 @@ struct ToMondayImpl\n     {\n         return time_zone.toFirstDayNumOfWeek(DayNum(d));\n     }\n-\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d));\n+    }\n     using FactorTransform = ZeroTransform;\n };\n \n@@ -185,6 +192,14 @@ struct ToStartOfMonthImpl\n     {\n         return time_zone.toFirstDayNumOfMonth(DayNum(d));\n     }\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfMonth(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfMonth(ExtendedDayNum(d));\n+    }\n \n     using FactorTransform = ZeroTransform;\n };\n@@ -218,7 +233,14 @@ struct ToLastDayOfMonthImpl\n         /// 0xFFF9 is Int value for 2149-05-31 -- the last day where we can actually find LastDayOfMonth. This will also be the return value.\n         return time_zone.toLastDayNumOfMonth(DayNum(std::min(d, UInt16(0xFFF9))));\n     }\n-\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfMonth(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfMonth(ExtendedDayNum(d));\n+    }\n     using FactorTransform = ZeroTransform;\n };\n \n@@ -242,7 +264,14 @@ struct ToStartOfQuarterImpl\n     {\n         return time_zone.toFirstDayNumOfQuarter(DayNum(d));\n     }\n-\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfQuarter(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfQuarter(ExtendedDayNum(d));\n+    }\n     using FactorTransform = ZeroTransform;\n };\n \n@@ -266,6 +295,14 @@ struct ToStartOfYearImpl\n     {\n         return time_zone.toFirstDayNumOfYear(DayNum(d));\n     }\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfYear(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfYear(ExtendedDayNum(d));\n+    }\n \n     using FactorTransform = ZeroTransform;\n };\n@@ -893,7 +930,7 @@ struct ToStartOfISOYearImpl\n \n     static inline UInt16 execute(Int64 t, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toFirstDayNumOfISOYear(time_zone.toDayNum(t));\n+        return t < 0 ? 0 : time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(std::min(Int32(time_zone.toDayNum(t)), Int32(DATE_LUT_MAX_DAY_NUM))));\n     }\n     static inline UInt16 execute(UInt32 t, const DateLUTImpl & time_zone)\n     {\n@@ -901,12 +938,20 @@ struct ToStartOfISOYearImpl\n     }\n     static inline UInt16 execute(Int32 d, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(d));\n+        return d < 0 ? 0 : time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(std::min(d, Int32(DATE_LUT_MAX_DAY_NUM))));\n     }\n     static inline UInt16 execute(UInt16 d, const DateLUTImpl & time_zone)\n     {\n         return time_zone.toFirstDayNumOfISOYear(DayNum(d));\n     }\n+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfISOYear(time_zone.toDayNum(t));\n+    }\n+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(d));\n+    }\n \n     using FactorTransform = ZeroTransform;\n };\n@@ -1201,7 +1246,7 @@ struct ToYYYYMMDDhhmmssImpl\n };\n \n \n-template <typename FromType, typename ToType, typename Transform>\n+template <typename FromType, typename ToType, typename Transform, bool is_extended_result = false>\n struct Transformer\n {\n     template <typename FromTypeVector, typename ToTypeVector>\n@@ -1211,18 +1256,21 @@ struct Transformer\n         vec_to.resize(size);\n \n         for (size_t i = 0; i < size; ++i)\n-            vec_to[i] = transform.execute(vec_from[i], time_zone);\n+            if constexpr (is_extended_result)\n+                vec_to[i] = transform.execute_extended_result(vec_from[i], time_zone);\n+            else\n+                vec_to[i] = transform.execute(vec_from[i], time_zone);\n     }\n };\n \n \n-template <typename FromDataType, typename ToDataType, typename Transform>\n+template <typename FromDataType, typename ToDataType, typename Transform, bool is_extended_result = false>\n struct DateTimeTransformImpl\n {\n     static ColumnPtr execute(\n         const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})\n     {\n-        using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>;\n+        using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform, is_extended_result>;\n \n         const ColumnPtr source_col = arguments[0].column;\n         if (const auto * sources = checkAndGetColumn<typename FromDataType::ColumnType>(source_col.get()))\ndiff --git a/src/Functions/FunctionCustomWeekToDateOrDate32.h b/src/Functions/FunctionCustomWeekToDateOrDate32.h\nnew file mode 100644\nindex 000000000000..0b91fbb3bbe1\n--- /dev/null\n+++ b/src/Functions/FunctionCustomWeekToDateOrDate32.h\n@@ -0,0 +1,78 @@\n+#pragma once\n+#include <Functions/IFunctionCustomWeek.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+template <typename Transform>\n+class FunctionCustomWeekToDateOrDate32 : public IFunctionCustomWeek<Transform>, WithContext\n+{\n+public:\n+    const bool enable_extended_results_for_datetime_functions = false;\n+\n+    static FunctionPtr create(ContextPtr context_)\n+    {\n+        return std::make_shared<FunctionCustomWeekToDateOrDate32>(context_);\n+    }\n+\n+    explicit FunctionCustomWeekToDateOrDate32(ContextPtr context_)\n+        : WithContext(context_)\n+        , enable_extended_results_for_datetime_functions(context_->getSettingsRef().enable_extended_results_for_datetime_functions)\n+    {\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true);\n+\n+        const IDataType * from_type = arguments[0].type.get();\n+        WhichDataType which(from_type);\n+        if ((which.isDate32() || which.isDateTime64()) && enable_extended_results_for_datetime_functions)\n+            return std::make_shared<DataTypeDate32>();\n+        else\n+            return std::make_shared<DataTypeDate>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        const IDataType * from_type = arguments[0].type.get();\n+        WhichDataType which(from_type);\n+\n+        if (which.isDate())\n+            return CustomWeekTransformImpl<DataTypeDate, DataTypeDate>::execute(\n+                arguments, result_type, input_rows_count, Transform{});\n+        else if (which.isDate32())\n+            if (enable_extended_results_for_datetime_functions)\n+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate32, /*is_extended_result*/ true>::execute(\n+                    arguments, result_type, input_rows_count, Transform{});\n+            else\n+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate>::execute(\n+                    arguments, result_type, input_rows_count, Transform{});\n+        else if (which.isDateTime())\n+            return CustomWeekTransformImpl<DataTypeDateTime, DataTypeDate>::execute(\n+                arguments, result_type, input_rows_count, Transform{});\n+        else if (which.isDateTime64())\n+        {\n+            if (enable_extended_results_for_datetime_functions)\n+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate32, /*is_extended_result*/ true>::execute(\n+                    arguments, result_type, input_rows_count,\n+                    TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});\n+            else\n+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate>::execute(\n+                    arguments, result_type, input_rows_count,\n+                    TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});\n+        }\n+        else\n+            throw Exception(\n+                \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + this->getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n+\n+};\n+\n+}\ndiff --git a/src/Functions/FunctionCustomWeekToSomething.h b/src/Functions/FunctionCustomWeekToSomething.h\nindex 8a0f474a7e87..eb65d5622211 100644\n--- a/src/Functions/FunctionCustomWeekToSomething.h\n+++ b/src/Functions/FunctionCustomWeekToSomething.h\n@@ -1,14 +1,5 @@\n #pragma once\n-#include <DataTypes/DataTypeDate.h>\n-#include <DataTypes/DataTypeDate32.h>\n-#include <DataTypes/DataTypeDateTime.h>\n-#include <DataTypes/DataTypeDateTime64.h>\n-#include <Functions/CustomWeekTransforms.h>\n-#include <Functions/IFunction.h>\n-#include <Functions/TransformDateTime64.h>\n-#include <IO/WriteHelpers.h>\n-#include <Interpreters/Context_fwd.h>\n-\n+#include <Functions/IFunctionCustomWeek.h>\n \n namespace DB\n {\n@@ -16,82 +7,23 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n \n /// See CustomWeekTransforms.h\n template <typename ToDataType, typename Transform>\n-class FunctionCustomWeekToSomething : public IFunction\n+class FunctionCustomWeekToSomething : public IFunctionCustomWeek<Transform>\n {\n public:\n-    static constexpr auto name = Transform::name;\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionCustomWeekToSomething>(); }\n \n-    String getName() const override { return name; }\n-\n-    bool isVariadic() const override { return true; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    size_t getNumberOfArguments() const override { return 0; }\n-\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.size() == 1)\n-        {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n-                throw Exception(\n-                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n-                        + \". Must be Date, Date32, DateTime or DateTime64.\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else if (arguments.size() == 2)\n-        {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n-                throw Exception(\n-                    \"Illegal type \" + arguments[0].type->getName() + \" of 1st argument of function \" + getName()\n-                        + \". Must be Date, Date32, DateTime or DateTime64.\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if (!isUInt8(arguments[1].type))\n-                throw Exception(\n-                    \"Illegal type of 2nd (optional) argument of function \" + getName()\n-                        + \". Must be constant UInt8 (week mode).\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else if (arguments.size() == 3)\n-        {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n-                throw Exception(\n-                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n-                        + \". Must be Date, Date32, DateTime or DateTime64\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if (!isUInt8(arguments[1].type))\n-                throw Exception(\n-                    \"Illegal type of 2nd (optional) argument of function \" + getName()\n-                        + \". Must be constant UInt8 (week mode).\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if (!isString(arguments[2].type))\n-                throw Exception(\n-                    \"Illegal type of 3rd (optional) argument of function \" + getName()\n-                        + \". Must be constant string (timezone name).\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if ((isDate(arguments[0].type) || isDate32(arguments[0].type))\n-                && (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>))\n-                throw Exception(\n-                    \"The timezone argument of function \" + getName() + \" is allowed only when the 1st argument is DateTime or DateTime64.\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else\n-            throw Exception(\n-                \"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(arguments.size())\n-                    + \", expected 1, 2 or 3.\",\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+        this->checkArguments(arguments);\n \n         return std::make_shared<ToDataType>();\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         const IDataType * from_type = arguments[0].type.get();\n@@ -114,44 +46,10 @@ class FunctionCustomWeekToSomething : public IFunction\n         }\n         else\n             throw Exception(\n-                \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName(),\n+                \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + this->getName(),\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n \n-\n-    bool hasInformationAboutMonotonicity() const override { return true; }\n-\n-    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n-    {\n-        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n-\n-        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };\n-        const IFunction::Monotonicity is_not_monotonic;\n-\n-        /// This method is called only if the function has one argument. Therefore, we do not care about the non-local time zone.\n-        const DateLUTImpl & date_lut = DateLUT::instance();\n-\n-        if (left.isNull() || right.isNull())\n-            return {};\n-\n-        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.\n-\n-        if (checkAndGetDataType<DataTypeDate>(&type))\n-        {\n-            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), date_lut)\n-                    == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), date_lut)\n-                ? is_monotonic\n-                : is_not_monotonic;\n-        }\n-        else\n-        {\n-            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), date_lut)\n-                    == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), date_lut)\n-                ? is_monotonic\n-                : is_not_monotonic;\n-        }\n-    }\n };\n \n }\ndiff --git a/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h b/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h\nnew file mode 100644\nindex 000000000000..3ff90cb57fbc\n--- /dev/null\n+++ b/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h\n@@ -0,0 +1,81 @@\n+#pragma once\n+#include <Functions/IFunctionDateOrDateTime.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+template <typename Transform>\n+class FunctionDateOrDateTimeToDateOrDate32 : public IFunctionDateOrDateTime<Transform>, WithContext\n+{\n+public:\n+    const bool enable_extended_results_for_datetime_functions = false;\n+\n+    static FunctionPtr create(ContextPtr context_)\n+    {\n+        return std::make_shared<FunctionDateOrDateTimeToDateOrDate32>(context_);\n+    }\n+\n+    explicit FunctionDateOrDateTimeToDateOrDate32(ContextPtr context_)\n+        : WithContext(context_)\n+        , enable_extended_results_for_datetime_functions(context_->getSettingsRef().enable_extended_results_for_datetime_functions)\n+    {\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true);\n+\n+        const IDataType * from_type = arguments[0].type.get();\n+        WhichDataType which(from_type);\n+\n+        /// If the time zone is specified but empty, throw an exception.\n+        /// only validate the time_zone part if the number of arguments is 2.\n+        if ((which.isDateTime() || which.isDateTime64()) && arguments.size() == 2\n+            && extractTimeZoneNameFromFunctionArguments(arguments, 1, 0).empty())\n+            throw Exception(\n+                \"Function \" + this->getName() + \" supports a 2nd argument (optional) that must be non-empty and be a valid time zone\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if ((which.isDate32() || which.isDateTime64()) && enable_extended_results_for_datetime_functions)\n+            return std::make_shared<DataTypeDate32>();\n+        else\n+            return std::make_shared<DataTypeDate>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        const IDataType * from_type = arguments[0].type.get();\n+        WhichDataType which(from_type);\n+\n+        if (which.isDate())\n+            return DateTimeTransformImpl<DataTypeDate, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);\n+        else if (which.isDate32())\n+            if (enable_extended_results_for_datetime_functions)\n+                return DateTimeTransformImpl<DataTypeDate32, DataTypeDate32, Transform, /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count);\n+            else\n+                return DateTimeTransformImpl<DataTypeDate32, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);\n+        else if (which.isDateTime())\n+            return DateTimeTransformImpl<DataTypeDateTime, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);\n+        else if (which.isDateTime64())\n+        {\n+            const auto scale = static_cast<const DataTypeDateTime64 *>(from_type)->getScale();\n+\n+            const TransformDateTime64<Transform> transformer(scale);\n+            if (enable_extended_results_for_datetime_functions)\n+                return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, decltype(transformer), /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count, transformer);\n+            else\n+                return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);\n+        }\n+        else\n+            throw Exception(\"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + this->getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n+\n+};\n+\n+}\ndiff --git a/src/Functions/FunctionDateOrDateTimeToSomething.h b/src/Functions/FunctionDateOrDateTimeToSomething.h\nindex d734c7f87c19..5c1c54c1b849 100644\n--- a/src/Functions/FunctionDateOrDateTimeToSomething.h\n+++ b/src/Functions/FunctionDateOrDateTimeToSomething.h\n@@ -1,14 +1,5 @@\n #pragma once\n-#include <DataTypes/DataTypeDate.h>\n-#include <DataTypes/DataTypeDate32.h>\n-#include <DataTypes/DataTypeDateTime.h>\n-#include <Functions/IFunction.h>\n-#include <DataTypes/DataTypeDateTime64.h>\n-#include <Functions/extractTimeZoneFromFunctionArguments.h>\n-#include <Functions/DateTimeTransforms.h>\n-#include <Functions/TransformDateTime64.h>\n-#include <IO/WriteHelpers.h>\n-\n+#include <Functions/IFunctionDateOrDateTime.h>\n \n namespace DB\n {\n@@ -16,59 +7,18 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n /// See DateTimeTransforms.h\n template <typename ToDataType, typename Transform>\n-class FunctionDateOrDateTimeToSomething : public IFunction\n+class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transform>\n {\n public:\n-    static constexpr auto name = Transform::name;\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionDateOrDateTimeToSomething>(); }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    bool isVariadic() const override { return true; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-    size_t getNumberOfArguments() const override { return 0; }\n-\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.size() == 1)\n-        {\n-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n-                throw Exception(\n-                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n-                        + \". Should be a date or a date with time\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else if (arguments.size() == 2)\n-        {\n-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n-                throw Exception(\n-                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n-                        + \". Should be a date or a date with time\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if (!isString(arguments[1].type))\n-                throw Exception(\n-                    \"Function \" + getName() + \" supports 1 or 2 arguments. The 1st argument \"\n-                          \"must be of type Date or DateTime. The 2nd argument (optional) must be \"\n-                          \"a constant string with timezone name\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>))\n-                throw Exception(\n-                    \"The timezone argument of function \" + getName() + \" is allowed only when the 1st argument has the type DateTime\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else\n-            throw Exception(\n-                \"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(arguments.size())\n-                    + \", should be 1 or 2\",\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+        this->checkArguments(arguments, (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>));\n \n         /// For DateTime, if time zone is specified, attach it to type.\n         /// If the time zone is specified but empty, throw an exception.\n@@ -79,7 +29,7 @@ class FunctionDateOrDateTimeToSomething : public IFunction\n             /// to accommodate functions like toStartOfDay(today()), toStartOfDay(yesterday()) etc.\n             if (arguments.size() == 2 && time_zone.empty())\n                 throw Exception(\n-                    \"Function \" + getName() + \" supports a 2nd argument (optional) that must be non-empty and be a valid time zone\",\n+                    \"Function \" + this->getName() + \" supports a 2nd argument (optional) that must be non-empty and be a valid time zone\",\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n             return std::make_shared<ToDataType>(time_zone);\n         }\n@@ -109,9 +59,6 @@ class FunctionDateOrDateTimeToSomething : public IFunction\n             return std::make_shared<ToDataType>();\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         const IDataType * from_type = arguments[0].type.get();\n@@ -131,51 +78,10 @@ class FunctionDateOrDateTimeToSomething : public IFunction\n             return DateTimeTransformImpl<DataTypeDateTime64, ToDataType, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);\n         }\n         else\n-            throw Exception(\"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName(),\n+            throw Exception(\"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + this->getName(),\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n \n-    bool hasInformationAboutMonotonicity() const override\n-    {\n-        return true;\n-    }\n-\n-    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n-    {\n-        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n-\n-        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };\n-        const IFunction::Monotonicity is_not_monotonic;\n-\n-        const DateLUTImpl * date_lut = &DateLUT::instance();\n-        if (const auto * timezone = dynamic_cast<const TimezoneMixin *>(&type))\n-            date_lut = &timezone->getTimeZone();\n-\n-        if (left.isNull() || right.isNull())\n-            return is_not_monotonic;\n-\n-        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.\n-\n-        if (checkAndGetDataType<DataTypeDate>(&type))\n-        {\n-            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), *date_lut)\n-                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), *date_lut)\n-                ? is_monotonic : is_not_monotonic;\n-        }\n-        else if (checkAndGetDataType<DataTypeDate32>(&type))\n-        {\n-            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), *date_lut)\n-                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), *date_lut)\n-                   ? is_monotonic : is_not_monotonic;\n-        }\n-        else\n-        {\n-            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), *date_lut)\n-                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), *date_lut)\n-                ? is_monotonic : is_not_monotonic;\n-        }\n-    }\n };\n \n }\ndiff --git a/src/Functions/IFunctionCustomWeek.h b/src/Functions/IFunctionCustomWeek.h\nnew file mode 100644\nindex 000000000000..1bc4e44655ac\n--- /dev/null\n+++ b/src/Functions/IFunctionCustomWeek.h\n@@ -0,0 +1,122 @@\n+#pragma once\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <Functions/CustomWeekTransforms.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/TransformDateTime64.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+template <typename Transform>\n+class IFunctionCustomWeek : public IFunction\n+{\n+public:\n+    static constexpr auto name = Transform::name;\n+    String getName() const override { return name; }\n+    bool isVariadic() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n+\n+    bool hasInformationAboutMonotonicity() const override { return true; }\n+\n+    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n+    {\n+        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)\n+            return {.is_monotonic = true, .is_always_monotonic = true};\n+\n+        const IFunction::Monotonicity is_monotonic = {.is_monotonic = true};\n+        const IFunction::Monotonicity is_not_monotonic;\n+\n+        /// This method is called only if the function has one argument. Therefore, we do not care about the non-local time zone.\n+        const DateLUTImpl & date_lut = DateLUT::instance();\n+\n+        if (left.isNull() || right.isNull())\n+            return {};\n+\n+        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.\n+\n+        if (checkAndGetDataType<DataTypeDate>(&type))\n+        {\n+            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), date_lut)\n+                    == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), date_lut)\n+                ? is_monotonic\n+                : is_not_monotonic;\n+        }\n+        else\n+        {\n+            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), date_lut)\n+                    == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), date_lut)\n+                ? is_monotonic\n+                : is_not_monotonic;\n+        }\n+    }\n+\n+protected:\n+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32 = false) const\n+    {\n+        if (arguments.size() == 1)\n+        {\n+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n+                        + \". Must be Date, Date32, DateTime or DateTime64.\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+        else if (arguments.size() == 2)\n+        {\n+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[0].type->getName() + \" of 1st argument of function \" + getName()\n+                        + \". Must be Date, Date32, DateTime or DateTime64.\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if (!isUInt8(arguments[1].type))\n+                throw Exception(\n+                    \"Illegal type of 2nd (optional) argument of function \" + getName()\n+                        + \". Must be constant UInt8 (week mode).\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+        else if (arguments.size() == 3)\n+        {\n+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n+                        + \". Must be Date, Date32, DateTime or DateTime64\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if (!isUInt8(arguments[1].type))\n+                throw Exception(\n+                    \"Illegal type of 2nd (optional) argument of function \" + getName()\n+                        + \". Must be constant UInt8 (week mode).\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if (!isString(arguments[2].type))\n+                throw Exception(\n+                    \"Illegal type of 3rd (optional) argument of function \" + getName()\n+                        + \". Must be constant string (timezone name).\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && is_result_type_date_or_date32)\n+                throw Exception(\n+                    \"The timezone argument of function \" + getName() + \" is allowed only when the 1st argument is DateTime or DateTime64.\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+        else\n+            throw Exception(\n+                \"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(arguments.size())\n+                    + \", expected 1, 2 or 3.\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+    }\n+\n+};\n+\n+}\ndiff --git a/src/Functions/IFunctionDateOrDateTime.h b/src/Functions/IFunctionDateOrDateTime.h\nnew file mode 100644\nindex 000000000000..1efe89c7fe94\n--- /dev/null\n+++ b/src/Functions/IFunctionDateOrDateTime.h\n@@ -0,0 +1,118 @@\n+#pragma once\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <Functions/IFunction.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+#include <Functions/DateTimeTransforms.h>\n+#include <Functions/TransformDateTime64.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+template <typename Transform>\n+class IFunctionDateOrDateTime : public IFunction\n+{\n+public:\n+    static constexpr auto name = Transform::name;\n+    String getName() const override { return name; }\n+\n+    bool isVariadic() const override { return true; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    bool hasInformationAboutMonotonicity() const override\n+    {\n+        return true;\n+    }\n+\n+    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n+    {\n+        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)\n+            return { .is_monotonic = true, .is_always_monotonic = true };\n+\n+        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };\n+        const IFunction::Monotonicity is_not_monotonic;\n+\n+        const DateLUTImpl * date_lut = &DateLUT::instance();\n+        if (const auto * timezone = dynamic_cast<const TimezoneMixin *>(&type))\n+            date_lut = &timezone->getTimeZone();\n+\n+        if (left.isNull() || right.isNull())\n+            return is_not_monotonic;\n+\n+        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.\n+\n+        if (checkAndGetDataType<DataTypeDate>(&type))\n+        {\n+            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), *date_lut)\n+                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), *date_lut)\n+                ? is_monotonic : is_not_monotonic;\n+        }\n+        else if (checkAndGetDataType<DataTypeDate32>(&type))\n+        {\n+            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), *date_lut)\n+                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), *date_lut)\n+                   ? is_monotonic : is_not_monotonic;\n+        }\n+        else\n+        {\n+            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), *date_lut)\n+                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), *date_lut)\n+                ? is_monotonic : is_not_monotonic;\n+        }\n+    }\n+\n+protected:\n+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32) const\n+    {\n+        if (arguments.size() == 1)\n+        {\n+            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n+                        + \". Should be Date, Date32, DateTime or DateTime64\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+        else if (arguments.size() == 2)\n+        {\n+            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName()\n+                        + \". Should be Date, Date32, DateTime or DateTime64\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if (!isString(arguments[1].type))\n+                throw Exception(\n+                    \"Function \" + getName() + \" supports 1 or 2 arguments. The optional 2nd argument must be \"\n+                    \"a constant string with a timezone name\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && is_result_type_date_or_date32)\n+                throw Exception(\n+                    \"The timezone argument of function \" + getName() + \" is allowed only when the 1st argument has the type DateTime or DateTime64\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+        else\n+            throw Exception(\n+                \"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(arguments.size())\n+                    + \", should be 1 or 2\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+    }\n+};\n+\n+}\ndiff --git a/src/Functions/TransformDateTime64.h b/src/Functions/TransformDateTime64.h\nindex 9ac28118b8f2..fbe7e2e82506 100644\n--- a/src/Functions/TransformDateTime64.h\n+++ b/src/Functions/TransformDateTime64.h\n@@ -87,6 +87,46 @@ class TransformDateTime64\n         return wrapped_transform.execute(t, std::forward<Args>(args)...);\n     }\n \n+\n+    template <typename ... Args>\n+    inline auto NO_SANITIZE_UNDEFINED execute_extended_result(const DateTime64 & t, Args && ... args) const\n+    {\n+        /// Type conversion from float to integer may be required.\n+        /// We are Ok with implementation specific result for out of range and denormals conversion.\n+\n+        if constexpr (TransformHasExecuteOverload_v<DateTime64, decltype(scale_multiplier), Args...>)\n+        {\n+            return wrapped_transform.execute_extended_result(t, scale_multiplier, std::forward<Args>(args)...);\n+        }\n+        else if constexpr (TransformHasExecuteOverload_v<DecimalUtils::DecimalComponents<DateTime64>, Args...>)\n+        {\n+            auto components = DecimalUtils::splitWithScaleMultiplier(t, scale_multiplier);\n+\n+            const auto result = wrapped_transform.execute_extended_result(components, std::forward<Args>(args)...);\n+            using ResultType = std::decay_t<decltype(result)>;\n+\n+            if constexpr (std::is_same_v<DecimalUtils::DecimalComponents<DateTime64>, ResultType>)\n+            {\n+                return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(result, scale_multiplier);\n+            }\n+            else\n+            {\n+                return result;\n+            }\n+        }\n+        else\n+        {\n+            const auto components = DecimalUtils::splitWithScaleMultiplier(t, scale_multiplier);\n+            return wrapped_transform.execute_extended_result(static_cast<Int64>(components.whole), std::forward<Args>(args)...);\n+        }\n+    }\n+\n+    template <typename T, typename ... Args, typename = std::enable_if_t<!std::is_same_v<T, DateTime64>>>\n+    inline auto execute_extended_result(const T & t, Args && ... args) const\n+    {\n+        return wrapped_transform.execute_extended_result(t, std::forward<Args>(args)...);\n+    }\n+\n private:\n     DateTime64::NativeType scale_multiplier = 1;\n     Transform wrapped_transform = {};\ndiff --git a/src/Functions/toCustomWeek.cpp b/src/Functions/toCustomWeek.cpp\nindex 13dc76b6389f..b773cc7df966 100644\n--- a/src/Functions/toCustomWeek.cpp\n+++ b/src/Functions/toCustomWeek.cpp\n@@ -1,6 +1,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/CustomWeekTransforms.h>\n #include <Functions/FunctionCustomWeekToSomething.h>\n+#include <Functions/FunctionCustomWeekToDateOrDate32.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/IFunction.h>\n \n@@ -9,7 +10,7 @@ namespace DB\n {\n using FunctionToWeek = FunctionCustomWeekToSomething<DataTypeUInt8, ToWeekImpl>;\n using FunctionToYearWeek = FunctionCustomWeekToSomething<DataTypeUInt32, ToYearWeekImpl>;\n-using FunctionToStartOfWeek = FunctionCustomWeekToSomething<DataTypeDate, ToStartOfWeekImpl>;\n+using FunctionToStartOfWeek = FunctionCustomWeekToDateOrDate32<ToStartOfWeekImpl>;\n \n REGISTER_FUNCTION(ToCustomWeek)\n {\ndiff --git a/src/Functions/toLastDayOfMonth.cpp b/src/Functions/toLastDayOfMonth.cpp\nindex a7faab15f9fa..9365880bfb83 100644\n--- a/src/Functions/toLastDayOfMonth.cpp\n+++ b/src/Functions/toLastDayOfMonth.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToLastDayOfMonth = FunctionDateOrDateTimeToSomething<DataTypeDate, ToLastDayOfMonthImpl>;\n+using FunctionToLastDayOfMonth = FunctionDateOrDateTimeToDateOrDate32<ToLastDayOfMonthImpl>;\n \n REGISTER_FUNCTION(ToLastDayOfMonth)\n {\ndiff --git a/src/Functions/toMonday.cpp b/src/Functions/toMonday.cpp\nindex 89145634e456..280c8a93b1a9 100644\n--- a/src/Functions/toMonday.cpp\n+++ b/src/Functions/toMonday.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToMonday = FunctionDateOrDateTimeToSomething<DataTypeDate, ToMondayImpl>;\n+using FunctionToMonday = FunctionDateOrDateTimeToDateOrDate32<ToMondayImpl>;\n \n REGISTER_FUNCTION(ToMonday)\n {\ndiff --git a/src/Functions/toStartOfISOYear.cpp b/src/Functions/toStartOfISOYear.cpp\nindex 366ba8dd09fd..245d043f0b6a 100644\n--- a/src/Functions/toStartOfISOYear.cpp\n+++ b/src/Functions/toStartOfISOYear.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToStartOfISOYear = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfISOYearImpl>;\n+using FunctionToStartOfISOYear = FunctionDateOrDateTimeToDateOrDate32<ToStartOfISOYearImpl>;\n \n REGISTER_FUNCTION(ToStartOfISOYear)\n {\ndiff --git a/src/Functions/toStartOfMonth.cpp b/src/Functions/toStartOfMonth.cpp\nindex 9674462097b0..00146e25d442 100644\n--- a/src/Functions/toStartOfMonth.cpp\n+++ b/src/Functions/toStartOfMonth.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToStartOfMonth = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfMonthImpl>;\n+using FunctionToStartOfMonth = FunctionDateOrDateTimeToDateOrDate32<ToStartOfMonthImpl>;\n \n REGISTER_FUNCTION(ToStartOfMonth)\n {\ndiff --git a/src/Functions/toStartOfQuarter.cpp b/src/Functions/toStartOfQuarter.cpp\nindex c7d697431982..74966d515843 100644\n--- a/src/Functions/toStartOfQuarter.cpp\n+++ b/src/Functions/toStartOfQuarter.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToStartOfQuarter = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfQuarterImpl>;\n+using FunctionToStartOfQuarter = FunctionDateOrDateTimeToDateOrDate32<ToStartOfQuarterImpl>;\n \n REGISTER_FUNCTION(ToStartOfQuarter)\n {\ndiff --git a/src/Functions/toStartOfYear.cpp b/src/Functions/toStartOfYear.cpp\nindex 13729f2f812e..27019bfd69f0 100644\n--- a/src/Functions/toStartOfYear.cpp\n+++ b/src/Functions/toStartOfYear.cpp\n@@ -1,12 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>\n \n \n namespace DB\n {\n \n-using FunctionToStartOfYear = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfYearImpl>;\n+using FunctionToStartOfYear = FunctionDateOrDateTimeToDateOrDate32<ToStartOfYearImpl>;\n \n REGISTER_FUNCTION(ToStartOfYear)\n {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01921_datatype_date32.reference b/tests/queries/0_stateless/01921_datatype_date32.reference\nindex a33a96ffffbc..b5bf4e06a4c6 100644\n--- a/tests/queries/0_stateless/01921_datatype_date32.reference\n+++ b/tests/queries/0_stateless/01921_datatype_date32.reference\n@@ -109,10 +109,10 @@\n -------toStartOfFifteenMinutes---------\n -------toStartOfHour---------\n -------toStartOfISOYear---------\n-2079-06-07\n-2079-06-07\n-2119-07-29\n-2119-07-29\n+1970-01-01\n+1970-01-01\n+2148-12-30\n+2148-12-30\n 2021-01-04\n -------toRelativeYearNum---------\n 1900\ndiff --git a/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.reference b/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.reference\nnew file mode 100644\nindex 000000000000..aa950215f59f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.reference\n@@ -0,0 +1,56 @@\n+toStartOfYear;toDate32;true\t1920-01-01\n+type;toStartOfYear;toDate32;true\tDate32\n+toStartOfYear;toDateTime64;true\t1920-01-01\n+type;toStartOfYear;toDateTime64;true\tDate32\n+toStartOfISOYear;toDate32;true\t1919-12-29\n+type;toStartOfISOYear;toDate32;true\tDate32\n+toStartOfISOYear;toDateTime64;true\t1919-12-29\n+type;toStartOfISOYear;toDateTime64;true\tDate32\n+toStartOfQuarter;toDate32;true\t1920-01-01\n+type;toStartOfQuarter;toDate32;true\tDate32\n+toStartOfQuarter;toDateTime64;true\t1920-01-01\n+type;toStartOfQuarter;toDateTime64;true\tDate32\n+toStartOfMonth;toDate32;true\t1920-02-01\n+type;toStartOfMonth;toDate32;true\tDate32\n+toStartOfMonth;toDateTime64;true\t1920-02-01\n+type;toStartOfMonth;toDateTime64;true\tDate32\n+toStartOfWeek;toDate32;true\t1920-02-01\n+type;toStartOfWeek;toDate32;true\tDate32\n+toStartOfWeek;toDateTime64;true\t1920-02-01\n+type;toStartOfWeek;toDateTime64;true\tDate32\n+toMonday;toDate32;true\t1920-02-02\n+type;toMonday;toDate32;true\tDate32\n+toMonday;toDateTime64;true\t1920-02-02\n+type;toMonday;toDateTime64;true\tDate32\n+toLastDayOfMonth;toDate32;true\t1920-02-29\n+type;toLastDayOfMonth;toDate32;true\tDate32\n+toLastDayOfMonth;toDateTime64;true\t1920-02-29\n+type;toLastDayOfMonth;toDateTime64;true\tDate32\n+toStartOfYear;toDate32;false\t1970-01-01\n+type;toStartOfYear;toDate32;false\tDate\n+toStartOfYear;toDateTime64;false\t1970-01-01\n+type;toStartOfYear;toDateTime64;false\tDate\n+toStartOfISOYear;toDate32;false\t1970-01-01\n+type;toStartOfISOYear;toDate32;false\tDate\n+toStartOfISOYear;toDateTime64;false\t1970-01-01\n+type;toStartOfISOYear;toDateTime64;false\tDate\n+toStartOfQuarter;toDate32;false\t1970-01-01\n+type;toStartOfQuarter;toDate32;false\tDate\n+toStartOfQuarter;toDateTime64;false\t1970-01-01\n+type;toStartOfQuarter;toDateTime64;false\tDate\n+toStartOfMonth;toDate32;false\t1970-01-01\n+type;toStartOfMonth;toDate32;false\tDate\n+toStartOfMonth;toDateTime64;false\t1970-01-01\n+type;toStartOfMonth;toDateTime64;false\tDate\n+toStartOfWeek;toDate32;false\t1970-01-01\n+type;toStartOfWeek;toDate32;false\tDate\n+toStartOfWeek;toDateTime64;false\t1970-01-01\n+type;toStartOfWeek;toDateTime64;false\tDate\n+toMonday;toDate32;false\t1970-01-01\n+type;toMonday;toDate32;false\tDate\n+toMonday;toDateTime64;false\t1970-01-01\n+type;toMonday;toDateTime64;false\tDate\n+toLastDayOfMonth;toDate32;false\t1970-01-01\n+type;toLastDayOfMonth;toDate32;false\tDate\n+toLastDayOfMonth;toDateTime64;false\t1970-01-01\n+type;toLastDayOfMonth;toDateTime64;false\tDate\ndiff --git a/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.sql.j2 b/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.sql.j2\nnew file mode 100644\nindex 000000000000..70c07c7792a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02403_enable_extended_results_for_datetime_functions.sql.j2\n@@ -0,0 +1,9 @@\n+{% for option_value in ['true', 'false'] -%}\n+{% for date_fun in ['toStartOfYear', 'toStartOfISOYear', 'toStartOfQuarter', 'toStartOfMonth', 'toStartOfWeek', 'toMonday', 'toLastDayOfMonth'] -%}\n+SELECT '{{ date_fun }};toDate32;{{ option_value }}', {{ date_fun }}(toDate32('1920-02-02')) SETTINGS enable_extended_results_for_datetime_functions = {{ option_value }};\n+SELECT 'type;{{ date_fun }};toDate32;{{ option_value }}', toTypeName({{ date_fun }}(toDate32('1920-02-02'))) SETTINGS enable_extended_results_for_datetime_functions = {{ option_value }};\n+SELECT '{{ date_fun }};toDateTime64;{{ option_value }}', {{ date_fun }}(toDateTime64('1920-02-02 10:20:30', 3)) SETTINGS enable_extended_results_for_datetime_functions = {{ option_value }};\n+SELECT 'type;{{ date_fun }};toDateTime64;{{ option_value }}', toTypeName({{ date_fun }}(toDateTime64('1920-02-02 10:20:30', 3))) SETTINGS enable_extended_results_for_datetime_functions = {{ option_value }};\n+{% endfor -%}\n+{% endfor -%}\n+\n",
  "problem_statement": "Strange toLastDayOfMonth behavior for DateTime64\nSELECT toLastDayOfMonth(toDateTime64('1950-02-02 10:20:30', 3));\r\n\r\n:) 2129-08-04\r\n\r\n\r\nSELECT version()\r\n\r\n:) 22.6.1.1978\r\n\r\nActually reproduced against  play.clickhouse.com\r\n\r\nLooking into this.\r\n\r\nDateTime32 is not affected, other date functions seem to be Ok.\n",
  "hints_text": "As far as I can see the LUT logic is fine, while\r\n```\r\nstruct ToLastDayOfMonthImpl\r\n{\r\n    static constexpr auto name = \"toLastDayOfMonth\";\r\n\r\n    static inline UInt16 execute(Int64 t, const DateLUTImpl & time_zone)\r\n    {\r\n        return time_zone.toLastDayNumOfMonth(time_zone.toDayNum(t));\r\n    }\r\n    static inline UInt16 execute(UInt32 t, const DateLUTImpl & time_zone)\r\n    {\r\n        return time_zone.toLastDayNumOfMonth(time_zone.toDayNum(t));\r\n    }\r\n    static inline UInt16 execute(Int32 d, const DateLUTImpl & time_zone)\r\n    {\r\n        return time_zone.toLastDayNumOfMonth(ExtendedDayNum(d));\r\n    }\r\n    static inline UInt16 execute(UInt16 d, const DateLUTImpl & time_zone)\r\n    {\r\n        return time_zone.toLastDayNumOfMonth(DayNum(d));\r\n    }\r\n```\r\nin DateTimeTransforms.h looks problematic.\r\nHere we try to fit Int32 into UInt16, and we do have negative numbers here for pre-1970 dates.\r\n\ntoLastDayOfMonth returns date, not number of days in a month (which might be initially intended).\nAccording to #33501 and #34394 this function initially intended to return date (not number of days). In fact it has registered alias LAST_DATE. \r\n```\r\nvoid registerFunctionToLastDayOfMonth(FunctionFactory & factory)\r\n{\r\n    factory.registerFunction<FunctionToLastDayOfMonth>();\r\n\r\n    /// MySQL compatibility alias.\r\n    factory.registerFunction<FunctionToLastDayOfMonth>(\"LAST_DAY\", FunctionFactory::CaseInsensitive);\r\n}\r\n```\r\nWhich is a standard function in Oracle and MySQL. It returns date. \nYes, sure, but the function name is toLastDay**Num**OfMonth.\nVery interesting that function:\r\n`inline Time toLastDayOfMonth(DateOrTime v) const`\r\nis defined. But it's never used in CH code (it's used only in gtest_DateLUTImpl.cpp).\r\nInstead toLastDay**Num**OfMonth function is used.\nThe code looks like there is no quick fix, it is designed in this way.\r\n\r\nIn documentation we have\r\n``\r\nThe return type toStartOf* functions described below is Date or DateTime. Though these functions can take DateTime64 as an argument, passing them a DateTime64 that is out of the normal range (years 1925 - 2283) will give an incorrect result.\r\n``\r\nHaving in mind that \r\n* DateTime starts at 1970\r\n* It is not about DateTime64, but about DateTime32 as well\r\n* It is not about toStartOf* only , but about anything any date function that returns date\r\n* It is not about out of 1925 - 2283, it is about pre-1970\r\n\r\nWe can either extend the warning or fix the issue.\r\n\r\n\r\n\r\nilejn-latitude-7490 :) SELECT toStartOfYear(toDateTime32('1930-01-01 00:00:00'));\r\n\r\nSELECT toStartOfYear(toDateTime32('1930-01-01 00:00:00'))\r\n\r\nQuery id: 9cbb8fab-7752-4228-a915-e38991ed465f\r\n\r\n\u250c\u2500toStartOfYear(toDateTime32('1930-01-01 00:00:00'))\u2500\u2510\r\n\u2502                                         1970-01-01 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.012 sec. \r\n\r\nilejn-latitude-7490 :) SELECT toStartOfYear(toDateTime64('1930-01-01 00:00:00', 3));\r\n\r\nSELECT toStartOfYear(toDateTime64('1930-01-01 00:00:00', 3))\r\n\r\nQuery id: a521ac4a-01ef-4317-a1d3-4e3be785d5cf\r\n\r\n\u250c\u2500toStartOfYear(toDateTime64('1930-01-01 00:00:00', 3))\u2500\u2510\r\n\u2502                                            2109-06-07 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.013 sec.\r\n\r\n\r\nHonestly, it looks too bad to be true. \r\nDon't I misunderstand something?\r\n\r\n\n:) SELECT toLastDayOfMonth(toDateTime64('1950-02-02 10:20:30', 3))\r\n2129-08-04\r\ntoLastDayOfMonth works exactly as conversion to Date\r\n:) SELECT toDate(toDateTime64('1950-02-28 10:20:30', 3))\r\n2129-08-04\r\nso it is not a problem of toLastDayOfMonth at all.\n1950-02-28 is -7247 (number of days from 1970-01-01)\r\ntoUInt16(-7247) is 58289\r\ntoDate(58289) is 2129-08-04\nI've created a mockup https://github.com/arenadata/ClickHouse/commit/f1064d4c88406433fbe44efd33b1ac05234e4867\r\nWorks Ok.\r\nIt brings return types deduction we have for date internal arithmetic to date functions.\r\nThe code should be cleaned up, improved, and maybe unified with FunctionDateOrDateTimeAddInterval. \r\nI think that realistically we (Arenadata) can make PR by the end of August.\nIt will require changing the function return type, which is only possible if you introduce a new setting for this behavior and cover it in the `compatibility` setting.\n> It will require changing the function return type, which is only possible if you introduce a new setting for this behavior and cover it in the `compatibility` setting.\r\n\r\nYes, correct, Date is not enough, it is going to be an incompatible change.\r\nI believe that it is worth doing anyway.\r\nAlternatively, we can introduce toLastDayOfMonth64 and suchlike, but it looks too heavy for me.\r\n\nSo, the proposal is to change the result type of Date-returning functions of DateTime64 from Date to Date32.\r\nOk, let's try to do it until it's too late :)\n@alexey-milovidov  It\u2019s about 10:00 PM in my UTC+3 timezone. I hope it\u2019s not too late :)\r\nAfter a talk with @ilejn  I want to say that I started to work in this issue.\r\n\r\nI am trying to compare pros and cons of different approaches. Do we need some kind of intelligent \u201creturn types deduction\u201c or should we simply use Date32 for return types when needed in a more simple way?\r\n \r\nWhat I see now that  some part of functions modified in https://github.com/arenadata/ClickHouse/commit/f1064d4c88406433fbe44efd33b1ac05234e4867  work in master branch. So we don\u2019t need to touch at all these functions. For example,\r\n\r\nSELECT toYear(toDateTime64('1930-01-01 00:00:00', 3));\r\n1930\r\n\r\nSELECT toYYYYMMDD(toDateTime64('1930-01-01 00:00:00', 3));\r\n19300101\r\n\r\nThese functions work fine. \r\n\r\nIt\u2019s not clear with toTime function:\r\nSELECT toTime(toDateTime64('1930-01-01 10:15:00', 3));\r\n1970-01-02 10:15:00\r\n\r\nSELECT toTime(toDateTime('1989-01-01 10:15:00', 3));\r\n1970-01-02 10:15:00\r\nIt seems like it\u2019s correct too. @den-crane  could we please comment is it OK output of toTime?\r\n\r\nIt\u2019s seems what is really needed to correct : all toStartOf and toLast functions for the case when they accept DateTime64 or Date32 as arguments. So I will make some code analysis first and then probably ask here for advice about the best approach to use. \n>It seems like it\u2019s correct too. @den-crane could we please comment is it OK output of toTime?\r\n\r\nYes, I think it's correct, at least consistent.\r\n\r\nThough it's surprising date `1970-01-02`, I never probably used this func. before.\r\n\r\n```sql\r\nClickHouse client version 20.8.17.25 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 20.8.17 revision 54438.\r\n\r\nd3005c90f081 :) SELECT toTime(now());\r\n\r\nSELECT toTime(now())\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500toTime(now())\u2500\u2510\r\n\u2502 1970-01-02 20:04:35 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nhttps://fiddle.clickhouse.com/472fd1f3-fd3b-46bd-9194-c295d8d300a1\r\n\n@ilejn yes, looks like we need to replace the Date return type to Date32 return type whenever the function takes DateTIme64,\r\nand from DateTime to DateTime64 (most likely already have done a long time ago) whenever the function takes DateTIme64.\r\n\r\nAbout `toTime` function. It normalizes the date component to some predetermined point of time and keeps the offset from midnight. 1970-01-02 has been used, because it does not underflow for all timezones.",
  "created_at": "2022-09-12T12:08:00Z"
}