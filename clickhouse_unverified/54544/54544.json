{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54544,
  "instance_id": "ClickHouse__ClickHouse-54544",
  "issue_numbers": [
    "48936"
  ],
  "base_commit": "9e1e8f4d67ae9e63b4eda046d6b47635912db408",
  "patch": "diff --git a/src/DataTypes/Utils.cpp b/src/DataTypes/Utils.cpp\nnew file mode 100644\nindex 000000000000..1c36b2dfc9d0\n--- /dev/null\n+++ b/src/DataTypes/Utils.cpp\n@@ -0,0 +1,231 @@\n+#include <DataTypes/Utils.h>\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeMap.h>\n+#include <DataTypes/DataTypeTuple.h>\n+\n+namespace DB\n+{\n+\n+bool canBeSafelyCasted(const DataTypePtr & from_type, const DataTypePtr & to_type)\n+{\n+    auto from_which_type = WhichDataType(from_type->getTypeId());\n+    bool to_type_was_nullable = isNullableOrLowCardinalityNullable(to_type);\n+    auto to_type_unwrapped = removeNullable(removeLowCardinality(to_type));\n+\n+    if (from_type->equals(*to_type_unwrapped))\n+        return true;\n+\n+    auto to_which_type = WhichDataType(to_type_unwrapped->getTypeId());\n+\n+    switch (from_which_type.idx)\n+    {\n+        case TypeIndex::UInt8:\n+        case TypeIndex::UInt16:\n+        case TypeIndex::UInt32:\n+        case TypeIndex::UInt64:\n+        case TypeIndex::UInt128:\n+        case TypeIndex::UInt256:\n+        {\n+            if (to_which_type.isUInt() &&\n+                to_type_unwrapped->getSizeOfValueInMemory() >= from_type->getSizeOfValueInMemory())\n+                return true;\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Int8:\n+        case TypeIndex::Int16:\n+        case TypeIndex::Int32:\n+        case TypeIndex::Int64:\n+        case TypeIndex::Int128:\n+        case TypeIndex::Int256:\n+        {\n+            if (to_which_type.isInt() &&\n+                to_type_unwrapped->getSizeOfValueInMemory() >= from_type->getSizeOfValueInMemory())\n+                return true;\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Float32:\n+        {\n+            if (to_which_type.isFloat64() || to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Float64:\n+        case TypeIndex::Date:\n+        case TypeIndex::Date32:\n+        case TypeIndex::DateTime:\n+        case TypeIndex::DateTime64:\n+        case TypeIndex::FixedString:\n+        case TypeIndex::Enum8:\n+        case TypeIndex::Enum16:\n+        case TypeIndex::IPv6:\n+        {\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Decimal32:\n+        case TypeIndex::Decimal64:\n+        case TypeIndex::Decimal128:\n+        case TypeIndex::Decimal256:\n+        {\n+            if (to_which_type.isDecimal())\n+            {\n+                auto from_type_decimal_precision = getDecimalPrecision(*from_type);\n+                auto to_type_decimal_precision = getDecimalPrecision(*to_type_unwrapped);\n+                if (from_type_decimal_precision > to_type_decimal_precision)\n+                    return false;\n+\n+                auto from_type_decimal_scale = getDecimalScale(*from_type);\n+                auto to_type_decimal_scale = getDecimalScale(*to_type_unwrapped);\n+                if (from_type_decimal_scale > to_type_decimal_scale)\n+                    return false;\n+\n+                return true;\n+            }\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::UUID:\n+        {\n+            if (to_which_type.isUInt128() || to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::IPv4:\n+        {\n+            if (to_which_type.isUInt32() || to_which_type.isUInt64() || to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Nullable:\n+        {\n+            if (to_type_was_nullable)\n+            {\n+                const auto & from_type_nullable = assert_cast<const DataTypeNullable &>(*from_type);\n+                return canBeSafelyCasted(from_type_nullable.getNestedType(), to_type_unwrapped);\n+            }\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::LowCardinality:\n+        {\n+            const auto & from_type_low_cardinality = assert_cast<const DataTypeLowCardinality &>(*from_type);\n+            return canBeSafelyCasted(from_type_low_cardinality.getDictionaryType(), to_type_unwrapped);\n+        }\n+        case TypeIndex::Array:\n+        {\n+            if (to_which_type.isArray())\n+            {\n+                const auto & from_type_array = assert_cast<const DataTypeArray &>(*from_type);\n+                const auto & to_type_array = assert_cast<const DataTypeArray &>(*to_type_unwrapped);\n+                return canBeSafelyCasted(from_type_array.getNestedType(), to_type_array.getNestedType());\n+            }\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Map:\n+        {\n+            if (to_which_type.isMap())\n+            {\n+                const auto & from_type_map = assert_cast<const DataTypeMap &>(*from_type);\n+                const auto & to_type_map = assert_cast<const DataTypeMap &>(*to_type_unwrapped);\n+                if (!canBeSafelyCasted(from_type_map.getKeyType(), to_type_map.getKeyType()))\n+                    return false;\n+\n+                if (!canBeSafelyCasted(from_type_map.getValueType(), to_type_map.getValueType()))\n+                    return false;\n+\n+                return true;\n+            }\n+\n+            if (to_which_type.isArray())\n+            {\n+                // Map nested type is Array(Tuple(key_type, value_type))\n+                const auto & from_type_map = assert_cast<const DataTypeMap &>(*from_type);\n+                const auto & to_type_array = assert_cast<const DataTypeArray &>(*to_type_unwrapped);\n+                const auto * to_type_nested_tuple_type = typeid_cast<const DataTypeTuple *>(to_type_array.getNestedType().get());\n+                if (!to_type_nested_tuple_type)\n+                    return false;\n+\n+                const auto & to_type_tuple_elements = to_type_nested_tuple_type->getElements();\n+                if (to_type_tuple_elements.size() != 2)\n+                    return false;\n+\n+                if (!canBeSafelyCasted(from_type_map.getKeyType(), to_type_tuple_elements[0]))\n+                    return false;\n+\n+                if (!canBeSafelyCasted(from_type_map.getValueType(), to_type_tuple_elements[1]))\n+                    return false;\n+\n+                return true;\n+            }\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::Tuple:\n+        {\n+            if (to_which_type.isTuple())\n+            {\n+                const auto & from_type_tuple = assert_cast<const DataTypeTuple &>(*from_type);\n+                const auto & to_type_tuple = assert_cast<const DataTypeTuple &>(*to_type_unwrapped);\n+\n+                const auto & from_tuple_type_elements = from_type_tuple.getElements();\n+                const auto & to_tuple_type_elements = to_type_tuple.getElements();\n+\n+                size_t lhs_type_elements_size = from_tuple_type_elements.size();\n+                if (lhs_type_elements_size != to_tuple_type_elements.size())\n+                    return false;\n+\n+                for (size_t i = 0; i < lhs_type_elements_size; ++i)\n+                    if (!canBeSafelyCasted(from_tuple_type_elements[i], to_tuple_type_elements[i]))\n+                        return false;\n+\n+                return true;\n+            }\n+\n+            if (to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n+        case TypeIndex::String:\n+        case TypeIndex::Object:\n+        case TypeIndex::Set:\n+        case TypeIndex::Interval:\n+        case TypeIndex::Function:\n+        case TypeIndex::AggregateFunction:\n+        case TypeIndex::Nothing:\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/DataTypes/Utils.h b/src/DataTypes/Utils.h\nnew file mode 100644\nindex 000000000000..bee109f45248\n--- /dev/null\n+++ b/src/DataTypes/Utils.h\n@@ -0,0 +1,19 @@\n+#pragma once\n+\n+#include <DataTypes/IDataType.h>\n+\n+namespace DB\n+{\n+\n+/** Returns true if from_type can be safely casted to to_type.\n+  *\n+  * Examples:\n+  * From type UInt8 to type UInt16 returns true.\n+  * From type UInt16 to type UInt8 returns false.\n+  * From type String to type LowCardinality(String) returns true.\n+  * From type LowCardinality(String) to type String returns true.\n+  * From type String to type UInt8 returns false.\n+  */\n+bool canBeSafelyCasted(const DataTypePtr & from_type, const DataTypePtr & to_type);\n+\n+}\ndiff --git a/src/Functions/FunctionHelpers.cpp b/src/Functions/FunctionHelpers.cpp\nindex 7a9817ad3445..6d3c20ef2ca5 100644\n--- a/src/Functions/FunctionHelpers.cpp\n+++ b/src/Functions/FunctionHelpers.cpp\n@@ -6,7 +6,6 @@\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnLowCardinality.h>\n #include <Common/assert_cast.h>\n-#include <DataTypes/DataTypeNullable.h>\n \n \n namespace DB\ndiff --git a/src/Interpreters/PreparedSets.cpp b/src/Interpreters/PreparedSets.cpp\nindex e0551dff2adb..955d8892284e 100644\n--- a/src/Interpreters/PreparedSets.cpp\n+++ b/src/Interpreters/PreparedSets.cpp\n@@ -48,7 +48,7 @@ static bool equals(const DataTypes & lhs, const DataTypes & rhs)\n \n FutureSetFromStorage::FutureSetFromStorage(SetPtr set_) : set(std::move(set_)) {}\n SetPtr FutureSetFromStorage::get() const { return set; }\n-const DataTypes & FutureSetFromStorage::getTypes() const { return set->getElementsTypes(); }\n+DataTypes FutureSetFromStorage::getTypes() const { return set->getElementsTypes(); }\n \n SetPtr FutureSetFromStorage::buildOrderedSetInplace(const ContextPtr &)\n {\n@@ -73,7 +73,7 @@ FutureSetFromTuple::FutureSetFromTuple(Block block, const Settings & settings)\n     set->finishInsert();\n }\n \n-const DataTypes & FutureSetFromTuple::getTypes() const { return set->getElementsTypes(); }\n+DataTypes FutureSetFromTuple::getTypes() const { return set->getElementsTypes(); }\n \n SetPtr FutureSetFromTuple::buildOrderedSetInplace(const ContextPtr & context)\n {\n@@ -138,7 +138,7 @@ void FutureSetFromSubquery::setQueryPlan(std::unique_ptr<QueryPlan> source_)\n     set_and_key->set->setHeader(source->getCurrentDataStream().header.getColumnsWithTypeAndName());\n }\n \n-const DataTypes & FutureSetFromSubquery::getTypes() const\n+DataTypes FutureSetFromSubquery::getTypes() const\n {\n     return set_and_key->set->getElementsTypes();\n }\n@@ -183,7 +183,10 @@ SetPtr FutureSetFromSubquery::buildOrderedSetInplace(const ContextPtr & context)\n     {\n         auto set = external_table_set->buildOrderedSetInplace(context);\n         if (set)\n-            return set_and_key->set = set;\n+        {\n+            set_and_key->set = set;\n+            return set_and_key->set;\n+        }\n     }\n \n     auto plan = build(context);\ndiff --git a/src/Interpreters/PreparedSets.h b/src/Interpreters/PreparedSets.h\nindex b953b8470e1b..e237789c63ca 100644\n--- a/src/Interpreters/PreparedSets.h\n+++ b/src/Interpreters/PreparedSets.h\n@@ -47,7 +47,7 @@ class FutureSet\n     /// Returns set if set is ready (created and filled) or nullptr if not.\n     virtual SetPtr get() const = 0;\n     /// Returns set->getElementsTypes(), even if set is not created yet.\n-    virtual const DataTypes & getTypes() const = 0;\n+    virtual DataTypes getTypes() const = 0;\n     /// If possible, return set with stored elements useful for PK analysis.\n     virtual SetPtr buildOrderedSetInplace(const ContextPtr & context) = 0;\n };\n@@ -62,7 +62,7 @@ class FutureSetFromStorage final : public FutureSet\n     FutureSetFromStorage(SetPtr set_);\n \n     SetPtr get() const override;\n-    const DataTypes & getTypes() const override;\n+    DataTypes getTypes() const override;\n     SetPtr buildOrderedSetInplace(const ContextPtr &) override;\n \n private:\n@@ -79,7 +79,7 @@ class FutureSetFromTuple final : public FutureSet\n     SetPtr get() const override { return set; }\n     SetPtr buildOrderedSetInplace(const ContextPtr & context) override;\n \n-    const DataTypes & getTypes() const override;\n+    DataTypes getTypes() const override;\n \n private:\n     SetPtr set;\n@@ -105,7 +105,7 @@ class FutureSetFromSubquery final : public FutureSet\n         const Settings & settings);\n \n     SetPtr get() const override;\n-    const DataTypes & getTypes() const override;\n+    DataTypes getTypes() const override;\n     SetPtr buildOrderedSetInplace(const ContextPtr & context) override;\n \n     std::unique_ptr<QueryPlan> build(const ContextPtr & context);\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 42731bac19b2..7abd708a944b 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -3,6 +3,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/FieldToDataType.h>\n #include <DataTypes/getLeastSupertype.h>\n+#include <DataTypes/Utils.h>\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/ExpressionActions.h>\n@@ -1253,10 +1254,18 @@ bool KeyCondition::tryPrepareSetIndex(\n \n     const auto right_arg = func.getArgumentAt(1);\n \n-    auto future_set = right_arg.tryGetPreparedSet(indexes_mapping, data_types);\n+    auto future_set = right_arg.tryGetPreparedSet();\n     if (!future_set)\n         return false;\n \n+    const auto set_types = future_set->getTypes();\n+    size_t set_types_size = set_types.size();\n+    size_t indexes_mapping_size = indexes_mapping.size();\n+\n+    for (auto & index_mapping : indexes_mapping)\n+        if (index_mapping.tuple_index >= set_types_size)\n+            return false;\n+\n     auto prepared_set = future_set->buildOrderedSetInplace(right_arg.getTreeContext().getQueryContext());\n     if (!prepared_set)\n         return false;\n@@ -1265,11 +1274,72 @@ bool KeyCondition::tryPrepareSetIndex(\n     if (!prepared_set->hasExplicitSetElements())\n         return false;\n \n-    prepared_set->checkColumnsNumber(left_args_count);\n-    for (size_t i = 0; i < indexes_mapping.size(); ++i)\n-        prepared_set->checkTypesEqual(indexes_mapping[i].tuple_index, data_types[i]);\n+    /** Try to convert set columns to primary key columns.\n+      * Example: SELECT id FROM test_table WHERE id IN (SELECT 1);\n+      * In this example table `id` column has type UInt64, Set column has type UInt8. To use index\n+      * we need to convert set column to primary key column.\n+      */\n+    auto set_columns = prepared_set->getSetElements();\n+    assert(set_types_size == set_columns.size());\n+\n+    for (size_t indexes_mapping_index = 0; indexes_mapping_index < indexes_mapping_size; ++indexes_mapping_index)\n+    {\n+        const auto & key_column_type = data_types[indexes_mapping_index];\n+        size_t set_element_index = indexes_mapping[indexes_mapping_index].tuple_index;\n+        auto set_element_type = set_types[set_element_index];\n+        auto set_column = set_columns[set_element_index];\n+\n+        if (canBeSafelyCasted(set_element_type, key_column_type))\n+        {\n+            set_columns[set_element_index] = castColumn({set_column, set_element_type, {}}, key_column_type);\n+            continue;\n+        }\n+\n+        if (!key_column_type->canBeInsideNullable())\n+            return false;\n+\n+        const NullMap * set_column_null_map = nullptr;\n+\n+        if (isNullableOrLowCardinalityNullable(set_element_type))\n+        {\n+            if (WhichDataType(set_element_type).isLowCardinality())\n+            {\n+                set_element_type = removeLowCardinality(set_element_type);\n+                set_column = set_column->convertToFullColumnIfLowCardinality();\n+            }\n+\n+            set_element_type = removeNullable(set_element_type);\n+            const auto & set_column_nullable = assert_cast<const ColumnNullable &>(*set_column);\n+            set_column_null_map = &set_column_nullable.getNullMapData();\n+            set_column = set_column_nullable.getNestedColumnPtr();\n+        }\n+\n+        auto nullable_set_column = castColumnAccurateOrNull({set_column, set_element_type, {}}, key_column_type);\n+        const auto & nullable_set_column_typed = assert_cast<const ColumnNullable &>(*nullable_set_column);\n+        const auto & nullable_set_column_null_map = nullable_set_column_typed.getNullMapData();\n+        size_t nullable_set_column_null_map_size = nullable_set_column_null_map.size();\n+\n+        IColumn::Filter filter(nullable_set_column_null_map_size);\n+\n+        if (set_column_null_map)\n+        {\n+            for (size_t i = 0; i < nullable_set_column_null_map_size; ++i)\n+                filter[i] = (*set_column_null_map)[i] || !nullable_set_column_null_map[i];\n+\n+            set_column = nullable_set_column_typed.filter(filter, 0);\n+        }\n+        else\n+        {\n+            for (size_t i = 0; i < nullable_set_column_null_map_size; ++i)\n+                filter[i] = !nullable_set_column_null_map[i];\n+\n+            set_column = nullable_set_column_typed.getNestedColumn().filter(filter, 0);\n+        }\n+\n+        set_columns[set_element_index] = std::move(set_column);\n+    }\n \n-    out.set_index = std::make_shared<MergeTreeSetIndex>(prepared_set->getSetElements(), std::move(indexes_mapping));\n+    out.set_index = std::make_shared<MergeTreeSetIndex>(set_columns, std::move(indexes_mapping));\n     return true;\n }\n \ndiff --git a/src/Storages/MergeTree/RPNBuilder.cpp b/src/Storages/MergeTree/RPNBuilder.cpp\nindex a0c96c13d59f..29bcd8b87f1a 100644\n--- a/src/Storages/MergeTree/RPNBuilder.cpp\n+++ b/src/Storages/MergeTree/RPNBuilder.cpp\n@@ -351,64 +351,6 @@ FutureSetPtr RPNBuilderTreeNode::tryGetPreparedSet(const DataTypes & data_types)\n     return nullptr;\n }\n \n-FutureSetPtr RPNBuilderTreeNode::tryGetPreparedSet(\n-    const std::vector<MergeTreeSetIndex::KeyTuplePositionMapping> & indexes_mapping,\n-    const DataTypes & data_types) const\n-{\n-    const auto & prepared_sets = getTreeContext().getPreparedSets();\n-\n-    /// We have `PreparedSetKey::forLiteral` but it is useless here as we don't have enough information\n-    /// about types in left argument of the IN operator. Instead, we manually iterate through all the sets\n-    /// and find the one for the right arg based on the AST structure (getTreeHash), after that we check\n-    /// that the types it was prepared with are compatible with the types of the primary key.\n-    auto types_match = [&indexes_mapping, &data_types](const DataTypes & set_types)\n-    {\n-        assert(indexes_mapping.size() == data_types.size());\n-\n-        for (size_t i = 0; i < indexes_mapping.size(); ++i)\n-        {\n-            if (indexes_mapping[i].tuple_index >= set_types.size())\n-                return false;\n-\n-            auto lhs = removeNullable(recursiveRemoveLowCardinality(data_types[i]));\n-            auto rhs = removeNullable(recursiveRemoveLowCardinality(set_types[indexes_mapping[i].tuple_index]));\n-\n-            if (!lhs->equals(*rhs))\n-                return false;\n-        }\n-\n-        return true;\n-    };\n-\n-    if (prepared_sets && ast_node)\n-    {\n-        if (ast_node->as<ASTSubquery>() || ast_node->as<ASTTableIdentifier>())\n-            return prepared_sets->findSubquery(ast_node->getTreeHash());\n-\n-        auto tree_hash = ast_node->getTreeHash();\n-        const auto & sets = prepared_sets->getSetsFromTuple();\n-        auto it = sets.find(tree_hash);\n-        if (it == sets.end())\n-            return nullptr;\n-\n-        for (const auto & future_set : it->second)\n-            if (types_match(future_set->getTypes()))\n-                return future_set;\n-    }\n-    else\n-    {\n-        const auto * node_without_alias = getNodeWithoutAlias(dag_node);\n-        if (node_without_alias->column)\n-        {\n-            auto future_set = tryGetSetFromDAGNode(node_without_alias);\n-            if (types_match(future_set->getTypes()))\n-                return future_set;\n-        }\n-    }\n-\n-    return nullptr;\n-}\n-\n RPNBuilderFunctionTreeNode RPNBuilderTreeNode::toFunctionNode() const\n {\n     if (!isFunction())\ndiff --git a/src/Storages/MergeTree/RPNBuilder.h b/src/Storages/MergeTree/RPNBuilder.h\nindex 9eeb6deefd5e..f14f241cac87 100644\n--- a/src/Storages/MergeTree/RPNBuilder.h\n+++ b/src/Storages/MergeTree/RPNBuilder.h\n@@ -116,11 +116,6 @@ class RPNBuilderTreeNode\n     /// Try get prepared set from node that match data types\n     FutureSetPtr tryGetPreparedSet(const DataTypes & data_types) const;\n \n-    /// Try get prepared set from node that match indexes mapping and data types\n-    FutureSetPtr tryGetPreparedSet(\n-        const std::vector<MergeTreeSetIndex::KeyTuplePositionMapping> & indexes_mapping,\n-        const DataTypes & data_types) const;\n-\n     /** Convert node to function node.\n       * Node must be function before calling these method, otherwise exception is thrown.\n       */\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.reference b/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.reference\nnew file mode 100644\nindex 000000000000..f34aad737d4e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.reference\n@@ -0,0 +1,88 @@\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Projection + Before ORDER BY))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 1-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Projection + Before ORDER BY))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 1-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Projection + Before ORDER BY))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 5-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Projection + Before ORDER BY))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 5-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Project names + Projection))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 1-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Project names + Projection))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 1-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Project names + Projection))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 5-element set))\n+        Parts: 1/1\n+        Granules: 1/1\n+CreatingSets (Create sets before main query execution)\n+  Expression ((Project names + Projection))\n+    ReadFromMergeTree (default.test_table)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          id\n+          value\n+        Condition: and((id in (-Inf, 10]), (value in 5-element set))\n+        Parts: 1/1\n+        Granules: 1/1\ndiff --git a/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.sql b/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.sql\nnew file mode 100644\nindex 000000000000..648a8041b71d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02882_primary_key_index_in_function_different_types.sql\n@@ -0,0 +1,24 @@\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table\n+(\n+    id UInt64,\n+    value UInt64\n+) ENGINE=MergeTree ORDER BY (id, value);\n+\n+INSERT INTO test_table SELECT number, number FROM numbers(10);\n+\n+SET allow_experimental_analyzer = 0;\n+\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT 5);\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT '5');\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT toUInt8(number) FROM numbers(5));\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT toString(number) FROM numbers(5));\n+\n+SET allow_experimental_analyzer = 1;\n+\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT 5);\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT '5');\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT toUInt8(number) FROM numbers(5));\n+EXPLAIN indexes = 1 SELECT id FROM test_table WHERE id <= 10 AND value IN (SELECT toString(number) FROM numbers(5));\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "Analyzer: Subquery filter not using primary key\n**Describe the unexpected behaviour**\r\n\r\nWhen using a subquery to filter a table the primary/sorting key is not being used.\r\n\r\n**How to reproduce**\r\n\r\nThis is happening in CH 23.3 but also reproduced in master:\r\n\r\n```sql\r\nSELECT version()\r\n\r\n\u250c\u2500version()\u2500\u2510\r\n\u2502 23.8.1.1  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe minimum reproducible script:\r\n\r\n```sql\r\nDROP TABLE IF EXISTS test;\r\n\r\nCREATE TABLE test.test\r\nENGINE = MergeTree\r\nORDER BY (pk1, pk2)\r\nSETTINGS index_granularity = 8\r\nAS\r\nSELECT\r\n    10 pk1,\r\n    number pk2,\r\n    'test_' || toString(number) str\r\nFROM numbers(20);\r\n\r\nEXPLAIN indexes = 1\r\nSELECT *\r\nFROM test.test\r\nWHERE pk1 <= 10 AND (pk2 IN (5))\r\nSETTINGS allow_experimental_analyzer = 1;\r\n\r\nEXPLAIN indexes = 1\r\nSELECT *\r\nFROM test.test\r\nWHERE pk1 <= 10 AND (pk2 IN (SELECT 5))\r\nSETTINGS allow_experimental_analyzer = 1;\r\n\r\nEXPLAIN indexes = 1\r\nSELECT *\r\nFROM test.test\r\nWHERE pk1 <= 10 AND (pk2 IN (SELECT number FROM numbers(5, 1)))\r\nSETTINGS allow_experimental_analyzer = 1;\r\n```\r\n\r\nWhen filtering by a subquery, the filter is not being used. See both query plans:\r\n\r\n```sql\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Expression ((Project names + Projection))                           \u2502\r\n\u2502   Expression (Change column names to column identifiers)            \u2502\r\n\u2502     ReadFromMergeTree (test.test)                                   \u2502\r\n\u2502     Indexes:                                                        \u2502\r\n\u2502       PrimaryKey                                                    \u2502\r\n\u2502         Keys:                                                       \u2502\r\n\u2502           pk1                                                       \u2502\r\n\u2502           pk2                                                       \u2502 <= pk2 being used\r\n\u2502         Condition: and((pk1 in (-Inf, 10]), (pk2 in 1-element set)) \u2502\r\n\u2502         Parts: 1/1                                                  \u2502\r\n\u2502         Granules: 1/3                                               \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CreatingSets (Create sets before main query execution)                                      \u2502\r\n\u2502   Expression ((Project names + Projection))                                                 \u2502\r\n\u2502     Expression (Change column names to column identifiers)                                  \u2502\r\n\u2502       ReadFromMergeTree (test.test)                                                         \u2502\r\n\u2502       Indexes:                                                                              \u2502\r\n\u2502         PrimaryKey                                                                          \u2502\r\n\u2502           Keys:                                                                             \u2502\r\n\u2502             pk1                                                                             \u2502 <= pk2 is gone\r\n\u2502           Condition: (pk1 in (-Inf, 10])                                                    \u2502\r\n\u2502           Parts: 1/1                                                                        \u2502\r\n\u2502           Granules: 3/3                                                                     \u2502\r\n\u2502   CreatingSet (Create set for subquery)                                                     \u2502\r\n\u2502     Expression ((Project names + (Projection + Change column names to column identifiers))) \u2502\r\n\u2502       ReadFromStorage (SystemOne)                                                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CreatingSets (Create sets before main query execution)                \u2502\r\n\u2502   Expression ((Project names + Projection))                           \u2502\r\n\u2502     Expression (Change column names to column identifiers)            \u2502\r\n\u2502       ReadFromMergeTree (test.test)                                   \u2502\r\n\u2502       Indexes:                                                        \u2502\r\n\u2502         PrimaryKey                                                    \u2502\r\n\u2502           Keys:                                                       \u2502\r\n\u2502             pk1                                                       \u2502\r\n\u2502             pk2                                                       \u2502\r\n\u2502           Condition: and((pk1 in (-Inf, 10]), (pk2 in 1-element set)) \u2502\r\n\u2502           Parts: 1/1                                                  \u2502\r\n\u2502           Granules: 1/3                                               \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI have used `SELECT 5` as subquery for simplicity reasons but this reproduces with any kind of subquery.\r\n\r\n**Expected behavior**\r\n\r\nWhen using a subquery I'd expect sorting keys to be used also. In real scenarios this is causing reading more data than expected.\n",
  "hints_text": "Cannot reproduce it on the current master.\nLooks like it was fixed between 23.5 and 23.6. Created a PR https://github.com/ClickHouse/ClickHouse/pull/52834 adding a test to prevent regressions\n@novikd while working in the PR to prevent the regression I have managed to reproduce the issue again. Updating the main message with the new reproducer.",
  "created_at": "2023-09-12T14:21:33Z"
}