{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 4707,
  "instance_id": "ClickHouse__ClickHouse-4707",
  "issue_numbers": [
    "2867"
  ],
  "base_commit": "93356b519039aac5b9b2111ecb75344cc9ae62ee",
  "patch": "diff --git a/dbms/programs/client/Client.cpp b/dbms/programs/client/Client.cpp\nindex 724bbc9eb932..22c33989d3c5 100644\n--- a/dbms/programs/client/Client.cpp\n+++ b/dbms/programs/client/Client.cpp\n@@ -973,7 +973,7 @@ class Client : public Poco::Util::Application\n         BlockInputStreamPtr block_input = context.getInputFormat(\n             current_format, buf, sample, insert_format_max_block_size);\n \n-        const auto & column_defaults = columns_description.defaults;\n+        const auto & column_defaults = columns_description.getDefaults();\n         if (!column_defaults.empty())\n             block_input = std::make_shared<AddingDefaultsBlockInputStream>(block_input, column_defaults, context);\n \ndiff --git a/dbms/programs/server/TCPHandler.cpp b/dbms/programs/server/TCPHandler.cpp\nindex e3582b9ff01f..1af2d2243bbf 100644\n--- a/dbms/programs/server/TCPHandler.cpp\n+++ b/dbms/programs/server/TCPHandler.cpp\n@@ -723,8 +723,7 @@ bool TCPHandler::receiveData()\n             if (!(storage = query_context->tryGetExternalTable(external_table_name)))\n             {\n                 NamesAndTypesList columns = block.getNamesAndTypesList();\n-                storage = StorageMemory::create(external_table_name,\n-                    ColumnsDescription{columns, NamesAndTypesList{}, NamesAndTypesList{}, ColumnDefaults{}, ColumnComments{}, ColumnCodecs{}});\n+                storage = StorageMemory::create(external_table_name, ColumnsDescription{columns});\n                 storage->startup();\n                 query_context->addExternalTable(external_table_name, storage);\n             }\ndiff --git a/dbms/programs/server/TCPHandler.h b/dbms/programs/server/TCPHandler.h\nindex 38ab27fd67b4..a2febf20a20b 100644\n--- a/dbms/programs/server/TCPHandler.h\n+++ b/dbms/programs/server/TCPHandler.h\n@@ -25,7 +25,7 @@ namespace Poco { class Logger; }\n namespace DB\n {\n \n-struct ColumnsDescription;\n+class ColumnsDescription;\n \n /// State of query processing.\n struct QueryState\ndiff --git a/dbms/src/DataStreams/InputStreamFromASTInsertQuery.cpp b/dbms/src/DataStreams/InputStreamFromASTInsertQuery.cpp\nindex dc0396480535..761767f11bae 100644\n--- a/dbms/src/DataStreams/InputStreamFromASTInsertQuery.cpp\n+++ b/dbms/src/DataStreams/InputStreamFromASTInsertQuery.cpp\n@@ -52,8 +52,12 @@ InputStreamFromASTInsertQuery::InputStreamFromASTInsertQuery(\n     res_stream = context.getInputFormat(format, *input_buffer_contacenated, header, context.getSettings().max_insert_block_size);\n \n     auto columns_description = ColumnsDescription::loadFromContext(context, ast_insert_query->database, ast_insert_query->table);\n-    if (columns_description && !columns_description->defaults.empty())\n-        res_stream = std::make_shared<AddingDefaultsBlockInputStream>(res_stream, columns_description->defaults, context);\n+    if (columns_description)\n+    {\n+        auto column_defaults = columns_description->getDefaults();\n+        if (!column_defaults.empty())\n+            res_stream = std::make_shared<AddingDefaultsBlockInputStream>(res_stream, column_defaults, context);\n+    }\n }\n \n }\ndiff --git a/dbms/src/DataTypes/NestedUtils.cpp b/dbms/src/DataTypes/NestedUtils.cpp\nindex d9a2ba2dc94f..195fd722450c 100644\n--- a/dbms/src/DataTypes/NestedUtils.cpp\n+++ b/dbms/src/DataTypes/NestedUtils.cpp\n@@ -77,51 +77,6 @@ std::string extractTableName(const std::string & nested_name)\n }\n \n \n-NamesAndTypesList flatten(const NamesAndTypesList & names_and_types)\n-{\n-    std::unordered_map<std::string, std::vector<std::string>> dummy;\n-    return flattenWithMapping(names_and_types, dummy);\n-}\n-\n-\n-NamesAndTypesList flattenWithMapping(const NamesAndTypesList & names_and_types, std::unordered_map<std::string, std::vector<std::string>> & mapping)\n-{\n-    NamesAndTypesList res;\n-\n-    for (const auto & name_type : names_and_types)\n-    {\n-        if (const DataTypeArray * type_arr = typeid_cast<const DataTypeArray *>(name_type.type.get()))\n-        {\n-            if (const DataTypeTuple * type_tuple = typeid_cast<const DataTypeTuple *>(type_arr->getNestedType().get()))\n-            {\n-                const DataTypes & elements = type_tuple->getElements();\n-                const Strings & names = type_tuple->getElementNames();\n-                size_t tuple_size = elements.size();\n-\n-                for (size_t i = 0; i < tuple_size; ++i)\n-                {\n-                    String nested_name = concatenateName(name_type.name, names[i]);\n-                    mapping[name_type.name].push_back(nested_name);\n-                    res.emplace_back(nested_name, std::make_shared<DataTypeArray>(elements[i]));\n-                }\n-            }\n-            else\n-            {\n-                mapping[name_type.name].push_back(name_type.name);\n-                res.push_back(name_type);\n-            }\n-        }\n-        else\n-        {\n-            mapping[name_type.name].push_back(name_type.name);\n-            res.push_back(name_type);\n-        }\n-    }\n-\n-    return res;\n-\n-}\n-\n Block flatten(const Block & block)\n {\n     Block res;\ndiff --git a/dbms/src/DataTypes/NestedUtils.h b/dbms/src/DataTypes/NestedUtils.h\nindex 0d1ed025281d..098d98699e44 100644\n--- a/dbms/src/DataTypes/NestedUtils.h\n+++ b/dbms/src/DataTypes/NestedUtils.h\n@@ -17,10 +17,7 @@ namespace Nested\n     std::string extractTableName(const std::string & nested_name);\n \n     /// Replace Array(Tuple(...)) columns to a multiple of Array columns in a form of `column_name.element_name`.\n-    NamesAndTypesList flatten(const NamesAndTypesList & names_and_types);\n     Block flatten(const Block & block);\n-    /// Works as normal flatten, but provide information about flattened columns\n-    NamesAndTypesList flattenWithMapping(const NamesAndTypesList & names_and_types, std::unordered_map<std::string, std::vector<std::string>> & mapping);\n \n     /// Collect Array columns in a form of `column_name.element_name` to single Array(Tuple(...)) column.\n     NamesAndTypesList collect(const NamesAndTypesList & names_and_types);\ndiff --git a/dbms/src/Interpreters/InterpreterCreateQuery.cpp b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\nindex 4e669faa5120..1a1f971777b1 100644\n--- a/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -175,165 +175,6 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n }\n \n \n-using ColumnsAndDefaults = std::pair<NamesAndTypesList, ColumnDefaults>;\n-using ColumnsDeclarationAndModifiers = std::tuple<NamesAndTypesList, ColumnDefaults, ColumnCodecs, ColumnComments>;\n-\n-/// AST to the list of columns with types. Columns of Nested type are expanded into a list of real columns.\n-static ColumnsDeclarationAndModifiers parseColumns(const ASTExpressionList & column_list_ast, const Context & context)\n-{\n-    /// list of table columns in correct order\n-    NamesAndTypesList columns{};\n-    ColumnDefaults defaults{};\n-    ColumnCodecs codecs{};\n-    ColumnComments comments{};\n-\n-    /// Columns requiring type-deduction or default_expression type-check\n-    std::vector<std::pair<NameAndTypePair *, ASTColumnDeclaration *>> defaulted_columns{};\n-\n-    /** all default_expressions as a single expression list,\n-     *  mixed with conversion-columns for each explicitly specified type */\n-    ASTPtr default_expr_list = std::make_shared<ASTExpressionList>();\n-    default_expr_list->children.reserve(column_list_ast.children.size());\n-\n-    for (const auto & ast : column_list_ast.children)\n-    {\n-        auto & col_decl = ast->as<ASTColumnDeclaration &>();\n-\n-        DataTypePtr column_type = nullptr;\n-        if (col_decl.type)\n-        {\n-            column_type = DataTypeFactory::instance().get(col_decl.type);\n-            columns.emplace_back(col_decl.name, column_type);\n-        }\n-        else\n-            /// we're creating dummy DataTypeUInt8 in order to prevent the NullPointerException in ExpressionActions\n-            columns.emplace_back(col_decl.name, std::make_shared<DataTypeUInt8>());\n-\n-        /// add column to postprocessing if there is a default_expression specified\n-        if (col_decl.default_expression)\n-        {\n-            defaulted_columns.emplace_back(&columns.back(), &col_decl);\n-\n-            /** for columns with explicitly-specified type create two expressions:\n-             *    1. default_expression aliased as column name with _tmp suffix\n-             *    2. conversion of expression (1) to explicitly-specified type alias as column name */\n-            if (col_decl.type)\n-            {\n-                const auto & final_column_name = col_decl.name;\n-                const auto tmp_column_name = final_column_name + \"_tmp\";\n-                const auto data_type_ptr = columns.back().type.get();\n-\n-                default_expr_list->children.emplace_back(setAlias(\n-                    makeASTFunction(\"CAST\", std::make_shared<ASTIdentifier>(tmp_column_name),\n-                        std::make_shared<ASTLiteral>(data_type_ptr->getName())), final_column_name));\n-                default_expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), tmp_column_name));\n-            }\n-            else\n-                default_expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), col_decl.name));\n-        }\n-\n-        if (col_decl.codec)\n-        {\n-            auto codec = CompressionCodecFactory::instance().get(col_decl.codec, column_type);\n-            codecs.emplace(col_decl.name, codec);\n-        }\n-\n-        if (col_decl.comment)\n-        {\n-            if (auto comment_str = col_decl.comment->as<ASTLiteral &>().value.get<String>(); !comment_str.empty())\n-                comments.emplace(col_decl.name, comment_str);\n-        }\n-    }\n-\n-    /// set missing types and wrap default_expression's in a conversion-function if necessary\n-    if (!defaulted_columns.empty())\n-    {\n-        auto syntax_analyzer_result = SyntaxAnalyzer(context).analyze(default_expr_list, columns);\n-        const auto actions = ExpressionAnalyzer(default_expr_list, syntax_analyzer_result, context).getActions(true);\n-        const auto block = actions->getSampleBlock();\n-\n-        for (auto action : actions->getActions())\n-            if (action.type == ExpressionAction::Type::JOIN || action.type == ExpressionAction::Type::ARRAY_JOIN)\n-                throw Exception(\"Cannot CREATE table. Unsupported default value that requires ARRAY JOIN or JOIN action\", ErrorCodes::THERE_IS_NO_DEFAULT_VALUE);\n-\n-        for (auto & column : defaulted_columns)\n-        {\n-            const auto name_and_type_ptr = column.first;\n-            const auto col_decl_ptr = column.second;\n-\n-            const auto & column_name = col_decl_ptr->name;\n-            const auto has_explicit_type = nullptr != col_decl_ptr->type;\n-            auto & explicit_type = name_and_type_ptr->type;\n-\n-            /// if column declaration contains explicit type, name_and_type_ptr->type is not null\n-            if (has_explicit_type)\n-            {\n-                const auto & tmp_column = block.getByName(column_name + \"_tmp\");\n-                const auto & deduced_type = tmp_column.type;\n-\n-                /// type mismatch between explicitly specified and deduced type, add conversion for non-array types\n-                if (!explicit_type->equals(*deduced_type))\n-                {\n-                    col_decl_ptr->default_expression = makeASTFunction(\"CAST\", col_decl_ptr->default_expression,\n-                        std::make_shared<ASTLiteral>(explicit_type->getName()));\n-\n-                    col_decl_ptr->children.clear();\n-                    col_decl_ptr->children.push_back(col_decl_ptr->type);\n-                    col_decl_ptr->children.push_back(col_decl_ptr->default_expression);\n-                }\n-            }\n-            else\n-                /// no explicit type, name_and_type_ptr->type is null, set to deduced type\n-                explicit_type = block.getByName(column_name).type;\n-\n-            defaults.emplace(column_name, ColumnDefault{\n-                columnDefaultKindFromString(col_decl_ptr->default_specifier),\n-                col_decl_ptr->default_expression\n-            });\n-        }\n-    }\n-\n-    std::unordered_map<std::string, std::vector<std::string>> mapping;\n-    auto new_columns = Nested::flattenWithMapping(columns, mapping);\n-    for (const auto & [old_name, new_names] : mapping)\n-    {\n-        auto codec_it = codecs.find(old_name);\n-        if ((new_names.size() == 1 && old_name == new_names.back()) || codec_it == codecs.end())\n-            continue;\n-\n-        auto codec = codec_it->second;\n-        codecs.erase(codec_it);\n-        for (const auto & new_name : new_names)\n-            codecs.emplace(new_name, codec);\n-    }\n-\n-    return {new_columns, defaults, codecs, comments};\n-}\n-\n-\n-static NamesAndTypesList removeAndReturnColumns(ColumnsAndDefaults & columns_declare, const ColumnDefaultKind kind)\n-{\n-    auto & columns = std::get<0>(columns_declare);\n-    auto & defaults = std::get<1>(columns_declare);\n-\n-    NamesAndTypesList removed{};\n-\n-    for (auto it = std::begin(columns); it != std::end(columns);)\n-    {\n-        const auto jt = defaults.find(it->name);\n-        if (jt != std::end(defaults) && jt->second.kind == kind)\n-        {\n-            removed.push_back(*it);\n-            it = columns.erase(it);\n-        }\n-        else\n-            ++it;\n-    }\n-\n-    return removed;\n-}\n-\n-\n ASTPtr InterpreterCreateQuery::formatColumns(const NamesAndTypesList & columns)\n {\n     auto columns_list = std::make_shared<ASTExpressionList>();\n@@ -358,7 +199,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)\n {\n     auto columns_list = std::make_shared<ASTExpressionList>();\n \n-    for (const auto & column : columns.getAll())\n+    for (const auto & column : columns)\n     {\n         const auto column_declaration = std::make_shared<ASTColumnDeclaration>();\n         ASTPtr column_declaration_ptr{column_declaration};\n@@ -371,23 +212,20 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)\n         const auto type_name_end = type_name_pos + type_name.size();\n         column_declaration->type = parseQuery(storage_p, type_name_pos, type_name_end, \"data type\", 0);\n \n-        const auto defaults_it = columns.defaults.find(column.name);\n-        if (defaults_it != std::end(columns.defaults))\n+        if (column.default_desc.expression)\n         {\n-            column_declaration->default_specifier = toString(defaults_it->second.kind);\n-            column_declaration->default_expression = defaults_it->second.expression->clone();\n+            column_declaration->default_specifier = toString(column.default_desc.kind);\n+            column_declaration->default_expression = column.default_desc.expression->clone();\n         }\n \n-        const auto comments_it = columns.comments.find(column.name);\n-        if (comments_it != std::end(columns.comments))\n+        if (!column.comment.empty())\n         {\n-            column_declaration->comment = std::make_shared<ASTLiteral>(Field(comments_it->second));\n+            column_declaration->comment = std::make_shared<ASTLiteral>(Field(column.comment));\n         }\n \n-        const auto ct = columns.codecs.find(column.name);\n-        if (ct != std::end(columns.codecs))\n+        if (column.codec)\n         {\n-            String codec_desc = ct->second->getCodecDesc();\n+            String codec_desc = column.codec->getCodecDesc();\n             codec_desc = \"CODEC(\" + codec_desc + \")\";\n             auto codec_desc_pos = codec_desc.data();\n             const auto codec_desc_end = codec_desc_pos + codec_desc.size();\n@@ -411,20 +249,110 @@ ASTPtr InterpreterCreateQuery::formatIndices(const IndicesDescription & indices)\n     return res;\n }\n \n-ColumnsDescription InterpreterCreateQuery::getColumnsDescription(const ASTExpressionList & columns, const Context & context)\n+ColumnsDescription InterpreterCreateQuery::getColumnsDescription(const ASTExpressionList & columns_ast, const Context & context)\n {\n+    /// First, deduce implicit types.\n+\n+    /** all default_expressions as a single expression list,\n+     *  mixed with conversion-columns for each explicitly specified type */\n+    ASTPtr default_expr_list = std::make_shared<ASTExpressionList>();\n+    NamesAndTypesList column_names_and_types;\n+\n+    for (const auto & ast : columns_ast.children)\n+    {\n+        const auto & col_decl = ast->as<ASTColumnDeclaration &>();\n+\n+        DataTypePtr column_type = nullptr;\n+        if (col_decl.type)\n+        {\n+            column_type = DataTypeFactory::instance().get(col_decl.type);\n+            column_names_and_types.emplace_back(col_decl.name, column_type);\n+        }\n+        else\n+        {\n+            /// we're creating dummy DataTypeUInt8 in order to prevent the NullPointerException in ExpressionActions\n+            column_names_and_types.emplace_back(col_decl.name, std::make_shared<DataTypeUInt8>());\n+        }\n+\n+        /// add column to postprocessing if there is a default_expression specified\n+        if (col_decl.default_expression)\n+        {\n+            /** for columns with explicitly-specified type create two expressions:\n+             *    1. default_expression aliased as column name with _tmp suffix\n+             *    2. conversion of expression (1) to explicitly-specified type alias as column name */\n+            if (col_decl.type)\n+            {\n+                const auto & final_column_name = col_decl.name;\n+                const auto tmp_column_name = final_column_name + \"_tmp\";\n+                const auto data_type_ptr = column_names_and_types.back().type.get();\n+\n+                default_expr_list->children.emplace_back(setAlias(\n+                    makeASTFunction(\"CAST\", std::make_shared<ASTIdentifier>(tmp_column_name),\n+                        std::make_shared<ASTLiteral>(data_type_ptr->getName())), final_column_name));\n+                default_expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), tmp_column_name));\n+            }\n+            else\n+                default_expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), col_decl.name));\n+        }\n+    }\n+\n+    Block defaults_sample_block;\n+    /// set missing types and wrap default_expression's in a conversion-function if necessary\n+    if (!default_expr_list->children.empty())\n+    {\n+        auto syntax_analyzer_result = SyntaxAnalyzer(context).analyze(default_expr_list, column_names_and_types);\n+        const auto actions = ExpressionAnalyzer(default_expr_list, syntax_analyzer_result, context).getActions(true);\n+        for (auto action : actions->getActions())\n+            if (action.type == ExpressionAction::Type::JOIN || action.type == ExpressionAction::Type::ARRAY_JOIN)\n+                throw Exception(\"Cannot CREATE table. Unsupported default value that requires ARRAY JOIN or JOIN action\", ErrorCodes::THERE_IS_NO_DEFAULT_VALUE);\n+\n+        defaults_sample_block = actions->getSampleBlock();\n+    }\n+\n     ColumnsDescription res;\n+    auto name_type_it = column_names_and_types.begin();\n+    for (auto ast_it = columns_ast.children.begin(); ast_it != columns_ast.children.end(); ++ast_it, ++name_type_it)\n+    {\n+        ColumnDescription column;\n+\n+        auto & col_decl = (*ast_it)->as<ASTColumnDeclaration &>();\n+\n+        column.name = col_decl.name;\n+\n+        if (col_decl.default_expression)\n+        {\n+            ASTPtr default_expr = col_decl.default_expression->clone();\n+            if (col_decl.type)\n+            {\n+                const auto & deduced_type = defaults_sample_block.getByName(column.name + \"_tmp\").type;\n+                column.type = name_type_it->type;\n+\n+                if (!column.type->equals(*deduced_type))\n+                    default_expr = makeASTFunction(\"CAST\", default_expr, std::make_shared<ASTLiteral>(column.type->getName()));\n+            }\n+            else\n+                column.type = defaults_sample_block.getByName(column.name).type;\n+\n+            column.default_desc.kind = columnDefaultKindFromString(col_decl.default_specifier);\n+            column.default_desc.expression = default_expr;\n+        }\n+        else if (col_decl.type)\n+            column.type = name_type_it->type;\n+        else\n+            throw Exception();\n+\n+        if (col_decl.comment)\n+            column.comment = col_decl.comment->as<ASTLiteral &>().value.get<String>();\n+\n+        if (col_decl.codec)\n+            column.codec = CompressionCodecFactory::instance().get(col_decl.codec, column.type);\n+\n+        res.add(std::move(column));\n+    }\n \n-    auto && parsed_columns = parseColumns(columns, context);\n-    auto columns_and_defaults = std::make_pair(std::move(std::get<0>(parsed_columns)), std::move(std::get<1>(parsed_columns)));\n-    res.aliases = removeAndReturnColumns(columns_and_defaults, ColumnDefaultKind::Alias);\n-    res.materialized = removeAndReturnColumns(columns_and_defaults, ColumnDefaultKind::Materialized);\n-    res.ordinary = std::move(columns_and_defaults.first);\n-    res.defaults = std::move(columns_and_defaults.second);\n-    res.codecs = std::move(std::get<2>(parsed_columns));\n-    res.comments = std::move(std::get<3>(parsed_columns));\n+    res.flattenNested();\n \n-    if (res.ordinary.size() + res.materialized.size() == 0)\n+    if (res.getAllPhysical().empty())\n         throw Exception{\"Cannot CREATE table without physical columns\", ErrorCodes::EMPTY_LIST_OF_COLUMNS_PASSED};\n \n     return res;\n@@ -434,33 +362,32 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(const ASTExpres\n ColumnsDescription InterpreterCreateQuery::setColumns(\n     ASTCreateQuery & create, const Block & as_select_sample, const StoragePtr & as_storage) const\n {\n-    ColumnsDescription res;\n+    ColumnsDescription columns;\n     IndicesDescription indices;\n \n     if (create.columns_list)\n     {\n         if (create.columns_list->columns)\n-            res = getColumnsDescription(*create.columns_list->columns, context);\n+            columns = getColumnsDescription(*create.columns_list->columns, context);\n         if (create.columns_list->indices)\n             for (const auto & index : create.columns_list->indices->children)\n                 indices.indices.push_back(\n-                        std::dynamic_pointer_cast<ASTIndexDeclaration>(index->clone()));\n+                    std::dynamic_pointer_cast<ASTIndexDeclaration>(index->clone()));\n     }\n     else if (!create.as_table.empty())\n     {\n-        res = as_storage->getColumns();\n+        columns = as_storage->getColumns();\n         indices = as_storage->getIndicesDescription();\n     }\n     else if (create.select)\n     {\n-        for (size_t i = 0; i < as_select_sample.columns(); ++i)\n-            res.ordinary.emplace_back(as_select_sample.safeGetByPosition(i).name, as_select_sample.safeGetByPosition(i).type);\n+        columns = ColumnsDescription(as_select_sample.getNamesAndTypesList());\n     }\n     else\n         throw Exception(\"Incorrect CREATE query: required list of column descriptions or AS section or SELECT.\", ErrorCodes::INCORRECT_QUERY);\n \n     /// Even if query has list of columns, canonicalize it (unfold Nested columns).\n-    ASTPtr new_columns = formatColumns(res);\n+    ASTPtr new_columns = formatColumns(columns);\n     ASTPtr new_indices = formatIndices(indices);\n \n     if (!create.columns_list)\n@@ -481,20 +408,13 @@ ColumnsDescription InterpreterCreateQuery::setColumns(\n \n     /// Check for duplicates\n     std::set<String> all_columns;\n-    auto check_column_already_exists = [&all_columns](const NameAndTypePair & column_name_and_type)\n+    for (const auto & column : columns)\n     {\n-        if (!all_columns.emplace(column_name_and_type.name).second)\n-            throw Exception(\"Column \" + backQuoteIfNeed(column_name_and_type.name) + \" already exists\", ErrorCodes::DUPLICATE_COLUMN);\n-    };\n-\n-    for (const auto & elem : res.ordinary)\n-        check_column_already_exists(elem);\n-    for (const auto & elem : res.materialized)\n-        check_column_already_exists(elem);\n-    for (const auto & elem : res.aliases)\n-        check_column_already_exists(elem);\n+        if (!all_columns.emplace(column.name).second)\n+            throw Exception(\"Column \" + backQuoteIfNeed(column.name) + \" already exists\", ErrorCodes::DUPLICATE_COLUMN);\n+    }\n \n-    return res;\n+    return columns;\n }\n \n \ndiff --git a/dbms/src/Interpreters/InterpreterDescribeQuery.cpp b/dbms/src/Interpreters/InterpreterDescribeQuery.cpp\nindex f91fb1c0a2ae..62dee79c17b4 100644\n--- a/dbms/src/Interpreters/InterpreterDescribeQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterDescribeQuery.cpp\n@@ -58,46 +58,39 @@ Block InterpreterDescribeQuery::getSampleBlock()\n \n BlockInputStreamPtr InterpreterDescribeQuery::executeImpl()\n {\n-    const auto & ast = query_ptr->as<ASTDescribeQuery &>();\n-\n-    NamesAndTypesList columns;\n-    ColumnDefaults column_defaults;\n-    ColumnComments column_comments;\n-    ColumnCodecs column_codecs;\n-    StoragePtr table;\n-\n-    const auto * table_expression = ast.table_expression->as<ASTTableExpression>();\n+    ColumnsDescription columns;\n \n-    if (table_expression->subquery)\n+    const auto & ast = query_ptr->as<ASTDescribeQuery &>();\n+    const auto & table_expression = ast.table_expression->as<ASTTableExpression &>();\n+    if (table_expression.subquery)\n     {\n-        columns = InterpreterSelectWithUnionQuery::getSampleBlock(table_expression->subquery->children[0], context).getNamesAndTypesList();\n+        auto names_and_types = InterpreterSelectWithUnionQuery::getSampleBlock(\n+            table_expression.subquery->children.at(0), context).getNamesAndTypesList();\n+        columns = ColumnsDescription(std::move(names_and_types));\n     }\n     else\n     {\n-        if (table_expression->table_function)\n+        StoragePtr table;\n+        if (table_expression.table_function)\n         {\n-            const auto * table_function = table_expression->table_function->as<ASTFunction>();\n-            /// Get the table function\n-            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_function->name, context);\n-            /// Run it and remember the result\n-            table = table_function_ptr->execute(table_expression->table_function, context);\n+            const auto & table_function = table_expression.table_function->as<ASTFunction &>();\n+            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_function.name, context);\n+            /// Run the table function and remember the result\n+            table = table_function_ptr->execute(table_expression.table_function, context);\n         }\n         else\n         {\n-            const auto * identifier = table_expression->database_and_table_name->as<ASTIdentifier>();\n+            const auto & identifier = table_expression.database_and_table_name->as<ASTIdentifier &>();\n \n             String database_name;\n             String table_name;\n-            std::tie(database_name, table_name) = IdentifierSemantic::extractDatabaseAndTable(*identifier);\n+            std::tie(database_name, table_name) = IdentifierSemantic::extractDatabaseAndTable(identifier);\n \n             table = context.getTable(database_name, table_name);\n         }\n \n         auto table_lock = table->lockStructureForShare(false, context.getCurrentQueryId());\n-        columns = table->getColumns().getAll();\n-        column_defaults = table->getColumns().defaults;\n-        column_comments = table->getColumns().comments;\n-        column_codecs = table->getColumns().codecs;\n+        columns = table->getColumns();\n     }\n \n     Block sample_block = getSampleBlock();\n@@ -108,37 +101,23 @@ BlockInputStreamPtr InterpreterDescribeQuery::executeImpl()\n         res_columns[0]->insert(column.name);\n         res_columns[1]->insert(column.type->getName());\n \n-        const auto defaults_it = column_defaults.find(column.name);\n-        if (defaults_it == std::end(column_defaults))\n+        if (column.default_desc.expression)\n         {\n-            res_columns[2]->insertDefault();\n-            res_columns[3]->insertDefault();\n+            res_columns[2]->insert(toString(column.default_desc.kind));\n+            res_columns[3]->insert(queryToString(column.default_desc.expression));\n         }\n         else\n         {\n-            res_columns[2]->insert(toString(defaults_it->second.kind));\n-            res_columns[3]->insert(queryToString(defaults_it->second.expression));\n+            res_columns[2]->insertDefault();\n+            res_columns[3]->insertDefault();\n         }\n \n-        const auto comments_it = column_comments.find(column.name);\n-        if (comments_it == std::end(column_comments))\n-        {\n-            res_columns[4]->insertDefault();\n-        }\n-        else\n-        {\n-            res_columns[4]->insert(comments_it->second);\n-        }\n+        res_columns[4]->insert(column.comment);\n \n-        const auto codecs_it = column_codecs.find(column.name);\n-        if (codecs_it == std::end(column_codecs))\n-        {\n-            res_columns[5]->insertDefault();\n-        }\n+        if (column.codec)\n+            res_columns[5]->insert(column.codec->getCodecDesc());\n         else\n-        {\n-            res_columns[5]->insert(codecs_it->second->getCodecDesc());\n-        }\n+            res_columns[5]->insertDefault();\n     }\n \n     return std::make_shared<OneBlockInputStream>(sample_block.cloneWithColumns(std::move(res_columns)));\ndiff --git a/dbms/src/Interpreters/InterpreterInsertQuery.cpp b/dbms/src/Interpreters/InterpreterInsertQuery.cpp\nindex d5b67e5518ae..444e41632fdf 100644\n--- a/dbms/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -115,7 +115,7 @@ BlockIO InterpreterInsertQuery::execute()\n     /// Actually we don't know structure of input blocks from query/table,\n     /// because some clients break insertion protocol (columns != header)\n     out = std::make_shared<AddingDefaultBlockOutputStream>(\n-        out, query_sample_block, table->getSampleBlock(), table->getColumns().defaults, context);\n+        out, query_sample_block, table->getSampleBlock(), table->getColumns().getDefaults(), context);\n \n     auto out_wrapper = std::make_shared<CountingBlockOutputStream>(out);\n     out_wrapper->setProcessListElement(context.getProcessListElement());\n@@ -140,9 +140,9 @@ BlockIO InterpreterInsertQuery::execute()\n         if (!allow_materialized)\n         {\n             Block in_header = res.in->getHeader();\n-            for (const auto & name_type : table->getColumns().materialized)\n-                if (in_header.has(name_type.name))\n-                    throw Exception(\"Cannot insert column \" + name_type.name + \", because it is MATERIALIZED column.\", ErrorCodes::ILLEGAL_COLUMN);\n+            for (const auto & column : table->getColumns())\n+                if (column.default_desc.kind == ColumnDefaultKind::Materialized && in_header.has(column.name))\n+                    throw Exception(\"Cannot insert column \" + column.name + \", because it is MATERIALIZED column.\", ErrorCodes::ILLEGAL_COLUMN);\n         }\n     }\n     else if (query.data && !query.has_tail) /// can execute without additional data\ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\nindex 2913e36f5486..0dfddc10dea0 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -808,13 +808,13 @@ void InterpreterSelectQuery::executeFetchColumns(\n     /// Are ALIAS columns required for query execution?\n     auto alias_columns_required = false;\n \n-    if (storage && !storage->getColumns().aliases.empty())\n+    if (storage)\n     {\n-        const auto & column_defaults = storage->getColumns().defaults;\n-        for (const auto & column : required_columns)\n+        const ColumnsDescription & storage_columns = storage->getColumns();\n+        for (const auto & column_name : required_columns)\n         {\n-            const auto default_it = column_defaults.find(column);\n-            if (default_it != std::end(column_defaults) && default_it->second.kind == ColumnDefaultKind::Alias)\n+            auto column_default = storage_columns.getDefault(column_name);\n+            if (column_default && column_default->kind == ColumnDefaultKind::Alias)\n             {\n                 alias_columns_required = true;\n                 break;\n@@ -843,10 +843,10 @@ void InterpreterSelectQuery::executeFetchColumns(\n             for (const auto & column : required_columns)\n             {\n                 ASTPtr column_expr;\n-                const auto default_it = column_defaults.find(column);\n-                bool is_alias = default_it != std::end(column_defaults) && default_it->second.kind == ColumnDefaultKind::Alias;\n+                const auto column_default = storage_columns.getDefault(column);\n+                bool is_alias = column_default && column_default->kind == ColumnDefaultKind::Alias;\n                 if (is_alias)\n-                    column_expr = setAlias(default_it->second.expression->clone(), column);\n+                    column_expr = setAlias(column_default->expression->clone(), column);\n                 else\n                     column_expr = std::make_shared<ASTIdentifier>(column);\n \ndiff --git a/dbms/src/Interpreters/MutationsInterpreter.cpp b/dbms/src/Interpreters/MutationsInterpreter.cpp\nindex fc3ebe2f76e1..e9f9310f32fe 100644\n--- a/dbms/src/Interpreters/MutationsInterpreter.cpp\n+++ b/dbms/src/Interpreters/MutationsInterpreter.cpp\n@@ -126,7 +126,7 @@ static void validateUpdateColumns(\n     for (const String & column_name : updated_columns)\n     {\n         auto found = false;\n-        for (const auto & col : storage->getColumns().ordinary)\n+        for (const auto & col : storage->getColumns().getOrdinary())\n         {\n             if (col.name == column_name)\n             {\n@@ -137,7 +137,7 @@ static void validateUpdateColumns(\n \n         if (!found)\n         {\n-            for (const auto & col : storage->getColumns().materialized)\n+            for (const auto & col : storage->getColumns().getMaterialized())\n             {\n                 if (col.name == column_name)\n                     throw Exception(\"Cannot UPDATE materialized column `\" + column_name + \"`\", ErrorCodes::CANNOT_UPDATE_COLUMN);\n@@ -187,19 +187,17 @@ void MutationsInterpreter::prepare(bool dry_run)\n     std::unordered_map<String, Names> column_to_affected_materialized;\n     if (!updated_columns.empty())\n     {\n-        for (const auto & kv : columns_desc.defaults)\n+        for (const auto & column : columns_desc)\n         {\n-            const String & column = kv.first;\n-            const ColumnDefault & col_default = kv.second;\n-            if (col_default.kind == ColumnDefaultKind::Materialized)\n+            if (column.default_desc.kind == ColumnDefaultKind::Materialized)\n             {\n-                auto query = col_default.expression->clone();\n+                auto query = column.default_desc.expression->clone();\n                 auto syntax_result = SyntaxAnalyzer(context).analyze(query, all_columns);\n                 ExpressionAnalyzer analyzer(query, syntax_result, context);\n                 for (const String & dependency : analyzer.getRequiredSourceColumns())\n                 {\n                     if (updated_columns.count(dependency))\n-                        column_to_affected_materialized[dependency].push_back(column);\n+                        column_to_affected_materialized[dependency].push_back(column.name);\n                 }\n             }\n         }\n@@ -250,11 +248,14 @@ void MutationsInterpreter::prepare(bool dry_run)\n             if (!affected_materialized.empty())\n             {\n                 stages.emplace_back(context);\n-                for (const auto & column : columns_desc.materialized)\n+                for (const auto & column : columns_desc)\n                 {\n-                    stages.back().column_to_updated.emplace(\n-                        column.name,\n-                        columns_desc.defaults.at(column.name).expression->clone());\n+                    if (column.default_desc.kind == ColumnDefaultKind::Materialized)\n+                    {\n+                        stages.back().column_to_updated.emplace(\n+                            column.name,\n+                            column.default_desc.expression->clone());\n+                    }\n                 }\n             }\n         }\ndiff --git a/dbms/src/Interpreters/SyntaxAnalyzer.cpp b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\nindex aab7bd3d4c29..34bec70223fb 100644\n--- a/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -75,7 +75,7 @@ void collectSourceColumns(const ASTSelectQuery * select_query, StoragePtr storag\n \n         if (select_query)\n         {\n-            const auto & storage_aliases = storage->getColumns().aliases;\n+            const auto & storage_aliases = storage->getColumns().getAliases();\n             source_columns.insert(source_columns.end(), storage_aliases.begin(), storage_aliases.end());\n         }\n     }\n@@ -659,7 +659,7 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(\n         }\n \n         translateQualifiedNames(query, *select_query, context,\n-                                (storage ? storage->getColumns().ordinary.getNames() : source_columns_list), source_columns_set,\n+                                (storage ? storage->getColumns().getOrdinary().getNames() : source_columns_list), source_columns_set,\n                                 result.analyzed_join.columns_from_joined_table);\n \n         /// Depending on the user's profile, check for the execution rights\ndiff --git a/dbms/src/Interpreters/interpretSubquery.cpp b/dbms/src/Interpreters/interpretSubquery.cpp\nindex d46217695f97..4f5b2c1c9394 100644\n--- a/dbms/src/Interpreters/interpretSubquery.cpp\n+++ b/dbms/src/Interpreters/interpretSubquery.cpp\n@@ -64,14 +64,14 @@ std::shared_ptr<InterpreterSelectWithUnionQuery> interpretSubquery(\n         {\n             auto query_context = const_cast<Context *>(&context.getQueryContext());\n             const auto & storage = query_context->executeTableFunction(table_expression);\n-            columns = storage->getColumns().ordinary;\n+            columns = storage->getColumns().getOrdinary();\n             select_query->addTableFunction(*const_cast<ASTPtr *>(&table_expression)); // XXX: const_cast should be avoided!\n         }\n         else\n         {\n             DatabaseAndTableWithAlias database_table(*table);\n             const auto & storage = context.getTable(database_table.database, database_table.table);\n-            columns = storage->getColumns().ordinary;\n+            columns = storage->getColumns().getOrdinary();\n             select_query->replaceDatabaseAndTable(database_table.database, database_table.table);\n         }\n \ndiff --git a/dbms/src/Parsers/ASTColumnDeclaration.h b/dbms/src/Parsers/ASTColumnDeclaration.h\nindex b24b9935dbe1..ad4af54d146d 100644\n--- a/dbms/src/Parsers/ASTColumnDeclaration.h\n+++ b/dbms/src/Parsers/ASTColumnDeclaration.h\n@@ -70,17 +70,17 @@ class ASTColumnDeclaration : public IAST\n             default_expression->formatImpl(settings, state, frame);\n         }\n \n-        if (codec)\n-        {\n-            settings.ostr << ' ';\n-            codec->formatImpl(settings, state, frame);\n-        }\n-\n         if (comment)\n         {\n             settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"COMMENT\" << (settings.hilite ? hilite_none : \"\") << ' ';\n             comment->formatImpl(settings, state, frame);\n         }\n+\n+        if (codec)\n+        {\n+            settings.ostr << ' ';\n+            codec->formatImpl(settings, state, frame);\n+        }\n     }\n };\n \ndiff --git a/dbms/src/Storages/AlterCommands.cpp b/dbms/src/Storages/AlterCommands.cpp\nindex 27126b7bcdf7..96705c3ab395 100644\n--- a/dbms/src/Storages/AlterCommands.cpp\n+++ b/dbms/src/Storages/AlterCommands.cpp\n@@ -52,6 +52,12 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n             command.default_expression = ast_col_decl.default_expression;\n         }\n \n+        if (ast_col_decl.comment)\n+        {\n+            const auto & ast_comment = typeid_cast<ASTLiteral &>(*ast_col_decl.comment);\n+            command.comment = ast_comment.value.get<String>();\n+        }\n+\n         if (ast_col_decl.codec)\n             command.codec = compression_codec_factory.get(ast_col_decl.codec);\n \n@@ -92,14 +98,15 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n             command.default_expression = ast_col_decl.default_expression;\n         }\n \n-        if (ast_col_decl.codec)\n-            command.codec = compression_codec_factory.get(ast_col_decl.codec);\n-\n         if (ast_col_decl.comment)\n         {\n             const auto & ast_comment = ast_col_decl.comment->as<ASTLiteral &>();\n             command.comment = ast_comment.value.get<String>();\n         }\n+\n+        if (ast_col_decl.codec)\n+            command.codec = compression_codec_factory.get(ast_col_decl.codec);\n+\n         command.if_exists = command_ast->if_exists;\n \n         return command;\n@@ -155,163 +162,46 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n }\n \n \n-/// the names are the same if they match the whole name or name_without_dot matches the part of the name up to the dot\n-static bool namesEqual(const String & name_without_dot, const DB::NameAndTypePair & name_type)\n-{\n-    String name_with_dot = name_without_dot + \".\";\n-    return (name_with_dot == name_type.name.substr(0, name_without_dot.length() + 1) || name_without_dot == name_type.name);\n-}\n-\n void AlterCommand::apply(ColumnsDescription & columns_description, IndicesDescription & indices_description,\n         ASTPtr & order_by_ast, ASTPtr & primary_key_ast) const\n {\n     if (type == ADD_COLUMN)\n     {\n-        if (columns_description.getAll().contains(column_name))\n-            throw Exception{\"Cannot add column \" + column_name + \": column with this name already exists\", ErrorCodes::ILLEGAL_COLUMN};\n-\n-        const auto add_column = [this] (NamesAndTypesList & columns)\n-        {\n-            auto insert_it = columns.end();\n-\n-            if (!after_column.empty())\n-            {\n-                /// We are trying to find first column from end with name `column_name` or with a name beginning with `column_name` and \".\".\n-                /// For example \"fruits.bananas\"\n-                /// names are considered the same if they completely match or `name_without_dot` matches the part of the name to the point\n-                const auto reverse_insert_it = std::find_if(columns.rbegin(), columns.rend(),\n-                    std::bind(namesEqual, std::cref(after_column), std::placeholders::_1));\n-\n-                if (reverse_insert_it == columns.rend())\n-                    throw Exception(\"Wrong column name. Cannot find column \" + after_column + \" to insert after\",\n-                                    ErrorCodes::ILLEGAL_COLUMN);\n-                else\n-                {\n-                    /// base returns an iterator that is already offset by one element to the right\n-                    insert_it = reverse_insert_it.base();\n-                }\n-            }\n-\n-            columns.emplace(insert_it, column_name, data_type);\n-        };\n-\n-        if (default_kind == ColumnDefaultKind::Default)\n-            add_column(columns_description.ordinary);\n-        else if (default_kind == ColumnDefaultKind::Materialized)\n-            add_column(columns_description.materialized);\n-        else if (default_kind == ColumnDefaultKind::Alias)\n-            add_column(columns_description.aliases);\n-        else\n-            throw Exception{\"Unknown ColumnDefaultKind value\", ErrorCodes::LOGICAL_ERROR};\n-\n+        ColumnDescription column(column_name, data_type);\n         if (default_expression)\n-            columns_description.defaults.emplace(column_name, ColumnDefault{default_kind, default_expression});\n+        {\n+            column.default_desc.kind = default_kind;\n+            column.default_desc.expression = default_expression;\n+        }\n+        column.comment = comment;\n+        column.codec = codec;\n \n-        if (codec)\n-            columns_description.codecs.emplace(column_name, codec);\n+        columns_description.add(column, after_column);\n \n         /// Slow, because each time a list is copied\n-        columns_description.ordinary = Nested::flatten(columns_description.ordinary);\n+        columns_description.flattenNested();\n     }\n     else if (type == DROP_COLUMN)\n     {\n-        /// look for a column in list and remove it if present, also removing corresponding entry from column_defaults\n-        const auto remove_column = [&columns_description, this] (NamesAndTypesList & columns)\n-        {\n-            auto removed = false;\n-            NamesAndTypesList::iterator column_it;\n-\n-            while (columns.end() != (column_it = std::find_if(columns.begin(), columns.end(),\n-                std::bind(namesEqual, std::cref(column_name), std::placeholders::_1))))\n-            {\n-                removed = true;\n-                column_it = columns.erase(column_it);\n-                columns_description.defaults.erase(column_name);\n-            }\n-\n-            return removed;\n-        };\n-\n-        if (!remove_column(columns_description.ordinary) &&\n-            !remove_column(columns_description.materialized) &&\n-            !remove_column(columns_description.aliases))\n-        {\n-            throw Exception(\"Wrong column name. Cannot find column \" + column_name + \" to drop\",\n-                            ErrorCodes::ILLEGAL_COLUMN);\n-        }\n+        columns_description.remove(column_name);\n     }\n     else if (type == MODIFY_COLUMN)\n     {\n+        ColumnDescription & column = columns_description.get(column_name);\n+\n         if (codec)\n-            columns_description.codecs[column_name] = codec;\n+            column.codec = codec;\n \n         if (!is_mutable())\n         {\n-            auto & comments = columns_description.comments;\n-            if (comment.empty())\n-            {\n-                if (auto it = comments.find(column_name); it != comments.end())\n-                    comments.erase(it);\n-            }\n-            else\n-                columns_description.comments[column_name] = comment;\n-\n+            column.comment = comment;\n             return;\n         }\n \n-        const auto default_it = columns_description.defaults.find(column_name);\n-        const auto had_default_expr = default_it != std::end(columns_description.defaults);\n-        const auto old_default_kind = had_default_expr ? default_it->second.kind : ColumnDefaultKind{};\n-\n-        /// target column list\n-        auto & new_columns =\n-            default_kind == ColumnDefaultKind::Default ? columns_description.ordinary\n-            : default_kind == ColumnDefaultKind::Materialized ? columns_description.materialized\n-            : columns_description.aliases;\n-\n-        /// find column or throw exception\n-        const auto find_column = [this] (NamesAndTypesList & columns)\n-        {\n-            const auto it = std::find_if(columns.begin(), columns.end(),\n-                std::bind(namesEqual, std::cref(column_name), std::placeholders::_1));\n-            if (it == columns.end())\n-                throw Exception(\"Wrong column name. Cannot find column \" + column_name + \" to modify\",\n-                                ErrorCodes::ILLEGAL_COLUMN);\n-\n-            return it;\n-        };\n-\n-        /// if default types differ, remove column from the old list, then add to the new list\n-        if (default_kind != old_default_kind)\n-        {\n-            /// source column list\n-            auto & old_columns =\n-                old_default_kind == ColumnDefaultKind::Default ? columns_description.ordinary\n-                : old_default_kind == ColumnDefaultKind::Materialized ? columns_description.materialized\n-                : columns_description.aliases;\n-\n-            const auto old_column_it = find_column(old_columns);\n-            new_columns.emplace_back(*old_column_it);\n-            old_columns.erase(old_column_it);\n-\n-            /// do not forget to change the default type of old column\n-            if (had_default_expr)\n-                columns_description.defaults[column_name].kind = default_kind;\n-        }\n+        column.type = data_type;\n \n-        /// find column in one of three column lists\n-        const auto column_it = find_column(new_columns);\n-        column_it->type = data_type;\n-\n-        if (!default_expression && had_default_expr)\n-            /// new column has no default expression, remove it from column_defaults along with it's type\n-            columns_description.defaults.erase(column_name);\n-        else if (default_expression && !had_default_expr)\n-            /// new column has a default expression while the old one had not, add it it column_defaults\n-            columns_description.defaults.emplace(column_name, ColumnDefault{default_kind, default_expression});\n-        else if (had_default_expr)\n-            /// both old and new columns have default expression, update it\n-            columns_description.defaults[column_name].expression = default_expression;\n+        column.default_desc.kind = default_kind;\n+        column.default_desc.expression = default_expression;\n     }\n     else if (type == MODIFY_ORDER_BY)\n     {\n@@ -326,7 +216,7 @@ void AlterCommand::apply(ColumnsDescription & columns_description, IndicesDescri\n     }\n     else if (type == COMMENT_COLUMN)\n     {\n-        columns_description.comments[column_name] = comment;\n+        columns_description.get(column_name).comment = comment;\n     }\n     else if (type == ADD_INDEX)\n     {\n@@ -415,25 +305,26 @@ void AlterCommands::apply(ColumnsDescription & columns_description, IndicesDescr\n \n void AlterCommands::validate(const IStorage & table, const Context & context)\n {\n-    auto all_columns = table.getColumns().getAll();\n-    auto defaults = table.getColumns().defaults;\n-\n-    std::vector<std::pair<NameAndTypePair, AlterCommand *>> defaulted_columns{};\n+    /// A temporary object that is used to keep track of the current state of columns after applying a subset of commands.\n+    auto columns = table.getColumns();\n \n+    /// Default expressions will be added to this list for type deduction.\n     auto default_expr_list = std::make_shared<ASTExpressionList>();\n-    default_expr_list->children.reserve(defaults.size());\n+    /// We will save ALTER ADD/MODIFY command indices (only the last for each column) for possible modification\n+    /// (we might need to add deduced types or modify default expressions).\n+    /// Saving indices because we can add new commands later and thus cause vector resize.\n+    std::unordered_map<String, size_t> column_to_command_idx;\n \n-    for (AlterCommand & command : *this)\n+    for (size_t i = 0; i < size(); ++i)\n     {\n+        auto & command = (*this)[i];\n         if (command.type == AlterCommand::ADD_COLUMN || command.type == AlterCommand::MODIFY_COLUMN)\n         {\n             const auto & column_name = command.column_name;\n-            const auto column_it = std::find_if(std::begin(all_columns), std::end(all_columns),\n-                std::bind(namesEqual, std::cref(command.column_name), std::placeholders::_1));\n \n             if (command.type == AlterCommand::ADD_COLUMN)\n             {\n-                if (std::end(all_columns) != column_it)\n+                if (columns.has(column_name) || columns.hasNested(column_name))\n                 {\n                     if (command.if_not_exists)\n                         command.ignore = true;\n@@ -443,8 +334,7 @@ void AlterCommands::validate(const IStorage & table, const Context & context)\n             }\n             else if (command.type == AlterCommand::MODIFY_COLUMN)\n             {\n-\n-                if (std::end(all_columns) == column_it)\n+                if (!columns.has(column_name))\n                 {\n                     if (command.if_exists)\n                         command.ignore = true;\n@@ -453,95 +343,72 @@ void AlterCommands::validate(const IStorage & table, const Context & context)\n                 }\n \n                 if (!command.ignore)\n-                {\n-                    all_columns.erase(column_it);\n-                    defaults.erase(column_name);\n-                }\n+                    columns.remove(column_name);\n             }\n \n             if (!command.ignore)\n             {\n+                column_to_command_idx[column_name] = i;\n+\n                 /// we're creating dummy DataTypeUInt8 in order to prevent the NullPointerException in ExpressionActions\n-                all_columns.emplace_back(column_name, command.data_type ? command.data_type : std::make_shared<DataTypeUInt8>());\n+                columns.add(ColumnDescription(\n+                    column_name, command.data_type ? command.data_type : std::make_shared<DataTypeUInt8>()));\n \n                 if (command.default_expression)\n                 {\n                     if (command.data_type)\n                     {\n-                        const auto &final_column_name = column_name;\n+                        const auto & final_column_name = column_name;\n                         const auto tmp_column_name = final_column_name + \"_tmp\";\n-                        const auto column_type_raw_ptr = command.data_type.get();\n \n                         default_expr_list->children.emplace_back(setAlias(\n                             makeASTFunction(\"CAST\", std::make_shared<ASTIdentifier>(tmp_column_name),\n-                                std::make_shared<ASTLiteral>(column_type_raw_ptr->getName())),\n+                                std::make_shared<ASTLiteral>(command.data_type->getName())),\n                             final_column_name));\n \n                         default_expr_list->children.emplace_back(setAlias(command.default_expression->clone(), tmp_column_name));\n-\n-                        defaulted_columns.emplace_back(NameAndTypePair{column_name, command.data_type}, &command);\n                     }\n                     else\n                     {\n                         /// no type explicitly specified, will deduce later\n                         default_expr_list->children.emplace_back(\n                             setAlias(command.default_expression->clone(), column_name));\n-\n-                        defaulted_columns.emplace_back(NameAndTypePair{column_name, nullptr}, &command);\n                     }\n                 }\n             }\n         }\n         else if (command.type == AlterCommand::DROP_COLUMN)\n         {\n-            for (const auto & default_column : defaults)\n+            if (columns.has(command.column_name) || columns.hasNested(command.column_name))\n             {\n-                const auto & default_expression = default_column.second.expression;\n-                ASTPtr query = default_expression;\n-                auto syntax_result = SyntaxAnalyzer(context).analyze(query, all_columns);\n-                const auto actions = ExpressionAnalyzer(query, syntax_result, context).getActions(true);\n-                const auto required_columns = actions->getRequiredColumns();\n-\n-                if (required_columns.end() != std::find(required_columns.begin(), required_columns.end(), command.column_name))\n-                    throw Exception(\n-                        \"Cannot drop column \" + command.column_name + \", because column \" + default_column.first +\n-                        \" depends on it\", ErrorCodes::ILLEGAL_COLUMN);\n-            }\n-\n-            auto found = false;\n-            for (auto it = std::begin(all_columns); it != std::end(all_columns);)\n-            {\n-                if (namesEqual(command.column_name, *it))\n+                for (const ColumnDescription & column : columns)\n                 {\n-                    found = true;\n-                    it = all_columns.erase(it);\n+                    const auto & default_expression = column.default_desc.expression;\n+                    if (!default_expression)\n+                        continue;\n+\n+                    ASTPtr query = default_expression->clone();\n+                    auto syntax_result = SyntaxAnalyzer(context).analyze(query, columns.getAll());\n+                    const auto actions = ExpressionAnalyzer(query, syntax_result, context).getActions(true);\n+                    const auto required_columns = actions->getRequiredColumns();\n+\n+                    if (required_columns.end() != std::find(required_columns.begin(), required_columns.end(), command.column_name))\n+                        throw Exception(\n+                            \"Cannot drop column \" + command.column_name + \", because column \" + column.name +\n+                            \" depends on it\", ErrorCodes::ILLEGAL_COLUMN);\n                 }\n-                else\n-                    ++it;\n-            }\n \n-            for (auto it = std::begin(defaults); it != std::end(defaults);)\n-            {\n-                if (namesEqual(command.column_name, { it->first, nullptr }))\n-                    it = defaults.erase(it);\n-                else\n-                    ++it;\n-            }\n-\n-            if (!found)\n-            {\n-                if (command.if_exists)\n-                    command.ignore = true;\n-                else\n-                    throw Exception(\"Wrong column name. Cannot find column \" + command.column_name + \" to drop\",\n-                        ErrorCodes::ILLEGAL_COLUMN);\n+                columns.remove(command.column_name);\n             }\n+            else if (command.if_exists)\n+                command.ignore = true;\n+            else\n+                throw Exception(\"Wrong column name. Cannot find column \" + command.column_name + \" to drop\",\n+                    ErrorCodes::ILLEGAL_COLUMN);\n         }\n         else if (command.type == AlterCommand::COMMENT_COLUMN)\n         {\n-            const auto column_it = std::find_if(std::begin(all_columns), std::end(all_columns),\n-                                                std::bind(namesEqual, std::cref(command.column_name), std::placeholders::_1));\n-            if (column_it == std::end(all_columns))\n+            if (!columns.has(command.column_name))\n             {\n                 if (command.if_exists)\n                     command.ignore = true;\n@@ -552,72 +419,64 @@ void AlterCommands::validate(const IStorage & table, const Context & context)\n     }\n \n     /** Existing defaulted columns may require default expression extensions with a type conversion,\n-        *  therefore we add them to defaulted_columns to allow further processing */\n-    for (const auto & col_def : defaults)\n+        *  therefore we add them to default_expr_list to recalculate their types */\n+    for (const auto & column : columns)\n     {\n-        const auto & column_name = col_def.first;\n-        const auto column_it = std::find_if(all_columns.begin(), all_columns.end(), [&] (const NameAndTypePair & name_type)\n-            { return namesEqual(column_name, name_type); });\n-\n-        const auto tmp_column_name = column_name + \"_tmp\";\n-        const auto & column_type_ptr = column_it->type;\n+        if (column.default_desc.expression)\n+        {\n+            const auto tmp_column_name = column.name + \"_tmp\";\n \n             default_expr_list->children.emplace_back(setAlias(\n-                makeASTFunction(\"CAST\", std::make_shared<ASTIdentifier>(tmp_column_name),\n-                    std::make_shared<ASTLiteral>(column_type_ptr->getName())),\n-                column_name));\n-\n-        default_expr_list->children.emplace_back(setAlias(col_def.second.expression->clone(), tmp_column_name));\n+                    makeASTFunction(\"CAST\", std::make_shared<ASTIdentifier>(tmp_column_name),\n+                        std::make_shared<ASTLiteral>(column.type->getName())),\n+                    column.name));\n \n-        defaulted_columns.emplace_back(NameAndTypePair{column_name, column_type_ptr}, nullptr);\n+            default_expr_list->children.emplace_back(setAlias(column.default_desc.expression->clone(), tmp_column_name));\n+        }\n     }\n \n     ASTPtr query = default_expr_list;\n-    auto syntax_result = SyntaxAnalyzer(context).analyze(query, all_columns);\n+    auto syntax_result = SyntaxAnalyzer(context).analyze(query, columns.getAll());\n     const auto actions = ExpressionAnalyzer(query, syntax_result, context).getActions(true);\n     const auto block = actions->getSampleBlock();\n \n     /// set deduced types, modify default expression if necessary\n-    for (auto & defaulted_column : defaulted_columns)\n+    for (const auto & column : columns)\n     {\n-        const auto & name_and_type = defaulted_column.first;\n-        AlterCommand * & command_ptr = defaulted_column.second;\n+        AlterCommand * command = nullptr;\n+        auto command_it = column_to_command_idx.find(column.name);\n+        if (command_it != column_to_command_idx.end())\n+            command = &(*this)[command_it->second];\n \n-        const auto & column_name = name_and_type.name;\n-        const auto has_explicit_type = nullptr != name_and_type.type;\n+        if (!(command && command->default_expression) && !column.default_desc.expression)\n+            continue;\n \n-        /// default expression on old column\n-        if (has_explicit_type)\n+        const DataTypePtr & explicit_type = command ? command->data_type : column.type;\n+        if (explicit_type)\n         {\n-            const auto & explicit_type = name_and_type.type;\n-            const auto & tmp_column = block.getByName(column_name + \"_tmp\");\n+            const auto & tmp_column = block.getByName(column.name + \"_tmp\");\n             const auto & deduced_type = tmp_column.type;\n-\n-            // column not specified explicitly in the ALTER query may require default_expression modification\n             if (!explicit_type->equals(*deduced_type))\n             {\n-                const auto default_it = defaults.find(column_name);\n-\n-                /// column has no associated alter command, let's create it\n-                if (!command_ptr)\n+                if (!command)\n                 {\n+                    /// column has no associated alter command, let's create it\n                     /// add a new alter command to modify existing column\n-                    this->emplace_back(AlterCommand{\n-                        AlterCommand::MODIFY_COLUMN, column_name, explicit_type,\n-                        default_it->second.kind, default_it->second.expression\n-                    });\n+                    this->emplace_back(AlterCommand{AlterCommand::MODIFY_COLUMN,\n+                        column.name, explicit_type, column.default_desc.kind, column.default_desc.expression});\n \n-                    command_ptr = &this->back();\n+                    command = &back();\n                 }\n \n-                command_ptr->default_expression = makeASTFunction(\"CAST\", command_ptr->default_expression->clone(),\n+                command->default_expression = makeASTFunction(\"CAST\",\n+                    command->default_expression->clone(),\n                     std::make_shared<ASTLiteral>(explicit_type->getName()));\n             }\n         }\n         else\n         {\n             /// just set deduced type\n-            command_ptr->data_type = block.getByName(column_name).type;\n+            command->data_type = block.getByName(column.name).type;\n         }\n     }\n }\ndiff --git a/dbms/src/Storages/ColumnDefault.cpp b/dbms/src/Storages/ColumnDefault.cpp\nindex 19ba69c2d943..2610b14f0b08 100644\n--- a/dbms/src/Storages/ColumnDefault.cpp\n+++ b/dbms/src/Storages/ColumnDefault.cpp\n@@ -50,7 +50,8 @@ std::string toString(const ColumnDefaultKind kind)\n \n bool operator==(const ColumnDefault & lhs, const ColumnDefault & rhs)\n {\n-    return lhs.kind == rhs.kind && queryToString(lhs.expression) == queryToString(rhs.expression);\n+    auto expression_str = [](const ASTPtr & expr) { return expr ? queryToString(expr) : String(); };\n+    return lhs.kind == rhs.kind && expression_str(lhs.expression) == expression_str(rhs.expression);\n }\n \n }\ndiff --git a/dbms/src/Storages/ColumnDefault.h b/dbms/src/Storages/ColumnDefault.h\nindex 0667ce4ed57e..4dcfa5da7893 100644\n--- a/dbms/src/Storages/ColumnDefault.h\n+++ b/dbms/src/Storages/ColumnDefault.h\n@@ -23,7 +23,7 @@ std::string toString(const ColumnDefaultKind type);\n \n struct ColumnDefault\n {\n-    ColumnDefaultKind kind;\n+    ColumnDefaultKind kind = ColumnDefaultKind::Default;\n     ASTPtr expression;\n };\n \ndiff --git a/dbms/src/Storages/ColumnsDescription.cpp b/dbms/src/Storages/ColumnsDescription.cpp\nindex 0f0636bc47fd..b1e5bb1f7f98 100644\n--- a/dbms/src/Storages/ColumnsDescription.cpp\n+++ b/dbms/src/Storages/ColumnsDescription.cpp\n@@ -9,19 +9,16 @@\n #include <IO/WriteHelpers.h>\n #include <IO/ReadBuffer.h>\n #include <IO/ReadHelpers.h>\n-\n #include <IO/WriteBufferFromString.h>\n #include <IO/ReadBufferFromString.h>\n #include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/NestedUtils.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeTuple.h>\n #include <Common/Exception.h>\n #include <Interpreters/Context.h>\n #include <Storages/IStorage.h>\n #include <Common/typeid_cast.h>\n-\n-#include <ext/collection_cast.h>\n-#include <ext/map.h>\n-\n-#include <boost/range/join.hpp>\n #include <Compression/CompressionFactory.h>\n \n #include <optional>\n@@ -33,187 +30,379 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int NO_SUCH_COLUMN_IN_TABLE;\n+    extern const int ILLEGAL_COLUMN;\n     extern const int CANNOT_PARSE_TEXT;\n }\n \n-\n-NamesAndTypesList ColumnsDescription::getAllPhysical() const\n+bool ColumnDescription::operator==(const ColumnDescription & other) const\n {\n-    return ext::collection_cast<NamesAndTypesList>(boost::join(ordinary, materialized));\n-}\n+    auto codec_str = [](const CompressionCodecPtr & codec_ptr) { return codec_ptr ? codec_ptr->getCodecDesc() : String(); };\n \n+    return name == other.name\n+        && type->equals(*other.type)\n+        && default_desc == other.default_desc\n+        && comment == other.comment\n+        && codec_str(codec) == codec_str(other.codec);\n+}\n \n-NamesAndTypesList ColumnsDescription::getAll() const\n+void ColumnDescription::writeText(WriteBuffer & buf) const\n {\n-    return ext::collection_cast<NamesAndTypesList>(boost::join(ordinary, boost::join(materialized, aliases)));\n-}\n+    writeBackQuotedString(name, buf);\n+    writeChar(' ', buf);\n+    DB::writeText(type->getName(), buf);\n+\n+    if (default_desc.expression)\n+    {\n+        writeChar('\\t', buf);\n+        DB::writeText(DB::toString(default_desc.kind), buf);\n+        writeChar('\\t', buf);\n+        DB::writeText(queryToString(default_desc.expression), buf);\n+    }\n \n+    if (!comment.empty())\n+    {\n+        writeChar('\\t', buf);\n+        DB::writeText(\"COMMENT \", buf);\n+        DB::writeText(queryToString(ASTLiteral(Field(comment))), buf);\n+    }\n \n-Names ColumnsDescription::getNamesOfPhysical() const\n+    if (codec)\n+    {\n+        writeChar('\\t', buf);\n+        DB::writeText(\"CODEC(\", buf);\n+        DB::writeText(codec->getCodecDesc(), buf);\n+        DB::writeText(\")\", buf);\n+    }\n+\n+    writeChar('\\n', buf);\n+}\n+\n+void ColumnDescription::readText(ReadBuffer & buf)\n {\n-    return ext::map<Names>(boost::join(ordinary, materialized), [] (const auto & it) { return it.name; });\n+    ParserColumnDeclaration column_parser(true);\n+    String column_line;\n+    readEscapedStringUntilEOL(column_line, buf);\n+    ASTPtr ast = parseQuery(column_parser, column_line, \"column parser\", 0);\n+    if (const auto * col_ast = ast->as<ASTColumnDeclaration>())\n+    {\n+        name = col_ast->name;\n+        type = DataTypeFactory::instance().get(col_ast->type);\n+\n+        if (col_ast->default_expression)\n+        {\n+            default_desc.kind = columnDefaultKindFromString(col_ast->default_specifier);\n+            default_desc.expression = std::move(col_ast->default_expression);\n+        }\n+\n+        if (col_ast->comment)\n+            comment = col_ast->comment->as<ASTLiteral &>().value.get<String>();\n+\n+        if (col_ast->codec)\n+            codec = CompressionCodecFactory::instance().get(col_ast->codec, type);\n+    }\n+    else\n+        throw Exception(\"Cannot parse column description\", ErrorCodes::CANNOT_PARSE_TEXT);\n }\n \n \n-NameAndTypePair ColumnsDescription::getPhysical(const String & column_name) const\n+ColumnsDescription::ColumnsDescription(NamesAndTypesList ordinary)\n {\n-    for (auto & it : boost::join(ordinary, materialized))\n-        if (it.name == column_name)\n-            return it;\n-    throw Exception(\"There is no column \" + column_name + \" in table.\", ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+    for (auto & elem : ordinary)\n+        add(ColumnDescription(std::move(elem.name), std::move(elem.type)));\n }\n \n+ColumnsDescription::ColumnsDescription(const ColumnsDescription & other)\n+    : columns(other.columns)\n+{\n+    for (auto it = columns.begin(); it != columns.end(); ++it)\n+        name_to_column.emplace(it->name, it);\n+}\n \n-bool ColumnsDescription::hasPhysical(const String & column_name) const\n+ColumnsDescription & ColumnsDescription::operator=(const ColumnsDescription & other)\n {\n-    for (auto & it : boost::join(ordinary, materialized))\n-        if (it.name == column_name)\n-            return true;\n-    return false;\n+    if (&other != this)\n+        *this = ColumnsDescription(other);\n+    return *this;\n }\n \n \n-bool ColumnsDescription::operator==(const ColumnsDescription & other) const\n+/// We are trying to find first column from end with name `column_name` or with a name beginning with `column_name` and \".\".\n+/// For example \"fruits.bananas\"\n+/// names are considered the same if they completely match or `name_without_dot` matches the part of the name to the point\n+static auto getNameRange(const std::list<ColumnDescription> & columns, const String & name_without_dot)\n {\n-    if (ordinary != other.ordinary\n-        || materialized != other.materialized\n-        || aliases != other.aliases\n-        || defaults != other.defaults\n-        || comments != other.comments)\n+    String name_with_dot = name_without_dot + \".\";\n+\n+    auto begin = columns.begin();\n+    for (; begin != columns.end(); ++begin)\n     {\n-        return false;\n+        if (begin->name == name_without_dot)\n+            return std::make_pair(begin, std::next(begin));\n+\n+        if (startsWith(begin->name, name_with_dot))\n+            break;\n     }\n \n-    if (codecs.size() != other.codecs.size())\n-        return false;\n+    if (begin == columns.end())\n+        return std::make_pair(begin, begin);\n \n-    for (const auto & [col_name, codec_ptr] : codecs)\n+    auto end = std::next(begin);\n+    for (; end != columns.end(); ++end)\n     {\n-        if (other.codecs.count(col_name) == 0)\n-            return false;\n-        if (other.codecs.at(col_name)->getCodecDesc() != codec_ptr->getCodecDesc())\n-            return false;\n+        if (!startsWith(end->name, name_with_dot))\n+            break;\n     }\n-    return true;\n+\n+    return std::make_pair(begin, end);\n }\n \n-String ColumnsDescription::toString() const\n+void ColumnsDescription::add(ColumnDescription column, const String & after_column)\n {\n-    WriteBufferFromOwnString buf;\n+    if (has(column.name))\n+        throw Exception(\"Cannot add column \" + column.name + \": column with this name already exists\",\n+            ErrorCodes::ILLEGAL_COLUMN);\n \n-    writeCString(\"columns format version: 1\\n\", buf);\n-    writeText(ordinary.size() + materialized.size() + aliases.size(), buf);\n-    writeCString(\" columns:\\n\", buf);\n+    auto insert_it = columns.cend();\n \n-    const auto write_columns = [this, &buf] (const NamesAndTypesList & columns)\n+    if (!after_column.empty())\n     {\n-        for (const auto & column : columns)\n-        {\n-            const auto defaults_it = defaults.find(column.name);\n-            const auto comments_it = comments.find(column.name);\n-            const auto codec_it = codecs.find(column.name);\n-\n-            writeBackQuotedString(column.name, buf);\n-            writeChar(' ', buf);\n-            writeText(column.type->getName(), buf);\n-\n-            const bool exist_comment = comments_it != std::end(comments);\n-            const bool exist_codec = codec_it != std::end(codecs);\n-            if (defaults_it != std::end(defaults))\n-            {\n-                writeChar('\\t', buf);\n-                writeText(DB::toString(defaults_it->second.kind), buf);\n-                writeChar('\\t', buf);\n-                writeText(queryToString(defaults_it->second.expression), buf);\n-            }\n-\n-            if (exist_comment)\n-            {\n-                writeChar('\\t', buf);\n-                writeText(\"COMMENT \", buf);\n-                writeText(queryToString(ASTLiteral(Field(comments_it->second))), buf);\n-            }\n-\n-            if (exist_codec)\n-            {\n-                writeChar('\\t', buf);\n-                writeText(\"CODEC(\", buf);\n-                writeText(codec_it->second->getCodecDesc(), buf);\n-                writeText(\")\", buf);\n-            }\n-\n-            writeChar('\\n', buf);\n-        }\n-    };\n+        auto range = getNameRange(columns, after_column);\n+        if (range.first == range.second)\n+            throw Exception(\"Wrong column name. Cannot find column \" + after_column + \" to insert after\",\n+                ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n \n-    write_columns(ordinary);\n-    write_columns(materialized);\n-    write_columns(aliases);\n-    return buf.str();\n+        insert_it = range.second;\n+    }\n+\n+    auto it = columns.insert(insert_it, std::move(column));\n+    name_to_column.emplace(it->name, it);\n }\n \n-void parseColumn(ReadBufferFromString & buf, ColumnsDescription & result, const DataTypeFactory & data_type_factory)\n+void ColumnsDescription::remove(const String & column_name)\n {\n-    ParserColumnDeclaration column_parser(true);\n-    String column_line;\n-    readEscapedStringUntilEOL(column_line, buf);\n-    ASTPtr ast = parseQuery(column_parser, column_line, \"column parser\", 0);\n-    if (const auto * col_ast = ast->as<ASTColumnDeclaration>())\n+    auto range = getNameRange(columns, column_name);\n+    if (range.first == range.second)\n+        throw Exception(\"There is no column \" + column_name + \" in table.\",\n+            ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+\n+    for (auto list_it = range.first; list_it != range.second;)\n+    {\n+        name_to_column.erase(list_it->name);\n+        list_it = columns.erase(list_it);\n+    }\n+}\n+\n+\n+void ColumnsDescription::flattenNested()\n+{\n+    for (auto it = columns.begin(); it != columns.end();)\n     {\n-        String column_name = col_ast->name;\n-        auto type = data_type_factory.get(col_ast->type);\n+        const auto * type_arr = typeid_cast<const DataTypeArray *>(it->type.get());\n+        if (!type_arr)\n+        {\n+            ++it;\n+            continue;\n+        }\n \n-        if (col_ast->default_expression)\n+        const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_arr->getNestedType().get());\n+        if (!type_tuple)\n         {\n-            auto kind = columnDefaultKindFromString(col_ast->default_specifier);\n-            switch (kind)\n-            {\n-            case ColumnDefaultKind::Default:\n-                result.ordinary.emplace_back(column_name, std::move(type));\n-                break;\n-            case ColumnDefaultKind::Materialized:\n-                result.materialized.emplace_back(column_name, std::move(type));\n-                break;\n-            case ColumnDefaultKind::Alias:\n-                result.aliases.emplace_back(column_name, std::move(type));\n-                break;\n-            }\n-\n-            result.defaults.emplace(column_name, ColumnDefault{kind, std::move(col_ast->default_expression)});\n+            ++it;\n+            continue;\n         }\n-        else\n-            result.ordinary.emplace_back(column_name, std::move(type));\n \n-        if (col_ast->comment)\n-            if (auto comment_str = col_ast->comment->as<ASTLiteral &>().value.get<String>(); !comment_str.empty())\n-                result.comments.emplace(column_name, std::move(comment_str));\n+        ColumnDescription column = std::move(*it);\n+        it = columns.erase(it);\n+        name_to_column.erase(column.name);\n \n-        if (col_ast->codec)\n+        const DataTypes & elements = type_tuple->getElements();\n+        const Strings & names = type_tuple->getElementNames();\n+        size_t tuple_size = elements.size();\n+\n+        for (size_t i = 0; i < tuple_size; ++i)\n         {\n-            auto codec = CompressionCodecFactory::instance().get(col_ast->codec, type);\n-            result.codecs.emplace(column_name, std::move(codec));\n+            auto nested_column = column;\n+            /// TODO: what to do with default expressions?\n+            nested_column.name = Nested::concatenateName(column.name, names[i]);\n+            nested_column.type = std::make_shared<DataTypeArray>(elements[i]);\n+\n+            auto inserted_it = columns.insert(it, std::move(nested_column));\n+            name_to_column.emplace(inserted_it->name, inserted_it);\n         }\n     }\n-    else\n-        throw Exception(\"Cannot parse column description\", ErrorCodes::CANNOT_PARSE_TEXT);\n }\n \n+\n+NamesAndTypesList ColumnsDescription::getOrdinary() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+    {\n+        if (col.default_desc.kind == ColumnDefaultKind::Default)\n+            ret.emplace_back(col.name, col.type);\n+    }\n+    return ret;\n+}\n+\n+NamesAndTypesList ColumnsDescription::getMaterialized() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+    {\n+        if (col.default_desc.kind == ColumnDefaultKind::Materialized)\n+            ret.emplace_back(col.name, col.type);\n+    }\n+    return ret;\n+}\n+\n+NamesAndTypesList ColumnsDescription::getAliases() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+    {\n+        if (col.default_desc.kind == ColumnDefaultKind::Alias)\n+            ret.emplace_back(col.name, col.type);\n+    }\n+    return ret;\n+}\n+\n+NamesAndTypesList ColumnsDescription::getAll() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+        ret.emplace_back(col.name, col.type);\n+    return ret;\n+}\n+\n+\n+bool ColumnsDescription::has(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    return it != name_to_column.end();\n+}\n+\n+bool ColumnsDescription::hasNested(const String & column_name) const\n+{\n+    auto range = getNameRange(columns, column_name);\n+    return range.first != range.second && range.first->name.length() > column_name.length();\n+}\n+\n+ColumnDescription & ColumnsDescription::get(const String & column_name)\n+{\n+    auto it = name_to_column.find(column_name);\n+    if (it == name_to_column.end())\n+        throw Exception(\"There is no column \" + column_name + \" in table.\",\n+            ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+\n+    return *it->second;\n+}\n+\n+const ColumnDescription & ColumnsDescription::get(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    if (it == name_to_column.end())\n+        throw Exception(\"There is no column \" + column_name + \" in table.\",\n+            ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+\n+    return *it->second;\n+}\n+\n+\n+NamesAndTypesList ColumnsDescription::getAllPhysical() const\n+{\n+    NamesAndTypesList ret;\n+    for (const auto & col : columns)\n+    {\n+        if (col.default_desc.kind != ColumnDefaultKind::Alias)\n+            ret.emplace_back(col.name, col.type);\n+    }\n+    return ret;\n+}\n+\n+Names ColumnsDescription::getNamesOfPhysical() const\n+{\n+    Names ret;\n+    for (const auto & col : columns)\n+    {\n+        if (col.default_desc.kind != ColumnDefaultKind::Alias)\n+            ret.emplace_back(col.name);\n+    }\n+    return ret;\n+}\n+\n+NameAndTypePair ColumnsDescription::getPhysical(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    if (it == name_to_column.end() || it->second->default_desc.kind == ColumnDefaultKind::Alias)\n+        throw Exception(\"There is no physical column \" + column_name + \" in table.\", ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n+    return NameAndTypePair(it->second->name, it->second->type);\n+}\n+\n+bool ColumnsDescription::hasPhysical(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    return it != name_to_column.end() && it->second->default_desc.kind != ColumnDefaultKind::Alias;\n+}\n+\n+\n+ColumnDefaults ColumnsDescription::getDefaults() const\n+{\n+    ColumnDefaults ret;\n+    for (const auto & column : columns)\n+    {\n+        if (column.default_desc.expression)\n+            ret.emplace(column.name, column.default_desc);\n+    }\n+\n+    return ret;\n+}\n+\n+bool ColumnsDescription::hasDefault(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    return it != name_to_column.end() && it->second->default_desc.expression;\n+}\n+\n+std::optional<ColumnDefault> ColumnsDescription::getDefault(const String & column_name) const\n+{\n+    auto it = name_to_column.find(column_name);\n+    if (it != name_to_column.end() && it->second->default_desc.expression)\n+        return it->second->default_desc;\n+\n+    return {};\n+}\n+\n+\n CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n {\n-    const auto codec = codecs.find(column_name);\n+    const auto it = name_to_column.find(column_name);\n \n-    if (codec == codecs.end())\n+    if (it == name_to_column.end() || !it->second->codec)\n         return default_codec;\n \n-    return codec->second;\n+    return it->second->codec;\n }\n \n-\n CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_name) const\n {\n     return getCodecOrDefault(column_name, CompressionCodecFactory::instance().getDefaultCodec());\n }\n \n+\n+String ColumnsDescription::toString() const\n+{\n+    WriteBufferFromOwnString buf;\n+\n+    writeCString(\"columns format version: 1\\n\", buf);\n+    DB::writeText(columns.size(), buf);\n+    writeCString(\" columns:\\n\", buf);\n+\n+    for (const ColumnDescription & column : columns)\n+        column.writeText(buf);\n+\n+    return buf.str();\n+}\n+\n ColumnsDescription ColumnsDescription::parse(const String & str)\n {\n     ReadBufferFromString buf{str};\n@@ -223,13 +412,13 @@ ColumnsDescription ColumnsDescription::parse(const String & str)\n     readText(count, buf);\n     assertString(\" columns:\\n\", buf);\n \n-    const DataTypeFactory & data_type_factory = DataTypeFactory::instance();\n-\n     ColumnsDescription result;\n     for (size_t i = 0; i < count; ++i)\n     {\n-        parseColumn(buf, result, data_type_factory);\n+        ColumnDescription column;\n+        column.readText(buf);\n         buf.ignore(1); /// ignore new line\n+        result.add(std::move(column));\n     }\n \n     assertEOF(buf);\ndiff --git a/dbms/src/Storages/ColumnsDescription.h b/dbms/src/Storages/ColumnsDescription.h\nindex d62c949b64c1..8d400c8d1de6 100644\n--- a/dbms/src/Storages/ColumnsDescription.h\n+++ b/dbms/src/Storages/ColumnsDescription.h\n@@ -5,67 +5,85 @@\n #include <Storages/ColumnDefault.h>\n #include <Core/Block.h>\n #include <Storages/ColumnCodec.h>\n+#include <optional>\n \n \n namespace DB\n {\n \n-/// key-values column_name, column_comment. column_comment should be non empty.\n-using ColumnComments = std::unordered_map<std::string, String>;\n-\n-struct ColumnsDescription\n+struct ColumnDescription\n {\n-    NamesAndTypesList ordinary;\n-    NamesAndTypesList materialized;\n-    NamesAndTypesList aliases;\n-    ColumnDefaults defaults;\n-    ColumnComments comments;\n-    ColumnCodecs codecs;\n+    String name;\n+    DataTypePtr type;\n+    ColumnDefault default_desc;\n+    String comment;\n+    CompressionCodecPtr codec;\n+\n+    ColumnDescription() = default;\n+    ColumnDescription(String name_, DataTypePtr type_) : name(std::move(name_)), type(std::move(type_)) {}\n+\n+    bool operator==(const ColumnDescription & other) const;\n+    bool operator!=(const ColumnDescription & other) const { return !(*this == other); }\n+\n+    void writeText(WriteBuffer & buf) const;\n+    void readText(ReadBuffer & buf);\n+};\n \n+class ColumnsDescription\n+{\n+public:\n     ColumnsDescription() = default;\n+    explicit ColumnsDescription(NamesAndTypesList ordinary_);\n+    ColumnsDescription(const ColumnsDescription & other);\n+    ColumnsDescription & operator=(const ColumnsDescription & other);\n+    ColumnsDescription(ColumnsDescription &&) noexcept = default;\n+    ColumnsDescription & operator=(ColumnsDescription &&) noexcept = default;\n+\n+    /// `after_column` can be a Nested column name;\n+    void add(ColumnDescription column, const String & after_column = String());\n+    /// `column_name` can be a Nested column name;\n+    void remove(const String & column_name);\n \n-    ColumnsDescription(\n-        NamesAndTypesList ordinary_,\n-        NamesAndTypesList materialized_,\n-        NamesAndTypesList aliases_,\n-        ColumnDefaults defaults_,\n-        ColumnComments comments_,\n-        ColumnCodecs codecs_)\n-        : ordinary(std::move(ordinary_))\n-        , materialized(std::move(materialized_))\n-        , aliases(std::move(aliases_))\n-        , defaults(std::move(defaults_))\n-        , comments(std::move(comments_))\n-        , codecs(std::move(codecs_))\n-    {}\n-\n-    explicit ColumnsDescription(NamesAndTypesList ordinary_) : ordinary(std::move(ordinary_)) {}\n-\n-    bool operator==(const ColumnsDescription & other) const;\n+    void flattenNested(); /// TODO: remove, insert already flattened Nested columns.\n \n+    bool operator==(const ColumnsDescription & other) const { return columns == other.columns; }\n     bool operator!=(const ColumnsDescription & other) const { return !(*this == other); }\n \n-    /// ordinary + materialized.\n-    NamesAndTypesList getAllPhysical() const;\n+    std::list<ColumnDescription>::const_iterator begin() const { return columns.begin(); }\n+    std::list<ColumnDescription>::const_iterator end() const { return columns.end(); }\n \n+    NamesAndTypesList getOrdinary() const;\n+    NamesAndTypesList getMaterialized() const;\n+    NamesAndTypesList getAliases() const;\n     /// ordinary + materialized + aliases.\n     NamesAndTypesList getAll() const;\n \n-    Names getNamesOfPhysical() const;\n-\n-    NameAndTypePair getPhysical(const String & column_name) const;\n+    bool has(const String & column_name) const;\n+    bool hasNested(const String & column_name) const;\n+    ColumnDescription & get(const String & column_name);\n+    const ColumnDescription & get(const String & column_name) const;\n \n+    /// ordinary + materialized.\n+    NamesAndTypesList getAllPhysical() const;\n+    Names getNamesOfPhysical() const;\n     bool hasPhysical(const String & column_name) const;\n+    NameAndTypePair getPhysical(const String & column_name) const;\n \n-    String toString() const;\n+    ColumnDefaults getDefaults() const; /// TODO: remove\n+    bool hasDefault(const String & column_name) const;\n+    std::optional<ColumnDefault> getDefault(const String & column_name) const;\n \n     CompressionCodecPtr getCodecOrDefault(const String & column_name, CompressionCodecPtr default_codec) const;\n-\n     CompressionCodecPtr getCodecOrDefault(const String & column_name) const;\n \n+    String toString() const;\n     static ColumnsDescription parse(const String & str);\n \n     static const ColumnsDescription * loadFromContext(const Context & context, const String & db, const String & table);\n+\n+private:\n+    std::list<ColumnDescription> columns;\n+    std::unordered_map<String, std::list<ColumnDescription>::iterator> name_to_column;\n };\n \n }\ndiff --git a/dbms/src/Storages/ITableDeclaration.cpp b/dbms/src/Storages/ITableDeclaration.cpp\nindex 2315e5a55384..c9385c24cbe9 100644\n--- a/dbms/src/Storages/ITableDeclaration.cpp\n+++ b/dbms/src/Storages/ITableDeclaration.cpp\n@@ -26,7 +26,7 @@ namespace ErrorCodes\n \n void ITableDeclaration::setColumns(ColumnsDescription columns_)\n {\n-    if (columns_.ordinary.empty())\n+    if (columns_.getOrdinary().empty())\n         throw Exception(\"Empty list of columns passed\", ErrorCodes::EMPTY_LIST_OF_COLUMNS_PASSED);\n     columns = std::move(columns_);\n }\n@@ -63,7 +63,7 @@ Block ITableDeclaration::getSampleBlockNonMaterialized() const\n {\n     Block res;\n \n-    for (const auto & col : getColumns().ordinary)\n+    for (const auto & col : getColumns().getOrdinary())\n         res.insert({ col.type->createColumn(), col.type, col.name });\n \n     return res;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\nindex 8712afe3a393..d3729bb0d086 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n@@ -26,14 +26,13 @@ NameSet injectRequiredColumns(const MergeTreeData & storage, const MergeTreeData\n             continue;\n         }\n \n-        const auto default_it = storage.getColumns().defaults.find(column_name);\n-        /// columns has no explicit default expression\n-        if (default_it == std::end(storage.getColumns().defaults))\n+        const auto column_default = storage.getColumns().getDefault(column_name);\n+        if (!column_default)\n             continue;\n \n         /// collect identifiers required for evaluation\n         IdentifierNameSet identifiers;\n-        default_it->second.expression->collectIdentifierNames(identifiers);\n+        column_default->expression->collectIdentifierNames(identifiers);\n \n         for (const auto & identifier : identifiers)\n         {\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeData.cpp b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\nindex 8c9afe37ade8..b2cf09497419 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -301,7 +301,7 @@ void MergeTreeData::setPrimaryKeyIndicesAndColumns(\n                         \"added to the sorting key. You can add expressions that use only the newly added columns\",\n                         ErrorCodes::BAD_ARGUMENTS);\n \n-                if (new_columns.defaults.count(col))\n+                if (new_columns.getDefaults().count(col))\n                     throw Exception(\"Newly added column \" + col + \" has a default expression, so adding \"\n                         \"expressions that use it to the sorting key is forbidden\",\n                         ErrorCodes::BAD_ARGUMENTS);\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeReader.cpp b/dbms/src/Storages/MergeTree/MergeTreeReader.cpp\nindex ba53037bd7ad..b226d55978e9 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeReader.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeReader.cpp\n@@ -300,7 +300,7 @@ void MergeTreeReader::fillMissingColumns(Block & res, bool & should_reorder, boo\n             if (!has_column)\n             {\n                 should_reorder = true;\n-                if (storage.getColumns().defaults.count(requested_column.name) != 0)\n+                if (storage.getColumns().hasDefault(requested_column.name))\n                 {\n                     should_evaluate_missing_defaults = true;\n                     continue;\n@@ -367,7 +367,7 @@ void MergeTreeReader::evaluateMissingDefaults(Block & res)\n {\n     try\n     {\n-        DB::evaluateMissingDefaults(res, columns, storage.getColumns().defaults, storage.global_context);\n+        DB::evaluateMissingDefaults(res, columns, storage.getColumns().getDefaults(), storage.global_context);\n     }\n     catch (Exception & e)\n     {\ndiff --git a/dbms/src/Storages/StorageBuffer.cpp b/dbms/src/Storages/StorageBuffer.cpp\nindex c9a1e2fe52be..c83dccc25211 100644\n--- a/dbms/src/Storages/StorageBuffer.cpp\n+++ b/dbms/src/Storages/StorageBuffer.cpp\n@@ -200,9 +200,9 @@ BlockInputStreams StorageBuffer::read(\n                 for (auto & stream : streams_from_dst)\n                 {\n                     stream = std::make_shared<AddingMissedBlockInputStream>(\n-                                stream, header_after_adding_defaults, getColumns().defaults, context);\n+                        stream, header_after_adding_defaults, getColumns().getDefaults(), context);\n                     stream = std::make_shared<ConvertingBlockInputStream>(\n-                                context, stream, header, ConvertingBlockInputStream::MatchColumnsMode::Name);\n+                        context, stream, header, ConvertingBlockInputStream::MatchColumnsMode::Name);\n                 }\n             }\n         }\ndiff --git a/dbms/src/Storages/StorageCatBoostPool.cpp b/dbms/src/Storages/StorageCatBoostPool.cpp\nindex 8ccde07e7114..1258ebec7e26 100644\n--- a/dbms/src/Storages/StorageCatBoostPool.cpp\n+++ b/dbms/src/Storages/StorageCatBoostPool.cpp\n@@ -225,35 +225,57 @@ void StorageCatBoostPool::createSampleBlockAndColumns()\n     ColumnsDescription columns;\n     NamesAndTypesList cat_columns;\n     NamesAndTypesList num_columns;\n+    NamesAndTypesList other_columns;\n     sample_block.clear();\n-    for (auto & desc : columns_description)\n+\n+    auto get_type = [](DatasetColumnType column_type) -> DataTypePtr\n     {\n-        DataTypePtr type;\n-        if (desc.column_type == DatasetColumnType::Categ\n-            || desc.column_type == DatasetColumnType::Auxiliary\n-            || desc.column_type == DatasetColumnType::DocId)\n-            type = std::make_shared<DataTypeString>();\n+        if (column_type == DatasetColumnType::Categ\n+            || column_type == DatasetColumnType::Auxiliary\n+            || column_type == DatasetColumnType::DocId)\n+            return std::make_shared<DataTypeString>();\n         else\n-            type = std::make_shared<DataTypeFloat64>();\n+            return std::make_shared<DataTypeFloat64>();\n+    };\n+\n+    for (auto & desc : columns_description)\n+    {\n+        DataTypePtr type = get_type(desc.column_type);\n \n         if (desc.column_type == DatasetColumnType::Categ)\n             cat_columns.emplace_back(desc.column_name, type);\n         else if (desc.column_type == DatasetColumnType::Num)\n             num_columns.emplace_back(desc.column_name, type);\n         else\n-            columns.materialized.emplace_back(desc.column_name, type);\n+            other_columns.emplace_back(desc.column_name, type);\n+\n+        sample_block.insert(ColumnWithTypeAndName(type, desc.column_name));\n+    }\n \n+    /// Order is important: first numeric columns, then categorial, then all others.\n+    for (const auto & column : num_columns)\n+        columns.add(DB::ColumnDescription(column.name, column.type));\n+    for (const auto & column : cat_columns)\n+        columns.add(DB::ColumnDescription(column.name, column.type));\n+    for (const auto & column : other_columns)\n+    {\n+        DB::ColumnDescription column_desc(column.name, column.type);\n+        /// We assign Materialized kind to the column so that it doesn't show in SELECT *.\n+        /// Because the table is readonly, we do not need default expression.\n+        column_desc.default_desc.kind = ColumnDefaultKind::Materialized;\n+        columns.add(std::move(column_desc));\n+    }\n+\n+    for (auto & desc : columns_description)\n+    {\n         if (!desc.alias.empty())\n         {\n-            auto alias = std::make_shared<ASTIdentifier>(desc.column_name);\n-            columns.defaults[desc.alias] = {ColumnDefaultKind::Alias, alias};\n-            columns.aliases.emplace_back(desc.alias, type);\n+            DB::ColumnDescription column(desc.alias, get_type(desc.column_type));\n+            column.default_desc.kind = ColumnDefaultKind::Alias;\n+            column.default_desc.expression = std::make_shared<ASTIdentifier>(desc.column_name);\n+            columns.add(std::move(column));\n         }\n-\n-        sample_block.insert(ColumnWithTypeAndName(type, desc.column_name));\n     }\n-    columns.ordinary.insert(columns.ordinary.end(), num_columns.begin(), num_columns.end());\n-    columns.ordinary.insert(columns.ordinary.end(), cat_columns.begin(), cat_columns.end());\n \n     setColumns(columns);\n }\ndiff --git a/dbms/src/Storages/StorageDictionary.cpp b/dbms/src/Storages/StorageDictionary.cpp\nindex 2c8c76005d46..ea9276766bac 100644\n--- a/dbms/src/Storages/StorageDictionary.cpp\n+++ b/dbms/src/Storages/StorageDictionary.cpp\n@@ -78,7 +78,7 @@ void StorageDictionary::checkNamesAndTypesCompatibleWithDictionary(const Diction\n     auto dictionary_names_and_types = getNamesAndTypes(dictionary_structure);\n     std::set<NameAndTypePair> names_and_types_set(dictionary_names_and_types.begin(), dictionary_names_and_types.end());\n \n-    for (const auto & column : getColumns().ordinary)\n+    for (const auto & column : getColumns().getOrdinary())\n     {\n         if (names_and_types_set.find(column) == names_and_types_set.end())\n         {\ndiff --git a/dbms/src/Storages/StorageFile.cpp b/dbms/src/Storages/StorageFile.cpp\nindex c6eb867f32ac..28c81c4902f7 100644\n--- a/dbms/src/Storages/StorageFile.cpp\n+++ b/dbms/src/Storages/StorageFile.cpp\n@@ -192,9 +192,10 @@ BlockInputStreams StorageFile::read(\n {\n     BlockInputStreamPtr block_input = std::make_shared<StorageFileBlockInputStream>(*this, context, max_block_size);\n     const ColumnsDescription & columns = getColumns();\n-    if (columns.defaults.empty())\n+    auto column_defaults = columns.getDefaults();\n+    if (column_defaults.empty())\n         return {block_input};\n-    return {std::make_shared<AddingDefaultsBlockInputStream>(block_input, columns.defaults, context)};\n+    return {std::make_shared<AddingDefaultsBlockInputStream>(block_input, column_defaults, context)};\n }\n \n \ndiff --git a/dbms/src/Storages/StorageLog.cpp b/dbms/src/Storages/StorageLog.cpp\nindex 968358990284..afef7af57e93 100644\n--- a/dbms/src/Storages/StorageLog.cpp\n+++ b/dbms/src/Storages/StorageLog.cpp\n@@ -551,8 +551,8 @@ void StorageLog::truncate(const ASTPtr &, const Context &)\n \n const StorageLog::Marks & StorageLog::getMarksWithRealRowCount() const\n {\n-    const String & column_name = getColumns().ordinary.front().name;\n-    const IDataType & column_type = *getColumns().ordinary.front().type;\n+    const String & column_name = getColumns().begin()->name;\n+    const IDataType & column_type = *getColumns().begin()->type;\n     String filename;\n \n     /** We take marks from first column.\ndiff --git a/dbms/src/Storages/StorageMySQL.cpp b/dbms/src/Storages/StorageMySQL.cpp\nindex cd700529b79b..c565369745f8 100644\n--- a/dbms/src/Storages/StorageMySQL.cpp\n+++ b/dbms/src/Storages/StorageMySQL.cpp\n@@ -57,7 +57,7 @@ BlockInputStreams StorageMySQL::read(\n {\n     check(column_names);\n     String query = transformQueryForExternalDatabase(\n-        *query_info.query, getColumns().ordinary, IdentifierQuotingStyle::Backticks, remote_database_name, remote_table_name, context);\n+        *query_info.query, getColumns().getOrdinary(), IdentifierQuotingStyle::Backticks, remote_database_name, remote_table_name, context);\n \n     Block sample_block;\n     for (const String & column_name : column_names)\ndiff --git a/dbms/src/Storages/StorageReplicatedMergeTree.cpp b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\nindex 045d25c61b0f..c51070c4b44f 100644\n--- a/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -397,8 +397,8 @@ void StorageReplicatedMergeTree::checkTableStructure(bool skip_sanity_checks, bo\n     {\n         if (allow_alter &&\n             (skip_sanity_checks ||\n-             old_columns.ordinary.sizeOfDifference(columns_from_zk.ordinary) +\n-             old_columns.materialized.sizeOfDifference(columns_from_zk.materialized) <= 2))\n+             old_columns.getOrdinary().sizeOfDifference(columns_from_zk.getOrdinary()) +\n+             old_columns.getMaterialized().sizeOfDifference(columns_from_zk.getMaterialized()) <= 2))\n         {\n             LOG_WARNING(log, \"Table structure in ZooKeeper is a little different from local table structure. Assuming ALTER.\");\n \ndiff --git a/dbms/src/Storages/StorageURL.cpp b/dbms/src/Storages/StorageURL.cpp\nindex 71575f27b1b1..0f1401f54d87 100644\n--- a/dbms/src/Storages/StorageURL.cpp\n+++ b/dbms/src/Storages/StorageURL.cpp\n@@ -176,10 +176,10 @@ BlockInputStreams IStorageURLBase::read(const Names & column_names,\n         ConnectionTimeouts::getHTTPTimeouts(context.getSettingsRef()));\n \n \n-    const ColumnsDescription & columns = getColumns();\n-    if (columns.defaults.empty())\n+    auto column_defaults = getColumns().getDefaults();\n+    if (column_defaults.empty())\n         return {block_input};\n-    return {std::make_shared<AddingDefaultsBlockInputStream>(block_input, columns.defaults, context)};\n+    return {std::make_shared<AddingDefaultsBlockInputStream>(block_input, column_defaults, context)};\n }\n \n void IStorageURLBase::rename(const String & /*new_path_to_db*/, const String & /*new_database_name*/, const String & /*new_table_name*/) {}\ndiff --git a/dbms/src/Storages/StorageXDBC.cpp b/dbms/src/Storages/StorageXDBC.cpp\nindex 3b02b86ad7fa..6e57f8a4286d 100644\n--- a/dbms/src/Storages/StorageXDBC.cpp\n+++ b/dbms/src/Storages/StorageXDBC.cpp\n@@ -64,7 +64,7 @@ std::function<void(std::ostream &)> StorageXDBC::getReadPOSTDataCallback(const N\n     size_t /*max_block_size*/) const\n {\n     String query = transformQueryForExternalDatabase(*query_info.query,\n-        getColumns().ordinary,\n+        getColumns().getOrdinary(),\n         bridge_helper->getIdentifierQuotingStyle(),\n         remote_database_name,\n         remote_table_name,\ndiff --git a/dbms/src/Storages/System/StorageSystemColumns.cpp b/dbms/src/Storages/System/StorageSystemColumns.cpp\nindex d94b8c0ab100..e55017479935 100644\n--- a/dbms/src/Storages/System/StorageSystemColumns.cpp\n+++ b/dbms/src/Storages/System/StorageSystemColumns.cpp\n@@ -88,10 +88,7 @@ class ColumnsBlockInputStream : public IBlockInputStream\n             const std::string table_name = (*tables)[db_table_num].get<std::string>();\n             ++db_table_num;\n \n-            NamesAndTypesList columns;\n-            ColumnDefaults column_defaults;\n-            ColumnComments column_comments;\n-            ColumnCodecs column_codecs;\n+            ColumnsDescription columns;\n             Names cols_required_for_partition_key;\n             Names cols_required_for_sorting_key;\n             Names cols_required_for_primary_key;\n@@ -119,10 +116,7 @@ class ColumnsBlockInputStream : public IBlockInputStream\n                         throw;\n                 }\n \n-                columns = storage->getColumns().getAll();\n-                column_codecs = storage->getColumns().codecs;\n-                column_defaults = storage->getColumns().defaults;\n-                column_comments = storage->getColumns().comments;\n+                columns = storage->getColumns();\n \n                 cols_required_for_partition_key = storage->getColumnsRequiredForPartitionKey();\n                 cols_required_for_sorting_key = storage->getColumnsRequiredForSortingKey();\n@@ -156,22 +150,19 @@ class ColumnsBlockInputStream : public IBlockInputStream\n                 if (columns_mask[src_index++])\n                     res_columns[res_index++]->insert(column.type->getName());\n \n+                if (column.default_desc.expression)\n                 {\n-                    const auto it = column_defaults.find(column.name);\n-                    if (it == std::end(column_defaults))\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insertDefault();\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insertDefault();\n-                    }\n-                    else\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insert(toString(it->second.kind));\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insert(queryToString(it->second.expression));\n-                    }\n+                    if (columns_mask[src_index++])\n+                        res_columns[res_index++]->insert(toString(column.default_desc.kind));\n+                    if (columns_mask[src_index++])\n+                        res_columns[res_index++]->insert(queryToString(column.default_desc.expression));\n+                }\n+                else\n+                {\n+                    if (columns_mask[src_index++])\n+                        res_columns[res_index++]->insertDefault();\n+                    if (columns_mask[src_index++])\n+                        res_columns[res_index++]->insertDefault();\n                 }\n \n                 {\n@@ -196,19 +187,8 @@ class ColumnsBlockInputStream : public IBlockInputStream\n                     }\n                 }\n \n-                {\n-                    const auto it = column_comments.find(column.name);\n-                    if (it == std::end(column_comments))\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insertDefault();\n-                    }\n-                    else\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insert(it->second);\n-                    }\n-                }\n+                if (columns_mask[src_index++])\n+                    res_columns[res_index++]->insert(column.comment);\n \n                 {\n                     auto find_in_vector = [&key = column.name](const Names& names)\n@@ -226,18 +206,12 @@ class ColumnsBlockInputStream : public IBlockInputStream\n                         res_columns[res_index++]->insert(find_in_vector(cols_required_for_sampling));\n                 }\n \n+                if (columns_mask[src_index++])\n                 {\n-                    const auto it = column_codecs.find(column.name);\n-                    if (it == std::end(column_codecs))\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insertDefault();\n-                    }\n+                    if (column.codec)\n+                        res_columns[res_index++]->insert(\"CODEC(\" + column.codec->getCodecDesc() + \")\");\n                     else\n-                    {\n-                        if (columns_mask[src_index++])\n-                            res_columns[res_index++]->insert(\"CODEC(\" + it->second->getCodecDesc() + \")\");\n-                    }\n+                        res_columns[res_index++]->insertDefault();\n                 }\n \n                 ++rows_count;\ndiff --git a/dbms/src/Storages/System/StorageSystemPartsBase.cpp b/dbms/src/Storages/System/StorageSystemPartsBase.cpp\nindex e65d780f629d..ca4ad4e91d90 100644\n--- a/dbms/src/Storages/System/StorageSystemPartsBase.cpp\n+++ b/dbms/src/Storages/System/StorageSystemPartsBase.cpp\n@@ -286,31 +286,21 @@ bool StorageSystemPartsBase::hasColumn(const String & column_name) const\n StorageSystemPartsBase::StorageSystemPartsBase(std::string name_, NamesAndTypesList && columns_)\n     : name(std::move(name_))\n {\n-    NamesAndTypesList aliases;\n-    ColumnDefaults defaults;\n+    ColumnsDescription columns(std::move(columns_));\n+\n     auto add_alias = [&](const String & alias_name, const String & column_name)\n     {\n-        DataTypePtr type;\n-        for (const NameAndTypePair & col : columns_)\n-        {\n-            if (col.name == column_name)\n-            {\n-                type = col.type;\n-                break;\n-            }\n-        }\n-        if (!type)\n-            throw Exception(\"No column \" + column_name + \" in table system.\" + name, ErrorCodes::LOGICAL_ERROR);\n-\n-        aliases.push_back({alias_name, type});\n-        defaults[alias_name] = ColumnDefault{ColumnDefaultKind::Alias, std::make_shared<ASTIdentifier>(column_name)};\n+        ColumnDescription column(alias_name, columns.get(column_name).type);\n+        column.default_desc.kind = ColumnDefaultKind::Alias;\n+        column.default_desc.expression = std::make_shared<ASTIdentifier>(column_name);\n+        columns.add(column);\n     };\n \n     /// Add aliases for old column names for backwards compatibility.\n     add_alias(\"bytes\", \"bytes_on_disk\");\n     add_alias(\"marks_size\", \"marks_bytes\");\n \n-    setColumns(ColumnsDescription(std::move(columns_), {}, std::move(aliases), std::move(defaults), ColumnComments{}, ColumnCodecs{}));\n+    setColumns(columns);\n }\n \n }\ndiff --git a/dbms/src/Storages/System/StorageSystemPartsColumns.cpp b/dbms/src/Storages/System/StorageSystemPartsColumns.cpp\nindex 6f9d234d51b0..f4abe7609cb5 100644\n--- a/dbms/src/Storages/System/StorageSystemPartsColumns.cpp\n+++ b/dbms/src/Storages/System/StorageSystemPartsColumns.cpp\n@@ -67,19 +67,14 @@ void StorageSystemPartsColumns::processNextStorage(MutableColumns & columns, con\n         String default_expression;\n     };\n \n-    NamesAndTypesList columns_list = info.storage->getColumns().getAll();\n-    const auto & column_defaults = info.storage->getColumns().defaults;\n     std::unordered_map<String, ColumnInfo> columns_info;\n-\n-    for (const auto & column : columns_list)\n+    for (const auto & column : info.storage->getColumns())\n     {\n         ColumnInfo column_info;\n-\n-        const auto it = column_defaults.find(column.name);\n-        if (it != std::end(column_defaults))\n+        if (column.default_desc.expression)\n         {\n-            column_info.default_kind = toString(it->second.kind);\n-            column_info.default_expression = queryToString(it->second.expression);\n+            column_info.default_kind = toString(column.default_desc.kind);\n+            column_info.default_expression = queryToString(column.default_desc.expression);\n         }\n \n         columns_info[column.name] = column_info;\ndiff --git a/dbms/src/Storages/getStructureOfRemoteTable.cpp b/dbms/src/Storages/getStructureOfRemoteTable.cpp\nindex e6e8cea7f78e..588d6ecc8c58 100644\n--- a/dbms/src/Storages/getStructureOfRemoteTable.cpp\n+++ b/dbms/src/Storages/getStructureOfRemoteTable.cpp\n@@ -89,29 +89,23 @@ ColumnsDescription getStructureOfRemoteTable(\n \n         for (size_t i = 0; i < size; ++i)\n         {\n-            String column_name = (*name)[i].get<const String &>();\n-            String data_type_name = (*type)[i].get<const String &>();\n-            String kind_name = (*default_kind)[i].get<const String &>();\n+            ColumnDescription column;\n \n-            auto data_type = data_type_factory.get(data_type_name);\n+            column.name = (*name)[i].get<const String &>();\n \n-            if (kind_name.empty())\n-                res.ordinary.emplace_back(column_name, std::move(data_type));\n-            else\n-            {\n-                auto kind = columnDefaultKindFromString(kind_name);\n+            String data_type_name = (*type)[i].get<const String &>();\n+            column.type = data_type_factory.get(data_type_name);\n \n+            String kind_name = (*default_kind)[i].get<const String &>();\n+            if (!kind_name.empty())\n+            {\n+                column.default_desc.kind = columnDefaultKindFromString(kind_name);\n                 String expr_str = (*default_expr)[i].get<const String &>();\n-                ASTPtr expr = parseQuery(expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), \"default expression\", 0);\n-                res.defaults.emplace(column_name, ColumnDefault{kind, expr});\n-\n-                if (ColumnDefaultKind::Default == kind)\n-                    res.ordinary.emplace_back(column_name, std::move(data_type));\n-                else if (ColumnDefaultKind::Materialized == kind)\n-                    res.materialized.emplace_back(column_name, std::move(data_type));\n-                else if (ColumnDefaultKind::Alias == kind)\n-                    res.aliases.emplace_back(column_name, std::move(data_type));\n+                column.default_desc.expression = parseQuery(\n+                    expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), \"default expression\", 0);\n             }\n+\n+            res.add(column);\n         }\n     }\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00079_defaulted_columns.reference b/dbms/tests/queries/0_stateless/00079_defaulted_columns.reference\nindex 8ae430dbd259..7e344830947b 100644\n--- a/dbms/tests/queries/0_stateless/00079_defaulted_columns.reference\n+++ b/dbms/tests/queries/0_stateless/00079_defaulted_columns.reference\n@@ -20,21 +20,21 @@ some string\t11\n hello clickhouse\t16\n some string\t11\n payload\tString\t\t\t\t\n-payload_length\tUInt64\tDEFAULT\tlength(payload)\t\t\n date\tDate\tMATERIALIZED\ttoday()\t\t\n key\tUInt64\tMATERIALIZED\t0 * rand()\t\t\n+payload_length\tUInt64\tDEFAULT\tlength(payload)\t\t\n hello clickhouse\t16\n some string\t11\n payload\tString\t\t\t\t\n-payload_length\tUInt16\tDEFAULT\tlength(payload) % 65535\t\t\n date\tDate\tMATERIALIZED\ttoday()\t\t\n key\tUInt64\tMATERIALIZED\t0 * rand()\t\t\n+payload_length\tUInt16\tDEFAULT\tlength(payload) % 65535\t\t\n hello clickhouse\t16\n some string\t11\n payload\tString\t\t\t\t\n-payload_length\tUInt16\tDEFAULT\tCAST(length(payload), \\'UInt16\\')\t\t\n date\tDate\tMATERIALIZED\ttoday()\t\t\n key\tUInt64\tMATERIALIZED\t0 * rand()\t\t\n+payload_length\tUInt16\tDEFAULT\tCAST(length(payload), \\'UInt16\\')\t\t\n payload\tString\t\t\t\t\n date\tDate\tMATERIALIZED\ttoday()\t\t\n key\tUInt64\tMATERIALIZED\t0 * rand()\t\t\ndiff --git a/dbms/tests/queries/0_stateless/00725_comment_columns.reference b/dbms/tests/queries/0_stateless/00725_comment_columns.reference\nindex 5d5f9422bd53..77b7c9415aff 100644\n--- a/dbms/tests/queries/0_stateless/00725_comment_columns.reference\n+++ b/dbms/tests/queries/0_stateless/00725_comment_columns.reference\n@@ -1,25 +1,25 @@\n-CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1\\',  fourth_column UInt8 COMMENT \\'comment 4\\',  fifth_column UInt8,  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3\\') ENGINE = TinyLog\n+CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1\\',  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3\\',  fourth_column UInt8 COMMENT \\'comment 4\\',  fifth_column UInt8) ENGINE = TinyLog\n first_column\tUInt8\tDEFAULT\t1\tcomment 1\t\n-fourth_column\tUInt8\t\t\tcomment 4\t\n-fifth_column\tUInt8\t\t\t\t\n second_column\tUInt8\tMATERIALIZED\tfirst_column\tcomment 2\t\n third_column\tUInt8\tALIAS\tsecond_column\tcomment 3\t\n+fourth_column\tUInt8\t\t\tcomment 4\t\n+fifth_column\tUInt8\t\t\t\t\n \u250c\u2500table\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500comment\u2500\u2500\u2500\u2510\n \u2502 check_query_comment_column \u2502 first_column  \u2502 comment 1 \u2502\n-\u2502 check_query_comment_column \u2502 fourth_column \u2502 comment 4 \u2502\n-\u2502 check_query_comment_column \u2502 fifth_column  \u2502           \u2502\n \u2502 check_query_comment_column \u2502 second_column \u2502 comment 2 \u2502\n \u2502 check_query_comment_column \u2502 third_column  \u2502 comment 3 \u2502\n+\u2502 check_query_comment_column \u2502 fourth_column \u2502 comment 4 \u2502\n+\u2502 check_query_comment_column \u2502 fifth_column  \u2502           \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1_1\\',  fourth_column UInt8 COMMENT \\'comment 4_1\\',  fifth_column UInt8 COMMENT \\'comment 5_1\\',  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2_1\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3_1\\') ENGINE = TinyLog\n+CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1_1\\',  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2_1\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3_1\\',  fourth_column UInt8 COMMENT \\'comment 4_1\\',  fifth_column UInt8 COMMENT \\'comment 5_1\\') ENGINE = TinyLog\n \u250c\u2500table\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500comment\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 check_query_comment_column \u2502 first_column  \u2502 comment 1_2 \u2502\n-\u2502 check_query_comment_column \u2502 fourth_column \u2502 comment 4_2 \u2502\n-\u2502 check_query_comment_column \u2502 fifth_column  \u2502 comment 5_2 \u2502\n \u2502 check_query_comment_column \u2502 second_column \u2502 comment 2_2 \u2502\n \u2502 check_query_comment_column \u2502 third_column  \u2502 comment 3_2 \u2502\n+\u2502 check_query_comment_column \u2502 fourth_column \u2502 comment 4_2 \u2502\n+\u2502 check_query_comment_column \u2502 fifth_column  \u2502 comment 5_2 \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1_2\\',  fourth_column UInt8 COMMENT \\'comment 4_2\\',  fifth_column UInt8 COMMENT \\'comment 5_2\\',  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2_2\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3_2\\') ENGINE = TinyLog\n+CREATE TABLE test.check_query_comment_column ( first_column UInt8 DEFAULT 1 COMMENT \\'comment 1_2\\',  second_column UInt8 MATERIALIZED first_column COMMENT \\'comment 2_2\\',  third_column UInt8 ALIAS second_column COMMENT \\'comment 3_2\\',  fourth_column UInt8 COMMENT \\'comment 4_2\\',  fifth_column UInt8 COMMENT \\'comment 5_2\\') ENGINE = TinyLog\n CREATE TABLE test.check_query_comment_column ( first_column UInt8 COMMENT \\'comment 1\\',  second_column UInt8 COMMENT \\'comment 2\\',  third_column UInt8 COMMENT \\'comment 3\\') ENGINE = MergeTree() PARTITION BY second_column ORDER BY first_column SAMPLE BY first_column SETTINGS index_granularity = 8192\n first_column\tUInt8\t\t\tcomment 1\t\n second_column\tUInt8\t\t\tcomment 2\t\ndiff --git a/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.reference b/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.reference\nnew file mode 100644\nindex 000000000000..a5e38b8e2a74\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.reference\n@@ -0,0 +1,3 @@\n+x\tUInt32\t\t\t\t\n+y\tString\tMATERIALIZED\ttoString(x)\t\t\n+z\tUInt64\t\t\t\t\ndiff --git a/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.sql b/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.sql\nnew file mode 100644\nindex 000000000000..125872a95106\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00916_add_materialized_column_after.sql\n@@ -0,0 +1,8 @@\n+DROP TABLE IF EXISTS test.add_materialized_column_after;\n+\n+CREATE TABLE test.add_materialized_column_after (x UInt32, z UInt64) ENGINE MergeTree ORDER BY x;\n+ALTER TABLE test.add_materialized_column_after ADD COLUMN y MATERIALIZED toString(x) AFTER x;\n+\n+DESC TABLE test.add_materialized_column_after;\n+\n+DROP TABLE test.add_materialized_column_after;\n",
  "problem_statement": "ALTER TABLE test ADD COLUMN column ALIAS CASE AFTER: Cannot find `column` to insert after\nGiven a table:\r\n\r\n```\r\nCREATE TABLE test(\r\n    date      Date,\r\n    type      UInt8,\r\n    id        UInt64\r\n) ENGINE = MergeTree(date, (id, date), 8192);\r\n```\r\n\r\nTrying to add a column after another one, with ALIAS CASE fails with: \r\n\r\n```\r\nALTER TABLE test ADD COLUMN _type Enum8(\r\n                            'ZERO' = 0,\r\n                            'ONE' = 1\r\n                    ) ALIAS CASE type\r\n                            WHEN 0 THEN 'ZERO'\r\n                            WHEN 1 THEN 'ONE'\r\n                            ELSE 'ZERO'\r\n                      END AFTER type;\r\n\r\nALTER TABLE test\r\n    ADD COLUMN\r\n    _type Enum8('ZERO' = 0, 'ONE' = 1) ALIAS caseWithExpression(type, 0, 'ZERO', 1, 'ONE', 'ZERO')     AFTER type\r\n\r\n\r\n\r\nReceived exception from server (version 1.1.54390):\r\nCode: 44. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Wrong column name. Cannot find column type to insert after.\r\n```\r\n\r\nSame behaviour is also with `version 18.10.54405`\r\n\n",
  "hints_text": "Known issue:\r\n- materialized columns and alias columns are grouped together and cannot be interleaved in table definition with ordinary columns.\r\n\r\nWe are going to fix it.",
  "created_at": "2019-03-15T15:01:16Z"
}