{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 75173,
  "instance_id": "ClickHouse__ClickHouse-75173",
  "issue_numbers": [
    "65389"
  ],
  "base_commit": "8789c96b7c46b48360d4710cec809da7159e2965",
  "patch": "diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex 26665754a167..ba4521bbf279 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -20,8 +20,9 @@\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSetQuery.h>\n \n-#include <Analyzer/Utils.h>\n+#include <Analyzer/InterpolateNode.h>\n #include <Analyzer/UnionNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -68,7 +69,7 @@ void QueryNode::resolveProjectionColumns(NamesAndTypes projection_columns_value)\n     projection_columns = std::move(projection_columns_value);\n }\n \n-void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns)\n+void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes)\n {\n     auto & projection_nodes = getProjection().getNodes();\n     size_t projection_columns_size = projection_columns.size();\n@@ -76,7 +77,7 @@ void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<std::stri\n \n     for (size_t i = 0; i < projection_columns_size; ++i)\n     {\n-        if (!used_projection_columns.contains(projection_columns[i].name))\n+        if (!used_projection_columns_indexes.contains(i))\n             continue;\n \n         projection_nodes[write_index] = projection_nodes[i];\n@@ -86,26 +87,23 @@ void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<std::stri\n \n     projection_nodes.erase(projection_nodes.begin() + write_index, projection_nodes.end());\n     projection_columns.erase(projection_columns.begin() + write_index, projection_columns.end());\n-}\n-\n-void QueryNode::removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes)\n-{\n-    auto & projection_nodes = getProjection().getNodes();\n-    size_t projection_columns_size = projection_columns.size();\n-    size_t write_index = 0;\n \n-    for (size_t i = 0; i < projection_columns_size; ++i)\n+    if (hasInterpolate())\n     {\n-        if (!used_projection_columns_indexes.contains(i))\n-            continue;\n-\n-        projection_nodes[write_index] = projection_nodes[i];\n-        projection_columns[write_index] = projection_columns[i];\n-        ++write_index;\n+        std::unordered_set<String> used_projection_columns;\n+        for (const auto & projection : projection_columns)\n+            used_projection_columns.insert(projection.name);\n+\n+        auto & interpolate_node = getInterpolate();\n+        auto & interpolate_list_nodes = interpolate_node->as<ListNode &>().getNodes();\n+        std::erase_if(\n+            interpolate_list_nodes,\n+            [&used_projection_columns](const QueryTreeNodePtr & interpolate)\n+            { return !used_projection_columns.contains(interpolate->as<InterpolateNode &>().getExpressionName()); });\n+\n+        if (interpolate_list_nodes.empty())\n+            interpolate_node = nullptr;\n     }\n-\n-    projection_nodes.erase(projection_nodes.begin() + write_index, projection_nodes.end());\n-    projection_columns.erase(projection_columns.begin() + write_index, projection_columns.end());\n }\n \n void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const\ndiff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex dbe4bac246bd..2ec1b96477c6 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -616,9 +616,6 @@ class QueryNode final : public IQueryTreeNode\n         projection_columns.clear();\n     }\n \n-    /// Remove unused projection columns\n-    void removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns);\n-\n     /// Remove unused projection columns\n     void removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes);\n \ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex 545a6b2195be..dcff552f07c9 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -115,32 +115,6 @@ NamesAndTypes UnionNode::computeProjectionColumns() const\n     return result_columns;\n }\n \n-void UnionNode::removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns)\n-{\n-    if (recursive_cte_table)\n-        return;\n-\n-    auto projection_columns = computeProjectionColumns();\n-    size_t projection_columns_size = projection_columns.size();\n-    std::unordered_set<size_t> used_projection_column_indexes;\n-\n-    for (size_t i = 0; i < projection_columns_size; ++i)\n-    {\n-        const auto & projection_column = projection_columns[i];\n-        if (used_projection_columns.contains(projection_column.name))\n-            used_projection_column_indexes.insert(i);\n-    }\n-\n-    auto & query_nodes = getQueries().getNodes();\n-    for (auto & query_node : query_nodes)\n-    {\n-        if (auto * query_node_typed = query_node->as<QueryNode>())\n-            query_node_typed->removeUnusedProjectionColumns(used_projection_column_indexes);\n-        else if (auto * union_node_typed = query_node->as<UnionNode>())\n-            union_node_typed->removeUnusedProjectionColumns(used_projection_column_indexes);\n-    }\n-}\n-\n void UnionNode::removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes)\n {\n     if (recursive_cte_table)\ndiff --git a/src/Analyzer/UnionNode.h b/src/Analyzer/UnionNode.h\nindex 8cbc50da8235..09018156e2d1 100644\n--- a/src/Analyzer/UnionNode.h\n+++ b/src/Analyzer/UnionNode.h\n@@ -167,9 +167,6 @@ class UnionNode final : public IQueryTreeNode\n     /// Compute union node projection columns\n     NamesAndTypes computeProjectionColumns() const;\n \n-    /// Remove unused projection columns\n-    void removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns);\n-\n     /// Remove unused projection columns\n     void removeUnusedProjectionColumns(const std::unordered_set<size_t> & used_projection_columns_indexes);\n \ndiff --git a/src/Planner/PlannerExpressionAnalysis.h b/src/Planner/PlannerExpressionAnalysis.h\nindex 283fcac7abab..9ae2e672af93 100644\n--- a/src/Planner/PlannerExpressionAnalysis.h\n+++ b/src/Planner/PlannerExpressionAnalysis.h\n@@ -1,7 +1,6 @@\n #pragma once\n \n #include <Core/ColumnsWithTypeAndName.h>\n-#include <Core/InterpolateDescription.h>\n \n #include <Analyzer/IQueryTreeNode.h>\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03322_unused_interpolate_expressions.reference b/tests/queries/0_stateless/03322_unused_interpolate_expressions.reference\nnew file mode 100644\nindex 000000000000..105b40f760c0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03322_unused_interpolate_expressions.reference\n@@ -0,0 +1,9 @@\n+0\n+1\n+2\n+0\t50\n+1\t-27\n+2\t-28\n+0\t50\t-123\n+1\t-27\t6\n+2\t-28\t97\ndiff --git a/tests/queries/0_stateless/03322_unused_interpolate_expressions.sql b/tests/queries/0_stateless/03322_unused_interpolate_expressions.sql\nnew file mode 100644\nindex 000000000000..fbdc49812c71\n--- /dev/null\n+++ b/tests/queries/0_stateless/03322_unused_interpolate_expressions.sql\n@@ -0,0 +1,60 @@\n+CREATE TABLE foo (\n+     open_time Int64,\n+     open_price Int8,\n+     close_price Int8\n+)\n+ENGINE = MergeTree\n+ORDER BY open_time;\n+\n+INSERT INTO foo SELECT number, cityHash64(number) % 256, cityHash64(number * number) % 256 FROM numbers(30);\n+\n+-- Both interpolate expression are removed\n+SELECT\n+    group_id\n+FROM (\n+\tSELECT\n+\t    intDiv(open_time, 10) AS group_id,\n+\t    toFloat64(argMin(open_price, open_time)) as open,\n+\t    toFloat64(argMax(close_price, open_time)) as close\n+\tFROM\n+\t    foo\n+\tGROUP BY\n+\t    group_id\n+\tORDER BY group_id ASC WITH FILL STEP 1 INTERPOLATE (\n+\t    open, close\n+\t)\n+);\n+\n+-- `close` interpolate expression is removed\n+SELECT\n+    group_id, open\n+FROM (\n+\tSELECT\n+\t    intDiv(open_time, 10) AS group_id,\n+\t    toFloat64(argMin(open_price, open_time)) as open,\n+\t    toFloat64(argMax(close_price, open_time)) as close\n+\tFROM\n+\t    foo\n+\tGROUP BY\n+\t    group_id\n+\tORDER BY group_id ASC WITH FILL STEP 1 INTERPOLATE (\n+\t    open, close\n+\t)\n+);\n+\n+-- Both interpolate expressions are kept\n+SELECT\n+    group_id, open, close\n+FROM (\n+\tSELECT\n+\t    intDiv(open_time, 10) AS group_id,\n+\t    toFloat64(argMin(open_price, open_time)) as open,\n+\t    toFloat64(argMax(close_price, open_time)) as close\n+\tFROM\n+\t    foo\n+\tGROUP BY\n+\t    group_id\n+\tORDER BY group_id ASC WITH FILL STEP 1 INTERPOLATE (\n+\t    open, close\n+\t)\n+);\n",
  "problem_statement": "DB::Exception Not found column after upgrading from 23.8 to 24.5\n**Describe what's wrong**\r\n\r\nAfter upgrading to version 24.5.x, the request start  failing with the following error:\r\n \r\n```\r\nSQL Error [10] [07000]: Code: 10. DB::Exception: Not found column toFloat64(argMax(__table2.close_price, __table2.open_time)) in block. There are only columns: toDateTime64(toStartOfInterval(__table2.open_time, _CAST(1_IntervalHour, 'IntervalHour'_String)), 3_UInt8), argMin(__table2.open_price, __table2.open_time), argMax(__table2.close_price, __table2.open_time), toFloat64(argMin(__table2.open_price, __table2.open_time)). (NOT_FOUND_COLUMN_IN_BLOCK) (version 24.5.3.5 (official build))\r\n```\r\n\r\n**Does it reproduce on the most recent release?**\r\n\r\n24.3 - 24.5.3.5\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nCREATE TABLE foo_klines (\r\n     open_time DateTime64(3),\r\n     close_time DateTime64(3),\r\n     open_price Decimal64(8),\r\n     close_price Decimal64(8),\r\n     high_price Decimal64(8),\r\n     low_price Decimal64(8)\r\n)\r\nENGINE = ReplacingMergeTree\r\nPARTITION BY toYYYYMM(open_time)\r\nORDER BY open_time;\r\n\r\n\r\nCREATE TABLE bar_klines (\r\n    `time` DateTime64(0),\r\n    open_price Decimal64(8),\r\n    close_price Decimal64(8),\r\n    high_price Decimal64(8),\r\n    low_price Decimal64(8)\r\n)\r\nENGINE = ReplacingMergeTree\r\nPARTITION BY toYYYYMM(time)\r\nORDER BY time;\r\n\r\n\r\nSELECT\r\n    toUnixTimestamp64Milli(q0.open_time) as open_time,\r\n    q0.open * q1.close as open\r\nFROM (\r\n\tSELECT\r\n\t    toDateTime64(group_time, 3) as open_time,\r\n\t    toFloat64(argMin(open_price, t0.open_time)) as open,\r\n\t    toFloat64(argMax(close_price, t0.open_time)) as close\r\n\tFROM\r\n\t    foo_klines  as t0\r\n\tGROUP BY \r\n\t    toStartOfInterval(t0.open_time, INTERVAL 1 HOUR) as group_time\r\n\tORDER BY open_time ASC WITH FILL STEP INTERVAL 1 HOUR INTERPOLATE (\r\n\t    open, close\r\n\t)\r\n) q0 INNER JOIN (\r\n\tSELECT\r\n\t    toDateTime64(group_time, 3) as open_time,\r\n\t    toFloat64(argMax(close_price, t1.time)) as close\r\n\tFROM\r\n\t    bar_klines as t1\r\n\tGROUP BY \r\n\t    toStartOfInterval(t1.time, INTERVAL 1 HOUR) as group_time\r\n\tORDER BY open_time ASC WITH FILL STEP INTERVAL 1 HOUR INTERPOLATE (\r\n\t    close\r\n\t)\r\n) q1 ON q0.open_time = q1.open_time\r\nORDER BY open_time ASC;\r\n```\r\n\r\n**Expected behavior**\r\n\r\nThe result will be returned without any exceptions, just as in version 23.8\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\nSQL Error [10] [07000]: Code: 10. DB::Exception: Not found column toFloat64(argMax(__table2.close_price, __table2.open_time)) in block. There are only columns: toDateTime64(toStartOfInterval(__table2.open_time, _CAST(1_IntervalHour, 'IntervalHour'_String)), 3_UInt8), argMin(__table2.open_price, __table2.open_time), argMax(__table2.close_price, __table2.open_time), toFloat64(argMin(__table2.open_price, __table2.open_time)). (NOT_FOUND_COLUMN_IN_BLOCK) (version 24.5.3.5 (official build))\r\n```\r\n\r\n**Additional context**\r\n\r\nThe same query work  like a charm in versions 23.8 - 24.2\r\n\n",
  "hints_text": "try\r\n\r\n```\r\ncat /etc/clickhouse-server/users.d/allow_experimental_analyzer.xml\r\n<?xml version=\"1.0\" ?>\r\n<clickhouse>\r\n    <profiles>\r\n        <default>\r\n            <allow_experimental_analyzer>0</allow_experimental_analyzer>\r\n        </default>\r\n    </profiles>\r\n</clickhouse>\r\n```\nworks with disabled analyzer  https://fiddle.clickhouse.com/30cc0579-ad35-4c58-bc7c-1ecfa9ac11f8\n@den-crane God bless you! You're a lifesaver! Thanks\n~It's a duplicate of #62946~\r\n\r\nI'm wrong\nIt seems like there's a bug in `RemoveUnusedProjectionColumnsPass.`\r\nIt thinks `toFloat64(argMax(close_price, t0.open_time))) as close` is unused in the left table expression, so it is removed from the projection list.\nYou can remove the `close` expression from the `INTERPOLATE` clause of the left join expression and run this query with the new analyzer as a workaround.\r\n\r\n```sql\r\nSELECT\r\n    toUnixTimestamp64Milli(q0.open_time) as open_time,\r\n    q0.open * q1.close as open\r\nFROM (\r\n\tSELECT\r\n\t    toDateTime64(group_time, 3) as open_time,\r\n\t    toFloat64(argMin(open_price, t0.open_time)) as open,\r\n\t    toFloat64(argMax(close_price, t0.open_time)) as close\r\n\tFROM\r\n\t    foo_klines  as t0\r\n\tGROUP BY \r\n\t    toStartOfInterval(t0.open_time, INTERVAL 1 HOUR) as group_time\r\n\tORDER BY open_time ASC WITH FILL STEP INTERVAL 1 HOUR INTERPOLATE (\r\n\t    open\r\n\t)\r\n) q0 INNER JOIN (\r\n\tSELECT\r\n\t    toDateTime64(group_time, 3) as open_time,\r\n\t    toFloat64(argMax(close_price, t1.time)) as close\r\n\tFROM\r\n\t    bar_klines as t1\r\n\tGROUP BY \r\n\t    toStartOfInterval(t1.time, INTERVAL 1 HOUR) as group_time\r\n\tORDER BY open_time ASC WITH FILL STEP INTERVAL 1 HOUR INTERPOLATE (\r\n\t    close\r\n\t)\r\n) q1 ON q0.open_time = q1.open_time\r\nORDER BY open_time ASC;\r\n```",
  "created_at": "2025-01-28T17:17:37Z"
}