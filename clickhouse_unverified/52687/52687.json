{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52687,
  "instance_id": "ClickHouse__ClickHouse-52687",
  "issue_numbers": [
    "51609"
  ],
  "base_commit": "9448d42aea6c5befae09cc923570fd6575a6d6f8",
  "patch": "diff --git a/docs/README.md b/docs/README.md\nindex 0cd35a4e3ec1..d12603121661 100644\n--- a/docs/README.md\n+++ b/docs/README.md\n@@ -200,8 +200,8 @@ Templates:\n - [Server Setting](_description_templates/template-server-setting.md)\n - [Database or Table engine](_description_templates/template-engine.md)\n - [System table](_description_templates/template-system-table.md)\n-- [Data type](_description_templates/data-type.md)\n-- [Statement](_description_templates/statement.md)\n+- [Data type](_description_templates/template-data-type.md)\n+- [Statement](_description_templates/template-statement.md)\n \n \n <a name=\"how-to-build-docs\"/>\ndiff --git a/docs/en/development/continuous-integration.md b/docs/en/development/continuous-integration.md\nindex 738c5458cc39..c76ab738004d 100644\n--- a/docs/en/development/continuous-integration.md\n+++ b/docs/en/development/continuous-integration.md\n@@ -141,6 +141,10 @@ Runs [stateful functional tests](tests.md#functional-tests). Treat them in the s\n Runs [integration tests](tests.md#integration-tests).\n \n \n+## Bugfix validate check\n+Checks that either a new test (functional or integration) or there some changed tests that fail with the binary built on master branch. This check is triggered when pull request has \"pr-bugfix\" label.\n+\n+\n ## Stress Test\n Runs stateless functional tests concurrently from several clients to detect\n concurrency-related errors. If it fails:\ndiff --git a/docs/en/engines/table-engines/integrations/deltalake.md b/docs/en/engines/table-engines/integrations/deltalake.md\nindex b562e9d7fe6f..964c952f31af 100644\n--- a/docs/en/engines/table-engines/integrations/deltalake.md\n+++ b/docs/en/engines/table-engines/integrations/deltalake.md\n@@ -22,7 +22,7 @@ CREATE TABLE deltalake\n - `url` \u2014 Bucket url with path to the existing Delta Lake table.\n - `aws_access_key_id`, `aws_secret_access_key` - Long-term credentials for the [AWS](https://aws.amazon.com/) account user.  You can use these to authenticate your requests. Parameter is optional. If credentials are not specified, they are used from the configuration file.\n \n-Engine parameters can be specified using [Named Collections](../../../operations/named-collections.md)\n+Engine parameters can be specified using [Named Collections](/docs/en/operations/named-collections.md).\n \n **Example**\n \ndiff --git a/docs/en/engines/table-engines/integrations/hudi.md b/docs/en/engines/table-engines/integrations/hudi.md\nindex c60618af2893..b2f599e5c92b 100644\n--- a/docs/en/engines/table-engines/integrations/hudi.md\n+++ b/docs/en/engines/table-engines/integrations/hudi.md\n@@ -22,7 +22,7 @@ CREATE TABLE hudi_table\n - `url` \u2014 Bucket url with the path to an existing Hudi table.\n - `aws_access_key_id`, `aws_secret_access_key` - Long-term credentials for the [AWS](https://aws.amazon.com/) account user.  You can use these to authenticate your requests. Parameter is optional. If credentials are not specified, they are used from the configuration file.\n \n-Engine parameters can be specified using [Named Collections](../../../operations/named-collections.md)\n+Engine parameters can be specified using [Named Collections](/docs/en/operations/named-collections.md).\n \n **Example**\n \ndiff --git a/docs/en/sql-reference/statements/alter/index.md b/docs/en/sql-reference/statements/alter/index.md\nindex 7dadc2be5b2c..dca34d16f25f 100644\n--- a/docs/en/sql-reference/statements/alter/index.md\n+++ b/docs/en/sql-reference/statements/alter/index.md\n@@ -36,6 +36,8 @@ These `ALTER` statements modify entities related to role-based access control:\n \n [ALTER TABLE ... MODIFY COMMENT](/docs/en/sql-reference/statements/alter/comment.md) statement adds, modifies, or removes comments to the table, regardless if it was set before or not.\n \n+[ALTER NAMED COLLECTION](/docs/en/sql-reference/statements/alter/named-collection.md) statement modifies [Named Collections](/docs/en/operations/named-collections.md).\n+\n ## Mutations\n \n `ALTER` queries that are intended to manipulate table data are implemented with a mechanism called \u201cmutations\u201d, most notably [ALTER TABLE \u2026 DELETE](/docs/en/sql-reference/statements/alter/delete.md) and [ALTER TABLE \u2026 UPDATE](/docs/en/sql-reference/statements/alter/update.md). They are asynchronous background processes similar to merges in [MergeTree](/docs/en/engines/table-engines/mergetree-family/index.md) tables that to produce new \u201cmutated\u201d versions of parts.\ndiff --git a/docs/en/sql-reference/statements/alter/named-collection.md b/docs/en/sql-reference/statements/alter/named-collection.md\nnew file mode 100644\nindex 000000000000..ac6752127c19\n--- /dev/null\n+++ b/docs/en/sql-reference/statements/alter/named-collection.md\n@@ -0,0 +1,30 @@\n+---\n+slug: /en/sql-reference/statements/alter/named-collection\n+sidebar_label: NAMED COLLECTION\n+---\n+\n+# ALTER NAMED COLLECTION\n+\n+This query intends to modify already existing named collections.\n+\n+**Syntax**\n+\n+```sql\n+ALTER NAMED COLLECTION [IF EXISTS] name [ON CLUSTER cluster]\n+[ SET\n+key_name1 = 'some value',\n+key_name2 = 'some value',\n+key_name3 = 'some value',\n+... ] |\n+[ DELETE key_name4, key_name5, ... ]\n+```\n+\n+**Example**\n+\n+```sql\n+CREATE NAMED COLLECTION foobar AS a = '1', b = '2';\n+\n+ALTER NAMED COLLECTION foobar SET a = '2', c = '3';\n+\n+ALTER NAMED COLLECTION foobar DELETE b;\n+```\ndiff --git a/docs/en/sql-reference/statements/create/index.md b/docs/en/sql-reference/statements/create/index.md\nindex 14e29d051d77..fa39526a53e7 100644\n--- a/docs/en/sql-reference/statements/create/index.md\n+++ b/docs/en/sql-reference/statements/create/index.md\n@@ -8,13 +8,14 @@ sidebar_label: CREATE\n \n Create queries make a new entity of one of the following kinds:\n \n-- [DATABASE](../../../sql-reference/statements/create/database.md)\n-- [TABLE](../../../sql-reference/statements/create/table.md)\n-- [VIEW](../../../sql-reference/statements/create/view.md)\n-- [DICTIONARY](../../../sql-reference/statements/create/dictionary.md)\n-- [FUNCTION](../../../sql-reference/statements/create/function.md)\n-- [USER](../../../sql-reference/statements/create/user.md)\n-- [ROLE](../../../sql-reference/statements/create/role.md)\n-- [ROW POLICY](../../../sql-reference/statements/create/row-policy.md)\n-- [QUOTA](../../../sql-reference/statements/create/quota.md)\n-- [SETTINGS PROFILE](../../../sql-reference/statements/create/settings-profile.md)\n+- [DATABASE](/docs/en/sql-reference/statements/create/database.md)\n+- [TABLE](/docs/en/sql-reference/statements/create/table.md)\n+- [VIEW](/docs/en/sql-reference/statements/create/view.md)\n+- [DICTIONARY](/docs/en/sql-reference/statements/create/dictionary.md)\n+- [FUNCTION](/docs/en/sql-reference/statements/create/function.md)\n+- [USER](/docs/en/sql-reference/statements/create/user.md)\n+- [ROLE](/docs/en/sql-reference/statements/create/role.md)\n+- [ROW POLICY](/docs/en/sql-reference/statements/create/row-policy.md)\n+- [QUOTA](/docs/en/sql-reference/statements/create/quota.md)\n+- [SETTINGS PROFILE](/docs/en/sql-reference/statements/create/settings-profile.md)\n+- [NAMED COLLECTION](/docs/en/sql-reference/statements/create/named-collection.md)\ndiff --git a/docs/en/sql-reference/statements/create/named-collection.md b/docs/en/sql-reference/statements/create/named-collection.md\nnew file mode 100644\nindex 000000000000..1fc7b11c5543\n--- /dev/null\n+++ b/docs/en/sql-reference/statements/create/named-collection.md\n@@ -0,0 +1,34 @@\n+---\n+slug: /en/sql-reference/statements/create/named-collection\n+sidebar_label: NAMED COLLECTION\n+---\n+\n+# CREATE NAMED COLLECTION\n+\n+Creates a new named collection.\n+\n+**Syntax**\n+\n+```sql\n+CREATE NAMED COLLECTION [IF NOT EXISTS] name [ON CLUSTER cluster] AS\n+key_name1 = 'some value',\n+key_name2 = 'some value',\n+key_name3 = 'some value',\n+...\n+```\n+\n+**Example**\n+\n+```sql\n+CREATE NAMED COLLECTION foobar AS a = '1', b = '2';\n+```\n+\n+**Related statements**\n+\n+- [CREATE NAMED COLLECTION](https://clickhouse.com/docs/en/sql-reference/statements/alter/named-collection)\n+- [DROP NAMED COLLECTION](https://clickhouse.com/docs/en/sql-reference/statements/drop#drop-function)\n+\n+\n+**See Also**\n+\n+- [Named collections guide](/docs/en/operations/named-collections.md)\ndiff --git a/docs/en/sql-reference/statements/drop.md b/docs/en/sql-reference/statements/drop.md\nindex b6208c2fd52a..c91457993c44 100644\n--- a/docs/en/sql-reference/statements/drop.md\n+++ b/docs/en/sql-reference/statements/drop.md\n@@ -119,3 +119,20 @@ DROP FUNCTION [IF EXISTS] function_name [on CLUSTER cluster]\n CREATE FUNCTION linear_equation AS (x, k, b) -> k*x + b;\n DROP FUNCTION linear_equation;\n ```\n+\n+## DROP NAMED COLLECTION\n+\n+Deletes a named collection.\n+\n+**Syntax**\n+\n+``` sql\n+DROP NAMED COLLECTION [IF EXISTS] name [on CLUSTER cluster]\n+```\n+\n+**Example**\n+\n+``` sql\n+CREATE NAMED COLLECTION foobar AS a = '1', b = '2';\n+DROP NAMED COLLECTION foobar;\n+```\ndiff --git a/docs/en/sql-reference/table-functions/iceberg.md b/docs/en/sql-reference/table-functions/iceberg.md\nindex 30db0ef00aa7..fa86b436a5e2 100644\n--- a/docs/en/sql-reference/table-functions/iceberg.md\n+++ b/docs/en/sql-reference/table-functions/iceberg.md\n@@ -21,7 +21,7 @@ iceberg(url [,aws_access_key_id, aws_secret_access_key] [,format] [,structure])\n - `format` \u2014 The [format](/docs/en/interfaces/formats.md/#formats) of the file. By default `Parquet` is used.\n - `structure` \u2014 Structure of the table. Format `'column1_name column1_type, column2_name column2_type, ...'`.\n \n-Engine parameters can be specified using [Named Collections](../../operations/named-collections.md)\n+Engine parameters can be specified using [Named Collections](/docs/en/operations/named-collections.md).\n \n **Returned value**\n \ndiff --git a/src/Common/NamedCollections/NamedCollectionUtils.cpp b/src/Common/NamedCollections/NamedCollectionUtils.cpp\nindex 6ec09fb8a77f..cab844d6213d 100644\n--- a/src/Common/NamedCollections/NamedCollectionUtils.cpp\n+++ b/src/Common/NamedCollections/NamedCollectionUtils.cpp\n@@ -8,6 +8,7 @@\n #include <Parsers/formatAST.h>\n #include <Parsers/ASTCreateNamedCollectionQuery.h>\n #include <Parsers/ASTAlterNamedCollectionQuery.h>\n+#include <Parsers/ASTDropNamedCollectionQuery.h>\n #include <Parsers/ASTSetQuery.h>\n #include <Parsers/ASTCreateQuery.h>\n #include <Parsers/parseQuery.h>\n@@ -225,24 +226,15 @@ class LoadFromSQL : private WithContext\n \n     void remove(const std::string & collection_name)\n     {\n-        if (!removeIfExists(collection_name))\n+        auto collection_path = getMetadataPath(collection_name);\n+        if (!fs::exists(collection_path))\n         {\n             throw Exception(\n                 ErrorCodes::NAMED_COLLECTION_DOESNT_EXIST,\n                 \"Cannot remove collection `{}`, because it doesn't exist\",\n                 collection_name);\n         }\n-    }\n-\n-    bool removeIfExists(const std::string & collection_name)\n-    {\n-        auto collection_path = getMetadataPath(collection_name);\n-        if (fs::exists(collection_path))\n-        {\n-            fs::remove(collection_path);\n-            return true;\n-        }\n-        return false;\n+        fs::remove(collection_path);\n     }\n \n private:\n@@ -393,36 +385,64 @@ void loadIfNot()\n     return loadIfNotUnlocked(lock);\n }\n \n-void removeFromSQL(const std::string & collection_name, ContextPtr context)\n+void removeFromSQL(const ASTDropNamedCollectionQuery & query, ContextPtr context)\n {\n     auto lock = lockNamedCollectionsTransaction();\n     loadIfNotUnlocked(lock);\n-    LoadFromSQL(context).remove(collection_name);\n-    NamedCollectionFactory::instance().remove(collection_name);\n-}\n-\n-void removeIfExistsFromSQL(const std::string & collection_name, ContextPtr context)\n-{\n-    auto lock = lockNamedCollectionsTransaction();\n-    loadIfNotUnlocked(lock);\n-    LoadFromSQL(context).removeIfExists(collection_name);\n-    NamedCollectionFactory::instance().removeIfExists(collection_name);\n+    auto & instance = NamedCollectionFactory::instance();\n+    if (!instance.exists(query.collection_name))\n+    {\n+        if (!query.if_exists)\n+        {\n+            throw Exception(\n+                ErrorCodes::NAMED_COLLECTION_DOESNT_EXIST,\n+                \"Cannot remove collection `{}`, because it doesn't exist\",\n+                query.collection_name);\n+        }\n+        return;\n+    }\n+    LoadFromSQL(context).remove(query.collection_name);\n+    instance.remove(query.collection_name);\n }\n \n void createFromSQL(const ASTCreateNamedCollectionQuery & query, ContextPtr context)\n {\n     auto lock = lockNamedCollectionsTransaction();\n     loadIfNotUnlocked(lock);\n-    NamedCollectionFactory::instance().add(query.collection_name, LoadFromSQL(context).create(query));\n+    auto & instance = NamedCollectionFactory::instance();\n+    if (instance.exists(query.collection_name))\n+    {\n+        if (!query.if_not_exists)\n+        {\n+            throw Exception(\n+                ErrorCodes::NAMED_COLLECTION_ALREADY_EXISTS,\n+                \"A named collection `{}` already exists\",\n+                query.collection_name);\n+        }\n+        return;\n+    }\n+    instance.add(query.collection_name, LoadFromSQL(context).create(query));\n }\n \n void updateFromSQL(const ASTAlterNamedCollectionQuery & query, ContextPtr context)\n {\n     auto lock = lockNamedCollectionsTransaction();\n     loadIfNotUnlocked(lock);\n+    auto & instance = NamedCollectionFactory::instance();\n+    if (!instance.exists(query.collection_name))\n+    {\n+        if (!query.if_exists)\n+        {\n+            throw Exception(\n+                ErrorCodes::NAMED_COLLECTION_DOESNT_EXIST,\n+                \"Cannot remove collection `{}`, because it doesn't exist\",\n+                query.collection_name);\n+        }\n+        return;\n+    }\n     LoadFromSQL(context).update(query);\n \n-    auto collection = NamedCollectionFactory::instance().getMutable(query.collection_name);\n+    auto collection = instance.getMutable(query.collection_name);\n     auto collection_lock = collection->lock();\n \n     for (const auto & [name, value] : query.changes)\ndiff --git a/src/Common/NamedCollections/NamedCollectionUtils.h b/src/Common/NamedCollections/NamedCollectionUtils.h\nindex c929abb5d74a..6cbe91015508 100644\n--- a/src/Common/NamedCollections/NamedCollectionUtils.h\n+++ b/src/Common/NamedCollections/NamedCollectionUtils.h\n@@ -8,6 +8,7 @@ namespace DB\n \n class ASTCreateNamedCollectionQuery;\n class ASTAlterNamedCollectionQuery;\n+class ASTDropNamedCollectionQuery;\n \n namespace NamedCollectionUtils\n {\n@@ -26,8 +27,7 @@ void reloadFromConfig(const Poco::Util::AbstractConfiguration & config);\n void loadFromSQL(ContextPtr context);\n \n /// Remove collection as well as its metadata from `context->getPath() / named_collections /`.\n-void removeFromSQL(const std::string & collection_name, ContextPtr context);\n-void removeIfExistsFromSQL(const std::string & collection_name, ContextPtr context);\n+void removeFromSQL(const ASTDropNamedCollectionQuery & query, ContextPtr context);\n \n /// Create a new collection from AST and put it to `context->getPath() / named_collections /`.\n void createFromSQL(const ASTCreateNamedCollectionQuery & query, ContextPtr context);\ndiff --git a/src/Coordination/KeeperSnapshotManagerS3.cpp b/src/Coordination/KeeperSnapshotManagerS3.cpp\nindex 0b1354422659..cbb5c110eda8 100644\n--- a/src/Coordination/KeeperSnapshotManagerS3.cpp\n+++ b/src/Coordination/KeeperSnapshotManagerS3.cpp\n@@ -218,7 +218,7 @@ void KeeperSnapshotManagerS3::uploadSnapshotImpl(const SnapshotFileInfo & snapsh\n             }\n             catch (...)\n             {\n-                LOG_INFO(log, \"Failed to delete lock file for {} from S3\", snapshot_path);\n+                LOG_INFO(log, \"Failed to delete lock file for {} from S3\", snapshot_file_info.path);\n                 tryLogCurrentException(__PRETTY_FUNCTION__);\n             }\n         });\ndiff --git a/src/Interpreters/InterpreterCreateNamedCollectionQuery.cpp b/src/Interpreters/InterpreterCreateNamedCollectionQuery.cpp\nindex bac599980627..3b0fba5fd9fa 100644\n--- a/src/Interpreters/InterpreterCreateNamedCollectionQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateNamedCollectionQuery.cpp\n@@ -1,5 +1,4 @@\n #include <Interpreters/InterpreterCreateNamedCollectionQuery.h>\n-\n #include <Parsers/ASTCreateNamedCollectionQuery.h>\n #include <Access/ContextAccess.h>\n #include <Interpreters/Context.h>\ndiff --git a/src/Interpreters/InterpreterDropNamedCollectionQuery.cpp b/src/Interpreters/InterpreterDropNamedCollectionQuery.cpp\nindex cc3444bb4df0..fe49b1cfd7c8 100644\n--- a/src/Interpreters/InterpreterDropNamedCollectionQuery.cpp\n+++ b/src/Interpreters/InterpreterDropNamedCollectionQuery.cpp\n@@ -22,11 +22,7 @@ BlockIO InterpreterDropNamedCollectionQuery::execute()\n         return executeDDLQueryOnCluster(query_ptr, current_context, params);\n     }\n \n-    if (query.if_exists)\n-        NamedCollectionUtils::removeIfExistsFromSQL(query.collection_name, current_context);\n-    else\n-        NamedCollectionUtils::removeFromSQL(query.collection_name, current_context);\n-\n+    NamedCollectionUtils::removeFromSQL(query, current_context);\n     return {};\n }\n \ndiff --git a/src/Parsers/ASTAlterNamedCollectionQuery.cpp b/src/Parsers/ASTAlterNamedCollectionQuery.cpp\nindex 7e95147ad753..6363a7306bda 100644\n--- a/src/Parsers/ASTAlterNamedCollectionQuery.cpp\n+++ b/src/Parsers/ASTAlterNamedCollectionQuery.cpp\n@@ -15,6 +15,8 @@ ASTPtr ASTAlterNamedCollectionQuery::clone() const\n void ASTAlterNamedCollectionQuery::formatImpl(const IAST::FormatSettings & settings, IAST::FormatState &, IAST::FormatStateStacked) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"Alter NAMED COLLECTION \";\n+    if (if_exists)\n+        settings.ostr << \"IF EXISTS \";\n     settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(collection_name) << (settings.hilite ? hilite_none : \"\");\n     formatOnCluster(settings);\n     if (!changes.empty())\ndiff --git a/src/Parsers/ASTCreateNamedCollectionQuery.cpp b/src/Parsers/ASTCreateNamedCollectionQuery.cpp\nindex 97e83541f057..45ef8565148c 100644\n--- a/src/Parsers/ASTCreateNamedCollectionQuery.cpp\n+++ b/src/Parsers/ASTCreateNamedCollectionQuery.cpp\n@@ -18,6 +18,8 @@ ASTPtr ASTCreateNamedCollectionQuery::clone() const\n void ASTCreateNamedCollectionQuery::formatImpl(const IAST::FormatSettings & settings, IAST::FormatState &, IAST::FormatStateStacked) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"CREATE NAMED COLLECTION \";\n+    if (if_not_exists)\n+        settings.ostr << \"IF NOT EXISTS \";\n     settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(collection_name) << (settings.hilite ? hilite_none : \"\");\n \n     formatOnCluster(settings);\ndiff --git a/src/Parsers/ASTCreateNamedCollectionQuery.h b/src/Parsers/ASTCreateNamedCollectionQuery.h\nindex 303d19019316..785aeb781b4b 100644\n--- a/src/Parsers/ASTCreateNamedCollectionQuery.h\n+++ b/src/Parsers/ASTCreateNamedCollectionQuery.h\n@@ -13,6 +13,7 @@ class ASTCreateNamedCollectionQuery : public IAST, public ASTQueryWithOnCluster\n public:\n     std::string collection_name;\n     SettingsChanges changes;\n+    bool if_not_exists = false;\n \n     String getID(char) const override { return \"CreateNamedCollectionQuery\"; }\n \ndiff --git a/src/Parsers/ASTDropNamedCollectionQuery.cpp b/src/Parsers/ASTDropNamedCollectionQuery.cpp\nindex 3b8568cfd70c..e317681d33df 100644\n--- a/src/Parsers/ASTDropNamedCollectionQuery.cpp\n+++ b/src/Parsers/ASTDropNamedCollectionQuery.cpp\n@@ -13,6 +13,8 @@ ASTPtr ASTDropNamedCollectionQuery::clone() const\n void ASTDropNamedCollectionQuery::formatImpl(const IAST::FormatSettings & settings, IAST::FormatState &, IAST::FormatStateStacked) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"DROP NAMED COLLECTION \";\n+    if (if_exists)\n+        settings.ostr << \"IF EXISTS \";\n     settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(collection_name) << (settings.hilite ? hilite_none : \"\");\n     formatOnCluster(settings);\n }\ndiff --git a/src/Parsers/ParserAlterNamedCollectionQuery.cpp b/src/Parsers/ParserAlterNamedCollectionQuery.cpp\nindex 9108747ad82a..8fb84f86246f 100644\n--- a/src/Parsers/ParserAlterNamedCollectionQuery.cpp\n+++ b/src/Parsers/ParserAlterNamedCollectionQuery.cpp\n@@ -13,8 +13,9 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod\n {\n     ParserKeyword s_alter(\"ALTER\");\n     ParserKeyword s_collection(\"NAMED COLLECTION\");\n+    ParserKeyword s_if_exists(\"IF EXISTS\");\n+    ParserKeyword s_on(\"ON\");\n     ParserKeyword s_delete(\"DELETE\");\n-\n     ParserIdentifier name_p;\n     ParserSetQuery set_p;\n     ParserToken s_comma(TokenType::Comma);\n@@ -32,10 +33,13 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod\n     if (!s_collection.ignore(pos, expected))\n         return false;\n \n+    if (s_if_exists.ignore(pos, expected))\n+        if_exists = true;\n+\n     if (!name_p.parse(pos, collection_name, expected))\n         return false;\n \n-    if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+    if (s_on.ignore(pos, expected))\n     {\n         if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n             return false;\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 415d3321eb5a..82674ab1a353 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -1421,15 +1421,17 @@ bool ParserCreateViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserKeyword s_create(\"CREATE\");\n-    ParserKeyword s_attach(\"ATTACH\");\n     ParserKeyword s_named_collection(\"NAMED COLLECTION\");\n+    ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n+    ParserKeyword s_on(\"ON\");\n     ParserKeyword s_as(\"AS\");\n-\n-    ParserToken s_comma(TokenType::Comma);\n     ParserIdentifier name_p;\n+    ParserToken s_comma(TokenType::Comma);\n \n-    ASTPtr collection_name;\n     String cluster_str;\n+    bool if_not_exists = false;\n+\n+    ASTPtr collection_name;\n \n     if (!s_create.ignore(pos, expected))\n         return false;\n@@ -1437,10 +1439,13 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n     if (!s_named_collection.ignore(pos, expected))\n         return false;\n \n+    if (s_if_not_exists.ignore(pos, expected))\n+        if_not_exists = true;\n+\n     if (!name_p.parse(pos, collection_name, expected))\n         return false;\n \n-    if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+    if (s_on.ignore(pos, expected))\n     {\n         if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n             return false;\n@@ -1465,7 +1470,9 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n     auto query = std::make_shared<ASTCreateNamedCollectionQuery>();\n \n     tryGetIdentifierNameInto(collection_name, query->collection_name);\n+    query->if_not_exists = if_not_exists;\n     query->changes = changes;\n+    query->cluster = std::move(cluster_str);\n \n     node = query;\n     return true;\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex 09935e2b6087..0a98923436cb 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -548,6 +548,7 @@ class ParserCreateDictionaryQuery : public IParserBase\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n+/// CREATE NAMED COLLECTION name [ON CLUSTER cluster]\n class ParserCreateNamedCollectionQuery : public IParserBase\n {\n protected:\ndiff --git a/src/Parsers/ParserDropNamedCollectionQuery.cpp b/src/Parsers/ParserDropNamedCollectionQuery.cpp\nindex 1ea8aa6d75d5..b0b010b5ef63 100644\n--- a/src/Parsers/ParserDropNamedCollectionQuery.cpp\n+++ b/src/Parsers/ParserDropNamedCollectionQuery.cpp\n@@ -12,6 +12,7 @@ bool ParserDropNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node\n     ParserKeyword s_drop(\"DROP\");\n     ParserKeyword s_collection(\"NAMED COLLECTION\");\n     ParserKeyword s_if_exists(\"IF EXISTS\");\n+    ParserKeyword s_on(\"ON\");\n     ParserIdentifier name_p;\n \n     String cluster_str;\n@@ -31,7 +32,7 @@ bool ParserDropNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node\n     if (!name_p.parse(pos, collection_name, expected))\n         return false;\n \n-    if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+    if (s_on.ignore(pos, expected))\n     {\n         if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n             return false;\ndiff --git a/src/Storages/HDFS/StorageHDFS.cpp b/src/Storages/HDFS/StorageHDFS.cpp\nindex f176ac6f037f..fa6cfd824e79 100644\n--- a/src/Storages/HDFS/StorageHDFS.cpp\n+++ b/src/Storages/HDFS/StorageHDFS.cpp\n@@ -114,9 +114,9 @@ namespace\n             {\n                 if (next_slash_after_glob_pos == std::string::npos)\n                 {\n-                    result.emplace_back(\n+                    result.emplace_back(StorageHDFS::PathWithInfo{\n                         String(ls.file_info[i].mName),\n-                        StorageHDFS::PathInfo{ls.file_info[i].mLastMod, static_cast<size_t>(ls.file_info[i].mSize)});\n+                        StorageHDFS::PathInfo{ls.file_info[i].mLastMod, static_cast<size_t>(ls.file_info[i].mSize)}});\n                 }\n                 else\n                 {\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex a314815e2c4f..81415436c457 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -98,6 +98,7 @@ BlockWriteOps\n BlockWriteTime\n Bool\n BrokenDistributedFilesToInsert\n+Bugfix\n BuildID\n BuilderBinAarch\n BuilderBinAmd\n@@ -1158,6 +1159,7 @@ brotli\n bson\n bsoneachrow\n buffersize\n+bugfix\n buildId\n buildable\n builtins\n",
  "test_patch": "diff --git a/tests/integration/test_named_collections_if_exists_on_cluster/__init__.py b/tests/integration/test_named_collections_if_exists_on_cluster/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_named_collections_if_exists_on_cluster/configs/config.d/cluster.xml b/tests/integration/test_named_collections_if_exists_on_cluster/configs/config.d/cluster.xml\nnew file mode 100644\nindex 000000000000..95336350c1e8\n--- /dev/null\n+++ b/tests/integration/test_named_collections_if_exists_on_cluster/configs/config.d/cluster.xml\n@@ -0,0 +1,22 @@\n+<clickhouse>\n+    <remote_servers>\n+        <cluster>\n+            <shard>\n+                <internal_replication>true</internal_replication>\n+                <replica>\n+                    <host>clickhouse1</host>\n+                    <port>9000</port>\n+                </replica>\n+                <replica>\n+                    <host>clickhouse2</host>\n+                    <port>9000</port>\n+                </replica>\n+                <replica>\n+                    <host>clickhouse3</host>\n+                    <port>9000</port>\n+                </replica>\n+            </shard>\n+            <allow_distributed_ddl_queries>true</allow_distributed_ddl_queries>\n+        </cluster>\n+    </remote_servers>\n+</clickhouse>\ndiff --git a/tests/integration/test_named_collections_if_exists_on_cluster/configs/users.d/default.xml b/tests/integration/test_named_collections_if_exists_on_cluster/configs/users.d/default.xml\nnew file mode 100644\nindex 000000000000..15da914f666b\n--- /dev/null\n+++ b/tests/integration/test_named_collections_if_exists_on_cluster/configs/users.d/default.xml\n@@ -0,0 +1,12 @@\n+<clickhouse>\n+    <users>\n+        <default>\n+            <password></password>\n+            <profile>default</profile>\n+            <quota>default</quota>\n+            <named_collection_control>1</named_collection_control>\n+            <show_named_collections>1</show_named_collections>\n+            <show_named_collections_secrets>1</show_named_collections_secrets>\n+        </default>\n+    </users>\n+</clickhouse>\ndiff --git a/tests/integration/test_named_collections_if_exists_on_cluster/test.py b/tests/integration/test_named_collections_if_exists_on_cluster/test.py\nnew file mode 100644\nindex 000000000000..5f5be9156b95\n--- /dev/null\n+++ b/tests/integration/test_named_collections_if_exists_on_cluster/test.py\n@@ -0,0 +1,148 @@\n+\"\"\"\n+Test cases:\n+\n+--- execute on the first node\n+create named collection foobar as a=1, b=2;\n+create named collection if not exists foobar on cluster '{cluster}' as a=1, b=2, c=3;\n+create named collection collection_present_on_first_node as a=1, b=2, s='string', x=0, y=-1;\n+\n+--- execute on any other node\n+alter named collection foobar on cluster '{cluster}' set a=2, c=3;\n+alter named collection foobar on cluster '{cluster}' delete b;\n+alter named collection foobar on cluster '{cluster}' set a=3 delete c;\n+alter named collection if exists collection_absent_ewerywhere on cluster '{cluster}' delete b;\n+alter named collection if exists collection_present_on_first_node on cluster '{cluster}' delete b;\n+\n+--- execute on every node\n+select * from system.named_collections;\n+\n+--- execute on any node\n+drop named collection foobar on cluster '{cluster}';\n+drop named collection if exists collection_absent_ewerywhere on cluster '{cluster}';\n+drop named collection if exists collection_present_on_first_node on cluster '{cluster}';\n+\n+--- execute on every node\n+select * from system.named_collections;\n+\"\"\"\n+\n+import logging\n+from json import dumps, loads\n+from functools import partial\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+dumps = partial(dumps, ensure_ascii=False)\n+\n+NODE01, NODE02, NODE03 = \"clickhouse1\", \"clickhouse2\", \"clickhouse3\"\n+\n+CHECK_STRING_VALUE = \"Some ~`$tr!ng-_+=123@#%^&&()|?[]{}<\ud83e\udd21>.,\\t\\n:;\"\n+\n+STMT_CREATE = \"CREATE NAMED COLLECTION\"\n+STMT_ALTER = \"ALTER NAMED COLLECTION\"\n+STMT_DROP = \"DROP NAMED COLLECTION\"\n+\n+SYSTEM_TABLE = \"system.named_collections\"\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def cluster():\n+    try:\n+        cluster = ClickHouseCluster(__file__)\n+        common_kwargs = dict(\n+            main_configs=[\n+                \"configs/config.d/cluster.xml\",\n+            ],\n+            user_configs=[\n+                \"configs/users.d/default.xml\",\n+            ],\n+            with_zookeeper=True,\n+            stay_alive=True,\n+        )\n+        for name in [NODE01, NODE02, NODE03]:\n+            cluster.add_instance(name, **common_kwargs)\n+\n+        logging.info(\"Starting cluster...\")\n+        cluster.start()\n+        logging.info(\"Cluster started\")\n+\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_create_alter_drop_on_cluster(cluster):\n+    \"\"\"\n+    Executes the set of queries and checks the final named collections state.\n+    \"\"\"\n+    q_count_collections = f\"select count() from {SYSTEM_TABLE}\"\n+\n+    def check_collections_empty():\n+        for name, node in list(cluster.instances.items()):\n+            assert (\n+                \"0\" == node.query(q_count_collections).strip()\n+            ), f\"{SYSTEM_TABLE} is not empty on {name}\"\n+\n+    foobar_final_state = {\"name\": \"foobar\", \"collection\": {\"a\": \"3\"}}\n+    collection_present_on_first_node_final_state = {\n+        \"name\": \"collection_present_on_first_node\",\n+        \"collection\": {\"a\": \"1\", \"s\": CHECK_STRING_VALUE, \"x\": \"0\", \"y\": \"-1\"},\n+    }\n+    expected_state = {\n+        NODE01: [foobar_final_state, collection_present_on_first_node_final_state],\n+        NODE02: [foobar_final_state],\n+        NODE03: [foobar_final_state],\n+    }\n+\n+    q_get_collections = f\"select * from {SYSTEM_TABLE} order by name desc format JSON\"\n+\n+    def check_state():\n+        for name, node in list(cluster.instances.items()):\n+            result = loads(node.query(q_get_collections))[\"data\"]\n+            logging.debug(\"%s ?= %s\", dumps(result), dumps(expected_state[name]))\n+            assert (\n+                expected_state[name] == result\n+            ), f\"invalid {SYSTEM_TABLE} content on {name}: {result}\"\n+\n+    check_collections_empty()\n+\n+    # create executed on the first node\n+    node = cluster.instances[NODE01]\n+    node.query(f\"{STMT_CREATE} foobar AS a=1, b=2\")\n+    node.query(\n+        f\"{STMT_CREATE} IF NOT EXISTS foobar ON CLUSTER 'cluster' AS a=1, b=2, c=3\"\n+    )\n+    node.query(\n+        f\"{STMT_CREATE} collection_present_on_first_node AS a=1, b=2, s='{CHECK_STRING_VALUE}', x=0, y=-1\"\n+    )\n+\n+    # alter executed on the second node\n+    node = cluster.instances[NODE02]\n+    node.query(f\"{STMT_ALTER} foobar ON CLUSTER 'cluster' SET a=2, c=3\")\n+    node.query(f\"{STMT_ALTER} foobar ON CLUSTER 'cluster' DELETE b\")\n+    node.query(f\"{STMT_ALTER} foobar ON CLUSTER 'cluster' SET a=3 DELETE c\")\n+    node.query(\n+        f\"{STMT_ALTER} IF EXISTS collection_absent_ewerywhere ON CLUSTER 'cluster' DELETE b\"\n+    )\n+    node.query(\n+        f\"{STMT_ALTER} IF EXISTS collection_present_on_first_node ON CLUSTER 'cluster' DELETE b\"\n+    )\n+\n+    check_state()\n+    for node in list(cluster.instances.values()):\n+        node.restart_clickhouse()\n+    check_state()\n+\n+    # drop executed on the third node\n+    node = cluster.instances[NODE03]\n+    node.query(f\"{STMT_DROP} foobar ON CLUSTER 'cluster'\")\n+    node.query(\n+        f\"{STMT_DROP} IF EXISTS collection_absent_ewerywhere ON CLUSTER 'cluster'\"\n+    )\n+    node.query(\n+        f\"{STMT_DROP} IF EXISTS collection_present_on_first_node ON CLUSTER 'cluster'\"\n+    )\n+\n+    check_collections_empty()\n+    for node in list(cluster.instances.values()):\n+        node.restart_clickhouse()\n+    check_collections_empty()\n",
  "problem_statement": "create named collection on cluster does not work\n```sql\r\n:) create named collection foo on cluster c1 AS user = 'user', password = 'password';\r\n\r\nCREATE NAMED COLLECTION foo AS user = 'user', password = 'password'\r\n\r\nQuery id: e4824737-ce7a-4cd6-967a-c3795740794c\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n```\r\n\r\n`if exists` also has issue\r\n```sql\r\n:) drop named collection if exists foo on cluster c1;\r\n\r\nDROP NAMED COLLECTION foo ON CLUSTER c1\r\n\r\nQuery id: e31007c7-48e9-4d13-b691-f12d14a90a3b\r\n\r\n\u250c\u2500host\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500port\u2500\u252c\u2500status\u2500\u252c\u2500error\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500num_hosts_remaining\u2500\u252c\u2500num_hosts_active\u2500\u2510\r\n\u2502 host1-1.s12222.mylocalnet \u2502 9000 \u2502      0 \u2502                                                                                                                                                          \u2502                   1 \u2502                0 \u2502\r\n\u2502 host1-1.s12221.mylocalnet \u2502 9000 \u2502    669 \u2502 Code: 669. DB::Exception: Cannot remove collection `foo`, because it doesn't exist. (NAMED_COLLECTION_DOESNT_EXIST) (version 23.3.3.52 (official build)) \u2502                   0 \u2502                0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u2198 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.)\r\n2 rows in set. Elapsed: 0.131 sec.\r\n\r\nReceived exception from server (version 23.3.3):\r\nCode: 669. DB::Exception: Received from localhost:9000. DB::Exception: There was an error on [host1-1.s12221.mylocalnet:9000]: Code: 669. DB::Exception: Cannot remove collection `foo`, because it doesn't exist. (NAMED_COLLECTION_DOESNT_EXIST) (version 23.3.3.52 (official build)). (NAMED_COLLECTION_DOESNT_EXIST)\r\n```\r\n\r\nif not exists also has issue\r\n```sql\r\n :) create named collection if not exists foo on cluster c1 AS user = 'user', password = 'password';\r\n\r\nSyntax error: failed at position 28 ('not'):\r\n\r\ncreate named collection if not exists foo on c1 segmented AS user = 'user', password = 'password';\r\n\r\nExpected one of: ON, AS\r\n```\r\n\r\n```sql\r\n:) create named collection if not exists foo AS user = 'user', password = 'password';\r\n\r\nSyntax error: failed at position 28 ('not'):\r\n\r\ncreate named collection if not exists foo AS user = 'user', password = 'password';\r\n\r\nExpected one of: ON, AS\r\n```\r\n\n",
  "hints_text": "> :) create named collection foo on cluster c1 AS\r\n> CREATE NAMED COLLECTION foo AS\r\n\r\n> :) drop named collection if exists foo\r\n> DROP NAMED COLLECTION foo\r\n\r\nIt's a bug in AST formatting ",
  "created_at": "2023-07-27T15:55:00Z"
}