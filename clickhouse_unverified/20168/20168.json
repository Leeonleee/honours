{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 20168,
  "instance_id": "ClickHouse__ClickHouse-20168",
  "issue_numbers": [
    "20093"
  ],
  "base_commit": "4650dcdbb0c8f3d525fb964131293333d81ecfc1",
  "patch": "diff --git a/programs/server/config.xml b/programs/server/config.xml\nindex ca57987d9018..ba9b8b04b05d 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -284,6 +284,10 @@\n          In bytes. Cache is single for server. Memory is allocated only on demand.\n          Cache is used when 'use_uncompressed_cache' user setting turned on (off by default).\n          Uncompressed cache is advantageous only for very short queries and in rare cases.\n+\n+         Note: uncompressed cache can be pointless for lz4, because memory bandwidth\n+         is slower than multi-core decompression on some server configurations.\n+         Enabling it can sometimes paradoxically make queries slower.\n       -->\n     <uncompressed_cache_size>8589934592</uncompressed_cache_size>\n \ndiff --git a/programs/server/users.xml b/programs/server/users.xml\nindex 3223d855651e..ef66891a6a03 100644\n--- a/programs/server/users.xml\n+++ b/programs/server/users.xml\n@@ -7,9 +7,6 @@\n             <!-- Maximum memory usage for processing single query, in bytes. -->\n             <max_memory_usage>10000000000</max_memory_usage>\n \n-            <!-- Use cache of uncompressed blocks of data. Meaningful only for processing many of very short queries. -->\n-            <use_uncompressed_cache>0</use_uncompressed_cache>\n-\n             <!-- How to choose between replicas during distributed query processing.\n                  random - choose random replica from set of replicas with minimum number of errors\n                  nearest_hostname - from set of replicas with minimum number of errors, choose replica\ndiff --git a/src/Columns/ColumnArray.cpp b/src/Columns/ColumnArray.cpp\nindex 8c0e06424e71..e8a486724350 100644\n--- a/src/Columns/ColumnArray.cpp\n+++ b/src/Columns/ColumnArray.cpp\n@@ -7,6 +7,7 @@\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnsCommon.h>\n+#include <Columns/ColumnCompressed.h>\n \n #include <common/unaligned.h>\n #include <common/sort.h>\n@@ -369,8 +370,12 @@ void ColumnArray::compareColumn(const IColumn & rhs, size_t rhs_row_num,\n                                         compare_results, direction, nan_direction_hint);\n }\n \n+\n+namespace\n+{\n+\n template <bool positive>\n-struct ColumnArray::Cmp\n+struct Cmp\n {\n     const ColumnArray & parent;\n     int nan_direction_hint;\n@@ -390,6 +395,9 @@ struct ColumnArray::Cmp\n     }\n };\n \n+}\n+\n+\n void ColumnArray::reserve(size_t n)\n {\n     getOffsets().reserve(n);\n@@ -912,6 +920,21 @@ void ColumnArray::updatePermutationWithCollation(const Collator & collator, bool\n         updatePermutationImpl(limit, res, equal_range, Cmp<true>(*this, nan_direction_hint, &collator));\n }\n \n+ColumnPtr ColumnArray::compress() const\n+{\n+    ColumnPtr data_compressed = data->compress();\n+    ColumnPtr offsets_compressed = offsets->compress();\n+\n+    size_t byte_size = data_compressed->byteSize() + offsets_compressed->byteSize();\n+\n+    return ColumnCompressed::create(size(), byte_size,\n+        [data_compressed = std::move(data_compressed), offsets_compressed = std::move(offsets_compressed)]\n+        {\n+            return ColumnArray::create(data_compressed->decompress(), offsets_compressed->decompress());\n+        });\n+}\n+\n+\n ColumnPtr ColumnArray::replicate(const Offsets & replicate_offsets) const\n {\n     if (replicate_offsets.empty())\ndiff --git a/src/Columns/ColumnArray.h b/src/Columns/ColumnArray.h\nindex e81ecbc1ca02..1caaf672d498 100644\n--- a/src/Columns/ColumnArray.h\n+++ b/src/Columns/ColumnArray.h\n@@ -123,6 +123,8 @@ class ColumnArray final : public COWHelper<IColumn, ColumnArray>\n \n     void gather(ColumnGathererStream & gatherer_stream) override;\n \n+    ColumnPtr compress() const override;\n+\n     void forEachSubcolumn(ColumnCallback callback) override\n     {\n         callback(offsets);\n@@ -183,9 +185,6 @@ class ColumnArray final : public COWHelper<IColumn, ColumnArray>\n \n     template <typename Comparator>\n     void updatePermutationImpl(size_t limit, Permutation & res, EqualRanges & equal_range, Comparator cmp) const;\n-\n-    template <bool positive>\n-    struct Cmp;\n };\n \n \ndiff --git a/src/Columns/ColumnCompressed.cpp b/src/Columns/ColumnCompressed.cpp\nnew file mode 100644\nindex 000000000000..292c6968b866\n--- /dev/null\n+++ b/src/Columns/ColumnCompressed.cpp\n@@ -0,0 +1,61 @@\n+#include <Columns/ColumnCompressed.h>\n+\n+#pragma GCC diagnostic ignored \"-Wold-style-cast\"\n+\n+#include <lz4.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_COMPRESS;\n+    extern const int CANNOT_DECOMPRESS;\n+}\n+\n+\n+std::shared_ptr<Memory<>> ColumnCompressed::compressBuffer(const void * data, size_t data_size, bool always_compress)\n+{\n+    size_t max_dest_size = LZ4_COMPRESSBOUND(data_size);\n+\n+    if (max_dest_size > std::numeric_limits<int>::max())\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress column of size {}\", formatReadableSizeWithBinarySuffix(data_size));\n+\n+    Memory<> compressed(max_dest_size);\n+\n+    auto compressed_size = LZ4_compress_default(\n+        reinterpret_cast<const char *>(data),\n+        compressed.data(),\n+        data_size,\n+        max_dest_size);\n+\n+    if (compressed_size <= 0)\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress column\");\n+\n+    /// If compression is inefficient.\n+    if (!always_compress && static_cast<size_t>(compressed_size) * 2 > data_size)\n+        return {};\n+\n+    /// Shrink to fit.\n+    auto shrank = std::make_shared<Memory<>>(compressed_size);\n+    memcpy(shrank->data(), compressed.data(), compressed_size);\n+\n+    return shrank;\n+}\n+\n+\n+void ColumnCompressed::decompressBuffer(\n+    const void * compressed_data, void * decompressed_data, size_t compressed_size, size_t decompressed_size)\n+{\n+    auto processed_size = LZ4_decompress_safe(\n+        reinterpret_cast<const char *>(compressed_data),\n+        reinterpret_cast<char *>(decompressed_data),\n+        compressed_size,\n+        decompressed_size);\n+\n+    if (processed_size <= 0)\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress column\");\n+}\n+\n+}\ndiff --git a/src/Columns/ColumnCompressed.h b/src/Columns/ColumnCompressed.h\nnew file mode 100644\nindex 000000000000..f6b6bf22177f\n--- /dev/null\n+++ b/src/Columns/ColumnCompressed.h\n@@ -0,0 +1,121 @@\n+#pragma once\n+\n+#include <optional>\n+#include <Core/Field.h>\n+#include <Columns/IColumn.h>\n+#include <IO/BufferWithOwnMemory.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+\n+/** Wrapper for compressed column data.\n+  * The only supported operations are:\n+  * - decompress (reconstruct the source column)\n+  * - get size in rows or bytes.\n+  *\n+  * It is needed to implement in-memory compression\n+  * - to keep compressed data in Block or pass around.\n+  *\n+  * It's often beneficial to store compressed data in-memory and decompress on the fly\n+  * because it allows to lower memory throughput. More specifically, if:\n+  *\n+  * decompression speed * num CPU cores >= memory read throughput\n+  *\n+  * Also in-memory compression allows to keep more data in RAM.\n+  */\n+class ColumnCompressed : public COWHelper<IColumn, ColumnCompressed>\n+{\n+public:\n+    using Lazy = std::function<ColumnPtr()>;\n+\n+    ColumnCompressed(size_t rows_, size_t bytes_, Lazy lazy_)\n+        : rows(rows_), bytes(bytes_), lazy(lazy_)\n+    {\n+    }\n+\n+    const char * getFamilyName() const override { return \"Compressed\"; }\n+\n+    size_t size() const override { return rows; }\n+    size_t byteSize() const override { return bytes; }\n+    size_t allocatedBytes() const override { return bytes; }\n+\n+    ColumnPtr decompress() const override\n+    {\n+        return lazy();\n+    }\n+\n+    /** Wrap uncompressed column without compression.\n+      * Method can be used when compression is not worth doing.\n+      * But returning CompressedColumn is still needed to keep uniform block structure.\n+      */\n+    static ColumnPtr wrap(ColumnPtr column)\n+    {\n+        return ColumnCompressed::create(\n+            column->size(),\n+            column->allocatedBytes(),\n+            [column = std::move(column)]{ return column; });\n+    }\n+\n+    /// Helper methods for compression.\n+\n+    /// If data is not worth to be compressed and not 'always_compress' - returns nullptr.\n+    /// Note: shared_ptr is to allow to be captured by std::function.\n+    static std::shared_ptr<Memory<>> compressBuffer(const void * data, size_t data_size, bool always_compress);\n+\n+    static void decompressBuffer(\n+        const void * compressed_data, void * decompressed_data, size_t compressed_size, size_t decompressed_size);\n+\n+    /// All other methods throw exception.\n+\n+    TypeIndex getDataType() const override { throwMustBeDecompressed(); }\n+    Field operator[](size_t) const override { throwMustBeDecompressed(); }\n+    void get(size_t, Field &) const override { throwMustBeDecompressed(); }\n+    StringRef getDataAt(size_t) const override { throwMustBeDecompressed(); }\n+    void insert(const Field &) override { throwMustBeDecompressed(); }\n+    void insertRangeFrom(const IColumn &, size_t, size_t) override { throwMustBeDecompressed(); }\n+    void insertData(const char *, size_t) override { throwMustBeDecompressed(); }\n+    void insertDefault() override { throwMustBeDecompressed(); }\n+    void popBack(size_t) override { throwMustBeDecompressed(); }\n+    StringRef serializeValueIntoArena(size_t, Arena &, char const *&) const override { throwMustBeDecompressed(); }\n+    const char * deserializeAndInsertFromArena(const char *) override { throwMustBeDecompressed(); }\n+    void updateHashWithValue(size_t, SipHash &) const override { throwMustBeDecompressed(); }\n+    void updateWeakHash32(WeakHash32 &) const override { throwMustBeDecompressed(); }\n+    void updateHashFast(SipHash &) const override { throwMustBeDecompressed(); }\n+    ColumnPtr filter(const Filter &, ssize_t) const override { throwMustBeDecompressed(); }\n+    ColumnPtr permute(const Permutation &, size_t) const override { throwMustBeDecompressed(); }\n+    ColumnPtr index(const IColumn &, size_t) const override { throwMustBeDecompressed(); }\n+    int compareAt(size_t, size_t, const IColumn &, int) const override { throwMustBeDecompressed(); }\n+    void compareColumn(const IColumn &, size_t, PaddedPODArray<UInt64> *, PaddedPODArray<Int8> &, int, int) const override\n+    {\n+        throwMustBeDecompressed();\n+    }\n+    void getPermutation(bool, size_t, int, Permutation &) const override { throwMustBeDecompressed(); }\n+    void updatePermutation(bool, size_t, int, Permutation &, EqualRanges &) const override { throwMustBeDecompressed(); }\n+    ColumnPtr replicate(const Offsets &) const override { throwMustBeDecompressed(); }\n+    MutableColumns scatter(ColumnIndex, const Selector &) const override { throwMustBeDecompressed(); }\n+    void gather(ColumnGathererStream &) override { throwMustBeDecompressed(); }\n+    void getExtremes(Field &, Field &) const override { throwMustBeDecompressed(); }\n+    size_t byteSizeAt(size_t) const override { throwMustBeDecompressed(); }\n+\n+protected:\n+    size_t rows;\n+    size_t bytes;\n+\n+    Lazy lazy;\n+\n+private:\n+    [[noreturn]] void throwMustBeDecompressed() const\n+    {\n+        throw Exception(\"ColumnCompressed must be decompressed before use\", ErrorCodes::LOGICAL_ERROR);\n+    }\n+};\n+\n+}\n+\ndiff --git a/src/Columns/ColumnDecimal.cpp b/src/Columns/ColumnDecimal.cpp\nindex ddc971032b65..bad3a4c34022 100644\n--- a/src/Columns/ColumnDecimal.cpp\n+++ b/src/Columns/ColumnDecimal.cpp\n@@ -14,6 +14,7 @@\n \n #include <Columns/ColumnsCommon.h>\n #include <Columns/ColumnDecimal.h>\n+#include <Columns/ColumnCompressed.h>\n #include <DataStreams/ColumnGathererStream.h>\n \n \n@@ -346,6 +347,30 @@ void ColumnDecimal<T>::gather(ColumnGathererStream & gatherer)\n     gatherer.gather(*this);\n }\n \n+template <typename T>\n+ColumnPtr ColumnDecimal<T>::compress() const\n+{\n+    size_t source_size = data.size() * sizeof(T);\n+\n+    /// Don't compress small blocks.\n+    if (source_size < 4096) /// A wild guess.\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    auto compressed = ColumnCompressed::compressBuffer(data.data(), source_size, false);\n+\n+    if (!compressed)\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    return ColumnCompressed::create(data.size(), compressed->size(),\n+        [compressed = std::move(compressed), column_size = data.size(), scale = this->scale]\n+        {\n+            auto res = ColumnDecimal<T>::create(column_size, scale);\n+            ColumnCompressed::decompressBuffer(\n+                compressed->data(), res->getData().data(), compressed->size(), column_size * sizeof(T));\n+            return res;\n+        });\n+}\n+\n template <typename T>\n void ColumnDecimal<T>::getExtremes(Field & min, Field & max) const\n {\ndiff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex ef841292a7de..5016ddca791f 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -172,6 +172,8 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T\n         return false;\n     }\n \n+    ColumnPtr compress() const override;\n+\n \n     void insertValue(const T value) { data.push_back(value); }\n     Container & getData() { return data; }\ndiff --git a/src/Columns/ColumnFixedString.cpp b/src/Columns/ColumnFixedString.cpp\nindex 6cfec89a5dce..c4a7f923867d 100644\n--- a/src/Columns/ColumnFixedString.cpp\n+++ b/src/Columns/ColumnFixedString.cpp\n@@ -1,6 +1,7 @@\n #include <Columns/ColumnFixedString.h>\n-\n #include <Columns/ColumnsCommon.h>\n+#include <Columns/ColumnCompressed.h>\n+\n #include <DataStreams/ColumnGathererStream.h>\n #include <IO/WriteHelpers.h>\n #include <Common/Arena.h>\n@@ -446,6 +447,34 @@ void ColumnFixedString::getExtremes(Field & min, Field & max) const\n     get(max_idx, max);\n }\n \n+ColumnPtr ColumnFixedString::compress() const\n+{\n+    size_t source_size = chars.size();\n+\n+    /// Don't compress small blocks.\n+    if (source_size < 4096) /// A wild guess.\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    auto compressed = ColumnCompressed::compressBuffer(chars.data(), source_size, false);\n+\n+    if (!compressed)\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    size_t column_size = size();\n+\n+    return ColumnCompressed::create(column_size, compressed->size(),\n+        [compressed = std::move(compressed), column_size, n = n]\n+        {\n+            size_t chars_size = n * column_size;\n+            auto res = ColumnFixedString::create(n);\n+            res->getChars().resize(chars_size);\n+            ColumnCompressed::decompressBuffer(\n+                compressed->data(), res->getChars().data(), compressed->size(), chars_size);\n+            return res;\n+        });\n+}\n+\n+\n void ColumnFixedString::alignStringLength(ColumnFixedString::Chars & data, size_t n, size_t old_size)\n {\n     size_t length = data.size() - old_size;\ndiff --git a/src/Columns/ColumnFixedString.h b/src/Columns/ColumnFixedString.h\nindex 24a99c27b132..d9f6619b2d1b 100644\n--- a/src/Columns/ColumnFixedString.h\n+++ b/src/Columns/ColumnFixedString.h\n@@ -156,6 +156,8 @@ class ColumnFixedString final : public COWHelper<ColumnVectorHelper, ColumnFixed\n \n     void gather(ColumnGathererStream & gatherer_stream) override;\n \n+    ColumnPtr compress() const override;\n+\n     void reserve(size_t size) override\n     {\n         chars.reserve(n * size);\ndiff --git a/src/Columns/ColumnMap.cpp b/src/Columns/ColumnMap.cpp\nindex 1cfd7e6c4ef7..cc2640a9cf6e 100644\n--- a/src/Columns/ColumnMap.cpp\n+++ b/src/Columns/ColumnMap.cpp\n@@ -1,4 +1,5 @@\n #include <Columns/ColumnMap.h>\n+#include <Columns/ColumnCompressed.h>\n #include <Columns/IColumnImpl.h>\n #include <DataStreams/ColumnGathererStream.h>\n #include <IO/WriteBufferFromString.h>\n@@ -243,4 +244,13 @@ bool ColumnMap::structureEquals(const IColumn & rhs) const\n     return false;\n }\n \n+ColumnPtr ColumnMap::compress() const\n+{\n+    auto compressed = nested->compress();\n+    return ColumnCompressed::create(size(), compressed->byteSize(), [compressed = std::move(compressed)]\n+    {\n+        return ColumnMap::create(compressed->decompress());\n+    });\n+}\n+\n }\ndiff --git a/src/Columns/ColumnMap.h b/src/Columns/ColumnMap.h\nindex c1948491db59..acae1574f4c8 100644\n--- a/src/Columns/ColumnMap.h\n+++ b/src/Columns/ColumnMap.h\n@@ -91,6 +91,8 @@ class ColumnMap final : public COWHelper<IColumn, ColumnMap>\n \n     const ColumnTuple & getNestedData() const { return assert_cast<const ColumnTuple &>(getNestedColumn().getData()); }\n     ColumnTuple & getNestedData() { return assert_cast<ColumnTuple &>(getNestedColumn().getData()); }\n+\n+    ColumnPtr compress() const override;\n };\n \n }\ndiff --git a/src/Columns/ColumnNullable.cpp b/src/Columns/ColumnNullable.cpp\nindex 35ce005073ab..4e5cc2b4cf7b 100644\n--- a/src/Columns/ColumnNullable.cpp\n+++ b/src/Columns/ColumnNullable.cpp\n@@ -7,6 +7,7 @@\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnCompressed.h>\n #include <DataStreams/ColumnGathererStream.h>\n \n \n@@ -511,6 +512,20 @@ void ColumnNullable::protect()\n     getNullMapColumn().protect();\n }\n \n+ColumnPtr ColumnNullable::compress() const\n+{\n+    ColumnPtr nested_compressed = nested_column->compress();\n+    ColumnPtr null_map_compressed = null_map->compress();\n+\n+    size_t byte_size = nested_column->byteSize() + null_map->byteSize();\n+\n+    return ColumnCompressed::create(size(), byte_size,\n+        [nested_column = std::move(nested_column), null_map = std::move(null_map)]\n+        {\n+            return ColumnNullable::create(nested_column->decompress(), null_map->decompress());\n+        });\n+}\n+\n \n namespace\n {\ndiff --git a/src/Columns/ColumnNullable.h b/src/Columns/ColumnNullable.h\nindex ade2c1066275..8d267de86442 100644\n--- a/src/Columns/ColumnNullable.h\n+++ b/src/Columns/ColumnNullable.h\n@@ -117,6 +117,8 @@ class ColumnNullable final : public COWHelper<IColumn, ColumnNullable>\n \n     void gather(ColumnGathererStream & gatherer_stream) override;\n \n+    ColumnPtr compress() const override;\n+\n     void forEachSubcolumn(ColumnCallback callback) override\n     {\n         callback(nested_column);\ndiff --git a/src/Columns/ColumnString.cpp b/src/Columns/ColumnString.cpp\nindex 00d6349408f8..8fd22e85e100 100644\n--- a/src/Columns/ColumnString.cpp\n+++ b/src/Columns/ColumnString.cpp\n@@ -2,6 +2,7 @@\n \n #include <Columns/Collator.h>\n #include <Columns/ColumnsCommon.h>\n+#include <Columns/ColumnCompressed.h>\n #include <DataStreams/ColumnGathererStream.h>\n #include <Common/Arena.h>\n #include <Common/HashTable/Hash.h>\n@@ -525,6 +526,47 @@ void ColumnString::getExtremes(Field & min, Field & max) const\n }\n \n \n+ColumnPtr ColumnString::compress() const\n+{\n+    size_t source_chars_size = chars.size();\n+    size_t source_offsets_size = offsets.size() * sizeof(Offset);\n+\n+    /// Don't compress small blocks.\n+    if (source_chars_size < 4096) /// A wild guess.\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    auto chars_compressed = ColumnCompressed::compressBuffer(chars.data(), source_chars_size, false);\n+\n+    /// Return original column if not compressible.\n+    if (!chars_compressed)\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    auto offsets_compressed = ColumnCompressed::compressBuffer(offsets.data(), source_offsets_size, true);\n+\n+    return ColumnCompressed::create(offsets.size(), chars_compressed->size() + offsets_compressed->size(),\n+        [\n+            chars_compressed = std::move(chars_compressed),\n+            offsets_compressed = std::move(offsets_compressed),\n+            source_chars_size,\n+            source_offsets_elements = offsets.size()\n+        ]\n+        {\n+            auto res = ColumnString::create();\n+\n+            res->getChars().resize(source_chars_size);\n+            res->getOffsets().resize(source_offsets_elements);\n+\n+            ColumnCompressed::decompressBuffer(\n+                chars_compressed->data(), res->getChars().data(), chars_compressed->size(), source_chars_size);\n+\n+            ColumnCompressed::decompressBuffer(\n+                offsets_compressed->data(), res->getOffsets().data(), offsets_compressed->size(), source_offsets_elements * sizeof(Offset));\n+\n+            return res;\n+        });\n+}\n+\n+\n int ColumnString::compareAtWithCollation(size_t n, size_t m, const IColumn & rhs_, int, const Collator & collator) const\n {\n     const ColumnString & rhs = assert_cast<const ColumnString &>(rhs_);\ndiff --git a/src/Columns/ColumnString.h b/src/Columns/ColumnString.h\nindex c1e76c5e28ee..843e445d1a01 100644\n--- a/src/Columns/ColumnString.h\n+++ b/src/Columns/ColumnString.h\n@@ -261,6 +261,8 @@ class ColumnString final : public COWHelper<IColumn, ColumnString>\n \n     void gather(ColumnGathererStream & gatherer_stream) override;\n \n+    ColumnPtr compress() const override;\n+\n     void reserve(size_t n) override;\n \n     void getExtremes(Field & min, Field & max) const override;\ndiff --git a/src/Columns/ColumnTuple.cpp b/src/Columns/ColumnTuple.cpp\nindex fa5a15d0351e..c7c5f7b97c6f 100644\n--- a/src/Columns/ColumnTuple.cpp\n+++ b/src/Columns/ColumnTuple.cpp\n@@ -1,6 +1,7 @@\n #include <Columns/ColumnTuple.h>\n \n #include <Columns/IColumnImpl.h>\n+#include <Columns/ColumnCompressed.h>\n #include <Core/Field.h>\n #include <DataStreams/ColumnGathererStream.h>\n #include <IO/Operators.h>\n@@ -486,7 +487,7 @@ bool ColumnTuple::structureEquals(const IColumn & rhs) const\n \n bool ColumnTuple::isCollationSupported() const\n {\n-    for (const auto& column : columns)\n+    for (const auto & column : columns)\n     {\n         if (column->isCollationSupported())\n             return true;\n@@ -495,4 +496,25 @@ bool ColumnTuple::isCollationSupported() const\n }\n \n \n+ColumnPtr ColumnTuple::compress() const\n+{\n+    size_t byte_size = 0;\n+    Columns compressed;\n+    compressed.reserve(columns.size());\n+    for (const auto & column : columns)\n+    {\n+        auto compressed_column = column->compress();\n+        byte_size += compressed_column->byteSize();\n+        compressed.emplace_back(std::move(compressed_column));\n+    }\n+\n+    return ColumnCompressed::create(size(), byte_size,\n+        [compressed = std::move(compressed)]() mutable\n+        {\n+            for (auto & column : compressed)\n+                column = column->decompress();\n+            return ColumnTuple::create(compressed);\n+        });\n+}\n+\n }\ndiff --git a/src/Columns/ColumnTuple.h b/src/Columns/ColumnTuple.h\nindex f763ca3fcba9..818b29937bd3 100644\n--- a/src/Columns/ColumnTuple.h\n+++ b/src/Columns/ColumnTuple.h\n@@ -89,6 +89,7 @@ class ColumnTuple final : public COWHelper<IColumn, ColumnTuple>\n     void forEachSubcolumn(ColumnCallback callback) override;\n     bool structureEquals(const IColumn & rhs) const override;\n     bool isCollationSupported() const override;\n+    ColumnPtr compress() const override;\n \n     size_t tupleSize() const { return columns.size(); }\n \ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex 5d58b2484e0d..fbd3c3641b55 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -28,13 +28,18 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n+/** Stores another column with unique values\n+  * and also an index that allows to find position by value.\n+  *\n+  * This column is not used on it's own but only as implementation detail of ColumnLowCardinality.\n+  */\n template <typename ColumnType>\n class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnType>>\n {\n     friend class COWHelper<IColumnUnique, ColumnUnique<ColumnType>>;\n \n private:\n-    explicit ColumnUnique(MutableColumnPtr && holder, bool is_nullable);\n+    ColumnUnique(MutableColumnPtr && holder, bool is_nullable);\n     explicit ColumnUnique(const IDataType & type);\n     ColumnUnique(const ColumnUnique & other);\n \ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex ec26500d0574..19ba86c51201 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -2,6 +2,7 @@\n \n #include <pdqsort.h>\n #include <Columns/ColumnsCommon.h>\n+#include <Columns/ColumnCompressed.h>\n #include <DataStreams/ColumnGathererStream.h>\n #include <IO/WriteHelpers.h>\n #include <Common/Arena.h>\n@@ -520,6 +521,33 @@ void ColumnVector<T>::getExtremes(Field & min, Field & max) const\n     max = NearestFieldType<T>(cur_max);\n }\n \n+\n+#pragma GCC diagnostic ignored \"-Wold-style-cast\"\n+\n+template <typename T>\n+ColumnPtr ColumnVector<T>::compress() const\n+{\n+    size_t source_size = data.size() * sizeof(T);\n+\n+    /// Don't compress small blocks.\n+    if (source_size < 4096) /// A wild guess.\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    auto compressed = ColumnCompressed::compressBuffer(data.data(), source_size, false);\n+\n+    if (!compressed)\n+        return ColumnCompressed::wrap(this->getPtr());\n+\n+    return ColumnCompressed::create(data.size(), compressed->size(),\n+        [compressed = std::move(compressed), column_size = data.size()]\n+        {\n+            auto res = ColumnVector<T>::create(column_size);\n+            ColumnCompressed::decompressBuffer(\n+                compressed->data(), res->getData().data(), compressed->size(), column_size * sizeof(T));\n+            return res;\n+        });\n+}\n+\n /// Explicit template instantiations - to avoid code bloat in headers.\n template class ColumnVector<UInt8>;\n template class ColumnVector<UInt16>;\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 586fced88a66..f0aa4a3bab5f 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -298,6 +298,8 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n         return typeid(rhs) == typeid(ColumnVector<T>);\n     }\n \n+    ColumnPtr compress() const override;\n+\n     /// Replace elements that match the filter with zeroes. If inverted replaces not matched elements.\n     void applyZeroMap(const IColumn::Filter & filt, bool inverted = false);\n \ndiff --git a/src/Columns/IColumn.h b/src/Columns/IColumn.h\nindex 824b5411744e..2b4b633f9a5f 100644\n--- a/src/Columns/IColumn.h\n+++ b/src/Columns/IColumn.h\n@@ -357,6 +357,21 @@ class IColumn : public COW<IColumn>\n         throw Exception(\"Method structureEquals is not supported for \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+    /// Compress column in memory to some representation that allows to decompress it back.\n+    /// Return itself if compression is not applicable for this column type.\n+    virtual Ptr compress() const\n+    {\n+        /// No compression by default.\n+        return getPtr();\n+    }\n+\n+    /// If it's CompressedColumn, decompress it and return.\n+    /// Otherwise return itself.\n+    virtual Ptr decompress() const\n+    {\n+        return getPtr();\n+    }\n+\n \n     static MutablePtr mutate(Ptr ptr)\n     {\n@@ -460,7 +475,7 @@ using Columns = std::vector<ColumnPtr>;\n using MutableColumns = std::vector<MutableColumnPtr>;\n \n using ColumnRawPtrs = std::vector<const IColumn *>;\n-//using MutableColumnRawPtrs = std::vector<IColumn *>;\n+\n \n template <typename ... Args>\n struct IsMutableColumns;\ndiff --git a/src/Columns/ReverseIndex.h b/src/Columns/ReverseIndex.h\nindex 154293acf99a..35b0029fc7b7 100644\n--- a/src/Columns/ReverseIndex.h\n+++ b/src/Columns/ReverseIndex.h\n@@ -316,8 +316,8 @@ template <typename IndexType, typename ColumnType>\n class ReverseIndex\n {\n public:\n-    explicit ReverseIndex(UInt64 num_prefix_rows_to_skip_, UInt64 base_index_)\n-            : num_prefix_rows_to_skip(num_prefix_rows_to_skip_), base_index(base_index_), saved_hash_ptr(nullptr) {}\n+    ReverseIndex(UInt64 num_prefix_rows_to_skip_, UInt64 base_index_)\n+        : num_prefix_rows_to_skip(num_prefix_rows_to_skip_), base_index(base_index_), saved_hash_ptr(nullptr) {}\n \n     void setColumn(ColumnType * column_);\n \n@@ -329,14 +329,16 @@ class ReverseIndex\n     /// Returns the found data's index in the dictionary. If index is not built, builds it.\n     UInt64 getInsertionPoint(StringRef data)\n     {\n-        if (!index) buildIndex();\n+        if (!index)\n+            buildIndex();\n         return getIndexImpl(data);\n     }\n \n     /// Returns the found data's index in the dictionary if the #index is built, otherwise, returns a std::nullopt.\n     std::optional<UInt64> getIndex(StringRef data) const\n     {\n-        if (!index) return {};\n+        if (!index)\n+            return {};\n         return getIndexImpl(data);\n     }\n \ndiff --git a/src/Columns/ya.make b/src/Columns/ya.make\nindex 2affaeb0fc66..54dd02609ff1 100644\n--- a/src/Columns/ya.make\n+++ b/src/Columns/ya.make\n@@ -7,18 +7,21 @@ ADDINCL(\n     contrib/libs/icu/common\n     contrib/libs/icu/i18n\n     contrib/libs/pdqsort\n+    contrib/libs/lz4\n )\n \n PEERDIR(\n     clickhouse/src/Common\n     contrib/libs/icu\n     contrib/libs/pdqsort\n+    contrib/libs/lz4\n )\n \n SRCS(\n     Collator.cpp\n     ColumnAggregateFunction.cpp\n     ColumnArray.cpp\n+    ColumnCompressed.cpp\n     ColumnConst.cpp\n     ColumnDecimal.cpp\n     ColumnFixedString.cpp\ndiff --git a/src/Columns/ya.make.in b/src/Columns/ya.make.in\nindex 677a5bcbd706..846e2c6c3bd5 100644\n--- a/src/Columns/ya.make.in\n+++ b/src/Columns/ya.make.in\n@@ -6,12 +6,14 @@ ADDINCL(\n     contrib/libs/icu/common\n     contrib/libs/icu/i18n\n     contrib/libs/pdqsort\n+    contrib/libs/lz4\n )\n \n PEERDIR(\n     clickhouse/src/Common\n     contrib/libs/icu\n     contrib/libs/pdqsort\n+    contrib/libs/lz4\n )\n \n SRCS(\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 9bb9ad30f15e..72b89e5e8db2 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -69,7 +69,7 @@ class IColumn;\n     M(UInt64, s3_max_redirects, 10, \"Max number of S3 redirects hops allowed.\", 0) \\\n     M(UInt64, s3_max_connections, 1024, \"The maximum number of connections per server.\", 0) \\\n     M(Bool, extremes, false, \"Calculate minimums and maximums of the result columns. They can be output in JSON-formats.\", IMPORTANT) \\\n-    M(Bool, use_uncompressed_cache, true, \"Whether to use the cache of uncompressed blocks.\", 0) \\\n+    M(Bool, use_uncompressed_cache, false, \"Whether to use the cache of uncompressed blocks.\", 0) \\\n     M(Bool, replace_running_query, false, \"Whether the running request should be canceled with the same id as the new one.\", 0) \\\n     M(UInt64, background_buffer_flush_schedule_pool_size, 16, \"Number of threads performing background flush for tables with Buffer engine. Only has meaning at server startup.\", 0) \\\n     M(UInt64, background_pool_size, 16, \"Number of threads performing background work for tables (for example, merging in merge tree). Only has meaning at server startup.\", 0) \\\ndiff --git a/src/DataTypes/DataTypeLowCardinality.h b/src/DataTypes/DataTypeLowCardinality.h\nindex 14beb423f1fa..f5b6b5711873 100644\n--- a/src/DataTypes/DataTypeLowCardinality.h\n+++ b/src/DataTypes/DataTypeLowCardinality.h\n@@ -1,7 +1,9 @@\n #pragma once\n+\n #include <DataTypes/IDataType.h>\n #include <Columns/IColumnUnique.h>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Storages/MemorySettings.cpp b/src/Storages/MemorySettings.cpp\nnew file mode 100644\nindex 000000000000..f5e182b3484e\n--- /dev/null\n+++ b/src/Storages/MemorySettings.cpp\n@@ -0,0 +1,36 @@\n+#include <Storages/MemorySettings.h>\n+#include <Parsers/ASTCreateQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Common/Exception.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNKNOWN_SETTING;\n+}\n+\n+IMPLEMENT_SETTINGS_TRAITS(memorySettingsTraits, MEMORY_SETTINGS)\n+\n+void MemorySettings::loadFromQuery(ASTStorage & storage_def)\n+{\n+    if (storage_def.settings)\n+    {\n+        try\n+        {\n+            applyChanges(storage_def.settings->changes);\n+        }\n+        catch (Exception & e)\n+        {\n+            if (e.code() == ErrorCodes::UNKNOWN_SETTING)\n+                e.addMessage(\"for storage \" + storage_def.engine->name);\n+            throw;\n+        }\n+    }\n+}\n+\n+}\n+\ndiff --git a/src/Storages/MemorySettings.h b/src/Storages/MemorySettings.h\nnew file mode 100644\nindex 000000000000..5e3b5f81ba5a\n--- /dev/null\n+++ b/src/Storages/MemorySettings.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+\n+#include <Core/BaseSettings.h>\n+\n+\n+namespace DB\n+{\n+class ASTStorage;\n+\n+\n+#define MEMORY_SETTINGS(M) \\\n+    M(Bool, compress, false, \"Compress data in memory\", 0) \\\n+\n+DECLARE_SETTINGS_TRAITS(memorySettingsTraits, MEMORY_SETTINGS)\n+\n+\n+/** Settings for the Memory engine.\n+  * Could be loaded from a CREATE TABLE query (SETTINGS clause).\n+  */\n+struct MemorySettings : public BaseSettings<memorySettingsTraits>\n+{\n+    void loadFromQuery(ASTStorage & storage_def);\n+};\n+\n+}\n+\ndiff --git a/src/Storages/StorageMemory.cpp b/src/Storages/StorageMemory.cpp\nindex 4530d93c274a..d7b0ae055ab3 100644\n--- a/src/Storages/StorageMemory.cpp\n+++ b/src/Storages/StorageMemory.cpp\n@@ -6,6 +6,7 @@\n #include <Interpreters/MutationsInterpreter.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/StorageMemory.h>\n+#include <Storages/MemorySettings.h>\n \n #include <IO/WriteHelpers.h>\n #include <Processors/Sources/SourceWithProgress.h>\n@@ -71,6 +72,8 @@ class MemorySource : public SourceWithProgress\n         for (const auto & elem : column_names_and_types)\n         {\n             auto current_column = src.getByName(elem.getNameInStorage()).column;\n+            current_column = current_column->decompress();\n+\n             if (elem.isSubcolumn())\n                 columns.emplace_back(elem.getTypeInStorage()->getSubcolumn(elem.getSubcolumnName(), *current_column));\n             else\n@@ -117,7 +120,19 @@ class MemoryBlockOutputStream : public IBlockOutputStream\n     void write(const Block & block) override\n     {\n         metadata_snapshot->check(block, true);\n-        new_blocks.emplace_back(block);\n+\n+        if (storage.compress)\n+        {\n+            Block compressed_block;\n+            for (const auto & elem : block)\n+                compressed_block.insert({ elem.column->compress(), elem.type, elem.name });\n+\n+            new_blocks.emplace_back(compressed_block);\n+        }\n+        else\n+        {\n+            new_blocks.emplace_back(block);\n+        }\n     }\n \n     void writeSuffix() override\n@@ -149,8 +164,12 @@ class MemoryBlockOutputStream : public IBlockOutputStream\n };\n \n \n-StorageMemory::StorageMemory(const StorageID & table_id_, ColumnsDescription columns_description_, ConstraintsDescription constraints_)\n-    : IStorage(table_id_), data(std::make_unique<const Blocks>())\n+StorageMemory::StorageMemory(\n+    const StorageID & table_id_,\n+    ColumnsDescription columns_description_,\n+    ConstraintsDescription constraints_,\n+    bool compress_)\n+    : IStorage(table_id_), data(std::make_unique<const Blocks>()), compress(compress_)\n {\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(std::move(columns_description_));\n@@ -245,9 +264,12 @@ void StorageMemory::mutate(const MutationCommands & commands, const Context & co\n \n     in->readPrefix();\n     Blocks out;\n-    Block block;\n-    while ((block = in->read()))\n+    while (Block block = in->read())\n     {\n+        if (compress)\n+            for (auto & elem : block)\n+                elem.column = elem.column->compress();\n+\n         out.push_back(block);\n     }\n     in->readSuffix();\n@@ -317,13 +339,19 @@ void registerStorageMemory(StorageFactory & factory)\n     factory.registerStorage(\"Memory\", [](const StorageFactory::Arguments & args)\n     {\n         if (!args.engine_args.empty())\n-            throw Exception(\n-                \"Engine \" + args.engine_name + \" doesn't support any arguments (\" + toString(args.engine_args.size()) + \" given)\",\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Engine {} doesn't support any arguments ({} given)\",\n+                args.engine_name, args.engine_args.size());\n+\n+        bool has_settings = args.storage_def->settings;\n+        MemorySettings settings;\n+        if (has_settings)\n+            settings.loadFromQuery(*args.storage_def);\n \n-        return StorageMemory::create(args.table_id, args.columns, args.constraints);\n+        return StorageMemory::create(args.table_id, args.columns, args.constraints, settings.compress);\n     },\n     {\n+        .supports_settings = true,\n         .supports_parallel_insert = true,\n     });\n }\ndiff --git a/src/Storages/StorageMemory.h b/src/Storages/StorageMemory.h\nindex 79ced856231e..db71c13ca991 100644\n--- a/src/Storages/StorageMemory.h\n+++ b/src/Storages/StorageMemory.h\n@@ -97,6 +97,7 @@ friend struct ext::shared_ptr_helper<StorageMemory>;\n \n private:\n     /// MultiVersion data storage, so that we can copy the list of blocks to readers.\n+\n     MultiVersion<Blocks> data;\n \n     mutable std::mutex mutex;\n@@ -106,8 +107,14 @@ friend struct ext::shared_ptr_helper<StorageMemory>;\n     std::atomic<size_t> total_size_bytes = 0;\n     std::atomic<size_t> total_size_rows = 0;\n \n+    bool compress;\n+\n protected:\n-    StorageMemory(const StorageID & table_id_, ColumnsDescription columns_description_, ConstraintsDescription constraints_);\n+    StorageMemory(\n+        const StorageID & table_id_,\n+        ColumnsDescription columns_description_,\n+        ConstraintsDescription constraints_,\n+        bool compress_ = false);\n };\n \n }\ndiff --git a/src/Storages/StorageSet.cpp b/src/Storages/StorageSet.cpp\nindex e518c7da0e45..d64042f0c1e0 100644\n--- a/src/Storages/StorageSet.cpp\n+++ b/src/Storages/StorageSet.cpp\n@@ -242,15 +242,12 @@ void registerStorageSet(StorageFactory & factory)\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n         bool has_settings = args.storage_def->settings;\n-\n-        auto set_settings = std::make_unique<SetSettings>();\n+        SetSettings set_settings;\n         if (has_settings)\n-        {\n-            set_settings->loadFromQuery(*args.storage_def);\n-        }\n+            set_settings.loadFromQuery(*args.storage_def);\n \n-        DiskPtr disk = args.context.getDisk(set_settings->disk);\n-        return StorageSet::create(disk, args.relative_data_path, args.table_id, args.columns, args.constraints, set_settings->persistent);\n+        DiskPtr disk = args.context.getDisk(set_settings.disk);\n+        return StorageSet::create(disk, args.relative_data_path, args.table_id, args.columns, args.constraints, set_settings.persistent);\n     }, StorageFactory::StorageFeatures{ .supports_settings = true, });\n }\n \ndiff --git a/src/Storages/ya.make b/src/Storages/ya.make\nindex dbf37e58695c..e3e1807c5660 100644\n--- a/src/Storages/ya.make\n+++ b/src/Storages/ya.make\n@@ -24,6 +24,7 @@ SRCS(\n     KeyDescription.cpp\n     LiveView/StorageLiveView.cpp\n     LiveView/TemporaryLiveViewCleaner.cpp\n+    MemorySettings.cpp\n     MergeTree/ActiveDataPartSet.cpp\n     MergeTree/AllMergeSelector.cpp\n     MergeTree/BackgroundJobsExecutor.cpp\n",
  "test_patch": "diff --git a/tests/integration/test_settings_profile/test.py b/tests/integration/test_settings_profile/test.py\nindex 3ceef9f25cf3..1945875bf539 100644\n--- a/tests/integration/test_settings_profile/test.py\n+++ b/tests/integration/test_settings_profile/test.py\n@@ -46,7 +46,7 @@ def reset_after_test():\n \n \n def test_smoke():\n-    # Set settings and constraints via CREATE SETTINGS PROFILE ... TO user \n+    # Set settings and constraints via CREATE SETTINGS PROFILE ... TO user\n     instance.query(\n         \"CREATE SETTINGS PROFILE xyz SETTINGS max_memory_usage = 100000001 MIN 90000000 MAX 110000000 TO robin\")\n     assert instance.query(\n@@ -194,13 +194,13 @@ def test_show_profiles():\n \n     assert instance.query(\"SHOW CREATE PROFILE xyz\") == \"CREATE SETTINGS PROFILE xyz\\n\"\n     assert instance.query(\n-        \"SHOW CREATE SETTINGS PROFILE default\") == \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, use_uncompressed_cache = 0, load_balancing = \\\\'random\\\\'\\n\"\n+        \"SHOW CREATE SETTINGS PROFILE default\") == \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, load_balancing = \\\\'random\\\\'\\n\"\n     assert instance.query(\n-        \"SHOW CREATE PROFILES\") == \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, use_uncompressed_cache = 0, load_balancing = \\\\'random\\\\'\\n\" \\\n+        \"SHOW CREATE PROFILES\") == \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, load_balancing = \\\\'random\\\\'\\n\" \\\n                                    \"CREATE SETTINGS PROFILE readonly SETTINGS readonly = 1\\n\" \\\n                                    \"CREATE SETTINGS PROFILE xyz\\n\"\n \n-    expected_access = \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, use_uncompressed_cache = 0, load_balancing = \\\\'random\\\\'\\n\" \\\n+    expected_access = \"CREATE SETTINGS PROFILE default SETTINGS max_memory_usage = 10000000000, load_balancing = \\\\'random\\\\'\\n\" \\\n                       \"CREATE SETTINGS PROFILE readonly SETTINGS readonly = 1\\n\" \\\n                       \"CREATE SETTINGS PROFILE xyz\\n\"\n     assert expected_access in instance.query(\"SHOW ACCESS\")\n@@ -210,7 +210,7 @@ def test_allow_ddl():\n     assert \"it's necessary to have grant\" in instance.query_and_get_error(\"CREATE TABLE tbl(a Int32) ENGINE=Log\", user=\"robin\")\n     assert \"it's necessary to have grant\" in instance.query_and_get_error(\"GRANT CREATE ON tbl TO robin\", user=\"robin\")\n     assert \"DDL queries are prohibited\" in instance.query_and_get_error(\"CREATE TABLE tbl(a Int32) ENGINE=Log\", settings={\"allow_ddl\": 0})\n-    \n+\n     instance.query(\"GRANT CREATE ON tbl TO robin\")\n     instance.query(\"CREATE TABLE tbl(a Int32) ENGINE=Log\", user=\"robin\")\n     instance.query(\"DROP TABLE tbl\")\n",
  "problem_statement": "Compression for Memory tables\nAdd very simple in-memory compression interface that works directly for columns.\r\n\r\nAdd method `IColumn::compress`. It returns either:\r\n- `CompressedColumnPtr` that is `shared_ptr` of `ICompressedColumn`, that has the only method `virtual ColumnPtr decompress()`;\r\n- `std::function<ColumnPtr()>` - a function object to get decompressed column back;\r\n\r\nThis method will take no parameters for compression but it can be extended later.\r\n\r\nIt should compress the whole buffers of columns as a single block with lz4. The usual compression interface with Read/Write buffers, support for checksums, etc. is not used.\r\n\r\nAdd support for SETTINGS clause for Memory table with the setting `compress = 0|1`.\r\n\r\nThe hypothesis is that compressed Memory tables will work faster on SELECTs by using less memory bandwidth.\r\nActually we already confirmed this hypothesis with MergeTree tables: they are compressed by default and it works faster than with disabled compression even if data is in memory and disk is not used.\n",
  "hints_text": "",
  "created_at": "2021-02-07T01:54:21Z",
  "modified_files": [
    "programs/server/config.xml",
    "programs/server/users.xml",
    "src/Columns/ColumnArray.cpp",
    "src/Columns/ColumnArray.h",
    "b/src/Columns/ColumnCompressed.cpp",
    "b/src/Columns/ColumnCompressed.h",
    "src/Columns/ColumnDecimal.cpp",
    "src/Columns/ColumnDecimal.h",
    "src/Columns/ColumnFixedString.cpp",
    "src/Columns/ColumnFixedString.h",
    "src/Columns/ColumnMap.cpp",
    "src/Columns/ColumnMap.h",
    "src/Columns/ColumnNullable.cpp",
    "src/Columns/ColumnNullable.h",
    "src/Columns/ColumnString.cpp",
    "src/Columns/ColumnString.h",
    "src/Columns/ColumnTuple.cpp",
    "src/Columns/ColumnTuple.h",
    "src/Columns/ColumnUnique.h",
    "src/Columns/ColumnVector.cpp",
    "src/Columns/ColumnVector.h",
    "src/Columns/IColumn.h",
    "src/Columns/ReverseIndex.h",
    "src/Columns/ya.make",
    "src/Columns/ya.make.in",
    "src/Core/Settings.h",
    "src/DataTypes/DataTypeLowCardinality.h",
    "b/src/Storages/MemorySettings.cpp",
    "b/src/Storages/MemorySettings.h",
    "src/Storages/StorageMemory.cpp",
    "src/Storages/StorageMemory.h",
    "src/Storages/StorageSet.cpp",
    "src/Storages/ya.make"
  ],
  "modified_test_files": [
    "tests/integration/test_settings_profile/test.py"
  ]
}