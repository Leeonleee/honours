{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60093,
  "instance_id": "ClickHouse__ClickHouse-60093",
  "issue_numbers": [
    "11188"
  ],
  "base_commit": "ea06825ddc6fd818a9388248eb8c0193cf92d588",
  "patch": "diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex d0bff759dea2..bc7a29247e44 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -421,11 +421,8 @@ ASTPtr QueryNode::toASTImpl(const ConvertToASTOptions & options) const\n \n     if (is_subquery)\n     {\n-        auto subquery = std::make_shared<ASTSubquery>();\n-\n+        auto subquery = std::make_shared<ASTSubquery>(std::move(result_select_query));\n         subquery->cte_name = cte_name;\n-        subquery->children.push_back(std::move(result_select_query));\n-\n         return subquery;\n     }\n \ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex 5d2ac128abe1..c60031265544 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -185,11 +185,8 @@ ASTPtr UnionNode::toASTImpl(const ConvertToASTOptions & options) const\n \n     if (is_subquery)\n     {\n-        auto subquery = std::make_shared<ASTSubquery>();\n-\n+        auto subquery = std::make_shared<ASTSubquery>(std::move(select_with_union_query));\n         subquery->cte_name = cte_name;\n-        subquery->children.push_back(std::move(select_with_union_query));\n-\n         return subquery;\n     }\n \ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex ecd021328e78..bb6df2da8d9b 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -262,8 +262,7 @@ struct ExistsExpressionData\n         select_with_union_query->list_of_selects->children.push_back(std::move(select_query));\n         select_with_union_query->children.push_back(select_with_union_query->list_of_selects);\n \n-        auto new_subquery = std::make_shared<ASTSubquery>();\n-        new_subquery->children.push_back(select_with_union_query);\n+        auto new_subquery = std::make_shared<ASTSubquery>(std::move(select_with_union_query));\n \n         auto function = makeASTFunction(\"in\", std::make_shared<ASTLiteral>(1u), new_subquery);\n         func = *function;\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 10567fbafd41..1ab66f49ac73 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -721,7 +721,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             /// Verify that AST formatting is consistent:\n             /// If you format AST, parse it back, and format it again, you get the same string.\n \n-            String formatted1 = ast->formatForErrorMessage();\n+            String formatted1 = ast->formatWithPossiblyHidingSensitiveData(0, true, true);\n \n             ASTPtr ast2 = parseQuery(parser,\n                 formatted1.data(),\n@@ -730,7 +730,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n \n             chassert(ast2);\n \n-            String formatted2 = ast2->formatForErrorMessage();\n+            String formatted2 = ast2->formatWithPossiblyHidingSensitiveData(0, true, true);\n \n             if (formatted1 != formatted2)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\ndiff --git a/src/Parsers/ASTSelectWithUnionQuery.cpp b/src/Parsers/ASTSelectWithUnionQuery.cpp\nindex 48b4ae3c38de..c377e4bd66b6 100644\n--- a/src/Parsers/ASTSelectWithUnionQuery.cpp\n+++ b/src/Parsers/ASTSelectWithUnionQuery.cpp\n@@ -71,8 +71,7 @@ void ASTSelectWithUnionQuery::formatQueryImpl(const FormatSettings & settings, F\n             }\n             else\n             {\n-                auto sub_query = std::make_shared<ASTSubquery>();\n-                sub_query->children.push_back(*it);\n+                auto sub_query = std::make_shared<ASTSubquery>(*it);\n                 sub_query->formatImpl(settings, state, frame);\n             }\n         }\ndiff --git a/src/Parsers/ASTSubquery.h b/src/Parsers/ASTSubquery.h\nindex ef277a631260..e92a88b04ddd 100644\n--- a/src/Parsers/ASTSubquery.h\n+++ b/src/Parsers/ASTSubquery.h\n@@ -26,6 +26,13 @@ class ASTSubquery : public ASTWithAlias\n         return clone;\n     }\n \n+    ASTSubquery() = default;\n+\n+    ASTSubquery(ASTPtr child)\n+    {\n+        children.emplace_back(std::move(child));\n+    }\n+\n     void updateTreeHashImpl(SipHash & hash_state, bool ignore_aliases) const override;\n     String getAliasOrColumnName() const override;\n     String tryGetAlias() const override;\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 42400a0f13b1..62c480e0f6b0 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -123,7 +123,7 @@ bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"EXPLAIN in a subquery cannot have a table function or table override\");\n \n         /// Replace subquery `(EXPLAIN <kind> <explain_settings> SELECT ...)`\n-        /// with `(SELECT * FROM viewExplain(\"<kind>\", \"<explain_settings>\", SELECT ...))`\n+        /// with `(SELECT * FROM viewExplain('<kind>', '<explain_settings>', (SELECT ...)))`\n \n         String kind_str = ASTExplainQuery::toString(explain_query.getKind());\n \n@@ -141,7 +141,7 @@ bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             auto view_explain = makeASTFunction(\"viewExplain\",\n                 std::make_shared<ASTLiteral>(kind_str),\n                 std::make_shared<ASTLiteral>(settings_str),\n-                explained_ast);\n+                std::make_shared<ASTSubquery>(explained_ast));\n             result_node = buildSelectFromTableFunction(view_explain);\n         }\n         else\n@@ -161,8 +161,7 @@ bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return false;\n     ++pos;\n \n-    node = std::make_shared<ASTSubquery>();\n-    node->children.push_back(result_node);\n+    node = std::make_shared<ASTSubquery>(std::move(result_node));\n     return true;\n }\n \ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 1e9383f96ae2..6d267a7d2156 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -225,8 +225,7 @@ static bool modifyAST(ASTPtr ast, SubqueryFunctionType type)\n     select_with_union_query->list_of_selects->children.push_back(std::move(select_query));\n     select_with_union_query->children.push_back(select_with_union_query->list_of_selects);\n \n-    auto new_subquery = std::make_shared<ASTSubquery>();\n-    new_subquery->children.push_back(select_with_union_query);\n+    auto new_subquery = std::make_shared<ASTSubquery>(std::move(select_with_union_query));\n     ast->children[0]->children.back() = std::move(new_subquery);\n \n     return true;\n@@ -1582,8 +1581,7 @@ class ExistsLayer : public Layer\n         if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n             return false;\n \n-        auto subquery = std::make_shared<ASTSubquery>();\n-        subquery->children.push_back(std::move(node));\n+        auto subquery = std::make_shared<ASTSubquery>(std::move(node));\n         elements = {makeASTFunction(\"exists\", subquery)};\n \n         finished = true;\ndiff --git a/src/Parsers/Kusto/ParserKQLQuery.cpp b/src/Parsers/Kusto/ParserKQLQuery.cpp\nindex 479869436622..30e9921e744d 100644\n--- a/src/Parsers/Kusto/ParserKQLQuery.cpp\n+++ b/src/Parsers/Kusto/ParserKQLQuery.cpp\n@@ -576,20 +576,19 @@ bool ParserKQLSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     if (!ParserKQLTableFunction().parse(pos, select_node, expected))\n         return false;\n \n-    ASTPtr node_subquery = std::make_shared<ASTSubquery>();\n-    node_subquery->children.push_back(select_node);\n+    ASTPtr node_subquery = std::make_shared<ASTSubquery>(std::move(select_node));\n \n     ASTPtr node_table_expr = std::make_shared<ASTTableExpression>();\n     node_table_expr->as<ASTTableExpression>()->subquery = node_subquery;\n \n     node_table_expr->children.emplace_back(node_subquery);\n \n-    ASTPtr node_table_in_select_query_emlement = std::make_shared<ASTTablesInSelectQueryElement>();\n-    node_table_in_select_query_emlement->as<ASTTablesInSelectQueryElement>()->table_expression = node_table_expr;\n+    ASTPtr node_table_in_select_query_element = std::make_shared<ASTTablesInSelectQueryElement>();\n+    node_table_in_select_query_element->as<ASTTablesInSelectQueryElement>()->table_expression = node_table_expr;\n \n     ASTPtr res = std::make_shared<ASTTablesInSelectQuery>();\n \n-    res->children.emplace_back(node_table_in_select_query_emlement);\n+    res->children.emplace_back(node_table_in_select_query_element);\n \n     node = res;\n     return true;\n@@ -618,20 +617,19 @@ bool ParserSimpleCHSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n             ASTSelectQuery::Expression::TABLES, parent_select_node->as<ASTSelectQuery>()->tables());\n     }\n \n-    ASTPtr node_subquery = std::make_shared<ASTSubquery>();\n-    node_subquery->children.push_back(sub_select_node);\n+    ASTPtr node_subquery = std::make_shared<ASTSubquery>(std::move(sub_select_node));\n \n     ASTPtr node_table_expr = std::make_shared<ASTTableExpression>();\n     node_table_expr->as<ASTTableExpression>()->subquery = node_subquery;\n \n     node_table_expr->children.emplace_back(node_subquery);\n \n-    ASTPtr node_table_in_select_query_emlement = std::make_shared<ASTTablesInSelectQueryElement>();\n-    node_table_in_select_query_emlement->as<ASTTablesInSelectQueryElement>()->table_expression = node_table_expr;\n+    ASTPtr node_table_in_select_query_element = std::make_shared<ASTTablesInSelectQueryElement>();\n+    node_table_in_select_query_element->as<ASTTablesInSelectQueryElement>()->table_expression = node_table_expr;\n \n     ASTPtr res = std::make_shared<ASTTablesInSelectQuery>();\n \n-    res->children.emplace_back(node_table_in_select_query_emlement);\n+    res->children.emplace_back(node_table_in_select_query_element);\n \n     node = res;\n     return true;\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 0fcd7afbbdf2..2826c3e23f15 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -345,13 +345,21 @@ IMergeTreeDataPart::~IMergeTreeDataPart()\n \n const IMergeTreeDataPart::Index & IMergeTreeDataPart::getIndex() const\n {\n+    std::scoped_lock lock(index_mutex);\n+    if (!index_loaded)\n+        loadIndex(lock);\n+    index_loaded = true;\n     return index;\n }\n \n \n void IMergeTreeDataPart::setIndex(Columns index_)\n {\n+    std::scoped_lock lock(index_mutex);\n+    if (!index.empty())\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"The index of data part can be set only once\");\n     index = std::move(index_);\n+    index_loaded = true;\n }\n \n \n@@ -682,8 +690,11 @@ void IMergeTreeDataPart::loadColumnsChecksumsIndexes(bool require_columns_checks\n         loadColumns(require_columns_checksums);\n         loadChecksums(require_columns_checksums);\n         loadIndexGranularity();\n+\n+        if (!storage.getSettings()->primary_key_lazy_load)\n+            getIndex();\n+\n         calculateColumnsAndSecondaryIndicesSizesOnDisk();\n-        loadIndex(); /// Must be called after loadIndexGranularity as it uses the value of `index_granularity`\n         loadRowsCount(); /// Must be called after loadIndexGranularity() as it uses the value of `index_granularity`.\n         loadPartitionAndMinMaxIndex();\n         bool has_broken_projections = false;\n@@ -817,8 +828,11 @@ void IMergeTreeDataPart::appendFilesOfIndexGranularity(Strings & /* files */) co\n {\n }\n \n-void IMergeTreeDataPart::loadIndex()\n+void IMergeTreeDataPart::loadIndex(std::scoped_lock<std::mutex> &) const\n {\n+    /// Memory for index must not be accounted as memory usage for query, because it belongs to a table.\n+    MemoryTrackerBlockerInThread temporarily_disable_memory_tracker;\n+\n     /// It can be empty in case of mutations\n     if (!index_granularity.isInitialized())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Index granularity is not loaded before index loading\");\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 72a4a55dd774..c9dea1afcc5f 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -562,9 +562,11 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n \n protected:\n     /// Primary key (correspond to primary.idx file).\n-    /// Always loaded in RAM. Contains each index_granularity-th value of primary key tuple.\n+    /// Lazily loaded in RAM. Contains each index_granularity-th value of primary key tuple.\n     /// Note that marks (also correspond to primary key) are not always in RAM, but cached. See MarkCache.h.\n-    Index index;\n+    mutable std::mutex index_mutex;\n+    mutable Index index;\n+    mutable bool index_loaded = false;\n \n     /// Total size of all columns, calculated once in calcuateColumnSizesOnDisk\n     ColumnSize total_columns_size;\n@@ -662,7 +664,7 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n     virtual void appendFilesOfIndexGranularity(Strings & files) const;\n \n     /// Loads the index file.\n-    void loadIndex();\n+    void loadIndex(std::scoped_lock<std::mutex> &) const;\n \n     void appendFilesOfIndex(Strings & files) const;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeMarksLoader.cpp b/src/Storages/MergeTree/MergeTreeMarksLoader.cpp\nindex 7531c03a011e..eb7b60b0727e 100644\n--- a/src/Storages/MergeTree/MergeTreeMarksLoader.cpp\n+++ b/src/Storages/MergeTree/MergeTreeMarksLoader.cpp\n@@ -6,7 +6,6 @@\n #include <Common/CurrentMetrics.h>\n #include <Common/MemoryTrackerBlockerInThread.h>\n #include <Common/ThreadPool.h>\n-#include <Common/scope_guard_safe.h>\n #include <Common/setThreadName.h>\n \n #include <utility>\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex 96cab9c0293f..b64632b61391 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -201,6 +201,7 @@ struct Settings;\n     M(String, primary_key_compression_codec, \"ZSTD(3)\", \"Compression encoding used by primary, primary key is small enough and cached, so the default compression is ZSTD(3).\", 0) \\\n     M(UInt64, marks_compress_block_size, 65536, \"Mark compress block size, the actual size of the block to compress.\", 0) \\\n     M(UInt64, primary_key_compress_block_size, 65536, \"Primary compress block size, the actual size of the block to compress.\", 0) \\\n+    M(Bool, primary_key_lazy_load, true, \"Load primary key in memory on first use instead of on table initialization. This can save memory in the presence of a large number of tables.\", 0) \\\n     \\\n     /** Projection settings. */ \\\n     M(UInt64, max_projections, 25, \"The maximum number of merge tree projections.\", 0) \\\ndiff --git a/src/Storages/StorageView.cpp b/src/Storages/StorageView.cpp\nindex 588e5303117d..181fd0ac61c5 100644\n--- a/src/Storages/StorageView.cpp\n+++ b/src/Storages/StorageView.cpp\n@@ -251,8 +251,7 @@ void StorageView::replaceWithSubquery(ASTSelectQuery & outer_query, ASTPtr view_\n \n     view_name = table_expression->database_and_table_name;\n     table_expression->database_and_table_name = {};\n-    table_expression->subquery = std::make_shared<ASTSubquery>();\n-    table_expression->subquery->children.push_back(view_query);\n+    table_expression->subquery = std::make_shared<ASTSubquery>(view_query);\n     table_expression->subquery->setAlias(alias);\n \n     for (auto & child : table_expression->children)\ndiff --git a/src/TableFunctions/TableFunctionExplain.cpp b/src/TableFunctions/TableFunctionExplain.cpp\nindex f993a9820cbe..400fc81e6d43 100644\n--- a/src/TableFunctions/TableFunctionExplain.cpp\n+++ b/src/TableFunctions/TableFunctionExplain.cpp\n@@ -1,4 +1,5 @@\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ParserSetQuery.h>\n #include <Parsers/parseQuery.h>\n@@ -21,6 +22,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int BAD_ARGUMENTS;\n+    extern const int UNEXPECTED_AST_STRUCTURE;\n }\n \n namespace\n@@ -103,11 +105,25 @@ void TableFunctionExplain::parseArguments(const ASTPtr & ast_function, ContextPt\n \n     if (function->arguments->children.size() > 2)\n     {\n-        const auto & query_arg = function->arguments->children[2];\n+        const auto & subquery_arg = function->arguments->children[2];\n+        const auto * subquery = subquery_arg->as<ASTSubquery>();\n+\n+        if (!subquery)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Table function '{}' requires a subquery argument, got '{}'\",\n+                getName(), queryToString(subquery_arg));\n+\n+        if (subquery->children.empty())\n+            throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE,\n+                \"A subquery AST element must have a child\");\n+\n+        const auto & query_arg = subquery->children[0];\n+\n         if (!query_arg->as<ASTSelectWithUnionQuery>())\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Table function '{}' requires a EXPLAIN SELECT query argument, got EXPLAIN '{}'\",\n+                \"Table function '{}' requires a EXPLAIN's SELECT query argument, got '{}'\",\n                 getName(), queryToString(query_arg));\n+\n         explain_query->setExplainedQuery(query_arg);\n     }\n     else if (kind != ASTExplainQuery::ExplainKind::CurrentTransaction)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02990_format_select_from_explain.reference b/tests/queries/0_stateless/02990_format_select_from_explain.reference\nnew file mode 100644\nindex 000000000000..7c8dcef3824a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02990_format_select_from_explain.reference\n@@ -0,0 +1,9 @@\n+SELECT explain\n+FROM\n+(\n+    SELECT *\n+    FROM viewExplain('EXPLAIN AST', '', (\n+        SELECT *\n+        FROM system.numbers\n+    ))\n+)\ndiff --git a/tests/queries/0_stateless/02990_format_select_from_explain.sh b/tests/queries/0_stateless/02990_format_select_from_explain.sh\nnew file mode 100755\nindex 000000000000..4955b7337883\n--- /dev/null\n+++ b/tests/queries/0_stateless/02990_format_select_from_explain.sh\n@@ -0,0 +1,7 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_FORMAT} --query \"SELECT explain FROM (EXPLAIN AST SELECT * FROM system.numbers)\"\ndiff --git a/tests/queries/0_stateless/02993_lazy_index_loading.reference b/tests/queries/0_stateless/02993_lazy_index_loading.reference\nnew file mode 100644\nindex 000000000000..5bc329ae4eb7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02993_lazy_index_loading.reference\n@@ -0,0 +1,4 @@\n+100000000\t140000000\n+0\t0\n+1\n+100000000\t100000000\ndiff --git a/tests/queries/0_stateless/02993_lazy_index_loading.sql b/tests/queries/0_stateless/02993_lazy_index_loading.sql\nnew file mode 100644\nindex 000000000000..7de4af9ef0e4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02993_lazy_index_loading.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (s String) ENGINE = MergeTree ORDER BY s SETTINGS index_granularity = 1;\n+\n+INSERT INTO test SELECT randomString(1000) FROM numbers(100000);\n+SELECT round(primary_key_bytes_in_memory, -7), round(primary_key_bytes_in_memory_allocated, -7) FROM system.parts WHERE database = currentDatabase() AND table = 'test';\n+\n+DETACH TABLE test;\n+SET max_memory_usage = '50M';\n+ATTACH TABLE test;\n+\n+SELECT primary_key_bytes_in_memory, primary_key_bytes_in_memory_allocated FROM system.parts WHERE database = currentDatabase() AND table = 'test';\n+\n+SET max_memory_usage = '200M';\n+SELECT s != '' FROM test LIMIT 1;\n+\n+SELECT round(primary_key_bytes_in_memory, -7), round(primary_key_bytes_in_memory_allocated, -7) FROM system.parts WHERE database = currentDatabase() AND table = 'test';\n+\n+DROP TABLE test;\n",
  "problem_statement": "Protection from too large size of index in memory.\nThe user may accidentially create a table with index_granularity = 1 and insert many rows.\r\nIn this case, the size of primary.idx may become too large, it will lead to OOM and subsequent infinite loop of OOM after startup.\n",
  "hints_text": "",
  "created_at": "2024-02-17T05:43:55Z",
  "modified_files": [
    "src/Analyzer/QueryNode.cpp",
    "src/Analyzer/UnionNode.cpp",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/executeQuery.cpp",
    "src/Parsers/ASTSelectWithUnionQuery.cpp",
    "src/Parsers/ASTSubquery.h",
    "src/Parsers/ExpressionElementParsers.cpp",
    "src/Parsers/ExpressionListParsers.cpp",
    "src/Parsers/Kusto/ParserKQLQuery.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.h",
    "src/Storages/MergeTree/MergeTreeMarksLoader.cpp",
    "src/Storages/MergeTree/MergeTreeSettings.h",
    "src/Storages/StorageView.cpp",
    "src/TableFunctions/TableFunctionExplain.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02990_format_select_from_explain.reference",
    "b/tests/queries/0_stateless/02990_format_select_from_explain.sh",
    "b/tests/queries/0_stateless/02993_lazy_index_loading.reference",
    "b/tests/queries/0_stateless/02993_lazy_index_loading.sql"
  ]
}