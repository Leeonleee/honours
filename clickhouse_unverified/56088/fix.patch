diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 4160cbd9c811..4df5e2afcbf7 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -1557,10 +1557,10 @@ Returns for a given date, the number of days passed since [1 January 0000](https
 toDaysSinceYearZero(date[, time_zone])
 ```
 
-Aliases: `TO_DAYS`
-
+Alias: `TO_DAYS`
 
 **Arguments**
+
 - `date` — The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).
 - `time_zone` — A String type const value or a expression represent the time zone. [String types](../../sql-reference/data-types/string.md)
 
@@ -1584,6 +1584,56 @@ Result:
 └────────────────────────────────────────────┘
 ```
 
+**See Also**
+
+- [fromDaysSinceYearZero](#fromDaysSinceYearZero)
+
+## fromDaysSinceYearZero
+
+Returns for a given number of days passed since [1 January 0000](https://en.wikipedia.org/wiki/Year_zero) the corresponding date in the [proleptic Gregorian calendar defined by ISO 8601](https://en.wikipedia.org/wiki/Gregorian_calendar#Proleptic_Gregorian_calendar). The calculation is the same as in MySQL's [`FROM_DAYS()`](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_from-days) function.
+
+The result is undefined if it cannot be represented within the bounds of the [Date](../../sql-reference/data-types/date.md) type.
+
+**Syntax**
+
+``` sql
+fromDaysSinceYearZero(days)
+```
+
+Alias: `FROM_DAYS`
+
+**Arguments**
+
+- `days` — The number of days passed since year zero.
+
+**Returned value**
+
+The date corresponding to the number of days passed since year zero.
+
+Type: [Date](../../sql-reference/data-types/date.md).
+
+**Example**
+
+``` sql
+SELECT fromDaysSinceYearZero(739136), fromDaysSinceYearZero(toDaysSinceYearZero(toDate('2023-09-08')));
+```
+
+Result:
+
+``` text
+┌─fromDaysSinceYearZero(739136)─┬─fromDaysSinceYearZero(toDaysSinceYearZero(toDate('2023-09-08')))─┐
+│                    2023-09-08 │                                                       2023-09-08 │
+└───────────────────────────────┴──────────────────────────────────────────────────────────────────┘
+```
+
+**See Also**
+
+- [toDaysSinceYearZero](#toDaysSinceYearZero)
+
+## fromDaysSinceYearZero32
+
+Like [fromDaysSinceYearZero](#fromDaysSinceYearZero) but returns a [Date32](../../sql-reference/data-types/date32.md).
+
 ## age
 
 Returns the `unit` component of the difference between `startdate` and `enddate`. The difference is calculated using a precision of 1 microsecond.
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 7f5cd88fa2bd..f334cd9ff241 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -458,6 +458,8 @@ inline bool isUInt32(const T & data_type) { return WhichDataType(data_type).isUI
 template <typename T>
 inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }
 template <typename T>
+inline bool isNativeUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isNativeUInt(); }
+template <typename T>
 inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }
 
 template <typename T>
diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h
index 9737e69bf340..74b37e189070 100644
--- a/src/Functions/DateTimeTransforms.h
+++ b/src/Functions/DateTimeTransforms.h
@@ -1387,10 +1387,11 @@ struct ToDayOfYearImpl
 struct ToDaysSinceYearZeroImpl
 {
 private:
-    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().
     static constexpr auto SECONDS_PER_DAY = 60 * 60 * 24;
 
 public:
+    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().
+
     static constexpr auto name = "toDaysSinceYearZero";
 
     static UInt32 execute(Int64 t, const DateLUTImpl & time_zone)
diff --git a/src/Functions/fromDaysSinceYearZero.cpp b/src/Functions/fromDaysSinceYearZero.cpp
new file mode 100644
index 000000000000..804a243cda01
--- /dev/null
+++ b/src/Functions/fromDaysSinceYearZero.cpp
@@ -0,0 +1,137 @@
+#include <Functions/IFunction.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/DateTimeTransforms.h>
+#include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDate32.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Columns/ColumnConst.h>
+#include <Columns/ColumnDecimal.h>
+#include <Columns/ColumnsDateTime.h>
+#include <Columns/ColumnsNumber.h>
+#include <Interpreters/castColumn.h>
+
+#include <Common/DateLUT.h>
+#include <Common/typeid_cast.h>
+
+#include <array>
+#include <cmath>
+
+namespace DB
+{
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+namespace
+{
+
+struct DateTraits
+{
+    static constexpr auto name = "fromDaysSinceYearZero";
+    using ReturnDataType = DataTypeDate;
+};
+
+struct DateTraits32
+{
+    static constexpr auto name = "fromDaysSinceYearZero32";
+    using ReturnDataType = DataTypeDate32;
+};
+
+template <typename Traits>
+class FunctionFromDaysSinceYearZero : public IFunction
+{
+
+public:
+    static constexpr auto name = Traits::name;
+    using RawReturnType = typename Traits::ReturnDataType::FieldType;
+
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionFromDaysSinceYearZero>(); }
+
+    String getName() const override { return name; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    size_t getNumberOfArguments() const override { return 1; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors args{
+            {"days", &isNativeUnsignedInteger<IDataType>, nullptr, "UInt*"}
+        };
+
+        validateFunctionArgumentTypes(*this, arguments, args);
+
+        return std::make_shared<typename Traits::ReturnDataType>();
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        auto res_column = Traits::ReturnDataType::ColumnType::create(input_rows_count);
+        const auto & src_column = arguments[0];
+
+        auto try_type = [&]<typename T>(T)
+        {
+            using ColVecType = ColumnVector<T>;
+
+            if (const ColVecType * col_vec = checkAndGetColumn<ColVecType>(src_column.column.get()))
+            {
+                execute<T>(*col_vec, *res_column, input_rows_count);
+                return true;
+            }
+            return false;
+        };
+
+        const bool success = try_type(UInt8{}) || try_type(UInt16{}) || try_type(UInt32{}) || try_type(UInt64{});
+
+        if (!success)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal column while execute function {}", getName());
+
+        return res_column;
+    }
+
+    template <typename T, typename ColVecType, typename ResCol>
+    void execute(const ColVecType & col, ResCol & result_column, size_t rows_count) const
+    {
+        const auto & src_data = col.getData();
+        auto & dst_data = result_column.getData();
+        dst_data.resize(rows_count);
+
+        using equivalent_integer = typename std::conditional_t<sizeof(T) == 4, UInt32, UInt64>;
+
+        for (size_t i = 0; i < rows_count; ++i)
+        {
+            auto raw_value = src_data[i];
+            auto value = static_cast<equivalent_integer>(raw_value);
+            dst_data[i] = static_cast<RawReturnType>(value - ToDaysSinceYearZeroImpl::DAYS_BETWEEN_YEARS_0_AND_1970);
+        }
+    }
+};
+
+
+}
+
+REGISTER_FUNCTION(FromDaysSinceYearZero)
+{
+    factory.registerFunction<FunctionFromDaysSinceYearZero<DateTraits>>(FunctionDocumentation{
+        .description = R"(
+Given the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.
+The calculation is the same as in MySQL's FROM_DAYS() function.
+)",
+        .examples{{"typical", "SELECT fromDaysSinceYearZero(713569)", "2023-09-08"}},
+        .categories{"Dates and Times"}});
+
+    factory.registerFunction<FunctionFromDaysSinceYearZero<DateTraits32>>(FunctionDocumentation{
+        .description = R"(
+Given the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.
+The calculation is the same as in MySQL's FROM_DAYS() function.
+)",
+        .examples{{"typical", "SELECT fromDaysSinceYearZero32(713569)", "2023-09-08"}},
+        .categories{"Dates and Times"}});
+
+    factory.registerAlias("FROM_DAYS", FunctionFromDaysSinceYearZero<DateTraits>::name, FunctionFactory::CaseInsensitive);
+}
+
+}
diff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp
index 61a17359d9ea..1381e9f28288 100644
--- a/src/Functions/makeDate.cpp
+++ b/src/Functions/makeDate.cpp
@@ -36,15 +36,8 @@ namespace
 class FunctionWithNumericParamsBase : public IFunction
 {
 public:
-    bool isInjective(const ColumnsWithTypeAndName &) const override
-    {
-        return false; /// invalid argument values and timestamps that are out of supported range are converted into a default value
-    }
-
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
 
-    bool useDefaultImplementationForNulls() const override { return true; }
-
     bool useDefaultImplementationForConstants() const override { return true; }
 
     bool isVariadic() const override { return true; }
@@ -191,7 +184,6 @@ class FunctionYYYYYMMDDToDate : public FunctionWithNumericParamsBase
 
     String getName() const override { return name; }
 
-    bool isVariadic() const override { return false; }
     size_t getNumberOfArguments() const override { return mandatory_argument_names.size(); }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index d4e8a802aae2..d00846d35888 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1495,6 +1495,7 @@ formated
 formatschema
 formatter
 freezed
+fromDaysSinceYearZero
 fromModifiedJulianDay
 fromModifiedJulianDayOrNull
 fromUTCTimestamp
