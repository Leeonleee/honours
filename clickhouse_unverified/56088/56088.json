{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56088,
  "instance_id": "ClickHouse__ClickHouse-56088",
  "issue_numbers": [
    "55308"
  ],
  "base_commit": "9c79c165b939143312a960081b371598f37232e2",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 4160cbd9c811..4df5e2afcbf7 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -1557,10 +1557,10 @@ Returns for a given date, the number of days passed since [1 January 0000](https\n toDaysSinceYearZero(date[, time_zone])\n ```\n \n-Aliases: `TO_DAYS`\n-\n+Alias: `TO_DAYS`\n \n **Arguments**\n+\n - `date` \u2014 The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).\n - `time_zone` \u2014 A String type const value or a expression represent the time zone. [String types](../../sql-reference/data-types/string.md)\n \n@@ -1584,6 +1584,56 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+**See Also**\n+\n+- [fromDaysSinceYearZero](#fromDaysSinceYearZero)\n+\n+## fromDaysSinceYearZero\n+\n+Returns for a given number of days passed since [1 January 0000](https://en.wikipedia.org/wiki/Year_zero) the corresponding date in the [proleptic Gregorian calendar defined by ISO 8601](https://en.wikipedia.org/wiki/Gregorian_calendar#Proleptic_Gregorian_calendar). The calculation is the same as in MySQL's [`FROM_DAYS()`](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_from-days) function.\n+\n+The result is undefined if it cannot be represented within the bounds of the [Date](../../sql-reference/data-types/date.md) type.\n+\n+**Syntax**\n+\n+``` sql\n+fromDaysSinceYearZero(days)\n+```\n+\n+Alias: `FROM_DAYS`\n+\n+**Arguments**\n+\n+- `days` \u2014 The number of days passed since year zero.\n+\n+**Returned value**\n+\n+The date corresponding to the number of days passed since year zero.\n+\n+Type: [Date](../../sql-reference/data-types/date.md).\n+\n+**Example**\n+\n+``` sql\n+SELECT fromDaysSinceYearZero(739136), fromDaysSinceYearZero(toDaysSinceYearZero(toDate('2023-09-08')));\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500fromDaysSinceYearZero(739136)\u2500\u252c\u2500fromDaysSinceYearZero(toDaysSinceYearZero(toDate('2023-09-08')))\u2500\u2510\n+\u2502                    2023-09-08 \u2502                                                       2023-09-08 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**See Also**\n+\n+- [toDaysSinceYearZero](#toDaysSinceYearZero)\n+\n+## fromDaysSinceYearZero32\n+\n+Like [fromDaysSinceYearZero](#fromDaysSinceYearZero) but returns a [Date32](../../sql-reference/data-types/date32.md).\n+\n ## age\n \n Returns the `unit` component of the difference between `startdate` and `enddate`. The difference is calculated using a precision of 1 microsecond.\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 7f5cd88fa2bd..f334cd9ff241 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -458,6 +458,8 @@ inline bool isUInt32(const T & data_type) { return WhichDataType(data_type).isUI\n template <typename T>\n inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }\n template <typename T>\n+inline bool isNativeUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isNativeUInt(); }\n+template <typename T>\n inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }\n \n template <typename T>\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 9737e69bf340..74b37e189070 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -1387,10 +1387,11 @@ struct ToDayOfYearImpl\n struct ToDaysSinceYearZeroImpl\n {\n private:\n-    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().\n     static constexpr auto SECONDS_PER_DAY = 60 * 60 * 24;\n \n public:\n+    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().\n+\n     static constexpr auto name = \"toDaysSinceYearZero\";\n \n     static UInt32 execute(Int64 t, const DateLUTImpl & time_zone)\ndiff --git a/src/Functions/fromDaysSinceYearZero.cpp b/src/Functions/fromDaysSinceYearZero.cpp\nnew file mode 100644\nindex 000000000000..804a243cda01\n--- /dev/null\n+++ b/src/Functions/fromDaysSinceYearZero.cpp\n@@ -0,0 +1,137 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/DateTimeTransforms.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnDecimal.h>\n+#include <Columns/ColumnsDateTime.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Interpreters/castColumn.h>\n+\n+#include <Common/DateLUT.h>\n+#include <Common/typeid_cast.h>\n+\n+#include <array>\n+#include <cmath>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+namespace\n+{\n+\n+struct DateTraits\n+{\n+    static constexpr auto name = \"fromDaysSinceYearZero\";\n+    using ReturnDataType = DataTypeDate;\n+};\n+\n+struct DateTraits32\n+{\n+    static constexpr auto name = \"fromDaysSinceYearZero32\";\n+    using ReturnDataType = DataTypeDate32;\n+};\n+\n+template <typename Traits>\n+class FunctionFromDaysSinceYearZero : public IFunction\n+{\n+\n+public:\n+    static constexpr auto name = Traits::name;\n+    using RawReturnType = typename Traits::ReturnDataType::FieldType;\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionFromDaysSinceYearZero>(); }\n+\n+    String getName() const override { return name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"days\", &isNativeUnsignedInteger<IDataType>, nullptr, \"UInt*\"}\n+        };\n+\n+        validateFunctionArgumentTypes(*this, arguments, args);\n+\n+        return std::make_shared<typename Traits::ReturnDataType>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto res_column = Traits::ReturnDataType::ColumnType::create(input_rows_count);\n+        const auto & src_column = arguments[0];\n+\n+        auto try_type = [&]<typename T>(T)\n+        {\n+            using ColVecType = ColumnVector<T>;\n+\n+            if (const ColVecType * col_vec = checkAndGetColumn<ColVecType>(src_column.column.get()))\n+            {\n+                execute<T>(*col_vec, *res_column, input_rows_count);\n+                return true;\n+            }\n+            return false;\n+        };\n+\n+        const bool success = try_type(UInt8{}) || try_type(UInt16{}) || try_type(UInt32{}) || try_type(UInt64{});\n+\n+        if (!success)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal column while execute function {}\", getName());\n+\n+        return res_column;\n+    }\n+\n+    template <typename T, typename ColVecType, typename ResCol>\n+    void execute(const ColVecType & col, ResCol & result_column, size_t rows_count) const\n+    {\n+        const auto & src_data = col.getData();\n+        auto & dst_data = result_column.getData();\n+        dst_data.resize(rows_count);\n+\n+        using equivalent_integer = typename std::conditional_t<sizeof(T) == 4, UInt32, UInt64>;\n+\n+        for (size_t i = 0; i < rows_count; ++i)\n+        {\n+            auto raw_value = src_data[i];\n+            auto value = static_cast<equivalent_integer>(raw_value);\n+            dst_data[i] = static_cast<RawReturnType>(value - ToDaysSinceYearZeroImpl::DAYS_BETWEEN_YEARS_0_AND_1970);\n+        }\n+    }\n+};\n+\n+\n+}\n+\n+REGISTER_FUNCTION(FromDaysSinceYearZero)\n+{\n+    factory.registerFunction<FunctionFromDaysSinceYearZero<DateTraits>>(FunctionDocumentation{\n+        .description = R\"(\n+Given the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.\n+The calculation is the same as in MySQL's FROM_DAYS() function.\n+)\",\n+        .examples{{\"typical\", \"SELECT fromDaysSinceYearZero(713569)\", \"2023-09-08\"}},\n+        .categories{\"Dates and Times\"}});\n+\n+    factory.registerFunction<FunctionFromDaysSinceYearZero<DateTraits32>>(FunctionDocumentation{\n+        .description = R\"(\n+Given the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601 return a corresponding date.\n+The calculation is the same as in MySQL's FROM_DAYS() function.\n+)\",\n+        .examples{{\"typical\", \"SELECT fromDaysSinceYearZero32(713569)\", \"2023-09-08\"}},\n+        .categories{\"Dates and Times\"}});\n+\n+    factory.registerAlias(\"FROM_DAYS\", FunctionFromDaysSinceYearZero<DateTraits>::name, FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp\nindex 61a17359d9ea..1381e9f28288 100644\n--- a/src/Functions/makeDate.cpp\n+++ b/src/Functions/makeDate.cpp\n@@ -36,15 +36,8 @@ namespace\n class FunctionWithNumericParamsBase : public IFunction\n {\n public:\n-    bool isInjective(const ColumnsWithTypeAndName &) const override\n-    {\n-        return false; /// invalid argument values and timestamps that are out of supported range are converted into a default value\n-    }\n-\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n-    bool useDefaultImplementationForNulls() const override { return true; }\n-\n     bool useDefaultImplementationForConstants() const override { return true; }\n \n     bool isVariadic() const override { return true; }\n@@ -191,7 +184,6 @@ class FunctionYYYYYMMDDToDate : public FunctionWithNumericParamsBase\n \n     String getName() const override { return name; }\n \n-    bool isVariadic() const override { return false; }\n     size_t getNumberOfArguments() const override { return mandatory_argument_names.size(); }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex d4e8a802aae2..d00846d35888 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1495,6 +1495,7 @@ formated\n formatschema\n formatter\n freezed\n+fromDaysSinceYearZero\n fromModifiedJulianDay\n fromModifiedJulianDayOrNull\n fromUTCTimestamp\n",
  "test_patch": "diff --git a/tests/fuzz/all.dict b/tests/fuzz/all.dict\nindex 8ded66cbd0d7..b38e2c11a1c4 100644\n--- a/tests/fuzz/all.dict\n+++ b/tests/fuzz/all.dict\n@@ -461,6 +461,9 @@\n \"FREEZE\"\n \"FROM\"\n \"FROM_BASE64\"\n+\"toDaysSinceYearZero\"\n+\"fromDaysSinceYearZero\"\n+\"fromDaysSinceYearZero32\"\n \"fromModifiedJulianDay\"\n \"fromModifiedJulianDayOrNull\"\n \"FROM_UNIXTIME\"\ndiff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex dfadb645f3f7..3fe8dbfe5016 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -336,6 +336,9 @@\n \"arraySort\"\n \"arrayPartialSort\"\n \"arrayPartialReverseSort\"\n+\"toDaysSinceYearZero\"\n+\"fromDaysSinceYearZero\"\n+\"fromDaysSinceYearZero32\"\n \"dumpColumnStructure\"\n \"multiSearchFirstIndex\"\n \"arrayReverseSplit\"\ndiff --git a/tests/queries/0_stateless/02907_fromDaysSinceYearZero.reference b/tests/queries/0_stateless/02907_fromDaysSinceYearZero.reference\nnew file mode 100644\nindex 000000000000..ac0f4662db27\n--- /dev/null\n+++ b/tests/queries/0_stateless/02907_fromDaysSinceYearZero.reference\n@@ -0,0 +1,22 @@\n+-- negative tests\n+-- const and non-const arguments\n+719527\t2149-06-06\t2149-06-06\n+719528\t1970-01-01\t1970-01-01\n+719529\t1970-01-02\t1970-01-02\n+785062\t2149-06-05\t2149-06-05\n+785063\t2149-06-06\t2149-06-06\n+785064\t1970-01-01\t1970-01-01\n+693960\t2299-12-31\t2299-12-31\n+693961\t1900-01-01\t1900-01-01\n+693962\t1900-01-02\t1900-01-02\n+840056\t2299-12-30\t2299-12-30\n+840057\t2299-12-31\t2299-12-31\n+840058\t2299-12-31\t2299-12-31\n+-- integer types != UInt32\n+255\t1974-06-12\t2299-12-31\n+65535\t1973-09-29\t2299-12-31\n+719529\t1970-01-02\t1970-01-02\n+-- NULL handling\n+\\N\t\\N\n+-- Alias\n+1973-10-01\ndiff --git a/tests/queries/0_stateless/02907_fromDaysSinceYearZero.sql b/tests/queries/0_stateless/02907_fromDaysSinceYearZero.sql\nnew file mode 100644\nindex 000000000000..83cfa01d5edc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02907_fromDaysSinceYearZero.sql\n@@ -0,0 +1,38 @@\n+SET session_timezone = 'Europe/Amsterdam'; -- disable time zone randomization in CI\n+\n+SELECT '-- negative tests';\n+SELECT fromDaysSinceYearZero(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT fromDaysSinceYearZero32(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT fromDaysSinceYearZero(1, 2); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT fromDaysSinceYearZero32(1, 2); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT fromDaysSinceYearZero('needs a number'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT fromDaysSinceYearZero32('needs a number'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT fromDaysSinceYearZero(-3); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT fromDaysSinceYearZero32(-3); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT '-- const and non-const arguments';\n+\n+SELECT 719527 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x)); -- outside Date's range\n+SELECT 719528 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x));\n+SELECT 719529 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x));\n+SELECT 785062 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x));\n+SELECT 785063 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x));\n+SELECT 785064 AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero(materialize(x)); -- outside Date's range\n+\n+SELECT 693960 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x)); -- outside Date32's range\n+SELECT 693961 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x));\n+SELECT 693962 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x));\n+SELECT 840056 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x));\n+SELECT 840057 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x));\n+SELECT 840058 AS x, fromDaysSinceYearZero32(x), fromDaysSinceYearZero32(materialize(x)); -- outside Date32's range\n+\n+SELECT '-- integer types != UInt32';\n+SELECT toUInt8(255) AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero32(x); -- outside Date's range for all UInt8-s\n+SELECT toUInt16(65535) AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero32(x); -- outside Date's range for all UInt16-s\n+SELECT toUInt64(719529) AS x, fromDaysSinceYearZero(x), fromDaysSinceYearZero32(x); -- something useful\n+\n+SELECT '-- NULL handling';\n+SELECT fromDaysSinceYearZero(NULL), fromDaysSinceYearZero32(NULL);\n+\n+SELECT '-- Alias';\n+SELECT FROM_DAYS(1);\n",
  "problem_statement": "Provide fromDaysSinceYearZero()\n#54856 (respectively #54796) added function [toDaysSinceYearZero()](https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#todayssinceyearzero). The main reason to add this function was to have something similar as MySQL's [TO_DAYS()](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days) in ClickHouse (besides that, there is probably little practical use for the function).\r\n\r\nAs per https://github.com/ClickHouse/ClickHouse/pull/54856#issuecomment-1751765802, we should provide the opposite function for consistency, i.e. `fromDaysSinceYearZero()`. See related `from*()` [date/time functions](https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions) for starting points.\n",
  "hints_text": "pls assign me this issue\nAppreciated!\n@rschu1ze I checked the code base and understood that a new file for `fromDaysSinceYearZero()` function has to be created, and referred `toDaysSinceYearZero()`, did i have to write code from the scratch, first making the years counting everything, checking leap years and all.\n@rschu1ze \r\n\r\nIts kind of seem to much stuff for me to parse, can you tell me how to approach. I can make a logic to convert number of days to year but your guidance will help. \n@bhavuk2002 Indeed, you would need to create a new file \"src/Functions/fromDaysSinceYearZero.cpp\". As a template / inspiration, you may look at the implementation of function [makeDate()](https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#makedate). It builds a Date from year / month / day integers which is kind of similar to `fromDaysSinceYearZero()`. To understand how things work, I suggest that you step through `FunctionMakeDate::getReturnTypeImpl()` and `FunctionMakeDate::executeImpl()` using a debugger. Functions derive from interface `IFunction` - its API has documentation, in case you wonder what the individual methods do.\r\n\r\n`toDaysSinceYearZero()` calculates its result as the sum of a constant offset in days until 1970 + the days since 1970 (based on the input data), see `ToDaysSinceYearZeroImpl` in Functions/DateTimeTransforms.h. A similar calculation could be done for `fromDaysSinceYearZero()` - that way, you would not need to care about leap years.\nApparently, this one is a blocker for Tableau Online, see the duplicate issue: https://github.com/ClickHouse/ClickHouse/issues/55992",
  "created_at": "2023-10-27T19:45:57Z"
}