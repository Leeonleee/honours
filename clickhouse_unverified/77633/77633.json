{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 77633,
  "instance_id": "ClickHouse__ClickHouse-77633",
  "issue_numbers": [
    "77553"
  ],
  "base_commit": "08019e1ae51f75d84ee83bc7ed4bddbc320f7740",
  "patch": "diff --git a/src/Interpreters/Cache/QueryResultCache.cpp b/src/Interpreters/Cache/QueryResultCache.cpp\nindex f5883d90b11c..a0c3cea3a3b9 100644\n--- a/src/Interpreters/Cache/QueryResultCache.cpp\n+++ b/src/Interpreters/Cache/QueryResultCache.cpp\n@@ -1,6 +1,8 @@\n #include \"Interpreters/Cache/QueryResultCache.h\"\n \n #include <Functions/FunctionFactory.h>\n+#include <Functions/UserDefined/UserDefinedSQLFunctionFactory.h>\n+#include <Functions/UserDefined/UserDefinedExecutableFunctionFactory.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n@@ -55,9 +57,24 @@ struct HasNonDeterministicFunctionsMatcher\n \n         if (const auto * function = node->as<ASTFunction>())\n         {\n-            const auto func = FunctionFactory::instance().tryGet(function->name, data.context);\n-            if (func && !func->isDeterministic())\n+            if (const auto func = FunctionFactory::instance().tryGet(function->name, data.context))\n+            {\n+                if (!func->isDeterministic())\n+                    data.has_non_deterministic_functions = true;\n+                return;\n+            }\n+            if (const auto udf_sql = UserDefinedSQLFunctionFactory::instance().tryGet(function->name))\n+            {\n+                /// ClickHouse currently doesn't know if SQL-based UDFs are deterministic or not. We must assume they are non-deterministic.\n                 data.has_non_deterministic_functions = true;\n+                return;\n+            }\n+            if (const auto udf_executable = UserDefinedExecutableFunctionFactory::tryGet(function->name, data.context))\n+            {\n+                if (!udf_executable->isDeterministic())\n+                    data.has_non_deterministic_functions = true;\n+                return;\n+            }\n         }\n     }\n };\n",
  "test_patch": "diff --git a/tests/integration/test_executable_user_defined_function/test.py b/tests/integration/test_executable_user_defined_function/test.py\nindex ccc06a7b43a8..8b79223a4d27 100644\n--- a/tests/integration/test_executable_user_defined_function/test.py\n+++ b/tests/integration/test_executable_user_defined_function/test.py\n@@ -163,6 +163,7 @@ def test_executable_function_non_direct_bash(started_cluster):\n def test_executable_function_sum_json_python(started_cluster):\n     skip_test_msan(node)\n \n+    node.query(\"DROP TABLE IF EXISTS test_table;\")\n     node.query(\"CREATE TABLE test_table (lhs UInt64, rhs UInt64) ENGINE=TinyLog;\")\n     node.query(\"INSERT INTO test_table VALUES (0, 0), (1, 1), (2, 2);\")\n \n@@ -234,6 +235,7 @@ def test_executable_function_sum_json_python(started_cluster):\n def test_executable_function_input_nullable_python(started_cluster):\n     skip_test_msan(node)\n \n+    node.query(\"DROP TABLE IF EXISTS test_table_nullable;\")\n     node.query(\n         \"CREATE TABLE test_table_nullable (value Nullable(UInt64)) ENGINE=TinyLog;\"\n     )\n@@ -265,6 +267,8 @@ def test_executable_function_input_nullable_python(started_cluster):\n         == \"Key 0\\nKey Nullable\\nKey 2\\n\"\n     )\n \n+    node.query(\"DROP TABLE test_table_nullable;\")\n+\n \n def test_executable_function_parameter_python(started_cluster):\n     skip_test_msan(node)\n@@ -334,3 +338,25 @@ def test_executable_function_always_error_python(started_cluster):\n         assert False, \"Exception have to be thrown\"\n     except Exception as ex:\n         assert \"DB::Exception: Child process was exited with return code 1\" in str(ex)\n+\n+def test_executable_function_query_cache(started_cluster):\n+    '''Test for issue #77553: Externally-defined UDFs may be non-deterministic. The query cache should treat them as such, i.e. reject them.'''\n+    '''Also see tests/0_stateless/test_query_cache_udf_sql.sql'''\n+    skip_test_msan(node)\n+\n+    node.query(\"SYSTEM DROP QUERY CACHE\");\n+\n+    # query_cache_nondeterministic_function_handling = throw\n+    assert node.query_and_get_error(\"SELECT test_function_bash(1) SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'throw'\")\n+    assert node.query(\"SELECT count(*) FROM system.query_cache\") == \"0\\n\"\n+    node.query(\"SYSTEM DROP QUERY CACHE\");\n+\n+    # query_cache_nondeterministic_function_handling = save\n+    assert node.query(\"SELECT test_function_bash(1) SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'save'\") == \"Key 1\\n\"\n+    assert node.query(\"SELECT count(*) FROM system.query_cache\") == \"1\\n\"\n+    node.query(\"SYSTEM DROP QUERY CACHE\");\n+\n+    # query_cache_nondeterministic_function_handling = ignore\n+    assert node.query(\"SELECT test_function_bash(1) SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'ignore'\") == \"Key 1\\n\"\n+    assert node.query(\"SELECT count(*) FROM system.query_cache\") == \"0\\n\"\n+    node.query(\"SYSTEM DROP QUERY CACHE\");\ndiff --git a/tests/queries/0_stateless/02494_query_cache_udf_sql.reference b/tests/queries/0_stateless/02494_query_cache_udf_sql.reference\nnew file mode 100644\nindex 000000000000..69692d402fc3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_udf_sql.reference\n@@ -0,0 +1,6 @@\n+-- query_cache_nondeterministic_function_handling = throw\n+0\n+-- query_cache_nondeterministic_function_handling = save\n+1\n+-- query_cache_nondeterministic_function_handling = ignore\n+0\ndiff --git a/tests/queries/0_stateless/02494_query_cache_udf_sql.sql b/tests/queries/0_stateless/02494_query_cache_udf_sql.sql\nnew file mode 100644\nindex 000000000000..0a87453400fe\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_udf_sql.sql\n@@ -0,0 +1,27 @@\n+-- Tags: no-parallel\n+-- Tag no-parallel: Messes with internal cache\n+\n+-- Test for issue #77553: SQL-defined UDFs may be non-deterministic. The query cache should treat them as such, i.e. reject them.\n+-- Also see 02494_query_cache_udf_executable.sh\n+\n+SYSTEM DROP QUERY CACHE;\n+DROP FUNCTION IF EXISTS udf;\n+\n+CREATE FUNCTION udf AS (a) -> a + 1;\n+\n+SELECT '-- query_cache_nondeterministic_function_handling = throw';\n+SELECT udf(1) FORMAT Null SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'throw'; -- { serverError QUERY_CACHE_USED_WITH_NONDETERMINISTIC_FUNCTIONS }\n+SELECT count(*) FROM system.query_cache;\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT '-- query_cache_nondeterministic_function_handling = save';\n+SELECT udf(1) FORMAT Null SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'save';\n+SELECT count(*) FROM system.query_cache;\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT '-- query_cache_nondeterministic_function_handling = ignore';\n+SELECT udf(1) FORMAT Null SETTINGS use_query_cache = true, query_cache_nondeterministic_function_handling = 'ignore';\n+SELECT count(*) FROM system.query_cache;\n+SYSTEM DROP QUERY CACHE;\n+\n+DROP FUNCTION udf;\n",
  "problem_statement": "UDF are considered deterministic\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nOpposite to what's described in [QueryCache documentation](https://clickhouse.com/docs/en/operations/query-cache#configuration-settings-and-usage) UDF's are managed as deterministic by default.\n\nThis is opposite to the request in issue #59988 but needs to be fixed before in order to implement that feature.\n\n\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n```sql\nCREATE FUNCTION parity_str AS (n) -> if(n % 2, 'odd', 'even');\nSELECT parity_str(4) settings use_query_cache = 1;\n\nSELECT count(*) FROM system.query_cache; -- returns 1\n```\n\nSomething similar happens with externally defined UDFs.\n\n### Expected behavior\n\nIn the previous example the `SELECT count(*) FROM system.query_cache; `should return `0` at the end.\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n`astContainsNonDeterministicFunctions` internally uses the visitor code in:\n\n`QuerryResultCache.cpp:HasNonDeterministicFunctionsMatcher:visit`\n\nThe problem is that this function uses the UDF function name to call\n\n`FunctionFactory.cpp:FunctionFactory::tryGet`\n\nIgnoring the functions in `UserDefinedSQLFunctionFactory` and `UserDefinedExecutableFunctionFactory`\n\n\n",
  "hints_text": "",
  "created_at": "2025-03-14T15:35:46Z"
}