{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55604,
  "instance_id": "ClickHouse__ClickHouse-55604",
  "issue_numbers": [
    "49449"
  ],
  "base_commit": "7d3e5c480e8ae89453a1f1a071dcfd4701e65d02",
  "patch": "diff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex a7445f89245b..f851607000c0 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -172,7 +172,7 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n \n     if (!partition_commands.empty())\n     {\n-        table->checkAlterPartitionIsPossible(partition_commands, metadata_snapshot, getContext()->getSettingsRef());\n+        table->checkAlterPartitionIsPossible(partition_commands, metadata_snapshot, getContext()->getSettingsRef(), getContext());\n         auto partition_commands_pipe = table->alterPartition(metadata_snapshot, partition_commands, getContext());\n         if (!partition_commands_pipe.empty())\n             res.pipeline = QueryPipeline(std::move(partition_commands_pipe));\ndiff --git a/src/Parsers/ASTPartition.cpp b/src/Parsers/ASTPartition.cpp\nindex 87d159b58170..22eecd37565c 100644\n--- a/src/Parsers/ASTPartition.cpp\n+++ b/src/Parsers/ASTPartition.cpp\n@@ -5,12 +5,39 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+void ASTPartition::setPartitionID(const ASTPtr & ast)\n+{\n+    if (children.empty())\n+    {\n+        children.push_back(ast);\n+        id = children[0].get();\n+    }\n+    else\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot have multiple children for partition AST\");\n+}\n+void ASTPartition::setPartitionValue(const ASTPtr & ast)\n+{\n+    if (children.empty())\n+    {\n+        children.push_back(ast);\n+        value = children[0].get();\n+    }\n+    else\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot have multiple children for partition AST\");\n+}\n+\n+\n String ASTPartition::getID(char delim) const\n {\n     if (value)\n         return \"Partition\";\n     else\n-        return \"Partition_ID\" + (delim + id);\n+        return \"Partition_ID\" + (delim + id->getID());\n }\n \n ASTPtr ASTPartition::clone() const\n@@ -20,8 +47,14 @@ ASTPtr ASTPartition::clone() const\n \n     if (value)\n     {\n-        res->value = value->clone();\n-        res->children.push_back(res->value);\n+        res->children.push_back(children[0]->clone());\n+        res->value = res->children[0].get();\n+    }\n+\n+    if (id)\n+    {\n+        res->children.push_back(children[0]->clone());\n+        res->id = res->children[0].get();\n     }\n \n     return res;\n@@ -33,18 +66,14 @@ void ASTPartition::formatImpl(const FormatSettings & settings, FormatState & sta\n     {\n         value->formatImpl(settings, state, frame);\n     }\n+    else if (all)\n+    {\n+        settings.ostr << \"ALL\";\n+    }\n     else\n     {\n-        if (all)\n-            settings.ostr << \"ALL\";\n-        else\n-        {\n-            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"ID \" << (settings.hilite ? hilite_none : \"\");\n-            WriteBufferFromOwnString id_buf;\n-            writeQuoted(id, id_buf);\n-            settings.ostr << id_buf.str();\n-        }\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"ID \" << (settings.hilite ? hilite_none : \"\");\n+        id->formatImpl(settings, state, frame);\n     }\n }\n-\n }\ndiff --git a/src/Parsers/ASTPartition.h b/src/Parsers/ASTPartition.h\nindex fbe05ce3a8e0..b2c87bb446ab 100644\n--- a/src/Parsers/ASTPartition.h\n+++ b/src/Parsers/ASTPartition.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <Parsers/IAST.h>\n-\n+#include <optional>\n \n namespace DB\n {\n@@ -10,15 +10,24 @@ namespace DB\n class ASTPartition : public IAST\n {\n public:\n-    ASTPtr value;\n-    size_t fields_count = 0;\n+    IAST * value{nullptr};\n+    std::optional<size_t> fields_count;\n \n-    String id;\n+    IAST * id{nullptr};\n     bool all = false;\n \n     String getID(char) const override;\n     ASTPtr clone() const override;\n \n+    void setPartitionID(const ASTPtr & ast);\n+    void setPartitionValue(const ASTPtr & ast);\n+\n+    void forEachPointerToChild(std::function<void(void **)> f) override\n+    {\n+        f(reinterpret_cast<void **>(&value));\n+        f(reinterpret_cast<void **>(&id));\n+    }\n+\n protected:\n     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n };\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex 040a81bbe278..6dba5a9c31f4 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -173,7 +173,7 @@ class ParserLeftAssociativeBinaryOperatorList : public IParserBase\n class ParserExpression : public IParserBase\n {\n public:\n-    ParserExpression(bool allow_trailing_commas_ = false) : allow_trailing_commas(allow_trailing_commas_) {}\n+    explicit ParserExpression(bool allow_trailing_commas_ = false) : allow_trailing_commas(allow_trailing_commas_) {}\n \n protected:\n     const char * getName() const override { return \"lambda expression\"; }\ndiff --git a/src/Parsers/ParserPartition.cpp b/src/Parsers/ParserPartition.cpp\nindex 9f1d4d4e889d..80debc13c676 100644\n--- a/src/Parsers/ParserPartition.cpp\n+++ b/src/Parsers/ParserPartition.cpp\n@@ -7,6 +7,7 @@\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Common/typeid_cast.h>\n+#include <Parsers/ASTQueryParameter.h>\n \n namespace DB\n {\n@@ -16,19 +17,25 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_id(\"ID\");\n     ParserKeyword s_all(\"ALL\");\n     ParserStringLiteral parser_string_literal;\n+    ParserSubstitution parser_substitution;\n+    ParserLiteral literal_parser;\n+    ParserTupleOfLiterals tuple_of_literals;\n     ParserExpression parser_expr;\n \n-    Pos begin = pos;\n-\n     auto partition = std::make_shared<ASTPartition>();\n \n     if (s_id.ignore(pos, expected))\n     {\n         ASTPtr partition_id;\n-        if (!parser_string_literal.parse(pos, partition_id, expected))\n+        if (!parser_string_literal.parse(pos, partition_id, expected) && !parser_substitution.parse(pos, partition_id, expected))\n             return false;\n \n-        partition->id = partition_id->as<ASTLiteral &>().value.get<String>();\n+        if (auto * partition_id_literal = partition_id->as<ASTLiteral>(); partition_id_literal != nullptr)\n+            partition->setPartitionID(partition_id);\n+        else if (auto * partition_id_query_parameter = partition_id->as<ASTQueryParameter>(); partition_id_query_parameter != nullptr)\n+            partition->setPartitionID(partition_id);\n+        else\n+            return false;\n     }\n     else if (s_all.ignore(pos, expected))\n     {\n@@ -37,27 +44,12 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     else\n     {\n         ASTPtr value;\n-        if (!parser_expr.parse(pos, value, expected))\n-            return false;\n-\n-        size_t fields_count;\n-\n-        const auto * tuple_ast = value->as<ASTFunction>();\n-        bool surrounded_by_parens = false;\n-        if (tuple_ast && tuple_ast->name == \"tuple\")\n-        {\n-            surrounded_by_parens = true;\n-            const auto * arguments_ast = tuple_ast->arguments->as<ASTExpressionList>();\n-            if (arguments_ast)\n-                fields_count = arguments_ast->children.size();\n-            else\n-                fields_count = 0;\n-        }\n-        else if (const auto * literal = value->as<ASTLiteral>())\n+        std::optional<size_t> fields_count;\n+        if (literal_parser.parse(pos, value, expected) || tuple_of_literals.parse(pos, value, expected))\n         {\n+            auto * literal = value->as<ASTLiteral>();\n             if (literal->value.getType() == Field::Types::Tuple)\n             {\n-                surrounded_by_parens = true;\n                 fields_count = literal->value.get<const Tuple &>().size();\n             }\n             else\n@@ -65,27 +57,31 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                 fields_count = 1;\n             }\n         }\n-        else\n-            return false;\n-\n-        if (surrounded_by_parens)\n+        else if (parser_substitution.parse(pos, value, expected))\n         {\n-            Pos left_paren = begin;\n-            Pos right_paren = pos;\n-\n-            while (left_paren != right_paren && left_paren->type != TokenType::OpeningRoundBracket)\n-                ++left_paren;\n-            if (left_paren->type != TokenType::OpeningRoundBracket)\n-                return false;\n-\n-            while (right_paren != left_paren && right_paren->type != TokenType::ClosingRoundBracket)\n-                --right_paren;\n-            if (right_paren->type != TokenType::ClosingRoundBracket)\n+            /// It can be tuple substitution\n+            fields_count = std::nullopt;\n+        }\n+        else if (parser_expr.parse(pos, value, expected))\n+        {\n+            const auto * tuple_ast = value->as<ASTFunction>();\n+            if (tuple_ast && tuple_ast->name == \"tuple\")\n+            {\n+                const auto * arguments_ast = tuple_ast->arguments->as<ASTExpressionList>();\n+                if (arguments_ast)\n+                    fields_count = arguments_ast->children.size();\n+                else\n+                    fields_count = 0;\n+            }\n+            else\n                 return false;\n         }\n+        else\n+        {\n+            return false;\n+        }\n \n-        partition->value = value;\n-        partition->children.push_back(value);\n+        partition->setPartitionValue(value);\n         partition->fields_count = fields_count;\n     }\n \ndiff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp\nindex ae7659e074f5..e98b38438b93 100644\n--- a/src/Storages/IStorage.cpp\n+++ b/src/Storages/IStorage.cpp\n@@ -211,7 +211,10 @@ void IStorage::checkMutationIsPossible(const MutationCommands & /*commands*/, co\n }\n \n void IStorage::checkAlterPartitionIsPossible(\n-    const PartitionCommands & /*commands*/, const StorageMetadataPtr & /*metadata_snapshot*/, const Settings & /*settings*/) const\n+    const PartitionCommands & /*commands*/,\n+    const StorageMetadataPtr & /*metadata_snapshot*/,\n+    const Settings & /*settings*/,\n+    ContextPtr /*context*/) const\n {\n     throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Table engine {} doesn't support partitioning\", getName());\n }\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex fcf7675d15d6..92920c50ba9f 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -495,7 +495,11 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n         ContextPtr /* context */);\n \n     /// Checks that partition commands can be applied to storage.\n-    virtual void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const;\n+    virtual void checkAlterPartitionIsPossible(\n+        const PartitionCommands & commands,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const Settings & settings,\n+        ContextPtr context) const;\n \n     /** Perform any background work. For example, combining parts in a MergeTree type table.\n       * Returns whether any work has been done.\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex fd5d9f736cce..63214ba671b6 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -37,6 +37,7 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/convertFieldToType.h>\n #include <Interpreters/evaluateConstantExpression.h>\n+#include <Interpreters/ReplaceQueryParameterVisitor.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/inplaceBlockConversions.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n@@ -52,6 +53,7 @@\n #include <IO/SharedThreadPools.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTIndexDeclaration.h>\n+#include <Parsers/ASTHelpers.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTNameTypePair.h>\n@@ -62,6 +64,7 @@\n #include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n #include <Parsers/ASTAlterQuery.h>\n+#include <Parsers/ASTQueryParameter.h>\n #include <Processors/Formats/IInputFormat.h>\n #include <Processors/QueryPlan/QueryIdHolder.h>\n #include <Processors/QueryPlan/ReadFromMergeTree.h>\n@@ -2967,7 +2970,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n         /// Just validate partition expression\n         if (command.partition)\n         {\n-            getPartitionIDFromQuery(command.partition, getContext());\n+            getPartitionIDFromQuery(command.partition, local_context);\n         }\n \n         if (command.column_name == merging_params.version_column)\n@@ -4635,7 +4638,7 @@ void MergeTreeData::removePartContributionToColumnAndSecondaryIndexSizes(const D\n }\n \n void MergeTreeData::checkAlterPartitionIsPossible(\n-    const PartitionCommands & commands, const StorageMetadataPtr & /*metadata_snapshot*/, const Settings & settings) const\n+    const PartitionCommands & commands, const StorageMetadataPtr & /*metadata_snapshot*/, const Settings & settings, ContextPtr local_context) const\n {\n     for (const auto & command : commands)\n     {\n@@ -4663,7 +4666,7 @@ void MergeTreeData::checkAlterPartitionIsPossible(\n                         throw DB::Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Only support DROP/DETACH PARTITION ALL currently\");\n                 }\n                 else\n-                    getPartitionIDFromQuery(command.partition, getContext());\n+                    getPartitionIDFromQuery(command.partition, local_context);\n             }\n         }\n     }\n@@ -5342,8 +5345,71 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n \n     if (!partition_ast.value)\n     {\n-        MergeTreePartInfo::validatePartitionID(partition_ast.id, format_version);\n-        return partition_ast.id;\n+        MergeTreePartInfo::validatePartitionID(partition_ast.id->clone(), format_version);\n+        return partition_ast.id->as<ASTLiteral>()->value.safeGet<String>();\n+    }\n+    size_t partition_ast_fields_count = 0;\n+    ASTPtr partition_value_ast = partition_ast.value->clone();\n+    if (!partition_ast.fields_count.has_value())\n+    {\n+        if (partition_value_ast->as<ASTLiteral>())\n+        {\n+            partition_ast_fields_count = 1;\n+        }\n+        else if (const auto * tuple_ast = partition_value_ast->as<ASTFunction>())\n+        {\n+            if (tuple_ast->name != \"tuple\")\n+            {\n+                if (isFunctionCast(tuple_ast))\n+                {\n+                    if (tuple_ast->arguments->as<ASTExpressionList>()->children.empty())\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::INVALID_PARTITION_VALUE, \"Expected tuple for complex partition key, got {}\", tuple_ast->name);\n+                    }\n+                    auto first_arg = tuple_ast->arguments->as<ASTExpressionList>()->children.at(0);\n+                    if (const auto * inner_tuple = first_arg->as<ASTFunction>(); inner_tuple && inner_tuple->name == \"tuple\")\n+                    {\n+                        const auto * arguments_ast = tuple_ast->arguments->as<ASTExpressionList>();\n+                        if (arguments_ast)\n+                            partition_ast_fields_count = arguments_ast->children.size();\n+                        else\n+                            partition_ast_fields_count = 0;\n+                    }\n+                    else if (const auto * inner_literal_tuple = first_arg->as<ASTLiteral>(); inner_literal_tuple)\n+                    {\n+                        if (inner_literal_tuple->value.getType() == Field::Types::Tuple)\n+                            partition_ast_fields_count = inner_literal_tuple->value.safeGet<Tuple>().size();\n+                        else\n+                            partition_ast_fields_count = 1;\n+                    }\n+                    else\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::INVALID_PARTITION_VALUE, \"Expected tuple for complex partition key, got {}\", tuple_ast->name);\n+                    }\n+                }\n+                else\n+                    throw Exception(ErrorCodes::INVALID_PARTITION_VALUE, \"Expected tuple for complex partition key, got {}\", tuple_ast->name);\n+            }\n+            else\n+            {\n+                const auto * arguments_ast = tuple_ast->arguments->as<ASTExpressionList>();\n+                if (arguments_ast)\n+                    partition_ast_fields_count = arguments_ast->children.size();\n+                else\n+                    partition_ast_fields_count = 0;\n+            }\n+        }\n+        else\n+        {\n+            throw Exception(\n+                ErrorCodes::INVALID_PARTITION_VALUE, \"Expected literal or tuple for partition key, got {}\", partition_value_ast->getID());\n+        }\n+    }\n+    else\n+    {\n+        partition_ast_fields_count = *partition_ast.fields_count;\n     }\n \n     if (format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)\n@@ -5352,9 +5418,8 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n         const auto * partition_lit = partition_ast.value->as<ASTLiteral>();\n         if (partition_lit && partition_lit->value.getType() == Field::Types::String)\n         {\n-            String partition_id = partition_lit->value.get<String>();\n-            MergeTreePartInfo::validatePartitionID(partition_id, format_version);\n-            return partition_id;\n+            MergeTreePartInfo::validatePartitionID(partition_ast.value->clone(), format_version);\n+            return partition_lit->value.get<String>();\n         }\n     }\n \n@@ -5362,35 +5427,48 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     const Block & key_sample_block = metadata_snapshot->getPartitionKey().sample_block;\n     size_t fields_count = key_sample_block.columns();\n-    if (partition_ast.fields_count != fields_count)\n+    if (partition_ast_fields_count != fields_count)\n         throw Exception(ErrorCodes::INVALID_PARTITION_VALUE,\n                         \"Wrong number of fields in the partition expression: {}, must be: {}\",\n-                        partition_ast.fields_count, fields_count);\n+                        partition_ast_fields_count, fields_count);\n \n     Row partition_row(fields_count);\n     if (fields_count == 0)\n     {\n         /// Function tuple(...) requires at least one argument, so empty key is a special case\n-        assert(!partition_ast.fields_count);\n-        assert(typeid_cast<ASTFunction *>(partition_ast.value.get()));\n-        assert(partition_ast.value->as<ASTFunction>()->name == \"tuple\");\n-        assert(partition_ast.value->as<ASTFunction>()->arguments);\n-        auto args = partition_ast.value->as<ASTFunction>()->arguments;\n+        assert(!partition_ast_fields_count);\n+        assert(typeid_cast<ASTFunction *>(partition_value_ast.get()));\n+        assert(partition_value_ast->as<ASTFunction>()->name == \"tuple\");\n+        assert(partition_value_ast->as<ASTFunction>()->arguments);\n+        auto args = partition_value_ast->as<ASTFunction>()->arguments;\n         if (!args)\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected at least one argument in partition AST\");\n-        bool empty_tuple = partition_ast.value->as<ASTFunction>()->arguments->children.empty();\n+        bool empty_tuple = partition_value_ast->as<ASTFunction>()->arguments->children.empty();\n         if (!empty_tuple)\n             throw Exception(ErrorCodes::INVALID_PARTITION_VALUE, \"Partition key is empty, expected 'tuple()' as partition key\");\n     }\n     else if (fields_count == 1)\n     {\n-        ASTPtr partition_value_ast = partition_ast.value;\n-        if (auto * tuple = partition_value_ast->as<ASTFunction>())\n+        if (auto * tuple = partition_value_ast->as<ASTFunction>(); tuple)\n         {\n-            assert(tuple->name == \"tuple\");\n-            assert(tuple->arguments);\n-            assert(tuple->arguments->children.size() == 1);\n-            partition_value_ast = tuple->arguments->children[0];\n+            if (tuple->name == \"tuple\")\n+            {\n+                assert(tuple->arguments);\n+                assert(tuple->arguments->children.size() == 1);\n+                partition_value_ast = tuple->arguments->children[0];\n+            }\n+            else if (isFunctionCast(tuple))\n+            {\n+                assert(tuple->arguments);\n+                assert(tuple->arguments->children.size() == 2);\n+            }\n+            else\n+            {\n+                throw Exception(\n+                    ErrorCodes::INVALID_PARTITION_VALUE,\n+                    \"Expected literal or tuple for partition key, got {}\",\n+                    partition_value_ast->getID());\n+            }\n         }\n         /// Simple partition key, need to evaluate and cast\n         Field partition_key_value = evaluateConstantExpression(partition_value_ast, local_context).first;\n@@ -5399,7 +5477,7 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n     else\n     {\n         /// Complex key, need to evaluate, untuple and cast\n-        Field partition_key_value = evaluateConstantExpression(partition_ast.value, local_context).first;\n+        Field partition_key_value = evaluateConstantExpression(partition_value_ast, local_context).first;\n         if (partition_key_value.getType() != Field::Types::Tuple)\n             throw Exception(ErrorCodes::INVALID_PARTITION_VALUE,\n                             \"Expected tuple for complex partition key, got {}\", partition_key_value.getTypeName());\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 93b8e69438e1..a8dac7cbade4 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -723,7 +723,11 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     void checkMutationIsPossible(const MutationCommands & commands, const Settings & settings) const override;\n \n     /// Checks that partition name in all commands is valid\n-    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override;\n+    void checkAlterPartitionIsPossible(\n+        const PartitionCommands & commands,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const Settings & settings,\n+        ContextPtr local_context) const override;\n \n     /// Change MergeTreeSettings\n     void changeSettings(\ndiff --git a/src/Storages/MergeTree/MergeTreePartInfo.cpp b/src/Storages/MergeTree/MergeTreePartInfo.cpp\nindex e1b52d8a7b7c..16c119c642ab 100644\n--- a/src/Storages/MergeTree/MergeTreePartInfo.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartInfo.cpp\n@@ -2,7 +2,8 @@\n #include <IO/ReadBufferFromString.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n-#include \"Core/ProtocolDefines.h\"\n+#include <Core/ProtocolDefines.h>\n+#include <Parsers/ASTLiteral.h>\n \n namespace DB\n {\n@@ -23,8 +24,15 @@ MergeTreePartInfo MergeTreePartInfo::fromPartName(const String & part_name, Merg\n         throw Exception(ErrorCodes::BAD_DATA_PART_NAME, \"Unexpected part name: {} for format version: {}\", part_name, format_version);\n }\n \n-void MergeTreePartInfo::validatePartitionID(const String & partition_id, MergeTreeDataFormatVersion format_version)\n+void MergeTreePartInfo::validatePartitionID(const ASTPtr & partition_id_ast, MergeTreeDataFormatVersion format_version)\n {\n+    std::string partition_id;\n+    if (auto * literal = partition_id_ast->as<ASTLiteral>(); literal != nullptr && literal->value.getType() == Field::Types::String)\n+        partition_id = literal->value.safeGet<String>();\n+\n+    else\n+        throw Exception(ErrorCodes::INVALID_PARTITION_VALUE, \"Partition id must be string literal\");\n+\n     if (partition_id.empty())\n         throw Exception(ErrorCodes::INVALID_PARTITION_VALUE, \"Partition id is empty\");\n \ndiff --git a/src/Storages/MergeTree/MergeTreePartInfo.h b/src/Storages/MergeTree/MergeTreePartInfo.h\nindex 9b14d4a2aced..d359e23901f2 100644\n--- a/src/Storages/MergeTree/MergeTreePartInfo.h\n+++ b/src/Storages/MergeTree/MergeTreePartInfo.h\n@@ -9,6 +9,7 @@\n #include <base/DayNum.h>\n #include <IO/ReadBuffer.h>\n #include <IO/WriteBuffer.h>\n+#include <Parsers/IAST_fwd.h>\n #include <Storages/MergeTree/MergeTreeDataFormatVersion.h>\n \n \n@@ -119,7 +120,7 @@ struct MergeTreePartInfo\n     void deserialize(ReadBuffer & in);\n \n     /// Simple sanity check for partition ID. Checking that it's not too long or too short, doesn't contain a lot of '_'.\n-    static void validatePartitionID(const String & partition_id, MergeTreeDataFormatVersion format_version);\n+    static void validatePartitionID(const ASTPtr & partition_id_ast, MergeTreeDataFormatVersion format_version);\n \n     static MergeTreePartInfo fromPartName(const String & part_name, MergeTreeDataFormatVersion format_version);\n \ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 7354dd565522..78dc89857b7b 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -330,10 +330,11 @@ Pipe StorageMaterializedView::alterPartition(\n }\n \n void StorageMaterializedView::checkAlterPartitionIsPossible(\n-    const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const\n+    const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot,\n+    const Settings & settings, ContextPtr local_context) const\n {\n     checkStatementCanBeForwarded();\n-    getTargetTable()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings);\n+    getTargetTable()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings, local_context);\n }\n \n void StorageMaterializedView::mutate(const MutationCommands & commands, ContextPtr local_context)\ndiff --git a/src/Storages/StorageMaterializedView.h b/src/Storages/StorageMaterializedView.h\nindex 3ec789aa7e36..95bedcd9ade9 100644\n--- a/src/Storages/StorageMaterializedView.h\n+++ b/src/Storages/StorageMaterializedView.h\n@@ -64,7 +64,7 @@ class StorageMaterializedView final : public IStorage, WithMutableContext\n \n     Pipe alterPartition(const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, ContextPtr context) override;\n \n-    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override;\n+    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings, ContextPtr local_context) const override;\n \n     void mutate(const MutationCommands & commands, ContextPtr context) override;\n \ndiff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h\nindex a4304faeaecf..d4357ffd3ac5 100644\n--- a/src/Storages/StorageProxy.h\n+++ b/src/Storages/StorageProxy.h\n@@ -115,9 +115,9 @@ class StorageProxy : public IStorage\n         return getNested()->alterPartition(metadata_snapshot, commands, context);\n     }\n \n-    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override\n+    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings, ContextPtr context) const override\n     {\n-        getNested()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings);\n+        getNested()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings, context);\n     }\n \n     bool optimize(\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02897_alter_partition_parameters.reference b/tests/queries/0_stateless/02897_alter_partition_parameters.reference\nnew file mode 100644\nindex 000000000000..bc6ff2b709c4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02897_alter_partition_parameters.reference\n@@ -0,0 +1,9 @@\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02897_alter_partition_parameters.sql b/tests/queries/0_stateless/02897_alter_partition_parameters.sql\nnew file mode 100644\nindex 000000000000..62ceb9d9768c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02897_alter_partition_parameters.sql\n@@ -0,0 +1,141 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test\n+(\n+  EventDate Date\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+PARTITION BY toMonday(EventDate);\n+\n+INSERT INTO test VALUES(toDate('2023-10-09'));\n+\n+SET param_partition='2023-10-09';\n+\n+ALTER TABLE test DROP PARTITION {partition:String};\n+\n+SELECT count() FROM test;\n+\n+INSERT INTO test VALUES(toDate('2023-10-09'));\n+\n+ALTER TABLE test DROP PARTITION tuple(toMonday({partition:Date}));\n+\n+SELECT count() FROM test;\n+\n+INSERT INTO test VALUES(toDate('2023-10-09'));\n+\n+-- for some reason only tuples are allowed as non-string arguments\n+ALTER TABLE test DROP PARTITION toMonday({partition:String}); --{clientError 62}\n+\n+set param_partition_id = '20231009';\n+\n+ALTER TABLE test DROP PARTITION ID {partition_id:String};\n+\n+SELECT count() FROM test;\n+\n+INSERT INTO test VALUES(toDate('2023-10-09'));\n+\n+ALTER TABLE test DROP PARTITION {partition:Date};\n+SELECT count() FROM test;\n+\n+DROP TABLE IF EXISTS test;\n+\n+DROP TABLE IF EXISTS test2;\n+\n+CREATE TABLE test2\n+(\n+  a UInt32,\n+  b Int64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+PARTITION BY (a * b, b * b);\n+\n+\n+INSERT INTO test2 VALUES(1, 2);\n+\n+SET param_first='2';\n+SET param_second='4';\n+\n+ALTER TABLE test2 DROP PARTITION tuple({first:UInt32},{second:Int64});\n+\n+SELECT count() FROM test2;\n+\n+DROP TABLE IF EXISTS test2;\n+DROP TABLE IF EXISTS test3;\n+\n+CREATE TABLE test3\n+(\n+  a UInt32,\n+  b Int64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+PARTITION BY a;\n+\n+INSERT INTO test3 VALUES(1, 2);\n+\n+SET param_simple='1';\n+\n+ALTER TABLE test3 DROP PARTITION {simple:String};\n+\n+SELECT count() FROM test3;\n+\n+DROP TABLE IF EXISTS test3;\n+\n+DROP TABLE IF EXISTS test4;\n+\n+CREATE TABLE test4 (EventDate Date) ENGINE = MergeTree() ORDER BY tuple() PARTITION BY EventDate;\n+\n+INSERT INTO test4 VALUES(toDate('2023-10-09'));\n+\n+SET param_partition='2023-10-09';\n+\n+ALTER TABLE test4 ON CLUSTER 'test_shard_localhost' DROP PARTITION {partition:String} FORMAT Null;\n+\n+SELECT count() FROM test4;\n+\n+DROP TABLE IF EXISTS test4;\n+\n+DROP TABLE IF EXISTS test5;\n+\n+CREATE TABLE test5\n+(\n+  a UInt32,\n+  b Int64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+PARTITION BY (a, b);\n+\n+INSERT INTO test5 VALUES(1, 2);\n+\n+SET param_f='1';\n+SET param_s='2';\n+\n+ALTER TABLE test5 DROP PARTITION ({f:UInt32}, 2);\n+\n+SELECT count() FROM test5;\n+\n+DROP TABLE IF EXISTS test5;\n+\n+DROP TABLE IF EXISTS test6;\n+\n+CREATE TABLE test6\n+(\n+  a UInt32,\n+  b Int64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+PARTITION BY (a, b);\n+\n+INSERT INTO test6 VALUES(1, 2);\n+\n+SET param_tuple=(1, 2);\n+\n+ALTER TABLE test6 DROP PARTITION {tuple:Tuple(UInt32, Int64)};\n+\n+SELECT count() FROM test6;\n+\n+DROP TABLE IF EXISTS test6;\n",
  "problem_statement": "Support passing partition value as a parameter to ALTER TABLE t DROP PARTITION \nCurrently partition can be passed as a parameter only inside tuple() function\r\n\r\n```\r\nALTER TABLE test DROP PARTITION tuple(toMonday({partition:Date}));\r\n```\r\nBut users would prefer to be able to pass it directly:\r\n```\r\nALTER TABLE test DROP PARTITION {partition:String};\r\nALTER TABLE test DROP PARTITION {partition:Date};\r\n```\r\n\r\nHere are the steps\r\n```\r\nCREATE OR REPLACE TABLE default.test\r\n(\r\n\r\n   EventDate Date\r\n)\r\nENGINE = MergeTree\r\nORDER BY tuple()\r\nPARTITION BY toMonday(EventDate);\r\n\r\n\r\nALTER TABLE test DROP PARTITION '2023-04-10'; -- works\r\n\r\n\r\nSET param_table=test;\r\nALTER TABLE {table:Identifier} DROP PARTITION '2023-04-10' -- works;\r\n\r\n\r\nSET param_partition='2023-04-10';\r\n\r\nALTER TABLE test DROP PARTITION tuple(toMonday({partition:Date})); -- works\r\n\r\nALTER TABLE test DROP PARTITION {partition:Identifier}; -- doesn't work\r\nALTER TABLE test DROP PARTITION '{partition:Identifier}'; -- doesn't work\r\nALTER TABLE test DROP PARTITION {partition:String}; -- doesn't work\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2023-10-13T14:24:33Z",
  "modified_files": [
    "src/Interpreters/InterpreterAlterQuery.cpp",
    "src/Parsers/ASTPartition.cpp",
    "src/Parsers/ASTPartition.h",
    "src/Parsers/ExpressionListParsers.h",
    "src/Parsers/ParserPartition.cpp",
    "src/Storages/IStorage.cpp",
    "src/Storages/IStorage.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreePartInfo.cpp",
    "src/Storages/MergeTree/MergeTreePartInfo.h",
    "src/Storages/StorageMaterializedView.cpp",
    "src/Storages/StorageMaterializedView.h",
    "src/Storages/StorageProxy.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02897_alter_partition_parameters.reference",
    "b/tests/queries/0_stateless/02897_alter_partition_parameters.sql"
  ]
}