{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58705,
  "instance_id": "ClickHouse__ClickHouse-58705",
  "issue_numbers": [
    "50572"
  ],
  "base_commit": "f313eb97371512b9a8fb28ddea0706237c0b7c5e",
  "patch": "diff --git a/docs/en/sql-reference/statements/drop.md b/docs/en/sql-reference/statements/drop.md\nindex 8ed00f625d61..159ab09ab946 100644\n--- a/docs/en/sql-reference/statements/drop.md\n+++ b/docs/en/sql-reference/statements/drop.md\n@@ -30,9 +30,11 @@ Also see [UNDROP TABLE](/docs/en/sql-reference/statements/undrop.md)\n Syntax:\n \n ``` sql\n-DROP [TEMPORARY] TABLE [IF EXISTS] [IF EMPTY] [db.]name [ON CLUSTER cluster] [SYNC]\n+DROP [TEMPORARY] TABLE [IF EXISTS] [IF EMPTY]  [db1.]name_1[, [db2.]name_2, ...] [ON CLUSTER cluster] [SYNC]\n ```\n \n+Note that deleting multiple tables at the same time is a non-atomic deletion. If a table fails to be deleted, subsequent tables will not be deleted.\n+\n ## DROP DICTIONARY\n \n Deletes the dictionary.\ndiff --git a/src/Interpreters/DDLTask.cpp b/src/Interpreters/DDLTask.cpp\nindex a37b4db029ae..37954850851d 100644\n--- a/src/Interpreters/DDLTask.cpp\n+++ b/src/Interpreters/DDLTask.cpp\n@@ -16,6 +16,7 @@\n #include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n #include <Parsers/ASTQueryWithTableAndOutput.h>\n+#include <Parsers/ASTDropQuery.h>\n \n \n namespace DB\n@@ -200,6 +201,14 @@ void DDLTaskBase::parseQueryFromEntry(ContextPtr context)\n     ParserQuery parser_query(end, settings.allow_settings_after_format_in_insert);\n     String description;\n     query = parseQuery(parser_query, begin, end, description, 0, settings.max_parser_depth, settings.max_parser_backtracks);\n+    if (auto * query_drop = query->as<ASTDropQuery>())\n+    {\n+        ASTs drops = query_drop->getRewrittenASTsOfSingleTable();\n+        if (drops.size() > 1)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not supports drop multiple tables for ddl task.\");\n+\n+        query = drops[0];\n+    }\n }\n \n void DDLTaskBase::formatRewrittenQuery(ContextPtr context)\ndiff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp\nindex c6df401c5550..e29e59ee4c34 100644\n--- a/src/Interpreters/InterpreterDropQuery.cpp\n+++ b/src/Interpreters/InterpreterDropQuery.cpp\n@@ -8,6 +8,7 @@\n #include <Interpreters/QueryLog.h>\n #include <Access/Common/AccessRightsElement.h>\n #include <Parsers/ASTDropQuery.h>\n+#include <Parsers/ASTIdentifier.h>\n #include <Storages/IStorage.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Common/escapeForFileName.h>\n@@ -54,16 +55,27 @@ InterpreterDropQuery::InterpreterDropQuery(const ASTPtr & query_ptr_, ContextMut\n {\n }\n \n-\n BlockIO InterpreterDropQuery::execute()\n {\n+    BlockIO res;\n     auto & drop = query_ptr->as<ASTDropQuery &>();\n+    ASTs drops = drop.getRewrittenASTsOfSingleTable();\n+    for (const auto & drop_query_ptr : drops)\n+    {\n+        current_query_ptr = drop_query_ptr;\n+        res = executeSingleDropQuery(drop_query_ptr);\n+    }\n+    return res;\n+}\n \n-    if (!drop.cluster.empty() && drop.table && !drop.if_empty && !maybeRemoveOnCluster(query_ptr, getContext()))\n+BlockIO InterpreterDropQuery::executeSingleDropQuery(const ASTPtr & drop_query_ptr)\n+{\n+    auto & drop = drop_query_ptr->as<ASTDropQuery &>();\n+    if (!drop.cluster.empty() && drop.table && !drop.if_empty && !maybeRemoveOnCluster(current_query_ptr, getContext()))\n     {\n         DDLQueryOnClusterParams params;\n         params.access_to_check = getRequiredAccessForDDLOnCluster();\n-        return executeDDLQueryOnCluster(query_ptr, getContext(), params);\n+        return executeDDLQueryOnCluster(current_query_ptr, getContext(), params);\n     }\n \n     if (getContext()->getSettingsRef().database_atomic_wait_for_drop_and_detach_synchronously)\n@@ -71,11 +83,11 @@ BlockIO InterpreterDropQuery::execute()\n \n     if (drop.table)\n         return executeToTable(drop);\n-    else if (drop.database && !drop.cluster.empty() && !maybeRemoveOnCluster(query_ptr, getContext()))\n+    else if (drop.database && !drop.cluster.empty() && !maybeRemoveOnCluster(current_query_ptr, getContext()))\n     {\n-            DDLQueryOnClusterParams params;\n-            params.access_to_check = getRequiredAccessForDDLOnCluster();\n-            return executeDDLQueryOnCluster(query_ptr, getContext(), params);\n+        DDLQueryOnClusterParams params;\n+        params.access_to_check = getRequiredAccessForDDLOnCluster();\n+        return executeDDLQueryOnCluster(current_query_ptr, getContext(), params);\n     }\n     else if (drop.database)\n         return executeToDatabase(drop);\n@@ -83,7 +95,6 @@ BlockIO InterpreterDropQuery::execute()\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Nothing to drop, both names are empty\");\n }\n \n-\n void InterpreterDropQuery::waitForTableToBeActuallyDroppedOrDetached(const ASTDropQuery & query, const DatabasePtr & db, const UUID & uuid_to_wait)\n {\n     if (uuid_to_wait == UUIDHelpers::Nil)\n@@ -156,7 +167,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue\n         table_id.uuid = database->tryGetTableUUID(table_id.table_name);\n \n         /// Prevents recursive drop from drop database query. The original query must specify a table.\n-        bool is_drop_or_detach_database = !query_ptr->as<ASTDropQuery>()->table;\n+        bool is_drop_or_detach_database = !current_query_ptr->as<ASTDropQuery>()->table;\n \n         AccessFlags drop_storage;\n \n@@ -179,7 +190,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue\n             return executeDDLQueryOnCluster(new_query_ptr, getContext(), params);\n         }\n \n-        if (database->shouldReplicateQuery(getContext(), query_ptr))\n+        if (database->shouldReplicateQuery(getContext(), current_query_ptr))\n         {\n             if (query.kind == ASTDropQuery::Kind::Detach)\n                 context_->checkAccess(drop_storage, table_id);\n@@ -249,7 +260,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue\n \n             auto metadata_snapshot = table->getInMemoryMetadataPtr();\n             /// Drop table data, don't touch metadata\n-            table->truncate(query_ptr, metadata_snapshot, context_, table_excl_lock);\n+            table->truncate(current_query_ptr, metadata_snapshot, context_, table_excl_lock);\n         }\n         else if (query.kind == ASTDropQuery::Kind::Drop)\n         {\n@@ -308,7 +319,7 @@ BlockIO InterpreterDropQuery::executeToTemporaryTable(const String & table_name,\n                     = table->lockExclusively(getContext()->getCurrentQueryId(), getContext()->getSettingsRef().lock_acquire_timeout);\n                 /// Drop table data, don't touch metadata\n                 auto metadata_snapshot = table->getInMemoryMetadataPtr();\n-                table->truncate(query_ptr, metadata_snapshot, getContext(), table_lock);\n+                table->truncate(current_query_ptr, metadata_snapshot, getContext(), table_lock);\n             }\n             else if (kind == ASTDropQuery::Kind::Drop)\n             {\n@@ -441,11 +452,39 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,\n     return {};\n }\n \n+void InterpreterDropQuery::extendQueryLogElemImpl(DB::QueryLogElement & elem, const DB::ASTPtr & ast, DB::ContextPtr context_) const\n+{\n+    auto & drop = ast->as<ASTDropQuery &>();\n+    if (drop.database_and_tables)\n+    {\n+        auto & list = drop.database_and_tables->as<ASTExpressionList &>();\n+        for (auto & child : list.children)\n+        {\n+            auto identifier = dynamic_pointer_cast<ASTTableIdentifier>(child);\n+            if (!identifier)\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Unexpected type for list of table names.\");\n+\n+            String query_database = identifier->getDatabaseName();\n+            String query_table = identifier->shortName();\n+            if (!query_database.empty() && query_table.empty())\n+            {\n+                elem.query_databases.insert(backQuoteIfNeed(query_database));\n+            }\n+            else if (!query_table.empty())\n+            {\n+                auto quoted_database = query_database.empty() ? backQuoteIfNeed(context_->getCurrentDatabase())\n+                                                              : backQuoteIfNeed(query_database);\n+                elem.query_databases.insert(quoted_database);\n+                elem.query_tables.insert(quoted_database + \".\" + backQuoteIfNeed(query_table));\n+            }\n+        }\n+    }\n+}\n \n AccessRightsElements InterpreterDropQuery::getRequiredAccessForDDLOnCluster() const\n {\n     AccessRightsElements required_access;\n-    const auto & drop = query_ptr->as<const ASTDropQuery &>();\n+    const auto & drop = current_query_ptr->as<const ASTDropQuery &>();\n \n     if (!drop.table)\n     {\n@@ -518,7 +557,7 @@ bool InterpreterDropQuery::supportsTransactions() const\n     return drop.cluster.empty()\n             && !drop.temporary\n             && drop.kind == ASTDropQuery::Kind::Truncate\n-            && drop.table;\n+            && drop.database_and_tables;\n }\n \n void registerInterpreterDropQuery(InterpreterFactory & factory)\ndiff --git a/src/Interpreters/InterpreterDropQuery.h b/src/Interpreters/InterpreterDropQuery.h\nindex 7ae544a7356a..08668f47225a 100644\n--- a/src/Interpreters/InterpreterDropQuery.h\n+++ b/src/Interpreters/InterpreterDropQuery.h\n@@ -29,10 +29,14 @@ class InterpreterDropQuery : public IInterpreter, WithMutableContext\n \n     bool supportsTransactions() const override;\n \n+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context_) const override;\n+\n private:\n     AccessRightsElements getRequiredAccessForDDLOnCluster() const;\n     ASTPtr query_ptr;\n+    ASTPtr current_query_ptr;\n \n+    BlockIO executeSingleDropQuery(const ASTPtr & drop_query_ptr);\n     BlockIO executeToDatabase(const ASTDropQuery & query);\n     BlockIO executeToDatabaseImpl(const ASTDropQuery & query, DatabasePtr & database, std::vector<UUID> & uuids_to_wait);\n \ndiff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp\nindex b491be1ea2c0..ecb9ad8169b4 100644\n--- a/src/Parsers/ASTDropQuery.cpp\n+++ b/src/Parsers/ASTDropQuery.cpp\n@@ -1,4 +1,6 @@\n #include <Parsers/ASTDropQuery.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTExpressionList.h>\n #include <Common/quoteString.h>\n #include <IO/Operators.h>\n \n@@ -49,7 +51,7 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n \n     if (has_all_tables)\n         settings.ostr << \"ALL TABLES \";\n-    else if (!table && database)\n+    else if (!table && !database_and_tables && database)\n         settings.ostr << \"DATABASE \";\n     else if (is_dictionary)\n         settings.ostr << \"DICTIONARY \";\n@@ -66,10 +68,33 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n-    if (!table && database)\n+    if (!table && !database_and_tables && database)\n     {\n         database->formatImpl(settings, state, frame);\n     }\n+    else if (database_and_tables)\n+    {\n+        auto & list = database_and_tables->as<ASTExpressionList &>();\n+        for (auto * it = list.children.begin(); it != list.children.end(); ++it)\n+        {\n+            if (it != list.children.begin())\n+                settings.ostr << \", \";\n+\n+            auto identifier = dynamic_pointer_cast<ASTTableIdentifier>(*it);\n+            if (!identifier)\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Unexpected type for list of table names.\");\n+\n+            if (auto db = identifier->getDatabase())\n+            {\n+                db->formatImpl(settings, state, frame);\n+                settings.ostr << '.';\n+            }\n+\n+            auto tb = identifier->getTable();\n+            chassert(tb);\n+            tb->formatImpl(settings, state, frame);\n+        }\n+    }\n     else\n     {\n         if (database)\n@@ -91,4 +116,39 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" SYNC\" << (settings.hilite ? hilite_none : \"\");\n }\n \n+ASTs ASTDropQuery::getRewrittenASTsOfSingleTable()\n+{\n+    ASTs res;\n+    if (database_and_tables == nullptr)\n+    {\n+        res.push_back(shared_from_this());\n+        return res;\n+    }\n+\n+    auto & list = database_and_tables->as<ASTExpressionList &>();\n+    for (const auto & child : list.children)\n+    {\n+        auto cloned = clone();\n+        auto & query = cloned->as<ASTDropQuery &>();\n+        query.database_and_tables = nullptr;\n+        query.children.clear();\n+\n+        auto database_and_table = dynamic_pointer_cast<ASTTableIdentifier>(child);\n+        if (!database_and_table)\n+            throw Exception(ErrorCodes::SYNTAX_ERROR, \"Unexpected type for list of table names.\");\n+\n+        query.database = database_and_table->getDatabase();\n+        query.table = database_and_table->getTable();\n+\n+        if (query.database)\n+            query.children.push_back(query.database);\n+\n+        if (query.table)\n+            query.children.push_back(query.table);\n+\n+        res.push_back(cloned);\n+    }\n+    return res;\n+}\n+\n }\ndiff --git a/src/Parsers/ASTDropQuery.h b/src/Parsers/ASTDropQuery.h\nindex fe79bdf8bf12..e0e908733e5c 100644\n--- a/src/Parsers/ASTDropQuery.h\n+++ b/src/Parsers/ASTDropQuery.h\n@@ -40,6 +40,9 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu\n     // We detach the object permanently, so it will not be reattached back during server restart.\n     bool permanently{false};\n \n+    /// Example: Drop TABLE t1, t2, t3...\n+    ASTPtr database_and_tables;\n+\n     /** Get the text that identifies this element. */\n     String getID(char) const override;\n     ASTPtr clone() const override;\n@@ -49,6 +52,8 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu\n         return removeOnCluster<ASTDropQuery>(clone(), params.default_database);\n     }\n \n+    ASTs getRewrittenASTsOfSingleTable();\n+\n     QueryKind getQueryKind() const override { return QueryKind::Drop; }\n \n protected:\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex f2c09e9b0501..1510cc8e1954 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -168,7 +168,7 @@ bool ParserColumnDeclarationList::parseImpl(Pos & pos, ASTPtr & node, Expected &\n \n bool ParserNameList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    return ParserList(std::make_unique<ParserCompoundIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma), false)\n+    return ParserList(std::make_unique<ParserCompoundIdentifier>(true, true), std::make_unique<ParserToken>(TokenType::Comma), false)\n         .parse(pos, node, expected);\n }\n \ndiff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp\nindex 75ea5fc89e1c..09f15e9649fd 100644\n--- a/src/Parsers/ParserDropQuery.cpp\n+++ b/src/Parsers/ParserDropQuery.cpp\n@@ -2,7 +2,7 @@\n \n #include <Parsers/CommonParsers.h>\n #include <Parsers/ParserDropQuery.h>\n-\n+#include <Parsers/ParserCreateQuery.h>\n \n namespace DB\n {\n@@ -26,9 +26,10 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     ParserKeyword s_permanently(Keyword::PERMANENTLY);\n     ParserKeyword s_no_delay(Keyword::NO_DELAY);\n     ParserKeyword s_sync(Keyword::SYNC);\n+    ParserNameList tables_p;\n \n     ASTPtr database;\n-    ASTPtr table;\n+    ASTPtr database_and_tables;\n     String cluster_str;\n     bool if_exists = false;\n     bool if_empty = false;\n@@ -81,15 +82,8 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n         if (s_if_empty.ignore(pos, expected))\n             if_empty = true;\n \n-        if (!name_p.parse(pos, table, expected))\n+        if (!tables_p.parse(pos, database_and_tables, expected))\n             return false;\n-\n-        if (s_dot.ignore(pos, expected))\n-        {\n-            database = table;\n-            if (!name_p.parse(pos, table, expected))\n-                return false;\n-        }\n     }\n \n     /// common for tables / dictionaries / databases\n@@ -119,13 +113,13 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     query->sync = sync;\n     query->permanently = permanently;\n     query->database = database;\n-    query->table = table;\n+    query->database_and_tables = database_and_tables;\n \n     if (database)\n         query->children.push_back(database);\n \n-    if (table)\n-        query->children.push_back(table);\n+    if (database_and_tables)\n+        query->children.push_back(database_and_tables);\n \n     query->cluster = cluster_str;\n \n",
  "test_patch": "diff --git a/src/Parsers/tests/gtest_dictionary_parser.cpp b/src/Parsers/tests/gtest_dictionary_parser.cpp\nindex a1ba46125a72..44205975cdc0 100644\n--- a/src/Parsers/tests/gtest_dictionary_parser.cpp\n+++ b/src/Parsers/tests/gtest_dictionary_parser.cpp\n@@ -301,8 +301,10 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n     ASTDropQuery * drop1 = ast1->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop1->is_dictionary);\n-    EXPECT_EQ(drop1->getDatabase(), \"test\");\n-    EXPECT_EQ(drop1->getTable(), \"dict1\");\n+    auto & database_and_tables1 = drop1->database_and_tables->as<ASTExpressionList &>();\n+    auto identifier1 = dynamic_pointer_cast<ASTTableIdentifier>(database_and_tables1.children[0]);\n+    EXPECT_EQ(identifier1->getDatabaseName(), \"test\");\n+    EXPECT_EQ(identifier1->shortName(), \"dict1\");\n     auto str1 = serializeAST(*drop1);\n     EXPECT_EQ(input1, str1);\n \n@@ -312,8 +314,10 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n     ASTDropQuery * drop2 = ast2->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop2->is_dictionary);\n-    EXPECT_EQ(drop2->getDatabase(), \"\");\n-    EXPECT_EQ(drop2->getTable(), \"dict2\");\n+    auto & database_and_tables2 = drop2->database_and_tables->as<ASTExpressionList &>();\n+    auto identifier2 = dynamic_pointer_cast<ASTTableIdentifier>(database_and_tables2.children[0]);\n+    EXPECT_EQ(identifier2->getDatabaseName(), \"\");\n+    EXPECT_EQ(identifier2->shortName(), \"dict2\");\n     auto str2 = serializeAST(*drop2);\n     EXPECT_EQ(input2, str2);\n }\ndiff --git a/tests/queries/0_stateless/02961_drop_tables.reference b/tests/queries/0_stateless/02961_drop_tables.reference\nnew file mode 100644\nindex 000000000000..c0465dc592a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02961_drop_tables.reference\n@@ -0,0 +1,8 @@\n+-- check which tables exist in 02961_db1\n+-- check which tables exist in 02961_db2\n+02961_tb4\n+02961_tb5\n+Test when deletion of existing table fails\n+-- check which tables exist in 02961_db1\n+-- check which tables exist in 02961_db2\n+02961_tb5\ndiff --git a/tests/queries/0_stateless/02961_drop_tables.sql b/tests/queries/0_stateless/02961_drop_tables.sql\nnew file mode 100644\nindex 000000000000..e91ac4bfe19b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02961_drop_tables.sql\n@@ -0,0 +1,32 @@\n+-- Tags: no-parallel\n+DROP DATABASE IF EXISTS 02961_db1;\n+CREATE DATABASE IF NOT EXISTS 02961_db1;\n+DROP DATABASE IF EXISTS 02961_db2;\n+CREATE DATABASE IF NOT EXISTS 02961_db2;\n+\n+\n+CREATE TABLE IF NOT EXISTS 02961_db1.02961_tb1 (id UInt32) Engine=Memory();\n+CREATE TABLE IF NOT EXISTS 02961_db1.02961_tb2 (id UInt32) Engine=Memory();\n+\n+CREATE TABLE IF NOT EXISTS 02961_db2.02961_tb3 (id UInt32) Engine=Memory();\n+CREATE TABLE IF NOT EXISTS 02961_db2.02961_tb4 (id UInt32) Engine=Memory();\n+CREATE TABLE IF NOT EXISTS 02961_db2.02961_tb5 (id UInt32) Engine=Memory();\n+\n+DROP TABLE 02961_db1.02961_tb1, 02961_db1.02961_tb2, 02961_db2.02961_tb3;\n+\n+SELECT '-- check which tables exist in 02961_db1';\n+SHOW TABLES FROM 02961_db1;\n+SELECT '-- check which tables exist in 02961_db2';\n+SHOW TABLES FROM 02961_db2;\n+\n+SELECT 'Test when deletion of existing table fails';\n+DROP TABLE 02961_db2.02961_tb4, 02961_db1.02961_tb1, 02961_db2.02961_tb5; -- { serverError UNKNOWN_TABLE }\n+\n+SELECT '-- check which tables exist in 02961_db1';\n+SHOW TABLES FROM 02961_db1;\n+SELECT '-- check which tables exist in 02961_db2';\n+SHOW TABLES FROM 02961_db2;\n+\n+\n+DROP DATABASE IF EXISTS 02961_db1;\n+DROP DATABASE IF EXISTS 02961_db2;\n",
  "problem_statement": "Allow DROP multiple tables\n**Use case**\r\n\r\n```\r\nDROP TABLE t1, t2, ...\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nIt works. It's ok to have a non-atomic implementation that can drop one table and throw an exception on another.\n",
  "hints_text": "Hi. I want to try if I can solve this, can I be assigned?\n@alexey-milovidov  @Qiaolin-Yu Hi i am new to open source and would like to work on this issue if no one is working.\r\nCould you refer where I could begin with.\nThis task is open.",
  "created_at": "2024-01-11T07:50:30Z"
}