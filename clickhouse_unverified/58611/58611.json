{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58611,
  "instance_id": "ClickHouse__ClickHouse-58611",
  "issue_numbers": [
    "58054"
  ],
  "base_commit": "4cacfa6b43da5982d1a7ef90e930f9bd6b816de3",
  "patch": "diff --git a/docs/en/operations/query-cache.md b/docs/en/operations/query-cache.md\nindex 50c5ff4457fc..fbff622ae384 100644\n--- a/docs/en/operations/query-cache.md\n+++ b/docs/en/operations/query-cache.md\n@@ -29,10 +29,6 @@ Transactionally inconsistent caching is traditionally provided by client tools o\n the same caching logic and configuration is often duplicated. With ClickHouse's query cache, the caching logic moves to the server side.\n This reduces maintenance effort and avoids redundancy.\n \n-:::note\n-Security consideration: The cached query result is tied to the user executing it. Authorization checks are performed when the query is executed. This means that if there are any alterations to the user's role or permissions between the time the query is cached and when the cache is accessed, the result will not reflect these changes. We recommend using different users to distinguish between different levels of access, instead of actively toggling roles for a single user between queries, as this practice may lead to unexpected query results.\n-:::\n-\n ## Configuration Settings and Usage\n \n Setting [use_query_cache](settings/settings.md#use-query-cache) can be used to control whether a specific query or all queries of the\ndiff --git a/src/Common/CacheBase.h b/src/Common/CacheBase.h\nindex 1cbfcc2165a5..a809136f4511 100644\n--- a/src/Common/CacheBase.h\n+++ b/src/Common/CacheBase.h\n@@ -5,15 +5,15 @@\n #include <Common/LRUCachePolicy.h>\n #include <Common/SLRUCachePolicy.h>\n \n+#include <base/UUID.h>\n+#include <base/defines.h>\n+\n #include <atomic>\n-#include <cassert>\n-#include <chrono>\n #include <memory>\n #include <mutex>\n+#include <optional>\n #include <unordered_map>\n \n-#include <base/defines.h>\n-\n \n namespace DB\n {\n@@ -227,10 +227,10 @@ class CacheBase\n         cache_policy->setMaxSizeInBytes(max_size_in_bytes);\n     }\n \n-    void setQuotaForUser(const String & user_name, size_t max_size_in_bytes, size_t max_entries)\n+    void setQuotaForUser(const UUID & user_id, size_t max_size_in_bytes, size_t max_entries)\n     {\n         std::lock_guard lock(mutex);\n-        cache_policy->setQuotaForUser(user_name, max_size_in_bytes, max_entries);\n+        cache_policy->setQuotaForUser(user_id, max_size_in_bytes, max_entries);\n     }\n \n     virtual ~CacheBase() = default;\ndiff --git a/src/Common/ICachePolicy.h b/src/Common/ICachePolicy.h\nindex 189af4db19be..8aa75d1d81fa 100644\n--- a/src/Common/ICachePolicy.h\n+++ b/src/Common/ICachePolicy.h\n@@ -2,10 +2,11 @@\n \n #include <Common/Exception.h>\n #include <Common/ICachePolicyUserQuota.h>\n+#include <base/UUID.h>\n \n #include <functional>\n #include <memory>\n-#include <mutex>\n+#include <optional>\n \n namespace DB\n {\n@@ -43,7 +44,7 @@ class ICachePolicy\n \n     virtual void setMaxCount(size_t /*max_count*/) = 0;\n     virtual void setMaxSizeInBytes(size_t /*max_size_in_bytes*/) = 0;\n-    virtual void setQuotaForUser(const String & user_name, size_t max_size_in_bytes, size_t max_entries) { user_quotas->setQuotaForUser(user_name, max_size_in_bytes, max_entries); }\n+    virtual void setQuotaForUser(const UUID & user_id, size_t max_size_in_bytes, size_t max_entries) { user_quotas->setQuotaForUser(user_id, max_size_in_bytes, max_entries); }\n \n     /// HashFunction usually hashes the entire key and the found key will be equal the provided key. In such cases, use get(). It is also\n     /// possible to store other, non-hashed data in the key. In that case, the found key is potentially different from the provided key.\ndiff --git a/src/Common/ICachePolicyUserQuota.h b/src/Common/ICachePolicyUserQuota.h\nindex 717cb916f856..6fa4f7947cb1 100644\n--- a/src/Common/ICachePolicyUserQuota.h\n+++ b/src/Common/ICachePolicyUserQuota.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <base/UUID.h>\n #include <base/types.h>\n \n namespace DB\n@@ -15,14 +16,14 @@ class ICachePolicyUserQuota\n {\n public:\n     /// Register or update the user's quota for the given resource.\n-    virtual void setQuotaForUser(const String & user_name, size_t max_size_in_bytes, size_t max_entries) = 0;\n+    virtual void setQuotaForUser(const UUID & user_id, size_t max_size_in_bytes, size_t max_entries) = 0;\n \n     /// Update the actual resource usage for the given user.\n-    virtual void increaseActual(const String & user_name, size_t entry_size_in_bytes) = 0;\n-    virtual void decreaseActual(const String & user_name, size_t entry_size_in_bytes) = 0;\n+    virtual void increaseActual(const UUID & user_id, size_t entry_size_in_bytes) = 0;\n+    virtual void decreaseActual(const UUID & user_id, size_t entry_size_in_bytes) = 0;\n \n     /// Is the user allowed to write a new entry into the cache?\n-    virtual bool approveWrite(const String & user_name, size_t entry_size_in_bytes) const = 0;\n+    virtual bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const = 0;\n \n     virtual ~ICachePolicyUserQuota() = default;\n };\n@@ -33,10 +34,10 @@ using CachePolicyUserQuotaPtr = std::unique_ptr<ICachePolicyUserQuota>;\n class NoCachePolicyUserQuota : public ICachePolicyUserQuota\n {\n public:\n-    void setQuotaForUser(const String & /*user_name*/, size_t /*max_size_in_bytes*/, size_t /*max_entries*/) override {}\n-    void increaseActual(const String & /*user_name*/, size_t /*entry_size_in_bytes*/) override {}\n-    void decreaseActual(const String & /*user_name*/, size_t /*entry_size_in_bytes*/) override {}\n-    bool approveWrite(const String & /*user_name*/, size_t /*entry_size_in_bytes*/) const override { return true; }\n+    void setQuotaForUser(const UUID & /*user_id*/, size_t /*max_size_in_bytes*/, size_t /*max_entries*/) override {}\n+    void increaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}\n+    void decreaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}\n+    bool approveWrite(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) const override { return true; }\n };\n \n \ndiff --git a/src/Common/TTLCachePolicy.h b/src/Common/TTLCachePolicy.h\nindex 98708c653c3d..338cc543385a 100644\n--- a/src/Common/TTLCachePolicy.h\n+++ b/src/Common/TTLCachePolicy.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Common/ICachePolicy.h>\n+#include <base/UUID.h>\n \n #include <limits>\n #include <unordered_map>\n@@ -11,37 +12,37 @@ namespace DB\n class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota\n {\n public:\n-    void setQuotaForUser(const String & user_name, size_t max_size_in_bytes, size_t max_entries) override\n+    void setQuotaForUser(const UUID & user_id, size_t max_size_in_bytes, size_t max_entries) override\n     {\n-        quotas[user_name] = {max_size_in_bytes, max_entries};\n+        quotas[user_id] = {max_size_in_bytes, max_entries};\n     }\n \n-    void increaseActual(const String & user_name, size_t entry_size_in_bytes) override\n+    void increaseActual(const UUID & user_id, size_t entry_size_in_bytes) override\n     {\n-        auto & actual_for_user = actual[user_name];\n+        auto & actual_for_user = actual[user_id];\n         actual_for_user.size_in_bytes += entry_size_in_bytes;\n         actual_for_user.num_items += 1;\n     }\n \n-    void decreaseActual(const String & user_name, size_t entry_size_in_bytes) override\n+    void decreaseActual(const UUID & user_id, size_t entry_size_in_bytes) override\n     {\n-        chassert(actual.contains(user_name));\n+        chassert(actual.contains(user_id));\n \n-        chassert(actual[user_name].size_in_bytes >= entry_size_in_bytes);\n-        actual[user_name].size_in_bytes -= entry_size_in_bytes;\n+        chassert(actual[user_id].size_in_bytes >= entry_size_in_bytes);\n+        actual[user_id].size_in_bytes -= entry_size_in_bytes;\n \n-        chassert(actual[user_name].num_items >= 1);\n-        actual[user_name].num_items -= 1;\n+        chassert(actual[user_id].num_items >= 1);\n+        actual[user_id].num_items -= 1;\n     }\n \n-    bool approveWrite(const String & user_name, size_t entry_size_in_bytes) const override\n+    bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const override\n     {\n-        auto it_actual = actual.find(user_name);\n+        auto it_actual = actual.find(user_id);\n         Resources actual_for_user{.size_in_bytes = 0, .num_items = 0}; /// assume zero actual resource consumption is user isn't found\n         if (it_actual != actual.end())\n             actual_for_user = it_actual->second;\n \n-        auto it_quota = quotas.find(user_name);\n+        auto it_quota = quotas.find(user_id);\n         Resources quota_for_user{.size_in_bytes = std::numeric_limits<size_t>::max(), .num_items = std::numeric_limits<size_t>::max()}; /// assume no threshold if no quota is found\n         if (it_quota != quotas.end())\n             quota_for_user = it_quota->second;\n@@ -69,10 +70,10 @@ class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota\n         size_t num_items = 0;\n     };\n \n-    /// user name --> cache size quota (in bytes) / number of items quota\n-    std::map<String, Resources> quotas;\n-    /// user name --> actual cache usage (in bytes) / number of items\n-    std::map<String, Resources> actual;\n+    /// user id --> cache size quota (in bytes) / number of items quota\n+    std::map<UUID, Resources> quotas;\n+    /// user id --> actual cache usage (in bytes) / number of items\n+    std::map<UUID, Resources> actual;\n };\n \n \n@@ -132,7 +133,8 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n         if (it == cache.end())\n             return;\n         size_t sz = weight_function(*it->second);\n-        Base::user_quotas->decreaseActual(it->first.user_name, sz);\n+        if (it->first.user_id.has_value())\n+            Base::user_quotas->decreaseActual(*it->first.user_id, sz);\n         cache.erase(it);\n         size_in_bytes -= sz;\n     }\n@@ -169,7 +171,9 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n         /// Checks against per-user limits\n         auto sufficient_space_in_cache_for_user = [&]()\n         {\n-            return Base::user_quotas->approveWrite(key.user_name, entry_size_in_bytes);\n+            if (key.user_id.has_value())\n+                return Base::user_quotas->approveWrite(*key.user_id, entry_size_in_bytes);\n+            return true;\n         };\n \n         if (!sufficient_space_in_cache() || !sufficient_space_in_cache_for_user())\n@@ -179,7 +183,8 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n                 if (is_stale_function(it->first))\n                 {\n                     size_t sz = weight_function(*it->second);\n-                    Base::user_quotas->decreaseActual(it->first.user_name, sz);\n+                    if (it->first.user_id.has_value())\n+                        Base::user_quotas->decreaseActual(*it->first.user_id, sz);\n                     it = cache.erase(it);\n                     size_in_bytes -= sz;\n                 }\n@@ -193,14 +198,16 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n             if (auto it = cache.find(key); it != cache.end())\n             {\n                 size_t sz = weight_function(*it->second);\n-                Base::user_quotas->decreaseActual(it->first.user_name, sz);\n+                if (it->first.user_id.has_value())\n+                    Base::user_quotas->decreaseActual(*it->first.user_id, sz);\n                 cache.erase(it); // stupid bug: (*) doesn't replace existing entries (likely due to custom hash function), need to erase explicitly\n                 size_in_bytes -= sz;\n             }\n \n             cache[key] = std::move(mapped); // (*)\n             size_in_bytes += entry_size_in_bytes;\n-            Base::user_quotas->increaseActual(key.user_name, entry_size_in_bytes);\n+            if (key.user_id.has_value())\n+                Base::user_quotas->increaseActual(*key.user_id, entry_size_in_bytes);\n         }\n     }\n \ndiff --git a/src/Interpreters/Cache/QueryCache.cpp b/src/Interpreters/Cache/QueryCache.cpp\nindex 8347d32bd3c4..151f2ea06cc9 100644\n--- a/src/Interpreters/Cache/QueryCache.cpp\n+++ b/src/Interpreters/Cache/QueryCache.cpp\n@@ -129,12 +129,14 @@ String queryStringFromAST(ASTPtr ast)\n QueryCache::Key::Key(\n     ASTPtr ast_,\n     Block header_,\n-    const String & user_name_, bool is_shared_,\n+    std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_,\n+    bool is_shared_,\n     std::chrono::time_point<std::chrono::system_clock> expires_at_,\n     bool is_compressed_)\n     : ast(removeQueryCacheSettings(ast_))\n     , header(header_)\n-    , user_name(user_name_)\n+    , user_id(user_id_)\n+    , current_user_roles(current_user_roles_)\n     , is_shared(is_shared_)\n     , expires_at(expires_at_)\n     , is_compressed(is_compressed_)\n@@ -142,8 +144,8 @@ QueryCache::Key::Key(\n {\n }\n \n-QueryCache::Key::Key(ASTPtr ast_, const String & user_name_)\n-    : QueryCache::Key(ast_, {}, user_name_, false, std::chrono::system_clock::from_time_t(1), false) /// dummy values for everything != AST or user name\n+QueryCache::Key::Key(ASTPtr ast_, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_)\n+    : QueryCache::Key(ast_, {}, user_id_, current_user_roles_, false, std::chrono::system_clock::from_time_t(1), false) /// dummy values for everything != AST or user name\n {\n }\n \n@@ -401,7 +403,9 @@ QueryCache::Reader::Reader(Cache & cache_, const Key & key, const std::lock_guar\n     const auto & entry_key = entry->key;\n     const auto & entry_mapped = entry->mapped;\n \n-    if (!entry_key.is_shared && entry_key.user_name != key.user_name)\n+    const bool is_same_user_id = ((!entry_key.user_id.has_value() && !key.user_id.has_value()) || (entry_key.user_id.has_value() && key.user_id.has_value() && *entry_key.user_id == *key.user_id));\n+    const bool is_same_current_user_roles = (entry_key.current_user_roles == key.current_user_roles);\n+    if (!entry_key.is_shared && (!is_same_user_id || !is_same_current_user_roles))\n     {\n         LOG_TRACE(logger, \"Inaccessible query result found for query {}\", doubleQuoteString(key.query_string));\n         return;\n@@ -503,7 +507,9 @@ QueryCache::Writer QueryCache::createWriter(const Key & key, std::chrono::millis\n     /// Update the per-user cache quotas with the values stored in the query context. This happens per query which writes into the query\n     /// cache. Obviously, this is overkill but I could find the good place to hook into which is called when the settings profiles in\n     /// users.xml change.\n-    cache.setQuotaForUser(key.user_name, max_query_cache_size_in_bytes_quota, max_query_cache_entries_quota);\n+    /// user_id == std::nullopt is the internal user for which no quota can be configured\n+    if (key.user_id.has_value())\n+        cache.setQuotaForUser(*key.user_id, max_query_cache_size_in_bytes_quota, max_query_cache_entries_quota);\n \n     std::lock_guard lock(mutex);\n     return Writer(cache, key, max_entry_size_in_bytes, max_entry_size_in_rows, min_query_runtime, squash_partial_results, max_block_size);\ndiff --git a/src/Interpreters/Cache/QueryCache.h b/src/Interpreters/Cache/QueryCache.h\nindex d3c98dbd97a5..2dd4887dd20a 100644\n--- a/src/Interpreters/Cache/QueryCache.h\n+++ b/src/Interpreters/Cache/QueryCache.h\n@@ -4,9 +4,12 @@\n #include <Common/logger_useful.h>\n #include <Core/Block.h>\n #include <Parsers/IAST_fwd.h>\n-#include <Processors/Sources/SourceFromChunks.h>\n #include <Processors/Chunk.h>\n+#include <Processors/Sources/SourceFromChunks.h>\n #include <QueryPipeline/Pipe.h>\n+#include <base/UUID.h>\n+\n+#include <optional>\n \n namespace DB\n {\n@@ -51,8 +54,15 @@ class QueryCache\n         /// Result metadata for constructing the pipe.\n         const Block header;\n \n-        /// The user who executed the query.\n-        const String user_name;\n+        /// The id and current roles of the user who executed the query.\n+        /// These members are necessary to ensure that a (non-shared, see below) entry can only be written and read by the same user with\n+        /// the same roles. Example attack scenarios:\n+        /// - after DROP USER, it must not be possible to create a new user with with the dropped user name and access the dropped user's\n+        ///   query cache entries\n+        /// - different roles of the same user may be tied to different row-level policies. It must not be possible to switch role and\n+        ///   access another role's cache entries\n+        std::optional<UUID> user_id;\n+        std::vector<UUID> current_user_roles;\n \n         /// If the associated entry can be read by other users. In general, sharing is a bad idea: First, it is unlikely that different\n         /// users pose the same queries. Second, sharing potentially breaches security. E.g. User A should not be able to bypass row\n@@ -74,12 +84,13 @@ class QueryCache\n         /// Ctor to construct a Key for writing into query cache.\n         Key(ASTPtr ast_,\n             Block header_,\n-            const String & user_name_, bool is_shared_,\n+            std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_,\n+            bool is_shared_,\n             std::chrono::time_point<std::chrono::system_clock> expires_at_,\n             bool is_compressed);\n \n         /// Ctor to construct a Key for reading from query cache (this operation only needs the AST + user name).\n-        Key(ASTPtr ast_, const String & user_name_);\n+        Key(ASTPtr ast_, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_);\n \n         bool operator==(const Key & other) const;\n     };\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex ef115b389acf..4b5a6a84e17e 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -1010,7 +1010,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             {\n                 if (can_use_query_cache && settings.enable_reads_from_query_cache)\n                 {\n-                    QueryCache::Key key(ast, context->getUserName());\n+                    QueryCache::Key key(ast, context->getUserID(), context->getCurrentRoles());\n                     QueryCache::Reader reader = query_cache->createReader(key);\n                     if (reader.hasCacheEntryForKey())\n                     {\n@@ -1123,7 +1123,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                         {\n                             QueryCache::Key key(\n                                 ast, res.pipeline.getHeader(),\n-                                context->getUserName(), settings.query_cache_share_between_users,\n+                                context->getUserID(), context->getCurrentRoles(),\n+                                settings.query_cache_share_between_users,\n                                 std::chrono::system_clock::now() + std::chrono::seconds(settings.query_cache_ttl),\n                                 settings.query_cache_compress_entries);\n \ndiff --git a/src/Storages/System/StorageSystemQueryCache.cpp b/src/Storages/System/StorageSystemQueryCache.cpp\nindex 8538820cf411..ec4f4eeec23e 100644\n--- a/src/Storages/System/StorageSystemQueryCache.cpp\n+++ b/src/Storages/System/StorageSystemQueryCache.cpp\n@@ -37,11 +37,15 @@ void StorageSystemQueryCache::fillData(MutableColumns & res_columns, ContextPtr\n     std::vector<QueryCache::Cache::KeyMapped> content = query_cache->dump();\n \n     const String & user_name = context->getUserName();\n+    std::optional<UUID> user_id = context->getUserID();\n+    std::vector<UUID> current_user_roles = context->getCurrentRoles();\n \n     for (const auto & [key, query_result] : content)\n     {\n         /// Showing other user's queries is considered a security risk\n-        if (!key.is_shared && key.user_name != user_name)\n+        const bool is_same_user_id = ((!key.user_id.has_value() && !user_id.has_value()) || (key.user_id.has_value() && user_id.has_value() && *key.user_id == *user_id));\n+        const bool is_same_current_user_roles = (key.current_user_roles == current_user_roles);\n+        if (!key.is_shared && (!is_same_user_id || !is_same_current_user_roles))\n             continue;\n \n         res_columns[0]->insert(key.query_string); /// approximates the original query string\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02494_query_cache_user_isolation.reference b/tests/queries/0_stateless/02494_query_cache_user_isolation.reference\nnew file mode 100644\nindex 000000000000..f8c4b31b22ae\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_user_isolation.reference\n@@ -0,0 +1,28 @@\n+Attack 1\n+0\n+system.query_cache with old user\t1\n+0\n+0\t1\n+1\t0\n+system.query_cache with new user\t0\n+0\n+0\t1\n+1\t0\n+0\t1\n+Attack 2\n+-- policy_1 test\n+1\t1\n+3\t1\n+6\t1\n+-- policy_2 test\n+2\t2\n+5\t2\n+8\t2\n+-- policy_1 with query cache test\n+1\t1\n+3\t1\n+6\t1\n+-- policy_2 with query cache test\n+2\t2\n+5\t2\n+8\t2\ndiff --git a/tests/queries/0_stateless/02494_query_cache_user_isolation.sh b/tests/queries/0_stateless/02494_query_cache_user_isolation.sh\nnew file mode 100755\nindex 000000000000..d55e2460619a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_user_isolation.sh\n@@ -0,0 +1,110 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel, no-fasttest, long\n+# Tag no-parallel: Messes with internal cache\n+#     no-fasttest: Produces wrong results in fasttest, unclear why, didn't reproduce locally.\n+#     long: Sloooow ...\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# -- Attack 1:\n+#    - create a user,\n+#    - run a query whose result is stored in the query cache,\n+#    - drop the user, recreate it with the same name\n+#    - test that the cache entry is inaccessible\n+\n+echo \"Attack 1\"\n+\n+rnd=`tr -dc 1-9 </dev/urandom | head -c 5` # disambiguates the specific query in system.query_log below\n+# echo $rnd\n+\n+# Start with empty query cache (QC).\n+${CLICKHOUSE_CLIENT} --query \"SYSTEM DROP QUERY CACHE\"\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP USER IF EXISTS admin\"\n+${CLICKHOUSE_CLIENT} --query \"CREATE USER admin\"\n+${CLICKHOUSE_CLIENT} --query \"GRANT CURRENT GRANTS ON *.* TO admin WITH GRANT OPTION\"\n+\n+# Insert cache entry\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT 0 == $rnd SETTINGS use_query_cache = 1\"\n+\n+# Check that the system view knows the new cache entry\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT 'system.query_cache with old user', count(*) FROM system.query_cache\"\n+\n+# Run query again. The 1st run must be a cache miss, the 2nd run a cache hit\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT 0 == $rnd SETTINGS use_query_cache = 1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SYSTEM FLUSH LOGS\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT ProfileEvents['QueryCacheHits'], ProfileEvents['QueryCacheMisses'] FROM system.query_log WHERE type = 'QueryFinish' AND current_database = currentDatabase() AND query = 'SELECT 0 == $rnd SETTINGS use_query_cache = 1' order by event_time_microseconds\"\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP USER IF EXISTS admin\"\n+${CLICKHOUSE_CLIENT} --query \"CREATE USER admin\"\n+${CLICKHOUSE_CLIENT} --query \"GRANT CURRENT GRANTS ON *.* TO admin WITH GRANT OPTION\"\n+\n+# Check that the system view reports the cache as empty\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT 'system.query_cache with new user', count(*) FROM system.query_cache\"\n+\n+# Run same query as old user. Expect a cache miss.\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT 0 == $rnd SETTINGS use_query_cache = 1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SYSTEM FLUSH LOGS\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT ProfileEvents['QueryCacheHits'], ProfileEvents['QueryCacheMisses'] FROM system.query_log WHERE type = 'QueryFinish' AND current_database = currentDatabase() AND query = 'SELECT 0 == $rnd SETTINGS use_query_cache = 1' order by event_time_microseconds\"\n+\n+# Cleanup\n+${CLICKHOUSE_CLIENT} --query \"DROP USER admin\"\n+${CLICKHOUSE_CLIENT} --query \"SYSTEM DROP QUERY CACHE\"\n+\n+# -- Attack 2: (scenario from issue #58054)\n+#    - create a user,\n+#    - create two roles, each with different row policies\n+#    - cached query result in the context of the 1st role must must not be visible in the context of the 2nd role\n+\n+echo \"Attack 2\"\n+\n+# Start with empty query cache (QC).\n+${CLICKHOUSE_CLIENT} --query \"SYSTEM DROP QUERY CACHE\"\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP USER IF EXISTS admin\"\n+${CLICKHOUSE_CLIENT} --query \"CREATE USER admin\"\n+${CLICKHOUSE_CLIENT} --query \"GRANT CURRENT GRANTS ON *.* TO admin WITH GRANT OPTION\"\n+\n+# Create table\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP TABLE IF EXISTS user_data\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"CREATE TABLE user_data (ID UInt32, userID UInt32) ENGINE = MergeTree ORDER BY userID\"\n+\n+# Create roles with row-level security\n+\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE IF EXISTS user_role_1\"\n+# ${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE POLICY IF EXISTS user_policy_1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"CREATE ROLE user_role_1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"GRANT SELECT ON user_data TO user_role_1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"CREATE ROW POLICY user_policy_1 ON user_data FOR SELECT USING userID = 1 TO user_role_1\"\n+\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE IF EXISTS user_role_2\"\n+# ${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE POLICY IF EXISTS user_policy_2\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"CREATE ROLE user_role_2\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"GRANT SELECT ON user_data TO user_role_2\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"CREATE ROW POLICY user_policy_2 ON user_data FOR SELECT USING userID = 2 TO user_role_2\"\n+\n+# Grant roles to admin\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"GRANT user_role_1, user_role_2 TO admin\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"INSERT INTO user_data (ID, userID) VALUES (1, 1), (2, 2), (3, 1), (4, 3), (5, 2), (6, 1), (7, 4), (8, 2)\"\n+\n+# Test...\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT '-- policy_1 test'\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --multiquery \"SET ROLE user_role_1; SELECT * FROM user_data\" # should only return rows with userID = 1\n+\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT '-- policy_2 test'\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --multiquery \"SET ROLE user_role_2; SELECT * FROM user_data\" # should only return rows with userID = 2\n+\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT '-- policy_1 with query cache test'\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --multiquery \"SET ROLE user_role_1; SELECT * FROM user_data SETTINGS use_query_cache = 1\" # should only return rows with userID = 1\n+\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"SELECT '-- policy_2 with query cache test'\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --multiquery \"SET ROLE user_role_2; SELECT * FROM user_data SETTINGS use_query_cache = 1\" # should only return rows with userID = 2 (not userID = 1!)\n+\n+# Cleanup\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE user_role_1\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP ROLE user_role_2\"\n+${CLICKHOUSE_CLIENT} --user \"admin\" --query \"DROP TABLE user_data\"\n+${CLICKHOUSE_CLIENT} --query \"DROP USER admin\"\n+${CLICKHOUSE_CLIENT} --query \"SYSTEM DROP QUERY CACHE\"\n",
  "problem_statement": "Flush cached result when user switch role\nCache query results are tied to the user and their queries. The authorisation on the data being accessed is checked at the time the queries execute but not when retrieving the cache. As such, Any changes on user's permission in between queries will not be reflected on the cached query result.\r\n\r\nSimple steps to test\r\n\r\n```\r\nCREATE USER admin IDENTIFIED BY  'password';\r\n\r\nGRANT CURRENT GRANTS ON *.* TO admin WITH GRANT OPTION;\r\n\r\n-- Login as admin.  Could be done anytime after admin creation, but must be\r\n-- done before table can be queried, after grants are given\r\n\r\n-- 1. Create the table\r\nCREATE TABLE user_data\r\n(\r\n    ID UInt32,\r\n    userID UInt32\r\n)\r\nENGINE = MergeTree\r\nORDER BY userID;\r\n\r\n-- 2. Create roles with row-level security\r\n\r\n-- Role for users with userID = 1\r\n\r\nCREATE ROLE user_role_1;\r\nGRANT SELECT ON user_data TO user_role_1;\r\nCREATE ROW POLICY user_policy_1 ON user_data\r\n    FOR SELECT USING userID = 1 TO user_role_1;\r\n\r\n-- Role for users with userID = 2\r\n\r\nCREATE ROLE user_role_2;\r\nGRANT SELECT ON user_data TO user_role_2;\r\nCREATE ROW POLICY user_policy_2 ON user_data\r\n    FOR SELECT USING userID = 2 TO user_role_2;\r\n\r\n-- 3. Grant roles to the admin user\r\n\r\nGRANT user_role_1, user_role_2 TO admin;\r\n\r\nINSERT INTO user_data (ID, userID) VALUES (1, 1), (2, 2), (3, 1), (4, 3), (5, 2), (6, 1), (7, 4), (8, 2);\r\n\r\n\r\n-- Switch to admin if not already done so\r\n\r\n-- Policy test\r\n\r\nSET ROLE user_role_1;\r\n\r\n-- only returns rows for user_role_1\r\nSELECT * FROM user_data;\r\n\r\nSET ROLE ALL;\r\nSET ROLE user_role_2;\r\n\r\n-- only returns rows for user_role_2\r\nSELECT * FROM user_data;\r\n\r\nSET ROLE ALL;\r\nSET ROLE user_role_1;\r\n\r\n-- only returns rows for user_role_1\r\nSELECT * FROM user_data SETTINGS use_query_cache=1;\r\n\r\nSET ROLE ALL;\r\nSET ROLE user_role_2;\r\n\r\n-- \ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8 user_role_1 ROWS is returned here instead of user_role_2\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\r\nSELECT * FROM user_data SETTINGS use_query_cache=1;\r\n```\r\n\r\nWhile i think the current behaviour is somewhat expected from a caching layer (this is similar to how web server caching behaves where CDN doesnt have context of user permissions and one would rely on the cache to eventually expire) and the issue only surface in a very particular setup & usage of cached query. For now, i [updated the documentation to warn about this behavior](https://github.com/ClickHouse/ClickHouse/pull/58053) until we solve it properly.\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nA simple fix would be to flush any cache result when the roles are updated.\r\n\r\nA more complex fix that may help when users switching roles/context all the time and still want to use cached query results is to incorporate into the query cache some sort of hash key with current grant (or at least the rolenames) to be checked when returning cache result.=\n",
  "hints_text": "When it comes to security, we rather keep things simple, i.e. flush the cache instead of adding grants/roles to the query cache key. Since flushing would affect only the entries of a single user (leaving other user's entries cached), and role changes are rather rare, performance impact will be negligible in the common case.\r\n\r\n@vitlibar I guess you know RBAC best. I have a few questions:\r\n- I suppose these queries are affected:\r\n    - `DROP USER` (needs query cache flush to prevent the creation of a new user with the same name that could access query cache entries of the dropped user)\r\n    - `SET ROLE` (needs query cache flush to prevent bypassing row policies, that's @santrancisco's example)\r\n    - anything else?\r\n\r\n- Could you please point me to files/functions in the code for each of the scenarios where a cache flush could be done?\nFlushing the cache doesn't look quite good because\r\n1. there can be simultaneous sessions with the same user and different roles\r\n2. it seems maybe difficult to understand when the cache must be flushed. For example, users as well as roles can be stored in ZooKeeper and so they can be changed remotely. We can subscribe on that of course but that would seem quite complicated.\r\n\r\nI think it's both easier and reliable to improve [QueryCache::Key](https://github.com/ClickHouse/ClickHouse/blob/6aee18ced8f2428c2d48dd0be78dd29be68cd97d/src/Interpreters/Cache/QueryCache.h#L55) instead. For example, we could replace `user_name` there with `user_id` (that will help with the case with `DROP USER` and then creating a user with the same name again), and also we could add `std::vector<UUID> current_roles` and maybe `Settings settings` to `QueryCache::Key` like it's done for `AsynchronousInsertQueue::InsertQuery`.\nSounds good, let me try.",
  "created_at": "2024-01-08T21:01:52Z"
}