You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Flush cached result when user switch role
Cache query results are tied to the user and their queries. The authorisation on the data being accessed is checked at the time the queries execute but not when retrieving the cache. As such, Any changes on user's permission in between queries will not be reflected on the cached query result.

Simple steps to test

```
CREATE USER admin IDENTIFIED BY  'password';

GRANT CURRENT GRANTS ON *.* TO admin WITH GRANT OPTION;

-- Login as admin.  Could be done anytime after admin creation, but must be
-- done before table can be queried, after grants are given

-- 1. Create the table
CREATE TABLE user_data
(
    ID UInt32,
    userID UInt32
)
ENGINE = MergeTree
ORDER BY userID;

-- 2. Create roles with row-level security

-- Role for users with userID = 1

CREATE ROLE user_role_1;
GRANT SELECT ON user_data TO user_role_1;
CREATE ROW POLICY user_policy_1 ON user_data
    FOR SELECT USING userID = 1 TO user_role_1;

-- Role for users with userID = 2

CREATE ROLE user_role_2;
GRANT SELECT ON user_data TO user_role_2;
CREATE ROW POLICY user_policy_2 ON user_data
    FOR SELECT USING userID = 2 TO user_role_2;

-- 3. Grant roles to the admin user

GRANT user_role_1, user_role_2 TO admin;

INSERT INTO user_data (ID, userID) VALUES (1, 1), (2, 2), (3, 1), (4, 3), (5, 2), (6, 1), (7, 4), (8, 2);


-- Switch to admin if not already done so

-- Policy test

SET ROLE user_role_1;

-- only returns rows for user_role_1
SELECT * FROM user_data;

SET ROLE ALL;
SET ROLE user_role_2;

-- only returns rows for user_role_2
SELECT * FROM user_data;

SET ROLE ALL;
SET ROLE user_role_1;

-- only returns rows for user_role_1
SELECT * FROM user_data SETTINGS use_query_cache=1;

SET ROLE ALL;
SET ROLE user_role_2;

-- ðŸš¨ðŸš¨ðŸš¨ðŸš¨ user_role_1 ROWS is returned here instead of user_role_2ðŸš¨ðŸš¨ðŸš¨ðŸš¨
SELECT * FROM user_data SETTINGS use_query_cache=1;
```

While i think the current behaviour is somewhat expected from a caching layer (this is similar to how web server caching behaves where CDN doesnt have context of user permissions and one would rely on the cache to eventually expire) and the issue only surface in a very particular setup & usage of cached query. For now, i [updated the documentation to warn about this behavior](https://github.com/ClickHouse/ClickHouse/pull/58053) until we solve it properly.


**Describe the solution you'd like**

A simple fix would be to flush any cache result when the roles are updated.

A more complex fix that may help when users switching roles/context all the time and still want to use cached query results is to incorporate into the query cache some sort of hash key with current grant (or at least the rolenames) to be checked when returning cache result.=
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
