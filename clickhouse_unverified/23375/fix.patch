diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 0a281436183e..1fa0f4eab7c6 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -1510,7 +1510,8 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
 
         optimize_read_in_order =
             settings.optimize_read_in_order
-            && storage && query.orderBy()
+            && storage
+            && query.orderBy()
             && !query_analyzer.hasAggregation()
             && !query_analyzer.hasWindow()
             && !query.final()
diff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp
index 5f2b5f4db962..3bb7034b5884 100644
--- a/src/Storages/ReadInOrderOptimizer.cpp
+++ b/src/Storages/ReadInOrderOptimizer.cpp
@@ -44,7 +44,7 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(const StorageMetadataPtr &
     int read_direction = required_sort_description.at(0).direction;
 
     size_t prefix_size = std::min(required_sort_description.size(), sorting_key_columns.size());
-    auto aliase_columns = metadata_snapshot->getColumns().getAliases();
+    auto aliased_columns = metadata_snapshot->getColumns().getAliases();
 
     for (size_t i = 0; i < prefix_size; ++i)
     {
@@ -55,13 +55,18 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(const StorageMetadataPtr &
         ///  or in some simple cases when order key element is wrapped into monotonic function.
         auto apply_order_judge = [&] (const ExpressionActions::Actions & actions, const String & sort_column)
         {
+            /// If required order depend on collation, it cannot be matched with primary key order.
+            /// Because primary keys cannot have collations.
+            if (required_sort_description[i].collator)
+                return false;
+
             int current_direction = required_sort_description[i].direction;
-            /// For the path:  order by (sort_column, ...)
+            /// For the path: order by (sort_column, ...)
             if (sort_column == sorting_key_columns[i] && current_direction == read_direction)
             {
                 return true;
             }
-            /// For the path:  order by (function(sort_column), ...)
+            /// For the path: order by (function(sort_column), ...)
             /// Allow only one simple monotonic functions with one argument
             /// Why not allow multi monotonic functions?
             else
@@ -125,7 +130,7 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(const StorageMetadataPtr &
         /// currently we only support alias column without any function wrapper
         /// ie: `order by aliased_column` can have this optimization, but `order by function(aliased_column)` can not.
         /// This suits most cases.
-        if (context->getSettingsRef().optimize_respect_aliases && aliase_columns.contains(required_sort_description[i].column_name))
+        if (context->getSettingsRef().optimize_respect_aliases && aliased_columns.contains(required_sort_description[i].column_name))
         {
             auto column_expr = metadata_snapshot->getColumns().get(required_sort_description[i].column_name).default_desc.expression->clone();
             replaceAliasColumnsInQuery(column_expr, metadata_snapshot->getColumns(), forbidden_columns, context);
