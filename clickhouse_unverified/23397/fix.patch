diff --git a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp
index 50f8266a2a0a..d19f6c721c80 100644
--- a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp
+++ b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp
@@ -218,14 +218,20 @@ void MergeTreeWhereOptimizer::optimize(ASTSelectQuery & select) const
         if (!it->viable)
             break;
 
-        /// 10% ratio is just a guess.
-        /// If sizes of compressed columns cannot be calculated, e.g. for compact parts,
-        /// use number of moved columns as a fallback.
-        bool moved_enough =
-            (total_size_of_queried_columns > 0 && total_size_of_moved_conditions > 0
-            && (total_size_of_moved_conditions + it->columns_size) * 10 > total_size_of_queried_columns)
-                || (total_number_of_moved_columns > 0
-                    && (total_number_of_moved_columns + it->identifiers.size()) * 10 > queried_columns.size());
+        bool moved_enough = false;
+        if (total_size_of_queried_columns > 0)
+        {
+            /// If we know size of queried columns use it as threshold. 10% ratio is just a guess.
+            moved_enough = total_size_of_moved_conditions > 0
+                && (total_size_of_moved_conditions + it->columns_size) * 10 > total_size_of_queried_columns;
+        }
+        else
+        {
+            /// Otherwise, use number of moved columns as a fallback.
+            /// It can happen, if table has only compact parts. 25% ratio is just a guess.
+            moved_enough = total_number_of_moved_columns > 0
+                && (total_number_of_moved_columns + it->identifiers.size()) * 4 > queried_columns.size();
+        }
 
         if (moved_enough)
             break;
