{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34932,
  "instance_id": "ClickHouse__ClickHouse-34932",
  "issue_numbers": [
    "5895"
  ],
  "base_commit": "ba9150abb00b31234ec1a6b426f3b36978f068c8",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 81613093a721..808350c5e863 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -444,6 +444,7 @@ class IColumn;\n     M(Bool, optimize_normalize_count_variants, true, \"Rewrite aggregate functions that semantically equals to count() as count().\", 0) \\\n     M(Bool, optimize_injective_functions_inside_uniq, true, \"Delete injective functions of one argument inside uniq*() functions.\", 0) \\\n     M(Bool, convert_query_to_cnf, false, \"Convert SELECT query to CNF\", 0) \\\n+    M(Bool, optimize_or_like_chain, true, \"Optimize multiple OR LIKE into multiMatchAny. This optimization should not be enabled by default, because it defies index analysis in some cases.\", 0) \\\n     M(Bool, optimize_arithmetic_operations_in_aggregate_functions, true, \"Move arithmetic operations out of aggregation functions\", 0) \\\n     M(Bool, optimize_duplicate_order_by_and_distinct, true, \"Remove duplicate ORDER BY and DISTINCT if it's possible\", 0) \\\n     M(Bool, optimize_redundant_functions_in_order_by, true, \"Remove functions from ORDER BY if its argument is also in ORDER BY\", 0) \\\ndiff --git a/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp b/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp\nnew file mode 100644\nindex 000000000000..523c7c109dd3\n--- /dev/null\n+++ b/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp\n@@ -0,0 +1,76 @@\n+#include <Functions/likePatternToRegexp.h>\n+#include <Interpreters/ConvertFunctionOrLikeVisitor.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/IAST.h>\n+#include <Common/typeid_cast.h>\n+\n+\n+namespace DB\n+{\n+\n+void ConvertFunctionOrLikeData::visit(ASTFunction & function, ASTPtr &)\n+{\n+    if (function.name != \"or\")\n+        return;\n+\n+    std::unordered_map<ASTPtr, std::shared_ptr<ASTLiteral>> identifier_to_literals;\n+    for (auto & child : function.children)\n+    {\n+        if (auto expr_list_fn = child->as<ASTExpressionList>())\n+        {\n+            ASTs unique_elems;\n+            for (auto child_expr_fn : expr_list_fn->children)\n+            {\n+                unique_elems.push_back(child_expr_fn);\n+                if (const auto * child_fn = child_expr_fn->as<ASTFunction>())\n+                {\n+                    const bool is_like = child_fn->name == \"like\";\n+                    const bool is_ilike = child_fn->name == \"ilike\";\n+\n+                    /// Not {i}like -> bail out.\n+                    if (!is_like && !is_ilike)\n+                        continue;\n+\n+                    const auto & arguments = child_fn->arguments->children;\n+\n+                    /// They should have 2 arguments.\n+                    if (arguments.size() != 2)\n+                        continue;\n+\n+                    /// Second one is string literal.\n+                    auto identifier = arguments[0];\n+                    auto literal = arguments[1]->as<ASTLiteral>();\n+                    if (!identifier || !literal || literal->value.getType() != Field::Types::String)\n+                        continue;\n+\n+                    String regexp = likePatternToRegexp(literal->value.get<String>());\n+                    /// Case insensitive. Works with UTF-8 as well.\n+                    if (is_ilike)\n+                        regexp = \"(?i)\" + regexp;\n+\n+                    unique_elems.pop_back();\n+                    auto it = identifier_to_literals.find(identifier);\n+                    if (it == identifier_to_literals.end())\n+                    {\n+                        it = identifier_to_literals.insert({identifier, std::make_shared<ASTLiteral>(Field{Array{}})}).first;\n+                        auto match = makeASTFunction(\"multiMatchAny\");\n+                        match->arguments->children.push_back(std::move(arguments[0]));\n+                        match->arguments->children.push_back(it->second);\n+                        unique_elems.push_back(std::move(match));\n+                    }\n+                    it->second->value.get<Array>().push_back(regexp);\n+                }\n+            }\n+\n+            /// OR must have at least two arguments.\n+            if (unique_elems.size() == 1)\n+                unique_elems.push_back(std::make_shared<ASTLiteral>(Field(false)));\n+\n+            expr_list_fn->children = std::move(unique_elems);\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/src/Interpreters/ConvertFunctionOrLikeVisitor.h b/src/Interpreters/ConvertFunctionOrLikeVisitor.h\nnew file mode 100644\nindex 000000000000..ba4a00734481\n--- /dev/null\n+++ b/src/Interpreters/ConvertFunctionOrLikeVisitor.h\n@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+namespace DB\n+{\n+\n+class ASTFunction;\n+\n+/// Replaces all the \"or\"'s with {i}like to multiMatchAny\n+class ConvertFunctionOrLikeData\n+{\n+public:\n+    using TypeToVisit = ASTFunction;\n+\n+    void visit(ASTFunction & function, ASTPtr & ast);\n+};\n+\n+using ConvertFunctionOrLikeVisitor = InDepthNodeVisitor<OneTypeMatcher<ConvertFunctionOrLikeData>, true>;\n+\n+}\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 64b25ca9777c..c28d07bee5b7 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -17,6 +17,7 @@\n #include <Interpreters/RewriteCountVariantsVisitor.h>\n #include <Interpreters/MonotonicityCheckVisitor.h>\n #include <Interpreters/ConvertStringsToEnumVisitor.h>\n+#include <Interpreters/ConvertFunctionOrLikeVisitor.h>\n #include <Interpreters/RewriteFunctionToSubcolumnVisitor.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n@@ -720,6 +721,12 @@ void optimizeFuseQuantileFunctions(ASTPtr & query)\n     }\n }\n \n+void optimizeOrLikeChain(ASTPtr & query)\n+{\n+    ConvertFunctionOrLikeVisitor::Data data = {};\n+    ConvertFunctionOrLikeVisitor(data).visit(query);\n+}\n+\n }\n \n void TreeOptimizer::optimizeIf(ASTPtr & query, Aliases & aliases, bool if_chain_to_multiif)\n@@ -828,6 +835,14 @@ void TreeOptimizer::apply(ASTPtr & query, TreeRewriterResult & result,\n \n     if (settings.optimize_syntax_fuse_functions)\n         optimizeFuseQuantileFunctions(query);\n+\n+    if (settings.optimize_or_like_chain\n+        && settings.allow_hyperscan\n+        && settings.max_hyperscan_regexp_length == 0\n+        && settings.max_hyperscan_regexp_total_length == 0)\n+    {\n+        optimizeOrLikeChain(query);\n+    }\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02226_or_like_combine.reference b/tests/queries/0_stateless/02226_or_like_combine.reference\nnew file mode 100644\nindex 000000000000..505554684352\n--- /dev/null\n+++ b/tests/queries/0_stateless/02226_or_like_combine.reference\n@@ -0,0 +1,34 @@\n+SELECT materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s\n+WHERE (s LIKE \\'hell%\\') OR (s ILIKE \\'%\u043f\u0440\u0438\u0432\u0435\u0442%\\') OR (s ILIKE \\'world%\\')\n+SELECT materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s\n+WHERE multiMatchAny(s, [\\'^hell\\', \\'(?i)\u043f\u0440\u0438\u0432\u0435\u0442\\', \\'(?i)^world\\']) OR false\n+SETTINGS optimize_or_like_chain = 1\n+SELECT\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s1,\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s2\n+WHERE multiMatchAny(s1, [\\'^hell\\', \\'(?i)^world\\']) OR multiMatchAny(s2, [\\'(?i)\u043f\u0440\u0438\u0432\u0435\u0442\\'])\n+SETTINGS optimize_or_like_chain = 1\n+SELECT\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s1,\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s2\n+WHERE (s1 LIKE \\'hell%\\') OR (s2 ILIKE \\'%\u043f\u0440\u0438\u0432\u0435\u0442%\\') OR (s1 ILIKE \\'world%\\')\n+SETTINGS optimize_or_like_chain = 1\n+SELECT\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s1,\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s2\n+WHERE (s1 LIKE \\'hell%\\') OR (s2 ILIKE \\'%\u043f\u0440\u0438\u0432\u0435\u0442%\\') OR (s1 ILIKE \\'world%\\')\n+SETTINGS optimize_or_like_chain = 1\n+SELECT\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s1,\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s2\n+WHERE (s1 LIKE \\'hell%\\') OR (s2 ILIKE \\'%\u043f\u0440\u0438\u0432\u0435\u0442%\\') OR (s1 ILIKE \\'world%\\')\n+SETTINGS optimize_or_like_chain = 1\n+SELECT\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s1,\n+    materialize(\\'\u041f\u0440\u0438\u0432\u0435\u0442, World\\') AS s2\n+WHERE multiMatchAny(s1, [\\'^hell\\', \\'(?i)^world\\']) OR multiMatchAny(s2, [\\'(?i)\u043f\u0440\u0438\u0432\u0435\u0442\\']) OR (s1 = \\'\u041f\u0440\u0438\u0432\u0435\u0442\\')\n+SETTINGS optimize_or_like_chain = 1\n+\u041f\u0440\u0438\u0432\u0435\u0442, optimized World\n+\u041f\u0440\u0438\u0432\u0435\u0442, World\n+\u041f\u0440\u0438\u0432\u0435\u0442, optimized World\n+\u041f\u0440\u0438\u0432\u0435\u0442, World\ndiff --git a/tests/queries/0_stateless/02226_or_like_combine.sql b/tests/queries/0_stateless/02226_or_like_combine.sql\nnew file mode 100644\nindex 000000000000..9a6fded98e0d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02226_or_like_combine.sql\n@@ -0,0 +1,15 @@\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s WHERE (s LIKE 'hell%') OR (s ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s ILIKE 'world%') SETTINGS optimize_or_like_chain = 0;\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s WHERE (s LIKE 'hell%') OR (s ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s ILIKE 'world%') SETTINGS optimize_or_like_chain = 1;\n+\n+\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s1, materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s2 WHERE (s1 LIKE 'hell%') OR (s2 ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s1 ILIKE 'world%') SETTINGS optimize_or_like_chain = 1;\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s1, materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s2 WHERE (s1 LIKE 'hell%') OR (s2 ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s1 ILIKE 'world%') SETTINGS optimize_or_like_chain = 1 SETTINGS allow_hyperscan = 0;\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s1, materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s2 WHERE (s1 LIKE 'hell%') OR (s2 ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s1 ILIKE 'world%') SETTINGS optimize_or_like_chain = 1 SETTINGS max_hyperscan_regexp_length = 10;\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s1, materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s2 WHERE (s1 LIKE 'hell%') OR (s2 ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s1 ILIKE 'world%') SETTINGS optimize_or_like_chain = 1 SETTINGS max_hyperscan_regexp_total_length = 10;\n+EXPLAIN SYNTAX SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s1, materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s2 WHERE (s1 LIKE 'hell%') OR (s2 ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s1 ILIKE 'world%') OR s1 == '\u041f\u0440\u0438\u0432\u0435\u0442' SETTINGS optimize_or_like_chain = 1;\n+\n+\n+SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, optimized World') AS s WHERE (s LIKE 'hell%') OR (s LIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s ILIKE '%world') SETTINGS optimize_or_like_chain = 1;\n+SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s WHERE (s LIKE 'hell%') OR (s LIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s ILIKE '%world') SETTINGS optimize_or_like_chain = 0;\n+SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, optimized World') AS s WHERE (s LIKE 'hell%') OR (s ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s LIKE 'world%') SETTINGS optimize_or_like_chain = 1;\n+SELECT materialize('\u041f\u0440\u0438\u0432\u0435\u0442, World') AS s WHERE (s LIKE 'hell%') OR (s ILIKE '%\u043f\u0440\u0438\u0432\u0435\u0442%') OR (s LIKE 'world%') SETTINGS optimize_or_like_chain = 0;\n",
  "problem_statement": "Transform OR LIKE chain to multiSearchAny or multiMatchAny.\n**Use case**\r\n`Params LIKE '%testid_145997%' OR Params LIKE '%testid_146118%' OR Params LIKE '%testid_146119%'`\r\n\n",
  "hints_text": "@kamalov-ruslan @xPoSx @demo-99",
  "created_at": "2022-02-27T16:52:56Z",
  "modified_files": [
    "src/Core/Settings.h",
    "b/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp",
    "b/src/Interpreters/ConvertFunctionOrLikeVisitor.h",
    "src/Interpreters/TreeOptimizer.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02226_or_like_combine.reference",
    "b/tests/queries/0_stateless/02226_or_like_combine.sql"
  ]
}