{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62362,
  "instance_id": "ClickHouse__ClickHouse-62362",
  "issue_numbers": [
    "62289"
  ],
  "base_commit": "f54b3438b149e9aa32dd30ffcdd574c221732271",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex ffbf008a6b3f..2502ab125041 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -2275,6 +2275,10 @@ void QueryAnalyzer::mergeWindowWithParentWindow(const QueryTreeNodePtr & window_\n   */\n void QueryAnalyzer::replaceNodesWithPositionalArguments(QueryTreeNodePtr & node_list, const QueryTreeNodes & projection_nodes, IdentifierResolveScope & scope)\n {\n+    const auto & settings = scope.context->getSettingsRef();\n+    if (!settings.enable_positional_arguments || scope.context->getClientInfo().query_kind != ClientInfo::QueryKind::INITIAL_QUERY)\n+        return;\n+\n     auto & node_list_typed = node_list->as<ListNode &>();\n \n     for (auto & node : node_list_typed.getNodes())\n@@ -2287,7 +2291,8 @@ void QueryAnalyzer::replaceNodesWithPositionalArguments(QueryTreeNodePtr & node_\n         auto * constant_node = (*node_to_replace)->as<ConstantNode>();\n \n         if (!constant_node\n-            || (constant_node->getValue().getType() != Field::Types::UInt64 && constant_node->getValue().getType() != Field::Types::Int64))\n+            || (constant_node->getValue().getType() != Field::Types::UInt64\n+                && constant_node->getValue().getType() != Field::Types::Int64))\n             continue;\n \n         UInt64 pos;\n@@ -6681,15 +6686,12 @@ void expandTuplesInList(QueryTreeNodes & key_list)\n   */\n void QueryAnalyzer::resolveGroupByNode(QueryNode & query_node_typed, IdentifierResolveScope & scope)\n {\n-    const auto & settings = scope.context->getSettingsRef();\n-\n     if (query_node_typed.isGroupByWithGroupingSets())\n     {\n         QueryTreeNodes nullable_group_by_keys;\n         for (auto & grouping_sets_keys_list_node : query_node_typed.getGroupBy().getNodes())\n         {\n-            if (settings.enable_positional_arguments)\n-                replaceNodesWithPositionalArguments(grouping_sets_keys_list_node, query_node_typed.getProjection().getNodes(), scope);\n+            replaceNodesWithPositionalArguments(grouping_sets_keys_list_node, query_node_typed.getProjection().getNodes(), scope);\n \n             // Remove redundant calls to `tuple` function. It simplifies checking if expression is an aggregation key.\n             // It's required to support queries like: SELECT number FROM numbers(3) GROUP BY (number, number % 2)\n@@ -6708,8 +6710,7 @@ void QueryAnalyzer::resolveGroupByNode(QueryNode & query_node_typed, IdentifierR\n     }\n     else\n     {\n-        if (settings.enable_positional_arguments)\n-            replaceNodesWithPositionalArguments(query_node_typed.getGroupByNode(), query_node_typed.getProjection().getNodes(), scope);\n+        replaceNodesWithPositionalArguments(query_node_typed.getGroupByNode(), query_node_typed.getProjection().getNodes(), scope);\n \n         // Remove redundant calls to `tuple` function. It simplifies checking if expression is an aggregation key.\n         // It's required to support queries like: SELECT number FROM numbers(3) GROUP BY (number, number % 2)\n@@ -7860,8 +7861,6 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n     if (query_node_typed.isCTE())\n         cte_in_resolve_process.insert(query_node_typed.getCTEName());\n \n-    const auto & settings = scope.context->getSettingsRef();\n-\n     bool is_rollup_or_cube = query_node_typed.isGroupByWithRollup() || query_node_typed.isGroupByWithCube();\n \n     if (query_node_typed.isGroupByWithGroupingSets()\n@@ -8045,8 +8044,9 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n     if (query_node_typed.hasOrderBy())\n     {\n-        if (settings.enable_positional_arguments)\n-            replaceNodesWithPositionalArguments(query_node_typed.getOrderByNode(), query_node_typed.getProjection().getNodes(), scope);\n+        replaceNodesWithPositionalArguments(query_node_typed.getOrderByNode(), query_node_typed.getProjection().getNodes(), scope);\n+\n+        const auto & settings = scope.context->getSettingsRef();\n \n         expandOrderByAll(query_node_typed, settings);\n         resolveSortNodeList(query_node_typed.getOrderByNode(), scope);\n@@ -8069,8 +8069,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n     if (query_node_typed.hasLimitBy())\n     {\n-        if (settings.enable_positional_arguments)\n-            replaceNodesWithPositionalArguments(query_node_typed.getLimitByNode(), query_node_typed.getProjection().getNodes(), scope);\n+        replaceNodesWithPositionalArguments(query_node_typed.getLimitByNode(), query_node_typed.getProjection().getNodes(), scope);\n \n         resolveExpressionNodeList(query_node_typed.getLimitByNode(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n     }\ndiff --git a/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp b/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\nindex c8d230c87d92..d45454824770 100644\n--- a/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\n+++ b/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\n@@ -68,6 +68,10 @@ std::unique_ptr<QueryPlan> createLocalPlan(\n \n     if (context->getSettingsRef().allow_experimental_analyzer)\n     {\n+        /// For Analyzer, identifier in GROUP BY/ORDER BY/LIMIT BY lists has been resolved to\n+        /// ConstantNode in QueryTree if it is an alias of a constant, so we should not replace\n+        /// ConstantNode with ProjectionNode again(https://github.com/ClickHouse/ClickHouse/issues/62289).\n+        new_context->setSetting(\"enable_positional_arguments\", Field(false));\n         auto interpreter = InterpreterSelectQueryAnalyzer(query_ast, new_context, select_query_options);\n         query_plan = std::make_unique<QueryPlan>(std::move(interpreter).extractQueryPlan());\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.reference b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.reference\nnew file mode 100644\nindex 000000000000..bb0b1cf658d1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.reference\n@@ -0,0 +1,3 @@\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.sql b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.sql\nnew file mode 100644\nindex 000000000000..16ba3b155948\n--- /dev/null\n+++ b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.sql\n@@ -0,0 +1,7 @@\n+select 0 as x\n+from remote('127.0.0.{1,2}', system.one)\n+group by x;\n+\n+select 0 as x\n+from remote('127.0.0.{1,2}', system.one)\n+order by x;\n",
  "problem_statement": "new analyzer: Positional argument is out of bounds in distributed queries\nhttps://fiddle.clickhouse.com/ba2e163f-644b-4a4c-b6f7-614aa285ca00\r\n\r\n```sql\r\nset allow_experimental_analyzer=0;\r\n\r\nselect 0 as x\r\nfrom remote('127.0.0.{1,2}', system.one)\r\ngroup by x\r\nformat Pretty;\r\n\r\n   +---+\r\n   | x |\r\n   +---+\r\n1. | 0 |\r\n   +---+\r\n\r\n\r\nset allow_experimental_analyzer=1;\r\n\r\nselect 0 as x\r\nfrom remote('127.0.0.{1,2}', system.one)\r\ngroup by x\r\nformat Pretty;\r\n\r\nReceived exception from server (version 24.3.2):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: \r\nPositional argument number 0 is out of bounds. Expected in range [1, 1]. \r\nIn scope SELECT 0 AS x FROM system.one AS __table1 GROUP BY 0. (BAD_ARGUMENTS)\r\n(query: select 0 as x\r\nfrom remote('127.0.0.{1,2}', system.one)\r\ngroup by x\r\nformat Pretty;)\r\n```\n",
  "hints_text": "",
  "created_at": "2024-04-06T14:25:18Z",
  "modified_files": [
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.reference",
    "b/tests/queries/0_stateless/03018_analyzer_distributed_query_with_positional_arguments.sql"
  ]
}