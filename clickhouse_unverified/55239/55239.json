{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55239,
  "instance_id": "ClickHouse__ClickHouse-55239",
  "issue_numbers": [
    "27229"
  ],
  "base_commit": "ef78889aa206eb6b5462d1661a2af2ee921837a4",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 22a362cd39c1..d7809be86bfe 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -2794,3 +2794,71 @@ message Root\n     uint32 column2 = 2;\n }\n ```\n+\n+## formatQuery\n+\n+Returns a formatted, possibly multi-line, version of the given SQL query.\n+\n+**Syntax**\n+\n+```sql\n+formatQuery(query)\n+```\n+\n+**Arguments**\n+\n+- `query` - The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n+\n+**Returned value**\n+\n+- The formatted query. [String](../../sql-reference/data-types/string.md).\n+\n+**Example**\n+\n+```sql\n+SELECT formatQuery('select a,    b FRom tab WHERE a > 3 and  b < 3');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500formatQuery('select a,    b FRom tab WHERE a > 3 and  b < 3')\u2500\u2510\n+\u2502 SELECT\n+    a,\n+    b\n+FROM tab\n+WHERE (a > 3) AND (b < 3)            \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## formatQuerySingleLine\n+\n+Like formatQuery() but the returned formatted string contains no line breaks.\n+\n+**Syntax**\n+\n+```sql\n+formatQuerySingleLine(query)\n+```\n+\n+**Arguments**\n+\n+- `query` - The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\n+\n+**Returned value**\n+\n+- The formatted query. [String](../../sql-reference/data-types/string.md).\n+\n+**Example**\n+\n+```sql\n+SELECT formatQuerySingleLine('select a,    b FRom tab WHERE a > 3 and  b < 3');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500formatQuerySingleLine('select a,    b FRom tab WHERE a > 3 and  b < 3')\u2500\u2510\n+\u2502 SELECT a, b FROM tab WHERE (a > 3) AND (b < 3)                          \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/formatQuery.cpp b/src/Functions/formatQuery.cpp\nnew file mode 100644\nindex 000000000000..f4cb937eed4b\n--- /dev/null\n+++ b/src/Functions/formatQuery.cpp\n@@ -0,0 +1,137 @@\n+#include <Columns/ColumnString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <IO/WriteBufferFromVector.h>\n+#include <Interpreters/Context.h>\n+#include <Parsers/ParserQuery.h>\n+#include <Parsers/formatAST.h>\n+#include <Parsers/parseQuery.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+template <bool one_line, typename Name>\n+class FunctionFormatQuery : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        const auto & settings = context->getSettings();\n+        return std::make_shared<FunctionFormatQuery>(settings.max_query_size, settings.max_parser_depth);\n+    }\n+\n+    FunctionFormatQuery(size_t max_query_size_, size_t max_parser_depth_)\n+        : max_query_size(max_query_size_), max_parser_depth(max_parser_depth_)\n+    {\n+    }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors mandatory_args{{\"query\", &isString<IDataType>, nullptr, \"String\"}};\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args);\n+        return arguments[0].type;\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    {\n+        const ColumnPtr column = arguments[0].column;\n+        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))\n+        {\n+            auto col_res = ColumnString::create();\n+            formatVector(col->getChars(), col->getOffsets(), col_res->getChars(), col_res->getOffsets());\n+            return col_res;\n+        }\n+        else\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName());\n+    }\n+\n+private:\n+    void formatQueryImpl(const char * begin, const char * end, ColumnString::Chars & output) const\n+    {\n+        ParserQuery parser{end};\n+        auto ast = parseQuery(parser, begin, end, {}, max_query_size, max_parser_depth);\n+        WriteBufferFromVector buf(output, AppendModeTag{});\n+        formatAST(*ast, buf, /* hilite */ false, /* one_line */ one_line);\n+        buf.finalize();\n+    }\n+    void formatVector(\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        ColumnString::Chars & res_data,\n+        ColumnString::Offsets & res_offsets) const\n+    {\n+        const size_t size = offsets.size();\n+        res_offsets.resize(size);\n+        res_data.reserve(data.size());\n+\n+        size_t prev_in_offset = 0;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            const auto * begin = reinterpret_cast<const char *>(&data[prev_in_offset]);\n+            const char * end = begin + offsets[i] - 1;\n+            formatQueryImpl(begin, end, res_data);\n+            res_offsets[i] = res_data.size() + 1;\n+            prev_in_offset = offsets[i];\n+        }\n+    }\n+    size_t max_query_size;\n+    size_t max_parser_depth;\n+};\n+\n+struct NameFormatQuery\n+{\n+    static constexpr auto name = \"formatQuery\";\n+};\n+\n+struct NameFormatQuerySingleLine\n+{\n+    static constexpr auto name = \"formatQuerySingleLine\";\n+};\n+\n+REGISTER_FUNCTION(formatQuery)\n+{\n+    factory.registerFunction<FunctionFormatQuery<false, NameFormatQuery>>(FunctionDocumentation{\n+        .description = \"Returns a formatted, possibly multi-line, version of the given SQL query.\\n[example:multiline]\",\n+        .syntax = \"formatQuery(query)\",\n+        .arguments = {{\"query\", \"The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\"}},\n+        .returned_value = \"The formatted query. [String](../../sql-reference/data-types/string.md).\",\n+        .examples{\n+            {\"multiline\",\n+             \"SELECT formatQuery('select a,    b FRom tab WHERE a > 3 and  b < 3');\",\n+             \"SELECT\\n\"\n+             \"    a,\\n\"\n+             \"    b\\n\"\n+             \"FROM tab\\n\"\n+             \"WHERE (a > 3) AND (b < 3)\"}},\n+        .categories{\"Other\"}});\n+}\n+\n+REGISTER_FUNCTION(formatQuerySingleLine)\n+{\n+    factory.registerFunction<FunctionFormatQuery<true, NameFormatQuerySingleLine>>(FunctionDocumentation{\n+        .description = \"Like formatQuery() but the returned formatted string contains no line breaks.\\n[example:multiline]\",\n+        .syntax = \"formatQuerySingleLine(query)\",\n+        .arguments = {{\"query\", \"The SQL query to be formatted. [String](../../sql-reference/data-types/string.md)\"}},\n+        .returned_value = \"The formatted query. [String](../../sql-reference/data-types/string.md).\",\n+        .examples{\n+            {\"multiline\",\n+             \"SELECT formatQuerySingleLine('select a,    b FRom tab WHERE a > 3 and  b < 3');\",\n+             \"SELECT a, b FROM tab WHERE (a > 3) AND (b < 3)\"}},\n+        .categories{\"Other\"}});\n+}\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex b5d66f5e17b1..b506794b5cff 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1476,6 +1476,8 @@ fmtlib\n formatDateTime\n formatDateTimeInJoda\n formatDateTimeInJodaSyntax\n+formatQuery\n+formatQuerySingleLine\n formatReadableDecimalSize\n formatReadableQuantity\n formatReadableSize\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02882_formatQuery.reference b/tests/queries/0_stateless/02882_formatQuery.reference\nnew file mode 100644\nindex 000000000000..fd84a9505b12\n--- /dev/null\n+++ b/tests/queries/0_stateless/02882_formatQuery.reference\n@@ -0,0 +1,19 @@\n+SELECT 1\n+SELECT 1\n+SELECT 1\n+SELECT 1\n+1\n+INSERT INTO tab FORMAT Values\n+CREATE TABLE default.no_prop_table\\n(\\n    `some_column` UInt64\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+EXPLAIN SYNTAX\\nSELECT\\n    CAST(1, \\'INT\\'),\\n    CEIL(1),\\n    CEILING(1),\\n    CHAR(49),\\n    CHAR_LENGTH(\\'1\\'),\\n    CHARACTER_LENGTH(\\'1\\'),\\n    COALESCE(1),\\n    CONCAT(\\'1\\', \\'1\\'),\\n    CORR(1, 1),\\n    COS(1),\\n    COUNT(1),\\n    COVAR_POP(1, 1),\\n    COVAR_SAMP(1, 1),\\n    DATABASE(),\\n    SCHEMA(),\\n    dateDiff(\\'DAY\\', toDate(\\'2020-10-24\\'), toDate(\\'2019-10-24\\')),\\n    EXP(1),\\n    FLATTEN([[1]]),\\n    FLOOR(1),\\n    FQDN(),\\n    GREATEST(1),\\n    IF(1, 1, 1),\\n    IFNULL(1, 1),\\n    LCASE(\\'A\\'),\\n    LEAST(1),\\n    LENGTH(\\'1\\'),\\n    LN(1),\\n    LOCATE(\\'1\\', \\'1\\'),\\n    LOG(1),\\n    LOG10(1),\\n    LOG2(1),\\n    LOWER(\\'A\\'),\\n    MAX(1),\\n    MID(\\'123\\', 1, 1),\\n    MIN(1),\\n    MOD(1, 1),\\n    NOT 1,\\n    NOW(),\\n    NOW64(),\\n    NULLIF(1, 1),\\n    PI(),\\n    position(\\'123\\', \\'2\\'),\\n    POW(1, 1),\\n    POWER(1, 1),\\n    RAND(),\\n    REPLACE(\\'1\\', \\'1\\', \\'2\\'),\\n    REVERSE(\\'123\\'),\\n    ROUND(1),\\n    SIN(1),\\n    SQRT(1),\\n    STDDEV_POP(1),\\n    STDDEV_SAMP(1),\\n    SUBSTR(\\'123\\', 2),\\n    substring(\\'123\\', 2),\\n    SUM(1),\\n    TAN(1),\\n    TANH(1),\\n    TRUNC(1),\\n    TRUNCATE(1),\\n    UCASE(\\'A\\'),\\n    UPPER(\\'A\\'),\\n    USER(),\\n    VAR_POP(1),\\n    VAR_SAMP(1),\\n    WEEK(toDate(\\'2020-10-24\\')),\\n    YEARWEEK(toDate(\\'2020-10-24\\'))\\nFORMAT TSVRaw\n+1\n+formatQuerySingleLine\n+SELECT 1\n+SELECT 1\n+SELECT 1\n+SELECT 1\n+1\n+INSERT INTO tab FORMAT Values\n+CREATE TABLE default.no_prop_table (`some_column` UInt64) ENGINE = MergeTree ORDER BY tuple() SETTINGS index_granularity = 8192\n+EXPLAIN SYNTAX SELECT CAST(1, \\'INT\\'), CEIL(1), CEILING(1), CHAR(49), CHAR_LENGTH(\\'1\\'), CHARACTER_LENGTH(\\'1\\'), COALESCE(1), CONCAT(\\'1\\', \\'1\\'), CORR(1, 1), COS(1), COUNT(1), COVAR_POP(1, 1), COVAR_SAMP(1, 1), DATABASE(), SCHEMA(), dateDiff(\\'DAY\\', toDate(\\'2020-10-24\\'), toDate(\\'2019-10-24\\')), EXP(1), FLATTEN([[1]]), FLOOR(1), FQDN(), GREATEST(1), IF(1, 1, 1), IFNULL(1, 1), LCASE(\\'A\\'), LEAST(1), LENGTH(\\'1\\'), LN(1), LOCATE(\\'1\\', \\'1\\'), LOG(1), LOG10(1), LOG2(1), LOWER(\\'A\\'), MAX(1), MID(\\'123\\', 1, 1), MIN(1), MOD(1, 1), NOT 1, NOW(), NOW64(), NULLIF(1, 1), PI(), position(\\'123\\', \\'2\\'), POW(1, 1), POWER(1, 1), RAND(), REPLACE(\\'1\\', \\'1\\', \\'2\\'), REVERSE(\\'123\\'), ROUND(1), SIN(1), SQRT(1), STDDEV_POP(1), STDDEV_SAMP(1), SUBSTR(\\'123\\', 2), substring(\\'123\\', 2), SUM(1), TAN(1), TANH(1), TRUNC(1), TRUNCATE(1), UCASE(\\'A\\'), UPPER(\\'A\\'), USER(), VAR_POP(1), VAR_SAMP(1), WEEK(toDate(\\'2020-10-24\\')), YEARWEEK(toDate(\\'2020-10-24\\')) FORMAT TSVRaw\n+1\ndiff --git a/tests/queries/0_stateless/02882_formatQuery.sql b/tests/queries/0_stateless/02882_formatQuery.sql\nnew file mode 100644\nindex 000000000000..767283552d51\n--- /dev/null\n+++ b/tests/queries/0_stateless/02882_formatQuery.sql\n@@ -0,0 +1,21 @@\n+SELECT formatQuery('select 1;');\n+SELECT formatQuery('select 1');\n+SELECT formatQuery('SELECT 1;');\n+SELECT formatQuery('SELECT 1');\n+SELECT formatQuery('select 1;') == formatQuery('SeLecT 1');\n+SELECT formatQuery('INSERT INTO tab VALUES (\\'\\') (\\'test\\')');\n+SELECT formatQuery('CREATE TABLE default.no_prop_table(`some_column` UInt64) ENGINE = MergeTree ORDER BY tuple() SETTINGS index_granularity = 8192');\n+SELECT formatQuery('EXPLAIN SYNTAX SELECT CAST(1 AS INT), CEIL(1), CEILING(1), CHAR(49), CHAR_LENGTH(\\'1\\'), CHARACTER_LENGTH(\\'1\\'), COALESCE(1), CONCAT(\\'1\\', \\'1\\'), CORR(1, 1), COS(1), COUNT(1), COVAR_POP(1, 1), COVAR_SAMP(1, 1), DATABASE(), SCHEMA(), DATEDIFF(\\'DAY\\', toDate(\\'2020-10-24\\'), toDate(\\'2019-10-24\\')), EXP(1), FLATTEN([[1]]), FLOOR(1), FQDN(), GREATEST(1), IF(1, 1, 1), IFNULL(1, 1), LCASE(\\'A\\'), LEAST(1), LENGTH(\\'1\\'), LN(1), LOCATE(\\'1\\', \\'1\\'), LOG(1), LOG10(1), LOG2(1), LOWER(\\'A\\'), MAX(1), MID(\\'123\\', 1, 1), MIN(1), MOD(1, 1), NOT(1), NOW(), NOW64(), NULLIF(1, 1), PI(), POSITION(\\'123\\', \\'2\\'), POW(1, 1), POWER(1, 1), RAND(), REPLACE(\\'1\\', \\'1\\', \\'2\\'), REVERSE(\\'123\\'), ROUND(1), SIN(1), SQRT(1), STDDEV_POP(1), STDDEV_SAMP(1), SUBSTR(\\'123\\', 2), SUBSTRING(\\'123\\', 2), SUM(1), TAN(1), TANH(1), TRUNC(1), TRUNCATE(1), UCASE(\\'A\\'), UPPER(\\'A\\'), USER(), VAR_POP(1), VAR_SAMP(1), WEEK(toDate(\\'2020-10-24\\')), YEARWEEK(toDate(\\'2020-10-24\\')) format TSVRaw;');\n+SELECT normalizedQueryHash(formatQuery('select 1')) = normalizedQueryHash(formatQuery('SELECT 1'));\n+SELECT formatQuery('SEECTwrong'); -- { serverError SYNTAX_ERROR }\n+SELECT 'formatQuerySingleLine';\n+SELECT formatQuerySingleLine('select 1;');\n+SELECT formatQuerySingleLine('select 1');\n+SELECT formatQuerySingleLine('SELECT 1;');\n+SELECT formatQuerySingleLine('SELECT 1');\n+SELECT formatQuerySingleLine('select 1;') == formatQuerySingleLine('SeLecT 1');\n+SELECT formatQuerySingleLine('INSERT INTO tab VALUES (\\'\\') (\\'test\\')');\n+SELECT formatQuerySingleLine('CREATE TABLE default.no_prop_table(`some_column` UInt64) ENGINE = MergeTree ORDER BY tuple() SETTINGS index_granularity = 8192');\n+SELECT formatQuerySingleLine('EXPLAIN SYNTAX SELECT CAST(1 AS INT), CEIL(1), CEILING(1), CHAR(49), CHAR_LENGTH(\\'1\\'), CHARACTER_LENGTH(\\'1\\'), COALESCE(1), CONCAT(\\'1\\', \\'1\\'), CORR(1, 1), COS(1), COUNT(1), COVAR_POP(1, 1), COVAR_SAMP(1, 1), DATABASE(), SCHEMA(), DATEDIFF(\\'DAY\\', toDate(\\'2020-10-24\\'), toDate(\\'2019-10-24\\')), EXP(1), FLATTEN([[1]]), FLOOR(1), FQDN(), GREATEST(1), IF(1, 1, 1), IFNULL(1, 1), LCASE(\\'A\\'), LEAST(1), LENGTH(\\'1\\'), LN(1), LOCATE(\\'1\\', \\'1\\'), LOG(1), LOG10(1), LOG2(1), LOWER(\\'A\\'), MAX(1), MID(\\'123\\', 1, 1), MIN(1), MOD(1, 1), NOT(1), NOW(), NOW64(), NULLIF(1, 1), PI(), POSITION(\\'123\\', \\'2\\'), POW(1, 1), POWER(1, 1), RAND(), REPLACE(\\'1\\', \\'1\\', \\'2\\'), REVERSE(\\'123\\'), ROUND(1), SIN(1), SQRT(1), STDDEV_POP(1), STDDEV_SAMP(1), SUBSTR(\\'123\\', 2), SUBSTRING(\\'123\\', 2), SUM(1), TAN(1), TANH(1), TRUNC(1), TRUNCATE(1), UCASE(\\'A\\'), UPPER(\\'A\\'), USER(), VAR_POP(1), VAR_SAMP(1), WEEK(toDate(\\'2020-10-24\\')), YEARWEEK(toDate(\\'2020-10-24\\')) format TSVRaw;');\n+SELECT normalizedQueryHash(formatQuerySingleLine('select 1')) = normalizedQueryHash(formatQuerySingleLine('SELECT 1'));\n+SELECT formatQuerySingleLine('SEECTwrong'); -- { serverError SYNTAX_ERROR }\n",
  "problem_statement": "Compare queries with normalized formatting\n**Use case**\r\nI want to compare two queries with same semantics, but different format.\r\n\r\n**Describe the solution you'd like**\r\nFunction to normalize query format (like in `SHOW CREATE` statement) or get query hash after re-formatting.\r\nOr function to compare two queries.\r\n\r\n**Describe alternatives you've considered**\r\n`normalizeQuery` and `normalizedQueryHash`, but they don't \"fix\" formatting and can't be used to compare two queries with same semantics, but different formatting:\r\n```\r\nSELECT normalizedQueryHash('select 1') = normalizedQueryHash('SELECT 1')\r\n\r\n\u250c\u2500equals(normalizedQueryHash('select 1'), normalizedQueryHash('SELECT 1'))\u2500\u2510\r\n\u2502                                                                        0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "It will also help remove trailing semicolons.",
  "created_at": "2023-10-04T14:21:13Z"
}