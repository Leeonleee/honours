{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33516,
  "instance_id": "ClickHouse__ClickHouse-33516",
  "issue_numbers": [
    "23821"
  ],
  "base_commit": "f9d73479d08f65dcccd001da6e41aee427c9f5d1",
  "patch": "diff --git a/src/Common/IntervalTree.h b/src/Common/IntervalTree.h\nnew file mode 100644\nindex 000000000000..fd2fec528a46\n--- /dev/null\n+++ b/src/Common/IntervalTree.h\n@@ -0,0 +1,683 @@\n+#pragma once\n+\n+#include <base/defines.h>\n+\n+#include <vector>\n+#include <utility>\n+\n+\n+namespace DB\n+{\n+\n+/** Structure that holds closed interval with left and right.\n+  * Example: [1, 1] is valid interval, that contain point 1.\n+  */\n+template <typename TIntervalStorageType>\n+struct Interval\n+{\n+    using IntervalStorageType = TIntervalStorageType;\n+    IntervalStorageType left;\n+    IntervalStorageType right;\n+\n+    Interval(IntervalStorageType left_, IntervalStorageType right_) : left(left_), right(right_) { }\n+\n+    inline bool contains(IntervalStorageType point) const { return left <= point && point <= right; }\n+};\n+\n+template <typename IntervalStorageType>\n+bool operator<(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) < std::tie(rhs.left, rhs.right);\n+}\n+\n+template <typename IntervalStorageType>\n+bool operator<=(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) <= std::tie(rhs.left, rhs.right);\n+}\n+\n+template <typename IntervalStorageType>\n+bool operator==(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) == std::tie(rhs.left, rhs.right);\n+}\n+\n+template <typename IntervalStorageType>\n+bool operator!=(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) != std::tie(rhs.left, rhs.right);\n+}\n+\n+template <typename IntervalStorageType>\n+bool operator>(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) > std::tie(rhs.left, rhs.right);\n+}\n+\n+template <typename IntervalStorageType>\n+bool operator>=(const Interval<IntervalStorageType> & lhs, const Interval<IntervalStorageType> & rhs)\n+{\n+    return std::tie(lhs.left, lhs.right) >= std::tie(rhs.left, rhs.right);\n+}\n+\n+struct IntervalTreeVoidValue\n+{\n+};\n+\n+/** Tree structure that allow to efficiently retrieve all intervals that intersect specific point.\n+  * https://en.wikipedia.org/wiki/Interval_tree\n+  *\n+  * Search for all intervals intersecting point has complexity O(log(n) + k), k is count of intervals that intersect point.\n+  * If we need to only check if there are some interval intersecting point such operation has complexity O(log(n)).\n+  *\n+  * Explanation:\n+  *\n+  * IntervalTree structure is balanced tree. Each node contains:\n+  * 1. Point\n+  * 2. Intervals sorted by left ascending that intersect that point.\n+  * 3. Intervals sorted by right descending that intersect that point.\n+  *\n+  * Build:\n+  *\n+  * To keep tree relatively balanced we can use median of all segment points.\n+  * On each step build tree node with intervals. For root node input intervals are all intervals.\n+  * First split intervals in 4 groups.\n+  * 1. Intervals that lie that are less than median point. Interval right is less than median point.\n+  * 2. Intervals that lie that are greater than median point. Interval right is less than median point.\n+  * 3. Intervals that intersect node sorted by left ascending.\n+  * 4. Intervals that intersect node sorted by right descending.\n+  *\n+  * If intervals in 1 group are not empty. Continue build left child recursively with intervals from 1 group.\n+  * If intervals in 2 group are not empty. Continue build right child recursively with intervals from 2 group.\n+  *\n+  * Search:\n+  *\n+  * Search for intervals intersecting point is started from root node.\n+  * If search point is less than point in node, then we check intervals sorted by left ascending\n+  * until left is greater than search point.\n+  * If there is left child, continue search recursively in left child.\n+  *\n+  * If search point is greater than point in node, then we check intervals sorted by right descending\n+  * until right is less than search point.\n+  * If there is right child, continue search recursively in right child.\n+  *\n+  * If search point is equal to point in node, then we can emit all intervals that intersect current tree node\n+  * and stop searching.\n+  *\n+  * Additional details:\n+  * 1. To improve cache locality tree is stored implicitly in array, after build method is called\n+  * other intervals cannot be added to the tree.\n+  * 2. Additionally to improve cache locality in tree node we store sorted intervals for all nodes in separate\n+  * array. In node we store only start of its sorted intervals, and also size of intersecting intervals.\n+  * If we need to retrieve intervals sorted by left ascending they will be stored in indexes\n+  * [sorted_intervals_start_index, sorted_intervals_start_index + intersecting_intervals_size).\n+  * If we need to retrieve intervals sorted by right descending they will be store in indexes\n+  * [sorted_intervals_start_index + intersecting_intervals_size, sorted_intervals_start_index + intersecting_intervals_size * 2).\n+  */\n+template <typename Interval, typename Value>\n+class IntervalTree\n+{\n+public:\n+    using IntervalStorageType = typename Interval::IntervalStorageType;\n+\n+    static constexpr bool is_empty_value = std::is_same_v<Value, IntervalTreeVoidValue>;\n+\n+    IntervalTree() { nodes.resize(1); }\n+\n+    template <typename TValue = Value, std::enable_if_t<std::is_same_v<TValue, IntervalTreeVoidValue>, bool> = true>\n+    void emplace(Interval interval)\n+    {\n+        assert(!tree_is_built);\n+        sorted_intervals.emplace_back(interval);\n+        increaseIntervalsSize();\n+    }\n+\n+    template <typename TValue = Value, std::enable_if_t<!std::is_same_v<TValue, IntervalTreeVoidValue>, bool> = true, typename... Args>\n+    void emplace(Interval interval, Args &&... args)\n+    {\n+        assert(!tree_is_built);\n+        sorted_intervals.emplace_back(\n+            std::piecewise_construct, std::forward_as_tuple(interval), std::forward_as_tuple(std::forward<Args>(args)...));\n+        increaseIntervalsSize();\n+    }\n+\n+    template <typename TValue = Value, std::enable_if_t<std::is_same_v<TValue, IntervalTreeVoidValue>, bool> = true>\n+    void insert(Interval interval)\n+    {\n+        assert(!tree_is_built);\n+        sorted_intervals.emplace_back(interval);\n+        increaseIntervalsSize();\n+    }\n+\n+    template <typename TValue = Value, std::enable_if_t<!std::is_same_v<TValue, IntervalTreeVoidValue>, bool> = true>\n+    void insert(Interval interval, const Value & value)\n+    {\n+        assert(!tree_is_built);\n+        sorted_intervals.emplace_back(interval, value);\n+        increaseIntervalsSize();\n+    }\n+\n+    template <typename TValue = Value, std::enable_if_t<!std::is_same_v<TValue, IntervalTreeVoidValue>, bool> = true>\n+    void insert(Interval interval, Value && value)\n+    {\n+        assert(!tree_is_built);\n+        sorted_intervals.emplace_back(interval, std::move(value));\n+        increaseIntervalsSize();\n+    }\n+\n+    /// Build tree, after that intervals cannot be inserted, and only search or iteration can be performed.\n+    void build()\n+    {\n+        assert(!tree_is_built);\n+        nodes.clear();\n+        nodes.reserve(sorted_intervals.size());\n+        buildTree();\n+        tree_is_built = true;\n+    }\n+\n+    /** Find all intervals intersecting point.\n+      *\n+      * Callback interface for IntervalSet:\n+      *\n+      * template <typename IntervalType>\n+      * struct IntervalSetCallback\n+      * {\n+      *     bool operator()(const IntervalType & interval)\n+      *     {\n+      *         bool should_continue_interval_iteration = false;\n+      *         return should_continue_interval_iteration;\n+      *     }\n+      * };\n+      *\n+      * Callback interface for IntervalMap:\n+      *\n+      * template <typename IntervalType, typename Value>\n+      * struct IntervalMapCallback\n+      * {\n+      *     bool operator()(const IntervalType & interval, const Value & value)\n+      *     {\n+      *         bool should_continue_interval_iteration = false;\n+      *         return should_continue_interval_iteration;\n+      *     }\n+      * };\n+      */\n+\n+    template <typename IntervalCallback>\n+    void find(IntervalStorageType point, IntervalCallback && callback) const\n+    {\n+        if (unlikely(!tree_is_built))\n+        {\n+            findIntervalsNonConstructedImpl(point, callback);\n+            return;\n+        }\n+\n+        findIntervalsImpl(point, callback);\n+    }\n+\n+    /// Check if there is an interval intersecting point\n+    bool has(IntervalStorageType point) const\n+    {\n+        bool has_intervals = false;\n+\n+        if constexpr (is_empty_value)\n+        {\n+            find(point, [&](auto &)\n+            {\n+                has_intervals = true;\n+                return false;\n+            });\n+        }\n+        else\n+        {\n+            find(point, [&](auto &, auto &)\n+            {\n+                has_intervals = true;\n+                return false;\n+            });\n+        }\n+\n+        return has_intervals;\n+    }\n+\n+    class Iterator;\n+    using iterator = Iterator;\n+    using const_iterator = Iterator;\n+\n+    iterator begin()\n+    {\n+        size_t start_index = findFirstIteratorNodeIndex();\n+        return Iterator(start_index, 0, this);\n+    }\n+\n+    iterator end()\n+    {\n+        size_t end_index = findLastIteratorNodeIndex();\n+        size_t last_interval_index = 0;\n+\n+        if (likely(end_index < nodes.size()))\n+            last_interval_index = nodes[end_index].sorted_intervals_range_size;\n+\n+        return Iterator(end_index, last_interval_index, this);\n+    }\n+\n+    const_iterator begin() const\n+    {\n+        size_t start_index = findFirstIteratorNodeIndex();\n+        return Iterator(start_index, 0, this);\n+    }\n+\n+    const_iterator end() const\n+    {\n+        size_t end_index = findLastIteratorNodeIndex();\n+        size_t last_interval_index = 0;\n+\n+        if (likely(end_index < nodes.size()))\n+            last_interval_index = nodes[end_index].sorted_intervals_range_size;\n+\n+        return Iterator(end_index, last_interval_index, this);\n+    }\n+\n+    const_iterator cbegin() const { return begin(); }\n+\n+    const_iterator cend() const { return end(); }\n+\n+    size_t getIntervalsSize() const { return intervals_size; }\n+\n+private:\n+    struct Node\n+    {\n+        size_t sorted_intervals_range_start_index;\n+        size_t sorted_intervals_range_size;\n+\n+        IntervalStorageType middle_element;\n+\n+        inline bool hasValue() const { return sorted_intervals_range_size != 0; }\n+    };\n+\n+    using IntervalWithEmptyValue = Interval;\n+    using IntervalWithNonEmptyValue = std::pair<Interval, Value>;\n+\n+    using IntervalWithValue = std::conditional_t<is_empty_value, IntervalWithEmptyValue, IntervalWithNonEmptyValue>;\n+\n+public:\n+    class Iterator\n+    {\n+    public:\n+        bool operator==(const Iterator & rhs) const\n+        {\n+            return node_index == rhs.node_index && current_interval_index == rhs.current_interval_index && tree == rhs.tree;\n+        }\n+\n+        bool operator!=(const Iterator & rhs) const { return !(*this == rhs); }\n+\n+        const IntervalWithValue & operator*() { return getCurrentValue(); }\n+\n+        const IntervalWithValue & operator*() const { return getCurrentValue(); }\n+\n+        const IntervalWithValue * operator->() { return &getCurrentValue(); }\n+\n+        const IntervalWithValue * operator->() const { return &getCurrentValue(); }\n+\n+        Iterator & operator++()\n+        {\n+            iterateToNext();\n+            return *this;\n+        }\n+\n+        Iterator operator++(int) // NOLINT\n+        {\n+            Iterator copy(*this);\n+            iterateToNext();\n+            return copy;\n+        }\n+\n+        Iterator & operator--()\n+        {\n+            iterateToPrevious();\n+            return *this;\n+        }\n+\n+        Iterator operator--(int) // NOLINT\n+        {\n+            Iterator copy(*this);\n+            iterateToPrevious();\n+            return copy;\n+        }\n+\n+    private:\n+        friend class IntervalTree;\n+\n+        Iterator(size_t node_index_, size_t current_interval_index_, const IntervalTree * tree_)\n+            : node_index(node_index_), current_interval_index(current_interval_index_), tree(tree_)\n+        {\n+        }\n+\n+        size_t node_index;\n+        size_t current_interval_index;\n+        const IntervalTree * tree;\n+\n+        void iterateToNext()\n+        {\n+            size_t nodes_size = tree->nodes.size();\n+            auto & current_node = tree->nodes[node_index];\n+\n+            ++current_interval_index;\n+\n+            if (current_interval_index < current_node.sorted_intervals_range_size)\n+                return;\n+\n+            size_t node_index_copy = node_index + 1;\n+            for (; node_index_copy < nodes_size; ++node_index_copy)\n+            {\n+                auto & node = tree->nodes[node_index_copy];\n+\n+                if (node.hasValue())\n+                {\n+                    node_index = node_index_copy;\n+                    current_interval_index = 0;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        void iterateToPrevious()\n+        {\n+            if (current_interval_index > 0)\n+            {\n+                --current_interval_index;\n+                return;\n+            }\n+\n+            while (node_index > 0)\n+            {\n+                auto & node = tree->nodes[node_index - 1];\n+                if (node.hasValue())\n+                {\n+                    current_interval_index = node.sorted_intervals_range_size - 1;\n+                    break;\n+                }\n+\n+                --node_index;\n+            }\n+        }\n+\n+        const IntervalWithValue & getCurrentValue() const\n+        {\n+            auto & current_node = tree->nodes[node_index];\n+            size_t interval_index = current_node.sorted_intervals_range_start_index + current_interval_index;\n+            return tree->sorted_intervals[interval_index];\n+        }\n+    };\n+\n+private:\n+    void buildTree()\n+    {\n+        std::vector<IntervalStorageType> temporary_points_storage;\n+        temporary_points_storage.reserve(sorted_intervals.size() * 2);\n+\n+        std::vector<IntervalWithValue> left_intervals;\n+        std::vector<IntervalWithValue> right_intervals;\n+        std::vector<IntervalWithValue> intervals_sorted_by_left_asc;\n+        std::vector<IntervalWithValue> intervals_sorted_by_right_desc;\n+\n+        struct StackFrame\n+        {\n+            size_t index;\n+            std::vector<IntervalWithValue> intervals;\n+        };\n+\n+        std::vector<StackFrame> stack;\n+        stack.emplace_back(StackFrame{0, std::move(sorted_intervals)});\n+        sorted_intervals.clear();\n+\n+        while (!stack.empty())\n+        {\n+            auto frame = std::move(stack.back());\n+            stack.pop_back();\n+\n+            size_t current_index = frame.index;\n+            auto & current_intervals = frame.intervals;\n+\n+            if (current_intervals.empty())\n+                continue;\n+\n+            if (current_index >= nodes.size())\n+                nodes.resize(current_index + 1);\n+\n+            temporary_points_storage.clear();\n+            intervalsToPoints(current_intervals, temporary_points_storage);\n+            auto median = pointsMedian(temporary_points_storage);\n+\n+            left_intervals.clear();\n+            right_intervals.clear();\n+            intervals_sorted_by_left_asc.clear();\n+            intervals_sorted_by_right_desc.clear();\n+\n+            for (const auto & interval_with_value : current_intervals)\n+            {\n+                auto & interval = getInterval(interval_with_value);\n+\n+                if (interval.right < median)\n+                {\n+                    left_intervals.emplace_back(interval_with_value);\n+                }\n+                else if (interval.left > median)\n+                {\n+                    right_intervals.emplace_back(interval_with_value);\n+                }\n+                else\n+                {\n+                    intervals_sorted_by_left_asc.emplace_back(interval_with_value);\n+                    intervals_sorted_by_right_desc.emplace_back(interval_with_value);\n+                }\n+            }\n+\n+            std::sort(intervals_sorted_by_left_asc.begin(), intervals_sorted_by_left_asc.end(), [](auto & lhs, auto & rhs)\n+            {\n+                auto & lhs_interval = getInterval(lhs);\n+                auto & rhs_interval = getInterval(rhs);\n+                return lhs_interval.left < rhs_interval.left;\n+            });\n+\n+            std::sort(intervals_sorted_by_right_desc.begin(), intervals_sorted_by_right_desc.end(), [](auto & lhs, auto & rhs)\n+            {\n+                auto & lhs_interval = getInterval(lhs);\n+                auto & rhs_interval = getInterval(rhs);\n+                return lhs_interval.right > rhs_interval.right;\n+            });\n+\n+            size_t sorted_intervals_range_start_index = sorted_intervals.size();\n+\n+            for (auto && interval_sorted_by_left_asc : intervals_sorted_by_left_asc)\n+                sorted_intervals.emplace_back(std::move(interval_sorted_by_left_asc));\n+\n+            for (auto && interval_sorted_by_right_desc : intervals_sorted_by_right_desc)\n+                sorted_intervals.emplace_back(std::move(interval_sorted_by_right_desc));\n+\n+            auto & node = nodes[current_index];\n+            node.middle_element = median;\n+            node.sorted_intervals_range_start_index = sorted_intervals_range_start_index;\n+            node.sorted_intervals_range_size = intervals_sorted_by_left_asc.size();\n+\n+            size_t left_child_index = current_index * 2 + 1;\n+            stack.emplace_back(StackFrame{left_child_index, std::move(left_intervals)});\n+\n+            size_t right_child_index = current_index * 2 + 2;\n+            stack.emplace_back(StackFrame{right_child_index, std::move(right_intervals)});\n+        }\n+    }\n+\n+    template <typename IntervalCallback>\n+    void findIntervalsImpl(IntervalStorageType point, IntervalCallback && callback) const\n+    {\n+        size_t current_index = 0;\n+\n+        while (true)\n+        {\n+            if (current_index >= nodes.size())\n+                break;\n+\n+            auto & node = nodes[current_index];\n+            if (!node.hasValue())\n+                break;\n+\n+            auto middle_element = node.middle_element;\n+\n+            if (point < middle_element)\n+            {\n+                size_t start = node.sorted_intervals_range_start_index;\n+                size_t end = start + node.sorted_intervals_range_size;\n+\n+                for (; start != end; ++start)\n+                {\n+                    auto & interval_with_value_left_sorted_asc = sorted_intervals[start];\n+                    auto & interval_left_sorted_asc = getInterval(interval_with_value_left_sorted_asc);\n+                    if (interval_left_sorted_asc.left > point)\n+                        break;\n+\n+                    bool should_continue = callCallback(interval_with_value_left_sorted_asc, callback);\n+                    if (unlikely(!should_continue))\n+                        return;\n+                }\n+\n+                size_t left_child_index = current_index * 2 + 1;\n+                current_index = left_child_index;\n+            }\n+            else\n+            {\n+                size_t start = node.sorted_intervals_range_start_index + node.sorted_intervals_range_size;\n+                size_t end = start + node.sorted_intervals_range_size;\n+\n+                for (; start != end; ++start)\n+                {\n+                    auto & interval_with_value_right_sorted_desc = sorted_intervals[start];\n+                    auto & interval_right_sorted_desc = getInterval(interval_with_value_right_sorted_desc);\n+                    if (interval_right_sorted_desc.right < point)\n+                        break;\n+\n+                    bool should_continue = callCallback(interval_with_value_right_sorted_desc, callback);\n+                    if (unlikely(!should_continue))\n+                        return;\n+                }\n+\n+                if (likely(point > middle_element))\n+                {\n+                    size_t right_child_index = current_index * 2 + 2;\n+                    current_index = right_child_index;\n+                }\n+                else\n+                {\n+                    /// This is case when point == middle_element.\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename IntervalCallback>\n+    void findIntervalsNonConstructedImpl(IntervalStorageType point, IntervalCallback && callback) const\n+    {\n+        for (auto & interval_with_value : sorted_intervals)\n+        {\n+            auto & interval = getInterval(interval_with_value);\n+\n+            if (interval.contains(point))\n+                callCallback(interval_with_value, callback);\n+        }\n+    }\n+\n+    inline size_t findFirstIteratorNodeIndex() const\n+    {\n+        size_t nodes_size = nodes.size();\n+        size_t result_index = 0;\n+\n+        for (; result_index < nodes_size; ++result_index)\n+        {\n+            if (nodes[result_index].hasValue())\n+                break;\n+        }\n+\n+        if (unlikely(result_index == nodes_size))\n+            result_index = 0;\n+\n+        return result_index;\n+    }\n+\n+    inline size_t findLastIteratorNodeIndex() const\n+    {\n+        if (unlikely(nodes.empty()))\n+            return 0;\n+\n+        size_t nodes_size = nodes.size();\n+        size_t result_index = nodes_size - 1;\n+        for (; result_index != 0; --result_index)\n+        {\n+            if (nodes[result_index].hasValue())\n+                break;\n+        }\n+\n+        return result_index;\n+    }\n+\n+    inline void increaseIntervalsSize()\n+    {\n+        /// Before tree is build we store all intervals size in our first node to allow tree iteration.\n+        ++intervals_size;\n+        nodes[0].sorted_intervals_range_size = intervals_size;\n+    }\n+\n+    std::vector<Node> nodes;\n+    std::vector<IntervalWithValue> sorted_intervals;\n+    size_t intervals_size = 0;\n+    bool tree_is_built = false;\n+\n+    static inline const Interval & getInterval(const IntervalWithValue & interval_with_value)\n+    {\n+        if constexpr (is_empty_value)\n+            return interval_with_value;\n+        else\n+            return interval_with_value.first;\n+    }\n+\n+    template <typename IntervalCallback>\n+    static inline bool callCallback(const IntervalWithValue & interval, IntervalCallback && callback)\n+    {\n+        if constexpr (is_empty_value)\n+            return callback(interval);\n+        else\n+            return callback(interval.first, interval.second);\n+    }\n+\n+    static inline void\n+    intervalsToPoints(const std::vector<IntervalWithValue> & intervals, std::vector<IntervalStorageType> & temporary_points_storage)\n+    {\n+        for (const auto & interval_with_value : intervals)\n+        {\n+            auto & interval = getInterval(interval_with_value);\n+            temporary_points_storage.emplace_back(interval.left);\n+            temporary_points_storage.emplace_back(interval.right);\n+        }\n+    }\n+\n+    static inline IntervalStorageType pointsMedian(std::vector<IntervalStorageType> & points)\n+    {\n+        size_t size = points.size();\n+        size_t middle_element_index = size / 2;\n+\n+        std::nth_element(points.begin(), points.begin() + middle_element_index, points.end());\n+\n+        /** We should not get median as average of middle_element_index and middle_element_index - 1\n+          * because we want point in node to intersect some interval.\n+          * Example: Intervals [1, 1], [3, 3]. If we choose 2 as average point, it does not intersect any interval.\n+          */\n+        return points[middle_element_index];\n+    }\n+};\n+\n+template <typename IntervalType>\n+using IntervalSet = IntervalTree<IntervalType, IntervalTreeVoidValue>;\n+\n+template <typename IntervalType, typename Value>\n+using IntervalMap = IntervalTree<IntervalType, Value>;\n+\n+}\ndiff --git a/src/Common/examples/CMakeLists.txt b/src/Common/examples/CMakeLists.txt\nindex be91101ef40b..7b21591f83e9 100644\n--- a/src/Common/examples/CMakeLists.txt\n+++ b/src/Common/examples/CMakeLists.txt\n@@ -83,3 +83,6 @@ target_link_libraries (executable_udf PRIVATE dbms)\n \n add_executable(hive_metastore_client hive_metastore_client.cpp)\n target_link_libraries (hive_metastore_client PUBLIC hivemetastore ${THRIFT_LIBRARY})\n+\n+add_executable (interval_tree interval_tree.cpp)\n+target_link_libraries (interval_tree PRIVATE dbms)\ndiff --git a/src/Common/examples/interval_tree.cpp b/src/Common/examples/interval_tree.cpp\nnew file mode 100644\nindex 000000000000..086fab37bbe8\n--- /dev/null\n+++ b/src/Common/examples/interval_tree.cpp\n@@ -0,0 +1,95 @@\n+#include <iomanip>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <set>\n+#include <vector>\n+\n+#include <Common/randomSeed.h>\n+#include <Common/Stopwatch.h>\n+#include <Common/IntervalTree.h>\n+\n+using namespace DB;\n+using Int64Interval = Interval<Int64>;\n+\n+int main(int, char **)\n+{\n+    {\n+        IntervalSet<Int64Interval> tree;\n+\n+        tree.emplace(Int64Interval(0, 5));\n+        tree.emplace(Int64Interval(10, 15));\n+\n+        tree.build();\n+\n+        for (const auto & interval : tree)\n+        {\n+            std::cout << \"Interval left \" << interval.left << \" right \" << interval.right << std::endl;\n+        }\n+    }\n+    {\n+        IntervalMap<Int64Interval, std::string> tree;\n+\n+        tree.emplace(Int64Interval(0, 5), \"value1\");\n+        tree.emplace(Int64Interval(10, 15), \"value2\");\n+\n+        tree.build();\n+\n+        for (const auto & [interval, value] : tree)\n+        {\n+            std::cout << \"Interval left \" << interval.left << \" right \" << interval.right;\n+            std::cout << \" value \" << value << std::endl;\n+        }\n+    }\n+    {\n+        IntervalSet<Int64Interval> tree;\n+        for (size_t i = 0; i < 5; ++i)\n+        {\n+            tree.emplace(Int64Interval(0, i));\n+        }\n+\n+        tree.build();\n+\n+        for (const auto & interval : tree)\n+        {\n+            std::cout << \"Interval left \" << interval.left << \" right \" << interval.right << std::endl;\n+        }\n+\n+        for (Int64 i = 0; i < 5; ++i)\n+        {\n+            tree.find(i, [](auto & interval)\n+            {\n+                std::cout << \"Interval left \" << interval.left << \" right \" << interval.right << std::endl;\n+                return true;\n+            });\n+        }\n+    }\n+    {\n+        IntervalMap<Int64Interval, std::string> tree;\n+        for (size_t i = 0; i < 5; ++i)\n+        {\n+            tree.emplace(Int64Interval(0, i), \"Value \" + std::to_string(i));\n+        }\n+\n+        tree.build();\n+\n+        for (const auto & [interval, value] : tree)\n+        {\n+            std::cout << \"Interval left \" << interval.left << \" right \" << interval.right;\n+            std::cout << \" value \" << value << std::endl;\n+        }\n+\n+        for (Int64 i = 0; i < 5; ++i)\n+        {\n+            tree.find(i, [](auto & interval, auto & value)\n+            {\n+                std::cout << \"Interval left \" << interval.left << \" right \" << interval.right;\n+                std::cout << \" value \" << value << std::endl;\n+\n+                return true;\n+            });\n+        }\n+    }\n+\n+    return 0;\n+}\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex 9dcc38dc4b2e..f6cdd5679d8b 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -22,6 +22,11 @@ using RangeStorageType = DB::RangeStorageType;\n const RangeStorageType RANGE_MIN_NULL_VALUE = std::numeric_limits<RangeStorageType>::max();\n const RangeStorageType RANGE_MAX_NULL_VALUE = std::numeric_limits<RangeStorageType>::lowest();\n \n+bool isCorrectDate(const RangeStorageType & date)\n+{\n+    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;\n+}\n+\n // Handle both kinds of null values: explicit nulls of NullableColumn and 'implicit' nulls of Date type.\n RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t index, bool isDate, const RangeStorageType & default_value)\n {\n@@ -29,7 +34,7 @@ RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t i\n         return default_value;\n \n     const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));\n-    if (isDate && !DB::Range::isCorrectDate(result))\n+    if (isDate && !isCorrectDate(result))\n         return default_value;\n \n     return result;\n@@ -57,20 +62,6 @@ namespace ErrorCodes\n     extern const int UNSUPPORTED_METHOD;\n }\n \n-bool Range::isCorrectDate(const RangeStorageType & date)\n-{\n-    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;\n-}\n-\n-bool Range::contains(const RangeStorageType & value) const\n-{\n-    return left <= value && value <= right;\n-}\n-\n-static bool operator<(const Range & left, const Range & right)\n-{\n-    return std::tie(left.left, left.right) < std::tie(right.left, right.right);\n-}\n \n template <DictionaryKeyType dictionary_key_type>\n RangeHashedDictionary<dictionary_key_type>::RangeHashedDictionary(\n@@ -260,16 +251,8 @@ ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Colum\n             if (it)\n             {\n                 const auto date = dates[key_index];\n-                const auto & ranges_and_values = it->getMapped();\n-                const auto val_it = std::find_if(\n-                    std::begin(ranges_and_values),\n-                    std::end(ranges_and_values),\n-                    [date](const Value<ValueType> & v)\n-                    {\n-                        return v.range.contains(date);\n-                    });\n-\n-                out[key_index] = val_it != std::end(ranges_and_values);\n+                const auto & interval_tree = it->getMapped();\n+                out[key_index] = interval_tree.has(date);\n                 keys_found += out[key_index];\n             }\n             else\n@@ -324,6 +307,8 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()\n         updateData();\n     }\n \n+    buildAttributeIntervalTrees();\n+\n     if (require_nonempty && 0 == element_count)\n         throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY,\n             \"{}: dictionary source is empty and 'require_nonempty' property is set.\");\n@@ -407,30 +392,40 @@ void RangeHashedDictionary<dictionary_key_type>::getItemsImpl(\n         if (it)\n         {\n             const auto date = dates[key_index];\n-            const auto & ranges_and_values = it->getMapped();\n-            const auto val_it = std::find_if(\n-                std::begin(ranges_and_values),\n-                std::end(ranges_and_values),\n-                [date](const Value<AttributeType> & v)\n-                {\n-                    return v.range.contains(date);\n-                });\n+            const auto & interval_tree = it->getMapped();\n+\n+            std::optional<AttributeType> min_value;\n+            std::optional<RangeInterval> min_range;\n+            bool has_interval = false;\n+\n+            interval_tree.find(date, [&](auto & interval, auto & value)\n+            {\n+                has_interval = true;\n+\n+                if (min_range && interval < *min_range)\n+                    min_range = interval;\n+                else\n+                    min_range = interval;\n \n-            if (val_it != std::end(ranges_and_values))\n+                min_value = value;\n+\n+                return true;\n+            });\n+\n+            if (has_interval)\n             {\n                 ++keys_found;\n-                auto & value = val_it->value;\n \n                 if constexpr (is_nullable)\n                 {\n-                    if (value.has_value())\n-                        set_value(key_index, *value, false);\n+                    if (min_value.has_value())\n+                        set_value(key_index, *min_value, false);\n                     else\n                         set_value(key_index, default_value_extractor[key_index], true);\n                 }\n                 else\n                 {\n-                    set_value(key_index, *value, false);\n+                    set_value(key_index, *min_value, false);\n                 }\n \n                 keys_extractor.rollbackCurrentKey();\n@@ -542,7 +537,7 @@ void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block &\n             if constexpr (std::is_same_v<KeyType, StringRef>)\n                 key = copyStringInArena(string_arena, key);\n \n-            setAttributeValue(attribute, key, Range{lower_bound, upper_bound}, attribute_column[key_index]);\n+            setAttributeValue(attribute, key, RangeInterval{lower_bound, upper_bound}, attribute_column[key_index]);\n             keys_extractor.rollbackCurrentKey();\n         }\n \n@@ -550,18 +545,38 @@ void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block &\n     }\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+void RangeHashedDictionary<dictionary_key_type>::buildAttributeIntervalTrees()\n+{\n+    for (auto & attribute : attributes)\n+    {\n+        auto type_call = [&](const auto & dictionary_attribute_type)\n+        {\n+            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+            using AttributeType = typename Type::AttributeType;\n+            using ValueType = DictionaryValueType<AttributeType>;\n+\n+            auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n+            for (auto & [_, ranges] : collection)\n+                ranges.build();\n+        };\n+\n+        callOnDictionaryAttributeType(attribute.type, type_call);\n+    }\n+}\n+\n template <DictionaryKeyType dictionary_key_type>\n template <typename T>\n-void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute & attribute, KeyType key, const Range & range, const Field & value)\n+void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)\n {\n     using ValueType = std::conditional_t<std::is_same_v<T, String>, StringRef, T>;\n     auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);\n \n-    Value<ValueType> value_to_insert;\n+    std::optional<ValueType> value_to_insert;\n \n     if (attribute.is_nullable && value.isNull())\n     {\n-        value_to_insert = { range, {} };\n+        value_to_insert = std::nullopt;\n     }\n     else\n     {\n@@ -569,11 +584,11 @@ void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute\n         {\n             const auto & string = value.get<String>();\n             StringRef string_ref = copyStringInArena(string_arena, string);\n-            value_to_insert = Value<ValueType>{ range, { string_ref }};\n+            value_to_insert = { string_ref };\n         }\n         else\n         {\n-            value_to_insert = Value<ValueType>{ range, { value.get<ValueType>() }};\n+            value_to_insert = { value.get<ValueType>() };\n         }\n     }\n \n@@ -582,33 +597,25 @@ void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute\n     if (it)\n     {\n         auto & values = it->getMapped();\n-\n-        const auto insert_it = std::lower_bound(\n-            std::begin(values),\n-            std::end(values),\n-            range,\n-            [](const Value<ValueType> & lhs, const Range & rhs_range)\n-            {\n-                return lhs.range < rhs_range;\n-            });\n-\n-        values.insert(insert_it, std::move(value_to_insert));\n+        values.emplace(interval, std::move(value_to_insert));\n     }\n     else\n     {\n-        collection.insert({key, Values<ValueType>{std::move(value_to_insert)}});\n+        Values<ValueType> values;\n+        values.emplace(interval, value_to_insert);\n+        collection.insert({key, std::move(values)});\n     }\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, KeyType key, const Range & range, const Field & value)\n+void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)\n {\n     auto type_call = [&](const auto &dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n \n-        setAttributeValueImpl<AttributeType>(attribute, key, range, value);\n+        setAttributeValueImpl<AttributeType>(attribute, key, interval, value);\n     };\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n@@ -650,14 +657,15 @@ void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(\n     end_dates.reserve(collection.size());\n \n     const bool is_date = isDate(dict_struct.range_min->type);\n+    (void)(is_date);\n \n     for (const auto & key : collection)\n     {\n-        for (const auto & value : key.getMapped())\n+        for (const auto & [interval, _] : key.getMapped())\n         {\n             keys.push_back(key.getKey());\n-            start_dates.push_back(value.range.left);\n-            end_dates.push_back(value.range.right);\n+            start_dates.push_back(interval.left);\n+            end_dates.push_back(interval.right);\n \n             if constexpr (std::numeric_limits<RangeType>::max() > DATE_LUT_MAX_DAY_NUM) /// Avoid warning about tautological comparison in next line.\n                 if (is_date && static_cast<UInt64>(end_dates.back()) > DATE_LUT_MAX_DAY_NUM)\n@@ -676,7 +684,7 @@ PaddedPODArray<Int64> RangeHashedDictionary<dictionary_key_type>::makeDateKeys(\n \n     for (size_t i = 0; i < keys.size(); ++i)\n     {\n-        if (Range::isCorrectDate(block_start_dates[i]))\n+        if (isCorrectDate(block_start_dates[i]))\n             keys[i] = block_start_dates[i]; // NOLINT\n         else\n             keys[i] = block_end_dates[i]; // NOLINT\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex a9b41a4c4d06..f31d6415dc80 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -8,26 +8,19 @@\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnString.h>\n #include <Common/HashTable/HashMap.h>\n-#include <Common/HashTable/HashSet.h>\n+#include <Common/IntervalTree.h>\n+\n #include <Dictionaries/DictionaryStructure.h>\n #include <Dictionaries/IDictionary.h>\n #include <Dictionaries/IDictionarySource.h>\n #include <Dictionaries/DictionaryHelpers.h>\n \n+\n namespace DB\n {\n \n using RangeStorageType = Int64;\n \n-struct Range\n-{\n-    RangeStorageType left;\n-    RangeStorageType right;\n-\n-    static bool isCorrectDate(const RangeStorageType & date);\n-    bool contains(const RangeStorageType & value) const;\n-};\n-\n template <DictionaryKeyType dictionary_key_type>\n class RangeHashedDictionary final : public IDictionary\n {\n@@ -94,15 +87,11 @@ class RangeHashedDictionary final : public IDictionary\n     Pipe read(const Names & column_names, size_t max_block_size, size_t num_streams) const override;\n \n private:\n-    template <typename T>\n-    struct Value final\n-    {\n-        Range range;\n-        std::optional<T> value;\n-    };\n+\n+    using RangeInterval = Interval<RangeStorageType>;\n \n     template <typename T>\n-    using Values = std::vector<Value<T>>;\n+    using Values = IntervalMap<RangeInterval, std::optional<T>>;\n \n     template <typename Value>\n     using CollectionType = std::conditional_t<\n@@ -160,10 +149,12 @@ class RangeHashedDictionary final : public IDictionary\n \n     void blockToAttributes(const Block & block);\n \n+    void buildAttributeIntervalTrees();\n+\n     template <typename T>\n-    void setAttributeValueImpl(Attribute & attribute, KeyType key, const Range & range, const Field & value);\n+    void setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);\n \n-    void setAttributeValue(Attribute & attribute, KeyType key, const Range & range, const Field & value);\n+    void setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);\n \n     template <typename RangeType>\n     void getKeysAndDates(\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_interval_tree.cpp b/src/Common/tests/gtest_interval_tree.cpp\nnew file mode 100644\nindex 000000000000..d9f19841b665\n--- /dev/null\n+++ b/src/Common/tests/gtest_interval_tree.cpp\n@@ -0,0 +1,540 @@\n+#include <gtest/gtest.h>\n+\n+#include <set>\n+#include <map>\n+\n+#include <base/types.h>\n+#include <Common/IntervalTree.h>\n+\n+\n+using namespace DB;\n+using Int64Interval = Interval<Int64>;\n+\n+template <typename IntervalType>\n+std::set<IntervalType> intervalSetToSet(const IntervalSet<IntervalType> & interval_set)\n+{\n+    std::set<IntervalType> result;\n+\n+    for (const auto & interval : interval_set)\n+        result.insert(interval);\n+\n+    return result;\n+}\n+\n+template <typename IntervalType, typename Value>\n+std::map<IntervalType, Value> intervalMapToMap(const IntervalMap<IntervalType, Value> & interval_map)\n+{\n+    std::map<IntervalType, Value> result;\n+\n+    for (const auto & [interval, value] : interval_map)\n+        result.emplace(interval, value);\n+\n+    return result;\n+}\n+\n+template <typename IntervalType>\n+struct CollectIntervalsSetCallback\n+{\n+    explicit CollectIntervalsSetCallback(std::set<IntervalType> & result_intervals_)\n+        : result_intervals(result_intervals_)\n+    {\n+    }\n+\n+    bool operator()(IntervalType interval)\n+    {\n+        result_intervals.insert(interval);\n+        return true;\n+    }\n+\n+    std::set<IntervalType> & result_intervals;\n+};\n+\n+using CollectIntervalsSetInt64Callback = CollectIntervalsSetCallback<Int64Interval>;\n+\n+template <typename IntervalType>\n+std::set<IntervalType> intervalSetFindIntervals(const IntervalSet<IntervalType> & interval_set, typename IntervalType::IntervalStorageType point)\n+{\n+    std::set<IntervalType> result;\n+    CollectIntervalsSetCallback<IntervalType> callback(result);\n+\n+    interval_set.find(point, callback);\n+\n+    return result;\n+}\n+\n+template <typename IntervalType, typename Value>\n+struct CollectIntervalsMapCallback\n+{\n+    explicit CollectIntervalsMapCallback(std::map<IntervalType, Value> & result_intervals_)\n+        : result_intervals(result_intervals_)\n+    {\n+    }\n+\n+    bool operator()(IntervalType interval, const Value & value)\n+    {\n+        result_intervals.emplace(interval, value);\n+        return true;\n+    }\n+\n+    std::map<IntervalType, Value> & result_intervals;\n+};\n+\n+\n+template <typename IntervalType, typename Value>\n+std::map<IntervalType, Value> intervalMapFindIntervals(const IntervalMap<IntervalType, Value> & interval_set, typename IntervalType::IntervalStorageType point)\n+{\n+    std::map<IntervalType, Value> result;\n+    CollectIntervalsMapCallback callback(result);\n+\n+    interval_set.find(point, callback);\n+\n+    return result;\n+}\n+\n+TEST(IntervalTree, IntervalSetBasic)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::set<Int64Interval> expected;\n+        IntervalSet<Int64Interval> set;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);\n+            expected.insert(interval);\n+            set.insert(interval);\n+        }\n+\n+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            std::set<Int64Interval> expected_intervals = {{expected_interval}};\n+\n+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalSetFindIntervals(set, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+\n+        set.build();\n+\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            auto actual_interval = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_interval.size() == 1);\n+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});\n+\n+            actual_interval = intervalSetFindIntervals(set, expected_interval.right);\n+            ASSERT_TRUE(actual_interval.size() == 1);\n+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalSetPoints)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::set<Int64Interval> expected;\n+        IntervalSet<Int64Interval> set;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(interval_index, interval_index);\n+            expected.insert(interval);\n+            set.insert(interval);\n+        }\n+\n+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            std::set<Int64Interval> expected_intervals = {{expected_interval}};\n+\n+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalSetFindIntervals(set, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+\n+        set.build();\n+\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            auto actual_interval = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_interval.size() == 1);\n+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});\n+\n+            actual_interval = intervalSetFindIntervals(set, expected_interval.right);\n+            ASSERT_TRUE(actual_interval.size() == 1);\n+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalSetIntersectingIntervals)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::set<Int64Interval> expected;\n+        IntervalSet<Int64Interval> set;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(0, interval_index * 2 + 1);\n+            expected.insert(interval);\n+            set.insert(interval);\n+        }\n+\n+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == expected.size());\n+            ASSERT_TRUE(actual_intervals == expected);\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+\n+        set.build();\n+\n+        ASSERT_TRUE(intervalSetToSet(set) == expected);\n+\n+        for (const auto & expected_interval : expected)\n+        {\n+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == expected.size());\n+            ASSERT_TRUE(actual_intervals == expected);\n+\n+            ASSERT_TRUE(set.has(expected_interval.left));\n+            ASSERT_TRUE(set.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalSetIterators)\n+{\n+    {\n+        IntervalSet<Int64Interval> set;\n+        ASSERT_TRUE(set.begin() == set.end());\n+        ASSERT_TRUE(set.cbegin() == set.cend());\n+        set.build();\n+        ASSERT_TRUE(set.begin() == set.end());\n+        ASSERT_TRUE(set.cbegin() == set.cend());\n+    }\n+    {\n+        IntervalSet<Int64Interval> set;\n+        set.emplace(Int64Interval(0, 5));\n+        ASSERT_TRUE(set.begin() != set.end());\n+        ASSERT_TRUE((*set.begin()).left == 0);\n+        ASSERT_TRUE((*set.begin()).right == 5);\n+        ASSERT_TRUE(set.begin()->left == 0);\n+        ASSERT_TRUE(set.begin()->right == 5);\n+        auto begin = set.begin();\n+        ++begin;\n+        ASSERT_TRUE(begin == set.end());\n+\n+        begin = set.begin();\n+        begin++;\n+        ASSERT_TRUE(begin == set.end());\n+\n+        auto end = set.end();\n+        --end;\n+        ASSERT_TRUE(set.begin() == end);\n+\n+        end = set.end();\n+        end--;\n+        ASSERT_TRUE(set.begin() == end);\n+    }\n+    {\n+        for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+        {\n+            std::set<Int64Interval> expected;\n+            IntervalSet<Int64Interval> set;\n+\n+            for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+            {\n+                auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);\n+                set.insert(interval);\n+                expected.insert(interval);\n+            }\n+\n+            auto end = set.end();\n+            auto begin = set.begin();\n+\n+            std::set<Int64Interval> actual;\n+\n+            while (end != begin)\n+            {\n+                --end;\n+                actual.insert(*end);\n+            }\n+\n+            if (end != begin)\n+                actual.insert(*end);\n+\n+            ASSERT_TRUE(actual == expected);\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalMapBasic)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::map<Int64Interval, std::string> expected;\n+        IntervalMap<Int64Interval, std::string> map;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);\n+            auto value = std::to_string(interval.left);\n+            expected.emplace(interval, value);\n+            map.emplace(interval, value);\n+        }\n+\n+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};\n+\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+\n+        map.build();\n+\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};\n+\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalMapPoints)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::map<Int64Interval, std::string> expected;\n+        IntervalMap<Int64Interval, std::string> map;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(interval_index, interval_index);\n+            auto value = std::to_string(interval.left);\n+            expected.emplace(interval, value);\n+            map.emplace(interval, value);\n+        }\n+\n+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};\n+\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+\n+        map.build();\n+\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};\n+\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);\n+            ASSERT_TRUE(actual_intervals.size() == 1);\n+            ASSERT_TRUE(actual_intervals == expected_intervals);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalMapIntersectingIntervals)\n+{\n+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+    {\n+        std::map<Int64Interval, std::string> expected;\n+        IntervalMap<Int64Interval, std::string> map;\n+\n+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+        {\n+            auto interval = Int64Interval(0, interval_index * 2 + 1);\n+            auto value = std::to_string(interval.left);\n+            expected.emplace(interval, value);\n+            map.emplace(interval, value);\n+        }\n+\n+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());\n+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+\n+            ASSERT_TRUE(actual_intervals.size() == expected.size());\n+            ASSERT_TRUE(actual_intervals == expected);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+\n+        map.build();\n+\n+        ASSERT_TRUE(intervalMapToMap(map) == expected);\n+\n+        for (const auto & [expected_interval, value] : expected)\n+        {\n+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);\n+\n+            ASSERT_TRUE(actual_intervals.size() == expected.size());\n+            ASSERT_TRUE(actual_intervals == expected);\n+\n+            ASSERT_TRUE(map.has(expected_interval.left));\n+            ASSERT_TRUE(map.has(expected_interval.right));\n+        }\n+    }\n+}\n+\n+TEST(IntervalTree, IntervalMapIterators)\n+{\n+    {\n+        IntervalMap<Int64Interval, std::string> map;\n+        ASSERT_TRUE(map.begin() == map.end());\n+        ASSERT_TRUE(map.cbegin() == map.cend());\n+        map.build();\n+        ASSERT_TRUE(map.begin() == map.end());\n+        ASSERT_TRUE(map.cbegin() == map.cend());\n+    }\n+    {\n+        IntervalMap<Int64Interval, std::string> map;\n+        map.emplace(Int64Interval(0, 5), \"value\");\n+        ASSERT_TRUE(map.begin() != map.end());\n+        ASSERT_TRUE((*map.begin()).first.left == 0);\n+        ASSERT_TRUE((*map.begin()).first.right == 5);\n+        ASSERT_TRUE((*map.begin()).second == \"value\");\n+        ASSERT_TRUE(map.begin()->first.left == 0);\n+        ASSERT_TRUE(map.begin()->first.right == 5);\n+        ASSERT_TRUE(map.begin()->second == \"value\");\n+        auto begin = map.begin();\n+        ++begin;\n+        ASSERT_TRUE(begin == map.end());\n+\n+        begin = map.begin();\n+        begin++;\n+        ASSERT_TRUE(begin == map.end());\n+\n+        auto end = map.end();\n+        --end;\n+        ASSERT_TRUE(map.begin() == end);\n+\n+        end = map.end();\n+        end--;\n+        ASSERT_TRUE(map.begin() == end);\n+    }\n+    {\n+        for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)\n+        {\n+            std::map<Int64Interval, std::string> expected;\n+            IntervalMap<Int64Interval, std::string> map;\n+\n+            for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)\n+            {\n+                auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);\n+                auto value = std::to_string(interval.left);\n+                map.emplace(interval, value);\n+                expected.emplace(interval, value);\n+            }\n+\n+            auto end = map.end();\n+            auto begin = map.begin();\n+\n+            std::map<Int64Interval, std::string> actual;\n+\n+            while (end != begin)\n+            {\n+                --end;\n+                actual.insert(*end);\n+            }\n+\n+            if (end != begin)\n+                actual.insert(*end);\n+\n+            ASSERT_TRUE(actual == expected);\n+        }\n+    }\n+}\ndiff --git a/tests/performance/range_hashed_dictionary.xml b/tests/performance/range_hashed_dictionary.xml\nnew file mode 100644\nindex 000000000000..bdf949cd1ff8\n--- /dev/null\n+++ b/tests/performance/range_hashed_dictionary.xml\n@@ -0,0 +1,126 @@\n+<test>\n+    <create_query>\n+        CREATE TABLE simple_key_range_hashed_dictionary_source_table\n+        (\n+            id UInt64,\n+            value UInt64,\n+            start UInt64,\n+            end UInt64\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE TABLE complex_key_range_hashed_dictionary_source_table\n+        (\n+            id UInt64,\n+            id_key String,\n+            value UInt64,\n+            start UInt64,\n+            end UInt64\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY simple_key_range_hashed_dictionary\n+        (\n+            id UInt64,\n+            value UInt64,\n+            start UInt64,\n+            end UInt64\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_range_hashed_dictionary_source_table'))\n+        LAYOUT(RANGE_HASHED())\n+        RANGE(MIN start MAX end)\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY complex_key_range_hashed_dictionary\n+        (\n+            id UInt64,\n+            id_key String,\n+            value UInt64,\n+            start UInt64,\n+            end UInt64\n+        )\n+        PRIMARY KEY id, id_key\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_key_range_hashed_dictionary_source_table'))\n+        LAYOUT(COMPLEX_KEY_RANGE_HASHED())\n+        RANGE(MIN start MAX end)\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO simple_key_range_hashed_dictionary_source_table\n+        SELECT key, key, range_start * 2, range_start * 2 + 1 FROM\n+            (SELECT number as key FROM numbers(10000)) as keys,\n+            (SELECT number as range_start FROM numbers(1000)) as ranges;\n+    </fill_query>\n+\n+    <fill_query>\n+        INSERT INTO complex_key_range_hashed_dictionary_source_table\n+        SELECT key, toString(key), key, range_start * 2, range_start * 2 + 1 FROM\n+            (SELECT number as key FROM numbers(10000)) as keys,\n+            (SELECT number as range_start FROM numbers(1000)) as ranges;\n+    </fill_query>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>elements_count</name>\n+            <values>\n+                <value>500000</value>\n+                <value>750000</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>\n+        WITH rand64() % 5000 as key\n+        SELECT dictGet('default.simple_key_range_hashed_dictionary', 'value', toUInt64(key), key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        WITH rand64() % 5000 as key\n+        SELECT dictHas('default.simple_key_range_hashed_dictionary', toUInt64(key), key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT * FROM simple_key_range_hashed_dictionary\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        WITH (rand64() % toUInt64(5000) as key, toString(key) as key_id) as complex_key\n+        SELECT dictGet('default.complex_key_range_hashed_dictionary', 'value', complex_key, key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        WITH (rand64() % toUInt64(5000) as key, toString(key) as key_id) as complex_key\n+        SELECT dictHas('default.complex_key_range_hashed_dictionary', complex_key, key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT * FROM complex_key_range_hashed_dictionary\n+        FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS simple_key_range_hashed_dictionary_source_table;</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS complex_key_range_hashed_dictionary_source_table;</drop_query>\n+\n+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_range_hashed_dictionary;</drop_query>\n+    <drop_query>DROP DICTIONARY IF EXISTS complex_key_range_hashed_dictionary;</drop_query>\n+\n+</test>\ndiff --git a/tests/queries/0_stateless/01676_range_hashed_dictionary.sql b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql\nindex ff69d61b26b8..7d1fc60e90dc 100644\n--- a/tests/queries/0_stateless/01676_range_hashed_dictionary.sql\n+++ b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql\n@@ -45,13 +45,13 @@ SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('\n SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('2019-05-31'));\n SELECT 'select columns from dictionary';\n SELECT 'allColumns';\n-SELECT * FROM database_for_range_dict.range_dictionary;\n+SELECT * FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'noColumns';\n-SELECT 1 FROM database_for_range_dict.range_dictionary;\n+SELECT 1 FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumns';\n-SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary;\n+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumn';\n-SELECT Tax FROM database_for_range_dict.range_dictionary;\n+SELECT Tax FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;\n \n DROP DICTIONARY database_for_range_dict.range_dictionary;\n DROP TABLE database_for_range_dict.date_table;\n@@ -97,13 +97,13 @@ SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2),\n SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2), toDate('2019-05-31'));\n SELECT 'select columns from dictionary';\n SELECT 'allColumns';\n-SELECT * FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT * FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'noColumns';\n-SELECT 1 FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT 1 FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumns';\n-SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumn';\n-SELECT Tax FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT Tax FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n \n DROP DICTIONARY database_for_range_dict.range_dictionary_nullable;\n DROP TABLE database_for_range_dict.date_table;\ndiff --git a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql\nindex 677879b1ebdd..72cac481376e 100644\n--- a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql\n+++ b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql\n@@ -45,13 +45,13 @@ SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-29'));\n SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-31'));\n SELECT 'select columns from dictionary';\n SELECT 'allColumns';\n-SELECT * FROM range_dictionary;\n+SELECT * FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'noColumns';\n-SELECT 1 FROM range_dictionary;\n+SELECT 1 FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumns';\n-SELECT CountryID, StartDate, Tax FROM range_dictionary;\n+SELECT CountryID, StartDate, Tax FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumn';\n-SELECT Tax FROM range_dictionary;\n+SELECT Tax FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;\n \n DROP TABLE date_table;\n DROP DICTIONARY range_dictionary;\n@@ -99,13 +99,13 @@ SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-\n SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-31'));\n SELECT 'select columns from dictionary';\n SELECT 'allColumns';\n-SELECT * FROM range_dictionary_nullable;\n+SELECT * FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'noColumns';\n-SELECT 1 FROM range_dictionary_nullable;\n+SELECT 1 FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumns';\n-SELECT CountryID, StartDate, Tax FROM range_dictionary_nullable;\n+SELECT CountryID, StartDate, Tax FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n SELECT 'onlySpecificColumn';\n-SELECT Tax FROM range_dictionary_nullable;\n+SELECT Tax FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;\n \n DROP TABLE date_table;\n DROP DICTIONARY range_dictionary_nullable;\n",
  "problem_statement": "range_hashed wierd issue with performance.\n```sql\r\nversion 21.5.1\r\n\r\ndrop dictionary if exists curs_dict;\r\ndrop table if exists curs;\r\n\r\nCREATE TABLE curs\r\n(\r\n    `a` UInt64,\r\n    `b` UInt64,\r\n    `e` UInt64,\r\n    `rate` UInt16\r\n)\r\nENGINE = MergeTree\r\nORDER BY a\r\n\r\ninsert into curs \r\n   select 1, \r\n   toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00')+number*2) , \r\n   toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00')+number*2+1), 1 \r\nfrom numbers(1000000);\r\n\r\nCREATE DICTIONARY curs_dict\r\n(\r\n    `a` Unt64,\r\n    `b` UInt64,\r\n    `e` UInt64,\r\n    `rate` UInt16\r\n)\r\nPRIMARY KEY a\r\nSOURCE(CLICKHOUSE(TABLE curs DB 'default' USER 'default'))\r\nLIFETIME(MIN 0 MAX 10)\r\nLAYOUT(RANGE_HASHED)\r\nRANGE(MIN b MAX e);\r\n\r\n0 rows in set. Elapsed: 115.715 sec.\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), toYYYYMMDDhhmmss((toDateTime('2020-01-01 00:00:00') + (number * 2)) + 1))) AS s\r\nFROM numbers(10000);\r\n\r\nElapsed: 0.023 sec.\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), toYYYYMMDDhhmmss((toDateTime('2020-01-01 00:00:00') + (number * 2)) + 1))) AS s\r\nFROM numbers(100000)\r\n\r\nElapsed: 2.264 sec.   / Expected  0.023*10 ~ 0.230\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), toYYYYMMDDhhmmss((toDateTime('2020-01-01 00:00:00') + (rand())) + 1))) AS s\r\nFROM numbers(100000)\r\n\r\nHangs forever\r\n```\n",
  "hints_text": "zero lifetime\r\n\r\n```sql\r\nCREATE DICTIONARY curs_dict\r\n(\r\n    `a` Unt64,\r\n    `b` UInt64,\r\n    `e` UInt64,\r\n    `rate` UInt16\r\n)\r\nPRIMARY KEY a\r\nSOURCE(CLICKHOUSE(TABLE curs DB 'default' USER 'default'))\r\nLIFETIME(0)\r\nLAYOUT(RANGE_HASHED)\r\nRANGE(MIN b MAX e);\r\n\r\n0 rows in set. Elapsed: 125.655 sec.\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00') + number))) AS s\r\nFROM numbers(1000000)\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500s\u2500\u2510\r\n\u2502 1000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 141.722 sec. Processed 1.05 million rows, 8.38 MB (7.40 thousand rows/s., 59.16 KB/s.)\r\n\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), toYYYYMMDDhhmmss((toDateTime('2020-01-01 00:00:00') + rand()) + 1))) AS s\r\nFROM numbers(100000)\r\n\r\n\u2199 Progress: 65.50 thousand rows, 524.04 KB (646.90 thousand rows/s., 5.18 MB/s.)  64%\r\n.........\r\n.........\r\n.........\r\n```\n```sql\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), \r\n   toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00') + (rand() % 54645654)))) AS s\r\nFROM numbers(100)\r\n\r\n1 rows in set. Elapsed: 0.445 sec.\r\n\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), \r\n   toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00') + (rand() % 54645654)))) AS s\r\nFROM numbers(1000)\r\n\r\n1 rows in set. Elapsed: 4.215 sec. Processed 1.00 thousand rows, 8.00 KB (237.24 rows/s., 1.90 KB/s.)\r\n\r\n\r\n\r\nSELECT sum(dictGetUInt16('curs_dict', 'rate', toUInt64(1), \r\n  toYYYYMMDDhhmmss(toDateTime('2020-01-01 00:00:00') + (rand() % 54645654)))) AS s\r\nFROM numbers(10000)\r\n\r\n1 rows in set. Elapsed: 51.282 sec. Processed 10.00 thousand rows, 80.00 KB (195.00 rows/s., 1.56 KB/s.)\r\n\r\n```\n@den-crane we does not change range dictionary much during dictionaries refactoring. Are there any performance issues with 21.1, 21.2, 21.3, 21.4 versions ?\r\nJust need to be sure that it is bad performance, not a regression.",
  "created_at": "2022-01-11T10:16:52Z"
}