{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16956,
  "instance_id": "ClickHouse__ClickHouse-16956",
  "issue_numbers": [
    "16107"
  ],
  "base_commit": "bbd85c3b2d3bf8de42209a0a2fe721c98f04a9cd",
  "patch": "diff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 61ca933dd535..603733129f48 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -26,6 +26,7 @@\n #include <Parsers/ASTTablesInSelectQuery.h>\n \n #include <Functions/FunctionFactory.h>\n+#include <Storages/StorageInMemoryMetadata.h>\n \n \n namespace DB\n@@ -438,7 +439,8 @@ void optimizeDuplicateDistinct(ASTSelectQuery & select)\n /// Replace monotonous functions in ORDER BY if they don't participate in GROUP BY expression,\n /// has a single argument and not an aggregate functions.\n void optimizeMonotonousFunctionsInOrderBy(ASTSelectQuery * select_query, const Context & context,\n-                                          const TablesWithColumns & tables_with_columns)\n+                                          const TablesWithColumns & tables_with_columns,\n+                                          const Names & sorting_key_columns)\n {\n     auto order_by = select_query->orderBy();\n     if (!order_by)\n@@ -455,13 +457,22 @@ void optimizeMonotonousFunctionsInOrderBy(ASTSelectQuery * select_query, const C\n         }\n     }\n \n-    for (auto & child : order_by->children)\n+    bool is_sorting_key_prefix = true;\n+    for (size_t i = 0; i < order_by->children.size(); ++i)\n     {\n-        auto * order_by_element = child->as<ASTOrderByElement>();\n+        auto * order_by_element = order_by->children[i]->as<ASTOrderByElement>();\n         auto & ast_func = order_by_element->children[0];\n         if (!ast_func->as<ASTFunction>())\n             continue;\n \n+        if (i >= sorting_key_columns.size() || ast_func->getColumnName() != sorting_key_columns[i])\n+            is_sorting_key_prefix = false;\n+\n+        /// If order by expression matches the sorting key, do not remove\n+        /// functions to allow execute reading in order of key.\n+        if (is_sorting_key_prefix)\n+            continue;\n+\n         MonotonicityCheckVisitor::Data data{tables_with_columns, context, group_by_hashes};\n         MonotonicityCheckVisitor(data).visit(ast_func);\n \n@@ -611,7 +622,8 @@ void TreeOptimizer::optimizeIf(ASTPtr & query, Aliases & aliases, bool if_chain_\n \n void TreeOptimizer::apply(ASTPtr & query, Aliases & aliases, const NameSet & source_columns_set,\n                           const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns,\n-                          const Context & context, bool & rewrite_subqueries)\n+                          const Context & context, const StorageMetadataPtr & metadata_snapshot,\n+                          bool & rewrite_subqueries)\n {\n     const auto & settings = context.getSettingsRef();\n \n@@ -652,9 +664,6 @@ void TreeOptimizer::apply(ASTPtr & query, Aliases & aliases, const NameSet & sou\n         optimizeAggregateFunctionsOfGroupByKeys(select_query, query);\n     }\n \n-    /// Remove duplicate items from ORDER BY.\n-    optimizeDuplicatesInOrderBy(select_query);\n-\n     /// Remove duplicate ORDER BY and DISTINCT from subqueries.\n     if (settings.optimize_duplicate_order_by_and_distinct)\n     {\n@@ -672,7 +681,13 @@ void TreeOptimizer::apply(ASTPtr & query, Aliases & aliases, const NameSet & sou\n \n     /// Replace monotonous functions with its argument\n     if (settings.optimize_monotonous_functions_in_order_by)\n-        optimizeMonotonousFunctionsInOrderBy(select_query, context, tables_with_columns);\n+        optimizeMonotonousFunctionsInOrderBy(select_query, context, tables_with_columns,\n+            metadata_snapshot ? metadata_snapshot->getSortingKeyColumns() : Names{});\n+\n+    /// Remove duplicate items from ORDER BY.\n+    /// Execute it after all order by optimizations,\n+    /// because they can produce duplicated columns.\n+    optimizeDuplicatesInOrderBy(select_query);\n \n     /// If function \"if\" has String-type arguments, transform them into enum\n     if (settings.optimize_if_transform_strings_to_enum)\ndiff --git a/src/Interpreters/TreeOptimizer.h b/src/Interpreters/TreeOptimizer.h\nindex a81264184c16..a10dfc57451a 100644\n--- a/src/Interpreters/TreeOptimizer.h\n+++ b/src/Interpreters/TreeOptimizer.h\n@@ -8,6 +8,8 @@ namespace DB\n {\n \n class Context;\n+struct StorageInMemoryMetadata;\n+using StorageMetadataPtr = std::shared_ptr<const StorageInMemoryMetadata>;\n \n /// Part of of Tree Rewriter (SyntaxAnalyzer) that optimizes AST.\n /// Query should be ready to execute either before either after it. But resulting query could be faster.\n@@ -16,7 +18,8 @@ class TreeOptimizer\n public:\n     static void apply(ASTPtr & query, Aliases & aliases, const NameSet & source_columns_set,\n                       const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns,\n-                      const Context & context, bool & rewrite_subqueries);\n+                      const Context & context, const StorageMetadataPtr & metadata_snapshot,\n+                      bool & rewrite_subqueries);\n \n     static void optimizeIf(ASTPtr & query, Aliases & aliases, bool if_chain_to_multiif);\n };\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex b2dbd0271914..c02d54435eb3 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -645,7 +645,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     /// Executing scalar subqueries - replacing them with constant values.\n     executeScalarSubqueries(query, context, subquery_depth, result.scalars, select_options.only_analyze);\n \n-    TreeOptimizer::apply(query, result.aliases, source_columns_set, tables_with_columns, context, result.rewrite_subqueries);\n+    TreeOptimizer::apply(query, result.aliases, source_columns_set, tables_with_columns, context, result.metadata_snapshot, result.rewrite_subqueries);\n \n     /// array_join_alias_to_name, array_join_result_to_source.\n     getArrayJoinedColumns(query, result, select_query, result.source_columns, source_columns_set);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01321_monotonous_functions_in_order_by.reference b/tests/queries/0_stateless/01321_monotonous_functions_in_order_by.reference\nindex ffa91586f350..0a7746e1832f 100644\n--- a/tests/queries/0_stateless/01321_monotonous_functions_in_order_by.reference\n+++ b/tests/queries/0_stateless/01321_monotonous_functions_in_order_by.reference\n@@ -54,14 +54,10 @@ FROM numbers(3)\n ORDER BY exp(number) ASC\n SELECT roundToExp2(number) AS x\n FROM numbers(3)\n-ORDER BY\n-    number ASC,\n-    number ASC\n+ORDER BY number ASC\n SELECT number AS x\n FROM numbers(3)\n-ORDER BY\n-    number ASC,\n-    number ASC\n+ORDER BY number ASC\n SELECT number\n FROM numbers(3)\n ORDER BY number DESC\n@@ -79,9 +75,7 @@ FROM numbers(3)\n ORDER BY exp(number) DESC\n SELECT roundToExp2(number) AS x\n FROM numbers(3)\n-ORDER BY\n-    number DESC,\n-    number DESC\n+ORDER BY number DESC\n 0\n 1\n 2\ndiff --git a/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference\nnew file mode 100644\nindex 000000000000..203efdab299b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference\n@@ -0,0 +1,46 @@\n+SELECT\n+    timestamp,\n+    key\n+FROM test_order_by\n+ORDER BY timestamp ASC\n+LIMIT 10\n+Expression (Projection)\n+  Limit (preliminary LIMIT)\n+    MergingSorted (Merge sorted streams for ORDER BY)\n+      MergeSorting (Merge sorted blocks for ORDER BY)\n+        PartialSorting (Sort each block for ORDER BY)\n+          Expression (Before ORDER BY and SELECT)\n+            SettingQuotaAndLimits (Set limits and quota after reading from storage)\n+              ReadFromStorage (MergeTree)\n+SELECT\n+    timestamp,\n+    key\n+FROM test_order_by\n+ORDER BY toDate(timestamp) ASC\n+LIMIT 10\n+Expression (Projection)\n+  Limit (preliminary LIMIT)\n+    FinishSorting\n+      Expression (Before ORDER BY and SELECT)\n+        SettingQuotaAndLimits (Set limits and quota after reading from storage)\n+          ReadFromStorage (MergeTree  with order)\n+SELECT\n+    timestamp,\n+    key\n+FROM test_order_by\n+ORDER BY\n+    toDate(timestamp) ASC,\n+    timestamp ASC\n+LIMIT 10\n+Expression (Projection)\n+  Limit (preliminary LIMIT)\n+    FinishSorting\n+      Expression (Before ORDER BY and SELECT)\n+        SettingQuotaAndLimits (Set limits and quota after reading from storage)\n+          ReadFromStorage (MergeTree  with order)\n+SELECT\n+    timestamp,\n+    key\n+FROM test_order_by\n+ORDER BY timestamp ASC\n+LIMIT 10\ndiff --git a/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.sql b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.sql\nnew file mode 100644\nindex 000000000000..b31457d8f686\n--- /dev/null\n+++ b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.sql\n@@ -0,0 +1,26 @@\n+SET optimize_monotonous_functions_in_order_by = 1;\n+\n+DROP TABLE IF EXISTS test_order_by;\n+\n+CREATE TABLE test_order_by (timestamp DateTime, key UInt32) ENGINE=MergeTree() ORDER BY (toDate(timestamp), key);\n+INSERT INTO test_order_by SELECT now() + toIntervalSecond(number), number % 4 FROM numbers(10000);\n+OPTIMIZE TABLE test_order_by FINAL;\n+\n+EXPLAIN SYNTAX SELECT * FROM test_order_by ORDER BY timestamp LIMIT 10;\n+EXPLAIN PLAN SELECT * FROM test_order_by ORDER BY timestamp LIMIT 10;\n+\n+EXPLAIN SYNTAX SELECT * FROM test_order_by ORDER BY toDate(timestamp) LIMIT 10;\n+EXPLAIN PLAN SELECT * FROM test_order_by ORDER BY toDate(timestamp) LIMIT 10;\n+\n+EXPLAIN SYNTAX SELECT * FROM test_order_by ORDER BY toDate(timestamp), timestamp LIMIT 10;\n+EXPLAIN PLAN SELECT * FROM test_order_by ORDER BY toDate(timestamp), timestamp LIMIT 10;\n+\n+DROP TABLE IF EXISTS test_order_by;\n+\n+CREATE TABLE test_order_by (timestamp DateTime, key UInt32) ENGINE=MergeTree() ORDER BY tuple();\n+INSERT INTO test_order_by SELECT now() + toIntervalSecond(number), number % 4 FROM numbers(10000);\n+OPTIMIZE TABLE test_order_by FINAL;\n+\n+EXPLAIN SYNTAX SELECT * FROM test_order_by ORDER BY toDate(timestamp), timestamp LIMIT 10;\n+\n+DROP TABLE IF EXISTS test_order_by;\n",
  "problem_statement": "optimize_read_in_order doesn't work with ORDER BY (toDate(timestamp)) in clickhouse 20.8+\n**How to reproduce**\r\n```\r\nCREATE TABLE test_order_by (timestamp DateTime, key UInt32) ENGINE=MergeTree() PARTITION BY toYYYYMM(timestamp) ORDER BY (toDate(timestamp), key);\r\nINSERT INTO test_order_by SELECT now() + toIntervalSecond(number), number % 4 FROM numbers(10000000);\r\nOPTIMIZE TABLE test_order_by FINAL;\r\nQ1: SELECT * FROM test_order_by ORDER BY timestamp LIMIT 10;\r\nQ2: SELECT * FROM test_order_by ORDER BY toDate(timestamp) LIMIT 10;\r\nQ3: SELECT * FROM test_order_by ORDER BY toDate(timestamp), timestamp LIMIT 10;\r\n\r\nQ1 works the same on all versions of clickhouse.\r\nQ1: 10 rows in set. Elapsed: 0.060 sec. Processed 10.00 million rows, 80.00 MB (166.87 million rows/s., 1.33 GB/s.)\r\n\r\nClickhouse 20.3.19\r\nQ2: 10 rows in set. Elapsed: 0.013 sec. Processed 655.36 thousand rows, 5.24 MB (50.57 million rows/s., 404.54 MB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.034 sec. Processed 720.90 thousand rows, 5.77 MB (21.15 million rows/s., 169.23 MB/s.)\r\nClickhouse 20.4.2.9\r\nQ2: Code: 15. DB::Exception: Received from localhost:9000. DB::Exception: Column 'toDate(timestamp)' already exists.\r\nQ3: Code: 15. DB::Exception: Received from localhost:9000. DB::Exception: Column 'toDate(timestamp)' already exists.\r\nClickhouse 20.5.5.74\r\nQ2: 10 rows in set. Elapsed: 0.020 sec. Processed 1.44 million rows, 11.53 MB (72.88 million rows/s., 583.04 MB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.013 sec. Processed 1.57 million rows, 12.58 MB (121.66 million rows/s., 973.31 MB/s.)\r\nClickhouse 20.6.8.5\r\nQ2: 10 rows in set. Elapsed: 0.008 sec. Processed 1.05 million rows, 8.39 MB (131.13 million rows/s., 1.05 GB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.011 sec. Processed 1.11 million rows, 8.91 MB (105.19 million rows/s., 841.48 MB/s.)\r\nClickhouse 20.7.4.11\r\nQ2: 10 rows in set. Elapsed: 0.008 sec. Processed 1.05 million rows, 8.38 MB (130.08 million rows/s., 1.04 GB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.012 sec. Processed 1.11 million rows, 8.91 MB (90.35 million rows/s., 722.80 MB/s.)\r\nClickhouse 20.8.4.11\r\nQ2: 10 rows in set. Elapsed: 0.046 sec. Processed 10.00 million rows, 80.00 MB (215.31 million rows/s., 1.72 GB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.054 sec. Processed 10.00 million rows, 80.00 MB (185.84 million rows/s., 1.49 GB/s.)\r\nClickhouse 20.9.3\r\nQ2: 10 rows in set. Elapsed: 0.055 sec. Processed 10.00 million rows, 80.00 MB (181.47 million rows/s., 1.45 GB/s.)\r\nQ3: 10 rows in set. Elapsed: 0.040 sec. Processed 10.00 million rows, 80.00 MB (250.70 million rows/s., 2.01 GB/s.)\r\n\r\n\r\n```\r\n**Additional context**\r\nIt would be a good feature, of clickhouse will use optimize in order with monotonic functions without ORDER BY rewriting.\r\n` SET optimize_monotonous_functions_in_order_by = 1` has no affect on that kind of queries.\r\n\n",
  "hints_text": "But with `SET optimize_monotonous_functions_in_order_by = 0` `optimize_read_in_order` works :)\r\n\r\nI guess, something wrong is in rewriting ASTs.\nIt's because `optimize_monotonous_functions_in_order_by` optimization drops `toDate` function as redundant and then we can't match `ORDER BY` expression with sorting key to apply `optimize_read_in_order` optimization.\r\n```sql\r\nEXPLAIN SYNTAX\r\nSELECT *\r\nFROM test_order_by\r\nORDER BY toDate(timestamp) ASC\r\nLIMIT 10\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 SELECT                 \u2502\r\n\u2502     timestamp,         \u2502\r\n\u2502     key                \u2502\r\n\u2502 FROM test_order_by     \u2502\r\n\u2502 ORDER BY timestamp ASC \u2502\r\n\u2502 LIMIT 10               \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```",
  "created_at": "2020-11-12T23:37:36Z",
  "modified_files": [
    "src/Interpreters/TreeOptimizer.cpp",
    "src/Interpreters/TreeOptimizer.h",
    "src/Interpreters/TreeRewriter.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01321_monotonous_functions_in_order_by.reference",
    "b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference",
    "b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.sql"
  ]
}