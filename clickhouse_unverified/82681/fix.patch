diff --git a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp
index e6905c61b118..4cfbbac6bd2f 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp
+++ b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp
@@ -138,7 +138,8 @@ AggregateFunctionPtr createAggregateFunctionNumericIndexedVector(
         if (!(first_which.isInt8() or first_which.isInt16() or first_which.isInt32() or first_which.isUInt8() or first_which.isUInt16()
               or first_which.isUInt32()))
             throw Exception(
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The first argument type only support Int8/Int16/Int32/UInt8/UInt16/UInt32 in BSI");
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "The first argument type must be one of Int8, Int16, Int32, UInt8, UInt16, UInt32 in BSI");
 
         if (!(second_which.isNativeInt() || second_which.isNativeUInt() || second_which.isNativeFloat()))
             throw Exception(
diff --git a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
index a155efc79e9d..07b4ad16ac29 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
@@ -5,7 +5,6 @@
 #include <IO/ReadBuffer.h>
 #include <base/demangle.h>
 #include <Common/JSONBuilder.h>
-#include <Common/logger_useful.h>
 
 /// Include this last â€” see the reason inside
 #include <AggregateFunctions/AggregateFunctionGroupBitmapData.h>
@@ -22,7 +21,9 @@ extern const int BAD_ARGUMENTS;
 extern const int INCORRECT_DATA;
 }
 
-/** The following example demonstrates the BSI storage mechanism.
+/** The following example demonstrates the Bit-Sliced Index (BSI) storage mechanism.
+ * This is implementation of https://dl.acm.org/doi/10.14778/3685800.3685823.
+ * Less dense explanation is here: https://github.com/ClickHouse/ClickHouse/issues/70582.
  * Original Vector:
  *  Suppose we have a sparse vector with:
  *  - Length: 4294967295 (UINT32_MAX).
@@ -76,7 +77,7 @@ class BSINumericIndexedVector
 
     static constexpr auto type = "BSI";
 
-    /** For Floar ValueType:
+    /** For Float ValueType:
      * - Use 40-bit fixed-point representation for integer part.
      *   Which means supported value range is [-2^39, 2^39 - 1] in the signed scenario.
      * - Use 24-bit represent decimal part, provides about 10^-7~10^-8(2^-24) resolution.
@@ -108,6 +109,20 @@ class BSINumericIndexedVector
     std::shared_ptr<Roaring> zero_indexes = std::make_shared<Roaring>();
     std::vector<std::shared_ptr<Roaring>> data_array;
 
+    /// The only way NaN and Inf values can enter BSI is if user adds them as they cannot appear in BSI by any permitted operation.
+    /// Do not allow user to do this as it achieves nothing and is very likely by mistake.
+    constexpr inline static void checkValidValue(const ValueType & value)
+    {
+        if constexpr (std::is_floating_point_v<ValueType>)
+        {
+            if (isnan(value))
+                throw Exception(ErrorCodes::INCORRECT_DATA, "NumericIndexedVector does not support NaN");
+            if (isinf(value))
+                throw Exception(ErrorCodes::INCORRECT_DATA, "NumericIndexedVector does not support Inf");
+        }
+    }
+
+
 public:
     BSINumericIndexedVector()
     {
@@ -258,6 +273,7 @@ class BSINumericIndexedVector
      */
     void initializeFromVectorAndValue(const BSINumericIndexedVector & rhs, ValueType value)
     {
+        checkValidValue(value);
         initialize(rhs.integer_bit_num, rhs.fraction_bit_num);
 
         auto all_index = rhs.getAllIndex();
@@ -1097,6 +1113,7 @@ class BSINumericIndexedVector
             res.zero_indexes->rb_or(*lhs.getAllIndex());
             return;
         }
+        checkValidValue(rhs);
 
         auto lhs_non_zero_indexes = lhs.getAllNonZeroIndex();
 
@@ -1248,6 +1265,7 @@ class BSINumericIndexedVector
             res_bm->rb_or(*lhs.zero_indexes);
             return res_bm;
         }
+        checkValidValue(rhs);
 
         res_bm = lhs.getAllNonZeroIndex();
 
@@ -1297,6 +1315,7 @@ class BSINumericIndexedVector
 
     static void pointwiseEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)
     {
+        checkValidValue(rhs);
         res.initialize(2, 0);
         res.getDataArrayAt(res.fraction_bit_num)->rb_or(*pointwiseEqual(lhs, rhs));
     }
@@ -1331,6 +1350,7 @@ class BSINumericIndexedVector
      */
     static void pointwiseNotEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)
     {
+        /// Do not need checkValidValue(rhs) as this is checked within pointwiseEqual
         pointwiseEqual(lhs, rhs, res);
         auto & res_bm = res.getDataArrayAt(res.fraction_bit_num);
 
@@ -1507,6 +1527,7 @@ class BSINumericIndexedVector
      */
     static void pointwiseLessEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)
     {
+        /// Do not need checkValidValue(rhs) as this is checked within pointwiseLess
         auto lt_bm = pointwiseLess(lhs, rhs);
         auto eq_bm = pointwiseEqual(lhs, rhs);
 
@@ -1578,6 +1599,8 @@ class BSINumericIndexedVector
     /// original_vector(this)[index] += value.
     void addValue(IndexType index, ValueType value)
     {
+        checkValidValue(value);
+
         if (sizeof(IndexType) > 4)
         {
             throw Exception(ErrorCodes::LOGICAL_ERROR, "IndexType must be at most 32 bits in BSI format");
