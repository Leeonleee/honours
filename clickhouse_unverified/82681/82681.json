{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 82681,
  "instance_id": "ClickHouse__ClickHouse-82681",
  "issue_numbers": [
    "82239"
  ],
  "base_commit": "b9da34008385eff57065b506e357cd4c5f07d011",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp\nindex e6905c61b118..4cfbbac6bd2f 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVector.cpp\n@@ -138,7 +138,8 @@ AggregateFunctionPtr createAggregateFunctionNumericIndexedVector(\n         if (!(first_which.isInt8() or first_which.isInt16() or first_which.isInt32() or first_which.isUInt8() or first_which.isUInt16()\n               or first_which.isUInt32()))\n             throw Exception(\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument type only support Int8/Int16/Int32/UInt8/UInt16/UInt32 in BSI\");\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"The first argument type must be one of Int8, Int16, Int32, UInt8, UInt16, UInt32 in BSI\");\n \n         if (!(second_which.isNativeInt() || second_which.isNativeUInt() || second_which.isNativeFloat()))\n             throw Exception(\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h\nindex a155efc79e9d..07b4ad16ac29 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h\n@@ -5,7 +5,6 @@\n #include <IO/ReadBuffer.h>\n #include <base/demangle.h>\n #include <Common/JSONBuilder.h>\n-#include <Common/logger_useful.h>\n \n /// Include this last \u2014 see the reason inside\n #include <AggregateFunctions/AggregateFunctionGroupBitmapData.h>\n@@ -22,7 +21,9 @@ extern const int BAD_ARGUMENTS;\n extern const int INCORRECT_DATA;\n }\n \n-/** The following example demonstrates the BSI storage mechanism.\n+/** The following example demonstrates the Bit-Sliced Index (BSI) storage mechanism.\n+ * This is implementation of https://dl.acm.org/doi/10.14778/3685800.3685823.\n+ * Less dense explanation is here: https://github.com/ClickHouse/ClickHouse/issues/70582.\n  * Original Vector:\n  *  Suppose we have a sparse vector with:\n  *  - Length: 4294967295 (UINT32_MAX).\n@@ -76,7 +77,7 @@ class BSINumericIndexedVector\n \n     static constexpr auto type = \"BSI\";\n \n-    /** For Floar ValueType:\n+    /** For Float ValueType:\n      * - Use 40-bit fixed-point representation for integer part.\n      *   Which means supported value range is [-2^39, 2^39 - 1] in the signed scenario.\n      * - Use 24-bit represent decimal part, provides about 10^-7~10^-8(2^-24) resolution.\n@@ -108,6 +109,20 @@ class BSINumericIndexedVector\n     std::shared_ptr<Roaring> zero_indexes = std::make_shared<Roaring>();\n     std::vector<std::shared_ptr<Roaring>> data_array;\n \n+    /// The only way NaN and Inf values can enter BSI is if user adds them as they cannot appear in BSI by any permitted operation.\n+    /// Do not allow user to do this as it achieves nothing and is very likely by mistake.\n+    constexpr inline static void checkValidValue(const ValueType & value)\n+    {\n+        if constexpr (std::is_floating_point_v<ValueType>)\n+        {\n+            if (isnan(value))\n+                throw Exception(ErrorCodes::INCORRECT_DATA, \"NumericIndexedVector does not support NaN\");\n+            if (isinf(value))\n+                throw Exception(ErrorCodes::INCORRECT_DATA, \"NumericIndexedVector does not support Inf\");\n+        }\n+    }\n+\n+\n public:\n     BSINumericIndexedVector()\n     {\n@@ -258,6 +273,7 @@ class BSINumericIndexedVector\n      */\n     void initializeFromVectorAndValue(const BSINumericIndexedVector & rhs, ValueType value)\n     {\n+        checkValidValue(value);\n         initialize(rhs.integer_bit_num, rhs.fraction_bit_num);\n \n         auto all_index = rhs.getAllIndex();\n@@ -1097,6 +1113,7 @@ class BSINumericIndexedVector\n             res.zero_indexes->rb_or(*lhs.getAllIndex());\n             return;\n         }\n+        checkValidValue(rhs);\n \n         auto lhs_non_zero_indexes = lhs.getAllNonZeroIndex();\n \n@@ -1248,6 +1265,7 @@ class BSINumericIndexedVector\n             res_bm->rb_or(*lhs.zero_indexes);\n             return res_bm;\n         }\n+        checkValidValue(rhs);\n \n         res_bm = lhs.getAllNonZeroIndex();\n \n@@ -1297,6 +1315,7 @@ class BSINumericIndexedVector\n \n     static void pointwiseEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)\n     {\n+        checkValidValue(rhs);\n         res.initialize(2, 0);\n         res.getDataArrayAt(res.fraction_bit_num)->rb_or(*pointwiseEqual(lhs, rhs));\n     }\n@@ -1331,6 +1350,7 @@ class BSINumericIndexedVector\n      */\n     static void pointwiseNotEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)\n     {\n+        /// Do not need checkValidValue(rhs) as this is checked within pointwiseEqual\n         pointwiseEqual(lhs, rhs, res);\n         auto & res_bm = res.getDataArrayAt(res.fraction_bit_num);\n \n@@ -1507,6 +1527,7 @@ class BSINumericIndexedVector\n      */\n     static void pointwiseLessEqual(const BSINumericIndexedVector & lhs, const ValueType & rhs, BSINumericIndexedVector & res)\n     {\n+        /// Do not need checkValidValue(rhs) as this is checked within pointwiseLess\n         auto lt_bm = pointwiseLess(lhs, rhs);\n         auto eq_bm = pointwiseEqual(lhs, rhs);\n \n@@ -1578,6 +1599,8 @@ class BSINumericIndexedVector\n     /// original_vector(this)[index] += value.\n     void addValue(IndexType index, ValueType value)\n     {\n+        checkValidValue(value);\n+\n         if (sizeof(IndexType) > 4)\n         {\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"IndexType must be at most 32 bits in BSI format\");\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.reference b/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.reference\nindex 3677309cd3a9..deae640f4092 100644\n--- a/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.reference\n+++ b/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.reference\n@@ -1,2 +1,4 @@\n {1:72999999515.86284,2:82999999514.86284,3:0,4:0,5:0,6:-92967846119.29968,7:0}\n {1:-72999999515.86284,2:-82999999514.86284,3:0,4:0,5:0,7:0}\n+\\N\n+3\ndiff --git a/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.sql b/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.sql\nindex 322313782bb5..d737f9f4dce8 100644\n--- a/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.sql\n+++ b/tests/queries/0_stateless/03463_numeric_indexed_vector_overflow.sql\n@@ -10,4 +10,47 @@ SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec_1, 99\n WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec_1, -9999999999));\n \n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec_1, nan)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec_1, Null));\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseDivide(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseAdd(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseEqual(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseNotEqual(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseLess(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseLessEqual(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseGreater(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseGreaterEqual(vec_1, inf)); -- { serverError INCORRECT_DATA }\n+\n+INSERT INTO uin_value_details (uin, value) values (1, 7.3), (2, 8.3), (3, 0), (4, 0), (5, 0), (6, 100.6543782), (7, inf);\n+WITH (SELECT groupNumericIndexedVectorState(uin, value) FROM uin_value_details) AS vec_1\n+SELECT numericIndexedVectorToMap(numericIndexedVectorPointwiseGreaterEqual(vec_1, 0)); -- { serverError INCORRECT_DATA }\n+\n DROP TABLE uin_value_details;\n+\n+\n+SELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, nan), (3, 2), (0, 0), (5, 1)); -- { serverError INCORRECT_DATA }\n+SELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, Null), (3, 2), (0, 0), (5, 1));\n+SELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, inf), (3, 2), (0, 0), (5, 1)); -- { serverError INCORRECT_DATA }\n+SELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, -inf), (3, 2), (0, 0), (5, 1)); -- { serverError INCORRECT_DATA }\n",
  "problem_statement": "Unexpected result of `groupNumericIndexedVector` with nan and inf\n### Describe the unexpected behaviour\n\n```sql\nSELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, nan), (3, 2), (0, 0), (5, 1));\n```\nOutput:\n```\n-549755813885\n```\nExpected output:\n```\nnan\n```\n\nSame with inf:\n```sql\nSELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)', (1, 0), (3, inf), (3, 2), (0, 0), (5, 1));\n```\nOutput:\n```\n-549755813885\n```\nExpected output:\n```\ninf\n```\n\n### Which ClickHouse versions are affected?\n\nHead (25.7.1.692)\n\n### How to reproduce\n\nhttps://fiddle.clickhouse.com/f829c76a-e0a4-4d59-9465-c0f386c09b02\n\n### Additional Context\n\n```sql\nSELECT groupNumericIndexedVector(x, y) FROM values('x Nullable(Int32), y Nullable(Float64)',  (2, nan), (NULL, 0));\n```\nOutput:\n```\n0\n```\n\nExpected: \n```\nnan\n```\n\nhttps://fiddle.clickhouse.com/79475c51-5490-46bf-9465-7e6fc2607ded\n",
  "hints_text": "@FriendLey @rienath Hey! Can you please tell if this behavior is expected?\nWhile it's possible to propagate nan and inf (we handle 0's in a similar way), I don\u2019t see any reasonable use case for this. We should return an error in both scenarios. What do you think @FriendLey?",
  "created_at": "2025-06-26T17:54:58Z"
}