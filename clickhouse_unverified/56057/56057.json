{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56057,
  "instance_id": "ClickHouse__ClickHouse-56057",
  "issue_numbers": [
    "56031"
  ],
  "base_commit": "ecafc77e0fc30b9892d2741b108e0af2c0720e16",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 03b70dd8764e..5cf0d386f285 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -623,12 +623,6 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n         if (storage && !query.final() && storage->needRewriteQueryWithFinal(syntax_analyzer_result->requiredSourceColumns()))\n             query.setFinal();\n \n-        /// Save scalar sub queries's results in the query context\n-        /// Note that we are only saving scalars and not local_scalars since the latter can't be safely shared across contexts\n-        if (!options.only_analyze && context->hasQueryContext())\n-            for (const auto & it : syntax_analyzer_result->getScalars())\n-                context->getQueryContext()->addScalar(it.first, it.second);\n-\n         if (view)\n         {\n             /// Restore original view name. Save rewritten subquery for future usage in StorageView.\ndiff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex 2db4fce81f0d..0ace0a8b79cd 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -1008,10 +1008,6 @@ void MutationsInterpreter::prepareMutationStages(std::vector<Stage> & prepared_s\n             all_asts, all_columns, source.getStorage(), storage_snapshot,\n             false, true, execute_scalar_subqueries);\n \n-        if (execute_scalar_subqueries && context->hasQueryContext())\n-            for (const auto & it : syntax_result->getScalars())\n-                context->getQueryContext()->addScalar(it.first, it.second);\n-\n         stage.analyzer = std::make_unique<ExpressionAnalyzer>(all_asts, syntax_result, context);\n \n         ExpressionActionsChain & actions_chain = stage.expressions_chain;\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 67187be962ca..6172ef06b9a2 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -1299,7 +1299,24 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     removeUnneededColumnsFromSelectClause(select_query, required_result_columns, remove_duplicates);\n \n     /// Executing scalar subqueries - replacing them with constant values.\n-    executeScalarSubqueries(query, getContext(), subquery_depth, result.scalars, result.local_scalars, select_options.only_analyze, select_options.is_create_parameterized_view);\n+    Scalars scalars;\n+    Scalars local_scalars;\n+    executeScalarSubqueries(\n+        query,\n+        getContext(),\n+        subquery_depth,\n+        scalars,\n+        local_scalars,\n+        select_options.only_analyze,\n+        select_options.is_create_parameterized_view);\n+\n+    /// Save scalar sub queries's results in the query context\n+    /// Note that we are only saving scalars and not local_scalars since the latter can't be safely shared across contexts\n+    if (!select_options.only_analyze && getContext()->hasQueryContext())\n+    {\n+        for (const auto & it : scalars)\n+            getContext()->getQueryContext()->addScalar(it.first, it.second);\n+    }\n \n     if (settings.legacy_column_name_of_tuple_literal)\n         markTupleLiteralsAsLegacy(query);\n@@ -1415,7 +1432,17 @@ TreeRewriterResultPtr TreeRewriter::analyze(\n     normalize(query, result.aliases, result.source_columns_set, false, settings, allow_self_aliases, getContext(), is_create_parameterized_view);\n \n     /// Executing scalar subqueries. Column defaults could be a scalar subquery.\n-    executeScalarSubqueries(query, getContext(), 0, result.scalars, result.local_scalars, !execute_scalar_subqueries, is_create_parameterized_view);\n+    Scalars scalars;\n+    Scalars local_scalars;\n+    executeScalarSubqueries(query, getContext(), 0, scalars, local_scalars, !execute_scalar_subqueries, is_create_parameterized_view);\n+\n+    /// Save scalar sub queries's results in the query context\n+    /// Note that we are only saving scalars and not local_scalars since the latter can't be safely shared across contexts\n+    if (execute_scalar_subqueries && getContext()->hasQueryContext())\n+    {\n+        for (const auto & it : scalars)\n+            getContext()->getQueryContext()->addScalar(it.first, it.second);\n+    }\n \n     if (settings.legacy_column_name_of_tuple_literal)\n         markTupleLiteralsAsLegacy(query);\ndiff --git a/src/Interpreters/TreeRewriter.h b/src/Interpreters/TreeRewriter.h\nindex 75d8fcf0223e..1858488afa3d 100644\n--- a/src/Interpreters/TreeRewriter.h\n+++ b/src/Interpreters/TreeRewriter.h\n@@ -81,10 +81,6 @@ struct TreeRewriterResult\n     /// Rewrite _shard_num to shardNum()\n     bool has_virtual_shard_num = false;\n \n-    /// Results of scalar sub queries\n-    Scalars scalars;\n-    Scalars local_scalars;\n-\n     explicit TreeRewriterResult(\n         const NamesAndTypesList & source_columns_,\n         ConstStoragePtr storage_ = {},\n@@ -96,7 +92,6 @@ struct TreeRewriterResult\n     Names requiredSourceColumns() const { return required_source_columns.getNames(); }\n     const Names & requiredSourceColumnsForAccessCheck() const { return required_source_columns_before_expanding_alias_columns; }\n     NameSet getArrayJoinSourceNameSet() const;\n-    const Scalars & getScalars() const { return scalars; }\n };\n \n using TreeRewriterResultPtr = std::shared_ptr<const TreeRewriterResult>;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02902_add_scalar_in_all_case.reference b/tests/queries/0_stateless/02902_add_scalar_in_all_case.reference\nnew file mode 100644\nindex 000000000000..5caff40c4a0c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02902_add_scalar_in_all_case.reference\n@@ -0,0 +1,1 @@\n+10000\ndiff --git a/tests/queries/0_stateless/02902_add_scalar_in_all_case.sql b/tests/queries/0_stateless/02902_add_scalar_in_all_case.sql\nnew file mode 100644\nindex 000000000000..047d2f4cdf8e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02902_add_scalar_in_all_case.sql\n@@ -0,0 +1,1 @@\n+SELECT count() FROM format(TSVRaw, (SELECT cast(arrayStringConcat(groupArray('some long string'), '\\n'), 'LowCardinality(String)') FROM numbers(10000))) FORMAT TSVRaw;\n",
  "problem_statement": "Scalar doesn't exist for `format` function \n```sql\r\nSELECT *\r\nFROM format(TSVRaw, (\r\n    SELECT\r\n        '123',\r\n        '456'\r\n))\r\nFORMAT TSVRaw\r\n\r\nQuery id: c5e0b9f8-d055-4b5d-8e14-b695f8096ab0\r\n\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception:\r\nCode: 36. DB::Exception: Scalar `2451974040954057853_15236037560691200747` doesn't exist (internal bug): While processing __getScalar('2451974040954057853_15236037560691200747') AS constant_expression. (BAD_ARGUMENTS)\r\n```\n",
  "hints_text": "",
  "created_at": "2023-10-26T17:51:59Z",
  "modified_files": [
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/MutationsInterpreter.cpp",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/TreeRewriter.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02902_add_scalar_in_all_case.reference",
    "b/tests/queries/0_stateless/02902_add_scalar_in_all_case.sql"
  ]
}