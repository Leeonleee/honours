{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9543,
  "instance_id": "ClickHouse__ClickHouse-9543",
  "issue_numbers": [
    "8641"
  ],
  "base_commit": "c07cb384233bc0afc7b6e882bc5d23f0ce95ab3b",
  "patch": "diff --git a/dbms/src/Functions/FunctionsFindCluster.cpp b/dbms/src/Functions/FunctionsFindCluster.cpp\ndeleted file mode 100644\nindex 4f7caf8d536e..000000000000\n--- a/dbms/src/Functions/FunctionsFindCluster.cpp\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-#include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionsFindCluster.h>\n-\n-\n-namespace DB\n-{\n-\n-void registerFunctionsFindCluster(FunctionFactory & factory)\n-{\n-    factory.registerFunction<FunctionFindClusterIndex>();\n-    factory.registerFunction<FunctionFindClusterValue>();\n-}\n-\n-}\ndiff --git a/dbms/src/Functions/FunctionsFindCluster.h b/dbms/src/Functions/FunctionsFindCluster.h\ndeleted file mode 100644\nindex 26eb65640203..000000000000\n--- a/dbms/src/Functions/FunctionsFindCluster.h\n+++ /dev/null\n@@ -1,302 +0,0 @@\n-#pragma once\n-\n-#include <DataTypes/DataTypesNumber.h>\n-#include <DataTypes/DataTypeArray.h>\n-#include <Columns/ColumnArray.h>\n-#include <Columns/ColumnConst.h>\n-#include <Columns/ColumnsNumber.h>\n-\n-#include <Functions/IFunctionImpl.h>\n-#include <Functions/FunctionHelpers.h>\n-\n-#include <IO/WriteHelpers.h>\n-\n-#include <Common/typeid_cast.h>\n-\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int ILLEGAL_COLUMN;\n-}\n-\n-enum ClusterOperation\n-{\n-    FindClusterIndex = 0,\n-    FindCentroidValue = 1\n-};\n-\n-/// The centroid values are converted to Float64 for easier coding of\n-/// distance calculations.\n-///\n-/// We assume to have 10th to 100th centroids, usually of type Float64, as a typical use case.\n-/// While it is possible to sort centroids and use a modification of a binary search to find the\n-/// nearest centroid, we think for arrays of 10th to 100th this might be an overkill.\n-///\n-/// Also, even though centroids of other types are feasible, this first implementation\n-/// lacks support of them for simplicity. Date, DateTime and Strings (eg. with the\n-/// Levenshtein distance) could be theoretically supported, as well as custom distance\n-/// functions (eg. Hamming distance) using Clickhouse lambdas.\n-\n-// Centroids array has the same size as number of clusters.\n-inline size_t find_centroid(Float64 x, std::vector<Float64> & centroids)\n-{\n-    // Centroids array has to have at least one element, and if it has only one element,\n-    // it is also the result of this Function.\n-    Float64 distance = std::abs(centroids[0] - x);\n-    size_t index = 0;\n-\n-    // Check if we have more clusters and if we have, whether some is closer to src[i]\n-    for (size_t j = 1; j < centroids.size(); ++j)\n-    {\n-        Float64 next_distance = std::abs(centroids[j] - x);\n-\n-        if (next_distance < distance)\n-        {\n-            distance = next_distance;\n-            index = j;\n-        }\n-    }\n-\n-    // Index of the closest cluster, or 0 in case of just one cluster\n-    return index;\n-}\n-\n-/** findClusterIndex(x, centroids_array) - find index of element in centroids_array with the value nearest to x\n- * findClusterValue(x, centroids_array) - find value of element in centroids_array with the value nearest to x\n- *\n- * Types:\n- * findClusterIndex(T, Array(T)) -> UInt64\n- * findClusterValue(T, Array(T)) -> T\n- *\n- * T can be any numeric type.\n- * centroids_array must be constant\n- */\n-class FunctionFindClusterIndex : public IFunction\n-{\n-public:\n-    static constexpr auto name = \"findClusterIndex\";\n-    static FunctionPtr create(const Context &)\n-    {\n-        return std::make_shared<FunctionFindClusterIndex>();\n-    }\n-\n-    String getName() const override\n-    {\n-        return FunctionFindClusterIndex::name;\n-    }\n-\n-    bool isVariadic() const override\n-    {\n-        return true;\n-    }\n-\n-    size_t getNumberOfArguments() const override\n-    {\n-        return 0;\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        const auto args_size = arguments.size();\n-        if (args_size != 2)\n-            throw Exception{\"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(args_size) + \", should be 2\",\n-                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};\n-\n-        const auto type_x = arguments[0];\n-\n-        if (!isNativeNumber(type_x))\n-            throw Exception{\"Unsupported type \" + type_x->getName() + \" of first argument of function \" + getName() + \" must be a numeric type\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-\n-        const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n-\n-        if (!type_arr_from)\n-            throw Exception{\"Second argument of function \" + getName() + \" must be literal array\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-\n-        return std::make_shared<DataTypeUInt64>();\n-    }\n-\n-    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) override\n-    {\n-        const auto in_untyped = block.getByPosition(arguments[0]).column.get();\n-        const auto centroids_array_untyped = block.getByPosition(arguments[1]).column.get();\n-        auto column_result = block.getByPosition(result).type->createColumn();\n-        auto out_untyped = column_result.get();\n-\n-        if (!isColumnConst(*centroids_array_untyped))\n-            throw Exception{\"Second argument of function \" + getName() + \" must be literal array\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-\n-        executeImplTyped(in_untyped, out_untyped, centroids_array_untyped);\n-\n-        block.getByPosition(result).column = std::move(column_result);\n-    }\n-\n-protected:\n-    virtual ClusterOperation getOperation()\n-    {\n-        return ClusterOperation::FindClusterIndex;\n-    }\n-\n-    virtual void executeImplTyped(const IColumn* in_untyped, IColumn* out_untyped, const IColumn* centroids_array_untyped)\n-    {\n-        if (!executeOperation<UInt8, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<UInt16, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<UInt32, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<UInt64, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Int8, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Int16, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Int32, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Int64, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Float32, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-                && !executeOperation<Float64, UInt64>(in_untyped, out_untyped, centroids_array_untyped))\n-        {\n-            throw Exception{\"Function \" + getName() + \" expects both x and centroids_array of a numeric type.\"\n-                    \" Passed arguments are \" + in_untyped->getName() + \" and \" + centroids_array_untyped->getName(), ErrorCodes::ILLEGAL_COLUMN};\n-\n-        }\n-    }\n-\n-    // Match the type of the centrods array and convert them to Float64, because we\n-    // don't want to have problems calculating negative distances of UInts\n-    template <typename CentroidsType>\n-    bool fillCentroids(const IColumn * centroids_array_untyped, std::vector<Float64> & centroids)\n-    {\n-        const ColumnConst * const_centroids_array = checkAndGetColumnConst<ColumnVector<Array>>(centroids_array_untyped);\n-\n-        if (!const_centroids_array)\n-            return false;\n-\n-        Array array = const_centroids_array->getValue<Array>();\n-        if (array.empty())\n-            throw Exception{\"Centroids array must be not empty\", ErrorCodes::ILLEGAL_COLUMN};\n-\n-        for (size_t k = 0; k < array.size(); ++k)\n-        {\n-            const Field & tmp_field = array[k];\n-            NearestFieldType<CentroidsType> value;\n-            if (!tmp_field.tryGet(value))\n-                return false;\n-\n-            centroids.push_back(Float64(value));\n-        }\n-        return true;\n-    }\n-\n-    template <typename CentroidsType, typename OutputType>\n-    bool executeOperation(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * centroids_array_untyped)\n-    {\n-        // Match the type of the output\n-        auto out = typeid_cast<ColumnVector<OutputType> *>(out_untyped);\n-\n-        if (!out)\n-            return false;\n-\n-        PaddedPODArray<OutputType> & dst = out->getData();\n-\n-        // try to match the type of the input column\n-        if (!executeOperationTyped<UInt8, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<UInt16, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<UInt32, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<UInt64, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Int8, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Int16, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Int32, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Int64, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Float32, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped)\n-            && !executeOperationTyped<Float64, OutputType, CentroidsType>(in_untyped, dst, centroids_array_untyped))\n-        {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename InputType, typename OutputType, typename CentroidsType>\n-    bool executeOperationTyped(const IColumn * in_untyped, PaddedPODArray<OutputType> & dst, const IColumn * centroids_array_untyped)\n-    {\n-        const auto maybe_const = in_untyped->convertToFullColumnIfConst();\n-        in_untyped = maybe_const.get();\n-\n-        const auto in_vector = checkAndGetColumn<ColumnVector<InputType>>(in_untyped);\n-        if (in_vector)\n-        {\n-            const PaddedPODArray<InputType> & src = in_vector->getData();\n-\n-            std::vector<Float64> centroids;\n-            if (!fillCentroids<CentroidsType>(centroids_array_untyped, centroids))\n-                return false;\n-\n-            for (size_t i = 0; i < src.size(); ++i)\n-            {\n-                size_t index = find_centroid(Float64(src[i]), centroids);\n-                if (getOperation() == ClusterOperation::FindClusterIndex)\n-                    // Note that array indexes start with 1 in Clickhouse\n-                    dst.push_back(UInt64(index + 1));\n-                else if (getOperation() == ClusterOperation::FindCentroidValue)\n-                    dst.push_back(centroids[index]);\n-                else\n-                    throw Exception{\"Unexpected error in findCluster* function\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-            }\n-\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-};\n-\n-class FunctionFindClusterValue : public FunctionFindClusterIndex\n-{\n-public:\n-    static constexpr auto name = \"findClusterValue\";\n-    static FunctionPtr create(const Context &)\n-    {\n-        return std::make_shared<FunctionFindClusterValue>();\n-    }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        FunctionFindClusterIndex::getReturnTypeImpl(arguments);\n-        const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n-        return type_arr_from->getNestedType();\n-    }\n-\n-    String getName() const override\n-    {\n-        return FunctionFindClusterValue::name;\n-    }\n-\n-protected:\n-    ClusterOperation getOperation() override\n-    {\n-        return ClusterOperation::FindCentroidValue;\n-    }\n-\n-    void executeImplTyped(const IColumn* in_untyped, IColumn* out_untyped, const IColumn* centroids_array_untyped) override\n-    {\n-        if (!executeOperation<UInt8, UInt8>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<UInt16, UInt16>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<UInt32, UInt32>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<UInt64, UInt64>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Int8, Int8>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Int16, Int16>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Int32, Int32>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Int64, Int64>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Float32, Float32>(in_untyped, out_untyped, centroids_array_untyped)\n-            && !executeOperation<Float64, Float64>(in_untyped, out_untyped, centroids_array_untyped))\n-        {\n-            throw Exception{\"Function \" + getName() + \" expects both x and centroids_array of a numeric type.\"\n-                    \"Passed arguments are \" + in_untyped->getName() + \" and \" + centroids_array_untyped->getName(), ErrorCodes::ILLEGAL_COLUMN};\n-        }\n-    }\n-};\n-\n-}\ndiff --git a/dbms/src/Functions/registerFunctions.cpp b/dbms/src/Functions/registerFunctions.cpp\nindex 652e9a8b8afb..233018c7f16f 100644\n--- a/dbms/src/Functions/registerFunctions.cpp\n+++ b/dbms/src/Functions/registerFunctions.cpp\n@@ -35,7 +35,6 @@ void registerFunctionsMath(FunctionFactory &);\n void registerFunctionsGeo(FunctionFactory &);\n void registerFunctionsIntrospection(FunctionFactory &);\n void registerFunctionsNull(FunctionFactory &);\n-void registerFunctionsFindCluster(FunctionFactory &);\n void registerFunctionsJSON(FunctionFactory &);\n void registerFunctionsConsistentHashing(FunctionFactory & factory);\n \n@@ -74,7 +73,6 @@ void registerFunctions()\n     registerFunctionsMath(factory);\n     registerFunctionsGeo(factory);\n     registerFunctionsNull(factory);\n-    registerFunctionsFindCluster(factory);\n     registerFunctionsJSON(factory);\n     registerFunctionsIntrospection(factory);\n     registerFunctionsConsistentHashing(factory);\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00809_add_days_segfault.sql b/dbms/tests/queries/0_stateless/00809_add_days_segfault.sql\nindex b087f7bbde50..3d2e11ece775 100644\n--- a/dbms/tests/queries/0_stateless/00809_add_days_segfault.sql\n+++ b/dbms/tests/queries/0_stateless/00809_add_days_segfault.sql\n@@ -8,5 +8,5 @@ SET send_logs_level = 'none';\n \n SELECT ignore(addDays((CAST((96.338) AS DateTime)), -3));\n SELECT ignore(subtractDays((CAST((-5263074.47) AS DateTime)), -737895));\n-SELECT quantileDeterministic([], findClusterIndex(( SELECT subtractDays((CAST((566450.398706) AS DateTime)), 54) ) )), '\\0', []; -- { serverError 42 }\n+SELECT quantileDeterministic([], identity(( SELECT subtractDays((CAST((566450.398706) AS DateTime)), 54) ) )), '\\0', []; -- { serverError 43 }\n SELECT sequenceCount((CAST((( SELECT NULL ) AS rg, ( SELECT ( SELECT [], '<e', caseWithExpr([NULL], -588755.149, []), retention(addWeeks((CAST((-7644612.39732) AS DateTime)), -23578040.02833), (CAST(([]) AS DateTime)), (CAST(([010977.08]) AS String))), emptyArrayToSingle('') ) , '\\0', toUInt64([], 't3hw@'), '\\0', toStartOfQuarter(-4230.1872, []) ) ) AS Date))); -- { serverError 43 }\n",
  "problem_statement": "Fix or remove findClusterIndex, findClusterValue functions.\nIt looks like these functions don't work and we don't have tests for them.\r\n#937, #980\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/pull/937#issuecomment-314255963",
  "created_at": "2020-03-06T18:51:13Z"
}