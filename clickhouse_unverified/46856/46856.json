{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46856,
  "instance_id": "ClickHouse__ClickHouse-46856",
  "issue_numbers": [
    "46855"
  ],
  "base_commit": "52beeadac7413d29408d91cc7cc9db2128714614",
  "patch": "diff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex 75505a173cda..e824546f220a 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -1112,7 +1112,9 @@ class FunctionAnyHash : public IFunction\n             {\n                 ToType h;\n                 if constexpr (std::endian::native == std::endian::little)\n+                {\n                     h = apply(key, reinterpret_cast<const char *>(&vec_from[i]), sizeof(vec_from[i]));\n+                }\n                 else\n                 {\n                     char tmp_buffer[sizeof(vec_from[i])];\n@@ -1131,7 +1133,9 @@ class FunctionAnyHash : public IFunction\n \n             ToType h;\n             if constexpr (std::endian::native == std::endian::little)\n+            {\n                 h = apply(key, reinterpret_cast<const char *>(&value), sizeof(value));\n+            }\n             else\n             {\n                 char tmp_buffer[sizeof(value)];\n@@ -1271,7 +1275,7 @@ class FunctionAnyHash : public IFunction\n         {\n             /// NOTE: here, of course, you can do without the materialization of the column.\n             ColumnPtr full_column = col_from_const->convertToFullColumn();\n-            executeArray<first>(key, type, &*full_column, vec_to);\n+            executeArray<first>(key, type, full_column.get(), vec_to);\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n@@ -1283,6 +1287,10 @@ class FunctionAnyHash : public IFunction\n     {\n         WhichDataType which(from_type);\n \n+        if (icolumn->size() != vec_to.size())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Argument column '{}' size {} doesn't match result column size {} of function {}\",\n+                    icolumn->getName(), icolumn->size(), vec_to.size(), getName());\n+\n         if      (which.isUInt8()) executeIntType<UInt8, first>(key, icolumn, vec_to);\n         else if (which.isUInt16()) executeIntType<UInt16, first>(key, icolumn, vec_to);\n         else if (which.isUInt32()) executeIntType<UInt32, first>(key, icolumn, vec_to);\n@@ -1343,10 +1351,9 @@ class FunctionAnyHash : public IFunction\n             const auto & type_map = assert_cast<const DataTypeMap &>(*type);\n             executeForArgument(key, type_map.getNestedType().get(), map->getNestedColumnPtr().get(), vec_to, is_first);\n         }\n-        else if (const auto * const_map = checkAndGetColumnConstData<ColumnMap>(column))\n+        else if (const auto * const_map = checkAndGetColumnConst<ColumnMap>(column))\n         {\n-            const auto & type_map = assert_cast<const DataTypeMap &>(*type);\n-            executeForArgument(key, type_map.getNestedType().get(), const_map->getNestedColumnPtr().get(), vec_to, is_first);\n+            executeForArgument(key, type, const_map->convertToFullColumnIfConst().get(), vec_to, is_first);\n         }\n         else\n         {\n@@ -1382,8 +1389,7 @@ class FunctionAnyHash : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        size_t rows = input_rows_count;\n-        auto col_to = ColumnVector<ToType>::create(rows);\n+        auto col_to = ColumnVector<ToType>::create(input_rows_count);\n \n         typename ColumnVector<ToType>::Container & vec_to = col_to->getData();\n \n@@ -1395,7 +1401,7 @@ class FunctionAnyHash : public IFunction\n         if (arguments.size() <= first_data_argument)\n         {\n             /// Return a fixed random-looking magic number when input is empty\n-            vec_to.assign(rows, static_cast<ToType>(0xe28dbde7fe22e41c));\n+            vec_to.assign(input_rows_count, static_cast<ToType>(0xe28dbde7fe22e41c));\n         }\n \n         KeyType key{};\ndiff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp\nindex 1c30dee04820..1f25794536b4 100644\n--- a/src/Functions/IFunction.cpp\n+++ b/src/Functions/IFunction.cpp\n@@ -26,6 +26,7 @@\n #    pragma GCC diagnostic pop\n #endif\n \n+\n namespace DB\n {\n \n@@ -66,12 +67,12 @@ ColumnPtr replaceLowCardinalityColumnsByNestedAndGetDictionaryIndexes(\n \n             if (!low_cardinality_type)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Incompatible type for low cardinality column: {}\",\n+                    \"Incompatible type for LowCardinality column: {}\",\n                     column.type->getName());\n \n             if (can_be_executed_on_default_arguments)\n             {\n-                /// Normal case, when function can be executed on values's default.\n+                /// Normal case, when function can be executed on values' default.\n                 column.column = low_cardinality_column->getDictionary().getNestedColumn();\n                 indexes = low_cardinality_column->getIndexesPtr();\n             }\n@@ -280,6 +281,7 @@ ColumnPtr IExecutableFunction::executeWithoutSparseColumns(const ColumnsWithType\n \n             auto res = executeWithoutLowCardinalityColumns(columns_without_low_cardinality, dictionary_type, new_input_rows_count, dry_run);\n             bool res_is_constant = isColumnConst(*res);\n+\n             auto keys = res_is_constant\n                 ? res->cloneResized(1)->convertToFullColumnIfConst()\n                 : res;\ndiff --git a/src/Functions/map.cpp b/src/Functions/map.cpp\nindex 3160c5ddb437..7fd4d3aa6d5d 100644\n--- a/src/Functions/map.cpp\n+++ b/src/Functions/map.cpp\n@@ -332,7 +332,7 @@ class FunctionMapContainsKeyLike : public IFunction\n             }\n \n             size_t col_key_size = sub_map_column->size();\n-            auto column = is_const? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);\n+            auto column = is_const ? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);\n \n             ColumnsWithTypeAndName new_arguments =\n                 {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02673_map_hashing_msan.reference b/tests/queries/0_stateless/02673_map_hashing_msan.reference\nnew file mode 100644\nindex 000000000000..d3fbc1377d47\n--- /dev/null\n+++ b/tests/queries/0_stateless/02673_map_hashing_msan.reference\n@@ -0,0 +1,6 @@\n+4786021384179797717\n+5368498105280294197\n+42\t15687122600100720591\n+42\t15687122600100720591\n+42\t15687122600100720591\n+\\N\ndiff --git a/tests/queries/0_stateless/02673_map_hashing_msan.sql b/tests/queries/0_stateless/02673_map_hashing_msan.sql\nnew file mode 100644\nindex 000000000000..2fe3620e68ca\n--- /dev/null\n+++ b/tests/queries/0_stateless/02673_map_hashing_msan.sql\n@@ -0,0 +1,7 @@\n+SELECT cityHash64(map(1, 'Hello'), CAST(materialize('World') AS LowCardinality(String)));\n+SELECT cityHash64(map(), CAST(materialize('') AS LowCardinality(Nullable(String))));\n+SELECT materialize(42) as last_element, cityHash64(map(), CAST(materialize('') AS LowCardinality(Nullable(String))), last_element) from numbers(3);\n+\n+SET allow_suspicious_low_cardinality_types = 1;\n+CREATE TEMPORARY TABLE datetime__fuzz_14 (`d` LowCardinality(Nullable(UInt128)));\n+SELECT max(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048), toInt64(9223), 3, -2147))), toInt64(1048), map('11', 257, '', NULL), cityHash64(*)) > NULL FROM (SELECT max(cityHash64(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048), toInt64(2147), 655, -2147))), *)) > NULL, map(toInt64(-2147), toInt64(100.0001), -2147, NULL), mapPopulateSeries(map(toInt64(1024), toInt64(1048), 1048, -1)), map(toInt64(256), toInt64(NULL), -1, NULL), quantile(0.0001)(d) FROM datetime__fuzz_14 WITH TOTALS);\n",
  "problem_statement": "MSan report in ColumnUnique (LowCardinality)\n**How to reproduce**\r\n```\r\nmilovidov-desktop :) SET allow_suspicious_low_cardinality_types = 1\r\n\r\nSET allow_suspicious_low_cardinality_types = 1\r\n\r\nQuery id: 74086d0f-0d7c-4ef1-beee-dfa586bd712f\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n\r\nmilovidov-desktop :) CREATE TEMPORARY TABLE datetime__fuzz_14 (`d` LowCardinality(Nullable(UInt128)));\r\n\r\nCREATE TEMPORARY TABLE datetime__fuzz_14\r\n(\r\n    `d` LowCardinality(Nullable(UInt128))\r\n)\r\n\r\nQuery id: 5d8fc3d3-39cf-44cb-ae40-3161fbaf0263\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec. \r\n\r\nmilovidov-desktop :) SELECT max(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048575), toInt64(9223372036854775806), 3, -2147483649))), toInt64(1048575), map('11', 257, '', NULL), cityHash64(*)) > NULL FROM (SELECT max(cityHash64(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048575), toInt64(2147483646), 65537, -2147483649))), *)) > NULL, map(toInt64(-2147483647), toInt64(100.0001), -2147483647, NULL), mapPopulateSeries(map(toInt64(1024), toInt64(1048576), 1048575, -1)), map(toInt64(256), toInt64(NULL), -1, NULL), quantile(0.0001)(d) FROM datetime__fuzz_14 WITH TOTALS)\r\n\r\nSELECT max(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048575), toInt64(9223372036854775806), 3, -2147483649))), toInt64(1048575), map('11', 257, '', NULL), cityHash64(*)) > NULL\r\nFROM\r\n(\r\n    SELECT\r\n        max(cityHash64(mapPopulateSeries(mapPopulateSeries(map(toInt64(1048575), toInt64(2147483646), 65537, -2147483649))), *)) > NULL,\r\n        map(toInt64(-2147483647), toInt64(100.0001), -2147483647, NULL),\r\n        mapPopulateSeries(map(toInt64(1024), toInt64(1048576), 1048575, -1)),\r\n        map(toInt64(256), toInt64(NULL), -1, NULL),\r\n        quantile(0.0001)(d)\r\n    FROM datetime__fuzz_14\r\n        WITH TOTALS\r\n)\r\n```\r\n\n",
  "hints_text": "Minimal example: \r\n```\r\nSELECT cityHash64(map(), CAST(materialize('') AS LowCardinality(Nullable(String))))\r\n```",
  "created_at": "2023-02-25T07:55:01Z"
}