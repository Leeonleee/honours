diff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h
index 75505a173cda..e824546f220a 100644
--- a/src/Functions/FunctionsHashing.h
+++ b/src/Functions/FunctionsHashing.h
@@ -1112,7 +1112,9 @@ class FunctionAnyHash : public IFunction
             {
                 ToType h;
                 if constexpr (std::endian::native == std::endian::little)
+                {
                     h = apply(key, reinterpret_cast<const char *>(&vec_from[i]), sizeof(vec_from[i]));
+                }
                 else
                 {
                     char tmp_buffer[sizeof(vec_from[i])];
@@ -1131,7 +1133,9 @@ class FunctionAnyHash : public IFunction
 
             ToType h;
             if constexpr (std::endian::native == std::endian::little)
+            {
                 h = apply(key, reinterpret_cast<const char *>(&value), sizeof(value));
+            }
             else
             {
                 char tmp_buffer[sizeof(value)];
@@ -1271,7 +1275,7 @@ class FunctionAnyHash : public IFunction
         {
             /// NOTE: here, of course, you can do without the materialization of the column.
             ColumnPtr full_column = col_from_const->convertToFullColumn();
-            executeArray<first>(key, type, &*full_column, vec_to);
+            executeArray<first>(key, type, full_column.get(), vec_to);
         }
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}",
@@ -1283,6 +1287,10 @@ class FunctionAnyHash : public IFunction
     {
         WhichDataType which(from_type);
 
+        if (icolumn->size() != vec_to.size())
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Argument column '{}' size {} doesn't match result column size {} of function {}",
+                    icolumn->getName(), icolumn->size(), vec_to.size(), getName());
+
         if      (which.isUInt8()) executeIntType<UInt8, first>(key, icolumn, vec_to);
         else if (which.isUInt16()) executeIntType<UInt16, first>(key, icolumn, vec_to);
         else if (which.isUInt32()) executeIntType<UInt32, first>(key, icolumn, vec_to);
@@ -1343,10 +1351,9 @@ class FunctionAnyHash : public IFunction
             const auto & type_map = assert_cast<const DataTypeMap &>(*type);
             executeForArgument(key, type_map.getNestedType().get(), map->getNestedColumnPtr().get(), vec_to, is_first);
         }
-        else if (const auto * const_map = checkAndGetColumnConstData<ColumnMap>(column))
+        else if (const auto * const_map = checkAndGetColumnConst<ColumnMap>(column))
         {
-            const auto & type_map = assert_cast<const DataTypeMap &>(*type);
-            executeForArgument(key, type_map.getNestedType().get(), const_map->getNestedColumnPtr().get(), vec_to, is_first);
+            executeForArgument(key, type, const_map->convertToFullColumnIfConst().get(), vec_to, is_first);
         }
         else
         {
@@ -1382,8 +1389,7 @@ class FunctionAnyHash : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
-        size_t rows = input_rows_count;
-        auto col_to = ColumnVector<ToType>::create(rows);
+        auto col_to = ColumnVector<ToType>::create(input_rows_count);
 
         typename ColumnVector<ToType>::Container & vec_to = col_to->getData();
 
@@ -1395,7 +1401,7 @@ class FunctionAnyHash : public IFunction
         if (arguments.size() <= first_data_argument)
         {
             /// Return a fixed random-looking magic number when input is empty
-            vec_to.assign(rows, static_cast<ToType>(0xe28dbde7fe22e41c));
+            vec_to.assign(input_rows_count, static_cast<ToType>(0xe28dbde7fe22e41c));
         }
 
         KeyType key{};
diff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp
index 1c30dee04820..1f25794536b4 100644
--- a/src/Functions/IFunction.cpp
+++ b/src/Functions/IFunction.cpp
@@ -26,6 +26,7 @@
 #    pragma GCC diagnostic pop
 #endif
 
+
 namespace DB
 {
 
@@ -66,12 +67,12 @@ ColumnPtr replaceLowCardinalityColumnsByNestedAndGetDictionaryIndexes(
 
             if (!low_cardinality_type)
                 throw Exception(ErrorCodes::LOGICAL_ERROR,
-                    "Incompatible type for low cardinality column: {}",
+                    "Incompatible type for LowCardinality column: {}",
                     column.type->getName());
 
             if (can_be_executed_on_default_arguments)
             {
-                /// Normal case, when function can be executed on values's default.
+                /// Normal case, when function can be executed on values' default.
                 column.column = low_cardinality_column->getDictionary().getNestedColumn();
                 indexes = low_cardinality_column->getIndexesPtr();
             }
@@ -280,6 +281,7 @@ ColumnPtr IExecutableFunction::executeWithoutSparseColumns(const ColumnsWithType
 
             auto res = executeWithoutLowCardinalityColumns(columns_without_low_cardinality, dictionary_type, new_input_rows_count, dry_run);
             bool res_is_constant = isColumnConst(*res);
+
             auto keys = res_is_constant
                 ? res->cloneResized(1)->convertToFullColumnIfConst()
                 : res;
diff --git a/src/Functions/map.cpp b/src/Functions/map.cpp
index 3160c5ddb437..7fd4d3aa6d5d 100644
--- a/src/Functions/map.cpp
+++ b/src/Functions/map.cpp
@@ -332,7 +332,7 @@ class FunctionMapContainsKeyLike : public IFunction
             }
 
             size_t col_key_size = sub_map_column->size();
-            auto column = is_const? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);
+            auto column = is_const ? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);
 
             ColumnsWithTypeAndName new_arguments =
                 {
