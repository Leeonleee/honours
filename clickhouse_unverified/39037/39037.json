{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39037,
  "instance_id": "ClickHouse__ClickHouse-39037",
  "issue_numbers": [
    "38333"
  ],
  "base_commit": "7fd37d5c548b3b9d2a6bebb757cc6f222aeb007b",
  "patch": "diff --git a/src/Functions/FunctionDateOrDateTimeToSomething.h b/src/Functions/FunctionDateOrDateTimeToSomething.h\nindex 5269eecea374..d734c7f87c19 100644\n--- a/src/Functions/FunctionDateOrDateTimeToSomething.h\n+++ b/src/Functions/FunctionDateOrDateTimeToSomething.h\n@@ -148,8 +148,10 @@ class FunctionDateOrDateTimeToSomething : public IFunction\n         const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };\n         const IFunction::Monotonicity is_not_monotonic;\n \n-        /// This method is called only if the function has one argument. Therefore, we do not care about the non-local time zone.\n-        const DateLUTImpl & date_lut = DateLUT::instance();\n+        const DateLUTImpl * date_lut = &DateLUT::instance();\n+        if (const auto * timezone = dynamic_cast<const TimezoneMixin *>(&type))\n+            date_lut = &timezone->getTimeZone();\n+\n         if (left.isNull() || right.isNull())\n             return is_not_monotonic;\n \n@@ -157,20 +159,20 @@ class FunctionDateOrDateTimeToSomething : public IFunction\n \n         if (checkAndGetDataType<DataTypeDate>(&type))\n         {\n-            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), date_lut)\n-                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), date_lut)\n+            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), *date_lut)\n+                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), *date_lut)\n                 ? is_monotonic : is_not_monotonic;\n         }\n         else if (checkAndGetDataType<DataTypeDate32>(&type))\n         {\n-            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), date_lut)\n-                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), date_lut)\n+            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), *date_lut)\n+                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), *date_lut)\n                    ? is_monotonic : is_not_monotonic;\n         }\n         else\n         {\n-            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), date_lut)\n-                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), date_lut)\n+            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), *date_lut)\n+                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), *date_lut)\n                 ? is_monotonic : is_not_monotonic;\n         }\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.reference b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.reference\nnew file mode 100644\nindex 000000000000..5d49984b71ba\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.reference\n@@ -0,0 +1,1 @@\n+5\t8\t42\ndiff --git a/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.sql b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.sql\nnew file mode 100644\nindex 000000000000..5eb396970d78\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.sql\n@@ -0,0 +1,8 @@\n+drop table if exists test_tz_hour;\n+\n+create table test_tz_hour(t DateTime, x String) engine MergeTree partition by toYYYYMMDD(t) order by x;\n+insert into test_tz_hour select toDateTime('2021-06-01 00:00:00', 'UTC') + number * 600, 'x' from numbers(1e3);\n+\n+select toHour(toTimeZone(t, 'UTC')) as toHour_UTC, toHour(toTimeZone(t, 'Asia/Jerusalem')) as toHour_Israel, count() from test_tz_hour where toHour_Israel = 8 group by toHour_UTC, toHour_Israel;\n+\n+drop table test_tz_hour;\n",
  "problem_statement": "Index analysis doesn't work with toHour and Timezone condition\n**Describe what's wrong**\r\nFilter condition doesn't work correctly when functions like toHour are involved, I have another examples involved toDayOfWeek function as well where produced results are incorrect but I'll report in separate ticket about it.\r\n\r\n**Does it reproduce on recent release?**\r\nYes, verified as part of v22.3-lts\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use 21.12.4.1\r\n* Which interface to use, if matters: clickhouse-client\r\n* Queries to run that lead to unexpected result and \r\n\r\n##### Table definition\r\n```\r\nclickhouse-db-02.server.internal :) show create db.articles_ext_data;\r\n\r\nSHOW CREATE TABLE db.articles_ext_data\r\n\r\nQuery id: 383c56fa-21e0-4dae-bc78-9eb9adfd03b2\r\n\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:19:47.831837 [ 65324 ] {383c56fa-21e0-4dae-bc78-9eb9adfd03b2} <Debug> executeQuery: (from 127.0.0.1:43080) show create db.articles_ext_data;\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:19:47.831935 [ 65324 ] {383c56fa-21e0-4dae-bc78-9eb9adfd03b2} <Trace> ContextAccess (default): Access granted: SHOW COLUMNS ON db.articles_ext_data\r\n\u250c\u2500statement\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CREATE TABLE db.articles_ext_data\r\n(\r\n    `internal_id` String,\r\n    `timestamp` Nullable(DateTime('UTC')),\r\n    `url` Nullable(String),\r\n    `data_provider` String,\r\n    `document_length` UInt32,\r\n    `domain_name` String,\r\n    `is_near_duplicate` UInt8,\r\n    `publish_date` DateTime('UTC'),\r\n    `lang` Nullable(String),\r\n    `frames.label` Array(String),\r\n    `frames.score` Array(Float64),\r\n    `frames.version` Array(UInt32),\r\n    `frames.role` Array(Array(String)),\r\n    `frames.value` Array(Array(String)),\r\n    `frames.entity_id` Array(Array(UInt32)),\r\n    `frames.salience_score` Array(Array(Float64)),\r\n    `tags.id` Array(UInt32),\r\n    `frames.num_mentions` Array(UInt32),\r\n    `tags.name` Array(String),\r\n    `tags.score` Array(Float64),\r\n    `tags.tagger` Array(String),\r\n    `tags.checksum` Array(String),\r\n    `tags.type` Array(String),\r\n    `kpis.entity_id` Array(UInt32),\r\n    `kpis.salience_score` Array(Float64),\r\n    `kpis.num_mentions` Array(UInt32)\r\n)\r\nENGINE = ReplicatedMergeTree('/clickhouse/tables/replicated/db/articles_ext_data', 'clickhouse-db-02.server.internal')\r\nPARTITION BY toYYYYMMDD(publish_date)\r\nPRIMARY KEY cityHash64(internal_id)\r\nORDER BY cityHash64(internal_id)\r\nSAMPLE BY cityHash64(internal_id)\r\nSETTINGS index_granularity = 8192 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:19:47.833999 [ 65324 ] {383c56fa-21e0-4dae-bc78-9eb9adfd03b2} <Information> executeQuery: Read 1 rows, 1.22 KiB in 0.002124662 sec., 470 rows/sec., 575.46 KiB/sec.\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:19:47.834029 [ 65324 ] {383c56fa-21e0-4dae-bc78-9eb9adfd03b2} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n```\r\n```\r\n# Working Use Case\r\nSELECT\r\n    toHour(toTimeZone(publish_date, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(publish_date, 'Asia/Jerusalem')) AS toHour_Israel\r\nFROM db.articles_ext_data\r\nWHERE (publish_date >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (publish_date < toTimeZone(toDateTime('2021-09-30 23:59:59'), 'Asia/Jerusalem'))\r\nHAVING toHour_UTC = 5\r\nORDER BY toHour_UTC DESC\r\nLIMIT 10\r\n\r\nQuery id: 9032228d-a5ae-465b-985d-6cb5d8369ec8\r\n\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.827400 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> executeQuery: (from 127.0.0.1:43080) SELECT toHour(toTimeZone(publish_date, 'UTC')) AS toHour_UTC, toHour(toTimeZone(publish_date, 'Asia/Jerusalem')) AS toHour_Israel FROM db.articles_ext_data WHERE (publish_date >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (publish_date < toTimeZone(toDateTime('2021-09-30 23:59:59'), 'Asia/Jerusalem')) HAVING toHour_UTC = 5 ORDER BY toHour_UTC DESC LIMIT 10;\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.828408 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Trace> ContextAccess (default): Access granted: SELECT(publish_date) ON db.articles_ext_data\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.829203 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.829851 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): Key condition: unknown, unknown, and, unknown, and\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.841597 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): MinMax index condition: (column 0 in [1625097600, +Inf)), (column 0 in (-Inf, 1633046398]), and, (toHour(toTimezone(column 0)) in [5, 5]), and\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.843542 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): Selected 117/3088 parts by partition key, 117 parts by primary key, 5858/5858 marks by primary key, 5858 marks to read from 117 ranges\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.845501 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): Reading approx. 6585652 rows with 32 streams\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.853734 [ 53567 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> MergingSortedTransform: Merge sorted 1 blocks, 10 rows in 0.007999958 sec., 1250.0065625344535 rows/sec., 15.63 KiB/sec\r\n\u250c\u2500toHour_UTC\u2500\u252c\u2500toHour_Israel\u2500\u2510\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2502          5 \u2502             8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.854394 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Information> executeQuery: Read 6585652 rows, 25.12 MiB in 0.026937251 sec., 244481220 rows/sec., 932.62 MiB/sec.\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:11.854421 [ 65324 ] {9032228d-a5ae-465b-985d-6cb5d8369ec8} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\r\n\r\n10 rows in set. Elapsed: 0.028 sec. Processed 6.59 million rows, 26.34 MB (235.49 million rows/s., 941.98 MB/s.)\r\n\r\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Not Working Use Case\r\nSELECT\r\n    toHour(toTimeZone(publish_date, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(publish_date, 'Asia/Jerusalem')) AS toHour_Israel\r\nFROM db.articles_ext_data\r\nWHERE (publish_date >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (publish_date < toTimeZone(toDateTime('2021-09-30 23:59:59'), 'Asia/Jerusalem'))\r\nHAVING toHour_Israel = 8\r\nORDER BY toHour_Israel DESC\r\nLIMIT 10\r\n\r\nQuery id: c1c83e59-af83-40cc-b93e-d2a774186fa1\r\n\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.523436 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Debug> executeQuery: (from 127.0.0.1:43080) SELECT toHour(toTimeZone(publish_date, 'UTC')) AS toHour_UTC, toHour(toTimeZone(publish_date, 'Asia/Jerusalem')) AS toHour_Israel FROM db.articles_ext_data WHERE (publish_date >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (publish_date < toTimeZone(toDateTime('2021-09-30 23:59:59'), 'Asia/Jerusalem')) HAVING toHour_Israel = 8 ORDER BY toHour_Israel DESC LIMIT 10\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.524450 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Trace> ContextAccess (default): Access granted: SELECT(publish_date) ON db.articles_ext_data\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.525283 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.526006 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): Key condition: unknown, unknown, and, unknown, and\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.537831 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): MinMax index condition: (column 0 in [1625097600, +Inf)), (column 0 in (-Inf, 1633046398]), and, (toHour(toTimezone(column 0)) in [8, 8]), and\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.537893 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Debug> db.articles_ext_data (bf32f1f5-ce1c-44e3-bf32-f1f5ce1c24e3) (SelectExecutor): Selected 0/3088 parts by partition key, 0 parts by primary key, 0/0 marks by primary key, 0 marks to read from 0 ranges\r\n[clickhouse-db-02.server.internal] 2022.06.23 08:18:34.538562 [ 65324 ] {c1c83e59-af83-40cc-b93e-d2a774186fa1} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.016 sec.\r\n```\r\n\r\n**Expected behavior**\r\nThe expected results should be identical to the first query response regardless of condition **toHour_UTC = 5 or toHour_Israel = 8** applies\r\n\r\n**Additional context**\r\nOn small tables with syntenic data, I was unable to reproduce the issue, I also tried to copy data from one table to another with the same structure and after data migration completion the issue reproduces consistently.\r\nMight be related to https://github.com/ClickHouse/ClickHouse/issues/10977\r\n\r\n\n",
  "hints_text": "Are you sure you `toTimeZone(toDateTime (...) ...)` does what you need / meant?\r\n\r\n```\r\nWITH toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem') AS x\r\nSELECT\r\n    x,\r\n    toUnixTimestamp(x),\r\n    toTypeName(x)\r\n\r\nQuery id: 2a3862f8-e62b-4321-94a5-5a7da2a257da\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nx:                  2021-07-01 03:00:00\r\ntoUnixTimestamp(x): 1625097600\r\ntoTypeName(x):      DateTime('Asia/Jerusalem')\r\n\r\n```\r\n\r\nCompare it to (did you mean that?)\r\n\r\n```\r\nWITH toDateTime('2021-07-01 00:00:00', 'Asia/Jerusalem') AS x\r\nSELECT\r\n    x,\r\n    toUnixTimestamp(x),\r\n    toTypeName(x)\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nx:                  2021-07-01 00:00:00\r\ntoUnixTimestamp(x): 1625086800\r\ntoTypeName(x):      DateTime('Asia/Jerusalem')\r\n```\n@filimonov thanks for looking.\r\n\r\nWe are storing publish_date as UTC (defined in schema) so I want to represent UTC Timestamp according to Israel Timezone and filter the results based on Hour Number according to the required TimeZone!\r\n\r\nIn here everything is accurate:\r\n\r\n```\r\nWITH\r\n    toDateTime('2021-07-01 00:00:00', 'UTC') AS UTC,\r\n    toHour(UTC) AS UTC_HOUR,\r\n    toTimeZone(toDateTime('2021-07-01 00:00:00', 'UTC'), 'Asia/Jerusalem') AS IDT,\r\n    toHour(IDT) AS IDT_HOUR\r\nSELECT\r\n    UTC,\r\n    UTC_HOUR,\r\n    toUnixTimestamp(UTC),\r\n    toTypeName(UTC),\r\n    IDT,\r\n    IDT_HOUR,\r\n    toUnixTimestamp(IDT),\r\n    toTypeName(IDT)\r\n\r\nQuery id: 53bfcd18-2610-411e-b8e8-e6d9a4d23496\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500UTC\u2500\u252c\u2500UTC_HOUR\u2500\u252c\u2500toUnixTimestamp(UTC)\u2500\u252c\u2500toTypeName(UTC)\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500IDT\u2500\u252c\u2500IDT_HOUR\u2500\u252c\u2500toUnixTimestamp(IDT)\u2500\u252c\u2500toTypeName(IDT)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 2021-07-01 00:00:00 \u2502        0 \u2502           1625097600 \u2502 DateTime('UTC') \u2502 2021-07-01 03:00:00 \u2502        3 \u2502           1625097600 \u2502 DateTime('Asia/Jerusalem') \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.020 sec.\r\n```\r\n\r\n\n@filimonov one more time I want to emphasize that on small tables things are working correctly \nCan you try to create a reproducable example? \n@pavelnemirovsky Please share `select timezone()`\n@den-crane \r\n```\r\nclickhouse-db-01. server.internal :) select timezone();\r\n\r\nSELECT timezone()\r\n\r\nQuery id: fd5b55ab-3f3b-43d4-9fd9-dada53e76eb8\r\n\r\n\u250c\u2500timezone()\u2500\u2510\r\n\u2502 Etc/UTC    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n```\n@filimonov I tried a lot, I wish I could provide an exact recipe, but on my data, it is reproducible regardless of how many times I am rebuilding the table using **INSERT INTO** from the original table.\n@pavelnemirovsky \r\n\r\n```\r\nselect partition, name, rows, min_date, max_date, min_time, max_time\r\nfrom system.parts\r\nwhere table = 'articles_ext_data' and active\r\nformat CSV\r\n```\r\n\n@den-crane \r\nAttached\r\n[results.txt](https://github.com/ClickHouse/ClickHouse/files/9001341/results.txt)\r\n\nrepro:\r\n\r\n```sql\r\ndrop table if exists test_tz_hour;\r\nCREATE TABLE test_tz_hour( t DateTime,  x String ) ENGINE = MergeTree PARTITION BY toYYYYMMDD(t) ORDER BY x;\r\n\r\ninsert into  test_tz_hour select  toDateTime('2021-06-01 00:00:00') + number * 600, 'x' from numbers(1e4);\r\n\r\nselect count(), toHour_UTC, toHour_Israel from (\r\nSELECT\r\n    toHour(toTimeZone(t, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(t, 'Asia/Jerusalem')) AS toHour_Israel\r\nFROM test_tz_hour\r\nWHERE (t >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (t < toTimeZone(toDateTime('2021-07-31 23:59:59'), 'Asia/Jerusalem'))\r\nHAVING toHour_UTC = 5\r\nORDER BY toHour_UTC DESC)\r\ngroup by toHour_UTC, toHour_Israel\r\n\r\n\u250c\u2500count()\u2500\u252c\u2500toHour_UTC\u2500\u252c\u2500toHour_Israel\u2500\u2510\r\n\u2502     186 \u2502          5 \u2502             8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect count(), toHour_UTC, toHour_Israel from (\r\nSELECT\r\n    toHour(toTimeZone(t, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(t, 'Asia/Jerusalem')) AS toHour_Israel\r\nFROM test_tz_hour\r\nWHERE (t >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (t < toTimeZone(toDateTime('2021-07-31 23:59:59'), 'Asia/Jerusalem'))\r\nHAVING (toHour_Israel) = 8\r\nORDER BY toHour_UTC DESC)\r\ngroup by toHour_UTC, toHour_Israel\r\n\r\n0 rows in set. Elapsed: 0.007 sec.\r\n```\r\n+ HAVING **materialize**(toHour_Israel) = 8 / HAVING **identity**(toHour_Israel) = 8\r\n\r\n```sql\r\nselect count(), toHour_UTC, toHour_Israel from (\r\nSELECT\r\n    toHour(toTimeZone(t, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(t, 'Asia/Jerusalem')) AS toHour_Israel\r\nFROM test_tz_hour\r\nWHERE (t >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (t < toTimeZone(toDateTime('2021-07-31 23:59:59'), 'Asia/Jerusalem'))\r\nHAVING materialize(toHour_Israel) = 8\r\nORDER BY toHour_UTC DESC)\r\ngroup by toHour_UTC, toHour_Israel\r\n\u250c\u2500count()\u2500\u252c\u2500toHour_UTC\u2500\u252c\u2500toHour_Israel\u2500\u2510\r\n\u2502     186 \u2502          5 \u2502             8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@pavelnemirovsky  you misuse toTimeZone, it's actually doing nothing here, but it does not related to the issue.\r\n\r\nyou should use probably `toDateTime('2021-07-01 00:00:00', 'Asia/Jerusalem')`\n```sql\r\ndrop table if exists test_tz_hour;\r\nCREATE TABLE test_tz_hour( t DateTime,  x String ) ENGINE = MergeTree PARTITION BY toYYYYMMDD(t) ORDER BY x;\r\n\r\ninsert into  test_tz_hour select  toDateTime('2021-06-01 00:00:00') + number * 600, 'x' from numbers(1e3);\r\n\r\nSELECT\r\n    toHour(toTimeZone(t, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(t, 'Asia/Jerusalem')) AS toHour_Israel,\r\n    count()\r\nFROM test_tz_hour\r\nwhere (toHour_Israel) = 8\r\ngroup by toHour_UTC, toHour_Israel;\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n\r\n-- +identity\r\nSELECT\r\n    toHour(toTimeZone(t, 'UTC')) AS toHour_UTC,\r\n    toHour(toTimeZone(t, 'Asia/Jerusalem')) AS toHour_Israel,\r\n    count()\r\nFROM test_tz_hour\r\nwhere identity(toHour_Israel) = 8\r\ngroup by toHour_UTC, toHour_Israel;\r\n\u250c\u2500toHour_UTC\u2500\u252c\u2500toHour_Israel\u2500\u252c\u2500count()\u2500\u2510\r\n\u2502          5 \u2502             8 \u2502      42 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.006 sec. Processed 1.00 thousand rows, 4.00 KB (161.96 thousand rows/s., 647.82 KB/s.)\r\n```\nhm, no issue in 21.8.13.6, it was introduced in 21.9\n>  no issue in 21.8.13.6\r\n\r\n`toHour()` monotonicity is broken from the very beginning. The result why it works is because we don't support `toTimeZone(t, 'Asia/Jerusalem')` in index analysis in 21.8\n@den-crane @amosbird thank you, guys.\n@den-crane https://github.com/ClickHouse/ClickHouse/issues/38333#issuecomment-1171686192 I assume you are referring to this mistake https://github.com/ClickHouse/ClickHouse/issues/38333#issuecomment-1165382415 but it is notactually not mine \ud83d\ude09 \n@pavelnemirovsky I see weirdness in  your original message\r\n\r\n```\r\nWHERE (publish_date >= toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem')) AND (publish_date < toTimeZone(toDateTime('2021-09-30 23:59:59'), 'Asia/Jerusalem'))\r\n```\r\n\r\nfrom my perspective, expected\r\n```\r\nWHERE (publish_date >= toDateTime('2021-07-01 00:00:00', 'Asia/Jerusalem') AND (publish_date < toDateTime('2021-09-30 23:59:59', 'Asia/Jerusalem')\r\n```\r\n\r\nbecause toTimeZone https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions/#totimezone\r\nis not applicable here.\r\n\r\n\r\n\r\n\n@den-crane I agree that under where condition **toTimeZone(toDateTime('2021-07-01 00:00:00'), 'Asia/Jerusalem'))** doesn't make sense since it's being converted to unixstamp it anyway, I just wanted to show a more self explainable example.",
  "created_at": "2022-07-08T17:22:01Z",
  "modified_files": [
    "src/Functions/FunctionDateOrDateTimeToSomething.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.reference",
    "b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix.sql"
  ]
}