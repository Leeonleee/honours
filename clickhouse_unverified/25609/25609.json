{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25609,
  "instance_id": "ClickHouse__ClickHouse-25609",
  "issue_numbers": [
    "25422"
  ],
  "base_commit": "9b01ded17a1c2aeec541e1cd3f5c13636ae86047",
  "patch": "diff --git a/src/Common/hex.cpp b/src/Common/hex.cpp\nindex bad1bf19b8de..e8f9b9810620 100644\n--- a/src/Common/hex.cpp\n+++ b/src/Common/hex.cpp\n@@ -56,3 +56,37 @@ const char * const hex_char_to_digit_table =\n     \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n     \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n     \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\";\n+\n+const char * const bin_byte_to_char_table =\n+    \"0000000000000001000000100000001100000100000001010000011000000111\"\n+    \"0000100000001001000010100000101100001100000011010000111000001111\"\n+    \"0001000000010001000100100001001100010100000101010001011000010111\"\n+    \"0001100000011001000110100001101100011100000111010001111000011111\"\n+    \"0010000000100001001000100010001100100100001001010010011000100111\"\n+    \"0010100000101001001010100010101100101100001011010010111000101111\"\n+    \"0011000000110001001100100011001100110100001101010011011000110111\"\n+    \"0011100000111001001110100011101100111100001111010011111000111111\"\n+    \"0100000001000001010000100100001101000100010001010100011001000111\"\n+    \"0100100001001001010010100100101101001100010011010100111001001111\"\n+    \"0101000001010001010100100101001101010100010101010101011001010111\"\n+    \"0101100001011001010110100101101101011100010111010101111001011111\"\n+    \"0110000001100001011000100110001101100100011001010110011001100111\"\n+    \"0110100001101001011010100110101101101100011011010110111001101111\"\n+    \"0111000001110001011100100111001101110100011101010111011001110111\"\n+    \"0111100001111001011110100111101101111100011111010111111001111111\"\n+    \"1000000010000001100000101000001110000100100001011000011010000111\"\n+    \"1000100010001001100010101000101110001100100011011000111010001111\"\n+    \"1001000010010001100100101001001110010100100101011001011010010111\"\n+    \"1001100010011001100110101001101110011100100111011001111010011111\"\n+    \"1010000010100001101000101010001110100100101001011010011010100111\"\n+    \"1010100010101001101010101010101110101100101011011010111010101111\"\n+    \"1011000010110001101100101011001110110100101101011011011010110111\"\n+    \"1011100010111001101110101011101110111100101111011011111010111111\"\n+    \"1100000011000001110000101100001111000100110001011100011011000111\"\n+    \"1100100011001001110010101100101111001100110011011100111011001111\"\n+    \"1101000011010001110100101101001111010100110101011101011011010111\"\n+    \"1101100011011001110110101101101111011100110111011101111011011111\"\n+    \"1110000011100001111000101110001111100100111001011110011011100111\"\n+    \"1110100011101001111010101110101111101100111011011110111011101111\"\n+    \"1111000011110001111100101111001111110100111101011111011011110111\"\n+    \"1111100011111001111110101111101111111100111111011111111011111111\";\ndiff --git a/src/Common/hex.h b/src/Common/hex.h\nindex a1fa7b324658..82eff7762445 100644\n--- a/src/Common/hex.h\n+++ b/src/Common/hex.h\n@@ -39,6 +39,12 @@ inline void writeHexByteLowercase(UInt8 byte, void * out)\n     memcpy(out, &hex_byte_to_char_lowercase_table[static_cast<size_t>(byte) * 2], 2);\n }\n \n+extern const char * const bin_byte_to_char_table;\n+\n+inline void writeBinByte(UInt8 byte, void * out)\n+{\n+    memcpy(out, &bin_byte_to_char_table[static_cast<size_t>(byte) * 8], 8);\n+}\n \n /// Produces hex representation of an unsigned int with leading zeros (for checksums)\n template <typename TUInt>\ndiff --git a/src/Functions/FunctionsCoding.cpp b/src/Functions/FunctionsCoding.cpp\nindex 150d792f63b8..f1bbeb5c43f0 100644\n--- a/src/Functions/FunctionsCoding.cpp\n+++ b/src/Functions/FunctionsCoding.cpp\n@@ -21,6 +21,8 @@ void registerFunctionsCoding(FunctionFactory & factory)\n     factory.registerFunction<FunctionUUIDStringToNum>();\n     factory.registerFunction<FunctionHex>(FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionUnhex>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<FunctionBin>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<FunctionUnbin>(FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionChar>(FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionBitmaskToArray>();\n     factory.registerFunction<FunctionBitPositionsToArray>();\ndiff --git a/src/Functions/FunctionsCoding.h b/src/Functions/FunctionsCoding.h\nindex da667bfc691e..72f2aa1be1c7 100644\n--- a/src/Functions/FunctionsCoding.h\n+++ b/src/Functions/FunctionsCoding.h\n@@ -65,7 +65,6 @@ namespace ErrorCodes\n constexpr size_t uuid_bytes_length = 16;\n constexpr size_t uuid_text_length = 36;\n \n-\n class FunctionIPv6NumToString : public IFunction\n {\n public:\n@@ -951,19 +950,22 @@ class FunctionUUIDStringToNum : public IFunction\n     }\n };\n \n-\n-class FunctionHex : public IFunction\n+/// Encode number or string to string with binary or hexadecimal representation\n+template <typename Impl>\n+class EncodeToBinaryRepr : public IFunction\n {\n public:\n-    static constexpr auto name = \"hex\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionHex>(); }\n+    static constexpr auto name = Impl::name;\n+    static constexpr size_t word_size = Impl::word_size;\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<EncodeToBinaryRepr>(); }\n+\n+    String getName() const override { return name; }\n \n     size_t getNumberOfArguments() const override { return 1; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n     bool isInjective(const ColumnsWithTypeAndName &) const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n@@ -983,25 +985,27 @@ class FunctionHex : public IFunction\n         return std::make_shared<DataTypeString>();\n     }\n \n-    template <typename T>\n-    void executeOneUInt(T x, char *& out) const\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        bool was_nonzero = false;\n-        for (int offset = (sizeof(T) - 1) * 8; offset >= 0; offset -= 8)\n-        {\n-            UInt8 byte = x >> offset;\n-\n-            /// Leading zeros.\n-            if (byte == 0 && !was_nonzero && offset)  // -V560\n-                continue;\n+        const IColumn * column = arguments[0].column.get();\n+        ColumnPtr res_column;\n \n-            was_nonzero = true;\n+        if (tryExecuteUInt<UInt8>(column, res_column) ||\n+            tryExecuteUInt<UInt16>(column, res_column) ||\n+            tryExecuteUInt<UInt32>(column, res_column) ||\n+            tryExecuteUInt<UInt64>(column, res_column) ||\n+            tryExecuteString(column, res_column) ||\n+            tryExecuteFixedString(column, res_column) ||\n+            tryExecuteFloat<Float32>(column, res_column) ||\n+            tryExecuteFloat<Float64>(column, res_column) ||\n+            tryExecuteDecimal<Decimal32>(column, res_column) ||\n+            tryExecuteDecimal<Decimal64>(column, res_column) ||\n+            tryExecuteDecimal<Decimal128>(column, res_column))\n+            return res_column;\n \n-            writeHexByteUppercase(byte, out);\n-            out += 2;\n-        }\n-        *out = '\\0';\n-        ++out;\n+        throw Exception(\"Illegal column \" + arguments[0].column->getName()\n+                        + \" of argument of function \" + getName(),\n+                        ErrorCodes::ILLEGAL_COLUMN);\n     }\n \n     template <typename T>\n@@ -1009,7 +1013,7 @@ class FunctionHex : public IFunction\n     {\n         const ColumnVector<T> * col_vec = checkAndGetColumn<ColumnVector<T>>(col);\n \n-        static constexpr size_t MAX_UINT_HEX_LENGTH = sizeof(T) * 2 + 1;    /// Including trailing zero byte.\n+        static constexpr size_t MAX_LENGTH = sizeof(T) * word_size + 1;    /// Including trailing zero byte.\n \n         if (col_vec)\n         {\n@@ -1021,23 +1025,22 @@ class FunctionHex : public IFunction\n \n             size_t size = in_vec.size();\n             out_offsets.resize(size);\n-            out_vec.resize(size * 3 + MAX_UINT_HEX_LENGTH); /// 3 is length of one byte in hex plus zero byte.\n+            out_vec.resize(size * (word_size+1) + MAX_LENGTH); /// word_size+1 is length of one byte in hex/bin plus zero byte.\n \n             size_t pos = 0;\n             for (size_t i = 0; i < size; ++i)\n             {\n                 /// Manual exponential growth, so as not to rely on the linear amortized work time of `resize` (no one guarantees it).\n-                if (pos + MAX_UINT_HEX_LENGTH > out_vec.size())\n-                    out_vec.resize(out_vec.size() * 2 + MAX_UINT_HEX_LENGTH);\n+                if (pos + MAX_LENGTH > out_vec.size())\n+                    out_vec.resize(out_vec.size() * word_size + MAX_LENGTH);\n \n                 char * begin = reinterpret_cast<char *>(&out_vec[pos]);\n                 char * end = begin;\n-                executeOneUInt<T>(in_vec[i], end);\n+                Impl::executeOneUInt(in_vec[i], end);\n \n                 pos += end - begin;\n                 out_offsets[i] = pos;\n             }\n-\n             out_vec.resize(pos);\n \n             col_res = std::move(col_str);\n@@ -1049,78 +1052,7 @@ class FunctionHex : public IFunction\n         }\n     }\n \n-    template <typename T>\n-    void executeFloatAndDecimal(const T & in_vec, ColumnPtr & col_res, const size_t type_size_in_bytes) const\n-    {\n-        const size_t hex_length = type_size_in_bytes * 2 + 1; /// Including trailing zero byte.\n-        auto col_str = ColumnString::create();\n-\n-        ColumnString::Chars & out_vec = col_str->getChars();\n-        ColumnString::Offsets & out_offsets = col_str->getOffsets();\n-\n-        size_t size = in_vec.size();\n-        out_offsets.resize(size);\n-        out_vec.resize(size * hex_length);\n-\n-        size_t pos = 0;\n-        char * out = reinterpret_cast<char *>(&out_vec[0]);\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            const UInt8 * in_pos = reinterpret_cast<const UInt8 *>(&in_vec[i]);\n-            executeOneString(in_pos, in_pos + type_size_in_bytes, out);\n-\n-            pos += hex_length;\n-            out_offsets[i] = pos;\n-        }\n-        col_res = std::move(col_str);\n-    }\n-\n-    template <typename T>\n-    bool tryExecuteFloat(const IColumn * col, ColumnPtr & col_res) const\n-    {\n-        const ColumnVector<T> * col_vec = checkAndGetColumn<ColumnVector<T>>(col);\n-        if (col_vec)\n-        {\n-            const typename ColumnVector<T>::Container & in_vec = col_vec->getData();\n-            executeFloatAndDecimal<typename ColumnVector<T>::Container>(in_vec, col_res, sizeof(T));\n-            return true;\n-        }\n-        else\n-        {\n-            return false;\n-        }\n-    }\n-\n-    template <typename T>\n-    bool tryExecuteDecimal(const IColumn * col, ColumnPtr & col_res) const\n-    {\n-        const ColumnDecimal<T> * col_dec = checkAndGetColumn<ColumnDecimal<T>>(col);\n-        if (col_dec)\n-        {\n-            const typename ColumnDecimal<T>::Container & in_vec = col_dec->getData();\n-            executeFloatAndDecimal<typename ColumnDecimal<T>::Container>(in_vec, col_res, sizeof(T));\n-            return true;\n-        }\n-        else\n-        {\n-            return false;\n-        }\n-    }\n-\n-\n-    static void executeOneString(const UInt8 * pos, const UInt8 * end, char *& out)\n-    {\n-        while (pos < end)\n-        {\n-            writeHexByteUppercase(*pos, out);\n-            ++pos;\n-            out += 2;\n-        }\n-        *out = '\\0';\n-        ++out;\n-    }\n-\n-    static bool tryExecuteString(const IColumn * col, ColumnPtr & col_res)\n+    bool tryExecuteString(const IColumn *col, ColumnPtr &col_res) const\n     {\n         const ColumnString * col_str_in = checkAndGetColumn<ColumnString>(col);\n \n@@ -1134,8 +1066,10 @@ class FunctionHex : public IFunction\n             const ColumnString::Offsets & in_offsets = col_str_in->getOffsets();\n \n             size_t size = in_offsets.size();\n+\n             out_offsets.resize(size);\n-            out_vec.resize(in_vec.size() * 2 - size);\n+            /// reserve `word_size` bytes for each non trailing zero byte from input + `size` bytes for trailing zeros\n+            out_vec.resize((in_vec.size() - size) * word_size + size);\n \n             char * begin = reinterpret_cast<char *>(out_vec.data());\n             char * pos = begin;\n@@ -1145,13 +1079,12 @@ class FunctionHex : public IFunction\n             {\n                 size_t new_offset = in_offsets[i];\n \n-                executeOneString(&in_vec[prev_offset], &in_vec[new_offset - 1], pos);\n+                Impl::executeOneString(&in_vec[prev_offset], &in_vec[new_offset - 1], pos);\n \n                 out_offsets[i] = pos - begin;\n \n                 prev_offset = new_offset;\n             }\n-\n             if (!out_offsets.empty() && out_offsets.back() != out_vec.size())\n                 throw Exception(\"Column size mismatch (internal logical error)\", ErrorCodes::LOGICAL_ERROR);\n \n@@ -1164,44 +1097,76 @@ class FunctionHex : public IFunction\n         }\n     }\n \n+    template <typename T>\n+    bool tryExecuteDecimal(const IColumn * col, ColumnPtr & col_res) const\n+    {\n+        const ColumnDecimal<T> * col_dec = checkAndGetColumn<ColumnDecimal<T>>(col);\n+        if (col_dec)\n+        {\n+            const typename ColumnDecimal<T>::Container & in_vec = col_dec->getData();\n+            Impl::executeFloatAndDecimal(in_vec, col_res, sizeof(T));\n+            return true;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+    }\n+\n     static bool tryExecuteFixedString(const IColumn * col, ColumnPtr & col_res)\n     {\n-        const ColumnFixedString * col_fstr_in = checkAndGetColumn<ColumnFixedString>(col);\n+         const ColumnFixedString * col_fstr_in = checkAndGetColumn<ColumnFixedString>(col);\n \n-        if (col_fstr_in)\n-        {\n-            auto col_str = ColumnString::create();\n-            ColumnString::Chars & out_vec = col_str->getChars();\n-            ColumnString::Offsets & out_offsets = col_str->getOffsets();\n+         if (col_fstr_in)\n+         {\n+             auto col_str = ColumnString::create();\n+             ColumnString::Chars & out_vec = col_str->getChars();\n+             ColumnString::Offsets & out_offsets = col_str->getOffsets();\n \n-            const ColumnString::Chars & in_vec = col_fstr_in->getChars();\n+             const ColumnString::Chars & in_vec = col_fstr_in->getChars();\n \n-            size_t size = col_fstr_in->size();\n+             size_t size = col_fstr_in->size();\n \n-            out_offsets.resize(size);\n-            out_vec.resize(in_vec.size() * 2 + size);\n+             out_offsets.resize(size);\n+             out_vec.resize(in_vec.size() * word_size + size);\n \n-            char * begin = reinterpret_cast<char *>(out_vec.data());\n-            char * pos = begin;\n+             char * begin = reinterpret_cast<char *>(out_vec.data());\n+             char * pos = begin;\n \n-            size_t n = col_fstr_in->getN();\n+             size_t n = col_fstr_in->getN();\n \n-            size_t prev_offset = 0;\n+             size_t prev_offset = 0;\n \n-            for (size_t i = 0; i < size; ++i)\n-            {\n-                size_t new_offset = prev_offset + n;\n+             for (size_t i = 0; i < size; ++i)\n+             {\n+                 size_t new_offset = prev_offset + n;\n \n-                executeOneString(&in_vec[prev_offset], &in_vec[new_offset], pos);\n+                 Impl::executeOneString(&in_vec[prev_offset], &in_vec[new_offset], pos);\n \n-                out_offsets[i] = pos - begin;\n-                prev_offset = new_offset;\n-            }\n+                 out_offsets[i] = pos - begin;\n+                 prev_offset = new_offset;\n+             }\n \n-            if (!out_offsets.empty() && out_offsets.back() != out_vec.size())\n-                throw Exception(\"Column size mismatch (internal logical error)\", ErrorCodes::LOGICAL_ERROR);\n+             if (!out_offsets.empty() && out_offsets.back() != out_vec.size())\n+                 throw Exception(\"Column size mismatch (internal logical error)\", ErrorCodes::LOGICAL_ERROR);\n \n-            col_res = std::move(col_str);\n+             col_res = std::move(col_str);\n+             return true;\n+         }\n+         else\n+         {\n+             return false;\n+         }\n+     }\n+\n+    template <typename T>\n+    bool tryExecuteFloat(const IColumn * col, ColumnPtr & col_res) const\n+    {\n+        const ColumnVector<T> * col_vec = checkAndGetColumn<ColumnVector<T>>(col);\n+        if (col_vec)\n+        {\n+            const typename ColumnVector<T>::Container & in_vec = col_vec->getData();\n+            Impl::executeFloatAndDecimal(in_vec, col_res, sizeof(T));\n             return true;\n         }\n         else\n@@ -1209,44 +1174,18 @@ class FunctionHex : public IFunction\n             return false;\n         }\n     }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n-    {\n-        const IColumn * column = arguments[0].column.get();\n-        ColumnPtr res_column;\n-\n-        if (tryExecuteUInt<UInt8>(column, res_column) ||\n-            tryExecuteUInt<UInt16>(column, res_column) ||\n-            tryExecuteUInt<UInt32>(column, res_column) ||\n-            tryExecuteUInt<UInt64>(column, res_column) ||\n-            tryExecuteString(column, res_column) ||\n-            tryExecuteFixedString(column, res_column) ||\n-            tryExecuteFloat<Float32>(column, res_column) ||\n-            tryExecuteFloat<Float64>(column, res_column) ||\n-            tryExecuteDecimal<Decimal32>(column, res_column) ||\n-            tryExecuteDecimal<Decimal64>(column, res_column) ||\n-            tryExecuteDecimal<Decimal128>(column, res_column))\n-            return res_column;\n-\n-        throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                        + \" of argument of function \" + getName(),\n-                        ErrorCodes::ILLEGAL_COLUMN);\n-    }\n };\n \n-\n-class FunctionUnhex : public IFunction\n+/// Decode number or string from string with binary or hexadecimal representation\n+template <typename Impl>\n+class DecodeFromBinaryRepr : public IFunction\n {\n public:\n-    static constexpr auto name = \"unhex\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionUnhex>(); }\n+    static constexpr auto name = Impl::name;\n+    static constexpr size_t word_size = Impl::word_size;\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<DecodeFromBinaryRepr>(); }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    String getName() const override { return name; }\n \n     size_t getNumberOfArguments() const override { return 1; }\n     bool isInjective(const ColumnsWithTypeAndName &) const override { return true; }\n@@ -1255,29 +1194,11 @@ class FunctionUnhex : public IFunction\n     {\n         if (!isString(arguments[0]))\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeString>();\n     }\n \n-    static void unhexOne(const char * pos, const char * end, char *& out)\n-    {\n-        if ((end - pos) & 1)\n-        {\n-            *out = unhex(*pos);\n-            ++out;\n-            ++pos;\n-        }\n-        while (pos < end)\n-        {\n-            *out = unhex2(pos);\n-            pos += 2;\n-            ++out;\n-        }\n-        *out = '\\0';\n-        ++out;\n-    }\n-\n     bool useDefaultImplementationForConstants() const override { return true; }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n@@ -1296,7 +1217,7 @@ class FunctionUnhex : public IFunction\n \n             size_t size = in_offsets.size();\n             out_offsets.resize(size);\n-            out_vec.resize(in_vec.size() / 2 + size);\n+            out_vec.resize(in_vec.size() / word_size + size);\n \n             char * begin = reinterpret_cast<char *>(out_vec.data());\n             char * pos = begin;\n@@ -1306,7 +1227,7 @@ class FunctionUnhex : public IFunction\n             {\n                 size_t new_offset = in_offsets[i];\n \n-                unhexOne(reinterpret_cast<const char *>(&in_vec[prev_offset]), reinterpret_cast<const char *>(&in_vec[new_offset - 1]), pos);\n+                Impl::decode(reinterpret_cast<const char *>(&in_vec[prev_offset]), reinterpret_cast<const char *>(&in_vec[new_offset - 1]), pos);\n \n                 out_offsets[i] = pos - begin;\n \n@@ -1326,6 +1247,219 @@ class FunctionUnhex : public IFunction\n     }\n };\n \n+struct HexImpl\n+{\n+    static constexpr auto name = \"hex\";\n+    static constexpr size_t word_size = 2;\n+\n+    template <typename T>\n+    static void executeOneUInt(T x, char *& out)\n+    {\n+        bool was_nonzero = false;\n+        for (int offset = (sizeof(T) - 1) * 8; offset >= 0; offset -= 8)\n+        {\n+            UInt8 byte = x >> offset;\n+\n+            /// Skip leading zeros\n+            if (byte == 0 && !was_nonzero && offset)\n+                continue;\n+\n+            was_nonzero = true;\n+            writeHexByteUppercase(byte, out);\n+            out += word_size;\n+        }\n+        *out = '\\0';\n+        ++out;\n+    }\n+\n+    static void executeOneString(const UInt8 * pos, const UInt8 * end, char *& out)\n+    {\n+        while (pos < end)\n+        {\n+            writeHexByteUppercase(*pos, out);\n+            ++pos;\n+            out += word_size;\n+        }\n+        *out = '\\0';\n+        ++out;\n+    }\n+\n+    template <typename T>\n+    static void executeFloatAndDecimal(const T & in_vec, ColumnPtr & col_res, const size_t type_size_in_bytes)\n+    {\n+        const size_t hex_length = type_size_in_bytes * word_size + 1; /// Including trailing zero byte.\n+        auto col_str = ColumnString::create();\n+\n+        ColumnString::Chars & out_vec = col_str->getChars();\n+        ColumnString::Offsets & out_offsets = col_str->getOffsets();\n+\n+        size_t size = in_vec.size();\n+        out_offsets.resize(size);\n+        out_vec.resize(size * hex_length);\n+\n+        size_t pos = 0;\n+        char * out = reinterpret_cast<char *>(&out_vec[0]);\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            const UInt8 * in_pos = reinterpret_cast<const UInt8 *>(&in_vec[i]);\n+            executeOneString(in_pos, in_pos + type_size_in_bytes, out);\n+\n+            pos += hex_length;\n+            out_offsets[i] = pos;\n+        }\n+        col_res = std::move(col_str);\n+    }\n+};\n+\n+struct UnhexImpl\n+{\n+    static constexpr auto name = \"unhex\";\n+    static constexpr size_t word_size = 2;\n+\n+    static void decode(const char * pos, const char * end, char *& out)\n+    {\n+        if ((end - pos) & 1)\n+        {\n+            *out = unhex(*pos);\n+            ++out;\n+            ++pos;\n+        }\n+        while (pos < end)\n+        {\n+            *out = unhex2(pos);\n+            pos += word_size;\n+            ++out;\n+        }\n+        *out = '\\0';\n+        ++out;\n+    }\n+};\n+\n+struct BinImpl\n+{\n+    static constexpr auto name = \"bin\";\n+    static constexpr size_t word_size = 8;\n+\n+    template <typename T>\n+    static void executeOneUInt(T x, char *& out)\n+    {\n+        bool was_nonzero = false;\n+        for (int offset = (sizeof(T) - 1) * 8; offset >= 0; offset -= 8)\n+        {\n+            UInt8 byte = x >> offset;\n+\n+            /// Skip leading zeros\n+            if (byte == 0 && !was_nonzero && offset)\n+                continue;\n+\n+            was_nonzero = true;\n+            writeBinByte(byte, out);\n+            out += word_size;\n+        }\n+        *out = '\\0';\n+        ++out;\n+    }\n+\n+    template <typename T>\n+    static void executeFloatAndDecimal(const T & in_vec, ColumnPtr & col_res, const size_t type_size_in_bytes)\n+    {\n+        const size_t hex_length = type_size_in_bytes * word_size + 1; /// Including trailing zero byte.\n+        auto col_str = ColumnString::create();\n+\n+        ColumnString::Chars & out_vec = col_str->getChars();\n+        ColumnString::Offsets & out_offsets = col_str->getOffsets();\n+\n+        size_t size = in_vec.size();\n+        out_offsets.resize(size);\n+        out_vec.resize(size * hex_length);\n+\n+        size_t pos = 0;\n+        char * out = reinterpret_cast<char *>(out_vec.data());\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            const UInt8 * in_pos = reinterpret_cast<const UInt8 *>(&in_vec[i]);\n+            executeOneString(in_pos, in_pos + type_size_in_bytes, out);\n+\n+            pos += hex_length;\n+            out_offsets[i] = pos;\n+        }\n+        col_res = std::move(col_str);\n+    }\n+\n+    static void executeOneString(const UInt8 * pos, const UInt8 * end, char *& out)\n+    {\n+        while (pos < end)\n+        {\n+            writeBinByte(*pos, out);\n+            ++pos;\n+            out += word_size;\n+        }\n+        *out = '\\0';\n+        ++out;\n+    }\n+};\n+\n+struct UnbinImpl\n+{\n+    static constexpr auto name = \"unbin\";\n+    static constexpr size_t word_size = 8;\n+\n+    static void decode(const char * pos, const char * end, char *& out)\n+    {\n+        if (pos == end)\n+        {\n+            *out = '\\0';\n+            ++out;\n+            return;\n+        }\n+\n+        UInt8 left = 0;\n+\n+        /// end - pos is the length of input.\n+        /// (length & 7) to make remain bits length mod 8 is zero to split.\n+        /// e.g. the length is 9 and the input is \"101000001\",\n+        /// first left_cnt is 1, left is 0, right shift, pos is 1, left = 1\n+        /// then, left_cnt is 0, remain input is '01000001'.\n+        for (UInt8 left_cnt = (end - pos) & 7; left_cnt > 0; --left_cnt)\n+        {\n+            left = left << 1;\n+            if (*pos != '0')\n+                left += 1;\n+            ++pos;\n+        }\n+\n+        if (left != 0 || end - pos == 0)\n+        {\n+            *out = left;\n+            ++out;\n+        }\n+\n+        assert((end - pos) % 8 == 0);\n+\n+        while (end - pos != 0)\n+        {\n+            UInt8 c = 0;\n+            for (UInt8 i = 0; i < 8; ++i)\n+            {\n+                c = c << 1;\n+                if (*pos != '0')\n+                    c += 1;\n+                ++pos;\n+            }\n+            *out = c;\n+            ++out;\n+        }\n+\n+        *out = '\\0';\n+        ++out;\n+    }\n+};\n+\n+using FunctionHex = EncodeToBinaryRepr<HexImpl>;\n+using FunctionUnhex = DecodeFromBinaryRepr<UnhexImpl>;\n+using FunctionBin = EncodeToBinaryRepr<BinImpl>;\n+using FunctionUnbin = DecodeFromBinaryRepr<UnbinImpl>;\n+\n class FunctionChar : public IFunction\n {\n public:\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01926_bin_unbin.reference b/tests/queries/0_stateless/01926_bin_unbin.reference\nnew file mode 100644\nindex 000000000000..f84a858e4498\n--- /dev/null\n+++ b/tests/queries/0_stateless/01926_bin_unbin.reference\n@@ -0,0 +1,35 @@\n+\n+00000000\n+00000001\n+00001010\n+01111111\n+11111111\n+0000000100000000\n+0000000111111111\n+0000001000000000\n+00110000\n+0011000100110000\n+111001101011010110001011111010001010111110010101\n+11100110101101011000101111101000101011111001010100000000000000000000000000000000\n+10011010100110011001100100111111\n+0011001100110011001100110011001100110011001100111111001100111111\n+00000000000011100010011100000111\n+0000000000000000000011000011110101011101010100111010101000000001\n+0011000100110010001100110011001100110010001101000011001000110100\n+0011000100110010001100110011001100110010001101000011001000110100\n+0011000100110010001100110011001100110010001101000011001000110100\n+0011000100110010001100110011001100110010001101000011001000110100\n+\n+1\n+0\n+10\n+\u6d4b\u8bd5\n+0\n+0\n+0\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01926_bin_unbin.sql b/tests/queries/0_stateless/01926_bin_unbin.sql\nnew file mode 100644\nindex 000000000000..555770d09c65\n--- /dev/null\n+++ b/tests/queries/0_stateless/01926_bin_unbin.sql\n@@ -0,0 +1,39 @@\n+select bin('');\n+select bin(0);\n+select bin(1);\n+select bin(10);\n+select bin(127);\n+select bin(255);\n+select bin(256);\n+select bin(511);\n+select bin(512);\n+select bin('0');\n+select bin('10');\n+select bin('\u6d4b\u8bd5');\n+select bin(toFixedString('\u6d4b\u8bd5', 10));\n+select bin(toFloat32(1.2));\n+select bin(toFloat64(1.2));\n+select bin(toDecimal32(1.2, 8));\n+select bin(toDecimal64(1.2, 17));\n+select bin('12332424');\n+select bin(materialize('12332424'));\n+select bin(toNullable(materialize('12332424')));\n+select bin(toLowCardinality(materialize('12332424')));\n+\n+select unbin('');\n+select unbin('0') == '\\0';\n+select unbin('00110000'); -- 0\n+select unbin('0011000100110000'); -- 10\n+select unbin('111001101011010110001011111010001010111110010101'); -- \u6d4b\u8bd5\n+select unbin(materialize('00110000'));\n+select unbin(toNullable(materialize('00110000')));\n+select unbin(toLowCardinality(materialize('00110000')));\n+\n+select unbin(bin('')) == '';\n+select bin(unbin('')) == '';\n+select bin(unbin('0')) == '00000000';\n+\n+-- hex and bin consistent for corner cases\n+select hex('') == bin('');\n+select unhex('') == unbin('');\n+select unhex('0') == unbin('0');\n",
  "problem_statement": "Add functions `bin` and `unbin`\n**Use case**\r\n\r\nViewing binary data such as bitmasks, hashes, internal representation of IEEE-754 numbers, etc.\r\nMostly for debugging.\r\n\r\n**Describe the solution you'd like**\r\n\r\nSimilar to `hex`/`unhex`.\r\n\r\n`bin` - returns a string with `0` and `1`. Bits are in \"human\" order, most significant first. Most significant zero bits are not printed (except the case with single zero).\r\n\r\n**Describe alternatives you've considered**\r\n\r\nNow I have to run interactive `python` from command line, but I will be more happy using ClickHouse.\r\n\r\n**Caveats**\r\n\r\nThe name `bin` may suggest that the function will \"split data into bins\" but it is completely unrelated.\n",
  "hints_text": "Should `bin` and `unbin` only accepts `int` or `long`?\nSimilarly to `hex`, they also accept String, FixedString, Float32/64...\r\n\r\n`bin` from String and FixedString returns bits starting from the most significant bit of the first byte to the least significant bit of the last byte. In contrast to integers, leading zero bits are included. Floats are treated as their byte representation in memory.\r\n\r\n`unbin` from FixedString returns FixedString and for other types - always returns String.\r\n\r\nPS. It should work similarly to `hex`/`unhex`.\nSee `FunctionsCoding.h/cpp`, `FunctionHex`, `FunctionUnhex`\nTests:\r\n\r\n```\r\nbin(0) = '0'\r\nbin(1) = '1'\r\nbin(10) = '1010'\r\nbin(127) = '1111111'\r\nbin(255) = '11111111'\r\nbin('0') = '00110000'\r\nbin('10') = '0011000100110000'\r\n```\nBut the implementation in `FunctionHex` and `FunctionUnhex` is a little complicated and I can't understand it clearly. ",
  "created_at": "2021-06-23T04:36:32Z"
}