{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78069,
  "instance_id": "ClickHouse__ClickHouse-78069",
  "issue_numbers": [
    "77978"
  ],
  "base_commit": "7612a9c6686649b3cfd167b15ee9a3cf96cf7657",
  "patch": "diff --git a/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp b/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\nindex ebd383426e54..3c365bcc19ee 100644\n--- a/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\n@@ -108,12 +108,26 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n     else\n         return updated_layers;\n \n-    /// Extract reference_vec. It is expected to be a COLUMN-type node and of type Const(Array(Float*)).\n+    /// Extract stuff from the ORDER BY clause. It is expected to look like this: ORDER BY cosineDistance(vec1, [1.0, 2.0 ...])\n+    /// - The search column is 'vec1'.\n+    /// - The reference vector is [1.0, 2.0, ...].\n     const ActionsDAG::NodeRawConstPtrs & sort_column_node_children = sort_column_node->children;\n     std::vector<Float64> reference_vector;\n+    String search_column;\n+\n     for (const auto * child : sort_column_node_children)\n     {\n-        if (child->type == ActionsDAG::ActionType::COLUMN)\n+        if (child->type == ActionsDAG::ActionType::ALIAS) /// new analyzer\n+        {\n+            const auto * search_column_node = child->children.at(0);\n+            if (search_column_node->type == ActionsDAG::ActionType::INPUT)\n+                search_column = search_column_node->result_name;\n+        }\n+        else if (child->type == ActionsDAG::ActionType::INPUT) /// old analyzer\n+        {\n+            search_column = child->result_name;\n+        }\n+        else if (child->type == ActionsDAG::ActionType::COLUMN)\n         {\n             /// Is it an Array(Float32) or Array(Float64) column?\n             const DataTypePtr & data_type = child->result_type;\n@@ -148,10 +162,10 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n         }\n     }\n \n-    if (reference_vector.empty())\n+    if (search_column.empty() || reference_vector.empty())\n         return updated_layers;\n \n-    auto vector_search_parameters = std::make_optional<VectorSearchParameters>(distance_function, n, reference_vector);\n+    auto vector_search_parameters = std::make_optional<VectorSearchParameters>(search_column, distance_function, n, reference_vector);\n     read_from_mergetree_step->setVectorSearchParameters(std::move(vector_search_parameters));\n \n     return updated_layers;\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\nindex 1b4d57880c5c..21e25f6c4b9a 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n@@ -143,6 +143,7 @@ void USearchIndexWithSerialization::deserialize(ReadBuffer & istr)\n         /// See the comment in MergeTreeIndexGranuleVectorSimilarity::deserializeBinary why we throw here\n         throw Exception(ErrorCodes::INCORRECT_DATA, \"Could not load vector similarity index. Please drop the index and create it again. Error: {}\", String(result.error.release()));\n \n+    /// Indicate the number of concurrent threads that will potentially search this specific usearch index\n     try_reserve(limits());\n }\n \n@@ -396,9 +397,11 @@ void MergeTreeIndexAggregatorVectorSimilarity::update(const Block & block, size_\n \n MergeTreeIndexConditionVectorSimilarity::MergeTreeIndexConditionVectorSimilarity(\n     const std::optional<VectorSearchParameters> & parameters_,\n+    const String & index_column_,\n     unum::usearch::metric_kind_t metric_kind_,\n     ContextPtr context)\n     : parameters(parameters_)\n+    , index_column(index_column_)\n     , metric_kind(metric_kind_)\n     , expansion_search(context->getSettingsRef()[Setting::hnsw_candidate_list_size_for_search])\n {\n@@ -413,13 +416,21 @@ bool MergeTreeIndexConditionVectorSimilarity::mayBeTrueOnGranule(MergeTreeIndexG\n \n bool MergeTreeIndexConditionVectorSimilarity::alwaysUnknownOrTrue() const\n {\n-    /// The vector similarity index was build for a specific distance function (\"metric_kind\").\n-    /// We can use it for vector search only if the distance function used in the SELECT query is the same.\n-    bool distance_function_in_query_and_distance_function_in_index_match = parameters &&\n-        ((parameters->distance_function == \"L2Distance\" && metric_kind == unum::usearch::metric_kind_t::l2sq_k)\n-        || (parameters->distance_function == \"cosineDistance\" && metric_kind == unum::usearch::metric_kind_t::cos_k));\n+    if (!parameters)\n+        return true;\n+\n+    /// The vector similarity index was build on a specific column.\n+    /// It can only be used if the ORDER BY clause in the SELECT query is against the same column.\n+    if (parameters->column != index_column)\n+        return true;\n+\n+    /// The vector similarity index was build for a specific distance function.\n+    /// It can only be used if the ORDER BY clause in the SELECT query uses the same distance function.\n+    if ((parameters->distance_function == \"L2Distance\" && metric_kind != unum::usearch::metric_kind_t::l2sq_k)\n+        || (parameters->distance_function == \"cosineDistance\" && metric_kind != unum::usearch::metric_kind_t::cos_k))\n+            return true;\n \n-    return !distance_function_in_query_and_distance_function_in_index_match;\n+    return false;\n }\n \n std::vector<UInt64> MergeTreeIndexConditionVectorSimilarity::calculateApproximateNearestNeighbors(MergeTreeIndexGranulePtr granule_) const\n@@ -496,7 +507,8 @@ MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(\n \n MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(const ActionsDAG * /*filter_actions_dag*/, ContextPtr context, const std::optional<VectorSearchParameters> & parameters) const\n {\n-    return std::make_shared<MergeTreeIndexConditionVectorSimilarity>(parameters, metric_kind, context);\n+    const String & index_column = index.column_names[0];\n+    return std::make_shared<MergeTreeIndexConditionVectorSimilarity>(parameters, index_column, metric_kind, context);\n }\n \n MergeTreeIndexPtr vectorSimilarityIndexCreator(const IndexDescription & index)\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\nindex e350360b3a4e..8341fd55bba7 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n@@ -142,6 +142,7 @@ class MergeTreeIndexConditionVectorSimilarity final : public IMergeTreeIndexCond\n public:\n     explicit MergeTreeIndexConditionVectorSimilarity(\n         const std::optional<VectorSearchParameters> & parameters_,\n+        const String & index_column_,\n         unum::usearch::metric_kind_t metric_kind_,\n         ContextPtr context);\n \n@@ -153,6 +154,7 @@ class MergeTreeIndexConditionVectorSimilarity final : public IMergeTreeIndexCond\n \n private:\n     std::optional<VectorSearchParameters> parameters;\n+    const String index_column;\n     const unum::usearch::metric_kind_t metric_kind;\n     const size_t expansion_search;\n };\ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h\nindex 6d2e1fbddd7a..f54089752789 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.h\n+++ b/src/Storages/MergeTree/MergeTreeIndices.h\n@@ -43,6 +43,7 @@ struct MergeTreeIndexFormat\n /// A vehicle which transports elements of the SELECT query to the vector similarity index.\n struct VectorSearchParameters\n {\n+    String column;\n     String distance_function;\n     size_t limit;\n     std::vector<Float64> reference_vector;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_vector_search_choose_correct_index.reference b/tests/queries/0_stateless/02354_vector_search_choose_correct_index.reference\nnew file mode 100644\nindex 000000000000..a16748967e0f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_vector_search_choose_correct_index.reference\n@@ -0,0 +1,27 @@\n+Searches on vec1 should use the vector index\n+Expression (Project names)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression ((Before ORDER BY + (Projection + Change column names to column identifiers)))\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 1/1\n+          Skip\n+            Name: idx\n+            Description: vector_similarity GRANULARITY 100000000\n+            Parts: 1/1\n+            Granules: 1/1\n+Searches on vec2 should be brute force\n+Expression (Project names)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression ((Before ORDER BY + (Projection + Change column names to column identifiers)))\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 1/1\ndiff --git a/tests/queries/0_stateless/02354_vector_search_choose_correct_index.sql b/tests/queries/0_stateless/02354_vector_search_choose_correct_index.sql\nnew file mode 100644\nindex 000000000000..6982b6685233\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_vector_search_choose_correct_index.sql\n@@ -0,0 +1,18 @@\n+-- Tags: no-fasttest, no-ordinary-database\n+\n+SET allow_experimental_vector_similarity_index=1;\n+SET enable_analyzer = 1; -- analyzer vs. non-analyzer produce slightly different EXPLAIN\n+\n+-- Test for issue #77978\n+\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab(id Int32, vec1 Array(Float32), vec2 Array(Float32), INDEX idx vec1 TYPE vector_similarity('hnsw', 'L2Distance')) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO tab VALUES (0, [1.0, 0.0], [1.0, 0.0]), (1, [1.1, 0.0], [1.1, 0.0]), (2, [1.2, 0.0], [1.2, 0.0]), (3, [1.3, 0.0], [1.3, 0.0]), (4, [1.4, 0.0], [1.4, 0,0]), (5, [1.5, 0.0], [1.5, 0.0]), (6, [0.0, 2.0], [0.0, 2.0]), (7, [0.0, 2.1], [0.0, 2.1]), (8, [0.0, 2.2], [0.0, 2.2]), (9, [0.0, 2.3], [0.0, 2.3]), (10, [0.0, 2.4], [0.0, 2.4]), (11, [0.0, 2.5], [0.0, 2.5]);\n+\n+SELECT 'Searches on vec1 should use the vector index';\n+EXPLAIN indexes=1 WITH [0.0, 2.0] AS reference_vec SELECT id FROM tab ORDER BY L2Distance(vec1, reference_vec) LIMIT 3;\n+\n+SELECT 'Searches on vec2 should be brute force';\n+EXPLAIN indexes=1 WITH [0.0, 2.0] AS reference_vec SELECT id FROM tab ORDER BY L2Distance(vec2, reference_vec) LIMIT 3;\n",
  "problem_statement": "Vector index incorrectly used for KNN query on non-vector column\n### Company or project name\n\nClickhouse ANN Search\n\n### Describe what's wrong\n\nTable has 2 vector columns : `vec1` and `vec2`. Vector index is defined only on column `vec1`. An intentional brute-force KNN query using column `vec2` incorrectly uses the vector index on `vec1` to prune.\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n```sql\nset allow_experimental_vector_similarity_index=1;\n\nDROP TABLE IF EXISTS tab;\n\nCREATE TABLE tab(id Int32, vec1 Array(Float32), vec2 Array(Float32), INDEX idx vec1 TYPE vector_similarity('hnsw', 'L2Distance')) ENGINE = MergeTree ORDER BY id;\n\nINSERT INTO tab VALUES (0, [1.0, 0.0], [1.0, 0.0]), (1, [1.1, 0.0], [1.1, 0.0]), (2, [1.2, 0.0], [1.2, 0.0]), (3, [1.3, 0.0], [1.3, 0.0]), (4, [1.4, 0.0], [1.4, 0,0]), (5, [1.5, 0.0], [1.5, 0.0]), (6, [0.0, 2.0], [0.0, 2.0]), (7, [0.0, 2.1], [0.0, 2.1]), (8, [0.0, 2.2], [0.0, 2.2]), (9, [0.0, 2.3], [0.0, 2.3]), (10, [0.0, 2.4], [0.0, 2.4]), (11, [0.0, 2.5], [0.0, 2.5]);\n\n-- should use vector index\nexplain indexes=1 WITH [0.0, 2.0] AS reference_vec SELECT id FROM tab ORDER BY L2Distance(vec1, reference_vec) LIMIT 3;\n\n-- should not use vector index as ORDER BY column is vec2, but vec1 index is wrongly used (25.3)\nexplain indexes=1 WITH [0.0, 2.0] AS reference_vec SELECT id FROM tab ORDER BY L2Distance(vec2, reference_vec) LIMIT 3;\n```\n\nOutput from query on `vec2`  -\n```sql\nEXPLAIN indexes = 1\nWITH [0., 2.] AS reference_vec\nSELECT id\nFROM tab\nORDER BY L2Distance(vec2, reference_vec) ASC\nLIMIT 3\n\nQuery id: a290be3c-a82c-42d7-ba5b-a7d86d2de98b\n\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n 1. \u2502 Expression (Project names)                                                                      \u2502\n 2. \u2502   Limit (preliminary LIMIT (without OFFSET))                                                    \u2502\n 3. \u2502     Sorting (Sorting for ORDER BY)                                                              \u2502\n 4. \u2502       Expression ((Before ORDER BY + (Projection + Change column names to column identifiers))) \u2502\n 5. \u2502         ReadFromMergeTree (default.tab)                                                         \u2502\n 6. \u2502         Indexes:                                                                                \u2502\n 7. \u2502           PrimaryKey                                                                            \u2502\n 8. \u2502             Condition: true                                                                     \u2502\n 9. \u2502             Parts: 1/1                                                                          \u2502\n10. \u2502             Granules: 1/1                                                                       \u2502\n11. \u2502           Skip                                                                                  \u2502\n12. \u2502             Name: idx                                                                           \u2502\n13. \u2502             Description: vector_similarity GRANULARITY 100000000                                \u2502\n14. \u2502             Parts: 1/1                                                                          \u2502\n15. \u2502             Granules: 1/1                                                                       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n15 rows in set. Elapsed: 0.001 sec.\n```\n\n\n### Expected behavior\n\nVector index on `vec1` should not be loaded / not be used when query is on `vec2`.\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "I am pretty sure this is a bug in `src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp`.",
  "created_at": "2025-03-21T10:45:28Z"
}