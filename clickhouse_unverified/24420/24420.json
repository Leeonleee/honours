{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 24420,
  "instance_id": "ClickHouse__ClickHouse-24420",
  "issue_numbers": [
    "21868"
  ],
  "base_commit": "a489ac046e6ac70bb94ceadaa2743c7fa8c0e410",
  "patch": "diff --git a/src/Common/ColumnsHashingImpl.h b/src/Common/ColumnsHashingImpl.h\nindex 9af746a69ad8..aa7ae6ea29db 100644\n--- a/src/Common/ColumnsHashingImpl.h\n+++ b/src/Common/ColumnsHashingImpl.h\n@@ -124,6 +124,10 @@ class FindResultImpl : public FindResultImplBase, public FindResultImplOffsetBas\n     Mapped * value;\n \n public:\n+    FindResultImpl()\n+        : FindResultImplBase(false), FindResultImplOffsetBase<need_offset>(0)\n+    {}\n+\n     FindResultImpl(Mapped * value_, bool found_, size_t off)\n         : FindResultImplBase(found_), FindResultImplOffsetBase<need_offset>(off), value(value_) {}\n     Mapped & getMapped() const { return *value; }\ndiff --git a/src/Core/SortDescription.h b/src/Core/SortDescription.h\nindex 41b4e5b6b327..e1653b9102b5 100644\n--- a/src/Core/SortDescription.h\n+++ b/src/Core/SortDescription.h\n@@ -42,15 +42,15 @@ struct SortColumnDescription\n     bool with_fill;\n     FillColumnDescription fill_description;\n \n-    SortColumnDescription(\n-            size_t column_number_, int direction_, int nulls_direction_,\n+    explicit SortColumnDescription(\n+            size_t column_number_, int direction_ = 1, int nulls_direction_ = 1,\n             const std::shared_ptr<Collator> & collator_ = nullptr,\n             bool with_fill_ = false, const FillColumnDescription & fill_description_ = {})\n             : column_number(column_number_), direction(direction_), nulls_direction(nulls_direction_), collator(collator_)\n             , with_fill(with_fill_), fill_description(fill_description_) {}\n \n-    SortColumnDescription(\n-            const std::string & column_name_, int direction_, int nulls_direction_,\n+    explicit SortColumnDescription(\n+            const std::string & column_name_, int direction_ = 1, int nulls_direction_ = 1,\n             const std::shared_ptr<Collator> & collator_ = nullptr,\n             bool with_fill_ = false, const FillColumnDescription & fill_description_ = {})\n             : column_name(column_name_), column_number(0), direction(direction_), nulls_direction(nulls_direction_)\ndiff --git a/src/Interpreters/CollectJoinOnKeysVisitor.cpp b/src/Interpreters/CollectJoinOnKeysVisitor.cpp\nindex 3b3fdaa65cb7..9715af01a0ab 100644\n--- a/src/Interpreters/CollectJoinOnKeysVisitor.cpp\n+++ b/src/Interpreters/CollectJoinOnKeysVisitor.cpp\n@@ -12,48 +12,77 @@ namespace ErrorCodes\n     extern const int INVALID_JOIN_ON_EXPRESSION;\n     extern const int AMBIGUOUS_COLUMN_NAME;\n     extern const int SYNTAX_ERROR;\n-    extern const int NOT_IMPLEMENTED;\n     extern const int LOGICAL_ERROR;\n }\n \n-void CollectJoinOnKeysMatcher::Data::addJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast,\n-                                                 const std::pair<size_t, size_t> & table_no)\n+namespace\n+{\n+\n+bool isLeftIdentifier(JoinIdentifierPos pos)\n+{\n+    /// Unknown identifiers  considered as left, we will try to process it on later stages\n+    /// Usually such identifiers came from `ARRAY JOIN ... AS ...`\n+    return pos == JoinIdentifierPos::Left || pos == JoinIdentifierPos::Unknown;\n+}\n+\n+bool isRightIdentifier(JoinIdentifierPos pos)\n+{\n+    return pos == JoinIdentifierPos::Right;\n+}\n+\n+}\n+\n+void CollectJoinOnKeysMatcher::Data::addJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast, JoinIdentifierPosPair table_pos)\n {\n     ASTPtr left = left_ast->clone();\n     ASTPtr right = right_ast->clone();\n \n-    if (table_no.first == 1 || table_no.second == 2)\n+    if (isLeftIdentifier(table_pos.first) && isRightIdentifier(table_pos.second))\n         analyzed_join.addOnKeys(left, right);\n-    else if (table_no.first == 2 || table_no.second == 1)\n+    else if (isRightIdentifier(table_pos.first) && isLeftIdentifier(table_pos.second))\n         analyzed_join.addOnKeys(right, left);\n     else\n         throw Exception(\"Cannot detect left and right JOIN keys. JOIN ON section is ambiguous.\",\n-                        ErrorCodes::AMBIGUOUS_COLUMN_NAME);\n-    has_some = true;\n+                        ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n }\n \n void CollectJoinOnKeysMatcher::Data::addAsofJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast,\n-                                                     const std::pair<size_t, size_t> & table_no, const ASOF::Inequality & inequality)\n+                                                     JoinIdentifierPosPair table_pos, const ASOF::Inequality & inequality)\n {\n-    if (table_no.first == 1 || table_no.second == 2)\n+    if (isLeftIdentifier(table_pos.first) && isRightIdentifier(table_pos.second))\n     {\n         asof_left_key = left_ast->clone();\n         asof_right_key = right_ast->clone();\n         analyzed_join.setAsofInequality(inequality);\n     }\n-    else if (table_no.first == 2 || table_no.second == 1)\n+    else if (isRightIdentifier(table_pos.first) && isLeftIdentifier(table_pos.second))\n     {\n         asof_left_key = right_ast->clone();\n         asof_right_key = left_ast->clone();\n         analyzed_join.setAsofInequality(ASOF::reverseInequality(inequality));\n     }\n+    else\n+    {\n+        throw Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n+                        \"Expressions {} and {} are from the same table but from different arguments of equal function in ASOF JOIN\",\n+                        queryToString(left_ast), queryToString(right_ast));\n+    }\n }\n \n void CollectJoinOnKeysMatcher::Data::asofToJoinKeys()\n {\n     if (!asof_left_key || !asof_right_key)\n         throw Exception(\"No inequality in ASOF JOIN ON section.\", ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n-    addJoinKeys(asof_left_key, asof_right_key, {1, 2});\n+    addJoinKeys(asof_left_key, asof_right_key, {JoinIdentifierPos::Left, JoinIdentifierPos::Right});\n+}\n+\n+void CollectJoinOnKeysMatcher::visit(const ASTIdentifier & ident, const ASTPtr & ast, CollectJoinOnKeysMatcher::Data & data)\n+{\n+    if (auto expr_from_table = getTableForIdentifiers(ast, false, data); expr_from_table != JoinIdentifierPos::Unknown)\n+        data.analyzed_join.addJoinCondition(ast, isLeftIdentifier(expr_from_table));\n+    else\n+        throw Exception(\"Unexpected identifier '\" + ident.name() + \"' in JOIN ON section\",\n+                        ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n }\n \n void CollectJoinOnKeysMatcher::visit(const ASTFunction & func, const ASTPtr & ast, Data & data)\n@@ -61,9 +90,6 @@ void CollectJoinOnKeysMatcher::visit(const ASTFunction & func, const ASTPtr & as\n     if (func.name == \"and\")\n         return; /// go into children\n \n-    if (func.name == \"or\")\n-        throw Exception(\"JOIN ON does not support OR. Unexpected '\" + queryToString(ast) + \"'\", ErrorCodes::NOT_IMPLEMENTED);\n-\n     ASOF::Inequality inequality = ASOF::getInequality(func.name);\n     if (func.name == \"equals\" || inequality != ASOF::Inequality::None)\n     {\n@@ -71,32 +97,50 @@ void CollectJoinOnKeysMatcher::visit(const ASTFunction & func, const ASTPtr & as\n             throw Exception(\"Function \" + func.name + \" takes two arguments, got '\" + func.formatForErrorMessage() + \"' instead\",\n                             ErrorCodes::SYNTAX_ERROR);\n     }\n-    else\n-        throw Exception(\"Expected equality or inequality, got '\" + queryToString(ast) + \"'\", ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n \n     if (func.name == \"equals\")\n     {\n         ASTPtr left = func.arguments->children.at(0);\n         ASTPtr right = func.arguments->children.at(1);\n-        auto table_numbers = getTableNumbers(ast, left, right, data);\n-        data.addJoinKeys(left, right, table_numbers);\n+        auto table_numbers = getTableNumbers(left, right, data);\n+        if (table_numbers.first == table_numbers.second)\n+        {\n+            if (table_numbers.first == JoinIdentifierPos::Unknown)\n+                throw Exception(\"Ambiguous column in expression '\" + queryToString(ast) + \"' in JOIN ON section\",\n+                                ErrorCodes::AMBIGUOUS_COLUMN_NAME);\n+            data.analyzed_join.addJoinCondition(ast, isLeftIdentifier(table_numbers.first));\n+            return;\n+        }\n+\n+        if (table_numbers.first != JoinIdentifierPos::NotApplicable && table_numbers.second != JoinIdentifierPos::NotApplicable)\n+        {\n+            data.addJoinKeys(left, right, table_numbers);\n+            return;\n+        }\n     }\n-    else if (inequality != ASOF::Inequality::None)\n+\n+    if (auto expr_from_table = getTableForIdentifiers(ast, false, data); expr_from_table != JoinIdentifierPos::Unknown)\n     {\n-        if (!data.is_asof)\n-            throw Exception(\"JOIN ON inequalities are not supported. Unexpected '\" + queryToString(ast) + \"'\",\n-                            ErrorCodes::NOT_IMPLEMENTED);\n+        data.analyzed_join.addJoinCondition(ast, isLeftIdentifier(expr_from_table));\n+        return;\n+    }\n \n+    if (data.is_asof && inequality != ASOF::Inequality::None)\n+    {\n         if (data.asof_left_key || data.asof_right_key)\n             throw Exception(\"ASOF JOIN expects exactly one inequality in ON section. Unexpected '\" + queryToString(ast) + \"'\",\n                             ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n \n         ASTPtr left = func.arguments->children.at(0);\n         ASTPtr right = func.arguments->children.at(1);\n-        auto table_numbers = getTableNumbers(ast, left, right, data);\n+        auto table_numbers = getTableNumbers(left, right, data);\n \n         data.addAsofJoinKeys(left, right, table_numbers, inequality);\n+        return;\n     }\n+\n+    throw Exception(\"Unsupported JOIN ON conditions. Unexpected '\" + queryToString(ast) + \"'\",\n+                    ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n }\n \n void CollectJoinOnKeysMatcher::getIdentifiers(const ASTPtr & ast, std::vector<const ASTIdentifier *> & out)\n@@ -118,32 +162,10 @@ void CollectJoinOnKeysMatcher::getIdentifiers(const ASTPtr & ast, std::vector<co\n         getIdentifiers(child, out);\n }\n \n-std::pair<size_t, size_t> CollectJoinOnKeysMatcher::getTableNumbers(const ASTPtr & expr, const ASTPtr & left_ast, const ASTPtr & right_ast,\n-                                                                    Data & data)\n+JoinIdentifierPosPair CollectJoinOnKeysMatcher::getTableNumbers(const ASTPtr & left_ast, const ASTPtr & right_ast, Data & data)\n {\n-    std::vector<const ASTIdentifier *> left_identifiers;\n-    std::vector<const ASTIdentifier *> right_identifiers;\n-\n-    getIdentifiers(left_ast, left_identifiers);\n-    getIdentifiers(right_ast, right_identifiers);\n-\n-    if (left_identifiers.empty() || right_identifiers.empty())\n-    {\n-        throw Exception(\"Not equi-join ON expression: \" + queryToString(expr) + \". No columns in one of equality side.\",\n-                        ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n-    }\n-\n-    size_t left_idents_table = getTableForIdentifiers(left_identifiers, data);\n-    size_t right_idents_table = getTableForIdentifiers(right_identifiers, data);\n-\n-    if (left_idents_table && left_idents_table == right_idents_table)\n-    {\n-        auto left_name = queryToString(*left_identifiers[0]);\n-        auto right_name = queryToString(*right_identifiers[0]);\n-\n-        throw Exception(\"In expression \" + queryToString(expr) + \" columns \" + left_name + \" and \" + right_name\n-            + \" are from the same table but from different arguments of equal function\", ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n-    }\n+    auto left_idents_table = getTableForIdentifiers(left_ast, true, data);\n+    auto right_idents_table = getTableForIdentifiers(right_ast, true, data);\n \n     return std::make_pair(left_idents_table, right_idents_table);\n }\n@@ -173,11 +195,16 @@ const ASTIdentifier * CollectJoinOnKeysMatcher::unrollAliases(const ASTIdentifie\n     return identifier;\n }\n \n-/// @returns 1 if identifiers belongs to left table, 2 for right table and 0 if unknown. Throws on table mix.\n+/// @returns Left or right table identifiers belongs to.\n /// Place detected identifier into identifiers[0] if any.\n-size_t CollectJoinOnKeysMatcher::getTableForIdentifiers(std::vector<const ASTIdentifier *> & identifiers, const Data & data)\n+JoinIdentifierPos CollectJoinOnKeysMatcher::getTableForIdentifiers(const ASTPtr & ast, bool throw_on_table_mix, const Data & data)\n {\n-    size_t table_number = 0;\n+    std::vector<const ASTIdentifier *> identifiers;\n+    getIdentifiers(ast, identifiers);\n+    if (identifiers.empty())\n+        return JoinIdentifierPos::NotApplicable;\n+\n+    JoinIdentifierPos table_number = JoinIdentifierPos::Unknown;\n \n     for (auto & ident : identifiers)\n     {\n@@ -187,10 +214,20 @@ size_t CollectJoinOnKeysMatcher::getTableForIdentifiers(std::vector<const ASTIde\n \n         /// Column name could be cropped to a short form in TranslateQualifiedNamesVisitor.\n         /// In this case it saves membership in IdentifierSemantic.\n-        auto opt = IdentifierSemantic::getMembership(*identifier);\n-        size_t membership = opt ? (*opt + 1) : 0;\n+        JoinIdentifierPos membership = JoinIdentifierPos::Unknown;\n+        if (auto opt = IdentifierSemantic::getMembership(*identifier); opt.has_value())\n+        {\n+            if (*opt == 0)\n+                membership = JoinIdentifierPos::Left;\n+            else if (*opt == 1)\n+                membership = JoinIdentifierPos::Right;\n+            else\n+                throw DB::Exception(ErrorCodes::AMBIGUOUS_COLUMN_NAME,\n+                                    \"Position of identifier {} can't be deteminated.\",\n+                                    identifier->name());\n+        }\n \n-        if (!membership)\n+        if (membership == JoinIdentifierPos::Unknown)\n         {\n             const String & name = identifier->name();\n             bool in_left_table = data.left_table.hasColumn(name);\n@@ -211,22 +248,24 @@ size_t CollectJoinOnKeysMatcher::getTableForIdentifiers(std::vector<const ASTIde\n             }\n \n             if (in_left_table)\n-                membership = 1;\n+                membership = JoinIdentifierPos::Left;\n             if (in_right_table)\n-                membership = 2;\n+                membership = JoinIdentifierPos::Right;\n         }\n \n-        if (membership && table_number == 0)\n+        if (membership != JoinIdentifierPos::Unknown && table_number == JoinIdentifierPos::Unknown)\n         {\n             table_number = membership;\n             std::swap(ident, identifiers[0]); /// move first detected identifier to the first position\n         }\n \n-        if (membership && membership != table_number)\n+        if (membership != JoinIdentifierPos::Unknown && membership != table_number)\n         {\n-            throw Exception(\"Invalid columns in JOIN ON section. Columns \"\n-                        + identifiers[0]->getAliasOrColumnName() + \" and \" + ident->getAliasOrColumnName()\n-                        + \" are from different tables.\", ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n+            if (throw_on_table_mix)\n+                throw Exception(\"Invalid columns in JOIN ON section. Columns \"\n+                            + identifiers[0]->getAliasOrColumnName() + \" and \" + ident->getAliasOrColumnName()\n+                            + \" are from different tables.\", ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n+            return JoinIdentifierPos::Unknown;\n         }\n     }\n \ndiff --git a/src/Interpreters/CollectJoinOnKeysVisitor.h b/src/Interpreters/CollectJoinOnKeysVisitor.h\nindex 54e008a114ef..0647f58f79b1 100644\n--- a/src/Interpreters/CollectJoinOnKeysVisitor.h\n+++ b/src/Interpreters/CollectJoinOnKeysVisitor.h\n@@ -18,6 +18,21 @@ namespace ASOF\n     enum class Inequality;\n }\n \n+enum class JoinIdentifierPos\n+{\n+    /// Position can't be established, identifier not resolved\n+    Unknown,\n+    /// Left side of JOIN\n+    Left,\n+    /// Right side of JOIN\n+    Right,\n+    /// Expression not valid, e.g. doesn't contain identifiers\n+    NotApplicable,\n+};\n+\n+using JoinIdentifierPosPair = std::pair<JoinIdentifierPos, JoinIdentifierPos>;\n+\n+\n class CollectJoinOnKeysMatcher\n {\n public:\n@@ -32,10 +47,9 @@ class CollectJoinOnKeysMatcher\n         const bool is_asof{false};\n         ASTPtr asof_left_key{};\n         ASTPtr asof_right_key{};\n-        bool has_some{false};\n \n-        void addJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast, const std::pair<size_t, size_t> & table_no);\n-        void addAsofJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast, const std::pair<size_t, size_t> & table_no,\n+        void addJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast, JoinIdentifierPosPair table_pos);\n+        void addAsofJoinKeys(const ASTPtr & left_ast, const ASTPtr & right_ast, JoinIdentifierPosPair table_pos,\n                              const ASOF::Inequality & asof_inequality);\n         void asofToJoinKeys();\n     };\n@@ -43,7 +57,17 @@ class CollectJoinOnKeysMatcher\n     static void visit(const ASTPtr & ast, Data & data)\n     {\n         if (auto * func = ast->as<ASTFunction>())\n+        {\n             visit(*func, ast, data);\n+        }\n+        else if (auto * ident = ast->as<ASTIdentifier>())\n+        {\n+            visit(*ident, ast, data);\n+        }\n+        else\n+        {\n+            /// visit children\n+        }\n     }\n \n     static bool needChildVisit(const ASTPtr & node, const ASTPtr &)\n@@ -55,11 +79,12 @@ class CollectJoinOnKeysMatcher\n \n private:\n     static void visit(const ASTFunction & func, const ASTPtr & ast, Data & data);\n+    static void visit(const ASTIdentifier & ident, const ASTPtr & ast, Data & data);\n \n     static void getIdentifiers(const ASTPtr & ast, std::vector<const ASTIdentifier *> & out);\n-    static std::pair<size_t, size_t> getTableNumbers(const ASTPtr & expr, const ASTPtr & left_ast, const ASTPtr & right_ast, Data & data);\n+    static JoinIdentifierPosPair getTableNumbers(const ASTPtr & left_ast, const ASTPtr & right_ast, Data & data);\n     static const ASTIdentifier * unrollAliases(const ASTIdentifier * identifier, const Aliases & aliases);\n-    static size_t getTableForIdentifiers(std::vector<const ASTIdentifier *> & identifiers, const Data & data);\n+    static JoinIdentifierPos getTableForIdentifiers(const ASTPtr & ast, bool throw_on_table_mix, const Data & data);\n };\n \n /// Parse JOIN ON expression and collect ASTs for joined columns.\ndiff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex 905fcf0331c2..6797947a1011 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -812,6 +812,9 @@ void ExpressionActionsChain::JoinStep::finalize(const NameSet & required_output_\n     for (const auto & name : analyzed_join->keyNamesLeft())\n         required_names.emplace(name);\n \n+    if (ASTPtr extra_condition_column = analyzed_join->joinConditionColumn(JoinTableSide::Left))\n+        required_names.emplace(extra_condition_column->getColumnName());\n+\n     for (const auto & column : required_columns)\n     {\n         if (required_names.count(column.name) != 0)\ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 56ad13511ac5..dd17fc1004c4 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -190,9 +190,12 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n {\n     LOG_DEBUG(log, \"Right sample block: {}\", right_sample_block.dumpStructure());\n \n-    table_join->splitAdditionalColumns(right_sample_block, right_table_keys, sample_block_with_columns_to_add);\n+    JoinCommon::splitAdditionalColumns(key_names_right, right_sample_block, right_table_keys, sample_block_with_columns_to_add);\n+\n     required_right_keys = table_join->getRequiredRightKeys(right_table_keys, required_right_keys_sources);\n \n+    std::tie(condition_mask_column_name_left, condition_mask_column_name_right) = table_join->joinConditionColumnNames();\n+\n     JoinCommon::removeLowCardinalityInplace(right_table_keys);\n     initRightBlockStructure(data->sample_block);\n \n@@ -500,7 +503,7 @@ namespace\n     template <ASTTableJoin::Strictness STRICTNESS, typename KeyGetter, typename Map, bool has_null_map>\n     size_t NO_INLINE insertFromBlockImplTypeCase(\n         HashJoin & join, Map & map, size_t rows, const ColumnRawPtrs & key_columns,\n-        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, Arena & pool)\n+        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, UInt8ColumnDataPtr join_mask, Arena & pool)\n     {\n         [[maybe_unused]] constexpr bool mapped_one = std::is_same_v<typename Map::mapped_type, RowRef>;\n         constexpr bool is_asof_join = STRICTNESS == ASTTableJoin::Strictness::Asof;\n@@ -516,6 +519,10 @@ namespace\n             if (has_null_map && (*null_map)[i])\n                 continue;\n \n+            /// Check condition for right table from ON section\n+            if (join_mask && !(*join_mask)[i])\n+                continue;\n+\n             if constexpr (is_asof_join)\n                 Inserter<Map, KeyGetter>::insertAsof(join, map, key_getter, stored_block, i, pool, *asof_column);\n             else if constexpr (mapped_one)\n@@ -530,19 +537,21 @@ namespace\n     template <ASTTableJoin::Strictness STRICTNESS, typename KeyGetter, typename Map>\n     size_t insertFromBlockImplType(\n         HashJoin & join, Map & map, size_t rows, const ColumnRawPtrs & key_columns,\n-        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, Arena & pool)\n+        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, UInt8ColumnDataPtr join_mask, Arena & pool)\n     {\n         if (null_map)\n-            return insertFromBlockImplTypeCase<STRICTNESS, KeyGetter, Map, true>(join, map, rows, key_columns, key_sizes, stored_block, null_map, pool);\n+            return insertFromBlockImplTypeCase<STRICTNESS, KeyGetter, Map, true>(\n+                join, map, rows, key_columns, key_sizes, stored_block, null_map, join_mask, pool);\n         else\n-            return insertFromBlockImplTypeCase<STRICTNESS, KeyGetter, Map, false>(join, map, rows, key_columns, key_sizes, stored_block, null_map, pool);\n+            return insertFromBlockImplTypeCase<STRICTNESS, KeyGetter, Map, false>(\n+                join, map, rows, key_columns, key_sizes, stored_block, null_map, join_mask, pool);\n     }\n \n \n     template <ASTTableJoin::Strictness STRICTNESS, typename Maps>\n     size_t insertFromBlockImpl(\n         HashJoin & join, HashJoin::Type type, Maps & maps, size_t rows, const ColumnRawPtrs & key_columns,\n-        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, Arena & pool)\n+        const Sizes & key_sizes, Block * stored_block, ConstNullMapPtr null_map, UInt8ColumnDataPtr join_mask, Arena & pool)\n     {\n         switch (type)\n         {\n@@ -553,7 +562,7 @@ namespace\n         #define M(TYPE) \\\n             case HashJoin::Type::TYPE: \\\n                 return insertFromBlockImplType<STRICTNESS, typename KeyGetterForType<HashJoin::Type::TYPE, std::remove_reference_t<decltype(*maps.TYPE)>>::Type>(\\\n-                    join, *maps.TYPE, rows, key_columns, key_sizes, stored_block, null_map, pool); \\\n+                    join, *maps.TYPE, rows, key_columns, key_sizes, stored_block, null_map, join_mask, pool); \\\n                     break;\n             APPLY_FOR_JOIN_VARIANTS(M)\n         #undef M\n@@ -624,10 +633,34 @@ bool HashJoin::addJoinedBlock(const Block & source_block, bool check_limits)\n     UInt8 save_nullmap = 0;\n     if (isRightOrFull(kind) && null_map)\n     {\n+        /// Save rows with NULL keys\n         for (size_t i = 0; !save_nullmap && i < null_map->size(); ++i)\n             save_nullmap |= (*null_map)[i];\n     }\n \n+    auto join_mask_col = JoinCommon::getColumnAsMask(block, condition_mask_column_name_right);\n+\n+    /// Save blocks that do not hold conditions in ON section\n+    ColumnUInt8::MutablePtr not_joined_map = nullptr;\n+    if (isRightOrFull(kind) && join_mask_col)\n+    {\n+        const auto & join_mask = assert_cast<const ColumnUInt8 &>(*join_mask_col).getData();\n+        /// Save rows that do not hold conditions\n+        not_joined_map = ColumnUInt8::create(block.rows(), 0);\n+        for (size_t i = 0, sz = join_mask.size(); i < sz; ++i)\n+        {\n+            /// Condition hold, do not save row\n+            if (join_mask[i])\n+                continue;\n+\n+            /// NULL key will be saved anyway because, do not save twice\n+            if (save_nullmap && (*null_map)[i])\n+                continue;\n+\n+            not_joined_map->getData()[i] = 1;\n+        }\n+    }\n+\n     Block structured_block = structureRightBlock(block);\n     size_t total_rows = 0;\n     size_t total_bytes = 0;\n@@ -647,7 +680,10 @@ bool HashJoin::addJoinedBlock(const Block & source_block, bool check_limits)\n         {\n             joinDispatch(kind, strictness, data->maps, [&](auto kind_, auto strictness_, auto & map)\n             {\n-                size_t size = insertFromBlockImpl<strictness_>(*this, data->type, map, rows, key_columns, key_sizes, stored_block, null_map, data->pool);\n+                size_t size = insertFromBlockImpl<strictness_>(\n+                                 *this, data->type, map, rows, key_columns, key_sizes, stored_block, null_map,\n+                                 join_mask_col ? &assert_cast<const ColumnUInt8 &>(*join_mask_col).getData() : nullptr,\n+                                 data->pool);\n                 /// Number of buckets + 1 value from zero storage\n                 used_flags.reinit<kind_, strictness_>(size + 1);\n             });\n@@ -656,6 +692,9 @@ bool HashJoin::addJoinedBlock(const Block & source_block, bool check_limits)\n         if (save_nullmap)\n             data->blocks_nullmaps.emplace_back(stored_block, null_map_holder);\n \n+        if (not_joined_map)\n+            data->blocks_nullmaps.emplace_back(stored_block, std::move(not_joined_map));\n+\n         if (!check_limits)\n             return true;\n \n@@ -693,6 +732,7 @@ class AddedColumns\n         const HashJoin & join,\n         const ColumnRawPtrs & key_columns_,\n         const Sizes & key_sizes_,\n+        const UInt8ColumnDataPtr & join_mask_column_,\n         bool is_asof_join,\n         bool is_join_get_)\n         : key_columns(key_columns_)\n@@ -700,6 +740,7 @@ class AddedColumns\n         , rows_to_add(block.rows())\n         , asof_type(join.getAsofType())\n         , asof_inequality(join.getAsofInequality())\n+        , join_mask_column(join_mask_column_)\n         , is_join_get(is_join_get_)\n     {\n         size_t num_columns_to_add = block_with_columns_to_add.columns();\n@@ -784,6 +825,8 @@ class AddedColumns\n     ASOF::Inequality asofInequality() const { return asof_inequality; }\n     const IColumn & leftAsofKey() const { return *left_asof_key; }\n \n+    bool isRowFiltered(size_t i) { return join_mask_column && !(*join_mask_column)[i]; }\n+\n     const ColumnRawPtrs & key_columns;\n     const Sizes & key_sizes;\n     size_t rows_to_add;\n@@ -799,6 +842,7 @@ class AddedColumns\n     std::optional<TypeIndex> asof_type;\n     ASOF::Inequality asof_inequality;\n     const IColumn * left_asof_key = nullptr;\n+    UInt8ColumnDataPtr join_mask_column;\n     bool is_join_get;\n \n     void addColumn(const ColumnWithTypeAndName & src_column, const std::string & qualified_name)\n@@ -891,7 +935,9 @@ NO_INLINE IColumn::Filter joinRightColumns(\n             }\n         }\n \n-        auto find_result = key_getter.findKey(map, i, pool);\n+        bool row_acceptable = !added_columns.isRowFiltered(i);\n+        using FindResult = typename KeyGetter::FindResult;\n+        auto find_result = row_acceptable ? key_getter.findKey(map, i, pool) : FindResult();\n \n         if (find_result.isFound())\n         {\n@@ -1098,7 +1144,20 @@ void HashJoin::joinBlockImpl(\n       * For ASOF, the last column is used as the ASOF column\n       */\n \n-    AddedColumns added_columns(block_with_columns_to_add, block, savedBlockSample(), *this, left_key_columns, key_sizes, is_asof_join, is_join_get);\n+    /// Only rows where mask == true can be joined\n+    ColumnPtr join_mask_column = JoinCommon::getColumnAsMask(block, condition_mask_column_name_left);\n+\n+    AddedColumns added_columns(\n+        block_with_columns_to_add,\n+        block,\n+        savedBlockSample(),\n+        *this,\n+        left_key_columns,\n+        key_sizes,\n+        join_mask_column ? &assert_cast<const ColumnUInt8 &>(*join_mask_column).getData() : nullptr,\n+        is_asof_join,\n+        is_join_get);\n+\n     bool has_required_right_keys = (required_right_keys.columns() != 0);\n     added_columns.need_filter = need_filter || has_required_right_keys;\n \n@@ -1324,7 +1383,8 @@ ColumnWithTypeAndName HashJoin::joinGet(const Block & block, const Block & block\n void HashJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)\n {\n     const Names & key_names_left = table_join->keyNamesLeft();\n-    JoinCommon::checkTypesOfKeys(block, key_names_left, right_table_keys, key_names_right);\n+    JoinCommon::checkTypesOfKeys(block, key_names_left, condition_mask_column_name_left,\n+                                 right_sample_block, key_names_right, condition_mask_column_name_right);\n \n     if (overDictionary())\n     {\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex 86c530810590..65e3f5dbabe5 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -377,6 +377,10 @@ class HashJoin : public IJoin\n     /// Left table column names that are sources for required_right_keys columns\n     std::vector<String> required_right_keys_sources;\n \n+    /// Additional conditions for rows to join from JOIN ON section\n+    String condition_mask_column_name_left;\n+    String condition_mask_column_name_right;\n+\n     Poco::Logger * log;\n \n     Block totals;\ndiff --git a/src/Interpreters/MergeJoin.cpp b/src/Interpreters/MergeJoin.cpp\nindex 8f9d94b60799..0a89a4568e3b 100644\n--- a/src/Interpreters/MergeJoin.cpp\n+++ b/src/Interpreters/MergeJoin.cpp\n@@ -1,19 +1,21 @@\n #include <limits>\n \n+#include <Columns/ColumnNullable.h>\n #include <Core/NamesAndTypes.h>\n #include <Core/SortCursor.h>\n-#include <Columns/ColumnNullable.h>\n+#include <DataStreams/BlocksListBlockInputStream.h>\n+#include <DataStreams/TemporaryFileStream.h>\n+#include <DataStreams/materializeBlock.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <Interpreters/MergeJoin.h>\n #include <Interpreters/TableJoin.h>\n-#include <Interpreters/sortBlock.h>\n #include <Interpreters/join_common.h>\n-#include <DataStreams/materializeBlock.h>\n-#include <DataStreams/TemporaryFileStream.h>\n-#include <Processors/Sources/SourceFromInputStream.h>\n+#include <Interpreters/sortBlock.h>\n+#include <Processors/Executors/PipelineExecutingBlockInputStream.h>\n #include <Processors/QueryPipeline.h>\n+#include <Processors/Sources/SourceFromInputStream.h>\n #include <Processors/Transforms/MergeSortingTransform.h>\n-#include <Processors/Executors/PipelineExecutingBlockInputStream.h>\n-#include <DataStreams/BlocksListBlockInputStream.h>\n \n \n namespace DB\n@@ -23,12 +25,50 @@ namespace ErrorCodes\n {\n     extern const int NOT_IMPLEMENTED;\n     extern const int PARAMETER_OUT_OF_BOUND;\n+    extern const int ILLEGAL_COLUMN;\n     extern const int LOGICAL_ERROR;\n }\n \n namespace\n {\n \n+String deriveTempName(const String & name)\n+{\n+    return \"--\" + name;\n+}\n+\n+/*\n+ * Convert column with conditions for left or right table to join to joining key.\n+ * Input column type is UInt8 output is Nullable(UInt8).\n+ * 0 converted to NULL and such rows won't be joined,\n+ * 1 converted to 0 (any constant non-NULL value to join)\n+ */\n+ColumnWithTypeAndName condtitionColumnToJoinable(const Block & block, const String & src_column_name)\n+{\n+    size_t res_size = block.rows();\n+    auto data_col = ColumnUInt8::create(res_size, 0);\n+    auto null_map = ColumnUInt8::create(res_size, 0);\n+\n+    if (!src_column_name.empty())\n+    {\n+        auto mask_col = JoinCommon::getColumnAsMask(block, src_column_name);\n+        assert(mask_col);\n+        const auto & mask_data = assert_cast<const ColumnUInt8 &>(*mask_col).getData();\n+\n+        for (size_t i = 0; i < res_size; ++i)\n+            null_map->getData()[i] = !mask_data[i];\n+    }\n+\n+    ColumnPtr res_col = ColumnNullable::create(std::move(data_col), std::move(null_map));\n+    DataTypePtr res_col_type = std::make_shared<DataTypeNullable>(std::make_shared<DataTypeUInt8>());\n+    String res_name = deriveTempName(src_column_name);\n+\n+    if (block.has(res_name))\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Conflicting column name '{}'\", res_name);\n+\n+    return {res_col, res_col_type, res_name};\n+}\n+\n template <bool has_left_nulls, bool has_right_nulls>\n int nullableCompareAt(const IColumn & left_column, const IColumn & right_column, size_t lhs_pos, size_t rhs_pos)\n {\n@@ -180,7 +220,7 @@ class MergeJoinCursor\n {\n public:\n     MergeJoinCursor(const Block & block, const SortDescription & desc_)\n-        : impl(SortCursorImpl(block, desc_))\n+        : impl(block, desc_)\n     {\n         /// SortCursorImpl can work with permutation, but MergeJoinCursor can't.\n         if (impl.permutation)\n@@ -320,14 +360,17 @@ MutableColumns makeMutableColumns(const Block & block, size_t rows_to_reserve =\n void makeSortAndMerge(const Names & keys, SortDescription & sort, SortDescription & merge)\n {\n     NameSet unique_keys;\n+    for (const auto & sd: merge)\n+        unique_keys.insert(sd.column_name);\n+\n     for (const auto & key_name : keys)\n     {\n-        merge.emplace_back(SortColumnDescription(key_name, 1, 1));\n+        merge.emplace_back(key_name);\n \n-        if (!unique_keys.count(key_name))\n+        if (!unique_keys.contains(key_name))\n         {\n             unique_keys.insert(key_name);\n-            sort.emplace_back(SortColumnDescription(key_name, 1, 1));\n+            sort.emplace_back(key_name);\n         }\n     }\n }\n@@ -464,15 +507,31 @@ MergeJoin::MergeJoin(std::shared_ptr<TableJoin> table_join_, const Block & right\n                             ErrorCodes::PARAMETER_OUT_OF_BOUND);\n     }\n \n-    for (const auto & right_key : table_join->keyNamesRight())\n+    std::tie(mask_column_name_left, mask_column_name_right) = table_join->joinConditionColumnNames();\n+\n+    /// Add auxiliary joining keys to join only rows where conditions from JOIN ON sections holds\n+    /// Input boolean column converted to nullable and only rows with non NULLS value will be joined\n+    if (!mask_column_name_left.empty() || !mask_column_name_right.empty())\n+    {\n+        JoinCommon::checkTypesOfMasks({}, \"\", right_sample_block, mask_column_name_right);\n+\n+        key_names_left.push_back(deriveTempName(mask_column_name_left));\n+        key_names_right.push_back(deriveTempName(mask_column_name_right));\n+    }\n+\n+    key_names_left.insert(key_names_left.end(), table_join->keyNamesLeft().begin(), table_join->keyNamesLeft().end());\n+    key_names_right.insert(key_names_right.end(), table_join->keyNamesRight().begin(), table_join->keyNamesRight().end());\n+\n+    addConditionJoinColumn(right_sample_block, JoinTableSide::Right);\n+    JoinCommon::splitAdditionalColumns(key_names_right, right_sample_block, right_table_keys, right_columns_to_add);\n+\n+    for (const auto & right_key : key_names_right)\n     {\n         if (right_sample_block.getByName(right_key).type->lowCardinality())\n             lowcard_right_keys.push_back(right_key);\n     }\n-\n-    table_join->splitAdditionalColumns(right_sample_block, right_table_keys, right_columns_to_add);\n     JoinCommon::removeLowCardinalityInplace(right_table_keys);\n-    JoinCommon::removeLowCardinalityInplace(right_sample_block, table_join->keyNamesRight());\n+    JoinCommon::removeLowCardinalityInplace(right_sample_block, key_names_right);\n \n     const NameSet required_right_keys = table_join->requiredRightKeys();\n     for (const auto & column : right_table_keys)\n@@ -484,8 +543,8 @@ MergeJoin::MergeJoin(std::shared_ptr<TableJoin> table_join_, const Block & right\n     if (nullable_right_side)\n         JoinCommon::convertColumnsToNullable(right_columns_to_add);\n \n-    makeSortAndMerge(table_join->keyNamesLeft(), left_sort_description, left_merge_description);\n-    makeSortAndMerge(table_join->keyNamesRight(), right_sort_description, right_merge_description);\n+    makeSortAndMerge(key_names_left, left_sort_description, left_merge_description);\n+    makeSortAndMerge(key_names_right, right_sort_description, right_merge_description);\n \n     /// Temporary disable 'partial_merge_join_left_table_buffer_bytes' without 'partial_merge_join_optimizations'\n     if (table_join->enablePartialMergeJoinOptimizations())\n@@ -526,7 +585,8 @@ void MergeJoin::mergeInMemoryRightBlocks()\n     pipeline.init(std::move(source));\n \n     /// TODO: there should be no split keys by blocks for RIGHT|FULL JOIN\n-    pipeline.addTransform(std::make_shared<MergeSortingTransform>(pipeline.getHeader(), right_sort_description, max_rows_in_right_block, 0, 0, 0, 0, nullptr, 0));\n+    pipeline.addTransform(std::make_shared<MergeSortingTransform>(\n+        pipeline.getHeader(), right_sort_description, max_rows_in_right_block, 0, 0, 0, 0, nullptr, 0));\n \n     auto sorted_input = PipelineExecutingBlockInputStream(std::move(pipeline));\n \n@@ -602,6 +662,7 @@ bool MergeJoin::addJoinedBlock(const Block & src_block, bool)\n {\n     Block block = modifyRightBlock(src_block);\n \n+    addConditionJoinColumn(block, JoinTableSide::Right);\n     sortBlock(block, right_sort_description);\n     return saveRightBlock(std::move(block));\n }\n@@ -611,16 +672,22 @@ void MergeJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)\n     Names lowcard_keys = lowcard_right_keys;\n     if (block)\n     {\n-        JoinCommon::checkTypesOfKeys(block, table_join->keyNamesLeft(), right_table_keys, table_join->keyNamesRight());\n+        JoinCommon::checkTypesOfMasks(block, mask_column_name_left, right_sample_block, mask_column_name_right);\n+\n+        /// Add auxiliary column, will be removed after joining\n+        addConditionJoinColumn(block, JoinTableSide::Left);\n+\n+        JoinCommon::checkTypesOfKeys(block, key_names_left, right_table_keys, key_names_right);\n+\n         materializeBlockInplace(block);\n \n-        for (const auto & column_name : table_join->keyNamesLeft())\n+        for (const auto & column_name : key_names_left)\n         {\n             if (block.getByName(column_name).type->lowCardinality())\n                 lowcard_keys.push_back(column_name);\n         }\n \n-        JoinCommon::removeLowCardinalityInplace(block, table_join->keyNamesLeft(), false);\n+        JoinCommon::removeLowCardinalityInplace(block, key_names_left, false);\n \n         sortBlock(block, left_sort_description);\n \n@@ -655,6 +722,9 @@ void MergeJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)\n     if (!not_processed && left_blocks_buffer)\n         not_processed = std::make_shared<NotProcessed>(NotProcessed{{}, 0, 0, 0});\n \n+    if (needConditionJoinColumn())\n+        block.erase(deriveTempName(mask_column_name_left));\n+\n     for (const auto & column_name : lowcard_keys)\n     {\n         if (!block.has(column_name))\n@@ -697,7 +767,7 @@ void MergeJoin::joinSortedBlock(Block & block, ExtraBlockPtr & not_processed)\n \n             if (skip_not_intersected)\n             {\n-                int intersection = left_cursor.intersect(min_max_right_blocks[i], table_join->keyNamesRight());\n+                int intersection = left_cursor.intersect(min_max_right_blocks[i], key_names_right);\n                 if (intersection < 0)\n                     break; /// (left) ... (right)\n                 if (intersection > 0)\n@@ -730,7 +800,7 @@ void MergeJoin::joinSortedBlock(Block & block, ExtraBlockPtr & not_processed)\n \n             if (skip_not_intersected)\n             {\n-                int intersection = left_cursor.intersect(min_max_right_blocks[i], table_join->keyNamesRight());\n+                int intersection = left_cursor.intersect(min_max_right_blocks[i], key_names_right);\n                 if (intersection < 0)\n                     break; /// (left) ... (right)\n                 if (intersection > 0)\n@@ -831,7 +901,7 @@ bool MergeJoin::leftJoin(MergeJoinCursor & left_cursor, const Block & left_block\n }\n \n bool MergeJoin::allInnerJoin(MergeJoinCursor & left_cursor, const Block & left_block, RightBlockInfo & right_block_info,\n-                          MutableColumns & left_columns, MutableColumns & right_columns, size_t & left_key_tail)\n+                             MutableColumns & left_columns, MutableColumns & right_columns, size_t & left_key_tail)\n {\n     const Block & right_block = *right_block_info.block;\n     MergeJoinCursor right_cursor(right_block, right_merge_description);\n@@ -970,11 +1040,15 @@ void MergeJoin::initRightTableWriter()\n class NonMergeJoinedBlockInputStream : private NotJoined, public IBlockInputStream\n {\n public:\n-    NonMergeJoinedBlockInputStream(const MergeJoin & parent_, const Block & result_sample_block_, UInt64 max_block_size_)\n+    NonMergeJoinedBlockInputStream(const MergeJoin & parent_,\n+                                   const Block & result_sample_block_,\n+                                   const Names & key_names_right_,\n+                                   UInt64 max_block_size_)\n         : NotJoined(*parent_.table_join,\n                     parent_.modifyRightBlock(parent_.right_sample_block),\n                     parent_.right_sample_block,\n-                    result_sample_block_)\n+                    result_sample_block_,\n+                    {}, key_names_right_)\n         , parent(parent_)\n         , max_block_size(max_block_size_)\n     {}\n@@ -1062,10 +1136,26 @@ class NonMergeJoinedBlockInputStream : private NotJoined, public IBlockInputStre\n BlockInputStreamPtr MergeJoin::createStreamWithNonJoinedRows(const Block & result_sample_block, UInt64 max_block_size) const\n {\n     if (table_join->strictness() == ASTTableJoin::Strictness::All && (is_right || is_full))\n-        return std::make_shared<NonMergeJoinedBlockInputStream>(*this, result_sample_block, max_block_size);\n+        return std::make_shared<NonMergeJoinedBlockInputStream>(*this, result_sample_block, key_names_right, max_block_size);\n     return {};\n }\n \n+bool MergeJoin::needConditionJoinColumn() const\n+{\n+    return !mask_column_name_left.empty() || !mask_column_name_right.empty();\n+}\n+\n+void MergeJoin::addConditionJoinColumn(Block & block, JoinTableSide block_side) const\n+{\n+    if (needConditionJoinColumn())\n+    {\n+        if (block_side == JoinTableSide::Left)\n+            block.insert(condtitionColumnToJoinable(block, mask_column_name_left));\n+        else\n+            block.insert(condtitionColumnToJoinable(block, mask_column_name_right));\n+    }\n+}\n+\n \n MergeJoin::RightBlockInfo::RightBlockInfo(std::shared_ptr<Block> block_, size_t block_number_, size_t & skip_, RowBitmaps * bitmaps_)\n     : block(block_)\ndiff --git a/src/Interpreters/MergeJoin.h b/src/Interpreters/MergeJoin.h\nindex 8c829569a41d..11e5dc86dc2c 100644\n--- a/src/Interpreters/MergeJoin.h\n+++ b/src/Interpreters/MergeJoin.h\n@@ -16,7 +16,7 @@ class TableJoin;\n class MergeJoinCursor;\n struct MergeJoinEqualRange;\n class RowBitmaps;\n-\n+enum class JoinTableSide;\n \n class MergeJoin : public IJoin\n {\n@@ -79,6 +79,14 @@ class MergeJoin : public IJoin\n     Block right_columns_to_add;\n     SortedBlocksWriter::Blocks right_blocks;\n \n+    Names key_names_right;\n+    Names key_names_left;\n+\n+    /// Additional conditions for rows to join from JOIN ON section.\n+    /// Only rows where conditions are met can be joined.\n+    String mask_column_name_left;\n+    String mask_column_name_right;\n+\n     /// Each block stores first and last row from corresponding sorted block on disk\n     Blocks min_max_right_blocks;\n     std::shared_ptr<SortedBlocksBuffer> left_blocks_buffer;\n@@ -151,6 +159,9 @@ class MergeJoin : public IJoin\n     void mergeFlushedRightBlocks();\n \n     void initRightTableWriter();\n+\n+    bool needConditionJoinColumn() const;\n+    void addConditionJoinColumn(Block & block, JoinTableSide block_side) const;\n };\n \n }\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex 122e2cd64793..20e8f6b18b4a 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -1,17 +1,17 @@\n #include <Interpreters/TableJoin.h>\n \n-#include <common/logger_useful.h>\n-\n-#include <Parsers/ASTExpressionList.h>\n+#include <Common/StringUtils/StringUtils.h>\n \n-#include <Core/Settings.h>\n #include <Core/Block.h>\n #include <Core/ColumnsWithTypeAndName.h>\n-\n-#include <Common/StringUtils/StringUtils.h>\n+#include <Core/Settings.h>\n \n #include <DataTypes/DataTypeNullable.h>\n-#include <DataStreams/materializeBlock.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/queryToString.h>\n+\n+#include <common/logger_useful.h>\n \n \n namespace DB\n@@ -132,6 +132,8 @@ ASTPtr TableJoin::leftKeysList() const\n {\n     ASTPtr keys_list = std::make_shared<ASTExpressionList>();\n     keys_list->children = key_asts_left;\n+    if (ASTPtr extra_cond = joinConditionColumn(JoinTableSide::Left))\n+        keys_list->children.push_back(extra_cond);\n     return keys_list;\n }\n \n@@ -140,6 +142,8 @@ ASTPtr TableJoin::rightKeysList() const\n     ASTPtr keys_list = std::make_shared<ASTExpressionList>();\n     if (hasOn())\n         keys_list->children = key_asts_right;\n+    if (ASTPtr extra_cond = joinConditionColumn(JoinTableSide::Right))\n+        keys_list->children.push_back(extra_cond);\n     return keys_list;\n }\n \n@@ -176,22 +180,6 @@ NamesWithAliases TableJoin::getRequiredColumns(const Block & sample, const Names\n     return getNamesWithAliases(required_columns);\n }\n \n-void TableJoin::splitAdditionalColumns(const Block & sample_block, Block & block_keys, Block & block_others) const\n-{\n-    block_others = materializeBlock(sample_block);\n-\n-    for (const String & column_name : key_names_right)\n-    {\n-        /// Extract right keys with correct keys order. There could be the same key names.\n-        if (!block_keys.has(column_name))\n-        {\n-            auto & col = block_others.getByName(column_name);\n-            block_keys.insert(col);\n-            block_others.erase(column_name);\n-        }\n-    }\n-}\n-\n Block TableJoin::getRequiredRightKeys(const Block & right_table_keys, std::vector<String> & keys_sources) const\n {\n     const Names & left_keys = keyNamesLeft();\n@@ -474,4 +462,48 @@ String TableJoin::renamedRightColumnName(const String & name) const\n     return name;\n }\n \n+void TableJoin::addJoinCondition(const ASTPtr & ast, bool is_left)\n+{\n+    LOG_TRACE(&Poco::Logger::get(\"TableJoin\"), \"Add join condition for {} table: {}\", (is_left ? \"left\" : \"right\"), queryToString(ast));\n+\n+    if (is_left)\n+        on_filter_condition_asts_left.push_back(ast);\n+    else\n+        on_filter_condition_asts_right.push_back(ast);\n+}\n+\n+/// Returns all conditions related to one table joined with 'and' function\n+static ASTPtr buildJoinConditionColumn(const ASTs & on_filter_condition_asts)\n+{\n+    if (on_filter_condition_asts.empty())\n+        return nullptr;\n+\n+    if (on_filter_condition_asts.size() == 1)\n+        return on_filter_condition_asts[0];\n+\n+    auto function = std::make_shared<ASTFunction>();\n+    function->name = \"and\";\n+    function->arguments = std::make_shared<ASTExpressionList>();\n+    function->children.push_back(function->arguments);\n+    function->arguments->children = on_filter_condition_asts;\n+    return function;\n+}\n+\n+ASTPtr TableJoin::joinConditionColumn(JoinTableSide side) const\n+{\n+    if (side == JoinTableSide::Left)\n+        return buildJoinConditionColumn(on_filter_condition_asts_left);\n+    return buildJoinConditionColumn(on_filter_condition_asts_right);\n+}\n+\n+std::pair<String, String> TableJoin::joinConditionColumnNames() const\n+{\n+    std::pair<String, String> res;\n+    if (auto cond_ast = joinConditionColumn(JoinTableSide::Left))\n+        res.first = cond_ast->getColumnName();\n+    if (auto cond_ast = joinConditionColumn(JoinTableSide::Right))\n+        res.second = cond_ast->getColumnName();\n+    return res;\n+}\n+\n }\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 08098e5378c6..4c8c16028f59 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -33,6 +33,12 @@ struct Settings;\n class IVolume;\n using VolumePtr = std::shared_ptr<IVolume>;\n \n+enum class JoinTableSide\n+{\n+    Left,\n+    Right\n+};\n+\n class TableJoin\n {\n \n@@ -67,9 +73,12 @@ class TableJoin\n \n     Names key_names_left;\n     Names key_names_right; /// Duplicating names are qualified.\n+    ASTs on_filter_condition_asts_left;\n+    ASTs on_filter_condition_asts_right;\n \n     ASTs key_asts_left;\n     ASTs key_asts_right;\n+\n     ASTTableJoin table_join;\n \n     ASOF::Inequality asof_inequality = ASOF::Inequality::GreaterOrEquals;\n@@ -150,6 +159,23 @@ class TableJoin\n     void addUsingKey(const ASTPtr & ast);\n     void addOnKeys(ASTPtr & left_table_ast, ASTPtr & right_table_ast);\n \n+    /* Conditions for left/right table from JOIN ON section.\n+     *\n+     * Conditions for left and right tables stored separately and united with 'and' function into one column.\n+     * For example for query:\n+     * SELECT ... JOIN ... ON t1.id == t2.id AND expr11(t1) AND expr21(t2) AND expr12(t1) AND expr22(t2)\n+     *\n+     * We will build two new ASTs: `expr11(t1) AND expr12(t1)`, `expr21(t2) AND expr22(t2)`\n+     * Such columns will be added and calculated for left and right tables respectively.\n+     * Only rows where conditions are met (where new columns have non-zero value) will be joined.\n+     *\n+     * NOTE: non-equi condition containing columns from different tables (like `... ON t1.id = t2.id AND t1.val > t2.val)\n+     *     doesn't supported yet, it can be added later.\n+     */\n+    void addJoinCondition(const ASTPtr & ast, bool is_left);\n+    ASTPtr joinConditionColumn(JoinTableSide side) const;\n+    std::pair<String, String> joinConditionColumnNames() const;\n+\n     bool hasUsing() const { return table_join.using_expression_list != nullptr; }\n     bool hasOn() const { return table_join.on_expression != nullptr; }\n \n@@ -201,8 +227,6 @@ class TableJoin\n     /// StorageJoin overrides key names (cause of different names qualification)\n     void setRightKeys(const Names & keys) { key_names_right = keys; }\n \n-    /// Split key and other columns by keys name list\n-    void splitAdditionalColumns(const Block & sample_block, Block & block_keys, Block & block_others) const;\n     Block getRequiredRightKeys(const Block & right_table_keys, std::vector<String> & keys_sources) const;\n \n     String renamedRightColumnName(const String & name) const;\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 2bdad8b698fd..3b6163590f75 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -532,9 +532,12 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTTableJoin & table_\n \n         CollectJoinOnKeysVisitor::Data data{analyzed_join, tables[0], tables[1], aliases, is_asof};\n         CollectJoinOnKeysVisitor(data).visit(table_join.on_expression);\n-        if (!data.has_some)\n+        if (analyzed_join.keyNamesLeft().empty())\n+        {\n             throw Exception(\"Cannot get JOIN keys from JOIN ON section: \" + queryToString(table_join.on_expression),\n                             ErrorCodes::INVALID_JOIN_ON_EXPRESSION);\n+        }\n+\n         if (is_asof)\n             data.asofToJoinKeys();\n     }\ndiff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp\nindex 74f2c26a2ef5..9d6abda42ed8 100644\n--- a/src/Interpreters/join_common.cpp\n+++ b/src/Interpreters/join_common.cpp\n@@ -1,21 +1,29 @@\n #include <Interpreters/join_common.h>\n-#include <Interpreters/TableJoin.h>\n-#include <Interpreters/ActionsDAG.h>\n-#include <Columns/ColumnNullable.h>\n+\n #include <Columns/ColumnLowCardinality.h>\n-#include <DataTypes/DataTypeNullable.h>\n+#include <Columns/ColumnNullable.h>\n+\n+#include <DataStreams/materializeBlock.h>\n+\n #include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/getLeastSupertype.h>\n-#include <DataStreams/materializeBlock.h>\n+\n #include <IO/WriteHelpers.h>\n \n+#include <Interpreters/ActionsDAG.h>\n+#include <Interpreters/TableJoin.h>\n+\n+#include <common/logger_useful.h>\n namespace DB\n {\n \n namespace ErrorCodes\n {\n-    extern const int TYPE_MISMATCH;\n+    extern const int INVALID_JOIN_ON_EXPRESSION;\n     extern const int LOGICAL_ERROR;\n+    extern const int TYPE_MISMATCH;\n }\n \n namespace\n@@ -220,6 +228,12 @@ ColumnRawPtrs materializeColumnsInplace(Block & block, const Names & names)\n     return ptrs;\n }\n \n+ColumnPtr materializeColumn(const Block & block, const String & column_name)\n+{\n+    const auto & src_column = block.getByName(column_name).column;\n+    return recursiveRemoveLowCardinality(src_column->convertToFullColumnIfConst());\n+}\n+\n Columns materializeColumns(const Block & block, const Names & names)\n {\n     Columns materialized;\n@@ -227,8 +241,7 @@ Columns materializeColumns(const Block & block, const Names & names)\n \n     for (const auto & column_name : names)\n     {\n-        const auto & src_column = block.getByName(column_name).column;\n-        materialized.emplace_back(recursiveRemoveLowCardinality(src_column->convertToFullColumnIfConst()));\n+        materialized.emplace_back(materializeColumn(block, column_name));\n     }\n \n     return materialized;\n@@ -294,7 +307,8 @@ ColumnRawPtrs extractKeysForJoin(const Block & block_keys, const Names & key_nam\n     return key_columns;\n }\n \n-void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, const Block & block_right, const Names & key_names_right)\n+void checkTypesOfKeys(const Block & block_left, const Names & key_names_left,\n+                      const Block & block_right, const Names & key_names_right)\n {\n     size_t keys_size = key_names_left.size();\n \n@@ -305,12 +319,38 @@ void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, co\n \n         if (!left_type->equals(*right_type))\n             throw Exception(\"Type mismatch of columns to JOIN by: \"\n-                + key_names_left[i] + \" \" + left_type->getName() + \" at left, \"\n-                + key_names_right[i] + \" \" + right_type->getName() + \" at right\",\n-                ErrorCodes::TYPE_MISMATCH);\n+                            + key_names_left[i] + \" \" + left_type->getName() + \" at left, \"\n+                            + key_names_right[i] + \" \" + right_type->getName() + \" at right\",\n+                            ErrorCodes::TYPE_MISMATCH);\n     }\n }\n \n+void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, const String & condition_name_left,\n+                      const Block & block_right, const Names & key_names_right, const String & condition_name_right)\n+{\n+    checkTypesOfKeys(block_left, key_names_left,block_right,key_names_right);\n+    checkTypesOfMasks(block_left, condition_name_left, block_right, condition_name_right);\n+}\n+\n+void checkTypesOfMasks(const Block & block_left, const String & condition_name_left,\n+                       const Block & block_right, const String & condition_name_right)\n+{\n+    auto check_cond_column_type = [](const Block & block, const String & col_name)\n+    {\n+        if (col_name.empty())\n+            return;\n+\n+        DataTypePtr dtype = removeNullable(recursiveRemoveLowCardinality(block.getByName(col_name).type));\n+\n+        if (!dtype->equals(DataTypeUInt8{}))\n+            throw Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n+                            \"Expected logical expression in JOIN ON section, got unexpected column '{}' of type '{}'\",\n+                            col_name, dtype->getName());\n+    };\n+    check_cond_column_type(block_left, condition_name_left);\n+    check_cond_column_type(block_right, condition_name_right);\n+}\n+\n void createMissedColumns(Block & block)\n {\n     for (size_t i = 0; i < block.columns(); ++i)\n@@ -359,28 +399,80 @@ bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type)\n     return left_type_strict->equals(*right_type_strict);\n }\n \n+ColumnPtr getColumnAsMask(const Block & block, const String & column_name)\n+{\n+    if (column_name.empty())\n+        return nullptr;\n+\n+    const auto & src_col = block.getByName(column_name);\n+\n+    DataTypePtr col_type = recursiveRemoveLowCardinality(src_col.type);\n+    if (isNothing(col_type))\n+        return ColumnUInt8::create(block.rows(), 0);\n+\n+    const auto & join_condition_col = recursiveRemoveLowCardinality(src_col.column->convertToFullColumnIfConst());\n+\n+    if (const auto * nullable_col = typeid_cast<const ColumnNullable *>(join_condition_col.get()))\n+    {\n+        if (isNothing(assert_cast<const DataTypeNullable &>(*col_type).getNestedType()))\n+            return ColumnUInt8::create(block.rows(), 0);\n+\n+        /// Return nested column with NULL set to false\n+        const auto & nest_col = assert_cast<const ColumnUInt8 &>(nullable_col->getNestedColumn());\n+        const auto & null_map = nullable_col->getNullMapColumn();\n+\n+        auto res = ColumnUInt8::create(nullable_col->size(), 0);\n+        for (size_t i = 0, sz = nullable_col->size(); i < sz; ++i)\n+            res->getData()[i] = !null_map.getData()[i] && nest_col.getData()[i];\n+        return res;\n+    }\n+    else\n+        return join_condition_col;\n+}\n+\n+\n+void splitAdditionalColumns(const Names & key_names, const Block & sample_block, Block & block_keys, Block & block_others)\n+{\n+    block_others = materializeBlock(sample_block);\n+\n+    for (const String & column_name : key_names)\n+    {\n+        /// Extract right keys with correct keys order. There could be the same key names.\n+        if (!block_keys.has(column_name))\n+        {\n+            auto & col = block_others.getByName(column_name);\n+            block_keys.insert(col);\n+            block_others.erase(column_name);\n+        }\n+    }\n+}\n+\n }\n \n \n NotJoined::NotJoined(const TableJoin & table_join, const Block & saved_block_sample_, const Block & right_sample_block,\n-                     const Block & result_sample_block_)\n+                     const Block & result_sample_block_, const Names & key_names_left_, const Names & key_names_right_)\n     : saved_block_sample(saved_block_sample_)\n     , result_sample_block(materializeBlock(result_sample_block_))\n+    , key_names_left(key_names_left_.empty() ? table_join.keyNamesLeft() : key_names_left_)\n+    , key_names_right(key_names_right_.empty() ? table_join.keyNamesRight() : key_names_right_)\n {\n     std::vector<String> tmp;\n     Block right_table_keys;\n     Block sample_block_with_columns_to_add;\n-    table_join.splitAdditionalColumns(right_sample_block, right_table_keys, sample_block_with_columns_to_add);\n+\n+    JoinCommon::splitAdditionalColumns(key_names_right, right_sample_block, right_table_keys,\n+                                       sample_block_with_columns_to_add);\n     Block required_right_keys = table_join.getRequiredRightKeys(right_table_keys, tmp);\n \n     std::unordered_map<size_t, size_t> left_to_right_key_remap;\n \n     if (table_join.hasUsing())\n     {\n-        for (size_t i = 0; i < table_join.keyNamesLeft().size(); ++i)\n+        for (size_t i = 0; i < key_names_left.size(); ++i)\n         {\n-            const String & left_key_name = table_join.keyNamesLeft()[i];\n-            const String & right_key_name = table_join.keyNamesRight()[i];\n+            const String & left_key_name = key_names_left[i];\n+            const String & right_key_name = key_names_right[i];\n \n             size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);\n             size_t right_key_pos = saved_block_sample.getPositionByName(right_key_name);\ndiff --git a/src/Interpreters/join_common.h b/src/Interpreters/join_common.h\nindex 2da795d0d4c6..8862116d1fa6 100644\n--- a/src/Interpreters/join_common.h\n+++ b/src/Interpreters/join_common.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <Columns/ColumnsNumber.h>\n #include <Core/Block.h>\n #include <Interpreters/IJoin.h>\n #include <Interpreters/ActionsDAG.h>\n@@ -12,6 +13,7 @@ struct ColumnWithTypeAndName;\n class TableJoin;\n class IColumn;\n using ColumnRawPtrs = std::vector<const IColumn *>;\n+using UInt8ColumnDataPtr = const ColumnUInt8::Container *;\n \n namespace JoinCommon\n {\n@@ -22,6 +24,7 @@ void convertColumnsToNullable(Block & block, size_t starting_pos = 0);\n void removeColumnNullability(ColumnWithTypeAndName & column);\n void changeColumnRepresentation(const ColumnPtr & src_column, ColumnPtr & dst_column);\n ColumnPtr emptyNotNullableClone(const ColumnPtr & column);\n+ColumnPtr materializeColumn(const Block & block, const String & name);\n Columns materializeColumns(const Block & block, const Names & names);\n ColumnRawPtrs materializeColumnsInplace(Block & block, const Names & names);\n ColumnRawPtrs getRawPointers(const Columns & columns);\n@@ -31,8 +34,17 @@ void restoreLowCardinalityInplace(Block & block);\n \n ColumnRawPtrs extractKeysForJoin(const Block & block_keys, const Names & key_names_right);\n \n-/// Throw an exception if blocks have different types of key columns. Compare up to Nullability.\n-void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, const Block & block_right, const Names & key_names_right);\n+/// Throw an exception if join condition column is not UIint8\n+void checkTypesOfMasks(const Block & block_left, const String & condition_name_left,\n+                       const Block & block_right, const String & condition_name_right);\n+\n+/// Throw an exception if blocks have different types of key columns . Compare up to Nullability.\n+void checkTypesOfKeys(const Block & block_left, const Names & key_names_left,\n+                      const Block & block_right, const Names & key_names_right);\n+\n+/// Check both keys and conditions\n+void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, const String & condition_name_left,\n+                      const Block & block_right, const Names & key_names_right, const String & condition_name_right);\n \n void createMissedColumns(Block & block);\n void joinTotals(Block left_totals, Block right_totals, const TableJoin & table_join, Block & out_block);\n@@ -41,6 +53,12 @@ void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count);\n \n bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type);\n \n+/// Return mask array of type ColumnUInt8 for specified column. Source should have type UInt8 or Nullable(UInt8).\n+ColumnPtr getColumnAsMask(const Block & block, const String & column_name);\n+\n+/// Split key and other columns by keys name list\n+void splitAdditionalColumns(const Names & key_names, const Block & sample_block, Block & block_keys, Block & block_others);\n+\n void changeLowCardinalityInplace(ColumnWithTypeAndName & column);\n \n }\n@@ -50,7 +68,7 @@ class NotJoined\n {\n public:\n     NotJoined(const TableJoin & table_join, const Block & saved_block_sample_, const Block & right_sample_block,\n-              const Block & result_sample_block_);\n+              const Block & result_sample_block_, const Names & key_names_left_ = {}, const Names & key_names_right_ = {});\n \n     void correctLowcardAndNullability(MutableColumns & columns_right);\n     void addLeftColumns(Block & block, size_t rows_added) const;\n@@ -61,6 +79,9 @@ class NotJoined\n     Block saved_block_sample;\n     Block result_sample_block;\n \n+    Names key_names_left;\n+    Names key_names_right;\n+\n     ~NotJoined() = default;\n \n private:\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00878_join_unexpected_results.reference b/tests/queries/0_stateless/00878_join_unexpected_results.reference\nindex a389cb47a962..1630e30d6416 100644\n--- a/tests/queries/0_stateless/00878_join_unexpected_results.reference\n+++ b/tests/queries/0_stateless/00878_join_unexpected_results.reference\n@@ -23,10 +23,15 @@ join_use_nulls = 1\n -\n \\N\t\\N\n -\n+1\t1\t\\N\t\\N\n+2\t2\t\\N\t\\N\n -\n 1\t1\t1\t1\n 2\t2\t\\N\t\\N\n -\n+1\t1\t1\t1\n+-\n+2\t2\t\\N\t\\N\n join_use_nulls = 0\n 1\t1\n 2\t2\n@@ -49,7 +54,12 @@ join_use_nulls = 0\n -\n -\n -\n+1\t1\t0\t0\n+2\t2\t0\t0\n -\n 1\t1\t1\t1\n 2\t2\t0\t0\n -\n+1\t1\t1\t1\n+-\n+2\t2\t0\t0\ndiff --git a/tests/queries/0_stateless/00878_join_unexpected_results.sql b/tests/queries/0_stateless/00878_join_unexpected_results.sql\nindex 0aef5208b26e..0ad7b1122e1e 100644\n--- a/tests/queries/0_stateless/00878_join_unexpected_results.sql\n+++ b/tests/queries/0_stateless/00878_join_unexpected_results.sql\n@@ -4,9 +4,8 @@ drop table if exists s;\n create table t(a Int64, b Int64) engine = Memory;\n create table s(a Int64, b Int64) engine = Memory;\n \n-insert into t values(1,1);\n-insert into t values(2,2);\n-insert into s values(1,1);\n+insert into t values (1,1), (2,2);\n+insert into s values (1,1);\n \n select 'join_use_nulls = 1';\n set join_use_nulls = 1;\n@@ -30,11 +29,13 @@ select * from t left outer join s on (t.a=s.a and t.b=s.b) where s.a is null;\n select '-';\n select s.* from t left outer join s on (t.a=s.a and t.b=s.b) where s.a is null;\n select '-';\n-select t.*, s.* from t left join s on (s.a=t.a and t.b=s.b and t.a=toInt64(2)) order by t.a; -- {serverError 403 }\n+select t.*, s.* from t left join s on (s.a=t.a and t.b=s.b and t.a=toInt64(2)) order by t.a;\n select '-';\n select t.*, s.* from t left join s on (s.a=t.a) order by t.a;\n select '-';\n-select t.*, s.* from t left join s on (t.b=toInt64(2) and s.a=t.a) where s.b=2; -- {serverError 403 }\n+select t.*, s.* from t left join s on (t.b=toInt64(1) and s.a=t.a) where s.b=1;\n+select '-';\n+select t.*, s.* from t left join s on (t.b=toInt64(2) and s.a=t.a) where t.b=2;\n \n select 'join_use_nulls = 0';\n set join_use_nulls = 0;\n@@ -58,11 +59,13 @@ select '-';\n select '-';\n -- select s.* from t left outer join s on (t.a=s.a and t.b=s.b) where s.a is null; -- TODO\n select '-';\n-select t.*, s.* from t left join s on (s.a=t.a and t.b=s.b and t.a=toInt64(2)) order by t.a; -- {serverError 403 }\n+select t.*, s.* from t left join s on (s.a=t.a and t.b=s.b and t.a=toInt64(2)) order by t.a;\n select '-';\n select t.*, s.* from t left join s on (s.a=t.a) order by t.a;\n select '-';\n-select t.*, s.* from t left join s on (t.b=toInt64(2) and s.a=t.a) where s.b=2; -- {serverError 403 }\n+select t.*, s.* from t left join s on (t.b=toInt64(1) and s.a=t.a) where s.b=1;\n+select '-';\n+select t.*, s.* from t left join s on (t.b=toInt64(2) and s.a=t.a) where t.b=2;\n \n drop table t;\n drop table s;\ndiff --git a/tests/queries/0_stateless/01095_tpch_like_smoke.reference b/tests/queries/0_stateless/01095_tpch_like_smoke.reference\nindex e47b402bf9f3..8cdcc2b015fd 100644\n--- a/tests/queries/0_stateless/01095_tpch_like_smoke.reference\n+++ b/tests/queries/0_stateless/01095_tpch_like_smoke.reference\n@@ -11,7 +11,7 @@\n 10\n 11\n 12\n-13\tfail: join predicates\n+13\n 14\n 0.000000\n 15\tfail: correlated subquery\ndiff --git a/tests/queries/0_stateless/01095_tpch_like_smoke.sql b/tests/queries/0_stateless/01095_tpch_like_smoke.sql\nindex ffd2e21dc396..5971178ade57 100644\n--- a/tests/queries/0_stateless/01095_tpch_like_smoke.sql\n+++ b/tests/queries/0_stateless/01095_tpch_like_smoke.sql\n@@ -476,7 +476,7 @@ group by\n order by\n     l_shipmode;\n \n-select 13, 'fail: join predicates'; -- TODO: Invalid expression for JOIN ON\n+select 13;\n select\n     c_count,\n     count(*) as custdist\n@@ -484,7 +484,7 @@ from\n     (\n         select\n             c_custkey,\n-            count(o_orderkey)\n+            count(o_orderkey) as c_count\n         from\n             customer left outer join orders on\n                 c_custkey = o_custkey\n@@ -496,7 +496,7 @@ group by\n     c_count\n order by\n     custdist desc,\n-    c_count desc; -- { serverError 403 }\n+    c_count desc;\n \n select 14;\n select\ndiff --git a/tests/queries/0_stateless/01429_join_on_error_messages.sql b/tests/queries/0_stateless/01429_join_on_error_messages.sql\nindex f9e2647f2e36..6e792e90d424 100644\n--- a/tests/queries/0_stateless/01429_join_on_error_messages.sql\n+++ b/tests/queries/0_stateless/01429_join_on_error_messages.sql\n@@ -4,8 +4,8 @@ SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON (A.a = arrayJoin([1])); -- {\n SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON equals(a); -- { serverError 62 }\n SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON less(a); -- { serverError 62 }\n \n-SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b OR a = b; -- { serverError 48 }\n-SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a > b; -- { serverError 48 }\n-SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a < b; -- { serverError 48 }\n-SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a >= b; -- { serverError 48 }\n-SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a <= b; -- { serverError 48 }\n+SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b OR a = b; -- { serverError 403 }\n+SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a > b; -- { serverError 403 }\n+SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a < b; -- { serverError 403 }\n+SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a >= b; -- { serverError 403 }\n+SELECT 1 FROM (select 1 a) A JOIN (select 1 b) B ON a = b AND a <= b; -- { serverError 403 }\ndiff --git a/tests/queries/0_stateless/01881_join_on_conditions.reference b/tests/queries/0_stateless/01881_join_on_conditions.reference\nnew file mode 100644\nindex 000000000000..e1fac0e7dc38\n--- /dev/null\n+++ b/tests/queries/0_stateless/01881_join_on_conditions.reference\n@@ -0,0 +1,108 @@\n+-- hash_join --\n+--\n+222\t2\n+222\t222\n+333\t333\n+--\n+222\t222\n+333\t333\n+--\n+222\n+333\n+--\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+--\n+2\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+--\n+222\t2\n+333\t3\n+222\t2\n+333\t3\n+--\n+0\t\t\t2\tAAA\ta\n+0\t\t\t4\tCCC\tCCC\n+1\t111\t111\t0\t\t\n+2\t222\t2\t0\t\t\n+2\t222\t222\t2\tAAA\tAAA\n+3\t333\t333\t3\tBBB\tBBB\n+--\n+2\t222\t2\t2\tAAA\ta\n+2\t222\t222\t2\tAAA\tAAA\n+-- partial_merge --\n+--\n+222\t2\n+222\t222\n+333\t333\n+--\n+222\t222\n+333\t333\n+--\n+222\n+333\n+--\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+--\n+2\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+2\n+3\n+--\n+222\t2\n+333\t3\n+222\t2\n+333\t3\n+--\n+0\t\t\t2\tAAA\ta\n+0\t\t\t4\tCCC\tCCC\n+1\t111\t111\t0\t\t\n+2\t222\t2\t0\t\t\n+2\t222\t222\t2\tAAA\tAAA\n+3\t333\t333\t3\tBBB\tBBB\n+--\n+2\t222\t2\t2\tAAA\ta\n+2\t222\t222\t2\tAAA\tAAA\ndiff --git a/tests/queries/0_stateless/01881_join_on_conditions.sql b/tests/queries/0_stateless/01881_join_on_conditions.sql\nnew file mode 100644\nindex 000000000000..a34c413845be\n--- /dev/null\n+++ b/tests/queries/0_stateless/01881_join_on_conditions.sql\n@@ -0,0 +1,141 @@\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+DROP TABLE IF EXISTS t2_nullable;\n+DROP TABLE IF EXISTS t2_lc;\n+\n+CREATE TABLE t1 (`id` Int32, key String, key2 String) ENGINE = TinyLog;\n+CREATE TABLE t2 (`id` Int32, key String, key2 String) ENGINE = TinyLog;\n+CREATE TABLE t2_nullable (`id` Int32, key String, key2 Nullable(String)) ENGINE = TinyLog;\n+CREATE TABLE t2_lc (`id` Int32, key String, key2 LowCardinality(String)) ENGINE = TinyLog;\n+\n+INSERT INTO t1 VALUES (1, '111', '111'),(2, '222', '2'),(2, '222', '222'),(3, '333', '333');\n+INSERT INTO t2 VALUES (2, 'AAA', 'AAA'),(2, 'AAA', 'a'),(3, 'BBB', 'BBB'),(4, 'CCC', 'CCC');\n+INSERT INTO t2_nullable VALUES (2, 'AAA', 'AAA'),(2, 'AAA', 'a'),(3, 'BBB', NULL),(4, 'CCC', 'CCC');\n+INSERT INTO t2_lc VALUES (2, 'AAA', 'AAA'),(2, 'AAA', 'a'),(3, 'BBB', 'BBB'),(4, 'CCC', 'CCC');\n+\n+SELECT '-- hash_join --';\n+\n+SELECT '--';\n+SELECT t1.key, t1.key2 FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2;\n+SELECT '--';\n+SELECT t1.key, t1.key2 FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2;\n+\n+SELECT '--';\n+SELECT t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2;\n+\n+SELECT '--';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.id > 2;\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.id == 3;\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.key2 == 'BBB';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND (t2.key == t2.key2 OR isNull(t2.key2)) AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_lc as t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND isNull(t2.key2);\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND t1.key2 like '33%';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.id >= length(t1.key);\n+\n+-- DISTINCT is used to remove the difference between 'hash' and 'merge' join: 'merge' doesn't support `any_join_distinct_right_table_keys`\n+\n+SELECT '--';\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND t2.key2 != '';\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(t2.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(t2.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(toNullable(t2.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(toLowCardinality(t2.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(t1.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(t1.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(toNullable(t1.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(toLowCardinality(t1.key2 != ''));\n+\n+SELECT '--';\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND e; \n+-- `e + 1` is UInt16\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND e + 1; -- { serverError 403 }\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toUInt8(e + 1); \n+\n+SELECT '--';\n+SELECT t1.id, t1.key, t1.key2, t2.id, t2.key, t2.key2  FROM t1 FULL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 ORDER BY t1.id, t2.id;\n+\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id + 2; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.id + 2; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.key; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key; -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON t2.key == t2.key2 AND (t1.id == t2.id OR isNull(t2.key2)); -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON t2.key == t2.key2 OR t1.id == t2.id; -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON (t2.key == t2.key2 AND (t1.key == t1.key2 AND t1.key != 'XXX' OR t1.id == t2.id)) AND t1.id == t2.id; -- { serverError 403 }\n+-- non-equi condition containing columns from different tables doesn't supported yet\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id >= t2.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.id >= length(t2.key); -- { serverError 403 }\n+\n+SELECT '--';\n+-- length(t1.key2) == length(t2.key2) is expression for columns from both tables, it works because it part of joining key\n+SELECT t1.*, t2.* FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND length(t1.key2) == length(t2.key2) AND t1.key != '333';\n+\n+SET join_algorithm = 'partial_merge';\n+\n+SELECT '-- partial_merge --';\n+\n+SELECT '--';\n+SELECT t1.key, t1.key2 FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2;\n+SELECT '--';\n+SELECT t1.key, t1.key2 FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2;\n+\n+SELECT '--';\n+SELECT t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2;\n+\n+SELECT '--';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.id > 2;\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.id == 3;\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t2.key2 == 'BBB';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND (t2.key == t2.key2 OR isNull(t2.key2)) AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_lc as t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.key2 == '333';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND isNull(t2.key2);\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND t1.key2 like '33%';\n+SELECT '333' = t1.key FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.id >= length(t1.key);\n+\n+-- DISTINCT is used to remove the difference between 'hash' and 'merge' join: 'merge' doesn't support `any_join_distinct_right_table_keys`\n+\n+SELECT '--';\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2_nullable as t2 ON t1.id == t2.id AND t2.key2 != '';\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(t2.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(t2.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(toNullable(t2.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(toLowCardinality(t2.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(t1.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(t1.key2 != '');\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toLowCardinality(toNullable(t1.key2 != ''));\n+SELECT DISTINCT t1.id FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toNullable(toLowCardinality(t1.key2 != ''));\n+\n+SELECT '--';\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND e; \n+-- `e + 1` is UInt16\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND e + 1; -- { serverError 403 }\n+SELECT DISTINCT t1.key, toUInt8(t1.id) as e FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND toUInt8(e + 1); \n+\n+SELECT '--';\n+SELECT t1.id, t1.key, t1.key2, t2.id, t2.key, t2.key2  FROM t1 FULL JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 ORDER BY t1.id, t2.id;\n+\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id + 2; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.id + 2; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.key; -- { serverError 403 }\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t2.key; -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON t2.key == t2.key2 AND (t1.id == t2.id OR isNull(t2.key2)); -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON t2.key == t2.key2 OR t1.id == t2.id; -- { serverError 403 }\n+SELECT * FROM t1 JOIN t2 ON (t2.key == t2.key2 AND (t1.key == t1.key2 AND t1.key != 'XXX' OR t1.id == t2.id)) AND t1.id == t2.id; -- { serverError 403 }\n+-- non-equi condition containing columns from different tables doesn't supported yet\n+SELECT * FROM t1 INNER ALL JOIN t2 ON t1.id == t2.id AND t1.id >= t2.id; -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND t2.key == t2.key2 AND t1.key == t1.key2 AND t1.id >= length(t2.key); -- { serverError 403 }\n+\n+SELECT '--';\n+-- length(t1.key2) == length(t2.key2) is expression for columns from both tables, it works because it part of joining key\n+SELECT t1.*, t2.* FROM t1 INNER ANY JOIN t2 ON t1.id == t2.id AND length(t1.key2) == length(t2.key2) AND t1.key != '333';\n+\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+DROP TABLE IF EXISTS t2_nullable;\n+DROP TABLE IF EXISTS t2_lc;\n",
  "problem_statement": "Support filters in `JOIN ON` section\nSupport in `JOIN ON` section filters that affect columns from only one table. For use case see\r\nhttps://stackoverflow.com/questions/5284929/mysql-left-join-with-optional-value-in-second-table\r\n\r\nNow it's only move such conditions from `ON` section to `WHERE`, but we need to handle this filters inside join implementation. It will also fix https://github.com/ClickHouse/ClickHouse/issues/21671\n",
  "hints_text": "",
  "created_at": "2021-05-22T21:03:16Z",
  "modified_files": [
    "src/Common/ColumnsHashingImpl.h",
    "src/Core/SortDescription.h",
    "src/Interpreters/CollectJoinOnKeysVisitor.cpp",
    "src/Interpreters/CollectJoinOnKeysVisitor.h",
    "src/Interpreters/ExpressionActions.cpp",
    "src/Interpreters/HashJoin.cpp",
    "src/Interpreters/HashJoin.h",
    "src/Interpreters/MergeJoin.cpp",
    "src/Interpreters/MergeJoin.h",
    "src/Interpreters/TableJoin.cpp",
    "src/Interpreters/TableJoin.h",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/join_common.cpp",
    "src/Interpreters/join_common.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00878_join_unexpected_results.reference",
    "tests/queries/0_stateless/00878_join_unexpected_results.sql",
    "tests/queries/0_stateless/01095_tpch_like_smoke.reference",
    "tests/queries/0_stateless/01095_tpch_like_smoke.sql",
    "tests/queries/0_stateless/01429_join_on_error_messages.sql",
    "b/tests/queries/0_stateless/01881_join_on_conditions.reference",
    "b/tests/queries/0_stateless/01881_join_on_conditions.sql"
  ]
}