{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23631,
  "instance_id": "ClickHouse__ClickHouse-23631",
  "issue_numbers": [
    "24018",
    "7834",
    "17828",
    "23936",
    "4176"
  ],
  "base_commit": "6d0bd4f7d2f3a08b5bba4f02eeb9e06d8a5d379a",
  "patch": "diff --git a/base/common/DecomposedFloat.h b/base/common/DecomposedFloat.h\nnew file mode 100644\nindex 000000000000..078ba823c153\n--- /dev/null\n+++ b/base/common/DecomposedFloat.h\n@@ -0,0 +1,216 @@\n+#pragma once\n+\n+#include <cstdint>\n+#include <cstddef>\n+#include <cstring>\n+#include <common/extended_types.h>\n+\n+\n+/// Allows to check the internals of IEEE-754 floating point number.\n+\n+template <typename T> struct FloatTraits;\n+\n+template <>\n+struct FloatTraits<float>\n+{\n+    using UInt = uint32_t;\n+    static constexpr size_t bits = 32;\n+    static constexpr size_t exponent_bits = 8;\n+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;\n+};\n+\n+template <>\n+struct FloatTraits<double>\n+{\n+    using UInt = uint64_t;\n+    static constexpr size_t bits = 64;\n+    static constexpr size_t exponent_bits = 11;\n+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;\n+};\n+\n+\n+/// x = sign * (2 ^ normalized_exponent) * (1 + mantissa * 2 ^ -mantissa_bits)\n+/// x = sign * (2 ^ normalized_exponent + mantissa * 2 ^ (normalized_exponent - mantissa_bits))\n+template <typename T>\n+struct DecomposedFloat\n+{\n+    using Traits = FloatTraits<T>;\n+\n+    DecomposedFloat(T x)\n+    {\n+        memcpy(&x_uint, &x, sizeof(x));\n+    }\n+\n+    typename Traits::UInt x_uint;\n+\n+    bool is_negative() const\n+    {\n+        return x_uint >> (Traits::bits - 1);\n+    }\n+\n+    /// Returns 0 for both +0. and -0.\n+    int sign() const\n+    {\n+        return (exponent() == 0 && mantissa() == 0)\n+            ? 0\n+            : (is_negative()\n+                ? -1\n+                : 1);\n+    }\n+\n+    uint16_t exponent() const\n+    {\n+        return (x_uint >> (Traits::mantissa_bits)) & (((1ull << (Traits::exponent_bits + 1)) - 1) >> 1);\n+    }\n+\n+    int16_t normalized_exponent() const\n+    {\n+        return int16_t(exponent()) - ((1ull << (Traits::exponent_bits - 1)) - 1);\n+    }\n+\n+    uint64_t mantissa() const\n+    {\n+        return x_uint & ((1ull << Traits::mantissa_bits) - 1);\n+    }\n+\n+    int64_t mantissa_with_sign() const\n+    {\n+        return is_negative() ? -mantissa() : mantissa();\n+    }\n+\n+    /// NOTE Probably floating point instructions can be better.\n+    bool is_integer_in_representable_range() const\n+    {\n+        return x_uint == 0\n+            || (normalized_exponent() >= 0  /// The number is not less than one\n+                /// The number is inside the range where every integer has exact representation in float\n+                && normalized_exponent() <= static_cast<int16_t>(Traits::mantissa_bits)\n+                /// After multiplying by 2^exp, the fractional part becomes zero, means the number is integer\n+                && ((mantissa() & ((1ULL << (Traits::mantissa_bits - normalized_exponent())) - 1)) == 0));\n+    }\n+\n+\n+    /// Compare float with integer of arbitrary width (both signed and unsigned are supported). Assuming two's complement arithmetic.\n+    /// Infinities are compared correctly. NaNs are treat similarly to infinities, so they can be less than all numbers.\n+    /// (note that we need total order)\n+    template <typename Int>\n+    int compare(Int rhs)\n+    {\n+        if (rhs == 0)\n+            return sign();\n+\n+        /// Different signs\n+        if (is_negative() && rhs > 0)\n+            return -1;\n+        if (!is_negative() && rhs < 0)\n+            return 1;\n+\n+        /// Fractional number with magnitude less than one\n+        if (normalized_exponent() < 0)\n+        {\n+            if (!is_negative())\n+                return rhs > 0 ? -1 : 1;\n+            else\n+                return rhs >= 0 ? -1 : 1;\n+        }\n+\n+        /// The case of the most negative integer\n+        if constexpr (is_signed_v<Int>)\n+        {\n+            if (rhs == std::numeric_limits<Int>::lowest())\n+            {\n+                assert(is_negative());\n+\n+                if (normalized_exponent() < static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))\n+                    return 1;\n+                if (normalized_exponent() > static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))\n+                    return -1;\n+\n+                if (mantissa() == 0)\n+                    return 0;\n+                else\n+                    return -1;\n+            }\n+        }\n+\n+        /// Too large number: abs(float) > abs(rhs). Also the case with infinities and NaN.\n+        if (normalized_exponent() >= static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))\n+            return is_negative() ? -1 : 1;\n+\n+        using UInt = make_unsigned_t<Int>;\n+        UInt uint_rhs = rhs < 0 ? -rhs : rhs;\n+\n+        /// Smaller octave: abs(rhs) < abs(float)\n+        if (uint_rhs < (static_cast<UInt>(1) << normalized_exponent()))\n+            return is_negative() ? -1 : 1;\n+\n+        /// Larger octave: abs(rhs) > abs(float)\n+        if (normalized_exponent() + 1 < static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>)\n+            && uint_rhs >= (static_cast<UInt>(1) << (normalized_exponent() + 1)))\n+            return is_negative() ? 1 : -1;\n+\n+        /// The same octave\n+        /// uint_rhs == 2 ^ normalized_exponent + mantissa * 2 ^ (normalized_exponent - mantissa_bits)\n+\n+        bool large_and_always_integer = normalized_exponent() >= static_cast<int16_t>(Traits::mantissa_bits);\n+\n+        typename Traits::UInt a = large_and_always_integer\n+            ? mantissa() << (normalized_exponent() - Traits::mantissa_bits)\n+            : mantissa() >> (Traits::mantissa_bits - normalized_exponent());\n+\n+        typename Traits::UInt b = uint_rhs - (static_cast<UInt>(1) << normalized_exponent());\n+\n+        if (a < b)\n+            return is_negative() ? 1 : -1;\n+        if (a > b)\n+            return is_negative() ? -1 : 1;\n+\n+        /// Float has no fractional part means that the numbers are equal.\n+        if (large_and_always_integer || (mantissa() & ((1ULL << (Traits::mantissa_bits - normalized_exponent())) - 1)) == 0)\n+            return 0;\n+        else\n+            /// Float has fractional part means its abs value is larger.\n+            return is_negative() ? -1 : 1;\n+    }\n+\n+\n+    template <typename Int>\n+    bool equals(Int rhs)\n+    {\n+        return compare(rhs) == 0;\n+    }\n+\n+    template <typename Int>\n+    bool notEquals(Int rhs)\n+    {\n+        return compare(rhs) != 0;\n+    }\n+\n+    template <typename Int>\n+    bool less(Int rhs)\n+    {\n+        return compare(rhs) < 0;\n+    }\n+\n+    template <typename Int>\n+    bool greater(Int rhs)\n+    {\n+        return compare(rhs) > 0;\n+    }\n+\n+    template <typename Int>\n+    bool lessOrEquals(Int rhs)\n+    {\n+        return compare(rhs) <= 0;\n+    }\n+\n+    template <typename Int>\n+    bool greaterOrEquals(Int rhs)\n+    {\n+        return compare(rhs) >= 0;\n+    }\n+};\n+\n+\n+using DecomposedFloat64 = DecomposedFloat<double>;\n+using DecomposedFloat32 = DecomposedFloat<float>;\ndiff --git a/base/common/arithmeticOverflow.h b/base/common/arithmeticOverflow.h\nindex c170d2146367..175e75a62f4b 100644\n--- a/base/common/arithmeticOverflow.h\n+++ b/base/common/arithmeticOverflow.h\n@@ -56,27 +56,33 @@ namespace common\n     }\n \n     template <>\n-    inline bool addOverflow(__int128 x, __int128 y, __int128 & res)\n+    inline bool addOverflow(Int128 x, Int128 y, Int128 & res)\n     {\n-        static constexpr __int128 min_int128 = minInt128();\n-        static constexpr __int128 max_int128 = maxInt128();\n         res = addIgnoreOverflow(x, y);\n-        return (y > 0 && x > max_int128 - y) || (y < 0 && x < min_int128 - y);\n+        return (y > 0 && x > std::numeric_limits<Int128>::max() - y) ||\n+            (y < 0 && x < std::numeric_limits<Int128>::min() - y);\n     }\n \n     template <>\n-    inline bool addOverflow(wInt256 x, wInt256 y, wInt256 & res)\n+    inline bool addOverflow(UInt128 x, UInt128 y, UInt128 & res)\n     {\n         res = addIgnoreOverflow(x, y);\n-        return (y > 0 && x > std::numeric_limits<wInt256>::max() - y) ||\n-            (y < 0 && x < std::numeric_limits<wInt256>::min() - y);\n+        return x > std::numeric_limits<UInt128>::max() - y;\n     }\n \n     template <>\n-    inline bool addOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n+    inline bool addOverflow(Int256 x, Int256 y, Int256 & res)\n     {\n         res = addIgnoreOverflow(x, y);\n-        return x > std::numeric_limits<wUInt256>::max() - y;\n+        return (y > 0 && x > std::numeric_limits<Int256>::max() - y) ||\n+            (y < 0 && x < std::numeric_limits<Int256>::min() - y);\n+    }\n+\n+    template <>\n+    inline bool addOverflow(UInt256 x, UInt256 y, UInt256 & res)\n+    {\n+        res = addIgnoreOverflow(x, y);\n+        return x > std::numeric_limits<UInt256>::max() - y;\n     }\n \n     template <typename T>\n@@ -104,24 +110,30 @@ namespace common\n     }\n \n     template <>\n-    inline bool subOverflow(__int128 x, __int128 y, __int128 & res)\n+    inline bool subOverflow(Int128 x, Int128 y, Int128 & res)\n     {\n-        static constexpr __int128 min_int128 = minInt128();\n-        static constexpr __int128 max_int128 = maxInt128();\n         res = subIgnoreOverflow(x, y);\n-        return (y < 0 && x > max_int128 + y) || (y > 0 && x < min_int128 + y);\n+        return (y < 0 && x > std::numeric_limits<Int128>::max() + y) ||\n+            (y > 0 && x < std::numeric_limits<Int128>::min() + y);\n     }\n \n     template <>\n-    inline bool subOverflow(wInt256 x, wInt256 y, wInt256 & res)\n+    inline bool subOverflow(UInt128 x, UInt128 y, UInt128 & res)\n     {\n         res = subIgnoreOverflow(x, y);\n-        return (y < 0 && x > std::numeric_limits<wInt256>::max() + y) ||\n-            (y > 0 && x < std::numeric_limits<wInt256>::min() + y);\n+        return x < y;\n     }\n \n     template <>\n-    inline bool subOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n+    inline bool subOverflow(Int256 x, Int256 y, Int256 & res)\n+    {\n+        res = subIgnoreOverflow(x, y);\n+        return (y < 0 && x > std::numeric_limits<Int256>::max() + y) ||\n+            (y > 0 && x < std::numeric_limits<Int256>::min() + y);\n+    }\n+\n+    template <>\n+    inline bool subOverflow(UInt256 x, UInt256 y, UInt256 & res)\n     {\n         res = subIgnoreOverflow(x, y);\n         return x < y;\n@@ -151,36 +163,33 @@ namespace common\n         return __builtin_smulll_overflow(x, y, &res);\n     }\n \n+    /// Overflow check is not implemented for big integers.\n+\n     template <>\n-    inline bool mulOverflow(__int128 x, __int128 y, __int128 & res)\n+    inline bool mulOverflow(Int128 x, Int128 y, Int128 & res)\n     {\n         res = mulIgnoreOverflow(x, y);\n-        if (!x || !y)\n-            return false;\n-\n-        unsigned __int128 a = (x > 0) ? x : -x;\n-        unsigned __int128 b = (y > 0) ? y : -y;\n-        return mulIgnoreOverflow(a, b) / b != a;\n+        return false;\n     }\n \n     template <>\n-    inline bool mulOverflow(wInt256 x, wInt256 y, wInt256 & res)\n+    inline bool mulOverflow(Int256 x, Int256 y, Int256 & res)\n     {\n         res = mulIgnoreOverflow(x, y);\n-        if (!x || !y)\n-            return false;\n+        return false;\n+    }\n \n-        wInt256 a = (x > 0) ? x : -x;\n-        wInt256 b = (y > 0) ? y : -y;\n-        return mulIgnoreOverflow(a, b) / b != a;\n+    template <>\n+    inline bool mulOverflow(UInt128 x, UInt128 y, UInt128 & res)\n+    {\n+        res = mulIgnoreOverflow(x, y);\n+        return false;\n     }\n \n     template <>\n-    inline bool mulOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)\n+    inline bool mulOverflow(UInt256 x, UInt256 y, UInt256 & res)\n     {\n         res = mulIgnoreOverflow(x, y);\n-        if (!x || !y)\n-            return false;\n-        return res / y != x;\n+        return false;\n     }\n }\ndiff --git a/base/common/extended_types.h b/base/common/extended_types.h\nindex 2ae70c0f4320..79209568ef51 100644\n--- a/base/common/extended_types.h\n+++ b/base/common/extended_types.h\n@@ -5,16 +5,14 @@\n #include <common/types.h>\n #include <common/wide_integer.h>\n \n-using Int128 = __int128;\n \n-using wInt256 = wide::integer<256, signed>;\n-using wUInt256 = wide::integer<256, unsigned>;\n+using Int128 = wide::integer<128, signed>;\n+using UInt128 = wide::integer<128, unsigned>;\n+using Int256 = wide::integer<256, signed>;\n+using UInt256 = wide::integer<256, unsigned>;\n \n-static_assert(sizeof(wInt256) == 32);\n-static_assert(sizeof(wUInt256) == 32);\n-\n-static constexpr __int128 minInt128() { return static_cast<unsigned __int128>(1) << 127; }\n-static constexpr __int128 maxInt128() { return (static_cast<unsigned __int128>(1) << 127) - 1; }\n+static_assert(sizeof(Int256) == 32);\n+static_assert(sizeof(UInt256) == 32);\n \n /// The standard library type traits, such as std::is_arithmetic, with one exception\n /// (std::common_type), are \"set in stone\". Attempting to specialize them causes undefined behavior.\n@@ -26,7 +24,7 @@ struct is_signed\n };\n \n template <> struct is_signed<Int128> { static constexpr bool value = true; };\n-template <> struct is_signed<wInt256> { static constexpr bool value = true; };\n+template <> struct is_signed<Int256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_signed_v = is_signed<T>::value;\n@@ -37,7 +35,8 @@ struct is_unsigned\n     static constexpr bool value = std::is_unsigned_v<T>;\n };\n \n-template <> struct is_unsigned<wUInt256> { static constexpr bool value = true; };\n+template <> struct is_unsigned<UInt128> { static constexpr bool value = true; };\n+template <> struct is_unsigned<UInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_unsigned_v = is_unsigned<T>::value;\n@@ -51,8 +50,9 @@ struct is_integer\n };\n \n template <> struct is_integer<Int128> { static constexpr bool value = true; };\n-template <> struct is_integer<wInt256> { static constexpr bool value = true; };\n-template <> struct is_integer<wUInt256> { static constexpr bool value = true; };\n+template <> struct is_integer<UInt128> { static constexpr bool value = true; };\n+template <> struct is_integer<Int256> { static constexpr bool value = true; };\n+template <> struct is_integer<UInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_integer_v = is_integer<T>::value;\n@@ -64,7 +64,11 @@ struct is_arithmetic\n     static constexpr bool value = std::is_arithmetic_v<T>;\n };\n \n-template <> struct is_arithmetic<__int128> { static constexpr bool value = true; };\n+template <> struct is_arithmetic<Int128> { static constexpr bool value = true; };\n+template <> struct is_arithmetic<UInt128> { static constexpr bool value = true; };\n+template <> struct is_arithmetic<Int256> { static constexpr bool value = true; };\n+template <> struct is_arithmetic<UInt256> { static constexpr bool value = true; };\n+\n \n template <typename T>\n inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;\n@@ -75,9 +79,10 @@ struct make_unsigned\n     typedef std::make_unsigned_t<T> type;\n };\n \n-template <> struct make_unsigned<Int128> { using type = unsigned __int128; };\n-template <> struct make_unsigned<wInt256>  { using type = wUInt256; };\n-template <> struct make_unsigned<wUInt256> { using type = wUInt256; };\n+template <> struct make_unsigned<Int128> { using type = UInt128; };\n+template <> struct make_unsigned<UInt128> { using type = UInt128; };\n+template <> struct make_unsigned<Int256>  { using type = UInt256; };\n+template <> struct make_unsigned<UInt256> { using type = UInt256; };\n \n template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;\n \n@@ -87,8 +92,10 @@ struct make_signed\n     typedef std::make_signed_t<T> type;\n };\n \n-template <> struct make_signed<wInt256>  { using type = wInt256; };\n-template <> struct make_signed<wUInt256> { using type = wInt256; };\n+template <> struct make_signed<Int128>  { using type = Int128; };\n+template <> struct make_signed<UInt128> { using type = Int128; };\n+template <> struct make_signed<Int256>  { using type = Int256; };\n+template <> struct make_signed<UInt256> { using type = Int256; };\n \n template <typename T> using make_signed_t = typename make_signed<T>::type;\n \n@@ -98,8 +105,10 @@ struct is_big_int\n     static constexpr bool value = false;\n };\n \n-template <> struct is_big_int<wInt256> { static constexpr bool value = true; };\n-template <> struct is_big_int<wUInt256> { static constexpr bool value = true; };\n+template <> struct is_big_int<Int128> { static constexpr bool value = true; };\n+template <> struct is_big_int<UInt128> { static constexpr bool value = true; };\n+template <> struct is_big_int<Int256> { static constexpr bool value = true; };\n+template <> struct is_big_int<UInt256> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_big_int_v = is_big_int<T>::value;\ndiff --git a/base/common/itoa.h b/base/common/itoa.h\nindex a02e7b68c059..4c86239de36c 100644\n--- a/base/common/itoa.h\n+++ b/base/common/itoa.h\n@@ -30,9 +30,8 @@\n #include <cstddef>\n #include <cstring>\n #include <type_traits>\n+#include <common/extended_types.h>\n \n-using int128_t = __int128;\n-using uint128_t = unsigned __int128;\n \n namespace impl\n {\n@@ -106,7 +105,7 @@ using UnsignedOfSize = typename SelectType\n     uint16_t,\n     uint32_t,\n     uint64_t,\n-    uint128_t\n+    __uint128_t\n >::Result;\n \n /// Holds the result of dividing an unsigned N-byte variable by 10^N resulting in\n@@ -313,7 +312,8 @@ namespace convert\n     }\n }\n \n-static inline int digits10(uint128_t x)\n+template <typename T>\n+static inline int digits10(T x)\n {\n     if (x < 10ULL)\n         return 1;\n@@ -346,8 +346,11 @@ static inline int digits10(uint128_t x)\n     return 12 + digits10(x / 1000000000000ULL);\n }\n \n-static inline char * writeUIntText(uint128_t x, char * p)\n+template <typename T>\n+static inline char * writeUIntText(T x, char * p)\n {\n+    static_assert(is_unsigned_v<T>);\n+\n     int len = digits10(x);\n     auto pp = p + len;\n     while (x >= 100)\n@@ -370,14 +373,28 @@ static inline char * writeLeadingMinus(char * pos)\n     return pos + 1;\n }\n \n-static inline char * writeSIntText(int128_t x, char * pos)\n+template <typename T>\n+static inline char * writeSIntText(T x, char * pos)\n {\n-    static constexpr int128_t min_int128 = uint128_t(1) << 127;\n+    static_assert(std::is_same_v<T, Int128> || std::is_same_v<T, Int256>);\n+\n+    using UnsignedT = make_unsigned_t<T>;\n+    static constexpr T min_int = UnsignedT(1) << (sizeof(T) * 8 - 1);\n \n-    if (unlikely(x == min_int128))\n+    if (unlikely(x == min_int))\n     {\n-        memcpy(pos, \"-170141183460469231731687303715884105728\", 40);\n-        return pos + 40;\n+        if constexpr (std::is_same_v<T, Int128>)\n+        {\n+            const char * res = \"-170141183460469231731687303715884105728\";\n+            memcpy(pos, res, strlen(res));\n+            return pos + strlen(res);\n+        }\n+        else if constexpr (std::is_same_v<T, Int256>)\n+        {\n+            const char * res = \"-57896044618658097711785492504343953926634992332820282019728792003956564819968\";\n+            memcpy(pos, res, strlen(res));\n+            return pos + strlen(res);\n+        }\n     }\n \n     if (x < 0)\n@@ -385,7 +402,7 @@ static inline char * writeSIntText(int128_t x, char * pos)\n         x = -x;\n         pos = writeLeadingMinus(pos);\n     }\n-    return writeUIntText(static_cast<uint128_t>(x), pos);\n+    return writeUIntText(UnsignedT(x), pos);\n }\n \n }\n@@ -403,13 +420,25 @@ inline char * itoa(char8_t i, char * p)\n }\n \n template <>\n-inline char * itoa<uint128_t>(uint128_t i, char * p)\n+inline char * itoa(UInt128 i, char * p)\n+{\n+    return impl::writeUIntText(i, p);\n+}\n+\n+template <>\n+inline char * itoa(Int128 i, char * p)\n+{\n+    return impl::writeSIntText(i, p);\n+}\n+\n+template <>\n+inline char * itoa(UInt256 i, char * p)\n {\n     return impl::writeUIntText(i, p);\n }\n \n template <>\n-inline char * itoa<int128_t>(int128_t i, char * p)\n+inline char * itoa(Int256 i, char * p)\n {\n     return impl::writeSIntText(i, p);\n }\ndiff --git a/base/common/strong_typedef.h b/base/common/strong_typedef.h\nindex 77b83bfa6e5f..a1e2b253aa70 100644\n--- a/base/common/strong_typedef.h\n+++ b/base/common/strong_typedef.h\n@@ -4,7 +4,8 @@\n #include <type_traits>\n #include <utility>\n \n-template <class T, class Tag>\n+\n+template <typename T, typename Tag>\n struct StrongTypedef\n {\n private:\n@@ -38,14 +39,16 @@ struct StrongTypedef\n \n     bool operator==(const Self & rhs) const { return t == rhs.t; }\n     bool operator<(const Self & rhs) const { return t < rhs.t; }\n+    bool operator>(const Self & rhs) const { return t > rhs.t; }\n \n     T & toUnderType() { return t; }\n     const T & toUnderType() const { return t; }\n };\n \n+\n namespace std\n {\n-    template <class T, class Tag>\n+    template <typename T, typename Tag>\n     struct hash<StrongTypedef<T, Tag>>\n     {\n         size_t operator()(const StrongTypedef<T, Tag> & x) const\ndiff --git a/base/common/throwError.h b/base/common/throwError.h\nindex b495a0fbc7af..dd352913e78c 100644\n--- a/base/common/throwError.h\n+++ b/base/common/throwError.h\n@@ -1,13 +1,15 @@\n #pragma once\n+\n #include <stdexcept>\n \n+\n /// Throw DB::Exception-like exception before its definition.\n /// DB::Exception derived from Poco::Exception derived from std::exception.\n-/// DB::Exception generally cought as Poco::Exception. std::exception generally has other catch blocks and could lead to other outcomes.\n+/// DB::Exception generally caught as Poco::Exception. std::exception generally has other catch blocks and could lead to other outcomes.\n /// DB::Exception is not defined yet. It'd better to throw Poco::Exception but we do not want to include any big header here, even <string>.\n /// So we throw some std::exception instead in the hope its catch block is the same as DB::Exception one.\n template <typename T>\n-inline void throwError(const T & err)\n+[[noreturn]] inline void throwError(const T & err)\n {\n     throw std::runtime_error(err);\n }\ndiff --git a/base/common/wide_integer.h b/base/common/wide_integer.h\nindex c9d1eaa32aa8..419b4e4558c6 100644\n--- a/base/common/wide_integer.h\n+++ b/base/common/wide_integer.h\n@@ -58,9 +58,11 @@ class integer\n     using signed_base_type = int64_t;\n \n     // ctors\n-    constexpr integer() noexcept;\n+    constexpr integer() noexcept = default;\n+\n     template <typename T>\n     constexpr integer(T rhs) noexcept;\n+\n     template <typename T>\n     constexpr integer(std::initializer_list<T> il) noexcept;\n \n@@ -108,9 +110,9 @@ class integer\n     constexpr explicit operator bool() const noexcept;\n \n     template <class T>\n-    using __integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;\n+    using _integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;\n \n-    template <class T, class = __integral_not_wide_integer_class<T>>\n+    template <class T, class = _integral_not_wide_integer_class<T>>\n     constexpr operator T() const noexcept;\n \n     constexpr operator long double() const noexcept;\n@@ -119,25 +121,27 @@ class integer\n \n     struct _impl;\n \n+    base_type items[_impl::item_count];\n+\n private:\n     template <size_t Bits2, typename Signed2>\n     friend class integer;\n \n     friend class std::numeric_limits<integer<Bits, signed>>;\n     friend class std::numeric_limits<integer<Bits, unsigned>>;\n-\n-    base_type items[_impl::item_count];\n };\n \n template <typename T>\n static constexpr bool ArithmeticConcept() noexcept;\n+\n template <class T1, class T2>\n-using __only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;\n+using _only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;\n \n template <typename T>\n static constexpr bool IntegralConcept() noexcept;\n+\n template <class T, class T2>\n-using __only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;\n+using _only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;\n \n // Unary operators\n template <size_t Bits, typename Signed>\n@@ -153,54 +157,55 @@ constexpr integer<Bits, Signed> operator+(const integer<Bits, Signed> & lhs) noe\n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator*(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator/(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator+(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator-(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator%(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>\n std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & rhs, const Integral2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator&(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>\n std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & rhs, const Integral2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator|(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>\n std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & rhs, const Integral2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr\n operator^(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>\n+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>\n std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & rhs, const Integral2 & lhs);\n \n // TODO: Integral\n template <size_t Bits, typename Signed>\n constexpr integer<Bits, Signed> operator<<(const integer<Bits, Signed> & lhs, int n) noexcept;\n+\n template <size_t Bits, typename Signed>\n constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, int n) noexcept;\n \n@@ -217,32 +222,32 @@ constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, In\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator<(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator<(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator>(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator>(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator<=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator<=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator>=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator>=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator==(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator==(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator!=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);\n-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>\n+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>\n constexpr bool operator!=(const Arithmetic & rhs, const Arithmetic2 & lhs);\n \n }\ndiff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h\nindex 456c10a22e43..725caec6a3ef 100644\n--- a/base/common/wide_integer_impl.h\n+++ b/base/common/wide_integer_impl.h\n@@ -5,6 +5,7 @@\n /// (See at http://www.boost.org/LICENSE_1_0.txt)\n \n #include \"throwError.h\"\n+\n #include <cmath>\n #include <cfloat>\n #include <cassert>\n@@ -81,7 +82,7 @@ class numeric_limits<wide::integer<Bits, Signed>>\n             res.items[T::_impl::big(0)] = std::numeric_limits<typename wide::integer<Bits, Signed>::signed_base_type>::min();\n             return res;\n         }\n-        return 0;\n+        return wide::integer<Bits, Signed>(0);\n     }\n \n     static constexpr wide::integer<Bits, Signed> max() noexcept\n@@ -176,7 +177,7 @@ struct integer<Bits, Signed>::_impl\n     constexpr static bool is_negative(const integer<B, T> & n) noexcept\n     {\n         if constexpr (std::is_same_v<T, signed>)\n-            return static_cast<signed_base_type>(n.items[big(0)]) < 0;\n+            return static_cast<signed_base_type>(n.items[integer<B, T>::_impl::big(0)]) < 0;\n         else\n             return false;\n     }\n@@ -193,40 +194,36 @@ struct integer<Bits, Signed>::_impl\n     template <size_t B, class S>\n     constexpr static integer<B, S> make_positive(const integer<B, S> & n) noexcept\n     {\n-        return is_negative(n) ? operator_unary_minus(n) : n;\n+        return is_negative(n) ? integer<B, S>(operator_unary_minus(n)) : n;\n     }\n \n     template <typename T>\n     __attribute__((no_sanitize(\"undefined\"))) constexpr static auto to_Integral(T f) noexcept\n     {\n-        if constexpr (std::is_same_v<T, __int128>)\n-            return f;\n-        else if constexpr (std::is_signed_v<T>)\n+        if constexpr (std::is_signed_v<T>)\n             return static_cast<int64_t>(f);\n         else\n             return static_cast<uint64_t>(f);\n     }\n \n     template <typename Integral>\n-    constexpr static void wide_integer_from_bultin(integer<Bits, Signed> & self, Integral rhs) noexcept\n+    constexpr static void wide_integer_from_builtin(integer<Bits, Signed> & self, Integral rhs) noexcept\n     {\n-        self.items[0] = _impl::to_Integral(rhs);\n-        if constexpr (std::is_same_v<Integral, __int128>)\n-            self.items[1] = rhs >> base_bits;\n+        static_assert(sizeof(Integral) <= sizeof(base_type));\n \n-        constexpr const unsigned start = (sizeof(Integral) == 16) ? 2 : 1;\n+        self.items[0] = _impl::to_Integral(rhs);\n \n         if constexpr (std::is_signed_v<Integral>)\n         {\n             if (rhs < 0)\n             {\n-                for (unsigned i = start; i < item_count; ++i)\n+                for (size_t i = 1; i < item_count; ++i)\n                     self.items[i] = -1;\n                 return;\n             }\n         }\n \n-        for (unsigned i = start; i < item_count; ++i)\n+        for (size_t i = 1; i < item_count; ++i)\n             self.items[i] = 0;\n     }\n \n@@ -239,7 +236,8 @@ struct integer<Bits, Signed>::_impl\n      * a_(n - 1) = a_n * max_int + b2, a_n <= max_int <- base case.\n      */\n     template <class T>\n-    constexpr static void set_multiplier(integer<Bits, Signed> & self, T t) noexcept {\n+    constexpr static void set_multiplier(integer<Bits, Signed> & self, T t) noexcept\n+    {\n         constexpr uint64_t max_int = std::numeric_limits<uint64_t>::max();\n \n         /// Implementation specific behaviour on overflow (if we don't check here, stack overflow will triggered in bigint_cast).\n@@ -260,7 +258,8 @@ struct integer<Bits, Signed>::_impl\n         self += static_cast<uint64_t>(t - alpha * static_cast<T>(max_int)); // += b_i\n     }\n \n-    constexpr static void wide_integer_from_bultin(integer<Bits, Signed>& self, double rhs) noexcept {\n+    constexpr static void wide_integer_from_builtin(integer<Bits, Signed>& self, double rhs) noexcept\n+    {\n         constexpr int64_t max_int = std::numeric_limits<int64_t>::max();\n         constexpr int64_t min_int = std::numeric_limits<int64_t>::min();\n \n@@ -383,13 +382,13 @@ struct integer<Bits, Signed>::_impl\n             if (bit_shift)\n                 lhs.items[big(items_shift)] |= std::numeric_limits<base_type>::max() << (base_bits - bit_shift);\n \n-            for (unsigned i = item_count - items_shift; i < items_shift; ++i)\n-                lhs.items[little(i)] = std::numeric_limits<base_type>::max();\n+            for (unsigned i = 0; i < items_shift; ++i)\n+                lhs.items[big(i)] = std::numeric_limits<base_type>::max();\n         }\n         else\n         {\n-            for (unsigned i = item_count - items_shift; i < items_shift; ++i)\n-                lhs.items[little(i)] = 0;\n+            for (unsigned i = 0; i < items_shift; ++i)\n+                lhs.items[big(i)] = 0;\n         }\n \n         return lhs;\n@@ -397,23 +396,23 @@ struct integer<Bits, Signed>::_impl\n \n private:\n     template <typename T>\n-    constexpr static base_type get_item(const T & x, unsigned number)\n+    constexpr static base_type get_item(const T & x, unsigned idx)\n     {\n         if constexpr (IsWideInteger<T>::value)\n         {\n-            if (number < T::_impl::item_count)\n-                return x.items[number];\n+            if (idx < T::_impl::item_count)\n+                return x.items[idx];\n             return 0;\n         }\n         else\n         {\n             if constexpr (sizeof(T) <= sizeof(base_type))\n             {\n-                if (!number)\n+                if (0 == idx)\n                     return x;\n             }\n-            else if (number * sizeof(base_type) < sizeof(T))\n-                return x >> (number * base_bits); // & std::numeric_limits<base_type>::max()\n+            else if (idx * sizeof(base_type) < sizeof(T))\n+                return x >> (idx * base_bits); // & std::numeric_limits<base_type>::max()\n             return 0;\n         }\n     }\n@@ -439,7 +438,7 @@ struct integer<Bits, Signed>::_impl\n \n         for (unsigned i = 1; i < item_count; ++i)\n         {\n-            if (underflows[i-1])\n+            if (underflows[i - 1])\n             {\n                 base_type & res_item = res.items[little(i)];\n                 if (res_item == 0)\n@@ -472,7 +471,7 @@ struct integer<Bits, Signed>::_impl\n \n         for (unsigned i = 1; i < item_count; ++i)\n         {\n-            if (overflows[i-1])\n+            if (overflows[i - 1])\n             {\n                 base_type & res_item = res.items[little(i)];\n                 ++res_item;\n@@ -532,6 +531,17 @@ struct integer<Bits, Signed>::_impl\n             res.items[little(2)] = r12 >> 64;\n             return res;\n         }\n+        else if constexpr (Bits == 128 && sizeof(base_type) == 8)\n+        {\n+            using CompilerUInt128 = unsigned __int128;\n+            CompilerUInt128 a = (CompilerUInt128(lhs.items[1]) << 64) + lhs.items[0];\n+            CompilerUInt128 b = (CompilerUInt128(rhs.items[1]) << 64) + rhs.items[0];\n+            CompilerUInt128 c = a * b;\n+            integer<Bits, Signed> res;\n+            res.items[0] = c;\n+            res.items[1] = c >> 64;\n+            return res;\n+        }\n         else\n         {\n             integer<Bits, Signed> res{};\n@@ -657,7 +667,7 @@ struct integer<Bits, Signed>::_impl\n     }\n \n     template <typename T>\n-    constexpr static bool operator_more(const integer<Bits, Signed> & lhs, const T & rhs) noexcept\n+    constexpr static bool operator_greater(const integer<Bits, Signed> & lhs, const T & rhs) noexcept\n     {\n         if constexpr (should_keep_size<T>())\n         {\n@@ -677,7 +687,7 @@ struct integer<Bits, Signed>::_impl\n         else\n         {\n             static_assert(IsWideInteger<T>::value);\n-            return std::common_type_t<integer<Bits, Signed>, T>::_impl::operator_more(T(lhs), rhs);\n+            return std::common_type_t<integer<Bits, Signed>, T>::_impl::operator_greater(T(lhs), rhs);\n         }\n     }\n \n@@ -764,7 +774,6 @@ struct integer<Bits, Signed>::_impl\n         }\n     }\n \n-private:\n     template <typename T>\n     constexpr static bool is_zero(const T & x)\n     {\n@@ -781,46 +790,65 @@ struct integer<Bits, Signed>::_impl\n     }\n \n     /// returns quotient as result and remainder in numerator.\n-    template <typename T>\n-    constexpr static T divide(T & numerator, T && denominator)\n+    template <size_t Bits2>\n+    constexpr static integer<Bits2, unsigned> divide(integer<Bits2, unsigned> & numerator, integer<Bits2, unsigned> denominator)\n     {\n+        static_assert(std::is_unsigned_v<Signed>);\n+\n+        if constexpr (Bits == 128 && sizeof(base_type) == 8)\n+        {\n+            using CompilerUInt128 = unsigned __int128;\n+\n+            CompilerUInt128 a = (CompilerUInt128(numerator.items[1]) << 64) + numerator.items[0];\n+            CompilerUInt128 b = (CompilerUInt128(denominator.items[1]) << 64) + denominator.items[0];\n+            CompilerUInt128 c = a / b;\n+\n+            integer<Bits, Signed> res;\n+            res.items[0] = c;\n+            res.items[1] = c >> 64;\n+\n+            CompilerUInt128 remainder = a - b * c;\n+            numerator.items[0] = remainder;\n+            numerator.items[1] = remainder >> 64;\n+\n+            return res;\n+        }\n+\n         if (is_zero(denominator))\n-            throwError(\"divide by zero\");\n+            throwError(\"Division by zero\");\n \n-        T & n = numerator;\n-        T & d = denominator;\n-        T x = 1;\n-        T quotient = 0;\n+        integer<Bits2, unsigned> x = 1;\n+        integer<Bits2, unsigned> quotient = 0;\n \n-        while (!operator_more(d, n) && operator_eq(operator_amp(shift_right(d, base_bits * item_count - 1), 1), 0))\n+        while (!operator_greater(denominator, numerator) && is_zero(operator_amp(shift_right(denominator, Bits2 - 1), 1)))\n         {\n             x = shift_left(x, 1);\n-            d = shift_left(d, 1);\n+            denominator = shift_left(denominator, 1);\n         }\n \n-        while (!operator_eq(x, 0))\n+        while (!is_zero(x))\n         {\n-            if (!operator_more(d, n))\n+            if (!operator_greater(denominator, numerator))\n             {\n-                n = operator_minus(n, d);\n+                numerator = operator_minus(numerator, denominator);\n                 quotient = operator_pipe(quotient, x);\n             }\n \n             x = shift_right(x, 1);\n-            d = shift_right(d, 1);\n+            denominator = shift_right(denominator, 1);\n         }\n \n         return quotient;\n     }\n \n-public:\n     template <typename T>\n     constexpr static auto operator_slash(const integer<Bits, Signed> & lhs, const T & rhs)\n     {\n         if constexpr (should_keep_size<T>())\n         {\n-            integer<Bits, Signed> numerator = make_positive(lhs);\n-            integer<Bits, Signed> quotient = divide(numerator, make_positive(integer<Bits, Signed>(rhs)));\n+            integer<Bits, unsigned> numerator = make_positive(lhs);\n+            integer<Bits, unsigned> denominator = make_positive(integer<Bits, Signed>(rhs));\n+            integer<Bits, unsigned> quotient = integer<Bits, unsigned>::_impl::divide(numerator, std::move(denominator));\n \n             if (std::is_same_v<Signed, signed> && is_negative(rhs) != is_negative(lhs))\n                 quotient = operator_unary_minus(quotient);\n@@ -838,8 +866,9 @@ struct integer<Bits, Signed>::_impl\n     {\n         if constexpr (should_keep_size<T>())\n         {\n-            integer<Bits, Signed> remainder = make_positive(lhs);\n-            divide(remainder, make_positive(integer<Bits, Signed>(rhs)));\n+            integer<Bits, unsigned> remainder = make_positive(lhs);\n+            integer<Bits, unsigned> denominator = make_positive(integer<Bits, Signed>(rhs));\n+            integer<Bits, unsigned>::_impl::divide(remainder, std::move(denominator));\n \n             if (std::is_same_v<Signed, signed> && is_negative(lhs))\n                 remainder = operator_unary_minus(remainder);\n@@ -905,7 +934,7 @@ struct integer<Bits, Signed>::_impl\n                     ++c;\n                 }\n                 else\n-                    throwError(\"invalid char from\");\n+                    throwError(\"Invalid char from\");\n             }\n         }\n         else\n@@ -913,7 +942,7 @@ struct integer<Bits, Signed>::_impl\n             while (*c)\n             {\n                 if (*c < '0' || *c > '9')\n-                    throwError(\"invalid char from\");\n+                    throwError(\"Invalid char from\");\n \n                 res = multiply(res, 10U);\n                 res = plus(res, *c - '0');\n@@ -930,11 +959,6 @@ struct integer<Bits, Signed>::_impl\n \n // Members\n \n-template <size_t Bits, typename Signed>\n-constexpr integer<Bits, Signed>::integer() noexcept\n-    : items{}\n-{}\n-\n template <size_t Bits, typename Signed>\n template <typename T>\n constexpr integer<Bits, Signed>::integer(T rhs) noexcept\n@@ -943,7 +967,7 @@ constexpr integer<Bits, Signed>::integer(T rhs) noexcept\n     if constexpr (IsWideInteger<T>::value)\n         _impl::wide_integer_from_wide_integer(*this, rhs);\n     else\n-        _impl::wide_integer_from_bultin(*this, rhs);\n+        _impl::wide_integer_from_builtin(*this, rhs);\n }\n \n template <size_t Bits, typename Signed>\n@@ -956,10 +980,19 @@ constexpr integer<Bits, Signed>::integer(std::initializer_list<T> il) noexcept\n         if constexpr (IsWideInteger<T>::value)\n             _impl::wide_integer_from_wide_integer(*this, *il.begin());\n         else\n-            _impl::wide_integer_from_bultin(*this, *il.begin());\n+            _impl::wide_integer_from_builtin(*this, *il.begin());\n+    }\n+    else if (il.size() == 0)\n+    {\n+        _impl::wide_integer_from_builtin(*this, 0);\n     }\n     else\n-        _impl::wide_integer_from_bultin(*this, 0);\n+    {\n+        auto it = il.begin();\n+        for (size_t i = 0; i < _impl::item_count; ++i)\n+            if (it < il.end())\n+                items[i] = *it;\n+    }\n }\n \n template <size_t Bits, typename Signed>\n@@ -974,7 +1007,7 @@ template <size_t Bits, typename Signed>\n template <typename T>\n constexpr integer<Bits, Signed> & integer<Bits, Signed>::operator=(T rhs) noexcept\n {\n-    _impl::wide_integer_from_bultin(*this, rhs);\n+    _impl::wide_integer_from_builtin(*this, rhs);\n     return *this;\n }\n \n@@ -1057,7 +1090,7 @@ constexpr integer<Bits, Signed> & integer<Bits, Signed>::operator>>=(int n) noex\n {\n     if (static_cast<size_t>(n) >= Bits)\n     {\n-        if (is_negative(*this))\n+        if (_impl::is_negative(*this))\n             *this = -1;\n         else\n             *this = 0;\n@@ -1107,16 +1140,17 @@ template <size_t Bits, typename Signed>\n template <class T, class>\n constexpr integer<Bits, Signed>::operator T() const noexcept\n {\n-    if constexpr (std::is_same_v<T, __int128>)\n-    {\n-        static_assert(Bits >= 128);\n-        return (__int128(items[1]) << 64) | items[0];\n-    }\n-    else\n-    {\n-        static_assert(std::numeric_limits<T>::is_integer);\n-        return items[0];\n-    }\n+    static_assert(std::numeric_limits<T>::is_integer);\n+\n+    /// NOTE: memcpy will suffice, but unfortunately, this function is constexpr.\n+\n+    using UnsignedT = std::make_unsigned_t<T>;\n+\n+    UnsignedT res{};\n+    for (unsigned i = 0; i < _impl::item_count && i < (sizeof(T) + sizeof(base_type) - 1) / sizeof(base_type); ++i)\n+        res += UnsignedT(items[i]) << (sizeof(base_type) * 8 * i);\n+\n+    return res;\n }\n \n template <size_t Bits, typename Signed>\n@@ -1280,7 +1314,7 @@ template <size_t Bits, typename Signed>\n constexpr integer<Bits, Signed> operator<<(const integer<Bits, Signed> & lhs, int n) noexcept\n {\n     if (static_cast<size_t>(n) >= Bits)\n-        return 0;\n+        return integer<Bits, Signed>(0);\n     if (n <= 0)\n         return lhs;\n     return integer<Bits, Signed>::_impl::shift_left(lhs, n);\n@@ -1289,7 +1323,7 @@ template <size_t Bits, typename Signed>\n constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, int n) noexcept\n {\n     if (static_cast<size_t>(n) >= Bits)\n-        return 0;\n+        return integer<Bits, Signed>(0);\n     if (n <= 0)\n         return lhs;\n     return integer<Bits, Signed>::_impl::shift_right(lhs, n);\n@@ -1309,7 +1343,7 @@ constexpr bool operator<(const Arithmetic & lhs, const Arithmetic2 & rhs)\n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator>(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs)\n {\n-    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs);\n+    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_greater(lhs, rhs);\n }\n template <typename Arithmetic, typename Arithmetic2, class>\n constexpr bool operator>(const Arithmetic & lhs, const Arithmetic2 & rhs)\n@@ -1332,7 +1366,7 @@ constexpr bool operator<=(const Arithmetic & lhs, const Arithmetic2 & rhs)\n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n constexpr bool operator>=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs)\n {\n-    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs)\n+    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_greater(lhs, rhs)\n         || std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);\n }\n template <typename Arithmetic, typename Arithmetic2, class>\ndiff --git a/base/common/wide_integer_to_string.h b/base/common/wide_integer_to_string.h\nindex 9908ef4be7a8..8b794fe9bcb2 100644\n--- a/base/common/wide_integer_to_string.h\n+++ b/base/common/wide_integer_to_string.h\n@@ -1,9 +1,12 @@\n #pragma once\n \n #include <string>\n+#include <ostream>\n+#include <fmt/format.h>\n \n #include \"wide_integer.h\"\n \n+\n namespace wide\n {\n \n@@ -33,3 +36,34 @@ inline std::string to_string(const integer<Bits, Signed> & n)\n }\n \n }\n+\n+\n+template <size_t Bits, typename Signed>\n+std::ostream & operator<<(std::ostream & out, const wide::integer<Bits, Signed> & value)\n+{\n+    return out << to_string(value);\n+}\n+\n+\n+/// See https://fmt.dev/latest/api.html#formatting-user-defined-types\n+template <size_t Bits, typename Signed>\n+struct fmt::formatter<wide::integer<Bits, Signed>>\n+{\n+    constexpr auto parse(format_parse_context & ctx)\n+    {\n+        auto it = ctx.begin();\n+        auto end = ctx.end();\n+\n+        /// Only support {}.\n+        if (it != end && *it != '}')\n+            throw format_error(\"invalid format\");\n+\n+        return it;\n+    }\n+\n+    template <typename FormatContext>\n+    auto format(const wide::integer<Bits, Signed> & value, FormatContext & ctx)\n+    {\n+        return format_to(ctx.out(), \"{}\", to_string(value));\n+    }\n+};\ndiff --git a/programs/client/QueryFuzzer.h b/programs/client/QueryFuzzer.h\nindex 9ef66db18737..7c79e683eb4e 100644\n--- a/programs/client/QueryFuzzer.h\n+++ b/programs/client/QueryFuzzer.h\n@@ -4,11 +4,14 @@\n #include <unordered_map>\n #include <vector>\n \n+#include <pcg-random/pcg_random.hpp>\n+\n #include <Common/randomSeed.h>\n #include <Common/Stopwatch.h>\n #include <Core/Field.h>\n #include <Parsers/IAST.h>\n \n+\n namespace DB\n {\n \ndiff --git a/programs/git-import/git-import.cpp b/programs/git-import/git-import.cpp\nindex b07435dcf781..7977cfba79d3 100644\n--- a/programs/git-import/git-import.cpp\n+++ b/programs/git-import/git-import.cpp\n@@ -774,7 +774,7 @@ UInt128 diffHash(const CommitDiff & file_changes)\n     }\n \n     UInt128 hash_of_diff;\n-    hasher.get128(hash_of_diff.low, hash_of_diff.high);\n+    hasher.get128(hash_of_diff.items[0], hash_of_diff.items[1]);\n \n     return hash_of_diff;\n }\ndiff --git a/programs/obfuscator/Obfuscator.cpp b/programs/obfuscator/Obfuscator.cpp\nindex c92eb5c66474..fb6817fbf806 100644\n--- a/programs/obfuscator/Obfuscator.cpp\n+++ b/programs/obfuscator/Obfuscator.cpp\n@@ -365,16 +365,20 @@ static void transformFixedString(const UInt8 * src, UInt8 * dst, size_t size, UI\n     }\n }\n \n-static void transformUUID(const UInt128 & src, UInt128 & dst, UInt64 seed)\n+static void transformUUID(const UUID & src_uuid, UUID & dst_uuid, UInt64 seed)\n {\n+    const UInt128 & src = src_uuid.toUnderType();\n+    UInt128 & dst = dst_uuid.toUnderType();\n+\n     SipHash hash;\n     hash.update(seed);\n-    hash.update(reinterpret_cast<const char *>(&src), sizeof(UInt128));\n+    hash.update(reinterpret_cast<const char *>(&src), sizeof(UUID));\n \n     /// Saving version and variant from an old UUID\n     hash.get128(reinterpret_cast<char *>(&dst));\n-    dst.high = (dst.high & 0x1fffffffffffffffull) | (src.high & 0xe000000000000000ull);\n-    dst.low = (dst.low & 0xffffffffffff0fffull) | (src.low & 0x000000000000f000ull);\n+\n+    dst.items[1] = (dst.items[1] & 0x1fffffffffffffffull) | (src.items[1] & 0xe000000000000000ull);\n+    dst.items[0] = (dst.items[0] & 0xffffffffffff0fffull) | (src.items[0] & 0x000000000000f000ull);\n }\n \n class FixedStringModel : public IModel\n@@ -426,10 +430,10 @@ class UUIDModel : public IModel\n \n     ColumnPtr generate(const IColumn & column) override\n     {\n-        const ColumnUInt128 & src_column = assert_cast<const ColumnUInt128 &>(column);\n+        const ColumnUUID & src_column = assert_cast<const ColumnUUID &>(column);\n         const auto & src_data = src_column.getData();\n \n-        auto res_column = ColumnUInt128::create();\n+        auto res_column = ColumnUUID::create();\n         auto & res_data = res_column->getData();\n \n         res_data.resize(src_data.size());\ndiff --git a/programs/odbc-bridge/ODBCBlockOutputStream.cpp b/programs/odbc-bridge/ODBCBlockOutputStream.cpp\nindex bdbe8add37eb..dc965b3b2a79 100644\n--- a/programs/odbc-bridge/ODBCBlockOutputStream.cpp\n+++ b/programs/odbc-bridge/ODBCBlockOutputStream.cpp\n@@ -1,5 +1,6 @@\n #include \"ODBCBlockOutputStream.h\"\n \n+#include <Common/hex.h>\n #include <common/logger_useful.h>\n #include <Core/Field.h>\n #include <common/LocalDate.h>\n@@ -37,7 +38,6 @@ namespace\n         query.IAST::format(settings);\n         return buf.str();\n     }\n-\n }\n \n ODBCBlockOutputStream::ODBCBlockOutputStream(nanodbc::ConnectionHolderPtr connection_,\ndiff --git a/src/Access/IAccessStorage.h b/src/Access/IAccessStorage.h\nindex 2cdd8eabf731..cc9146641499 100644\n--- a/src/Access/IAccessStorage.h\n+++ b/src/Access/IAccessStorage.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <Access/IAccessEntity.h>\n-#include <common/types.h>\n+#include <Core/Types.h>\n #include <Core/UUID.h>\n #include <ext/scope_guard.h>\n #include <functional>\ndiff --git a/src/Access/RolesOrUsersSet.h b/src/Access/RolesOrUsersSet.h\nindex 0d8983c2ec39..871bb0c0758e 100644\n--- a/src/Access/RolesOrUsersSet.h\n+++ b/src/Access/RolesOrUsersSet.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Core/UUID.h>\n+#include <Core/Types.h>\n #include <boost/container/flat_set.hpp>\n #include <memory>\n #include <optional>\ndiff --git a/src/Access/RowPolicy.h b/src/Access/RowPolicy.h\nindex c9b4d69152de..723db545dbeb 100644\n--- a/src/Access/RowPolicy.h\n+++ b/src/Access/RowPolicy.h\n@@ -2,6 +2,7 @@\n \n #include <Access/IAccessEntity.h>\n #include <Access/RolesOrUsersSet.h>\n+#include <Core/Types.h>\n #include <array>\n \n \ndiff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h\nindex 8a6491d9b61a..f2ea51ac28dd 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvg.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvg.h\n@@ -7,7 +7,7 @@\n #include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <AggregateFunctions/IAggregateFunction.h>\n-#include \"Core/DecimalFunctions.h\"\n+#include <Core/DecimalFunctions.h>\n \n \n namespace DB\ndiff --git a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\nindex f8b452fc4445..8b932918aa5a 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\n@@ -5,18 +5,18 @@\n \n namespace DB\n {\n-template <class T>\n+template <typename T>\n using AvgWeightedFieldType = std::conditional_t<IsDecimalNumber<T>,\n     std::conditional_t<std::is_same_v<T, Decimal256>, Decimal256, Decimal128>,\n     std::conditional_t<DecimalOrExtendedInt<T>,\n         Float64, // no way to do UInt128 * UInt128, better cast to Float64\n         NearestFieldType<T>>>;\n \n-template <class T, class U>\n+template <typename T, typename U>\n using MaxFieldType = std::conditional_t<(sizeof(AvgWeightedFieldType<T>) > sizeof(AvgWeightedFieldType<U>)),\n     AvgWeightedFieldType<T>, AvgWeightedFieldType<U>>;\n \n-template <class Value, class Weight>\n+template <typename Value, typename Weight>\n class AggregateFunctionAvgWeighted final :\n     public AggregateFunctionAvgBase<\n         MaxFieldType<Value, Weight>, AvgWeightedFieldType<Weight>, AggregateFunctionAvgWeighted<Value, Weight>>\ndiff --git a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\nindex 15b355f51a6b..bee58a4a9322 100644\n--- a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\n+++ b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\n@@ -2,7 +2,6 @@\n \n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnsNumber.h>\n-#include <Common/FieldVisitors.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n #include <AggregateFunctions/Helpers.h>\ndiff --git a/src/AggregateFunctions/AggregateFunctionDistinct.h b/src/AggregateFunctions/AggregateFunctionDistinct.h\nindex b587bbebf6e2..b551f8a4ec50 100644\n--- a/src/AggregateFunctions/AggregateFunctionDistinct.h\n+++ b/src/AggregateFunctions/AggregateFunctionDistinct.h\n@@ -10,7 +10,6 @@\n #include <Common/HashTable/HashMap.h>\n #include <Common/SipHash.h>\n \n-#include <Common/FieldVisitors.h>\n \n namespace DB\n {\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArray.h b/src/AggregateFunctions/AggregateFunctionGroupArray.h\nindex 921274f7d59f..e59f19e3baed 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArray.h\n@@ -296,12 +296,7 @@ class GroupArrayNumericImpl final\n         if (size)\n         {\n             typename ColumnVector<T>::Container & data_to = assert_cast<ColumnVector<T> &>(arr_to.getData()).getData();\n-            if constexpr (is_big_int_v<T>)\n-                // is data_to empty? we should probably use std::vector::insert then\n-                for (auto it = this->data(place).value.begin(); it != this->data(place).value.end(); it++)\n-                    data_to.push_back(*it);\n-            else\n-                data_to.insert(this->data(place).value.begin(), this->data(place).value.end());\n+            data_to.insert(this->data(place).value.begin(), this->data(place).value.end());\n         }\n     }\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\nindex e2139ba882fc..b6e9fda95591 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n@@ -21,6 +21,7 @@ namespace ErrorCodes\n namespace\n {\n \n+/// TODO Proper support for Decimal256.\n template <typename T, typename LimitNumberOfElements>\n struct MovingSum\n {\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\nindex 3bab831d3163..8b7109ae3ef8 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\n@@ -38,7 +38,7 @@ struct MovingData\n     using Array = PODArray<T, 32, Allocator>;\n \n     Array value;    /// Prefix sums.\n-    T sum = 0;\n+    T sum{};\n \n     void NO_SANITIZE_UNDEFINED add(T val, Arena * arena)\n     {\n@@ -69,9 +69,9 @@ struct MovingAvgData : public MovingData<T>\n     T NO_SANITIZE_UNDEFINED get(size_t idx, UInt64 window_size) const\n     {\n         if (idx < window_size)\n-            return this->value[idx] / window_size;\n+            return this->value[idx] / T(window_size);\n         else\n-            return (this->value[idx] - this->value[idx - window_size]) / window_size;\n+            return (this->value[idx] - this->value[idx - window_size]) / T(window_size);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionMannWhitney.h b/src/AggregateFunctions/AggregateFunctionMannWhitney.h\nindex 7efdebf16391..7573de65cc0c 100644\n--- a/src/AggregateFunctions/AggregateFunctionMannWhitney.h\n+++ b/src/AggregateFunctions/AggregateFunctionMannWhitney.h\n@@ -6,7 +6,6 @@\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnTuple.h>\n #include <Common/assert_cast.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/PODArray_fwd.h>\n #include <common/types.h>\n #include <DataTypes/DataTypesDecimal.h>\n@@ -21,7 +20,7 @@\n \n #include <Common/ArenaAllocator.h>\n \n-#include <iostream>\n+\n namespace DB\n {\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionQuantile.cpp b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\nindex 1dcdb2883394..e8d86a03ff17 100644\n--- a/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n@@ -100,13 +100,14 @@ AggregateFunctionPtr createAggregateFunctionQuantile(const std::string & name, c\n         if (which.idx == TypeIndex::Decimal32) return std::make_shared<Function<Decimal32, false>>(argument_types, params);\n         if (which.idx == TypeIndex::Decimal64) return std::make_shared<Function<Decimal64, false>>(argument_types, params);\n         if (which.idx == TypeIndex::Decimal128) return std::make_shared<Function<Decimal128, false>>(argument_types, params);\n+        if (which.idx == TypeIndex::Decimal256) return std::make_shared<Function<Decimal256, false>>(argument_types, params);\n         if (which.idx == TypeIndex::DateTime64) return std::make_shared<Function<DateTime64, false>>(argument_types, params);\n-        //if (which.idx == TypeIndex::Decimal256) return std::make_shared<Function<Decimal256, false>>(argument_types, params);\n     }\n \n     if constexpr (supportBigInt<Function>())\n     {\n         if (which.idx == TypeIndex::Int128) return std::make_shared<Function<Int128, true>>(argument_types, params);\n+        if (which.idx == TypeIndex::UInt128) return std::make_shared<Function<Int128, true>>(argument_types, params);\n         if (which.idx == TypeIndex::Int256) return std::make_shared<Function<Int256, true>>(argument_types, params);\n         if (which.idx == TypeIndex::UInt256) return std::make_shared<Function<UInt256, true>>(argument_types, params);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionStatistics.cpp b/src/AggregateFunctions/AggregateFunctionStatistics.cpp\nindex 9e3aa0962db5..d8c8c2ab2100 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatistics.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionStatistics.cpp\n@@ -36,7 +36,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsBinary(const std::string &\n     assertNoParameters(name, parameters);\n     assertBinary(name, argument_types);\n \n-    AggregateFunctionPtr res(createWithTwoNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));\n+    AggregateFunctionPtr res(createWithTwoBasicNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));\n     if (!res)\n         throw Exception(\"Illegal types \" + argument_types[0]->getName() + \" and \" + argument_types[1]->getName()\n             + \" of arguments for aggregate function \" + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\ndiff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp\nindex c7c2f9025eda..5dde84c1b647 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp\n@@ -41,7 +41,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsBinary(const std::string &\n     assertNoParameters(name, parameters);\n     assertBinary(name, argument_types);\n \n-    AggregateFunctionPtr res(createWithTwoNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));\n+    AggregateFunctionPtr res(createWithTwoBasicNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));\n     if (!res)\n         throw Exception(\"Illegal types \" + argument_types[0]->getName() + \" and \" + argument_types[1]->getName()\n             + \" of arguments for aggregate function \" + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\ndiff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\nindex a5d6bbb7dc86..eaf119a62649 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n@@ -131,11 +131,10 @@ class AggregateFunctionVarianceSimple final\n                 static_cast<ResultType>(static_cast<const ColVecT2 &>(*columns[1]).getData()[row_num]));\n         else\n         {\n-            if constexpr (std::is_same_v<T1, Decimal256>)\n+            if constexpr (IsDecimalNumber<T1>)\n             {\n                 this->data(place).add(static_cast<ResultType>(\n-                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value\n-                ));\n+                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value));\n             }\n             else\n                 this->data(place).add(\ndiff --git a/src/AggregateFunctions/AggregateFunctionTopK.cpp b/src/AggregateFunctions/AggregateFunctionTopK.cpp\nindex e32da02f4424..79a39817ea5a 100644\n--- a/src/AggregateFunctions/AggregateFunctionTopK.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionTopK.cpp\n@@ -2,9 +2,10 @@\n #include <AggregateFunctions/AggregateFunctionTopK.h>\n #include <AggregateFunctions/Helpers.h>\n #include <AggregateFunctions/FactoryHelpers.h>\n+#include <Common/FieldVisitors.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n-#include \"registerAggregateFunctions.h\"\n+\n \n #define TOP_K_MAX_SIZE 0xFFFFFF\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionTopK.h b/src/AggregateFunctions/AggregateFunctionTopK.h\nindex dbc471687ead..5e5e7d07cecb 100644\n--- a/src/AggregateFunctions/AggregateFunctionTopK.h\n+++ b/src/AggregateFunctions/AggregateFunctionTopK.h\n@@ -10,7 +10,6 @@\n #include <Columns/ColumnArray.h>\n \n #include <Common/SpaceSaving.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/assert_cast.h>\n \n #include <AggregateFunctions/IAggregateFunction.h>\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniq.h b/src/AggregateFunctions/AggregateFunctionUniq.h\nindex 253af6e28957..dfe9acf267ed 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniq.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniq.h\n@@ -69,7 +69,7 @@ struct AggregateFunctionUniqHLL12Data<String>\n };\n \n template <>\n-struct AggregateFunctionUniqHLL12Data<UInt128>\n+struct AggregateFunctionUniqHLL12Data<UUID>\n {\n     using Set = HyperLogLogWithSmallSetOptimization<UInt64, 16, 12>;\n     Set set;\n@@ -133,16 +133,14 @@ template <typename T> struct AggregateFunctionUniqTraits\n {\n     static UInt64 hash(T x)\n     {\n-        if constexpr (std::is_same_v<T, UInt128>)\n-        {\n-            return sipHash64(x);\n-        }\n-        else if constexpr (std::is_same_v<T, Float32> || std::is_same_v<T, Float64>)\n+        if constexpr (std::is_same_v<T, Float32> || std::is_same_v<T, Float64>)\n         {\n             return ext::bit_cast<UInt64>(x);\n         }\n         else if constexpr (sizeof(T) <= sizeof(UInt64))\n+        {\n             return x;\n+        }\n         else\n             return DefaultHash64<T>(x);\n     }\n@@ -184,7 +182,7 @@ struct OneAdder\n                 UInt128 key;\n                 SipHash hash;\n                 hash.update(value.data, value.size);\n-                hash.get128(key.low, key.high);\n+                hash.get128(key);\n \n                 data.set.insert(key);\n             }\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp\nindex c0064044f958..84a9267ffe0f 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp\n@@ -3,11 +3,13 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/Helpers.h>\n \n+#include <Common/FieldVisitors.h>\n+\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n \n #include <functional>\n-#include \"registerAggregateFunctions.h\"\n+\n \n namespace DB\n {\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.h b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\nindex 31bd8021dcfb..f425a343caa5 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n@@ -1,7 +1,6 @@\n #pragma once\n \n #include <Common/CombinedCardinalityEstimator.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/SipHash.h>\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp\nindex 9befc515de6e..8195bd8964c5 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp\n@@ -1,11 +1,11 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/Helpers.h>\n #include <AggregateFunctions/AggregateFunctionUniqUpTo.h>\n+#include <Common/FieldVisitors.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeFixedString.h>\n-#include \"registerAggregateFunctions.h\"\n \n \n namespace DB\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\nindex 853e1cb6447d..5dd62c96a9ed 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n-#include <Common/FieldVisitors.h>\n+#include <common/unaligned.h>\n+\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n \n@@ -35,7 +36,7 @@ namespace DB\n   */\n \n template <typename T>\n-struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n+struct AggregateFunctionUniqUpToData\n {\n /** If count == threshold + 1 - this means that it is \"overflowed\" (values greater than threshold).\n   * In this case (for example, after calling the merge function), the `data` array does not necessarily contain the initialized values\n@@ -43,7 +44,17 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n   *   then set count to `threshold + 1`, and values from another state are not copied.\n   */\n     UInt8 count = 0;\n-    T data[0];\n+    char data_ptr[0];\n+\n+    T load(size_t i) const\n+    {\n+        return unalignedLoad<T>(data_ptr + i * sizeof(T));\n+    }\n+\n+    void store(size_t i, const T & x)\n+    {\n+        unalignedStore<T>(data_ptr + i * sizeof(T), x);\n+    }\n \n     size_t size() const\n     {\n@@ -60,12 +71,12 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n \n         /// Linear search for the matching element.\n         for (size_t i = 0; i < count; ++i)\n-            if (data[i] == x)\n+            if (load(i) == x)\n                 return;\n \n         /// Did not find the matching element. If there is room for one more element, insert it.\n         if (count < threshold)\n-            data[count] = x;\n+            store(count, x);\n \n         /// After increasing count, the state may be overflowed.\n         ++count;\n@@ -84,7 +95,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n         }\n \n         for (size_t i = 0; i < rhs.count; ++i)\n-            insert(rhs.data[i], threshold);\n+            insert(rhs.load(i), threshold);\n     }\n \n     void write(WriteBuffer & wb, UInt8 threshold) const\n@@ -93,7 +104,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n \n         /// Write values only if the state is not overflowed. Otherwise, they are not needed, and only the fact that the state is overflowed is important.\n         if (count <= threshold)\n-            wb.write(reinterpret_cast<const char *>(data), count * sizeof(data[0]));\n+            wb.write(data_ptr, count * sizeof(T));\n     }\n \n     void read(ReadBuffer & rb, UInt8 threshold)\n@@ -101,7 +112,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData\n         readBinary(count, rb);\n \n         if (count <= threshold)\n-            rb.read(reinterpret_cast<char *>(data), count * sizeof(data[0]));\n+            rb.read(data_ptr, count * sizeof(T));\n     }\n \n     /// ALWAYS_INLINE is required to have better code layout for uniqUpTo function\ndiff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h\nindex bf51b5f6e2eb..d1f1830eb274 100644\n--- a/src/AggregateFunctions/Helpers.h\n+++ b/src/AggregateFunctions/Helpers.h\n@@ -15,12 +15,12 @@\n     M(Float32) \\\n     M(Float64)\n \n-// No UInt128 here because of the name conflict\n #define FOR_NUMERIC_TYPES(M) \\\n     M(UInt8) \\\n     M(UInt16) \\\n     M(UInt32) \\\n     M(UInt64) \\\n+    M(UInt128) \\\n     M(UInt256) \\\n     M(Int8) \\\n     M(Int16) \\\n@@ -109,6 +109,8 @@ static IAggregateFunction * createWithUnsignedIntegerType(const IDataType & argu\n     if (which.idx == TypeIndex::UInt16) return new AggregateFunctionTemplate<UInt16, Data<UInt16>>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::UInt32) return new AggregateFunctionTemplate<UInt32, Data<UInt32>>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::UInt64) return new AggregateFunctionTemplate<UInt64, Data<UInt64>>(std::forward<TArgs>(args)...);\n+    if (which.idx == TypeIndex::UInt128) return new AggregateFunctionTemplate<UInt128, Data<UInt128>>(std::forward<TArgs>(args)...);\n+    if (which.idx == TypeIndex::UInt256) return new AggregateFunctionTemplate<UInt256, Data<UInt256>>(std::forward<TArgs>(args)...);\n     return nullptr;\n }\n \n@@ -119,11 +121,11 @@ static IAggregateFunction * createWithNumericBasedType(const IDataType & argumen\n     if (f)\n         return f;\n \n-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128\n+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32\n     WhichDataType which(argument_type);\n     if (which.idx == TypeIndex::Date) return new AggregateFunctionTemplate<UInt16>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::DateTime) return new AggregateFunctionTemplate<UInt32>(std::forward<TArgs>(args)...);\n-    if (which.idx == TypeIndex::UUID) return new AggregateFunctionTemplate<UInt128>(std::forward<TArgs>(args)...);\n+    if (which.idx == TypeIndex::UUID) return new AggregateFunctionTemplate<UUID>(std::forward<TArgs>(args)...);\n     return nullptr;\n }\n \n@@ -184,6 +186,29 @@ static IAggregateFunction * createWithTwoNumericTypes(const IDataType & first_ty\n     return nullptr;\n }\n \n+template <typename FirstType, template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>\n+static IAggregateFunction * createWithTwoBasicNumericTypesSecond(const IDataType & second_type, TArgs && ... args)\n+{\n+    WhichDataType which(second_type);\n+#define DISPATCH(TYPE) \\\n+    if (which.idx == TypeIndex::TYPE) return new AggregateFunctionTemplate<FirstType, TYPE>(std::forward<TArgs>(args)...);\n+    FOR_BASIC_NUMERIC_TYPES(DISPATCH)\n+#undef DISPATCH\n+    return nullptr;\n+}\n+\n+template <template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>\n+static IAggregateFunction * createWithTwoBasicNumericTypes(const IDataType & first_type, const IDataType & second_type, TArgs && ... args)\n+{\n+    WhichDataType which(first_type);\n+#define DISPATCH(TYPE) \\\n+    if (which.idx == TypeIndex::TYPE) \\\n+        return createWithTwoBasicNumericTypesSecond<TYPE, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);\n+    FOR_BASIC_NUMERIC_TYPES(DISPATCH)\n+#undef DISPATCH\n+    return nullptr;\n+}\n+\n template <typename FirstType, template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>\n static IAggregateFunction * createWithTwoNumericOrDateTypesSecond(const IDataType & second_type, TArgs && ... args)\n {\n@@ -195,7 +220,7 @@ static IAggregateFunction * createWithTwoNumericOrDateTypesSecond(const IDataTyp\n     if (which.idx == TypeIndex::Enum8) return new AggregateFunctionTemplate<FirstType, Int8>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::Enum16) return new AggregateFunctionTemplate<FirstType, Int16>(std::forward<TArgs>(args)...);\n \n-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128\n+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32\n     if (which.idx == TypeIndex::Date) return new AggregateFunctionTemplate<FirstType, UInt16>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::DateTime) return new AggregateFunctionTemplate<FirstType, UInt32>(std::forward<TArgs>(args)...);\n \n@@ -216,7 +241,7 @@ static IAggregateFunction * createWithTwoNumericOrDateTypes(const IDataType & fi\n     if (which.idx == TypeIndex::Enum16)\n         return createWithTwoNumericOrDateTypesSecond<Int16, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);\n \n-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128\n+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32\n     if (which.idx == TypeIndex::Date)\n         return createWithTwoNumericOrDateTypesSecond<UInt16, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::DateTime)\ndiff --git a/src/AggregateFunctions/QuantileReservoirSampler.h b/src/AggregateFunctions/QuantileReservoirSampler.h\nindex 6b4af04a5fbd..e0217731a123 100644\n--- a/src/AggregateFunctions/QuantileReservoirSampler.h\n+++ b/src/AggregateFunctions/QuantileReservoirSampler.h\n@@ -54,7 +54,7 @@ struct QuantileReservoirSampler\n     /// Get the value of the `level` quantile. The level must be between 0 and 1.\n     Value get(Float64 level)\n     {\n-        return data.quantileInterpolated(level);\n+        return Value(data.quantileInterpolated(level));\n     }\n \n     /// Get the `size` values of `levels` quantiles. Write `size` results starting with `result` address.\n@@ -62,7 +62,7 @@ struct QuantileReservoirSampler\n     void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)\n     {\n         for (size_t i = 0; i < size; ++i)\n-            result[indices[i]] = data.quantileInterpolated(levels[indices[i]]);\n+            result[indices[i]] = Value(data.quantileInterpolated(levels[indices[i]]));\n     }\n \n     /// The same, but in the case of an empty state, NaN is returned.\ndiff --git a/src/AggregateFunctions/ReservoirSampler.h b/src/AggregateFunctions/ReservoirSampler.h\nindex a321ef086481..e4cc77dd3610 100644\n--- a/src/AggregateFunctions/ReservoirSampler.h\n+++ b/src/AggregateFunctions/ReservoirSampler.h\n@@ -131,12 +131,20 @@ class ReservoirSampler\n         size_t left_index = static_cast<size_t>(index);\n         size_t right_index = left_index + 1;\n         if (right_index == samples.size())\n-            return static_cast<double>(samples[left_index]);\n+        {\n+            if constexpr (DB::IsDecimalNumber<T>)\n+                return static_cast<double>(samples[left_index].value);\n+            else\n+                return static_cast<double>(samples[left_index]);\n+        }\n \n         double left_coef = right_index - index;\n         double right_coef = index - left_index;\n \n-        return static_cast<double>(samples[left_index]) * left_coef + static_cast<double>(samples[right_index]) * right_coef;\n+        if constexpr (DB::IsDecimalNumber<T>)\n+            return static_cast<double>(samples[left_index].value) * left_coef + static_cast<double>(samples[right_index].value) * right_coef;\n+        else\n+            return static_cast<double>(samples[left_index]) * left_coef + static_cast<double>(samples[right_index]) * right_coef;\n     }\n \n     void merge(const ReservoirSampler<T, OnEmpty> & b)\ndiff --git a/src/AggregateFunctions/UniqVariadicHash.h b/src/AggregateFunctions/UniqVariadicHash.h\nindex d6e584a2e1e1..7ca80a9db34d 100644\n--- a/src/AggregateFunctions/UniqVariadicHash.h\n+++ b/src/AggregateFunctions/UniqVariadicHash.h\n@@ -3,7 +3,6 @@\n #include <city.h>\n #include <Core/Defines.h>\n #include <Common/SipHash.h>\n-#include <Common/UInt128.h>\n #include <Common/assert_cast.h>\n #include <Columns/ColumnTuple.h>\n \n@@ -107,7 +106,7 @@ struct UniqVariadicHash<true, false>\n         }\n \n         UInt128 key;\n-        hash.get128(key.low, key.high);\n+        hash.get128(key);\n         return key;\n     }\n };\n@@ -131,7 +130,7 @@ struct UniqVariadicHash<true, true>\n         }\n \n         UInt128 key;\n-        hash.get128(key.low, key.high);\n+        hash.get128(key);\n         return key;\n     }\n };\ndiff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex a4fa15c2d953..8621a793f495 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -85,8 +85,8 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T\n     {}\n \n public:\n-    const char * getFamilyName() const override { return TypeName<T>::get(); }\n-    TypeIndex getDataType() const override { return TypeId<T>::value; }\n+    const char * getFamilyName() const override { return TypeName<T>; }\n+    TypeIndex getDataType() const override { return TypeId<T>; }\n \n     bool isNumeric() const override { return false; }\n     bool canBeInsideNullable() const override { return true; }\ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex 820833391077..51b45be53fdf 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -665,7 +665,7 @@ UInt128 ColumnUnique<ColumnType>::IncrementalHash::getHash(const ColumnType & co\n             column.updateHashWithValue(i, sip_hash);\n \n         std::lock_guard lock(mutex);\n-        sip_hash.get128(hash.low, hash.high);\n+        sip_hash.get128(hash);\n         cur_hash = hash;\n         num_added_rows.store(column_size);\n     }\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex a64906ba2578..4e2a8c16586d 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -33,6 +33,7 @@ namespace ErrorCodes\n     extern const int PARAMETER_OUT_OF_BOUND;\n     extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;\n     extern const int LOGICAL_ERROR;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n template <typename T>\n@@ -154,7 +155,7 @@ void ColumnVector<T>::getPermutation(bool reverse, size_t limit, int nan_directi\n     else\n     {\n         /// A case for radix sort\n-        if constexpr (is_arithmetic_v<T> && !std::is_same_v<T, UInt128>)\n+        if constexpr (is_arithmetic_v<T> && !is_big_int_v<T>)\n         {\n             /// Thresholds on size. Lower threshold is arbitrary. Upper threshold is chosen by the type for histogram counters.\n             if (s >= 256 && s <= std::numeric_limits<UInt32>::max())\n@@ -292,28 +293,37 @@ MutableColumnPtr ColumnVector<T>::cloneResized(size_t size) const\n         memcpy(new_col.data.data(), data.data(), count * sizeof(data[0]));\n \n         if (size > count)\n-            memset(static_cast<void *>(&new_col.data[count]), static_cast<int>(ValueType()), (size - count) * sizeof(ValueType));\n+            memset(static_cast<void *>(&new_col.data[count]), 0, (size - count) * sizeof(ValueType));\n     }\n \n     return res;\n }\n \n template <typename T>\n-UInt64 ColumnVector<T>::get64(size_t n) const\n+UInt64 ColumnVector<T>::get64(size_t n [[maybe_unused]]) const\n {\n-    return ext::bit_cast<UInt64>(data[n]);\n+    if constexpr (is_arithmetic_v<T>)\n+        return ext::bit_cast<UInt64>(data[n]);\n+    else\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as UInt64\", TypeName<T>);\n }\n \n template <typename T>\n-inline Float64 ColumnVector<T>::getFloat64(size_t n) const\n+inline Float64 ColumnVector<T>::getFloat64(size_t n [[maybe_unused]]) const\n {\n-    return static_cast<Float64>(data[n]);\n+    if constexpr (is_arithmetic_v<T>)\n+        return static_cast<Float64>(data[n]);\n+    else\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as Float64\", TypeName<T>);\n }\n \n template <typename T>\n-Float32 ColumnVector<T>::getFloat32(size_t n) const\n+Float32 ColumnVector<T>::getFloat32(size_t n [[maybe_unused]]) const\n {\n-    return static_cast<Float32>(data[n]);\n+    if constexpr (is_arithmetic_v<T>)\n+        return static_cast<Float32>(data[n]);\n+    else\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as Float32\", TypeName<T>);\n }\n \n template <typename T>\n@@ -482,8 +492,6 @@ void ColumnVector<T>::gather(ColumnGathererStream & gatherer)\n template <typename T>\n void ColumnVector<T>::getExtremes(Field & min, Field & max) const\n {\n-    using FastRefT = std::conditional_t<is_big_int_v<T>, const T &, const T>;\n-\n     size_t size = data.size();\n \n     if (size == 0)\n@@ -504,7 +512,7 @@ void ColumnVector<T>::getExtremes(Field & min, Field & max) const\n     T cur_min = NaNOrZero<T>();\n     T cur_max = NaNOrZero<T>();\n \n-    for (FastRefT x : data)\n+    for (const T & x : data)\n     {\n         if (isNaN(x))\n             continue;\n@@ -569,5 +577,6 @@ template class ColumnVector<Int128>;\n template class ColumnVector<Int256>;\n template class ColumnVector<Float32>;\n template class ColumnVector<Float64>;\n+template class ColumnVector<UUID>;\n \n }\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 30ab38ed1c2d..e75fd11d1900 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -12,6 +12,12 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n+\n /** Stuff for comparing numbers.\n   * Integer values are compared as usual.\n   * Floating-point numbers are compared this way that NaNs always end up at the end\n@@ -90,6 +96,7 @@ struct FloatCompareHelper\n template <class U> struct CompareHelper<Float32, U> : public FloatCompareHelper<Float32> {};\n template <class U> struct CompareHelper<Float64, U> : public FloatCompareHelper<Float64> {};\n \n+\n /** A template for columns that use a simple array to store.\n  */\n template <typename T>\n@@ -118,7 +125,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n     ColumnVector(std::initializer_list<T> il) : data{il} {}\n \n public:\n-    bool isNumeric() const override { return IsNumber<T>; }\n+    bool isNumeric() const override { return is_arithmetic_v<T>; }\n \n     size_t size() const override\n     {\n@@ -221,8 +228,8 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n         data.reserve(n);\n     }\n \n-    const char * getFamilyName() const override { return TypeName<T>::get(); }\n-    TypeIndex getDataType() const override { return TypeId<T>::value; }\n+    const char * getFamilyName() const override { return TypeName<T>; }\n+    TypeIndex getDataType() const override { return TypeId<T>; }\n \n     MutableColumnPtr cloneResized(size_t size) const override;\n \n@@ -245,18 +252,27 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n     /// Out of range conversion is permitted.\n     UInt64 NO_SANITIZE_UNDEFINED getUInt(size_t n) const override\n     {\n-        return UInt64(data[n]);\n+        if constexpr (is_arithmetic_v<T>)\n+            return UInt64(data[n]);\n+        else\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as UInt\", TypeName<T>);\n     }\n \n     /// Out of range conversion is permitted.\n     Int64 NO_SANITIZE_UNDEFINED getInt(size_t n) const override\n     {\n-        return Int64(data[n]);\n+        if constexpr (is_arithmetic_v<T>)\n+            return Int64(data[n]);\n+        else\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as Int\", TypeName<T>);\n     }\n \n     bool getBool(size_t n) const override\n     {\n-        return bool(data[n]);\n+        if constexpr (is_arithmetic_v<T>)\n+            return bool(data[n]);\n+        else\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot get the value of {} as bool\", TypeName<T>);\n     }\n \n     void insert(const Field & x) override\n@@ -370,5 +386,6 @@ extern template class ColumnVector<Int128>;\n extern template class ColumnVector<Int256>;\n extern template class ColumnVector<Float32>;\n extern template class ColumnVector<Float64>;\n+extern template class ColumnVector<UUID>;\n \n }\ndiff --git a/src/Columns/ColumnsNumber.h b/src/Columns/ColumnsNumber.h\nindex 17a28e617c3f..48721c32fa01 100644\n--- a/src/Columns/ColumnsNumber.h\n+++ b/src/Columns/ColumnsNumber.h\n@@ -26,6 +26,6 @@ using ColumnInt256 = ColumnVector<Int256>;\n using ColumnFloat32 = ColumnVector<Float32>;\n using ColumnFloat64 = ColumnVector<Float64>;\n \n-using ColumnUUID = ColumnVector<UInt128>;\n+using ColumnUUID = ColumnVector<UUID>;\n \n }\ndiff --git a/src/Columns/IColumnUnique.h b/src/Columns/IColumnUnique.h\nindex 731445e2b80b..2c1c542fce5e 100644\n--- a/src/Columns/IColumnUnique.h\n+++ b/src/Columns/IColumnUnique.h\n@@ -1,7 +1,6 @@\n #pragma once\n #include <optional>\n #include <Columns/IColumn.h>\n-#include <Common/UInt128.h>\n \n namespace DB\n {\ndiff --git a/src/Common/ColumnsHashing.h b/src/Common/ColumnsHashing.h\nindex ada783d982c3..3ffa9bb71de4 100644\n--- a/src/Common/ColumnsHashing.h\n+++ b/src/Common/ColumnsHashing.h\n@@ -166,8 +166,7 @@ class LowCardinalityDictionaryCache : public HashMethodContext\n         size_t operator()(const DictionaryKey & key) const\n         {\n             SipHash hash;\n-            hash.update(key.hash.low);\n-            hash.update(key.hash.high);\n+            hash.update(key.hash);\n             hash.update(key.size);\n             return hash.get64();\n         }\ndiff --git a/src/Common/FieldVisitors.cpp b/src/Common/FieldVisitors.cpp\nindex 62f048160329..b87152da7e73 100644\n--- a/src/Common/FieldVisitors.cpp\n+++ b/src/Common/FieldVisitors.cpp\n@@ -1,4 +1,3 @@\n-#include <Core/UUID.h>\n #include <IO/ReadBuffer.h>\n #include <IO/WriteBuffer.h>\n #include <IO/WriteHelpers.h>\n@@ -27,7 +26,7 @@ template <typename T>\n static inline String formatQuotedWithPrefix(T x, const char * prefix)\n {\n     WriteBufferFromOwnString wb;\n-    wb.write(prefix, strlen(prefix));\n+    writeCString(prefix, wb);\n     writeQuoted(x, wb);\n     return wb.str();\n }\n@@ -48,10 +47,11 @@ String FieldVisitorDump::operator() (const DecimalField<Decimal32> & x) const {\n String FieldVisitorDump::operator() (const DecimalField<Decimal64> & x) const { return formatQuotedWithPrefix(x, \"Decimal64_\"); }\n String FieldVisitorDump::operator() (const DecimalField<Decimal128> & x) const { return formatQuotedWithPrefix(x, \"Decimal128_\"); }\n String FieldVisitorDump::operator() (const DecimalField<Decimal256> & x) const { return formatQuotedWithPrefix(x, \"Decimal256_\"); }\n+String FieldVisitorDump::operator() (const UInt128 & x) const { return formatQuotedWithPrefix(x, \"UInt128_\"); }\n String FieldVisitorDump::operator() (const UInt256 & x) const { return formatQuotedWithPrefix(x, \"UInt256_\"); }\n-String FieldVisitorDump::operator() (const Int256 & x) const { return formatQuotedWithPrefix(x, \"Int256_\"); }\n String FieldVisitorDump::operator() (const Int128 & x) const { return formatQuotedWithPrefix(x, \"Int128_\"); }\n-String FieldVisitorDump::operator() (const UInt128 & x) const { return formatQuotedWithPrefix(UUID(x), \"UUID_\"); }\n+String FieldVisitorDump::operator() (const Int256 & x) const { return formatQuotedWithPrefix(x, \"Int256_\"); }\n+String FieldVisitorDump::operator() (const UUID & x) const { return formatQuotedWithPrefix(x, \"UUID_\"); }\n \n \n String FieldVisitorDump::operator() (const String & x) const\n@@ -152,13 +152,11 @@ String FieldVisitorToString::operator() (const DecimalField<Decimal64> & x) cons\n String FieldVisitorToString::operator() (const DecimalField<Decimal128> & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const DecimalField<Decimal256> & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const Int128 & x) const { return formatQuoted(x); }\n-String FieldVisitorToString::operator() (const UInt128 & x) const { return formatQuoted(UUID(x)); }\n-String FieldVisitorToString::operator() (const AggregateFunctionStateData & x) const\n-{\n-    return formatQuoted(x.data);\n-}\n+String FieldVisitorToString::operator() (const UInt128 & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const UInt256 & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const Int256 & x) const { return formatQuoted(x); }\n+String FieldVisitorToString::operator() (const UUID & x) const { return formatQuoted(x); }\n+String FieldVisitorToString::operator() (const AggregateFunctionStateData & x) const { return formatQuoted(x.data); }\n \n String FieldVisitorToString::operator() (const Array & x) const\n {\n@@ -228,6 +226,7 @@ void FieldVisitorWriteBinary::operator() (const UInt128 & x, WriteBuffer & buf)\n void FieldVisitorWriteBinary::operator() (const Int128 & x, WriteBuffer & buf) const { DB::writeVarInt(x, buf); }\n void FieldVisitorWriteBinary::operator() (const UInt256 & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }\n void FieldVisitorWriteBinary::operator() (const Int256 & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }\n+void FieldVisitorWriteBinary::operator() (const UUID & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal32> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal64> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal128> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }\n@@ -315,6 +314,13 @@ void FieldVisitorHash::operator() (const Int128 & x) const\n     hash.update(x);\n }\n \n+void FieldVisitorHash::operator() (const UUID & x) const\n+{\n+    UInt8 type = Field::Types::UUID;\n+    hash.update(type);\n+    hash.update(x);\n+}\n+\n void FieldVisitorHash::operator() (const Float64 & x) const\n {\n     UInt8 type = Field::Types::Float64;\ndiff --git a/src/Common/FieldVisitors.h b/src/Common/FieldVisitors.h\nindex 5adbf2b01ac2..0384be39494f 100644\n--- a/src/Common/FieldVisitors.h\n+++ b/src/Common/FieldVisitors.h\n@@ -19,14 +19,6 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n }\n \n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n-// Just dont mess with it. If the redundant redeclaration is removed then ReaderHelpers.h should be included.\n-// This leads to Arena.h inclusion which has a problem with ASAN stuff included properly and messing macro definition\n-// which intefrers with... You dont want to know, really.\n-UInt128 stringToUUID(const String & str);\n-#pragma GCC diagnostic pop\n-\n \n /** StaticVisitor (and its descendants) - class with overloaded operator() for all types of fields.\n   * You could call visitor for field using function 'applyVisitor'.\n@@ -71,8 +63,11 @@ class FieldVisitorToString : public StaticVisitor<String>\n     String operator() (const Null & x) const;\n     String operator() (const UInt64 & x) const;\n     String operator() (const UInt128 & x) const;\n+    String operator() (const UInt256 & x) const;\n     String operator() (const Int64 & x) const;\n     String operator() (const Int128 & x) const;\n+    String operator() (const Int256 & x) const;\n+    String operator() (const UUID & x) const;\n     String operator() (const Float64 & x) const;\n     String operator() (const String & x) const;\n     String operator() (const Array & x) const;\n@@ -83,9 +78,6 @@ class FieldVisitorToString : public StaticVisitor<String>\n     String operator() (const DecimalField<Decimal128> & x) const;\n     String operator() (const DecimalField<Decimal256> & x) const;\n     String operator() (const AggregateFunctionStateData & x) const;\n-\n-    String operator() (const UInt256 & x) const;\n-    String operator() (const Int256 & x) const;\n };\n \n \n@@ -95,8 +87,11 @@ class FieldVisitorWriteBinary\n     void operator() (const Null & x, WriteBuffer & buf) const;\n     void operator() (const UInt64 & x, WriteBuffer & buf) const;\n     void operator() (const UInt128 & x, WriteBuffer & buf) const;\n+    void operator() (const UInt256 & x, WriteBuffer & buf) const;\n     void operator() (const Int64 & x, WriteBuffer & buf) const;\n     void operator() (const Int128 & x, WriteBuffer & buf) const;\n+    void operator() (const Int256 & x, WriteBuffer & buf) const;\n+    void operator() (const UUID & x, WriteBuffer & buf) const;\n     void operator() (const Float64 & x, WriteBuffer & buf) const;\n     void operator() (const String & x, WriteBuffer & buf) const;\n     void operator() (const Array & x, WriteBuffer & buf) const;\n@@ -107,9 +102,6 @@ class FieldVisitorWriteBinary\n     void operator() (const DecimalField<Decimal128> & x, WriteBuffer & buf) const;\n     void operator() (const DecimalField<Decimal256> & x, WriteBuffer & buf) const;\n     void operator() (const AggregateFunctionStateData & x, WriteBuffer & buf) const;\n-\n-    void operator() (const UInt256 & x, WriteBuffer & buf) const;\n-    void operator() (const Int256 & x, WriteBuffer & buf) const;\n };\n \n \n@@ -120,8 +112,11 @@ class FieldVisitorDump : public StaticVisitor<String>\n     String operator() (const Null & x) const;\n     String operator() (const UInt64 & x) const;\n     String operator() (const UInt128 & x) const;\n+    String operator() (const UInt256 & x) const;\n     String operator() (const Int64 & x) const;\n     String operator() (const Int128 & x) const;\n+    String operator() (const Int256 & x) const;\n+    String operator() (const UUID & x) const;\n     String operator() (const Float64 & x) const;\n     String operator() (const String & x) const;\n     String operator() (const Array & x) const;\n@@ -132,9 +127,6 @@ class FieldVisitorDump : public StaticVisitor<String>\n     String operator() (const DecimalField<Decimal128> & x) const;\n     String operator() (const DecimalField<Decimal256> & x) const;\n     String operator() (const AggregateFunctionStateData & x) const;\n-\n-    String operator() (const UInt256 & x) const;\n-    String operator() (const Int256 & x) const;\n };\n \n \n@@ -171,6 +163,7 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n     T operator() (const UInt64 & x) const { return T(x); }\n     T operator() (const Int64 & x) const { return T(x); }\n     T operator() (const Int128 & x) const { return T(x); }\n+    T operator() (const UUID & x) const { return T(x.toUnderType()); }\n \n     T operator() (const Float64 & x) const\n     {\n@@ -259,8 +252,11 @@ class FieldVisitorHash : public StaticVisitor<>\n     void operator() (const Null & x) const;\n     void operator() (const UInt64 & x) const;\n     void operator() (const UInt128 & x) const;\n+    void operator() (const UInt256 & x) const;\n     void operator() (const Int64 & x) const;\n     void operator() (const Int128 & x) const;\n+    void operator() (const Int256 & x) const;\n+    void operator() (const UUID & x) const;\n     void operator() (const Float64 & x) const;\n     void operator() (const String & x) const;\n     void operator() (const Array & x) const;\n@@ -271,9 +267,6 @@ class FieldVisitorHash : public StaticVisitor<>\n     void operator() (const DecimalField<Decimal128> & x) const;\n     void operator() (const DecimalField<Decimal256> & x) const;\n     void operator() (const AggregateFunctionStateData & x) const;\n-\n-    void operator() (const UInt256 & x) const;\n-    void operator() (const Int256 & x) const;\n };\n \n \n@@ -309,7 +302,7 @@ class FieldVisitorSum : public StaticVisitor<bool>\n     bool operator() (Array &) const { throw Exception(\"Cannot sum Arrays\", ErrorCodes::LOGICAL_ERROR); }\n     bool operator() (Tuple &) const { throw Exception(\"Cannot sum Tuples\", ErrorCodes::LOGICAL_ERROR); }\n     bool operator() (Map &) const { throw Exception(\"Cannot sum Maps\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (UInt128 &) const { throw Exception(\"Cannot sum UUIDs\", ErrorCodes::LOGICAL_ERROR); }\n+    bool operator() (UUID &) const { throw Exception(\"Cannot sum UUIDs\", ErrorCodes::LOGICAL_ERROR); }\n     bool operator() (AggregateFunctionStateData &) const { throw Exception(\"Cannot sum AggregateFunctionStates\", ErrorCodes::LOGICAL_ERROR); }\n \n     bool operator() (Int128 & x) const\ndiff --git a/src/Common/FieldVisitorsAccurateComparison.h b/src/Common/FieldVisitorsAccurateComparison.h\nindex 84099eafb0f4..cf3cbb208dc4 100644\n--- a/src/Common/FieldVisitorsAccurateComparison.h\n+++ b/src/Common/FieldVisitorsAccurateComparison.h\n@@ -36,41 +36,30 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>\n             if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n                 return accurate::equalsOp(l, r);\n \n+            /// TODO This is wrong (does not respect scale).\n             if constexpr (isDecimalField<T>() && isDecimalField<U>())\n                 return l == r;\n \n             if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)\n-                return l == DecimalField<Decimal128>(r, 0);\n+                return l == DecimalField<Decimal256>(Decimal256(r), 0);\n \n             if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())\n-                return DecimalField<Decimal128>(l, 0) == r;\n+                return DecimalField<Decimal256>(Decimal256(l), 0) == r;\n \n-            if constexpr (std::is_same_v<T, String>)\n+            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)\n             {\n-                if constexpr (std::is_same_v<U, UInt128>)\n-                    return stringToUUID(l) == r;\n-\n-                if constexpr (std::is_arithmetic_v<U>)\n-                {\n-                    ReadBufferFromString in(l);\n-                    U parsed;\n-                    readText(parsed, in);\n-                    return operator()(parsed, r);\n-                }\n+                ReadBufferFromString in(l);\n+                U parsed;\n+                readText(parsed, in);\n+                return operator()(parsed, r);\n             }\n \n-            if constexpr (std::is_same_v<U, String>)\n+            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)\n             {\n-                if constexpr (std::is_same_v<T, UInt128>)\n-                    return l == stringToUUID(r);\n-\n-                if constexpr (std::is_arithmetic_v<T>)\n-                {\n-                    ReadBufferFromString in(r);\n-                    T parsed;\n-                    readText(parsed, in);\n-                    return operator()(l, parsed);\n-                }\n+                ReadBufferFromString in(r);\n+                T parsed;\n+                readText(parsed, in);\n+                return operator()(l, parsed);\n             }\n         }\n \n@@ -96,41 +85,30 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>\n             if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n                 return accurate::lessOp(l, r);\n \n+            /// TODO This is wrong (does not respect scale).\n             if constexpr (isDecimalField<T>() && isDecimalField<U>())\n                 return l < r;\n \n             if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)\n-                return l < DecimalField<Decimal128>(r, 0);\n+                return l < DecimalField<Decimal256>(Decimal256(r), 0);\n \n             if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())\n-                return DecimalField<Decimal128>(l, 0) < r;\n+                return DecimalField<Decimal256>(Decimal256(l), 0) < r;\n \n-            if constexpr (std::is_same_v<T, String>)\n+            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)\n             {\n-                if constexpr (std::is_same_v<U, UInt128>)\n-                    return stringToUUID(l) < r;\n-\n-                if constexpr (std::is_arithmetic_v<U>)\n-                {\n-                    ReadBufferFromString in(l);\n-                    U parsed;\n-                    readText(parsed, in);\n-                    return operator()(parsed, r);\n-                }\n+                ReadBufferFromString in(l);\n+                U parsed;\n+                readText(parsed, in);\n+                return operator()(parsed, r);\n             }\n \n-            if constexpr (std::is_same_v<U, String>)\n+            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)\n             {\n-                if constexpr (std::is_same_v<T, UInt128>)\n-                    return l < stringToUUID(r);\n-\n-                if constexpr (std::is_arithmetic_v<T>)\n-                {\n-                    ReadBufferFromString in(r);\n-                    T parsed;\n-                    readText(parsed, in);\n-                    return operator()(l, parsed);\n-                }\n+                ReadBufferFromString in(r);\n+                T parsed;\n+                readText(parsed, in);\n+                return operator()(l, parsed);\n             }\n         }\n \ndiff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h\nindex d601d945ccfd..84e514c1375b 100644\n--- a/src/Common/HashTable/Hash.h\n+++ b/src/Common/HashTable/Hash.h\n@@ -1,9 +1,10 @@\n #pragma once\n \n+#include <city.h>\n+#include <Core/Types.h>\n #include <common/types.h>\n #include <common/unaligned.h>\n #include <common/StringRef.h>\n-#include <Common/UInt128.h>\n \n #include <type_traits>\n \n@@ -167,35 +168,36 @@ inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) <= sizeof(UInt64)), T> k\n     return intHash64(u.out);\n }\n \n-template <typename T>\n-static constexpr bool UseDefaultHashForBigInts =\n-    std::is_same_v<T, DB::Int128>  ||\n-    std::is_same_v<T, DB::UInt128> ||\n-    (is_big_int_v<T> && sizeof(T) == 32);\n \n template <typename T>\n-inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64) && UseDefaultHashForBigInts<T>), T> key)\n+inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> key)\n {\n-    if constexpr (std::is_same_v<T, DB::Int128>)\n+    if constexpr (is_big_int_v<T> && sizeof(T) == 16)\n     {\n-        return intHash64(static_cast<UInt64>(key) ^ static_cast<UInt64>(key >> 64));\n+        /// TODO This is classical antipattern.\n+        return intHash64(\n+            static_cast<UInt64>(key) ^\n+            static_cast<UInt64>(key >> 64));\n     }\n-    else if constexpr (std::is_same_v<T, DB::UInt128>)\n+    else if constexpr (std::is_same_v<T, DB::UUID>)\n     {\n-        return intHash64(key.low ^ key.high);\n+        return intHash64(\n+            static_cast<UInt64>(key.toUnderType()) ^\n+            static_cast<UInt64>(key.toUnderType() >> 64));\n     }\n     else if constexpr (is_big_int_v<T> && sizeof(T) == 32)\n     {\n-        return intHash64(static_cast<UInt64>(key) ^\n+        return intHash64(\n+            static_cast<UInt64>(key) ^\n             static_cast<UInt64>(key >> 64) ^\n             static_cast<UInt64>(key >> 128) ^\n             static_cast<UInt64>(key >> 256));\n     }\n-\n     assert(false);\n     __builtin_unreachable();\n }\n \n+\n template <typename T, typename Enable = void>\n struct DefaultHash;\n \n@@ -213,7 +215,7 @@ struct DefaultHash<T, std::enable_if_t<DB::IsDecimalNumber<T>>>\n {\n     size_t operator() (T key) const\n     {\n-        return DefaultHash64<typename T::NativeType>(key);\n+        return DefaultHash64<typename T::NativeType>(key.value);\n     }\n };\n \n@@ -261,15 +263,98 @@ DEFINE_HASH(DB::Int128)\n DEFINE_HASH(DB::Int256)\n DEFINE_HASH(DB::Float32)\n DEFINE_HASH(DB::Float64)\n+DEFINE_HASH(DB::UUID)\n \n #undef DEFINE_HASH\n \n \n+struct UInt128Hash\n+{\n+    size_t operator()(UInt128 x) const\n+    {\n+        return CityHash_v1_0_2::Hash128to64({x.items[0], x.items[1]});\n+    }\n+};\n+\n+struct UUIDHash\n+{\n+    size_t operator()(DB::UUID x) const\n+    {\n+        return UInt128Hash()(x.toUnderType());\n+    }\n+};\n+\n+#ifdef __SSE4_2__\n+\n+struct UInt128HashCRC32\n+{\n+    size_t operator()(UInt128 x) const\n+    {\n+        UInt64 crc = -1ULL;\n+        crc = _mm_crc32_u64(crc, x.items[0]);\n+        crc = _mm_crc32_u64(crc, x.items[1]);\n+        return crc;\n+    }\n+};\n+\n+#else\n+\n+/// On other platforms we do not use CRC32. NOTE This can be confusing.\n+struct UInt128HashCRC32 : public UInt128Hash {};\n+\n+#endif\n+\n+struct UInt128TrivialHash\n+{\n+    size_t operator()(UInt128 x) const { return x.items[0]; }\n+};\n+\n+struct UUIDTrivialHash\n+{\n+    size_t operator()(DB::UUID x) const { return x.toUnderType().items[0]; }\n+};\n+\n+struct UInt256Hash\n+{\n+    size_t operator()(UInt256 x) const\n+    {\n+        /// NOTE suboptimal\n+        return CityHash_v1_0_2::Hash128to64({\n+            CityHash_v1_0_2::Hash128to64({x.items[0], x.items[1]}),\n+            CityHash_v1_0_2::Hash128to64({x.items[2], x.items[3]})});\n+    }\n+};\n+\n+#ifdef __SSE4_2__\n+\n+struct UInt256HashCRC32\n+{\n+    size_t operator()(UInt256 x) const\n+    {\n+        UInt64 crc = -1ULL;\n+        crc = _mm_crc32_u64(crc, x.items[0]);\n+        crc = _mm_crc32_u64(crc, x.items[1]);\n+        crc = _mm_crc32_u64(crc, x.items[2]);\n+        crc = _mm_crc32_u64(crc, x.items[3]);\n+        return crc;\n+    }\n+};\n+\n+#else\n+\n+/// We do not need to use CRC32 on other platforms. NOTE This can be confusing.\n+struct UInt256HashCRC32 : public UInt256Hash {};\n+\n+#endif\n+\n template <>\n-struct DefaultHash<DB::UInt128> : public DB::UInt128Hash {};\n+struct DefaultHash<DB::UInt128> : public UInt128Hash {};\n \n template <>\n-struct DefaultHash<DB::DummyUInt256> : public DB::UInt256Hash {};\n+struct DefaultHash<DB::UInt256> : public UInt256Hash {};\n+\n+template <>\n+struct DefaultHash<DB::UUID> : public UUIDHash {};\n \n \n /// It is reasonable to use for UInt8, UInt16 with sufficient hash table size.\n@@ -322,23 +407,18 @@ struct IntHash32\n {\n     size_t operator() (const T & key) const\n     {\n-        if constexpr (std::is_same_v<T, DB::Int128>)\n-        {\n-            return intHash32<salt>(static_cast<UInt64>(key) ^ static_cast<UInt64>(key >> 64));\n-        }\n-        else if constexpr (std::is_same_v<T, DB::UInt128>)\n+        if constexpr (is_big_int_v<T> && sizeof(T) == 16)\n         {\n-            return intHash32<salt>(key.low ^ key.high);\n+            return intHash32<salt>(key.items[0] ^ key.items[1]);\n         }\n         else if constexpr (is_big_int_v<T> && sizeof(T) == 32)\n         {\n-            return intHash32<salt>(static_cast<UInt64>(key) ^\n-                static_cast<UInt64>(key >> 64) ^\n-                static_cast<UInt64>(key >> 128) ^\n-                static_cast<UInt64>(key >> 256));\n+            return intHash32<salt>(key.items[0] ^ key.items[1] ^ key.items[2] ^ key.items[3]);\n         }\n         else if constexpr (sizeof(T) <= sizeof(UInt64))\n+        {\n             return intHash32<salt>(key);\n+        }\n \n         assert(false);\n         __builtin_unreachable();\ndiff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h\nindex 128fed7822eb..e25b3191652a 100644\n--- a/src/Common/HashTable/HashTable.h\n+++ b/src/Common/HashTable/HashTable.h\n@@ -70,10 +70,10 @@ namespace ZeroTraits\n {\n \n template <typename T>\n-bool check(const T x) { return x == 0; }\n+bool check(const T x) { return x == T{}; }\n \n template <typename T>\n-void set(T & x) { x = 0; }\n+void set(T & x) { x = {}; }\n \n }\n \ndiff --git a/src/Common/HashTable/StringHashMap.h b/src/Common/HashTable/StringHashMap.h\nindex fe4eab160928..298580dc8375 100644\n--- a/src/Common/HashTable/StringHashMap.h\n+++ b/src/Common/HashTable/StringHashMap.h\n@@ -28,9 +28,8 @@ struct StringHashMapCell<StringKey16, TMapped> : public HashMapCell<StringKey16,\n \n     // Zero means unoccupied cells in hash table. Use key with last word = 0 as\n     // zero keys, because such keys are unrepresentable (no way to encode length).\n-    static bool isZero(const StringKey16 & key, const HashTableNoState &)\n-    { return key.high == 0; }\n-    void setZero() { this->value.first.high = 0; }\n+    static bool isZero(const StringKey16 & key, const HashTableNoState &) { return key.items[1] == 0; }\n+    void setZero() { this->value.first.items[1] = 0; }\n \n     // external\n     const StringRef getKey() const { return toStringRef(this->value.first); }\ndiff --git a/src/Common/HashTable/StringHashSet.h b/src/Common/HashTable/StringHashSet.h\nindex 8714a0e1fe4d..0466dca3574b 100644\n--- a/src/Common/HashTable/StringHashSet.h\n+++ b/src/Common/HashTable/StringHashSet.h\n@@ -33,8 +33,8 @@ struct StringHashSetCell<StringKey16> : public HashTableCell<StringKey16, String\n     // Zero means unoccupied cells in hash table. Use key with last word = 0 as\n     // zero keys, because such keys are unrepresentable (no way to encode length).\n     static bool isZero(const StringKey16 & key_, const HashTableNoState &)\n-    { return key_.high == 0; }\n-    void setZero() { this->key.high = 0; }\n+    { return key_.items[1] == 0; }\n+    void setZero() { this->key.items[1] = 0; }\n };\n \n template <>\ndiff --git a/src/Common/HashTable/StringHashTable.h b/src/Common/HashTable/StringHashTable.h\nindex 3a96d0cefdec..b05d119e0e97 100644\n--- a/src/Common/HashTable/StringHashTable.h\n+++ b/src/Common/HashTable/StringHashTable.h\n@@ -25,8 +25,8 @@ inline StringRef ALWAYS_INLINE toStringRef(const StringKey8 & n)\n }\n inline StringRef ALWAYS_INLINE toStringRef(const StringKey16 & n)\n {\n-    assert(n.high != 0);\n-    return {reinterpret_cast<const char *>(&n), 16ul - (__builtin_clzll(n.high) >> 3)};\n+    assert(n.items[1] != 0);\n+    return {reinterpret_cast<const char *>(&n), 16ul - (__builtin_clzll(n.items[1]) >> 3)};\n }\n inline StringRef ALWAYS_INLINE toStringRef(const StringKey24 & n)\n {\n@@ -46,8 +46,8 @@ struct StringHashTableHash\n     size_t ALWAYS_INLINE operator()(StringKey16 key) const\n     {\n         size_t res = -1ULL;\n-        res = _mm_crc32_u64(res, key.low);\n-        res = _mm_crc32_u64(res, key.high);\n+        res = _mm_crc32_u64(res, key.items[0]);\n+        res = _mm_crc32_u64(res, key.items[1]);\n         return res;\n     }\n     size_t ALWAYS_INLINE operator()(StringKey24 key) const\ndiff --git a/src/Common/MemoryTracker.cpp b/src/Common/MemoryTracker.cpp\nindex 60fb4d06b14f..e4c4e0b0ab1f 100644\n--- a/src/Common/MemoryTracker.cpp\n+++ b/src/Common/MemoryTracker.cpp\n@@ -6,12 +6,14 @@\n #include <Common/formatReadable.h>\n #include <common/logger_useful.h>\n #include <Common/ProfileEvents.h>\n+#include <Common/thread_local_rng.h>\n \n #include <atomic>\n #include <cmath>\n #include <random>\n #include <cstdlib>\n \n+\n #ifdef MEMORY_TRACKER_DEBUG_CHECKS\n thread_local bool _memory_tracker_always_throw_logical_error_on_allocation = false;\n #endif\ndiff --git a/src/Common/OpenTelemetryTraceContext.h b/src/Common/OpenTelemetryTraceContext.h\nindex 56503c16a00b..9f2b5af9105d 100644\n--- a/src/Common/OpenTelemetryTraceContext.h\n+++ b/src/Common/OpenTelemetryTraceContext.h\n@@ -6,12 +6,12 @@ namespace DB\n // The runtime info we need to create new OpenTelemetry spans.\n struct OpenTelemetryTraceContext\n {\n-    __uint128_t trace_id = 0;\n+    UUID trace_id{};\n     UInt64 span_id = 0;\n     // The incoming tracestate header and the trace flags, we just pass them\n     // downstream. See https://www.w3.org/TR/trace-context/\n     String tracestate;\n-    uint8_t trace_flags = 0;\n+    UInt8 trace_flags = 0;\n \n     // Parse/compose OpenTelemetry traceparent header.\n     bool parseTraceparentHeader(const std::string & traceparent, std::string & error);\ndiff --git a/src/Common/PODArray.h b/src/Common/PODArray.h\nindex b1042332cfac..8f6414b3fa93 100644\n--- a/src/Common/PODArray.h\n+++ b/src/Common/PODArray.h\n@@ -260,22 +260,12 @@ class PODArrayBase : private boost::noncopyable, private TAllocator    /// empty\n     template <typename ... TAllocatorParams>\n     void push_back_raw(const void * ptr, TAllocatorParams &&... allocator_params)\n     {\n-        push_back_raw_many(1, ptr, std::forward<TAllocatorParams>(allocator_params)...);\n-    }\n-\n-    template <typename ... TAllocatorParams>\n-    void push_back_raw_many(size_t number_of_items, const void * ptr, TAllocatorParams &&... allocator_params)\n-    {\n-        size_t required_capacity = size() + number_of_items;\n+        size_t required_capacity = size() + ELEMENT_SIZE;\n         if (unlikely(required_capacity > capacity()))\n             reserve(required_capacity, std::forward<TAllocatorParams>(allocator_params)...);\n \n-        size_t items_byte_size = byte_size(number_of_items);\n-        if (items_byte_size)\n-        {\n-            memcpy(c_end, ptr, items_byte_size);\n-            c_end += items_byte_size;\n-        }\n+        memcpy(c_end, ptr, ELEMENT_SIZE);\n+        c_end += ELEMENT_SIZE;\n     }\n \n     void protect()\ndiff --git a/src/Common/SipHash.h b/src/Common/SipHash.h\nindex ce7e80a7204a..92d635eb63cf 100644\n--- a/src/Common/SipHash.h\n+++ b/src/Common/SipHash.h\n@@ -155,7 +155,6 @@ class SipHash\n         unalignedStore<UInt64>(out + 8, v2 ^ v3);\n     }\n \n-    /// template for avoiding 'unsigned long long' vs 'unsigned long' problem on old poco in macos\n     template <typename T>\n     ALWAYS_INLINE void get128(T & lo, T & hi)\n     {\n@@ -165,6 +164,13 @@ class SipHash\n         hi = v2 ^ v3;\n     }\n \n+    template <typename T>\n+    ALWAYS_INLINE void get128(T & dst)\n+    {\n+        static_assert(sizeof(T) == 16);\n+        get128(reinterpret_cast<char *>(&dst));\n+    }\n+\n     UInt64 get64()\n     {\n         finalize();\ndiff --git a/src/Common/SpaceSaving.h b/src/Common/SpaceSaving.h\nindex 7ad48a6cf874..b7353d803b78 100644\n--- a/src/Common/SpaceSaving.h\n+++ b/src/Common/SpaceSaving.h\n@@ -6,7 +6,6 @@\n #include <boost/range/adaptor/reversed.hpp>\n \n #include <Common/ArenaWithFreeLists.h>\n-#include <Common/UInt128.h>\n #include <Common/HashTable/Hash.h>\n #include <Common/HashTable/HashMap.h>\n \ndiff --git a/src/Common/UInt128.h b/src/Common/UInt128.h\ndeleted file mode 100644\nindex be96f4096735..000000000000\n--- a/src/Common/UInt128.h\n+++ /dev/null\n@@ -1,292 +0,0 @@\n-#pragma once\n-\n-#include <tuple>\n-#include <iomanip>\n-#include <city.h>\n-\n-#include <Core/Types.h>\n-#include <Common/hex.h>\n-\n-#ifdef __SSE4_2__\n-#include <nmmintrin.h>\n-#endif\n-\n-\n-namespace DB\n-{\n-\n-/// For aggregation by SipHash, UUID type or concatenation of several fields.\n-struct UInt128\n-{\n-/// Suppress gcc7 warnings: 'prev_key.DB::UInt128::low' may be used uninitialized in this function\n-#if !defined(__clang__)\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n-#endif\n-\n-    /// This naming assumes little endian.\n-    UInt64 low;\n-    UInt64 high;\n-\n-    /// TODO: Make this constexpr. Currently it is used in unions\n-    /// and union cannot contain member with non trivial constructor\n-    /// constructor must be non user provided but compiler cannot constexpr constructor\n-    /// if members low and high are not initialized, if we default member initialize them\n-    /// constructor becomes non trivial.\n-    UInt128() = default;\n-    explicit constexpr UInt128(const UInt64 low_, const UInt64 high_) : low(low_), high(high_) { }\n-\n-    /// We need Int128 to UInt128 conversion or AccurateComparison will call greaterOp<Int128, UInt64> instead of greaterOp<Int128, UInt128>\n-    explicit constexpr UInt128(const Int128 rhs) : low(rhs), high(rhs >> 64) {}\n-    explicit constexpr UInt128(const Int64 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const Int32 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const Int16 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const Int8 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const UInt8 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const UInt16 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const UInt32 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const UInt64 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const Float32 rhs) : low(rhs), high() {}\n-    explicit constexpr UInt128(const Float64 rhs) : low(rhs), high() {}\n-\n-    constexpr auto tuple() const { return std::tie(high, low); }\n-\n-    String toHexString() const\n-    {\n-        String res(2 * sizeof(UInt128), 0);\n-        writeHexUIntLowercase(*this, res.data());\n-        return res;\n-    }\n-\n-    constexpr bool operator== (const UInt128 rhs) const { return tuple() == rhs.tuple(); }\n-    constexpr bool operator!= (const UInt128 rhs) const { return tuple() != rhs.tuple(); }\n-    constexpr bool operator<  (const UInt128 rhs) const { return tuple() < rhs.tuple(); }\n-    constexpr bool operator<= (const UInt128 rhs) const { return tuple() <= rhs.tuple(); }\n-    constexpr bool operator>  (const UInt128 rhs) const { return tuple() > rhs.tuple(); }\n-    constexpr bool operator>= (const UInt128 rhs) const { return tuple() >= rhs.tuple(); }\n-\n-    constexpr bool operator == (const Int128 rhs) const { return *this == UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-    constexpr bool operator != (const Int128 rhs) const { return *this != UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    constexpr bool operator >= (const Int128 rhs) const { return *this >= UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    constexpr bool operator >  (const Int128 rhs) const { return *this >  UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    constexpr bool operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-    constexpr bool operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-\n-    constexpr bool operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }\n-    constexpr bool operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }\n-    constexpr bool operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }\n-    constexpr bool operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }\n-\n-    template <typename T> constexpr bool operator== (const T rhs) const { return *this == UInt128(rhs); }\n-    template <typename T> constexpr bool operator!= (const T rhs) const { return *this != UInt128(rhs); }\n-    template <typename T> constexpr bool operator>= (const T rhs) const { return *this >= UInt128(rhs); }\n-    template <typename T> constexpr bool operator>  (const T rhs) const { return *this >  UInt128(rhs); }\n-    template <typename T> constexpr bool operator<= (const T rhs) const { return *this <= UInt128(rhs); }\n-    template <typename T> constexpr bool operator<  (const T rhs) const { return *this <  UInt128(rhs); }\n-\n-    template <typename T> explicit operator T() const\n-    {\n-        if constexpr (std::is_class_v<T>)\n-            return T();\n-        else\n-            return static_cast<T>(low);\n-    }\n-\n-#if !defined(__clang__)\n-#pragma GCC diagnostic pop\n-#endif\n-\n-    constexpr UInt128 & operator= (const UInt64 rhs) { low = rhs; high = 0; return *this; }\n-};\n-\n-template <typename T> constexpr bool operator == (T a, const UInt128 b) { return b.operator==(a); }\n-template <typename T> constexpr bool operator != (T a, const UInt128 b) { return b.operator!=(a); }\n-template <typename T> constexpr bool operator >= (T a, const UInt128 b) { return b <= a; }\n-template <typename T> constexpr bool operator >  (T a, const UInt128 b) { return b < a; }\n-template <typename T> constexpr bool operator <= (T a, const UInt128 b) { return b >= a; }\n-template <typename T> constexpr bool operator <  (T a, const UInt128 b) { return b > a; }\n-\n-template <> inline constexpr bool IsNumber<UInt128> = true;\n-template <> struct TypeName<UInt128> { static constexpr const char * get() { return \"UInt128\"; } };\n-template <> struct TypeId<UInt128> { static constexpr const TypeIndex value = TypeIndex::UInt128; };\n-\n-struct UInt128Hash\n-{\n-    size_t operator()(UInt128 x) const\n-    {\n-        return CityHash_v1_0_2::Hash128to64({x.low, x.high});\n-    }\n-};\n-\n-#ifdef __SSE4_2__\n-\n-struct UInt128HashCRC32\n-{\n-    size_t operator()(UInt128 x) const\n-    {\n-        UInt64 crc = -1ULL;\n-        crc = _mm_crc32_u64(crc, x.low);\n-        crc = _mm_crc32_u64(crc, x.high);\n-        return crc;\n-    }\n-};\n-\n-#else\n-\n-/// On other platforms we do not use CRC32. NOTE This can be confusing.\n-struct UInt128HashCRC32 : public UInt128Hash {};\n-\n-#endif\n-\n-struct UInt128TrivialHash\n-{\n-    size_t operator()(UInt128 x) const { return x.low; }\n-};\n-\n-\n-/** Used for aggregation, for putting a large number of constant-length keys in a hash table.\n-  */\n-struct DummyUInt256\n-{\n-\n-/// Suppress gcc7 warnings: 'prev_key.DB::UInt256::a' may be used uninitialized in this function\n-#if !defined(__clang__)\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n-#endif\n-\n-    UInt64 a;\n-    UInt64 b;\n-    UInt64 c;\n-    UInt64 d;\n-\n-    bool operator== (const DummyUInt256 rhs) const\n-    {\n-        return a == rhs.a && b == rhs.b && c == rhs.c && d == rhs.d;\n-\n-    /* So it's no better.\n-        return 0xFFFF == _mm_movemask_epi8(_mm_and_si128(\n-            _mm_cmpeq_epi8(\n-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&a)),\n-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&rhs.a))),\n-            _mm_cmpeq_epi8(\n-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&c)),\n-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&rhs.c)))));*/\n-    }\n-\n-    bool operator!= (const DummyUInt256 rhs) const { return !operator==(rhs); }\n-\n-    bool operator== (const UInt64 rhs) const { return a == rhs && b == 0 && c == 0 && d == 0; }\n-    bool operator!= (const UInt64 rhs) const { return !operator==(rhs); }\n-\n-#if !defined(__clang__)\n-#pragma GCC diagnostic pop\n-#endif\n-\n-    DummyUInt256 & operator = (const UInt64 rhs) { a = rhs; b = 0; c = 0; d = 0; return *this; }\n-};\n-\n-struct UInt256Hash\n-{\n-    size_t operator()(DummyUInt256 x) const\n-    {\n-        /// NOTE suboptimal\n-        return CityHash_v1_0_2::Hash128to64({CityHash_v1_0_2::Hash128to64({x.a, x.b}), CityHash_v1_0_2::Hash128to64({x.c, x.d})});\n-    }\n-};\n-\n-#ifdef __SSE4_2__\n-\n-struct UInt256HashCRC32\n-{\n-    size_t operator()(DummyUInt256 x) const\n-    {\n-        UInt64 crc = -1ULL;\n-        crc = _mm_crc32_u64(crc, x.a);\n-        crc = _mm_crc32_u64(crc, x.b);\n-        crc = _mm_crc32_u64(crc, x.c);\n-        crc = _mm_crc32_u64(crc, x.d);\n-        return crc;\n-    }\n-};\n-\n-#else\n-\n-/// We do not need to use CRC32 on other platforms. NOTE This can be confusing.\n-struct UInt256HashCRC32 : public UInt256Hash {};\n-\n-#endif\n-\n-}\n-\n-template <> struct is_signed<DB::UInt128>\n-{\n-    static constexpr bool value = false;\n-};\n-\n-template <> struct is_unsigned<DB::UInt128>\n-{\n-    static constexpr bool value = true;\n-};\n-\n-template <> struct is_integer<DB::UInt128>\n-{\n-    static constexpr bool value = true;\n-};\n-\n-// Operator +, -, /, *, % aren't implemented so it's not an arithmetic type\n-template <> struct is_arithmetic<DB::UInt128>\n-{\n-    static constexpr bool value = false;\n-};\n-\n-/// Overload hash for type casting\n-namespace std\n-{\n-template <> struct hash<DB::UInt128>\n-{\n-    size_t operator()(const DB::UInt128 & u) const\n-    {\n-        return CityHash_v1_0_2::Hash128to64({u.low, u.high});\n-    }\n-};\n-\n-template<>\n-class numeric_limits<DB::UInt128>\n-{\n-public:\n-    static constexpr bool is_specialized = true;\n-    static constexpr bool is_signed = ::is_signed<DB::UInt128>::value;\n-    static constexpr bool is_integer = ::is_integer<DB::UInt128>::value;\n-    static constexpr bool is_exact = true;\n-    static constexpr bool has_infinity = false;\n-    static constexpr bool has_quiet_NaN = false;\n-    static constexpr bool has_signaling_NaN = false;\n-    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;\n-    static constexpr bool has_denorm_loss = false;\n-    static constexpr std::float_round_style round_style = std::round_toward_zero;\n-    static constexpr bool is_iec559 = false;\n-    static constexpr bool is_bounded = true;\n-    static constexpr bool is_modulo = true;\n-    static constexpr int digits = std::numeric_limits<UInt64>::digits * 2;\n-    static constexpr int digits10 = digits * 0.30103 /*std::log10(2)*/;\n-    static constexpr int max_digits10 = 0;\n-    static constexpr int radix = 2;\n-    static constexpr int min_exponent = 0;\n-    static constexpr int min_exponent10 = 0;\n-    static constexpr int max_exponent = 0;\n-    static constexpr int max_exponent10 = 0;\n-    static constexpr bool traps = true;\n-    static constexpr bool tinyness_before = false;\n-\n-    static constexpr DB::UInt128 min() noexcept { return DB::UInt128(0, 0); }\n-\n-    static constexpr DB::UInt128 max() noexcept\n-    {\n-        return DB::UInt128(std::numeric_limits<UInt64>::max(), std::numeric_limits<UInt64>::max());\n-    }\n-\n-    static constexpr DB::UInt128 lowest() noexcept { return min(); }\n-};\n-\n-}\ndiff --git a/src/Common/examples/arena_with_free_lists.cpp b/src/Common/examples/arena_with_free_lists.cpp\nindex d02fadca794c..207fcd7dba2f 100644\n--- a/src/Common/examples/arena_with_free_lists.cpp\n+++ b/src/Common/examples/arena_with_free_lists.cpp\n@@ -172,17 +172,17 @@ struct Dictionary\n     {\n         switch (attribute.type)\n         {\n-            case AttributeUnderlyingType::utUInt8: std::get<ContainerPtrType<UInt8>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n-            case AttributeUnderlyingType::utUInt16: std::get<ContainerPtrType<UInt16>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n-            case AttributeUnderlyingType::utUInt32: std::get<ContainerPtrType<UInt32>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n-            case AttributeUnderlyingType::utUInt64: std::get<ContainerPtrType<UInt64>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n-            case AttributeUnderlyingType::utInt8: std::get<ContainerPtrType<Int8>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n-            case AttributeUnderlyingType::utInt16: std::get<ContainerPtrType<Int16>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n-            case AttributeUnderlyingType::utInt32: std::get<ContainerPtrType<Int32>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n-            case AttributeUnderlyingType::utInt64: std::get<ContainerPtrType<Int64>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n-            case AttributeUnderlyingType::utFloat32: std::get<ContainerPtrType<Float32>>(attribute.arrays)[idx] = value.get<Float64>(); break;\n-            case AttributeUnderlyingType::utFloat64: std::get<ContainerPtrType<Float64>>(attribute.arrays)[idx] = value.get<Float64>(); break;\n-            case AttributeUnderlyingType::utString:\n+            case AttributeUnderlyingType::UInt8: std::get<ContainerPtrType<UInt8>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n+            case AttributeUnderlyingType::UInt16: std::get<ContainerPtrType<UInt16>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n+            case AttributeUnderlyingType::UInt32: std::get<ContainerPtrType<UInt32>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n+            case AttributeUnderlyingType::UInt64: std::get<ContainerPtrType<UInt64>>(attribute.arrays)[idx] = value.get<UInt64>(); break;\n+            case AttributeUnderlyingType::Int8: std::get<ContainerPtrType<Int8>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n+            case AttributeUnderlyingType::Int16: std::get<ContainerPtrType<Int16>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n+            case AttributeUnderlyingType::Int32: std::get<ContainerPtrType<Int32>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n+            case AttributeUnderlyingType::Int64: std::get<ContainerPtrType<Int64>>(attribute.arrays)[idx] = value.get<Int64>(); break;\n+            case AttributeUnderlyingType::Float32: std::get<ContainerPtrType<Float32>>(attribute.arrays)[idx] = value.get<Float64>(); break;\n+            case AttributeUnderlyingType::Float64: std::get<ContainerPtrType<Float64>>(attribute.arrays)[idx] = value.get<Float64>(); break;\n+            case AttributeUnderlyingType::String:\n             {\n                 const auto & string = value.get<String>();\n                 auto & string_ref = std::get<ContainerPtrType<StringRef>>(attribute.arrays)[idx];\n@@ -308,7 +308,7 @@ int main(int argc, char ** argv)\n     constexpr size_t cache_size = 1024;\n \n     Dictionary::Attribute attr;\n-    attr.type = Dictionary::AttributeUnderlyingType::utString;\n+    attr.type = Dictionary::AttributeUnderlyingType::String;\n     std::get<Dictionary::ContainerPtrType<StringRef>>(attr.arrays).reset(new StringRef[cache_size]{});  // NOLINT\n \n     while (true)\ndiff --git a/src/Common/getHashOfLoadedBinary.cpp b/src/Common/getHashOfLoadedBinary.cpp\nindex d401b0311be4..dcf483b4fa80 100644\n--- a/src/Common/getHashOfLoadedBinary.cpp\n+++ b/src/Common/getHashOfLoadedBinary.cpp\n@@ -38,7 +38,7 @@ std::string getHashOfLoadedBinaryHex()\n {\n     SipHash hash = getHashOfLoadedBinary();\n     std::array<UInt64, 2> checksum;\n-    hash.get128(checksum[0], checksum[1]);\n+    hash.get128(checksum);\n     return getHexUIntUppercase(checksum);\n }\n \ndiff --git a/src/Common/intExp.h b/src/Common/intExp.h\nindex bc977a41d33c..b2d704e58b29 100644\n--- a/src/Common/intExp.h\n+++ b/src/Common/intExp.h\n@@ -138,9 +138,9 @@ constexpr inline Int128 exp10_i128(int x)\n }\n \n \n-inline wInt256 exp10_i256(int x)\n+inline Int256 exp10_i256(int x)\n {\n-    using Int256 = wInt256;\n+    using Int256 = Int256;\n     static constexpr Int256 i10e18{1000000000000000000ll};\n     static const Int256 values[] = {\n         static_cast<Int256>(1ll),\ndiff --git a/src/Compression/getCompressionCodecForFile.cpp b/src/Compression/getCompressionCodecForFile.cpp\nindex 05dd49f3939b..1557985ff66d 100644\n--- a/src/Compression/getCompressionCodecForFile.cpp\n+++ b/src/Compression/getCompressionCodecForFile.cpp\n@@ -6,8 +6,6 @@\n #include <Common/PODArray.h>\n #include <common/logger_useful.h>\n \n-#include <Common/UInt128.h>\n-\n namespace DB\n {\n \ndiff --git a/src/Core/AccurateComparison.h b/src/Core/AccurateComparison.h\nindex 1e45dbe23dcb..29088cbf1b5c 100644\n--- a/src/Core/AccurateComparison.h\n+++ b/src/Core/AccurateComparison.h\n@@ -2,11 +2,11 @@\n \n #include <cmath>\n #include <limits>\n-#include \"Defines.h\"\n-#include \"Types.h\"\n+#include <common/DecomposedFloat.h>\n+#include <Core/Defines.h>\n+#include <Core/Types.h>\n #include <common/extended_types.h>\n #include <Common/NaNUtils.h>\n-#include <Common/UInt128.h>\n \n /** Preceptually-correct number comparisons.\n   * Example: Int8(-1) != UInt8(255)\n@@ -15,504 +15,142 @@\n namespace accurate\n {\n \n-using DB::UInt64;\n-\n-/** Cases:\n-    1) Safe conversion (in case of default C++ operators)\n-        a) int vs any int\n-        b) uint vs any uint\n-        c) float vs any float\n-    2) int vs uint\n-        a) sizeof(int) <= sizeof(uint). Accurate comparison with MAX_INT tresholds\n-        b) sizeof(int)  > sizeof(uint). Casting to int\n-    3) integral_type vs floating_type\n-        a) sizeof(integral_type) <= 4. Comparison via casting arguments to Float64\n-        b) sizeof(integral_type) == 8. Accurate comparison. Consider 3 sets of intervals:\n-            1) interval between adjacent floats less or equal 1\n-            2) interval between adjacent floats greater then 2\n-            3) float is outside [MIN_INT64; MAX_INT64]\n-*/\n-\n-// Case 1. Is pair of floats or pair of ints or pair of uints\n-template <typename A, typename B>\n-constexpr bool is_safe_conversion = (std::is_floating_point_v<A> && std::is_floating_point_v<B>)\n-    || (is_integer_v<A> && is_integer_v<B> && !(is_signed_v<A> ^ is_signed_v<B>));\n-template <typename A, typename B>\n-using bool_if_safe_conversion = std::enable_if_t<is_safe_conversion<A, B>, bool>;\n-template <typename A, typename B>\n-using bool_if_not_safe_conversion = std::enable_if_t<!is_safe_conversion<A, B>, bool>;\n-\n-\n-/// Case 2. Are params IntXX and UIntYY ?\n-template <typename TInt, typename TUInt>\n-constexpr bool is_any_int_vs_uint\n-    = is_integer_v<TInt> && is_integer_v<TUInt> && is_signed_v<TInt> && is_unsigned_v<TUInt>;\n-\n-// Case 2a. Are params IntXX and UIntYY and sizeof(IntXX) >= sizeof(UIntYY) (in such case will use accurate compare)\n-template <typename TInt, typename TUInt>\n-constexpr bool is_le_int_vs_uint = is_any_int_vs_uint<TInt, TUInt> && (sizeof(TInt) <= sizeof(TUInt));\n-\n-static_assert(is_le_int_vs_uint<Int128, DB::UInt128>);\n-static_assert(is_le_int_vs_uint<Int128, DB::UInt256>);\n-\n-template <typename TInt, typename TUInt>\n-using bool_if_le_int_vs_uint_t = std::enable_if_t<is_le_int_vs_uint<TInt, TUInt>, bool>;\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_le_int_vs_uint_t<TInt, TUInt> greaterOpTmpl(TInt a, TUInt b)\n-{\n-    return static_cast<TUInt>(a) > b && a >= 0 && b <= static_cast<TUInt>(std::numeric_limits<TInt>::max());\n-}\n-\n-template <typename TUInt, typename TInt>\n-inline bool_if_le_int_vs_uint_t<TInt, TUInt> greaterOpTmpl(TUInt a, TInt b)\n-{\n-    return a > static_cast<TUInt>(b) || b < 0 || a > static_cast<TUInt>(std::numeric_limits<TInt>::max());\n-}\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_le_int_vs_uint_t<TInt, TUInt> equalsOpTmpl(TInt a, TUInt b)\n-{\n-    return static_cast<TUInt>(a) == b && a >= 0 && b <= static_cast<TUInt>(std::numeric_limits<TInt>::max());\n-}\n-\n-template <typename TUInt, typename TInt>\n-inline bool_if_le_int_vs_uint_t<TInt, TUInt> equalsOpTmpl(TUInt a, TInt b)\n-{\n-    return a == static_cast<TUInt>(b) && b >= 0 && a <= static_cast<TUInt>(std::numeric_limits<TInt>::max());\n-}\n-\n-\n-// Case 2b. Are params IntXX and UIntYY and sizeof(IntXX) > sizeof(UIntYY) (in such case will cast UIntYY to IntXX and compare)\n-template <typename TInt, typename TUInt>\n-constexpr bool is_gt_int_vs_uint = is_any_int_vs_uint<TInt, TUInt> && (sizeof(TInt) > sizeof(TUInt));\n-\n-template <typename TInt, typename TUInt>\n-using bool_if_gt_int_vs_uint = std::enable_if_t<is_gt_int_vs_uint<TInt, TUInt>, bool>;\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TInt a, TUInt b)\n-{\n-    return static_cast<TInt>(a) > static_cast<TInt>(b);\n-}\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TUInt a, TInt b)\n-{\n-    using CastA = std::conditional_t<is_big_int_v<TInt> && std::is_same_v<TUInt, DB::UInt128>, DB::UInt256, TInt>;\n-\n-    return static_cast<CastA>(a) > b;\n-}\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TInt a, TUInt b)\n-{\n-    return static_cast<TInt>(a) == static_cast<TInt>(b);\n-}\n-\n-template <typename TInt, typename TUInt>\n-inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TUInt a, TInt b)\n-{\n-    return static_cast<TInt>(a) == static_cast<TInt>(b);\n-}\n-\n-\n-// Case 3a. Comparison via conversion to double.\n-template <typename TAInt, typename TAFloat>\n-using bool_if_double_can_be_used\n-    = std::enable_if_t<is_integer_v<TAInt> && (sizeof(TAInt) <= 4) && std::is_floating_point_v<TAFloat>, bool>;\n-\n-template <typename TAInt, typename TAFloat>\n-inline bool_if_double_can_be_used<TAInt, TAFloat> greaterOpTmpl(TAInt a, TAFloat b)\n-{\n-    return static_cast<double>(a) > static_cast<double>(b);\n-}\n-\n-template <typename TAInt, typename TAFloat>\n-inline bool_if_double_can_be_used<TAInt, TAFloat> greaterOpTmpl(TAFloat a, TAInt b)\n-{\n-    return static_cast<double>(a) > static_cast<double>(b);\n-}\n-\n-template <typename TAInt, typename TAFloat>\n-inline bool_if_double_can_be_used<TAInt, TAFloat> equalsOpTmpl(TAInt a, TAFloat b)\n-{\n-    return static_cast<double>(a) == static_cast<double>(b);\n-}\n-\n-template <typename TAInt, typename TAFloat>\n-inline bool_if_double_can_be_used<TAInt, TAFloat> equalsOpTmpl(TAFloat a, TAInt b)\n-{\n-    return static_cast<double>(a) == static_cast<double>(b);\n-}\n-\n-// Big integers vs Float (not equal in any case for now, until big floats are introduced?)\n-template <typename TABigInt, typename TAFloat>\n-constexpr bool if_big_int_vs_float = (is_big_int_v<TABigInt> && std::is_floating_point_v<TAFloat>);\n-\n-template <typename TABigInt, typename TAFloat>\n-using bool_if_big_int_vs_float = std::enable_if_t<if_big_int_vs_float<TABigInt, TAFloat>, bool>;\n-\n-template <typename TABigInt, typename TAFloat>\n-inline bool_if_big_int_vs_float<TABigInt, TAFloat> greaterOpTmpl(TAFloat, TABigInt)\n-{\n-    return false;\n-}\n-\n-template <typename TABigInt, typename TAFloat>\n-inline bool_if_big_int_vs_float<TABigInt, TAFloat> greaterOpTmpl(TABigInt, TAFloat)\n-{\n-    return false;\n-}\n-\n-template <typename TABigInt, typename TAFloat>\n-inline bool_if_big_int_vs_float<TABigInt, TAFloat> equalsOpTmpl(TAFloat, TABigInt)\n-{\n-    return false;\n-}\n-\n-template <typename TABigInt, typename TAFloat>\n-inline bool_if_big_int_vs_float<TABigInt, TAFloat> equalsOpTmpl(TABigInt, TAFloat)\n-{\n-    return false;\n-}\n-\n-/* Final implementations */\n+using namespace DB;\n \n \n template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> greaterOp(A a, B b)\n+bool lessOp(A a, B b)\n {\n-    return greaterOpTmpl(a, b);\n-}\n-\n-template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> greaterOp(A a, B b)\n-{\n-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;\n-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;\n-\n-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;\n-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n-\n-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return static_cast<CastA>(a) > static_cast<CastB>(b);\n-    else\n-        return a > b;\n-}\n-\n-// Case 3b. 64-bit integers vs floats comparison.\n-// See hint at https://github.com/JuliaLang/julia/issues/257 (but it doesn't work properly for -2**63)\n-\n-constexpr DB::Int64 MAX_INT64_WITH_EXACT_FLOAT64_REPR = 9007199254740992LL; // 2^53\n-\n-template <>\n-inline bool greaterOp<DB::Float64, DB::Int64>(DB::Float64 f, DB::Int64 i)\n-{\n-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)\n-        return f > static_cast<DB::Float64>(i);\n-\n-    return (f >= static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::max())) // rhs is 2**63 (not 2^63 - 1)\n-            || (f > static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::min()) && static_cast<DB::Int64>(f) > i);\n-}\n-\n-template <>\n-inline bool greaterOp<DB::Int64, DB::Float64>(DB::Int64 i, DB::Float64 f)\n-{\n-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)\n-        return f < static_cast<DB::Float64>(i);\n-\n-    return (f < static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::min()))\n-            || (f < static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::max()) && i > static_cast<DB::Int64>(f));\n-}\n-\n-template <>\n-inline bool greaterOp<DB::Float64, DB::UInt64>(DB::Float64 f, DB::UInt64 u)\n-{\n-    if (u <= static_cast<DB::UInt64>(MAX_INT64_WITH_EXACT_FLOAT64_REPR))\n-        return f > static_cast<DB::Float64>(u);\n+    if constexpr (std::is_same_v<A, B>)\n+        return a < b;\n \n-    return (f >= static_cast<DB::Float64>(std::numeric_limits<DB::UInt64>::max()))\n-            || (f >= 0 && static_cast<DB::UInt64>(f) > u);\n-}\n+    /// float vs float\n+    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)\n+        return a < b;\n \n-template <>\n-inline bool greaterOp<DB::UInt64, DB::Float64>(DB::UInt64 u, DB::Float64 f)\n-{\n-    if (u <= static_cast<DB::UInt64>(MAX_INT64_WITH_EXACT_FLOAT64_REPR))\n-        return static_cast<DB::Float64>(u) > f;\n+    /// anything vs NaN\n+    if (isNaN(a) || isNaN(b))\n+        return false;\n \n-    return (f < 0)\n-            || (f < static_cast<DB::Float64>(std::numeric_limits<DB::UInt64>::max()) && u > static_cast<UInt64>(f));\n-}\n+    /// int vs int\n+    if constexpr (is_integer_v<A> && is_integer_v<B>)\n+    {\n+        /// same signedness\n+        if constexpr (is_signed_v<A> == is_signed_v<B>)\n+            return a < b;\n \n-// Case 3b for float32\n-template <>\n-inline bool greaterOp<DB::Float32, DB::Int64>(DB::Float32 f, DB::Int64 i)\n-{\n-    return greaterOp(static_cast<DB::Float64>(f), i);\n-}\n+        /// different signedness\n \n-template <>\n-inline bool greaterOp<DB::Int64, DB::Float32>(DB::Int64 i, DB::Float32 f)\n-{\n-    return greaterOp(i, static_cast<DB::Float64>(f));\n-}\n+        if constexpr (is_signed_v<A> && !is_signed_v<B>)\n+            return a < 0 || static_cast<make_unsigned_t<A>>(a) < b;\n \n-template <>\n-inline bool greaterOp<DB::Float32, DB::UInt64>(DB::Float32 f, DB::UInt64 u)\n-{\n-    return greaterOp(static_cast<DB::Float64>(f), u);\n-}\n+        if constexpr (!is_signed_v<A> && is_signed_v<B>)\n+            return b >= 0 && a < static_cast<make_unsigned_t<B>>(b);\n+    }\n \n-template <>\n-inline bool greaterOp<DB::UInt64, DB::Float32>(DB::UInt64 u, DB::Float32 f)\n-{\n-    return greaterOp(u, static_cast<DB::Float64>(f));\n-}\n+    /// int vs float\n+    if constexpr (is_integer_v<A> && std::is_floating_point_v<B>)\n+    {\n+        if constexpr (sizeof(A) <= 4)\n+            return static_cast<double>(a) < static_cast<double>(b);\n \n-template <>\n-inline bool greaterOp<DB::Float64, DB::UInt128>(DB::Float64 f, DB::UInt128 u)\n-{\n-    /// TODO: This is wrong.\n-    return u.low == 0 && greaterOp(f, u.high);\n-}\n+        return DecomposedFloat<B>(b).greater(a);\n+    }\n \n-template <>\n-inline bool greaterOp<DB::UInt128, DB::Float64>(DB::UInt128 u, DB::Float64 f)\n-{\n-    /// TODO: This is wrong.\n-    return u.low != 0 || greaterOp(u.high, f);\n-}\n+    if constexpr (std::is_floating_point_v<A> && is_integer_v<B>)\n+    {\n+        if constexpr (sizeof(B) <= 4)\n+            return static_cast<double>(a) < static_cast<double>(b);\n \n-template <>\n-inline bool greaterOp<DB::Float32, DB::UInt128>(DB::Float32 f, DB::UInt128 u)\n-{\n-    return greaterOp(static_cast<DB::Float64>(f), u);\n-}\n+        return DecomposedFloat<A>(a).less(b);\n+    }\n \n-template <>\n-inline bool greaterOp<DB::UInt128, DB::Float32>(DB::UInt128 u, DB::Float32 f)\n-{\n-    return greaterOp(u, static_cast<DB::Float64>(f));\n+    static_assert(is_integer_v<A> || std::is_floating_point_v<A>);\n+    static_assert(is_integer_v<B> || std::is_floating_point_v<B>);\n+    __builtin_unreachable();\n }\n \n template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> equalsOp(A a, B b)\n+bool greaterOp(A a, B b)\n {\n-    return equalsOpTmpl(a, b);\n+    return lessOp(b, a);\n }\n \n template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> equalsOp(A a, B b)\n-{\n-    using LargestType = std::conditional_t<(sizeof(A) > sizeof(B)) || ((sizeof(A) == sizeof(B)) && !std::is_same_v<A, DB::UInt128>), A, B>;\n-\n-    return static_cast<LargestType>(a) == static_cast<LargestType>(b);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float64, DB::UInt64>(DB::Float64 f, DB::UInt64 u)\n-{\n-    /// Maximum exactly representable integer.\n-    return u <= (1ULL << std::numeric_limits<DB::Float64>::digits)\n-        && f == static_cast<DB::Float64>(u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::UInt64, DB::Float64>(DB::UInt64 u, DB::Float64 f)\n-{\n-    return equalsOp(f, u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float64, DB::Int64>(DB::Float64 f, DB::Int64 u)\n-{\n-    return u <= (1LL << std::numeric_limits<DB::Float64>::digits)\n-        && u >= -(1LL << std::numeric_limits<DB::Float64>::digits)\n-        && f == static_cast<DB::Float64>(u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Int64, DB::Float64>(DB::Int64 u, DB::Float64 f)\n-{\n-    return equalsOp(f, u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float32, DB::UInt64>(DB::Float32 f, DB::UInt64 u)\n-{\n-    return u <= (1ULL << std::numeric_limits<DB::Float32>::digits)\n-        && f == static_cast<DB::Float32>(u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::UInt64, DB::Float32>(DB::UInt64 u, DB::Float32 f)\n-{\n-    return equalsOp(f, u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float32, DB::Int64>(DB::Float32 f, DB::Int64 u)\n-{\n-    return u <= (1LL << std::numeric_limits<DB::Float32>::digits)\n-        && u >= -(1LL << std::numeric_limits<DB::Float32>::digits)\n-        && f == static_cast<DB::Float32>(u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Int64, DB::Float32>(DB::Int64 u, DB::Float32 f)\n-{\n-    return equalsOp(f, u);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::UInt128, DB::Float64>(DB::UInt128 u, DB::Float64 f)\n-{\n-    /// TODO: This is wrong.\n-    return u.low == 0 && equalsOp(static_cast<UInt64>(u.high), f);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::UInt128, DB::Float32>(DB::UInt128 u, DB::Float32 f)\n-{\n-    return equalsOp(u, static_cast<DB::Float64>(f));\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float64, DB::UInt128>(DB::Float64 f, DB::UInt128 u)\n-{\n-    return equalsOp(u, f);\n-}\n-\n-template <>\n-inline bool equalsOp<DB::Float32, DB::UInt128>(DB::Float32 f, DB::UInt128 u)\n+bool greaterOrEqualsOp(A a, B b)\n {\n-    return equalsOp(static_cast<DB::Float64>(f), u);\n-}\n-\n-inline bool NO_SANITIZE_UNDEFINED greaterOp(DB::Int128 i, DB::Float64 f)\n-{\n-    static constexpr Int128 min_int128 = minInt128();\n-    static constexpr Int128 max_int128 = maxInt128();\n-\n-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)\n-        return static_cast<DB::Float64>(i) > f;\n-\n-    return (f < static_cast<DB::Float64>(min_int128))\n-        || (f < static_cast<DB::Float64>(max_int128) && i > static_cast<DB::Int128>(f));\n-}\n-\n-inline bool NO_SANITIZE_UNDEFINED greaterOp(DB::Float64 f, DB::Int128 i)\n-{\n-    static constexpr Int128 min_int128 = minInt128();\n-    static constexpr Int128 max_int128 = maxInt128();\n-\n-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)\n-        return f > static_cast<DB::Float64>(i);\n+    if (isNaN(a) || isNaN(b))\n+        return false;\n \n-    return (f >= static_cast<DB::Float64>(max_int128))\n-        || (f > static_cast<DB::Float64>(min_int128) && static_cast<DB::Int128>(f) > i);\n+    return !lessOp(a, b);\n }\n \n-inline bool greaterOp(DB::Int128 i, DB::Float32 f) { return greaterOp(i, static_cast<DB::Float64>(f)); }\n-inline bool greaterOp(DB::Float32 f, DB::Int128 i) { return greaterOp(static_cast<DB::Float64>(f), i); }\n-\n-inline bool NO_SANITIZE_UNDEFINED equalsOp(DB::Int128 i, DB::Float64 f) { return i == static_cast<DB::Int128>(f) && static_cast<DB::Float64>(i) == f; }\n-inline bool NO_SANITIZE_UNDEFINED equalsOp(DB::Int128 i, DB::Float32 f) { return i == static_cast<DB::Int128>(f) && static_cast<DB::Float32>(i) == f; }\n-inline bool equalsOp(DB::Float64 f, DB::Int128 i) { return equalsOp(i, f); }\n-inline bool equalsOp(DB::Float32 f, DB::Int128 i) { return equalsOp(i, f); }\n-\n template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> notEqualsOp(A a, B b)\n+bool lessOrEqualsOp(A a, B b)\n {\n-    return !equalsOp(a, b);\n+    if (isNaN(a) || isNaN(b))\n+        return false;\n+\n+    return !lessOp(b, a);\n }\n \n template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> notEqualsOp(A a, B b)\n+bool equalsOp(A a, B b)\n {\n-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;\n-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;\n+    if constexpr (std::is_same_v<A, B>)\n+        return a == b;\n \n-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;\n-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n+    /// float vs float\n+    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)\n+        return a == b;\n \n-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return static_cast<CastA>(a) != static_cast<CastB>(b);\n-    else\n-        return a != b;\n-}\n+    /// anything vs NaN\n+    if (isNaN(a) || isNaN(b))\n+        return false;\n \n+    /// int vs int\n+    if constexpr (is_integer_v<A> && is_integer_v<B>)\n+    {\n+        /// same signedness\n+        if constexpr (is_signed_v<A> == is_signed_v<B>)\n+            return a == b;\n \n-template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> lessOp(A a, B b)\n-{\n-    return greaterOp(b, a);\n-}\n+        /// different signedness\n \n-template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> lessOp(A a, B b)\n-{\n-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;\n-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;\n+        if constexpr (is_signed_v<A> && !is_signed_v<B>)\n+            return a >= 0 && static_cast<make_unsigned_t<A>>(a) == b;\n \n-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;\n-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n-\n-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return static_cast<CastA>(a) < static_cast<CastB>(b);\n-    else\n-        return a < b;\n-}\n+        if constexpr (!is_signed_v<A> && is_signed_v<B>)\n+            return b >= 0 && a == static_cast<make_unsigned_t<B>>(b);\n+    }\n \n+    /// int vs float\n+    if constexpr (is_integer_v<A> && std::is_floating_point_v<B>)\n+    {\n+        if constexpr (sizeof(A) <= 4)\n+            return static_cast<double>(a) == static_cast<double>(b);\n \n-template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> lessOrEqualsOp(A a, B b)\n-{\n-    if (isNaN(a) || isNaN(b))\n-        return false;\n-    return !greaterOp(a, b);\n-}\n+        return DecomposedFloat<B>(b).equals(a);\n+    }\n \n-template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> lessOrEqualsOp(A a, B b)\n-{\n-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;\n-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;\n+    if constexpr (std::is_floating_point_v<A> && is_integer_v<B>)\n+    {\n+        if constexpr (sizeof(B) <= 4)\n+            return static_cast<double>(a) == static_cast<double>(b);\n \n-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;\n-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n+        return DecomposedFloat<A>(a).equals(b);\n+    }\n \n-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return static_cast<CastA>(a) <= static_cast<CastB>(b);\n-    else\n-        return a <= b;\n+    /// e.g comparing UUID with integer.\n+    return false;\n }\n \n-\n template <typename A, typename B>\n-inline bool_if_not_safe_conversion<A, B> greaterOrEqualsOp(A a, B b)\n+bool notEqualsOp(A a, B b)\n {\n-    if (isNaN(a) || isNaN(b))\n-        return false;\n-    return !greaterOp(b, a);\n+    return !equalsOp(a, b);\n }\n \n-template <typename A, typename B>\n-inline bool_if_safe_conversion<A, B> greaterOrEqualsOp(A a, B b)\n-{\n-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;\n-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;\n-\n-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;\n-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;\n-\n-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n-        return static_cast<CastA>(a) >= static_cast<CastB>(b);\n-    else\n-        return a >= b;\n-}\n \n /// Converts numeric to an equal numeric of other type.\n template <typename From, typename To>\n@@ -547,8 +185,8 @@ inline bool NO_SANITIZE_UNDEFINED convertNumeric(From value, To & result)\n         }\n     }\n \n-    if (accurate::greaterOp(value, std::numeric_limits<To>::max())\n-        || accurate::greaterOp(std::numeric_limits<To>::lowest(), value))\n+    if (greaterOp(value, std::numeric_limits<To>::max())\n+        || lessOp(value, std::numeric_limits<To>::lowest()))\n     {\n         return false;\n     }\ndiff --git a/src/Core/BaseSettings.h b/src/Core/BaseSettings.h\nindex b193fdd4c933..3b6cc61d1ebc 100644\n--- a/src/Core/BaseSettings.h\n+++ b/src/Core/BaseSettings.h\n@@ -2,7 +2,6 @@\n \n #include <Core/SettingsFields.h>\n #include <Common/SettingsChanges.h>\n-#include <Common/FieldVisitors.h>\n #include <ext/range.h>\n #include <boost/blank.hpp>\n #include <unordered_map>\ndiff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h\nindex 486c2c1f8f47..5b017cd46348 100644\n--- a/src/Core/DecimalComparison.h\n+++ b/src/Core/DecimalComparison.h\n@@ -36,10 +36,13 @@ inline bool allowDecimalComparison(const DataTypePtr & left_type, const DataType\n     return false;\n }\n \n-template <size_t > struct ConstructDecInt { using Type = Int32; };\n+template <size_t> struct ConstructDecInt;\n+template <> struct ConstructDecInt<1> { using Type = Int32; };\n+template <> struct ConstructDecInt<2> { using Type = Int32; };\n+template <> struct ConstructDecInt<4> { using Type = Int32; };\n template <> struct ConstructDecInt<8> { using Type = Int64; };\n template <> struct ConstructDecInt<16> { using Type = Int128; };\n-template <> struct ConstructDecInt<48> { using Type = Int256; };\n+template <> struct ConstructDecInt<32> { using Type = Int256; };\n \n template <typename T, typename U>\n struct DecCompareInt\n@@ -249,7 +252,7 @@ class DecimalComparison\n                 overflow |= common::mulOverflow(y, scale, y);\n \n             if (overflow)\n-                throw Exception(\"Can't compare\", ErrorCodes::DECIMAL_OVERFLOW);\n+                throw Exception(\"Can't compare decimal number due to overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n         }\n         else\n         {\ndiff --git a/src/Core/DecimalFunctions.h b/src/Core/DecimalFunctions.h\nindex 2131a6e3c33e..0e3992100882 100644\n--- a/src/Core/DecimalFunctions.h\n+++ b/src/Core/DecimalFunctions.h\n@@ -276,9 +276,7 @@ template <typename To, typename DecimalType>\n To convertTo(const DecimalType & decimal, size_t scale)\n {\n     To result;\n-\n     convertToImpl<To, DecimalType, void>(decimal, scale, result);\n-\n     return result;\n }\n \ndiff --git a/src/Core/Field.cpp b/src/Core/Field.cpp\nindex 8aa79b0bbe11..9dec8563d36c 100644\n--- a/src/Core/Field.cpp\n+++ b/src/Core/Field.cpp\n@@ -238,6 +238,13 @@ Field Field::restoreFromDump(const std::string_view & dump_)\n         return value;\n     }\n \n+    prefix = std::string_view{\"UInt128_\"};\n+    if (dump.starts_with(prefix))\n+    {\n+        UInt128 value = parseFromString<UInt128>(dump.substr(prefix.length()));\n+        return value;\n+    }\n+\n     prefix = std::string_view{\"Int256_\"};\n     if (dump.starts_with(prefix))\n     {\n@@ -295,15 +302,6 @@ Field Field::restoreFromDump(const std::string_view & dump_)\n         return decimal;\n     }\n \n-    prefix = std::string_view{\"UUID_\"};\n-    if (dump.starts_with(prefix))\n-    {\n-        UUID uuid;\n-        ReadBufferFromString buf{dump.substr(prefix.length())};\n-        readQuoted(uuid, buf);\n-        return uuid;\n-    }\n-\n     if (dump.starts_with(\"\\'\"))\n     {\n         String str;\n@@ -410,45 +408,45 @@ Field Field::restoreFromDump(const std::string_view & dump_)\n \n \n template <typename T>\n-static bool decEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)\n+bool decimalEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)\n {\n     using Comparator = DecimalComparison<T, T, EqualsOp>;\n     return Comparator::compare(x, y, x_scale, y_scale);\n }\n \n template <typename T>\n-static bool decLess(T x, T y, UInt32 x_scale, UInt32 y_scale)\n+bool decimalLess(T x, T y, UInt32 x_scale, UInt32 y_scale)\n {\n     using Comparator = DecimalComparison<T, T, LessOp>;\n     return Comparator::compare(x, y, x_scale, y_scale);\n }\n \n template <typename T>\n-static bool decLessOrEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)\n+bool decimalLessOrEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)\n {\n     using Comparator = DecimalComparison<T, T, LessOrEqualsOp>;\n     return Comparator::compare(x, y, x_scale, y_scale);\n }\n \n-template <> bool decimalEqual(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n-template <> bool decimalLess(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n-template <> bool decimalLessOrEqual(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n \n-template <> bool decimalEqual(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n-template <> bool decimalLess(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n-template <> bool decimalLessOrEqual(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n+template bool decimalEqual<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalEqual<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalEqual<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalEqual<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalEqual<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);\n \n-template <> bool decimalEqual(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n-template <> bool decimalLess(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n-template <> bool decimalLessOrEqual(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n+template bool decimalLess<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLess<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLess<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLess<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLess<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);\n \n-template <> bool decimalEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n-template <> bool decimalLess(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n-template <> bool decimalLessOrEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n+template bool decimalLessOrEqual<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLessOrEqual<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLessOrEqual<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLessOrEqual<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);\n+template bool decimalLessOrEqual<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);\n \n-template <> bool decimalEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n-template <> bool decimalLess(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n-template <> bool decimalLessOrEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n \n inline void writeText(const Null &, WriteBuffer & buf)\n {\ndiff --git a/src/Core/Field.h b/src/Core/Field.h\nindex 2c3ca1310e4b..fb9f811ddf3d 100644\n--- a/src/Core/Field.h\n+++ b/src/Core/Field.h\n@@ -7,7 +7,6 @@\n #include <functional>\n \n #include <Common/Exception.h>\n-#include <Common/UInt128.h>\n #include <Common/AllocatorWithMemoryTracking.h>\n #include <Core/Types.h>\n #include <Core/Defines.h>\n@@ -177,8 +176,7 @@ template <> struct NearestFieldTypeImpl<UInt16> { using Type = UInt64; };\n template <> struct NearestFieldTypeImpl<UInt32> { using Type = UInt64; };\n \n template <> struct NearestFieldTypeImpl<DayNum> { using Type = UInt64; };\n-template <> struct NearestFieldTypeImpl<UInt128> { using Type = UInt128; };\n-template <> struct NearestFieldTypeImpl<UUID> { using Type = UInt128; };\n+template <> struct NearestFieldTypeImpl<UUID> { using Type = UUID; };\n template <> struct NearestFieldTypeImpl<Int16> { using Type = Int64; };\n template <> struct NearestFieldTypeImpl<Int32> { using Type = Int64; };\n \n@@ -191,8 +189,9 @@ template <> struct NearestFieldTypeImpl<unsigned long long> { using Type = UInt6\n \n template <> struct NearestFieldTypeImpl<UInt256> { using Type = UInt256; };\n template <> struct NearestFieldTypeImpl<Int256> { using Type = Int256; };\n-\n+template <> struct NearestFieldTypeImpl<UInt128> { using Type = UInt128; };\n template <> struct NearestFieldTypeImpl<Int128> { using Type = Int128; };\n+\n template <> struct NearestFieldTypeImpl<Decimal32> { using Type = DecimalField<Decimal32>; };\n template <> struct NearestFieldTypeImpl<Decimal64> { using Type = DecimalField<Decimal64>; };\n template <> struct NearestFieldTypeImpl<Decimal128> { using Type = DecimalField<Decimal128>; };\n@@ -235,7 +234,7 @@ struct NearestFieldTypeImpl<T, std::enable_if_t<std::is_enum_v<T>>>\n   *  but somewhat more efficient, and simpler.\n   *\n   * Used to represent a single value of one of several types in memory.\n-  * Warning! Prefer to use chunks of columns instead of single values. See Column.h\n+  * Warning! Prefer to use chunks of columns instead of single values. See IColumn.h\n   */\n class Field\n {\n@@ -252,8 +251,6 @@ class Field\n             UInt128 = 4,\n             Int128  = 5,\n \n-            /// Non-POD types.\n-\n             String  = 16,\n             Array   = 17,\n             Tuple   = 18,\n@@ -265,10 +262,9 @@ class Field\n             UInt256 = 24,\n             Int256  = 25,\n             Map = 26,\n+            UUID = 27,\n         };\n \n-        static const int MIN_NON_POD = 16;\n-\n         static const char * toString(Which which)\n         {\n             switch (which)\n@@ -276,8 +272,11 @@ class Field\n                 case Null:    return \"Null\";\n                 case UInt64:  return \"UInt64\";\n                 case UInt128: return \"UInt128\";\n+                case UInt256: return \"UInt256\";\n                 case Int64:   return \"Int64\";\n                 case Int128:  return \"Int128\";\n+                case Int256:  return \"Int256\";\n+                case UUID:    return \"UUID\";\n                 case Float64: return \"Float64\";\n                 case String:  return \"String\";\n                 case Array:   return \"Array\";\n@@ -288,8 +287,6 @@ class Field\n                 case Decimal128: return \"Decimal128\";\n                 case Decimal256: return \"Decimal256\";\n                 case AggregateFunctionState: return \"AggregateFunctionState\";\n-                case UInt256: return \"UInt256\";\n-                case Int256:  return \"Int256\";\n             }\n \n             throw Exception(\"Bad type of Field\", ErrorCodes::BAD_TYPE_OF_FIELD);\n@@ -303,12 +300,17 @@ class Field\n \n     static bool IsDecimal(Types::Which which)\n     {\n-        return (which >= Types::Decimal32 && which <= Types::Decimal128) || which == Types::Decimal256;\n+        return which == Types::Decimal32\n+            || which == Types::Decimal64\n+            || which == Types::Decimal128\n+            || which == Types::Decimal256;\n     }\n \n     /// Templates to avoid ambiguity.\n     template <typename T, typename Z = void *>\n-    using enable_if_not_field_or_stringlike_t = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Field> && !std::is_same_v<NearestFieldType<std::decay_t<T>>, String>, Z>;\n+    using enable_if_not_field_or_stringlike_t = std::enable_if_t<\n+        !std::is_same_v<std::decay_t<T>, Field>\n+        && !std::is_same_v<NearestFieldType<std::decay_t<T>>, String>, Z>;\n \n     Field() //-V730\n         : which(Types::Null)\n@@ -382,10 +384,10 @@ class Field\n     enable_if_not_field_or_stringlike_t<T, Field> &\n     operator=(T && rhs);\n \n-    Field & operator =(const std::string_view & str);\n-    Field & operator =(const String & str) { return *this = std::string_view{str}; }\n-    Field & operator =(String && str);\n-    Field & operator =(const char * str) { return *this = std::string_view{str}; }\n+    Field & operator= (const std::string_view & str);\n+    Field & operator= (const String & str) { return *this = std::string_view{str}; }\n+    Field & operator= (String && str);\n+    Field & operator= (const char * str) { return *this = std::string_view{str}; }\n \n     ~Field()\n     {\n@@ -454,8 +456,11 @@ class Field\n             case Types::Null:    return false;\n             case Types::UInt64:  return get<UInt64>()  < rhs.get<UInt64>();\n             case Types::UInt128: return get<UInt128>() < rhs.get<UInt128>();\n+            case Types::UInt256: return get<UInt256>() < rhs.get<UInt256>();\n             case Types::Int64:   return get<Int64>()   < rhs.get<Int64>();\n             case Types::Int128:  return get<Int128>()  < rhs.get<Int128>();\n+            case Types::Int256:  return get<Int256>()  < rhs.get<Int256>();\n+            case Types::UUID:    return get<UUID>()    < rhs.get<UUID>();\n             case Types::Float64: return get<Float64>() < rhs.get<Float64>();\n             case Types::String:  return get<String>()  < rhs.get<String>();\n             case Types::Array:   return get<Array>()   < rhs.get<Array>();\n@@ -466,8 +471,6 @@ class Field\n             case Types::Decimal128: return get<DecimalField<Decimal128>>() < rhs.get<DecimalField<Decimal128>>();\n             case Types::Decimal256: return get<DecimalField<Decimal256>>() < rhs.get<DecimalField<Decimal256>>();\n             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() < rhs.get<AggregateFunctionStateData>();\n-            case Types::UInt256: return get<UInt256>() < rhs.get<UInt256>();\n-            case Types::Int256: return get<Int256>() < rhs.get<Int256>();\n         }\n \n         throw Exception(\"Bad type of Field\", ErrorCodes::BAD_TYPE_OF_FIELD);\n@@ -490,8 +493,11 @@ class Field\n             case Types::Null:    return true;\n             case Types::UInt64:  return get<UInt64>()  <= rhs.get<UInt64>();\n             case Types::UInt128: return get<UInt128>() <= rhs.get<UInt128>();\n+            case Types::UInt256: return get<UInt256>() <= rhs.get<UInt256>();\n             case Types::Int64:   return get<Int64>()   <= rhs.get<Int64>();\n             case Types::Int128:  return get<Int128>()  <= rhs.get<Int128>();\n+            case Types::Int256:  return get<Int256>()  <= rhs.get<Int256>();\n+            case Types::UUID:    return get<UUID>().toUnderType() <= rhs.get<UUID>().toUnderType();\n             case Types::Float64: return get<Float64>() <= rhs.get<Float64>();\n             case Types::String:  return get<String>()  <= rhs.get<String>();\n             case Types::Array:   return get<Array>()   <= rhs.get<Array>();\n@@ -502,8 +508,6 @@ class Field\n             case Types::Decimal128: return get<DecimalField<Decimal128>>() <= rhs.get<DecimalField<Decimal128>>();\n             case Types::Decimal256: return get<DecimalField<Decimal256>>() <= rhs.get<DecimalField<Decimal256>>();\n             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() <= rhs.get<AggregateFunctionStateData>();\n-            case Types::UInt256: return get<UInt256>() <= rhs.get<UInt256>();\n-            case Types::Int256: return get<Int256>() <= rhs.get<Int256>();\n         }\n \n         throw Exception(\"Bad type of Field\", ErrorCodes::BAD_TYPE_OF_FIELD);\n@@ -531,19 +535,20 @@ class Field\n                 // Compare as UInt64 so that NaNs compare as equal.\n                 return reinterpret<UInt64>() == rhs.reinterpret<UInt64>();\n             }\n+            case Types::UUID:    return get<UUID>()    == rhs.get<UUID>();\n             case Types::String:  return get<String>()  == rhs.get<String>();\n             case Types::Array:   return get<Array>()   == rhs.get<Array>();\n             case Types::Tuple:   return get<Tuple>()   == rhs.get<Tuple>();\n             case Types::Map:     return get<Map>()     == rhs.get<Map>();\n             case Types::UInt128: return get<UInt128>() == rhs.get<UInt128>();\n+            case Types::UInt256: return get<UInt256>() == rhs.get<UInt256>();\n             case Types::Int128:  return get<Int128>()  == rhs.get<Int128>();\n+            case Types::Int256:  return get<Int256>()  == rhs.get<Int256>();\n             case Types::Decimal32:  return get<DecimalField<Decimal32>>()  == rhs.get<DecimalField<Decimal32>>();\n             case Types::Decimal64:  return get<DecimalField<Decimal64>>()  == rhs.get<DecimalField<Decimal64>>();\n             case Types::Decimal128: return get<DecimalField<Decimal128>>() == rhs.get<DecimalField<Decimal128>>();\n             case Types::Decimal256: return get<DecimalField<Decimal256>>() == rhs.get<DecimalField<Decimal256>>();\n             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() == rhs.get<AggregateFunctionStateData>();\n-            case Types::UInt256: return get<UInt256>() == rhs.get<UInt256>();\n-            case Types::Int256:  return get<Int256>()  == rhs.get<Int256>();\n         }\n \n         throw Exception(\"Bad type of Field\", ErrorCodes::BAD_TYPE_OF_FIELD);\n@@ -569,7 +574,11 @@ class Field\n #endif\n             case Types::UInt64:  return f(field.template get<UInt64>());\n             case Types::UInt128: return f(field.template get<UInt128>());\n+            case Types::UInt256: return f(field.template get<UInt256>());\n             case Types::Int64:   return f(field.template get<Int64>());\n+            case Types::Int128:  return f(field.template get<Int128>());\n+            case Types::Int256:  return f(field.template get<Int256>());\n+            case Types::UUID:    return f(field.template get<UUID>());\n             case Types::Float64: return f(field.template get<Float64>());\n             case Types::String:  return f(field.template get<String>());\n             case Types::Array:   return f(field.template get<Array>());\n@@ -580,19 +589,12 @@ class Field\n             case Types::Decimal128: return f(field.template get<DecimalField<Decimal128>>());\n             case Types::Decimal256: return f(field.template get<DecimalField<Decimal256>>());\n             case Types::AggregateFunctionState: return f(field.template get<AggregateFunctionStateData>());\n-            case Types::Int128: return f(field.template get<Int128>());\n-            case Types::UInt256: return f(field.template get<UInt256>());\n-            case Types::Int256: return f(field.template get<Int256>());\n #if !defined(__clang__)\n #pragma GCC diagnostic pop\n #endif\n         }\n \n-        // GCC 9 complains that control reaches the end, despite that we handle\n-        // all the cases above (maybe because of throw?). Return something to\n-        // silence it.\n-        Null null{};\n-        return f(null);\n+        __builtin_unreachable();\n     }\n \n     String dump() const;\n@@ -600,10 +602,9 @@ class Field\n \n private:\n     std::aligned_union_t<DBMS_MIN_FIELD_SIZE - sizeof(Types::Which),\n-        Null, UInt64, UInt128, Int64, Int128, Float64, String, Array, Tuple, Map,\n+        Null, UInt64, UInt128, UInt256, Int64, Int128, Int256, UUID, Float64, String, Array, Tuple, Map,\n         DecimalField<Decimal32>, DecimalField<Decimal64>, DecimalField<Decimal128>, DecimalField<Decimal256>,\n-        AggregateFunctionStateData,\n-        UInt256, Int256\n+        AggregateFunctionStateData\n         > storage;\n \n     Types::Which which;\n@@ -685,9 +686,6 @@ class Field\n \n     ALWAYS_INLINE void destroy()\n     {\n-        if (which < Types::MIN_NON_POD)\n-            return;\n-\n         switch (which)\n         {\n             case Types::String:\n@@ -726,8 +724,11 @@ class Field\n template <> struct Field::TypeToEnum<Null>    { static const Types::Which value = Types::Null; };\n template <> struct Field::TypeToEnum<UInt64>  { static const Types::Which value = Types::UInt64; };\n template <> struct Field::TypeToEnum<UInt128> { static const Types::Which value = Types::UInt128; };\n+template <> struct Field::TypeToEnum<UInt256> { static const Types::Which value = Types::UInt256; };\n template <> struct Field::TypeToEnum<Int64>   { static const Types::Which value = Types::Int64; };\n template <> struct Field::TypeToEnum<Int128>  { static const Types::Which value = Types::Int128; };\n+template <> struct Field::TypeToEnum<Int256>  { static const Types::Which value = Types::Int256; };\n+template <> struct Field::TypeToEnum<UUID>    { static const Types::Which value = Types::UUID; };\n template <> struct Field::TypeToEnum<Float64> { static const Types::Which value = Types::Float64; };\n template <> struct Field::TypeToEnum<String>  { static const Types::Which value = Types::String; };\n template <> struct Field::TypeToEnum<Array>   { static const Types::Which value = Types::Array; };\n@@ -739,14 +740,15 @@ template <> struct Field::TypeToEnum<DecimalField<Decimal128>>{ static const Typ\n template <> struct Field::TypeToEnum<DecimalField<Decimal256>>{ static const Types::Which value = Types::Decimal256; };\n template <> struct Field::TypeToEnum<DecimalField<DateTime64>>{ static const Types::Which value = Types::Decimal64; };\n template <> struct Field::TypeToEnum<AggregateFunctionStateData>{ static const Types::Which value = Types::AggregateFunctionState; };\n-template <> struct Field::TypeToEnum<UInt256> { static const Types::Which value = Types::UInt256; };\n-template <> struct Field::TypeToEnum<Int256> { static const Types::Which value = Types::Int256; };\n \n template <> struct Field::EnumToType<Field::Types::Null>    { using Type = Null; };\n template <> struct Field::EnumToType<Field::Types::UInt64>  { using Type = UInt64; };\n template <> struct Field::EnumToType<Field::Types::UInt128> { using Type = UInt128; };\n+template <> struct Field::EnumToType<Field::Types::UInt256> { using Type = UInt256; };\n template <> struct Field::EnumToType<Field::Types::Int64>   { using Type = Int64; };\n template <> struct Field::EnumToType<Field::Types::Int128>  { using Type = Int128; };\n+template <> struct Field::EnumToType<Field::Types::Int256>  { using Type = Int256; };\n+template <> struct Field::EnumToType<Field::Types::UUID>    { using Type = UUID; };\n template <> struct Field::EnumToType<Field::Types::Float64> { using Type = Float64; };\n template <> struct Field::EnumToType<Field::Types::String>  { using Type = String; };\n template <> struct Field::EnumToType<Field::Types::Array>   { using Type = Array; };\n@@ -757,10 +759,8 @@ template <> struct Field::EnumToType<Field::Types::Decimal64> { using Type = Dec\n template <> struct Field::EnumToType<Field::Types::Decimal128> { using Type = DecimalField<Decimal128>; };\n template <> struct Field::EnumToType<Field::Types::Decimal256> { using Type = DecimalField<Decimal256>; };\n template <> struct Field::EnumToType<Field::Types::AggregateFunctionState> { using Type = DecimalField<AggregateFunctionStateData>; };\n-template <> struct Field::EnumToType<Field::Types::UInt256> { using Type = UInt256; };\n-template <> struct Field::EnumToType<Field::Types::Int256>  { using Type = Int256; };\n \n-inline constexpr bool isInt64FieldType(Field::Types::Which t)\n+inline constexpr bool isInt64OrUInt64FieldType(Field::Types::Which t)\n {\n     return t == Field::Types::Int64\n         || t == Field::Types::UInt64;\n@@ -782,7 +782,7 @@ NearestFieldType<std::decay_t<T>> & Field::get()\n     // Disregard signedness when converting between int64 types.\n     constexpr Field::Types::Which target = TypeToEnum<StoredType>::value;\n     if (target != which\n-           && (!isInt64FieldType(target) || !isInt64FieldType(which)))\n+           && (!isInt64OrUInt64FieldType(target) || !isInt64OrUInt64FieldType(which)))\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid Field get from type {} to type {}\", Types::toString(which), Types::toString(target));\n #endif\n \n@@ -834,11 +834,11 @@ T safeGet(Field & field)\n     return field.template safeGet<T>();\n }\n \n+template <> inline constexpr const char * TypeName<Array> = \"Array\";\n+template <> inline constexpr const char * TypeName<Tuple> = \"Tuple\";\n+template <> inline constexpr const char * TypeName<Map> = \"Map\";\n+template <> inline constexpr const char * TypeName<AggregateFunctionStateData> = \"AggregateFunctionState\";\n \n-template <> struct TypeName<Array> { static std::string get() { return \"Array\"; } };\n-template <> struct TypeName<Tuple> { static std::string get() { return \"Tuple\"; } };\n-template <> struct TypeName<Map>   { static std::string get() { return \"Map\"; } };\n-template <> struct TypeName<AggregateFunctionStateData> { static std::string get() { return \"AggregateFunctionState\"; } };\n \n template <typename T>\n decltype(auto) castToNearestFieldType(T && x)\n@@ -965,7 +965,7 @@ struct fmt::formatter<DB::Field>\n \n         /// Only support {}.\n         if (it != end && *it != '}')\n-            throw format_error(\"invalid format\");\n+            throw format_error(\"Invalid format\");\n \n         return it;\n     }\ndiff --git a/src/Core/MySQL/MySQLGtid.cpp b/src/Core/MySQL/MySQLGtid.cpp\nindex 13dc6e0fd699..a441bccb0765 100644\n--- a/src/Core/MySQL/MySQLGtid.cpp\n+++ b/src/Core/MySQL/MySQLGtid.cpp\n@@ -1,6 +1,7 @@\n #include \"MySQLGtid.h\"\n-\n #include <boost/algorithm/string.hpp>\n+#include <IO/ReadHelpers.h>\n+\n \n namespace DB\n {\n@@ -38,7 +39,7 @@ void GTIDSets::parse(const String gtid_format)\n         boost::split(server_ids, gset, [](char c) { return c == ':'; });\n \n         GTIDSet set;\n-        set.uuid = stringToUUID(server_ids[0]);\n+        set.uuid = DB::parse<UUID>(server_ids[0]);\n \n         for (size_t k = 1; k < server_ids.size(); k++)\n         {\n@@ -174,8 +175,8 @@ String GTIDSets::toPayload() const\n     for (const auto & set : sets)\n     {\n         // MySQL UUID is big-endian.\n-        writeBinaryBigEndian(set.uuid.toUnderType().low, buffer);\n-        writeBinaryBigEndian(set.uuid.toUnderType().high, buffer);\n+        writeBinaryBigEndian(set.uuid.toUnderType().items[0], buffer);\n+        writeBinaryBigEndian(set.uuid.toUnderType().items[1], buffer);\n \n         UInt64 intervals_size = set.intervals.size();\n         buffer.write(reinterpret_cast<const char *>(&intervals_size), 8);\ndiff --git a/src/Core/MySQL/MySQLReplication.cpp b/src/Core/MySQL/MySQLReplication.cpp\nindex 402b026736cc..e326d5e5b32f 100644\n--- a/src/Core/MySQL/MySQLReplication.cpp\n+++ b/src/Core/MySQL/MySQLReplication.cpp\n@@ -658,12 +658,13 @@ namespace MySQLReplication\n         payload.readStrict(reinterpret_cast<char *>(&commit_flag), 1);\n \n         // MySQL UUID is big-endian.\n-        UInt64 high = 0UL, low = 0UL;\n+        UInt64 high = 0UL;\n+        UInt64 low = 0UL;\n         readBigEndianStrict(payload, reinterpret_cast<char *>(&low), 8);\n-        gtid.uuid.toUnderType().low = low;\n+        gtid.uuid.toUnderType().items[0] = low;\n \n         readBigEndianStrict(payload, reinterpret_cast<char *>(&high), 8);\n-        gtid.uuid.toUnderType().high = high;\n+        gtid.uuid.toUnderType().items[1] = high;\n \n         payload.readStrict(reinterpret_cast<char *>(&gtid.seq_no), 8);\n \ndiff --git a/src/Core/TypeListNumber.h b/src/Core/TypeListNumber.h\nindex 9b7c33a6007b..b65bdef4e468 100644\n--- a/src/Core/TypeListNumber.h\n+++ b/src/Core/TypeListNumber.h\n@@ -1,20 +1,18 @@\n #pragma once\n \n #include <Core/Types.h>\n-#include <Common/UInt128.h>\n #include <Common/TypeList.h>\n \n namespace DB\n {\n \n using TypeListNativeNumbers = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64>;\n-using TypeListExtendedNumbers = TypeList<Int128, UInt256, Int256>;\n+using TypeListExtendedNumbers = TypeList<UInt128, Int128, UInt256, Int256>;\n using TypeListDecimalNumbers = TypeList<Decimal32, Decimal64, Decimal128, Decimal256>;\n \n using TypeListGeneralNumbers = typename TypeListConcat<TypeListNativeNumbers, TypeListExtendedNumbers>::Type;\n using TypeListNumbers = typename TypeListConcat<TypeListGeneralNumbers, TypeListDecimalNumbers>::Type;\n \n-/// Currently separate because UInt128 cannot be used in every context where other numbers can be used.\n-using TypeListNumbersAndUInt128 = typename AppendToTypeList<UInt128, TypeListNumbers>::Type;\n+using TypeListNumbersAndUUID = typename TypeListConcat<TypeListNumbers, TypeList<UUID>>::Type;\n \n }\ndiff --git a/src/Core/Types.h b/src/Core/Types.h\nindex b9ecda4a46da..151d9bdcf5a0 100644\n--- a/src/Core/Types.h\n+++ b/src/Core/Types.h\n@@ -3,6 +3,7 @@\n #include <cstdint>\n #include <string>\n #include <vector>\n+#include <common/strong_typedef.h>\n #include <common/extended_types.h>\n #include <common/defines.h>\n \n@@ -63,60 +64,52 @@ enum class TypeIndex\n #pragma GCC diagnostic pop\n #endif\n \n-/// Other int defines are in common/types.h\n-using UInt256 = ::wUInt256;\n+\n+using UInt128 = ::UInt128;\n+using UInt256 = ::UInt256;\n using Int128 = ::Int128;\n-using Int256 = ::wInt256;\n-\n-/** Note that for types not used in DB, IsNumber is false.\n-  */\n-template <typename T> constexpr bool IsNumber = false;\n-\n-template <> inline constexpr bool IsNumber<UInt8> = true;\n-template <> inline constexpr bool IsNumber<UInt16> = true;\n-template <> inline constexpr bool IsNumber<UInt32> = true;\n-template <> inline constexpr bool IsNumber<UInt64> = true;\n-template <> inline constexpr bool IsNumber<UInt256> = true;\n-template <> inline constexpr bool IsNumber<Int8> = true;\n-template <> inline constexpr bool IsNumber<Int16> = true;\n-template <> inline constexpr bool IsNumber<Int32> = true;\n-template <> inline constexpr bool IsNumber<Int64> = true;\n-template <> inline constexpr bool IsNumber<Int128> = true;\n-template <> inline constexpr bool IsNumber<Int256> = true;\n-template <> inline constexpr bool IsNumber<Float32> = true;\n-template <> inline constexpr bool IsNumber<Float64> = true;\n-\n-template <typename T> struct TypeName;\n-\n-template <> struct TypeName<UInt8>   { static constexpr const char * get() { return \"UInt8\";   } };\n-template <> struct TypeName<UInt16>  { static constexpr const char * get() { return \"UInt16\";  } };\n-template <> struct TypeName<UInt32>  { static constexpr const char * get() { return \"UInt32\";  } };\n-template <> struct TypeName<UInt64>  { static constexpr const char * get() { return \"UInt64\";  } };\n-template <> struct TypeName<UInt256> { static constexpr const char * get() { return \"UInt256\"; } };\n-template <> struct TypeName<Int8>    { static constexpr const char * get() { return \"Int8\";    } };\n-template <> struct TypeName<Int16>   { static constexpr const char * get() { return \"Int16\";   } };\n-template <> struct TypeName<Int32>   { static constexpr const char * get() { return \"Int32\";   } };\n-template <> struct TypeName<Int64>   { static constexpr const char * get() { return \"Int64\";   } };\n-template <> struct TypeName<Int128>  { static constexpr const char * get() { return \"Int128\";  } };\n-template <> struct TypeName<Int256> { static constexpr const char * get() { return \"Int256\";  } };\n-template <> struct TypeName<Float32> { static constexpr const char * get() { return \"Float32\"; } };\n-template <> struct TypeName<Float64> { static constexpr const char * get() { return \"Float64\"; } };\n-template <> struct TypeName<String>  { static constexpr const char * get() { return \"String\";  } };\n-\n-template <typename T> struct TypeId;\n-template <> struct TypeId<UInt8>    { static constexpr const TypeIndex value = TypeIndex::UInt8;  };\n-template <> struct TypeId<UInt16>   { static constexpr const TypeIndex value = TypeIndex::UInt16;  };\n-template <> struct TypeId<UInt32>   { static constexpr const TypeIndex value = TypeIndex::UInt32;  };\n-template <> struct TypeId<UInt64>   { static constexpr const TypeIndex value = TypeIndex::UInt64;  };\n-template <> struct TypeId<UInt256>  { static constexpr const TypeIndex value = TypeIndex::UInt256; };\n-template <> struct TypeId<Int8>     { static constexpr const TypeIndex value = TypeIndex::Int8;  };\n-template <> struct TypeId<Int16>    { static constexpr const TypeIndex value = TypeIndex::Int16; };\n-template <> struct TypeId<Int32>    { static constexpr const TypeIndex value = TypeIndex::Int32; };\n-template <> struct TypeId<Int64>    { static constexpr const TypeIndex value = TypeIndex::Int64; };\n-template <> struct TypeId<Int128>   { static constexpr const TypeIndex value = TypeIndex::Int128; };\n-template <> struct TypeId<Int256>   { static constexpr const TypeIndex value = TypeIndex::Int256; };\n-template <> struct TypeId<Float32>  { static constexpr const TypeIndex value = TypeIndex::Float32;  };\n-template <> struct TypeId<Float64>  { static constexpr const TypeIndex value = TypeIndex::Float64;  };\n+using Int256 = ::Int256;\n+\n+STRONG_TYPEDEF(UInt128, UUID)\n+\n+\n+template <typename T> constexpr const char * TypeName = \"\";\n+\n+template <> inline constexpr const char * TypeName<UInt8> = \"UInt8\";\n+template <> inline constexpr const char * TypeName<UInt16> = \"UInt16\";\n+template <> inline constexpr const char * TypeName<UInt32> = \"UInt32\";\n+template <> inline constexpr const char * TypeName<UInt64> = \"UInt64\";\n+template <> inline constexpr const char * TypeName<UInt128> = \"UInt128\";\n+template <> inline constexpr const char * TypeName<UInt256> = \"UInt256\";\n+template <> inline constexpr const char * TypeName<Int8> = \"Int8\";\n+template <> inline constexpr const char * TypeName<Int16> = \"Int16\";\n+template <> inline constexpr const char * TypeName<Int32> = \"Int32\";\n+template <> inline constexpr const char * TypeName<Int64> = \"Int64\";\n+template <> inline constexpr const char * TypeName<Int128> = \"Int128\";\n+template <> inline constexpr const char * TypeName<Int256> = \"Int256\";\n+template <> inline constexpr const char * TypeName<Float32> = \"Float32\";\n+template <> inline constexpr const char * TypeName<Float64> = \"Float64\";\n+template <> inline constexpr const char * TypeName<String> = \"String\";\n+template <> inline constexpr const char * TypeName<UUID> = \"UUID\";\n+\n+/// TODO Try to remove it.\n+template <typename T> constexpr TypeIndex TypeId = TypeIndex::Nothing;\n+template <> inline constexpr TypeIndex TypeId<UInt8> = TypeIndex::UInt8;\n+template <> inline constexpr TypeIndex TypeId<UInt16> = TypeIndex::UInt16;\n+template <> inline constexpr TypeIndex TypeId<UInt32> = TypeIndex::UInt32;\n+template <> inline constexpr TypeIndex TypeId<UInt64> = TypeIndex::UInt64;\n+template <> inline constexpr TypeIndex TypeId<UInt128> = TypeIndex::UInt128;\n+template <> inline constexpr TypeIndex TypeId<UInt256> = TypeIndex::UInt256;\n+template <> inline constexpr TypeIndex TypeId<Int8> = TypeIndex::Int8;\n+template <> inline constexpr TypeIndex TypeId<Int16> = TypeIndex::Int16;\n+template <> inline constexpr TypeIndex TypeId<Int32> = TypeIndex::Int32;\n+template <> inline constexpr TypeIndex TypeId<Int64> = TypeIndex::Int64;\n+template <> inline constexpr TypeIndex TypeId<Int128> = TypeIndex::Int128;\n+template <> inline constexpr TypeIndex TypeId<Int256> = TypeIndex::Int256;\n+template <> inline constexpr TypeIndex TypeId<Float32> = TypeIndex::Float32;\n+template <> inline constexpr TypeIndex TypeId<Float64> = TypeIndex::Float64;\n+template <> inline constexpr TypeIndex TypeId<UUID> = TypeIndex::UUID;\n+\n \n /// Not a data type in database, defined just for convenience.\n using Strings = std::vector<String>;\n@@ -167,6 +160,12 @@ struct Decimal\n     const Decimal<T> & operator /= (const T & x) { value /= x; return *this; }\n     const Decimal<T> & operator %= (const T & x) { value %= x; return *this; }\n \n+    template <typename U> const Decimal<T> & operator += (const Decimal<U> & x) { value += x.value; return *this; }\n+    template <typename U> const Decimal<T> & operator -= (const Decimal<U> & x) { value -= x.value; return *this; }\n+    template <typename U> const Decimal<T> & operator *= (const Decimal<U> & x) { value *= x.value; return *this; }\n+    template <typename U> const Decimal<T> & operator /= (const Decimal<U> & x) { value /= x.value; return *this; }\n+    template <typename U> const Decimal<T> & operator %= (const Decimal<U> & x) { value %= x.value; return *this; }\n+\n     /// This is to avoid UB for sumWithOverflow()\n     void NO_SANITIZE_UNDEFINED addOverflow(const T & x) { value += x; }\n \n@@ -175,6 +174,8 @@ struct Decimal\n \n template <typename T> inline bool operator< (const Decimal<T> & x, const Decimal<T> & y) { return x.value < y.value; }\n template <typename T> inline bool operator> (const Decimal<T> & x, const Decimal<T> & y) { return x.value > y.value; }\n+template <typename T> inline bool operator<= (const Decimal<T> & x, const Decimal<T> & y) { return x.value <= y.value; }\n+template <typename T> inline bool operator>= (const Decimal<T> & x, const Decimal<T> & y) { return x.value >= y.value; }\n template <typename T> inline bool operator== (const Decimal<T> & x, const Decimal<T> & y) { return x.value == y.value; }\n template <typename T> inline bool operator!= (const Decimal<T> & x, const Decimal<T> & y) { return x.value != y.value; }\n \n@@ -202,17 +203,17 @@ class DateTime64 : public Decimal64\n     {}\n };\n \n-template <> struct TypeName<Decimal32>   { static constexpr const char * get() { return \"Decimal32\";   } };\n-template <> struct TypeName<Decimal64>   { static constexpr const char * get() { return \"Decimal64\";   } };\n-template <> struct TypeName<Decimal128>  { static constexpr const char * get() { return \"Decimal128\";  } };\n-template <> struct TypeName<Decimal256>  { static constexpr const char * get() { return \"Decimal256\";  } };\n-template <> struct TypeName<DateTime64>  { static constexpr const char * get() { return \"DateTime64\";  } };\n+template <> inline constexpr const char * TypeName<Decimal32> = \"Decimal32\";\n+template <> inline constexpr const char * TypeName<Decimal64> = \"Decimal64\";\n+template <> inline constexpr const char * TypeName<Decimal128> = \"Decimal128\";\n+template <> inline constexpr const char * TypeName<Decimal256> = \"Decimal256\";\n+template <> inline constexpr const char * TypeName<DateTime64> = \"DateTime64\";\n \n-template <> struct TypeId<Decimal32>    { static constexpr const TypeIndex value = TypeIndex::Decimal32; };\n-template <> struct TypeId<Decimal64>    { static constexpr const TypeIndex value = TypeIndex::Decimal64; };\n-template <> struct TypeId<Decimal128>   { static constexpr const TypeIndex value = TypeIndex::Decimal128; };\n-template <> struct TypeId<Decimal256>   { static constexpr const TypeIndex value = TypeIndex::Decimal256; };\n-template <> struct TypeId<DateTime64>   { static constexpr const TypeIndex value = TypeIndex::DateTime64; };\n+template <> inline constexpr TypeIndex TypeId<Decimal32> = TypeIndex::Decimal32;\n+template <> inline constexpr TypeIndex TypeId<Decimal64> = TypeIndex::Decimal64;\n+template <> inline constexpr TypeIndex TypeId<Decimal128> = TypeIndex::Decimal128;\n+template <> inline constexpr TypeIndex TypeId<Decimal256> = TypeIndex::Decimal256;\n+template <> inline constexpr TypeIndex TypeId<DateTime64> = TypeIndex::DateTime64;\n \n template <typename T> constexpr bool IsDecimalNumber = false;\n template <> inline constexpr bool IsDecimalNumber<Decimal32> = true;\n@@ -229,8 +230,11 @@ template <> struct NativeType<Decimal256> { using Type = Int256; };\n template <> struct NativeType<DateTime64> { using Type = Int64; };\n \n template <typename T> constexpr bool OverBigInt = false;\n+template <> inline constexpr bool OverBigInt<Int128> = true;\n+template <> inline constexpr bool OverBigInt<UInt128> = true;\n template <> inline constexpr bool OverBigInt<Int256> = true;\n template <> inline constexpr bool OverBigInt<UInt256> = true;\n+template <> inline constexpr bool OverBigInt<Decimal128> = true;\n template <> inline constexpr bool OverBigInt<Decimal256> = true;\n \n inline constexpr const char * getTypeName(TypeIndex idx)\n@@ -238,31 +242,31 @@ inline constexpr const char * getTypeName(TypeIndex idx)\n     switch (idx)\n     {\n         case TypeIndex::Nothing:    return \"Nothing\";\n-        case TypeIndex::UInt8:      return TypeName<UInt8>::get();\n-        case TypeIndex::UInt16:     return TypeName<UInt16>::get();\n-        case TypeIndex::UInt32:     return TypeName<UInt32>::get();\n-        case TypeIndex::UInt64:     return TypeName<UInt64>::get();\n+        case TypeIndex::UInt8:      return \"UInt8\";\n+        case TypeIndex::UInt16:     return \"UInt16\";\n+        case TypeIndex::UInt32:     return \"UInt32\";\n+        case TypeIndex::UInt64:     return \"UInt64\";\n         case TypeIndex::UInt128:    return \"UInt128\";\n-        case TypeIndex::UInt256:    return TypeName<UInt256>::get();\n-        case TypeIndex::Int8:       return TypeName<Int8>::get();\n-        case TypeIndex::Int16:      return TypeName<Int16>::get();\n-        case TypeIndex::Int32:      return TypeName<Int32>::get();\n-        case TypeIndex::Int64:      return TypeName<Int64>::get();\n-        case TypeIndex::Int128:     return TypeName<Int128>::get();\n-        case TypeIndex::Int256:     return TypeName<Int256>::get();\n-        case TypeIndex::Float32:    return TypeName<Float32>::get();\n-        case TypeIndex::Float64:    return TypeName<Float64>::get();\n+        case TypeIndex::UInt256:    return \"UInt256\";\n+        case TypeIndex::Int8:       return \"Int8\";\n+        case TypeIndex::Int16:      return \"Int16\";\n+        case TypeIndex::Int32:      return \"Int32\";\n+        case TypeIndex::Int64:      return \"Int64\";\n+        case TypeIndex::Int128:     return \"Int128\";\n+        case TypeIndex::Int256:     return \"Int256\";\n+        case TypeIndex::Float32:    return \"Float32\";\n+        case TypeIndex::Float64:    return \"Float64\";\n         case TypeIndex::Date:       return \"Date\";\n         case TypeIndex::DateTime:   return \"DateTime\";\n         case TypeIndex::DateTime64: return \"DateTime64\";\n-        case TypeIndex::String:     return TypeName<String>::get();\n+        case TypeIndex::String:     return \"String\";\n         case TypeIndex::FixedString: return \"FixedString\";\n         case TypeIndex::Enum8:      return \"Enum8\";\n         case TypeIndex::Enum16:     return \"Enum16\";\n-        case TypeIndex::Decimal32:  return TypeName<Decimal32>::get();\n-        case TypeIndex::Decimal64:  return TypeName<Decimal64>::get();\n-        case TypeIndex::Decimal128: return TypeName<Decimal128>::get();\n-        case TypeIndex::Decimal256: return TypeName<Decimal256>::get();\n+        case TypeIndex::Decimal32:  return \"Decimal32\";\n+        case TypeIndex::Decimal64:  return \"Decimal64\";\n+        case TypeIndex::Decimal128: return \"Decimal128\";\n+        case TypeIndex::Decimal256: return \"Decimal256\";\n         case TypeIndex::UUID:       return \"UUID\";\n         case TypeIndex::Array:      return \"Array\";\n         case TypeIndex::Tuple:      return \"Tuple\";\ndiff --git a/src/Core/UUID.cpp b/src/Core/UUID.cpp\nnew file mode 100644\nindex 000000000000..ef1e10f50636\n--- /dev/null\n+++ b/src/Core/UUID.cpp\n@@ -0,0 +1,19 @@\n+#include <Core/UUID.h>\n+#include <Common/thread_local_rng.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace UUIDHelpers\n+{\n+    UUID generateV4()\n+    {\n+        UInt128 res{thread_local_rng(), thread_local_rng()};\n+        res.items[0] = (res.items[0] & 0xffffffffffff0fffull) | 0x0000000000004000ull;\n+        res.items[1] = (res.items[1] & 0x3fffffffffffffffull) | 0x8000000000000000ull;\n+        return UUID{res};\n+    }\n+}\n+\n+}\ndiff --git a/src/Core/UUID.h b/src/Core/UUID.h\nindex d5a6232a72b2..a24dcebdc9e1 100644\n--- a/src/Core/UUID.h\n+++ b/src/Core/UUID.h\n@@ -1,25 +1,17 @@\n #pragma once\n \n-#include <Common/UInt128.h>\n-#include <common/strong_typedef.h>\n-#include <Common/thread_local_rng.h>\n+#include <Core/Types.h>\n+\n \n namespace DB\n {\n \n-STRONG_TYPEDEF(UInt128, UUID)\n-\n namespace UUIDHelpers\n {\n-    inline UUID generateV4()\n-    {\n-        UInt128 res{thread_local_rng(), thread_local_rng()};\n-        res.low = (res.low & 0xffffffffffff0fffull) | 0x0000000000004000ull;\n-        res.high = (res.high & 0x3fffffffffffffffull) | 0x8000000000000000ull;\n-        return UUID{res};\n-    }\n+    /// Generate random UUID.\n+    UUID generateV4();\n \n-    const UUID Nil = UUID(UInt128(0, 0));\n+    const UUID Nil{};\n }\n \n }\ndiff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex 2d6134ab9fc8..520be263f9ff 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -26,6 +26,7 @@ bool callOnBasicType(TypeIndex number, F && f)\n             case TypeIndex::UInt16:       return f(TypePair<T, UInt16>());\n             case TypeIndex::UInt32:       return f(TypePair<T, UInt32>());\n             case TypeIndex::UInt64:       return f(TypePair<T, UInt64>());\n+            case TypeIndex::UInt128:      return f(TypePair<T, UInt128>());\n             case TypeIndex::UInt256:      return f(TypePair<T, UInt256>());\n \n             case TypeIndex::Int8:         return f(TypePair<T, Int8>());\n@@ -94,6 +95,7 @@ inline bool callOnBasicTypes(TypeIndex type_num1, TypeIndex type_num2, F && f)\n             case TypeIndex::UInt16: return callOnBasicType<UInt16, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::UInt32: return callOnBasicType<UInt32, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::UInt64: return callOnBasicType<UInt64, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n+            case TypeIndex::UInt128: return callOnBasicType<UInt128, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::UInt256: return callOnBasicType<UInt256, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n \n             case TypeIndex::Int8: return callOnBasicType<Int8, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n@@ -171,6 +173,7 @@ bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)\n         case TypeIndex::UInt16:         return f(TypePair<DataTypeNumber<UInt16>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::UInt32:         return f(TypePair<DataTypeNumber<UInt32>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::UInt64:         return f(TypePair<DataTypeNumber<UInt64>, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::UInt128:        return f(TypePair<DataTypeNumber<UInt128>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::UInt256:        return f(TypePair<DataTypeNumber<UInt256>, T>(), std::forward<ExtraArgs>(args)...);\n \n         case TypeIndex::Int8:           return f(TypePair<DataTypeNumber<Int8>, T>(), std::forward<ExtraArgs>(args)...);\ndiff --git a/src/DataStreams/MongoDBBlockInputStream.cpp b/src/DataStreams/MongoDBBlockInputStream.cpp\nindex e4ddcd09ede4..d740448e0cfd 100644\n--- a/src/DataStreams/MongoDBBlockInputStream.cpp\n+++ b/src/DataStreams/MongoDBBlockInputStream.cpp\n@@ -25,7 +25,6 @@\n // Poco/MongoDB/BSONWriter.h:54: void writeCString(const std::string & value);\n // src/IO/WriteHelpers.h:146 #define writeCString(s, buf)\n #include <IO/WriteHelpers.h>\n-#include <Common/FieldVisitors.h>\n #include <ext/enumerate.h>\n \n namespace DB\n@@ -290,7 +289,7 @@ namespace\n                 if (value.type() == Poco::MongoDB::ElementTraits<String>::TypeId)\n                 {\n                     String string = static_cast<const Poco::MongoDB::ConcreteElement<String> &>(value).value();\n-                    assert_cast<ColumnUInt128 &>(column).getData().push_back(parse<UUID>(string));\n+                    assert_cast<ColumnUUID &>(column).getData().push_back(parse<UUID>(string));\n                 }\n                 else\n                     throw Exception{\"Type mismatch, expected String (UUID), got type id = \" + toString(value.type()) + \" for column \"\ndiff --git a/src/DataStreams/PostgreSQLBlockInputStream.cpp b/src/DataStreams/PostgreSQLBlockInputStream.cpp\nindex 8897cd13a2e1..63a8e9edb79c 100644\n--- a/src/DataStreams/PostgreSQLBlockInputStream.cpp\n+++ b/src/DataStreams/PostgreSQLBlockInputStream.cpp\n@@ -161,7 +161,7 @@ void PostgreSQLBlockInputStream::insertValue(IColumn & column, std::string_view\n             assert_cast<ColumnString &>(column).insertData(value.data(), value.size());\n             break;\n         case ValueType::vtUUID:\n-            assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(value.data(), value.size()));\n+            assert_cast<ColumnUUID &>(column).insert(parse<UUID>(value.data(), value.size()));\n             break;\n         case ValueType::vtDate:\n             assert_cast<ColumnUInt16 &>(column).insertValue(UInt16{LocalDate{std::string(value)}.getDayNum()});\ndiff --git a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h\nindex 44b007ab07fe..dc054144e144 100644\n--- a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h\n+++ b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h\n@@ -2,7 +2,6 @@\n \n #include <DataTypes/DataTypeCustom.h>\n #include <AggregateFunctions/IAggregateFunction.h>\n-#include <Common/FieldVisitors.h>\n \n #include <IO/ReadHelpers.h>\n \ndiff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h\nindex 9e44310a0fff..aea837f890f6 100644\n--- a/src/DataTypes/DataTypeDecimalBase.h\n+++ b/src/DataTypes/DataTypeDecimalBase.h\n@@ -76,7 +76,7 @@ class DataTypeDecimalBase : public IDataType\n             throw Exception(\"Scale \" + std::to_string(scale) + \" is out of bounds\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n     }\n \n-    TypeIndex getTypeId() const override { return TypeId<T>::value; }\n+    TypeIndex getTypeId() const override { return TypeId<T>; }\n \n     Field getDefault() const override;\n     MutableColumnPtr createColumn() const override;\n@@ -113,15 +113,15 @@ class DataTypeDecimalBase : public IDataType\n \n     T maxWholeValue() const { return getScaleMultiplier(precision - scale) - T(1); }\n \n-    template<typename U>\n+    template <typename U>\n     bool canStoreWhole(U x) const\n     {\n-        static_assert(std::is_signed_v<typename T::NativeType>);\n+        static_assert(is_signed_v<typename T::NativeType>);\n         T max = maxWholeValue();\n-        if constexpr (std::is_signed_v<U>)\n-            return -max <= x && x <= max;\n+        if constexpr (is_signed_v<U>)\n+            return -max.value <= x && x <= max.value;\n         else\n-            return x <= static_cast<std::make_unsigned_t<typename T::NativeType>>(max.value);\n+            return x <= static_cast<make_unsigned_t<typename T::NativeType>>(max.value);\n     }\n \n     /// @returns multiplier for U to become T with correct scale\ndiff --git a/src/DataTypes/DataTypeLowCardinality.cpp b/src/DataTypes/DataTypeLowCardinality.cpp\nindex 485083d67ee3..95a5addf62a5 100644\n--- a/src/DataTypes/DataTypeLowCardinality.cpp\n+++ b/src/DataTypes/DataTypeLowCardinality.cpp\n@@ -79,6 +79,8 @@ MutableColumnUniquePtr DataTypeLowCardinality::createColumnUniqueImpl(const IDat\n         return creator(static_cast<ColumnVector<UInt16> *>(nullptr));\n     else if (which.isDateTime())\n         return creator(static_cast<ColumnVector<UInt32> *>(nullptr));\n+    else if (which.isUUID())\n+        return creator(static_cast<ColumnVector<UUID> *>(nullptr));\n     else if (which.isInt() || which.isUInt() || which.isFloat())\n     {\n         MutableColumnUniquePtr column;\ndiff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp\nindex 1d5807613625..b09a5e9e590f 100644\n--- a/src/DataTypes/DataTypeMap.cpp\n+++ b/src/DataTypes/DataTypeMap.cpp\n@@ -55,9 +55,12 @@ DataTypeMap::DataTypeMap(const DataTypePtr & key_type_, const DataTypePtr & valu\n \n void DataTypeMap::assertKeyType() const\n {\n-    if (!key_type->isValueRepresentedByInteger() && !isStringOrFixedString(*key_type) && !WhichDataType(key_type).isNothing())\n+    if (!key_type->isValueRepresentedByInteger()\n+        && !isStringOrFixedString(*key_type)\n+        && !WhichDataType(key_type).isNothing()\n+        && !WhichDataType(key_type).isUUID())\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-            \"Type of Map key must be a type, that can be represented by integer or string,\"\n+            \"Type of Map key must be a type, that can be represented by integer or string or UUID,\"\n             \" but {} given\", key_type->getName());\n }\n \ndiff --git a/src/DataTypes/DataTypeNumberBase.cpp b/src/DataTypes/DataTypeNumberBase.cpp\nindex a9df7db73349..12d1989a9d67 100644\n--- a/src/DataTypes/DataTypeNumberBase.cpp\n+++ b/src/DataTypes/DataTypeNumberBase.cpp\n@@ -43,7 +43,7 @@ template class DataTypeNumberBase<UInt8>;\n template class DataTypeNumberBase<UInt16>;\n template class DataTypeNumberBase<UInt32>;\n template class DataTypeNumberBase<UInt64>;\n-template class DataTypeNumberBase<UInt128>; // base for UUID\n+template class DataTypeNumberBase<UInt128>;\n template class DataTypeNumberBase<UInt256>;\n template class DataTypeNumberBase<Int8>;\n template class DataTypeNumberBase<Int16>;\ndiff --git a/src/DataTypes/DataTypeNumberBase.h b/src/DataTypes/DataTypeNumberBase.h\nindex 97c3563b032c..c24778691d9a 100644\n--- a/src/DataTypes/DataTypeNumberBase.h\n+++ b/src/DataTypes/DataTypeNumberBase.h\n@@ -1,6 +1,5 @@\n #pragma once\n \n-#include <Common/UInt128.h>\n #include <DataTypes/IDataType.h>\n #include <DataTypes/Serializations/SerializationNumber.h>\n \n@@ -16,19 +15,17 @@ class ColumnVector;\n template <typename T>\n class DataTypeNumberBase : public IDataType\n {\n-    static_assert(IsNumber<T>);\n+    static_assert(is_arithmetic_v<T>);\n \n public:\n     static constexpr bool is_parametric = false;\n+    static constexpr auto family_name = TypeName<T>;\n \n     using FieldType = T;\n-    static constexpr auto type_id = TypeId<T>::value;\n-    static constexpr auto family_name = TypeName<T>::get();\n-\n     using ColumnType = ColumnVector<T>;\n \n-    const char * getFamilyName() const override { return family_name; }\n-    TypeIndex getTypeId() const override { return type_id; }\n+    const char * getFamilyName() const override { return TypeName<T>; }\n+    TypeIndex getTypeId() const override { return TypeId<T>; }\n \n     Field getDefault() const override;\n \n@@ -63,7 +60,7 @@ extern template class DataTypeNumberBase<UInt8>;\n extern template class DataTypeNumberBase<UInt16>;\n extern template class DataTypeNumberBase<UInt32>;\n extern template class DataTypeNumberBase<UInt64>;\n-extern template class DataTypeNumberBase<UInt128>; // base for UUID\n+extern template class DataTypeNumberBase<UInt128>;\n extern template class DataTypeNumberBase<UInt256>;\n extern template class DataTypeNumberBase<Int16>;\n extern template class DataTypeNumberBase<Int8>;\ndiff --git a/src/DataTypes/DataTypeUUID.cpp b/src/DataTypes/DataTypeUUID.cpp\nindex 387ccc56a712..44182a700b44 100644\n--- a/src/DataTypes/DataTypeUUID.cpp\n+++ b/src/DataTypes/DataTypeUUID.cpp\n@@ -16,6 +16,16 @@ SerializationPtr DataTypeUUID::doGetDefaultSerialization() const\n     return std::make_shared<SerializationUUID>();\n }\n \n+Field DataTypeUUID::getDefault() const\n+{\n+    return UUID{};\n+}\n+\n+MutableColumnPtr DataTypeUUID::createColumn() const\n+{\n+    return ColumnVector<UUID>::create();\n+}\n+\n void registerDataTypeUUID(DataTypeFactory & factory)\n {\n     factory.registerSimpleDataType(\"UUID\", [] { return DataTypePtr(std::make_shared<DataTypeUUID>()); });\ndiff --git a/src/DataTypes/DataTypeUUID.h b/src/DataTypes/DataTypeUUID.h\nindex 1546ca385a44..70104a034786 100644\n--- a/src/DataTypes/DataTypeUUID.h\n+++ b/src/DataTypes/DataTypeUUID.h\n@@ -1,26 +1,44 @@\n #pragma once\n \n-#include <Common/UInt128.h>\n-#include <DataTypes/DataTypeNumberBase.h>\n #include <DataTypes/IDataType.h>\n+#include <Columns/ColumnVector.h>\n+#include <Core/UUID.h>\n+\n \n namespace DB\n {\n \n-class DataTypeUUID final : public DataTypeNumberBase<UInt128>\n+class DataTypeUUID : public IDataType\n {\n-\n public:\n+    static constexpr bool is_parametric = false;\n+\n+    using FieldType = UUID;\n+    using ColumnType = ColumnVector<UUID>;\n+\n     const char * getFamilyName() const override { return \"UUID\"; }\n     TypeIndex getTypeId() const override { return TypeIndex::UUID; }\n \n+    Field getDefault() const override;\n+\n+    MutableColumnPtr createColumn() const override;\n+\n+    bool isParametric() const override { return false; }\n+    bool haveSubtypes() const override { return false; }\n+\n     bool equals(const IDataType & rhs) const override;\n \n     bool canBeUsedInBitOperations() const override { return true; }\n     bool canBeInsideNullable() const override { return true; }\n-    bool canBeInsideLowCardinality() const override { return false; }\n-\n     bool canBePromoted() const override { return false; }\n+    bool shouldAlignRightInPrettyFormats() const override { return false; }\n+    bool textCanContainOnlyValidUTF8() const override { return true; }\n+    bool isComparable() const override { return true; }\n+    bool isValueUnambiguouslyRepresentedInContiguousMemoryRegion() const override { return true; }\n+    bool haveMaximumSizeOfValue() const override { return true; }\n+    size_t getSizeOfValueInMemory() const override { return sizeof(UUID); }\n+    bool isCategorial() const override { return true; }\n+    bool canBeInsideLowCardinality() const override { return true; }\n \n     SerializationPtr doGetDefaultSerialization() const override;\n };\ndiff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex 5aeac78b2efa..f08bdb80d41f 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <common/arithmeticOverflow.h>\n+#include <common/extended_types.h>\n #include <Common/typeid_cast.h>\n #include <DataTypes/IDataType.h>\n #include <DataTypes/DataTypeDecimalBase.h>\n@@ -38,7 +39,7 @@ class DataTypeDecimal final : public DataTypeDecimalBase<T>\n \n     const char * getFamilyName() const override { return family_name; }\n     std::string doGetName() const override;\n-    TypeIndex getTypeId() const override { return TypeId<T>::value; }\n+    TypeIndex getTypeId() const override { return TypeId<T>; }\n     bool canBePromoted() const override { return true; }\n     DataTypePtr promoteNumericType() const override;\n \n@@ -150,7 +151,7 @@ tryConvertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_\n }\n \n template <typename FromDataType, typename ToDataType, typename ReturnType>\n-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, ReturnType>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, ReturnType>\n convertFromDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n {\n     using FromFieldType = typename FromDataType::FieldType;\n@@ -160,7 +161,7 @@ convertFromDecimalImpl(const typename FromDataType::FieldType & value, UInt32 sc\n }\n \n template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, typename ToDataType::FieldType>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, typename ToDataType::FieldType>\n convertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n {\n     typename ToDataType::FieldType result;\n@@ -171,14 +172,14 @@ convertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n }\n \n template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, bool>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, bool>\n tryConvertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n {\n     return convertFromDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);\n }\n \n template <typename FromDataType, typename ToDataType, typename ReturnType>\n-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, ReturnType>\n+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, ReturnType>\n convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n {\n     using FromFieldType = typename FromDataType::FieldType;\n@@ -199,35 +200,18 @@ convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scal\n         }\n \n         auto out = value * static_cast<FromFieldType>(DecimalUtils::scaleMultiplier<ToNativeType>(scale));\n-        if constexpr (std::is_same_v<ToNativeType, Int128>)\n-        {\n-            static constexpr Int128 min_int128 = minInt128();\n-            static constexpr Int128 max_int128 = maxInt128();\n-\n-            if (out <= static_cast<ToNativeType>(min_int128) || out >= static_cast<ToNativeType>(max_int128))\n-            {\n-                if constexpr (throw_exception)\n-                    throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n-                                    ErrorCodes::DECIMAL_OVERFLOW);\n-                else\n-                    return ReturnType(false);\n-            }\n-        }\n-        else\n+\n+        if (out <= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::min()) ||\n+            out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))\n         {\n-            if (out <= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::min()) ||\n-                out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))\n-            {\n-                if constexpr (throw_exception)\n-                    throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n-                                    ErrorCodes::DECIMAL_OVERFLOW);\n-                else\n-                    return ReturnType(false);\n-            }\n+            if constexpr (throw_exception)\n+                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n+                                ErrorCodes::DECIMAL_OVERFLOW);\n+            else\n+                return ReturnType(false);\n         }\n \n         result = static_cast<ToNativeType>(out);\n-\n         return ReturnType(true);\n     }\n     else\n@@ -235,25 +219,23 @@ convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scal\n         if constexpr (is_big_int_v<FromFieldType>)\n             return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal256>, ToDataType, ReturnType>(static_cast<Int256>(value), 0, scale, result));\n         else if constexpr (std::is_same_v<FromFieldType, UInt64>)\n-            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal128>, ToDataType, ReturnType>(value, 0, scale, result));\n+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal128>, ToDataType, ReturnType>(static_cast<Int128>(value), 0, scale, result));\n         else\n-            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal64>, ToDataType, ReturnType>(value, 0, scale, result));\n+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal64>, ToDataType, ReturnType>(static_cast<Int64>(value), 0, scale, result));\n     }\n }\n \n template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n {\n     typename ToDataType::FieldType result;\n-\n     convertToDecimalImpl<FromDataType, ToDataType, void>(value, scale, result);\n-\n     return result;\n }\n \n template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, bool>\n+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, bool>\n tryConvertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n {\n     return convertToDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);\ndiff --git a/src/DataTypes/DataTypesNumber.cpp b/src/DataTypes/DataTypesNumber.cpp\nindex 5cfffa878f23..6a1aed888c9e 100644\n--- a/src/DataTypes/DataTypesNumber.cpp\n+++ b/src/DataTypes/DataTypesNumber.cpp\n@@ -21,12 +21,12 @@ static DataTypePtr createNumericDataType(const ASTPtr & arguments)\n         if (std::is_integral_v<T>)\n         {\n             if (arguments->children.size() > 1)\n-                throw Exception(String(TypeName<T>::get()) + \" data type family must not have more than one argument - display width\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"{} data type family must not have more than one argument - display width\", TypeName<T>);\n         }\n         else\n         {\n             if (arguments->children.size() > 2)\n-                throw Exception(String(TypeName<T>::get()) + \" data type family must not have more than two arguments - total number of digits and number of digits following the decimal point\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"{} data type family must not have more than two arguments - total number of digits and number of digits following the decimal point\", TypeName<T>);\n         }\n     }\n     return std::make_shared<DataTypeNumber<T>>();\n@@ -44,10 +44,13 @@ void registerDataTypeNumbers(DataTypeFactory & factory)\n     factory.registerDataType(\"Int16\", createNumericDataType<Int16>);\n     factory.registerDataType(\"Int32\", createNumericDataType<Int32>);\n     factory.registerDataType(\"Int64\", createNumericDataType<Int64>);\n+\n     factory.registerDataType(\"Float32\", createNumericDataType<Float32>);\n     factory.registerDataType(\"Float64\", createNumericDataType<Float64>);\n \n+    factory.registerSimpleDataType(\"UInt128\", [] { return DataTypePtr(std::make_shared<DataTypeUInt128>()); });\n     factory.registerSimpleDataType(\"UInt256\", [] { return DataTypePtr(std::make_shared<DataTypeUInt256>()); });\n+\n     factory.registerSimpleDataType(\"Int128\", [] { return DataTypePtr(std::make_shared<DataTypeInt128>()); });\n     factory.registerSimpleDataType(\"Int256\", [] { return DataTypePtr(std::make_shared<DataTypeInt256>()); });\n \ndiff --git a/src/DataTypes/DataTypesNumber.h b/src/DataTypes/DataTypesNumber.h\nindex 792727564650..9f026e061277 100644\n--- a/src/DataTypes/DataTypesNumber.h\n+++ b/src/DataTypes/DataTypesNumber.h\n@@ -44,6 +44,7 @@ using DataTypeInt64 = DataTypeNumber<Int64>;\n using DataTypeFloat32 = DataTypeNumber<Float32>;\n using DataTypeFloat64 = DataTypeNumber<Float64>;\n \n+using DataTypeUInt128 = DataTypeNumber<UInt128>;\n using DataTypeInt128 = DataTypeNumber<Int128>;\n using DataTypeUInt256 = DataTypeNumber<UInt256>;\n using DataTypeInt256 = DataTypeNumber<Int256>;\ndiff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp\nindex 95f033851212..a8d439612f50 100644\n--- a/src/DataTypes/FieldToDataType.cpp\n+++ b/src/DataTypes/FieldToDataType.cpp\n@@ -1,4 +1,3 @@\n-#include <Common/FieldVisitors.h>\n #include <DataTypes/FieldToDataType.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeMap.h>\n@@ -8,6 +7,7 @@\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeNothing.h>\n+#include <DataTypes/DataTypeUUID.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <Common/Exception.h>\n@@ -20,7 +20,6 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int EMPTY_DATA_PASSED;\n-    extern const int NOT_IMPLEMENTED;\n }\n \n \n@@ -37,11 +36,6 @@ DataTypePtr FieldToDataType::operator() (const UInt64 & x) const\n     return std::make_shared<DataTypeUInt64>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const UInt128 &) const\n-{\n-    throw Exception(\"There are no UInt128 literals in SQL\", ErrorCodes::NOT_IMPLEMENTED);\n-}\n-\n DataTypePtr FieldToDataType::operator() (const Int64 & x) const\n {\n     if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();\n@@ -50,18 +44,34 @@ DataTypePtr FieldToDataType::operator() (const Int64 & x) const\n     return std::make_shared<DataTypeInt64>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Int128 & x) const\n+DataTypePtr FieldToDataType::operator() (const Float64 &) const\n+{\n+    return std::make_shared<DataTypeFloat64>();\n+}\n+\n+DataTypePtr FieldToDataType::operator() (const UInt128 &) const\n+{\n+    return std::make_shared<DataTypeUInt128>();\n+}\n+\n+DataTypePtr FieldToDataType::operator() (const Int128 &) const\n {\n-    if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();\n-    if (x <= std::numeric_limits<Int16>::max() && x >= std::numeric_limits<Int16>::min()) return std::make_shared<DataTypeInt16>();\n-    if (x <= std::numeric_limits<Int32>::max() && x >= std::numeric_limits<Int32>::min()) return std::make_shared<DataTypeInt32>();\n-    if (x <= std::numeric_limits<Int64>::max() && x >= std::numeric_limits<Int64>::min()) return std::make_shared<DataTypeInt64>();\n     return std::make_shared<DataTypeInt128>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Float64 &) const\n+DataTypePtr FieldToDataType::operator() (const UInt256 &) const\n {\n-    return std::make_shared<DataTypeFloat64>();\n+    return std::make_shared<DataTypeUInt256>();\n+}\n+\n+DataTypePtr FieldToDataType::operator() (const Int256 &) const\n+{\n+    return std::make_shared<DataTypeInt256>();\n+}\n+\n+DataTypePtr FieldToDataType::operator() (const UUID &) const\n+{\n+    return std::make_shared<DataTypeUUID>();\n }\n \n DataTypePtr FieldToDataType::operator() (const String &) const\n@@ -143,14 +153,4 @@ DataTypePtr FieldToDataType::operator() (const AggregateFunctionStateData & x) c\n     return DataTypeFactory::instance().get(name);\n }\n \n-DataTypePtr FieldToDataType::operator() (const UInt256 &) const\n-{\n-    throw Exception(\"There are no UInt256 literals in SQL\", ErrorCodes::NOT_IMPLEMENTED);\n-}\n-\n-DataTypePtr FieldToDataType::operator() (const Int256 &) const\n-{\n-    throw Exception(\"There are no Int256 literals in SQL\", ErrorCodes::NOT_IMPLEMENTED);\n-}\n-\n }\ndiff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h\nindex 39457564a2f2..ca83ce868fc6 100644\n--- a/src/DataTypes/FieldToDataType.h\n+++ b/src/DataTypes/FieldToDataType.h\n@@ -1,5 +1,8 @@\n #pragma once\n \n+#include <memory>\n+#include <Core/Types.h>\n+#include <Core/Field.h>\n #include <Common/FieldVisitors.h>\n \n \n@@ -20,8 +23,11 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>\n     DataTypePtr operator() (const Null & x) const;\n     DataTypePtr operator() (const UInt64 & x) const;\n     DataTypePtr operator() (const UInt128 & x) const;\n+    DataTypePtr operator() (const UInt256 & x) const;\n     DataTypePtr operator() (const Int64 & x) const;\n     DataTypePtr operator() (const Int128 & x) const;\n+    DataTypePtr operator() (const Int256 & x) const;\n+    DataTypePtr operator() (const UUID & x) const;\n     DataTypePtr operator() (const Float64 & x) const;\n     DataTypePtr operator() (const String & x) const;\n     DataTypePtr operator() (const Array & x) const;\n@@ -32,8 +38,6 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>\n     DataTypePtr operator() (const DecimalField<Decimal128> & x) const;\n     DataTypePtr operator() (const DecimalField<Decimal256> & x) const;\n     DataTypePtr operator() (const AggregateFunctionStateData & x) const;\n-    DataTypePtr operator() (const UInt256 & x) const;\n-    DataTypePtr operator() (const Int256 & x) const;\n };\n \n }\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 5a676819b77b..4602083f4887 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -342,7 +342,7 @@ struct WhichDataType\n     constexpr bool isFunction() const { return idx == TypeIndex::Function; }\n     constexpr bool isAggregateFunction() const { return idx == TypeIndex::AggregateFunction; }\n \n-    constexpr bool IsBigIntOrDeimal() const { return isInt128() || isInt256() || isUInt256() || isDecimal256(); }\n+    constexpr bool IsBigIntOrDeimal() const { return isInt128() || isUInt128() || isInt256() || isUInt256() || isDecimal256(); }\n };\n \n /// IDataType helpers (alternative for IDataType virtual methods with single point of truth)\n@@ -430,7 +430,7 @@ template <typename T, typename DataType>\n inline bool isColumnedAsDecimalT(const DataType & data_type)\n {\n     const WhichDataType which(data_type);\n-    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>::value;\n+    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>;\n }\n \n template <typename T>\n@@ -469,19 +469,6 @@ inline bool isCompilableType(const DataTypePtr & data_type)\n     return data_type->isValueRepresentedByNumber() && !isDecimal(data_type);\n }\n \n-template <TypeIndex TYPE_IDX, typename DataType>\n-inline bool isDataType(const DataType & data_type)\n-{\n-    WhichDataType which(data_type);\n-    return which.idx == TYPE_IDX;\n-}\n-\n-template <typename ExpectedDataType, typename DataType>\n-inline bool isDataType(const DataType & data_type)\n-{\n-    return isDataType<ExpectedDataType::type_id>(data_type);\n-}\n-\n template <typename DataType> constexpr bool IsDataTypeDecimal = false;\n template <typename DataType> constexpr bool IsDataTypeNumber = false;\n template <typename DataType> constexpr bool IsDataTypeDateOrDateTime = false;\ndiff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h\nindex c3b0d956ef5a..dc96f2db128f 100644\n--- a/src/DataTypes/NumberTraits.h\n+++ b/src/DataTypes/NumberTraits.h\n@@ -3,7 +3,6 @@\n #include <type_traits>\n \n #include <Core/Types.h>\n-#include <Common/UInt128.h>\n \n \n namespace DB\n@@ -47,7 +46,7 @@ template <> struct Construct<false, false, 1> { using Type = UInt8; };\n template <> struct Construct<false, false, 2> { using Type = UInt16; };\n template <> struct Construct<false, false, 4> { using Type = UInt32; };\n template <> struct Construct<false, false, 8> { using Type = UInt64; };\n-template <> struct Construct<false, false, 16> { using Type = UInt256; }; /// TODO: we cannot use our UInt128 here\n+template <> struct Construct<false, false, 16> { using Type = UInt128; };\n template <> struct Construct<false, false, 32> { using Type = UInt256; };\n template <> struct Construct<false, true, 1> { using Type = Float32; };\n template <> struct Construct<false, true, 2> { using Type = Float32; };\n@@ -183,11 +182,12 @@ struct ResultOfIf\n                 ? max(sizeof(A), sizeof(B)) * 2\n                 : max(sizeof(A), sizeof(B))>::Type;\n \n-    using ConstructedTypeWithoutUUID = std::conditional_t<std::is_same_v<A, UInt128> || std::is_same_v<B, UInt128>, Error, ConstructedType>;\n-    using ConstructedWithUUID = std::conditional_t<std::is_same_v<A, UInt128> && std::is_same_v<B, UInt128>, A, ConstructedTypeWithoutUUID>;\n-\n-    using Type = std::conditional_t<!IsDecimalNumber<A> && !IsDecimalNumber<B>, ConstructedWithUUID,\n-        std::conditional_t<IsDecimalNumber<A> && IsDecimalNumber<B>, std::conditional_t<(sizeof(A) > sizeof(B)), A, B>, Error>>;\n+    using Type =\n+        std::conditional_t<std::is_same_v<A, B>, A,\n+        std::conditional_t<IsDecimalNumber<A> && IsDecimalNumber<B>,\n+            std::conditional_t<(sizeof(A) > sizeof(B)), A, B>,\n+        std::conditional_t<!IsDecimalNumber<A> && !IsDecimalNumber<B>,\n+            ConstructedType, Error>>>;\n };\n \n /** Before applying operator `%` and bitwise operations, operands are casted to whole numbers. */\ndiff --git a/src/DataTypes/Serializations/SerializationNumber.cpp b/src/DataTypes/Serializations/SerializationNumber.cpp\nindex 36cbd6a5ef8d..347db5d0aa5f 100644\n--- a/src/DataTypes/Serializations/SerializationNumber.cpp\n+++ b/src/DataTypes/Serializations/SerializationNumber.cpp\n@@ -157,7 +157,7 @@ template class SerializationNumber<UInt8>;\n template class SerializationNumber<UInt16>;\n template class SerializationNumber<UInt32>;\n template class SerializationNumber<UInt64>;\n-template class SerializationNumber<UInt128>; // base for UUID\n+template class SerializationNumber<UInt128>;\n template class SerializationNumber<UInt256>;\n template class SerializationNumber<Int8>;\n template class SerializationNumber<Int16>;\ndiff --git a/src/DataTypes/Serializations/SerializationNumber.h b/src/DataTypes/Serializations/SerializationNumber.h\nindex 09976a4bc4f2..cb40b6c5437e 100644\n--- a/src/DataTypes/Serializations/SerializationNumber.h\n+++ b/src/DataTypes/Serializations/SerializationNumber.h\n@@ -9,7 +9,7 @@ namespace DB\n template <typename T>\n class SerializationNumber : public SimpleTextSerialization\n {\n-    static_assert(IsNumber<T>);\n+    static_assert(is_arithmetic_v<T>);\n \n public:\n     using FieldType = T;\ndiff --git a/src/DataTypes/Serializations/SerializationUUID.cpp b/src/DataTypes/Serializations/SerializationUUID.cpp\nindex 1a0640a5e69d..3c1ba869466d 100644\n--- a/src/DataTypes/Serializations/SerializationUUID.cpp\n+++ b/src/DataTypes/Serializations/SerializationUUID.cpp\n@@ -6,19 +6,20 @@\n #include <IO/ReadHelpers.h>\n #include <Common/assert_cast.h>\n \n+\n namespace DB\n {\n \n void SerializationUUID::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const\n {\n-    writeText(UUID(assert_cast<const ColumnUInt128 &>(column).getData()[row_num]), ostr);\n+    writeText(assert_cast<const ColumnUUID &>(column).getData()[row_num], ostr);\n }\n \n void SerializationUUID::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     UUID x;\n     readText(x, istr);\n-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);\n+    assert_cast<ColumnUUID &>(column).getData().push_back(x);\n }\n \n void SerializationUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n@@ -44,7 +45,7 @@ void SerializationUUID::deserializeTextQuoted(IColumn & column, ReadBuffer & ist\n     assertChar('\\'', istr);\n     readText(x, istr);\n     assertChar('\\'', istr);\n-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.\n+    assert_cast<ColumnUUID &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.\n }\n \n void SerializationUUID::serializeTextJSON(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n@@ -60,7 +61,7 @@ void SerializationUUID::deserializeTextJSON(IColumn & column, ReadBuffer & istr,\n     assertChar('\"', istr);\n     readText(x, istr);\n     assertChar('\"', istr);\n-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);\n+    assert_cast<ColumnUUID &>(column).getData().push_back(x);\n }\n \n void SerializationUUID::serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n@@ -74,7 +75,55 @@ void SerializationUUID::deserializeTextCSV(IColumn & column, ReadBuffer & istr,\n {\n     UUID value;\n     readCSV(value, istr);\n-    assert_cast<ColumnUInt128 &>(column).getData().push_back(value);\n+    assert_cast<ColumnUUID &>(column).getData().push_back(value);\n+}\n+\n+\n+void SerializationUUID::serializeBinary(const Field & field, WriteBuffer & ostr) const\n+{\n+    UUID x = get<UUID>(field);\n+    writeBinary(x, ostr);\n+}\n+\n+void SerializationUUID::deserializeBinary(Field & field, ReadBuffer & istr) const\n+{\n+    UUID x;\n+    readBinary(x, istr);\n+    field = NearestFieldType<UUID>(x);\n+}\n+\n+void SerializationUUID::serializeBinary(const IColumn & column, size_t row_num, WriteBuffer & ostr) const\n+{\n+    writeBinary(assert_cast<const ColumnVector<UUID> &>(column).getData()[row_num], ostr);\n+}\n+\n+void SerializationUUID::deserializeBinary(IColumn & column, ReadBuffer & istr) const\n+{\n+    UUID x;\n+    readBinary(x, istr);\n+    assert_cast<ColumnVector<UUID> &>(column).getData().push_back(x);\n+}\n+\n+void SerializationUUID::serializeBinaryBulk(const IColumn & column, WriteBuffer & ostr, size_t offset, size_t limit) const\n+{\n+    const typename ColumnVector<UUID>::Container & x = typeid_cast<const ColumnVector<UUID> &>(column).getData();\n+\n+    size_t size = x.size();\n+\n+    if (limit == 0 || offset + limit > size)\n+        limit = size - offset;\n+\n+    if (limit)\n+        ostr.write(reinterpret_cast<const char *>(&x[offset]), sizeof(UUID) * limit);\n+}\n+\n+void SerializationUUID::deserializeBinaryBulk(IColumn & column, ReadBuffer & istr, size_t limit, double /*avg_value_size_hint*/) const\n+{\n+    typename ColumnVector<UUID>::Container & x = typeid_cast<ColumnVector<UUID> &>(column).getData();\n+    size_t initial_size = x.size();\n+    x.resize(initial_size + limit);\n+    size_t size = istr.readBig(reinterpret_cast<char*>(&x[initial_size]), sizeof(UUID) * limit);\n+    x.resize(initial_size + size / sizeof(UUID));\n }\n \n }\ndiff --git a/src/DataTypes/Serializations/SerializationUUID.h b/src/DataTypes/Serializations/SerializationUUID.h\nindex 93bf166bbd97..3100e1288485 100644\n--- a/src/DataTypes/Serializations/SerializationUUID.h\n+++ b/src/DataTypes/Serializations/SerializationUUID.h\n@@ -5,7 +5,7 @@\n namespace DB\n {\n \n-class SerializationUUID : public SerializationNumber<UInt128>\n+class SerializationUUID : public SimpleTextSerialization\n {\n public:\n     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n@@ -18,6 +18,13 @@ class SerializationUUID : public SerializationNumber<UInt128>\n     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;\n+\n+    void serializeBinary(const Field & field, WriteBuffer & ostr) const override;\n+    void deserializeBinary(Field & field, ReadBuffer & istr) const override;\n+    void serializeBinary(const IColumn & column, size_t row_num, WriteBuffer & ostr) const override;\n+    void deserializeBinary(IColumn & column, ReadBuffer & istr) const override;\n+    void serializeBinaryBulk(const IColumn & column, WriteBuffer & ostr, size_t offset, size_t limit) const override;\n+    void deserializeBinaryBulk(IColumn & column, ReadBuffer & istr, size_t limit, double avg_value_size_hint) const override;\n };\n \n }\ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex 31e8613a88e4..a04d16ef7cd7 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -390,6 +390,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n                 maximize(max_bits_of_unsigned_integer, 32);\n             else if (typeid_cast<const DataTypeUInt64 *>(type.get()))\n                 maximize(max_bits_of_unsigned_integer, 64);\n+            else if (typeid_cast<const DataTypeUInt128 *>(type.get()))\n+                maximize(max_bits_of_unsigned_integer, 128);\n             else if (typeid_cast<const DataTypeUInt256 *>(type.get()))\n                 maximize(max_bits_of_unsigned_integer, 256);\n             else if (typeid_cast<const DataTypeInt8 *>(type.get()) || typeid_cast<const DataTypeEnum8 *>(type.get()))\n@@ -482,6 +484,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n                     return std::make_shared<DataTypeUInt32>();\n                 else if (min_bit_width_of_integer <= 64)\n                     return std::make_shared<DataTypeUInt64>();\n+                else if (min_bit_width_of_integer <= 128)\n+                    return std::make_shared<DataTypeUInt128>();\n                 else if (min_bit_width_of_integer <= 256)\n                     return std::make_shared<DataTypeUInt256>();\n                 else\ndiff --git a/src/Dictionaries/CacheDictionaryStorage.h b/src/Dictionaries/CacheDictionaryStorage.h\nindex 720800e63577..a79d83eea057 100644\n--- a/src/Dictionaries/CacheDictionaryStorage.h\n+++ b/src/Dictionaries/CacheDictionaryStorage.h\n@@ -594,16 +594,20 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n             PaddedPODArray<UInt32>,\n             PaddedPODArray<UInt64>,\n             PaddedPODArray<UInt128>,\n+            PaddedPODArray<UInt256>,\n             PaddedPODArray<Int8>,\n             PaddedPODArray<Int16>,\n             PaddedPODArray<Int32>,\n             PaddedPODArray<Int64>,\n+            PaddedPODArray<Int128>,\n+            PaddedPODArray<Int256>,\n             PaddedPODArray<Decimal32>,\n             PaddedPODArray<Decimal64>,\n             PaddedPODArray<Decimal128>,\n             PaddedPODArray<Decimal256>,\n             PaddedPODArray<Float32>,\n             PaddedPODArray<Float64>,\n+            PaddedPODArray<UUID>,\n             PaddedPODArray<StringRef>,\n             std::vector<Field>> attribute_container;\n     };\ndiff --git a/src/Dictionaries/CassandraBlockInputStream.cpp b/src/Dictionaries/CassandraBlockInputStream.cpp\nindex 4e71c2124515..9afc0069d480 100644\n--- a/src/Dictionaries/CassandraBlockInputStream.cpp\n+++ b/src/Dictionaries/CassandraBlockInputStream.cpp\n@@ -138,7 +138,7 @@ void CassandraBlockInputStream::insertValue(IColumn & column, ValueType type, co\n             cass_value_get_uuid(cass_value, &value);\n             std::array<char, CASS_UUID_STRING_LENGTH> uuid_str;\n             cass_uuid_string(value, uuid_str.data());\n-            assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(uuid_str.data(), uuid_str.size()));\n+            assert_cast<ColumnUUID &>(column).insert(parse<UUID>(uuid_str.data(), uuid_str.size()));\n             break;\n         }\n         default:\ndiff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex c2071d8136ae..6d459bab85f6 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -243,13 +243,19 @@ class DictionaryAttributeColumnProvider\n         {\n             return ColumnType::create();\n         }\n-        if constexpr (IsDecimalNumber<DictionaryAttributeType>)\n+        else if constexpr (std::is_same_v<DictionaryAttributeType, UUID>)\n+        {\n+            return ColumnType::create(size);\n+        }\n+        else if constexpr (IsDecimalNumber<DictionaryAttributeType>)\n         {\n             auto scale = getDecimalScale(*dictionary_attribute.nested_type);\n             return ColumnType::create(size, scale);\n         }\n-        else if constexpr (IsNumber<DictionaryAttributeType>)\n+        else if constexpr (is_arithmetic_v<DictionaryAttributeType>)\n+        {\n             return ColumnType::create(size);\n+        }\n         else\n             throw Exception(ErrorCodes::TYPE_MISMATCH, \"Unsupported attribute type.\");\n     }\n@@ -563,7 +569,7 @@ static const PaddedPODArray<T> & getColumnVectorData(\n         throw Exception(ErrorCodes::TYPE_MISMATCH,\n             \"{}: type mismatch: column has wrong type expected {}\",\n             dictionary->getDictionaryID().getNameForLogs(),\n-            TypeName<T>::get());\n+            TypeName<T>);\n     }\n \n     if (is_const_column)\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex dd53e31041bd..c0d00d3ae40d 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -14,6 +14,7 @@\n #include <unordered_set>\n #include <ext/range.h>\n \n+\n namespace DB\n {\n namespace ErrorCodes\n@@ -48,36 +49,39 @@ AttributeUnderlyingType getAttributeUnderlyingType(const DataTypePtr & type)\n \n     switch (type_index)\n     {\n-        case TypeIndex::UInt8:          return AttributeUnderlyingType::utUInt8;\n-        case TypeIndex::UInt16:         return AttributeUnderlyingType::utUInt16;\n-        case TypeIndex::UInt32:         return AttributeUnderlyingType::utUInt32;\n-        case TypeIndex::UInt64:         return AttributeUnderlyingType::utUInt64;\n-        case TypeIndex::UInt128:        return AttributeUnderlyingType::utUInt128;\n+        case TypeIndex::UInt8:          return AttributeUnderlyingType::UInt8;\n+        case TypeIndex::UInt16:         return AttributeUnderlyingType::UInt16;\n+        case TypeIndex::UInt32:         return AttributeUnderlyingType::UInt32;\n+        case TypeIndex::UInt64:         return AttributeUnderlyingType::UInt64;\n+        case TypeIndex::UInt128:        return AttributeUnderlyingType::UInt128;\n+        case TypeIndex::UInt256:        return AttributeUnderlyingType::UInt256;\n \n-        case TypeIndex::Int8:           return AttributeUnderlyingType::utInt8;\n-        case TypeIndex::Int16:          return AttributeUnderlyingType::utInt16;\n-        case TypeIndex::Int32:          return AttributeUnderlyingType::utInt32;\n-        case TypeIndex::Int64:          return AttributeUnderlyingType::utInt64;\n+        case TypeIndex::Int8:           return AttributeUnderlyingType::Int8;\n+        case TypeIndex::Int16:          return AttributeUnderlyingType::Int16;\n+        case TypeIndex::Int32:          return AttributeUnderlyingType::Int32;\n+        case TypeIndex::Int64:          return AttributeUnderlyingType::Int64;\n+        case TypeIndex::Int128:         return AttributeUnderlyingType::Int128;\n+        case TypeIndex::Int256:         return AttributeUnderlyingType::Int256;\n \n-        case TypeIndex::Float32:        return AttributeUnderlyingType::utFloat32;\n-        case TypeIndex::Float64:        return AttributeUnderlyingType::utFloat64;\n+        case TypeIndex::Float32:        return AttributeUnderlyingType::Float32;\n+        case TypeIndex::Float64:        return AttributeUnderlyingType::Float64;\n \n-        case TypeIndex::Decimal32:      return AttributeUnderlyingType::utDecimal32;\n-        case TypeIndex::Decimal64:      return AttributeUnderlyingType::utDecimal64;\n-        case TypeIndex::Decimal128:     return AttributeUnderlyingType::utDecimal128;\n-        case TypeIndex::Decimal256:     return AttributeUnderlyingType::utDecimal256;\n+        case TypeIndex::Decimal32:      return AttributeUnderlyingType::Decimal32;\n+        case TypeIndex::Decimal64:      return AttributeUnderlyingType::Decimal64;\n+        case TypeIndex::Decimal128:     return AttributeUnderlyingType::Decimal128;\n+        case TypeIndex::Decimal256:     return AttributeUnderlyingType::Decimal256;\n \n-        case TypeIndex::Date:           return AttributeUnderlyingType::utUInt16;\n-        case TypeIndex::DateTime:       return AttributeUnderlyingType::utUInt32;\n-        case TypeIndex::DateTime64:     return AttributeUnderlyingType::utUInt64;\n+        case TypeIndex::Date:           return AttributeUnderlyingType::UInt16;\n+        case TypeIndex::DateTime:       return AttributeUnderlyingType::UInt32;\n+        case TypeIndex::DateTime64:     return AttributeUnderlyingType::UInt64;\n \n-        case TypeIndex::UUID:           return AttributeUnderlyingType::utUInt128;\n+        case TypeIndex::UUID:           return AttributeUnderlyingType::UUID;\n \n-        case TypeIndex::String:         return AttributeUnderlyingType::utString;\n+        case TypeIndex::String:         return AttributeUnderlyingType::String;\n \n         // Temporary hack to allow arrays in keys, since they are never retrieved for polygon dictionaries.\n         // TODO: This should be fixed by fully supporting arrays in dictionaries.\n-        case TypeIndex::Array:          return AttributeUnderlyingType::utString;\n+        case TypeIndex::Array:          return AttributeUnderlyingType::String;\n \n         default: break;\n     }\n@@ -90,38 +94,9 @@ std::string toString(AttributeUnderlyingType type)\n {\n     switch (type)\n     {\n-        case AttributeUnderlyingType::utUInt8:\n-            return \"UInt8\";\n-        case AttributeUnderlyingType::utUInt16:\n-            return \"UInt16\";\n-        case AttributeUnderlyingType::utUInt32:\n-            return \"UInt32\";\n-        case AttributeUnderlyingType::utUInt64:\n-            return \"UInt64\";\n-        case AttributeUnderlyingType::utUInt128:\n-            return \"UUID\";\n-        case AttributeUnderlyingType::utInt8:\n-            return \"Int8\";\n-        case AttributeUnderlyingType::utInt16:\n-            return \"Int16\";\n-        case AttributeUnderlyingType::utInt32:\n-            return \"Int32\";\n-        case AttributeUnderlyingType::utInt64:\n-            return \"Int64\";\n-        case AttributeUnderlyingType::utFloat32:\n-            return \"Float32\";\n-        case AttributeUnderlyingType::utFloat64:\n-            return \"Float64\";\n-        case AttributeUnderlyingType::utDecimal32:\n-            return \"Decimal32\";\n-        case AttributeUnderlyingType::utDecimal64:\n-            return \"Decimal64\";\n-        case AttributeUnderlyingType::utDecimal128:\n-            return \"Decimal128\";\n-        case AttributeUnderlyingType::utDecimal256:\n-            return \"Decimal256\";\n-        case AttributeUnderlyingType::utString:\n-            return \"String\";\n+#define M(TYPE) case AttributeUnderlyingType::TYPE: return #TYPE;\n+    FOR_ATTRIBUTE_TYPES(M)\n+#undef M\n     }\n \n     throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Unknown dictionary attribute type {}\", toString(static_cast<int>(type)));\n@@ -208,7 +183,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n \n         if (attribute.hierarchical)\n         {\n-            if (id && attribute.underlying_type != AttributeUnderlyingType::utUInt64)\n+            if (id && attribute.underlying_type != AttributeUnderlyingType::UInt64)\n                 throw Exception(ErrorCodes::TYPE_MISMATCH,\n                     \"Hierarchical attribute type for dictionary with simple key must be UInt64. Actual {}\",\n                     toString(attribute.underlying_type));\n@@ -320,7 +295,7 @@ bool DictionaryStructure::isKeySizeFixed() const\n         return true;\n \n     for (const auto & key_i : *key)\n-        if (key_i.underlying_type == AttributeUnderlyingType::utString)\n+        if (key_i.underlying_type == AttributeUnderlyingType::String)\n             return false;\n \n     return true;\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex ce5dd3dd422c..4815501b6962 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -5,7 +5,6 @@\n #include <string>\n #include <vector>\n \n-\n #include <Poco/Util/AbstractConfiguration.h>\n \n #include <Core/Field.h>\n@@ -13,27 +12,43 @@\n #include <DataTypes/IDataType.h>\n #include <Interpreters/IExternalLoadable.h>\n \n+#if defined(__GNUC__)\n+    /// GCC mistakenly warns about the names in enum class.\n+    #pragma GCC diagnostic ignored \"-Wshadow\"\n+#endif\n+\n+\n+#define FOR_ATTRIBUTE_TYPES(M) \\\n+    M(UInt8) \\\n+    M(UInt16) \\\n+    M(UInt32) \\\n+    M(UInt64) \\\n+    M(UInt128) \\\n+    M(UInt256) \\\n+    M(Int8) \\\n+    M(Int16) \\\n+    M(Int32) \\\n+    M(Int64) \\\n+    M(Int128) \\\n+    M(Int256) \\\n+    M(Float32) \\\n+    M(Float64) \\\n+    M(Decimal32) \\\n+    M(Decimal64) \\\n+    M(Decimal128) \\\n+    M(Decimal256) \\\n+    M(UUID) \\\n+    M(String) \\\n+\n+\n namespace DB\n {\n \n enum class AttributeUnderlyingType\n {\n-    utUInt8,\n-    utUInt16,\n-    utUInt32,\n-    utUInt64,\n-    utUInt128,\n-    utInt8,\n-    utInt16,\n-    utInt32,\n-    utInt64,\n-    utFloat32,\n-    utFloat64,\n-    utDecimal32,\n-    utDecimal64,\n-    utDecimal128,\n-    utDecimal256,\n-    utString\n+#define M(TYPE) TYPE,\n+    FOR_ATTRIBUTE_TYPES(M)\n+#undef M\n };\n \n \n@@ -81,54 +96,12 @@ void callOnDictionaryAttributeType(AttributeUnderlyingType type, F&& func)\n {\n     switch (type)\n     {\n-        case AttributeUnderlyingType::utUInt8:\n-            func(DictionaryAttributeType<UInt8>());\n-            break;\n-        case AttributeUnderlyingType::utUInt16:\n-            func(DictionaryAttributeType<UInt16>());\n-            break;\n-        case AttributeUnderlyingType::utUInt32:\n-            func(DictionaryAttributeType<UInt32>());\n-            break;\n-        case AttributeUnderlyingType::utUInt64:\n-            func(DictionaryAttributeType<UInt64>());\n-            break;\n-        case AttributeUnderlyingType::utUInt128:\n-            func(DictionaryAttributeType<UInt128>());\n-            break;\n-        case AttributeUnderlyingType::utInt8:\n-            func(DictionaryAttributeType<Int8>());\n-            break;\n-        case AttributeUnderlyingType::utInt16:\n-            func(DictionaryAttributeType<Int16>());\n-            break;\n-        case AttributeUnderlyingType::utInt32:\n-            func(DictionaryAttributeType<Int32>());\n-            break;\n-        case AttributeUnderlyingType::utInt64:\n-            func(DictionaryAttributeType<Int64>());\n-            break;\n-        case AttributeUnderlyingType::utFloat32:\n-            func(DictionaryAttributeType<Float32>());\n-            break;\n-        case AttributeUnderlyingType::utFloat64:\n-            func(DictionaryAttributeType<Float64>());\n-            break;\n-        case AttributeUnderlyingType::utString:\n-            func(DictionaryAttributeType<String>());\n-            break;\n-        case AttributeUnderlyingType::utDecimal32:\n-            func(DictionaryAttributeType<Decimal32>());\n-            break;\n-        case AttributeUnderlyingType::utDecimal64:\n-            func(DictionaryAttributeType<Decimal64>());\n-            break;\n-        case AttributeUnderlyingType::utDecimal128:\n-            func(DictionaryAttributeType<Decimal128>());\n-            break;\n-        case AttributeUnderlyingType::utDecimal256:\n-            func(DictionaryAttributeType<Decimal256>());\n+#define M(TYPE) \\\n+        case AttributeUnderlyingType::TYPE: \\\n+            func(DictionaryAttributeType<TYPE>()); \\\n             break;\n+    FOR_ATTRIBUTE_TYPES(M)\n+#undef M\n     }\n };\n \ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex 61a1099aa6df..211b1cdc33dc 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -121,16 +121,20 @@ class FlatDictionary final : public IDictionary\n             UInt32,\n             UInt64,\n             UInt128,\n+            UInt256,\n             Int8,\n             Int16,\n             Int32,\n             Int64,\n+            Int128,\n+            Int256,\n             Decimal32,\n             Decimal64,\n             Decimal128,\n             Decimal256,\n             Float32,\n             Float64,\n+            UUID,\n             StringRef>\n             null_values;\n         std::variant<\n@@ -139,16 +143,20 @@ class FlatDictionary final : public IDictionary\n             ContainerType<UInt32>,\n             ContainerType<UInt64>,\n             ContainerType<UInt128>,\n+            ContainerType<UInt256>,\n             ContainerType<Int8>,\n             ContainerType<Int16>,\n             ContainerType<Int32>,\n             ContainerType<Int64>,\n+            ContainerType<Int128>,\n+            ContainerType<Int256>,\n             ContainerType<Decimal32>,\n             ContainerType<Decimal64>,\n             ContainerType<Decimal128>,\n             ContainerType<Decimal256>,\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n+            ContainerType<UUID>,\n             ContainerType<StringRef>>\n             container;\n \ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex eeb873fb190a..cc04c6805eef 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -153,16 +153,20 @@ class HashedDictionary final : public IDictionary\n             UInt32,\n             UInt64,\n             UInt128,\n+            UInt256,\n             Int8,\n             Int16,\n             Int32,\n             Int64,\n+            Int128,\n+            Int256,\n             Decimal32,\n             Decimal64,\n             Decimal128,\n             Decimal256,\n             Float32,\n             Float64,\n+            UUID,\n             StringRef>\n             null_values;\n \n@@ -172,16 +176,20 @@ class HashedDictionary final : public IDictionary\n             CollectionType<UInt32>,\n             CollectionType<UInt64>,\n             CollectionType<UInt128>,\n+            CollectionType<UInt256>,\n             CollectionType<Int8>,\n             CollectionType<Int16>,\n             CollectionType<Int32>,\n             CollectionType<Int64>,\n+            CollectionType<Int128>,\n+            CollectionType<Int256>,\n             CollectionType<Decimal32>,\n             CollectionType<Decimal64>,\n             CollectionType<Decimal128>,\n             CollectionType<Decimal256>,\n             CollectionType<Float32>,\n             CollectionType<Float64>,\n+            CollectionType<UUID>,\n             CollectionType<StringRef>>\n             container;\n \ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex 9c58a93de8ac..edca68aedbaa 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -102,16 +102,20 @@ class IPAddressDictionary final : public IDictionary\n             UInt32,\n             UInt64,\n             UInt128,\n+            UInt256,\n             Int8,\n             Int16,\n             Int32,\n             Int64,\n+            Int128,\n+            Int256,\n             Decimal32,\n             Decimal64,\n             Decimal128,\n             Decimal256,\n             Float32,\n             Float64,\n+            UUID,\n             String>\n             null_values;\n         std::variant<\n@@ -120,16 +124,20 @@ class IPAddressDictionary final : public IDictionary\n             ContainerType<UInt32>,\n             ContainerType<UInt64>,\n             ContainerType<UInt128>,\n+            ContainerType<UInt256>,\n             ContainerType<Int8>,\n             ContainerType<Int16>,\n             ContainerType<Int32>,\n             ContainerType<Int64>,\n+            ContainerType<Int128>,\n+            ContainerType<Int256>,\n             ContainerType<Decimal32>,\n             ContainerType<Decimal64>,\n             ContainerType<Decimal128>,\n             ContainerType<Decimal256>,\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n+            ContainerType<UUID>,\n             ContainerType<StringRef>>\n             maps;\n         std::unique_ptr<Arena> string_arena;\ndiff --git a/src/Dictionaries/MongoDBDictionarySource.cpp b/src/Dictionaries/MongoDBDictionarySource.cpp\nindex 0ab45dc45938..634951740377 100644\n--- a/src/Dictionaries/MongoDBDictionarySource.cpp\n+++ b/src/Dictionaries/MongoDBDictionarySource.cpp\n@@ -50,7 +50,6 @@ void registerDictionarySourceMongoDB(DictionarySourceFactory & factory)\n // Poco/MongoDB/BSONWriter.h:54: void writeCString(const std::string & value);\n // src/IO/WriteHelpers.h:146 #define writeCString(s, buf)\n #include <IO/WriteHelpers.h>\n-#include <Common/FieldVisitors.h>\n #include <ext/enumerate.h>\n #include <DataStreams/MongoDBBlockInputStream.h>\n \n@@ -59,6 +58,7 @@ namespace DB\n {\n namespace ErrorCodes\n {\n+    extern const int NOT_IMPLEMENTED;\n     extern const int UNSUPPORTED_METHOD;\n     extern const int MONGODB_CANNOT_AUTHENTICATE;\n }\n@@ -186,28 +186,26 @@ BlockInputStreamPtr MongoDBDictionarySource::loadKeys(const Columns & key_column\n         {\n             switch (attr.second.underlying_type)\n             {\n-                case AttributeUnderlyingType::utUInt8:\n-                case AttributeUnderlyingType::utUInt16:\n-                case AttributeUnderlyingType::utUInt32:\n-                case AttributeUnderlyingType::utUInt64:\n-                case AttributeUnderlyingType::utUInt128:\n-                case AttributeUnderlyingType::utInt8:\n-                case AttributeUnderlyingType::utInt16:\n-                case AttributeUnderlyingType::utInt32:\n-                case AttributeUnderlyingType::utInt64:\n-                case AttributeUnderlyingType::utDecimal32:\n-                case AttributeUnderlyingType::utDecimal64:\n-                case AttributeUnderlyingType::utDecimal128:\n-                case AttributeUnderlyingType::utDecimal256:\n+                case AttributeUnderlyingType::UInt8:\n+                case AttributeUnderlyingType::UInt16:\n+                case AttributeUnderlyingType::UInt32:\n+                case AttributeUnderlyingType::UInt64:\n+                case AttributeUnderlyingType::Int8:\n+                case AttributeUnderlyingType::Int16:\n+                case AttributeUnderlyingType::Int32:\n+                case AttributeUnderlyingType::Int64:\n+                {\n                     key.add(attr.second.name, Int32(key_columns[attr.first]->get64(row_idx)));\n                     break;\n-\n-                case AttributeUnderlyingType::utFloat32:\n-                case AttributeUnderlyingType::utFloat64:\n+                }\n+                case AttributeUnderlyingType::Float32:\n+                case AttributeUnderlyingType::Float64:\n+                {\n                     key.add(attr.second.name, key_columns[attr.first]->getFloat64(row_idx));\n                     break;\n-\n-                case AttributeUnderlyingType::utString:\n+                }\n+                case AttributeUnderlyingType::String:\n+                {\n                     String loaded_str(get<String>((*key_columns[attr.first])[row_idx]));\n                     /// Convert string to ObjectID\n                     if (attr.second.is_object_id)\n@@ -220,6 +218,9 @@ BlockInputStreamPtr MongoDBDictionarySource::loadKeys(const Columns & key_column\n                         key.add(attr.second.name, loaded_str);\n                     }\n                     break;\n+                }\n+                default:\n+                    throw Exception(\"Unsupported dictionary attribute type for MongoDB dictionary source\", ErrorCodes::NOT_IMPLEMENTED);\n             }\n         }\n     }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 76dc00135685..edd8275acd1c 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -113,16 +113,20 @@ class RangeHashedDictionary final : public IDictionary\n             UInt32,\n             UInt64,\n             UInt128,\n+            UInt256,\n             Int8,\n             Int16,\n             Int32,\n             Int64,\n+            Int128,\n+            Int256,\n             Decimal32,\n             Decimal64,\n             Decimal128,\n             Decimal256,\n             Float32,\n             Float64,\n+            UUID,\n             StringRef>\n             null_values;\n         std::variant<\n@@ -131,16 +135,20 @@ class RangeHashedDictionary final : public IDictionary\n             Ptr<UInt32>,\n             Ptr<UInt64>,\n             Ptr<UInt128>,\n+            Ptr<UInt256>,\n             Ptr<Int8>,\n             Ptr<Int16>,\n             Ptr<Int32>,\n             Ptr<Int64>,\n+            Ptr<Int128>,\n+            Ptr<Int256>,\n             Ptr<Decimal32>,\n             Ptr<Decimal64>,\n             Ptr<Decimal128>,\n             Ptr<Decimal256>,\n             Ptr<Float32>,\n             Ptr<Float64>,\n+            Ptr<UUID>,\n             Ptr<StringRef>>\n             maps;\n         std::unique_ptr<Arena> string_arena;\ndiff --git a/src/Dictionaries/RedisBlockInputStream.cpp b/src/Dictionaries/RedisBlockInputStream.cpp\nindex f74ac348a99d..bb8ef92eeea7 100644\n--- a/src/Dictionaries/RedisBlockInputStream.cpp\n+++ b/src/Dictionaries/RedisBlockInputStream.cpp\n@@ -109,7 +109,7 @@ namespace DB\n                     break;\n                 }\n                 case ValueType::vtUUID:\n-                    assert_cast<ColumnUInt128 &>(column).insertValue(parse<UUID>(string_value));\n+                    assert_cast<ColumnUUID &>(column).insertValue(parse<UUID>(string_value));\n                     break;\n                 default:\n                     throw Exception(ErrorCodes::UNKNOWN_TYPE,\ndiff --git a/src/Dictionaries/RedisDictionarySource.cpp b/src/Dictionaries/RedisDictionarySource.cpp\nindex 8144b37e63df..f62dc0d74bd9 100644\n--- a/src/Dictionaries/RedisDictionarySource.cpp\n+++ b/src/Dictionaries/RedisDictionarySource.cpp\n@@ -30,7 +30,6 @@ void registerDictionarySourceRedis(DictionarySourceFactory & factory)\n #include <Poco/Util/AbstractConfiguration.h>\n \n #include <IO/WriteHelpers.h>\n-#include <Common/FieldVisitors.h>\n \n #include \"RedisBlockInputStream.h\"\n \ndiff --git a/src/Formats/MySQLBlockInputStream.cpp b/src/Formats/MySQLBlockInputStream.cpp\nindex be0cb31f22d2..b12b4f755ed2 100644\n--- a/src/Formats/MySQLBlockInputStream.cpp\n+++ b/src/Formats/MySQLBlockInputStream.cpp\n@@ -177,8 +177,8 @@ namespace\n                 break;\n             }\n             case ValueType::vtUUID:\n-                assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(value.data(), value.size()));\n-                read_bytes_size += assert_cast<ColumnUInt128 &>(column).byteSize();\n+                assert_cast<ColumnUUID &>(column).insert(parse<UUID>(value.data(), value.size()));\n+                read_bytes_size += assert_cast<ColumnUUID &>(column).byteSize();\n                 break;\n             case ValueType::vtDateTime64:[[fallthrough]];\n             case ValueType::vtDecimal32: [[fallthrough]];\ndiff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp\nindex 3539628f98e9..962df507f824 100644\n--- a/src/Formats/ProtobufSerializer.cpp\n+++ b/src/Formats/ProtobufSerializer.cpp\n@@ -237,7 +237,7 @@ namespace\n             }\n             catch (...)\n             {\n-                cannotConvertValue(str, \"String\", TypeName<DestType>::get());\n+                cannotConvertValue(str, \"String\", TypeName<DestType>);\n             }\n         }\n \n@@ -254,7 +254,7 @@ namespace\n             }\n             catch (boost::numeric::bad_numeric_cast &)\n             {\n-                cannotConvertValue(toString(value), TypeName<SrcType>::get(), TypeName<DestType>::get());\n+                cannotConvertValue(toString(value), TypeName<SrcType>, TypeName<DestType>);\n             }\n             return result;\n         }\n@@ -429,7 +429,7 @@ namespace\n                         else if (value == 1)\n                             writeUInt(1);\n                         else\n-                            cannotConvertValue(toString(value), TypeName<NumberType>::get(), field_descriptor.type_name());\n+                            cannotConvertValue(toString(value), TypeName<NumberType>, field_descriptor.type_name());\n                     };\n \n                     read_function = [this]() -> NumberType\n@@ -438,7 +438,7 @@ namespace\n                         if (u64 < 2)\n                             return static_cast<NumberType>(u64);\n                         else\n-                            cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<NumberType>::get());\n+                            cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<NumberType>);\n                     };\n \n                     default_function = [this]() -> NumberType { return static_cast<NumberType>(field_descriptor.default_value_bool()); };\n@@ -492,7 +492,7 @@ namespace\n         {\n             throw Exception(\n                 \"The field \" + quoteString(field_descriptor.full_name()) + \" has an incompatible type \" + field_descriptor.type_name()\n-                    + \" for serialization of the data type \" + quoteString(TypeName<NumberType>::get()),\n+                    + \" for serialization of the data type \" + quoteString(TypeName<NumberType>),\n                 ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);\n         }\n \n@@ -507,7 +507,7 @@ namespace\n         {\n             const auto * enum_value_descriptor = field_descriptor.enum_type()->FindValueByNumber(value);\n             if (!enum_value_descriptor)\n-                cannotConvertValue(toString(value), TypeName<NumberType>::get(), field_descriptor.type_name());\n+                cannotConvertValue(toString(value), TypeName<NumberType>, field_descriptor.type_name());\n         }\n \n     protected:\n@@ -1240,7 +1240,7 @@ namespace\n                             {\n                                 WriteBufferFromOwnString buf;\n                                 writeText(decimal, scale, buf);\n-                                cannotConvertValue(buf.str(), TypeName<DecimalType>::get(), field_descriptor.type_name());\n+                                cannotConvertValue(buf.str(), TypeName<DecimalType>, field_descriptor.type_name());\n                             }\n                         };\n \n@@ -1250,7 +1250,7 @@ namespace\n                             if (u64 < 2)\n                                 return numberToDecimal(static_cast<UInt64>(u64 != 0));\n                             else\n-                                cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<DecimalType>::get());\n+                                cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<DecimalType>);\n                         };\n \n                         default_function = [this]() -> DecimalType\n@@ -1289,7 +1289,7 @@ namespace\n         {\n             throw Exception(\n                 \"The field \" + quoteString(field_descriptor.full_name()) + \" has an incompatible type \" + field_descriptor.type_name()\n-                    + \" for serialization of the data type \" + quoteString(TypeName<DecimalType>::get()),\n+                    + \" for serialization of the data type \" + quoteString(TypeName<DecimalType>),\n                 ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);\n         }\n \n@@ -1503,18 +1503,42 @@ namespace\n     };\n \n \n-    /// Serializes a ColumnVector<UInt128> containing UUIDs to a field of type TYPE_STRING or TYPE_BYTES.\n-    class ProtobufSerializerUUID : public ProtobufSerializerNumber<UInt128>\n+    /// Serializes a ColumnVector<UUID> containing UUIDs to a field of type TYPE_STRING or TYPE_BYTES.\n+    class ProtobufSerializerUUID : public ProtobufSerializerSingleValue\n     {\n     public:\n         ProtobufSerializerUUID(\n             const google::protobuf::FieldDescriptor & field_descriptor_,\n             const ProtobufReaderOrWriter & reader_or_writer_)\n-            : ProtobufSerializerNumber<UInt128>(field_descriptor_, reader_or_writer_)\n+            : ProtobufSerializerSingleValue(field_descriptor_, reader_or_writer_)\n         {\n             setFunctions();\n         }\n \n+        void writeRow(size_t row_num) override\n+        {\n+            const auto & column_vector = assert_cast<const ColumnVector<UUID> &>(*column);\n+            write_function(column_vector.getElement(row_num));\n+        }\n+\n+        void readRow(size_t row_num) override\n+        {\n+            UUID value = read_function();\n+            auto & column_vector = assert_cast<ColumnVector<UUID> &>(column->assumeMutableRef());\n+            if (row_num < column_vector.size())\n+                column_vector.getElement(row_num) = value;\n+            else\n+                column_vector.insertValue(value);\n+        }\n+\n+        void insertDefaults(size_t row_num) override\n+        {\n+            auto & column_vector = assert_cast<ColumnVector<UUID> &>(column->assumeMutableRef());\n+            if (row_num < column_vector.size())\n+                return;\n+            column_vector.insertDefault();\n+        }\n+\n     private:\n         void setFunctions()\n         {\n@@ -1526,19 +1550,19 @@ namespace\n                     ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);\n             }\n \n-            write_function = [this](UInt128 value)\n+            write_function = [this](UUID value)\n             {\n-                uuidToString(static_cast<UUID>(value), text_buffer);\n+                uuidToString(value, text_buffer);\n                 writeStr(text_buffer);\n             };\n \n-            read_function = [this]() -> UInt128\n+            read_function = [this]() -> UUID\n             {\n                 readStr(text_buffer);\n-                return stringToUUID(text_buffer);\n+                return parse<UUID>(text_buffer);\n             };\n \n-            default_function = [this]() -> UInt128 { return stringToUUID(field_descriptor.default_value_string()); };\n+            default_function = [this]() -> UUID { return parse<UUID>(field_descriptor.default_value_string()); };\n         }\n \n         static void uuidToString(const UUID & uuid, String & str)\n@@ -1547,13 +1571,10 @@ namespace\n             writeText(uuid, buf);\n         }\n \n-        static UUID stringToUUID(const String & str)\n-        {\n-            ReadBufferFromString buf{str};\n-            UUID uuid;\n-            readUUIDText(uuid, buf);\n-            return uuid;\n-        }\n+        std::function<void(UUID)> write_function;\n+        std::function<UUID()> read_function;\n+        std::function<UUID()> default_function;\n+        String text_buffer;\n     };\n \n \ndiff --git a/src/Functions/CustomWeekTransforms.h b/src/Functions/CustomWeekTransforms.h\nindex 28da546eb93a..98b7c38f2668 100644\n--- a/src/Functions/CustomWeekTransforms.h\n+++ b/src/Functions/CustomWeekTransforms.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <regex>\n+\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnsNumber.h>\n #include <common/types.h>\n@@ -13,6 +13,7 @@\n /// The default mode value to use for the WEEK() function\n #define DEFAULT_WEEK_MODE 0\n \n+\n namespace DB\n {\n namespace ErrorCodes\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex c299b9c4169c..86cac4f42226 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -1,9 +1,9 @@\n #pragma once\n+\n #include <common/types.h>\n #include <Core/DecimalFunctions.h>\n #include <Common/Exception.h>\n #include <common/DateLUTImpl.h>\n-//#include <common/TimeZone.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnDecimal.h>\n #include <Functions/FunctionHelpers.h>\n@@ -12,6 +12,7 @@\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n \n+\n namespace DB\n {\n \n@@ -857,7 +858,8 @@ struct Transformer\n template <typename FromDataType, typename ToDataType, typename Transform>\n struct DateTimeTransformImpl\n {\n-    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})\n+    static ColumnPtr execute(\n+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})\n     {\n         using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>;\n \ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex e6c3a50a206e..508c598b0ede 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -5,7 +5,7 @@\n // sanitizer/asan_interface.h\n #include <memory>\n #include <type_traits>\n-#include <Common/Arena.h>\n+#include <common/wide_integer_to_string.h>\n \n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypesDecimal.h>\n@@ -29,6 +29,7 @@\n #include \"DivisionUtils.h\"\n #include \"castTypeToEither.h\"\n #include \"FunctionFactory.h\"\n+#include <Common/Arena.h>\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n #include <Common/FieldVisitors.h>\n@@ -86,6 +87,7 @@ template <> inline constexpr bool IsIntegral<DataTypeInt32> = true;\n template <> inline constexpr bool IsIntegral<DataTypeInt64> = true;\n \n template <typename DataType> constexpr bool IsExtended = false;\n+template <> inline constexpr bool IsExtended<DataTypeUInt128> = true;\n template <> inline constexpr bool IsExtended<DataTypeUInt256> = true;\n template <> inline constexpr bool IsExtended<DataTypeInt128> = true;\n template <> inline constexpr bool IsExtended<DataTypeInt256> = true;\n@@ -523,6 +525,7 @@ class FunctionBinaryArithmetic : public IFunction\n             DataTypeUInt16,\n             DataTypeUInt32,\n             DataTypeUInt64,\n+            DataTypeUInt128,\n             DataTypeUInt256,\n             DataTypeInt8,\n             DataTypeInt16,\n@@ -550,6 +553,7 @@ class FunctionBinaryArithmetic : public IFunction\n             DataTypeUInt16,\n             DataTypeUInt32,\n             DataTypeUInt64,\n+            DataTypeUInt128,\n             DataTypeUInt256,\n             DataTypeInt8,\n             DataTypeInt16,\n@@ -782,7 +786,7 @@ class FunctionBinaryArithmetic : public IFunction\n         return function->execute(new_arguments, result_type, input_rows_count);\n     }\n \n-    template <class T, class ResultDataType, class CC, class C>\n+    template <typename T, typename ResultDataType, typename CC, typename C>\n     static auto helperGetOrConvert(const CC & col_const, const C & col)\n     {\n         using ResultType = typename ResultDataType::FieldType;\n@@ -790,12 +794,14 @@ class FunctionBinaryArithmetic : public IFunction\n \n         if constexpr (IsFloatingPoint<ResultDataType> && IsDecimalNumber<T>)\n             return DecimalUtils::convertTo<NativeResultType>(col_const->template getValue<T>(), col.getScale());\n+        else if constexpr (IsDecimalNumber<T>)\n+            return col_const->template getValue<T>().value;\n         else\n             return col_const->template getValue<T>();\n     }\n \n-    template <OpCase op_case, bool left_decimal, bool right_decimal, class OpImpl, class OpImplCheck,\n-              class L, class R, class VR, class SA, class SB>\n+    template <OpCase op_case, bool left_decimal, bool right_decimal, typename OpImpl, typename OpImplCheck,\n+              typename L, typename R, typename VR, typename SA, typename SB>\n     void helperInvokeEither(const L& left, const R& right, VR& vec_res, SA scale_a, SB scale_b) const\n     {\n         if (check_decimal_overflow)\ndiff --git a/src/Functions/FunctionFactory.h b/src/Functions/FunctionFactory.h\nindex 96238a884206..7a49c79e2bf7 100644\n--- a/src/Functions/FunctionFactory.h\n+++ b/src/Functions/FunctionFactory.h\n@@ -51,6 +51,13 @@ class FunctionFactory : private boost::noncopyable,\n     FunctionOverloadResolverImplPtr getImpl(const std::string & name, ContextPtr context) const;\n     FunctionOverloadResolverImplPtr tryGetImpl(const std::string & name, ContextPtr context) const;\n \n+    /// Register a function by its name.\n+    /// No locking, you must register all functions before usage of get.\n+    void registerFunction(\n+        const std::string & name,\n+        Value creator,\n+        CaseSensitiveness case_sensitiveness = CaseSensitive);\n+\n private:\n     using Functions = std::unordered_map<std::string, Value>;\n \n@@ -68,13 +75,6 @@ class FunctionFactory : private boost::noncopyable,\n     const Functions & getCaseInsensitiveMap() const override { return case_insensitive_functions; }\n \n     String getFactoryName() const override { return \"FunctionFactory\"; }\n-\n-    /// Register a function by its name.\n-    /// No locking, you must register all functions before usage of get.\n-    void registerFunction(\n-            const std::string & name,\n-            Value creator,\n-            CaseSensitiveness case_sensitiveness = CaseSensitive);\n };\n \n }\ndiff --git a/src/Functions/FunctionMathBinaryFloat64.h b/src/Functions/FunctionMathBinaryFloat64.h\nindex 00f6909f65cd..7b54d59d852b 100644\n--- a/src/Functions/FunctionMathBinaryFloat64.h\n+++ b/src/Functions/FunctionMathBinaryFloat64.h\n@@ -76,18 +76,8 @@ class FunctionMathBinaryFloat64 : public IFunction\n             if (rows_remaining != 0)\n             {\n                 RightType right_src_remaining[Impl::rows_per_iteration];\n-                if constexpr (!is_big_int_v<RightType> && !std::is_same_v<RightType, Decimal256>)\n-                {\n-                    memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));\n-                    memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));\n-                }\n-                else\n-                {\n-                    for (size_t i = 0; i < rows_remaining; i++)\n-                        right_src_remaining[i] = right_src_data[rows_size + i];\n-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)\n-                        right_src_remaining[i] = 0;\n-                }\n+                memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));\n+                memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));\n                 Float64 dst_remaining[Impl::rows_per_iteration];\n \n                 Impl::execute(left_src_data, right_src_remaining, dst_remaining);\n@@ -123,32 +113,13 @@ class FunctionMathBinaryFloat64 : public IFunction\n             if (rows_remaining != 0)\n             {\n                 LeftType left_src_remaining[Impl::rows_per_iteration];\n-                if constexpr (!is_big_int_v<LeftType> && !std::is_same_v<LeftType, Decimal256>)\n-                {\n-                    memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));\n-                    memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));\n-                }\n-                else\n-                {\n-                    for (size_t i = 0; i < rows_remaining; i++)\n-                        left_src_remaining[i] = left_src_data[rows_size + i];\n-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)\n-                        left_src_remaining[i] = 0;\n-                }\n+                memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));\n+                memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));\n \n                 RightType right_src_remaining[Impl::rows_per_iteration];\n-                if constexpr (!is_big_int_v<RightType> && !std::is_same_v<RightType, Decimal256>)\n-                {\n-                    memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));\n-                    memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));\n-                }\n-                else\n-                {\n-                    for (size_t i = 0; i < rows_remaining; i++)\n-                        right_src_remaining[i] = right_src_data[rows_size + i];\n-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)\n-                        right_src_remaining[i] = 0;\n-                }\n+                memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));\n+                memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));\n+\n                 Float64 dst_remaining[Impl::rows_per_iteration];\n \n                 Impl::execute(left_src_remaining, right_src_remaining, dst_remaining);\n@@ -178,18 +149,8 @@ class FunctionMathBinaryFloat64 : public IFunction\n             if (rows_remaining != 0)\n             {\n                 LeftType left_src_remaining[Impl::rows_per_iteration];\n-                if constexpr (!is_big_int_v<LeftType> && !std::is_same_v<LeftType, Decimal256>)\n-                {\n-                    memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));\n-                    memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));\n-                }\n-                else\n-                {\n-                    for (size_t i = 0; i < rows_remaining; i++)\n-                        left_src_remaining[i] = left_src_data[rows_size + i];\n-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)\n-                        left_src_remaining[i] = 0;\n-                }\n+                memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));\n+                memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));\n \n                 Float64 dst_remaining[Impl::rows_per_iteration];\n \ndiff --git a/src/Functions/FunctionMathUnary.h b/src/Functions/FunctionMathUnary.h\nindex e24d19e5a9b4..78c6cf3ce0ba 100644\n--- a/src/Functions/FunctionMathUnary.h\n+++ b/src/Functions/FunctionMathUnary.h\n@@ -87,18 +87,8 @@ class FunctionMathUnary : public IFunction\n             if (rows_remaining != 0)\n             {\n                 T src_remaining[Impl::rows_per_iteration];\n-                if constexpr (is_big_int_v<T> || std::is_same_v<T, Decimal256>)\n-                {\n-                    for (size_t i = 0; i < rows_remaining; i++)\n-                        src_remaining[i] = src_data[rows_size + i];\n-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)\n-                        src_remaining[i] = 0;\n-                }\n-                else\n-                {\n-                    memcpy(src_remaining, &src_data[rows_size], rows_remaining * sizeof(T));\n-                    memset(src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(T));\n-                }\n+                memcpy(src_remaining, &src_data[rows_size], rows_remaining * sizeof(T));\n+                memset(src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(T));\n                 ReturnType dst_remaining[Impl::rows_per_iteration];\n \n                 Impl::execute(src_remaining, dst_remaining);\ndiff --git a/src/Functions/FunctionUnaryArithmetic.h b/src/Functions/FunctionUnaryArithmetic.h\nindex 0c5c3f629616..0b616fd8ab6f 100644\n--- a/src/Functions/FunctionUnaryArithmetic.h\n+++ b/src/Functions/FunctionUnaryArithmetic.h\n@@ -91,6 +91,7 @@ class FunctionUnaryArithmetic : public IFunction\n             DataTypeUInt16,\n             DataTypeUInt32,\n             DataTypeUInt64,\n+            DataTypeUInt128,\n             DataTypeUInt256,\n             DataTypeInt8,\n             DataTypeInt16,\ndiff --git a/src/Functions/FunctionUnixTimestamp64.h b/src/Functions/FunctionUnixTimestamp64.h\nindex 18f9c7a8b020..d8d8a1b7a06b 100644\n--- a/src/Functions/FunctionUnixTimestamp64.h\n+++ b/src/Functions/FunctionUnixTimestamp64.h\n@@ -5,145 +5,131 @@\n #include <Functions/FunctionHelpers.h>\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <Columns/ColumnsNumber.h>\n \n #include <common/arithmeticOverflow.h>\n \n+\n namespace DB\n {\n \n namespace ErrorCodes\n {\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int DECIMAL_OVERFLOW;\n }\n \n-/** Casts DateTim64 to or from Int64 representation narrowed down (or scaled up) to any scale value defined in Impl.\n- */\n-template <typename Impl>\n-class FunctionUnixTimestamp64 : public IFunction\n+/// Cast DateTime64 to Int64 representation narrowed down (or scaled up) to any scale value defined in Impl.\n+class FunctionToUnixTimestamp64 : public IFunction\n {\n+private:\n+    size_t target_scale;\n+    const char * name;\n public:\n-    static constexpr auto name = Impl::name;\n-    static constexpr auto target_scale = Impl::target_scale;\n-\n-    using SourceDataType = typename Impl::SourceDataType;\n-    using ResultDataType = typename Impl::ResultDataType;\n-\n-    static constexpr bool is_result_datetime64 = std::is_same_v<ResultDataType, DataTypeDateTime64>;\n-\n-    static_assert(std::is_same_v<SourceDataType, DataTypeDateTime64> || std::is_same_v<ResultDataType, DataTypeDateTime64>);\n-\n-    static auto create(ContextPtr)\n+    FunctionToUnixTimestamp64(size_t target_scale_, const char * name_)\n+        : target_scale(target_scale_), name(name_)\n     {\n-        return std::make_shared<FunctionUnixTimestamp64<Impl>>();\n     }\n \n     String getName() const override { return name; }\n-    size_t getNumberOfArguments() const override { return is_result_datetime64 ? 2 : 1; }\n-    bool isVariadic() const override { return is_result_datetime64; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isVariadic() const override { return false; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if constexpr (is_result_datetime64)\n-        {\n-            validateFunctionArgumentTypes(*this, arguments,\n-                    FunctionArgumentDescriptors{{\"value\", isDataType<SourceDataType>, nullptr, std::string(SourceDataType::family_name).c_str()}},\n-                    // optional\n-                    FunctionArgumentDescriptors{\n-    //                    {\"precision\", isDataType<DataTypeUInt8>, isColumnConst, (\"Precision of the result, default is \" + std::to_string(target_scale)).c_str()},\n-                        {\"timezone\", isStringOrFixedString, isColumnConst, \"Timezone of the result\"},\n-                    });\n-            const auto timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);\n-            return std::make_shared<DataTypeDateTime64>(target_scale, timezone);\n-        }\n-        else\n-        {\n-            validateFunctionArgumentTypes(*this, arguments,\n-                    FunctionArgumentDescriptors{{\"value\", isDataType<SourceDataType>, nullptr, std::string(SourceDataType::family_name).c_str()}});\n-            return std::make_shared<DataTypeInt64>();\n-        }\n+        if (!isDateTime64(arguments[0].type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be DateTime64\", name);\n+\n+        return std::make_shared<DataTypeInt64>();\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        using SourceColumnType = typename SourceDataType::ColumnType;\n-        using ResultColumnType = typename ResultDataType::ColumnType;\n-\n         const auto & src = arguments[0];\n         const auto & col = *src.column;\n \n-        const SourceColumnType * source_col_typed = checkAndGetColumn<SourceColumnType>(col);\n-        if (!source_col_typed && !(source_col_typed = checkAndGetColumnConstData<SourceColumnType>(&col)))\n-            throw Exception(\"Invalid column type\" + col.getName() + \" expected \"\n-                    + std::string(SourceDataType::family_name),\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        auto res_column = result_type->createColumn();\n-\n-        if (input_rows_count == 0)\n-            return res_column;\n+        auto res_column = ColumnInt64::create(input_rows_count);\n+        auto & result_data = res_column->getData();\n \n-        auto & result_data = assert_cast<ResultColumnType &>(res_column->assumeMutableRef()).getData();\n-        result_data.reserve(source_col_typed->size());\n-        const auto & source_data = source_col_typed->getData();\n+        const auto & source_data = typeid_cast<const ColumnDecimal<DateTime64> &>(col).getData();\n \n-        const auto scale_diff = getScaleDiff(*checkAndGetDataType<SourceDataType>(src.type.get()), *checkAndGetDataType<ResultDataType>(result_type.get()));\n+        Int32 scale_diff = typeid_cast<const DataTypeDateTime64 &>(*src.type).getScale() - target_scale;\n         if (scale_diff == 0)\n         {\n-            static_assert(sizeof(typename SourceColumnType::Container::value_type) == sizeof(typename ResultColumnType::Container::value_type));\n-            // no conversion necessary\n-            result_data.push_back_raw_many(source_data.size(), source_data.data());\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+                result_data[i] = source_data[i];\n         }\n         else if (scale_diff < 0)\n         {\n-            const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(std::abs(scale_diff));\n-            for (const auto & v : source_data)\n+            const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(-scale_diff);\n+            for (size_t i = 0; i < input_rows_count; ++i)\n             {\n-                Int64 result_value = toDestValue(v);\n+                Int64 result_value = source_data[i];\n                 if (common::mulOverflow(result_value, scale_multiplier, result_value))\n                     throw Exception(\"Decimal overflow in \" + getName(), ErrorCodes::DECIMAL_OVERFLOW);\n \n-                result_data.push_back(result_value);\n+                result_data[i] = result_value;\n             }\n         }\n         else\n         {\n             const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(scale_diff);\n-            for (const auto & v : source_data)\n-                result_data.push_back(static_cast<Int64>(toDestValue(v) / scale_multiplier));\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+                result_data[i] = Int64(source_data[i]) / scale_multiplier;\n         }\n \n         return res_column;\n     }\n+};\n+\n \n+class FunctionFromUnixTimestamp64 : public IFunction\n+{\n private:\n-    static Int64 getScaleDiff(const SourceDataType & src, const ResultDataType & dst)\n+    size_t target_scale;\n+    const char * name;\n+public:\n+    FunctionFromUnixTimestamp64(size_t target_scale_, const char * name_)\n+        : target_scale(target_scale_), name(name_)\n     {\n-        Int64 src_scale = target_scale;\n-        if constexpr (std::is_same_v<SourceDataType, DataTypeDateTime64>)\n-        {\n-            src_scale = src.getScale();\n-        }\n-\n-        Int64 dst_scale = target_scale;\n-        if constexpr (std::is_same_v<ResultDataType, DataTypeDateTime64>)\n-        {\n-            dst_scale = dst.getScale();\n-        }\n-\n-        return src_scale - dst_scale;\n     }\n \n-    static auto toDestValue(const DateTime64 & v)\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        return Int64{v.value};\n+        if (arguments.size() < 1 || arguments.size() > 2)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} takes one or two arguments\", name);\n+\n+        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument for function {} must be Int64\", name);\n+\n+        std::string timezone;\n+        if (arguments.size() == 2)\n+            timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);\n+\n+        return std::make_shared<DataTypeDateTime64>(target_scale, timezone);\n     }\n \n-    template <typename T>\n-    static auto toDestValue(const T & v)\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        return Int64{v};\n+        const auto & src = arguments[0];\n+        const auto & col = *src.column;\n+\n+        auto res_column = ColumnDecimal<DateTime64>::create(input_rows_count, target_scale);\n+        auto & result_data = res_column->getData();\n+\n+        const auto & source_data = typeid_cast<const ColumnInt64 &>(col).getData();\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+            result_data[i] = source_data[i];\n+\n+        return res_column;\n     }\n };\n \ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex 3110a204deb6..b4cf875adfbd 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -13,6 +13,7 @@ void registerFunctionsConversion(FunctionFactory & factory)\n     factory.registerFunction<FunctionToUInt16>();\n     factory.registerFunction<FunctionToUInt32>();\n     factory.registerFunction<FunctionToUInt64>();\n+    factory.registerFunction<FunctionToUInt128>();\n     factory.registerFunction<FunctionToUInt256>();\n     factory.registerFunction<FunctionToInt8>();\n     factory.registerFunction<FunctionToInt16>();\n@@ -50,6 +51,7 @@ void registerFunctionsConversion(FunctionFactory & factory)\n     factory.registerFunction<FunctionToUInt16OrZero>();\n     factory.registerFunction<FunctionToUInt32OrZero>();\n     factory.registerFunction<FunctionToUInt64OrZero>();\n+    factory.registerFunction<FunctionToUInt128OrZero>();\n     factory.registerFunction<FunctionToUInt256OrZero>();\n     factory.registerFunction<FunctionToInt8OrZero>();\n     factory.registerFunction<FunctionToInt16OrZero>();\n@@ -74,6 +76,7 @@ void registerFunctionsConversion(FunctionFactory & factory)\n     factory.registerFunction<FunctionToUInt16OrNull>();\n     factory.registerFunction<FunctionToUInt32OrNull>();\n     factory.registerFunction<FunctionToUInt64OrNull>();\n+    factory.registerFunction<FunctionToUInt128OrNull>();\n     factory.registerFunction<FunctionToUInt256OrNull>();\n     factory.registerFunction<FunctionToInt8OrNull>();\n     factory.registerFunction<FunctionToInt16OrNull>();\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 1cd308c774d3..8830107b170f 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -36,7 +36,6 @@\n #include <Columns/ColumnTuple.h>\n #include <Columns/ColumnMap.h>\n #include <Columns/ColumnsCommon.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/assert_cast.h>\n #include <Common/quoteString.h>\n #include <Core/AccurateComparison.h>\n@@ -125,7 +124,7 @@ struct ConvertImpl\n \n     template <typename Additions = void *>\n     static ColumnPtr NO_SANITIZE_UNDEFINED execute(\n-        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t /*input_rows_count*/,\n+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t input_rows_count,\n         Additions additions [[maybe_unused]] = Additions())\n     {\n         const ColumnWithTypeAndName & named_from = arguments[0];\n@@ -173,31 +172,19 @@ struct ConvertImpl\n \n             const auto & vec_from = col_from->getData();\n             auto & vec_to = col_to->getData();\n-            size_t size = vec_from.size();\n-            vec_to.resize(size);\n+            vec_to.resize(input_rows_count);\n \n             ColumnUInt8::MutablePtr col_null_map_to;\n             ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n             if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n             {\n-                col_null_map_to = ColumnUInt8::create(size, false);\n+                col_null_map_to = ColumnUInt8::create(input_rows_count, false);\n                 vec_null_map_to = &col_null_map_to->getData();\n             }\n \n-            for (size_t i = 0; i < size; ++i)\n+            for (size_t i = 0; i < input_rows_count; ++i)\n             {\n-                if constexpr ((is_big_int_v<FromFieldType> || is_big_int_v<ToFieldType>) &&\n-                    (std::is_same_v<FromFieldType, UInt128> || std::is_same_v<ToFieldType, UInt128>))\n-                {\n-                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n-                    {\n-                        vec_to[i] = 0;\n-                        (*vec_null_map_to)[i] = true;\n-                    }\n-                    else\n-                        throw Exception(\"Unexpected UInt128 to big int conversion\", ErrorCodes::NOT_IMPLEMENTED);\n-                }\n-                else if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)\n+                if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)\n                 {\n                     throw Exception(\"Conversion between numeric types and UUID is not supported\", ErrorCodes::NOT_IMPLEMENTED);\n                 }\n@@ -784,7 +771,7 @@ inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb\n {\n     UUID tmp;\n     readUUIDText(tmp, rb);\n-    x = tmp;\n+    x = tmp.toUnderType();\n }\n \n \n@@ -824,7 +811,7 @@ inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer &\n     if (!tryReadUUIDText(tmp, rb))\n         return false;\n \n-    x = tmp;\n+    x = tmp.toUnderType();\n     return true;\n }\n \n@@ -1454,7 +1441,7 @@ class FunctionConvert : public IFunction\n     ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n     {\n         if (arguments.empty())\n-            throw Exception{\"Function \" + getName() + \" expects at least 1 arguments\",\n+            throw Exception{\"Function \" + getName() + \" expects at least 1 argument\",\n                ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};\n \n         const IDataType * from_type = arguments[0].type.get();\n@@ -1471,7 +1458,7 @@ class FunctionConvert : public IFunction\n             {\n                 if constexpr (std::is_same_v<RightDataType, DataTypeDateTime64>)\n                 {\n-                    // account for optional timezone argument\n+                    /// Account for optional timezone argument.\n                     if (arguments.size() != 2 && arguments.size() != 3)\n                         throw Exception{\"Function \" + getName() + \" expects 2 or 3 arguments for DataTypeDateTime64.\",\n                             ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};\n@@ -1958,6 +1945,7 @@ struct NameToUInt8 { static constexpr auto name = \"toUInt8\"; };\n struct NameToUInt16 { static constexpr auto name = \"toUInt16\"; };\n struct NameToUInt32 { static constexpr auto name = \"toUInt32\"; };\n struct NameToUInt64 { static constexpr auto name = \"toUInt64\"; };\n+struct NameToUInt128 { static constexpr auto name = \"toUInt128\"; };\n struct NameToUInt256 { static constexpr auto name = \"toUInt256\"; };\n struct NameToInt8 { static constexpr auto name = \"toInt8\"; };\n struct NameToInt16 { static constexpr auto name = \"toInt16\"; };\n@@ -1973,6 +1961,7 @@ using FunctionToUInt8 = FunctionConvert<DataTypeUInt8, NameToUInt8, ToNumberMono\n using FunctionToUInt16 = FunctionConvert<DataTypeUInt16, NameToUInt16, ToNumberMonotonicity<UInt16>>;\n using FunctionToUInt32 = FunctionConvert<DataTypeUInt32, NameToUInt32, ToNumberMonotonicity<UInt32>>;\n using FunctionToUInt64 = FunctionConvert<DataTypeUInt64, NameToUInt64, ToNumberMonotonicity<UInt64>>;\n+using FunctionToUInt128 = FunctionConvert<DataTypeUInt128, NameToUInt128, ToNumberMonotonicity<UInt128>>;\n using FunctionToUInt256 = FunctionConvert<DataTypeUInt256, NameToUInt256, ToNumberMonotonicity<UInt256>>;\n using FunctionToInt8 = FunctionConvert<DataTypeInt8, NameToInt8, ToNumberMonotonicity<Int8>>;\n using FunctionToInt16 = FunctionConvert<DataTypeInt16, NameToInt16, ToNumberMonotonicity<Int16>>;\n@@ -2001,6 +1990,7 @@ template <> struct FunctionTo<DataTypeUInt8> { using Type = FunctionToUInt8; };\n template <> struct FunctionTo<DataTypeUInt16> { using Type = FunctionToUInt16; };\n template <> struct FunctionTo<DataTypeUInt32> { using Type = FunctionToUInt32; };\n template <> struct FunctionTo<DataTypeUInt64> { using Type = FunctionToUInt64; };\n+template <> struct FunctionTo<DataTypeUInt128> { using Type = FunctionToUInt128; };\n template <> struct FunctionTo<DataTypeUInt256> { using Type = FunctionToUInt256; };\n template <> struct FunctionTo<DataTypeInt8> { using Type = FunctionToInt8; };\n template <> struct FunctionTo<DataTypeInt16> { using Type = FunctionToInt16; };\n@@ -2030,6 +2020,7 @@ struct NameToUInt8OrZero { static constexpr auto name = \"toUInt8OrZero\"; };\n struct NameToUInt16OrZero { static constexpr auto name = \"toUInt16OrZero\"; };\n struct NameToUInt32OrZero { static constexpr auto name = \"toUInt32OrZero\"; };\n struct NameToUInt64OrZero { static constexpr auto name = \"toUInt64OrZero\"; };\n+struct NameToUInt128OrZero { static constexpr auto name = \"toUInt128OrZero\"; };\n struct NameToUInt256OrZero { static constexpr auto name = \"toUInt256OrZero\"; };\n struct NameToInt8OrZero { static constexpr auto name = \"toInt8OrZero\"; };\n struct NameToInt16OrZero { static constexpr auto name = \"toInt16OrZero\"; };\n@@ -2052,6 +2043,7 @@ using FunctionToUInt8OrZero = FunctionConvertFromString<DataTypeUInt8, NameToUIn\n using FunctionToUInt16OrZero = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToUInt32OrZero = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToUInt64OrZero = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrZero, ConvertFromStringExceptionMode::Zero>;\n+using FunctionToUInt128OrZero = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToUInt256OrZero = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToInt8OrZero = FunctionConvertFromString<DataTypeInt8, NameToInt8OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToInt16OrZero = FunctionConvertFromString<DataTypeInt16, NameToInt16OrZero, ConvertFromStringExceptionMode::Zero>;\n@@ -2074,6 +2066,7 @@ struct NameToUInt8OrNull { static constexpr auto name = \"toUInt8OrNull\"; };\n struct NameToUInt16OrNull { static constexpr auto name = \"toUInt16OrNull\"; };\n struct NameToUInt32OrNull { static constexpr auto name = \"toUInt32OrNull\"; };\n struct NameToUInt64OrNull { static constexpr auto name = \"toUInt64OrNull\"; };\n+struct NameToUInt128OrNull { static constexpr auto name = \"toUInt128OrNull\"; };\n struct NameToUInt256OrNull { static constexpr auto name = \"toUInt256OrNull\"; };\n struct NameToInt8OrNull { static constexpr auto name = \"toInt8OrNull\"; };\n struct NameToInt16OrNull { static constexpr auto name = \"toInt16OrNull\"; };\n@@ -2096,6 +2089,7 @@ using FunctionToUInt8OrNull = FunctionConvertFromString<DataTypeUInt8, NameToUIn\n using FunctionToUInt16OrNull = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToUInt32OrNull = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToUInt64OrNull = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrNull, ConvertFromStringExceptionMode::Null>;\n+using FunctionToUInt128OrNull = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToUInt256OrNull = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToInt8OrNull = FunctionConvertFromString<DataTypeInt8, NameToInt8OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToInt16OrNull = FunctionConvertFromString<DataTypeInt16, NameToInt16OrNull, ConvertFromStringExceptionMode::Null>;\n@@ -3043,6 +3037,7 @@ class FunctionCast final : public IFunctionBaseImpl\n                 std::is_same_v<ToDataType, DataTypeUInt16> ||\n                 std::is_same_v<ToDataType, DataTypeUInt32> ||\n                 std::is_same_v<ToDataType, DataTypeUInt64> ||\n+                std::is_same_v<ToDataType, DataTypeUInt128> ||\n                 std::is_same_v<ToDataType, DataTypeUInt256> ||\n                 std::is_same_v<ToDataType, DataTypeInt8> ||\n                 std::is_same_v<ToDataType, DataTypeInt16> ||\n@@ -3122,43 +3117,45 @@ class MonotonicityHelper\n \n     static MonotonicityForRange getMonotonicityInformation(const DataTypePtr & from_type, const IDataType * to_type)\n     {\n-        if (const auto *const type = checkAndGetDataType<DataTypeUInt8>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt8>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt16>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeUInt16>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt32>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeUInt32>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt64>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeUInt64>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt128>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeUInt256>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeUInt256>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt8>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt8>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt16>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt16>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt32>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt32>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt64>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt64>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt128>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt128>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeInt256>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeInt256>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeFloat32>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeFloat32>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeFloat64>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeFloat64>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeDate>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeDate>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeDateTime>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeDateTime>(to_type))\n             return monotonicityForType(type);\n-        if (const auto *const type = checkAndGetDataType<DataTypeString>(to_type))\n+        if (const auto * type = checkAndGetDataType<DataTypeString>(to_type))\n             return monotonicityForType(type);\n         if (isEnum(from_type))\n         {\n-            if (const auto *const type = checkAndGetDataType<DataTypeEnum8>(to_type))\n+            if (const auto * type = checkAndGetDataType<DataTypeEnum8>(to_type))\n                 return monotonicityForType(type);\n-            if (const auto *const type = checkAndGetDataType<DataTypeEnum16>(to_type))\n+            if (const auto * type = checkAndGetDataType<DataTypeEnum16>(to_type))\n                 return monotonicityForType(type);\n         }\n         /// other types like Null, FixedString, Array and Tuple have no monotonicity defined\ndiff --git a/src/Functions/FunctionsEmbeddedDictionaries.h b/src/Functions/FunctionsEmbeddedDictionaries.h\nindex 7584a217a26e..82b6ebb021b2 100644\n--- a/src/Functions/FunctionsEmbeddedDictionaries.h\n+++ b/src/Functions/FunctionsEmbeddedDictionaries.h\n@@ -165,14 +165,14 @@ class FunctionTransformWithDictionary : public IFunction\n                 + toString(arguments.size()) + \", should be 1 or 2.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        if (arguments[0]->getName() != TypeName<T>::get())\n+        if (arguments[0]->getName() != TypeName<T>)\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<T>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<T>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())\n+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)\n             throw Exception(\"Illegal type \" + arguments[1]->getName() + \" of the second ('point of view') argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<T>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<T>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return arguments[0];\n@@ -259,19 +259,19 @@ class FunctionIsInWithDictionary : public IFunction\n                 + toString(arguments.size()) + \", should be 2 or 3.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        if (arguments[0]->getName() != TypeName<T>::get())\n+        if (arguments[0]->getName() != TypeName<T>)\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of first argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<T>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<T>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        if (arguments[1]->getName() != TypeName<T>::get())\n+        if (arguments[1]->getName() != TypeName<T>)\n             throw Exception(\"Illegal type \" + arguments[1]->getName() + \" of second argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<T>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<T>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        if (arguments.size() == 3 && arguments[2]->getName() != TypeName<String>::get())\n+        if (arguments.size() == 3 && arguments[2]->getName() != TypeName<String>)\n             throw Exception(\"Illegal type \" + arguments[2]->getName() + \" of the third ('point of view') argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<String>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<String>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeUInt8>();\n@@ -397,14 +397,14 @@ class FunctionHierarchyWithDictionary : public IFunction\n                 + toString(arguments.size()) + \", should be 1 or 2.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        if (arguments[0]->getName() != TypeName<T>::get())\n+        if (arguments[0]->getName() != TypeName<T>)\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName()\n-            + \" (must be \" + String(TypeName<T>::get()) + \")\",\n+            + \" (must be \" + String(TypeName<T>) + \")\",\n             ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())\n+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)\n             throw Exception(\"Illegal type \" + arguments[1]->getName() + \" of the second ('point of view') argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<String>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<String>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeArray>(arguments[0]);\n@@ -602,14 +602,14 @@ class FunctionRegionToName : public IFunction\n                 + toString(arguments.size()) + \", should be 1 or 2.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        if (arguments[0]->getName() != TypeName<UInt32>::get())\n+        if (arguments[0]->getName() != TypeName<UInt32>)\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of the first argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<UInt32>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<UInt32>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())\n+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of the second argument of function \" + getName()\n-                + \" (must be \" + String(TypeName<String>::get()) + \")\",\n+                + \" (must be \" + String(TypeName<String>) + \")\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeString>();\ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex 94f8acbdf666..e664d0e035df 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -973,7 +973,7 @@ class FunctionAnyHash : public IFunction\n         else if (which.isUInt16()) executeIntType<UInt16, first>(icolumn, vec_to);\n         else if (which.isUInt32()) executeIntType<UInt32, first>(icolumn, vec_to);\n         else if (which.isUInt64()) executeIntType<UInt64, first>(icolumn, vec_to);\n-        else if (which.isUInt128() || which.isUUID()) executeBigIntType<UInt128, first>(icolumn, vec_to);\n+        else if (which.isUInt128()) executeBigIntType<UInt128, first>(icolumn, vec_to);\n         else if (which.isUInt256()) executeBigIntType<UInt256, first>(icolumn, vec_to);\n         else if (which.isInt8()) executeIntType<Int8, first>(icolumn, vec_to);\n         else if (which.isInt16()) executeIntType<Int16, first>(icolumn, vec_to);\n@@ -981,6 +981,7 @@ class FunctionAnyHash : public IFunction\n         else if (which.isInt64()) executeIntType<Int64, first>(icolumn, vec_to);\n         else if (which.isInt128()) executeBigIntType<Int128, first>(icolumn, vec_to);\n         else if (which.isInt256()) executeBigIntType<Int256, first>(icolumn, vec_to);\n+        else if (which.isUUID()) executeBigIntType<UUID, first>(icolumn, vec_to);\n         else if (which.isEnum8()) executeIntType<Int8, first>(icolumn, vec_to);\n         else if (which.isEnum16()) executeIntType<Int16, first>(icolumn, vec_to);\n         else if (which.isDate()) executeIntType<UInt16, first>(icolumn, vec_to);\ndiff --git a/src/Functions/FunctionsRound.h b/src/Functions/FunctionsRound.h\nindex 01074984ebf3..e62d9524675f 100644\n--- a/src/Functions/FunctionsRound.h\n+++ b/src/Functions/FunctionsRound.h\n@@ -444,13 +444,7 @@ class DecimalRoundingImpl\n         }\n         else\n         {\n-            if constexpr (!is_big_int_v<NativeType>)\n-                memcpy(out.data(), in.data(), in.size() * sizeof(T));\n-            else\n-            {\n-                for (size_t i = 0; i < in.size(); i++)\n-                    out[i] = in[i];\n-            }\n+            memcpy(out.data(), in.data(), in.size() * sizeof(T));\n         }\n     }\n };\n@@ -511,7 +505,7 @@ class Dispatcher\n public:\n     static ColumnPtr apply(const IColumn * column, Scale scale_arg)\n     {\n-        if constexpr (IsNumber<T>)\n+        if constexpr (is_arithmetic_v<T>)\n             return apply(checkAndGetColumn<ColumnVector<T>>(column), scale_arg);\n         else if constexpr (IsDecimalNumber<T>)\n             return apply(checkAndGetColumn<ColumnDecimal<T>>(column), scale_arg);\ndiff --git a/src/Functions/GCDLCMImpl.h b/src/Functions/GCDLCMImpl.h\nindex b83fe37abb67..f13a6dc3f95b 100644\n--- a/src/Functions/GCDLCMImpl.h\n+++ b/src/Functions/GCDLCMImpl.h\n@@ -2,7 +2,7 @@\n \n #include <DataTypes/NumberTraits.h>\n #include <Common/Exception.h>\n-#include <numeric>\n+#include <common/extended_types.h>\n #include <limits>\n #include <type_traits>\n \n@@ -16,12 +16,9 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int NOT_IMPLEMENTED;\n     extern const int DECIMAL_OVERFLOW;\n }\n \n-template <class T>\n-inline constexpr bool is_gcd_lcm_implemeted = !is_big_int_v<T>;\n \n template <typename A, typename B, typename Impl, typename Name>\n struct GCDLCMImpl\n@@ -30,15 +27,7 @@ struct GCDLCMImpl\n     static const constexpr bool allow_fixed_string = false;\n \n     template <typename Result = ResultType>\n-    static inline std::enable_if_t<!is_gcd_lcm_implemeted<Result>, Result>\n-    apply(A, B)\n-    {\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} is not implemented for big integers\", Name::name);\n-    }\n-\n-    template <typename Result = ResultType>\n-    static inline std::enable_if_t<is_gcd_lcm_implemeted<Result>, Result>\n-    apply(A a, B b)\n+    static inline Result apply(A a, B b)\n     {\n         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));\n         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<B>::Type(b), typename NumberTraits::ToInteger<A>::Type(a));\n@@ -50,7 +39,7 @@ struct GCDLCMImpl\n             /// gcd() internally uses std::abs()\n             Int a_s = static_cast<Int>(a);\n             Int b_s = static_cast<Int>(b);\n-            Int min = std::numeric_limits<Int>::min();\n+            Int min = std::numeric_limits<Int>::lowest();\n             Int max = std::numeric_limits<Int>::max();\n             if (unlikely((a_s == min || a_s == max) || (b_s == min || b_s == max)))\n                 throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Intermediate result overflow (signed a = {}, signed b = {}, min = {}, max = {})\", a_s, b_s, min, max);\ndiff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h\nindex 1a962089d0c6..d17ab0820040 100644\n--- a/src/Functions/GatherUtils/Algorithms.h\n+++ b/src/Functions/GatherUtils/Algorithms.h\n@@ -13,7 +13,6 @@ namespace DB::ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int TOO_LARGE_ARRAY_SIZE;\n-    extern const int NOT_IMPLEMENTED;\n }\n \n namespace DB::GatherUtils\n@@ -45,11 +44,7 @@ void writeSlice(const NumericArraySlice<T> & slice, NumericArraySink<U> & sink)\n \n         if constexpr (OverBigInt<T> || OverBigInt<U>)\n         {\n-            if constexpr (std::is_same_v<U, UInt128>)\n-            {\n-                throw Exception(\"No conversion between UInt128 and \" + demangle(typeid(T).name()), ErrorCodes::NOT_IMPLEMENTED);\n-            }\n-            else if constexpr (IsDecimalNumber<T>)\n+            if constexpr (IsDecimalNumber<T>)\n                 dst = static_cast<NativeU>(src.value);\n             else\n                 dst = static_cast<NativeU>(src);\ndiff --git a/src/Functions/GatherUtils/ArraySinkVisitor.h b/src/Functions/GatherUtils/ArraySinkVisitor.h\nindex b146780924fd..7a53da258691 100644\n--- a/src/Functions/GatherUtils/ArraySinkVisitor.h\n+++ b/src/Functions/GatherUtils/ArraySinkVisitor.h\n@@ -14,7 +14,7 @@ struct GenericArraySink;\n template <typename ArraySink>\n struct NullableArraySink;\n \n-using NumericArraySinks = typename TypeListMap<NumericArraySink, TypeListNumbersAndUInt128>::Type;\n+using NumericArraySinks = typename TypeListMap<NumericArraySink, TypeListNumbersAndUUID>::Type;\n using BasicArraySinks = typename AppendToTypeList<GenericArraySink, NumericArraySinks>::Type;\n using NullableArraySinks = typename TypeListMap<NullableArraySink, BasicArraySinks>::Type;\n using TypeListArraySinks = typename TypeListConcat<BasicArraySinks, NullableArraySinks>::Type;\ndiff --git a/src/Functions/GatherUtils/ArraySourceVisitor.h b/src/Functions/GatherUtils/ArraySourceVisitor.h\nindex 260e9a871616..1b92a9d2e815 100644\n--- a/src/Functions/GatherUtils/ArraySourceVisitor.h\n+++ b/src/Functions/GatherUtils/ArraySourceVisitor.h\n@@ -17,7 +17,7 @@ struct NullableArraySource;\n template <typename Base>\n struct ConstSource;\n \n-using NumericArraySources = typename TypeListMap<NumericArraySource, TypeListNumbersAndUInt128>::Type;\n+using NumericArraySources = typename TypeListMap<NumericArraySource, TypeListNumbersAndUUID>::Type;\n using BasicArraySources = typename AppendToTypeList<GenericArraySource, NumericArraySources>::Type;\n \n class ArraySourceVisitor : public ApplyTypeListForClass<Visitor, BasicArraySources>::Type\ndiff --git a/src/Functions/GatherUtils/ValueSourceVisitor.h b/src/Functions/GatherUtils/ValueSourceVisitor.h\nindex 538ee156e5da..be503cdcfcf2 100644\n--- a/src/Functions/GatherUtils/ValueSourceVisitor.h\n+++ b/src/Functions/GatherUtils/ValueSourceVisitor.h\n@@ -17,7 +17,7 @@ struct NullableValueSource;\n template <typename Base>\n struct ConstSource;\n \n-using NumericValueSources = typename TypeListMap<NumericValueSource, TypeListNumbersAndUInt128>::Type;\n+using NumericValueSources = typename TypeListMap<NumericValueSource, TypeListNumbersAndUUID>::Type;\n using BasicValueSources = typename AppendToTypeList<GenericValueSource, NumericValueSources>::Type;\n using NullableValueSources = typename TypeListMap<NullableValueSource, BasicValueSources>::Type;\n using BasicAndNullableValueSources = typename TypeListConcat<BasicValueSources, NullableValueSources>::Type;\ndiff --git a/src/Functions/GatherUtils/createArraySink.cpp b/src/Functions/GatherUtils/createArraySink.cpp\nindex 00b33cf98212..90983c9c25c6 100644\n--- a/src/Functions/GatherUtils/createArraySink.cpp\n+++ b/src/Functions/GatherUtils/createArraySink.cpp\n@@ -55,7 +55,7 @@ struct ArraySinkCreator<>\n \n std::unique_ptr<IArraySink> createArraySink(ColumnArray & col, size_t column_size)\n {\n-    using Creator = ApplyTypeListForClass<ArraySinkCreator, TypeListNumbersAndUInt128>::Type;\n+    using Creator = ApplyTypeListForClass<ArraySinkCreator, TypeListNumbersAndUUID>::Type;\n     return Creator::create(col.getData(), col.getOffsets(), column_size);\n }\n }\ndiff --git a/src/Functions/GatherUtils/createArraySource.cpp b/src/Functions/GatherUtils/createArraySource.cpp\nindex 0744e2f2ea31..d98a72e456f8 100644\n--- a/src/Functions/GatherUtils/createArraySource.cpp\n+++ b/src/Functions/GatherUtils/createArraySource.cpp\n@@ -58,7 +58,7 @@ struct ArraySourceCreator<>\n \n std::unique_ptr<IArraySource> createArraySource(const ColumnArray & col, bool is_const, size_t total_rows)\n {\n-    using Creator = typename ApplyTypeListForClass<ArraySourceCreator, TypeListNumbersAndUInt128>::Type;\n+    using Creator = typename ApplyTypeListForClass<ArraySourceCreator, TypeListNumbersAndUUID>::Type;\n     if (const auto * column_nullable = typeid_cast<const ColumnNullable *>(&col.getData()))\n     {\n         auto column = ColumnArray::create(column_nullable->getNestedColumnPtr(), col.getOffsetsPtr());\ndiff --git a/src/Functions/GatherUtils/createValueSource.cpp b/src/Functions/GatherUtils/createValueSource.cpp\nindex 201100662147..4f538b95369e 100644\n--- a/src/Functions/GatherUtils/createValueSource.cpp\n+++ b/src/Functions/GatherUtils/createValueSource.cpp\n@@ -58,7 +58,7 @@ struct ValueSourceCreator<>\n \n std::unique_ptr<IValueSource> createValueSource(const IColumn & col, bool is_const, size_t total_rows)\n {\n-    using Creator = typename ApplyTypeListForClass<ValueSourceCreator, TypeListNumbersAndUInt128>::Type;\n+    using Creator = typename ApplyTypeListForClass<ValueSourceCreator, TypeListNumbersAndUUID>::Type;\n     if (const auto * column_nullable = typeid_cast<const ColumnNullable *>(&col))\n     {\n         return Creator::create(column_nullable->getNestedColumn(), &column_nullable->getNullMapData(), is_const, total_rows);\ndiff --git a/src/Functions/GregorianDate.h b/src/Functions/GregorianDate.h\nindex 844fb180e5e3..5f179483b536 100644\n--- a/src/Functions/GregorianDate.h\n+++ b/src/Functions/GregorianDate.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <common/extended_types.h>\n #include <Common/Exception.h>\n #include <Core/Types.h>\n #include <IO/ReadBuffer.h>\n@@ -9,6 +10,7 @@\n \n #include <cstdint>\n \n+\n namespace DB\n {\n     namespace ErrorCodes\n@@ -27,8 +29,6 @@ namespace DB\n     class GregorianDate\n     {\n     public:\n-        GregorianDate() = delete;\n-\n         /** Construct from date in text form 'YYYY-MM-DD' by reading from\n           * ReadBuffer.\n           */\n@@ -38,14 +38,14 @@ namespace DB\n           * integral type which should be at least 32 bits wide, and\n           * should preferably signed.\n           */\n-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>\n+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>\n         GregorianDate(T mjd);\n \n         /** Convert to Modified Julian Day. The type T is an integral type\n           * which should be at least 32 bits wide, and should preferably\n           * signed.\n           */\n-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>\n+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>\n         T toModifiedJulianDay() const;\n \n         /** Write the date in text form 'YYYY-MM-DD' to a buffer.\n@@ -90,14 +90,14 @@ namespace DB\n           * integral type which should be at least 32 bits wide, and\n           * should preferably signed.\n           */\n-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>\n+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>\n         OrdinalDate(T mjd);\n \n         /** Convert to Modified Julian Day. The type T is an integral\n           * type which should be at least 32 bits wide, and should\n           * preferably be signed.\n           */\n-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>\n+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>\n         T toModifiedJulianDay() const noexcept;\n \n         YearT year() const noexcept\n@@ -259,7 +259,7 @@ namespace DB\n     }\n \n     template <typename YearT>\n-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>\n+    template <typename T, std::enable_if_t<is_integer_v<T>> *>\n     GregorianDate<YearT>::GregorianDate(T mjd)\n     {\n         const OrdinalDate<YearT> ord(mjd);\n@@ -270,7 +270,7 @@ namespace DB\n     }\n \n     template <typename YearT>\n-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>\n+    template <typename T, std::enable_if_t<is_integer_v<T>> *>\n     T GregorianDate<YearT>::toModifiedJulianDay() const\n     {\n         const MonthDay md(month_, day_of_month_);\n@@ -332,7 +332,7 @@ namespace DB\n     }\n \n     template <typename YearT>\n-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>\n+    template <typename T, std::enable_if_t<is_integer_v<T>> *>\n     OrdinalDate<YearT>::OrdinalDate(T mjd)\n     {\n         const auto a         = mjd + 678575;\n@@ -348,7 +348,7 @@ namespace DB\n     }\n \n     template <typename YearT>\n-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>\n+    template <typename T, std::enable_if_t<is_integer_v<T>> *>\n     T OrdinalDate<YearT>::toModifiedJulianDay() const noexcept\n     {\n         const auto y = year_ - 1;\ndiff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp\nindex e65d07cf6ac8..c8a3bd22c3cc 100644\n--- a/src/Functions/IFunction.cpp\n+++ b/src/Functions/IFunction.cpp\n@@ -64,8 +64,7 @@ class ExecutableFunctionLowCardinalityResultCache\n         size_t operator()(const DictionaryKey & key) const\n         {\n             SipHash hash;\n-            hash.update(key.hash.low);\n-            hash.update(key.hash.high);\n+            hash.update(key.hash);\n             hash.update(key.size);\n             return hash.get64();\n         }\ndiff --git a/src/Functions/PolygonUtils.h b/src/Functions/PolygonUtils.h\nindex 27ee1d2a99fc..4226e3ae0b03 100644\n--- a/src/Functions/PolygonUtils.h\n+++ b/src/Functions/PolygonUtils.h\n@@ -646,7 +646,7 @@ UInt128 sipHash128(Polygon && polygon)\n         hash_ring(inner);\n \n     UInt128 res;\n-    hash.get128(res.low, res.high);\n+    hash.get128(res);\n     return res;\n }\n \ndiff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp\nindex 784beb9fc3a2..3d40dfe83eac 100644\n--- a/src/Functions/array/arrayAggregation.cpp\n+++ b/src/Functions/array/arrayAggregation.cpp\n@@ -68,12 +68,13 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>\n {\n     using Result =\n         std::conditional_t<std::is_same_v<ArrayElement, Int128>, Int128,\n-            std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,\n-                std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,\n-                    std::conditional_t<IsDecimalNumber<ArrayElement>, Decimal128,\n-                        std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,\n-                            std::conditional_t<std::is_signed_v<ArrayElement>, Int64,\n-                                UInt64>>>>>>;\n+        std::conditional_t<std::is_same_v<ArrayElement, UInt128>, UInt128,\n+        std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,\n+        std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,\n+        std::conditional_t<IsDecimalNumber<ArrayElement>, Decimal128,\n+        std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,\n+        std::conditional_t<std::is_signed_v<ArrayElement>, Int64,\n+            UInt64>>>>>>>;\n };\n \n template <typename ArrayElement, AggregateOperation operation>\n@@ -173,7 +174,7 @@ struct ArrayAggregateImpl\n                 {\n                     size_t array_size = offsets[i] - pos;\n                     /// Just multiply the value by array size.\n-                    res[i] = x * array_size;\n+                    res[i] = x * ResultType(array_size);\n                 }\n                 else if constexpr (aggregate_operation == AggregateOperation::min ||\n                                 aggregate_operation == AggregateOperation::max)\n@@ -244,12 +245,15 @@ struct ArrayAggregateImpl\n         size_t pos = 0;\n         for (size_t i = 0; i < offsets.size(); ++i)\n         {\n-            AggregationType aggregate_value = 0;\n+            AggregationType aggregate_value{};\n \n             /// Array is empty\n             if (offsets[i] == pos)\n             {\n-                res[i] = aggregate_value;\n+                if constexpr (IsDecimalNumber<AggregationType>)\n+                    res[i] = aggregate_value.value;\n+                else\n+                    res[i] = aggregate_value;\n                 continue;\n             }\n \n@@ -304,7 +308,7 @@ struct ArrayAggregateImpl\n             {\n                 if constexpr (IsDecimalNumber<Element>)\n                 {\n-                    aggregate_value = aggregate_value / count;\n+                    aggregate_value = aggregate_value / AggregationType(count);\n                     res[i] = DecimalUtils::convertTo<ResultType>(aggregate_value, data.getScale());\n                 }\n                 else\n@@ -340,6 +344,7 @@ struct ArrayAggregateImpl\n             executeType<UInt16>(mapped, offsets, res) ||\n             executeType<UInt32>(mapped, offsets, res) ||\n             executeType<UInt64>(mapped, offsets, res) ||\n+            executeType<UInt128>(mapped, offsets, res) ||\n             executeType<UInt256>(mapped, offsets, res) ||\n             executeType<Int8>(mapped, offsets, res) ||\n             executeType<Int16>(mapped, offsets, res) ||\ndiff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp\nindex 2c7362a16057..288422c1c9c1 100644\n--- a/src/Functions/array/arrayCumSumNonNegative.cpp\n+++ b/src/Functions/array/arrayCumSumNonNegative.cpp\n@@ -60,8 +60,8 @@ struct ArrayCumSumNonNegativeImpl\n             for (; pos < offset; ++pos)\n             {\n                 accumulated += src_values[pos];\n-                if (accumulated < 0)\n-                    accumulated = 0;\n+                if (accumulated < Dst{})\n+                    accumulated = {};\n                 res_values[pos] = accumulated;\n             }\n         }\ndiff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp\nindex 45ff117bfdf1..7d11c6e89c8b 100644\n--- a/src/Functions/array/arrayDifference.cpp\n+++ b/src/Functions/array/arrayDifference.cpp\n@@ -58,7 +58,7 @@ struct ArrayDifferenceImpl\n         {\n             if (pos == begin)\n             {\n-                dst[pos] = 0;\n+                dst[pos] = {};\n                 prev = src[pos];\n             }\n             else\n@@ -70,7 +70,10 @@ struct ArrayDifferenceImpl\n                     using ResultNativeType = typename Result::NativeType;\n \n                     ResultNativeType result_value;\n-                    bool overflow = common::subOverflow(static_cast<ResultNativeType>(curr.value), static_cast<ResultNativeType>(prev), result_value);\n+                    bool overflow = common::subOverflow(\n+                        static_cast<ResultNativeType>(curr.value),\n+                        static_cast<ResultNativeType>(prev.value),\n+                        result_value);\n                     if (overflow)\n                         throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n \ndiff --git a/src/Functions/array/arrayDistinct.cpp b/src/Functions/array/arrayDistinct.cpp\nindex cf73a577def0..c43047a0c564 100644\n--- a/src/Functions/array/arrayDistinct.cpp\n+++ b/src/Functions/array/arrayDistinct.cpp\n@@ -270,7 +270,7 @@ void FunctionArrayDistinct::executeHashed(\n             UInt128 hash;\n             SipHash hash_function;\n             src_data.updateHashWithValue(j, hash_function);\n-            hash_function.get128(reinterpret_cast<char *>(&hash));\n+            hash_function.get128(hash);\n \n             if (!set.find(hash))\n             {\ndiff --git a/src/Functions/array/arrayElement.cpp b/src/Functions/array/arrayElement.cpp\nindex 4254b00e4bcf..f49739d75cc4 100644\n--- a/src/Functions/array/arrayElement.cpp\n+++ b/src/Functions/array/arrayElement.cpp\n@@ -876,7 +876,7 @@ bool FunctionArrayElement::matchKeyToIndexNumberConst(\n     Field::dispatch([&](const auto & value)\n     {\n         using FieldType = std::decay_t<decltype(value)>;\n-        if constexpr (is_integer_v<FieldType> && std::is_convertible_v<FieldType, DataType>)\n+        if constexpr (std::is_same_v<FieldType, DataType> || (is_integer_v<FieldType> && std::is_convertible_v<FieldType, DataType>))\n             index_as_integer = static_cast<DataType>(value);\n     }, index);\n \n@@ -914,14 +914,15 @@ bool FunctionArrayElement::matchKeyToIndex(\n         || matchKeyToIndexNumber<UInt16>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<UInt32>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<UInt64>(data, offsets, arguments, matched_idxs)\n+        || matchKeyToIndexNumber<UInt128>(data, offsets, arguments, matched_idxs)\n+        || matchKeyToIndexNumber<UInt256>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int8>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int16>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int32>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int64>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int128>(data, offsets, arguments, matched_idxs)\n-        || matchKeyToIndexNumber<UInt128>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexNumber<Int256>(data, offsets, arguments, matched_idxs)\n-        || matchKeyToIndexNumber<UInt256>(data, offsets, arguments, matched_idxs)\n+        || matchKeyToIndexNumber<UUID>(data, offsets, arguments, matched_idxs)\n         || matchKeyToIndexString(data, offsets, arguments, matched_idxs);\n }\n \n@@ -933,14 +934,15 @@ bool FunctionArrayElement::matchKeyToIndexConst(\n         || matchKeyToIndexNumberConst<UInt16>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<UInt32>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<UInt64>(data, offsets, index, matched_idxs)\n+        || matchKeyToIndexNumberConst<UInt128>(data, offsets, index, matched_idxs)\n+        || matchKeyToIndexNumberConst<UInt256>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int8>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int16>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int32>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int64>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int128>(data, offsets, index, matched_idxs)\n-        || matchKeyToIndexNumberConst<UInt128>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexNumberConst<Int256>(data, offsets, index, matched_idxs)\n-        || matchKeyToIndexNumberConst<UInt256>(data, offsets, index, matched_idxs)\n+        || matchKeyToIndexNumberConst<UUID>(data, offsets, index, matched_idxs)\n         || matchKeyToIndexStringConst(data, offsets, index, matched_idxs);\n }\n \ndiff --git a/src/Functions/array/arrayEnumerateRanked.h b/src/Functions/array/arrayEnumerateRanked.h\nindex 2d13482b01ef..789c2c38e96f 100644\n--- a/src/Functions/array/arrayEnumerateRanked.h\n+++ b/src/Functions/array/arrayEnumerateRanked.h\n@@ -142,7 +142,7 @@ static inline UInt128 ALWAYS_INLINE hash128depths(const std::vector<size_t> & in\n         key_columns[j]->updateHashWithValue(indices[j], hash);\n     }\n \n-    hash.get128(key.low, key.high);\n+    hash.get128(key);\n \n     return key;\n }\ndiff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp\nindex 7275a1395c08..05bb4351c3ec 100644\n--- a/src/Functions/array/arrayIntersect.cpp\n+++ b/src/Functions/array/arrayIntersect.cpp\n@@ -518,7 +518,9 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n                     typename Map::mapped_type * value = nullptr;\n \n                     if constexpr (is_numeric_column)\n+                    {\n                         value = &map[columns[arg_num]->getElement(i)];\n+                    }\n                     else if constexpr (std::is_same<ColumnType, ColumnString>::value || std::is_same<ColumnType, ColumnFixedString>::value)\n                         value = &map[columns[arg_num]->getDataAt(i)];\n                     else\ndiff --git a/src/Functions/array/mapOp.cpp b/src/Functions/array/mapOp.cpp\nindex 78b7ce2b1557..1a19ee41d2f1 100644\n--- a/src/Functions/array/mapOp.cpp\n+++ b/src/Functions/array/mapOp.cpp\n@@ -30,15 +30,15 @@ struct TupArg\n     const IColumn::Offsets & val_offsets;\n     bool is_const;\n };\n-using TupleMaps = std::vector<struct TupArg>;\n+using TupleMaps = std::vector<TupArg>;\n \n-namespace OpTypes\n+enum class OpTypes\n {\n-    extern const int ADD = 0;\n-    extern const int SUBTRACT = 1;\n-}\n+    ADD = 0,\n+    SUBTRACT = 1\n+};\n \n-template <int op_type>\n+template <OpTypes op_type>\n class FunctionMapOp : public IFunction\n {\n public:\n@@ -160,7 +160,7 @@ class FunctionMapOp : public IFunction\n                     KeyType key;\n                     if constexpr (is_str_key)\n                     {\n-                        // have to use Field structs to get strings\n+                        // have to use Field to get strings\n                         key = arg.key_column[offset + j].get<KeyType>();\n                     }\n                     else\n@@ -209,7 +209,8 @@ class FunctionMapOp : public IFunction\n     {\n         const auto & promoted_type = (assert_cast<const DataTypeArray *>(res_type.getElements()[1].get()))->getNestedType();\n #define MATCH_EXECUTE(is_str) \\\n-        switch (promoted_type->getTypeId()) { \\\n+        switch (promoted_type->getTypeId()) \\\n+        { \\\n             case TypeIndex::Int64: return execute2<KeyType, is_str, Int64>(row_count, args, res_type); \\\n             case TypeIndex::UInt64: return execute2<KeyType, is_str, UInt64>(row_count, args, res_type); \\\n             case TypeIndex::Float64: return execute2<KeyType, is_str, Float64>(row_count, args, res_type); \\\n@@ -290,6 +291,10 @@ class FunctionMapOp : public IFunction\n                 return execute1<Int32, false>(row_count, res_type, args);\n             case TypeIndex::Int64:\n                 return execute1<Int64, false>(row_count, res_type, args);\n+            case TypeIndex::Int128:\n+                return execute1<Int128, false>(row_count, res_type, args);\n+            case TypeIndex::Int256:\n+                return execute1<Int256, false>(row_count, res_type, args);\n             case TypeIndex::UInt8:\n                 return execute1<UInt8, false>(row_count, res_type, args);\n             case TypeIndex::Date:\n@@ -300,8 +305,12 @@ class FunctionMapOp : public IFunction\n                 return execute1<UInt32, false>(row_count, res_type, args);\n             case TypeIndex::UInt64:\n                 return execute1<UInt64, false>(row_count, res_type, args);\n-            case TypeIndex::UUID:\n+            case TypeIndex::UInt128:\n                 return execute1<UInt128, false>(row_count, res_type, args);\n+            case TypeIndex::UInt256:\n+                return execute1<UInt256, false>(row_count, res_type, args);\n+            case TypeIndex::UUID:\n+                return execute1<UUID, false>(row_count, res_type, args);\n             case TypeIndex::FixedString:\n             case TypeIndex::String:\n                 return execute1<String, true>(row_count, res_type, args);\ndiff --git a/src/Functions/bar.cpp b/src/Functions/bar.cpp\nindex c2b5f93994ec..821cd8bcfab9 100644\n--- a/src/Functions/bar.cpp\n+++ b/src/Functions/bar.cpp\n@@ -3,7 +3,6 @@\n #include <DataTypes/DataTypeString.h>\n #include <Columns/ColumnString.h>\n #include <Common/UnicodeBar.h>\n-#include <Common/FieldVisitors.h>\n #include <IO/WriteHelpers.h>\n \n \ndiff --git a/src/Functions/fromUnixTimestamp64Micro.cpp b/src/Functions/fromUnixTimestamp64Micro.cpp\nindex a4bac327a3a0..6cc22b31758f 100644\n--- a/src/Functions/fromUnixTimestamp64Micro.cpp\n+++ b/src/Functions/fromUnixTimestamp64Micro.cpp\n@@ -4,17 +4,11 @@\n namespace DB\n {\n \n-struct TransformFromMicro\n-{\n-    static constexpr auto name = \"fromUnixTimestamp64Micro\";\n-    static constexpr auto target_scale = 6;\n-    using SourceDataType = DataTypeInt64;\n-    using ResultDataType = DataTypeDateTime64;\n-};\n-\n void registerFromUnixTimestamp64Micro(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromMicro>>();\n+    factory.registerFunction(\"fromUnixTimestamp64Micro\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionFromUnixTimestamp64>(6, \"fromUnixTimestamp64Micro\")); });\n }\n \n }\ndiff --git a/src/Functions/fromUnixTimestamp64Milli.cpp b/src/Functions/fromUnixTimestamp64Milli.cpp\nindex a4ce79ecebbe..6973fb471762 100644\n--- a/src/Functions/fromUnixTimestamp64Milli.cpp\n+++ b/src/Functions/fromUnixTimestamp64Milli.cpp\n@@ -4,17 +4,11 @@\n namespace DB\n {\n \n-struct TransformFromMilli\n-{\n-    static constexpr auto name = \"fromUnixTimestamp64Milli\";\n-    static constexpr auto target_scale = 3;\n-    using SourceDataType = DataTypeInt64;\n-    using ResultDataType = DataTypeDateTime64;\n-};\n-\n void registerFromUnixTimestamp64Milli(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromMilli>>();\n+    factory.registerFunction(\"fromUnixTimestamp64Milli\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionFromUnixTimestamp64>(3, \"fromUnixTimestamp64Milli\")); });\n }\n \n }\ndiff --git a/src/Functions/fromUnixTimestamp64Nano.cpp b/src/Functions/fromUnixTimestamp64Nano.cpp\nindex cd69aa56a2c0..50c4e4dc8d8d 100644\n--- a/src/Functions/fromUnixTimestamp64Nano.cpp\n+++ b/src/Functions/fromUnixTimestamp64Nano.cpp\n@@ -4,17 +4,11 @@\n namespace DB\n {\n \n-struct TransformFromNano\n-{\n-    static constexpr auto name = \"fromUnixTimestamp64Nano\";\n-    static constexpr auto target_scale = 9;\n-    using SourceDataType = DataTypeInt64;\n-    using ResultDataType = DataTypeDateTime64;\n-};\n-\n void registerFromUnixTimestamp64Nano(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromNano>>();\n+    factory.registerFunction(\"fromUnixTimestamp64Nano\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionFromUnixTimestamp64>(9, \"fromUnixTimestamp64Nano\")); });\n }\n \n }\ndiff --git a/src/Functions/gcd.cpp b/src/Functions/gcd.cpp\nindex 52addfc66edf..f42f8f96cdb7 100644\n--- a/src/Functions/gcd.cpp\n+++ b/src/Functions/gcd.cpp\n@@ -2,6 +2,8 @@\n #include <Functions/FunctionBinaryArithmetic.h>\n #include <Functions/GCDLCMImpl.h>\n \n+#include <boost/integer/common_factor.hpp>\n+\n \n namespace DB\n {\n@@ -19,7 +21,7 @@ struct GCDImpl : public GCDLCMImpl<A, B, GCDImpl<A, B>, NameGCD>\n     static ResultType applyImpl(A a, B b)\n     {\n         using Int = typename NumberTraits::ToInteger<ResultType>::Type;\n-        return std::gcd(Int(a), Int(b));\n+        return boost::integer::gcd(Int(a), Int(b));\n     }\n };\n \ndiff --git a/src/Functions/generateUUIDv4.cpp b/src/Functions/generateUUIDv4.cpp\nindex a1e50e3c54fc..7ca127857df7 100644\n--- a/src/Functions/generateUUIDv4.cpp\n+++ b/src/Functions/generateUUIDv4.cpp\n@@ -32,21 +32,22 @@ class FunctionGenerateUUIDv4 : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        auto col_res = ColumnVector<UInt128>::create();\n-        typename ColumnVector<UInt128>::Container & vec_to = col_res->getData();\n+        auto col_res = ColumnVector<UUID>::create();\n+        typename ColumnVector<UUID>::Container & vec_to = col_res->getData();\n \n         size_t size = input_rows_count;\n         vec_to.resize(size);\n \n         /// RandImpl is target-dependent and is not the same in different TargetSpecific namespaces.\n-        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), vec_to.size() * sizeof(UInt128));\n+        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), vec_to.size() * sizeof(UUID));\n \n-        for (UInt128 & uuid: vec_to)\n+        for (UUID & uuid : vec_to)\n         {\n-            /** https://tools.ietf.org/html/rfc4122#section-4.4\n-             */\n-            uuid.low = (uuid.low & 0xffffffffffff0fffull) | 0x0000000000004000ull;\n-            uuid.high = (uuid.high & 0x3fffffffffffffffull) | 0x8000000000000000ull;\n+            /// https://tools.ietf.org/html/rfc4122#section-4.4\n+\n+            UInt128 & impl = uuid.toUnderType();\n+            impl.items[0] = (impl.items[0] & 0xffffffffffff0fffull) | 0x0000000000004000ull;\n+            impl.items[1] = (impl.items[1] & 0x3fffffffffffffffull) | 0x8000000000000000ull;\n         }\n \n         return col_res;\ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex a9b3a2245bd5..e1acd830dcb6 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -986,7 +986,7 @@ class FunctionIf : public FunctionIfBase\n             right_id = right_array->getNestedType()->getTypeId();\n \n         if (!(callOnBasicTypes<true, true, true, false>(left_id, right_id, call)\n-            || (res = executeTyped<UInt128, UInt128>(cond_col, arguments, result_type, input_rows_count))\n+            || (res = executeTyped<UUID, UUID>(cond_col, arguments, result_type, input_rows_count))\n             || (res = executeString(cond_col, arguments, result_type))\n             || (res = executeGenericArray(cond_col, arguments, result_type))\n             || (res = executeTuple(arguments, result_type, input_rows_count))))\ndiff --git a/src/Functions/lcm.cpp b/src/Functions/lcm.cpp\nindex f46e11dfa172..672d47d06b90 100644\n--- a/src/Functions/lcm.cpp\n+++ b/src/Functions/lcm.cpp\n@@ -2,6 +2,9 @@\n #include <Functions/FunctionBinaryArithmetic.h>\n #include <Functions/GCDLCMImpl.h>\n \n+#include <boost/integer/common_factor.hpp>\n+\n+\n namespace\n {\n \n@@ -46,7 +49,7 @@ struct LCMImpl : public GCDLCMImpl<A, B, LCMImpl<A, B>, NameLCM>\n           * (example: throw an exception or overflow in implementation specific way).\n           */\n \n-        Unsigned val1 = abs<Int>(a) / std::gcd(Int(a), Int(b));\n+        Unsigned val1 = abs<Int>(a) / boost::integer::gcd(Int(a), Int(b));\n         Unsigned val2 = abs<Int>(b);\n \n         /// Overflow in implementation specific way.\ndiff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp\nindex f8a7b8eec841..94c9eec58687 100644\n--- a/src/Functions/reinterpretAs.cpp\n+++ b/src/Functions/reinterpretAs.cpp\n@@ -409,6 +409,7 @@ struct NameReinterpretAsUInt8       { static constexpr auto name = \"reinterpretA\n struct NameReinterpretAsUInt16      { static constexpr auto name = \"reinterpretAsUInt16\"; };\n struct NameReinterpretAsUInt32      { static constexpr auto name = \"reinterpretAsUInt32\"; };\n struct NameReinterpretAsUInt64      { static constexpr auto name = \"reinterpretAsUInt64\"; };\n+struct NameReinterpretAsUInt128     { static constexpr auto name = \"reinterpretAsUInt128\"; };\n struct NameReinterpretAsUInt256     { static constexpr auto name = \"reinterpretAsUInt256\"; };\n struct NameReinterpretAsInt8        { static constexpr auto name = \"reinterpretAsInt8\"; };\n struct NameReinterpretAsInt16       { static constexpr auto name = \"reinterpretAsInt16\"; };\n@@ -428,6 +429,7 @@ using FunctionReinterpretAsUInt8 = FunctionReinterpretAs<DataTypeUInt8, NameRein\n using FunctionReinterpretAsUInt16 = FunctionReinterpretAs<DataTypeUInt16, NameReinterpretAsUInt16>;\n using FunctionReinterpretAsUInt32 = FunctionReinterpretAs<DataTypeUInt32, NameReinterpretAsUInt32>;\n using FunctionReinterpretAsUInt64 = FunctionReinterpretAs<DataTypeUInt64, NameReinterpretAsUInt64>;\n+using FunctionReinterpretAsUInt128 = FunctionReinterpretAs<DataTypeUInt128, NameReinterpretAsUInt128>;\n using FunctionReinterpretAsUInt256 = FunctionReinterpretAs<DataTypeUInt256, NameReinterpretAsUInt256>;\n using FunctionReinterpretAsInt8 = FunctionReinterpretAs<DataTypeInt8, NameReinterpretAsInt8>;\n using FunctionReinterpretAsInt16 = FunctionReinterpretAs<DataTypeInt16, NameReinterpretAsInt16>;\n@@ -453,6 +455,7 @@ void registerFunctionsReinterpretAs(FunctionFactory & factory)\n     factory.registerFunction<FunctionReinterpretAsUInt16>();\n     factory.registerFunction<FunctionReinterpretAsUInt32>();\n     factory.registerFunction<FunctionReinterpretAsUInt64>();\n+    factory.registerFunction<FunctionReinterpretAsUInt128>();\n     factory.registerFunction<FunctionReinterpretAsUInt256>();\n     factory.registerFunction<FunctionReinterpretAsInt8>();\n     factory.registerFunction<FunctionReinterpretAsInt16>();\ndiff --git a/src/Functions/roundToExp2.cpp b/src/Functions/roundToExp2.cpp\nindex 50a548e095ed..2abe94b2b263 100644\n--- a/src/Functions/roundToExp2.cpp\n+++ b/src/Functions/roundToExp2.cpp\n@@ -27,18 +27,6 @@ roundDownToPowerOfTwo(T x)\n     return x <= 0 ? 0 : (T(1) << (63 - __builtin_clzll(x)));\n }\n \n-template <typename T>\n-inline std::enable_if_t<std::is_same_v<T, Int128>, T>\n-roundDownToPowerOfTwo(T x)\n-{\n-    if (x <= 0)\n-        return 0;\n-\n-    if (Int64 x64 = Int64(x >> 64))\n-        return Int128(roundDownToPowerOfTwo(x64)) << 64;\n-    return roundDownToPowerOfTwo(Int64(x));\n-}\n-\n template <typename T>\n inline std::enable_if_t<std::is_same_v<T, Float32>, T>\n roundDownToPowerOfTwo(T x)\ndiff --git a/src/Functions/sign.cpp b/src/Functions/sign.cpp\nindex 3c03f4e1f2ef..8e2964c18597 100644\n--- a/src/Functions/sign.cpp\n+++ b/src/Functions/sign.cpp\n@@ -1,7 +1,7 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionUnaryArithmetic.h>\n #include <DataTypes/NumberTraits.h>\n-#include <Common/FieldVisitors.h>\n+\n \n namespace DB\n {\ndiff --git a/src/Functions/toUnixTimestamp64Micro.cpp b/src/Functions/toUnixTimestamp64Micro.cpp\nindex e1a9382e69af..f91f04dc519b 100644\n--- a/src/Functions/toUnixTimestamp64Micro.cpp\n+++ b/src/Functions/toUnixTimestamp64Micro.cpp\n@@ -3,22 +3,12 @@\n \n namespace DB\n {\n-namespace\n-{\n-\n-struct TransformToMicro\n-{\n-    static constexpr auto name = \"toUnixTimestamp64Micro\";\n-    static constexpr auto target_scale = 6;\n-    using SourceDataType = DataTypeDateTime64;\n-    using ResultDataType = DataTypeInt64;\n-};\n-\n-}\n \n void registerToUnixTimestamp64Micro(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformToMicro>>();\n+    factory.registerFunction(\"toUnixTimestamp64Micro\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionToUnixTimestamp64>(6, \"toUnixTimestamp64Micro\")); });\n }\n \n }\ndiff --git a/src/Functions/toUnixTimestamp64Milli.cpp b/src/Functions/toUnixTimestamp64Milli.cpp\nindex b49b1c9042b3..857ce973c563 100644\n--- a/src/Functions/toUnixTimestamp64Milli.cpp\n+++ b/src/Functions/toUnixTimestamp64Milli.cpp\n@@ -3,22 +3,12 @@\n \n namespace DB\n {\n-namespace\n-{\n-\n-struct TransformToMilli\n-{\n-    static constexpr auto name = \"toUnixTimestamp64Milli\";\n-    static constexpr auto target_scale = 3;\n-    using SourceDataType = DataTypeDateTime64;\n-    using ResultDataType = DataTypeInt64;\n-};\n-\n-}\n \n void registerToUnixTimestamp64Milli(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformToMilli>>();\n+    factory.registerFunction(\"toUnixTimestamp64Milli\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionToUnixTimestamp64>(3, \"toUnixTimestamp64Milli\")); });\n }\n \n }\ndiff --git a/src/Functions/toUnixTimestamp64Nano.cpp b/src/Functions/toUnixTimestamp64Nano.cpp\nindex 832d845434cd..7f065568f9f4 100644\n--- a/src/Functions/toUnixTimestamp64Nano.cpp\n+++ b/src/Functions/toUnixTimestamp64Nano.cpp\n@@ -3,22 +3,12 @@\n \n namespace DB\n {\n-namespace\n-{\n-\n-struct TransformToNano\n-{\n-    static constexpr auto name = \"toUnixTimestamp64Nano\";\n-    static constexpr auto target_scale = 9;\n-    using SourceDataType = DataTypeDateTime64;\n-    using ResultDataType = DataTypeInt64;\n-};\n-\n-}\n \n void registerToUnixTimestamp64Nano(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionUnixTimestamp64<TransformToNano>>();\n+    factory.registerFunction(\"toUnixTimestamp64Nano\",\n+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(\n+            std::make_shared<FunctionToUnixTimestamp64>(9, \"toUnixTimestamp64Nano\")); });\n }\n \n }\ndiff --git a/src/IO/MMappedFileCache.h b/src/IO/MMappedFileCache.h\nindex cbd1977350b8..adbb85a18cf7 100644\n--- a/src/IO/MMappedFileCache.h\n+++ b/src/IO/MMappedFileCache.h\n@@ -1,8 +1,9 @@\n #pragma once\n \n+#include <Core/Types.h>\n+#include <Common/HashTable/Hash.h>\n #include <Common/LRUCache.h>\n #include <Common/SipHash.h>\n-#include <Common/UInt128.h>\n #include <Common/ProfileEvents.h>\n #include <IO/MMappedFile.h>\n \n@@ -39,8 +40,7 @@ class MMappedFileCache : public LRUCache<UInt128, MMappedFile, UInt128TrivialHas\n         hash.update(offset);\n         hash.update(length);\n \n-        hash.get128(key.low, key.high);\n-\n+        hash.get128(key);\n         return key;\n     }\n \ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex 72ffd74a42d6..8e9a14a20fb6 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -81,11 +81,6 @@ void parseUUIDWithoutSeparator(const UInt8 * src36, std::reverse_iterator<UInt8\n     parseHex(&src36[16], dst16, 8);\n }\n \n-UInt128 stringToUUID(const String & str)\n-{\n-    return parseFromString<UUID>(str);\n-}\n-\n void NO_INLINE throwAtAssertionFailed(const char * s, ReadBuffer & buf)\n {\n     WriteBufferFromOwnString out;\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex cf25b819e6c0..9003ec2d9ed0 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -21,7 +21,6 @@\n #include <Common/Exception.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/Arena.h>\n-#include <Common/UInt128.h>\n #include <Common/intExp.h>\n \n #include <Formats/FormatSettings.h>\n@@ -51,7 +50,6 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_UUID;\n     extern const int CANNOT_READ_ARRAY_FROM_TEXT;\n     extern const int CANNOT_PARSE_NUMBER;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int INCORRECT_DATA;\n }\n \n@@ -257,13 +255,12 @@ enum class ReadIntTextCheckOverflow\n template <typename T, typename ReturnType = void, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>\n ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n {\n-    /// TODO: disabled for big ints cause of 127 vs 128 bit conversion\n-    using UnsignedT = std::conditional_t<is_big_int_v<T>, T, make_unsigned_t<T>>;\n+    using UnsignedT = make_unsigned_t<T>;\n \n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n     bool negative = false;\n-    UnsignedT res = 0;\n+    UnsignedT res{};\n     if (buf.eof())\n     {\n         if constexpr (throw_exception)\n@@ -305,7 +302,7 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n             case '8': [[fallthrough]];\n             case '9':\n             {\n-                if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)\n+                if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW && !is_big_int_v<T>)\n                 {\n                     /// Perform relativelly slow overflow check only when\n                     /// number of decimal digits so far is close to the max for given type.\n@@ -318,12 +315,8 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n                             || common::addOverflow<T>(signed_res, (*buf.position() - '0'), signed_res))\n                             return ReturnType(false);\n \n-                        /// Cannot assign signed to unsigned for big ints. Ignore fast path.\n-                        if constexpr (!is_big_int_v<T>)\n-                        {\n-                            res = signed_res;\n-                            break;\n-                        }\n+                        res = signed_res;\n+                        break;\n                     }\n                 }\n                 res *= 10;\n@@ -535,9 +528,6 @@ void parseUUIDWithoutSeparator(const UInt8 * src36, UInt8 * dst16);\n void parseUUID(const UInt8 * src36, std::reverse_iterator<UInt8 *> dst16);\n void parseUUIDWithoutSeparator(const UInt8 * src36, std::reverse_iterator<UInt8 *> dst16);\n \n-template <typename IteratorSrc, typename IteratorDst>\n-void formatHex(IteratorSrc src, IteratorDst dst, size_t num_bytes);\n-\n \n template <typename ReturnType>\n ReturnType readDateTextFallback(LocalDate & date, ReadBuffer & buf);\n@@ -686,13 +676,6 @@ inline T parseFromString(const std::string_view & str)\n     return parse<T>(str.data(), str.size());\n }\n \n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n-// Just dont mess with it. If the redundant redeclaration is removed then ReaderHelpers.h should be included.\n-// This leads to Arena.h inclusion which has a problem with ASAN stuff included properly and messing macro definition\n-// which intefrers with... You dont want to know, really.\n-UInt128 stringToUUID(const String & str);\n-#pragma GCC diagnostic pop\n \n template <typename ReturnType = void>\n ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut);\n@@ -839,16 +822,15 @@ readBinary(T & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n \n inline void readBinary(String & x, ReadBuffer & buf) { readStringBinary(x, buf); }\n inline void readBinary(Int128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n+inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(UInt128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n-inline void readBinary(DummyUInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n+inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal64 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal256 & x, ReadBuffer & buf) { readPODBinary(x.value, buf); }\n inline void readBinary(LocalDate & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n \n-inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n-inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n \n template <typename T>\n inline std::enable_if_t<is_arithmetic_v<T> && (sizeof(T) <= 8), void>\n@@ -889,13 +871,6 @@ inline void readText(String & x, ReadBuffer & buf) { readEscapedString(x, buf);\n inline void readText(LocalDate & x, ReadBuffer & buf) { readDateText(x, buf); }\n inline void readText(LocalDateTime & x, ReadBuffer & buf) { readDateTimeText(x, buf); }\n inline void readText(UUID & x, ReadBuffer & buf) { readUUIDText(x, buf); }\n-[[noreturn]] inline void readText(UInt128 &, ReadBuffer &)\n-{\n-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-\n-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.\n-     */\n-    throw Exception(\"UInt128 cannot be read as a text\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-}\n \n /// Generic methods to read value in text format,\n ///  possibly in single quotes (only for data types that use quotes in VALUES format of INSERT statement in SQL).\n@@ -975,13 +950,8 @@ inline void readCSV(String & x, ReadBuffer & buf, const FormatSettings::CSV & se\n inline void readCSV(LocalDate & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(LocalDateTime & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UUID & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n-[[noreturn]] inline void readCSV(UInt128 &, ReadBuffer &)\n-{\n-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-\n-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.\n-     */\n-    throw Exception(\"UInt128 cannot be read as a text\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-}\n+inline void readCSV(UInt128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n+inline void readCSV(Int128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UInt256 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(Int256 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n \ndiff --git a/src/IO/UncompressedCache.h b/src/IO/UncompressedCache.h\nindex b2f62ef2ada6..5826b7f020a0 100644\n--- a/src/IO/UncompressedCache.h\n+++ b/src/IO/UncompressedCache.h\n@@ -2,8 +2,8 @@\n \n #include <Common/LRUCache.h>\n #include <Common/SipHash.h>\n-#include <Common/UInt128.h>\n #include <Common/ProfileEvents.h>\n+#include <Common/HashTable/Hash.h>\n #include <IO/BufferWithOwnMemory.h>\n \n \n@@ -53,7 +53,7 @@ class UncompressedCache : public LRUCache<UInt128, UncompressedCacheCell, UInt12\n         SipHash hash;\n         hash.update(path_to_file.data(), path_to_file.size() + 1);\n         hash.update(offset);\n-        hash.get128(key.low, key.high);\n+        hash.get128(key);\n \n         return key;\n     }\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 0f8b5adee1af..3a79951e144a 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -6,12 +6,14 @@\n #include <algorithm>\n #include <iterator>\n \n+#include <pcg-random/pcg_random.hpp>\n+\n #include <common/DateLUT.h>\n #include <common/LocalDate.h>\n #include <common/LocalDateTime.h>\n #include <common/find_symbols.h>\n #include <common/StringRef.h>\n-#include <common/wide_integer_to_string.h>\n+#include <common/DecomposedFloat.h>\n \n #include <Core/DecimalFunctions.h>\n #include <Core/Types.h>\n@@ -19,7 +21,6 @@\n \n #include <Common/Exception.h>\n #include <Common/StringUtils/StringUtils.h>\n-#include <Common/UInt128.h>\n #include <Common/NaNUtils.h>\n \n #include <IO/CompressionMethod.h>\n@@ -48,14 +49,8 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n-template <typename T>\n-inline std::string bigintToString(const T & x)\n-{\n-    return to_string(x);\n-}\n \n /// Helper functions for formatted and binary output.\n \n@@ -137,81 +132,6 @@ inline void writeBoolText(bool x, WriteBuffer & buf)\n }\n \n \n-struct DecomposedFloat64\n-{\n-    DecomposedFloat64(double x)\n-    {\n-        memcpy(&x_uint, &x, sizeof(x));\n-    }\n-\n-    uint64_t x_uint;\n-\n-    bool sign() const\n-    {\n-        return x_uint >> 63;\n-    }\n-\n-    uint16_t exponent() const\n-    {\n-        return (x_uint >> 52) & 0x7FF;\n-    }\n-\n-    int16_t normalized_exponent() const\n-    {\n-        return int16_t(exponent()) - 1023;\n-    }\n-\n-    uint64_t mantissa() const\n-    {\n-        return x_uint & 0x5affffffffffffful;\n-    }\n-\n-    /// NOTE Probably floating point instructions can be better.\n-    bool is_inside_int64() const\n-    {\n-        return x_uint == 0\n-            || (normalized_exponent() >= 0 && normalized_exponent() <= 52\n-                && ((mantissa() & ((1ULL << (52 - normalized_exponent())) - 1)) == 0));\n-    }\n-};\n-\n-struct DecomposedFloat32\n-{\n-    DecomposedFloat32(float x)\n-    {\n-        memcpy(&x_uint, &x, sizeof(x));\n-    }\n-\n-    uint32_t x_uint;\n-\n-    bool sign() const\n-    {\n-        return x_uint >> 31;\n-    }\n-\n-    uint16_t exponent() const\n-    {\n-        return (x_uint >> 23) & 0xFF;\n-    }\n-\n-    int16_t normalized_exponent() const\n-    {\n-        return int16_t(exponent()) - 127;\n-    }\n-\n-    uint32_t mantissa() const\n-    {\n-        return x_uint & 0x7fffff;\n-    }\n-\n-    bool is_inside_int32() const\n-    {\n-        return x_uint == 0\n-            || (normalized_exponent() >= 0 && normalized_exponent() <= 23\n-                && ((mantissa() & ((1ULL << (23 - normalized_exponent())) - 1)) == 0));\n-    }\n-};\n-\n template <typename T>\n inline size_t writeFloatTextFastPath(T x, char * buffer)\n {\n@@ -222,14 +142,14 @@ inline size_t writeFloatTextFastPath(T x, char * buffer)\n         /// The library Ryu has low performance on integers.\n         /// This workaround improves performance 6..10 times.\n \n-        if (DecomposedFloat64(x).is_inside_int64())\n+        if (DecomposedFloat64(x).is_integer_in_representable_range())\n             result = itoa(Int64(x), buffer) - buffer;\n         else\n             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;\n     }\n     else\n     {\n-        if (DecomposedFloat32(x).is_inside_int32())\n+        if (DecomposedFloat32(x).is_integer_in_representable_range())\n             result = itoa(Int32(x), buffer) - buffer;\n         else\n             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;\n@@ -742,13 +662,12 @@ void formatUUID(std::reverse_iterator<const UInt8 *> src16, UInt8 * dst36);\n inline void writeUUIDText(const UUID & uuid, WriteBuffer & buf)\n {\n     char s[36];\n-\n     formatUUID(std::reverse_iterator<const UInt8 *>(reinterpret_cast<const UInt8 *>(&uuid) + 16), reinterpret_cast<UInt8 *>(s));\n     buf.write(s, sizeof(s));\n }\n \n-template<typename DecimalType>\n-inline void writeDecimalTypeFractionalText(typename DecimalType::NativeType fractional, UInt32 scale, WriteBuffer & buf)\n+template <typename DecimalType>\n+inline void writeDateTime64FractionalText(typename DecimalType::NativeType fractional, UInt32 scale, WriteBuffer & buf)\n {\n     static constexpr UInt32 MaxScale = DecimalUtils::max_precision<DecimalType>;\n \n@@ -878,7 +797,7 @@ inline void writeDateTimeText(DateTime64 datetime64, UInt32 scale, WriteBuffer &\n     if (scale > 0)\n     {\n         buf.write(fractional_time_delimiter);\n-        writeDecimalTypeFractionalText<DateTime64>(components.fractional, scale, buf);\n+        writeDateTime64FractionalText<DateTime64>(components.fractional, scale, buf);\n     }\n }\n \n@@ -931,7 +850,7 @@ inline void writeDateTimeUnixTimestamp(DateTime64 datetime64, UInt32 scale, Writ\n     if (scale > 0) //-V547\n     {\n         buf.write('.');\n-        writeDecimalTypeFractionalText<DateTime64>(components.fractional, scale, buf);\n+        writeDateTime64FractionalText<DateTime64>(components.fractional, scale, buf);\n     }\n }\n \n@@ -943,23 +862,17 @@ writeBinary(const T & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const String & x, WriteBuffer & buf) { writeStringBinary(x, buf); }\n inline void writeBinary(const StringRef & x, WriteBuffer & buf) { writeStringBinary(x, buf); }\n inline void writeBinary(const std::string_view & x, WriteBuffer & buf) { writeStringBinary(x, buf); }\n-inline void writeBinary(const Int128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-inline void writeBinary(const UInt128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-inline void writeBinary(const UUID & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-inline void writeBinary(const DummyUInt256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal32 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal64 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const Decimal256 & x, WriteBuffer & buf) { writePODBinary(x.value, buf); }\n inline void writeBinary(const LocalDate & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const LocalDateTime & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-\n-inline void writeBinary(const UInt256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n-inline void writeBinary(const Int256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n+inline void writeBinary(const UUID & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n \n /// Methods for outputting the value in text form for a tab-separated format.\n template <typename T>\n-inline std::enable_if_t<is_integer_v<T> && !is_big_int_v<T>, void>\n+inline std::enable_if_t<is_integer_v<T>, void>\n writeText(const T & x, WriteBuffer & buf) { writeIntText(x, buf); }\n \n template <typename T>\n@@ -980,23 +893,18 @@ inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(Local\n inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }\n inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }\n inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }\n-inline void writeText(const UInt128 & x, WriteBuffer & buf) { writeText(UUID(x), buf); }\n-inline void writeText(const UInt256 & x, WriteBuffer & buf) { writeText(bigintToString(x), buf); }\n-inline void writeText(const Int256 & x, WriteBuffer & buf) { writeText(bigintToString(x), buf); }\n \n template <typename T>\n String decimalFractional(const T & x, UInt32 scale)\n {\n     if constexpr (std::is_same_v<T, Int256>)\n     {\n-        static constexpr Int128 max_int128 = (Int128(0x7fffffffffffffffll) << 64) + 0xffffffffffffffffll;\n-\n         if (x <= std::numeric_limits<UInt32>::max())\n             return decimalFractional(static_cast<UInt32>(x), scale);\n         else if (x <= std::numeric_limits<UInt64>::max())\n             return decimalFractional(static_cast<UInt64>(x), scale);\n-        else if (x <= max_int128)\n-            return decimalFractional(static_cast<Int128>(x), scale);\n+        else if (x <= std::numeric_limits<UInt128>::max())\n+            return decimalFractional(static_cast<UInt128>(x), scale);\n     }\n     else if constexpr (std::is_same_v<T, Int128>)\n     {\n@@ -1023,10 +931,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr)\n         writeChar('-', ostr); /// avoid crop leading minus when whole part is zero\n     }\n \n-    if constexpr (std::is_same_v<T, Int256>)\n-        writeText(part, ostr);\n-    else\n-        writeIntText(part, ostr);\n+    writeIntText(part, ostr);\n \n     if (scale)\n     {\n@@ -1069,19 +974,6 @@ inline void writeQuoted(const UUID & x, WriteBuffer & buf)\n     writeChar('\\'', buf);\n }\n \n-inline void writeQuoted(const UInt256 & x, WriteBuffer & buf)\n-{\n-    writeChar('\\'', buf);\n-    writeText(x, buf);\n-    writeChar('\\'', buf);\n-}\n-\n-inline void writeQuoted(const Int256 & x, WriteBuffer & buf)\n-{\n-    writeChar('\\'', buf);\n-    writeText(x, buf);\n-    writeChar('\\'', buf);\n-}\n \n /// String, date, datetime are in double quotes with C-style escaping. Numbers - without.\n template <typename T>\n@@ -1125,13 +1017,6 @@ inline void writeCSV(const String & x, WriteBuffer & buf) { writeCSVString<>(x,\n inline void writeCSV(const LocalDate & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n inline void writeCSV(const LocalDateTime & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n inline void writeCSV(const UUID & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n-[[noreturn]] inline void writeCSV(const UInt128, WriteBuffer &)\n-{\n-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-\n-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.\n-     */\n-    throw Exception(\"UInt128 cannot be write as a text\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-}\n \n template <typename T>\n void writeBinary(const std::vector<T> & x, WriteBuffer & buf)\ndiff --git a/src/IO/WriteIntText.h b/src/IO/WriteIntText.h\nindex 93444e7df730..456aed350fcb 100644\n--- a/src/IO/WriteIntText.h\n+++ b/src/IO/WriteIntText.h\n@@ -4,8 +4,24 @@\n #include <IO/WriteBuffer.h>\n #include <common/itoa.h>\n \n-/// 40 digits or 39 digits and a sign\n-#define WRITE_HELPERS_MAX_INT_WIDTH 40U\n+\n+namespace\n+{\n+    template <typename T> constexpr size_t max_int_width = 20;\n+    template <> inline constexpr size_t max_int_width<UInt8> = 3;    /// 255\n+    template <> inline constexpr size_t max_int_width<Int8> = 4;     /// -128\n+    template <> inline constexpr size_t max_int_width<UInt16> = 5;   /// 65535\n+    template <> inline constexpr size_t max_int_width<Int16> = 6;    /// -32768\n+    template <> inline constexpr size_t max_int_width<UInt32> = 10;  /// 4294967295\n+    template <> inline constexpr size_t max_int_width<Int32> = 11;   /// -2147483648\n+    template <> inline constexpr size_t max_int_width<UInt64> = 20;  /// 18446744073709551615\n+    template <> inline constexpr size_t max_int_width<Int64> = 20;   /// -9223372036854775808\n+    template <> inline constexpr size_t max_int_width<UInt128> = 39; /// 340282366920938463463374607431768211455\n+    template <> inline constexpr size_t max_int_width<Int128> = 40;  /// -170141183460469231731687303715884105728\n+    template <> inline constexpr size_t max_int_width<UInt256> = 78; /// 115792089237316195423570985008687907853269984665640564039457584007913129639935\n+    template <> inline constexpr size_t max_int_width<Int256> = 78;  /// -57896044618658097711785492504343953926634992332820282019728792003956564819968\n+}\n+\n \n namespace DB\n {\n@@ -15,16 +31,16 @@ namespace detail\n     template <typename T>\n     void NO_INLINE writeUIntTextFallback(T x, WriteBuffer & buf)\n     {\n-        char tmp[WRITE_HELPERS_MAX_INT_WIDTH];\n-        int len = itoa(x, tmp) - tmp;\n-        buf.write(tmp, len);\n+        char tmp[max_int_width<T>];\n+        char * end = itoa(x, tmp);\n+        buf.write(tmp, end - tmp);\n     }\n }\n \n template <typename T>\n void writeIntText(T x, WriteBuffer & buf)\n {\n-    if (likely(reinterpret_cast<intptr_t>(buf.position()) + WRITE_HELPERS_MAX_INT_WIDTH < reinterpret_cast<intptr_t>(buf.buffer().end())))\n+    if (likely(reinterpret_cast<uintptr_t>(buf.position()) + max_int_width<T> < reinterpret_cast<uintptr_t>(buf.buffer().end())))\n         buf.position() = itoa(x, buf.position());\n     else\n         detail::writeUIntTextFallback(x, buf);\ndiff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h\nindex 203d8e3963bb..6545155aa6e0 100644\n--- a/src/IO/readDecimalText.h\n+++ b/src/IO/readDecimalText.h\n@@ -3,6 +3,7 @@\n #include <limits>\n #include <IO/ReadHelpers.h>\n #include <Common/intExp.h>\n+#include <common/wide_integer_to_string.h>\n \n \n namespace DB\n@@ -160,7 +161,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_\n             \" Expected to read decimal with scale {} and precision {}\";\n \n         if constexpr (is_big_int_v<typename T::NativeType>)\n-            throw Exception(fmt::format(pattern, digits, bigintToString(x.value), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+            throw Exception(fmt::format(pattern, digits, x.value, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n         else\n             throw Exception(fmt::format(pattern, digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n     }\ndiff --git a/src/Interpreters/AggregationCommon.h b/src/Interpreters/AggregationCommon.h\nindex 43b0671f6612..dc94c2981b33 100644\n--- a/src/Interpreters/AggregationCommon.h\n+++ b/src/Interpreters/AggregationCommon.h\n@@ -4,7 +4,6 @@\n \n #include <Common/SipHash.h>\n #include <Common/Arena.h>\n-#include <Common/UInt128.h>\n #include <Common/HashTable/Hash.h>\n #include <Common/memcpySmall.h>\n #include <Common/assert_cast.h>\n@@ -265,7 +264,7 @@ static inline UInt128 ALWAYS_INLINE hash128(\n     for (size_t j = 0; j < keys_size; ++j)\n         key_columns[j]->updateHashWithValue(i, hash);\n \n-    hash.get128(key.low, key.high);\n+    hash.get128(key);\n \n     return key;\n }\ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex b78e1186cc98..18482a2ef0ad 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -325,7 +325,7 @@ AggregatedDataVariants::Type Aggregator::chooseAggregationMethod()\n             /// into a fixed 16- or 32-byte blob.\n             if (std::tuple_size<KeysNullMap<UInt128>>::value + keys_bytes <= 16)\n                 return AggregatedDataVariants::Type::nullable_keys128;\n-            if (std::tuple_size<KeysNullMap<DummyUInt256>>::value + keys_bytes <= 32)\n+            if (std::tuple_size<KeysNullMap<UInt256>>::value + keys_bytes <= 32)\n                 return AggregatedDataVariants::Type::nullable_keys256;\n         }\n \ndiff --git a/src/Interpreters/Aggregator.h b/src/Interpreters/Aggregator.h\nindex 31eefe03b3ce..38b80d8923b2 100644\n--- a/src/Interpreters/Aggregator.h\n+++ b/src/Interpreters/Aggregator.h\n@@ -15,7 +15,6 @@\n #include <Common/HashTable/TwoLevelStringHashMap.h>\n \n #include <Common/ThreadPool.h>\n-#include <Common/UInt128.h>\n #include <Common/ColumnsHashing.h>\n #include <Common/assert_cast.h>\n #include <Common/filesystemHelpers.h>\n@@ -78,7 +77,7 @@ using AggregatedDataWithShortStringKey = StringHashMap<AggregateDataPtr>;\n using AggregatedDataWithStringKey = HashMapWithSavedHash<StringRef, AggregateDataPtr>;\n \n using AggregatedDataWithKeys128 = HashMap<UInt128, AggregateDataPtr, UInt128HashCRC32>;\n-using AggregatedDataWithKeys256 = HashMap<DummyUInt256, AggregateDataPtr, UInt256HashCRC32>;\n+using AggregatedDataWithKeys256 = HashMap<UInt256, AggregateDataPtr, UInt256HashCRC32>;\n \n using AggregatedDataWithUInt32KeyTwoLevel = TwoLevelHashMap<UInt32, AggregateDataPtr, HashCRC32<UInt32>>;\n using AggregatedDataWithUInt64KeyTwoLevel = TwoLevelHashMap<UInt64, AggregateDataPtr, HashCRC32<UInt64>>;\n@@ -88,7 +87,7 @@ using AggregatedDataWithShortStringKeyTwoLevel = TwoLevelStringHashMap<Aggregate\n using AggregatedDataWithStringKeyTwoLevel = TwoLevelHashMapWithSavedHash<StringRef, AggregateDataPtr>;\n \n using AggregatedDataWithKeys128TwoLevel = TwoLevelHashMap<UInt128, AggregateDataPtr, UInt128HashCRC32>;\n-using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<DummyUInt256, AggregateDataPtr, UInt256HashCRC32>;\n+using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<UInt256, AggregateDataPtr, UInt256HashCRC32>;\n \n /** Variants with better hash function, using more than 32 bits for hash.\n   * Using for merging phase of external aggregation, where number of keys may be far greater than 4 billion,\n@@ -100,7 +99,7 @@ using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<DummyUInt256, Aggregat\n using AggregatedDataWithUInt64KeyHash64 = HashMap<UInt64, AggregateDataPtr, DefaultHash<UInt64>>;\n using AggregatedDataWithStringKeyHash64 = HashMapWithSavedHash<StringRef, AggregateDataPtr, StringRefHash64>;\n using AggregatedDataWithKeys128Hash64 = HashMap<UInt128, AggregateDataPtr, UInt128Hash>;\n-using AggregatedDataWithKeys256Hash64 = HashMap<DummyUInt256, AggregateDataPtr, UInt256Hash>;\n+using AggregatedDataWithKeys256Hash64 = HashMap<UInt256, AggregateDataPtr, UInt256Hash>;\n \n template <typename Base>\n struct AggregationDataWithNullKey : public Base\ndiff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\nindex 5c071ed9134c..bdd9ce327078 100644\n--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n@@ -64,6 +64,8 @@ Field zeroField(const Field & value)\n         case Field::Types::Float64: return Float64(0);\n         case Field::Types::UInt128: return UInt128(0);\n         case Field::Types::Int128: return Int128(0);\n+        case Field::Types::UInt256: return UInt256(0);\n+        case Field::Types::Int256: return Int256(0);\n         default:\n             break;\n     }\ndiff --git a/src/Interpreters/BloomFilterHash.h b/src/Interpreters/BloomFilterHash.h\nindex b64f7bae79d5..b88ca36ad845 100644\n--- a/src/Interpreters/BloomFilterHash.h\n+++ b/src/Interpreters/BloomFilterHash.h\n@@ -93,7 +93,7 @@ struct BloomFilterHash\n         else if (which.isDateTime()) return build_hash_column(getNumberTypeHash<UInt64, UInt32>(field));\n         else if (which.isFloat32()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));\n         else if (which.isFloat64()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));\n-        else if (which.isUUID()) return build_hash_column(getNumberTypeHash<UInt128, UInt128>(field));\n+        else if (which.isUUID()) return build_hash_column(getNumberTypeHash<UUID, UUID>(field));\n         else if (which.isString()) return build_hash_column(getStringTypeHash(field));\n         else if (which.isFixedString()) return build_hash_column(getFixedStringTypeHash(field, data_type));\n         else throw Exception(\"Unexpected type \" + data_type->getName() + \" of bloom filter index.\", ErrorCodes::BAD_ARGUMENTS);\n@@ -154,7 +154,7 @@ struct BloomFilterHash\n         else if (which.isDateTime()) getNumberTypeHash<UInt32, is_first>(column, vec, pos);\n         else if (which.isFloat32()) getNumberTypeHash<Float32, is_first>(column, vec, pos);\n         else if (which.isFloat64()) getNumberTypeHash<Float64, is_first>(column, vec, pos);\n-        else if (which.isUUID()) getNumberTypeHash<UInt128, is_first>(column, vec, pos);\n+        else if (which.isUUID()) getNumberTypeHash<UUID, is_first>(column, vec, pos);\n         else if (which.isString()) getStringTypeHash<is_first>(column, vec, pos);\n         else if (which.isFixedString()) getStringTypeHash<is_first>(column, vec, pos);\n         else throw Exception(\"Unexpected type \" + data_type->getName() + \" of bloom filter index.\", ErrorCodes::BAD_ARGUMENTS);\ndiff --git a/src/Interpreters/ClientInfo.cpp b/src/Interpreters/ClientInfo.cpp\nindex 223837aaf3d5..248c8cc6b807 100644\n--- a/src/Interpreters/ClientInfo.cpp\n+++ b/src/Interpreters/ClientInfo.cpp\n@@ -71,7 +71,7 @@ void ClientInfo::write(WriteBuffer & out, const UInt64 server_protocol_revision)\n \n     if (server_protocol_revision >= DBMS_MIN_REVISION_WITH_OPENTELEMETRY)\n     {\n-        if (client_trace_context.trace_id)\n+        if (client_trace_context.trace_id != UUID())\n         {\n             // Have OpenTelemetry header.\n             writeBinary(uint8_t(1), out);\ndiff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h\nindex 60abb0dd671e..b4579877ef66 100644\n--- a/src/Interpreters/ClientInfo.h\n+++ b/src/Interpreters/ClientInfo.h\n@@ -2,7 +2,6 @@\n \n #include <Core/UUID.h>\n #include <Poco/Net/SocketAddress.h>\n-#include <Common/UInt128.h>\n #include <common/types.h>\n #include <Common/OpenTelemetryTraceContext.h>\n \ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 8d3a4719ceeb..76a921c81e94 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1228,13 +1228,13 @@ void Context::setCurrentQueryId(const String & query_id)\n             UInt64 a;\n             UInt64 b;\n         } words;\n-        __uint128_t uuid;\n+        UUID uuid{};\n     } random;\n \n     random.words.a = thread_local_rng(); //-V656\n     random.words.b = thread_local_rng(); //-V656\n \n-    if (client_info.client_trace_context.trace_id != 0)\n+    if (client_info.client_trace_context.trace_id != UUID())\n     {\n         // Use the OpenTelemetry trace context we received from the client, and\n         // create a new span for the query.\ndiff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h\nindex 4fa6c5c0a108..5f6936f8b189 100644\n--- a/src/Interpreters/DatabaseCatalog.h\n+++ b/src/Interpreters/DatabaseCatalog.h\n@@ -226,7 +226,7 @@ class DatabaseCatalog : boost::noncopyable, WithContext\n \n     static inline size_t getFirstLevelIdx(const UUID & uuid)\n     {\n-        return uuid.toUnderType().low >> (64 - bits_for_first_level);\n+        return uuid.toUnderType().items[0] >> (64 - bits_for_first_level);\n     }\n \n     struct TableMarkedAsDropped\ndiff --git a/src/Interpreters/ExpressionJIT.h b/src/Interpreters/ExpressionJIT.h\nindex 899c08a5296b..b7a7dd64cdda 100644\n--- a/src/Interpreters/ExpressionJIT.h\n+++ b/src/Interpreters/ExpressionJIT.h\n@@ -7,6 +7,7 @@\n #if USE_EMBEDDED_COMPILER\n #    include <Functions/IFunctionImpl.h>\n #    include <Common/LRUCache.h>\n+#    include <Common/HashTable/Hash.h>\n \n \n namespace DB\ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex d6163ff773a3..51373ea49d4a 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -384,7 +384,7 @@ template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin:\n };\n template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin::Type::keys256, Value, Mapped>\n {\n-    using Type = ColumnsHashing::HashMethodKeysFixed<Value, DummyUInt256, Mapped, false, false, false, use_offset>;\n+    using Type = ColumnsHashing::HashMethodKeysFixed<Value, UInt256, Mapped, false, false, false, use_offset>;\n };\n template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin::Type::hashed, Value, Mapped>\n {\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex c0a699d0a127..5ec8ed92f105 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -224,15 +224,15 @@ class HashJoin : public IJoin\n     template <typename Mapped>\n     struct MapsTemplate\n     {\n-        std::unique_ptr<FixedHashMap<UInt8, Mapped>>   key8;\n-        std::unique_ptr<FixedHashMap<UInt16, Mapped>> key16;\n-        std::unique_ptr<HashMap<UInt32, Mapped, HashCRC32<UInt32>>>                     key32;\n-        std::unique_ptr<HashMap<UInt64, Mapped, HashCRC32<UInt64>>>                     key64;\n-        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>                        key_string;\n-        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>                        key_fixed_string;\n-        std::unique_ptr<HashMap<UInt128, Mapped, UInt128HashCRC32>>                     keys128;\n-        std::unique_ptr<HashMap<DummyUInt256, Mapped, UInt256HashCRC32>>                keys256;\n-        std::unique_ptr<HashMap<UInt128, Mapped, UInt128TrivialHash>>                   hashed;\n+        std::unique_ptr<FixedHashMap<UInt8, Mapped>>                  key8;\n+        std::unique_ptr<FixedHashMap<UInt16, Mapped>>                 key16;\n+        std::unique_ptr<HashMap<UInt32, Mapped, HashCRC32<UInt32>>>   key32;\n+        std::unique_ptr<HashMap<UInt64, Mapped, HashCRC32<UInt64>>>   key64;\n+        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>      key_string;\n+        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>      key_fixed_string;\n+        std::unique_ptr<HashMap<UInt128, Mapped, UInt128HashCRC32>>   keys128;\n+        std::unique_ptr<HashMap<UInt256, Mapped, UInt256HashCRC32>>   keys256;\n+        std::unique_ptr<HashMap<UInt128, Mapped, UInt128TrivialHash>> hashed;\n \n         void create(Type which)\n         {\ndiff --git a/src/Interpreters/JIT/CompileDAG.cpp b/src/Interpreters/JIT/CompileDAG.cpp\nindex 6737069f31c2..5fc88e7884cb 100644\n--- a/src/Interpreters/JIT/CompileDAG.cpp\n+++ b/src/Interpreters/JIT/CompileDAG.cpp\n@@ -171,7 +171,7 @@ UInt128 CompileDAG::hash() const\n     }\n \n     UInt128 result;\n-    hash.get128(result.low, result.high);\n+    hash.get128(result);\n     return result;\n }\n \ndiff --git a/src/Interpreters/JIT/CompileDAG.h b/src/Interpreters/JIT/CompileDAG.h\nindex 3872a896e383..a981c801e304 100644\n--- a/src/Interpreters/JIT/CompileDAG.h\n+++ b/src/Interpreters/JIT/CompileDAG.h\n@@ -9,7 +9,6 @@\n #include <vector>\n \n #include <Core/Types.h>\n-#include <Common/UInt128.h>\n \n #include <Columns/IColumn.h>\n #include <DataTypes/IDataType.h>\ndiff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\nindex 2420255c5c1b..40508488d051 100644\n--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n@@ -185,7 +185,7 @@ static inline std::tuple<NamesAndTypesList, NamesAndTypesList, NamesAndTypesList\n                     {\n                         const auto & prefix_limit = function->arguments->children[0]->as<ASTLiteral>();\n \n-                        if (prefix_limit && isInt64FieldType(prefix_limit->value.getType()))\n+                        if (prefix_limit && isInt64OrUInt64FieldType(prefix_limit->value.getType()))\n                             res->children.back() = std::make_shared<ASTIdentifier>(function->name);\n                     }\n                 }\ndiff --git a/src/Interpreters/OpenTelemetrySpanLog.cpp b/src/Interpreters/OpenTelemetrySpanLog.cpp\nindex c72b0f3d3265..727a60f22608 100644\n--- a/src/Interpreters/OpenTelemetrySpanLog.cpp\n+++ b/src/Interpreters/OpenTelemetrySpanLog.cpp\n@@ -8,6 +8,9 @@\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeUUID.h>\n \n+#include <Common/hex.h>\n+\n+\n namespace DB\n {\n \n@@ -43,7 +46,7 @@ void OpenTelemetrySpanLogElement::appendToBlock(MutableColumns & columns) const\n {\n     size_t i = 0;\n \n-    columns[i++]->insert(UInt128(Int128(trace_id)));\n+    columns[i++]->insert(trace_id);\n     columns[i++]->insert(span_id);\n     columns[i++]->insert(parent_span_id);\n     columns[i++]->insert(operation_name);\n@@ -79,10 +82,8 @@ OpenTelemetrySpanHolder::OpenTelemetrySpanHolder(const std::string & _operation_\n     auto & thread = CurrentThread::get();\n \n     trace_id = thread.thread_trace_context.trace_id;\n-    if (!trace_id)\n-    {\n+    if (trace_id == UUID())\n         return;\n-    }\n \n     parent_span_id = thread.thread_trace_context.span_id;\n     span_id = thread_local_rng();\n@@ -98,10 +99,8 @@ OpenTelemetrySpanHolder::~OpenTelemetrySpanHolder()\n {\n     try\n     {\n-        if (!trace_id)\n-        {\n+        if (trace_id == UUID())\n             return;\n-        }\n \n         // First of all, return old value of current span.\n         auto & thread = CurrentThread::get();\n@@ -145,18 +144,31 @@ OpenTelemetrySpanHolder::~OpenTelemetrySpanHolder()\n }\n \n \n+template <typename T>\n+static T readHex(const char * data)\n+{\n+    T x{};\n+\n+    const char * end = data + sizeof(T) * 2;\n+    while (data < end)\n+    {\n+        x *= 16;\n+        x += unhex(*data);\n+        ++data;\n+    }\n+\n+    return x;\n+}\n+\n+\n bool OpenTelemetryTraceContext::parseTraceparentHeader(const std::string & traceparent,\n     std::string & error)\n {\n     trace_id = 0;\n \n-    uint8_t version = -1;\n-    uint64_t trace_id_high = 0;\n-    uint64_t trace_id_low = 0;\n-\n     // Version 00, which is the only one we can parse, is fixed width. Use this\n     // fact for an additional sanity check.\n-    const int expected_length = 2 + 1 + 32 + 1 + 16 + 1 + 2;\n+    const int expected_length = strlen(\"xx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xx\");\n     if (traceparent.length() != expected_length)\n     {\n         error = fmt::format(\"unexpected length {}, expected {}\",\n@@ -164,39 +176,46 @@ bool OpenTelemetryTraceContext::parseTraceparentHeader(const std::string & trace\n         return false;\n     }\n \n-    // clang-tidy doesn't like sscanf:\n-    //   error: 'sscanf' used to convert a string to an unsigned integer value,\n-    //   but function will not report conversion errors; consider using 'strtoul'\n-    //   instead [cert-err34-c,-warnings-as-errors]\n-    // There is no other ready solution, and hand-rolling a more complicated\n-    // parser for an HTTP header in C++ sounds like RCE.\n-    // NOLINTNEXTLINE(cert-err34-c)\n-    int result = sscanf(&traceparent[0],\n-        \"%2\" SCNx8 \"-%16\" SCNx64 \"%16\" SCNx64 \"-%16\" SCNx64 \"-%2\" SCNx8,\n-        &version, &trace_id_high, &trace_id_low, &span_id, &trace_flags);\n-\n-    if (result == EOF)\n+    const char * data = traceparent.data();\n+\n+    uint8_t version = readHex<uint8_t>(data);\n+    data += 2;\n+\n+    if (version != 0)\n     {\n-        error = \"EOF\";\n+        error = fmt::format(\"unexpected version {}, expected 00\", version);\n         return false;\n     }\n \n-    // We read uint128 as two uint64, so 5 parts and not 4.\n-    if (result != 5)\n+    if (*data != '-')\n     {\n-        error = fmt::format(\"could only read {} parts instead of the expected 5\",\n-            result);\n+        error = fmt::format(\"Malformed traceparant header: {}\", traceparent);\n         return false;\n     }\n \n-    if (version != 0)\n+    ++data;\n+    UInt128 trace_id_128 = readHex<UInt128>(data);\n+    trace_id = trace_id_128;\n+    data += 32;\n+\n+    if (*data != '-')\n     {\n-        error = fmt::format(\"unexpected version {}, expected 00\", version);\n+        error = fmt::format(\"Malformed traceparant header: {}\", traceparent);\n+        return false;\n+    }\n+\n+    ++data;\n+    span_id = readHex<UInt64>(data);\n+    data += 16;\n+\n+    if (*data != '-')\n+    {\n+        error = fmt::format(\"Malformed traceparant header: {}\", traceparent);\n         return false;\n     }\n \n-    trace_id = static_cast<__uint128_t>(trace_id_high) << 64\n-        | trace_id_low;\n+    ++data;\n+    trace_flags = readHex<UInt8>(data);\n     return true;\n }\n \n@@ -205,7 +224,7 @@ std::string OpenTelemetryTraceContext::composeTraceparentHeader() const\n {\n     // This span is a parent for its children, so we specify this span_id as a\n     // parent id.\n-    return fmt::format(\"00-{:032x}-{:016x}-{:02x}\", trace_id,\n+    return fmt::format(\"00-{:032x}-{:016x}-{:02x}\", __uint128_t(trace_id.toUnderType()),\n         span_id,\n         // This cast is needed because fmt is being weird and complaining that\n         // \"mixing character types is not allowed\".\ndiff --git a/src/Interpreters/OpenTelemetrySpanLog.h b/src/Interpreters/OpenTelemetrySpanLog.h\nindex f74e1f0c9fd8..861293b4f980 100644\n--- a/src/Interpreters/OpenTelemetrySpanLog.h\n+++ b/src/Interpreters/OpenTelemetrySpanLog.h\n@@ -7,7 +7,7 @@ namespace DB\n \n struct OpenTelemetrySpan\n {\n-    __uint128_t trace_id;\n+    UUID trace_id;\n     UInt64 span_id;\n     UInt64 parent_span_id;\n     std::string operation_name;\ndiff --git a/src/Interpreters/RewriteSumIfFunctionVisitor.cpp b/src/Interpreters/RewriteSumIfFunctionVisitor.cpp\nindex 2593c220c631..7b322ca1585a 100644\n--- a/src/Interpreters/RewriteSumIfFunctionVisitor.cpp\n+++ b/src/Interpreters/RewriteSumIfFunctionVisitor.cpp\n@@ -29,7 +29,7 @@ void RewriteSumIfFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast,\n     {\n         /// sumIf(1, cond) -> countIf(cond)\n         const auto * literal = func_arguments[0]->as<ASTLiteral>();\n-        if (!literal || !DB::isInt64FieldType(literal->value.getType()))\n+        if (!literal || !DB::isInt64OrUInt64FieldType(literal->value.getType()))\n             return;\n \n         if (func_arguments.size() == 2 && literal->value.get<UInt64>() == 1)\n@@ -54,7 +54,7 @@ void RewriteSumIfFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast,\n \n         if (first_literal && second_literal)\n         {\n-            if (!DB::isInt64FieldType(first_literal->value.getType()) || !DB::isInt64FieldType(second_literal->value.getType()))\n+            if (!DB::isInt64OrUInt64FieldType(first_literal->value.getType()) || !DB::isInt64OrUInt64FieldType(second_literal->value.getType()))\n                 return;\n \n             auto first_value = first_literal->value.get<UInt64>();\ndiff --git a/src/Interpreters/Set.cpp b/src/Interpreters/Set.cpp\nindex b150eabda65a..713be3c1447f 100644\n--- a/src/Interpreters/Set.cpp\n+++ b/src/Interpreters/Set.cpp\n@@ -1,7 +1,6 @@\n #include <optional>\n \n #include <Core/Field.h>\n-#include <Common/FieldVisitors.h>\n #include <Core/Row.h>\n \n #include <Columns/ColumnsNumber.h>\ndiff --git a/src/Interpreters/SetVariants.cpp b/src/Interpreters/SetVariants.cpp\nindex eb21333e3ecf..1cc0f767ecc2 100644\n--- a/src/Interpreters/SetVariants.cpp\n+++ b/src/Interpreters/SetVariants.cpp\n@@ -122,7 +122,7 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose\n                 throw Exception{\"Aggregator: keys sizes overflow\", ErrorCodes::LOGICAL_ERROR};\n             if ((std::tuple_size<KeysNullMap<UInt128>>::value + keys_bytes) <= 16)\n                 return Type::nullable_keys128;\n-            if ((std::tuple_size<KeysNullMap<DummyUInt256>>::value + keys_bytes) <= 32)\n+            if ((std::tuple_size<KeysNullMap<UInt256>>::value + keys_bytes) <= 32)\n                 return Type::nullable_keys256;\n         }\n \ndiff --git a/src/Interpreters/SetVariants.h b/src/Interpreters/SetVariants.h\nindex bcd833e42a81..d6be996effb3 100644\n--- a/src/Interpreters/SetVariants.h\n+++ b/src/Interpreters/SetVariants.h\n@@ -8,7 +8,6 @@\n #include <Common/HashTable/ClearableHashSet.h>\n #include <Common/HashTable/FixedClearableHashSet.h>\n #include <Common/HashTable/FixedHashSet.h>\n-#include <Common/UInt128.h>\n \n \n namespace DB\n@@ -202,12 +201,12 @@ struct NonClearableSet\n     std::unique_ptr<SetMethodString<HashSetWithSavedHash<StringRef>>>                        key_string;\n     std::unique_ptr<SetMethodFixedString<HashSetWithSavedHash<StringRef>>>                   key_fixed_string;\n     std::unique_ptr<SetMethodKeysFixed<HashSet<UInt128, UInt128HashCRC32>>>                  keys128;\n-    std::unique_ptr<SetMethodKeysFixed<HashSet<DummyUInt256, UInt256HashCRC32>>>             keys256;\n+    std::unique_ptr<SetMethodKeysFixed<HashSet<UInt256, UInt256HashCRC32>>>                  keys256;\n     std::unique_ptr<SetMethodHashed<HashSet<UInt128, UInt128TrivialHash>>>                   hashed;\n \n     /// Support for nullable keys (for DISTINCT implementation).\n     std::unique_ptr<SetMethodKeysFixed<HashSet<UInt128, UInt128HashCRC32>, true>>            nullable_keys128;\n-    std::unique_ptr<SetMethodKeysFixed<HashSet<DummyUInt256, UInt256HashCRC32>, true>>       nullable_keys256;\n+    std::unique_ptr<SetMethodKeysFixed<HashSet<UInt256, UInt256HashCRC32>, true>>            nullable_keys256;\n     /** Unlike Aggregator, `concat` method is not used here.\n       * This is done because `hashed` method, although slower, but in this case, uses less RAM.\n       *  since when you use it, the key values themselves are not stored.\n@@ -224,12 +223,12 @@ struct ClearableSet\n     std::unique_ptr<SetMethodString<ClearableHashSetWithSavedHash<StringRef>>>                       key_string;\n     std::unique_ptr<SetMethodFixedString<ClearableHashSetWithSavedHash<StringRef>>>                  key_fixed_string;\n     std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt128, UInt128HashCRC32>>>                 keys128;\n-    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<DummyUInt256, UInt256HashCRC32>>>            keys256;\n+    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt256, UInt256HashCRC32>>>                 keys256;\n     std::unique_ptr<SetMethodHashed<ClearableHashSet<UInt128, UInt128TrivialHash>>>                  hashed;\n \n     /// Support for nullable keys (for DISTINCT implementation).\n     std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt128, UInt128HashCRC32>, true>>           nullable_keys128;\n-    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<DummyUInt256, UInt256HashCRC32>, true>>      nullable_keys256;\n+    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt256, UInt256HashCRC32>, true>>           nullable_keys256;\n     /** Unlike Aggregator, `concat` method is not used here.\n       * This is done because `hashed` method, although slower, but in this case, uses less RAM.\n       *  since when you use it, the key values themselves are not stored.\ndiff --git a/src/Interpreters/ThreadStatusExt.cpp b/src/Interpreters/ThreadStatusExt.cpp\nindex c04534e11a1b..cff6fb9cbcd2 100644\n--- a/src/Interpreters/ThreadStatusExt.cpp\n+++ b/src/Interpreters/ThreadStatusExt.cpp\n@@ -80,7 +80,7 @@ void ThreadStatus::attachQueryContext(ContextPtr query_context_)\n     // on OpenTelemetrySpanHolder due to link order issues.\n     // FIXME why and how is this different from setupState()?\n     thread_trace_context = query_context_->query_trace_context;\n-    if (thread_trace_context.trace_id)\n+    if (thread_trace_context.trace_id != UUID())\n     {\n         thread_trace_context.span_id = thread_local_rng();\n     }\n@@ -126,7 +126,7 @@ void ThreadStatus::setupState(const ThreadGroupStatusPtr & thread_group_)\n         // Generate new span for thread manually here, because we can't depend\n         // on OpenTelemetrySpanHolder due to link order issues.\n         thread_trace_context = query_context_ptr->query_trace_context;\n-        if (thread_trace_context.trace_id)\n+        if (thread_trace_context.trace_id != UUID())\n         {\n             thread_trace_context.span_id = thread_local_rng();\n         }\n@@ -335,7 +335,7 @@ void ThreadStatus::detachQuery(bool exit_if_already_detached, bool thread_exits)\n \n     std::shared_ptr<OpenTelemetrySpanLog> opentelemetry_span_log;\n     auto query_context_ptr = query_context.lock();\n-    if (thread_trace_context.trace_id && query_context_ptr)\n+    if (thread_trace_context.trace_id != UUID() && query_context_ptr)\n     {\n         opentelemetry_span_log = query_context_ptr->getOpenTelemetrySpanLog();\n     }\ndiff --git a/src/Interpreters/WindowDescription.cpp b/src/Interpreters/WindowDescription.cpp\nindex 05d75d4647ee..b9f8597706e6 100644\n--- a/src/Interpreters/WindowDescription.cpp\n+++ b/src/Interpreters/WindowDescription.cpp\n@@ -1,9 +1,11 @@\n #include <Interpreters/WindowDescription.h>\n \n #include <Core/Field.h>\n+#include <Common/FieldVisitors.h>\n #include <IO/Operators.h>\n #include <Parsers/ASTFunction.h>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Interpreters/WindowDescription.h b/src/Interpreters/WindowDescription.h\nindex 70a4e0e44e02..4cb478bae85b 100644\n--- a/src/Interpreters/WindowDescription.h\n+++ b/src/Interpreters/WindowDescription.h\n@@ -1,6 +1,5 @@\n #pragma once\n \n-#include <Common/FieldVisitors.h>\n #include <Core/Field.h>\n #include <Parsers/IAST_fwd.h>\n #include <AggregateFunctions/IAggregateFunction.h>\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex 529caec9c800..fa49b7303797 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -14,14 +14,13 @@\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeEnum.h>\n+#include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypeNullable.h>\n \n #include <Core/AccurateComparison.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/typeid_cast.h>\n #include <Common/NaNUtils.h>\n-#include <DataTypes/DataTypeUUID.h>\n-#include <DataTypes/DataTypeLowCardinality.h>\n \n #include <common/DateLUT.h>\n #include <DataTypes/DataTypeAggregateFunction.h>\n@@ -67,6 +66,14 @@ static Field convertNumericType(const Field & from, const IDataType & type)\n         return convertNumericTypeImpl<Int64, To>(from);\n     if (from.getType() == Field::Types::Float64)\n         return convertNumericTypeImpl<Float64, To>(from);\n+    if (from.getType() == Field::Types::UInt128)\n+        return convertNumericTypeImpl<UInt128, To>(from);\n+    if (from.getType() == Field::Types::Int128)\n+        return convertNumericTypeImpl<Int128, To>(from);\n+    if (from.getType() == Field::Types::UInt256)\n+        return convertNumericTypeImpl<UInt256, To>(from);\n+    if (from.getType() == Field::Types::Int256)\n+        return convertNumericTypeImpl<Int256, To>(from);\n \n     throw Exception(\"Type mismatch in IN or VALUES section. Expected: \" + type.getName() + \". Got: \"\n         + Field::Types::toString(from.getType()), ErrorCodes::TYPE_MISMATCH);\n@@ -78,9 +85,9 @@ static Field convertIntToDecimalType(const Field & from, const DataTypeDecimal<T\n {\n     From value = from.get<From>();\n     if (!type.canStoreWhole(value))\n-        throw Exception(\"Number is too much to place in \" + type.getName(), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+        throw Exception(\"Number is too big to place in \" + type.getName(), ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n \n-    T scaled_value = type.getScaleMultiplier() * value;\n+    T scaled_value = type.getScaleMultiplier() * static_cast<T>(value);\n     return DecimalField<T>(scaled_value, type.getScale());\n }\n \n@@ -108,6 +115,15 @@ static Field convertDecimalType(const Field & from, const To & type)\n         return convertIntToDecimalType<UInt64>(from, type);\n     if (from.getType() == Field::Types::Int64)\n         return convertIntToDecimalType<Int64>(from, type);\n+    if (from.getType() == Field::Types::UInt128)\n+        return convertIntToDecimalType<UInt128>(from, type);\n+    if (from.getType() == Field::Types::Int128)\n+        return convertIntToDecimalType<Int128>(from, type);\n+    if (from.getType() == Field::Types::UInt256)\n+        return convertIntToDecimalType<UInt256>(from, type);\n+    if (from.getType() == Field::Types::Int256)\n+        return convertIntToDecimalType<Int256>(from, type);\n+\n     if (from.getType() == Field::Types::String)\n         return convertStringToDecimalType(from, type);\n \n@@ -125,7 +141,6 @@ static Field convertDecimalType(const Field & from, const To & type)\n \n Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const IDataType * from_type_hint)\n {\n-    // This was added to mitigate converting DateTime64-Field (a typedef to a Decimal64) to DataTypeDate64-compatible type.\n     if (from_type_hint && from_type_hint->equals(type))\n     {\n         return src;\n@@ -133,6 +148,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n \n     WhichDataType which_type(type);\n     WhichDataType which_from_type;\n+\n     if (from_type_hint)\n     {\n         which_from_type = WhichDataType(*from_type_hint);\n@@ -179,12 +195,6 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n             return src;\n         }\n \n-        if (which_type.isUUID() && src.getType() == Field::Types::UInt128)\n-        {\n-            /// Already in needed type.\n-            return src;\n-        }\n-\n         if (which_type.isDateTime64() && src.getType() == Field::Types::Decimal64)\n         {\n             /// Already in needed type.\n@@ -193,6 +203,11 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n \n         /// TODO Conversion from integers to DateTime64\n     }\n+    else if (which_type.isUUID() && src.getType() == Field::Types::UUID)\n+    {\n+        /// Already in needed type.\n+        return src;\n+    }\n     else if (which_type.isStringOrFixedString())\n     {\n         if (src.getType() == Field::Types::String)\n@@ -364,6 +379,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n \n }\n \n+\n Field convertFieldToType(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint)\n {\n     if (from_value.isNull())\n@@ -390,18 +406,22 @@ Field convertFieldToType(const Field & from_value, const IDataType & to_type, co\n         return convertFieldToTypeImpl(from_value, to_type, from_type_hint);\n }\n \n+\n Field convertFieldToTypeOrThrow(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint)\n {\n     bool is_null = from_value.isNull();\n     if (is_null && !to_type.isNullable())\n         throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot convert NULL to {}\", to_type.getName());\n+\n     Field converted = convertFieldToType(from_value, to_type, from_type_hint);\n+\n     if (!is_null && converted.isNull())\n         throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n             \"Cannot convert value '{}'{}: it cannot be represented as {}\",\n             toString(from_value),\n             from_type_hint ? \" from \" + from_type_hint->getName() : \"\",\n             to_type.getName());\n+\n     return converted;\n }\n \ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex f310ce0d5299..90e39ae0af7f 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -174,7 +174,7 @@ static void logQuery(const String & query, ContextPtr context, bool internal)\n             comment,\n             joinLines(query));\n \n-        if (client_info.client_trace_context.trace_id)\n+        if (client_info.client_trace_context.trace_id != UUID())\n         {\n             LOG_TRACE(&Poco::Logger::get(\"executeQuery\"),\n                 \"OpenTelemetry traceparent '{}'\",\n@@ -289,7 +289,7 @@ static void onExceptionBeforeStart(const String & query_for_logging, ContextPtr\n             query_log->add(elem);\n \n     if (auto opentelemetry_span_log = context->getOpenTelemetrySpanLog();\n-        context->query_trace_context.trace_id\n+        context->query_trace_context.trace_id != UUID()\n             && opentelemetry_span_log)\n     {\n         OpenTelemetrySpanLogElement span;\n@@ -792,7 +792,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 }\n \n                 if (auto opentelemetry_span_log = context->getOpenTelemetrySpanLog();\n-                    context->query_trace_context.trace_id\n+                    context->query_trace_context.trace_id != UUID()\n                         && opentelemetry_span_log)\n                 {\n                     OpenTelemetrySpanLogElement span;\ndiff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp\nindex a0662a471522..d4a420f01289 100644\n--- a/src/Parsers/ASTFunction.cpp\n+++ b/src/Parsers/ASTFunction.cpp\n@@ -415,7 +415,7 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n                 // them, and we want to have consistent formatting.\n                 if (tuple_arguments_valid && lit_right)\n                 {\n-                    if (isInt64FieldType(lit_right->value.getType())\n+                    if (isInt64OrUInt64FieldType(lit_right->value.getType())\n                         && lit_right->value.get<Int64>() >= 0)\n                     {\n                         if (frame.need_parens)\ndiff --git a/src/Parsers/ASTSampleRatio.h b/src/Parsers/ASTSampleRatio.h\nindex 09dec6aac999..a3e70b7dab70 100644\n--- a/src/Parsers/ASTSampleRatio.h\n+++ b/src/Parsers/ASTSampleRatio.h\n@@ -2,6 +2,7 @@\n \n #include <Parsers/IAST.h>\n \n+\n namespace DB\n {\n \n@@ -11,12 +12,7 @@ namespace DB\n class ASTSampleRatio : public IAST\n {\n public:\n-#ifdef __SIZEOF_INT128__\n     using BigNum = __uint128_t;    /// Must contain the result of multiplying two UInt64.\n-#else\n-    #warning \"No uint128_t type. Sampling ratios cannot work correctly.\"\n-    using BigNum = uint64_t;\n-#endif\n \n     struct Rational\n     {\ndiff --git a/src/Parsers/ASTWindowDefinition.cpp b/src/Parsers/ASTWindowDefinition.cpp\nindex 35374df61772..37b27b22c7d7 100644\n--- a/src/Parsers/ASTWindowDefinition.cpp\n+++ b/src/Parsers/ASTWindowDefinition.cpp\n@@ -1,8 +1,10 @@\n #include <Parsers/ASTWindowDefinition.h>\n \n #include <Common/quoteString.h>\n+#include <Common/FieldVisitors.h>\n #include <IO/Operators.h>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp\nindex 6451a9d0c0dd..3a21d704eb90 100644\n--- a/src/Parsers/IAST.cpp\n+++ b/src/Parsers/IAST.cpp\n@@ -53,7 +53,7 @@ IAST::Hash IAST::getTreeHash() const\n     SipHash hash_state;\n     updateTreeHash(hash_state);\n     IAST::Hash res;\n-    hash_state.get128(res.first, res.second);\n+    hash_state.get128(res);\n     return res;\n }\n \ndiff --git a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\nindex 288c6ee09ef9..cc9ae5e65bb1 100644\n--- a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n+++ b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n@@ -363,7 +363,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP\n     hash_state.update(salt);\n \n     IAST::Hash res128;\n-    hash_state.get128(res128.first, res128.second);\n+    hash_state.get128(res128);\n     size_t res = 0;\n     boost::hash_combine(res, res128.first);\n     boost::hash_combine(res, res128.second);\ndiff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex 701385447b4c..1eb64682faec 100644\n--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -6,7 +6,6 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Processors/Formats/Impl/ValuesBlockInputFormat.h>\n #include <Formats/FormatFactory.h>\n-#include <Common/FieldVisitors.h>\n #include <Core/Block.h>\n #include <common/find_symbols.h>\n #include <Common/typeid_cast.h>\ndiff --git a/src/Processors/Transforms/LimitByTransform.cpp b/src/Processors/Transforms/LimitByTransform.cpp\nindex 5c405046a831..cb2804007bd4 100644\n--- a/src/Processors/Transforms/LimitByTransform.cpp\n+++ b/src/Processors/Transforms/LimitByTransform.cpp\n@@ -33,13 +33,13 @@ void LimitByTransform::transform(Chunk & chunk)\n \n     for (UInt64 row = 0; row < num_rows; ++row)\n     {\n-        UInt128 key(0, 0);\n+        UInt128 key{};\n         SipHash hash;\n \n         for (auto position : key_positions)\n             columns[position]->updateHashWithValue(row, hash);\n \n-        hash.get128(key.low, key.high);\n+        hash.get128(key);\n \n         auto count = keys_counts[key]++;\n         if (count >= group_offset\ndiff --git a/src/Processors/Transforms/LimitByTransform.h b/src/Processors/Transforms/LimitByTransform.h\nindex 9773f637f407..8c2b46af69ef 100644\n--- a/src/Processors/Transforms/LimitByTransform.h\n+++ b/src/Processors/Transforms/LimitByTransform.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include <Processors/ISimpleTransform.h>\n #include <Common/HashTable/HashMap.h>\n-#include <Common/UInt128.h>\n+\n \n namespace DB\n {\ndiff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp\nindex df92f911325f..798f19c37ff6 100644\n--- a/src/Processors/Transforms/WindowTransform.cpp\n+++ b/src/Processors/Transforms/WindowTransform.cpp\n@@ -3,6 +3,7 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <Common/Arena.h>\n #include <Common/FieldVisitorsAccurateComparison.h>\n+#include <common/arithmeticOverflow.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <Interpreters/ExpressionActions.h>\n@@ -67,15 +68,9 @@ static int compareValuesWithOffset(const IColumn * _compared_column,\n \n     bool is_overflow;\n     if (offset_is_preceding)\n-    {\n-        is_overflow = __builtin_sub_overflow(reference_value, offset,\n-            &reference_value);\n-    }\n+        is_overflow = common::subOverflow(reference_value, offset, reference_value);\n     else\n-    {\n-        is_overflow = __builtin_add_overflow(reference_value, offset,\n-            &reference_value);\n-    }\n+        is_overflow = common::addOverflow(reference_value, offset, reference_value);\n \n //    fmt::print(stderr,\n //        \"compared [{}] = {}, old ref {}, shifted ref [{}] = {}, offset {} preceding {} overflow {} to negative {}\\n\",\n@@ -1465,7 +1460,7 @@ struct WindowFunctionLagLeadInFrame final : public WindowFunction\n             return;\n         }\n \n-        if (!isInt64FieldType(argument_types[1]->getDefault().getType()))\n+        if (!isInt64OrUInt64FieldType(argument_types[1]->getDefault().getType()))\n         {\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n                 \"Offset must be an integer, '{}' given\",\ndiff --git a/src/Processors/Transforms/WindowTransform.h b/src/Processors/Transforms/WindowTransform.h\nindex 882bf429c0a8..611b03ebf72d 100644\n--- a/src/Processors/Transforms/WindowTransform.h\n+++ b/src/Processors/Transforms/WindowTransform.h\n@@ -8,6 +8,7 @@\n \n #include <deque>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Storages/LiveView/LiveViewBlockOutputStream.h b/src/Storages/LiveView/LiveViewBlockOutputStream.h\nindex 5a1f75a8c2fd..6b8a5a2cb9ec 100644\n--- a/src/Storages/LiveView/LiveViewBlockOutputStream.h\n+++ b/src/Storages/LiveView/LiveViewBlockOutputStream.h\n@@ -3,6 +3,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataStreams/IBlockOutputStream.h>\n #include <Storages/LiveView/StorageLiveView.h>\n+#include <Common/hex.h>\n \n \n namespace DB\n@@ -25,8 +26,8 @@ class LiveViewBlockOutputStream : public IBlockOutputStream\n         UInt128 key;\n         String key_str;\n \n-        new_hash->get128(key.low, key.high);\n-        key_str = key.toHexString();\n+        new_hash->get128(key);\n+        key_str = getHexUIntLowercase(key);\n \n         std::lock_guard lock(storage.mutex);\n \ndiff --git a/src/Storages/LiveView/StorageLiveView.cpp b/src/Storages/LiveView/StorageLiveView.cpp\nindex 1d81405ec263..19c3992276f8 100644\n--- a/src/Storages/LiveView/StorageLiveView.cpp\n+++ b/src/Storages/LiveView/StorageLiveView.cpp\n@@ -23,6 +23,7 @@ limitations under the License. */\n #include <common/logger_useful.h>\n #include <Common/typeid_cast.h>\n #include <Common/SipHash.h>\n+#include <Common/hex.h>\n \n #include <Storages/LiveView/StorageLiveView.h>\n #include <Storages/LiveView/LiveViewBlockInputStream.h>\n@@ -366,20 +367,20 @@ bool StorageLiveView::getNewBlocks()\n         new_blocks->push_back(block);\n     }\n \n-    hash.get128(key.low, key.high);\n+    hash.get128(key);\n \n     /// Update blocks only if hash keys do not match\n     /// NOTE: hash could be different for the same result\n     ///       if blocks are not in the same order\n     bool updated = false;\n     {\n-        if (getBlocksHashKey() != key.toHexString())\n+        if (getBlocksHashKey() != getHexUIntLowercase(key))\n         {\n             if (new_blocks->empty())\n             {\n                 new_blocks->push_back(getHeader());\n             }\n-            new_blocks_metadata->hash = key.toHexString();\n+            new_blocks_metadata->hash = getHexUIntLowercase(key);\n             new_blocks_metadata->version = getBlocksVersion() + 1;\n             new_blocks_metadata->time = std::chrono::system_clock::now();\n \ndiff --git a/src/Storages/MarkCache.h b/src/Storages/MarkCache.h\nindex 5dfaa9ef0ea8..ccf8a2e606db 100644\n--- a/src/Storages/MarkCache.h\n+++ b/src/Storages/MarkCache.h\n@@ -50,7 +50,7 @@ class MarkCache : public LRUCache<UInt128, MarksInCompressedFile, UInt128Trivial\n \n         SipHash hash;\n         hash.update(path_to_file.data(), path_to_file.size() + 1);\n-        hash.get128(key.low, key.high);\n+        hash.get128(key);\n \n         return key;\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp b/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp\nindex b0eb1cbea70e..3a944b3e7f03 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp\n@@ -299,7 +299,8 @@ String MergeTreeDataPartChecksums::getTotalChecksumHex() const\n         hash_of_all_files.update(checksum.file_hash);\n     }\n \n-    UInt64 lo, hi;\n+    UInt64 lo;\n+    UInt64 hi;\n     hash_of_all_files.get128(lo, hi);\n \n     return getHexUIntUppercase(hi) + getHexUIntUppercase(lo);\n@@ -394,7 +395,7 @@ void MinimalisticDataPartChecksums::computeTotalChecksums(const MergeTreeDataPar\n \n     auto get_hash = [] (SipHash & hash, uint128 & data)\n     {\n-        hash.get128(data.first, data.second);\n+        hash.get128(data);\n     };\n \n     get_hash(hash_of_all_files_state, hash_of_all_files);\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\nindex 045ab488adac..fb7431e0bfe9 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp\n@@ -125,7 +125,7 @@ IMergeTreeDataPart::Checksum MergeTreeDataPartInMemory::calculateBlockChecksum()\n         column.column->updateHashFast(hash);\n \n     checksum.uncompressed_size = block.bytes();\n-    hash.get128(checksum.uncompressed_hash.first, checksum.uncompressed_hash.second);\n+    hash.get128(checksum.uncompressed_hash);\n     return checksum;\n }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp b/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp\nindex 17d198557986..3c3a6ecee7f7 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp\n@@ -1,5 +1,7 @@\n+#include <vector>\n #include <Storages/MergeTree/MergeTreeDataPartUUID.h>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 8245364d87a1..91448e17c9da 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -5,7 +5,6 @@\n \n #include <Poco/File.h>\n \n-#include <Common/FieldVisitors.h>\n #include <Storages/MergeTree/MergeTreeDataSelectExecutor.h>\n #include <Storages/MergeTree/MergeTreeSelectProcessor.h>\n #include <Storages/MergeTree/MergeTreeReverseSelectProcessor.h>\n@@ -40,6 +39,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Storages/VirtualColumnUtils.h>\n \n+\n namespace ProfileEvents\n {\n     extern const Event SelectedParts;\ndiff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp\nindex bc158c38f376..7987fcc3b311 100644\n--- a/src/Storages/StorageGenerateRandom.cpp\n+++ b/src/Storages/StorageGenerateRandom.cpp\n@@ -213,10 +213,7 @@ ColumnPtr fillColumnWithRandomData(\n         {\n             auto column = ColumnUInt16::create();\n             column->getData().resize(limit);\n-\n-            for (size_t i = 0; i < limit; ++i)\n-                column->getData()[i] = rng() % (DATE_LUT_MAX_DAY_NUM + 1);\n-\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt16), rng);\n             return column;\n         }\n         case TypeIndex::UInt32: [[fallthrough]];\n@@ -234,14 +231,28 @@ ColumnPtr fillColumnWithRandomData(\n             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt64), rng);\n             return column;\n         }\n-        case TypeIndex::UInt128: [[fallthrough]];\n-        case TypeIndex::UUID:\n+        case TypeIndex::UInt128:\n         {\n             auto column = ColumnUInt128::create();\n             column->getData().resize(limit);\n             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt128), rng);\n             return column;\n         }\n+        case TypeIndex::UInt256:\n+        {\n+            auto column = ColumnUInt256::create();\n+            column->getData().resize(limit);\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt256), rng);\n+            return column;\n+        }\n+        case TypeIndex::UUID:\n+        {\n+            auto column = ColumnUUID::create();\n+            column->getData().resize(limit);\n+            /// NOTE This is slightly incorrect as random UUIDs should have fixed version 4.\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UUID), rng);\n+            return column;\n+        }\n         case TypeIndex::Int8:\n         {\n             auto column = ColumnInt8::create();\n@@ -270,6 +281,20 @@ ColumnPtr fillColumnWithRandomData(\n             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int64), rng);\n             return column;\n         }\n+        case TypeIndex::Int128:\n+        {\n+            auto column = ColumnInt128::create();\n+            column->getData().resize(limit);\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int128), rng);\n+            return column;\n+        }\n+        case TypeIndex::Int256:\n+        {\n+            auto column = ColumnInt256::create();\n+            column->getData().resize(limit);\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int256), rng);\n+            return column;\n+        }\n         case TypeIndex::Float32:\n         {\n             auto column = ColumnFloat32::create();\n@@ -308,6 +333,14 @@ ColumnPtr fillColumnWithRandomData(\n             fillBufferWithRandomData(reinterpret_cast<char *>(column_concrete.getData().data()), limit * sizeof(Decimal128), rng);\n             return column;\n         }\n+        case TypeIndex::Decimal256:\n+        {\n+            auto column = type->createColumn();\n+            auto & column_concrete = typeid_cast<ColumnDecimal<Decimal256> &>(*column);\n+            column_concrete.getData().resize(limit);\n+            fillBufferWithRandomData(reinterpret_cast<char *>(column_concrete.getData().data()), limit * sizeof(Decimal256), rng);\n+            return column;\n+        }\n         case TypeIndex::FixedString:\n         {\n             size_t n = typeid_cast<const DataTypeFixedString &>(*type).getN();\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 7eadfc5142d7..c1b64bb2e8b2 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -3,7 +3,6 @@\n #include <Databases/IDatabase.h>\n #include <Common/escapeForFileName.h>\n #include <Common/typeid_cast.h>\n-#include <Common/FieldVisitors.h>\n #include <Common/ThreadPool.h>\n #include <Interpreters/InterpreterAlterQuery.h>\n #include <Interpreters/PartLog.h>\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 71645edfbbf4..588a0a830048 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -1,6 +1,5 @@\n #include <Core/Defines.h>\n \n-#include <Common/FieldVisitors.h>\n #include <Common/Macros.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/ThreadPool.h>\ndiff --git a/src/Storages/StorageURL.cpp b/src/Storages/StorageURL.cpp\nindex e6c2f52f9256..824f11648512 100644\n--- a/src/Storages/StorageURL.cpp\n+++ b/src/Storages/StorageURL.cpp\n@@ -79,7 +79,7 @@ namespace\n             if (CurrentThread::isInitialized())\n             {\n                 const auto & thread_trace_context = CurrentThread::get().thread_trace_context;\n-                if (thread_trace_context.trace_id)\n+                if (thread_trace_context.trace_id != UUID())\n                 {\n                     header.emplace_back(\"traceparent\",\n                         thread_trace_context.composeTraceparentHeader());\ndiff --git a/src/Storages/System/StorageSystemQuotas.cpp b/src/Storages/System/StorageSystemQuotas.cpp\nindex 4bba082f66e8..5e1ce220bec8 100644\n--- a/src/Storages/System/StorageSystemQuotas.cpp\n+++ b/src/Storages/System/StorageSystemQuotas.cpp\n@@ -60,7 +60,7 @@ void StorageSystemQuotas::fillData(MutableColumns & res_columns, ContextPtr cont\n \n     size_t column_index = 0;\n     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);\n-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();\n+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();\n     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);\n     auto & column_key_types = assert_cast<ColumnInt8 &>(assert_cast<ColumnArray &>(*res_columns[column_index]).getData()).getData();\n     auto & column_key_types_offsets = assert_cast<ColumnArray &>(*res_columns[column_index++]).getOffsets();\n@@ -80,7 +80,7 @@ void StorageSystemQuotas::fillData(MutableColumns & res_columns, ContextPtr cont\n                        const RolesOrUsersSet & apply_to)\n     {\n         column_name.insertData(name.data(), name.length());\n-        column_id.push_back(id);\n+        column_id.push_back(id.toUnderType());\n         column_storage.insertData(storage_name.data(), storage_name.length());\n \n         if (key_type != KeyType::NONE)\ndiff --git a/src/Storages/System/StorageSystemRoles.cpp b/src/Storages/System/StorageSystemRoles.cpp\nindex 65ae74887a75..42983670466e 100644\n--- a/src/Storages/System/StorageSystemRoles.cpp\n+++ b/src/Storages/System/StorageSystemRoles.cpp\n@@ -31,7 +31,7 @@ void StorageSystemRoles::fillData(MutableColumns & res_columns, ContextPtr conte\n \n     size_t column_index = 0;\n     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);\n-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();\n+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();\n     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);\n \n     auto add_row = [&](const String & name,\n@@ -39,7 +39,7 @@ void StorageSystemRoles::fillData(MutableColumns & res_columns, ContextPtr conte\n                        const String & storage_name)\n     {\n         column_name.insertData(name.data(), name.length());\n-        column_id.push_back(id);\n+        column_id.push_back(id.toUnderType());\n         column_storage.insertData(storage_name.data(), storage_name.length());\n     };\n \ndiff --git a/src/Storages/System/StorageSystemRowPolicies.cpp b/src/Storages/System/StorageSystemRowPolicies.cpp\nindex f9d6b14957e2..c7a403a4abe5 100644\n--- a/src/Storages/System/StorageSystemRowPolicies.cpp\n+++ b/src/Storages/System/StorageSystemRowPolicies.cpp\n@@ -63,7 +63,7 @@ void StorageSystemRowPolicies::fillData(MutableColumns & res_columns, ContextPtr\n     auto & column_short_name = assert_cast<ColumnString &>(*res_columns[column_index++]);\n     auto & column_database = assert_cast<ColumnString &>(*res_columns[column_index++]);\n     auto & column_table = assert_cast<ColumnString &>(*res_columns[column_index++]);\n-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();\n+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();\n     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);\n \n     ColumnString * column_condition[MAX_CONDITION_TYPE];\n@@ -93,7 +93,7 @@ void StorageSystemRowPolicies::fillData(MutableColumns & res_columns, ContextPtr\n         column_short_name.insertData(name_parts.short_name.data(), name_parts.short_name.length());\n         column_database.insertData(name_parts.database.data(), name_parts.database.length());\n         column_table.insertData(name_parts.table_name.data(), name_parts.table_name.length());\n-        column_id.push_back(id);\n+        column_id.push_back(id.toUnderType());\n         column_storage.insertData(storage_name.data(), storage_name.length());\n \n         for (auto condition_type : ext::range(MAX_CONDITION_TYPE))\ndiff --git a/src/Storages/System/StorageSystemSettingsProfiles.cpp b/src/Storages/System/StorageSystemSettingsProfiles.cpp\nindex c726f54a3249..87847fb80bce 100644\n--- a/src/Storages/System/StorageSystemSettingsProfiles.cpp\n+++ b/src/Storages/System/StorageSystemSettingsProfiles.cpp\n@@ -38,7 +38,7 @@ void StorageSystemSettingsProfiles::fillData(MutableColumns & res_columns, Conte\n \n     size_t column_index = 0;\n     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);\n-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();\n+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();\n     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);\n     auto & column_num_elements = assert_cast<ColumnUInt64 &>(*res_columns[column_index++]).getData();\n     auto & column_apply_to_all = assert_cast<ColumnUInt8 &>(*res_columns[column_index++]).getData();\n@@ -54,7 +54,7 @@ void StorageSystemSettingsProfiles::fillData(MutableColumns & res_columns, Conte\n                        const RolesOrUsersSet & apply_to)\n     {\n         column_name.insertData(name.data(), name.length());\n-        column_id.push_back(id);\n+        column_id.push_back(id.toUnderType());\n         column_storage.insertData(storage_name.data(), storage_name.length());\n         column_num_elements.push_back(elements.size());\n \ndiff --git a/src/Storages/System/StorageSystemUsers.cpp b/src/Storages/System/StorageSystemUsers.cpp\nindex e60f1372df93..74ac48c145c4 100644\n--- a/src/Storages/System/StorageSystemUsers.cpp\n+++ b/src/Storages/System/StorageSystemUsers.cpp\n@@ -63,7 +63,7 @@ void StorageSystemUsers::fillData(MutableColumns & res_columns, ContextPtr conte\n \n     size_t column_index = 0;\n     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);\n-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();\n+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();\n     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);\n     auto & column_auth_type = assert_cast<ColumnInt8 &>(*res_columns[column_index++]).getData();\n     auto & column_auth_params = assert_cast<ColumnString &>(*res_columns[column_index++]);\n@@ -95,7 +95,7 @@ void StorageSystemUsers::fillData(MutableColumns & res_columns, ContextPtr conte\n                        const RolesOrUsersSet & grantees)\n     {\n         column_name.insertData(name.data(), name.length());\n-        column_id.push_back(id);\n+        column_id.push_back(id.toUnderType());\n         column_storage.insertData(storage_name.data(), storage_name.length());\n         column_auth_type.push_back(static_cast<Int8>(authentication.getType()));\n \n",
  "test_patch": "diff --git a/src/Columns/tests/gtest_weak_hash_32.cpp b/src/Columns/tests/gtest_weak_hash_32.cpp\nindex 0dabfc32b33d..2fa6c0ea8ac4 100644\n--- a/src/Columns/tests/gtest_weak_hash_32.cpp\n+++ b/src/Columns/tests/gtest_weak_hash_32.cpp\n@@ -14,11 +14,11 @@\n #include <DataTypes/DataTypesNumber.h>\n \n #include <Common/WeakHash.h>\n+#include <Common/hex.h>\n \n #include <unordered_map>\n #include <iostream>\n #include <sstream>\n-#include <Common/hex.h>\n \n \n using namespace DB;\n@@ -27,20 +27,11 @@ template <typename T>\n void checkColumn(\n     const WeakHash32::Container & hash,\n     const PaddedPODArray<T> & eq_class,\n-    const std::function<std::string(size_t)> & print_function,\n     size_t allowed_collisions = 0,\n     size_t max_collisions_to_print = 10)\n {\n     ASSERT_EQ(hash.size(), eq_class.size());\n \n-    auto print_for_row = [&](size_t row)\n-    {\n-        std::string res = \"row: \" + std::to_string(row);\n-        res += \" hash: \" + std::to_string(hash[row]);\n-        res += \" value: \" + print_function(row);\n-        return res;\n-    };\n-\n     /// Check equal rows has equal hash.\n     {\n         std::unordered_map<T, UInt32> map;\n@@ -55,11 +46,7 @@ void checkColumn(\n             else\n             {\n                 if (it->second != hash[i])\n-                {\n-                    std::cout << \"Different hashes for the same equivalent class (\" << size_t(val) << \"):\\n\";\n-                    std::cout << print_for_row(it->first) << '\\n';\n-                    std::cout << print_for_row(i) << std::endl;\n-                }\n+                    std::cout << \"Different hashes for the same equivalent class (\" << toString(val) << \")\\n\";\n \n                 ASSERT_EQ(it->second, hash[i]);\n             }\n@@ -88,7 +75,6 @@ void checkColumn(\n                 if (num_collisions <= max_collisions_to_print)\n                 {\n                     collisions_str << \"Collision:\\n\";\n-                    collisions_str << print_for_row(i) << std::endl;\n                 }\n \n                 if (num_collisions > allowed_collisions)\n@@ -117,7 +103,7 @@ TEST(WeakHash32, ColumnVectorU8)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorI8)\n@@ -134,7 +120,7 @@ TEST(WeakHash32, ColumnVectorI8)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorU16)\n@@ -151,7 +137,7 @@ TEST(WeakHash32, ColumnVectorU16)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorI16)\n@@ -168,7 +154,7 @@ TEST(WeakHash32, ColumnVectorI16)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorU32)\n@@ -185,7 +171,7 @@ TEST(WeakHash32, ColumnVectorU32)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorI32)\n@@ -202,7 +188,7 @@ TEST(WeakHash32, ColumnVectorI32)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorU64)\n@@ -219,7 +205,7 @@ TEST(WeakHash32, ColumnVectorU64)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorI64)\n@@ -236,7 +222,7 @@ TEST(WeakHash32, ColumnVectorI64)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnVectorU128)\n@@ -250,7 +236,9 @@ TEST(WeakHash32, ColumnVectorU128)\n     {\n         for (uint64_t i = 0; i < 65536; ++i)\n         {\n-            UInt128 val(i << 32u, i << 32u);\n+            UInt128 val;\n+            val.items[0] = i << 32u;\n+            val.items[1] = i << 32u;\n             data.push_back(val);\n             eq_data.push_back(i);\n         }\n@@ -259,7 +247,7 @@ TEST(WeakHash32, ColumnVectorU128)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), eq_data, [&](size_t row) { return col->getElement(row).toHexString(); });\n+    checkColumn(hash.getData(), eq_data);\n }\n \n TEST(WeakHash32, ColumnVectorI128)\n@@ -276,7 +264,7 @@ TEST(WeakHash32, ColumnVectorI128)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(Int64(col->getElement(row))); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnDecimal32)\n@@ -293,7 +281,7 @@ TEST(WeakHash32, ColumnDecimal32)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnDecimal64)\n@@ -310,7 +298,7 @@ TEST(WeakHash32, ColumnDecimal64)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(col->getElement(row)); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnDecimal128)\n@@ -327,7 +315,7 @@ TEST(WeakHash32, ColumnDecimal128)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), col->getData(), [&](size_t row) { return std::to_string(Int64(col->getElement(row))); });\n+    checkColumn(hash.getData(), col->getData());\n }\n \n TEST(WeakHash32, ColumnString1)\n@@ -349,7 +337,7 @@ TEST(WeakHash32, ColumnString1)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), data, [&](size_t row) { return col->getDataAt(row).toString(); });\n+    checkColumn(hash.getData(), data);\n }\n \n TEST(WeakHash32, ColumnString2)\n@@ -389,7 +377,7 @@ TEST(WeakHash32, ColumnString2)\n     /// Now there is single collision between 'k' * 544 and 'q' * 2512 (which is calculated twice)\n     size_t allowed_collisions = 4;\n \n-    checkColumn(hash.getData(), data, [&](size_t row) { return col->getDataAt(row).toString(); }, allowed_collisions);\n+    checkColumn(hash.getData(), data, allowed_collisions);\n }\n \n TEST(WeakHash32, ColumnString3)\n@@ -427,7 +415,7 @@ TEST(WeakHash32, ColumnString3)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), data, [&](size_t row) { return col->getDataAt(row).toString(); });\n+    checkColumn(hash.getData(), data);\n }\n \n TEST(WeakHash32, ColumnFixedString)\n@@ -455,7 +443,7 @@ TEST(WeakHash32, ColumnFixedString)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), data, [&](size_t row) { return col->getDataAt(row).toString(); });\n+    checkColumn(hash.getData(), data);\n }\n \n TEST(WeakHash32, ColumnArray)\n@@ -502,15 +490,7 @@ TEST(WeakHash32, ColumnArray)\n     WeakHash32 hash(col_arr->size());\n     col_arr->updateWeakHash32(hash);\n \n-    auto print_function = [&col_arr](size_t row)\n-    {\n-        auto & offsets = col_arr->getOffsets();\n-        size_t s = offsets[row] - offsets[row - 1];\n-        auto value = col_arr->getData().getUInt(offsets[row]);\n-        return std::string(\"[array of size \") + std::to_string(s) + \" with values \" + std::to_string(value) + \"]\";\n-    };\n-\n-    checkColumn(hash.getData(), eq_data, print_function);\n+    checkColumn(hash.getData(), eq_data);\n }\n \n TEST(WeakHash32, ColumnArray2)\n@@ -545,15 +525,7 @@ TEST(WeakHash32, ColumnArray2)\n     WeakHash32 hash(col_arr->size());\n     col_arr->updateWeakHash32(hash);\n \n-    auto print_function = [&col_arr](size_t row)\n-    {\n-        auto & offsets = col_arr->getOffsets();\n-        auto value1 = col_arr->getData().getUInt(offsets[row]);\n-        auto value2 = col_arr->getData().getUInt(offsets[row] + 1);\n-        return std::string(\"[\") + std::to_string(value1) + \", \" + std::to_string(value2) + \"]\";\n-    };\n-\n-    checkColumn(hash.getData(), eq_data, print_function);\n+    checkColumn(hash.getData(), eq_data);\n }\n \n TEST(WeakHash32, ColumnArrayArray)\n@@ -610,20 +582,7 @@ TEST(WeakHash32, ColumnArrayArray)\n     WeakHash32 hash(col_arr_arr->size());\n     col_arr_arr->updateWeakHash32(hash);\n \n-    auto print_function = [&col_arr_arr](size_t row2)\n-    {\n-        auto & offsets2 = col_arr_arr->getOffsets();\n-        size_t s2 = offsets2[row2] - offsets2[row2 - 1];\n-        const auto & arr2 = typeid_cast<const ColumnArray &>(col_arr_arr->getData());\n-        const auto & offsets = arr2.getOffsets();\n-        size_t row = offsets2[row2];\n-        size_t s = offsets[row] - offsets[row - 1];\n-        auto value = arr2.getData().getUInt(offsets[row]);\n-        return std::string(\"[array of size \") + std::to_string(s2) + \" with values [\"\n-                                \"[[array of size \" + std::to_string(s) + \" with values \" + std::to_string(value) + \"]]\";\n-    };\n-\n-    checkColumn(hash.getData(), eq_data, print_function);\n+    checkColumn(hash.getData(), eq_data);\n }\n \n TEST(WeakHash32, ColumnConst)\n@@ -642,7 +601,7 @@ TEST(WeakHash32, ColumnConst)\n     WeakHash32 hash(col_const->size());\n     col_const->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), data, [&](size_t) { return std::to_string(0); });\n+    checkColumn(hash.getData(), data);\n }\n \n TEST(WeakHash32, ColumnLowcardinality)\n@@ -663,7 +622,7 @@ TEST(WeakHash32, ColumnLowcardinality)\n     WeakHash32 hash(col->size());\n     col->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), data, [&](size_t row) { return std::to_string(col->getUInt(row)); });\n+    checkColumn(hash.getData(), data);\n }\n \n TEST(WeakHash32, ColumnNullable)\n@@ -689,7 +648,7 @@ TEST(WeakHash32, ColumnNullable)\n     WeakHash32 hash(col_null->size());\n     col_null->updateWeakHash32(hash);\n \n-    checkColumn(hash.getData(), eq, [&](size_t row) { return eq[row] == -1 ? \"Null\" : std::to_string(eq[row]); });\n+    checkColumn(hash.getData(), eq);\n }\n \n TEST(WeakHash32, ColumnTupleUInt64UInt64)\n@@ -720,14 +679,7 @@ TEST(WeakHash32, ColumnTupleUInt64UInt64)\n     WeakHash32 hash(col_tuple->size());\n     col_tuple->updateWeakHash32(hash);\n \n-    auto print_func = [&](size_t row)\n-    {\n-        std::string l = std::to_string(col_tuple->getColumn(0).getUInt(row));\n-        std::string r = std::to_string(col_tuple->getColumn(1).getUInt(row));\n-        return \"(\" + l + \", \" + r + \")\";\n-    };\n-\n-    checkColumn(hash.getData(), eq, print_func);\n+    checkColumn(hash.getData(), eq);\n }\n \n TEST(WeakHash32, ColumnTupleUInt64String)\n@@ -765,15 +717,8 @@ TEST(WeakHash32, ColumnTupleUInt64String)\n     WeakHash32 hash(col_tuple->size());\n     col_tuple->updateWeakHash32(hash);\n \n-    auto print_func = [&](size_t row)\n-    {\n-        std::string l = std::to_string(col_tuple->getColumn(0).getUInt(row));\n-        std::string r = col_tuple->getColumn(1).getDataAt(row).toString();\n-        return \"(\" + l + \", \" + r + \")\";\n-    };\n-\n     size_t allowed_collisions = 8;\n-    checkColumn(hash.getData(), eq, print_func, allowed_collisions);\n+    checkColumn(hash.getData(), eq, allowed_collisions);\n }\n \n TEST(WeakHash32, ColumnTupleUInt64FixedString)\n@@ -811,14 +756,7 @@ TEST(WeakHash32, ColumnTupleUInt64FixedString)\n     WeakHash32 hash(col_tuple->size());\n     col_tuple->updateWeakHash32(hash);\n \n-    auto print_func = [&](size_t row)\n-    {\n-        std::string l = std::to_string(col_tuple->getColumn(0).getUInt(row));\n-        std::string r = col_tuple->getColumn(1).getDataAt(row).toString();\n-        return \"(\" + l + \", \" + r + \")\";\n-    };\n-\n-    checkColumn(hash.getData(), eq, print_func);\n+    checkColumn(hash.getData(), eq);\n }\n \n TEST(WeakHash32, ColumnTupleUInt64Array)\n@@ -865,23 +803,10 @@ TEST(WeakHash32, ColumnTupleUInt64Array)\n     WeakHash32 hash(col_tuple->size());\n     col_tuple->updateWeakHash32(hash);\n \n-    auto print_func = [&](size_t row)\n-    {\n-        std::string l = std::to_string(col_tuple->getColumn(0).getUInt(row));\n-\n-        const auto * col_arr = typeid_cast<const ColumnArray *>(col_tuple->getColumnPtr(1).get());\n-        const auto & offsets = col_arr->getOffsets();\n-        size_t s = offsets[row] - offsets[row - 1];\n-        auto value = col_arr->getData().getUInt(offsets[row]);\n-        auto r = std::string(\"[array of size \") + std::to_string(s) + \" with values \" + std::to_string(value) + \"]\";\n-\n-        return \"(\" + l + \", \" + r + \")\";\n-    };\n-\n     /// There are 2 collisions right now (repeated 2 times each):\n     /// (0, [array of size 1212 with values 7]) vs (0, [array of size 2265 with values 17])\n     /// (0, [array of size 558 with values 5]) vs (1, [array of size 879 with values 21])\n \n     size_t allowed_collisions = 8;\n-    checkColumn(hash.getData(), eq_data, print_func, allowed_collisions);\n+    checkColumn(hash.getData(), eq_data, allowed_collisions);\n }\ndiff --git a/src/Common/tests/gtest_hash_table.cpp b/src/Common/tests/gtest_hash_table.cpp\nindex 1c673166ca9c..35fb471f07c8 100644\n--- a/src/Common/tests/gtest_hash_table.cpp\n+++ b/src/Common/tests/gtest_hash_table.cpp\n@@ -5,11 +5,17 @@\n \n #include <Common/HashTable/HashMap.h>\n #include <Common/HashTable/HashSet.h>\n+#include <Common/HashTable/Hash.h>\n \n #include <IO/ReadBufferFromString.h>\n+#include <IO/WriteHelpers.h>\n \n #include <gtest/gtest.h>\n \n+\n+using namespace DB;\n+\n+\n /// To test dump functionality without using other hashes that can change\n template <typename T>\n struct DummyHash\n@@ -18,12 +24,12 @@ struct DummyHash\n };\n \n template<typename HashTable>\n-std::set<typename HashTable::value_type> convertToSet(const HashTable& table)\n+std::set<std::string> convertToSet(const HashTable & table)\n {\n-    std::set<typename HashTable::value_type> result;\n+    std::set<std::string> result;\n \n     for (auto v: table)\n-        result.emplace(v.getValue());\n+        result.emplace(toString(v.getValue()));\n \n     return result;\n }\n@@ -91,8 +97,8 @@ TEST(HashTable, Iteration)\n     cont.insert(2);\n     cont.insert(3);\n \n-    std::set<int> expected = {1, 2, 3};\n-    std::set<int> actual = convertToSet(cont);\n+    std::set<std::string> expected = {\"1\", \"2\", \"3\"};\n+    std::set<std::string> actual = convertToSet(cont);\n \n     ASSERT_EQ(actual, expected);\n }\n@@ -251,14 +257,14 @@ TEST(HashTable, SerializationDeserialization)\n         cont.insert(2);\n         cont.insert(3);\n \n-        DB::WriteBufferFromOwnString wb;\n+        WriteBufferFromOwnString wb;\n         cont.writeText(wb);\n \n         std::string expected = \"3,1,2,3\";\n \n         ASSERT_EQ(wb.str(), expected);\n \n-        DB::ReadBufferFromString rb(expected);\n+        ReadBufferFromString rb(expected);\n \n         Cont deserialized;\n         deserialized.readText(rb);\n@@ -273,10 +279,10 @@ TEST(HashTable, SerializationDeserialization)\n         cont.insert(2);\n         cont.insert(3);\n \n-        DB::WriteBufferFromOwnString wb;\n+        WriteBufferFromOwnString wb;\n         cont.write(wb);\n \n-        DB::ReadBufferFromString rb(wb.str());\n+        ReadBufferFromString rb(wb.str());\n \n         Cont deserialized;\n         deserialized.read(rb);\n@@ -286,23 +292,23 @@ TEST(HashTable, SerializationDeserialization)\n         using Cont = HashSet<int, DummyHash<int>, HashTableGrower<1>>;\n         Cont cont;\n \n-        DB::WriteBufferFromOwnString wb;\n+        WriteBufferFromOwnString wb;\n         cont.writeText(wb);\n \n         std::string expected = \"0\";\n         ASSERT_EQ(wb.str(), expected);\n \n-        DB::ReadBufferFromString rb(expected);\n+        ReadBufferFromString rb(expected);\n \n         Cont deserialized;\n         deserialized.readText(rb);\n         ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));\n     }\n     {\n-        using Cont = HashSet<DB::UInt128, DB::UInt128TrivialHash>;\n+        using Cont = HashSet<UInt128, UInt128TrivialHash>;\n         Cont cont;\n \n-        DB::WriteBufferFromOwnString wb;\n+        WriteBufferFromOwnString wb;\n         cont.write(wb);\n \n         std::string expected;\n@@ -310,7 +316,7 @@ TEST(HashTable, SerializationDeserialization)\n \n         ASSERT_EQ(wb.str(), expected);\n \n-        DB::ReadBufferFromString rb(expected);\n+        ReadBufferFromString rb(expected);\n \n         Cont deserialized;\n         deserialized.read(rb);\n@@ -359,8 +365,8 @@ TEST(HashTable, Resize)\n         cont.insert(3);\n         cont.insert(1);\n \n-        std::set<int> expected = {1, 3};\n-        std::set<int> actual = convertToSet(cont);\n+        std::set<std::string> expected = {\"1\", \"3\"};\n+        std::set<std::string> actual = convertToSet(cont);\n \n         ASSERT_EQ(actual, expected);\n     }\ndiff --git a/src/Common/tests/gtest_pod_array.cpp b/src/Common/tests/gtest_pod_array.cpp\nindex 2f41f641b097..74fbf447f29a 100644\n--- a/src/Common/tests/gtest_pod_array.cpp\n+++ b/src/Common/tests/gtest_pod_array.cpp\n@@ -459,18 +459,6 @@ TEST(Common, PODArrayInsertFromItself)\n     }\n }\n \n-TEST(Common, PODPushBackRawMany)\n-{\n-    PODArray<char> chars;\n-    chars.push_back_raw_many(5, \"first\");\n-    EXPECT_EQ(std::string(\"first\"), std::string(chars.data(), chars.size()));\n-    EXPECT_EQ(5, chars.size());\n-    EXPECT_LE(chars.capacity() - chars.size(), 10);\n-    chars.push_back_raw_many(10, \"0123456789\");\n-    EXPECT_EQ(15, chars.size());\n-    EXPECT_EQ(std::string(\"first0123456789\"), std::string(chars.data(), chars.size()));\n-}\n-\n TEST(Common, PODNoOverallocation)\n {\n     /// Check that PaddedPODArray allocates for smaller number of elements than the power of two due to padding.\ndiff --git a/src/Common/tests/gtest_wide_integer.cpp b/src/Common/tests/gtest_wide_integer.cpp\nnew file mode 100644\nindex 000000000000..982bbee804ef\n--- /dev/null\n+++ b/src/Common/tests/gtest_wide_integer.cpp\n@@ -0,0 +1,281 @@\n+#include <gtest/gtest.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+#include <initializer_list>\n+\n+#include <Core/Types.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadHelpers.h>\n+#include <common/demangle.h>\n+\n+\n+static_assert(is_signed_v<Int128>);\n+static_assert(!is_unsigned_v<Int128>);\n+static_assert(is_integer_v<Int128>);\n+static_assert(sizeof(Int128) == 16);\n+\n+static_assert(is_signed_v<Int256>);\n+static_assert(!is_unsigned_v<Int256>);\n+static_assert(is_integer_v<Int256>);\n+static_assert(sizeof(Int256) == 32);\n+\n+static_assert(!is_signed_v<UInt128>);\n+static_assert(is_unsigned_v<UInt128>);\n+static_assert(is_integer_v<UInt128>);\n+static_assert(sizeof(UInt128) == 16);\n+\n+static_assert(!is_signed_v<UInt256>);\n+static_assert(is_unsigned_v<UInt256>);\n+static_assert(is_integer_v<UInt256>);\n+static_assert(sizeof(UInt256) == 32);\n+\n+\n+using namespace DB;\n+\n+\n+GTEST_TEST(WideInteger, Conversions)\n+{\n+    ASSERT_EQ(toString(UInt128(12345678901234567890ULL)), \"12345678901234567890\");\n+    ASSERT_EQ(toString(UInt256(12345678901234567890ULL)), \"12345678901234567890\");\n+\n+    Int128 minus_one = -1;\n+    ASSERT_EQ(minus_one.items[0], -1);\n+    ASSERT_EQ(minus_one.items[1], -1);\n+\n+    ASSERT_EQ(0, memcmp(&minus_one, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(minus_one)));\n+\n+    ASSERT_EQ(minus_one, -1);\n+    ASSERT_EQ(minus_one, -1LL);\n+    ASSERT_EQ(minus_one, Int8(-1));\n+    ASSERT_EQ(minus_one, Int16(-1));\n+    ASSERT_EQ(minus_one, Int32(-1));\n+    ASSERT_EQ(minus_one, Int64(-1));\n+\n+    ASSERT_LT(minus_one, 0);\n+\n+    Int128 zero = 0;\n+    zero += -1;\n+    ASSERT_EQ(zero, -1);\n+    ASSERT_EQ(zero, minus_one);\n+\n+    zero += minus_one;\n+    ASSERT_EQ(0, memcmp(&zero, \"\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(zero)));\n+\n+    zero += 2;\n+    ASSERT_EQ(zero, 0);\n+\n+    ASSERT_EQ(toString(Int128(-1)), \"-1\");\n+    ASSERT_EQ(toString(Int256(-1)), \"-1\");\n+\n+    ASSERT_EQ(toString(Int128(-1LL)), \"-1\");\n+    ASSERT_EQ(toString(Int256(-1LL)), \"-1\");\n+\n+    ASSERT_EQ(toString(Int128(-1234567890123456789LL)), \"-1234567890123456789\");\n+    ASSERT_EQ(toString(Int256(-1234567890123456789LL)), \"-1234567890123456789\");\n+\n+    ASSERT_EQ(UInt64(UInt128(12345678901234567890ULL)), 12345678901234567890ULL);\n+    ASSERT_EQ(UInt64(UInt256(12345678901234567890ULL)), 12345678901234567890ULL);\n+\n+    ASSERT_EQ(__uint128_t(UInt128(12345678901234567890ULL)), 12345678901234567890ULL);\n+    ASSERT_EQ(__uint128_t(UInt256(12345678901234567890ULL)), 12345678901234567890ULL);\n+\n+    ASSERT_EQ(__int128_t(Int128(-1234567890123456789LL)), -1234567890123456789LL);\n+    ASSERT_EQ(__int128_t(Int256(-1234567890123456789LL)), -1234567890123456789LL);\n+\n+    ASSERT_EQ(toString(Int128(-1)), \"-1\");\n+    ASSERT_EQ(toString(Int256(-1)), \"-1\");\n+\n+    ASSERT_EQ(toString(UInt128(123.456)), \"123\");\n+    ASSERT_EQ(toString(UInt256(123.456)), \"123\");\n+    ASSERT_EQ(toString(Int128(-123.456)), \"-123\");\n+    ASSERT_EQ(toString(Int256(-123.456)), \"-123\");\n+\n+    ASSERT_EQ(toString(UInt128(123.456f)), \"123\");\n+    ASSERT_EQ(toString(UInt256(123.456f)), \"123\");\n+    ASSERT_EQ(toString(Int128(-123.456f)), \"-123\");\n+    ASSERT_EQ(toString(Int256(-123.456f)), \"-123\");\n+\n+    ASSERT_EQ(toString(UInt128(1) * 1000000000 * 1000000000 * 1000000000 * 1000000000), \"1000000000000000000000000000000000000\");\n+    ASSERT_EQ(Float64(UInt128(1) * 1000000000 * 1000000000 * 1000000000 * 1000000000), 1e36);\n+\n+    ASSERT_EQ(toString(UInt256(1) * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000),\n+        \"1000000000000000000000000000000000000000000000000000000000000000000000000\");\n+    ASSERT_EQ(Float64(UInt256(1) * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000 * 1000000000), 1e72);\n+\n+    EXPECT_EQ(toString(parse<Int128>(\"148873535527910577765226390751398592640\")), \"148873535527910577765226390751398592640\");\n+    EXPECT_EQ(toString(parse<UInt128>(\"148873535527910577765226390751398592640\")), \"148873535527910577765226390751398592640\");\n+}\n+\n+\n+template <typename T>\n+static T divide(T & numerator, T && denominator)\n+{\n+    if (!denominator)\n+        throwError(\"Division by zero\");\n+\n+    T & n = numerator;\n+    T & d = denominator;\n+    T x = 1;\n+    T quotient = 0;\n+\n+    /// Multiply d to the power of two until it will be greater than n.\n+    /// The factor will be collected in x.\n+    while (d <= n && ((d >> (sizeof(T) * 8 - 1)) & 1) == 0)\n+    {\n+        x <<= 1;\n+        d <<= 1;\n+    }\n+\n+    std::cerr << toString(x) << \", \" << toString(d) << \"\\n\";\n+\n+    while (x)\n+    {\n+        if (d <= n)\n+        {\n+            n -= d;\n+            quotient |= x;\n+        }\n+\n+        x >>= 1;\n+        d >>= 1;\n+    }\n+\n+    return quotient;\n+}\n+\n+\n+GTEST_TEST(WideInteger, Arithmetic)\n+{\n+    Int128 minus_one = -1;\n+    Int128 zero = 0;\n+\n+    zero += -1;\n+    ASSERT_EQ(zero, -1);\n+    ASSERT_EQ(zero, minus_one);\n+\n+    zero += minus_one;\n+    ASSERT_EQ(0, memcmp(&zero, \"\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(zero)));\n+\n+    zero += 2;\n+    ASSERT_EQ(zero, 0);\n+\n+    ASSERT_EQ(UInt256(12345678901234567890ULL) * 12345678901234567890ULL / 12345678901234567890ULL, 12345678901234567890ULL);\n+    ASSERT_EQ(UInt256(12345678901234567890ULL) * UInt256(12345678901234567890ULL) / 12345678901234567890ULL, 12345678901234567890ULL);\n+    ASSERT_EQ(UInt256(12345678901234567890ULL) * 12345678901234567890ULL / UInt256(12345678901234567890ULL), 12345678901234567890ULL);\n+    ASSERT_EQ(UInt256(12345678901234567890ULL) * 12345678901234567890ULL / 12345678901234567890ULL, UInt256(12345678901234567890ULL));\n+    ASSERT_EQ(UInt128(12345678901234567890ULL) * 12345678901234567890ULL / UInt128(12345678901234567890ULL), 12345678901234567890ULL);\n+    ASSERT_EQ(UInt256(12345678901234567890ULL) * UInt128(12345678901234567890ULL) / 12345678901234567890ULL, 12345678901234567890ULL);\n+\n+    ASSERT_EQ(Int128(0) + Int32(-1), Int128(-1));\n+\n+    Int128 x(parse<Int128>(\"148873535527910577765226390751398592640\"));\n+    Int128 dividend = x / 10;\n+    ASSERT_EQ(toString(dividend), \"14887353552791057776522639075139859264\");\n+}\n+\n+\n+GTEST_TEST(WideInteger, DecimalArithmetic)\n+{\n+    Decimal128 zero{};\n+    Decimal32 addend = -1000;\n+\n+    zero += Decimal128(addend);\n+    ASSERT_EQ(zero.value, -1000);\n+\n+    zero += addend;\n+    ASSERT_EQ(zero.value, -2000);\n+}\n+\n+\n+GTEST_TEST(WideInteger, FromDouble)\n+{\n+    /// Check that we are being able to convert double to big integer without the help of floating point instructions.\n+    /// (a prototype of a function that we may need)\n+\n+    double f = -123.456;\n+    UInt64 u;\n+    memcpy(&u, &f, sizeof(f));\n+\n+    bool is_negative = u >> 63;\n+    uint16_t exponent = (u >> 52) & (((1ull << 12) - 1) >> 1);\n+    int16_t normalized_exponent = exponent - 1023;\n+    UInt64 mantissa = u & ((1ull << 52) - 1);\n+\n+    // std::cerr << is_negative << \", \" << normalized_exponent << \", \" << mantissa << \"\\n\";\n+\n+    /// x = sign * (2 ^ normalized_exponent + mantissa * 2 ^ (normalized_exponent - mantissa_bits))\n+\n+    Int128 res = 0;\n+\n+    if (normalized_exponent >= 128)\n+    {\n+    }\n+    else\n+    {\n+        res = mantissa;\n+        if (normalized_exponent > 52)\n+            res <<= (normalized_exponent - 52);\n+        else\n+            res >>= (52 - normalized_exponent);\n+\n+        if (normalized_exponent > 0)\n+            res += Int128(1) << normalized_exponent;\n+    }\n+\n+    if (is_negative)\n+        res = -res;\n+\n+    ASSERT_EQ(toString(res), \"-123\");\n+}\n+\n+\n+GTEST_TEST(WideInteger, Shift)\n+{\n+    Int128 x = 1;\n+\n+    auto y = x << 64;\n+    ASSERT_EQ(0, memcmp(&y, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", sizeof(Int128)));\n+\n+    auto z = y << 11;\n+    ASSERT_EQ(toString(z), \"37778931862957161709568\");\n+\n+    auto a = x << 11;\n+    ASSERT_EQ(a, 2048);\n+\n+    z >>= 64;\n+    ASSERT_EQ(z, a);\n+\n+    x = -1;\n+    y = x << 16;\n+\n+    ASSERT_EQ(0, memcmp(&y, \"\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(Int128)));\n+\n+    y >>= 16;\n+    ASSERT_EQ(0, memcmp(&y, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(Int128)));\n+\n+    y <<= 64;\n+    ASSERT_EQ(0, memcmp(&y, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(Int128)));\n+\n+    y >>= 32;\n+    ASSERT_EQ(0, memcmp(&y, \"\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", sizeof(Int128)));\n+\n+    y <<= 64;\n+    ASSERT_EQ(0, memcmp(&y, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\", sizeof(Int128)));\n+}\n+\n+\n+GTEST_TEST(WideInteger, DecimalFormatting)\n+{\n+    Decimal128 x(parse<Int128>(\"148873535527910577765226390751398592640\"));\n+\n+    EXPECT_EQ(toString(x.value), \"148873535527910577765226390751398592640\");\n+    EXPECT_EQ(toString(x.value / 10), \"14887353552791057776522639075139859264\");\n+    EXPECT_EQ(toString(x.value % 10), \"0\");\n+\n+    Int128 fractional = DecimalUtils::getFractionalPart(x, 2);\n+\n+    EXPECT_EQ(fractional, 40);\n+    EXPECT_EQ(decimalFractional(fractional, 2), \"40\");\n+}\ndiff --git a/src/Core/tests/gtest_accurate_comparison.cpp b/src/Core/tests/gtest_accurate_comparison.cpp\nnew file mode 100644\nindex 000000000000..bac4ad3d72df\n--- /dev/null\n+++ b/src/Core/tests/gtest_accurate_comparison.cpp\n@@ -0,0 +1,76 @@\n+#include <gtest/gtest.h>\n+#include <Core/AccurateComparison.h>\n+\n+using namespace DB;\n+\n+\n+GTEST_TEST(AccurateComparison, Tests)\n+{\n+    /// Arbitrary assortion of cases.\n+\n+    ASSERT_TRUE(accurate::equalsOp(static_cast<Float32>(123), static_cast<UInt64>(123)));\n+    ASSERT_TRUE(accurate::lessOp(static_cast<Float32>(123), static_cast<UInt64>(124)));\n+    ASSERT_TRUE(accurate::lessOp(static_cast<Float32>(-1), static_cast<UInt64>(1)));\n+    ASSERT_TRUE(accurate::lessOp(static_cast<Int64>(-1), static_cast<UInt64>(1)));\n+    ASSERT_TRUE(!accurate::equalsOp(static_cast<Int64>(-1), static_cast<UInt64>(-1)));\n+\n+    ASSERT_TRUE(accurate::equalsOp(-0., 0));\n+    ASSERT_TRUE(accurate::lessOp(-0., 1));\n+    ASSERT_TRUE(accurate::lessOp(-0.5, 1));\n+    ASSERT_TRUE(accurate::lessOp(0.5, 1));\n+    ASSERT_TRUE(accurate::equalsOp(1.0, 1));\n+    ASSERT_TRUE(accurate::greaterOp(1.1, 1));\n+    ASSERT_TRUE(accurate::greaterOp(11.1, 1));\n+    ASSERT_TRUE(accurate::greaterOp(11.1, 11));\n+    ASSERT_TRUE(accurate::lessOp(-11.1, 11));\n+    ASSERT_TRUE(accurate::lessOp(-11.1, -11));\n+    ASSERT_TRUE(accurate::lessOp(-1.1, -1));\n+    ASSERT_TRUE(accurate::greaterOp(-1.1, -2));\n+    ASSERT_TRUE(accurate::greaterOp(1000., 100));\n+    ASSERT_TRUE(accurate::greaterOp(-100., -1000));\n+    ASSERT_TRUE(accurate::lessOp(100., 1000));\n+    ASSERT_TRUE(accurate::lessOp(-1000., -100));\n+\n+    ASSERT_TRUE(accurate::lessOp(-std::numeric_limits<Float64>::infinity(), 0));\n+    ASSERT_TRUE(accurate::lessOp(-std::numeric_limits<Float64>::infinity(), 1000));\n+    ASSERT_TRUE(accurate::lessOp(-std::numeric_limits<Float64>::infinity(), -1000));\n+    ASSERT_TRUE(accurate::greaterOp(std::numeric_limits<Float64>::infinity(), 0));\n+    ASSERT_TRUE(accurate::greaterOp(std::numeric_limits<Float64>::infinity(), 1000));\n+    ASSERT_TRUE(accurate::greaterOp(std::numeric_limits<Float64>::infinity(), -1000));\n+\n+    ASSERT_TRUE(accurate::lessOp(1, 1e100));\n+    ASSERT_TRUE(accurate::lessOp(-1, 1e100));\n+    ASSERT_TRUE(accurate::lessOp(-1e100, 1));\n+    ASSERT_TRUE(accurate::lessOp(-1e100, -1));\n+\n+    /// Tricky cases with floats.\n+\n+    ASSERT_TRUE(accurate::equalsOp(static_cast<UInt64>(9223372036854775808ULL), static_cast<Float64>(9223372036854775808ULL)));\n+    ASSERT_TRUE(accurate::equalsOp(static_cast<UInt64>(9223372036854775808ULL), static_cast<Float32>(9223372036854775808ULL)));\n+\n+    ASSERT_TRUE(accurate::greaterOp(static_cast<UInt64>(9223372036854776000ULL), static_cast<Float64>(9223372036854776000ULL)));\n+    ASSERT_TRUE(accurate::lessOp(static_cast<UInt64>(9223372000000000000ULL), static_cast<Float32>(9223372000000000000ULL)));\n+\n+    ASSERT_TRUE(accurate::equalsOp(static_cast<Float32>(9223372036854775808ULL), static_cast<Float64>(9223372036854775808ULL)));\n+\n+    /// Integers\n+\n+    ASSERT_TRUE(accurate::lessOp(static_cast<UInt8>(255), 300));\n+    ASSERT_TRUE(accurate::lessOp(static_cast<UInt8>(255), static_cast<Int16>(300)));\n+    ASSERT_TRUE(accurate::notEqualsOp(static_cast<UInt8>(255), 44));\n+    ASSERT_TRUE(accurate::notEqualsOp(static_cast<UInt8>(255), static_cast<Int16>(44)));\n+\n+\n+/*    Float32 f = static_cast<Float32>(9223372000000000000ULL);\n+    UInt64 u = static_cast<UInt64>(9223372000000000000ULL);\n+    DecomposedFloat32 components(f);\n+\n+    std::cerr << std::fixed << std::setprecision(3) << f\n+        << \", \" << components.normalized_exponent()\n+        << \", \" << components.mantissa()\n+        << \", \" << (components.mantissa() << (components.normalized_exponent() - 23))\n+        << \", \" << (1ULL << components.normalized_exponent())\n+        << \", \" << (components.normalized_exponent() >= static_cast<int16_t>(8 * sizeof(UInt64) - is_signed_v<UInt64>))\n+        << \": \" << components.compare(u)\n+        << \"\\n\";*/\n+}\ndiff --git a/src/Storages/MergeTree/tests/gtest_ReplicatedMergeTreeLogEntry.cpp b/src/Storages/MergeTree/tests/gtest_ReplicatedMergeTreeLogEntry.cpp\ndeleted file mode 100644\nindex 03f36d866bb3..000000000000\n--- a/src/Storages/MergeTree/tests/gtest_ReplicatedMergeTreeLogEntry.cpp\n+++ /dev/null\n@@ -1,348 +0,0 @@\n-#include <Storages/MergeTree/ReplicatedMergeTreeLogEntry.h>\n-\n-#include <IO/ReadBufferFromString.h>\n-\n-#include <Core/iostream_debug_helpers.h>\n-\n-#include <type_traits>\n-#include <regex>\n-\n-#include <gtest/gtest.h>\n-\n-namespace DB\n-{\n-std::ostream & operator<<(std::ostream & ostr, const MergeTreeDataPartType & type)\n-{\n-    return ostr << type.toString();\n-}\n-\n-std::ostream & operator<<(std::ostream & ostr, const UInt128 & v)\n-{\n-    return ostr << v.toHexString();\n-}\n-\n-template <typename T, typename Tag>\n-std::ostream & operator<<(std::ostream & ostr, const StrongTypedef<T, Tag> & v)\n-{\n-    return ostr << v.toUnderType();\n-}\n-\n-std::ostream & operator<<(std::ostream & ostr, const MergeType & v)\n-{\n-    return ostr << toString(v);\n-}\n-\n-}\n-\n-namespace std\n-{\n-\n-std::ostream & operator<<(std::ostream & ostr, const std::exception_ptr & exception)\n-{\n-    try\n-    {\n-        if (exception)\n-        {\n-            std::rethrow_exception(exception);\n-        }\n-        return ostr << \"<NULL EXCEPTION>\";\n-    }\n-    catch (const std::exception& e)\n-    {\n-        return ostr << e.what();\n-    }\n-}\n-\n-template <typename T>\n-inline std::ostream& operator<<(std::ostream & ostr, const std::vector<T> & v)\n-{\n-    ostr << \"[\";\n-    for (size_t i = 0; i < v.size(); ++i)\n-    {\n-        ostr << i;\n-        if (i != v.size() - 1)\n-            ostr << \", \";\n-    }\n-    return ostr << \"] (\" << v.size() << \") items\";\n-}\n-\n-}\n-\n-namespace\n-{\n-using namespace DB;\n-\n-template <typename T>\n-void compareAttributes(::testing::AssertionResult & result, const char * name, const T & expected_value, const T & actual_value);\n-\n-#define CMP_ATTRIBUTE(attribute) compareAttributes(result, #attribute, expected.attribute, actual.attribute)\n-\n-::testing::AssertionResult compare(\n-        const ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry & expected,\n-        const ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry & actual)\n-{\n-    auto result = ::testing::AssertionSuccess();\n-\n-    CMP_ATTRIBUTE(drop_range_part_name);\n-    CMP_ATTRIBUTE(from_database);\n-    CMP_ATTRIBUTE(from_table);\n-    CMP_ATTRIBUTE(src_part_names);\n-    CMP_ATTRIBUTE(new_part_names);\n-    CMP_ATTRIBUTE(part_names_checksums);\n-    CMP_ATTRIBUTE(columns_version);\n-\n-    return result;\n-}\n-\n-template <typename T>\n-bool compare(const T & expected, const T & actual)\n-{\n-    return expected == actual;\n-}\n-\n-template <typename T>\n-::testing::AssertionResult compare(const std::shared_ptr<T> & expected, const std::shared_ptr<T> & actual)\n-{\n-    if (!!expected != !!actual)\n-        return ::testing::AssertionFailure()\n-                << \"expected : \" << static_cast<const void*>(expected.get())\n-                << \"\\nactual   : \" << static_cast<const void*>(actual.get());\n-\n-    if (expected && actual)\n-        return compare(*expected, *actual);\n-\n-    return ::testing::AssertionSuccess();\n-}\n-\n-template <typename T>\n-void compareAttributes(::testing::AssertionResult & result, const char * name, const T & expected_value, const T & actual_value)\n-{\n-    const auto cmp_result = compare(expected_value, actual_value);\n-    if (cmp_result == false)\n-    {\n-        if (result)\n-            result = ::testing::AssertionFailure();\n-\n-        result << \"\\nMismatching attribute: \\\"\" << name << \"\\\"\";\n-        if constexpr (std::is_same_v<std::decay_t<decltype(cmp_result)>, ::testing::AssertionResult>)\n-            result << \"\\n\" << cmp_result.message();\n-        else\n-            result << \"\\n\\texpected: \" << expected_value\n-                   << \"\\n\\tactual  : \" << actual_value;\n-    }\n-};\n-\n-::testing::AssertionResult compare(const ReplicatedMergeTreeLogEntryData & expected, const ReplicatedMergeTreeLogEntryData & actual)\n-{\n-    ::testing::AssertionResult result = ::testing::AssertionSuccess();\n-\n-    CMP_ATTRIBUTE(znode_name);\n-    CMP_ATTRIBUTE(type);\n-    CMP_ATTRIBUTE(source_replica);\n-    CMP_ATTRIBUTE(new_part_name);\n-    CMP_ATTRIBUTE(new_part_type);\n-    CMP_ATTRIBUTE(block_id);\n-    CMP_ATTRIBUTE(actual_new_part_name);\n-    CMP_ATTRIBUTE(new_part_uuid);\n-    CMP_ATTRIBUTE(source_parts);\n-    CMP_ATTRIBUTE(deduplicate);\n-    CMP_ATTRIBUTE(deduplicate_by_columns);\n-    CMP_ATTRIBUTE(merge_type);\n-    CMP_ATTRIBUTE(column_name);\n-    CMP_ATTRIBUTE(index_name);\n-    CMP_ATTRIBUTE(detach);\n-    CMP_ATTRIBUTE(replace_range_entry);\n-    CMP_ATTRIBUTE(alter_version);\n-    CMP_ATTRIBUTE(have_mutation);\n-    CMP_ATTRIBUTE(columns_str);\n-    CMP_ATTRIBUTE(metadata_str);\n-    CMP_ATTRIBUTE(currently_executing);\n-    CMP_ATTRIBUTE(removed_by_other_entry);\n-    CMP_ATTRIBUTE(num_tries);\n-    CMP_ATTRIBUTE(exception);\n-    CMP_ATTRIBUTE(last_attempt_time);\n-    CMP_ATTRIBUTE(num_postponed);\n-    CMP_ATTRIBUTE(postpone_reason);\n-    CMP_ATTRIBUTE(last_postpone_time);\n-    CMP_ATTRIBUTE(create_time);\n-    CMP_ATTRIBUTE(quorum);\n-\n-    return result;\n-}\n-}\n-\n-\n-class ReplicatedMergeTreeLogEntryDataTest : public ::testing::TestWithParam<std::tuple<ReplicatedMergeTreeLogEntryData, const char* /* serialized RE*/>>\n-{};\n-\n-TEST_P(ReplicatedMergeTreeLogEntryDataTest, transcode)\n-{\n-    const auto & [expected, match_regex] = GetParam();\n-    const auto str = expected.toString();\n-\n-    if (match_regex)\n-    {\n-        try\n-        {\n-            // egrep since \".\" matches newline and we can also use \"\\n\" explicitly\n-            std::regex re(match_regex, std::regex::egrep);\n-            EXPECT_TRUE(std::regex_match(str, re))\n-                    << \"Failed to match serialized ReplicatedMergeTreeLogEntryData: {\\n\"\n-                    << str << \"} \\nwith regex: \\\"\" << match_regex << \"\\\"\\n\";\n-        }\n-        catch (const std::regex_error &e)\n-        {\n-            FAIL() << e.what()\n-                   << \" on regex: \" << match_regex\n-                   << \" (\" << strlen(match_regex) << \" bytes)\" << std::endl;\n-        }\n-        catch (...)\n-        {\n-            throw;\n-        }\n-    }\n-\n-    ReplicatedMergeTreeLogEntryData actual;\n-    {\n-        DB::ReadBufferFromString buffer(str);\n-        EXPECT_NO_THROW(actual.readText(buffer)) << \"While reading:\\n\" << str;\n-    }\n-\n-    ASSERT_TRUE(compare(expected, actual)) << \"Via text:\\n\" << str;\n-}\n-\n-// Enabling this warning would ruin test brievity without adding anything else in return,\n-// since most of the fields have default constructors or be will be zero-initialized as by standard,\n-// so values are predicatable and stable across runs.\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n-\n-INSTANTIATE_TEST_SUITE_P(Merge, ReplicatedMergeTreeLogEntryDataTest,\n-        ::testing::ValuesIn(std::initializer_list<std::tuple<ReplicatedMergeTreeLogEntryData, const char*>>{\n-    {\n-        {\n-            // Basic: minimal set of attributes.\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-            .create_time = 123, // 0 means 'now' which could cause flaky tests.\n-        },\n-        R\"re(^format version: 4.+merge.+into.+deduplicate: 0.+$)re\"\n-    },\n-    {\n-        {\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-\n-            // Format version 4\n-            .deduplicate = true,\n-\n-            .create_time = 123,\n-        },\n-        R\"re(^format version: 4.+merge.+into.+deduplicate: 1.+$)re\"\n-    },\n-    {\n-        {\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-\n-            // Format version 5\n-            .new_part_uuid = UUID(UInt128(123456789, 10111213141516)),\n-\n-            .create_time = 123,\n-        },\n-        R\"re(^format version: 5.+merge.+into.+deduplicate: 0.+into_uuid: 00000000-075b-cd15-0000-093233447e0c.+$)re\"\n-    },\n-    {\n-        {\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-\n-            // Format version 6\n-            .deduplicate = true,\n-            .deduplicate_by_columns = {\"foo\", \"bar\", \"qux\"},\n-\n-            .create_time = 123,\n-        },\n-        R\"re(^format version: 6.+merge.+into.+deduplicate: 1.+deduplicate_by_columns: 'foo','bar','qux'.*$)re\"\n-    },\n-    {\n-        {\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-\n-            // Mixing features\n-            .new_part_uuid = UUID(UInt128(123456789, 10111213141516)),\n-            .deduplicate = true,\n-            .deduplicate_by_columns = {\"foo\", \"bar\", \"qux\"},\n-\n-            .create_time = 123,\n-        },\n-        R\"re(^format version: 6.+merge.+into.+deduplicate: 1.+into_uuid: 00000000-075b-cd15-0000-093233447e0c.+deduplicate_by_columns: 'foo','bar','qux'.*$)re\"\n-    },\n-    {\n-        // Validate that exotic column names are serialized/deserialized properly\n-        {\n-            .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-            .new_part_type = MergeTreeDataPartType::WIDE,\n-\n-            // Mixing features\n-            .new_part_uuid = UUID(UInt128(123456789, 10111213141516)),\n-            .deduplicate = true,\n-            .deduplicate_by_columns = {\"name with space\", \"\\\"column\\\"\", \"'column'\", \"\u043a\u043e\u043b\u043e\u043d\u043a\u0430\", \"\\u30ab\\u30e9\\u30e0\", \"\\x01\\x03 column \\x10\\x11\\x12\"},\n-\n-            .create_time = 123,\n-        },\n-        R\"re(^format version: 6.+merge.+deduplicate_by_columns: 'name with space','\"column\"','\\\\'column\\\\'','\u043a\u043e\u043b\u043e\u043d\u043a\u0430')re\"\n-                \",'\\u30ab\\u30e9\\u30e0','\\x01\\x03 column \\x10\\x11\\x12'.*$\"\n-    },\n-}));\n-\n-#pragma GCC diagnostic pop\n-\n-// This is just an example of how to set all fields. Can't be used as is since depending on type,\n-// only some fields are serialized/deserialized, and even if everything works perfectly,\n-// some fields in deserialized object would be unset (hence differ from expected).\n-// INSTANTIATE_TEST_SUITE_P(Full, ReplicatedMergeTreeLogEntryDataTest,\n-//         ::testing::ValuesIn(std::initializer_list<ReplicatedMergeTreeLogEntryData>{\n-//     {\n-//         .znode_name = \"znode name\",\n-//         .type = ReplicatedMergeTreeLogEntryData::MERGE_PARTS,\n-//         .source_replica = \"source replica\",\n-//         .new_part_name = \"new part name\",\n-//         .new_part_type = MergeTreeDataPartType::WIDE,\n-//         .block_id = \"block id\",\n-//         .actual_new_part_name = \"new part name\",\n-//         .new_part_uuid = UUID(UInt128(123456789, 10111213141516)),\n-//         .source_parts = {\"part1\", \"part2\"},\n-//         .deduplicate = true,\n-//         .deduplicate_by_columns = {\"col1\", \"col2\"},\n-//         .merge_type = MergeType::REGULAR,\n-//         .column_name = \"column name\",\n-//         .index_name = \"index name\",\n-//         .detach = false,\n-//         .replace_range_entry = std::make_shared<ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry>(\n-//             ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry\n-//             {\n-//                 .drop_range_part_name = \"drop range part name\",\n-//                 .from_database = \"from database\",\n-//                 .src_part_names = {\"src part name1\", \"src part name2\"},\n-//                 .new_part_names = {\"new part name1\", \"new part name2\"},\n-//                 .columns_version = 123456,\n-//             }),\n-//         .alter_version = 56789,\n-//         .have_mutation = false,\n-//         .columns_str = \"columns str\",\n-//         .metadata_str = \"metadata str\",\n-//         // Those attributes are not serialized to string, hence it makes no sense to set.\n-//         // .currently_executing\n-//         // .removed_by_other_entry\n-//         // .num_tries\n-//         // .exception\n-//         // .last_attempt_time\n-//         // .num_postponed\n-//         // .postpone_reason\n-//         // .last_postpone_time,\n-//         .create_time = static_cast<time_t>(123456789),\n-//         .quorum = 321,\n-//     },\n-// }));\ndiff --git a/tests/integration/runner b/tests/integration/runner\nindex e89e10fbc213..ee116c29aa5e 100755\n--- a/tests/integration/runner\n+++ b/tests/integration/runner\n@@ -64,7 +64,7 @@ def check_args_and_update_paths(args):\n         args.src_dir = os.path.abspath(os.path.join(CLICKHOUSE_ROOT, SRC_DIR_IN_REPO))\n         logging.info(\"src dir is not set. Will use {}\".format(args.src_dir))\n \n-    logging.info(\"base_configs_dir: {},  binary: {}, cases_dir: {} \".format(args.base_configs_dir, args.binary, args.cases_dir))\n+    logging.info(\"base_configs_dir: {}, binary: {}, cases_dir: {} \".format(args.base_configs_dir, args.binary, args.cases_dir))\n \n     for path in [args.binary, args.odbc_bridge_binary, args.library_bridge_binary, args.base_configs_dir, args.cases_dir, CLICKHOUSE_ROOT]:\n         if not os.path.exists(path):\ndiff --git a/tests/integration/test_distributed_ddl/test.py b/tests/integration/test_distributed_ddl/test.py\nindex 9af27738eed2..68d8a2dab53e 100755\n--- a/tests/integration/test_distributed_ddl/test.py\n+++ b/tests/integration/test_distributed_ddl/test.py\n@@ -341,8 +341,8 @@ def test_replicated_without_arguments(test_cluster):\n                                  \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree('/clickhouse/tables/{uuid}/{shard}', '{replica}') ORDER BY n\")\n     test_cluster.ddl_check_query(instance,\n                                  \"EXCHANGE TABLES test_atomic.rmt AND test_atomic.rmt_renamed ON CLUSTER cluster\")\n-    assert instance.query(\"SELECT countDistinct(uuid) from clusterAllReplicas('cluster', 'system', 'databases') WHERE uuid != 0 AND name='test_atomic'\") == \"1\\n\"\n-    assert instance.query(\"SELECT countDistinct(uuid) from clusterAllReplicas('cluster', 'system', 'tables') WHERE uuid != 0 AND name='rmt'\") == \"1\\n\"\n+    assert instance.query(\"SELECT countDistinct(uuid) from clusterAllReplicas('cluster', 'system', 'databases') WHERE uuid != '00000000-0000-0000-0000-000000000000' AND name='test_atomic'\") == \"1\\n\"\n+    assert instance.query(\"SELECT countDistinct(uuid) from clusterAllReplicas('cluster', 'system', 'tables') WHERE uuid != '00000000-0000-0000-0000-000000000000' AND name='rmt'\") == \"1\\n\"\n     test_cluster.ddl_check_query(instance,\n                                  \"CREATE TABLE test_atomic.rrmt ON CLUSTER cluster (n UInt64, m UInt64) ENGINE=ReplicatedReplacingMergeTree(m) ORDER BY n\")\n     test_cluster.ddl_check_query(instance,\ndiff --git a/tests/integration/test_distributed_ddl_on_cross_replication/test.py b/tests/integration/test_distributed_ddl_on_cross_replication/test.py\nindex 85800b2e5e6e..833a3fb1f043 100644\n--- a/tests/integration/test_distributed_ddl_on_cross_replication/test.py\n+++ b/tests/integration/test_distributed_ddl_on_cross_replication/test.py\n@@ -20,23 +20,23 @@ def started_cluster():\n         node1.query('''\n             CREATE DATABASE replica_1 ON CLUSTER cross_3shards_2replicas;\n             CREATE DATABASE replica_2 ON CLUSTER cross_3shards_2replicas;\n-            \n-            CREATE TABLE replica_1.replicated_local  \n+\n+            CREATE TABLE replica_1.replicated_local\n             ON CLUSTER cross_3shards_2replicas (part_key Date, id UInt32, shard_id UInt32)\n-            ENGINE = ReplicatedMergeTree('/clickhouse/tables/{shard}/replicated', '{replica}') \n+            ENGINE = ReplicatedMergeTree('/clickhouse/tables/{shard}/replicated', '{replica}')\n             partition by part_key order by id;\n-            \n-            CREATE TABLE replica_1.replicated  \n-            ON CLUSTER cross_3shards_2replicas as replica_1.replicated_local  \n+\n+            CREATE TABLE replica_1.replicated\n+            ON CLUSTER cross_3shards_2replicas as replica_1.replicated_local\n             ENGINE = Distributed(cross_3shards_2replicas, '', replicated_local, shard_id);\n-                \n-            CREATE TABLE replica_2.replicated_local \n+\n+            CREATE TABLE replica_2.replicated_local\n             ON CLUSTER cross_3shards_2replicas (part_key Date, id UInt32, shard_id UInt32)\n-            ENGINE = ReplicatedMergeTree('/clickhouse/tables/{shard_bk}/replicated', '{replica_bk}') \n+            ENGINE = ReplicatedMergeTree('/clickhouse/tables/{shard_bk}/replicated', '{replica_bk}')\n             partition by part_key order by id;\n-            \n-            CREATE TABLE replica_2.replicated  \n-            ON CLUSTER cross_3shards_2replicas as replica_2.replicated_local  \n+\n+            CREATE TABLE replica_2.replicated\n+            ON CLUSTER cross_3shards_2replicas as replica_2.replicated_local\n             ENGINE = Distributed(cross_3shards_2replicas, '', replicated_local, shard_id);\n             ''')\n \n@@ -98,8 +98,8 @@ def test_atomic_database(started_cluster):\n     node1.query(\"CREATE TABLE replica_1.rmt ON CLUSTER cross_3shards_2replicas (n UInt64, s String) ENGINE=ReplicatedMergeTree('/tables/{shard}/rmt/', '{replica}') ORDER BY n\")\n     node1.query(\"CREATE TABLE replica_2.rmt ON CLUSTER cross_3shards_2replicas (n UInt64, s String) ENGINE=ReplicatedMergeTree('/tables/{shard_bk}/rmt/', '{replica_bk}') ORDER BY n\")\n \n-    assert node1.query(\"SELECT countDistinct(uuid) from remote('node1,node2,node3', 'system', 'databases') WHERE uuid != 0 AND name='replica_1'\") == \"1\\n\"\n-    assert node1.query(\"SELECT countDistinct(uuid) from remote('node1,node2,node3', 'system', 'tables') WHERE uuid != 0 AND name='rmt'\") == \"2\\n\"\n+    assert node1.query(\"SELECT countDistinct(uuid) from remote('node1,node2,node3', 'system', 'databases') WHERE uuid != '00000000-0000-0000-0000-000000000000' AND name='replica_1'\") == \"1\\n\"\n+    assert node1.query(\"SELECT countDistinct(uuid) from remote('node1,node2,node3', 'system', 'tables') WHERE uuid != '00000000-0000-0000-0000-000000000000' AND name='rmt'\") == \"2\\n\"\n \n     node1.query(\"INSERT INTO replica_1.rmt VALUES (1, 'test')\")\n     node2.query(\"SYSTEM SYNC REPLICA replica_2.rmt\", timeout=5)\ndiff --git a/tests/performance/single_fixed_string_groupby.xml b/tests/performance/single_fixed_string_groupby.xml\nindex 6bf5821707f5..8e166a124ff8 100644\n--- a/tests/performance/single_fixed_string_groupby.xml\n+++ b/tests/performance/single_fixed_string_groupby.xml\n@@ -10,8 +10,8 @@\n         INSERT INTO perf_lc_fixed_str_groupby SELECT ('number key ' || toString(number % 400)) AS a, ('number key ' || toString(number % 20)) AS b FROM numbers(30000000)\n     </fill_query>\n \n-    <query short=\"1\">SELECT count() FROM perf_lc_fixed_str_groupby GROUP BY a</query>\n-    <query short=\"1\">SELECT count() FROM perf_lc_fixed_str_groupby GROUP BY b</query>\n+    <query short=\"1\">SELECT count() FROM perf_lc_fixed_str_groupby GROUP BY a FORMAT Null</query>\n+    <query short=\"1\">SELECT count() FROM perf_lc_fixed_str_groupby GROUP BY b FORMAT Null</query>\n \n     <drop_query>DROP TABLE IF EXISTS perf_lc_fixed_str_groupby</drop_query>\n </test>\ndiff --git a/tests/queries/0_stateless/00700_decimal_arithm.reference b/tests/queries/0_stateless/00700_decimal_arithm.reference\nindex d0040ff5ae2c..9de0d4cbf9a1 100644\n--- a/tests/queries/0_stateless/00700_decimal_arithm.reference\n+++ b/tests/queries/0_stateless/00700_decimal_arithm.reference\n@@ -3,11 +3,13 @@\n 84\t0\t1764\t1\t1\t1\n 84.840\t0.000\t1799.456400\t1.000\t1.000\t1.000\n 84.840000000\t0.000000000\n+84.840000000000000000\t0.000000000000000000\t98.044565395307682683126962841158942720\t1.000000000000000000\t1.000000000000000000\t1.000000000000000000\n 84.840000000000000000\t0.000000000000000000\n 84.84\t0.00\t1799.4564\t1.00\t1.00\t1.00\n 63\t21\t-42\t882\t-882\t2\t0\t2\t0\n 63\t21\t-42\t882\t-882\t2\t0\t2\t0\n 63\t21\t-42\t882\t-882\t2\t0\t2\t0\n+1.00305798474369219219752355409390731264\t-0.16305798474369219219752355409390731264\t1.49059173023461586584365185794205286400\t-1.38847100762815390390123822295304634368\t1.38847100762815390390123822295304634368\t0.02000000000000000000000000000000000000\t0.00500000000000000000000000000000000000\n 63.420\t21.420\t-41.580\t890.820\t-890.820\t2.020\t0.505\t2.020\t0.505\n 63.420000000\t21.420000000\t-41.580000000\t890.820000000\t-890.820000000\t2.020000000\t0.505000000\t2.020000000\t0.505000000\n 63.420000000000000000\t21.420000000000000000\t-41.580000000000000000\t890.820000000000000000\t-890.820000000000000000\t2.020000000000000000\t0.505000000000000000\t2.020000000000000000\t0.505000000000000000\n@@ -15,6 +17,7 @@\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n+1.00305798474369219219752355409390731264\t0.16305798474369219219752355409390731264\t-1.49059173023461586584365185794205286400\t-1.38847100762815390390123822295304634368\t1.38847100762815390390123822295304634368\t-0.00000000000000000000000000000000000001\t0.00000000000000000000000000000000000001\n 63.420\t-21.420\t41.580\t890.820\t-890.820\t0.495\t1.980\t0.495\t1.980\n 63.420000000\t-21.420000000\t41.580000000\t890.820000000\t-890.820000000\n 63.420000000000000000\t-21.420000000000000000\t41.580000000000000000\t890.820000000000000000\t-890.820000000000000000\t0.495049504950495049\t1.980198019801980198\t0.495049504950495049\t1.980198019801980198\ndiff --git a/tests/queries/0_stateless/00700_decimal_arithm.sql b/tests/queries/0_stateless/00700_decimal_arithm.sql\nindex 3fa2aade7430..c305a850e5b3 100644\n--- a/tests/queries/0_stateless/00700_decimal_arithm.sql\n+++ b/tests/queries/0_stateless/00700_decimal_arithm.sql\n@@ -31,7 +31,7 @@ SELECT f + f, f - f, f * f, f / f, intDiv(f, f), intDivOrZero(f, f) FROM decimal\n SELECT g + g, g - g, g * g, g / g, intDiv(g, g), intDivOrZero(g, g) FROM decimal WHERE g > 0;\n SELECT h + h, h - h, h * h, h / h, intDiv(h, h), intDivOrZero(h, h) FROM decimal WHERE h > 0; -- { serverError 407 }\n SELECT h + h, h - h FROM decimal WHERE h > 0;\n-SELECT i + i, i - i, i * i, i / i, intDiv(i, i), intDivOrZero(i, i) FROM decimal WHERE i > 0; -- { serverError 407 }\n+SELECT i + i, i - i, i * i, i / i, intDiv(i, i), intDivOrZero(i, i) FROM decimal WHERE i > 0;\n SELECT i + i, i - i FROM decimal WHERE i > 0;\n SELECT j + j, j - j, j * j, j / j, intDiv(j, j), intDivOrZero(j, j) FROM decimal WHERE j > 0;\n \n@@ -39,7 +39,7 @@ SELECT a + 21, a - 21, a - 84, a * 21, a * -21, a / 21, a / 84, intDiv(a, 21), i\n SELECT b + 21, b - 21, b - 84, b * 21, b * -21, b / 21, b / 84, intDiv(b, 21), intDivOrZero(b, 84) FROM decimal WHERE b = 42;\n SELECT c + 21, c - 21, c - 84, c * 21, c * -21, c / 21, c / 84, intDiv(c, 21), intDivOrZero(c, 84) FROM decimal WHERE c = 42;\n SELECT e + 21, e - 21, e - 84, e * 21, e * -21, e / 21, e / 84 FROM decimal WHERE e > 0; -- { serverError 407 }\n-SELECT f + 21, f - 21, f - 84, f * 21, f * -21, f / 21, f / 84 FROM decimal WHERE f > 0; -- { serverError 407 }\n+SELECT f + 21, f - 21, f - 84, f * 21, f * -21, f / 21, f / 84 FROM decimal WHERE f > 0;\n SELECT g + 21, g - 21, g - 84, g * 21, g * -21, g / 21, g / 84, intDiv(g, 21), intDivOrZero(g, 84) FROM decimal WHERE g > 0;\n SELECT h + 21, h - 21, h - 84, h * 21, h * -21, h / 21, h / 84, intDiv(h, 21), intDivOrZero(h, 84) FROM decimal WHERE h > 0;\n SELECT i + 21, i - 21, i - 84, i * 21, i * -21, i / 21, i / 84, intDiv(i, 21), intDivOrZero(i, 84) FROM decimal WHERE i > 0;\n@@ -49,7 +49,7 @@ SELECT 21 + a, 21 - a, 84 - a, 21 * a, -21 * a, 21 / a, 84 / a, intDiv(21, a), i\n SELECT 21 + b, 21 - b, 84 - b, 21 * b, -21 * b, 21 / b, 84 / b, intDiv(21, b), intDivOrZero(84, b) FROM decimal WHERE b = 42;\n SELECT 21 + c, 21 - c, 84 - c, 21 * c, -21 * c, 21 / c, 84 / c, intDiv(21, c), intDivOrZero(84, c) FROM decimal WHERE c = 42;\n SELECT 21 + e, 21 - e, 84 - e, 21 * e, -21 * e, 21 / e, 84 / e FROM decimal WHERE e > 0; -- { serverError 407 }\n-SELECT 21 + f, 21 - f, 84 - f, 21 * f, -21 * f, 21 / f, 84 / f FROM decimal WHERE f > 0; -- { serverError 407 }\n+SELECT 21 + f, 21 - f, 84 - f, 21 * f, -21 * f, 21 / f, 84 / f FROM decimal WHERE f > 0;\n SELECT 21 + g, 21 - g, 84 - g, 21 * g, -21 * g, 21 / g, 84 / g, intDiv(21, g), intDivOrZero(84, g) FROM decimal WHERE g > 0;\n SELECT 21 + h, 21 - h, 84 - h, 21 * h, -21 * h, 21 / h, 84 / h FROM decimal WHERE h > 0; -- { serverError 407 }\n SELECT 21 + h, 21 - h, 84 - h, 21 * h, -21 * h FROM decimal WHERE h > 0;\ndiff --git a/tests/queries/0_stateless/00700_decimal_casts.reference b/tests/queries/0_stateless/00700_decimal_casts.reference\nindex 8832c2109f9a..99d8b9493981 100644\n--- a/tests/queries/0_stateless/00700_decimal_casts.reference\n+++ b/tests/queries/0_stateless/00700_decimal_casts.reference\n@@ -157,39 +157,3 @@\n 0.12345678\n 0.12345678912345678\n 0.1234567890123456789012345678901234567\n-1234567890.0000000000000000000000000000\t1234567890.00000000000000000000000000000\t1234567890.00000000000000000000000000000\n-1234567890.00000000\t1234567890.000000000\t1234567890.000000000\n-12345678.0\t12345678.00\t12345678.00\n-9223372036854775807.000000\t9223372036854775807\t-9223372036854775807\n-9223372036854775800\t9223372036854775800\t-9223372036854775800\n-92233720368547758.00\t92233720368547758\t-92233720368547758\n-2147483647.0000000000\t2147483647\t-2147483647\n-2147483647.00\t2147483647\t-2147483647\n-92233720368547757.99\t92233720368547757\t-92233720368547757\n-2147483640.99\t2147483640\t-2147483640\n--0.90000000\t0\n--0.90000000\t0\n--0.90000000\t0\n--0.8000\t0\n--0.8000\t0\n--0.8000\t0\n--0.70\t0\n--0.70\t0\n--0.70\t0\n--0.600000\t0\n--0.600000\t0\n--0.600000\t0\n-18446744073709551615\t18446744073709551615\n-18446744073709551615.00000000\t18446744073709551615\n-4294967295\t4294967295\n-4294967295.0000000000\t4294967295\n-4294967295\t4294967295\n-4294967295.0000\t4294967295\n-65535\t65535\n-65535.0000000000\t65535\n-65535\t65535\n-65535.0000\t65535\n-2147483647\t2147483647\n--2147483647\t-2147483647\n-2147483647\t2147483647\n-9223372036854775807\t9223372036854775807\ndiff --git a/tests/queries/0_stateless/00700_decimal_casts.sql b/tests/queries/0_stateless/00700_decimal_casts.sql\nindex 602ee02bc07b..8c752565feeb 100644\n--- a/tests/queries/0_stateless/00700_decimal_casts.sql\n+++ b/tests/queries/0_stateless/00700_decimal_casts.sql\n@@ -146,123 +146,3 @@ SELECT CAST('0.12345678901234567890123456789012345678', 'Decimal(38,38)');\n SELECT CAST('0.123456789', 'Decimal(9,8)');\n SELECT CAST('0.123456789123456789', 'Decimal(18,17)');\n SELECT CAST('0.12345678901234567890123456789012345678', 'Decimal(38,37)');\n-\n-SELECT toDecimal128('1234567890', 28) AS x, toDecimal128(x, 29), toDecimal128(toDecimal128('1234567890', 28), 29);\n-SELECT toDecimal128(toDecimal128('1234567890', 28), 30); -- { serverError 407 }\n-\n-SELECT toDecimal64('1234567890', 8) AS x, toDecimal64(x, 9), toDecimal64(toDecimal64('1234567890', 8), 9);\n-SELECT toDecimal64(toDecimal64('1234567890', 8), 10); -- { serverError 407 }\n-\n-SELECT toDecimal32('12345678', 1) AS x, toDecimal32(x, 2), toDecimal32(toDecimal32('12345678', 1), 2);\n-SELECT toDecimal32(toDecimal32('12345678', 1), 3); -- { serverError 407 }\n-\n-SELECT toDecimal64(toDecimal64('92233720368547758.1', 1), 2); -- { serverError 407 }\n-SELECT toDecimal64(toDecimal64('-92233720368547758.1', 1), 2); -- { serverError 407 }\n-\n-SELECT toDecimal128('9223372036854775807', 6) AS x, toInt64(x), toInt64(-x);\n-SELECT toDecimal128('9223372036854775809', 6) AS x, toInt64(x); -- { serverError 407 }\n-SELECT toDecimal128('9223372036854775809', 6) AS x, toInt64(-x); -- { serverError 407 }\n-SELECT toDecimal64('922337203685477580', 0) * 10 AS x, toInt64(x), toInt64(-x);\n-SELECT toDecimal64(toDecimal64('92233720368547758.0', 1), 2) AS x, toInt64(x), toInt64(-x);\n-\n-SELECT toDecimal128('2147483647', 10) AS x, toInt32(x), toInt32(-x);\n-SELECT toDecimal128('2147483649', 10) AS x, toInt32(x), toInt32(-x); -- { serverError 407 }\n-SELECT toDecimal64('2147483647', 2) AS x, toInt32(x), toInt32(-x);\n-SELECT toDecimal64('2147483649', 2) AS x, toInt32(x), toInt32(-x); -- { serverError 407 }\n-\n-SELECT toDecimal128('92233720368547757.99', 2) AS x, toInt64(x), toInt64(-x);\n-SELECT toDecimal64('2147483640.99', 2) AS x, toInt32(x), toInt32(-x);\n-\n-SELECT toDecimal128('-0.9', 8) AS x, toUInt64(x);\n-SELECT toDecimal64('-0.9', 8) AS x, toUInt64(x);\n-SELECT toDecimal32('-0.9', 8) AS x, toUInt64(x);\n-\n-SELECT toDecimal128('-0.8', 4) AS x, toUInt32(x);\n-SELECT toDecimal64('-0.8', 4) AS x, toUInt32(x);\n-SELECT toDecimal32('-0.8', 4) AS x, toUInt32(x);\n-\n-SELECT toDecimal128('-0.7', 2) AS x, toUInt16(x);\n-SELECT toDecimal64('-0.7', 2) AS x, toUInt16(x);\n-SELECT toDecimal32('-0.7', 2) AS x, toUInt16(x);\n-\n-SELECT toDecimal128('-0.6', 6) AS x, toUInt8(x);\n-SELECT toDecimal64('-0.6', 6) AS x, toUInt8(x);\n-SELECT toDecimal32('-0.6', 6) AS x, toUInt8(x);\n-\n-SELECT toDecimal128('-1', 7) AS x, toUInt64(x); -- { serverError 407 }\n-SELECT toDecimal128('-1', 7) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal128('-1', 7) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal128('-1', 7) AS x, toUInt8(x); -- { serverError 407 }\n-\n-SELECT toDecimal64('-1', 5) AS x, toUInt64(x); -- { serverError 407 }\n-SELECT toDecimal64('-1', 5) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal64('-1', 5) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal64('-1', 5) AS x, toUInt8(x); -- { serverError 407 }\n-\n-SELECT toDecimal32('-1', 3) AS x, toUInt64(x); -- { serverError 407 }\n-SELECT toDecimal32('-1', 3) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal32('-1', 3) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal32('-1', 3) AS x, toUInt8(x); -- { serverError 407 }\n-\n-SELECT toDecimal128('18446744073709551615', 0) AS x, toUInt64(x);\n-SELECT toDecimal128('18446744073709551616', 0) AS x, toUInt64(x); -- { serverError 407 }\n-SELECT toDecimal128('18446744073709551615', 8) AS x, toUInt64(x);\n-SELECT toDecimal128('18446744073709551616', 8) AS x, toUInt64(x); -- { serverError 407 }\n-\n-SELECT toDecimal128('4294967295', 0) AS x, toUInt32(x);\n-SELECT toDecimal128('4294967296', 0) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal128('4294967295', 10) AS x, toUInt32(x);\n-SELECT toDecimal128('4294967296', 10) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal64('4294967295', 0) AS x, toUInt32(x);\n-SELECT toDecimal64('4294967296', 0) AS x, toUInt32(x); -- { serverError 407 }\n-SELECT toDecimal64('4294967295', 4) AS x, toUInt32(x);\n-SELECT toDecimal64('4294967296', 4) AS x, toUInt32(x); -- { serverError 407 }\n-\n-SELECT toDecimal128('65535', 0) AS x, toUInt16(x);\n-SELECT toDecimal128('65536', 0) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal128('65535', 10) AS x, toUInt16(x);\n-SELECT toDecimal128('65536', 10) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal64('65535', 0) AS x, toUInt16(x);\n-SELECT toDecimal64('65536', 0) AS x, toUInt16(x); -- { serverError 407 }\n-SELECT toDecimal64('65535', 4) AS x, toUInt16(x);\n-SELECT toDecimal64('65536', 4) AS x, toUInt16(x); -- { serverError 407 }\n-\n-SELECT toInt64('2147483647') AS x, toDecimal32(x, 0);\n-SELECT toInt64('-2147483647') AS x, toDecimal32(x, 0);\n-SELECT toUInt64('2147483647') AS x, toDecimal32(x, 0);\n-SELECT toInt64('2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n-SELECT toInt64('-2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n-SELECT toUInt64('2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n-\n-SELECT toUInt64('9223372036854775807') AS x, toDecimal64(x, 0);\n-SELECT toUInt64('9223372036854775809') AS x, toDecimal64(x, 0); -- { serverError 407 }\n-\n-SELECT toDecimal32(0, rowNumberInBlock()); -- { serverError 44 }\n-SELECT toDecimal64(0, rowNumberInBlock()); -- { serverError 44 }\n-SELECT toDecimal128(0, rowNumberInBlock()); -- { serverError 44 }\n-\n-SELECT toDecimal32(1/0, 0); -- { serverError 407 }\n-SELECT toDecimal64(1/0, 1); -- { serverError 407 }\n-SELECT toDecimal128(0/0, 2); -- { serverError 407 }\n-SELECT CAST(1/0, 'Decimal(9, 0)'); -- { serverError 407 }\n-SELECT CAST(1/0, 'Decimal(18, 1)'); -- { serverError 407 }\n-SELECT CAST(1/0, 'Decimal(38, 2)'); -- { serverError 407 }\n-SELECT CAST(0/0, 'Decimal(9, 3)'); -- { serverError 407 }\n-SELECT CAST(0/0, 'Decimal(18, 4)'); -- { serverError 407 }\n-SELECT CAST(0/0, 'Decimal(38, 5)'); -- { serverError 407 }\n-\n-select toDecimal32(10000.1, 6); -- { serverError 407 }\n-select toDecimal64(10000.1, 18); -- { serverError 407 }\n-select toDecimal128(1000000000000000000000.1, 18); -- { serverError 407 }\n-\n-select toDecimal32(-10000.1, 6); -- { serverError 407 }\n-select toDecimal64(-10000.1, 18); -- { serverError 407 }\n-select toDecimal128(-1000000000000000000000.1, 18); -- { serverError 407 }\n-\n-select toDecimal32(2147483647.0 + 1.0, 0); -- { serverError 407 }\n-select toDecimal64(9223372036854775807.0, 0); -- { serverError 407 }\n-select toDecimal128(170141183460469231731687303715884105729.0, 0); -- { serverError 407 }\n-\n-select toDecimal32(-2147483647.0 - 1.0, 0); -- { serverError 407 }\n-select toDecimal64(-9223372036854775807.0, 0); -- { serverError 407 }\n-select toDecimal128(-170141183460469231731687303715884105729.0, 0); -- { serverError 407 }\ndiff --git a/tests/queries/0_stateless/00700_decimal_casts_2.reference b/tests/queries/0_stateless/00700_decimal_casts_2.reference\nnew file mode 100644\nindex 000000000000..393baae6c476\n--- /dev/null\n+++ b/tests/queries/0_stateless/00700_decimal_casts_2.reference\n@@ -0,0 +1,37 @@\n+1234567890.0000000000000000000000000000\t1234567890.00000000000000000000000000000\t1234567890.00000000000000000000000000000\n+-126561577.683753853853498429727072845824\n+1234567890.00000000\t1234567890.000000000\t1234567890.000000000\n+12345678.0\t12345678.00\t12345678.00\n+9223372036854775807.000000\t9223372036854775807\t-9223372036854775807\n+9223372036854775800\t9223372036854775800\t-9223372036854775800\n+92233720368547758.00\t92233720368547758\t-92233720368547758\n+2147483647.0000000000\t2147483647\t-2147483647\n+2147483647.00\t2147483647\t-2147483647\n+92233720368547757.99\t92233720368547757\t-92233720368547757\n+2147483640.99\t2147483640\t-2147483640\n+-0.90000000\t0\n+-0.90000000\t0\n+-0.90000000\t0\n+-0.8000\t0\n+-0.8000\t0\n+-0.8000\t0\n+-0.70\t0\n+-0.70\t0\n+-0.70\t0\n+-0.600000\t0\n+-0.600000\t0\n+-0.600000\t0\n+18446744073709551615\t18446744073709551615\n+18446744073709551615.00000000\t18446744073709551615\n+4294967295\t4294967295\n+4294967295.0000000000\t4294967295\n+4294967295\t4294967295\n+4294967295.0000\t4294967295\n+65535\t65535\n+65535.0000000000\t65535\n+65535\t65535\n+65535.0000\t65535\n+2147483647\t2147483647\n+-2147483647\t-2147483647\n+2147483647\t2147483647\n+9223372036854775807\t9223372036854775807\ndiff --git a/tests/queries/0_stateless/00700_decimal_casts_2.sql b/tests/queries/0_stateless/00700_decimal_casts_2.sql\nnew file mode 100644\nindex 000000000000..89c95fed2713\n--- /dev/null\n+++ b/tests/queries/0_stateless/00700_decimal_casts_2.sql\n@@ -0,0 +1,119 @@\n+SELECT toDecimal128('1234567890', 28) AS x, toDecimal128(x, 29), toDecimal128(toDecimal128('1234567890', 28), 29);\n+SELECT toDecimal128(toDecimal128('1234567890', 28), 30);\n+\n+SELECT toDecimal64('1234567890', 8) AS x, toDecimal64(x, 9), toDecimal64(toDecimal64('1234567890', 8), 9);\n+SELECT toDecimal64(toDecimal64('1234567890', 8), 10); -- { serverError 407 }\n+\n+SELECT toDecimal32('12345678', 1) AS x, toDecimal32(x, 2), toDecimal32(toDecimal32('12345678', 1), 2);\n+SELECT toDecimal32(toDecimal32('12345678', 1), 3); -- { serverError 407 }\n+\n+SELECT toDecimal64(toDecimal64('92233720368547758.1', 1), 2); -- { serverError 407 }\n+SELECT toDecimal64(toDecimal64('-92233720368547758.1', 1), 2); -- { serverError 407 }\n+\n+SELECT toDecimal128('9223372036854775807', 6) AS x, toInt64(x), toInt64(-x);\n+SELECT toDecimal128('9223372036854775809', 6) AS x, toInt64(x); -- { serverError 407 }\n+SELECT toDecimal128('9223372036854775809', 6) AS x, toInt64(-x); -- { serverError 407 }\n+SELECT toDecimal64('922337203685477580', 0) * 10 AS x, toInt64(x), toInt64(-x);\n+SELECT toDecimal64(toDecimal64('92233720368547758.0', 1), 2) AS x, toInt64(x), toInt64(-x);\n+\n+SELECT toDecimal128('2147483647', 10) AS x, toInt32(x), toInt32(-x);\n+SELECT toDecimal128('2147483649', 10) AS x, toInt32(x), toInt32(-x); -- { serverError 407 }\n+SELECT toDecimal64('2147483647', 2) AS x, toInt32(x), toInt32(-x);\n+SELECT toDecimal64('2147483649', 2) AS x, toInt32(x), toInt32(-x); -- { serverError 407 }\n+\n+SELECT toDecimal128('92233720368547757.99', 2) AS x, toInt64(x), toInt64(-x);\n+SELECT toDecimal64('2147483640.99', 2) AS x, toInt32(x), toInt32(-x);\n+\n+SELECT toDecimal128('-0.9', 8) AS x, toUInt64(x);\n+SELECT toDecimal64('-0.9', 8) AS x, toUInt64(x);\n+SELECT toDecimal32('-0.9', 8) AS x, toUInt64(x);\n+\n+SELECT toDecimal128('-0.8', 4) AS x, toUInt32(x);\n+SELECT toDecimal64('-0.8', 4) AS x, toUInt32(x);\n+SELECT toDecimal32('-0.8', 4) AS x, toUInt32(x);\n+\n+SELECT toDecimal128('-0.7', 2) AS x, toUInt16(x);\n+SELECT toDecimal64('-0.7', 2) AS x, toUInt16(x);\n+SELECT toDecimal32('-0.7', 2) AS x, toUInt16(x);\n+\n+SELECT toDecimal128('-0.6', 6) AS x, toUInt8(x);\n+SELECT toDecimal64('-0.6', 6) AS x, toUInt8(x);\n+SELECT toDecimal32('-0.6', 6) AS x, toUInt8(x);\n+\n+SELECT toDecimal128('-1', 7) AS x, toUInt64(x); -- { serverError 407 }\n+SELECT toDecimal128('-1', 7) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal128('-1', 7) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal128('-1', 7) AS x, toUInt8(x); -- { serverError 407 }\n+\n+SELECT toDecimal64('-1', 5) AS x, toUInt64(x); -- { serverError 407 }\n+SELECT toDecimal64('-1', 5) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal64('-1', 5) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal64('-1', 5) AS x, toUInt8(x); -- { serverError 407 }\n+\n+SELECT toDecimal32('-1', 3) AS x, toUInt64(x); -- { serverError 407 }\n+SELECT toDecimal32('-1', 3) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal32('-1', 3) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal32('-1', 3) AS x, toUInt8(x); -- { serverError 407 }\n+\n+SELECT toDecimal128('18446744073709551615', 0) AS x, toUInt64(x);\n+SELECT toDecimal128('18446744073709551616', 0) AS x, toUInt64(x); -- { serverError 407 }\n+SELECT toDecimal128('18446744073709551615', 8) AS x, toUInt64(x);\n+SELECT toDecimal128('18446744073709551616', 8) AS x, toUInt64(x); -- { serverError 407 }\n+\n+SELECT toDecimal128('4294967295', 0) AS x, toUInt32(x);\n+SELECT toDecimal128('4294967296', 0) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal128('4294967295', 10) AS x, toUInt32(x);\n+SELECT toDecimal128('4294967296', 10) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal64('4294967295', 0) AS x, toUInt32(x);\n+SELECT toDecimal64('4294967296', 0) AS x, toUInt32(x); -- { serverError 407 }\n+SELECT toDecimal64('4294967295', 4) AS x, toUInt32(x);\n+SELECT toDecimal64('4294967296', 4) AS x, toUInt32(x); -- { serverError 407 }\n+\n+SELECT toDecimal128('65535', 0) AS x, toUInt16(x);\n+SELECT toDecimal128('65536', 0) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal128('65535', 10) AS x, toUInt16(x);\n+SELECT toDecimal128('65536', 10) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal64('65535', 0) AS x, toUInt16(x);\n+SELECT toDecimal64('65536', 0) AS x, toUInt16(x); -- { serverError 407 }\n+SELECT toDecimal64('65535', 4) AS x, toUInt16(x);\n+SELECT toDecimal64('65536', 4) AS x, toUInt16(x); -- { serverError 407 }\n+\n+SELECT toInt64('2147483647') AS x, toDecimal32(x, 0);\n+SELECT toInt64('-2147483647') AS x, toDecimal32(x, 0);\n+SELECT toUInt64('2147483647') AS x, toDecimal32(x, 0);\n+SELECT toInt64('2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n+SELECT toInt64('-2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n+SELECT toUInt64('2147483649') AS x, toDecimal32(x, 0); -- { serverError 407 }\n+\n+SELECT toUInt64('9223372036854775807') AS x, toDecimal64(x, 0);\n+SELECT toUInt64('9223372036854775809') AS x, toDecimal64(x, 0); -- { serverError 407 }\n+\n+SELECT toDecimal32(0, rowNumberInBlock()); -- { serverError 44 }\n+SELECT toDecimal64(0, rowNumberInBlock()); -- { serverError 44 }\n+SELECT toDecimal128(0, rowNumberInBlock()); -- { serverError 44 }\n+\n+SELECT toDecimal32(1/0, 0); -- { serverError 407 }\n+SELECT toDecimal64(1/0, 1); -- { serverError 407 }\n+SELECT toDecimal128(0/0, 2); -- { serverError 407 }\n+SELECT CAST(1/0, 'Decimal(9, 0)'); -- { serverError 407 }\n+SELECT CAST(1/0, 'Decimal(18, 1)'); -- { serverError 407 }\n+SELECT CAST(1/0, 'Decimal(38, 2)'); -- { serverError 407 }\n+SELECT CAST(0/0, 'Decimal(9, 3)'); -- { serverError 407 }\n+SELECT CAST(0/0, 'Decimal(18, 4)'); -- { serverError 407 }\n+SELECT CAST(0/0, 'Decimal(38, 5)'); -- { serverError 407 }\n+\n+select toDecimal32(10000.1, 6); -- { serverError 407 }\n+select toDecimal64(10000.1, 18); -- { serverError 407 }\n+select toDecimal128(1000000000000000000000.1, 18); -- { serverError 407 }\n+\n+select toDecimal32(-10000.1, 6); -- { serverError 407 }\n+select toDecimal64(-10000.1, 18); -- { serverError 407 }\n+select toDecimal128(-1000000000000000000000.1, 18); -- { serverError 407 }\n+\n+select toDecimal32(2147483647.0 + 1.0, 0); -- { serverError 407 }\n+select toDecimal64(9223372036854775807.0, 0); -- { serverError 407 }\n+select toDecimal128(170141183460469231731687303715884105729.0, 0); -- { serverError 407 }\n+\n+select toDecimal32(-2147483647.0 - 1.0, 0); -- { serverError 407 }\n+select toDecimal64(-9223372036854775807.0, 0); -- { serverError 407 }\n+select toDecimal128(-170141183460469231731687303715884105729.0, 0); -- { serverError 407 }\ndiff --git a/tests/queries/0_stateless/00700_decimal_math.reference b/tests/queries/0_stateless/00700_decimal_math.reference\nindex 889170047021..f58e08dc1fb2 100644\n--- a/tests/queries/0_stateless/00700_decimal_math.reference\n+++ b/tests/queries/0_stateless/00700_decimal_math.reference\n@@ -26,5 +26,5 @@\n 1.00000\t0.8427007929497149\t0.15729920705028513\n 42.4200\t115.60113124678627\t1.6029995567009473e50\n 0.00\t0\t1\t0\n-3.1415926535897927981986333033020522496\t0\t-1\t-0\n+3.14159265358979\t0\t-1\t-0\n 1.00\t1.5707963267948966\t0\t0.7853981633974483\ndiff --git a/tests/queries/0_stateless/00700_decimal_math.sql b/tests/queries/0_stateless/00700_decimal_math.sql\nindex a6c1ab2f393f..237bee1c6918 100644\n--- a/tests/queries/0_stateless/00700_decimal_math.sql\n+++ b/tests/queries/0_stateless/00700_decimal_math.sql\n@@ -36,7 +36,7 @@ SELECT toDecimal128('1.0', 5) AS x, erf(x), erfc(x);\n SELECT toDecimal128('42.42', 4) AS x, lgamma(x), tgamma(x);\n \n SELECT toDecimal128('0.0', 2) AS x, round(sin(x), 8), round(cos(x), 8), round(tan(x), 8);\n-SELECT toDecimal128(pi(), 37) AS x, round(sin(x), 8), round(cos(x), 8), round(tan(x), 8);\n+SELECT toDecimal128(pi(), 14) AS x, round(sin(x), 8), round(cos(x), 8), round(tan(x), 8);\n SELECT toDecimal128('1.0', 2) AS x, asin(x), acos(x), atan(x);\n \n \ndiff --git a/tests/queries/0_stateless/00700_decimal_round.reference b/tests/queries/0_stateless/00700_decimal_round.reference\nindex 11281cdeeb67..230b6863411f 100644\n--- a/tests/queries/0_stateless/00700_decimal_round.reference\n+++ b/tests/queries/0_stateless/00700_decimal_round.reference\n@@ -58,18 +58,18 @@\n -12345.6789\t-12340.0000\t-12300.0000\t-12000.0000\t-10000.0000\t0.0000\n -12345.6789\t-12350.0000\t-12400.0000\t-13000.0000\t-20000.0000\t-100000.0000\n -12345.6789\t-12340.0000\t-12300.0000\t-12000.0000\t-10000.0000\t0.0000\n-123456789.123456784\t-123456789.123456784\t123456789.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123460000\t123500000.000000000\t-123500000.000000000\n-123456789.123456784\t-123456789.123456784\t123456789.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123460000\t123500000.000000000\t-123500000.000000000\n-123456789.123456784\t-123456789.123456784\t123456790.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123450000\t123500000.000000000\t-123400000.000000000\n-123456789.123456784\t-123456789.123456784\t123456789.000000000\t-123456790.000000000\t123456789.123450000\t-123456789.123460000\t123400000.000000000\t-123500000.000000000\n-123456789.123456784\t-123456789.123456784\t123456789.000000000\t-123456789.000000000\t123456789.123450000\t-123456789.123450000\t123400000.000000000\t-123400000.000000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491324606.797000000\t-12345678901234567525491324606.797000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491324606.797000000\t-12345678901234567525491324606.797000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324606.000000000\t12345678901234567525491324606.798000000\t-12345678901234567525491324606.797000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324606.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491324606.797000000\t-12345678901234567525491324606.798000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324606.000000000\t-12345678901234567525491324606.000000000\t12345678901234567525491324606.797000000\t-12345678901234567525491324606.797000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491325000.000000000\t-12345678901234567525491325000.000000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491325000.000000000\t-12345678901234567525491325000.000000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324607.000000000\t-12345678901234567525491324606.000000000\t12345678901234567525491325000.000000000\t-12345678901234567525491324000.000000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324606.000000000\t-12345678901234567525491324607.000000000\t12345678901234567525491324000.000000000\t-12345678901234567525491325000.000000000\n-12345678901234567525491324606.797053952\t-12345678901234567525491324606.797053952\t12345678901234567525491324606.000000000\t-12345678901234567525491324606.000000000\t12345678901234567525491324000.000000000\t-12345678901234567525491324000.000000000\n+123456789.123456789\t-123456789.123456789\t123456789.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123460000\t123500000.000000000\t-123500000.000000000\n+123456789.123456789\t-123456789.123456789\t123456789.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123460000\t123500000.000000000\t-123500000.000000000\n+123456789.123456789\t-123456789.123456789\t123456790.000000000\t-123456789.000000000\t123456789.123460000\t-123456789.123450000\t123500000.000000000\t-123400000.000000000\n+123456789.123456789\t-123456789.123456789\t123456789.000000000\t-123456790.000000000\t123456789.123450000\t-123456789.123460000\t123400000.000000000\t-123500000.000000000\n+123456789.123456789\t-123456789.123456789\t123456789.000000000\t-123456789.000000000\t123456789.123450000\t-123456789.123450000\t123400000.000000000\t-123400000.000000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123456789.123000000\t-12345678901234567890123456789.123000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123456789.123000000\t-12345678901234567890123456789.123000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456790.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123456789.124000000\t-12345678901234567890123456789.123000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456790.000000000\t12345678901234567890123456789.123000000\t-12345678901234567890123456789.124000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123456789.123000000\t-12345678901234567890123456789.123000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123457000.000000000\t-12345678901234567890123457000.000000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123457000.000000000\t-12345678901234567890123457000.000000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456790.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123457000.000000000\t-12345678901234567890123456000.000000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456790.000000000\t12345678901234567890123456000.000000000\t-12345678901234567890123457000.000000000\n+12345678901234567890123456789.123456789\t-12345678901234567890123456789.123456789\t12345678901234567890123456789.000000000\t-12345678901234567890123456789.000000000\t12345678901234567890123456000.000000000\t-12345678901234567890123456000.000000000\ndiff --git a/tests/queries/0_stateless/00700_decimal_round.sql b/tests/queries/0_stateless/00700_decimal_round.sql\nindex 318a7718de9f..c5b8dbb520bf 100644\n--- a/tests/queries/0_stateless/00700_decimal_round.sql\n+++ b/tests/queries/0_stateless/00700_decimal_round.sql\n@@ -61,20 +61,20 @@ SELECT toDecimal128(-12345.6789, 4) AS x, ceil(x, -1), ceil(x, -2), ceil(x, -3),\n SELECT toDecimal128(-12345.6789, 4) AS x, floor(x, -1), floor(x, -2), floor(x, -3), floor(x, -4), floor(x, -5);\n SELECT toDecimal128(-12345.6789, 4) AS x, trunc(x, -1), trunc(x, -2), trunc(x, -3), trunc(x, -4), trunc(x, -5);\n \n-SELECT toDecimal64(123456789.123456789, 9) AS x, -x AS y, round(x), round(y), round(x, 5), round(y, 5), round(x, -5), round(y, -5);\n-SELECT toDecimal64(123456789.123456789, 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, 5), roundBankers(y, 5), roundBankers(x, -5), roundBankers(y, -5);\n-SELECT toDecimal64(123456789.123456789, 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, 5), ceil(y, 5), ceil(x, -5), ceil(y, -5);\n-SELECT toDecimal64(123456789.123456789, 9) AS x, -x AS y, floor(x), floor(y), floor(x, 5), floor(y, 5), floor(x, -5), floor(y, -5);\n-SELECT toDecimal64(123456789.123456789, 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, 5), trunc(y, 5), trunc(x, -5), trunc(y, -5);\n+SELECT toDecimal64('123456789.123456789', 9) AS x, -x AS y, round(x), round(y), round(x, 5), round(y, 5), round(x, -5), round(y, -5);\n+SELECT toDecimal64('123456789.123456789', 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, 5), roundBankers(y, 5), roundBankers(x, -5), roundBankers(y, -5);\n+SELECT toDecimal64('123456789.123456789', 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, 5), ceil(y, 5), ceil(x, -5), ceil(y, -5);\n+SELECT toDecimal64('123456789.123456789', 9) AS x, -x AS y, floor(x), floor(y), floor(x, 5), floor(y, 5), floor(x, -5), floor(y, -5);\n+SELECT toDecimal64('123456789.123456789', 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, 5), trunc(y, 5), trunc(x, -5), trunc(y, -5);\n \n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, round(x), round(y), round(x, 3), round(y, 3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, 3), roundBankers(y, 3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, 3), ceil(y, 3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, floor(x), floor(y), floor(x, 3), floor(y, 3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, 3), trunc(y, 3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, round(x), round(y), round(x, 3), round(y, 3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, 3), roundBankers(y, 3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, 3), ceil(y, 3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, floor(x), floor(y), floor(x, 3), floor(y, 3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, 3), trunc(y, 3);\n \n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, round(x), round(y), round(x, -3), round(y, -3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, -3), roundBankers(y, -3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, -3), ceil(y, -3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, floor(x), floor(y), floor(x, -3), floor(y, -3);\n-SELECT toDecimal128(12345678901234567890123456789.123456789, 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, -3), trunc(y, -3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, round(x), round(y), round(x, -3), round(y, -3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, roundBankers(x), roundBankers(y), roundBankers(x, -3), roundBankers(y, -3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, ceil(x), ceil(y), ceil(x, -3), ceil(y, -3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, floor(x), floor(y), floor(x, -3), floor(y, -3);\n+SELECT toDecimal128('12345678901234567890123456789.123456789', 9) AS x, -x AS y, trunc(x), trunc(y), trunc(x, -3), trunc(y, -3);\ndiff --git a/tests/queries/0_stateless/01035_avg.reference b/tests/queries/0_stateless/01035_avg.reference\nindex ec79205c6f8a..a9f31de57e11 100644\n--- a/tests/queries/0_stateless/01035_avg.reference\n+++ b/tests/queries/0_stateless/01035_avg.reference\n@@ -1,5 +1,5 @@\n-nan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\n--0.5\t-0.5\t-0.5\t-0.5\t-0.5\t-0.5\t127.493856\t32355.57552\t499999.5\t499999.5\t499999.5\t499999.5\t499999.5\t-0.000500002\t0.49999949943727\t-0.000005\t-0.000005257366687274546\n+nan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\n+-0.5\t-0.5\t-0.5\t-0.5\t-0.5\t-0.5\t127.493856\t32355.57552\t499999.5\t499999.5\t499999.5\t499999.5\t499999.5\t499999.5\t-0.000500002\t0.49999949943727\t-0.000005026740899901579\t-0.000005257366687274546\n -2767.546272\n 999999\n--0.50000449943727\n+-0.5000045261781699\ndiff --git a/tests/queries/0_stateless/01035_avg.sql b/tests/queries/0_stateless/01035_avg.sql\nindex a185ce816fb3..7ad083739172 100644\n--- a/tests/queries/0_stateless/01035_avg.sql\n+++ b/tests/queries/0_stateless/01035_avg.sql\n@@ -1,6 +1,5 @@\n SET allow_experimental_bigint_types=1;\n \n--- no UInt128 as for now\n CREATE TABLE IF NOT EXISTS test_01035_avg (\n     i8 Int8         DEFAULT i64,\n     i16 Int16       DEFAULT i64,\n@@ -13,6 +12,7 @@ CREATE TABLE IF NOT EXISTS test_01035_avg (\n     u16 UInt16      DEFAULT u64,\n     u32 UInt32      DEFAULT u64,\n     u64 UInt64,\n+    u128 UInt128    DEFAULT u64,\n     u256 UInt256    DEFAULT u64,\n \n     f32 Float32     DEFAULT u64,\n@@ -25,14 +25,14 @@ CREATE TABLE IF NOT EXISTS test_01035_avg (\n ) ENGINE = MergeTree() ORDER BY i64;\n \n SELECT avg(i8), avg(i16), avg(i32), avg(i64), avg(i128), avg(i256),\n-       avg(u8), avg(u16), avg(u32), avg(u64), avg(u256),\n+       avg(u8), avg(u16), avg(u32), avg(u64), avg(u128), avg(u256),\n        avg(f32), avg(f64),\n        avg(d32), avg(d64), avg(d128), avg(d256) FROM test_01035_avg;\n \n INSERT INTO test_01035_avg (u64) SELECT number FROM system.numbers LIMIT 1000000;\n \n SELECT avg(i8), avg(i16), avg(i32), avg(i64), avg(i128), avg(i256),\n-       avg(u8), avg(u16), avg(u32), avg(u64), avg(u256),\n+       avg(u8), avg(u16), avg(u32), avg(u64), avg(u128), avg(u256),\n        avg(f32), avg(f64),\n        avg(d32), avg(d64), avg(d128), avg(d256) FROM test_01035_avg;\n \ndiff --git a/tests/queries/0_stateless/01087_table_function_generate.reference b/tests/queries/0_stateless/01087_table_function_generate.reference\nindex d8886945caa3..c04fa831328b 100644\n--- a/tests/queries/0_stateless/01087_table_function_generate.reference\n+++ b/tests/queries/0_stateless/01087_table_function_generate.reference\n@@ -1,14 +1,14 @@\n UInt64\tInt64\tUInt32\tInt32\tUInt16\tInt16\tUInt8\tInt8\n-2804162938822577320\t-2776833771540858\t3467776823\t1163715250\t23903\t-2916\t220\t-117\n-7885388429666205427\t-1363628932535403038\t484159052\t-308788249\t44305\t13638\t143\t-105\n-4357435422797280898\t1355609803008819271\t4126129912\t-852056475\t58858\t9166\t49\t33\n-5935810273536892891\t-804738887697332962\t3109335413\t-80126721\t13655\t-31421\t186\t-77\n-368066018677693974\t-4927165984347126295\t1015254922\t2026080544\t21973\t-29626\t240\t108\n-8124171311239967992\t-1179703908046100129\t1720727300\t-138469036\t36175\t-12819\t138\t16\n-15657812979985370729\t-5733276247123822513\t3254757884\t-500590428\t13193\t30527\t3\t-81\n-18371568619324220532\t-6793779541583578394\t1686821450\t-455892108\t52282\t2284\t252\t-90\n-821735343441964030\t3148260644406230976\t256251035\t-885069056\t55255\t11455\t176\t90\n-9558594037060121162\t-2907172753635797124\t4276198376\t1947296644\t48701\t26632\t97\t43\n+2804162938822577320\t-2776833771540858\t3467776823\t1163715250\t23903\t13655\t137\t-41\n+7885388429666205427\t-1363628932535403038\t484159052\t-308788249\t56810\t-22227\t51\t-41\n+4357435422797280898\t1355609803008819271\t4126129912\t-852056475\t64304\t-11401\t139\t86\n+5935810273536892891\t-804738887697332962\t3109335413\t-80126721\t258\t12889\t18\t88\n+368066018677693974\t-4927165984347126295\t1015254922\t2026080544\t44305\t21973\t16\t0\n+8124171311239967992\t-1179703908046100129\t1720727300\t-138469036\t61343\t10573\t252\t-32\n+15657812979985370729\t-5733276247123822513\t3254757884\t-500590428\t45913\t19153\t105\t-102\n+18371568619324220532\t-6793779541583578394\t1686821450\t-455892108\t49050\t-28603\t248\t80\n+821735343441964030\t3148260644406230976\t256251035\t-885069056\t58858\t-29361\t58\t61\n+9558594037060121162\t-2907172753635797124\t4276198376\t1947296644\t26801\t-13531\t204\t-66\n -\n Enum8(\\'hello\\' = 1, \\'world\\' = 5)\n hello\n@@ -47,16 +47,16 @@ h\n o\n -\n Date\tDateTime\tDateTime(\\'Europe/Moscow\\')\n-2113-06-12\t1970-10-09 02:30:14\t2074-08-12 11:31:27\n-2103-11-03\t2106-01-30 21:52:44\t2097-05-25 07:54:35\n-2008-03-16\t2096-12-12 00:40:50\t1988-08-10 11:16:31\n-2126-11-26\t2096-01-15 16:31:33\t2063-10-20 08:48:17\n-1991-02-02\t2103-02-11 16:44:39\t2036-10-09 04:29:10\n-2096-11-03\t1980-01-02 05:18:22\t2055-12-23 12:33:52\n-2024-12-16\t2079-06-11 16:29:02\t2000-12-05 17:46:24\n-2085-04-07\t2100-03-01 18:50:22\t1993-03-25 01:19:12\n-2135-05-30\t2034-08-25 19:46:33\t2045-12-10 16:47:40\n-2094-12-18\t2069-09-30 16:07:48\t2084-08-26 03:33:12\n+2113-06-12\t2050-12-17 02:46:35\t2096-02-16 22:18:22\n+2141-08-09\t2013-10-17 23:35:26\t1976-01-24 12:52:48\n+2039-08-16\t1974-11-17 23:22:46\t1980-03-04 21:02:50\n+1997-04-11\t1972-09-18 23:44:08\t2040-07-10 14:46:42\n+2103-11-03\t2044-11-23 20:57:12\t1970-10-09 02:30:14\n+2066-11-19\t2029-12-10 03:13:55\t2106-01-30 21:52:44\n+2064-08-14\t2016-07-14 11:33:45\t2096-12-12 00:40:50\n+2046-09-13\t2085-07-10 18:51:14\t2096-01-15 16:31:33\n+2008-03-16\t2047-05-16 23:28:36\t2103-02-11 16:44:39\n+2000-07-07\t2105-07-19 19:29:06\t1980-01-02 05:18:22\n -\n DateTime64(3)\tDateTime64(6)\tDateTime64(6, \\'Europe/Moscow\\')\n 1978-06-07 23:50:57.320\t2013-08-28 10:21:54.010758\t1991-08-25 16:23:26.140215\n@@ -225,14 +225,14 @@ RL,{Xs\\\\tw\n [114]\t-84125.1554\t('2023-06-06 06:55:06.492','bf9ab359-ef9f-ad11-7e6c-160368b1e5ea')\n [124]\t-114719.5228\t('2010-11-11 22:57:23.722','c1046ffb-3415-cc3a-509a-e0005856d7d7')\n -\n-[]\t1900051923\t{\t-189530.5846\th\t-5.6279699579452485e47\t('1984-12-06','2090-10-31 19:35:45','2038-07-15 05:22:51.805','63d9a12d-d1cf-1f3a-57c6-9bc6dddd0975')\t8502\n-[-102,-118]\t392272782\tEb\t-14818.0200\to\t-2.664492247169164e59\t('2024-01-16','1994-07-16 00:40:02','2034-02-02 05:30:44.960','4fa09948-d32e-8903-63df-43ad759e43f7')\tDA61\n-[-71]\t775049089\t\\N\t-158115.1178\tw\t4.1323844687113747e-305\t('2103-08-04','2062-08-12 23:41:53','2074-02-13 10:29:40.749','c4a44dd7-d009-6f65-1494-9daedfa8a124')\t83A7\n-[-28,100]\t3675466147\t{\t-146685.1749\th\t3.6676044396877755e142\t('2119-02-01','2002-06-26 03:33:41','2002-12-02 05:46:03.455','98714b2c-65e7-b5cb-a040-421e260c6d8d')\t4B94\n-[-23]\t2514120753\t(`u,\t-119659.6174\tw\t1.3231258347475906e34\t('2017-10-25','2080-03-28 08:11:25','2073-07-10 12:19:58.146','003b3b6b-088f-f941-aeb9-c26e0ee72b8e')\t6B1F\n-[11,-36]\t3308237300\t\\N\t171205.1896\t\\N\t5.634708707075817e195\t('2084-01-01','2041-11-11 13:19:44','2044-03-18 17:34:17.814','9e60f4cb-6e55-1deb-5ac4-d66a86a8886d')\t1964\n-[39]\t1614362420\t`4A8P\t157144.0630\to\t-1.1843143253872814e-255\t('2061-03-10','2066-03-02 11:07:49','1997-10-22 20:14:13.755','97685503-2609-d2b9-981c-02fd75d106cb')\tA35B\n-[48,-120]\t3848918261\t1<Lu3\t91487.2852\th\t-1.9300793134783347e263\t('2081-06-01','2031-08-07 11:29:42','2085-03-11 15:17:17.374','af838873-48b2-f609-6483-f5c08733364c')\t8E7C\n-[55]\t3047524030\tli&lF\t93462.3661\th\t2.8979254388809897e54\t('2108-04-19','2058-07-14 01:47:30','2055-10-14 06:36:20.056','e932a7b5-173a-1304-e522-b794b8fa3f11')\t35D9\n-[100,-42]\t3999367674\t\t-112975.9852\th\t2.658098863752086e-160\t('2005-08-26','2029-04-21 12:27:59','2068-08-27 07:49:41.825','802b2a96-319b-8e60-63d9-99b88ccae237')\t074E\n+[]\t1900051923\t{\t-189530.5846\th\t-5.6279699579452485e47\t('1984-12-06','2028-08-17 06:05:01','2036-04-02 23:52:28.468','4b3d498c-dd44-95c1-5b75-921504ec5d8d')\tF743\n+[-102,-118]\t392272782\tEb\t-14818.0200\to\t-2.664492247169164e59\t('2082-12-26','2052-09-09 06:50:50','2088-04-21 05:07:08.245','aeb9c26e-0ee7-2b8e-802b-2a96319b8e60')\tCBF4\n+[-71]\t775049089\t\\N\t-158115.1178\tw\t4.1323844687113747e-305\t('2108-04-19','2090-07-31 16:45:26','2076-07-10 09:11:06.385','57c69bc6-dddd-0975-e932-a7b5173a1304')\tEB1D\n+[-28,100]\t3675466147\t{\t-146685.1749\th\t3.6676044396877755e142\t('2017-10-25','2100-02-28 18:07:18','2055-10-14 06:36:20.056','14949dae-dfa8-a124-af83-887348b2f609')\t6D88\n+[-23]\t2514120753\t(`u,\t-119659.6174\tw\t1.3231258347475906e34\t('2141-04-06','2074-08-10 06:25:12','1976-12-04 18:31:55.745','86a9b3c1-4593-4d56-7762-3aa1dd22cbbf')\tAD43\n+[11,-36]\t3308237300\t\\N\t171205.1896\t\\N\t5.634708707075817e195\t('1974-10-31','1993-12-24 09:38:45','2038-07-15 05:22:51.805','63d999b8-8cca-e237-c4a4-4dd7d0096f65')\t609E\n+[39]\t1614362420\t`4A8P\t157144.0630\to\t-1.1843143253872814e-255\t('2147-08-18','2072-09-28 18:27:27','2073-07-10 12:19:58.146','6483f5c0-8733-364c-4fa0-9948d32e8903')\tA886\n+[48,-120]\t3848918261\t1<Lu3\t91487.2852\th\t-1.9300793134783347e263\t('2050-12-04','2076-04-05 09:33:05','2103-12-13 23:48:44.066','e522b794-b8fa-3f11-003b-3b6b088ff941')\t556E\n+[55]\t3047524030\tli&lF\t93462.3661\th\t2.8979254388809897e54\t('1976-01-10','1987-07-14 00:25:51','2021-11-19 04:44:08.986','486e5b26-5fe8-fe3e-12ef-09aee40643e0')\t9E75\n+[100,-42]\t3999367674\t\t-112975.9852\th\t2.658098863752086e-160\t('2081-05-13','2071-08-07 13:34:33','1980-11-11 12:00:44.669','9754e8ac-5145-befb-63d9-a12dd1cf1f3a')\tDF63\n -\ndiff --git a/tests/queries/0_stateless/01125_generate_random_qoega.reference b/tests/queries/0_stateless/01125_generate_random_qoega.reference\nindex af3f8c998962..22bc4946401e 100644\n--- a/tests/queries/0_stateless/01125_generate_random_qoega.reference\n+++ b/tests/queries/0_stateless/01125_generate_random_qoega.reference\n@@ -1,1 +1,1 @@\n-100\t663736399314727673\n+100\t9702509002514908721\ndiff --git a/tests/queries/0_stateless/01128_generate_random_nested.reference b/tests/queries/0_stateless/01128_generate_random_nested.reference\nindex 6d2e90d81935..12701aed1ab1 100644\n--- a/tests/queries/0_stateless/01128_generate_random_nested.reference\n+++ b/tests/queries/0_stateless/01128_generate_random_nested.reference\n@@ -1,2 +1,2 @@\n-100\t12122376849981951205\n-109\t6180823897498688294\n+100\t8533268631048830017\n+99\t923254289621389072\ndiff --git a/tests/queries/0_stateless/01666_gcd_ubsan.reference b/tests/queries/0_stateless/01666_gcd_ubsan.reference\nindex af041bdcbdea..37b1968542e1 100644\n--- a/tests/queries/0_stateless/01666_gcd_ubsan.reference\n+++ b/tests/queries/0_stateless/01666_gcd_ubsan.reference\n@@ -5,8 +5,10 @@ SELECT gcd(-9223372036854775808, 9223372036854775807); -- { serverError 407 }\n SELECT gcd(-9223372036854775807, 9223372036854775808); -- { serverError 407 }\n SELECT gcd(9223372036854775808, -1); -- { serverError 407 }\n SELECT lcm(-170141183460469231731687303715884105728, -170141183460469231731687303715884105728); -- { serverError 43 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728)); -- { serverError 407 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720)); -- { serverError 407 }\n+SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728));\n+170141183460469231722463931679029329921\n+SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720));\n+170141183460469231722463931679029329921\n SELECT lcm(toInt128('-170141183460469231731687303715884105720'), toInt128('-170141183460469231731687303715884105720'));\n 170141183460469231731687303715884105720\n SELECT gcd(-9223372036854775806, -9223372036854775806);\ndiff --git a/tests/queries/0_stateless/01666_gcd_ubsan.sql b/tests/queries/0_stateless/01666_gcd_ubsan.sql\nindex a1f501cda0b1..da41022ddebe 100644\n--- a/tests/queries/0_stateless/01666_gcd_ubsan.sql\n+++ b/tests/queries/0_stateless/01666_gcd_ubsan.sql\n@@ -5,7 +5,7 @@ SELECT gcd(-9223372036854775808, 9223372036854775807); -- { serverError 407 }\n SELECT gcd(-9223372036854775807, 9223372036854775808); -- { serverError 407 }\n SELECT gcd(9223372036854775808, -1); -- { serverError 407 }\n SELECT lcm(-170141183460469231731687303715884105728, -170141183460469231731687303715884105728); -- { serverError 43 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728)); -- { serverError 407 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720)); -- { serverError 407 }\n+SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728));\n+SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720));\n SELECT lcm(toInt128('-170141183460469231731687303715884105720'), toInt128('-170141183460469231731687303715884105720'));\n SELECT gcd(-9223372036854775806, -9223372036854775806);\ndiff --git a/tests/queries/0_stateless/01666_lcm_ubsan.reference b/tests/queries/0_stateless/01666_lcm_ubsan.reference\nindex d8ed13191d33..bd1972e8a6d6 100644\n--- a/tests/queries/0_stateless/01666_lcm_ubsan.reference\n+++ b/tests/queries/0_stateless/01666_lcm_ubsan.reference\n@@ -5,8 +5,10 @@ SELECT lcm(-9223372036854775808, 9223372036854775807); -- { serverError 407 }\n SELECT lcm(-9223372036854775807, 9223372036854775808); -- { serverError 407 }\n SELECT lcm(9223372036854775808, -1); -- { serverError 407 }\n SELECT lcm(-170141183460469231731687303715884105728, -170141183460469231731687303715884105728); -- { serverError 43 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728)); -- { serverError 407 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720)); -- { serverError 407 }\n+SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728));\n+170141183460469231722463931679029329921\n+SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720));\n+170141183460469231722463931679029329921\n SELECT lcm(toInt128('-170141183460469231731687303715884105720'), toInt128('-170141183460469231731687303715884105720'));\n 170141183460469231731687303715884105720\n SELECT lcm(-9223372036854775806, -9223372036854775806);\ndiff --git a/tests/queries/0_stateless/01666_lcm_ubsan.sql b/tests/queries/0_stateless/01666_lcm_ubsan.sql\nindex b3b869c80ed4..8ebdf148a65b 100644\n--- a/tests/queries/0_stateless/01666_lcm_ubsan.sql\n+++ b/tests/queries/0_stateless/01666_lcm_ubsan.sql\n@@ -5,7 +5,7 @@ SELECT lcm(-9223372036854775808, 9223372036854775807); -- { serverError 407 }\n SELECT lcm(-9223372036854775807, 9223372036854775808); -- { serverError 407 }\n SELECT lcm(9223372036854775808, -1); -- { serverError 407 }\n SELECT lcm(-170141183460469231731687303715884105728, -170141183460469231731687303715884105728); -- { serverError 43 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728)); -- { serverError 407 }\n-SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720)); -- { serverError 407 }\n+SELECT lcm(toInt128(-170141183460469231731687303715884105728), toInt128(-170141183460469231731687303715884105728));\n+SELECT lcm(toInt128(-170141183460469231731687303715884105720), toInt128(-170141183460469231731687303715884105720));\n SELECT lcm(toInt128('-170141183460469231731687303715884105720'), toInt128('-170141183460469231731687303715884105720'));\n SELECT lcm(-9223372036854775806, -9223372036854775806);\ndiff --git a/tests/queries/0_stateless/01720_type_map_and_casts.reference b/tests/queries/0_stateless/01720_type_map_and_casts.reference\nindex 590bdedd7f23..760624d7f407 100644\n--- a/tests/queries/0_stateless/01720_type_map_and_casts.reference\n+++ b/tests/queries/0_stateless/01720_type_map_and_casts.reference\n@@ -32,7 +32,7 @@ Map(UUID, UInt16)\n {'00001192-0000-4000-8000-000000000001':1,'00001192-0000-4000-7000-000000000001':2}\n 0\t2\t1\n Map(Int128, String)\n-{-1:'a',0:'b',1234567898765432193024000:'c',-1234567898765432193024000:'d'}\n+{-1:'a',0:'b',1234567898765432123456789:'c',-1234567898765432123456789:'d'}\n a\tb\tc\td\n \n a\ndiff --git a/tests/queries/0_stateless/01720_type_map_and_casts.sql b/tests/queries/0_stateless/01720_type_map_and_casts.sql\nindex d7991999ef71..f03773d90849 100644\n--- a/tests/queries/0_stateless/01720_type_map_and_casts.sql\n+++ b/tests/queries/0_stateless/01720_type_map_and_casts.sql\n@@ -65,15 +65,15 @@ CREATE TABLE table_map_with_key_integer (d DATE, m Map(Int128, String))\n ENGINE = MergeTree() ORDER BY d;\n \n \n-INSERT INTO table_map_with_key_integer SELECT '2020-01-01', map(-1, 'a', 0, 'b', toInt128(1234567898765432123456789), 'c', toInt128(-1234567898765432123456789), 'd');\n+INSERT INTO table_map_with_key_integer SELECT '2020-01-01', map(-1, 'a', 0, 'b', toInt128('1234567898765432123456789'), 'c', toInt128('-1234567898765432123456789'), 'd');\n \n SELECT 'Map(Int128, String)';\n \n SELECT m FROM table_map_with_key_integer;\n-SELECT m[toInt128(-1)], m[toInt128(0)], m[toInt128(1234567898765432123456789)], m[toInt128(-1234567898765432123456789)] FROM table_map_with_key_integer;\n+SELECT m[toInt128(-1)], m[toInt128(0)], m[toInt128('1234567898765432123456789')], m[toInt128('-1234567898765432123456789')] FROM table_map_with_key_integer;\n SELECT m[toInt128(number - 2)] FROM table_map_with_key_integer ARRAY JOIN [0, 1, 2, 3] AS number;\n \n-SELECT m[-1], m[0], m[toInt128(1234567898765432123456789)], m[toInt128(-1234567898765432123456789)] FROM table_map_with_key_integer;\n+SELECT m[-1], m[0], m[toInt128('1234567898765432123456789')], m[toInt128('-1234567898765432123456789')] FROM table_map_with_key_integer;\n SELECT m[toUInt64(0)], m[toInt64(0)], m[toUInt8(0)], m[toUInt16(0)] FROM table_map_with_key_integer;\n \n DROP TABLE IF EXISTS table_map_with_key_integer;\n",
  "problem_statement": "toDecimal256 returns exception for values that should be in range.\n**Describe the bug**\r\nDocumentation states the range of Decimal256(S) is (-10*(76-S), 10*(76-S)). toDecimal256(value,0) returns an error at 10\\*10 and -10\\*10 and values farther out.\r\n\r\n**How to reproduce**\r\n* ClickHouse server version 21.5.1 revision 54447\r\n* Queries to run that lead to unexpected result\r\n```\r\n:) select toDecimal256('10000000000',0)\r\n\r\nSELECT toDecimal256('10000000000', 0)\r\n\r\nQuery id: bb396e72-4fe6-4b9b-8319-9975e950d388\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Can't compare.\r\n\r\n:) select toDecimal256(10000000000,0)\r\n\r\nSELECT toDecimal256(10000000000, 0)\r\n\r\nQuery id: 13386ae2-535c-40f0-b99b-78e8e98793fb\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Can't compare.\r\n\r\n:) select toDecimal256(-10000000000,0)\r\n\r\nSELECT toDecimal256(-10000000000, 0)\r\n\r\nQuery id: ada9f101-e8af-4413-9dc8-fa83dc6d4036\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Can't compare.\r\n\r\n:) select toDecimal256('-10000000000',0)\r\n\r\nSELECT toDecimal256('-10000000000', 0)\r\n\r\nQuery id: 03efbf92-3fb3-44f5-9cd8-d9e0bd98be0e\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Can't compare.\r\n```\nCode: 48. DB::Exception: There are no UInt128 literals in SQL\nThis error occurs when a subquery returns a value of the type UUID.\r\n\r\n**How to reproduce**\r\n* ClickHouse server versions: 19.16.3, 19.17.3.7\r\n* Create two tables:\r\n`CREATE TABLE single_id(id UUID) ENGINE = Log`\r\n`CREATE TABLE other_table(id UUID) ENGINE = Log`\r\n* Sample data (single row):\r\n`INSERT INTO single_id VALUES ('61f0c404-5cb3-11e7-907b-a6006ad3dba0')`\r\n* Run query:\r\n`SELECT * FROM other_table WHERE id = (SELECT * FROM single_id)`\r\n\r\n**Expected behavior**\r\nThe query should return a table with one column and zero rows.\r\n\r\n**Error message**\r\n`Received exception from server (version 19.16.3):`\r\n`Code: 48. DB::Exception: There are no UInt128 literals in SQL.`\r\n\nCan't cast any String decimal to Decimal256\n**Describe the unexpected behaviour**\r\n\r\nHi,\r\n\r\nWhen trying to cast a String to a `Decimal256`, I encountered 2 different unexpected exceptions:\r\n\r\n- The first one is a `Can't compare` exception when casting a decimal with high precision and scale:\r\n```\r\ndata :) SELECT CAST('123456789123456789123456789.123456789123456789123456789', 'Decimal256(38)')\r\n\r\nSELECT CAST('123456789123456789123456789.123456789123456789123456789', 'Decimal256(38)')\r\n\r\n\r\nReceived exception from server (version 20.11.4):\r\nCode: 407. DB::Exception: Received from 10.170.2.185:9000. DB::Exception: Can't compare. \r\n\r\n0 rows in set. Elapsed: 0.234 sec. \r\n```\r\n\r\n- The second one is a `Decimal math overflow` when trying to cast a simple string decimal, while the casting to `Decimal128` work as intended: \r\n```\r\ndata :) SELECT CAST('1.0', 'Decimal256(38)')\r\n\r\nSELECT CAST('1.0', 'Decimal256(38)')\r\n\r\n\r\nReceived exception from server (version 20.11.4):\r\nCode: 407. DB::Exception: Received from 10.170.2.185:9000. DB::Exception: Decimal math overflow: While processing CAST('1.0', 'Decimal256(38)'). \r\n\r\n0 rows in set. Elapsed: 0.196 sec. \r\n\r\ndata :) SELECT CAST('1.0', 'Decimal128(18)')\r\n\r\nSELECT CAST('1.0', 'Decimal128(18)')\r\n\r\n\u250c\u2500CAST('1.0', 'Decimal128(18)')\u2500\u2510\r\n\u2502          1.000000000000000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.195 sec. \r\n```\r\n\r\n\r\n**How to reproduce**\r\n\r\nPlease see the above queries to reproduce. \r\nServer version: `20.11.4`\r\nClient version: `20.10.2.20`\r\n\r\n**Expected behavior**\r\nI would expect the casting of both string to `Decimal256(38)` to work and not raise any exception as the numbesr that I'm trying to cast are in the range of the `Decimal256(38)`.\r\n\r\n**Error message and/or stacktrace**\r\n2 errors:\r\n```\r\nCode: 407. DB::Exception: Received from 10.170.2.185:9000. DB::Exception: Can't compare. \r\n```\r\n```\r\nCode: 407. DB::Exception: Received from 10.170.2.185:9000. DB::Exception: Decimal math overflow: While processing CAST('1.0', 'Decimal256(38)'). \r\n```\r\n\nLowCardinality(UUID) is forbidden since 21.2\nOn 21.1::\r\n```\r\ncreate table test (x LowCardinality(UUID)) engine=Memory;\r\n\r\nReceived exception from server (version 21.1.9):\r\nCode: 455. DB::Exception: Received from localhost:9000. DB::Exception: Creating columns of type LowCardinality(UUID) is prohibited by default due to expected negative impact on performance. It can be enabled with the \"allow_suspicious_low_cardinality_types\" setting.. Stack trace:\r\n\r\n0. DB::InterpreterCreateQuery::validateTableStructure(DB::ASTCreateQuery const&, DB::InterpreterCreateQuery::TableProperties const&) const @ 0xec3ec84 in /usr/bin/clickhouse\r\n1. DB::InterpreterCreateQuery::setProperties(DB::ASTCreateQuery&) const @ 0xec3d5b8 in /usr/bin/clickhouse\r\n2. DB::InterpreterCreateQuery::createTable(DB::ASTCreateQuery&) @ 0xec4196e in /usr/bin/clickhouse\r\n3. DB::InterpreterCreateQuery::execute() @ 0xec46647 in /usr/bin/clickhouse\r\n4. ? @ 0xf1672db in /usr/bin/clickhouse\r\n5. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) @ 0xf165cbd in /usr/bin/clickhouse\r\n6. DB::TCPHandler::runImpl() @ 0xf875556 in /usr/bin/clickhouse\r\n7. DB::TCPHandler::run() @ 0xf884367 in /usr/bin/clickhouse\r\n8. Poco::Net::TCPServerConnection::start() @ 0x11dca62f in /usr/bin/clickhouse\r\n9. Poco::Net::TCPServerDispatcher::run() @ 0x11dcc041 in /usr/bin/clickhouse\r\n10. Poco::PooledThread::run() @ 0x11ef7c49 in /usr/bin/clickhouse\r\n11. Poco::ThreadImpl::runnableEntry(void*) @ 0x11ef3bda in /usr/bin/clickhouse\r\n12. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so\r\n13. __clone @ 0x122293 in /usr/lib/x86_64-linux-gnu/libc-2.31.so\r\n```\r\n\r\nand allowing it:\r\n\r\n```\r\nset allow_suspicious_low_cardinality_types=1;\r\ncreate table test (x LowCardinality(UUID)) engine=Memory;\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec. \r\n```\r\n\r\nOn 21.2 and newer:\r\n```\r\n:) create table test (x LowCardinality(UUID)) engine=Memory;\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nReceived exception from server (version 21.6.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: DataTypeLowCardinality is supported only for numbers, strings, Date or DateTime, but got UUID. Stack trace:\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0x87df5fa in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n1. DB::DataTypeLowCardinality::DataTypeLowCardinality(std::__1::shared_ptr<DB::IDataType const>) @ 0xed65f26 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n2. std::__1::shared_ptr<DB::DataTypeLowCardinality> std::__1::allocate_shared<DB::DataTypeLowCardinality, std::__1::allocator<DB::DataTypeLowCardinality>, std::__1::shared_ptr<DB::IDataType const>, void>(std::__1::allocator<DB::DataTypeLowCardinality> const&, std::__1::shared_ptr<DB::IDataType const>&&) @ 0xed68397 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n3. DB::create(std::__1::shared_ptr<DB::IAST> const&) (.llvm.15080078877451193199) @ 0xed67b00 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n4. DB::DataTypeFactory::get(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::IAST> const&) const @ 0xed5c622 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n5. DB::DataTypeFactory::get(std::__1::shared_ptr<DB::IAST> const&) const @ 0xed5c406 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n6. DB::InterpreterCreateQuery::getColumnsDescription(DB::ASTExpressionList const&, std::__1::shared_ptr<DB::Context>, bool) @ 0xf06dc10 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n7. DB::InterpreterCreateQuery::setProperties(DB::ASTCreateQuery&) const @ 0xf06fa1a in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n8. DB::InterpreterCreateQuery::createTable(DB::ASTCreateQuery&) @ 0xf075664 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n9. DB::InterpreterCreateQuery::execute() @ 0xf07bd61 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n10. DB::executeQueryImpl(char const*, char const*, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*) @ 0xf6161e4 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n11. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, bool) @ 0xf614863 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n12. DB::TCPHandler::runImpl() @ 0xfde46d2 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n13. DB::TCPHandler::run() @ 0xfdf7659 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n14. Poco::Net::TCPServerConnection::start() @ 0x1249674f in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n15. Poco::Net::TCPServerDispatcher::run() @ 0x124981da in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n16. Poco::PooledThread::run() @ 0x125d1f99 in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n17. Poco::ThreadImpl::runnableEntry(void*) @ 0x125cdf8a in /usr/lib/debug/.build-id/d3/728012801ccf966515b1b6be77a02c9ae2a69e.debug\r\n18. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so\r\n19. __clone @ 0x122293 in /usr/lib/x86_64-linux-gnu/libc-2.31.so\r\n```\r\n\r\nand `allow_suspicious_low_cardinality_types` doesn't help anymore (same exception).\r\n\r\nActually `UUID` is the same as `FixedSting(16)`, and it definitely have sense to use it with LowCardinality.\nLowCardinality: UUID is not implemented\nversion 19.1.6. \r\n\r\nselect toLowCardinality(generateUUIDv4()) \r\nUnexpected dictionary type for DataTypeLowCardinality: UUID.\r\n\r\n\n",
  "hints_text": "\nSame error text also in #7463\nStill relevant in version 20.11.\nhttps://clickhouse.tech/docs/en/sql-reference/data-types/decimal/ talks about overflow\n\n",
  "created_at": "2021-04-25T10:06:23Z"
}