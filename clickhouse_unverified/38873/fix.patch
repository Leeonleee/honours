diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 42a53fb7138e..8b2b105f769e 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -890,21 +890,23 @@ SortDescription InterpreterSelectQuery::getSortDescription(const ASTSelectQuery
 {
     SortDescription order_descr;
     order_descr.reserve(query.orderBy()->children.size());
+
     for (const auto & elem : query.orderBy()->children)
     {
-        String name = elem->children.front()->getColumnName();
+        const String & column_name = elem->children.front()->getColumnName();
         const auto & order_by_elem = elem->as<ASTOrderByElement &>();
 
         std::shared_ptr<Collator> collator;
         if (order_by_elem.collation)
             collator = std::make_shared<Collator>(order_by_elem.collation->as<ASTLiteral &>().value.get<String>());
+
         if (order_by_elem.with_fill)
         {
             FillColumnDescription fill_desc = getWithFillDescription(order_by_elem, context_);
-            order_descr.emplace_back(name, order_by_elem.direction, order_by_elem.nulls_direction, collator, true, fill_desc);
+            order_descr.emplace_back(column_name, order_by_elem.direction, order_by_elem.nulls_direction, collator, true, fill_desc);
         }
         else
-            order_descr.emplace_back(name, order_by_elem.direction, order_by_elem.nulls_direction, collator);
+            order_descr.emplace_back(column_name, order_by_elem.direction, order_by_elem.nulls_direction, collator);
     }
 
     order_descr.compile_sort_description = context_->getSettingsRef().compile_sort_description;
diff --git a/src/Interpreters/RewriteOrderByVisitor.cpp b/src/Interpreters/RewriteOrderByVisitor.cpp
new file mode 100644
index 000000000000..694dec84b7a0
--- /dev/null
+++ b/src/Interpreters/RewriteOrderByVisitor.cpp
@@ -0,0 +1,53 @@
+#include <Interpreters/RewriteOrderByVisitor.hpp>
+#include <Parsers/ASTExpressionList.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTOrderByElement.h>
+#include <Parsers/ASTSelectQuery.h>
+
+namespace DB
+{
+
+void RewriteOrderBy::visit(ASTPtr & ast, Data &)
+{
+    auto * query = ast->as<ASTSelectQuery>();
+    if (!query)
+        return;
+
+    const ASTPtr & order_by = query->orderBy();
+    if (!order_by)
+        return;
+
+    const auto * expr_list = order_by->as<ASTExpressionList>();
+    if (!expr_list)
+        return;
+
+    if (expr_list->children.size() != 1)
+        return;
+
+    const auto * order_by_elem = expr_list->children.front()->as<ASTOrderByElement>();
+    if (!order_by_elem)
+        return;
+
+    const auto * func = order_by_elem->children.front()->as<ASTFunction>();
+    if (!func || func->name != "tuple")
+        return;
+
+    if (const auto * inner_list = func->children.front()->as<ASTExpressionList>())
+    {
+        auto new_order_by = std::make_shared<ASTExpressionList>();
+        for (const auto & identifier : inner_list->children)
+        {
+            // clone w/o children
+            auto clone = std::make_shared<ASTOrderByElement>(*order_by_elem);
+            clone->children.clear();
+
+            clone->children.emplace_back(identifier);
+            new_order_by->children.emplace_back(clone);
+        }
+        if (!new_order_by->children.empty())
+            query->setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(new_order_by));
+    }
+}
+
+}
+
diff --git a/src/Interpreters/RewriteOrderByVisitor.hpp b/src/Interpreters/RewriteOrderByVisitor.hpp
new file mode 100644
index 000000000000..a3857e046cad
--- /dev/null
+++ b/src/Interpreters/RewriteOrderByVisitor.hpp
@@ -0,0 +1,35 @@
+#pragma once
+
+#include <Parsers/IAST.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+
+namespace DB
+{
+///
+/// Remove outer braces in ORDER BY
+/// For example, rewrite (1) to (2)
+/// (1) ... ORDER BY (a, b)
+/// │    ExpressionList (children 1)              │
+/// │     OrderByElement (children 1)             │
+/// │      Function tuple (children 1)            │
+/// │       ExpressionList (children 2)           │
+/// │        Identifier CounterID                 │
+/// │        Identifier EventDate                 │
+/// (2) ... ORDER BY a,b
+/// │    ExpressionList (children 2)              │
+/// │     OrderByElement (children 1)             │
+/// │      Identifier CounterID                   │
+/// │     OrderByElement (children 1)             │
+/// │      Identifier EventDate                   │
+///
+class RewriteOrderBy
+{
+public:
+    struct Data {};
+    static void visit(ASTPtr & ast, Data &);
+    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }
+};
+
+using RewriteOrderByVisitor = InDepthNodeVisitor<RewriteOrderBy, true>;
+}
+
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index 9a4a956f3dc8..b57433fb0c67 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -26,6 +26,7 @@
 #include <Interpreters/replaceAliasColumnsInQuery.h>
 #include <Interpreters/evaluateConstantExpression.h>
 #include <Interpreters/PredicateExpressionsOptimizer.h>
+#include <Interpreters/RewriteOrderByVisitor.hpp>
 
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTFunction.h>
@@ -1326,6 +1327,10 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(
             !select_query->sampleSize() && !select_query->sampleOffset() && !select_query->final() &&
             (tables_with_columns.size() < 2 || isLeft(result.analyzed_join->kind()));
 
+    // remove outer braces in order by
+    RewriteOrderByVisitor::Data data;
+    RewriteOrderByVisitor(data).visit(query);
+
     return std::make_shared<const TreeRewriterResult>(result);
 }
 
