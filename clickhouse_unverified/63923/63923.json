{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63923,
  "instance_id": "ClickHouse__ClickHouse-63923",
  "issue_numbers": [
    "63858"
  ],
  "base_commit": "0b3b51c274f85eab06528e4496f7e8d7fb8d7d93",
  "patch": "diff --git a/contrib/datasketches-cpp b/contrib/datasketches-cpp\nindex c3abaaefe5fa..76edd74f5db2 160000\n--- a/contrib/datasketches-cpp\n+++ b/contrib/datasketches-cpp\n@@ -1,1 +1,1 @@\n-Subproject commit c3abaaefe5fa400eed99e082af07c1b61a7144db\n+Subproject commit 76edd74f5db286b672c170a8ded4ce39b3a8800f\ndiff --git a/docs/changelogs/v22.11.1.1360-stable.md b/docs/changelogs/v22.11.1.1360-stable.md\nindex 4aa110484f85..4acaffb2c3ba 100644\n--- a/docs/changelogs/v22.11.1.1360-stable.md\n+++ b/docs/changelogs/v22.11.1.1360-stable.md\n@@ -93,7 +93,7 @@ sidebar_label: 2022\n * `(U)Int128` and `(U)Int256` values are correctly checked in `PREWHERE`. [#42605](https://github.com/ClickHouse/ClickHouse/pull/42605) ([Antonio Andelic](https://github.com/antonio2368)).\n * Fix a bug in ParserFunction that could have led to a segmentation fault. [#42724](https://github.com/ClickHouse/ClickHouse/pull/42724) ([Nikolay Degterinsky](https://github.com/evillique)).\n * Fix truncate table does not hold lock correctly. [#42728](https://github.com/ClickHouse/ClickHouse/pull/42728) ([flynn](https://github.com/ucasfl)).\n-* Fix possible SIGSEGV for web disks when file does not exists (or `OPTIMIZE TABLE FINAL`, that also can got the same error eventually). [#42767](https://github.com/ClickHouse/ClickHouse/pull/42767) ([Azat Khuzhin](https://github.com/azat)).\n+* Fix possible SIGSEGV for web disks when file does not exist (or `OPTIMIZE TABLE FINAL`, that also can got the same error eventually). [#42767](https://github.com/ClickHouse/ClickHouse/pull/42767) ([Azat Khuzhin](https://github.com/azat)).\n * Fix `auth_type` mapping in `system.session_log`, by including `SSL_CERTIFICATE` for the enum values. [#42782](https://github.com/ClickHouse/ClickHouse/pull/42782) ([Miel Donkers](https://github.com/mdonkers)).\n * Fix stack-use-after-return under ASAN build in ParserCreateUserQuery. [#42804](https://github.com/ClickHouse/ClickHouse/pull/42804) ([Nikolay Degterinsky](https://github.com/evillique)).\n * Fix lowerUTF8()/upperUTF8() in case of symbol was in between 16-byte boundary (very frequent case of you have strings > 16 bytes long). [#42812](https://github.com/ClickHouse/ClickHouse/pull/42812) ([Azat Khuzhin](https://github.com/azat)).\ndiff --git a/docs/changelogs/v22.8.1.2097-lts.md b/docs/changelogs/v22.8.1.2097-lts.md\nindex b6b634f48264..f9a1fa8a4a9a 100644\n--- a/docs/changelogs/v22.8.1.2097-lts.md\n+++ b/docs/changelogs/v22.8.1.2097-lts.md\n@@ -53,7 +53,7 @@ sidebar_label: 2022\n * Store Keeper API version inside a predefined path. [#39096](https://github.com/ClickHouse/ClickHouse/pull/39096) ([Antonio Andelic](https://github.com/antonio2368)).\n * Now entrypoint.sh in docker image creates and executes chown for all folders it found in config for multidisk setup [#17717](https://github.com/ClickHouse/ClickHouse/issues/17717). [#39121](https://github.com/ClickHouse/ClickHouse/pull/39121) ([Nikita Mikhaylov](https://github.com/nikitamikhaylov)).\n * Add profile events for fsync. [#39179](https://github.com/ClickHouse/ClickHouse/pull/39179) ([Azat Khuzhin](https://github.com/azat)).\n-* Add the second argument to the ordinary function `file(path[, default])`, which function returns in the case when a file does not exists. [#39218](https://github.com/ClickHouse/ClickHouse/pull/39218) ([Nikolay Degterinsky](https://github.com/evillique)).\n+* Add the second argument to the ordinary function `file(path[, default])`, which function returns in the case when a file does not exist. [#39218](https://github.com/ClickHouse/ClickHouse/pull/39218) ([Nikolay Degterinsky](https://github.com/evillique)).\n * Some small fixes for reading via http, allow to retry partial content in case if got 200OK. [#39244](https://github.com/ClickHouse/ClickHouse/pull/39244) ([Kseniia Sumarokova](https://github.com/kssenii)).\n * Improved Base58 encoding/decoding. [#39292](https://github.com/ClickHouse/ClickHouse/pull/39292) ([Andrey Zvonov](https://github.com/zvonand)).\n * Normalize `AggregateFunction` types and state representations because optimizations like https://github.com/ClickHouse/ClickHouse/pull/35788 will treat `count(not null columns)` as `count()`, which might confuses distributed interpreters with the following error : `Conversion from AggregateFunction(count) to AggregateFunction(count, Int64) is not supported`. [#39420](https://github.com/ClickHouse/ClickHouse/pull/39420) ([Amos Bird](https://github.com/amosbird)).\ndiff --git a/docs/changelogs/v23.10.1.1976-stable.md b/docs/changelogs/v23.10.1.1976-stable.md\nindex b08383a859b1..4d093f934f16 100644\n--- a/docs/changelogs/v23.10.1.1976-stable.md\n+++ b/docs/changelogs/v23.10.1.1976-stable.md\n@@ -291,7 +291,7 @@ sidebar_label: 2023\n * Fix replica groups for Replicated database engine [#55587](https://github.com/ClickHouse/ClickHouse/pull/55587) ([Azat Khuzhin](https://github.com/azat)).\n * Remove unused protobuf includes [#55590](https://github.com/ClickHouse/ClickHouse/pull/55590) ([Ra\u00fal Mar\u00edn](https://github.com/Algunenano)).\n * Apply Context changes to standalone Keeper [#55591](https://github.com/ClickHouse/ClickHouse/pull/55591) ([Antonio Andelic](https://github.com/antonio2368)).\n-* Do not fail if label-to-remove does not exists in PR [#55592](https://github.com/ClickHouse/ClickHouse/pull/55592) ([Mikhail f. Shiryaev](https://github.com/Felixoid)).\n+* Do not fail if label-to-remove does not exist in PR [#55592](https://github.com/ClickHouse/ClickHouse/pull/55592) ([Mikhail f. Shiryaev](https://github.com/Felixoid)).\n * CI: cast extra column expression `pull_request_number` to Int32 [#55599](https://github.com/ClickHouse/ClickHouse/pull/55599) ([Han Fei](https://github.com/hanfei1991)).\n * Add back a test that was removed by mistake [#55605](https://github.com/ClickHouse/ClickHouse/pull/55605) ([Alexander Tokmakov](https://github.com/tavplubix)).\n * Bump croaring to v2.0.4 [#55606](https://github.com/ClickHouse/ClickHouse/pull/55606) ([Robert Schulze](https://github.com/rschu1ze)).\ndiff --git a/docs/en/operations/utilities/clickhouse-keeper-client.md b/docs/en/operations/utilities/clickhouse-keeper-client.md\nindex 4588f68cacd1..6407c66783b6 100644\n--- a/docs/en/operations/utilities/clickhouse-keeper-client.md\n+++ b/docs/en/operations/utilities/clickhouse-keeper-client.md\n@@ -35,7 +35,7 @@ api_version\n /keeper/api_version :) ls\n \n /keeper/api_version :) cd xyz\n-Path /keeper/api_version/xyz does not exists\n+Path /keeper/api_version/xyz does not exist\n /keeper/api_version :) cd ../../\n / :) ls\n keeper foo bar\ndiff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex 396cd3e646b1..01ed7d70b380 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -263,7 +263,7 @@ void Client::initialize(Poco::Util::Application & self)\n         config().add(loaded_config.configuration);\n     }\n     else if (config().has(\"connection\"))\n-        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"--connection was specified, but config does not exists\");\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"--connection was specified, but config does not exist\");\n \n     /** getenv is thread-safe in Linux glibc and in all sane libc implementations.\n       * But the standard does not guarantee that subsequent calls will not rewrite the value by returned pointer.\ndiff --git a/programs/keeper-client/Commands.cpp b/programs/keeper-client/Commands.cpp\nindex ec5eaf5070cc..a109912e6e04 100644\n--- a/programs/keeper-client/Commands.cpp\n+++ b/programs/keeper-client/Commands.cpp\n@@ -63,7 +63,7 @@ void CDCommand::execute(const ASTKeeperQuery * query, KeeperClient * client) con\n \n     auto new_path = client->getAbsolutePath(query->args[0].safeGet<String>());\n     if (!client->zookeeper->exists(new_path))\n-        std::cerr << \"Path \" << new_path << \" does not exists\\n\";\n+        std::cerr << \"Path \" << new_path << \" does not exist\\n\";\n     else\n         client->cwd = new_path;\n }\ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex bfe2f981c638..dae17e18b85b 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -5090,14 +5090,14 @@ ProjectionName QueryAnalyzer::resolveWindow(QueryTreeNodePtr & node, IdentifierR\n         auto * nearest_query_scope = scope.getNearestQueryScope();\n \n         if (!nearest_query_scope)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Window '{}' does not exists.\", parent_window_name);\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Window '{}' does not exist.\", parent_window_name);\n \n         auto & scope_window_name_to_window_node = nearest_query_scope->window_name_to_window_node;\n \n         auto window_node_it = scope_window_name_to_window_node.find(parent_window_name);\n         if (window_node_it == scope_window_name_to_window_node.end())\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Window '{}' does not exists. In scope {}\",\n+                \"Window '{}' does not exist. In scope {}\",\n                 parent_window_name,\n                 nearest_query_scope->scope_node->formatASTForErrorMessage());\n \n@@ -5861,7 +5861,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n     {\n         if (!AggregateFunctionFactory::instance().isAggregateFunctionName(function_name))\n         {\n-            throw Exception(ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION, \"Aggregate function with name '{}' does not exists. In scope {}{}\",\n+            throw Exception(ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION, \"Aggregate function with name '{}' does not exist. In scope {}{}\",\n                             function_name, scope.scope_node->formatASTForErrorMessage(),\n                             getHintsErrorMessageSuffix(AggregateFunctionFactory::instance().getHints(function_name)));\n         }\n@@ -5942,7 +5942,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             auto hints = NamePrompter<2>::getHints(function_name, possible_function_names);\n \n             throw Exception(ErrorCodes::UNKNOWN_FUNCTION,\n-                \"Function with name '{}' does not exists. In scope {}{}\",\n+                \"Function with name '{}' does not exist. In scope {}{}\",\n                 function_name,\n                 scope.scope_node->formatASTForErrorMessage(),\n                 getHintsErrorMessageSuffix(hints));\n@@ -8070,7 +8070,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n             auto window_node_it = scope.window_name_to_window_node.find(parent_window_name);\n             if (window_node_it == scope.window_name_to_window_node.end())\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Window '{}' does not exists. In scope {}\",\n+                    \"Window '{}' does not exist. In scope {}\",\n                     parent_window_name,\n                     scope.scope_node->formatASTForErrorMessage());\n \n@@ -8268,7 +8268,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n         if (!has_node_in_alias_table)\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Node {} with duplicate alias {} does not exists in alias table. In scope {}\",\n+                \"Node {} with duplicate alias {} does not exist in alias table. In scope {}\",\n                 node->formatASTForErrorMessage(),\n                 node_alias,\n                 scope.scope_node->formatASTForErrorMessage());\ndiff --git a/src/Common/Logger.h b/src/Common/Logger.h\nindex b4688eb0a9c8..b54ccd33e725 100644\n--- a/src/Common/Logger.h\n+++ b/src/Common/Logger.h\n@@ -26,12 +26,12 @@ using LoggerRawPtr = Poco::Logger *;\n   * Then it must be destroyed when underlying table is destroyed.\n   */\n \n-/** Get Logger with specified name. If the Logger does not exists, it is created.\n+/** Get Logger with specified name. If the Logger does not exist, it is created.\n   * Logger is destroyed, when last shared ptr that refers to Logger with specified name is destroyed.\n   */\n LoggerPtr getLogger(const std::string & name);\n \n-/** Get Logger with specified name. If the Logger does not exists, it is created.\n+/** Get Logger with specified name. If the Logger does not exist, it is created.\n   * This overload was added for specific purpose, when logger is constructed from constexpr string.\n   * Logger is destroyed only during program shutdown.\n   */\ndiff --git a/src/Databases/MySQL/DatabaseMySQL.cpp b/src/Databases/MySQL/DatabaseMySQL.cpp\nindex 84dd385e191c..1c82131af0d7 100644\n--- a/src/Databases/MySQL/DatabaseMySQL.cpp\n+++ b/src/Databases/MySQL/DatabaseMySQL.cpp\n@@ -440,7 +440,7 @@ void DatabaseMySQL::detachTablePermanently(ContextPtr, const String & table_name\n         throw Exception(ErrorCodes::TABLE_IS_DROPPED, \"Table {}.{} is dropped\", backQuoteIfNeed(database_name), backQuoteIfNeed(table_name));\n \n     if (fs::exists(remove_flag))\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"The remove flag file already exists but the {}.{} does not exists remove tables, it is bug.\",\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"The remove flag file already exists but the {}.{} does not exist remove tables, it is bug.\",\n                         backQuoteIfNeed(database_name), backQuoteIfNeed(table_name));\n \n     auto table_iter = local_tables_cache.find(table_name);\ndiff --git a/src/Dictionaries/SSDCacheDictionaryStorage.h b/src/Dictionaries/SSDCacheDictionaryStorage.h\nindex b23f9617ec8e..e3eea71cd9a8 100644\n--- a/src/Dictionaries/SSDCacheDictionaryStorage.h\n+++ b/src/Dictionaries/SSDCacheDictionaryStorage.h\n@@ -470,7 +470,7 @@ class SSDCacheFileBuffer : private boost::noncopyable\n         auto path = std::filesystem::path{file_path};\n         auto parent_path_directory = path.parent_path();\n \n-        /// If cache file is in directory that does not exists create it\n+        /// If cache file is in directory that does not exist create it\n         if (!std::filesystem::exists(parent_path_directory))\n             if (!std::filesystem::create_directories(parent_path_directory))\n                 throw Exception(ErrorCodes::CANNOT_CREATE_DIRECTORY, \"Failed to create directories.\");\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 547ea7ec566e..dc612e446426 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1641,7 +1641,7 @@ void Context::updateExternalTable(const String & table_name, std::shared_ptr<Tem\n     std::lock_guard lock(mutex);\n     auto it = external_tables_mapping.find(table_name);\n     if (it == external_tables_mapping.end())\n-        throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Temporary table {} does not exists\", backQuoteIfNeed(table_name));\n+        throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Temporary table {} does not exist\", backQuoteIfNeed(table_name));\n \n     it->second = std::move(temporary_table);\n }\ndiff --git a/src/Planner/TableExpressionData.h b/src/Planner/TableExpressionData.h\nindex 9ab7a8e64fed..9723a00a3560 100644\n--- a/src/Planner/TableExpressionData.h\n+++ b/src/Planner/TableExpressionData.h\n@@ -137,7 +137,7 @@ class TableExpressionData\n         if (it == column_name_to_column.end())\n         {\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Column for column name {} does not exists. There are only column names: {}\",\n+                \"Column for column name {} does not exist. There are only column names: {}\",\n                 column_name,\n                 fmt::join(column_names.begin(), column_names.end(), \", \"));\n         }\n@@ -154,7 +154,7 @@ class TableExpressionData\n         if (it == column_name_to_column_identifier.end())\n         {\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Column identifier for column name {} does not exists. There are only column names: {}\",\n+                \"Column identifier for column name {} does not exist. There are only column names: {}\",\n                 column_name,\n                 fmt::join(column_names.begin(), column_names.end(), \", \"));\n         }\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex e1ddd89322f7..3db935729b4d 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -1107,7 +1107,7 @@ void TCPHandler::processTablesStatusRequest()\n     ContextPtr context_to_resolve_table_names;\n     if (is_interserver_mode)\n     {\n-        /// In interserver mode session context does not exists, because authentication is done for each query.\n+        /// In the interserver mode session context does not exist, because authentication is done for each query.\n         /// We also cannot create query context earlier, because it cannot be created before authentication,\n         /// but query is not received yet. So we have to do this trick.\n         ContextMutablePtr fake_interserver_context = Context::createCopy(server.context());\ndiff --git a/src/Storages/Distributed/DistributedAsyncInsertBatch.cpp b/src/Storages/Distributed/DistributedAsyncInsertBatch.cpp\nindex 2d052255ac51..06d4c1858407 100644\n--- a/src/Storages/Distributed/DistributedAsyncInsertBatch.cpp\n+++ b/src/Storages/Distributed/DistributedAsyncInsertBatch.cpp\n@@ -173,7 +173,7 @@ bool DistributedAsyncInsertBatch::valid()\n     {\n         if (!fs::exists(file))\n         {\n-            LOG_WARNING(parent.log, \"File {} does not exists, likely due abnormal shutdown\", file);\n+            LOG_WARNING(parent.log, \"File {} does not exist, likely due abnormal shutdown\", file);\n             res = false;\n         }\n     }\ndiff --git a/src/Storages/Distributed/DistributedAsyncInsertDirectoryQueue.cpp b/src/Storages/Distributed/DistributedAsyncInsertDirectoryQueue.cpp\nindex 1ee776111916..14866c25365c 100644\n--- a/src/Storages/Distributed/DistributedAsyncInsertDirectoryQueue.cpp\n+++ b/src/Storages/Distributed/DistributedAsyncInsertDirectoryQueue.cpp\n@@ -554,7 +554,7 @@ void DistributedAsyncInsertDirectoryQueue::processFilesWithBatching(const Settin\n         {\n             if (!fs::exists(file_path))\n             {\n-                LOG_WARNING(log, \"File {} does not exists, likely due to current_batch.txt processing\", file_path);\n+                LOG_WARNING(log, \"File {} does not exist, likely due to current_batch.txt processing\", file_path);\n                 continue;\n             }\n \ndiff --git a/src/Storages/MergeTree/DataPartStorageOnDiskBase.cpp b/src/Storages/MergeTree/DataPartStorageOnDiskBase.cpp\nindex 052e3ba4b744..82af6c1fbe8f 100644\n--- a/src/Storages/MergeTree/DataPartStorageOnDiskBase.cpp\n+++ b/src/Storages/MergeTree/DataPartStorageOnDiskBase.cpp\n@@ -580,7 +580,7 @@ void DataPartStorageOnDiskBase::rename(\n         disk.setLastModified(from, Poco::Timestamp::fromEpochTime(time(nullptr)));\n         disk.moveDirectory(from, to);\n \n-        /// Only after moveDirectory() since before the directory does not exists.\n+        /// Only after moveDirectory() since before the directory does not exist.\n         SyncGuardPtr to_sync_guard;\n         if (fsync_part_dir)\n             to_sync_guard = volume->getDisk()->getDirectorySyncGuard(to);\ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.h b/src/Storages/MergeTree/IMergeTreeReader.h\nindex a5b84eba241f..a1ec0339fd65 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.h\n+++ b/src/Storages/MergeTree/IMergeTreeReader.h\n@@ -100,7 +100,7 @@ class IMergeTreeReader : private boost::noncopyable\n     /// Position and level (of nesting).\n     using ColumnNameLevel = std::optional<std::pair<String, size_t>>;\n \n-    /// In case of part of the nested column does not exists, offsets should be\n+    /// In case of part of the nested column does not exist, offsets should be\n     /// read, but only the offsets for the current column, that is why it\n     /// returns pair of size_t, not just one.\n     ColumnNameLevel findColumnForOffsets(const NameAndTypePair & column) const;\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex f448a9a820db..167160db3174 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -5126,7 +5126,7 @@ void MergeTreeData::movePartitionToVolume(const ASTPtr & partition, const String\n \n     auto volume = getStoragePolicy()->getVolumeByName(name);\n     if (!volume)\n-        throw Exception(ErrorCodes::UNKNOWN_DISK, \"Volume {} does not exists on policy {}\", name, getStoragePolicy()->getName());\n+        throw Exception(ErrorCodes::UNKNOWN_DISK, \"Volume {} does not exist on policy {}\", name, getStoragePolicy()->getName());\n \n     if (parts.empty())\n         throw Exception(ErrorCodes::NO_SUCH_DATA_PART, \"Nothing to move (check that the partition exists).\");\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\nindex 4b164f5ac420..f5569d95a1bc 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\n@@ -490,11 +490,11 @@ bool MergeTreeIndexConditionBloomFilter::traverseTreeIn(\n         if (key_node_function_name == \"arrayElement\")\n         {\n             /** Try to parse arrayElement for mapKeys index.\n-              * It is important to ignore keys like column_map['Key'] IN ('') because if key does not exists in map\n-              * we return default value for arrayElement.\n+              * It is important to ignore keys like column_map['Key'] IN ('') because if the key does not exist in the map\n+              * we return the default value for arrayElement.\n               *\n               * We cannot skip keys that does not exist in map if comparison is with default type value because\n-              * that way we skip necessary granules where map key does not exists.\n+              * that way we skip necessary granules where the map key does not exist.\n               */\n             if (!prepared_set)\n                 return false;\n@@ -781,11 +781,11 @@ bool MergeTreeIndexConditionBloomFilter::traverseTreeEquals(\n         if (key_node_function_name == \"arrayElement\" && (function_name == \"equals\" || function_name == \"notEquals\"))\n         {\n             /** Try to parse arrayElement for mapKeys index.\n-              * It is important to ignore keys like column_map['Key'] = '' because if key does not exists in map\n+              * It is important to ignore keys like column_map['Key'] = '' because if key does not exist in map\n               * we return default value for arrayElement.\n               *\n               * We cannot skip keys that does not exist in map if comparison is with default type value because\n-              * that way we skip necessary granules where map key does not exists.\n+              * that way we skip necessary granules where map key does not exist.\n               */\n             if (value_field == value_type->getDefault())\n                 return false;\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\nindex 826b149cf017..82a0e0f8cd1c 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n@@ -444,11 +444,11 @@ bool MergeTreeConditionBloomFilterText::traverseTreeEquals(\n         if (key_function_node_function_name == \"arrayElement\")\n         {\n             /** Try to parse arrayElement for mapKeys index.\n-              * It is important to ignore keys like column_map['Key'] = '' because if key does not exists in map\n+              * It is important to ignore keys like column_map['Key'] = '' because if key does not exist in map\n               * we return default value for arrayElement.\n               *\n               * We cannot skip keys that does not exist in map if comparison is with default type value because\n-              * that way we skip necessary granules where map key does not exists.\n+              * that way we skip necessary granules where map key does not exist.\n               */\n             if (value_field == value_type->getDefault())\n                 return false;\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\nindex 9535cf18127b..cea260e0a76a 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n@@ -477,11 +477,11 @@ bool MergeTreeConditionFullText::traverseASTEquals(\n         if (function.getFunctionName() == \"arrayElement\")\n         {\n             /** Try to parse arrayElement for mapKeys index.\n-              * It is important to ignore keys like column_map['Key'] = '' because if key does not exists in map\n+              * It is important to ignore keys like column_map['Key'] = '' because if key does not exist in map\n               * we return default value for arrayElement.\n               *\n               * We cannot skip keys that does not exist in map if comparison is with default type value because\n-              * that way we skip necessary granules where map key does not exists.\n+              * that way we skip necessary granules where map key does not exist.\n               */\n             if (value_field == value_type->getDefault())\n                 return false;\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\nindex 643a1c31474e..34fb214a1ce8 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n@@ -232,7 +232,7 @@ bool MergeTreeReaderCompact::needSkipStream(size_t column_pos, const ISerializat\n     ///\n     /// Consider the following columns in nested \"root\":\n     /// - root.array Array(UInt8) - exists\n-    /// - root.nested_array Array(Array(UInt8)) - does not exists (only_offsets_level=1)\n+    /// - root.nested_array Array(Array(UInt8)) - does not exist (only_offsets_level=1)\n     ///\n     /// For root.nested_array it will try to read multiple streams:\n     /// - offsets (substream_path = {ArraySizes})\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 4f2790ac24ab..bfb35f72b727 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -58,7 +58,7 @@ static inline String generateInnerTableName(const StorageID & view_id)\n     return \".inner.\" + view_id.getTableName();\n }\n \n-/// Remove columns from target_header that does not exists in src_header\n+/// Remove columns from target_header that does not exist in src_header\n static void removeNonCommonColumns(const Block & src_header, Block & target_header)\n {\n     std::set<size_t> target_only_positions;\n@@ -233,10 +233,10 @@ void StorageMaterializedView::read(\n         auto mv_header = getHeaderForProcessingStage(column_names, storage_snapshot, query_info, context, processed_stage);\n         auto target_header = query_plan.getCurrentDataStream().header;\n \n-        /// No need to convert columns that does not exists in MV\n+        /// No need to convert columns that does not exist in MV\n         removeNonCommonColumns(mv_header, target_header);\n \n-        /// No need to convert columns that does not exists in the result header.\n+        /// No need to convert columns that does not exist in the result header.\n         ///\n         /// Distributed storage may process query up to the specific stage, and\n         /// so the result header may not include all the columns from the\n",
  "test_patch": "diff --git a/docker/test/fuzzer/run-fuzzer.sh b/docker/test/fuzzer/run-fuzzer.sh\nindex d1ccdea304b7..b8f967ed9c27 100755\n--- a/docker/test/fuzzer/run-fuzzer.sh\n+++ b/docker/test/fuzzer/run-fuzzer.sh\n@@ -138,7 +138,7 @@ function filter_exists_and_template\n             # but it doesn't allow to use regex\n             echo \"$path\" | sed 's/\\.sql\\.j2$/.gen.sql/'\n         else\n-            echo \"'$path' does not exists\" >&2\n+            echo \"'$path' does not exist\" >&2\n         fi\n     done\n }\ndiff --git a/tests/integration/test_access_for_functions/test.py b/tests/integration/test_access_for_functions/test.py\nindex 3e58c9614218..004d39e1deae 100644\n--- a/tests/integration/test_access_for_functions/test.py\n+++ b/tests/integration/test_access_for_functions/test.py\n@@ -42,7 +42,7 @@ def test_access_rights_for_function():\n     function_resolution_error = instance.query_and_get_error(\"SELECT MySum(1, 2)\")\n     assert (\n         \"Unknown function MySum\" in function_resolution_error\n-        or \"Function with name 'MySum' does not exists.\" in function_resolution_error\n+        or \"Function with name 'MySum' does not exist.\" in function_resolution_error\n     )\n \n     instance.query(\"REVOKE CREATE FUNCTION ON *.* FROM A\")\ndiff --git a/tests/integration/test_sql_user_defined_functions_on_cluster/test.py b/tests/integration/test_sql_user_defined_functions_on_cluster/test.py\nindex 0bf03f545bef..dc36a7b32b83 100644\n--- a/tests/integration/test_sql_user_defined_functions_on_cluster/test.py\n+++ b/tests/integration/test_sql_user_defined_functions_on_cluster/test.py\n@@ -28,7 +28,7 @@ def check_function_does_not_exist(node: ClickHouseInstance):\n         error_message = node.query_and_get_error(\"SELECT test_function(1);\")\n         assert (\n             \"Unknown function test_function\" in error_message\n-            or \"Function with name 'test_function' does not exists. In scope SELECT test_function(1)\"\n+            or \"Function with name 'test_function' does not exist. In scope SELECT test_function(1)\"\n             in error_message\n         )\n \ndiff --git a/tests/integration/test_user_defined_object_persistence/test.py b/tests/integration/test_user_defined_object_persistence/test.py\nindex 1919da0726e2..986438a4eed9 100644\n--- a/tests/integration/test_user_defined_object_persistence/test.py\n+++ b/tests/integration/test_user_defined_object_persistence/test.py\n@@ -38,13 +38,13 @@ def test_persistence():\n     error_message = instance.query_and_get_error(\"SELECT MySum1(1, 2)\")\n     assert (\n         \"Unknown function MySum1\" in error_message\n-        or \"Function with name 'MySum1' does not exists. In scope SELECT MySum1(1, 2)\"\n+        or \"Function with name 'MySum1' does not exist. In scope SELECT MySum1(1, 2)\"\n         in error_message\n     )\n \n     error_message = instance.query_and_get_error(\"SELECT MySum2(1, 2)\")\n     assert (\n         \"Unknown function MySum2\" in error_message\n-        or \"Function with name 'MySum2' does not exists. In scope SELECT MySum2(1, 2)\"\n+        or \"Function with name 'MySum2' does not exist. In scope SELECT MySum2(1, 2)\"\n         in error_message\n     )\ndiff --git a/tests/queries/0_stateless/02722_database_filesystem.sh b/tests/queries/0_stateless/02722_database_filesystem.sh\nindex 0c75c15fc695..374dd246c96c 100755\n--- a/tests/queries/0_stateless/02722_database_filesystem.sh\n+++ b/tests/queries/0_stateless/02722_database_filesystem.sh\n@@ -72,7 +72,7 @@ DROP DATABASE IF EXISTS test2;\n CREATE DATABASE test2 ENGINE = Filesystem('/tmp');\n \"\"\" 2>&1 | tr '\\n' ' ' | grep -oF -e \"UNKNOWN_TABLE\" -e \"BAD_ARGUMENTS\" > /dev/null && echo \"OK\" || echo 'FAIL' ||:\n \n-# BAD_ARGUMENTS: .../user_files/relative_unknown_dir does not exists\n+# BAD_ARGUMENTS: .../user_files/relative_unknown_dir does not exist\n ${CLICKHOUSE_CLIENT} --multiline --multiquery -q \"\"\"\n DROP DATABASE IF EXISTS test2;\n CREATE DATABASE test2 ENGINE = Filesystem('relative_unknown_dir');\ndiff --git a/tests/queries/0_stateless/03096_text_log_format_string_args_not_empty.sql b/tests/queries/0_stateless/03096_text_log_format_string_args_not_empty.sql\nindex 0f4a217a4aef..cffc8a49c676 100644\n--- a/tests/queries/0_stateless/03096_text_log_format_string_args_not_empty.sql\n+++ b/tests/queries/0_stateless/03096_text_log_format_string_args_not_empty.sql\n@@ -10,4 +10,4 @@ select count() > 0 from system.text_log where message_format_string = 'Peak memo\n \n select count() > 0 from system.text_log where level = 'Error' and message_format_string = 'Unknown {}{} identifier \\'{}\\' in scope {}{}' and value1 = 'expression' and value3 = 'count' and value4 = 'SELECT count';\n \n-select count() > 0 from system.text_log where level = 'Error' and message_format_string = 'Function with name \\'{}\\' does not exists. In scope {}{}' and value1 = 'conut' and value2 = 'SELECT conut()' and value3 ilike '%\\'count\\'%';\n+select count() > 0 from system.text_log where level = 'Error' and message_format_string = 'Function with name \\'{}\\' does not exist. In scope {}{}' and value1 = 'conut' and value2 = 'SELECT conut()' and value3 ilike '%\\'count\\'%';\ndiff --git a/tests/queries/0_stateless/03155_datasketches_ubsan.reference b/tests/queries/0_stateless/03155_datasketches_ubsan.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03155_datasketches_ubsan.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/03155_datasketches_ubsan.sql b/tests/queries/0_stateless/03155_datasketches_ubsan.sql\nnew file mode 100644\nindex 000000000000..521301d03f72\n--- /dev/null\n+++ b/tests/queries/0_stateless/03155_datasketches_ubsan.sql\n@@ -0,0 +1,2 @@\n+-- Tags: no-fasttest\n+SELECT uniqTheta(toFixedString('uniqTheta distinct', 18)) FROM (SELECT number % 2 AS x FROM numbers(10) WHERE materialize(16));\n",
  "problem_statement": "Apache Datasketches: UBSan report: load of misaligned address\nhttps://s3.amazonaws.com/clickhouse-test-reports/63802/a0cbbeb2c98cf673f068edf44cc089b43062a3d8/ast_fuzzer__ubsan_.html\n",
  "hints_text": "```\r\nmilovidov@milovidov-pc:~/work/ClickHouse/build_ubsan$ programs/clickhouse \r\nClickHouse local version 24.5.1.1.\r\n\r\nmilovidov-pc :) SELECT uniqTheta(toFixedString('uniqTheta distinct', 18)) FROM (SELECT number % 2 AS x FROM numbers(10) WHERE materialize(16))\r\n\r\nSELECT uniqTheta(toFixedString('uniqTheta distinct', 18))\r\nFROM\r\n(\r\n    SELECT number % 2 AS x\r\n    FROM numbers(10)\r\n    WHERE materialize(16)\r\n)\r\n\r\nQuery id: 9d6781dd-864d-4197-8726-2600e62d6018\r\n\r\n/home/milovidov/work/ClickHouse/contrib/datasketches-cpp/common/include/MurmurHash3.h:77:16: runtime error: load of misaligned address 0x7f25f4002ba2 for type 'const uint64_t *' (aka 'const unsigned long *'), which requires 8 byte alignment\r\n0x7f25f4002ba2: note: pointer points here\r\n 69 6e  63 74 75 6e 69 71 54 68  65 74 61 20 64 69 73 74  69 6e 63 74 75 6e 69 71  54 68 65 74 61 20\r\n              ^ \r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/milovidov/work/ClickHouse/contrib/datasketches-cpp/common/include/MurmurHash3.h:77:16\r\n```",
  "created_at": "2024-05-15T22:44:19Z",
  "modified_files": [
    "contrib/datasketches-cpp",
    "docs/changelogs/v22.11.1.1360-stable.md",
    "docs/changelogs/v22.8.1.2097-lts.md",
    "docs/changelogs/v23.10.1.1976-stable.md",
    "docs/en/operations/utilities/clickhouse-keeper-client.md",
    "programs/client/Client.cpp",
    "programs/keeper-client/Commands.cpp",
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Common/Logger.h",
    "src/Databases/MySQL/DatabaseMySQL.cpp",
    "src/Dictionaries/SSDCacheDictionaryStorage.h",
    "src/Interpreters/Context.cpp",
    "src/Planner/TableExpressionData.h",
    "src/Server/TCPHandler.cpp",
    "src/Storages/Distributed/DistributedAsyncInsertBatch.cpp",
    "src/Storages/Distributed/DistributedAsyncInsertDirectoryQueue.cpp",
    "src/Storages/MergeTree/DataPartStorageOnDiskBase.cpp",
    "src/Storages/MergeTree/IMergeTreeReader.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp",
    "src/Storages/MergeTree/MergeTreeIndexFullText.cpp",
    "src/Storages/MergeTree/MergeTreeReaderCompact.cpp",
    "src/Storages/StorageMaterializedView.cpp"
  ],
  "modified_test_files": [
    "docker/test/fuzzer/run-fuzzer.sh",
    "tests/integration/test_access_for_functions/test.py",
    "tests/integration/test_sql_user_defined_functions_on_cluster/test.py",
    "tests/integration/test_user_defined_object_persistence/test.py",
    "tests/queries/0_stateless/02722_database_filesystem.sh",
    "tests/queries/0_stateless/03096_text_log_format_string_args_not_empty.sql",
    "b/tests/queries/0_stateless/03155_datasketches_ubsan.reference",
    "b/tests/queries/0_stateless/03155_datasketches_ubsan.sql"
  ]
}