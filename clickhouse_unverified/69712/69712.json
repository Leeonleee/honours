{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69712,
  "instance_id": "ClickHouse__ClickHouse-69712",
  "issue_numbers": [
    "69713"
  ],
  "base_commit": "3ed76059cddf816088d07280763257c572435f49",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex d268a5471ccf..b8d16debbacc 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -2054,35 +2054,40 @@ ClickHouse Avro format supports reading and writing [Avro data files](https://av\n \n The table below shows supported data types and how they match ClickHouse [data types](/docs/en/sql-reference/data-types/index.md) in `INSERT` and `SELECT` queries.\n \n-| Avro data type `INSERT`                     | ClickHouse data type                                                                                                          | Avro data type `SELECT`       |\n-|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|-------------------------------|\n-| `boolean`, `int`, `long`, `float`, `double` | [Int(8\\16\\32)](/docs/en/sql-reference/data-types/int-uint.md), [UInt(8\\16\\32)](/docs/en/sql-reference/data-types/int-uint.md) | `int`                         |\n-| `boolean`, `int`, `long`, `float`, `double` | [Int64](/docs/en/sql-reference/data-types/int-uint.md), [UInt64](/docs/en/sql-reference/data-types/int-uint.md)               | `long`                        |\n-| `boolean`, `int`, `long`, `float`, `double` | [Float32](/docs/en/sql-reference/data-types/float.md)                                                                         | `float`                       |\n-| `boolean`, `int`, `long`, `float`, `double` | [Float64](/docs/en/sql-reference/data-types/float.md)                                                                         | `double`                      |\n-| `bytes`, `string`, `fixed`, `enum`          | [String](/docs/en/sql-reference/data-types/string.md)                                                                         | `bytes` or `string` \\*        |\n-| `bytes`, `string`, `fixed`                  | [FixedString(N)](/docs/en/sql-reference/data-types/fixedstring.md)                                                            | `fixed(N)`                    |\n-| `enum`                                      | [Enum(8\\16)](/docs/en/sql-reference/data-types/enum.md)                                                                       | `enum`                        |\n-| `array(T)`                                  | [Array(T)](/docs/en/sql-reference/data-types/array.md)                                                                        | `array(T)`                    |\n-| `map(V, K)`                                 | [Map(V, K)](/docs/en/sql-reference/data-types/map.md)                                                                         | `map(string, K)`              |\n-| `union(null, T)`, `union(T, null)`          | [Nullable(T)](/docs/en/sql-reference/data-types/date.md)                                                                      | `union(null, T)`              |\n-| `null`                                      | [Nullable(Nothing)](/docs/en/sql-reference/data-types/special-data-types/nothing.md)                                          | `null`                        |\n-| `int (date)` \\**                            | [Date](/docs/en/sql-reference/data-types/date.md), [Date32](docs/en/sql-reference/data-types/date32.md)                       | `int (date)` \\**              |\n-| `long (timestamp-millis)` \\**               | [DateTime64(3)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `long (timestamp-millis)` \\** |\n-| `long (timestamp-micros)` \\**               | [DateTime64(6)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `long (timestamp-micros)` \\** |\n-| `bytes (decimal)`  \\**                      | [DateTime64(N)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `bytes (decimal)`  \\**        |\n-| `int`                                       | [IPv4](/docs/en/sql-reference/data-types/ipv4.md)                                                                             | `int`                         |\n-| `fixed(16)`                                 | [IPv6](/docs/en/sql-reference/data-types/ipv6.md)                                                                             | `fixed(16)`                   |\n-| `bytes (decimal)` \\**                       | [Decimal(P, S)](/docs/en/sql-reference/data-types/decimal.md)                                                                 | `bytes (decimal)` \\**         |\n-| `string (uuid)` \\**                         | [UUID](/docs/en/sql-reference/data-types/uuid.md)                                                                             | `string (uuid)` \\**           |\n-| `fixed(16)`                                 | [Int128/UInt128](/docs/en/sql-reference/data-types/int-uint.md)                                                               | `fixed(16)`                   |\n-| `fixed(32)`                                 | [Int256/UInt256](/docs/en/sql-reference/data-types/int-uint.md)                                                               | `fixed(32)`                   |\n-| `record`                                    | [Tuple](/docs/en/sql-reference/data-types/tuple.md)                                                                           | `record`                      |\n+| Avro data type `INSERT`                     | ClickHouse data type                                                                                                          | Avro data type `SELECT`         |\n+|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|---------------------------------|\n+| `boolean`, `int`, `long`, `float`, `double` | [Int(8\\16\\32)](/docs/en/sql-reference/data-types/int-uint.md), [UInt(8\\16\\32)](/docs/en/sql-reference/data-types/int-uint.md) | `int`                           |\n+| `boolean`, `int`, `long`, `float`, `double` | [Int64](/docs/en/sql-reference/data-types/int-uint.md), [UInt64](/docs/en/sql-reference/data-types/int-uint.md)               | `long`                          |\n+| `boolean`, `int`, `long`, `float`, `double` | [Float32](/docs/en/sql-reference/data-types/float.md)                                                                         | `float`                         |\n+| `boolean`, `int`, `long`, `float`, `double` | [Float64](/docs/en/sql-reference/data-types/float.md)                                                                         | `double`                        |\n+| `bytes`, `string`, `fixed`, `enum`          | [String](/docs/en/sql-reference/data-types/string.md)                                                                         | `bytes` or `string` \\*          |\n+| `bytes`, `string`, `fixed`                  | [FixedString(N)](/docs/en/sql-reference/data-types/fixedstring.md)                                                            | `fixed(N)`                      |\n+| `enum`                                      | [Enum(8\\16)](/docs/en/sql-reference/data-types/enum.md)                                                                       | `enum`                          |\n+| `array(T)`                                  | [Array(T)](/docs/en/sql-reference/data-types/array.md)                                                                        | `array(T)`                      |\n+| `map(V, K)`                                 | [Map(V, K)](/docs/en/sql-reference/data-types/map.md)                                                                         | `map(string, K)`                |\n+| `union(null, T)`, `union(T, null)`          | [Nullable(T)](/docs/en/sql-reference/data-types/date.md)                                                                      | `union(null, T)`                |\n+| `union(T1, T2, \u2026)` \\**                      | [Variant(T1, T2, \u2026)](/docs/en/sql-reference/data-types/variant.md)                                                            | `union(T1, T2, \u2026)` \\**          |\n+| `null`                                      | [Nullable(Nothing)](/docs/en/sql-reference/data-types/special-data-types/nothing.md)                                          | `null`                          |\n+| `int (date)` \\**\\*                          | [Date](/docs/en/sql-reference/data-types/date.md), [Date32](docs/en/sql-reference/data-types/date32.md)                       | `int (date)` \\**\\*              |\n+| `long (timestamp-millis)` \\**\\*             | [DateTime64(3)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `long (timestamp-millis)` \\**\\* |\n+| `long (timestamp-micros)` \\**\\*             | [DateTime64(6)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `long (timestamp-micros)` \\**\\* |\n+| `bytes (decimal)`  \\**\\*                    | [DateTime64(N)](/docs/en/sql-reference/data-types/datetime.md)                                                                | `bytes (decimal)`  \\**\\*        |\n+| `int`                                       | [IPv4](/docs/en/sql-reference/data-types/ipv4.md)                                                                             | `int`                           |\n+| `fixed(16)`                                 | [IPv6](/docs/en/sql-reference/data-types/ipv6.md)                                                                             | `fixed(16)`                     |\n+| `bytes (decimal)` \\**\\*                     | [Decimal(P, S)](/docs/en/sql-reference/data-types/decimal.md)                                                                 | `bytes (decimal)` \\**\\*         |\n+| `string (uuid)` \\**\\*                       | [UUID](/docs/en/sql-reference/data-types/uuid.md)                                                                             | `string (uuid)` \\**\\*           |\n+| `fixed(16)`                                 | [Int128/UInt128](/docs/en/sql-reference/data-types/int-uint.md)                                                               | `fixed(16)`                     |\n+| `fixed(32)`                                 | [Int256/UInt256](/docs/en/sql-reference/data-types/int-uint.md)                                                               | `fixed(32)`                     |\n+| `record`                                    | [Tuple](/docs/en/sql-reference/data-types/tuple.md)                                                                           | `record`                        |\n \n \n \n \\* `bytes` is default, controlled by [output_format_avro_string_column_pattern](/docs/en/operations/settings/settings-formats.md/#output_format_avro_string_column_pattern)\n-\\** [Avro logical types](https://avro.apache.org/docs/current/spec.html#Logical+Types)\n+\n+\\**  [Variant type](/docs/en/sql-reference/data-types/variant) implicitly accepts `null` as a field value, so for example the Avro `union(T1, T2, null)` will be converted to `Variant(T1, T2)`.\n+As a result, when producing Avro from ClickHouse, we have to always include the `null` type to the Avro `union` type set as we don't know if any value is actually `null` during the schema inference.\n+\n+\\**\\* [Avro logical types](https://avro.apache.org/docs/current/spec.html#Logical+Types)\n \n Unsupported Avro logical data types: `time-millis`, `time-micros`, `duration`\n \ndiff --git a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\nindex 2d32214dba04..0119bf95b34a 100644\n--- a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\n@@ -1,5 +1,4 @@\n #include \"AvroRowInputFormat.h\"\n-#include \"DataTypes/DataTypeLowCardinality.h\"\n #if USE_AVRO\n \n #include <numeric>\n@@ -21,20 +20,20 @@\n #include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/DataTypeFixedString.h>\n+#include \"DataTypes/DataTypeLowCardinality.h\"\n #include <DataTypes/DataTypeNothing.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include \"DataTypes/DataTypeVariant.h\"\n #include <DataTypes/IDataType.h>\n #include <DataTypes/DataTypeMap.h>\n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/DataTypeFactory.h>\n \n #include <Columns/ColumnArray.h>\n-#include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnNullable.h>\n-#include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnLowCardinality.h>\n #include <Columns/ColumnTuple.h>\n@@ -44,12 +43,10 @@\n #include <DataFile.hh>\n #include <Decoder.hh>\n #include <Node.hh>\n-#include <NodeConcepts.hh>\n #include <NodeImpl.hh>\n #include <Types.hh>\n #include <ValidSchema.hh>\n \n-#include <Poco/Buffer.h>\n #include <Poco/JSON/Object.h>\n #include <Poco/JSON/Parser.h>\n #include <Poco/Net/HTTPBasicCredentials.h>\n@@ -387,7 +384,7 @@ AvroDeserializer::DeserializeFn AvroDeserializer::createDeserializeFn(const avro\n                     return true;\n                 };\n             }\n-            /// FIXME Support UNION has more than two datatypes.\n+\n             if (root_node->leaves() == 2\n                 && (root_node->leafAt(0)->type() == avro::AVRO_NULL || root_node->leafAt(1)->type() == avro::AVRO_NULL))\n             {\n@@ -434,6 +431,74 @@ AvroDeserializer::DeserializeFn AvroDeserializer::createDeserializeFn(const avro\n                     avro::toString(root_node->leafAt(non_null_union_index)->type()),\n                     target_type->getName());\n             }\n+\n+            if (target.isVariant())\n+            {\n+                const auto & variant_type = assert_cast<const DataTypeVariant &>(*target_type);\n+                const auto & nested_types = variant_type.getVariants();\n+\n+                using AvroUnionIndex = size_t;\n+                std::map<AvroUnionIndex, ColumnVariant::Discriminator> union_index_to_global_discriminator;\n+                std::vector<DeserializeFn> nested_deserializers;\n+                nested_deserializers.reserve(root_node->leaves());\n+\n+                bool union_has_null = false;\n+                for (size_t i = 0; i != root_node->leaves(); ++i)\n+                {\n+                    const auto & avro_node = root_node->leafAt(static_cast<int>(i));\n+                    if (avro_node->type() == avro::AVRO_NULL)\n+                    {\n+                        union_has_null = true;\n+                        nested_deserializers.emplace_back();\n+                        union_index_to_global_discriminator.insert_or_assign(i, ColumnVariant::NULL_DISCRIMINATOR);\n+                        continue;\n+                    }\n+                    const auto variant = AvroSchemaReader::avroNodeToDataType(avro_node);\n+                    nested_deserializers.emplace_back(createDeserializeFn(avro_node, variant));\n+\n+                    auto corresponding_discriminator = variant_type.tryGetVariantDiscriminator(variant->getName());\n+                    if (!corresponding_discriminator)\n+                        throw Exception(\n+                            ErrorCodes::ILLEGAL_COLUMN,\n+                            \"Destination {} and Avro Union containing {} are not compatible. If this is an issue, then let the Input \"\n+                            \"Format infer the schema from the Avro message instead of providing custom Variant type.\",\n+                            variant_type.getName(),\n+                            variant->getName());\n+\n+                    union_index_to_global_discriminator.insert_or_assign(i, std::move(corresponding_discriminator.value()));\n+                }\n+\n+                if (root_node->leaves() != nested_types.size() + (union_has_null ? 1 : 0))\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"The number of (non-null) union types in Avro record ({}) does not match the number of types in destination Variant \"\n+                        \"type ({}).\",\n+                        root_node->leaves() - (union_has_null ? 1 : 0),\n+                        nested_types.size());\n+\n+                return [union_has_null,\n+                        deserializers = std::move(nested_deserializers),\n+                        discriminators_map = std::move(union_index_to_global_discriminator)](IColumn & column, avro::Decoder & decoder)\n+                {\n+                    auto & column_variant = assert_cast<ColumnVariant &>(column);\n+\n+                    const AvroUnionIndex union_index = decoder.decodeUnionIndex();\n+                    const auto global_discriminator = discriminators_map.at(union_index);\n+                    if (union_has_null && global_discriminator == ColumnVariant::NULL_DISCRIMINATOR)\n+                    {\n+                        column_variant.insertDefault();\n+                        return true;\n+                    }\n+\n+                    const auto local_discriminator = column_variant.localDiscriminatorByGlobal(global_discriminator);\n+                    auto & variant = column_variant.getVariantByLocalDiscriminator(local_discriminator);\n+                    deserializers[union_index](variant, decoder);\n+\n+                    column_variant.getLocalDiscriminators().push_back(local_discriminator);\n+                    column_variant.getOffsets().push_back(variant.size() - 1);\n+                    return true;\n+                };\n+            }\n             break;\n         }\n         case avro::AVRO_NULL:\n@@ -1250,11 +1315,15 @@ DataTypePtr AvroSchemaReader::avroNodeToDataType(avro::NodePtr node)\n         case avro::Type::AVRO_NULL:\n             return std::make_shared<DataTypeNothing>();\n         case avro::Type::AVRO_UNION:\n+        {\n+            // Treat union[T] as just T\n             if (node->leaves() == 1)\n             {\n                 return avroNodeToDataType(node->leafAt(0));\n             }\n-            else if (\n+\n+            // Treat union[T, NULL] and union[NULL, T] as Nullable(T)\n+            if (\n                 node->leaves() == 2\n                 && (node->leafAt(0)->type() == avro::Type::AVRO_NULL || node->leafAt(1)->type() == avro::Type::AVRO_NULL))\n             {\n@@ -1262,8 +1331,23 @@ DataTypePtr AvroSchemaReader::avroNodeToDataType(avro::NodePtr node)\n                 auto nested_type = avroNodeToDataType(node->leafAt(nested_leaf_index));\n                 return nested_type->canBeInsideNullable() ? makeNullable(nested_type) : nested_type;\n             }\n-            /// FIXME Support UNION has more than two datatypes.\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Avro type  UNION is not supported for inserting.\");\n+\n+            // Treat union[T1, T2, \u2026] as Variant(T1, T2)\n+            const int avro_union_size = static_cast<int>(node->leaves());\n+\n+            DataTypes nested_types;\n+            nested_types.reserve(avro_union_size);\n+\n+            for (int i = 0; i != avro_union_size; ++i)\n+            {\n+                // We skip the null union type in Variant, since it is encoded using the null discriminator (implicitly all Variants can \"contain null\").\n+                if (node->leafAt(i)->type() == avro::Type::AVRO_NULL) continue;\n+\n+                const auto & avro_node = node->leafAt(i);\n+                nested_types.push_back(avroNodeToDataType(avro_node));\n+            }\n+            return std::make_shared<DataTypeVariant>(nested_types);\n+        }\n         case avro::Type::AVRO_SYMBOLIC:\n             return avroNodeToDataType(avro::resolveSymbol(node));\n         case avro::Type::AVRO_RECORD:\ndiff --git a/src/Processors/Formats/Impl/AvroRowOutputFormat.cpp b/src/Processors/Formats/Impl/AvroRowOutputFormat.cpp\nindex 71ed4f83486c..e505d545f17d 100644\n--- a/src/Processors/Formats/Impl/AvroRowOutputFormat.cpp\n+++ b/src/Processors/Formats/Impl/AvroRowOutputFormat.cpp\n@@ -16,6 +16,7 @@\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeUUID.h>\n #include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypeVariant.h>\n #include <DataTypes/DataTypeMap.h>\n \n #include <Columns/ColumnArray.h>\n@@ -126,7 +127,6 @@ AvroSerializer::SchemaWithSerializeFn createBigIntegerSchemaWithSerializeFn(cons\n }\n \n }\n-\n AvroSerializer::SchemaWithSerializeFn AvroSerializer::createSchemaWithSerializeFn(const DataTypePtr & data_type, size_t & type_name_increment, const String & column_name)\n {\n     ++type_name_increment;\n@@ -259,12 +259,13 @@ AvroSerializer::SchemaWithSerializeFn AvroSerializer::createSchemaWithSerializeF\n         }\n         case TypeIndex::String:\n             if (traits->isStringAsString(column_name))\n-                return {avro::StringSchema(), [](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n+                return {\n+                    avro::StringSchema(),\n+                    [](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n                     {\n                         const std::string_view & s = assert_cast<const ColumnString &>(column).getDataAt(row_num).toView();\n                         encoder.encodeString(std::string(s));\n-                    }\n-                };\n+                    }};\n             else\n                 return {avro::BytesSchema(), [](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n                     {\n@@ -339,26 +340,28 @@ AvroSerializer::SchemaWithSerializeFn AvroSerializer::createSchemaWithSerializeF\n             const auto & array_type = assert_cast<const DataTypeArray &>(*data_type);\n             auto nested_mapping = createSchemaWithSerializeFn(array_type.getNestedType(), type_name_increment, column_name);\n             auto schema = avro::ArraySchema(nested_mapping.schema);\n-            return {schema, [nested_mapping](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n-            {\n-                const ColumnArray & column_array = assert_cast<const ColumnArray &>(column);\n-                const ColumnArray::Offsets & offsets = column_array.getOffsets();\n-                size_t offset = offsets[row_num - 1];\n-                size_t next_offset = offsets[row_num];\n-                size_t row_count = next_offset - offset;\n-                const IColumn & nested_column = column_array.getData();\n-\n-                encoder.arrayStart();\n-                if (row_count > 0)\n-                {\n-                    encoder.setItemCount(row_count);\n-                }\n-                for (size_t i = offset; i < next_offset; ++i)\n+            return {\n+                schema,\n+                [nested_mapping](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n                 {\n-                    nested_mapping.serialize(nested_column, i, encoder);\n-                }\n-                encoder.arrayEnd();\n-            }};\n+                    const ColumnArray & column_array = assert_cast<const ColumnArray &>(column);\n+                    const ColumnArray::Offsets & offsets = column_array.getOffsets();\n+                    size_t offset = offsets[row_num - 1];\n+                    size_t next_offset = offsets[row_num];\n+                    size_t row_count = next_offset - offset;\n+                    const IColumn & nested_column = column_array.getData();\n+\n+                    encoder.arrayStart();\n+                    if (row_count > 0)\n+                    {\n+                        encoder.setItemCount(row_count);\n+                    }\n+                    for (size_t i = offset; i < next_offset; ++i)\n+                    {\n+                        nested_mapping.serialize(nested_column, i, encoder);\n+                    }\n+                    encoder.arrayEnd();\n+                }};\n         }\n         case TypeIndex::Nullable:\n         {\n@@ -368,26 +371,23 @@ AvroSerializer::SchemaWithSerializeFn AvroSerializer::createSchemaWithSerializeF\n             {\n                 return nested_mapping;\n             }\n-\n             avro::UnionSchema union_schema;\n             union_schema.addType(avro::NullSchema());\n             union_schema.addType(nested_mapping.schema);\n-            return {\n-                union_schema,\n-                [nested_mapping](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n+            return {union_schema, [nested_mapping](const IColumn & column, size_t row_num, avro::Encoder & encoder)\n+            {\n+                const ColumnNullable & col = assert_cast<const ColumnNullable &>(column);\n+                if (!col.isNullAt(row_num))\n                 {\n-                    const ColumnNullable & col = assert_cast<const ColumnNullable &>(column);\n-                    if (!col.isNullAt(row_num))\n-                    {\n-                        encoder.encodeUnionIndex(1);\n-                        nested_mapping.serialize(col.getNestedColumn(), row_num, encoder);\n-                    }\n-                    else\n-                    {\n-                        encoder.encodeUnionIndex(0);\n-                        encoder.encodeNull();\n-                    }\n-                }};\n+                    encoder.encodeUnionIndex(1);\n+                    nested_mapping.serialize(col.getNestedColumn(), row_num, encoder);\n+                }\n+                else\n+                {\n+                    encoder.encodeUnionIndex(0);\n+                    encoder.encodeNull();\n+                }\n+            }};\n         }\n         case TypeIndex::LowCardinality:\n         {\n@@ -401,6 +401,49 @@ AvroSerializer::SchemaWithSerializeFn AvroSerializer::createSchemaWithSerializeF\n         }\n         case TypeIndex::Nothing:\n             return {avro::NullSchema(), [](const IColumn &, size_t, avro::Encoder & encoder) { encoder.encodeNull(); }};\n+        case TypeIndex::Variant:\n+        {\n+            const auto & variant_type = assert_cast<const DataTypeVariant &>(*data_type);\n+\n+            avro::UnionSchema union_schema;\n+            const auto & nested_types = variant_type.getVariants();\n+\n+            std::vector<SerializeFn> nested_serializers;\n+            nested_serializers.reserve(nested_types.size());\n+\n+            for (const auto & nested_type : nested_types)\n+            {\n+                const auto [schema, serialize] = createSchemaWithSerializeFn(nested_type, type_name_increment, column_name);\n+                union_schema.addType(schema);\n+                nested_serializers.push_back(serialize);\n+            }\n+\n+            // Since Variants have no schema-guaranteed nullability, we need to always include the null as one of the options in Avro Union.\n+            // This is because Variant is considered Null in case it doesn't have any of the variants defined.\n+            const auto null_union_index = nested_types.size();\n+            union_schema.addType(avro::NullSchema());\n+\n+            return {\n+                static_cast<avro::Schema>(union_schema),\n+                [serializers = std::move(nested_serializers),\n+                 null_union_index](const IColumn & column, const size_t row_num, avro::Encoder & encoder)\n+                {\n+                    const auto & col = assert_cast<const ColumnVariant &>(column);\n+                    const auto global_discriminator = col.globalDiscriminatorAt(row_num);\n+\n+                    if (global_discriminator == ColumnVariant::NULL_DISCRIMINATOR)\n+                    {\n+                        encoder.encodeUnionIndex(null_union_index);\n+                        encoder.encodeNull();\n+                    }\n+                    else\n+                    {\n+                        size_t offset = col.offsetAt(row_num);\n+                        encoder.encodeUnionIndex(global_discriminator);\n+                        serializers[global_discriminator](col.getVariantByGlobalDiscriminator(global_discriminator), offset, encoder);\n+                    }\n+                }};\n+        }\n         case TypeIndex::Tuple:\n         {\n             const auto & tuple_type = assert_cast<const DataTypeTuple &>(*data_type);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03237_avro_union_in_complex_types.reference b/tests/queries/0_stateless/03237_avro_union_in_complex_types.reference\nnew file mode 100644\nindex 000000000000..758fd07a0da1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03237_avro_union_in_complex_types.reference\n@@ -0,0 +1,81 @@\n+== DESCRIBE ==\n+string_only\tString\t\t\t\t\t\n+string_or_null\tNullable(String)\t\t\t\t\t\n+null_or_string\tNullable(String)\t\t\t\t\t\n+double_or_string\tVariant(Float64, String)\t\t\t\t\t\n+string_or_double\tVariant(Float64, String)\t\t\t\t\t\n+null_or_string_or_double\tVariant(Float64, String)\t\t\t\t\t\n+string_or_double_or_null\tVariant(Float64, String)\t\t\t\t\t\n+string_or_float_or_long\tVariant(Float32, Int64, String)\t\t\t\t\t\n+long_or_string_or_float\tVariant(Float32, Int64, String)\t\t\t\t\t\n+double_or_null_or_string_or_long\tVariant(Float64, Int64, String)\t\t\t\t\t\n+double_or_long_or_string_in_array\tArray(Variant(Float64, Int64, String))\t\t\t\t\t\n+double_or_string_or_long_or_null_in_map\tMap(String, Variant(Float64, Int64, String))\t\t\t\t\t\n+\n+== SELECT variantType ==\n+String\t0\t1\tFloat64\tString\tString\tFloat64\tString\tFloat32\tFloat64\t['Float64','String','Int64']\t['Float64','None']\n+String\t1\t0\tString\tFloat64\tFloat64\tString\tFloat32\tString\tInt64\t['Float64','Int64','String']\t['String','Float64']\n+String\t0\t1\tFloat64\tString\tNone\tNone\tInt64\tFloat32\tString\t['Float64','Int64','String']\t['Float64','String']\n+String\t1\t0\tFloat64\tFloat64\tFloat64\tString\tString\tFloat32\tNone\t['Float64','String','Int64']\t['String','Float64']\n+String\t0\t0\tFloat64\tString\tNone\tFloat64\tFloat32\tString\tFloat64\t['Float64','Int64','String']\t['Int64','None']\n+\n+== SELECT * ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\n+\n+== SELECT * WITH CustomSchema ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\n+\n+== SELECT * WITH CustomSchema SwappedFirstLastVariant ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\n+\n+== SELECT * WITH CustomSchema Float32 instead of Float64 ==\n+2\n+\n+== SELECT * WITH CustomSchema more types than expected ==\n+2\n+\n+== SELECT * WITH CustomSchema less types than expected ==\n+2\n+\n+== CREATE TABLE avro_union_test_03237 ==\n+\n+== SELECT * FORMAT Avro | INSERT INTO avro_union_test_03237 FORMAT Avro ==\n+\n+== SELECT * FROM avro_union_test_03237 ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\n+\n+== TRUNCATE TABLE avro_union_test_03237 ==\n+\n+== insert into table avro_union_test_03237 select * from file('union_in_complex_types.avro') ==\n+\n+== SELECT * FROM avro_union_test_03237 ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\n+\n+== insert into table function file('union_in_complex_types_2.avro') select * from file('union_in_complex_types.avro') ==\n+\n+== SELECT * FROM file('union_in_complex_types_2.avro') ==\n+alpha\tbravo\t\\N\t3.1415926535\tcharlie\tdelta\t2.7182818284\techo\t42\t-3.1415926535\t[1.4142135623,'foxtrot',-100]\t{'key1':3.1415926535,'key2':NULL}\n+golf\t\\N\thotel\tindia\t1.6180339887\t3.1415926535\tjuliet\t7.38906\tkilo\t1000\t[-1.6180339887,0,'lima']\t{'key3':'mike','key4':1e-9}\n+november\toscar\t\\N\t10000000000\tpapa\t\\N\t\\N\t-5000000\t1.7320508\tquebec\t[2.7182818284,1729,'romeo']\t{'key5':-2.7182818284,'key6':'sierra'}\n+tango\t\\N\tuniform\t-1.4142135623\t-1.6180339887\t0.00001\tvictor\twhiskey\t-987654340\t\\N\t[-3.1415926535,'xray',31415926535]\t{'key7':'yankee','key8':-987.654}\n+zulu\talpha1\tbravo1\t2.718281828\tcharlie1\t\\N\t-1.7320508075\t1000000\tdelta1\t-1.6180339887\t[-2.7182818284,123456789,'echo1']\t{'key9':9223372036854775807,'key10':NULL}\ndiff --git a/tests/queries/0_stateless/03237_avro_union_in_complex_types.sh b/tests/queries/0_stateless/03237_avro_union_in_complex_types.sh\nnew file mode 100755\nindex 000000000000..ecbd19d8056b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03237_avro_union_in_complex_types.sh\n@@ -0,0 +1,166 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel, no-fasttest\n+\n+set -e\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+DATA_DIR=$CUR_DIR/data_avro\n+\n+CH_CLIENT=\"$CLICKHOUSE_CLIENT --allow_experimental_variant_type=1\"\n+\n+cp $DATA_DIR/union_in_complex_types.avro $CLICKHOUSE_USER_FILES/union_in_complex_types.avro\n+\n+echo \"== DESCRIBE ==\"\n+$CH_CLIENT -q \"desc file('union_in_complex_types.avro')\"\n+echo\n+\n+echo \"== SELECT variantType ==\"\n+$CH_CLIENT -q \"\n+  SELECT\n+      toTypeName(string_only),\n+      string_or_null IS NULL,\n+      null_or_string IS NULL,\n+      * EXCEPT (string_only, string_or_null, null_or_string, double_or_long_or_string_in_array, double_or_string_or_long_or_null_in_map) APPLY (x -> variantType(x)),\n+      arrayMap(x -> variantType(x), double_or_long_or_string_in_array),\n+      arrayMap(x -> variantType(x), mapValues(double_or_string_or_long_or_null_in_map))\n+  FROM file('union_in_complex_types.avro')\"\n+echo\n+\n+echo \"== SELECT * ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro')\"\n+echo\n+\n+echo \"== SELECT * WITH CustomSchema ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro', 'Avro', '\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(Float64, String),\n+  string_or_double Variant(Float64, String),\n+  null_or_string_or_double Variant(Float64, String),\n+  string_or_double_or_null Variant(Float64, String),\n+  string_or_float_or_long Variant(Float32, Int64, String),\n+  long_or_string_or_float Variant(Float32, Int64, String),\n+  double_or_null_or_string_or_long Variant(Float64, String, Int64),\n+  double_or_long_or_string_in_array Array(Variant(Float64, String, Int64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(Float64, Int64, String))\n+');\"\n+echo\n+\n+echo \"== SELECT * WITH CustomSchema SwappedFirstLastVariant ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro', 'Avro', '\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(String, Float64),\n+  string_or_double Variant(String, Float64),\n+  null_or_string_or_double Variant(String, Float64),\n+  string_or_double_or_null Variant(String, Float64),\n+  string_or_float_or_long Variant(String, Int64, Float32),\n+  long_or_string_or_float Variant(String, Int64, Float32),\n+  double_or_null_or_string_or_long Variant(Int64, String, Float64),\n+  double_or_long_or_string_in_array Array(Variant(Int64, String, Float64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(String, Int64, Float64))\n+');\"\n+echo\n+\n+echo \"== SELECT * WITH CustomSchema Float32 instead of Float64 ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro', 'Avro', '\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(Float32, String),\n+  string_or_double Variant(Float32, String),\n+  null_or_string_or_double Variant(Float32, String),\n+  string_or_double_or_null Variant(Float32, String),\n+  string_or_float_or_long Variant(Float32, Int64, String),\n+  long_or_string_or_float Variant(Float32, Int64, String),\n+  double_or_null_or_string_or_long Variant(Float32, String, Int64),\n+  double_or_long_or_string_in_array Array(Variant(Float32, String, Int64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(Float32, Int64, String))\n+');\" 2>&1 | grep -c 'DB::Exception: Destination Variant(Float32, String) and Avro Union containing Float64 are not compatible.'\n+echo\n+\n+echo \"== SELECT * WITH CustomSchema more types than expected ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro', 'Avro', '\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(Float64, String, Int64),\n+  string_or_double Variant(Float64, String, Int64),\n+  null_or_string_or_double Variant(Float64, String, Int64),\n+  string_or_double_or_null Variant(Float64, String, Int64),\n+  string_or_float_or_long Variant(Float32, Int64, String, Int64),\n+  long_or_string_or_float Variant(Float32, Int64, String, Int64),\n+  double_or_null_or_string_or_long Variant(Float64, String, Int64, Int64),\n+  double_or_long_or_string_in_array Array(Variant(Float64, String, Int64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(Float64, Int64, String))\n+');\" 2>&1 | grep -c 'DB::Exception: The number of (non-null) union types in Avro record (2) does not match the number of types in destination Variant type (3).'\n+echo\n+\n+echo \"== SELECT * WITH CustomSchema less types than expected ==\"\n+$CH_CLIENT -q \"select * from file('union_in_complex_types.avro', 'Avro', '\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(Float64, String),\n+  string_or_double Variant(Float64, String),\n+  null_or_string_or_double Variant(Float64, String),\n+  string_or_double_or_null Variant(Float64, String),\n+  string_or_float_or_long Variant(Float32, Int64, String),\n+  long_or_string_or_float Variant(Float32, Int64, String),\n+  double_or_null_or_string_or_long Variant(Float64, String, Int64),\n+  double_or_long_or_string_in_array Array(Variant(Float64, String, Int64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(Float64, Int64))\n+');\" 2>&1 | grep -c 'DB::Exception: Destination Variant(Float64, Int64) and Avro Union containing String are not compatible.'\n+echo\n+\n+echo \"== CREATE TABLE avro_union_test_03237 ==\"\n+$CH_CLIENT -q \"CREATE TABLE avro_union_test_03237 (\n+  string_only String,\n+  string_or_null Nullable(String),\n+  null_or_string Nullable(String),\n+  double_or_string Variant(Float64, String),\n+  string_or_double Variant(Float64, String),\n+  null_or_string_or_double Variant(Float64, String),\n+  string_or_double_or_null Variant(Float64, String),\n+  string_or_float_or_long Variant(Float32, Int64, String),\n+  long_or_string_or_float Variant(Float32, Int64, String),\n+  double_or_null_or_string_or_long Variant(Float64, String, Int64),\n+  double_or_long_or_string_in_array Array(Variant(Float64, String, Int64)),\n+  double_or_string_or_long_or_null_in_map Map(String, Variant(Float64, Int64, String))\n+) ENGINE = MergeTree ORDER BY tuple()\"\n+echo\n+\n+echo \"== SELECT * FORMAT Avro | INSERT INTO avro_union_test_03237 FORMAT Avro ==\"\n+$CH_CLIENT -q \"SELECT * FROM file('union_in_complex_types.avro') FORMAT Avro\" | tee /tmp/out.avro | $CH_CLIENT -q \"INSERT INTO avro_union_test_03237 FORMAT Avro\"\n+echo\n+\n+\n+echo \"== SELECT * FROM avro_union_test_03237 ==\"\n+$CH_CLIENT -q \"SELECT * FROM avro_union_test_03237\"\n+echo\n+\n+echo \"== TRUNCATE TABLE avro_union_test_03237 ==\"\n+$CH_CLIENT -q \"TRUNCATE TABLE avro_union_test_03237\"\n+echo\n+\n+echo \"== insert into table avro_union_test_03237 select * from file('union_in_complex_types.avro') ==\"\n+$CH_CLIENT -q \"insert into table avro_union_test_03237 select * from file('union_in_complex_types.avro')\"\n+echo\n+\n+echo \"== SELECT * FROM avro_union_test_03237 ==\"\n+$CH_CLIENT -q \"SELECT * FROM avro_union_test_03237\"\n+echo\n+\n+rm -f $CLICKHOUSE_USER_FILES/union_in_complex_types_2.avro\n+\n+echo \"== insert into table function file('union_in_complex_types_2.avro') select * from file('union_in_complex_types.avro') ==\"\n+$CH_CLIENT -q \"insert into table function file('union_in_complex_types_2.avro') select * from file('union_in_complex_types.avro') format Avro\"\n+echo\n+\n+echo \"== SELECT * FROM file('union_in_complex_types_2.avro') ==\"\n+$CH_CLIENT -q \"SELECT * FROM file('union_in_complex_types_2.avro')\"\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/data_avro/union_in_complex_types.avro b/tests/queries/0_stateless/data_avro/union_in_complex_types.avro\nnew file mode 100644\nindex 000000000000..4e9d62f07c2d\nBinary files /dev/null and b/tests/queries/0_stateless/data_avro/union_in_complex_types.avro differ\ndiff --git a/tests/queries/0_stateless/data_avro/union_in_complex_types.generate_avro.py b/tests/queries/0_stateless/data_avro/union_in_complex_types.generate_avro.py\nnew file mode 100644\nindex 000000000000..8d3f5437cb57\n--- /dev/null\n+++ b/tests/queries/0_stateless/data_avro/union_in_complex_types.generate_avro.py\n@@ -0,0 +1,121 @@\n+import io\n+\n+import avro.datafile\n+import avro.io\n+import avro.schema\n+\n+# Define the schema\n+schema = avro.schema.parse(\n+    \"\"\"\n+    {\n+      \"type\": \"record\",\n+      \"name\": \"TestRecord\",\n+      \"fields\": [\n+        {\"name\": \"string_only\", \"type\": [\"string\"]},\n+        {\"name\": \"string_or_null\", \"type\": [\"string\", \"null\"]},\n+        {\"name\": \"null_or_string\", \"type\": [\"null\", \"string\"]},\n+        {\"name\": \"double_or_string\", \"type\": [\"double\", \"string\"]},\n+        {\"name\": \"string_or_double\", \"type\": [\"string\", \"double\"]},\n+        {\"name\": \"null_or_string_or_double\", \"type\": [\"null\", \"string\", \"double\"]},\n+        {\"name\": \"string_or_double_or_null\", \"type\": [\"string\", \"double\", \"null\"]},\n+        {\"name\": \"string_or_float_or_long\", \"type\": [\"string\", \"float\", \"long\"]},\n+        {\"name\": \"long_or_string_or_float\", \"type\": [\"long\", \"string\", \"float\"]},\n+        {\"name\": \"double_or_null_or_string_or_long\", \"type\": [\"double\", \"null\", \"string\", \"long\"]},\n+        {\"name\": \"double_or_long_or_string_in_array\", \"type\": {\n+          \"type\": \"array\",\n+          \"items\": [\"double\", \"long\", \"string\"]\n+        }},\n+        {\"name\": \"double_or_string_or_long_or_null_in_map\", \"type\": {\n+          \"type\": \"map\",\n+          \"values\": [\"double\", \"string\", \"long\", \"null\"]\n+        }}\n+      ]\n+    }\n+    \"\"\"\n+)\n+\n+records = [\n+    {\n+        \"string_only\": \"alpha\",\n+        \"string_or_null\": \"bravo\",\n+        \"null_or_string\": None,\n+        \"double_or_string\": 3.1415926535,\n+        \"string_or_double\": \"charlie\",\n+        \"null_or_string_or_double\": \"delta\",\n+        \"string_or_double_or_null\": 2.7182818284,\n+        \"string_or_float_or_long\": \"echo\",\n+        \"long_or_string_or_float\": 42,\n+        \"double_or_null_or_string_or_long\": -3.1415926535,\n+        \"double_or_long_or_string_in_array\": [1.4142135623, \"foxtrot\", -100],\n+        \"double_or_string_or_long_or_null_in_map\": {\"key1\": 3.1415926535, \"key2\": None},\n+    },\n+    {\n+        \"string_only\": \"golf\",\n+        \"string_or_null\": None,\n+        \"null_or_string\": \"hotel\",\n+        \"double_or_string\": \"india\",\n+        \"string_or_double\": 1.6180339887,\n+        \"null_or_string_or_double\": 3.1415926535,\n+        \"string_or_double_or_null\": \"juliet\",\n+        \"string_or_float_or_long\": 7.38906,\n+        \"long_or_string_or_float\": \"kilo\",\n+        \"double_or_null_or_string_or_long\": 1000,\n+        \"double_or_long_or_string_in_array\": [-1.6180339887, 0, \"lima\"],\n+        \"double_or_string_or_long_or_null_in_map\": {\"key3\": \"mike\", \"key4\": 1e-9},\n+    },\n+    {\n+        \"string_only\": \"november\",\n+        \"string_or_null\": \"oscar\",\n+        \"null_or_string\": None,\n+        \"double_or_string\": 1e10,\n+        \"string_or_double\": \"papa\",\n+        \"null_or_string_or_double\": None,\n+        \"string_or_double_or_null\": None,\n+        \"string_or_float_or_long\": -5000000,\n+        \"long_or_string_or_float\": 1.7320508,\n+        \"double_or_null_or_string_or_long\": \"quebec\",\n+        \"double_or_long_or_string_in_array\": [2.7182818284, 1729, \"romeo\"],\n+        \"double_or_string_or_long_or_null_in_map\": {\n+            \"key5\": -2.7182818284,\n+            \"key6\": \"sierra\",\n+        },\n+    },\n+    {\n+        \"string_only\": \"tango\",\n+        \"string_or_null\": None,\n+        \"null_or_string\": \"uniform\",\n+        \"double_or_string\": -1.4142135623,\n+        \"string_or_double\": -1.6180339887,\n+        \"null_or_string_or_double\": 1e-5,\n+        \"string_or_double_or_null\": \"victor\",\n+        \"string_or_float_or_long\": \"whiskey\",\n+        \"long_or_string_or_float\": -987654321,\n+        \"double_or_null_or_string_or_long\": None,\n+        \"double_or_long_or_string_in_array\": [-3.1415926535, \"xray\", 31415926535],\n+        \"double_or_string_or_long_or_null_in_map\": {\"key7\": \"yankee\", \"key8\": -987.654},\n+    },\n+    {\n+        \"string_only\": \"zulu\",\n+        \"string_or_null\": \"alpha1\",\n+        \"null_or_string\": \"bravo1\",\n+        \"double_or_string\": 2.718281828,\n+        \"string_or_double\": \"charlie1\",\n+        \"null_or_string_or_double\": None,\n+        \"string_or_double_or_null\": -1.7320508075,\n+        \"string_or_float_or_long\": 1e6,\n+        \"long_or_string_or_float\": \"delta1\",\n+        \"double_or_null_or_string_or_long\": -1.6180339887,\n+        \"double_or_long_or_string_in_array\": [-2.7182818284, 123456789, \"echo1\"],\n+        \"double_or_string_or_long_or_null_in_map\": {\n+            \"key9\": 9223372036854775807,\n+            \"key10\": None,\n+        },\n+    },\n+]\n+\n+# Write the data to an Avro file\n+with open(\"union_in_complex_types.avro\", \"wb\") as avro_file:\n+    writer = avro.datafile.DataFileWriter(avro_file, avro.io.DatumWriter(), schema)\n+    for record in records:\n+        writer.append(record)\n+    writer.close()\n",
  "problem_statement": "Implement full Avro Union support for Avro Format SerDe\n**Describe the unexpected behaviour**\n\nCurrently, Avro Union is supported only for these two special cases:\n1. The Avro Union contains only a single type. Maps directly to `T`.\n2. The Avro Union has exactly two types, while one of them is null. Maps to `Nullable(T)`.\n\nI would expect the following Avro Schema to be supported:\n\n```json\n{\n  \"type\": \"record\",\n  \"name\": \"TestRecord\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"variant_with_double\", \"type\": [\"double\", \"string\"]},\n    {\"name\": \"variant_array\", \"type\": {\n      \"type\": \"array\",\n      \"items\": [\"double\", \"string\"]\n    }},\n    {\"name\": \"variant_map\", \"type\": {\n      \"type\": \"map\",\n      \"values\": [\"double\", \"string\"]\n    }}\n  ]\n}\n```\n\nClickHouse already supports `Variant` type proposed by #54864 and implemented in https://github.com/ClickHouse/ClickHouse/pull/58047. Though still experimental, I suggest we use it as the ClickHouse solution to store Avro Union type.\n\nSo I'd like to produce generic `Variant(T1, T2, \u2026)` from generic `avro::UnionType(T1, T2, \u2026.)`.\n\n**How to reproduce**\n\nTry to read Avro file containing the schema mentioned above. The URL in the queries below is pointing to my branch in my fork, specifically to the file I am using for functionality tests in the Pull Request https://github.com/ClickHouse/ClickHouse/pull/69712 which should resolve this issue.\n\n```sql\nSET max_http_get_redirects = 2;\n\nDESCRIBE TABLE url('https://github.com/jirislav/ClickHouse/raw/refs/heads/add_support_for_avro_union_input_format/tests/queries/0_stateless/data_avro/union_in_complex_types.avro');\n\nSELECT * FROM\nurl('https://github.com/jirislav/ClickHouse/raw/refs/heads/add_support_for_avro_union_input_format/tests/queries/0_stateless/data_avro/union_in_complex_types.avro');\n```\n\n<details><summary>How I generated the avro file.</summary>\n\n```sh\npip3 install avro-python3\n```\n\n```py\n#!/usr/bin/env python3\n\nimport avro.schema\nimport avro.datafile\nimport avro.io\nimport io\n\n# Define the schema\nschema = avro.schema.parse('''\n{\n  \"type\": \"record\",\n  \"name\": \"TestRecord\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"variant_with_double\", \"type\": [\"double\", \"string\"]},\n    {\"name\": \"variant_array\", \"type\": {\n      \"type\": \"array\",\n      \"items\": [\"double\", \"string\"]\n    }},\n    {\"name\": \"variant_map\", \"type\": {\n      \"type\": \"map\",\n      \"values\": [\"double\", \"string\"]\n    }}\n  ]\n}\n''')\n\n# Create sample data\nrecords = [\n    {\n        \"name\": \"record1\",\n        \"variant_with_double\": 42.0,\n        \"variant_array\": [42.0, \"test1\"],\n        \"variant_map\": {\"key1\": 42.0, \"key2\": \"value1\"}\n    },\n    {\n        \"name\": \"record2\",\n        \"variant_with_double\": \"variant_string\",\n        \"variant_array\": [\"test2\", 23.5],\n        \"variant_map\": {\"key3\": \"value2\", \"key4\": 15.7}\n    },\n    {\n        \"name\": \"record3\",\n        \"variant_with_double\": 15.5,\n        \"variant_array\": [11.0, \"test3\"],\n        \"variant_map\": {\"key5\": 100.0, \"key6\": \"value3\"}\n    }\n]\n\n# Write the data to an Avro file\nwith open('union_in_complex_types.avro', 'wb') as avro_file:\n    writer = avro.datafile.DataFileWriter(avro_file, avro.io.DatumWriter(), schema)\n    for record in records:\n        writer.append(record)\n    writer.close()\n```\n\n</details>\n\n```[tasklist]\n### Tasks\n- [ ] https://github.com/ClickHouse/ClickHouse/pull/69712\n- [ ] https://github.com/ClickHouse/ClickHouse/pull/69712\n```\n\n",
  "hints_text": "",
  "created_at": "2024-09-17T23:23:15Z"
}