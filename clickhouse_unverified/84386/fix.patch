diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp
index a98960b10b5a..7d4e8e180299 100644
--- a/src/Storages/MergeTree/KeyCondition.cpp
+++ b/src/Storages/MergeTree/KeyCondition.cpp
@@ -224,14 +224,35 @@ static String firstStringThatIsGreaterThanAllStringsWithPrefix(const String & pr
     return res;
 }
 
+namespace
+{
+bool isNaN(const Field & field)
+{
+    if (field.getType() != Field::Types::Float64)
+        return false;
+
+    const double value = field.safeGet<Float64>();
+    return std::isnan(value);
+}
+}
+
 const KeyCondition::AtomMap KeyCondition::atom_map
 {
         {
             "notEquals",
             [] (RPNElement & out, const Field & value)
             {
-                out.function = RPNElement::FUNCTION_NOT_IN_RANGE;
-                out.range = Range(value);
+                if (isNaN(value))
+                {
+                    /// Convert data <> NaN -> data IN [-INF, INF]
+                    out.function = RPNElement::FUNCTION_IN_RANGE;
+                    out.range = Range::createWholeUniverse();
+                }
+                else
+                {
+                    out.function = RPNElement::FUNCTION_NOT_IN_RANGE;
+                    out.range = Range(value);
+                }
                 return true;
             }
         },
@@ -240,7 +261,15 @@ const KeyCondition::AtomMap KeyCondition::atom_map
             [] (RPNElement & out, const Field & value)
             {
                 out.function = RPNElement::FUNCTION_IN_RANGE;
-                out.range = Range(value);
+                if (isNaN(value))
+                {
+                    /// Convert data = NaN -> data IN (INF, -INF)
+                    out.range = Range(POSITIVE_INFINITY, false, NEGATIVE_INFINITY, false);
+                }
+                else
+                {
+                    out.range = Range(value);
+                }
                 return true;
             }
         },
@@ -3214,14 +3243,13 @@ BoolMask KeyCondition::checkInHyperrectangle(
                                 hyperrectangle.size(), element.key_column, element.toString());
             }
 
-            const Range * key_range = &hyperrectangle[element.key_column];
+            Range key_range = hyperrectangle[element.key_column];
 
             /// The case when the column is wrapped in a chain of possibly monotonic functions.
-            Range transformed_range = Range::createWholeUniverse();
             if (!element.monotonic_functions_chain.empty())
             {
                 std::optional<Range> new_range = applyMonotonicFunctionsChainToRange(
-                    *key_range,
+                    key_range,
                     element.monotonic_functions_chain,
                     data_types[element.key_column],
                     single_point
@@ -3232,12 +3260,11 @@ BoolMask KeyCondition::checkInHyperrectangle(
                     rpn_stack.emplace_back(true, true);
                     continue;
                 }
-                transformed_range = *new_range;
-                key_range = &transformed_range;
+                key_range = *new_range;
             }
 
-            bool intersects = element.range.intersectsRange(*key_range);
-            bool contains = element.range.containsRange(*key_range);
+            bool intersects = element.range.intersectsRange(key_range);
+            bool contains = element.range.containsRange(key_range);
 
             rpn_stack.emplace_back(intersects, !contains);
 
