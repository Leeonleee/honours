{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84386,
  "instance_id": "ClickHouse__ClickHouse-84386",
  "issue_numbers": [
    "75523"
  ],
  "base_commit": "f713664d0a55845b9f63c7a93423fd5f181c69ed",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex a98960b10b5a..7d4e8e180299 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -224,14 +224,35 @@ static String firstStringThatIsGreaterThanAllStringsWithPrefix(const String & pr\n     return res;\n }\n \n+namespace\n+{\n+bool isNaN(const Field & field)\n+{\n+    if (field.getType() != Field::Types::Float64)\n+        return false;\n+\n+    const double value = field.safeGet<Float64>();\n+    return std::isnan(value);\n+}\n+}\n+\n const KeyCondition::AtomMap KeyCondition::atom_map\n {\n         {\n             \"notEquals\",\n             [] (RPNElement & out, const Field & value)\n             {\n-                out.function = RPNElement::FUNCTION_NOT_IN_RANGE;\n-                out.range = Range(value);\n+                if (isNaN(value))\n+                {\n+                    /// Convert data <> NaN -> data IN [-INF, INF]\n+                    out.function = RPNElement::FUNCTION_IN_RANGE;\n+                    out.range = Range::createWholeUniverse();\n+                }\n+                else\n+                {\n+                    out.function = RPNElement::FUNCTION_NOT_IN_RANGE;\n+                    out.range = Range(value);\n+                }\n                 return true;\n             }\n         },\n@@ -240,7 +261,15 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n             [] (RPNElement & out, const Field & value)\n             {\n                 out.function = RPNElement::FUNCTION_IN_RANGE;\n-                out.range = Range(value);\n+                if (isNaN(value))\n+                {\n+                    /// Convert data = NaN -> data IN (INF, -INF)\n+                    out.range = Range(POSITIVE_INFINITY, false, NEGATIVE_INFINITY, false);\n+                }\n+                else\n+                {\n+                    out.range = Range(value);\n+                }\n                 return true;\n             }\n         },\n@@ -3214,14 +3243,13 @@ BoolMask KeyCondition::checkInHyperrectangle(\n                                 hyperrectangle.size(), element.key_column, element.toString());\n             }\n \n-            const Range * key_range = &hyperrectangle[element.key_column];\n+            Range key_range = hyperrectangle[element.key_column];\n \n             /// The case when the column is wrapped in a chain of possibly monotonic functions.\n-            Range transformed_range = Range::createWholeUniverse();\n             if (!element.monotonic_functions_chain.empty())\n             {\n                 std::optional<Range> new_range = applyMonotonicFunctionsChainToRange(\n-                    *key_range,\n+                    key_range,\n                     element.monotonic_functions_chain,\n                     data_types[element.key_column],\n                     single_point\n@@ -3232,12 +3260,11 @@ BoolMask KeyCondition::checkInHyperrectangle(\n                     rpn_stack.emplace_back(true, true);\n                     continue;\n                 }\n-                transformed_range = *new_range;\n-                key_range = &transformed_range;\n+                key_range = *new_range;\n             }\n \n-            bool intersects = element.range.intersectsRange(*key_range);\n-            bool contains = element.range.containsRange(*key_range);\n+            bool intersects = element.range.intersectsRange(key_range);\n+            bool contains = element.range.containsRange(key_range);\n \n             rpn_stack.emplace_back(intersects, !contains);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00944_minmax_nan.reference b/tests/queries/0_stateless/00944_minmax_nan.reference\nnew file mode 100644\nindex 000000000000..3dcb98d31b91\n--- /dev/null\n+++ b/tests/queries/0_stateless/00944_minmax_nan.reference\n@@ -0,0 +1,21 @@\n+NaN comparison\n+0\n+7\n+0\n+7\n+2\n+5\n+MinMax index should skip all granules for column = NaN comparison\n+Description: minmax GRANULARITY 1\n+Parts: 0/1\n+Granules: 0/1\n+Description: minmax GRANULARITY 1\n+Parts: 0/1\n+Granules: 0/1\n+MinMax index should use all granules for column <> NaN comparison\n+Description: minmax GRANULARITY 1\n+Parts: 1/1\n+Granules: 1/1\n+Description: minmax GRANULARITY 1\n+Parts: 1/1\n+Granules: 1/1\ndiff --git a/tests/queries/0_stateless/00944_minmax_nan.sql b/tests/queries/0_stateless/00944_minmax_nan.sql\nnew file mode 100644\nindex 000000000000..bb6343162140\n--- /dev/null\n+++ b/tests/queries/0_stateless/00944_minmax_nan.sql\n@@ -0,0 +1,62 @@\n+SET parallel_replicas_local_plan = 1;\n+\n+-- Test for issue #75523\n+\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab (\n+  id UInt64,\n+  col Float,\n+  INDEX col_idx col TYPE minmax\n+)\n+ENGINE = MergeTree()\n+ORDER BY id; -- This is important. We want to have additional primary index that does not use the column `col`.\n+\n+INSERT INTO tab VALUES\n+    (1, 1.0),\n+    (2, inf),\n+    (3, 2.0),\n+    (4, -inf),\n+    (5, 3.0),\n+    (6, nan),\n+    (7, -nan);\n+\n+SELECT 'NaN comparison';\n+SELECT count() FROM tab WHERE col = nan;\n+SELECT count() FROM tab WHERE col <> nan;\n+SELECT count() FROM tab WHERE col = -nan;\n+SELECT count() FROM tab WHERE col <> -nan;\n+SELECT count() FROM tab WHERE isNaN(col);\n+SELECT count() FROM tab WHERE NOT isNaN(col);\n+\n+SELECT 'MinMax index should skip all granules for column = NaN comparison';\n+SELECT trimLeft(explain) AS explain FROM (\n+    EXPLAIN indexes=1\n+    SELECT count() FROM tab WHERE col = nan\n+)\n+WHERE explain LIKE '%Description:%' OR explain LIKE '%Parts:%' OR explain LIKE '%Granules:%'\n+LIMIT 2, 3; -- Skip the primary index parts and granules.\n+\n+SELECT trimLeft(explain) AS explain FROM (\n+    EXPLAIN indexes=1\n+    SELECT count() FROM tab WHERE col = -nan\n+)\n+WHERE explain LIKE '%Description:%' OR explain LIKE '%Parts:%' OR explain LIKE '%Granules:%'\n+LIMIT 2, 3; -- Skip the primary index parts and granules.\n+\n+SELECT 'MinMax index should use all granules for column <> NaN comparison';\n+SELECT trimLeft(explain) AS explain FROM (\n+    EXPLAIN indexes=1\n+    SELECT count() FROM tab WHERE col <> nan\n+)\n+WHERE explain LIKE '%Description:%' OR explain LIKE '%Parts:%' OR explain LIKE '%Granules:%'\n+LIMIT 2, 3; -- Skip the primary index parts and granules.\n+\n+SELECT trimLeft(explain) AS explain FROM (\n+    EXPLAIN indexes=1\n+    SELECT count() FROM tab WHERE col <> -nan\n+)\n+WHERE explain LIKE '%Description:%' OR explain LIKE '%Parts:%' OR explain LIKE '%Granules:%'\n+LIMIT 2, 3; -- Skip the primary index parts and granules.\n+\n+DROP TABLE tab;\n",
  "problem_statement": "Wrong result minmax index query with nan\n### Describe the bug\n\nCheck Fiddle, an inequality comparison query should return input for count.\n\n### How to reproduce\n\nRun Fiddle: https://fiddle.clickhouse.com/b042dec8-aa3f-4932-b3f9-b2690ae33f50\n\n### Error message and/or stacktrace\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-07-24T14:06:23Z"
}