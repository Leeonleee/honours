diff --git a/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.reference b/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.reference
index 6bac61731830..a4d91178d73d 100644
--- a/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.reference
+++ b/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.reference
@@ -3,5 +3,7 @@
 2018-01-01	2	2
 2018-01-01	2	2
 == (Replicas) Test optimize ==
+d1	2	1
 d2	1	0
+d3	2	1
 d4	1	0
diff --git a/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.sql b/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.sql
index e3c1bb10426e..9e293d0f7e24 100644
--- a/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.sql
+++ b/tests/queries/0_stateless/00577_replacing_merge_tree_vertical_merge.sql
@@ -7,14 +7,14 @@ create table tab_00577 (date Date, version UInt64, val UInt64) engine = Replacin
 insert into tab_00577 values ('2018-01-01', 2, 2), ('2018-01-01', 1, 1);
 insert into tab_00577 values ('2018-01-01', 0, 0);
 select * from tab_00577 order by version;
-OPTIMIZE TABLE tab_00577 FINAL CLEANUP;
+OPTIMIZE TABLE tab_00577 FINAL;
 select * from tab_00577;
 drop table tab_00577;
 
 
 DROP TABLE IF EXISTS testCleanupR1;
 CREATE TABLE testCleanupR1 (uid String, version UInt32, is_deleted UInt8)
-    ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{database}/tables/test_cleanup/', 'r1', version, is_deleted)
+    ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{database}/tables/test_cleanup/', 'r1', version)
     ORDER BY uid SETTINGS enable_vertical_merge_algorithm = 1, vertical_merge_algorithm_min_rows_to_activate = 0, vertical_merge_algorithm_min_columns_to_activate = 0, min_rows_for_wide_part = 0,
     min_bytes_for_wide_part = 0;
 INSERT INTO testCleanupR1 (*) VALUES ('d1', 1, 0),('d2', 1, 0),('d3', 1, 0),('d4', 1, 0);
@@ -22,9 +22,9 @@ INSERT INTO testCleanupR1 (*) VALUES ('d3', 2, 1);
 INSERT INTO testCleanupR1 (*) VALUES ('d1', 2, 1);
 SYSTEM SYNC REPLICA testCleanupR1; -- Avoid "Cannot select parts for optimization: Entry for part all_2_2_0 hasn't been read from the replication log yet"
 
-OPTIMIZE TABLE testCleanupR1 FINAL CLEANUP;
+OPTIMIZE TABLE testCleanupR1 FINAL;
 
 -- Only d3 to d5 remain
 SELECT '== (Replicas) Test optimize ==';
 SELECT * FROM testCleanupR1 order by uid;
-DROP TABLE IF EXISTS testCleanupR1
\ No newline at end of file
+DROP TABLE IF EXISTS testCleanupR1
diff --git a/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.reference b/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.reference
deleted file mode 100644
index 04a2b75bb4f2..000000000000
--- a/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.reference
+++ /dev/null
@@ -1,99 +0,0 @@
-== Test SELECT ... FINAL - no is_deleted ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-== Test SELECT ... FINAL - no is_deleted SETTINGS clean_deleted_rows=Always ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-== Test SELECT ... FINAL ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-== Insert backups ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-== Insert a second batch with overlaping data ==
-d1	5	0
-d2	3	0
-d3	3	0
-d4	3	0
-d5	1	0
-== Only last version remains after OPTIMIZE W/ CLEANUP ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	1	0
-d5	1	0
-d6	3	0
-== OPTIMIZE W/ CLEANUP (remove d6) ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	1	0
-d5	1	0
-== Test of the SETTINGS clean_deleted_rows as Always ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-== Test of the SETTINGS clean_deleted_rows as Never ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	3	0
-d5	1	0
-d6	2	1
-== (Replicas) Test optimize ==
-d2	1	0
-d4	1	0
-== (Replicas) Test settings ==
-c2	1	0
-c4	1	0
-== Check cleanup & settings for other merge trees ==
-d1	1	1
-d1	1	1
-d1	1	1
-d1	1	1	1
-d1	1	1	1
diff --git a/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.sql b/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.sql
deleted file mode 100644
index 8549300d49ff..000000000000
--- a/tests/queries/0_stateless/02490_replacing_merge_tree_is_deleted_column.sql
+++ /dev/null
@@ -1,160 +0,0 @@
--- Tags: zookeeper
-
--- Settings allow_deprecated_syntax_for_merge_tree prevent to enable the is_deleted column
-set allow_deprecated_syntax_for_merge_tree=0;
-
--- Test the bahaviour without the is_deleted column
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version) Order by (uid);
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
-SELECT '== Test SELECT ... FINAL - no is_deleted ==';
-select * from test FINAL order by uid;
-OPTIMIZE TABLE test FINAL CLEANUP;
-select * from test order by uid;
-
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version) Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
-SELECT '== Test SELECT ... FINAL - no is_deleted SETTINGS clean_deleted_rows=Always ==';
-select * from test FINAL order by uid;
-OPTIMIZE TABLE test FINAL CLEANUP;
-select * from test order by uid;
-
--- Test the new behaviour
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid);
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
-SELECT '== Test SELECT ... FINAL ==';
-select * from test FINAL order by uid;
-select * from test order by uid;
-
-SELECT '== Insert backups ==';
-INSERT INTO test (*) VALUES ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1);
-select * from test FINAL order by uid;
-
-SELECT '== Insert a second batch with overlaping data ==';
-INSERT INTO test (*) VALUES ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 1), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0), ('d2', 2, 1), ('d2', 3, 0), ('d3', 2, 1), ('d3', 3, 0);
-select * from test FINAL order by uid;
-
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid);
-
--- Expect d6 to be version=3 is_deleted=false
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 3, 0);
--- Insert previous version of 'd6' but only v=3 is_deleted=false will remain
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 2, 1);
-SELECT '== Only last version remains after OPTIMIZE W/ CLEANUP ==';
-OPTIMIZE TABLE test FINAL CLEANUP;
-select * from test order by uid;
-
--- insert d6 v=3 is_deleted=true (timestamp more recent so this version should be the one take into acount)
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 3, 1);
-
-SELECT '== OPTIMIZE W/ CLEANUP (remove d6) ==';
-OPTIMIZE TABLE test FINAL CLEANUP;
--- No d6 anymore
-select * from test order by uid;
-
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid) SETTINGS clean_deleted_rows='Always';
-
-SELECT '== Test of the SETTINGS clean_deleted_rows as Always ==';
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
--- Even if the setting is set to Always, the SELECT FINAL doesn't delete rows
-select * from test FINAL order by uid;
-select * from test order by uid;
-
-OPTIMIZE TABLE test FINAL;
--- d6 has to be removed since we set clean_deleted_rows as 'Always'
-select * from test order by uid;
-
-SELECT '== Test of the SETTINGS clean_deleted_rows as Never ==';
-ALTER TABLE test MODIFY SETTING clean_deleted_rows='Never';
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d2', 1, 0), ('d6', 1, 0), ('d4', 1, 0), ('d6', 2, 1), ('d3', 1, 0), ('d1', 2, 1), ('d5', 1, 0), ('d4', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d4', 3, 0), ('d1', 5, 0);
-OPTIMIZE TABLE test FINAL;
--- d6 has NOT to be removed since we set clean_deleted_rows as 'Never'
-select * from test order by uid;
-
-DROP TABLE IF EXISTS testCleanupR1;
-
-CREATE TABLE testCleanupR1 (uid String, version UInt32, is_deleted UInt8)
-    ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{database}/tables/test_cleanup/', 'r1', version, is_deleted)
-    ORDER BY uid;
-
-
-INSERT INTO testCleanupR1 (*) VALUES ('d1', 1, 0),('d2', 1, 0),('d3', 1, 0),('d4', 1, 0);
-INSERT INTO testCleanupR1 (*) VALUES ('d3', 2, 1);
-INSERT INTO testCleanupR1 (*) VALUES ('d1', 2, 1);
-SYSTEM SYNC REPLICA testCleanupR1; -- Avoid "Cannot select parts for optimization: Entry for part all_2_2_0 hasn't been read from the replication log yet"
-
-OPTIMIZE TABLE testCleanupR1 FINAL CLEANUP;
-
--- Only d3 to d5 remain
-SELECT '== (Replicas) Test optimize ==';
-SELECT * FROM testCleanupR1 order by uid;
-
-------------------------------
-
-DROP TABLE IF EXISTS testSettingsR1;
-
-CREATE TABLE testSettingsR1 (col1 String, version UInt32, is_deleted UInt8)
-    ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{database}/tables/test_setting/', 'r1', version, is_deleted)
-    ORDER BY col1
-    SETTINGS clean_deleted_rows = 'Always';
-
-INSERT INTO testSettingsR1 (*) VALUES ('c1', 1, 1),('c2', 1, 0),('c3', 1, 1),('c4', 1, 0);
-SYSTEM SYNC REPLICA testSettingsR1; -- Avoid "Cannot select parts for optimization: Entry for part all_2_2_0 hasn't been read from the replication log yet"
-
-OPTIMIZE TABLE testSettingsR1 FINAL;
-
--- Only d3 to d5 remain
-SELECT '== (Replicas) Test settings ==';
-SELECT * FROM testSettingsR1 order by col1;
-
-
-------------------------------
--- Check errors
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid);
-
--- is_deleted == 0/1
-INSERT INTO test (*) VALUES ('d1', 1, 2); -- { serverError INCORRECT_DATA }
-
-DROP TABLE IF EXISTS test;
--- checkis_deleted type
-CREATE TABLE test (uid String, version UInt32, is_deleted String) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid); -- { serverError BAD_TYPE_OF_FIELD }
-
--- is_deleted column for other mergeTrees - ErrorCodes::LOGICAL_ERROR)
-
--- Check clean_deleted_rows='Always' for other MergeTrees
-SELECT '== Check cleanup & settings for other merge trees ==';
-CREATE TABLE testMT (uid String, version UInt32, is_deleted UInt8) ENGINE = MergeTree() Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO testMT (*) VALUES ('d1', 1, 1);
-OPTIMIZE TABLE testMT FINAL CLEANUP;  -- { serverError CANNOT_ASSIGN_OPTIMIZE }
-OPTIMIZE TABLE testMT FINAL;
-SELECT * FROM testMT order by uid;
-
-CREATE TABLE testSummingMT (uid String, version UInt32, is_deleted UInt8) ENGINE = SummingMergeTree() Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO testSummingMT (*) VALUES ('d1', 1, 1);
-OPTIMIZE TABLE testSummingMT FINAL CLEANUP;  -- { serverError CANNOT_ASSIGN_OPTIMIZE }
-OPTIMIZE TABLE testSummingMT FINAL;
-SELECT * FROM testSummingMT order by uid;
-
-CREATE TABLE testAggregatingMT (uid String, version UInt32, is_deleted UInt8) ENGINE = AggregatingMergeTree() Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO testAggregatingMT (*) VALUES ('d1', 1, 1);
-OPTIMIZE TABLE testAggregatingMT FINAL CLEANUP;  -- { serverError CANNOT_ASSIGN_OPTIMIZE }
-OPTIMIZE TABLE testAggregatingMT FINAL;
-SELECT * FROM testAggregatingMT order by uid;
-
-CREATE TABLE testCollapsingMT (uid String, version UInt32, is_deleted UInt8, sign Int8) ENGINE = CollapsingMergeTree(sign) Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO testCollapsingMT (*) VALUES ('d1', 1, 1, 1);
-OPTIMIZE TABLE testCollapsingMT FINAL CLEANUP;  -- { serverError CANNOT_ASSIGN_OPTIMIZE }
-OPTIMIZE TABLE testCollapsingMT FINAL;
-SELECT * FROM testCollapsingMT order by uid;
-
-CREATE TABLE testVersionedCMT (uid String, version UInt32, is_deleted UInt8, sign Int8) ENGINE = VersionedCollapsingMergeTree(sign, version) Order by (uid) SETTINGS clean_deleted_rows='Always';
-INSERT INTO testVersionedCMT (*) VALUES ('d1', 1, 1, 1);
-OPTIMIZE TABLE testVersionedCMT FINAL CLEANUP;  -- { serverError CANNOT_ASSIGN_OPTIMIZE }
-OPTIMIZE TABLE testVersionedCMT FINAL;
-SELECT * FROM testVersionedCMT order by uid;
diff --git a/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.reference b/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.reference
deleted file mode 100644
index d19222b55ecd..000000000000
--- a/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.reference
+++ /dev/null
@@ -1,31 +0,0 @@
---- Based on https://github.com/ClickHouse/ClickHouse/issues/49685
---- Verify that ReplacingMergeTree properly handles _is_deleted:
---- SELECT FINAL should take `_is_deleted` into consideration when there is only one partition.
--- { echoOn }
-
-DROP TABLE IF EXISTS t;
-CREATE TABLE t
-(
-    `account_id` UInt64,
-    `_is_deleted` UInt8,
-    `_version` UInt64
-)
-ENGINE = ReplacingMergeTree(_version, _is_deleted)
-ORDER BY (account_id);
-INSERT INTO t SELECT number, 0, 1 FROM numbers(1e3);
--- Mark the first 100 rows as deleted.
-INSERT INTO t SELECT number, 1, 1 FROM numbers(1e2);
--- Put everything in one partition
-OPTIMIZE TABLE t FINAL;
-SELECT count() FROM t;
-1000
-SELECT count() FROM t FINAL;
-900
--- Both should produce the same number of rows.
--- Previously, `do_not_merge_across_partitions_select_final = 1` showed more rows, 
--- as if no rows were deleted.
-SELECT count() FROM t FINAL SETTINGS do_not_merge_across_partitions_select_final = 1;
-900
-SELECT count() FROM t FINAL SETTINGS do_not_merge_across_partitions_select_final = 0;
-900
-DROP TABLE t;
diff --git a/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.sql b/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.sql
deleted file mode 100644
index a89a1ff590a6..000000000000
--- a/tests/queries/0_stateless/02814_ReplacingMergeTree_fix_select_final_on_single_partition.sql
+++ /dev/null
@@ -1,32 +0,0 @@
---- Based on https://github.com/ClickHouse/ClickHouse/issues/49685
---- Verify that ReplacingMergeTree properly handles _is_deleted:
---- SELECT FINAL should take `_is_deleted` into consideration when there is only one partition.
--- { echoOn }
-
-DROP TABLE IF EXISTS t;
-CREATE TABLE t
-(
-    `account_id` UInt64,
-    `_is_deleted` UInt8,
-    `_version` UInt64
-)
-ENGINE = ReplacingMergeTree(_version, _is_deleted)
-ORDER BY (account_id);
-
-INSERT INTO t SELECT number, 0, 1 FROM numbers(1e3);
--- Mark the first 100 rows as deleted.
-INSERT INTO t SELECT number, 1, 1 FROM numbers(1e2);
-
--- Put everything in one partition
-OPTIMIZE TABLE t FINAL;
-
-SELECT count() FROM t;
-SELECT count() FROM t FINAL;
-
--- Both should produce the same number of rows.
--- Previously, `do_not_merge_across_partitions_select_final = 1` showed more rows, 
--- as if no rows were deleted.
-SELECT count() FROM t FINAL SETTINGS do_not_merge_across_partitions_select_final = 1;
-SELECT count() FROM t FINAL SETTINGS do_not_merge_across_partitions_select_final = 0;
-
-DROP TABLE t;
diff --git a/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.reference b/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.reference
deleted file mode 100644
index 9c9caa221391..000000000000
--- a/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.reference
+++ /dev/null
@@ -1,13 +0,0 @@
-== Only last version remains after OPTIMIZE W/ CLEANUP ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	1	0
-d5	1	0
-d6	3	0
-== OPTIMIZE W/ CLEANUP (remove d6) ==
-d1	5	0
-d2	1	0
-d3	1	0
-d4	1	0
-d5	1	0
diff --git a/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.sql b/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.sql
deleted file mode 100644
index 7b78e2900e7e..000000000000
--- a/tests/queries/0_stateless/02861_replacing_merge_tree_with_cleanup.sql
+++ /dev/null
@@ -1,23 +0,0 @@
-DROP TABLE IF EXISTS test;
-CREATE TABLE test (uid String, version UInt32, is_deleted UInt8) ENGINE = ReplacingMergeTree(version, is_deleted) Order by (uid) SETTINGS vertical_merge_algorithm_min_rows_to_activate = 1,
-    vertical_merge_algorithm_min_columns_to_activate = 0,
-    min_rows_for_wide_part = 1,
-    min_bytes_for_wide_part = 1;
-
--- Expect d6 to be version=3 is_deleted=false
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 3, 0);
--- Insert previous version of 'd6' but only v=3 is_deleted=false will remain
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 2, 1);
-SELECT '== Only last version remains after OPTIMIZE W/ CLEANUP ==';
-OPTIMIZE TABLE test FINAL CLEANUP;
-select * from test order by uid;
-
--- insert d6 v=3 is_deleted=true (timestamp more recent so this version should be the one take into acount)
-INSERT INTO test (*) VALUES ('d1', 1, 0), ('d1', 2, 1), ('d1', 3, 0), ('d1', 4, 1), ('d1', 5, 0), ('d2', 1, 0), ('d3', 1, 0), ('d4', 1, 0),  ('d5', 1, 0), ('d6', 1, 0), ('d6', 3, 1);
-
-SELECT '== OPTIMIZE W/ CLEANUP (remove d6) ==';
-OPTIMIZE TABLE test FINAL CLEANUP;
--- No d6 anymore
-select * from test order by uid;
-
-DROP TABLE IF EXISTS test;
diff --git a/tests/queries/0_stateless/02910_replicated_merge_parameters_must_consistent.sql b/tests/queries/0_stateless/02910_replicated_merge_parameters_must_consistent.sql
index 3c1bec4fb3f1..c832e16e81ee 100644
--- a/tests/queries/0_stateless/02910_replicated_merge_parameters_must_consistent.sql
+++ b/tests/queries/0_stateless/02910_replicated_merge_parameters_must_consistent.sql
@@ -17,26 +17,6 @@ CREATE TABLE t_r
 ENGINE = ReplicatedReplacingMergeTree('/tables/{database}/t/', 'r2')
 ORDER BY id; -- { serverError METADATA_MISMATCH }
 
-CREATE TABLE t2
-(
-    `id` UInt64,
-    `val` String,
-    `legacy_ver` UInt64,
-    `deleted` UInt8
-)
-ENGINE = ReplicatedReplacingMergeTree('/tables/{database}/t2/', 'r1', legacy_ver)
-ORDER BY id;
-
-CREATE TABLE t2_r
-(
-    `id` UInt64,
-    `val` String,
-    `legacy_ver` UInt64,
-    `deleted` UInt8
-)
-ENGINE = ReplicatedReplacingMergeTree('/tables/{database}/t2/', 'r2', legacy_ver, deleted)
-ORDER BY id; -- { serverError METADATA_MISMATCH }
-
 CREATE TABLE t3
 (
     `key` UInt64,
