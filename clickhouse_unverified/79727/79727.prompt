You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Logical error: Cannot find the original scope of the column
### Describe the bug

From this run: https://s3.amazonaws.com/clickhouse-test-reports/json.html?REF=master&sha=c6dc04b2034b94744761cf4689510d2db5cec140&name_0=MasterCI&name_1=AST+fuzzer+%28amd_debug%29 It was introduced in v25.4. Time to bisect...

### How to reproduce

Simplified into this Fiddle: https://fiddle.clickhouse.com/2a2d13be-3e47-4c57-a14e-bc186db2093b

### Error message and/or stacktrace

Stack trace:

```
<Fatal> : Logical error: 'Cannot find the original scope of the column'.
<Fatal> : Stack trace (when copying this message, always include the lines below):

0. std::exception::exception[abi:ne190107]() @ 0x0000000018108794
1. base/poco/Foundation/src/Exception.cpp:27: Poco::Exception::Exception(String const&, int) @ 0x0000000036610f80
2. src/Common/Exception.cpp:108: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x00000000249cfcab
3. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000017fbc316
4. DB::Exception::Exception<>(int, FormatStringHelperImpl<>) @ 0x0000000017fd14cf
5. src/Analyzer/Utils.cpp:286: DB::checkCorrelatedColumn(DB::IdentifierResolveScope*, std::shared_ptr<DB::ColumnNode> const&) @ 0x000000002d7fb3f7
6. src/Analyzer/Resolve/QueryAnalyzer.cpp:1387: DB::QueryAnalyzer::tryResolveIdentifierInParentScopes(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d942f59
7. src/Analyzer/Resolve/QueryAnalyzer.cpp:1553: DB::QueryAnalyzer::tryResolveIdentifier(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d9420dc
8. src/Analyzer/Resolve/QueryAnalyzer.cpp:1343: DB::QueryAnalyzer::tryResolveIdentifierInParentScopes(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d942b89
9. src/Analyzer/Resolve/QueryAnalyzer.cpp:1553: DB::QueryAnalyzer::tryResolveIdentifier(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d9420dc
10. src/Analyzer/Resolve/QueryAnalyzer.cpp:3732: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d92906a
11. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f
12. src/Analyzer/Resolve/QueryAnalyzer.cpp:4344: DB::QueryAnalyzer::resolveProjectionExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d96f70c
13. src/Analyzer/Resolve/QueryAnalyzer.cpp:5641: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d52f
14. src/Analyzer/Resolve/QueryAnalyzer.cpp:3910: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9282bf
15. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f
16. src/Analyzer/Resolve/QueryAnalyzer.cpp:2912: DB::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d94cd17
17. src/Analyzer/Resolve/QueryAnalyzer.cpp:3878: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9284e0
18. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f
19. src/Analyzer/Resolve/QueryAnalyzer.cpp:4344: DB::QueryAnalyzer::resolveProjectionExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d96f70c
20. src/Analyzer/Resolve/QueryAnalyzer.cpp:5641: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d52f
21. src/Analyzer/Resolve/QueryAnalyzer.cpp:3910: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9282bf
22. src/Analyzer/Resolve/QueryAnalyzer.cpp:5370: DB::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, DB::QueryExpressionsAliasVisitor&) @ 0x000000002d973b49
23. src/Analyzer/Resolve/QueryAnalyzer.cpp:5633: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d4c8
24. src/Analyzer/Resolve/QueryAnalyzer.cpp:180: DB::QueryAnalyzer::resolve(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::IQueryTreeNode> const&, std::shared_ptr<DB::Context const>) @ 0x000000002d91b169
25. src/Analyzer/Resolve/QueryAnalysisPass.cpp:18: DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x000000002d91a791
26. src/Analyzer/QueryTreePassManager.cpp:187: DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>) @ 0x000000002d9c73b9
27. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:165: DB::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) @ 0x000000002eb44c28
28. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:182: DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x000000002eb4227a
29. contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:634: std::__unique_if<DB::InterpreterSelectQueryAnalyzer>::__unique_single std::make_unique[abi:ne190107]<DB::InterpreterSelectQueryAnalyzer, std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&>(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&) @ 0x000000002eb46c0e
30. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:307: std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl[abi:ne190107]<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) @ 0x000000002eb46585
31. contrib/llvm-project/libcxx/include/__functional/function.h:716: ? @ 0x000000002eab022f
```
UNSUPPORTED_METHOD error when adding alias based on JSON
### Company or project name

_No response_

### Describe the unexpected behaviour

i've noticed change in behavior between ClickHouse 24.12.1 and 25.3.1.

i'm trying to migrate existing data structure that's based on arrays of ints, arrays of arrays of into JSON. to preserve backwards compatibility with existing queries - i'm trying to use alias, but those don't work in 25.3.1.
this code works fine in the older version but not in the latest stable:
```
set enable_json_type = 1;
create or replace table inp ( id UInt64, name Array(UInt32), value Array(Array(UInt32)) ) order by id;
create or replace table out0 ( id UInt64, j JSON ) order by id;
insert into inp ( id, name, value ) values(1, [1,2], [[3],[4]]);
insert into out0 select id, toJSONString(mapFromArrays(name,value)) from inp;

create or replace table out1 ( id UInt64, j JSON, name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)), value Array(Array(UInt32)) alias arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)   )order by id;
insert into out1 select id, toJSONString(mapFromArrays(name,value)) from inp;

-- so far so good
select * from out1;
```

SELECT will return expected result in 24.12.1 and error in 25.3.1:
```
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolved identifier 'j' in parent scope to expression 'default.out1.j' with correlated column 'j'. In scope x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'). (UNSUPPORTED_METHOD)
```



### How to reproduce

this code works fine in the older version but not in the latest stable:
```
set enable_json_type = 1;
create or replace table inp ( id UInt64, name Array(UInt32), value Array(Array(UInt32)) ) order by id;
create or replace table out0 ( id UInt64, j JSON ) order by id;
insert into inp ( id, name, value ) values(1, [1,2], [[3],[4]]);
insert into out0 select id, toJSONString(mapFromArrays(name,value)) from inp;

 select arrayMap(x -> toUInt32(x), JSONAllPaths(j)) as name, arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name) from out0;

create or replace table out1 ( id UInt64, j JSON, name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)), value Array(Array(UInt32)) alias arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)   )order by id;
insert into out1 select id, toJSONString(mapFromArrays(name,value)) from inp;


-- so far so good
select * from out1;
```

SELECT will return expected result in 24.12.1 and error in 25.3.1:
```
Code: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolved identifier 'j' in parent scope to expression 'default.out1.j' with correlated column 'j'. In scope x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'). (UNSUPPORTED_METHOD)
```



### Expected behavior

above select should succeed as it does in 24.12.1

### Error message and/or stacktrace

_No response_

### Additional context

clickhouse .deb from your builds. amd64 Debian linux.

thx!
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
