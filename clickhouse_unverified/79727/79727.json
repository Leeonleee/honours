{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79727,
  "instance_id": "ClickHouse__ClickHouse-79727",
  "issue_numbers": [
    "79451",
    "78183"
  ],
  "base_commit": "b32121b3989b27ff5a975dcb4e50df3d72a0dcfc",
  "patch": "diff --git a/src/Analyzer/Resolve/CorrelatedColumnsCollector.h b/src/Analyzer/Resolve/CorrelatedColumnsCollector.h\nnew file mode 100644\nindex 000000000000..f960c859c7ec\n--- /dev/null\n+++ b/src/Analyzer/Resolve/CorrelatedColumnsCollector.h\n@@ -0,0 +1,77 @@\n+#pragma once\n+\n+#include <Analyzer/IQueryTreeNode.h>\n+#include <Analyzer/Utils.h>\n+\n+#include <Analyzer/Resolve/IdentifierResolveScope.h>\n+\n+#include <unordered_map>\n+#include <vector>\n+\n+namespace DB\n+{\n+\n+class IQueryTreeNode;\n+using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;\n+using QueryTreeNodes = std::vector<QueryTreeNodePtr>;\n+\n+struct CorrelatedColumnsCollector\n+{\n+    explicit CorrelatedColumnsCollector(\n+        const QueryTreeNodePtr & expression,\n+        const IdentifierResolveScope * current_scope,\n+        const std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> & map\n+    )\n+        : node_to_scope_map(map)\n+        , correlated_columns()\n+    {\n+        visitExpression(expression, current_scope);\n+    }\n+\n+    bool has() const { return !correlated_columns.empty(); }\n+\n+    const QueryTreeNodes & get() const { return correlated_columns; }\n+\n+private:\n+    void visitExpression(const QueryTreeNodePtr & expression, const IdentifierResolveScope * current_scope)\n+    {\n+        QueryTreeNodes nodes_to_process = { expression };\n+        while (!nodes_to_process.empty())\n+        {\n+            auto current = nodes_to_process.back();\n+            nodes_to_process.pop_back();\n+\n+            auto current_node_type = current->getNodeType();\n+\n+            /// Change scope if expression is a QueryNode.\n+            /// Columns in these subqueries can appear from table expressions\n+            /// that are registered in the child scope.\n+            if (current_node_type == QueryTreeNodeType::QUERY)\n+            {\n+                auto it = node_to_scope_map.find(current);\n+                if (it != node_to_scope_map.end() && current != current_scope->scope_node)\n+                {\n+                    visitExpression(current, &it->second);\n+                    continue;\n+                }\n+            }\n+\n+            if (current_node_type == QueryTreeNodeType::COLUMN)\n+            {\n+                if (checkCorrelatedColumn(current_scope, current))\n+                    correlated_columns.push_back(current);\n+            }\n+\n+            for (const auto & child : current->getChildren())\n+            {\n+                if (child)\n+                    nodes_to_process.push_back(child);\n+            }\n+        }\n+    }\n+\n+    const std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> & node_to_scope_map;\n+    QueryTreeNodes correlated_columns;\n+};\n+\n+}\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex a018b07903fa..bb3597d7a8a1 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -1,4 +1,3 @@\n-#include <Interpreters/ProcessorsProfileLog.h>\n #include <Common/FieldVisitorToString.h>\n \n #include <Columns/ColumnNullable.h>\n@@ -20,16 +19,18 @@\n #include <Functions/exists.h>\n #include <Functions/grouping.h>\n \n-#include <TableFunctions/TableFunctionFactory.h>\n #include <Formats/FormatFactory.h>\n \n+#include <TableFunctions/TableFunctionFactory.h>\n+\n #include <Storages/IStorage.h>\n #include <Storages/StorageJoin.h>\n \n-#include <Interpreters/misc.h>\n #include <Interpreters/convertFieldToType.h>\n+#include <Interpreters/misc.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n #include <Interpreters/InterpreterSelectQueryAnalyzer.h>\n+#include <Interpreters/ProcessorsProfileLog.h>\n \n #include <Processors/Executors/PullingAsyncPipelineExecutor.h>\n \n@@ -61,6 +62,7 @@\n #include <Analyzer/FunctionSecretArgumentsFinderTreeNode.h>\n #include <Analyzer/RecursiveCTE.h>\n \n+#include <Analyzer/Resolve/CorrelatedColumnsCollector.h>\n #include <Analyzer/Resolve/IdentifierResolveScope.h>\n #include <Analyzer/Resolve/QueryAnalyzer.h>\n #include <Analyzer/Resolve/QueryExpressionsAliasVisitor.h>\n@@ -69,10 +71,10 @@\n #include <Analyzer/Resolve/TableFunctionsWithClusterAlternativesVisitor.h>\n #include <Analyzer/Resolve/TypoCorrection.h>\n \n-#include <Planner/PlannerActionsVisitor.h>\n-\n #include <Core/Settings.h>\n \n+#include <ranges>\n+\n namespace ProfileEvents\n {\n     extern const Event ScalarSubqueriesGlobalCacheHit;\n@@ -161,7 +163,7 @@ QueryAnalyzer::~QueryAnalyzer() = default;\n \n void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)\n {\n-    IdentifierResolveScope scope(node, nullptr /*parent_scope*/);\n+    IdentifierResolveScope & scope = createIdentifierResolveScope(node, /*parent_scope=*/ nullptr);\n \n     if (!scope.context)\n         scope.context = context;\n@@ -231,7 +233,7 @@ void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & ta\n \n void QueryAnalyzer::resolveConstantExpression(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)\n {\n-    IdentifierResolveScope scope(node, nullptr /*parent_scope*/);\n+    IdentifierResolveScope & scope = createIdentifierResolveScope(node, /*parent_scope=*/ nullptr);\n \n     if (!scope.context)\n         scope.context = context;\n@@ -292,6 +294,12 @@ std::optional<JoinTableSide> QueryAnalyzer::getColumnSideFromJoinTree(const Quer\n     return {};\n }\n \n+IdentifierResolveScope & QueryAnalyzer::createIdentifierResolveScope(const QueryTreeNodePtr & scope_node, IdentifierResolveScope * parent_scope)\n+{\n+    auto [it, _] = node_to_scope_map.emplace(scope_node, IdentifierResolveScope{scope_node, parent_scope});\n+    return it->second;\n+}\n+\n ProjectionName QueryAnalyzer::calculateFunctionProjectionName(const QueryTreeNodePtr & function_node, const ProjectionNames & parameters_projection_names,\n     const ProjectionNames & arguments_projection_names)\n {\n@@ -1383,31 +1391,16 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const\n     if (identifier_lookup.isFunctionLookup())\n         return resolve_result;\n \n-    QueryTreeNodes nodes_to_process = { resolved_identifier };\n-    while (!nodes_to_process.empty())\n+    CorrelatedColumnsCollector correlated_columns_collector{resolved_identifier, identifier_resolve_context.scope_to_resolve_alias_expression, node_to_scope_map};\n+    if (correlated_columns_collector.has() && !scope.context->getSettingsRef()[Setting::allow_experimental_correlated_subqueries])\n     {\n-        auto current = nodes_to_process.back();\n-        nodes_to_process.pop_back();\n-        if (current->getNodeType() == QueryTreeNodeType::COLUMN)\n-        {\n-            auto is_correlated_column = checkCorrelatedColumn(&scope, current);\n-            if (is_correlated_column && !scope.context->getSettingsRef()[Setting::allow_experimental_correlated_subqueries])\n-            {\n-                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                    \"Resolved identifier '{}' in parent scope to expression '{}' with correlated column '{}'\"\n-                    \" (Enable 'allow_experimental_correlated_subqueries' setting to allow correlated subqueries execution). In scope {}\",\n-                    identifier_lookup.identifier.getFullName(),\n-                    resolved_identifier->formatASTForErrorMessage(),\n-                    current->as<ColumnNode>()->getColumnName(),\n-                    scope.scope_node->formatASTForErrorMessage());\n-            }\n-        }\n-\n-        for (const auto & child : current->getChildren())\n-        {\n-            if (child)\n-                nodes_to_process.push_back(child);\n-        }\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+            \"Resolved identifier '{}' in parent scope to expression '{}' with correlated columns '{}'\"\n+            \" (Enable 'allow_experimental_correlated_subqueries' setting to allow correlated subqueries execution). In scope {}\",\n+            identifier_lookup.identifier.getFullName(),\n+            resolved_identifier->formatASTForErrorMessage(),\n+            fmt::join(correlated_columns_collector.get() | std::views::transform([](const auto & e) { return e->template as<ColumnNode>()->getColumnName(); }), \"', '\"),\n+            scope.scope_node->formatASTForErrorMessage());\n     }\n \n     return resolve_result;\n@@ -2328,7 +2321,7 @@ ProjectionNames QueryAnalyzer::resolveMatcher(QueryTreeNodePtr & matcher_node, I\n                 if (apply_transformer->getApplyTransformerType() == ApplyColumnTransformerType::LAMBDA)\n                 {\n                     auto lambda_expression_to_resolve = expression_node->clone();\n-                    IdentifierResolveScope lambda_scope(expression_node, &scope /*parent_scope*/);\n+                    auto & lambda_scope = createIdentifierResolveScope(lambda_expression_to_resolve, /*parent_scope=*/&scope);\n                     node_projection_names = resolveLambda(expression_node, lambda_expression_to_resolve, {node}, lambda_scope);\n                     auto & lambda_expression_to_resolve_typed = lambda_expression_to_resolve->as<LambdaNode &>();\n                     node = lambda_expression_to_resolve_typed.getExpression();\n@@ -3122,7 +3115,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n         auto first_argument_type = in_first_argument->getNodeType();\n         if (first_argument_type == QueryTreeNodeType::QUERY || first_argument_type == QueryTreeNodeType::UNION)\n         {\n-            IdentifierResolveScope subquery_scope(in_first_argument, &scope /*parent_scope*/);\n+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(in_first_argument, &scope /*parent_scope*/);\n             subquery_scope.subquery_depth = scope.subquery_depth + 1;\n \n             evaluateScalarSubqueryIfNeeded(in_first_argument, subquery_scope);\n@@ -3251,7 +3244,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n \n             auto lambda_expression_clone = lambda_expression_untyped->clone();\n \n-            IdentifierResolveScope lambda_scope(lambda_expression_clone, &scope /*parent_scope*/);\n+            IdentifierResolveScope & lambda_scope = createIdentifierResolveScope(lambda_expression_clone, &scope /*parent_scope*/);\n             ProjectionNames lambda_projection_names = resolveLambda(lambda_expression_untyped, lambda_expression_clone, function_arguments, lambda_scope);\n \n             auto & resolved_lambda = lambda_expression_clone->as<LambdaNode &>();\n@@ -3499,7 +3492,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             QueryTreeNodes lambda_arguments;\n             lambda_arguments.reserve(lambda_arguments_size);\n \n-            IdentifierResolveScope lambda_scope(lambda_to_resolve, &scope /*parent_scope*/);\n+            IdentifierResolveScope & lambda_scope = createIdentifierResolveScope(lambda_to_resolve, &scope /*parent_scope*/);\n             for (size_t i = 0; i < lambda_arguments_size; ++i)\n             {\n                 const auto & argument_type = function_data_type_argument_types[i];\n@@ -3726,7 +3719,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(\n         auto node_type = node->getNodeType();\n         if (!allow_table_expression && (node_type == QueryTreeNodeType::QUERY || node_type == QueryTreeNodeType::UNION))\n         {\n-            IdentifierResolveScope subquery_scope(node, &scope /*parent_scope*/);\n+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(node, &scope /*parent_scope*/);\n             subquery_scope.subquery_depth = scope.subquery_depth + 1;\n \n             evaluateScalarSubqueryIfNeeded(node, subquery_scope);\n@@ -3801,7 +3794,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(\n                         else\n                             union_node->setIsCTE(false);\n \n-                        IdentifierResolveScope subquery_scope(resolved_identifier_node, &scope /*parent_scope*/);\n+                        IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(resolved_identifier_node, &scope /*parent_scope*/);\n                         subquery_scope.subquery_depth = scope.subquery_depth + 1;\n \n                         /// CTE is being resolved, it's required to forbid to resolve to it again\n@@ -3938,7 +3931,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(\n             [[fallthrough]];\n         case QueryTreeNodeType::UNION:\n         {\n-            IdentifierResolveScope subquery_scope(node, &scope /*parent_scope*/);\n+            IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(node, &scope /*parent_scope*/);\n             subquery_scope.subquery_depth = scope.subquery_depth + 1;\n \n             std::string projection_name = \"_subquery_\" + std::to_string(subquery_counter);\n@@ -4367,7 +4360,7 @@ void QueryAnalyzer::resolveInterpolateColumnsNodeList(QueryTreeNodePtr & interpo\n         bool is_column_constant = interpolate_node_typed.getExpression()->getNodeType() == QueryTreeNodeType::CONSTANT;\n \n         auto & interpolation_to_resolve = interpolate_node_typed.getInterpolateExpression();\n-        IdentifierResolveScope interpolate_scope(interpolation_to_resolve, &scope /*parent_scope*/);\n+        IdentifierResolveScope & interpolate_scope = createIdentifierResolveScope(interpolation_to_resolve, &scope /*parent_scope*/);\n \n         auto fake_column_node = std::make_shared<ColumnNode>(NameAndTypePair(column_to_interpolate_name, interpolate_node_typed.getExpression()->getResultType()), interpolate_node);\n         if (is_column_constant)\n@@ -4672,7 +4665,7 @@ void QueryAnalyzer::initializeTableExpressionData(const QueryTreeNodePtr & table\n               */\n             alias_column_to_resolve = column_name_to_column_node[alias_column_to_resolve_name];\n \n-            IdentifierResolveScope alias_column_resolve_scope(alias_column_to_resolve, nullptr /*parent_scope*/);\n+            IdentifierResolveScope & alias_column_resolve_scope = createIdentifierResolveScope(alias_column_to_resolve, &scope /*parent_scope*/);\n             alias_column_resolve_scope.column_name_to_column_node = std::move(column_name_to_column_node);\n             alias_column_resolve_scope.context = scope.context;\n \n@@ -5345,7 +5338,7 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS\n                         left_subquery->getProjection().getNodes().push_back(projection_node->clone());\n                         left_subquery->getJoinTree() = left_table_expression;\n \n-                        IdentifierResolveScope left_subquery_scope(left_subquery, nullptr /*parent_scope*/);\n+                        IdentifierResolveScope & left_subquery_scope = createIdentifierResolveScope(left_subquery, nullptr /*parent_scope*/);\n                         resolveQuery(left_subquery, left_subquery_scope);\n \n                         const auto & resolved_nodes = left_subquery->getProjection().getNodes();\n@@ -5972,7 +5965,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier\n         auto & non_recursive_query_mutable_context = non_recursive_query_is_query_node ? non_recursive_query->as<QueryNode &>().getMutableContext()\n             :  non_recursive_query->as<UnionNode &>().getMutableContext();\n \n-        IdentifierResolveScope non_recursive_subquery_scope(non_recursive_query, &scope /*parent_scope*/);\n+        IdentifierResolveScope & non_recursive_subquery_scope = createIdentifierResolveScope(non_recursive_query, &scope /*parent_scope*/);\n         non_recursive_subquery_scope.subquery_depth = scope.subquery_depth + 1;\n \n         if (non_recursive_query_is_query_node)\n@@ -6003,7 +5996,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier\n     {\n         auto & query_node = queries_nodes[i];\n \n-        IdentifierResolveScope subquery_scope(query_node, &scope /*parent_scope*/);\n+        IdentifierResolveScope & subquery_scope = createIdentifierResolveScope(query_node, &scope /*parent_scope*/);\n \n         if (recursive_cte_table_node)\n             subquery_scope.expression_argument_name_to_node[union_node_typed.getCTEName()] = recursive_cte_table_node;\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.h b/src/Analyzer/Resolve/QueryAnalyzer.h\nindex 51d5cb7640b7..a5b58eeadf3b 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.h\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <unordered_map>\n #include <Interpreters/Context_fwd.h>\n #include <Analyzer/HashUtils.h>\n #include <Analyzer/IQueryTreeNode.h>\n@@ -124,6 +125,8 @@ class QueryAnalyzer\n private:\n     /// Utility functions\n \n+    IdentifierResolveScope & createIdentifierResolveScope(const QueryTreeNodePtr & scope_node, IdentifierResolveScope * parent_scope);\n+\n     static ProjectionName calculateFunctionProjectionName(const QueryTreeNodePtr & function_node,\n         const ProjectionNames & parameters_projection_names,\n         const ProjectionNames & arguments_projection_names);\n@@ -285,6 +288,8 @@ class QueryAnalyzer\n     std::unordered_map<QueryTreeNodePtrWithHash, Block> scalar_subquery_to_scalar_value_local;\n     std::unordered_map<QueryTreeNodePtrWithHash, Block> scalar_subquery_to_scalar_value_global;\n \n+    std::unordered_map<QueryTreeNodePtr, IdentifierResolveScope> node_to_scope_map;\n+\n     const bool only_analyze;\n };\n \ndiff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex d2626e08653e..be68bc3aa42c 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -251,11 +251,11 @@ bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node)\n }\n \n bool checkCorrelatedColumn(\n-    IdentifierResolveScope * scope_to_check,\n+    const IdentifierResolveScope * scope_to_check,\n     const QueryTreeNodePtr & column\n )\n {\n-    auto * current_scope = scope_to_check;\n+    const auto * current_scope = scope_to_check;\n     chassert(column->getNodeType() == QueryTreeNodeType::COLUMN);\n     auto * column_node = column->as<ColumnNode>();\n     auto column_source = column_node->getColumnSource();\n@@ -272,9 +272,15 @@ bool checkCorrelatedColumn(\n \n     while (scope_to_check != nullptr)\n     {\n+        /// Check if column source is in the FROM section of the current scope (query).\n         if (scope_to_check->registered_table_expression_nodes.contains(column_source))\n             break;\n \n+        /// Previous check wouldn't work in the case of resolution of alias columns.\n+        /// In that case table expression is not registered yet and table expression data is being computed.\n+        if (scope_to_check->table_expressions_in_resolve_process.contains(column_source.get()))\n+            break;\n+\n         if (isQueryOrUnionNode(scope_to_check->scope_node))\n         {\n             is_correlated = true;\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex e0063d51bd94..8ebd0a186a19 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -71,7 +71,7 @@ bool isCorrelatedQueryOrUnionNode(const QueryTreeNodePtr & node);\n  * in corresponding QueryNode or UnionNode.\n  */\n bool checkCorrelatedColumn(\n-    IdentifierResolveScope * scope_to_check,\n+    const IdentifierResolveScope * scope_to_check,\n     const QueryTreeNodePtr & column\n );\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03444_analyzer_resolve_alias_columns.reference b/tests/queries/0_stateless/03444_analyzer_resolve_alias_columns.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03444_analyzer_resolve_alias_columns.sql b/tests/queries/0_stateless/03444_analyzer_resolve_alias_columns.sql\nnew file mode 100644\nindex 000000000000..ee8136b4743a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03444_analyzer_resolve_alias_columns.sql\n@@ -0,0 +1,25 @@\n+CREATE TABLE users (\n+    uid Int16,\n+    name String,\n+    age Int16,\n+    v Array(Int16) ALIAS arrayMap(x -> age, array(name))\n+) ENGINE=Memory;\n+\n+INSERT INTO users VALUES (1231, 'John', 33);\n+INSERT INTO users VALUES (6666, 'Ksenia', 48);\n+INSERT INTO users VALUES (8888, 'Alice', 50);\n+\n+SELECT * FROM users FORMAT Null;\n+\n+CREATE TABLE out1\n+  (\n+    id UInt64,\n+    j JSON,\n+    name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)),\n+    value Array(Array(UInt32)) ALIAS arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)\n+)\n+ORDER BY id;\n+\n+INSERT INTO out1 SELECT 42, '{\"a\" : 42}';\n+\n+SELECT * FROM out1 FORMAT Null;\ndiff --git a/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.reference b/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.reference\nnew file mode 100644\nindex 000000000000..0d66ea1aee95\n--- /dev/null\n+++ b/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.reference\n@@ -0,0 +1,2 @@\n+0\n+1\ndiff --git a/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.sql b/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.sql\nnew file mode 100644\nindex 000000000000..f3ca233d9cf9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03522_analyzer_check_correlated_columns.sql\n@@ -0,0 +1,7 @@\n+set enable_analyzer = 1;\n+\n+SELECT min(*) y FROM (SELECT 1 IN (SELECT y));\n+\n+WITH toDateTime(*) AS t SELECT t IN (SELECT t WHERE t IN (SELECT t));\n+\n+SELECT (SELECT min(*) FROM (SELECT t0.c0)) AS a0, (SELECT a0) FROM (SELECT 1 c0) AS t0 SETTINGS allow_experimental_correlated_subqueries = 1; -- { serverError NOT_IMPLEMENTED }\n",
  "problem_statement": "Logical error: Cannot find the original scope of the column\n### Describe the bug\n\nFrom this run: https://s3.amazonaws.com/clickhouse-test-reports/json.html?REF=master&sha=c6dc04b2034b94744761cf4689510d2db5cec140&name_0=MasterCI&name_1=AST+fuzzer+%28amd_debug%29 It was introduced in v25.4. Time to bisect...\n\n### How to reproduce\n\nSimplified into this Fiddle: https://fiddle.clickhouse.com/2a2d13be-3e47-4c57-a14e-bc186db2093b\n\n### Error message and/or stacktrace\n\nStack trace:\n\n```\n<Fatal> : Logical error: 'Cannot find the original scope of the column'.\n<Fatal> : Stack trace (when copying this message, always include the lines below):\n\n0. std::exception::exception[abi:ne190107]() @ 0x0000000018108794\n1. base/poco/Foundation/src/Exception.cpp:27: Poco::Exception::Exception(String const&, int) @ 0x0000000036610f80\n2. src/Common/Exception.cpp:108: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x00000000249cfcab\n3. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000017fbc316\n4. DB::Exception::Exception<>(int, FormatStringHelperImpl<>) @ 0x0000000017fd14cf\n5. src/Analyzer/Utils.cpp:286: DB::checkCorrelatedColumn(DB::IdentifierResolveScope*, std::shared_ptr<DB::ColumnNode> const&) @ 0x000000002d7fb3f7\n6. src/Analyzer/Resolve/QueryAnalyzer.cpp:1387: DB::QueryAnalyzer::tryResolveIdentifierInParentScopes(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d942f59\n7. src/Analyzer/Resolve/QueryAnalyzer.cpp:1553: DB::QueryAnalyzer::tryResolveIdentifier(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d9420dc\n8. src/Analyzer/Resolve/QueryAnalyzer.cpp:1343: DB::QueryAnalyzer::tryResolveIdentifierInParentScopes(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d942b89\n9. src/Analyzer/Resolve/QueryAnalyzer.cpp:1553: DB::QueryAnalyzer::tryResolveIdentifier(DB::IdentifierLookup const&, DB::IdentifierResolveScope&, DB::IdentifierResolveContext) @ 0x000000002d9420dc\n10. src/Analyzer/Resolve/QueryAnalyzer.cpp:3732: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d92906a\n11. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f\n12. src/Analyzer/Resolve/QueryAnalyzer.cpp:4344: DB::QueryAnalyzer::resolveProjectionExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d96f70c\n13. src/Analyzer/Resolve/QueryAnalyzer.cpp:5641: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d52f\n14. src/Analyzer/Resolve/QueryAnalyzer.cpp:3910: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9282bf\n15. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f\n16. src/Analyzer/Resolve/QueryAnalyzer.cpp:2912: DB::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d94cd17\n17. src/Analyzer/Resolve/QueryAnalyzer.cpp:3878: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9284e0\n18. src/Analyzer/Resolve/QueryAnalyzer.cpp:4020: DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x000000002d92735f\n19. src/Analyzer/Resolve/QueryAnalyzer.cpp:4344: DB::QueryAnalyzer::resolveProjectionExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x000000002d96f70c\n20. src/Analyzer/Resolve/QueryAnalyzer.cpp:5641: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d52f\n21. src/Analyzer/Resolve/QueryAnalyzer.cpp:3910: DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x000000002d9282bf\n22. src/Analyzer/Resolve/QueryAnalyzer.cpp:5370: DB::QueryAnalyzer::resolveQueryJoinTreeNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, DB::QueryExpressionsAliasVisitor&) @ 0x000000002d973b49\n23. src/Analyzer/Resolve/QueryAnalyzer.cpp:5633: DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x000000002d91d4c8\n24. src/Analyzer/Resolve/QueryAnalyzer.cpp:180: DB::QueryAnalyzer::resolve(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::IQueryTreeNode> const&, std::shared_ptr<DB::Context const>) @ 0x000000002d91b169\n25. src/Analyzer/Resolve/QueryAnalysisPass.cpp:18: DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x000000002d91a791\n26. src/Analyzer/QueryTreePassManager.cpp:187: DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>) @ 0x000000002d9c73b9\n27. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:165: DB::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) @ 0x000000002eb44c28\n28. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:182: DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x000000002eb4227a\n29. contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:634: std::__unique_if<DB::InterpreterSelectQueryAnalyzer>::__unique_single std::make_unique[abi:ne190107]<DB::InterpreterSelectQueryAnalyzer, std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&>(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&) @ 0x000000002eb46c0e\n30. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:307: std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl[abi:ne190107]<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) @ 0x000000002eb46585\n31. contrib/llvm-project/libcxx/include/__functional/function.h:716: ? @ 0x000000002eab022f\n```\nUNSUPPORTED_METHOD error when adding alias based on JSON\n### Company or project name\n\n_No response_\n\n### Describe the unexpected behaviour\n\ni've noticed change in behavior between ClickHouse 24.12.1 and 25.3.1.\n\ni'm trying to migrate existing data structure that's based on arrays of ints, arrays of arrays of into JSON. to preserve backwards compatibility with existing queries - i'm trying to use alias, but those don't work in 25.3.1.\nthis code works fine in the older version but not in the latest stable:\n```\nset enable_json_type = 1;\ncreate or replace table inp ( id UInt64, name Array(UInt32), value Array(Array(UInt32)) ) order by id;\ncreate or replace table out0 ( id UInt64, j JSON ) order by id;\ninsert into inp ( id, name, value ) values(1, [1,2], [[3],[4]]);\ninsert into out0 select id, toJSONString(mapFromArrays(name,value)) from inp;\n\ncreate or replace table out1 ( id UInt64, j JSON, name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)), value Array(Array(UInt32)) alias arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)   )order by id;\ninsert into out1 select id, toJSONString(mapFromArrays(name,value)) from inp;\n\n-- so far so good\nselect * from out1;\n```\n\nSELECT will return expected result in 24.12.1 and error in 25.3.1:\n```\nCode: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolved identifier 'j' in parent scope to expression 'default.out1.j' with correlated column 'j'. In scope x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'). (UNSUPPORTED_METHOD)\n```\n\n\n\n### How to reproduce\n\nthis code works fine in the older version but not in the latest stable:\n```\nset enable_json_type = 1;\ncreate or replace table inp ( id UInt64, name Array(UInt32), value Array(Array(UInt32)) ) order by id;\ncreate or replace table out0 ( id UInt64, j JSON ) order by id;\ninsert into inp ( id, name, value ) values(1, [1,2], [[3],[4]]);\ninsert into out0 select id, toJSONString(mapFromArrays(name,value)) from inp;\n\n select arrayMap(x -> toUInt32(x), JSONAllPaths(j)) as name, arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name) from out0;\n\ncreate or replace table out1 ( id UInt64, j JSON, name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)), value Array(Array(UInt32)) alias arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)   )order by id;\ninsert into out1 select id, toJSONString(mapFromArrays(name,value)) from inp;\n\n\n-- so far so good\nselect * from out1;\n```\n\nSELECT will return expected result in 24.12.1 and error in 25.3.1:\n```\nCode: 1. DB::Exception: Received from localhost:9000. DB::Exception: Resolved identifier 'j' in parent scope to expression 'default.out1.j' with correlated column 'j'. In scope x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'). (UNSUPPORTED_METHOD)\n```\n\n\n\n### Expected behavior\n\nabove select should succeed as it does in 24.12.1\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\nclickhouse .deb from your builds. amd64 Debian linux.\n\nthx!\n",
  "hints_text": "Also seen in this job : https://github.com/ClickHouse/ClickHouse/actions/runs/14655920201/job/41131856524?pr=79563\n\nIt's not related to new JSON:\n```sql\ncreate table out1 ( id UInt64, j JSON, name Array(UInt32) ALIAS arrayMap(x -> toUInt32(x), JSONAllPaths(j)), value Array(Array(UInt32)) alias arrayMap(x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'), name)   )order by id;\ninsert into out1 select 42, '{\"a\" : 42}'\nselect * from out1;\n```\n\nAlso gives error:\n```\nReceived exception:\nCode: 1. DB::Exception: Resolved identifier 'j' in parent scope to expression 'default.out1.j' with correlated column 'j'. In scope x -> JSONExtract(CAST(j, 'String'), indexOf(name, x), 'Array(UInt32)'). (UNSUPPORTED_METHOD)\n```\n\nBut it works with disabled analyzer:\n```sql\nselect * from out1 settings enable_analyzer=0\n\n   \u250c\u2500id\u2500\u252c\u2500j\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n1. \u2502 42 \u2502 {\"a\" : 42} \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n@novikd can you take a look?\nYes, it's a bug related to identifier resolution in parent scopes. I suppose it was introduced by #66143. I'll take a look and try to fix it.\nas a note, for whomever might be googling for it - in 25.4.1 there's a new error message:\n\n```\nReceived exception from server (version 25.4.1):\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Cannot find the original scope of the column. (LOGICAL_ERROR)\n```\nwhich is the same as in https://github.com/clickhouse/clickhouse/issues/79451 although query differs.\n\nproposed workaround - adding _SETTINGS enable_analyzer=0_ still works.\n\n\n",
  "created_at": "2025-04-30T13:49:34Z"
}