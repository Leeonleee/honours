{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63452,
  "instance_id": "ClickHouse__ClickHouse-63452",
  "issue_numbers": [
    "52765"
  ],
  "base_commit": "fe2c7efc41dc6248499be5b38b4d10bc9582778f",
  "patch": "diff --git a/docs/en/sql-reference/table-functions/loop.md b/docs/en/sql-reference/table-functions/loop.md\nnew file mode 100644\nindex 000000000000..3a9367b2d108\n--- /dev/null\n+++ b/docs/en/sql-reference/table-functions/loop.md\n@@ -0,0 +1,55 @@\n+# loop\n+\n+**Syntax**\n+\n+``` sql\n+SELECT ... FROM loop(database, table);\n+SELECT ... FROM loop(database.table);\n+SELECT ... FROM loop(table);\n+SELECT ... FROM loop(other_table_function(...));\n+```\n+\n+**Parameters**\n+\n+- `database` \u2014 database name.\n+- `table` \u2014 table name.\n+- `other_table_function(...)` \u2014 other table function.\n+  Example: `SELECT * FROM loop(numbers(10));`\n+  `other_table_function(...)` here is `numbers(10)`.\n+\n+**Returned Value**\n+\n+Infinite loop to return query results.\n+\n+**Examples**\n+\n+Selecting data from ClickHouse:\n+\n+``` sql\n+SELECT * FROM loop(test_database, test_table);\n+SELECT * FROM loop(test_database.test_table);\n+SELECT * FROM loop(test_table);\n+```\n+\n+Or using other table function:\n+\n+``` sql\n+SELECT * FROM loop(numbers(3)) LIMIT 7;\n+   \u250c\u2500number\u2500\u2510\n+1. \u2502      0 \u2502\n+2. \u2502      1 \u2502\n+3. \u2502      2 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+   \u250c\u2500number\u2500\u2510\n+4. \u2502      0 \u2502\n+5. \u2502      1 \u2502\n+6. \u2502      2 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+   \u250c\u2500number\u2500\u2510\n+7. \u2502      0 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+``` \n+``` sql\n+SELECT * FROM loop(mysql('localhost:3306', 'test', 'test', 'user', 'password'));\n+...\n+```\n\\ No newline at end of file\ndiff --git a/src/Processors/QueryPlan/ReadFromLoopStep.cpp b/src/Processors/QueryPlan/ReadFromLoopStep.cpp\nnew file mode 100644\nindex 000000000000..10436490a2aa\n--- /dev/null\n+++ b/src/Processors/QueryPlan/ReadFromLoopStep.cpp\n@@ -0,0 +1,156 @@\n+#include <Processors/QueryPlan/ReadFromLoopStep.h>\n+#include <Processors/QueryPlan/QueryPlan.h>\n+#include <Storages/IStorage.h>\n+#include <QueryPipeline/QueryPipelineBuilder.h>\n+#include <QueryPipeline/QueryPipeline.h>\n+#include <Processors/QueryPlan/BuildQueryPipelineSettings.h>\n+#include <Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h>\n+#include <QueryPipeline/QueryPlanResourceHolder.h>\n+#include <Processors/ISource.h>\n+#include <Processors/Sources/NullSource.h>\n+#include <Processors/Executors/PullingPipelineExecutor.h>\n+\n+namespace DB\n+{\n+    namespace ErrorCodes\n+    {\n+        extern const int TOO_MANY_RETRIES_TO_FETCH_PARTS;\n+    }\n+    class PullingPipelineExecutor;\n+\n+    class LoopSource : public ISource\n+    {\n+    public:\n+\n+        LoopSource(\n+                const Names & column_names_,\n+                const SelectQueryInfo & query_info_,\n+                const StorageSnapshotPtr & storage_snapshot_,\n+                ContextPtr & context_,\n+                QueryProcessingStage::Enum processed_stage_,\n+                StoragePtr inner_storage_,\n+                size_t max_block_size_,\n+                size_t num_streams_)\n+                : ISource(storage_snapshot_->getSampleBlockForColumns(column_names_))\n+                , column_names(column_names_)\n+                , query_info(query_info_)\n+                , storage_snapshot(storage_snapshot_)\n+                , processed_stage(processed_stage_)\n+                , context(context_)\n+                , inner_storage(std::move(inner_storage_))\n+                , max_block_size(max_block_size_)\n+                , num_streams(num_streams_)\n+        {\n+        }\n+\n+        String getName() const override { return \"Loop\"; }\n+\n+        Chunk generate() override\n+        {\n+            while (true)\n+            {\n+                if (!loop)\n+                {\n+                    QueryPlan plan;\n+                    auto storage_snapshot_ = inner_storage->getStorageSnapshotForQuery(inner_storage->getInMemoryMetadataPtr(), nullptr, context);\n+                    inner_storage->read(\n+                            plan,\n+                            column_names,\n+                            storage_snapshot_,\n+                            query_info,\n+                            context,\n+                            processed_stage,\n+                            max_block_size,\n+                            num_streams);\n+                    auto builder = plan.buildQueryPipeline(\n+                            QueryPlanOptimizationSettings::fromContext(context),\n+                            BuildQueryPipelineSettings::fromContext(context));\n+                    QueryPlanResourceHolder resources;\n+                    auto pipe = QueryPipelineBuilder::getPipe(std::move(*builder), resources);\n+                    query_pipeline = QueryPipeline(std::move(pipe));\n+                    executor = std::make_unique<PullingPipelineExecutor>(query_pipeline);\n+                    loop = true;\n+                }\n+                Chunk chunk;\n+                if (executor->pull(chunk))\n+                {\n+                    if (chunk)\n+                    {\n+                        retries_count = 0;\n+                        return chunk;\n+                    }\n+\n+                }\n+                else\n+                {\n+                    ++retries_count;\n+                    if (retries_count > max_retries_count)\n+                        throw Exception(ErrorCodes::TOO_MANY_RETRIES_TO_FETCH_PARTS, \"Too many retries to pull from storage\");\n+                    loop = false;\n+                    executor.reset();\n+                    query_pipeline.reset();\n+                }\n+            }\n+        }\n+\n+    private:\n+\n+        const Names column_names;\n+        SelectQueryInfo query_info;\n+        const StorageSnapshotPtr storage_snapshot;\n+        QueryProcessingStage::Enum processed_stage;\n+        ContextPtr context;\n+        StoragePtr inner_storage;\n+        size_t max_block_size;\n+        size_t num_streams;\n+        // add retries. If inner_storage failed to pull X times in a row we'd better to fail here not to hang\n+        size_t retries_count = 0;\n+        size_t max_retries_count = 3;\n+        bool loop = false;\n+        QueryPipeline query_pipeline;\n+        std::unique_ptr<PullingPipelineExecutor> executor;\n+    };\n+\n+    ReadFromLoopStep::ReadFromLoopStep(\n+            const Names & column_names_,\n+            const SelectQueryInfo & query_info_,\n+            const StorageSnapshotPtr & storage_snapshot_,\n+            const ContextPtr & context_,\n+            QueryProcessingStage::Enum processed_stage_,\n+            StoragePtr inner_storage_,\n+            size_t max_block_size_,\n+            size_t num_streams_)\n+            : SourceStepWithFilter(\n+            DataStream{.header = storage_snapshot_->getSampleBlockForColumns(column_names_)},\n+            column_names_,\n+            query_info_,\n+            storage_snapshot_,\n+            context_)\n+            , column_names(column_names_)\n+            , processed_stage(processed_stage_)\n+            , inner_storage(std::move(inner_storage_))\n+            , max_block_size(max_block_size_)\n+            , num_streams(num_streams_)\n+    {\n+    }\n+\n+    Pipe ReadFromLoopStep::makePipe()\n+    {\n+        return Pipe(std::make_shared<LoopSource>(\n+                column_names, query_info, storage_snapshot, context, processed_stage, inner_storage, max_block_size, num_streams));\n+    }\n+\n+    void ReadFromLoopStep::initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n+    {\n+        auto pipe = makePipe();\n+\n+        if (pipe.empty())\n+        {\n+            assert(output_stream != std::nullopt);\n+            pipe = Pipe(std::make_shared<NullSource>(output_stream->header));\n+        }\n+\n+        pipeline.init(std::move(pipe));\n+    }\n+\n+}\ndiff --git a/src/Processors/QueryPlan/ReadFromLoopStep.h b/src/Processors/QueryPlan/ReadFromLoopStep.h\nnew file mode 100644\nindex 000000000000..4eee0ca56057\n--- /dev/null\n+++ b/src/Processors/QueryPlan/ReadFromLoopStep.h\n@@ -0,0 +1,37 @@\n+#pragma once\n+#include <Core/QueryProcessingStage.h>\n+#include <Processors/QueryPlan/SourceStepWithFilter.h>\n+#include <QueryPipeline/Pipe.h>\n+#include <Storages/SelectQueryInfo.h>\n+\n+namespace DB\n+{\n+\n+    class ReadFromLoopStep final : public SourceStepWithFilter\n+    {\n+    public:\n+        ReadFromLoopStep(\n+                const Names & column_names_,\n+                const SelectQueryInfo & query_info_,\n+                const StorageSnapshotPtr & storage_snapshot_,\n+                const ContextPtr & context_,\n+                QueryProcessingStage::Enum processed_stage_,\n+                StoragePtr inner_storage_,\n+                size_t max_block_size_,\n+                size_t num_streams_);\n+\n+        String getName() const override { return \"ReadFromLoop\"; }\n+\n+        void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;\n+\n+    private:\n+\n+        Pipe makePipe();\n+\n+        const Names column_names;\n+        QueryProcessingStage::Enum processed_stage;\n+        StoragePtr inner_storage;\n+        size_t max_block_size;\n+        size_t num_streams;\n+    };\n+}\ndiff --git a/src/Storages/StorageLoop.cpp b/src/Storages/StorageLoop.cpp\nnew file mode 100644\nindex 000000000000..2062749e60b3\n--- /dev/null\n+++ b/src/Storages/StorageLoop.cpp\n@@ -0,0 +1,49 @@\n+#include \"StorageLoop.h\"\n+#include <Storages/StorageFactory.h>\n+#include <Processors/QueryPlan/QueryPlan.h>\n+#include <Processors/QueryPlan/ReadFromLoopStep.h>\n+\n+\n+namespace DB\n+{\n+    namespace ErrorCodes\n+    {\n+\n+    }\n+    StorageLoop::StorageLoop(\n+            const StorageID & table_id_,\n+            StoragePtr inner_storage_)\n+            : IStorage(table_id_)\n+            , inner_storage(std::move(inner_storage_))\n+    {\n+        StorageInMemoryMetadata storage_metadata = inner_storage->getInMemoryMetadata();\n+        setInMemoryMetadata(storage_metadata);\n+    }\n+\n+\n+    void StorageLoop::read(\n+            QueryPlan & query_plan,\n+            const Names & column_names,\n+            const StorageSnapshotPtr & storage_snapshot,\n+            SelectQueryInfo & query_info,\n+            ContextPtr context,\n+            QueryProcessingStage::Enum processed_stage,\n+            size_t max_block_size,\n+            size_t num_streams)\n+    {\n+        query_info.optimize_trivial_count = false;\n+\n+        query_plan.addStep(std::make_unique<ReadFromLoopStep>(\n+                column_names, query_info, storage_snapshot, context, processed_stage, inner_storage, max_block_size, num_streams\n+        ));\n+    }\n+\n+    void registerStorageLoop(StorageFactory & factory)\n+    {\n+        factory.registerStorage(\"Loop\", [](const StorageFactory::Arguments & args)\n+        {\n+            StoragePtr inner_storage;\n+            return std::make_shared<StorageLoop>(args.table_id, inner_storage);\n+        });\n+    }\n+}\ndiff --git a/src/Storages/StorageLoop.h b/src/Storages/StorageLoop.h\nnew file mode 100644\nindex 000000000000..48760b169c20\n--- /dev/null\n+++ b/src/Storages/StorageLoop.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+#include \"config.h\"\n+#include <Storages/IStorage.h>\n+\n+\n+namespace DB\n+{\n+\n+    class StorageLoop final : public IStorage\n+    {\n+    public:\n+        StorageLoop(\n+                const StorageID & table_id,\n+                StoragePtr inner_storage_);\n+\n+        std::string getName() const override { return \"Loop\"; }\n+\n+        void read(\n+                QueryPlan & query_plan,\n+                const Names & column_names,\n+                const StorageSnapshotPtr & storage_snapshot,\n+                SelectQueryInfo & query_info,\n+                ContextPtr context,\n+                QueryProcessingStage::Enum processed_stage,\n+                size_t max_block_size,\n+                size_t num_streams) override;\n+\n+        bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return false; }\n+\n+    private:\n+        StoragePtr inner_storage;\n+    };\n+}\ndiff --git a/src/Storages/registerStorages.cpp b/src/Storages/registerStorages.cpp\nindex 0fb00c08acc8..47542b7b47ea 100644\n--- a/src/Storages/registerStorages.cpp\n+++ b/src/Storages/registerStorages.cpp\n@@ -25,6 +25,7 @@ void registerStorageLiveView(StorageFactory & factory);\n void registerStorageGenerateRandom(StorageFactory & factory);\n void registerStorageExecutable(StorageFactory & factory);\n void registerStorageWindowView(StorageFactory & factory);\n+void registerStorageLoop(StorageFactory & factory);\n #if USE_RAPIDJSON || USE_SIMDJSON\n void registerStorageFuzzJSON(StorageFactory & factory);\n #endif\n@@ -120,6 +121,7 @@ void registerStorages()\n     registerStorageGenerateRandom(factory);\n     registerStorageExecutable(factory);\n     registerStorageWindowView(factory);\n+    registerStorageLoop(factory);\n #if USE_RAPIDJSON || USE_SIMDJSON\n     registerStorageFuzzJSON(factory);\n #endif\ndiff --git a/src/TableFunctions/TableFunctionLoop.cpp b/src/TableFunctions/TableFunctionLoop.cpp\nnew file mode 100644\nindex 000000000000..0281002e50f3\n--- /dev/null\n+++ b/src/TableFunctions/TableFunctionLoop.cpp\n@@ -0,0 +1,156 @@\n+#include \"config.h\"\n+#include <TableFunctions/ITableFunction.h>\n+#include <TableFunctions/TableFunctionFactory.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/DatabaseCatalog.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Common/Exception.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+#include <Storages/checkAndGetLiteralArgument.h>\n+#include <Storages/StorageLoop.h>\n+#include \"registerTableFunctions.h\"\n+\n+namespace DB\n+{\n+    namespace ErrorCodes\n+    {\n+        extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+        extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+        extern const int UNKNOWN_TABLE;\n+    }\n+    namespace\n+    {\n+        class TableFunctionLoop : public ITableFunction\n+        {\n+        public:\n+            static constexpr auto name = \"loop\";\n+            std::string getName() const override { return name; }\n+        private:\n+            StoragePtr executeImpl(const ASTPtr & ast_function, ContextPtr context, const String & table_name, ColumnsDescription cached_columns, bool is_insert_query) const override;\n+            const char * getStorageTypeName() const override { return \"Loop\"; }\n+            ColumnsDescription getActualTableStructure(ContextPtr context, bool is_insert_query) const override;\n+            void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;\n+\n+            // save the inner table function AST\n+            ASTPtr inner_table_function_ast;\n+            // save database and table\n+            std::string loop_database_name;\n+            std::string loop_table_name;\n+        };\n+\n+    }\n+\n+    void TableFunctionLoop::parseArguments(const ASTPtr & ast_function, ContextPtr context)\n+    {\n+        const auto & args_func = ast_function->as<ASTFunction &>();\n+\n+        if (!args_func.arguments)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Table function 'loop' must have arguments.\");\n+\n+        auto & args = args_func.arguments->children;\n+        if (args.empty())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"No arguments provided for table function 'loop'\");\n+\n+        if (args.size() == 1)\n+        {\n+            if (const auto * id = args[0]->as<ASTIdentifier>())\n+            {\n+                String id_name = id->name();\n+\n+                size_t dot_pos = id_name.find('.');\n+                if (id_name.find('.', dot_pos + 1) != String::npos)\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"There are more than one dot\");\n+                if (dot_pos != String::npos)\n+                {\n+                    loop_database_name = id_name.substr(0, dot_pos);\n+                    loop_table_name = id_name.substr(dot_pos + 1);\n+                }\n+                else\n+                {\n+                    loop_table_name = id_name;\n+                }\n+            }\n+            else if (const auto * func = args[0]->as<ASTFunction>())\n+            {\n+                inner_table_function_ast = args[0];\n+            }\n+            else\n+            {\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Expected identifier or function for argument 1 of function 'loop', got {}\", args[0]->getID());\n+            }\n+        }\n+            // loop(database, table)\n+        else if (args.size() == 2)\n+        {\n+            args[0] = evaluateConstantExpressionForDatabaseName(args[0], context);\n+            args[1] = evaluateConstantExpressionOrIdentifierAsLiteral(args[1], context);\n+\n+            loop_database_name = checkAndGetLiteralArgument<String>(args[0], \"database\");\n+            loop_table_name = checkAndGetLiteralArgument<String>(args[1], \"table\");\n+        }\n+        else\n+        {\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Table function 'loop' must have 1 or 2 arguments.\");\n+        }\n+    }\n+\n+    ColumnsDescription TableFunctionLoop::getActualTableStructure(ContextPtr /*context*/, bool /*is_insert_query*/) const\n+    {\n+        return ColumnsDescription();\n+    }\n+\n+    StoragePtr TableFunctionLoop::executeImpl(\n+            const ASTPtr & /*ast_function*/,\n+            ContextPtr context,\n+            const std::string & table_name,\n+            ColumnsDescription cached_columns,\n+            bool is_insert_query) const\n+    {\n+        StoragePtr storage;\n+        if (!loop_table_name.empty())\n+        {\n+            String database_name = loop_database_name;\n+            if (database_name.empty())\n+                database_name = context->getCurrentDatabase();\n+\n+            auto database = DatabaseCatalog::instance().getDatabase(database_name);\n+            storage = database->tryGetTable(loop_table_name, context);\n+            if (!storage)\n+                throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table '{}' not found in database '{}'\", loop_table_name, database_name);\n+        }\n+\n+        else\n+        {\n+            auto inner_table_function = TableFunctionFactory::instance().get(inner_table_function_ast, context);\n+            storage = inner_table_function->execute(\n+                    inner_table_function_ast,\n+                    context,\n+                    table_name,\n+                    std::move(cached_columns),\n+                    is_insert_query);\n+        }\n+        auto res = std::make_shared<StorageLoop>(\n+                StorageID(getDatabaseName(), table_name),\n+                storage\n+        );\n+        res->startup();\n+        return res;\n+    }\n+\n+    void registerTableFunctionLoop(TableFunctionFactory & factory)\n+    {\n+        factory.registerFunction<TableFunctionLoop>(\n+                {.documentation\n+                = {.description=R\"(The table function can be used to continuously output query results in an infinite loop.)\",\n+                                .examples{{\"loop\", \"SELECT * FROM loop((numbers(3)) LIMIT 7\", \"0\"\n+                                                                                              \"1\"\n+                                                                                              \"2\"\n+                                                                                              \"0\"\n+                                                                                              \"1\"\n+                                                                                              \"2\"\n+                                                                                              \"0\"}}\n+                        }});\n+    }\n+\n+}\ndiff --git a/src/TableFunctions/registerTableFunctions.cpp b/src/TableFunctions/registerTableFunctions.cpp\nindex 26b9a7714164..ca4913898f96 100644\n--- a/src/TableFunctions/registerTableFunctions.cpp\n+++ b/src/TableFunctions/registerTableFunctions.cpp\n@@ -11,6 +11,7 @@ void registerTableFunctions()\n     registerTableFunctionMerge(factory);\n     registerTableFunctionRemote(factory);\n     registerTableFunctionNumbers(factory);\n+    registerTableFunctionLoop(factory);\n     registerTableFunctionGenerateSeries(factory);\n     registerTableFunctionNull(factory);\n     registerTableFunctionZeros(factory);\ndiff --git a/src/TableFunctions/registerTableFunctions.h b/src/TableFunctions/registerTableFunctions.h\nindex 4a89b3afbb3b..efde4d6dcdc0 100644\n--- a/src/TableFunctions/registerTableFunctions.h\n+++ b/src/TableFunctions/registerTableFunctions.h\n@@ -8,6 +8,7 @@ class TableFunctionFactory;\n void registerTableFunctionMerge(TableFunctionFactory & factory);\n void registerTableFunctionRemote(TableFunctionFactory & factory);\n void registerTableFunctionNumbers(TableFunctionFactory & factory);\n+void registerTableFunctionLoop(TableFunctionFactory & factory);\n void registerTableFunctionGenerateSeries(TableFunctionFactory & factory);\n void registerTableFunctionNull(TableFunctionFactory & factory);\n void registerTableFunctionZeros(TableFunctionFactory & factory);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03147_table_function_loop.reference b/tests/queries/0_stateless/03147_table_function_loop.reference\nnew file mode 100644\nindex 000000000000..46a2310b65f1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03147_table_function_loop.reference\n@@ -0,0 +1,65 @@\n+0\n+1\n+2\n+0\n+1\n+2\n+0\n+1\n+2\n+0\n+0\n+1\n+2\n+0\n+1\n+2\n+0\n+1\n+2\n+0\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+0\n+1\n+2\n+3\n+4\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+0\n+1\n+2\n+3\n+4\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+0\n+1\n+2\n+3\n+4\ndiff --git a/tests/queries/0_stateless/03147_table_function_loop.sql b/tests/queries/0_stateless/03147_table_function_loop.sql\nnew file mode 100644\nindex 000000000000..af48e4b11e31\n--- /dev/null\n+++ b/tests/queries/0_stateless/03147_table_function_loop.sql\n@@ -0,0 +1,14 @@\n+-- Tags: no-parallel\n+\n+SELECT * FROM loop(numbers(3)) LIMIT 10;\n+SELECT * FROM loop (numbers(3)) LIMIT 10 settings max_block_size = 1;\n+\n+DROP DATABASE IF EXISTS 03147_db;\n+CREATE DATABASE IF NOT EXISTS 03147_db;\n+CREATE TABLE 03147_db.t (n Int8) ENGINE=MergeTree ORDER BY n;\n+INSERT INTO 03147_db.t SELECT * FROM numbers(10);\n+USE 03147_db;\n+\n+SELECT * FROM loop(03147_db.t) LIMIT 15;\n+SELECT * FROM loop(t) LIMIT 15;\n+SELECT * FROM loop(03147_db, t) LIMIT 15;\n",
  "problem_statement": "Table function `loop`\n**Use case**\r\n\r\nTests and benchmarks.\r\n\r\n```\r\nSELECT ... FROM loop(database, table);\r\nSELECT ... FROM loop(database.table);\r\nSELECT ... FROM loop(table);\r\nSELECT ... FROM loop(other_table_function(...));\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nEvery interface method is forwarded, but for reading, the pipeline is modified to repeat the reading when it is finished,\r\nand writing is not allowed. Trivial count optimization is disabled. Index analysis works in the same way as for the argument's table.\r\n\r\nIt is unspecified if the function should use the same table snapshot on every reading or different.\r\n\n",
  "hints_text": "",
  "created_at": "2024-05-07T07:23:07Z"
}