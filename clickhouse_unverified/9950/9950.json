{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9950,
  "instance_id": "ClickHouse__ClickHouse-9950",
  "issue_numbers": [
    "9810"
  ],
  "base_commit": "7974fcb9d7c033734a5a171d09b61782ab3a7e7a",
  "patch": "diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp\nindex a18d34af9942..bc29a74f4ebd 100644\n--- a/src/Core/Block.cpp\n+++ b/src/Core/Block.cpp\n@@ -181,25 +181,25 @@ const ColumnWithTypeAndName & Block::safeGetByPosition(size_t position) const\n }\n \n \n-ColumnWithTypeAndName & Block::getByName(const std::string & name)\n+const ColumnWithTypeAndName * Block::findByName(const std::string & name) const\n {\n     auto it = index_by_name.find(name);\n     if (index_by_name.end() == it)\n-        throw Exception(\"Not found column \" + name + \" in block. There are only columns: \" + dumpNames()\n-            , ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);\n-\n-    return data[it->second];\n+    {\n+        return nullptr;\n+    }\n+    return &data[it->second];\n }\n \n \n const ColumnWithTypeAndName & Block::getByName(const std::string & name) const\n {\n-    auto it = index_by_name.find(name);\n-    if (index_by_name.end() == it)\n+    auto * result = findByName(name);\n+    if (!result)\n         throw Exception(\"Not found column \" + name + \" in block. There are only columns: \" + dumpNames()\n             , ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);\n \n-    return data[it->second];\n+    return *result;\n }\n \n \ndiff --git a/src/Core/Block.h b/src/Core/Block.h\nindex 82b60c83efbc..ce804ddc0b5d 100644\n--- a/src/Core/Block.h\n+++ b/src/Core/Block.h\n@@ -28,7 +28,7 @@ class Block\n {\n private:\n     using Container = ColumnsWithTypeAndName;\n-    using IndexByName = std::map<String, size_t>;\n+    using IndexByName = std::unordered_map<String, size_t>;\n \n     Container data;\n     IndexByName index_by_name;\n@@ -64,7 +64,20 @@ class Block\n     ColumnWithTypeAndName & safeGetByPosition(size_t position);\n     const ColumnWithTypeAndName & safeGetByPosition(size_t position) const;\n \n-    ColumnWithTypeAndName & getByName(const std::string & name);\n+    ColumnWithTypeAndName* findByName(const std::string & name)\n+    {\n+        return const_cast<ColumnWithTypeAndName *>(\n+            const_cast<const Block *>(this)->findByName(name));\n+    }\n+\n+    const ColumnWithTypeAndName* findByName(const std::string & name) const;\n+\n+    ColumnWithTypeAndName & getByName(const std::string & name)\n+    {\n+        return const_cast<ColumnWithTypeAndName &>(\n+            const_cast<const Block *>(this)->getByName(name));\n+    }\n+\n     const ColumnWithTypeAndName & getByName(const std::string & name) const;\n \n     Container::iterator begin() { return data.begin(); }\ndiff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex 38656c47765c..b810182eb48a 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -195,14 +195,6 @@ SetPtr makeExplicitSet(\n     return set;\n }\n \n-static String getUniqueName(const Block & block, const String & prefix)\n-{\n-    int i = 1;\n-    while (block.has(prefix + toString(i)))\n-        ++i;\n-    return prefix + toString(i);\n-}\n-\n ScopeStack::ScopeStack(const ExpressionActionsPtr & actions, const Context & context_)\n     : context(context_)\n {\n@@ -431,7 +423,6 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n     for (size_t arg = 0; arg < node.arguments->children.size(); ++arg)\n     {\n         auto & child = node.arguments->children[arg];\n-        auto child_column_name = child->getColumnName();\n \n         const auto * lambda = child->as<ASTFunction>();\n         const auto * identifier = child->as<ASTIdentifier>();\n@@ -459,9 +450,9 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n             /// If the argument is a set given by an enumeration of values (so, the set was already built), give it a unique name,\n             ///  so that sets with the same literal representation do not fuse together (they can have different types).\n             if (!prepared_set->empty())\n-                column.name = getUniqueName(data.getSampleBlock(), \"__set\");\n+                column.name = data.getUniqueName(\"__set\");\n             else\n-                column.name = child_column_name;\n+                column.name = child->getColumnName();\n \n             if (!data.hasColumn(column.name))\n             {\n@@ -487,7 +478,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n             ColumnWithTypeAndName column(\n                 ColumnConst::create(std::move(column_string), 1),\n                 std::make_shared<DataTypeString>(),\n-                getUniqueName(data.getSampleBlock(), \"__joinGet\"));\n+                data.getUniqueName(\"__joinGet\"));\n             data.addAction(ExpressionAction::addColumn(column));\n             argument_types.push_back(column.type);\n             argument_names.push_back(column.name);\n@@ -496,6 +487,18 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         {\n             /// If the argument is not a lambda expression, call it recursively and find out its type.\n             visit(child, data);\n+\n+            // In the above visit() call, if the argument is a literal, we\n+            // generated a unique column name for it. Use it instead of a generic\n+            // display name.\n+            auto child_column_name = child->getColumnName();\n+            auto as_literal = child->as<ASTLiteral>();\n+            if (as_literal)\n+            {\n+                assert(!as_literal->unique_column_name.empty());\n+                child_column_name = as_literal->unique_column_name;\n+            }\n+\n             if (data.hasColumn(child_column_name))\n             {\n                 argument_types.push_back(data.getSampleBlock().getByName(child_column_name).type);\n@@ -556,7 +559,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n \n                 /// We can not name `getColumnName()`,\n                 ///  because it does not uniquely define the expression (the types of arguments can be different).\n-                String lambda_name = getUniqueName(data.getSampleBlock(), \"__lambda\");\n+                String lambda_name = data.getUniqueName(\"__lambda\");\n \n                 auto function_capture = std::make_unique<FunctionCaptureOverloadResolver>(\n                         lambda_actions, captured, lambda_arguments, result_type, result_name);\n@@ -587,18 +590,53 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n     }\n }\n \n-void ActionsMatcher::visit(const ASTLiteral & literal, const ASTPtr & ast, Data & data)\n+void ActionsMatcher::visit(const ASTLiteral & literal, const ASTPtr & /* ast */,\n+    Data & data)\n {\n-    CachedColumnName column_name;\n-    if (data.hasColumn(column_name.get(ast)))\n-        return;\n-\n     DataTypePtr type = applyVisitor(FieldToDataType(), literal.value);\n+    const auto value = convertFieldToType(literal.value, *type);\n+\n+    // FIXME why do we have a second pass with a clean sample block over the same\n+    // AST here? Anyway, do not modify the column name if it is set already.\n+    if (literal.unique_column_name.empty())\n+    {\n+        const auto default_name = literal.getColumnName();\n+        auto & block = data.getSampleBlock();\n+        auto * existing_column = block.findByName(default_name);\n+\n+        /*\n+         * To approximate CSE, bind all identical literals to a single temporary\n+         * columns. We try to find the column by its default name, but after that\n+         * we have to check that it contains the correct data. This might not be\n+         * the case if it is a user-supplied column, or it is from under a join,\n+         * etc.\n+         * Overall, this is a hack around a generally poor name-based notion of\n+         * column identity we currently use.\n+         */\n+        if (existing_column\n+            && existing_column->column\n+            && isColumnConst(*existing_column->column)\n+            && existing_column->column->size() == 1\n+            && existing_column->column->operator[](0) == value)\n+        {\n+            const_cast<ASTLiteral &>(literal).unique_column_name = default_name;\n+        }\n+        else\n+        {\n+            const_cast<ASTLiteral &>(literal).unique_column_name\n+                = data.getUniqueName(default_name);\n+        }\n+    }\n+\n+    if (data.hasColumn(literal.unique_column_name))\n+    {\n+        return;\n+    }\n \n     ColumnWithTypeAndName column;\n-    column.column = type->createColumnConst(1, convertFieldToType(literal.value, *type));\n+    column.name = literal.unique_column_name;\n+    column.column = type->createColumnConst(1, value);\n     column.type = type;\n-    column.name = column_name.get(ast);\n \n     data.addAction(ExpressionAction::addColumn(column));\n }\ndiff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h\nindex f6db551ff332..dbcc54c01d65 100644\n--- a/src/Interpreters/ActionsVisitor.h\n+++ b/src/Interpreters/ActionsVisitor.h\n@@ -80,6 +80,13 @@ class ActionsMatcher\n         size_t visit_depth;\n         ScopeStack actions_stack;\n \n+        /*\n+         * Remember the last unique column suffix to avoid quadratic behavior\n+         * when we add lots of column with same prefix. One counter for all\n+         * prefixes is good enough.\n+         */\n+        int next_unique_suffix;\n+\n         Data(const Context & context_, SizeLimits set_size_limit_, size_t subquery_depth_,\n                 const NamesAndTypesList & source_columns_, const ExpressionActionsPtr & actions,\n                 PreparedSets & prepared_sets_, SubqueriesForSets & subqueries_for_sets_,\n@@ -95,7 +102,8 @@ class ActionsMatcher\n             only_consts(only_consts_),\n             no_storage_or_local(no_storage_or_local_),\n             visit_depth(0),\n-            actions_stack(actions, context)\n+            actions_stack(actions, context),\n+            next_unique_suffix(actions_stack.getSampleBlock().columns() + 1)\n         {}\n \n         void updateActions(ExpressionActionsPtr & actions)\n@@ -118,6 +126,26 @@ class ActionsMatcher\n         {\n             return actions_stack.getSampleBlock().has(columnName);\n         }\n+\n+        /*\n+         * Generate a column name that is not present in the sample block, using\n+         * the given prefix and an optional numeric suffix.\n+         */\n+        String getUniqueName(const String & prefix)\n+        {\n+            const auto & block = getSampleBlock();\n+            auto result = prefix;\n+\n+            // First, try the name without any suffix, because it is currently\n+            // used both as a display name and a column id.\n+            while (block.has(result))\n+            {\n+                result = prefix + \"_\" + toString(next_unique_suffix);\n+                ++next_unique_suffix;\n+            }\n+\n+            return result;\n+        }\n     };\n \n     static void visit(const ASTPtr & ast, Data & data);\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 9ec32737fdcb..bb33aca76558 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -854,7 +854,34 @@ void SelectQueryExpressionAnalyzer::appendProjectResult(ExpressionActionsChain &\n         String result_name = ast->getAliasOrColumnName();\n         if (required_result_columns.empty() || required_result_columns.count(result_name))\n         {\n-            result_columns.emplace_back(ast->getColumnName(), result_name);\n+            std::string source_name = ast->getColumnName();\n+\n+            /*\n+             * For temporary columns created by ExpressionAnalyzer for literals,\n+             * use the correct source column. Using the default display name\n+             * returned by getColumnName is not enough, and we have to use the\n+             * column id set by EA. In principle, this logic applies to all kinds\n+             * of columns, not only literals. Literals are especially problematic\n+             * for two reasons:\n+             * 1) confusing different literal columns leads to weird side\n+             *    effects (see 01101_literal_columns_clash);\n+             * 2) the disambiguation mechanism in SyntaxAnalyzer, that, among\n+             *    other things, creates unique aliases for columns with same\n+             *    names from different tables, is applied before these temporary\n+             *    columns are created by ExpressionAnalyzer.\n+             * Similar problems should also manifest for function columns, which\n+             * are likewise created at a later stage by EA.\n+             * In general, we need to have explicit separation between display\n+             * names and identifiers for columns. This code is a workaround for\n+             * a particular subclass of problems, and not a proper solution.\n+             */\n+            if (auto as_literal = ast->as<ASTLiteral>())\n+            {\n+                source_name = as_literal->unique_column_name;\n+                assert(!source_name.empty());\n+            }\n+\n+            result_columns.emplace_back(source_name, result_name);\n             step.required_output.push_back(result_columns.back().second);\n         }\n     }\ndiff --git a/src/Parsers/ASTLiteral.h b/src/Parsers/ASTLiteral.h\nindex 552f5da04a2d..18f440a81a4a 100644\n--- a/src/Parsers/ASTLiteral.h\n+++ b/src/Parsers/ASTLiteral.h\n@@ -21,6 +21,17 @@ class ASTLiteral : public ASTWithAlias\n     std::optional<TokenIterator> begin;\n     std::optional<TokenIterator> end;\n \n+    /*\n+     * The name of the column corresponding to this literal. Only used to\n+     * disambiguate the literal columns with the same display name that are\n+     * created at the expression analyzer stage. In the future, we might want to\n+     * have a full separation between display names and column identifiers. For\n+     * now, this field is effectively just some private EA data.\n+     */\n+    String unique_column_name;\n+\n+\n+public:\n     ASTLiteral(Field && value_) : value(value_) {}\n     ASTLiteral(const Field & value_) : value(value_) {}\n \n",
  "test_patch": "diff --git a/tests/integration/test_row_policy/test.py b/tests/integration/test_row_policy/test.py\nindex 3a5b73405284..75c75e3b20ab 100644\n--- a/tests/integration/test_row_policy/test.py\n+++ b/tests/integration/test_row_policy/test.py\n@@ -102,8 +102,8 @@ def test_join():\n \n def test_cannot_trick_row_policy_with_keyword_with():\n     assert instance.query(\"WITH 0 AS a SELECT * FROM mydb.filtered_table1\") == \"1\\t0\\n1\\t1\\n\"\n-    assert instance.query(\"WITH 0 AS a SELECT a, b FROM mydb.filtered_table1\") == \"1\\t0\\n1\\t1\\n\"\n-    assert instance.query(\"WITH 0 AS a SELECT a FROM mydb.filtered_table1\") == \"1\\n1\\n\"\n+    assert instance.query(\"WITH 0 AS a SELECT a, b FROM mydb.filtered_table1\") == \"0\\t0\\n0\\t1\\n\"\n+    assert instance.query(\"WITH 0 AS a SELECT a FROM mydb.filtered_table1\") == \"0\\n0\\n\"\n     assert instance.query(\"WITH 0 AS a SELECT b FROM mydb.filtered_table1\") == \"0\\n1\\n\"\n \n \ndiff --git a/tests/queries/0_stateless/01101_literal_column_clash.reference b/tests/queries/0_stateless/01101_literal_column_clash.reference\nnew file mode 100644\nindex 000000000000..47458541f793\n--- /dev/null\n+++ b/tests/queries/0_stateless/01101_literal_column_clash.reference\n@@ -0,0 +1,14 @@\n+1\n+7\t3\n+7\t0\n+7\t1\n+xyzabc\t2\n+1\t3\n+1\t2\t0\t0\n+1\t0\t0\t3\n+\\N\t1\t2\t\\N\t0\n+\\N\t1\t0\t\\N\t3\n+1\n+1\n+1\thello\\0\\0\\0\n+1\thello\\0\\0\\0\ndiff --git a/tests/queries/0_stateless/01101_literal_column_clash.sql b/tests/queries/0_stateless/01101_literal_column_clash.sql\nnew file mode 100644\nindex 000000000000..2c665d3833b1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01101_literal_column_clash.sql\n@@ -0,0 +1,23 @@\n+-- https://github.com/ClickHouse/ClickHouse/issues/9810\n+select cast(1 as String)\n+from (select 1 as iid) as t1\n+join (select '1' as sid) as t2 on t2.sid = cast(t1.iid as String);\n+\n+-- even simpler cases\n+select cast(7 as String), * from (select 3 \"'String'\");\n+select cast(7 as String), * from (select number \"'String'\" FROM numbers(2));\n+SELECT concat('xyz', 'abc'), * FROM (SELECT 2 AS \"'xyz'\");\n+with 3 as \"1\" select 1, \"1\";\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/9953\n+select 1, * from (select 2 x) a left join (select 1, 3 y) b on y = x;\n+select 1, * from (select 2 x, 1) a right join (select 3 y) b on y = x;\n+select null, isConstant(null), * from (select 2 x) a left join (select null, 3 y) b on y = x;\n+select null, isConstant(null), * from (select 2 x, null) a right join (select 3 y) b on y = x;\n+\n+-- other cases with joins and constants\n+\n+select cast(1, 'UInt8') from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n+\n+select isConstant('UInt8'), toFixedString('hello', toUInt8(substring('UInt8', 5, 1))) from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n+\ndiff --git a/tests/queries/bugs/join_constants_on.sql b/tests/queries/bugs/join_constants_on.sql\ndeleted file mode 100644\nindex ae967e07adbb..000000000000\n--- a/tests/queries/bugs/join_constants_on.sql\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-select cast(1, 'UInt8') from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n-select isConstant('UInt8'), toFixedString('hello', toUInt8(substring('UInt8', 5, 1))) from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n",
  "problem_statement": "Cast bug\nReceived exception: DB::Exception: Second argument to CAST must be a constant string describing type (version 19.17.2.4 (official build))\r\n`select cast(1 as String)`\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on t2.sid = cast(t1.iid as String)`\r\n\r\nOn version 19.4.5.1 this query works fine.\r\n\r\nAlso if I change some parts in this query it will be work without exceptions, for example:\r\n`select cast(1 as Date)` -- or another type except String\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on t2.sid = cast(t1.iid as String)`\r\n\r\n`select cast(1 as String)`\r\n`from (select 1 as iid) as t1`\r\n\r\n`select cast(1 as String)` -- or another type\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on cast(t2.sid as UInt8) = t1.iid`\n",
  "hints_text": "reproduces in master, 20.3\nRelated #7798 \nCan be reproduced even simpler:\r\n\r\n```\r\n:) select cast(2 as String), * from (select 2 \"'String'\")\r\n\r\nReceived exception from server (version 20.4.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Second argument to CAST must be a constant string describing type. Stack trace:\r\n```\r\n\r\nTechnical note:\r\nThis is a general issue where auto-generated column names collide with other names. In the original case, column (1) is a constant column `\"'String'\"` with value `String`, generated as a second parameter for the function `cast(1, 'String')`. Column (2) is identical, but generated for `cast(t1.iid, 'String')`. Column (2) is below the join, so it gets materialized when JOIN expression action is applied. After that, `cast(1, 'String')` tries to use the same column and finds that it is not constant, hence the error.\r\n\r\n\n```\r\nSELECT concat('xyz', 'abc'), * FROM (SELECT 2 AS `'xyz'`)\r\n```",
  "created_at": "2020-03-30T18:02:25Z"
}