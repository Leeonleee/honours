{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52758,
  "instance_id": "ClickHouse__ClickHouse-52758",
  "issue_numbers": [
    "52752"
  ],
  "base_commit": "1365fc91c7b7d2022509e7948dd51f2eb2dfd5cd",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 86a5ce29d9cf..d724c35c3830 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -755,6 +755,9 @@ class FunctionBinaryArithmetic : public IFunction\n     static constexpr bool is_multiply = IsOperation<Op>::multiply;\n     static constexpr bool is_division = IsOperation<Op>::division;\n     static constexpr bool is_bit_hamming_distance = IsOperation<Op>::bit_hamming_distance;\n+    static constexpr bool is_modulo = IsOperation<Op>::modulo;\n+    static constexpr bool is_div_int = IsOperation<Op>::div_int;\n+    static constexpr bool is_div_int_or_zero = IsOperation<Op>::div_int_or_zero;\n \n     ContextPtr context;\n     bool check_decimal_overflow = true;\n@@ -964,13 +967,28 @@ class FunctionBinaryArithmetic : public IFunction\n                                                                   \"argument of numeric type cannot be first\", name);\n \n         std::string function_name;\n-        if (is_multiply)\n+        if constexpr (is_multiply)\n         {\n             function_name = \"tupleMultiplyByNumber\";\n         }\n-        else\n+        else // is_division\n         {\n-            function_name = \"tupleDivideByNumber\";\n+            if constexpr (is_modulo)\n+            {\n+                function_name = \"tupleModuloByNumber\";\n+            }\n+            else if constexpr (is_div_int)\n+            {\n+                function_name = \"tupleIntDivByNumber\";\n+            }\n+            else if constexpr (is_div_int_or_zero)\n+            {\n+                function_name = \"tupleIntDivOrZeroByNumber\";\n+            }\n+            else\n+            {\n+                function_name = \"tupleDivideByNumber\";\n+            }\n         }\n \n         return FunctionFactory::instance().get(function_name, context);\ndiff --git a/src/Functions/IsOperation.h b/src/Functions/IsOperation.h\nindex 0c54901579e5..8ea53c865ced 100644\n--- a/src/Functions/IsOperation.h\n+++ b/src/Functions/IsOperation.h\n@@ -60,7 +60,7 @@ struct IsOperation\n \n     static constexpr bool bit_hamming_distance = IsSameOperation<Op, BitHammingDistanceImpl>::value;\n \n-    static constexpr bool division = div_floating || div_int || div_int_or_zero;\n+    static constexpr bool division = div_floating || div_int || div_int_or_zero || modulo;\n \n     static constexpr bool allow_decimal = plus || minus || multiply || division || least || greatest;\n };\ndiff --git a/src/Functions/vectorFunctions.cpp b/src/Functions/vectorFunctions.cpp\nindex d53d39e2f3be..35ba49e45450 100644\n--- a/src/Functions/vectorFunctions.cpp\n+++ b/src/Functions/vectorFunctions.cpp\n@@ -23,6 +23,9 @@ struct PlusName { static constexpr auto name = \"plus\"; };\n struct MinusName { static constexpr auto name = \"minus\"; };\n struct MultiplyName { static constexpr auto name = \"multiply\"; };\n struct DivideName { static constexpr auto name = \"divide\"; };\n+struct ModuloName { static constexpr auto name = \"modulo\"; };\n+struct IntDivName { static constexpr auto name = \"intDiv\"; };\n+struct IntDivOrZeroName { static constexpr auto name = \"intDivOrZero\"; };\n \n struct L1Label { static constexpr auto name = \"1\"; };\n struct L2Label { static constexpr auto name = \"2\"; };\n@@ -141,6 +144,12 @@ using FunctionTupleMultiply = FunctionTupleOperator<MultiplyName>;\n \n using FunctionTupleDivide = FunctionTupleOperator<DivideName>;\n \n+using FunctionTupleModulo = FunctionTupleOperator<ModuloName>;\n+\n+using FunctionTupleIntDiv = FunctionTupleOperator<IntDivName>;\n+\n+using FunctionTupleIntDivOrZero = FunctionTupleOperator<IntDivOrZeroName>;\n+\n class FunctionTupleNegate : public ITupleFunction\n {\n public:\n@@ -297,6 +306,12 @@ using FunctionTupleMultiplyByNumber = FunctionTupleOperatorByNumber<MultiplyName\n \n using FunctionTupleDivideByNumber = FunctionTupleOperatorByNumber<DivideName>;\n \n+using FunctionTupleModuloByNumber = FunctionTupleOperatorByNumber<ModuloName>;\n+\n+using FunctionTupleIntDivByNumber = FunctionTupleOperatorByNumber<IntDivName>;\n+\n+using FunctionTupleIntDivOrZeroByNumber = FunctionTupleOperatorByNumber<IntDivOrZeroName>;\n+\n class FunctionDotProduct : public ITupleFunction\n {\n public:\n@@ -1563,6 +1578,9 @@ REGISTER_FUNCTION(VectorFunctions)\n     factory.registerAlias(\"vectorDifference\", FunctionTupleMinus::name, FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionTupleMultiply>();\n     factory.registerFunction<FunctionTupleDivide>();\n+    factory.registerFunction<FunctionTupleModulo>();\n+    factory.registerFunction<FunctionTupleIntDiv>();\n+    factory.registerFunction<FunctionTupleIntDivOrZero>();\n     factory.registerFunction<FunctionTupleNegate>();\n \n     factory.registerFunction<FunctionAddTupleOfIntervals>(FunctionDocumentation\n@@ -1626,6 +1644,9 @@ If the types of the first interval (or the interval in the tuple) and the second\n \n     factory.registerFunction<FunctionTupleMultiplyByNumber>();\n     factory.registerFunction<FunctionTupleDivideByNumber>();\n+    factory.registerFunction<FunctionTupleModuloByNumber>();\n+    factory.registerFunction<FunctionTupleIntDivByNumber>();\n+    factory.registerFunction<FunctionTupleIntDivOrZeroByNumber>();\n \n     factory.registerFunction<TupleOrArrayFunctionDotProduct>();\n     factory.registerAlias(\"scalarProduct\", TupleOrArrayFunctionDotProduct::name, FunctionFactory::CaseInsensitive);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 61a2e4e9f02f..b57372ffa8da 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -885,7 +885,13 @@ tupleDivide\n tupleDivideByNumber\n tupleElement\n tupleHammingDistance\n+tupleIntDiv\n+tupleIntDivByNumber\n+tupleIntDivOrZero\n+tupleIntDivOrZeroByNumber\n tupleMinus\n+tupleModulo\n+tupleModuloByNumber\n tupleMultiply\n tupleMultiplyByNumber\n tupleNegate\ndiff --git a/tests/queries/0_stateless/02841_tuple_modulo.reference b/tests/queries/0_stateless/02841_tuple_modulo.reference\nnew file mode 100644\nindex 000000000000..6e6f07d06837\n--- /dev/null\n+++ b/tests/queries/0_stateless/02841_tuple_modulo.reference\n@@ -0,0 +1,4 @@\n+(1,0)\n+(2,2)\n+(2,2)\n+(0,0)\ndiff --git a/tests/queries/0_stateless/02841_tuple_modulo.sql b/tests/queries/0_stateless/02841_tuple_modulo.sql\nnew file mode 100644\nindex 000000000000..56bacf879676\n--- /dev/null\n+++ b/tests/queries/0_stateless/02841_tuple_modulo.sql\n@@ -0,0 +1,4 @@\n+SELECT (5,4) % 2;\n+SELECT intDiv((5,4), 2);\n+SELECT intDivOrZero((5,4), 2);\n+SELECT intDivOrZero((5,4), 0);\n",
  "problem_statement": "Modulo doesn't work for Tuple and intDiv works incorrectly.\n**Describe what's wrong**\r\n\r\nModulo doesn't work for Tuple and intDiv works incorrectly.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nyes\r\n\r\n**How to reproduce**\r\n```\r\nip-172-31-42-195.us-east-2.compute.internal :) select (3, 2) % 2\r\n\r\nSELECT (3, 2) % 2\r\n\r\nQuery id: a01d6231-9e24-49e8-8525-88671e602aff\r\n\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\nReceived exception:\r\nCode: 43. DB::Exception: Illegal types Tuple(UInt8, UInt8) and UInt8 of arguments of function modulo: While processing (3, 2) % 2. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\nip-172-31-42-195.us-east-2.compute.internal :) select intDiv((3, 2), 2)\r\n\r\nSELECT intDiv((3, 2), 2)\r\n\r\nQuery id: 2a59cc45-c13a-480c-a84d-d120ec52a2a7\r\n\r\n\u250c\u2500intDiv((3, 2), 2)\u2500\u2510\r\n\u2502 (1.5,1)           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.007 sec.\r\n```\r\n**Expected behavior**\r\n\r\n`(3, 2) % 2` expected to produce `(1,0)`\r\n`intDiv((3, 2), 2)` expected to produce `(1,1)`\r\n\r\n\r\nThis issue is follow up #51642\r\natt @antaljanosbenjamin \n",
  "hints_text": "We don't automatically map operators or functions to tuples, this is normal.\nI see we have `*` and `/`, so adding `%` and `intDiv` will be nice to do.",
  "created_at": "2023-07-29T02:07:57Z",
  "modified_files": [
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/IsOperation.h",
    "src/Functions/vectorFunctions.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "b/tests/queries/0_stateless/02841_tuple_modulo.reference",
    "b/tests/queries/0_stateless/02841_tuple_modulo.sql"
  ]
}