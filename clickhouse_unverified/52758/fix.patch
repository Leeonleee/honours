diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index 86a5ce29d9cf..d724c35c3830 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -755,6 +755,9 @@ class FunctionBinaryArithmetic : public IFunction
     static constexpr bool is_multiply = IsOperation<Op>::multiply;
     static constexpr bool is_division = IsOperation<Op>::division;
     static constexpr bool is_bit_hamming_distance = IsOperation<Op>::bit_hamming_distance;
+    static constexpr bool is_modulo = IsOperation<Op>::modulo;
+    static constexpr bool is_div_int = IsOperation<Op>::div_int;
+    static constexpr bool is_div_int_or_zero = IsOperation<Op>::div_int_or_zero;
 
     ContextPtr context;
     bool check_decimal_overflow = true;
@@ -964,13 +967,28 @@ class FunctionBinaryArithmetic : public IFunction
                                                                   "argument of numeric type cannot be first", name);
 
         std::string function_name;
-        if (is_multiply)
+        if constexpr (is_multiply)
         {
             function_name = "tupleMultiplyByNumber";
         }
-        else
+        else // is_division
         {
-            function_name = "tupleDivideByNumber";
+            if constexpr (is_modulo)
+            {
+                function_name = "tupleModuloByNumber";
+            }
+            else if constexpr (is_div_int)
+            {
+                function_name = "tupleIntDivByNumber";
+            }
+            else if constexpr (is_div_int_or_zero)
+            {
+                function_name = "tupleIntDivOrZeroByNumber";
+            }
+            else
+            {
+                function_name = "tupleDivideByNumber";
+            }
         }
 
         return FunctionFactory::instance().get(function_name, context);
diff --git a/src/Functions/IsOperation.h b/src/Functions/IsOperation.h
index 0c54901579e5..8ea53c865ced 100644
--- a/src/Functions/IsOperation.h
+++ b/src/Functions/IsOperation.h
@@ -60,7 +60,7 @@ struct IsOperation
 
     static constexpr bool bit_hamming_distance = IsSameOperation<Op, BitHammingDistanceImpl>::value;
 
-    static constexpr bool division = div_floating || div_int || div_int_or_zero;
+    static constexpr bool division = div_floating || div_int || div_int_or_zero || modulo;
 
     static constexpr bool allow_decimal = plus || minus || multiply || division || least || greatest;
 };
diff --git a/src/Functions/vectorFunctions.cpp b/src/Functions/vectorFunctions.cpp
index d53d39e2f3be..35ba49e45450 100644
--- a/src/Functions/vectorFunctions.cpp
+++ b/src/Functions/vectorFunctions.cpp
@@ -23,6 +23,9 @@ struct PlusName { static constexpr auto name = "plus"; };
 struct MinusName { static constexpr auto name = "minus"; };
 struct MultiplyName { static constexpr auto name = "multiply"; };
 struct DivideName { static constexpr auto name = "divide"; };
+struct ModuloName { static constexpr auto name = "modulo"; };
+struct IntDivName { static constexpr auto name = "intDiv"; };
+struct IntDivOrZeroName { static constexpr auto name = "intDivOrZero"; };
 
 struct L1Label { static constexpr auto name = "1"; };
 struct L2Label { static constexpr auto name = "2"; };
@@ -141,6 +144,12 @@ using FunctionTupleMultiply = FunctionTupleOperator<MultiplyName>;
 
 using FunctionTupleDivide = FunctionTupleOperator<DivideName>;
 
+using FunctionTupleModulo = FunctionTupleOperator<ModuloName>;
+
+using FunctionTupleIntDiv = FunctionTupleOperator<IntDivName>;
+
+using FunctionTupleIntDivOrZero = FunctionTupleOperator<IntDivOrZeroName>;
+
 class FunctionTupleNegate : public ITupleFunction
 {
 public:
@@ -297,6 +306,12 @@ using FunctionTupleMultiplyByNumber = FunctionTupleOperatorByNumber<MultiplyName
 
 using FunctionTupleDivideByNumber = FunctionTupleOperatorByNumber<DivideName>;
 
+using FunctionTupleModuloByNumber = FunctionTupleOperatorByNumber<ModuloName>;
+
+using FunctionTupleIntDivByNumber = FunctionTupleOperatorByNumber<IntDivName>;
+
+using FunctionTupleIntDivOrZeroByNumber = FunctionTupleOperatorByNumber<IntDivOrZeroName>;
+
 class FunctionDotProduct : public ITupleFunction
 {
 public:
@@ -1563,6 +1578,9 @@ REGISTER_FUNCTION(VectorFunctions)
     factory.registerAlias("vectorDifference", FunctionTupleMinus::name, FunctionFactory::CaseInsensitive);
     factory.registerFunction<FunctionTupleMultiply>();
     factory.registerFunction<FunctionTupleDivide>();
+    factory.registerFunction<FunctionTupleModulo>();
+    factory.registerFunction<FunctionTupleIntDiv>();
+    factory.registerFunction<FunctionTupleIntDivOrZero>();
     factory.registerFunction<FunctionTupleNegate>();
 
     factory.registerFunction<FunctionAddTupleOfIntervals>(FunctionDocumentation
@@ -1626,6 +1644,9 @@ If the types of the first interval (or the interval in the tuple) and the second
 
     factory.registerFunction<FunctionTupleMultiplyByNumber>();
     factory.registerFunction<FunctionTupleDivideByNumber>();
+    factory.registerFunction<FunctionTupleModuloByNumber>();
+    factory.registerFunction<FunctionTupleIntDivByNumber>();
+    factory.registerFunction<FunctionTupleIntDivOrZeroByNumber>();
 
     factory.registerFunction<TupleOrArrayFunctionDotProduct>();
     factory.registerAlias("scalarProduct", TupleOrArrayFunctionDotProduct::name, FunctionFactory::CaseInsensitive);
