diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h
index abdc3a4bd1e6..30752113a6bf 100644
--- a/dbms/src/Core/Settings.h
+++ b/dbms/src/Core/Settings.h
@@ -176,8 +176,9 @@ struct Settings : public SettingsCollection<Settings>
     M(SettingBool, input_format_skip_unknown_fields, false, "Skip columns with unknown names from input data (it works for JSONEachRow, CSVWithNames, TSVWithNames and TSKV formats).") \
     M(SettingBool, input_format_with_names_use_header, false, "For TSVWithNames and CSVWithNames input formats this controls whether format parser is to assume that column data appear in the input exactly as they are specified in the header.") \
     M(SettingBool, input_format_import_nested_json, false, "Map nested JSON data to nested tables (it works for JSONEachRow format).") \
-    M(SettingBool, input_format_defaults_for_omitted_fields, true, "For input data calculate default expressions for omitted fields (it works for JSONEachRow format).") \
-    M(SettingBool, input_format_null_as_default, false, "For CSV format initialize null fields with default values if data type of this field is not nullable") \
+    M(SettingBool, input_format_defaults_for_omitted_fields, true, "For input data calculate default expressions for omitted fields (it works for JSONEachRow, CSV and TSV formats).") \
+    M(SettingBool, input_format_tsv_empty_as_default, false, "Treat empty fields in TSV input as default values.") \
+    M(SettingBool, input_format_null_as_default, false, "For text input formats initialize null fields with default values if data type of this field is not nullable") \
     \
     M(SettingBool, input_format_values_interpret_expressions, true, "For Values format: if field could not be parsed by streaming parser, run SQL parser and try to interpret it as SQL expression.") \
     M(SettingBool, input_format_values_deduce_templates_of_expressions, false, "For Values format: if field could not be parsed by streaming parser, run SQL parser, deduce template of the SQL expression, try to parse all rows using template and then interpret expression for all rows.") \
@@ -202,8 +203,8 @@ struct Settings : public SettingsCollection<Settings>
     \
     M(SettingBool, fsync_metadata, 1, "Do fsync after changing metadata for tables and databases (.sql files). Could be disabled in case of poor latency on server with high load of DDL queries and high load of disk subsystem.") \
     \
-    M(SettingUInt64, input_format_allow_errors_num, 0, "Maximum absolute amount of errors while reading text formats (like CSV, TSV). In case of error, if both absolute and relative values are non-zero, and at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.") \
-    M(SettingFloat, input_format_allow_errors_ratio, 0, "Maximum relative amount of errors while reading text formats (like CSV, TSV). In case of error, if both absolute and relative values are non-zero, and at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.") \
+    M(SettingUInt64, input_format_allow_errors_num, 0, "Maximum absolute amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.") \
+    M(SettingFloat, input_format_allow_errors_ratio, 0, "Maximum relative amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.") \
     \
     M(SettingBool, join_use_nulls, 0, "Use NULLs for non-joined rows of outer JOINs for types that can be inside Nullable. If false, use default value of corresponding columns data type.") \
     \
diff --git a/dbms/src/DataTypes/DataTypeNullable.cpp b/dbms/src/DataTypes/DataTypeNullable.cpp
index 0eb82d6abdbb..fa6eb0d6d715 100644
--- a/dbms/src/DataTypes/DataTypeNullable.cpp
+++ b/dbms/src/DataTypes/DataTypeNullable.cpp
@@ -156,11 +156,11 @@ void DataTypeNullable::serializeBinary(const IColumn & column, size_t row_num, W
         nested_data_type->serializeBinary(col.getNestedColumn(), row_num, ostr);
 }
 
-
+/// Deserialize value into ColumnNullable.
 /// We need to insert both to nested column and to null byte map, or, in case of exception, to not insert at all.
-template <typename CheckForNull, typename DeserializeNested>
-static void safeDeserialize(
-    IColumn & column,
+template <typename ReturnType = void, typename CheckForNull, typename DeserializeNested, typename std::enable_if_t<std::is_same_v<ReturnType, void>, ReturnType>* = nullptr>
+static ReturnType safeDeserialize(
+    IColumn & column, const IDataType & /*nested_data_type*/,
     CheckForNull && check_for_null, DeserializeNested && deserialize_nested)
 {
     ColumnNullable & col = assert_cast<ColumnNullable &>(column);
@@ -185,10 +185,26 @@ static void safeDeserialize(
     }
 }
 
+/// Deserialize value into non-nullable column. In case of NULL, insert default value and return false.
+template <typename ReturnType = void, typename CheckForNull, typename DeserializeNested, typename std::enable_if_t<std::is_same_v<ReturnType, bool>, ReturnType>* = nullptr>
+static ReturnType safeDeserialize(
+        IColumn & column, const IDataType & nested_data_type,
+        CheckForNull && check_for_null, DeserializeNested && deserialize_nested)
+{
+    assert(!dynamic_cast<ColumnNullable *>(&column));
+    assert(!dynamic_cast<const DataTypeNullable *>(&nested_data_type));
+    bool insert_default = check_for_null();
+    if (insert_default)
+        nested_data_type.insertDefaultInto(column);
+    else
+        deserialize_nested(column);
+    return !insert_default;
+}
+
 
 void DataTypeNullable::deserializeBinary(IColumn & column, ReadBuffer & istr) const
 {
-    safeDeserialize(column,
+    safeDeserialize(column, *nested_data_type,
         [&istr] { bool is_null = 0; readBinary(is_null, istr); return is_null; },
         [this, &istr] (IColumn & nested) { nested_data_type->deserializeBinary(nested, istr); });
 }
@@ -206,6 +222,13 @@ void DataTypeNullable::serializeTextEscaped(const IColumn & column, size_t row_n
 
 
 void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
+{
+    deserializeTextEscaped<void>(column, istr, settings, nested_data_type);
+}
+
+template<typename ReturnType>
+ReturnType DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,
+                                                    const DataTypePtr & nested_data_type)
 {
     /// Little tricky, because we cannot discriminate null from first character.
 
@@ -215,9 +238,9 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist
     /// This is not null, surely.
     if (*istr.position() != '\\')
     {
-        safeDeserialize(column,
+        return safeDeserialize<ReturnType>(column, *nested_data_type,
             [] { return false; },
-            [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextEscaped(nested, istr, settings); });
+            [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextEscaped(nested, istr, settings); });
     }
     else
     {
@@ -227,7 +250,7 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist
         if (istr.eof())
             throw Exception("Unexpected end of stream, while parsing value of Nullable type, after backslash", ErrorCodes::CANNOT_READ_ALL_DATA);
 
-        safeDeserialize(column,
+        return safeDeserialize<ReturnType>(column, *nested_data_type,
             [&istr]
             {
                 if (*istr.position() == 'N')
@@ -237,7 +260,7 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist
                 }
                 return false;
             },
-            [this, &istr, &settings] (IColumn & nested)
+            [&nested_data_type, &istr, &settings] (IColumn & nested)
             {
                 if (istr.position() != istr.buffer().begin())
                 {
@@ -275,15 +298,22 @@ void DataTypeNullable::serializeTextQuoted(const IColumn & column, size_t row_nu
 
 void DataTypeNullable::deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
 {
-    safeDeserialize(column,
+    deserializeTextQuoted<void>(column, istr, settings, nested_data_type);
+}
+
+template<typename ReturnType>
+ReturnType DataTypeNullable::deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,
+                                                   const DataTypePtr & nested_data_type)
+{
+    return safeDeserialize<ReturnType>(column, *nested_data_type,
         [&istr] { return checkStringByFirstCharacterAndAssertTheRestCaseInsensitive("NULL", istr); },
-        [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextQuoted(nested, istr, settings); });
+        [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextQuoted(nested, istr, settings); });
 }
 
 
 void DataTypeNullable::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
 {
-    safeDeserialize(column,
+    safeDeserialize(column, *nested_data_type,
         [&istr] { return checkStringByFirstCharacterAndAssertTheRestCaseInsensitive("NULL", istr); },
         [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsWholeText(nested, istr, settings); });
 }
@@ -300,6 +330,13 @@ void DataTypeNullable::serializeTextCSV(const IColumn & column, size_t row_num,
 }
 
 void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
+{
+    deserializeTextCSV<void>(column, istr, settings, nested_data_type);
+}
+
+template<typename ReturnType>
+ReturnType DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,
+                                                    const DataTypePtr & nested_data_type)
 {
     constexpr char const * null_literal = "NULL";
     constexpr size_t len = 4;
@@ -331,7 +368,7 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c
         return false;
     };
 
-    auto deserialize_nested = [this, &settings, &istr, &null_prefix_len] (IColumn & nested)
+    auto deserialize_nested = [&nested_data_type, &settings, &istr, &null_prefix_len] (IColumn & nested)
     {
         if (likely(!null_prefix_len))
             nested_data_type->deserializeAsTextCSV(nested, istr, settings);
@@ -357,8 +394,8 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c
                 WriteBufferFromOwnString parsed_value;
                 nested_data_type->serializeAsTextCSV(nested, nested.size() - 1, parsed_value, settings);
                 throw DB::Exception("Error while parsing \"" + std::string(null_literal, null_prefix_len)
-                                    + std::string(istr.position(), std::min(size_t{10}, istr.available())) + "\" as " + getName()
-                                    + " at position " + std::to_string(istr.count()) + ": expected \"NULL\" or " + nested_data_type->getName()
+                                    + std::string(istr.position(), std::min(size_t{10}, istr.available())) + "\" as Nullable(" + nested_data_type->getName()
+                                    + ") at position " + std::to_string(istr.count()) + ": expected \"NULL\" or " + nested_data_type->getName()
                                     + ", got \"" + std::string(null_literal, buf.count()) + "\", which was deserialized as \""
                                     + parsed_value.str() + "\". It seems that input data is ill-formatted.",
                                     ErrorCodes::CANNOT_READ_ALL_DATA);
@@ -366,7 +403,7 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c
         }
     };
 
-    safeDeserialize(column, check_for_null, deserialize_nested);
+    return safeDeserialize<ReturnType>(column, *nested_data_type, check_for_null, deserialize_nested);
 }
 
 void DataTypeNullable::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
@@ -397,9 +434,16 @@ void DataTypeNullable::serializeTextJSON(const IColumn & column, size_t row_num,
 
 void DataTypeNullable::deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
 {
-    safeDeserialize(column,
+    deserializeTextJSON<void>(column, istr, settings, nested_data_type);
+}
+
+template<typename ReturnType>
+ReturnType DataTypeNullable::deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,
+                                                    const DataTypePtr & nested_data_type)
+{
+    return safeDeserialize<ReturnType>(column, *nested_data_type,
         [&istr] { return checkStringByFirstCharacterAndAssertTheRest("null", istr); },
-        [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextJSON(nested, istr, settings); });
+        [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextJSON(nested, istr, settings); });
 }
 
 void DataTypeNullable::serializeTextXML(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
@@ -492,4 +536,10 @@ DataTypePtr removeNullable(const DataTypePtr & type)
     return type;
 }
 
+
+template bool DataTypeNullable::deserializeTextEscaped<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);
+template bool DataTypeNullable::deserializeTextQuoted<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);
+template bool DataTypeNullable::deserializeTextCSV<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);
+template bool DataTypeNullable::deserializeTextJSON<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);
+
 }
diff --git a/dbms/src/DataTypes/DataTypeNullable.h b/dbms/src/DataTypes/DataTypeNullable.h
index 49b14eefc6c1..1766b399c2a8 100644
--- a/dbms/src/DataTypes/DataTypeNullable.h
+++ b/dbms/src/DataTypes/DataTypeNullable.h
@@ -100,6 +100,17 @@ class DataTypeNullable final : public IDataType
 
     const DataTypePtr & getNestedType() const { return nested_data_type; }
 
+    /// If ReturnType is bool, check for NULL and deserialize value into non-nullable column (and return true) or insert default value of nested type (and return false)
+    /// If ReturnType is void, deserialize Nullable(T)
+    template <typename ReturnType = bool>
+    static ReturnType deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);
+    template <typename ReturnType = bool>
+    static ReturnType deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);
+    template <typename ReturnType = bool>
+    static ReturnType deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);
+    template <typename ReturnType = bool>
+    static ReturnType deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);
+
 private:
     DataTypePtr nested_data_type;
 };
diff --git a/dbms/src/Formats/FormatFactory.cpp b/dbms/src/Formats/FormatFactory.cpp
index 1fc7da240b20..eddd5aa92cda 100644
--- a/dbms/src/Formats/FormatFactory.cpp
+++ b/dbms/src/Formats/FormatFactory.cpp
@@ -40,7 +40,7 @@ static FormatSettings getInputFormatSetting(const Settings & settings)
     format_settings.csv.allow_double_quotes = settings.format_csv_allow_double_quotes;
     format_settings.csv.unquoted_null_literal_as_null = settings.input_format_csv_unquoted_null_literal_as_null;
     format_settings.csv.empty_as_default = settings.input_format_defaults_for_omitted_fields;
-    format_settings.csv.null_as_default = settings.input_format_null_as_default;
+    format_settings.null_as_default = settings.input_format_null_as_default;
     format_settings.values.interpret_expressions = settings.input_format_values_interpret_expressions;
     format_settings.values.deduce_templates_of_expressions = settings.input_format_values_deduce_templates_of_expressions;
     format_settings.values.accurate_types_of_literals = settings.input_format_values_accurate_types_of_literals;
@@ -53,6 +53,7 @@ static FormatSettings getInputFormatSetting(const Settings & settings)
     format_settings.template_settings.resultset_format = settings.format_template_resultset;
     format_settings.template_settings.row_format = settings.format_template_row;
     format_settings.template_settings.row_between_delimiter = settings.format_template_rows_between_delimiter;
+    format_settings.tsv.empty_as_default = settings.input_format_tsv_empty_as_default;
 
     return format_settings;
 }
diff --git a/dbms/src/Formats/FormatSettings.h b/dbms/src/Formats/FormatSettings.h
index f8018dec1250..dfd5d5b86f62 100644
--- a/dbms/src/Formats/FormatSettings.h
+++ b/dbms/src/Formats/FormatSettings.h
@@ -29,7 +29,6 @@ struct FormatSettings
         bool allow_double_quotes = true;
         bool unquoted_null_literal_as_null = false;
         bool empty_as_default = false;
-        bool null_as_default = false;
     };
 
     CSV csv;
@@ -61,10 +60,18 @@ struct FormatSettings
 
     Template template_settings;
 
+    struct TSV
+    {
+        bool empty_as_default = false;
+    };
+
+    TSV tsv;
+
     bool skip_unknown_fields = false;
     bool with_names_use_header = false;
     bool write_statistics = true;
     bool import_nested_json = false;
+    bool null_as_default = false;
 
     enum class DateTimeInputFormat
     {
diff --git a/dbms/src/Interpreters/evaluateConstantExpression.cpp b/dbms/src/Interpreters/evaluateConstantExpression.cpp
index f7843f682b72..2e46ff294cc3 100644
--- a/dbms/src/Interpreters/evaluateConstantExpression.cpp
+++ b/dbms/src/Interpreters/evaluateConstantExpression.cpp
@@ -15,6 +15,7 @@
 #include <Parsers/ExpressionElementParsers.h>
 #include <TableFunctions/TableFunctionFactory.h>
 #include <Common/typeid_cast.h>
+#include <Interpreters/ReplaceQueryParameterVisitor.h>
 
 
 namespace DB
@@ -31,6 +32,9 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co
 {
     NamesAndTypesList source_columns = {{ "_dummy", std::make_shared<DataTypeUInt8>() }};
     auto ast = node->clone();
+    ReplaceQueryParameterVisitor param_visitor(context.getQueryParameters());
+    param_visitor.visit(ast);
+    String name = ast->getColumnName();
     auto syntax_result = SyntaxAnalyzer(context).analyze(ast, source_columns);
     ExpressionActionsPtr expr_for_constant_folding = ExpressionAnalyzer(ast, syntax_result, context).getConstActions();
 
@@ -42,8 +46,6 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co
     if (!block_with_constants || block_with_constants.rows() == 0)
         throw Exception("Logical error: empty block after evaluation of constant expression for IN, VALUES or LIMIT", ErrorCodes::LOGICAL_ERROR);
 
-    String name = node->getColumnName();
-
     if (!block_with_constants.has(name))
         throw Exception("Element of set in IN, VALUES or LIMIT is not a constant expression (result column not found): " + name, ErrorCodes::BAD_ARGUMENTS);
 
diff --git a/dbms/src/Processors/Formats/IRowInputFormat.cpp b/dbms/src/Processors/Formats/IRowInputFormat.cpp
index 5aec8e94cf12..39422bf20b52 100644
--- a/dbms/src/Processors/Formats/IRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/IRowInputFormat.cpp
@@ -46,6 +46,7 @@ Chunk IRowInputFormat::generate()
     size_t prev_rows = total_rows;
 
     ///auto chunk_missing_values = std::make_unique<ChunkMissingValues>();
+    block_missing_values.clear();
 
     try
     {
diff --git a/dbms/src/Processors/Formats/IRowInputFormat.h b/dbms/src/Processors/Formats/IRowInputFormat.h
index 9443d2b633bc..38dcb6acc9e9 100644
--- a/dbms/src/Processors/Formats/IRowInputFormat.h
+++ b/dbms/src/Processors/Formats/IRowInputFormat.h
@@ -77,7 +77,6 @@ class IRowInputFormat : public IInputFormat
 
 private:
     Params params;
-    Stopwatch total_stopwatch {CLOCK_MONOTONIC_COARSE};
 
     size_t total_rows = 0;
     size_t num_errors = 0;
diff --git a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp
index b5ee30fb7f8c..a13bb3651920 100644
--- a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp
@@ -24,12 +24,17 @@ CSVRowInputFormat::CSVRowInputFormat(const Block & header_, ReadBuffer & in_, co
     , with_names(with_names_)
     , format_settings(format_settings_)
 {
+
+    const String bad_delimiters = " \t\"'.UL";
+    if (bad_delimiters.find(format_settings.csv.delimiter) != String::npos)
+        throw Exception(String("CSV format may not work correctly with delimiter '") + format_settings.csv.delimiter +
+                        "'. Try use CustomSeparated format instead.", ErrorCodes::BAD_ARGUMENTS);
+
     auto & sample = getPort().getHeader();
     size_t num_columns = sample.columns();
 
     data_types.resize(num_columns);
     column_indexes_by_names.reserve(num_columns);
-    column_idx_to_nullable_column_idx.resize(num_columns);
 
     for (size_t i = 0; i < num_columns; ++i)
     {
@@ -37,16 +42,6 @@ CSVRowInputFormat::CSVRowInputFormat(const Block & header_, ReadBuffer & in_, co
 
         data_types[i] = column_info.type;
         column_indexes_by_names.emplace(column_info.name, i);
-
-        /// If input_format_null_as_default=1 we need ColumnNullable of type DataTypeNullable(nested_type)
-        /// to parse value as nullable before inserting it in corresponding column of not-nullable type.
-        /// Constructing temporary column for each row is slow, so we prepare it here
-        if (format_settings_.csv.null_as_default && !column_info.type->isNullable() && column_info.type->canBeInsideNullable())
-        {
-            column_idx_to_nullable_column_idx[i] = nullable_columns.size();
-            nullable_types.emplace_back(std::make_shared<DataTypeNullable>(column_info.type));
-            nullable_columns.emplace_back(nullable_types.back()->createColumn());
-        }
     }
 }
 
@@ -220,6 +215,7 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext
     /// it doesn't have to check it.
     bool have_default_columns = have_always_default_columns;
 
+    ext.read_columns.assign(read_columns.size(), true);
     const auto delimiter = format_settings.csv.delimiter;
     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)
     {
@@ -229,9 +225,8 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext
         if (table_column)
         {
             skipWhitespacesAndTabs(in);
-            read_columns[*table_column] = readField(*columns[*table_column], data_types[*table_column],
-                                                    is_last_file_column, *table_column);
-            if (!read_columns[*table_column])
+            ext.read_columns[*table_column] = readField(*columns[*table_column], data_types[*table_column], is_last_file_column);
+            if (!ext.read_columns[*table_column])
                 have_default_columns = true;
             skipWhitespacesAndTabs(in);
         }
@@ -258,9 +253,9 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext
                 /// value, we do not have to use the default value specified by
                 /// the data type, and can just use IColumn::insertDefault().
                 columns[i]->insertDefault();
+                ext.read_columns[i] = false;
             }
         }
-        ext.read_columns = read_columns;
     }
 
     return true;
@@ -365,8 +360,7 @@ void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn &
     if (column_indexes_for_input_fields[file_column])
     {
         const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();
-        if (!readField(column, type, is_last_file_column, *column_indexes_for_input_fields[file_column]))
-            column.insertDefault();
+        readField(column, type, is_last_file_column);
     }
     else
     {
@@ -378,12 +372,14 @@ void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn &
     skipWhitespacesAndTabs(in);
 }
 
-bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column, size_t column_idx)
+bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column)
 {
     const bool at_delimiter = !in.eof() && *in.position() == format_settings.csv.delimiter;
     const bool at_last_column_line_end = is_last_file_column
                                          && (in.eof() || *in.position() == '
' || *in.position() == '\r');
 
+    /// Note: Tuples are serialized in CSV as separate columns, but with empty_as_default or null_as_default
+    /// only one empty or NULL column will be expected
     if (format_settings.csv.empty_as_default
         && (at_delimiter || at_last_column_line_end))
     {
@@ -393,20 +389,13 @@ bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bo
         /// commas, which might be also used as delimiters. However,
         /// they do not contain empty unquoted fields, so this check
         /// works for tuples as well.
+        column.insertDefault();
         return false;
     }
-    else if (column_idx_to_nullable_column_idx[column_idx])
+    else if (format_settings.null_as_default && !type->isNullable())
     {
         /// If value is null but type is not nullable then use default value instead.
-        const size_t nullable_idx = *column_idx_to_nullable_column_idx[column_idx];
-        auto & tmp_col = *nullable_columns[nullable_idx];
-        nullable_types[nullable_idx]->deserializeAsTextCSV(tmp_col, in, format_settings);
-        Field value = tmp_col[0];
-        tmp_col.popBack(1);     /// do not store copy of values in memory
-        if (value.isNull())
-            return false;
-        column.insert(value);
-        return true;
+        return DataTypeNullable::deserializeTextCSV(column, in, format_settings, type);
     }
     else
     {
diff --git a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h
index b8a3a956e1ed..cebc8f6d6a16 100644
--- a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h
@@ -61,12 +61,7 @@ class CSVRowInputFormat : public RowInputFormatWithDiagnosticInfo
         return *pos != '
' && *pos != '\r' && *pos != format_settings.csv.delimiter;
     }
 
-    /// For setting input_format_null_as_default
-    DataTypes nullable_types;
-    MutableColumns nullable_columns;
-    OptionalIndexes column_idx_to_nullable_column_idx;
-
-    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column, size_t column_idx);
+    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column);
 };
 
 }
diff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
index c6c88b8505f8..8c834c44932c 100644
--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
@@ -151,7 +151,7 @@ class ReplaceLiteralsVisitor
         {
             info.special_parser.is_array = true;
             info.type = applyVisitor(FieldToDataType(), info.literal->value);
-            auto nested_type = dynamic_cast<const DataTypeArray &>(*info.type).getNestedType();
+            auto nested_type = assert_cast<const DataTypeArray &>(*info.type).getNestedType();
 
             /// It can be Array(Nullable(nested_type))
             bool array_of_nullable = false;
@@ -212,9 +212,9 @@ class ReplaceLiteralsVisitor
 /// E.g. template of "position('some string', 'other string') != 0" is
 /// ["position", "(", DataTypeString, ",", DataTypeString, ")", "!=", DataTypeUInt64]
 ConstantExpressionTemplate::TemplateStructure::TemplateStructure(LiteralsInfo & replaced_literals, TokenIterator expression_begin, TokenIterator expression_end,
-                                                                 ASTPtr & expression, const IDataType & result_type, const Context & context)
+                                                                 ASTPtr & expression, const IDataType & result_type, bool null_as_default_, const Context & context)
 {
-
+    null_as_default = null_as_default_;
 
     std::sort(replaced_literals.begin(), replaced_literals.end(), [](const LiteralInfo & a, const LiteralInfo & b)
     {
@@ -252,16 +252,17 @@ ConstantExpressionTemplate::TemplateStructure::TemplateStructure(LiteralsInfo &
         ++prev_end;
     }
 
-    addNodesToCastResult(result_type, expression);
-    result_column_name = expression->getColumnName();
+    addNodesToCastResult(result_type, expression, null_as_default);
 
     auto syntax_result = SyntaxAnalyzer(context).analyze(expression, literals.getNamesAndTypesList());
+    result_column_name = expression->getColumnName();
     actions_on_literals = ExpressionAnalyzer(expression, syntax_result, context).getActions(false);
 }
 
 size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTPtr & expression,
                                                                       const LiteralsInfo & replaced_literals,
                                                                       const DataTypePtr & result_column_type,
+                                                                      bool null_as_default,
                                                                       const String & salt)
 {
     /// TODO distinguish expressions with the same AST and different tokens (e.g. "CAST(expr, 'Type')" and "CAST(expr AS Type)")
@@ -272,6 +273,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP
 
     for (const auto & info : replaced_literals)
         hash_state.update(info.type->getName());
+    hash_state.update(null_as_default);
 
     /// Allows distinguish expression in the last column in Values format
     hash_state.update(salt);
@@ -288,6 +290,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP
 
 ConstantExpressionTemplate::TemplateStructurePtr
 ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & result_column_type,
+                                                           bool null_as_default,
                                                            TokenIterator expression_begin,
                                                            TokenIterator expression_end,
                                                            const ASTPtr & expression_,
@@ -298,17 +301,18 @@ ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & r
     TemplateStructurePtr res;
     ASTPtr expression = expression_->clone();
     ReplaceLiteralsVisitor visitor(context);
-    visitor.visit(expression, result_column_type->isNullable());
+    visitor.visit(expression, result_column_type->isNullable() || null_as_default);
     ReplaceQueryParameterVisitor param_visitor(context.getQueryParameters());
     param_visitor.visit(expression);
 
-    size_t template_hash = TemplateStructure::getTemplateHash(expression, visitor.replaced_literals, result_column_type, salt);
+    size_t template_hash = TemplateStructure::getTemplateHash(expression, visitor.replaced_literals, result_column_type, null_as_default, salt);
     auto iter = cache.find(template_hash);
     if (iter == cache.end())
     {
         if (max_size <= cache.size())
             cache.clear();
-        res = std::make_shared<TemplateStructure>(visitor.replaced_literals, expression_begin, expression_end, expression, *result_column_type, context);
+        res = std::make_shared<TemplateStructure>(visitor.replaced_literals, expression_begin, expression_end,
+                                                  expression, *result_column_type, null_as_default, context);
         cache.insert({template_hash, res});
         if (found_in_cache)
             *found_in_cache = false;
@@ -416,7 +420,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co
 
         const Field & array = ast->as<ASTLiteral &>().value;
         auto array_type = applyVisitor(FieldToDataType(), array);
-        auto nested_type = dynamic_cast<const DataTypeArray &>(*array_type).getNestedType();
+        auto nested_type = assert_cast<const DataTypeArray &>(*array_type).getNestedType();
         if (type_info.is_nullable)
             if (auto nullable = dynamic_cast<const DataTypeNullable *>(nested_type.get()))
                 nested_type = nullable->getNestedType();
@@ -488,7 +492,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co
     }
 }
 
-ColumnPtr ConstantExpressionTemplate::evaluateAll()
+ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset)
 {
     Block evaluated = structure->literals.cloneWithColumns(std::move(columns));
     columns = structure->literals.cloneEmptyColumns();
@@ -506,23 +510,40 @@ ColumnPtr ConstantExpressionTemplate::evaluateAll()
                         ErrorCodes::LOGICAL_ERROR);
 
     rows_count = 0;
-    return evaluated.getByName(structure->result_column_name).column->convertToFullColumnIfConst();
+    ColumnPtr res = evaluated.getByName(structure->result_column_name).column->convertToFullColumnIfConst();
+    if (!structure->null_as_default)
+        return res;
+
+    /// Extract column with evaluated expression and mask for NULLs
+    auto & tuple = assert_cast<const ColumnTuple &>(*res);
+    if (tuple.tupleSize() != 2)
+        throw Exception("Invalid tuple size, it'a a bug", ErrorCodes::LOGICAL_ERROR);
+    auto & is_null = assert_cast<const ColumnUInt8 &>(tuple.getColumn(1));
+
+    for (size_t i = 0; i < is_null.size(); ++i)
+        if (is_null.getUInt(i))
+            nulls.setBit(column_idx, offset + i);
+
+    return tuple.getColumnPtr(0);
 }
 
-void ConstantExpressionTemplate::TemplateStructure::addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr)
+void ConstantExpressionTemplate::TemplateStructure::addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr, bool null_as_default)
 {
-    auto result_type = std::make_shared<ASTLiteral>(result_column_type.getName());
-
-    auto arguments = std::make_shared<ASTExpressionList>();
-    arguments->children.push_back(std::move(expr));
-    arguments->children.push_back(std::move(result_type));
+    /// Replace "expr" with "CAST(expr, 'TypeName')"
+    /// or with "(CAST(assumeNotNull(expr as _expression), 'TypeName'), isNull(_expression))" if null_as_default is true
+    if (null_as_default)
+    {
+        expr->setAlias("_expression");
+        expr = makeASTFunction("assumeNotNull", std::move(expr));
+    }
 
-    auto cast = std::make_shared<ASTFunction>();
-    cast->name = "CAST";
-    cast->arguments = std::move(arguments);
-    cast->children.push_back(cast->arguments);
+    expr = makeASTFunction("CAST", std::move(expr), std::make_shared<ASTLiteral>(result_column_type.getName()));
 
-    expr = std::move(cast);
+    if (null_as_default)
+    {
+        auto is_null = makeASTFunction("isNull", std::make_shared<ASTIdentifier>("_expression"));
+        expr = makeASTFunction("tuple", std::move(expr), std::move(is_null));
+    }
 }
 
 }
diff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
index 4f4dac849b27..96e1c653c037 100644
--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
@@ -21,10 +21,11 @@ class ConstantExpressionTemplate : boost::noncopyable
     struct TemplateStructure : boost::noncopyable
     {
         TemplateStructure(LiteralsInfo & replaced_literals, TokenIterator expression_begin, TokenIterator expression_end,
-                          ASTPtr & expr, const IDataType & result_type, const Context & context);
+                          ASTPtr & expr, const IDataType & result_type, bool null_as_default_, const Context & context);
 
-        static void addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr);
-        static size_t getTemplateHash(const ASTPtr & expression, const LiteralsInfo & replaced_literals, const DataTypePtr & result_column_type, const String & salt);
+        static void addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr, bool null_as_default);
+        static size_t getTemplateHash(const ASTPtr & expression, const LiteralsInfo & replaced_literals,
+                                      const DataTypePtr & result_column_type, bool null_as_default, const String & salt);
 
         String result_column_name;
 
@@ -35,6 +36,7 @@ class ConstantExpressionTemplate : boost::noncopyable
         ExpressionActionsPtr actions_on_literals;
 
         std::vector<SpecialParserType> special_parser;
+        bool null_as_default;
     };
 
 public:
@@ -50,6 +52,7 @@ class ConstantExpressionTemplate : boost::noncopyable
 
         /// Deduce template of expression of type result_column_type and add it to cache (or use template from cache)
         TemplateStructurePtr getFromCacheOrConstruct(const DataTypePtr & result_column_type,
+                                                     bool null_as_default,
                                                      TokenIterator expression_begin,
                                                      TokenIterator expression_end,
                                                      const ASTPtr & expression_,
@@ -65,8 +68,9 @@ class ConstantExpressionTemplate : boost::noncopyable
     /// and parse literals into temporary columns
     bool parseExpression(ReadBuffer & istr, const FormatSettings & settings);
 
-    /// Evaluate batch of expressions were parsed using template
-    ColumnPtr evaluateAll();
+    /// Evaluate batch of expressions were parsed using template.
+    /// If template was deduced with null_as_default == true, set bits in nulls for NULL values in column_idx, starting from offset.
+    ColumnPtr evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset = 0);
 
     size_t rowsCount() const { return rows_count; }
 
diff --git a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp
index 20830d2eccff..e49f9315887d 100644
--- a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp
@@ -3,6 +3,7 @@
 #include <Processors/Formats/Impl/JSONEachRowRowInputFormat.h>
 #include <Formats/FormatFactory.h>
 #include <DataTypes/NestedUtils.h>
+#include <DataTypes/DataTypeNullable.h>
 
 namespace DB
 {
@@ -129,21 +130,23 @@ void JSONEachRowRowInputFormat::skipUnknownField(const StringRef & name_ref)
 
 void JSONEachRowRowInputFormat::readField(size_t index, MutableColumns & columns)
 {
-    if (read_columns[index])
+    if (seen_columns[index])
         throw Exception("Duplicate field found while parsing JSONEachRow format: " + columnName(index), ErrorCodes::INCORRECT_DATA);
 
     try
     {
-        auto & header = getPort().getHeader();
-        header.getByPosition(index).type->deserializeAsTextJSON(*columns[index], in, format_settings);
+        seen_columns[index] = read_columns[index] = true;
+        const auto & type = getPort().getHeader().getByPosition(index).type;
+        if (format_settings.null_as_default && !type->isNullable())
+            read_columns[index] = DataTypeNullable::deserializeTextJSON(*columns[index], in, format_settings, type);
+        else
+            type->deserializeAsTextJSON(*columns[index], in, format_settings);
     }
     catch (Exception & e)
     {
         e.addMessage("(while read the value of key " + columnName(index) + ")");
         throw;
     }
-
-    read_columns[index] = true;
 }
 
 inline bool JSONEachRowRowInputFormat::advanceToNextKey(size_t key_index)
@@ -230,8 +233,8 @@ bool JSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi
 
     size_t num_columns = columns.size();
 
-    /// Set of columns for which the values were read. The rest will be filled with default values.
     read_columns.assign(num_columns, false);
+    seen_columns.assign(num_columns, false);
 
     nested_prefix_length = 0;
     readJSONObject(columns);
@@ -239,7 +242,7 @@ bool JSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi
     auto & header = getPort().getHeader();
     /// Fill non-visited columns with the default values.
     for (size_t i = 0; i < num_columns; ++i)
-        if (!read_columns[i])
+        if (!seen_columns[i])
             header.getByPosition(i).type->insertDefaultInto(*columns[i]);
 
     /// return info about defaults set
diff --git a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h
index afa3c9f2ba15..3e7a38e593a7 100644
--- a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h
@@ -55,7 +55,12 @@ class JSONEachRowRowInputFormat : public IRowInputFormat
     /// the nested column names are 'n.i' and 'n.s' and the nested prefix is 'n.'
     size_t nested_prefix_length = 0;
 
+    /// Set of columns for which the values were read. The rest will be filled with default values.
     std::vector<UInt8> read_columns;
+    /// Set of columns which already met in row. Exception is thrown if there are more than one column with the same name.
+    std::vector<UInt8> seen_columns;
+    /// These sets may be different, because if null_as_default=1 read_columns[i] will be false and seen_columns[i] will be true
+    /// for row like {..., "non-nullable column name" : null, ...}
 
     /// Hash table match `field name -> position in the block`. NOTE You can use perfect hash map.
     using NameMap = HashMap<StringRef, size_t, StringRefHash>;
diff --git a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp
index 8cf3702d3bf9..60df642836cb 100644
--- a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp
@@ -1,6 +1,7 @@
 #include <IO/ReadHelpers.h>
 #include <Processors/Formats/Impl/TSKVRowInputFormat.h>
 #include <Formats/FormatFactory.h>
+#include <DataTypes/DataTypeNullable.h>
 
 
 namespace DB
@@ -98,6 +99,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex
 
     /// Set of columns for which the values were read. The rest will be filled with default values.
     read_columns.assign(num_columns, false);
+    seen_columns.assign(num_columns, false);
 
     if (unlikely(*in.position() == '
'))
     {
@@ -131,12 +133,15 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex
                 {
                     index = *lookupResultGetMapped(it);
 
-                    if (read_columns[index])
+                    if (seen_columns[index])
                         throw Exception("Duplicate field found while parsing TSKV format: " + name_ref.toString(), ErrorCodes::INCORRECT_DATA);
 
-                    read_columns[index] = true;
-
-                    header.getByPosition(index).type->deserializeAsTextEscaped(*columns[index], in, format_settings);
+                    seen_columns[index] = read_columns[index] = true;
+                    const auto & type = getPort().getHeader().getByPosition(index).type;
+                    if (format_settings.null_as_default && !type->isNullable())
+                        read_columns[index] = DataTypeNullable::deserializeTextEscaped(*columns[index], in, format_settings, type);
+                    else
+                        header.getByPosition(index).type->deserializeAsTextEscaped(*columns[index], in, format_settings);
                 }
             }
             else
@@ -166,7 +171,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex
                 if (index >= 0)
                 {
                     columns[index]->popBack(1);
-                    read_columns[index] = false;
+                    seen_columns[index] = read_columns[index] = false;
                 }
 
                 throw Exception("Found garbage after field in TSKV format: " + name_ref.toString(), ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);
@@ -176,7 +181,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex
 
     /// Fill in the not met columns with default values.
     for (size_t i = 0; i < num_columns; ++i)
-        if (!read_columns[i])
+        if (!seen_columns[i])
             header.getByPosition(i).type->insertDefaultInto(*columns[i]);
 
     /// return info about defaults set
diff --git a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h
index 52330665395a..cd7ad69aed65 100644
--- a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h
@@ -41,7 +41,12 @@ class TSKVRowInputFormat : public IRowInputFormat
     using NameMap = HashMap<StringRef, size_t, StringRefHash>;
     NameMap name_map;
 
+    /// Set of columns for which the values were read. The rest will be filled with default values.
     std::vector<UInt8> read_columns;
+    /// Set of columns which already met in row. Exception is thrown if there are more than one column with the same name.
+    std::vector<UInt8> seen_columns;
+    /// These sets may be different, because if null_as_default=1 read_columns[i] will be false and seen_columns[i] will be true
+    /// for row like ..., non-nullable column name=\N, ...
 };
 
 }
diff --git a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp
index cb9ff5b53bec..b57fc51f1834 100644
--- a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp
@@ -6,6 +6,7 @@
 #include <Formats/verbosePrintString.h>
 #include <Formats/FormatFactory.h>
 #include <DataTypes/DataTypeNothing.h>
+#include <DataTypes/DataTypeNullable.h>
 
 namespace DB
 {
@@ -117,9 +118,10 @@ void TabSeparatedRowInputFormat::fillUnreadColumnsWithDefaults(MutableColumns &
     }
 
     for (const auto column_index : columns_to_fill_with_default_values)
+    {
         data_types[column_index]->insertDefaultInto(*columns[column_index]);
-
-    row_read_extension.read_columns = read_columns;
+        row_read_extension.read_columns[column_index] = false;
+    }
 }
 
 
@@ -174,12 +176,15 @@ bool TabSeparatedRowInputFormat::readRow(MutableColumns & columns, RowReadExtens
 
     updateDiagnosticInfo();
 
+    ext.read_columns.assign(read_columns.size(), true);
     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)
     {
         const auto & column_index = column_indexes_for_input_fields[file_column];
+        const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();
         if (column_index)
         {
-            data_types[*column_index]->deserializeAsTextEscaped(*columns[*column_index], in, format_settings);
+            const auto & type = data_types[*column_index];
+            ext.read_columns[*column_index] = readField(*columns[*column_index], type, is_last_file_column);
         }
         else
         {
@@ -206,6 +211,22 @@ bool TabSeparatedRowInputFormat::readRow(MutableColumns & columns, RowReadExtens
     return true;
 }
 
+
+bool TabSeparatedRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column)
+{
+    const bool at_delimiter = !is_last_file_column && !in.eof() && *in.position() == '\t';
+    const bool at_last_column_line_end = is_last_file_column && (in.eof() || *in.position() == '
');
+    if (format_settings.tsv.empty_as_default && (at_delimiter || at_last_column_line_end))
+    {
+        column.insertDefault();
+        return false;
+    }
+    else if (format_settings.null_as_default && !type->isNullable())
+        return DataTypeNullable::deserializeTextEscaped(column, in, format_settings, type);
+    type->deserializeAsTextEscaped(column, in, format_settings);
+    return true;
+}
+
 bool TabSeparatedRowInputFormat::parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out)
 {
     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)
@@ -303,7 +324,10 @@ void TabSeparatedRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, I
 {
     prev_pos = in.position();
     if (column_indexes_for_input_fields[file_column])
-        type->deserializeAsTextEscaped(column, in, format_settings);
+    {
+        const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();
+        readField(column, type, is_last_file_column);
+    }
     else
     {
         NullSink null_sink;
diff --git a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h
index a28ac62ed4f2..9d3f0b52d119 100644
--- a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h
@@ -41,6 +41,8 @@ class TabSeparatedRowInputFormat : public RowInputFormatWithDiagnosticInfo
     std::vector<UInt8> read_columns;
     std::vector<size_t> columns_to_fill_with_default_values;
 
+    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column);
+
     void addInputColumn(const String & column_name);
     void setupAllColumnsByTableSchema();
     void fillUnreadColumnsWithDefaults(MutableColumns & columns, RowReadExtension& ext);
diff --git a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp
index f0b2238ec7ff..b77ec5417b03 100644
--- a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp
@@ -4,6 +4,7 @@
 #include <IO/Operators.h>
 #include <DataTypes/DataTypeNothing.h>
 #include <Interpreters/Context.h>
+#include <DataTypes/DataTypeNullable.h>
 
 namespace DB
 {
@@ -23,7 +24,8 @@ TemplateRowInputFormat::TemplateRowInputFormat(const Block & header_, ReadBuffer
                                                ParsedTemplateFormatString format_, ParsedTemplateFormatString row_format_)
     : RowInputFormatWithDiagnosticInfo(header_, buf, params_), buf(in_), data_types(header_.getDataTypes()),
       settings(settings_), ignore_spaces(ignore_spaces_),
-      format(std::move(format_)), row_format(std::move(row_format_))
+      format(std::move(format_)), row_format(std::move(row_format_)),
+      default_csv_delimiter(settings.csv.delimiter)
 {
     /// Validate format string for result set
     bool has_data = false;
@@ -68,6 +70,10 @@ TemplateRowInputFormat::TemplateRowInputFormat(const Block & header_, ReadBuffer
             column_in_format[col_idx] = true;
         }
     }
+
+    for (size_t i = 0; i < header_.columns(); ++i)
+        if (!column_in_format[i])
+            always_default_columns.push_back(i);
 }
 
 void TemplateRowInputFormat::readPrefix()
@@ -166,8 +172,7 @@ bool TemplateRowInputFormat::readRow(MutableColumns & columns, RowReadExtension
         if (row_format.format_idx_to_column_idx[i])
         {
             size_t col_idx = *row_format.format_idx_to_column_idx[i];
-            deserializeField(*data_types[col_idx], *columns[col_idx], row_format.formats[i]);
-            extra.read_columns[col_idx] = true;
+            extra.read_columns[col_idx] = deserializeField(data_types[col_idx], *columns[col_idx], i);
         }
         else
             skipField(row_format.formats[i]);
@@ -177,30 +182,47 @@ bool TemplateRowInputFormat::readRow(MutableColumns & columns, RowReadExtension
     skipSpaces();
     assertString(row_format.delimiters.back(), buf);
 
-    for (size_t i = 0; i < columns.size(); ++i)
-        if (!extra.read_columns[i])
-            data_types[i]->insertDefaultInto(*columns[i]);
+    for (const auto & idx : always_default_columns)
+        data_types[idx]->insertDefaultInto(*columns[idx]);
 
     return true;
 }
 
-void TemplateRowInputFormat::deserializeField(const IDataType & type, IColumn & column, ColumnFormat col_format)
+bool TemplateRowInputFormat::deserializeField(const DataTypePtr & type, IColumn & column, size_t file_column)
 {
+    ColumnFormat col_format = row_format.formats[file_column];
+    bool read = true;
+    bool parse_as_nullable = settings.null_as_default && !type->isNullable();
     try
     {
         switch (col_format)
         {
             case ColumnFormat::Escaped:
-                type.deserializeAsTextEscaped(column, buf, settings);
+                if (parse_as_nullable)
+                    read = DataTypeNullable::deserializeTextEscaped(column, buf, settings, type);
+                else
+                    type->deserializeAsTextEscaped(column, buf, settings);
                 break;
             case ColumnFormat::Quoted:
-                type.deserializeAsTextQuoted(column, buf, settings);
+                if (parse_as_nullable)
+                    read = DataTypeNullable::deserializeTextQuoted(column, buf, settings, type);
+                else
+                    type->deserializeAsTextQuoted(column, buf, settings);
                 break;
             case ColumnFormat::Csv:
-                type.deserializeAsTextCSV(column, buf, settings);
+                /// Will read unquoted string until settings.csv.delimiter
+                settings.csv.delimiter = row_format.delimiters[file_column + 1].empty() ? default_csv_delimiter :
+                                                                                          row_format.delimiters[file_column + 1].front();
+                if (parse_as_nullable)
+                    read = DataTypeNullable::deserializeTextCSV(column, buf, settings, type);
+                else
+                    type->deserializeAsTextCSV(column, buf, settings);
                 break;
             case ColumnFormat::Json:
-                type.deserializeAsTextJSON(column, buf, settings);
+                if (parse_as_nullable)
+                    read = DataTypeNullable::deserializeTextJSON(column, buf, settings, type);
+                else
+                    type->deserializeAsTextJSON(column, buf, settings);
                 break;
             default:
                 __builtin_unreachable();
@@ -212,6 +234,7 @@ void TemplateRowInputFormat::deserializeField(const IDataType & type, IColumn &
             throwUnexpectedEof();
         throw;
     }
+    return read;
 }
 
 void TemplateRowInputFormat::skipField(TemplateRowInputFormat::ColumnFormat col_format)
@@ -391,7 +414,7 @@ void TemplateRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColu
 {
     prev_pos = buf.position();
     if (row_format.format_idx_to_column_idx[file_column])
-        deserializeField(*type, column, row_format.formats[file_column]);
+        deserializeField(type, column, file_column);
     else
         skipField(row_format.formats[file_column]);
     curr_pos = buf.position();
diff --git a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h
index 2142d4929881..7b62347c37d8 100644
--- a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h
@@ -29,7 +29,7 @@ class TemplateRowInputFormat : public RowInputFormatWithDiagnosticInfo
     void syncAfterError() override;
 
 private:
-    void deserializeField(const IDataType & type, IColumn & column, ColumnFormat col_format);
+    bool deserializeField(const DataTypePtr & type, IColumn & column, size_t file_column);
     void skipField(ColumnFormat col_format);
     inline void skipSpaces() { if (ignore_spaces) skipWhitespaceIfAny(buf); }
 
@@ -50,13 +50,15 @@ class TemplateRowInputFormat : public RowInputFormatWithDiagnosticInfo
     PeekableReadBuffer buf;
     DataTypes data_types;
 
-    const FormatSettings settings;
+    FormatSettings settings;
     const bool ignore_spaces;
     ParsedTemplateFormatString format;
     ParsedTemplateFormatString row_format;
 
     size_t format_data_idx;
     bool end_of_stream = false;
+    std::vector<size_t> always_default_columns;
+    char default_csv_delimiter;
 };
 
 }
diff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
index 5c5bca9f9628..05bde62d9023 100644
--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
@@ -11,6 +11,7 @@
 #include <Common/typeid_cast.h>
 #include <common/find_symbols.h>
 #include <Parsers/ASTLiteral.h>
+#include <DataTypes/DataTypeNullable.h>
 
 
 namespace DB
@@ -47,6 +48,7 @@ Chunk ValuesBlockInputFormat::generate()
 {
     const Block & header = getPort().getHeader();
     MutableColumns columns = header.cloneEmptyColumns();
+    block_missing_values.clear();
 
     for (size_t rows_in_block = 0; rows_in_block < params.max_block_size; ++rows_in_block)
     {
@@ -55,7 +57,7 @@ Chunk ValuesBlockInputFormat::generate()
             skipWhitespaceIfAny(buf);
             if (buf.eof() || *buf.position() == ';')
                 break;
-            readRow(columns);
+            readRow(columns, rows_in_block);
             if (params.callback)
                 params.callback();
         }
@@ -73,10 +75,10 @@ Chunk ValuesBlockInputFormat::generate()
         if (!templates[i] || !templates[i]->rowsCount())
             continue;
         if (columns[i]->empty())
-            columns[i] = std::move(*templates[i]->evaluateAll()).mutate();
+            columns[i] = std::move(*templates[i]->evaluateAll(block_missing_values, i)).mutate();
         else
         {
-            ColumnPtr evaluated = templates[i]->evaluateAll();
+            ColumnPtr evaluated = templates[i]->evaluateAll(block_missing_values, i, columns[i]->size());
             columns[i]->insertRangeFrom(*evaluated, 0, evaluated->size());
         }
     }
@@ -91,7 +93,7 @@ Chunk ValuesBlockInputFormat::generate()
     return Chunk{std::move(columns), rows_in_block};
 }
 
-void ValuesBlockInputFormat::readRow(MutableColumns & columns)
+void ValuesBlockInputFormat::readRow(MutableColumns & columns, size_t row_num)
 {
     assertChar('(', buf);
 
@@ -99,17 +101,22 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns)
     {
         skipWhitespaceIfAny(buf);
         PeekableReadBufferCheckpoint checkpoint{buf};
+        bool read;
 
         /// Parse value using fast streaming parser for literals and slow SQL parser for expressions.
         /// If there is SQL expression in some row, template of this expression will be deduced,
         /// so it makes possible to parse the following rows much faster
         /// if expressions in the following rows have the same structure
         if (parser_type_for_column[column_idx] == ParserType::Streaming)
-            tryReadValue(*columns[column_idx], column_idx);
+            read = tryReadValue(*columns[column_idx], column_idx);
         else if (parser_type_for_column[column_idx] == ParserType::BatchTemplate)
-            tryParseExpressionUsingTemplate(columns[column_idx], column_idx);
+            read = tryParseExpressionUsingTemplate(columns[column_idx], column_idx);
         else /// if (parser_type_for_column[column_idx] == ParserType::SingleExpressionEvaluation)
-            parseExpression(*columns[column_idx], column_idx);
+            read = parseExpression(*columns[column_idx], column_idx);
+
+        if (!read)
+            block_missing_values.setBit(column_idx, row_num);
+        /// If read is true, value still may be missing. Bit mask for these values will be copied from ConstantExpressionTemplate later.
     }
 
     skipWhitespaceIfAny(buf);
@@ -119,22 +126,22 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns)
     ++total_rows;
 }
 
-void ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)
+bool ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)
 {
     /// Try to parse expression using template if one was successfully deduced while parsing the first row
     if (templates[column_idx]->parseExpression(buf, format_settings))
     {
         ++rows_parsed_using_template[column_idx];
-        return;
+        return true;
     }
 
     /// Expression in the current row is not match template deduced on the first row.
     /// Evaluate expressions, which were parsed using this template.
     if (column->empty())
-        column = std::move(*templates[column_idx]->evaluateAll()).mutate();
+        column = std::move(*templates[column_idx]->evaluateAll(block_missing_values, column_idx)).mutate();
     else
     {
-        ColumnPtr evaluated = templates[column_idx]->evaluateAll();
+        ColumnPtr evaluated = templates[column_idx]->evaluateAll(block_missing_values, column_idx, column->size());
         column->insertRangeFrom(*evaluated, 0, evaluated->size());
     }
     /// Do not use this template anymore
@@ -142,19 +149,25 @@ void ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr &
     buf.rollbackToCheckpoint();
 
     /// It will deduce new template or fallback to slow SQL parser
-    parseExpression(*column, column_idx);
+    return parseExpression(*column, column_idx);
 }
 
-void ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)
+bool ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)
 {
     bool rollback_on_exception = false;
     try
     {
-        types[column_idx]->deserializeAsTextQuoted(column, buf, format_settings);
+        bool read = true;
+        const auto & type = types[column_idx];
+        if (format_settings.null_as_default && !type->isNullable())
+            read = DataTypeNullable::deserializeTextQuoted(column, buf, format_settings, type);
+        else
+            type->deserializeAsTextQuoted(column, buf, format_settings);
         rollback_on_exception = true;
 
         skipWhitespaceIfAny(buf);
         assertDelimiterAfterValue(column_idx);
+        return read;
     }
     catch (const Exception & e)
     {
@@ -166,12 +179,11 @@ void ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)
         /// Switch to SQL parser and don't try to use streaming parser for complex expressions
         /// Note: Throwing exceptions for each expression may be very slow because of stacktraces
         buf.rollbackToCheckpoint();
-        parseExpression(column, column_idx);
+        return parseExpression(column, column_idx);
     }
 }
 
-void
-ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
+bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
 {
     const Block & header = getPort().getHeader();
     const IDataType & type = *header.getByPosition(column_idx).type;
@@ -223,7 +235,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
         if (ok)
         {
             parser_type_for_column[column_idx] = ParserType::Streaming;
-            return;
+            return true;
         }
         else if (rollback_on_exception)
             column.popBack(1);
@@ -243,7 +255,8 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
             bool found_in_cache = false;
             const auto & result_type = header.getByPosition(column_idx).type;
             const char * delimiter = (column_idx + 1 == num_columns) ? ")" : ",";
-            auto structure = templates_cache.getFromCacheOrConstruct(result_type, TokenIterator(tokens), token_iterator,
+            auto structure = templates_cache.getFromCacheOrConstruct(result_type, format_settings.null_as_default,
+                                                                     TokenIterator(tokens), token_iterator,
                                                                      ast, *context, &found_in_cache, delimiter);
             templates[column_idx].emplace(structure);
             if (found_in_cache)
@@ -256,7 +269,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
             {
                 ++rows_parsed_using_template[column_idx];
                 parser_type_for_column[column_idx] = ParserType::BatchTemplate;
-                return;
+                return true;
             }
         }
         catch (...)
@@ -290,6 +303,11 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
     /// Check that we are indeed allowed to insert a NULL.
     if (value.isNull() && !type.isNullable())
     {
+        if (format_settings.null_as_default)
+        {
+            type.insertDefaultInto(column);
+            return false;
+        }
         buf.rollbackToCheckpoint();
         throw Exception{"Cannot insert NULL value into a column of type '" + type.getName() + "'"
                         + " at: " +
@@ -298,6 +316,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)
     }
 
     column.insert(value);
+    return true;
 }
 
 /// Can be used in fileSegmentationEngine for parallel parsing of Values
diff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h
index ec6a3b931e49..cf2c4efb1cf8 100644
--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h
+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h
@@ -33,6 +33,8 @@ class ValuesBlockInputFormat : public IInputFormat
 
     String getName() const override { return "ValuesBlockInputFormat"; }
 
+    const BlockMissingValues & getMissingValues() const override { return block_missing_values; }
+
 private:
     enum class ParserType
     {
@@ -45,11 +47,11 @@ class ValuesBlockInputFormat : public IInputFormat
 
     Chunk generate() override;
 
-    void readRow(MutableColumns & columns);
+    void readRow(MutableColumns & columns, size_t row_num);
 
-    void tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx);
-    ALWAYS_INLINE inline void tryReadValue(IColumn & column, size_t column_idx);
-    void parseExpression(IColumn & column, size_t column_idx);
+    bool tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx);
+    ALWAYS_INLINE inline bool tryReadValue(IColumn & column, size_t column_idx);
+    bool parseExpression(IColumn & column, size_t column_idx);
 
     ALWAYS_INLINE inline void assertDelimiterAfterValue(size_t column_idx);
     ALWAYS_INLINE inline bool checkDelimiterAfterValue(size_t column_idx);
@@ -81,6 +83,8 @@ class ValuesBlockInputFormat : public IInputFormat
     ConstantExpressionTemplate::Cache templates_cache;
 
     DataTypes types;
+
+    BlockMissingValues block_missing_values;
 };
 
 }
diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md
index 100dbe6b68af..eebdf10702de 100644
--- a/docs/en/interfaces/formats.md
+++ b/docs/en/interfaces/formats.md
@@ -983,3 +983,11 @@ should be located in the directory specified in [format_schema_path](../operatio
 in the server configuration.
 
 [Original article](https://clickhouse.yandex/docs/en/interfaces/formats/) <!--hide-->
+
+## Skipping Errors {#skippingerrors}
+
+Some formats such as `CSV`, `TabSeparated`, `TSKV`, `JSONEachRow`, `Template`, `CustomSeparated` and `Protobuf` can skip broken row if parsing error occurred and continue parsing from the beginning of next row. See [input_format_allow_errors_num](../operations/settings/settings.md#settings-input_format_allow_errors_num) and 
+[input_format_allow_errors_ratio](../operations/settings/settings.md#settings-input_format_allow_errors_ratio) settings.
+Limitations:
+ - In case of parsing error `JSONEachRow` skips all data until the new line (or EOF), so rows must be delimited by `
` to count errors correctly.
+ - `Template` and `CustomSeparated` use delimiter after the last column and delimiter between rows to find the beginning of next row, so skipping errors works only if at least one of them is not empty.
diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index 3f94d8e45c53..ef1b664272e0 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -130,30 +130,30 @@ Possible values:
 
 Default value: 0.
 
-## input_format_allow_errors_num
+## input_format_allow_errors_num {#settings-input_format_allow_errors_num}
 
 Sets the maximum number of acceptable errors when reading from text formats (CSV, TSV, etc.).
 
 The default value is 0.
 
-Always pair it with `input_format_allow_errors_ratio`. To skip errors, both settings must be greater than 0.
+Always pair it with `input_format_allow_errors_ratio`.
 
 If an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_num`, ClickHouse ignores the row and moves on to the next one.
 
-If `input_format_allow_errors_num` is exceeded, ClickHouse throws an exception.
+If both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception.
 
-## input_format_allow_errors_ratio
+## input_format_allow_errors_ratio {#settings-input_format_allow_errors_ratio}
 
 Sets the maximum percentage of errors allowed when reading from text formats (CSV, TSV, etc.).
 The percentage of errors is set as a floating-point number between 0 and 1.
 
 The default value is 0.
 
-Always pair it with `input_format_allow_errors_num`. To skip errors, both settings must be greater than 0.
+Always pair it with `input_format_allow_errors_num`.
 
 If an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_ratio`, ClickHouse ignores the row and moves on to the next one.
 
-If `input_format_allow_errors_ratio` is exceeded, ClickHouse throws an exception.
+If both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception.
 
 
 ## input_format_values_interpret_expressions {#settings-input_format_values_interpret_expressions}
@@ -227,7 +227,7 @@ Enabled by default.
 
 ## input_format_defaults_for_omitted_fields {#session_settings-input_format_defaults_for_omitted_fields}
 
-When performing `INSERT` queries, replace omitted input column values with default values of the respective columns. This option only applies to [JSONEachRow](../../interfaces/formats.md#jsoneachrow) and [CSV](../../interfaces/formats.md#csv) formats.
+When performing `INSERT` queries, replace omitted input column values with default values of the respective columns. This option only applies to [JSONEachRow](../../interfaces/formats.md#jsoneachrow), [CSV](../../interfaces/formats.md#csv) and [TabSeparated](../../interfaces/formats.md#tabseparated) formats.
 
 !!! note "Note"
     When this option is enabled, extended table metadata are sent from server to client. It consumes additional computing resources on the server and can reduce performance.
@@ -239,9 +239,15 @@ Possible values:
 
 Default value: 1.
 
+## input_format_tsv_empty_as_default {#settings-input_format_tsv_empty_as_default}
+
+When enabled, replace empty input fields in TSV with default values. For complex default expressions `input_format_defaults_for_omitted_fields` must be enabled too.
+
+Disabled by default.
+
 ## input_format_null_as_default {#settings-input_format_null_as_default}
 
-Enables or disables using default values if input data contain `NULL`, but data type of corresponding column in not `Nullable(T)` (for CSV format).
+Enables or disables using default values if input data contain `NULL`, but data type of corresponding column in not `Nullable(T)` (for text input formats).
 
 
 ## input_format_skip_unknown_fields {#settings-input_format_skip_unknown_fields}
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index 13d14389fc44..90803a7d27ea 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -207,6 +207,7 @@ Ok.
 
 - [JSONEachRow](../../interfaces/formats.md#jsoneachrow)
 - [CSV](../../interfaces/formats.md#csv)
+- [TabSeparated](../../interfaces/formats.md#tabseparated)
 
 !!! note "Примечание"
     Когда опция включена, сервер отправляет клиенту расширенные метаданные. Это требует дополнительных вычислительных ресурсов на сервере и может снизить производительность.
@@ -220,7 +221,7 @@ Ok.
 
 ## input_format_null_as_default {#settings-input_format_null_as_default}
 
-Включает или отключает использование значений по умолчанию в случаях, когда во входных данных содержится `NULL`, но тип соответствующего столбца не `Nullable(T)` (для формата CSV).
+Включает или отключает использование значений по умолчанию в случаях, когда во входных данных содержится `NULL`, но тип соответствующего столбца не `Nullable(T)` (для текстовых форматов).
 
 ## input_format_skip_unknown_fields {#settings-input_format_skip_unknown_fields}
 
