{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7215,
  "instance_id": "ClickHouse__ClickHouse-7215",
  "issue_numbers": [
    "6033"
  ],
  "base_commit": "dfe297b93f1815126fbc2186591226d28d3e2e5b",
  "patch": "diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h\nindex abdc3a4bd1e6..30752113a6bf 100644\n--- a/dbms/src/Core/Settings.h\n+++ b/dbms/src/Core/Settings.h\n@@ -176,8 +176,9 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, input_format_skip_unknown_fields, false, \"Skip columns with unknown names from input data (it works for JSONEachRow, CSVWithNames, TSVWithNames and TSKV formats).\") \\\n     M(SettingBool, input_format_with_names_use_header, false, \"For TSVWithNames and CSVWithNames input formats this controls whether format parser is to assume that column data appear in the input exactly as they are specified in the header.\") \\\n     M(SettingBool, input_format_import_nested_json, false, \"Map nested JSON data to nested tables (it works for JSONEachRow format).\") \\\n-    M(SettingBool, input_format_defaults_for_omitted_fields, true, \"For input data calculate default expressions for omitted fields (it works for JSONEachRow format).\") \\\n-    M(SettingBool, input_format_null_as_default, false, \"For CSV format initialize null fields with default values if data type of this field is not nullable\") \\\n+    M(SettingBool, input_format_defaults_for_omitted_fields, true, \"For input data calculate default expressions for omitted fields (it works for JSONEachRow, CSV and TSV formats).\") \\\n+    M(SettingBool, input_format_tsv_empty_as_default, false, \"Treat empty fields in TSV input as default values.\") \\\n+    M(SettingBool, input_format_null_as_default, false, \"For text input formats initialize null fields with default values if data type of this field is not nullable\") \\\n     \\\n     M(SettingBool, input_format_values_interpret_expressions, true, \"For Values format: if field could not be parsed by streaming parser, run SQL parser and try to interpret it as SQL expression.\") \\\n     M(SettingBool, input_format_values_deduce_templates_of_expressions, false, \"For Values format: if field could not be parsed by streaming parser, run SQL parser, deduce template of the SQL expression, try to parse all rows using template and then interpret expression for all rows.\") \\\n@@ -202,8 +203,8 @@ struct Settings : public SettingsCollection<Settings>\n     \\\n     M(SettingBool, fsync_metadata, 1, \"Do fsync after changing metadata for tables and databases (.sql files). Could be disabled in case of poor latency on server with high load of DDL queries and high load of disk subsystem.\") \\\n     \\\n-    M(SettingUInt64, input_format_allow_errors_num, 0, \"Maximum absolute amount of errors while reading text formats (like CSV, TSV). In case of error, if both absolute and relative values are non-zero, and at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.\") \\\n-    M(SettingFloat, input_format_allow_errors_ratio, 0, \"Maximum relative amount of errors while reading text formats (like CSV, TSV). In case of error, if both absolute and relative values are non-zero, and at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.\") \\\n+    M(SettingUInt64, input_format_allow_errors_num, 0, \"Maximum absolute amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.\") \\\n+    M(SettingFloat, input_format_allow_errors_ratio, 0, \"Maximum relative amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.\") \\\n     \\\n     M(SettingBool, join_use_nulls, 0, \"Use NULLs for non-joined rows of outer JOINs for types that can be inside Nullable. If false, use default value of corresponding columns data type.\") \\\n     \\\ndiff --git a/dbms/src/DataTypes/DataTypeNullable.cpp b/dbms/src/DataTypes/DataTypeNullable.cpp\nindex 0eb82d6abdbb..fa6eb0d6d715 100644\n--- a/dbms/src/DataTypes/DataTypeNullable.cpp\n+++ b/dbms/src/DataTypes/DataTypeNullable.cpp\n@@ -156,11 +156,11 @@ void DataTypeNullable::serializeBinary(const IColumn & column, size_t row_num, W\n         nested_data_type->serializeBinary(col.getNestedColumn(), row_num, ostr);\n }\n \n-\n+/// Deserialize value into ColumnNullable.\n /// We need to insert both to nested column and to null byte map, or, in case of exception, to not insert at all.\n-template <typename CheckForNull, typename DeserializeNested>\n-static void safeDeserialize(\n-    IColumn & column,\n+template <typename ReturnType = void, typename CheckForNull, typename DeserializeNested, typename std::enable_if_t<std::is_same_v<ReturnType, void>, ReturnType>* = nullptr>\n+static ReturnType safeDeserialize(\n+    IColumn & column, const IDataType & /*nested_data_type*/,\n     CheckForNull && check_for_null, DeserializeNested && deserialize_nested)\n {\n     ColumnNullable & col = assert_cast<ColumnNullable &>(column);\n@@ -185,10 +185,26 @@ static void safeDeserialize(\n     }\n }\n \n+/// Deserialize value into non-nullable column. In case of NULL, insert default value and return false.\n+template <typename ReturnType = void, typename CheckForNull, typename DeserializeNested, typename std::enable_if_t<std::is_same_v<ReturnType, bool>, ReturnType>* = nullptr>\n+static ReturnType safeDeserialize(\n+        IColumn & column, const IDataType & nested_data_type,\n+        CheckForNull && check_for_null, DeserializeNested && deserialize_nested)\n+{\n+    assert(!dynamic_cast<ColumnNullable *>(&column));\n+    assert(!dynamic_cast<const DataTypeNullable *>(&nested_data_type));\n+    bool insert_default = check_for_null();\n+    if (insert_default)\n+        nested_data_type.insertDefaultInto(column);\n+    else\n+        deserialize_nested(column);\n+    return !insert_default;\n+}\n+\n \n void DataTypeNullable::deserializeBinary(IColumn & column, ReadBuffer & istr) const\n {\n-    safeDeserialize(column,\n+    safeDeserialize(column, *nested_data_type,\n         [&istr] { bool is_null = 0; readBinary(is_null, istr); return is_null; },\n         [this, &istr] (IColumn & nested) { nested_data_type->deserializeBinary(nested, istr); });\n }\n@@ -206,6 +222,13 @@ void DataTypeNullable::serializeTextEscaped(const IColumn & column, size_t row_n\n \n \n void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n+{\n+    deserializeTextEscaped<void>(column, istr, settings, nested_data_type);\n+}\n+\n+template<typename ReturnType>\n+ReturnType DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,\n+                                                    const DataTypePtr & nested_data_type)\n {\n     /// Little tricky, because we cannot discriminate null from first character.\n \n@@ -215,9 +238,9 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist\n     /// This is not null, surely.\n     if (*istr.position() != '\\\\')\n     {\n-        safeDeserialize(column,\n+        return safeDeserialize<ReturnType>(column, *nested_data_type,\n             [] { return false; },\n-            [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextEscaped(nested, istr, settings); });\n+            [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextEscaped(nested, istr, settings); });\n     }\n     else\n     {\n@@ -227,7 +250,7 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist\n         if (istr.eof())\n             throw Exception(\"Unexpected end of stream, while parsing value of Nullable type, after backslash\", ErrorCodes::CANNOT_READ_ALL_DATA);\n \n-        safeDeserialize(column,\n+        return safeDeserialize<ReturnType>(column, *nested_data_type,\n             [&istr]\n             {\n                 if (*istr.position() == 'N')\n@@ -237,7 +260,7 @@ void DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer & ist\n                 }\n                 return false;\n             },\n-            [this, &istr, &settings] (IColumn & nested)\n+            [&nested_data_type, &istr, &settings] (IColumn & nested)\n             {\n                 if (istr.position() != istr.buffer().begin())\n                 {\n@@ -275,15 +298,22 @@ void DataTypeNullable::serializeTextQuoted(const IColumn & column, size_t row_nu\n \n void DataTypeNullable::deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    safeDeserialize(column,\n+    deserializeTextQuoted<void>(column, istr, settings, nested_data_type);\n+}\n+\n+template<typename ReturnType>\n+ReturnType DataTypeNullable::deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,\n+                                                   const DataTypePtr & nested_data_type)\n+{\n+    return safeDeserialize<ReturnType>(column, *nested_data_type,\n         [&istr] { return checkStringByFirstCharacterAndAssertTheRestCaseInsensitive(\"NULL\", istr); },\n-        [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextQuoted(nested, istr, settings); });\n+        [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextQuoted(nested, istr, settings); });\n }\n \n \n void DataTypeNullable::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    safeDeserialize(column,\n+    safeDeserialize(column, *nested_data_type,\n         [&istr] { return checkStringByFirstCharacterAndAssertTheRestCaseInsensitive(\"NULL\", istr); },\n         [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsWholeText(nested, istr, settings); });\n }\n@@ -300,6 +330,13 @@ void DataTypeNullable::serializeTextCSV(const IColumn & column, size_t row_num,\n }\n \n void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n+{\n+    deserializeTextCSV<void>(column, istr, settings, nested_data_type);\n+}\n+\n+template<typename ReturnType>\n+ReturnType DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,\n+                                                    const DataTypePtr & nested_data_type)\n {\n     constexpr char const * null_literal = \"NULL\";\n     constexpr size_t len = 4;\n@@ -331,7 +368,7 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c\n         return false;\n     };\n \n-    auto deserialize_nested = [this, &settings, &istr, &null_prefix_len] (IColumn & nested)\n+    auto deserialize_nested = [&nested_data_type, &settings, &istr, &null_prefix_len] (IColumn & nested)\n     {\n         if (likely(!null_prefix_len))\n             nested_data_type->deserializeAsTextCSV(nested, istr, settings);\n@@ -357,8 +394,8 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c\n                 WriteBufferFromOwnString parsed_value;\n                 nested_data_type->serializeAsTextCSV(nested, nested.size() - 1, parsed_value, settings);\n                 throw DB::Exception(\"Error while parsing \\\"\" + std::string(null_literal, null_prefix_len)\n-                                    + std::string(istr.position(), std::min(size_t{10}, istr.available())) + \"\\\" as \" + getName()\n-                                    + \" at position \" + std::to_string(istr.count()) + \": expected \\\"NULL\\\" or \" + nested_data_type->getName()\n+                                    + std::string(istr.position(), std::min(size_t{10}, istr.available())) + \"\\\" as Nullable(\" + nested_data_type->getName()\n+                                    + \") at position \" + std::to_string(istr.count()) + \": expected \\\"NULL\\\" or \" + nested_data_type->getName()\n                                     + \", got \\\"\" + std::string(null_literal, buf.count()) + \"\\\", which was deserialized as \\\"\"\n                                     + parsed_value.str() + \"\\\". It seems that input data is ill-formatted.\",\n                                     ErrorCodes::CANNOT_READ_ALL_DATA);\n@@ -366,7 +403,7 @@ void DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & istr, c\n         }\n     };\n \n-    safeDeserialize(column, check_for_null, deserialize_nested);\n+    return safeDeserialize<ReturnType>(column, *nested_data_type, check_for_null, deserialize_nested);\n }\n \n void DataTypeNullable::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n@@ -397,9 +434,16 @@ void DataTypeNullable::serializeTextJSON(const IColumn & column, size_t row_num,\n \n void DataTypeNullable::deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    safeDeserialize(column,\n+    deserializeTextJSON<void>(column, istr, settings, nested_data_type);\n+}\n+\n+template<typename ReturnType>\n+ReturnType DataTypeNullable::deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings & settings,\n+                                                    const DataTypePtr & nested_data_type)\n+{\n+    return safeDeserialize<ReturnType>(column, *nested_data_type,\n         [&istr] { return checkStringByFirstCharacterAndAssertTheRest(\"null\", istr); },\n-        [this, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextJSON(nested, istr, settings); });\n+        [&nested_data_type, &istr, &settings] (IColumn & nested) { nested_data_type->deserializeAsTextJSON(nested, istr, settings); });\n }\n \n void DataTypeNullable::serializeTextXML(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n@@ -492,4 +536,10 @@ DataTypePtr removeNullable(const DataTypePtr & type)\n     return type;\n }\n \n+\n+template bool DataTypeNullable::deserializeTextEscaped<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);\n+template bool DataTypeNullable::deserializeTextQuoted<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);\n+template bool DataTypeNullable::deserializeTextCSV<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);\n+template bool DataTypeNullable::deserializeTextJSON<bool>(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);\n+\n }\ndiff --git a/dbms/src/DataTypes/DataTypeNullable.h b/dbms/src/DataTypes/DataTypeNullable.h\nindex 49b14eefc6c1..1766b399c2a8 100644\n--- a/dbms/src/DataTypes/DataTypeNullable.h\n+++ b/dbms/src/DataTypes/DataTypeNullable.h\n@@ -100,6 +100,17 @@ class DataTypeNullable final : public IDataType\n \n     const DataTypePtr & getNestedType() const { return nested_data_type; }\n \n+    /// If ReturnType is bool, check for NULL and deserialize value into non-nullable column (and return true) or insert default value of nested type (and return false)\n+    /// If ReturnType is void, deserialize Nullable(T)\n+    template <typename ReturnType = bool>\n+    static ReturnType deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);\n+    template <typename ReturnType = bool>\n+    static ReturnType deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);\n+    template <typename ReturnType = bool>\n+    static ReturnType deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const DataTypePtr & nested);\n+    template <typename ReturnType = bool>\n+    static ReturnType deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &, const DataTypePtr & nested);\n+\n private:\n     DataTypePtr nested_data_type;\n };\ndiff --git a/dbms/src/Formats/FormatFactory.cpp b/dbms/src/Formats/FormatFactory.cpp\nindex 1fc7da240b20..eddd5aa92cda 100644\n--- a/dbms/src/Formats/FormatFactory.cpp\n+++ b/dbms/src/Formats/FormatFactory.cpp\n@@ -40,7 +40,7 @@ static FormatSettings getInputFormatSetting(const Settings & settings)\n     format_settings.csv.allow_double_quotes = settings.format_csv_allow_double_quotes;\n     format_settings.csv.unquoted_null_literal_as_null = settings.input_format_csv_unquoted_null_literal_as_null;\n     format_settings.csv.empty_as_default = settings.input_format_defaults_for_omitted_fields;\n-    format_settings.csv.null_as_default = settings.input_format_null_as_default;\n+    format_settings.null_as_default = settings.input_format_null_as_default;\n     format_settings.values.interpret_expressions = settings.input_format_values_interpret_expressions;\n     format_settings.values.deduce_templates_of_expressions = settings.input_format_values_deduce_templates_of_expressions;\n     format_settings.values.accurate_types_of_literals = settings.input_format_values_accurate_types_of_literals;\n@@ -53,6 +53,7 @@ static FormatSettings getInputFormatSetting(const Settings & settings)\n     format_settings.template_settings.resultset_format = settings.format_template_resultset;\n     format_settings.template_settings.row_format = settings.format_template_row;\n     format_settings.template_settings.row_between_delimiter = settings.format_template_rows_between_delimiter;\n+    format_settings.tsv.empty_as_default = settings.input_format_tsv_empty_as_default;\n \n     return format_settings;\n }\ndiff --git a/dbms/src/Formats/FormatSettings.h b/dbms/src/Formats/FormatSettings.h\nindex f8018dec1250..dfd5d5b86f62 100644\n--- a/dbms/src/Formats/FormatSettings.h\n+++ b/dbms/src/Formats/FormatSettings.h\n@@ -29,7 +29,6 @@ struct FormatSettings\n         bool allow_double_quotes = true;\n         bool unquoted_null_literal_as_null = false;\n         bool empty_as_default = false;\n-        bool null_as_default = false;\n     };\n \n     CSV csv;\n@@ -61,10 +60,18 @@ struct FormatSettings\n \n     Template template_settings;\n \n+    struct TSV\n+    {\n+        bool empty_as_default = false;\n+    };\n+\n+    TSV tsv;\n+\n     bool skip_unknown_fields = false;\n     bool with_names_use_header = false;\n     bool write_statistics = true;\n     bool import_nested_json = false;\n+    bool null_as_default = false;\n \n     enum class DateTimeInputFormat\n     {\ndiff --git a/dbms/src/Interpreters/evaluateConstantExpression.cpp b/dbms/src/Interpreters/evaluateConstantExpression.cpp\nindex f7843f682b72..2e46ff294cc3 100644\n--- a/dbms/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/dbms/src/Interpreters/evaluateConstantExpression.cpp\n@@ -15,6 +15,7 @@\n #include <Parsers/ExpressionElementParsers.h>\n #include <TableFunctions/TableFunctionFactory.h>\n #include <Common/typeid_cast.h>\n+#include <Interpreters/ReplaceQueryParameterVisitor.h>\n \n \n namespace DB\n@@ -31,6 +32,9 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co\n {\n     NamesAndTypesList source_columns = {{ \"_dummy\", std::make_shared<DataTypeUInt8>() }};\n     auto ast = node->clone();\n+    ReplaceQueryParameterVisitor param_visitor(context.getQueryParameters());\n+    param_visitor.visit(ast);\n+    String name = ast->getColumnName();\n     auto syntax_result = SyntaxAnalyzer(context).analyze(ast, source_columns);\n     ExpressionActionsPtr expr_for_constant_folding = ExpressionAnalyzer(ast, syntax_result, context).getConstActions();\n \n@@ -42,8 +46,6 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co\n     if (!block_with_constants || block_with_constants.rows() == 0)\n         throw Exception(\"Logical error: empty block after evaluation of constant expression for IN, VALUES or LIMIT\", ErrorCodes::LOGICAL_ERROR);\n \n-    String name = node->getColumnName();\n-\n     if (!block_with_constants.has(name))\n         throw Exception(\"Element of set in IN, VALUES or LIMIT is not a constant expression (result column not found): \" + name, ErrorCodes::BAD_ARGUMENTS);\n \ndiff --git a/dbms/src/Processors/Formats/IRowInputFormat.cpp b/dbms/src/Processors/Formats/IRowInputFormat.cpp\nindex 5aec8e94cf12..39422bf20b52 100644\n--- a/dbms/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/IRowInputFormat.cpp\n@@ -46,6 +46,7 @@ Chunk IRowInputFormat::generate()\n     size_t prev_rows = total_rows;\n \n     ///auto chunk_missing_values = std::make_unique<ChunkMissingValues>();\n+    block_missing_values.clear();\n \n     try\n     {\ndiff --git a/dbms/src/Processors/Formats/IRowInputFormat.h b/dbms/src/Processors/Formats/IRowInputFormat.h\nindex 9443d2b633bc..38dcb6acc9e9 100644\n--- a/dbms/src/Processors/Formats/IRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/IRowInputFormat.h\n@@ -77,7 +77,6 @@ class IRowInputFormat : public IInputFormat\n \n private:\n     Params params;\n-    Stopwatch total_stopwatch {CLOCK_MONOTONIC_COARSE};\n \n     size_t total_rows = 0;\n     size_t num_errors = 0;\ndiff --git a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\nindex b5ee30fb7f8c..a13bb3651920 100644\n--- a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n@@ -24,12 +24,17 @@ CSVRowInputFormat::CSVRowInputFormat(const Block & header_, ReadBuffer & in_, co\n     , with_names(with_names_)\n     , format_settings(format_settings_)\n {\n+\n+    const String bad_delimiters = \" \\t\\\"'.UL\";\n+    if (bad_delimiters.find(format_settings.csv.delimiter) != String::npos)\n+        throw Exception(String(\"CSV format may not work correctly with delimiter '\") + format_settings.csv.delimiter +\n+                        \"'. Try use CustomSeparated format instead.\", ErrorCodes::BAD_ARGUMENTS);\n+\n     auto & sample = getPort().getHeader();\n     size_t num_columns = sample.columns();\n \n     data_types.resize(num_columns);\n     column_indexes_by_names.reserve(num_columns);\n-    column_idx_to_nullable_column_idx.resize(num_columns);\n \n     for (size_t i = 0; i < num_columns; ++i)\n     {\n@@ -37,16 +42,6 @@ CSVRowInputFormat::CSVRowInputFormat(const Block & header_, ReadBuffer & in_, co\n \n         data_types[i] = column_info.type;\n         column_indexes_by_names.emplace(column_info.name, i);\n-\n-        /// If input_format_null_as_default=1 we need ColumnNullable of type DataTypeNullable(nested_type)\n-        /// to parse value as nullable before inserting it in corresponding column of not-nullable type.\n-        /// Constructing temporary column for each row is slow, so we prepare it here\n-        if (format_settings_.csv.null_as_default && !column_info.type->isNullable() && column_info.type->canBeInsideNullable())\n-        {\n-            column_idx_to_nullable_column_idx[i] = nullable_columns.size();\n-            nullable_types.emplace_back(std::make_shared<DataTypeNullable>(column_info.type));\n-            nullable_columns.emplace_back(nullable_types.back()->createColumn());\n-        }\n     }\n }\n \n@@ -220,6 +215,7 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext\n     /// it doesn't have to check it.\n     bool have_default_columns = have_always_default_columns;\n \n+    ext.read_columns.assign(read_columns.size(), true);\n     const auto delimiter = format_settings.csv.delimiter;\n     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)\n     {\n@@ -229,9 +225,8 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext\n         if (table_column)\n         {\n             skipWhitespacesAndTabs(in);\n-            read_columns[*table_column] = readField(*columns[*table_column], data_types[*table_column],\n-                                                    is_last_file_column, *table_column);\n-            if (!read_columns[*table_column])\n+            ext.read_columns[*table_column] = readField(*columns[*table_column], data_types[*table_column], is_last_file_column);\n+            if (!ext.read_columns[*table_column])\n                 have_default_columns = true;\n             skipWhitespacesAndTabs(in);\n         }\n@@ -258,9 +253,9 @@ bool CSVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext\n                 /// value, we do not have to use the default value specified by\n                 /// the data type, and can just use IColumn::insertDefault().\n                 columns[i]->insertDefault();\n+                ext.read_columns[i] = false;\n             }\n         }\n-        ext.read_columns = read_columns;\n     }\n \n     return true;\n@@ -365,8 +360,7 @@ void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn &\n     if (column_indexes_for_input_fields[file_column])\n     {\n         const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();\n-        if (!readField(column, type, is_last_file_column, *column_indexes_for_input_fields[file_column]))\n-            column.insertDefault();\n+        readField(column, type, is_last_file_column);\n     }\n     else\n     {\n@@ -378,12 +372,14 @@ void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn &\n     skipWhitespacesAndTabs(in);\n }\n \n-bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column, size_t column_idx)\n+bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column)\n {\n     const bool at_delimiter = !in.eof() && *in.position() == format_settings.csv.delimiter;\n     const bool at_last_column_line_end = is_last_file_column\n                                          && (in.eof() || *in.position() == '\\n' || *in.position() == '\\r');\n \n+    /// Note: Tuples are serialized in CSV as separate columns, but with empty_as_default or null_as_default\n+    /// only one empty or NULL column will be expected\n     if (format_settings.csv.empty_as_default\n         && (at_delimiter || at_last_column_line_end))\n     {\n@@ -393,20 +389,13 @@ bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bo\n         /// commas, which might be also used as delimiters. However,\n         /// they do not contain empty unquoted fields, so this check\n         /// works for tuples as well.\n+        column.insertDefault();\n         return false;\n     }\n-    else if (column_idx_to_nullable_column_idx[column_idx])\n+    else if (format_settings.null_as_default && !type->isNullable())\n     {\n         /// If value is null but type is not nullable then use default value instead.\n-        const size_t nullable_idx = *column_idx_to_nullable_column_idx[column_idx];\n-        auto & tmp_col = *nullable_columns[nullable_idx];\n-        nullable_types[nullable_idx]->deserializeAsTextCSV(tmp_col, in, format_settings);\n-        Field value = tmp_col[0];\n-        tmp_col.popBack(1);     /// do not store copy of values in memory\n-        if (value.isNull())\n-            return false;\n-        column.insert(value);\n-        return true;\n+        return DataTypeNullable::deserializeTextCSV(column, in, format_settings, type);\n     }\n     else\n     {\ndiff --git a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h\nindex b8a3a956e1ed..cebc8f6d6a16 100644\n--- a/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h\n@@ -61,12 +61,7 @@ class CSVRowInputFormat : public RowInputFormatWithDiagnosticInfo\n         return *pos != '\\n' && *pos != '\\r' && *pos != format_settings.csv.delimiter;\n     }\n \n-    /// For setting input_format_null_as_default\n-    DataTypes nullable_types;\n-    MutableColumns nullable_columns;\n-    OptionalIndexes column_idx_to_nullable_column_idx;\n-\n-    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column, size_t column_idx);\n+    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column);\n };\n \n }\ndiff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\nindex c6c88b8505f8..8c834c44932c 100644\n--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n@@ -151,7 +151,7 @@ class ReplaceLiteralsVisitor\n         {\n             info.special_parser.is_array = true;\n             info.type = applyVisitor(FieldToDataType(), info.literal->value);\n-            auto nested_type = dynamic_cast<const DataTypeArray &>(*info.type).getNestedType();\n+            auto nested_type = assert_cast<const DataTypeArray &>(*info.type).getNestedType();\n \n             /// It can be Array(Nullable(nested_type))\n             bool array_of_nullable = false;\n@@ -212,9 +212,9 @@ class ReplaceLiteralsVisitor\n /// E.g. template of \"position('some string', 'other string') != 0\" is\n /// [\"position\", \"(\", DataTypeString, \",\", DataTypeString, \")\", \"!=\", DataTypeUInt64]\n ConstantExpressionTemplate::TemplateStructure::TemplateStructure(LiteralsInfo & replaced_literals, TokenIterator expression_begin, TokenIterator expression_end,\n-                                                                 ASTPtr & expression, const IDataType & result_type, const Context & context)\n+                                                                 ASTPtr & expression, const IDataType & result_type, bool null_as_default_, const Context & context)\n {\n-\n+    null_as_default = null_as_default_;\n \n     std::sort(replaced_literals.begin(), replaced_literals.end(), [](const LiteralInfo & a, const LiteralInfo & b)\n     {\n@@ -252,16 +252,17 @@ ConstantExpressionTemplate::TemplateStructure::TemplateStructure(LiteralsInfo &\n         ++prev_end;\n     }\n \n-    addNodesToCastResult(result_type, expression);\n-    result_column_name = expression->getColumnName();\n+    addNodesToCastResult(result_type, expression, null_as_default);\n \n     auto syntax_result = SyntaxAnalyzer(context).analyze(expression, literals.getNamesAndTypesList());\n+    result_column_name = expression->getColumnName();\n     actions_on_literals = ExpressionAnalyzer(expression, syntax_result, context).getActions(false);\n }\n \n size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTPtr & expression,\n                                                                       const LiteralsInfo & replaced_literals,\n                                                                       const DataTypePtr & result_column_type,\n+                                                                      bool null_as_default,\n                                                                       const String & salt)\n {\n     /// TODO distinguish expressions with the same AST and different tokens (e.g. \"CAST(expr, 'Type')\" and \"CAST(expr AS Type)\")\n@@ -272,6 +273,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP\n \n     for (const auto & info : replaced_literals)\n         hash_state.update(info.type->getName());\n+    hash_state.update(null_as_default);\n \n     /// Allows distinguish expression in the last column in Values format\n     hash_state.update(salt);\n@@ -288,6 +290,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP\n \n ConstantExpressionTemplate::TemplateStructurePtr\n ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & result_column_type,\n+                                                           bool null_as_default,\n                                                            TokenIterator expression_begin,\n                                                            TokenIterator expression_end,\n                                                            const ASTPtr & expression_,\n@@ -298,17 +301,18 @@ ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & r\n     TemplateStructurePtr res;\n     ASTPtr expression = expression_->clone();\n     ReplaceLiteralsVisitor visitor(context);\n-    visitor.visit(expression, result_column_type->isNullable());\n+    visitor.visit(expression, result_column_type->isNullable() || null_as_default);\n     ReplaceQueryParameterVisitor param_visitor(context.getQueryParameters());\n     param_visitor.visit(expression);\n \n-    size_t template_hash = TemplateStructure::getTemplateHash(expression, visitor.replaced_literals, result_column_type, salt);\n+    size_t template_hash = TemplateStructure::getTemplateHash(expression, visitor.replaced_literals, result_column_type, null_as_default, salt);\n     auto iter = cache.find(template_hash);\n     if (iter == cache.end())\n     {\n         if (max_size <= cache.size())\n             cache.clear();\n-        res = std::make_shared<TemplateStructure>(visitor.replaced_literals, expression_begin, expression_end, expression, *result_column_type, context);\n+        res = std::make_shared<TemplateStructure>(visitor.replaced_literals, expression_begin, expression_end,\n+                                                  expression, *result_column_type, null_as_default, context);\n         cache.insert({template_hash, res});\n         if (found_in_cache)\n             *found_in_cache = false;\n@@ -416,7 +420,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co\n \n         const Field & array = ast->as<ASTLiteral &>().value;\n         auto array_type = applyVisitor(FieldToDataType(), array);\n-        auto nested_type = dynamic_cast<const DataTypeArray &>(*array_type).getNestedType();\n+        auto nested_type = assert_cast<const DataTypeArray &>(*array_type).getNestedType();\n         if (type_info.is_nullable)\n             if (auto nullable = dynamic_cast<const DataTypeNullable *>(nested_type.get()))\n                 nested_type = nullable->getNestedType();\n@@ -488,7 +492,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co\n     }\n }\n \n-ColumnPtr ConstantExpressionTemplate::evaluateAll()\n+ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset)\n {\n     Block evaluated = structure->literals.cloneWithColumns(std::move(columns));\n     columns = structure->literals.cloneEmptyColumns();\n@@ -506,23 +510,40 @@ ColumnPtr ConstantExpressionTemplate::evaluateAll()\n                         ErrorCodes::LOGICAL_ERROR);\n \n     rows_count = 0;\n-    return evaluated.getByName(structure->result_column_name).column->convertToFullColumnIfConst();\n+    ColumnPtr res = evaluated.getByName(structure->result_column_name).column->convertToFullColumnIfConst();\n+    if (!structure->null_as_default)\n+        return res;\n+\n+    /// Extract column with evaluated expression and mask for NULLs\n+    auto & tuple = assert_cast<const ColumnTuple &>(*res);\n+    if (tuple.tupleSize() != 2)\n+        throw Exception(\"Invalid tuple size, it'a a bug\", ErrorCodes::LOGICAL_ERROR);\n+    auto & is_null = assert_cast<const ColumnUInt8 &>(tuple.getColumn(1));\n+\n+    for (size_t i = 0; i < is_null.size(); ++i)\n+        if (is_null.getUInt(i))\n+            nulls.setBit(column_idx, offset + i);\n+\n+    return tuple.getColumnPtr(0);\n }\n \n-void ConstantExpressionTemplate::TemplateStructure::addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr)\n+void ConstantExpressionTemplate::TemplateStructure::addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr, bool null_as_default)\n {\n-    auto result_type = std::make_shared<ASTLiteral>(result_column_type.getName());\n-\n-    auto arguments = std::make_shared<ASTExpressionList>();\n-    arguments->children.push_back(std::move(expr));\n-    arguments->children.push_back(std::move(result_type));\n+    /// Replace \"expr\" with \"CAST(expr, 'TypeName')\"\n+    /// or with \"(CAST(assumeNotNull(expr as _expression), 'TypeName'), isNull(_expression))\" if null_as_default is true\n+    if (null_as_default)\n+    {\n+        expr->setAlias(\"_expression\");\n+        expr = makeASTFunction(\"assumeNotNull\", std::move(expr));\n+    }\n \n-    auto cast = std::make_shared<ASTFunction>();\n-    cast->name = \"CAST\";\n-    cast->arguments = std::move(arguments);\n-    cast->children.push_back(cast->arguments);\n+    expr = makeASTFunction(\"CAST\", std::move(expr), std::make_shared<ASTLiteral>(result_column_type.getName()));\n \n-    expr = std::move(cast);\n+    if (null_as_default)\n+    {\n+        auto is_null = makeASTFunction(\"isNull\", std::make_shared<ASTIdentifier>(\"_expression\"));\n+        expr = makeASTFunction(\"tuple\", std::move(expr), std::move(is_null));\n+    }\n }\n \n }\ndiff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\nindex 4f4dac849b27..96e1c653c037 100644\n--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n@@ -21,10 +21,11 @@ class ConstantExpressionTemplate : boost::noncopyable\n     struct TemplateStructure : boost::noncopyable\n     {\n         TemplateStructure(LiteralsInfo & replaced_literals, TokenIterator expression_begin, TokenIterator expression_end,\n-                          ASTPtr & expr, const IDataType & result_type, const Context & context);\n+                          ASTPtr & expr, const IDataType & result_type, bool null_as_default_, const Context & context);\n \n-        static void addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr);\n-        static size_t getTemplateHash(const ASTPtr & expression, const LiteralsInfo & replaced_literals, const DataTypePtr & result_column_type, const String & salt);\n+        static void addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr, bool null_as_default);\n+        static size_t getTemplateHash(const ASTPtr & expression, const LiteralsInfo & replaced_literals,\n+                                      const DataTypePtr & result_column_type, bool null_as_default, const String & salt);\n \n         String result_column_name;\n \n@@ -35,6 +36,7 @@ class ConstantExpressionTemplate : boost::noncopyable\n         ExpressionActionsPtr actions_on_literals;\n \n         std::vector<SpecialParserType> special_parser;\n+        bool null_as_default;\n     };\n \n public:\n@@ -50,6 +52,7 @@ class ConstantExpressionTemplate : boost::noncopyable\n \n         /// Deduce template of expression of type result_column_type and add it to cache (or use template from cache)\n         TemplateStructurePtr getFromCacheOrConstruct(const DataTypePtr & result_column_type,\n+                                                     bool null_as_default,\n                                                      TokenIterator expression_begin,\n                                                      TokenIterator expression_end,\n                                                      const ASTPtr & expression_,\n@@ -65,8 +68,9 @@ class ConstantExpressionTemplate : boost::noncopyable\n     /// and parse literals into temporary columns\n     bool parseExpression(ReadBuffer & istr, const FormatSettings & settings);\n \n-    /// Evaluate batch of expressions were parsed using template\n-    ColumnPtr evaluateAll();\n+    /// Evaluate batch of expressions were parsed using template.\n+    /// If template was deduced with null_as_default == true, set bits in nulls for NULL values in column_idx, starting from offset.\n+    ColumnPtr evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset = 0);\n \n     size_t rowsCount() const { return rows_count; }\n \ndiff --git a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\nindex 20830d2eccff..e49f9315887d 100644\n--- a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n@@ -3,6 +3,7 @@\n #include <Processors/Formats/Impl/JSONEachRowRowInputFormat.h>\n #include <Formats/FormatFactory.h>\n #include <DataTypes/NestedUtils.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n namespace DB\n {\n@@ -129,21 +130,23 @@ void JSONEachRowRowInputFormat::skipUnknownField(const StringRef & name_ref)\n \n void JSONEachRowRowInputFormat::readField(size_t index, MutableColumns & columns)\n {\n-    if (read_columns[index])\n+    if (seen_columns[index])\n         throw Exception(\"Duplicate field found while parsing JSONEachRow format: \" + columnName(index), ErrorCodes::INCORRECT_DATA);\n \n     try\n     {\n-        auto & header = getPort().getHeader();\n-        header.getByPosition(index).type->deserializeAsTextJSON(*columns[index], in, format_settings);\n+        seen_columns[index] = read_columns[index] = true;\n+        const auto & type = getPort().getHeader().getByPosition(index).type;\n+        if (format_settings.null_as_default && !type->isNullable())\n+            read_columns[index] = DataTypeNullable::deserializeTextJSON(*columns[index], in, format_settings, type);\n+        else\n+            type->deserializeAsTextJSON(*columns[index], in, format_settings);\n     }\n     catch (Exception & e)\n     {\n         e.addMessage(\"(while read the value of key \" + columnName(index) + \")\");\n         throw;\n     }\n-\n-    read_columns[index] = true;\n }\n \n inline bool JSONEachRowRowInputFormat::advanceToNextKey(size_t key_index)\n@@ -230,8 +233,8 @@ bool JSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi\n \n     size_t num_columns = columns.size();\n \n-    /// Set of columns for which the values were read. The rest will be filled with default values.\n     read_columns.assign(num_columns, false);\n+    seen_columns.assign(num_columns, false);\n \n     nested_prefix_length = 0;\n     readJSONObject(columns);\n@@ -239,7 +242,7 @@ bool JSONEachRowRowInputFormat::readRow(MutableColumns & columns, RowReadExtensi\n     auto & header = getPort().getHeader();\n     /// Fill non-visited columns with the default values.\n     for (size_t i = 0; i < num_columns; ++i)\n-        if (!read_columns[i])\n+        if (!seen_columns[i])\n             header.getByPosition(i).type->insertDefaultInto(*columns[i]);\n \n     /// return info about defaults set\ndiff --git a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h\nindex afa3c9f2ba15..3e7a38e593a7 100644\n--- a/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h\n@@ -55,7 +55,12 @@ class JSONEachRowRowInputFormat : public IRowInputFormat\n     /// the nested column names are 'n.i' and 'n.s' and the nested prefix is 'n.'\n     size_t nested_prefix_length = 0;\n \n+    /// Set of columns for which the values were read. The rest will be filled with default values.\n     std::vector<UInt8> read_columns;\n+    /// Set of columns which already met in row. Exception is thrown if there are more than one column with the same name.\n+    std::vector<UInt8> seen_columns;\n+    /// These sets may be different, because if null_as_default=1 read_columns[i] will be false and seen_columns[i] will be true\n+    /// for row like {..., \"non-nullable column name\" : null, ...}\n \n     /// Hash table match `field name -> position in the block`. NOTE You can use perfect hash map.\n     using NameMap = HashMap<StringRef, size_t, StringRefHash>;\ndiff --git a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\nindex 8cf3702d3bf9..60df642836cb 100644\n--- a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n@@ -1,6 +1,7 @@\n #include <IO/ReadHelpers.h>\n #include <Processors/Formats/Impl/TSKVRowInputFormat.h>\n #include <Formats/FormatFactory.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n \n namespace DB\n@@ -98,6 +99,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n \n     /// Set of columns for which the values were read. The rest will be filled with default values.\n     read_columns.assign(num_columns, false);\n+    seen_columns.assign(num_columns, false);\n \n     if (unlikely(*in.position() == '\\n'))\n     {\n@@ -131,12 +133,15 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n                 {\n                     index = *lookupResultGetMapped(it);\n \n-                    if (read_columns[index])\n+                    if (seen_columns[index])\n                         throw Exception(\"Duplicate field found while parsing TSKV format: \" + name_ref.toString(), ErrorCodes::INCORRECT_DATA);\n \n-                    read_columns[index] = true;\n-\n-                    header.getByPosition(index).type->deserializeAsTextEscaped(*columns[index], in, format_settings);\n+                    seen_columns[index] = read_columns[index] = true;\n+                    const auto & type = getPort().getHeader().getByPosition(index).type;\n+                    if (format_settings.null_as_default && !type->isNullable())\n+                        read_columns[index] = DataTypeNullable::deserializeTextEscaped(*columns[index], in, format_settings, type);\n+                    else\n+                        header.getByPosition(index).type->deserializeAsTextEscaped(*columns[index], in, format_settings);\n                 }\n             }\n             else\n@@ -166,7 +171,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n                 if (index >= 0)\n                 {\n                     columns[index]->popBack(1);\n-                    read_columns[index] = false;\n+                    seen_columns[index] = read_columns[index] = false;\n                 }\n \n                 throw Exception(\"Found garbage after field in TSKV format: \" + name_ref.toString(), ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n@@ -176,7 +181,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n \n     /// Fill in the not met columns with default values.\n     for (size_t i = 0; i < num_columns; ++i)\n-        if (!read_columns[i])\n+        if (!seen_columns[i])\n             header.getByPosition(i).type->insertDefaultInto(*columns[i]);\n \n     /// return info about defaults set\ndiff --git a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h\nindex 52330665395a..cd7ad69aed65 100644\n--- a/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h\n@@ -41,7 +41,12 @@ class TSKVRowInputFormat : public IRowInputFormat\n     using NameMap = HashMap<StringRef, size_t, StringRefHash>;\n     NameMap name_map;\n \n+    /// Set of columns for which the values were read. The rest will be filled with default values.\n     std::vector<UInt8> read_columns;\n+    /// Set of columns which already met in row. Exception is thrown if there are more than one column with the same name.\n+    std::vector<UInt8> seen_columns;\n+    /// These sets may be different, because if null_as_default=1 read_columns[i] will be false and seen_columns[i] will be true\n+    /// for row like ..., non-nullable column name=\\N, ...\n };\n \n }\ndiff --git a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\nindex cb9ff5b53bec..b57fc51f1834 100644\n--- a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n@@ -6,6 +6,7 @@\n #include <Formats/verbosePrintString.h>\n #include <Formats/FormatFactory.h>\n #include <DataTypes/DataTypeNothing.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n namespace DB\n {\n@@ -117,9 +118,10 @@ void TabSeparatedRowInputFormat::fillUnreadColumnsWithDefaults(MutableColumns &\n     }\n \n     for (const auto column_index : columns_to_fill_with_default_values)\n+    {\n         data_types[column_index]->insertDefaultInto(*columns[column_index]);\n-\n-    row_read_extension.read_columns = read_columns;\n+        row_read_extension.read_columns[column_index] = false;\n+    }\n }\n \n \n@@ -174,12 +176,15 @@ bool TabSeparatedRowInputFormat::readRow(MutableColumns & columns, RowReadExtens\n \n     updateDiagnosticInfo();\n \n+    ext.read_columns.assign(read_columns.size(), true);\n     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)\n     {\n         const auto & column_index = column_indexes_for_input_fields[file_column];\n+        const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();\n         if (column_index)\n         {\n-            data_types[*column_index]->deserializeAsTextEscaped(*columns[*column_index], in, format_settings);\n+            const auto & type = data_types[*column_index];\n+            ext.read_columns[*column_index] = readField(*columns[*column_index], type, is_last_file_column);\n         }\n         else\n         {\n@@ -206,6 +211,22 @@ bool TabSeparatedRowInputFormat::readRow(MutableColumns & columns, RowReadExtens\n     return true;\n }\n \n+\n+bool TabSeparatedRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column)\n+{\n+    const bool at_delimiter = !is_last_file_column && !in.eof() && *in.position() == '\\t';\n+    const bool at_last_column_line_end = is_last_file_column && (in.eof() || *in.position() == '\\n');\n+    if (format_settings.tsv.empty_as_default && (at_delimiter || at_last_column_line_end))\n+    {\n+        column.insertDefault();\n+        return false;\n+    }\n+    else if (format_settings.null_as_default && !type->isNullable())\n+        return DataTypeNullable::deserializeTextEscaped(column, in, format_settings, type);\n+    type->deserializeAsTextEscaped(column, in, format_settings);\n+    return true;\n+}\n+\n bool TabSeparatedRowInputFormat::parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out)\n {\n     for (size_t file_column = 0; file_column < column_indexes_for_input_fields.size(); ++file_column)\n@@ -303,7 +324,10 @@ void TabSeparatedRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, I\n {\n     prev_pos = in.position();\n     if (column_indexes_for_input_fields[file_column])\n-        type->deserializeAsTextEscaped(column, in, format_settings);\n+    {\n+        const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();\n+        readField(column, type, is_last_file_column);\n+    }\n     else\n     {\n         NullSink null_sink;\ndiff --git a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\nindex a28ac62ed4f2..9d3f0b52d119 100644\n--- a/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\n@@ -41,6 +41,8 @@ class TabSeparatedRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     std::vector<UInt8> read_columns;\n     std::vector<size_t> columns_to_fill_with_default_values;\n \n+    bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column);\n+\n     void addInputColumn(const String & column_name);\n     void setupAllColumnsByTableSchema();\n     void fillUnreadColumnsWithDefaults(MutableColumns & columns, RowReadExtension& ext);\ndiff --git a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\nindex f0b2238ec7ff..b77ec5417b03 100644\n--- a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n@@ -4,6 +4,7 @@\n #include <IO/Operators.h>\n #include <DataTypes/DataTypeNothing.h>\n #include <Interpreters/Context.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n namespace DB\n {\n@@ -23,7 +24,8 @@ TemplateRowInputFormat::TemplateRowInputFormat(const Block & header_, ReadBuffer\n                                                ParsedTemplateFormatString format_, ParsedTemplateFormatString row_format_)\n     : RowInputFormatWithDiagnosticInfo(header_, buf, params_), buf(in_), data_types(header_.getDataTypes()),\n       settings(settings_), ignore_spaces(ignore_spaces_),\n-      format(std::move(format_)), row_format(std::move(row_format_))\n+      format(std::move(format_)), row_format(std::move(row_format_)),\n+      default_csv_delimiter(settings.csv.delimiter)\n {\n     /// Validate format string for result set\n     bool has_data = false;\n@@ -68,6 +70,10 @@ TemplateRowInputFormat::TemplateRowInputFormat(const Block & header_, ReadBuffer\n             column_in_format[col_idx] = true;\n         }\n     }\n+\n+    for (size_t i = 0; i < header_.columns(); ++i)\n+        if (!column_in_format[i])\n+            always_default_columns.push_back(i);\n }\n \n void TemplateRowInputFormat::readPrefix()\n@@ -166,8 +172,7 @@ bool TemplateRowInputFormat::readRow(MutableColumns & columns, RowReadExtension\n         if (row_format.format_idx_to_column_idx[i])\n         {\n             size_t col_idx = *row_format.format_idx_to_column_idx[i];\n-            deserializeField(*data_types[col_idx], *columns[col_idx], row_format.formats[i]);\n-            extra.read_columns[col_idx] = true;\n+            extra.read_columns[col_idx] = deserializeField(data_types[col_idx], *columns[col_idx], i);\n         }\n         else\n             skipField(row_format.formats[i]);\n@@ -177,30 +182,47 @@ bool TemplateRowInputFormat::readRow(MutableColumns & columns, RowReadExtension\n     skipSpaces();\n     assertString(row_format.delimiters.back(), buf);\n \n-    for (size_t i = 0; i < columns.size(); ++i)\n-        if (!extra.read_columns[i])\n-            data_types[i]->insertDefaultInto(*columns[i]);\n+    for (const auto & idx : always_default_columns)\n+        data_types[idx]->insertDefaultInto(*columns[idx]);\n \n     return true;\n }\n \n-void TemplateRowInputFormat::deserializeField(const IDataType & type, IColumn & column, ColumnFormat col_format)\n+bool TemplateRowInputFormat::deserializeField(const DataTypePtr & type, IColumn & column, size_t file_column)\n {\n+    ColumnFormat col_format = row_format.formats[file_column];\n+    bool read = true;\n+    bool parse_as_nullable = settings.null_as_default && !type->isNullable();\n     try\n     {\n         switch (col_format)\n         {\n             case ColumnFormat::Escaped:\n-                type.deserializeAsTextEscaped(column, buf, settings);\n+                if (parse_as_nullable)\n+                    read = DataTypeNullable::deserializeTextEscaped(column, buf, settings, type);\n+                else\n+                    type->deserializeAsTextEscaped(column, buf, settings);\n                 break;\n             case ColumnFormat::Quoted:\n-                type.deserializeAsTextQuoted(column, buf, settings);\n+                if (parse_as_nullable)\n+                    read = DataTypeNullable::deserializeTextQuoted(column, buf, settings, type);\n+                else\n+                    type->deserializeAsTextQuoted(column, buf, settings);\n                 break;\n             case ColumnFormat::Csv:\n-                type.deserializeAsTextCSV(column, buf, settings);\n+                /// Will read unquoted string until settings.csv.delimiter\n+                settings.csv.delimiter = row_format.delimiters[file_column + 1].empty() ? default_csv_delimiter :\n+                                                                                          row_format.delimiters[file_column + 1].front();\n+                if (parse_as_nullable)\n+                    read = DataTypeNullable::deserializeTextCSV(column, buf, settings, type);\n+                else\n+                    type->deserializeAsTextCSV(column, buf, settings);\n                 break;\n             case ColumnFormat::Json:\n-                type.deserializeAsTextJSON(column, buf, settings);\n+                if (parse_as_nullable)\n+                    read = DataTypeNullable::deserializeTextJSON(column, buf, settings, type);\n+                else\n+                    type->deserializeAsTextJSON(column, buf, settings);\n                 break;\n             default:\n                 __builtin_unreachable();\n@@ -212,6 +234,7 @@ void TemplateRowInputFormat::deserializeField(const IDataType & type, IColumn &\n             throwUnexpectedEof();\n         throw;\n     }\n+    return read;\n }\n \n void TemplateRowInputFormat::skipField(TemplateRowInputFormat::ColumnFormat col_format)\n@@ -391,7 +414,7 @@ void TemplateRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColu\n {\n     prev_pos = buf.position();\n     if (row_format.format_idx_to_column_idx[file_column])\n-        deserializeField(*type, column, row_format.formats[file_column]);\n+        deserializeField(type, column, file_column);\n     else\n         skipField(row_format.formats[file_column]);\n     curr_pos = buf.position();\ndiff --git a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h\nindex 2142d4929881..7b62347c37d8 100644\n--- a/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h\n@@ -29,7 +29,7 @@ class TemplateRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     void syncAfterError() override;\n \n private:\n-    void deserializeField(const IDataType & type, IColumn & column, ColumnFormat col_format);\n+    bool deserializeField(const DataTypePtr & type, IColumn & column, size_t file_column);\n     void skipField(ColumnFormat col_format);\n     inline void skipSpaces() { if (ignore_spaces) skipWhitespaceIfAny(buf); }\n \n@@ -50,13 +50,15 @@ class TemplateRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     PeekableReadBuffer buf;\n     DataTypes data_types;\n \n-    const FormatSettings settings;\n+    FormatSettings settings;\n     const bool ignore_spaces;\n     ParsedTemplateFormatString format;\n     ParsedTemplateFormatString row_format;\n \n     size_t format_data_idx;\n     bool end_of_stream = false;\n+    std::vector<size_t> always_default_columns;\n+    char default_csv_delimiter;\n };\n \n }\ndiff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex 5c5bca9f9628..05bde62d9023 100644\n--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -11,6 +11,7 @@\n #include <Common/typeid_cast.h>\n #include <common/find_symbols.h>\n #include <Parsers/ASTLiteral.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n \n namespace DB\n@@ -47,6 +48,7 @@ Chunk ValuesBlockInputFormat::generate()\n {\n     const Block & header = getPort().getHeader();\n     MutableColumns columns = header.cloneEmptyColumns();\n+    block_missing_values.clear();\n \n     for (size_t rows_in_block = 0; rows_in_block < params.max_block_size; ++rows_in_block)\n     {\n@@ -55,7 +57,7 @@ Chunk ValuesBlockInputFormat::generate()\n             skipWhitespaceIfAny(buf);\n             if (buf.eof() || *buf.position() == ';')\n                 break;\n-            readRow(columns);\n+            readRow(columns, rows_in_block);\n             if (params.callback)\n                 params.callback();\n         }\n@@ -73,10 +75,10 @@ Chunk ValuesBlockInputFormat::generate()\n         if (!templates[i] || !templates[i]->rowsCount())\n             continue;\n         if (columns[i]->empty())\n-            columns[i] = std::move(*templates[i]->evaluateAll()).mutate();\n+            columns[i] = std::move(*templates[i]->evaluateAll(block_missing_values, i)).mutate();\n         else\n         {\n-            ColumnPtr evaluated = templates[i]->evaluateAll();\n+            ColumnPtr evaluated = templates[i]->evaluateAll(block_missing_values, i, columns[i]->size());\n             columns[i]->insertRangeFrom(*evaluated, 0, evaluated->size());\n         }\n     }\n@@ -91,7 +93,7 @@ Chunk ValuesBlockInputFormat::generate()\n     return Chunk{std::move(columns), rows_in_block};\n }\n \n-void ValuesBlockInputFormat::readRow(MutableColumns & columns)\n+void ValuesBlockInputFormat::readRow(MutableColumns & columns, size_t row_num)\n {\n     assertChar('(', buf);\n \n@@ -99,17 +101,22 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns)\n     {\n         skipWhitespaceIfAny(buf);\n         PeekableReadBufferCheckpoint checkpoint{buf};\n+        bool read;\n \n         /// Parse value using fast streaming parser for literals and slow SQL parser for expressions.\n         /// If there is SQL expression in some row, template of this expression will be deduced,\n         /// so it makes possible to parse the following rows much faster\n         /// if expressions in the following rows have the same structure\n         if (parser_type_for_column[column_idx] == ParserType::Streaming)\n-            tryReadValue(*columns[column_idx], column_idx);\n+            read = tryReadValue(*columns[column_idx], column_idx);\n         else if (parser_type_for_column[column_idx] == ParserType::BatchTemplate)\n-            tryParseExpressionUsingTemplate(columns[column_idx], column_idx);\n+            read = tryParseExpressionUsingTemplate(columns[column_idx], column_idx);\n         else /// if (parser_type_for_column[column_idx] == ParserType::SingleExpressionEvaluation)\n-            parseExpression(*columns[column_idx], column_idx);\n+            read = parseExpression(*columns[column_idx], column_idx);\n+\n+        if (!read)\n+            block_missing_values.setBit(column_idx, row_num);\n+        /// If read is true, value still may be missing. Bit mask for these values will be copied from ConstantExpressionTemplate later.\n     }\n \n     skipWhitespaceIfAny(buf);\n@@ -119,22 +126,22 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns)\n     ++total_rows;\n }\n \n-void ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)\n+bool ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)\n {\n     /// Try to parse expression using template if one was successfully deduced while parsing the first row\n     if (templates[column_idx]->parseExpression(buf, format_settings))\n     {\n         ++rows_parsed_using_template[column_idx];\n-        return;\n+        return true;\n     }\n \n     /// Expression in the current row is not match template deduced on the first row.\n     /// Evaluate expressions, which were parsed using this template.\n     if (column->empty())\n-        column = std::move(*templates[column_idx]->evaluateAll()).mutate();\n+        column = std::move(*templates[column_idx]->evaluateAll(block_missing_values, column_idx)).mutate();\n     else\n     {\n-        ColumnPtr evaluated = templates[column_idx]->evaluateAll();\n+        ColumnPtr evaluated = templates[column_idx]->evaluateAll(block_missing_values, column_idx, column->size());\n         column->insertRangeFrom(*evaluated, 0, evaluated->size());\n     }\n     /// Do not use this template anymore\n@@ -142,19 +149,25 @@ void ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr &\n     buf.rollbackToCheckpoint();\n \n     /// It will deduce new template or fallback to slow SQL parser\n-    parseExpression(*column, column_idx);\n+    return parseExpression(*column, column_idx);\n }\n \n-void ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)\n+bool ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)\n {\n     bool rollback_on_exception = false;\n     try\n     {\n-        types[column_idx]->deserializeAsTextQuoted(column, buf, format_settings);\n+        bool read = true;\n+        const auto & type = types[column_idx];\n+        if (format_settings.null_as_default && !type->isNullable())\n+            read = DataTypeNullable::deserializeTextQuoted(column, buf, format_settings, type);\n+        else\n+            type->deserializeAsTextQuoted(column, buf, format_settings);\n         rollback_on_exception = true;\n \n         skipWhitespaceIfAny(buf);\n         assertDelimiterAfterValue(column_idx);\n+        return read;\n     }\n     catch (const Exception & e)\n     {\n@@ -166,12 +179,11 @@ void ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)\n         /// Switch to SQL parser and don't try to use streaming parser for complex expressions\n         /// Note: Throwing exceptions for each expression may be very slow because of stacktraces\n         buf.rollbackToCheckpoint();\n-        parseExpression(column, column_idx);\n+        return parseExpression(column, column_idx);\n     }\n }\n \n-void\n-ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n+bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n {\n     const Block & header = getPort().getHeader();\n     const IDataType & type = *header.getByPosition(column_idx).type;\n@@ -223,7 +235,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n         if (ok)\n         {\n             parser_type_for_column[column_idx] = ParserType::Streaming;\n-            return;\n+            return true;\n         }\n         else if (rollback_on_exception)\n             column.popBack(1);\n@@ -243,7 +255,8 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n             bool found_in_cache = false;\n             const auto & result_type = header.getByPosition(column_idx).type;\n             const char * delimiter = (column_idx + 1 == num_columns) ? \")\" : \",\";\n-            auto structure = templates_cache.getFromCacheOrConstruct(result_type, TokenIterator(tokens), token_iterator,\n+            auto structure = templates_cache.getFromCacheOrConstruct(result_type, format_settings.null_as_default,\n+                                                                     TokenIterator(tokens), token_iterator,\n                                                                      ast, *context, &found_in_cache, delimiter);\n             templates[column_idx].emplace(structure);\n             if (found_in_cache)\n@@ -256,7 +269,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n             {\n                 ++rows_parsed_using_template[column_idx];\n                 parser_type_for_column[column_idx] = ParserType::BatchTemplate;\n-                return;\n+                return true;\n             }\n         }\n         catch (...)\n@@ -290,6 +303,11 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n     /// Check that we are indeed allowed to insert a NULL.\n     if (value.isNull() && !type.isNullable())\n     {\n+        if (format_settings.null_as_default)\n+        {\n+            type.insertDefaultInto(column);\n+            return false;\n+        }\n         buf.rollbackToCheckpoint();\n         throw Exception{\"Cannot insert NULL value into a column of type '\" + type.getName() + \"'\"\n                         + \" at: \" +\n@@ -298,6 +316,7 @@ ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx)\n     }\n \n     column.insert(value);\n+    return true;\n }\n \n /// Can be used in fileSegmentationEngine for parallel parsing of Values\ndiff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h\nindex ec6a3b931e49..cf2c4efb1cf8 100644\n--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h\n+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h\n@@ -33,6 +33,8 @@ class ValuesBlockInputFormat : public IInputFormat\n \n     String getName() const override { return \"ValuesBlockInputFormat\"; }\n \n+    const BlockMissingValues & getMissingValues() const override { return block_missing_values; }\n+\n private:\n     enum class ParserType\n     {\n@@ -45,11 +47,11 @@ class ValuesBlockInputFormat : public IInputFormat\n \n     Chunk generate() override;\n \n-    void readRow(MutableColumns & columns);\n+    void readRow(MutableColumns & columns, size_t row_num);\n \n-    void tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx);\n-    ALWAYS_INLINE inline void tryReadValue(IColumn & column, size_t column_idx);\n-    void parseExpression(IColumn & column, size_t column_idx);\n+    bool tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx);\n+    ALWAYS_INLINE inline bool tryReadValue(IColumn & column, size_t column_idx);\n+    bool parseExpression(IColumn & column, size_t column_idx);\n \n     ALWAYS_INLINE inline void assertDelimiterAfterValue(size_t column_idx);\n     ALWAYS_INLINE inline bool checkDelimiterAfterValue(size_t column_idx);\n@@ -81,6 +83,8 @@ class ValuesBlockInputFormat : public IInputFormat\n     ConstantExpressionTemplate::Cache templates_cache;\n \n     DataTypes types;\n+\n+    BlockMissingValues block_missing_values;\n };\n \n }\ndiff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex 100dbe6b68af..eebdf10702de 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -983,3 +983,11 @@ should be located in the directory specified in [format_schema_path](../operatio\n in the server configuration.\n \n [Original article](https://clickhouse.yandex/docs/en/interfaces/formats/) <!--hide-->\n+\n+## Skipping Errors {#skippingerrors}\n+\n+Some formats such as `CSV`, `TabSeparated`, `TSKV`, `JSONEachRow`, `Template`, `CustomSeparated` and `Protobuf` can skip broken row if parsing error occurred and continue parsing from the beginning of next row. See [input_format_allow_errors_num](../operations/settings/settings.md#settings-input_format_allow_errors_num) and \n+[input_format_allow_errors_ratio](../operations/settings/settings.md#settings-input_format_allow_errors_ratio) settings.\n+Limitations:\n+ - In case of parsing error `JSONEachRow` skips all data until the new line (or EOF), so rows must be delimited by `\\n` to count errors correctly.\n+ - `Template` and `CustomSeparated` use delimiter after the last column and delimiter between rows to find the beginning of next row, so skipping errors works only if at least one of them is not empty.\ndiff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 3f94d8e45c53..ef1b664272e0 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -130,30 +130,30 @@ Possible values:\n \n Default value: 0.\n \n-## input_format_allow_errors_num\n+## input_format_allow_errors_num {#settings-input_format_allow_errors_num}\n \n Sets the maximum number of acceptable errors when reading from text formats (CSV, TSV, etc.).\n \n The default value is 0.\n \n-Always pair it with `input_format_allow_errors_ratio`. To skip errors, both settings must be greater than 0.\n+Always pair it with `input_format_allow_errors_ratio`.\n \n If an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_num`, ClickHouse ignores the row and moves on to the next one.\n \n-If `input_format_allow_errors_num` is exceeded, ClickHouse throws an exception.\n+If both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception.\n \n-## input_format_allow_errors_ratio\n+## input_format_allow_errors_ratio {#settings-input_format_allow_errors_ratio}\n \n Sets the maximum percentage of errors allowed when reading from text formats (CSV, TSV, etc.).\n The percentage of errors is set as a floating-point number between 0 and 1.\n \n The default value is 0.\n \n-Always pair it with `input_format_allow_errors_num`. To skip errors, both settings must be greater than 0.\n+Always pair it with `input_format_allow_errors_num`.\n \n If an error occurred while reading rows but the error counter is still less than `input_format_allow_errors_ratio`, ClickHouse ignores the row and moves on to the next one.\n \n-If `input_format_allow_errors_ratio` is exceeded, ClickHouse throws an exception.\n+If both `input_format_allow_errors_num` and `input_format_allow_errors_ratio` are exceeded, ClickHouse throws an exception.\n \n \n ## input_format_values_interpret_expressions {#settings-input_format_values_interpret_expressions}\n@@ -227,7 +227,7 @@ Enabled by default.\n \n ## input_format_defaults_for_omitted_fields {#session_settings-input_format_defaults_for_omitted_fields}\n \n-When performing `INSERT` queries, replace omitted input column values with default values of the respective columns. This option only applies to [JSONEachRow](../../interfaces/formats.md#jsoneachrow) and [CSV](../../interfaces/formats.md#csv) formats.\n+When performing `INSERT` queries, replace omitted input column values with default values of the respective columns. This option only applies to [JSONEachRow](../../interfaces/formats.md#jsoneachrow), [CSV](../../interfaces/formats.md#csv) and [TabSeparated](../../interfaces/formats.md#tabseparated) formats.\n \n !!! note \"Note\"\n     When this option is enabled, extended table metadata are sent from server to client. It consumes additional computing resources on the server and can reduce performance.\n@@ -239,9 +239,15 @@ Possible values:\n \n Default value: 1.\n \n+## input_format_tsv_empty_as_default {#settings-input_format_tsv_empty_as_default}\n+\n+When enabled, replace empty input fields in TSV with default values. For complex default expressions `input_format_defaults_for_omitted_fields` must be enabled too.\n+\n+Disabled by default.\n+\n ## input_format_null_as_default {#settings-input_format_null_as_default}\n \n-Enables or disables using default values if input data contain `NULL`, but data type of corresponding column in not `Nullable(T)` (for CSV format).\n+Enables or disables using default values if input data contain `NULL`, but data type of corresponding column in not `Nullable(T)` (for text input formats).\n \n \n ## input_format_skip_unknown_fields {#settings-input_format_skip_unknown_fields}\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex 13d14389fc44..90803a7d27ea 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -207,6 +207,7 @@ Ok.\n \n - [JSONEachRow](../../interfaces/formats.md#jsoneachrow)\n - [CSV](../../interfaces/formats.md#csv)\n+- [TabSeparated](../../interfaces/formats.md#tabseparated)\n \n !!! note \"\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435\"\n     \u041a\u043e\u0433\u0434\u0430 \u043e\u043f\u0446\u0438\u044f \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0430, \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0435 \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435. \u042d\u0442\u043e \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435 \u0438 \u043c\u043e\u0436\u0435\u0442 \u0441\u043d\u0438\u0437\u0438\u0442\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c.\n@@ -220,7 +221,7 @@ Ok.\n \n ## input_format_null_as_default {#settings-input_format_null_as_default}\n \n-\u0412\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u044f\u0445, \u043a\u043e\u0433\u0434\u0430 \u0432\u043e \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f `NULL`, \u043d\u043e \u0442\u0438\u043f \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u043d\u0435 `Nullable(T)` (\u0434\u043b\u044f \u0444\u043e\u0440\u043c\u0430\u0442\u0430 CSV).\n+\u0412\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u044f\u0445, \u043a\u043e\u0433\u0434\u0430 \u0432\u043e \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f `NULL`, \u043d\u043e \u0442\u0438\u043f \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u043d\u0435 `Nullable(T)` (\u0434\u043b\u044f \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0445 \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u0432).\n \n ## input_format_skip_unknown_fields {#settings-input_format_skip_unknown_fields}\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00301_csv.reference b/dbms/tests/queries/0_stateless/00301_csv.reference\nindex 92cb50c0727b..a9351f91f703 100644\n--- a/dbms/tests/queries/0_stateless/00301_csv.reference\n+++ b/dbms/tests/queries/0_stateless/00301_csv.reference\n@@ -4,10 +4,6 @@ Hello \"world\"\t789\t2016-01-03\n Hello\\n world\t100\t2016-01-04\n default\t1\t2019-06-19\n default-eof\t1\t2019-06-19\n-0\t1\t42\t2019-07-22\n-1\tworld\t3\t2019-07-23\n-2\tHello\t123\t2019-06-19\n-3\tHello\t42\t2019-06-19\n 2016-01-01 01:02:03\t1\n 2016-01-02 01:02:03\t2\n 2017-08-15 13:15:01\t3\ndiff --git a/dbms/tests/queries/0_stateless/00301_csv.sh b/dbms/tests/queries/0_stateless/00301_csv.sh\nindex c1bb6710c1f7..cb0167b4e99c 100755\n--- a/dbms/tests/queries/0_stateless/00301_csv.sh\n+++ b/dbms/tests/queries/0_stateless/00301_csv.sh\n@@ -17,17 +17,6 @@ Hello \"world\", 789 ,2016-01-03\n $CLICKHOUSE_CLIENT --query=\"SELECT * FROM csv ORDER BY d\";\n $CLICKHOUSE_CLIENT --query=\"DROP TABLE csv\";\n \n-\n-$CLICKHOUSE_CLIENT --query=\"CREATE TABLE csv (i Int8, s String DEFAULT 'Hello', n UInt64 DEFAULT 42, d Date DEFAULT '2019-06-19') ENGINE = Memory\";\n-echo '\\N, 1, \\N, \"2019-07-22\"\n-1, world, 3, \"2019-07-23\"\n-2, \\N, 123, \\N\n-3, \\N, \\N, \\N' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --query=\"INSERT INTO csv FORMAT CSV\";\n-\n-$CLICKHOUSE_CLIENT --query=\"SELECT * FROM csv ORDER BY i\";\n-$CLICKHOUSE_CLIENT --query=\"DROP TABLE csv\";\n-\n-\n $CLICKHOUSE_CLIENT --query=\"CREATE TABLE csv (t DateTime('Europe/Moscow'), s String) ENGINE = Memory\";\n \n echo '\"2016-01-01 01:02:03\",\"1\"\ndiff --git a/dbms/tests/queries/0_stateless/00937_template_output_format.sh b/dbms/tests/queries/0_stateless/00937_template_output_format.sh\nindex 239f7d672d01..0b0cba4e2bd8 100755\n--- a/dbms/tests/queries/0_stateless/00937_template_output_format.sh\n+++ b/dbms/tests/queries/0_stateless/00937_template_output_format.sh\n@@ -20,3 +20,4 @@ format_template_row = '$CURDIR/00937_template_output_format_row.tmp', \\\n format_template_rows_between_delimiter = ';\\n'\";\n \n $CLICKHOUSE_CLIENT --query=\"DROP TABLE template\";\n+rm $CURDIR/00937_template_output_format_resultset.tmp $CURDIR/00937_template_output_format_row.tmp\ndiff --git a/dbms/tests/queries/0_stateless/00938_template_input_format.sh b/dbms/tests/queries/0_stateless/00938_template_input_format.sh\nindex 998fe195203e..ca314db13de6 100755\n--- a/dbms/tests/queries/0_stateless/00938_template_input_format.sh\n+++ b/dbms/tests/queries/0_stateless/00938_template_input_format.sh\n@@ -50,3 +50,4 @@ $CLICKHOUSE_CLIENT --query=\"SELECT * FROM template2 ORDER BY n FORMAT CSV\";\n \n $CLICKHOUSE_CLIENT --query=\"DROP TABLE template1\";\n $CLICKHOUSE_CLIENT --query=\"DROP TABLE template2\";\n+rm $CURDIR/00938_template_input_format_resultset.tmp $CURDIR/00938_template_input_format_row.tmp\ndiff --git a/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.reference b/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.reference\nindex e98738050e57..c887e5feb5f0 100644\n--- a/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.reference\n+++ b/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.reference\n@@ -2,3 +2,4 @@\n 1\tworldparam\t[0.2,0.3]\n 2\ttestparam\t[0.3]\n 3\tparamparam\t[]\n+4\tevaluateparam\t[0.2]\ndiff --git a/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.sh b/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.sh\nindex 2fd06535ebe8..8edda6629b05 100755\n--- a/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.sh\n+++ b/dbms/tests/queries/0_stateless/01015_insert_values_parametrized.sh\n@@ -6,12 +6,15 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n $CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS insert_values_parametrized\";\n $CLICKHOUSE_CLIENT --query=\"CREATE TABLE insert_values_parametrized (n UInt8, s String, a Array(Float32)) ENGINE = Memory\";\n \n-$CLICKHOUSE_CLIENT --input_format_values_deduce_templates_of_expressions=1 --param_p_n=\"-1\" --param_p_s=\"param\" --param_p_a=\"[0.2,0.3]\" --query=\"INSERT INTO insert_values_parametrized  VALUES\n+$CLICKHOUSE_CLIENT --input_format_values_deduce_templates_of_expressions=1 --input_format_values_interpret_expressions=0 --param_p_n=\"-1\" --param_p_s=\"param\" --param_p_a=\"[0.2,0.3]\" --query=\"INSERT INTO insert_values_parametrized  VALUES\n (1 + {p_n:Int8}, lower(concat('Hello', {p_s:String})), arraySort(arrayIntersect([],            {p_a:Array(Nullable(Float32))}))),\\\n (2 + {p_n:Int8}, lower(concat('world', {p_s:String})), arraySort(arrayIntersect([0.1,0.2,0.3], {p_a:Array(Nullable(Float32))}))),\\\n (3 + {p_n:Int8}, lower(concat('TEST',  {p_s:String})), arraySort(arrayIntersect([0.1,0.3,0.4], {p_a:Array(Nullable(Float32))}))),\\\n (4 + {p_n:Int8}, lower(concat('PaRaM', {p_s:String})), arraySort(arrayIntersect([0.5],         {p_a:Array(Nullable(Float32))})))\";\n \n+$CLICKHOUSE_CLIENT --input_format_values_deduce_templates_of_expressions=0 --input_format_values_interpret_expressions=1 --param_p_n=\"-1\" --param_p_s=\"param\" --param_p_a=\"[0.2,0.3]\" --query=\"INSERT INTO insert_values_parametrized  VALUES \\\n+(5 + {p_n:Int8}, lower(concat('Evaluate', {p_s:String})), arrayIntersect([0, 0.2, 0.6], {p_a:Array(Nullable(Float32))}))\"\n+\n $CLICKHOUSE_CLIENT --query=\"SELECT * FROM insert_values_parametrized ORDER BY n\";\n \n $CLICKHOUSE_CLIENT --query=\"DROP TABLE insert_values_parametrized\";\ndiff --git a/dbms/tests/queries/0_stateless/01016_input_null_as_default.reference b/dbms/tests/queries/0_stateless/01016_input_null_as_default.reference\nnew file mode 100644\nindex 000000000000..ba9657bf16e0\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01016_input_null_as_default.reference\n@@ -0,0 +1,30 @@\n+CSV\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\n+TSV\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\n+TSKV\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\n+JSONEachRow\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\n+Template (Quoted)\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\n+Values\n+0\t1\t42\t2019-07-22\t[10,20,30]\t('default',0)\n+1\tworld\t3\t2019-07-23\t[1,2,3]\t('tuple',3.14)\n+2\tHello\t123\t2019-06-19\t[]\t('test',2.71828)\n+3\tHello\t42\t2019-06-19\t[1,2,3]\t('default',0.75)\ndiff --git a/dbms/tests/queries/0_stateless/01016_input_null_as_default.sh b/dbms/tests/queries/0_stateless/01016_input_null_as_default.sh\nnew file mode 100755\nindex 000000000000..f7fdefc26df8\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01016_input_null_as_default.sh\n@@ -0,0 +1,55 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS null_as_default\";\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE null_as_default (i Int8, s String DEFAULT 'Hello', n UInt64 DEFAULT 42, d Date DEFAULT '2019-06-19', a Array(UInt8) DEFAULT [1, 2, 3], t Tuple(String, Float64) DEFAULT ('default', i / 4)) ENGINE = Memory\";\n+\n+echo 'CSV'\n+echo '\\N, 1, \\N, \"2019-07-22\", \"[10, 20, 30]\", \\N\n+1, world, 3, \"2019-07-23\", \\N, tuple, 3.14\n+2, \\N, 123, \\N, \"[]\", test, 2.71828\n+3, \\N, \\N, \\N, \\N, \\N' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --query=\"INSERT INTO null_as_default FORMAT CSV\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"TRUNCATE TABLE null_as_default\";\n+\n+echo 'TSV'\n+echo -e '\\N\\t1\\t\\N\\t2019-07-22\\t[10, 20, 30]\\t\\N\n+1\\tworld\\t3\\t2019-07-23\\t\\N\\t('\\''tuple'\\'', 3.14)\n+2\\t\\N\\t123\\t\\N\\t[]\\t('\\''test'\\'', 2.71828)\n+3\\t\\N\\t\\N\\t\\N\\t\\N\\t\\N' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --query=\"INSERT INTO null_as_default FORMAT TSV\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"TRUNCATE TABLE null_as_default\";\n+\n+echo 'TSKV'\n+echo -e 'i=\\N\\ts=1\\tn=\\N\\td=2019-07-22\\ta=[10, 20, 30]\\tt=\\N\n+i=1\\ts=world\\tn=3\\td=2019-07-23\\ta=\\N\\tt=('\\''tuple'\\'', 3.14)\n+i=2\\ts=\\N\\tn=123\\td=\\N\\ta=[]\\tt=('\\''test'\\'', 2.71828)\n+i=3\\ts=\\N\\tn=\\N\\td=\\N\\ta=\\N\\tt=\\N' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --query=\"INSERT INTO null_as_default FORMAT TSKV\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"TRUNCATE TABLE null_as_default\";\n+\n+echo 'JSONEachRow'\n+echo '{\"i\": null, \"s\": \"1\", \"n\": null, \"d\": \"2019-07-22\", \"a\": [10, 20, 30], \"t\": null}\n+{\"i\": 1, \"s\": \"world\", \"n\": 3, \"d\": \"2019-07-23\", \"a\": null, \"t\": [\"tuple\", 3.14]}\n+{\"i\": 2, \"s\": null, \"n\": 123, \"d\": null, \"a\": [], \"t\": [\"test\", 2.71828]}\n+{\"i\": 3, \"s\": null, \"n\": null, \"d\": null, \"a\": null, \"t\": null}' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --query=\"INSERT INTO null_as_default FORMAT JSONEachRow\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"TRUNCATE TABLE null_as_default\";\n+\n+echo 'Template (Quoted)'\n+echo 'NULL, '\\''1'\\'', null, '\\''2019-07-22'\\'', [10, 20, 30], NuLl\n+1, '\\''world'\\'', 3, '\\''2019-07-23'\\'', NULL, ('\\''tuple'\\'', 3.14)\n+2, null, 123, null, [], ('\\''test'\\'', 2.71828)\n+3, null, null, null, null, null' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --format_custom_escaping_rule=Quoted --format_custom_field_delimiter=', ' --query=\"INSERT INTO null_as_default FORMAT CustomSeparated\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"TRUNCATE TABLE null_as_default\";\n+\n+echo 'Values'\n+echo '(NULL, '\\''1'\\'', (null), '\\''2019-07-22'\\'', ([10, 20, 30]), (NuLl)),\n+(1, '\\''world'\\'', (3), '\\''2019-07-23'\\'', (NULL), (('\\''tuple'\\'', 3.14))),\n+(2, null, (123), null, ([]), (('\\''test'\\'', 2.71828))),\n+(3, null, (null), null, (null), (null))' | $CLICKHOUSE_CLIENT --input_format_null_as_default=1 --input_format_values_deduce_templates_of_expressions=1 --query=\"INSERT INTO null_as_default VALUES\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM null_as_default ORDER BY i\";\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE null_as_default\";\ndiff --git a/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.reference b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.reference\nnew file mode 100644\nindex 000000000000..feca2ec64849\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.reference\n@@ -0,0 +1,4 @@\n+\t1\t2019-06-19\n+abcd\t100\t2016-01-01\n+default\t1\t2019-06-19\n+default-eof\t1\t2019-06-19\ndiff --git a/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.sh b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.sh\nnew file mode 100755\nindex 000000000000..cdaa5016d3e6\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.sh\n@@ -0,0 +1,14 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS empty_as_default\";\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE empty_as_default (s String, n UInt64 DEFAULT 1, d Date DEFAULT '2019-06-19') ENGINE = Memory\";\n+\n+echo -ne 'abcd\\t100\\t2016-01-01\n+default\\t\\t\n+\\t\\t\n+default-eof\\t\\t' | $CLICKHOUSE_CLIENT --input_format_defaults_for_omitted_fields=1 --input_format_tsv_empty_as_default=1 --query=\"INSERT INTO empty_as_default FORMAT TSV\";\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM empty_as_default ORDER BY s\";\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE empty_as_default\";\ndiff --git a/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.reference b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.reference\nnew file mode 100644\nindex 000000000000..d598f5d498a8\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.reference\n@@ -0,0 +1,2 @@\n+1\thello\n+2\tworld\ndiff --git a/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.sh b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.sh\nnew file mode 100755\nindex 000000000000..c6931fd68ee1\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.sh\n@@ -0,0 +1,10 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS defaults\"\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE defaults (n UInt8, s String DEFAULT 'hello') ENGINE = Memory\"\n+echo '{\"n\": 1} {\"n\": 2, \"s\":\"world\"}' | $CLICKHOUSE_CLIENT --max_insert_block_size=1 --query=\"INSERT INTO defaults FORMAT JSONEachRow\"\n+$CLICKHOUSE_CLIENT --query=\"SELECT * FROM defaults ORDER BY n\"\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE defaults\"\n",
  "problem_statement": "input_format_null_as_default setting.\nWhen this setting enabled, we will parse non-Nullable columns with Nullable data type and treat parsed NULL values as defaults.\n",
  "hints_text": "",
  "created_at": "2019-10-07T19:01:14Z",
  "modified_files": [
    "dbms/src/Core/Settings.h",
    "dbms/src/DataTypes/DataTypeNullable.cpp",
    "dbms/src/DataTypes/DataTypeNullable.h",
    "dbms/src/Formats/FormatFactory.cpp",
    "dbms/src/Formats/FormatSettings.h",
    "dbms/src/Interpreters/evaluateConstantExpression.cpp",
    "dbms/src/Processors/Formats/IRowInputFormat.cpp",
    "dbms/src/Processors/Formats/IRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/CSVRowInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/CSVRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp",
    "dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h",
    "dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/TSKVRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/TemplateRowInputFormat.h",
    "dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp",
    "dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.h",
    "docs/en/interfaces/formats.md",
    "docs/en/operations/settings/settings.md",
    "docs/ru/operations/settings/settings.md"
  ],
  "modified_test_files": [
    "dbms/tests/queries/0_stateless/00301_csv.reference",
    "dbms/tests/queries/0_stateless/00301_csv.sh",
    "dbms/tests/queries/0_stateless/00937_template_output_format.sh",
    "dbms/tests/queries/0_stateless/00938_template_input_format.sh",
    "dbms/tests/queries/0_stateless/01015_insert_values_parametrized.reference",
    "dbms/tests/queries/0_stateless/01015_insert_values_parametrized.sh",
    "b/dbms/tests/queries/0_stateless/01016_input_null_as_default.reference",
    "b/dbms/tests/queries/0_stateless/01016_input_null_as_default.sh",
    "b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.reference",
    "b/dbms/tests/queries/0_stateless/01017_tsv_empty_as_default.sh",
    "b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.reference",
    "b/dbms/tests/queries/0_stateless/01018_insert_multiple_blocks_with_defaults.sh"
  ]
}