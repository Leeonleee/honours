{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 83399,
  "instance_id": "ClickHouse__ClickHouse-83399",
  "issue_numbers": [
    "82621"
  ],
  "base_commit": "de5f157efb2aa44891c2cc988bd21b5b9023b239",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 0dbf176d7487..ab9547218557 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -6247,7 +6247,7 @@ reinterpret(x, type)\n **Arguments**\n \n - `x` \u2014 Any type.\n-- `type` \u2014 Destination type. [String](../data-types/string.md).\n+- `type` \u2014 Destination type. If it is an array, then the array element type must be a fixed length type.\n \n **Returned value**\n \n@@ -6270,6 +6270,19 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+Query:\n+```sql\n+SELECT reinterpret(x'3108b4403108d4403108b4403108d440', 'Array(Float32)') AS string_to_array_of_Float32;\n+```\n+\n+Result:\n+\n+```text\n+\u250c\u2500string_to_array_of_Float32\u2500\u2510\n+\u2502 [5.626,6.626,5.626,6.626]  \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## CAST {#cast}\n \n Converts an input value to the specified data type. Unlike the [reinterpret](#reinterpret) function, `CAST` tries to present the same value using the new data type. If the conversion can not be done then an exception is raised.\ndiff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp\nindex 2667f382a495..855b98f2abe2 100644\n--- a/src/Functions/reinterpretAs.cpp\n+++ b/src/Functions/reinterpretAs.cpp\n@@ -9,15 +9,16 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnVector.h>\n+#include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeFixedString.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeUUID.h>\n-#include <DataTypes/DataTypesDecimal.h>\n-#include <DataTypes/DataTypesNumber.h>\n \n #include <Common/transformEndianness.h>\n #include <Common/memcpySmall.h>\n@@ -103,6 +104,20 @@ class FunctionReinterpret : public IFunction\n                     from_type->getName(),\n                     to_type->getName());\n         }\n+        else if (result_reinterpret_type.isArray())\n+        {\n+            WhichDataType from_data_type(from_type);\n+            if (!from_data_type.isStringOrFixedString())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Cannot reinterpret {} as {} because only String or FixedString can be reinterpreted as array\",\n+                    from_type->getName(),\n+                    to_type->getName());\n+            if (!to_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Cannot reinterpret {} as {} because the array element type is not fixed length\",\n+                    from_type->getName(),\n+                    to_type->getName());\n+        }\n         else\n         {\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n@@ -275,10 +290,41 @@ class FunctionReinterpret : public IFunction\n             return false;\n         }))\n         {\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Cannot reinterpret {} as {}\",\n-                from_type->getName(),\n-                result_type->getName());\n+            /// Destination could be array, source has to be String/FixedString\n+            /// Above lambda block of callOnTwoTypeIndexes() only for scalar result type specializations.\n+            /// All Array(T) result types are handled with a single code block below using insertData().\n+            if (WhichDataType(result_type).isArray())\n+            {\n+                auto inner_type = typeid_cast<const DataTypeArray &>(*result_type).getNestedType();\n+                const IColumn * col_from = nullptr;\n+\n+                if (WhichDataType(from_type).isString())\n+                    col_from = &assert_cast<const ColumnString &>(*arguments[0].column);\n+                else if (WhichDataType(from_type).isFixedString())\n+                    col_from = &assert_cast<const ColumnFixedString &>(*arguments[0].column);\n+                else\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Cannot reinterpret {} as {}, expected String or FixedString as source\",\n+                        from_type->getName(),\n+                        result_type->getName());\n+\n+                auto col_res = ColumnArray::create(inner_type->createColumn());\n+\n+                for (size_t i = 0; i < input_rows_count; ++i)\n+                {\n+                    StringRef ref = col_from->getDataAt(i);\n+                    col_res->insertData(ref.data, ref.size);\n+                }\n+\n+                result = std::move(col_res);\n+            }\n+            else\n+            {\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Cannot reinterpret {} as {}\",\n+                    from_type->getName(),\n+                    result_type->getName());\n+            }\n         }\n \n         return result;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03547_reinterpret_to_array.reference b/tests/queries/0_stateless/03547_reinterpret_to_array.reference\nnew file mode 100644\nindex 000000000000..661f5209dec0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03547_reinterpret_to_array.reference\n@@ -0,0 +1,27 @@\n+Verify correct destination type is instantiated\n+Array(Int32)\n+Array(UInt32)\n+Array(Float32)\n+Array(Int64)\n+Array(UInt64)\n+Array(Float64)\n+Array(FixedString(4))\n+Array(Decimal(10, 0))\n+Array(Decimal(18, 4))\n+Unsupported destination type\n+Verify few output values are correct\n+16843009\n+[16843009]\n+[16843009,33686018]\n+5.626\n+6.626\n+[5.626,6.626,5.626,6.626]\n+[5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626,5.626,6.626]\n+40\n+['abab']\n+1\n+Input data of wrong length should throw error\n+Wrong source type should throw error\n+Couple of tests with FixedString input\n+[5.626,6.626]\n+[6.626,5.626]\ndiff --git a/tests/queries/0_stateless/03547_reinterpret_to_array.sql b/tests/queries/0_stateless/03547_reinterpret_to_array.sql\nnew file mode 100644\nindex 000000000000..347e91a2b89d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03547_reinterpret_to_array.sql\n@@ -0,0 +1,49 @@\n+-- Tests for reinterpret(<source string>, <array_of_fixed_type>)\n+\n+SELECT 'Verify correct destination type is instantiated';\n+SELECT toTypeName(reinterpret(x'01010101', 'Array(Int32)'));\n+SELECT toTypeName(reinterpret(x'01010101', 'Array(UInt32)'));\n+SELECT toTypeName(reinterpret(x'01010101', 'Array(Float32)'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(Int64)'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(UInt64)'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(Float64)'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(FixedString(4))'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(Decimal)'));\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(Decimal64(4))'));\n+\n+SELECT 'Unsupported destination type';\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(String)')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toTypeName(reinterpret(x'0101010101010101', 'Array(Array(Int32))')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Verify few output values are correct';\n+\n+SELECT reinterpret(x'01010101', 'Int32');\n+SELECT reinterpret(x'01010101', 'Array(Int32)');\n+SELECT reinterpret(x'0101010102020202', 'Array(Int32)');\n+\n+SELECT reinterpret(x'3108b440', 'Float32');\n+SELECT reinterpret(x'3108d440', 'Float32');\n+SELECT reinterpret(x'3108b4403108d4403108b4403108d440', 'Array(Float32)');\n+SELECT reinterpret(repeat(x'3108b4403108d4403108b4403108d440', 10), 'Array(Float32)');\n+SELECT length(reinterpret(repeat(x'3108b4403108d4403108b4403108d440', 10), 'Array(Float32)'));\n+\n+SELECT reinterpret('abab', 'Array(FixedString(4))');\n+SELECT length(reinterpret(repeat('abab', 100), 'Array(FixedString(4))')) = 100;\n+\n+SELECT 'Input data of wrong length should throw error';\n+SELECT reinterpret('ababc', 'Array(FixedString(4))'); -- { serverError BAD_ARGUMENTS }\n+SELECT reinterpret(x'3108d4', 'Array(Float32)'); -- { serverError BAD_ARGUMENTS }\n+SELECT reinterpret(concat(repeat(x'3108b4403108d4403108b4403108d440', 10),  x'aa'), 'Array(Float32)'); -- { serverError BAD_ARGUMENTS }\n+\n+SELECT 'Wrong source type should throw error';\n+SELECT reinterpret(95, 'Array(FixedString(4))'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Couple of tests with FixedString input';\n+DROP TABLE IF EXISTS tab1;\n+CREATE TABLE tab1 (id Int32, s FixedString(8)) Engine = Memory;\n+INSERT INTO tab1 VALUES (1, x'3108b4403108d440');\n+INSERT INTO tab1 VALUES (2, x'3108d4403108b440');\n+\n+SELECT reinterpret(s, 'Array(Float32)') FROM tab1 ORDER BY id;\n+\n+DROP TABLE tab1;\n",
  "problem_statement": "`reinterpret` should be able to convert between String/FixedString and Array of fixed-size types\n### Company or project name\n\nClickHouse\n\n### Use case\n\nRepresent large arrays in the binary form in the query.\n\n### Describe the solution you'd like\n\nSupport this: `SELECT reinterpret('abcdefgh', 'Array(UInt32)')`\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-07-07T16:05:40Z"
}