diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md
index 0dbf176d7487..ab9547218557 100644
--- a/docs/en/sql-reference/functions/type-conversion-functions.md
+++ b/docs/en/sql-reference/functions/type-conversion-functions.md
@@ -6247,7 +6247,7 @@ reinterpret(x, type)
 **Arguments**
 
 - `x` — Any type.
-- `type` — Destination type. [String](../data-types/string.md).
+- `type` — Destination type. If it is an array, then the array element type must be a fixed length type.
 
 **Returned value**
 
@@ -6270,6 +6270,19 @@ Result:
 └─────────────┴──────────────┴───────────────┘
 ```
 
+Query:
+```sql
+SELECT reinterpret(x'3108b4403108d4403108b4403108d440', 'Array(Float32)') AS string_to_array_of_Float32;
+```
+
+Result:
+
+```text
+┌─string_to_array_of_Float32─┐
+│ [5.626,6.626,5.626,6.626]  │
+└────────────────────────────┘
+```
+
 ## CAST {#cast}
 
 Converts an input value to the specified data type. Unlike the [reinterpret](#reinterpret) function, `CAST` tries to present the same value using the new data type. If the conversion can not be done then an exception is raised.
diff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp
index 2667f382a495..855b98f2abe2 100644
--- a/src/Functions/reinterpretAs.cpp
+++ b/src/Functions/reinterpretAs.cpp
@@ -9,15 +9,16 @@
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnVector.h>
+#include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypesDecimal.h>
 #include <DataTypes/DataTypeFactory.h>
+#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeFixedString.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeUUID.h>
-#include <DataTypes/DataTypesDecimal.h>
-#include <DataTypes/DataTypesNumber.h>
 
 #include <Common/transformEndianness.h>
 #include <Common/memcpySmall.h>
@@ -103,6 +104,20 @@ class FunctionReinterpret : public IFunction
                     from_type->getName(),
                     to_type->getName());
         }
+        else if (result_reinterpret_type.isArray())
+        {
+            WhichDataType from_data_type(from_type);
+            if (!from_data_type.isStringOrFixedString())
+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Cannot reinterpret {} as {} because only String or FixedString can be reinterpreted as array",
+                    from_type->getName(),
+                    to_type->getName());
+            if (!to_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Cannot reinterpret {} as {} because the array element type is not fixed length",
+                    from_type->getName(),
+                    to_type->getName());
+        }
         else
         {
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
@@ -275,10 +290,41 @@ class FunctionReinterpret : public IFunction
             return false;
         }))
         {
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                "Cannot reinterpret {} as {}",
-                from_type->getName(),
-                result_type->getName());
+            /// Destination could be array, source has to be String/FixedString
+            /// Above lambda block of callOnTwoTypeIndexes() only for scalar result type specializations.
+            /// All Array(T) result types are handled with a single code block below using insertData().
+            if (WhichDataType(result_type).isArray())
+            {
+                auto inner_type = typeid_cast<const DataTypeArray &>(*result_type).getNestedType();
+                const IColumn * col_from = nullptr;
+
+                if (WhichDataType(from_type).isString())
+                    col_from = &assert_cast<const ColumnString &>(*arguments[0].column);
+                else if (WhichDataType(from_type).isFixedString())
+                    col_from = &assert_cast<const ColumnFixedString &>(*arguments[0].column);
+                else
+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Cannot reinterpret {} as {}, expected String or FixedString as source",
+                        from_type->getName(),
+                        result_type->getName());
+
+                auto col_res = ColumnArray::create(inner_type->createColumn());
+
+                for (size_t i = 0; i < input_rows_count; ++i)
+                {
+                    StringRef ref = col_from->getDataAt(i);
+                    col_res->insertData(ref.data, ref.size);
+                }
+
+                result = std::move(col_res);
+            }
+            else
+            {
+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Cannot reinterpret {} as {}",
+                    from_type->getName(),
+                    result_type->getName());
+            }
         }
 
         return result;
