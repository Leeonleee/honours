{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 17845,
  "instance_id": "ClickHouse__ClickHouse-17845",
  "issue_numbers": [
    "17404"
  ],
  "base_commit": "fb1221148d2d86f48cbb19d2290b2c19945ad61c",
  "patch": "diff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h\nindex a569b1c15db0..c3fed54206ee 100644\n--- a/src/Common/HashTable/HashTable.h\n+++ b/src/Common/HashTable/HashTable.h\n@@ -194,9 +194,6 @@ struct HashTableCell\n     /// Do the hash table need to store the zero key separately (that is, can a zero key be inserted into the hash table).\n     static constexpr bool need_zero_value_storage = true;\n \n-    /// Whether the cell is deleted.\n-    bool isDeleted() const { return false; }\n-\n     /// Set the mapped value, if any (for HashMap), to the corresponding `value`.\n     void setMapped(const value_type & /*value*/) {}\n \n@@ -230,6 +227,9 @@ struct HashTableGrower\n     UInt8 size_degree = initial_size_degree;\n     static constexpr auto initial_count = 1ULL << initial_size_degree;\n \n+    /// If collision resolution chains are contiguous, we can implement erase operation by moving the elements.\n+    static constexpr auto performs_linear_probing_with_single_step = true;\n+\n     /// The size of the hash table in the cells.\n     size_t bufSize() const               { return 1ULL << size_degree; }\n \n@@ -277,6 +277,9 @@ template <size_t key_bits>\n struct HashTableFixedGrower\n {\n     static constexpr auto initial_count = 1ULL << key_bits;\n+\n+    static constexpr auto performs_linear_probing_with_single_step = true;\n+\n     size_t bufSize() const               { return 1ULL << key_bits; }\n     size_t place(size_t x) const         { return x; }\n     /// You could write __builtin_unreachable(), but the compiler does not optimize everything, and it turns out less efficiently.\n@@ -466,7 +469,7 @@ class HashTable :\n           */\n         size_t i = 0;\n         for (; i < old_size; ++i)\n-            if (!buf[i].isZero(*this) && !buf[i].isDeleted())\n+            if (!buf[i].isZero(*this))\n                 reinsert(buf[i], buf[i].getHash(*this));\n \n         /** There is also a special case:\n@@ -477,7 +480,7 @@ class HashTable :\n           *    after transferring all the elements from the old halves you need to     [         o   x    ]\n           *    process tail from the collision resolution chain immediately after it   [        o    x    ]\n           */\n-        for (; !buf[i].isZero(*this) && !buf[i].isDeleted(); ++i)\n+        for (; !buf[i].isZero(*this); ++i)\n             reinsert(buf[i], buf[i].getHash(*this));\n \n #ifdef DBMS_HASH_MAP_DEBUG_RESIZES\n@@ -829,6 +832,7 @@ class HashTable :\n                   */\n                 --m_size;\n                 buf[place_value].setZero();\n+                inserted = false;\n                 throw;\n             }\n \n@@ -954,6 +958,97 @@ class HashTable :\n         return const_cast<std::decay_t<decltype(*this)> *>(this)->find(x, hash_value);\n     }\n \n+    std::enable_if_t<Grower::performs_linear_probing_with_single_step, void>\n+    ALWAYS_INLINE erase(const Key & x)\n+    {\n+        /** Deletion from open addressing hash table without tombstones\n+          *\n+          * https://en.wikipedia.org/wiki/Linear_probing\n+          * https://en.wikipedia.org/wiki/Open_addressing\n+          * Algorithm without recomputing hash but keep probes difference value (difference of natural cell position and inserted one)\n+          *  in cell https://arxiv.org/ftp/arxiv/papers/0909/0909.2547.pdf\n+          *\n+          * Currently we use algorithm with hash recomputing on each step from https://en.wikipedia.org/wiki/Open_addressing\n+          */\n+\n+        if (Cell::isZero(x, *this))\n+        {\n+            if (this->hasZero())\n+            {\n+                --m_size;\n+                this->clearHasZero();\n+            }\n+            else\n+            {\n+                return;\n+            }\n+        }\n+\n+        size_t hash_value = hash(x);\n+        size_t erased_key_position = findCell(x, hash_value, grower.place(hash_value));\n+\n+        /// Key is not found\n+        if (buf[erased_key_position].isZero(*this))\n+        {\n+            return;\n+        }\n+\n+        /// We need to guarantee loop termination because there will be empty position\n+        assert(m_size < grower.bufSize());\n+\n+        size_t next_position = erased_key_position;\n+\n+        /// Walk to the right through collision resolution chain and move elements to better positions\n+        while (true)\n+        {\n+            next_position = grower.next(next_position);\n+\n+            /// If there's no more elements in the chain\n+            if (buf[next_position].isZero(*this))\n+                break;\n+\n+            /// The optimal position of the element in the cell at next_position\n+            size_t optimal_position = grower.place(buf[next_position].getHash(*this));\n+\n+            /// If position of this element is already optimal - proceed to the next element.\n+            if (optimal_position == next_position)\n+                continue;\n+\n+            /// The case of non overlapping part of chain\n+            if (next_position > erased_key_position\n+                /// Cannot move this element because optimal position is after the freed place\n+                /// The second condition is tricky - if the chain was overlapped before erased_key_position,\n+                ///  and the optimal position is actually before in collision resolution chain:\n+                ///\n+                /// [*xn***----------------***]\n+                ///   ^^-next elem          ^\n+                ///   |                     |\n+                ///   erased elem           the optimal position of the next elem\n+                ///\n+                /// so, the next elem should be moved to position of erased elem\n+                && (optimal_position > erased_key_position) && (optimal_position < next_position))\n+            {\n+                continue;\n+            }\n+\n+            /// The case of overlapping chain\n+            if (next_position < erased_key_position\n+                /// Cannot move this element because optimal position is after the freed place\n+                && ((optimal_position > erased_key_position) || (optimal_position < next_position)))\n+            {\n+                continue;\n+            }\n+\n+            /// Move the element to the freed place\n+            memcpy(static_cast<void *>(&buf[erased_key_position]), static_cast<void *>(&buf[next_position]), sizeof(Cell));\n+            /// Now we have another freed place\n+            erased_key_position = next_position;\n+        }\n+\n+        buf[erased_key_position].setZero();\n+        --m_size;\n+    }\n+\n     bool ALWAYS_INLINE has(const Key & x) const\n     {\n         if (Cell::isZero(x, *this))\ndiff --git a/src/Common/SpaceSaving.h b/src/Common/SpaceSaving.h\nindex cb6fee1ad91c..185b4aa90aef 100644\n--- a/src/Common/SpaceSaving.h\n+++ b/src/Common/SpaceSaving.h\n@@ -353,6 +353,7 @@ class SpaceSaving\n     void destroyLastElement()\n     {\n         auto last_element = counter_list.back();\n+        counter_map.erase(last_element->key);\n         arena.free(last_element->key);\n         delete last_element;\n         counter_list.pop_back();\n",
  "test_patch": "diff --git a/src/Common/tests/CMakeLists.txt b/src/Common/tests/CMakeLists.txt\nindex 6a39c2f85533..cb36e2b97d28 100644\n--- a/src/Common/tests/CMakeLists.txt\n+++ b/src/Common/tests/CMakeLists.txt\n@@ -10,9 +10,6 @@ target_link_libraries (sip_hash_perf PRIVATE clickhouse_common_io)\n add_executable (auto_array auto_array.cpp)\n target_link_libraries (auto_array PRIVATE clickhouse_common_io)\n \n-add_executable (hash_table hash_table.cpp)\n-target_link_libraries (hash_table PRIVATE clickhouse_common_io)\n-\n add_executable (small_table small_table.cpp)\n target_link_libraries (small_table PRIVATE clickhouse_common_io)\n \ndiff --git a/src/Common/tests/gtest_hash_table.cpp b/src/Common/tests/gtest_hash_table.cpp\nnew file mode 100644\nindex 000000000000..bd789f277096\n--- /dev/null\n+++ b/src/Common/tests/gtest_hash_table.cpp\n@@ -0,0 +1,210 @@\n+#include <iomanip>\n+#include <iostream>\n+\n+#include <Interpreters/AggregationCommon.h>\n+\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/HashTable/HashSet.h>\n+\n+#include <IO/ReadBufferFromString.h>\n+\n+#include <gtest/gtest.h>\n+\n+/// To test dump functionality without using other hashes that can change\n+template <typename T>\n+struct DummyHash\n+{\n+    size_t operator()(T key) const { return T(key); }\n+};\n+\n+template<typename HashTable>\n+std::set<typename HashTable::value_type> convertToSet(const HashTable& table)\n+{\n+    std::set<typename HashTable::value_type> result;\n+\n+    for (auto v: table)\n+        result.emplace(v.getValue());\n+\n+    return result;\n+}\n+\n+\n+TEST(HashTable, Insert)\n+{\n+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+\n+    Cont cont;\n+\n+    cont.insert(1);\n+    cont.insert(2);\n+\n+    ASSERT_EQ(cont.size(), 2);\n+}\n+\n+TEST(HashTable, Emplace)\n+{\n+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+\n+    Cont cont;\n+\n+    Cont::LookupResult it;\n+    bool inserted = false;\n+    cont.emplace(1, it, inserted);\n+    ASSERT_EQ(it->getKey(), 1);\n+    ASSERT_EQ(inserted, true);\n+\n+    cont.emplace(2, it, inserted);\n+    ASSERT_EQ(it->getKey(), 2);\n+    ASSERT_EQ(inserted, true);\n+\n+    cont.emplace(1, it, inserted);\n+    ASSERT_EQ(it->getKey(), 1);\n+    ASSERT_EQ(inserted, false);\n+}\n+\n+TEST(HashTable, Lookup)\n+{\n+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+\n+    Cont cont;\n+\n+    cont.insert(1);\n+    cont.insert(2);\n+\n+    Cont::LookupResult it = cont.find(1);\n+    ASSERT_TRUE(it != nullptr);\n+\n+    it = cont.find(2);\n+    ASSERT_TRUE(it != nullptr);\n+\n+    it = cont.find(3);\n+    ASSERT_TRUE(it == nullptr);\n+}\n+\n+TEST(HashTable, Iteration)\n+{\n+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+\n+    Cont cont;\n+\n+    cont.insert(1);\n+    cont.insert(2);\n+    cont.insert(3);\n+\n+    std::set<int> expected = {1, 2, 3};\n+    std::set<int> actual = convertToSet(cont);\n+\n+    ASSERT_EQ(actual, expected);\n+}\n+\n+TEST(HashTable, Erase)\n+{\n+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+    Cont cont;\n+\n+    for (size_t i = 0; i < 5000; ++i)\n+    {\n+        cont.insert(i);\n+    }\n+\n+    for (size_t i = 0; i < 2500; ++i)\n+    {\n+        cont.erase(i);\n+    }\n+\n+    for (size_t i = 5000; i < 10000; ++i)\n+    {\n+        cont.insert(i);\n+    }\n+\n+    for (size_t i = 5000; i < 10000; ++i)\n+    {\n+        cont.erase(i);\n+    }\n+\n+    for (size_t i = 2500; i < 5000; ++i)\n+    {\n+        cont.erase(i);\n+    }\n+\n+    ASSERT_EQ(cont.size(), 0);\n+}\n+\n+TEST(HashTable, SerializationDeserialization)\n+{\n+    {\n+        /// Use dummy hash to make it reproducible if default hash implementation will be changed\n+        using Cont = HashSet<int, DummyHash<int>, HashTableGrower<1>>;\n+\n+        Cont cont;\n+\n+        cont.insert(1);\n+        cont.insert(2);\n+        cont.insert(3);\n+\n+        DB::WriteBufferFromOwnString wb;\n+        cont.writeText(wb);\n+\n+        std::string expected = \"3,1,2,3\";\n+\n+        ASSERT_EQ(wb.str(), expected);\n+\n+        DB::ReadBufferFromString rb(expected);\n+\n+        Cont deserialized;\n+        deserialized.readText(rb);\n+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));\n+    }\n+    {\n+        using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n+\n+        Cont cont;\n+\n+        cont.insert(1);\n+        cont.insert(2);\n+        cont.insert(3);\n+\n+        DB::WriteBufferFromOwnString wb;\n+        cont.write(wb);\n+\n+        DB::ReadBufferFromString rb(wb.str());\n+\n+        Cont deserialized;\n+        deserialized.read(rb);\n+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));\n+    }\n+    {\n+        using Cont = HashSet<int, DummyHash<int>, HashTableGrower<1>>;\n+        Cont cont;\n+\n+        DB::WriteBufferFromOwnString wb;\n+        cont.writeText(wb);\n+\n+        std::string expected = \"0\";\n+        ASSERT_EQ(wb.str(), expected);\n+\n+        DB::ReadBufferFromString rb(expected);\n+\n+        Cont deserialized;\n+        deserialized.readText(rb);\n+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));\n+    }\n+    {\n+        using Cont = HashSet<DB::UInt128, DB::UInt128TrivialHash>;\n+        Cont cont;\n+\n+        DB::WriteBufferFromOwnString wb;\n+        cont.write(wb);\n+\n+        std::string expected;\n+        expected += static_cast<char>(0);\n+\n+        ASSERT_EQ(wb.str(), expected);\n+\n+        DB::ReadBufferFromString rb(expected);\n+\n+        Cont deserialized;\n+        deserialized.read(rb);\n+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));\n+    }\n+}\ndiff --git a/src/Common/tests/hash_table.cpp b/src/Common/tests/hash_table.cpp\ndeleted file mode 100644\nindex ebc22c5b5e51..000000000000\n--- a/src/Common/tests/hash_table.cpp\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-#include <iostream>\n-#include <iomanip>\n-\n-#include <Interpreters/AggregationCommon.h>\n-\n-#include <Common/HashTable/HashMap.h>\n-#include <Common/HashTable/HashSet.h>\n-\n-\n-int main(int, char **)\n-{\n-    {\n-        using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;\n-        Cont cont;\n-\n-        cont.insert(1);\n-        cont.insert(2);\n-\n-        Cont::LookupResult it;\n-        bool inserted;\n-        int key = 3;\n-        cont.emplace(key, it, inserted);\n-        std::cerr << inserted << \", \" << key << std::endl;\n-\n-        cont.emplace(key, it, inserted);\n-        std::cerr << inserted << \", \" << key << std::endl;\n-\n-        for (auto x : cont)\n-            std::cerr << x.getValue() << std::endl;\n-\n-        DB::WriteBufferFromOwnString wb;\n-        cont.writeText(wb);\n-\n-        std::cerr << \"dump: \" << wb.str() << std::endl;\n-    }\n-\n-    {\n-        using Cont = HashSet<\n-            DB::UInt128,\n-            DB::UInt128TrivialHash>;\n-        Cont cont;\n-\n-        DB::WriteBufferFromOwnString wb;\n-        cont.write(wb);\n-\n-        std::cerr << \"dump: \" << wb.str() << std::endl;\n-    }\n-\n-    return 0;\n-}\ndiff --git a/tests/queries/0_stateless/00453_top_k.reference b/tests/queries/0_stateless/00453_top_k.reference\nindex 1a768b03965d..14beb3273fa1 100644\n--- a/tests/queries/0_stateless/00453_top_k.reference\n+++ b/tests/queries/0_stateless/00453_top_k.reference\n@@ -1,1 +1,8 @@\n [0,1,2,3,4,5,6,7,8,9]\n+0\t[[],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5']]]\n+1\t[[[]],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5'],[NULL,'1','2','3','4','5','6']]]\n+2\t[[[],[NULL]],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5'],[NULL,'1','2','3','4','5','6'],[NULL,'1','2','3','4','5','6','7']]]\n+3\t[[[],[NULL],[NULL,'1']]]\n+4\t[[[],[NULL],[NULL,'1'],[NULL,'1','2']]]\n+5\t[[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3']]]\n+6\t[[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4']]]\ndiff --git a/tests/queries/0_stateless/00453_top_k.sql b/tests/queries/0_stateless/00453_top_k.sql\nindex 1f79a8c53933..fb3b88e29e4b 100644\n--- a/tests/queries/0_stateless/00453_top_k.sql\n+++ b/tests/queries/0_stateless/00453_top_k.sql\n@@ -1,1 +1,15 @@\n-SELECT topK(10)(n) FROM (SELECT if(number % 100 < 10, number % 10, number) AS n FROM system.numbers LIMIT 100000);\n\\ No newline at end of file\n+SELECT topK(10)(n) FROM (SELECT if(number % 100 < 10, number % 10, number) AS n FROM system.numbers LIMIT 100000);\n+\n+SELECT\n+    k,\n+    topK(v)\n+FROM\n+(\n+    SELECT\n+        number % 7 AS k,\n+        arrayMap(x -> arrayMap(x -> if(x = 0, NULL, toString(x)), range(x)), range(intDiv(number, 1))) AS v\n+    FROM system.numbers\n+    LIMIT 10\n+)\n+GROUP BY k\n+ORDER BY k ASC\n",
  "problem_statement": "Query Fuzzer, `topK`, segfault.\nhttps://clickhouse-test-reports.s3.yandex.net/17375/99073c26ee2692f8efe2ab14b2d8ae0fd813b80e/fuzzer/fuzzer.log\r\n\r\n```\r\nSELECT\r\n    k,\r\n    topK(v)\r\nFROM \r\n(\r\n    SELECT\r\n        number % 7 AS k,\r\n        arrayMap(x -> arrayMap(x -> if(x = 0, NULL, toString(x)), range(x)), range(intDiv(number, 1))) AS v\r\n    FROM system.numbers\r\n    LIMIT 257\r\n)\r\nGROUP BY k\r\nORDER BY k ASC\r\n```\n",
  "hints_text": "this query runs ok: return 7 rows.\r\nwith CH version 20.13.1.1.",
  "created_at": "2020-12-06T19:15:49Z",
  "modified_files": [
    "src/Common/HashTable/HashTable.h",
    "src/Common/SpaceSaving.h"
  ],
  "modified_test_files": [
    "src/Common/tests/CMakeLists.txt",
    "b/src/Common/tests/gtest_hash_table.cpp",
    "src/Common/tests/hash_table.cpp",
    "tests/queries/0_stateless/00453_top_k.reference",
    "tests/queries/0_stateless/00453_top_k.sql"
  ]
}