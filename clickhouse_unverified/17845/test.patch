diff --git a/src/Common/tests/CMakeLists.txt b/src/Common/tests/CMakeLists.txt
index 6a39c2f85533..cb36e2b97d28 100644
--- a/src/Common/tests/CMakeLists.txt
+++ b/src/Common/tests/CMakeLists.txt
@@ -10,9 +10,6 @@ target_link_libraries (sip_hash_perf PRIVATE clickhouse_common_io)
 add_executable (auto_array auto_array.cpp)
 target_link_libraries (auto_array PRIVATE clickhouse_common_io)
 
-add_executable (hash_table hash_table.cpp)
-target_link_libraries (hash_table PRIVATE clickhouse_common_io)
-
 add_executable (small_table small_table.cpp)
 target_link_libraries (small_table PRIVATE clickhouse_common_io)
 
diff --git a/src/Common/tests/gtest_hash_table.cpp b/src/Common/tests/gtest_hash_table.cpp
new file mode 100644
index 000000000000..bd789f277096
--- /dev/null
+++ b/src/Common/tests/gtest_hash_table.cpp
@@ -0,0 +1,210 @@
+#include <iomanip>
+#include <iostream>
+
+#include <Interpreters/AggregationCommon.h>
+
+#include <Common/HashTable/HashMap.h>
+#include <Common/HashTable/HashSet.h>
+
+#include <IO/ReadBufferFromString.h>
+
+#include <gtest/gtest.h>
+
+/// To test dump functionality without using other hashes that can change
+template <typename T>
+struct DummyHash
+{
+    size_t operator()(T key) const { return T(key); }
+};
+
+template<typename HashTable>
+std::set<typename HashTable::value_type> convertToSet(const HashTable& table)
+{
+    std::set<typename HashTable::value_type> result;
+
+    for (auto v: table)
+        result.emplace(v.getValue());
+
+    return result;
+}
+
+
+TEST(HashTable, Insert)
+{
+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+
+    Cont cont;
+
+    cont.insert(1);
+    cont.insert(2);
+
+    ASSERT_EQ(cont.size(), 2);
+}
+
+TEST(HashTable, Emplace)
+{
+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+
+    Cont cont;
+
+    Cont::LookupResult it;
+    bool inserted = false;
+    cont.emplace(1, it, inserted);
+    ASSERT_EQ(it->getKey(), 1);
+    ASSERT_EQ(inserted, true);
+
+    cont.emplace(2, it, inserted);
+    ASSERT_EQ(it->getKey(), 2);
+    ASSERT_EQ(inserted, true);
+
+    cont.emplace(1, it, inserted);
+    ASSERT_EQ(it->getKey(), 1);
+    ASSERT_EQ(inserted, false);
+}
+
+TEST(HashTable, Lookup)
+{
+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+
+    Cont cont;
+
+    cont.insert(1);
+    cont.insert(2);
+
+    Cont::LookupResult it = cont.find(1);
+    ASSERT_TRUE(it != nullptr);
+
+    it = cont.find(2);
+    ASSERT_TRUE(it != nullptr);
+
+    it = cont.find(3);
+    ASSERT_TRUE(it == nullptr);
+}
+
+TEST(HashTable, Iteration)
+{
+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+
+    Cont cont;
+
+    cont.insert(1);
+    cont.insert(2);
+    cont.insert(3);
+
+    std::set<int> expected = {1, 2, 3};
+    std::set<int> actual = convertToSet(cont);
+
+    ASSERT_EQ(actual, expected);
+}
+
+TEST(HashTable, Erase)
+{
+    using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+    Cont cont;
+
+    for (size_t i = 0; i < 5000; ++i)
+    {
+        cont.insert(i);
+    }
+
+    for (size_t i = 0; i < 2500; ++i)
+    {
+        cont.erase(i);
+    }
+
+    for (size_t i = 5000; i < 10000; ++i)
+    {
+        cont.insert(i);
+    }
+
+    for (size_t i = 5000; i < 10000; ++i)
+    {
+        cont.erase(i);
+    }
+
+    for (size_t i = 2500; i < 5000; ++i)
+    {
+        cont.erase(i);
+    }
+
+    ASSERT_EQ(cont.size(), 0);
+}
+
+TEST(HashTable, SerializationDeserialization)
+{
+    {
+        /// Use dummy hash to make it reproducible if default hash implementation will be changed
+        using Cont = HashSet<int, DummyHash<int>, HashTableGrower<1>>;
+
+        Cont cont;
+
+        cont.insert(1);
+        cont.insert(2);
+        cont.insert(3);
+
+        DB::WriteBufferFromOwnString wb;
+        cont.writeText(wb);
+
+        std::string expected = "3,1,2,3";
+
+        ASSERT_EQ(wb.str(), expected);
+
+        DB::ReadBufferFromString rb(expected);
+
+        Cont deserialized;
+        deserialized.readText(rb);
+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));
+    }
+    {
+        using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
+
+        Cont cont;
+
+        cont.insert(1);
+        cont.insert(2);
+        cont.insert(3);
+
+        DB::WriteBufferFromOwnString wb;
+        cont.write(wb);
+
+        DB::ReadBufferFromString rb(wb.str());
+
+        Cont deserialized;
+        deserialized.read(rb);
+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));
+    }
+    {
+        using Cont = HashSet<int, DummyHash<int>, HashTableGrower<1>>;
+        Cont cont;
+
+        DB::WriteBufferFromOwnString wb;
+        cont.writeText(wb);
+
+        std::string expected = "0";
+        ASSERT_EQ(wb.str(), expected);
+
+        DB::ReadBufferFromString rb(expected);
+
+        Cont deserialized;
+        deserialized.readText(rb);
+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));
+    }
+    {
+        using Cont = HashSet<DB::UInt128, DB::UInt128TrivialHash>;
+        Cont cont;
+
+        DB::WriteBufferFromOwnString wb;
+        cont.write(wb);
+
+        std::string expected;
+        expected += static_cast<char>(0);
+
+        ASSERT_EQ(wb.str(), expected);
+
+        DB::ReadBufferFromString rb(expected);
+
+        Cont deserialized;
+        deserialized.read(rb);
+        ASSERT_EQ(convertToSet(cont), convertToSet(deserialized));
+    }
+}
diff --git a/src/Common/tests/hash_table.cpp b/src/Common/tests/hash_table.cpp
deleted file mode 100644
index ebc22c5b5e51..000000000000
--- a/src/Common/tests/hash_table.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <iostream>
-#include <iomanip>
-
-#include <Interpreters/AggregationCommon.h>
-
-#include <Common/HashTable/HashMap.h>
-#include <Common/HashTable/HashSet.h>
-
-
-int main(int, char **)
-{
-    {
-        using Cont = HashSet<int, DefaultHash<int>, HashTableGrower<1>>;
-        Cont cont;
-
-        cont.insert(1);
-        cont.insert(2);
-
-        Cont::LookupResult it;
-        bool inserted;
-        int key = 3;
-        cont.emplace(key, it, inserted);
-        std::cerr << inserted << ", " << key << std::endl;
-
-        cont.emplace(key, it, inserted);
-        std::cerr << inserted << ", " << key << std::endl;
-
-        for (auto x : cont)
-            std::cerr << x.getValue() << std::endl;
-
-        DB::WriteBufferFromOwnString wb;
-        cont.writeText(wb);
-
-        std::cerr << "dump: " << wb.str() << std::endl;
-    }
-
-    {
-        using Cont = HashSet<
-            DB::UInt128,
-            DB::UInt128TrivialHash>;
-        Cont cont;
-
-        DB::WriteBufferFromOwnString wb;
-        cont.write(wb);
-
-        std::cerr << "dump: " << wb.str() << std::endl;
-    }
-
-    return 0;
-}
diff --git a/tests/queries/0_stateless/00453_top_k.reference b/tests/queries/0_stateless/00453_top_k.reference
index 1a768b03965d..14beb3273fa1 100644
--- a/tests/queries/0_stateless/00453_top_k.reference
+++ b/tests/queries/0_stateless/00453_top_k.reference
@@ -1,1 +1,8 @@
 [0,1,2,3,4,5,6,7,8,9]
+0	[[],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5']]]
+1	[[[]],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5'],[NULL,'1','2','3','4','5','6']]]
+2	[[[],[NULL]],[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4'],[NULL,'1','2','3','4','5'],[NULL,'1','2','3','4','5','6'],[NULL,'1','2','3','4','5','6','7']]]
+3	[[[],[NULL],[NULL,'1']]]
+4	[[[],[NULL],[NULL,'1'],[NULL,'1','2']]]
+5	[[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3']]]
+6	[[[],[NULL],[NULL,'1'],[NULL,'1','2'],[NULL,'1','2','3'],[NULL,'1','2','3','4']]]
diff --git a/tests/queries/0_stateless/00453_top_k.sql b/tests/queries/0_stateless/00453_top_k.sql
index 1f79a8c53933..fb3b88e29e4b 100644
--- a/tests/queries/0_stateless/00453_top_k.sql
+++ b/tests/queries/0_stateless/00453_top_k.sql
@@ -1,1 +1,15 @@
-SELECT topK(10)(n) FROM (SELECT if(number % 100 < 10, number % 10, number) AS n FROM system.numbers LIMIT 100000);
\ No newline at end of file
+SELECT topK(10)(n) FROM (SELECT if(number % 100 < 10, number % 10, number) AS n FROM system.numbers LIMIT 100000);
+
+SELECT
+    k,
+    topK(v)
+FROM
+(
+    SELECT
+        number % 7 AS k,
+        arrayMap(x -> arrayMap(x -> if(x = 0, NULL, toString(x)), range(x)), range(intDiv(number, 1))) AS v
+    FROM system.numbers
+    LIMIT 10
+)
+GROUP BY k
+ORDER BY k ASC
