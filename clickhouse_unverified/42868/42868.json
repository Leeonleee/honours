{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42868,
  "instance_id": "ClickHouse__ClickHouse-42868",
  "issue_numbers": [
    "42825"
  ],
  "base_commit": "876dca48da8859ceb72b562c35f69789056a9de5",
  "patch": "diff --git a/src/Compression/LZ4_decompress_faster.cpp b/src/Compression/LZ4_decompress_faster.cpp\nindex f2084f34274a..34bb440c19cf 100644\n--- a/src/Compression/LZ4_decompress_faster.cpp\n+++ b/src/Compression/LZ4_decompress_faster.cpp\n@@ -3,10 +3,10 @@\n #include <cstring>\n #include <iostream>\n #include <Core/Defines.h>\n-#include <Common/Stopwatch.h>\n-#include <Common/TargetSpecific.h>\n #include <base/types.h>\n #include <base/unaligned.h>\n+#include <Common/Stopwatch.h>\n+#include <Common/TargetSpecific.h>\n \n #ifdef __SSE2__\n #include <emmintrin.h>\n@@ -599,6 +599,9 @@ bool NO_INLINE decompressImpl(const char * const source, char * const dest, size\n \n         copy_end = op + length;\n \n+        if (unlikely(copy_end > output_end))\n+            return false;\n+\n         /** Here we can write up to copy_amount - 1 - 4 * 2 bytes after buffer.\n           * The worst case when offset = 1 and length = 4\n           */\n",
  "test_patch": "diff --git a/src/Compression/tests/gtest_compressionCodec.cpp b/src/Compression/tests/gtest_compressionCodec.cpp\nindex 2df3edb23ad6..49cc0aaef771 100644\n--- a/src/Compression/tests/gtest_compressionCodec.cpp\n+++ b/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -1,8 +1,5 @@\n #include <Compression/CompressionFactory.h>\n \n-#include <Common/PODArray.h>\n-#include <Common/Stopwatch.h>\n-#include <base/types.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/IDataType.h>\n #include <IO/ReadBufferFromMemory.h>\n@@ -10,6 +7,12 @@\n #include <Parsers/ExpressionElementParsers.h>\n #include <Parsers/IParser.h>\n #include <Parsers/TokenIterator.h>\n+#include <base/types.h>\n+#include <Common/PODArray.h>\n+#include <Common/Stopwatch.h>\n+\n+#include <Compression/LZ4_decompress_faster.h>\n+#include <IO/BufferWithOwnMemory.h>\n \n #include <random>\n #include <bitset>\n@@ -1314,4 +1317,34 @@ INSTANTIATE_TEST_SUITE_P(Gorilla,\n //    ),\n //);\n \n+TEST(LZ4Test, DecompressMalformedInput)\n+{\n+    /// This malformed input was initially found by lz4_decompress_fuzzer and causes failure under UBSAN.\n+    constexpr unsigned char data[]\n+        = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,\n+           0x00, 0x20, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0xff, 0xff, 0xff, 0x17, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n+           0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+           0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n+\n+    const char * const source = reinterpret_cast<const char * const>(data);\n+    const uint32_t source_size = std::size(data);\n+    constexpr uint32_t uncompressed_size = 80;\n+\n+    DB::Memory<> memory;\n+    memory.resize(ICompressionCodec::getHeaderSize() + uncompressed_size + LZ4::ADDITIONAL_BYTES_AT_END_OF_BUFFER);\n+    unalignedStoreLE<uint8_t>(memory.data(), static_cast<uint8_t>(CompressionMethodByte::LZ4));\n+    unalignedStoreLE<uint32_t>(&memory[1], source_size);\n+    unalignedStoreLE<uint32_t>(&memory[5], uncompressed_size);\n+\n+    auto codec = CompressionCodecFactory::instance().get(\"LZ4\", {});\n+    ASSERT_THROW(codec->decompress(source, source_size, memory.data()), Exception);\n+}\n+\n }\n",
  "problem_statement": "Check oss-fuzz reports about lz4\n\n",
  "hints_text": "",
  "created_at": "2022-11-01T15:02:54Z"
}