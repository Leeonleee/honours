{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59747,
  "instance_id": "ClickHouse__ClickHouse-59747",
  "issue_numbers": [
    "56257"
  ],
  "base_commit": "ba547f3622a2e408810ab11e9878105004ed0861",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex a137eb2bdf22..66d5bd2e5741 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -197,6 +197,7 @@ SELECT * FROM nestedt FORMAT TSV\n - [input_format_tsv_enum_as_number](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_enum_as_number) - treat inserted enum values in TSV formats as enum indices. Default value - `false`.\n - [input_format_tsv_use_best_effort_in_schema_inference](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_use_best_effort_in_schema_inference) - use some tweaks and heuristics to infer schema in TSV format. If disabled, all fields will be inferred as Strings. Default value - `true`.\n - [output_format_tsv_crlf_end_of_line](/docs/en/operations/settings/settings-formats.md/#output_format_tsv_crlf_end_of_line) - if it is set true, end of line in TSV output format will be `\\r\\n` instead of `\\n`. Default value - `false`.\n+- [input_format_tsv_crlf_end_of_line](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_crlf_end_of_line) - if it is set true, end of line in TSV input format will be `\\r\\n` instead of `\\n`. Default value - `false`.\n - [input_format_tsv_skip_first_lines](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_skip_first_lines) - skip specified number of lines at the beginning of data. Default value - `0`.\n - [input_format_tsv_detect_header](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_detect_header) - automatically detect header with names and types in TSV format. Default value - `true`.\n - [input_format_tsv_skip_trailing_empty_lines](/docs/en/operations/settings/settings-formats.md/#input_format_tsv_skip_trailing_empty_lines) - skip trailing empty lines at the end of data. Default value - `false`.\ndiff --git a/docs/en/operations/settings/settings-formats.md b/docs/en/operations/settings/settings-formats.md\nindex 6666f68c1777..1a27b3506529 100644\n--- a/docs/en/operations/settings/settings-formats.md\n+++ b/docs/en/operations/settings/settings-formats.md\n@@ -831,7 +831,13 @@ Default value: `0`.\n \n ### output_format_tsv_crlf_end_of_line {#output_format_tsv_crlf_end_of_line}\n \n-Use DOC/Windows-style line separator (CRLF) in TSV instead of Unix style (LF).\n+Use DOS/Windows-style line separator (CRLF) in TSV instead of Unix style (LF).\n+\n+Disabled by default.\n+\n+### input_format_tsv_crlf_end_of_line {#input_format_tsv_crlf_end_of_line}\n+\n+Use DOS/Windows-style line separator (CRLF) for TSV input files instead of Unix style (LF).\n \n Disabled by default.\n \ndiff --git a/docs/ru/interfaces/formats.md b/docs/ru/interfaces/formats.md\nindex a9280de9c7bc..4ed42b6fb22e 100644\n--- a/docs/ru/interfaces/formats.md\n+++ b/docs/ru/interfaces/formats.md\n@@ -119,6 +119,7 @@ Hello\\nworld\n Hello\\\n world\n ```\n+`\\n\\r` (CRLF) \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 `input_format_tsv_crlf_end_of_line`. \n \n \u0412\u0442\u043e\u0440\u043e\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044f, \u0442\u0430\u043a \u043a\u0430\u043a \u0435\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 MySQL \u043f\u0440\u0438 \u0437\u0430\u043f\u0438\u0441\u0438 tab-separated \u0434\u0430\u043c\u043f\u0430.\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 4a0de354a034..eb4024a0ab48 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -1078,6 +1078,7 @@ class IColumn;\n     M(Bool, input_format_csv_skip_trailing_empty_lines, false, \"Skip trailing empty lines in CSV format\", 0) \\\n     M(Bool, input_format_tsv_skip_trailing_empty_lines, false, \"Skip trailing empty lines in TSV format\", 0) \\\n     M(Bool, input_format_custom_skip_trailing_empty_lines, false, \"Skip trailing empty lines in CustomSeparated format\", 0) \\\n+    M(Bool, input_format_tsv_crlf_end_of_line, false, \"If it is set true, file function will read TSV format with \\\\r\\\\n instead of \\\\n.\", 0) \\\n     \\\n     M(Bool, input_format_native_allow_types_conversion, true, \"Allow data types conversion in Native input format\", 0) \\\n     \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex ece486206187..a94b5ad0f598 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -87,6 +87,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n {\n     {\"24.5\", {{\"allow_deprecated_functions\", true, false, \"Allow usage of deprecated functions\"},\n               {\"allow_experimental_join_condition\", false, false, \"Support join with inequal conditions which involve columns from both left and right table. e.g. t1.y < t2.y.\"},\n+              {\"input_format_tsv_crlf_end_of_line\", false, false, \"Enables reading of CRLF line endings with TSV formats\"},\n               {\"output_format_parquet_use_custom_encoder\", false, true, \"Enable custom Parquet encoder.\"},\n               {\"cross_join_min_rows_to_compress\", 0, 10000000, \"A new setting.\"},\n               {\"cross_join_min_bytes_to_compress\", 0, 1_GiB, \"A new setting.\"},\ndiff --git a/src/DataTypes/Serializations/SerializationAggregateFunction.cpp b/src/DataTypes/Serializations/SerializationAggregateFunction.cpp\nindex bab7c1d4cf27..55f7641e058b 100644\n--- a/src/DataTypes/Serializations/SerializationAggregateFunction.cpp\n+++ b/src/DataTypes/Serializations/SerializationAggregateFunction.cpp\n@@ -146,10 +146,10 @@ void SerializationAggregateFunction::serializeTextEscaped(const IColumn & column\n }\n \n \n-void SerializationAggregateFunction::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void SerializationAggregateFunction::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n     String s;\n-    readEscapedString(s, istr);\n+    settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(s, istr) : readEscapedString(s, istr);\n     deserializeFromString(function, column, s, version);\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationBool.cpp b/src/DataTypes/Serializations/SerializationBool.cpp\nindex b63f25ddc35b..a71c8a91cef0 100644\n--- a/src/DataTypes/Serializations/SerializationBool.cpp\n+++ b/src/DataTypes/Serializations/SerializationBool.cpp\n@@ -242,8 +242,10 @@ void SerializationBool::deserializeTextEscaped(IColumn & column, ReadBuffer & is\n {\n     if (istr.eof())\n         throw Exception(ErrorCodes::CANNOT_PARSE_BOOL, \"Expected boolean value but get EOF.\");\n-\n-    deserializeImpl(column, istr, settings, [](ReadBuffer & buf){ return buf.eof() || *buf.position() == '\\t' || *buf.position() == '\\n'; });\n+    if (settings.tsv.crlf_end_of_line_input)\n+        deserializeImpl(column, istr, settings, [](ReadBuffer & buf){ return buf.eof() || *buf.position() == '\\t' || *buf.position() == '\\n' || *buf.position() == '\\r'; });\n+    else\n+        deserializeImpl(column, istr, settings, [](ReadBuffer & buf){ return buf.eof() || *buf.position() == '\\t' || *buf.position() == '\\n'; });\n }\n \n bool SerializationBool::tryDeserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\ndiff --git a/src/DataTypes/Serializations/SerializationCustomSimpleText.cpp b/src/DataTypes/Serializations/SerializationCustomSimpleText.cpp\nindex 938fd0501735..1ba16f8492ec 100644\n--- a/src/DataTypes/Serializations/SerializationCustomSimpleText.cpp\n+++ b/src/DataTypes/Serializations/SerializationCustomSimpleText.cpp\n@@ -75,7 +75,7 @@ void SerializationCustomSimpleText::serializeTextEscaped(const IColumn & column,\n void SerializationCustomSimpleText::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n     String str;\n-    readEscapedString(str, istr);\n+    settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(str, istr) : readEscapedString(str, istr);\n     deserializeFromString(*this, column, str, settings);\n }\n \ndiff --git a/src/DataTypes/Serializations/SerializationEnum.cpp b/src/DataTypes/Serializations/SerializationEnum.cpp\nindex d72442eec99d..6d36c6a9a96d 100644\n--- a/src/DataTypes/Serializations/SerializationEnum.cpp\n+++ b/src/DataTypes/Serializations/SerializationEnum.cpp\n@@ -29,7 +29,7 @@ void SerializationEnum<Type>::deserializeTextEscaped(IColumn & column, ReadBuffe\n     {\n         /// NOTE It would be nice to do without creating a temporary object - at least extract std::string out.\n         std::string field_name;\n-        readEscapedString(field_name, istr);\n+        settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(field_name, istr) : readEscapedString(field_name, istr);\n         assert_cast<ColumnType &>(column).getData().push_back(ref_enum_values.getValue(StringRef(field_name), true));\n     }\n }\ndiff --git a/src/DataTypes/Serializations/SerializationFixedString.cpp b/src/DataTypes/Serializations/SerializationFixedString.cpp\nindex 481ae2a61659..f919dc16d339 100644\n--- a/src/DataTypes/Serializations/SerializationFixedString.cpp\n+++ b/src/DataTypes/Serializations/SerializationFixedString.cpp\n@@ -10,8 +10,10 @@\n #include <IO/WriteHelpers.h>\n #include <IO/VarInt.h>\n \n+#include \"Common/PODArray.h\"\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n+#include \"base/types.h\"\n \n namespace DB\n {\n@@ -183,14 +185,17 @@ static inline bool tryRead(const SerializationFixedString & self, IColumn & colu\n }\n \n \n-void SerializationFixedString::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void SerializationFixedString::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    read(*this, column, [&istr](ColumnFixedString::Chars & data) { readEscapedStringInto(data, istr); });\n+    read(*this, column, [&istr, &settings](ColumnFixedString::Chars & data)\n+    {\n+        settings.tsv.crlf_end_of_line_input ? readEscapedStringInto<ColumnFixedString::Chars,true>(data, istr) : readEscapedStringInto<ColumnFixedString::Chars,false>(data, istr);\n+    });\n }\n \n bool SerializationFixedString::tryDeserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n-    return tryRead(*this, column, [&istr](ColumnFixedString::Chars & data) { readEscapedStringInto(data, istr); return true; });\n+    return tryRead(*this, column, [&istr](ColumnFixedString::Chars & data) { readEscapedStringInto<PaddedPODArray<UInt8>,false>(data, istr); return true; });\n }\n \n \ndiff --git a/src/DataTypes/Serializations/SerializationNullable.cpp b/src/DataTypes/Serializations/SerializationNullable.cpp\nindex 4d31451f92d1..06361e24aa24 100644\n--- a/src/DataTypes/Serializations/SerializationNullable.cpp\n+++ b/src/DataTypes/Serializations/SerializationNullable.cpp\n@@ -286,7 +286,7 @@ bool SerializationNullable::tryDeserializeNullRaw(DB::ReadBuffer & istr, const D\n }\n \n template<typename ReturnType, bool escaped>\n-ReturnType deserializeTextEscapedAndRawImpl(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const SerializationPtr & nested_serialization, bool & is_null)\n+ReturnType  deserializeTextEscapedAndRawImpl(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, const SerializationPtr & nested_serialization, bool & is_null)\n {\n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n@@ -319,10 +319,10 @@ ReturnType deserializeTextEscapedAndRawImpl(IColumn & column, ReadBuffer & istr,\n     /// Check if we have enough data in buffer to check if it's a null.\n     if (istr.available() > null_representation.size())\n     {\n-        auto check_for_null = [&null_representation](ReadBuffer & buf)\n+        auto check_for_null = [&null_representation, &settings](ReadBuffer & buf)\n         {\n             auto * pos = buf.position();\n-            if (checkString(null_representation, buf) && (*buf.position() == '\\t' || *buf.position() == '\\n'))\n+            if (checkString(null_representation, buf) && (*buf.position() == '\\t' || *buf.position() == '\\n' || (settings.tsv.crlf_end_of_line_input && *buf.position() == '\\r')))\n                 return true;\n             buf.position() = pos;\n             return false;\n@@ -334,14 +334,14 @@ ReturnType deserializeTextEscapedAndRawImpl(IColumn & column, ReadBuffer & istr,\n     /// Use PeekableReadBuffer to make a checkpoint before checking null\n     /// representation and rollback if check was failed.\n     PeekableReadBuffer peekable_buf(istr, true);\n-    auto check_for_null = [&null_representation](ReadBuffer & buf_)\n+    auto check_for_null = [&null_representation, &settings](ReadBuffer & buf_)\n     {\n         auto & buf = assert_cast<PeekableReadBuffer &>(buf_);\n         buf.setCheckpoint();\n         SCOPE_EXIT(buf.dropCheckpoint());\n-        if (checkString(null_representation, buf) && (buf.eof() || *buf.position() == '\\t' || *buf.position() == '\\n'))\n-            return true;\n \n+        if (checkString(null_representation, buf) && (buf.eof() || *buf.position() == '\\t' || *buf.position() == '\\n' || (settings.tsv.crlf_end_of_line_input && *buf.position() == '\\r')))\n+            return true;\n         buf.rollbackToCheckpoint();\n         return false;\n     };\n@@ -371,7 +371,10 @@ ReturnType deserializeTextEscapedAndRawImpl(IColumn & column, ReadBuffer & istr,\n \n         if (null_representation.find('\\t') != std::string::npos || null_representation.find('\\n') != std::string::npos)\n             throw DB::Exception(ErrorCodes::CANNOT_READ_ALL_DATA, \"TSV custom null representation \"\n-                                       \"containing '\\\\t' or '\\\\n' may not work correctly for large input.\");\n+                \"containing '\\\\t' or '\\\\n' may not work correctly for large input.\");\n+        if (settings.tsv.crlf_end_of_line_input && null_representation.find('\\r') != std::string::npos)\n+            throw DB::Exception(ErrorCodes::CANNOT_READ_ALL_DATA, \"TSV custom null representation \"\n+                \"containing '\\\\r' may not work correctly for large input.\");\n \n         WriteBufferFromOwnString parsed_value;\n         if constexpr (escaped)\ndiff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp\nindex 67bf7af7799c..c82968ce0908 100644\n--- a/src/DataTypes/Serializations/SerializationObject.cpp\n+++ b/src/DataTypes/Serializations/SerializationObject.cpp\n@@ -104,9 +104,9 @@ void SerializationObject<Parser>::deserializeWholeText(IColumn & column, ReadBuf\n }\n \n template <typename Parser>\n-void SerializationObject<Parser>::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void SerializationObject<Parser>::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    deserializeTextImpl(column, [&](String & s) { readEscapedString(s, istr); });\n+    deserializeTextImpl(column, [&](String & s) { settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(s, istr) : readEscapedString(s, istr); });\n }\n \n template <typename Parser>\ndiff --git a/src/DataTypes/Serializations/SerializationString.cpp b/src/DataTypes/Serializations/SerializationString.cpp\nindex 8abaa3bd5ea5..9e39ab23709d 100644\n--- a/src/DataTypes/Serializations/SerializationString.cpp\n+++ b/src/DataTypes/Serializations/SerializationString.cpp\n@@ -147,7 +147,6 @@ void SerializationString::serializeBinaryBulk(const IColumn & column, WriteBuffe\n     }\n }\n \n-\n template <int UNROLL_TIMES>\n static NO_INLINE void deserializeBinarySSE2(ColumnString::Chars & data, ColumnString::Offsets & offsets, ReadBuffer & istr, size_t limit)\n {\n@@ -324,14 +323,17 @@ bool SerializationString::tryDeserializeWholeText(IColumn & column, ReadBuffer &\n     return read<bool>(column, [&](ColumnString::Chars & data) { readStringUntilEOFInto(data, istr); return true; });\n }\n \n-void SerializationString::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void SerializationString::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n-    read<void>(column, [&](ColumnString::Chars & data) { readEscapedStringInto(data, istr); });\n+    read<void>(column, [&](ColumnString::Chars & data)\n+    {\n+        settings.tsv.crlf_end_of_line_input ? readEscapedStringInto<PaddedPODArray<UInt8>,true>(data, istr) : readEscapedStringInto<PaddedPODArray<UInt8>,false>(data, istr);\n+    });\n }\n \n bool SerializationString::tryDeserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n-    return read<bool>(column, [&](ColumnString::Chars & data) { readEscapedStringInto(data, istr); return true; });\n+    return read<bool>(column, [&](ColumnString::Chars & data) { readEscapedStringInto<PaddedPODArray<UInt8>,true>(data, istr); return true; });\n }\n \n void SerializationString::serializeTextQuoted(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\ndiff --git a/src/DataTypes/Serializations/SerializationVariant.cpp b/src/DataTypes/Serializations/SerializationVariant.cpp\nindex 300686ff8d39..dbd7355944b6 100644\n--- a/src/DataTypes/Serializations/SerializationVariant.cpp\n+++ b/src/DataTypes/Serializations/SerializationVariant.cpp\n@@ -599,14 +599,14 @@ void SerializationVariant::serializeTextEscaped(const IColumn & column, size_t r\n bool SerializationVariant::tryDeserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n     String field;\n-    readEscapedString(field, istr);\n+    settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(field, istr) : readEscapedString(field, istr);\n     return tryDeserializeTextEscapedImpl(column, field, settings);\n }\n \n void SerializationVariant::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n {\n     String field;\n-    readEscapedString(field, istr);\n+    settings.tsv.crlf_end_of_line_input ? readEscapedStringCRLF(field, istr) : readEscapedString(field, istr);\n     if (!tryDeserializeTextEscapedImpl(column, field, settings))\n         throw Exception(ErrorCodes::INCORRECT_DATA, \"Cannot parse escaped value of type {} here: {}\", variant_name, field);\n }\ndiff --git a/src/Formats/EscapingRuleUtils.cpp b/src/Formats/EscapingRuleUtils.cpp\nindex 3edade639df3..89a7a31d0332 100644\n--- a/src/Formats/EscapingRuleUtils.cpp\n+++ b/src/Formats/EscapingRuleUtils.cpp\n@@ -76,7 +76,7 @@ void skipFieldByEscapingRule(ReadBuffer & buf, FormatSettings::EscapingRule esca\n             /// Empty field, just skip spaces\n             break;\n         case FormatSettings::EscapingRule::Escaped:\n-            readEscapedStringInto(out, buf);\n+            readEscapedStringInto<NullOutput,false>(out, buf);\n             break;\n         case FormatSettings::EscapingRule::Quoted:\n             readQuotedFieldInto(out, buf);\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 43ccee173f0d..80895769a08b 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -203,6 +203,7 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se\n     format_settings.tsv.try_detect_header = settings.input_format_tsv_detect_header;\n     format_settings.tsv.skip_trailing_empty_lines = settings.input_format_tsv_skip_trailing_empty_lines;\n     format_settings.tsv.allow_variable_number_of_columns = settings.input_format_tsv_allow_variable_number_of_columns;\n+    format_settings.tsv.crlf_end_of_line_input = settings.input_format_tsv_crlf_end_of_line;\n     format_settings.values.accurate_types_of_literals = settings.input_format_values_accurate_types_of_literals;\n     format_settings.values.allow_data_after_semicolon = settings.input_format_values_allow_data_after_semicolon;\n     format_settings.values.deduce_templates_of_expressions = settings.input_format_values_deduce_templates_of_expressions;\ndiff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h\nindex 2964158c9d84..bf3269bd42d4 100644\n--- a/src/Formats/FormatSettings.h\n+++ b/src/Formats/FormatSettings.h\n@@ -362,6 +362,7 @@ struct FormatSettings\n         bool try_detect_header = true;\n         bool skip_trailing_empty_lines = false;\n         bool allow_variable_number_of_columns = false;\n+        bool crlf_end_of_line_input = false;\n     } tsv{};\n \n     struct\ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex 8c83eac5cff7..5518f2ebc406 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -352,7 +352,6 @@ static ReturnType parseComplexEscapeSequence(Vector & s, ReadBuffer & buf)\n         {\n             return error(\"Cannot parse escape sequence\", ErrorCodes::CANNOT_PARSE_ESCAPE_SEQUENCE);\n         }\n-\n         s.push_back(unhex2(hex_code));\n     }\n     else if (char_after_backslash == 'N')\n@@ -608,13 +607,20 @@ static ReturnType parseJSONEscapeSequence(Vector & s, ReadBuffer & buf, bool kee\n }\n \n \n-template <typename Vector, bool parse_complex_escape_sequence>\n+template <typename Vector, bool parse_complex_escape_sequence, bool support_crlf>\n void readEscapedStringIntoImpl(Vector & s, ReadBuffer & buf)\n {\n     while (!buf.eof())\n     {\n-        char * next_pos = find_first_symbols<'\\t', '\\n', '\\\\'>(buf.position(), buf.buffer().end());\n-\n+        char * next_pos;\n+        if constexpr (support_crlf)\n+        {\n+            next_pos = find_first_symbols<'\\t', '\\n', '\\\\','\\r'>(buf.position(), buf.buffer().end());\n+        }\n+        else\n+        {\n+            next_pos = find_first_symbols<'\\t', '\\n', '\\\\'>(buf.position(), buf.buffer().end());\n+        }\n         appendToStringOrVector(s, buf, next_pos);\n         buf.position() = next_pos;\n \n@@ -641,25 +647,46 @@ void readEscapedStringIntoImpl(Vector & s, ReadBuffer & buf)\n                 }\n             }\n         }\n+\n+        if constexpr (support_crlf)\n+        {\n+            if (*buf.position() == '\\r')\n+            {\n+                ++buf.position();\n+                if (!buf.eof() && *buf.position() != '\\n')\n+                {\n+                    s.push_back('\\r');\n+                    continue;\n+                }\n+                return;\n+            }\n+        }\n     }\n }\n \n-template <typename Vector>\n+template <typename Vector, bool support_crlf>\n void readEscapedStringInto(Vector & s, ReadBuffer & buf)\n {\n-    readEscapedStringIntoImpl<Vector, true>(s, buf);\n+    readEscapedStringIntoImpl<Vector, true, support_crlf>(s, buf);\n }\n \n \n void readEscapedString(String & s, ReadBuffer & buf)\n {\n     s.clear();\n-    readEscapedStringInto(s, buf);\n+    readEscapedStringInto<String,false>(s, buf);\n }\n \n-template void readEscapedStringInto<PaddedPODArray<UInt8>>(PaddedPODArray<UInt8> & s, ReadBuffer & buf);\n-template void readEscapedStringInto<NullOutput>(NullOutput & s, ReadBuffer & buf);\n+void readEscapedStringCRLF(String & s, ReadBuffer & buf)\n+{\n+    s.clear();\n+    readEscapedStringInto<String,true>(s, buf);\n+}\n \n+template void readEscapedStringInto<PaddedPODArray<UInt8>,false>(PaddedPODArray<UInt8> & s, ReadBuffer & buf);\n+template void readEscapedStringInto<NullOutput,false>(NullOutput & s, ReadBuffer & buf);\n+template void readEscapedStringInto<PaddedPODArray<UInt8>,true>(PaddedPODArray<UInt8> & s, ReadBuffer & buf);\n+template void readEscapedStringInto<NullOutput,true>(NullOutput & s, ReadBuffer & buf);\n \n /** If enable_sql_style_quoting == true,\n   *  strings like 'abc''def' will be parsed as abc'def.\n@@ -2069,7 +2096,14 @@ bool tryReadJSONField(String & s, ReadBuffer & buf, const FormatSettings::JSON &\n void readTSVField(String & s, ReadBuffer & buf)\n {\n     s.clear();\n-    readEscapedStringIntoImpl<String, false>(s, buf);\n+    readEscapedStringIntoImpl<String, false, false>(s, buf);\n }\n \n+void readTSVFieldCRLF(String & s, ReadBuffer & buf)\n+{\n+    s.clear();\n+    readEscapedStringIntoImpl<String, false, true>(s, buf);\n+}\n+\n+\n }\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 5cf7d3e5b665..7170b12569dc 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -583,6 +583,8 @@ void readString(String & s, ReadBuffer & buf);\n \n void readEscapedString(String & s, ReadBuffer & buf);\n \n+void readEscapedStringCRLF(String & s, ReadBuffer & buf);\n+\n void readQuotedString(String & s, ReadBuffer & buf);\n void readQuotedStringWithSQLStyle(String & s, ReadBuffer & buf);\n \n@@ -645,7 +647,7 @@ void readStringInto(Vector & s, ReadBuffer & buf);\n template <typename Vector>\n void readNullTerminated(Vector & s, ReadBuffer & buf);\n \n-template <typename Vector>\n+template <typename Vector, bool support_crlf>\n void readEscapedStringInto(Vector & s, ReadBuffer & buf);\n \n template <bool enable_sql_style_quoting, typename Vector>\n@@ -1901,6 +1903,7 @@ void readJSONField(String & s, ReadBuffer & buf, const FormatSettings::JSON & se\n bool tryReadJSONField(String & s, ReadBuffer & buf, const FormatSettings::JSON & settings);\n \n void readTSVField(String & s, ReadBuffer & buf);\n+void readTSVFieldCRLF(String & s, ReadBuffer & buf);\n \n /** Parse the escape sequence, which can be simple (one character after backslash) or more complex (multiple characters).\n   * It is assumed that the cursor is located on the `\\` symbol\ndiff --git a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\nindex 5382527fcdcc..4d67bc1a4e9e 100644\n--- a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n@@ -135,7 +135,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n \n                     /// If the key is not found, skip the value.\n                     NullOutput sink;\n-                    readEscapedStringInto(sink, *in);\n+                    readEscapedStringInto<NullOutput,false>(sink, *in);\n                 }\n                 else\n                 {\ndiff --git a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\nindex 09f8fa92e5f1..6d4dcba9e609 100644\n--- a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n@@ -10,6 +10,8 @@\n #include <Formats/verbosePrintString.h>\n #include <Formats/EscapingRuleUtils.h>\n #include <Processors/Formats/Impl/TabSeparatedRowInputFormat.h>\n+#include <boost/range/adaptor/map.hpp>\n+#include \"Formats/FormatSettings.h\"\n \n namespace DB\n {\n@@ -28,7 +30,8 @@ static void checkForCarriageReturn(ReadBuffer & in)\n         throw Exception(ErrorCodes::INCORRECT_DATA, \"\\nYou have carriage return (\\\\r, 0x0D, ASCII 13) at end of first row.\"\n             \"\\nIt's like your input data has DOS/Windows style line separators, that are illegal in TabSeparated format.\"\n             \" You must transform your file to Unix format.\"\n-            \"\\nBut if you really need carriage return at end of string value of last column, you need to escape it as \\\\r.\");\n+            \"\\nBut if you really need carriage return at end of string value of last column, you need to escape it as \\\\r\"\n+            \"\\nor else enable setting 'input_format_tsv_crlf_end_of_line'\");\n }\n \n TabSeparatedRowInputFormat::TabSeparatedRowInputFormat(\n@@ -92,7 +95,12 @@ void TabSeparatedFormatReader::skipRowEndDelimiter()\n     if (buf->eof())\n         return;\n \n-    if (unlikely(first_row))\n+    if (format_settings.tsv.crlf_end_of_line_input)\n+    {\n+        if (*buf->position() == '\\r')\n+            ++buf->position();\n+    }\n+    else if (unlikely(first_row))\n     {\n         checkForCarriageReturn(*buf);\n         first_row = false;\n@@ -105,14 +113,15 @@ template <bool read_string>\n String TabSeparatedFormatReader::readFieldIntoString()\n {\n     String field;\n+    bool support_crlf = format_settings.tsv.crlf_end_of_line_input;\n     if (is_raw)\n         readString(field, *buf);\n     else\n     {\n         if constexpr (read_string)\n-            readEscapedString(field, *buf);\n+            support_crlf ? readEscapedStringCRLF(field, *buf) : readEscapedString(field, *buf);\n         else\n-            readTSVField(field, *buf);\n+            support_crlf ? readTSVFieldCRLF(field, *buf) : readTSVField(field, *buf);\n     }\n     return field;\n }\n@@ -123,7 +132,7 @@ void TabSeparatedFormatReader::skipField()\n     if (is_raw)\n         readStringInto(out, *buf);\n     else\n-        readEscapedStringInto(out, *buf);\n+        format_settings.tsv.crlf_end_of_line_input ? readEscapedStringInto<NullOutput,true>(out, *buf) : readEscapedStringInto<NullOutput,false>(out, *buf);\n }\n \n void TabSeparatedFormatReader::skipHeaderRow()\n@@ -155,7 +164,7 @@ bool TabSeparatedFormatReader::readField(IColumn & column, const DataTypePtr & t\n     const SerializationPtr & serialization, bool is_last_file_column, const String & /*column_name*/)\n {\n     const bool at_delimiter = !is_last_file_column && !buf->eof() && *buf->position() == '\\t';\n-    const bool at_last_column_line_end = is_last_file_column && (buf->eof() || *buf->position() == '\\n');\n+    const bool at_last_column_line_end = is_last_file_column && (buf->eof() || *buf->position() == '\\n' || (format_settings.tsv.crlf_end_of_line_input && *buf->position() == '\\r'));\n \n     if (format_settings.tsv.empty_as_default && (at_delimiter || at_last_column_line_end))\n     {\n@@ -220,7 +229,10 @@ bool TabSeparatedFormatReader::parseRowEndWithDiagnosticInfo(WriteBuffer & out)\n \n     try\n     {\n-        assertChar('\\n', *buf);\n+        if (!format_settings.tsv.crlf_end_of_line_input)\n+            assertChar('\\n', *buf);\n+        else\n+            assertChar('\\r', *buf);\n     }\n     catch (const DB::Exception &)\n     {\n@@ -233,7 +245,10 @@ bool TabSeparatedFormatReader::parseRowEndWithDiagnosticInfo(WriteBuffer & out)\n         else if (*buf->position() == '\\r')\n         {\n             out << \"ERROR: Carriage return found where line feed is expected.\"\n-                   \" It's like your file has DOS/Windows style line separators, that is illegal in TabSeparated format.\\n\";\n+                   \" It's like your file has DOS/Windows style line separators. \\n\"\n+                   \"You must transform your file to Unix format. \\n\"\n+                   \"But if you really need carriage return at end of string value of last column, you need to escape it as \\\\r \\n\"\n+                   \"or else enable setting 'input_format_tsv_crlf_end_of_line'\";\n         }\n         else\n         {\n@@ -348,7 +363,7 @@ void TabSeparatedFormatReader::skipRow()\n \n bool TabSeparatedFormatReader::checkForEndOfRow()\n {\n-    return buf->eof() || *buf->position() == '\\n';\n+    return buf->eof() || *buf->position() == '\\n' || (format_settings.tsv.crlf_end_of_line_input && *buf->position() == '\\r');\n }\n \n TabSeparatedSchemaReader::TabSeparatedSchemaReader(\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.reference b/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.reference\nnew file mode 100644\nindex 000000000000..88d203bd7238\n--- /dev/null\n+++ b/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.reference\n@@ -0,0 +1,11 @@\n+<-- Read UNIX endings -->\n+\n+Akiba_Hebrew_Academy\t2017-08-01\t241\n+Aegithina_tiphia\t2018-02-01\t34\n+1971-72_Utah_Stars_season\t2016-10-01\t1\n+\n+<-- Read DOS endings with setting input_format_tsv_crlf_end_of_line=1 -->\n+\n+Akiba_Hebrew_Academy\t2017-08-01\t241\n+Aegithina_tiphia\t2018-02-01\t34\n+1971-72_Utah_Stars_season\t2016-10-01\t1\ndiff --git a/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.sh b/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.sh\nnew file mode 100755\nindex 000000000000..14f28f1ba4af\n--- /dev/null\n+++ b/tests/queries/0_stateless/02973_parse_crlf_with_tsv_files.sh\n@@ -0,0 +1,29 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+# Data preparation step\n+USER_FILES_PATH=$($CLICKHOUSE_CLIENT_BINARY --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+UNIX_ENDINGS=\"${CLICKHOUSE_TEST_UNIQUE_NAME}_data_without_crlf.tsv\"\n+DOS_ENDINGS=\"${CLICKHOUSE_TEST_UNIQUE_NAME}_data_with_crlf.tsv\"\n+DATA_FILE_UNIX_ENDINGS=\"${USER_FILES_PATH:?}/${UNIX_ENDINGS}\"\n+DATA_FILE_DOS_ENDINGS=\"${USER_FILES_PATH:?}/${DOS_ENDINGS}\"\n+\n+touch $DATA_FILE_UNIX_ENDINGS\n+touch $DATA_FILE_DOS_ENDINGS    \n+\n+echo -ne \"Akiba_Hebrew_Academy\\t2017-08-01\\t241\\nAegithina_tiphia\\t2018-02-01\\t34\\n1971-72_Utah_Stars_season\\t2016-10-01\\t1\\n\" > $DATA_FILE_UNIX_ENDINGS\n+echo -ne \"Akiba_Hebrew_Academy\\t2017-08-01\\t241\\r\\nAegithina_tiphia\\t2018-02-01\\t34\\r\\n1971-72_Utah_Stars_season\\t2016-10-01\\t1\\r\\n\" > $DATA_FILE_DOS_ENDINGS\n+\n+echo -e \"<-- Read UNIX endings -->\\n\"\n+$CLICKHOUSE_CLIENT --query \"SELECT * FROM file(${UNIX_ENDINGS}, 'TabSeparated', 'SearchTerm String, Date Date, Hits UInt32');\" \n+$CLICKHOUSE_CLIENT --multiquery --query \"SELECT * FROM file(${DOS_ENDINGS}, 'TabSeparated', 'SearchTerm String, Date Date, Hits UInt32'); --{serverError 117}\" \n+\n+echo -e \"\\n<-- Read DOS endings with setting input_format_tsv_crlf_end_of_line=1 -->\\n\"\n+$CLICKHOUSE_CLIENT --query \"SELECT * FROM file(${DOS_ENDINGS}, 'TabSeparated', 'SearchTerm String, Date Date, Hits UInt32') SETTINGS input_format_tsv_crlf_end_of_line = 1;\"\n+\n+# Test teardown \n+rm $DATA_FILE_UNIX_ENDINGS\n+rm $DATA_FILE_DOS_ENDINGS\n",
  "problem_statement": "Add a setting to parse crlf with Tab separated CSV (TSV?!) files\nNot sure if this is a feature or usability, so feel free to re-label. \r\n\r\nI have a tab separated file with windows line endings, which means it doesn't work correctly with any of the TSV formats. It will process with the CSV ones:\r\n\r\n```\r\nFROM file(\r\n     'data/Stock Histories.zip :: {NASDAQ,NYSE}.txt', \r\n     CSVWithNames\r\n)\r\nSELECT *, _file\r\nORDER BY rand()\r\nLIMIT 10;\r\n```\r\n\r\nBut then every field is inside one row and I have to do a split on tab to separate them.\r\n\r\n@alexey-milovidov said maybe we could add a setting:\r\n\r\n> TSV does not have quoting, and escaping of \\r is not mandatory, so the interpretation of crlf will be ambiguous if you have a binary string.\r\n> We can add it under a setting\u2026\n",
  "hints_text": "@Avogar I'll work on this one ",
  "created_at": "2024-02-08T06:34:36Z"
}