diff --git a/tests/integration/test_postgresql_protocol/test.py b/tests/integration/test_postgresql_protocol/test.py
index 52c911cb9391..3436fc5bace4 100644
--- a/tests/integration/test_postgresql_protocol/test.py
+++ b/tests/integration/test_postgresql_protocol/test.py
@@ -120,7 +120,7 @@ def test_python_client(server_address):
         cur.execute('select name from tables;')
 
     assert exc_info.value.args == (
-        "Query execution failed.
DB::Exception: Table default.tables doesn't exist.
SSL connection has been closed unexpectedly
",)
+        "Query execution failed.
DB::Exception: Table default.tables doesn't exist
SSL connection has been closed unexpectedly
",)
 
     ch = py_psql.connect(host=server_address, port=server_port, user='default', password='123', database='')
     cur = ch.cursor()
diff --git a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference
index 1fca8dab675b..e362d692f42d 100644
--- a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference
+++ b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference
@@ -1,5 +1,5 @@
 122
 
-Table dictdb.dict_invalidate doesn\'t exist.
+Table dictdb.dict_invalidate doesn\'t exist
 
 133
diff --git a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh
index 3dd3c0ee3632..18f040329332 100755
--- a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh
+++ b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh
@@ -51,7 +51,7 @@ function check_exception_detected()
 export -f check_exception_detected;
 timeout 30 bash -c check_exception_detected 2> /dev/null
 
-$CLICKHOUSE_CLIENT --query "SELECT last_exception FROM system.dictionaries WHERE database = 'dictdb' AND name = 'invalidate'" 2>&1 | grep -Eo "Table dictdb.dict_invalidate .* exist."
+$CLICKHOUSE_CLIENT --query "SELECT last_exception FROM system.dictionaries WHERE database = 'dictdb' AND name = 'invalidate'" 2>&1 | grep -Eo "Table dictdb.dict_invalidate .* exist"
 
 $CLICKHOUSE_CLIENT --query "
 CREATE TABLE dictdb.dict_invalidate
diff --git a/tests/queries/0_stateless/01600_detach_permanently.reference b/tests/queries/0_stateless/01600_detach_permanently.reference
new file mode 100644
index 000000000000..98ed3b6762d7
--- /dev/null
+++ b/tests/queries/0_stateless/01600_detach_permanently.reference
@@ -0,0 +1,102 @@
+##################
+setup env
+##################
+db_ordinary.log_table 1
+>table detached!
+db_ordinary.log_table 2
+>Table is back after restart
+10
+db_ordinary.log_table 3
+>table detached (permanently)!
+db_ordinary.log_table 4
+>table is still detached (after restart)!
+db_ordinary.log_table 5
+>Table is back after attach
+db_ordinary.log_table 6
+10
+##################
+db_ordinary.mt_table 1
+>table detached!
+db_ordinary.mt_table 2
+>Table is back after restart
+10
+db_ordinary.mt_table 3
+>table detached (permanently)!
+db_ordinary.mt_table 4
+>table is still detached (after restart)!
+db_ordinary.mt_table 5
+>Table is back after attach
+db_ordinary.mt_table 6
+10
+##################
+db_ordinary.null_table 1
+>table detached!
+db_ordinary.null_table 2
+>Table is back after restart
+0
+db_ordinary.null_table 3
+>table detached (permanently)!
+db_ordinary.null_table 4
+>table is still detached (after restart)!
+db_ordinary.null_table 5
+>Table is back after attach
+db_ordinary.null_table 6
+0
+##################
+db_atomic.log_table 1
+>table detached!
+db_atomic.log_table 2
+>Table is back after restart
+10
+db_atomic.log_table 3
+>table detached (permanently)!
+db_atomic.log_table 4
+>table is still detached (after restart)!
+db_atomic.log_table 5
+>Table is back after attach
+db_atomic.log_table 6
+10
+##################
+db_atomic.mt_table 1
+>table detached!
+db_atomic.mt_table 2
+>Table is back after restart
+10
+db_atomic.mt_table 3
+>table detached (permanently)!
+db_atomic.mt_table 4
+>table is still detached (after restart)!
+db_atomic.mt_table 5
+>Table is back after attach
+db_atomic.mt_table 6
+10
+##################
+db_atomic.null_table 1
+>table detached!
+db_atomic.null_table 2
+>Table is back after restart
+0
+db_atomic.null_table 3
+>table detached (permanently)!
+db_atomic.null_table 4
+>table is still detached (after restart)!
+db_atomic.null_table 5
+>Table is back after attach
+db_atomic.null_table 6
+0
+##################
+test for MV
+MV is working
+Usual detach works immediately till restart
+Usual detach activates after restart
+Permanent detach works immediately
+Permanent detach still works after restart
+View can be reattached
+##################
+test for MV with inner table
+MV is working
+1
+View can be reattached
+##################
+DETACH DATABASE is not implemented (proper error)
+1
diff --git a/tests/queries/0_stateless/01600_detach_permanently.sh b/tests/queries/0_stateless/01600_detach_permanently.sh
new file mode 100755
index 000000000000..e897f80a33f7
--- /dev/null
+++ b/tests/queries/0_stateless/01600_detach_permanently.sh
@@ -0,0 +1,125 @@
+#!/usr/bin/env bash
+
+CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
+. "$CURDIR"/../shell_config.sh
+
+## tests with real clickhouse restart would be a bit to heavy,
+## to ensure the table will not reappear back clickhose-local is enough.
+
+WORKING_FOLDER_01600="${CLICKHOUSE_TMP}/01600_detach_permanently"
+rm -rf "${WORKING_FOLDER_01600}"
+mkdir -p "${WORKING_FOLDER_01600}"
+
+clickhouse_local() {
+    local query="$1"
+    shift
+    ${CLICKHOUSE_LOCAL} --query "$query" $@ -- --path="${WORKING_FOLDER_01600}"
+}
+
+test_detach_attach_sequence() {
+    local db="$1"
+    local table="$2"
+    echo "##################"
+
+    echo "${db}.${table} 1"
+    # normal DETACH - while process is running (clickhouse-local here, same for server) table is detached.
+    clickhouse_local "DETACH TABLE ${db}.${table}; SELECT if( count() = 0, '>table detached!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';"
+
+    # but once we restart the precess (either clickhouse-local either clickhouse server) the table is back.
+    echo "${db}.${table} 2"
+    clickhouse_local "SELECT if(name='${table}', '>Table is back after restart', '>fail') FROM system.tables WHERE database='${db}' AND name='${table}'; SELECT count() FROM ${db}.${table};"
+
+    # permanent DETACH - table is detached, and metadata file renamed, prevening further attach
+    echo "${db}.${table} 3"
+    clickhouse_local "DETACH TABLE ${db}.${table} PERMANENTLY; SELECT if( count() = 0, '>table detached (permanently)!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';"
+
+    # still detached after restart
+    echo "${db}.${table} 4"
+    clickhouse_local "SELECT if( count() = 0, '>table is still detached (after restart)!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';"
+
+    # but can be reattached
+    echo "${db}.${table} 5"
+    clickhouse_local "ATTACH TABLE ${db}.${table}; SELECT if(name='${table}', '>Table is back after attach', '>fail') FROM system.tables WHERE database='${db}' AND name='${table}';"
+
+    echo "${db}.${table} 6"
+    clickhouse_local "SELECT count() FROM ${db}.${table};"
+}
+
+echo "##################"
+echo "setup env"
+
+clickhouse_local "DROP DATABASE IF EXISTS db_ordinary SYNC;"
+clickhouse_local "DROP DATABASE IF EXISTS db_atomic SYNC;"
+
+clickhouse_local "CREATE DATABASE db_ordinary Engine=Ordinary"
+clickhouse_local "CREATE DATABASE db_atomic Engine=Atomic"
+
+clickhouse_local "CREATE TABLE db_ordinary.log_table Engine=Log AS SELECT * FROM numbers(10)"
+clickhouse_local "CREATE TABLE db_ordinary.mt_table Engine=MergeTree ORDER BY tuple() AS SELECT * FROM numbers(10)"
+clickhouse_local "CREATE TABLE db_ordinary.null_table Engine=Null AS SELECT * FROM numbers(10)"
+
+clickhouse_local "CREATE TABLE db_atomic.log_table Engine=Log AS SELECT * FROM numbers(10)"
+clickhouse_local "CREATE TABLE db_atomic.mt_table Engine=MergeTree ORDER BY tuple() AS SELECT * FROM numbers(10)"
+clickhouse_local "CREATE TABLE db_atomic.null_table Engine=Null AS SELECT * FROM numbers(10)"
+
+test_detach_attach_sequence "db_ordinary" "log_table"
+test_detach_attach_sequence "db_ordinary" "mt_table"
+test_detach_attach_sequence "db_ordinary" "null_table"
+
+test_detach_attach_sequence "db_atomic" "log_table"
+test_detach_attach_sequence "db_atomic" "mt_table"
+test_detach_attach_sequence "db_atomic" "null_table"
+
+echo "##################"
+echo "test for MV"
+clickhouse_local "CREATE TABLE db_ordinary.src Engine=Null AS system.numbers"
+clickhouse_local "CREATE TABLE db_ordinary.dst Engine=Log AS system.numbers"
+clickhouse_local "CREATE MATERIALIZED VIEW db_ordinary.src2dst_mv_to TO db_ordinary.dst AS SELECT * FROM db_ordinary.src"
+
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 10, 'MV is working', 'MV failed') from db_ordinary.dst;"
+
+clickhouse_local "DETACH VIEW db_ordinary.src2dst_mv_to; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 10, 'Usual detach works immediately till restart', 'Usual detach failed') from db_ordinary.dst;"
+
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 20, 'Usual detach activates after restart', 'Usual detach reactivation failed') from db_ordinary.dst;"
+
+clickhouse_local "DETACH VIEW db_ordinary.src2dst_mv_to PERMANENTLY; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 20, 'Permanent detach works immediately', 'Permanent detach failed') from db_ordinary.dst;"
+
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 20, 'Permanent detach still works after restart', 'Permanent detach reactivated!') from db_ordinary.dst;"
+
+## Quite silly: ATTACH MATERIALIZED VIEW don't work with short syntax (w/o select), but i can attach it using ATTACH TABLE ...
+clickhouse_local "ATTACH TABLE db_ordinary.src2dst_mv_to"
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 30, 'View can be reattached', 'can not reattach permanently detached view') from db_ordinary.dst;"
+
+clickhouse_local "DROP VIEW db_ordinary.src2dst_mv_to SYNC"
+
+echo "##################"
+echo "test for MV with inner table"
+clickhouse_local "CREATE MATERIALIZED VIEW db_ordinary.src_mv_with_inner Engine=Log AS SELECT * FROM db_ordinary.src"
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+
+clickhouse_local "SELECT if(count() = 10, 'MV is working', 'MV failed') FROM db_ordinary.src_mv_with_inner"
+
+clickhouse_local "DETACH VIEW db_ordinary.src_mv_with_inner PERMANENTLY; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)" --stacktrace
+clickhouse_local "SELECT if(count() = 10, 'MV can be detached permanently', 'MV detach failed') FROM db_ordinary.src_mv_with_inner" 2>&1 | grep -c "db_ordinary.src_mv_with_inner doesn't exist"
+## Quite silly: ATTACH MATERIALIZED VIEW don't work with short syntax (w/o select), but i can attach it using ATTACH TABLE ...
+clickhouse_local "ATTACH TABLE db_ordinary.src_mv_with_inner"
+clickhouse_local "INSERT INTO db_ordinary.src SELECT * FROM numbers(10)"
+clickhouse_local "SELECT if(count() = 20, 'View can be reattached', 'can not reattach permanently detached view') from db_ordinary.src_mv_with_inner;"
+
+## clickhouse_local can't work with dicts...
+# mkdir -p "${WORKING_FOLDER_01600}/user_files"
+# echo "1" > "${WORKING_FOLDER_01600}/user_files/dummy_dict.tsv"
+# clickhouse_local "DROP DICTIONARY db_ordinary.dummy; CREATE DICTIONARY db_ordinary.dummy (id UInt64) PRIMARY KEY id LAYOUT(FLAT()) SOURCE(FILE(path 'dummy_dict.tsv' format 'TabSeparated')) LIFETIME(MIN 1 MAX 10); DETACH DICTIONARY db_ordinary.dummy PERMANENTLY; SELECT dictGet('db_ordinary.dummy','val',toUInt64(1));"
+
+echo "##################"
+echo "DETACH DATABASE is not implemented (proper error)"
+clickhouse_local "DETACH DATABASE db_ordinary PERMANENTLY;" 2>&1 | grep -c 'DETACH PERMANENTLY is not implemented'
+
+# clean up
+rm -rf "${WORKING_FOLDER_01600}"
diff --git a/tests/queries/0_stateless/01601_detach_permanently.reference b/tests/queries/0_stateless/01601_detach_permanently.reference
new file mode 100644
index 000000000000..6683603c9727
--- /dev/null
+++ b/tests/queries/0_stateless/01601_detach_permanently.reference
@@ -0,0 +1,79 @@
+database atomic tests
+can not create table with same name as detached permanently
+can not detach twice
+can not drop detached
+can not replace with the other table
+can still show the create statement
+Row 1:
+──────
+statement: CREATE TABLE test1601_detach_permanently_atomic.test_name_reuse
+(
+    `number` UInt64
+)
+ENGINE = MergeTree
+ORDER BY tuple()
+SETTINGS index_granularity = 8192
+can not attach with bad uuid
+can attach with short syntax
+100
+can not detach permanently the table which is already detached (temporary)
+100
+After database reattachement the table is back (it was detached temporary)
+And we can detach it permanently
+After database reattachement the table is still absent (it was detached permamently)
+And we can not detach it permanently
+But we can attach it back
+And detach permanently again to check how database drop will behave
+DROP database
+-----------------------
+database ordinary tests
+can not create table with same name as detached permanently
+can not detach twice
+can not drop detached
+can not replace with the other table
+can still show the create statement
+Row 1:
+──────
+statement: CREATE TABLE test1601_detach_permanently_ordinary.test_name_reuse
+(
+    `number` UInt64
+)
+ENGINE = MergeTree
+ORDER BY tuple()
+SETTINGS index_granularity = 8192
+can attach with full syntax
+can attach with short syntax
+can not detach permanently the table which is already detached (temporary)
+After database reattachement the table is back (it was detached temporary)
+And we can detach it permanently
+After database reattachement the table is still absent (it was detached permamently)
+And we can not detach it permanently
+But we can attach it back
+And detach permanently again to check how database drop will behave
+DROP database - Directory not empty error, but database deteched
+DROP database - now success
+-----------------------
+database lazy tests
+can not create table with same name as detached permanently
+can not detach twice
+can not drop detached
+can not replace with the other table
+can still show the create statement
+Row 1:
+──────
+statement: CREATE TABLE test1601_detach_permanently_lazy.test_name_reuse
+(
+    `number` UInt64
+)
+ENGINE = Log
+can attach with full syntax
+can attach with short syntax
+can not detach permanently the table which is already detached (temporary)
+After database reattachement the table is back (it was detached temporary)
+And we can detach it permanently
+After database reattachement the table is still absent (it was detached permamently)
+And we can not detach it permanently
+But we can attach it back
+And detach permanently again to check how database drop will behave
+DROP database - Directory not empty error, but database deteched
+DROP database - now success
diff --git a/tests/queries/0_stateless/01601_detach_permanently.sql b/tests/queries/0_stateless/01601_detach_permanently.sql
new file mode 100644
index 000000000000..0e21fd8f463b
--- /dev/null
+++ b/tests/queries/0_stateless/01601_detach_permanently.sql
@@ -0,0 +1,214 @@
+SELECT 'database atomic tests';
+
+DROP DATABASE IF EXISTS test1601_detach_permanently_atomic;
+CREATE DATABASE test1601_detach_permanently_atomic Engine=Atomic;
+
+create table test1601_detach_permanently_atomic.test_name_reuse (number UInt64) engine=MergeTree order by tuple();
+
+INSERT INTO test1601_detach_permanently_atomic.test_name_reuse SELECT * FROM numbers(100);
+
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;
+
+SELECT 'can not create table with same name as detached permanently';
+create table test1601_detach_permanently_atomic.test_name_reuse (number UInt64) engine=MergeTree order by tuple(); -- { serverError 57 }
+
+SELECT 'can not detach twice';
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }
+DETACH table test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }
+
+SELECT 'can not drop detached';
+drop table test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }
+
+create table test1601_detach_permanently_atomic.test_name_rename_attempt (number UInt64) engine=MergeTree order by tuple();
+
+SELECT 'can not replace with the other table';
+RENAME TABLE test1601_detach_permanently_atomic.test_name_rename_attempt TO test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 57 }
+EXCHANGE TABLES test1601_detach_permanently_atomic.test_name_rename_attempt AND test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }
+
+SELECT 'can still show the create statement';
+SHOW CREATE TABLE test1601_detach_permanently_atomic.test_name_reuse FORMAT Vertical;
+
+SELECT 'can not attach with bad uuid';
+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse UUID '00000000-0000-0000-0000-000000000001'　(`number` UInt64　)　ENGINE = MergeTree　ORDER BY tuple()　SETTINGS index_granularity = 8192 ;  -- { serverError 57 }
+
+SELECT 'can attach with short syntax';
+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse;
+
+SELECT count() FROM test1601_detach_permanently_atomic.test_name_reuse;
+
+DETACH table test1601_detach_permanently_atomic.test_name_reuse;
+
+SELECT 'can not detach permanently the table which is already detached (temporary)';
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+DETACH DATABASE test1601_detach_permanently_atomic;
+ATTACH DATABASE test1601_detach_permanently_atomic;
+
+SELECT count() FROM test1601_detach_permanently_atomic.test_name_reuse;
+
+SELECT 'After database reattachement the table is back (it was detached temporary)';
+SELECT 'And we can detach it permanently';
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;
+
+DETACH DATABASE test1601_detach_permanently_atomic;
+ATTACH DATABASE test1601_detach_permanently_atomic;
+
+SELECT 'After database reattachement the table is still absent (it was detached permamently)';
+SELECT 'And we can not detach it permanently';
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+SELECT 'But we can attach it back';
+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse;
+
+SELECT 'And detach permanently again to check how database drop will behave';
+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;
+
+SELECT 'DROP database';
+DROP DATABASE test1601_detach_permanently_atomic SYNC;
+
+SELECT '-----------------------';
+SELECT 'database ordinary tests';
+
+DROP DATABASE IF EXISTS test1601_detach_permanently_ordinary;
+CREATE DATABASE test1601_detach_permanently_ordinary Engine=Ordinary;
+
+create table test1601_detach_permanently_ordinary.test_name_reuse (number UInt64) engine=MergeTree order by tuple();
+
+INSERT INTO test1601_detach_permanently_ordinary.test_name_reuse SELECT * FROM numbers(100);
+
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;
+
+SELECT 'can not create table with same name as detached permanently';
+create table test1601_detach_permanently_ordinary.test_name_reuse (number UInt64) engine=MergeTree order by tuple(); -- { serverError 57 }
+
+SELECT 'can not detach twice';
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 60 }
+
+SELECT 'can not drop detached';
+drop table test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 60 }
+
+create table test1601_detach_permanently_ordinary.test_name_rename_attempt (number UInt64) engine=MergeTree order by tuple();
+
+SELECT 'can not replace with the other table';
+RENAME TABLE test1601_detach_permanently_ordinary.test_name_rename_attempt TO test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 57 }
+
+SELECT 'can still show the create statement';
+SHOW CREATE TABLE test1601_detach_permanently_ordinary.test_name_reuse FORMAT Vertical;
+
+SELECT 'can attach with full syntax';
+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse (`number` UInt64　)　ENGINE = MergeTree　ORDER BY tuple()　SETTINGS index_granularity = 8192;
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;
+
+SELECT 'can attach with short syntax';
+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;
+
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse;
+
+SELECT 'can not detach permanently the table which is already detached (temporary)';
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+DETACH DATABASE test1601_detach_permanently_ordinary;
+ATTACH DATABASE test1601_detach_permanently_ordinary;
+
+SELECT 'After database reattachement the table is back (it was detached temporary)';
+SELECT 'And we can detach it permanently';
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;
+
+DETACH DATABASE test1601_detach_permanently_ordinary;
+ATTACH DATABASE test1601_detach_permanently_ordinary;
+
+SELECT 'After database reattachement the table is still absent (it was detached permamently)';
+SELECT 'And we can not detach it permanently';
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+SELECT 'But we can attach it back';
+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;
+
+SELECT 'And detach permanently again to check how database drop will behave';
+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;
+
+SELECT 'DROP database - Directory not empty error, but database deteched';
+DROP DATABASE test1601_detach_permanently_ordinary; -- { serverError 1000 }
+
+ATTACH DATABASE test1601_detach_permanently_ordinary;
+
+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;
+DROP TABLE test1601_detach_permanently_ordinary.test_name_reuse;
+
+SELECT 'DROP database - now success';
+DROP DATABASE test1601_detach_permanently_ordinary;
+
+
+SELECT '-----------------------';
+SELECT 'database lazy tests';
+
+DROP DATABASE IF EXISTS test1601_detach_permanently_lazy;
+CREATE DATABASE test1601_detach_permanently_lazy Engine=Lazy(10);
+
+create table test1601_detach_permanently_lazy.test_name_reuse (number UInt64) engine=Log;
+
+INSERT INTO test1601_detach_permanently_lazy.test_name_reuse SELECT * FROM numbers(100);
+
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;
+
+SELECT 'can not create table with same name as detached permanently';
+create table test1601_detach_permanently_lazy.test_name_reuse (number UInt64) engine=Log; -- { serverError 57 }
+
+SELECT 'can not detach twice';
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }
+DETACH table test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 60 }
+
+SELECT 'can not drop detached';
+drop table test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 60 }
+
+create table test1601_detach_permanently_lazy.test_name_rename_attempt (number UInt64) engine=Log;
+
+SELECT 'can not replace with the other table';
+RENAME TABLE test1601_detach_permanently_lazy.test_name_rename_attempt TO test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 57 }
+
+SELECT 'can still show the create statement';
+SHOW CREATE TABLE test1601_detach_permanently_lazy.test_name_reuse FORMAT Vertical;
+
+SELECT 'can attach with full syntax';
+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse (`number` UInt64　)　ENGINE = Log;
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;
+
+SELECT 'can attach with short syntax';
+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;
+
+DETACH table test1601_detach_permanently_lazy.test_name_reuse;
+
+SELECT 'can not detach permanently the table which is already detached (temporary)';
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+DETACH DATABASE test1601_detach_permanently_lazy;
+ATTACH DATABASE test1601_detach_permanently_lazy;
+
+SELECT 'After database reattachement the table is back (it was detached temporary)';
+SELECT 'And we can detach it permanently';
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;
+
+DETACH DATABASE test1601_detach_permanently_lazy;
+ATTACH DATABASE test1601_detach_permanently_lazy;
+
+SELECT 'After database reattachement the table is still absent (it was detached permamently)';
+SELECT 'And we can not detach it permanently';
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }
+
+SELECT 'But we can attach it back';
+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;
+
+SELECT 'And detach permanently again to check how database drop will behave';
+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;
+
+SELECT 'DROP database - Directory not empty error, but database deteched';
+DROP DATABASE test1601_detach_permanently_lazy; -- { serverError 1000 }
+
+ATTACH DATABASE test1601_detach_permanently_lazy;
+
+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;
+DROP TABLE test1601_detach_permanently_lazy.test_name_reuse;
+
+SELECT 'DROP database - now success';
+DROP DATABASE test1601_detach_permanently_lazy;
diff --git a/tests/queries/0_stateless/01603_rename_overwrite_bug.reference b/tests/queries/0_stateless/01603_rename_overwrite_bug.reference
new file mode 100644
index 000000000000..2c98ac3d71ab
--- /dev/null
+++ b/tests/queries/0_stateless/01603_rename_overwrite_bug.reference
@@ -0,0 +1,4 @@
+0
+200
+0
+200
diff --git a/tests/queries/0_stateless/01603_rename_overwrite_bug.sql b/tests/queries/0_stateless/01603_rename_overwrite_bug.sql
new file mode 100644
index 000000000000..c857e08b2434
--- /dev/null
+++ b/tests/queries/0_stateless/01603_rename_overwrite_bug.sql
@@ -0,0 +1,22 @@
+DROP database IF EXISTS test_1603_rename_bug_ordinary;
+create database test_1603_rename_bug_ordinary engine=Ordinary;
+create table test_1603_rename_bug_ordinary.foo engine=Memory as select * from numbers(100);
+create table test_1603_rename_bug_ordinary.bar engine=Log as select * from numbers(200);
+detach table test_1603_rename_bug_ordinary.foo;
+rename table test_1603_rename_bug_ordinary.bar to test_1603_rename_bug_ordinary.foo; -- { serverError 57 }
+attach table test_1603_rename_bug_ordinary.foo;
+SELECT count() from test_1603_rename_bug_ordinary.foo;
+SELECT count() from test_1603_rename_bug_ordinary.bar;
+DROP DATABASE test_1603_rename_bug_ordinary;
+
+-- was not broken, adding just in case.
+DROP database IF EXISTS test_1603_rename_bug_atomic;
+create database test_1603_rename_bug_atomic engine=Atomic;
+create table test_1603_rename_bug_atomic.foo engine=Memory as select * from numbers(100);
+create table test_1603_rename_bug_atomic.bar engine=Log as select * from numbers(200);
+detach table test_1603_rename_bug_atomic.foo;
+rename table test_1603_rename_bug_atomic.bar to test_1603_rename_bug_atomic.foo; -- { serverError 57 }
+attach table test_1603_rename_bug_atomic.foo;
+SELECT count() from test_1603_rename_bug_atomic.foo;
+SELECT count() from test_1603_rename_bug_atomic.bar;
+DROP DATABASE test_1603_rename_bug_atomic;
