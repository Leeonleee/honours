{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 17642,
  "instance_id": "ClickHouse__ClickHouse-17642",
  "issue_numbers": [
    "13850"
  ],
  "base_commit": "dd2ae6926dd3ef82176146c75d5f437c1c0a8a67",
  "patch": "diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex f9cc7a4197b3..17a91a1fff97 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -217,6 +217,9 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n     if (is_dictionary && !inside_database)\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot move dictionary to other database\");\n \n+    if (!exchange)\n+        other_db.checkMetadataFilenameAvailabilityUnlocked(to_table_name, inside_database ? db_lock : other_db_lock);\n+\n     StoragePtr table = getTableUnlocked(table_name, db_lock);\n     table->checkTableCanBeRenamed();\n     assert_can_move_mat_view(table);\ndiff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp\nindex 0119f17f8431..f297bf2c82f2 100644\n--- a/src/Databases/DatabaseLazy.cpp\n+++ b/src/Databases/DatabaseLazy.cpp\n@@ -42,6 +42,14 @@ void DatabaseLazy::loadStoredObjects(\n     iterateMetadataFiles(context, [this](const String & file_name)\n     {\n         const std::string table_name = file_name.substr(0, file_name.size() - 4);\n+\n+        auto detached_permanently_flag = Poco::File(getMetadataPath() + \"/\" + file_name + detached_suffix);\n+        if (detached_permanently_flag.exists())\n+        {\n+            LOG_DEBUG(log, \"Skipping permanently detached table {}.\", backQuote(table_name));\n+            return;\n+        }\n+\n         attachTable(table_name, nullptr, {});\n     });\n }\ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 4f172f0f8deb..2a8276ec6dbf 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -164,20 +164,38 @@ void DatabaseOnDisk::createTable(\n     /// But there is protection from it - see using DDLGuard in InterpreterCreateQuery.\n \n     if (isDictionaryExist(table_name))\n-        throw Exception(\"Dictionary \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" already exists.\",\n-            ErrorCodes::DICTIONARY_ALREADY_EXISTS);\n+        throw Exception(ErrorCodes::DICTIONARY_ALREADY_EXISTS, \"Dictionary {}.{} already exists\", backQuote(getDatabaseName()), backQuote(table_name));\n \n     if (isTableExist(table_name, global_context))\n-        throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n+        throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {}.{} already exists\", backQuote(getDatabaseName()), backQuote(table_name));\n+\n+    String table_metadata_path = getObjectMetadataPath(table_name);\n \n     if (create.attach_short_syntax)\n     {\n         /// Metadata already exists, table was detached\n         attachTable(table_name, table, getTableDataPath(create));\n+        removeDetachedPermanentlyFlag(table_name, table_metadata_path);\n         return;\n     }\n \n-    String table_metadata_path = getObjectMetadataPath(table_name);\n+    if (!create.attach)\n+        checkMetadataFilenameAvailability(table_name);\n+\n+    if (create.attach && Poco::File(table_metadata_path).exists())\n+    {\n+        ASTPtr ast_detached = parseQueryFromMetadata(log, context, table_metadata_path);\n+        auto & create_detached = ast_detached->as<ASTCreateQuery &>();\n+\n+        // either both should be Nil, either values should be equal\n+        if (create.uuid != create_detached.uuid)\n+            throw Exception(\n+                    ErrorCodes::TABLE_ALREADY_EXISTS,\n+                    \"Table {}.{} already exist (detached permanently). To attach it back \"\n+                    \"you need to use short ATTACH syntax or a full statement with the same UUID\",\n+                    backQuote(getDatabaseName()), backQuote(table_name));\n+    }\n+\n     String table_metadata_tmp_path = table_metadata_path + create_suffix;\n     String statement;\n \n@@ -194,6 +212,26 @@ void DatabaseOnDisk::createTable(\n     }\n \n     commitCreateTable(create, table, table_metadata_tmp_path, table_metadata_path);\n+\n+    removeDetachedPermanentlyFlag(table_name, table_metadata_path);\n+}\n+\n+/// If the table was detached permanently we will have a flag file with\n+/// .sql.detached extension, is not needed anymore since we attached the table back\n+void DatabaseOnDisk::removeDetachedPermanentlyFlag(const String & table_name, const String & table_metadata_path) const\n+{\n+    try\n+    {\n+        auto detached_permanently_flag = Poco::File(table_metadata_path + detached_suffix);\n+\n+        if (detached_permanently_flag.exists())\n+            detached_permanently_flag.remove();\n+    }\n+    catch (Exception & e)\n+    {\n+        e.addMessage(\"while trying to remove permanenty detached flag. Table {}.{} may still be marked as permanently detached, and will not be reattached during server restart.\", backQuote(getDatabaseName()), backQuote(table_name));\n+        throw;\n+    }\n }\n \n void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const StoragePtr & table,\n@@ -215,6 +253,22 @@ void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const Stora\n     }\n }\n \n+void DatabaseOnDisk::detachTablePermanently(const String & table_name)\n+{\n+    auto table = detachTable(table_name);\n+\n+    Poco::File detached_permanently_flag(getObjectMetadataPath(table_name) + detached_suffix);\n+    try\n+    {\n+        detached_permanently_flag.createFile();\n+    }\n+    catch (Exception & e)\n+    {\n+        e.addMessage(\"while trying to set permanenty detached flag. Table {}.{} may be reattached during server restart.\", backQuote(getDatabaseName()), backQuote(table_name));\n+        throw;\n+    }\n+}\n+\n void DatabaseOnDisk::dropTable(const Context & context, const String & table_name, bool /*no_delay*/)\n {\n     String table_metadata_path = getObjectMetadataPath(table_name);\n@@ -253,6 +307,27 @@ void DatabaseOnDisk::dropTable(const Context & context, const String & table_nam\n     Poco::File(table_metadata_path_drop).remove();\n }\n \n+void DatabaseOnDisk::checkMetadataFilenameAvailability(const String & to_table_name) const\n+{\n+    std::unique_lock lock(mutex);\n+    checkMetadataFilenameAvailabilityUnlocked(to_table_name, lock);\n+}\n+\n+void DatabaseOnDisk::checkMetadataFilenameAvailabilityUnlocked(const String & to_table_name, std::unique_lock<std::mutex> &) const\n+{\n+    String table_metadata_path = getObjectMetadataPath(to_table_name);\n+\n+    if (Poco::File(table_metadata_path).exists())\n+    {\n+        auto detached_permanently_flag = Poco::File(table_metadata_path + detached_suffix);\n+\n+        if (detached_permanently_flag.exists())\n+            throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {}.{} already exists (detached permanently)\", backQuote(database_name), backQuote(to_table_name));\n+        else\n+            throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {}.{} already exists (detached)\", backQuote(database_name), backQuote(to_table_name));\n+    }\n+}\n+\n void DatabaseOnDisk::renameTable(\n         const Context & context,\n         const String & table_name,\n@@ -299,6 +374,9 @@ void DatabaseOnDisk::renameTable(\n         if (from_atomic_to_ordinary)\n             create.uuid = UUIDHelpers::Nil;\n \n+        if (auto * target_db = dynamic_cast<DatabaseOnDisk *>(&to_database))\n+            target_db->checkMetadataFilenameAvailability(to_table_name);\n+\n         /// Notify the table that it is renamed. It will move data to new path (if it stores data on disk) and update StorageID\n         table->rename(to_database.getTableDataPath(create), StorageID(create));\n     }\n@@ -328,6 +406,8 @@ void DatabaseOnDisk::renameTable(\n     }\n }\n \n+\n+/// It returns create table statement (even if table is detached)\n ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const String & table_name, const Context &, bool throw_on_error) const\n {\n     ASTPtr ast;\n@@ -430,8 +510,11 @@ void DatabaseOnDisk::iterateMetadataFiles(const Context & context, const Iterati\n         if (endsWith(dir_it.name(), \".sql.bak\"))\n             continue;\n \n-        static const char * tmp_drop_ext = \".sql.tmp_drop\";\n-        if (endsWith(dir_it.name(), tmp_drop_ext))\n+        /// Permanently detached table flag\n+        if (endsWith(dir_it.name(), \".sql.detached\"))\n+            continue;\n+\n+        if (endsWith(dir_it.name(), \".sql.tmp_drop\"))\n         {\n             /// There are files that we tried to delete previously\n             metadata_files.emplace(dir_it.name(), false);\ndiff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h\nindex 586491d4d29d..fff2a259911b 100644\n--- a/src/Databases/DatabaseOnDisk.h\n+++ b/src/Databases/DatabaseOnDisk.h\n@@ -39,6 +39,8 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n         const StoragePtr & table,\n         const ASTPtr & query) override;\n \n+    void detachTablePermanently(const String & table_name) override;\n+\n     void dropTable(\n         const Context & context,\n         const String & table_name,\n@@ -67,9 +69,14 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n \n     static ASTPtr parseQueryFromMetadata(Poco::Logger * log, const Context & context, const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false);\n \n+    /// will throw when the table we want to attach already exists (in active / detached / detached permanently form)\n+    void checkMetadataFilenameAvailability(const String & to_table_name) const;\n+    void checkMetadataFilenameAvailabilityUnlocked(const String & to_table_name, std::unique_lock<std::mutex> &) const;\n+\n protected:\n     static constexpr const char * create_suffix = \".tmp\";\n     static constexpr const char * drop_suffix = \".tmp_drop\";\n+    static constexpr const char * detached_suffix = \".detached\";\n \n     using IteratingFunction = std::function<void(const String &)>;\n \n@@ -87,6 +94,9 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n \n     const String metadata_path;\n     const String data_path;\n+\n+private:\n+    void removeDetachedPermanentlyFlag(const String & table_name, const String & table_metadata_path) const;\n };\n \n }\ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex 24e2bdcd6b29..58b4ad72a1b8 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -135,6 +135,19 @@ void DatabaseOrdinary::loadStoredObjects(Context & context, bool has_force_resto\n             {\n                 auto * create_query = ast->as<ASTCreateQuery>();\n                 create_query->database = database_name;\n+\n+                auto detached_permanently_flag = Poco::File(full_path.string() + detached_suffix);\n+                if (detached_permanently_flag.exists())\n+                {\n+                    /// FIXME: even if we don't load the table we can still mark the uuid of it as taken.\n+                    /// if (create_query->uuid != UUIDHelpers::Nil)\n+                    ///     DatabaseCatalog::instance().addUUIDMapping(create_query->uuid);\n+\n+                    const std::string table_name = file_name.substr(0, file_name.size() - 4);\n+                    LOG_DEBUG(log, \"Skipping permanently detached table {}.\", backQuote(table_name));\n+                    return;\n+                }\n+\n                 std::lock_guard lock{file_names_mutex};\n                 file_names[file_name] = ast;\n                 total_dictionaries += create_query->is_dictionary;\ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex 29262318138b..2d3d206162bd 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -72,7 +72,7 @@ StoragePtr DatabaseWithOwnTablesBase::detachTableUnlocked(const String & table_n\n \n     auto it = tables.find(table_name);\n     if (it == tables.end())\n-        throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist.\",\n+        throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist\",\n                         backQuote(database_name), backQuote(table_name));\n     res = it->second;\n     tables.erase(it);\n@@ -157,7 +157,7 @@ StoragePtr DatabaseWithOwnTablesBase::getTableUnlocked(const String & table_name\n     auto it = tables.find(table_name);\n     if (it != tables.end())\n         return it->second;\n-    throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist.\",\n+    throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist\",\n                     backQuote(database_name), backQuote(table_name));\n }\n \ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex 9a0eb8d99695..fc821fcab30f 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -221,6 +221,8 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n     }\n \n     /// Add a table to the database, but do not add it to the metadata. The database may not support this method.\n+    ///\n+    /// Note: ATTACH TABLE statement actually uses createTable method.\n     virtual void attachTable(const String & /*name*/, const StoragePtr & /*table*/, [[maybe_unused]] const String & relative_table_path = {})\n     {\n         throw Exception(\"There is no ATTACH TABLE query for Database\" + getEngineName(), ErrorCodes::NOT_IMPLEMENTED);\n@@ -245,6 +247,13 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n         throw Exception(\"There is no DETACH DICTIONARY query for Database\" + getEngineName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+    /// Forget about the table without deleting it's data, but rename metadata file to prevent reloading it\n+    /// with next restart. The database may not support this method.\n+    virtual void detachTablePermanently(const String & /*name*/)\n+    {\n+        throw Exception(\"There is no DETACH TABLE PERMANENTLY query for Database\" + getEngineName(), ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n     /// Rename the table and possibly move the table to another database.\n     virtual void renameTable(\n         const Context & /*context*/,\ndiff --git a/src/Databases/MySQL/DatabaseConnectionMySQL.cpp b/src/Databases/MySQL/DatabaseConnectionMySQL.cpp\nindex 454830557393..35b016f255b9 100644\n--- a/src/Databases/MySQL/DatabaseConnectionMySQL.cpp\n+++ b/src/Databases/MySQL/DatabaseConnectionMySQL.cpp\n@@ -395,7 +395,7 @@ void DatabaseConnectionMySQL::loadStoredObjects(Context &, bool, bool /*force_at\n     }\n }\n \n-void DatabaseConnectionMySQL::dropTable(const Context &, const String & table_name, bool /*no_delay*/)\n+void DatabaseConnectionMySQL::detachTablePermanently(const String & table_name)\n {\n     std::lock_guard<std::mutex> lock{mutex};\n \n@@ -429,6 +429,11 @@ void DatabaseConnectionMySQL::dropTable(const Context &, const String & table_na\n     table_iter->second.second->is_dropped = true;\n }\n \n+void DatabaseConnectionMySQL::dropTable(const Context &, const String & table_name, bool /*no_delay*/)\n+{\n+    detachTablePermanently(table_name);\n+}\n+\n DatabaseConnectionMySQL::~DatabaseConnectionMySQL()\n {\n     try\ndiff --git a/src/Databases/MySQL/DatabaseConnectionMySQL.h b/src/Databases/MySQL/DatabaseConnectionMySQL.h\nindex d8694e71db23..3e305fcb20df 100644\n--- a/src/Databases/MySQL/DatabaseConnectionMySQL.h\n+++ b/src/Databases/MySQL/DatabaseConnectionMySQL.h\n@@ -72,6 +72,8 @@ class DatabaseConnectionMySQL final : public IDatabase\n \n     StoragePtr detachTable(const String & table_name) override;\n \n+    void detachTablePermanently(const String & table_name) override;\n+\n     void dropTable(const Context &, const String & table_name, bool no_delay) override;\n \n     void attachTable(const String & table_name, const StoragePtr & storage, const String & relative_table_path) override;\ndiff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp\nindex 813918314c6d..e9caaab4ef93 100644\n--- a/src/Interpreters/DatabaseCatalog.cpp\n+++ b/src/Interpreters/DatabaseCatalog.cpp\n@@ -211,7 +211,7 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n     if (!table_id)\n     {\n         if (exception)\n-            exception->emplace(\"Cannot find table: StorageID is empty\", ErrorCodes::UNKNOWN_TABLE);\n+            exception->emplace(ErrorCodes::UNKNOWN_TABLE, \"Cannot find table: StorageID is empty\");\n         return {};\n     }\n \n@@ -223,7 +223,7 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n         {\n             assert(!db_and_table.first && !db_and_table.second);\n             if (exception)\n-                exception->emplace(\"Table \" + table_id.getNameForLogs() + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+                exception->emplace(ErrorCodes::UNKNOWN_TABLE, \"Table {} doesn't exist\", table_id.getNameForLogs());\n             return {};\n         }\n \n@@ -244,7 +244,7 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n         /// If table_id has no UUID, then the name of database was specified by user and table_id was not resolved through context.\n         /// Do not allow access to TEMPORARY_DATABASE because it contains all temporary tables of all contexts and users.\n         if (exception)\n-            exception->emplace(\"Direct access to `\" + String(TEMPORARY_DATABASE) + \"` database is not allowed.\", ErrorCodes::DATABASE_ACCESS_DENIED);\n+            exception->emplace(ErrorCodes::DATABASE_ACCESS_DENIED, \"Direct access to `{}` database is not allowed\", String(TEMPORARY_DATABASE));\n         return {};\n     }\n \n@@ -255,8 +255,7 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n         if (databases.end() == it)\n         {\n             if (exception)\n-                exception->emplace(\"Database \" + backQuoteIfNeed(table_id.getDatabaseName()) + \" doesn't exist\",\n-                                   ErrorCodes::UNKNOWN_DATABASE);\n+                exception->emplace(ErrorCodes::UNKNOWN_DATABASE, \"Database {} doesn't exist\", backQuoteIfNeed(table_id.getDatabaseName()));\n             return {};\n         }\n         database = it->second;\n@@ -264,7 +263,7 @@ DatabaseAndTable DatabaseCatalog::getTableImpl(\n \n     auto table = database->tryGetTable(table_id.table_name, context);\n     if (!table && exception)\n-            exception->emplace(\"Table \" + table_id.getNameForLogs() + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n+            exception->emplace(ErrorCodes::UNKNOWN_TABLE, \"Table {} doesn't exist\", table_id.getNameForLogs());\n     if (!table)\n         database = nullptr;\n \ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex a7edd8dd5cd6..4b2166741a99 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -734,7 +734,7 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n         auto database = DatabaseCatalog::instance().getDatabase(database_name);\n         bool if_not_exists = create.if_not_exists;\n \n-        // Table SQL definition is available even if the table is detached\n+        // Table SQL definition is available even if the table is detached (even permanently)\n         auto query = database->getCreateTableQuery(create.table, context);\n         create = query->as<ASTCreateQuery &>(); // Copy the saved create query, but use ATTACH instead of CREATE\n         if (create.is_dictionary)\ndiff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp\nindex 00039297244d..47bafdbdcb4f 100644\n--- a/src/Interpreters/InterpreterDropQuery.cpp\n+++ b/src/Interpreters/InterpreterDropQuery.cpp\n@@ -30,6 +30,7 @@ namespace ErrorCodes\n     extern const int SYNTAX_ERROR;\n     extern const int UNKNOWN_TABLE;\n     extern const int UNKNOWN_DICTIONARY;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n \n@@ -55,6 +56,8 @@ BlockIO InterpreterDropQuery::execute()\n     {\n         if (!drop.is_dictionary)\n             return executeToTable(drop);\n+        else if (drop.permanently && drop.kind == ASTDropQuery::Kind::Detach)\n+            throw Exception(\"DETACH PERMANENTLY is not implemented for dictionaries\", ErrorCodes::NOT_IMPLEMENTED);\n         else\n             return executeToDictionary(drop.database, drop.table, drop.kind, drop.if_exists, drop.temporary, drop.no_ddl_lock);\n     }\n@@ -128,8 +131,18 @@ BlockIO InterpreterDropQuery::executeToTableImpl(const ASTDropQuery & query, Dat\n             TableExclusiveLockHolder table_lock;\n             if (database->getUUID() == UUIDHelpers::Nil)\n                 table_lock = table->lockExclusively(context.getCurrentQueryId(), context.getSettingsRef().lock_acquire_timeout);\n-            /// Drop table from memory, don't touch data and metadata\n-            database->detachTable(table_id.table_name);\n+\n+            if (query.permanently)\n+            {\n+                /// Drop table from memory, don't touch data, metadata file renamed and will be skipped during server restart\n+                database->detachTablePermanently(table_id.table_name);\n+            }\n+            else\n+            {\n+                /// Drop table from memory, don't touch data and metadata\n+                database->detachTable(table_id.table_name);\n+            }\n+\n         }\n         else if (query.kind == ASTDropQuery::Kind::Truncate)\n         {\n@@ -286,6 +299,9 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,\n             bool drop = query.kind == ASTDropQuery::Kind::Drop;\n             context.checkAccess(AccessType::DROP_DATABASE, database_name);\n \n+            if (query.kind == ASTDropQuery::Kind::Detach && query.permanently)\n+                throw Exception(\"DETACH PERMANENTLY is not implemented for databases\", ErrorCodes::NOT_IMPLEMENTED);\n+\n #if USE_MYSQL\n             if (database->getEngineName() == \"MaterializeMySQL\")\n                 stopDatabaseSynchronization(database);\ndiff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp\nindex bb476999f8c9..71d3c7e6e5b9 100644\n--- a/src/Interpreters/loadMetadata.cpp\n+++ b/src/Interpreters/loadMetadata.cpp\n@@ -108,6 +108,7 @@ void loadMetadata(Context & context, const String & default_database_name)\n \n         if (!it->isDirectory())\n         {\n+            /// TODO: DETACH DATABASE PERMANENTLY ?\n             if (endsWith(it.name(), \".sql\"))\n             {\n                 String db_name = it.name().substr(0, it.name().size() - 4);\ndiff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp\nindex b09b588ca6eb..6ea6c81c3be8 100644\n--- a/src/Parsers/ASTDropQuery.cpp\n+++ b/src/Parsers/ASTDropQuery.cpp\n@@ -67,6 +67,9 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n \n     formatOnCluster(settings);\n \n+    if (permanently)\n+        settings.ostr << \" PERMANENTLY\";\n+\n     if (no_delay)\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" NO DELAY\" << (settings.hilite ? hilite_none : \"\");\n }\ndiff --git a/src/Parsers/ASTDropQuery.h b/src/Parsers/ASTDropQuery.h\nindex 5096975c219f..b612618aaec2 100644\n--- a/src/Parsers/ASTDropQuery.h\n+++ b/src/Parsers/ASTDropQuery.h\n@@ -33,6 +33,9 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu\n \n     bool no_delay{false};\n \n+    // We detach the object permanently, so it will not be reattached back during server restart.\n+    bool permanently{false};\n+\n     /** Get the text that identifies this element. */\n     String getID(char) const override;\n     ASTPtr clone() const override;\ndiff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp\nindex e09642e7b84b..5400f33fbd93 100644\n--- a/src/Parsers/ParserDropQuery.cpp\n+++ b/src/Parsers/ParserDropQuery.cpp\n@@ -11,7 +11,7 @@ namespace DB\n namespace\n {\n \n-bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool optional_table_keyword = false)\n+bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, const ASTDropQuery::Kind kind)\n {\n     ParserKeyword s_temporary(\"TEMPORARY\");\n     ParserKeyword s_table(\"TABLE\");\n@@ -21,6 +21,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n     ParserToken s_dot(TokenType::Dot);\n     ParserKeyword s_if_exists(\"IF EXISTS\");\n     ParserIdentifier name_p;\n+    ParserKeyword s_permanently(\"PERMANENTLY\");\n     ParserKeyword s_no_delay(\"NO DELAY\");\n     ParserKeyword s_sync(\"SYNC\");\n \n@@ -32,6 +33,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n     bool is_dictionary = false;\n     bool is_view = false;\n     bool no_delay = false;\n+    bool permanently = false;\n \n     if (s_database.ignore(pos, expected))\n     {\n@@ -40,15 +42,6 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n \n         if (!name_p.parse(pos, database, expected))\n             return false;\n-\n-        if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n-        {\n-            if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n-                return false;\n-        }\n-\n-        if (s_no_delay.ignore(pos, expected) || s_sync.ignore(pos, expected))\n-            no_delay = true;\n     }\n     else\n     {\n@@ -59,7 +52,8 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n         else if (s_temporary.ignore(pos, expected))\n             temporary = true;\n \n-        if (!is_view && !is_dictionary && (!s_table.ignore(pos, expected) && !optional_table_keyword))\n+        /// for TRUNCATE queries TABLE keyword is assumed as default and can be skipped\n+        if (!is_view && !is_dictionary && (!s_table.ignore(pos, expected) && kind != ASTDropQuery::Kind::Truncate))\n         {\n             return false;\n         }\n@@ -76,26 +70,32 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n             if (!name_p.parse(pos, table, expected))\n                 return false;\n         }\n+    }\n \n-        if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n-        {\n-            if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n-                return false;\n-        }\n-\n-        if (s_no_delay.ignore(pos, expected) || s_sync.ignore(pos, expected))\n-            no_delay = true;\n+    /// common for tables / dictionaries / databases\n+    if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+    {\n+        if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n+            return false;\n     }\n \n+    if (kind == ASTDropQuery::Kind::Detach && s_permanently.ignore(pos, expected))\n+        permanently = true;\n+\n+    /// actually for TRUNCATE NO DELAY / SYNC means nothing\n+    if (s_no_delay.ignore(pos, expected) || s_sync.ignore(pos, expected))\n+        no_delay = true;\n+\n     auto query = std::make_shared<ASTDropQuery>();\n     node = query;\n \n-    query->kind = ASTDropQuery::Kind::Drop;\n+    query->kind = kind;\n     query->if_exists = if_exists;\n     query->temporary = temporary;\n     query->is_dictionary = is_dictionary;\n     query->is_view = is_view;\n     query->no_delay = no_delay;\n+    query->permanently = permanently;\n \n     tryGetIdentifierNameInto(database, query->database);\n     tryGetIdentifierNameInto(table, query->table);\n@@ -105,28 +105,6 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, bool\n     return true;\n }\n \n-bool parseDetachQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    if (parseDropQuery(pos, node, expected))\n-    {\n-        auto * drop_query = node->as<ASTDropQuery>();\n-        drop_query->kind = ASTDropQuery::Kind::Detach;\n-        return true;\n-    }\n-    return false;\n-}\n-\n-bool parseTruncateQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    if (parseDropQuery(pos, node, expected, true))\n-    {\n-        auto * drop_query = node->as<ASTDropQuery>();\n-        drop_query->kind = ASTDropQuery::Kind::Truncate;\n-        return true;\n-    }\n-    return false;\n-}\n-\n }\n \n bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n@@ -136,11 +114,11 @@ bool ParserDropQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_truncate(\"TRUNCATE\");\n \n     if (s_drop.ignore(pos, expected))\n-        return parseDropQuery(pos, node, expected);\n+        return parseDropQuery(pos, node, expected, ASTDropQuery::Kind::Drop);\n     else if (s_detach.ignore(pos, expected))\n-        return parseDetachQuery(pos, node, expected);\n+        return parseDropQuery(pos, node, expected, ASTDropQuery::Kind::Detach);\n     else if (s_truncate.ignore(pos, expected))\n-        return parseTruncateQuery(pos, node, expected);\n+        return parseDropQuery(pos, node, expected, ASTDropQuery::Kind::Truncate);\n     else\n         return false;\n }\ndiff --git a/src/Parsers/ParserDropQuery.h b/src/Parsers/ParserDropQuery.h\nindex 069b9c34ddd9..39ff5b7c4fd9 100644\n--- a/src/Parsers/ParserDropQuery.h\n+++ b/src/Parsers/ParserDropQuery.h\n@@ -8,7 +8,7 @@ namespace DB\n {\n \n /** Query like this:\n-  * DROP|DETACH|TRUNCATE TABLE [IF EXISTS] [db.]name\n+  * DROP|DETACH|TRUNCATE TABLE [IF EXISTS] [db.]name [PERMANENTLY]\n   *\n   * Or:\n   * DROP DATABASE [IF EXISTS] db\ndiff --git a/src/Storages/StorageDictionary.cpp b/src/Storages/StorageDictionary.cpp\nindex 4896ace4e7ae..32fe7b4c0264 100644\n--- a/src/Storages/StorageDictionary.cpp\n+++ b/src/Storages/StorageDictionary.cpp\n@@ -121,9 +121,9 @@ StorageDictionary::StorageDictionary(\n void StorageDictionary::checkTableCanBeDropped() const\n {\n     if (location == Location::SameDatabaseAndNameAsDictionary)\n-        throw Exception(\"Cannot detach dictionary \" + backQuote(dictionary_name) + \" as table, use DETACH DICTIONARY query\", ErrorCodes::CANNOT_DETACH_DICTIONARY_AS_TABLE);\n+        throw Exception(\"Cannot drop/detach dictionary \" + backQuote(dictionary_name) + \" as table, use DROP DICTIONARY or DETACH DICTIONARY query instead\", ErrorCodes::CANNOT_DETACH_DICTIONARY_AS_TABLE);\n     if (location == Location::DictionaryDatabase)\n-        throw Exception(\"Cannot detach table \" + getStorageID().getFullTableName() + \" from a database with DICTIONARY engine\", ErrorCodes::CANNOT_DETACH_DICTIONARY_AS_TABLE);\n+        throw Exception(\"Cannot drop/detach table \" + getStorageID().getFullTableName() + \" from a database with DICTIONARY engine\", ErrorCodes::CANNOT_DETACH_DICTIONARY_AS_TABLE);\n }\n \n void StorageDictionary::checkTableCanBeDetached() const\n",
  "test_patch": "diff --git a/tests/integration/test_postgresql_protocol/test.py b/tests/integration/test_postgresql_protocol/test.py\nindex 52c911cb9391..3436fc5bace4 100644\n--- a/tests/integration/test_postgresql_protocol/test.py\n+++ b/tests/integration/test_postgresql_protocol/test.py\n@@ -120,7 +120,7 @@ def test_python_client(server_address):\n         cur.execute('select name from tables;')\n \n     assert exc_info.value.args == (\n-        \"Query execution failed.\\nDB::Exception: Table default.tables doesn't exist.\\nSSL connection has been closed unexpectedly\\n\",)\n+        \"Query execution failed.\\nDB::Exception: Table default.tables doesn't exist\\nSSL connection has been closed unexpectedly\\n\",)\n \n     ch = py_psql.connect(host=server_address, port=server_port, user='default', password='123', database='')\n     cur = ch.cursor()\ndiff --git a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference\nindex 1fca8dab675b..e362d692f42d 100644\n--- a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference\n+++ b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.reference\n@@ -1,5 +1,5 @@\n 122\n \n-Table dictdb.dict_invalidate doesn\\'t exist.\n+Table dictdb.dict_invalidate doesn\\'t exist\n \n 133\ndiff --git a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh\nindex 3dd3c0ee3632..18f040329332 100755\n--- a/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh\n+++ b/tests/queries/0_stateless/01040_dictionary_invalidate_query_switchover_long.sh\n@@ -51,7 +51,7 @@ function check_exception_detected()\n export -f check_exception_detected;\n timeout 30 bash -c check_exception_detected 2> /dev/null\n \n-$CLICKHOUSE_CLIENT --query \"SELECT last_exception FROM system.dictionaries WHERE database = 'dictdb' AND name = 'invalidate'\" 2>&1 | grep -Eo \"Table dictdb.dict_invalidate .* exist.\"\n+$CLICKHOUSE_CLIENT --query \"SELECT last_exception FROM system.dictionaries WHERE database = 'dictdb' AND name = 'invalidate'\" 2>&1 | grep -Eo \"Table dictdb.dict_invalidate .* exist\"\n \n $CLICKHOUSE_CLIENT --query \"\n CREATE TABLE dictdb.dict_invalidate\ndiff --git a/tests/queries/0_stateless/01600_detach_permanently.reference b/tests/queries/0_stateless/01600_detach_permanently.reference\nnew file mode 100644\nindex 000000000000..98ed3b6762d7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_detach_permanently.reference\n@@ -0,0 +1,102 @@\n+##################\n+setup env\n+##################\n+db_ordinary.log_table 1\n+>table detached!\n+db_ordinary.log_table 2\n+>Table is back after restart\n+10\n+db_ordinary.log_table 3\n+>table detached (permanently)!\n+db_ordinary.log_table 4\n+>table is still detached (after restart)!\n+db_ordinary.log_table 5\n+>Table is back after attach\n+db_ordinary.log_table 6\n+10\n+##################\n+db_ordinary.mt_table 1\n+>table detached!\n+db_ordinary.mt_table 2\n+>Table is back after restart\n+10\n+db_ordinary.mt_table 3\n+>table detached (permanently)!\n+db_ordinary.mt_table 4\n+>table is still detached (after restart)!\n+db_ordinary.mt_table 5\n+>Table is back after attach\n+db_ordinary.mt_table 6\n+10\n+##################\n+db_ordinary.null_table 1\n+>table detached!\n+db_ordinary.null_table 2\n+>Table is back after restart\n+0\n+db_ordinary.null_table 3\n+>table detached (permanently)!\n+db_ordinary.null_table 4\n+>table is still detached (after restart)!\n+db_ordinary.null_table 5\n+>Table is back after attach\n+db_ordinary.null_table 6\n+0\n+##################\n+db_atomic.log_table 1\n+>table detached!\n+db_atomic.log_table 2\n+>Table is back after restart\n+10\n+db_atomic.log_table 3\n+>table detached (permanently)!\n+db_atomic.log_table 4\n+>table is still detached (after restart)!\n+db_atomic.log_table 5\n+>Table is back after attach\n+db_atomic.log_table 6\n+10\n+##################\n+db_atomic.mt_table 1\n+>table detached!\n+db_atomic.mt_table 2\n+>Table is back after restart\n+10\n+db_atomic.mt_table 3\n+>table detached (permanently)!\n+db_atomic.mt_table 4\n+>table is still detached (after restart)!\n+db_atomic.mt_table 5\n+>Table is back after attach\n+db_atomic.mt_table 6\n+10\n+##################\n+db_atomic.null_table 1\n+>table detached!\n+db_atomic.null_table 2\n+>Table is back after restart\n+0\n+db_atomic.null_table 3\n+>table detached (permanently)!\n+db_atomic.null_table 4\n+>table is still detached (after restart)!\n+db_atomic.null_table 5\n+>Table is back after attach\n+db_atomic.null_table 6\n+0\n+##################\n+test for MV\n+MV is working\n+Usual detach works immediately till restart\n+Usual detach activates after restart\n+Permanent detach works immediately\n+Permanent detach still works after restart\n+View can be reattached\n+##################\n+test for MV with inner table\n+MV is working\n+1\n+View can be reattached\n+##################\n+DETACH DATABASE is not implemented (proper error)\n+1\ndiff --git a/tests/queries/0_stateless/01600_detach_permanently.sh b/tests/queries/0_stateless/01600_detach_permanently.sh\nnew file mode 100755\nindex 000000000000..e897f80a33f7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_detach_permanently.sh\n@@ -0,0 +1,125 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+## tests with real clickhouse restart would be a bit to heavy,\n+## to ensure the table will not reappear back clickhose-local is enough.\n+\n+WORKING_FOLDER_01600=\"${CLICKHOUSE_TMP}/01600_detach_permanently\"\n+rm -rf \"${WORKING_FOLDER_01600}\"\n+mkdir -p \"${WORKING_FOLDER_01600}\"\n+\n+clickhouse_local() {\n+    local query=\"$1\"\n+    shift\n+    ${CLICKHOUSE_LOCAL} --query \"$query\" $@ -- --path=\"${WORKING_FOLDER_01600}\"\n+}\n+\n+test_detach_attach_sequence() {\n+    local db=\"$1\"\n+    local table=\"$2\"\n+    echo \"##################\"\n+\n+    echo \"${db}.${table} 1\"\n+    # normal DETACH - while process is running (clickhouse-local here, same for server) table is detached.\n+    clickhouse_local \"DETACH TABLE ${db}.${table}; SELECT if( count() = 0, '>table detached!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';\"\n+\n+    # but once we restart the precess (either clickhouse-local either clickhouse server) the table is back.\n+    echo \"${db}.${table} 2\"\n+    clickhouse_local \"SELECT if(name='${table}', '>Table is back after restart', '>fail') FROM system.tables WHERE database='${db}' AND name='${table}'; SELECT count() FROM ${db}.${table};\"\n+\n+    # permanent DETACH - table is detached, and metadata file renamed, prevening further attach\n+    echo \"${db}.${table} 3\"\n+    clickhouse_local \"DETACH TABLE ${db}.${table} PERMANENTLY; SELECT if( count() = 0, '>table detached (permanently)!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';\"\n+\n+    # still detached after restart\n+    echo \"${db}.${table} 4\"\n+    clickhouse_local \"SELECT if( count() = 0, '>table is still detached (after restart)!', '>Fail') FROM system.tables WHERE database='${db}' AND name='${table}';\"\n+\n+    # but can be reattached\n+    echo \"${db}.${table} 5\"\n+    clickhouse_local \"ATTACH TABLE ${db}.${table}; SELECT if(name='${table}', '>Table is back after attach', '>fail') FROM system.tables WHERE database='${db}' AND name='${table}';\"\n+\n+    echo \"${db}.${table} 6\"\n+    clickhouse_local \"SELECT count() FROM ${db}.${table};\"\n+}\n+\n+echo \"##################\"\n+echo \"setup env\"\n+\n+clickhouse_local \"DROP DATABASE IF EXISTS db_ordinary SYNC;\"\n+clickhouse_local \"DROP DATABASE IF EXISTS db_atomic SYNC;\"\n+\n+clickhouse_local \"CREATE DATABASE db_ordinary Engine=Ordinary\"\n+clickhouse_local \"CREATE DATABASE db_atomic Engine=Atomic\"\n+\n+clickhouse_local \"CREATE TABLE db_ordinary.log_table Engine=Log AS SELECT * FROM numbers(10)\"\n+clickhouse_local \"CREATE TABLE db_ordinary.mt_table Engine=MergeTree ORDER BY tuple() AS SELECT * FROM numbers(10)\"\n+clickhouse_local \"CREATE TABLE db_ordinary.null_table Engine=Null AS SELECT * FROM numbers(10)\"\n+\n+clickhouse_local \"CREATE TABLE db_atomic.log_table Engine=Log AS SELECT * FROM numbers(10)\"\n+clickhouse_local \"CREATE TABLE db_atomic.mt_table Engine=MergeTree ORDER BY tuple() AS SELECT * FROM numbers(10)\"\n+clickhouse_local \"CREATE TABLE db_atomic.null_table Engine=Null AS SELECT * FROM numbers(10)\"\n+\n+test_detach_attach_sequence \"db_ordinary\" \"log_table\"\n+test_detach_attach_sequence \"db_ordinary\" \"mt_table\"\n+test_detach_attach_sequence \"db_ordinary\" \"null_table\"\n+\n+test_detach_attach_sequence \"db_atomic\" \"log_table\"\n+test_detach_attach_sequence \"db_atomic\" \"mt_table\"\n+test_detach_attach_sequence \"db_atomic\" \"null_table\"\n+\n+echo \"##################\"\n+echo \"test for MV\"\n+clickhouse_local \"CREATE TABLE db_ordinary.src Engine=Null AS system.numbers\"\n+clickhouse_local \"CREATE TABLE db_ordinary.dst Engine=Log AS system.numbers\"\n+clickhouse_local \"CREATE MATERIALIZED VIEW db_ordinary.src2dst_mv_to TO db_ordinary.dst AS SELECT * FROM db_ordinary.src\"\n+\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 10, 'MV is working', 'MV failed') from db_ordinary.dst;\"\n+\n+clickhouse_local \"DETACH VIEW db_ordinary.src2dst_mv_to; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 10, 'Usual detach works immediately till restart', 'Usual detach failed') from db_ordinary.dst;\"\n+\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 20, 'Usual detach activates after restart', 'Usual detach reactivation failed') from db_ordinary.dst;\"\n+\n+clickhouse_local \"DETACH VIEW db_ordinary.src2dst_mv_to PERMANENTLY; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 20, 'Permanent detach works immediately', 'Permanent detach failed') from db_ordinary.dst;\"\n+\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 20, 'Permanent detach still works after restart', 'Permanent detach reactivated!') from db_ordinary.dst;\"\n+\n+## Quite silly: ATTACH MATERIALIZED VIEW don't work with short syntax (w/o select), but i can attach it using ATTACH TABLE ...\n+clickhouse_local \"ATTACH TABLE db_ordinary.src2dst_mv_to\"\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 30, 'View can be reattached', 'can not reattach permanently detached view') from db_ordinary.dst;\"\n+\n+clickhouse_local \"DROP VIEW db_ordinary.src2dst_mv_to SYNC\"\n+\n+echo \"##################\"\n+echo \"test for MV with inner table\"\n+clickhouse_local \"CREATE MATERIALIZED VIEW db_ordinary.src_mv_with_inner Engine=Log AS SELECT * FROM db_ordinary.src\"\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+\n+clickhouse_local \"SELECT if(count() = 10, 'MV is working', 'MV failed') FROM db_ordinary.src_mv_with_inner\"\n+\n+clickhouse_local \"DETACH VIEW db_ordinary.src_mv_with_inner PERMANENTLY; INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\" --stacktrace\n+clickhouse_local \"SELECT if(count() = 10, 'MV can be detached permanently', 'MV detach failed') FROM db_ordinary.src_mv_with_inner\" 2>&1 | grep -c \"db_ordinary.src_mv_with_inner doesn't exist\"\n+## Quite silly: ATTACH MATERIALIZED VIEW don't work with short syntax (w/o select), but i can attach it using ATTACH TABLE ...\n+clickhouse_local \"ATTACH TABLE db_ordinary.src_mv_with_inner\"\n+clickhouse_local \"INSERT INTO db_ordinary.src SELECT * FROM numbers(10)\"\n+clickhouse_local \"SELECT if(count() = 20, 'View can be reattached', 'can not reattach permanently detached view') from db_ordinary.src_mv_with_inner;\"\n+\n+## clickhouse_local can't work with dicts...\n+# mkdir -p \"${WORKING_FOLDER_01600}/user_files\"\n+# echo \"1\" > \"${WORKING_FOLDER_01600}/user_files/dummy_dict.tsv\"\n+# clickhouse_local \"DROP DICTIONARY db_ordinary.dummy; CREATE DICTIONARY db_ordinary.dummy (id UInt64) PRIMARY KEY id LAYOUT(FLAT()) SOURCE(FILE(path 'dummy_dict.tsv' format 'TabSeparated')) LIFETIME(MIN 1 MAX 10); DETACH DICTIONARY db_ordinary.dummy PERMANENTLY; SELECT dictGet('db_ordinary.dummy','val',toUInt64(1));\"\n+\n+echo \"##################\"\n+echo \"DETACH DATABASE is not implemented (proper error)\"\n+clickhouse_local \"DETACH DATABASE db_ordinary PERMANENTLY;\" 2>&1 | grep -c 'DETACH PERMANENTLY is not implemented'\n+\n+# clean up\n+rm -rf \"${WORKING_FOLDER_01600}\"\ndiff --git a/tests/queries/0_stateless/01601_detach_permanently.reference b/tests/queries/0_stateless/01601_detach_permanently.reference\nnew file mode 100644\nindex 000000000000..6683603c9727\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_detach_permanently.reference\n@@ -0,0 +1,79 @@\n+database atomic tests\n+can not create table with same name as detached permanently\n+can not detach twice\n+can not drop detached\n+can not replace with the other table\n+can still show the create statement\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+statement: CREATE TABLE test1601_detach_permanently_atomic.test_name_reuse\n+(\n+    `number` UInt64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+SETTINGS index_granularity = 8192\n+can not attach with bad uuid\n+can attach with short syntax\n+100\n+can not detach permanently the table which is already detached (temporary)\n+100\n+After database reattachement the table is back (it was detached temporary)\n+And we can detach it permanently\n+After database reattachement the table is still absent (it was detached permamently)\n+And we can not detach it permanently\n+But we can attach it back\n+And detach permanently again to check how database drop will behave\n+DROP database\n+-----------------------\n+database ordinary tests\n+can not create table with same name as detached permanently\n+can not detach twice\n+can not drop detached\n+can not replace with the other table\n+can still show the create statement\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+statement: CREATE TABLE test1601_detach_permanently_ordinary.test_name_reuse\n+(\n+    `number` UInt64\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+SETTINGS index_granularity = 8192\n+can attach with full syntax\n+can attach with short syntax\n+can not detach permanently the table which is already detached (temporary)\n+After database reattachement the table is back (it was detached temporary)\n+And we can detach it permanently\n+After database reattachement the table is still absent (it was detached permamently)\n+And we can not detach it permanently\n+But we can attach it back\n+And detach permanently again to check how database drop will behave\n+DROP database - Directory not empty error, but database deteched\n+DROP database - now success\n+-----------------------\n+database lazy tests\n+can not create table with same name as detached permanently\n+can not detach twice\n+can not drop detached\n+can not replace with the other table\n+can still show the create statement\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+statement: CREATE TABLE test1601_detach_permanently_lazy.test_name_reuse\n+(\n+    `number` UInt64\n+)\n+ENGINE = Log\n+can attach with full syntax\n+can attach with short syntax\n+can not detach permanently the table which is already detached (temporary)\n+After database reattachement the table is back (it was detached temporary)\n+And we can detach it permanently\n+After database reattachement the table is still absent (it was detached permamently)\n+And we can not detach it permanently\n+But we can attach it back\n+And detach permanently again to check how database drop will behave\n+DROP database - Directory not empty error, but database deteched\n+DROP database - now success\ndiff --git a/tests/queries/0_stateless/01601_detach_permanently.sql b/tests/queries/0_stateless/01601_detach_permanently.sql\nnew file mode 100644\nindex 000000000000..0e21fd8f463b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_detach_permanently.sql\n@@ -0,0 +1,214 @@\n+SELECT 'database atomic tests';\n+\n+DROP DATABASE IF EXISTS test1601_detach_permanently_atomic;\n+CREATE DATABASE test1601_detach_permanently_atomic Engine=Atomic;\n+\n+create table test1601_detach_permanently_atomic.test_name_reuse (number UInt64) engine=MergeTree order by tuple();\n+\n+INSERT INTO test1601_detach_permanently_atomic.test_name_reuse SELECT * FROM numbers(100);\n+\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;\n+\n+SELECT 'can not create table with same name as detached permanently';\n+create table test1601_detach_permanently_atomic.test_name_reuse (number UInt64) engine=MergeTree order by tuple(); -- { serverError 57 }\n+\n+SELECT 'can not detach twice';\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }\n+\n+SELECT 'can not drop detached';\n+drop table test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }\n+\n+create table test1601_detach_permanently_atomic.test_name_rename_attempt (number UInt64) engine=MergeTree order by tuple();\n+\n+SELECT 'can not replace with the other table';\n+RENAME TABLE test1601_detach_permanently_atomic.test_name_rename_attempt TO test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 57 }\n+EXCHANGE TABLES test1601_detach_permanently_atomic.test_name_rename_attempt AND test1601_detach_permanently_atomic.test_name_reuse; -- { serverError 60 }\n+\n+SELECT 'can still show the create statement';\n+SHOW CREATE TABLE test1601_detach_permanently_atomic.test_name_reuse FORMAT Vertical;\n+\n+SELECT 'can not attach with bad uuid';\n+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse UUID '00000000-0000-0000-0000-000000000001'\u3000(`number` UInt64\u3000)\u3000ENGINE = MergeTree\u3000ORDER BY tuple()\u3000SETTINGS index_granularity = 8192 ;  -- { serverError 57 }\n+\n+SELECT 'can attach with short syntax';\n+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse;\n+\n+SELECT count() FROM test1601_detach_permanently_atomic.test_name_reuse;\n+\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse;\n+\n+SELECT 'can not detach permanently the table which is already detached (temporary)';\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+DETACH DATABASE test1601_detach_permanently_atomic;\n+ATTACH DATABASE test1601_detach_permanently_atomic;\n+\n+SELECT count() FROM test1601_detach_permanently_atomic.test_name_reuse;\n+\n+SELECT 'After database reattachement the table is back (it was detached temporary)';\n+SELECT 'And we can detach it permanently';\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;\n+\n+DETACH DATABASE test1601_detach_permanently_atomic;\n+ATTACH DATABASE test1601_detach_permanently_atomic;\n+\n+SELECT 'After database reattachement the table is still absent (it was detached permamently)';\n+SELECT 'And we can not detach it permanently';\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+SELECT 'But we can attach it back';\n+ATTACH TABLE test1601_detach_permanently_atomic.test_name_reuse;\n+\n+SELECT 'And detach permanently again to check how database drop will behave';\n+DETACH table test1601_detach_permanently_atomic.test_name_reuse PERMANENTLY;\n+\n+SELECT 'DROP database';\n+DROP DATABASE test1601_detach_permanently_atomic SYNC;\n+\n+SELECT '-----------------------';\n+SELECT 'database ordinary tests';\n+\n+DROP DATABASE IF EXISTS test1601_detach_permanently_ordinary;\n+CREATE DATABASE test1601_detach_permanently_ordinary Engine=Ordinary;\n+\n+create table test1601_detach_permanently_ordinary.test_name_reuse (number UInt64) engine=MergeTree order by tuple();\n+\n+INSERT INTO test1601_detach_permanently_ordinary.test_name_reuse SELECT * FROM numbers(100);\n+\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;\n+\n+SELECT 'can not create table with same name as detached permanently';\n+create table test1601_detach_permanently_ordinary.test_name_reuse (number UInt64) engine=MergeTree order by tuple(); -- { serverError 57 }\n+\n+SELECT 'can not detach twice';\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 60 }\n+\n+SELECT 'can not drop detached';\n+drop table test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 60 }\n+\n+create table test1601_detach_permanently_ordinary.test_name_rename_attempt (number UInt64) engine=MergeTree order by tuple();\n+\n+SELECT 'can not replace with the other table';\n+RENAME TABLE test1601_detach_permanently_ordinary.test_name_rename_attempt TO test1601_detach_permanently_ordinary.test_name_reuse; -- { serverError 57 }\n+\n+SELECT 'can still show the create statement';\n+SHOW CREATE TABLE test1601_detach_permanently_ordinary.test_name_reuse FORMAT Vertical;\n+\n+SELECT 'can attach with full syntax';\n+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse (`number` UInt64\u3000)\u3000ENGINE = MergeTree\u3000ORDER BY tuple()\u3000SETTINGS index_granularity = 8192;\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;\n+\n+SELECT 'can attach with short syntax';\n+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;\n+\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse;\n+\n+SELECT 'can not detach permanently the table which is already detached (temporary)';\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+DETACH DATABASE test1601_detach_permanently_ordinary;\n+ATTACH DATABASE test1601_detach_permanently_ordinary;\n+\n+SELECT 'After database reattachement the table is back (it was detached temporary)';\n+SELECT 'And we can detach it permanently';\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;\n+\n+DETACH DATABASE test1601_detach_permanently_ordinary;\n+ATTACH DATABASE test1601_detach_permanently_ordinary;\n+\n+SELECT 'After database reattachement the table is still absent (it was detached permamently)';\n+SELECT 'And we can not detach it permanently';\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+SELECT 'But we can attach it back';\n+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;\n+\n+SELECT 'And detach permanently again to check how database drop will behave';\n+DETACH table test1601_detach_permanently_ordinary.test_name_reuse PERMANENTLY;\n+\n+SELECT 'DROP database - Directory not empty error, but database deteched';\n+DROP DATABASE test1601_detach_permanently_ordinary; -- { serverError 1000 }\n+\n+ATTACH DATABASE test1601_detach_permanently_ordinary;\n+\n+ATTACH TABLE test1601_detach_permanently_ordinary.test_name_reuse;\n+DROP TABLE test1601_detach_permanently_ordinary.test_name_reuse;\n+\n+SELECT 'DROP database - now success';\n+DROP DATABASE test1601_detach_permanently_ordinary;\n+\n+\n+SELECT '-----------------------';\n+SELECT 'database lazy tests';\n+\n+DROP DATABASE IF EXISTS test1601_detach_permanently_lazy;\n+CREATE DATABASE test1601_detach_permanently_lazy Engine=Lazy(10);\n+\n+create table test1601_detach_permanently_lazy.test_name_reuse (number UInt64) engine=Log;\n+\n+INSERT INTO test1601_detach_permanently_lazy.test_name_reuse SELECT * FROM numbers(100);\n+\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;\n+\n+SELECT 'can not create table with same name as detached permanently';\n+create table test1601_detach_permanently_lazy.test_name_reuse (number UInt64) engine=Log; -- { serverError 57 }\n+\n+SELECT 'can not detach twice';\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 60 }\n+\n+SELECT 'can not drop detached';\n+drop table test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 60 }\n+\n+create table test1601_detach_permanently_lazy.test_name_rename_attempt (number UInt64) engine=Log;\n+\n+SELECT 'can not replace with the other table';\n+RENAME TABLE test1601_detach_permanently_lazy.test_name_rename_attempt TO test1601_detach_permanently_lazy.test_name_reuse; -- { serverError 57 }\n+\n+SELECT 'can still show the create statement';\n+SHOW CREATE TABLE test1601_detach_permanently_lazy.test_name_reuse FORMAT Vertical;\n+\n+SELECT 'can attach with full syntax';\n+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse (`number` UInt64\u3000)\u3000ENGINE = Log;\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;\n+\n+SELECT 'can attach with short syntax';\n+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;\n+\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse;\n+\n+SELECT 'can not detach permanently the table which is already detached (temporary)';\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+DETACH DATABASE test1601_detach_permanently_lazy;\n+ATTACH DATABASE test1601_detach_permanently_lazy;\n+\n+SELECT 'After database reattachement the table is back (it was detached temporary)';\n+SELECT 'And we can detach it permanently';\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;\n+\n+DETACH DATABASE test1601_detach_permanently_lazy;\n+ATTACH DATABASE test1601_detach_permanently_lazy;\n+\n+SELECT 'After database reattachement the table is still absent (it was detached permamently)';\n+SELECT 'And we can not detach it permanently';\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY; -- { serverError 60 }\n+\n+SELECT 'But we can attach it back';\n+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;\n+\n+SELECT 'And detach permanently again to check how database drop will behave';\n+DETACH table test1601_detach_permanently_lazy.test_name_reuse PERMANENTLY;\n+\n+SELECT 'DROP database - Directory not empty error, but database deteched';\n+DROP DATABASE test1601_detach_permanently_lazy; -- { serverError 1000 }\n+\n+ATTACH DATABASE test1601_detach_permanently_lazy;\n+\n+ATTACH TABLE test1601_detach_permanently_lazy.test_name_reuse;\n+DROP TABLE test1601_detach_permanently_lazy.test_name_reuse;\n+\n+SELECT 'DROP database - now success';\n+DROP DATABASE test1601_detach_permanently_lazy;\ndiff --git a/tests/queries/0_stateless/01603_rename_overwrite_bug.reference b/tests/queries/0_stateless/01603_rename_overwrite_bug.reference\nnew file mode 100644\nindex 000000000000..2c98ac3d71ab\n--- /dev/null\n+++ b/tests/queries/0_stateless/01603_rename_overwrite_bug.reference\n@@ -0,0 +1,4 @@\n+0\n+200\n+0\n+200\ndiff --git a/tests/queries/0_stateless/01603_rename_overwrite_bug.sql b/tests/queries/0_stateless/01603_rename_overwrite_bug.sql\nnew file mode 100644\nindex 000000000000..c857e08b2434\n--- /dev/null\n+++ b/tests/queries/0_stateless/01603_rename_overwrite_bug.sql\n@@ -0,0 +1,22 @@\n+DROP database IF EXISTS test_1603_rename_bug_ordinary;\n+create database test_1603_rename_bug_ordinary engine=Ordinary;\n+create table test_1603_rename_bug_ordinary.foo engine=Memory as select * from numbers(100);\n+create table test_1603_rename_bug_ordinary.bar engine=Log as select * from numbers(200);\n+detach table test_1603_rename_bug_ordinary.foo;\n+rename table test_1603_rename_bug_ordinary.bar to test_1603_rename_bug_ordinary.foo; -- { serverError 57 }\n+attach table test_1603_rename_bug_ordinary.foo;\n+SELECT count() from test_1603_rename_bug_ordinary.foo;\n+SELECT count() from test_1603_rename_bug_ordinary.bar;\n+DROP DATABASE test_1603_rename_bug_ordinary;\n+\n+-- was not broken, adding just in case.\n+DROP database IF EXISTS test_1603_rename_bug_atomic;\n+create database test_1603_rename_bug_atomic engine=Atomic;\n+create table test_1603_rename_bug_atomic.foo engine=Memory as select * from numbers(100);\n+create table test_1603_rename_bug_atomic.bar engine=Log as select * from numbers(200);\n+detach table test_1603_rename_bug_atomic.foo;\n+rename table test_1603_rename_bug_atomic.bar to test_1603_rename_bug_atomic.foo; -- { serverError 57 }\n+attach table test_1603_rename_bug_atomic.foo;\n+SELECT count() from test_1603_rename_bug_atomic.foo;\n+SELECT count() from test_1603_rename_bug_atomic.bar;\n+DROP DATABASE test_1603_rename_bug_atomic;\n",
  "problem_statement": "\"use DETACH DICTIONARY query\"\n```\r\nDROP TABLE test_dict\r\n\r\n\r\nReceived exception from server (version 20.7.1):\r\nCode: 520. DB::Exception: Received from localhost:9000. DB::Exception: Cannot detach dictionary `default.test_dict` as table, use DETACH DICTIONARY query. \r\n```\r\n\r\nMessage should be:\r\n```\r\nCannot drop/detach dictionary `default.test_dict` as table, use DROP/DETACH DICTIONARY query\r\n```\r\n\r\nAnd/or: is it ok that it tries to DETACH dict as regular table and exception came from DETACH? Maybe the check should happen earlier? \n",
  "hints_text": "",
  "created_at": "2020-11-30T17:55:02Z"
}