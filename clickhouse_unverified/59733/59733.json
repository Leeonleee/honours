{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59733,
  "instance_id": "ClickHouse__ClickHouse-59733",
  "issue_numbers": [
    "59727"
  ],
  "base_commit": "82cb09cab30e351861610e35bb09ac5b7bcf19b0",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp b/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\nindex b1f8e09be9fb..20dfed8cf8f9 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\n@@ -15,6 +15,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int BAD_ARGUMENTS;\n }\n \n \n@@ -217,7 +218,20 @@ MergeTreeIndexPtr minmaxIndexCreator(\n     return std::make_shared<MergeTreeIndexMinMax>(index);\n }\n \n-void minmaxIndexValidator(const IndexDescription & /* index */, bool /* attach */)\n+void minmaxIndexValidator(const IndexDescription & index, bool attach)\n {\n+    if (attach)\n+        return;\n+\n+    for (const auto & column : index.sample_block)\n+    {\n+        if (!column.type->isComparable())\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Data type of argument for minmax index must be comparable, got {} type for column {} instead\",\n+                column.type->getName(), column.name);\n+        }\n+    }\n }\n+\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02985_minmax_index_aggregate_function.reference b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.reference\nnew file mode 100644\nindex 000000000000..e71eb4f0d573\n--- /dev/null\n+++ b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.reference\n@@ -0,0 +1,6 @@\n+1\n+5\t10\n+6\t11\n+7\t12\n+8\t13\n+9\t14\ndiff --git a/tests/queries/0_stateless/02985_minmax_index_aggregate_function.sql b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.sql\nnew file mode 100644\nindex 000000000000..7d35c1b310b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.sql\n@@ -0,0 +1,36 @@\n+DROP TABLE IF EXISTS t_index_agg_func;\n+\n+CREATE TABLE t_index_agg_func\n+(\n+    id UInt64,\n+    v AggregateFunction(avg, UInt64),\n+    INDEX idx_v v TYPE minmax GRANULARITY 1\n+)\n+ENGINE = AggregatingMergeTree ORDER BY id\n+SETTINGS index_granularity = 4; -- { serverError BAD_ARGUMENTS }\n+\n+CREATE TABLE t_index_agg_func\n+(\n+    id UInt64,\n+    v AggregateFunction(avg, UInt64),\n+)\n+ENGINE = AggregatingMergeTree ORDER BY id\n+SETTINGS index_granularity = 4;\n+\n+ALTER TABLE t_index_agg_func ADD INDEX idx_v v TYPE minmax GRANULARITY 1; -- { serverError BAD_ARGUMENTS }\n+\n+ALTER TABLE t_index_agg_func ADD INDEX idx_v finalizeAggregation(v) TYPE minmax GRANULARITY 1;\n+\n+INSERT INTO t_index_agg_func SELECT number % 10, initializeAggregation('avgState', toUInt64(number % 20)) FROM numbers(1000);\n+INSERT INTO t_index_agg_func SELECT number % 10, initializeAggregation('avgState', toUInt64(number % 20)) FROM numbers(1000, 1000);\n+\n+OPTIMIZE TABLE t_index_agg_func FINAL;\n+\n+SELECT count() FROM system.parts WHERE table = 't_index_agg_func' AND database = currentDatabase() AND active;\n+\n+SET force_data_skipping_indices = 'idx_v';\n+SET use_skip_indexes_if_final = 1;\n+\n+SELECT id, finalizeAggregation(v) AS vv FROM t_index_agg_func FINAL WHERE vv >= 10 ORDER BY id;\n+\n+DROP TABLE t_index_agg_func;\n",
  "problem_statement": "Minmax index on aggregate function breaks merges for table\n> Please make sure that the version you're using is still supported\r\n\r\n23.10.5.20\r\n\r\n> You have to provide the following information whenever possible.\r\n\r\n**Describe what's wrong**\r\n\r\nminmax index on aggregate function causes broken merges\r\n\r\ntable column\r\n```sql\r\n`avg_time` AggregateFunction(avgWeighted, Int64, UInt64) CODEC(ZSTD(1)),\r\n```\r\n\r\nindex on table\r\n```\r\nINDEX idx_avg_time avg_time TYPE minmax GRANULARITY 1,\r\n```\r\n\r\nerror seen in system.merge_log causing merge failures\r\n```\r\nCode: 43. DB::Exception: Operator < is not implemented for AggregateFunctionStateData. (ILLEGAL_TYPE_OF_ARGUMENT), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000cdce617 in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<char const (&) [62]>(int, char const (&) [62]) @ 0x0000000007b746e0 in /usr/bin/clickhouse\r\n2. auto DB::Field::dispatch<auto auto DB::applyVisitor<DB::FieldVisitorAccurateLess, DB::FieldRef&, DB::FieldRef&>(DB::FieldVisitorAccurateLess&&, DB::FieldRef&, DB::FieldRef&)::'lambda'(DB::FieldVisitorAccurateLess&)::operator()<DB::AggregateFunctionStateData>(DB::FieldVisitorAccurateLess&) const::'lambda'(DB::FieldVisitorAccurateLess&), DB::FieldRef&>(DB::FieldVisitorAccurateLess&&, DB::FieldRef&) @ 0x00000000134d7e04 in /usr/bin/clickhouse\r\n3. auto DB::Field::dispatch<auto DB::applyVisitor<DB::FieldVisitorAccurateLess, DB::FieldRef&, DB::FieldRef&>(DB::FieldVisitorAccurateLess&&, DB::FieldRef&, DB::FieldRef&)::'lambda'(DB::FieldVisitorAccurateLess&), DB::FieldRef&>(DB::FieldVisitorAccurateLess&&, DB::FieldRef&) @ 0x00000000134d20bd in /usr/bin/clickhouse\r\n4. DB::MergeTreeIndexAggregatorMinMax::update(DB::Block const&, unsigned long*, unsigned long) @ 0x0000000013664915 in /usr/bin/clickhouse\r\n5. DB::MergeTreeDataPartWriterOnDisk::calculateAndSerializeSkipIndices(DB::Block const&, std::vector<DB::Granule, std::allocator<DB::Granule>> const&) @ 0x0000000013611be9 in /usr/bin/clickhouse\r\n6. DB::MergeTreeDataPartWriterWide::write(DB::Block const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 63ul, 64ul> const*) @ 0x0000000013615367 in /usr/bin/clickhouse\r\n7. DB::MergedBlockOutputStream::write(DB::Block const&) @ 0x000000001375db64 in /usr/bin/clickhouse\r\n8. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl() @ 0x00000000135219f0 in /usr/bin/clickhouse\r\n9. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::execute() @ 0x000000001352154b in /usr/bin/clickhouse\r\n10. DB::MergeTask::execute() @ 0x00000000135268f9 in /usr/bin/clickhouse\r\n11. DB::ReplicatedMergeMutateTaskBase::executeStep() @ 0x00000000137c61ce in /usr/bin/clickhouse\r\n12. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::threadFunction() @ 0x000000001353855b in /usr/bin/clickhouse\r\n13. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0x000000000ceb7abf in /usr/bin/clickhouse\r\n14. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000cebb5dc in /usr/bin/clickhouse\r\n15. void* std::__thread_proxy[abi:v15000]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000ceb9e07 in /usr/bin/clickhouse\r\n16. ? @ 0x00007f2a86e41609 in ?\r\n17. ? @ 0x00007f2a86d66133 in ?\r\n```\r\n\n",
  "hints_text": "It should not be allowed to create `minmax` index with `AggregateFunction` data type.",
  "created_at": "2024-02-07T17:40:28Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeIndexMinMax.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.reference",
    "b/tests/queries/0_stateless/02985_minmax_index_aggregate_function.sql"
  ]
}