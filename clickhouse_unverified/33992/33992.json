{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33992,
  "instance_id": "ClickHouse__ClickHouse-33992",
  "issue_numbers": [
    "7334"
  ],
  "base_commit": "c5ca5b608e092704652d3fb3184d443015a501f3",
  "patch": "diff --git a/src/Common/StringSearcher.h b/src/Common/StringSearcher.h\nindex f34bc6f73227..406298382848 100644\n--- a/src/Common/StringSearcher.h\n+++ b/src/Common/StringSearcher.h\n@@ -24,7 +24,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int UNSUPPORTED_PARAMETER;\n     extern const int BAD_ARGUMENTS;\n }\n \n@@ -34,9 +33,12 @@ namespace ErrorCodes\n   */\n \n \n-struct StringSearcherBase\n+class StringSearcherBase\n {\n+public:\n+    bool force_fallback = false;\n #ifdef __SSE2__\n+protected:\n     static constexpr auto n = sizeof(__m128i);\n     const int page_size = ::getPageSize();\n \n@@ -53,7 +55,7 @@ template <bool CaseSensitive, bool ASCII> class StringSearcher;\n \n /// Case-insensitive UTF-8 searcher\n template <>\n-class StringSearcher<false, false> : private StringSearcherBase\n+class StringSearcher<false, false> : public StringSearcherBase\n {\n private:\n     using UTF8SequenceBuffer = uint8_t[6];\n@@ -119,11 +121,14 @@ class StringSearcher<false, false> : private StringSearcherBase\n                 size_t length_u = UTF8::convertCodePointToUTF8(first_u_u32, u_seq, sizeof(u_seq));\n \n                 if (length_l != length_u)\n-                    throw Exception{\"UTF8 sequences with different lowercase and uppercase lengths are not supported\", ErrorCodes::UNSUPPORTED_PARAMETER};\n+                    force_fallback = true;\n             }\n \n             l = l_seq[0];\n             u = u_seq[0];\n+\n+            if (force_fallback)\n+                return;\n         }\n \n #ifdef __SSE4_1__\n@@ -158,7 +163,10 @@ class StringSearcher<false, false> : private StringSearcherBase\n \n                 /// @note Unicode standard states it is a rare but possible occasion\n                 if (!(dst_l_len == dst_u_len && dst_u_len == src_len))\n-                    throw Exception{\"UTF8 sequences with different lowercase and uppercase lengths are not supported\", ErrorCodes::UNSUPPORTED_PARAMETER};\n+                {\n+                    force_fallback = true;\n+                    return;\n+                }\n             }\n \n             cache_actual_len += src_len;\n@@ -199,9 +207,10 @@ class StringSearcher<false, false> : private StringSearcherBase\n             if (Poco::Unicode::toLower(*haystack_code_point) != Poco::Unicode::toLower(*needle_code_point))\n                 break;\n \n-            /// @note assuming sequences for lowercase and uppercase have exact same length (that is not always true)\n-            const auto len = UTF8::seqLength(*haystack_pos);\n+            auto len = UTF8::seqLength(*haystack_pos);\n             haystack_pos += len;\n+\n+            len = UTF8::seqLength(*needle_pos);\n             needle_pos += len;\n         }\n \n@@ -213,7 +222,7 @@ class StringSearcher<false, false> : private StringSearcherBase\n     {\n \n #ifdef __SSE4_1__\n-        if (pageSafe(pos))\n+        if (pageSafe(pos) && !force_fallback)\n         {\n             const auto v_haystack = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pos));\n             const auto v_against_l = _mm_cmpeq_epi8(v_haystack, cachel);\n@@ -262,7 +271,7 @@ class StringSearcher<false, false> : private StringSearcherBase\n         while (haystack < haystack_end)\n         {\n #ifdef __SSE4_1__\n-            if (haystack + n <= haystack_end && pageSafe(haystack))\n+            if (haystack + n <= haystack_end && pageSafe(haystack) && !force_fallback)\n             {\n                 const auto v_haystack = _mm_loadu_si128(reinterpret_cast<const __m128i *>(haystack));\n                 const auto v_against_l = _mm_cmpeq_epi8(v_haystack, patl);\n@@ -339,7 +348,7 @@ class StringSearcher<false, false> : private StringSearcherBase\n \n /// Case-insensitive ASCII searcher\n template <>\n-class StringSearcher<false, true> : private StringSearcherBase\n+class StringSearcher<false, true> : public StringSearcherBase\n {\n private:\n     /// string to be searched for\n@@ -541,7 +550,7 @@ class StringSearcher<false, true> : private StringSearcherBase\n \n /// Case-sensitive searcher (both ASCII and UTF-8)\n template <bool ASCII>\n-class StringSearcher<true, ASCII> : private StringSearcherBase\n+class StringSearcher<true, ASCII> : public StringSearcherBase\n {\n private:\n     /// string to be searched for\n@@ -725,7 +734,7 @@ class StringSearcher<true, ASCII> : private StringSearcherBase\n // Any value outside of basic ASCII (>=128) is considered a non-separator symbol, hence UTF-8 strings\n // should work just fine. But any Unicode whitespace is not considered a token separtor.\n template <typename StringSearcher>\n-class TokenSearcher\n+class TokenSearcher : public StringSearcherBase\n {\n     StringSearcher searcher;\n     size_t needle_size;\n@@ -809,7 +818,7 @@ using ASCIICaseInsensitiveTokenSearcher = TokenSearcher<ASCIICaseInsensitiveStri\n   * It is required that strings are zero-terminated.\n   */\n \n-struct LibCASCIICaseSensitiveStringSearcher\n+struct LibCASCIICaseSensitiveStringSearcher : public StringSearcherBase\n {\n     const char * const needle;\n \n@@ -833,7 +842,7 @@ struct LibCASCIICaseSensitiveStringSearcher\n     }\n };\n \n-struct LibCASCIICaseInsensitiveStringSearcher\n+struct LibCASCIICaseInsensitiveStringSearcher : public StringSearcherBase\n {\n     const char * const needle;\n \ndiff --git a/src/Common/Volnitsky.h b/src/Common/Volnitsky.h\nindex f08172c8a772..881817f33bed 100644\n--- a/src/Common/Volnitsky.h\n+++ b/src/Common/Volnitsky.h\n@@ -372,7 +372,7 @@ class VolnitskyBase\n         , fallback{VolnitskyTraits::isFallbackNeedle(needle_size, haystack_size_hint)}\n         , fallback_searcher{needle_, needle_size}\n     {\n-        if (fallback)\n+        if (fallback || fallback_searcher.force_fallback)\n             return;\n \n         hash = std::unique_ptr<VolnitskyTraits::Offset[]>(new VolnitskyTraits::Offset[VolnitskyTraits::hash_size]{});\n@@ -393,7 +393,7 @@ class VolnitskyBase\n \n         const auto haystack_end = haystack + haystack_size;\n \n-        if (fallback || haystack_size <= needle_size)\n+        if (fallback || haystack_size <= needle_size || fallback_searcher.force_fallback)\n             return fallback_searcher.search(haystack, haystack_end);\n \n         /// Let's \"apply\" the needle to the haystack and compare the n-gram from the end of the needle.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00312_position_case_insensitive_utf8.reference b/tests/queries/0_stateless/00312_position_case_insensitive_utf8.reference\nindex 86745bb6299c..f56ae0763f7b 100644\n--- a/tests/queries/0_stateless/00312_position_case_insensitive_utf8.reference\n+++ b/tests/queries/0_stateless/00312_position_case_insensitive_utf8.reference\n@@ -90,3 +90,31 @@\n 21\n 22\n 23\n+6\n+7\n+7\n+5\n+6\n+7\n+8\n+9\n+10\n+11\n+12\n+13\n+14\n+15\n+16\n+17\n+5\n+6\n+7\n+8\n+9\n+10\n+11\n+12\n+13\n+14\n+15\n+16\ndiff --git a/tests/queries/0_stateless/00312_position_case_insensitive_utf8.sql b/tests/queries/0_stateless/00312_position_case_insensitive_utf8.sql\nindex 010a1d78dfa8..8bb8512fa4bf 100644\n--- a/tests/queries/0_stateless/00312_position_case_insensitive_utf8.sql\n+++ b/tests/queries/0_stateless/00312_position_case_insensitive_utf8.sql\n@@ -93,3 +93,34 @@ SELECT position(concat('                   \u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', arrayStringConcat\n SELECT position(concat('                    \u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', arrayStringConcat(arrayMap(x -> ' ', range(20000)))), '\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443') AS res;\n SELECT position(concat('                     \u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', arrayStringConcat(arrayMap(x -> ' ', range(20000)))), '\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443') AS res;\n SELECT position(concat('                      \u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', arrayStringConcat(arrayMap(x -> ' ', range(20000)))), '\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443') AS res;\n+\n+SELECT positionCaseInsensitiveUTF8(materialize('test \u00df test'), '\u00df') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize('test Aa\u00dfAa test'), 'a\u00dfa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize('test A1\u00df2a test'), '1\u00df2') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize('x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest'), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat(' test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('  test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('   test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('    test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('     test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('      test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('       test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('        test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('         test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('          test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('           test a1\u00dfAa test', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'a1\u1e9eaa') AS res;\n+\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat(' x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('  x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('   x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('    x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('     x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('      x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('       x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('        x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('         x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('          x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\n+SELECT positionCaseInsensitiveUTF8(materialize(concat('           x\u1e9eyyaa1\u1e9e1yz\u1e9eX\u1e9e\u1e9e1\u1e9e\u1e9e1bctest', arrayStringConcat(arrayMap(x -> ' ', range(20000))))), 'aa1\u1e9e1Yz\u00dfx\u00df\u00df1\u00df\u00df1BC') AS res;\ndiff --git a/tests/queries/0_stateless/01674_unicode_asan.sql b/tests/queries/0_stateless/01674_unicode_asan.sql\nindex 2ba34b46f930..85c210235c40 100644\n--- a/tests/queries/0_stateless/01674_unicode_asan.sql\n+++ b/tests/queries/0_stateless/01674_unicode_asan.sql\n@@ -1,3 +1,2 @@\n SELECT positionCaseInsensitiveUTF8('\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', '\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\ufffd\\0') AS res;\n-SELECT positionCaseInsensitiveUTF8('\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', randomString(rand() % 100)) FROM system.numbers; -- { serverError 2 }\n SELECT sum(ignore(positionCaseInsensitiveUTF8('\u0438\u0433\u043e\u043b\u043a\u0430.\u0440\u0443', randomString(rand() % 2)))) FROM numbers(1000000);\n",
  "problem_statement": "Cannot use positionCaseInsensitiveUTF8() with \"\u00df\" letter\nHello,\r\n\r\n**Describe the bug or unexpected behaviour**\r\n\r\nLetter \"\u00df\" is part of german alphabet. Im not able to search for it using positionCaseInsensitiveUTF8() function. Function returns an error:\r\n\r\n```\r\nCode: 2. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: UTF8 sequences with different lowercase and uppercase lengths are not supported.\r\n```\r\n\r\n**How to reproduce**\r\n\r\nExamples, where I could not use that sign:\r\n\r\n```\r\nCREATE TABLE test2 ( d Date, test String ) ENGINE = MergeTree(d, d, d, 8192);\r\nINSERT INTO test2 VALUES('2019/04/05', 'this is example \u00df test string');\r\n\r\nSELECT * FROM test2 WHERE positionCaseInsensitiveUTF8(test, '\u00df') != 0\r\n\r\nReceived exception from server (version 19.6.2):\r\nCode: 2. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: UTF8 sequences with different lowercase and uppercase lengths are not supported. \r\n```\r\n\r\nFunction positionUTF8 works fine\r\n\r\n```\r\nf45b09c5fb9a :) SELECT * FROM test2 WHERE positionUTF8(test, '\u00df') != 0\r\n\r\nSELECT *\r\nFROM test2 \r\nWHERE positionUTF8(test, '\u00df') != 0\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500test\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 2019-04-05 \u2502 this is example \u00df test string \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAnother example, where I could search for \"\u00df\":\r\n\r\n```\r\nSELECT positionCaseInsensitiveUTF8('test \u00df test', '\u00df');\r\n\r\nSELECT positionCaseInsensitiveUTF8('test \u00df test', '\u00df')\r\n\r\n\u250c\u2500positionCaseInsensitiveUTF8('test \u00df test', '\u00df')\u2500\u2510\r\n\u2502                                               6 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Which ClickHouse server version to use**\r\n\r\n19.6.2.11, problem exists also on 19.13.5.44\r\n\r\n**Expected behavior**\r\n\r\nPosition of this character in string\n",
  "hints_text": "Workaround:\r\n```\r\nSELECT * FROM test2 WHERE positionUTF8(test, '\u00df') != 0 or positionUTF8(test, 'SS') != 0\r\n```\r\n\r\nBTW: https://en.wikipedia.org/wiki/Capital_%E1%BA%9E \r\n\r\nMore general: https://github.com/ClickHouse/ClickHouse/issues/7341\nMinimal reproducing example:\r\n```\r\nSELECT positionCaseInsensitiveUTF8(materialize('test \u00df test'), '\u00df')\r\n```\nWe will implement the use case when upper and lower cases are represented by the same number of code points but with different number of bytes in UTF-8. Examples: \u1e9e and \u00df.\r\n\r\n```\r\n\u250c\u2500hex('\u1e9e')\u2500\u252c\u2500hex('\u00df')\u2500\u2510\r\n\u2502 E1BA9E   \u2502 C39F     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut implementing the case when upper and lower cases splits/joins the code points is out of scope. Examples: \u00df and ss.",
  "created_at": "2022-01-25T19:27:18Z"
}