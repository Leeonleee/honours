diff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h
index 63edafa6810a..4d1551bfa2e5 100644
--- a/src/DataTypes/NumberTraits.h
+++ b/src/DataTypes/NumberTraits.h
@@ -100,10 +100,12 @@ template <typename A, typename B> struct ResultOfIntegerDivision
     */
 template <typename A, typename B> struct ResultOfModulo
 {
-    using Type = typename Construct<
-        is_signed_v<A> || is_signed_v<B>,
-        false,
-        sizeof(B)>::Type;
+    using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>,
+        Float64,
+        typename Construct<
+            is_signed_v<A> || is_signed_v<B>,
+            false,
+            sizeof(B)>::Type>;
 };
 
 template <typename A> struct ResultOfNegate
diff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h
index cab947b92a2e..25fd62b1b322 100644
--- a/src/Functions/DivisionUtils.h
+++ b/src/Functions/DivisionUtils.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <cmath>
 #include <type_traits>
 #include <Common/Exception.h>
 #include <DataTypes/NumberTraits.h>
@@ -86,8 +87,16 @@ struct ModuloImpl
     template <typename Result = ResultType>
     static inline Result apply(A a, B b)
     {
-        throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));
-        return typename NumberTraits::ToInteger<A>::Type(a) % typename NumberTraits::ToInteger<B>::Type(b);
+        if constexpr (std::is_floating_point_v<ResultType>)
+        {
+            /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.
+            return ResultType(a) - trunc(ResultType(a) / ResultType(b)) * ResultType(b);
+        }
+        else
+        {
+            throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));
+            return typename NumberTraits::ToInteger<A>::Type(a) % typename NumberTraits::ToInteger<B>::Type(b);
+        }
     }
 
 #if USE_EMBEDDED_COMPILER
diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index dbead7bff01e..fc45807050b3 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -506,10 +506,11 @@ struct BinaryOperationTraits
         /// greatest(Date, Date) -> Date
         Case<std::is_same_v<LeftDataType, RightDataType> && (std::is_same_v<Op, LeastBaseImpl<T0, T1>> || std::is_same_v<Op, GreatestBaseImpl<T0, T1>>),
             LeftDataType>,
-        /// Date % Int32 -> int32
+        /// Date % Int32 -> Int32
+        /// Date % Float -> Float64
         Case<std::is_same_v<Op, ModuloImpl<T0, T1>>, Switch<
             Case<IsDateOrDateTime<LeftDataType> && IsIntegral<RightDataType>, RightDataType>,
-            Case<IsDateOrDateTime<LeftDataType> && IsFloatingPoint<RightDataType>, DataTypeInt32>>>>;
+            Case<IsDateOrDateTime<LeftDataType> && IsFloatingPoint<RightDataType>, DataTypeFloat64>>>>;
 };
 
 
diff --git a/src/Functions/modulo.cpp b/src/Functions/modulo.cpp
index c90a590da617..68cdceed6eab 100644
--- a/src/Functions/modulo.cpp
+++ b/src/Functions/modulo.cpp
@@ -102,6 +102,7 @@ using FunctionModulo = FunctionBinaryArithmetic<ModuloImpl, NameModulo, false>;
 void registerFunctionModulo(FunctionFactory & factory)
 {
     factory.registerFunction<FunctionModulo>();
+    factory.registerAlias("mod", "modulo", FunctionFactory::CaseInsensitive);
 }
 
 }
diff --git a/src/Functions/moduloOrZero.cpp b/src/Functions/moduloOrZero.cpp
index 22ef069defdf..457c67c9e932 100644
--- a/src/Functions/moduloOrZero.cpp
+++ b/src/Functions/moduloOrZero.cpp
@@ -14,10 +14,18 @@ struct ModuloOrZeroImpl
     template <typename Result = ResultType>
     static inline Result apply(A a, B b)
     {
-        if (unlikely(divisionLeadsToFPE(a, b)))
-            return 0;
-
-        return ModuloImpl<A, B>::template apply<Result>(a, b);
+        if constexpr (std::is_floating_point_v<ResultType>)
+        {
+            /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.
+            return ResultType(a) - trunc(ResultType(a) / ResultType(b)) * ResultType(b);
+        }
+        else
+        {
+            if (unlikely(divisionLeadsToFPE(a, b)))
+                return 0;
+
+            return ModuloImpl<A, B>::template apply<Result>(a, b);
+        }
     }
 
 #if USE_EMBEDDED_COMPILER
