diff --git a/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp
index bc1b3695d88c..c175cd516ac7 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp
@@ -22,6 +22,7 @@
 #include <Processors/QueryPlan/TotalsHavingStep.h>
 #include <Processors/QueryPlan/UnionStep.h>
 #include <Processors/QueryPlan/WindowStep.h>
+#include "Storages/KeyDescription.h"
 #include <Storages/StorageMerge.h>
 #include <Common/typeid_cast.h>
 
@@ -332,8 +333,7 @@ InputOrderInfoPtr buildInputOrderInfo(
     const FixedColumns & fixed_columns,
     const ActionsDAGPtr & dag,
     const SortDescription & description,
-    const ActionsDAG & sorting_key_dag,
-    const Names & sorting_key_columns,
+    const KeyDescription & sorting_key,
     size_t limit)
 {
     //std::cerr << "------- buildInputOrderInfo " << std::endl;
@@ -343,6 +343,8 @@ InputOrderInfoPtr buildInputOrderInfo(
     MatchedTrees::Matches matches;
     FixedColumns fixed_key_columns;
 
+    const auto & sorting_key_dag = sorting_key.expression->getActionsDAG();
+
     if (dag)
     {
         matches = matchTrees(sorting_key_dag.getOutputs(), *dag);
@@ -371,9 +373,9 @@ InputOrderInfoPtr buildInputOrderInfo(
     size_t next_description_column = 0;
     size_t next_sort_key = 0;
 
-    while (next_description_column < description.size() && next_sort_key < sorting_key_columns.size())
+    while (next_description_column < description.size() && next_sort_key < sorting_key.column_names.size())
     {
-        const auto & sorting_key_column = sorting_key_columns[next_sort_key];
+        const auto & sorting_key_column = sorting_key.column_names[next_sort_key];
         const auto & sort_column_description = description[next_description_column];
 
         /// If required order depend on collation, it cannot be matched with primary key order.
@@ -381,6 +383,12 @@ InputOrderInfoPtr buildInputOrderInfo(
         if (sort_column_description.collator)
             break;
 
+        /// Since sorting key columns are always sorted with NULLS LAST, reading in order
+        /// supported only for ASC NULLS LAST ("in order"), and DESC NULLS FIRST ("reverse")
+        const auto column_is_nullable = sorting_key.data_types[next_sort_key]->isNullable();
+        if (column_is_nullable && sort_column_description.nulls_direction != 1)
+            break;
+
         /// Direction for current sort key.
         int current_direction = 0;
         bool strict_monotonic = true;
@@ -691,12 +699,11 @@ InputOrderInfoPtr buildInputOrderInfo(
     size_t limit)
 {
     const auto & sorting_key = reading->getStorageMetadata()->getSortingKey();
-    const auto & sorting_key_columns = sorting_key.column_names;
 
     return buildInputOrderInfo(
         fixed_columns,
         dag, description,
-        sorting_key.expression->getActionsDAG(), sorting_key_columns,
+        sorting_key,
         limit);
 }
 
@@ -714,15 +721,14 @@ InputOrderInfoPtr buildInputOrderInfo(
     {
         auto storage = std::get<StoragePtr>(table);
         const auto & sorting_key = storage->getInMemoryMetadataPtr()->getSortingKey();
-        const auto & sorting_key_columns = sorting_key.column_names;
 
-        if (sorting_key_columns.empty())
+        if (sorting_key.column_names.empty())
             return nullptr;
 
         auto table_order_info = buildInputOrderInfo(
             fixed_columns,
             dag, description,
-            sorting_key.expression->getActionsDAG(), sorting_key_columns,
+            sorting_key,
             limit);
 
         if (!table_order_info)
