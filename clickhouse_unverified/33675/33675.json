{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33675,
  "instance_id": "ClickHouse__ClickHouse-33675",
  "issue_numbers": [
    "7462"
  ],
  "base_commit": "b686fc142cc170993168442eb195ce16c66b5218",
  "patch": "diff --git a/base/base/wide_integer_impl.h b/base/base/wide_integer_impl.h\nindex cffffcc213f4..ec146fd58211 100644\n--- a/base/base/wide_integer_impl.h\n+++ b/base/base/wide_integer_impl.h\n@@ -125,11 +125,11 @@ class numeric_limits<wide::integer<Bits, Signed>>\n template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>\n struct common_type<wide::integer<Bits, Signed>, wide::integer<Bits2, Signed2>>\n {\n-    using type = std::conditional_t < Bits == Bits2,\n-          wide::integer<\n-              Bits,\n-              std::conditional_t<(std::is_same_v<Signed, Signed2> && std::is_same_v<Signed2, signed>), signed, unsigned>>,\n-          std::conditional_t<Bits2<Bits, wide::integer<Bits, Signed>, wide::integer<Bits2, Signed2>>>;\n+    using type = std::conditional_t<Bits == Bits2,\n+        wide::integer<\n+            Bits,\n+            std::conditional_t<(std::is_same_v<Signed, Signed2> && std::is_same_v<Signed2, signed>), signed, unsigned>>,\n+        std::conditional_t<Bits2<Bits, wide::integer<Bits, Signed>, wide::integer<Bits2, Signed2>>>;\n };\n \n template <size_t Bits, typename Signed, typename Arithmetic>\ndiff --git a/src/Columns/ColumnFunction.cpp b/src/Columns/ColumnFunction.cpp\nindex 09a3dbad2421..f4b7eeb771ca 100644\n--- a/src/Columns/ColumnFunction.cpp\n+++ b/src/Columns/ColumnFunction.cpp\n@@ -3,9 +3,11 @@\n #include <Columns/ColumnsCommon.h>\n #include <Common/PODArray.h>\n #include <Common/ProfileEvents.h>\n+#include <Common/assert_cast.h>\n #include <IO/WriteHelpers.h>\n #include <Functions/IFunction.h>\n \n+\n namespace ProfileEvents\n {\n     extern const Event FunctionExecute;\n@@ -59,6 +61,40 @@ ColumnPtr ColumnFunction::cut(size_t start, size_t length) const\n     return ColumnFunction::create(length, function, capture, is_short_circuit_argument, is_function_compiled);\n }\n \n+void ColumnFunction::insertFrom(const IColumn & src, size_t n)\n+{\n+    const ColumnFunction & src_func = assert_cast<const ColumnFunction &>(src);\n+\n+    size_t num_captured_columns = captured_columns.size();\n+    assert(num_captured_columns == src_func.captured_columns.size());\n+\n+    for (size_t i = 0; i < num_captured_columns; ++i)\n+    {\n+        auto mut_column = IColumn::mutate(std::move(captured_columns[i].column));\n+        mut_column->insertFrom(*src_func.captured_columns[i].column, n);\n+        captured_columns[i].column = std::move(mut_column);\n+    }\n+\n+    ++size_;\n+}\n+\n+void ColumnFunction::insertRangeFrom(const IColumn & src, size_t start, size_t length)\n+{\n+    const ColumnFunction & src_func = assert_cast<const ColumnFunction &>(src);\n+\n+    size_t num_captured_columns = captured_columns.size();\n+    assert(num_captured_columns == src_func.captured_columns.size());\n+\n+    for (size_t i = 0; i < num_captured_columns; ++i)\n+    {\n+        auto mut_column = IColumn::mutate(std::move(captured_columns[i].column));\n+        mut_column->insertRangeFrom(*src_func.captured_columns[i].column, start, length);\n+        captured_columns[i].column = std::move(mut_column);\n+    }\n+\n+    size_ += length;\n+}\n+\n ColumnPtr ColumnFunction::filter(const Filter & filt, ssize_t result_size_hint) const\n {\n     if (size_ != filt.size())\ndiff --git a/src/Columns/ColumnFunction.h b/src/Columns/ColumnFunction.h\nindex 2592dc01f982..5b410a28ddf6 100644\n--- a/src/Columns/ColumnFunction.h\n+++ b/src/Columns/ColumnFunction.h\n@@ -88,10 +88,8 @@ class ColumnFunction final : public COWHelper<IColumn, ColumnFunction>\n         throw Exception(\"Cannot insert into \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n-    void insertRangeFrom(const IColumn &, size_t, size_t) override\n-    {\n-        throw Exception(\"Cannot insert into \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n-    }\n+    void insertFrom(const IColumn & src, size_t n) override;\n+    void insertRangeFrom(const IColumn &, size_t start, size_t length) override;\n \n     void insertData(const char *, size_t) override\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02178_column_function_insert_from.reference b/tests/queries/0_stateless/02178_column_function_insert_from.reference\nnew file mode 100644\nindex 000000000000..480bb5ef6e74\n--- /dev/null\n+++ b/tests/queries/0_stateless/02178_column_function_insert_from.reference\n@@ -0,0 +1,2 @@\n+1\t0\t['1']\n+1\t1\t['1']\ndiff --git a/tests/queries/0_stateless/02178_column_function_insert_from.sql b/tests/queries/0_stateless/02178_column_function_insert_from.sql\nnew file mode 100644\nindex 000000000000..13d1ebb4788a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02178_column_function_insert_from.sql\n@@ -0,0 +1,14 @@\n+DROP TABLE IF EXISTS TESTTABLE;\n+\n+CREATE TABLE TESTTABLE (\n+  _id UInt64,  pt String, attr_list Array(String)\n+) ENGINE = MergeTree() PARTITION BY (pt) ORDER BY tuple();\n+\n+INSERT INTO TESTTABLE values (0,'0',['1']), (1,'1',['1']);\n+\n+SET max_threads = 1;\n+\n+SELECT attr, _id, arrayFilter(x -> (x IN (select '1')), attr_list) z\n+FROM TESTTABLE ARRAY JOIN z AS attr ORDER BY _id LIMIT 3 BY attr;\n+\n+DROP TABLE TESTTABLE;\n",
  "problem_statement": "Error. Cannot get value from Function with ARRAY JOIN over lambda + limit by \n```\r\nDROP TABLE TESTTABLE;\r\nCREATE TABLE TESTTABLE (\r\n  _id UInt64,  pt String, attr_list Array(String)\r\n) ENGINE = MergeTree() PARTITION BY (pt) ORDER BY  tuple();\r\n\r\ninsert into TESTTABLE  values (0,'0',['1']),(1,'1',['1']);\r\n\r\nSELECT attr, _id, arrayFilter(x -> (x IN (select '1')), attr_list) z\r\nFROM TESTTABLE ARRAY JOIN z AS attr ORDER BY _id LIMIT 3 BY attr\r\n\r\n\u2192 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 19.15.2):\r\nCode: 48. DB::Exception: Received from localhost:9000. DB::Exception: Cannot get value from Function.\r\n\r\n```\r\n 19.15.2.2 (official build).\n",
  "hints_text": "```\r\n18.14.18\r\n\u250c\u2500attr\u2500\u252c\u2500_id\u2500\u252c\u2500z\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1    \u2502   0 \u2502 ['1'] \u2502\r\n\u2502 1    \u2502   1 \u2502 ['1'] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n20.2.1.2362\r\nDB::Exception: Cannot get value from Function: While executing MergeSortingTransform.\r\n\r\n```\nThis issue persists with v20.3.4 as well\nStill relevant in 20.7.\n20.11.1.4897\r\n\r\n```\r\n\u250c\u2500attr\u2500\u252c\u2500_id\u2500\u252c\u2500z\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1    \u2502   0 \u2502 ['1'] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500attr\u2500\u252c\u2500_id\u2500\u252c\u2500z\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1    \u2502   1 \u2502 ['1'] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n20.11.1.4897\r\nNow it needs `max_threads=1` to reproduce.\r\n```\r\n\r\nset max_threads=1;\r\n\r\nSELECT attr, _id, arrayFilter(x -> (x IN (select '1')), attr_list) z\r\nFROM TESTTABLE ARRAY JOIN z AS attr ORDER BY _id LIMIT 3 BY attr;\r\n\r\nCannot get value from Function: While executing MergeSortingTransform.\r\n\r\n```\nstill relevant 21.3.1.5944\nReceived exception from server (version 21.8.2):\r\nCode: 48. DB::Exception: Received from localhost:9000. DB::Exception: Cannot get value from Function: While executing MergeSortingTransform.\nStill relevant in 22.1.",
  "created_at": "2022-01-16T03:19:58Z"
}