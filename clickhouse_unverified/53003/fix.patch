diff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp
index 210dab9921e8..837aae6753a2 100644
--- a/src/DataTypes/FieldToDataType.cpp
+++ b/src/DataTypes/FieldToDataType.cpp
@@ -136,8 +136,17 @@ DataTypePtr FieldToDataType<on_error>::operator() (const Array & x) const
     DataTypes element_types;
     element_types.reserve(x.size());
 
+    bool has_signed_int = false;
+    bool uint64_convert_possible = true;
     for (const Field & elem : x)
-        element_types.emplace_back(applyVisitor(*this, elem));
+    {
+        DataTypePtr type = applyVisitor(*this, elem);
+        element_types.emplace_back(type);
+        checkUInt64ToIn64Conversion(has_signed_int, uint64_convert_possible, type, elem);
+    }
+
+    if (has_signed_int && uint64_convert_possible)
+        convertUInt64ToInt64IfPossible(element_types);
 
     return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(element_types));
 }
@@ -165,14 +174,28 @@ DataTypePtr FieldToDataType<on_error>::operator() (const Map & map) const
     key_types.reserve(map.size());
     value_types.reserve(map.size());
 
+    bool k_has_signed_int = false;
+    bool k_uint64_convert_possible = true;
+    bool v_has_signed_int = false;
+    bool v_uint64_convert_possible = true;
     for (const auto & elem : map)
     {
         const auto & tuple = elem.safeGet<const Tuple &>();
         assert(tuple.size() == 2);
-        key_types.push_back(applyVisitor(*this, tuple[0]));
-        value_types.push_back(applyVisitor(*this, tuple[1]));
+        DataTypePtr k_type = applyVisitor(*this, tuple[0]);
+        key_types.push_back(k_type);
+        checkUInt64ToIn64Conversion(k_has_signed_int, k_uint64_convert_possible, k_type, tuple[0]);
+        DataTypePtr v_type = applyVisitor(*this, tuple[1]);
+        value_types.push_back(v_type);
+        checkUInt64ToIn64Conversion(v_has_signed_int, v_uint64_convert_possible, v_type, tuple[1]);
     }
 
+    if (k_has_signed_int && k_uint64_convert_possible)
+        convertUInt64ToInt64IfPossible(key_types);
+
+    if (v_has_signed_int && v_uint64_convert_possible)
+        convertUInt64ToInt64IfPossible(value_types);
+
     return std::make_shared<DataTypeMap>(
         getLeastSupertype<on_error>(key_types),
         getLeastSupertype<on_error>(value_types));
@@ -204,6 +227,28 @@ DataTypePtr FieldToDataType<on_error>::operator()(const bool &) const
     return DataTypeFactory::instance().get("Bool");
 }
 
+template <LeastSupertypeOnError on_error>
+void FieldToDataType<on_error>::checkUInt64ToIn64Conversion(bool & has_signed_int, bool & uint64_convert_possible, const DataTypePtr & type, const Field & elem) const
+{
+    if (uint64_convert_possible)
+    {
+        bool is_native_int = WhichDataType(type).isNativeInt();
+
+        if (is_native_int)
+            has_signed_int |= is_native_int;
+        else if (type->getTypeId() == TypeIndex::UInt64)
+            uint64_convert_possible &= (elem.template get<UInt64>() <= std::numeric_limits<Int64>::max());
+    }
+}
+
+template <LeastSupertypeOnError on_error>
+void FieldToDataType<on_error>::convertUInt64ToInt64IfPossible(DataTypes & data_types) const
+{
+    for (auto& type : data_types)
+        if (type->getTypeId() == TypeIndex::UInt64)
+            type = std::make_shared<DataTypeInt64>();
+}
+
 template class FieldToDataType<LeastSupertypeOnError::Throw>;
 template class FieldToDataType<LeastSupertypeOnError::String>;
 template class FieldToDataType<LeastSupertypeOnError::Null>;
diff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h
index 8febadc1a0d1..d1a3f11e8de6 100644
--- a/src/DataTypes/FieldToDataType.h
+++ b/src/DataTypes/FieldToDataType.h
@@ -45,6 +45,16 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>
     DataTypePtr operator() (const UInt256 & x) const;
     DataTypePtr operator() (const Int256 & x) const;
     DataTypePtr operator() (const bool & x) const;
+
+private:
+    // The conditions for converting UInt64 to Int64 are:
+    // 1. The existence of Int.
+    // 2. The existence of UInt64, and the UInt64 value must be <= Int64.max.
+    void checkUInt64ToIn64Conversion(bool& has_signed_int, bool& uint64_convert_possible, const DataTypePtr & type, const Field & elem) const;
+
+    // Convert the UInt64 type to Int64 in order to cover other signed_integer types
+    // and obtain the least super type of all ints.
+    void convertUInt64ToInt64IfPossible(DataTypes & data_types) const;
 };
 
 }
