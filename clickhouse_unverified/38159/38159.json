{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38159,
  "instance_id": "ClickHouse__ClickHouse-38159",
  "issue_numbers": [
    "38126"
  ],
  "base_commit": "5e86d6c55b6f325c22a3bb1f2d0cafb47b94e16c",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex 55fd684fddbc..a8924e3aaba6 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -268,3 +268,9 @@\n [submodule \"contrib/hashidsxx\"]\n \tpath = contrib/hashidsxx\n \turl = https://github.com/schoentoon/hashidsxx.git\n+[submodule \"contrib/base-x\"]\n+\tpath = contrib/base-x\n+\turl = https://github.com/ClickHouse/base-x.git\n+[submodule \"contrib/liburing\"]\n+\tpath = contrib/liburing\n+\turl = https://github.com/axboe/liburing.git\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 09cf80595a72..f2513c29d3e2 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -155,6 +155,7 @@ endif()\n \n add_contrib (sqlite-cmake sqlite-amalgamation)\n add_contrib (s2geometry-cmake s2geometry)\n+add_contrib (base-x-cmake base-x)\n \n # Put all targets defined here and in subdirectories under \"contrib/<immediate-subdir>\" folders in GUI-based IDEs.\n # Some of third-party projects may override CMAKE_FOLDER or FOLDER property of their targets, so they would not appear\ndiff --git a/contrib/base-x-cmake/CMakeLists.txt b/contrib/base-x-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..b0c11a176c6c\n--- /dev/null\n+++ b/contrib/base-x-cmake/CMakeLists.txt\n@@ -0,0 +1,28 @@\n+option (ENABLE_BASEX \"Enable base-x\" ${ENABLE_LIBRARIES})\n+\n+if (NOT ENABLE_BASEX)\n+    message(STATUS \"Not using base-x\")\n+    return()\n+endif()\n+\n+set(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/base-x\")\n+\n+set (SRCS\n+        ${LIBRARY_DIR}/base_x.hh\n+        ${LIBRARY_DIR}/uinteger_t.hh\n+        )\n+\n+add_library(_base-x INTERFACE)\n+target_include_directories(_base-x SYSTEM BEFORE INTERFACE \"${ClickHouse_SOURCE_DIR}/contrib/base-x\")\n+\n+if (XCODE OR XCODE_VERSION)\n+    # https://gitlab.kitware.com/cmake/cmake/issues/17457\n+    #     Some native build systems may not like targets that have only object files, so consider adding at least one real source file\n+    # This applies to Xcode.\n+    if (NOT EXISTS \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\")\n+        file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\" \"\")\n+    endif ()\n+    target_sources(_base-x PRIVATE \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\")\n+endif ()\n+\n+add_library(ch_contrib::base-x ALIAS _base-x)\n\\ No newline at end of file\ndiff --git a/contrib/base-x/.gitignore b/contrib/base-x/.gitignore\nnew file mode 100644\nindex 000000000000..b63b40c8b71c\n--- /dev/null\n+++ b/contrib/base-x/.gitignore\n@@ -0,0 +1,4 @@\n+.DS_Store\n+test\n+*.o\n+*.dSYM\n\\ No newline at end of file\ndiff --git a/contrib/base-x/.travis.yml b/contrib/base-x/.travis.yml\nnew file mode 100755\nindex 000000000000..f55132e614f2\n--- /dev/null\n+++ b/contrib/base-x/.travis.yml\n@@ -0,0 +1,36 @@\n+sudo: false\n+\n+language: cpp\n+\n+compiler:\n+  - clang\n+  - gcc\n+\n+addons:\n+  apt:\n+    sources:\n+    - ubuntu-toolchain-r-test\n+    - llvm-toolchain-precise-3.8\n+    packages:\n+    - g++-6\n+    - clang-3.8\n+\n+install:\n+  - if [ \"$CXX\" = \"g++\" ]; then export CXX=\"g++-6\"; fi\n+  - if [ \"$CXX\" == \"clang++\" ]; then export CXX=\"clang++-3.8\"; fi\n+  - sudo apt-get install -qq git cmake\n+\n+before_script:\n+  # not much better than git submodules, but there was never a need/want for the repo in this repo\n+  - cd ..\n+  - git clone https://github.com/google/googletest.git\n+  - cd googletest\n+  - git reset --hard d62d6c6556d96dda924382547c54a4b3afedb22c\n+  - cmake CMakeLists.txt\n+  - make\n+\n+  - cd ../base-x/tests\n+  - make\n+\n+script:\n+  - make run\ndiff --git a/contrib/base-x/LICENSE b/contrib/base-x/LICENSE\nnew file mode 100644\nindex 000000000000..f7b3408abace\n--- /dev/null\n+++ b/contrib/base-x/LICENSE\n@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\ndiff --git a/contrib/base-x/README.md b/contrib/base-x/README.md\nnew file mode 100644\nindex 000000000000..5dc4a068043c\n--- /dev/null\n+++ b/contrib/base-x/README.md\n@@ -0,0 +1,97 @@\n+\ufeff# base-x [![License][license-img]][license-url] [![GitHub Stars][stars-img]][stars-url] [![GitHub Forks][forks-img]][forks-url] [![GitHub Watchers][watchers-img]][watchers-url] [![Tweet][tweet-img]][tweet-url]\n+\n+[![Build Status](https://travis-ci.org/Kronuz/base-x.svg?branch=master)](https://travis-ci.org/Kronuz/base-x)\n+\n+\n+### BaseX encoder / decoder for C++\n+\n+This is a fast base encoder / decoder of any given alphabet.\n+\n+\n+#### Example\n+\n+``` cpp\n+// example.cc\n+// g++ -std=c++14 -o example example.cc\n+\n+#include <iostream>\n+#include \"base_x.hh\"\n+\n+int main() {\n+    auto encoded = Base58::base58().encode(\"Hello world!\");\n+\n+    std::cout << encoded << std::endl;\n+    // => 1LDlk6QWOejX6rPrJ\n+\n+    return 0;\n+}\n+```\n+\n+\n+#### Compilation\n+\n+* g++ and clang++ are supported.\n+* C++14 is required.\n+\n+\n+### Alphabets\n+\n+See below for a list of commonly recognized alphabets, and their respective base.\n+\n+Base | Factory             | Alphabet\n+-----|---------------------|-------------\n+   2 | base2::base2()      | `01`\n+   2 | base8::base8()      | `01234567`\n+  11 | bas11::bas11()      | `0123456789a`\n+  16 | base16::base16()    | `0123456789abcdef`\n+  32 | base32::base32()    | `0123456789ABCDEFGHJKMNPQRSTVWXYZ`\n+  36 | base36::base36()    | `0123456789abcdefghijklmnopqrstuvwxyz`\n+  58 | base58::base58()    | `123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`\n+  58 | base58::bitcoin()   | `123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`\n+  58 | base58::gmp()       | `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv`\n+  58 | base58::ripple()    | `rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz`\n+  58 | base58::flickr()    | `123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ`\n+  62 | base62::base62()    | `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`\n+  62 | base62::inverted()  | `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`\n+  64 | base64::base64()    | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`\n+  64 | base64::urlsafe()   | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_`\n+  66 | base66::base66()    | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~`\n+\n+\n+### How it works\n+\n+It encodes octet arrays by doing long divisions on all significant digits in the\n+array, creating a representation of that number in the new base.\n+\n+**If you need standard hex encoding, or base64 encoding, this module is NOT\n+appropriate.**\n+\n+\n+## Author\n+[**German Mendez Bravo (Kronuz)**](https://kronuz.io/)\n+\n+[![Follow on GitHub][github-follow-img]][github-follow-url]\n+[![Follow on Twitter][twitter-follow-img]][twitter-follow-url]\n+\n+\n+## License\n+\n+MIT License. See [LICENSE](LICENSE) for details.\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+\n+\n+[license-url]: https://github.com/Kronuz/base-x/blob/master/LICENSE\n+[license-img]: https://img.shields.io/github/license/Kronuz/base-x.svg\n+[stars-url]: https://github.com/Kronuz/base-x/stargazers\n+[stars-img]: https://img.shields.io/github/stars/Kronuz/base-x.svg?style=social&amp;label=Stars\n+[forks-url]: https://github.com/Kronuz/base-x/network/members\n+[forks-img]: https://img.shields.io/github/forks/Kronuz/base-x.svg?style=social&amp;label=Forks\n+[watchers-url]: https://github.com/Kronuz/base-x/watchers\n+[watchers-img]: https://img.shields.io/github/watchers/Kronuz/base-x.svg?style=social&amp;label=Watchers\n+[tweet-img]: https://img.shields.io/twitter/url/https/github.com/Kronuz/base-x.svg?style=social\n+[tweet-url]: https://twitter.com/intent/tweet?text=Base-X+encoding%2Fdecoding+for+modern+C%2B%2B+by+%40germbravo:&url=https%3A%2F%2Fgithub.com%2FKronuz%2Fbase-x\n+[github-follow-url]: https://github.com/Kronuz\n+[github-follow-img]: https://img.shields.io/github/followers/Kronuz.svg?style=social&label=Follow\n+[twitter-follow-url]: https://twitter.com/intent/follow?screen_name=germbravo\n+[twitter-follow-img]: https://img.shields.io/twitter/follow/germbravo.svg?style=social&label=Follow\ndiff --git a/contrib/base-x/base_x.hh b/contrib/base-x/base_x.hh\nnew file mode 100644\nindex 000000000000..fdc06fead2f1\n--- /dev/null\n+++ b/contrib/base-x/base_x.hh\n@@ -0,0 +1,614 @@\n+/*\n+base_x.hh\n+BaseX encoder / decoder for C++\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+*/\n+\n+#ifndef __BASE_X__H_\n+#define __BASE_X__H_\n+\n+#include <algorithm>        // for std::find_if, std::reverse\n+#include <stdexcept>        // for std::invalid_argument\n+#include <string>           // for std::string\n+#include <type_traits>      // for std::enable_if_t\n+\n+#include \"uinteger_t.hh\"\n+\n+\n+class BaseX {\n+\tchar _chr[256];\n+\tint _ord[256];\n+\n+\tconst int size;\n+\tconst int alphabet_base;\n+\tconst unsigned base_size;\n+\tconst unsigned alphabet_base_bits;\n+\tconst unsigned block_size;\n+\tconst uinteger_t::digit alphabet_base_mask;\n+\tconst unsigned padding_size;\n+\tconst char padding;\n+\tconst int flags;\n+\n+\tconstexpr char chr(unsigned char ord) const {\n+\t\treturn _chr[ord];\n+\t}\n+\n+\tconstexpr int ord(unsigned char chr) const {\n+\t\treturn _ord[chr];\n+\t}\n+\n+public:\n+\tstatic constexpr int ignore_case =   (1 << 0);\n+\tstatic constexpr int with_checksum = (1 << 1);\n+\tstatic constexpr int with_check =    (1 << 2);\n+\tstatic constexpr int block_padding = (1 << 3);\n+\n+\ttemplate <std::size_t alphabet_size1, std::size_t extended_size1, std::size_t padding_size1, std::size_t translate_size1>\n+\tconstexpr BaseX(int flgs, const char (&alphabet)[alphabet_size1], const char (&extended)[extended_size1], const char (&padding_string)[padding_size1], const char (&translate)[translate_size1]) :\n+\t\t_chr(),\n+\t\t_ord(),\n+\t\tsize(alphabet_size1 - 1 + extended_size1 - 1),\n+\t\talphabet_base(alphabet_size1 - 1),\n+\t\tbase_size(uinteger_t::base_size(alphabet_base)),\n+\t\talphabet_base_bits(uinteger_t::base_bits(alphabet_base)),\n+\t\tblock_size((flgs & BaseX::block_padding) ? alphabet_base_bits : 0),\n+\t\talphabet_base_mask(alphabet_base - 1),\n+\t\tpadding_size(padding_size1 - 1),\n+\t\tpadding(padding_size ? padding_string[0] : '\\0'),\n+\t\tflags(flgs)\n+\t{\n+\t\tfor (int c = 0; c < 256; ++c) {\n+\t\t\t_chr[c] = 0;\n+\t\t\t_ord[c] = alphabet_base;\n+\t\t}\n+\t\tfor (int cp = 0; cp < alphabet_base; ++cp) {\n+\t\t\tauto ch = alphabet[cp];\n+\t\t\t_chr[cp] = ch;\n+\t\t\tASSERT(_ord[(unsigned char)ch] == alphabet_base);  // Duplicate character in the alphabet\n+\t\t\t_ord[(unsigned char)ch] = cp;\n+\t\t\tif (flags & BaseX::ignore_case) {\n+\t\t\t\tif (ch >= 'A' && ch <='Z') {\n+\t\t\t\t\t_ord[(unsigned char)ch - 'A' + 'a'] = cp;\n+\t\t\t\t} else if (ch >= 'a' && ch <='z') {\n+\t\t\t\t\t_ord[(unsigned char)ch - 'a' + 'A'] = cp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (std::size_t i = 0; i < extended_size1 - 1; ++i) {\n+\t\t\tauto ch = extended[i];\n+\t\t\tauto cp = alphabet_base + i;\n+\t\t\t_chr[cp] = ch;\n+\t\t\tASSERT(_ord[(unsigned char)ch] == alphabet_base); // Duplicate character in the extended alphabet\n+\t\t\t_ord[(unsigned char)ch] = cp;\n+\t\t\tif (flags & BaseX::ignore_case) {\n+\t\t\t\tif (ch >= 'A' && ch <='Z') {\n+\t\t\t\t\t_ord[(unsigned char)ch - 'A' + 'a'] = cp;\n+\t\t\t\t} else if (ch >= 'a' && ch <='z') {\n+\t\t\t\t\t_ord[(unsigned char)ch - 'a' + 'A'] = cp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tint cp = -1;\n+\t\tfor (std::size_t i = 0; i < translate_size1 - 1; ++i) {\n+\t\t\tauto ch = translate[i];\n+\t\t\tauto ncp = _ord[(unsigned char)ch];\n+\t\t\tif (ncp >= alphabet_base) {\n+\t\t\t\tASSERT(_ord[(unsigned char)ch] == alphabet_base); // Invalid translation character\n+\t\t\t\t_ord[(unsigned char)ch] = cp;\n+\t\t\t\tif (flags & BaseX::ignore_case) {\n+\t\t\t\t\tif (ch >= 'A' && ch <='Z') {\n+\t\t\t\t\t\t_ord[(unsigned char)ch - 'A' + 'a'] = cp;\n+\t\t\t\t\t} else if (ch >= 'a' && ch <='z') {\n+\t\t\t\t\t\t_ord[(unsigned char)ch - 'a' + 'A'] = cp;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcp = ncp;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Get string representation of value\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid encode(Result& result, const uinteger_t& input) const {\n+\t\tstd::size_t bp = 0;\n+\t\tuinteger_t quotient;\n+\t\tif (block_size) {\n+\t\t\tbp = ((input.bits() + 7) & 0xf8) % block_size;\n+\t\t\tbp = bp ? (block_size - bp) % block_size : 0;\n+\t\t\tif (bp) {\n+\t\t\t\tquotient = input << bp;\n+\t\t\t}\n+\t\t}\n+\t\tconst uinteger_t& num = bp ? quotient : input;\n+\t\tauto num_sz = num.size();\n+\t\tif (num_sz) {\n+\t\t\tint sum = 0;\n+\t\t\tresult.reserve(num_sz * base_size);\n+\t\t\tif (alphabet_base_bits) {\n+\t\t\t\tstd::size_t shift = 0;\n+\t\t\t\tauto ptr = reinterpret_cast<const uinteger_t::half_digit*>(num.data());\n+\t\t\t\tuinteger_t::digit v = *ptr++;\n+\t\t\t\tv <<= uinteger_t::half_digit_bits;\n+\t\t\t\tfor (auto i = num_sz * 2 - 1; i; --i) {\n+\t\t\t\t\tv >>= uinteger_t::half_digit_bits;\n+\t\t\t\t\tv |= (static_cast<uinteger_t::digit>(*ptr++) << uinteger_t::half_digit_bits);\n+\t\t\t\t\tdo {\n+\t\t\t\t\t\tauto d = static_cast<int>((v >> shift) & alphabet_base_mask);\n+\t\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\t\tshift += alphabet_base_bits;\n+\t\t\t\t\t\tsum += d;\n+\t\t\t\t\t} while (shift <= uinteger_t::half_digit_bits);\n+\t\t\t\t\tshift -= uinteger_t::half_digit_bits;\n+\t\t\t\t}\n+\t\t\t\tv >>= (shift + uinteger_t::half_digit_bits);\n+\t\t\t\twhile (v) {\n+\t\t\t\t\tauto d = static_cast<int>(v & alphabet_base_mask);\n+\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\tv >>= alphabet_base_bits;\n+\t\t\t\t\tsum += d;\n+\t\t\t\t}\n+\t\t\t\tauto s = chr(0);\n+\t\t\t\tauto rit_f = std::find_if(result.rbegin(), result.rend(), [s](const char& c) { return c != s; });\n+\t\t\t\tresult.resize(result.rend() - rit_f); // shrink\n+\t\t\t} else {\n+\t\t\t\tuinteger_t uint_base = alphabet_base;\n+\t\t\t\tif (!bp) {\n+\t\t\t\t\tquotient = num;\n+\t\t\t\t}\n+\t\t\t\tdo {\n+\t\t\t\t\tauto r = quotient.divmod(uint_base);\n+\t\t\t\t\tauto d = static_cast<int>(r.second);\n+\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\tquotient = std::move(r.first);\n+\t\t\t\t\tsum += d;\n+\t\t\t\t} while (quotient);\n+\t\t\t}\n+\t\t\tstd::reverse(result.begin(), result.end());\n+\t\t\tif (padding_size) {\n+\t\t\t\tResult p;\n+\t\t\t\tp.resize((padding_size - (result.size() % padding_size)) % padding_size, padding);\n+\t\t\t\tresult.append(p);\n+\t\t\t}\n+\t\t\tif (flags & BaseX::with_check) {\n+\t\t\t\tauto chk = static_cast<int>(num % size);\n+\t\t\t\tresult.push_back(chr(chk));\n+\t\t\t\tsum += chk;\n+\t\t\t}\n+\t\t\tif (flags & BaseX::with_checksum) {\n+\t\t\t\tauto sz = result.size();\n+\t\t\t\tsz = (sz + sz / size) % size;\n+\t\t\t\tsum += sz;\n+\t\t\t\tsum = (size - sum % size) % size;\n+\t\t\t\tresult.push_back(chr(sum));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult.push_back(chr(0));\n+\t\t}\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult encode(const uinteger_t& num) const {\n+\t\tResult result;\n+\t\tencode(result, num);\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid encode(Result& result, const unsigned char* decoded, std::size_t decoded_size) const {\n+\t\tencode(result, uinteger_t(decoded, decoded_size, 256));\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult encode(const unsigned char* decoded, std::size_t decoded_size) const {\n+\t\tResult result;\n+\t\tencode(result, uinteger_t(decoded, decoded_size, 256));\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid encode(Result& result, const char* decoded, std::size_t decoded_size) const {\n+\t\tencode(result, uinteger_t(decoded, decoded_size, 256));\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult encode(const char* decoded, std::size_t decoded_size) const {\n+\t\tResult result;\n+\t\tencode(result, uinteger_t(decoded, decoded_size, 256));\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid encode(Result& result, T (&s)[N]) const {\n+\t\tencode(result, s, N - 1);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult encode(T (&s)[N]) const {\n+\t\tResult result;\n+\t\tencode(result, s, N - 1);\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid encode(Result& result, const std::string& binary) const {\n+\t\treturn encode(result, binary.data(), binary.size());\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult encode(const std::string& binary) const {\n+\t\tResult result;\n+\t\tencode(result, binary.data(), binary.size());\n+\t\treturn result;\n+\t}\n+\n+\tvoid decode(uinteger_t& result, const char* encoded, std::size_t encoded_size) const {\n+\t\tresult = 0;\n+\t\tint sum = 0;\n+\t\tint sumsz = 0;\n+\t\tint direction = 1;\n+\n+\t\tauto sz = encoded_size;\n+\t\tif (flags & BaseX::with_checksum) --sz;\n+\t\tif (flags & BaseX::with_check) --sz;\n+\n+\t\tint bp = 0;\n+\n+\t\tif (alphabet_base_bits) {\n+\t\t\tfor (; sz; --sz, encoded += direction) {\n+\t\t\t\tauto c = *encoded;\n+\t\t\t\tif (c == padding) break;\n+\t\t\t\tauto d = ord(static_cast<int>(c));\n+\t\t\t\tif (d < 0) continue; // ignored character\n+\t\t\t\tif (d >= alphabet_base) {\n+\t\t\t\t\tthrow std::invalid_argument(\"Error: Invalid character: '\" + std::string(1, c) + \"' at \" + std::to_string(encoded_size - sz));\n+\t\t\t\t}\n+\t\t\t\tsum += d;\n+\t\t\t\t++sumsz;\n+\t\t\t\tresult = (result << alphabet_base_bits) | d;\n+\t\t\t\tbp += block_size;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tuinteger_t uint_base = alphabet_base;\n+\t\t\tfor (; sz; --sz, encoded += direction) {\n+\t\t\t\tauto c = *encoded;\n+\t\t\t\tif (c == padding) break;\n+\t\t\t\tauto d = ord(static_cast<int>(c));\n+\t\t\t\tif (d < 0) continue; // ignored character\n+\t\t\t\tif (d >= alphabet_base) {\n+\t\t\t\t\tthrow std::invalid_argument(\"Error: Invalid character: '\" + std::string(1, c) + \"' at \" + std::to_string(encoded_size - sz));\n+\t\t\t\t}\n+\t\t\t\tsum += d;\n+\t\t\t\t++sumsz;\n+\t\t\t\tresult = (result * uint_base) + d;\n+\t\t\t\tbp += block_size;\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (; sz && *encoded == padding; --sz, ++encoded);\n+\n+\t\tresult >>= (bp & 7);\n+\n+\t\tif (flags & BaseX::with_check) {\n+\t\t\tauto c = *encoded;\n+\t\t\tauto d = ord(static_cast<int>(c));\n+\t\t\tif (d < 0 || d >= size) {\n+\t\t\t\tthrow std::invalid_argument(\"Error: Invalid character: '\" + std::string(1, c) + \"' at \" + std::to_string(encoded_size - sz));\n+\t\t\t}\n+\t\t\tauto chk = static_cast<int>(result % size);\n+\t\t\tif (d != chk) {\n+\t\t\t\tthrow std::invalid_argument(\"Error: Invalid check\");\n+\t\t\t}\n+\t\t\tsum += chk;\n+\t\t\t++sumsz;\n+\t\t\t++encoded;\n+\t\t}\n+\n+\t\tif (flags & BaseX::with_checksum) {\n+\t\t\tauto c = *encoded;\n+\t\t\tauto d = ord(static_cast<int>(c));\n+\t\t\tif (d < 0 || d >= size) {\n+\t\t\t\tthrow std::invalid_argument(\"Error: Invalid character: '\" + std::string(1, c) + \"' at \" + std::to_string(encoded_size - sz));\n+\t\t\t}\n+\t\t\tsum += d;\n+\t\t\tsum += (sumsz + sumsz / size) % size;\n+\t\t\tif (sum % size) {\n+\t\t\t\tthrow std::invalid_argument(\"Error: Invalid checksum\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\ttemplate <typename Result, typename = typename std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tvoid decode(Result& result, const char* encoded, std::size_t encoded_size) const {\n+\t\tuinteger_t num;\n+\t\tdecode(num, encoded, encoded_size);\n+\t\tresult = num.template str<Result>(256);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>\n+\tResult decode(const char* encoded, std::size_t encoded_size) const {\n+\t\tResult result;\n+\t\tdecode(result, encoded, encoded_size);\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>\n+\tvoid decode(Result& result, T (&s)[N]) const {\n+\t\tdecode(result, s, N - 1);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>\n+\tResult decode(T (&s)[N]) const {\n+\t\tResult result;\n+\t\tdecode(result, s, N - 1);\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>\n+\tvoid decode(Result& result, const std::string& encoded) const {\n+\t\tdecode(result, encoded.data(), encoded.size());\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>\n+\tResult decode(const std::string& encoded) const {\n+\t\tResult result;\n+\t\tdecode(result, encoded.data(), encoded.size());\n+\t\treturn result;\n+\t}\n+\n+\tbool is_valid(const char* encoded, std::size_t encoded_size) const {\n+\t\tint sum = 0;\n+\t\tint sumsz = 0;\n+\t\tif (flags & BaseX::with_checksum) --sumsz;\n+\t\tfor (; encoded_size; --encoded_size, ++encoded) {\n+\t\t\tauto d = ord(static_cast<int>(*encoded));\n+\t\t\tif (d < 0) continue; // ignored character\n+\t\t\tif (d >= alphabet_base) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tsum += d;\n+\t\t\t++sumsz;\n+\t\t}\n+\t\tif (flags & BaseX::with_checksum) {\n+\t\t\tsum += (sumsz + sumsz / size) % size;\n+\t\t\tif (sum % size) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\ttemplate <typename T, std::size_t N>\n+\tbool is_valid(T (&s)[N]) const {\n+\t\treturn is_valid(s, N - 1);\n+\t}\n+\n+\tbool is_valid(const std::string& encoded) const {\n+\t\treturn is_valid(encoded.data(), encoded.size());\n+\t}\n+};\n+\n+// base2\n+struct Base2 {\n+\tstatic const BaseX& base2() {\n+\t\tstatic constexpr BaseX encoder(0, \"01\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base2chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"01\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base8\n+struct Base8 {\n+\tstatic const BaseX& base8() {\n+\t\tstatic constexpr BaseX encoder(0, \"01234567\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base8chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"01234567\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base11\n+struct Base11 {\n+\tstatic const BaseX& base11() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case, \"0123456789a\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base11chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, \"0123456789a\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base16\n+struct Base16 {\n+\tstatic const BaseX& base16() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case, \"0123456789abcdef\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base16chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, \"0123456789abcdef\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& rfc4648() {\n+\t\tstatic constexpr BaseX encoder(0, \"0123456789ABCDEF\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base32\n+struct Base32 {\n+\tstatic const BaseX& base32() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case, \"0123456789abcdefghijklmnopqrstuv\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base32chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, \"0123456789abcdefghijklmnopqrstuv\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& crockford() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case, \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\", \"\", \"\", \"-0O1IL\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& crockfordchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_check, \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\", \"*~$=U\", \"\", \"-0O1IL\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& rfc4648() {\n+\t\tstatic constexpr BaseX encoder(BaseX::block_padding, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", \"\", \"========\", \"\\n\\r\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& rfc4648hex() {\n+\t\tstatic constexpr BaseX encoder(BaseX::block_padding, \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", \"\", \"========\", \"\\n\\r\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base36\n+struct Base36 {\n+\tstatic const BaseX& base36() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case, \"0123456789abcdefghijklmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base36chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, \"0123456789abcdefghijklmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base58\n+struct Base58 {\n+\tstatic const BaseX& base58() {\n+\t\tstatic constexpr BaseX encoder(0, \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base58chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& bitcoin() {\n+\t\tstatic constexpr BaseX encoder(0, \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& bitcoinchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& ripple() {\n+\t\tstatic constexpr BaseX encoder(0, \"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& ripplechk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& flickr() {\n+\t\tstatic constexpr BaseX encoder(0, \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& flickrchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base59\n+struct Base59 {\n+\tstatic const BaseX& base59() {\n+\t\tstatic constexpr BaseX encoder(0, \"23456789abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ\", \"\", \"\", \"l1IO0\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base59chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"23456789abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ\", \"\", \"\", \"l1IO0\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& dubaluchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"zy9MalDxwpKLdvW2AtmscgbYUq6jhP7E53TiXenZRkVCrouBH4GSQf8FNJO\", \"\", \"\", \"-l1IO0\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base62\n+struct Base62 {\n+\tstatic const BaseX& base62() {\n+\t\tstatic constexpr BaseX encoder(0, \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base62chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& inverted() {\n+\t\tstatic constexpr BaseX encoder(0, \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& invertedchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base64\n+struct Base64 {\n+\tstatic const BaseX& base64() {\n+\t\tstatic constexpr BaseX encoder(0, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base64chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& url() {\n+\t\tstatic constexpr BaseX encoder(0, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& urlchk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& rfc4648() {\n+\t\tstatic constexpr BaseX encoder(BaseX::block_padding, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", \"\", \"====\", \"\\n\\r\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& rfc4648url() {\n+\t\tstatic constexpr BaseX encoder(BaseX::block_padding, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", \"\", \"====\", \"\\n\\r\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+// base66\n+struct Base66 {\n+\tstatic const BaseX& base66() {\n+\t\tstatic constexpr BaseX encoder(0, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+\tstatic const BaseX& base66chk() {\n+\t\tstatic constexpr BaseX encoder(BaseX::with_checksum, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~\", \"\", \"\", \"\");\n+\t\treturn encoder;\n+\t}\n+};\n+\n+#endif\ndiff --git a/contrib/base-x/uinteger_t.hh b/contrib/base-x/uinteger_t.hh\nnew file mode 100644\nindex 000000000000..901460f75c49\n--- /dev/null\n+++ b/contrib/base-x/uinteger_t.hh\n@@ -0,0 +1,2546 @@\n+/*\n+uinteger_t.hh\n+An arbitrary precision unsigned integer type for C++\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+Copyright (c) 2013 - 2017 Jason Lee @ calccrypto at gmail.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+\n+With much help from Auston Sterling\n+\n+Thanks to Stefan Deigm\u00fcller for finding\n+a bug in operator*.\n+\n+Thanks to Fran\u00e7ois Dessenne for convincing me\n+to do a general rewrite of this class.\n+\n+Germ\u00e1n M\u00e1ndez Bravo (Kronuz) converted Jason Lee's uint128_t\n+to header-only and extended to arbitrary bit length.\n+*/\n+\n+#ifndef __uint_t__\n+#define __uint_t__\n+\n+#include <vector>\n+#include <string>\n+#include <cassert>\n+#include <utility>\n+#include <cstring>\n+#include <cstdint>\n+#include <iostream>\n+#include <algorithm>\n+#include <stdexcept>\n+#include <functional>\n+#include <type_traits>\n+\n+#define ASSERT assert\n+\n+// Compatibility inlines\n+#ifndef __has_builtin         // Optional of course\n+#define __has_builtin(x) 0    // Compatibility with non-clang compilers\n+#endif\n+\n+#if defined _MSC_VER\n+#  define HAVE___ADDCARRY_U64\n+#  define HAVE___SUBBORROW_U64\n+#  define HAVE___ADDCARRY_U32\n+#  define HAVE___SUBBORROW_U32\n+#  define HAVE___ADDCARRY_U16\n+#  define HAVE___SUBBORROW_U16\n+#  define HAVE___UMUL128\n+#  define HAVE___UMUL64\n+#  define HAVE___UMUL32\n+#  include <intrin.h>\n+#endif\n+\n+#if (defined(__clang__) && __has_builtin(__builtin_clzll)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))\n+#  define HAVE____BUILTIN_CLZLL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_clzl)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))\n+#  define HAVE____BUILTIN_CLZL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_clz)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))\n+#  define HAVE____BUILTIN_CLZ\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_addcll))\n+#  define HAVE____BUILTIN_ADDCLL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_addcl))\n+#  define HAVE____BUILTIN_ADDCL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_addc))\n+#  define HAVE____BUILTIN_ADDC\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_subcll))\n+#  define HAVE____BUILTIN_SUBCLL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_subcl))\n+#  define HAVE____BUILTIN_SUBCL\n+#endif\n+#if (defined(__clang__) && __has_builtin(__builtin_subc))\n+#  define HAVE____BUILTIN_SUBC\n+#endif\n+\n+#if defined __SIZEOF_INT128__\n+#define HAVE____INT128_T\n+#endif\n+\n+\n+#ifndef DIGIT_T\n+#define DIGIT_T        std::uint64_t\n+#endif\n+\n+#ifndef HALF_DIGIT_T\n+#define HALF_DIGIT_T   std::uint32_t\n+#endif\n+\n+class uinteger_t;\n+\n+namespace std {  // This is probably not a good idea\n+\t// Give uinteger_t type traits\n+\ttemplate <> struct is_arithmetic <uinteger_t> : std::true_type {};\n+\ttemplate <> struct is_integral   <uinteger_t> : std::true_type {};\n+\ttemplate <> struct is_unsigned   <uinteger_t> : std::true_type {};\n+}\n+\n+class uinteger_t {\n+public:\n+\tusing digit = DIGIT_T;\n+\tusing half_digit = HALF_DIGIT_T;\n+\n+\tstatic constexpr std::size_t digit_octets = sizeof(digit);             // number of octets per digit\n+\tstatic constexpr std::size_t digit_bits = digit_octets * 8;            // number of bits per digit\n+\tstatic constexpr std::size_t half_digit_octets = sizeof(half_digit);   // number of octets per half_digit\n+\tstatic constexpr std::size_t half_digit_bits = half_digit_octets * 8;  // number of bits per half_digit\n+\n+\tusing container = std::vector<digit>;\n+\n+\ttemplate <typename T>\n+\tstruct is_result {\n+\t\tstatic const bool value = false;\n+\t};\n+\n+\ttemplate <typename T, typename Alloc>\n+\tstruct is_result<std::vector<T, Alloc>> {\n+\t\tstatic const bool value = true;\n+\t};\n+\n+\ttemplate <typename charT, typename traits, typename Alloc>\n+\tstruct is_result<std::basic_string<charT, traits, Alloc>> {\n+\t\tstatic const bool value = true;\n+\t};\n+\n+private:\n+\tstatic_assert(digit_octets == half_digit_octets * 2, \"half_digit must be exactly half the size of digit\");\n+\n+\tstatic constexpr std::size_t karatsuba_cutoff = 1024 / digit_bits;\n+\tstatic constexpr double growth_factor = 1.5;\n+\n+\tstd::size_t _begin;\n+\tstd::size_t _end;\n+\tcontainer _value_instance;\n+\tcontainer& _value;\n+\tbool _carry;\n+\n+public:\n+\t// Window to vector (uses _begin and _end)\n+\n+\tvoid reserve(std::size_t sz) {\n+\t\t_value.reserve(sz + _begin);\n+\t}\n+\n+\tstd::size_t grow(std::size_t n) {\n+\t\t// expands the vector using a growth factor\n+\t\t// and returns the new capacity.\n+\t\tauto cc = _value.capacity();\n+\t\tif (n >= cc) {\n+\t\t\tcc = n * growth_factor;\n+\t\t\t_value.reserve(cc);\n+\t\t}\n+\t\treturn cc;\n+\t}\n+\n+\tvoid resize(std::size_t sz) {\n+\t\tgrow(sz + _begin);\n+\t\t_value.resize(sz + _begin);\n+\t}\n+\n+\tvoid resize(std::size_t sz, const digit& c) {\n+\t\tgrow(sz + _begin);\n+\t\t_value.resize(sz + _begin, c);\n+\t}\n+\n+\tvoid clear() {\n+\t\t_value.clear();\n+\t\t_begin = 0;\n+\t\t_end = 0;\n+\t\t_carry = false;\n+\t}\n+\n+\tdigit* data() noexcept {\n+\t\treturn _value.data() + _begin;\n+\t}\n+\n+\tconst digit* data() const noexcept {\n+\t\treturn _value.data() + _begin;\n+\t}\n+\n+\tstd::size_t size() const noexcept {\n+\t\treturn _end ? _end - _begin : _value.size() - _begin;\n+\t}\n+\n+\tvoid prepend(std::size_t sz, const digit& c) {\n+\t\t// Efficiently prepend by growing backwards by growth factor\n+\t\tauto min = std::min(_begin, sz);\n+\t\tif (min) {\n+\t\t\t// If there is some space before `_begin`, we try using it first:\n+\t\t\t_begin -= min;\n+\t\t\tstd::fill_n(_value.begin() + _begin, min, c);\n+\t\t\tsz -= min;\n+\t\t}\n+\t\tif (sz) {\n+\t\t\tASSERT(_begin == 0); // _begin should be 0 in here\n+\t\t\t// If there's still more room needed, we grow the vector:\n+\t\t\t// Ex.: grow using prepend(3, y)\n+\t\t\t//    sz = 3\n+\t\t\t//    _begin = 0  (B)\n+\t\t\t//    _end = 1  (E)\n+\t\t\t// initially (capacity == 12):\n+\t\t\t//              |xxxxxxxxxx- |\n+\t\t\t//              B           E\n+\t\t\t// after reclaiming space after `_end` (same capacity == 12):\n+\t\t\t//              |xxxxxxxxxx  |\n+\t\t\t//              B\n+\t\t\t//    _end = 0\n+\t\t\t//    csz = 10\n+\t\t\t// grow returns the new capacity (22)\n+\t\t\t//    isz = 12  (22 - 10)\n+\t\t\t//    _begin = 9  (12 - 3)\n+\t\t\t// after (capacity == (12 + 3) * 1.5 == 22):\n+\t\t\t//    |---------yyyxxxxxxxxxx|\n+\t\t\t//              B\n+\t\t\tif (_end) {\n+\t\t\t\t// reclaim space after `_end`\n+\t\t\t\t_value.resize(_end);\n+\t\t\t\t_end = 0;\n+\t\t\t}\n+\t\t\tauto csz = _value.size();\n+\t\t\tauto isz = grow(csz + sz) - csz;\n+\t\t\t_value.insert(_value.begin(), isz, c);\n+\t\t\t_begin = isz - sz;\n+\t\t}\n+\t}\n+\n+\tvoid prepend(const digit& c) {\n+\t\tprepend(1, c);\n+\t}\n+\n+\tvoid prepend(const uinteger_t& num) {\n+\t\tprepend(num.size(), 0);\n+\t\tstd::copy(num.begin(), num.end(), begin());\n+\t}\n+\n+\tvoid append(std::size_t sz, const digit& c) {\n+\t\t// Efficiently append by growing by growth factor\n+\t\tif (_end) {\n+\t\t\t// reclaim space after `_end`\n+\t\t\t_value.resize(_end);\n+\t\t\t_end = 0;\n+\t\t}\n+\t\tauto nsz = _value.size() + sz;\n+\t\tgrow(nsz);\n+\t\t_value.resize(nsz, c);\n+\t}\n+\n+\tvoid append(const digit& c) {\n+\t\tappend(1, c);\n+\t}\n+\n+\tvoid append(const uinteger_t& num) {\n+\t\tauto sz = num.size();\n+\t\tappend(sz, 0);\n+\t\tstd::copy(num.begin(), num.end(), end() - sz);\n+\t}\n+\n+\tcontainer::iterator begin() noexcept {\n+\t\treturn _value.begin() + _begin;\n+\t}\n+\n+\tcontainer::const_iterator begin() const noexcept {\n+\t\treturn _value.cbegin() + _begin;\n+\t}\n+\n+\tcontainer::iterator end() noexcept {\n+\t\treturn _end ? _value.begin() + _end : _value.end();\n+\t}\n+\n+\tcontainer::const_iterator end() const noexcept {\n+\t\treturn _end ? _value.cbegin() + _end : _value.cend();\n+\t}\n+\n+\tcontainer::reverse_iterator rbegin() noexcept {\n+\t\treturn _end ? container::reverse_iterator(_value.begin() + _end) : _value.rbegin();\n+\t}\n+\n+\tcontainer::const_reverse_iterator rbegin() const noexcept {\n+\t\treturn _end ? container::const_reverse_iterator(_value.cbegin() + _end) : _value.crbegin();\n+\t}\n+\n+\tcontainer::reverse_iterator rend() noexcept {\n+\t\treturn container::reverse_iterator(_value.begin() + _begin);\n+\t}\n+\n+\tcontainer::const_reverse_iterator rend() const noexcept {\n+\t\treturn container::const_reverse_iterator(_value.cbegin() + _begin);\n+\t}\n+\n+\tcontainer::reference front() {\n+\t\treturn *begin();\n+\t}\n+\n+\tcontainer::const_reference front() const {\n+\t\treturn *begin();\n+\t}\n+\n+\tcontainer::reference back() {\n+\t\treturn *rbegin();\n+\t}\n+\n+\tcontainer::const_reference back() const {\n+\t\treturn *rbegin();\n+\t}\n+\n+private:\n+\t// Optimized primitives for operations\n+\n+\tstatic digit _bits(digit x) {\n+\t#if defined HAVE____BUILTIN_CLZLL\n+\t\tif (digit_octets == sizeof(unsigned long long)) {\n+\t\t\treturn x ? digit_bits - __builtin_clzll(x) : 1;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_CLZL\n+\t\tif (digit_octets == sizeof(unsigned long)) {\n+\t\t\treturn x ? digit_bits - __builtin_clzl(x) : 1;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_CLZ\n+\t\tif (digit_octets == sizeof(unsigned)) {\n+\t\t\treturn x ? digit_bits - __builtin_clz(x) : 1;\n+\t\t}\n+\t#endif\n+\t\t{\n+\t\t\tdigit c = x ? 0 : 1;\n+\t\t\twhile (x) {\n+\t\t\t\tx >>= 1;\n+\t\t\t\t++c;\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t}\n+\t}\n+\n+\tstatic digit _mult(digit x, digit y, digit* lo) {\n+\t#if defined HAVE___UMUL128\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul128(x, y, &h);  // _umul128(x, y, *hi) -> lo\n+\t\t\treturn h;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___UMUL64\n+\t\tif (digit_bits == 32) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul64(x, y, &h);  // _umul64(x, y, *hi) -> lo\n+\t\t\treturn h;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___UMUL32\n+\t\tif (digit_bits == 16) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul32(x, y, &h);  // _umul32(x, y, *hi) -> lo\n+\t\t\treturn h;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____INT128_T\n+\t\tif (digit_bits == 64) {\n+\t\t\tauto r = static_cast<__uint128_t>(x) * static_cast<__uint128_t>(y);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> digit_bits;\n+\t\t}\n+\t#endif\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit x0 = x & 0xffffffffUL;\n+\t\t\tdigit x1 = x >> 32;\n+\t\t\tdigit y0 = y & 0xffffffffUL;\n+\t\t\tdigit y1 = y >> 32;\n+\n+\t\t\tdigit u = (x0 * y0);\n+\t\t\tdigit v = (x1 * y0) + (u >> 32);\n+\t\t\tdigit w = (x0 * y1) + (v & 0xffffffffUL);\n+\n+\t\t\t*lo = (w << 32) + (u & 0xffffffffUL); // low\n+\t\t\treturn (x1 * y1) + (v >> 32) + (w >> 32); // high\n+\t\t} if (digit_bits == 32) {\n+\t\t\tauto r = static_cast<std::uint64_t>(x) * static_cast<std::uint64_t>(y);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 32;\n+\t\t} if (digit_bits == 16) {\n+\t\t\tauto r = static_cast<std::uint32_t>(x) * static_cast<std::uint32_t>(y);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 16;\n+\t\t} if (digit_bits == 8) {\n+\t\t\tauto r = static_cast<std::uint16_t>(x) * static_cast<std::uint16_t>(y);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 8;\n+\t\t}\n+\t}\n+\n+\tstatic digit _multadd(digit x, digit y, digit a, digit c, digit* lo) {\n+\t#if defined HAVE___UMUL128 && defined HAVE___ADDCARRY_U64\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul128(x, y, &h);  // _umul128(x, y, *hi) -> lo\n+\t\t\treturn h + _addcarry_u64(c, l, a, lo);  // _addcarry_u64(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___UMUL64 && defined HAVE___ADDCARRY_U32\n+\t\tif (digit_bits == 32) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul64(x, y, &h);  // _umul64(x, y, *hi) -> lo\n+\t\t\treturn h + _addcarry_u32(c, l, a, lo);  // _addcarry_u32(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___UMUL32 && defined HAVE___ADDCARRY_U16\n+\t\tif (digit_bits == 16) {\n+\t\t\tdigit h;\n+\t\t\tdigit l = _umul32(x, y, &h);  // _umul32(x, y, *hi) -> lo\n+\t\t\treturn h + _addcarry_u16(c, l, a, lo);  // _addcarry_u16(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____INT128_T\n+\t\tif (digit_bits == 64) {\n+\t\t\tauto r = static_cast<__uint128_t>(x) * static_cast<__uint128_t>(y) + static_cast<__uint128_t>(a) + static_cast<__uint128_t>(c);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> digit_bits;\n+\t\t}\n+\t#endif\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit x0 = x & 0xffffffffUL;\n+\t\t\tdigit x1 = x >> 32;\n+\t\t\tdigit y0 = y & 0xffffffffUL;\n+\t\t\tdigit y1 = y >> 32;\n+\n+\t\t\tdigit u = (x0 * y0) + (a & 0xffffffffUL) + (c & 0xffffffffUL);\n+\t\t\tdigit v = (x1 * y0) + (u >> 32) + (a >> 32) + (c >> 32);\n+\t\t\tdigit w = (x0 * y1) + (v & 0xffffffffUL);\n+\n+\t\t\t*lo = (w << 32) + (u & 0xffffffffUL); // low\n+\t\t\treturn (x1 * y1) + (v >> 32) + (w >> 32); // high\n+\t\t}\n+\t\tif (digit_bits == 32) {\n+\t\t\tauto r = static_cast<std::uint64_t>(x) * static_cast<std::uint64_t>(y) + static_cast<std::uint64_t>(a) + static_cast<std::uint64_t>(c);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 32;\n+\t\t}\n+\t\tif (digit_bits == 16) {\n+\t\t\tauto r = static_cast<std::uint32_t>(x) * static_cast<std::uint32_t>(y) + static_cast<std::uint32_t>(a) + static_cast<std::uint32_t>(c);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 16;\n+\t\t}\n+\t\tif (digit_bits == 8) {\n+\t\t\tauto r = static_cast<std::uint16_t>(x) * static_cast<std::uint16_t>(y) + static_cast<std::uint16_t>(a) + static_cast<std::uint16_t>(c);\n+\t\t\t*lo = r;\n+\t\t\treturn r >> 8;\n+\t\t}\n+\t}\n+\n+\tstatic digit _divmod(digit x_hi, digit x_lo, digit y, digit* result) {\n+\t#if defined HAVE____INT128_T\n+\t\tif (digit_bits == 64) {\n+\t\t\tauto x = static_cast<__uint128_t>(x_hi) << digit_bits | static_cast<__uint128_t>(x_lo);\n+\t\t\tdigit q = x / y;\n+\t\t\tdigit r = x % y;\n+\n+\t\t\t*result = q;\n+\t\t\treturn r;\n+\t\t}\n+\t#endif\n+\t\tif (digit_bits == 64) {\n+\t\t\t// quotient\n+\t\t\tdigit q = x_lo << 1;\n+\n+\t\t\t// remainder\n+\t\t\tdigit r = x_hi;\n+\n+\t\t\tdigit carry = x_lo >> 63;\n+\t\t\tint i;\n+\n+\t\t\tfor (i = 0; i < 64; i++) {\n+\t\t\t\tauto tmp = r >> 63;\n+\t\t\t\tr <<= 1;\n+\t\t\t\tr |= carry;\n+\t\t\t\tcarry = tmp;\n+\n+\t\t\t\tif (carry == 0) {\n+\t\t\t\t\tif (r >= y) {\n+\t\t\t\t\t\tcarry = 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttmp = q >> 63;\n+\t\t\t\t\t\tq <<= 1;\n+\t\t\t\t\t\tq |= carry;\n+\t\t\t\t\t\tcarry = tmp;\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tr -= y;\n+\t\t\t\tr -= (1 - carry);\n+\t\t\t\tcarry = 1;\n+\t\t\t\ttmp = q >> 63;\n+\t\t\t\tq <<= 1;\n+\t\t\t\tq |= carry;\n+\t\t\t\tcarry = tmp;\n+\t\t\t}\n+\n+\t\t\t*result = q;\n+\t\t\treturn r;\n+\t\t}\n+\t\tif (digit_bits == 32) {\n+\t\t\tauto x = static_cast<std::uint64_t>(x_hi) << 32 | static_cast<std::uint64_t>(x_lo);\n+\t\t\tdigit q = x / y;\n+\t\t\tdigit r = x % y;\n+\n+\t\t\t*result = q;\n+\t\t\treturn r;\n+\t\t}\n+\t\tif (digit_bits == 16) {\n+\t\t\tauto x = static_cast<std::uint32_t>(x_hi) << 16 | static_cast<std::uint32_t>(x_lo);\n+\t\t\tdigit q = x / y;\n+\t\t\tdigit r = x % y;\n+\n+\t\t\t*result = q;\n+\t\t\treturn r;\n+\t\t}\n+\t\tif (digit_bits == 8) {\n+\t\t\tauto x = static_cast<std::uint16_t>(x_hi) << 8 | static_cast<std::uint16_t>(x_lo);\n+\t\t\tdigit q = x / y;\n+\t\t\tdigit r = x % y;\n+\n+\t\t\t*result = q;\n+\t\t\treturn r;\n+\t\t}\n+\t}\n+\n+\tstatic digit _addcarry(digit x, digit y, digit c, digit* result) {\n+\t#if defined HAVE___ADDCARRY_U64\n+\t\tif (digit_bits == 64) {\n+\t\t\treturn _addcarry_u64(c, x, y, result);  // _addcarry_u64(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___ADDCARRY_U32\n+\t\tif (digit_bits == 32) {\n+\t\t\treturn _addcarry_u32(c, x, y, result);  // _addcarry_u32(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___ADDCARRY_U16\n+\t\tif (digit_bits == 16) {\n+\t\t\treturn _addcarry_u16(c, x, y, result);  // _addcarry_u16(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_ADDCLL\n+\t\tif (digit_octets == sizeof(unsigned long long)) {\n+\t\t\tunsigned long long carryout;\n+\t\t\t*result = __builtin_addcll(x, y, c, &carryout);  // __builtin_addcll(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_ADDCL\n+\t\tif (digit_octets == sizeof(unsigned long)) {\n+\t\t\tunsigned long carryout;\n+\t\t\t*result = __builtin_addcl(x, y, c, &carryout);  // __builtin_addcl(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_ADDC\n+\t\tif (digit_octets == sizeof(unsigned)) {\n+\t\t\tunsigned carryout;\n+\t\t\t*result = __builtin_addc(x, y, c, &carryout);  // __builtin_addc(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____INT128_T\n+\t\tif (digit_bits == 64) {\n+\t\t\tauto r = static_cast<__uint128_t>(x) + static_cast<__uint128_t>(y) + static_cast<__uint128_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> digit_bits);\n+\t\t}\n+\t#endif\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit x0 = x & 0xffffffffUL;\n+\t\t\tdigit x1 = x >> 32;\n+\t\t\tdigit y0 = y & 0xffffffffUL;\n+\t\t\tdigit y1 = y >> 32;\n+\n+\t\t\tauto u = x0 + y0 + c;\n+\t\t\tauto v = x1 + y1 + static_cast<bool>(u >> 32);\n+\t\t\t*result = (v << 32) + (u & 0xffffffffUL);\n+\t\t\treturn static_cast<bool>(v >> 32);\n+\t\t}\n+\t\tif (digit_bits == 32) {\n+\t\t\tauto r = static_cast<std::uint64_t>(x) + static_cast<std::uint64_t>(y) + static_cast<std::uint64_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 32);\n+\t\t}\n+\t\tif (digit_bits == 16) {\n+\t\t\tauto r = static_cast<std::uint32_t>(x) + static_cast<std::uint32_t>(y) + static_cast<std::uint32_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 16);\n+\t\t}\n+\t\tif (digit_bits == 8) {\n+\t\t\tauto r = static_cast<std::uint16_t>(x) + static_cast<std::uint16_t>(y) + static_cast<std::uint16_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 8);\n+\t\t}\n+\t}\n+\n+\tstatic digit _subborrow(digit x, digit y, digit c, digit* result) {\n+\t#if defined HAVE___SUBBORROW_U64\n+\t\tif (digit_bits == 64) {\n+\t\t\treturn _subborrow_u64(c, x, y, result);  // _subborrow_u64(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___SUBBORROW_U32\n+\t\tif (digit_bits == 64) {\n+\t\t\treturn _subborrow_u32(c, x, y, result);  // _subborrow_u32(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE___SUBBORROW_U16\n+\t\tif (digit_bits == 64) {\n+\t\t\treturn _subborrow_u16(c, x, y, result);  // _subborrow_u16(carryin, x, y, *sum) -> carryout\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_SUBCLL\n+\t\tif (digit_octets == sizeof(unsigned long long)) {\n+\t\t\tunsigned long long carryout;\n+\t\t\t*result = __builtin_subcll(x, y, c, &carryout);  // __builtin_subcll(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_SUBCL\n+\t\tif (digit_octets == sizeof(unsigned long)) {\n+\t\t\tunsigned long carryout;\n+\t\t\t*result = __builtin_subcl(x, y, c, &carryout);  // __builtin_subcl(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____BUILTIN_SUBC\n+\t\tif (digit_octets == sizeof(unsigned)) {\n+\t\t\tunsigned carryout;\n+\t\t\t*result = __builtin_subc(x, y, c, &carryout);  // __builtin_subc(x, y, carryin, *carryout) -> sum\n+\t\t\treturn carryout;\n+\t\t}\n+\t#endif\n+\t#if defined HAVE____INT128_T\n+\t\tif (digit_bits == 64) {\n+\t\t\tauto r = static_cast<__uint128_t>(x) - static_cast<__uint128_t>(y) - static_cast<__uint128_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 64);\n+\t\t}\n+\t#endif\n+\t\tif (digit_bits == 64) {\n+\t\t\tdigit x0 = x & 0xffffffffUL;\n+\t\t\tdigit x1 = x >> 32;\n+\t\t\tdigit y0 = y & 0xffffffffUL;\n+\t\t\tdigit y1 = y >> 32;\n+\n+\t\t\tauto u = x0 - y0 - c;\n+\t\t\tauto v = x1 - y1 - static_cast<bool>(u >> 32);\n+\t\t\t*result = (v << 32) + (u & 0xffffffffUL);\n+\t\t\treturn static_cast<bool>(v >> 32);\n+\t\t}\n+\t\tif (digit_bits == 32) {\n+\t\t\tauto r = static_cast<std::uint64_t>(x) - static_cast<std::uint64_t>(y) - static_cast<std::uint64_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 32);\n+\t\t}\n+\t\tif (digit_bits == 16) {\n+\t\t\tauto r = static_cast<std::uint32_t>(x) - static_cast<std::uint32_t>(y) - static_cast<std::uint32_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 16);\n+\t\t}\n+\t\tif (digit_bits == 8) {\n+\t\t\tauto r = static_cast<std::uint16_t>(x) - static_cast<std::uint16_t>(y) - static_cast<std::uint16_t>(c);\n+\t\t\t*result = r;\n+\t\t\treturn static_cast<bool>(r >> 8);\n+\t\t}\n+\t}\n+\n+\t// Helper functions\n+\n+\tvoid trim(digit mask = 0) {\n+\t\tauto rit = rbegin();\n+\t\tauto rit_e = rend();\n+\n+\t\t// Masks the last value of internal vector\n+\t\tmask &= (digit_bits - 1);\n+\t\tif (mask && rit != rit_e) {\n+\t\t\t*rit &= (static_cast<digit>(1) << mask) - 1;\n+\t\t}\n+\n+\t\t// Removes all unused zeros from the internal vector\n+\t\tauto rit_f = std::find_if(rit, rit_e, [](const digit& c) { return c; });\n+\t\tresize(rit_e - rit_f); // shrink\n+\t}\n+\n+\tstatic constexpr char chr(int ord) {\n+\t\tconstexpr const char _[256] = {\n+\t\t\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',\n+\t\t\t'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n+\t\t\t'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+\t\t};\n+\t\treturn _[ord];\n+\t}\n+\n+\tstatic constexpr int ord(int chr) {\n+\t\tconstexpr const int _[256] = {\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n+\n+\t\t\t-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n+\t\t\t25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n+\t\t\t-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n+\t\t\t25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n+\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+\t\t};\n+\t\treturn _[chr];\n+\t}\n+\n+public:\n+\tstatic constexpr unsigned base_bits(int base) {\n+\t\tconstexpr const unsigned _[256] = {\n+\t\t\t0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,\n+\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,\n+\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,\n+\t\t};\n+\t\treturn _[base - 1];\n+\t}\n+\n+\tstatic constexpr unsigned base_size(int base) {\n+\t\tconstexpr const unsigned _[256] = {\n+\t\t\t0, 64, 41, 32, 28, 25, 23, 22, 21, 20, 19, 18, 18, 17, 17, 16,\n+\t\t\t16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 13, 13,\n+\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12,\n+\t\t\t12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11,\n+\n+\t\t\t11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+\t\t\t11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+\t\t\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+\t\t\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+\n+\t\t\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+\t\t\t9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  8,\n+\t\t};\n+\t\treturn _[base - 1];\n+\t}\n+\n+\tstatic const uinteger_t uint_0() {\n+\t\tstatic uinteger_t uint_0(0);\n+\t\treturn uint_0;\n+\t}\n+\n+\tstatic const uinteger_t uint_1() {\n+\t\tstatic uinteger_t uint_1(1);\n+\t\treturn uint_1;\n+\t}\n+\n+private:\n+\t// Public Implementation\n+#ifdef UINT_T_PUBLIC_IMPLEMENTATION\n+public:\n+#endif\n+\tstatic uinteger_t& bitwise_and(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz > rhs_sz) {\n+\t\t\tlhs.resize(rhs_sz); // shrink\n+\t\t}\n+\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs.end();\n+\n+\t\tauto rhs_it = rhs.begin();\n+\n+\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t*lhs_it &= *rhs_it;\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_and(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tauto result_sz = std::max(lhs_sz, rhs_sz);\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tauto it = result.begin();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it & *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\t*it = 0;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it & *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t bitwise_and(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_and(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_or(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tlhs.resize(rhs_sz, 0); // grow\n+\t\t}\n+\n+\t\tauto lhs_it = lhs.begin();\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs.end();\n+\n+\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t*lhs_it |= *rhs_it;\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_or(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tauto result_sz = std::max(lhs_sz, rhs_sz);\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tauto it = result.begin();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it | *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\t*it = *rhs_it;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it | *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\tstatic uinteger_t bitwise_or(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_or(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_xor(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tlhs.resize(rhs_sz, 0); // grow\n+\t\t}\n+\n+\t\tauto lhs_it = lhs.begin();\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs.end();\n+\n+\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t*lhs_it ^= *rhs_it;\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_xor(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tauto result_sz = std::max(lhs_sz, rhs_sz);\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tauto it = result.begin();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it ^ *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\t*it = *rhs_it;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it ^ *rhs_it;\n+\t\t\t}\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t bitwise_xor(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_xor(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_inv(uinteger_t& lhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\n+\t\tauto b = lhs.bits();\n+\n+\t\tif (!lhs_sz) {\n+\t\t\tlhs.append(0);\n+\t\t}\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` if `result` is also `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tfor (; lhs_it != lhs_it_e; ++lhs_it) {\n+\t\t\t*lhs_it = ~*lhs_it;\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tlhs.trim(b ? b : 1);\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_inv(uinteger_t& result, const uinteger_t& lhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\n+\t\tauto b = lhs.bits();\n+\n+\t\tauto result_sz = lhs_sz ? lhs_sz : 1;\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` if `result` is also `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto it = result.begin();\n+\t\tauto it_e = it + result_sz;\n+\n+\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t*it = ~*lhs_it;\n+\t\t}\n+\t\tfor (; it != it_e; ++it) {\n+\t\t\t*it = ~static_cast<digit>(0);\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim(b ? b : 1);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t bitwise_inv(const uinteger_t& lhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_inv(result, lhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_lshift(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tif (!rhs) {\n+\t\t\treturn lhs;\n+\t\t}\n+\n+\t\tuinteger_t shifts_q;\n+\t\tuinteger_t shifts_r;\n+\t\tauto _digit_bits = digit_bits;\n+\t\tauto uint_digit_bits = uinteger_t(_digit_bits);\n+\t\tdivmod(shifts_q, shifts_r, rhs, uint_digit_bits);\n+\t\tstd::size_t shifts = static_cast<std::size_t>(shifts_q);\n+\t\tstd::size_t shift = static_cast<std::size_t>(shifts_r);\n+\n+\t\tif (shifts) {\n+\t\t\tlhs.prepend(shifts, 0);\n+\t\t}\n+\t\tif (shift) {\n+\t\t\tdigit shifted = 0;\n+\t\t\tauto lhs_it = lhs.begin() + shifts;\n+\t\t\tauto lhs_it_e = lhs.end();\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it) {\n+\t\t\t\tauto v = (*lhs_it << shift) | shifted;\n+\t\t\t\tshifted = *lhs_it >> (_digit_bits - shift);\n+\t\t\t\t*lhs_it = v;\n+\t\t\t}\n+\t\t\tif (shifted) {\n+\t\t\t\tlhs.append(shifted);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_lshift(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tif (&result._value == &lhs._value) {\n+\t\t\tbitwise_lshift(result, rhs);\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (!rhs) {\n+\t\t\tresult = lhs;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tauto lhs_sz = lhs.size();\n+\n+\t\tuinteger_t shifts_q;\n+\t\tuinteger_t shifts_r;\n+\t\tauto _digit_bits = digit_bits;\n+\t\tauto uint_digit_bits = uinteger_t(_digit_bits);\n+\t\tdivmod(shifts_q, shifts_r, rhs, uint_digit_bits);\n+\t\tstd::size_t shifts = static_cast<std::size_t>(shifts_q);\n+\t\tstd::size_t shift = static_cast<std::size_t>(shifts_r);\n+\n+\t\tauto result_sz = lhs_sz + shifts;\n+\t\tresult.grow(result_sz + 1);\n+\t\tresult.resize(shifts, 0);\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` if `result` is also `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto it = result.begin() + shifts;\n+\n+\t\tif (shift) {\n+\t\t\tdigit shifted = 0;\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\tauto v = (*lhs_it << shift) | shifted;\n+\t\t\t\tshifted = *lhs_it >> (_digit_bits - shift);\n+\t\t\t\t*it = v;\n+\t\t\t}\n+\t\t\tif (shifted) {\n+\t\t\t\tresult.append(shifted);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t bitwise_lshift(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_lshift(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_rshift(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tif (!rhs) {\n+\t\t\treturn lhs;\n+\t\t}\n+\n+\t\tauto lhs_sz = lhs.size();\n+\n+\t\tauto _digit_bits = digit_bits;\n+\t\tif (compare(rhs, uinteger_t(lhs_sz * _digit_bits)) >= 0) {\n+\t\t\tlhs = uint_0();\n+\t\t\treturn lhs;\n+\t\t}\n+\n+\t\tuinteger_t shifts_q;\n+\t\tuinteger_t shifts_r;\n+\t\tauto uint_digit_bits = uinteger_t(_digit_bits);\n+\t\tdivmod(shifts_q, shifts_r, rhs, uint_digit_bits);\n+\t\tstd::size_t shifts = static_cast<std::size_t>(shifts_q);\n+\t\tstd::size_t shift = static_cast<std::size_t>(shifts_r);\n+\n+\t\tif (shifts) {\n+\t\t\tlhs._begin += shifts;\n+\t\t}\n+\t\tif (shift) {\n+\t\t\tdigit shifted = 0;\n+\t\t\tauto lhs_rit = lhs.rbegin();\n+\t\t\tauto lhs_rit_e = lhs.rend();\n+\t\t\tfor (; lhs_rit != lhs_rit_e; ++lhs_rit) {\n+\t\t\t\tauto v = (*lhs_rit >> shift) | shifted;\n+\t\t\t\tshifted = *lhs_rit << (_digit_bits - shift);\n+\t\t\t\t*lhs_rit = v;\n+\t\t\t}\n+\t\t\tlhs.trim();\n+\t\t}\n+\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& bitwise_rshift(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tif (&result._value == &lhs._value) {\n+\t\t\tbitwise_lshift(result, rhs);\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (!rhs) {\n+\t\t\tresult = lhs;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tauto lhs_sz = lhs.size();\n+\n+\t\tauto _digit_bits = digit_bits;\n+\t\tif (compare(rhs, uinteger_t(lhs_sz * _digit_bits)) >= 0) {\n+\t\t\tresult = uint_0();\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tuinteger_t shifts_q;\n+\t\tuinteger_t shifts_r;\n+\t\tauto uint_digit_bits = uinteger_t(_digit_bits);\n+\t\tdivmod(shifts_q, shifts_r, rhs, uint_digit_bits);\n+\t\tstd::size_t shifts = static_cast<std::size_t>(shifts_q);\n+\t\tstd::size_t shift = static_cast<std::size_t>(shifts_r);\n+\n+\t\tauto result_sz = lhs_sz - shifts;\n+\t\tresult.resize(result_sz);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` if `result` is also `lhs`.\n+\t\tauto lhs_rit = lhs.rbegin();\n+\t\tauto lhs_rit_e = lhs_rit + lhs_sz - shifts;\n+\n+\t\tauto rit = result.rbegin();\n+\t\tauto rit_e = rit + result_sz;\n+\n+\t\tif (shift) {\n+\t\t\tdigit shifted = 0;\n+\t\t\tfor (; lhs_rit != lhs_rit_e; ++lhs_rit, ++rit) {\n+\t\t\t\tASSERT(rit != rit_e); (void)(rit_e);\n+\t\t\t\tauto v = (*lhs_rit >> shift) | shifted;\n+\t\t\t\tshifted = *lhs_rit << (_digit_bits - shift);\n+\t\t\t\t*rit = v;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; lhs_rit != lhs_rit_e; ++lhs_rit, ++rit) {\n+\t\t\t\tASSERT(rit != rit_e); (void)(rit_e);\n+\t\t\t\t*rit = *lhs_rit;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t bitwise_rshift(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tbitwise_rshift(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic int compare(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz > rhs_sz) return 1;\n+\t\tif (lhs_sz < rhs_sz) return -1;\n+\n+\t\tauto lhs_rit = lhs.rbegin();\n+\t\tauto lhs_rit_e = lhs.rend();\n+\n+\t\tauto rhs_rit = rhs.rbegin();\n+\n+\t\tfor (; lhs_rit != lhs_rit_e && *lhs_rit == *rhs_rit; ++lhs_rit, ++rhs_rit);\n+\n+\t\tif (lhs_rit != lhs_rit_e) {\n+\t\t\tif (*lhs_rit > *rhs_rit) return 1;\n+\t\t\tif (*lhs_rit < *rhs_rit) return -1;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tstatic uinteger_t& long_add(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tlhs.reserve(rhs_sz + 1);\n+\t\t\tlhs.resize(rhs_sz, 0); // grow\n+\t\t}\n+\n+\t\t// not using `end()` because resize of `lhs.resize()` could have\n+\t\t// resized `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tdigit carry = 0;\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++rhs_it, ++lhs_it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, *rhs_it, carry, &*lhs_it);\n+\t\t\t}\n+\t\t\tfor (; carry && rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {\n+\t\t\t\tcarry = _addcarry(0, *rhs_it, carry, &*lhs_it);\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {\n+\t\t\t\t*lhs_it = *rhs_it;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, *rhs_it, carry, &*lhs_it);\n+\t\t\t}\n+\t\t\tfor (; carry && lhs_it != lhs_it_e; ++lhs_it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, 0, carry, &*lhs_it);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (carry) {\n+\t\t\tlhs.append(1);\n+\t\t}\n+\n+\t\tlhs._carry = false;\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& long_add(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tauto result_sz = std::max(lhs_sz, rhs_sz);\n+\t\tresult.reserve(result_sz + 1);\n+\t\tresult.resize(result_sz, 0);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tauto it = result.begin();\n+\n+\t\tdigit carry = 0;\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, *rhs_it, carry, &*it);\n+\t\t\t}\n+\t\t\tfor (; carry && rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\tcarry = _addcarry(0, *rhs_it, carry, &*it);\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\t*it = *rhs_it;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, *rhs_it, carry, &*it);\n+\t\t\t}\n+\t\t\tfor (; carry && lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\tcarry = _addcarry(*lhs_it, 0, carry, &*it);\n+\t\t\t}\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (carry) {\n+\t\t\tresult.append(1);\n+\t\t}\n+\t\tresult._carry = false;\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& add(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!rhs) {\n+\t\t\treturn lhs;\n+\t\t}\n+\t\tif (!lhs) {\n+\t\t\tlhs = rhs;\n+\t\t\treturn lhs;\n+\t\t}\n+\n+\t\treturn long_add(lhs, rhs);\n+\t}\n+\n+\tstatic uinteger_t& add(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!rhs) {\n+\t\t\tresult = lhs;\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (!lhs) {\n+\t\t\tresult = rhs;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\treturn long_add(result, lhs, rhs);\n+\t}\n+\n+\tstatic uinteger_t add(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tadd(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& long_sub(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tlhs.resize(rhs_sz, 0); // grow\n+\t\t}\n+\n+\t\t// not using `end()` because resize of `lhs.resize()` could have\n+\t\t// resized `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tdigit borrow = 0;\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, *rhs_it, borrow, &*lhs_it);\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t\tborrow = _subborrow(0, *rhs_it, borrow, &*lhs_it);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, *rhs_it, borrow, &*lhs_it);\n+\t\t\t}\n+\t\t\tfor (; borrow && lhs_it != lhs_it_e; ++lhs_it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, 0, borrow, &*lhs_it);\n+\t\t\t}\n+\t\t}\n+\n+\t\tlhs._carry = borrow;\n+\n+\t\t// Finish up\n+\t\tlhs.trim();\n+\t\treturn lhs;\n+\t}\n+\n+\tstatic uinteger_t& long_sub(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tauto result_sz = std::max(lhs_sz, rhs_sz);\n+\t\tresult.resize(result_sz, 0);\n+\n+\t\t// not using `end()` because resize of `result.resize()` could have\n+\t\t// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.\n+\t\tauto lhs_it = lhs.begin();\n+\t\tauto lhs_it_e = lhs_it + lhs_sz;\n+\n+\t\tauto rhs_it = rhs.begin();\n+\t\tauto rhs_it_e = rhs_it + rhs_sz;\n+\n+\t\tauto it = result.begin();\n+\n+\t\tdigit borrow = 0;\n+\t\tif (lhs_sz < rhs_sz) {\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, *rhs_it, borrow, &*it);\n+\t\t\t}\n+\t\t\tfor (; rhs_it != rhs_it_e; ++rhs_it, ++it) {\n+\t\t\t\tborrow = _subborrow(0, *rhs_it, borrow, &*it);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, *rhs_it, borrow, &*it);\n+\t\t\t}\n+\t\t\tfor (; borrow && lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\tborrow = _subborrow(*lhs_it, 0, borrow, &*it);\n+\t\t\t}\n+\t\t\tfor (; lhs_it != lhs_it_e; ++lhs_it, ++it) {\n+\t\t\t\t*it = *lhs_it;\n+\t\t\t}\n+\t\t}\n+\n+\t\tresult._carry = borrow;\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& sub(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!rhs) {\n+\t\t\treturn lhs;\n+\t\t}\n+\n+\t\treturn long_sub(lhs, rhs);\n+\t}\n+\n+\tstatic uinteger_t& sub(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!rhs) {\n+\t\t\tresult = lhs;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\treturn long_sub(result, lhs, rhs);\n+\t}\n+\n+\tstatic uinteger_t sub(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tsub(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\t// Single word long multiplication\n+\t// Fastests, but ONLY for single sized rhs\n+\tstatic uinteger_t& single_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tASSERT(rhs_sz == 1); (void)(rhs_sz);\n+\t\tauto n = rhs.front();\n+\n+\t\tuinteger_t tmp;\n+\t\ttmp.resize(lhs_sz + 1, 0);\n+\n+\t\tauto it_lhs = lhs.begin();\n+\t\tauto it_lhs_e = lhs.end();\n+\n+\t\tauto it_result = tmp.begin();\n+\n+\t\tdigit carry = 0;\n+\t\tfor (; it_lhs != it_lhs_e; ++it_lhs, ++it_result) {\n+\t\t\tcarry = _multadd(*it_lhs, n, 0, carry, &*it_result);\n+\t\t}\n+\t\tif (carry) {\n+\t\t\t*it_result = carry;\n+\t\t}\n+\n+\t\tresult = std::move(tmp);\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& long_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz > rhs_sz) {\n+\t\t\t// rhs should be the largest:\n+\t\t\treturn long_mult(result, rhs, lhs);\n+\t\t}\n+\n+\t\tif (lhs_sz == 1) {\n+\t\t\treturn single_mult(result, rhs, lhs);\n+\t\t}\n+\n+\t\tuinteger_t tmp;\n+\t\ttmp.resize(lhs_sz + rhs_sz, 0);\n+\n+\t\tauto it_lhs = lhs.begin();\n+\t\tauto it_lhs_e = lhs.end();\n+\n+\t\tauto it_rhs = rhs.begin();\n+\t\tauto it_rhs_e = rhs.end();\n+\n+\t\tauto it_result = tmp.begin();\n+\t\tauto it_result_s = it_result;\n+\t\tauto it_result_l = it_result;\n+\n+\t\tfor (; it_lhs != it_lhs_e; ++it_lhs, ++it_result) {\n+\t\t\tif (auto lhs_it_val = *it_lhs) {\n+\t\t\t\tauto _it_rhs = it_rhs;\n+\t\t\t\tauto _it_result = it_result;\n+\t\t\t\tdigit carry = 0;\n+\t\t\t\tfor (; _it_rhs != it_rhs_e; ++_it_rhs, ++_it_result) {\n+\t\t\t\t\tcarry = _multadd(*_it_rhs, lhs_it_val, *_it_result, carry, &*_it_result);\n+\t\t\t\t}\n+\t\t\t\tif (carry) {\n+\t\t\t\t\t*_it_result++ = carry;\n+\t\t\t\t}\n+\t\t\t\tif (it_result_l < _it_result) {\n+\t\t\t\t\tit_result_l = _it_result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\ttmp.resize(it_result_l - it_result_s); // shrink\n+\n+\t\tresult = std::move(tmp);\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\t// A helper for Karatsuba multiplication to split a number in two, at n.\n+\tstatic std::pair<const uinteger_t, const uinteger_t> karatsuba_mult_split(const uinteger_t& num, std::size_t n) {\n+\t\tconst uinteger_t a(num, num._begin, num._begin + n);\n+\t\tconst uinteger_t b(num, num._begin + n, num._end);\n+\t\treturn std::make_pair(std::move(a), std::move(b));\n+\t}\n+\n+\t// If rhs has at least twice the digits of lhs, and lhs is big enough that\n+\t// Karatsuba would pay off *if* the inputs had balanced sizes.\n+\t// View rhs as a sequence of slices, each with lhs.size() digits,\n+\t// and multiply the slices by lhs, one at a time.\n+\tstatic uinteger_t& karatsuba_lopsided_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs, std::size_t cutoff) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tASSERT(lhs_sz > cutoff);\n+\t\tASSERT(2 * lhs_sz <= rhs_sz);\n+\n+\t\tauto rhs_begin = rhs._begin;\n+\t\tstd::size_t shift = 0;\n+\n+\t\tuinteger_t r;\n+\t\twhile (rhs_sz > 0) {\n+\t\t\t// Multiply the next slice of rhs by lhs and add into result:\n+\t\t\tauto slice_size = std::min(lhs_sz, rhs_sz);\n+\t\t\tconst uinteger_t rhs_slice(rhs, rhs_begin, rhs_begin + slice_size);\n+\t\t\tuinteger_t p;\n+\t\t\tkaratsuba_mult(p, lhs, rhs_slice, cutoff);\n+\t\t\tuinteger_t rs(r, shift, 0);\n+\t\t\tadd(rs, rs, p);\n+\t\t\tshift += slice_size;\n+\t\t\trhs_sz -= slice_size;\n+\t\t\trhs_begin += slice_size;\n+\t\t}\n+\n+\t\tresult = std::move(r);\n+\t\treturn result;\n+\t}\n+\n+\t// Karatsuba multiplication\n+\tstatic uinteger_t& karatsuba_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs, std::size_t cutoff = 1) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tif (lhs_sz > rhs_sz) {\n+\t\t\t// rhs should be the largest:\n+\t\t\treturn karatsuba_mult(result, rhs, lhs, cutoff);\n+\t\t}\n+\n+\t\tif (lhs_sz <= cutoff) {\n+\t\t\treturn long_mult(result, lhs, rhs);\n+\t\t}\n+\n+\t\t// If a is too small compared to b, splitting on b gives a degenerate case\n+\t\t// in which Karatsuba may be (even much) less efficient than long multiplication.\n+\t\tif (2 * lhs_sz <= rhs_sz) {\n+\t\t\treturn karatsuba_lopsided_mult(result, lhs, rhs, cutoff);\n+\t\t}\n+\n+\t\t// Karatsuba:\n+\t\t//\n+\t\t//                  A      B\n+\t\t//               x  C      D\n+\t\t//     ---------------------\n+\t\t//                 AD     BD\n+\t\t//       AC        BC\n+\t\t//     ---------------------\n+\t\t//       AC    AD + BC    BD\n+\t\t//\n+\t\t//  AD + BC  =\n+\t\t//  AC + AD + BC + BD - AC - BD\n+\t\t//  (A + B) (C + D) - AC - BD\n+\n+\t\t// Calculate the split point near the middle of the largest (rhs).\n+\t\tauto shift = rhs_sz >> 1;\n+\n+\t\t// Split to get A and B:\n+\t\tconst auto lhs_pair = karatsuba_mult_split(lhs, shift);\n+\t\tconst auto& A = lhs_pair.second; // hi\n+\t\tconst auto& B = lhs_pair.first;  // lo\n+\n+\t\t// Split to get C and D:\n+\t\tconst auto rhs_pair = karatsuba_mult_split(rhs, shift);\n+\t\tconst auto& C = rhs_pair.second; // hi\n+\t\tconst auto& D = rhs_pair.first;  // lo\n+\n+\t\t// Get the pieces:\n+\t\tuinteger_t AC;\n+\t\tkaratsuba_mult(AC, A, C, cutoff);\n+\n+\t\tuinteger_t BD;\n+\t\tkaratsuba_mult(BD, B, D, cutoff);\n+\t\tuinteger_t AD_BC, AB, CD;\n+\t\tkaratsuba_mult(AD_BC, A + B, C + D, cutoff);\n+\t\tAD_BC -= AC;\n+\t\tAD_BC -= BD;\n+\n+\t\t// Join the pieces, AC and BD (can't overlap) into BD:\n+\t\tBD.reserve(shift * 2 + AC.size());\n+\t\tBD.resize(shift * 2, 0);\n+\t\tBD.append(AC);\n+\n+\t\t// And add AD_BC to the middle: (AC           BD) + (    AD + BC    ):\n+\t\tuinteger_t BDs(BD, shift, 0);\n+\t\tadd(BDs, BDs, AD_BC);\n+\n+\t\tresult = std::move(BD);\n+\n+\t\t// Finish up\n+\t\tresult.trim();\n+\t\treturn result;\n+\t}\n+\n+\tstatic uinteger_t& mult(uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// Hard to see how this could have a further optimized implementation.\n+\t\treturn mult(lhs, lhs, rhs);\n+\t}\n+\n+\tstatic uinteger_t& mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!lhs || !rhs) {\n+\t\t\tresult = uint_0();\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (compare(lhs, uint_1()) == 0) {\n+\t\t\tresult = rhs;\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (compare(rhs, uint_1()) == 0) {\n+\t\t\tresult = lhs;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\treturn karatsuba_mult(result, lhs, rhs, karatsuba_cutoff);\n+\t}\n+\n+\tstatic uinteger_t mult(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t result;\n+\t\tmult(result, lhs, rhs);\n+\t\treturn result;\n+\t}\n+\n+\t// Single word long division\n+\t// Fastests, but ONLY for single sized rhs\n+\tstatic std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> single_divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\n+\t\tASSERT(rhs_sz == 1); (void)(rhs_sz);\n+\t\tauto n = rhs.front();\n+\n+\t\tauto rit_lhs = lhs.rbegin();\n+\t\tauto rit_lhs_e = lhs.rend();\n+\n+\t\tauto q = uint_0();\n+\t\tq.resize(lhs_sz, 0);\n+\t\tauto rit_q = q.rbegin();\n+\n+\t\tdigit r = 0;\n+\t\tfor (; rit_lhs != rit_lhs_e; ++rit_lhs, ++rit_q) {\n+\t\t\tr = _divmod(r, *rit_lhs, n, &*rit_q);\n+\t\t}\n+\n+\t\tq.trim();\n+\n+\t\tquotient = std::move(q);\n+\t\tremainder = r;\n+\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t}\n+\n+\t// Implementation of Knuth's Algorithm D\n+\tstatic std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> knuth_divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t v(lhs);\n+\t\tuinteger_t w(rhs);\n+\n+\t\tauto v_size = v.size();\n+\t\tauto w_size = w.size();\n+\t\tASSERT(v_size >= w_size && w_size >= 2);\n+\n+\t\t// D1. normalize: shift rhs left so that its top digit is >= 63 bits.\n+\t\t// shift lhs left by the same amount. Results go into w and v.\n+\t\tauto d = uinteger_t(digit_bits - _bits(w.back()));\n+\t\tv <<= d;\n+\t\tw <<= d;\n+\n+\t\tif (*v.rbegin() >= *w.rbegin()) {\n+\t\t\tv.append(0);\n+\t\t}\n+\t\tv_size = v.size();\n+\t\tv.append(0);\n+\n+\t\t// Now *v.rbegin() < *w.rbegin() so quotient has at most\n+\t\t// (and usually exactly) k = v.size() - w.size() digits.\n+\t\tauto k = v_size - w_size;\n+\t\tauto q = uint_0();\n+\t\tq.resize(k + 1, 0);\n+\n+\t\tauto rit_q = q.rend() - (k + 1);\n+\n+\t\tauto it_v_b = v.begin();\n+\t\tauto it_v_k = it_v_b + k;\n+\n+\t\tauto it_w = w.begin();\n+\t\tauto it_w_e = w.end();\n+\n+\t\tauto rit_w = w.rbegin();\n+\t\tauto wm1 = *rit_w++;\n+\t\tauto wm2 = *rit_w;\n+\n+\t\t// D2. inner loop: divide v[k+0..k+n] by w[0..n]\n+\t\tfor (; it_v_k >= it_v_b; --it_v_k, ++rit_q) {\n+\t\t\t// D3. Compute estimate quotient digit q; may overestimate by 1 (rare)\n+\t\t\tdigit _q;\n+\t\t\tauto _r = _divmod(*(it_v_k + w_size), *(it_v_k + w_size - 1), wm1, &_q);\n+\t\t\tdigit mullo = 0;\n+\t\t\tauto mulhi = _mult(_q, wm2, &mullo);\n+\t\t\tauto rlo = *(it_v_k + w_size - 2);\n+\t\t\twhile (mulhi > _r || (mulhi == _r && mullo > rlo)) {\n+\t\t\t\t--_q;\n+\t\t\t\tif (_addcarry(_r, wm1, 0, &_r)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tmulhi = _mult(_q, wm2, &mullo);\n+\t\t\t}\n+\n+\t\t\t// D4. Multiply and subtract _q * w0[0:size_w] from vk[0:size_w+1]\n+\t\t\tauto _it_v = it_v_k;\n+\t\t\tauto _it_w = it_w;\n+\t\t\tmulhi = 0;\n+\t\t\tdigit carry = 0;\n+\t\t\tfor (; _it_w != it_w_e; ++_it_v, ++_it_w) {\n+\t\t\t\tmullo = 0;\n+\t\t\t\tmulhi = _multadd(*_it_w, _q, 0, mulhi, &mullo);\n+\t\t\t\tcarry = _subborrow(*_it_v, mullo, carry, &*_it_v);\n+\t\t\t}\n+\t\t\tcarry = _subborrow(*_it_v, 0, carry, &*_it_v);\n+\n+\t\t\tif (carry) {\n+\t\t\t\t// D6. Add w back if q was too large (this branch taken rarely)\n+\t\t\t\t--_q;\n+\n+\t\t\t\t_it_v = it_v_k;\n+\t\t\t\t_it_w = it_w;\n+\t\t\t\tcarry = 0;\n+\t\t\t\tfor (; _it_w != it_w_e; ++_it_v, ++_it_w) {\n+\t\t\t\t\tcarry = _addcarry(*_it_v, *_it_w, carry, &*_it_v);\n+\t\t\t\t}\n+\t\t\t\tcarry = _addcarry(*_it_v, 0, carry, &*_it_v);\n+\t\t\t}\n+\n+\t\t\t/* store quotient digit */\n+\t\t\t*rit_q = _q;\n+\t\t}\n+\n+\t\t// D8. unnormalize: unshift remainder.\n+\t\tv.resize(w_size);\n+\t\tv >>= d;\n+\n+\t\tq.trim();\n+\t\tv.trim();\n+\n+\t\tquotient = std::move(q);\n+\t\tremainder = std::move(v);\n+\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t}\n+\n+\tstatic std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\t// First try saving some calculations:\n+\t\tif (!rhs) {\n+\t\t\tthrow std::domain_error(\"Error: division or modulus by 0\");\n+\t\t}\n+\t\tauto lhs_sz = lhs.size();\n+\t\tauto rhs_sz = rhs.size();\n+\t\tif (lhs_sz == 1 && rhs_sz == 1) {\n+\t\t\t// Fast division and modulo for single value\n+\t\t\tauto a = *lhs.begin();\n+\t\t\tauto b = *rhs.begin();\n+\t\t\tquotient = a / b;\n+\t\t\tremainder = a % b;\n+\t\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t\t}\n+\t\tif (compare(rhs, uint_1()) == 0) {\n+\t\t\tquotient = lhs;\n+\t\t\tremainder = uint_0();\n+\t\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t\t}\n+\t\tauto compared = compare(lhs, rhs);\n+\t\tif (compared == 0) {\n+\t\t\tquotient = uint_1();\n+\t\t\tremainder = uint_0();\n+\t\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t\t}\n+\t\tif (!lhs || compared < 0) {\n+\t\t\tquotient = uint_0();\n+\t\t\tremainder = lhs;\n+\t\t\treturn std::make_pair(std::ref(quotient), std::ref(remainder));\n+\t\t}\n+\t\tif (rhs_sz == 1) {\n+\t\t\treturn single_divmod(quotient, remainder, lhs, rhs);\n+\t\t}\n+\n+\t\treturn knuth_divmod(quotient, remainder, lhs, rhs);\n+\t}\n+\n+\tstatic std::pair<uinteger_t, uinteger_t> divmod(const uinteger_t& lhs, const uinteger_t& rhs) {\n+\t\tuinteger_t quotient;\n+\t\tuinteger_t remainder;\n+\t\tdivmod(quotient, remainder, lhs, rhs);\n+\t\treturn std::make_pair(std::move(quotient), std::move(remainder));\n+\t}\n+\n+private:\n+\t// Constructors\n+\n+\ttemplate <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+\tvoid _uint_t(const T& value) {\n+\t\tappend(static_cast<digit>(value));\n+\t}\n+\n+\ttemplate <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+\tvoid _uint_t(const T& value, Args... args) {\n+\t\t_uint_t(args...);\n+\t\tappend(static_cast<digit>(value));\n+\t}\n+\n+\t// This constructor creates a window view of the _value\n+\tuinteger_t(const uinteger_t& o, std::size_t begin, std::size_t end) :\n+\t\t_begin(begin),\n+\t\t_end(end),\n+\t\t_value(o._value),\n+\t\t_carry(o._carry) { }\n+\n+public:\n+\tuinteger_t() :\n+\t\t_begin(0),\n+\t\t_end(0),\n+\t\t_value(_value_instance),\n+\t\t_carry(false) { }\n+\n+\tuinteger_t(const uinteger_t& o) :\n+\t\t_begin(0),\n+\t\t_end(0),\n+\t\t_value_instance(o.begin(), o.end()),\n+\t\t_value(_value_instance),\n+\t\t_carry(o._carry) { }\n+\n+\tuinteger_t(uinteger_t&& o) :\n+\t\t_begin(std::move(o._begin)),\n+\t\t_end(std::move(o._end)),\n+\t\t_value_instance(std::move(o._value_instance)),\n+\t\t_value(_value_instance),\n+\t\t_carry(std::move(o._carry)) { }\n+\n+\ttemplate <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+\tuinteger_t(const T& value) :\n+\t\t_begin(0),\n+\t\t_end(0),\n+\t\t_value(_value_instance),\n+\t\t_carry(false) {\n+\t\tif (value) {\n+\t\t\tappend(static_cast<digit>(value));\n+\t\t}\n+\t}\n+\n+\ttemplate <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+\tuinteger_t(const T& value, Args... args) :\n+\t\t_begin(0),\n+\t\t_end(0),\n+\t\t_value(_value_instance),\n+\t\t_carry(false) {\n+\t\t_uint_t(args...);\n+\t\tappend(static_cast<digit>(value));\n+\t\ttrim();\n+\t}\n+\n+\ttemplate <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+\tuinteger_t(std::initializer_list<T> list) :\n+\t\t_begin(0),\n+\t\t_end(0),\n+\t\t_value(_value_instance),\n+\t\t_carry(false) {\n+\t\treserve(list.size());\n+\t\tfor (const auto& value : list) {\n+\t\t\tappend(static_cast<digit>(value));\n+\t\t}\n+\t\ttrim();\n+\t}\n+\n+\ttemplate <typename T, std::size_t N>\n+\texplicit uinteger_t(T (&s)[N], int base=10) :\n+\t\tuinteger_t(s, N - 1, base) { }\n+\n+\texplicit uinteger_t(const unsigned char* bytes, std::size_t sz, int base) :\n+\t\tuinteger_t(strtouint(bytes, sz, base)) { }\n+\n+\texplicit uinteger_t(const char* bytes, std::size_t sz, int base) :\n+\t\tuinteger_t(strtouint(bytes, sz, base)) { }\n+\n+\ttemplate <typename T>\n+\texplicit uinteger_t(const std::vector<T>& bytes, int base=10) :\n+\t\tuinteger_t(bytes.data(), bytes.size(), base) { }\n+\n+\texplicit uinteger_t(const std::string& bytes, int base=10) :\n+\t\tuinteger_t(bytes.data(), bytes.size(), base) { }\n+\n+\t// Assignment Operator\n+\tuinteger_t& operator=(const uinteger_t& o) {\n+\t\t_begin = 0;\n+\t\t_end = 0;\n+\t\t_value = container(o.begin(), o.end());\n+\t\t_carry = o._carry;\n+\t\treturn *this;\n+\t}\n+\tuinteger_t& operator=(uinteger_t&& o) {\n+\t\t_begin = std::move(o._begin);\n+\t\t_end = std::move(o._end);\n+\t\t_value_instance = std::move(o._value_instance);\n+\t\t_carry = std::move(o._carry);\n+\t\treturn *this;\n+\t}\n+\n+\t// Typecast Operators\n+\texplicit operator bool() const {\n+\t\treturn static_cast<bool>(size());\n+\t}\n+\texplicit operator unsigned char() const {\n+\t\treturn static_cast<unsigned char>(size() ? front() : 0);\n+\t}\n+\texplicit operator unsigned short() const {\n+\t\treturn static_cast<unsigned short>(size() ? front() : 0);\n+\t}\n+\texplicit operator unsigned int() const {\n+\t\treturn static_cast<unsigned int>(size() ? front() : 0);\n+\t}\n+\texplicit operator unsigned long() const {\n+\t\treturn static_cast<unsigned long>(size() ? front() : 0);\n+\t}\n+\texplicit operator unsigned long long() const {\n+\t\treturn static_cast<unsigned long long>(size() ? front() : 0);\n+\t}\n+\texplicit operator char() const {\n+\t\treturn static_cast<char>(size() ? front() : 0);\n+\t}\n+\texplicit operator short() const {\n+\t\treturn static_cast<short>(size() ? front() : 0);\n+\t}\n+\texplicit operator int() const {\n+\t\treturn static_cast<int>(size() ? front() : 0);\n+\t}\n+\texplicit operator long() const {\n+\t\treturn static_cast<long>(size() ? front() : 0);\n+\t}\n+\texplicit operator long long() const {\n+\t\treturn static_cast<long long>(size() ? front() : 0);\n+\t}\n+\n+\t// Bitwise Operators\n+\tuinteger_t operator&(const uinteger_t& rhs) const {\n+\t\treturn bitwise_and(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator&=(const uinteger_t& rhs) {\n+\t\treturn bitwise_and(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator|(const uinteger_t& rhs) const {\n+\t\treturn bitwise_or(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator|=(const uinteger_t& rhs) {\n+\t\treturn bitwise_or(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator^(const uinteger_t& rhs) const {\n+\t\treturn bitwise_xor(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator^=(const uinteger_t& rhs) {\n+\t\treturn bitwise_xor(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator~() const {\n+\t\treturn bitwise_inv(*this);\n+\t}\n+\n+\tuinteger_t inv() {\n+\t\treturn bitwise_inv(*this);\n+\t}\n+\n+\t// Bit Shift Operators\n+\tuinteger_t operator<<(const uinteger_t& rhs) const {\n+\t\treturn bitwise_lshift(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator<<=(const uinteger_t& rhs) {\n+\t\treturn bitwise_lshift(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator>>(const uinteger_t& rhs) const {\n+\t\treturn bitwise_rshift(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator>>=(const uinteger_t& rhs) {\n+\t\treturn bitwise_rshift(*this, rhs);\n+\t}\n+\n+\t// Logical Operators\n+\tbool operator!() const {\n+\t\treturn !static_cast<bool>(*this);\n+\t}\n+\n+\tbool operator&&(const uinteger_t& rhs) const {\n+\t\treturn static_cast<bool>(*this) && rhs;\n+\t}\n+\n+\tbool operator||(const uinteger_t& rhs) const {\n+\t\treturn static_cast<bool>(*this) || rhs;\n+\t}\n+\n+\t// Comparison Operators\n+\tbool operator==(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) == 0;\n+\t}\n+\n+\tbool operator!=(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) != 0;\n+\t}\n+\n+\tbool operator>(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) > 0;\n+\t}\n+\n+\tbool operator<(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) < 0;\n+\t}\n+\n+\tbool operator>=(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) >= 0;\n+\t}\n+\n+\tbool operator<=(const uinteger_t& rhs) const {\n+\t\treturn compare(*this, rhs) <= 0;\n+\t}\n+\n+\t// Arithmetic Operators\n+\tuinteger_t operator+(const uinteger_t& rhs) const {\n+\t\treturn add(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator+=(const uinteger_t& rhs) {\n+\t\treturn add(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator-(const uinteger_t& rhs) const {\n+\t\treturn sub(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator-=(const uinteger_t& rhs) {\n+\t\treturn sub(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator*(const uinteger_t& rhs) const {\n+\t\treturn mult(*this, rhs);\n+\t}\n+\n+\tuinteger_t& operator*=(const uinteger_t& rhs) {\n+\t\treturn mult(*this, rhs);\n+\t}\n+\n+\tstd::pair<uinteger_t, uinteger_t> divmod(const uinteger_t& rhs) const {\n+\t\treturn divmod(*this, rhs);\n+\t}\n+\n+\tuinteger_t operator/(const uinteger_t& rhs) const {\n+\t\treturn divmod(*this, rhs).first;\n+\t}\n+\n+\tuinteger_t& operator/=(const uinteger_t& rhs) {\n+\t\tuinteger_t quotient;\n+\t\tuinteger_t remainder;\n+\t\tdivmod(quotient, remainder, *this, rhs);\n+\t\t*this = std::move(quotient);\n+\t\treturn *this;\n+\t}\n+\n+\tuinteger_t operator%(const uinteger_t& rhs) const {\n+\t\treturn divmod(*this, rhs).second;\n+\t}\n+\n+\tuinteger_t& operator%=(const uinteger_t& rhs) {\n+\t\tuinteger_t quotient;\n+\t\tuinteger_t remainder;\n+\t\tdivmod(quotient, remainder, *this, rhs);\n+\t\t*this = std::move(remainder);\n+\t\treturn *this;\n+\t}\n+\n+\t// Increment Operator\n+\tuinteger_t& operator++() {\n+\t\treturn *this += uint_1();\n+\t}\n+\tuinteger_t operator++(int) {\n+\t\tuinteger_t temp(*this);\n+\t\t++*this;\n+\t\treturn temp;\n+\t}\n+\n+\t// Decrement Operator\n+\tuinteger_t& operator--() {\n+\t\treturn *this -= uint_1();\n+\t}\n+\tuinteger_t operator--(int) {\n+\t\tuinteger_t temp(*this);\n+\t\t--*this;\n+\t\treturn temp;\n+\t}\n+\n+\t// Nothing done since promotion doesn't work here\n+\tuinteger_t operator+() const {\n+\t\treturn *this;\n+\t}\n+\n+\t// two's complement\n+\tuinteger_t operator-() const {\n+\t\treturn uint_0() - *this;\n+\t}\n+\n+\t// Get private value at index\n+\tconst digit& value(std::size_t idx) const {\n+\t\tstatic const digit zero = 0;\n+\t\treturn idx < size() ? *(begin() + idx) : zero;\n+\t}\n+\n+\t// Get value of bit N\n+\tbool operator[](std::size_t n) const {\n+\t\tauto nd = n / digit_bits;\n+\t\tauto nm = n % digit_bits;\n+\t\treturn nd < size() ? (*(begin() + nd) >> nm) & 1 : 0;\n+\t}\n+\n+\t// Get bitsize of value\n+\tstd::size_t bits() const {\n+\t\tauto sz = size();\n+\t\tif (sz) {\n+\t\t\treturn _bits(back()) + (sz - 1) * digit_bits;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t// Get string representation of value\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult str(int alphabet_base = 10) const {\n+\t\tauto num_sz = size();\n+\t\tif (alphabet_base >= 2 && alphabet_base <= 36) {\n+\t\t\tResult result;\n+\t\t\tif (num_sz) {\n+\t\t\t\tauto alphabet_base_bits = base_bits(alphabet_base);\n+\t\t\t\tresult.reserve(num_sz * base_size(alphabet_base));\n+\t\t\t\tif (alphabet_base_bits) {\n+\t\t\t\t\tdigit alphabet_base_mask = alphabet_base - 1;\n+\t\t\t\t\tstd::size_t shift = 0;\n+\t\t\t\t\tauto ptr = reinterpret_cast<const half_digit*>(data());\n+\t\t\t\t\tdigit v = *ptr++;\n+\t\t\t\t\tv <<= half_digit_bits;\n+\t\t\t\t\tfor (auto i = num_sz * 2 - 1; i; --i) {\n+\t\t\t\t\t\tv >>= half_digit_bits;\n+\t\t\t\t\t\tv |= (static_cast<digit>(*ptr++) << half_digit_bits);\n+\t\t\t\t\t\tdo {\n+\t\t\t\t\t\t\tauto d = static_cast<int>((v >> shift) & alphabet_base_mask);\n+\t\t\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\t\t\tshift += alphabet_base_bits;\n+\t\t\t\t\t\t} while (shift <= half_digit_bits);\n+\t\t\t\t\t\tshift -= half_digit_bits;\n+\t\t\t\t\t}\n+\t\t\t\t\tv >>= (shift + half_digit_bits);\n+\t\t\t\t\twhile (v) {\n+\t\t\t\t\t\tauto d = static_cast<int>(v & alphabet_base_mask);\n+\t\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\t\tv >>= alphabet_base_bits;\n+\t\t\t\t\t}\n+\t\t\t\t\tauto s = chr(0);\n+\t\t\t\t\tauto rit_f = std::find_if(result.rbegin(), result.rend(), [s](const char& c) { return c != s; });\n+\t\t\t\t\tresult.resize(result.rend() - rit_f); // shrink\n+\t\t\t\t} else {\n+\t\t\t\t\tuinteger_t uint_base = alphabet_base;\n+\t\t\t\t\tuinteger_t quotient = *this;\n+\t\t\t\t\tdo {\n+\t\t\t\t\t\tauto r = quotient.divmod(uint_base);\n+\t\t\t\t\t\tauto d = static_cast<int>(r.second);\n+\t\t\t\t\t\tresult.push_back(chr(d));\n+\t\t\t\t\t\tquotient = std::move(r.first);\n+\t\t\t\t\t} while (quotient);\n+\t\t\t\t}\n+\t\t\t\tstd::reverse(result.begin(), result.end());\n+\t\t\t} else {\n+\t\t\t\tresult.push_back(chr(0));\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} else if (alphabet_base == 256) {\n+\t\t\tif (num_sz) {\n+\t\t\t\tauto ptr = reinterpret_cast<const char*>(data());\n+\t\t\t\tResult result(ptr, ptr + num_sz * digit_octets);\n+\t\t\t\tauto rit_f = std::find_if(result.rbegin(), result.rend(), [](const char& c) { return c; });\n+\t\t\t\tresult.resize(result.rend() - rit_f); // shrink\n+\t\t\t\tstd::reverse(result.begin(), result.end());\n+\t\t\t\treturn result;\n+\t\t\t} else {\n+\t\t\t\tResult result;\n+\t\t\t\tresult.push_back('\\x00');\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthrow std::invalid_argument(\"Base must be in the range [2, 36]\");\n+\t\t}\n+\t}\n+\n+\tstatic uinteger_t strtouint(const void* encoded, std::size_t encoded_size, int alphabet_base) {\n+\t\tconst char* data = (const char *)encoded;\n+\t\tuinteger_t result;\n+\n+\t\tif (alphabet_base >= 2 && alphabet_base <= 36) {\n+\t\t\tuinteger_t alphabet_base_bits = base_bits(alphabet_base);\n+\t\t\tuinteger_t uint_base = alphabet_base;\n+\t\t\tif (alphabet_base_bits) {\n+\t\t\t\tfor (; encoded_size; --encoded_size, ++data) {\n+\t\t\t\t\tauto d = ord(static_cast<int>(*data));\n+\t\t\t\t\tif (d < 0) {\n+\t\t\t\t\t\tthrow std::invalid_argument(\"Error: Not a digit in base \" + std::to_string(alphabet_base) + \": '\" + std::string(1, *data) + \"' at \" + std::to_string(encoded_size));\n+\t\t\t\t\t}\n+\t\t\t\t\tresult = (result << alphabet_base_bits) | d;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor (; encoded_size; --encoded_size, ++data) {\n+\t\t\t\t\tauto d = ord(static_cast<int>(*data));\n+\t\t\t\t\tif (d < 0) {\n+\t\t\t\t\t\tthrow std::invalid_argument(\"Error: Not a digit in base \" + std::to_string(alphabet_base) + \": '\" + std::string(1, *data) + \"' at \" + std::to_string(encoded_size));\n+\t\t\t\t\t}\n+\t\t\t\t\tresult = (result * uint_base) + d;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (encoded_size && alphabet_base == 256) {\n+\t\t\tauto value_size = encoded_size / digit_octets;\n+\t\t\tauto value_padding = encoded_size % digit_octets;\n+\t\t\tif (value_padding) {\n+\t\t\t\tvalue_padding = digit_octets - value_padding;\n+\t\t\t\t++value_size;\n+\t\t\t}\n+\t\t\tresult.resize(value_size); // grow (no initialization)\n+\t\t\t*result.begin() = 0; // initialize value\n+\t\t\tauto ptr = reinterpret_cast<char*>(result.data());\n+\t\t\tstd::copy(data, data + encoded_size, ptr + value_padding);\n+\t\t\tstd::reverse(ptr, ptr + value_size * digit_octets);\n+\t\t} else {\n+\t\t\tthrow std::invalid_argument(\"Error: Cannot convert from base \" + std::to_string(alphabet_base));\n+\t\t}\n+\n+\t\treturn result;\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult bin() const {\n+\t\treturn str<Result>(2);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult oct() const {\n+\t\treturn str<Result>(8);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult hex() const {\n+\t\treturn str<Result>(16);\n+\t}\n+\n+\ttemplate <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>\n+\tResult raw() const {\n+\t\treturn str<Result>(256);\n+\t}\n+};\n+\n+namespace std {  // This is probably not a good idea\n+\t// Make it work with std::string()\n+\tinline std::string to_string(uinteger_t& num) {\n+\t\treturn num.str();\n+\t}\n+\tinline const std::string to_string(const uinteger_t& num) {\n+\t\treturn num.str();\n+\t}\n+}\n+\n+// lhs type T as first arguemnt\n+// If the output is not a bool, casts to type T\n+\n+// Bitwise Operators\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator&(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) & rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator&=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(rhs & lhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator|(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) | rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator|=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(rhs | lhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator^(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) ^ rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator^=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(rhs ^ lhs);\n+}\n+\n+// Bitshift operators\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+inline uinteger_t operator<<(T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) << rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator<<=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(lhs << rhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+inline uinteger_t operator>>(T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) >> rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator>>=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(lhs >> rhs);\n+}\n+\n+// Comparison Operators\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator==(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) == rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator!=(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) != rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator>(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) > rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator<(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) < rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator>=(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) >= rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+bool operator<=(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) <= rhs;\n+}\n+\n+// Arithmetic Operators\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator+(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) + rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator+=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(rhs + lhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator-(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) - rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator-=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(lhs - rhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator*(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) * rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator*=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(rhs * lhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator/(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) / rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator/=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(lhs / rhs);\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+uinteger_t operator%(const T& lhs, const uinteger_t& rhs) {\n+\treturn uinteger_t(lhs) % rhs;\n+}\n+\n+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>\n+T& operator%=(T& lhs, const uinteger_t& rhs) {\n+\treturn lhs = static_cast<T>(lhs % rhs);\n+}\n+\n+// IO Operator\n+inline std::ostream& operator<<(std::ostream& stream, const uinteger_t& rhs) {\n+\tif (stream.flags() & stream.oct) {\n+\t\tstream << rhs.str(8);\n+\t} else if (stream.flags() & stream.dec) {\n+\t\tstream << rhs.str(10);\n+\t} else if (stream.flags() & stream.hex) {\n+\t\tstream << rhs.str(16);\n+\t}\n+\treturn stream;\n+}\n+\n+#endif\ndiff --git a/docs/en/development/contrib.md b/docs/en/development/contrib.md\nindex 3936b613bcb5..b589a6d64fd0 100644\n--- a/docs/en/development/contrib.md\n+++ b/docs/en/development/contrib.md\n@@ -18,6 +18,7 @@ The list of third-party libraries:\n | aws-c-common | [Apache](https://github.com/ClickHouse-Extras/aws-c-common/blob/736a82d1697c108b04a277e66438a7f4e19b6857/LICENSE) |\n | aws-c-event-stream | [Apache](https://github.com/ClickHouse-Extras/aws-c-event-stream/blob/3bc33662f9ccff4f4cbcf9509cc78c26e022fde0/LICENSE) |\n | aws-checksums | [Apache](https://github.com/ClickHouse-Extras/aws-checksums/blob/519d6d9093819b6cf89ffff589a27ef8f83d0f65/LICENSE) |\n+| base58 | [MIT](https://github.com/ClickHouse/base-x/blob/3e58874643c087f57e82b0ff03825c933fab945a/LICENSE) |\n | base64 | [BSD 2-clause](https://github.com/ClickHouse-Extras/Turbo-Base64/blob/af9b331f2b4f30b41c70f3a571ff904a8251c1d3/LICENSE) |\n | boost | [Boost](https://github.com/ClickHouse-Extras/boost/blob/9cf09dbfd55a5c6202dedbdf40781a51b02c2675/LICENSE_1_0.txt) |\n | boringssl | [BSD](https://github.com/ClickHouse-Extras/boringssl/blob/a6a2e2ab3e44d97ce98e51c558e989f211de7eb3/LICENSE) |\ndiff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex cac546d9a705..38d247457cf7 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -494,6 +494,48 @@ If the \u2018s\u2019 string is non-empty and does not contain the \u2018c\u2019 character at\n \n Returns the string \u2018s\u2019 that was converted from the encoding in \u2018from\u2019 to the encoding in \u2018to\u2019.\n \n+## Base58Encode(plaintext[, alphabet_name]), Base58Decode(encoded_text[, alphabet_name])\n+\n+Accepts a String and encodes/decodes it using [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) encoding scheme using specified alphabet.\n+\n+**Syntax**\n+\n+```sql\n+base58Encode(decoded[, alphabet_name])\n+base58Decode(encoded[, alphabet_name])\n+```\n+\n+**Arguments**\n+\n+- `decoded` \u2014 [String](../../sql-reference/data-types/string.md) column or constant.\n+- `encoded` \u2014 [String](../../sql-reference/data-types/string.md) column or constant. If the string is not a valid base58-encoded value, an exception is thrown.\n+- `alphabet_name` \u2014 String constant. Specifies alphabet used for encoding. Possible values: `gmp`, `bitcoin`, `ripple`, `flickr`. Default: `bitcoin`.\n+\n+**Returned value**\n+\n+-   A string containing encoded/decoded value of 1st argument.\n+\n+Type: [String](../../sql-reference/data-types/string.md).\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT base58Encode('encode', 'flickr');\n+SELECT base58Decode('izCFiDUY', 'ripple');\n+```\n+\n+Result:\n+```text\n+\u250c\u2500base58Encode('encode', 'flickr')\u2500\u2510\n+\u2502 SvyTHb1D                         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500base58Decode('izCFiDUY', 'ripple')\u2500\u2510\n+\u2502 decode                             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## base64Encode(s)\n \n Encodes \u2018s\u2019 string into base64\ndiff --git a/docs/ru/development/contrib.md b/docs/ru/development/contrib.md\nindex 1b99ec975534..0f4d22e90ceb 100644\n--- a/docs/ru/development/contrib.md\n+++ b/docs/ru/development/contrib.md\n@@ -18,6 +18,7 @@ sidebar_label: \"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u043d\u0438\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438\n | aws-c-common | [Apache](https://github.com/ClickHouse-Extras/aws-c-common/blob/736a82d1697c108b04a277e66438a7f4e19b6857/LICENSE) |\n | aws-c-event-stream | [Apache](https://github.com/ClickHouse-Extras/aws-c-event-stream/blob/3bc33662f9ccff4f4cbcf9509cc78c26e022fde0/LICENSE) |\n | aws-checksums | [Apache](https://github.com/ClickHouse-Extras/aws-checksums/blob/519d6d9093819b6cf89ffff589a27ef8f83d0f65/LICENSE) |\n+| base58 | [MIT](https://github.com/ClickHouse/base-x/blob/3e58874643c087f57e82b0ff03825c933fab945a/LICENSE) |\n | base64 | [BSD 2-clause](https://github.com/ClickHouse-Extras/Turbo-Base64/blob/af9b331f2b4f30b41c70f3a571ff904a8251c1d3/LICENSE) |\n | boost | [Boost](https://github.com/ClickHouse-Extras/boost/blob/9cf09dbfd55a5c6202dedbdf40781a51b02c2675/LICENSE_1_0.txt) |\n | boringssl | [BSD](https://github.com/ClickHouse-Extras/boringssl/blob/a6a2e2ab3e44d97ce98e51c558e989f211de7eb3/LICENSE) |\ndiff --git a/docs/ru/sql-reference/functions/string-functions.md b/docs/ru/sql-reference/functions/string-functions.md\nindex 6cd4cea403ea..1acf5ec58b2d 100644\n--- a/docs/ru/sql-reference/functions/string-functions.md\n+++ b/docs/ru/sql-reference/functions/string-functions.md\n@@ -490,6 +490,48 @@ SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY (key1, key2);\n \n \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e \u0438\u0437 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438 from \u0432 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443 to \u0441\u0442\u0440\u043e\u043a\u0443 s.\n \n+## Base58Encode(plaintext[, alphabet_name]), Base58Decode(plaintext[, alphabet_name]) {#base58}\n+\n+\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043d\u0430 \u0432\u0445\u043e\u0434 \u0441\u0442\u0440\u043e\u043a\u0443 \u0438\u043b\u0438 \u043a\u043e\u043b\u043e\u043d\u043a\u0443 \u0441\u0442\u0440\u043e\u043a \u0438 \u043a\u043e\u0434\u0438\u0440\u0443\u0435\u0442/\u0440\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u0443\u0435\u0442 \u0438\u0445 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0441\u0445\u0435\u043c\u044b \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0430.\n+\n+**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n+\n+```sql\n+base58Encode(decoded[, alphabet_name])\n+base58Decode(encoded[, alphabet_name])\n+```\n+\n+**\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n+\n+- `decoded` \u2014 \u041a\u043e\u043b\u043e\u043d\u043a\u0430 \u0438\u043b\u0438 \u0441\u0442\u0440\u043e\u043a\u0430 \u0442\u0438\u043f\u0430 [String](../../sql-reference/data-types/string.md).\n+- `encoded` \u2014 \u041a\u043e\u043b\u043e\u043d\u043a\u0430 \u0438\u043b\u0438 \u0441\u0442\u0440\u043e\u043a\u0430 \u0442\u0438\u043f\u0430 [String](../../sql-reference/data-types/string.md). \u0415\u0441\u043b\u0438 \u0432\u0445\u043e\u0434\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u043c \u043a\u043e\u0434\u043e\u043c \u0434\u043b\u044f \u043a\u0430\u043a\u043e\u0439-\u043b\u0438\u0431\u043e \u0434\u0440\u0443\u0433\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438, \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 `1001`.\n+- `alphabet_name` \u2014 \u0421\u0442\u0440\u043e\u043a\u043e\u0432\u0430\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430. \u0423\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0430\u043b\u0444\u0430\u0432\u0438\u0442, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u0434. \u041c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u043e\u0434\u043d\u043e \u0438\u0437 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439: `gmp`, `bitcoin`, `ripple`, `flickr`. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `bitcoin`.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+-   \u0421\u0442\u0440\u043e\u043a\u0430, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0430\u044f \u0440\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439/\u0437\u0430\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0432\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442.\n+\n+\u0422\u0438\u043f: [String](../../sql-reference/data-types/string.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440:**\n+\n+\u0417\u0430\u043f\u0440\u043e\u0441:\n+\n+``` sql\n+SELECT base58Encode('encode', 'flickr');\n+SELECT base58Decode('izCFiDUY', 'ripple');\n+```\n+\n+\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\n+```text\n+\u250c\u2500base58Encode('encode', 'flickr')\u2500\u2510\n+\u2502 SvyTHb1D                         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500base58Decode('izCFiDUY', 'ripple')\u2500\u2510\n+\u2502 decode                             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## base64Encode(s) {#base64encode}\n \n \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 s \u0432 base64-\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435.\ndiff --git a/src/Functions/CMakeLists.txt b/src/Functions/CMakeLists.txt\nindex 60386908f014..32f7952961c3 100644\n--- a/src/Functions/CMakeLists.txt\n+++ b/src/Functions/CMakeLists.txt\n@@ -72,6 +72,10 @@ if (TARGET ch_contrib::llvm)\n     target_link_libraries(clickhouse_functions PRIVATE ch_contrib::llvm)\n endif ()\n \n+if (TARGET ch_contrib::base-x)\n+    target_link_libraries(clickhouse_functions PRIVATE ch_contrib::base-x)\n+endif()\n+\n if (TARGET ch_contrib::base64)\n     target_link_libraries(clickhouse_functions PRIVATE ch_contrib::base64)\n endif()\ndiff --git a/src/Functions/FunctionBase58Conversion.h b/src/Functions/FunctionBase58Conversion.h\nnew file mode 100644\nindex 000000000000..6979ce849f46\n--- /dev/null\n+++ b/src/Functions/FunctionBase58Conversion.h\n@@ -0,0 +1,256 @@\n+#pragma once\n+#include \"config_functions.h\"\n+\n+#if USE_BASEX\n+#    include <Columns/ColumnConst.h>\n+#    include <Common/MemorySanitizer.h>\n+#    include <Columns/ColumnString.h>\n+#    include <DataTypes/DataTypeString.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/FunctionHelpers.h>\n+#    include <IO/WriteHelpers.h>\n+#    include <base_x.hh>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+struct Base58Encode\n+{\n+    static constexpr auto name = \"base58Encode\";\n+\n+    static void process(const ColumnString & input, ColumnString::MutablePtr & dst_column, const std::string & alphabet, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+\n+        /// Wikipedia states Base58 has efficiency of 73%, and we take 1.5 scale to avoid reallocation in most cases\n+        size_t current_allocated_size = ceil(1.5 * input.getChars().size());\n+\n+        dst_data.resize(current_allocated_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const ColumnString::Offsets & src_offsets = input.getOffsets();\n+\n+        const auto * source = input.getChars().raw_data();\n+        auto * dst = dst_data.data();\n+        auto * dst_pos = dst;\n+\n+        size_t src_offset_prev = 0;\n+        size_t processed_size = 0;\n+\n+        const auto& encoder = (alphabet == \"bitcoin\") ? Base58::bitcoin() :\n+                             ((alphabet == \"flickr\") ? Base58::flickr() :\n+                             ((alphabet == \"ripple\") ? Base58::ripple() :\n+                                                       Base58::base58())); //GMP\n+\n+        std::string encoded;\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            size_t srclen = src_offsets[row] - src_offset_prev - 1;\n+            /// Why we didn't use char* here?\n+            /// We don't know the size of the result string beforehand (it's not byte-to-byte encoding),\n+            /// so we may need to do many resizes (the worst case -- we'll do it for each row)\n+            /// This way we do exponential resizes and one final resize after whole operation is complete\n+            encoded.clear();\n+            if (srclen)\n+                try\n+                {\n+                    encoder.encode(encoded, source, srclen);\n+                }\n+                catch (const std::invalid_argument& e)\n+                {\n+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);\n+                }\n+                catch (const std::domain_error& e)\n+                {\n+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);\n+                }\n+            size_t outlen = encoded.size();\n+\n+            if (processed_size + outlen >= current_allocated_size)\n+            {\n+                current_allocated_size += current_allocated_size;\n+                dst_data.resize(current_allocated_size);\n+                auto processed_offset = dst_pos - dst;\n+                dst = dst_data.data();\n+                dst_pos = dst;\n+                dst_pos += processed_offset;\n+            }\n+            std::memcpy(dst_pos, encoded.c_str(), ++outlen);\n+\n+            source += srclen + 1;\n+            dst_pos += outlen;\n+\n+            dst_offsets[row] = dst_pos - dst;\n+            src_offset_prev = src_offsets[row];\n+            processed_size += outlen;\n+        }\n+\n+        dst_data.resize(dst_pos - dst);\n+    }\n+};\n+\n+struct Base58Decode\n+{\n+    static constexpr auto name = \"base58Decode\";\n+\n+    static void process(const ColumnString & input, ColumnString::MutablePtr & dst_column, const std::string & alphabet, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+\n+        /// We allocate probably even more then needed to avoid many resizes\n+        size_t current_allocated_size = input.getChars().size();\n+\n+        dst_data.resize(current_allocated_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const ColumnString::Offsets & src_offsets = input.getOffsets();\n+\n+        const auto * source = input.getChars().raw_data();\n+        auto * dst = dst_data.data();\n+        auto * dst_pos = dst;\n+\n+        size_t src_offset_prev = 0;\n+        size_t processed_size = 0;\n+\n+        const auto& decoder = (alphabet == \"bitcoin\") ? Base58::bitcoin() :\n+                             ((alphabet == \"flickr\") ? Base58::flickr() :\n+                             ((alphabet == \"ripple\") ? Base58::ripple() :\n+                                                       Base58::base58()));\n+\n+        std::string decoded;\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            size_t srclen = src_offsets[row] - src_offset_prev - 1;\n+            /// Why we didn't use char* here?\n+            /// We don't know the size of the result string beforehand (it's not byte-to-byte encoding),\n+            /// so we may need to do many resizes (the worst case -- we'll do it for each row)\n+            /// This way we do exponential resizes and one final resize after whole operation is complete\n+            decoded.clear();\n+            if (srclen)\n+                try\n+                {\n+                    decoder.decode(decoded, source, srclen);\n+                }\n+                catch (const std::invalid_argument& e)\n+                {\n+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);\n+                }\n+                catch (const std::domain_error& e)\n+                {\n+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);\n+                }\n+            size_t outlen = decoded.size();\n+\n+            if (processed_size + outlen >= current_allocated_size)\n+            {\n+                current_allocated_size += current_allocated_size;\n+                dst_data.resize(current_allocated_size);\n+                auto processed_offset = dst_pos - dst;\n+                dst = dst_data.data();\n+                dst_pos = dst;\n+                dst_pos += processed_offset;\n+            }\n+            std::memcpy(dst_pos, decoded.c_str(), ++outlen);\n+\n+            source += srclen + 1;\n+            dst_pos += outlen;\n+\n+            dst_offsets[row] = dst_pos - dst;\n+            src_offset_prev = src_offsets[row];\n+            processed_size += outlen;\n+        }\n+\n+        dst_data.resize(dst_pos - dst);\n+    }\n+};\n+\n+template <typename Func>\n+class FunctionBase58Conversion : public IFunction\n+{\n+public:\n+    static constexpr auto name = Func::name;\n+\n+    static FunctionPtr create(ContextPtr)\n+    {\n+        return std::make_shared<FunctionBase58Conversion>();\n+    }\n+\n+    String getName() const override\n+    {\n+        return Func::name;\n+    }\n+\n+    bool isVariadic() const override { return true; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() != 1 && arguments.size() != 2)\n+            throw Exception(\n+                \"Wrong number of arguments for function \" + getName() + \":  1 or 2 expected.\",\n+                ErrorCodes::BAD_ARGUMENTS);\n+\n+        if (!isString(arguments[0].type))\n+            throw Exception(\n+                \"Illegal type \" + arguments[0].type->getName() + \" of 1st argument of function \" + getName() + \". Must be String.\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if (arguments.size() == 2 && !isString(arguments[1].type))\n+            throw Exception(\n+                \"Illegal type \" + arguments[1].type->getName() + \" of 2nd argument of function \" + getName() + \". Must be String.\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const ColumnPtr column_string = arguments[0].column;\n+        const ColumnString * input = checkAndGetColumn<ColumnString>(column_string.get());\n+        if (!input)\n+            throw Exception(\n+                \"Illegal column \" + arguments[0].column->getName() + \" of first argument of function \" + getName() + \", must be String\",\n+                ErrorCodes::ILLEGAL_COLUMN);\n+\n+        std::string alphabet = \"bitcoin\";\n+\n+        if (arguments.size() == 2)\n+        {\n+            const auto * alphabet_column = checkAndGetColumn<ColumnConst>(arguments[1].column.get());\n+\n+            if (!alphabet_column)\n+                throw Exception(\"Second argument for function \" + getName() + \" must be constant String\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+            alphabet = alphabet_column->getValue<DB::String>();\n+            if (alphabet != \"bitcoin\" && alphabet != \"ripple\" && alphabet != \"flickr\" && alphabet != \"gmp\")\n+                throw Exception(\"Second argument for function \" + getName() + \" must be 'bitcoin', 'ripple', 'gmp' or 'flickr'\", ErrorCodes::ILLEGAL_COLUMN);\n+\n+        }\n+\n+        auto dst_column = ColumnString::create();\n+\n+        Func::process(*input, dst_column, alphabet, input_rows_count);\n+\n+        return dst_column;\n+    }\n+};\n+}\n+\n+#endif\ndiff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h\nindex a1d6b9666603..87a3309f7ef7 100644\n--- a/src/Functions/FunctionBase64Conversion.h\n+++ b/src/Functions/FunctionBase64Conversion.h\n@@ -85,7 +85,7 @@ class FunctionBase64Conversion : public IFunction\n     {\n         if (!WhichDataType(arguments[0].type).isString())\n             throw Exception(\n-                \"Illegal type \" + arguments[0].type->getName() + \" of 1 argument of function \" + getName() + \". Must be String.\",\n+                \"Illegal type \" + arguments[0].type->getName() + \" of 1st argument of function \" + getName() + \". Must be String.\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeString>();\n@@ -98,7 +98,7 @@ class FunctionBase64Conversion : public IFunction\n \n         if (!input)\n             throw Exception(\n-                \"Illegal column \" + arguments[0].column->getName() + \" of first argument of function \" + getName(),\n+                \"Illegal column \" + arguments[0].column->getName() + \" of first argument of function \" + getName() + \", must be of type String\",\n                 ErrorCodes::ILLEGAL_COLUMN);\n \n         auto dst_column = ColumnString::create();\ndiff --git a/src/Functions/FunctionsBase58.cpp b/src/Functions/FunctionsBase58.cpp\nnew file mode 100644\nindex 000000000000..dc325ff8cfcd\n--- /dev/null\n+++ b/src/Functions/FunctionsBase58.cpp\n@@ -0,0 +1,17 @@\n+#include <Functions/FunctionBase58Conversion.h>\n+#if USE_BASEX\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+void registerFunctionBase58Encode(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionBase58Conversion<Base58Encode>>();\n+}\n+\n+void registerFunctionBase58Decode(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionBase58Conversion<Base58Decode>>();\n+}\n+}\n+#endif\ndiff --git a/src/Functions/config_functions.h.in b/src/Functions/config_functions.h.in\nindex a693611f975e..0bfea78922b5 100644\n--- a/src/Functions/config_functions.h.in\n+++ b/src/Functions/config_functions.h.in\n@@ -2,6 +2,7 @@\n \n // .h autogenerated by cmake!\n \n+#cmakedefine01 USE_BASEX\n #cmakedefine01 USE_BASE64\n #cmakedefine01 USE_SIMDJSON\n #cmakedefine01 USE_RAPIDJSON\ndiff --git a/src/Functions/configure_config.cmake b/src/Functions/configure_config.cmake\nindex 7615a2eeeaf0..1038c09e53f1 100644\n--- a/src/Functions/configure_config.cmake\n+++ b/src/Functions/configure_config.cmake\n@@ -1,6 +1,9 @@\n if (TARGET ch_contrib::fastops)\n     set(USE_FASTOPS 1)\n endif()\n+if (TARGET ch_contrib::base-x)\n+    set(USE_BASEX 1)\n+endif()\n if (TARGET ch_contrib::base64)\n     set(USE_BASE64 1)\n endif()\ndiff --git a/src/Functions/registerFunctionsString.cpp b/src/Functions/registerFunctionsString.cpp\nindex f86043c69597..248b6391b4f3 100644\n--- a/src/Functions/registerFunctionsString.cpp\n+++ b/src/Functions/registerFunctionsString.cpp\n@@ -49,6 +49,11 @@ void registerFunctionBase64Decode(FunctionFactory &);\n void registerFunctionTryBase64Decode(FunctionFactory &);\n #endif\n \n+#if USE_BASEX\n+void registerFunctionBase58Encode(FunctionFactory &);\n+void registerFunctionBase58Decode(FunctionFactory &);\n+#endif\n+\n #if USE_NLP\n void registerFunctionStem(FunctionFactory &);\n void registerFunctionSynonyms(FunctionFactory &);\n@@ -105,6 +110,11 @@ void registerFunctionsString(FunctionFactory & factory)\n     registerFunctionTryBase64Decode(factory);\n #endif\n \n+#if USE_BASEX\n+    registerFunctionBase58Encode(factory);\n+    registerFunctionBase58Decode(factory);\n+#endif\n+\n #if USE_NLP\n     registerFunctionStem(factory);\n     registerFunctionSynonyms(factory);\ndiff --git a/src/configure_config.cmake b/src/configure_config.cmake\nindex 519307ba28a8..45e45b505d41 100644\n--- a/src/configure_config.cmake\n+++ b/src/configure_config.cmake\n@@ -55,6 +55,9 @@ endif()\n if (TARGET ch_contrib::base64)\n     set(USE_BASE64 1)\n endif()\n+if (TARGET ch_contrib::base-x)\n+    set(USE_BASEX 1)\n+endif()\n if (TARGET ch_contrib::yaml_cpp)\n     set(USE_YAML_CPP 1)\n endif()\n",
  "test_patch": "diff --git a/contrib/base-x/tests/test.cc b/contrib/base-x/tests/test.cc\nnew file mode 100644\nindex 000000000000..d47d211173e2\n--- /dev/null\n+++ b/contrib/base-x/tests/test.cc\n@@ -0,0 +1,30 @@\n+/*\n+The MIT License (MIT)\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+*/\n+\n+#include <gtest/gtest.h>\n+\n+int main(int argc, char * argv[]){\n+    ::testing::InitGoogleTest(&argc, argv);\n+    return RUN_ALL_TESTS();\n+}\n\\ No newline at end of file\ndiff --git a/contrib/base-x/tests/testcases/tests.cc b/contrib/base-x/tests/testcases/tests.cc\nnew file mode 100644\nindex 000000000000..c5bebfc82885\n--- /dev/null\n+++ b/contrib/base-x/tests/testcases/tests.cc\n@@ -0,0 +1,359 @@\n+/*\n+The MIT License (MIT)\n+\n+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+*/\n+\n+#include <gtest/gtest.h>\n+\n+#include \"base_x.hh\"\n+\n+\n+static constexpr BaseX test_base2(0, \"01\", \"\", \"\", \"\");\n+static constexpr BaseX test_base16(0, \"0123456789abcdef\", \"\", \"\", \"\");\n+static constexpr BaseX test_base58(0, \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\", \"\", \"\", \"\");\n+\n+\n+TEST(UUID, Encode) {\n+\tEXPECT_EQ(Base62::base62().encode(\"\\330\\105\\140\\310\\23\\117\\21\\346\\241\\342\\64\\66\\73\\322\\155\\256\"), \"6a630O1jrtMjCrQDyG3D3O\");\n+\tEXPECT_EQ(Base58::bitcoin().encode(\"\\330\\105\\140\\310\\23\\117\\21\\346\\241\\342\\64\\66\\73\\322\\155\\256\"), \"ThxCy1Ek2q6UhWQhj9CK1o\");\n+\tEXPECT_EQ(Base58::base58().encode(\"\\330\\105\\140\\310\\23\\117\\21\\346\\241\\342\\64\\66\\73\\322\\155\\256\"), \"QetBu0Dh1m5ReTNeg8BI0k\");\n+}\n+\n+TEST(BaseX, checksums) {\n+\tEXPECT_EQ(Base64::base64().encode(\"Hello world!\"), \"SGVsbG8gd29ybGQh\");\n+\tEXPECT_EQ(Base64::base64chk().encode(\"Hello world!\"), \"SGVsbG8gd29ybGQhG\");\n+\n+\tEXPECT_EQ(Base64::base64().decode(\"SGVsbG8gd29ybGQh\"), \"Hello world!\");\n+\tEXPECT_EQ(Base64::base64chk().decode(\"SGVsbG8gd29ybGQhG\"), \"Hello world!\");\n+\n+\tEXPECT_EQ(Base62::base62().encode(\"Hello world!\"), \"T8dgcjRGuYUueWht\");\n+\tEXPECT_EQ(Base62::base62chk().encode(\"Hello world!\"), \"T8dgcjRGuYUueWhtE\");\n+\n+\tEXPECT_EQ(Base62::base62().decode(\"T8dgcjRGuYUueWht\"), \"Hello world!\");\n+\tEXPECT_EQ(Base62::base62chk().decode(\"T8dgcjRGuYUueWhtE\"), \"Hello world!\");\n+\n+\tEXPECT_EQ(Base62::base62chk().is_valid(\"T8dgcjRGuYUueWhtE\"), true);\n+\tEXPECT_EQ(Base62::base62chk().is_valid(\"Some random text!\"), false);\n+}\n+\n+TEST(base16, Encoder) {\n+\tEXPECT_EQ(Base16::base16().encode(\"A\"), \"41\");\n+\tEXPECT_EQ(Base16::base16().encode(\"AB\"), \"4142\");\n+\tEXPECT_EQ(Base16::base16().encode(\"ABC\"), \"414243\");\n+\tEXPECT_EQ(Base16::base16().encode(\"ABCD\"), \"41424344\");\n+\tEXPECT_EQ(Base16::base16().encode(\"ABCDE\"), \"4142434445\");\n+\tEXPECT_EQ(Base16::base16().encode(\"ABCDEF\"), \"414243444546\");\n+\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"A\"), \"41\");\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"AB\"), \"4142\");\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"ABC\"), \"414243\");\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"ABCD\"), \"41424344\");\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"ABCDE\"), \"4142434445\");\n+\tEXPECT_EQ(Base16::rfc4648().encode(\"ABCDEF\"), \"414243444546\");\n+}\n+\n+TEST(base16, Decoder) {\n+\tEXPECT_EQ(Base16::base16().decode(\"41\"), \"A\");\n+\tEXPECT_EQ(Base16::base16().decode(\"4142\"), \"AB\");\n+\tEXPECT_EQ(Base16::base16().decode(\"414243\"), \"ABC\");\n+\tEXPECT_EQ(Base16::base16().decode(\"41424344\"), \"ABCD\");\n+\tEXPECT_EQ(Base16::base16().decode(\"4142434445\"), \"ABCDE\");\n+\tEXPECT_EQ(Base16::base16().decode(\"414243444546\"), \"ABCDEF\");\n+\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"41\"), \"A\");\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"4142\"), \"AB\");\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"414243\"), \"ABC\");\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"41424344\"), \"ABCD\");\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"4142434445\"), \"ABCDE\");\n+\tEXPECT_EQ(Base16::rfc4648().decode(\"414243444546\"), \"ABCDEF\");\n+}\n+\n+TEST(base32, Encoder) {\n+\t// Note base64() encoding is NOT the same as the standard (rfc4648)\n+\tEXPECT_EQ(Base32::base32().encode(\"A\"), \"21\");\n+\tEXPECT_EQ(Base32::base32().encode(\"AB\"), \"ga2\");\n+\tEXPECT_EQ(Base32::base32().encode(\"ABC\"), \"42gi3\");\n+\tEXPECT_EQ(Base32::base32().encode(\"ABCD\"), \"10k4gq4\");\n+\tEXPECT_EQ(Base32::base32().encode(\"ABCDE\"), \"85146h25\");\n+\tEXPECT_EQ(Base32::base32().encode(\"ABCDEF\"), \"21891k8ha6\");\n+\tEXPECT_EQ(Base32::base32().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"21891k8ha68t44iiib9h6ksjqga5956l2lapblgmaq\");\n+\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"A\"), \"IE======\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"AB\"), \"IFBA====\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"ABC\"), \"IFBEG===\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"ABCD\"), \"IFBEGRA=\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"ABCDE\"), \"IFBEGRCF\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"ABCDEF\"), \"IFBEGRCFIY======\");\n+\tEXPECT_EQ(Base32::rfc4648().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"IFBEGRCFIZDUQSKKJNGE2TSPKBIVEU2UKVLFOWCZLI======\");\n+\n+\tEXPECT_EQ(Base32::crockford().encode(519571), \"FVCK\");\n+\tEXPECT_EQ(Base32::crockfordchk().encode(1234), \"16JD\");\n+\tEXPECT_EQ(Base32::crockfordchk().encode(\"Hello World\"), \"28CNP6RVS0AXQQ4V348\");\n+}\n+\n+TEST(base32, Decoder) {\n+\t// Note base64() encoding is NOT the same as the standard (rfc4648)\n+\tEXPECT_EQ(Base32::base32().decode(\"21\"), \"A\");\n+\tEXPECT_EQ(Base32::base32().decode(\"ga2\"), \"AB\");\n+\tEXPECT_EQ(Base32::base32().decode(\"42gi3\"), \"ABC\");\n+\tEXPECT_EQ(Base32::base32().decode(\"10k4gq4\"), \"ABCD\");\n+\tEXPECT_EQ(Base32::base32().decode(\"85146h25\"), \"ABCDE\");\n+\tEXPECT_EQ(Base32::base32().decode(\"21891k8ha6\"), \"ABCDEF\");\n+\tEXPECT_EQ(Base32::base32().decode(\"21891k8ha68t44iiib9h6ksjqga5956l2lapblgmaq\"), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IE======\"), \"A\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBA====\"), \"AB\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBEG===\"), \"ABC\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBEGRA=\"), \"ABCD\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBEGRCF\"), \"ABCDE\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBEGRCFIY======\"), \"ABCDEF\");\n+\tEXPECT_EQ(Base32::rfc4648().decode(\"IFBEGRCFIZDUQSKKJNGE2TSPKBIVEU2UKVLFOWCZLI======\"), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+\n+\tEXPECT_EQ(Base32::crockford().decode<uinteger_t>(\"FVCK\"), 519571);\n+\tEXPECT_EQ(Base32::crockfordchk().is_valid(\"16JD\"), true);\n+\tEXPECT_EQ(Base32::crockfordchk().decode<uinteger_t>(\"16JD\"), 1234);\n+\n+\tEXPECT_EQ(Base32::crockfordchk().decode(\"2-8cn-p6r-vso-axq-q4v-348\"), \"Hello World\");\n+}\n+\n+TEST(base58, Encoder) {\n+\tEXPECT_EQ(Base58::base58().decode<uinteger_t>(\"1TFvCj\"), 987654321);\n+\tEXPECT_EQ(Base58::base58().encode(987654321), \"1TFvCj\");\n+\tEXPECT_EQ(Base58::base58().encode(\"Hello world!\"), \"1LDlk6QWOejX6rPrJ\");\n+\tEXPECT_EQ(Base58::bitcoin().encode(\"Hello world!\"), \"2NEpo7TZRhna7vSvL\");\n+}\n+\n+TEST(base62, Encoder) {\n+\tEXPECT_EQ(Base62::base62().decode<uinteger_t>(\"14q60P\"), 987654321);\n+\tEXPECT_EQ(Base62::base62().encode(987654321), \"14q60P\");\n+\tEXPECT_EQ(Base62::base62().encode(\"Hello world!\"), \"T8dgcjRGuYUueWht\");\n+\tEXPECT_EQ(Base62::inverted().encode(\"Hello world!\"), \"t8DGCJrgUyuUEwHT\");\n+}\n+\n+TEST(base64, Encoder) {\n+\t// Note Base64 encoding is NOT the same as the standard (rfc4648)\n+\tEXPECT_EQ(Base64::base64().encode(\"A\"), \"BB\");\n+\tEXPECT_EQ(Base64::base64().encode(\"AB\"), \"EFC\");\n+\tEXPECT_EQ(Base64::base64().encode(\"ABC\"), \"QUJD\");\n+\tEXPECT_EQ(Base64::base64().encode(\"ABCD\"), \"BBQkNE\");\n+\tEXPECT_EQ(Base64::base64().encode(\"ABCDE\"), \"EFCQ0RF\");\n+\tEXPECT_EQ(Base64::base64().encode(\"ABCDEF\"), \"QUJDREVG\");\n+\tEXPECT_EQ(Base64::base64().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"EFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFla\");\n+\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"A\"), \"QQ==\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"AB\"), \"QUI=\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"ABC\"), \"QUJD\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"ABCD\"), \"QUJDRA==\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"ABCDE\"), \"QUJDREU=\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"ABCDEF\"), \"QUJDREVG\");\n+\tEXPECT_EQ(Base64::rfc4648().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\");\n+}\n+\n+TEST(base64, Decoder) {\n+\t// Note Base64 encoding is NOT the same as the standard (rfc4648)\n+\tEXPECT_EQ(Base64::base64().decode(\"BB\"), \"A\");\n+\tEXPECT_EQ(Base64::base64().decode(\"EFC\"), \"AB\");\n+\tEXPECT_EQ(Base64::base64().decode(\"QUJD\"), \"ABC\");\n+\tEXPECT_EQ(Base64::base64().decode(\"BBQkNE\"), \"ABCD\");\n+\tEXPECT_EQ(Base64::base64().decode(\"EFCQ0RF\"), \"ABCDE\");\n+\tEXPECT_EQ(Base64::base64().decode(\"QUJDREVG\"), \"ABCDEF\");\n+\tEXPECT_EQ(Base64::base64().decode(\"EFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFla\"), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QQ==\"), \"A\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUI=\"), \"AB\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUJD\"), \"ABC\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUJDRA==\"), \"ABCD\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUJDREU=\"), \"ABCDE\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUJDREVG\"), \"ABCDEF\");\n+\tEXPECT_EQ(Base64::rfc4648().decode(\"QUJDREVG\\nR0hJSktM\\nTU5PUFFS\\nU1RVVldY\\nWVo=\"), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+}\n+\n+TEST(base58, ShouldEncodeAndDecodeIntegers) {\n+\tauto data = 987654321;\n+\n+\tauto gmpEncoded = Base58::base58().encode(data);\n+\tauto bitcoinEncoded = Base58::bitcoin().encode(data);\n+\tauto rippleEncoded = Base58::ripple().encode(data);\n+\tauto flickrEncoded = Base58::flickr().encode(data);\n+\n+\tEXPECT_EQ(gmpEncoded, \"1TFvCj\");\n+\tEXPECT_EQ(bitcoinEncoded, \"2WGzDn\");\n+\tEXPECT_EQ(rippleEncoded, \"pWGzD8\");\n+\tEXPECT_EQ(flickrEncoded, \"2vgZdM\");\n+\n+\tauto gmpDecoded = Base58::base58().decode<uinteger_t>(gmpEncoded);\n+\tauto bitcoinDecoded = Base58::bitcoin().decode<uinteger_t>(bitcoinEncoded);\n+\tauto rippleDecoded = Base58::ripple().decode<uinteger_t>(rippleEncoded);\n+\tauto flickrDecoded = Base58::flickr().decode<uinteger_t>(flickrEncoded);\n+\n+\tEXPECT_EQ(gmpDecoded, data);\n+\tEXPECT_EQ(bitcoinDecoded, data);\n+\tEXPECT_EQ(rippleDecoded, data);\n+\tEXPECT_EQ(flickrDecoded, data);\n+\n+\tauto encoded = Base58::base58().encode(data);\n+\tauto decoded = Base58::base58().decode<uinteger_t>(encoded);\n+\n+\tEXPECT_EQ(decoded, data);\n+}\n+\n+TEST(base58, LongText) {\n+\tauto data = \"Lorem ipsum dolor consectetur.\";\n+\n+\tauto gmpEncoded = Base58::base58().encode(data);\n+\tauto bitcoinEncoded = Base58::bitcoin().encode(data);\n+\tauto rippleEncoded = Base58::ripple().encode(data);\n+\tauto flickrEncoded = Base58::flickr().encode(data);\n+\n+\tEXPECT_EQ(gmpEncoded, \"FIHZQEpJ739QdqChX1PkgTBqP1FaDgJWQiGvY92YA\");\n+\tEXPECT_EQ(bitcoinEncoded, \"GKJcTFtL84ATguDka2SojWCuS2GdEjLZTmHzbA3bB\");\n+\tEXPECT_EQ(rippleEncoded, \"GKJcTEtL3hwTguDk2pSojWUuSpGdNjLZTmHzbwsbB\");\n+\tEXPECT_EQ(flickrEncoded, \"gjiBsfTk84asFUdKz2rNJvcUr2gCeJkysLhZAa3Ab\");\n+\n+\tauto gmpDecoded = Base58::base58().decode(gmpEncoded);\n+\tauto bitcoinDecoded = Base58::bitcoin().decode(bitcoinEncoded);\n+\tauto rippleDecoded = Base58::ripple().decode(rippleEncoded);\n+\tauto flickrDecoded = Base58::flickr().decode(flickrEncoded);\n+\n+\tEXPECT_EQ(gmpDecoded, data);\n+\tEXPECT_EQ(bitcoinDecoded, data);\n+\tEXPECT_EQ(rippleDecoded, data);\n+\tEXPECT_EQ(flickrDecoded, data);\n+}\n+\n+TEST(base58, Tests) {\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"000f\", 16)), \"1111\");\n+\t// EXPECT_EQ(test_base2.encode(uinteger_t(\"00ff\", 16)), \"011111111\"); // ->>\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"00ff\", 16)), \"11111111\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"0fff\", 16)), \"111111111111\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"ff00ff00\", 16)), \"11111111000000001111111100000000\");\n+\t// EXPECT_EQ(test_base16.encode(uinteger_t(\"0000000f\", 16)), \"000f\"); // ->>\n+\tEXPECT_EQ(test_base16.encode(uinteger_t(\"0000000f\", 16)), \"f\");\n+\t// EXPECT_EQ(test_base16.encode(uinteger_t(\"000fff\", 16)), \"0fff\"); // ->>\n+\tEXPECT_EQ(test_base16.encode(uinteger_t(\"000fff\", 16)), \"fff\");\n+\tEXPECT_EQ(test_base16.encode(uinteger_t(\"ffff\", 16)), \"ffff\");\n+\t// EXPECT_EQ(test_base58.encode(uinteger_t(\"\", 16)), \"\"); // ->>\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"\", 16)), \"1\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"61\", 16)), \"2g\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"626262\", 16)), \"a3gV\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"636363\", 16)), \"aPEr\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"73696d706c792061206c6f6e6720737472696e67\", 16)), \"2cFupjhnEsSn59qHXstmK2ffpLv2\");\n+\t// EXPECT_EQ(test_base58.encode(uinteger_t(\"00eb15231dfceb60925886b67d065299925915aeb172c06647\", 16)), \"1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L\"); // ->>\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"00eb15231dfceb60925886b67d065299925915aeb172c06647\", 16)), \"NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"516b6fcd0f\", 16)), \"ABnLTmg\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"bf4f89001e670274dd\", 16)), \"3SEo3LWLoPntC\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"572e4794\", 16)), \"3EFU7m\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ecac89cad93923c02321\", 16)), \"EJDM8drfXA6uyA\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"10c8511e\", 16)), \"Rt5zm\");\n+\t// EXPECT_EQ(test_base58.encode(uinteger_t(\"00000000000000000000\", 16)), \"1111111111\"); // ->>\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"00000000000000000000\", 16)), \"1\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"801184cd2cdd640ca42cfc3a091c51d549b2f016d454b2774019c2b2d2e08529fd206ec97e\", 16)), \"5Hx15HFGyep2CfPxsJKe2fXJsCVn5DEiyoeGGF6JZjGbTRnqfiD\");\n+\t// EXPECT_EQ(test_base58.encode(uinteger_t(\"003c176e659bea0f29a3e9bf7880c112b1b31b4dc826268187\", 16)), \"16UjcYNBG9GTK4uq2f7yYEbuifqCzoLMGS\"); // ->>\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"003c176e659bea0f29a3e9bf7880c112b1b31b4dc826268187\", 16)), \"6UjcYNBG9GTK4uq2f7yYEbuifqCzoLMGS\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ffffffffffffffffffff\", 16)), \"FPBt6CHo3fovdL\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ffffffffffffffffffffffffff\", 16)), \"NKioeUVktgzXLJ1B3t\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ffffffffffffffffffffffffffffffff\", 16)), \"YcVfxkQb6JRzqk5kF2tNLv\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"fb6f9ac3\", 16)), \"11111011011011111001101011000011\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"179eea7a\", 16)), \"10111100111101110101001111010\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"6db825db\", 16)), \"1101101101110000010010111011011\");\n+\tEXPECT_EQ(test_base2.encode(uinteger_t(\"93976aa7\", 16)), \"10010011100101110110101010100111\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ef41b9ce7e830af7\", 16)), \"h26E62FyLQN\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"606cbc791036d2e9\", 16)), \"H8Sa62HVULG\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"bdcb0ea69c2c8ec8\", 16)), \"YkESUPpnfoD\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"1a2358ba67fb71d5\", 16)), \"5NaBN89ajtQ\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"e6173f0f4d5fb5d7\", 16)), \"fVAoezT1ZkS\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"91c81cbfdd58bbd2\", 16)), \"RPGNSU3bqTX\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"329e0bf0e388dbfe\", 16)), \"9U41ZkwwysT\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"30b10393210fa65b\", 16)), \"99NMW3WHjjY\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ab3bdd18e3623654\", 16)), \"VeBbqBb4rCT\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"fe29d1751ec4af8a\", 16)), \"jWhmYLN9dUm\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"c1273ab5488769807d\", 16)), \"3Tbh4kL3WKW6g\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6c7907904de934f852\", 16)), \"2P5jNYhfpTJxy\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"05f0be055db47a0dc9\", 16)), \"5PN768Kr5oEp\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"3511e6206829b35b12\", 16)), \"gBREojGaJ6DF\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"d1c7c2ddc4a459d503\", 16)), \"3fsekq5Esq2KC\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"1f88efd17ab073e9a1\", 16)), \"QHJbmW9ZY7jn\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"0f45dadf4e64c5d5c2\", 16)), \"CGyVUMmCKLRf\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"de1e5c5f718bb7fafa\", 16)), \"3pyy8U7w3KUa5\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"123190b93e9a49a46c\", 16)), \"ES3DeFrG1zbd\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"8bee94a543e7242e5a\", 16)), \"2nJnuWyLpGf6y\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"9fd5f2285362f5cfd834\", 16)), \"9yqFhqeewcW3pF\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6987bac63ad23828bb31\", 16)), \"6vskE5Y1LhS3U4\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"19d4a0f9d459cc2a08b0\", 16)), \"2TAsHPuaLhh5Aw\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"a1e47ffdbea5a807ab26\", 16)), \"A6XzPgSUJDf1W5\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"35c231e5b3a86a9b83db\", 16)), \"42B8reRwPAAoAa\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"b2351012a48b8347c351\", 16)), \"B1hPyomGx4Vhqa\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"71d402694dd9517ea653\", 16)), \"7Pv2SyAQx2Upu8\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"55227c0ec7955c2bd6e8\", 16)), \"5nR64BkskyjHMq\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"17b3d8ee7907c1be34df\", 16)), \"2LEg7TxosoxTGS\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"7e7bba7b68bb8e95827f\", 16)), \"879o2ATGnmYyAW\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"db9c13f5ba7654b01407fb\", 16)), \"wTYfxjDVbiks874\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6186449d20f5fd1e6c4393\", 16)), \"RBeiWhzZNL6VtMG\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"5248751cebf4ad1c1a83c3\", 16)), \"MQSVNnc8ehFCqtW\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"32090ef18cd479fc376a74\", 16)), \"DQdu351ExDaeYeX\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"7cfa5d6ed1e467d986c426\", 16)), \"XzW67T5qfEnFcaZ\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"9d8707723c7ede51103b6d\", 16)), \"g4eTCg6QJnB1UU4\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6f4d1e392d6a9b4ed8b223\", 16)), \"Ubo7kZY5aDpAJp2\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"38057d98797cd39f80a0c9\", 16)), \"EtjQ2feamJvuqse\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"de7e59903177e20880e915\", 16)), \"xB2N7yRBnDYEoT2\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"b2ea24a28bc4a60b5c4b8d\", 16)), \"mNFMpJ2P3TGYqhv\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"cf84938958589b6ffba6114d\", 16)), \"4v8ZbsGh2ePz5sipt\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"dee13be7b8d8a08c94a3c02a\", 16)), \"5CwmE9jQqwtHkTF45\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"14cb9c6b3f8cd2e02710f569\", 16)), \"Pm85JHVAAdeUdxtp\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ca3f2d558266bdcc44c79cb5\", 16)), \"4pMwomBAQHuUnoLUC\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"c031215be44cbad745f38982\", 16)), \"4dMeTrcxiVw9RWvj3\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"1435ab1dbc403111946270a5\", 16)), \"P7wX3sCWNrbqhBEC\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"d8c6e4d775e7a66a0d0f9f41\", 16)), \"56GLoRDGWGuGJJwPN\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"dcee35e74f0fd74176fce2f4\", 16)), \"5Ap1zyuYiJJFwWcMR\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"bfcc0ca4b4855d1cf8993fc0\", 16)), \"4cvafQW4PEhARKv9D\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"e02a3ac25ece7b54584b670a\", 16)), \"5EMM28xkpxZ1kkVUM\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"fe4d938fc3719f064cabb4bfff\", 16)), \"NBXKkbHwrAsiWTLAk6\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"9289cb4f6b15c57e6086b87ea5\", 16)), \"DCvDpjEXEbHjZqskKv\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"fc266f35626b3612bfe978537b\", 16)), \"N186PVoBWrNre35BGE\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"33ff08c06d92502bf258c07166\", 16)), \"5LC4SoW6jmTtbkbePw\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6a81cac1f3666bc59dc67b1c3c\", 16)), \"9sXgUySUzwiqDU5WHy\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"9dfb8e7e744c544c0f323ea729\", 16)), \"EACsmGmkgcwsrPFzLg\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"1e7a1e284f70838b38442b682b\", 16)), \"3YEVk9bE7rw5qExMkv\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"2a862ad57901a8235f5dc74eaf\", 16)), \"4YS259nuTLfeXa5Wuc\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"74c82096baef21f9d3089e5462\", 16)), \"AjAcKEhUfrqm8smvM7\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"7a3edbc23d7b600263920261cc\", 16)), \"BBZXyRgey5S5DDZkcK\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"20435664c357d25a9c8df751cf4f\", 16)), \"CrwNL6Fbv4pbRx1zd9g\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"51a7aa87cf5cb1c12d045ec3422d\", 16)), \"X27NHGgKXmGzzQvDtpC\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"344d2e116aa26f1062a2cb6ebbef\", 16)), \"LEDLDvL1Hg4qt1efVXt\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6941add7be4c0b5c7163e4928f8e\", 16)), \"fhMyN6gwoxE3uYraVzV\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"10938fcbb7c4ab991649734a14bf\", 16)), \"76TPrSDxzGQfSzMu974\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"eafe04d944ba504e9af9117b07de\", 16)), \"2VPgov563ryfe4L2Bj6M\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"58d0aeed4d35da20b6f052127edf\", 16)), \"ZenZhXF9YwP8nQvNtNz\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"d734984e2f5aecf25f7a3e353f8a\", 16)), \"2N7n3jFsTdyN49Faoq6h\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"57d873fdb405b7daf4bafa62068a\", 16)), \"ZJ7NwoP4wHvwyZg3Wjs\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"bda4ec7b40d0d65ca95dec4c4d3b\", 16)), \"2CijxjsNyvqTwPCfDcpA\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"826c4abdceb1b91f0d4ad665f86d2e\", 16)), \"4edfvuDQu9KzVxLuXHfMo\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"e7ecb35d07e65b960cb10574a4f51a\", 16)), \"7VLRYdB4cToipp2J2p3v9\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"4f2d72ead87b31d6869fba39eac6dc\", 16)), \"3DUjqJRcfdWhpsrLrGcQs\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"8b4f5788d60030950d5dfbf94c585d\", 16)), \"4u44JSRH5jP5X39YhPsmE\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"ee4c0a0025d1a74ace9fe349355cc5\", 16)), \"7fgACjABRQUGUEpN6VBBA\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"58ac05b9a0b4b66083ff1d489b8d84\", 16)), \"3UtJPyTwGXapcxHx8Rom5\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"1aa35c05e1132e8e049aafaef035d8\", 16)), \"kE2eSU7gM2619pT82iGP\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"771b0c28608484562a292e5d5d2b30\", 16)), \"4LGYeWhyfrjUByibUqdVR\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"78ff9a0e56f9e88dc1cd654b40d019\", 16)), \"4PLggs66qAdbmZgkaPihe\");\n+\tEXPECT_EQ(test_base58.encode(uinteger_t(\"6d691bdd736346aa5a0a95b373b2ab\", 16)), \"44Y6qTgSvRMkdqpQ5ufkN\");\n+}\ndiff --git a/tests/queries/0_stateless/02337_base58.reference b/tests/queries/0_stateless/02337_base58.reference\nnew file mode 100644\nindex 000000000000..f4a2c95304b6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02337_base58.reference\n@@ -0,0 +1,47 @@\n+32YCBjgZhV4AdCWHaCDNu\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+2m\n+8o8\n+bQbp\n+3csAg9\n+CZJRhmz\n+t1Zv2yaZ\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\ndiff --git a/tests/queries/0_stateless/02337_base58.sql b/tests/queries/0_stateless/02337_base58.sql\nnew file mode 100644\nindex 000000000000..34da1da4c86a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02337_base58.sql\n@@ -0,0 +1,17 @@\n+-- Tags: no-fasttest\n+\n+SET send_logs_level = 'fatal';\n+\n+SELECT base58Encode('Hold my beer...');\n+SELECT base58Encode('Hold my beer...', ''); -- { serverError 44 }\n+SELECT base58Encode('Hold my beer...', 'gmp', 'third'); -- { serverError 36 }\n+\n+SELECT base58Decode(encoded, 'gmp') FROM (SELECT base58Encode(val, 'gmp') as encoded FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+SELECT base58Decode(encoded, 'ripple') FROM (SELECT base58Encode(val, 'ripple') as encoded FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+SELECT base58Decode(encoded, 'flickr') FROM (SELECT base58Encode(val, 'flickr') as encoded FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+SELECT base58Decode(encoded, 'bitcoin') FROM (SELECT base58Encode(val, 'bitcoin') as encoded FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+\n+SELECT base58Encode(val) FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar']) val);\n+SELECT base58Decode(val) FROM (select arrayJoin(['', '2m', '8o8', 'bQbp', '3csAg9', 'CZJRhmz', 't1Zv2yaZ']) val);\n+\n+SELECT base58Decode('Why_not?'); -- { serverError 36 }\n",
  "problem_statement": "base58 encode / decode\nThere is like 4 different formats:\r\n\r\nbitcion\r\ngmp\r\nripple\r\nflickr\r\n\n",
  "hints_text": "",
  "created_at": "2022-06-16T20:55:19Z"
}