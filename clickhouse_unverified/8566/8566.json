{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8566,
  "instance_id": "ClickHouse__ClickHouse-8566",
  "issue_numbers": [
    "8317"
  ],
  "base_commit": "f53aa30e8a14f63951d624d40a8c5947206cf547",
  "patch": "diff --git a/dbms/src/Interpreters/BloomFilterHash.h b/dbms/src/Interpreters/BloomFilterHash.h\nindex 38bedb213cdc..e74114337812 100644\n--- a/dbms/src/Interpreters/BloomFilterHash.h\n+++ b/dbms/src/Interpreters/BloomFilterHash.h\n@@ -34,45 +34,64 @@ struct BloomFilterHash\n         15033938188484401405ULL, 18286745649494826751ULL, 6852245486148412312ULL, 8886056245089344681ULL, 10151472371158292780ULL\n     };\n \n-    static ColumnPtr hashWithField(const IDataType * data_type, const Field & field)\n+    template <typename FieldGetType, typename FieldType>\n+    static UInt64 getNumberTypeHash(const Field & field)\n     {\n-        WhichDataType which(data_type);\n-        UInt64 hash = 0;\n-        bool unexpected_type = false;\n+        /// For negative, we should convert the type to make sure the symbol is in right place\n+        return field.isNull() ? intHash64(0) : intHash64(ext::bit_cast<UInt64>(FieldType(field.safeGet<FieldGetType>())));\n+    }\n \n-        if (field.isNull())\n+    static UInt64 getStringTypeHash(const Field & field)\n+    {\n+        if (!field.isNull())\n         {\n-            if (which.isInt() || which.isUInt() || which.isEnum() || which.isDateOrDateTime() || which.isFloat())\n-                hash = intHash64(0);\n-            else if (which.isString())\n-                hash = CityHash_v1_0_2::CityHash64(\"\", 0);\n-            else if (which.isFixedString())\n-            {\n-                const auto * fixed_string_type = typeid_cast<const DataTypeFixedString *>(data_type);\n-                const std::vector<char> value(fixed_string_type->getN(), 0);\n-                hash = CityHash_v1_0_2::CityHash64(value.data(), value.size());\n-            }\n-            else\n-                unexpected_type = true;\n+            const auto & value = field.safeGet<String>();\n+            return CityHash_v1_0_2::CityHash64(value.data(), value.size());\n         }\n-        else if (which.isUInt() || which.isDateOrDateTime())\n-            hash = intHash64(field.safeGet<UInt64>());\n-        else if (which.isInt() || which.isEnum())\n-            hash = intHash64(ext::bit_cast<UInt64>(field.safeGet<Int64>()));\n-        else if (which.isFloat32() || which.isFloat64())\n-            hash = intHash64(ext::bit_cast<UInt64>(field.safeGet<Float64>()));\n-        else if (which.isString() || which.isFixedString())\n+\n+        return CityHash_v1_0_2::CityHash64(\"\", 0);\n+    }\n+\n+    static UInt64 getFixedStringTypeHash(const Field & field, const IDataType * type)\n+    {\n+        if (!field.isNull())\n         {\n             const auto & value = field.safeGet<String>();\n-            hash = CityHash_v1_0_2::CityHash64(value.data(), value.size());\n+            return CityHash_v1_0_2::CityHash64(value.data(), value.size());\n         }\n-        else\n-            unexpected_type = true;\n \n-        if (unexpected_type)\n-            throw Exception(\"Unexpected type \" + data_type->getName() + \" of bloom filter index.\", ErrorCodes::BAD_ARGUMENTS);\n+        const auto * fixed_string_type = typeid_cast<const DataTypeFixedString *>(type);\n+        const std::vector<char> value(fixed_string_type->getN(), 0);\n+        return CityHash_v1_0_2::CityHash64(value.data(), value.size());\n+    }\n+\n+    static ColumnPtr hashWithField(const IDataType * data_type, const Field & field)\n+    {\n+        const auto & build_hash_column = [&](const UInt64 & hash) -> ColumnPtr\n+        {\n+            return ColumnConst::create(ColumnUInt64::create(1, hash), 1);\n+        };\n+\n \n-        return ColumnConst::create(ColumnUInt64::create(1, hash), 1);\n+        WhichDataType which(data_type);\n+\n+        if (which.isUInt8()) return build_hash_column(getNumberTypeHash<UInt64, UInt8>(field));\n+        else if (which.isUInt16()) return build_hash_column(getNumberTypeHash<UInt64, UInt16>(field));\n+        else if (which.isUInt32()) return build_hash_column(getNumberTypeHash<UInt64, UInt32>(field));\n+        else if (which.isUInt64()) return build_hash_column(getNumberTypeHash<UInt64, UInt64>(field));\n+        else if (which.isInt8()) return build_hash_column(getNumberTypeHash<Int64, Int8>(field));\n+        else if (which.isInt16()) return build_hash_column(getNumberTypeHash<Int64, Int16>(field));\n+        else if (which.isInt32()) return build_hash_column(getNumberTypeHash<Int64, Int32>(field));\n+        else if (which.isInt64()) return build_hash_column(getNumberTypeHash<Int64, Int64>(field));\n+        else if (which.isEnum8()) return build_hash_column(getNumberTypeHash<Int64, Int8>(field));\n+        else if (which.isEnum16()) return build_hash_column(getNumberTypeHash<Int64, Int16>(field));\n+        else if (which.isDate()) return build_hash_column(getNumberTypeHash<UInt64, UInt16>(field));\n+        else if (which.isDateTime()) return build_hash_column(getNumberTypeHash<UInt64, UInt32>(field));\n+        else if (which.isFloat32()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));\n+        else if (which.isFloat64()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));\n+        else if (which.isString()) return build_hash_column(getStringTypeHash(field));\n+        else if (which.isFixedString()) return build_hash_column(getFixedStringTypeHash(field, data_type));\n+        else throw Exception(\"Unexpected type \" + data_type->getName() + \" of bloom filter index.\", ErrorCodes::BAD_ARGUMENTS);\n     }\n \n     static ColumnPtr hashWithColumn(const DataTypePtr & data_type, const ColumnPtr & column, size_t pos, size_t limit)\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.reference b/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.reference\nnew file mode 100644\nindex 000000000000..20c726bd2803\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.reference\n@@ -0,0 +1,4 @@\n+-1\t-1\t-1\t-1\n+-1\t-1\t-1\t-1\n+-1\t-1\t-1\t-1\n+-1\t-1\t-1\t-1\ndiff --git a/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.sql b/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.sql\nnew file mode 100644\nindex 000000000000..271754b848ff\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01056_negative_with_bloom_filter.sql\n@@ -0,0 +1,14 @@\n+SET allow_experimental_data_skipping_indices = 1;\n+\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (`int8` Int8, `int16` Int16, `int32` Int32, `int64` Int64, INDEX idx (`int8`, `int16`, `int32`, `int64`) TYPE bloom_filter(0.01) GRANULARITY 8192 ) ENGINE = MergeTree() ORDER BY `int8`;\n+\n+INSERT INTO test VALUES (-1, -1, -1, -1);\n+\n+SELECT * FROM test WHERE `int8` = -1;\n+SELECT * FROM test WHERE `int16` = -1;\n+SELECT * FROM test WHERE `int32` = -1;\n+SELECT * FROM test WHERE `int64` = -1;\n+\n+DROP TABLE IF EXISTS test;\n",
  "problem_statement": "BloomFilter index couldn't find negative integers.\nBloomFilter index is very fast and awesome feature of ClickHouse. \r\nBut, there was an unexpected behavior.\r\nIt seems not to handle negative integers.\r\nIf you want to reproduce this bug, follow below queries.\r\n\r\n**Create a test table and insert a negative integer**\r\n```SQL\r\nSET allow_experimental_data_skipping_indices = 1;\r\n\r\nCREATE TABLE bf_int\r\n(\r\n    `id` int,\r\n    `i` int,\r\n    INDEX idx i TYPE bloom_filter(0.01) GRANULARITY 8192\r\n)\r\nENGINE = MergeTree()\r\nORDER BY id;\r\n\r\nINSERT INTO bf_int VALUES (1, -1);\r\n```\r\n\r\n**Select with where statement for the negative integer**\r\n```SQL\r\nSELECT *\r\nFROM bf_int\r\nWHERE i = -1\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n\r\n```\r\n\r\nThe result for the `select` returned 0 row.\r\n\r\nBut, there must had been one row...\r\n\r\n```SQL\r\nSELECT *\r\nFROM bf_int\r\nFORMAT TSV\r\n\r\n1       -1\r\n\r\n1 rows in set. Elapsed: 0.002 sec. \r\n```\n",
  "hints_text": "",
  "created_at": "2020-01-08T05:02:02Z"
}