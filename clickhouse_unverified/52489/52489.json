{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52489,
  "instance_id": "ClickHouse__ClickHouse-52489",
  "issue_numbers": [
    "52228"
  ],
  "base_commit": "e8b271e8784546a9d73bbdd17a9386dc968c474e",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex ba71a8ae3a7a..30085fb8dd49 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -340,3 +340,6 @@\n [submodule \"contrib/c-ares\"]\n \tpath = contrib/c-ares\n \turl = https://github.com/c-ares/c-ares.git\n+[submodule \"contrib/incbin\"]\n+\tpath = contrib/incbin\n+\turl = https://github.com/graphitemaster/incbin.git\ndiff --git a/cmake/embed_binary.cmake b/cmake/embed_binary.cmake\ndeleted file mode 100644\nindex e5428c249398..000000000000\n--- a/cmake/embed_binary.cmake\n+++ /dev/null\n@@ -1,58 +0,0 @@\n-# Embed a set of resource files into a resulting object file.\n-#\n-# Signature: `clickhouse_embed_binaries(TARGET <target> RESOURCE_DIR <dir> RESOURCES <resource> ...)\n-#\n-# This will generate a static library target named `<target>`, which contains the contents of\n-# each `<resource>` file. The files should be located in `<dir>`. <dir> defaults to\n-# ${CMAKE_CURRENT_SOURCE_DIR}, and the resources may not be empty.\n-#\n-# Each resource will result in three symbols in the final archive, based on the name `<resource>`.\n-# These are:\n-#   1. `_binary_<name>_start`: Points to the start of the binary data from `<resource>`.\n-#   2. `_binary_<name>_end`: Points to the end of the binary data from `<resource>`.\n-#   2. `_binary_<name>_size`: Points to the size of the binary data from `<resource>`.\n-#\n-# `<name>` is a normalized name derived from `<resource>`, by replacing the characters \"./-\" with\n-# the character \"_\", and the character \"+\" with \"_PLUS_\". This scheme is similar to those generated\n-# by `ld -r -b binary`, and matches the expectations in `./base/common/getResource.cpp`.\n-macro(clickhouse_embed_binaries)\n-    set(one_value_args TARGET RESOURCE_DIR)\n-    set(resources RESOURCES)\n-    cmake_parse_arguments(EMBED \"\" \"${one_value_args}\" ${resources} ${ARGN})\n-\n-    if (NOT DEFINED EMBED_TARGET)\n-        message(FATAL_ERROR \"A target name must be provided for embedding binary resources into\")\n-    endif()\n-\n-    if (NOT DEFINED EMBED_RESOURCE_DIR)\n-        set(EMBED_RESOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}\")\n-    endif()\n-\n-    list(LENGTH EMBED_RESOURCES N_RESOURCES)\n-    if (N_RESOURCES LESS 1)\n-        message(FATAL_ERROR \"The list of binary resources to embed may not be empty\")\n-    endif()\n-\n-    add_library(\"${EMBED_TARGET}\" STATIC)\n-    set_target_properties(\"${EMBED_TARGET}\" PROPERTIES LINKER_LANGUAGE C)\n-\n-    set(EMBED_TEMPLATE_FILE \"${PROJECT_SOURCE_DIR}/programs/embed_binary.S.in\")\n-\n-    foreach(RESOURCE_FILE ${EMBED_RESOURCES})\n-        set(ASSEMBLY_FILE_NAME \"${RESOURCE_FILE}.S\")\n-        set(BINARY_FILE_NAME \"${RESOURCE_FILE}\")\n-\n-        # Normalize the name of the resource.\n-        string(REGEX REPLACE \"[\\./-]\" \"_\" SYMBOL_NAME \"${RESOURCE_FILE}\") # - must be last in regex\n-        string(REPLACE \"+\" \"_PLUS_\" SYMBOL_NAME \"${SYMBOL_NAME}\")\n-\n-        # Generate the configured assembly file in the output directory.\n-        configure_file(\"${EMBED_TEMPLATE_FILE}\" \"${CMAKE_CURRENT_BINARY_DIR}/${ASSEMBLY_FILE_NAME}\" @ONLY)\n-\n-        # Set the include directory for relative paths specified for `.incbin` directive.\n-        set_property(SOURCE \"${CMAKE_CURRENT_BINARY_DIR}/${ASSEMBLY_FILE_NAME}\" APPEND PROPERTY INCLUDE_DIRECTORIES \"${EMBED_RESOURCE_DIR}\")\n-\n-        target_sources(\"${EMBED_TARGET}\" PRIVATE \"${CMAKE_CURRENT_BINARY_DIR}/${ASSEMBLY_FILE_NAME}\")\n-        set_target_properties(\"${EMBED_TARGET}\" PROPERTIES OBJECT_DEPENDS \"${RESOURCE_FILE}\")\n-    endforeach()\n-endmacro()\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 0f68c0cbc7c7..fdf6e60e58fd 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -164,13 +164,13 @@ add_contrib (libpq-cmake libpq)\n add_contrib (nuraft-cmake NuRaft)\n add_contrib (fast_float-cmake fast_float)\n add_contrib (datasketches-cpp-cmake datasketches-cpp)\n+add_contrib (incbin-cmake incbin)\n \n option(ENABLE_NLP \"Enable NLP functions support\" ${ENABLE_LIBRARIES})\n if (ENABLE_NLP)\n     add_contrib (libstemmer-c-cmake libstemmer_c)\n     add_contrib (wordnet-blast-cmake wordnet-blast)\n     add_contrib (lemmagen-c-cmake lemmagen-c)\n-    add_contrib (nlp-data-cmake nlp-data)\n     add_contrib (cld2-cmake cld2)\n endif()\n \ndiff --git a/contrib/cctz-cmake/CMakeLists.txt b/contrib/cctz-cmake/CMakeLists.txt\nindex 10070fbd9494..7161f743de15 100644\n--- a/contrib/cctz-cmake/CMakeLists.txt\n+++ b/contrib/cctz-cmake/CMakeLists.txt\n@@ -1,4 +1,3 @@\n-include(${ClickHouse_SOURCE_DIR}/cmake/embed_binary.cmake)\n set(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/cctz\")\n \n set (SRCS\n@@ -23,12 +22,10 @@ if (OS_FREEBSD)\n endif ()\n \n # Related to time_zones table:\n-# StorageSystemTimeZones.generated.cpp is autogenerated each time during a build\n-# data in this file will be used to populate the system.time_zones table, this is specific to OS_LINUX\n-# as the library that's built using embedded tzdata is also specific to OS_LINUX\n-set(SYSTEM_STORAGE_TZ_FILE \"${PROJECT_BINARY_DIR}/src/Storages/System/StorageSystemTimeZones.generated.cpp\")\n+# TimeZones.generated.cpp is autogenerated each time during a build\n+set(TIMEZONES_FILE \"${CMAKE_CURRENT_BINARY_DIR}/TimeZones.generated.cpp\")\n # remove existing copies so that its generated fresh on each build.\n-file(REMOVE ${SYSTEM_STORAGE_TZ_FILE})\n+file(REMOVE ${TIMEZONES_FILE})\n \n # get the list of timezones from tzdata shipped with cctz\n set(TZDIR \"${LIBRARY_DIR}/testdata/zoneinfo\")\n@@ -36,28 +33,44 @@ file(STRINGS \"${LIBRARY_DIR}/testdata/version\" TZDATA_VERSION)\n set_property(GLOBAL PROPERTY TZDATA_VERSION_PROP \"${TZDATA_VERSION}\")\n message(STATUS \"Packaging with tzdata version: ${TZDATA_VERSION}\")\n \n-set(TIMEZONE_RESOURCE_FILES)\n-\n # each file in that dir (except of tab and localtime) store the info about timezone\n execute_process(COMMAND\n     bash -c \"cd ${TZDIR} && find * -type f -and ! -name '*.tab' -and ! -name 'localtime' | LC_ALL=C sort | paste -sd ';' -\"\n     OUTPUT_STRIP_TRAILING_WHITESPACE\n     OUTPUT_VARIABLE TIMEZONES)\n \n-file(APPEND ${SYSTEM_STORAGE_TZ_FILE} \"// autogenerated by ClickHouse/contrib/cctz-cmake/CMakeLists.txt\\n\")\n-file(APPEND ${SYSTEM_STORAGE_TZ_FILE} \"const char * auto_time_zones[] {\\n\" )\n+file(APPEND ${TIMEZONES_FILE} \"// autogenerated by ClickHouse/contrib/cctz-cmake/CMakeLists.txt\\n\")\n+file(APPEND ${TIMEZONES_FILE} \"#include <incbin.h>\\n\")\n \n+set (COUNTER 1)\n foreach(TIMEZONE ${TIMEZONES})\n-    file(APPEND ${SYSTEM_STORAGE_TZ_FILE} \"    \\\"${TIMEZONE}\\\",\\n\")\n-    list(APPEND TIMEZONE_RESOURCE_FILES \"${TIMEZONE}\")\n+    file(APPEND ${TIMEZONES_FILE} \"INCBIN(resource_timezone${COUNTER}, \\\"${TZDIR}/${TIMEZONE}\\\");\\n\")\n+    MATH(EXPR COUNTER \"${COUNTER}+1\")\n endforeach(TIMEZONE)\n-file(APPEND ${SYSTEM_STORAGE_TZ_FILE} \"    nullptr};\\n\")\n-clickhouse_embed_binaries(\n-    TARGET tzdata\n-    RESOURCE_DIR \"${TZDIR}\"\n-    RESOURCES ${TIMEZONE_RESOURCE_FILES}\n-)\n-add_dependencies(_cctz tzdata)\n-target_link_libraries(_cctz INTERFACE \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:tzdata> -Wl,${NO_WHOLE_ARCHIVE}\")\n+\n+file(APPEND ${TIMEZONES_FILE} \"const char * auto_time_zones[] {\\n\" )\n+\n+foreach(TIMEZONE ${TIMEZONES})\n+    file(APPEND ${TIMEZONES_FILE} \"    \\\"${TIMEZONE}\\\",\\n\")\n+    MATH(EXPR COUNTER \"${COUNTER}+1\")\n+endforeach(TIMEZONE)\n+\n+file(APPEND ${TIMEZONES_FILE} \"    nullptr\\n};\\n\\n\")\n+\n+file(APPEND ${TIMEZONES_FILE} \"#include <string_view>\\n\\n\")\n+file(APPEND ${TIMEZONES_FILE} \"std::string_view getTimeZone(const char * name)\\n{\\n\" )\n+\n+set (COUNTER 1)\n+foreach(TIMEZONE ${TIMEZONES})\n+    file(APPEND ${TIMEZONES_FILE} \"    if (std::string_view(\\\"${TIMEZONE}\\\") == name) return { reinterpret_cast<const char *>(gresource_timezone${COUNTER}Data), gresource_timezone${COUNTER}Size };\\n\")\n+    MATH(EXPR COUNTER \"${COUNTER}+1\")\n+endforeach(TIMEZONE)\n+\n+file(APPEND ${TIMEZONES_FILE} \"    return {};\\n\")\n+file(APPEND ${TIMEZONES_FILE} \"}\\n\")\n+\n+add_library (tzdata ${TIMEZONES_FILE})\n+target_link_libraries(tzdata ch_contrib::incbin)\n+target_link_libraries(_cctz tzdata)\n \n add_library(ch_contrib::cctz ALIAS _cctz)\ndiff --git a/contrib/incbin b/contrib/incbin\nnew file mode 160000\nindex 000000000000..6e576cae5ab5\n--- /dev/null\n+++ b/contrib/incbin\n@@ -0,0 +1,1 @@\n+Subproject commit 6e576cae5ab5810f25e2631f2e0b80cbe7dc8cbf\ndiff --git a/contrib/incbin-cmake/CMakeLists.txt b/contrib/incbin-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..5778cf83c221\n--- /dev/null\n+++ b/contrib/incbin-cmake/CMakeLists.txt\n@@ -0,0 +1,8 @@\n+set(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/incbin\")\n+add_library(_incbin INTERFACE)\n+target_include_directories(_incbin SYSTEM INTERFACE ${LIBRARY_DIR})\n+add_library(ch_contrib::incbin ALIAS _incbin)\n+\n+# Warning \"incbin is incompatible with bitcode. Using the library will break upload to App Store if you have bitcode enabled.\n+# Add `#define INCBIN_SILENCE_BITCODE_WARNING` before including this header to silence this warning.\"\n+target_compile_definitions(_incbin INTERFACE INCBIN_SILENCE_BITCODE_WARNING)\ndiff --git a/contrib/nlp-data-cmake/CMakeLists.txt b/contrib/nlp-data-cmake/CMakeLists.txt\ndeleted file mode 100644\nindex 5380269c4799..000000000000\n--- a/contrib/nlp-data-cmake/CMakeLists.txt\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-include(${ClickHouse_SOURCE_DIR}/cmake/embed_binary.cmake)\n-\n-set(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/nlp-data\")\n-\n-add_library (_nlp_data INTERFACE)\n-\n-clickhouse_embed_binaries(\n-    TARGET nlp_dictionaries\n-    RESOURCE_DIR \"${LIBRARY_DIR}\"\n-    RESOURCES charset.zst tonality_ru.zst programming.zst\n-)\n-\n-add_dependencies(_nlp_data nlp_dictionaries)\n-target_link_libraries(_nlp_data INTERFACE \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:nlp_dictionaries> -Wl,${NO_WHOLE_ARCHIVE}\")\n-add_library(ch_contrib::nlp_data ALIAS _nlp_data)\ndiff --git a/programs/install/Install.cpp b/programs/install/Install.cpp\nindex d83e189f7efb..d7086c95bebf 100644\n--- a/programs/install/Install.cpp\n+++ b/programs/install/Install.cpp\n@@ -20,10 +20,7 @@\n #include <Common/formatReadable.h>\n #include <Common/Config/ConfigProcessor.h>\n #include <Common/OpenSSLHelpers.h>\n-#include <base/hex.h>\n-#include <Common/getResource.h>\n #include <base/sleep.h>\n-#include <IO/ReadBufferFromFileDescriptor.h>\n #include <IO/WriteBufferFromFileDescriptor.h>\n #include <IO/ReadBufferFromFile.h>\n #include <IO/WriteBufferFromFile.h>\n@@ -35,6 +32,14 @@\n \n #include <Poco/Util/XMLConfiguration.h>\n \n+#include <incbin.h>\n+\n+#include \"config.h\"\n+\n+/// Embedded configuration files used inside the install program\n+INCBIN(resource_config_xml, SOURCE_DIR \"/programs/server/config.xml\");\n+INCBIN(resource_users_xml, SOURCE_DIR \"/programs/server/users.xml\");\n+\n \n /** This tool can be used to install ClickHouse without a deb/rpm/tgz package, having only \"clickhouse\" binary.\n   * It also allows to avoid dependency on systemd, upstart, SysV init.\n@@ -560,7 +565,7 @@ int mainEntryClickHouseInstall(int argc, char ** argv)\n \n         if (!fs::exists(main_config_file))\n         {\n-            std::string_view main_config_content = getResource(\"config.xml\");\n+            std::string_view main_config_content(reinterpret_cast<const char *>(gresource_config_xmlData), gresource_config_xmlSize);\n             if (main_config_content.empty())\n             {\n                 fmt::print(\"There is no default config.xml, you have to download it and place to {}.\\n\", main_config_file.string());\n@@ -672,7 +677,7 @@ int mainEntryClickHouseInstall(int argc, char ** argv)\n \n         if (!fs::exists(users_config_file))\n         {\n-            std::string_view users_config_content = getResource(\"users.xml\");\n+            std::string_view users_config_content(reinterpret_cast<const char *>(gresource_users_xmlData), gresource_users_xmlSize);\n             if (users_config_content.empty())\n             {\n                 fmt::print(\"There is no default users.xml, you have to download it and place to {}.\\n\", users_config_file.string());\ndiff --git a/programs/keeper/CMakeLists.txt b/programs/keeper/CMakeLists.txt\nindex 940e68485978..317e35959aa6 100644\n--- a/programs/keeper/CMakeLists.txt\n+++ b/programs/keeper/CMakeLists.txt\n@@ -1,16 +1,3 @@\n-include(${ClickHouse_SOURCE_DIR}/cmake/embed_binary.cmake)\n-\n-if (OS_LINUX)\n-    set (LINK_RESOURCE_LIB INTERFACE \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:clickhouse_keeper_configs> -Wl,${NO_WHOLE_ARCHIVE}\")\n-    # for some reason INTERFACE linkage doesn't work for standalone binary\n-    set (LINK_RESOURCE_LIB_STANDALONE_KEEPER \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:clickhouse_keeper_configs> -Wl,${NO_WHOLE_ARCHIVE}\")\n-endif ()\n-\n-clickhouse_embed_binaries(\n-    TARGET clickhouse_keeper_configs\n-    RESOURCES keeper_config.xml keeper_embedded.xml\n-)\n-\n set(CLICKHOUSE_KEEPER_SOURCES\n     Keeper.cpp\n )\n@@ -29,7 +16,6 @@ set (CLICKHOUSE_KEEPER_LINK\n clickhouse_program_add(keeper)\n \n install(FILES keeper_config.xml DESTINATION \"${CLICKHOUSE_ETC_DIR}/clickhouse-keeper\" COMPONENT clickhouse-keeper)\n-add_dependencies(clickhouse-keeper-lib clickhouse_keeper_configs)\n \n if (BUILD_STANDALONE_KEEPER)\n     # Straight list of all required sources\n@@ -215,7 +201,6 @@ if (BUILD_STANDALONE_KEEPER)\n         ${LINK_RESOURCE_LIB_STANDALONE_KEEPER}\n     )\n \n-    add_dependencies(clickhouse-keeper clickhouse_keeper_configs)\n     set_target_properties(clickhouse-keeper PROPERTIES RUNTIME_OUTPUT_DIRECTORY ../)\n \n     if (SPLIT_DEBUG_SYMBOLS)\ndiff --git a/programs/keeper/Keeper.cpp b/programs/keeper/Keeper.cpp\nindex 6034d63a0165..a38467c3369f 100644\n--- a/programs/keeper/Keeper.cpp\n+++ b/programs/keeper/Keeper.cpp\n@@ -457,8 +457,10 @@ try\n     const std::string key_path = config().getString(\"openSSL.server.privateKeyFile\", \"\");\n \n     std::vector<std::string> extra_paths = {include_from_path};\n-    if (!cert_path.empty()) extra_paths.emplace_back(cert_path);\n-    if (!key_path.empty()) extra_paths.emplace_back(key_path);\n+    if (!cert_path.empty())\n+        extra_paths.emplace_back(cert_path);\n+    if (!key_path.empty())\n+        extra_paths.emplace_back(key_path);\n \n     /// ConfigReloader have to strict parameters which are redundant in our case\n     auto main_config_reloader = std::make_unique<ConfigReloader>(\ndiff --git a/programs/server/CMakeLists.txt b/programs/server/CMakeLists.txt\nindex 855973d10e1d..b8241afa1eb5 100644\n--- a/programs/server/CMakeLists.txt\n+++ b/programs/server/CMakeLists.txt\n@@ -1,12 +1,8 @@\n-include(${ClickHouse_SOURCE_DIR}/cmake/embed_binary.cmake)\n-\n set(CLICKHOUSE_SERVER_SOURCES\n     MetricsTransmitter.cpp\n     Server.cpp\n )\n \n-set (LINK_RESOURCE_LIB INTERFACE \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:clickhouse_server_configs> -Wl,${NO_WHOLE_ARCHIVE}\")\n-\n set (CLICKHOUSE_SERVER_LINK\n     PRIVATE\n         clickhouse_aggregate_functions\n@@ -34,9 +30,3 @@ endif()\n clickhouse_program_add(server)\n \n install(FILES config.xml users.xml DESTINATION \"${CLICKHOUSE_ETC_DIR}/clickhouse-server\" COMPONENT clickhouse)\n-\n-clickhouse_embed_binaries(\n-    TARGET clickhouse_server_configs\n-    RESOURCES config.xml users.xml embedded.xml play.html dashboard.html js/uplot.js\n-)\n-add_dependencies(clickhouse-server-lib clickhouse_server_configs)\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 8c0248580bdc..b57521476b34 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -128,6 +128,10 @@\n #   include <azure/storage/common/internal/xml_wrapper.hpp>\n #endif\n \n+#include <incbin.h>\n+/// A minimal file used when the server is run without installation\n+INCBIN(resource_embedded_xml, SOURCE_DIR \"/programs/server/embedded.xml\");\n+\n namespace CurrentMetrics\n {\n     extern const Metric Revision;\n@@ -393,6 +397,7 @@ int Server::run()\n \n void Server::initialize(Poco::Util::Application & self)\n {\n+    ConfigProcessor::registerEmbeddedConfig(\"config.xml\", std::string_view(reinterpret_cast<const char *>(gresource_embedded_xmlData), gresource_embedded_xmlSize));\n     BaseDaemon::initialize(self);\n     logger().information(\"starting up\");\n \n@@ -1106,8 +1111,10 @@ try\n     const std::string key_path = config().getString(\"openSSL.server.privateKeyFile\", \"\");\n \n     std::vector<std::string> extra_paths = {include_from_path};\n-    if (!cert_path.empty()) extra_paths.emplace_back(cert_path);\n-    if (!key_path.empty()) extra_paths.emplace_back(key_path);\n+    if (!cert_path.empty())\n+        extra_paths.emplace_back(cert_path);\n+    if (!key_path.empty())\n+        extra_paths.emplace_back(key_path);\n \n     auto main_config_reloader = std::make_unique<ConfigReloader>(\n         config_path,\ndiff --git a/programs/server/resources.cpp b/programs/server/resources.cpp\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex f870993f0805..975bf9bb6187 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -210,7 +210,7 @@ if (TARGET ch_contrib::jemalloc)\n     target_link_libraries (clickhouse_storages_system PRIVATE ch_contrib::jemalloc)\n endif()\n \n-target_link_libraries (clickhouse_common_io PUBLIC ch_contrib::sparsehash)\n+target_link_libraries (clickhouse_common_io PUBLIC ch_contrib::sparsehash ch_contrib::incbin)\n \n add_subdirectory(Access/Common)\n add_subdirectory(Common/ZooKeeper)\n@@ -561,7 +561,6 @@ if (ENABLE_NLP)\n     dbms_target_link_libraries (PUBLIC ch_contrib::stemmer)\n     dbms_target_link_libraries (PUBLIC ch_contrib::wnb)\n     dbms_target_link_libraries (PUBLIC ch_contrib::lemmagen)\n-    dbms_target_link_libraries (PUBLIC ch_contrib::nlp_data)\n endif()\n \n if (TARGET ch_contrib::ulid)\ndiff --git a/src/Common/CMakeLists.txt b/src/Common/CMakeLists.txt\nindex e527b3dec43c..b83c8431f0a4 100644\n--- a/src/Common/CMakeLists.txt\n+++ b/src/Common/CMakeLists.txt\n@@ -9,5 +9,5 @@ if (ENABLE_EXAMPLES)\n endif()\n \n if (ENABLE_MYSQL)\n-    add_subdirectory (mysqlxx)\n+    add_subdirectory(mysqlxx)\n endif ()\ndiff --git a/src/Common/Config/ConfigProcessor.cpp b/src/Common/Config/ConfigProcessor.cpp\nindex 5bbc8eae0de1..bda181eceebf 100644\n--- a/src/Common/Config/ConfigProcessor.cpp\n+++ b/src/Common/Config/ConfigProcessor.cpp\n@@ -19,7 +19,6 @@\n #include <Common/ZooKeeper/KeeperException.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/Exception.h>\n-#include <Common/getResource.h>\n #include <Common/XMLUtils.h>\n #include <Common/logger_useful.h>\n #include <base/errnoToString.h>\n@@ -83,6 +82,13 @@ ConfigProcessor::~ConfigProcessor()\n         Poco::Logger::destroy(\"ConfigProcessor\");\n }\n \n+static std::unordered_map<std::string, std::string_view> embedded_configs;\n+\n+void ConfigProcessor::registerEmbeddedConfig(std::string name, std::string_view content)\n+{\n+    embedded_configs[name] = content;\n+}\n+\n \n /// Vector containing the name of the element and a sorted list of attribute names and values\n /// (except \"remove\" and \"replace\" attributes).\n@@ -281,15 +287,15 @@ void ConfigProcessor::doIncludesRecursive(\n         {\n             std::string value = node->nodeValue();\n \n-            bool replace_occured = false;\n+            bool replace_occurred = false;\n             size_t pos;\n             while ((pos = value.find(substitution.first)) != std::string::npos)\n             {\n                 value.replace(pos, substitution.first.length(), substitution.second);\n-                replace_occured = true;\n+                replace_occurred = true;\n             }\n \n-            if (replace_occured)\n+            if (replace_occurred)\n                 node->setNodeValue(value);\n         }\n     }\n@@ -528,26 +534,14 @@ XMLDocumentPtr ConfigProcessor::processConfig(\n     }\n     else\n     {\n-        /// These embedded files added during build with some cmake magic.\n-        /// Look at the end of programs/server/CMakeLists.txt.\n-        std::string embedded_name;\n-        if (path == \"config.xml\")\n-            embedded_name = \"embedded.xml\";\n-\n-        if (path == \"keeper_config.xml\")\n-            embedded_name = \"keeper_embedded.xml\";\n-\n-        /// When we can use config embedded in binary.\n-        if (!embedded_name.empty())\n+        /// When we can use a config embedded in the binary.\n+        if (auto it = embedded_configs.find(path); it != embedded_configs.end())\n         {\n-            auto resource = getResource(embedded_name);\n-            if (resource.empty())\n-                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"Configuration file {} doesn't exist and there is no embedded config\", path);\n             LOG_DEBUG(log, \"There is no file '{}', will use embedded config.\", path);\n-            config = dom_parser.parseMemory(resource.data(), resource.size());\n+            config = dom_parser.parseMemory(it->second.data(), it->second.size());\n         }\n         else\n-            throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"Configuration file {} doesn't exist\", path);\n+            throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"Configuration file {} doesn't exist and there is no embedded config\", path);\n     }\n \n     std::vector<std::string> contributing_files;\ndiff --git a/src/Common/Config/ConfigProcessor.h b/src/Common/Config/ConfigProcessor.h\nindex 0ca3e46db884..eefe65ef06cd 100644\n--- a/src/Common/Config/ConfigProcessor.h\n+++ b/src/Common/Config/ConfigProcessor.h\n@@ -65,6 +65,9 @@ class ConfigProcessor\n         zkutil::ZooKeeperNodeCache * zk_node_cache = nullptr,\n         const zkutil::EventPtr & zk_changed_event = nullptr);\n \n+    /// These configurations will be used if there is no configuration file.\n+    static void registerEmbeddedConfig(std::string name, std::string_view content);\n+\n \n     /// loadConfig* functions apply processConfig and create Poco::Util::XMLConfiguration.\n     /// The resulting XML document is saved into a file with the name\ndiff --git a/src/Common/DateLUTImpl.cpp b/src/Common/DateLUTImpl.cpp\nindex 8146b35cc5f9..d5e04238ef99 100644\n--- a/src/Common/DateLUTImpl.cpp\n+++ b/src/Common/DateLUTImpl.cpp\n@@ -3,7 +3,6 @@\n #include <cctz/civil_time.h>\n #include <cctz/time_zone.h>\n #include <cctz/zone_info_source.h>\n-#include <Common/getResource.h>\n #include <Poco/Exception.h>\n \n #include <algorithm>\n@@ -11,6 +10,11 @@\n #include <chrono>\n #include <cstring>\n #include <memory>\n+#include <iostream>\n+\n+\n+/// Embedded timezones.\n+std::string_view getTimeZone(const char * name);\n \n \n namespace\n@@ -249,9 +253,10 @@ namespace cctz_extension\n             const std::string & name,\n             const std::function<std::unique_ptr<cctz::ZoneInfoSource>(const std::string & name)> & fallback)\n         {\n-            std::string_view resource = getResource(name);\n-            if (!resource.empty())\n-                return std::make_unique<Source>(resource.data(), resource.size());\n+            std::string_view tz_file = getTimeZone(name.data());\n+\n+            if (!tz_file.empty())\n+                return std::make_unique<Source>(tz_file.data(), tz_file.size());\n \n             return fallback(name);\n         }\ndiff --git a/src/Common/FrequencyHolder.cpp b/src/Common/FrequencyHolder.cpp\nnew file mode 100644\nindex 000000000000..7dc1f622aebe\n--- /dev/null\n+++ b/src/Common/FrequencyHolder.cpp\n@@ -0,0 +1,185 @@\n+#include <Common/FrequencyHolder.h>\n+\n+#if USE_NLP\n+\n+#include <incbin.h>\n+\n+/// Embedded SQL definitions\n+INCBIN(resource_charset_zst, SOURCE_DIR \"/contrib/nlp-data/charset.zst\");\n+INCBIN(resource_tonality_ru_zst, SOURCE_DIR \"/contrib/nlp-data/tonality_ru.zst\");\n+INCBIN(resource_programming_zst, SOURCE_DIR \"/contrib/nlp-data/programming.zst\");\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int FILE_DOESNT_EXIST;\n+}\n+\n+\n+FrequencyHolder & FrequencyHolder::getInstance()\n+{\n+    static FrequencyHolder instance;\n+    return instance;\n+}\n+\n+FrequencyHolder::FrequencyHolder()\n+{\n+    loadEmotionalDict();\n+    loadEncodingsFrequency();\n+    loadProgrammingFrequency();\n+}\n+\n+void FrequencyHolder::loadEncodingsFrequency()\n+{\n+    Poco::Logger * log = &Poco::Logger::get(\"EncodingsFrequency\");\n+\n+    LOG_TRACE(log, \"Loading embedded charset frequencies\");\n+\n+    std::string_view resource(reinterpret_cast<const char *>(gresource_charset_zstData), gresource_charset_zstSize);\n+    if (resource.empty())\n+        throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded charset frequencies\");\n+\n+    String line;\n+    UInt16 bigram;\n+    Float64 frequency;\n+    String charset_name;\n+\n+    auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n+    ZstdInflatingReadBuffer in(std::move(buf));\n+\n+    while (!in.eof())\n+    {\n+        readString(line, in);\n+        in.ignore();\n+\n+        if (line.empty())\n+            continue;\n+\n+        ReadBufferFromString buf_line(line);\n+\n+        // Start loading a new charset\n+        if (line.starts_with(\"// \"))\n+        {\n+            // Skip \"// \"\n+            buf_line.ignore(3);\n+            readString(charset_name, buf_line);\n+\n+            /* In our dictionary we have lines with form: <Language>_<Charset>\n+            * If we need to find language of data, we return <Language>\n+            * If we need to find charset of data, we return <Charset>.\n+            */\n+            size_t sep = charset_name.find('_');\n+\n+            Encoding enc;\n+            enc.lang = charset_name.substr(0, sep);\n+            enc.name = charset_name.substr(sep + 1);\n+            encodings_freq.push_back(std::move(enc));\n+        }\n+        else\n+        {\n+            readIntText(bigram, buf_line);\n+            buf_line.ignore();\n+            readFloatText(frequency, buf_line);\n+\n+            encodings_freq.back().map[bigram] = frequency;\n+        }\n+    }\n+    LOG_TRACE(log, \"Charset frequencies was added, charsets count: {}\", encodings_freq.size());\n+}\n+\n+void FrequencyHolder::loadEmotionalDict()\n+{\n+    Poco::Logger * log = &Poco::Logger::get(\"EmotionalDict\");\n+    LOG_TRACE(log, \"Loading embedded emotional dictionary\");\n+\n+    std::string_view resource(reinterpret_cast<const char *>(gresource_tonality_ru_zstData), gresource_tonality_ru_zstSize);\n+    if (resource.empty())\n+        throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded emotional dictionary\");\n+\n+    String line;\n+    String word;\n+    Float64 tonality;\n+    size_t count = 0;\n+\n+    auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n+    ZstdInflatingReadBuffer in(std::move(buf));\n+\n+    while (!in.eof())\n+    {\n+        readString(line, in);\n+        in.ignore();\n+\n+        if (line.empty())\n+            continue;\n+\n+        ReadBufferFromString buf_line(line);\n+\n+        readStringUntilWhitespace(word, buf_line);\n+        buf_line.ignore();\n+        readFloatText(tonality, buf_line);\n+\n+        StringRef ref{string_pool.insert(word.data(), word.size()), word.size()};\n+        emotional_dict[ref] = tonality;\n+        ++count;\n+    }\n+    LOG_TRACE(log, \"Emotional dictionary was added. Word count: {}\", std::to_string(count));\n+}\n+\n+void FrequencyHolder::loadProgrammingFrequency()\n+{\n+    Poco::Logger * log = &Poco::Logger::get(\"ProgrammingFrequency\");\n+\n+    LOG_TRACE(log, \"Loading embedded programming languages frequencies loading\");\n+\n+    std::string_view resource(reinterpret_cast<const char *>(gresource_programming_zstData), gresource_programming_zstSize);\n+    if (resource.empty())\n+        throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded programming languages frequencies\");\n+\n+    String line;\n+    String bigram;\n+    Float64 frequency;\n+    String programming_language;\n+\n+    auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n+    ZstdInflatingReadBuffer in(std::move(buf));\n+\n+    while (!in.eof())\n+    {\n+        readString(line, in);\n+        in.ignore();\n+\n+        if (line.empty())\n+            continue;\n+\n+        ReadBufferFromString buf_line(line);\n+\n+        // Start loading a new language\n+        if (line.starts_with(\"// \"))\n+        {\n+            // Skip \"// \"\n+            buf_line.ignore(3);\n+            readString(programming_language, buf_line);\n+\n+            Language lang;\n+            lang.name = programming_language;\n+            programming_freq.push_back(std::move(lang));\n+        }\n+        else\n+        {\n+            readStringUntilWhitespace(bigram, buf_line);\n+            buf_line.ignore();\n+            readFloatText(frequency, buf_line);\n+\n+            StringRef ref{string_pool.insert(bigram.data(), bigram.size()), bigram.size()};\n+            programming_freq.back().map[ref] = frequency;\n+        }\n+    }\n+    LOG_TRACE(log, \"Programming languages frequencies was added\");\n+}\n+\n+}\n+\n+#endif\ndiff --git a/src/Common/FrequencyHolder.h b/src/Common/FrequencyHolder.h\nindex 74098598441e..73675ed98148 100644\n--- a/src/Common/FrequencyHolder.h\n+++ b/src/Common/FrequencyHolder.h\n@@ -1,5 +1,9 @@\n #pragma once\n \n+#include \"config.h\"\n+\n+#if USE_NLP\n+\n #include <base/StringRef.h>\n #include <Common/logger_useful.h>\n \n@@ -7,7 +11,6 @@\n #include <unordered_map>\n \n #include <Common/Arena.h>\n-#include <Common/getResource.h>\n #include <Common/HashTable/HashMap.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <IO/ReadBufferFromFile.h>\n@@ -20,11 +23,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int FILE_DOESNT_EXIST;\n-}\n-\n /// FrequencyHolder class is responsible for storing and loading dictionaries\n /// needed for text classification functions:\n ///\n@@ -56,11 +54,7 @@ class FrequencyHolder\n     using EncodingMap = HashMap<UInt16, Float64>;\n     using EncodingContainer = std::vector<Encoding>;\n \n-    static FrequencyHolder & getInstance()\n-    {\n-        static FrequencyHolder instance;\n-        return instance;\n-    }\n+    static FrequencyHolder & getInstance();\n \n     const Map & getEmotionalDict() const\n     {\n@@ -78,161 +72,11 @@ class FrequencyHolder\n     }\n \n private:\n+    FrequencyHolder();\n \n-    FrequencyHolder()\n-    {\n-        loadEmotionalDict();\n-        loadEncodingsFrequency();\n-        loadProgrammingFrequency();\n-    }\n-\n-    void loadEncodingsFrequency()\n-    {\n-        Poco::Logger * log = &Poco::Logger::get(\"EncodingsFrequency\");\n-\n-        LOG_TRACE(log, \"Loading embedded charset frequencies\");\n-\n-        auto resource = getResource(\"charset.zst\");\n-            if (resource.empty())\n-                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded charset frequencies\");\n-\n-        String line;\n-        UInt16 bigram;\n-        Float64 frequency;\n-        String charset_name;\n-\n-        auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n-        ZstdInflatingReadBuffer in(std::move(buf));\n-\n-        while (!in.eof())\n-        {\n-            readString(line, in);\n-            in.ignore();\n-\n-            if (line.empty())\n-                continue;\n-\n-            ReadBufferFromString buf_line(line);\n-\n-            // Start loading a new charset\n-            if (line.starts_with(\"// \"))\n-            {\n-                // Skip \"// \"\n-                buf_line.ignore(3);\n-                readString(charset_name, buf_line);\n-\n-                /* In our dictionary we have lines with form: <Language>_<Charset>\n-                * If we need to find language of data, we return <Language>\n-                * If we need to find charset of data, we return <Charset>.\n-                */\n-                size_t sep = charset_name.find('_');\n-\n-                Encoding enc;\n-                enc.lang = charset_name.substr(0, sep);\n-                enc.name = charset_name.substr(sep + 1);\n-                encodings_freq.push_back(std::move(enc));\n-            }\n-            else\n-            {\n-                readIntText(bigram, buf_line);\n-                buf_line.ignore();\n-                readFloatText(frequency, buf_line);\n-\n-                encodings_freq.back().map[bigram] = frequency;\n-            }\n-        }\n-        LOG_TRACE(log, \"Charset frequencies was added, charsets count: {}\", encodings_freq.size());\n-    }\n-\n-    void loadEmotionalDict()\n-    {\n-        Poco::Logger * log = &Poco::Logger::get(\"EmotionalDict\");\n-        LOG_TRACE(log, \"Loading embedded emotional dictionary\");\n-\n-        auto resource = getResource(\"tonality_ru.zst\");\n-            if (resource.empty())\n-                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded emotional dictionary\");\n-\n-        String line;\n-        String word;\n-        Float64 tonality;\n-        size_t count = 0;\n-\n-        auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n-        ZstdInflatingReadBuffer in(std::move(buf));\n-\n-        while (!in.eof())\n-        {\n-            readString(line, in);\n-            in.ignore();\n-\n-            if (line.empty())\n-                continue;\n-\n-            ReadBufferFromString buf_line(line);\n-\n-            readStringUntilWhitespace(word, buf_line);\n-            buf_line.ignore();\n-            readFloatText(tonality, buf_line);\n-\n-            StringRef ref{string_pool.insert(word.data(), word.size()), word.size()};\n-            emotional_dict[ref] = tonality;\n-            ++count;\n-        }\n-        LOG_TRACE(log, \"Emotional dictionary was added. Word count: {}\", std::to_string(count));\n-    }\n-\n-    void loadProgrammingFrequency()\n-    {\n-        Poco::Logger * log = &Poco::Logger::get(\"ProgrammingFrequency\");\n-\n-        LOG_TRACE(log, \"Loading embedded programming languages frequencies loading\");\n-\n-        auto resource = getResource(\"programming.zst\");\n-            if (resource.empty())\n-                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, \"There is no embedded programming languages frequencies\");\n-\n-        String line;\n-        String bigram;\n-        Float64 frequency;\n-        String programming_language;\n-\n-        auto buf = std::make_unique<ReadBufferFromMemory>(resource.data(), resource.size());\n-        ZstdInflatingReadBuffer in(std::move(buf));\n-\n-        while (!in.eof())\n-        {\n-            readString(line, in);\n-            in.ignore();\n-\n-            if (line.empty())\n-                continue;\n-\n-            ReadBufferFromString buf_line(line);\n-\n-            // Start loading a new language\n-            if (line.starts_with(\"// \"))\n-            {\n-                // Skip \"// \"\n-                buf_line.ignore(3);\n-                readString(programming_language, buf_line);\n-\n-                Language lang;\n-                lang.name = programming_language;\n-                programming_freq.push_back(std::move(lang));\n-            }\n-            else\n-            {\n-                readStringUntilWhitespace(bigram, buf_line);\n-                buf_line.ignore();\n-                readFloatText(frequency, buf_line);\n-\n-                StringRef ref{string_pool.insert(bigram.data(), bigram.size()), bigram.size()};\n-                programming_freq.back().map[ref] = frequency;\n-            }\n-        }\n-        LOG_TRACE(log, \"Programming languages frequencies was added\");\n-    }\n+    void loadEncodingsFrequency();\n+    void loadEmotionalDict();\n+    void loadProgrammingFrequency();\n \n     Arena string_pool;\n \n@@ -241,3 +85,5 @@ class FrequencyHolder\n     EncodingContainer encodings_freq;\n };\n }\n+\n+#endif\ndiff --git a/src/Common/SymbolIndex.cpp b/src/Common/SymbolIndex.cpp\nindex cb02bb3ff75e..ac406538033c 100644\n--- a/src/Common/SymbolIndex.cpp\n+++ b/src/Common/SymbolIndex.cpp\n@@ -87,50 +87,13 @@ namespace\n /// https://stackoverflow.com/questions/32088140/multiple-string-tables-in-elf-object\n \n \n-void updateResources(ElfW(Addr) base_address, std::string_view object_name, std::string_view name, const void * address, SymbolIndex::Resources & resources)\n-{\n-    const char * char_address = static_cast<const char *>(address);\n-\n-    if (name.starts_with(\"_binary_\") || name.starts_with(\"binary_\"))\n-    {\n-        if (name.ends_with(\"_start\"))\n-        {\n-            name = name.substr((name[0] == '_') + strlen(\"binary_\"));\n-            name = name.substr(0, name.size() - strlen(\"_start\"));\n-\n-            auto & resource = resources[name];\n-            if (!resource.base_address || resource.base_address == base_address)\n-            {\n-                resource.base_address = base_address;\n-                resource.start = std::string_view{char_address, 0}; // NOLINT(bugprone-string-constructor)\n-                resource.object_name = object_name;\n-            }\n-        }\n-        if (name.ends_with(\"_end\"))\n-        {\n-            name = name.substr((name[0] == '_') + strlen(\"binary_\"));\n-            name = name.substr(0, name.size() - strlen(\"_end\"));\n-\n-            auto & resource = resources[name];\n-            if (!resource.base_address || resource.base_address == base_address)\n-            {\n-                resource.base_address = base_address;\n-                resource.end = std::string_view{char_address, 0}; // NOLINT(bugprone-string-constructor)\n-                resource.object_name = object_name;\n-            }\n-        }\n-    }\n-}\n-\n-\n /// Based on the code of musl-libc and the answer of Kanalpiroge on\n /// https://stackoverflow.com/questions/15779185/list-all-the-functions-symbols-on-the-fly-in-c-code-on-a-linux-architecture\n /// It does not extract all the symbols (but only public - exported and used for dynamic linking),\n /// but will work if we cannot find or parse ELF files.\n void collectSymbolsFromProgramHeaders(\n     dl_phdr_info * info,\n-    std::vector<SymbolIndex::Symbol> & symbols,\n-    SymbolIndex::Resources & resources)\n+    std::vector<SymbolIndex::Symbol> & symbols)\n {\n     /* Iterate over all headers of the current shared lib\n      * (first call is for the executable itself)\n@@ -248,9 +211,6 @@ void collectSymbolsFromProgramHeaders(\n                     /// We are not interested in empty symbols.\n                     if (elf_sym[sym_index].st_size)\n                         symbols.push_back(symbol);\n-\n-                    /// But resources can be represented by a pair of empty symbols (indicating their boundaries).\n-                    updateResources(base_address, info->dlpi_name, symbol.name, symbol.address_begin, resources);\n                 }\n \n                 break;\n@@ -281,8 +241,7 @@ void collectSymbolsFromELFSymbolTable(\n     const Elf & elf,\n     const Elf::Section & symbol_table,\n     const Elf::Section & string_table,\n-    std::vector<SymbolIndex::Symbol> & symbols,\n-    SymbolIndex::Resources & resources)\n+    std::vector<SymbolIndex::Symbol> & symbols)\n {\n     /// Iterate symbol table.\n     const ElfSym * symbol_table_entry = reinterpret_cast<const ElfSym *>(symbol_table.begin());\n@@ -312,8 +271,6 @@ void collectSymbolsFromELFSymbolTable(\n \n         if (symbol_table_entry->st_size)\n             symbols.push_back(symbol);\n-\n-        updateResources(info->dlpi_addr, info->dlpi_name, symbol.name, symbol.address_begin, resources);\n     }\n }\n \n@@ -323,8 +280,7 @@ bool searchAndCollectSymbolsFromELFSymbolTable(\n     const Elf & elf,\n     unsigned section_header_type,\n     const char * string_table_name,\n-    std::vector<SymbolIndex::Symbol> & symbols,\n-    SymbolIndex::Resources & resources)\n+    std::vector<SymbolIndex::Symbol> & symbols)\n {\n     std::optional<Elf::Section> symbol_table;\n     std::optional<Elf::Section> string_table;\n@@ -342,7 +298,7 @@ bool searchAndCollectSymbolsFromELFSymbolTable(\n         return false;\n     }\n \n-    collectSymbolsFromELFSymbolTable(info, elf, *symbol_table, *string_table, symbols, resources);\n+    collectSymbolsFromELFSymbolTable(info, elf, *symbol_table, *string_table, symbols);\n     return true;\n }\n \n@@ -351,7 +307,6 @@ void collectSymbolsFromELF(\n     dl_phdr_info * info,\n     std::vector<SymbolIndex::Symbol> & symbols,\n     std::vector<SymbolIndex::Object> & objects,\n-    SymbolIndex::Resources & resources,\n     String & build_id)\n {\n     String object_name;\n@@ -462,11 +417,11 @@ void collectSymbolsFromELF(\n     object.name = object_name;\n     objects.push_back(std::move(object));\n \n-    searchAndCollectSymbolsFromELFSymbolTable(info, *objects.back().elf, SHT_SYMTAB, \".strtab\", symbols, resources);\n+    searchAndCollectSymbolsFromELFSymbolTable(info, *objects.back().elf, SHT_SYMTAB, \".strtab\", symbols);\n \n     /// Unneeded if they were parsed from \"program headers\" of loaded objects.\n #if defined USE_MUSL\n-    searchAndCollectSymbolsFromELFSymbolTable(info, *objects.back().elf, SHT_DYNSYM, \".dynstr\", symbols, resources);\n+    searchAndCollectSymbolsFromELFSymbolTable(info, *objects.back().elf, SHT_DYNSYM, \".dynstr\", symbols);\n #endif\n }\n \n@@ -479,8 +434,8 @@ int collectSymbols(dl_phdr_info * info, size_t, void * data_ptr)\n {\n     SymbolIndex::Data & data = *reinterpret_cast<SymbolIndex::Data *>(data_ptr);\n \n-    collectSymbolsFromProgramHeaders(info, data.symbols, data.resources);\n-    collectSymbolsFromELF(info, data.symbols, data.objects, data.resources, data.build_id);\n+    collectSymbolsFromProgramHeaders(info, data.symbols);\n+    collectSymbolsFromELF(info, data.symbols, data.objects, data.build_id);\n \n     /* Continue iterations */\n     return 0;\ndiff --git a/src/Common/SymbolIndex.h b/src/Common/SymbolIndex.h\nindex 4fd108434d50..8c7b89718059 100644\n--- a/src/Common/SymbolIndex.h\n+++ b/src/Common/SymbolIndex.h\n@@ -8,6 +8,7 @@\n #include <Common/Elf.h>\n #include <boost/noncopyable.hpp>\n \n+\n namespace DB\n {\n \n@@ -45,44 +46,15 @@ class SymbolIndex : private boost::noncopyable\n     const std::vector<Symbol> & symbols() const { return data.symbols; }\n     const std::vector<Object> & objects() const { return data.objects; }\n \n-    std::string_view getResource(String name) const\n-    {\n-        if (auto it = data.resources.find(name); it != data.resources.end())\n-            return it->second.data();\n-        return {};\n-    }\n-\n     /// The BuildID that is generated by compiler.\n     String getBuildID() const { return data.build_id; }\n     String getBuildIDHex() const;\n \n-    struct ResourcesBlob\n-    {\n-        /// Symbol can be presented in multiple shared objects,\n-        /// base_address will be used to compare only symbols from the same SO.\n-        ElfW(Addr) base_address = 0;\n-        /// Just a human name of the SO.\n-        std::string_view object_name;\n-        /// Data blob.\n-        std::string_view start;\n-        std::string_view end;\n-\n-        std::string_view data() const\n-        {\n-            assert(end.data() >= start.data());\n-            return std::string_view{start.data(), static_cast<size_t>(end.data() - start.data())};\n-        }\n-    };\n-    using Resources = std::unordered_map<std::string_view /* symbol name */, ResourcesBlob>;\n-\n     struct Data\n     {\n         std::vector<Symbol> symbols;\n         std::vector<Object> objects;\n         String build_id;\n-\n-        /// Resources (embedded binary data) are located by symbols in form of _binary_name_start and _binary_name_end.\n-        Resources resources;\n     };\n private:\n     Data data;\ndiff --git a/src/Common/config.h.in b/src/Common/config.h.in\nindex a2c18fc330f8..628f0847d65f 100644\n--- a/src/Common/config.h.in\n+++ b/src/Common/config.h.in\n@@ -59,3 +59,7 @@\n #cmakedefine01 USE_ULID\n #cmakedefine01 FIU_ENABLE\n #cmakedefine01 USE_BCRYPT\n+\n+/// This is needed for .incbin in assembly. For some reason, include paths don't work there in presence of LTO.\n+/// That's why we use absolute paths.\n+#cmakedefine SOURCE_DIR \"@SOURCE_DIR@\"\ndiff --git a/src/Common/getResource.cpp b/src/Common/getResource.cpp\ndeleted file mode 100644\nindex 72ba24c2f44f..000000000000\n--- a/src/Common/getResource.cpp\n+++ /dev/null\n@@ -1,52 +0,0 @@\n-#include \"getResource.h\"\n-#include <dlfcn.h>\n-#include <string>\n-#include <boost/algorithm/string/replace.hpp>\n-#include <Common/SymbolIndex.h>\n-\n-\n-std::string_view getResource(std::string_view name)\n-{\n-    // Convert the resource file name into the form generated by `ld -r -b binary`.\n-    std::string name_replaced(name);\n-    std::replace(name_replaced.begin(), name_replaced.end(), '/', '_');\n-    std::replace(name_replaced.begin(), name_replaced.end(), '-', '_');\n-    std::replace(name_replaced.begin(), name_replaced.end(), '.', '_');\n-    boost::replace_all(name_replaced, \"+\", \"_PLUS_\");\n-\n-#if defined USE_MUSL\n-    /// If static linking is used, we cannot use dlsym and have to parse ELF symbol table by ourself.\n-    return DB::SymbolIndex::instance().getResource(name_replaced);\n-\n-#else\n-    // In most `dlsym(3)` APIs, one passes the symbol name as it appears via\n-    // something like `nm` or `objdump -t`. For example, a symbol `_foo` would be\n-    // looked up with the string `\"_foo\"`.\n-    //\n-    // Apple's linker is confusingly different. The NOTES on the man page for\n-    // `dlsym(3)` claim that one looks up the symbol with \"the name used in C\n-    // source code\". In this example, that would mean using the string `\"foo\"`.\n-    // This apparently applies even in the case where the symbol did not originate\n-    // from C source, such as the embedded binary resource files used here. So\n-    // the symbol name must not have a leading `_` on Apple platforms. It's not\n-    // clear how this applies to other symbols, such as those which _have_ a leading\n-    // underscore in them by design, many leading underscores, etc.\n-#if defined OS_DARWIN\n-    std::string prefix = \"binary_\";\n-#else\n-    std::string prefix = \"_binary_\";\n-#endif\n-    std::string symbol_name_start = prefix + name_replaced + \"_start\";\n-    std::string symbol_name_end = prefix + name_replaced + \"_end\";\n-\n-    const char * sym_start = reinterpret_cast<const char *>(dlsym(RTLD_DEFAULT, symbol_name_start.c_str()));\n-    const char * sym_end = reinterpret_cast<const char *>(dlsym(RTLD_DEFAULT, symbol_name_end.c_str()));\n-\n-    if (sym_start && sym_end)\n-    {\n-        auto resource_size = static_cast<size_t>(std::distance(sym_start, sym_end));\n-        return { sym_start, resource_size };\n-    }\n-    return {};\n-#endif\n-}\ndiff --git a/src/Common/getResource.h b/src/Common/getResource.h\ndeleted file mode 100644\nindex 8975cc7841e3..000000000000\n--- a/src/Common/getResource.h\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-#pragma once\n-\n-#include <string_view>\n-\n-/// Get resource from binary if exists. Otherwise return empty string view.\n-/// Resources are data that is embedded into executable at link time.\n-std::string_view getResource(std::string_view name);\ndiff --git a/src/Daemon/BaseDaemon.cpp b/src/Daemon/BaseDaemon.cpp\nindex 3852ec5ada52..f61ca054b2ae 100644\n--- a/src/Daemon/BaseDaemon.cpp\n+++ b/src/Daemon/BaseDaemon.cpp\n@@ -38,7 +38,6 @@\n #include <base/coverage.h>\n #include <base/sleep.h>\n \n-#include <IO/WriteBufferFromFile.h>\n #include <IO/WriteBufferFromFileDescriptorDiscardOnFailure.h>\n #include <IO/ReadBufferFromFileDescriptor.h>\n #include <IO/ReadHelpers.h>\ndiff --git a/src/Functions/FunctionsCharsetClassification.cpp b/src/Functions/FunctionsCharsetClassification.cpp\nindex a25da8f6c13a..0a332ab70a9c 100644\n--- a/src/Functions/FunctionsCharsetClassification.cpp\n+++ b/src/Functions/FunctionsCharsetClassification.cpp\n@@ -1,9 +1,12 @@\n #include <Common/FrequencyHolder.h>\n+\n+#if USE_NLP\n+\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsTextClassification.h>\n \n #include <memory>\n-#include <unordered_map>\n+\n \n namespace DB\n {\n@@ -46,7 +49,7 @@ namespace\n         return res;\n     }\n \n-    /// \u0421ount how many times each bigram occurs in the text.\n+    /// Count how many times each bigram occurs in the text.\n     template <typename ModelMap>\n     ALWAYS_INLINE inline void calculateStats(\n         const UInt8 * data,\n@@ -150,3 +153,5 @@ REGISTER_FUNCTION(DetectCharset)\n }\n \n }\n+\n+#endif\ndiff --git a/src/Functions/FunctionsLanguageClassification.cpp b/src/Functions/FunctionsLanguageClassification.cpp\nindex 6088fd52efa2..55485d41ce03 100644\n--- a/src/Functions/FunctionsLanguageClassification.cpp\n+++ b/src/Functions/FunctionsLanguageClassification.cpp\n@@ -5,19 +5,17 @@\n #include <Columns/ColumnMap.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnString.h>\n-#include <Columns/ColumnsNumber.h>\n #include <Common/isValidUTF8.h>\n #include <DataTypes/DataTypeMap.h>\n #include <DataTypes/DataTypeString.h>\n-#include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsTextClassification.h>\n-#include <Interpreters/Context.h>\n \n #include <compact_lang_det.h>\n \n+\n namespace DB\n {\n /* Determine language of Unicode UTF-8 text.\ndiff --git a/src/Functions/FunctionsProgrammingClassification.cpp b/src/Functions/FunctionsProgrammingClassification.cpp\nindex 8a552a30e65e..a93e1d9a87da 100644\n--- a/src/Functions/FunctionsProgrammingClassification.cpp\n+++ b/src/Functions/FunctionsProgrammingClassification.cpp\n@@ -1,4 +1,7 @@\n #include <Common/FrequencyHolder.h>\n+\n+#if USE_NLP\n+\n #include <Common/StringUtils/StringUtils.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsTextClassification.h>\n@@ -118,3 +121,5 @@ REGISTER_FUNCTION(DetectProgrammingLanguage)\n }\n \n }\n+\n+#endif\ndiff --git a/src/Functions/FunctionsTonalityClassification.cpp b/src/Functions/FunctionsTonalityClassification.cpp\nindex e39f9c637580..3de38d99c88b 100644\n--- a/src/Functions/FunctionsTonalityClassification.cpp\n+++ b/src/Functions/FunctionsTonalityClassification.cpp\n@@ -1,4 +1,7 @@\n #include <Common/FrequencyHolder.h>\n+\n+#if USE_NLP\n+\n #include <Common/StringUtils/StringUtils.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsTextClassification.h>\n@@ -87,3 +90,5 @@ REGISTER_FUNCTION(DetectTonality)\n }\n \n }\n+\n+#endif\ndiff --git a/src/Server/WebUIRequestHandler.cpp b/src/Server/WebUIRequestHandler.cpp\nindex 3997e0f19b63..6fa1d65de42b 100644\n--- a/src/Server/WebUIRequestHandler.cpp\n+++ b/src/Server/WebUIRequestHandler.cpp\n@@ -6,10 +6,18 @@\n #include <Poco/Util/LayeredConfiguration.h>\n \n #include <IO/HTTPCommon.h>\n-#include <Common/getResource.h>\n \n #include <re2/re2.h>\n \n+#include <incbin.h>\n+\n+#include \"config.h\"\n+\n+/// Embedded HTML pages\n+INCBIN(resource_play_html, SOURCE_DIR \"/programs/server/play.html\");\n+INCBIN(resource_dashboard_html, SOURCE_DIR \"/programs/server/dashboard.html\");\n+INCBIN(resource_uplot_js, SOURCE_DIR \"/programs/server/js/uplot.js\");\n+\n \n namespace DB\n {\n@@ -34,13 +42,13 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR\n     if (request.getURI().starts_with(\"/play\"))\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n-        *response.send() << getResource(\"play.html\");\n+        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_play_htmlData), gresource_play_htmlSize);\n     }\n     else if (request.getURI().starts_with(\"/dashboard\"))\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n \n-        std::string html(getResource(\"dashboard.html\"));\n+        std::string html(reinterpret_cast<const char *>(gresource_dashboard_htmlData), gresource_dashboard_htmlSize);\n \n         /// Replace a link to external JavaScript file to embedded file.\n         /// This allows to open the HTML without running a server and to host it on server.\n@@ -55,7 +63,7 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR\n     else if (request.getURI() == \"/js/uplot.js\")\n     {\n         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);\n-        *response.send() << getResource(\"js/uplot.js\");\n+        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_uplot_jsData), gresource_uplot_jsSize);\n     }\n     else\n     {\ndiff --git a/src/Storages/System/CMakeLists.txt b/src/Storages/System/CMakeLists.txt\nindex 1d2a3de51017..c3a2e7263653 100644\n--- a/src/Storages/System/CMakeLists.txt\n+++ b/src/Storages/System/CMakeLists.txt\n@@ -30,7 +30,6 @@ endif()\n add_dependencies(generate-source generate-contributors)\n \n set(GENERATED_LICENSES_SRC \"${CMAKE_CURRENT_BINARY_DIR}/StorageSystemLicenses.generated.cpp\")\n-set(GENERATED_TIMEZONES_SRC \"${CMAKE_CURRENT_BINARY_DIR}/StorageSystemTimeZones.generated.cpp\")\n \n add_custom_command(\n     OUTPUT StorageSystemLicenses.generated.cpp\n@@ -38,23 +37,13 @@ add_custom_command(\n     WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n \n list (APPEND storages_system_sources ${GENERATED_LICENSES_SRC})\n-list (APPEND storages_system_sources ${GENERATED_TIMEZONES_SRC})\n \n # Overlength strings\n set_source_files_properties(${GENERATED_LICENSES_SRC} PROPERTIES COMPILE_FLAGS -w)\n \n-include(${ClickHouse_SOURCE_DIR}/cmake/embed_binary.cmake)\n-clickhouse_embed_binaries(\n-        TARGET information_schema_metadata\n-        RESOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/InformationSchema/\"\n-        RESOURCES schemata.sql tables.sql views.sql columns.sql\n-)\n-\n list (SORT storages_system_sources) # Reproducible build\n add_library(clickhouse_storages_system ${storages_system_sources})\n \n-add_dependencies(clickhouse_storages_system information_schema_metadata)\n-\n target_link_libraries(clickhouse_storages_system PRIVATE\n     dbms\n     common\n@@ -62,5 +51,6 @@ target_link_libraries(clickhouse_storages_system PRIVATE\n     clickhouse_common_zookeeper\n     clickhouse_parsers\n     Poco::JSON\n-    INTERFACE \"-Wl,${WHOLE_ARCHIVE} $<TARGET_FILE:information_schema_metadata> -Wl,${NO_WHOLE_ARCHIVE}\"\n )\n+\n+target_include_directories(clickhouse_storages_system PRIVATE InformationSchema)\ndiff --git a/src/Storages/System/attachInformationSchemaTables.cpp b/src/Storages/System/attachInformationSchemaTables.cpp\nindex 61a916853242..12cef89b553d 100644\n--- a/src/Storages/System/attachInformationSchemaTables.cpp\n+++ b/src/Storages/System/attachInformationSchemaTables.cpp\n@@ -3,14 +3,23 @@\n #include <Storages/System/attachSystemTablesImpl.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n-#include <Common/getResource.h>\n+#include <incbin.h>\n+\n+#include \"config.h\"\n+\n+/// Embedded SQL definitions\n+INCBIN(resource_schemata_sql, SOURCE_DIR \"/src/Storages/System/InformationSchema/schemata.sql\");\n+INCBIN(resource_tables_sql, SOURCE_DIR \"/src/Storages/System/InformationSchema/tables.sql\");\n+INCBIN(resource_views_sql, SOURCE_DIR \"/src/Storages/System/InformationSchema/views.sql\");\n+INCBIN(resource_columns_sql, SOURCE_DIR \"/src/Storages/System/InformationSchema/columns.sql\");\n+\n \n namespace DB\n {\n \n /// View structures are taken from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt\n \n-static void createInformationSchemaView(ContextMutablePtr context, IDatabase & database, const String & view_name)\n+static void createInformationSchemaView(ContextMutablePtr context, IDatabase & database, const String & view_name, std::string_view query)\n {\n     try\n     {\n@@ -21,12 +30,11 @@ static void createInformationSchemaView(ContextMutablePtr context, IDatabase & d\n         bool is_uppercase = database.getDatabaseName() == DatabaseCatalog::INFORMATION_SCHEMA_UPPERCASE;\n \n         String metadata_resource_name = view_name + \".sql\";\n-        auto attach_query = getResource(metadata_resource_name);\n-        if (attach_query.empty())\n+        if (query.empty())\n             return;\n \n         ParserCreateQuery parser;\n-        ASTPtr ast = parseQuery(parser, attach_query.data(), attach_query.data() + attach_query.size(),\n+        ASTPtr ast = parseQuery(parser, query.data(), query.data() + query.size(),\n                                 \"Attach query from embedded resource \" + metadata_resource_name,\n                                 DBMS_DEFAULT_MAX_QUERY_SIZE, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n@@ -50,10 +58,10 @@ static void createInformationSchemaView(ContextMutablePtr context, IDatabase & d\n \n void attachInformationSchema(ContextMutablePtr context, IDatabase & information_schema_database)\n {\n-    createInformationSchemaView(context, information_schema_database, \"schemata\");\n-    createInformationSchemaView(context, information_schema_database, \"tables\");\n-    createInformationSchemaView(context, information_schema_database, \"views\");\n-    createInformationSchemaView(context, information_schema_database, \"columns\");\n+    createInformationSchemaView(context, information_schema_database, \"schemata\", std::string_view(reinterpret_cast<const char *>(gresource_schemata_sqlData), gresource_schemata_sqlSize));\n+    createInformationSchemaView(context, information_schema_database, \"tables\", std::string_view(reinterpret_cast<const char *>(gresource_tables_sqlData), gresource_tables_sqlSize));\n+    createInformationSchemaView(context, information_schema_database, \"views\", std::string_view(reinterpret_cast<const char *>(gresource_views_sqlData), gresource_views_sqlSize));\n+    createInformationSchemaView(context, information_schema_database, \"columns\", std::string_view(reinterpret_cast<const char *>(gresource_columns_sqlData), gresource_columns_sqlSize));\n }\n \n }\ndiff --git a/src/configure_config.cmake b/src/configure_config.cmake\nindex ae6305705c24..5529e2f2f39c 100644\n--- a/src/configure_config.cmake\n+++ b/src/configure_config.cmake\n@@ -162,3 +162,5 @@ endif ()\n if (TARGET ch_contrib::fiu)\n     set(FIU_ENABLE 1)\n endif()\n+\n+set(SOURCE_DIR ${CMAKE_SOURCE_DIR})\n",
  "test_patch": "diff --git a/docker/test/fasttest/run.sh b/docker/test/fasttest/run.sh\nindex e25b5fdbfedd..60e6199aaa4c 100755\n--- a/docker/test/fasttest/run.sh\n+++ b/docker/test/fasttest/run.sh\n@@ -147,6 +147,7 @@ function clone_submodules\n             contrib/simdjson\n             contrib/liburing\n             contrib/libfiu\n+            contrib/incbin\n         )\n \n         git submodule sync\ndiff --git a/src/Common/tests/gtest_DateLUTImpl.cpp b/src/Common/tests/gtest_DateLUTImpl.cpp\nindex 04f63403ec2d..3d3a3f049411 100644\n--- a/src/Common/tests/gtest_DateLUTImpl.cpp\n+++ b/src/Common/tests/gtest_DateLUTImpl.cpp\n@@ -548,4 +548,3 @@ INSTANTIATE_TEST_SUITE_P(AllTimezones_Year1970,\n //            {0, 0 + 11 * 3600 * 24 + 12, 11},\n         }))\n );\n-\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 10701dbfc637..247df64f741a 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -238,10 +238,6 @@ defaultValueOfArgumentType\n defaultValueOfTypeName\n degrees\n demangle\n-detectCharset\n-detectLanguageUnknown\n-detectProgrammingLanguage\n-detectTonality\n divide\n dotProduct\n dumpColumnStructure\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\nindex ed95c06d016f..4f40da6c626a 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n@@ -15,5 +15,7 @@ AND name NOT IN (\n     'h3ToGeoBoundary', 'h3ToParent', 'h3ToString', 'h3UnidirectionalEdgeIsValid', 'h3kRing', 'stringToH3',\n     'geoToS2', 's2CapContains', 's2CapUnion', 's2CellsIntersect', 's2GetNeighbors', 's2RectAdd', 's2RectContains', 's2RectIntersection', 's2RectUnion', 's2ToGeo',\n     'normalizeUTF8NFC', 'normalizeUTF8NFD', 'normalizeUTF8NFKC', 'normalizeUTF8NFKD',\n-    'lemmatize', 'tokenize', 'stem', 'synonyms' -- these functions are not enabled in fast test\n+    'lemmatize', 'tokenize', 'stem', 'synonyms',\n+    'detectCharset', 'detectLanguageUnknown', 'detectProgrammingLanguage', 'detectTonality'\n+     -- these functions are not enabled in fast test\n ) ORDER BY name;\n",
  "problem_statement": "Replace `getResource` to inline asm with `incbin`\nWith https://github.com/graphitemaster/incbin\r\n\r\n**Use case**\r\n\r\n`getResource` requires creating `SymbolIndex`, which takes a long time.\r\nBut we can make the symbols visible as external variables and link directly.\r\n\r\n**Additional context**\r\n\r\nNeeded for #47475\r\nand for #41988\r\n\r\nNote: it is not so trivial because sometimes we have dynamic symbol names, e.g. for time zones.\r\nThe proposed solution is to generate an array with names at build time, referencing them, and allowing searching.\n",
  "hints_text": "",
  "created_at": "2023-07-23T04:10:24Z",
  "modified_files": [
    ".gitmodules",
    "cmake/embed_binary.cmake",
    "contrib/CMakeLists.txt",
    "contrib/cctz-cmake/CMakeLists.txt",
    "b/contrib/incbin",
    "b/contrib/incbin-cmake/CMakeLists.txt",
    "contrib/nlp-data-cmake/CMakeLists.txt",
    "programs/install/Install.cpp",
    "programs/keeper/CMakeLists.txt",
    "programs/keeper/Keeper.cpp",
    "programs/server/CMakeLists.txt",
    "programs/server/Server.cpp",
    "src/CMakeLists.txt",
    "src/Common/CMakeLists.txt",
    "src/Common/Config/ConfigProcessor.cpp",
    "src/Common/Config/ConfigProcessor.h",
    "src/Common/DateLUTImpl.cpp",
    "b/src/Common/FrequencyHolder.cpp",
    "src/Common/FrequencyHolder.h",
    "src/Common/SymbolIndex.cpp",
    "src/Common/SymbolIndex.h",
    "src/Common/config.h.in",
    "src/Common/getResource.cpp",
    "src/Common/getResource.h",
    "src/Daemon/BaseDaemon.cpp",
    "src/Functions/FunctionsCharsetClassification.cpp",
    "src/Functions/FunctionsLanguageClassification.cpp",
    "src/Functions/FunctionsProgrammingClassification.cpp",
    "src/Functions/FunctionsTonalityClassification.cpp",
    "src/Server/WebUIRequestHandler.cpp",
    "src/Storages/System/CMakeLists.txt",
    "src/Storages/System/attachInformationSchemaTables.cpp",
    "src/configure_config.cmake"
  ],
  "modified_test_files": [
    "docker/test/fasttest/run.sh",
    "src/Common/tests/gtest_DateLUTImpl.cpp",
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql"
  ]
}