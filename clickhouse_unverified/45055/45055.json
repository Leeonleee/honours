{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 45055,
  "instance_id": "ClickHouse__ClickHouse-45055",
  "issue_numbers": [
    "44984"
  ],
  "base_commit": "91226abbfedd2ba94f65793213c21ee1d08409a2",
  "patch": "diff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex d89be9f3e2eb..5ea29615942a 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -790,10 +790,10 @@ void ExpressionActions::assertDeterministic() const\n }\n \n \n-std::string ExpressionActions::getSmallestColumn(const NamesAndTypesList & columns)\n+NameAndTypePair ExpressionActions::getSmallestColumn(const NamesAndTypesList & columns)\n {\n     std::optional<size_t> min_size;\n-    String res;\n+    NameAndTypePair result;\n \n     for (const auto & column : columns)\n     {\n@@ -807,14 +807,14 @@ std::string ExpressionActions::getSmallestColumn(const NamesAndTypesList & colum\n         if (!min_size || size < *min_size)\n         {\n             min_size = size;\n-            res = column.name;\n+            result = column;\n         }\n     }\n \n     if (!min_size)\n         throw Exception(\"No available columns\", ErrorCodes::LOGICAL_ERROR);\n \n-    return res;\n+    return result;\n }\n \n std::string ExpressionActions::dumpActions() const\ndiff --git a/src/Interpreters/ExpressionActions.h b/src/Interpreters/ExpressionActions.h\nindex be63b9e0d784..faefe0985f70 100644\n--- a/src/Interpreters/ExpressionActions.h\n+++ b/src/Interpreters/ExpressionActions.h\n@@ -111,7 +111,7 @@ class ExpressionActions\n     std::string dumpActions() const;\n     JSONBuilder::ItemPtr toTree() const;\n \n-    static std::string getSmallestColumn(const NamesAndTypesList & columns);\n+    static NameAndTypePair getSmallestColumn(const NamesAndTypesList & columns);\n \n     /// Check if column is always zero. True if it's definite, false if we can't say for sure.\n     /// Call it only after subqueries for sets were executed.\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 20c14b8d7b65..a1b3c8011cd8 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -1146,7 +1146,7 @@ void TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n             required.insert(std::min_element(columns.begin(), columns.end())->name);\n         else if (!source_columns.empty())\n             /// If we have no information about columns sizes, choose a column of minimum size of its data type.\n-            required.insert(ExpressionActions::getSmallestColumn(source_columns));\n+            required.insert(ExpressionActions::getSmallestColumn(source_columns).name);\n     }\n     else if (is_select && storage_snapshot && !columns_context.has_array_join)\n     {\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 3584c9d4caa6..999aa32d850e 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -81,6 +81,63 @@ void checkAccessRights(const TableNode & table_node, const Names & column_names,\n     query_context->checkAccess(AccessType::SELECT, storage_id, column_names);\n }\n \n+NameAndTypePair chooseSmallestColumnToReadFromStorage(const StoragePtr & storage, const StorageSnapshotPtr & storage_snapshot)\n+{\n+    /** We need to read at least one column to find the number of rows.\n+      * We will find a column with minimum <compressed_size, type_size, uncompressed_size>.\n+      * Because it is the column that is cheapest to read.\n+      */\n+    class ColumnWithSize\n+    {\n+    public:\n+        ColumnWithSize(NameAndTypePair column_, ColumnSize column_size_)\n+            : column(std::move(column_))\n+            , compressed_size(column_size_.data_compressed)\n+            , uncompressed_size(column_size_.data_uncompressed)\n+            , type_size(column.type->haveMaximumSizeOfValue() ? column.type->getMaximumSizeOfValueInMemory() : 100)\n+        {\n+        }\n+\n+        bool operator<(const ColumnWithSize & rhs) const\n+        {\n+            return std::tie(compressed_size, type_size, uncompressed_size)\n+                < std::tie(rhs.compressed_size, rhs.type_size, rhs.uncompressed_size);\n+        }\n+\n+        NameAndTypePair column;\n+        size_t compressed_size = 0;\n+        size_t uncompressed_size = 0;\n+        size_t type_size = 0;\n+    };\n+\n+    std::vector<ColumnWithSize> columns_with_sizes;\n+\n+    auto column_sizes = storage->getColumnSizes();\n+    auto column_names_and_types = storage_snapshot->getColumns(GetColumnsOptions(GetColumnsOptions::AllPhysical).withSubcolumns());\n+\n+    if (!column_sizes.empty())\n+    {\n+        for (auto & column_name_and_type : column_names_and_types)\n+        {\n+            auto it = column_sizes.find(column_name_and_type.name);\n+            if (it == column_sizes.end())\n+                continue;\n+\n+            columns_with_sizes.emplace_back(column_name_and_type, it->second);\n+        }\n+    }\n+\n+    NameAndTypePair result;\n+\n+    if (!columns_with_sizes.empty())\n+        result = std::min_element(columns_with_sizes.begin(), columns_with_sizes.end())->column;\n+    else\n+        /// If we have no information about columns sizes, choose a column of minimum size of its data type\n+        result = ExpressionActions::getSmallestColumn(column_names_and_types);\n+\n+    return result;\n+}\n+\n QueryPlan buildQueryPlanForTableExpression(QueryTreeNodePtr table_expression,\n     SelectQueryInfo & select_query_info,\n     const SelectQueryOptions & select_query_options,\n@@ -127,9 +184,7 @@ QueryPlan buildQueryPlanForTableExpression(QueryTreeNodePtr table_expression,\n \n         if (columns_names.empty())\n         {\n-            auto column_names_and_types = storage_snapshot->getColumns(GetColumnsOptions(GetColumnsOptions::All).withSubcolumns());\n-            auto additional_column_to_read = column_names_and_types.front();\n-\n+            auto additional_column_to_read = chooseSmallestColumnToReadFromStorage(storage, storage_snapshot);\n             const auto & column_identifier = planner_context->getGlobalPlannerContext()->createColumnIdentifier(additional_column_to_read, table_expression);\n             columns_names.push_back(additional_column_to_read.name);\n             table_expression_data.addColumn(additional_column_to_read, column_identifier);\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 0d8fe84f9d3b..e5ad2729e6cb 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1023,7 +1023,7 @@ MergeTreeDataSelectAnalysisResultPtr ReadFromMergeTree::selectRangesToReadImpl(\n     if (result.column_names_to_read.empty())\n     {\n         NamesAndTypesList available_real_columns = metadata_snapshot->getColumns().getAllPhysical();\n-        result.column_names_to_read.push_back(ExpressionActions::getSmallestColumn(available_real_columns));\n+        result.column_names_to_read.push_back(ExpressionActions::getSmallestColumn(available_real_columns).name);\n     }\n \n     // storage_snapshot->check(result.column_names_to_read);\ndiff --git a/src/Storages/HDFS/StorageHDFS.cpp b/src/Storages/HDFS/StorageHDFS.cpp\nindex bbabd523c45d..c7008a317c37 100644\n--- a/src/Storages/HDFS/StorageHDFS.cpp\n+++ b/src/Storages/HDFS/StorageHDFS.cpp\n@@ -599,7 +599,7 @@ Pipe StorageHDFS::read(\n             { return std::any_of(virtuals.begin(), virtuals.end(), [&](const NameAndTypePair & virtual_col){ return col == virtual_col.name; }); });\n \n         if (fetch_columns.empty())\n-            fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()));\n+            fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()).name);\n \n         columns_description = storage_snapshot->getDescriptionForColumns(fetch_columns);\n         block_for_format = storage_snapshot->getSampleBlockForColumns(columns_description.getNamesOfPhysical());\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 95bd0e7c53ee..922754c2d8cd 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -706,7 +706,7 @@ Pipe StorageFile::read(\n                 });\n \n             if (fetch_columns.empty())\n-                fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()));\n+                fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()).name);\n             columns_description = storage_snapshot->getDescriptionForColumns(fetch_columns);\n         }\n         else\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 79efab9e9d7c..3e279b408d7b 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -488,7 +488,7 @@ void ReadFromMerge::initializePipeline(QueryPipelineBuilder & pipeline, const Bu\n \n             column_names_as_aliases = alias_actions->getRequiredColumns().getNames();\n             if (column_names_as_aliases.empty())\n-                column_names_as_aliases.push_back(ExpressionActions::getSmallestColumn(storage_metadata_snapshot->getColumns().getAllPhysical()));\n+                column_names_as_aliases.push_back(ExpressionActions::getSmallestColumn(storage_metadata_snapshot->getColumns().getAllPhysical()).name);\n         }\n \n         auto source_pipeline = createSources(\n@@ -574,7 +574,7 @@ QueryPipelineBuilderPtr ReadFromMerge::createSources(\n     {\n         /// If there are only virtual columns in query, you must request at least one other column.\n         if (real_column_names.empty())\n-            real_column_names.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()));\n+            real_column_names.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()).name);\n \n         QueryPlan plan;\n         if (StorageView * view = dynamic_cast<StorageView *>(storage.get()))\ndiff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp\nindex edd60a364af3..9cb992bd24fd 100644\n--- a/src/Storages/StorageS3.cpp\n+++ b/src/Storages/StorageS3.cpp\n@@ -1057,7 +1057,7 @@ Pipe StorageS3::read(\n             { return std::any_of(virtuals.begin(), virtuals.end(), [&](const NameAndTypePair & virtual_col){ return col == virtual_col.name; }); });\n \n         if (fetch_columns.empty())\n-            fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()));\n+            fetch_columns.push_back(ExpressionActions::getSmallestColumn(storage_snapshot->metadata->getColumns().getAllPhysical()).name);\n \n         columns_description = storage_snapshot->getDescriptionForColumns(fetch_columns);\n         block_for_format = storage_snapshot->getSampleBlockForColumns(columns_description.getNamesOfPhysical());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.reference b/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.sql b/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.sql\nnew file mode 100644\nindex 000000000000..105bce6711ca\n--- /dev/null\n+++ b/tests/queries/0_stateless/02521_analyzer_aggregation_without_column.sql\n@@ -0,0 +1,15 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table\n+(\n+    c0 String ALIAS c1,\n+    c1 String,\n+    c2 String,\n+) ENGINE = MergeTree ORDER BY c1;\n+\n+INSERT INTO test_table VALUES ('a', 'b');\n+\n+SELECT MAX(1) FROM test_table;\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "(only with new Analyzer) NO_SUCH_COLUMN_IN_TABLE for aggregation without column chosen\n\r\n```\r\nCREATE TABLE repro (c0 String ALIAS c1, c1 String, c2 String, PRIMARY KEY c1) ENGINE = MergeTree;\r\nINSERT INTO TABLE repro VALUES ('a', 'b');\r\nSELECT MAX(1) FROM repro SETTINGS allow_experimental_analyzer=1;\r\n```\r\n\r\n```\r\nCode: 16. DB::Exception: Received from localhost:9000. DB::Exception: There is no physical column or subcolumn c0 in table: While executing MergeTreeInOrder. Stack trace:\r\n\r\n0. /build/build_docker/../contrib/llvm-project/libcxx/include/exception:134: std::exception::capture() @ 0x187d80c2 in /home/ubuntu/debug-ch/clickhouse\r\n1. /build/build_docker/../contrib/llvm-project/libcxx/include/exception:112: std::exception::exception[abi:v15000]() @ 0x187d808d in /home/ubuntu/debug-ch/clickhouse\r\n2. /build/build_docker/../contrib/poco/Foundation/src/Exception.cpp:27: Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, int) @ 0x300dd5c0 in /home/ubuntu/debug-ch/clickhouse\r\n3. /build/build_docker/../src/Common/Exception.cpp:75: DB::Exception::Exception(DB::Exception::MessageMasked const&, int, bool) @ 0x211e6dce in /home/ubuntu/debug-ch/clickhouse\r\n4. /build/build_docker/../src/Common/Exception.h:41: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, int, bool) @ 0x187cbbea in /home/ubuntu/debug-ch/clickhouse\r\n5. /build/build_docker/../src/Common/Exception.h:50: DB::Exception::Exception<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&>(int, fmt::v8::basic_format_string<char, fmt::v8::type_identity<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&>::type>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>&) @ 0x1b007bb9 in /home/ubuntu/debug-ch/clickhouse\r\n6. /build/build_docker/../src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp:114: DB::injectRequiredColumns(DB::IMergeTreeDataPartInfoForReader const&, std::__1::shared_ptr<DB::StorageSnapshot> const&, bool, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>>&) @ 0x2a86f071 in /home/ubuntu/debug-ch/clickhouse\r\n7. /build/build_docker/../src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp:300: DB::getReadTaskColumns(DB::IMergeTreeDataPartInfoForReader const&, std::__1::shared_ptr<DB::StorageSnapshot> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::shared_ptr<DB::PrewhereInfo> const&, bool) @ 0x2a870bb7 in /home/ubuntu/debug-ch/clickhouse\r\n8. /build/build_docker/../src/Storages/MergeTree/MergeTreeSelectProcessor.cpp:46: DB::MergeTreeSelectAlgorithm::initializeReaders() @ 0x2baf4781 in /home/ubuntu/debug-ch/clickhouse\r\n9. /build/build_docker/../src/Storages/MergeTree/MergeTreeInOrderSelectProcessor.cpp:18: DB::MergeTreeInOrderSelectAlgorithm::getNewTaskImpl() @ 0x2baf76c3 in /home/ubuntu/debug-ch/clickhouse\r\n10. /build/build_docker/../src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp:121: DB::IMergeTreeSelectAlgorithm::getNewTask() @ 0x2baa4bf2 in /home/ubuntu/debug-ch/clickhouse\r\n11. /build/build_docker/../src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp:211: DB::IMergeTreeSelectAlgorithm::read() @ 0x2baa6fd9 in /home/ubuntu/debug-ch/clickhouse\r\n12. /build/build_docker/../src/Storages/MergeTree/MergeTreeSource.cpp:214: DB::MergeTreeSource::tryGenerate() @ 0x2baf1557 in /home/ubuntu/debug-ch/clickhouse\r\n13. /build/build_docker/../src/Processors/ISource.cpp:94: DB::ISource::work() @ 0x2b3ba90b in /home/ubuntu/debug-ch/clickhouse\r\n14. /build/build_docker/../src/Processors/Executors/ExecutionThreadContext.cpp:47: DB::executeJob(DB::ExecutingGraph::Node*, DB::ReadProgressCallback*) @ 0x2b3fb483 in /home/ubuntu/debug-ch/clickhouse\r\n15. /build/build_docker/../src/Processors/Executors/ExecutionThreadContext.cpp:92: DB::ExecutionThreadContext::executeTask() @ 0x2b3fb186 in /home/ubuntu/debug-ch/clickhouse\r\n16. /build/build_docker/../src/Processors/Executors/PipelineExecutor.cpp:229: DB::PipelineExecutor::executeStepImpl(unsigned long, std::__1::atomic<bool>*) @ 0x2b3d9da1 in /home/ubuntu/debug-ch/clickhouse\r\n17. /build/build_docker/../src/Processors/Executors/PipelineExecutor.cpp:195: DB::PipelineExecutor::executeSingleThread(unsigned long) @ 0x2b3da0b7 in /home/ubuntu/debug-ch/clickhouse\r\n18. /build/build_docker/../src/Processors/Executors/PipelineExecutor.cpp:320: DB::PipelineExecutor::spawnThreads()::$_0::operator()() const @ 0x2b3db678 in /home/ubuntu/debug-ch/clickhouse\r\n19. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/invoke.h:394: decltype(std::declval<DB::PipelineExecutor::spawnThreads()::$_0&>()()) std::__1::__invoke[abi:v15000]<DB::PipelineExecutor::spawnThreads()::$_0&>(DB::PipelineExecutor::spawnThreads()::$_0&) @ 0x2b3db5d5 in /home/ubuntu/debug-ch/clickhouse\r\n20. /build/build_docker/../contrib/llvm-project/libcxx/include/tuple:1789: decltype(auto) std::__1::__apply_tuple_impl[abi:v15000]<DB::PipelineExecutor::spawnThreads()::$_0&, std::__1::tuple<>&>(DB::PipelineExecutor::spawnThreads()::$_0&, std::__1::tuple<>&, std::__1::__tuple_indices<>) @ 0x2b3db5b9 in /home/ubuntu/debug-ch/clickhouse\r\n21. /build/build_docker/../contrib/llvm-project/libcxx/include/tuple:1798: decltype(auto) std::__1::apply[abi:v15000]<DB::PipelineExecutor::spawnThreads()::$_0&, std::__1::tuple<>&>(DB::PipelineExecutor::spawnThreads()::$_0&, std::__1::tuple<>&) @ 0x2b3db51d in /home/ubuntu/debug-ch/clickhouse\r\n22. /build/build_docker/../src/Common/ThreadPool.h:196: ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'()::operator()() @ 0x2b3db422 in /home/ubuntu/debug-ch/clickhouse\r\n23. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/invoke.h:394: decltype(std::declval<DB::PipelineExecutor::spawnThreads()::$_0>()()) std::__1::__invoke[abi:v15000]<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'()&>(DB::PipelineExecutor::spawnThreads()::$_0&&) @ 0x2b3db395 in /home/ubuntu/debug-ch/clickhouse\r\n24. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/invoke.h:480: void std::__1::__invoke_void_return_wrapper<void, true>::__call<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'()&>(ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'()&) @ 0x2b3db375 in /home/ubuntu/debug-ch/clickhouse\r\n25. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/function.h:235: std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'(), void ()>::operator()[abi:v15000]() @ 0x2b3db355 in /home/ubuntu/debug-ch/clickhouse\r\n26. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/function.h:716: void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<DB::PipelineExecutor::spawnThreads()::$_0>(DB::PipelineExecutor::spawnThreads()::$_0&&)::'lambda'(), void ()>>(std::__1::__function::__policy_storage const*) @ 0x2b3db320 in /home/ubuntu/debug-ch/clickhouse\r\n27. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/function.h:848: std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const @ 0x2123a996 in /home/ubuntu/debug-ch/clickhouse\r\n28. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/function.h:1187: std::__1::function<void ()>::operator()() const @ 0x21236895 in /home/ubuntu/debug-ch/clickhouse\r\n29. /build/build_docker/../src/Common/ThreadPool.cpp:295: ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x21324a3c in /home/ubuntu/debug-ch/clickhouse\r\n30. /build/build_docker/../src/Common/ThreadPool.cpp:144: void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, long, std::__1::optional<unsigned long>, bool)::'lambda0'()::operator()() const @ 0x2132b724 in /home/ubuntu/debug-ch/clickhouse\r\n31. /build/build_docker/../contrib/llvm-project/libcxx/include/__functional/invoke.h:394: decltype(std::declval<void>()()) std::__1::__invoke[abi:v15000]<void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, long, std::__1::optional<unsigned long>, bool)::'lambda0'()>(void&&) @ 0x2132b6d5 in /home/ubuntu/debug-ch/clickhouse\r\n. (NO_SUCH_COLUMN_IN_TABLE)\r\n```\r\n\r\n```\r\nSELECT MAX(1) FROM repro SETTINGS allow_experimental_analyzer=0;\r\n\r\nSELECT MAX(1)\r\nFROM repro\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\nQuery id: 30dd0012-0fa8-4952-8416-021a2f1348c6\r\n\r\n\u250c\u2500max(1)\u2500\u2510\r\n\u2502      1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.020 sec.\r\n```\n",
  "hints_text": "",
  "created_at": "2023-01-09T10:35:35Z"
}