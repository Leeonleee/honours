{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34318,
  "instance_id": "ClickHouse__ClickHouse-34318",
  "issue_numbers": [
    "33944"
  ],
  "base_commit": "22de534fdcd3f05e27423d13f5875f97c3ba5f10",
  "patch": "diff --git a/src/Functions/array/mapPopulateSeries.cpp b/src/Functions/array/mapPopulateSeries.cpp\nindex b253a85c95d2..17269f8dfe1e 100644\n--- a/src/Functions/array/mapPopulateSeries.cpp\n+++ b/src/Functions/array/mapPopulateSeries.cpp\n@@ -1,15 +1,20 @@\n+#include <base/sort.h>\n+\n+#include <Core/ColumnWithTypeAndName.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnMap.h>\n #include <Columns/ColumnTuple.h>\n #include <Columns/ColumnVector.h>\n+#include <DataTypes/IDataType.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeMap.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n-#include \"Core/ColumnWithTypeAndName.h\"\n-#include \"DataTypes/DataTypeMap.h\"\n-#include \"DataTypes/IDataType.h\"\n+#include <Interpreters/castColumn.h>\n+\n \n namespace DB\n {\n@@ -19,6 +24,8 @@ namespace ErrorCodes\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int TOO_LARGE_ARRAY_SIZE;\n+    extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n }\n \n class FunctionMapPopulateSeries : public IFunction\n@@ -35,415 +42,458 @@ class FunctionMapPopulateSeries : public IFunction\n     bool useDefaultImplementationForConstants() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n-    void checkTypes(const DataTypePtr & key_type, const DataTypePtr max_key_type) const\n+    void checkTypes(const DataTypePtr & key_type, const DataTypePtr & value_type, const DataTypePtr & max_key_type) const\n     {\n-        WhichDataType which_key(key_type);\n-        if (!(which_key.isInt() || which_key.isUInt()))\n+        WhichDataType key_data_type(key_type);\n+        WhichDataType value_data_type(value_type);\n+\n+        if (!(key_data_type.isInt() || key_data_type.isUInt()))\n         {\n             throw Exception(\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Keys for {} function should be of integer type (signed or unsigned)\", getName());\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Function {} key argument should be of signed or unsigned integer type. Actual type {}\",\n+                getName(),\n+                key_type->getName());\n         }\n \n-        if (max_key_type)\n+        if (!(value_data_type.isInt() || value_data_type.isUInt()))\n         {\n-            WhichDataType which_max_key(max_key_type);\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Function {} key argument should be of signed or unsigned integer type. Actual type {}\",\n+                getName(),\n+                key_type->getName());\n+        }\n \n-            if (which_max_key.isNullable())\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Max key argument in arguments of function \" + getName() + \" can not be Nullable\");\n+        if (!max_key_type)\n+            return;\n \n-            if (key_type->getTypeId() != max_key_type->getTypeId())\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Max key type in {} should be same as keys type\", getName());\n-        }\n+        WhichDataType max_key_data_type(max_key_type);\n+\n+        if (max_key_data_type.isNullable())\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Function {} max key argument can not be Nullable. Actual type {}\",\n+                getName(),\n+                max_key_type->getName());\n+\n+        if (!(max_key_data_type.isInt() || max_key_data_type.isUInt()))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Function {} max key should be of signed or unsigned integer type. Actual type {}.\",\n+                getName(),\n+                key_type->getName(),\n+                max_key_type->getName());\n     }\n \n-    DataTypePtr getReturnTypeForTuple(const DataTypes & arguments) const\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        if (arguments.size() < 2)\n-            throw Exception(\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} accepts at least two arrays for key and value\", getName());\n+        if (arguments.empty() || arguments.size() > 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+            \"Function {} accepts at least one map or two arrays arguments, and optional max key argument\",\n+            getName());\n \n-        if (arguments.size() > 3)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Too many arguments in {} call\", getName());\n+        WhichDataType key_argument_data_type(arguments[0]);\n \n-        const DataTypeArray * key_array_type = checkAndGetDataType<DataTypeArray>(arguments[0].get());\n-        const DataTypeArray * val_array_type = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n+        DataTypePtr key_argument_series_type;\n+        DataTypePtr value_argument_series_type;\n \n-        if (!key_array_type || !val_array_type)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Function {} accepts two arrays for key and value\", getName());\n+        size_t max_key_argument_index = 0;\n \n-        const auto & key_type = key_array_type->getNestedType();\n+        if (key_argument_data_type.isArray())\n+        {\n+            DataTypePtr value_type;\n+            if (1 < arguments.size())\n+                value_type = arguments[1];\n \n-        if (arguments.size() == 3)\n-            this->checkTypes(key_type, arguments[2]);\n-        else\n-            this->checkTypes(key_type, nullptr);\n+            if (arguments.size() < 2 || (value_type && !isArray(value_type)))\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Function {} if array argument is passed as key, additional array argument as value must be passed\",\n+                    getName());\n \n-        return std::make_shared<DataTypeTuple>(DataTypes{arguments[0], arguments[1]});\n-    }\n+            const auto & key_array_type = assert_cast<const DataTypeArray &>(*arguments[0]);\n+            const auto & value_array_type = assert_cast<const DataTypeArray &>(*value_type);\n \n-    DataTypePtr getReturnTypeForMap(const DataTypes & arguments) const\n-    {\n-        const auto * map = assert_cast<const DataTypeMap *>(arguments[0].get());\n-        if (arguments.size() == 1)\n-            this->checkTypes(map->getKeyType(), nullptr);\n-        else if (arguments.size() == 2)\n-            this->checkTypes(map->getKeyType(), arguments[1]);\n-        else\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Too many arguments in {} call\", getName());\n+            key_argument_series_type = key_array_type.getNestedType();\n+            value_argument_series_type = value_array_type.getNestedType();\n \n-        return std::make_shared<DataTypeMap>(map->getKeyType(), map->getValueType());\n-    }\n+            max_key_argument_index = 2;\n+        }\n+        else if (key_argument_data_type.isMap())\n+        {\n+            const auto & map_data_type = assert_cast<const DataTypeMap &>(*arguments[0]);\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        if (arguments.empty())\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, getName() + \" accepts at least one map or two arrays\");\n+            key_argument_series_type = map_data_type.getKeyType();\n+            value_argument_series_type = map_data_type.getValueType();\n \n-        if (arguments[0]->getTypeId() == TypeIndex::Array)\n-            return getReturnTypeForTuple(arguments);\n-        else if (arguments[0]->getTypeId() == TypeIndex::Map)\n-            return getReturnTypeForMap(arguments);\n+            max_key_argument_index = 1;\n+        }\n         else\n             throw Exception(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Function {} only accepts one map or arrays, but got {}\",\n                 getName(),\n                 arguments[0]->getName());\n-    }\n \n-    // Struct holds input and output columns references,\n-    // Both arrays and maps have similar columns to work with but extracted differently\n-    template <typename KeyType, typename ValType>\n-    struct ColumnsInOut\n-    {\n-        // inputs\n-        const PaddedPODArray<KeyType> & in_keys_data;\n-        const PaddedPODArray<ValType> & in_vals_data;\n-        const IColumn::Offsets & in_key_offsets;\n-        const IColumn::Offsets & in_val_offsets;\n-        size_t row_count;\n-        bool key_is_const;\n-        bool val_is_const;\n-\n-        // outputs\n-        PaddedPODArray<KeyType> & out_keys_data;\n-        PaddedPODArray<ValType> & out_vals_data;\n-\n-        IColumn::Offsets & out_keys_offsets;\n-        // with map argument this field will not be used\n-        IColumn::Offsets * out_vals_offsets;\n-    };\n+        DataTypePtr max_key_argument_type;\n+        if (max_key_argument_index < arguments.size())\n+            max_key_argument_type = arguments[max_key_argument_index];\n \n-    template <typename KeyType, typename ValType>\n-    ColumnsInOut<KeyType, ValType> getInOutDataFromArrays(MutableColumnPtr & res_column, ColumnPtr * arg_columns) const\n-    {\n-        auto * out_tuple = assert_cast<ColumnTuple *>(res_column.get());\n-        auto & out_keys_array = assert_cast<ColumnArray &>(out_tuple->getColumn(0));\n-        auto & out_vals_array = assert_cast<ColumnArray &>(out_tuple->getColumn(1));\n+        checkTypes(key_argument_series_type, value_argument_series_type, max_key_argument_type);\n \n-        const auto * key_column = arg_columns[0].get();\n-        const auto * in_keys_array = checkAndGetColumn<ColumnArray>(key_column);\n+        if (key_argument_data_type.isArray())\n+            return std::make_shared<DataTypeTuple>(DataTypes{arguments[0], arguments[1]});\n+        else\n+            return arguments[0];\n+    }\n \n-        bool key_is_const = false, val_is_const = false;\n+    template <typename KeyType, typename ValueType>\n+    void executeImplTyped(\n+        const ColumnPtr & key_column,\n+        const ColumnPtr & value_column,\n+        const ColumnPtr & offsets_column,\n+        const ColumnPtr & max_key_column,\n+        MutableColumnPtr result_key_column,\n+        MutableColumnPtr result_value_column,\n+        MutableColumnPtr result_offset_column) const\n+    {\n+        const auto & key_column_typed = assert_cast<const ColumnVector<KeyType> &>(*key_column);\n+        const auto & key_column_data = key_column_typed.getData();\n \n-        if (!in_keys_array)\n-        {\n-            const ColumnConst * const_array = checkAndGetColumnConst<ColumnArray>(key_column);\n-            if (!const_array)\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_COLUMN, \"Expected array column in function {}, found {}\", getName(), key_column->getName());\n+        const auto & offsets_column_typed = assert_cast<const ColumnVector<ColumnArray::Offset> &>(*offsets_column);\n+        const auto & offsets = offsets_column_typed.getData();\n \n-            in_keys_array = checkAndGetColumn<ColumnArray>(const_array->getDataColumnPtr().get());\n-            key_is_const = true;\n-        }\n+        const auto & value_column_typed = assert_cast<const ColumnVector<ValueType> &>(*value_column);\n+        const auto & value_column_data = value_column_typed.getData();\n \n-        const auto * val_column = arg_columns[1].get();\n-        const auto * in_values_array = checkAndGetColumn<ColumnArray>(val_column);\n-        if (!in_values_array)\n-        {\n-            const ColumnConst * const_array = checkAndGetColumnConst<ColumnArray>(val_column);\n-            if (!const_array)\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_COLUMN, \"Expected array column in function {}, found {}\", getName(), val_column->getName());\n+        auto & result_key_column_typed = assert_cast<ColumnVector<KeyType> &>(*result_key_column);\n+        auto & result_key_data = result_key_column_typed.getData();\n \n-            in_values_array = checkAndGetColumn<ColumnArray>(const_array->getDataColumnPtr().get());\n-            val_is_const = true;\n-        }\n+        auto & result_value_column_typed = assert_cast<ColumnVector<ValueType> &>(*result_value_column);\n+        auto & result_value_data = result_value_column_typed.getData();\n \n-        if (!in_keys_array || !in_values_array)\n-            /* something went wrong */\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal columns in arguments of function \" + getName());\n-\n-        const auto & in_keys_data = assert_cast<const ColumnVector<KeyType> &>(in_keys_array->getData()).getData();\n-        const auto & in_values_data = assert_cast<const ColumnVector<ValType> &>(in_values_array->getData()).getData();\n-        const auto & in_keys_offsets = in_keys_array->getOffsets();\n-        const auto & in_vals_offsets = in_values_array->getOffsets();\n-\n-        auto & out_keys_data = assert_cast<ColumnVector<KeyType> &>(out_keys_array.getData()).getData();\n-        auto & out_vals_data = assert_cast<ColumnVector<ValType> &>(out_vals_array.getData()).getData();\n-        auto & out_keys_offsets = out_keys_array.getOffsets();\n-\n-        size_t row_count = key_is_const ? in_values_array->size() : in_keys_array->size();\n-        IColumn::Offsets * out_vals_offsets = &out_vals_array.getOffsets();\n-\n-        return {\n-            in_keys_data,\n-            in_values_data,\n-            in_keys_offsets,\n-            in_vals_offsets,\n-            row_count,\n-            key_is_const,\n-            val_is_const,\n-            out_keys_data,\n-            out_vals_data,\n-            out_keys_offsets,\n-            out_vals_offsets};\n-    }\n+        auto & result_offsets_column_typed = assert_cast<ColumnVector<ColumnArray::Offset> &>(*result_offset_column);\n+        auto & result_offsets_data = result_offsets_column_typed.getData();\n \n-    template <typename KeyType, typename ValType>\n-    ColumnsInOut<KeyType, ValType> getInOutDataFromMap(MutableColumnPtr & res_column, ColumnPtr * arg_columns) const\n-    {\n-        const auto * in_map = assert_cast<const ColumnMap *>(arg_columns[0].get());\n-        const auto & in_nested_array = in_map->getNestedColumn();\n-        const auto & in_nested_tuple = in_map->getNestedData();\n-        const auto & in_keys_data = assert_cast<const ColumnVector<KeyType> &>(in_nested_tuple.getColumn(0)).getData();\n-        const auto & in_vals_data = assert_cast<const ColumnVector<ValType> &>(in_nested_tuple.getColumn(1)).getData();\n-        const auto & in_keys_offsets = in_nested_array.getOffsets();\n-\n-        auto * out_map = assert_cast<ColumnMap *>(res_column.get());\n-        auto & out_nested_array = out_map->getNestedColumn();\n-        auto & out_nested_tuple = out_map->getNestedData();\n-        auto & out_keys_data = assert_cast<ColumnVector<KeyType> &>(out_nested_tuple.getColumn(0)).getData();\n-        auto & out_vals_data = assert_cast<ColumnVector<ValType> &>(out_nested_tuple.getColumn(1)).getData();\n-        auto & out_keys_offsets = out_nested_array.getOffsets();\n-\n-        return {\n-            in_keys_data,\n-            in_vals_data,\n-            in_keys_offsets,\n-            in_keys_offsets,\n-            in_nested_array.size(),\n-            false,\n-            false,\n-            out_keys_data,\n-            out_vals_data,\n-            out_keys_offsets,\n-            nullptr};\n-    }\n+        const PaddedPODArray<KeyType> * max_key_data = max_key_column ? &assert_cast<const ColumnVector<KeyType> &>(*max_key_column).getData() : nullptr;\n \n-    template <typename KeyType, typename ValType>\n-    ColumnPtr execute2(ColumnPtr * arg_columns, ColumnPtr max_key_column, const DataTypePtr & res_type) const\n-    {\n-        MutableColumnPtr res_column = res_type->createColumn();\n-        bool max_key_is_const = false;\n-        auto columns = res_column->getDataType() == TypeIndex::Tuple ? getInOutDataFromArrays<KeyType, ValType>(res_column, arg_columns)\n-                                                                     : getInOutDataFromMap<KeyType, ValType>(res_column, arg_columns);\n+        PaddedPODArray<std::pair<KeyType, ValueType>> sorted_keys_values;\n \n-        KeyType max_key_const{0};\n+        size_t key_offsets_size = offsets.size();\n+        result_key_data.reserve(key_offsets_size);\n+        result_value_data.reserve(key_offsets_size);\n \n-        if (max_key_column && isColumnConst(*max_key_column))\n+        for (size_t offset_index = 0; offset_index < key_offsets_size; ++offset_index)\n         {\n-            const auto * column_const = static_cast<const ColumnConst *>(&*max_key_column);\n-            max_key_const = column_const->template getValue<KeyType>();\n-            max_key_is_const = true;\n-        }\n+            size_t start_offset = offsets[offset_index - 1];\n+            size_t end_offset = offsets[offset_index];\n \n-        IColumn::Offset offset{0};\n-        std::map<KeyType, ValType> res_map;\n+            sorted_keys_values.clear();\n \n-        //Iterate through two arrays and fill result values.\n-        for (size_t row = 0; row < columns.row_count; ++row)\n-        {\n-            size_t key_offset = 0, val_offset = 0, items_count = columns.in_key_offsets[0], val_array_size = columns.in_val_offsets[0];\n-\n-            res_map.clear();\n+            for (; start_offset < end_offset; ++start_offset)\n+                sorted_keys_values.emplace_back(key_column_data[start_offset], value_column_data[start_offset]);\n \n-            if (!columns.key_is_const)\n+            if unlikely(sorted_keys_values.empty())\n             {\n-                key_offset = row > 0 ? columns.in_key_offsets[row - 1] : 0;\n-                items_count = columns.in_key_offsets[row] - key_offset;\n+                result_offsets_data.emplace_back(result_value_data.size());\n+                continue;\n             }\n \n-            if (!columns.val_is_const)\n-            {\n-                val_offset = row > 0 ? columns.in_val_offsets[row - 1] : 0;\n-                val_array_size = columns.in_val_offsets[row] - val_offset;\n-            }\n+            ::sort(sorted_keys_values.begin(), sorted_keys_values.end());\n \n-            if (items_count != val_array_size)\n-                throw Exception(\n-                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                    \"Key and value array should have same amount of elements in function {}\",\n-                    getName());\n+            KeyType min_key = sorted_keys_values.front().first;\n+            KeyType max_key = sorted_keys_values.back().first;\n \n-            if (items_count == 0)\n+            if (max_key_data)\n             {\n-                columns.out_keys_offsets.push_back(offset);\n-                continue;\n-            }\n+                max_key = (*max_key_data)[offset_index];\n \n-            for (size_t i = 0; i < items_count; ++i)\n-            {\n-                res_map.insert({columns.in_keys_data[key_offset + i], columns.in_vals_data[val_offset + i]});\n+                if (unlikely(max_key < min_key))\n+                {\n+                    result_offsets_data.emplace_back(result_value_data.size());\n+                    continue;\n+                }\n             }\n \n-            auto min_key = res_map.begin()->first;\n-            auto max_key = res_map.rbegin()->first;\n+            using KeyTypeUnsigned = ::make_unsigned_t<KeyType>;\n+            KeyTypeUnsigned max_min_key_difference = 0;\n \n-            if (max_key_column)\n+            if constexpr (::is_unsigned_v<KeyType>)\n             {\n-                /* update the current max key if it's not constant */\n-                if (max_key_is_const)\n+                max_min_key_difference = max_key - min_key;\n+            }\n+            else\n+            {\n+                bool is_max_key_positive = max_key >= 0;\n+                bool is_min_key_positive = min_key >= 0;\n+\n+                if (is_max_key_positive && is_min_key_positive)\n                 {\n-                    max_key = max_key_const;\n+                    max_min_key_difference = static_cast<KeyTypeUnsigned>(max_key - min_key);\n                 }\n-                else\n+                else if (is_max_key_positive && !is_min_key_positive)\n                 {\n-                    max_key = (static_cast<const ColumnVector<KeyType> *>(max_key_column.get()))->getData()[row];\n+                    KeyTypeUnsigned min_key_unsigned = -static_cast<KeyTypeUnsigned>(min_key);\n+                    max_min_key_difference = static_cast<KeyTypeUnsigned>(max_key) + min_key_unsigned;\n                 }\n-\n-                /* no need to add anything, max key is less that first key */\n-                if (max_key < min_key)\n+                else\n                 {\n-                    columns.out_keys_offsets.push_back(offset);\n-                    continue;\n+                    /// Both max and min key are negative\n+                    KeyTypeUnsigned min_key_unsigned = -static_cast<KeyTypeUnsigned>(min_key);\n+                    KeyTypeUnsigned max_key_unsigned = -static_cast<KeyTypeUnsigned>(max_key);\n+                    max_min_key_difference = min_key_unsigned - max_key_unsigned;\n                 }\n             }\n \n             static constexpr size_t MAX_ARRAY_SIZE = 1ULL << 30;\n-            if (static_cast<size_t>(max_key) - static_cast<size_t>(min_key) > MAX_ARRAY_SIZE)\n-                throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, \"Too large array size in the result of function {}\", getName());\n+            if (max_min_key_difference > MAX_ARRAY_SIZE)\n+                throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE,\n+                    \"Function {} too large array size in the result\",\n+                    getName());\n+\n+            size_t length = static_cast<size_t>(max_min_key_difference);\n+            size_t result_key_data_size = result_key_data.size();\n+            size_t result_value_data_size = result_value_data.size();\n+            size_t sorted_keys_values_size = sorted_keys_values.size();\n \n-            /* fill the result arrays */\n-            KeyType key;\n-            for (key = min_key;; ++key)\n+            result_key_data.resize_fill(result_key_data_size + length + 1);\n+            result_value_data.resize_fill(result_value_data_size + length + 1);\n+\n+            size_t sorted_values_index = 0;\n+\n+            for (KeyType current_key = min_key; current_key <= max_key; ++current_key)\n             {\n-                columns.out_keys_data.push_back(key);\n+                size_t key_offset_index = current_key - min_key;\n+                size_t insert_index = result_value_data_size + key_offset_index;\n \n-                auto it = res_map.find(key);\n-                if (it != res_map.end())\n-                {\n-                    columns.out_vals_data.push_back(it->second);\n-                }\n-                else\n+                result_key_data[insert_index] = current_key;\n+\n+                if (sorted_values_index < sorted_keys_values_size &&\n+                    sorted_keys_values[sorted_values_index].first == current_key)\n                 {\n-                    columns.out_vals_data.push_back(0);\n+                    auto & sorted_key_value = sorted_keys_values[sorted_values_index];\n+                    if (current_key == sorted_key_value.first)\n+                    {\n+                        result_value_data[insert_index] = sorted_key_value.second;\n+                    }\n+\n+                    ++sorted_values_index;\n+                    while (sorted_values_index < sorted_keys_values_size &&\n+                        current_key == sorted_keys_values[sorted_values_index].first)\n+                    {\n+                        ++sorted_values_index;\n+                    }\n                 }\n \n-                ++offset;\n-                if (key == max_key)\n+                if (current_key == max_key)\n                     break;\n             }\n \n-            columns.out_keys_offsets.push_back(offset);\n+            result_offsets_data.emplace_back(result_value_data.size());\n         }\n+    }\n+\n+    struct KeyAndValueInput\n+    {\n+        DataTypePtr key_series_type;\n+        DataTypePtr value_series_type;\n \n-        if (columns.out_vals_offsets)\n-            columns.out_vals_offsets->insert(columns.out_keys_offsets.begin(), columns.out_keys_offsets.end());\n+        ColumnPtr key_column;\n+        ColumnPtr value_column;\n+        ColumnPtr offsets_column;\n \n-        return res_column;\n-    }\n+        /// Optional max key column\n+        ColumnPtr max_key_column;\n+    };\n \n-    template <typename KeyType>\n-    ColumnPtr execute1(ColumnPtr * arg_columns, ColumnPtr max_key_column, const DataTypePtr & res_type, const DataTypePtr & val_type) const\n+    KeyAndValueInput extractKeyAndValueInput(const ColumnsWithTypeAndName & arguments) const\n     {\n-        switch (val_type->getTypeId())\n+        KeyAndValueInput input;\n+\n+        size_t max_key_argument_index = 0;\n+\n+        auto first_argument_column = arguments[0].column->convertToFullColumnIfConst();\n+        ColumnPtr second_argument_array_column;\n+\n+        if (const auto * key_argument_array_column = typeid_cast<const ColumnArray *>(first_argument_column.get()))\n         {\n-            case TypeIndex::Int8:\n-                return execute2<KeyType, Int8>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::Int16:\n-                return execute2<KeyType, Int16>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::Int32:\n-                return execute2<KeyType, Int32>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::Int64:\n-                return execute2<KeyType, Int64>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::Int128:\n-                return execute2<KeyType, Int128>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::Int256:\n-                return execute2<KeyType, Int256>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt8:\n-                return execute2<KeyType, UInt8>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt16:\n-                return execute2<KeyType, UInt16>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt32:\n-                return execute2<KeyType, UInt32>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt64:\n-                return execute2<KeyType, UInt64>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt128:\n-                return execute2<KeyType, UInt128>(arg_columns, max_key_column, res_type);\n-            case TypeIndex::UInt256:\n-                return execute2<KeyType, UInt256>(arg_columns, max_key_column, res_type);\n-            default:\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal columns in arguments of function \" + getName());\n+            const ColumnArray * value_argument_array_column = nullptr;\n+\n+            if (1 < arguments.size())\n+            {\n+                second_argument_array_column = arguments[1].column->convertToFullColumnIfConst();\n+                value_argument_array_column = typeid_cast<const ColumnArray *>(second_argument_array_column.get());\n+            }\n+\n+            if (!value_argument_array_column)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Function {} if array argument is passed as key, additional array argument as value must be passed\",\n+                    getName());\n+\n+            input.key_series_type = assert_cast<const DataTypeArray &>(*arguments[0].type).getNestedType();\n+            input.key_column = key_argument_array_column->getDataPtr();\n+            const auto & key_offsets = key_argument_array_column->getOffsets();\n+\n+            input.value_series_type = assert_cast<const DataTypeArray &>(*arguments[1].type).getNestedType();\n+            input.value_column = value_argument_array_column->getDataPtr();\n+            const auto & value_offsets = value_argument_array_column->getOffsets();\n+\n+            if (key_offsets != value_offsets)\n+                throw Exception(\n+                    ErrorCodes::BAD_ARGUMENTS,\n+                    \"Function {} key and value array should have same amount of elements\",\n+                    getName());\n+\n+            input.offsets_column = key_argument_array_column->getOffsetsPtr();\n+            max_key_argument_index = 2;\n         }\n-    }\n+        else if (const auto * key_argument_map_column = typeid_cast<const ColumnMap *>(first_argument_column.get()))\n+        {\n+            const auto & nested_array = key_argument_map_column->getNestedColumn();\n+            const auto & nested_data_column = key_argument_map_column->getNestedData();\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t) const override\n-    {\n-        DataTypePtr res_type, key_type, val_type;\n-        ColumnPtr max_key_column = nullptr;\n-        ColumnPtr arg_columns[] = {arguments[0].column, nullptr};\n+            const auto & map_argument_type = assert_cast<const DataTypeMap &>(*arguments[0].type);\n+            input.key_series_type = map_argument_type.getKeyType();\n+            input.value_series_type = map_argument_type.getValueType();\n+\n+            input.key_column = nested_data_column.getColumnPtr(0);\n+            input.value_column = nested_data_column.getColumnPtr(1);\n+            input.offsets_column = nested_array.getOffsetsPtr();\n \n-        if (arguments[0].type->getTypeId() == TypeIndex::Array)\n+            max_key_argument_index = 1;\n+        }\n+        else\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Function {} only accepts one map or arrays, but got {}\",\n+                getName(),\n+                arguments[0].type->getName());\n+\n+        ColumnPtr max_key_column;\n+\n+        if (max_key_argument_index < arguments.size())\n         {\n-            key_type = assert_cast<const DataTypeArray *>(arguments[0].type.get())->getNestedType();\n-            val_type = assert_cast<const DataTypeArray *>(arguments[1].type.get())->getNestedType();\n-            res_type = getReturnTypeImpl(DataTypes{arguments[0].type, arguments[1].type});\n+            max_key_column = arguments[max_key_argument_index].column->convertToFullColumnIfConst();\n+            auto max_key_column_type = arguments[max_key_argument_index].type;\n \n-            arg_columns[1] = arguments[1].column;\n-            if (arguments.size() == 3)\n+            if (!max_key_column_type->equals(*input.key_series_type))\n             {\n-                /* max key provided */\n-                max_key_column = arguments[2].column;\n+                ColumnWithTypeAndName column_to_cast = {max_key_column, max_key_column_type, \"\"};\n+                auto casted_column = castColumnAccurate(std::move(column_to_cast), input.key_series_type);\n+                max_key_column = std::move(casted_column);\n             }\n         }\n+\n+        input.max_key_column = std::move(max_key_column);\n+\n+        return input;\n+    }\n+\n+    struct ResultColumns\n+    {\n+        MutableColumnPtr result_key_column;\n+        MutableColumnPtr result_value_column;\n+        MutableColumnPtr result_offset_column;\n+        IColumn * result_offset_column_raw;\n+        /// If we return tuple of two arrays, this offset need to be the same as result_offset_column\n+        MutableColumnPtr result_array_additional_offset_column;\n+    };\n+\n+    ResultColumns extractResultColumns(MutableColumnPtr & result_column, const DataTypePtr & result_type) const\n+    {\n+        ResultColumns result;\n+\n+        auto * tuple_column = typeid_cast<ColumnTuple *>(result_column.get());\n+\n+        if (tuple_column && tuple_column->tupleSize() == 2)\n+        {\n+            auto key_array_column = tuple_column->getColumnPtr(0)->assumeMutable();\n+            auto value_array_column = tuple_column->getColumnPtr(1)->assumeMutable();\n+\n+            auto * key_array_column_typed = typeid_cast<ColumnArray *>(key_array_column.get());\n+            auto * value_array_column_typed = typeid_cast<ColumnArray *>(value_array_column.get());\n+\n+            if (!key_array_column_typed || !value_array_column_typed)\n+                throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Function {} result type should be Tuple with two nested Array columns or Map. Actual {}\",\n+                    getName(),\n+                    result_type->getName());\n+\n+            result.result_key_column = key_array_column_typed->getDataPtr()->assumeMutable();\n+            result.result_value_column = value_array_column_typed->getDataPtr()->assumeMutable();\n+            result.result_offset_column = key_array_column_typed->getOffsetsPtr()->assumeMutable();\n+            result.result_offset_column_raw = result.result_offset_column.get();\n+            result.result_array_additional_offset_column = value_array_column_typed->getOffsetsPtr()->assumeMutable();\n+        }\n+        else if (const auto * map_column = typeid_cast<ColumnMap *>(result_column.get()))\n+        {\n+            result.result_key_column = map_column->getNestedData().getColumnPtr(0)->assumeMutable();\n+            result.result_value_column = map_column->getNestedData().getColumnPtr(1)->assumeMutable();\n+            result.result_offset_column = map_column->getNestedColumn().getOffsetsPtr()->assumeMutable();\n+            result.result_offset_column_raw = result.result_offset_column.get();\n+            result.result_array_additional_offset_column = nullptr;\n+        }\n         else\n         {\n-            assert(arguments[0].type->getTypeId() == TypeIndex::Map);\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Function {} result type should be Tuple with two nested Array columns or Map. Actual {}\",\n+                    getName(),\n+                    result_type->getName());\n+        }\n+\n+        return result;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t) const override\n+    {\n+        auto input = extractKeyAndValueInput(arguments);\n \n-            const auto * map_type = assert_cast<const DataTypeMap *>(arguments[0].type.get());\n-            res_type = getReturnTypeImpl(DataTypes{arguments[0].type});\n-            key_type = map_type->getKeyType();\n-            val_type = map_type->getValueType();\n+        auto result_column = result_type->createColumn();\n+        auto result_columns = extractResultColumns(result_column, result_type);\n \n-            if (arguments.size() == 2)\n+        auto call = [&](const auto & types)\n+        {\n+            using Types = std::decay_t<decltype(types)>;\n+            using KeyType = typename Types::LeftType;\n+            using ValueType = typename Types::RightType;\n+\n+            static constexpr bool key_and_value_are_numbers = IsDataTypeNumber<KeyType> && IsDataTypeNumber<ValueType>;\n+            static constexpr bool key_is_float = std::is_same_v<KeyType, DataTypeFloat32> || std::is_same_v<KeyType, DataTypeFloat64>;\n+\n+            if constexpr (key_and_value_are_numbers && !key_is_float)\n             {\n-                /* max key provided */\n-                max_key_column = arguments[1].column;\n+                using KeyFieldType = typename KeyType::FieldType;\n+                using ValueFieldType = typename ValueType::FieldType;\n+\n+                executeImplTyped<KeyFieldType, ValueFieldType>(\n+                    input.key_column,\n+                    input.value_column,\n+                    input.offsets_column,\n+                    input.max_key_column,\n+                    std::move(result_columns.result_key_column),\n+                    std::move(result_columns.result_value_column),\n+                    std::move(result_columns.result_offset_column));\n+\n+                return true;\n             }\n-        }\n \n-        switch (key_type->getTypeId())\n+            return false;\n+        };\n+\n+        if (!callOnTwoTypeIndexes(input.key_series_type->getTypeId(), input.value_series_type->getTypeId(), call))\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+            \"Function {} illegal columns passed as arguments\",\n+             getName());\n+\n+        if (result_columns.result_array_additional_offset_column)\n         {\n-            case TypeIndex::Int8:\n-                return execute1<Int8>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::Int16:\n-                return execute1<Int16>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::Int32:\n-                return execute1<Int32>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::Int64:\n-                return execute1<Int64>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::Int128:\n-                return execute1<Int128>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::Int256:\n-                return execute1<Int256>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt8:\n-                return execute1<UInt8>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt16:\n-                return execute1<UInt16>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt32:\n-                return execute1<UInt32>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt64:\n-                return execute1<UInt64>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt128:\n-                return execute1<UInt128>(arg_columns, max_key_column, res_type, val_type);\n-            case TypeIndex::UInt256:\n-                return execute1<UInt256>(arg_columns, max_key_column, res_type, val_type);\n-            default:\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal columns in arguments of function \" + getName());\n+            result_columns.result_array_additional_offset_column->insertRangeFrom(\n+                *result_columns.result_offset_column_raw,\n+                0,\n+                result_columns.result_offset_column_raw->size());\n         }\n+\n+        return result_column;\n     }\n };\n \n@@ -451,4 +501,5 @@ void registerFunctionMapPopulateSeries(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionMapPopulateSeries>();\n }\n+\n }\n",
  "test_patch": "diff --git a/tests/performance/map_populate_series.xml b/tests/performance/map_populate_series.xml\nnew file mode 100644\nindex 000000000000..a050be6f3a8b\n--- /dev/null\n+++ b/tests/performance/map_populate_series.xml\n@@ -0,0 +1,4 @@\n+<test>\n+    <query>SELECT mapPopulateSeries(range(number), range(number)) FROM numbers(5000) FORMAT Null;</query>\n+    <query>SELECT mapPopulateSeries(range(number), range(number), 2500) FROM numbers(5000) FORMAT Null;</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01318_map_populate_series.reference b/tests/queries/0_stateless/01318_map_populate_series.reference\nindex 2d83844c8e19..65e6f8e462c3 100644\n--- a/tests/queries/0_stateless/01318_map_populate_series.reference\n+++ b/tests/queries/0_stateless/01318_map_populate_series.reference\n@@ -13,6 +13,11 @@\n ([1,2,3,4,5,6,7,8,9,10],[1,0,2,0,0,0,0,0,0,0])\n ([1,2,3,4,5,6,7,8,9,10],[1,0,0,2,0,0,0,0,0,0])\n ([1,2,3,4,5,6,7,8,9,10],[1,0,0,0,2,0,0,0,0,0])\n+([1,2,3,4,5,6,7,8,9,10],[1,0,0,0,0,0,0,0,0,0])\n+([1,2,3,4,5,6,7,8,9,10],[1,2,0,0,0,0,0,0,0,0])\n+([1,2,3,4,5,6,7,8,9,10],[1,0,2,0,0,0,0,0,0,0])\n+([1,2,3,4,5,6,7,8,9,10],[1,0,0,2,0,0,0,0,0,0])\n+([1,2,3,4,5,6,7,8,9,10],[1,0,0,0,2,0,0,0,0,0])\n ([1,2],[1,0])\n ([1,2,3],[1,2,0])\n ([1,2,3,4],[1,0,2,0])\ndiff --git a/tests/queries/0_stateless/01318_map_populate_series.sql b/tests/queries/0_stateless/01318_map_populate_series.sql\nindex e52571182fee..f7fa8c81e8ca 100644\n--- a/tests/queries/0_stateless/01318_map_populate_series.sql\n+++ b/tests/queries/0_stateless/01318_map_populate_series.sql\n@@ -4,7 +4,7 @@ create table map_test engine=TinyLog() as (select (number + 1) as n, ([1, number\n select mapPopulateSeries(map.1, map.2) from map_test;\n select mapPopulateSeries(map.1, map.2, toUInt64(3)) from map_test;\n select mapPopulateSeries(map.1, map.2, toUInt64(10)) from map_test;\n-select mapPopulateSeries(map.1, map.2, 1000) from map_test; -- { serverError 43 }\n+select mapPopulateSeries(map.1, map.2, 10) from map_test;\n select mapPopulateSeries(map.1, map.2, n) from map_test;\n select mapPopulateSeries(map.1, [11,22]) from map_test;\n select mapPopulateSeries([3, 4], map.2) from map_test;\n@@ -31,6 +31,6 @@ select mapPopulateSeries([toInt64(-10), 2], [toInt64(1), 1], toInt64(-5)) as res\n -- empty\n select mapPopulateSeries(cast([], 'Array(UInt8)'), cast([], 'Array(UInt8)'), 5);\n \n-select mapPopulateSeries(['1', '2'], [1,1]) as res, toTypeName(res); -- { serverError 43 }\n-select mapPopulateSeries([1, 2, 3], [1,1]) as res, toTypeName(res); -- { serverError 42 }\n-select mapPopulateSeries([1, 2], [1,1,1]) as res, toTypeName(res); -- { serverError 42 }\n+select mapPopulateSeries(['1', '2'], [1, 1]) as res, toTypeName(res); -- { serverError 43 }\n+select mapPopulateSeries([1, 2, 3], [1, 1]) as res, toTypeName(res); -- { serverError 36 }\n+select mapPopulateSeries([1, 2], [1, 1, 1]) as res, toTypeName(res); -- { serverError 36 }\ndiff --git a/tests/queries/0_stateless/01925_map_populate_series_on_map.reference b/tests/queries/0_stateless/01925_map_populate_series_on_map.reference\nindex fd3d3b2450dd..318f5ced2314 100644\n--- a/tests/queries/0_stateless/01925_map_populate_series_on_map.reference\n+++ b/tests/queries/0_stateless/01925_map_populate_series_on_map.reference\n@@ -20,7 +20,12 @@ select mapPopulateSeries(m, toUInt64(10)) from map_test;\n {1:1,2:0,3:2,4:0,5:0,6:0,7:0,8:0,9:0,10:0}\n {1:1,2:0,3:0,4:2,5:0,6:0,7:0,8:0,9:0,10:0}\n {1:1,2:0,3:0,4:0,5:2,6:0,7:0,8:0,9:0,10:0}\n-select mapPopulateSeries(m, 1000) from map_test; -- { serverError 43 }\n+select mapPopulateSeries(m, 10) from map_test;\n+{1:1,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0}\n+{1:1,2:2,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0}\n+{1:1,2:0,3:2,4:0,5:0,6:0,7:0,8:0,9:0,10:0}\n+{1:1,2:0,3:0,4:2,5:0,6:0,7:0,8:0,9:0,10:0}\n+{1:1,2:0,3:0,4:0,5:2,6:0,7:0,8:0,9:0,10:0}\n select mapPopulateSeries(m, n) from map_test;\n {1:1,2:0}\n {1:1,2:2,3:0}\ndiff --git a/tests/queries/0_stateless/01925_map_populate_series_on_map.sql b/tests/queries/0_stateless/01925_map_populate_series_on_map.sql\nindex ac78280ec1d0..635fba37cc86 100644\n--- a/tests/queries/0_stateless/01925_map_populate_series_on_map.sql\n+++ b/tests/queries/0_stateless/01925_map_populate_series_on_map.sql\n@@ -6,7 +6,7 @@ create table map_test engine=TinyLog() as (select (number + 1) as n, map(1, 1, n\n select mapPopulateSeries(m) from map_test;\n select mapPopulateSeries(m, toUInt64(3)) from map_test;\n select mapPopulateSeries(m, toUInt64(10)) from map_test;\n-select mapPopulateSeries(m, 1000) from map_test; -- { serverError 43 }\n+select mapPopulateSeries(m, 10) from map_test;\n select mapPopulateSeries(m, n) from map_test;\n \n drop table map_test;\ndiff --git a/tests/queries/0_stateless/02205_map_populate_series_non_const.reference b/tests/queries/0_stateless/02205_map_populate_series_non_const.reference\nnew file mode 100644\nindex 000000000000..5d938d2917dd\n--- /dev/null\n+++ b/tests/queries/0_stateless/02205_map_populate_series_non_const.reference\n@@ -0,0 +1,34 @@\n+mapPopulateSeries with map\n+Without max key\n+{0:5}\n+{0:5,1:0,2:0,3:0,4:0,5:10}\n+{-5:-5,-4:0,-3:0,-2:0,-1:0,0:5,1:0,2:0,3:0,4:0,5:10}\n+{-5:-5,-4:0,-3:0,-2:0,-1:0,0:5,1:0,2:0,3:0,4:0,5:10,6:0,7:0,8:0,9:0,10:15}\n+With max key\n+{0:5,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0,15:0,16:0,17:0,18:0,19:0,20:0}\n+{0:5,1:0,2:0,3:0,4:0,5:10,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0,15:0,16:0,17:0,18:0,19:0,20:0}\n+{-5:-5,-4:0,-3:0,-2:0,-1:0,0:5,1:0,2:0,3:0,4:0,5:10}\n+{-5:-5,-4:0,-3:0,-2:0,-1:0,0:5,1:0,2:0,3:0,4:0,5:10,6:0,7:0,8:0,9:0,10:15,11:0,12:0,13:0,14:0,15:0,16:0,17:0,18:0,19:0,20:0}\n+Possible verflow\n+{18446744073709551610:5,18446744073709551611:0,18446744073709551612:0,18446744073709551613:0,18446744073709551614:0,18446744073709551615:0}\n+{18446744073709551615:5}\n+Duplicate keys\n+{1:4,2:0,3:0,4:0,5:6}\n+{1:4,2:0,3:0,4:0,5:6,6:0,7:0,8:0,9:0,10:0}\n+mapPopulateSeries with two arrays\n+Without max key\n+([0],[5])\n+([0,1,2,3,4,5],[5,0,0,0,0,10])\n+([-5,-4,-3,-2,-1,0,1,2,3,4,5],[-5,0,0,0,0,5,0,0,0,0,10])\n+([-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10],[-5,0,0,0,0,5,0,0,0,0,10,0,0,0,0,15])\n+With max key\n+([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])\n+([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[5,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])\n+([-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[-5,0,0,0,0,5,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])\n+([-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[-5,0,0,0,0,5,0,0,0,0,10,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0])\n+Possible verflow\n+([18446744073709551610,18446744073709551611,18446744073709551612,18446744073709551613,18446744073709551614,18446744073709551615],[5,0,0,0,0,0])\n+([18446744073709551615],[5])\n+Duplicate keys\n+([1,2,3,4,5],[4,0,0,0,6])\n+([1,2,3,4,5,6,7,8,9,10],[4,0,0,0,6,0,0,0,0,0])\ndiff --git a/tests/queries/0_stateless/02205_map_populate_series_non_const.sql b/tests/queries/0_stateless/02205_map_populate_series_non_const.sql\nnew file mode 100644\nindex 000000000000..08a3dd51eb11\n--- /dev/null\n+++ b/tests/queries/0_stateless/02205_map_populate_series_non_const.sql\n@@ -0,0 +1,125 @@\n+DROP TABLE IF EXISTS 02005_test_table;\n+CREATE TABLE 02005_test_table\n+(\n+    value Map(Int64, Int64)\n+)\n+ENGINE = TinyLog;\n+\n+SELECT 'mapPopulateSeries with map';\n+\n+SELECT 'Without max key';\n+\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(0, 5));\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(0, 5, 5, 10));\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(-5, -5, 0, 5, 5, 10));\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(-5, -5, 0, 5, 5, 10, 10, 15));\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+SELECT 'With max key';\n+\n+SELECT mapPopulateSeries(value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(0, 5));\n+SELECT mapPopulateSeries(value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(0, 5, 5, 10));\n+SELECT mapPopulateSeries(value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(-5, -5, 0, 5, 5, 10));\n+SELECT mapPopulateSeries(value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES (map(-5, -5, 0, 5, 5, 10, 10, 15));\n+SELECT mapPopulateSeries(value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+SELECT 'Possible verflow';\n+\n+SELECT mapPopulateSeries(map(toUInt64(18446744073709551610), toUInt64(5)), 18446744073709551615);\n+SELECT mapPopulateSeries(map(toUInt64(18446744073709551615), toUInt64(5)), 18446744073709551615);\n+\n+SELECT 'Duplicate keys';\n+\n+SELECT mapPopulateSeries(map(1, 4, 1, 5, 5, 6));\n+SELECT mapPopulateSeries(map(1, 4, 1, 5, 5, 6), materialize(10));\n+\n+DROP TABLE 02005_test_table;\n+\n+DROP TABLE IF EXISTS 02005_test_table;\n+CREATE TABLE 02005_test_table\n+(\n+    key Array(Int64),\n+    value Array(Int64)\n+)\n+ENGINE = TinyLog;\n+\n+SELECT 'mapPopulateSeries with two arrays';\n+SELECT 'Without max key';\n+\n+SELECT mapPopulateSeries(key, value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([0], [5]);\n+SELECT mapPopulateSeries(key, value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([0, 5], [5, 10]);\n+SELECT mapPopulateSeries(key, value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([-5, 0, 5], [-5, 5, 10]);\n+SELECT mapPopulateSeries(key, value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([-5, 0, 5, 10], [-5, 5, 10, 15]);\n+SELECT mapPopulateSeries(key, value) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+SELECT 'With max key';\n+\n+SELECT mapPopulateSeries(key, value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([0], [5]);\n+SELECT mapPopulateSeries(key, value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([0, 5], [5, 10]);\n+SELECT mapPopulateSeries(key, value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([-5, 0, 5], [-5, 5, 10]);\n+SELECT mapPopulateSeries(key, value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+INSERT INTO 02005_test_table VALUES ([-5, 0, 5, 10], [-5, 5, 10, 15]);\n+SELECT mapPopulateSeries(key, value, materialize(20)) FROM 02005_test_table;\n+TRUNCATE TABLE 02005_test_table;\n+\n+SELECT 'Possible verflow';\n+\n+SELECT mapPopulateSeries([18446744073709551610], [5], 18446744073709551615);\n+SELECT mapPopulateSeries([18446744073709551615], [5], 18446744073709551615);\n+\n+SELECT 'Duplicate keys';\n+\n+SELECT mapPopulateSeries([1, 1, 5], [4, 5, 6]);\n+SELECT mapPopulateSeries([1, 1, 5], [4, 5, 6], materialize(10));\n+\n+DROP TABLE 02005_test_table;\n",
  "problem_statement": "mapPopulateSeries LOGICAL_ERROR\n**Describe what's wrong**\r\n\r\n\r\n**How to reproduce**\r\n\r\n\r\n```sql\r\n\r\nSELECT mapPopulateSeries(range(10), range(10), toUInt8(number))\r\nFROM numbers(10)\r\nLIMIT 1\r\n\r\nQuery id: 5eb2e3fb-26a0-4a17-8a37-9714d35095bd\r\n\r\n\u250c\u2500mapPopulateSeries(range(10), range(10), toUInt8(number))\u2500\u2510\r\n\u2502 ([0],[0])                                                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500mapPopulateSeries(range(10), range(10), toUInt8(number))\u2500\u2510\r\n\u2502 ([0],[0])                                                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.004 sec.\r\n\r\nSELECT mapPopulateSeries(range(900), range(900), materialize(1000)).2\r\nFROM numbers(100)\r\nFORMAT `Null`\r\n\r\nQuery id: 6418bf79-5d29-4709-86d6-7bdee9b7c9f7\r\n\r\n\u2190 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.)\r\n1 rows in set. Elapsed: 0.014 sec.\r\n\r\nReceived exception from server (version 21.13.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Invalid number of rows in Chunk column Array(UInt16) position 0: expected 100, got 1. (LOGICAL_ERROR)\r\n\r\nSELECT mapPopulateSeries(range(900), range(900), toUInt16(number)).2\r\nFROM numbers(100)\r\nLIMIT 1000\r\n\r\n\u250c\u2500tupleElement(mapPopulateSeries(range(900), range(900), toUInt16(number)), 2)\u2500\u2510\r\n\u2502 [0]                                                                          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u2192 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.)\r\n1 rows in set. Elapsed: 0.007 sec.\r\n\r\nReceived exception from server (version 21.13.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Invalid number of rows in Chunk column Array(UInt16) position 0: expected 100, got 1. (LOGICAL_ERROR)\r\n\r\nSELECT mapPopulateSeries(range(10), range(10), toUInt16(number))\r\nFROM numbers(10)\r\nLIMIT 1\r\n\r\nQuery id: 7b6d6e3d-19f1-489b-93a7-022eaa507af4\r\n\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\nReceived exception from server (version 21.13.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Max key type in mapPopulateSeries should be same as keys type: While processing mapPopulateSeries(range(10), range(10), toUInt16(number)). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\n**Expected behavior**\r\n\r\n> A clear and concise description of what you expected to happen.\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Invalid number of rows in Chunk column Array(UInt16) position 0: expected 100, got 1. (LOGICAL_ERROR)\r\n```\n",
  "hints_text": "",
  "created_at": "2022-02-04T14:54:49Z"
}