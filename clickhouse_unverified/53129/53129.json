{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53129,
  "instance_id": "ClickHouse__ClickHouse-53129",
  "issue_numbers": [
    "52838"
  ],
  "base_commit": "72b52250ea63ed7fc01c72b0f18e06db57225181",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex de3cc00e4c94..29434ef556f1 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -98,6 +98,18 @@ Default value: 0.\n </profiles>\n ```\n \n+## mutations_execute_nondeterministic_on_initiator {#mutations_execute_nondeterministic_on_initiator}\n+\n+If true constant nondeterministic functions (e.g. function `now()`) are executed on initiator and replaced to literals in `UPDATE` and `DELETE` queries. It helps to keep data in sync on replicas while executing mutations with constant nondeterministic functions. Default value: `false`.\n+\n+## mutations_execute_subqueries_on_initiator {#mutations_execute_subqueries_on_initiator}\n+\n+If true scalar subqueries are executed on initiator and replaced to literals in `UPDATE` and `DELETE` queries. Default value: `false`.\n+\n+## mutations_max_literal_size_to_replace {#mutations_max_literal_size_to_replace}\n+\n+The maximum size of serialized literal in bytes to replace in `UPDATE` and `DELETE` queries. Takes effect only if at least one the two settings above is enabled. Default value: 16384 (16 KiB).\n+\n ## distributed_product_mode {#distributed-product-mode}\n \n Changes the behaviour of [distributed subqueries](../../sql-reference/operators/in.md).\n@@ -4298,7 +4310,7 @@ Use this setting only for backward compatibility if your use cases depend on old\n ## session_timezone {#session_timezone}\n \n Sets the implicit time zone of the current session or query.\n-The implicit time zone is the time zone applied to values of type DateTime/DateTime64 which have no explicitly specified time zone. \n+The implicit time zone is the time zone applied to values of type DateTime/DateTime64 which have no explicitly specified time zone.\n The setting takes precedence over the globally configured (server-level) implicit time zone.\n A value of '' (empty string) means that the implicit time zone of the current session or query is equal to the [server time zone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone).\n \n@@ -4333,7 +4345,7 @@ SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zuric\n ```\n \n :::warning\n-Not all functions that parse DateTime/DateTime64 respect `session_timezone`. This can lead to subtle errors. \n+Not all functions that parse DateTime/DateTime64 respect `session_timezone`. This can lead to subtle errors.\n See the following example and explanation.\n :::\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 714ac17a15df..3996ed4e3740 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -591,6 +591,9 @@ class IColumn;\n     M(Bool, insert_null_as_default, true, \"Insert DEFAULT values instead of NULL in INSERT SELECT (UNION ALL)\", 0) \\\n     M(Bool, describe_extend_object_types, false, \"Deduce concrete type of columns of type Object in DESCRIBE query\", 0) \\\n     M(Bool, describe_include_subcolumns, false, \"If true, subcolumns of all table columns will be included into result of DESCRIBE query\", 0) \\\n+    M(Bool, mutations_execute_nondeterministic_on_initiator, false, \"If true nondeterministic function are executed on initiator and replaced to literals in UPDATE and DELETE queries\", 0) \\\n+    M(Bool, mutations_execute_subqueries_on_initiator, false, \"If true scalar subqueries are executed on initiator and replaced to literals in UPDATE and DELETE queries\", 0) \\\n+    M(UInt64, mutations_max_literal_size_to_replace, 16384, \"The maximum size of serialized literal in bytes to replace in UPDATE and DELETE queries\", 0) \\\n     \\\n     M(Bool, use_query_cache, false, \"Enable the query cache\", 0) \\\n     M(Bool, enable_writes_to_query_cache, true, \"Enable storing results of SELECT queries in the query cache\", 0) \\\ndiff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex e82415f1aca9..7d1f99482383 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -132,6 +132,21 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n                 throw Exception(ErrorCodes::INCORRECT_QUERY, \"Cannot MATERIALIZE TTL as there is no TTL set for table {}\",\n                     table->getStorageID().getNameForLogs());\n \n+            if (mut_command->type == MutationCommand::UPDATE || mut_command->type == MutationCommand::DELETE)\n+            {\n+                /// TODO: add a check for result query size.\n+                auto rewritten_command_ast = replaceNonDeterministicToScalars(*command_ast, getContext());\n+                if (rewritten_command_ast)\n+                {\n+                    auto * new_alter_command = rewritten_command_ast->as<ASTAlterCommand>();\n+                    mut_command = MutationCommand::parse(new_alter_command);\n+                    if (!mut_command)\n+                        throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                            \"Alter command '{}' is rewritten to invalid command '{}'\",\n+                            queryToString(*command_ast), queryToString(*rewritten_command_ast));\n+                }\n+            }\n+\n             mutation_commands.emplace_back(std::move(*mut_command));\n         }\n         else\ndiff --git a/src/Interpreters/MutationsNonDeterministicHelpers.cpp b/src/Interpreters/MutationsNonDeterministicHelpers.cpp\nindex 46c203e15bc8..119759265efa 100644\n--- a/src/Interpreters/MutationsNonDeterministicHelpers.cpp\n+++ b/src/Interpreters/MutationsNonDeterministicHelpers.cpp\n@@ -63,6 +63,71 @@ class FirstNonDeterministicFunctionMatcher\n using FirstNonDeterministicFunctionFinder = InDepthNodeVisitor<FirstNonDeterministicFunctionMatcher, true>;\n using FirstNonDeterministicFunctionData = FirstNonDeterministicFunctionMatcher::Data;\n \n+/// Executes and replaces with literals\n+/// non-deterministic functions in query.\n+/// Similar to ExecuteScalarSubqueriesVisitor.\n+class ExecuteNonDeterministicConstFunctionsMatcher\n+{\n+public:\n+\n+    struct Data\n+    {\n+        ContextPtr context;\n+        std::optional<size_t> max_literal_size;\n+    };\n+\n+    static bool needChildVisit(const ASTPtr & ast, const ASTPtr & /*child*/)\n+    {\n+        /// Do not visit subqueries because they are executed separately.\n+        return !ast->as<ASTSelectQuery>();\n+    }\n+\n+    static void visit(ASTPtr & ast, const Data & data)\n+    {\n+        if (auto * function = ast->as<ASTFunction>())\n+            visit(*function, ast, data);\n+    }\n+\n+    static void visit(ASTFunction & function, ASTPtr & ast, const Data & data)\n+    {\n+        if (!FunctionFactory::instance().has(function.name))\n+            return;\n+\n+        /// It makes sense to execute functions which are deterministic\n+        /// in scope of query because they are usually constant expressions.\n+        auto builder = FunctionFactory::instance().get(function.name, data.context);\n+        if (builder->isDeterministic() || !builder->isDeterministicInScopeOfQuery())\n+            return;\n+\n+        Field field;\n+        DataTypePtr type;\n+\n+        try\n+        {\n+            std::tie(field, type) = evaluateConstantExpression(ast, data.context);\n+        }\n+        catch (...)\n+        {\n+            /// An exception can be thrown if the expression is not constant.\n+            /// It's ok in that context and we just do nothing in that case.\n+            /// It's bad pattern but it's quite hard to implement it in another way.\n+            return;\n+        }\n+\n+        auto column = type->createColumn();\n+        column->insert(field);\n+\n+        Block scalar{{std::move(column), type, \"_constant\"}};\n+        if (worthConvertingScalarToLiteral(scalar, data.max_literal_size))\n+        {\n+            auto literal = std::make_unique<ASTLiteral>(std::move(field));\n+            ast = addTypeConversionToAST(std::move(literal), type->getName());\n+        }\n+    }\n+};\n+\n+using ExecuteNonDeterministicConstFunctionsVisitor = InDepthNodeVisitor<ExecuteNonDeterministicConstFunctionsMatcher, true>;\n+\n }\n \n FirstNonDeterministicFunctionResult findFirstNonDeterministicFunction(const MutationCommand & command, ContextPtr context)\n@@ -97,4 +162,51 @@ FirstNonDeterministicFunctionResult findFirstNonDeterministicFunction(const Muta\n     return {};\n }\n \n+ASTPtr replaceNonDeterministicToScalars(const ASTAlterCommand & alter_command, ContextPtr context)\n+{\n+    const auto & settings = context->getSettingsRef();\n+    if (!settings.mutations_execute_subqueries_on_initiator\n+        && !settings.mutations_execute_nondeterministic_on_initiator)\n+        return nullptr;\n+\n+    auto query = alter_command.clone();\n+    auto & new_alter_command = *query->as<ASTAlterCommand>();\n+\n+    if (settings.mutations_execute_subqueries_on_initiator)\n+    {\n+        Scalars scalars;\n+        Scalars local_scalars;\n+\n+        ExecuteScalarSubqueriesVisitor::Data data{\n+            WithContext{context},\n+            /*subquery_depth=*/ 0,\n+            scalars,\n+            local_scalars,\n+            /*only_analyze=*/ false,\n+            /*is_create_parameterized_view=*/ false,\n+            /*replace_only_to_literals=*/ true,\n+            settings.mutations_max_literal_size_to_replace};\n+\n+        ExecuteScalarSubqueriesVisitor visitor(data);\n+        if (new_alter_command.update_assignments)\n+            visitor.visit(new_alter_command.update_assignments);\n+        if (new_alter_command.predicate)\n+            visitor.visit(new_alter_command.predicate);\n+    }\n+\n+    if (settings.mutations_execute_nondeterministic_on_initiator)\n+    {\n+        ExecuteNonDeterministicConstFunctionsVisitor::Data data{\n+            context, settings.mutations_max_literal_size_to_replace};\n+\n+        ExecuteNonDeterministicConstFunctionsVisitor visitor(data);\n+        if (new_alter_command.update_assignments)\n+            visitor.visit(new_alter_command.update_assignments);\n+        if (new_alter_command.predicate)\n+            visitor.visit(new_alter_command.predicate);\n+    }\n+\n+    return query;\n+}\n+\n }\ndiff --git a/src/Interpreters/MutationsNonDeterministicHelpers.h b/src/Interpreters/MutationsNonDeterministicHelpers.h\nindex eb3a3b1c7a45..5d9aa9752f16 100644\n--- a/src/Interpreters/MutationsNonDeterministicHelpers.h\n+++ b/src/Interpreters/MutationsNonDeterministicHelpers.h\n@@ -7,6 +7,7 @@ namespace DB\n {\n \n struct MutationCommand;\n+class ASTAlterCommand;\n \n struct FirstNonDeterministicFunctionResult\n {\n@@ -18,4 +19,9 @@ struct FirstNonDeterministicFunctionResult\n /// may also be non-deterministic in expressions of mutation command.\n FirstNonDeterministicFunctionResult findFirstNonDeterministicFunction(const MutationCommand & command, ContextPtr context);\n \n+/// Executes non-deterministic functions and subqueries in expressions of mutation\n+/// command and replaces them to the literals with a result of expressions.\n+/// Returns rewritten query if expressions were replaced, nullptr otherwise.\n+ASTPtr replaceNonDeterministicToScalars(const ASTAlterCommand & alter_command, ContextPtr context);\n+\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.reference b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.reference\nnew file mode 100644\nindex 000000000000..729d6cc94e64\n--- /dev/null\n+++ b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.reference\n@@ -0,0 +1,10 @@\n+10\t4950\n+UPDATE v = _CAST(4950, \\'Nullable(UInt64)\\') WHERE 1\n+10\t[0,1,2,3,4,5,6,7,8,9]\n+UPDATE v = _CAST([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], \\'Array(UInt64)\\') WHERE 1\n+10\t5\n+UPDATE v = _CAST(\\'\u0005\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\u0001\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\u0004\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\u0002\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\u0003\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0\\', \\'AggregateFunction(uniqExact, UInt64)\\') WHERE 1\n+10\t1\n+UPDATE v = _CAST(timestamp, \\'DateTime\\') WHERE 1\n+UPDATE v = (SELECT sum(number) FROM numbers(1000) WHERE number > randConstant()) WHERE 1\n+20\t2100-10-10 00:00:00\ndiff --git a/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.sql b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.sql\nnew file mode 100644\nindex 000000000000..b0e1b5c54fbc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.sql\n@@ -0,0 +1,134 @@\n+DROP TABLE IF EXISTS t_mutations_nondeterministic SYNC;\n+\n+SET mutations_sync = 2;\n+SET mutations_execute_subqueries_on_initiator = 1;\n+SET mutations_execute_nondeterministic_on_initiator = 1;\n+\n+-- SELECT sum(...)\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v UInt64)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, 20);\n+\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = (SELECT sum(number) FROM numbers(100)) WHERE 1;\n+\n+SELECT id, v FROM t_mutations_nondeterministic ORDER BY id;\n+\n+SELECT command FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND is_done\n+ORDER BY command;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- SELECT groupArray(...)\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v Array(UInt64))\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, [20]);\n+\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = (SELECT groupArray(number) FROM numbers(10)) WHERE 1;\n+\n+SELECT id, v FROM t_mutations_nondeterministic ORDER BY id;\n+\n+-- Too big result.\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = (SELECT groupArray(number) FROM numbers(10000)) WHERE 1; -- { serverError BAD_ARGUMENTS }\n+\n+SELECT command FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND is_done\n+ORDER BY command;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- SELECT uniqExactState(...)\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v AggregateFunction(uniqExact, UInt64))\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, initializeAggregation('uniqExactState', 1::UInt64));\n+\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = (SELECT uniqExactState(number) FROM numbers(5)) WHERE 1;\n+\n+SELECT id, finalizeAggregation(v) FROM t_mutations_nondeterministic ORDER BY id;\n+\n+SELECT command FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND is_done\n+ORDER BY command;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- now()\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v DateTime)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, '2020-10-10');\n+\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = now() WHERE 1;\n+\n+SELECT id, v BETWEEN now() - INTERVAL 10 MINUTE AND now() FROM t_mutations_nondeterministic;\n+\n+SELECT\n+    replaceRegexpOne(command, '(\\\\d{10})', 'timestamp'),\n+FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND is_done\n+ORDER BY command;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- filesystem(...)\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v UInt64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1') ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, 10);\n+\n+ALTER TABLE t_mutations_nondeterministic UPDATE v = filesystemCapacity(materialize('default')) WHERE 1; -- { serverError BAD_ARGUMENTS }\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- UPDATE SELECT randConstant()\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, v UInt64)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, 10);\n+\n+-- Check that function in subquery is not rewritten.\n+ALTER TABLE t_mutations_nondeterministic\n+UPDATE v =\n+(\n+    SELECT sum(number) FROM numbers(1000) WHERE number > randConstant()\n+) WHERE 1\n+SETTINGS mutations_execute_subqueries_on_initiator = 0, allow_nondeterministic_mutations = 1;\n+\n+SELECT command FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND is_done\n+ORDER BY command;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n+\n+-- DELETE WHERE now()\n+\n+CREATE TABLE t_mutations_nondeterministic (id UInt64, d DateTime)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/02842_mutations_replace', '1')\n+ORDER BY id;\n+\n+INSERT INTO t_mutations_nondeterministic VALUES (10, '2000-10-10'), (20, '2100-10-10');\n+\n+ALTER TABLE t_mutations_nondeterministic DELETE WHERE d < now();\n+\n+SELECT\n+    replaceRegexpOne(command, '(\\\\d{10})', 'timestamp'),\n+FROM system.mutations\n+WHERE database = currentDatabase() AND table = 't_mutations_nondeterministic' AND NOT is_done\n+ORDER BY command;\n+\n+SELECT id, d FROM t_mutations_nondeterministic ORDER BY id;\n+\n+DROP TABLE t_mutations_nondeterministic SYNC;\n",
  "problem_statement": "materialize now() for mutations\nthis \r\n```sql\r\nalter table t UPDATE ts = now() where 1\r\n```\r\n\r\nleads to \r\n\r\n```\r\nData after mutation is not byte-identical to data on another replicas.\r\n```\r\nif `allow_nondeterministic_mutations=1`.\r\n\r\nBut Clickhouse can substitute `now()` with the current time during alter \"parsing\".\r\nor with a mutation's create time during execution (the same as now() = merge task's create time)\n",
  "hints_text": ">But Clickhouse can substitute now() with the current time when during after \"parsing\".\r\n\r\nIt is an interesting suggestion. For most queries it can be done on analyzer stage. And we can add a setting how to treat `now()` and potentially separate `nowPerBlock()` function that will not be the same for different blocks.",
  "created_at": "2023-08-07T17:17:52Z",
  "modified_files": [
    "docs/en/operations/settings/settings.md",
    "src/Core/Settings.h",
    "src/Interpreters/InterpreterAlterQuery.cpp",
    "src/Interpreters/MutationsNonDeterministicHelpers.cpp",
    "src/Interpreters/MutationsNonDeterministicHelpers.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.reference",
    "b/tests/queries/0_stateless/02842_mutations_replace_non_deterministic.sql"
  ]
}