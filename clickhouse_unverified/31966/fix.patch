diff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h
index 0398ec5cbac1..b8498b6c84b1 100644
--- a/src/Core/DecimalComparison.h
+++ b/src/Core/DecimalComparison.h
@@ -52,7 +52,6 @@ struct DecCompareInt
     using TypeB = Type;
 };
 
-///
 template <typename A, typename B, template <typename, typename> typename Operation, bool _check_overflow = true,
     bool _actual = is_decimal<A> || is_decimal<B>>
 class DecimalComparison
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 85644b6f6cae..9f3458b1ecef 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -506,7 +506,7 @@ inline bool isNotCreatable(const T & data_type)
 inline bool isNotDecimalButComparableToDecimal(const DataTypePtr & data_type)
 {
     WhichDataType which(data_type);
-    return which.isInt() || which.isUInt();
+    return which.isInt() || which.isUInt() || which.isFloat();
 }
 
 inline bool isCompilableType(const DataTypePtr & data_type)
diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h
index 945090781dcc..a0c7fc643d2a 100644
--- a/src/Functions/FunctionsComparison.h
+++ b/src/Functions/FunctionsComparison.h
@@ -11,17 +11,17 @@
 #include <Columns/ColumnTuple.h>
 #include <Columns/ColumnArray.h>
 
-#include <DataTypes/DataTypesNumber.h>
-#include <DataTypes/DataTypeNullable.h>
-#include <DataTypes/DataTypeNothing.h>
+#include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
-#include <DataTypes/DataTypeDate.h>
-#include <DataTypes/DataTypeString.h>
-#include <DataTypes/DataTypeUUID.h>
+#include <DataTypes/DataTypeEnum.h>
 #include <DataTypes/DataTypeFixedString.h>
+#include <DataTypes/DataTypeNothing.h>
+#include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeTuple.h>
-#include <DataTypes/DataTypeEnum.h>
+#include <DataTypes/DataTypeUUID.h>
+#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/getLeastSupertype.h>
 
 #include <Interpreters/convertFieldToType.h>
@@ -1175,8 +1175,11 @@ class FunctionComparison : public IFunction
         const bool left_is_num = col_left_untyped->isNumeric();
         const bool right_is_num = col_right_untyped->isNumeric();
 
-        const bool left_is_string = isStringOrFixedString(which_left);
-        const bool right_is_string = isStringOrFixedString(which_right);
+        const bool left_is_string = which_left.isStringOrFixedString();
+        const bool right_is_string = which_right.isStringOrFixedString();
+
+        const bool left_is_float = which_left.isFloat();
+        const bool right_is_float = which_right.isFloat();
 
         bool date_and_datetime = (which_left.idx != which_right.idx) && (which_left.isDate() || which_left.isDate32() || which_left.isDateTime() || which_left.isDateTime64())
             && (which_right.isDate() || which_right.isDate32() || which_right.isDateTime() || which_right.isDateTime64());
@@ -1232,11 +1235,23 @@ class FunctionComparison : public IFunction
             }
             else
             {
-                // compare
+                /// Check does another data type is comparable to Decimal, includes Int and Float.
                 if (!allowDecimalComparison(left_type, right_type) && !date_and_datetime)
                     throw Exception(
                         "No operation " + getName() + " between " + left_type->getName() + " and " + right_type->getName(),
                         ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+                /// When Decimal comparing to Float32/64, we convert both of them into Float64.
+                /// Other systems like MySQL and Spark also do as this.
+                if (left_is_float || right_is_float)
+                {
+                    const auto converted_type = std::make_shared<DataTypeFloat64>();
+                    ColumnPtr c0_converted = castColumn(col_with_type_and_name_left, converted_type);
+                    ColumnPtr c1_converted = castColumn(col_with_type_and_name_right, converted_type);
+
+                    auto new_arguments
+                        = ColumnsWithTypeAndName{{c0_converted, converted_type, "left"}, {c1_converted, converted_type, "right"}};
+                    return executeImpl(new_arguments, result_type, input_rows_count);
+                }
                 return executeDecimal(col_with_type_and_name_left, col_with_type_and_name_right);
             }
 
