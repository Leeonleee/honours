diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index 8ccf95deadc7..2882c4e0c020 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -760,4 +760,26 @@ QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_ty
     return function_node;
 }
 
+QueryTreeNodePtr buildSubqueryToReadColumnsFromTableExpression(QueryTreeNodePtr table_node, const ContextPtr & context)
+{
+    const auto & storage_snapshot = table_node->as<TableNode>()->getStorageSnapshot();
+    auto columns_to_select = storage_snapshot->getColumns(GetColumnsOptions(GetColumnsOptions::Ordinary));
+    size_t columns_to_select_size = columns_to_select.size();
+    auto column_nodes_to_select = std::make_shared<ListNode>();
+    column_nodes_to_select->getNodes().reserve(columns_to_select_size);
+    NamesAndTypes projection_columns;
+    projection_columns.reserve(columns_to_select_size);
+    for (auto & column : columns_to_select)
+    {
+        column_nodes_to_select->getNodes().emplace_back(std::make_shared<ColumnNode>(column, table_node));
+        projection_columns.emplace_back(column.name, column.type);
+    }
+    auto subquery_for_table = std::make_shared<QueryNode>(Context::createCopy(context));
+    subquery_for_table->setIsSubquery(true);
+    subquery_for_table->getProjectionNode() = std::move(column_nodes_to_select);
+    subquery_for_table->getJoinTree() = std::move(table_node);
+    subquery_for_table->resolveProjectionColumns(std::move(projection_columns));
+    return subquery_for_table;
+}
+
 }
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index 8e32ef0464c1..1b4a7d5ef3c9 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -105,4 +105,7 @@ NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);
 /// Wrap node into `_CAST` function
 QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_type, ContextPtr context);
 
+/// Build subquery which we execute for `IN table` function.
+QueryTreeNodePtr buildSubqueryToReadColumnsFromTableExpression(QueryTreeNodePtr table_node, const ContextPtr & context);
+
 }
diff --git a/src/Planner/CollectSets.cpp b/src/Planner/CollectSets.cpp
index e150b8a5956b..f00b1e6ab164 100644
--- a/src/Planner/CollectSets.cpp
+++ b/src/Planner/CollectSets.cpp
@@ -89,27 +89,8 @@ class CollectSetsVisitor : public ConstInDepthQueryTreeVisitor<CollectSetsVisito
                 return;
 
             auto subquery_to_execute = in_second_argument;
-            if (auto * table_node = in_second_argument->as<TableNode>())
-            {
-                auto storage_snapshot = table_node->getStorageSnapshot();
-                auto columns_to_select = storage_snapshot->getColumns(GetColumnsOptions(GetColumnsOptions::Ordinary));
-                size_t columns_to_select_size = columns_to_select.size();
-                auto column_nodes_to_select = std::make_shared<ListNode>();
-                column_nodes_to_select->getNodes().reserve(columns_to_select_size);
-                NamesAndTypes projection_columns;
-                projection_columns.reserve(columns_to_select_size);
-                for (auto & column : columns_to_select)
-                {
-                    column_nodes_to_select->getNodes().emplace_back(std::make_shared<ColumnNode>(column, subquery_to_execute));
-                    projection_columns.emplace_back(column.name, column.type);
-                }
-                auto subquery_for_table = std::make_shared<QueryNode>(Context::createCopy(planner_context.getQueryContext()));
-                subquery_for_table->setIsSubquery(true);
-                subquery_for_table->getProjectionNode() = std::move(column_nodes_to_select);
-                subquery_for_table->getJoinTree() = std::move(subquery_to_execute);
-                subquery_for_table->resolveProjectionColumns(std::move(projection_columns));
-                subquery_to_execute = std::move(subquery_for_table);
-            }
+            if (in_second_argument->as<TableNode>())
+                subquery_to_execute = buildSubqueryToReadColumnsFromTableExpression(std::move(subquery_to_execute), planner_context.getQueryContext());
 
             sets.addFromSubquery(set_key, std::move(subquery_to_execute), settings);
         }
diff --git a/src/Storages/buildQueryTreeForShard.cpp b/src/Storages/buildQueryTreeForShard.cpp
index 5284f52a7e42..5bbdbe487b00 100644
--- a/src/Storages/buildQueryTreeForShard.cpp
+++ b/src/Storages/buildQueryTreeForShard.cpp
@@ -361,10 +361,14 @@ QueryTreeNodePtr buildQueryTreeForShard(const PlannerContextPtr & planner_contex
         {
             auto & in_function_subquery_node = in_function_node->getArguments().getNodes().at(1);
             auto in_function_node_type = in_function_subquery_node->getNodeType();
-            if (in_function_node_type != QueryTreeNodeType::QUERY && in_function_node_type != QueryTreeNodeType::UNION)
+            if (in_function_node_type != QueryTreeNodeType::QUERY && in_function_node_type != QueryTreeNodeType::UNION && in_function_node_type != QueryTreeNodeType::TABLE)
                 continue;
 
-            auto temporary_table_expression_node = executeSubqueryNode(in_function_subquery_node,
+            auto subquery_to_execute = in_function_subquery_node;
+            if (subquery_to_execute->as<TableNode>())
+                subquery_to_execute = buildSubqueryToReadColumnsFromTableExpression(std::move(subquery_to_execute), planner_context->getQueryContext());
+
+            auto temporary_table_expression_node = executeSubqueryNode(subquery_to_execute,
                 planner_context->getMutableQueryContext(),
                 global_in_or_join_node.subquery_depth);
 
