diff --git a/src/DataTypes/DataTypeFixedString.h b/src/DataTypes/DataTypeFixedString.h
index d82ea9824f35..f88d2f5337ab 100644
--- a/src/DataTypes/DataTypeFixedString.h
+++ b/src/DataTypes/DataTypeFixedString.h
@@ -2,6 +2,7 @@
 
 #include <DataTypes/IDataType.h>
 #include <Common/PODArray_fwd.h>
+#include <Common/Exception.h>
 
 #define MAX_FIXEDSTRING_SIZE 0xFFFFFF
 
diff --git a/src/Functions/ngrams.cpp b/src/Functions/ngrams.cpp
new file mode 100644
index 000000000000..c5ce65537cb1
--- /dev/null
+++ b/src/Functions/ngrams.cpp
@@ -0,0 +1,126 @@
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeFixedString.h>
+#include <Columns/ColumnString.h>
+#include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnArray.h>
+#include <Interpreters/Context_fwd.h>
+#include <Interpreters/ITokenExtractor.h>
+#include <Functions/IFunction.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/FunctionFactory.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+}
+
+class FunctionNgrams : public IFunction
+{
+public:
+
+    static constexpr auto name = "ngrams";
+
+    static FunctionPtr create(ContextPtr)
+    {
+        return std::make_shared<FunctionNgrams>();
+    }
+
+    String getName() const override { return name; }
+
+    size_t getNumberOfArguments() const override { return 2; }
+    bool isVariadic() const override { return false; }
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+
+    bool useDefaultImplementationForNulls() const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    bool useDefaultImplementationForLowCardinalityColumns() const override { return true; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        auto ngram_input_argument_type = WhichDataType(arguments[0].type);
+        if (!ngram_input_argument_type.isStringOrFixedString())
+            throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                "Function {} second argument type should be String or FixedString. Actual {}",
+                getName(),
+                arguments[0].type->getName());
+
+        const auto & column_with_type = arguments[1];
+        const auto & ngram_argument_column = arguments[1].column;
+        auto ngram_argument_type = WhichDataType(column_with_type.type);
+
+        if (!ngram_argument_type.isNativeUInt() || !ngram_argument_column || !isColumnConst(*ngram_argument_column))
+            throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                "Function {} second argument type should be constant UInt. Actual {}",
+                getName(),
+                arguments[1].type->getName());
+
+        Field ngram_argument_value;
+        ngram_argument_column->get(0, ngram_argument_value);
+        auto ngram_value = ngram_argument_value.safeGet<UInt64>();
+
+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeFixedString>(ngram_value));
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t) const override
+    {
+        Field ngram_argument_value;
+        arguments[1].column->get(0, ngram_argument_value);
+        auto ngram_value = ngram_argument_value.safeGet<UInt64>();
+
+        NgramTokenExtractor extractor(ngram_value);
+
+        auto result_column_fixed_string = ColumnFixedString::create(ngram_value);
+        auto column_offsets = ColumnArray::ColumnOffsets::create();
+
+        auto input_column = arguments[0].column;
+        if (const auto * column_string = checkAndGetColumn<ColumnString>(input_column.get()))
+            executeImpl(extractor, *column_string, *result_column_fixed_string, *column_offsets);
+        else if (const auto * column_fixed_string = checkAndGetColumn<ColumnFixedString>(input_column.get()))
+            executeImpl(extractor, *column_fixed_string, *result_column_fixed_string, *column_offsets);
+
+        return ColumnArray::create(std::move(result_column_fixed_string), std::move(column_offsets));
+    }
+
+private:
+
+    template <typename StringColumnType>
+    inline void executeImpl(const NgramTokenExtractor & extractor, StringColumnType & input_data_column, ColumnFixedString & result_data_column, ColumnArray::ColumnOffsets & offsets_column) const
+    {
+        size_t current_tokens_size = 0;
+        auto & offsets_data = offsets_column.getData();
+
+        size_t column_size = input_data_column.size();
+        offsets_data.resize(column_size);
+
+        for (size_t i = 0; i < column_size; ++i)
+        {
+            auto data = input_data_column.getDataAt(i);
+
+            size_t cur = 0;
+            size_t token_start = 0;
+            size_t token_length = 0;
+
+            while (cur < data.size && extractor.nextInString(data.data, data.size, &cur, &token_start, &token_length))
+            {
+                result_data_column.insertData(data.data + token_start, token_length);
+                ++current_tokens_size;
+            }
+
+            offsets_data[i] = current_tokens_size;
+        }
+    }
+};
+
+void registerFunctionNgrams(FunctionFactory & factory)
+{
+    factory.registerFunction<FunctionNgrams>();
+}
+
+}
+
+
diff --git a/src/Functions/registerFunctions.cpp b/src/Functions/registerFunctions.cpp
index 4733829de56a..35193e9be8d0 100644
--- a/src/Functions/registerFunctions.cpp
+++ b/src/Functions/registerFunctions.cpp
@@ -37,6 +37,7 @@ void registerFunctionsStringArray(FunctionFactory &);
 void registerFunctionsStringSearch(FunctionFactory &);
 void registerFunctionsStringRegexp(FunctionFactory &);
 void registerFunctionsStringSimilarity(FunctionFactory &);
+void registerFunctionNgrams(FunctionFactory &);
 void registerFunctionsURL(FunctionFactory &);
 void registerFunctionsVisitParam(FunctionFactory &);
 void registerFunctionsMath(FunctionFactory &);
@@ -103,6 +104,7 @@ void registerFunctions()
     registerFunctionsStringSearch(factory);
     registerFunctionsStringRegexp(factory);
     registerFunctionsStringSimilarity(factory);
+    registerFunctionNgrams(factory);
     registerFunctionsURL(factory);
     registerFunctionsVisitParam(factory);
     registerFunctionsMath(factory);
diff --git a/src/Interpreters/ITokenExtractor.cpp b/src/Interpreters/ITokenExtractor.cpp
new file mode 100644
index 000000000000..83166079e898
--- /dev/null
+++ b/src/Interpreters/ITokenExtractor.cpp
@@ -0,0 +1,242 @@
+#include "ITokenExtractor.h"
+
+#include <boost/algorithm/string.hpp>
+
+#include <Common/StringUtils/StringUtils.h>
+#include <Common/UTF8Helpers.h>
+
+#if defined(__SSE2__)
+#include <immintrin.h>
+
+#if defined(__SSE4_2__)
+#include <nmmintrin.h>
+#endif
+
+#endif
+
+
+namespace DB
+{
+
+bool NgramTokenExtractor::nextInString(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const
+{
+    *token_start = *pos;
+    *token_length = 0;
+    size_t code_points = 0;
+    for (; code_points < n && *token_start + *token_length < length; ++code_points)
+    {
+        size_t sz = UTF8::seqLength(static_cast<UInt8>(data[*token_start + *token_length]));
+        *token_length += sz;
+    }
+    *pos += UTF8::seqLength(static_cast<UInt8>(data[*pos]));
+    return code_points == n;
+}
+
+bool NgramTokenExtractor::nextInStringLike(const char * data, size_t length, size_t * pos, String & token) const
+{
+    token.clear();
+
+    size_t code_points = 0;
+    bool escaped = false;
+    for (size_t i = *pos; i < length;)
+    {
+        if (escaped && (data[i] == '%' || data[i] == '_' || data[i] == '\\'))
+        {
+            token += data[i];
+            ++code_points;
+            escaped = false;
+            ++i;
+        }
+        else if (!escaped && (data[i] == '%' || data[i] == '_'))
+        {
+            /// This token is too small, go to the next.
+            token.clear();
+            code_points = 0;
+            escaped = false;
+            *pos = ++i;
+        }
+        else if (!escaped && data[i] == '\\')
+        {
+            escaped = true;
+            ++i;
+        }
+        else
+        {
+            const size_t sz = UTF8::seqLength(static_cast<UInt8>(data[i]));
+            for (size_t j = 0; j < sz; ++j)
+                token += data[i + j];
+            i += sz;
+            ++code_points;
+            escaped = false;
+        }
+
+        if (code_points == n)
+        {
+            *pos += UTF8::seqLength(static_cast<UInt8>(data[*pos]));
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool SplitTokenExtractor::nextInString(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const
+{
+    *token_start = *pos;
+    *token_length = 0;
+
+    while (*pos < length)
+    {
+        if (isASCII(data[*pos]) && !isAlphaNumericASCII(data[*pos]))
+        {
+            /// Finish current token if any
+            if (*token_length > 0)
+                return true;
+            *token_start = ++*pos;
+        }
+        else
+        {
+            /// Note that UTF-8 sequence is completely consisted of non-ASCII bytes.
+            ++*pos;
+            ++*token_length;
+        }
+    }
+
+    return *token_length > 0;
+}
+
+bool SplitTokenExtractor::nextInStringPadded(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const
+{
+    *token_start = *pos;
+    *token_length = 0;
+
+    while (*pos < length)
+    {
+#if defined(__SSE2__) && !defined(MEMORY_SANITIZER) /// We read uninitialized bytes and decide on the calculated mask
+        // NOTE: we assume that `data` string is padded from the right with 15 bytes.
+        const __m128i haystack = _mm_loadu_si128(reinterpret_cast<const __m128i *>(data + *pos));
+        const size_t haystack_length = 16;
+
+#if defined(__SSE4_2__)
+        // With the help of https://www.strchr.com/strcmp_and_strlen_using_sse_4.2
+        const auto alnum_chars_ranges = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,
+                '\xFF', '\x80', 'z', 'a', 'Z', 'A', '9', '0');
+        // Every bit represents if `haystack` character is in the ranges (1) or not (0)
+        const int result_bitmask = _mm_cvtsi128_si32(_mm_cmpestrm(alnum_chars_ranges, 8, haystack, haystack_length, _SIDD_CMP_RANGES));
+#else
+        // NOTE: -1 and +1 required since SSE2 has no `>=` and `<=` instructions on packed 8-bit integers (epi8).
+        const auto number_begin =      _mm_set1_epi8('0' - 1);
+        const auto number_end =        _mm_set1_epi8('9' + 1);
+        const auto alpha_lower_begin = _mm_set1_epi8('a' - 1);
+        const auto alpha_lower_end =   _mm_set1_epi8('z' + 1);
+        const auto alpha_upper_begin = _mm_set1_epi8('A' - 1);
+        const auto alpha_upper_end =   _mm_set1_epi8('Z' + 1);
+        const auto zero =              _mm_set1_epi8(0);
+
+        // every bit represents if `haystack` character `c` satisfies condition:
+        // (c < 0) || (c > '0' - 1 && c < '9' + 1) || (c > 'a' - 1 && c < 'z' + 1) || (c > 'A' - 1 && c < 'Z' + 1)
+        // < 0 since _mm_cmplt_epi8 threats chars as SIGNED, and so all chars > 0x80 are negative.
+        const int result_bitmask = _mm_movemask_epi8(_mm_or_si128(_mm_or_si128(_mm_or_si128(
+                _mm_cmplt_epi8(haystack, zero),
+                _mm_and_si128(_mm_cmpgt_epi8(haystack, number_begin),      _mm_cmplt_epi8(haystack, number_end))),
+                _mm_and_si128(_mm_cmpgt_epi8(haystack, alpha_lower_begin), _mm_cmplt_epi8(haystack, alpha_lower_end))),
+                _mm_and_si128(_mm_cmpgt_epi8(haystack, alpha_upper_begin), _mm_cmplt_epi8(haystack, alpha_upper_end))));
+#endif
+        if (result_bitmask == 0)
+        {
+            if (*token_length != 0)
+                // end of token started on previous haystack
+                return true;
+
+            *pos += haystack_length;
+            continue;
+        }
+
+        const auto token_start_pos_in_current_haystack = getTrailingZeroBitsUnsafe(result_bitmask);
+        if (*token_length == 0)
+            // new token
+            *token_start = *pos + token_start_pos_in_current_haystack;
+        else if (token_start_pos_in_current_haystack != 0)
+            // end of token starting in one of previous haystacks
+            return true;
+
+        const auto token_bytes_in_current_haystack = getTrailingZeroBitsUnsafe(~(result_bitmask >> token_start_pos_in_current_haystack));
+        *token_length += token_bytes_in_current_haystack;
+
+        *pos += token_start_pos_in_current_haystack + token_bytes_in_current_haystack;
+        if (token_start_pos_in_current_haystack + token_bytes_in_current_haystack == haystack_length)
+            // check if there are leftovers in next `haystack`
+            continue;
+
+        break;
+#else
+        if (isASCII(data[*pos]) && !isAlphaNumericASCII(data[*pos]))
+        {
+            /// Finish current token if any
+            if (*token_length > 0)
+                return true;
+            *token_start = ++*pos;
+        }
+        else
+        {
+            /// Note that UTF-8 sequence is completely consisted of non-ASCII bytes.
+            ++*pos;
+            ++*token_length;
+        }
+#endif
+    }
+
+#if defined(__SSE2__) && !defined(MEMORY_SANITIZER)
+    // Could happen only if string is not padded with zeros, and we accidentally hopped over the end of data.
+    if (*token_start > length)
+        return false;
+    *token_length = std::min(length - *token_start, *token_length);
+#endif
+
+    return *token_length > 0;
+}
+
+bool SplitTokenExtractor::nextInStringLike(const char * data, size_t length, size_t * pos, String & token) const
+{
+    token.clear();
+    bool bad_token = false; // % or _ before token
+    bool escaped = false;
+    while (*pos < length)
+    {
+        if (!escaped && (data[*pos] == '%' || data[*pos] == '_'))
+        {
+            token.clear();
+            bad_token = true;
+            ++*pos;
+        }
+        else if (!escaped && data[*pos] == '\\')
+        {
+            escaped = true;
+            ++*pos;
+        }
+        else if (isASCII(data[*pos]) && !isAlphaNumericASCII(data[*pos]))
+        {
+            if (!bad_token && !token.empty())
+                return true;
+
+            token.clear();
+            bad_token = false;
+            escaped = false;
+            ++*pos;
+        }
+        else
+        {
+            const size_t sz = UTF8::seqLength(static_cast<UInt8>(data[*pos]));
+            for (size_t j = 0; j < sz; ++j)
+            {
+                token += data[*pos];
+                ++*pos;
+            }
+            escaped = false;
+        }
+    }
+
+    return !bad_token && !token.empty();
+}
+
+}
diff --git a/src/Interpreters/ITokenExtractor.h b/src/Interpreters/ITokenExtractor.h
new file mode 100644
index 000000000000..afcc8442d583
--- /dev/null
+++ b/src/Interpreters/ITokenExtractor.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include <base/types.h>
+
+#include <Interpreters/BloomFilter.h>
+
+
+namespace DB
+{
+
+/// Interface for string parsers.
+struct ITokenExtractor
+{
+    virtual ~ITokenExtractor() = default;
+
+    /// Fast inplace implementation for regular use.
+    /// Gets string (data ptr and len) and start position for extracting next token (state of extractor).
+    /// Returns false if parsing is finished, otherwise returns true.
+    virtual bool nextInString(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const = 0;
+
+    /// Optimized version that can assume at least 15 padding bytes after data + len (as our Columns provide).
+    virtual bool nextInStringPadded(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const
+    {
+        return nextInString(data, length, pos, token_start, token_length);
+    }
+
+    /// Special implementation for creating bloom filter for LIKE function.
+    /// It skips unescaped `%` and `_` and supports escaping symbols, but it is less lightweight.
+    virtual bool nextInStringLike(const char * data, size_t length, size_t * pos, String & out) const = 0;
+
+    virtual void stringToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const = 0;
+
+    virtual void stringPaddedToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const
+    {
+        return stringToBloomFilter(data, length, bloom_filter);
+    }
+
+    virtual void stringLikeToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const = 0;
+
+};
+
+using TokenExtractorPtr = const ITokenExtractor *;
+
+template <typename Derived>
+class ITokenExtractorHelper : public ITokenExtractor
+{
+    void stringToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const override
+    {
+        size_t cur = 0;
+        size_t token_start = 0;
+        size_t token_len = 0;
+
+        while (cur < length && static_cast<const Derived *>(this)->nextInString(data, length, &cur, &token_start, &token_len))
+            bloom_filter.add(data + token_start, token_len);
+    }
+
+    void stringPaddedToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const override
+    {
+        size_t cur = 0;
+        size_t token_start = 0;
+        size_t token_len = 0;
+
+        while (cur < length && static_cast<const Derived *>(this)->nextInStringPadded(data, length, &cur, &token_start, &token_len))
+            bloom_filter.add(data + token_start, token_len);
+    }
+
+    void stringLikeToBloomFilter(const char * data, size_t length, BloomFilter & bloom_filter) const override
+    {
+        size_t cur = 0;
+        String token;
+        while (cur < length && static_cast<const Derived *>(this)->nextInStringLike(data, length, &cur, token))
+            bloom_filter.add(token.c_str(), token.size());
+    }
+};
+
+
+/// Parser extracting all ngrams from string.
+struct NgramTokenExtractor final : public ITokenExtractorHelper<NgramTokenExtractor>
+{
+    explicit NgramTokenExtractor(size_t n_) : n(n_) {}
+
+    static const char * getName() { return "ngrambf_v1"; }
+
+    bool nextInString(const char * data, size_t length, size_t *  __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const override;
+
+    bool nextInStringLike(const char * data, size_t length, size_t * pos, String & token) const override;
+
+    size_t getN() const { return n; }
+
+private:
+
+    size_t n;
+};
+
+/// Parser extracting tokens (sequences of numbers and ascii letters).
+struct SplitTokenExtractor final : public ITokenExtractorHelper<SplitTokenExtractor>
+{
+    static const char * getName() { return "tokenbf_v1"; }
+
+    bool nextInString(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const override;
+
+    bool nextInStringPadded(const char * data, size_t length, size_t * __restrict pos, size_t * __restrict token_start, size_t * __restrict token_length) const override;
+
+    bool nextInStringLike(const char * data, size_t length, size_t * __restrict pos, String & token) const override;
+
+};
+
+}
diff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
index beaef6a10806..a8820b3f6d4e 100644
--- a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
@@ -1,7 +1,5 @@
 #include <Storages/MergeTree/MergeTreeIndexFullText.h>
 
-#include <Common/StringUtils/StringUtils.h>
-#include <Common/UTF8Helpers.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeArray.h>
 #include <IO/WriteHelpers.h>
@@ -19,17 +17,6 @@
 
 #include <Poco/Logger.h>
 
-#include <boost/algorithm/string.hpp>
-
-#if defined(__SSE2__)
-#include <immintrin.h>
-
-#if defined(__SSE4_2__)
-#include <nmmintrin.h>
-#endif
-
-#endif
-
 
 namespace DB
 {
@@ -41,52 +28,6 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
 }
 
-
-/// Adds all tokens from string to bloom filter.
-static void stringToBloomFilter(
-    const String & string, TokenExtractorPtr token_extractor, BloomFilter & bloom_filter)
-{
-    const char * data = string.data();
-    size_t size = string.size();
-
-    size_t cur = 0;
-    size_t token_start = 0;
-    size_t token_len = 0;
-    while (cur < size && token_extractor->nextInField(data, size, &cur, &token_start, &token_len))
-        bloom_filter.add(data + token_start, token_len);
-}
-
-static void columnToBloomFilter(
-    const char * data, size_t size, TokenExtractorPtr token_extractor, BloomFilter & bloom_filter)
-{
-    size_t cur = 0;
-    size_t token_start = 0;
-    size_t token_len = 0;
-    while (cur < size && token_extractor->nextInColumn(data, size, &cur, &token_start, &token_len))
-        bloom_filter.add(data + token_start, token_len);
-}
-
-
-/// Adds all tokens from like pattern string to bloom filter. (Because like pattern can contain `\%` and `\_`.)
-static void likeStringToBloomFilter(
-    const String & data, TokenExtractorPtr token_extractor, BloomFilter & bloom_filter)
-{
-    size_t cur = 0;
-    String token;
-    while (cur < data.size() && token_extractor->nextLike(data, &cur, token))
-        bloom_filter.add(token.c_str(), token.size());
-}
-
-/// Unified condition for equals, startsWith and endsWith
-bool MergeTreeConditionFullText::createFunctionEqualsCondition(
-    RPNElement & out, const Field & value, const BloomFilterParameters & params, TokenExtractorPtr token_extractor)
-{
-    out.function = RPNElement::FUNCTION_EQUALS;
-    out.bloom_filter = std::make_unique<BloomFilter>(params);
-    stringToBloomFilter(value.get<String>(), token_extractor, *out.bloom_filter);
-    return true;
-}
-
 MergeTreeIndexGranuleFullText::MergeTreeIndexGranuleFullText(
     const String & index_name_,
     size_t columns_number,
@@ -174,7 +115,7 @@ void MergeTreeIndexAggregatorFullText::update(const Block & block, size_t * pos,
                 for (size_t row_num = 0; row_num < elements_size; row_num++)
                 {
                     auto ref = column_key.getDataAt(element_start_row + row_num);
-                    columnToBloomFilter(ref.data, ref.size, token_extractor, granule->bloom_filters[col]);
+                    token_extractor->stringPaddedToBloomFilter(ref.data, ref.size, granule->bloom_filters[col]);
                 }
 
                 current_position += 1;
@@ -185,7 +126,7 @@ void MergeTreeIndexAggregatorFullText::update(const Block & block, size_t * pos,
             for (size_t i = 0; i < rows_read; ++i)
             {
                 auto ref = column->getDataAt(current_position + i);
-                columnToBloomFilter(ref.data, ref.size, token_extractor, granule->bloom_filters[col]);
+                token_extractor->stringPaddedToBloomFilter(ref.data, ref.size, granule->bloom_filters[col]);
             }
         }
     }
@@ -194,7 +135,6 @@ void MergeTreeIndexAggregatorFullText::update(const Block & block, size_t * pos,
     *pos += rows_read;
 }
 
-
 MergeTreeConditionFullText::MergeTreeConditionFullText(
     const SelectQueryInfo & query_info,
     ContextPtr context,
@@ -454,9 +394,6 @@ bool MergeTreeConditionFullText::traverseASTEquals(
     if (!value_data_type.isStringOrFixedString() && !value_data_type.isArray())
         return false;
 
-    if (!token_extractor->supportLike() && (function_name == "like" || function_name == "notLike"))
-        return false;
-
     Field const_value = value_field;
 
     size_t key_column_num = 0;
@@ -527,8 +464,8 @@ bool MergeTreeConditionFullText::traverseASTEquals(
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_HAS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        stringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
-
+        auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
     else if (function_name == "has")
@@ -536,8 +473,8 @@ bool MergeTreeConditionFullText::traverseASTEquals(
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_HAS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        stringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
-
+        auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
 
@@ -546,20 +483,26 @@ bool MergeTreeConditionFullText::traverseASTEquals(
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_NOT_EQUALS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        stringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
     else if (function_name == "equals")
     {
         out.key_column = key_column_num;
-        return createFunctionEqualsCondition(out, const_value, params, token_extractor);
+        out.function = RPNElement::FUNCTION_EQUALS;
+        out.bloom_filter = std::make_unique<BloomFilter>(params);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
+        return true;
     }
     else if (function_name == "like")
     {
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_EQUALS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        likeStringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringLikeToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
     else if (function_name == "notLike")
@@ -567,7 +510,8 @@ bool MergeTreeConditionFullText::traverseASTEquals(
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_NOT_EQUALS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        likeStringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringLikeToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
     else if (function_name == "hasToken")
@@ -575,18 +519,27 @@ bool MergeTreeConditionFullText::traverseASTEquals(
         out.key_column = key_column_num;
         out.function = RPNElement::FUNCTION_EQUALS;
         out.bloom_filter = std::make_unique<BloomFilter>(params);
-        stringToBloomFilter(const_value.get<String>(), token_extractor, *out.bloom_filter);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
         return true;
     }
     else if (function_name == "startsWith")
     {
         out.key_column = key_column_num;
-        return createFunctionEqualsCondition(out, const_value, params, token_extractor);
+        out.function = RPNElement::FUNCTION_EQUALS;
+        out.bloom_filter = std::make_unique<BloomFilter>(params);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
+        return true;
     }
     else if (function_name == "endsWith")
     {
         out.key_column = key_column_num;
-        return createFunctionEqualsCondition(out, const_value, params, token_extractor);
+        out.function = RPNElement::FUNCTION_EQUALS;
+        out.bloom_filter = std::make_unique<BloomFilter>(params);
+        const auto & value = const_value.get<String>();
+        token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);
+        return true;
     }
     else if (function_name == "multiSearchAny")
     {
@@ -602,7 +555,8 @@ bool MergeTreeConditionFullText::traverseASTEquals(
                 return false;
 
             bloom_filters.back().emplace_back(params);
-            stringToBloomFilter(element.get<String>(), token_extractor, bloom_filters.back().back());
+            const auto & value = element.get<String>();
+            token_extractor->stringToBloomFilter(value.data(), value.size(), bloom_filters.back().back());
         }
         out.set_bloom_filters = std::move(bloom_filters);
         return true;
@@ -681,7 +635,7 @@ bool MergeTreeConditionFullText::tryPrepareSetBloomFilter(
         {
             bloom_filters.back().emplace_back(params);
             auto ref = column->getDataAt(row);
-            columnToBloomFilter(ref.data, ref.size, token_extractor, bloom_filters.back().back());
+            token_extractor->stringPaddedToBloomFilter(ref.data, ref.size, bloom_filters.back().back());
         }
     }
 
@@ -712,230 +666,6 @@ bool MergeTreeIndexFullText::mayBenefitFromIndexForIn(const ASTPtr & node) const
     return std::find(std::cbegin(index.column_names), std::cend(index.column_names), node->getColumnName()) != std::cend(index.column_names);
 }
 
-
-bool NgramTokenExtractor::nextInField(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const
-{
-    *token_start = *pos;
-    *token_len = 0;
-    size_t code_points = 0;
-    for (; code_points < n && *token_start + *token_len < len; ++code_points)
-    {
-        size_t sz = UTF8::seqLength(static_cast<UInt8>(data[*token_start + *token_len]));
-        *token_len += sz;
-    }
-    *pos += UTF8::seqLength(static_cast<UInt8>(data[*pos]));
-    return code_points == n;
-}
-
-bool NgramTokenExtractor::nextLike(const String & str, size_t * pos, String & token) const
-{
-    token.clear();
-
-    size_t code_points = 0;
-    bool escaped = false;
-    for (size_t i = *pos; i < str.size();)
-    {
-        if (escaped && (str[i] == '%' || str[i] == '_' || str[i] == '\\'))
-        {
-            token += str[i];
-            ++code_points;
-            escaped = false;
-            ++i;
-        }
-        else if (!escaped && (str[i] == '%' || str[i] == '_'))
-        {
-            /// This token is too small, go to the next.
-            token.clear();
-            code_points = 0;
-            escaped = false;
-            *pos = ++i;
-        }
-        else if (!escaped && str[i] == '\\')
-        {
-            escaped = true;
-            ++i;
-        }
-        else
-        {
-            const size_t sz = UTF8::seqLength(static_cast<UInt8>(str[i]));
-            for (size_t j = 0; j < sz; ++j)
-                token += str[i + j];
-            i += sz;
-            ++code_points;
-            escaped = false;
-        }
-
-        if (code_points == n)
-        {
-            *pos += UTF8::seqLength(static_cast<UInt8>(str[*pos]));
-            return true;
-        }
-    }
-
-    return false;
-}
-
-
-bool SplitTokenExtractor::nextInField(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const
-{
-    *token_start = *pos;
-    *token_len = 0;
-
-    while (*pos < len)
-    {
-        if (isASCII(data[*pos]) && !isAlphaNumericASCII(data[*pos]))
-        {
-            /// Finish current token if any
-            if (*token_len > 0)
-                return true;
-            *token_start = ++*pos;
-        }
-        else
-        {
-            /// Note that UTF-8 sequence is completely consisted of non-ASCII bytes.
-            ++*pos;
-            ++*token_len;
-        }
-    }
-
-    return *token_len > 0;
-}
-
-bool SplitTokenExtractor::nextInColumn(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const
-{
-    *token_start = *pos;
-    *token_len = 0;
-
-    while (*pos < len)
-    {
-#if defined(__SSE2__) && !defined(MEMORY_SANITIZER) /// We read uninitialized bytes and decide on the calculated mask
-        // NOTE: we assume that `data` string is padded from the right with 15 bytes.
-        const __m128i haystack = _mm_loadu_si128(reinterpret_cast<const __m128i *>(data + *pos));
-        const size_t haystack_length = 16;
-
-#if defined(__SSE4_2__)
-        // With the help of https://www.strchr.com/strcmp_and_strlen_using_sse_4.2
-        const auto alnum_chars_ranges = _mm_set_epi8(0, 0, 0, 0, 0, 0, 0, 0,
-                '\xFF', '\x80', 'z', 'a', 'Z', 'A', '9', '0');
-        // Every bit represents if `haystack` character is in the ranges (1) or not (0)
-        const int result_bitmask = _mm_cvtsi128_si32(_mm_cmpestrm(alnum_chars_ranges, 8, haystack, haystack_length, _SIDD_CMP_RANGES));
-#else
-        // NOTE: -1 and +1 required since SSE2 has no `>=` and `<=` instructions on packed 8-bit integers (epi8).
-        const auto number_begin =      _mm_set1_epi8('0' - 1);
-        const auto number_end =        _mm_set1_epi8('9' + 1);
-        const auto alpha_lower_begin = _mm_set1_epi8('a' - 1);
-        const auto alpha_lower_end =   _mm_set1_epi8('z' + 1);
-        const auto alpha_upper_begin = _mm_set1_epi8('A' - 1);
-        const auto alpha_upper_end =   _mm_set1_epi8('Z' + 1);
-        const auto zero =              _mm_set1_epi8(0);
-
-        // every bit represents if `haystack` character `c` satisfies condition:
-        // (c < 0) || (c > '0' - 1 && c < '9' + 1) || (c > 'a' - 1 && c < 'z' + 1) || (c > 'A' - 1 && c < 'Z' + 1)
-        // < 0 since _mm_cmplt_epi8 threats chars as SIGNED, and so all chars > 0x80 are negative.
-        const int result_bitmask = _mm_movemask_epi8(_mm_or_si128(_mm_or_si128(_mm_or_si128(
-                _mm_cmplt_epi8(haystack, zero),
-                _mm_and_si128(_mm_cmpgt_epi8(haystack, number_begin),      _mm_cmplt_epi8(haystack, number_end))),
-                _mm_and_si128(_mm_cmpgt_epi8(haystack, alpha_lower_begin), _mm_cmplt_epi8(haystack, alpha_lower_end))),
-                _mm_and_si128(_mm_cmpgt_epi8(haystack, alpha_upper_begin), _mm_cmplt_epi8(haystack, alpha_upper_end))));
-#endif
-        if (result_bitmask == 0)
-        {
-            if (*token_len != 0)
-                // end of token started on previous haystack
-                return true;
-
-            *pos += haystack_length;
-            continue;
-        }
-
-        const auto token_start_pos_in_current_haystack = getTrailingZeroBitsUnsafe(result_bitmask);
-        if (*token_len == 0)
-            // new token
-            *token_start = *pos + token_start_pos_in_current_haystack;
-        else if (token_start_pos_in_current_haystack != 0)
-            // end of token starting in one of previous haystacks
-            return true;
-
-        const auto token_bytes_in_current_haystack = getTrailingZeroBitsUnsafe(~(result_bitmask >> token_start_pos_in_current_haystack));
-        *token_len += token_bytes_in_current_haystack;
-
-        *pos += token_start_pos_in_current_haystack + token_bytes_in_current_haystack;
-        if (token_start_pos_in_current_haystack + token_bytes_in_current_haystack == haystack_length)
-            // check if there are leftovers in next `haystack`
-            continue;
-
-        break;
-#else
-        if (isASCII(data[*pos]) && !isAlphaNumericASCII(data[*pos]))
-        {
-            /// Finish current token if any
-            if (*token_len > 0)
-                return true;
-            *token_start = ++*pos;
-        }
-        else
-        {
-            /// Note that UTF-8 sequence is completely consisted of non-ASCII bytes.
-            ++*pos;
-            ++*token_len;
-        }
-#endif
-    }
-
-#if defined(__SSE2__) && !defined(MEMORY_SANITIZER)
-    // Could happen only if string is not padded with zeros, and we accidentally hopped over the end of data.
-    if (*token_start > len)
-        return false;
-    *token_len = std::min(len - *token_start, *token_len);
-#endif
-
-    return *token_len > 0;
-}
-
-bool SplitTokenExtractor::nextLike(const String & str, size_t * pos, String & token) const
-{
-    token.clear();
-    bool bad_token = false; // % or _ before token
-    bool escaped = false;
-    while (*pos < str.size())
-    {
-        if (!escaped && (str[*pos] == '%' || str[*pos] == '_'))
-        {
-            token.clear();
-            bad_token = true;
-            ++*pos;
-        }
-        else if (!escaped && str[*pos] == '\\')
-        {
-            escaped = true;
-            ++*pos;
-        }
-        else if (isASCII(str[*pos]) && !isAlphaNumericASCII(str[*pos]))
-        {
-            if (!bad_token && !token.empty())
-                return true;
-
-            token.clear();
-            bad_token = false;
-            escaped = false;
-            ++*pos;
-        }
-        else
-        {
-            const size_t sz = UTF8::seqLength(static_cast<UInt8>(str[*pos]));
-            for (size_t j = 0; j < sz; ++j)
-            {
-                token += str[*pos];
-                ++*pos;
-            }
-            escaped = false;
-        }
-    }
-
-    return !bad_token && !token.empty();
-}
-
-
 MergeTreeIndexPtr bloomFilterIndexCreator(
     const IndexDescription & index)
 {
diff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.h b/src/Storages/MergeTree/MergeTreeIndexFullText.h
index f8e35fd84da7..1826719df0bd 100644
--- a/src/Storages/MergeTree/MergeTreeIndexFullText.h
+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.h
@@ -1,40 +1,16 @@
 #pragma once
 
-#include <Interpreters/BloomFilter.h>
+#include <memory>
+
 #include <Storages/MergeTree/MergeTreeIndices.h>
 #include <Storages/MergeTree/KeyCondition.h>
-
-#include <memory>
+#include <Interpreters/BloomFilter.h>
+#include <Interpreters/ITokenExtractor.h>
 
 
 namespace DB
 {
 
-/// Interface for string parsers.
-struct ITokenExtractor
-{
-    virtual ~ITokenExtractor() = default;
-
-    /// Fast inplace implementation for regular use.
-    /// Gets string (data ptr and len) and start position for extracting next token (state of extractor).
-    /// Returns false if parsing is finished, otherwise returns true.
-    virtual bool nextInField(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const = 0;
-
-    /// Optimized version that can assume at least 15 padding bytes after data + len (as our Columns provide).
-    virtual bool nextInColumn(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const
-    {
-        return nextInField(data, len, pos, token_start, token_len);
-    }
-
-    /// Special implementation for creating bloom filter for LIKE function.
-    /// It skips unescaped `%` and `_` and supports escaping symbols, but it is less lightweight.
-    virtual bool nextLike(const String & str, size_t * pos, String & out) const = 0;
-
-    virtual bool supportLike() const = 0;
-};
-
-using TokenExtractorPtr = const ITokenExtractor *;
-
 struct MergeTreeIndexGranuleFullText final : public IMergeTreeIndexGranule
 {
     explicit MergeTreeIndexGranuleFullText(
@@ -170,35 +146,6 @@ class MergeTreeConditionFullText final : public IMergeTreeIndexCondition
     PreparedSets prepared_sets;
 };
 
-
-/// Parser extracting all ngrams from string.
-struct NgramTokenExtractor final : public ITokenExtractor
-{
-    NgramTokenExtractor(size_t n_) : n(n_) {}
-
-    static String getName() { return "ngrambf_v1"; }
-
-    bool nextInField(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const override;
-    bool nextLike(const String & str, size_t * pos, String & token) const override;
-
-    bool supportLike() const override { return true; }
-
-    size_t n;
-};
-
-/// Parser extracting tokens (sequences of numbers and ascii letters).
-struct SplitTokenExtractor final : public ITokenExtractor
-{
-    static String getName() { return "tokenbf_v1"; }
-
-    bool nextInField(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const override;
-    bool nextInColumn(const char * data, size_t len, size_t * pos, size_t * token_start, size_t * token_len) const override;
-    bool nextLike(const String & str, size_t * pos, String & token) const override;
-
-    bool supportLike() const override { return true; }
-};
-
-
 class MergeTreeIndexFullText final : public IMergeTreeIndex
 {
 public:
