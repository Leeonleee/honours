{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68644,
  "instance_id": "ClickHouse__ClickHouse-68644",
  "issue_numbers": [
    "68643"
  ],
  "base_commit": "d8bf6bfc07b6400224d4c8e5ccfd2517a234c371",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\nindex b5c6bb95d379..ba3ca2f139ab 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n@@ -128,14 +128,14 @@ void MergeTreeIndexAggregatorFullText::update(const Block & block, size_t * pos,\n                 \"Position: {}, Block rows: {}.\", *pos, block.rows());\n \n     size_t rows_read = std::min(limit, block.rows() - *pos);\n-    auto row_id = store->getNextRowIDRange(rows_read);\n-    auto start_row_id = row_id;\n+    auto start_row_id = store->getNextRowIDRange(rows_read);\n \n     for (size_t col = 0; col < index_columns.size(); ++col)\n     {\n         const auto & column_with_type = block.getByName(index_columns[col]);\n         const auto & column = column_with_type.column;\n         size_t current_position = *pos;\n+        auto row_id = start_row_id;\n \n         bool need_to_write = false;\n         if (isArray(column_with_type.type))\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03228_full_text_with_multi_col.reference b/tests/queries/0_stateless/03228_full_text_with_multi_col.reference\nnew file mode 100644\nindex 000000000000..9f721a82e591\n--- /dev/null\n+++ b/tests/queries/0_stateless/03228_full_text_with_multi_col.reference\n@@ -0,0 +1,2 @@\n+Query column at granularity boundary\n+0,0\t0,1\ndiff --git a/tests/queries/0_stateless/03228_full_text_with_multi_col.sql b/tests/queries/0_stateless/03228_full_text_with_multi_col.sql\nnew file mode 100644\nindex 000000000000..e1c78c5ffda5\n--- /dev/null\n+++ b/tests/queries/0_stateless/03228_full_text_with_multi_col.sql\n@@ -0,0 +1,18 @@\n+SET allow_experimental_full_text_index=1;\n+\n+DROP TABLE IF EXISTS multi_col_ivt;\n+\n+CREATE TABLE tab (\n+    v0 String,\n+    v1 String,\n+    INDEX idx (v0, v1) TYPE full_text GRANULARITY 1)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+SETTINGS index_granularity = 1;\n+\n+INSERT INTO tab VALUES('0,0', '0,1')('2,2','2,3');\n+\n+SELECT 'Query column at granularity boundary';\n+SELECT * FROM tab WHERE hasToken(v1, '1');\n+\n+DROP TABLE tab;\n",
  "problem_statement": "Full text index may filter out wrong columns when index multiple columns\n**Describe the unexpected behaviour**\r\nWhen using full text index with multiple columns, it may filter out some rows which contains the data.\r\n\r\n**How to reproduce**\r\n```sql\r\nCREATE TABLE tab (\r\n    v0 String,\r\n    v1 String,\r\n    INDEX idx (v0, v1) TYPE full_text GRANULARITY 1)\r\nENGINE = MergeTree\r\nORDER BY tuple()\r\nSETTINGS index_granularity = 1;\r\n\r\nINSERT INTO tab VALUES('0,0', '0,1')('2,2','2,3');\r\n\r\n-- Return 0 rows\r\nSELECT * FROM tab WHERE hasToken(v1, '1');\r\n```\r\n\r\n**Expected behavior**\r\n```sql\r\n--   \u250f\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2513\r\n--   \u2503 v0  \u2503 v1  \u2503\r\n--   \u2521\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2529\r\n--1. \u2502 0,0 \u2502 0,1 \u2502\r\n--   \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\r\nSELECT * FROM tab WHERE hasToken(v1, '1');\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2024-08-21T08:01:24Z"
}