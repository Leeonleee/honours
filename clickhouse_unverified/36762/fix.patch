diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp
index 64c7a84c263f..c862aa0c3449 100644
--- a/src/Columns/ColumnObject.cpp
+++ b/src/Columns/ColumnObject.cpp
@@ -334,7 +334,6 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
 void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t start, size_t length)
 {
     assert(src.isFinalized());
-
     const auto & src_column = src.data.back();
     const auto & src_type = src.least_common_type.get();
 
@@ -646,9 +645,17 @@ void ColumnObject::get(size_t n, Field & res) const
     }
 }
 
+void ColumnObject::insertFrom(const IColumn & src, size_t n)
+{
+    insert(src[n]);
+    finalize();
+}
+
 void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t length)
 {
     const auto & src_object = assert_cast<const ColumnObject &>(src);
+    if (!src_object.isFinalized())
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot insertRangeFrom non-finalized ColumnObject");
 
     for (auto & entry : subcolumns)
     {
@@ -658,6 +665,33 @@ void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t len
             entry->data.insertManyDefaults(length);
     }
 
+    for (const auto & entry : src_object.subcolumns)
+    {
+        if (!hasSubcolumn(entry->path))
+        {
+            if (entry->path.hasNested())
+            {
+                const auto & base_type = entry->data.getLeastCommonTypeBase();
+                FieldInfo field_info
+                {
+                    .scalar_type = base_type,
+                    .have_nulls = base_type->isNullable(),
+                    .need_convert = false,
+                    .num_dimensions = entry->data.getNumberOfDimensions(),
+                };
+
+                addNestedSubcolumn(entry->path, field_info, num_rows);
+            }
+            else
+            {
+                addSubcolumn(entry->path, num_rows);
+            }
+
+            auto & subcolumn = getSubcolumn(entry->path);
+            subcolumn.insertRangeFrom(entry->data, start, length);
+        }
+    }
+
     num_rows += length;
     finalize();
 }
@@ -685,6 +719,36 @@ void ColumnObject::popBack(size_t length)
     num_rows -= length;
 }
 
+template <typename Func>
+ColumnPtr ColumnObject::applyForSubcolumns(Func && func, std::string_view func_name) const
+{
+    if (!isFinalized())
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot {} non-finalized ColumnObject", func_name);
+
+    auto res = ColumnObject::create(is_nullable);
+    for (const auto & subcolumn : subcolumns)
+    {
+        auto new_subcolumn = func(subcolumn->data.getFinalizedColumn());
+        res->addSubcolumn(subcolumn->path, new_subcolumn->assumeMutable());
+    }
+    return res;
+}
+
+ColumnPtr ColumnObject::permute(const Permutation & perm, size_t limit) const
+{
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.permute(perm, limit); }, "permute");
+}
+
+ColumnPtr ColumnObject::filter(const Filter & filter, ssize_t result_size_hint) const
+{
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.filter(filter, result_size_hint); }, "filter");
+}
+
+ColumnPtr ColumnObject::index(const IColumn & indexes, size_t limit) const
+{
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.index(indexes, limit); }, "index");
+}
+
 const ColumnObject::Subcolumn & ColumnObject::getSubcolumn(const PathInData & key) const
 {
     if (const auto * node = subcolumns.findLeaf(key))
diff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h
index 9d61b1650420..73fc738cb8d4 100644
--- a/src/Columns/ColumnObject.h
+++ b/src/Columns/ColumnObject.h
@@ -68,6 +68,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
 
         bool isFinalized() const;
         const DataTypePtr & getLeastCommonType() const { return least_common_type.get(); }
+        const DataTypePtr & getLeastCommonTypeBase() const { return least_common_type.getBase(); }
+        size_t getNumberOfDimensions() const { return least_common_type.getNumberOfDimensions(); }
 
         /// Checks the consistency of column's parts stored in @data.
         void checkTypes() const;
@@ -193,15 +195,18 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     void forEachSubcolumn(ColumnCallback callback) override;
     void insert(const Field & field) override;
     void insertDefault() override;
+    void insertFrom(const IColumn & src, size_t n) override;
     void insertRangeFrom(const IColumn & src, size_t start, size_t length) override;
     ColumnPtr replicate(const Offsets & offsets) const override;
     void popBack(size_t length) override;
     Field operator[](size_t n) const override;
     void get(size_t n, Field & res) const override;
+    ColumnPtr permute(const Permutation & perm, size_t limit) const override;
+    ColumnPtr filter(const Filter & filter, ssize_t result_size_hint) const override;
+    ColumnPtr index(const IColumn & indexes, size_t limit) const override;
 
     /// All other methods throw exception.
 
-    ColumnPtr decompress() const override { throwMustBeConcrete(); }
     StringRef getDataAt(size_t) const override { throwMustBeConcrete(); }
     bool isDefaultAt(size_t) const override { throwMustBeConcrete(); }
     void insertData(const char *, size_t) override { throwMustBeConcrete(); }
@@ -211,10 +216,7 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     void updateHashWithValue(size_t, SipHash &) const override { throwMustBeConcrete(); }
     void updateWeakHash32(WeakHash32 &) const override { throwMustBeConcrete(); }
     void updateHashFast(SipHash &) const override { throwMustBeConcrete(); }
-    ColumnPtr filter(const Filter &, ssize_t) const override { throwMustBeConcrete(); }
     void expand(const Filter &, bool) override { throwMustBeConcrete(); }
-    ColumnPtr permute(const Permutation &, size_t) const override { throwMustBeConcrete(); }
-    ColumnPtr index(const IColumn &, size_t) const override { throwMustBeConcrete(); }
     int compareAt(size_t, size_t, const IColumn &, int) const override { throwMustBeConcrete(); }
     void compareColumn(const IColumn &, size_t, PaddedPODArray<UInt64> *, PaddedPODArray<Int8> &, int, int) const override { throwMustBeConcrete(); }
     bool hasEqualValues() const override { throwMustBeConcrete(); }
@@ -232,6 +234,9 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     {
         throw Exception("ColumnObject must be converted to ColumnTuple before use", ErrorCodes::LOGICAL_ERROR);
     }
+
+    template <typename Func>
+    ColumnPtr applyForSubcolumns(Func && func, std::string_view func_name) const;
 };
 
 }
diff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp
index 044e03afd104..0d8dea4315d0 100644
--- a/src/DataTypes/ObjectUtils.cpp
+++ b/src/DataTypes/ObjectUtils.cpp
@@ -107,6 +107,9 @@ DataTypePtr getDataTypeByColumn(const IColumn & column)
     if (WhichDataType(idx).isSimple())
         return DataTypeFactory::instance().get(String(magic_enum::enum_name(idx)));
 
+    if (WhichDataType(idx).isNothing())
+        return std::make_shared<DataTypeNothing>();
+
     if (const auto * column_array = checkAndGetColumn<ColumnArray>(&column))
         return std::make_shared<DataTypeArray>(getDataTypeByColumn(column_array->getData()));
 
diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp
index b0aaac6e7455..8408b0ac5fcb 100644
--- a/src/Interpreters/InterpreterInsertQuery.cpp
+++ b/src/Interpreters/InterpreterInsertQuery.cpp
@@ -438,7 +438,7 @@ BlockIO InterpreterInsertQuery::execute()
         });
 
         /// We need to convert Sparse columns to full, because it's destination storage
-        /// may not support it may have different settings for applying Sparse serialization.
+        /// may not support it or may have different settings for applying Sparse serialization.
         pipeline.addSimpleTransform([&](const Block & in_header) -> ProcessorPtr
         {
             return std::make_shared<MaterializingTransform>(in_header);
diff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp
index f29f96bbb3bc..9896f95bb541 100644
--- a/src/Processors/Formats/IRowInputFormat.cpp
+++ b/src/Processors/Formats/IRowInputFormat.cpp
@@ -213,7 +213,6 @@ Chunk IRowInputFormat::generate()
 
     finalizeObjectColumns(columns);
     Chunk chunk(std::move(columns), num_rows);
-    //chunk.setChunkInfo(std::move(chunk_missing_values));
     return chunk;
 }
 
