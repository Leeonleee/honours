{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49750,
  "instance_id": "ClickHouse__ClickHouse-49750",
  "issue_numbers": [
    "49672"
  ],
  "base_commit": "8adc878049b1182a9b8c7778a8f1055a545b5139",
  "patch": "diff --git a/src/Common/Volnitsky.h b/src/Common/Volnitsky.h\nindex a0fce5531cd7..64c5bf4c0d38 100644\n--- a/src/Common/Volnitsky.h\n+++ b/src/Common/Volnitsky.h\n@@ -386,8 +386,6 @@ class VolnitskyBase\n     FallbackSearcher fallback_searcher;\n \n public:\n-    using Searcher = FallbackSearcher;\n-\n     /** haystack_size_hint - the expected total size of the haystack for `search` calls. Optional (zero means unspecified).\n       * If you specify it small enough, the fallback algorithm will be used,\n       *  since it is considered that it's useless to waste time initializing the hash table.\n@@ -729,7 +727,7 @@ class MultiVolnitskyBase\n \n \n using Volnitsky = VolnitskyBase<true, true, ASCIICaseSensitiveStringSearcher>;\n-using VolnitskyUTF8 = VolnitskyBase<true, false, ASCIICaseSensitiveStringSearcher>; /// exactly same as Volnitsky\n+using VolnitskyUTF8 = VolnitskyBase<true, false, UTF8CaseSensitiveStringSearcher>;\n using VolnitskyCaseInsensitive = VolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>; /// ignores non-ASCII bytes\n using VolnitskyCaseInsensitiveUTF8 = VolnitskyBase<false, false, UTF8CaseInsensitiveStringSearcher>;\n \n@@ -737,7 +735,7 @@ using VolnitskyCaseSensitiveToken = VolnitskyBase<true, true, ASCIICaseSensitive\n using VolnitskyCaseInsensitiveToken = VolnitskyBase<false, true, ASCIICaseInsensitiveTokenSearcher>;\n \n using MultiVolnitsky = MultiVolnitskyBase<true, true, ASCIICaseSensitiveStringSearcher>;\n-using MultiVolnitskyUTF8 = MultiVolnitskyBase<true, false, ASCIICaseSensitiveStringSearcher>;\n+using MultiVolnitskyUTF8 = MultiVolnitskyBase<true, false, UTF8CaseSensitiveStringSearcher>;\n using MultiVolnitskyCaseInsensitive = MultiVolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>;\n using MultiVolnitskyCaseInsensitiveUTF8 = MultiVolnitskyBase<false, false, UTF8CaseInsensitiveStringSearcher>;\n \ndiff --git a/src/Common/format.h b/src/Common/format.h\nindex 1a02a064c097..b72c4f15125f 100644\n--- a/src/Common/format.h\n+++ b/src/Common/format.h\n@@ -17,18 +17,18 @@ namespace Format\n {\n     using IndexPositions = PODArrayWithStackMemory<UInt64, 64>;\n \n-    static inline void parseNumber(const String & description, UInt64 l, UInt64 r, UInt64 & res, UInt64 argument_number)\n+    static inline UInt64 parseNumber(const String & description, UInt64 l, UInt64 r, UInt64 argument_number)\n     {\n-        res = 0;\n+        UInt64 res = 0;\n         for (UInt64 pos = l; pos < r; ++pos)\n         {\n             if (!isNumericASCII(description[pos]))\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Not a number in curly braces at position {}\", std::to_string(pos));\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Not a number in curly braces at position {}\", pos);\n             res = res * 10 + description[pos] - '0';\n             if (res >= argument_number)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Too big number for arguments, must be at most {}\",\n-                    argument_number - 1);\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Too big number for arguments, must be at most {}\", argument_number - 1);\n         }\n+        return res;\n     }\n \n     static inline void init(\n@@ -132,8 +132,7 @@ namespace Format\n                         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot switch from automatic field numbering to manual field specification\");\n                     is_plain_numbering = false;\n \n-                    UInt64 arg;\n-                    parseNumber(pattern, last_open, i, arg, argument_number);\n+                    UInt64 arg = parseNumber(pattern, last_open, i, argument_number);\n \n                     if (arg >= argument_number)\n                         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument is too big for formatting. Note that indexing starts from zero\");\ndiff --git a/src/Functions/randomStringUTF8.cpp b/src/Functions/randomStringUTF8.cpp\nindex 14860338d4a6..831b19a62165 100644\n--- a/src/Functions/randomStringUTF8.cpp\n+++ b/src/Functions/randomStringUTF8.cpp\n@@ -61,26 +61,26 @@ class FunctionRandomStringUTF8 : public IFunction\n \n         offsets_to.resize(input_rows_count);\n \n-        const IColumn & length_column = *arguments[0].column;\n-        size_t summary_utf8_len = 0;\n+        const IColumn & col_length = *arguments[0].column;\n+        size_t total_codepoints = 0;\n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n         {\n-            size_t utf8_len = length_column.getUInt(row_num);\n-            summary_utf8_len += utf8_len;\n+            size_t codepoints = col_length.getUInt(row_num);\n+            total_codepoints += codepoints;\n         }\n \n         /* As we generate only assigned planes, the mathematical expectation of the number of bytes\n          * per generated code point ~= 3.85. So, reserving for coefficient 4 will not be an overhead\n          */\n \n-        if (summary_utf8_len > (1 << 29))\n+        if (total_codepoints > (1 << 29))\n             throw Exception(ErrorCodes::TOO_LARGE_STRING_SIZE, \"Too large string size in function {}\", getName());\n \n-        size_t size_in_bytes_with_margin = summary_utf8_len * 4 + input_rows_count;\n-        data_to.resize(size_in_bytes_with_margin);\n-        pcg64_fast rng(randomSeed()); // TODO It is inefficient. We should use SIMD PRNG instead.\n+        size_t max_byte_size = total_codepoints * 4 + input_rows_count;\n+        data_to.resize(max_byte_size);\n \n-        const auto generate_code_point = [](UInt32 rand) -> UInt32 {\n+        const auto generate_code_point = [](UInt32 rand)\n+        {\n             /// We want to generate number in [0x0, 0x70000) and shift it if need\n \n             /// Generate highest byte in [0, 6]\n@@ -104,43 +104,41 @@ class FunctionRandomStringUTF8 : public IFunction\n             return code_point;\n         };\n \n+        pcg64_fast rng(randomSeed());\n         IColumn::Offset offset = 0;\n+\n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n         {\n-            size_t utf8_len = length_column.getUInt(row_num);\n+            size_t codepoints = col_length.getUInt(row_num);\n             auto * pos = data_to.data() + offset;\n \n-            size_t last_writen_bytes = 0;\n-            size_t i = 0;\n-            for (; i < utf8_len; i += 2)\n+            for (size_t i = 0; i < codepoints; i +=2)\n             {\n-                UInt64 rand = rng();\n+                UInt64 rand = rng(); /// that's the bottleneck\n \n                 UInt32 code_point1 = generate_code_point(static_cast<UInt32>(rand));\n-                UInt32 code_point2 = generate_code_point(static_cast<UInt32>(rand >> 32u));\n \n-                /// We have padding in column buffers that we can overwrite.\n-                size_t length1 = UTF8::convertCodePointToUTF8(code_point1, pos, sizeof(int));\n-                assert(length1 <= 4);\n-                pos += length1;\n-\n-                size_t length2 = UTF8::convertCodePointToUTF8(code_point2, pos, sizeof(int));\n-                assert(length2 <= 4);\n-                last_writen_bytes = length2;\n-                pos += last_writen_bytes;\n-            }\n-            offset = pos - data_to.data() + 1;\n-            if (i > utf8_len)\n-            {\n-                offset -= last_writen_bytes;\n+                size_t bytes1 = UTF8::convertCodePointToUTF8(code_point1, pos, 4);\n+                chassert(bytes1 <= 4);\n+                pos += bytes1;\n+\n+                if (i + 1 != codepoints)\n+                {\n+                    UInt32 code_point2 = generate_code_point(static_cast<UInt32>(rand >> 32u));\n+                    size_t bytes2 = UTF8::convertCodePointToUTF8(code_point2, pos, 4);\n+                    chassert(bytes2 <= 4);\n+                    pos += bytes2;\n+                }\n             }\n+\n+            *pos = 0;\n+            ++pos;\n+\n+            offset = pos - data_to.data();\n             offsets_to[row_num] = offset;\n         }\n \n-        /// Put zero bytes in between.\n-        auto * pos = data_to.data();\n-        for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n-            pos[offsets_to[row_num] - 1] = 0;\n+        data_to.resize(offset);\n \n         return col_to;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01278_random_string_utf8.reference b/tests/queries/0_stateless/01278_random_string_utf8.reference\nindex 36ae0ace76a5..45efb26db752 100644\n--- a/tests/queries/0_stateless/01278_random_string_utf8.reference\n+++ b/tests/queries/0_stateless/01278_random_string_utf8.reference\n@@ -2,3 +2,4 @@\n String\n 1\n \n+99\ndiff --git a/tests/queries/0_stateless/01278_random_string_utf8.sql b/tests/queries/0_stateless/01278_random_string_utf8.sql\nindex f2c0a6c41c75..76349d9d814b 100644\n--- a/tests/queries/0_stateless/01278_random_string_utf8.sql\n+++ b/tests/queries/0_stateless/01278_random_string_utf8.sql\n@@ -3,3 +3,4 @@ SELECT lengthUTF8(randomStringUTF8(100));\n SELECT toTypeName(randomStringUTF8(10));\n SELECT isValidUTF8(randomStringUTF8(100000));\n SELECT randomStringUTF8(0);\n+SELECT lengthUTF8(lowerUTF8(randomStringUTF8(99))); -- bug #49672: msan assert\n",
  "problem_statement": "AST Fuzzer (msan): use-of-uninitialized-value in StringSearcher\n[A link to the report\r\n](https://s3.amazonaws.com/clickhouse-test-reports/49636/fe02317d4595ddcea9837dc5a33f047242653642/fuzzer_astfuzzermsan/report.html)\r\n\r\nStacks:\r\nhttps://pastila.nl/?030ef1b1/7e71a0d51ee89c61ce8ca97856c021e2\r\nhttps://pastila.nl/?0269eed6/0c3c7e9b0b6c6db8cbc7dbeed06ce055\r\nhttps://pastila.nl/?0269eed6/2d09fe39393369b364c2d304993d12cc\r\n\r\nLook like something related to string searcher\r\nCC @rschu1ze \n",
  "hints_text": "Minimal repro: `SELECT positionUTF8(concat('xyz', randomStringUTF8(15), '\\0'), 'needle')` (msan build)\nMore minimal repro: `SELECT lowerUTF8(concat(randomStringUTF8(50), '\\0', 'x'))`. My first suspicion was the SIMD optimizations in #46289 caused this but it looks like `concat()` messes up its output. Checking further ...",
  "created_at": "2023-05-10T17:53:20Z",
  "modified_files": [
    "src/Common/Volnitsky.h",
    "src/Common/format.h",
    "src/Functions/randomStringUTF8.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01278_random_string_utf8.reference",
    "tests/queries/0_stateless/01278_random_string_utf8.sql"
  ]
}