{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51858,
  "instance_id": "ClickHouse__ClickHouse-51858",
  "issue_numbers": [
    "37250",
    "37286"
  ],
  "base_commit": "ecbae2d8fda6e288f898e73d05df23d4f5fc28e1",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex a6280a284367..9601cd3e3986 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -156,6 +156,7 @@ class IColumn;\n     M(Bool, allow_suspicious_low_cardinality_types, false, \"In CREATE TABLE statement allows specifying LowCardinality modifier for types of small fixed size (8 or less). Enabling this may increase merge times and memory consumption.\", 0) \\\n     M(Bool, allow_suspicious_fixed_string_types, false, \"In CREATE TABLE statement allows creating columns of type FixedString(n) with n > 256. FixedString with length >= 256 is suspicious and most likely indicates misusage\", 0) \\\n     M(Bool, allow_suspicious_indices, false, \"Reject primary/secondary indexes and sorting keys with identical expressions\", 0) \\\n+    M(Bool, allow_suspicious_ttl_expressions, false, \"Reject TTL expressions that don't depend on any of table's columns. It indicates a user error most of the time.\", 0) \\\n     M(Bool, compile_expressions, false, \"Compile some scalar functions and operators to native code.\", 0) \\\n     M(UInt64, min_count_to_compile_expression, 3, \"The number of identical expressions before they are JIT-compiled\", 0) \\\n     M(Bool, compile_aggregate_expressions, true, \"Compile aggregate functions to native code.\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex 90a18b9b2f53..54c28fb9f927 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -7,6 +7,7 @@\n #include <boost/algorithm/string.hpp>\n #include <map>\n \n+\n namespace DB\n {\n \n@@ -80,6 +81,7 @@ namespace SettingsChangesHistory\n /// It's used to implement `compatibility` setting (see https://github.com/ClickHouse/ClickHouse/issues/35972)\n static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> settings_changes_history =\n {\n+    {\"23.12\", {{\"allow_suspicious_ttl_expressions\", true, false, \"It is a new setting, and in previous versions the behavior was equivalent to allowing.\"}}},\n     {\"23.9\", {{\"optimize_group_by_constant_keys\", false, true, \"Optimize group by constant keys by default\"},\n               {\"input_format_json_try_infer_named_tuples_from_objects\", false, true, \"Try to infer named Tuples from JSON objects by default\"},\n               {\"input_format_json_read_numbers_as_strings\", false, true, \"Allow to read numbers as strings in JSON formats by default\"},\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex d19f92ae7677..6f93cb3c3709 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -707,7 +707,7 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)\n     }\n     else if (type == MODIFY_TTL)\n     {\n-        metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(ttl, metadata.columns, context, metadata.primary_key);\n+        metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(ttl, metadata.columns, context, metadata.primary_key, context->getSettingsRef().allow_suspicious_ttl_expressions);\n     }\n     else if (type == REMOVE_TTL)\n     {\n@@ -1136,13 +1136,13 @@ void AlterCommands::apply(StorageInMemoryMetadata & metadata, ContextPtr context\n     metadata_copy.column_ttls_by_name.clear();\n     for (const auto & [name, ast] : column_ttl_asts)\n     {\n-        auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, metadata_copy.columns, context, metadata_copy.primary_key);\n+        auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, metadata_copy.columns, context, metadata_copy.primary_key, context->getSettingsRef().allow_suspicious_ttl_expressions);\n         metadata_copy.column_ttls_by_name[name] = new_ttl_entry;\n     }\n \n     if (metadata_copy.table_ttl.definition_ast != nullptr)\n         metadata_copy.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n-            metadata_copy.table_ttl.definition_ast, metadata_copy.columns, context, metadata_copy.primary_key);\n+            metadata_copy.table_ttl.definition_ast, metadata_copy.columns, context, metadata_copy.primary_key, context->getSettingsRef().allow_suspicious_ttl_expressions);\n \n     metadata = std::move(metadata_copy);\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 2f57ba4bfbc4..8445c513372d 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -2957,7 +2957,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n \n     if (!settings.allow_non_metadata_alters)\n     {\n-        auto mutation_commands = commands.getMutationCommands(new_metadata, settings.materialize_ttl_after_modify, getContext());\n+        auto mutation_commands = commands.getMutationCommands(new_metadata, settings.materialize_ttl_after_modify, local_context);\n \n         if (!mutation_commands.empty())\n             throw Exception(ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN,\n@@ -2966,7 +2966,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n                             queryToString(mutation_commands.ast()));\n     }\n \n-    commands.apply(new_metadata, getContext());\n+    commands.apply(new_metadata, local_context);\n \n     if (commands.hasInvertedIndex(new_metadata) && !settings.allow_experimental_inverted_index)\n         throw Exception(ErrorCodes::SUPPORT_IS_DISABLED,\n@@ -3253,7 +3253,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n     if (!columns_to_check_conversion.empty())\n     {\n         auto old_header = old_metadata.getSampleBlock();\n-        performRequiredConversions(old_header, columns_to_check_conversion, getContext());\n+        performRequiredConversions(old_header, columns_to_check_conversion, local_context);\n     }\n \n     if (old_metadata.hasSettingsChanges())\n@@ -3285,7 +3285,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n             }\n \n             if (setting_name == \"storage_policy\")\n-                checkStoragePolicy(getContext()->getStoragePolicy(new_value.safeGet<String>()));\n+                checkStoragePolicy(local_context->getStoragePolicy(new_value.safeGet<String>()));\n         }\n \n         /// Check if it is safe to reset the settings\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\nindex 41ff93e28f70..f4e4756279f9 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n@@ -409,7 +409,7 @@ StorageInMemoryMetadata ReplicatedMergeTreeTableMetadata::Diff::getNewMetadata(c\n                 ParserTTLExpressionList parser;\n                 auto ttl_for_table_ast = parseQuery(parser, new_ttl_table, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n                 new_metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n-                    ttl_for_table_ast, new_metadata.columns, context, new_metadata.primary_key);\n+                    ttl_for_table_ast, new_metadata.columns, context, new_metadata.primary_key, true /* allow_suspicious; because it is replication */);\n             }\n             else /// TTL was removed\n             {\n@@ -422,7 +422,7 @@ StorageInMemoryMetadata ReplicatedMergeTreeTableMetadata::Diff::getNewMetadata(c\n     new_metadata.column_ttls_by_name.clear();\n     for (const auto & [name, ast] : new_metadata.columns.getColumnTTLs())\n     {\n-        auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, new_metadata.columns, context, new_metadata.primary_key);\n+        auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, new_metadata.columns, context, new_metadata.primary_key, true /* allow_suspicious; because it is replication */);\n         new_metadata.column_ttls_by_name[name] = new_ttl_entry;\n     }\n \n@@ -454,7 +454,7 @@ StorageInMemoryMetadata ReplicatedMergeTreeTableMetadata::Diff::getNewMetadata(c\n \n     if (!ttl_table_changed && new_metadata.table_ttl.definition_ast != nullptr)\n         new_metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n-            new_metadata.table_ttl.definition_ast, new_metadata.columns, context, new_metadata.primary_key);\n+            new_metadata.table_ttl.definition_ast, new_metadata.columns, context, new_metadata.primary_key, true /* allow_suspicious; because it is replication */);\n \n     if (!projections_changed)\n     {\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 3310b8cb72df..9a5af77d57cd 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -581,10 +581,12 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         if (args.storage_def->sample_by)\n             metadata.sampling_key = KeyDescription::getKeyFromAST(args.storage_def->sample_by->ptr(), metadata.columns, context);\n \n+        bool allow_suspicious_ttl = args.attach || args.getLocalContext()->getSettingsRef().allow_suspicious_ttl_expressions;\n+\n         if (args.storage_def->ttl_table)\n         {\n             metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n-                args.storage_def->ttl_table->ptr(), metadata.columns, context, metadata.primary_key);\n+                args.storage_def->ttl_table->ptr(), metadata.columns, context, metadata.primary_key, allow_suspicious_ttl);\n         }\n \n         if (args.query.columns_list && args.query.columns_list->indices)\n@@ -602,7 +604,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         auto column_ttl_asts = columns.getColumnTTLs();\n         for (const auto & [name, ast] : column_ttl_asts)\n         {\n-            auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, columns, context, metadata.primary_key);\n+            auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, columns, context, metadata.primary_key, allow_suspicious_ttl);\n             metadata.column_ttls_by_name[name] = new_ttl_entry;\n         }\n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex ac771cdd0ae3..4fb21705534a 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -1379,7 +1379,6 @@ void StorageReplicatedMergeTree::setTableStructure(const StorageID & table_id, c\n     checkTTLExpressions(new_metadata, old_metadata);\n     setProperties(new_metadata, old_metadata);\n \n-\n     DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n }\n \ndiff --git a/src/Storages/TTLDescription.cpp b/src/Storages/TTLDescription.cpp\nindex f601fed06aca..41a222525bf0 100644\n--- a/src/Storages/TTLDescription.cpp\n+++ b/src/Storages/TTLDescription.cpp\n@@ -55,22 +55,29 @@ TTLAggregateDescription & TTLAggregateDescription::operator=(const TTLAggregateD\n namespace\n {\n \n-void checkTTLExpression(const ExpressionActionsPtr & ttl_expression, const String & result_column_name)\n+void checkTTLExpression(const ExpressionActionsPtr & ttl_expression, const String & result_column_name, bool allow_suspicious)\n {\n-    for (const auto & action : ttl_expression->getActions())\n+    /// Do not apply this check in ATTACH queries for compatibility reasons and if explicitly allowed.\n+    if (!allow_suspicious)\n     {\n-        if (action.node->type == ActionsDAG::ActionType::FUNCTION)\n+        if (ttl_expression->getRequiredColumns().empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"TTL expression {} does not depend on any of the columns of the table\", result_column_name);\n+\n+        for (const auto & action : ttl_expression->getActions())\n         {\n-            const IFunctionBase & func = *action.node->function_base;\n-            if (!func.isDeterministic())\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                                \"TTL expression cannot contain non-deterministic functions, but contains function {}\",\n-                                func.getName());\n+            if (action.node->type == ActionsDAG::ActionType::FUNCTION)\n+            {\n+                const IFunctionBase & func = *action.node->function_base;\n+                if (!func.isDeterministic())\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                                    \"TTL expression cannot contain non-deterministic functions, but contains function {}\",\n+                                    func.getName());\n+            }\n         }\n     }\n \n     const auto & result_column = ttl_expression->getSampleBlock().getByName(result_column_name);\n-\n     if (!typeid_cast<const DataTypeDateTime *>(result_column.type.get())\n         && !typeid_cast<const DataTypeDate *>(result_column.type.get()))\n     {\n@@ -162,7 +169,8 @@ TTLDescription TTLDescription::getTTLFromAST(\n     const ASTPtr & definition_ast,\n     const ColumnsDescription & columns,\n     ContextPtr context,\n-    const KeyDescription & primary_key)\n+    const KeyDescription & primary_key,\n+    bool is_attach)\n {\n     TTLDescription result;\n     const auto * ttl_element = definition_ast->as<ASTTTLElement>();\n@@ -289,7 +297,7 @@ TTLDescription TTLDescription::getTTLFromAST(\n         }\n     }\n \n-    checkTTLExpression(result.expression, result.result_column);\n+    checkTTLExpression(result.expression, result.result_column, is_attach || context->getSettingsRef().allow_suspicious_ttl_expressions);\n     return result;\n }\n \n@@ -327,7 +335,8 @@ TTLTableDescription TTLTableDescription::getTTLForTableFromAST(\n     const ASTPtr & definition_ast,\n     const ColumnsDescription & columns,\n     ContextPtr context,\n-    const KeyDescription & primary_key)\n+    const KeyDescription & primary_key,\n+    bool is_attach)\n {\n     TTLTableDescription result;\n     if (!definition_ast)\n@@ -338,7 +347,7 @@ TTLTableDescription TTLTableDescription::getTTLForTableFromAST(\n     bool have_unconditional_delete_ttl = false;\n     for (const auto & ttl_element_ptr : definition_ast->children)\n     {\n-        auto ttl = TTLDescription::getTTLFromAST(ttl_element_ptr, columns, context, primary_key);\n+        auto ttl = TTLDescription::getTTLFromAST(ttl_element_ptr, columns, context, primary_key, is_attach);\n         if (ttl.mode == TTLMode::DELETE)\n         {\n             if (!ttl.where_expression)\n@@ -380,7 +389,7 @@ TTLTableDescription TTLTableDescription::parse(const String & str, const Columns\n     ASTPtr ast = parseQuery(parser, str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     FunctionNameNormalizer().visit(ast.get());\n \n-    return getTTLForTableFromAST(ast, columns, context, primary_key);\n+    return getTTLForTableFromAST(ast, columns, context, primary_key, context->getSettingsRef().allow_suspicious_ttl_expressions);\n }\n \n }\ndiff --git a/src/Storages/TTLDescription.h b/src/Storages/TTLDescription.h\nindex 8f60eb604b56..aab5b43e53e6 100644\n--- a/src/Storages/TTLDescription.h\n+++ b/src/Storages/TTLDescription.h\n@@ -1,4 +1,5 @@\n #pragma once\n+\n #include <Parsers/IAST_fwd.h>\n #include <Storages/DataDestinationType.h>\n #include <Storages/ColumnsDescription.h>\n@@ -7,6 +8,7 @@\n #include <Interpreters/AggregateDescription.h>\n #include <Storages/TTLMode.h>\n \n+\n namespace DB\n {\n \n@@ -82,9 +84,8 @@ struct TTLDescription\n     /// Codec name which will be used to recompress data\n     ASTPtr recompression_codec;\n \n-    /// Parse TTL structure from definition. Able to parse both column and table\n-    /// TTLs.\n-    static TTLDescription getTTLFromAST(const ASTPtr & definition_ast, const ColumnsDescription & columns, ContextPtr context, const KeyDescription & primary_key);\n+    /// Parse TTL structure from definition. Able to parse both column and table TTLs.\n+    static TTLDescription getTTLFromAST(const ASTPtr & definition_ast, const ColumnsDescription & columns, ContextPtr context, const KeyDescription & primary_key, bool is_attach);\n \n     TTLDescription() = default;\n     TTLDescription(const TTLDescription & other);\n@@ -121,7 +122,7 @@ struct TTLTableDescription\n     TTLTableDescription & operator=(const TTLTableDescription & other);\n \n     static TTLTableDescription getTTLForTableFromAST(\n-        const ASTPtr & definition_ast, const ColumnsDescription & columns, ContextPtr context, const KeyDescription & primary_key);\n+        const ASTPtr & definition_ast, const ColumnsDescription & columns, ContextPtr context, const KeyDescription & primary_key, bool is_attach);\n \n     /// Parse description from string\n     static TTLTableDescription parse(const String & str, const ColumnsDescription & columns, ContextPtr context, const KeyDescription & primary_key);\n",
  "test_patch": "diff --git a/tests/integration/test_multiple_disks/test.py b/tests/integration/test_multiple_disks/test.py\nindex 30669feb6b3a..fdd81284b2a2 100644\n--- a/tests/integration/test_multiple_disks/test.py\n+++ b/tests/integration/test_multiple_disks/test.py\n@@ -1837,7 +1837,8 @@ def _insert_merge_execute(\n             SETTINGS storage_policy='{policy}'\n         \"\"\".format(\n                 name=name, policy=policy\n-            )\n+            ),\n+            settings={\"allow_suspicious_ttl_expressions\": 1},\n         )\n \n         for i in range(parts):\ndiff --git a/tests/integration/test_ttl_move/test.py b/tests/integration/test_ttl_move/test.py\nindex 2f18a0a1afa2..1df9bc6d3c92 100644\n--- a/tests/integration/test_ttl_move/test.py\n+++ b/tests/integration/test_ttl_move/test.py\n@@ -302,7 +302,8 @@ def test_moves_work_after_storage_policy_change(started_cluster, name, engine):\n         node1.query(\n             \"\"\"ALTER TABLE {name} MODIFY TTL now()-3600 TO DISK 'jbod1', d1 TO DISK 'external'\"\"\".format(\n                 name=name\n-            )\n+            ),\n+            settings={\"allow_suspicious_ttl_expressions\": 1},\n         )\n \n         wait_expire_1 = 12\ndiff --git a/tests/queries/0_stateless/00933_ttl_simple.reference b/tests/queries/0_stateless/00933_ttl_simple.reference\nindex e3982814eab4..72f5134e235d 100644\n--- a/tests/queries/0_stateless/00933_ttl_simple.reference\n+++ b/tests/queries/0_stateless/00933_ttl_simple.reference\n@@ -6,11 +6,11 @@\n 2000-10-10 00:00:00\t0\n 2100-10-10 00:00:00\t3\n 2100-10-10\t2\n-CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL now() - 1000\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n+CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL CAST(\\'2000-10-10 00:00:00\\', \\'DateTime\\')\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n 1\t0\n-CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL now() + 1000\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n+CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL CAST(\\'2100-10-10 00:00:00\\', \\'DateTime\\')\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n 1\t1\n-CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL today() - 1\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n+CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL CAST(\\'2000-10-10\\', \\'Date\\')\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n 1\t0\n-CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL today() + 1\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n+CREATE TABLE default.ttl_00933_1\\n(\\n    `b` Int32,\\n    `a` Int32 TTL CAST(\\'2100-10-10\\', \\'Date\\')\\n)\\nENGINE = MergeTree\\nPARTITION BY tuple()\\nORDER BY tuple()\\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192\n 1\t1\ndiff --git a/tests/queries/0_stateless/00933_ttl_simple.sql b/tests/queries/0_stateless/00933_ttl_simple.sql\nindex ad40e7c7e475..c1df338a0ffc 100644\n--- a/tests/queries/0_stateless/00933_ttl_simple.sql\n+++ b/tests/queries/0_stateless/00933_ttl_simple.sql\n@@ -8,7 +8,8 @@\n --     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now()\u2500\u252c\u2500toDate(toTimeZone(now(), 'America/Mazatlan'))\u2500\u252c\u2500\u2500\u2500\u2500today()\u2500\u2510\n --     \u2502 2023-07-24 06:24:06 \u2502                                    2023-07-23 \u2502 2023-07-24 \u2502\n --     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-set session_timezone = '';\n+SET session_timezone = '';\n+SET allow_suspicious_ttl_expressions = 1;\n \n drop table if exists ttl_00933_1;\n \n@@ -65,7 +66,9 @@ select * from ttl_00933_1 order by d;\n \n -- const DateTime TTL positive\n drop table if exists ttl_00933_1;\n-create table ttl_00933_1 (b Int, a Int ttl now()-1000) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n+create table ttl_00933_1 (b Int, a Int ttl '2000-10-10 00:00:00'::DateTime)\n+engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n+\n show create table ttl_00933_1;\n insert into ttl_00933_1 values (1, 1);\n optimize table ttl_00933_1 final;\n@@ -73,7 +76,7 @@ select * from ttl_00933_1;\n \n -- const DateTime TTL negative\n drop table if exists ttl_00933_1;\n-create table ttl_00933_1 (b Int, a Int ttl now()+1000) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n+create table ttl_00933_1 (b Int, a Int ttl '2100-10-10 00:00:00'::DateTime) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n show create table ttl_00933_1;\n insert into ttl_00933_1 values (1, 1);\n optimize table ttl_00933_1 final;\n@@ -81,7 +84,7 @@ select * from ttl_00933_1;\n \n -- const Date TTL positive\n drop table if exists ttl_00933_1;\n-create table ttl_00933_1 (b Int, a Int ttl today()-1) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n+create table ttl_00933_1 (b Int, a Int ttl '2000-10-10'::Date) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n show create table ttl_00933_1;\n insert into ttl_00933_1 values (1, 1);\n optimize table ttl_00933_1 final;\n@@ -89,7 +92,7 @@ select * from ttl_00933_1;\n \n -- const Date TTL negative\n drop table if exists ttl_00933_1;\n-create table ttl_00933_1 (b Int, a Int ttl today()+1) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n+create table ttl_00933_1 (b Int, a Int ttl '2100-10-10'::Date) engine = MergeTree order by tuple() partition by tuple() settings min_bytes_for_wide_part = 0;\n show create table ttl_00933_1;\n insert into ttl_00933_1 values (1, 1);\n optimize table ttl_00933_1 final;\ndiff --git a/tests/queries/0_stateless/01070_alter_with_ttl.sql b/tests/queries/0_stateless/01070_alter_with_ttl.sql\nindex 3adc3ccd6ae9..44d422cbe6d0 100644\n--- a/tests/queries/0_stateless/01070_alter_with_ttl.sql\n+++ b/tests/queries/0_stateless/01070_alter_with_ttl.sql\n@@ -1,5 +1,7 @@\n drop table if exists alter_ttl;\n \n+SET allow_suspicious_ttl_expressions = 1;\n+\n create table alter_ttl(i Int) engine = MergeTree order by i ttl toDate('2020-05-05');\n alter table alter_ttl add column s String;\n alter table alter_ttl modify column s String ttl toDate('2020-01-01');\ndiff --git a/tests/queries/0_stateless/01070_materialize_ttl.sql b/tests/queries/0_stateless/01070_materialize_ttl.sql\nindex b6a03f2ca10b..b322b67882c8 100644\n--- a/tests/queries/0_stateless/01070_materialize_ttl.sql\n+++ b/tests/queries/0_stateless/01070_materialize_ttl.sql\n@@ -1,5 +1,7 @@\n -- Tags: no-parallel\n \n+SET allow_suspicious_ttl_expressions = 1;\n+\n drop table if exists ttl;\n \n create table ttl (d Date, a Int) engine = MergeTree order by a partition by toDayOfMonth(d);\ndiff --git a/tests/queries/0_stateless/01070_modify_ttl.sql b/tests/queries/0_stateless/01070_modify_ttl.sql\nindex 0716ccd70436..4ffd59fc8a95 100644\n--- a/tests/queries/0_stateless/01070_modify_ttl.sql\n+++ b/tests/queries/0_stateless/01070_modify_ttl.sql\n@@ -1,5 +1,7 @@\n -- Tags: no-parallel\n \n+SET allow_suspicious_ttl_expressions = 1;\n+\n drop table if exists ttl;\n \n create table ttl (d Date, a Int) engine = MergeTree order by a partition by toDayOfMonth(d);\ndiff --git a/tests/queries/0_stateless/01070_modify_ttl_recalc_only.sql b/tests/queries/0_stateless/01070_modify_ttl_recalc_only.sql\nindex 7ac70d418718..2700cc03ff5a 100644\n--- a/tests/queries/0_stateless/01070_modify_ttl_recalc_only.sql\n+++ b/tests/queries/0_stateless/01070_modify_ttl_recalc_only.sql\n@@ -5,6 +5,8 @@ set mutations_sync = 2;\n -- system.parts has server default, timezone cannot be randomized\n set session_timezone = '';\n \n+SET allow_suspicious_ttl_expressions = 1;\n+\n drop table if exists ttl;\n \n create table ttl (d Date, a Int) engine = MergeTree order by a partition by toDayOfMonth(d)\ndiff --git a/tests/queries/0_stateless/01070_mutations_with_dependencies.sql b/tests/queries/0_stateless/01070_mutations_with_dependencies.sql\nindex 566bb16b10c8..813ebf3f5a73 100644\n--- a/tests/queries/0_stateless/01070_mutations_with_dependencies.sql\n+++ b/tests/queries/0_stateless/01070_mutations_with_dependencies.sql\n@@ -34,6 +34,8 @@ select count() from ttl where s = 'b';\n drop table ttl;\n \n -- check only that it doesn't throw exceptions.\n+SET allow_suspicious_ttl_expressions = 1;\n+\n create table ttl (i Int, s String) engine = MergeTree order by i ttl toDate('2000-01-01') TO DISK 'default';\n alter table ttl materialize ttl;\n drop table ttl;\ndiff --git a/tests/queries/0_stateless/02296_ttl_non_deterministic.reference b/tests/queries/0_stateless/02296_ttl_non_deterministic.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02296_ttl_non_deterministic.sql b/tests/queries/0_stateless/02296_ttl_non_deterministic.sql\nnew file mode 100644\nindex 000000000000..14d8979a624a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02296_ttl_non_deterministic.sql\n@@ -0,0 +1,34 @@\n+-- Tags: replica\n+\n+DROP TABLE IF EXISTS t_ttl_non_deterministic;\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64)\n+ENGINE = MergeTree ORDER BY A TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/ttl1', '1') ORDER BY A TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64) ENGINE = MergeTree ORDER BY A;\n+ALTER TABLE t_ttl_non_deterministic MODIFY TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+DROP TABLE t_ttl_non_deterministic;\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/ttl2', '1') ORDER BY A;\n+ALTER TABLE t_ttl_non_deterministic MODIFY TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+DROP TABLE t_ttl_non_deterministic;\n+\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64, B Int64 TTL now() + toIntervalMonth(1))\n+ENGINE = MergeTree ORDER BY A; -- {serverError BAD_ARGUMENTS}\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64, B Int64 TTL now() + toIntervalMonth(1))\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/ttl3', '1') ORDER BY A; -- {serverError BAD_ARGUMENTS}\n+\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64, B Int64) ENGINE = MergeTree ORDER BY A;\n+ALTER TABLE t_ttl_non_deterministic MODIFY COLUMN B Int64 TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+DROP TABLE t_ttl_non_deterministic;\n+\n+CREATE TABLE t_ttl_non_deterministic(A Int64, B Int64) ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/ttl4', '1') ORDER BY A;\n+ALTER TABLE t_ttl_non_deterministic MODIFY COLUMN B Int64 TTL now() + toIntervalMonth(1); -- {serverError BAD_ARGUMENTS}\n+DROP TABLE t_ttl_non_deterministic;\ndiff --git a/tests/queries/0_stateless/02864_statistic_exception.sql b/tests/queries/0_stateless/02864_statistic_exception.sql\nindex c37f6b1ce062..092fa9bda85a 100644\n--- a/tests/queries/0_stateless/02864_statistic_exception.sql\n+++ b/tests/queries/0_stateless/02864_statistic_exception.sql\n@@ -47,7 +47,7 @@ ALTER TABLE t1 MATERIALIZE STATISTIC b TYPE tdigest; -- { serverError ILLEGAL_ST\n \n ALTER TABLE t1 ADD STATISTIC a TYPE tdigest;\n ALTER TABLE t1 ADD STATISTIC b TYPE tdigest;\n-ALTER TABLE t1 MODIFY COLUMN a Float64 TTL now() + INTERVAL 1 MONTH;\n+ALTER TABLE t1 MODIFY COLUMN a Float64 TTL toDateTime(b) + INTERVAL 1 MONTH;\n ALTER TABLE t1 MODIFY COLUMN a Int64; -- { serverError ALTER_OF_COLUMN_IS_FORBIDDEN }\n \n DROP TABLE t1;\n",
  "problem_statement": "TTL now() + interval\n`TTL now() + toIntervalMonth(1)` probably it should be forbidden, `now()` in this case == time of the `create table`? Or documented.\r\n\r\n\r\n```sql\r\ncreate table XXX ( A Int64 ) Engine=MergeTree order by A TTL now() + toIntervalMonth(1);\r\n\r\nselect now();\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now()\u2500\u2510\r\n\u2502 2022-05-16 13:39:33 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n..... some time ....\r\n\r\ninsert into XXX select * from numbers(10);\r\n..... some time ....\r\ninsert into XXX select * from numbers(10);\r\n\r\nselect name,modification_time,  delete_ttl_info_min,delete_ttl_info_max from system.parts where table = 'XXX' and active;\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500modification_time\u2500\u252c\u2500delete_ttl_info_min\u2500\u252c\u2500delete_ttl_info_max\u2500\u2510\r\n\u2502 all_1_1_0 \u2502 2022-05-16 13:40:57 \u2502 2022-06-16 13:39:24 \u2502 2022-06-16 13:39:24 \u2502\r\n\u2502 all_2_2_0 \u2502 2022-05-16 13:41:47 \u2502 2022-06-16 13:39:24 \u2502 2022-06-16 13:39:24 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\noptimize table XXX final;\r\n\r\nselect name,modification_time,  delete_ttl_info_min,delete_ttl_info_max from system.parts where table = 'XXX' and active;\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500modification_time\u2500\u252c\u2500delete_ttl_info_min\u2500\u252c\u2500delete_ttl_info_max\u2500\u2510\r\n\u2502 all_1_2_1 \u2502 2022-05-16 13:45:38 \u2502 2022-06-16 13:39:24 \u2502 2022-06-16 13:39:24 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt seems all data will be removed after 1 month of table creation.\r\n\nFix check for non-deterministic functions in TTL expressions\n### Changelog category (leave one):\r\n- Bug Fix (user-visible misbehavior in official stable or prestable release)\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nFix check for non-deterministic functions in TTL expressions. Previously you could create a TTL expression with non-deterministic functions in some cases, which could lead to undefined behaviour later.\r\n\r\nFixes #37250.\n",
  "hints_text": "Probably we should prohibit all the non-deterministic functions, as we do for mutations. @CurtizJ do we have such an issue?\r\n\nActually it should be prohibited, but does not work in this case\r\nhttps://github.com/ClickHouse/ClickHouse/blob/b71511eaf872136f07a2596e30108cfb101599d0/src/Storages/TTLDescription.cpp#L58-L72\nThe same with `TTL toDateTime(1) + toIntervalMonth(1);` -- though it has some sense\r\n\r\n`TTL toDateTime(shardNum()) + toIntervalMonth(1)` -- this is also possible.\r\n\r\nMay be TTL should depend on data (at least one column) of the table?\n>  May be TTL should depend on data (at least one column) of the table?\r\n\r\n\r\n\r\nInitially it was so, but then this restriction was removed for some reason, I don't remember why.\nI think forbid non-deterministic functions is enough. `shardNum()` is also non-deterministic.\n```\r\ncreate table XXX ( A Int64 ) Engine=MergeTree order by A TTL toDateTime(rand()) + toIntervalMonth(1);\r\nDB::Exception: TTL expression cannot contain non-deterministic functions, but contains function rand. (BAD_ARGUMENTS)\r\n```\r\n\r\nYou forbade non-deterministic functions long time ago :) .\n",
  "created_at": "2023-07-05T18:52:16Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.h",
    "src/Storages/AlterCommands.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp",
    "src/Storages/MergeTree/registerStorageMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/TTLDescription.cpp",
    "src/Storages/TTLDescription.h"
  ],
  "modified_test_files": [
    "tests/integration/test_multiple_disks/test.py",
    "tests/integration/test_ttl_move/test.py",
    "tests/queries/0_stateless/00933_ttl_simple.reference",
    "tests/queries/0_stateless/00933_ttl_simple.sql",
    "tests/queries/0_stateless/01070_alter_with_ttl.sql",
    "tests/queries/0_stateless/01070_materialize_ttl.sql",
    "tests/queries/0_stateless/01070_modify_ttl.sql",
    "tests/queries/0_stateless/01070_modify_ttl_recalc_only.sql",
    "tests/queries/0_stateless/01070_mutations_with_dependencies.sql",
    "b/tests/queries/0_stateless/02296_ttl_non_deterministic.sql",
    "tests/queries/0_stateless/02864_statistic_exception.sql"
  ]
}