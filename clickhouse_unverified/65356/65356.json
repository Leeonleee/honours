{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 65356,
  "instance_id": "ClickHouse__ClickHouse-65356",
  "issue_numbers": [
    "64596"
  ],
  "base_commit": "bbe3a9f78e24e2e7c82e5358530c239cd2e9a463",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 8e072779b53a..38ffd40b6cd7 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1474,6 +1474,9 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P\n     if (expressions.hasHaving() && query.group_by_with_totals && (query.group_by_with_rollup || query.group_by_with_cube))\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of HAVING\");\n \n+    if (query.qualify())\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"QUALIFY clause is not supported in the old analyzer\");\n+\n     if (options.only_analyze)\n     {\n         auto read_nothing = std::make_unique<ReadNothingStep>(source_header);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03173_forbid_qualify.reference b/tests/queries/0_stateless/03173_forbid_qualify.reference\nnew file mode 100644\nindex 000000000000..c2f595d8c4bd\n--- /dev/null\n+++ b/tests/queries/0_stateless/03173_forbid_qualify.reference\n@@ -0,0 +1,3 @@\n+100\n+49\n+100\ndiff --git a/tests/queries/0_stateless/03173_forbid_qualify.sql b/tests/queries/0_stateless/03173_forbid_qualify.sql\nnew file mode 100644\nindex 000000000000..d8cb2bad2eaa\n--- /dev/null\n+++ b/tests/queries/0_stateless/03173_forbid_qualify.sql\n@@ -0,0 +1,11 @@\n+drop table if exists test_qualify;\n+create table test_qualify (number Int64) ENGINE = MergeTree ORDER BY (number);\n+\n+insert into test_qualify SELECT * FROM numbers(100);\n+\n+select count() from test_qualify; -- 100\n+select * from test_qualify qualify row_number() over (order by number) = 50 SETTINGS allow_experimental_analyzer = 1; -- 49\n+select * from test_qualify qualify row_number() over (order by number) = 50 SETTINGS allow_experimental_analyzer = 0; -- { serverError NOT_IMPLEMENTED }\n+\n+delete from test_qualify where number in (select number from test_qualify qualify row_number() over (order by number) = 50); -- { serverError UNFINISHED }\n+select count() from test_qualify; -- 100\n",
  "problem_statement": "Deleting using QUALIFY operator deletes all the rows in the table\nDeleting using QUALIFY operator deletes all the rows in the table. The following example should delete only one row.\r\nlogs: [downloaded-logs-20240529-165631.csv](https://github.com/ClickHouse/ClickHouse/files/15487174/downloaded-logs-20240529-165631.csv)\r\n\r\nversion: 24.4.1.2088\r\n\r\nSteps to reproduce:\r\n\r\n```sql\r\ndrop table if exists default.test_qualify;\r\ncreate table default.test_qualify (number Int64) ENGINE = MergeTree ORDER BY (number);\r\ninsert into default.test_qualify SELECT * FROM numbers(100);\r\nselect count() from default.test_qualify; -- 100\r\nselect * from default.test_qualify qualify row_number() over (order by number) = 50; -- 49\r\ndelete from default.test_qualify where number in (select number from default.test_qualify qualify row_number() over (order by number) = 50);\r\nselect count() from default.test_qualify; -- 0\r\n```\n",
  "hints_text": "It also happens on alter delete/update queries. The query behaves as if the QUALIFY condition wasn't there. I wonder if that's because it's using the legacy analyzer (from the logs).\nDoesn't seem like it, it seems to reproduce when using the new analyzer too: https://fiddle.clickhouse.com/243a3ed3-5fc5-4052-a476-f57d4a08b61a\n> Doesn't seem like it, it seems to reproduce when using the new analyzer too: [fiddle.clickhouse.com/243a3ed3-5fc5-4052-a476-f57d4a08b61a](https://fiddle.clickhouse.com/243a3ed3-5fc5-4052-a476-f57d4a08b61a)\r\n\r\ndoes the allow flag force it?\n```\r\n2024.05.31 23:08:17.094432 [ 64523 ] {8465f036-0aff-4a65-8f6a-2539a5736fc5} <Debug> executeQuery: (from 127.0.0.1:36270) alter table test_qualify UPDATE _row_exists = 0 WHERE number IN (SELECT number FROM default.test_qualify QUALIFY row_number() OVER (ORDER BY number ASC) = 50) (stage: Complete)\r\n2024.05.31 23:08:17.094625 [ 64523 ] {8465f036-0aff-4a65-8f6a-2539a5736fc5} <Debug> MutationsInterpreter(default.test_qualify): Will use old analyzer to prepare mutation\r\n```\r\n\r\nand guess what\r\n\r\n``` sql\r\nSELECT count()\r\nFROM\r\n(\r\n    SELECT number\r\n    FROM default.test_qualify\r\n    QUALIFY row_number() OVER (ORDER BY number ASC) = 50\r\n)\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\n   \u250c\u2500count()\u2500\u2510\r\n1. \u2502       1 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT count()\r\nFROM\r\n(\r\n    SELECT number\r\n    FROM default.test_qualify\r\n    QUALIFY row_number() OVER (ORDER BY number ASC) = 50\r\n)\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\n   \u250c\u2500count()\u2500\u2510\r\n1. \u2502     100 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\nbecause the old interpreter just ignores it somehow:\r\n\r\n``` sql\r\nEXPLAIN actions = 1\r\nSELECT number\r\nFROM default.test_qualify\r\nQUALIFY row_number() OVER (ORDER BY number ASC) = 50\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\n\r\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n 1. \u2502 Expression ((Projection + Before ORDER BY))             \u2502\r\n 2. \u2502 Actions: INPUT :: 0 -> number Int64 : 0                 \u2502\r\n 3. \u2502 Positions: 0                                            \u2502\r\n 4. \u2502   Window (Window step for window 'ORDER BY number ASC') \u2502\r\n 5. \u2502   Window: (ORDER BY number ASC)                         \u2502\r\n 6. \u2502   Functions: row_number() OVER (ORDER BY number ASC)    \u2502\r\n 7. \u2502     Sorting (Sorting for window 'ORDER BY number ASC')  \u2502\r\n 8. \u2502     Prefix sort description: number ASC                 \u2502\r\n 9. \u2502     Result sort description: number ASC                 \u2502\r\n10. \u2502       Expression (Before window functions)              \u2502\r\n11. \u2502       Actions: INPUT :: 0 -> number Int64 : 0           \u2502\r\n12. \u2502       Positions: 0                                      \u2502\r\n13. \u2502         ReadFromMergeTree (default.test_qualify)        \u2502\r\n14. \u2502         ReadType: InOrder                               \u2502\r\n15. \u2502         Parts: 1                                        \u2502\r\n16. \u2502         Granules: 1                                     \u2502\r\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n``` sql\r\nEXPLAIN actions = 1\r\nSELECT number\r\nFROM default.test_qualify\r\nQUALIFY row_number() OVER (ORDER BY number ASC) = 50\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n 1. \u2502 Expression ((Project names + Projection))                                                                                                                                        \u2502\r\n 2. \u2502 Actions: INPUT : 0 -> __table1.number Int64 : 0                                                                                                                                  \u2502\r\n 3. \u2502          ALIAS __table1.number :: 0 -> number Int64 : 1                                                                                                                          \u2502\r\n 4. \u2502 Positions: 1                                                                                                                                                                     \u2502\r\n 5. \u2502   Filter (QUALIFY)                                                                                                                                                               \u2502\r\n 6. \u2502   Filter column: equals(row_number() OVER (ORDER BY __table1.number ASC), 50_UInt8) (removed)                                                                                    \u2502\r\n 7. \u2502   Actions: INPUT :: 0 -> __table1.number Int64 : 0                                                                                                                               \u2502\r\n 8. \u2502            INPUT : 1 -> row_number() OVER (ORDER BY __table1.number ASC) UInt64 : 1                                                                                              \u2502\r\n 9. \u2502            COLUMN Const(UInt8) -> 50_UInt8 UInt8 : 2                                                                                                                             \u2502\r\n10. \u2502            FUNCTION equals(row_number() OVER (ORDER BY __table1.number ASC) :: 1, 50_UInt8 :: 2) -> equals(row_number() OVER (ORDER BY __table1.number ASC), 50_UInt8) UInt8 : 3 \u2502\r\n11. \u2502   Positions: 3 0                                                                                                                                                                 \u2502\r\n12. \u2502     Window (Window step for window 'ORDER BY __table1.number ASC')                                                                                                               \u2502\r\n13. \u2502     Window: (ORDER BY __table1.number ASC)                                                                                                                                       \u2502\r\n14. \u2502     Functions: row_number() OVER (ORDER BY __table1.number ASC)                                                                                                                  \u2502\r\n15. \u2502       Sorting (Sorting for window 'ORDER BY __table1.number ASC')                                                                                                                \u2502\r\n16. \u2502       Prefix sort description: __table1.number ASC                                                                                                                               \u2502\r\n17. \u2502       Result sort description: __table1.number ASC                                                                                                                               \u2502\r\n18. \u2502         Expression ((Before WINDOW + Change column names to column identifiers))                                                                                                 \u2502\r\n19. \u2502         Actions: INPUT : 0 -> number Int64 : 0                                                                                                                                   \u2502\r\n20. \u2502                  ALIAS number :: 0 -> __table1.number Int64 : 1                                                                                                                  \u2502\r\n21. \u2502         Positions: 1                                                                                                                                                             \u2502\r\n22. \u2502           ReadFromMergeTree (default.test_qualify)                                                                                                                               \u2502\r\n23. \u2502           ReadType: InOrder                                                                                                                                                      \u2502\r\n24. \u2502           Parts: 1                                                                                                                                                               \u2502\r\n25. \u2502           Granules: 1                                                                                                                                                            \u2502\r\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nIt's not a bug but an incomplete implementation.\r\n\r\n1. `MutationsInterpreter` currently always uses an old analyzer. We have a separate issue for that: #61563.\r\n2. The `QUALIFY` clause is only supported in the new analyzer. It won't be supported in the old analyzer. We don't modify the previous interpreter anymore (with the exception of crashes and logical errors).\r\n\r\nI think we can close this issue as a duplicate of #61563.\nThanks for checking. I'd add a note to the docs when things are known to be not fully implemented whenever possible.\n> It's not a bug but an incomplete implementation.\r\n> I think we can close this issue as a duplicate of https://github.com/ClickHouse/ClickHouse/issues/61563.\r\n\r\nBut shouldn't it throw in that case instead of deleting everything? Probably it's an issue with the old interpreter not throwing with `QUALIFY`\r\n\n> But shouldn't it throw in that case instead of deleting everything? Probably it's an issue with the old interpreter not throwing with QUALIFY\r\n\r\nYes, that would be a better behavior. The old analyzer just doesn't know about `QUALIFY`.",
  "created_at": "2024-06-17T16:19:39Z"
}