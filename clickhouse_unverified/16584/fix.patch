diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp
index 4fcd9f122765..af8b751e7872 100644
--- a/src/Databases/DatabaseAtomic.cpp
+++ b/src/Databases/DatabaseAtomic.cpp
@@ -114,7 +114,8 @@ void DatabaseAtomic::dropTable(const Context &, const String & table_name, bool
         DatabaseWithDictionaries::detachTableUnlocked(table_name, lock);       /// Should never throw
         table_name_to_path.erase(table_name);
     }
-    tryRemoveSymlink(table_name);
+    if (table->storesDataOnDisk())
+        tryRemoveSymlink(table_name);
     /// Remove the inner table (if any) to avoid deadlock
     /// (due to attempt to execute DROP from the worker thread)
     if (auto * mv = dynamic_cast<StorageMaterializedView *>(table.get()))
@@ -145,7 +146,7 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n
     String old_metadata_path = getObjectMetadataPath(table_name);
     String new_metadata_path = to_database.getObjectMetadataPath(to_table_name);
 
-    auto detach = [](DatabaseAtomic & db, const String & table_name_)
+    auto detach = [](DatabaseAtomic & db, const String & table_name_, bool has_symlink)
     {
         auto it = db.table_name_to_path.find(table_name_);
         String table_data_path_saved;
@@ -155,7 +156,7 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n
         assert(!table_data_path_saved.empty() || db.dictionaries.find(table_name_) != db.dictionaries.end());
         db.tables.erase(table_name_);
         db.table_name_to_path.erase(table_name_);
-        if (!table_data_path_saved.empty())
+        if (has_symlink)
             db.tryRemoveSymlink(table_name_);
         return table_data_path_saved;
     };
@@ -166,7 +167,8 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n
         if (table_data_path_.empty())
             return;
         db.table_name_to_path.emplace(table_name_, table_data_path_);
-        db.tryCreateSymlink(table_name_, table_data_path_);
+        if (table_->storesDataOnDisk())
+            db.tryCreateSymlink(table_name_, table_data_path_);
     };
 
     auto assert_can_move_mat_view = [inside_database](const StoragePtr & table_)
@@ -228,9 +230,9 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n
         renameNoReplace(old_metadata_path, new_metadata_path);
 
     /// After metadata was successfully moved, the following methods should not throw (if them do, it's a logical error)
-    table_data_path = detach(*this, table_name);
+    table_data_path = detach(*this, table_name, table->storesDataOnDisk());
     if (exchange)
-        other_table_data_path = detach(other_db, to_table_name);
+        other_table_data_path = detach(other_db, to_table_name, other_table->storesDataOnDisk());
 
     auto old_table_id = table->getStorageID();
 
@@ -286,7 +288,8 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora
             DatabaseCatalog::instance().removeUUIDMappingFinally(query.uuid);
         throw;
     }
-    tryCreateSymlink(query.table, table_data_path);
+    if (table->storesDataOnDisk())
+        tryCreateSymlink(query.table, table_data_path);
 }
 
 void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path)
@@ -383,17 +386,18 @@ void DatabaseAtomic::loadStoredObjects(Context & context, bool has_force_restore
 
         Poco::File(path_to_table_symlinks).createDirectories();
         for (const auto & table : table_names)
-            tryCreateSymlink(table.first, table.second);
+            tryCreateSymlink(table.first, table.second, true);
     }
 }
 
-void DatabaseAtomic::tryCreateSymlink(const String & table_name, const String & actual_data_path)
+void DatabaseAtomic::tryCreateSymlink(const String & table_name, const String & actual_data_path, bool if_data_path_exist)
 {
     try
     {
         String link = path_to_table_symlinks + escapeForFileName(table_name);
-        String data = Poco::Path(global_context.getPath()).makeAbsolute().toString() + actual_data_path;
-        Poco::File{data}.linkTo(link, Poco::File::LINK_SYMBOLIC);
+        Poco::File data = Poco::Path(global_context.getPath()).makeAbsolute().toString() + actual_data_path;
+        if (!if_data_path_exist || data.exists())
+            data.linkTo(link, Poco::File::LINK_SYMBOLIC);
     }
     catch (...)
     {
diff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h
index 2d90ed96f1d8..82408ff3ab3a 100644
--- a/src/Databases/DatabaseAtomic.h
+++ b/src/Databases/DatabaseAtomic.h
@@ -55,7 +55,7 @@ class DatabaseAtomic : public DatabaseOrdinary
 
     UUID tryGetTableUUID(const String & table_name) const override;
 
-    void tryCreateSymlink(const String & table_name, const String & actual_data_path);
+    void tryCreateSymlink(const String & table_name, const String & actual_data_path, bool if_data_path_exist = false);
     void tryRemoveSymlink(const String & table_name);
 
     void waitDetachedTableNotInUse(const UUID & uuid);
diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp
index 8d9f222bf697..4d7fcd4e2485 100644
--- a/src/Databases/DatabaseOnDisk.cpp
+++ b/src/Databases/DatabaseOnDisk.cpp
@@ -321,7 +321,7 @@ void DatabaseOnDisk::renameTable(
 
     /// Special case: usually no actions with symlinks are required when detaching/attaching table,
     /// but not when moving from Atomic database to Ordinary
-    if (from_atomic_to_ordinary)
+    if (from_atomic_to_ordinary && table->storesDataOnDisk())
     {
         auto & atomic_db = assert_cast<DatabaseAtomic &>(*this);
         atomic_db.tryRemoveSymlink(table_name);
diff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp
index 906863f3f44b..9de938ae184e 100644
--- a/src/Interpreters/DatabaseCatalog.cpp
+++ b/src/Interpreters/DatabaseCatalog.cpp
@@ -134,7 +134,10 @@ void DatabaseCatalog::loadDatabases()
     loadMarkedAsDroppedTables();
     auto task_holder = global_context->getSchedulePool().createTask("DatabaseCatalog", [this](){ this->dropTableDataTask(); });
     drop_task = std::make_unique<BackgroundSchedulePoolTaskHolder>(std::move(task_holder));
-    (*drop_task)->activateAndSchedule();
+    (*drop_task)->activate();
+    std::lock_guard lock{tables_marked_dropped_mutex};
+    if (!tables_marked_dropped.empty())
+        (*drop_task)->schedule();
 }
 
 void DatabaseCatalog::shutdownImpl()
@@ -760,14 +763,15 @@ void DatabaseCatalog::enqueueDroppedTableCleanup(StorageID table_id, StoragePtr
 
     std::lock_guard lock(tables_marked_dropped_mutex);
     if (ignore_delay)
-        tables_marked_dropped.push_front({table_id, table, dropped_metadata_path, 0});
+        tables_marked_dropped.push_front({table_id, table, dropped_metadata_path, drop_time});
     else
-        tables_marked_dropped.push_back({table_id, table, dropped_metadata_path, drop_time});
+        tables_marked_dropped.push_back({table_id, table, dropped_metadata_path, drop_time + drop_delay_sec});
     tables_marked_dropped_ids.insert(table_id.uuid);
     CurrentMetrics::add(CurrentMetrics::TablesToDropQueueSize, 1);
 
-    /// If list of dropped tables was empty, start a drop task
-    if (drop_task && tables_marked_dropped.size() == 1)
+    /// If list of dropped tables was empty, start a drop task.
+    /// If ignore_delay is set, schedule drop task as soon as possible.
+    if (drop_task && (tables_marked_dropped.size() == 1 || ignore_delay))
         (*drop_task)->schedule();
 }
 
@@ -777,26 +781,40 @@ void DatabaseCatalog::dropTableDataTask()
     /// Table can be removed when it's not used by queries and drop_delay_sec elapsed since it was marked as dropped.
 
     bool need_reschedule = true;
+    /// Default reschedule time for the case when we are waiting for reference count to become 1.
+    size_t schedule_after_ms = reschedule_time_ms;
     TableMarkedAsDropped table;
     try
     {
         std::lock_guard lock(tables_marked_dropped_mutex);
+        assert(!tables_marked_dropped.empty());
         time_t current_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
+        time_t min_drop_time = std::numeric_limits<time_t>::max();
+        size_t tables_in_use_count = 0;
         auto it = std::find_if(tables_marked_dropped.begin(), tables_marked_dropped.end(), [&](const auto & elem)
         {
             bool not_in_use = !elem.table || elem.table.unique();
-            bool old_enough = elem.drop_time + drop_delay_sec < current_time;
+            bool old_enough = elem.drop_time <= current_time;
+            min_drop_time = std::min(min_drop_time, elem.drop_time);
+            tables_in_use_count += !not_in_use;
             return not_in_use && old_enough;
         });
         if (it != tables_marked_dropped.end())
         {
             table = std::move(*it);
-            LOG_INFO(log, "Will try drop {}", table.table_id.getNameForLogs());
+            LOG_INFO(log, "Have {} tables in drop queue ({} of them are in use), will try drop {}",
+                     tables_marked_dropped.size(), tables_in_use_count, table.table_id.getNameForLogs());
             tables_marked_dropped.erase(it);
+            /// Schedule the task as soon as possible, while there are suitable tables to drop.
+            schedule_after_ms = 0;
         }
-        else
+        else if (current_time < min_drop_time)
         {
-            LOG_TRACE(log, "Not found any suitable tables to drop, still have {} tables in drop queue", tables_marked_dropped.size());
+            /// We are waiting for drop_delay_sec to exceed, no sense to wakeup until min_drop_time.
+            /// If new table is added to the queue with ignore_delay flag, schedule() is called to wakeup the task earlier.
+            schedule_after_ms = (min_drop_time - current_time) * 1000;
+            LOG_TRACE(log, "Not found any suitable tables to drop, still have {} tables in drop queue ({} of them are in use). "
+                           "Will check again after {} seconds", tables_marked_dropped.size(), tables_in_use_count, min_drop_time - current_time);
         }
         need_reschedule = !tables_marked_dropped.empty();
     }
@@ -820,11 +838,15 @@ void DatabaseCatalog::dropTableDataTask()
             tryLogCurrentException(log, "Cannot drop table " + table.table_id.getNameForLogs() +
                                         ". Will retry later.");
             {
+                table.drop_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) + drop_error_cooldown_sec;
                 std::lock_guard lock(tables_marked_dropped_mutex);
                 tables_marked_dropped.emplace_back(std::move(table));
                 /// If list of dropped tables was empty, schedule a task to retry deletion.
                 if (tables_marked_dropped.size() == 1)
+                {
                     need_reschedule = true;
+                    schedule_after_ms = drop_error_cooldown_sec * 1000;
+                }
             }
         }
 
@@ -833,7 +855,7 @@ void DatabaseCatalog::dropTableDataTask()
 
     /// Do not schedule a task if there is no tables to drop
     if (need_reschedule)
-        (*drop_task)->scheduleAfter(reschedule_time_ms);
+        (*drop_task)->scheduleAfter(schedule_after_ms);
 }
 
 void DatabaseCatalog::dropTableFinally(const TableMarkedAsDropped & table)
diff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h
index d26307a3bc3d..2fd5c8d2be8f 100644
--- a/src/Interpreters/DatabaseCatalog.h
+++ b/src/Interpreters/DatabaseCatalog.h
@@ -234,6 +234,7 @@ class DatabaseCatalog : boost::noncopyable
     void dropTableFinally(const TableMarkedAsDropped & table);
 
     static constexpr size_t reschedule_time_ms = 100;
+    static constexpr time_t drop_error_cooldown_sec = 5;
 
 private:
     using UUIDToDatabaseMap = std::unordered_map<UUID, DatabasePtr>;
diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h
index 836e2d7dcf11..fd73ae2ccd24 100644
--- a/src/Storages/IStorage.h
+++ b/src/Storages/IStorage.h
@@ -449,6 +449,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo
     /// We do not use mutex because it is not very important that the size could change during the operation.
     virtual void checkPartitionCanBeDropped(const ASTPtr & /*partition*/) {}
 
+    /// Returns true if Storage may store some data on disk.
+    /// NOTE: may not be equivalent to !getDataPaths().empty()
+    virtual bool storesDataOnDisk() const { return false; }
+
     /// Returns data paths if storage supports it, empty vector otherwise.
     virtual Strings getDataPaths() const { return {}; }
 
diff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h
index 5c18661dad13..a8371a2dca2a 100644
--- a/src/Storages/MergeTree/MergeTreeData.h
+++ b/src/Storages/MergeTree/MergeTreeData.h
@@ -618,6 +618,7 @@ class MergeTreeData : public IStorage
     /// `additional_path` can be set if part is not located directly in table data path (e.g. 'detached/')
     std::optional<String> getFullRelativePathForPart(const String & part_name, const String & additional_path = "") const;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override;
 
     using PathsWithDisks = std::vector<PathWithDisk>;
diff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h
index dd043e5feeb2..5adc4ca56271 100644
--- a/src/Storages/StorageDistributed.h
+++ b/src/Storages/StorageDistributed.h
@@ -82,6 +82,7 @@ class StorageDistributed final : public ext::shared_ptr_helper<StorageDistribute
     void shutdown() override;
     void drop() override;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override;
 
     const ExpressionActionsPtr & getShardingKeyExpr() const { return sharding_key_expr; }
diff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp
index 8c7cd7b63d76..0cc3aa807c4d 100644
--- a/src/Storages/StorageFile.cpp
+++ b/src/Storages/StorageFile.cpp
@@ -524,6 +524,11 @@ BlockOutputStreamPtr StorageFile::write(
         chooseCompressionMethod(path, compression_method), context);
 }
 
+bool StorageFile::storesDataOnDisk() const
+{
+    return is_db_table;
+}
+
 Strings StorageFile::getDataPaths() const
 {
     if (paths.empty())
diff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h
index f331538b4c79..eb6f0cb4d870 100644
--- a/src/Storages/StorageFile.h
+++ b/src/Storages/StorageFile.h
@@ -46,6 +46,7 @@ class StorageFile final : public ext::shared_ptr_helper<StorageFile>, public ISt
 
     void rename(const String & new_path_to_table_data, const StorageID & new_table_id) override;
 
+    bool storesDataOnDisk() const override;
     Strings getDataPaths() const override;
 
     struct CommonArguments
diff --git a/src/Storages/StorageLog.h b/src/Storages/StorageLog.h
index 49fc9a576c5b..306383a12354 100644
--- a/src/Storages/StorageLog.h
+++ b/src/Storages/StorageLog.h
@@ -41,6 +41,7 @@ class StorageLog final : public ext::shared_ptr_helper<StorageLog>, public IStor
 
     void truncate(const ASTPtr &, const StorageMetadataPtr & metadata_snapshot, const Context &, TableExclusiveLockHolder &) override;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }
 
 protected:
diff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h
index 7b010476b22f..e2a6438ecfe6 100644
--- a/src/Storages/StorageProxy.h
+++ b/src/Storages/StorageProxy.h
@@ -144,6 +144,7 @@ class StorageProxy : public IStorage
     CheckResults checkData(const ASTPtr & query , const Context & context) override { return getNested()->checkData(query, context); }
     void checkTableCanBeDropped() const override { getNested()->checkTableCanBeDropped(); }
     void checkPartitionCanBeDropped(const ASTPtr & partition) override { getNested()->checkPartitionCanBeDropped(partition); }
+    bool storesDataOnDisk() const override { return getNested()->storesDataOnDisk(); }
     Strings getDataPaths() const override { return getNested()->getDataPaths(); }
     StoragePolicyPtr getStoragePolicy() const override { return getNested()->getStoragePolicy(); }
     std::optional<UInt64> totalRows() const override { return getNested()->totalRows(); }
diff --git a/src/Storages/StorageSet.h b/src/Storages/StorageSet.h
index 98677dcfb155..9a734b50002b 100644
--- a/src/Storages/StorageSet.h
+++ b/src/Storages/StorageSet.h
@@ -24,6 +24,7 @@ class StorageSetOrJoinBase : public IStorage
 
     BlockOutputStreamPtr write(const ASTPtr & query, const StorageMetadataPtr & /*metadata_snapshot*/, const Context & context) override;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override { return {path}; }
 
 protected:
diff --git a/src/Storages/StorageStripeLog.h b/src/Storages/StorageStripeLog.h
index f88120a932ec..ea2b1693169c 100644
--- a/src/Storages/StorageStripeLog.h
+++ b/src/Storages/StorageStripeLog.h
@@ -40,6 +40,7 @@ class StorageStripeLog final : public ext::shared_ptr_helper<StorageStripeLog>,
 
     CheckResults checkData(const ASTPtr & /* query */, const Context & /* context */) override;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }
 
     void truncate(const ASTPtr &, const StorageMetadataPtr &, const Context &, TableExclusiveLockHolder&) override;
diff --git a/src/Storages/StorageTinyLog.h b/src/Storages/StorageTinyLog.h
index dc6ff1015038..39c2994aaedc 100644
--- a/src/Storages/StorageTinyLog.h
+++ b/src/Storages/StorageTinyLog.h
@@ -39,6 +39,7 @@ class StorageTinyLog final : public ext::shared_ptr_helper<StorageTinyLog>, publ
 
     CheckResults checkData(const ASTPtr & /* query */, const Context & /* context */) override;
 
+    bool storesDataOnDisk() const override { return true; }
     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }
 
     void truncate(const ASTPtr &, const StorageMetadataPtr & metadata_snapshot, const Context &, TableExclusiveLockHolder &) override;
