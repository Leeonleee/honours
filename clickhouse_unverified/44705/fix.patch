diff --git a/src/Interpreters/InterpreterDeleteQuery.cpp b/src/Interpreters/InterpreterDeleteQuery.cpp
index b5b8ae81366a..720a179a9d47 100644
--- a/src/Interpreters/InterpreterDeleteQuery.cpp
+++ b/src/Interpreters/InterpreterDeleteQuery.cpp
@@ -23,6 +23,7 @@ namespace ErrorCodes
 {
     extern const int TABLE_IS_READ_ONLY;
     extern const int SUPPORT_IS_DISABLED;
+    extern const int BAD_ARGUMENTS;
 }
 
 
@@ -58,8 +59,7 @@ BlockIO InterpreterDeleteQuery::execute()
     auto table_lock = table->lockForShare(getContext()->getCurrentQueryId(), getContext()->getSettingsRef().lock_acquire_timeout);
     auto metadata_snapshot = table->getInMemoryMetadataPtr();
 
-    auto merge_tree = std::dynamic_pointer_cast<MergeTreeData>(table);
-    if (!merge_tree)
+    if (table->supportsDelete())
     {
         /// Convert to MutationCommand
         MutationCommands mutation_commands;
@@ -75,39 +75,45 @@ BlockIO InterpreterDeleteQuery::execute()
         table->mutate(mutation_commands, getContext());
         return {};
     }
+    else if (table->supportsLightweightDelete())
+    {
+        if (!getContext()->getSettingsRef().allow_experimental_lightweight_delete)
+            throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, "Lightweight delete mutate is experimental. Set `allow_experimental_lightweight_delete` setting to enable it");
+
+        /// Convert to MutationCommand
+        MutationCommands mutation_commands;
+        MutationCommand mut_command;
+
+        /// Build "UPDATE _row_exists = 0 WHERE predicate" query
+        mut_command.type = MutationCommand::Type::UPDATE;
+        mut_command.predicate = delete_query.predicate;
+
+        auto command = std::make_shared<ASTAlterCommand>();
+        command->type = ASTAlterCommand::UPDATE;
+        command->predicate = delete_query.predicate;
+        command->update_assignments = std::make_shared<ASTExpressionList>();
+        auto set_row_does_not_exist = std::make_shared<ASTAssignment>();
+        set_row_does_not_exist->column_name = LightweightDeleteDescription::FILTER_COLUMN.name;
+        auto zero_value = std::make_shared<ASTLiteral>(DB::Field(UInt8(0)));
+        set_row_does_not_exist->children.push_back(zero_value);
+        command->update_assignments->children.push_back(set_row_does_not_exist);
+        command->children.push_back(command->predicate);
+        command->children.push_back(command->update_assignments);
+        mut_command.column_to_update_expression[set_row_does_not_exist->column_name] = zero_value;
+        mut_command.ast = command->ptr();
+
+        mutation_commands.emplace_back(mut_command);
+
+        table->checkMutationIsPossible(mutation_commands, getContext()->getSettingsRef());
+        MutationsInterpreter(table, metadata_snapshot, mutation_commands, getContext(), false).validate();
+        table->mutate(mutation_commands, getContext());
 
-    if (!getContext()->getSettingsRef().allow_experimental_lightweight_delete)
-        throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, "Lightweight delete mutate is experimental. Set `allow_experimental_lightweight_delete` setting to enable it");
-
-    /// Convert to MutationCommand
-    MutationCommands mutation_commands;
-    MutationCommand mut_command;
-
-    /// Build "UPDATE _row_exists = 0 WHERE predicate" query
-    mut_command.type = MutationCommand::Type::UPDATE;
-    mut_command.predicate = delete_query.predicate;
-
-    auto command = std::make_shared<ASTAlterCommand>();
-    command->type = ASTAlterCommand::UPDATE;
-    command->predicate = delete_query.predicate;
-    command->update_assignments = std::make_shared<ASTExpressionList>();
-    auto set_row_does_not_exist = std::make_shared<ASTAssignment>();
-    set_row_does_not_exist->column_name = LightweightDeleteDescription::FILTER_COLUMN.name;
-    auto zero_value = std::make_shared<ASTLiteral>(DB::Field(UInt8(0)));
-    set_row_does_not_exist->children.push_back(zero_value);
-    command->update_assignments->children.push_back(set_row_does_not_exist);
-    command->children.push_back(command->predicate);
-    command->children.push_back(command->update_assignments);
-    mut_command.column_to_update_expression[set_row_does_not_exist->column_name] = zero_value;
-    mut_command.ast = command->ptr();
-
-    mutation_commands.emplace_back(mut_command);
-
-    table->checkMutationIsPossible(mutation_commands, getContext()->getSettingsRef());
-    MutationsInterpreter(table, metadata_snapshot, mutation_commands, getContext(), false).validate();
-    table->mutate(mutation_commands, getContext());
-
-    return {};
+        return {};
+    }
+    else
+    {
+        throw Exception(ErrorCodes::BAD_ARGUMENTS, "DELETE query is not supported for table");
+    }
 }
 
 }
diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h
index a0585e9c9a12..2c4ea91869cd 100644
--- a/src/Storages/IStorage.h
+++ b/src/Storages/IStorage.h
@@ -241,6 +241,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo
     /// Return true if storage can execute lightweight delete mutations.
     virtual bool supportsLightweightDelete() const { return false; }
 
+    /// Return true if storage can execute 'DELETE FROM' mutations. This is different from lightweight delete
+    /// because those are internally translated into 'ALTER UDPATE' mutations.
+    virtual bool supportsDelete() const { return false; }
+
 private:
 
     StorageID storage_id;
diff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h
index ca0ab7a18408..eec817acd557 100644
--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h
+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h
@@ -80,6 +80,8 @@ class StorageEmbeddedRocksDB final : public IStorage, public IKeyValueEntity, Wi
         const std::vector<std::string> & keys,
         PaddedPODArray<UInt8> * out_null_map) const;
 
+    bool supportsDelete() const override { return true; }
+
 private:
     const String primary_key;
     using RocksDBPtr = std::unique_ptr<rocksdb::DB>;
