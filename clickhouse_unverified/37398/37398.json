{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37398,
  "instance_id": "ClickHouse__ClickHouse-37398",
  "issue_numbers": [
    "37094",
    "37133"
  ],
  "base_commit": "008de5c779b442af64e8337a45894d01a63e4ac6",
  "patch": "diff --git a/base/base/defines.h b/base/base/defines.h\nindex bd98e99f5b92..084e710abf6a 100644\n--- a/base/base/defines.h\n+++ b/base/base/defines.h\n@@ -105,6 +105,25 @@\n #   define ASAN_POISON_MEMORY_REGION(a, b)\n #endif\n \n+#if !defined(ABORT_ON_LOGICAL_ERROR)\n+    #if !defined(NDEBUG) || defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) || defined(MEMORY_SANITIZER) || defined(UNDEFINED_BEHAVIOR_SANITIZER)\n+        #define ABORT_ON_LOGICAL_ERROR\n+    #endif\n+#endif\n+\n+/// chassert(x) is similar to assert(x), but:\n+///     - works in builds with sanitizers, not only in debug builds\n+///     - tries to print failed assertion into server log\n+/// It can be used for all assertions except heavy ones.\n+/// Heavy assertions (that run loops or call complex functions) are allowed in debug builds only.\n+#if !defined(chassert)\n+    #if defined(ABORT_ON_LOGICAL_ERROR)\n+        #define chassert(x) static_cast<bool>(x) ? void(0) : abortOnFailedAssertion(#x)\n+    #else\n+        #define chassert(x) ((void)0)\n+    #endif\n+#endif\n+\n /// A template function for suppressing warnings about unused variables or function results.\n template <typename... Args>\n constexpr void UNUSED(Args &&... args [[maybe_unused]])\ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 5f78c79f606f..5d5ce052aaa3 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -627,6 +627,7 @@\n     M(656, MEILISEARCH_EXCEPTION) \\\n     M(657, UNSUPPORTED_MEILISEARCH_TYPE) \\\n     M(658, MEILISEARCH_MISSING_SOME_COLUMNS) \\\n+    M(659, UNKNOWN_STATUS_OF_TRANSACTION) \\\n     \\\n     M(999, KEEPER_EXCEPTION) \\\n     M(1000, POCO_EXCEPTION) \\\ndiff --git a/src/Common/Exception.cpp b/src/Common/Exception.cpp\nindex 21f605ad353b..d0f7af2da6b7 100644\n--- a/src/Common/Exception.cpp\n+++ b/src/Common/Exception.cpp\n@@ -35,6 +35,18 @@ namespace ErrorCodes\n     extern const int CANNOT_MREMAP;\n }\n \n+void abortOnFailedAssertion(const String & description)\n+{\n+    LOG_FATAL(&Poco::Logger::root(), \"Logical error: '{}'.\", description);\n+\n+    /// This is to suppress -Wmissing-noreturn\n+    volatile bool always_false = false;\n+    if (always_false)\n+        return;\n+\n+    abort();\n+}\n+\n /// - Aborts the process if error code is LOGICAL_ERROR.\n /// - Increments error codes statistics.\n void handle_error_code([[maybe_unused]] const std::string & msg, int code, bool remote, const Exception::FramePointers & trace)\n@@ -44,8 +56,7 @@ void handle_error_code([[maybe_unused]] const std::string & msg, int code, bool\n #ifdef ABORT_ON_LOGICAL_ERROR\n     if (code == ErrorCodes::LOGICAL_ERROR)\n     {\n-        LOG_FATAL(&Poco::Logger::root(), \"Logical error: '{}'.\", msg);\n-        abort();\n+        abortOnFailedAssertion(msg);\n     }\n #endif\n \ndiff --git a/src/Common/Exception.h b/src/Common/Exception.h\nindex 086b64bf5f90..253dbe6d65c3 100644\n--- a/src/Common/Exception.h\n+++ b/src/Common/Exception.h\n@@ -12,16 +12,14 @@\n \n #include <fmt/format.h>\n \n-#if !defined(NDEBUG) || defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) || defined(MEMORY_SANITIZER) || defined(UNDEFINED_BEHAVIOR_SANITIZER)\n-#define ABORT_ON_LOGICAL_ERROR\n-#endif\n-\n namespace Poco { class Logger; }\n \n \n namespace DB\n {\n \n+void abortOnFailedAssertion(const String & description);\n+\n class Exception : public Poco::Exception\n {\n public:\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 7b63aa341c0f..8cb35db65527 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -592,6 +592,7 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     M(String, insert_deduplication_token, \"\", \"If not empty, used for duplicate detection instead of data digest\", 0) \\\n     M(Bool, count_distinct_optimization, false, \"Rewrite count distinct to subquery of group by\", 0) \\\n     M(Bool, throw_on_unsupported_query_inside_transaction, true, \"Throw exception if unsupported query is used inside transaction\", 0) \\\n+    M(TransactionsWaitCSNMode, wait_changes_become_visible_after_commit_mode, TransactionsWaitCSNMode::WAIT_UNKNOWN, \"Wait for committed changes to become actually visible in the latest snapshot\", 0) \\\n     M(Bool, throw_if_no_data_to_insert, true, \"Enables or disables empty INSERTs, enabled by default\", 0) \\\n     M(Bool, compatibility_ignore_auto_increment_in_create_table, false, \"Ignore AUTO_INCREMENT keyword in column declaration if true, otherwise return error. It simplifies migration from MySQL\", 0) \\\n     // End of COMMON_SETTINGS\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex a37c1e9be860..bff1971bad90 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -131,6 +131,11 @@ IMPLEMENT_SETTING_ENUM(ShortCircuitFunctionEvaluation, ErrorCodes::BAD_ARGUMENTS\n      {\"force_enable\",    ShortCircuitFunctionEvaluation::FORCE_ENABLE},\n      {\"disable\",         ShortCircuitFunctionEvaluation::DISABLE}})\n \n+IMPLEMENT_SETTING_ENUM(TransactionsWaitCSNMode, ErrorCodes::BAD_ARGUMENTS,\n+    {{\"async\",          TransactionsWaitCSNMode::ASYNC},\n+     {\"wait\",           TransactionsWaitCSNMode::WAIT},\n+     {\"wait_unknown\",   TransactionsWaitCSNMode::WAIT_UNKNOWN}})\n+\n IMPLEMENT_SETTING_ENUM(EnumComparingMode, ErrorCodes::BAD_ARGUMENTS,\n     {{\"by_names\",   FormatSettings::EnumComparingMode::BY_NAMES},\n      {\"by_values\",  FormatSettings::EnumComparingMode::BY_VALUES},\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 08091da6d6cc..83a65f2a3209 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -183,6 +183,15 @@ enum class ShortCircuitFunctionEvaluation\n \n DECLARE_SETTING_ENUM(ShortCircuitFunctionEvaluation)\n \n+enum class TransactionsWaitCSNMode\n+{\n+    ASYNC,\n+    WAIT,\n+    WAIT_UNKNOWN,\n+};\n+\n+DECLARE_SETTING_ENUM(TransactionsWaitCSNMode)\n+\n DECLARE_SETTING_ENUM_WITH_RENAME(EnumComparingMode, FormatSettings::EnumComparingMode)\n \n DECLARE_SETTING_ENUM_WITH_RENAME(EscapingRule, FormatSettings::EscapingRule)\ndiff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp\nindex 0e12c5e9e5a1..2b2de84c314a 100644\n--- a/src/Interpreters/DDLWorker.cpp\n+++ b/src/Interpreters/DDLWorker.cpp\n@@ -287,7 +287,7 @@ void DDLWorker::scheduleTasks(bool reinitialized)\n     Strings queue_nodes = zookeeper->getChildren(queue_dir, &queue_node_stat, queue_updated_event);\n     size_t size_before_filtering = queue_nodes.size();\n     filterAndSortQueueNodes(queue_nodes);\n-    /// The following message is too verbose, but it can be useful too debug mysterious test failures in CI\n+    /// The following message is too verbose, but it can be useful to debug mysterious test failures in CI\n     LOG_TRACE(log, \"scheduleTasks: initialized={}, size_before_filtering={}, queue_size={}, \"\n                    \"entries={}..{}, \"\n                    \"first_failed_task_name={}, current_tasks_size={}, \"\ndiff --git a/src/Interpreters/InterpreterTransactionControlQuery.cpp b/src/Interpreters/InterpreterTransactionControlQuery.cpp\nindex 61b2a4e865f6..1e4868788ba1 100644\n--- a/src/Interpreters/InterpreterTransactionControlQuery.cpp\n+++ b/src/Interpreters/InterpreterTransactionControlQuery.cpp\n@@ -10,6 +10,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int INVALID_TRANSACTION;\n+    extern const int UNKNOWN_STATUS_OF_TRANSACTION;\n }\n \n BlockIO InterpreterTransactionControlQuery::execute()\n@@ -55,7 +56,42 @@ BlockIO InterpreterTransactionControlQuery::executeCommit(ContextMutablePtr sess\n     if (txn->getState() != MergeTreeTransaction::RUNNING)\n         throw Exception(ErrorCodes::INVALID_TRANSACTION, \"Transaction is not in RUNNING state\");\n \n-    TransactionLog::instance().commitTransaction(txn);\n+    TransactionsWaitCSNMode mode = query_context->getSettingsRef().wait_changes_become_visible_after_commit_mode;\n+    CSN csn;\n+    try\n+    {\n+        csn = TransactionLog::instance().commitTransaction(txn, /* throw_on_unknown_status */ mode != TransactionsWaitCSNMode::WAIT_UNKNOWN);\n+    }\n+    catch (const Exception & e)\n+    {\n+        if (e.code() == ErrorCodes::UNKNOWN_STATUS_OF_TRANSACTION)\n+        {\n+            /// Detach transaction from current context if connection was lost and its status is unknown\n+            session_context->setCurrentTransaction(NO_TRANSACTION_PTR);\n+        }\n+        throw;\n+    }\n+\n+    if (csn == Tx::CommittingCSN)\n+    {\n+        chassert(mode == TransactionsWaitCSNMode::WAIT_UNKNOWN);\n+\n+        /// Try to wait for connection to be restored and its status to be loaded.\n+        /// It's useful for testing. It allows to enable fault injection (after commit) without breaking tests.\n+        txn->waitStateChange(Tx::CommittingCSN);\n+\n+        if (txn->getState() == MergeTreeTransaction::ROLLED_BACK)\n+            throw Exception(ErrorCodes::INVALID_TRANSACTION, \"Transaction {} was rolled back\", txn->tid);\n+        if (txn->getState() != MergeTreeTransaction::COMMITTED)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Transaction {} has invalid state {}\", txn->tid, txn->getState());\n+\n+        csn = txn->getCSN();\n+    }\n+\n+    /// Wait for committed changes to become actually visible, so the next transaction in this session will see the changes\n+    if (mode != TransactionsWaitCSNMode::ASYNC)\n+        TransactionLog::instance().waitForCSNLoaded(csn);\n+\n     session_context->setCurrentTransaction(NO_TRANSACTION_PTR);\n     return {};\n }\n@@ -67,6 +103,8 @@ BlockIO InterpreterTransactionControlQuery::executeRollback(ContextMutablePtr se\n         throw Exception(ErrorCodes::INVALID_TRANSACTION, \"There is no current transaction\");\n     if (txn->getState() == MergeTreeTransaction::COMMITTED)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Transaction is in COMMITTED state\");\n+    if (txn->getState() == MergeTreeTransaction::COMMITTING)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Transaction is in COMMITTING state\");\n \n     if (txn->getState() == MergeTreeTransaction::RUNNING)\n         TransactionLog::instance().rollbackTransaction(txn);\ndiff --git a/src/Interpreters/InterpreterTransactionControlQuery.h b/src/Interpreters/InterpreterTransactionControlQuery.h\nindex 05d3068e095f..bf2dc7891a7a 100644\n--- a/src/Interpreters/InterpreterTransactionControlQuery.h\n+++ b/src/Interpreters/InterpreterTransactionControlQuery.h\n@@ -22,7 +22,7 @@ class InterpreterTransactionControlQuery : public IInterpreter\n \n private:\n     BlockIO executeBegin(ContextMutablePtr session_context);\n-    static BlockIO executeCommit(ContextMutablePtr session_context);\n+    BlockIO executeCommit(ContextMutablePtr session_context);\n     static BlockIO executeRollback(ContextMutablePtr session_context);\n     static BlockIO executeSetSnapshot(ContextMutablePtr session_context, UInt64 snapshot);\n \ndiff --git a/src/Interpreters/MergeTreeTransaction.cpp b/src/Interpreters/MergeTreeTransaction.cpp\nindex c0d3cdfeb623..cab40f3c6db4 100644\n--- a/src/Interpreters/MergeTreeTransaction.cpp\n+++ b/src/Interpreters/MergeTreeTransaction.cpp\n@@ -38,13 +38,26 @@ void MergeTreeTransaction::setSnapshot(CSN new_snapshot)\n MergeTreeTransaction::State MergeTreeTransaction::getState() const\n {\n     CSN c = csn.load();\n-    if (c == Tx::UnknownCSN || c == Tx::CommittingCSN)\n+    if (c == Tx::UnknownCSN)\n         return RUNNING;\n+    if (c == Tx::CommittingCSN)\n+        return COMMITTING;\n     if (c == Tx::RolledBackCSN)\n         return ROLLED_BACK;\n     return COMMITTED;\n }\n \n+bool MergeTreeTransaction::waitStateChange(CSN current_state_csn) const\n+{\n+    CSN current_value = current_state_csn;\n+    while (current_value == current_state_csn && !TransactionLog::instance().isShuttingDown())\n+    {\n+        csn.wait(current_value);\n+        current_value = csn.load();\n+    }\n+    return current_value != current_state_csn;\n+}\n+\n void MergeTreeTransaction::checkIsNotCancelled() const\n {\n     CSN c = csn.load();\n@@ -158,7 +171,7 @@ void MergeTreeTransaction::addMutation(const StoragePtr & table, const String &\n bool MergeTreeTransaction::isReadOnly() const\n {\n     std::lock_guard lock{mutex};\n-    assert((creating_parts.empty() && removing_parts.empty() && mutations.empty()) == storages.empty());\n+    chassert((creating_parts.empty() && removing_parts.empty() && mutations.empty()) == storages.empty());\n     return storages.empty();\n }\n \n@@ -204,7 +217,7 @@ void MergeTreeTransaction::afterCommit(CSN assigned_csn) noexcept\n     /// and we will be able to remove old entries from transaction log in ZK.\n     /// It's not a problem if server crash before CSN is written, because we already have TID in data part and entry in the log.\n     [[maybe_unused]] CSN prev_value = csn.exchange(assigned_csn);\n-    assert(prev_value == Tx::CommittingCSN);\n+    chassert(prev_value == Tx::CommittingCSN);\n     for (const auto & part : creating_parts)\n     {\n         part->version.creation_csn.store(csn);\n@@ -321,7 +334,7 @@ String MergeTreeTransaction::dumpDescription() const\n     {\n         String info = fmt::format(\"{} (created by {}, {})\", part->name, part->version.getCreationTID(), part->version.creation_csn);\n         std::get<1>(storage_to_changes[&(part->storage)]).push_back(std::move(info));\n-        assert(!part->version.creation_csn || part->version.creation_csn <= snapshot);\n+        chassert(!part->version.creation_csn || part->version.creation_csn <= snapshot);\n     }\n \n     for (const auto & mutation : mutations)\ndiff --git a/src/Interpreters/MergeTreeTransaction.h b/src/Interpreters/MergeTreeTransaction.h\nindex 7ebea450dd0e..309b8e3eeff0 100644\n--- a/src/Interpreters/MergeTreeTransaction.h\n+++ b/src/Interpreters/MergeTreeTransaction.h\n@@ -26,6 +26,7 @@ class MergeTreeTransaction : public std::enable_shared_from_this<MergeTreeTransa\n     enum State\n     {\n         RUNNING,\n+        COMMITTING,\n         COMMITTED,\n         ROLLED_BACK,\n     };\n@@ -55,6 +56,11 @@ class MergeTreeTransaction : public std::enable_shared_from_this<MergeTreeTransa\n \n     Float64 elapsedSeconds() const { return elapsed.elapsedSeconds(); }\n \n+    /// Waits for transaction state to become not equal to the state corresponding to current_state_csn\n+    bool waitStateChange(CSN current_state_csn) const;\n+\n+    CSN getCSN() const { return csn; }\n+\n private:\n     scope_guard beforeCommit();\n     void afterCommit(CSN assigned_csn) noexcept;\ndiff --git a/src/Interpreters/MergeTreeTransactionHolder.cpp b/src/Interpreters/MergeTreeTransactionHolder.cpp\nindex bf63a4712821..2944fb78b769 100644\n--- a/src/Interpreters/MergeTreeTransactionHolder.cpp\n+++ b/src/Interpreters/MergeTreeTransactionHolder.cpp\n@@ -53,7 +53,7 @@ void MergeTreeTransactionHolder::onDestroy() noexcept\n     {\n         try\n         {\n-            TransactionLog::instance().commitTransaction(txn);\n+            TransactionLog::instance().commitTransaction(txn, /* throw_on_unknown_status */ false);\n             return;\n         }\n         catch (...)\ndiff --git a/src/Interpreters/TransactionLog.cpp b/src/Interpreters/TransactionLog.cpp\nindex e65630d907ba..4f0e79297b86 100644\n--- a/src/Interpreters/TransactionLog.cpp\n+++ b/src/Interpreters/TransactionLog.cpp\n@@ -21,6 +21,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int UNKNOWN_STATUS_OF_TRANSACTION;\n }\n \n static void tryWriteEventToSystemLog(Poco::Logger * log, ContextPtr context,\n@@ -52,6 +53,8 @@ TransactionLog::TransactionLog()\n \n     zookeeper_path = global_context->getConfigRef().getString(\"transaction_log.zookeeper_path\", \"/clickhouse/txn\");\n     zookeeper_path_log = zookeeper_path + \"/log\";\n+    fault_probability_before_commit = global_context->getConfigRef().getDouble(\"transaction_log.fault_probability_before_commit\", 0);\n+    fault_probability_after_commit = global_context->getConfigRef().getDouble(\"transaction_log.fault_probability_after_commit\", 0);\n \n     loadLogFromZooKeeper();\n \n@@ -145,24 +148,29 @@ void TransactionLog::loadEntries(Strings::const_iterator beg, Strings::const_ite\n \n     NOEXCEPT_SCOPE;\n     LockMemoryExceptionInThread lock_memory_tracker(VariableContext::Global);\n-    std::lock_guard lock{mutex};\n-    for (const auto & entry : loaded)\n     {\n-        if (entry.first == Tx::EmptyTID.getHash())\n-            continue;\n+        std::lock_guard lock{mutex};\n+        for (const auto & entry : loaded)\n+        {\n+            if (entry.first == Tx::EmptyTID.getHash())\n+                continue;\n \n-        tid_to_csn.emplace(entry.first, entry.second);\n+            tid_to_csn.emplace(entry.first, entry.second);\n+        }\n+        last_loaded_entry = last_entry;\n+    }\n+    {\n+        std::lock_guard lock{running_list_mutex};\n+        latest_snapshot = loaded.back().second.csn;\n+        local_tid_counter = Tx::MaxReservedLocalTID;\n     }\n-    last_loaded_entry = last_entry;\n-    latest_snapshot = loaded.back().second.csn;\n-    local_tid_counter = Tx::MaxReservedLocalTID;\n }\n \n void TransactionLog::loadLogFromZooKeeper()\n {\n-    assert(!zookeeper);\n-    assert(tid_to_csn.empty());\n-    assert(last_loaded_entry.empty());\n+    chassert(!zookeeper);\n+    chassert(tid_to_csn.empty());\n+    chassert(last_loaded_entry.empty());\n     zookeeper = global_context->getZooKeeper();\n \n     /// We do not write local_tid_counter to disk or zk and maintain it only in memory.\n@@ -172,7 +180,7 @@ void TransactionLog::loadLogFromZooKeeper()\n     if (code != Coordination::Error::ZOK)\n     {\n         /// Log probably does not exist, create it\n-        assert(code == Coordination::Error::ZNONODE);\n+        chassert(code == Coordination::Error::ZNONODE);\n         zookeeper->createAncestors(zookeeper_path_log);\n         Coordination::Requests ops;\n         ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/tail_ptr\", serializeCSN(Tx::MaxReservedCSN), zkutil::CreateMode::Persistent));\n@@ -192,11 +200,11 @@ void TransactionLog::loadLogFromZooKeeper()\n     /// 2. simplify log rotation\n     /// 3. support 64-bit CSNs on top of Apache ZooKeeper (it uses Int32 for sequential numbers)\n     Strings entries_list = zookeeper->getChildren(zookeeper_path_log, nullptr, log_updated_event);\n-    assert(!entries_list.empty());\n+    chassert(!entries_list.empty());\n     std::sort(entries_list.begin(), entries_list.end());\n     loadEntries(entries_list.begin(), entries_list.end());\n-    assert(!last_loaded_entry.empty());\n-    assert(latest_snapshot == deserializeCSN(last_loaded_entry));\n+    chassert(!last_loaded_entry.empty());\n+    chassert(latest_snapshot == deserializeCSN(last_loaded_entry));\n     local_tid_counter = Tx::MaxReservedLocalTID;\n \n     tail_ptr = deserializeCSN(zookeeper->get(zookeeper_path + \"/tail_ptr\"));\n@@ -208,19 +216,31 @@ void TransactionLog::runUpdatingThread()\n     {\n         try\n         {\n-            log_updated_event->wait();\n+            /// Do not wait if we have some transactions to finalize\n+            if (!unknown_state_list_loaded.empty())\n+                log_updated_event->wait();\n+\n             if (stop_flag.load())\n                 return;\n \n-            if (getZooKeeper()->expired())\n+            bool connection_loss = getZooKeeper()->expired();\n+            if (connection_loss)\n             {\n                 auto new_zookeeper = global_context->getZooKeeper();\n-                std::lock_guard lock{mutex};\n-                zookeeper = new_zookeeper;\n+                {\n+                    std::lock_guard lock{mutex};\n+                    zookeeper = new_zookeeper;\n+                }\n+\n+                /// It's possible that we connected to different [Zoo]Keeper instance\n+                /// so we may read a bit stale state. Run some writing request before loading log entries\n+                /// to make that instance up-to-date.\n+                zookeeper->set(zookeeper_path_log, \"\");\n             }\n \n             loadNewEntries();\n             removeOldEntries();\n+            tryFinalizeUnknownStateTransactions();\n         }\n         catch (const Coordination::Exception &)\n         {\n@@ -241,12 +261,12 @@ void TransactionLog::runUpdatingThread()\n void TransactionLog::loadNewEntries()\n {\n     Strings entries_list = zookeeper->getChildren(zookeeper_path_log, nullptr, log_updated_event);\n-    assert(!entries_list.empty());\n+    chassert(!entries_list.empty());\n     std::sort(entries_list.begin(), entries_list.end());\n     auto it = std::upper_bound(entries_list.begin(), entries_list.end(), last_loaded_entry);\n     loadEntries(it, entries_list.end());\n-    assert(last_loaded_entry == entries_list.back());\n-    assert(latest_snapshot == deserializeCSN(last_loaded_entry));\n+    chassert(last_loaded_entry == entries_list.back());\n+    chassert(latest_snapshot == deserializeCSN(last_loaded_entry));\n     latest_snapshot.notify_all();\n }\n \n@@ -309,6 +329,46 @@ void TransactionLog::removeOldEntries()\n         tid_to_csn.erase(tid_hash);\n }\n \n+void TransactionLog::tryFinalizeUnknownStateTransactions()\n+{\n+    /// We just recovered connection to [Zoo]Keeper.\n+    /// Check if transactions in unknown state were actually committed or not and finalize or rollback them.\n+    UnknownStateList list;\n+    {\n+        /// We must be sure that the corresponding CSN entry is loaded from ZK.\n+        /// Otherwise we may accidentally rollback committed transaction in case of race condition like this:\n+        ///   - runUpdatingThread: loaded some entries, ready to call tryFinalizeUnknownStateTransactions()\n+        ///   - commitTransaction: creates CSN entry in the log (txn is committed)\n+        ///   - [session expires]\n+        ///   - commitTransaction: catches Coordination::Exception (maybe due to fault injection), appends txn to unknown_state_list\n+        ///   - runUpdatingThread: calls tryFinalizeUnknownStateTransactions(), fails to find CSN for this txn, rolls it back\n+        /// So all CSN entries that might exist at the moment of appending txn to unknown_state_list\n+        /// must be loaded from ZK before we start finalize that txn.\n+        /// That's why we use two lists here:\n+        ///    1. At first we put txn into unknown_state_list\n+        ///    2. We move it to unknown_state_list_loaded when runUpdatingThread done at least one iteration\n+        ///    3. Then we can safely finalize txns from unknown_state_list_loaded, because all required entries are loaded\n+        std::lock_guard lock{running_list_mutex};\n+        std::swap(list, unknown_state_list);\n+        std::swap(list, unknown_state_list_loaded);\n+    }\n+\n+    for (auto & [txn, state_guard] : list)\n+    {\n+        /// CSNs must be already loaded, only need to check if the corresponding mapping exists.\n+        if (auto csn = getCSN(txn->tid))\n+        {\n+            finalizeCommittedTransaction(txn, csn, state_guard);\n+        }\n+        else\n+        {\n+            assertTIDIsNotOutdated(txn->tid);\n+            state_guard = {};\n+            rollbackTransaction(txn->shared_from_this());\n+        }\n+    }\n+}\n+\n CSN TransactionLog::getLatestSnapshot() const\n {\n     return latest_snapshot.load();\n@@ -334,58 +394,117 @@ MergeTreeTransactionPtr TransactionLog::beginTransaction()\n     return txn;\n }\n \n-CSN TransactionLog::commitTransaction(const MergeTreeTransactionPtr & txn)\n+CSN TransactionLog::commitTransaction(const MergeTreeTransactionPtr & txn, bool throw_on_unknown_status)\n {\n     /// Some precommit checks, may throw\n-    auto committing_lock = txn->beforeCommit();\n+    auto state_guard = txn->beforeCommit();\n \n-    CSN new_csn;\n+    CSN allocated_csn = Tx::UnknownCSN;\n     if (txn->isReadOnly())\n     {\n         /// Don't need to allocate CSN in ZK for readonly transactions, it's safe to use snapshot/start_csn as \"commit\" timestamp\n         LOG_TEST(log, \"Closing readonly transaction {}\", txn->tid);\n-        new_csn = txn->snapshot;\n-        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, new_csn);\n     }\n     else\n     {\n         LOG_TEST(log, \"Committing transaction {}\", txn->dumpDescription());\n-        /// TODO handle connection loss\n         /// TODO support batching\n         auto current_zookeeper = getZooKeeper();\n-        String path_created = current_zookeeper->create(zookeeper_path_log + \"/csn-\", serializeTID(txn->tid), zkutil::CreateMode::PersistentSequential);    /// Commit point\n-        NOEXCEPT_SCOPE;\n+        String csn_path_created;\n+        try\n+        {\n+            if (unlikely(fault_probability_before_commit))\n+            {\n+                std::bernoulli_distribution fault(fault_probability_before_commit);\n+                if (fault(thread_local_rng))\n+                    throw Coordination::Exception(\"Fault injected (before commit)\", Coordination::Error::ZCONNECTIONLOSS);\n+            }\n+\n+            /// Commit point\n+            csn_path_created = current_zookeeper->create(zookeeper_path_log + \"/csn-\", serializeTID(txn->tid), zkutil::CreateMode::PersistentSequential);\n+\n+            if (unlikely(fault_probability_after_commit))\n+            {\n+                std::bernoulli_distribution fault(fault_probability_after_commit);\n+                if (fault(thread_local_rng))\n+                    throw Coordination::Exception(\"Fault injected (after commit)\", Coordination::Error::ZCONNECTIONLOSS);\n+            }\n+        }\n+        catch (const Coordination::Exception & e)\n+        {\n+            if (!Coordination::isHardwareError(e.code))\n+                throw;\n+\n+            /// We don't know if transaction has been actually committed or not.\n+            /// The only thing we can do is to postpone its finalization.\n+            {\n+                std::lock_guard lock{running_list_mutex};\n+                unknown_state_list.emplace_back(txn.get(), std::move(state_guard));\n+            }\n+            log_updated_event->set();\n+            if (throw_on_unknown_status)\n+                throw Exception(ErrorCodes::UNKNOWN_STATUS_OF_TRANSACTION,\n+                                \"Connection lost on attempt to commit transaction {}, will finalize it later: {}\",\n+                                txn->tid, e.message());\n \n+            LOG_INFO(log, \"Connection lost on attempt to commit transaction {}, will finalize it later: {}\", txn->tid, e.message());\n+            return Tx::CommittingCSN;\n+        }\n+\n+        /// Do not allow exceptions between commit point and the and of transaction finalization\n+        /// (otherwise it may stuck in COMMITTING state holding snapshot).\n+        NOEXCEPT_SCOPE;\n         /// FIXME Transactions: Sequential node numbers in ZooKeeper are Int32, but 31 bit is not enough for production use\n         /// (overflow is possible in a several weeks/months of active usage)\n-        new_csn = deserializeCSN(path_created.substr(zookeeper_path_log.size() + 1));\n+        allocated_csn = deserializeCSN(csn_path_created.substr(zookeeper_path_log.size() + 1));\n+    }\n \n-        LOG_INFO(log, \"Transaction {} committed with CSN={}\", txn->tid, new_csn);\n-        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, new_csn);\n+    return finalizeCommittedTransaction(txn.get(), allocated_csn, state_guard);\n+}\n \n-        /// Wait for committed changes to become actually visible, so the next transaction in this session will see the changes\n-        /// TODO it's optional, add a setting for this\n-        auto current_latest_snapshot = latest_snapshot.load();\n-        while (current_latest_snapshot < new_csn && !stop_flag)\n-        {\n-            latest_snapshot.wait(current_latest_snapshot);\n-            current_latest_snapshot = latest_snapshot.load();\n-        }\n+CSN TransactionLog::finalizeCommittedTransaction(MergeTreeTransaction * txn, CSN allocated_csn, scope_guard & state_guard) noexcept\n+{\n+    chassert(!allocated_csn == txn->isReadOnly());\n+    if (allocated_csn)\n+    {\n+        LOG_INFO(log, \"Transaction {} committed with CSN={}\", txn->tid, allocated_csn);\n+        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, allocated_csn);\n+    }\n+    else\n+    {\n+        /// Transaction was readonly\n+        allocated_csn = txn->snapshot;\n+        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, allocated_csn);\n     }\n \n     /// Write allocated CSN, so we will be able to cleanup log in ZK. This method is noexcept.\n-    txn->afterCommit(new_csn);\n+    txn->afterCommit(allocated_csn);\n+    state_guard = {};\n \n     {\n         /// Finally we can remove transaction from the list and release the snapshot\n         std::lock_guard lock{running_list_mutex};\n+        snapshots_in_use.erase(txn->snapshot_in_use_it);\n         bool removed = running_list.erase(txn->tid.getHash());\n         if (!removed)\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"I's a bug: TID {} {} doesn't exist\", txn->tid.getHash(), txn->tid);\n-        snapshots_in_use.erase(txn->snapshot_in_use_it);\n+        {\n+            LOG_ERROR(log , \"I's a bug: TID {} {} doesn't exist\", txn->tid.getHash(), txn->tid);\n+            abort();\n+        }\n     }\n \n-    return new_csn;\n+    return allocated_csn;\n+}\n+\n+bool TransactionLog::waitForCSNLoaded(CSN csn) const\n+{\n+    auto current_latest_snapshot = latest_snapshot.load();\n+    while (current_latest_snapshot < csn && !stop_flag)\n+    {\n+        latest_snapshot.wait(current_latest_snapshot);\n+        current_latest_snapshot = latest_snapshot.load();\n+    }\n+    return csn <= current_latest_snapshot;\n }\n \n void TransactionLog::rollbackTransaction(const MergeTreeTransactionPtr & txn) noexcept\n@@ -395,8 +514,8 @@ void TransactionLog::rollbackTransaction(const MergeTreeTransactionPtr & txn) no\n \n     if (!txn->rollback())\n     {\n-        /// Transaction was cancelled concurrently, it's already rolled back.\n-        assert(txn->csn == Tx::RolledBackCSN);\n+        /// Transaction was cancelled or committed concurrently\n+        chassert(txn->csn != Tx::UnknownCSN);\n         return;\n     }\n \n@@ -438,8 +557,8 @@ CSN TransactionLog::getCSN(const TIDHash & tid)\n \n CSN TransactionLog::getCSNImpl(const TIDHash & tid_hash) const\n {\n-    assert(tid_hash);\n-    assert(tid_hash != Tx::EmptyTID.getHash());\n+    chassert(tid_hash);\n+    chassert(tid_hash != Tx::EmptyTID.getHash());\n \n     std::lock_guard lock{mutex};\n     auto it = tid_to_csn.find(tid_hash);\n@@ -467,6 +586,8 @@ CSN TransactionLog::getOldestSnapshot() const\n     std::lock_guard lock{running_list_mutex};\n     if (snapshots_in_use.empty())\n         return getLatestSnapshot();\n+    chassert(running_list.size() == snapshots_in_use.size());\n+    chassert(snapshots_in_use.size() < 2 || snapshots_in_use.front() <= *++snapshots_in_use.begin());\n     return snapshots_in_use.front();\n }\n \ndiff --git a/src/Interpreters/TransactionLog.h b/src/Interpreters/TransactionLog.h\nindex 86584a74c688..a0268ce9b885 100644\n--- a/src/Interpreters/TransactionLog.h\n+++ b/src/Interpreters/TransactionLog.h\n@@ -97,7 +97,8 @@ class TransactionLog final : public SingletonHelper<TransactionLog>\n     /// Tries to commit transaction. Returns Commit Sequence Number.\n     /// Throw if transaction was concurrently killed or if some precommit check failed.\n     /// May throw if ZK connection is lost. Transaction status is unknown in this case.\n-    CSN commitTransaction(const MergeTreeTransactionPtr & txn);\n+    /// Returns CommittingCSN if throw_on_unknown_status is false and connection was lost.\n+    CSN commitTransaction(const MergeTreeTransactionPtr & txn, bool throw_on_unknown_status);\n \n     /// Releases locks that that were acquired by transaction, releases snapshot, removes transaction from the list of active transactions.\n     /// Normally it should not throw, but if it does for some reason (global memory limit exceeded, disk failure, etc)\n@@ -119,6 +120,12 @@ class TransactionLog final : public SingletonHelper<TransactionLog>\n     /// Returns copy of list of running transactions.\n     TransactionsList getTransactionsList() const;\n \n+    /// Waits for provided CSN (and all previous ones) to be loaded from the log.\n+    /// Returns false if waiting was interrupted (e.g. by shutdown)\n+    bool waitForCSNLoaded(CSN csn) const;\n+\n+    bool isShuttingDown() const { return stop_flag.load(); }\n+\n private:\n     void loadLogFromZooKeeper();\n     void runUpdatingThread();\n@@ -127,6 +134,10 @@ class TransactionLog final : public SingletonHelper<TransactionLog>\n     void loadNewEntries();\n     void removeOldEntries();\n \n+    CSN finalizeCommittedTransaction(MergeTreeTransaction * txn, CSN allocated_csn, scope_guard & state_guard) noexcept;\n+\n+    void tryFinalizeUnknownStateTransactions();\n+\n     static UInt64 deserializeCSN(const String & csn_node_name);\n     static String serializeCSN(CSN csn);\n     static TransactionID deserializeTID(const String & csn_node_content);\n@@ -159,6 +170,10 @@ class TransactionLog final : public SingletonHelper<TransactionLog>\n     mutable std::mutex running_list_mutex;\n     /// Transactions that are currently processed\n     TransactionsList running_list;\n+    /// If we lost connection on attempt to create csn- node then we don't know transaction's state.\n+    using UnknownStateList = std::vector<std::pair<MergeTreeTransaction *, scope_guard>>;\n+    UnknownStateList unknown_state_list;\n+    UnknownStateList unknown_state_list_loaded;\n     /// Ordered list of snapshots that are currently used by some transactions. Needed for background cleanup.\n     std::list<CSN> snapshots_in_use;\n \n@@ -175,6 +190,9 @@ class TransactionLog final : public SingletonHelper<TransactionLog>\n \n     std::atomic_bool stop_flag = false;\n     ThreadFromGlobalPool updating_thread;\n+\n+    Float64 fault_probability_before_commit = 0;\n+    Float64 fault_probability_after_commit = 0;\n };\n \n template <typename Derived>\ndiff --git a/src/Interpreters/TransactionVersionMetadata.cpp b/src/Interpreters/TransactionVersionMetadata.cpp\nindex b965ade8d100..36a4fb9cc5be 100644\n--- a/src/Interpreters/TransactionVersionMetadata.cpp\n+++ b/src/Interpreters/TransactionVersionMetadata.cpp\n@@ -88,8 +88,8 @@ void VersionMetadata::lockRemovalTID(const TransactionID & tid, const Transactio\n \n bool VersionMetadata::tryLockRemovalTID(const TransactionID & tid, const TransactionInfoContext & context, TIDHash * locked_by_id)\n {\n-    assert(!tid.isEmpty());\n-    assert(!creation_tid.isEmpty());\n+    chassert(!tid.isEmpty());\n+    chassert(!creation_tid.isEmpty());\n     TIDHash removal_lock_value = tid.getHash();\n     TIDHash expected_removal_lock_value = 0;\n     bool locked = removal_tid_lock.compare_exchange_strong(expected_removal_lock_value, removal_lock_value);\n@@ -115,7 +115,7 @@ bool VersionMetadata::tryLockRemovalTID(const TransactionID & tid, const Transac\n void VersionMetadata::unlockRemovalTID(const TransactionID & tid, const TransactionInfoContext & context)\n {\n     LOG_TEST(log, \"Unlocking removal_tid by {}, table: {}, part: {}\", tid, context.table.getNameForLogs(), context.part_name);\n-    assert(!tid.isEmpty());\n+    chassert(!tid.isEmpty());\n     TIDHash removal_lock_value = tid.getHash();\n     TIDHash locked_by = removal_tid_lock.load();\n \n@@ -145,7 +145,7 @@ bool VersionMetadata::isRemovalTIDLocked() const\n void VersionMetadata::setCreationTID(const TransactionID & tid, TransactionInfoContext * context)\n {\n     /// NOTE ReplicatedMergeTreeSink may add one part multiple times\n-    assert(creation_tid.isEmpty() || creation_tid == tid);\n+    chassert(creation_tid.isEmpty() || creation_tid == tid);\n     creation_tid = tid;\n     if (context)\n         tryWriteEventToSystemLog(log, TransactionsInfoLogElement::ADD_PART, tid, *context);\n@@ -158,7 +158,7 @@ bool VersionMetadata::isVisible(const MergeTreeTransaction & txn)\n \n bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)\n {\n-    assert(!creation_tid.isEmpty());\n+    chassert(!creation_tid.isEmpty());\n     CSN creation = creation_csn.load(std::memory_order_relaxed);\n     TIDHash removal_lock = removal_tid_lock.load(std::memory_order_relaxed);\n     CSN removal = removal_csn.load(std::memory_order_relaxed);\n@@ -166,10 +166,10 @@ bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)\n     [[maybe_unused]] bool had_creation_csn = creation;\n     [[maybe_unused]] bool had_removal_tid = removal_lock;\n     [[maybe_unused]] bool had_removal_csn = removal;\n-    assert(!had_removal_csn || had_removal_tid);\n-    assert(!had_removal_csn || had_creation_csn);\n-    assert(creation == Tx::UnknownCSN || creation == Tx::PrehistoricCSN || Tx::MaxReservedCSN < creation);\n-    assert(removal == Tx::UnknownCSN || removal == Tx::PrehistoricCSN || Tx::MaxReservedCSN < removal);\n+    chassert(!had_removal_csn || had_removal_tid);\n+    chassert(!had_removal_csn || had_creation_csn);\n+    chassert(creation == Tx::UnknownCSN || creation == Tx::PrehistoricCSN || Tx::MaxReservedCSN < creation);\n+    chassert(removal == Tx::UnknownCSN || removal == Tx::PrehistoricCSN || Tx::MaxReservedCSN < removal);\n \n     /// Special snapshot for introspection purposes\n     if (unlikely(snapshot_version == Tx::EverythingVisibleCSN))\n@@ -204,8 +204,8 @@ bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)\n     /// Data part has creation_tid/removal_tid, but does not have creation_csn/removal_csn.\n     /// It means that some transaction is creating/removing the part right now or has done it recently\n     /// and we don't know if it was already committed or not.\n-    assert(!had_creation_csn || (had_removal_tid && !had_removal_csn));\n-    assert(current_tid.isEmpty() || (creation_tid != current_tid && removal_lock != current_tid.getHash()));\n+    chassert(!had_creation_csn || (had_removal_tid && !had_removal_csn));\n+    chassert(current_tid.isEmpty() || (creation_tid != current_tid && removal_lock != current_tid.getHash()));\n \n     /// Before doing CSN lookup, let's check some extra conditions.\n     /// If snapshot_version <= some_tid.start_csn, then changes of the transaction with some_tid\n@@ -347,8 +347,8 @@ void VersionMetadata::write(WriteBuffer & buf) const\n \n     if (removal_tid_lock)\n     {\n-        assert(!removal_tid.isEmpty());\n-        assert(removal_tid.getHash() == removal_tid_lock);\n+        chassert(!removal_tid.isEmpty());\n+        chassert(removal_tid.getHash() == removal_tid_lock);\n         writeRemovalTID(buf);\n         writeCSN(buf, REMOVAL, /* internal */ true);\n     }\n@@ -384,21 +384,23 @@ void VersionMetadata::read(ReadBuffer & buf)\n \n         if (name == CREATION_CSN_STR)\n         {\n-            assert(!creation_csn);\n+            chassert(!creation_csn);\n             creation_csn = read_csn();\n         }\n         else if (name == REMOVAL_TID_STR)\n         {\n             /// NOTE Metadata file may actually contain multiple creation TIDs, we need the last one.\n             removal_tid = TransactionID::read(buf);\n-            if (!removal_tid.isEmpty())\n+            if (removal_tid.isEmpty())\n+                removal_tid_lock = 0;\n+            else\n                 removal_tid_lock = removal_tid.getHash();\n         }\n         else if (name == REMOVAL_CSN_STR)\n         {\n             if (removal_tid.isEmpty())\n                 throw Exception(ErrorCodes::CANNOT_PARSE_TEXT, \"Found removal_csn in metadata file, but removal_tid is {}\", removal_tid);\n-            assert(!removal_csn);\n+            chassert(!removal_csn);\n             removal_csn = read_csn();\n         }\n         else\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 3c03bea3dd18..186c8c30cfa8 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -444,9 +444,10 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n \n         if (auto txn = context->getCurrentTransaction())\n         {\n-            assert(txn->getState() != MergeTreeTransaction::COMMITTED);\n+            chassert(txn->getState() != MergeTreeTransaction::COMMITTING);\n+            chassert(txn->getState() != MergeTreeTransaction::COMMITTED);\n             if (txn->getState() == MergeTreeTransaction::ROLLED_BACK && !ast->as<ASTTransactionControl>() && !ast->as<ASTExplainQuery>())\n-                throw Exception(ErrorCodes::INVALID_TRANSACTION, \"Cannot execute query: transaction is rolled back\");\n+                throw Exception(ErrorCodes::INVALID_TRANSACTION, \"Cannot execute query because current transaction failed. Expecting ROLLBACK statement.\");\n         }\n \n         /// Interpret SETTINGS clauses as early as possible (before invoking the corresponding interpreter),\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 2c9dd2b49344..40fba34cd03d 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -1282,12 +1282,12 @@ void IMergeTreeDataPart::storeVersionMetadata() const\n \n void IMergeTreeDataPart::appendCSNToVersionMetadata(VersionMetadata::WhichCSN which_csn) const\n {\n-    assert(!version.creation_tid.isEmpty());\n-    assert(!(which_csn == VersionMetadata::WhichCSN::CREATION && version.creation_tid.isPrehistoric()));\n-    assert(!(which_csn == VersionMetadata::WhichCSN::CREATION && version.creation_csn == 0));\n-    assert(!(which_csn == VersionMetadata::WhichCSN::REMOVAL && (version.removal_tid.isPrehistoric() || version.removal_tid.isEmpty())));\n-    assert(!(which_csn == VersionMetadata::WhichCSN::REMOVAL && version.removal_csn == 0));\n-    assert(isStoredOnDisk());\n+    chassert(!version.creation_tid.isEmpty());\n+    chassert(!(which_csn == VersionMetadata::WhichCSN::CREATION && version.creation_tid.isPrehistoric()));\n+    chassert(!(which_csn == VersionMetadata::WhichCSN::CREATION && version.creation_csn == 0));\n+    chassert(!(which_csn == VersionMetadata::WhichCSN::REMOVAL && (version.removal_tid.isPrehistoric() || version.removal_tid.isEmpty())));\n+    chassert(!(which_csn == VersionMetadata::WhichCSN::REMOVAL && version.removal_csn == 0));\n+    chassert(isStoredOnDisk());\n \n     /// Small enough appends to file are usually atomic,\n     /// so we append new metadata instead of rewriting file to reduce number of fsyncs.\n@@ -1303,10 +1303,10 @@ void IMergeTreeDataPart::appendCSNToVersionMetadata(VersionMetadata::WhichCSN wh\n \n void IMergeTreeDataPart::appendRemovalTIDToVersionMetadata(bool clear) const\n {\n-    assert(!version.creation_tid.isEmpty());\n-    assert(version.removal_csn == 0);\n-    assert(!version.removal_tid.isEmpty());\n-    assert(isStoredOnDisk());\n+    chassert(!version.creation_tid.isEmpty());\n+    chassert(version.removal_csn == 0);\n+    chassert(!version.removal_tid.isEmpty());\n+    chassert(isStoredOnDisk());\n \n     if (version.creation_tid.isPrehistoric() && !clear)\n     {\n@@ -1437,7 +1437,9 @@ bool IMergeTreeDataPart::assertHasValidVersionMetadata() const\n         bool valid_removal_tid = version.removal_tid == file.removal_tid || version.removal_tid == Tx::PrehistoricTID;\n         bool valid_creation_csn = version.creation_csn == file.creation_csn || version.creation_csn == Tx::RolledBackCSN;\n         bool valid_removal_csn = version.removal_csn == file.removal_csn || version.removal_csn == Tx::PrehistoricCSN;\n-        if (!valid_creation_tid || !valid_removal_tid || !valid_creation_csn || !valid_removal_csn)\n+        bool valid_removal_tid_lock = (version.removal_tid.isEmpty() && version.removal_tid_lock == 0)\n+            || (version.removal_tid_lock == version.removal_tid.getHash());\n+        if (!valid_creation_tid || !valid_removal_tid || !valid_creation_csn || !valid_removal_csn || !valid_removal_tid_lock)\n             throw Exception(ErrorCodes::CORRUPTED_DATA, \"Invalid version metadata file\");\n         return true;\n     }\n@@ -1445,7 +1447,8 @@ bool IMergeTreeDataPart::assertHasValidVersionMetadata() const\n     {\n         WriteBufferFromOwnString expected;\n         version.write(expected);\n-        tryLogCurrentException(storage.log, fmt::format(\"File {} contains:\\n{}\\nexpected:\\n{}\", version_file_name, content, expected.str()));\n+        tryLogCurrentException(storage.log, fmt::format(\"File {} contains:\\n{}\\nexpected:\\n{}\\nlock: {}\",\n+                                                        version_file_name, content, expected.str(), version.removal_tid_lock));\n         return false;\n     }\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 50811daa4abf..d2c757f67509 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1364,7 +1364,7 @@ void MergeTreeData::loadDataParts(bool skip_sanity_checks)\n \n         /// Check if CSNs were witten after committing transaction, update and write if needed.\n         bool version_updated = false;\n-        assert(!version.creation_tid.isEmpty());\n+        chassert(!version.creation_tid.isEmpty());\n         if (!part->version.creation_csn)\n         {\n             auto min = TransactionLog::getCSN(version.creation_tid);\ndiff --git a/src/Storages/System/StorageSystemParts.cpp b/src/Storages/System/StorageSystemParts.cpp\nindex 6674de06c07a..a8edb8dd78ba 100644\n--- a/src/Storages/System/StorageSystemParts.cpp\n+++ b/src/Storages/System/StorageSystemParts.cpp\n@@ -85,6 +85,7 @@ StorageSystemParts::StorageSystemParts(const StorageID & table_id_)\n \n         {\"visible\",                                     std::make_shared<DataTypeUInt8>()},\n         {\"creation_tid\",                                getTransactionIDDataType()},\n+        {\"removal_tid_lock\",                            std::make_shared<DataTypeUInt64>()},\n         {\"removal_tid\",                                 getTransactionIDDataType()},\n         {\"creation_csn\",                                std::make_shared<DataTypeUInt64>()},\n         {\"removal_csn\",                                 std::make_shared<DataTypeUInt64>()},\n@@ -295,6 +296,8 @@ void StorageSystemParts::processNextStorage(\n \n         if (columns_mask[src_index++])\n             columns[res_index++]->insert(get_tid_as_field(part->version.creation_tid));\n+        if (columns_mask[src_index++])\n+            columns[res_index++]->insert(part->version.removal_tid_lock.load(std::memory_order_relaxed));\n         if (columns_mask[src_index++])\n             columns[res_index++]->insert(get_tid_as_field(part->version.getRemovalTID()));\n         if (columns_mask[src_index++])\ndiff --git a/src/Storages/System/StorageSystemTransactions.cpp b/src/Storages/System/StorageSystemTransactions.cpp\nindex 396fc875f74e..21fa72ea12a8 100644\n--- a/src/Storages/System/StorageSystemTransactions.cpp\n+++ b/src/Storages/System/StorageSystemTransactions.cpp\n@@ -15,6 +15,7 @@ static DataTypePtr getStateEnumType()\n     DataTypeEnum8::Values\n         {\n             {\"RUNNING\",           static_cast<Int8>(MergeTreeTransaction::State::RUNNING)},\n+            {\"COMMITTING\",           static_cast<Int8>(MergeTreeTransaction::State::COMMITTING)},\n             {\"COMMITTED\",         static_cast<Int8>(MergeTreeTransaction::State::COMMITTED)},\n             {\"ROLLED_BACK\",       static_cast<Int8>(MergeTreeTransaction::State::ROLLED_BACK)},\n         });\n",
  "test_patch": "diff --git a/tests/config/config.d/transactions.xml b/tests/config/config.d/transactions.xml\nindex 19810986ea10..9948b1f1865e 100644\n--- a/tests/config/config.d/transactions.xml\n+++ b/tests/config/config.d/transactions.xml\n@@ -10,4 +10,12 @@\n         <flush_interval_milliseconds>7500</flush_interval_milliseconds>\n     </transactions_info_log>\n \n+    <transaction_log>\n+        <zookeeper_path>/test/clickhouse/txn</zookeeper_path>\n+\n+        <fault_probability_before_commit>0.0</fault_probability_before_commit>\n+\n+        <!-- Fault injection after commit should not affect tests, because default waiting mode is WAIT_UNKNOWN -->\n+        <fault_probability_after_commit>0.01</fault_probability_after_commit>\n+    </transaction_log>\n </yandex>\ndiff --git a/tests/queries/0_stateless/01133_begin_commit_race.reference b/tests/queries/0_stateless/01133_begin_commit_race.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01133_begin_commit_race.sh b/tests/queries/0_stateless/01133_begin_commit_race.sh\nnew file mode 100755\nindex 000000000000..f64570950c71\n--- /dev/null\n+++ b/tests/queries/0_stateless/01133_begin_commit_race.sh\n@@ -0,0 +1,58 @@\n+#!/usr/bin/env bash\n+# Tags: long\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+set -e\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS mt\";\n+$CLICKHOUSE_CLIENT --query \"CREATE TABLE mt (n Int64) ENGINE=MergeTree ORDER BY n SETTINGS old_parts_lifetime=0\";\n+\n+\n+function begin_commit_readonly()\n+{\n+    $CLICKHOUSE_CLIENT --multiquery --query \"\n+            SET wait_changes_become_visible_after_commit_mode='wait';\n+            BEGIN TRANSACTION;\n+            COMMIT;\" 2>&1| grep -Fa \"Exception: \" | grep -Fv UNKNOWN_STATUS_OF_TRANSACTION\n+}\n+\n+function begin_rollback_readonly()\n+{\n+    $CLICKHOUSE_CLIENT --wait_changes_become_visible_after_commit_mode=wait_unknown --multiquery --query \"\n+            BEGIN TRANSACTION;\n+            SET TRANSACTION SNAPSHOT 42;\n+            ROLLBACK;\"\n+}\n+\n+function begin_insert_commit()\n+{\n+    $CLICKHOUSE_CLIENT --wait_changes_become_visible_after_commit_mode=async --multiquery --query \"\n+            BEGIN TRANSACTION;\n+            INSERT INTO mt VALUES ($RANDOM);\n+            COMMIT;\" 2>&1| grep -Fa \"Exception: \" | grep -Fv UNKNOWN_STATUS_OF_TRANSACTION\n+}\n+\n+function introspection()\n+{\n+    $CLICKHOUSE_CLIENT -q \"SELECT * FROM system.transactions FORMAT Null\"\n+    $CLICKHOUSE_CLIENT -q \"SELECT transactionLatestSnapshot(), transactionOldestSnapshot() FORMAT Null\"\n+}\n+\n+export -f begin_commit_readonly\n+export -f begin_rollback_readonly\n+export -f begin_insert_commit\n+export -f introspection\n+\n+TIMEOUT=20\n+\n+clickhouse_client_loop_timeout $TIMEOUT begin_commit_readonly &\n+clickhouse_client_loop_timeout $TIMEOUT begin_rollback_readonly &\n+clickhouse_client_loop_timeout $TIMEOUT begin_insert_commit &\n+clickhouse_client_loop_timeout $TIMEOUT introspection &\n+\n+wait\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE mt\";\ndiff --git a/tests/queries/0_stateless/01172_transaction_counters.sql b/tests/queries/0_stateless/01172_transaction_counters.sql\nindex 5431673fd62a..b84a7b25c471 100644\n--- a/tests/queries/0_stateless/01172_transaction_counters.sql\n+++ b/tests/queries/0_stateless/01172_transaction_counters.sql\n@@ -42,7 +42,13 @@ rollback;\n \n system flush logs;\n select indexOf((select arraySort(groupUniqArray(tid)) from system.transactions_info_log where database=currentDatabase() and table='txn_counters'), tid),\n-       (toDecimal64(now64(6), 6) - toDecimal64(event_time, 6)) < 100, type, thread_id!=0, length(query_id)=length(queryID()), tid_hash!=0, csn=0, part\n+       (toDecimal64(now64(6), 6) - toDecimal64(event_time, 6)) < 100,\n+       type,\n+       thread_id!=0,\n+       length(query_id)=length(queryID()) or type='Commit' and query_id='',  -- ignore fault injection after commit\n+       tid_hash!=0,\n+       csn=0,\n+       part\n from system.transactions_info_log\n where tid in (select tid from system.transactions_info_log where database=currentDatabase() and table='txn_counters' and not (tid.1=1 and tid.2=1))\n or (database=currentDatabase() and table='txn_counters') order by event_time;\ndiff --git a/tests/queries/0_stateless/02117_show_create_table_system.reference b/tests/queries/0_stateless/02117_show_create_table_system.reference\nindex ad18e38adcca..d4ada9ba5c8f 100644\n--- a/tests/queries/0_stateless/02117_show_create_table_system.reference\n+++ b/tests/queries/0_stateless/02117_show_create_table_system.reference\n@@ -485,6 +485,7 @@ CREATE TABLE system.parts\n     `projections` Array(String),\n     `visible` UInt8,\n     `creation_tid` Tuple(UInt64, UInt64, UUID),\n+    `removal_tid_lock` UInt64,\n     `removal_tid` Tuple(UInt64, UInt64, UUID),\n     `creation_csn` UInt64,\n     `removal_csn` UInt64,\n",
  "problem_statement": "Transaction rollback aborted\nReport: https://s3.amazonaws.com/clickhouse-test-reports/36947/240d063df3985d54215d636fe68bc7a08f3338c9/stress_test__debug__actions_.html\r\n```\r\n2022.05.10 16:43:37.766030 [ 765 ] {f41c7dc9-8dc0-4b38-9ea3-8b355f7511f4::200001_11_11_0_12} <Trace> MergedBlockOutputStream: filled checksums 200001_11_11_0_12 (state Temporary)\r\n2022.05.10 16:43:38.033023 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Trace> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Renaming temporary part tmp_merge_all_1_166_21 to all_1_166_21.\r\n2022.05.10 16:43:38.128466 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_1_150_20\r\n2022.05.10 16:43:38.140403 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_1_150_20 (creation: (186, 106, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.146535 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_152_152_0\r\n2022.05.10 16:43:38.149169 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_152_152_0 (creation: (184, 36, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.156443 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_154_154_0\r\n2022.05.10 16:43:38.156986 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_154_154_0 (creation: (184, 37, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.159785 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_155_155_0\r\n2022.05.10 16:43:38.162823 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_155_155_0 (creation: (184, 37, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.166237 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_156_156_0\r\n2022.05.10 16:43:38.176535 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_156_156_0 (creation: (184, 36, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.180755 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_163_163_0\r\n2022.05.10 16:43:38.182130 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_163_163_0 (creation: (192, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.185295 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_164_164_0\r\n2022.05.10 16:43:38.195583 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_164_164_0 (creation: (192, 42, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.200524 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_165_165_0\r\n2022.05.10 16:43:38.204152 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_165_165_0 (creation: (192, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.208219 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> VersionMetadata: Trying to lock removal_tid by (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69), table: test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032), part: all_166_166_0\r\n2022.05.10 16:43:38.210982 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Test> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032): Appending removal TID for all_166_166_0 (creation: (192, 42, 78350abb-a9f7-4c76-b390-089625b0bd69), removal (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69))\r\n2022.05.10 16:43:38.222773 [ 765 ] {6012eeee-ae36-440f-a186-9c1e127fd032::all_1_166_21} <Trace> test_27.dst (6012eeee-ae36-440f-a186-9c1e127fd032) (MergerMutator): Merged 9 parts: from all_1_150_20 to all_166_166_0\r\n2022.05.10 16:43:38.230849 [ 765 ] {} <Test> TransactionLog: Committing transaction (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69) state: RUNNING, snapshot: 198, affects 1 tables:\r\n2022.05.10 16:43:51.756993 [ 765 ] {} <Error> void DB::MergeTreeTransactionHolder::onDestroy(): Code: 999. Coordination::Exception: Connection loss, path: /clickhouse/txn/log/csn-. (KEEPER_EXCEPTION), Stack trace (when copying this message, always include the lines below):\r\n0. /build/build_docker/../contrib/libcxx/include/exception:133: std::exception::capture() @ 0x17368762 in /usr/bin/clickhouse\r\n1. /build/build_docker/../contrib/libcxx/include/exception:111: std::exception::exception() @ 0x17368733 in /usr/bin/clickhouse\r\n2. /build/build_docker/../contrib/poco/Foundation/src/Exception.cpp:27: Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x2d60e4a0 in /usr/bin/clickhouse\r\n3. /build/build_docker/../src/Common/Exception.cpp:56: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0x173447ee in /usr/bin/clickhouse\r\n4. /build/build_docker/../src/Common/ZooKeeper/IKeeper.cpp:25: Coordination::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, Coordination::Error, int) @ 0x27c7f10f in /usr/bin/clickhouse\r\n5. /build/build_docker/../src/Common/ZooKeeper/IKeeper.cpp:46: Coordination::Exception::Exception(Coordination::Error, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x27c7f6d5 in /usr/bin/clickhouse\r\n6. /build/build_docker/../src/Common/ZooKeeper/ZooKeeper.cpp:409: zkutil::ZooKeeper::tryCreate(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >&) @ 0x27c86d7e in /usr/bin/clickhouse\r\n7. /build/build_docker/../src/Common/ZooKeeper/ZooKeeper.cpp:397: zkutil::ZooKeeper::create(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x27c86c90 in /usr/bin/clickhouse\r\n8. /build/build_docker/../src/Interpreters/TransactionLog.cpp:356: DB::TransactionLog::commitTransaction(std::__1::shared_ptr<DB::MergeTreeTransaction> const&) @ 0x2640e734 in /usr/bin/clickhouse\r\n9. /build/build_docker/../src/Interpreters/MergeTreeTransactionHolder.cpp:56: DB::MergeTreeTransactionHolder::onDestroy() @ 0x2617b5a7 in /usr/bin/clickhouse\r\n10. /build/build_docker/../src/Interpreters/MergeTreeTransactionHolder.cpp:42: DB::MergeTreeTransactionHolder::~MergeTreeTransactionHolder() @ 0x2617b699 in /usr/bin/clickhouse\r\n11. /build/build_docker/../src/Storages/MergeTree/MergePlainMergeTreeTask.h:13: DB::MergePlainMergeTreeTask::~MergePlainMergeTreeTask() @ 0x272e7721 in /usr/bin/clickhouse\r\n12. /build/build_docker/../contrib/libcxx/include/__memory/construct_at.h:57: void std::__1::__destroy_at<DB::MergePlainMergeTreeTask, 0>(DB::MergePlainMergeTreeTask*) @ 0x272d7388 in /usr/bin/clickhouse\r\n13. /build/build_docker/../contrib/libcxx/include/__memory/construct_at.h:82: void std::__1::destroy_at<DB::MergePlainMergeTreeTask, 0>(DB::MergePlainMergeTreeTask*) @ 0x272d7315 in /usr/bin/clickhouse\r\n14. /build/build_docker/../contrib/libcxx/include/__memory/allocator_traits.h:321: void std::__1::allocator_traits<std::__1::allocator<DB::MergePlainMergeTreeTask> >::destroy<DB::MergePlainMergeTreeTask, void, void>(std::__1::allocator<DB::MergePlainMergeTreeTask>&, DB::MergePlainMergeTreeTask*) @ 0x272d72f9 in /usr/bin/clickhouse\r\n15. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:310: std::__1::__shared_ptr_emplace<DB::MergePlainMergeTreeTask, std::__1::allocator<DB::MergePlainMergeTreeTask> >::__on_zero_shared() @ 0x272d710e in /usr/bin/clickhouse\r\n16. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:175: std::__1::__shared_count::__release_shared() @ 0x17338831 in /usr/bin/clickhouse\r\n17. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:216: std::__1::__shared_weak_count::__release_shared() @ 0x173387d9 in /usr/bin/clickhouse\r\n18. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:704: std::__1::shared_ptr<DB::IExecutableTask>::~shared_ptr() @ 0x26e556cc in /usr/bin/clickhouse\r\n19. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:770: std::__1::shared_ptr<DB::IExecutableTask>::reset() @ 0x26f413f3 in /usr/bin/clickhouse\r\n20. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.cpp:199: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::routine(std::__1::shared_ptr<DB::TaskRuntimeData>) @ 0x26f410f9 in /usr/bin/clickhouse\r\n21. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.cpp:229: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::threadFunction() @ 0x26f417e2 in /usr/bin/clickhouse\r\n22. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.h:183: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()::operator()() const @ 0x26f4a078 in /usr/bin/clickhouse\r\n23. /build/build_docker/../contrib/libcxx/include/type_traits:3640: decltype(static_cast<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(fp)()) std::__1::__invoke<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&) @ 0x26f4a035 in /usr/bin/clickhouse\r\n24. /build/build_docker/../contrib/libcxx/include/__functional/invoke.h:62: void std::__1::__invoke_void_return_wrapper<void, true>::__call<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&) @ 0x26f49ffd in /usr/bin/clickhouse\r\n25. /build/build_docker/../contrib/libcxx/include/__functional/function.h:230: std::__1::__function::__default_alloc_func<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'(), void ()>::operator()() @ 0x26f49fd5 in /usr/bin/clickhouse\r\n26. /build/build_docker/../contrib/libcxx/include/__functional/function.h:711: void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'(), void ()> >(std::__1::__function::__policy_storage const*) @ 0x26f49f9d in /usr/bin/clickhouse\r\n27. /build/build_docker/../contrib/libcxx/include/__functional/function.h:843: std::__1::__function::__policy_func<void ()>::operator()() const @ 0x173aa2c6 in /usr/bin/clickhouse\r\n28. /build/build_docker/../contrib/libcxx/include/__functional/function.h:1184: std::__1::function<void ()>::operator()() const @ 0x173a67f5 in /usr/bin/clickhouse\r\n29. /build/build_docker/../src/Common/ThreadPool.cpp:281: ThreadPoolImpl<ThreadFromGlobalPool>::worker(std::__1::__list_iterator<ThreadFromGlobalPool, void*>) @ 0x1745b80f in /usr/bin/clickhouse\r\n30. /build/build_docker/../src/Common/ThreadPool.cpp:143: void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()::operator()() const @ 0x174656e4 in /usr/bin/clickhouse\r\n31. /build/build_docker/../contrib/libcxx/include/type_traits:3648: decltype(static_cast<void>(fp)()) std::__1::__invoke_constexpr<void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()&>(void&&) @ 0x174656b5 in /usr/bin/clickhouse\r\n (version 22.5.1.1)\r\n2022.05.10 16:43:51.764477 [ 765 ] {} <Trace> TransactionLog: Rolling back transaction (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69)\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:33.905172 [ 15371 ] {} <Fatal> BaseDaemon: ########################################\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.166110 [ 15371 ] {} <Fatal> BaseDaemon: (version 22.5.1.1, build id: CE457CD1E3B43B06) (from thread 765) (no query) Received signal Aborted (6)\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.170258 [ 15371 ] {} <Fatal> BaseDaemon: \r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.201226 [ 15371 ] {} <Fatal> BaseDaemon: Stack trace: 0x7fb2d48ae03b 0x7fb2d488d859 0x7fb2d488d729 0x7fb2d489f006 0x26ea6e01 0x2616e6b5 0x2640fd9b 0x2617b659 0x2617b699 0x272e7721 0x272d7388 0x272d7315 0x272d72f9 0x272d710e 0x17338831 0x173387d9 0x26e556cc 0x26f413f3 0x26f410f9 0x26f417e2 0x26f4a078 0x26f4a035 0x26f49ffd 0x26f49fd5 0x26f49f9d 0x173aa2c6 0x173a67f5 0x1745b80f 0x174656e4 0x174656b5 0x17465641 0x17465192 0x17464f36 0x17464e15 0x17464ddd 0x17464db5 0x17464d80 0x173aa2c6 0x173a67f5 0x1745940f 0x1745fe24\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.287812 [ 15371 ] {} <Fatal> BaseDaemon: 4. gsignal @ 0x7fb2d48ae03b in ?\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.312126 [ 15371 ] {} <Fatal> BaseDaemon: 5. abort @ 0x7fb2d488d859 in ?\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.324288 [ 15371 ] {} <Fatal> BaseDaemon: 6. ? @ 0x7fb2d488d729 in ?\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:34.338905 [ 15371 ] {} <Fatal> BaseDaemon: 7. ? @ 0x7fb2d489f006 in ?\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:35.336094 [ 15371 ] {} <Fatal> BaseDaemon: 8. /build/build_docker/../src/Storages/MergeTree/IMergeTreeDataPart.cpp:0: DB::IMergeTreeDataPart::appendRemovalTIDToVersionMetadata(bool) const @ 0x26ea6e01 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:36.125652 [ 15371 ] {} <Fatal> BaseDaemon: 9. /build/build_docker/../src/Interpreters/MergeTreeTransaction.cpp:278: DB::MergeTreeTransaction::rollback() @ 0x2616e6b5 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:36.741204 [ 15371 ] {} <Fatal> BaseDaemon: 10. /build/build_docker/../src/Interpreters/TransactionLog.cpp:396: DB::TransactionLog::rollbackTransaction(std::__1::shared_ptr<DB::MergeTreeTransaction> const&) @ 0x2640fd9b in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:37.101879 [ 15371 ] {} <Fatal> BaseDaemon: 11. /build/build_docker/../src/Interpreters/MergeTreeTransactionHolder.cpp:66: DB::MergeTreeTransactionHolder::onDestroy() @ 0x2617b659 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:37.524433 [ 15371 ] {} <Fatal> BaseDaemon: 12. /build/build_docker/../src/Interpreters/MergeTreeTransactionHolder.cpp:42: DB::MergeTreeTransactionHolder::~MergeTreeTransactionHolder() @ 0x2617b699 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:37.733710 [ 15371 ] {} <Fatal> BaseDaemon: 13. /build/build_docker/../src/Storages/MergeTree/MergePlainMergeTreeTask.h:13: DB::MergePlainMergeTreeTask::~MergePlainMergeTreeTask() @ 0x272e7721 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:40.300674 [ 15371 ] {} <Fatal> BaseDaemon: 14. /build/build_docker/../contrib/libcxx/include/__memory/construct_at.h:57: void std::__1::__destroy_at<DB::MergePlainMergeTreeTask, 0>(DB::MergePlainMergeTreeTask*) @ 0x272d7388 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:42.070072 [ 15371 ] {} <Fatal> BaseDaemon: 15. /build/build_docker/../contrib/libcxx/include/__memory/construct_at.h:82: void std::__1::destroy_at<DB::MergePlainMergeTreeTask, 0>(DB::MergePlainMergeTreeTask*) @ 0x272d7315 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:43.753169 [ 15371 ] {} <Fatal> BaseDaemon: 16. /build/build_docker/../contrib/libcxx/include/__memory/allocator_traits.h:321: void std::__1::allocator_traits<std::__1::allocator<DB::MergePlainMergeTreeTask> >::destroy<DB::MergePlainMergeTreeTask, void, void>(std::__1::allocator<DB::MergePlainMergeTreeTask>&, DB::MergePlainMergeTreeTask*) @ 0x272d72f9 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:47.712647 [ 15371 ] {} <Fatal> BaseDaemon: 17. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:310: std::__1::__shared_ptr_emplace<DB::MergePlainMergeTreeTask, std::__1::allocator<DB::MergePlainMergeTreeTask> >::__on_zero_shared() @ 0x272d710e in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:47.880687 [ 15371 ] {} <Fatal> BaseDaemon: 18. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:175: std::__1::__shared_count::__release_shared() @ 0x17338831 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:47.917788 [ 15371 ] {} <Fatal> BaseDaemon: 19. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:216: std::__1::__shared_weak_count::__release_shared() @ 0x173387d9 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:48.171377 [ 15371 ] {} <Fatal> BaseDaemon: 20. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:704: std::__1::shared_ptr<DB::IExecutableTask>::~shared_ptr() @ 0x26e556cc in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:48.700714 [ 15371 ] {} <Fatal> BaseDaemon: 21. /build/build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:770: std::__1::shared_ptr<DB::IExecutableTask>::reset() @ 0x26f413f3 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:48.906271 [ 15371 ] {} <Fatal> BaseDaemon: 22. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.cpp:199: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::routine(std::__1::shared_ptr<DB::TaskRuntimeData>) @ 0x26f410f9 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:49.209706 [ 15371 ] {} <Fatal> BaseDaemon: 23. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.cpp:229: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::threadFunction() @ 0x26f417e2 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:49.701005 [ 15371 ] {} <Fatal> BaseDaemon: 24. /build/build_docker/../src/Storages/MergeTree/MergeTreeBackgroundExecutor.h:183: DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()::operator()() const @ 0x26f4a078 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:49.940334 [ 15371 ] {} <Fatal> BaseDaemon: 25. /build/build_docker/../contrib/libcxx/include/type_traits:3640: decltype(static_cast<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(fp)()) std::__1::__invoke<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&) @ 0x26f4a035 in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:50.327665 [ 15371 ] {} <Fatal> BaseDaemon: 26. /build/build_docker/../contrib/libcxx/include/__functional/invoke.h:62: void std::__1::__invoke_void_return_wrapper<void, true>::__call<DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&>(DB::MergeTreeBackgroundExecutor<DB::MergeMutateRuntimeQueue>::MergeTreeBackgroundExecutor(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, unsigned long, unsigned long, unsigned long)::'lambda'()&) @ 0x26f49ffd in /usr/bin/clickhouse\r\n/var/log/clickhouse-server/clickhouse-server.err.log:2022.05.10 16:51:51.182942 [ 657 ] {} <Fatal> Application: Child process was terminated by signal 6.\r\n```\nLogical error: TID exists\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/ee0cef35764cc11040f4e49484aaf7ccb6b34a69/stress_test__thread__actions_.html\r\n\r\n```\r\n2022.05.11 18:43:07.102816 [ 29625 ] {97a96732-a382-464b-84e6-a2b7eb3c48aa} <Fatal> : Logical error: 'I's a bug: TID 13371105542879853581 (159, 33, c36968aa-1241-4c3d-acce-a338a37547b6) exists'.\r\n2022.05.11 18:54:00.506766 [ 33365 ] {} <Fatal> BaseDaemon: ########################################\r\n2022.05.11 18:54:00.512030 [ 33365 ] {} <Fatal> BaseDaemon: (version 22.5.1.1 (official build), build id: 0E595FB130E67337) (from thread 29625) (query_id: 97a96732-a382-464b-84e6-a2b7eb3c48aa) (query: BEGIN TRANSACTION) Received signal Aborted (6)\r\n2022.05.11 18:54:00.517724 [ 33365 ] {} <Fatal> BaseDaemon: \r\n2022.05.11 18:54:00.534411 [ 33365 ] {} <Fatal> BaseDaemon: Stack trace: 0x7fa9d14b203b 0x7fa9d1491859 0xae85163 0xaf3a5af 0xaf3a82a 0x19c75350 0x19c72a6b 0x19a203f2 0x19a20189 0x19d590b2 0x19d56862 0x1ab79aa7 0x1ab8a6c8 0x1f836423 0x1f836c93 0x1fa9b536 0x1fa996d0 0x1fa97d48 0xae7f7fd 0x7fa9d1669609 0x7fa9d158e163\r\n2022.05.11 18:54:00.548981 [ 33365 ] {} <Fatal> BaseDaemon: 5. gsignal @ 0x7fa9d14b203b in ?\r\n2022.05.11 18:54:00.561996 [ 33365 ] {} <Fatal> BaseDaemon: 6. abort @ 0x7fa9d1491859 in ?\r\n2022.05.11 18:54:20.564198 [ 638 ] {} <Fatal> Application: Child process was terminated by signal 6.\r\n```\n",
  "hints_text": "```\r\n2022.05.10 16:43:38.230849 [ 765 ] {} <Test> TransactionLog: Committing transaction (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69) state: RUNNING, snapshot: 198, affects 1 tables:\r\n2022.05.10 16:43:51.756993 [ 765 ] {} <Error> void DB::MergeTreeTransactionHolder::onDestroy(): Code: 999. Coordination::Exception: Connection loss, path: /clickhouse/txn/log/csn-. (KEEPER_EXCEPTION), Stack trace (when copying this message, always include the lines below):\r\n2022.05.10 16:43:51.764477 [ 765 ] {} <Trace> TransactionLog: Rolling back transaction (198, 39, 78350abb-a9f7-4c76-b390-089625b0bd69)\r\n\r\n```\n```\r\n2022-05-17 22:27:38 [f5e573b1d559] 2022.05.17 22:27:38.274128 [ 43722 ] {e775d4aa-2215-4d18-82e1-e5237861a5db}  executeQuery: Code: 49. DB::Exception: I's a bug: TID 1898908438987714624 (193, 33, 5b71d7de-245a-4adc-802b-0f58d3c7b894) exists. (LOGICAL_ERROR) (version 22.5.1.1) (from [::1]:33418) (comment: 01174_select_insert_isolation.sh) (in query: BEGIN TRANSACTION), Stack trace (when copying this message, always include the lines below):\r\n2022-05-17 22:27:38 \r\n2022-05-17 22:27:38 0. DB::Exception::Exception(std::__1::basic_string, std::__1::allocator > const&, int, bool) @ 0x94ba38c in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 1. DB::Exception::Exception(int, fmt::v8::basic_format_string::type, fmt::v8::type_identity::type>, unsigned long&&, DB::TransactionID const&) @ 0x125db180 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 2. DB::TransactionLog::beginTransaction() @ 0x125daff8 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 3. DB::InterpreterTransactionControlQuery::executeBegin(std::__1::shared_ptr) @ 0x12401d1c in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 4. DB::InterpreterTransactionControlQuery::execute() @ 0x12401ab4 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 5. ? @ 0x126992a0 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 6. DB::executeQuery(std::__1::basic_string, std::__1::allocator > const&, std::__1::shared_ptr, bool, DB::QueryProcessingStage::Enum) @ 0x12696d5c in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 7. DB::TCPHandler::runImpl() @ 0x13196be8 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 8. DB::TCPHandler::run() @ 0x131a5f44 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 9. Poco::Net::TCPServerConnection::start() @ 0x13d4f600 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 10. Poco::Net::TCPServerDispatcher::run() @ 0x13d51df8 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 11. Poco::PooledThread::run() @ 0x13f4b758 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 12. Poco::ThreadImpl::runnableEntry(void*) @ 0x13f48888 in /usr/bin/clickhouse\r\n2022-05-17 22:27:38 13. start_thread @ 0x751c in /usr/lib/aarch64-linux-gnu/libpthread-2.31.so\r\n2022-05-17 22:27:38 14. ? @ 0xd122c in /usr/lib/aarch64-linux-gnu/libc-2.31.so\r\n```\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/37299/a82239984cbe7dcc14c8c7a3b1aa8678c87d31b3/stateless_tests__aarch64__actions_.html",
  "created_at": "2022-05-20T20:17:45Z"
}