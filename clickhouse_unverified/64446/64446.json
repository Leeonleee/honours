{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64446,
  "instance_id": "ClickHouse__ClickHouse-64446",
  "issue_numbers": [
    "56791"
  ],
  "base_commit": "975e8ee14a16c0ee7c8c558dd40f0fef1ef10a4e",
  "patch": "diff --git a/docs/en/operations/utilities/clickhouse-disks.md b/docs/en/operations/utilities/clickhouse-disks.md\nindex 76db9e41836c..e22bc06b641c 100644\n--- a/docs/en/operations/utilities/clickhouse-disks.md\n+++ b/docs/en/operations/utilities/clickhouse-disks.md\n@@ -4,35 +4,56 @@ sidebar_position: 59\n sidebar_label: clickhouse-disks\n ---\n \n-# clickhouse-disks\n+# Clickhouse-disks\n \n-A utility providing filesystem-like operations for ClickHouse disks.\n+A utility providing filesystem-like operations for ClickHouse disks. It can work in both interactive and not interactive modes.\n \n-Program-wide options:\n+## Program-wide options\n \n * `--config-file, -C` -- path to ClickHouse config, defaults to `/etc/clickhouse-server/config.xml`.\n * `--save-logs` -- Log progress of invoked commands to `/var/log/clickhouse-server/clickhouse-disks.log`.\n * `--log-level` -- What [type](../server-configuration-parameters/settings#server_configuration_parameters-logger) of events to log, defaults to `none`.\n * `--disk` -- what disk to use for `mkdir, move, read, write, remove` commands. Defaults to `default`.\n+* `--query, -q` -- single query that can be executed without launching interactive mode\n+* `--help, -h` -- print all the options and commands with description\n+\n+## Default Disks\n+After the launch two disks are initialized. The first one is a disk `local` that is supposed to imitate local file system from which clickhouse-disks utility was launched. The second one is a disk `default` that is mounted to the local filesystem in the directory that can be found in config as a parameter `clickhouse/path` (default value is `/var/lib/clickhouse`).\n+\n+## Clickhouse-disks state\n+For each disk that was added the utility stores current directory (as in a usual filesystem). User can change current directory and switch between disks.\n+\n+State is reflected in a prompt \"`disk_name`:`path_name`\" \n \n ## Commands\n \n-* `copy [--disk-from d1] [--disk-to d2] <FROM_PATH> <TO_PATH>`.\n-  Recursively copy data from `FROM_PATH` at disk `d1` (defaults to `disk` value if not provided)\n-  to `TO_PATH` at disk `d2` (defaults to `disk` value if not provided).\n-* `move <FROM_PATH> <TO_PATH>`.\n-  Move file or directory from `FROM_PATH` to `TO_PATH`.\n-* `remove <PATH>`.\n-  Remove `PATH` recursively.\n-* `link <FROM_PATH> <TO_PATH>`.\n-  Create a hardlink from `FROM_PATH` to `TO_PATH`.\n-* `list [--recursive] <PATH>...`\n-  List files at `PATH`s. Non-recursive by default.\n-* `list-disks`.\n+In these documentation file all mandatory positional arguments are referred as `<parameter>`, named arguments are referred as `[--parameter value]`. All positional parameters could be mentioned as a named parameter with a corresponding name.\n+\n+* `cd (change-dir, change_dir) [--disk disk] <path>`\n+  Change directory to path `path` on disk `disk` (default value is a current disk). No disk switching happens.\n+* `copy (cp) [--disk-from disk_1] [--disk-to disk_2] <path-from> <path-to>`.\n+  Recursively copy data from `path-from` at disk `disk_1` (default value is a current disk (parameter `disk` in a non-interactive mode))\n+  to `path-to` at disk `disk_2` (default value is a current disk (parameter `disk` in a non-interactive mode)).\n+* `current_disk_with_path (current, current_disk, current_path)`\n+  Print current state in format: \n+    `Disk: \"current_disk\" Path: \"current path on current disk\"`\n+* `help [<command>]`\n+  Print help message about command `command`. If `command` is not specified print information about all commands.\n+* `move (mv) <path-from> <path-to>`.\n+  Move file or directory from `path-from` to `path-to` within current disk.\n+* `remove (rm, delete) <path>`.\n+  Remove `path` recursively on a current disk.\n+* `link (ln) <path-from> <path-to>`.\n+  Create a hardlink from `path-from` to `path-to` on a current disk.\n+* `list (ls) [--recursive] <path>`\n+  List files at `path`s on a current disk. Non-recursive by default.\n+* `list-disks (list_disks, ls-disks, ls_disks)`.\n   List disks names.\n-* `mkdir [--recursive] <PATH>`.\n+* `mkdir [--recursive] <path>` on a current disk.\n   Create a directory. Non-recursive by default.\n-* `read: <FROM_PATH> [<TO_PATH>]`\n-  Read a file from `FROM_PATH` to `TO_PATH` (`stdout` if not supplied).\n-* `write [FROM_PATH] <TO_PATH>`.\n-  Write a file from `FROM_PATH` (`stdin` if not supplied) to `TO_PATH`.\n+* `read (r) <path-from> [--path-to path]`\n+  Read a file from `path-from` to `path` (`stdout` if not supplied).\n+* `switch-disk [--path path] <disk>`\n+  Switch to disk `disk` on path `path` (if `path` is not specified default value is a previous path on disk `disk`). \n+* `write (w) [--path-from path] <path-to>`.\n+  Write a file from `path` (`stdin` if `path` is not supplied, input must finish by Ctrl+D) to `path-to`.\ndiff --git a/programs/disks/CMakeLists.txt b/programs/disks/CMakeLists.txt\nindex f0949fcfcebc..7e8afe084fba 100644\n--- a/programs/disks/CMakeLists.txt\n+++ b/programs/disks/CMakeLists.txt\n@@ -1,6 +1,8 @@\n set (CLICKHOUSE_DISKS_SOURCES\n     DisksApp.cpp\n+    DisksClient.cpp\n     ICommand.cpp\n+    CommandChangeDirectory.cpp\n     CommandCopy.cpp\n     CommandLink.cpp\n     CommandList.cpp\n@@ -9,10 +11,14 @@ set (CLICKHOUSE_DISKS_SOURCES\n     CommandMove.cpp\n     CommandRead.cpp\n     CommandRemove.cpp\n-    CommandWrite.cpp)\n+    CommandSwitchDisk.cpp\n+    CommandWrite.cpp\n+    CommandHelp.cpp\n+    CommandTouch.cpp\n+    CommandGetCurrentDiskAndPath.cpp)\n \n if (CLICKHOUSE_CLOUD)\n-    set (CLICKHOUSE_DISKS_SOURCES ${CLICKHOUSE_DISKS_SOURCES} CommandPackedIO.cpp)\n+  set (CLICKHOUSE_DISKS_SOURCES ${CLICKHOUSE_DISKS_SOURCES} CommandPackedIO.cpp)\n endif ()\n \n set (CLICKHOUSE_DISKS_LINK\ndiff --git a/programs/disks/CommandChangeDirectory.cpp b/programs/disks/CommandChangeDirectory.cpp\nnew file mode 100644\nindex 000000000000..b545f37de72f\n--- /dev/null\n+++ b/programs/disks/CommandChangeDirectory.cpp\n@@ -0,0 +1,35 @@\n+#include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+#include \"DisksApp.h\"\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n+\n+namespace DB\n+{\n+\n+class CommandChangeDirectory final : public ICommand\n+{\n+public:\n+    explicit CommandChangeDirectory() : ICommand()\n+    {\n+        command_name = \"cd\";\n+        description = \"Change directory (makes sense only in interactive mode)\";\n+        options_description.add_options()(\"path\", po::value<String>(), \"the path to which we want to change (mandatory, positional)\")(\n+            \"disk\", po::value<String>(), \"A disk where the path is changed (without disk switching)\");\n+        positional_options_description.add(\"path\", 1);\n+    }\n+\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n+    {\n+        DiskWithPath & disk = getDiskWithPath(client, options, \"disk\");\n+        String path = getValueFromCommandLineOptionsThrow<String>(options, \"path\");\n+        disk.setPath(path);\n+    }\n+};\n+\n+CommandPtr makeCommandChangeDirectory()\n+{\n+    return std::make_shared<DB::CommandChangeDirectory>();\n+}\n+\n+}\ndiff --git a/programs/disks/CommandCopy.cpp b/programs/disks/CommandCopy.cpp\nindex f176fa277d78..e3051f2702c6 100644\n--- a/programs/disks/CommandCopy.cpp\n+++ b/programs/disks/CommandCopy.cpp\n@@ -1,6 +1,8 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n+#include \"Common/Exception.h\"\n #include <Common/TerminalSize.h>\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n \n namespace DB\n {\n@@ -10,59 +12,89 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+\n class CommandCopy final : public ICommand\n {\n public:\n-    CommandCopy()\n+    explicit CommandCopy() : ICommand()\n     {\n         command_name = \"copy\";\n-        command_option_description.emplace(createOptionsDescription(\"Allowed options\", getTerminalWidth()));\n-        description = \"Recursively copy data from `FROM_PATH` to `TO_PATH`\";\n-        usage = \"copy [OPTION]... <FROM_PATH> <TO_PATH>\";\n-        command_option_description->add_options()\n-            (\"disk-from\", po::value<String>(), \"disk from which we copy\")\n-            (\"disk-to\", po::value<String>(), \"disk to which we copy\");\n+        description = \"Recursively copy data from `path-from` to `path-to`\";\n+        options_description.add_options()(\n+            \"disk-from\", po::value<String>(), \"disk from which we copy is executed (default value is a current disk)\")(\n+            \"disk-to\", po::value<String>(), \"disk to which copy is executed (default value is a current disk)\")(\n+            \"path-from\", po::value<String>(), \"path from which copy is executed (mandatory, positional)\")(\n+            \"path-to\", po::value<String>(), \"path to which copy is executed (mandatory, positional)\")(\n+            \"recursive,r\", \"recursively copy the directory (required to remove a directory)\");\n+        positional_options_description.add(\"path-from\", 1);\n+        positional_options_description.add(\"path-to\", 1);\n     }\n \n-    void processOptions(\n-        Poco::Util::LayeredConfiguration & config,\n-        po::variables_map & options) const override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (options.count(\"disk-from\"))\n-            config.setString(\"disk-from\", options[\"disk-from\"].as<String>());\n-        if (options.count(\"disk-to\"))\n-            config.setString(\"disk-to\", options[\"disk-to\"].as<String>());\n-    }\n+        auto disk_from = getDiskWithPath(client, options, \"disk-from\");\n+        auto disk_to = getDiskWithPath(client, options, \"disk-to\");\n+        String path_from = disk_from.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-from\"));\n+        String path_to = disk_to.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-to\"));\n+        bool recursive = options.count(\"recursive\");\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n-    {\n-        if (command_arguments.size() != 2)\n+        if (!disk_from.getDisk()->exists(path_from))\n         {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"cannot stat '{}' on disk '{}': No such file or directory\",\n+                path_from,\n+                disk_from.getDisk()->getName());\n         }\n+        else if (disk_from.getDisk()->isFile(path_from))\n+        {\n+            auto target_location = getTargetLocation(path_from, disk_to, path_to);\n+            if (!disk_to.getDisk()->exists(target_location) || disk_to.getDisk()->isFile(target_location))\n+            {\n+                disk_from.getDisk()->copyFile(\n+                    path_from,\n+                    *disk_to.getDisk(),\n+                    target_location,\n+                    /* read_settings= */ {},\n+                    /* write_settings= */ {},\n+                    /* cancellation_hook= */ {});\n+            }\n+            else\n+            {\n+                throw Exception(\n+                    ErrorCodes::BAD_ARGUMENTS, \"cannot overwrite directory {} with non-directory {}\", target_location, path_from);\n+            }\n+        }\n+        else if (disk_from.getDisk()->isDirectory(path_from))\n+        {\n+            if (!recursive)\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"--recursive not specified; omitting directory {}\", path_from);\n+            }\n+            auto target_location = getTargetLocation(path_from, disk_to, path_to);\n \n-        String disk_name_from = config.getString(\"disk-from\", config.getString(\"disk\", \"default\"));\n-        String disk_name_to = config.getString(\"disk-to\", config.getString(\"disk\", \"default\"));\n-\n-        const String & path_from = command_arguments[0];\n-        const String & path_to =  command_arguments[1];\n-\n-        DiskPtr disk_from = disk_selector->get(disk_name_from);\n-        DiskPtr disk_to = disk_selector->get(disk_name_to);\n-\n-        String relative_path_from = validatePathAndGetAsRelative(path_from);\n-        String relative_path_to = validatePathAndGetAsRelative(path_to);\n-\n-        disk_from->copyDirectoryContent(relative_path_from, disk_to, relative_path_to, /* read_settings= */ {}, /* write_settings= */ {}, /* cancellation_hook= */ {});\n+            if (disk_to.getDisk()->isFile(target_location))\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"cannot overwrite non-directory {} with directory {}\", path_to, target_location);\n+            }\n+            else if (!disk_to.getDisk()->exists(target_location))\n+            {\n+                disk_to.getDisk()->createDirectory(target_location);\n+            }\n+            disk_from.getDisk()->copyDirectoryContent(\n+                path_from,\n+                disk_to.getDisk(),\n+                target_location,\n+                /* read_settings= */ {},\n+                /* write_settings= */ {},\n+                /* cancellation_hook= */ {});\n+        }\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandCopy()\n+CommandPtr makeCommandCopy()\n {\n-    return std::make_unique<DB::CommandCopy>();\n+    return std::make_shared<DB::CommandCopy>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandGetCurrentDiskAndPath.cpp b/programs/disks/CommandGetCurrentDiskAndPath.cpp\nnew file mode 100644\nindex 000000000000..15f8ef5aae8a\n--- /dev/null\n+++ b/programs/disks/CommandGetCurrentDiskAndPath.cpp\n@@ -0,0 +1,30 @@\n+#include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+#include \"DisksApp.h\"\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n+\n+namespace DB\n+{\n+\n+class CommandGetCurrentDiskAndPath final : public ICommand\n+{\n+public:\n+    explicit CommandGetCurrentDiskAndPath() : ICommand()\n+    {\n+        command_name = \"current_disk_with_path\";\n+        description = \"Prints current disk and path (which coincide with the prompt)\";\n+    }\n+\n+    void executeImpl(const CommandLineOptions &, DisksClient & client) override\n+    {\n+        auto disk = client.getCurrentDiskWithPath();\n+        std::cout << \"Disk: \" << disk.getDisk()->getName() << \"\\nPath: \" << disk.getCurrentPath() << std::endl;\n+    }\n+};\n+\n+CommandPtr makeCommandGetCurrentDiskAndPath()\n+{\n+    return std::make_shared<DB::CommandGetCurrentDiskAndPath>();\n+}\n+}\ndiff --git a/programs/disks/CommandHelp.cpp b/programs/disks/CommandHelp.cpp\nnew file mode 100644\nindex 000000000000..a3aee9498d30\n--- /dev/null\n+++ b/programs/disks/CommandHelp.cpp\n@@ -0,0 +1,43 @@\n+#include \"DisksApp.h\"\n+#include \"ICommand.h\"\n+\n+#include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+\n+namespace DB\n+{\n+\n+class CommandHelp final : public ICommand\n+{\n+public:\n+    explicit CommandHelp(const DisksApp & disks_app_) : disks_app(disks_app_)\n+    {\n+        command_name = \"help\";\n+        description = \"Print help message about available commands\";\n+        options_description.add_options()(\n+            \"command\", po::value<String>(), \"A command to help with (optional, positional), if not specified, help lists all the commands\");\n+        positional_options_description.add(\"command\", 1);\n+    }\n+\n+    void executeImpl(const CommandLineOptions & options, DisksClient & /*client*/) override\n+    {\n+        std::optional<String> command = getValueFromCommandLineOptionsWithOptional<String>(options, \"command\");\n+        if (command.has_value())\n+        {\n+            disks_app.printCommandHelpMessage(command.value());\n+        }\n+        else\n+        {\n+            disks_app.printAvailableCommandsHelpMessage();\n+        }\n+    }\n+\n+    const DisksApp & disks_app;\n+};\n+\n+CommandPtr makeCommandHelp(const DisksApp & disks_app)\n+{\n+    return std::make_shared<DB::CommandHelp>(disks_app);\n+}\n+\n+}\ndiff --git a/programs/disks/CommandLink.cpp b/programs/disks/CommandLink.cpp\nindex dbaa3162f82c..11c196cafc5d 100644\n--- a/programs/disks/CommandLink.cpp\n+++ b/programs/disks/CommandLink.cpp\n@@ -1,14 +1,9 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n+#include \"ICommand.h\"\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandLink final : public ICommand\n {\n public:\n@@ -16,42 +11,27 @@ class CommandLink final : public ICommand\n     {\n         command_name = \"link\";\n         description = \"Create hardlink from `from_path` to `to_path`\";\n-        usage = \"link [OPTION]... <FROM_PATH> <TO_PATH>\";\n-    }\n-\n-    void processOptions(\n-        Poco::Util::LayeredConfiguration &,\n-        po::variables_map &) const override\n-    {\n+        options_description.add_options()(\n+            \"path-from\", po::value<String>(), \"the path from which a hard link will be created (mandatory, positional)\")(\n+            \"path-to\", po::value<String>(), \"the path where a hard link will be created (mandatory, positional)\");\n+        positional_options_description.add(\"path-from\", 1);\n+        positional_options_description.add(\"path-to\", 1);\n     }\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 2)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        const String & path_from = command_arguments[0];\n-        const String & path_to = command_arguments[1];\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n+        auto disk = client.getCurrentDiskWithPath();\n \n-        String relative_path_from = validatePathAndGetAsRelative(path_from);\n-        String relative_path_to = validatePathAndGetAsRelative(path_to);\n+        const String & path_from = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-from\"));\n+        const String & path_to = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-to\"));\n \n-        disk->createHardLink(relative_path_from, relative_path_to);\n+        disk.getDisk()->createHardLink(path_from, path_to);\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandLink()\n+CommandPtr makeCommandLink()\n {\n-    return std::make_unique<DB::CommandLink>();\n+    return std::make_shared<DB::CommandLink>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandList.cpp b/programs/disks/CommandList.cpp\nindex 7213802ea865..77479b1d217b 100644\n--- a/programs/disks/CommandList.cpp\n+++ b/programs/disks/CommandList.cpp\n@@ -1,98 +1,95 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n #include <Common/TerminalSize.h>\n+#include \"DisksApp.h\"\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandList final : public ICommand\n {\n public:\n-    CommandList()\n+    explicit CommandList() : ICommand()\n     {\n         command_name = \"list\";\n-        command_option_description.emplace(createOptionsDescription(\"Allowed options\", getTerminalWidth()));\n         description = \"List files at path[s]\";\n-        usage = \"list [OPTION]... <PATH>...\";\n-        command_option_description->add_options()\n-            (\"recursive\", \"recursively list all directories\");\n-    }\n-\n-    void processOptions(\n-        Poco::Util::LayeredConfiguration & config,\n-        po::variables_map & options) const override\n-    {\n-        if (options.count(\"recursive\"))\n-            config.setBool(\"recursive\", true);\n+        options_description.add_options()(\"recursive\", \"recursively list the directory\")(\"all\", \"show hidden files\")(\n+            \"path\", po::value<String>(), \"the path of listing (mandatory, positional)\");\n+        positional_options_description.add(\"path\", 1);\n     }\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 1)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        const String & path =  command_arguments[0];\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n-\n-        String relative_path = validatePathAndGetAsRelative(path);\n-\n-        bool recursive = config.getBool(\"recursive\", false);\n+        bool recursive = options.count(\"recursive\");\n+        bool show_hidden = options.count(\"all\");\n+        auto disk = client.getCurrentDiskWithPath();\n+        String path = getValueFromCommandLineOptionsWithDefault<String>(options, \"path\", \".\");\n \n         if (recursive)\n-            listRecursive(disk, relative_path);\n+            listRecursive(disk, path, show_hidden);\n         else\n-            list(disk, relative_path);\n+            list(disk, path, show_hidden);\n     }\n \n private:\n-    static void list(const DiskPtr & disk, const std::string & relative_path)\n+    static void list(const DiskWithPath & disk, const std::string & path, bool show_hidden)\n     {\n-        std::vector<String> file_names;\n-        disk->listFiles(relative_path, file_names);\n+        std::vector<String> file_names = disk.listAllFilesByPath(path);\n+        std::vector<String> selected_and_sorted_file_names{};\n \n         for (const auto & file_name : file_names)\n-            std::cout << file_name << '\\n';\n+            if (show_hidden || (!file_name.starts_with('.')))\n+                selected_and_sorted_file_names.push_back(file_name);\n+\n+        std::sort(selected_and_sorted_file_names.begin(), selected_and_sorted_file_names.end());\n+        for (const auto & file_name : selected_and_sorted_file_names)\n+        {\n+            std::cout << file_name << \"\\n\";\n+        }\n     }\n \n-    static void listRecursive(const DiskPtr & disk, const std::string & relative_path)\n+    static void listRecursive(const DiskWithPath & disk, const std::string & relative_path, bool show_hidden)\n     {\n-        std::vector<String> file_names;\n-        disk->listFiles(relative_path, file_names);\n+        std::vector<String> file_names = disk.listAllFilesByPath(relative_path);\n+        std::vector<String> selected_and_sorted_file_names{};\n \n         std::cout << relative_path << \":\\n\";\n \n-        if (!file_names.empty())\n+        for (const auto & file_name : file_names)\n+            if (show_hidden || (!file_name.starts_with('.')))\n+                selected_and_sorted_file_names.push_back(file_name);\n+\n+        std::sort(selected_and_sorted_file_names.begin(), selected_and_sorted_file_names.end());\n+        for (const auto & file_name : selected_and_sorted_file_names)\n         {\n-            for (const auto & file_name : file_names)\n-                std::cout << file_name << '\\n';\n-            std::cout << \"\\n\";\n+            std::cout << file_name << \"\\n\";\n         }\n+        std::cout << \"\\n\";\n \n-        for (const auto & file_name : file_names)\n+        for (const auto & file_name : selected_and_sorted_file_names)\n         {\n-            auto path = relative_path.empty() ? file_name : (relative_path + \"/\" + file_name);\n-            if (disk->isDirectory(path))\n-                listRecursive(disk, path);\n+            auto path = [&]() -> String\n+            {\n+                if (relative_path.ends_with(\"/\"))\n+                {\n+                    return relative_path + file_name;\n+                }\n+                else\n+                {\n+                    return relative_path + \"/\" + file_name;\n+                }\n+            }();\n+            if (disk.isDirectory(path))\n+            {\n+                listRecursive(disk, path, show_hidden);\n+            }\n         }\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandList()\n+CommandPtr makeCommandList()\n {\n-    return std::make_unique<DB::CommandList>();\n+    return std::make_shared<DB::CommandList>();\n+}\n }\ndiff --git a/programs/disks/CommandListDisks.cpp b/programs/disks/CommandListDisks.cpp\nindex 79da021fd000..9fb67fed5e03 100644\n--- a/programs/disks/CommandListDisks.cpp\n+++ b/programs/disks/CommandListDisks.cpp\n@@ -1,68 +1,40 @@\n-#include \"ICommand.h\"\n+#include <algorithm>\n #include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandListDisks final : public ICommand\n {\n public:\n-    CommandListDisks()\n+    explicit CommandListDisks() : ICommand()\n     {\n         command_name = \"list-disks\";\n-        description = \"List disks names\";\n-        usage = \"list-disks [OPTION]\";\n+        description = \"Lists all available disks\";\n     }\n \n-    void processOptions(\n-        Poco::Util::LayeredConfiguration &,\n-        po::variables_map &) const override\n-    {}\n-\n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> &,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions &, DisksClient & client) override\n     {\n-        if (!command_arguments.empty())\n+        std::vector<String> sorted_and_selected{};\n+        for (const auto & disk_name : client.getAllDiskNames())\n         {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n+            sorted_and_selected.push_back(disk_name + \":\" + client.getDiskWithPath(disk_name).getAbsolutePath(\"\"));\n         }\n-\n-        constexpr auto config_prefix = \"storage_configuration.disks\";\n-        constexpr auto default_disk_name = \"default\";\n-\n-        Poco::Util::AbstractConfiguration::Keys keys;\n-        config.keys(config_prefix, keys);\n-\n-        bool has_default_disk = false;\n-\n-        /// For the output to be ordered\n-        std::set<String> disks;\n-\n-        for (const auto & disk_name : keys)\n+        std::sort(sorted_and_selected.begin(), sorted_and_selected.end());\n+        for (const auto & disk_name : sorted_and_selected)\n         {\n-            if (disk_name == default_disk_name)\n-                has_default_disk = true;\n-            disks.insert(disk_name);\n+            std::cout << disk_name << \"\\n\";\n         }\n-\n-        if (!has_default_disk)\n-            disks.insert(default_disk_name);\n-\n-        for (const auto & disk : disks)\n-            std::cout << disk << '\\n';\n     }\n+\n+private:\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandListDisks()\n+CommandPtr makeCommandListDisks()\n {\n-    return std::make_unique<DB::CommandListDisks>();\n+    return std::make_shared<DB::CommandListDisks>();\n+}\n }\ndiff --git a/programs/disks/CommandMkDir.cpp b/programs/disks/CommandMkDir.cpp\nindex 6d33bdec4986..c6222f326d49 100644\n--- a/programs/disks/CommandMkDir.cpp\n+++ b/programs/disks/CommandMkDir.cpp\n@@ -6,61 +6,35 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandMkDir final : public ICommand\n {\n public:\n     CommandMkDir()\n     {\n         command_name = \"mkdir\";\n-        command_option_description.emplace(createOptionsDescription(\"Allowed options\", getTerminalWidth()));\n-        description = \"Create a directory\";\n-        usage = \"mkdir [OPTION]... <PATH>\";\n-        command_option_description->add_options()\n-            (\"recursive\", \"recursively create directories\");\n-    }\n-\n-    void processOptions(\n-        Poco::Util::LayeredConfiguration & config,\n-        po::variables_map & options) const override\n-    {\n-        if (options.count(\"recursive\"))\n-            config.setBool(\"recursive\", true);\n+        description = \"Creates a directory\";\n+        options_description.add_options()(\"parents\", \"recursively create directories\")(\n+            \"path\", po::value<String>(), \"the path on which directory should be created (mandatory, positional)\");\n+        positional_options_description.add(\"path\", 1);\n     }\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 1)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n+        bool recursive = options.count(\"parents\");\n+        auto disk = client.getCurrentDiskWithPath();\n \n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        const String & path = command_arguments[0];\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n-\n-        String relative_path = validatePathAndGetAsRelative(path);\n-        bool recursive = config.getBool(\"recursive\", false);\n+        String path = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path\"));\n \n         if (recursive)\n-            disk->createDirectories(relative_path);\n+            disk.getDisk()->createDirectories(path);\n         else\n-            disk->createDirectory(relative_path);\n+            disk.getDisk()->createDirectory(path);\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandMkDir()\n+CommandPtr makeCommandMkDir()\n {\n-    return std::make_unique<DB::CommandMkDir>();\n+    return std::make_shared<DB::CommandMkDir>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandMove.cpp b/programs/disks/CommandMove.cpp\nindex 75cf96252ed5..e3d485032e03 100644\n--- a/programs/disks/CommandMove.cpp\n+++ b/programs/disks/CommandMove.cpp\n@@ -1,5 +1,5 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n+#include \"ICommand.h\"\n \n namespace DB\n {\n@@ -9,6 +9,7 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+\n class CommandMove final : public ICommand\n {\n public:\n@@ -16,44 +17,62 @@ class CommandMove final : public ICommand\n     {\n         command_name = \"move\";\n         description = \"Move file or directory from `from_path` to `to_path`\";\n-        usage = \"move [OPTION]... <FROM_PATH> <TO_PATH>\";\n+        options_description.add_options()(\"path-from\", po::value<String>(), \"path from which we copy (mandatory, positional)\")(\n+            \"path-to\", po::value<String>(), \"path to which we copy (mandatory, positional)\");\n+        positional_options_description.add(\"path-from\", 1);\n+        positional_options_description.add(\"path-to\", 1);\n     }\n \n-    void processOptions(\n-        Poco::Util::LayeredConfiguration &,\n-        po::variables_map &) const override\n-    {}\n-\n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 2)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        const String & path_from = command_arguments[0];\n-        const String & path_to = command_arguments[1];\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n+        auto disk = client.getCurrentDiskWithPath();\n \n-        String relative_path_from = validatePathAndGetAsRelative(path_from);\n-        String relative_path_to = validatePathAndGetAsRelative(path_to);\n+        String path_from = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-from\"));\n+        String path_to = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-to\"));\n \n-        if (disk->isFile(relative_path_from))\n-            disk->moveFile(relative_path_from, relative_path_to);\n-        else\n-            disk->moveDirectory(relative_path_from, relative_path_to);\n+        if (disk.getDisk()->isFile(path_from))\n+        {\n+            disk.getDisk()->moveFile(path_from, path_to);\n+        }\n+        else if (disk.getDisk()->isDirectory(path_from))\n+        {\n+            auto target_location = getTargetLocation(path_from, disk, path_to);\n+            if (!disk.getDisk()->exists(target_location))\n+            {\n+                disk.getDisk()->createDirectory(target_location);\n+                disk.getDisk()->moveDirectory(path_from, target_location);\n+            }\n+            else\n+            {\n+                if (disk.getDisk()->isFile(target_location))\n+                {\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS, \"cannot overwrite non-directory '{}' with directory '{}'\", target_location, path_from);\n+                }\n+                if (!disk.getDisk()->isDirectoryEmpty(target_location))\n+                {\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"cannot move '{}' to '{}': Directory not empty\", path_from, target_location);\n+                }\n+                else\n+                {\n+                    disk.getDisk()->moveDirectory(path_from, target_location);\n+                }\n+            }\n+        }\n+        else if (!disk.getDisk()->exists(path_from))\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"cannot stat '{}' on disk: '{}': No such file or directory\",\n+                path_from,\n+                disk.getDisk()->getName());\n+        }\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandMove()\n+CommandPtr makeCommandMove()\n {\n-    return std::make_unique<DB::CommandMove>();\n+    return std::make_shared<DB::CommandMove>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandRead.cpp b/programs/disks/CommandRead.cpp\nindex 0f3ac7ab98c8..277e735f5074 100644\n--- a/programs/disks/CommandRead.cpp\n+++ b/programs/disks/CommandRead.cpp\n@@ -1,78 +1,52 @@\n-#include \"ICommand.h\"\n-#include <Interpreters/Context.h>\n #include <IO/ReadBufferFromFile.h>\n #include <IO/WriteBufferFromFile.h>\n #include <IO/copyData.h>\n+#include <Interpreters/Context.h>\n #include <Common/TerminalSize.h>\n+#include \"ICommand.h\"\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandRead final : public ICommand\n {\n public:\n     CommandRead()\n     {\n         command_name = \"read\";\n-        command_option_description.emplace(createOptionsDescription(\"Allowed options\", getTerminalWidth()));\n-        description = \"Read a file from `FROM_PATH` to `TO_PATH`\";\n-        usage = \"read [OPTION]... <FROM_PATH> [<TO_PATH>]\";\n-        command_option_description->add_options()\n-            (\"output\", po::value<String>(), \"file to which we are reading, defaults to `stdout`\");\n-    }\n-\n-    void processOptions(\n-        Poco::Util::LayeredConfiguration & config,\n-        po::variables_map & options) const override\n-    {\n-        if (options.count(\"output\"))\n-            config.setString(\"output\", options[\"output\"].as<String>());\n+        description = \"Read a file from `path-from` to `path-to`\";\n+        options_description.add_options()(\"path-from\", po::value<String>(), \"file from which we are reading (mandatory, positional)\")(\n+            \"path-to\", po::value<String>(), \"file to which we are writing, defaults to `stdout`\");\n+        positional_options_description.add(\"path-from\", 1);\n     }\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-       std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 1)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n-\n-        String relative_path = validatePathAndGetAsRelative(command_arguments[0]);\n+        auto disk = client.getCurrentDiskWithPath();\n+        String path_from = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-from\"));\n+        std::optional<String> path_to = getValueFromCommandLineOptionsWithOptional<String>(options, \"path-to\");\n \n-        String path_output = config.getString(\"output\", \"\");\n-\n-        if (!path_output.empty())\n+        auto in = disk.getDisk()->readFile(path_from);\n+        std::unique_ptr<WriteBufferFromFileBase> out = {};\n+        if (path_to.has_value())\n         {\n-            String relative_path_output = validatePathAndGetAsRelative(path_output);\n-\n-            auto in = disk->readFile(relative_path);\n-            auto out = disk->writeFile(relative_path_output);\n+            String relative_path_to = disk.getRelativeFromRoot(path_to.value());\n+            out = disk.getDisk()->writeFile(relative_path_to);\n             copyData(*in, *out);\n-            out->finalize();\n         }\n         else\n         {\n-            auto in = disk->readFile(relative_path);\n-            std::unique_ptr<WriteBufferFromFileBase> out = std::make_unique<WriteBufferFromFileDescriptor>(STDOUT_FILENO);\n+            out = std::make_unique<WriteBufferFromFileDescriptor>(STDOUT_FILENO);\n             copyData(*in, *out);\n+            out->write('\\n');\n         }\n+        out->finalize();\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandRead()\n+CommandPtr makeCommandRead()\n {\n-    return std::make_unique<DB::CommandRead>();\n+    return std::make_shared<DB::CommandRead>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandRemove.cpp b/programs/disks/CommandRemove.cpp\nindex 0c631eacff3c..4388f6c0b14e 100644\n--- a/programs/disks/CommandRemove.cpp\n+++ b/programs/disks/CommandRemove.cpp\n@@ -1,5 +1,6 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n+#include \"Common/Exception.h\"\n+#include \"ICommand.h\"\n \n namespace DB\n {\n@@ -9,46 +10,49 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+\n class CommandRemove final : public ICommand\n {\n public:\n     CommandRemove()\n     {\n         command_name = \"remove\";\n-        description = \"Remove file or directory with all children. Throws exception if file doesn't exists.\\nPath should be in format './' or './path' or 'path'\";\n-        usage = \"remove [OPTION]... <PATH>\";\n+        description = \"Remove file or directory. Throws exception if file doesn't exists\";\n+        options_description.add_options()(\"path\", po::value<String>(), \"path that is going to be deleted (mandatory, positional)\")(\n+            \"recursive,r\", \"recursively removes the directory (required to remove a directory)\");\n+        positional_options_description.add(\"path\", 1);\n     }\n \n-    void processOptions(\n-        Poco::Util::LayeredConfiguration &,\n-        po::variables_map &) const override\n-    {}\n-\n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 1)\n+        auto disk = client.getCurrentDiskWithPath();\n+        const String & path = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path\"));\n+        bool recursive = options.count(\"recursive\");\n+        if (!disk.getDisk()->exists(path))\n         {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Path {} on disk {} doesn't exist\", path, disk.getDisk()->getName());\n+        }\n+        else if (disk.getDisk()->isDirectory(path))\n+        {\n+            if (!recursive)\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"cannot remove '{}': Is a directory\", path);\n+            }\n+            else\n+            {\n+                disk.getDisk()->removeRecursive(path);\n+            }\n+        }\n+        else\n+        {\n+            disk.getDisk()->removeFileIfExists(path);\n         }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n-\n-        const String & path = command_arguments[0];\n-\n-        DiskPtr disk = disk_selector->get(disk_name);\n-\n-        String relative_path = validatePathAndGetAsRelative(path);\n-\n-        disk->removeRecursive(relative_path);\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandRemove()\n+CommandPtr makeCommandRemove()\n {\n-    return std::make_unique<DB::CommandRemove>();\n+    return std::make_shared<DB::CommandRemove>();\n+}\n+\n }\ndiff --git a/programs/disks/CommandSwitchDisk.cpp b/programs/disks/CommandSwitchDisk.cpp\nnew file mode 100644\nindex 000000000000..fa02d991365e\n--- /dev/null\n+++ b/programs/disks/CommandSwitchDisk.cpp\n@@ -0,0 +1,35 @@\n+#include <optional>\n+#include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+#include \"DisksApp.h\"\n+#include \"ICommand.h\"\n+\n+namespace DB\n+{\n+\n+class CommandSwitchDisk final : public ICommand\n+{\n+public:\n+    explicit CommandSwitchDisk() : ICommand()\n+    {\n+        command_name = \"switch-disk\";\n+        description = \"Switch disk (makes sense only in interactive mode)\";\n+        options_description.add_options()(\"disk\", po::value<String>(), \"the disk to switch to (mandatory, positional)\")(\n+            \"path\", po::value<String>(), \"the path to switch on the disk\");\n+        positional_options_description.add(\"disk\", 1);\n+    }\n+\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n+    {\n+        String disk = getValueFromCommandLineOptions<String>(options, \"disk\");\n+        std::optional<String> path = getValueFromCommandLineOptionsWithOptional<String>(options, \"path\");\n+\n+        client.switchToDisk(disk, path);\n+    }\n+};\n+\n+CommandPtr makeCommandSwitchDisk()\n+{\n+    return std::make_shared<DB::CommandSwitchDisk>();\n+}\n+}\ndiff --git a/programs/disks/CommandTouch.cpp b/programs/disks/CommandTouch.cpp\nnew file mode 100644\nindex 000000000000..c0bdb64cf9e4\n--- /dev/null\n+++ b/programs/disks/CommandTouch.cpp\n@@ -0,0 +1,34 @@\n+#include <Interpreters/Context.h>\n+#include <Common/TerminalSize.h>\n+#include \"DisksApp.h\"\n+#include \"DisksClient.h\"\n+#include \"ICommand.h\"\n+\n+namespace DB\n+{\n+\n+class CommandTouch final : public ICommand\n+{\n+public:\n+    explicit CommandTouch() : ICommand()\n+    {\n+        command_name = \"touch\";\n+        description = \"Create a file by path\";\n+        options_description.add_options()(\"path\", po::value<String>(), \"the path of listing (mandatory, positional)\");\n+        positional_options_description.add(\"path\", 1);\n+    }\n+\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n+    {\n+        auto disk = client.getCurrentDiskWithPath();\n+        String path = getValueFromCommandLineOptionsThrow<String>(options, \"path\");\n+\n+        disk.getDisk()->createFile(disk.getRelativeFromRoot(path));\n+    }\n+};\n+\n+CommandPtr makeCommandTouch()\n+{\n+    return std::make_shared<DB::CommandTouch>();\n+}\n+}\ndiff --git a/programs/disks/CommandWrite.cpp b/programs/disks/CommandWrite.cpp\nindex 7ded37e067a5..9c82132e2844 100644\n--- a/programs/disks/CommandWrite.cpp\n+++ b/programs/disks/CommandWrite.cpp\n@@ -1,79 +1,57 @@\n-#include \"ICommand.h\"\n #include <Interpreters/Context.h>\n+#include \"ICommand.h\"\n \n-#include <Common/TerminalSize.h>\n #include <IO/ReadBufferFromFile.h>\n #include <IO/WriteBufferFromFile.h>\n #include <IO/copyData.h>\n+#include <Common/TerminalSize.h>\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n class CommandWrite final : public ICommand\n {\n public:\n     CommandWrite()\n     {\n         command_name = \"write\";\n-        command_option_description.emplace(createOptionsDescription(\"Allowed options\", getTerminalWidth()));\n-        description = \"Write a file from `FROM_PATH` to `TO_PATH`\";\n-        usage = \"write [OPTION]... [<FROM_PATH>] <TO_PATH>\";\n-        command_option_description->add_options()\n-            (\"input\", po::value<String>(), \"file from which we are reading, defaults to `stdin`\");\n+        description = \"Write a file from `path-from` to `path-to`\";\n+        options_description.add_options()(\"path-from\", po::value<String>(), \"file from which we are reading, defaults to `stdin` (input from `stdin` is finished by Ctrl+D)\")(\n+            \"path-to\", po::value<String>(), \"file to which we are writing (mandatory, positional)\");\n+        positional_options_description.add(\"path-to\", 1);\n     }\n \n-    void processOptions(\n-        Poco::Util::LayeredConfiguration & config,\n-        po::variables_map & options) const override\n-    {\n-        if (options.count(\"input\"))\n-            config.setString(\"input\", options[\"input\"].as<String>());\n-    }\n \n-    void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) override\n+    void executeImpl(const CommandLineOptions & options, DisksClient & client) override\n     {\n-        if (command_arguments.size() != 1)\n-        {\n-            printHelpMessage();\n-            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-        }\n-\n-        String disk_name = config.getString(\"disk\", \"default\");\n+        auto disk = client.getCurrentDiskWithPath();\n \n-        const String & path = command_arguments[0];\n+        std::optional<String> path_from = getValueFromCommandLineOptionsWithOptional<String>(options, \"path-from\");\n \n-        DiskPtr disk = disk_selector->get(disk_name);\n+        String path_to = disk.getRelativeFromRoot(getValueFromCommandLineOptionsThrow<String>(options, \"path-to\"));\n \n-        String relative_path = validatePathAndGetAsRelative(path);\n-\n-        String path_input = config.getString(\"input\", \"\");\n-        std::unique_ptr<ReadBufferFromFileBase> in;\n-        if (path_input.empty())\n-        {\n-            in = std::make_unique<ReadBufferFromFileDescriptor>(STDIN_FILENO);\n-        }\n-        else\n+        auto in = [&]() -> std::unique_ptr<ReadBufferFromFileBase>\n         {\n-            String relative_path_input = validatePathAndGetAsRelative(path_input);\n-            in = disk->readFile(relative_path_input);\n-        }\n-\n-        auto out = disk->writeFile(relative_path);\n+            if (!path_from.has_value())\n+            {\n+                return std::make_unique<ReadBufferFromFileDescriptor>(STDIN_FILENO);\n+            }\n+            else\n+            {\n+                String relative_path_from = disk.getRelativeFromRoot(path_from.value());\n+                return disk.getDisk()->readFile(relative_path_from);\n+            }\n+        }();\n+\n+        auto out = disk.getDisk()->writeFile(path_to);\n         copyData(*in, *out);\n         out->finalize();\n     }\n };\n-}\n \n-std::unique_ptr <DB::ICommand> makeCommandWrite()\n+CommandPtr makeCommandWrite()\n {\n-    return std::make_unique<DB::CommandWrite>();\n+    return std::make_shared<DB::CommandWrite>();\n+}\n+\n }\ndiff --git a/programs/disks/DisksApp.cpp b/programs/disks/DisksApp.cpp\nindex 5da5ab4bae9f..59ba45b94519 100644\n--- a/programs/disks/DisksApp.cpp\n+++ b/programs/disks/DisksApp.cpp\n@@ -1,11 +1,22 @@\n #include \"DisksApp.h\"\n+#include <Client/ClientBase.h>\n+#include <Client/ReplxxLineReader.h>\n+#include \"Common/Exception.h\"\n+#include \"Common/filesystemHelpers.h\"\n+#include <Common/Config/ConfigProcessor.h>\n+#include \"DisksClient.h\"\n #include \"ICommand.h\"\n+#include \"ICommand_fwd.h\"\n+\n+#include <cstring>\n+#include <filesystem>\n+#include <memory>\n+#include <optional>\n \n #include <Disks/registerDisks.h>\n \n-#include <Common/TerminalSize.h>\n #include <Formats/registerFormats.h>\n-\n+#include <Common/TerminalSize.h>\n \n namespace DB\n {\n@@ -13,74 +24,289 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n+};\n+\n+LineReader::Patterns DisksApp::query_extenders = {\"\\\\\"};\n+LineReader::Patterns DisksApp::query_delimiters = {\"\"};\n+String DisksApp::word_break_characters = \" \\t\\v\\f\\a\\b\\r\\n\";\n+\n+CommandPtr DisksApp::getCommandByName(const String & command) const\n+{\n+    try\n+    {\n+        if (auto it = aliases.find(command); it != aliases.end())\n+            return command_descriptions.at(it->second);\n+\n+        return command_descriptions.at(command);\n+    }\n+    catch (std::out_of_range &)\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The command `{}` is unknown\", command);\n+    }\n+}\n+\n+std::vector<String> DisksApp::getEmptyCompletion(String command_name) const\n+{\n+    auto command_ptr = command_descriptions.at(command_name);\n+    std::vector<String> answer{};\n+    if (multidisk_commands.contains(command_ptr->command_name))\n+    {\n+        answer = client->getAllFilesByPatternFromAllDisks(\"\");\n+    }\n+    else\n+    {\n+        answer = client->getCurrentDiskWithPath().getAllFilesByPattern(\"\");\n+    }\n+    for (const auto & disk_name : client->getAllDiskNames())\n+    {\n+        answer.push_back(disk_name);\n+    }\n+    for (const auto & option : command_ptr->options_description.options())\n+    {\n+        answer.push_back(\"--\" + option->long_name());\n+    }\n+    if (command_name == \"help\")\n+    {\n+        for (const auto & [current_command_name, description] : command_descriptions)\n+        {\n+            answer.push_back(current_command_name);\n+        }\n+    }\n+    std::sort(answer.begin(), answer.end());\n+    return answer;\n }\n \n-size_t DisksApp::findCommandPos(std::vector<String> & common_arguments)\n+std::vector<String> DisksApp::getCommandsToComplete(const String & command_prefix) const\n {\n-    for (size_t i = 0; i < common_arguments.size(); i++)\n-        if (supported_commands.contains(common_arguments[i]))\n-            return i + 1;\n-    return common_arguments.size();\n+    std::vector<String> answer{};\n+    for (const auto & [word, _] : command_descriptions)\n+    {\n+        if (word.starts_with(command_prefix))\n+        {\n+            answer.push_back(word);\n+        }\n+    }\n+    if (!answer.empty())\n+    {\n+        std::sort(answer.begin(), answer.end());\n+        return answer;\n+    }\n+    for (const auto & [word, _] : aliases)\n+    {\n+        if (word.starts_with(command_prefix))\n+        {\n+            answer.push_back(word);\n+        }\n+    }\n+    if (!answer.empty())\n+    {\n+        std::sort(answer.begin(), answer.end());\n+        return answer;\n+    }\n+    return {command_prefix};\n+}\n+\n+std::vector<String> DisksApp::getCompletions(const String & prefix) const\n+{\n+    auto arguments = po::split_unix(prefix, word_break_characters);\n+    if (arguments.empty())\n+    {\n+        return {};\n+    }\n+    if (word_break_characters.contains(prefix.back()))\n+    {\n+        CommandPtr command;\n+        try\n+        {\n+            command = getCommandByName(arguments[0]);\n+        }\n+        catch (...)\n+        {\n+            return {arguments.back()};\n+        }\n+        return getEmptyCompletion(command->command_name);\n+    }\n+    else if (arguments.size() == 1)\n+    {\n+        String command_prefix = arguments[0];\n+        return getCommandsToComplete(command_prefix);\n+    }\n+    else\n+    {\n+        String last_token = arguments.back();\n+        CommandPtr command;\n+        try\n+        {\n+            command = getCommandByName(arguments[0]);\n+        }\n+        catch (...)\n+        {\n+            return {last_token};\n+        }\n+        std::vector<String> answer = {};\n+        if (command->command_name == \"help\")\n+        {\n+            return getCommandsToComplete(last_token);\n+        }\n+        else\n+        {\n+            answer = [&]() -> std::vector<String>\n+            {\n+                if (multidisk_commands.contains(command->command_name))\n+                {\n+                    return client->getAllFilesByPatternFromAllDisks(last_token);\n+                }\n+                else\n+                {\n+                    return client->getCurrentDiskWithPath().getAllFilesByPattern(last_token);\n+                }\n+            }();\n+\n+            for (const auto & disk_name : client->getAllDiskNames())\n+            {\n+                if (disk_name.starts_with(last_token))\n+                {\n+                    answer.push_back(disk_name);\n+                }\n+            }\n+            for (const auto & option : command->options_description.options())\n+            {\n+                String option_sign = \"--\" + option->long_name();\n+                if (option_sign.starts_with(last_token))\n+                {\n+                    answer.push_back(option_sign);\n+                }\n+            }\n+        }\n+        if (!answer.empty())\n+        {\n+            std::sort(answer.begin(), answer.end());\n+            return answer;\n+        }\n+        else\n+        {\n+            return {last_token};\n+        }\n+    }\n }\n \n-void DisksApp::printHelpMessage(ProgramOptionsDescription & command_option_description)\n+bool DisksApp::processQueryText(const String & text)\n {\n-    std::optional<ProgramOptionsDescription> help_description =\n-        createOptionsDescription(\"Help Message for clickhouse-disks\", getTerminalWidth());\n+    if (text.find_first_not_of(word_break_characters) == std::string::npos)\n+    {\n+        return true;\n+    }\n+    if (exit_strings.find(text) != exit_strings.end())\n+        return false;\n+    CommandPtr command;\n+    try\n+    {\n+        auto arguments = po::split_unix(text, word_break_characters);\n+        command = getCommandByName(arguments[0]);\n+        arguments.erase(arguments.begin());\n+        command->execute(arguments, *client);\n+    }\n+    catch (DB::Exception & err)\n+    {\n+        int code = getCurrentExceptionCode();\n+        if (code == ErrorCodes::LOGICAL_ERROR)\n+        {\n+            throw std::move(err);\n+        }\n+        else if (code == ErrorCodes::BAD_ARGUMENTS)\n+        {\n+            std::cerr << err.message() << \"\\n\"\n+                      << \"\\n\";\n+            if (command.get())\n+            {\n+                std::cerr << \"COMMAND: \" << command->command_name << \"\\n\";\n+                std::cerr << command->options_description << \"\\n\";\n+            }\n+            else\n+            {\n+                printAvailableCommandsHelpMessage();\n+            }\n+        }\n+        else\n+        {\n+            std::cerr << err.message() << \"\\n\";\n+        }\n+    }\n+    catch (std::exception & err)\n+    {\n+        std::cerr << err.what() << \"\\n\";\n+    }\n \n-    help_description->add(command_option_description);\n+    return true;\n+}\n \n-    std::cout << \"ClickHouse disk management tool\\n\";\n-    std::cout << \"Usage: ./clickhouse-disks [OPTION]\\n\";\n-    std::cout << \"clickhouse-disks\\n\\n\";\n+void DisksApp::runInteractiveReplxx()\n+{\n+    ReplxxLineReader lr(\n+        suggest,\n+        history_file,\n+        /* multiline= */ false,\n+        query_extenders,\n+        query_delimiters,\n+        word_break_characters.c_str(),\n+        /* highlighter_= */ {});\n+    lr.enableBracketedPaste();\n+\n+    while (true)\n+    {\n+        DiskWithPath disk_with_path = client->getCurrentDiskWithPath();\n+        String prompt = \"\\x1b[1;34m\" + disk_with_path.getDisk()->getName() + \"\\x1b[0m:\" + \"\\x1b[1;31m\" + disk_with_path.getCurrentPath()\n+            + \"\\x1b[0m$ \";\n \n-    for (const auto & current_command : supported_commands)\n-        std::cout << command_descriptions[current_command]->command_name\n-                  << \"\\t\"\n-                  << command_descriptions[current_command]->description\n-                  << \"\\n\\n\";\n+        auto input = lr.readLine(prompt, \"\\x1b[1;31m:-] \\x1b[0m\");\n+        if (input.empty())\n+            break;\n \n-    std::cout << command_option_description << '\\n';\n+        if (!processQueryText(input))\n+            break;\n+    }\n }\n \n-String DisksApp::getDefaultConfigFileName()\n+void DisksApp::parseAndCheckOptions(\n+    const std::vector<String> & arguments, const ProgramOptionsDescription & options_description, CommandLineOptions & options)\n {\n-    return \"/etc/clickhouse-server/config.xml\";\n+    auto parser = po::command_line_parser(arguments).options(options_description).allow_unregistered();\n+    po::parsed_options parsed = parser.run();\n+    po::store(parsed, options);\n }\n \n-void DisksApp::addOptions(\n-    ProgramOptionsDescription & options_description_,\n-    boost::program_options::positional_options_description & positional_options_description\n-)\n+void DisksApp::addOptions()\n {\n-    options_description_.add_options()\n-        (\"help,h\", \"Print common help message\")\n-        (\"config-file,C\", po::value<String>(), \"Set config file\")\n-        (\"disk\", po::value<String>(), \"Set disk name\")\n-        (\"command_name\", po::value<String>(), \"Name for command to do\")\n-        (\"save-logs\", \"Save logs to a file\")\n-        (\"log-level\", po::value<String>(), \"Logging level\")\n-        ;\n-\n-    positional_options_description.add(\"command_name\", 1);\n-\n-    supported_commands = {\"list-disks\", \"list\", \"move\", \"remove\", \"link\", \"copy\", \"write\", \"read\", \"mkdir\"};\n-#ifdef CLICKHOUSE_CLOUD\n-    supported_commands.insert(\"packed-io\");\n-#endif\n+    options_description.add_options()(\"help,h\", \"Print common help message\")(\"config-file,C\", po::value<String>(), \"Set config file\")(\n+        \"disk\", po::value<String>(), \"Set disk name\")(\"save-logs\", \"Save logs to a file\")(\n+        \"log-level\", po::value<String>(), \"Logging level\")(\"query,q\", po::value<String>(), \"Query for a non-interactive mode\")(\n+        \"test-mode\", \"Interactive interface in test regyme\");\n \n     command_descriptions.emplace(\"list-disks\", makeCommandListDisks());\n+    command_descriptions.emplace(\"copy\", makeCommandCopy());\n     command_descriptions.emplace(\"list\", makeCommandList());\n+    command_descriptions.emplace(\"cd\", makeCommandChangeDirectory());\n     command_descriptions.emplace(\"move\", makeCommandMove());\n     command_descriptions.emplace(\"remove\", makeCommandRemove());\n     command_descriptions.emplace(\"link\", makeCommandLink());\n-    command_descriptions.emplace(\"copy\", makeCommandCopy());\n     command_descriptions.emplace(\"write\", makeCommandWrite());\n     command_descriptions.emplace(\"read\", makeCommandRead());\n     command_descriptions.emplace(\"mkdir\", makeCommandMkDir());\n+    command_descriptions.emplace(\"switch-disk\", makeCommandSwitchDisk());\n+    command_descriptions.emplace(\"current_disk_with_path\", makeCommandGetCurrentDiskAndPath());\n+    command_descriptions.emplace(\"touch\", makeCommandTouch());\n+    command_descriptions.emplace(\"help\", makeCommandHelp(*this));\n #ifdef CLICKHOUSE_CLOUD\n     command_descriptions.emplace(\"packed-io\", makeCommandPackedIO());\n #endif\n+    for (const auto & [command_name, command_ptr] : command_descriptions)\n+    {\n+        if (command_name != command_ptr->command_name)\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Command name inside map doesn't coincide with actual command name\");\n+        }\n+    }\n }\n \n void DisksApp::processOptions()\n@@ -93,76 +319,122 @@ void DisksApp::processOptions()\n         config().setBool(\"save-logs\", true);\n     if (options.count(\"log-level\"))\n         config().setString(\"log-level\", options[\"log-level\"].as<String>());\n+    if (options.count(\"test-mode\"))\n+        config().setBool(\"test-mode\", true);\n+    if (options.count(\"query\"))\n+        query = std::optional{options[\"query\"].as<String>()};\n }\n \n-DisksApp::~DisksApp()\n+\n+void DisksApp::printEntryHelpMessage() const\n {\n-    if (global_context)\n-        global_context->shutdown();\n+    std::cout << \"\\x1b[1;33m ClickHouse disk management tool \\x1b[0m \\n\";\n+    std::cout << options_description << '\\n';\n+}\n+\n+\n+void DisksApp::printAvailableCommandsHelpMessage() const\n+{\n+    std::cout << \"\\x1b[1;32mAvailable commands:\\x1b[0m\\n\";\n+    std::vector<std::pair<String, CommandPtr>> commands_with_aliases_and_descrtiptions{};\n+    size_t maximal_command_length = 0;\n+    for (const auto & [command_name, command_ptr] : command_descriptions)\n+    {\n+        std::string command_string = getCommandLineWithAliases(command_ptr);\n+        maximal_command_length = std::max(maximal_command_length, command_string.size());\n+        commands_with_aliases_and_descrtiptions.push_back({std::move(command_string), command_descriptions.at(command_name)});\n+    }\n+    for (const auto & [command_with_aliases, command_ptr] : commands_with_aliases_and_descrtiptions)\n+    {\n+        std::cout << \"\\x1b[1;33m\" << command_with_aliases << \"\\x1b[0m\" << std::string(5, ' ') << \"\\x1b[1;33m\" << command_ptr->description\n+                  << \"\\x1b[0m \\n\";\n+        std::cout << command_ptr->options_description;\n+        std::cout << std::endl;\n+    }\n }\n \n-void DisksApp::init(std::vector<String> & common_arguments)\n+void DisksApp::printCommandHelpMessage(CommandPtr command) const\n {\n-    stopOptionsProcessing();\n+    String command_name_with_aliases = getCommandLineWithAliases(command);\n+    std::cout << \"\\x1b[1;32m\" << command_name_with_aliases << \"\\x1b[0m\" << std::string(2, ' ') << command->description << \"\\n\";\n+    std::cout << command->options_description;\n+}\n \n-    ProgramOptionsDescription options_description{createOptionsDescription(\"clickhouse-disks\", getTerminalWidth())};\n+void DisksApp::printCommandHelpMessage(String command_name) const\n+{\n+    printCommandHelpMessage(getCommandByName(command_name));\n+}\n \n-    po::positional_options_description positional_options_description;\n+String DisksApp::getCommandLineWithAliases(CommandPtr command) const\n+{\n+    String command_string = command->command_name;\n+    bool need_comma = false;\n+    for (const auto & [alias_name, alias_command_name] : aliases)\n+    {\n+        if (alias_command_name == command->command_name)\n+        {\n+            if (std::exchange(need_comma, true))\n+                command_string += \",\";\n+            else\n+                command_string += \"(\";\n+            command_string += alias_name;\n+        }\n+    }\n+    command_string += (need_comma ? \")\" : \"\");\n+    return command_string;\n+}\n \n-    addOptions(options_description, positional_options_description);\n+void DisksApp::initializeHistoryFile()\n+{\n+    String home_path;\n+    const char * home_path_cstr = getenv(\"HOME\"); // NOLINT(concurrency-mt-unsafe)\n+    if (home_path_cstr)\n+        home_path = home_path_cstr;\n+    if (config().has(\"history-file\"))\n+        history_file = config().getString(\"history-file\");\n+    else\n+        history_file = home_path + \"/.disks-file-history\";\n \n-    size_t command_pos = findCommandPos(common_arguments);\n-    std::vector<String> global_flags(command_pos);\n-    command_arguments.resize(common_arguments.size() - command_pos);\n-    copy(common_arguments.begin(), common_arguments.begin() + command_pos, global_flags.begin());\n-    copy(common_arguments.begin() + command_pos, common_arguments.end(), command_arguments.begin());\n+    if (!history_file.empty() && !fs::exists(history_file))\n+    {\n+        try\n+        {\n+            FS::createFile(history_file);\n+        }\n+        catch (const ErrnoException & e)\n+        {\n+            if (e.getErrno() != EEXIST)\n+                throw;\n+        }\n+    }\n+}\n \n-    parseAndCheckOptions(options_description, positional_options_description, global_flags);\n+void DisksApp::init(const std::vector<String> & common_arguments)\n+{\n+    addOptions();\n+    parseAndCheckOptions(common_arguments, options_description, options);\n \n     po::notify(options);\n \n     if (options.count(\"help\"))\n     {\n-        printHelpMessage(options_description);\n+        printEntryHelpMessage();\n+        printAvailableCommandsHelpMessage();\n         exit(0); // NOLINT(concurrency-mt-unsafe)\n     }\n \n-    if (!supported_commands.contains(command_name))\n-    {\n-        std::cerr << \"Unknown command name:  \" << command_name << \"\\n\";\n-        printHelpMessage(options_description);\n-        throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Bad Arguments\");\n-    }\n-\n     processOptions();\n }\n \n-void DisksApp::parseAndCheckOptions(\n-    ProgramOptionsDescription & options_description_,\n-    boost::program_options::positional_options_description & positional_options_description,\n-    std::vector<String> & arguments)\n+String DisksApp::getDefaultConfigFileName()\n {\n-    auto parser = po::command_line_parser(arguments)\n-        .options(options_description_)\n-        .positional(positional_options_description)\n-        .allow_unregistered();\n-\n-    po::parsed_options parsed = parser.run();\n-    po::store(parsed, options);\n-\n-    auto positional_arguments = po::collect_unrecognized(parsed.options, po::collect_unrecognized_mode::include_positional);\n-    for (const auto & arg : positional_arguments)\n-    {\n-        if (command_descriptions.contains(arg))\n-        {\n-            command_name = arg;\n-            break;\n-        }\n-    }\n+    return \"/etc/clickhouse-server/config.xml\";\n }\n \n int DisksApp::main(const std::vector<String> & /*args*/)\n {\n+    std::vector<std::string> keys;\n+    config().keys(keys);\n     if (config().has(\"config-file\") || fs::exists(getDefaultConfigFileName()))\n     {\n         String config_path = config().getString(\"config-file\", getDefaultConfigFileName());\n@@ -173,9 +445,13 @@ int DisksApp::main(const std::vector<String> & /*args*/)\n     }\n     else\n     {\n+        printEntryHelpMessage();\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"No config-file specified\");\n     }\n \n+    config().keys(keys);\n+    initializeHistoryFile();\n+\n     if (config().has(\"save-logs\"))\n     {\n         auto log_level = config().getString(\"log-level\", \"trace\");\n@@ -200,61 +476,68 @@ int DisksApp::main(const std::vector<String> & /*args*/)\n     global_context->setApplicationType(Context::ApplicationType::DISKS);\n \n     String path = config().getString(\"path\", DBMS_DEFAULT_PATH);\n+\n     global_context->setPath(path);\n \n-    auto & command = command_descriptions[command_name];\n+    String main_disk = config().getString(\"disk\", \"default\");\n \n-    auto command_options = command->getCommandOptions();\n-    std::vector<String> args;\n-    if (command_options)\n-    {\n-        auto parser = po::command_line_parser(command_arguments).options(*command_options).allow_unregistered();\n-        po::parsed_options parsed = parser.run();\n-        po::store(parsed, options);\n-        po::notify(options);\n+    auto validator = [](const Poco::Util::AbstractConfiguration &, const std::string &, const std::string &) { return true; };\n \n-        args = po::collect_unrecognized(parsed.options, po::collect_unrecognized_mode::include_positional);\n-        command->processOptions(config(), options);\n-    }\n-    else\n+    constexpr auto config_prefix = \"storage_configuration.disks\";\n+    auto disk_selector = std::make_shared<DiskSelector>(std::unordered_set<String>{\"cache\", \"encrypted\"});\n+    disk_selector->initialize(config(), config_prefix, global_context, validator);\n+\n+    std::vector<std::pair<DiskPtr, std::optional<String>>> disks_with_path;\n+\n+    for (const auto & [_, disk_ptr] : disk_selector->getDisksMap())\n     {\n-        auto parser = po::command_line_parser(command_arguments).options({}).allow_unregistered();\n-        po::parsed_options parsed = parser.run();\n-        args = po::collect_unrecognized(parsed.options, po::collect_unrecognized_mode::include_positional);\n+        disks_with_path.emplace_back(\n+            disk_ptr, (disk_ptr->getName() == \"local\") ? std::optional{fs::current_path().string()} : std::nullopt);\n     }\n \n-    std::unordered_set<std::string> disks\n-    {\n-        config().getString(\"disk\", \"default\"),\n-        config().getString(\"disk-from\", config().getString(\"disk\", \"default\")),\n-        config().getString(\"disk-to\", config().getString(\"disk\", \"default\")),\n-    };\n \n-    auto validator = [&disks](\n-        const Poco::Util::AbstractConfiguration & config,\n-        const std::string & disk_config_prefix,\n-        const std::string & disk_name)\n-    {\n-        if (!disks.contains(disk_name))\n-            return false;\n+    client = std::make_unique<DisksClient>(std::move(disks_with_path), main_disk);\n \n-        const auto disk_type = config.getString(disk_config_prefix + \".type\", \"local\");\n+    suggest.setCompletionsCallback([&](const String & prefix, size_t /* prefix_length */) { return getCompletions(prefix); });\n \n-        if (disk_type == \"cache\")\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Disk type 'cache' of disk {} is not supported by clickhouse-disks\", disk_name);\n+    if (!query.has_value())\n+    {\n+        runInteractive();\n+    }\n+    else\n+    {\n+        processQueryText(query.value());\n+    }\n \n-        return true;\n-    };\n+    return Application::EXIT_OK;\n+}\n \n-    constexpr auto config_prefix = \"storage_configuration.disks\";\n-    auto disk_selector = std::make_shared<DiskSelector>();\n-    disk_selector->initialize(config(), config_prefix, global_context, validator);\n+DisksApp::~DisksApp()\n+{\n+    client.reset(nullptr);\n+    if (global_context)\n+        global_context->shutdown();\n+}\n \n-    command->execute(args, disk_selector, config());\n+void DisksApp::runInteractiveTestMode()\n+{\n+    for (String input; std::getline(std::cin, input);)\n+    {\n+        if (!processQueryText(input))\n+            break;\n \n-    return Application::EXIT_OK;\n+        std::cout << \"\\a\\a\\a\\a\" << std::endl;\n+        std::cerr << std::flush;\n+    }\n }\n \n+void DisksApp::runInteractive()\n+{\n+    if (config().hasOption(\"test-mode\"))\n+        runInteractiveTestMode();\n+    else\n+        runInteractiveReplxx();\n+}\n }\n \n int mainEntryClickHouseDisks(int argc, char ** argv)\n@@ -269,16 +552,16 @@ int mainEntryClickHouseDisks(int argc, char ** argv)\n     catch (const DB::Exception & e)\n     {\n         std::cerr << DB::getExceptionMessage(e, false) << std::endl;\n-        return 1;\n+        return 0;\n     }\n     catch (const boost::program_options::error & e)\n     {\n         std::cerr << \"Bad arguments: \" << e.what() << std::endl;\n-        return DB::ErrorCodes::BAD_ARGUMENTS;\n+        return 0;\n     }\n     catch (...)\n     {\n         std::cerr << DB::getCurrentExceptionMessage(true) << std::endl;\n-        return 1;\n+        return 0;\n     }\n }\ndiff --git a/programs/disks/DisksApp.h b/programs/disks/DisksApp.h\nindex 51bc3f58dc43..f8167884c621 100644\n--- a/programs/disks/DisksApp.h\n+++ b/programs/disks/DisksApp.h\n@@ -1,61 +1,107 @@\n #pragma once\n \n+#include <unordered_map>\n+#include <vector>\n+#include <Client/ReplxxLineReader.h>\n #include <Loggers/Loggers.h>\n+#include \"DisksClient.h\"\n+#include \"ICommand_fwd.h\"\n \n #include <Interpreters/Context.h>\n+#include <boost/program_options/options_description.hpp>\n+#include <boost/program_options/variables_map.hpp>\n #include <Poco/Util/Application.h>\n \n-#include <boost/program_options.hpp>\n-\n namespace DB\n {\n \n-class ICommand;\n-using CommandPtr = std::unique_ptr<ICommand>;\n-\n-namespace po = boost::program_options;\n using ProgramOptionsDescription = boost::program_options::options_description;\n using CommandLineOptions = boost::program_options::variables_map;\n \n-class DisksApp : public Poco::Util::Application, public Loggers\n+class DisksApp : public Poco::Util::Application\n {\n public:\n-    DisksApp() = default;\n-    ~DisksApp() override;\n+    void addOptions();\n \n-    void init(std::vector<String> & common_arguments);\n+    void processOptions();\n \n-    int main(const std::vector<String> & args) override;\n+    bool processQueryText(const String & text);\n \n-protected:\n-    static String getDefaultConfigFileName();\n+    void init(const std::vector<String> & common_arguments);\n+\n+    int main(const std::vector<String> & /*args*/) override;\n+\n+    CommandPtr getCommandByName(const String & command) const;\n+\n+    void initializeHistoryFile();\n+\n+    static void parseAndCheckOptions(\n+        const std::vector<String> & arguments, const ProgramOptionsDescription & options_description, CommandLineOptions & options);\n+\n+    void printEntryHelpMessage() const;\n+    void printAvailableCommandsHelpMessage() const;\n+    void printCommandHelpMessage(String command_name) const;\n+    void printCommandHelpMessage(CommandPtr command) const;\n+    String getCommandLineWithAliases(CommandPtr command) const;\n \n-    void addOptions(\n-        ProgramOptionsDescription & options_description,\n-        boost::program_options::positional_options_description & positional_options_description);\n-    void processOptions();\n \n-    void printHelpMessage(ProgramOptionsDescription & command_option_description);\n+    std::vector<String> getCompletions(const String & prefix) const;\n \n-    size_t findCommandPos(std::vector<String> & common_arguments);\n+    std::vector<String> getEmptyCompletion(String command_name) const;\n+\n+    ~DisksApp() override;\n \n private:\n-    void parseAndCheckOptions(\n-        ProgramOptionsDescription & options_description,\n-        boost::program_options::positional_options_description & positional_options_description,\n-        std::vector<String> & arguments);\n+    void runInteractive();\n+    void runInteractiveReplxx();\n+    void runInteractiveTestMode();\n \n-protected:\n-    ContextMutablePtr global_context;\n-    SharedContextHolder shared_context;\n+    String getDefaultConfigFileName();\n+\n+    std::vector<String> getCommandsToComplete(const String & command_prefix) const;\n \n-    String command_name;\n-    std::vector<String> command_arguments;\n+    // Fields responsible for the REPL work\n+    String history_file;\n+    LineReader::Suggest suggest;\n+    static LineReader::Patterns query_extenders;\n+    static LineReader::Patterns query_delimiters;\n+    static String word_break_characters;\n \n-    std::unordered_set<String> supported_commands;\n+    // General command line arguments parsing fields\n+\n+    SharedContextHolder shared_context;\n+    ContextMutablePtr global_context;\n+    ProgramOptionsDescription options_description;\n+    CommandLineOptions options;\n     std::unordered_map<String, CommandPtr> command_descriptions;\n \n-    po::variables_map options;\n+    std::optional<String> query;\n+\n+    const std::unordered_map<String, String> aliases\n+        = {{\"cp\", \"copy\"},\n+           {\"mv\", \"move\"},\n+           {\"ls\", \"list\"},\n+           {\"list_disks\", \"list-disks\"},\n+           {\"ln\", \"link\"},\n+           {\"rm\", \"remove\"},\n+           {\"cat\", \"read\"},\n+           {\"r\", \"read\"},\n+           {\"w\", \"write\"},\n+           {\"create\", \"touch\"},\n+           {\"delete\", \"remove\"},\n+           {\"ls-disks\", \"list-disks\"},\n+           {\"ls_disks\", \"list-disks\"},\n+           {\"packed_io\", \"packed-io\"},\n+           {\"change-dir\", \"cd\"},\n+           {\"change_dir\", \"cd\"},\n+           {\"switch_disk\", \"switch-disk\"},\n+           {\"current\", \"current_disk_with_path\"},\n+           {\"current_disk\", \"current_disk_with_path\"},\n+           {\"current_path\", \"current_disk_with_path\"},\n+           {\"cur\", \"current_disk_with_path\"}};\n+\n+    std::set<String> multidisk_commands = {\"copy\", \"packed-io\", \"switch-disk\", \"cd\"};\n+\n+    std::unique_ptr<DisksClient> client{};\n };\n-\n }\ndiff --git a/programs/disks/DisksClient.cpp b/programs/disks/DisksClient.cpp\nnew file mode 100644\nindex 000000000000..7e36c7911ab3\n--- /dev/null\n+++ b/programs/disks/DisksClient.cpp\n@@ -0,0 +1,263 @@\n+#include \"DisksClient.h\"\n+#include <Client/ClientBase.h>\n+#include <Client/ReplxxLineReader.h>\n+#include <Disks/registerDisks.h>\n+#include <Common/Config/ConfigProcessor.h>\n+\n+#include <Formats/registerFormats.h>\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n+};\n+\n+namespace DB\n+{\n+DiskWithPath::DiskWithPath(DiskPtr disk_, std::optional<String> path_) : disk(disk_)\n+{\n+    if (path_.has_value())\n+    {\n+        if (!fs::path{path_.value()}.is_absolute())\n+        {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Initializing path {} is not absolute\", path_.value());\n+        }\n+        path = path_.value();\n+    }\n+    else\n+    {\n+        path = String{\"/\"};\n+    }\n+\n+    String relative_path = normalizePathAndGetAsRelative(path);\n+    if (disk->isDirectory(relative_path) || (relative_path.empty() && (disk->isDirectory(\"/\"))))\n+    {\n+        return;\n+    }\n+    throw Exception(\n+        ErrorCodes::BAD_ARGUMENTS,\n+        \"Initializing path {} (normalized path: {}) at disk {} is not a directory\",\n+        path,\n+        relative_path,\n+        disk->getName());\n+}\n+\n+std::vector<String> DiskWithPath::listAllFilesByPath(const String & any_path) const\n+{\n+    if (isDirectory(any_path))\n+    {\n+        std::vector<String> file_names;\n+        disk->listFiles(getRelativeFromRoot(any_path), file_names);\n+        return file_names;\n+    }\n+    else\n+    {\n+        return {};\n+    }\n+}\n+\n+std::vector<String> DiskWithPath::getAllFilesByPattern(const String & pattern) const\n+{\n+    auto [path_before, path_after] = [&]() -> std::pair<String, String>\n+    {\n+        auto slash_pos = pattern.find_last_of('/');\n+        if (slash_pos >= pattern.size())\n+        {\n+            return {\"\", pattern};\n+        }\n+        else\n+        {\n+            return {pattern.substr(0, slash_pos + 1), pattern.substr(slash_pos + 1, pattern.size() - slash_pos - 1)};\n+        }\n+    }();\n+\n+    if (!isDirectory(path_before))\n+    {\n+        return {};\n+    }\n+    else\n+    {\n+        std::vector<String> file_names = listAllFilesByPath(path_before);\n+\n+        std::vector<String> answer;\n+\n+        for (const auto & file_name : file_names)\n+        {\n+            if (file_name.starts_with(path_after))\n+            {\n+                String file_pattern = path_before + file_name;\n+                if (isDirectory(file_pattern))\n+                {\n+                    file_pattern = file_pattern + \"/\";\n+                }\n+                answer.push_back(file_pattern);\n+            }\n+        }\n+        return answer;\n+    }\n+};\n+\n+void DiskWithPath::setPath(const String & any_path)\n+{\n+    if (isDirectory(any_path))\n+    {\n+        path = getAbsolutePath(any_path);\n+    }\n+    else\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Path {} at disk {} is not a directory\", any_path, disk->getName());\n+    }\n+}\n+\n+String DiskWithPath::validatePathAndGetAsRelative(const String & path)\n+{\n+    String lexically_normal_path = fs::path(path).lexically_normal();\n+    if (lexically_normal_path.find(\"..\") != std::string::npos)\n+        throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Path {} is not normalized\", path);\n+\n+    /// If path is absolute we should keep it as relative inside disk, so disk will look like\n+    /// an ordinary filesystem with root.\n+    if (fs::path(lexically_normal_path).is_absolute())\n+        return lexically_normal_path.substr(1);\n+\n+    return lexically_normal_path;\n+}\n+\n+String DiskWithPath::normalizePathAndGetAsRelative(const String & messyPath)\n+{\n+    std::filesystem::path path(messyPath);\n+    std::filesystem::path canonical_path = std::filesystem::weakly_canonical(path);\n+    String npath = canonical_path.make_preferred().string();\n+    return validatePathAndGetAsRelative(npath);\n+}\n+\n+String DiskWithPath::normalizePath(const String & path)\n+{\n+    std::filesystem::path canonical_path = std::filesystem::weakly_canonical(path);\n+    return canonical_path.make_preferred().string();\n+}\n+\n+DisksClient::DisksClient(std::vector<std::pair<DiskPtr, std::optional<String>>> && disks_with_paths, std::optional<String> begin_disk)\n+{\n+    if (disks_with_paths.empty())\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Initializing array of disks is empty\");\n+    }\n+    if (!begin_disk.has_value())\n+    {\n+        begin_disk = disks_with_paths[0].first->getName();\n+    }\n+    bool has_begin_disk = false;\n+    for (auto & [disk, path] : disks_with_paths)\n+    {\n+        addDisk(disk, path);\n+        if (disk->getName() == begin_disk.value())\n+        {\n+            has_begin_disk = true;\n+        }\n+    }\n+    if (!has_begin_disk)\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"There is no begin_disk '{}' in initializing array\", begin_disk.value());\n+    }\n+    current_disk = std::move(begin_disk.value());\n+}\n+\n+const DiskWithPath & DisksClient::getDiskWithPath(const String & disk) const\n+{\n+    try\n+    {\n+        return disks.at(disk);\n+    }\n+    catch (...)\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The disk '{}' is unknown\", disk);\n+    }\n+}\n+\n+DiskWithPath & DisksClient::getDiskWithPath(const String & disk)\n+{\n+    try\n+    {\n+        return disks.at(disk);\n+    }\n+    catch (...)\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The disk '{}' is unknown\", disk);\n+    }\n+}\n+\n+const DiskWithPath & DisksClient::getCurrentDiskWithPath() const\n+{\n+    try\n+    {\n+        return disks.at(current_disk);\n+    }\n+    catch (...)\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"There is no current disk in client\");\n+    }\n+}\n+\n+DiskWithPath & DisksClient::getCurrentDiskWithPath()\n+{\n+    try\n+    {\n+        return disks.at(current_disk);\n+    }\n+    catch (...)\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"There is no current disk in client\");\n+    }\n+}\n+\n+void DisksClient::switchToDisk(const String & disk_, const std::optional<String> & path_)\n+{\n+    if (disks.contains(disk_))\n+    {\n+        if (path_.has_value())\n+        {\n+            disks.at(disk_).setPath(path_.value());\n+        }\n+        current_disk = disk_;\n+    }\n+    else\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The disk '{}' is unknown\", disk_);\n+    }\n+}\n+\n+std::vector<String> DisksClient::getAllDiskNames() const\n+{\n+    std::vector<String> answer{};\n+    answer.reserve(disks.size());\n+    for (const auto & [disk_name, _] : disks)\n+    {\n+        answer.push_back(disk_name);\n+    }\n+    return answer;\n+}\n+\n+std::vector<String> DisksClient::getAllFilesByPatternFromAllDisks(const String & pattern) const\n+{\n+    std::vector<String> answer{};\n+    for (const auto & [_, disk] : disks)\n+    {\n+        for (auto & word : disk.getAllFilesByPattern(pattern))\n+        {\n+            answer.push_back(word);\n+        }\n+    }\n+    return answer;\n+}\n+\n+void DisksClient::addDisk(DiskPtr disk_, const std::optional<String> & path_)\n+{\n+    String disk_name = disk_->getName();\n+    if (disks.contains(disk_->getName()))\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The disk '{}' already exists\", disk_name);\n+    }\n+    disks.emplace(disk_name, DiskWithPath{disk_, path_});\n+}\n+}\ndiff --git a/programs/disks/DisksClient.h b/programs/disks/DisksClient.h\nnew file mode 100644\nindex 000000000000..8a55d22af935\n--- /dev/null\n+++ b/programs/disks/DisksClient.h\n@@ -0,0 +1,89 @@\n+#pragma once\n+\n+#include <filesystem>\n+#include <optional>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+#include <Client/ReplxxLineReader.h>\n+#include <Loggers/Loggers.h>\n+#include \"Disks/IDisk.h\"\n+\n+#include <Interpreters/Context.h>\n+#include <boost/program_options/options_description.hpp>\n+#include <boost/program_options/variables_map.hpp>\n+\n+namespace fs = std::filesystem;\n+\n+namespace DB\n+{\n+\n+std::vector<String> split(const String & text, const String & delimiters);\n+\n+using ProgramOptionsDescription = boost::program_options::options_description;\n+using CommandLineOptions = boost::program_options::variables_map;\n+\n+class DiskWithPath\n+{\n+public:\n+    explicit DiskWithPath(DiskPtr disk_, std::optional<String> path_ = std::nullopt);\n+\n+    String getAbsolutePath(const String & any_path) const { return normalizePath(fs::path(path) / any_path); }\n+\n+    String getCurrentPath() const { return path; }\n+\n+    bool isDirectory(const String & any_path) const\n+    {\n+        return disk->isDirectory(getRelativeFromRoot(any_path)) || (getRelativeFromRoot(any_path).empty() && (disk->isDirectory(\"/\")));\n+    }\n+\n+    std::vector<String> listAllFilesByPath(const String & any_path) const;\n+\n+    std::vector<String> getAllFilesByPattern(const String & pattern) const;\n+\n+    DiskPtr getDisk() const { return disk; }\n+\n+    void setPath(const String & any_path);\n+\n+    String getRelativeFromRoot(const String & any_path) const { return normalizePathAndGetAsRelative(getAbsolutePath(any_path)); }\n+\n+private:\n+    static String validatePathAndGetAsRelative(const String & path);\n+    static std::string normalizePathAndGetAsRelative(const std::string & messyPath);\n+    static std::string normalizePath(const std::string & messyPath);\n+\n+    const DiskPtr disk;\n+    String path;\n+};\n+\n+class DisksClient\n+{\n+public:\n+    explicit DisksClient(std::vector<std::pair<DiskPtr, std::optional<String>>> && disks_with_paths, std::optional<String> begin_disk);\n+\n+    const DiskWithPath & getDiskWithPath(const String & disk) const;\n+\n+    DiskWithPath & getDiskWithPath(const String & disk);\n+\n+    const DiskWithPath & getCurrentDiskWithPath() const;\n+\n+    DiskWithPath & getCurrentDiskWithPath();\n+\n+    DiskPtr getCurrentDisk() const { return getCurrentDiskWithPath().getDisk(); }\n+\n+    DiskPtr getDisk(const String & disk) const { return getDiskWithPath(disk).getDisk(); }\n+\n+    void switchToDisk(const String & disk_, const std::optional<String> & path_);\n+\n+    std::vector<String> getAllDiskNames() const;\n+\n+    std::vector<String> getAllFilesByPatternFromAllDisks(const String & pattern) const;\n+\n+\n+private:\n+    void addDisk(DiskPtr disk_, const std::optional<String> & path_);\n+\n+    String current_disk;\n+    std::unordered_map<String, DiskWithPath> disks;\n+};\n+}\ndiff --git a/programs/disks/ICommand.cpp b/programs/disks/ICommand.cpp\nindex 86188fb6db1d..f622bcad3c6c 100644\n--- a/programs/disks/ICommand.cpp\n+++ b/programs/disks/ICommand.cpp\n@@ -1,5 +1,5 @@\n #include \"ICommand.h\"\n-#include <iostream>\n+#include \"DisksClient.h\"\n \n \n namespace DB\n@@ -10,43 +10,42 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n-void ICommand::printHelpMessage() const\n+CommandLineOptions ICommand::processCommandLineArguments(const Strings & commands)\n {\n-    std::cout << \"Command: \" << command_name << '\\n';\n-    std::cout << \"Description: \" << description << '\\n';\n-    std::cout << \"Usage: \" << usage << '\\n';\n+    CommandLineOptions options;\n+    auto parser = po::command_line_parser(commands);\n+    parser.options(options_description).positional(positional_options_description);\n \n-    if (command_option_description)\n-    {\n-        auto options = *command_option_description;\n-        if (!options.options().empty())\n-            std::cout << options << '\\n';\n-    }\n+    po::parsed_options parsed = parser.run();\n+    po::store(parsed, options);\n+\n+    return options;\n }\n \n-void ICommand::addOptions(ProgramOptionsDescription & options_description)\n+void ICommand::execute(const Strings & commands, DisksClient & client)\n {\n-    if (!command_option_description || command_option_description->options().empty())\n-        return;\n-\n-    options_description.add(*command_option_description);\n+    try\n+    {\n+        processCommandLineArguments(commands);\n+    }\n+    catch (std::exception & exc)\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{}\", exc.what());\n+    }\n+    executeImpl(processCommandLineArguments(commands), client);\n }\n \n-String ICommand::validatePathAndGetAsRelative(const String & path)\n+DiskWithPath & ICommand::getDiskWithPath(DisksClient & client, const CommandLineOptions & options, const String & name)\n {\n-    /// If path contain non-normalized symbols like . we will normalized them. If the resulting normalized path\n-    /// still contain '..' it can be dangerous, disallow such paths. Also since clickhouse-disks\n-    /// is not an interactive program (don't track you current path) it's OK to disallow .. paths.\n-    String lexically_normal_path = fs::path(path).lexically_normal();\n-    if (lexically_normal_path.find(\"..\") != std::string::npos)\n-        throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Path {} is not normalized\", path);\n-\n-    /// If path is absolute we should keep it as relative inside disk, so disk will look like\n-    /// an ordinary filesystem with root.\n-    if (fs::path(lexically_normal_path).is_absolute())\n-        return lexically_normal_path.substr(1);\n-\n-    return lexically_normal_path;\n+    auto disk_name = getValueFromCommandLineOptionsWithOptional<String>(options, name);\n+    if (disk_name.has_value())\n+    {\n+        return client.getDiskWithPath(disk_name.value());\n+    }\n+    else\n+    {\n+        return client.getCurrentDiskWithPath();\n+    }\n }\n \n }\ndiff --git a/programs/disks/ICommand.h b/programs/disks/ICommand.h\nindex efe350fe87b7..6faf90e2b527 100644\n--- a/programs/disks/ICommand.h\n+++ b/programs/disks/ICommand.h\n@@ -1,66 +1,146 @@\n #pragma once\n \n-#include <Disks/IDisk.h>\n+#include <optional>\n #include <Disks/DiskSelector.h>\n+#include <Disks/IDisk.h>\n \n+#include <boost/any/bad_any_cast.hpp>\n #include <boost/program_options.hpp>\n \n-#include <Common/Config/ConfigProcessor.h>\n #include <Poco/Util/Application.h>\n+#include \"Common/Exception.h\"\n+#include <Common/Config/ConfigProcessor.h>\n+\n+#include <boost/program_options/positional_options.hpp>\n \n-#include <memory>\n+#include \"DisksApp.h\"\n+\n+#include \"DisksClient.h\"\n+\n+#include \"ICommand_fwd.h\"\n \n namespace DB\n {\n \n namespace po = boost::program_options;\n-using ProgramOptionsDescription = boost::program_options::options_description;\n-using CommandLineOptions = boost::program_options::variables_map;\n+using ProgramOptionsDescription = po::options_description;\n+using PositionalProgramOptionsDescription = po::positional_options_description;\n+using CommandLineOptions = po::variables_map;\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n \n class ICommand\n {\n public:\n-    ICommand() = default;\n+    explicit ICommand() = default;\n \n     virtual ~ICommand() = default;\n \n-    virtual void execute(\n-        const std::vector<String> & command_arguments,\n-        std::shared_ptr<DiskSelector> & disk_selector,\n-        Poco::Util::LayeredConfiguration & config) = 0;\n+    void execute(const Strings & commands, DisksClient & client);\n \n-    const std::optional<ProgramOptionsDescription> & getCommandOptions() const { return command_option_description; }\n+    virtual void executeImpl(const CommandLineOptions & options, DisksClient & client) = 0;\n \n-    void addOptions(ProgramOptionsDescription & options_description);\n-\n-    virtual void processOptions(Poco::Util::LayeredConfiguration & config, po::variables_map & options) const = 0;\n+    CommandLineOptions processCommandLineArguments(const Strings & commands);\n \n protected:\n-    void printHelpMessage() const;\n+    template <typename T>\n+    static T getValueFromCommandLineOptions(const CommandLineOptions & options, const String & name)\n+    {\n+        try\n+        {\n+            return options[name].as<T>();\n+        }\n+        catch (boost::bad_any_cast &)\n+        {\n+            throw DB::Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument '{}' has wrong type and can't be parsed\", name);\n+        }\n+    }\n+\n+    template <typename T>\n+    static T getValueFromCommandLineOptionsThrow(const CommandLineOptions & options, const String & name)\n+    {\n+        if (options.count(name))\n+        {\n+            return getValueFromCommandLineOptions<T>(options, name);\n+        }\n+        else\n+        {\n+            throw DB::Exception(ErrorCodes::BAD_ARGUMENTS, \"Mandatory argument '{}' is missing\", name);\n+        }\n+    }\n+\n+    template <typename T>\n+    static T getValueFromCommandLineOptionsWithDefault(const CommandLineOptions & options, const String & name, const T & default_value)\n+    {\n+        if (options.count(name))\n+        {\n+            return getValueFromCommandLineOptions<T>(options, name);\n+        }\n+        else\n+        {\n+            return default_value;\n+        }\n+    }\n+\n+    template <typename T>\n+    static std::optional<T> getValueFromCommandLineOptionsWithOptional(const CommandLineOptions & options, const String & name)\n+    {\n+        if (options.count(name))\n+        {\n+            return std::optional{getValueFromCommandLineOptions<T>(options, name)};\n+        }\n+        else\n+        {\n+            return std::nullopt;\n+        }\n+    }\n+\n+    DiskWithPath & getDiskWithPath(DisksClient & client, const CommandLineOptions & options, const String & name);\n+\n+    String getTargetLocation(const String & path_from, DiskWithPath & disk_to, const String & path_to)\n+    {\n+        if (!disk_to.getDisk()->isDirectory(path_to))\n+        {\n+            return path_to;\n+        }\n+        String copied_path_from = path_from;\n+        if (copied_path_from.ends_with('/'))\n+        {\n+            copied_path_from.pop_back();\n+        }\n+        String plain_filename = fs::path(copied_path_from).filename();\n+\n+        return fs::path{path_to} / plain_filename;\n+    }\n \n-    static String validatePathAndGetAsRelative(const String & path);\n \n public:\n     String command_name;\n     String description;\n+    ProgramOptionsDescription options_description;\n \n protected:\n-    std::optional<ProgramOptionsDescription> command_option_description;\n-    String usage;\n-    po::positional_options_description positional_options_description;\n+    PositionalProgramOptionsDescription positional_options_description;\n };\n \n-using CommandPtr = std::unique_ptr<ICommand>;\n-\n-}\n-\n DB::CommandPtr makeCommandCopy();\n-DB::CommandPtr makeCommandLink();\n-DB::CommandPtr makeCommandList();\n DB::CommandPtr makeCommandListDisks();\n+DB::CommandPtr makeCommandList();\n+DB::CommandPtr makeCommandChangeDirectory();\n+DB::CommandPtr makeCommandLink();\n DB::CommandPtr makeCommandMove();\n DB::CommandPtr makeCommandRead();\n DB::CommandPtr makeCommandRemove();\n DB::CommandPtr makeCommandWrite();\n DB::CommandPtr makeCommandMkDir();\n+DB::CommandPtr makeCommandSwitchDisk();\n+DB::CommandPtr makeCommandGetCurrentDiskAndPath();\n+DB::CommandPtr makeCommandHelp(const DisksApp & disks_app);\n+DB::CommandPtr makeCommandTouch();\n+#ifdef CLICKHOUSE_CLOUD\n DB::CommandPtr makeCommandPackedIO();\n+#endif\n+}\ndiff --git a/programs/disks/ICommand_fwd.h b/programs/disks/ICommand_fwd.h\nnew file mode 100644\nindex 000000000000..84310b4a18d4\n--- /dev/null\n+++ b/programs/disks/ICommand_fwd.h\n@@ -0,0 +1,10 @@\n+#pragma once\n+\n+#include <memory>\n+\n+namespace DB\n+{\n+class ICommand;\n+\n+using CommandPtr = std::shared_ptr<ICommand>;\n+}\ndiff --git a/src/Disks/DiskFactory.cpp b/src/Disks/DiskFactory.cpp\nindex de7ee5a74f42..4aa7f6ff564d 100644\n--- a/src/Disks/DiskFactory.cpp\n+++ b/src/Disks/DiskFactory.cpp\n@@ -27,7 +27,8 @@ DiskPtr DiskFactory::create(\n     ContextPtr context,\n     const DisksMap & map,\n     bool attach,\n-    bool custom_disk) const\n+    bool custom_disk,\n+    const std::unordered_set<String> & skip_types) const\n {\n     const auto disk_type = config.getString(config_prefix + \".type\", \"local\");\n \n@@ -38,6 +39,11 @@ DiskPtr DiskFactory::create(\n                         \"DiskFactory: the disk '{}' has unknown disk type: {}\", name, disk_type);\n     }\n \n+    if (skip_types.contains(found->first))\n+    {\n+        return nullptr;\n+    }\n+\n     const auto & disk_creator = found->second;\n     return disk_creator(name, config, config_prefix, context, map, attach, custom_disk);\n }\ndiff --git a/src/Disks/DiskFactory.h b/src/Disks/DiskFactory.h\nindex d03ffa6a40fc..044ce81dbaeb 100644\n--- a/src/Disks/DiskFactory.h\n+++ b/src/Disks/DiskFactory.h\n@@ -42,7 +42,8 @@ class DiskFactory final : private boost::noncopyable\n         ContextPtr context,\n         const DisksMap & map,\n         bool attach = false,\n-        bool custom_disk = false) const;\n+        bool custom_disk = false,\n+        const std::unordered_set<String> & skip_types = {}) const;\n \n private:\n     using DiskTypeRegistry = std::unordered_map<String, Creator>;\ndiff --git a/src/Disks/DiskSelector.cpp b/src/Disks/DiskSelector.cpp\nindex a9260a249ddd..f45d12618bfc 100644\n--- a/src/Disks/DiskSelector.cpp\n+++ b/src/Disks/DiskSelector.cpp\n@@ -7,7 +7,6 @@\n #include <Common/logger_useful.h>\n #include <Interpreters/Context.h>\n \n-#include <set>\n \n namespace DB\n {\n@@ -27,7 +26,8 @@ void DiskSelector::assertInitialized() const\n }\n \n \n-void DiskSelector::initialize(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context, DiskValidator disk_validator)\n+void DiskSelector::initialize(\n+    const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context, DiskValidator disk_validator)\n {\n     Poco::Util::AbstractConfiguration::Keys keys;\n     config.keys(config_prefix, keys);\n@@ -36,6 +36,8 @@ void DiskSelector::initialize(const Poco::Util::AbstractConfiguration & config,\n \n     constexpr auto default_disk_name = \"default\";\n     bool has_default_disk = false;\n+    constexpr auto local_disk_name = \"local\";\n+    bool has_local_disk = false;\n     for (const auto & disk_name : keys)\n     {\n         if (!std::all_of(disk_name.begin(), disk_name.end(), isWordCharASCII))\n@@ -44,21 +46,31 @@ void DiskSelector::initialize(const Poco::Util::AbstractConfiguration & config,\n         if (disk_name == default_disk_name)\n             has_default_disk = true;\n \n+        if (disk_name == local_disk_name)\n+            has_local_disk = true;\n+\n         const auto disk_config_prefix = config_prefix + \".\" + disk_name;\n \n         if (disk_validator && !disk_validator(config, disk_config_prefix, disk_name))\n             continue;\n-\n-        disks.emplace(disk_name, factory.create(disk_name, config, disk_config_prefix, context, disks));\n+        auto created_disk\n+            = factory.create(disk_name, config, disk_config_prefix, context, disks, /*attach*/ false, /*custom_disk*/ false, skip_types);\n+        if (created_disk.get())\n+        {\n+            disks.emplace(disk_name, std::move(created_disk));\n+        }\n     }\n     if (!has_default_disk)\n     {\n         disks.emplace(\n-            default_disk_name,\n-            std::make_shared<DiskLocal>(\n-                default_disk_name, context->getPath(), 0, context, config, config_prefix));\n+            default_disk_name, std::make_shared<DiskLocal>(default_disk_name, context->getPath(), 0, context, config, config_prefix));\n     }\n \n+    if (!has_local_disk && (context->getApplicationType() == Context::ApplicationType::DISKS))\n+    {\n+        throw_away_local_on_update = true;\n+        disks.emplace(local_disk_name, std::make_shared<DiskLocal>(local_disk_name, \"/\", 0, context, config, config_prefix));\n+    }\n     is_initialized = true;\n }\n \n@@ -76,6 +88,7 @@ DiskSelectorPtr DiskSelector::updateFromConfig(\n     std::shared_ptr<DiskSelector> result = std::make_shared<DiskSelector>(*this);\n \n     constexpr auto default_disk_name = \"default\";\n+    constexpr auto local_disk_name = \"local\";\n     DisksMap old_disks_minus_new_disks(result->getDisksMap());\n \n     for (const auto & disk_name : keys)\n@@ -86,7 +99,12 @@ DiskSelectorPtr DiskSelector::updateFromConfig(\n         auto disk_config_prefix = config_prefix + \".\" + disk_name;\n         if (!result->getDisksMap().contains(disk_name))\n         {\n-            result->addToDiskMap(disk_name, factory.create(disk_name, config, disk_config_prefix, context, result->getDisksMap()));\n+            auto created_disk = factory.create(\n+                disk_name, config, disk_config_prefix, context, result->getDisksMap(), /*attach*/ false, /*custom_disk*/ false, skip_types);\n+            if (created_disk)\n+            {\n+                result->addToDiskMap(disk_name, created_disk);\n+            }\n         }\n         else\n         {\n@@ -99,6 +117,10 @@ DiskSelectorPtr DiskSelector::updateFromConfig(\n     }\n \n     old_disks_minus_new_disks.erase(default_disk_name);\n+    if (throw_away_local_on_update)\n+    {\n+        old_disks_minus_new_disks.erase(local_disk_name);\n+    }\n \n     if (!old_disks_minus_new_disks.empty())\n     {\ndiff --git a/src/Disks/DiskSelector.h b/src/Disks/DiskSelector.h\nindex 6669b428158d..49a1be5cf50d 100644\n--- a/src/Disks/DiskSelector.h\n+++ b/src/Disks/DiskSelector.h\n@@ -20,7 +20,7 @@ class DiskSelector\n public:\n     static constexpr auto TMP_INTERNAL_DISK_PREFIX = \"__tmp_internal_\";\n \n-    DiskSelector() = default;\n+    explicit DiskSelector(std::unordered_set<String> skip_types_ = {}) : skip_types(skip_types_) { }\n     DiskSelector(const DiskSelector & from) = default;\n \n     using DiskValidator = std::function<bool(const Poco::Util::AbstractConfiguration & config, const String & disk_config_prefix, const String & disk_name)>;\n@@ -48,6 +48,10 @@ class DiskSelector\n     bool is_initialized = false;\n \n     void assertInitialized() const;\n+\n+    const std::unordered_set<String> skip_types;\n+\n+    bool throw_away_local_on_update = false;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/integration/test_disks_app_func/test.py b/tests/integration/test_disks_app_func/test.py\nindex 97d5da787cd6..56ea5c8846a5 100644\n--- a/tests/integration/test_disks_app_func/test.py\n+++ b/tests/integration/test_disks_app_func/test.py\n@@ -9,7 +9,9 @@ def started_cluster():\n     try:\n         cluster = ClickHouseCluster(__file__)\n         cluster.add_instance(\n-            \"disks_app_test\", main_configs=[\"config.xml\"], with_minio=True\n+            \"disks_app_test\",\n+            main_configs=[\"config.xml\"],\n+            with_minio=True,\n         )\n \n         cluster.start()\n@@ -47,12 +49,18 @@ def test_disks_app_func_ld(started_cluster):\n     source = cluster.instances[\"disks_app_test\"]\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"list-disks\"]\n+        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--query\", \"list-disks\"]\n     )\n \n-    disks = out.split(\"\\n\")\n+    disks = list(\n+        sorted(\n+            map(\n+                lambda x: x.split(\":\")[0], filter(lambda x: len(x) > 1, out.split(\"\\n\"))\n+            )\n+        )\n+    )\n \n-    assert disks[0] == \"default\" and disks[1] == \"test1\" and disks[2] == \"test2\"\n+    assert disks[:4] == [\"default\", \"local\", \"test1\", \"test2\"]\n \n \n def test_disks_app_func_ls(started_cluster):\n@@ -61,7 +69,15 @@ def test_disks_app_func_ls(started_cluster):\n     init_data(source)\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test1\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test1\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     files = out.split(\"\\n\")\n@@ -75,9 +91,8 @@ def test_disks_app_func_ls(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test1\",\n-            \"list\",\n-            \".\",\n-            \"--recursive\",\n+            \"--query\",\n+            \"list . --recursive\",\n         ]\n     )\n \n@@ -102,8 +117,8 @@ def test_disks_app_func_cp(started_cluster):\n                     \"--save-logs\",\n                     \"--disk\",\n                     \"test1\",\n-                    \"write\",\n-                    \"path1\",\n+                    \"--query\",\n+                    \"'write path1'\",\n                 ]\n             ),\n         ]\n@@ -113,18 +128,21 @@ def test_disks_app_func_cp(started_cluster):\n         [\n             \"/usr/bin/clickhouse\",\n             \"disks\",\n-            \"copy\",\n-            \"--disk-from\",\n-            \"test1\",\n-            \"--disk-to\",\n-            \"test2\",\n-            \".\",\n-            \".\",\n+            \"--query\",\n+            \"copy --recursive --disk-from test1 --disk-to test2 . .\",\n         ]\n     )\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test2\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test2\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     assert \"path1\" in out\n@@ -136,8 +154,8 @@ def test_disks_app_func_cp(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test2\",\n-            \"remove\",\n-            \"path1\",\n+            \"--query\",\n+            \"remove path1\",\n         ]\n     )\n \n@@ -148,21 +166,37 @@ def test_disks_app_func_cp(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test1\",\n-            \"remove\",\n-            \"path1\",\n+            \"--query\",\n+            \"remove path1\",\n         ]\n     )\n \n     # alesapin: Why we need list one more time?\n     # kssenii: it is an assertion that the file is indeed deleted\n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test2\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test2\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     assert \"path1\" not in out\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test1\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test1\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     assert \"path1\" not in out\n@@ -177,14 +211,13 @@ def test_disks_app_func_ln(started_cluster):\n         [\n             \"/usr/bin/clickhouse\",\n             \"disks\",\n-            \"link\",\n-            \"data/default/test_table\",\n-            \"data/default/z_tester\",\n+            \"--query\",\n+            \"link data/default/test_table data/default/z_tester\",\n         ]\n     )\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"list\", \"data/default/\"]\n+        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--query\", \"list data/default/\"]\n     )\n \n     files = out.split(\"\\n\")\n@@ -209,15 +242,23 @@ def test_disks_app_func_rm(started_cluster):\n                     \"--save-logs\",\n                     \"--disk\",\n                     \"test2\",\n-                    \"write\",\n-                    \"path3\",\n+                    \"--query\",\n+                    \"'write path3'\",\n                 ]\n             ),\n         ]\n     )\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test2\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test2\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     assert \"path3\" in out\n@@ -229,13 +270,21 @@ def test_disks_app_func_rm(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test2\",\n-            \"remove\",\n-            \"path3\",\n+            \"--query\",\n+            \"remove path3\",\n         ]\n     )\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test2\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test2\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     assert \"path3\" not in out\n@@ -247,7 +296,15 @@ def test_disks_app_func_mv(started_cluster):\n     init_data(source)\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test1\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test1\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     files = out.split(\"\\n\")\n@@ -260,14 +317,21 @@ def test_disks_app_func_mv(started_cluster):\n             \"disks\",\n             \"--disk\",\n             \"test1\",\n-            \"move\",\n-            \"store\",\n-            \"old_store\",\n+            \"--query\",\n+            \"move store old_store\",\n         ]\n     )\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test1\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test1\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     files = out.split(\"\\n\")\n@@ -290,8 +354,8 @@ def test_disks_app_func_read_write(started_cluster):\n                     \"--save-logs\",\n                     \"--disk\",\n                     \"test1\",\n-                    \"write\",\n-                    \"5.txt\",\n+                    \"--query\",\n+                    \"'write 5.txt'\",\n                 ]\n             ),\n         ]\n@@ -304,8 +368,8 @@ def test_disks_app_func_read_write(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test1\",\n-            \"read\",\n-            \"5.txt\",\n+            \"--query\",\n+            \"read 5.txt\",\n         ]\n     )\n \n@@ -319,7 +383,15 @@ def test_remote_disk_list(started_cluster):\n     init_data_s3(source)\n \n     out = source.exec_in_container(\n-        [\"/usr/bin/clickhouse\", \"disks\", \"--save-logs\", \"--disk\", \"test3\", \"list\", \".\"]\n+        [\n+            \"/usr/bin/clickhouse\",\n+            \"disks\",\n+            \"--save-logs\",\n+            \"--disk\",\n+            \"test3\",\n+            \"--query\",\n+            \"list .\",\n+        ]\n     )\n \n     files = out.split(\"\\n\")\n@@ -333,9 +405,8 @@ def test_remote_disk_list(started_cluster):\n             \"--save-logs\",\n             \"--disk\",\n             \"test3\",\n-            \"list\",\n-            \".\",\n-            \"--recursive\",\n+            \"--query\",\n+            \"list . --recursive\",\n         ]\n     )\n \ndiff --git a/tests/integration/test_disks_app_interactive/__init__.py b/tests/integration/test_disks_app_interactive/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_disks_app_interactive/configs/config.xml b/tests/integration/test_disks_app_interactive/configs/config.xml\nnew file mode 100644\nindex 000000000000..bcbb107f0a27\n--- /dev/null\n+++ b/tests/integration/test_disks_app_interactive/configs/config.xml\n@@ -0,0 +1,3 @@\n+<clickhouse>\n+    <path>/var/lib/clickhouse/</path>\n+</clickhouse>\n\\ No newline at end of file\ndiff --git a/tests/integration/test_disks_app_interactive/test.py b/tests/integration/test_disks_app_interactive/test.py\nnew file mode 100644\nindex 000000000000..ca4ba5d90658\n--- /dev/null\n+++ b/tests/integration/test_disks_app_interactive/test.py\n@@ -0,0 +1,331 @@\n+from helpers.cluster import ClickHouseCluster\n+\n+import pytest\n+\n+import pathlib\n+\n+import subprocess\n+import select\n+import io\n+from typing import List, Tuple, Dict, Union, Optional\n+\n+import os\n+\n+\n+class ClickHouseDisksException(Exception):\n+    pass\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    global cluster\n+    try:\n+        cluster = ClickHouseCluster(__file__)\n+        cluster.add_instance(\n+            \"disks_app_test\",\n+            main_configs=[\"server_configs/config.xml\"],\n+            with_minio=True,\n+        )\n+\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+class DisksClient(object):\n+    SEPARATOR = b\"\\a\\a\\a\\a\\n\"\n+    local_client: Optional[\"DisksClient\"] = None  # static variable\n+    default_disk_root_directory: str = \"/var/lib/clickhouse\"\n+\n+    def __init__(self, bin_path: str, config_path: str, working_path: str):\n+        self.bin_path = bin_path\n+        self.working_path = working_path\n+\n+        self.proc = subprocess.Popen(\n+            [bin_path, \"disks\", \"--test-mode\", \"--config\", config_path],\n+            stdin=subprocess.PIPE,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+        )\n+\n+        self.poller = select.epoll()\n+        self.poller.register(self.proc.stdout)\n+        self.poller.register(self.proc.stderr)\n+\n+        self.stopped = False\n+\n+        self._fd_nums = {\n+            self.proc.stdout.fileno(): self.proc.stdout,\n+            self.proc.stderr.fileno(): self.proc.stderr,\n+        }\n+\n+    def execute_query(self, query: str, timeout: float = 5.0) -> str:\n+        output = io.BytesIO()\n+\n+        self.proc.stdin.write(query.encode() + b\"\\n\")\n+        self.proc.stdin.flush()\n+\n+        events = self.poller.poll(timeout)\n+        if not events:\n+            raise TimeoutError(f\"Disks client returned no output\")\n+\n+        for fd_num, event in events:\n+            if event & (select.EPOLLIN | select.EPOLLPRI):\n+                file = self._fd_nums[fd_num]\n+\n+                if file == self.proc.stdout:\n+                    while True:\n+                        chunk = file.readline()\n+                        if chunk.endswith(self.SEPARATOR):\n+                            break\n+\n+                        output.write(chunk)\n+\n+                elif file == self.proc.stderr:\n+                    error_line = self.proc.stderr.readline()\n+                    print(error_line)\n+                    raise ClickHouseDisksException(error_line.strip().decode())\n+\n+            else:\n+                raise ValueError(f\"Failed to read from pipe. Flag {event}\")\n+\n+        data = output.getvalue().strip().decode()\n+        return data\n+\n+    def list_disks(self) -> List[Tuple[str, str]]:\n+        output = self.execute_query(\"list-disks\")\n+        return list(\n+            sorted(\n+                map(\n+                    lambda x: (x.split(\":\")[0], \":\".join(x.split(\":\")[1:])),\n+                    output.split(\"\\n\"),\n+                )\n+            )\n+        )\n+\n+    def current_disk_with_path(self) -> Tuple[str, str]:\n+        output = self.execute_query(\"current_disk_with_path\")\n+        disk_line = output.split(\"\\n\")[0]\n+        path_line = output.split(\"\\n\")[1]\n+        assert disk_line.startswith(\"Disk: \")\n+        assert path_line.startswith(\"Path: \")\n+        return disk_line[6:], path_line[6:]\n+\n+    def ls(\n+        self, path: str, recursive: bool = False, show_hidden: bool = False\n+    ) -> Union[List[str], Dict[str, List[str]]]:\n+        recursive_adding = \"--recursive \" if recursive else \"\"\n+        show_hidden_adding = \"--all \" if show_hidden else \"\"\n+        output = self.execute_query(\n+            f\"list {path} {recursive_adding} {show_hidden_adding}\"\n+        )\n+        if recursive:\n+            answer: Dict[str, List[str]] = dict()\n+            blocks = output.split(\"\\n\\n\")\n+            for block in blocks:\n+                directory = block.split(\"\\n\")[0][:-1]\n+                files = block.split(\"\\n\")[1:]\n+                answer[directory] = files\n+            return answer\n+        else:\n+            return output.split(\"\\n\")\n+\n+    def switch_disk(self, disk: str, directory: Optional[str] = None):\n+        directory_addition = f\"--path {directory} \" if directory is not None else \"\"\n+        self.execute_query(f\"switch-disk {disk} {directory_addition}\")\n+\n+    def cd(self, directory: str, disk: Optional[str] = None):\n+        disk_addition = f\"--disk {disk} \" if disk is not None else \"\"\n+        self.execute_query(f\"cd {directory} {disk_addition}\")\n+\n+    def copy(\n+        self,\n+        path_from,\n+        path_to,\n+        disk_from: Optional[str] = None,\n+        disk_to: Optional[str] = None,\n+        recursive: bool = False,\n+    ):\n+        disk_from_option = f\"--disk-from {disk_from} \" if disk_from is not None else \"\"\n+        disk_to_option = f\"--disk-to {disk_to} \" if disk_to is not None else \"\"\n+        recursive_tag = \"--recursive\" if recursive else \"\"\n+\n+        self.execute_query(\n+            f\"copy {recursive_tag} {path_from} {path_to} {disk_from_option} {disk_to_option}\"\n+        )\n+\n+    def move(self, path_from: str, path_to: str):\n+        self.execute_query(f\"move {path_from} {path_to}\")\n+\n+    def rm(self, path: str, recursive: bool = False):\n+        recursive_tag = \"--recursive\" if recursive else \"\"\n+        self.execute_query(f\"rm {recursive_tag} {path}\")\n+\n+    def mkdir(self, path: str, recursive: bool = False):\n+        recursive_adding = \"--recursive \" if recursive else \"\"\n+        self.execute_query(f\"mkdir {path} {recursive_adding}\")\n+\n+    def ln(self, path_from: str, path_to: str):\n+        self.execute_query(f\"link {path_from} {path_to}\")\n+\n+    def read(self, path_from: str, path_to: Optional[str] = None):\n+        path_to_adding = f\"--path-to {path_to} \" if path_to is not None else \"\"\n+        output = self.execute_query(f\"read {path_from} {path_to_adding}\")\n+        return output\n+\n+    def write(\n+        self, path_from: str, path_to: str\n+    ):  # Writing from stdin is difficult to test (do not know how to do this in python)\n+        path_from_adding = f\"--path-from {path_from}\"\n+        self.execute_query(f\"write {path_from_adding} {path_to}\")\n+\n+    @staticmethod\n+    def getLocalDisksClient(refresh: bool):\n+        if (DisksClient.local_client is None) or refresh:\n+            binary_file = os.environ.get(\"CLICKHOUSE_TESTS_SERVER_BIN_PATH\")\n+            current_working_directory = str(pathlib.Path().resolve())\n+            config_file = f\"{current_working_directory}/test_disks_app_interactive/configs/config.xml\"\n+            if not os.path.exists(DisksClient.default_disk_root_directory):\n+                os.mkdir(DisksClient.default_disk_root_directory)\n+\n+            DisksClient.local_client = DisksClient(\n+                binary_file, config_file, current_working_directory\n+            )\n+            return DisksClient.local_client\n+        else:\n+            return DisksClient.local_client\n+\n+\n+def test_disks_app_interactive_list_disks():\n+    client = DisksClient.getLocalDisksClient(True)\n+    expected_disks_with_path = [\n+        (\"default\", \"/\"),\n+        (\"local\", client.working_path),\n+    ]\n+    assert expected_disks_with_path == client.list_disks()\n+    assert client.current_disk_with_path() == (\"default\", \"/\")\n+    client.switch_disk(\"local\")\n+    assert client.current_disk_with_path() == (\n+        \"local\",\n+        client.working_path,\n+    )\n+\n+\n+def test_disks_app_interactive_list_files_local():\n+    client = DisksClient.getLocalDisksClient(True)\n+    client.switch_disk(\"local\")\n+    excepted_listed_files = sorted(os.listdir(\"test_disks_app_interactive/\"))\n+    listed_files = sorted(client.ls(\"test_disks_app_interactive/\"))\n+    assert excepted_listed_files == listed_files\n+\n+\n+def test_disks_app_interactive_list_directories_default():\n+    client = DisksClient.getLocalDisksClient(True)\n+    traversed_dir = client.ls(\".\", recursive=True)\n+    client.mkdir(\"dir1\")\n+    client.mkdir(\"dir2\")\n+    client.mkdir(\".dir3\")\n+    client.cd(\"dir1\")\n+    client.mkdir(\"dir11\")\n+    client.mkdir(\".dir12\")\n+    client.mkdir(\"dir13\")\n+    client.cd(\"../dir2\")\n+    client.mkdir(\"dir21\")\n+    client.mkdir(\"dir22\")\n+    client.mkdir(\".dir23\")\n+    client.cd(\"../.dir3\")\n+    client.mkdir(\"dir31\")\n+    client.mkdir(\".dir32\")\n+    client.cd(\"..\")\n+    traversed_dir = client.ls(\".\", recursive=True)\n+    assert traversed_dir == {\n+        \".\": [\"dir1\", \"dir2\"],\n+        \"./dir1\": [\"dir11\", \"dir13\"],\n+        \"./dir2\": [\"dir21\", \"dir22\"],\n+        \"./dir1/dir11\": [],\n+        \"./dir1/dir13\": [],\n+        \"./dir2/dir21\": [],\n+        \"./dir2/dir22\": [],\n+    }\n+    traversed_dir = client.ls(\".\", recursive=True, show_hidden=True)\n+    assert traversed_dir == {\n+        \".\": [\".dir3\", \"dir1\", \"dir2\"],\n+        \"./dir1\": [\".dir12\", \"dir11\", \"dir13\"],\n+        \"./dir2\": [\".dir23\", \"dir21\", \"dir22\"],\n+        \"./.dir3\": [\".dir32\", \"dir31\"],\n+        \"./dir1/dir11\": [],\n+        \"./dir1/.dir12\": [],\n+        \"./dir1/dir13\": [],\n+        \"./dir2/dir21\": [],\n+        \"./dir2/dir22\": [],\n+        \"./dir2/.dir23\": [],\n+        \"./.dir3/dir31\": [],\n+        \"./.dir3/.dir32\": [],\n+    }\n+    client.rm(\"dir2\", recursive=True)\n+    traversed_dir = client.ls(\".\", recursive=True, show_hidden=True)\n+    assert traversed_dir == {\n+        \".\": [\".dir3\", \"dir1\"],\n+        \"./dir1\": [\".dir12\", \"dir11\", \"dir13\"],\n+        \"./.dir3\": [\".dir32\", \"dir31\"],\n+        \"./dir1/dir11\": [],\n+        \"./dir1/.dir12\": [],\n+        \"./dir1/dir13\": [],\n+        \"./.dir3/dir31\": [],\n+        \"./.dir3/.dir32\": [],\n+    }\n+    traversed_dir = client.ls(\".\", recursive=True, show_hidden=False)\n+    assert traversed_dir == {\n+        \".\": [\"dir1\"],\n+        \"./dir1\": [\"dir11\", \"dir13\"],\n+        \"./dir1/dir11\": [],\n+        \"./dir1/dir13\": [],\n+    }\n+    client.rm(\"dir1\", recursive=True)\n+    client.rm(\".dir3\", recursive=True)\n+    assert client.ls(\".\", recursive=True, show_hidden=False) == {\".\": []}\n+\n+\n+def test_disks_app_interactive_cp_and_read():\n+    initial_text = \"File content\"\n+    with open(\"a.txt\", \"w\") as file:\n+        file.write(initial_text)\n+    client = DisksClient.getLocalDisksClient(True)\n+    client.switch_disk(\"default\")\n+    client.copy(\"a.txt\", \"/a.txt\", disk_from=\"local\", disk_to=\"default\")\n+    read_text = client.read(\"a.txt\")\n+    assert initial_text == read_text\n+    client.mkdir(\"dir1\")\n+    client.copy(\"a.txt\", \"/dir1/b.txt\", disk_from=\"local\", disk_to=\"default\")\n+    read_text = client.read(\"a.txt\", path_to=\"dir1/b.txt\")\n+    assert \"\" == read_text\n+    read_text = client.read(\"/dir1/b.txt\")\n+    assert read_text == initial_text\n+    with open(f\"{DisksClient.default_disk_root_directory}/dir1/b.txt\", \"r\") as file:\n+        read_text = file.read()\n+        assert read_text == initial_text\n+    os.remove(\"a.txt\")\n+    client.rm(\"a.txt\")\n+    client.rm(\"/dir1\", recursive=True)\n+\n+\n+def test_disks_app_interactive_test_move_and_write():\n+    initial_text = \"File content\"\n+    with open(\"a.txt\", \"w\") as file:\n+        file.write(initial_text)\n+    client = DisksClient.getLocalDisksClient(True)\n+    client.switch_disk(\"default\")\n+    client.copy(\"a.txt\", \"/a.txt\", disk_from=\"local\", disk_to=\"default\")\n+    files = client.ls(\".\")\n+    assert files == [\"a.txt\"]\n+    client.move(\"a.txt\", \"b.txt\")\n+    files = client.ls(\".\")\n+    assert files == [\"b.txt\"]\n+    read_text = client.read(\"/b.txt\")\n+    assert read_text == initial_text\n+    client.write(\"b.txt\", \"c.txt\")\n+    read_text = client.read(\"c.txt\")\n+    assert read_text == initial_text\n+    os.remove(\"a.txt\")\ndiff --git a/tests/queries/0_stateless/02802_clickhouse_disks_s3_copy.sh b/tests/queries/0_stateless/02802_clickhouse_disks_s3_copy.sh\nindex 2b9e5296a05e..20b02bcba32f 100755\n--- a/tests/queries/0_stateless/02802_clickhouse_disks_s3_copy.sh\n+++ b/tests/queries/0_stateless/02802_clickhouse_disks_s3_copy.sh\n@@ -14,14 +14,11 @@ function run_test_for_disk()\n \n     echo \"$disk\"\n \n-    clickhouse-disks -C \"$config\" --disk \"$disk\" write --input \"$config\" $CLICKHOUSE_DATABASE/test\n-    clickhouse-disks -C \"$config\" --log-level test --disk \"$disk\" copy $CLICKHOUSE_DATABASE/test $CLICKHOUSE_DATABASE/test.copy |& {\n+    clickhouse-disks -C \"$config\" --disk \"$disk\" --query \"write --path-from $config $CLICKHOUSE_DATABASE/test\"\n+    clickhouse-disks -C \"$config\" --log-level test --disk \"$disk\" --query \"copy -r $CLICKHOUSE_DATABASE/test $CLICKHOUSE_DATABASE/test.copy\" |& {\n         grep -o -e \"Single part upload has completed.\" -e \"Single operation copy has completed.\"\n     }\n-    clickhouse-disks -C \"$config\" --disk \"$disk\" remove $CLICKHOUSE_DATABASE/test\n-    # NOTE: this is due to \"copy\" does works like \"cp -R from to/\" instead of \"cp from to\"\n-    clickhouse-disks -C \"$config\" --disk \"$disk\" remove $CLICKHOUSE_DATABASE/test.copy/test\n-    clickhouse-disks -C \"$config\" --disk \"$disk\" remove $CLICKHOUSE_DATABASE/test.copy\n+    clickhouse-disks -C \"$config\" --disk \"$disk\" --query \"remove -r $CLICKHOUSE_DATABASE/test\"\n }\n \n function run_test_copy_from_s3_to_s3(){\n@@ -29,13 +26,12 @@ function run_test_copy_from_s3_to_s3(){\n     local disk_dest=$1 && shift\n \n     echo \"copy from $disk_src to $disk_dest\"\n-    clickhouse-disks -C \"$config\" --disk \"$disk_src\" write  --input \"$config\" $CLICKHOUSE_DATABASE/test\n+    clickhouse-disks -C \"$config\" --disk \"$disk_src\" --query \"write --path-from $config $CLICKHOUSE_DATABASE/test\"\n \n-    clickhouse-disks -C \"$config\" --log-level test copy --disk-from \"$disk_src\" --disk-to \"$disk_dest\"  $CLICKHOUSE_DATABASE/test $CLICKHOUSE_DATABASE/test.copy |& {\n+    clickhouse-disks -C \"$config\" --log-level test --query \"copy -r --disk-from $disk_src --disk-to $disk_dest $CLICKHOUSE_DATABASE/test $CLICKHOUSE_DATABASE/test.copy\" |& {\n         grep -o -e \"Single part upload has completed.\" -e \"Single operation copy has completed.\"\n     }\n-    clickhouse-disks -C \"$config\" --disk \"$disk_dest\" remove $CLICKHOUSE_DATABASE/test.copy/test\n-    clickhouse-disks -C \"$config\" --disk \"$disk_dest\" remove $CLICKHOUSE_DATABASE/test.copy\n+    clickhouse-disks -C \"$config\" --disk \"$disk_dest\" --query \"remove -r $CLICKHOUSE_DATABASE/test.copy\"\n }\n \n run_test_for_disk s3_plain_native_copy\ndiff --git a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.reference b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.reference\nindex 531163e1d84e..3135f2d01e1a 100644\n--- a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.reference\n+++ b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.reference\n@@ -3,28 +3,28 @@ data after ATTACH\t1\n Files before DETACH TABLE\n all_1_1_0\n \n-backups/ordinary_default/data/ordinary_default/data/all_1_1_0:\n-primary.cidx\n-serialization.json\n-metadata_version.txt\n-default_compression_codec.txt\n+/backups/ordinary_default/data/ordinary_default/data/all_1_1_0:\n+checksums.txt\n+columns.txt\n+count.txt\n data.bin\n data.cmrk3\n-count.txt\n-columns.txt\n-checksums.txt\n+default_compression_codec.txt\n+metadata_version.txt\n+primary.cidx\n+serialization.json\n \n Files after DETACH TABLE\n all_1_1_0\n \n-backups/ordinary_default/data/ordinary_default/data/all_1_1_0:\n-primary.cidx\n-serialization.json\n-metadata_version.txt\n-default_compression_codec.txt\n+/backups/ordinary_default/data/ordinary_default/data/all_1_1_0:\n+checksums.txt\n+columns.txt\n+count.txt\n data.bin\n data.cmrk3\n-count.txt\n-columns.txt\n-checksums.txt\n+default_compression_codec.txt\n+metadata_version.txt\n+primary.cidx\n+serialization.json\n \ndiff --git a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.sh b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.sh\nindex 12d08159012d..d543f7195a9a 100755\n--- a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.sh\n+++ b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.sh\n@@ -49,11 +49,11 @@ path=$($CLICKHOUSE_CLIENT -q \"SELECT replace(data_paths[1], 's3_plain', '') FROM\n path=${path%/}\n \n echo \"Files before DETACH TABLE\"\n-clickhouse-disks -C \"$config\" --disk s3_plain_disk list --recursive \"${path:?}\" | tail -n+2\n+clickhouse-disks -C \"$config\" --disk s3_plain_disk --query \"list --recursive $path\" | tail -n+2\n \n $CLICKHOUSE_CLIENT -q \"detach table data\"\n echo \"Files after DETACH TABLE\"\n-clickhouse-disks -C \"$config\" --disk s3_plain_disk list --recursive \"$path\" | tail -n+2\n+clickhouse-disks -C \"$config\" --disk s3_plain_disk --query \"list --recursive $path\" | tail -n+2\n \n # metadata file is left\n $CLICKHOUSE_CLIENT --force_remove_data_recursively_on_drop=1 -q \"drop database if exists $CLICKHOUSE_DATABASE\"\ndiff --git a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.reference b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.reference\nindex 1e191b719a5a..a2dd196083e1 100644\n--- a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.reference\n+++ b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.reference\n@@ -3,28 +3,28 @@ data after ATTACH\t1\n Files before DETACH TABLE\n all_X_X_X\n \n-backups/ordinary_default/data/ordinary_default/data_read/all_X_X_X:\n-primary.cidx\n-serialization.json\n-metadata_version.txt\n-default_compression_codec.txt\n+/backups/ordinary_default/data/ordinary_default/data_read/all_X_X_X:\n+checksums.txt\n+columns.txt\n+count.txt\n data.bin\n data.cmrk3\n-count.txt\n-columns.txt\n-checksums.txt\n+default_compression_codec.txt\n+metadata_version.txt\n+primary.cidx\n+serialization.json\n \n Files after DETACH TABLE\n all_X_X_X\n \n-backups/ordinary_default/data/ordinary_default/data_read/all_X_X_X:\n-primary.cidx\n-serialization.json\n-metadata_version.txt\n-default_compression_codec.txt\n+/backups/ordinary_default/data/ordinary_default/data_read/all_X_X_X:\n+checksums.txt\n+columns.txt\n+count.txt\n data.bin\n data.cmrk3\n-count.txt\n-columns.txt\n-checksums.txt\n+default_compression_codec.txt\n+metadata_version.txt\n+primary.cidx\n+serialization.json\n \ndiff --git a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.sh b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.sh\nindex b079e67a0001..eec05c813446 100755\n--- a/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.sh\n+++ b/tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.sh\n@@ -55,14 +55,14 @@ path=${path%/}\n \n echo \"Files before DETACH TABLE\"\n # sed to match any part, since in case of fault injection part name may not be all_0_0_0 but all_1_1_0\n-clickhouse-disks -C \"$config\" --disk s3_plain_disk list --recursive \"${path:?}\" | tail -n+2 | sed 's/all_[^_]*_[^_]*_0/all_X_X_X/g'\n+clickhouse-disks -C \"$config\" --disk s3_plain_disk --query \"list --recursive $path\" | tail -n+2 | sed 's/all_[^_]*_[^_]*_0/all_X_X_X/g'\n \n $CLICKHOUSE_CLIENT -nm -q \"\n     detach table data_read;\n     detach table data_write;\n \"\n echo \"Files after DETACH TABLE\"\n-clickhouse-disks -C \"$config\" --disk s3_plain_disk list --recursive \"$path\" | tail -n+2 | sed 's/all_[^_]*_[^_]*_0/all_X_X_X/g'\n+clickhouse-disks -C \"$config\" --disk s3_plain_disk --query \"list --recursive $path\" | tail -n+2 | sed 's/all_[^_]*_[^_]*_0/all_X_X_X/g'\n \n # metadata file is left\n $CLICKHOUSE_CLIENT --force_remove_data_recursively_on_drop=1 -q \"drop database if exists $CLICKHOUSE_DATABASE\"\n",
  "problem_statement": "`clickhouse-disks` usability improvements\n`clickhouse-disks` is an awesome tool which allow to interact with any implementation of IDisk in ClickHouse. So if you need to list/read/remove something on remote filesystem you can use this tool in the following way:\r\n\r\n`clickhouse-disks --config /etc/clickhouse-server/config.xml --disk s3_disk list data/table_path/detached/part`\r\n\r\nHowever usability of this command is far from perfect. There are list of things to do to improve usability:\r\n1. Tool always tries to load all disks not the disk you actually need to operate. It makes the tool super slow on startup. \r\n2. If you have cached disks `clickhouse-disk` refuse to start because of lock-file https://github.com/yandex/ch-backup/issues/84#issuecomment-1797996846.\r\n3. When you have typo in command (`rm` instead of `remove` for example) `clickhouse-disk` produce unreadable error message.\r\n4. There is no interactive mode in `clickhouse-disks`, it would be super useful to have. Look at clickhouse-keeper-client implementation.\r\n5. Recursive copy do something strange. If you want to copy directory with nested subdirs like: \r\n```\r\nall_0_0_0/columns.txt\r\n...\r\nall_0_0_0/projection.proj/columns.txt\r\n...\r\n```\r\n(just try it).\r\n6. For some reason operations are super super slow. It can take tens of seconds to remove a single directory.\r\n7. Tool lack verbose mode. I really want to see what happens when I execute remove recursive.\r\n\n",
  "hints_text": "Since the `remove` command is sequential, it can take quite a long time to execute when we are deleting big directory.  Also if object storage disk is used the situation becomes even more complicated. \r\n\r\nSo maybe make sense to enable parallel execution? For example, with some knob that allows  deleting not in single transaction.\r\n ",
  "created_at": "2024-05-27T11:56:03Z",
  "modified_files": [
    "docs/en/operations/utilities/clickhouse-disks.md",
    "programs/disks/CMakeLists.txt",
    "b/programs/disks/CommandChangeDirectory.cpp",
    "programs/disks/CommandCopy.cpp",
    "b/programs/disks/CommandGetCurrentDiskAndPath.cpp",
    "b/programs/disks/CommandHelp.cpp",
    "programs/disks/CommandLink.cpp",
    "programs/disks/CommandList.cpp",
    "programs/disks/CommandListDisks.cpp",
    "programs/disks/CommandMkDir.cpp",
    "programs/disks/CommandMove.cpp",
    "programs/disks/CommandRead.cpp",
    "programs/disks/CommandRemove.cpp",
    "b/programs/disks/CommandSwitchDisk.cpp",
    "b/programs/disks/CommandTouch.cpp",
    "programs/disks/CommandWrite.cpp",
    "programs/disks/DisksApp.cpp",
    "programs/disks/DisksApp.h",
    "b/programs/disks/DisksClient.cpp",
    "b/programs/disks/DisksClient.h",
    "programs/disks/ICommand.cpp",
    "programs/disks/ICommand.h",
    "b/programs/disks/ICommand_fwd.h",
    "src/Disks/DiskFactory.cpp",
    "src/Disks/DiskFactory.h",
    "src/Disks/DiskSelector.cpp",
    "src/Disks/DiskSelector.h"
  ],
  "modified_test_files": [
    "tests/integration/test_disks_app_func/test.py",
    "b/tests/integration/test_disks_app_interactive/configs/config.xml",
    "b/tests/integration/test_disks_app_interactive/test.py",
    "tests/queries/0_stateless/02802_clickhouse_disks_s3_copy.sh",
    "tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.reference",
    "tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_MergeTree.sh",
    "tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.reference",
    "tests/queries/0_stateless/02980_s3_plain_DROP_TABLE_ReplicatedMergeTree.sh"
  ]
}