{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9251,
  "instance_id": "ClickHouse__ClickHouse-9251",
  "issue_numbers": [
    "7314"
  ],
  "base_commit": "0c686baf4f810f9aba2d3da9dd0c1e068ec4a93f",
  "patch": "diff --git a/dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp b/dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp\nindex 54d5205c4c29..740fe35e9368 100644\n--- a/dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp\n+++ b/dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp\n@@ -124,15 +124,12 @@ class CheckExpressionVisitorData\n         {\n             /// leave other comparisons as is\n         }\n-        else if (functionIsLikeOperator(node.name)) /// LIKE, NOT LIKE\n+        else if (functionIsLikeOperator(node.name) || /// LIKE, NOT LIKE\n+                 functionIsInOperator(node.name))  /// IN, NOT IN\n         {\n-            /// leave as is\n-        }\n-        else if (functionIsInOperator(node.name)) /// IN, NOT IN\n-        {\n-            if (auto ident = node.arguments->children.at(0)->as<ASTIdentifier>())\n-                if (size_t min_table = checkIdentifier(*ident))\n-                    asts_to_join_on[min_table].push_back(ast);\n+            /// leave as is. It's not possible to make push down here cause of unknown aliases and not implemented JOIN predicates.\n+            ///     select a as b form t1, t2 where t1.x = t2.x and b in(42)\n+            ///     select a as b form t1 inner join t2 on t1.x = t2.x and b in(42)\n         }\n         else\n         {\n@@ -202,16 +199,6 @@ class CheckExpressionVisitorData\n         }\n         return 0;\n     }\n-\n-    size_t checkIdentifier(const ASTIdentifier & identifier)\n-    {\n-        size_t best_table_pos = 0;\n-        bool match = IdentifierSemantic::chooseTable(identifier, tables, best_table_pos);\n-\n-        if (match && joined_tables[best_table_pos].canAttachOnExpression())\n-            return best_table_pos;\n-        return 0;\n-    }\n };\n \n using CheckExpressionMatcher = ConstOneTypeMatcher<CheckExpressionVisitorData, false>;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00863_comma_join_in.sql b/dbms/tests/queries/0_stateless/00863_comma_join_in.sql\nindex 8cfc00627dce..ebccd351c8a1 100644\n--- a/dbms/tests/queries/0_stateless/00863_comma_join_in.sql\n+++ b/dbms/tests/queries/0_stateless/00863_comma_join_in.sql\n@@ -10,6 +10,8 @@ insert into test1_00863 (id, code) select number, toString(number) FROM numbers(\n insert into test3_00863 (id, code) select number, toString(number) FROM numbers(100000);\n insert into test2_00863 (id, code, test1_id, test3_id) select number, toString(number), number, number FROM numbers(100000);\n \n+SET max_memory_usage = 50000000;\n+\n select test2_00863.id\n from test1_00863, test2_00863, test3_00863\n where test1_00863.code in ('1', '2', '3')\ndiff --git a/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.reference b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.reference\nnew file mode 100644\nindex 000000000000..699fa0cd95c4\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.reference\n@@ -0,0 +1,1 @@\n+2\t2\t1\ndiff --git a/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.sql b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.sql\nnew file mode 100644\nindex 000000000000..f6d788512f84\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.sql\n@@ -0,0 +1,13 @@\n+drop table if exists ax;\n+drop table if exists bx;\n+\n+create table ax (A Int64, B Int64) Engine = Memory;\n+create table bx (A Int64) Engine = Memory;\n+\n+insert into ax values (1, 1), (2, 1);\n+insert into bx values (2), (4);\n+\n+select * from bx, ax where ax.A = bx.A and ax.B in (1,2);\n+\n+drop table ax;\n+drop table bx;\n",
  "problem_statement": "Can not use comma-separated join tables with IN clause\nHere's the query I have tried\r\n\r\n```\r\nselect *\r\nfrom `web_olap`.`date_dim` as `date_dim`, `web_olap`.`sale_fact` as `sale_fact`\r\nwhere `sale_fact`.`date_dim_id` = `date_dim`.`id`\r\n  and (`sale_fact`.`order_id` in (1, 2))\r\n\r\n```\r\nIt didn't work and throw exception\r\n\r\n**Invalid expression for JOIN ON. Expected equals expression, got order_id IN (1, 2). Supported syntax: JOIN ON Expr([table.]column, ...) = Expr([table.]column, ...) [AND Expr([table.]column, ...) = Expr([table.]column, ...) ...], Stack trace:**\r\n\r\n> 0. 0x34293f8 StackTrace::StackTrace() /usr/local/bin/clickhouse\r\n> 1. 0x3431e3f DB::Exception::Exception(std::string const&, int) /usr/local/bin/clickhouse\r\n> 2. 0x6183d30 DB::CollectJoinOnKeysMatcher::throwSyntaxException(std::string const&) /usr/local/bin/clickhouse\r\n> 3. 0x6184a59 DB::CollectJoinOnKeysMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::CollectJoinOnKeysMatcher::Data&) /usr/local/bin/clickhouse\r\n> 4. 0x5c6506f DB::InDepthNodeVisitorTemplate<DB::CollectJoinOnKeysMatcher, true, std::shared_ptr<DB::IAST> const>::visit(std::shared_ptr<DB::IAST> const&) /usr/local/bin/clickhouse\r\n> 5. 0x5c650b3 DB::InDepthNodeVisitorTemplate<DB::CollectJoinOnKeysMatcher, true, std::shared_ptr<DB::IAST> const>::visit(std::shared_ptr<DB::IAST> const&) /usr/local/bin/clickhouse\r\n> 6. 0x5c650b3 DB::InDepthNodeVisitorTemplate<DB::CollectJoinOnKeysMatcher, true, std::shared_ptr<DB::IAST> const>::visit(std::shared_ptr<DB::IAST> const&) /usr/local/bin/clickhouse\r\n> 7. 0x5c613c2 DB::SyntaxAnalyzer::analyze(std::shared_ptr<DB::IAST>&, DB::NamesAndTypesList const&, std::vector<std::string, std::allocator<std::string> > const&, std::shared_ptr<DB::IStorage>, DB::NamesAndTypesList const&) const /usr/local/bin/clickhouse\r\n> 8. 0x5b7a04e DB::InterpreterSelectQuery::InterpreterSelectQuery(std::shared_ptr<DB::IAST> const&, DB::Context const&, std::shared_ptr<DB::IBlockInputStream> const&, std::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::vector<std::string, std::allocator<std::string> > const&) /usr/local/bin/clickhouse\r\n> 9. 0x5b7b1ab DB::InterpreterSelectQuery::InterpreterSelectQuery(std::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::vector<std::string, std::allocator<std::string> > const&) /usr/local/bin/clickhouse\r\n> 10. 0x5ba43d1 DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::vector<std::string, std::allocator<std::string> > const&) /usr/local/bin/clickhouse\r\n> 11. 0x5b5ffaf DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, DB::Context&, DB::QueryProcessingStage::Enum) /usr/local/bin/clickhouse\r\n> 12. 0x5c82e98 DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*, bool) /usr/local/bin/clickhouse\r\n> 13. 0x5c856f5 DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::string const&)>, std::function<void (std::string const&)>) /usr/local/bin/clickhouse\r\n> 14. 0x34f1241 DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&) /usr/local/bin/clickhouse\r\n> 15. 0x34f36ff DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&) /usr/local/bin/clickhouse\r\n> 16. 0x65f5ba0 Poco::Net::HTTPServerConnection::run() /usr/local/bin/clickhouse\r\n> 17. 0x65f32cf Poco::Net::TCPServerConnection::start() /usr/local/bin/clickhouse\r\n> 18. 0x65f3995 Poco::Net::TCPServerDispatcher::run() /usr/local/bin/clickhouse\r\n> 19. 0x69b5eb1 Poco::PooledThread::run() /usr/local/bin/clickhouse\r\n> 20. 0x69b3cf8 Poco::ThreadImpl::runnableEntry(void*) /usr/local/bin/clickhouse\r\n> 21. 0x6f8cb8f execute_native_thread_routine /usr/local/bin/clickhouse\r\n> 22. 0x7f686171cdd5 start_thread /usr/lib64/libpthread-2.17.so\r\n> 23. 0x7f6861039ead __clone /usr/lib64/libc-2.17.so\r\n>  (version 19.15.2.2)\r\n> \n",
  "hints_text": "it should be\r\n```\r\n\r\nselect *\r\nfrom `web_olap`.`date_dim` as `date_dim` \r\n         join `web_olap`.`sale_fact` as `sale_fact` on  `sale_fact`.`date_dim_id` = `date_dim`.`id`\r\n  where (`sale_fact`.`order_id` in (1, 2))\r\n```\r\n\r\nand for better performance\r\n```\r\n\r\nselect *\r\nfrom `web_olap`.`date_dim` as `date_dim` \r\n         join (select  .... from `web_olap`.`sale_fact` where (`sale_fact`.`order_id` in (1, 2))) as `sale_fact` on  `sale_fact`.`date_dim_id` = `date_dim`.`id`\r\n  \r\n```\nThanks for quick response, but I currently use clickhouse-jdbc with Mondrian schema and it generates sql like above\r\n\r\n```\r\nselect *\r\nfrom `web_olap`.`date_dim` as `date_dim`, `web_olap`.`sale_fact` as `sale_fact`\r\nwhere `sale_fact`.`date_dim_id` = `date_dim`.`id`\r\n  and (`sale_fact`.`order_id` in (1, 2))\r\n```\r\n\r\nCan clickhouse somehow support this type of query please?\r\n\nReproducible example:\r\n\r\ncreate table ax (A Int64, B Int64) Engine=Memory;\r\ncreate table bx (A Int64) Engine=Memory;\r\n\r\nselect * from bx, ax where ax.A=bx.A and ax.B in (1,2);\r\n\r\n\r\nReceived exception from server (version 19.16.1):\r\nCode: 403. DB::Exception: Received from localhost:9000. DB::Exception: Invalid expression for JOIN ON. Expected equals expression, got B IN (1, 2)\r\n\r\n\r\n------------\r\n\r\nselect * from ax,bx where ax.A=bx.A and ax.B in (1,2);\r\n\r\nOk.\r\n0 rows in set. Elapsed: 0.002 sec.\nThe problem is here: https://github.com/ClickHouse/ClickHouse/blob/master/dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp#L124\r\n\r\nIt's not easy to fix. It's hack to push IN clause down to subquery. And it looks like it depends on tables order. Related to #4731 ",
  "created_at": "2020-02-20T13:34:54Z",
  "modified_files": [
    "dbms/src/Interpreters/CrossToInnerJoinVisitor.cpp"
  ],
  "modified_test_files": [
    "dbms/tests/queries/0_stateless/00863_comma_join_in.sql",
    "b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.reference",
    "b/dbms/tests/queries/0_stateless/01083_cross_to_inner_with_in_bug.sql"
  ]
}