{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64775,
  "instance_id": "ClickHouse__ClickHouse-64775",
  "issue_numbers": [
    "64513"
  ],
  "base_commit": "8f550f17575c0f5c51fbf6fb40d284e3d3b93479",
  "patch": "diff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 1b2a55a50b04..83b6f4f2c269 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -1526,6 +1526,8 @@ JoinTreeQueryPlan buildQueryPlanForJoinNode(const QueryTreeNodePtr & join_table_\n         left_join_tree_query_plan.actions_dags.emplace_back(std::move(join_clauses_and_actions.left_join_expressions_actions));\n     if (join_clauses_and_actions.right_join_expressions_actions)\n         left_join_tree_query_plan.actions_dags.emplace_back(std::move(join_clauses_and_actions.right_join_expressions_actions));\n+    if (join_clauses_and_actions.mixed_join_expressions_actions)\n+        left_join_tree_query_plan.actions_dags.push_back(join_clauses_and_actions.mixed_join_expressions_actions);\n \n     auto mapping = std::move(left_join_tree_query_plan.query_node_to_plan_step_mapping);\n     auto & r_mapping = right_join_tree_query_plan.query_node_to_plan_step_mapping;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.reference b/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.reference\nindex 806596f8a63d..46f24f73356b 100644\n--- a/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.reference\n+++ b/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.reference\n@@ -38,6 +38,17 @@ key4\tf\t2\t3\t4\t\t\t0\t0\t\\N\n SELECT t1.*, t2.* from t1 LEFT JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 LEFT JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key2\ta2\t1\t1\t1\t\t\t0\t0\t\\N\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n key1\ta\t1\t1\t2\tkey1\tB\t2\t1\t2\n@@ -67,6 +78,16 @@ key1\tc\t3\t2\t1\tkey1\tD\t4\t1\t6\n SELECT t1.*, t2.* from t1 INNER JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 INNER JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 RIGHT JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n \t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n@@ -102,6 +123,17 @@ key1\tc\t3\t2\t1\tkey1\tD\t4\t1\t6\n SELECT t1.*, t2.* from t1 RIGHT JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 RIGHT JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 RIGHT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+\t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 FULL JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n \t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n@@ -146,6 +178,18 @@ key4\tf\t2\t3\t4\t\t\t0\t0\t\\N\n SELECT t1.*, t2.* from t1 FULL JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 FULL JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 FULL JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+\t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key2\ta2\t1\t1\t1\t\t\t0\t0\t\\N\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SET join_algorithm='grace_hash';\n SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n@@ -185,6 +229,17 @@ key4\tf\t2\t3\t4\t\t\t0\t0\t\\N\n SELECT t1.*, t2.* from t1 LEFT JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 LEFT JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key2\ta2\t1\t1\t1\t\t\t0\t0\t\\N\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n key1\ta\t1\t1\t2\tkey1\tB\t2\t1\t2\n@@ -214,6 +269,16 @@ key1\tc\t3\t2\t1\tkey1\tD\t4\t1\t6\n SELECT t1.*, t2.* from t1 INNER JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 INNER JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 RIGHT JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n \t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n@@ -249,6 +314,17 @@ key1\tc\t3\t2\t1\tkey1\tD\t4\t1\t6\n SELECT t1.*, t2.* from t1 RIGHT JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 RIGHT JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 RIGHT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+\t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SELECT t1.*, t2.* FROM t1 FULL JOIN t2 ON (t1.a < t2.a OR lower(t1.attr) == lower(t2.attr)) AND t1.key = t2.key ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n \t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\n@@ -293,6 +369,18 @@ key4\tf\t2\t3\t4\t\t\t0\t0\t\\N\n SELECT t1.*, t2.* from t1 FULL JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 FULL JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n 1\t1\t1\t1\t1\t1\n+SELECT t1.*, t2.* FROM t1 FULL JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n+\t\t0\t0\t\\N\tkey3\ta3\t1\t1\t1\n+key1\ta\t1\t1\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tA\t1\t2\t1\n+key1\tb\t2\t3\t2\tkey1\tB\t2\t1\t2\n+key1\tb\t2\t3\t2\tkey1\tC\t3\t4\t5\n+key1\tb\t2\t3\t2\tkey1\tD\t4\t1\t6\n+key1\tc\t3\t2\t1\tkey1\tC\t3\t4\t5\n+key1\td\t4\t7\t2\tkey1\tC\t3\t4\t5\n+key1\te\t5\t5\t5\tkey1\tC\t3\t4\t5\n+key2\ta2\t1\t1\t1\t\t\t0\t0\t\\N\n+key4\tf\t2\t3\t4\tkey4\tF\t1\t1\t1\n SET join_algorithm='hash';\n SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND t1.a < t2.a OR t1.a = t2.a ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n key1\ta\t1\t1\t2\tkey1\tA\t1\t2\t1\ndiff --git a/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.sql.j2 b/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.sql.j2\nindex d3aa74f5c38d..a363101ca693 100644\n--- a/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.sql.j2\n+++ b/tests/queries/0_stateless/03006_join_on_inequal_expression_fast.sql.j2\n@@ -18,6 +18,7 @@ SELECT t1.*, t2.* from t1 {{ join_type }} JOIN t2 ON t1.key = t2.key and (t1.b +\n SELECT t1.*, t2.* from t1 {{ join_type }} JOIN t2 ON t1.key = t2.key and (t1.a < t2.a) ORDER BY (t1.key, t1.attr, t2.key, t2.attr);\n SELECT t1.*, t2.* from t1 {{ join_type }} JOIN t2 ON t1.key = t2.key and t1.c ORDER BY (t1.key, t1.attr, t2.key, t2.attr); -- { serverError INVALID_JOIN_ON_EXPRESSION }\n SELECT * FROM (SELECT 1 AS a, 1 AS b, 1 AS c) AS t1 {{ join_type }} JOIN (SELECT 1 AS a, 1 AS b, 1 AS c) AS t2 ON t1.a = t2.a AND (t1.b > 0 OR t2.b > 0);\n+SELECT t1.*, t2.* FROM t1 {{ join_type }} JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 3))) ORDER BY ALL;\n {% endfor -%}\n {% endfor -%}\n \n",
  "problem_statement": "Experimental unequal JOIN condition with OR+IN subquery (LOGICAL_ERROR: Not-ready Set is passed)\n\r\nReproducing example:\r\n```\r\npastila https://pastila.nl/?001ca277/f9a3d3ed2c4546ab2cf08a121f1a7817#ooPNiXCy2oRdI7DLq5PL/A== | clickhouse client -n --echo\r\n```\r\n\r\nQuery:\r\n```\r\nDROP TABLE IF EXISTS t1;\r\nDROP TABLE IF EXISTS t2;\r\n\r\nCREATE TABLE t1 (\r\n    key UInt32,\r\n    a UInt32\r\n)  ENGINE = MergeTree ORDER BY key;\r\n\r\nCREATE TABLE t2 (\r\n    key UInt32,\r\n    a UInt32\r\n) ENGINE = MergeTree ORDER BY key;\r\n\r\nINSERT INTO t1 (key, a) VALUES (1, 10), (2, 15), (3, 20);\r\nINSERT INTO t2 (key, a) VALUES (1, 5), (2, 10), (4, 25);\r\n\r\nSET allow_experimental_analyzer=1;\r\nSET allow_experimental_join_condition = 1;\r\nSET join_algorithm='hash';\r\nSET send_logs_level = 'error';\r\n\r\n-- These queries work\r\nSELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND ((t2.a IN (SELECT a FROM t1 WHERE a = 10))) ORDER BY t1.key, t2.key;\r\n\r\nSELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 AND (t2.a IN (SELECT a FROM t1 WHERE a = 10))) ORDER BY t1.key, t2.key;\r\n\r\n-- This query doesn't\r\nSELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 10))) ORDER BY t1.key, t2.key;\r\n```\r\n\r\nResult:\r\n```\r\n[nikpc] 2024.05.28 15:05:47.881292 [ 2530949 ] {0b49ebc4-8a12-4d2a-bb51-d0ba17e22d62} <Error> executeQuery: Code: 49. DB::Exception: Not-ready Set is passed as the second argument for function 'in': while executing 'FUNCTION in(__table2.a :: 1, __set_18088566730452824076_8550654433943010493 :: 0) -> in(__table2.a, __set_18088566730452824076_8550654433943010493) UInt8 : 4': While executing JoiningTransform. (LOGICAL_ERROR) (version 24.5.1.1747 (official build)) (from 127.0.0.1:43828) (in query: -- This query is not\r\n SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 10))) ORDER BY t1.key, t2.key;), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. ./build_docker/./src/Common/Exception.cpp:101: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000c5c4fbb\r\n1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x00000000077960ec\r\n2. DB::Exception::Exception<String>(int, FormatStringHelperImpl<std::type_identity<String>::type>, String&&) @ 0x0000000007795c4b\r\n3. DB::(anonymous namespace)::FunctionIn<false, false, true, false>::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000098c284c\r\n4. DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000080cbb0e\r\n5. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000000f222770\r\n6. DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000000f223301\r\n7. DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000000f224779\r\n8. ./contrib/boost/boost/smart_ptr/intrusive_ptr.hpp:117: DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool, bool) const @ 0x000000001016cb59\r\n9. ./contrib/llvm-project/libcxx/include/vector:537: DB::ExpressionActions::execute(DB::Block&, bool, bool) const @ 0x000000001016e00e\r\n10. ./contrib/llvm-project/libcxx/include/vector:1457: COW<DB::IColumn>::immutable_ptr<DB::IColumn> DB::(anonymous namespace)::buildAdditionalFilter<DB::(anonymous namespace)::AddedColumns<true>>(unsigned long, std::vector<DB::RowRef, std::allocator<DB::RowRef>> const&, std::vector<unsigned long, std::allocator<unsigned long>> const&, DB::(anonymous namespace)::AddedColumns<true>&) @ 0x000000001052e791\r\n11. ./build_docker/./src/Interpreters/HashJoin.cpp:0: unsigned long DB::(anonymous namespace)::joinRightColumnsWithAddtitionalFilter<DB::ColumnsHashing::HashMethodOneNumber<PairNoInit<unsigned int, DB::RowRefList>, DB::RowRefList const, unsigned int, false, true, false>, HashMapTable<unsigned int, HashMapCell<unsigned int, DB::RowRefList, HashCRC32<unsigned int>, HashTableNoState, PairNoInit<unsigned int, DB::RowRefList>>, HashCRC32<unsigned int>, HashTableGrowerWithPrecalculation<8ul>, Allocator<true, true>>, true, DB::(anonymous namespace)::AddedColumns<true>>(std::vector<DB::ColumnsHashing::HashMethodOneNumber<PairNoInit<unsigned int, DB::RowRefList>, DB::RowRefList const, unsigned int, false, true, false>, std::allocator<DB::ColumnsHashing::HashMethodOneNumber<PairNoInit<unsigned int, DB::RowRefList>, DB::RowRefList const, unsigned int, false, true, false>>>&&, std::vector<HashMapTable<unsigned int, HashMapCell<unsigned int, DB::RowRefList, HashCRC32<unsigned int>, HashTableNoState, PairNoInit<unsigned int, DB::RowRefList>>, HashCRC32<unsigned int>, HashTableGrowerWithPrecalculation<8ul>, Allocator<true, true>> const*, std::allocator<HashMapTable<unsigned int, HashMapCell<unsigned int, DB::RowRefList, HashCRC32<unsigned int>, HashTableNoState, PairNoInit<unsigned int, DB::RowRefList>>, HashCRC32<unsigned int>, HashTableGrowerWithPrecalculation<8ul>, Allocator<true, true>> const*>> const&, DB::(anonymous namespace)::AddedColumns<true>&, DB::JoinStuff::JoinUsedFlags&, bool, bool, bool, bool) @ 0x000000001053b35e\r\n12. ./build_docker/./src/Interpreters/HashJoin.cpp:0: DB::Block DB::HashJoin::joinBlockImpl<(DB::JoinKind)1, (DB::JoinStrictness)3, DB::HashJoin::MapsTemplate<DB::RowRefList>>(DB::Block&, DB::Block const&, std::vector<DB::HashJoin::MapsTemplate<DB::RowRefList> const*, std::allocator<DB::HashJoin::MapsTemplate<DB::RowRefList> const*>> const&, bool) const @ 0x000000001052ad4c\r\n13. ./contrib/llvm-project/libcxx/include/vector:1429: _Z15static_for_implIiTnT_Li0EZN2DB12joinDispatchINSt3__17variantIJNS1_8HashJoin12MapsTemplateINS1_6RowRefEEENS6_INS1_10RowRefListEEENS6_INS3_10unique_ptrINS1_22SortedLookupVectorBaseENS3_14default_deleteISC_EEEEEEEEEZNS5_9joinBlockERNS1_5BlockERNS3_10shared_ptrINS1_10ExtraBlockEEEE3$_0EEbNS1_8JoinKindENS1_14JoinStrictnessERNS3_6vectorIPKS0_NS3_9allocatorIST_EEEEOT0_EUlS0_E_TpTnS0_JLi0ELi1ELi2ELi3ELi4ELi5ELi6ELi7ELi8ELi9ELi10ELi11ELi12ELi13ELi14ELi15ELi16ELi17ELi18ELi19ELi20ELi21ELi22ELi23EEEbOT1_NS3_16integer_sequenceIS0_JXspT2_EEEE @ 0x000000001050ac51\r\n14. ./build_docker/./src/Interpreters/HashJoin.cpp:2470: DB::HashJoin::joinBlock(DB::Block&, std::shared_ptr<DB::ExtraBlock>&) @ 0x00000000104c8a55\r\n15. ./build_docker/./src/Processors/Transforms/JoiningTransform.cpp:0: DB::JoiningTransform::work() @ 0x00000000121655a5\r\n16. ./build_docker/./src/Processors/Executors/ExecutionThreadContext.cpp:0: DB::ExecutionThreadContext::executeTask() @ 0x0000000011f111a7\r\n17. ./build_docker/./src/Processors/Executors/PipelineExecutor.cpp:272: DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000011f05a90\r\n18. ./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:701: DB::PipelineExecutor::execute(unsigned long, bool) @ 0x0000000011f04f22\r\n19. ./build_docker/./src/Processors/Executors/PullingAsyncPipelineExecutor.cpp:0: void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<true, true>::ThreadFromGlobalPoolImpl<DB::PullingAsyncPipelineExecutor::pull(DB::Chunk&, unsigned long)::$_0>(DB::PullingAsyncPipelineExecutor::pull(DB::Chunk&, unsigned long)::$_0&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x0000000011f14cca\r\n20. ./base/base/../base/wide_integer_impl.h:817: void* std::__thread_proxy[abi:v15000]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000c676f83\r\n21. ? @ 0x00007e4230e94ac3\r\n22. ? @ 0x00007e4230f26850\r\n\r\nReceived exception from server (version 24.5.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Not-ready Set is passed as the second argument for function 'in': while executing 'FUNCTION in(__table2.a :: 1, __set_18088566730452824076_8550654433943010493 :: 0) -> in(__table2.a, __set_18088566730452824076_8550654433943010493) UInt8 : 4': While executing JoiningTransform. (LOGICAL_ERROR)\r\n(query: -- This query is not\r\nSELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON t1.key = t2.key AND (t1.a=2 OR (t2.a IN (SELECT a FROM t1 WHERE a = 10))) ORDER BY t1.key, t2.key;)\r\n```\r\n\r\nVersion 24.6.1.2120\r\n\n",
  "hints_text": "cc @lgbo-ustc",
  "created_at": "2024-06-04T03:14:43Z"
}