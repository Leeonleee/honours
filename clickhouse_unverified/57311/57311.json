{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57311,
  "instance_id": "ClickHouse__ClickHouse-57311",
  "issue_numbers": [
    "15206"
  ],
  "base_commit": "b9b94a8e0afe7993e7efda332e7eccb9725c4333",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 5000d2d3e02a..14cd4f8de609 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -575,7 +575,6 @@ class IColumn;\n     M(Bool, optimize_substitute_columns, false, \"Use constraints for column substitution\", 0)                                                                                                                                         \\\n     M(Bool, optimize_append_index, false, \"Use constraints in order to append index condition (indexHint)\", 0) \\\n     M(Bool, normalize_function_names, true, \"Normalize function names to their canonical names\", 0) \\\n-    M(Bool, allow_experimental_alter_materialized_view_structure, false, \"Allow atomic alter on Materialized views. Work in progress.\", 0) \\\n     M(Bool, enable_early_constant_folding, true, \"Enable query optimization where we analyze function and subqueries results and rewrite query if there're constants there\", 0) \\\n     M(Bool, deduplicate_blocks_in_dependent_materialized_views, false, \"Should deduplicate blocks for materialized views if the block is not a duplicate for the table. Use true to always deduplicate in dependent tables.\", 0) \\\n     M(Bool, materialized_views_ignore_errors, false, \"Allows to ignore errors for MATERIALIZED VIEW, and deliver original block to the table regardless of MVs\", 0) \\\n@@ -856,6 +855,7 @@ class IColumn;\n     MAKE_OBSOLETE(M, Bool, allow_experimental_window_functions, true) \\\n     MAKE_OBSOLETE(M, Bool, allow_experimental_geo_types, true) \\\n     MAKE_OBSOLETE(M, Bool, allow_experimental_query_cache, true) \\\n+    MAKE_OBSOLETE(M, Bool, allow_experimental_alter_materialized_view_structure, true) \\\n     \\\n     MAKE_OBSOLETE(M, Milliseconds, async_insert_stale_timeout_ms, 0) \\\n     MAKE_OBSOLETE(M, StreamingHandleErrorMode, handle_kafka_error_mode, StreamingHandleErrorMode::DEFAULT) \\\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 7d6f7a489e31..8227df3b0fc1 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -15,6 +15,8 @@\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/RenameColumnVisitor.h>\n #include <Interpreters/GinFilter.h>\n+#include <Interpreters/InterpreterSelectWithUnionQuery.h>\n+#include <Interpreters/InterpreterSelectQueryAnalyzer.h>\n #include <Parsers/ASTAlterQuery.h>\n #include <Parsers/ASTColumnDeclaration.h>\n #include <Parsers/ASTConstraintDeclaration.h>\n@@ -712,6 +714,21 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)\n     else if (type == MODIFY_QUERY)\n     {\n         metadata.select = SelectQueryDescription::getSelectQueryFromASTForMatView(select, context);\n+        Block as_select_sample;\n+\n+        if (context->getSettingsRef().allow_experimental_analyzer)\n+        {\n+            as_select_sample = InterpreterSelectQueryAnalyzer::getSampleBlock(select->clone(), context);\n+        }\n+        else\n+        {\n+            as_select_sample = InterpreterSelectWithUnionQuery::getSampleBlock(select->clone(),\n+                context,\n+                false /* is_subquery */,\n+                false);\n+        }\n+\n+        metadata.columns = ColumnsDescription(as_select_sample.getNamesAndTypesList());\n     }\n     else if (type == MODIFY_SETTING)\n     {\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 97cfd5507690..a7e2f246cec6 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -282,13 +282,10 @@ void StorageMaterializedView::alter(\n     params.apply(new_metadata, local_context);\n \n     /// start modify query\n-    if (local_context->getSettingsRef().allow_experimental_alter_materialized_view_structure)\n-    {\n-        const auto & new_select = new_metadata.select;\n-        const auto & old_select = old_metadata.getSelectQuery();\n+    const auto & new_select = new_metadata.select;\n+    const auto & old_select = old_metadata.getSelectQuery();\n \n-        DatabaseCatalog::instance().updateViewDependency(old_select.select_table_id, table_id, new_select.select_table_id, table_id);\n-    }\n+    DatabaseCatalog::instance().updateViewDependency(old_select.select_table_id, table_id, new_select.select_table_id, table_id);\n     /// end modify query\n \n     DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n@@ -296,26 +293,13 @@ void StorageMaterializedView::alter(\n }\n \n \n-void StorageMaterializedView::checkAlterIsPossible(const AlterCommands & commands, ContextPtr local_context) const\n+void StorageMaterializedView::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /*local_context*/) const\n {\n-    const auto & settings = local_context->getSettingsRef();\n-    if (settings.allow_experimental_alter_materialized_view_structure)\n+    for (const auto & command : commands)\n     {\n-        for (const auto & command : commands)\n-        {\n-            if (!command.isCommentAlter() && command.type != AlterCommand::MODIFY_QUERY)\n-                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n-                    command.type, getName());\n-        }\n-    }\n-    else\n-    {\n-        for (const auto & command : commands)\n-        {\n-            if (!command.isCommentAlter())\n-                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n-                    command.type, getName());\n-        }\n+        if (!command.isCommentAlter() && command.type != AlterCommand::MODIFY_QUERY)\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n+                command.type, getName());\n     }\n }\n \n",
  "test_patch": "diff --git a/tests/integration/test_replicated_database/test.py b/tests/integration/test_replicated_database/test.py\nindex a591c93d264b..3ced82ebb57e 100644\n--- a/tests/integration/test_replicated_database/test.py\n+++ b/tests/integration/test_replicated_database/test.py\n@@ -799,7 +799,7 @@ def test_recover_staled_replica(started_cluster):\n             settings=settings,\n         )\n         main_node.query_with_retry(\n-            \"ALTER TABLE recover.mv1 MODIFY QUERY SELECT m FROM recover.rmt1\",\n+            \"ALTER TABLE recover.mv1 MODIFY QUERY SELECT m as n FROM recover.rmt1\",\n             settings=settings,\n         )\n         main_node.query_with_retry(\ndiff --git a/tests/queries/0_stateless/02888_obsolete_settings.reference b/tests/queries/0_stateless/02888_obsolete_settings.reference\nindex dbf781f183ff..0ef6404eabbc 100644\n--- a/tests/queries/0_stateless/02888_obsolete_settings.reference\n+++ b/tests/queries/0_stateless/02888_obsolete_settings.reference\n@@ -1,5 +1,6 @@\n -- Obsolete server settings\n -- Obsolete general settings\n+allow_experimental_alter_materialized_view_structure\n allow_experimental_bigint_types\n allow_experimental_database_atomic\n allow_experimental_geo_types\ndiff --git a/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.reference b/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.reference\nnew file mode 100644\nindex 000000000000..45e4b958f4b9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.reference\n@@ -0,0 +1,3 @@\n+v\tUInt64\t\t\t\t\t\n+v2\tUInt8\t\t\t\t\t\n+CREATE MATERIALIZED VIEW default.pipe TO default.dest\\n(\\n    `v` UInt64,\\n    `v2` UInt8\\n) AS\\nSELECT\\n    v * 2 AS v,\\n    1 AS v2\\nFROM default.src\ndiff --git a/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.sql b/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.sql\nnew file mode 100644\nindex 000000000000..895d5b3ab053\n--- /dev/null\n+++ b/tests/queries/0_stateless/02931_alter_materialized_view_query_inconsistent.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS pipe;\n+DROP TABLE IF EXISTS src;\n+DROP TABLE IF EXISTS dest;\n+\n+CREATE TABLE src(v UInt64) ENGINE = Null;\n+CREATE TABLE dest(v UInt64) Engine = MergeTree() ORDER BY v;\n+CREATE MATERIALIZED VIEW pipe TO dest AS SELECT v FROM src;\n+\n+ALTER TABLE dest ADD COLUMN v2 UInt64;\n+\n+ALTER TABLE pipe MODIFY QUERY SELECT v * 2 as v, 1 as v2 FROM src;\n+\n+DESCRIBE TABLE pipe;\n+SHOW CREATE TABLE pipe;\n+\n+DROP TABLE IF EXISTS pipe;\n+DROP TABLE IF EXISTS src;\n+DROP TABLE IF EXISTS dest;\n",
  "problem_statement": "ALTER MV MODIFY QUERY changes MV query but not columns list.\n```\r\nCREATE TABLE src(v UInt64) ENGINE = Null;\r\nCREATE TABLE dest(v UInt64) Engine = MergeTree() ORDER BY v;\r\nCREATE MATERIALIZED VIEW pipe TO dest AS SELECT v FROM src;\r\nALTER TABLE dest ADD COLUMN v2 UInt64;\r\n\r\nSET allow_experimental_alter_materialized_view_structure = 1;\r\n\r\nALTER TABLE pipe add column v2 Int64, MODIFY QUERY SELECT v * 2 as v, 1 as v2 FROM src;\r\n\r\nDESCRIBE TABLE pipe\r\n\r\n\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\r\n\u2502 v    \u2502 UInt64 \u2502              \u2502                    \u2502         \u2502                  \u2502                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nexpected 2 columns `v`, `v2`\r\n\r\nSHOW CREATE TABLE pipe\r\n\r\n\u250c\u2500statement\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CREATE MATERIALIZED VIEW dw.pipe TO dw.dest\r\n(\r\n    `v` UInt64\r\n) AS\r\nSELECT\r\n    v * 2 AS v,\r\n    1 AS v2\r\nFROM dw.src \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "CC @nvartolomei \nThe actual result is:\r\n\r\n```\r\nCode: 48. DB::Exception: Received from localhost:9000. DB::Exception: Alter of type 'ADD COLUMN' is not supported by storage MaterializedView.\r\n```\r\n\r\nThis is intended as the environment I did this for had some odd table structures that did not match what you could usually infer from the select statement and modifying table structure could end up with surprises. Instead we settled on using MV just as \"pipes\" connecting null tables to destination tables, and for reads read destination tables directly or create normal views (never seen them actually).\r\n\r\nFrom usability perspective all \"improvements\" i could think of had drawbacks. If I had to do it properly again I would probably introduce a new concept just called \"pipe\" from getting data from one table to another and forget about materialized views.\r\n\r\nLater add: Even if we allow explicit chaining of ADD/DROP/MODIFY COLUMN it is still not very clear if this would affect the MV or MV and underlying the table as some alters on MV are currently propagated to inner table.",
  "created_at": "2023-11-28T12:19:26Z"
}