{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 29155,
  "instance_id": "ClickHouse__ClickHouse-29155",
  "issue_numbers": [
    "18693"
  ],
  "base_commit": "a9e8ba0c00cd3e5024004c0ada823a1de9e85f1f",
  "patch": "diff --git a/programs/server/config.xml b/programs/server/config.xml\nindex f9a3a5030d94..35d86e70f690 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -62,6 +62,27 @@\n         -->\n     </logger>\n \n+    <!-- Add headers to response in options request. OPTIONS method is used in CORS preflight requests. -->\n+    <!-- It is off by default. Next headers are obligate for CORS.-->\n+    <!-- http_options_response>\n+        <header>\n+            <name>Access-Control-Allow-Origin</name>\n+            <value>*</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Allow-Headers</name>\n+            <value>origin, x-requested-with</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Allow-Methods</name>\n+            <value>POST, GET, OPTIONS</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Max-Age</name>\n+            <value>86400</value>\n+        </header>\n+    </http_options_response -->\n+\n     <!-- It is the name that will be shown in the clickhouse-client.\n          By default, anything with \"production\" will be highlighted in red in query prompt.\n     -->\ndiff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h\nindex 661497c88f5f..ed00de6e8034 100644\n--- a/src/Interpreters/ClientInfo.h\n+++ b/src/Interpreters/ClientInfo.h\n@@ -35,8 +35,9 @@ class ClientInfo\n     enum class HTTPMethod : uint8_t\n     {\n         UNKNOWN = 0,\n-        GET = 1,\n-        POST = 2,\n+        GET     = 1,\n+        POST    = 2,\n+        OPTIONS = 3\n     };\n \n     enum class QueryKind : uint8_t\ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex aefa1fe68e1b..b7e7ac2ac33a 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -24,13 +24,16 @@\n #include <Server/HTTPHandlerFactory.h>\n #include <Server/HTTPHandlerRequestFilter.h>\n #include <Server/IServer.h>\n+#include <base/logger_useful.h>\n #include <Common/SettingsChanges.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/escapeForFileName.h>\n #include <Common/setThreadName.h>\n #include <Common/typeid_cast.h>\n+\n #include <base/getFQDNOrHostName.h>\n #include <base/scope_guard.h>\n+#include <Server/HTTP/HTTPResponse.h>\n \n #if !defined(ARCADIA_BUILD)\n #    include <Common/config.h>\n@@ -107,6 +110,45 @@ namespace ErrorCodes\n     extern const int HTTP_LENGTH_REQUIRED;\n }\n \n+namespace\n+{\n+bool tryAddHeadersFromConfig(HTTPServerResponse & response, const Poco::Util::LayeredConfiguration & config)\n+{\n+    if (config.has(\"http_options_response\"))\n+    {\n+        Strings config_keys;\n+        config.keys(\"http_options_response\", config_keys);\n+        for (const std::string & config_key : config_keys)\n+        {\n+            if (config_key == \"header\" || config_key.starts_with(\"header[\"))\n+            {\n+                /// If there is empty header name, it will not be processed and message about it will be in logs\n+                if (config.getString(\"http_options_response.\" + config_key + \".name\", \"\").empty())\n+                    LOG_WARNING(&Poco::Logger::get(\"processOptionsRequest\"), \"Empty header was found in config. It will not be processed.\");\n+                else\n+                    response.add(config.getString(\"http_options_response.\" + config_key + \".name\", \"\"),\n+                                    config.getString(\"http_options_response.\" + config_key + \".value\", \"\"));\n+\n+            }\n+        }\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/// Process options request. Useful for CORS.\n+void processOptionsRequest(HTTPServerResponse & response, const Poco::Util::LayeredConfiguration & config)\n+{\n+    /// If can add some headers from config\n+    if (tryAddHeadersFromConfig(response, config))\n+    {\n+        response.setKeepAlive(false);\n+        response.setStatusAndReason(HTTPResponse::HTTP_NO_CONTENT);\n+        response.send();\n+    }\n+}\n+}\n+\n static String base64Decode(const String & encoded)\n {\n     String decoded;\n@@ -703,9 +745,16 @@ void HTTPHandler::processQuery(\n     if (in_post_compressed && settings.http_native_compression_disable_checksumming_on_decompress)\n         static_cast<CompressedReadBuffer &>(*in_post_maybe_compressed).disableChecksumming();\n \n-    /// Add CORS header if 'add_http_cors_header' setting is turned on and the client passed\n-    /// Origin header.\n-    used_output.out->addHeaderCORS(settings.add_http_cors_header && !request.get(\"Origin\", \"\").empty());\n+    /// Add CORS header if 'add_http_cors_header' setting is turned on send * in Access-Control-Allow-Origin,\n+    /// or if config has http_options_response, which means that there\n+    /// are some headers to be sent, and the client passed Origin header.\n+    if (!request.get(\"Origin\", \"\").empty())\n+    {\n+        if (config.has(\"http_options_response\"))\n+            tryAddHeadersFromConfig(response, config);\n+        else if (settings.add_http_cors_header)\n+            used_output.out->addHeaderCORS(true);\n+    }\n \n     auto append_callback = [context = context] (ProgressCallback callback)\n     {\n@@ -854,6 +903,11 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n \n     try\n     {\n+        if (request.getMethod() == HTTPServerRequest::HTTP_OPTIONS)\n+        {\n+            processOptionsRequest(response, server.config());\n+            return;\n+        }\n         response.setContentType(\"text/plain; charset=UTF-8\");\n         response.set(\"X-ClickHouse-Server-Display-Name\", server_display_name);\n         /// For keep-alive to work.\ndiff --git a/src/Server/HTTPHandlerFactory.cpp b/src/Server/HTTPHandlerFactory.cpp\nindex 62225e7e7944..526b86a5c28e 100644\n--- a/src/Server/HTTPHandlerFactory.cpp\n+++ b/src/Server/HTTPHandlerFactory.cpp\n@@ -123,7 +123,7 @@ static inline HTTPRequestHandlerFactoryPtr createInterserverHTTPHandlerFactory(I\n     addCommonDefaultHandlersFactory(*factory, server);\n \n     auto main_handler = std::make_shared<HandlingRuleHTTPHandlerFactory<InterserverIOHTTPHandler>>(server);\n-    main_handler->allowPostGetOrHeadRequest();\n+    main_handler->allowPostAndGetParamsAndOptionsRequest();\n     factory->addHandler(main_handler);\n \n     return factory;\n@@ -180,7 +180,7 @@ void addDefaultHandlersFactory(HTTPRequestHandlerFactoryMain & factory, IServer\n     addCommonDefaultHandlersFactory(factory, server);\n \n     auto query_handler = std::make_shared<HandlingRuleHTTPHandlerFactory<DynamicQueryHandler>>(server, \"query\");\n-    query_handler->allowPostGetOrHeadRequest();\n+    query_handler->allowPostAndGetParamsAndOptionsRequest();\n     factory.addHandler(query_handler);\n \n     /// We check that prometheus handler will be served on current (default) port.\ndiff --git a/src/Server/HTTPHandlerFactory.h b/src/Server/HTTPHandlerFactory.h\nindex ed5431113eff..ef16806dfdc2 100644\n--- a/src/Server/HTTPHandlerFactory.h\n+++ b/src/Server/HTTPHandlerFactory.h\n@@ -103,14 +103,15 @@ class HandlingRuleHTTPHandlerFactory : public HTTPRequestHandlerFactory\n         });\n     }\n \n-    /// Handle Post request or (Get or Head) requests with params\n-    void allowPostGetOrHeadRequest()\n+    /// Handle Post request or (Get or Head) with params or OPTIONS requests\n+    void allowPostAndGetParamsAndOptionsRequest()\n     {\n         addFilter([](const auto & request)\n         {\n             return (request.getURI().find('?') != std::string::npos\n                 && (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET\n                 || request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD))\n+                || request.getMethod() == Poco::Net::HTTPRequest::HTTP_OPTIONS\n                 || request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST;\n         });\n     }\n",
  "test_patch": "diff --git a/tests/config/config.d/CORS.xml b/tests/config/config.d/CORS.xml\nnew file mode 100644\nindex 000000000000..b96209866a73\n--- /dev/null\n+++ b/tests/config/config.d/CORS.xml\n@@ -0,0 +1,20 @@\n+<clickhouse>\n+    <http_options_response>\n+        <header>\n+            <name>Access-Control-Allow-Origin</name>\n+            <value>*</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Allow-Headers</name>\n+            <value>origin, x-requested-with</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Allow-Methods</name>\n+            <value>POST, GET, OPTIONS</value>\n+        </header>\n+        <header>\n+            <name>Access-Control-Max-Age</name>\n+            <value>86400</value>\n+        </header>\n+    </http_options_response>\n+</clickhouse>\ndiff --git a/tests/config/install.sh b/tests/config/install.sh\nindex 05db883c6916..94ad55504a82 100755\n--- a/tests/config/install.sh\n+++ b/tests/config/install.sh\n@@ -37,6 +37,7 @@ ln -sf $SRC_PATH/config.d/tcp_with_proxy.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/top_level_domains_lists.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/top_level_domains_path.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/encryption.xml $DEST_SERVER_PATH/config.d/\n+ln -sf $SRC_PATH/config.d/CORS.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/zookeeper_log.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/config.d/logger.xml $DEST_SERVER_PATH/config.d/\n ln -sf $SRC_PATH/users.d/log_queries.xml $DEST_SERVER_PATH/users.d/\ndiff --git a/tests/queries/0_stateless/00372_cors_header.reference b/tests/queries/0_stateless/00372_cors_header.reference\nindex e22493782f08..2f1465d1598d 100644\n--- a/tests/queries/0_stateless/00372_cors_header.reference\n+++ b/tests/queries/0_stateless/00372_cors_header.reference\n@@ -1,3 +1,3 @@\n 1\n-0\n+1\n 0\ndiff --git a/tests/queries/0_stateless/02029_test_options_requests.reference b/tests/queries/0_stateless/02029_test_options_requests.reference\nnew file mode 100644\nindex 000000000000..8b001eacbe30\n--- /dev/null\n+++ b/tests/queries/0_stateless/02029_test_options_requests.reference\n@@ -0,0 +1,5 @@\n+< HTTP/1.1 204 No Content\r\n+< Access-Control-Allow-Origin: *\r\n+< Access-Control-Allow-Headers: origin, x-requested-with\r\n+< Access-Control-Allow-Methods: POST, GET, OPTIONS\r\n+< Access-Control-Max-Age: 86400\r\ndiff --git a/tests/queries/0_stateless/02029_test_options_requests.sh b/tests/queries/0_stateless/02029_test_options_requests.sh\nnew file mode 100755\nindex 000000000000..8ea09e3ffe68\n--- /dev/null\n+++ b/tests/queries/0_stateless/02029_test_options_requests.sh\n@@ -0,0 +1,8 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# grep all fields, that should be set for CORS support (see CORS.xml)\n+$CLICKHOUSE_CURL \"${CLICKHOUSE_URL}\" -X OPTIONS -vs 2>&1 | grep -E \"HTTP/1.1 204 No Content|Access-Control-Allow-Origin|Access-Control-Allow-Headers|Access-Control-Allow-Methods|Access-Control-Max-Age\"\n",
  "problem_statement": "Support CORS fully with pre-flight requests using HTTP OPTIONS and server-side config for CORS\n**Use case**\r\nClickHouse cannot accept connections from web browser-based query tools that implement [CORS protocol preflight requests](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request).  The reason is preflight checks use an OPTIONS request, which ClickHouse does not implement in the HTTP interface. \r\n\r\nThe problem occurs in tools like Grafana and [ObservableHQ](https://observablehq.com), whenever (a) ClickHouse is on a different server from the web page source and (b) the call to ClickHouse is processed directly in the browser. This use case occurs commonly when integrating ClickHouse cloud implementations with SaaS-based BI tools. In each case the browser will do the following: \r\n\r\n1. Send an OPTIONS request to check if ClickHouse allows cross-site requests.  The browser expects to see an Access-Control-Allow-Origin header that whitelists the original site and a 200 status code.  \r\n2. Once the OPTIONS request returns successfully, send the actual request. \r\n\r\nWhen Grafana tries to do this it fails with the following message in the browser console. ObservableHQ fails similarly. \r\n\r\n```\r\nAccess to fetch at 'https://github.demo.trial.altinity.cloud:8443/?add_http_cors_header=1' from origin 'http://localhost:3000' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\r\n```\r\nIn the case of Grafana you can work-around CORS problems by running the ClickHouse queries on the Grafana server (set Access to 'Server' in the Datasource definition).  For ObservableHQ this is a blocking bug.  \r\n\r\nThere is another problem in that the current add_http_cors_header=1 option used to allow ClickHouse to return a Access-Control-Allow-Origin header makes client URLs more cumbersome. There's also a security issue in that CORS should be enabled by the server, not triggered by the client. Malicious sites can undo CORS protection by changing the URL. \r\n\r\n**Describe the solution you'd like**\r\nClickHouse should implement [server-side CORS support](https://enable-cors.org/server.html) fully, which includes the following: \r\n\r\n1. Implement OPTIONS requests for CORS preflight checks.  The expected behavior is shown in the referenced page above and illustrated in the attached Python3 script showing a typical OPTIONS request for pre-flight checks. Note that you can run a preflight request without authenticating. \r\n2. Make CORS support a server-side setting.  It would make sense to enable cors using a regex with '*' to designate accept all sites.  CORS should be off by default. \r\n3. Deprecate the add_http_cors_header=1 URL option as soon as possible. \r\n\r\n**Describe alternatives you've considered**\r\nAn alternative option is to enable CORS using a proxy, but this seems cumbersome and hard for developers.  If ClickHouse supports HTTP it should do it completely, including CORS. \r\n\r\n**Additional context**\r\nAs noted above this is a much more prominent problem with ClickHouse cloud platforms. \n",
  "hints_text": "Sample script showing typical OPTIONS request for CORS preflight check. \r\n[options-request.py.txt](https://github.com/ClickHouse/ClickHouse/files/5761362/options-request.py.txt)\r\n\nYep, it seems preflight CORS just hangs waiting to request body\r\n\r\nThat hangs:\r\n```\r\ncurl --verbose -X OPTIONS -H \"Access-Control-Request-Method: GET\" -H \"Origin: http://localhost\" 'http://localhost:8123/?add_http_cors_header=1&query=SELECT%20*%20FROM%20numbers(10)'\r\n*   Trying 127.0.0.1:8123...\r\n* TCP_NODELAY set\r\n* Connected to localhost (127.0.0.1) port 8123 (#0)\r\n> OPTIONS /?add_http_cors_header=1&query=SELECT%20*%20FROM%20numbers(10) HTTP/1.1\r\n> Host: localhost:8123\r\n> User-Agent: curl/7.68.0\r\n> Accept: */*\r\n> Access-Control-Request-Method: GET\r\n> Origin: http://localhost\r\n> \r\n^C\r\n```\r\n\r\n\r\nThat returns data (which is also wrong):\r\n\r\n```\r\necho '' | curl --verbose -X OPTIONS -H \"Access-Control-Request-Method: GET\" -H \"Origin: http://localhost\" 'http://localhost:8123/?add_http_cors_header=1&query=SELECT%20*%20FROM%20numbers(10)' --data-binary @-\r\n*   Trying 127.0.0.1:8123...\r\n* TCP_NODELAY set\r\n* Connected to localhost (127.0.0.1) port 8123 (#0)\r\n> OPTIONS /?add_http_cors_header=1&query=SELECT%20*%20FROM%20numbers(10) HTTP/1.1\r\n> Host: localhost:8123\r\n> User-Agent: curl/7.68.0\r\n> Accept: */*\r\n> Access-Control-Request-Method: GET\r\n> Origin: http://localhost\r\n> Content-Length: 1\r\n> Content-Type: application/x-www-form-urlencoded\r\n> \r\n* upload completely sent off: 1 out of 1 bytes\r\n* Mark bundle as not supporting multiuse\r\n< HTTP/1.1 200 OK\r\n< Date: Mon, 04 Jan 2021 15:58:40 GMT\r\n< Connection: Keep-Alive\r\n< Content-Type: text/tab-separated-values; charset=UTF-8\r\n< X-ClickHouse-Server-Display-Name: laptop-5591\r\n< Transfer-Encoding: chunked\r\n< X-ClickHouse-Query-Id: b9c1e486-414c-4217-9c05-ba2ae19fd50d\r\n< X-ClickHouse-Format: TabSeparated\r\n< X-ClickHouse-Timezone: Europe/Warsaw\r\n< Access-Control-Allow-Origin: *\r\n< Keep-Alive: timeout=3\r\n< X-ClickHouse-Summary: {\"read_rows\":\"0\",\"read_bytes\":\"0\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"0\"}\r\n< \r\n0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n* Connection #0 to host localhost left intact\r\n```\r\n\nYep, that's the behavior I get as well for curl. Internally it seems ClickHouse might be treating OPTIONS as a POST and trying to read the body. The behavior actually depends on how the client forms the request. In the Python sample it just fails. \r\n\r\nI've implemented CORS previously in Java.  It's not hard.  I might try doing the PR on this one myself.  \nBump. Still relevant.\nMaybe implement it like this. Add a section in config.xml like this:\r\n\r\n```\r\n<http_options_response>\r\n    <header>\r\n        <name>Access-Control-Allow-Origin</name>\r\n        <value>*</value>\r\n    </header>\r\n</http_options_response>\r\n```\r\n\r\nThe server will simply output the HTTP 204 response for OPTION request with this set of headers.",
  "created_at": "2021-09-18T09:38:11Z",
  "modified_files": [
    "programs/server/config.xml",
    "src/Interpreters/ClientInfo.h",
    "src/Server/HTTPHandler.cpp",
    "src/Server/HTTPHandlerFactory.cpp",
    "src/Server/HTTPHandlerFactory.h"
  ],
  "modified_test_files": [
    "b/tests/config/config.d/CORS.xml",
    "tests/config/install.sh",
    "tests/queries/0_stateless/00372_cors_header.reference",
    "b/tests/queries/0_stateless/02029_test_options_requests.reference",
    "b/tests/queries/0_stateless/02029_test_options_requests.sh"
  ]
}