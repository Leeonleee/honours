{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10099,
  "instance_id": "ClickHouse__ClickHouse-10099",
  "issue_numbers": [
    "9826"
  ],
  "base_commit": "aadb05cbe31418dfd52603957489a8f7316b5290",
  "patch": "diff --git a/src/Processors/Executors/PipelineExecutor.cpp b/src/Processors/Executors/PipelineExecutor.cpp\nindex 9108f5ac2a1f..f2d2477991e3 100644\n--- a/src/Processors/Executors/PipelineExecutor.cpp\n+++ b/src/Processors/Executors/PipelineExecutor.cpp\n@@ -96,7 +96,7 @@ bool PipelineExecutor::addEdges(UInt64 node)\n         {\n             const IProcessor * proc = &it->getOutputPort().getProcessor();\n             auto output_port_number = proc->getOutputPortNumber(&it->getOutputPort());\n-            add_edge(*it, proc, graph[node].backEdges, true, from_input, output_port_number, &graph[node].post_updated_input_ports);\n+            add_edge(*it, proc, graph[node].backEdges, true, from_input, output_port_number, graph[node].post_updated_input_ports.get());\n         }\n     }\n \n@@ -111,7 +111,7 @@ bool PipelineExecutor::addEdges(UInt64 node)\n         {\n             const IProcessor * proc = &it->getInputPort().getProcessor();\n             auto input_port_number = proc->getInputPortNumber(&it->getInputPort());\n-            add_edge(*it, proc, graph[node].directEdges, false, input_port_number, from_output, &graph[node].post_updated_output_ports);\n+            add_edge(*it, proc, graph[node].directEdges, false, input_port_number, from_output, graph[node].post_updated_output_ports.get());\n         }\n     }\n \n@@ -221,7 +221,7 @@ bool PipelineExecutor::expandPipeline(Stack & stack, UInt64 pid)\n \n         if (addEdges(node))\n         {\n-            std::lock_guard guard(graph[node].status_mutex);\n+            std::lock_guard guard(*graph[node].status_mutex);\n \n             for (; num_back_edges < graph[node].backEdges.size(); ++num_back_edges)\n                 graph[node].updated_input_ports.emplace_back(num_back_edges);\n@@ -246,7 +246,7 @@ bool PipelineExecutor::tryAddProcessorToStackIfUpdated(Edge & edge, Queue & queu\n \n     auto & node = graph[edge.to];\n \n-    std::unique_lock lock(node.status_mutex);\n+    std::unique_lock lock(*node.status_mutex);\n \n     ExecStatus status = node.status;\n \n@@ -340,22 +340,22 @@ bool PipelineExecutor::prepareProcessor(UInt64 pid, size_t thread_number, Queue\n         }\n \n         {\n-            for (auto & edge_id : node.post_updated_input_ports)\n+            for (auto & edge_id : *node.post_updated_input_ports)\n             {\n                 auto edge = static_cast<Edge *>(edge_id);\n                 updated_back_edges.emplace_back(edge);\n                 edge->update_info.trigger();\n             }\n \n-            for (auto & edge_id : node.post_updated_output_ports)\n+            for (auto & edge_id : *node.post_updated_output_ports)\n             {\n                 auto edge = static_cast<Edge *>(edge_id);\n                 updated_direct_edges.emplace_back(edge);\n                 edge->update_info.trigger();\n             }\n \n-            node.post_updated_input_ports.clear();\n-            node.post_updated_output_ports.clear();\n+            node.post_updated_input_ports->clear();\n+            node.post_updated_output_ports->clear();\n         }\n     }\n \n@@ -402,7 +402,7 @@ bool PipelineExecutor::prepareProcessor(UInt64 pid, size_t thread_number, Queue\n         while (!stack.empty())\n         {\n             auto item = stack.top();\n-            if (!prepareProcessor(item, thread_number, queue, std::unique_lock<std::mutex>(graph[item].status_mutex)))\n+            if (!prepareProcessor(item, thread_number, queue, std::unique_lock<std::mutex>(*graph[item].status_mutex)))\n                 return false;\n \n             stack.pop();\n@@ -519,7 +519,7 @@ void PipelineExecutor::executeSingleThread(size_t thread_num, size_t num_threads\n \n     auto prepare_processor = [&](UInt64 pid, Queue & queue)\n     {\n-        if (!prepareProcessor(pid, thread_num, queue, std::unique_lock<std::mutex>(graph[pid].status_mutex)))\n+        if (!prepareProcessor(pid, thread_num, queue, std::unique_lock<std::mutex>(*graph[pid].status_mutex)))\n             finish();\n     };\n \n@@ -729,7 +729,7 @@ void PipelineExecutor::executeImpl(size_t num_threads)\n             UInt64 proc = stack.top();\n             stack.pop();\n \n-            prepareProcessor(proc, 0, queue, std::unique_lock<std::mutex>(graph[proc].status_mutex));\n+            prepareProcessor(proc, 0, queue, std::unique_lock<std::mutex>(*graph[proc].status_mutex));\n \n             while (!queue.empty())\n             {\ndiff --git a/src/Processors/Executors/PipelineExecutor.h b/src/Processors/Executors/PipelineExecutor.h\nindex 673151bd5eb9..c0ce9053e5aa 100644\n--- a/src/Processors/Executors/PipelineExecutor.h\n+++ b/src/Processors/Executors/PipelineExecutor.h\n@@ -104,10 +104,10 @@ class PipelineExecutor\n         Edges backEdges;\n \n         ExecStatus status;\n-        std::mutex status_mutex;\n+        std::unique_ptr<std::mutex> status_mutex;\n \n-        std::vector<void *> post_updated_input_ports;\n-        std::vector<void *> post_updated_output_ports;\n+        std::unique_ptr<Port::UpdateInfo::UpdateList> post_updated_input_ports;\n+        std::unique_ptr<Port::UpdateInfo::UpdateList> post_updated_output_ports;\n \n         /// Last state for profiling.\n         IProcessor::Status last_processor_status = IProcessor::Status::NeedData;\n@@ -124,12 +124,10 @@ class PipelineExecutor\n             execution_state->processor = processor;\n             execution_state->processors_id = processor_id;\n             execution_state->has_quota = processor->hasQuota();\n-        }\n \n-        Node(Node && other) noexcept\n-            : processor(other.processor), status(other.status)\n-            , execution_state(std::move(other.execution_state))\n-        {\n+            status_mutex = std::make_unique<std::mutex>();\n+            post_updated_input_ports = std::make_unique<Port::UpdateInfo::UpdateList>();\n+            post_updated_output_ports = std::make_unique<Port::UpdateInfo::UpdateList>();\n         }\n     };\n \ndiff --git a/src/Processors/Port.h b/src/Processors/Port.h\nindex e200b8c1ecbb..63fef27e81a0 100644\n--- a/src/Processors/Port.h\n+++ b/src/Processors/Port.h\n@@ -30,7 +30,9 @@ class Port\n public:\n     struct UpdateInfo\n     {\n-        std::vector<void *> * update_list = nullptr;\n+        using UpdateList = std::vector<void *>;\n+\n+        UpdateList * update_list = nullptr;\n         void * id = nullptr;\n         UInt64 version = 0;\n         UInt64 prev_version = 0;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01232_preparing_sets_race_condition.reference b/tests/queries/0_stateless/01232_preparing_sets_race_condition.reference\nnew file mode 100644\nindex 000000000000..2fc36ed5c975\n--- /dev/null\n+++ b/tests/queries/0_stateless/01232_preparing_sets_race_condition.reference\n@@ -0,0 +1,10 @@\n+8\n+8\n+8\n+8\n+8\n+8\n+8\n+8\n+8\n+8\ndiff --git a/tests/queries/0_stateless/01232_preparing_sets_race_condition.sh b/tests/queries/0_stateless/01232_preparing_sets_race_condition.sh\nnew file mode 100755\nindex 000000000000..5f7b76c0e992\n--- /dev/null\n+++ b/tests/queries/0_stateless/01232_preparing_sets_race_condition.sh\n@@ -0,0 +1,117 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+set -o errexit\n+set -o pipefail\n+\n+\n+echo \"\n+    DROP TABLE if exists tableA;\n+    DROP TABLE if exists tableB;\n+\n+    create table tableA (id UInt64, col1 UInt64, colDate Date) engine = ReplacingMergeTree(colDate, id, 8192);\n+    create table tableB (id UInt64, Aid UInt64, colDate Date) engine = ReplacingMergeTree(colDate, id, 8192);\n+\n+    insert into tableA select number, number % 10, addDays(toDate('2020-01-01'), - number % 1000) from numbers(100000);\n+    insert into tableB select number, number % 100000, addDays(toDate('2020-01-01'), number % 90) from numbers(50000000);\n+\" | $CLICKHOUSE_CLIENT -n\n+\n+for i in {1..10}; do echo \"\n+SELECT tableName\n+FROM \n+    (\n+        SELECT \n+            col1, \n+            'T1_notJoin1' AS tableName, \n+            count(*) AS c\n+        FROM tableA\n+        GROUP BY col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T2_filteredAfterJoin1' AS tableName, \n+            count(*) AS c\n+        FROM tableB AS b\n+        INNER JOIN tableA AS a ON a.id = b.Aid\n+        WHERE b.colDate = '2020-01-01'\n+        GROUP BY a.col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T3_filteredAfterJoin2' AS tableName, \n+            count(*) AS c\n+        FROM tableB AS b\n+            INNER JOIN\n+            tableA AS a\n+            ON a.id = b.Aid\n+        WHERE b.colDate = '2020-01-02'\n+        GROUP BY a.col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T4_filteredBeforeJoin1' AS tableName, \n+            count(*) AS c\n+        FROM tableA AS a\n+        INNER JOIN \n+        (\n+            SELECT \n+                Aid\n+            FROM tableB\n+            WHERE colDate = '2020-01-01'\n+        ) AS b ON a.id = b.Aid\n+        GROUP BY a.col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T5_filteredBeforeJoin2' AS tableName, \n+            count(*) AS c\n+        FROM tableA AS a\n+        INNER JOIN \n+        (\n+            SELECT \n+                Aid\n+            FROM tableB\n+            WHERE colDate = '2020-01-02'\n+        ) AS b ON a.id = b.Aid\n+        GROUP BY a.col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T6_filteredAfterJoin3' AS tableName, \n+            count(*) AS c\n+        FROM tableB AS b\n+        INNER JOIN tableA AS a ON a.id = b.Aid\n+        WHERE b.colDate = '2020-01-03'\n+        GROUP BY a.col1\n+        UNION ALL\n+        SELECT \n+            col1, \n+            'T7_notJoin2' AS tableName, \n+            count(*) AS c\n+        FROM tableA\n+        GROUP BY col1\n+        UNION ALL\n+        SELECT \n+            a.col1, \n+            'T8_filteredBeforeJoin3' AS tableName, \n+            count(*) AS c\n+        FROM tableA AS a\n+        INNER JOIN \n+        (\n+            SELECT \n+                Aid\n+            FROM tableB\n+            WHERE colDate = '2020-01-03'\n+        ) AS b ON a.id = b.Aid\n+        GROUP BY a.col1\n+    ) AS a\n+GROUP BY tableName\n+ORDER BY tableName ASC;\n+\" | $CLICKHOUSE_CLIENT -n | wc -l ; done;\n+\n+echo \"\n+    DROP TABLE tableA;\n+    DROP TABLE tableB;\n+\" | $CLICKHOUSE_CLIENT -n\n",
  "problem_statement": "Different results are returned at every execution by executing same query which contains several UNIONs and JOINs in version 20.3.3.\n#### Overview\r\nDifferent results are returned as result of executing the same query which commands joining several tables and union each tables. \r\n\r\nSometimes results of executing the query lacking some joined tables.\r\n\r\nWhen I execute it several times, joined tables which are heavier and/or in latter position of query are lacked in more trial.\r\n\r\nIt seems that a bug occurs on executing parallel processing, and it maybe union executing before fetching all intermediate tables.\r\n\r\nThis occurs on clickhouse version20.3.3.\r\n\r\n#### How to Reproduce\r\n\r\nI execute below query.\r\nThis query is **expected returning 8 tableNames**, but it returns **different number of tableNames at every execution**.\r\n\r\n#### Executing Query\r\n```\r\nSELECT\r\n    tableName\r\nFROM\r\n    (\r\n    queryNotJoin('T1_notJoin1')    \r\n    union ALL\r\n    queryFilteredAfterJoin('T2_filteredAfterJoin1', '2020-01-01')\r\n    union ALL\r\n    queryFilteredAfterJoin('T3_filteredAfterJoin2', '2020-01-02')\r\n    union ALL\r\n    queryFilteredBeforeJoin('T4_filteredBeforeJoin1', '2020-01-01')\r\n    union ALL\r\n    queryFilteredBeforeJoin('T5_filteredBeforeJoin2', '2020-01-02')\r\n    union all\r\n    queryFilteredAfterJoin('T6_filteredAfterJoin3', '2020-01-03')\r\n    union all\r\n    queryNotJoin('T7_notJoin2')\r\n    union ALL\r\n    queryFilteredBeforeJoin('T8_filteredBeforeJoin3', '2020-01-03')\r\n    ) as a\r\ngroup BY \r\n    tableName\r\norder BY\r\n    tableName\r\n\r\nIn above query, using below function-like table aliases to make it easier to read.\r\n\r\nqueryNotJoin(name)\r\n select\r\n     col1, \r\n     '{name}' as tableName,\r\n     count(*) as c\r\n from\r\n     tableA\r\n\r\nqueryFilteringAfterJoin(name, date)\r\n select\r\n     a.col1,\r\n     '{name}' as tableName,\r\n     count(*) as c\r\n from\r\n     tableB as b\r\n     inner JOIN\r\n     tableA as a\r\n     on a.id = b.Aid\r\n where\r\n     a.colDate = '{date}'\r\n group by\r\n     a.col1\r\n   \r\nqueryFilteringBeforeJoin(name, date)\r\n select\r\n     a.col1,\r\n     '{name}' as tableName,\r\n     count(*) as c\r\n from\r\n     tableB as b\r\n     inner JOIN\r\n     (select col1, id from tableA WHERE colDate = '{date}') as a\r\n     on a.id = b.Aid\r\n group by\r\n     a.col1\r\n\r\ntableA has  9.6G columns.\r\ntableB has 59.9K columns.\r\n```\r\n\r\n#### Testing and consideration\r\n\r\nI executed the query 100 times and counted values in tableName rows.\r\n\r\n```\r\n'T1_notJoin1'           : 100\r\n'T2_filteredAfterJoin1' :  59\r\n'T3_filteredAfterJoin2' :  47\r\n'T4_filteredBeforeJoin1': 100\r\n'T5_filteredBeforeJoin2':  95\r\n'T6_filteredAfterJoin3' :  11\r\n'T7_notJoin2'           : 100\r\n'T8_filteredBeforeJoin3' : 54\r\n```\r\n*When executing alone, queryNotJoin, queryFilteredBeforeJoin and queryFilteredAfterJoin are spent less time in this order. \r\n\r\n* Comparing same joined table query, result of in latter position of query result is more lacked.\r\n\r\n*  Comparing different joined table query, result of slower query is more lacked.\r\n\r\nI guess that this problem is  caused by that the UNION is executed without  waiting to done processes of fetching joined table.   \n",
  "hints_text": "@KochetovNicolai can you check it is not related to processors?\r\n\r\n@lu-yuki-matsumoto Can you check that it is reproducing even with `--experimental_use_processors 0` setting?\n@qoega \r\n\r\nI checked the query with `--experimental_use_processors 0` 20 times, Clickhouse returned 8 values in every execution.\r\nIt is **not reproducing with `--experimental_use_processors 0` setting.**\r\n\r\nThank you,\nHi @lu-yuki-matsumoto \r\nI am trying to reproduce this bug, but have not succeed so far.\r\n\r\nCould you please show me the whole query and `create table` statements?\r\nIf you could also send me table's data, it would be very helpful.\r\n\r\nOr, probably, find a smaller reproducible example (like, create some tables and insert toy data into them).\nThings I tried:\r\n```\r\ncreate table tableA (id UInt64, col1 UInt64, colDate Date) engine = MergeTree order by colDate;\r\ncreate table tableB (Aid UInt64) engine = MergeTree order by tuple();\r\n\r\ninsert into tableA select number, number % 10, '2020-01-01' from numbers(10000000);\r\ninsert into tableA select number, number % 100000, '2020-01-02' from numbers(10000000);\r\ninsert into tableA select number, number, '2020-01-03' from numbers(10000000);\r\n\r\ninsert into tableB select number * 2 from numbers(100000);\r\n\r\nset max_memory_usage = 40000000000;\r\n\r\nSELECT tableName\r\nFROM \r\n(\r\n    SELECT \r\n        col1, \r\n        'T1_notJoin1' AS tableName, \r\n        count(*) AS c\r\n    FROM tableA\r\n    GROUP BY col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T2_filteredAfterJoin1' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN tableA AS a ON a.id = b.Aid\r\n    WHERE a.colDate = '2020-01-01'\r\n    GROUP BY a.col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T3_filteredAfterJoin2' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN tableA AS a ON a.id = b.Aid\r\n    WHERE a.colDate = '2020-01-02'\r\n    GROUP BY a.col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T4_filteredBeforeJoin1' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN \r\n    (\r\n        SELECT \r\n            col1, \r\n            id\r\n        FROM tableA\r\n        WHERE colDate = '2020-01-01'\r\n    ) AS a ON a.id = b.Aid\r\n    GROUP BY a.col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T5_filteredBeforeJoin2' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN \r\n    (\r\n        SELECT \r\n            col1, \r\n            id\r\n        FROM tableA\r\n        WHERE colDate = '2020-01-02'\r\n    ) AS a ON a.id = b.Aid\r\n    GROUP BY a.col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T6_filteredAfterJoin3' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN tableA AS a ON a.id = b.Aid\r\n    WHERE a.colDate = '2020-01-03'\r\n    GROUP BY a.col1\r\n    UNION ALL\r\n    SELECT \r\n        col1, \r\n        'T7_notJoin2' AS tableName, \r\n        count(*) AS c\r\n    FROM tableA\r\n    GROUP BY col1\r\n    UNION ALL\r\n    SELECT \r\n        a.col1, \r\n        'T8_filteredBeforeJoin3' AS tableName, \r\n        count(*) AS c\r\n    FROM tableB AS b\r\n    INNER JOIN \r\n    (\r\n        SELECT \r\n            col1, \r\n            id\r\n        FROM tableA\r\n        WHERE colDate = '2020-01-03'\r\n    ) AS a ON a.id = b.Aid\r\n    GROUP BY a.col1\r\n) AS a\r\nGROUP BY tableName\r\nORDER BY tableName ASC\r\n\r\n\u250c\u2500tableName\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 T1_notJoin1            \u2502\r\n\u2502 T2_filteredAfterJoin1  \u2502\r\n\u2502 T3_filteredAfterJoin2  \u2502\r\n\u2502 T4_filteredBeforeJoin1 \u2502\r\n\u2502 T5_filteredBeforeJoin2 \u2502\r\n\u2502 T6_filteredAfterJoin3  \u2502\r\n\u2502 T7_notJoin2            \u2502\r\n\u2502 T8_filteredBeforeJoin3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nStill can't reproduce.\n@KochetovNicolai \r\n\r\nI'm sorry to be very late.\r\nIn our case, \r\n\r\n```\r\nCREATE TABLE tableB\r\n(`id` UInt64,\r\n `colA` UInt32,\r\n `colB` UInt32,\r\n `colC` Enum8(2 vals),\r\n `Aid` UInt32,\r\n `colD` Enum8(8 vals),\r\n `colE` UInt8,\r\n `colF` UInt8,\r\n `colG` UInt8,\r\n `colH` DateTime,\r\n `colDate` Date\r\n ) ENGINE = ReplacingMergeTree(colDate, id, 8192)\r\n \r\nCREATE TABLE tableA\r\n (`id` UInt32,\r\n  `colJ` UInt32,\r\n  `colK` String,\r\n  `colL` Enum8(11 vals),\r\n  `colM` Enum8(12 vals),\r\n  `colN` DateTime,\r\n  `colO` DateTime,\r\n  `colP` String,\r\n  `colQ` String,\r\n  `colR` Enum8(4 vals),\r\n  `colS` DateTime,\r\n  `colT` DateTime,\r\n  `colU` DateTime,\r\n  `colV` Date,\r\n  `colW` UInt32) ENGINE = ReplacingMergeTree(colV, id, 8192)\r\n\r\nmax_memory_usage = 100000000000;\r\nmax_memory_usage_for_all_queries =  130000000000;  \r\n```\n@lu-yuki-matsumoto thank you.\r\nIs the query I used (in my previous comment) the same as the your query?\r\n\r\nI still can't reproduce the issue on my artificial generated data.\r\nYou may help me to investigate this issue:\r\n* Try to reduce the query. Usually, most parts of the query can be removed, until you get a small query which returns incorrect result (at least sometimes)\r\n* Make completely reproducible example. Create empty tables, insert artificially generated data into them, and try to reproduce over it.\r\n* Or send your real data, if you can. (Only parts for affected period are needed. They should start from `202001` for your tables.)\r\n\r\nIt will help me a lot if you do anything of that.\n@KochetovNicolai \r\n\r\n I should apologize for you about mistake I made in my query.\r\nGroup column is in tableA.\r\n\r\nBelow query can reproduce only case of returning 7 values.\r\n(I have not find artificial data to reproduce cases of returning 4-6 values yet.)\r\n\r\n```\r\ncreate table tableA (id UInt64, col1 UInt64, colDate Date) engine = ReplacingMergeTree(colDate, id, 8192);\r\ncreate table tableB (id UInt64, Aid UInt64, colDate Date) engine = ReplacingMergeTree(colDate, id, 8192);\r\n\r\ninsert into tableA select number, number % 10, addDays(toDate('2020-01-01'), - number % 1000) from numbers(100000);\r\ninsert into tableB select number, number % 100000, addDays(toDate('2020-01-01'), number % 90) from numbers(50000000);\r\n\r\nSELECT tableName\r\nFROM \r\n    (\r\n        SELECT \r\n            col1, \r\n            'T1_notJoin1' AS tableName, \r\n            count(*) AS c\r\n        FROM tableA\r\n        GROUP BY col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T2_filteredAfterJoin1' AS tableName, \r\n            count(*) AS c\r\n        FROM tableB AS b\r\n        INNER JOIN tableA AS a ON a.id = b.Aid\r\n        WHERE b.colDate = '2020-01-01'\r\n        GROUP BY a.col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T3_filteredAfterJoin2' AS tableName, \r\n            count(*) AS c\r\n        FROM tableB AS b\r\n            INNER JOIN\r\n            tableA AS a\r\n            ON a.id = b.Aid\r\n        WHERE b.colDate = '2020-01-02'\r\n        GROUP BY a.col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T4_filteredBeforeJoin1' AS tableName, \r\n            count(*) AS c\r\n        FROM tableA AS a\r\n        INNER JOIN \r\n        (\r\n            SELECT \r\n                Aid\r\n            FROM tableB\r\n            WHERE colDate = '2020-01-01'\r\n        ) AS b ON a.id = b.Aid\r\n        GROUP BY a.col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T5_filteredBeforeJoin2' AS tableName, \r\n            count(*) AS c\r\n        FROM tableA AS a\r\n        INNER JOIN \r\n        (\r\n            SELECT \r\n                Aid\r\n            FROM tableB\r\n            WHERE colDate = '2020-01-02'\r\n        ) AS b ON a.id = b.Aid\r\n        GROUP BY a.col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T6_filteredAfterJoin3' AS tableName, \r\n            count(*) AS c\r\n        FROM tableB AS b\r\n        INNER JOIN tableA AS a ON a.id = b.Aid\r\n        WHERE b.colDate = '2020-01-03'\r\n        GROUP BY a.col1\r\n        UNION ALL\r\n        SELECT \r\n            col1, \r\n            'T7_notJoin2' AS tableName, \r\n            count(*) AS c\r\n        FROM tableA\r\n        GROUP BY col1\r\n        UNION ALL\r\n        SELECT \r\n            a.col1, \r\n            'T8_filteredBeforeJoin3' AS tableName, \r\n            count(*) AS c\r\n        FROM tableA AS a\r\n        INNER JOIN \r\n        (\r\n            SELECT \r\n                Aid\r\n            FROM tableB\r\n            WHERE colDate = '2020-01-03'\r\n        ) AS b ON a.id = b.Aid\r\n        GROUP BY a.col1\r\n    ) AS a\r\nGROUP BY tableName\r\nORDER BY tableName ASC;\r\n```\r\n\n@lu-yuki-matsumoto thank you so much!\r\nYour test perfectly reproduces the case you have described.",
  "created_at": "2020-04-07T18:28:27Z"
}