{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14646,
  "instance_id": "ClickHouse__ClickHouse-14646",
  "issue_numbers": [
    "13634"
  ],
  "base_commit": "87b3984d1776545fa3bd05ec23317d556ef4bcfd",
  "patch": "diff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 1090de556a09..55ab67d6214d 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -7,6 +7,7 @@\n #include <common/unaligned.h>\n #include <Core/Field.h>\n #include <Core/BigInt.h>\n+#include <Common/assert_cast.h>\n \n \n namespace DB\n@@ -130,7 +131,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n \n     void insertFrom(const IColumn & src, size_t n) override\n     {\n-        data.push_back(static_cast<const Self &>(src).getData()[n]);\n+        data.push_back(assert_cast<const Self &>(src).getData()[n]);\n     }\n \n     void insertData(const char * pos, size_t) override\n@@ -205,14 +206,14 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n     /// This method implemented in header because it could be possibly devirtualized.\n     int compareAt(size_t n, size_t m, const IColumn & rhs_, int nan_direction_hint) const override\n     {\n-        return CompareHelper<T>::compare(data[n], static_cast<const Self &>(rhs_).data[m], nan_direction_hint);\n+        return CompareHelper<T>::compare(data[n], assert_cast<const Self &>(rhs_).data[m], nan_direction_hint);\n     }\n \n     void compareColumn(const IColumn & rhs, size_t rhs_row_num,\n                        PaddedPODArray<UInt64> * row_indexes, PaddedPODArray<Int8> & compare_results,\n                        int direction, int nan_direction_hint) const override\n     {\n-        return this->template doCompareColumn<Self>(static_cast<const Self &>(rhs), rhs_row_num, row_indexes,\n+        return this->template doCompareColumn<Self>(assert_cast<const Self &>(rhs), rhs_row_num, row_indexes,\n                                                     compare_results, direction, nan_direction_hint);\n     }\n \ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex 20848bede323..584bed3f8c55 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -604,7 +604,6 @@ class FunctionIf : public FunctionIfBase</*null_is_false=*/false>\n         const ColumnUInt8 * cond_col, Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count)\n     {\n         /// Convert both columns to the common type (if needed).\n-\n         const ColumnWithTypeAndName & arg1 = block.getByPosition(arguments[1]);\n         const ColumnWithTypeAndName & arg2 = block.getByPosition(arguments[2]);\n \n@@ -765,10 +764,22 @@ class FunctionIf : public FunctionIfBase</*null_is_false=*/false>\n         return ColumnNullable::create(materialized, ColumnUInt8::create(column->size(), 0));\n     }\n \n-    static ColumnPtr getNestedColumn(const ColumnPtr & column)\n+    /// Return nested column recursively removing Nullable, examples:\n+    /// Nullable(size = 1, Int32(size = 1), UInt8(size = 1)) -> Int32(size = 1)\n+    /// Const(size = 0, Nullable(size = 1, Int32(size = 1), UInt8(size = 1))) ->\n+    /// Const(size = 0, Int32(size = 1))\n+    static ColumnPtr recursiveGetNestedColumnWithoutNullable(const ColumnPtr & column)\n     {\n         if (const auto * nullable = checkAndGetColumn<ColumnNullable>(*column))\n+        {\n+            /// Nullable cannot contain Nullable\n             return nullable->getNestedColumnPtr();\n+        }\n+        else if (const auto * column_const = checkAndGetColumn<ColumnConst>(*column))\n+        {\n+            /// Save Constant, but remove Nullable\n+            return ColumnConst::create(recursiveGetNestedColumnWithoutNullable(column_const->getDataColumnPtr()), column->size());\n+        }\n \n         return column;\n     }\n@@ -826,12 +837,12 @@ class FunctionIf : public FunctionIfBase</*null_is_false=*/false>\n             {\n                 arg_cond,\n                 {\n-                    getNestedColumn(arg_then.column),\n+                    recursiveGetNestedColumnWithoutNullable(arg_then.column),\n                     removeNullable(arg_then.type),\n                     \"\"\n                 },\n                 {\n-                    getNestedColumn(arg_else.column),\n+                    recursiveGetNestedColumnWithoutNullable(arg_else.column),\n                     removeNullable(arg_else.type),\n                     \"\"\n                 },\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01475_mutation_with_if.reference b/tests/queries/0_stateless/01475_mutation_with_if.reference\nnew file mode 100644\nindex 000000000000..2874a18147f7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01475_mutation_with_if.reference\n@@ -0,0 +1,1 @@\n+1\t150\ndiff --git a/tests/queries/0_stateless/01475_mutation_with_if.sql b/tests/queries/0_stateless/01475_mutation_with_if.sql\nnew file mode 100644\nindex 000000000000..6f0ef8924bec\n--- /dev/null\n+++ b/tests/queries/0_stateless/01475_mutation_with_if.sql\n@@ -0,0 +1,16 @@\n+DROP TABLE IF EXISTS mutation_table;\n+CREATE TABLE mutation_table (\n+    id int,\n+    price Nullable(Int32)\n+)\n+ENGINE = MergeTree()\n+PARTITION BY id\n+ORDER BY id;\n+\n+INSERT INTO mutation_table (id, price) VALUES (1, 100);\n+\n+ALTER TABLE mutation_table UPDATE price = 150 WHERE id = 1 SETTINGS mutations_sync = 2;\n+\n+SELECT * FROM mutation_table;\n+\n+DROP TABLE IF EXISTS mutation_table;\n",
  "problem_statement": "Updating a Nullable column to a value would sets another value if `where` is used\nUpdating a Nullable column value by using alter .... where ... causes to set another value!\r\n\r\nClickHouse version: 20.6.3.28\r\nEngine: MergeTree\r\nOS: Ubuntu 18.04.3 LTS\r\n\r\nSteps to reproduce:\r\n```sql\r\nCREATE TABLE table1(\r\n\tid int,\r\n\tprice Nullable(Int32)\r\n)\r\nENGINE = MergeTree()\r\nPARTITION BY id\r\nORDER BY (id);\r\nINSERT INTO table1 (id, price) VALUES (1, 100);\r\nALTER TABLE table1  update price = 150 where id=1;\r\nSELECT * FROM table1;\r\n```\r\nWe expect the price to be `150`, but it's `93148480`:\r\n\r\n```\r\n\u250c\u2500id\u2500\u252c\u2500\u2500\u2500\u2500price\u2500\u2510\r\n\u2502  1 \u2502 93148480 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nUsing `Decimal(9,2)` field instead of `Int32` would set the value  `932342.88` always. It seems there's a fixed value for each data type.\r\n\r\nIf we don't use such a `where` clause, it works correctly:\r\n```sql\r\nALTER TABLE db1.table1  update price = 150 where 1=1;\r\n\u250c\u2500id\u2500\u252c\u2500price\u2500\u2510\r\n\u2502  1 \u2502   150 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "`ClickHouse server version 20.5.3 revision 54435.`  is correct\nSame issue in 20.5.4.40",
  "created_at": "2020-09-09T16:49:00Z"
}