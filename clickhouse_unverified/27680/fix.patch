diff --git a/src/Common/FieldVisitorDump.cpp b/src/Common/FieldVisitorDump.cpp
index 5e767cf30c13..660677404ade 100644
--- a/src/Common/FieldVisitorDump.cpp
+++ b/src/Common/FieldVisitorDump.cpp
@@ -20,7 +20,7 @@ template <typename T>
 static inline void writeQuoted(const DecimalField<T> & x, WriteBuffer & buf)
 {
     writeChar('\'', buf);
-    writeText(x.getValue(), x.getScale(), buf);
+    writeText(x.getValue(), x.getScale(), buf, {});
     writeChar('\'', buf);
 }
 
diff --git a/src/Common/FieldVisitorToString.cpp b/src/Common/FieldVisitorToString.cpp
index 74dfc55e1db1..b8750d95e5e8 100644
--- a/src/Common/FieldVisitorToString.cpp
+++ b/src/Common/FieldVisitorToString.cpp
@@ -26,7 +26,7 @@ template <typename T>
 static inline void writeQuoted(const DecimalField<T> & x, WriteBuffer & buf)
 {
     writeChar('\'', buf);
-    writeText(x.getValue(), x.getScale(), buf);
+    writeText(x.getValue(), x.getScale(), buf, {});
     writeChar('\'', buf);
 }
 
diff --git a/src/Core/Field.cpp b/src/Core/Field.cpp
index b7b03951ac90..8739f56d9917 100644
--- a/src/Core/Field.cpp
+++ b/src/Core/Field.cpp
@@ -23,65 +23,99 @@ inline Field getBinaryValue(UInt8 type, ReadBuffer & buf)
 {
     switch (type)
     {
-        case Field::Types::Null: {
-            return DB::Field();
+        case Field::Types::Null:
+        {
+            return Field();
         }
-        case Field::Types::UInt64: {
+        case Field::Types::UInt64:
+        {
             UInt64 value;
-            DB::readVarUInt(value, buf);
+            readVarUInt(value, buf);
             return value;
         }
-        case Field::Types::UInt128: {
+        case Field::Types::UInt128:
+        {
             UInt128 value;
-            DB::readBinary(value, buf);
+            readBinary(value, buf);
+            return value;
+        }
+        case Field::Types::UInt256:
+        {
+            UInt256 value;
+            readBinary(value, buf);
             return value;
         }
-        case Field::Types::Int64: {
+        case Field::Types::UUID:
+        {
+            UUID value;
+            readBinary(value, buf);
+            return value;
+        }
+        case Field::Types::Int64:
+        {
             Int64 value;
-            DB::readVarInt(value, buf);
+            readVarInt(value, buf);
+            return value;
+        }
+        case Field::Types::Int128:
+        {
+            Int128 value;
+            readBinary(value, buf);
+            return value;
+        }
+        case Field::Types::Int256:
+        {
+            Int256 value;
+            readBinary(value, buf);
             return value;
         }
-        case Field::Types::Float64: {
+        case Field::Types::Float64:
+        {
             Float64 value;
-            DB::readFloatBinary(value, buf);
+            readFloatBinary(value, buf);
             return value;
         }
-        case Field::Types::String: {
+        case Field::Types::String:
+        {
             std::string value;
-            DB::readStringBinary(value, buf);
+            readStringBinary(value, buf);
             return value;
         }
-        case Field::Types::Array: {
+        case Field::Types::Array:
+        {
             Array value;
-            DB::readBinary(value, buf);
+            readBinary(value, buf);
             return value;
         }
-        case Field::Types::Tuple: {
+        case Field::Types::Tuple:
+        {
             Tuple value;
-            DB::readBinary(value, buf);
+            readBinary(value, buf);
             return value;
         }
-        case Field::Types::Map: {
+        case Field::Types::Map:
+        {
             Map value;
-            DB::readBinary(value, buf);
+            readBinary(value, buf);
             return value;
         }
-        case Field::Types::AggregateFunctionState: {
+        case Field::Types::AggregateFunctionState:
+        {
             AggregateFunctionStateData value;
-            DB::readStringBinary(value.name, buf);
-            DB::readStringBinary(value.data, buf);
+            readStringBinary(value.name, buf);
+            readStringBinary(value.data, buf);
             return value;
         }
     }
-    return DB::Field();
+    return Field();
 }
 
 void readBinary(Array & x, ReadBuffer & buf)
 {
     size_t size;
     UInt8 type;
-    DB::readBinary(type, buf);
-    DB::readBinary(size, buf);
+    readBinary(type, buf);
+    readBinary(size, buf);
 
     for (size_t index = 0; index < size; ++index)
         x.push_back(getBinaryValue(type, buf));
@@ -93,8 +127,8 @@ void writeBinary(const Array & x, WriteBuffer & buf)
     size_t size = x.size();
     if (size)
         type = x.front().getType();
-    DB::writeBinary(type, buf);
-    DB::writeBinary(size, buf);
+    writeBinary(type, buf);
+    writeBinary(size, buf);
 
     for (const auto & elem : x)
         Field::dispatch([&buf] (const auto & value) { FieldVisitorWriteBinary()(value, buf); }, elem);
@@ -102,19 +136,19 @@ void writeBinary(const Array & x, WriteBuffer & buf)
 
 void writeText(const Array & x, WriteBuffer & buf)
 {
-    DB::String res = applyVisitor(FieldVisitorToString(), DB::Field(x));
+    String res = applyVisitor(FieldVisitorToString(), Field(x));
     buf.write(res.data(), res.size());
 }
 
 void readBinary(Tuple & x, ReadBuffer & buf)
 {
     size_t size;
-    DB::readBinary(size, buf);
+    readBinary(size, buf);
 
     for (size_t index = 0; index < size; ++index)
     {
         UInt8 type;
-        DB::readBinary(type, buf);
+        readBinary(type, buf);
         x.push_back(getBinaryValue(type, buf));
     }
 }
@@ -122,30 +156,30 @@ void readBinary(Tuple & x, ReadBuffer & buf)
 void writeBinary(const Tuple & x, WriteBuffer & buf)
 {
     const size_t size = x.size();
-    DB::writeBinary(size, buf);
+    writeBinary(size, buf);
 
     for (const auto & elem : x)
     {
         const UInt8 type = elem.getType();
-        DB::writeBinary(type, buf);
+        writeBinary(type, buf);
         Field::dispatch([&buf] (const auto & value) { FieldVisitorWriteBinary()(value, buf); }, elem);
     }
 }
 
 void writeText(const Tuple & x, WriteBuffer & buf)
 {
-    writeFieldText(DB::Field(x), buf);
+    writeFieldText(Field(x), buf);
 }
 
 void readBinary(Map & x, ReadBuffer & buf)
 {
     size_t size;
-    DB::readBinary(size, buf);
+    readBinary(size, buf);
 
     for (size_t index = 0; index < size; ++index)
     {
         UInt8 type;
-        DB::readBinary(type, buf);
+        readBinary(type, buf);
         x.push_back(getBinaryValue(type, buf));
     }
 }
@@ -153,19 +187,19 @@ void readBinary(Map & x, ReadBuffer & buf)
 void writeBinary(const Map & x, WriteBuffer & buf)
 {
     const size_t size = x.size();
-    DB::writeBinary(size, buf);
+    writeBinary(size, buf);
 
     for (const auto & elem : x)
     {
         const UInt8 type = elem.getType();
-        DB::writeBinary(type, buf);
+        writeBinary(type, buf);
         Field::dispatch([&buf] (const auto & value) { FieldVisitorWriteBinary()(value, buf); }, elem);
     }
 }
 
 void writeText(const Map & x, WriteBuffer & buf)
 {
-    writeFieldText(DB::Field(x), buf);
+    writeFieldText(Field(x), buf);
 }
 
 template <typename T>
diff --git a/src/Core/Field.h b/src/Core/Field.h
index 744675d6e86f..0023497e970e 100644
--- a/src/Core/Field.h
+++ b/src/Core/Field.h
@@ -974,9 +974,9 @@ __attribute__ ((noreturn)) inline void writeText(const AggregateFunctionStateDat
 }
 
 template <typename T>
-inline void writeText(const DecimalField<T> & value, WriteBuffer & buf)
+inline void writeText(const DecimalField<T> & value, WriteBuffer & buf, bool trailing_zeros = false)
 {
-    writeText(value.getValue(), value.getScale(), buf);
+    writeText(value.getValue(), value.getScale(), buf, trailing_zeros);
 }
 
 template <typename T>
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 19f9f2a94c81..f2f0c946b82f 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -560,6 +560,7 @@ class IColumn;
     M(UInt64, output_format_avro_sync_interval, 16 * 1024, "Sync interval in bytes.", 0) \
     M(Bool, output_format_tsv_crlf_end_of_line, false, "If it is set true, end of line in TSV format will be \\r\
 instead of \
.", 0) \
     M(String, output_format_tsv_null_representation, "\\N", "Custom NULL representation in TSV format", 0) \
+    M(Bool, output_format_decimal_trailing_zeros, false, "Output trailing zeros when printing Decimal values. E.g. 1.230000 instead of 1.23.", 0) \
     \
     M(UInt64, input_format_allow_errors_num, 0, "Maximum absolute amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.", 0) \
     M(Float, input_format_allow_errors_ratio, 0, "Maximum relative amount of errors while reading text formats (like CSV, TSV). In case of error, if at least absolute or relative amount of errors is lower than corresponding value, will skip until next line and continue.", 0) \
diff --git a/src/DataTypes/Serializations/SerializationDecimal.cpp b/src/DataTypes/Serializations/SerializationDecimal.cpp
index e0073c80aca0..88c6d9709806 100644
--- a/src/DataTypes/Serializations/SerializationDecimal.cpp
+++ b/src/DataTypes/Serializations/SerializationDecimal.cpp
@@ -44,10 +44,10 @@ void SerializationDecimal<T>::readText(T & x, ReadBuffer & istr, UInt32 precisio
 }
 
 template <typename T>
-void SerializationDecimal<T>::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const
+void SerializationDecimal<T>::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
 {
     T value = assert_cast<const ColumnType &>(column).getData()[row_num];
-    writeText(value, this->scale, ostr);
+    writeText(value, this->scale, ostr, settings.decimal_trailing_zeros);
 }
 
 template <typename T>
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index 7b2aac78067b..95270cb304f3 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -81,6 +81,7 @@ FormatSettings getFormatSettings(ContextPtr context, const Settings & settings)
     format_settings.json.quote_64bit_integers = settings.output_format_json_quote_64bit_integers;
     format_settings.json.quote_denormals = settings.output_format_json_quote_denormals;
     format_settings.null_as_default = settings.input_format_null_as_default;
+    format_settings.decimal_trailing_zeros = settings.output_format_decimal_trailing_zeros;
     format_settings.parquet.row_group_size = settings.output_format_parquet_row_group_size;
     format_settings.parquet.import_nested = settings.input_format_parquet_import_nested;
     format_settings.pretty.charset = settings.output_format_pretty_grid_charset.toString() == "ASCII" ? FormatSettings::Pretty::Charset::ASCII : FormatSettings::Pretty::Charset::UTF8;
diff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h
index d77a7c95d690..3e1e00584c00 100644
--- a/src/Formats/FormatSettings.h
+++ b/src/Formats/FormatSettings.h
@@ -28,6 +28,7 @@ struct FormatSettings
     bool write_statistics = true;
     bool import_nested_json = false;
     bool null_as_default = true;
+    bool decimal_trailing_zeros = false;
 
     enum class DateTimeInputFormat
     {
diff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp
index c5781ee6c9ff..baeefa8f98e4 100644
--- a/src/Formats/ProtobufSerializer.cpp
+++ b/src/Formats/ProtobufSerializer.cpp
@@ -1239,7 +1239,7 @@ namespace
                             else
                             {
                                 WriteBufferFromOwnString buf;
-                                writeText(decimal, scale, buf);
+                                writeText(decimal, scale, buf, false);
                                 cannotConvertValue(buf.str(), TypeName<DecimalType>, field_descriptor.type_name());
                             }
                         };
@@ -1316,9 +1316,9 @@ namespace
         {
             WriteBufferFromString buf{str};
             if constexpr (std::is_same_v<DecimalType, DateTime64>)
-               writeDateTimeText(decimal, scale, buf);
+                writeDateTimeText(decimal, scale, buf);
             else
-                writeText(decimal, scale, buf);
+                writeText(decimal, scale, buf, false);
         }
 
         DecimalType stringToDecimal(const String & str) const
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index e57998e4a72c..8f34abc00582 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -733,7 +733,7 @@ struct FormatImpl<DataTypeDecimal<FieldType>>
     template <typename ReturnType = void>
     static ReturnType execute(const FieldType x, WriteBuffer & wb, const DataTypeDecimal<FieldType> * type, const DateLUTImpl *)
     {
-        writeText(x, type->getScale(), wb);
+        writeText(x, type->getScale(), wb, false);
         return ReturnType(true);
     }
 };
diff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h
index 556adbe2d6fb..6a0050b061fb 100644
--- a/src/IO/WriteHelpers.h
+++ b/src/IO/WriteHelpers.h
@@ -901,34 +901,67 @@ inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTim
 inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }
 
 template <typename T>
-String decimalFractional(const T & x, UInt32 scale)
+void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)
 {
+    /// If it's big integer, but the number of digits is small,
+    /// use the implementation for smaller integers for more efficient arithmetic.
+
     if constexpr (std::is_same_v<T, Int256>)
     {
         if (x <= std::numeric_limits<UInt32>::max())
-            return decimalFractional(static_cast<UInt32>(x), scale);
+        {
+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);
+            return;
+        }
         else if (x <= std::numeric_limits<UInt64>::max())
-            return decimalFractional(static_cast<UInt64>(x), scale);
+        {
+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);
+            return;
+        }
         else if (x <= std::numeric_limits<UInt128>::max())
-            return decimalFractional(static_cast<UInt128>(x), scale);
+        {
+            writeDecimalFractional(static_cast<UInt128>(x), scale, ostr, trailing_zeros);
+            return;
+        }
     }
     else if constexpr (std::is_same_v<T, Int128>)
     {
         if (x <= std::numeric_limits<UInt32>::max())
-            return decimalFractional(static_cast<UInt32>(x), scale);
+        {
+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);
+            return;
+        }
         else if (x <= std::numeric_limits<UInt64>::max())
-            return decimalFractional(static_cast<UInt64>(x), scale);
+        {
+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);
+            return;
+        }
     }
 
-    String str(scale, '0');
+    constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;
+    assert(scale <= max_digits);
+    char buf[max_digits];
+    memset(buf, '0', scale);
+
     T value = x;
-    for (Int32 pos = scale - 1; pos >= 0; --pos, value /= 10)
-        str[pos] += static_cast<char>(value % 10);
-    return str;
+    Int32 last_nonzero_pos = 0;
+    for (Int32 pos = scale - 1; pos >= 0; --pos)
+    {
+        auto remainder = value % 10;
+        value /= 10;
+
+        if (remainder != 0 && last_nonzero_pos == 0)
+            last_nonzero_pos = pos;
+
+        buf[pos] += static_cast<char>(remainder);
+    }
+
+    writeChar('.', ostr);
+    ostr.write(buf, trailing_zeros ? scale : last_nonzero_pos + 1);
 }
 
 template <typename T>
-void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr)
+void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)
 {
     T part = DecimalUtils::getWholePart(x, scale);
 
@@ -941,10 +974,9 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr)
 
     if (scale)
     {
-        writeChar('.', ostr);
         part = DecimalUtils::getFractionalPart(x, scale);
-        String fractional = decimalFractional(part, scale);
-        ostr.write(fractional.data(), scale);
+        if (part || trailing_zeros)
+            writeDecimalFractional(part, scale, ostr, trailing_zeros);
     }
 }
 
