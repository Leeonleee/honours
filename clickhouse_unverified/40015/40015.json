{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40015,
  "instance_id": "ClickHouse__ClickHouse-40015",
  "issue_numbers": [
    "37492"
  ],
  "base_commit": "de49e1ae9a124a2d8d9fb8166a9d17a5faee1e20",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex c51445675f51..9514760fd7dd 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -1452,13 +1452,25 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## parseDateTime64BestEffortUS\n+\n+Same as for [parseDateTime64BestEffort](#parsedatetime64besteffort), except that this function prefers US date format (`MM/DD/YYYY` etc.) in case of ambiguity.\n+\n ## parseDateTime64BestEffortOrNull\n \n Same as for [parseDateTime64BestEffort](#parsedatetime64besteffort) except that it returns `NULL` when it encounters a date format that cannot be processed.\n \n ## parseDateTime64BestEffortOrZero\n \n-Same as for [parseDateTime64BestEffort](#parsedatetimebesteffort) except that it returns zero date or zero date time when it encounters a date format that cannot be processed.\n+Same as for [parseDateTime64BestEffort](#parsedatetime64besteffort) except that it returns zero date or zero date time when it encounters a date format that cannot be processed.\n+\n+## parseDateTime64BestEffortUSOrNull\n+\n+Same as for [parseDateTime64BestEffort](#parsedatetime64besteffort), except that this function prefers US date format (`MM/DD/YYYY` etc.) in case of ambiguity and returns `NULL` when it encounters a date format that cannot be processed.\n+\n+## parseDateTime64BestEffortUSOrZero\n+\n+Same as for [parseDateTime64BestEffort](#parsedatetime64besteffort), except that this function prefers US date format (`MM/DD/YYYY` etc.) in case of ambiguity and returns zero date or zero date time when it encounters a date format that cannot be processed.\n \n \n ## toLowCardinality\ndiff --git a/docs/ru/sql-reference/functions/type-conversion-functions.md b/docs/ru/sql-reference/functions/type-conversion-functions.md\nindex 946abddf3d05..56e63b793f39 100644\n--- a/docs/ru/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/ru/sql-reference/functions/type-conversion-functions.md\n@@ -1374,13 +1374,25 @@ FORMAT PrettyCompactMonoBlock;\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## parseDateTime64BestEffortOrNull {#parsedatetime32besteffortornull}\n+## parseDateTime64BestEffortUS {#parsedatetime64besteffortus}\n+\n+\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetime64besteffort), \u043d\u043e \u0440\u0430\u0437\u043d\u0438\u0446\u0430 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0432 \u0442\u043e\u043c, \u0447\u0442\u043e \u0432 \u043e\u043d\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u0430\u043c\u0435\u0440\u0438\u043a\u0430\u043d\u0441\u043a\u0438\u0439 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b (`MM/DD/YYYY` etc.) \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0435\u043e\u0434\u043d\u043e\u0437\u043d\u0430\u0447\u043d\u043e\u0441\u0442\u0438.\n+\n+## parseDateTime64BestEffortOrNull {#parsedatetime64besteffortornull}\n \n \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetime64besteffort), \u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 `NULL`, \u0435\u0441\u043b\u0438 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d.\n \n ## parseDateTime64BestEffortOrZero {#parsedatetime64besteffortorzero}\n \n-\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetimebesteffort), \u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0443\u043b\u0435\u0432\u0443\u044e \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043c\u044f, \u0435\u0441\u043b\u0438 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d.\n+\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetime64besteffort), \u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0443\u043b\u0435\u0432\u0443\u044e \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043c\u044f, \u0435\u0441\u043b\u0438 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d.\n+\n+## parseDateTime64BestEffortUSOrNull {#parsedatetime64besteffortusornull}\n+\n+\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetime64besteffort), \u043d\u043e \u0440\u0430\u0437\u043d\u0438\u0446\u0430 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0432 \u0442\u043e\u043c, \u0447\u0442\u043e \u0432 \u043e\u043d\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u0430\u043c\u0435\u0440\u0438\u043a\u0430\u043d\u0441\u043a\u0438\u0439 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b (`MM/DD/YYYY` etc.) \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0435\u043e\u0434\u043d\u043e\u0437\u043d\u0430\u0447\u043d\u043e\u0441\u0442\u0438 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 `NULL`, \u0435\u0441\u043b\u0438 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d.\n+\n+## parseDateTime64BestEffortUSOrZero {#parsedatetime64besteffortusorzero}\n+\n+\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [parseDateTime64BestEffort](#parsedatetime64besteffort), \u043d\u043e \u0440\u0430\u0437\u043d\u0438\u0446\u0430 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0432 \u0442\u043e\u043c, \u0447\u0442\u043e \u0432 \u043e\u043d\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u0430\u043c\u0435\u0440\u0438\u043a\u0430\u043d\u0441\u043a\u0438\u0439 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b (`MM/DD/YYYY` etc.) \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0435\u043e\u0434\u043d\u043e\u0437\u043d\u0430\u0447\u043d\u043e\u0441\u0442\u0438 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0443\u043b\u0435\u0432\u0443\u044e \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043c\u044f, \u0435\u0441\u043b\u0438 \u0444\u043e\u0440\u043c\u0430\u0442 \u0434\u0430\u0442\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d.\n \n ## toLowCardinality {#tolowcardinality}\n \ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex ae6ad0a60342..dc0235f810f0 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -103,6 +103,9 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionParseDateTime64BestEffort>();\n     factory.registerFunction<FunctionParseDateTime64BestEffortOrZero>();\n     factory.registerFunction<FunctionParseDateTime64BestEffortOrNull>();\n+    factory.registerFunction<FunctionParseDateTime64BestEffortUS>();\n+    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrZero>();\n+    factory.registerFunction<FunctionParseDateTime64BestEffortUSOrNull>();\n \n     factory.registerFunction<FunctionConvert<DataTypeInterval, NameToIntervalNanosecond, PositiveMonotonicity>>();\n     factory.registerFunction<FunctionConvert<DataTypeInterval, NameToIntervalMicrosecond, PositiveMonotonicity>>();\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 014ce98a7958..1387c7af2b83 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1336,9 +1336,18 @@ struct ConvertThroughParsing\n                 }\n                 else if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                 {\n-                    time_t res;\n-                    parsed = tryParseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n-                    convertFromTime<ToDataType>(vec_to[i],res);\n+                    if constexpr (to_datetime64)\n+                    {\n+                        DateTime64 res = 0;\n+                        parsed = tryParseDateTime64BestEffortUS(res, col_to->getScale(), read_buffer, *local_time_zone, *utc_time_zone);\n+                        vec_to[i] = res;\n+                    }\n+                    else\n+                    {\n+                        time_t res;\n+                        parsed = tryParseDateTimeBestEffortUS(res, read_buffer, *local_time_zone, *utc_time_zone);\n+                        convertFromTime<ToDataType>(vec_to[i],res);\n+                    }\n                 }\n                 else\n                 {\n@@ -2525,6 +2534,9 @@ struct NameParseDateTime32BestEffortOrNull { static constexpr auto name = \"parse\n struct NameParseDateTime64BestEffort { static constexpr auto name = \"parseDateTime64BestEffort\"; };\n struct NameParseDateTime64BestEffortOrZero { static constexpr auto name = \"parseDateTime64BestEffortOrZero\"; };\n struct NameParseDateTime64BestEffortOrNull { static constexpr auto name = \"parseDateTime64BestEffortOrNull\"; };\n+struct NameParseDateTime64BestEffortUS { static constexpr auto name = \"parseDateTime64BestEffortUS\"; };\n+struct NameParseDateTime64BestEffortUSOrZero { static constexpr auto name = \"parseDateTime64BestEffortUSOrZero\"; };\n+struct NameParseDateTime64BestEffortUSOrNull { static constexpr auto name = \"parseDateTime64BestEffortUSOrNull\"; };\n \n \n using FunctionParseDateTimeBestEffort = FunctionConvertFromString<\n@@ -2555,6 +2567,14 @@ using FunctionParseDateTime64BestEffortOrZero = FunctionConvertFromString<\n using FunctionParseDateTime64BestEffortOrNull = FunctionConvertFromString<\n     DataTypeDateTime64, NameParseDateTime64BestEffortOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffort>;\n \n+using FunctionParseDateTime64BestEffortUS = FunctionConvertFromString<\n+    DataTypeDateTime64, NameParseDateTime64BestEffortUS, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::BestEffortUS>;\n+using FunctionParseDateTime64BestEffortUSOrZero = FunctionConvertFromString<\n+    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrZero, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::BestEffortUS>;\n+using FunctionParseDateTime64BestEffortUSOrNull = FunctionConvertFromString<\n+    DataTypeDateTime64, NameParseDateTime64BestEffortUSOrNull, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::BestEffortUS>;\n+\n+\n class ExecutableFunctionCast : public IExecutableFunction\n {\n public:\ndiff --git a/src/IO/parseDateTimeBestEffort.cpp b/src/IO/parseDateTimeBestEffort.cpp\nindex 3c6f9b8f9f5b..df3f02708a9b 100644\n--- a/src/IO/parseDateTimeBestEffort.cpp\n+++ b/src/IO/parseDateTimeBestEffort.cpp\n@@ -697,4 +697,9 @@ bool tryParseDateTime64BestEffort(DateTime64 & res, UInt32 scale, ReadBuffer & i\n     return parseDateTime64BestEffortImpl<bool, false>(res, scale, in, local_time_zone, utc_time_zone);\n }\n \n+bool tryParseDateTime64BestEffortUS(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone)\n+{\n+    return parseDateTime64BestEffortImpl<bool, true>(res, scale, in, local_time_zone, utc_time_zone);\n+}\n+\n }\ndiff --git a/src/IO/parseDateTimeBestEffort.h b/src/IO/parseDateTimeBestEffort.h\nindex fe3da24a7974..22af44f9e76c 100644\n--- a/src/IO/parseDateTimeBestEffort.h\n+++ b/src/IO/parseDateTimeBestEffort.h\n@@ -27,7 +27,6 @@ class ReadBuffer;\n   *\n   * DD/MM/YY\n   * DD/MM/YYYY - when '/' separator is used, these are the only possible forms\n-  * Note that American style is not supported.\n   *\n   * hh:mm:ss - when ':' separator is used, it is always time\n   * hh:mm - it can be specified without seconds\n@@ -61,7 +60,7 @@ bool tryParseDateTimeBestEffort(time_t & res, ReadBuffer & in, const DateLUTImpl\n void parseDateTimeBestEffortUS(time_t & res, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n bool tryParseDateTimeBestEffortUS(time_t & res, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n void parseDateTime64BestEffort(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n-void parseDateTime64BestEffortUS(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n bool tryParseDateTime64BestEffort(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n-\n+void parseDateTime64BestEffortUS(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n+bool tryParseDateTime64BestEffortUS(DateTime64 & res, UInt32 scale, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.reference b/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.reference\nnew file mode 100644\nindex 000000000000..c9a13c97baf7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.reference\n@@ -0,0 +1,12 @@\n+parseDateTime64BestEffortUS\n+ s                                           a\n+\n+ 01-02-1930 12:00:00   1930-01-02 12:00:00.000 \n+ 12.02.1930 12:00:00   1930-12-02 12:00:00.000 \n+ 13/02/1930 12:00:00   1930-02-13 12:00:00.000 \n+ 02/25/1930 12:00:00   1930-02-25 12:00:00.000 \n+\n+parseDateTime64BestEffortUSOrNull\n+\\N\n+parseDateTime64BestEffortUSOrZero\n+1970-01-01 00:00:00.000\ndiff --git a/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.sql b/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.sql\nnew file mode 100644\nindex 000000000000..21dc7b1a990d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_parseDateTime64BestEffortUS.sql\n@@ -0,0 +1,22 @@\n+SELECT 'parseDateTime64BestEffortUS';\n+\n+SELECT\n+    s,\n+    parseDateTime64BestEffortUS(s,3,'UTC') AS a\n+FROM\n+(\n+    SELECT arrayJoin([\n+'01-02-1930 12:00:00',\n+'12.02.1930 12:00:00',\n+'13/02/1930 12:00:00',\n+'02/25/1930 12:00:00'\n+]) AS s)\n+FORMAT PrettySpaceNoEscapes;\n+\n+SELECT '';\n+\n+SELECT 'parseDateTime64BestEffortUSOrNull';\n+SELECT parseDateTime64BestEffortUSOrNull('01/45/1925 16:00:00',3,'UTC');\n+\n+SELECT 'parseDateTime64BestEffortUSOrZero';\n+SELECT parseDateTime64BestEffortUSOrZero('01/45/1925 16:00:00',3,'UTC');\n",
  "problem_statement": "DateTime64 is missing parseDateTime64BestEffort and parseDateTime64BestEffortUS\nWhile loading data containing string dates like so:\r\n```\r\n10/10/1958 18:42:00\r\n01/22/1980 16:00:00\r\n```\r\nI realized that I needed to swap the date format from `MM/DD/YYYY` to `YYYY/MM/DD` and that I needed support for 64 bit dates to back before 1970.  The 64 bit `parseDateTimeBestEffort` is not implemented.  \r\n\r\nThis is how I worked around it:\r\n```\r\nselect replaceRegexpOne(complaint_time, '(\\\\d{2})/(\\\\d{2})/(\\\\d{4})', '\\\\3/\\\\1/\\\\2')::DateTime64(0) AS report_time64\r\n```\r\n\r\nThis is with version 22.4.5.9\r\n\r\n\r\n\n",
  "hints_text": "22.3\r\n```\r\n\u250c\u2500parseDateTime64BestEffort('01/22/1980 16:00:00')\u2500\u2510\r\n\u2502                          1980-01-22 16:00:00.000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500parseDateTime64BestEffort('10/10/1958 18:42:00')\u2500\u2510\r\n\u2502                          1958-10-10 18:42:00.000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nThanks @alex-zaitsev , I apologize, I was wrong!\nThere is no function for the US.\n@DanRoscigno please don't apologize.\n@alexey-milovidov Alright if I take a stab at adding this `parseDateTime64BestEffortUS` function? It keeps me up at night that datasets with US-style dates are missing this functionality.\n@tbragin Yes, your help will be very appreciated!",
  "created_at": "2022-08-09T03:50:19Z"
}