diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md
index 03cf345349e2..e66dfac4db74 100644
--- a/docs/en/interfaces/formats.md
+++ b/docs/en/interfaces/formats.md
@@ -91,6 +91,7 @@ The supported formats are:
 | [MySQLDump](#mysqldump)                                                                   | ✔    | ✗     |
 | [DWARF](#dwarf)                                                                           | ✔    | ✗     |
 | [Markdown](#markdown)                                                                     | ✗    | ✔     |
+| [Form](#form)                                                                             | ✔    | ✗     |
 
 
 You can control some format processing parameters with the ClickHouse settings. For more information read the [Settings](/docs/en/operations/settings/settings-formats.md) section.
@@ -2843,3 +2844,31 @@ FORMAT Markdown
 ```
 
 Markdown table will be generated automatically and can be used on markdown-enabled platforms, like Github. This format is used only for output.
+
+## Form {#form}
+
+The Form format can be used to read or write a single record in the application/x-www-form-urlencoded format in which data is formatted `key1=value1&key2=value2`
+
+Examples:
+
+Given a file `data.tmp` placed in the `user_files` path with some URL encoded data:
+
+```text
+t_page=116&c.e=ls7xfkpm&c.tti.m=raf&rt.start=navigation&rt.bmr=390%2C11%2C10
+```
+
+```sql
+SELECT * FROM file(data.tmp, Form) FORMAT vertical;
+```
+
+Result:
+
+```text
+Row 1:
+──────
+t_page:   116
+c.e:      ls7xfkpm
+c.tti.m:  raf
+rt.start: navigation
+rt.bmr:   390,11,10
+```
diff --git a/src/Formats/registerFormats.cpp b/src/Formats/registerFormats.cpp
index cc9cf380693f..1f851da850a8 100644
--- a/src/Formats/registerFormats.cpp
+++ b/src/Formats/registerFormats.cpp
@@ -76,6 +76,7 @@ void registerInputFormatCustomSeparated(FormatFactory & factory);
 void registerOutputFormatCustomSeparated(FormatFactory & factory);
 void registerInputFormatCapnProto(FormatFactory & factory);
 void registerOutputFormatCapnProto(FormatFactory & factory);
+void registerInputFormatForm(FormatFactory & factory);
 
 /// Output only (presentational) formats.
 
@@ -148,6 +149,7 @@ void registerParquetMetadataSchemaReader(FormatFactory & factory);
 void registerDWARFSchemaReader(FormatFactory & factory);
 void registerOneSchemaReader(FormatFactory & factory);
 void registerNpySchemaReader(FormatFactory & factory);
+void registerFormSchemaReader(FormatFactory & factory);
 
 void registerFileExtensions(FormatFactory & factory);
 
@@ -212,6 +214,7 @@ void registerFormats()
     registerOutputFormatRawBLOB(factory);
     registerInputFormatCustomSeparated(factory);
     registerOutputFormatCustomSeparated(factory);
+    registerInputFormatForm(factory);
 
     registerInputFormatORC(factory);
     registerOutputFormatORC(factory);
@@ -291,6 +294,7 @@ void registerFormats()
     registerDWARFSchemaReader(factory);
     registerOneSchemaReader(factory);
     registerNpySchemaReader(factory);
+    registerFormSchemaReader(factory);
 }
 
 }
diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp
index 68b61e96c513..8c83eac5cff7 100644
--- a/src/IO/ReadHelpers.cpp
+++ b/src/IO/ReadHelpers.cpp
@@ -243,6 +243,18 @@ void readStringUntilWhitespace(String & s, ReadBuffer & buf)
     readStringUntilWhitespaceInto(s, buf);
 }
 
+void readStringUntilAmpersand(String & s, ReadBuffer & buf)
+{
+    s.clear();
+    readStringUntilCharsInto<'&'>(s, buf);
+}
+
+void readStringUntilEquals(String & s, ReadBuffer & buf)
+{
+    s.clear();
+    readStringUntilCharsInto<'='>(s, buf);
+}
+
 template void readNullTerminated<PODArray<char>>(PODArray<char> & s, ReadBuffer & buf);
 template void readNullTerminated<String>(String & s, ReadBuffer & buf);
 
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index a136eb4d1551..f349ab45cfe0 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -609,6 +609,9 @@ void readEscapedStringUntilEOL(String & s, ReadBuffer & buf);
 /// Only 0x20 as whitespace character
 void readStringUntilWhitespace(String & s, ReadBuffer & buf);
 
+void readStringUntilAmpersand(String & s, ReadBuffer & buf);
+void readStringUntilEquals(String & s, ReadBuffer & buf);
+
 
 /** Read string in CSV format.
   * Parsing rules:
diff --git a/src/Processors/Formats/Impl/FormRowInputFormat.cpp b/src/Processors/Formats/Impl/FormRowInputFormat.cpp
new file mode 100644
index 000000000000..448c9e52cce2
--- /dev/null
+++ b/src/Processors/Formats/Impl/FormRowInputFormat.cpp
@@ -0,0 +1,179 @@
+#include<Processors/Formats/Impl/FormRowInputFormat.h>
+#include "Formats/EscapingRuleUtils.h"
+#include <Formats/FormatFactory.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int INCORRECT_DATA;
+}
+
+namespace
+{
+    String readFieldName(ReadBuffer & buf)
+    {
+        String field;
+        readStringUntilEquals(field, buf);
+        assertChar('=', buf);
+        return field;
+    }
+}
+
+FormRowInputFormat::FormRowInputFormat(ReadBuffer & in_, Block header_, Params params_, const FormatSettings & format_settings_) : IRowInputFormat(std::move(header_), in_, params_), format_settings(format_settings_)
+{
+    const auto & header = getPort().getHeader();
+    size_t num_columns = header.columns();
+    for (size_t i = 0; i < num_columns; ++i)
+        name_map[header.getByPosition(i).name] = i;
+}
+
+void FormRowInputFormat::readPrefix()
+{
+    skipBOMIfExists(*in);
+}
+
+const String & FormRowInputFormat::columnName(size_t i) const
+{
+    return getPort().getHeader().getByPosition(i).name;
+}
+
+void FormRowInputFormat::readField(size_t index, MutableColumns & columns)
+{
+    if (seen_columns[index])
+        throw Exception(ErrorCodes::INCORRECT_DATA, "Duplicate field found while parsing Form format: {}", columnName(index));
+
+    seen_columns[index] = true;
+    const auto & serialization = serializations[index];
+
+    String encoded_str, decoded_str;
+    readStringUntilAmpersand(encoded_str,*in);
+
+    if (!in->eof())
+        assertChar('&', *in);
+
+    Poco::URI::decode(encoded_str, decoded_str);
+    ReadBufferFromString buf(decoded_str);
+    serialization->deserializeWholeText(*columns[index], buf, format_settings);
+}
+
+void FormRowInputFormat::readFormData(MutableColumns & columns)
+{
+    size_t index = 0;
+    StringRef name_ref;
+    while (true)
+    {
+        if (in->eof())
+            break;
+
+        auto tmp = readFieldName(*in);
+        name_ref = StringRef(tmp);
+        auto * it = name_map.find(name_ref);
+
+        if (!it)
+        {
+            if (!format_settings.skip_unknown_fields)
+                throw Exception(ErrorCodes::INCORRECT_DATA, "Unknown field found while parsing Form format: {}", name_ref.toString());
+
+            /// Skip the value if key is not found.
+            String encoded_str;
+            readStringUntilAmpersand(encoded_str, *in);
+
+            if (!in->eof())
+                assertChar('&',*in);
+
+        }
+        else
+        {
+            index = it->getMapped();
+            readField(index, columns);
+        }
+    }
+}
+
+bool FormRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ext)
+{
+    if (in->eof())
+        return false;
+
+    size_t num_columns = columns.size();
+    seen_columns.assign(num_columns, false);
+
+    readFormData(columns);
+
+    const auto & header = getPort().getHeader();
+    /// Non-visited columns get filled with default values
+    for (size_t i = 0; i < num_columns; ++i)
+        if (!seen_columns[i])
+            header.getByPosition(i).type->insertDefaultInto(*columns[i]);
+
+    /// Return info about defaults set.
+    /// If defaults_for_omitted_fields is set to 0, then we leave already inserted defaults.
+    if (format_settings.defaults_for_omitted_fields)
+        ext.read_columns = seen_columns;
+    else
+        ext.read_columns.assign(seen_columns.size(), true);
+    return true;
+}
+
+void FormRowInputFormat::resetParser()
+{
+    IRowInputFormat::resetParser();
+    seen_columns.clear();
+}
+
+FormSchemaReader::FormSchemaReader(ReadBuffer & in_, const FormatSettings & format_settings_)
+    : IRowWithNamesSchemaReader(in_, format_settings_,getDefaultDataTypeForEscapingRule(FormatSettings::EscapingRule::Escaped))
+{
+}
+
+NamesAndTypesList readRowAndGetNamesAndDataTypesForFormRow(ReadBuffer & in, const FormatSettings & settings)
+{
+    NamesAndTypesList names_and_types;
+    String field, value, decoded_value;
+    do
+    {
+        auto name = readFieldName(in);
+        readStringUntilAmpersand(value,in);
+        Poco::URI::decode(value, decoded_value);
+        auto type = tryInferDataTypeByEscapingRule(decoded_value, settings, FormatSettings::EscapingRule::Raw);
+        names_and_types.emplace_back(name, type);
+    }
+    while (checkChar('&',in));
+    return names_and_types;
+}
+
+NamesAndTypesList FormSchemaReader::readRowAndGetNamesAndDataTypes(bool & eof)
+{
+    if (in.eof())
+    {
+        eof = true;
+        return {};
+    }
+    return readRowAndGetNamesAndDataTypesForFormRow(in, format_settings);
+}
+
+void registerInputFormatForm(FormatFactory & factory)
+{
+    factory.registerInputFormat("Form", [](
+        ReadBuffer & buf,
+        const Block & sample,
+        IRowInputFormat::Params params,
+        const FormatSettings & settings)
+    {
+        return std::make_shared<FormRowInputFormat>(buf, sample, std::move(params),settings);
+    });
+}
+
+void registerFormSchemaReader(FormatFactory & factory)
+{
+    factory.registerSchemaReader("Form", [](ReadBuffer & buffer, const FormatSettings & settings)
+    {
+        return std::make_shared<FormSchemaReader>(buffer, settings);
+    });
+}
+
+}
+
+
diff --git a/src/Processors/Formats/Impl/FormRowInputFormat.h b/src/Processors/Formats/Impl/FormRowInputFormat.h
new file mode 100644
index 000000000000..00a90f39e8e7
--- /dev/null
+++ b/src/Processors/Formats/Impl/FormRowInputFormat.h
@@ -0,0 +1,46 @@
+#pragma once
+
+#include <Processors/Formats/IRowInputFormat.h>
+#include <Processors/Formats/ISchemaReader.h>
+#include <Formats/FormatSettings.h>
+#include <Common/HashTable/HashMap.h>
+
+namespace DB
+{
+
+class ReadBuffer;
+
+class FormRowInputFormat final : public IRowInputFormat
+{
+public:
+    FormRowInputFormat(ReadBuffer & in_, Block header_, Params params_, const FormatSettings & format_settings_);
+    String getName() const override { return "FormInputFormat"; }
+    void resetParser() override;
+
+private:
+    void readPrefix() override;
+    bool readRow(MutableColumns & columns, RowReadExtension & ext) override;
+    void readFormData(MutableColumns & columns);
+    void readField(size_t index, MutableColumns & columns);
+    const String & columnName(size_t i) const;
+
+    /// Hash table matches field name to position in the block
+    using NameMap = HashMap<StringRef, size_t, StringRefHash>;
+    NameMap name_map;
+
+protected:
+    const FormatSettings format_settings;
+    std::vector<UInt8> seen_columns;
+};
+
+class FormSchemaReader : public IRowWithNamesSchemaReader
+{
+public:
+    FormSchemaReader(ReadBuffer & in_, const FormatSettings & format_settings_);
+private:
+    NamesAndTypesList readRowAndGetNamesAndDataTypes(bool & eof) override;
+    NamesAndTypesList readRowAndGetNamesAndDataTypesForForm(ReadBuffer & in, const FormatSettings & settings);
+};
+
+}
+
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 2b260566816d..755bc9cea2ce 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1002,6 +1002,7 @@ UMTS
 UNDROP
 UPDATEs
 URIs
+URL
 URL's
 URLHash
 URLHierarchy
@@ -2761,6 +2762,7 @@ uptime
 uptrace
 uring
 url
+urlencoded
 urlCluster
 urls
 usearch
