{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6756,
  "instance_id": "ClickHouse__ClickHouse-6756",
  "issue_numbers": [
    "6757"
  ],
  "base_commit": "ddbb1abbaf5dbdf66b2ddcb517336b4fefbdcd12",
  "patch": "diff --git a/dbms/src/Interpreters/InterpreterRenameQuery.cpp b/dbms/src/Interpreters/InterpreterRenameQuery.cpp\nindex e763c002209e..3e8bc3a88fba 100644\n--- a/dbms/src/Interpreters/InterpreterRenameQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterRenameQuery.cpp\n@@ -26,8 +26,6 @@ struct RenameDescription\n         to_table_name(elem.to.table)\n     {}\n \n-    TableStructureWriteLockHolder from_table_lock;\n-\n     String from_database_name;\n     String from_table_name;\n \n@@ -77,8 +75,6 @@ BlockIO InterpreterRenameQuery::execute()\n         }\n     };\n \n-    std::map<UniqueTableName, TableStructureWriteLockHolder> tables_from_locks;\n-\n     /// Don't allow to drop tables (that we are renaming); don't allow to create tables in places where tables will be renamed.\n     std::map<UniqueTableName, std::unique_ptr<DDLGuard>> table_guards;\n \n@@ -89,36 +85,26 @@ BlockIO InterpreterRenameQuery::execute()\n         UniqueTableName from(descriptions.back().from_database_name, descriptions.back().from_table_name);\n         UniqueTableName to(descriptions.back().to_database_name, descriptions.back().to_table_name);\n \n-        if (!tables_from_locks.count(from))\n-            if (auto table = context.tryGetTable(from.database_name, from.table_name))\n-                tables_from_locks.emplace(from, table->lockExclusively(context.getCurrentQueryId()));\n-\n-        descriptions.back().from_table_lock = tables_from_locks[from];\n-\n-        if (!table_guards.count(from))\n-            table_guards.emplace(from, context.getDDLGuard(from.database_name, from.table_name));\n-\n-        if (!table_guards.count(to))\n-            table_guards.emplace(to, context.getDDLGuard(to.database_name, to.table_name));\n+        table_guards[from];\n+        table_guards[to];\n     }\n \n-    /** All tables are locked. If there are more than one rename in chain,\n-      *  we need to hold global lock while doing all renames. Order matters to avoid deadlocks.\n-      * It provides atomicity of all RENAME chain as a whole, from the point of view of DBMS client,\n-      *  but only in cases when there was no exceptions during this process and server does not fall.\n-      */\n-\n-    decltype(context.getLock()) lock;\n-\n-    if (descriptions.size() > 1)\n-        lock = context.getLock();\n+    /// Must do it in consistent order.\n+    for (auto & table_guard : table_guards)\n+        table_guard.second = context.getDDLGuard(table_guard.first.database_name, table_guard.first.table_name);\n \n     for (auto & elem : descriptions)\n     {\n         context.assertTableDoesntExist(elem.to_database_name, elem.to_table_name);\n+        auto from_table = context.getTable(elem.from_database_name, elem.from_table_name);\n+        auto from_table_lock = from_table->lockExclusively(context.getCurrentQueryId());\n \n         context.getDatabase(elem.from_database_name)->renameTable(\n-            context, elem.from_table_name, *context.getDatabase(elem.to_database_name), elem.to_table_name, elem.from_table_lock);\n+            context,\n+            elem.from_table_name,\n+            *context.getDatabase(elem.to_database_name),\n+            elem.to_table_name,\n+            from_table_lock);\n     }\n \n     return {};\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01004_rename_deadlock.reference b/dbms/tests/queries/0_stateless/01004_rename_deadlock.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/queries/0_stateless/01004_rename_deadlock.sh b/dbms/tests/queries/0_stateless/01004_rename_deadlock.sh\nnew file mode 100755\nindex 000000000000..5d5726bb001e\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01004_rename_deadlock.sh\n@@ -0,0 +1,60 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+set -e\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS test1\";\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS test2\";\n+$CLICKHOUSE_CLIENT --query \"CREATE TABLE test1 (x UInt8) ENGINE = MergeTree ORDER BY x\";\n+$CLICKHOUSE_CLIENT --query \"CREATE TABLE test2 (x UInt8) ENGINE = MergeTree ORDER BY x\";\n+\n+function thread1()\n+{\n+    while true; do \n+        $CLICKHOUSE_CLIENT --query \"RENAME TABLE test1 TO test_tmp, test2 TO test1, test_tmp TO test2\"\n+    done\n+}\n+\n+function thread2()\n+{\n+    while true; do\n+        $CLICKHOUSE_CLIENT --query \"SELECT * FROM test1 UNION ALL SELECT * FROM test2\" --format Null\n+    done\n+}\n+\n+function thread3()\n+{\n+    while true; do\n+        $CLICKHOUSE_CLIENT --query \"SELECT * FROM system.tables\" --format Null\n+    done\n+}\n+\n+# https://stackoverflow.com/questions/9954794/execute-a-shell-function-with-timeout\n+export -f thread1;\n+export -f thread2;\n+export -f thread3;\n+\n+TIMEOUT=10\n+\n+timeout $TIMEOUT bash -c thread1 2> /dev/null &\n+timeout $TIMEOUT bash -c thread2 2> /dev/null &\n+timeout $TIMEOUT bash -c thread3 2> /dev/null &\n+\n+timeout $TIMEOUT bash -c thread1 2> /dev/null &\n+timeout $TIMEOUT bash -c thread2 2> /dev/null &\n+timeout $TIMEOUT bash -c thread3 2> /dev/null &\n+\n+timeout $TIMEOUT bash -c thread1 2> /dev/null &\n+timeout $TIMEOUT bash -c thread2 2> /dev/null &\n+timeout $TIMEOUT bash -c thread3 2> /dev/null &\n+\n+timeout $TIMEOUT bash -c thread1 2> /dev/null &\n+timeout $TIMEOUT bash -c thread2 2> /dev/null &\n+timeout $TIMEOUT bash -c thread3 2> /dev/null &\n+\n+wait\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE test1\"\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE test2\"\n",
  "problem_statement": "Refuse to support atomicity of multiple tables rename\nThe query\r\n\r\n```\r\nRENAME a TO c, b TO a, c TO b\r\n```\r\n\r\nis documented to be atomic from the point of view of other clients.\r\nFor example, no one else will see table `c` in any moment of time.\r\n\r\nThis is barely supported in ClickHouse, but many complications exist:\r\n\r\n1. It isn't atomic in respect to `kill -9`.\r\n2. It isn't atmoic in the case of unexpected errors in the middle of rename chain.\r\n3. The query `SELECT * FROM a UNION ALL SELECT * FROM b` doesn't use atomic snapshot of database catalog. In presence of concurrent `RENAME a TO c, b TO a, c TO b` it may read from `a` two times or from `b` two times. Every sub-select uses atomic snapshot of database catalog but not all query as a whole.\r\n4. The logic to support atomicity of RENAME is too complicated and it's difficult to avoid deadlocks (it's technically possible, but the logic is broken).\r\n\r\nProposed solution:\r\n\r\n- multiple tables rename is still supported (as now);\r\n- it is serialized in respect to other DDL operations involving the same tables (as now);\r\n- it's checked that all rename chain is possible and in absense of unexpected errors, either all renames performed or no renames performed (as now);\r\n- other clients may see intermediate state - for example, clients may see table `c` of `RENAME a TO c, b TO a, c TO b` (this is what will be changed).\n",
  "hints_text": "",
  "created_at": "2019-08-31T02:33:17Z"
}