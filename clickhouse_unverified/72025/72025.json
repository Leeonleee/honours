{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 72025,
  "instance_id": "ClickHouse__ClickHouse-72025",
  "issue_numbers": [
    "69571"
  ],
  "base_commit": "0876057b55efee942124efcea5299502201b5ece",
  "patch": "diff --git a/src/Analyzer/ConstantNode.cpp b/src/Analyzer/ConstantNode.cpp\nindex 3a99ad08ad84..1fbeaa0530ed 100644\n--- a/src/Analyzer/ConstantNode.cpp\n+++ b/src/Analyzer/ConstantNode.cpp\n@@ -114,7 +114,12 @@ void ConstantNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state\n \n     buffer << \", constant_value: \";\n     if (mask_id)\n-        buffer << \"[HIDDEN id: \" << mask_id << \"]\";\n+    {\n+        if (mask_id == std::numeric_limits<decltype(mask_id)>::max())\n+            buffer << \"[HIDDEN]\";\n+        else\n+            buffer << \"[HIDDEN id: \" << mask_id << \"]\";\n+    }\n     else\n         buffer << constant_value->getValue().dump();\n \ndiff --git a/src/Analyzer/ConstantNode.h b/src/Analyzer/ConstantNode.h\nindex 0c88862b8792..1e1b8003ff8e 100644\n--- a/src/Analyzer/ConstantNode.h\n+++ b/src/Analyzer/ConstantNode.h\n@@ -82,7 +82,7 @@ class ConstantNode final : public IQueryTreeNode\n     /// Check if constant is a result of _CAST function constant folding.\n     bool receivedFromInitiatorServer() const;\n \n-    void setMaskId(size_t id)\n+    void setMaskId(size_t id = std::numeric_limits<decltype(mask_id)>::max())\n     {\n         mask_id = id;\n     }\ndiff --git a/src/Analyzer/FunctionSecretArgumentsFinderTreeNode.h b/src/Analyzer/FunctionSecretArgumentsFinderTreeNode.h\nindex c598adfd98e1..8bcb6e147420 100644\n--- a/src/Analyzer/FunctionSecretArgumentsFinderTreeNode.h\n+++ b/src/Analyzer/FunctionSecretArgumentsFinderTreeNode.h\n@@ -3,13 +3,30 @@\n #include <Parsers/FunctionSecretArgumentsFinder.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/TableFunctionNode.h>\n #include <Analyzer/IdentifierNode.h>\n \n \n namespace DB\n {\n \n-class FunctionTreeNode : public AbstractFunction\n+template <typename FunctionNodeType>\n+inline String getFunctionNameImpl(const FunctionNodeType *);\n+\n+template <>\n+inline String getFunctionNameImpl<FunctionNode>(const FunctionNode * function)\n+{\n+    return function->getFunctionName();\n+}\n+\n+template <>\n+inline String getFunctionNameImpl<TableFunctionNode>(const TableFunctionNode * function)\n+{\n+    return function->getTableFunctionName();\n+}\n+\n+template <typename FunctionNodeType>\n+class FunctionTreeNodeImpl : public AbstractFunction\n {\n public:\n     class ArgumentTreeNode : public Argument\n@@ -19,7 +36,7 @@ class FunctionTreeNode : public AbstractFunction\n         std::unique_ptr<AbstractFunction> getFunction() const override\n         {\n             if (const auto * f = argument->as<FunctionNode>())\n-                return std::make_unique<FunctionTreeNode>(*f);\n+                return std::make_unique<FunctionTreeNodeImpl<FunctionNode>>(*f);\n             return nullptr;\n         }\n         bool isIdentifier() const override { return argument->as<IdentifierNode>(); }\n@@ -60,24 +77,24 @@ class FunctionTreeNode : public AbstractFunction\n         const QueryTreeNodes * arguments = nullptr;\n     };\n \n-    explicit FunctionTreeNode(const FunctionNode & function_) : function(&function_)\n+    explicit FunctionTreeNodeImpl(const FunctionNodeType & function_) : function(&function_)\n     {\n         if (const auto & nodes = function->getArguments().getNodes(); !nodes.empty())\n             arguments = std::make_unique<ArgumentsTreeNode>(&nodes);\n     }\n-    String name() const override { return function->getFunctionName(); }\n+    String name() const override { return getFunctionNameImpl(function); }\n private:\n-    const FunctionNode * function = nullptr;\n+    const FunctionNodeType * function = nullptr;\n };\n \n-\n /// Finds arguments of a specified function which should not be displayed for most users for security reasons.\n /// That involves passwords and secret keys.\n-class FunctionSecretArgumentsFinderTreeNode : public FunctionSecretArgumentsFinder\n+template <typename FunctionNodeType>\n+class FunctionSecretArgumentsFinderTreeNodeImpl : public FunctionSecretArgumentsFinder\n {\n public:\n-    explicit FunctionSecretArgumentsFinderTreeNode(const FunctionNode & function_)\n-        : FunctionSecretArgumentsFinder(std::make_unique<FunctionTreeNode>(function_))\n+    explicit FunctionSecretArgumentsFinderTreeNodeImpl(const FunctionNodeType & function_)\n+        : FunctionSecretArgumentsFinder(std::make_unique<FunctionTreeNodeImpl<FunctionNodeType>>(function_))\n     {\n         if (!function->hasArguments())\n             return;\n@@ -88,4 +105,8 @@ class FunctionSecretArgumentsFinderTreeNode : public FunctionSecretArgumentsFind\n     FunctionSecretArgumentsFinder::Result getResult() const { return result; }\n };\n \n+\n+using FunctionSecretArgumentsFinderTreeNode = FunctionSecretArgumentsFinderTreeNodeImpl<FunctionNode>;\n+using TableFunctionSecretArgumentsFinderTreeNode = FunctionSecretArgumentsFinderTreeNodeImpl<TableFunctionNode>;\n+\n }\ndiff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp\nindex 85dd4bcc9470..cd25b7672239 100644\n--- a/src/Interpreters/InterpreterExplainQuery.cpp\n+++ b/src/Interpreters/InterpreterExplainQuery.cpp\n@@ -21,6 +21,7 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSetQuery.h>\n+#include <Parsers/FunctionSecretArgumentsFinder.h>\n \n #include <Storages/StorageView.h>\n #include <Processors/QueryPlan/QueryPlan.h>\n@@ -33,6 +34,9 @@\n \n #include <Analyzer/QueryTreeBuilder.h>\n #include <Analyzer/QueryTreePassManager.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/FunctionSecretArgumentsFinderTreeNode.h>\n+\n \n namespace DB\n {\n@@ -40,6 +44,7 @@ namespace Setting\n {\n     extern const SettingsBool allow_experimental_analyzer;\n     extern const SettingsBool allow_statistics_optimize;\n+    extern const SettingsBool format_display_secrets_in_show_and_select;\n }\n \n namespace ErrorCodes\n@@ -90,6 +95,36 @@ namespace\n \n     using ExplainAnalyzedSyntaxVisitor = InDepthNodeVisitor<ExplainAnalyzedSyntaxMatcher, true>;\n \n+    class TableFunctionSecretsVisitor : public InDepthQueryTreeVisitor<TableFunctionSecretsVisitor>\n+    {\n+        friend class InDepthQueryTreeVisitor;\n+        bool needChildVisit(VisitQueryTreeNodeType & parent [[maybe_unused]], VisitQueryTreeNodeType & child [[maybe_unused]])\n+        {\n+            QueryTreeNodeType type = parent->getNodeType();\n+            return type == QueryTreeNodeType::QUERY || type == QueryTreeNodeType::JOIN || type == QueryTreeNodeType::TABLE_FUNCTION;\n+        }\n+\n+        void visitImpl(VisitQueryTreeNodeType & query_tree_node)\n+        {\n+            auto * table_function_node_ptr = query_tree_node->as<TableFunctionNode>();\n+            if (!table_function_node_ptr)\n+                return;\n+\n+            if (FunctionSecretArgumentsFinder::Result secret_arguments = TableFunctionSecretArgumentsFinderTreeNode(*table_function_node_ptr).getResult(); secret_arguments.count)\n+            {\n+                auto & argument_nodes = table_function_node_ptr->getArgumentsNode()->as<ListNode &>().getNodes();\n+\n+                for (size_t n = secret_arguments.start; n < secret_arguments.start + secret_arguments.count; ++n)\n+                {\n+                    if (secret_arguments.are_named)\n+                        argument_nodes[n]->as<FunctionNode&>().getArguments().getNodes()[1]->as<ConstantNode&>().setMaskId();\n+                    else\n+                        argument_nodes[n]->as<ConstantNode&>().setMaskId();\n+                }\n+            }\n+        }\n+    };\n+\n }\n \n BlockIO InterpreterExplainQuery::execute()\n@@ -411,6 +446,12 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n             auto query_tree = buildQueryTree(ast.getExplainedQuery(), getContext());\n             bool need_newline = false;\n \n+            if (!getContext()->getSettingsRef()[Setting::format_display_secrets_in_show_and_select])\n+            {\n+                TableFunctionSecretsVisitor visitor;\n+                visitor.visit(query_tree);\n+            }\n+\n             if (settings.run_passes)\n             {\n                 auto query_tree_pass_manager = QueryTreePassManager(getContext());\n@@ -441,7 +482,10 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n                 if (need_newline)\n                     buf << \"\\n\\n\";\n \n-                query_tree->toAST()->format(buf, IAST::FormatSettings(false));\n+                IAST::FormatSettings format_settings(false);\n+                format_settings.show_secrets = getContext()->getSettingsRef()[Setting::format_display_secrets_in_show_and_select];\n+\n+                query_tree->toAST()->format(buf, format_settings);\n             }\n \n             break;\n",
  "test_patch": "diff --git a/tests/integration/test_mask_sensitive_info/test.py b/tests/integration/test_mask_sensitive_info/test.py\nindex 97a0e33e8bdd..016b99cb6e98 100644\n--- a/tests/integration/test_mask_sensitive_info/test.py\n+++ b/tests/integration/test_mask_sensitive_info/test.py\n@@ -504,6 +504,22 @@ def make_test_case(i):\n         if not error:\n             node.query(f\"DROP TABLE {table_name}\")\n \n+    # Check EXPLAIN QUERY TREE\n+    secrets = [password, azure_account_key]\n+    for toggle in range(2):\n+        for table_function in table_functions:\n+            # check only table functions containing secrets\n+            if any(word in table_function for word in secrets):\n+                output = node.query(\n+                    f\"EXPLAIN QUERY TREE run_passes=0 SELECT * FROM {table_function} {show_secrets}={toggle}\"\n+                )\n+                is_secret_present = any(word in output for word in secrets)\n+                if toggle:\n+                    assert is_secret_present\n+                else:\n+                    assert not is_secret_present\n+                    assert \"[HIDDEN]\" in output\n+\n \n def test_table_function_ways_to_call():\n     password = new_password()\ndiff --git a/tests/queries/0_stateless/02479_mysql_connect_to_self.reference b/tests/queries/0_stateless/02479_mysql_connect_to_self.reference\nindex 8057b945c5a9..9e95a2651556 100644\n--- a/tests/queries/0_stateless/02479_mysql_connect_to_self.reference\n+++ b/tests/queries/0_stateless/02479_mysql_connect_to_self.reference\n@@ -59,7 +59,7 @@ QUERY id: 0\n               FUNCTION id: 10, function_name: currentDatabase, function_type: ordinary, result_type: String\n           IDENTIFIER id: 11, identifier: foo\n           CONSTANT id: 12, constant_value: \\'default\\', constant_value_type: String\n-          CONSTANT id: 13, constant_value: \\'\\', constant_value_type: String\n+          CONSTANT id: 13, constant_value: [HIDDEN], constant_value_type: String\n       SETTINGS connection_wait_timeout=123 connect_timeout=40123002 read_write_timeout=40123001 connection_pool_size=3\n \n SELECT\n@@ -67,6 +67,6 @@ SELECT\n     __table1.a AS a,\n     __table1.b AS b,\n     __table1.c AS c\n-FROM mysql(\\'127.0.0.1:9004\\', _CAST(\\'default\\', \\'String\\'), foo, \\'default\\', \\'\\', SETTINGS connection_wait_timeout = 123, connect_timeout = 40123002, read_write_timeout = 40123001, connection_pool_size = 3) AS __table1\n+FROM mysql(\\'127.0.0.1:9004\\', _CAST(\\'default\\', \\'String\\'), foo, \\'default\\', \\'[HIDDEN]\\', SETTINGS connection_wait_timeout = 123, connect_timeout = 40123002, read_write_timeout = 40123001, connection_pool_size = 3) AS __table1\n ---\n 5\n",
  "problem_statement": "Table function credentials are not properly masked in analyzer\nThere is a masking for functions in analyzer: https://github.com/ClickHouse/ClickHouse/blob/8610a01745a459459159b109b7193a5ab1a2d52e/src/Analyzer/Resolve/QueryAnalyzer.cpp#L2812-L2829\r\n\r\nBut it's not working for table functions (`s3`, `azureBlobStorage`, ...)\n",
  "hints_text": "cc @yakov-olkhovskiy @novikd\nI wrote a test for hiding table functions' credentials in analyzer:\r\nhttps://github.com/ClickHouse/ClickHouse/pull/69667/files\nshould be solved by #69615\n> should be solved by #69615\r\n\r\nNot really, it solved the future issue when we miss some functions for analyzer. But in this case masking only works from `resolveFunction` in `QueryAnalyzer`, but it's not invoked for table functions, there's a different path for them",
  "created_at": "2024-11-18T09:43:41Z"
}