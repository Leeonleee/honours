diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 42ac9cb6a5ba..bade0810320d 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -11,6 +11,8 @@
 #include <Interpreters/InterpreterSelectQuery.h>
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/ASTLiteral.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTExpressionList.h>
 #include <DataTypes/DataTypeString.h>
 #include <Columns/ColumnString.h>
 #include <Common/typeid_cast.h>
@@ -41,19 +43,42 @@ namespace
 {
 
 /// Rewrite original query removing joined tables from it
-void removeJoin(const ASTSelectQuery & select)
+bool removeJoin(ASTSelectQuery & select)
 {
     const auto & tables = select.tables();
     if (!tables || tables->children.size() < 2)
-        return;
+        return false;
 
     const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();
     if (!joined_table.table_join)
-        return;
+        return false;
 
     /// The most simple temporary solution: leave only the first table in query.
     /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).
     tables->children.resize(1);
+    return true;
+}
+
+void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result)
+{
+    if (removeJoin(select))
+    {
+        /// Also remove GROUP BY cause ExpressionAnalyzer would check if it has all aggregate columns but joined columns would be missed.
+        select.setExpression(ASTSelectQuery::Expression::GROUP_BY, {});
+
+        /// Replace select list to remove joined columns
+        auto select_list = std::make_shared<ASTExpressionList>();
+        for (const auto & column : rewriter_result.required_source_columns)
+            select_list->children.emplace_back(std::make_shared<ASTIdentifier>(column.name));
+
+        select.setExpression(ASTSelectQuery::Expression::SELECT, select_list);
+
+        /// TODO: keep WHERE/PREWHERE. We have to remove joined columns and their expressions but keep others.
+        select.setExpression(ASTSelectQuery::Expression::WHERE, {});
+        select.setExpression(ASTSelectQuery::Expression::PREWHERE, {});
+        select.setExpression(ASTSelectQuery::Expression::HAVING, {});
+        select.setExpression(ASTSelectQuery::Expression::ORDER_BY, {});
+    }
 }
 
 }
@@ -265,7 +290,8 @@ Pipe StorageMerge::createSources(
     modified_query_info.query = query_info.query->clone();
 
     /// Original query could contain JOIN but we need only the first joined table and its columns.
-    removeJoin(*modified_query_info.query->as<ASTSelectQuery>());
+    auto & modified_select = modified_query_info.query->as<ASTSelectQuery &>();
+    modifySelect(modified_select, *query_info.syntax_analyzer_result);
 
     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, "_table", table_name);
 
@@ -282,7 +308,7 @@ Pipe StorageMerge::createSources(
         return pipe;
     }
 
-    auto storage_stage = storage->getQueryProcessingStage(*modified_context, QueryProcessingStage::Complete, query_info.query);
+    auto storage_stage = storage->getQueryProcessingStage(*modified_context, QueryProcessingStage::Complete, modified_query_info.query);
     if (processed_stage <= storage_stage)
     {
         /// If there are only virtual columns in query, you must request at least one other column.
@@ -294,7 +320,7 @@ Pipe StorageMerge::createSources(
     }
     else if (processed_stage > storage_stage)
     {
-        modified_query_info.query->as<ASTSelectQuery>()->replaceDatabaseAndTable(source_database, table_name);
+        modified_select.replaceDatabaseAndTable(source_database, table_name);
 
         /// Maximum permissible parallelism is streams_num
         modified_context->setSetting("max_threads", streams_num);
