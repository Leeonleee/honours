{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 15242,
  "instance_id": "ClickHouse__ClickHouse-15242",
  "issue_numbers": [
    "15228"
  ],
  "base_commit": "c9eeb149fd11b314fa0a21ca302503df6623740d",
  "patch": "diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 42ac9cb6a5ba..bade0810320d 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -11,6 +11,8 @@\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTLiteral.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTExpressionList.h>\n #include <DataTypes/DataTypeString.h>\n #include <Columns/ColumnString.h>\n #include <Common/typeid_cast.h>\n@@ -41,19 +43,42 @@ namespace\n {\n \n /// Rewrite original query removing joined tables from it\n-void removeJoin(const ASTSelectQuery & select)\n+bool removeJoin(ASTSelectQuery & select)\n {\n     const auto & tables = select.tables();\n     if (!tables || tables->children.size() < 2)\n-        return;\n+        return false;\n \n     const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();\n     if (!joined_table.table_join)\n-        return;\n+        return false;\n \n     /// The most simple temporary solution: leave only the first table in query.\n     /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n     tables->children.resize(1);\n+    return true;\n+}\n+\n+void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result)\n+{\n+    if (removeJoin(select))\n+    {\n+        /// Also remove GROUP BY cause ExpressionAnalyzer would check if it has all aggregate columns but joined columns would be missed.\n+        select.setExpression(ASTSelectQuery::Expression::GROUP_BY, {});\n+\n+        /// Replace select list to remove joined columns\n+        auto select_list = std::make_shared<ASTExpressionList>();\n+        for (const auto & column : rewriter_result.required_source_columns)\n+            select_list->children.emplace_back(std::make_shared<ASTIdentifier>(column.name));\n+\n+        select.setExpression(ASTSelectQuery::Expression::SELECT, select_list);\n+\n+        /// TODO: keep WHERE/PREWHERE. We have to remove joined columns and their expressions but keep others.\n+        select.setExpression(ASTSelectQuery::Expression::WHERE, {});\n+        select.setExpression(ASTSelectQuery::Expression::PREWHERE, {});\n+        select.setExpression(ASTSelectQuery::Expression::HAVING, {});\n+        select.setExpression(ASTSelectQuery::Expression::ORDER_BY, {});\n+    }\n }\n \n }\n@@ -265,7 +290,8 @@ Pipe StorageMerge::createSources(\n     modified_query_info.query = query_info.query->clone();\n \n     /// Original query could contain JOIN but we need only the first joined table and its columns.\n-    removeJoin(*modified_query_info.query->as<ASTSelectQuery>());\n+    auto & modified_select = modified_query_info.query->as<ASTSelectQuery &>();\n+    modifySelect(modified_select, *query_info.syntax_analyzer_result);\n \n     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, \"_table\", table_name);\n \n@@ -282,7 +308,7 @@ Pipe StorageMerge::createSources(\n         return pipe;\n     }\n \n-    auto storage_stage = storage->getQueryProcessingStage(*modified_context, QueryProcessingStage::Complete, query_info.query);\n+    auto storage_stage = storage->getQueryProcessingStage(*modified_context, QueryProcessingStage::Complete, modified_query_info.query);\n     if (processed_stage <= storage_stage)\n     {\n         /// If there are only virtual columns in query, you must request at least one other column.\n@@ -294,7 +320,7 @@ Pipe StorageMerge::createSources(\n     }\n     else if (processed_stage > storage_stage)\n     {\n-        modified_query_info.query->as<ASTSelectQuery>()->replaceDatabaseAndTable(source_database, table_name);\n+        modified_select.replaceDatabaseAndTable(source_database, table_name);\n \n         /// Maximum permissible parallelism is streams_num\n         modified_context->setSetting(\"max_threads\", streams_num);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference\nnew file mode 100644\nindex 000000000000..b2c3ea56b7f7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference\n@@ -0,0 +1,7 @@\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+1\n+0\t1\n+0\t1\ndiff --git a/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql\nnew file mode 100644\nindex 000000000000..a6678ca9040e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql\n@@ -0,0 +1,22 @@\n+DROP TABLE IF EXISTS a;\n+DROP TABLE IF EXISTS b;\n+DROP TABLE IF EXISTS m;\n+\n+CREATE TABLE a (key UInt32) ENGINE = MergeTree ORDER BY key;\n+CREATE TABLE b (key UInt32, ID UInt32) ENGINE = MergeTree ORDER BY key;\n+CREATE TABLE m (key UInt32) ENGINE = Merge(currentDatabase(), 'a');\n+\n+INSERT INTO a VALUES (0);\n+INSERT INTO b VALUES (0, 1);\n+\n+SELECT * FROM m INNER JOIN b USING(key);\n+SELECT * FROM a INNER JOIN b USING(key) GROUP BY ID, key;\n+SELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1;\n+SELECT * FROM m INNER JOIN b USING(key) GROUP BY ID, key;\n+SELECT ID FROM m INNER JOIN b USING(key) GROUP BY ID;\n+SELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 HAVING ID = 1 ORDER BY ID;\n+SELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 GROUP BY ID, key HAVING ID = 1 ORDER BY ID;\n+\n+DROP TABLE IF EXISTS a;\n+DROP TABLE IF EXISTS b;\n+DROP TABLE IF EXISTS m;\n",
  "problem_statement": "Merge table 'Unknown identifier' in GROUP BY for joined column\n**How to reproduce**\r\nClickhouse server version 20.3.17\r\n\r\n```\r\nCREATE TABLE table_2(key UInt32, ID UInt32) ENGINE = MergeTree PARTITION BY tuple() ORDER BY key;\r\nCREATE TABLE merge_table (key UInt32) ENGINE=Merge(default,'^table');\r\nCREATE TABLE table (key UInt32) ENGINE=MergeTree PARTITION BY tuple() ORDER BY key;}\r\n\r\nSELECT ID, key FROM merge_table INNER JOIN table_2 USING(key) GROUP BY ID, key;\r\n\r\n[a5342ff16411] 2020.09.24 10:45:40.732748 [ 72 ] {42a90654-6796-4584-a7f0-5113d0b3d721} <Debug> executeQuery: (from 127.0.0.1:40086) SELECT ID, key FROM merge_table INNER JOIN table_2 USING (key) GROUP BY ID, key\r\n[a5342ff16411] 2020.09.24 10:45:40.733291 [ 72 ] {42a90654-6796-4584-a7f0-5113d0b3d721} <Trace> AccessRightsContext (default): Access granted: SELECT(key, ID) ON default.table_2\r\n[a5342ff16411] 2020.09.24 10:45:40.733356 [ 72 ] {42a90654-6796-4584-a7f0-5113d0b3d721} <Debug> Join: setSampleBlock: table_2.key UInt32 UInt32(size = 0), ID UInt32 UInt32(size = 0)\r\n[a5342ff16411] 2020.09.24 10:45:40.733928 [ 72 ] {42a90654-6796-4584-a7f0-5113d0b3d721} <Debug> MemoryTracker: Peak memory usage (total): 0.00 B.\r\n[a5342ff16411] 2020.09.24 10:45:40.734072 [ 72 ] {42a90654-6796-4584-a7f0-5113d0b3d721} <Error> executeQuery: Code: 47, e.displayText() = DB::Exception: Unknown identifier (in GROUP BY): ID (version 20.3.17.173 (official build)) (from 127.0.0.1:40086) (in query: SELECT ID, key FROM merge_table INNER JOIN table_2 USING (key) GROUP BY ID, key), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x1059b460 in /usr/bin/clickhouse\r\n1. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x8f9972d in /usr/bin/clickhouse\r\n2. ? @ 0xd34aca0 in /usr/bin/clickhouse\r\n3. DB::ExpressionAnalyzer::ExpressionAnalyzer(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::SyntaxAnalyzerResult const> const&, DB::Context const&, unsigned long, bool) @ 0xd346e65 in /usr/bin/clickhouse\r\n4. DB::KeyCondition::getBlockWithConstants(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::SyntaxAnalyzerResult const> const&, DB::Context const&) @ 0xd910f68 in /usr/bin/clickhouse\r\n5. DB::KeyCondition::KeyCondition(DB::SelectQueryInfo const&, DB::Context const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::ExpressionActions> const&) @ 0xd9178a1 in /usr/bin/clickhouse\r\n6. DB::MergeTreeDataSelectExecutor::readFromParts(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > >, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, unsigned long, unsigned int, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, long> > > const*) const @ 0xda02303 in /usr/bin/clickhouse\r\n7. DB::MergeTreeDataSelectExecutor::read(std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, unsigned long, unsigned int, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, long> > > const*) const @ 0xda08103 in /usr/bin/clickhouse\r\n8. DB::StorageMergeTree::read(std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, DB::QueryProcessingStage::Enum, unsigned long, unsigned int) @ 0xd765f45 in /usr/bin/clickhouse\r\n9. DB::StorageMerge::createSources(DB::SelectQueryInfo const&, DB::QueryProcessingStage::Enum const&, unsigned long, DB::Block const&, std::__1::tuple<std::__1::shared_ptr<DB::IStorage>, DB::TableStructureReadLockHolder, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >&, std::__1::shared_ptr<DB::Context> const&, unsigned long, bool, bool) @ 0xd75a276 in /usr/bin/clickhouse\r\n10. DB::StorageMerge::read(std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, DB::QueryProcessingStage::Enum, unsigned long, unsigned int) @ 0xd75b95f in /usr/bin/clickhouse\r\n11. void DB::InterpreterSelectQuery::executeFetchColumns<DB::QueryPipeline>(DB::QueryProcessingStage::Enum, DB::QueryPipeline&, std::__1::shared_ptr<DB::PrewhereInfo> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::QueryPipeline&) @ 0xd1ba65d in /usr/bin/clickhouse\r\n12. void DB::InterpreterSelectQuery::executeImpl<DB::QueryPipeline>(DB::QueryPipeline&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, DB::QueryPipeline&) @ 0xd1bddc7 in /usr/bin/clickhouse\r\n13. DB::InterpreterSelectQuery::executeWithProcessors() @ 0xd180155 in /usr/bin/clickhouse\r\n14. DB::InterpreterSelectWithUnionQuery::executeWithProcessors() @ 0xd38c8f8 in /usr/bin/clickhouse\r\n15. ? @ 0xd59ff3a in /usr/bin/clickhouse\r\n16. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, bool) @ 0xd5a0a01 in /usr/bin/clickhouse\r\n17. DB::TCPHandler::runImpl() @ 0x907b5c9 in /usr/bin/clickhouse\r\n18. DB::TCPHandler::run() @ 0x907c5b0 in /usr/bin/clickhouse\r\n19. Poco::Net::TCPServerConnection::start() @ 0xe402b9b in /usr/bin/clickhouse\r\n20. Poco::Net::TCPServerDispatcher::run() @ 0xe40301d in /usr/bin/clickhouse\r\n21. Poco::PooledThread::run() @ 0x106295c7 in /usr/bin/clickhouse\r\n22. Poco::ThreadImpl::runnableEntry(void*) @ 0x106253cc in /usr/bin/clickhouse\r\n23. ? @ 0x10626d6d in /usr/bin/clickhouse\r\n24. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n25. __clone @ 0x121a3f in /lib/x86_64-linux-gnu/libc-2.27.so\r\n\r\n\r\nReceived exception from server (version 20.3.17):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown identifier (in GROUP BY): ID.\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n```\r\n**Expected behavior**\r\n\r\nClickhouse server version 20.3.15\r\n\r\n```\r\nSELECT\r\n    ID,\r\n    key\r\nFROM merge_table\r\nINNER JOIN table_2 USING (key)\r\n\r\n[4b6e47203a6d] 2020.09.24 10:47:41.508163 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> executeQuery: (from 172.17.0.1:52396) SELECT ID, key FROM merge_table INNER JOIN table_2 USING(key);\r\n[4b6e47203a6d] 2020.09.24 10:47:41.508710 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Trace> AccessRightsContext (default): Access granted: SELECT(key, ID) ON default.table_2\r\n[4b6e47203a6d] 2020.09.24 10:47:41.508765 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> Join: setSampleBlock: table_2.key UInt32 UInt32(size = 0), ID UInt32 UInt32(size = 0)\r\n[4b6e47203a6d] 2020.09.24 10:47:41.508943 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table (SelectExecutor): Key condition: unknown\r\n[4b6e47203a6d] 2020.09.24 10:47:41.508999 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table (SelectExecutor): Selected 0 parts by date, 0 parts by key, 0 marks to read from 0 ranges\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509077 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table_2 (SelectExecutor): Key condition: unknown\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509115 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table_2 (SelectExecutor): Selected 0 parts by date, 0 parts by key, 0 marks to read from 0 ranges\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509166 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509563 [ 203 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Trace> CreatingSetsBlockInputStream: Creating join.\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509643 [ 203 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table_2 (SelectExecutor): Key condition: unknown\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509673 [ 203 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> default.table_2 (SelectExecutor): Selected 0 parts by date, 0 parts by key, 0 marks to read from 0 ranges\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509713 [ 203 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[4b6e47203a6d] 2020.09.24 10:47:41.509791 [ 203 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> CreatingSetsBlockInputStream: Subquery has empty result.\r\n[4b6e47203a6d] 2020.09.24 10:47:41.510345 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Information> executeQuery: Read 1 rows, 4.00 B in 0.002 sec., 478 rows/sec., 1.87 KiB/sec.\r\n[4b6e47203a6d] 2020.09.24 10:47:41.510439 [ 248 ] {2c1bd414-7a2e-4025-ba12-aefbbb84b46c} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n\r\n```\r\n\r\n**Additional context**\r\nClickhouse server version 20.3.16 works correctly.\r\nClickhouse server version 20.3.18 doesn't work.\r\nClickhouse server version 20.9.2 doesn't work.\r\n\r\n\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/pull/13679 ? \nThere's no `ID` in table `table`. Merge pattern '^table' should combine both `table` and `table_2`, `GROUP BY ID, key` cannot find `ID` in one of combined tables. It was wrong if it worked before.\nThere's inconsistency with `WHERE` that works\r\n```\r\nSELECT ID, key FROM merge_table INNER JOIN table_2 USING(key) WHERE ID = 0; \r\n```\r\n\r\nAny case there's nothing ralated to JOIN.\n> Merge pattern '^table' should combine both table and table_2\r\n\r\nIt's probably bad naming in my example.\r\n\r\nDoesn't work either.\r\n```\r\nCREATE TABLE other_table(key UInt32, ID UInt32) ENGINE = MergeTree PARTITION BY tuple() ORDER BY key;\r\nCREATE TABLE merge_table (key UInt32) ENGINE=Merge(default,'^table');\r\nCREATE TABLE table (key UInt32) ENGINE=MergeTree PARTITION BY tuple() ORDER BY key;\r\nSELECT ID, key FROM merge_table INNER JOIN other_table USING(key) GROUP BY ID, key;\r\n```\r\n\r\n\r\nClickhouse version  20.3.15.133\r\n```\r\n\r\nSELECT\r\n    ID,\r\n    key\r\nFROM merge_table\r\nINNER JOIN other_table USING (key)\r\nGROUP BY\r\n    ID,\r\n    key\r\n\r\n[4b6e47203a6d] 2020.09.24 12:08:22.370924 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> executeQuery: (from 172.17.0.1:52568) SELECT ID, key FROM merge_table INNER JOIN other_table USING(key) GROUP BY ID, key;\r\n[4b6e47203a6d] 2020.09.24 12:08:22.371476 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> AccessRightsContext (default): Access granted: SELECT(key, ID) ON default.other_table\r\n[4b6e47203a6d] 2020.09.24 12:08:22.371534 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> Join: setSampleBlock: other_table.key UInt32 UInt32(size = 0), ID UInt32 UInt32(size = 0)\r\n[4b6e47203a6d] 2020.09.24 12:08:22.371727 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> default.table (SelectExecutor): Key condition: unknown\r\n[4b6e47203a6d] 2020.09.24 12:08:22.371766 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> default.table (SelectExecutor): Selected 0 parts by date, 0 parts by key, 0 marks to read from 0 ranges\r\n[4b6e47203a6d] 2020.09.24 12:08:22.371815 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372218 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> CreatingSetsBlockInputStream: Creating join.\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372308 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> default.other_table (SelectExecutor): Key condition: unknown\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372368 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> default.other_table (SelectExecutor): Selected 0 parts by date, 0 parts by key, 0 marks to read from 0 ranges\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372405 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372480 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> CreatingSetsBlockInputStream: Subquery has empty result.\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372528 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> AggregatingTransform: Aggregated. 0 to 0 rows (from 0.000 MiB) in 0.001 sec. (0.000 rows/sec., 0.000 MiB/sec.)\r\n[4b6e47203a6d] 2020.09.24 12:08:22.372550 [ 243 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Trace> Aggregator: Merging aggregated data\r\n[4b6e47203a6d] 2020.09.24 12:08:22.373249 [ 248 ] {dbe48397-4adf-47ff-8808-33998f9249c6} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.005 sec.\r\n```\r\n\nReproduced in master\r\n```\r\nCREATE TABLE a (key UInt32) ENGINE = MergeTree ORDER BY key;\r\nCREATE TABLE b (key UInt32, ID UInt32) ENGINE = MergeTree ORDER BY key;\r\nCREATE TABLE m (key UInt32) ENGINE = Merge(default, 'a');\r\n\r\nINSERT INTO a VALUES (0);\r\nINSERT INTO b VALUES (0, 1);\r\n\r\nSELECT * FROM m INNER JOIN b USING(key);\r\nSELECT * FROM a INNER JOIN b USING(key) GROUP BY ID, key;\r\nSELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1; -- OK\r\nSELECT * FROM m INNER JOIN b USING(key) GROUP BY ID, key; -- FAIL\r\n-- SELECT ID FROM m INNER JOIN b USING(key) GROUP BY ID; -- FAIL\r\nSELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 HAVING ID = 1 ORDER BY ID; -- OK\r\nSELECT * FROM m INNER JOIN b USING(key) WHERE ID = 1 GROUP BY ID, key HAVING ID = 1 ORDER BY ID; -- FAIL\r\n```\nAlso I've made a mistake in query and found that we know `ID` as required and available column:\r\n```\r\nSELECT ID FROM m INNER JOIN b ON a.key = b.key GROUP BY b.ID;\r\n\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'a.key' while processing query: 'SELECT ID FROM m ALL INNER JOIN (SELECT * FROM b) AS b ON a.key = b.key GROUP BY ID', required columns: 'ID' 'a.key' 'b.key', source columns: 'key', joined columns: 'b.key' 'ID'. \r\n```\r\nSo it's something in expressions. We know about column in before expressions, in WHERE, HAVING and ORDER BY. But forget it in GROUP BY for some reason.",
  "created_at": "2020-09-24T17:00:18Z",
  "modified_files": [
    "src/Storages/StorageMerge.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.reference",
    "b/tests/queries/0_stateless/01483_merge_table_join_and_group_by.sql"
  ]
}