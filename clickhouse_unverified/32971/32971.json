{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32971,
  "instance_id": "ClickHouse__ClickHouse-32971",
  "issue_numbers": [
    "32913"
  ],
  "base_commit": "967738ff8f9fd852f3a18b24969453b6602bd948",
  "patch": "diff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex 18d4526e0f35..b55083cd671a 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -87,7 +87,7 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T\n \n public:\n     const char * getFamilyName() const override { return TypeName<T>.data(); }\n-    TypeIndex getDataType() const override { return TypeId<T>; }\n+    TypeIndex getDataType() const override { return TypeToTypeIndex<T>; }\n \n     bool isNumeric() const override { return false; }\n     bool canBeInsideNullable() const override { return true; }\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex bee7bfa738c7..62a0e3a11904 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -238,7 +238,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n     }\n \n     const char * getFamilyName() const override { return TypeName<T>.data(); }\n-    TypeIndex getDataType() const override { return TypeId<T>; }\n+    TypeIndex getDataType() const override { return TypeToTypeIndex<T>; }\n \n     MutableColumnPtr cloneResized(size_t size) const override;\n \ndiff --git a/src/Core/TypeId.h b/src/Core/TypeId.h\nindex 3218db10778a..390587731842 100644\n--- a/src/Core/TypeId.h\n+++ b/src/Core/TypeId.h\n@@ -10,12 +10,12 @@ namespace DB\n  * Returns TypeIndex::Nothing if type was not present in TypeIndex;\n  * Returns TypeIndex element otherwise.\n  *\n- * @example TypeId<UInt8> == TypeIndex::UInt8\n- * @example TypeId<MySuperType> == TypeIndex::Nothing\n+ * @example TypeToTypeIndex<UInt8> == TypeIndex::UInt8\n+ * @example TypeToTypeIndex<MySuperType> == TypeIndex::Nothing\n  */\n-template <class T> inline constexpr TypeIndex TypeId = TypeIndex::Nothing;\n+template <class T> inline constexpr TypeIndex TypeToTypeIndex = TypeIndex::Nothing;\n \n-template <TypeIndex index> struct ReverseTypeIdT : std::false_type {};\n+template <TypeIndex index> struct TypeIndexToTypeHelper : std::false_type {};\n \n /**\n  * Obtain real type from TypeIndex if possible.\n@@ -23,14 +23,14 @@ template <TypeIndex index> struct ReverseTypeIdT : std::false_type {};\n  * Returns a type alias if is corresponds to TypeIndex value.\n  * Yields a compiler error otherwise.\n  *\n- * @example ReverseTypeId<TypeIndex::UInt8> == UInt8\n+ * @example TypeIndexToType<TypeIndex::UInt8> == UInt8\n  */\n-template <TypeIndex index> using ReverseTypeId = typename ReverseTypeIdT<index>::T;\n-template <TypeIndex index> constexpr bool HasReverseTypeId = ReverseTypeIdT<index>::value;\n+template <TypeIndex index> using TypeIndexToType = typename TypeIndexToTypeHelper<index>::T;\n+template <TypeIndex index> constexpr bool TypeIndexHasType = TypeIndexToTypeHelper<index>::value;\n \n #define TYPEID_MAP(_A) \\\n-    template <> inline constexpr TypeIndex TypeId<_A> = TypeIndex::_A; \\\n-    template <> struct ReverseTypeIdT<TypeIndex::_A> : std::true_type { using T = _A; };\n+    template <> inline constexpr TypeIndex TypeToTypeIndex<_A> = TypeIndex::_A; \\\n+    template <> struct TypeIndexToTypeHelper<TypeIndex::_A> : std::true_type { using T = _A; };\n \n TYPEID_MAP(UInt8)\n TYPEID_MAP(UInt16)\n@@ -58,4 +58,7 @@ TYPEID_MAP(String)\n \n struct Array;\n TYPEID_MAP(Array)\n+\n+#undef TYPEID_MAP\n+\n }\ndiff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h\nindex c0585095eebe..a92defea8249 100644\n--- a/src/DataTypes/DataTypeDecimalBase.h\n+++ b/src/DataTypes/DataTypeDecimalBase.h\n@@ -74,7 +74,7 @@ class DataTypeDecimalBase : public IDataType\n             throw Exception(\"Scale \" + std::to_string(scale) + \" is out of bounds\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n     }\n \n-    TypeIndex getTypeId() const override { return TypeId<T>; }\n+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }\n \n     Field getDefault() const override;\n     MutableColumnPtr createColumn() const override;\ndiff --git a/src/DataTypes/DataTypeNumberBase.h b/src/DataTypes/DataTypeNumberBase.h\nindex 959750516008..842ae1bb9eaa 100644\n--- a/src/DataTypes/DataTypeNumberBase.h\n+++ b/src/DataTypes/DataTypeNumberBase.h\n@@ -25,7 +25,7 @@ class DataTypeNumberBase : public IDataType\n     using ColumnType = ColumnVector<T>;\n \n     const char * getFamilyName() const override { return TypeName<T>.data(); }\n-    TypeIndex getTypeId() const override { return TypeId<T>; }\n+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }\n \n     Field getDefault() const override;\n \ndiff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex 199f7796f025..fb590dd1d4b2 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -38,7 +38,7 @@ class DataTypeDecimal final : public DataTypeDecimalBase<T>\n \n     const char * getFamilyName() const override { return family_name; }\n     std::string doGetName() const override;\n-    TypeIndex getTypeId() const override { return TypeId<T>; }\n+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }\n     bool canBePromoted() const override { return true; }\n     DataTypePtr promoteNumericType() const override;\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 864dde0e86e0..da4bb448e39c 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -473,7 +473,7 @@ template <typename T, typename DataType>\n inline bool isColumnedAsDecimalT(const DataType & data_type)\n {\n     const WhichDataType which(data_type);\n-    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>;\n+    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeToTypeIndex<T>;\n }\n \n template <typename T>\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex 21d430312048..4bf8419df5ba 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -1,17 +1,20 @@\n-#include \"DictionaryStructure.h\"\n+#include <Dictionaries/DictionaryStructure.h>\n+\n+#include <numeric>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include <IO/WriteHelpers.h>\n+#include <IO/Operators.h>\n+\n+#include <Common/StringUtils/StringUtils.h>\n+\n+#include <Formats/FormatSettings.h>\n #include <Columns/IColumn.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Functions/FunctionHelpers.h>\n-#include <Formats/FormatSettings.h>\n-#include <IO/WriteHelpers.h>\n-#include <IO/Operators.h>\n-#include <Common/StringUtils/StringUtils.h>\n-\n-#include <numeric>\n-#include <unordered_map>\n-#include <unordered_set>\n \n \n namespace DB\n@@ -38,13 +41,14 @@ DictionaryTypedSpecialAttribute makeDictionaryTypedSpecialAttribute(\n     return DictionaryTypedSpecialAttribute{std::move(name), std::move(expression), DataTypeFactory::instance().get(type_name)};\n }\n \n-std::optional<AttributeUnderlyingType> maybeGetAttributeUnderlyingType(TypeIndex index)\n+std::optional<AttributeUnderlyingType> tryGetAttributeUnderlyingType(TypeIndex index)\n {\n     switch (index) /// Special cases which do not map TypeIndex::T -> AttributeUnderlyingType::T\n     {\n         case TypeIndex::Date:       return AttributeUnderlyingType::UInt16;\n+        case TypeIndex::Date32:     return AttributeUnderlyingType::Int32;\n         case TypeIndex::DateTime:   return AttributeUnderlyingType::UInt32;\n-        case TypeIndex::DateTime64: return AttributeUnderlyingType::UInt64;\n+        case TypeIndex::DateTime64: return AttributeUnderlyingType::Int64;\n         default: break;\n     }\n \n@@ -296,7 +300,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n \n         auto non_nullable_type = removeNullable(initial_type);\n \n-        const auto underlying_type_opt = maybeGetAttributeUnderlyingType(non_nullable_type->getTypeId());\n+        const auto underlying_type_opt = tryGetAttributeUnderlyingType(non_nullable_type->getTypeId());\n \n         if (!underlying_type_opt)\n             throw Exception(ErrorCodes::UNKNOWN_TYPE,\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 4de00ddd259d..f0aa372ec9a6 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -26,7 +26,7 @@ using TypeIndexUnderlying = magic_enum::underlying_type_t<TypeIndex>;\n // We need to be able to map TypeIndex -> AttributeUnderlyingType and AttributeUnderlyingType -> real type\n // The first can be done by defining AttributeUnderlyingType enum values to TypeIndex values and then performing\n // a enum_cast.\n-// The second can be achieved by using ReverseTypeId\n+// The second can be achieved by using TypeIndexToType\n #define map_item(__T) __T = static_cast<TypeIndexUnderlying>(TypeIndex::__T)\n \n enum class AttributeUnderlyingType : TypeIndexUnderlying\n@@ -73,7 +73,7 @@ template <AttributeUnderlyingType type>\n struct DictionaryAttributeType\n {\n     /// Converts @c type to it underlying type e.g. AttributeUnderlyingType::UInt8 -> UInt8\n-    using AttributeType = ReverseTypeId<\n+    using AttributeType = TypeIndexToType<\n         static_cast<TypeIndex>(\n             static_cast<TypeIndexUnderlying>(type))>;\n };\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex f32d5df8a213..4f5f6ae483f4 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -32,7 +32,7 @@ void registerFunctionsConversion(FunctionFactory & factory)\n     factory.registerFunction<FunctionToDecimal256>();\n \n     factory.registerFunction<FunctionToDate>();\n-    /// MysQL compatibility alias.\n+    /// MySQL compatibility alias.\n     factory.registerFunction<FunctionToDate>(\"DATE\", FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionToDate32>();\n     factory.registerFunction<FunctionToDateTime>();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02152_dictionary_date32_type.reference b/tests/queries/0_stateless/02152_dictionary_date32_type.reference\nnew file mode 100644\nindex 000000000000..6cde3c4678b8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02152_dictionary_date32_type.reference\n@@ -0,0 +1,2 @@\n+0\t2019-05-05\n+2019-05-05\ndiff --git a/tests/queries/0_stateless/02152_dictionary_date32_type.sql b/tests/queries/0_stateless/02152_dictionary_date32_type.sql\nnew file mode 100644\nindex 000000000000..65547883acd9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02152_dictionary_date32_type.sql\n@@ -0,0 +1,24 @@\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table\n+(\n+    id UInt64,\n+    value Date32\n+) ENGINE=TinyLog;\n+\n+INSERT INTO test_table VALUES (0, toDate32('2019-05-05'));\n+\n+DROP DICTIONARY IF EXISTS test_dictionary;\n+CREATE DICTIONARY test_dictionary\n+(\n+    id UInt64,\n+    value Date32\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT * FROM test_dictionary;\n+SELECT dictGet('test_dictionary', 'value', toUInt64(0));\n+\n+DROP DICTIONARY test_dictionary;\n+DROP TABLE test_table;\n",
  "problem_statement": "Date32 datatype is not supported in dictionaries\nDate32 datatype is not supported in dictionaries. For example:\r\n```sql\r\nCREATE DICTIONARY testDate32\r\n(\r\n  date Date32\r\n)\r\nPRIMARY KEY date\r\nSOURCE(CLICKHOUSE(\r\n  host 'localhost'\r\n  query 'SELECT toDate32(now())'\r\n))\r\nLAYOUT(COMPLEX_KEY_HASHED())\r\nLIFETIME(0)\r\n```\r\n\r\n```\r\nDB::Exception: Unknown type Date32 for dictionary attribute. (UNKNOWN_TYPE) (version 21.12.2.17 (official build))\r\n```\n",
  "hints_text": "",
  "created_at": "2021-12-20T10:39:50Z"
}