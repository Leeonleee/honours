{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71855,
  "instance_id": "ClickHouse__ClickHouse-71855",
  "issue_numbers": [
    "68602"
  ],
  "base_commit": "66ff828faec7f9e90bfa2cd9f59d991d88f62e34",
  "patch": "diff --git a/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp b/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp\nindex dcf024bb46cb..fc122730b372 100644\n--- a/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp\n+++ b/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp\n@@ -12,9 +12,13 @@\n #include <Analyzer/HashUtils.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/ColumnNode.h>\n+#include <Analyzer/ValidationUtils.h>\n+\n+#include <ranges>\n \n namespace DB\n {\n+\n namespace Setting\n {\n     extern const SettingsBool force_grouping_standard_compatibility;\n@@ -27,6 +31,26 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+struct GroupByKeyComparator\n+{\n+    GroupByKeyComparator(QueryTreeNodePtr node_) /// NOLINT\n+        : node(std::move(node_))\n+        , hash(node->getTreeHash({.compare_aliases = false, .compare_types = true}))\n+    {}\n+\n+    bool operator==(const GroupByKeyComparator & other) const { return hash == other.hash && compareGroupByKeys(node, other.node); }\n+\n+    bool operator!=(const GroupByKeyComparator & other) const { return !(*this == other); }\n+\n+    struct Hasher { size_t operator()(const GroupByKeyComparator & key) const { return key.hash.low64; } };\n+\n+    QueryTreeNodePtr node = nullptr;\n+    CityHash_v1_0_2::uint128 hash;\n+};\n+\n+template <typename Value>\n+using AggredationKeyNodeMap = std::unordered_map<GroupByKeyComparator, Value, GroupByKeyComparator::Hasher>;\n+\n namespace\n {\n \n@@ -42,7 +66,7 @@ class GroupingFunctionResolveVisitor : public InDepthQueryTreeVisitorWithContext\n {\n public:\n     GroupingFunctionResolveVisitor(GroupByKind group_by_kind_,\n-        QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index_,\n+        AggredationKeyNodeMap<size_t> aggregation_key_to_index_,\n         ColumnNumbersList grouping_sets_keys_indices_,\n         ContextPtr context_)\n         : InDepthQueryTreeVisitorWithContext(std::move(context_))\n@@ -67,9 +91,12 @@ class GroupingFunctionResolveVisitor : public InDepthQueryTreeVisitorWithContext\n         {\n             auto it = aggregation_key_to_index.find(argument);\n             if (it == aggregation_key_to_index.end())\n+            {\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Argument {} of GROUPING function is not a part of GROUP BY clause\",\n-                    argument->formatASTForErrorMessage());\n+                    \"Argument {} of GROUPING function is not a part of GROUP BY clause [{}]\",\n+                    argument->formatASTForErrorMessage(),\n+                    fmt::join(aggregation_key_to_index | std::views::transform([](const auto & e) { return e.first.node->formatASTForErrorMessage(); }), \", \"));\n+            }\n \n             arguments_indexes.push_back(it->second);\n         }\n@@ -133,7 +160,7 @@ class GroupingFunctionResolveVisitor : public InDepthQueryTreeVisitorWithContext\n \n private:\n     GroupByKind group_by_kind;\n-    QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index;\n+    AggredationKeyNodeMap<size_t> aggregation_key_to_index;\n     ColumnNumbersList grouping_sets_keys_indexes;\n };\n \n@@ -142,7 +169,7 @@ void resolveGroupingFunctions(QueryTreeNodePtr & query_node, ContextPtr context)\n     auto & query_node_typed = query_node->as<QueryNode &>();\n \n     size_t aggregation_node_index = 0;\n-    QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index;\n+    AggredationKeyNodeMap<size_t> aggregation_key_to_index;\n \n     std::vector<QueryTreeNodes> grouping_sets_used_aggregation_keys_list;\n \ndiff --git a/src/Analyzer/ValidationUtils.cpp b/src/Analyzer/ValidationUtils.cpp\nindex d1ff3c916f8b..d6afe8c59d56 100644\n--- a/src/Analyzer/ValidationUtils.cpp\n+++ b/src/Analyzer/ValidationUtils.cpp\n@@ -80,6 +80,65 @@ void validateFilters(const QueryTreeNodePtr & query_node)\n         validateFilter(query_node_typed.getQualify(), \"QUALIFY\", query_node);\n }\n \n+bool areColumnSourcesEqual(const QueryTreeNodePtr & lhs, const QueryTreeNodePtr & rhs)\n+{\n+    using NodePair = std::pair<const IQueryTreeNode *, const IQueryTreeNode *>;\n+    std::vector<NodePair> nodes_to_process;\n+    nodes_to_process.emplace_back(lhs.get(), rhs.get());\n+\n+    while (!nodes_to_process.empty())\n+    {\n+        const auto [lhs_node, rhs_node] = nodes_to_process.back();\n+        nodes_to_process.pop_back();\n+\n+        if (lhs_node->getNodeType() != rhs_node->getNodeType())\n+            return false;\n+\n+        if (lhs_node->getNodeType() == QueryTreeNodeType::COLUMN)\n+        {\n+            const auto * lhs_column_node = lhs_node->as<ColumnNode>();\n+            const auto * rhs_column_node = rhs_node->as<ColumnNode>();\n+            if (!lhs_column_node->getColumnSource()->isEqual(*rhs_column_node->getColumnSource()))\n+                return false;\n+        }\n+\n+        const auto & lhs_children = lhs_node->getChildren();\n+        const auto & rhs_children = rhs_node->getChildren();\n+        if (lhs_children.size() != rhs_children.size())\n+            return false;\n+\n+        for (size_t i = 0; i < lhs_children.size(); ++i)\n+        {\n+            const auto & lhs_child = lhs_children[i];\n+            const auto & rhs_child = rhs_children[i];\n+\n+            if (!lhs_child && !rhs_child)\n+                continue;\n+            if (lhs_child && !rhs_child)\n+                return false;\n+            if (!lhs_child && rhs_child)\n+                return false;\n+\n+            nodes_to_process.emplace_back(lhs_child.get(), rhs_child.get());\n+        }\n+    }\n+    return true;\n+}\n+\n+bool compareGroupByKeys(const QueryTreeNodePtr & node, const QueryTreeNodePtr & group_by_key_node)\n+{\n+    if (node->isEqual(*group_by_key_node, {.compare_aliases = false}))\n+    {\n+        /** Column sources should be compared with aliases for correct GROUP BY keys validation,\n+            * otherwise t2.x and t1.x will be considered as the same column:\n+            * SELECT t2.x FROM t1 JOIN t1 as t2 ON t1.x = t2.x GROUP BY t1.x;\n+            */\n+        if (areColumnSourcesEqual(node, group_by_key_node))\n+            return true;\n+    }\n+    return false;\n+}\n+\n namespace\n {\n \n@@ -154,51 +213,6 @@ class ValidateGroupByColumnsVisitor : public ConstInDepthQueryTreeVisitor<Valida\n \n private:\n \n-    static bool areColumnSourcesEqual(const QueryTreeNodePtr & lhs, const QueryTreeNodePtr & rhs)\n-    {\n-        using NodePair = std::pair<const IQueryTreeNode *, const IQueryTreeNode *>;\n-        std::vector<NodePair> nodes_to_process;\n-        nodes_to_process.emplace_back(lhs.get(), rhs.get());\n-\n-        while (!nodes_to_process.empty())\n-        {\n-            const auto [lhs_node, rhs_node] = nodes_to_process.back();\n-            nodes_to_process.pop_back();\n-\n-            if (lhs_node->getNodeType() != rhs_node->getNodeType())\n-                return false;\n-\n-            if (lhs_node->getNodeType() == QueryTreeNodeType::COLUMN)\n-            {\n-                const auto * lhs_column_node = lhs_node->as<ColumnNode>();\n-                const auto * rhs_column_node = rhs_node->as<ColumnNode>();\n-                if (!lhs_column_node->getColumnSource()->isEqual(*rhs_column_node->getColumnSource()))\n-                    return false;\n-            }\n-\n-            const auto & lhs_children = lhs_node->getChildren();\n-            const auto & rhs_children = rhs_node->getChildren();\n-            if (lhs_children.size() != rhs_children.size())\n-                return false;\n-\n-            for (size_t i = 0; i < lhs_children.size(); ++i)\n-            {\n-                const auto & lhs_child = lhs_children[i];\n-                const auto & rhs_child = rhs_children[i];\n-\n-                if (!lhs_child && !rhs_child)\n-                    continue;\n-                if (lhs_child && !rhs_child)\n-                    return false;\n-                if (!lhs_child && rhs_child)\n-                    return false;\n-\n-                nodes_to_process.emplace_back(lhs_child.get(), rhs_child.get());\n-            }\n-        }\n-        return true;\n-    }\n-\n     bool nodeIsAggregateFunctionOrInGroupByKeys(const QueryTreeNodePtr & node) const\n     {\n         if (auto * function_node = node->as<FunctionNode>())\n@@ -207,15 +221,8 @@ class ValidateGroupByColumnsVisitor : public ConstInDepthQueryTreeVisitor<Valida\n \n         for (const auto & group_by_key_node : group_by_keys_nodes)\n         {\n-            if (node->isEqual(*group_by_key_node, {.compare_aliases = false}))\n-            {\n-                /** Column sources should be compared with aliases for correct GROUP BY keys validation,\n-                  * otherwise t2.x and t1.x will be considered as the same column:\n-                  * SELECT t2.x FROM t1 JOIN t1 as t2 ON t1.x = t2.x GROUP BY t1.x;\n-                  */\n-                if (areColumnSourcesEqual(node, group_by_key_node))\n-                    return true;\n-            }\n+            if (compareGroupByKeys(node, group_by_key_node))\n+                return true;\n         }\n \n         return false;\ndiff --git a/src/Analyzer/ValidationUtils.h b/src/Analyzer/ValidationUtils.h\nindex 3041447af175..df2cdb0d52f7 100644\n--- a/src/Analyzer/ValidationUtils.h\n+++ b/src/Analyzer/ValidationUtils.h\n@@ -41,4 +41,10 @@ void validateTreeSize(const QueryTreeNodePtr & node,\n     size_t max_size,\n     std::unordered_map<QueryTreeNodePtr, size_t> & node_to_tree_size);\n \n+\n+/** Compare node with group by key node.\n+  * Such comparison does not take into account aliases, but checks types and column sources.\n+  */\n+bool compareGroupByKeys(const QueryTreeNodePtr & node, const QueryTreeNodePtr & group_by_key_node);\n+\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03259_grouping_sets_aliases.reference b/tests/queries/0_stateless/03259_grouping_sets_aliases.reference\nnew file mode 100644\nindex 000000000000..80711029676d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03259_grouping_sets_aliases.reference\n@@ -0,0 +1,2 @@\n+LOW\t2\t0\n+HIGH\t1\t0\ndiff --git a/tests/queries/0_stateless/03259_grouping_sets_aliases.sql b/tests/queries/0_stateless/03259_grouping_sets_aliases.sql\nnew file mode 100644\nindex 000000000000..80ab800865fb\n--- /dev/null\n+++ b/tests/queries/0_stateless/03259_grouping_sets_aliases.sql\n@@ -0,0 +1,9 @@\n+DROP TABLE IF EXISTS users;\n+CREATE TABLE users (name String, score UInt8, user_level String ALIAS multiIf(score <= 3, 'LOW', score <= 6, 'MEDIUM', 'HIGH') ) ENGINE=MergeTree ORDER BY name;\n+\n+INSERT INTO users VALUES ('a',1),('b',2),('c', 50);\n+\n+SELECT user_level as level_alias, uniq(name) as name_alias, grouping(level_alias) as _totals\n+FROM remote('127.0.0.{1,2}', currentDatabase(), users)\n+GROUP BY GROUPING SETS ((level_alias))\n+ORDER BY name_alias DESC;\n",
  "problem_statement": "GROUPING function casue error when input is ALIAS on distribured table\nDescribe what's wrong\r\n\r\nGROUPING function doesn't recognize ALIAS column and throw an error on distribured table \r\nWhen I use `allow_experimental_analyzer=0` it working without errors\r\n\r\nDoes it reproduce on the most recent release?\r\n\r\nYes, on latest \r\nhttps://fiddle.clickhouse.com/49d59283-0fc2-4be1-91c0-a3882c31a0a5\r\n\r\nHow to reproduce\r\n```\r\nCREATE TABLE users (name String, score UInt8, user_level String ALIAS multiIf(score <= 3, 'LOW', score <= 6, 'MEDIUM', 'HIGH') ) ENGINE=Memory;\r\n\r\nINSERT INTO users VALUES ('a',1);\r\nINSERT INTO users VALUES ('b',2);\r\nINSERT INTO users VALUES ( 'c', 50);\r\n\r\nSELECT  user_level as level_alias,uniq(name) as name_alias, grouping (level_alias) as _totals \r\nFROM remote('127.0.0.{1,2}', default, users)\r\nGROUP BY\r\n\tGROUPING SETS ((level_alias),\r\n\t())\r\n```\r\n\r\nExpected behavior\r\n\r\nThe GROUPING should recongize the alias column and retured results\n",
  "hints_text": "@Sigma711, you are absolutely right. However, for some reason, it doesn\u2019t hold in the mentioned query, so it appears to be an internal bug. I assume this may not be particularly interesting for contributors to fix.\r\nIf you\u2019re interested in taking on an issue, I\u2019d recommend choosing something more enjoyable from this list of [easy tasks](https://github.com/ClickHouse/ClickHouse/issues?q=sort%3Aupdated-desc+is%3Aissue+is%3Aopen+label%3A%22easy+task%22+) or [warm-up tasks](https://github.com/ClickHouse/ClickHouse/issues?q=sort%3Aupdated-desc+is%3Aissue+is%3Aopen+label%3A%22warmup+task%22+).\r\n\r\nThanks so much for your enthusiasm!\r\n",
  "created_at": "2024-11-13T11:01:12Z"
}