{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50181,
  "instance_id": "ClickHouse__ClickHouse-50181",
  "issue_numbers": [
    "49887"
  ],
  "base_commit": "6feac7bab7059568a1205b5663baa90fe94a59ac",
  "patch": "diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex 6804e85c4cf7..5e8f2ab8e610 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -573,4 +573,36 @@ void replaceColumns(QueryTreeNodePtr & node,\n     visitor.visit(node);\n }\n \n+namespace\n+{\n+\n+class CollectIdentifiersFullNamesVisitor : public ConstInDepthQueryTreeVisitor<CollectIdentifiersFullNamesVisitor>\n+{\n+public:\n+    explicit CollectIdentifiersFullNamesVisitor(NameSet & used_identifiers_)\n+        : used_identifiers(used_identifiers_) { }\n+\n+    static bool needChildVisit(const QueryTreeNodePtr &, const QueryTreeNodePtr &) { return true; }\n+\n+    void visitImpl(const QueryTreeNodePtr & node)\n+    {\n+        auto * column_node = node->as<IdentifierNode>();\n+        if (!column_node)\n+            return;\n+\n+        used_identifiers.insert(column_node->getIdentifier().getFullName());\n+    }\n+\n+    NameSet & used_identifiers;\n+};\n+\n+}\n+\n+NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node)\n+{\n+    NameSet out;\n+    CollectIdentifiersFullNamesVisitor visitor(out);\n+    visitor.visit(node);\n+    return out;\n+}\n }\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex ea36e17bf11f..6756c4d313c3 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -83,4 +83,8 @@ void replaceColumns(QueryTreeNodePtr & node,\n     const QueryTreeNodePtr & table_expression_node,\n     const std::unordered_map<std::string, QueryTreeNodePtr> & column_name_to_node);\n \n+\n+/// Just collect all identifiers from query tree\n+NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);\n+\n }\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 3ade4474b6b8..c6fa17583b51 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -845,6 +845,12 @@ bool AlterCommand::isRemovingProperty() const\n     return to_remove != RemoveProperty::NO_PROPERTY;\n }\n \n+bool AlterCommand::isDropSomething() const\n+{\n+    return type == Type::DROP_COLUMN || type == Type::DROP_INDEX\n+        || type == Type::DROP_CONSTRAINT || type == Type::DROP_PROJECTION;\n+}\n+\n std::optional<MutationCommand> AlterCommand::tryConvertToMutationCommand(StorageInMemoryMetadata & metadata, ContextPtr context) const\n {\n     if (!isRequireMutationStage(metadata))\ndiff --git a/src/Storages/AlterCommands.h b/src/Storages/AlterCommands.h\nindex c06872f9757d..74a11d2beaac 100644\n--- a/src/Storages/AlterCommands.h\n+++ b/src/Storages/AlterCommands.h\n@@ -167,6 +167,8 @@ struct AlterCommand\n     /// Command removing some property from column or table\n     bool isRemovingProperty() const;\n \n+    bool isDropSomething() const;\n+\n     /// If possible, convert alter command to mutation command. In other case\n     /// return empty optional. Some storages may execute mutations after\n     /// metadata changes.\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex d6c39da48e24..5f11f54f131e 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1,25 +1,27 @@\n #include <Storages/MergeTree/MergeTreeData.h>\n \n #include <AggregateFunctions/AggregateFunctionCount.h>\n+#include <Analyzer/QueryTreeBuilder.h>\n+#include <Analyzer/Utils.h>\n #include <Backups/BackupEntriesCollector.h>\n #include <Backups/BackupEntryFromSmallFile.h>\n #include <Backups/BackupEntryWrappedWith.h>\n #include <Backups/IBackup.h>\n #include <Backups/RestorerFromBackup.h>\n-#include <Common/escapeForFileName.h>\n+#include <Common/Config/ConfigHelper.h>\n+#include <Common/CurrentMetrics.h>\n #include <Common/Increment.h>\n-#include <Common/noexcept_scope.h>\n #include <Common/ProfileEventsScope.h>\n-#include <Common/quoteString.h>\n-#include <Common/scope_guard_safe.h>\n #include <Common/SimpleIncrement.h>\n #include <Common/Stopwatch.h>\n #include <Common/StringUtils/StringUtils.h>\n-#include <Common/typeid_cast.h>\n-#include <Common/CurrentMetrics.h>\n #include <Common/ThreadFuzzer.h>\n+#include <Common/escapeForFileName.h>\n #include <Common/getNumberOfPhysicalCPUCores.h>\n-#include <Common/Config/ConfigHelper.h>\n+#include <Common/noexcept_scope.h>\n+#include <Common/quoteString.h>\n+#include <Common/scope_guard_safe.h>\n+#include <Common/typeid_cast.h>\n #include <Storages/MergeTree/RangesInDataPart.h>\n #include <Compression/CompressedReadBuffer.h>\n #include <Core/QueryProcessingStage.h>\n@@ -27,31 +29,29 @@\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeUUID.h>\n-#include <DataTypes/hasNullable.h>\n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/ObjectUtils.h>\n-#include <Disks/createVolume.h>\n+#include <DataTypes/hasNullable.h>\n #include <Disks/ObjectStorages/DiskObjectStorage.h>\n #include <Disks/TemporaryFileOnDisk.h>\n+#include <Disks/createVolume.h>\n #include <Functions/IFunction.h>\n+#include <IO/Operators.h>\n+#include <IO/S3Common.h>\n+#include <IO/SharedThreadPools.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <IO/WriteHelpers.h>\n #include <Interpreters/Aggregator.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/convertFieldToType.h>\n #include <Interpreters/evaluateConstantExpression.h>\n-#include <Interpreters/ReplaceQueryParameterVisitor.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n-#include <Interpreters/inplaceBlockConversions.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Interpreters/MergeTreeTransaction.h>\n #include <Interpreters/PartLog.h>\n #include <Interpreters/TransactionLog.h>\n #include <Interpreters/TreeRewriter.h>\n-#include <Interpreters/Context_fwd.h>\n-#include <IO/S3Common.h>\n-#include <IO/WriteHelpers.h>\n-#include <IO/Operators.h>\n-#include <IO/WriteBufferFromString.h>\n-#include <IO/SharedThreadPools.h>\n+#include <Interpreters/inplaceBlockConversions.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTIndexDeclaration.h>\n #include <Parsers/ASTHelpers.h>\n@@ -65,25 +65,24 @@\n #include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n #include <Parsers/ASTAlterQuery.h>\n-#include <Parsers/ASTQueryParameter.h>\n #include <Processors/Formats/IInputFormat.h>\n #include <Processors/QueryPlan/QueryIdHolder.h>\n #include <Processors/QueryPlan/ReadFromMergeTree.h>\n #include <Storages/AlterCommands.h>\n+#include <Storages/BlockNumberColumn.h>\n #include <Storages/Freeze.h>\n-#include <Storages/MergeTree/checkDataPart.h>\n-#include <Storages/MergeTree/MergeTreeSelectProcessor.h>\n+#include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n+#include <Storages/MergeTree/MergeTreeDataPartBuilder.h>\n #include <Storages/MergeTree/MergeTreeDataPartCompact.h>\n #include <Storages/MergeTree/MergeTreeDataPartInMemory.h>\n #include <Storages/MergeTree/MergeTreeDataPartWide.h>\n-#include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n+#include <Storages/MergeTree/MergeTreeSelectProcessor.h>\n+#include <Storages/MergeTree/checkDataPart.h>\n+#include <Storages/MutationCommands.h>\n #include <Storages/MergeTree/ActiveDataPartSet.h>\n #include <Storages/StorageMergeTree.h>\n #include <Storages/StorageReplicatedMergeTree.h>\n #include <Storages/VirtualColumnUtils.h>\n-#include <Storages/MergeTree/MergeTreeDataPartBuilder.h>\n-#include <Storages/MutationCommands.h>\n-#include <Storages/BlockNumberColumn.h>\n \n #include <boost/range/algorithm_ext/erase.hpp>\n #include <boost/algorithm/string/join.hpp>\n@@ -2967,9 +2966,11 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n \n     NamesAndTypesList columns_to_check_conversion;\n \n+    auto unfinished_mutations = getUnfinishedMutationCommands();\n     std::optional<NameDependencies> name_deps{};\n     for (const AlterCommand & command : commands)\n     {\n+        checkDropCommandDoesntAffectInProgressMutations(command, unfinished_mutations, local_context);\n         /// Just validate partition expression\n         if (command.partition)\n         {\n@@ -4323,7 +4324,7 @@ void MergeTreeData::delayMutationOrThrowIfNeeded(Poco::Event * until, const Cont\n     if (!num_mutations_to_delay && !num_mutations_to_throw)\n         return;\n \n-    size_t num_unfinished_mutations = getNumberOfUnfinishedMutations();\n+    size_t num_unfinished_mutations = getUnfinishedMutationCommands().size();\n     if (num_mutations_to_throw && num_unfinished_mutations >= num_mutations_to_throw)\n     {\n         ProfileEvents::increment(ProfileEvents::RejectedMutations);\n@@ -7601,6 +7602,70 @@ bool MergeTreeData::canUsePolymorphicParts() const\n     return canUsePolymorphicParts(*getSettings(), unused);\n }\n \n+\n+void MergeTreeData::checkDropCommandDoesntAffectInProgressMutations(const AlterCommand & command, const std::map<std::string, MutationCommands> & unfinished_mutations, ContextPtr local_context) const\n+{\n+    if (!command.isDropSomething() || unfinished_mutations.empty())\n+        return;\n+\n+    auto throw_exception = [] (\n+        const std::string & mutation_name,\n+        const std::string & entity_name,\n+        const std::string & identifier_name)\n+    {\n+        throw Exception(\n+            ErrorCodes::BAD_ARGUMENTS,\n+            \"Cannot drop {} {} because it's affected by mutation with ID '{}' which is not finished yet. \"\n+            \"Wait this mutation, or KILL it with command \"\n+            \"\\\"KILL MUTATION WHERE mutation_id = '{}'\\\"\",\n+            entity_name,\n+            backQuoteIfNeed(identifier_name),\n+            mutation_name,\n+            mutation_name);\n+    };\n+\n+    for (const auto & [mutation_name, commands] : unfinished_mutations)\n+    {\n+        for (const MutationCommand & mutation_command : commands)\n+        {\n+            if (command.type == AlterCommand::DROP_INDEX && mutation_command.index_name == command.index_name)\n+            {\n+                throw_exception(mutation_name, \"index\", command.index_name);\n+            }\n+            else if (command.type == AlterCommand::DROP_PROJECTION\n+                     && mutation_command.projection_name == command.projection_name)\n+            {\n+                throw_exception(mutation_name, \"projection\", command.projection_name);\n+            }\n+            else if (command.type == AlterCommand::DROP_COLUMN)\n+            {\n+                if (mutation_command.column_name == command.column_name)\n+                    throw_exception(mutation_name, \"column\", command.column_name);\n+\n+                if (mutation_command.predicate)\n+                {\n+                    auto query_tree = buildQueryTree(mutation_command.predicate, local_context);\n+                    auto identifiers = collectIdentifiersFullNames(query_tree);\n+\n+                    if (identifiers.contains(command.column_name))\n+                        throw_exception(mutation_name, \"column\", command.column_name);\n+                }\n+\n+                for (const auto & [name, expr] : mutation_command.column_to_update_expression)\n+                {\n+                    if (name == command.column_name)\n+                        throw_exception(mutation_name, \"column\", command.column_name);\n+\n+                    auto query_tree = buildQueryTree(expr, local_context);\n+                    auto identifiers = collectIdentifiersFullNames(query_tree);\n+                    if (identifiers.contains(command.column_name))\n+                        throw_exception(mutation_name, \"column\", command.column_name);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n bool MergeTreeData::canUsePolymorphicParts(const MergeTreeSettings & settings, String & out_reason) const\n {\n     if (!canUseAdaptiveGranularity())\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex a8dac7cbade4..600f5058f73d 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -47,6 +47,7 @@ namespace DB\n /// Number of streams is not number parts, but number or parts*files, hence 1000.\n const size_t DEFAULT_DELAYED_STREAMS_FOR_PARALLEL_WRITE = 1000;\n \n+struct AlterCommand;\n class AlterCommands;\n class MergeTreePartsMover;\n class MergeTreeDataMergerMutator;\n@@ -579,9 +580,6 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// The decision to delay or throw is made according to settings 'number_of_mutations_to_delay' and 'number_of_mutations_to_throw'.\n     void delayMutationOrThrowIfNeeded(Poco::Event * until, const ContextPtr & query_context) const;\n \n-    /// Returns number of unfinished mutations (is_done = 0).\n-    virtual size_t getNumberOfUnfinishedMutations() const = 0;\n-\n     /// Renames temporary part to a permanent part and adds it to the parts set.\n     /// It is assumed that the part does not intersect with existing parts.\n     /// Adds the part in the PreActive state (the part will be added to the active set later with out_transaction->commit()).\n@@ -718,6 +716,13 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// If something is wrong, throws an exception.\n     void checkAlterIsPossible(const AlterCommands & commands, ContextPtr context) const override;\n \n+    /// Throw exception if command is some kind of DROP command (drop column, drop index, etc)\n+    /// and we have unfinished mutation which need this column to finish.\n+    void checkDropCommandDoesntAffectInProgressMutations(\n+        const AlterCommand & command, const std::map<std::string, MutationCommands> & unfinished_mutations, ContextPtr context) const;\n+    /// Return mapping unfinished mutation name -> Mutation command\n+    virtual std::map<std::string, MutationCommands> getUnfinishedMutationCommands() const = 0;\n+\n     /// Checks if the Mutation can be performed.\n     /// (currently no additional checks: always ok)\n     void checkMutationIsPossible(const MutationCommands & commands, const Settings & settings) const override;\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex aeaeb4168afd..bb74c4dd7bb6 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -8,6 +8,7 @@\n #include <IO/WriteHelpers.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/CurrentMetrics.h>\n+#include \"Storages/MutationCommands.h\"\n #include <Parsers/formatAST.h>\n #include <base/sort.h>\n \n@@ -557,7 +558,7 @@ bool ReplicatedMergeTreeQueue::removeFailedQuorumPart(const MergeTreePartInfo &\n     return virtual_parts.remove(part_info);\n }\n \n-int32_t ReplicatedMergeTreeQueue::pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallback watch_callback, PullLogsReason reason)\n+std::pair<int32_t, int32_t> ReplicatedMergeTreeQueue::pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallback watch_callback, PullLogsReason reason)\n {\n     std::lock_guard lock(pull_logs_to_queue_mutex);\n \n@@ -589,7 +590,7 @@ int32_t ReplicatedMergeTreeQueue::pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper\n     /// in the queue.\n     /// With this we ensure that if you read the log state L1 and then the state of mutations M1,\n     /// then L1 \"happened-before\" M1.\n-    updateMutations(zookeeper);\n+    int32_t mutations_version = updateMutations(zookeeper);\n \n     if (index_str.empty())\n     {\n@@ -718,7 +719,7 @@ int32_t ReplicatedMergeTreeQueue::pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper\n         storage.background_operations_assignee.trigger();\n     }\n \n-    return stat.version;\n+    return std::pair{stat.version, mutations_version};\n }\n \n \n@@ -857,11 +858,12 @@ ActiveDataPartSet getPartNamesToMutate(\n \n }\n \n-void ReplicatedMergeTreeQueue::updateMutations(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallbackPtr watch_callback)\n+int32_t ReplicatedMergeTreeQueue::updateMutations(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallbackPtr watch_callback)\n {\n     std::lock_guard lock(update_mutations_mutex);\n \n-    Strings entries_in_zk = zookeeper->getChildrenWatch(fs::path(zookeeper_path) / \"mutations\", nullptr, watch_callback);\n+    Coordination::Stat mutations_stat;\n+    Strings entries_in_zk = zookeeper->getChildrenWatch(fs::path(zookeeper_path) / \"mutations\", &mutations_stat, watch_callback);\n     StringSet entries_in_zk_set(entries_in_zk.begin(), entries_in_zk.end());\n \n     /// Compare with the local state, delete obsolete entries and determine which new entries to load.\n@@ -976,6 +978,7 @@ void ReplicatedMergeTreeQueue::updateMutations(zkutil::ZooKeeperPtr zookeeper, C\n         if (some_mutations_are_probably_done)\n             storage.mutations_finalizing_task->schedule();\n     }\n+    return mutations_stat.version;\n }\n \n \n@@ -1761,22 +1764,21 @@ size_t ReplicatedMergeTreeQueue::countFinishedMutations() const\n     return count;\n }\n \n-size_t ReplicatedMergeTreeQueue::countUnfinishedMutations() const\n+std::map<std::string, MutationCommands> ReplicatedMergeTreeQueue::getUnfinishedMutations() const\n {\n+    std::map<std::string, MutationCommands> result;\n     std::lock_guard lock(state_mutex);\n \n-    size_t count = 0;\n-    for (const auto & [_, status] : mutations_by_znode | std::views::reverse)\n+    for (const auto & [name, status] : mutations_by_znode | std::views::reverse)\n     {\n         if (status.is_done)\n             break;\n-        ++count;\n+        result.emplace(name, status.entry->commands);\n     }\n \n-    return count;\n+    return result;\n }\n \n-\n ReplicatedMergeTreeMergePredicate ReplicatedMergeTreeQueue::getMergePredicate(zkutil::ZooKeeperPtr & zookeeper,\n                                                                               std::optional<PartitionIdsHint> && partition_ids_hint)\n {\n@@ -2211,7 +2213,7 @@ ReplicatedMergeTreeMergePredicate::ReplicatedMergeTreeMergePredicate(\n \n     committing_blocks = std::make_shared<CommittingBlocks>(getCommittingBlocks(zookeeper, queue.zookeeper_path, queue.log));\n \n-    merges_version = queue_.pullLogsToQueue(zookeeper, {}, ReplicatedMergeTreeQueue::MERGE_PREDICATE);\n+    std::tie(merges_version, std::ignore) = queue_.pullLogsToQueue(zookeeper, {}, ReplicatedMergeTreeQueue::MERGE_PREDICATE);\n \n     {\n         /// We avoid returning here a version to be used in a lightweight transaction.\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\nindex 292046112004..ae8ae623a302 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n@@ -331,11 +331,11 @@ class ReplicatedMergeTreeQueue\n       * Additionally loads mutations (so that the set of mutations is always more recent than the queue).\n       * Return the version of \"logs\" node (that is updated for every merge/mutation/... added to the log)\n       */\n-    int32_t pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallback watch_callback = {}, PullLogsReason reason = OTHER);\n+    std::pair<int32_t, int32_t> pullLogsToQueue(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallback watch_callback = {}, PullLogsReason reason = OTHER);\n \n     /// Load new mutation entries. If something new is loaded, schedule storage.merge_selecting_task.\n     /// If watch_callback is not empty, will call it when new mutations appear in ZK.\n-    void updateMutations(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallbackPtr watch_callback = {});\n+    int32_t updateMutations(zkutil::ZooKeeperPtr zookeeper, Coordination::WatchCallbackPtr watch_callback = {});\n \n     /// Remove a mutation from ZooKeeper and from the local set. Returns the removed entry or nullptr\n     /// if it could not be found. Called during KILL MUTATION query execution.\n@@ -388,12 +388,12 @@ class ReplicatedMergeTreeQueue\n \n     /// Count the total number of active mutations that are finished (is_done = true).\n     size_t countFinishedMutations() const;\n-    /// Count the total number of active mutations that are not finished (is_done = false).\n-    size_t countUnfinishedMutations() const;\n+\n+    std::map<std::string, MutationCommands> getUnfinishedMutations() const;\n \n     /// Returns functor which used by MergeTreeMergerMutator to select parts for merge\n-    ReplicatedMergeTreeMergePredicate getMergePredicate(zkutil::ZooKeeperPtr & zookeeper,\n-                                                        std::optional<PartitionIdsHint> && partition_ids_hint);\n+    ReplicatedMergeTreeMergePredicate\n+    getMergePredicate(zkutil::ZooKeeperPtr & zookeeper, std::optional<PartitionIdsHint> && partition_ids_hint);\n \n     MutationCommands getMutationCommands(const MergeTreeData::DataPartPtr & part, Int64 desired_mutation_version,\n                                          Strings & mutation_ids) const;\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex a1523346395d..293991e315f9 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -707,6 +707,33 @@ std::optional<MergeTreeMutationStatus> StorageMergeTree::getIncompleteMutationsS\n     return result;\n }\n \n+std::map<std::string, MutationCommands> StorageMergeTree::getUnfinishedMutationCommands() const\n+{\n+    std::lock_guard lock(currently_processing_in_background_mutex);\n+    std::vector<PartVersionWithName> part_versions_with_names;\n+    auto data_parts = getDataPartsVectorForInternalUsage();\n+    part_versions_with_names.reserve(data_parts.size());\n+    for (const auto & part : data_parts)\n+        part_versions_with_names.emplace_back(PartVersionWithName{part->info.getDataVersion(), part->name});\n+    std::sort(part_versions_with_names.begin(), part_versions_with_names.end(), comparator);\n+\n+    std::map<std::string, MutationCommands> result;\n+\n+    for (const auto & kv : current_mutations_by_version)\n+    {\n+        Int64 mutation_version = kv.first;\n+        const MergeTreeMutationEntry & entry = kv.second;\n+        const PartVersionWithName needle{mutation_version, \"\"};\n+        auto versions_it = std::lower_bound(\n+            part_versions_with_names.begin(), part_versions_with_names.end(), needle, comparator);\n+\n+        size_t parts_to_do = versions_it - part_versions_with_names.begin();\n+        if (parts_to_do > 0)\n+            result.emplace(entry.file_name, entry.commands);\n+    }\n+    return result;\n+}\n+\n std::vector<MergeTreeMutationStatus> StorageMergeTree::getMutationsStatus() const\n {\n     std::lock_guard lock(currently_processing_in_background_mutex);\n@@ -1386,26 +1413,6 @@ bool StorageMergeTree::scheduleDataProcessingJob(BackgroundJobsAssignee & assign\n     return scheduled;\n }\n \n-size_t StorageMergeTree::getNumberOfUnfinishedMutations() const\n-{\n-    std::unique_lock lock(currently_processing_in_background_mutex);\n-\n-    size_t count = 0;\n-    for (const auto & [version, _] : current_mutations_by_version | std::views::reverse)\n-    {\n-        auto status = getIncompleteMutationsStatusUnlocked(version, lock, nullptr, true);\n-        if (!status)\n-            continue;\n-\n-        if (status->is_done)\n-            break;\n-\n-        ++count;\n-    }\n-\n-    return count;\n-}\n-\n UInt64 StorageMergeTree::getCurrentMutationVersion(\n     const DataPartPtr & part,\n     std::unique_lock<std::mutex> & /*currently_processing_in_background_mutex_lock*/) const\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex 89da9ab839e3..f0759d5c4db7 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -112,7 +112,7 @@ class StorageMergeTree final : public MergeTreeData\n \n     bool scheduleDataProcessingJob(BackgroundJobsAssignee & assignee) override;\n \n-    size_t getNumberOfUnfinishedMutations() const override;\n+    std::map<std::string, MutationCommands> getUnfinishedMutationCommands() const override;\n \n     MergeTreeDeduplicationLog * getDeduplicationLog() { return deduplication_log.get(); }\n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 14e1a65ce927..4be080df09cd 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -5739,6 +5739,7 @@ void StorageReplicatedMergeTree::alter(\n         return;\n     }\n \n+\n     auto ast_to_str = [](ASTPtr query) -> String\n     {\n         if (!query)\n@@ -5753,6 +5754,31 @@ void StorageReplicatedMergeTree::alter(\n \n     while (true)\n     {\n+        if (shutdown_called || partial_shutdown_called)\n+            throw Exception(ErrorCodes::ABORTED, \"Cannot assign alter because shutdown called\");\n+\n+        bool pulled_queue = false;\n+        std::optional<int32_t> maybe_mutations_version_after_logs_pull;\n+        std::map<std::string, MutationCommands> unfinished_mutations;\n+        for (const auto & command : commands)\n+        {\n+            if (command.isDropSomething())\n+            {\n+                if (shutdown_called || partial_shutdown_called)\n+                    throw Exception(ErrorCodes::ABORTED, \"Cannot assign alter because shutdown called\");\n+\n+                if (!pulled_queue)\n+                {\n+                    auto [_, mutations_version] = queue.pullLogsToQueue(zookeeper, {}, ReplicatedMergeTreeQueue::SYNC);\n+                    maybe_mutations_version_after_logs_pull.emplace(mutations_version);\n+                    unfinished_mutations = getUnfinishedMutationCommands();\n+                    pulled_queue = true;\n+                }\n+\n+                checkDropCommandDoesntAffectInProgressMutations(command, unfinished_mutations, query_context);\n+            }\n+        }\n+\n         /// Clear nodes from previous iteration\n         alter_entry.emplace();\n         mutation_znode.reset();\n@@ -5866,8 +5892,18 @@ void StorageReplicatedMergeTree::alter(\n             mutation_entry.source_replica = replica_name;\n             mutation_entry.commands = std::move(maybe_mutation_commands);\n \n-            Coordination::Stat mutations_stat;\n-            zookeeper->get(mutations_path, &mutations_stat);\n+            int32_t mutations_version;\n+            if (maybe_mutations_version_after_logs_pull.has_value())\n+            {\n+                mutations_version = *maybe_mutations_version_after_logs_pull;\n+            }\n+            else\n+            {\n+                Coordination::Stat mutations_stat;\n+                zookeeper->get(mutations_path, &mutations_stat);\n+                mutations_version = mutations_stat.version;\n+            }\n+\n \n             partition_block_numbers_holder =\n                 allocateBlockNumbersInAffectedPartitions(mutation_entry.commands, query_context, zookeeper);\n@@ -5875,7 +5911,7 @@ void StorageReplicatedMergeTree::alter(\n             mutation_entry.block_numbers = partition_block_numbers_holder.getBlockNumbers();\n             mutation_entry.create_time = time(nullptr);\n \n-            ops.emplace_back(zkutil::makeSetRequest(mutations_path, String(), mutations_stat.version));\n+            ops.emplace_back(zkutil::makeSetRequest(mutations_path, String(), mutations_version));\n             mutation_path_idx = ops.size();\n             ops.emplace_back(\n                 zkutil::makeCreateRequest(fs::path(mutations_path) / \"\", mutation_entry.toString(), zkutil::CreateMode::PersistentSequential));\n@@ -8701,9 +8737,9 @@ String StorageReplicatedMergeTree::getTableSharedID() const\n     return toString(table_shared_id);\n }\n \n-size_t StorageReplicatedMergeTree::getNumberOfUnfinishedMutations() const\n+std::map<std::string, MutationCommands> StorageReplicatedMergeTree::getUnfinishedMutationCommands() const\n {\n-    return queue.countUnfinishedMutations();\n+    return queue.getUnfinishedMutations();\n }\n \n void StorageReplicatedMergeTree::createTableSharedID() const\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex 794991d8e062..4e8fae6c6acd 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -347,7 +347,7 @@ class StorageReplicatedMergeTree final : public MergeTreeData\n     // Return table id, common for different replicas\n     String getTableSharedID() const override;\n \n-    size_t getNumberOfUnfinishedMutations() const override;\n+    std::map<std::string, MutationCommands> getUnfinishedMutationCommands() const override;\n \n     /// Returns the same as getTableSharedID(), but extracts it from a create query.\n     static std::optional<String> tryGetTableSharedIDFromCreateQuery(const IAST & create_query, const ContextPtr & global_context);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02597_column_delete_and_replication.reference b/tests/queries/0_stateless/02597_column_delete_and_replication.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02597_column_delete_and_replication.sql b/tests/queries/0_stateless/02597_column_delete_and_replication.sql\nnew file mode 100644\nindex 000000000000..b0257f666d91\n--- /dev/null\n+++ b/tests/queries/0_stateless/02597_column_delete_and_replication.sql\n@@ -0,0 +1,27 @@\n+CREATE TABLE test (\n+    `c_id` String,\n+    `p_id` String,\n+    `d` String\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '1')\n+ORDER BY (c_id, p_id);\n+\n+INSERT INTO test SELECT '1', '11', '111' FROM numbers(3);\n+\n+INSERT INTO test SELECT '2', '22', '22' FROM numbers(3);\n+\n+set mutations_sync=0;\n+\n+ALTER TABLE test UPDATE d = d || toString(sleepEachRow(0.3)) where 1;\n+\n+ALTER TABLE test ADD COLUMN x UInt32 default 0;\n+ALTER TABLE test UPDATE d = d || '1' where x = 42;\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2; --{serverError 36}\n+\n+ALTER TABLE test UPDATE x = x + 1 where 1 SETTINGS mutations_sync = 2;\n+\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2;\n+\n+select * from test format Null;\n+\n+DROP TABLE test;\ndiff --git a/tests/queries/0_stateless/02597_column_update_and_replication.reference b/tests/queries/0_stateless/02597_column_update_and_replication.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02597_column_update_and_replication.sql b/tests/queries/0_stateless/02597_column_update_and_replication.sql\nnew file mode 100644\nindex 000000000000..42fe813f8a10\n--- /dev/null\n+++ b/tests/queries/0_stateless/02597_column_update_and_replication.sql\n@@ -0,0 +1,27 @@\n+CREATE TABLE test (\n+    `c_id` String,\n+    `p_id` String,\n+    `d` String\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '1')\n+ORDER BY (c_id, p_id);\n+\n+INSERT INTO test SELECT '1', '11', '111' FROM numbers(3);\n+\n+INSERT INTO test SELECT '2', '22', '22' FROM numbers(3);\n+\n+set mutations_sync=0;\n+\n+ALTER TABLE test UPDATE d = d || toString(sleepEachRow(0.3)) where 1;\n+\n+ALTER TABLE test ADD COLUMN x UInt32 default 0;\n+ALTER TABLE test UPDATE x = x + 1 where 1;\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2; --{serverError 36}\n+\n+ALTER TABLE test UPDATE x = x + 1 where 1 SETTINGS mutations_sync = 2;\n+\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2;\n+\n+select * from test format Null;\n+\n+DROP TABLE test;\ndiff --git a/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.reference b/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.sql b/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.sql\nnew file mode 100644\nindex 000000000000..b07b3b545141\n--- /dev/null\n+++ b/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.sql\n@@ -0,0 +1,28 @@\n+CREATE TABLE test (\n+    `c_id` String,\n+    `p_id` String,\n+    `d` UInt32\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '1')\n+ORDER BY (c_id, p_id);\n+\n+INSERT INTO test SELECT '1', '11', '111' FROM numbers(3);\n+\n+INSERT INTO test SELECT '2', '22', '22' FROM numbers(3);\n+\n+set mutations_sync=0;\n+\n+ALTER TABLE test UPDATE d = d + sleepEachRow(0.3) where 1;\n+\n+ALTER TABLE test ADD COLUMN x UInt32 default 0;\n+ALTER TABLE test UPDATE d = x + 1 where 1;\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2; --{serverError 36}\n+\n+ALTER TABLE test UPDATE x = x + 1 where 1 SETTINGS mutations_sync = 2;\n+\n+ALTER TABLE test DROP COLUMN x SETTINGS mutations_sync = 2;\n+\n+select * from test format Null;\n+\n+DROP TABLE test;\n+\ndiff --git a/tests/queries/0_stateless/02597_projection_materialize_and_replication.reference b/tests/queries/0_stateless/02597_projection_materialize_and_replication.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02597_projection_materialize_and_replication.sql b/tests/queries/0_stateless/02597_projection_materialize_and_replication.sql\nnew file mode 100644\nindex 000000000000..031cb3cb6fbb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02597_projection_materialize_and_replication.sql\n@@ -0,0 +1,28 @@\n+CREATE TABLE test (\n+    `c_id` String,\n+    `p_id` String,\n+    `d` String\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '1')\n+ORDER BY (c_id, p_id);\n+\n+INSERT INTO test SELECT '1', '11', '111' FROM numbers(3);\n+\n+INSERT INTO test SELECT '2', '22', '22' FROM numbers(3);\n+\n+set mutations_sync=0;\n+\n+ALTER TABLE test UPDATE d = d || toString(sleepEachRow(0.3)) where 1;\n+\n+ALTER TABLE test ADD PROJECTION d_order ( SELECT min(c_id) GROUP BY `d`);\n+ALTER TABLE test MATERIALIZE PROJECTION d_order;\n+ALTER TABLE test DROP PROJECTION d_order SETTINGS mutations_sync = 2; --{serverError 36}\n+\n+-- just to wait prev mutation\n+ALTER TABLE test DELETE where d = 'Hello' SETTINGS mutations_sync = 2;\n+\n+ALTER TABLE test DROP PROJECTION d_order SETTINGS mutations_sync = 2;\n+\n+select * from test format Null;\n+\n+DROP TABLE test;\n",
  "problem_statement": "NO_SUCH_PROJECTION_IN_TABLE when doing ADD, MATERIALIZE, DROP projection on ReplicatedMergeTree\n```\r\nCREATE TABLE test (\r\n    `c_id` String,\r\n    `p_id` String,\r\n    `d` String\r\n)\r\nENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '1')\r\nORDER BY (c_id, p_id);\r\n\r\n\r\nCREATE TABLE test_r2 (\r\n    `c_id` String,\r\n    `p_id` String,\r\n    `d` String\r\n)\r\nENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/test_table', '2')\r\nORDER BY (c_id, p_id);\r\n\r\n\r\nINSERT INTO test SELECT '1', '11', '111' FROM numbers(3);\r\n\r\nINSERT INTO test SELECT '2', '22', '22' FROM numbers(3);\r\n\r\nselect * from test;\r\nselect min(c_id) from test group by d;\r\n\r\n\r\n-- do ADD, MATERIALIZE and DROP \r\nALTER TABLE test ADD PROJECTION d_order ( SELECT min(c_id) GROUP BY `d`);\r\n\r\nALTER TABLE test MATERIALIZE PROJECTION d_order;\r\n\r\nALTER TABLE test DROP PROJECTION d_order SETTINGS mutations_sync = 2;\r\n\r\nSELECT * FROM system.mutations WHERE database=currentDatabase() AND table='test' AND NOT is_done;\r\n\r\n\r\nselect * from test;\r\n\r\n\r\n--DROP TABLE test;\r\n```\r\n\r\nFails with an error\r\n\r\n```\r\n[davenger-xps] 2023.05.15 18:06:39.338512 [ 41829 ] {15bccf4d-1324-4a62-a8fc-8f7d99a03848} <Error> executeQuery: Code: 341. DB::Exception: Exception happened during execution of mutations '0000000000, 0000000001' with part 'all_1_1_0' reason: 'Code: 582. DB::Exception: There is no projection d_order in table. (NO_SUCH_PROJECTION_IN_TABLE) (version 23.5.1.1)'. This error maybe retryable or not. In case of unretryable error, mutation can be killed with KILL MUTATION query. (UNFINISHED) (version 23.5.1.1) (from 127.0.0.1:44518) (comment: 02597_projection_materialize_and_replication.sql) (in query: ALTER TABLE test DROP PROJECTION d_order SETTINGS mutations_sync = 2;), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. /home/davenger/src/ClickHouse/contrib/llvm-project/libcxx/include/exception:134: std::exception::capture() @ 0x000000002be6f722 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n1. /home/davenger/src/ClickHouse/contrib/llvm-project/libcxx/include/exception:112: std::exception::exception[abi:v15000]() @ 0x000000002be6f6db in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n2. /home/davenger/src/ClickHouse/base/poco/Foundation/src/Exception.cpp:27: Poco::Exception::Exception(String const&, int) @ 0x0000000067d3afe0 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n3. /home/davenger/src/ClickHouse/src/Common/Exception.cpp:90: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000004068851e in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n4. /home/davenger/src/ClickHouse/src/Common/Exception.h:54: DB::Exception::Exception(String&&, int, bool) @ 0x000000002be526e7 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n5. /home/davenger/src/ClickHouse/src/Common/Exception.h:81: DB::Exception::Exception<char const*, String, String&, String&>(int, FormatStringHelperImpl<std::type_identity<char const*>::type, std::type_identity<String>::type, std::type_identity<String&>::type, std::type_identity<String&>::type>, char const*&&, String&&, String&, String&) @ 0x0000000059c21f93 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n6. /home/davenger/src/ClickHouse/src/Storages/MergeTree/MergeTreeMutationStatus.cpp:26: DB::checkMutationStatus(std::optional<DB::MergeTreeMutationStatus>&, std::set<String, std::less<String>, std::allocator<String>> const&) @ 0x0000000059c2176c in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n7. /home/davenger/src/ClickHouse/src/Storages/StorageReplicatedMergeTree.cpp:614: DB::StorageReplicatedMergeTree::waitMutationToFinishOnReplicas(std::vector<String, std::allocator<String>> const&, String const&) const @ 0x000000005858d7fb in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n8. /home/davenger/src/ClickHouse/src/Storages/StorageReplicatedMergeTree.cpp:6540: DB::StorageReplicatedMergeTree::waitMutation(String const&, unsigned long) const @ 0x000000005865e8f0 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n9. /home/davenger/src/ClickHouse/src/Storages/StorageReplicatedMergeTree.cpp:5365: DB::StorageReplicatedMergeTree::alter(DB::AlterCommands const&, std::shared_ptr<DB::Context const>, std::unique_lock<std::timed_mutex>&) @ 0x000000005865caf1 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n10. /home/davenger/src/ClickHouse/src/Interpreters/InterpreterAlterQuery.cpp:193: DB::InterpreterAlterQuery::executeToTable(DB::ASTAlterQuery const&) @ 0x0000000055cbdc12 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n11. /home/davenger/src/ClickHouse/src/Interpreters/InterpreterAlterQuery.cpp:64: DB::InterpreterAlterQuery::execute() @ 0x0000000055cb92ef in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n12. /home/davenger/src/ClickHouse/src/Interpreters/executeQuery.cpp:717: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x0000000057232a1d in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n13. /home/davenger/src/ClickHouse/src/Interpreters/executeQuery.cpp:1173: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x000000005722ab62 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n14. /home/davenger/src/ClickHouse/src/Server/TCPHandler.cpp:420: DB::TCPHandler::runImpl() @ 0x000000005a86bd22 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n15. /home/davenger/src/ClickHouse/src/Server/TCPHandler.cpp:2043: DB::TCPHandler::run() @ 0x000000005a8924ca in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n16. /home/davenger/src/ClickHouse/base/poco/Net/src/TCPServerConnection.cpp:43: Poco::Net::TCPServerConnection::start() @ 0x000000006789fac5 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n17. /home/davenger/src/ClickHouse/base/poco/Net/src/TCPServerDispatcher.cpp:115: Poco::Net::TCPServerDispatcher::run() @ 0x00000000678a066d in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n18. /home/davenger/src/ClickHouse/base/poco/Foundation/src/ThreadPool.cpp:188: Poco::PooledThread::run() @ 0x0000000067e706b4 in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n19. /home/davenger/src/ClickHouse/base/poco/Foundation/src/Thread.cpp:46: Poco::(anonymous namespace)::RunnableHolder::run() @ 0x0000000067e690ca in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n20. /home/davenger/src/ClickHouse/base/poco/Foundation/src/Thread_POSIX.cpp:335: Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000067e668ef in /home/davenger/src/ClickHouse/build_Debug/programs/clickhouse\r\n21. ? @ 0x00007f44f4294b43 in ?\r\n22. ? @ 0x00007f44f4326a00 in ?\r\n\r\n```\n",
  "hints_text": "I cannot reproduce it in latest master. ",
  "created_at": "2023-05-24T11:06:03Z",
  "modified_files": [
    "src/Analyzer/Utils.cpp",
    "src/Analyzer/Utils.h",
    "src/Storages/AlterCommands.cpp",
    "src/Storages/AlterCommands.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageMergeTree.h",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02597_column_delete_and_replication.sql",
    "b/tests/queries/0_stateless/02597_column_update_and_replication.sql",
    "b/tests/queries/0_stateless/02597_column_update_tricy_expression_and_replication.sql",
    "b/tests/queries/0_stateless/02597_projection_materialize_and_replication.sql"
  ]
}