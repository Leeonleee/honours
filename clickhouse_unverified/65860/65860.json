{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 65860,
  "instance_id": "ClickHouse__ClickHouse-65860",
  "issue_numbers": [
    "44817"
  ],
  "base_commit": "a15fb8be75943c659e3837c752f2aeff1c74e2c8",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex 6b0b8fc5b505..0d731ed0e147 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -14,6 +14,7 @@\n #include <Databases/registerDatabases.h>\n #include <Databases/DatabaseFilesystem.h>\n #include <Databases/DatabaseMemory.h>\n+#include <Databases/DatabaseAtomic.h>\n #include <Databases/DatabasesOverlay.h>\n #include <Storages/System/attachSystemTables.h>\n #include <Storages/System/attachInformationSchemaTables.h>\n@@ -50,7 +51,6 @@\n #include <Dictionaries/registerDictionaries.h>\n #include <Disks/registerDisks.h>\n #include <Formats/registerFormats.h>\n-#include <boost/algorithm/string/replace.hpp>\n #include <boost/program_options/options_description.hpp>\n #include <base/argsToConfig.h>\n #include <filesystem>\n@@ -216,12 +216,12 @@ static DatabasePtr createMemoryDatabaseIfNotExists(ContextPtr context, const Str\n     return system_database;\n }\n \n-static DatabasePtr createClickHouseLocalDatabaseOverlay(const String & name_, ContextPtr context_)\n+static DatabasePtr createClickHouseLocalDatabaseOverlay(const String & name_, ContextPtr context)\n {\n-    auto databaseCombiner = std::make_shared<DatabasesOverlay>(name_, context_);\n-    databaseCombiner->registerNextDatabase(std::make_shared<DatabaseFilesystem>(name_, \"\", context_));\n-    databaseCombiner->registerNextDatabase(std::make_shared<DatabaseMemory>(name_, context_));\n-    return databaseCombiner;\n+    auto overlay = std::make_shared<DatabasesOverlay>(name_, context);\n+    overlay->registerNextDatabase(std::make_shared<DatabaseAtomic>(name_, fs::weakly_canonical(context->getPath()), UUIDHelpers::generateV4(), context));\n+    overlay->registerNextDatabase(std::make_shared<DatabaseFilesystem>(name_, \"\", context));\n+    return overlay;\n }\n \n /// If path is specified and not empty, will try to setup server environment and load existing metadata\n@@ -367,7 +367,7 @@ std::string LocalServer::getInitialCreateTableQuery()\n     else\n         table_structure = \"(\" + table_structure + \")\";\n \n-    return fmt::format(\"CREATE TABLE {} {} ENGINE = File({}, {});\",\n+    return fmt::format(\"CREATE TEMPORARY TABLE {} {} ENGINE = File({}, {});\",\n                        table_name, table_structure, data_format, table_file);\n }\n \n@@ -761,7 +761,12 @@ void LocalServer::processConfig()\n     DatabaseCatalog::instance().initializeAndLoadTemporaryDatabase();\n \n     std::string default_database = server_settings.default_database;\n-    DatabaseCatalog::instance().attachDatabase(default_database, createClickHouseLocalDatabaseOverlay(default_database, global_context));\n+    {\n+        DatabasePtr database = createClickHouseLocalDatabaseOverlay(default_database, global_context);\n+        if (UUID uuid = database->getUUID(); uuid != UUIDHelpers::Nil)\n+            DatabaseCatalog::instance().addUUIDMapping(uuid);\n+        DatabaseCatalog::instance().attachDatabase(default_database, database);\n+    }\n     global_context->setCurrentDatabase(default_database);\n \n     if (getClientConfiguration().has(\"path\"))\ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex d86e29ca915c..83b82976e4f2 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -53,9 +53,6 @@ DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, c\n     , db_uuid(uuid)\n {\n     assert(db_uuid != UUIDHelpers::Nil);\n-    fs::create_directories(fs::path(getContext()->getPath()) / \"metadata\");\n-    fs::create_directories(path_to_table_symlinks);\n-    tryCreateMetadataSymlink();\n }\n \n DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, ContextPtr context_)\n@@ -63,6 +60,16 @@ DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, C\n {\n }\n \n+void DatabaseAtomic::createDirectories()\n+{\n+    if (database_atomic_directories_created.test_and_set())\n+        return;\n+    DatabaseOnDisk::createDirectories();\n+    fs::create_directories(fs::path(getContext()->getPath()) / \"metadata\");\n+    fs::create_directories(path_to_table_symlinks);\n+    tryCreateMetadataSymlink();\n+}\n+\n String DatabaseAtomic::getTableDataPath(const String & table_name) const\n {\n     std::lock_guard lock(mutex);\n@@ -99,6 +106,7 @@ void DatabaseAtomic::drop(ContextPtr)\n void DatabaseAtomic::attachTable(ContextPtr /* context_ */, const String & name, const StoragePtr & table, const String & relative_table_path)\n {\n     assert(relative_table_path != data_path && !relative_table_path.empty());\n+    createDirectories();\n     DetachedTables not_in_use;\n     std::lock_guard lock(mutex);\n     not_in_use = cleanupDetachedTables();\n@@ -200,11 +208,15 @@ void DatabaseAtomic::renameTable(ContextPtr local_context, const String & table_\n     if (exchange && !supportsAtomicRename())\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"RENAME EXCHANGE is not supported\");\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     auto & other_db = dynamic_cast<DatabaseAtomic &>(to_database);\n     bool inside_database = this == &other_db;\n \n+    if (!inside_database)\n+        other_db.createDirectories();\n+\n     String old_metadata_path = getObjectMetadataPath(table_name);\n     String new_metadata_path = to_database.getObjectMetadataPath(to_table_name);\n \n@@ -325,6 +337,7 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n                                        const String & table_metadata_tmp_path, const String & table_metadata_path,\n                                        ContextPtr query_context)\n {\n+    createDirectories();\n     DetachedTables not_in_use;\n     auto table_data_path = getTableDataPath(query);\n     try\n@@ -461,6 +474,9 @@ void DatabaseAtomic::beforeLoadingMetadata(ContextMutablePtr /*context*/, Loadin\n     if (mode < LoadingStrictnessLevel::FORCE_RESTORE)\n         return;\n \n+    if (!fs::exists(path_to_table_symlinks))\n+        return;\n+\n     /// Recreate symlinks to table data dirs in case of force restore, because some of them may be broken\n     for (const auto & table_path : fs::directory_iterator(path_to_table_symlinks))\n     {\n@@ -588,6 +604,7 @@ void DatabaseAtomic::renameDatabase(ContextPtr query_context, const String & new\n {\n     /// CREATE, ATTACH, DROP, DETACH and RENAME DATABASE must hold DDLGuard\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     bool check_ref_deps = query_context->getSettingsRef().check_referential_table_dependencies;\n@@ -679,4 +696,5 @@ void registerDatabaseAtomic(DatabaseFactory & factory)\n     };\n     factory.registerDatabase(\"Atomic\", create_fn);\n }\n+\n }\ndiff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h\nindex 4a4ccfa25733..ca24494f6006 100644\n--- a/src/Databases/DatabaseAtomic.h\n+++ b/src/Databases/DatabaseAtomic.h\n@@ -76,6 +76,9 @@ class DatabaseAtomic : public DatabaseOrdinary\n     using DetachedTables = std::unordered_map<UUID, StoragePtr>;\n     [[nodiscard]] DetachedTables cleanupDetachedTables() TSA_REQUIRES(mutex);\n \n+    std::atomic_flag database_atomic_directories_created = ATOMIC_FLAG_INIT;\n+    void createDirectories();\n+\n     void tryCreateMetadataSymlink();\n \n     virtual bool allowMoveTableToOtherDatabaseEngine(IDatabase & /*to_database*/) const { return false; }\ndiff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp\nindex 3fb6d30fcb82..e43adfc5d378 100644\n--- a/src/Databases/DatabaseLazy.cpp\n+++ b/src/Databases/DatabaseLazy.cpp\n@@ -47,12 +47,13 @@ DatabaseLazy::DatabaseLazy(const String & name_, const String & metadata_path_,\n     : DatabaseOnDisk(name_, metadata_path_, std::filesystem::path(\"data\") / escapeForFileName(name_) / \"\", \"DatabaseLazy (\" + name_ + \")\", context_)\n     , expiration_time(expiration_time_)\n {\n+    createDirectories();\n }\n \n \n void DatabaseLazy::loadStoredObjects(ContextMutablePtr local_context, LoadingStrictnessLevel /*mode*/)\n {\n-    iterateMetadataFiles(local_context, [this, &local_context](const String & file_name)\n+    iterateMetadataFiles([this, &local_context](const String & file_name)\n     {\n         const std::string table_name = unescapeForFileName(file_name.substr(0, file_name.size() - 4));\n \ndiff --git a/src/Databases/DatabaseLazy.h b/src/Databases/DatabaseLazy.h\nindex 41cfb7511415..aeac130594f7 100644\n--- a/src/Databases/DatabaseLazy.h\n+++ b/src/Databases/DatabaseLazy.h\n@@ -12,7 +12,7 @@ class DatabaseLazyIterator;\n class Context;\n \n /** Lazy engine of databases.\n-  * Works like DatabaseOrdinary, but stores in memory only the cache.\n+  * Works like DatabaseOrdinary, but stores only recently accessed tables in memory.\n   * Can be used only with *Log engines.\n   */\n class DatabaseLazy final : public DatabaseOnDisk\ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 734f354d9a5a..82a81b0b32d0 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -172,7 +172,14 @@ DatabaseOnDisk::DatabaseOnDisk(\n     , metadata_path(metadata_path_)\n     , data_path(data_path_)\n {\n-    fs::create_directories(local_context->getPath() + data_path);\n+}\n+\n+\n+void DatabaseOnDisk::createDirectories()\n+{\n+    if (directories_created.test_and_set())\n+        return;\n+    fs::create_directories(std::filesystem::path(getContext()->getPath()) / data_path);\n     fs::create_directories(metadata_path);\n }\n \n@@ -190,6 +197,8 @@ void DatabaseOnDisk::createTable(\n     const StoragePtr & table,\n     const ASTPtr & query)\n {\n+    createDirectories();\n+\n     const auto & settings = local_context->getSettingsRef();\n     const auto & create = query->as<ASTCreateQuery &>();\n     assert(table_name == create.getTable());\n@@ -257,7 +266,6 @@ void DatabaseOnDisk::createTable(\n     }\n \n     commitCreateTable(create, table, table_metadata_tmp_path, table_metadata_path, local_context);\n-\n     removeDetachedPermanentlyFlag(local_context, table_name, table_metadata_path, false);\n }\n \n@@ -285,6 +293,8 @@ void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const Stora\n {\n     try\n     {\n+        createDirectories();\n+\n         /// Add a table to the map of known tables.\n         attachTable(query_context, query.getTable(), table, getTableDataPath(query));\n \n@@ -420,6 +430,7 @@ void DatabaseOnDisk::renameTable(\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Moving tables between databases of different engines is not supported\");\n     }\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     auto table_data_relative_path = getTableDataPath(table_name);\n@@ -568,14 +579,14 @@ void DatabaseOnDisk::drop(ContextPtr local_context)\n     assert(TSA_SUPPRESS_WARNING_FOR_READ(tables).empty());\n     if (local_context->getSettingsRef().force_remove_data_recursively_on_drop)\n     {\n-        (void)fs::remove_all(local_context->getPath() + getDataPath());\n+        (void)fs::remove_all(std::filesystem::path(getContext()->getPath()) / data_path);\n         (void)fs::remove_all(getMetadataPath());\n     }\n     else\n     {\n         try\n         {\n-            (void)fs::remove(local_context->getPath() + getDataPath());\n+            (void)fs::remove(std::filesystem::path(getContext()->getPath()) / data_path);\n             (void)fs::remove(getMetadataPath());\n         }\n         catch (const fs::filesystem_error & e)\n@@ -613,15 +624,18 @@ time_t DatabaseOnDisk::getObjectMetadataModificationTime(const String & object_n\n     }\n }\n \n-void DatabaseOnDisk::iterateMetadataFiles(ContextPtr local_context, const IteratingFunction & process_metadata_file) const\n+void DatabaseOnDisk::iterateMetadataFiles(const IteratingFunction & process_metadata_file) const\n {\n+    if (!fs::exists(metadata_path))\n+        return;\n+\n     auto process_tmp_drop_metadata_file = [&](const String & file_name)\n     {\n         assert(getUUID() == UUIDHelpers::Nil);\n         static const char * tmp_drop_ext = \".sql.tmp_drop\";\n         const std::string object_name = file_name.substr(0, file_name.size() - strlen(tmp_drop_ext));\n \n-        if (fs::exists(local_context->getPath() + getDataPath() + '/' + object_name))\n+        if (fs::exists(std::filesystem::path(getContext()->getPath()) / data_path / object_name))\n         {\n             fs::rename(getMetadataPath() + file_name, getMetadataPath() + object_name + \".sql\");\n             LOG_WARNING(log, \"Object {} was not dropped previously and will be restored\", backQuote(object_name));\n@@ -638,7 +652,7 @@ void DatabaseOnDisk::iterateMetadataFiles(ContextPtr local_context, const Iterat\n     std::vector<std::pair<String, bool>> metadata_files;\n \n     fs::directory_iterator dir_end;\n-    for (fs::directory_iterator dir_it(getMetadataPath()); dir_it != dir_end; ++dir_it)\n+    for (fs::directory_iterator dir_it(metadata_path); dir_it != dir_end; ++dir_it)\n     {\n         String file_name = dir_it->path().filename();\n         /// For '.svn', '.gitignore' directory and similar.\ndiff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h\nindex 12656068643b..0c0ecf76a266 100644\n--- a/src/Databases/DatabaseOnDisk.h\n+++ b/src/Databases/DatabaseOnDisk.h\n@@ -64,7 +64,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n     time_t getObjectMetadataModificationTime(const String & object_name) const override;\n \n     String getDataPath() const override { return data_path; }\n-    String getTableDataPath(const String & table_name) const override { return data_path + escapeForFileName(table_name) + \"/\"; }\n+    String getTableDataPath(const String & table_name) const override { return std::filesystem::path(data_path) / escapeForFileName(table_name) / \"\"; }\n     String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.getTable()); }\n     String getMetadataPath() const override { return metadata_path; }\n \n@@ -83,7 +83,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n \n     using IteratingFunction = std::function<void(const String &)>;\n \n-    void iterateMetadataFiles(ContextPtr context, const IteratingFunction & process_metadata_file) const;\n+    void iterateMetadataFiles(const IteratingFunction & process_metadata_file) const;\n \n     ASTPtr getCreateTableQueryImpl(\n         const String & table_name,\n@@ -99,6 +99,9 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n     virtual void removeDetachedPermanentlyFlag(ContextPtr context, const String & table_name, const String & table_metadata_path, bool attach);\n     virtual void setDetachedTableNotInUseForce(const UUID & /*uuid*/) {}\n \n+    std::atomic_flag directories_created = ATOMIC_FLAG_INIT;\n+    void createDirectories();\n+\n     const String metadata_path;\n     const String data_path;\n };\ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex 8808261654f7..dd8a3f42ea8a 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -55,7 +55,7 @@ static constexpr size_t METADATA_FILE_BUFFER_SIZE = 32768;\n static constexpr const char * const CONVERT_TO_REPLICATED_FLAG_NAME = \"convert_to_replicated\";\n \n DatabaseOrdinary::DatabaseOrdinary(const String & name_, const String & metadata_path_, ContextPtr context_)\n-    : DatabaseOrdinary(name_, metadata_path_, \"data/\" + escapeForFileName(name_) + \"/\", \"DatabaseOrdinary (\" + name_ + \")\", context_)\n+    : DatabaseOrdinary(name_, metadata_path_, std::filesystem::path(\"data\") / escapeForFileName(name_) / \"\", \"DatabaseOrdinary (\" + name_ + \")\", context_)\n {\n }\n \n@@ -265,7 +265,7 @@ void DatabaseOrdinary::loadTablesMetadata(ContextPtr local_context, ParsedTables\n         }\n     };\n \n-    iterateMetadataFiles(local_context, process_metadata);\n+    iterateMetadataFiles(process_metadata);\n \n     size_t objects_in_database = metadata.parsed_tables.size() - prev_tables_count;\n     size_t dictionaries_in_database = metadata.total_dictionaries - prev_total_dictionaries;\ndiff --git a/src/Databases/DatabasesOverlay.cpp b/src/Databases/DatabasesOverlay.cpp\nindex 801356b3dd79..495733e15fd5 100644\n--- a/src/Databases/DatabasesOverlay.cpp\n+++ b/src/Databases/DatabasesOverlay.cpp\n@@ -14,6 +14,8 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int CANNOT_GET_CREATE_TABLE_QUERY;\n+    extern const int BAD_ARGUMENTS;\n+    extern const int UNKNOWN_TABLE;\n }\n \n DatabasesOverlay::DatabasesOverlay(const String & name_, ContextPtr context_)\n@@ -124,6 +126,39 @@ StoragePtr DatabasesOverlay::detachTable(ContextPtr context_, const String & tab\n         getEngineName());\n }\n \n+void DatabasesOverlay::renameTable(\n+    ContextPtr current_context,\n+    const String & name,\n+    IDatabase & to_database,\n+    const String & to_name,\n+    bool exchange,\n+    bool dictionary)\n+{\n+    for (auto & db : databases)\n+    {\n+        if (db->isTableExist(name, current_context))\n+        {\n+            if (DatabasesOverlay * to_overlay_database = typeid_cast<DatabasesOverlay *>(&to_database))\n+            {\n+                /// Renaming from Overlay database inside itself or into another Overlay database.\n+                /// Just use the first database in the overlay as a destination.\n+                if (to_overlay_database->databases.empty())\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The destination Overlay database {} does not have any members\", to_database.getDatabaseName());\n+\n+                db->renameTable(current_context, name, *to_overlay_database->databases[0], to_name, exchange, dictionary);\n+            }\n+            else\n+            {\n+                /// Renaming into a different type of database. E.g. from Overlay on top of Atomic database into just Atomic database.\n+                db->renameTable(current_context, name, to_database, to_name, exchange, dictionary);\n+            }\n+\n+            return;\n+        }\n+    }\n+    throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist\", backQuote(getDatabaseName()), backQuote(name));\n+}\n+\n ASTPtr DatabasesOverlay::getCreateTableQueryImpl(const String & name, ContextPtr context_, bool throw_on_error) const\n {\n     ASTPtr result = nullptr;\n@@ -178,6 +213,18 @@ String DatabasesOverlay::getTableDataPath(const ASTCreateQuery & query) const\n     return result;\n }\n \n+UUID DatabasesOverlay::getUUID() const\n+{\n+    UUID result = UUIDHelpers::Nil;\n+    for (const auto & db : databases)\n+    {\n+        result = db->getUUID();\n+        if (result != UUIDHelpers::Nil)\n+            break;\n+    }\n+    return result;\n+}\n+\n UUID DatabasesOverlay::tryGetTableUUID(const String & table_name) const\n {\n     UUID result = UUIDHelpers::Nil;\ndiff --git a/src/Databases/DatabasesOverlay.h b/src/Databases/DatabasesOverlay.h\nindex b0c7e7e40326..40c653e5cb50 100644\n--- a/src/Databases/DatabasesOverlay.h\n+++ b/src/Databases/DatabasesOverlay.h\n@@ -35,12 +35,21 @@ class DatabasesOverlay : public IDatabase, protected WithContext\n \n     StoragePtr detachTable(ContextPtr context, const String & table_name) override;\n \n+    void renameTable(\n+        ContextPtr current_context,\n+        const String & name,\n+        IDatabase & to_database,\n+        const String & to_name,\n+        bool exchange,\n+        bool dictionary) override;\n+\n     ASTPtr getCreateTableQueryImpl(const String & name, ContextPtr context, bool throw_on_error) const override;\n     ASTPtr getCreateDatabaseQuery() const override;\n \n     String getTableDataPath(const String & table_name) const override;\n     String getTableDataPath(const ASTCreateQuery & query) const override;\n \n+    UUID getUUID() const override;\n     UUID tryGetTableUUID(const String & table_name) const override;\n \n     void drop(ContextPtr context) override;\ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex f94326d220e4..02418abb2b06 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -416,6 +416,7 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n         std::lock_guard lock{mutex};\n         return database_name;\n     }\n+\n     /// Get UUID of database.\n     virtual UUID getUUID() const { return UUIDHelpers::Nil; }\n \ndiff --git a/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp b/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\nindex 2f5477a6b9d5..8b3850c4e0c9 100644\n--- a/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\n+++ b/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\n@@ -46,6 +46,7 @@ DatabaseMaterializedMySQL::DatabaseMaterializedMySQL(\n     , settings(std::move(settings_))\n     , materialize_thread(context_, database_name_, mysql_database_name_, std::move(pool_), std::move(client_), binlog_client_, settings.get())\n {\n+    createDirectories();\n }\n \n void DatabaseMaterializedMySQL::rethrowExceptionIfNeeded() const\ndiff --git a/src/Interpreters/StorageID.h b/src/Interpreters/StorageID.h\nindex f9afbc7b98d9..ad55d16e284d 100644\n--- a/src/Interpreters/StorageID.h\n+++ b/src/Interpreters/StorageID.h\n@@ -27,7 +27,6 @@ class ASTQueryWithTableAndOutput;\n class ASTTableIdentifier;\n class Context;\n \n-// TODO(ilezhankin): refactor and merge |ASTTableIdentifier|\n struct StorageID\n {\n     String database_name;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01191_rename_dictionary.sql b/tests/queries/0_stateless/01191_rename_dictionary.sql\nindex c5012dabc812..be95e5a7d4b3 100644\n--- a/tests/queries/0_stateless/01191_rename_dictionary.sql\n+++ b/tests/queries/0_stateless/01191_rename_dictionary.sql\n@@ -27,6 +27,7 @@ RENAME DICTIONARY test_01191.t TO test_01191.dict1; -- {serverError INCORRECT_QU\n DROP DICTIONARY test_01191.t; -- {serverError INCORRECT_QUERY}\n DROP TABLE test_01191.t;\n \n+DROP DATABASE IF EXISTS dummy_db;\n CREATE DATABASE dummy_db ENGINE=Atomic;\n RENAME DICTIONARY test_01191.dict TO dummy_db.dict1;\n RENAME DICTIONARY dummy_db.dict1 TO test_01191.dict;\ndiff --git a/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.reference b/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.reference\nindex 0bb8966cbe46..0e74c0a083ec 100644\n--- a/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.reference\n+++ b/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.reference\n@@ -1,2 +1,2 @@\n-CREATE TABLE default.`table`\\n(\\n    `key` String\\n)\\nENGINE = File(\\'TSVWithNamesAndTypes\\', \\'/dev/null\\')\n-CREATE TABLE foo.`table`\\n(\\n    `key` String\\n)\\nENGINE = File(\\'TSVWithNamesAndTypes\\', \\'/dev/null\\')\n+CREATE TEMPORARY TABLE `table`\\n(\\n    `key` String\\n)\\nENGINE = File(TSVWithNamesAndTypes, \\'/dev/null\\')\n+CREATE TEMPORARY TABLE `table`\\n(\\n    `key` String\\n)\\nENGINE = File(TSVWithNamesAndTypes, \\'/dev/null\\')\ndiff --git a/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.sh b/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.sh\nindex 934d87616ace..3a95e59416a7 100755\n--- a/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.sh\n+++ b/tests/queries/0_stateless/02141_clickhouse_local_interactive_table.sh\n@@ -4,5 +4,5 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n # shellcheck source=../shell_config.sh\n . \"$CURDIR\"/../shell_config.sh\n \n-$CLICKHOUSE_LOCAL --file /dev/null --structure \"key String\" --input-format TSVWithNamesAndTypes --interactive --send_logs_level=trace <<<'show create table table'\n-$CLICKHOUSE_LOCAL --database foo --file /dev/null --structure \"key String\" --input-format TSVWithNamesAndTypes --interactive --send_logs_level=trace <<<'show create table table'\n+$CLICKHOUSE_LOCAL --file /dev/null --structure \"key String\" --input-format TSVWithNamesAndTypes --interactive --send_logs_level=trace <<<'show create temporary table table'\n+$CLICKHOUSE_LOCAL --database foo --file /dev/null --structure \"key String\" --input-format TSVWithNamesAndTypes --interactive --send_logs_level=trace <<<'show create temporary table table'\ndiff --git a/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference b/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference\nnew file mode 100644\nindex 000000000000..1975397394b7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference\n@@ -0,0 +1,6 @@\n+123\n+Hello\n+['Hello','world']\n+Hello\n+Hello\n+['Hello','world']\ndiff --git a/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh b/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh\nnew file mode 100755\nindex 000000000000..edaa83b8f959\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh\n@@ -0,0 +1,24 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_LOCAL} -n \"\n+CREATE TABLE test (x UInt8) ORDER BY x;\n+INSERT INTO test VALUES (123);\n+SELECT * FROM test;\n+CREATE OR REPLACE TABLE test (s String) ORDER BY s;\n+INSERT INTO test VALUES ('Hello');\n+SELECT * FROM test;\n+RENAME TABLE test TO test2;\n+CREATE OR REPLACE TABLE test (s Array(String)) ORDER BY s;\n+INSERT INTO test VALUES (['Hello', 'world']);\n+SELECT * FROM test;\n+SELECT * FROM test2;\n+EXCHANGE TABLES test AND test2;\n+SELECT * FROM test;\n+SELECT * FROM test2;\n+DROP TABLE test;\n+DROP TABLE test2;\n+\"\n",
  "problem_statement": "CREATE OR REPLACE and EXCHANGE TABLES for Memory database\n**Use case**\r\n\r\n`Memory` database engine is used in `clickhouse-local`, and nothing prevents implementing these queries.\r\n\r\n**Describe the solution you'd like**\r\n\r\nA mutex.\n",
  "hints_text": "The Memory database engine does not use UUIDs in tables and databases, and if the table stores data on the disk then the table data is stored directly in the `data/database_name/table_name` folder and not in (for example) `store/xxx/1e8dfeba-73a1-4b40-8238-63e58c9a3893`.\r\n\r\nSo in the case of RENAME query, we would need to either modify every table engine that stores data to have the ability to move its data from `data/database_name/table_name` to `data/database_name/new_table_name` (and hope that nothing breaks) or to use UUIDs and store the data in the `store/` directory which kind of makes it not temporary and basically an Atomic engine without saving metadata.\r\n\r\nIs there a reason for using the Memory engine in clickhouse-local? Either way, we will store the data in the `/tmp/clickhouse-local-.../` directory and it seems like the better solution would be to just use the Atomic engine.\nMemory database engine is like another database engine, but without persisting the .sql files.\r\nCurrently, it is modeled after the Ordinary database engine.\r\nBut the Ordinary database engine is obsolete. Let's make the tables' paths like in the Atomic database engine.\r\n\r\nLet's not worry about compatibility because it's expected that everything in the Memory database is temporary.\r\n\r\nPS. These operations should be supported:\r\n\r\n`REPLACE TABLE`\r\n`CREATE OR REPLACE TABLE`\r\n`EXCHANGE TABLES`\r\n`ATTACH TABLE ... UUID '...'`\r\n\r\nPS. Maybe we can decouple the way how DB's metadata is stored with the way how the table's paths are determined? It will also help with the implementation of the Replicated database engine. But this will be a much broader task. Let's consider it only after making the first solution.",
  "created_at": "2024-06-30T03:13:16Z",
  "modified_files": [
    "programs/local/LocalServer.cpp",
    "src/Databases/DatabaseAtomic.cpp",
    "src/Databases/DatabaseAtomic.h",
    "src/Databases/DatabaseLazy.cpp",
    "src/Databases/DatabaseLazy.h",
    "src/Databases/DatabaseOnDisk.cpp",
    "src/Databases/DatabaseOnDisk.h",
    "src/Databases/DatabaseOrdinary.cpp",
    "src/Databases/DatabasesOverlay.cpp",
    "src/Databases/DatabasesOverlay.h",
    "src/Databases/IDatabase.h",
    "src/Databases/MySQL/DatabaseMaterializedMySQL.cpp",
    "src/Interpreters/StorageID.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01191_rename_dictionary.sql",
    "tests/queries/0_stateless/02141_clickhouse_local_interactive_table.reference",
    "tests/queries/0_stateless/02141_clickhouse_local_interactive_table.sh",
    "b/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference",
    "b/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh"
  ]
}