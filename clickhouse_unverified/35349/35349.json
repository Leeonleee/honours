{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35349,
  "instance_id": "ClickHouse__ClickHouse-35349",
  "issue_numbers": [
    "34903"
  ],
  "base_commit": "2c12c93d9e01bf04a8c9141e4acf1afc94b0abbd",
  "patch": "diff --git a/docs/en/sql-reference/statements/select/index.md b/docs/en/sql-reference/statements/select/index.md\nindex 336441331537..c5421c830914 100644\n--- a/docs/en/sql-reference/statements/select/index.md\n+++ b/docs/en/sql-reference/statements/select/index.md\n@@ -22,7 +22,7 @@ SELECT [DISTINCT [ON (column1, column2, ...)]] expr_list\n [WHERE expr]\n [GROUP BY expr_list] [WITH ROLLUP|WITH CUBE] [WITH TOTALS]\n [HAVING expr]\n-[ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr]\n+[ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr] [INTERPOLATE [(expr_list)]]\n [LIMIT [offset_value, ]n BY columns]\n [LIMIT [n, ]m] [WITH TIES]\n [SETTINGS ...]\ndiff --git a/docs/en/sql-reference/statements/select/order-by.md b/docs/en/sql-reference/statements/select/order-by.md\nindex b24f0213e4e3..04630ba10759 100644\n--- a/docs/en/sql-reference/statements/select/order-by.md\n+++ b/docs/en/sql-reference/statements/select/order-by.md\n@@ -280,6 +280,7 @@ To fill multiple columns, add `WITH FILL` modifier with optional parameters afte\n \n ``` sql\n ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_expr], ... exprN [WITH FILL] [FROM expr] [TO expr] [STEP numeric_expr]\n+[INTERPOLATE [(col [AS expr], ... colN [AS exprN])]]\n ```\n \n `WITH FILL` can be applied for fields with Numeric (all kinds of float, decimal, int) or Date/DateTime types. When applied for `String` fields, missed values are filled with empty strings.\n@@ -287,6 +288,7 @@ When `FROM const_expr` not defined sequence of filling use minimal `expr` field\n When `TO const_expr` not defined sequence of filling use maximum `expr` field value from `ORDER BY`.\n When `STEP const_numeric_expr` defined then `const_numeric_expr` interprets `as is` for numeric types, as `days` for Date type, as `seconds` for DateTime type. It also supports [INTERVAL](https://clickhouse.com/docs/en/sql-reference/data-types/special-data-types/interval/) data type representing time and date intervals.\n When `STEP const_numeric_expr` omitted then sequence of filling use `1.0` for numeric type, `1 day` for Date type and `1 second` for DateTime type.\n+`INTERPOLATE` can be applied to columns not participating in `ORDER BY WITH FILL`. Such columns are filled based on previous fields values by applying `expr`. If `expr` is not present will repeate previous value. Omitted list will result in including all allowed columns.\n \n Example of a query without `WITH FILL`:\n \n@@ -483,4 +485,62 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+Example of a query without `INTERPOLATE`:\n+\n+``` sql\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter\n+   FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u252c\u2500inter\u2500\u2510\n+\u2502   0 \u2502          \u2502     0 \u2502\n+\u2502 0.5 \u2502          \u2502     0 \u2502\n+\u2502   1 \u2502 original \u2502     1 \u2502\n+\u2502 1.5 \u2502          \u2502     0 \u2502\n+\u2502   2 \u2502          \u2502     0 \u2502\n+\u2502 2.5 \u2502          \u2502     0 \u2502\n+\u2502   3 \u2502          \u2502     0 \u2502\n+\u2502 3.5 \u2502          \u2502     0 \u2502\n+\u2502   4 \u2502 original \u2502     4 \u2502\n+\u2502 4.5 \u2502          \u2502     0 \u2502\n+\u2502   5 \u2502          \u2502     0 \u2502\n+\u2502 5.5 \u2502          \u2502     0 \u2502\n+\u2502   7 \u2502 original \u2502     7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Same query after applying `INTERPOLATE`:\n+\n+``` sql\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter\n+   FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u252c\u2500inter\u2500\u2510\n+\u2502   0 \u2502          \u2502     0 \u2502\n+\u2502 0.5 \u2502          \u2502     0 \u2502\n+\u2502   1 \u2502 original \u2502     1 \u2502\n+\u2502 1.5 \u2502          \u2502     2 \u2502\n+\u2502   2 \u2502          \u2502     3 \u2502\n+\u2502 2.5 \u2502          \u2502     4 \u2502\n+\u2502   3 \u2502          \u2502     5 \u2502\n+\u2502 3.5 \u2502          \u2502     6 \u2502\n+\u2502   4 \u2502 original \u2502     4 \u2502\n+\u2502 4.5 \u2502          \u2502     5 \u2502\n+\u2502   5 \u2502          \u2502     6 \u2502\n+\u2502 5.5 \u2502          \u2502     7 \u2502\n+\u2502   7 \u2502 original \u2502     7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n [Original article](https://clickhouse.com/docs/en/sql-reference/statements/select/order-by/) <!--hide-->\ndiff --git a/docs/ru/sql-reference/statements/select/index.md b/docs/ru/sql-reference/statements/select/index.md\nindex 4a409dc77435..fead3c110602 100644\n--- a/docs/ru/sql-reference/statements/select/index.md\n+++ b/docs/ru/sql-reference/statements/select/index.md\n@@ -20,7 +20,7 @@ SELECT [DISTINCT [ON (column1, column2, ...)]] expr_list\n [WHERE expr]\n [GROUP BY expr_list] [WITH ROLLUP|WITH CUBE] [WITH TOTALS]\n [HAVING expr]\n-[ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr]\n+[ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr] [INTERPOLATE [(expr_list)]]\n [LIMIT [offset_value, ]n BY columns]\n [LIMIT [n, ]m] [WITH TIES]\n [SETTINGS ...]\ndiff --git a/docs/ru/sql-reference/statements/select/order-by.md b/docs/ru/sql-reference/statements/select/order-by.md\nindex 3f52b260423a..e293e62e34ce 100644\n--- a/docs/ru/sql-reference/statements/select/order-by.md\n+++ b/docs/ru/sql-reference/statements/select/order-by.md\n@@ -280,6 +280,7 @@ SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';\n \n ```sql\n ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_expr], ... exprN [WITH FILL] [FROM expr] [TO expr] [STEP numeric_expr]\n+[INTERPOLATE [(col [AS expr], ... colN [AS exprN])]]\n ```\n \n `WITH FILL` \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d \u043a \u043f\u043e\u043b\u044f\u043c \u0441 \u0447\u0438\u0441\u043b\u043e\u0432\u044b\u043c\u0438 (\u0432\u0441\u0435 \u0440\u0430\u0437\u043d\u043e\u0432\u0438\u0434\u043d\u043e\u0441\u0442\u0438 float, int, decimal) \u0438\u043b\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 (\u0432\u0441\u0435 \u0440\u0430\u0437\u043d\u043e\u0432\u0438\u0434\u043d\u043e\u0441\u0442\u0438 Date, DateTime) \u0442\u0438\u043f\u0430\u043c\u0438. \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043a \u043f\u043e\u043b\u044f\u043c \u0442\u0438\u043f\u0430 `String` \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u044e\u0449\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u043e\u0439.\n@@ -289,6 +290,8 @@ ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_\n \n \u041a\u043e\u0433\u0434\u0430 `STEP const_numeric_expr` \u043d\u0435 \u0443\u043a\u0430\u0437\u0430\u043d, \u0442\u043e\u0433\u0434\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f `1.0` \u0434\u043b\u044f \u0447\u0438\u0441\u043b\u043e\u0432\u044b\u0445 \u0442\u0438\u043f\u043e\u0432, `1 \u0434\u0435\u043d\u044c` \u0434\u043b\u044f \u0442\u0438\u043f\u0430 Date \u0438 `1 \u0441\u0435\u043a\u0443\u043d\u0434\u0430` \u0434\u043b\u044f \u0442\u0438\u043f\u0430 DateTime.\n \n+`INTERPOLATE` \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d \u043a \u043a\u043e\u043b\u043e\u043d\u043a\u0430\u043c, \u043d\u0435 \u0443\u0447\u0430\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u043c \u0432 `ORDER BY WITH FILL`. \u0422\u0430\u043a\u0438\u0435 \u043a\u043e\u043b\u043e\u043d\u043a\u0438 \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438, \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c\u044b\u043c\u0438 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435\u043c `expr` \u043a \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e. \u0415\u0441\u043b\u0438 `expr` \u043e\u043f\u0443\u0449\u0435\u043d, \u0442\u043e \u043a\u043e\u043b\u043e\u043d\u043a\u0430 \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c. \u0415\u0441\u043b\u0438 \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043b\u043e\u043d\u043e\u043a \u043d\u0435 \u0443\u043a\u0430\u0437\u0430\u043d, \u0442\u043e \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0442\u0441\u044f \u0432\u0441\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u043d\u044b\u0435 \u043a\u043e\u043b\u043e\u043d\u043a\u0438.\n+\n \u041f\u0440\u0438\u043c\u0435\u0440 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0431\u0435\u0437 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f `WITH FILL`:\n ```sql\n SELECT n, source FROM (\n@@ -395,3 +398,58 @@ ORDER BY\n \u2502 1970-03-12 \u2502 1970-01-08 \u2502 original \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+\u041f\u0440\u0438\u043c\u0435\u0440 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0431\u0435\u0437 `INTERPOLATE`:\n+\n+``` sql\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter\n+   FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;\n+```\n+\n+\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\n+``` text\n+\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u252c\u2500inter\u2500\u2510\n+\u2502   0 \u2502          \u2502     0 \u2502\n+\u2502 0.5 \u2502          \u2502     0 \u2502\n+\u2502   1 \u2502 original \u2502     1 \u2502\n+\u2502 1.5 \u2502          \u2502     0 \u2502\n+\u2502   2 \u2502          \u2502     0 \u2502\n+\u2502 2.5 \u2502          \u2502     0 \u2502\n+\u2502   3 \u2502          \u2502     0 \u2502\n+\u2502 3.5 \u2502          \u2502     0 \u2502\n+\u2502   4 \u2502 original \u2502     4 \u2502\n+\u2502 4.5 \u2502          \u2502     0 \u2502\n+\u2502   5 \u2502          \u2502     0 \u2502\n+\u2502 5.5 \u2502          \u2502     0 \u2502\n+\u2502   7 \u2502 original \u2502     7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\u0422\u043e\u0442 \u0436\u0435 \u0437\u0430\u043f\u0440\u043e\u0441 \u0441 `INTERPOLATE`:\n+\n+``` sql\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter\n+   FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);\n+```\n+\n+\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\n+``` text\n+\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u252c\u2500inter\u2500\u2510\n+\u2502   0 \u2502          \u2502     0 \u2502\n+\u2502 0.5 \u2502          \u2502     0 \u2502\n+\u2502   1 \u2502 original \u2502     1 \u2502\n+\u2502 1.5 \u2502          \u2502     2 \u2502\n+\u2502   2 \u2502          \u2502     3 \u2502\n+\u2502 2.5 \u2502          \u2502     4 \u2502\n+\u2502   3 \u2502          \u2502     5 \u2502\n+\u2502 3.5 \u2502          \u2502     6 \u2502\n+\u2502   4 \u2502 original \u2502     4 \u2502\n+\u2502 4.5 \u2502          \u2502     5 \u2502\n+\u2502   5 \u2502          \u2502     6 \u2502\n+\u2502 5.5 \u2502          \u2502     7 \u2502\n+\u2502   7 \u2502 original \u2502     7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/src/Core/InterpolateDescription.cpp b/src/Core/InterpolateDescription.cpp\nnew file mode 100644\nindex 000000000000..e7b74716b794\n--- /dev/null\n+++ b/src/Core/InterpolateDescription.cpp\n@@ -0,0 +1,32 @@\n+#include <Core/Block.h>\n+#include <IO/Operators.h>\n+#include <Common/JSONBuilder.h>\n+#include <Core/InterpolateDescription.h>\n+#include <Interpreters/convertFieldToType.h>\n+\n+namespace DB\n+{\n+\n+    InterpolateDescription::InterpolateDescription(ActionsDAGPtr actions_, const Aliases & aliases)\n+        : actions(actions_)\n+    {\n+        for (const auto & name_type : actions->getRequiredColumns())\n+        {\n+            if (const auto & p = aliases.find(name_type.name); p != aliases.end())\n+                required_columns_map[p->second->getColumnName()] = name_type;\n+            else\n+                required_columns_map[name_type.name] = name_type;\n+        }\n+\n+        for (const ColumnWithTypeAndName & column : actions->getResultColumns())\n+        {\n+            std::string name = column.name;\n+            if (const auto & p = aliases.find(name); p != aliases.end())\n+                name = p->second->getColumnName();\n+\n+            result_columns_set.insert(name);\n+            result_columns_order.push_back(name);\n+        }\n+    }\n+\n+}\ndiff --git a/src/Core/InterpolateDescription.h b/src/Core/InterpolateDescription.h\nnew file mode 100644\nindex 000000000000..8aabce1470e5\n--- /dev/null\n+++ b/src/Core/InterpolateDescription.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <unordered_map>\n+#include <memory>\n+#include <cstddef>\n+#include <string>\n+#include <Core/Field.h>\n+#include <Core/SettingsEnums.h>\n+#include <Common/IntervalKind.h>\n+#include <Parsers/ASTOrderByElement.h>\n+#include <Parsers/ASTInterpolateElement.h>\n+#include <Functions/FunctionsMiscellaneous.h>\n+#include <Interpreters/Aliases.h>\n+\n+\n+namespace DB\n+{\n+\n+/// Interpolate description\n+struct InterpolateDescription\n+{\n+    explicit InterpolateDescription(ActionsDAGPtr actions, const Aliases & aliases);\n+\n+    ActionsDAGPtr actions;\n+\n+    std::unordered_map<std::string, NameAndTypePair> required_columns_map; /// input column name -> {alias, type}\n+    std::unordered_set<std::string> result_columns_set; /// result block columns\n+    std::vector<std::string> result_columns_order; /// result block columns order\n+};\n+\n+using InterpolateDescriptionPtr = std::shared_ptr<InterpolateDescription>;\n+\n+}\ndiff --git a/src/Core/SortDescription.h b/src/Core/SortDescription.h\nindex 66f2ca24c693..b86706e665a4 100644\n--- a/src/Core/SortDescription.h\n+++ b/src/Core/SortDescription.h\n@@ -7,6 +7,7 @@\n #include <Core/Field.h>\n #include <Core/SettingsEnums.h>\n #include <Common/IntervalKind.h>\n+#include <DataTypes/IDataType.h>\n \n class Collator;\n \ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 5877ca353925..5e5931713e00 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -9,6 +9,7 @@\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTWindowDefinition.h>\n #include <Parsers/DumpASTNode.h>\n+#include <Parsers/ASTInterpolateElement.h>\n \n #include <DataTypes/DataTypeNullable.h>\n #include <Columns/IColumn.h>\n@@ -1333,6 +1334,38 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChai\n             with_fill = true;\n     }\n \n+    if (auto interpolate_list = select_query->interpolate())\n+    {\n+\n+        NameSet select;\n+        for (const auto & child : select_query->select()->children)\n+            select.insert(child->getAliasOrColumnName());\n+\n+        /// collect columns required for interpolate expressions -\n+        /// interpolate expression can use any available column\n+        auto find_columns = [&step, &select](IAST * function)\n+        {\n+            auto f_impl = [&step, &select](IAST * fn, auto fi)\n+            {\n+                if (auto * ident = fn->as<ASTIdentifier>())\n+                {\n+                    /// exclude columns from select expression - they are already available\n+                    if (select.count(ident->getColumnName()) == 0)\n+                        step.addRequiredOutput(ident->getColumnName());\n+                    return;\n+                }\n+                if (fn->as<ASTFunction>() || fn->as<ASTExpressionList>())\n+                    for (const auto & ch : fn->children)\n+                        fi(ch.get(), fi);\n+                return;\n+            };\n+            f_impl(function, f_impl);\n+        };\n+\n+        for (const auto & interpolate : interpolate_list->children)\n+            find_columns(interpolate->as<ASTInterpolateElement>()->expr.get());\n+    }\n+\n     if (optimize_read_in_order)\n     {\n         for (auto & child : select_query->orderBy()->children)\ndiff --git a/src/Interpreters/FillingRow.cpp b/src/Interpreters/FillingRow.cpp\nindex 94f185a44cc1..bb8661d0ef94 100644\n--- a/src/Interpreters/FillingRow.cpp\n+++ b/src/Interpreters/FillingRow.cpp\n@@ -19,26 +19,27 @@ bool equals(const Field & lhs, const Field & rhs)\n }\n \n \n-FillingRow::FillingRow(const SortDescription & sort_description) : description(sort_description)\n+FillingRow::FillingRow(const SortDescription & sort_description_)\n+    : sort_description(sort_description_)\n {\n-    row.resize(description.size());\n+    row.resize(sort_description.size());\n }\n \n bool FillingRow::operator<(const FillingRow & other) const\n {\n-    for (size_t i = 0; i < size(); ++i)\n+    for (size_t i = 0; i < sort_description.size(); ++i)\n     {\n-        if (row[i].isNull() || other[i].isNull() || equals(row[i], other[i]))\n+        if ((*this)[i].isNull() || other.row[i].isNull() || equals(row[i], other.row[i]))\n             continue;\n-        return less(row[i], other[i], getDirection(i));\n+        return less(row[i], other.row[i], getDirection(i));\n     }\n     return false;\n }\n \n bool FillingRow::operator==(const FillingRow & other) const\n {\n-    for (size_t i = 0; i < size(); ++i)\n-        if (!equals(row[i], other[i]))\n+    for (size_t i = 0; i < sort_description.size(); ++i)\n+        if (!equals(row[i], other.row[i]))\n             return false;\n     return true;\n }\n@@ -48,16 +49,16 @@ bool FillingRow::next(const FillingRow & to_row)\n     size_t pos = 0;\n \n     /// Find position we need to increment for generating next row.\n-    for (; pos < row.size(); ++pos)\n-        if (!row[pos].isNull() && !to_row[pos].isNull() && !equals(row[pos], to_row[pos]))\n+    for (; pos < size(); ++pos)\n+        if (!row[pos].isNull() && !to_row.row[pos].isNull() && !equals(row[pos], to_row.row[pos]))\n             break;\n \n-    if (pos == row.size() || less(to_row[pos], row[pos], getDirection(pos)))\n+    if (pos == size() || less(to_row.row[pos], row[pos], getDirection(pos)))\n         return false;\n \n     /// If we have any 'fill_to' value at position greater than 'pos',\n     ///  we need to generate rows up to 'fill_to' value.\n-    for (size_t i = row.size() - 1; i > pos; --i)\n+    for (size_t i = size() - 1; i > pos; --i)\n     {\n         if (getFillDescription(i).fill_to.isNull() || row[i].isNull())\n             continue;\n@@ -75,21 +76,22 @@ bool FillingRow::next(const FillingRow & to_row)\n     auto next_value = row[pos];\n     getFillDescription(pos).step_func(next_value);\n \n-    if (less(to_row[pos], next_value, getDirection(pos)))\n+    if (less(to_row.row[pos], next_value, getDirection(pos)))\n         return false;\n \n     row[pos] = next_value;\n-    if (equals(row[pos], to_row[pos]))\n+    if (equals(row[pos], to_row.row[pos]))\n     {\n         bool is_less = false;\n-        for (size_t i = pos + 1; i < size(); ++i)\n+        size_t i = pos + 1;\n+        for (; i < size(); ++i)\n         {\n             const auto & fill_from = getFillDescription(i).fill_from;\n             if (!fill_from.isNull())\n                 row[i] = fill_from;\n             else\n-                row[i] = to_row[i];\n-            is_less |= less(row[i], to_row[i], getDirection(i));\n+                row[i] = to_row.row[i];\n+            is_less |= less(row[i], to_row.row[i], getDirection(i));\n         }\n \n         return is_less;\n@@ -101,12 +103,12 @@ bool FillingRow::next(const FillingRow & to_row)\n \n void FillingRow::initFromDefaults(size_t from_pos)\n {\n-    for (size_t i = from_pos; i < row.size(); ++i)\n+    for (size_t i = from_pos; i < sort_description.size(); ++i)\n         row[i] = getFillDescription(i).fill_from;\n }\n \n-\n-void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & other_columns, const FillingRow & filling_row)\n+void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns,\n+    const FillingRow & filling_row, const Block & interpolate_block)\n {\n     for (size_t i = 0; i < filling_columns.size(); ++i)\n     {\n@@ -116,6 +118,16 @@ void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & oth\n             filling_columns[i]->insert(filling_row[i]);\n     }\n \n+    if (size_t size = interpolate_block.columns())\n+    {\n+        Columns columns = interpolate_block.getColumns();\n+        for (size_t i = 0; i < size; ++i)\n+            interpolate_columns[i]->insertFrom(*columns[i]->convertToFullColumnIfConst(), 0);\n+    }\n+    else\n+        for (const auto & interpolate_column : interpolate_columns)\n+            interpolate_column->insertDefault();\n+\n     for (const auto & other_column : other_columns)\n         other_column->insertDefault();\n }\ndiff --git a/src/Interpreters/FillingRow.h b/src/Interpreters/FillingRow.h\nindex 604f4b1ee741..626bee708969 100644\n--- a/src/Interpreters/FillingRow.h\n+++ b/src/Interpreters/FillingRow.h\n@@ -1,5 +1,6 @@\n #pragma once\n #include <Core/SortDescription.h>\n+#include <Core/InterpolateDescription.h>\n #include <Columns/IColumn.h>\n \n \n@@ -17,7 +18,7 @@ bool equals(const Field & lhs, const Field & rhs);\n class FillingRow\n {\n public:\n-    FillingRow(const SortDescription & sort_description);\n+    explicit FillingRow(const SortDescription & sort_description);\n \n     /// Generates next row according to fill 'from', 'to' and 'step' values.\n     bool next(const FillingRow & to_row);\n@@ -30,15 +31,16 @@ class FillingRow\n     bool operator<(const FillingRow & other) const;\n     bool operator==(const FillingRow & other) const;\n \n-    int getDirection(size_t index) const { return description[index].direction; }\n-    FillColumnDescription & getFillDescription(size_t index) { return description[index].fill_description; }\n+    int getDirection(size_t index) const { return sort_description[index].direction; }\n+    FillColumnDescription & getFillDescription(size_t index) { return sort_description[index].fill_description; }\n \n private:\n     Row row;\n-    SortDescription description;\n+    SortDescription sort_description;\n };\n \n-void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & other_columns, const FillingRow & filling_row);\n+void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns,\n+    const FillingRow & filling_row, const Block & interpolate_block);\n void copyRowFromColumns(MutableColumns & dest, const Columns & source, size_t row_num);\n \n }\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 5091debbe722..d4f0f3994a74 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -5,6 +5,7 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTOrderByElement.h>\n+#include <Parsers/ASTInterpolateElement.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n@@ -100,6 +101,7 @@ namespace ErrorCodes\n     extern const int INVALID_LIMIT_EXPRESSION;\n     extern const int INVALID_WITH_FILL_EXPRESSION;\n     extern const int ACCESS_DENIED;\n+    extern const int UNKNOWN_IDENTIFIER;\n }\n \n /// Assumes `storage` is set and the table filter (row-level security) is not empty.\n@@ -764,6 +766,7 @@ static std::pair<Field, std::optional<IntervalKind>> getWithFillStep(const ASTPt\n static FillColumnDescription getWithFillDescription(const ASTOrderByElement & order_by_elem, ContextPtr context)\n {\n     FillColumnDescription descr;\n+\n     if (order_by_elem.fill_from)\n         descr.fill_from = getWithFillFieldValue(order_by_elem.fill_from, context);\n     if (order_by_elem.fill_to)\n@@ -819,7 +822,6 @@ static SortDescription getSortDescription(const ASTSelectQuery & query, ContextP\n         std::shared_ptr<Collator> collator;\n         if (order_by_elem.collation)\n             collator = std::make_shared<Collator>(order_by_elem.collation->as<ASTLiteral &>().value.get<String>());\n-\n         if (order_by_elem.with_fill)\n         {\n             FillColumnDescription fill_desc = getWithFillDescription(order_by_elem, context);\n@@ -832,6 +834,77 @@ static SortDescription getSortDescription(const ASTSelectQuery & query, ContextP\n     return order_descr;\n }\n \n+static InterpolateDescriptionPtr getInterpolateDescription(\n+    const ASTSelectQuery & query, const Block & source_block, const Block & result_block, const Aliases & aliases, ContextPtr context)\n+{\n+    InterpolateDescriptionPtr interpolate_descr;\n+    if (query.interpolate())\n+    {\n+        NamesAndTypesList source_columns;\n+        ColumnsWithTypeAndName result_columns;\n+        ASTPtr exprs = std::make_shared<ASTExpressionList>();\n+\n+        if (query.interpolate()->children.empty())\n+        {\n+            std::unordered_map<String, DataTypePtr> column_names;\n+            for (const auto & column : result_block.getColumnsWithTypeAndName())\n+                column_names[column.name] = column.type;\n+            for (const auto & elem : query.orderBy()->children)\n+                if (elem->as<ASTOrderByElement>()->with_fill)\n+                    column_names.erase(elem->as<ASTOrderByElement>()->children.front()->getColumnName());\n+            for (const auto & [name, type] : column_names)\n+            {\n+                source_columns.emplace_back(name, type);\n+                result_columns.emplace_back(type, name);\n+                exprs->children.emplace_back(std::make_shared<ASTIdentifier>(name));\n+            }\n+        }\n+        else\n+        {\n+            NameSet col_set;\n+            for (const auto & elem : query.interpolate()->children)\n+            {\n+                const auto & interpolate = elem->as<ASTInterpolateElement &>();\n+\n+                if (const ColumnWithTypeAndName *result_block_column = result_block.findByName(interpolate.column))\n+                {\n+                    if (!col_set.insert(result_block_column->name).second)\n+                        throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n+                            \"Duplicate INTERPOLATE column '{}'\", interpolate.column);\n+\n+                    result_columns.emplace_back(result_block_column->type, result_block_column->name);\n+                }\n+                else\n+                    throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER,\n+                        \"Missing column '{}' as an INTERPOLATE expression target\", interpolate.column);\n+\n+                exprs->children.emplace_back(interpolate.expr->clone());\n+            }\n+\n+            col_set.clear();\n+            for (const auto & column : source_block)\n+            {\n+                source_columns.emplace_back(column.name, column.type);\n+                col_set.insert(column.name);\n+            }\n+            for (const auto & column : result_block)\n+                if (col_set.count(column.name) == 0)\n+                    source_columns.emplace_back(column.name, column.type);\n+        }\n+\n+        auto syntax_result = TreeRewriter(context).analyze(exprs, source_columns);\n+        ExpressionAnalyzer analyzer(exprs, syntax_result, context);\n+        ActionsDAGPtr actions = analyzer.getActionsDAG(true);\n+        ActionsDAGPtr conv_dag = ActionsDAG::makeConvertingActions(actions->getResultColumns(),\n+            result_columns, ActionsDAG::MatchColumnsMode::Position, true);\n+        ActionsDAGPtr merge_dag = ActionsDAG::merge(std::move(*actions->clone()), std::move(*conv_dag));\n+\n+        interpolate_descr = std::make_shared<InterpolateDescription>(merge_dag, aliases);\n+    }\n+\n+    return interpolate_descr;\n+}\n+\n static SortDescription getSortDescriptionFromGroupBy(const ASTSelectQuery & query)\n {\n     SortDescription order_descr;\n@@ -2499,7 +2572,9 @@ void InterpreterSelectQuery::executeWithFill(QueryPlan & query_plan)\n         if (fill_descr.empty())\n             return;\n \n-        auto filling_step = std::make_unique<FillingStep>(query_plan.getCurrentDataStream(), std::move(fill_descr));\n+        InterpolateDescriptionPtr interpolate_descr =\n+            getInterpolateDescription(query, source_header, result_header, syntax_analyzer_result->aliases, context);\n+        auto filling_step = std::make_unique<FillingStep>(query_plan.getCurrentDataStream(), std::move(fill_descr), interpolate_descr);\n         query_plan.addStep(std::move(filling_step));\n     }\n }\ndiff --git a/src/Interpreters/QueryNormalizer.cpp b/src/Interpreters/QueryNormalizer.cpp\nindex 7c820622c379..28b2195c9c3b 100644\n--- a/src/Interpreters/QueryNormalizer.cpp\n+++ b/src/Interpreters/QueryNormalizer.cpp\n@@ -9,6 +9,7 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTQueryParameter.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTInterpolateElement.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Common/quoteString.h>\n #include <IO/WriteHelpers.h>\n@@ -134,7 +135,8 @@ void QueryNormalizer::visit(ASTTablesInSelectQueryElement & node, const ASTPtr &\n \n static bool needVisitChild(const ASTPtr & child)\n {\n-    return !(child->as<ASTSelectQuery>() || child->as<ASTTableExpression>());\n+    /// exclude interpolate elements - they are not subject for normalization and will be processed in filling transform\n+    return !(child->as<ASTSelectQuery>() || child->as<ASTTableExpression>() || child->as<ASTInterpolateElement>());\n }\n \n /// special visitChildren() for ASTSelectQuery\ndiff --git a/src/Interpreters/RequiredSourceColumnsVisitor.cpp b/src/Interpreters/RequiredSourceColumnsVisitor.cpp\nindex 21ec94a6917d..cc9a2d86d287 100644\n--- a/src/Interpreters/RequiredSourceColumnsVisitor.cpp\n+++ b/src/Interpreters/RequiredSourceColumnsVisitor.cpp\n@@ -7,6 +7,7 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTInterpolateElement.h>\n \n namespace DB\n {\n@@ -46,7 +47,7 @@ bool RequiredSourceColumnsMatcher::needChildVisit(const ASTPtr & node, const AST\n         return false;\n \n     /// Processed. Do not need children.\n-    if (node->as<ASTTableExpression>() || node->as<ASTArrayJoin>() || node->as<ASTSelectQuery>())\n+    if (node->as<ASTTableExpression>() || node->as<ASTArrayJoin>() || node->as<ASTSelectQuery>() || node->as<ASTInterpolateElement>())\n         return false;\n \n     if (const auto * f = node->as<ASTFunction>())\n@@ -114,15 +115,42 @@ void RequiredSourceColumnsMatcher::visit(const ASTPtr & ast, Data & data)\n \n void RequiredSourceColumnsMatcher::visit(const ASTSelectQuery & select, const ASTPtr &, Data & data)\n {\n+    NameSet select_columns;\n     /// special case for top-level SELECT items: they are publics\n     for (auto & node : select.select()->children)\n     {\n+        select_columns.insert(node->getAliasOrColumnName());\n+\n         if (const auto * identifier = node->as<ASTIdentifier>())\n             data.addColumnIdentifier(*identifier);\n         else\n             data.addColumnAliasIfAny(*node);\n     }\n \n+    if (auto interpolate_list = select.interpolate())\n+    {\n+        auto find_columns = [&data, &select_columns](IAST * function)\n+        {\n+            auto f_impl = [&data, &select_columns](IAST * fn, auto fi)\n+            {\n+                if (auto * ident = fn->as<ASTIdentifier>())\n+                {\n+                    if (select_columns.count(ident->getColumnName()) == 0)\n+                        data.addColumnIdentifier(*ident);\n+                    return;\n+                }\n+                if (fn->as<ASTFunction>() || fn->as<ASTExpressionList>())\n+                    for (const auto & ch : fn->children)\n+                        fi(ch.get(), fi);\n+                return;\n+            };\n+            f_impl(function, f_impl);\n+        };\n+\n+        for (const auto & interpolate : interpolate_list->children)\n+            find_columns(interpolate->as<ASTInterpolateElement>()->expr.get());\n+    }\n+\n     if (const auto & with = select.with())\n     {\n         for (auto & node : with->children)\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 929e516f687d..d0e54f9f5984 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -32,6 +32,7 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTInterpolateElement.h>\n #include <Parsers/queryToString.h>\n \n #include <DataTypes/NestedUtils.h>\n@@ -420,7 +421,8 @@ void renameDuplicatedColumns(const ASTSelectQuery * select_query)\n /// Sometimes we have to calculate more columns in SELECT clause than will be returned from query.\n /// This is the case when we have DISTINCT or arrayJoin: we require more columns in SELECT even if we need less columns in result.\n /// Also we have to remove duplicates in case of GLOBAL subqueries. Their results are placed into tables so duplicates are impossible.\n-void removeUnneededColumnsFromSelectClause(const ASTSelectQuery * select_query, const Names & required_result_columns, bool remove_dups)\n+/// Also remove all INTERPOLATE columns which are not in SELECT anymore.\n+void removeUnneededColumnsFromSelectClause(ASTSelectQuery * select_query, const Names & required_result_columns, bool remove_dups)\n {\n     ASTs & elements = select_query->select()->children;\n \n@@ -449,6 +451,8 @@ void removeUnneededColumnsFromSelectClause(const ASTSelectQuery * select_query,\n     ASTs new_elements;\n     new_elements.reserve(elements.size());\n \n+    NameSet remove_columns;\n+\n     for (const auto & elem : elements)\n     {\n         String name = elem->getAliasOrColumnName();\n@@ -465,6 +469,8 @@ void removeUnneededColumnsFromSelectClause(const ASTSelectQuery * select_query,\n         }\n         else\n         {\n+            remove_columns.insert(name);\n+\n             ASTFunction * func = elem->as<ASTFunction>();\n \n             /// Never remove untuple. It's result column may be in required columns.\n@@ -478,6 +484,24 @@ void removeUnneededColumnsFromSelectClause(const ASTSelectQuery * select_query,\n         }\n     }\n \n+    if (select_query->interpolate())\n+    {\n+        auto & children = select_query->interpolate()->children;\n+        if (!children.empty())\n+        {\n+            for (auto it = children.begin(); it != children.end();)\n+            {\n+                if (remove_columns.count((*it)->as<ASTInterpolateElement>()->column))\n+                    it = select_query->interpolate()->children.erase(it);\n+                else\n+                    ++it;\n+            }\n+\n+            if (children.empty())\n+                select_query->setExpression(ASTSelectQuery::Expression::INTERPOLATE, nullptr);\n+        }\n+    }\n+\n     elements = std::move(new_elements);\n }\n \ndiff --git a/src/Parsers/ASTInterpolateElement.cpp b/src/Parsers/ASTInterpolateElement.cpp\nnew file mode 100644\nindex 000000000000..15531962eb9c\n--- /dev/null\n+++ b/src/Parsers/ASTInterpolateElement.cpp\n@@ -0,0 +1,16 @@\n+#include <Columns/Collator.h>\n+#include <Parsers/ASTInterpolateElement.h>\n+#include <Common/SipHash.h>\n+#include <IO/Operators.h>\n+\n+\n+namespace DB\n+{\n+\n+void ASTInterpolateElement::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+        settings.ostr << column << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\");\n+        expr->formatImpl(settings, state, frame);\n+}\n+\n+}\ndiff --git a/src/Parsers/ASTInterpolateElement.h b/src/Parsers/ASTInterpolateElement.h\nnew file mode 100644\nindex 000000000000..a278755de887\n--- /dev/null\n+++ b/src/Parsers/ASTInterpolateElement.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+\n+\n+namespace DB\n+{\n+\n+class ASTInterpolateElement : public IAST\n+{\n+public:\n+    String column;\n+    ASTPtr expr;\n+\n+    String getID(char delim) const override { return String(\"InterpolateElement\") + delim + \"(column \" + column + \")\"; }\n+\n+    ASTPtr clone() const override\n+    {\n+        auto clone = std::make_shared<ASTInterpolateElement>(*this);\n+        clone->expr = clone->expr->clone();\n+        clone->children.clear();\n+        clone->children.push_back(clone->expr);\n+        return clone;\n+    }\n+\n+\n+protected:\n+    void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n+};\n+\n+}\ndiff --git a/src/Parsers/ASTOrderByElement.h b/src/Parsers/ASTOrderByElement.h\nindex 8c868312834a..4d07405c17a2 100644\n--- a/src/Parsers/ASTOrderByElement.h\n+++ b/src/Parsers/ASTOrderByElement.h\n@@ -37,4 +37,5 @@ class ASTOrderByElement : public IAST\n protected:\n     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n };\n+\n }\ndiff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp\nindex 3f40167b1d16..048b9dfc38f9 100644\n--- a/src/Parsers/ASTSelectQuery.cpp\n+++ b/src/Parsers/ASTSelectQuery.cpp\n@@ -129,6 +129,17 @@ void ASTSelectQuery::formatImpl(const FormatSettings & s, FormatState & state, F\n         s.one_line\n             ? orderBy()->formatImpl(s, state, frame)\n             : orderBy()->as<ASTExpressionList &>().formatImplMultiline(s, state, frame);\n+\n+        if (interpolate())\n+        {\n+            s.ostr << (s.hilite ? hilite_keyword : \"\") << s.nl_or_ws << indent_str << \"INTERPOLATE\" << (s.hilite ? hilite_none : \"\");\n+            if (!interpolate()->children.empty())\n+            {\n+                s.ostr << \" (\";\n+                interpolate()->formatImpl(s, state, frame);\n+                s.ostr << \" )\";\n+            }\n+        }\n     }\n \n     if (limitByLength())\ndiff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h\nindex 9a8f1dbd2e71..4a30d6afee38 100644\n--- a/src/Parsers/ASTSelectQuery.h\n+++ b/src/Parsers/ASTSelectQuery.h\n@@ -32,7 +32,8 @@ class ASTSelectQuery : public IAST\n         LIMIT_BY,\n         LIMIT_OFFSET,\n         LIMIT_LENGTH,\n-        SETTINGS\n+        SETTINGS,\n+        INTERPOLATE\n     };\n \n     static String expressionToString(Expression expr)\n@@ -69,6 +70,8 @@ class ASTSelectQuery : public IAST\n                 return \"LIMIT LENGTH\";\n             case Expression::SETTINGS:\n                 return \"SETTINGS\";\n+            case Expression::INTERPOLATE:\n+                return \"INTERPOLATE\";\n         }\n         return \"\";\n     }\n@@ -91,21 +94,22 @@ class ASTSelectQuery : public IAST\n     ASTPtr & refWhere()     { return getExpression(Expression::WHERE); }\n     ASTPtr & refHaving()    { return getExpression(Expression::HAVING); }\n \n-    ASTPtr with()           const { return getExpression(Expression::WITH); }\n-    ASTPtr select()         const { return getExpression(Expression::SELECT); }\n-    ASTPtr tables()         const { return getExpression(Expression::TABLES); }\n-    ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }\n-    ASTPtr where()          const { return getExpression(Expression::WHERE); }\n-    ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }\n-    ASTPtr having()         const { return getExpression(Expression::HAVING); }\n-    ASTPtr window() const { return getExpression(Expression::WINDOW); }\n-    ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }\n-    ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }\n-    ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }\n-    ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }\n-    ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }\n-    ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }\n-    ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }\n+    const ASTPtr with()           const { return getExpression(Expression::WITH); }\n+    const ASTPtr select()         const { return getExpression(Expression::SELECT); }\n+    const ASTPtr tables()         const { return getExpression(Expression::TABLES); }\n+    const ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }\n+    const ASTPtr where()          const { return getExpression(Expression::WHERE); }\n+    const ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }\n+    const ASTPtr having()         const { return getExpression(Expression::HAVING); }\n+    const ASTPtr window()         const { return getExpression(Expression::WINDOW); }\n+    const ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }\n+    const ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }\n+    const ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }\n+    const ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }\n+    const ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }\n+    const ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }\n+    const ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }\n+    const ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }\n \n     bool hasFiltration() const { return where() || prewhere() || having(); }\n \ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex ef236388a044..cd07e304a39f 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -16,6 +16,7 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTOrderByElement.h>\n+#include <Parsers/ASTInterpolateElement.h>\n #include <Parsers/ASTQualifiedAsterisk.h>\n #include <Parsers/ASTQueryParameter.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n@@ -2316,6 +2317,35 @@ bool ParserOrderByElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expect\n     return true;\n }\n \n+bool ParserInterpolateElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ParserKeyword as(\"AS\");\n+    ParserExpression element_p;\n+    ParserIdentifier ident_p;\n+\n+    ASTPtr ident;\n+    if (!ident_p.parse(pos, ident, expected))\n+        return false;\n+\n+    ASTPtr expr;\n+    if (as.ignore(pos, expected))\n+    {\n+        if (!element_p.parse(pos, expr, expected))\n+            return false;\n+    }\n+    else\n+        expr = ident;\n+\n+    auto elem = std::make_shared<ASTInterpolateElement>();\n+    elem->column = ident->getColumnName();\n+    elem->expr = expr;\n+    elem->children.push_back(expr);\n+\n+    node = elem;\n+\n+    return true;\n+}\n+\n bool ParserFunctionWithKeyValueArguments::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserIdentifier id_parser;\ndiff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h\nindex c86721dca185..10b4f5fd7d1e 100644\n--- a/src/Parsers/ExpressionElementParsers.h\n+++ b/src/Parsers/ExpressionElementParsers.h\n@@ -420,6 +420,15 @@ class ParserOrderByElement : public IParserBase\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n+/** Element of INTERPOLATE expression\n+  */\n+class ParserInterpolateElement : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"element of INTERPOLATE expression\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n /** Parser for function with arguments like KEY VALUE (space separated)\n   * no commas allowed, just space-separated pairs.\n   */\ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 10cbd95ec590..8f5d1fa4ddac 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -763,6 +763,13 @@ bool ParserOrderByExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected &\n }\n \n \n+bool ParserInterpolateExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    return ParserList(std::make_unique<ParserInterpolateElement>(), std::make_unique<ParserToken>(TokenType::Comma), true)\n+        .parse(pos, node, expected);\n+}\n+\n+\n bool ParserTTLExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     return ParserList(std::make_unique<ParserTTLElement>(), std::make_unique<ParserToken>(TokenType::Comma), false)\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex 18d25bcb6d9b..2325433a00a7 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -517,6 +517,12 @@ class ParserOrderByExpressionList : public IParserBase\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n+class ParserInterpolateExpressionList : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"interpolate expression\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n \n /// Parser for key-value pair, where value can be list of pairs.\n class ParserKeyValuePair : public IParserBase\ndiff --git a/src/Parsers/ParserSelectQuery.cpp b/src/Parsers/ParserSelectQuery.cpp\nindex 90ab5911d6bb..572edd93e39d 100644\n--- a/src/Parsers/ParserSelectQuery.cpp\n+++ b/src/Parsers/ParserSelectQuery.cpp\n@@ -10,6 +10,10 @@\n #include <Parsers/ParserSelectQuery.h>\n #include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/ParserWithElement.h>\n+#include <Parsers/ASTOrderByElement.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTInterpolateElement.h>\n+#include <Parsers/ASTIdentifier.h>\n \n \n namespace DB\n@@ -59,12 +63,14 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_rows(\"ROWS\");\n     ParserKeyword s_first(\"FIRST\");\n     ParserKeyword s_next(\"NEXT\");\n+    ParserKeyword s_interpolate(\"INTERPOLATE\");\n \n     ParserNotEmptyExpressionList exp_list(false);\n     ParserNotEmptyExpressionList exp_list_for_with_clause(false);\n     ParserNotEmptyExpressionList exp_list_for_select_clause(true);    /// Allows aliases without AS keyword.\n     ParserExpressionWithOptionalAlias exp_elem(false);\n     ParserOrderByExpressionList order_list;\n+    ParserInterpolateExpressionList interpolate_list;\n \n     ParserToken open_bracket(TokenType::OpeningRoundBracket);\n     ParserToken close_bracket(TokenType::ClosingRoundBracket);\n@@ -78,6 +84,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ASTPtr having_expression;\n     ASTPtr window_list;\n     ASTPtr order_expression_list;\n+    ASTPtr interpolate_expression_list;\n     ASTPtr limit_by_length;\n     ASTPtr limit_by_offset;\n     ASTPtr limit_by_expression_list;\n@@ -239,6 +246,23 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         if (!order_list.parse(pos, order_expression_list, expected))\n             return false;\n+\n+        /// if any WITH FILL parse possible INTERPOLATE list\n+        if (std::any_of(order_expression_list->children.begin(), order_expression_list->children.end(),\n+                [](auto & child) { return child->template as<ASTOrderByElement>()->with_fill; }))\n+        {\n+            if (s_interpolate.ignore(pos, expected))\n+            {\n+                if (open_bracket.ignore(pos, expected))\n+                {\n+                    if (!interpolate_list.parse(pos, interpolate_expression_list, expected))\n+                        return false;\n+                    if (!close_bracket.ignore(pos, expected))\n+                        return false;\n+                } else\n+                    interpolate_expression_list = std::make_shared<ASTExpressionList>();\n+            }\n+        }\n     }\n \n     /// This is needed for TOP expression, because it can also use WITH TIES.\n@@ -430,6 +454,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     select_query->setExpression(ASTSelectQuery::Expression::LIMIT_OFFSET, std::move(limit_offset));\n     select_query->setExpression(ASTSelectQuery::Expression::LIMIT_LENGTH, std::move(limit_length));\n     select_query->setExpression(ASTSelectQuery::Expression::SETTINGS, std::move(settings));\n+    select_query->setExpression(ASTSelectQuery::Expression::INTERPOLATE, std::move(interpolate_expression_list));\n     return true;\n }\n \ndiff --git a/src/Processors/QueryPlan/FillingStep.cpp b/src/Processors/QueryPlan/FillingStep.cpp\nindex a94bbdb08775..41bc2f44dbab 100644\n--- a/src/Processors/QueryPlan/FillingStep.cpp\n+++ b/src/Processors/QueryPlan/FillingStep.cpp\n@@ -28,9 +28,9 @@ static ITransformingStep::Traits getTraits()\n     };\n }\n \n-FillingStep::FillingStep(const DataStream & input_stream_, SortDescription sort_description_)\n+FillingStep::FillingStep(const DataStream & input_stream_, SortDescription sort_description_, InterpolateDescriptionPtr interpolate_description_)\n     : ITransformingStep(input_stream_, FillingTransform::transformHeader(input_stream_.header, sort_description_), getTraits())\n-    , sort_description(std::move(sort_description_))\n+    , sort_description(std::move(sort_description_)), interpolate_description(interpolate_description_)\n {\n     if (!input_stream_.has_single_port)\n         throw Exception(\"FillingStep expects single input\", ErrorCodes::LOGICAL_ERROR);\n@@ -41,7 +41,7 @@ void FillingStep::transformPipeline(QueryPipelineBuilder & pipeline, const Build\n     pipeline.addSimpleTransform([&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr\n     {\n         bool on_totals = stream_type == QueryPipelineBuilder::StreamType::Totals;\n-        return std::make_shared<FillingTransform>(header, sort_description, on_totals);\n+        return std::make_shared<FillingTransform>(header, sort_description, std::move(interpolate_description), on_totals);\n     });\n }\n \ndiff --git a/src/Processors/QueryPlan/FillingStep.h b/src/Processors/QueryPlan/FillingStep.h\nindex 6a5bca1890d4..0393b2c525b2 100644\n--- a/src/Processors/QueryPlan/FillingStep.h\n+++ b/src/Processors/QueryPlan/FillingStep.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include <Processors/QueryPlan/ITransformingStep.h>\n #include <Core/SortDescription.h>\n+#include <Core/InterpolateDescription.h>\n \n namespace DB\n {\n@@ -9,7 +10,7 @@ namespace DB\n class FillingStep : public ITransformingStep\n {\n public:\n-    FillingStep(const DataStream & input_stream_, SortDescription sort_description_);\n+    FillingStep(const DataStream & input_stream_, SortDescription sort_description_, InterpolateDescriptionPtr interpolate_description_);\n \n     String getName() const override { return \"Filling\"; }\n \n@@ -22,6 +23,7 @@ class FillingStep : public ITransformingStep\n \n private:\n     SortDescription sort_description;\n+    InterpolateDescriptionPtr interpolate_description;\n };\n \n }\ndiff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex ae97a769b238..c7bcd03ec089 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -18,7 +18,7 @@ namespace ErrorCodes\n     extern const int INVALID_WITH_FILL_EXPRESSION;\n }\n \n-Block FillingTransform::transformHeader(Block header, const SortDescription & sort_description)\n+Block FillingTransform::transformHeader(Block header, const SortDescription & sort_description/*, const InterpolateDescription & interpolate_description*/)\n {\n     NameSet sort_keys;\n     for (const auto & key : sort_description)\n@@ -138,19 +138,28 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n }\n \n FillingTransform::FillingTransform(\n-    const Block & header_, const SortDescription & sort_description_, bool on_totals_)\n-    : ISimpleTransform(header_, transformHeader(header_, sort_description_), true)\n-    , sort_description(sort_description_)\n-    , on_totals(on_totals_)\n-    , filling_row(sort_description_)\n-    , next_row(sort_description_)\n+        const Block & header_, const SortDescription & sort_description_, InterpolateDescriptionPtr interpolate_description_, bool on_totals_)\n+        : ISimpleTransform(header_, transformHeader(header_, sort_description_), true)\n+        , sort_description(sort_description_)\n+        , interpolate_description(interpolate_description_)\n+        , on_totals(on_totals_)\n+        , filling_row(sort_description_)\n+        , next_row(sort_description_)\n {\n     if (on_totals)\n         return;\n \n+    if (interpolate_description)\n+        interpolate_actions = std::make_shared<ExpressionActions>(interpolate_description->actions);\n+\n     std::vector<bool> is_fill_column(header_.columns());\n     for (size_t i = 0, size = sort_description.size(); i < size; ++i)\n     {\n+        if (interpolate_description && interpolate_description->result_columns_set.count(sort_description[i].column_name))\n+            throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n+                \"Column '{}' is participating in ORDER BY ... WITH FILL expression and can't be INTERPOLATE output\",\n+                sort_description[i].column_name);\n+\n         size_t block_position = header_.getPositionByName(sort_description[i].column_name);\n         is_fill_column[block_position] = true;\n         fill_column_positions.push_back(block_position);\n@@ -176,9 +185,23 @@ FillingTransform::FillingTransform(\n         if (!unique_positions.insert(pos).second)\n             throw Exception(\"Multiple WITH FILL for identical expressions is not supported in ORDER BY\", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n \n-    for (size_t i = 0; i < header_.columns(); ++i)\n-        if (!is_fill_column[i])\n-            other_column_positions.push_back(i);\n+    size_t idx = 0;\n+    for (const ColumnWithTypeAndName & column : header_.getColumnsWithTypeAndName())\n+    {\n+        if (interpolate_description)\n+            if (const auto & p = interpolate_description->required_columns_map.find(column.name);\n+                p != interpolate_description->required_columns_map.end())\n+                    input_positions.emplace_back(idx, p->second);\n+\n+        if (!is_fill_column[idx] && !(interpolate_description && interpolate_description->result_columns_set.count(column.name)))\n+                other_column_positions.push_back(idx);\n+\n+        ++idx;\n+    }\n+\n+    if (interpolate_description)\n+        for (const auto & name : interpolate_description->result_columns_order)\n+            interpolate_column_positions.push_back(header_.getPositionByName(name));\n }\n \n IProcessor::Status FillingTransform::prepare()\n@@ -207,37 +230,90 @@ void FillingTransform::transform(Chunk & chunk)\n         return;\n \n     Columns old_fill_columns;\n+    Columns old_interpolate_columns;\n     Columns old_other_columns;\n     MutableColumns res_fill_columns;\n+    MutableColumns res_interpolate_columns;\n     MutableColumns res_other_columns;\n \n-    auto init_columns_by_positions = [](const Columns & old_columns, Columns & new_columns,\n-                                        MutableColumns & new_mutable_columns, const Positions & positions)\n+    std::vector<std::pair<MutableColumns *, size_t>> res_map;\n+    res_map.resize(input.getHeader().columns());\n+\n+    auto init_columns_by_positions = [&res_map](const Columns & old_columns, Columns & new_columns,\n+        MutableColumns & new_mutable_columns, const Positions & positions)\n     {\n         for (size_t pos : positions)\n         {\n             auto old_column = old_columns[pos]->convertToFullColumnIfConst();\n             new_columns.push_back(old_column);\n+            res_map[pos] = {&new_mutable_columns, new_mutable_columns.size()};\n             new_mutable_columns.push_back(old_column->cloneEmpty()->assumeMutable());\n         }\n     };\n \n+    Block interpolate_block;\n+\n+    auto interpolate = [&]()\n+    {\n+        if (interpolate_description)\n+        {\n+            interpolate_block.clear();\n+\n+            if (!input_positions.empty())\n+            {\n+                /// populate calculation block with required columns with values from previous row\n+                for (const auto & [col_pos, name_type] : input_positions)\n+                {\n+                    MutableColumnPtr column = name_type.type->createColumn();\n+                    auto [res_columns, pos] = res_map[col_pos];\n+                    size_t size = (*res_columns)[pos]->size();\n+                    if (size == 0) /// this is the first row in current chunk\n+                    {\n+                        /// take value from last row of previous chunk if exists, else use default\n+                        if (last_row.size() > col_pos && !last_row[col_pos]->empty())\n+                            column->insertFrom(*last_row[col_pos], 0);\n+                        else\n+                            column->insertDefault();\n+                    }\n+                    else /// take value from previous row of current chunk\n+                        column->insertFrom(*(*res_columns)[pos], size - 1);\n+\n+                    interpolate_block.insert({std::move(column), name_type.type, name_type.name});\n+                }\n+                interpolate_actions->execute(interpolate_block);\n+            }\n+            else /// all INTERPOLATE expressions are constants\n+            {\n+                size_t n = 1;\n+                interpolate_actions->execute(interpolate_block, n);\n+            }\n+        }\n+    };\n+\n     if (generate_suffix)\n     {\n         const auto & empty_columns = input.getHeader().getColumns();\n         init_columns_by_positions(empty_columns, old_fill_columns, res_fill_columns, fill_column_positions);\n+        init_columns_by_positions(empty_columns, old_interpolate_columns, res_interpolate_columns, interpolate_column_positions);\n         init_columns_by_positions(empty_columns, old_other_columns, res_other_columns, other_column_positions);\n \n         if (first)\n             filling_row.initFromDefaults();\n \n         if (should_insert_first && filling_row < next_row)\n-            insertFromFillingRow(res_fill_columns, res_other_columns, filling_row);\n+        {\n+            interpolate();\n+            insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+        }\n \n+        interpolate();\n         while (filling_row.next(next_row))\n-            insertFromFillingRow(res_fill_columns, res_other_columns, filling_row);\n+        {\n+                insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+                interpolate();\n+        }\n \n-        setResultColumns(chunk, res_fill_columns, res_other_columns);\n+        setResultColumns(chunk, res_fill_columns, res_interpolate_columns, res_other_columns);\n         return;\n     }\n \n@@ -245,6 +321,7 @@ void FillingTransform::transform(Chunk & chunk)\n     auto old_columns = chunk.detachColumns();\n \n     init_columns_by_positions(old_columns, old_fill_columns, res_fill_columns, fill_column_positions);\n+    init_columns_by_positions(old_columns, old_interpolate_columns, res_interpolate_columns, interpolate_column_positions);\n     init_columns_by_positions(old_columns, old_other_columns, res_other_columns, other_column_positions);\n \n     if (first)\n@@ -258,7 +335,10 @@ void FillingTransform::transform(Chunk & chunk)\n             {\n                 filling_row.initFromDefaults(i);\n                 if (less(fill_from, current_value, filling_row.getDirection(i)))\n-                    insertFromFillingRow(res_fill_columns, res_other_columns, filling_row);\n+                {\n+                    interpolate();\n+                    insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+                }\n                 break;\n             }\n             filling_row[i] = current_value;\n@@ -284,31 +364,72 @@ void FillingTransform::transform(Chunk & chunk)\n         /// A case, when at previous step row was initialized from defaults 'fill_from' values\n         ///  and probably we need to insert it to block.\n         if (should_insert_first && filling_row < next_row)\n-            insertFromFillingRow(res_fill_columns, res_other_columns, filling_row);\n+        {\n+            interpolate();\n+            insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+        }\n \n-        /// Insert generated filling row to block, while it is less than current row in block.\n+        interpolate();\n         while (filling_row.next(next_row))\n-            insertFromFillingRow(res_fill_columns, res_other_columns, filling_row);\n+        {\n+            insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+            interpolate();\n+        }\n \n         copyRowFromColumns(res_fill_columns, old_fill_columns, row_ind);\n+        copyRowFromColumns(res_interpolate_columns, old_interpolate_columns, row_ind);\n         copyRowFromColumns(res_other_columns, old_other_columns, row_ind);\n     }\n \n-    setResultColumns(chunk, res_fill_columns, res_other_columns);\n+    saveLastRow(res_fill_columns, res_interpolate_columns, res_other_columns);\n+    setResultColumns(chunk, res_fill_columns, res_interpolate_columns, res_other_columns);\n }\n \n-void FillingTransform::setResultColumns(Chunk & chunk, MutableColumns & fill_columns, MutableColumns & other_columns) const\n+void FillingTransform::setResultColumns(Chunk & chunk, MutableColumns & fill_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns) const\n {\n-    MutableColumns result_columns(fill_columns.size() + other_columns.size());\n+    MutableColumns result_columns(fill_columns.size() + interpolate_columns.size() + other_columns.size());\n     /// fill_columns always non-empty.\n     size_t num_rows = fill_columns[0]->size();\n \n     for (size_t i = 0, size = fill_columns.size(); i < size; ++i)\n         result_columns[fill_column_positions[i]] = std::move(fill_columns[i]);\n+    for (size_t i = 0, size = interpolate_columns.size(); i < size; ++i)\n+        result_columns[interpolate_column_positions[i]] = std::move(interpolate_columns[i]);\n     for (size_t i = 0, size = other_columns.size(); i < size; ++i)\n         result_columns[other_column_positions[i]] = std::move(other_columns[i]);\n \n     chunk.setColumns(std::move(result_columns), num_rows);\n }\n \n+void FillingTransform::saveLastRow(const MutableColumns & fill_columns, const MutableColumns & interpolate_columns, const MutableColumns & other_columns)\n+{\n+    last_row.clear();\n+    last_row.resize(fill_columns.size() + interpolate_columns.size() + other_columns.size());\n+\n+    size_t num_rows = fill_columns[0]->size();\n+    if (num_rows == 0)\n+        return;\n+\n+    for (size_t i = 0, size = fill_columns.size(); i < size; ++i)\n+    {\n+        auto column = fill_columns[i]->cloneEmpty();\n+        column->insertFrom(*fill_columns[i], num_rows - 1);\n+        last_row[fill_column_positions[i]] = std::move(column);\n+    }\n+\n+    for (size_t i = 0, size = interpolate_columns.size(); i < size; ++i)\n+    {\n+        auto column = interpolate_columns[i]->cloneEmpty();\n+        column->insertFrom(*interpolate_columns[i], num_rows - 1);\n+        last_row[interpolate_column_positions[i]] = std::move(column);\n+    }\n+\n+    for (size_t i = 0, size = other_columns.size(); i < size; ++i)\n+    {\n+        auto column = other_columns[i]->cloneEmpty();\n+        column->insertFrom(*other_columns[i], num_rows - 1);\n+        last_row[other_column_positions[i]] = std::move(column);\n+    }\n+}\n+\n }\ndiff --git a/src/Processors/Transforms/FillingTransform.h b/src/Processors/Transforms/FillingTransform.h\nindex 7ccebadfb6da..5e1068e18e23 100644\n--- a/src/Processors/Transforms/FillingTransform.h\n+++ b/src/Processors/Transforms/FillingTransform.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include <Processors/ISimpleTransform.h>\n #include <Core/SortDescription.h>\n+#include <Core/InterpolateDescription.h>\n #include <Interpreters/FillingRow.h>\n \n namespace DB\n@@ -13,7 +14,7 @@ namespace DB\n class FillingTransform : public ISimpleTransform\n {\n public:\n-    FillingTransform(const Block & header_, const SortDescription & sort_description_, bool on_totals_);\n+    FillingTransform(const Block & header_, const SortDescription & sort_description_, InterpolateDescriptionPtr interpolate_description_, bool on_totals_);\n \n     String getName() const override { return \"FillingTransform\"; }\n \n@@ -25,9 +26,11 @@ class FillingTransform : public ISimpleTransform\n     void transform(Chunk & Chunk) override;\n \n private:\n-    void setResultColumns(Chunk & chunk, MutableColumns & fill_columns, MutableColumns & other_columns) const;\n+    void setResultColumns(Chunk & chunk, MutableColumns & fill_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns) const;\n+    void saveLastRow(const MutableColumns & fill_columns, const MutableColumns & interpolate_columns, const MutableColumns & other_columns);\n \n-    const SortDescription sort_description; /// Contains only rows with WITH FILL.\n+    const SortDescription sort_description; /// Contains only columns with WITH FILL.\n+    const InterpolateDescriptionPtr interpolate_description; /// Contains INTERPOLATE columns\n     const bool on_totals; /// FillingTransform does nothing on totals.\n \n     FillingRow filling_row; /// Current row, which is used to fill gaps.\n@@ -35,10 +38,15 @@ class FillingTransform : public ISimpleTransform\n \n     using Positions = std::vector<size_t>;\n     Positions fill_column_positions;\n+    Positions interpolate_column_positions;\n     Positions other_column_positions;\n+    std::vector<std::pair<size_t, NameAndTypePair>> input_positions; /// positions in result columns required for actions\n+    ExpressionActionsPtr interpolate_actions;\n     bool first = true;\n     bool generate_suffix = false;\n \n+    Columns last_row;\n+\n     /// Determines should we insert filling row before start generating next rows.\n     bool should_insert_first = false;\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02233_interpolate_1.reference b/tests/queries/0_stateless/02233_interpolate_1.reference\nnew file mode 100644\nindex 000000000000..64f5a8308bf3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02233_interpolate_1.reference\n@@ -0,0 +1,240 @@\n+0\t\t0\n+0.5\t\t0\n+1\toriginal\t1\n+1.5\t\t0\n+2\t\t0\n+2.5\t\t0\n+3\t\t0\n+3.5\t\t0\n+4\toriginal\t4\n+4.5\t\t0\n+5\t\t0\n+5.5\t\t0\n+6\t\t0\n+6.5\t\t0\n+7\toriginal\t7\n+7.5\t\t0\n+8\t\t0\n+8.5\t\t0\n+9\t\t0\n+9.5\t\t0\n+10\t\t0\n+10.5\t\t0\n+11\t\t0\n+11.5\t\t0\n+0\t\t42\n+0.5\t\t42\n+1\toriginal\t1\n+1.5\t\t42\n+2\t\t42\n+2.5\t\t42\n+3\t\t42\n+3.5\t\t42\n+4\toriginal\t4\n+4.5\t\t42\n+5\t\t42\n+5.5\t\t42\n+6\t\t42\n+6.5\t\t42\n+7\toriginal\t7\n+7.5\t\t42\n+8\t\t42\n+8.5\t\t42\n+9\t\t42\n+9.5\t\t42\n+10\t\t42\n+10.5\t\t42\n+11\t\t42\n+11.5\t\t42\n+0\t\t0\n+0.5\t\t0\n+1\toriginal\t1\n+1.5\t\t1\n+2\t\t1\n+2.5\t\t1\n+3\t\t1\n+3.5\t\t1\n+4\toriginal\t4\n+4.5\t\t4\n+5\t\t4\n+5.5\t\t4\n+6\t\t4\n+6.5\t\t4\n+7\toriginal\t7\n+7.5\t\t7\n+8\t\t7\n+8.5\t\t7\n+9\t\t7\n+9.5\t\t7\n+10\t\t7\n+10.5\t\t7\n+11\t\t7\n+11.5\t\t7\n+0\t\t1\n+0.5\t\t2\n+1\toriginal\t1\n+1.5\t\t2\n+2\t\t3\n+2.5\t\t4\n+3\t\t5\n+3.5\t\t6\n+4\toriginal\t4\n+4.5\t\t5\n+5\t\t6\n+5.5\t\t7\n+6\t\t8\n+6.5\t\t9\n+7\toriginal\t7\n+7.5\t\t8\n+8\t\t9\n+8.5\t\t10\n+9\t\t11\n+9.5\t\t12\n+10\t\t13\n+10.5\t\t14\n+11\t\t15\n+11.5\t\t16\n+0\t\t1\n+0.5\t\t2\n+1\toriginal\t2\n+1.5\t\t3\n+2\t\t4\n+2.5\t\t5\n+3\t\t6\n+3.5\t\t7\n+4\toriginal\t5\n+4.5\t\t6\n+5\t\t7\n+5.5\t\t8\n+6\t\t9\n+6.5\t\t10\n+7\toriginal\t8\n+7.5\t\t9\n+8\t\t10\n+8.5\t\t11\n+9\t\t12\n+9.5\t\t13\n+10\t\t14\n+10.5\t\t15\n+11\t\t16\n+11.5\t\t17\n+\t0\n+\t0\n+original\t1\n+\t3\n+\t3\n+\t3\n+\t3\n+\t3\n+original\t4\n+\t9\n+\t9\n+\t9\n+\t9\n+\t9\n+original\t7\n+\t15\n+\t15\n+\t15\n+\t15\n+\t15\n+\t15\n+\t15\n+\t15\n+\t15\n+0\t\t0\n+0.5\t\t0\n+1\toriginal\t1\n+1.5\t\t3\n+2\t\t3\n+2.5\t\t3\n+3\t\t3\n+3.5\t\t3\n+4\toriginal\t4\n+4.5\t\t9\n+5\t\t9\n+5.5\t\t9\n+6\t\t9\n+6.5\t\t9\n+7\toriginal\t7\n+7.5\t\t15\n+8\t\t15\n+8.5\t\t15\n+9\t\t15\n+9.5\t\t15\n+10\t\t15\n+10.5\t\t15\n+11\t\t15\n+11.5\t\t15\n+0\t\t1\n+0.5\t\t2\n+1\toriginal\t1\n+1.5\t\t2\n+2\t\t3\n+2.5\t\t4\n+3\t\t5\n+3.5\t\t6\n+4\toriginal\t4\n+4.5\t\t5\n+5\t\t6\n+5.5\t\t7\n+6\t\t8\n+6.5\t\t9\n+7\toriginal\t7\n+7.5\t\t8\n+8\t\t9\n+8.5\t\t10\n+9\t\t11\n+9.5\t\t12\n+10\t\t13\n+10.5\t\t14\n+11\t\t15\n+11.5\t\t16\n+0\t\t\\N\n+0.5\t\t\\N\n+1\toriginal\t\\N\n+1.5\t\t\\N\n+2\t\t\\N\n+2.5\t\t\\N\n+3\t\t\\N\n+3.5\t\t\\N\n+4\toriginal\t\\N\n+4.5\t\t\\N\n+5\t\t\\N\n+5.5\t\t\\N\n+6\t\t\\N\n+6.5\t\t\\N\n+7\toriginal\t\\N\n+7.5\t\t\\N\n+8\t\t\\N\n+8.5\t\t\\N\n+9\t\t\\N\n+9.5\t\t\\N\n+10\t\t\\N\n+10.5\t\t\\N\n+11\t\t\\N\n+11.5\t\t\\N\n+0\t\t\\N\n+0.5\t\t\\N\n+1\toriginal\t\\N\n+1.5\t\t\\N\n+2\t\t\\N\n+2.5\t\t\\N\n+3\t\t\\N\n+3.5\t\t\\N\n+4\toriginal\t\\N\n+4.5\t\t\\N\n+5\t\t\\N\n+5.5\t\t\\N\n+6\t\t\\N\n+6.5\t\t\\N\n+7\toriginal\t\\N\n+7.5\t\t\\N\n+8\t\t\\N\n+8.5\t\t\\N\n+9\t\t\\N\n+9.5\t\t\\N\n+10\t\t\\N\n+10.5\t\t\\N\n+11\t\t\\N\n+11.5\t\t\\N\ndiff --git a/tests/queries/0_stateless/02233_interpolate_1.sql b/tests/queries/0_stateless/02233_interpolate_1.sql\nnew file mode 100644\nindex 000000000000..b11385e17b60\n--- /dev/null\n+++ b/tests/queries/0_stateless/02233_interpolate_1.sql\n@@ -0,0 +1,72 @@\n+# Test WITH FILL without INTERPOLATE\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5;\n+\n+# Test INTERPOLATE with const\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS 42);\n+\n+# Test INTERPOLATE with field value\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS inter);\n+\n+# Test INTERPOLATE with expression\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);\n+\n+# Test INTERPOLATE with incompatible const - should produce error\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS 'inter'); -- { serverError 6 }\n+\n+# Test INTERPOLATE with incompatible expression - should produce error\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS inter||'inter'); -- { serverError 44 }\n+\n+# Test INTERPOLATE with column from WITH FILL expression - should produce error\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (n AS n); -- { serverError 475 }\n+\n+# Test INTERPOLATE with inconsistent column - should produce error\n+SELECT n, source, inter FROM (\n+   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS source); -- { serverError 32 }\n+\n+# Test INTERPOLATE with aliased column\n+SELECT n, source, inter + 1 AS inter_p FROM (\n+    SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter FROM numbers(10) WHERE (number % 3) = 1\n+) ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter_p AS inter_p + 1 );\n+\n+# Test INTERPOLATE with column not present in select\n+SELECT source, inter FROM (\n+    SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter, number + 1 AS inter2 FROM numbers(10) WHERE (number % 3) = 1\n+) ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter AS inter2 + inter );\n+\n+# Test INTERPOLATE in sub-select\n+SELECT n, source, inter FROM (\n+    SELECT n, source, inter, inter2 FROM (\n+        SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter, number + 1 AS inter2 FROM numbers(10) WHERE (number % 3) = 1\n+    ) ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter AS inter + inter2 )\n+);\n+\n+# Test INTERPOLATE with aggregates\n+SELECT n, any(source), sum(inter) AS inter_s FROM (\n+    SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter FROM numbers(10) WHERE (number % 3) = 1\n+) GROUP BY n\n+ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter_s AS inter_s + 1 );\n+\n+# Test INTERPOLATE with Nullable in result\n+SELECT n, source, inter + NULL AS inter_p FROM (\n+    SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter FROM numbers(10) WHERE (number % 3) = 1\n+) ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter_p AS inter_p + 1 );\n+\n+# Test INTERPOLATE with Nullable in source\n+SELECT n, source, inter AS inter_p FROM (\n+    SELECT toFloat32(number % 10) AS n, 'original' AS source, number + NULL AS inter FROM numbers(10) WHERE (number % 3) = 1\n+) ORDER BY n ASC WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE ( inter_p AS inter_p + 1 );\n",
  "problem_statement": "ORDER BY WITH FILL with last values\nThere is a table with balances. All balances are included in this table. Some balances can change several times a day, and some balances can change at all once in all time.\r\n\r\n```sql\r\ncreate table aaa (\r\n    d Date,\r\n    dd DateTime,\r\n    balanceAccountId UInt64,\r\n    activeBalance Int64,\r\n    inactiveBalance Int64\r\n) ENGINE Memory();\r\n\r\ninsert into aaa (d, dd, balanceAccountId, activeBalance, inactiveBalance) VALUES\r\n('2022-01-03', '2022-01-03 15:44:21', 1, 1000, 0),\r\n('2022-01-05', '2022-01-05 10:01:56', 2, 2000, 100),\r\n('2022-01-26', '2022-01-26 08:30:23', 3, 0, 500),\r\n('2022-01-26', '2022-01-26 16:25:41', 2, 1000, 0),\r\n('2022-01-26', '2022-01-26 17:09:54', 3, 100, 500),\r\n('2022-02-10', '2022-02-10 21:01:33', 1, 2000, 0);\r\n```\r\n\r\nAt the same time, for example, for any day you need to receive the amount for all balances. You also need to receive balance sheet amounts by day for the last month, for example. And so on.\r\n\r\n```sql\r\nselect any(d) d, sum(aBalance)active, sum(iBalance) inactive, active + inactive balance\r\nfrom (\r\n    with date(dateSub(DAY, 15, NOW())) as current_date\r\n    select current_date d, argMax(activeBalance, dd) aBalance, argMax(inactiveBalance, dd) iBalance\r\n    from aaa\r\n    where dd <= current_date\r\n    group by balanceAccountId\r\n);\r\n\r\n+----------+------+--------+-------+\r\n|d         |active|inactive|balance|\r\n+----------+------+--------+-------+\r\n|2022-02-09|2100  |500     |2600   |\r\n+----------+------+--------+-------+\r\n\r\nselect any(d) d, sum(aBalance)active, sum(iBalance) inactive, active + inactive balance\r\nfrom (\r\n    with date(dateSub(DAY, 10, NOW())) as current_date\r\n    select current_date d, argMax(activeBalance, dd) aBalance, argMax(inactiveBalance, dd) iBalance\r\n    from aaa\r\n    where dd <= current_date\r\n    group by balanceAccountId\r\n);\r\n+----------+------+--------+-------+\r\n|d         |active|inactive|balance|\r\n+----------+------+--------+-------+\r\n|2022-02-14|3100  |500     |3600   |\r\n+----------+------+--------+-------+\r\n```\r\n\r\nIf there was an analogue of ORDER BY WITH FILL, but with the saving of data on the last records, and not with default, as is now possible, then it would probably be possible to solve this problem gracefully. But maybe there are other ways?\n",
  "hints_text": "Makes sense and is easy to implement, we only need to come up with a syntax for it.\n> we only need to come up with a syntax for it.\r\n\r\n```sql\r\nSELECT\r\n    n,\r\n    source,\r\n    x\r\nFROM\r\n(\r\n    SELECT\r\n        toFloat32(number % 10) AS n,\r\n        concat('original', toString(number)) AS source,\r\n        number AS x\r\n    FROM numbers(10)\r\n    WHERE (number % 3) = 1\r\n)\r\nORDER BY n ASC WITH FILL FROM 0 TO 5.51 STEP 0.5\r\n\r\nQuery id: aa165b61-bd57-4ba4-8522-ff2e82d10110\r\n\r\n\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u2500\u252c\u2500x\u2500\u2510\r\n\u2502   0 \u2502           \u2502 0 \u2502\r\n\u2502 0.5 \u2502           \u2502 0 \u2502\r\n\u2502   1 \u2502 original1 \u2502 1 \u2502\r\n\u2502 1.5 \u2502           \u2502 0 \u2502\r\n\u2502   2 \u2502           \u2502 0 \u2502\r\n\u2502 2.5 \u2502           \u2502 0 \u2502\r\n\u2502   3 \u2502           \u2502 0 \u2502\r\n\u2502 3.5 \u2502           \u2502 0 \u2502\r\n\u2502   4 \u2502 original4 \u2502 4 \u2502\r\n\u2502 4.5 \u2502           \u2502 0 \u2502\r\n\u2502   5 \u2502           \u2502 0 \u2502\r\n\u2502 5.5 \u2502           \u2502 0 \u2502\r\n\u2502   7 \u2502 original7 \u2502 7 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\r\nsomething like \r\n\r\n```sql\r\nSELECT\r\n    n,\r\n    source,\r\n    x\r\nFROM\r\n(\r\n    SELECT\r\n        toFloat32(number % 10) AS n, 'original'||toString(number) AS source, number x\r\n    FROM numbers(10)\r\n    WHERE (number % 3) = 1\r\n)\r\nORDER BY n ASC WITH FILL FROM 0 TO 5.51 STEP 0.5 \r\nINTERPOLATE (source PREVIOUS VALUE source||'xxx', x PREVIOUS VALUE x+1);\r\n\r\n\u250c\u2500\u2500\u2500n\u2500\u252c\u2500source\u2500\u2500\u2500\u2500\u252c\u2500x\u2500\u2510\r\n\u2502   0 \u2502           \u2502 0 \u2502\r\n\u2502 0.5 \u2502           \u2502 1 \u2502\r\n\u2502   1 \u2502 original1 \u2502 1 \u2502\r\n\u2502 1.5 \u2502 original1 \u2502 2 \u2502\r\n\u2502   2 \u2502 original1 \u2502 3 \u2502\r\n\u2502 2.5 \u2502 original1 \u2502 4 \u2502\r\n\u2502   3 \u2502 original1 \u2502 5 \u2502\r\n\u2502 3.5 \u2502 original1 \u2502 6 \u2502\r\n\u2502   4 \u2502 original4 \u2502 4 \u2502\r\n\u2502 4.5 \u2502 original4 \u2502 5 \u2502\r\n\u2502   5 \u2502 original4 \u2502 6 \u2502\r\n\u2502 5.5 \u2502 original4 \u2502 7 \u2502\r\n\u2502   7 \u2502 original7 \u2502 7 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\nAnd if you simplify before adding only one INTERPOLATE statement before FILL?\r\n\r\n```sql\r\nSELECT\r\n    n,\r\n    source,\r\n    x\r\nFROM\r\n(\r\n    SELECT\r\n        toFloat32(number % 10) AS n,\r\n        concat('original', toString(number)) AS source,\r\n        number AS x\r\n    FROM numbers(10)\r\n    WHERE (number % 3) = 1\r\n)\r\nORDER BY n ASC WITH INTERPOLATE FILL FROM 0 TO 5.51 STEP 0.5\r\n```\nI will take it.",
  "created_at": "2022-03-17T06:35:28Z"
}