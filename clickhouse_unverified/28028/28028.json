{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28028,
  "instance_id": "ClickHouse__ClickHouse-28028",
  "issue_numbers": [
    "26672"
  ],
  "base_commit": "4f7728053f6a03d012a4c19f1020e32d3affd75f",
  "patch": "diff --git a/src/DataTypes/DataTypeEnum.h b/src/DataTypes/DataTypeEnum.h\nindex 57657d1d1104..92c72b87afa6 100644\n--- a/src/DataTypes/DataTypeEnum.h\n+++ b/src/DataTypes/DataTypeEnum.h\n@@ -27,6 +27,8 @@ class IDataTypeEnum : public IDataType\n     bool isCategorial() const override { return true; }\n     bool canBeInsideNullable() const override { return true; }\n     bool isComparable() const override { return true; }\n+\n+    virtual bool contains(const IDataType & rhs) const = 0;\n };\n \n \n@@ -76,7 +78,7 @@ class DataTypeEnum final : public IDataTypeEnum, public EnumValues<Type>\n     /// Example:\n     /// Enum('a' = 1, 'b' = 2) -> Enum('c' = 1, 'b' = 2, 'd' = 3) OK\n     /// Enum('a' = 1, 'b' = 2) -> Enum('a' = 2, 'b' = 1) NOT OK\n-    bool contains(const IDataType & rhs) const;\n+    bool contains(const IDataType & rhs) const override;\n \n     SerializationPtr doGetDefaultSerialization() const override;\n };\ndiff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp\nindex 5183b9251412..a1325cb05698 100644\n--- a/src/Storages/StorageInMemoryMetadata.cpp\n+++ b/src/Storages/StorageInMemoryMetadata.cpp\n@@ -5,6 +5,7 @@\n #include <Common/quoteString.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <Core/ColumnWithTypeAndName.h>\n+#include <DataTypes/DataTypeEnum.h>\n #include <IO/ReadBufferFromString.h>\n #include <IO/ReadHelpers.h>\n #include <IO/Operators.h>\n@@ -493,6 +494,23 @@ namespace\n \n         return res;\n     }\n+\n+    /*\n+     * This function checks compatibility of enums. It returns true if:\n+     * 1. Both types are enums.\n+     * 2. The first type can represent all possible values of the second one.\n+     * 3. Both types require the same amount of memory.\n+     */\n+    bool isCompatibleEnumTypes(const IDataType * lhs, const IDataType * rhs)\n+    {\n+        if (IDataTypeEnum const * enum_type = dynamic_cast<IDataTypeEnum const *>(lhs))\n+        {\n+            if (!enum_type->contains(*rhs))\n+                return false;\n+            return enum_type->getMaximumSizeOfValueInMemory() == rhs->getMaximumSizeOfValueInMemory();\n+        }\n+        return false;\n+    }\n }\n \n void StorageInMemoryMetadata::check(const Names & column_names, const NamesAndTypesList & virtuals, const StorageID & storage_id) const\n@@ -544,12 +562,13 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns)\n                 column.name,\n                 listOfColumns(available_columns));\n \n-        if (!column.type->equals(*it->getMapped()))\n+        const auto * available_type = it->getMapped();\n+        if (!column.type->equals(*available_type) && !isCompatibleEnumTypes(available_type, column.type.get()))\n             throw Exception(\n                 ErrorCodes::TYPE_MISMATCH,\n                 \"Type mismatch for column {}. Column has type {}, got type {}\",\n                 column.name,\n-                it->getMapped()->getName(),\n+                available_type->getName(),\n                 column.type->getName());\n \n         if (unique_names.end() != unique_names.find(column.name))\n@@ -588,16 +607,16 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns,\n                 name,\n                 listOfColumns(available_columns));\n \n-        const auto & provided_column_type = *it->getMapped();\n-        const auto & available_column_type = *jt->getMapped();\n+        const auto * provided_column_type = it->getMapped();\n+        const auto * available_column_type = jt->getMapped();\n \n-        if (!provided_column_type.equals(available_column_type))\n+        if (!provided_column_type->equals(*available_column_type) && !isCompatibleEnumTypes(available_column_type, provided_column_type))\n             throw Exception(\n                 ErrorCodes::TYPE_MISMATCH,\n                 \"Type mismatch for column {}. Column has type {}, got type {}\",\n                 name,\n-                provided_column_type.getName(),\n-                available_column_type.getName());\n+                available_column_type->getName(),\n+                provided_column_type->getName());\n \n         if (unique_names.end() != unique_names.find(name))\n             throw Exception(ErrorCodes::COLUMN_QUERIED_MORE_THAN_ONCE,\n@@ -632,12 +651,13 @@ void StorageInMemoryMetadata::check(const Block & block, bool need_all) const\n                 column.name,\n                 listOfColumns(available_columns));\n \n-        if (!column.type->equals(*it->getMapped()))\n+        const auto * available_type = it->getMapped();\n+        if (!column.type->equals(*available_type) && !isCompatibleEnumTypes(available_type, column.type.get()))\n             throw Exception(\n                 ErrorCodes::TYPE_MISMATCH,\n                 \"Type mismatch for column {}. Column has type {}, got type {}\",\n                 column.name,\n-                it->getMapped()->getName(),\n+                available_type->getName(),\n                 column.type->getName());\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.reference b/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.reference\nnew file mode 100644\nindex 000000000000..abb96cefb59e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.reference\n@@ -0,0 +1,4 @@\n+one\n+one\n+two\n+two\ndiff --git a/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.sql b/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.sql\nnew file mode 100644\nindex 000000000000..9e25df0f41ac\n--- /dev/null\n+++ b/tests/queries/0_stateless/02012_changed_enum_type_non_replicated.sql\n@@ -0,0 +1,8 @@\n+create table enum_alter_issue (a Enum8('one' = 1, 'two' = 2)) engine = MergeTree() ORDER BY a;\n+insert into enum_alter_issue values ('one'), ('two');\n+alter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\n+insert into enum_alter_issue values ('one'), ('two');\n+alter table enum_alter_issue detach partition id 'all';\n+alter table enum_alter_issue attach partition id 'all';\n+select * from enum_alter_issue order by a;\n+drop table enum_alter_issue;\ndiff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.reference b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.reference\nnew file mode 100644\nindex 000000000000..a83c714a5cfc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.reference\n@@ -0,0 +1,4 @@\n+one\t1\n+two\t2\n+one\t3\n+two\t4\ndiff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.sql b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.sql\nnew file mode 100644\nindex 000000000000..0c95c7ff403b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type.sql\n@@ -0,0 +1,13 @@\n+create table enum_alter_issue (a Enum8('one' = 1, 'two' = 2), b Int)\n+engine = ReplicatedMergeTree('/clickhouse/tables/{database}/test_02012/enum_alter_issue', 'r1')\n+ORDER BY a;\n+\n+insert into enum_alter_issue values ('one', 1), ('two', 2);\n+alter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\n+insert into enum_alter_issue values ('one', 3), ('two', 4);\n+\n+alter table enum_alter_issue detach partition id 'all';\n+alter table enum_alter_issue attach partition id 'all';\n+select * from enum_alter_issue order by b;\n+\n+drop table enum_alter_issue;\ndiff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql\nnew file mode 100644\nindex 000000000000..e86023c96fa4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql\n@@ -0,0 +1,12 @@\n+drop table if exists enum_alter_issue;\n+create table enum_alter_issue (a Enum16('one' = 1, 'two' = 2), b Int)\n+engine = ReplicatedMergeTree('/clickhouse/tables/{database}/test_02012/enum_alter_issue', 'r2')\n+ORDER BY b;\n+\n+insert into enum_alter_issue values ('one', 1), ('two', 1);\n+alter table enum_alter_issue detach partition id 'all';\n+alter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\n+insert into enum_alter_issue values ('one', 1), ('two', 1);\n+\n+alter table enum_alter_issue attach partition id 'all'; -- {serverError TYPE_MISMATCH}\n+drop table enum_alter_issue;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex c2b5782e7660..385339101b5b 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -161,6 +161,9 @@\n         \"00980_zookeeper_merge_tree_alter_settings\",\n         \"00980_merge_alter_settings\",\n         \"02009_array_join_partition\",\n+        \"02012_changed_enum_type_non_replicated\",\n+        \"02012_zookeeper_changed_enum_type\",\n+        \"02012_zookeeper_changed_enum_type_incompatible\",\n         /// Old syntax is not allowed\n         \"01062_alter_on_mutataion_zookeeper\",\n         \"00925_zookeeper_empty_replicated_merge_tree_optimize_final\",\n",
  "problem_statement": "attaching parts with 'compatible' enum types\nGot something like that in practice with backup recovery - IRL most probably the sequence of events leading to that discrepancy was different (not clear yet).\r\n\r\n```sql\r\ndrop table enum_alter_issue;\r\ncreate table enum_alter_issue (a Enum8('one' = 1, 'two' = 2)) engine = ReplicatedMergeTree('/clickhouse/tables/enum_alter_issue', 'test') ORDER BY a;\r\n\r\n-- backup / move part aside or similar operation \r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue detach partition id 'all';\r\n\r\n-- schema evolution (enum get extended)\r\nalter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue detach partition id 'all';\r\n\r\n-- attempt to attach back all the parts (new generation and old generation)\r\nalter table enum_alter_issue attach partition id 'all';\r\n\r\nReceived exception from server (version 21.9.1):\r\nCode: 53. DB::Exception: Received from localhost:9000. DB::Exception: Type mismatch for column a. Column has type Enum8('one' = 1, 'two' = 2, 'three' = 3), got type Enum8('one' = 1, 'two' = 2). \r\n```\n",
  "hints_text": "hm, this issue is only with Replicated\r\n\r\n```sql\r\ncreate table enum_alter_issue (a Enum8('one' = 1, 'two' = 2)) engine = MergeTree() ORDER BY a;\r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue detach partition id 'all';\r\nalter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue detach partition id 'all';\r\nalter table enum_alter_issue attach partition id 'all';\r\nselect * from enum_alter_issue;\r\n\u250c\u2500a\u2500\u2500\u2500\u2510\r\n\u2502 one \u2502\r\n\u2502 two \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500a\u2500\u2500\u2500\u2510\r\n\u2502 one \u2502\r\n\u2502 two \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAnd it reproduces without the first detach, it's not about \"backup\"\r\n\r\n```sql\r\ndrop table enum_alter_issue;\r\ncreate table enum_alter_issue (a Enum8('one' = 1, 'two' = 2)) engine = ReplicatedMergeTree('/clickhouse/tables/enum_alter_issue', 'test') ORDER BY a;\r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\r\ninsert into enum_alter_issue values ('one'), ('two');\r\nalter table enum_alter_issue detach partition id 'all';\r\nalter table enum_alter_issue attach partition id 'all';\r\nDB::Exception: Type mismatch for column a\r\n```",
  "created_at": "2021-08-23T13:24:26Z"
}