diff --git a/src/DataTypes/DataTypeEnum.h b/src/DataTypes/DataTypeEnum.h
index 57657d1d1104..92c72b87afa6 100644
--- a/src/DataTypes/DataTypeEnum.h
+++ b/src/DataTypes/DataTypeEnum.h
@@ -27,6 +27,8 @@ class IDataTypeEnum : public IDataType
     bool isCategorial() const override { return true; }
     bool canBeInsideNullable() const override { return true; }
     bool isComparable() const override { return true; }
+
+    virtual bool contains(const IDataType & rhs) const = 0;
 };
 
 
@@ -76,7 +78,7 @@ class DataTypeEnum final : public IDataTypeEnum, public EnumValues<Type>
     /// Example:
     /// Enum('a' = 1, 'b' = 2) -> Enum('c' = 1, 'b' = 2, 'd' = 3) OK
     /// Enum('a' = 1, 'b' = 2) -> Enum('a' = 2, 'b' = 1) NOT OK
-    bool contains(const IDataType & rhs) const;
+    bool contains(const IDataType & rhs) const override;
 
     SerializationPtr doGetDefaultSerialization() const override;
 };
diff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp
index 5183b9251412..a1325cb05698 100644
--- a/src/Storages/StorageInMemoryMetadata.cpp
+++ b/src/Storages/StorageInMemoryMetadata.cpp
@@ -5,6 +5,7 @@
 #include <Common/quoteString.h>
 #include <Common/StringUtils/StringUtils.h>
 #include <Core/ColumnWithTypeAndName.h>
+#include <DataTypes/DataTypeEnum.h>
 #include <IO/ReadBufferFromString.h>
 #include <IO/ReadHelpers.h>
 #include <IO/Operators.h>
@@ -493,6 +494,23 @@ namespace
 
         return res;
     }
+
+    /*
+     * This function checks compatibility of enums. It returns true if:
+     * 1. Both types are enums.
+     * 2. The first type can represent all possible values of the second one.
+     * 3. Both types require the same amount of memory.
+     */
+    bool isCompatibleEnumTypes(const IDataType * lhs, const IDataType * rhs)
+    {
+        if (IDataTypeEnum const * enum_type = dynamic_cast<IDataTypeEnum const *>(lhs))
+        {
+            if (!enum_type->contains(*rhs))
+                return false;
+            return enum_type->getMaximumSizeOfValueInMemory() == rhs->getMaximumSizeOfValueInMemory();
+        }
+        return false;
+    }
 }
 
 void StorageInMemoryMetadata::check(const Names & column_names, const NamesAndTypesList & virtuals, const StorageID & storage_id) const
@@ -544,12 +562,13 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns)
                 column.name,
                 listOfColumns(available_columns));
 
-        if (!column.type->equals(*it->getMapped()))
+        const auto * available_type = it->getMapped();
+        if (!column.type->equals(*available_type) && !isCompatibleEnumTypes(available_type, column.type.get()))
             throw Exception(
                 ErrorCodes::TYPE_MISMATCH,
                 "Type mismatch for column {}. Column has type {}, got type {}",
                 column.name,
-                it->getMapped()->getName(),
+                available_type->getName(),
                 column.type->getName());
 
         if (unique_names.end() != unique_names.find(column.name))
@@ -588,16 +607,16 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns,
                 name,
                 listOfColumns(available_columns));
 
-        const auto & provided_column_type = *it->getMapped();
-        const auto & available_column_type = *jt->getMapped();
+        const auto * provided_column_type = it->getMapped();
+        const auto * available_column_type = jt->getMapped();
 
-        if (!provided_column_type.equals(available_column_type))
+        if (!provided_column_type->equals(*available_column_type) && !isCompatibleEnumTypes(available_column_type, provided_column_type))
             throw Exception(
                 ErrorCodes::TYPE_MISMATCH,
                 "Type mismatch for column {}. Column has type {}, got type {}",
                 name,
-                provided_column_type.getName(),
-                available_column_type.getName());
+                available_column_type->getName(),
+                provided_column_type->getName());
 
         if (unique_names.end() != unique_names.find(name))
             throw Exception(ErrorCodes::COLUMN_QUERIED_MORE_THAN_ONCE,
@@ -632,12 +651,13 @@ void StorageInMemoryMetadata::check(const Block & block, bool need_all) const
                 column.name,
                 listOfColumns(available_columns));
 
-        if (!column.type->equals(*it->getMapped()))
+        const auto * available_type = it->getMapped();
+        if (!column.type->equals(*available_type) && !isCompatibleEnumTypes(available_type, column.type.get()))
             throw Exception(
                 ErrorCodes::TYPE_MISMATCH,
                 "Type mismatch for column {}. Column has type {}, got type {}",
                 column.name,
-                it->getMapped()->getName(),
+                available_type->getName(),
                 column.type->getName());
     }
 
