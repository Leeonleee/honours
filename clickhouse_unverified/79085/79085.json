{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79085,
  "instance_id": "ClickHouse__ClickHouse-79085",
  "issue_numbers": [
    "65023"
  ],
  "base_commit": "64fab303a5edc8a876e6894844d6459045037ee1",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex 1ddd05809b2f..31687dbdf625 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -405,12 +405,19 @@ void LocalServer::cleanup()\n }\n \n \n-std::string LocalServer::getInitialCreateTableQuery()\n+std::pair<std::string, std::string> LocalServer::getInitialCreateTableQuery()\n {\n-    if (!getClientConfiguration().has(\"table-structure\") && !getClientConfiguration().has(\"table-file\") && !getClientConfiguration().has(\"table-data-format\") && (!isRegularFile(STDIN_FILENO) || queries.empty()))\n+    /// The input data can be specified explicitly with any of the `file`, `structure`, `input-format` command line arguments,\n+    /// or it can be implicitly specified in stdin - then the structure and format is autodetected.\n+    /// But if queries were not specified in the command line, they might me in stdin, and this means that stdin is not input data.\n+\n+    if (!getClientConfiguration().has(\"table-structure\")\n+        && !getClientConfiguration().has(\"table-file\")\n+        && !getClientConfiguration().has(\"table-data-format\")\n+        && (queries.empty() || !isFileDescriptorSuitableForInput(stdin_fd))) /// In we know that there is data in stdin, we can auto-detect the format.\n         return {};\n \n-    auto table_name = backQuoteIfNeed(getClientConfiguration().getString(\"table-name\", \"table\"));\n+    auto table_name = getClientConfiguration().getString(\"table-name\", \"table\");\n     auto table_structure = getClientConfiguration().getString(\"table-structure\", \"auto\");\n \n     String table_file;\n@@ -429,15 +436,24 @@ std::string LocalServer::getInitialCreateTableQuery()\n         table_file = quoteString(file_name);\n     }\n \n-    String data_format = backQuoteIfNeed(default_input_format);\n+    String data_format;\n+\n+    if (default_input_format == \"auto\" && getClientConfiguration().has(\"table-structure\"))\n+        data_format = \"TabSeparated\";   /// Compatibility with older versions when format inference was not available.\n+    else\n+        data_format = backQuoteIfNeed(default_input_format);\n \n     if (table_structure == \"auto\")\n         table_structure = \"\";\n     else\n         table_structure = \"(\" + table_structure + \")\";\n \n-    return fmt::format(\"CREATE TEMPORARY TABLE {} {} ENGINE = File({}, {}, {});\",\n-                       table_name, table_structure, data_format, table_file, compression);\n+    return\n+    {\n+        table_name,\n+        fmt::format(\"CREATE TEMPORARY TABLE {} {} ENGINE = File({}, {}, {});\",\n+            backQuote(table_name), table_structure, data_format, table_file, compression)\n+    };\n }\n \n \n@@ -613,10 +629,13 @@ try\n         std::cerr << std::endl;\n     }\n \n+    auto [table_name, initial_query] = getInitialCreateTableQuery();\n+    if (!table_name.empty())\n+        client_context->setSetting(\"implicit_table_at_top_level\", table_name);\n+\n     connect();\n \n-    String initial_query = getInitialCreateTableQuery();\n-    if (!initial_query.empty())\n+    if (!table_name.empty())\n         processQueryText(initial_query);\n \n #if USE_FUZZING_MODE\n@@ -855,7 +874,7 @@ void LocalServer::processConfig()\n #endif\n \n     /// NOTE: it is important to apply any overrides before\n-    /// setDefaultProfiles() calls since it will copy current context (i.e.\n+    /// `setDefaultProfiles` calls since it will copy current context (i.e.\n     /// there is separate context for Buffer tables).\n     adjustSettings();\n     applySettingsOverridesForLocal(global_context);\ndiff --git a/programs/local/LocalServer.h b/programs/local/LocalServer.h\nindex 5c070c8d3ee0..747ece68d41b 100644\n--- a/programs/local/LocalServer.h\n+++ b/programs/local/LocalServer.h\n@@ -53,9 +53,10 @@ class LocalServer : public ClientApplicationBase, public Loggers\n private:\n     /** Composes CREATE subquery based on passed arguments (--structure --file --table and --input-format)\n       * This query will be executed first, before queries passed through --query argument\n-      * Returns empty string if it cannot compose that query.\n+      * Returns a pair of the table name and the corresponding create table statement.\n+      * Returns empty strings if it cannot compose that query.\n       */\n-    std::string getInitialCreateTableQuery();\n+    std::pair<std::string, std::string> getInitialCreateTableQuery();\n \n     void tryInitPath();\n     void setupUsers();\ndiff --git a/src/Analyzer/QueryTreeBuilder.cpp b/src/Analyzer/QueryTreeBuilder.cpp\nindex c12c076c045f..679774de81c7 100644\n--- a/src/Analyzer/QueryTreeBuilder.cpp\n+++ b/src/Analyzer/QueryTreeBuilder.cpp\n@@ -4,7 +4,6 @@\n #include <Common/quoteString.h>\n \n #include <DataTypes/FieldToDataType.h>\n-#include <Parsers/ParserSelectWithUnionQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n #include <Parsers/ASTExpressionList.h>\n@@ -47,12 +46,12 @@\n \n #include <Databases/IDatabase.h>\n \n-#include <Interpreters/StorageID.h>\n #include <Interpreters/Context.h>\n \n \n namespace DB\n {\n+\n namespace Setting\n {\n     extern const SettingsBool allow_experimental_variant_type;\n@@ -62,6 +61,7 @@ namespace Setting\n     extern const SettingsUInt64 limit;\n     extern const SettingsUInt64 offset;\n     extern const SettingsBool use_variant_as_common_type;\n+    extern const SettingsString implicit_table_at_top_level;\n }\n \n \n@@ -123,7 +123,7 @@ class QueryTreeBuilder\n \n     QueryTreeNodePtr buildWindow(const ASTPtr & window_definition, const ContextPtr & context) const;\n \n-    QueryTreeNodePtr buildJoinTree(const ASTSelectQuery & select_query, const ContextPtr & context) const;\n+    QueryTreeNodePtr buildJoinTree(bool is_subquery, const ASTSelectQuery & select_query, const ContextPtr & context) const;\n \n     ColumnTransformersNodes buildColumnTransformers(const ASTPtr & matcher_expression, const ContextPtr & context) const;\n \n@@ -239,7 +239,8 @@ QueryTreeNodePtr QueryTreeBuilder::buildSelectIntersectExceptQuery(const ASTPtr\n     return union_node;\n }\n \n-QueryTreeNodePtr QueryTreeBuilder::buildSelectExpression(const ASTPtr & select_query,\n+QueryTreeNodePtr QueryTreeBuilder::buildSelectExpression(\n+    const ASTPtr & select_query,\n     bool is_subquery,\n     const std::string & cte_name,\n     const ASTPtr & aliases,\n@@ -313,7 +314,7 @@ QueryTreeNodePtr QueryTreeBuilder::buildSelectExpression(const ASTPtr & select_q\n \n     auto current_context = current_query_tree->getContext();\n \n-    current_query_tree->getJoinTree() = buildJoinTree(select_query_typed, current_context);\n+    current_query_tree->getJoinTree() = buildJoinTree(is_subquery, select_query_typed, current_context);\n \n     auto select_with_list = select_query_typed.with();\n     if (select_with_list)\n@@ -853,16 +854,23 @@ std::shared_ptr<TableFunctionNode> QueryTreeBuilder::buildTableFunction(const AS\n     return node;\n }\n \n-QueryTreeNodePtr QueryTreeBuilder::buildJoinTree(const ASTSelectQuery & select_query, const ContextPtr & context) const\n+QueryTreeNodePtr QueryTreeBuilder::buildJoinTree(bool is_subquery, const ASTSelectQuery & select_query, const ContextPtr & context) const\n {\n     const auto & tables_in_select_query = select_query.tables();\n     if (!tables_in_select_query)\n     {\n-        /** If no table is specified in SELECT query we substitute system.one table.\n-          * SELECT * FROM system.one;\n+        /** If no table is specified in SELECT query,\n+          * if 'implicit_table_at_top_level' is set, we substitute it as a table,\n+          * otherwise, we substitute the system.one table: SELECT * FROM system.one;\n           */\n-        Identifier storage_identifier(\"system.one\");\n-        return std::make_shared<IdentifierNode>(storage_identifier);\n+        if (!is_subquery)\n+        {\n+            String implicit_table = context->getSettingsRef()[Setting::implicit_table_at_top_level];\n+            if (!implicit_table.empty())\n+                return std::make_shared<IdentifierNode>(Identifier(implicit_table));\n+        }\n+\n+        return std::make_shared<IdentifierNode>(Identifier(\"system.one\"));\n     }\n \n     auto & tables = tables_in_select_query->as<ASTTablesInSelectQuery &>();\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 68d0acfacec9..2712129b1c92 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -113,6 +113,7 @@ namespace Setting\n     extern const SettingsBool allow_suspicious_types_in_order_by;\n     extern const SettingsBool allow_not_comparable_types_in_order_by;\n     extern const SettingsBool use_concurrency_control;\n+    extern const SettingsString implicit_table_at_top_level;\n }\n \n \n@@ -581,6 +582,7 @@ void QueryAnalyzer::evaluateScalarSubqueryIfNeeded(QueryTreeNodePtr & node, Iden\n         Settings subquery_settings = context->getSettingsCopy();\n         subquery_settings[Setting::max_result_rows] = 1;\n         subquery_settings[Setting::extremes] = false;\n+        subquery_settings[Setting::implicit_table_at_top_level] = \"\";\n         /// When execute `INSERT INTO t WITH ... SELECT ...`, it may lead to `Unknown columns`\n         /// exception with this settings enabled(https://github.com/ClickHouse/ClickHouse/issues/52494).\n         subquery_settings[Setting::use_structure_from_insertion_table_in_table_functions] = false;\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex e051910c6631..8e32adc9546f 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -877,10 +877,11 @@ void ClientBase::initClientContext()\n     client_context->setQueryParameters(query_parameters);\n }\n \n-bool ClientBase::isRegularFile(int fd)\n+bool ClientBase::isFileDescriptorSuitableForInput(int fd)\n {\n     struct stat file_stat;\n-    return fstat(fd, &file_stat) == 0 && S_ISREG(file_stat.st_mode);\n+    return fstat(fd, &file_stat) == 0\n+        && (S_ISREG(file_stat.st_mode) || S_ISLNK(file_stat.st_mode));\n }\n \n void ClientBase::setDefaultFormatsAndCompressionFromConfiguration()\n@@ -900,7 +901,7 @@ void ClientBase::setDefaultFormatsAndCompressionFromConfiguration()\n         default_output_format = \"Vertical\";\n         is_default_format = false;\n     }\n-    else if (isRegularFile(stdout_fd))\n+    else if (isFileDescriptorSuitableForInput(stdout_fd))\n     {\n         std::optional<String> format_from_file_name = FormatFactory::instance().tryGetFormatFromFileDescriptor(stdout_fd);\n         if (format_from_file_name)\n@@ -936,7 +937,7 @@ void ClientBase::setDefaultFormatsAndCompressionFromConfiguration()\n         if (format_from_file_name)\n             default_input_format = *format_from_file_name;\n         else\n-            default_input_format = \"TSV\";\n+            default_input_format = \"auto\";\n     }\n     else\n     {\n@@ -944,7 +945,7 @@ void ClientBase::setDefaultFormatsAndCompressionFromConfiguration()\n         if (format_from_file_name)\n             default_input_format = *format_from_file_name;\n         else\n-            default_input_format = \"TSV\";\n+            default_input_format = \"auto\";\n \n         std::optional<String> file_name = tryGetFileNameFromFileDescriptor(stdin_fd);\n         if (file_name)\ndiff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h\nindex 0144cbedc90e..473ad8add9dd 100644\n--- a/src/Client/ClientBase.h\n+++ b/src/Client/ClientBase.h\n@@ -265,7 +265,7 @@ class ClientBase\n     static bool isSyncInsertWithData(const ASTInsertQuery & insert_query, const ContextPtr & context);\n     bool processMultiQueryFromFile(const String & file_name);\n \n-    static bool isRegularFile(int fd);\n+    static bool isFileDescriptorSuitableForInput(int fd);\n \n     /// Adjust some settings after command line options and config had been processed.\n     void adjustSettings();\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex 60192a897d36..86e7289bdc14 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -6401,6 +6401,19 @@ Enable pushing user roles from originator to other nodes while performing a quer\n )\", 0) \\\n     DECLARE(Bool, shared_merge_tree_sync_parts_on_partition_operations, true, R\"(\n Automatically synchronize set of data parts after MOVE|REPLACE|ATTACH partition operations in SMT tables. Cloud only\n+)\", 0) \\\n+    DECLARE(String, implicit_table_at_top_level, \"\", R\"(\n+If not empty, queries without FROM at the top level will read from this table instead of system.one.\n+\n+This is used in clickhouse-local for input data processing.\n+The setting could be set explicitly by a user but is not intended for this type of usage.\n+\n+Subqueries are not affected by this setting (neither scalar, FROM, or IN subqueries).\n+SELECTs at the top level of UNION, INTERSECT, EXCEPT chains are treated uniformly and affected by this setting, regardless of their grouping in parentheses.\n+It is unspecified how this setting affects views and distributed queries.\n+\n+The setting accepts a table name (then the table is resolved from the current database) or a qualified name in the form of 'database.table'.\n+Both database and table names have to be unquoted - only simple identifiers are allowed.\n )\", 0) \\\n     \\\n     DECLARE(Bool, allow_experimental_variant_type, true, R\"(\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 01b4bf59232a..8b145afc11f4 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -69,6 +69,7 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n         addSettingsChanges(settings_changes_history, \"25.5\",\n         {\n             {\"secondary_indices_enable_bulk_filtering\", false, true, \"A new algorithm for filtering by data skipping indices\"},\n+            {\"implicit_table_at_top_level\", \"\", \"\", \"A new setting, used in clickhouse-local\"},\n         });\n         addSettingsChanges(settings_changes_history, \"25.4\",\n         {\ndiff --git a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\nindex 32d941c5f961..26261d9b290b 100644\n--- a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\n+++ b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\n@@ -5,14 +5,12 @@\n #include <Core/Settings.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeTuple.h>\n-#include <IO/WriteBufferFromString.h>\n #include <IO/WriteHelpers.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n #include <Interpreters/ProcessorsProfileLog.h>\n #include <Interpreters/addTypeConversionToAST.h>\n #include <Interpreters/misc.h>\n-#include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSelectQuery.h>\n@@ -38,6 +36,7 @@ namespace Setting\n     extern const SettingsBool extremes;\n     extern const SettingsUInt64 max_result_rows;\n     extern const SettingsBool use_concurrency_control;\n+    extern const SettingsString implicit_table_at_top_level;\n }\n \n namespace ErrorCodes\n@@ -96,6 +95,7 @@ static auto getQueryInterpreter(const ASTSubquery & subquery, ExecuteScalarSubqu\n     Settings subquery_settings = data.getContext()->getSettingsCopy();\n     subquery_settings[Setting::max_result_rows] = 1;\n     subquery_settings[Setting::extremes] = false;\n+    subquery_settings[Setting::implicit_table_at_top_level] = \"\";\n     subquery_context->setSettings(subquery_settings);\n \n     if (subquery_context->hasQueryContext())\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 12713604f8be..7f15995fa7ec 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -193,6 +193,7 @@ namespace Setting\n     extern const SettingsUInt64 max_bytes_to_transfer;\n     extern const SettingsUInt64 max_rows_to_transfer;\n     extern const SettingsOverflowMode transfer_overflow_mode;\n+    extern const SettingsString implicit_table_at_top_level;\n }\n \n namespace ServerSetting\n@@ -355,6 +356,7 @@ ContextPtr getSubqueryContext(const ContextPtr & context)\n     Settings subquery_settings = context->getSettingsCopy();\n     subquery_settings[Setting::max_result_rows] = 0;\n     subquery_settings[Setting::max_result_bytes] = 0;\n+    subquery_settings[Setting::implicit_table_at_top_level] = \"\";\n     /// The calculation of extremes does not make sense and is not necessary (if you do it, then the extremes of the subquery can be taken for whole query).\n     subquery_settings[Setting::extremes] = false;\n     subquery_context->setSettings(subquery_settings);\ndiff --git a/src/Interpreters/interpretSubquery.cpp b/src/Interpreters/interpretSubquery.cpp\nindex a6c3c0902476..b8f3a9e0a0dd 100644\n--- a/src/Interpreters/interpretSubquery.cpp\n+++ b/src/Interpreters/interpretSubquery.cpp\n@@ -1,6 +1,5 @@\n #include <Common/typeid_cast.h>\n #include <Core/Settings.h>\n-#include <IO/WriteHelpers.h>\n \n #include <Storages/IStorage.h>\n \n@@ -23,6 +22,7 @@ namespace Setting\n     extern const SettingsBool extremes;\n     extern const SettingsUInt64 max_result_bytes;\n     extern const SettingsUInt64 max_result_rows;\n+    extern const SettingsString implicit_table_at_top_level;\n }\n \n namespace ErrorCodes\n@@ -74,6 +74,7 @@ std::shared_ptr<InterpreterSelectWithUnionQuery> interpretSubquery(\n     subquery_settings[Setting::max_result_bytes] = 0;\n     /// The calculation of `extremes` does not make sense and is not necessary (if you do it, then the `extremes` of the subquery can be taken instead of the whole query).\n     subquery_settings[Setting::extremes] = false;\n+    subquery_settings[Setting::implicit_table_at_top_level] = \"\";\n     subquery_context->setSettings(subquery_settings);\n \n     auto subquery_options = options.subquery();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01500_StorageFile_write_to_fd.sh b/tests/queries/0_stateless/01500_StorageFile_write_to_fd.sh\nindex 1d66f374a204..d4bb7d468bd4 100755\n--- a/tests/queries/0_stateless/01500_StorageFile_write_to_fd.sh\n+++ b/tests/queries/0_stateless/01500_StorageFile_write_to_fd.sh\n@@ -5,7 +5,7 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n . \"$CURDIR\"/../shell_config.sh\n \n # The following command will execute:\n-#     CREATE TABLE table (key UInt32) ENGINE = File(TSV, stdin);\n+#     CREATE TEMPORARY TABLE table (key UInt32) ENGINE = File(TSV, stdin);\n #     INSERT INTO `table` SELECT key FROM input('key UInt32') FORMAT TSV\n-${CLICKHOUSE_LOCAL} -S 'key UInt32' -q \"INSERT INTO \\`table\\` SELECT key FROM input('key UInt32') FORMAT TSV\" < /dev/null 2>&1 \\\n+${CLICKHOUSE_LOCAL} -S 'key UInt32' -q \"INSERT INTO \\`table\\` SELECT key FROM input('key UInt32') FORMAT TSV\" --input-format TSV < /dev/null 2>&1 \\\n     | grep -q \"No data to insert\" || echo \"Fail\"\ndiff --git a/tests/queries/0_stateless/03408_implicit_table.reference b/tests/queries/0_stateless/03408_implicit_table.reference\nnew file mode 100644\nindex 000000000000..8ae9641531e2\n--- /dev/null\n+++ b/tests/queries/0_stateless/03408_implicit_table.reference\n@@ -0,0 +1,27 @@\n+-- { echo }\n+SET implicit_select = 1, implicit_table_at_top_level = 'test', enable_analyzer = 1;\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (s String) ENGINE = Memory;\n+INSERT INTO test VALUES ('Hello'), ('World');\n+s;\n+Hello\n+World\n+count();\n+2\n+1;\n+1\n+1\n+*;\n+Hello\n+World\n+SELECT *, (SELECT 1);\n+Hello\t1\n+World\t1\n+SELECT * FROM (SELECT *);\n+0\n+SELECT * UNION ALL SELECT *;\n+Hello\n+World\n+Hello\n+World\n+DROP TABLE test;\ndiff --git a/tests/queries/0_stateless/03408_implicit_table.sql b/tests/queries/0_stateless/03408_implicit_table.sql\nnew file mode 100644\nindex 000000000000..58e292ed3415\n--- /dev/null\n+++ b/tests/queries/0_stateless/03408_implicit_table.sql\n@@ -0,0 +1,15 @@\n+-- { echo }\n+SET implicit_select = 1, implicit_table_at_top_level = 'test', enable_analyzer = 1;\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (s String) ENGINE = Memory;\n+INSERT INTO test VALUES ('Hello'), ('World');\n+\n+s;\n+count();\n+1;\n+*;\n+SELECT *, (SELECT 1);\n+SELECT * FROM (SELECT *);\n+SELECT * UNION ALL SELECT *;\n+\n+DROP TABLE test;\ndiff --git a/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.reference b/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.reference\nnew file mode 100644\nindex 000000000000..d4a828faccee\n--- /dev/null\n+++ b/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.reference\n@@ -0,0 +1,1 @@\n+123\ttest\ndiff --git a/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.sh b/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.sh\nnew file mode 100755\nindex 000000000000..3c98f3f13f4f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03409_implicit_table_clickhouse_local.sh\n@@ -0,0 +1,7 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+echo '{\"Hello\": {\"world\": 123}, \"goodbye\": \"test\"}' | ${CLICKHOUSE_LOCAL} -q \"Hello.world, goodbye\" --input-format JSONEachRow\n",
  "problem_statement": "`clickhouse-local`: if there is input, use it as a default table in SELECT instead of system.one\nAllow to write\r\n\r\n```\r\nclickhouse-local --query \"SELECT *\" < data.csv\r\n```\r\n\r\ninstead of\r\n\r\n```\r\nclickhouse-local --query \"SELECT * FROM table\" < data.csv\r\n```\r\n\n",
  "hints_text": "Hi @alexey-milovidov! I would like to work on this task if it's possible\nOk, but this task isn't easy. I have already considered three different ways to implement it, with various logical consequences. It is marked as \"warmup task\".\nHi, it would be very useful to hear your opinion on possible implementations \r\n\r\nI also wanted to ask if it is possible to take this task in tandem with @m4xxx1m? We both ready to dive into \r\n\r\ncc: @alexey-milovidov \nYes, it's good to implement it together!\r\nI'm going to write down my thoughts in a week.\nping @alexey-milovidov \n@m7kss1 \n\nLet's consider the requirements for this feature with examples.\n\n1. `SELECT a`\n\nIn this example, the user selects a column `a`. We have to substitute the default table.\nWithout a new feature, it will return an error.\n\n2. `SELECT count()`\n\nIn this example, the user didn't reference any columns from the table, but the intent is to count all records in the input. This means we should substitute the table.\n\n3. `SELECT 1`\n\nIn this example, the user intent is unclear, but to make the implementation consistent with the previous example, we should substitute the table in this case. It will produce as many records containing `1` as the number of rows in the table.\n\n4. `SELECT *`\n\nThe user didn't reference any columns explicitly. However, the intent is to return everything from the input, so the table has to be substituted.\n\n5. `SELECT (SELECT 1)`\n\nThis example is problematic. If we make the subquery behave in the same way as in the previous items, it is no longer a scalar subquery, and the error will be produced.\n\n6. `SELECT * FROM (SELECT *)`\n\nIt is a subquery, but the user wants it to behave similarly to example 3.\n\n7. `SELECT * UNION ALL SELECT *`\n\nHere we have a chain of UNION, and the user wants to read from the input data twice.\nI see the following way of implementation:\n\nAllow substitution only for the top level of the query.\nThis prevents item 6 from working as expected. But it's ok to require explicit specification of tables in all subqueries. However, UNION, EXCEPT, and INTERSECT will work.\n\nIt works regardless of specified columns, which means, the table is substituted even for `SELECT 1` and `SELECT *`\n\nIt is implemented with a new setting, `default_table_at_top_query_level`, which means it can work not only in `clickhouse-local`, but in `clickhouse-server` as well. But it will be used automatically in `clickhouse-local` (enabled if there is an input and a command line parameter does not disable it).",
  "created_at": "2025-04-13T03:31:45Z"
}