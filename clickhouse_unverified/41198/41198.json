{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41198,
  "instance_id": "ClickHouse__ClickHouse-41198",
  "issue_numbers": [
    "38411"
  ],
  "base_commit": "2d2413fb7bc52e0dbcd1c387e3cdfe4b349feb77",
  "patch": "diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex d1f1df24398f..3d447d6bbb8f 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -82,13 +82,17 @@\n #if USE_BORINGSSL\n #include <Compression/CompressionCodecEncrypted.h>\n #endif\n+#include <Server/HTTP/HTTPServerConnectionFactory.h>\n #include <Server/MySQLHandlerFactory.h>\n #include <Server/PostgreSQLHandlerFactory.h>\n+#include <Server/ProxyV1HandlerFactory.h>\n+#include <Server/TLSHandlerFactory.h>\n #include <Server/CertificateReloader.h>\n #include <Server/ProtocolServerAdapter.h>\n #include <Server/HTTP/HTTPServer.h>\n #include <Interpreters/AsynchronousInsertQueue.h>\n #include <filesystem>\n+#include <unordered_set>\n \n #include \"config.h\"\n #include \"config_version.h\"\n@@ -387,7 +391,16 @@ bool getListenTry(const Poco::Util::AbstractConfiguration & config)\n {\n     bool listen_try = config.getBool(\"listen_try\", false);\n     if (!listen_try)\n-        listen_try = DB::getMultipleValuesFromConfig(config, \"\", \"listen_host\").empty();\n+    {\n+        Poco::Util::AbstractConfiguration::Keys protocols;\n+        config.keys(\"protocols\", protocols);\n+        listen_try =\n+            DB::getMultipleValuesFromConfig(config, \"\", \"listen_host\").empty() &&\n+            std::none_of(protocols.begin(), protocols.end(), [&](const auto & protocol)\n+            {\n+                return config.has(\"protocols.\" + protocol + \".host\") && config.has(\"protocols.\" + protocol + \".port\");\n+            });\n+    }\n     return listen_try;\n }\n \n@@ -1853,6 +1866,82 @@ int Server::main(const std::vector<std::string> & /*args*/)\n     return Application::EXIT_OK;\n }\n \n+std::unique_ptr<TCPProtocolStackFactory> Server::buildProtocolStackFromConfig(\n+    const Poco::Util::AbstractConfiguration & config,\n+    const std::string & protocol,\n+    Poco::Net::HTTPServerParams::Ptr http_params,\n+    AsynchronousMetrics & async_metrics,\n+    bool & is_secure)\n+{\n+    auto create_factory = [&](const std::string & type, const std::string & conf_name) -> TCPServerConnectionFactory::Ptr\n+    {\n+        if (type == \"tcp\")\n+            return TCPServerConnectionFactory::Ptr(new TCPHandlerFactory(*this, false, false));\n+\n+        if (type == \"tls\")\n+#if USE_SSL\n+            return TCPServerConnectionFactory::Ptr(new TLSHandlerFactory(*this, conf_name));\n+#else\n+            throw Exception{\"SSL support for TCP protocol is disabled because Poco library was built without NetSSL support.\",\n+                            ErrorCodes::SUPPORT_IS_DISABLED};\n+#endif\n+\n+        if (type == \"proxy1\")\n+            return TCPServerConnectionFactory::Ptr(new ProxyV1HandlerFactory(*this, conf_name));\n+        if (type == \"mysql\")\n+            return TCPServerConnectionFactory::Ptr(new MySQLHandlerFactory(*this));\n+        if (type == \"postgres\")\n+            return TCPServerConnectionFactory::Ptr(new PostgreSQLHandlerFactory(*this));\n+        if (type == \"http\")\n+            return TCPServerConnectionFactory::Ptr(\n+                new HTTPServerConnectionFactory(context(), http_params, createHandlerFactory(*this, config, async_metrics, \"HTTPHandler-factory\"))\n+            );\n+        if (type == \"prometheus\")\n+            return TCPServerConnectionFactory::Ptr(\n+                new HTTPServerConnectionFactory(context(), http_params, createHandlerFactory(*this, config, async_metrics, \"PrometheusHandler-factory\"))\n+            );\n+        if (type == \"interserver\")\n+            return TCPServerConnectionFactory::Ptr(\n+                new HTTPServerConnectionFactory(context(), http_params, createHandlerFactory(*this, config, async_metrics, \"InterserverIOHTTPHandler-factory\"))\n+            );\n+\n+        throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol configuration error, unknown protocol name '{}'\", type);\n+    };\n+\n+    std::string conf_name = \"protocols.\" + protocol;\n+    std::string prefix = conf_name + \".\";\n+    std::unordered_set<std::string> pset {conf_name};\n+\n+    auto stack = std::make_unique<TCPProtocolStackFactory>(*this, conf_name);\n+\n+    while (true)\n+    {\n+        // if there is no \"type\" - it's a reference to another protocol and this is just an endpoint\n+        if (config.has(prefix + \"type\"))\n+        {\n+            std::string type = config.getString(prefix + \"type\");\n+            if (type == \"tls\")\n+            {\n+                if (is_secure)\n+                    throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol '{}' contains more than one TLS layer\", protocol);\n+                is_secure = true;\n+            }\n+\n+            stack->append(create_factory(type, conf_name));\n+        }\n+\n+        if (!config.has(prefix + \"impl\"))\n+            break;\n+\n+        conf_name = \"protocols.\" + config.getString(prefix + \"impl\");\n+        prefix = conf_name + \".\";\n+\n+        if (!pset.insert(conf_name).second)\n+            throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol '{}' configuration contains a loop on '{}'\", protocol, conf_name);\n+    }\n+\n+    return stack;\n+}\n \n void Server::createServers(\n     Poco::Util::AbstractConfiguration & config,\n@@ -1871,6 +1960,55 @@ void Server::createServers(\n     http_params->setTimeout(settings.http_receive_timeout);\n     http_params->setKeepAliveTimeout(keep_alive_timeout);\n \n+    Poco::Util::AbstractConfiguration::Keys protocols;\n+    config.keys(\"protocols\", protocols);\n+\n+    for (const auto & protocol : protocols)\n+    {\n+        std::vector<std::string> hosts;\n+        if (config.has(\"protocols.\" + protocol + \".host\"))\n+            hosts.push_back(config.getString(\"protocols.\" + protocol + \".host\"));\n+        else\n+            hosts = listen_hosts;\n+\n+        for (const auto & host : hosts)\n+        {\n+            std::string conf_name = \"protocols.\" + protocol;\n+            std::string prefix = conf_name + \".\";\n+\n+            if (!config.has(prefix + \"port\"))\n+                continue;\n+\n+            std::string description {\"<undefined> protocol\"};\n+            if (config.has(prefix + \"description\"))\n+                description = config.getString(prefix + \"description\");\n+            std::string port_name = prefix + \"port\";\n+            bool is_secure = false;\n+            auto stack = buildProtocolStackFromConfig(config, protocol, http_params, async_metrics, is_secure);\n+\n+            if (stack->empty())\n+                throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol '{}' stack empty\", protocol);\n+\n+            createServer(config, host, port_name.c_str(), listen_try, start_servers, servers, [&](UInt16 port) -> ProtocolServerAdapter\n+            {\n+                Poco::Net::ServerSocket socket;\n+                auto address = socketBindListen(config, socket, host, port, is_secure);\n+                socket.setReceiveTimeout(settings.receive_timeout);\n+                socket.setSendTimeout(settings.send_timeout);\n+\n+                return ProtocolServerAdapter(\n+                    host,\n+                    port_name.c_str(),\n+                    description + \": \" + address.toString(),\n+                    std::make_unique<TCPServer>(\n+                        stack.release(),\n+                        server_pool,\n+                        socket,\n+                        new Poco::Net::TCPServerParams));\n+            });\n+        }\n+    }\n+\n     for (const auto & listen_host : listen_hosts)\n     {\n         /// HTTP\n@@ -2118,13 +2256,50 @@ void Server::updateServers(\n     {\n         if (!server.isStopping())\n         {\n-            bool has_host = std::find(listen_hosts.begin(), listen_hosts.end(), server.getListenHost()) != listen_hosts.end();\n-            bool has_port = !config.getString(server.getPortName(), \"\").empty();\n+            std::string port_name = server.getPortName();\n+            bool has_host = false;\n+            bool is_http = false;\n+            if (port_name.starts_with(\"protocols.\"))\n+            {\n+                std::string protocol = port_name.substr(0, port_name.find_last_of('.'));\n+                has_host = config.has(protocol + \".host\");\n+\n+                std::string conf_name = protocol;\n+                std::string prefix = protocol + \".\";\n+                std::unordered_set<std::string> pset {conf_name};\n+                while (true)\n+                {\n+                    if (config.has(prefix + \"type\"))\n+                    {\n+                        std::string type = config.getString(prefix + \"type\");\n+                        if (type == \"http\")\n+                        {\n+                            is_http = true;\n+                            break;\n+                        }\n+                    }\n+\n+                    if (!config.has(prefix + \"impl\"))\n+                        break;\n+\n+                    conf_name = \"protocols.\" + config.getString(prefix + \"impl\");\n+                    prefix = conf_name + \".\";\n+\n+                    if (!pset.insert(conf_name).second)\n+                        throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Protocol '{}' configuration contains a loop on '{}'\", protocol, conf_name);\n+                }\n+            }\n+            else\n+            {\n+                /// NOTE: better to compare using getPortName() over using\n+                /// dynamic_cast<> since HTTPServer is also used for prometheus and\n+                /// internal replication communications.\n+                is_http = server.getPortName() == \"http_port\" || server.getPortName() == \"https_port\";\n+            }\n \n-            /// NOTE: better to compare using getPortName() over using\n-            /// dynamic_cast<> since HTTPServer is also used for prometheus and\n-            /// internal replication communications.\n-            bool is_http = server.getPortName() == \"http_port\" || server.getPortName() == \"https_port\";\n+            if (!has_host)\n+                has_host = std::find(listen_hosts.begin(), listen_hosts.end(), server.getListenHost()) != listen_hosts.end();\n+            bool has_port = !config.getString(port_name, \"\").empty();\n             bool force_restart = is_http && !isSameConfiguration(previous_config, config, \"http_handlers\");\n             if (force_restart)\n                 LOG_TRACE(log, \"<http_handlers> had been changed, will reload {}\", server.getDescription());\ndiff --git a/programs/server/Server.h b/programs/server/Server.h\nindex 44a5a441e435..53841b1fcd45 100644\n--- a/programs/server/Server.h\n+++ b/programs/server/Server.h\n@@ -3,6 +3,8 @@\n #include <Server/IServer.h>\n \n #include <Daemon/BaseDaemon.h>\n+#include <Server/TCPProtocolStackFactory.h>\n+#include <Poco/Net/HTTPServerParams.h>\n \n /** Server provides three interfaces:\n   * 1. HTTP - simple interface for any applications.\n@@ -77,6 +79,13 @@ class Server : public BaseDaemon, public IServer\n         UInt16 port,\n         [[maybe_unused]] bool secure = false) const;\n \n+    std::unique_ptr<TCPProtocolStackFactory> buildProtocolStackFromConfig(\n+        const Poco::Util::AbstractConfiguration & config,\n+        const std::string & protocol,\n+        Poco::Net::HTTPServerParams::Ptr http_params,\n+        AsynchronousMetrics & async_metrics,\n+        bool & is_secure);\n+\n     using CreateServerFunc = std::function<ProtocolServerAdapter(UInt16)>;\n     void createServer(\n         Poco::Util::AbstractConfiguration & config,\ndiff --git a/src/Functions/FunctionShowCertificate.h b/src/Functions/FunctionShowCertificate.h\nindex 32041e55b008..3c30d8138e5a 100644\n--- a/src/Functions/FunctionShowCertificate.h\n+++ b/src/Functions/FunctionShowCertificate.h\n@@ -2,6 +2,9 @@\n \n #include \"config.h\"\n \n+#include <memory>\n+#include <string>\n+\n #include <Columns/ColumnMap.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnString.h>\n@@ -33,14 +36,18 @@ class FunctionShowCertificate : public IFunction\n public:\n     static constexpr auto name = \"showCertificate\";\n \n-    static FunctionPtr create(ContextPtr)\n+    static FunctionPtr create(ContextPtr ctx)\n     {\n #if !defined(USE_SSL) || USE_SSL == 0\n         throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"SSL support is disabled\");\n #endif\n-        return std::make_shared<FunctionShowCertificate>();\n+        return std::make_shared<FunctionShowCertificate>(ctx->getQueryContext()->getClientInfo().certificate);\n     }\n \n+    std::string certificate;\n+\n+    explicit FunctionShowCertificate(const std::string & certificate_ = \"\") : certificate(certificate_) {}\n+\n     String getName() const override { return name; }\n \n     size_t getNumberOfArguments() const override { return 0; }\n@@ -61,7 +68,15 @@ class FunctionShowCertificate : public IFunction\n         if (input_rows_count)\n         {\n #if USE_SSL\n-            if (const X509 * cert = SSL_CTX_get0_certificate(Poco::Net::SSLManager::instance().defaultServerContext()->sslContext()))\n+            std::unique_ptr<Poco::Crypto::X509Certificate> x509_cert;\n+            if (!certificate.empty())\n+                x509_cert = std::make_unique<Poco::Crypto::X509Certificate>(certificate);\n+\n+            const X509 * cert = x509_cert ?\n+                x509_cert->certificate() :\n+                SSL_CTX_get0_certificate(Poco::Net::SSLManager::instance().defaultServerContext()->sslContext());\n+\n+            if (cert)\n             {\n                 BIO * b = BIO_new(BIO_s_mem());\n                 SCOPE_EXIT(\ndiff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h\nindex a1096b993256..f7a172b226de 100644\n--- a/src/Interpreters/ClientInfo.h\n+++ b/src/Interpreters/ClientInfo.h\n@@ -69,6 +69,7 @@ class ClientInfo\n \n     Interface interface = Interface::TCP;\n     bool is_secure = false;\n+    String certificate;\n \n     /// For tcp\n     String os_user;\ndiff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp\nindex 52588a5f4cc4..7639dec813d1 100644\n--- a/src/Interpreters/Session.cpp\n+++ b/src/Interpreters/Session.cpp\n@@ -244,7 +244,7 @@ void Session::shutdownNamedSessions()\n     NamedSessionsStorage::instance().shutdown();\n }\n \n-Session::Session(const ContextPtr & global_context_, ClientInfo::Interface interface_, bool is_secure)\n+Session::Session(const ContextPtr & global_context_, ClientInfo::Interface interface_, bool is_secure, const std::string & certificate)\n     : auth_id(UUIDHelpers::generateV4()),\n       global_context(global_context_),\n       log(&Poco::Logger::get(String{magic_enum::enum_name(interface_)} + \"-Session\"))\n@@ -252,6 +252,7 @@ Session::Session(const ContextPtr & global_context_, ClientInfo::Interface inter\n     prepared_client_info.emplace();\n     prepared_client_info->interface = interface_;\n     prepared_client_info->is_secure = is_secure;\n+    prepared_client_info->certificate = certificate;\n }\n \n Session::~Session()\ndiff --git a/src/Interpreters/Session.h b/src/Interpreters/Session.h\nindex ed4f7809dee6..0f17c378915e 100644\n--- a/src/Interpreters/Session.h\n+++ b/src/Interpreters/Session.h\n@@ -32,7 +32,7 @@ class Session\n     /// Stops using named sessions. The method must be called at the server shutdown.\n     static void shutdownNamedSessions();\n \n-    Session(const ContextPtr & global_context_, ClientInfo::Interface interface_, bool is_secure = false);\n+    Session(const ContextPtr & global_context_, ClientInfo::Interface interface_, bool is_secure = false, const std::string & certificate = \"\");\n     ~Session();\n \n     Session(const Session &&) = delete;\ndiff --git a/src/Server/ProxyV1Handler.cpp b/src/Server/ProxyV1Handler.cpp\nnew file mode 100644\nindex 000000000000..838a1de1c04a\n--- /dev/null\n+++ b/src/Server/ProxyV1Handler.cpp\n@@ -0,0 +1,123 @@\n+#include <Server/ProxyV1Handler.h>\n+#include <Poco/Net/NetException.h>\n+#include <Common/NetException.h>\n+#include <Interpreters/Context.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NETWORK_ERROR;\n+    extern const int SOCKET_TIMEOUT;\n+    extern const int CANNOT_READ_FROM_SOCKET;\n+    extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n+}\n+\n+void ProxyV1Handler::run()\n+{\n+    const auto & settings = server.context()->getSettingsRef();\n+    socket().setReceiveTimeout(settings.receive_timeout);\n+\n+    std::string word;\n+    bool eol;\n+\n+    // Read PROXYv1 protocol header\n+    // http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\n+\n+    // read \"PROXY\"\n+    if (!readWord(5, word, eol) || word != \"PROXY\" || eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    // read \"TCP4\" or \"TCP6\" or \"UNKNOWN\"\n+    if (!readWord(7, word, eol))\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    if (word != \"TCP4\" && word != \"TCP6\" && word != \"UNKNOWN\")\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    if (word == \"UNKNOWN\" && eol)\n+        return;\n+\n+    if (eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    // read address\n+    if (!readWord(39, word, eol) || eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    stack_data.forwarded_for = std::move(word);\n+\n+    // read address\n+    if (!readWord(39, word, eol) || eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    // read port\n+    if (!readWord(5, word, eol) || eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+\n+    // read port and \"\\r\\n\"\n+    if (!readWord(5, word, eol) || !eol)\n+        throw ParsingException(\"PROXY protocol violation\", ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+}\n+\n+bool ProxyV1Handler::readWord(int max_len, std::string & word, bool & eol)\n+{\n+    word.clear();\n+    eol = false;\n+\n+    char ch = 0;\n+    int n = 0;\n+    bool is_cr = false;\n+    try\n+    {\n+        for (++max_len; max_len > 0 || is_cr; --max_len)\n+        {\n+            n = socket().receiveBytes(&ch, 1);\n+            if (n == 0)\n+            {\n+                socket().shutdown();\n+                return false;\n+            }\n+            if (n < 0)\n+                break;\n+\n+            if (is_cr)\n+                return ch == 0x0A;\n+\n+            if (ch == 0x0D)\n+            {\n+                is_cr = true;\n+                eol = true;\n+                continue;\n+            }\n+\n+            if (ch == ' ')\n+                return true;\n+\n+            word.push_back(ch);\n+        }\n+    }\n+    catch (const Poco::Net::NetException & e)\n+    {\n+        throw NetException(e.displayText() + \", while reading from socket (\" + socket().peerAddress().toString() + \")\", ErrorCodes::NETWORK_ERROR);\n+    }\n+    catch (const Poco::TimeoutException &)\n+    {\n+        throw NetException(fmt::format(\"Timeout exceeded while reading from socket ({}, {} ms)\",\n+            socket().peerAddress().toString(),\n+            socket().getReceiveTimeout().totalMilliseconds()), ErrorCodes::SOCKET_TIMEOUT);\n+    }\n+    catch (const Poco::IOException & e)\n+    {\n+        throw NetException(e.displayText() + \", while reading from socket (\" + socket().peerAddress().toString() + \")\", ErrorCodes::NETWORK_ERROR);\n+    }\n+\n+    if (n < 0)\n+        throw NetException(\"Cannot read from socket (\" + socket().peerAddress().toString() + \")\", ErrorCodes::CANNOT_READ_FROM_SOCKET);\n+\n+    return false;\n+}\n+\n+}\ndiff --git a/src/Server/ProxyV1Handler.h b/src/Server/ProxyV1Handler.h\nnew file mode 100644\nindex 000000000000..062cc0e291a6\n--- /dev/null\n+++ b/src/Server/ProxyV1Handler.h\n@@ -0,0 +1,29 @@\n+#pragma once\n+\n+#include <Poco/Net/TCPServerConnection.h>\n+#include <Server/IServer.h>\n+#include <Server/TCPProtocolStackData.h>\n+\n+\n+namespace DB\n+{\n+\n+class ProxyV1Handler : public Poco::Net::TCPServerConnection\n+{\n+    using StreamSocket = Poco::Net::StreamSocket;\n+public:\n+    explicit ProxyV1Handler(const StreamSocket & socket, IServer & server_, const std::string & conf_name_, TCPProtocolStackData & stack_data_)\n+        : Poco::Net::TCPServerConnection(socket), server(server_), conf_name(conf_name_), stack_data(stack_data_) {}\n+\n+    void run() override;\n+\n+protected:\n+    bool readWord(int max_len, std::string & word, bool & eol);\n+\n+private:\n+    IServer & server;\n+    std::string conf_name;\n+    TCPProtocolStackData & stack_data;\n+};\n+\n+}\ndiff --git a/src/Server/ProxyV1HandlerFactory.h b/src/Server/ProxyV1HandlerFactory.h\nnew file mode 100644\nindex 000000000000..028596d745d0\n--- /dev/null\n+++ b/src/Server/ProxyV1HandlerFactory.h\n@@ -0,0 +1,56 @@\n+#pragma once\n+\n+#include <Poco/Net/NetException.h>\n+#include <Poco/Net/TCPServerConnection.h>\n+#include <Server/ProxyV1Handler.h>\n+#include <Common/logger_useful.h>\n+#include <Server/IServer.h>\n+#include <Server/TCPServer.h>\n+#include <Server/TCPProtocolStackData.h>\n+\n+\n+namespace DB\n+{\n+\n+class ProxyV1HandlerFactory : public TCPServerConnectionFactory\n+{\n+private:\n+    IServer & server;\n+    Poco::Logger * log;\n+    std::string conf_name;\n+\n+    class DummyTCPHandler : public Poco::Net::TCPServerConnection\n+    {\n+    public:\n+        using Poco::Net::TCPServerConnection::TCPServerConnection;\n+        void run() override {}\n+    };\n+\n+public:\n+    explicit ProxyV1HandlerFactory(IServer & server_, const std::string & conf_name_)\n+        : server(server_), log(&Poco::Logger::get(\"ProxyV1HandlerFactory\")), conf_name(conf_name_)\n+    {\n+    }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) override\n+    {\n+        TCPProtocolStackData stack_data;\n+        return createConnection(socket, tcp_server, stack_data);\n+    }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer &/* tcp_server*/, TCPProtocolStackData & stack_data) override\n+    {\n+        try\n+        {\n+            LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n+            return new ProxyV1Handler(socket, server, conf_name, stack_data);\n+        }\n+        catch (const Poco::Net::NetException &)\n+        {\n+            LOG_TRACE(log, \"TCP Request. Client is not connected (most likely RST packet was sent).\");\n+            return new DummyTCPHandler(socket);\n+        }\n+    }\n+};\n+\n+}\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex df22afebb1db..bcf675fbe824 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -109,6 +109,18 @@ TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::N\n {\n }\n \n+TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_)\n+: Poco::Net::TCPServerConnection(socket_)\n+    , server(server_)\n+    , tcp_server(tcp_server_)\n+    , log(&Poco::Logger::get(\"TCPHandler\"))\n+    , forwarded_for(stack_data.forwarded_for)\n+    , certificate(stack_data.certificate)\n+    , default_database(stack_data.default_database)\n+    , server_display_name(std::move(server_display_name_))\n+{\n+}\n+\n TCPHandler::~TCPHandler()\n {\n     try\n@@ -1055,7 +1067,7 @@ std::unique_ptr<Session> TCPHandler::makeSession()\n {\n     auto interface = is_interserver_mode ? ClientInfo::Interface::TCP_INTERSERVER : ClientInfo::Interface::TCP;\n \n-    auto res = std::make_unique<Session>(server.context(), interface, socket().secure());\n+    auto res = std::make_unique<Session>(server.context(), interface, socket().secure(), certificate);\n \n     auto & client_info = res->getClientInfo();\n     client_info.forwarded_for = forwarded_for;\n@@ -1082,6 +1094,7 @@ void TCPHandler::receiveHello()\n     UInt64 packet_type = 0;\n     String user;\n     String password;\n+    String default_db;\n \n     readVarUInt(packet_type, *in);\n     if (packet_type != Protocol::Client::Hello)\n@@ -1103,7 +1116,9 @@ void TCPHandler::receiveHello()\n     readVarUInt(client_version_minor, *in);\n     // NOTE For backward compatibility of the protocol, client cannot send its version_patch.\n     readVarUInt(client_tcp_protocol_version, *in);\n-    readStringBinary(default_database, *in);\n+    readStringBinary(default_db, *in);\n+    if (!default_db.empty())\n+        default_database = default_db;\n     readStringBinary(user, *in);\n     readStringBinary(password, *in);\n \ndiff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h\nindex ea5fb2f9fe03..c36ce1e93780 100644\n--- a/src/Server/TCPHandler.h\n+++ b/src/Server/TCPHandler.h\n@@ -22,6 +22,7 @@\n #include <Storages/MergeTree/ParallelReplicasReadingCoordinator.h>\n \n #include \"IServer.h\"\n+#include \"Server/TCPProtocolStackData.h\"\n #include \"base/types.h\"\n \n \n@@ -137,6 +138,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n       * Proxy-forwarded (original client) IP address is used for quota accounting if quota is keyed by forwarded IP.\n       */\n     TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_);\n+    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_);\n     ~TCPHandler() override;\n \n     void run() override;\n@@ -151,6 +153,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n     Poco::Logger * log;\n \n     String forwarded_for;\n+    String certificate;\n \n     String client_name;\n     UInt64 client_version_major = 0;\ndiff --git a/src/Server/TCPHandlerFactory.h b/src/Server/TCPHandlerFactory.h\nindex 354c886f4c09..fde04c6e0ab4 100644\n--- a/src/Server/TCPHandlerFactory.h\n+++ b/src/Server/TCPHandlerFactory.h\n@@ -3,6 +3,7 @@\n #include <Poco/Net/NetException.h>\n #include <Poco/Util/LayeredConfiguration.h>\n #include <Common/logger_useful.h>\n+#include \"Server/TCPProtocolStackData.h\"\n #include <Server/IServer.h>\n #include <Server/TCPHandler.h>\n #include <Server/TCPServerConnectionFactory.h>\n@@ -53,6 +54,21 @@ class TCPHandlerFactory : public TCPServerConnectionFactory\n             return new DummyTCPHandler(socket);\n         }\n     }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData & stack_data) override\n+    {\n+        try\n+        {\n+            LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n+\n+            return new TCPHandler(server, tcp_server, socket, stack_data, server_display_name);\n+        }\n+        catch (const Poco::Net::NetException &)\n+        {\n+            LOG_TRACE(log, \"TCP Request. Client is not connected (most likely RST packet was sent).\");\n+            return new DummyTCPHandler(socket);\n+        }\n+    }\n };\n \n }\ndiff --git a/src/Server/TCPProtocolStackData.h b/src/Server/TCPProtocolStackData.h\nnew file mode 100644\nindex 000000000000..4ad401e723f8\n--- /dev/null\n+++ b/src/Server/TCPProtocolStackData.h\n@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <string>\n+#include <Poco/Net/StreamSocket.h>\n+\n+namespace DB\n+{\n+\n+// Data to communicate between protocol layers\n+struct TCPProtocolStackData\n+{\n+    // socket implementation can be replaced by some layer - TLS as an example\n+    Poco::Net::StreamSocket socket;\n+    // host from PROXY layer\n+    std::string forwarded_for;\n+    // certificate path from TLS layer to TCP layer\n+    std::string certificate;\n+    // default database from endpoint configuration to TCP layer\n+    std::string default_database;\n+};\n+\n+}\ndiff --git a/src/Server/TCPProtocolStackFactory.h b/src/Server/TCPProtocolStackFactory.h\nnew file mode 100644\nindex 000000000000..16b57649a725\n--- /dev/null\n+++ b/src/Server/TCPProtocolStackFactory.h\n@@ -0,0 +1,92 @@\n+#pragma once\n+\n+#include <Server/TCPServerConnectionFactory.h>\n+#include <Server/IServer.h>\n+#include <Server/TCPProtocolStackHandler.h>\n+#include <Poco/Logger.h>\n+#include <Poco/Net/NetException.h>\n+#include <Common/logger_useful.h>\n+#include <Access/Common/AllowedClientHosts.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNKNOWN_ADDRESS_PATTERN_TYPE;\n+    extern const int IP_ADDRESS_NOT_ALLOWED;\n+}\n+\n+\n+class TCPProtocolStackFactory : public TCPServerConnectionFactory\n+{\n+private:\n+    IServer & server [[maybe_unused]];\n+    Poco::Logger * log;\n+    std::string conf_name;\n+    std::vector<TCPServerConnectionFactory::Ptr> stack;\n+    AllowedClientHosts allowed_client_hosts;\n+\n+    class DummyTCPHandler : public Poco::Net::TCPServerConnection\n+    {\n+    public:\n+        using Poco::Net::TCPServerConnection::TCPServerConnection;\n+        void run() override {}\n+    };\n+\n+public:\n+    template <typename... T>\n+    explicit TCPProtocolStackFactory(IServer & server_, const std::string & conf_name_, T... factory)\n+        : server(server_), log(&Poco::Logger::get(\"TCPProtocolStackFactory\")), conf_name(conf_name_), stack({factory...})\n+    {\n+        const auto & config = server.config();\n+        /// Fill list of allowed hosts.\n+        const auto networks_config = conf_name + \".networks\";\n+        if (config.has(networks_config))\n+        {\n+            Poco::Util::AbstractConfiguration::Keys keys;\n+            config.keys(networks_config, keys);\n+            for (const String & key : keys)\n+            {\n+                String value = config.getString(networks_config + \".\" + key);\n+                if (key.starts_with(\"ip\"))\n+                    allowed_client_hosts.addSubnet(value);\n+                else if (key.starts_with(\"host_regexp\"))\n+                    allowed_client_hosts.addNameRegexp(value);\n+                else if (key.starts_with(\"host\"))\n+                    allowed_client_hosts.addName(value);\n+                else\n+                    throw Exception(\"Unknown address pattern type: \" + key, ErrorCodes::UNKNOWN_ADDRESS_PATTERN_TYPE);\n+            }\n+        }\n+    }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) override\n+    {\n+        if (!allowed_client_hosts.empty() && !allowed_client_hosts.contains(socket.peerAddress().host()))\n+            throw Exception(\"Connections from \" + socket.peerAddress().toString() + \" are not allowed\", ErrorCodes::IP_ADDRESS_NOT_ALLOWED);\n+\n+        try\n+        {\n+            LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n+            return new TCPProtocolStackHandler(server, tcp_server, socket, stack, conf_name);\n+        }\n+        catch (const Poco::Net::NetException &)\n+        {\n+            LOG_TRACE(log, \"TCP Request. Client is not connected (most likely RST packet was sent).\");\n+            return new DummyTCPHandler(socket);\n+        }\n+    }\n+\n+    void append(TCPServerConnectionFactory::Ptr factory)\n+    {\n+        stack.push_back(std::move(factory));\n+    }\n+\n+    size_t size() { return stack.size(); }\n+    bool empty() { return stack.empty(); }\n+};\n+\n+\n+}\ndiff --git a/src/Server/TCPProtocolStackHandler.h b/src/Server/TCPProtocolStackHandler.h\nnew file mode 100644\nindex 000000000000..e16a6b6b2cae\n--- /dev/null\n+++ b/src/Server/TCPProtocolStackHandler.h\n@@ -0,0 +1,46 @@\n+#pragma once\n+\n+#include <Server/TCPServerConnectionFactory.h>\n+#include <Server/TCPServer.h>\n+#include <Poco/Util/LayeredConfiguration.h>\n+#include <Server/IServer.h>\n+#include <Server/TCPProtocolStackData.h>\n+\n+\n+namespace DB\n+{\n+\n+\n+class TCPProtocolStackHandler : public Poco::Net::TCPServerConnection\n+{\n+    using StreamSocket = Poco::Net::StreamSocket;\n+    using TCPServerConnection = Poco::Net::TCPServerConnection;\n+private:\n+    IServer & server;\n+    TCPServer & tcp_server;\n+    std::vector<TCPServerConnectionFactory::Ptr> stack;\n+    std::string conf_name;\n+\n+public:\n+    TCPProtocolStackHandler(IServer & server_, TCPServer & tcp_server_, const StreamSocket & socket, const std::vector<TCPServerConnectionFactory::Ptr> & stack_, const std::string & conf_name_)\n+        : TCPServerConnection(socket), server(server_), tcp_server(tcp_server_), stack(stack_), conf_name(conf_name_)\n+    {}\n+\n+    void run() override\n+    {\n+        const auto & conf = server.config();\n+        TCPProtocolStackData stack_data;\n+        stack_data.socket = socket();\n+        stack_data.default_database = conf.getString(conf_name + \".default_database\", \"\");\n+        for (auto & factory : stack)\n+        {\n+            std::unique_ptr<TCPServerConnection> connection(factory->createConnection(socket(), tcp_server, stack_data));\n+            connection->run();\n+            if (stack_data.socket != socket())\n+                socket() = stack_data.socket;\n+        }\n+    }\n+};\n+\n+\n+}\ndiff --git a/src/Server/TCPServerConnectionFactory.h b/src/Server/TCPServerConnectionFactory.h\nindex 613f98352bdf..18b30557b000 100644\n--- a/src/Server/TCPServerConnectionFactory.h\n+++ b/src/Server/TCPServerConnectionFactory.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Poco/SharedPtr.h>\n+#include <Server/TCPProtocolStackData.h>\n \n namespace Poco\n {\n@@ -23,5 +24,9 @@ class TCPServerConnectionFactory\n \n     /// Same as Poco::Net::TCPServerConnectionFactory except we can pass the TCPServer\n     virtual Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) = 0;\n+    virtual Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData &/* stack_data */)\n+    {\n+        return createConnection(socket, tcp_server);\n+    }\n };\n }\ndiff --git a/src/Server/TLSHandler.h b/src/Server/TLSHandler.h\nnew file mode 100644\nindex 000000000000..5b7377515c14\n--- /dev/null\n+++ b/src/Server/TLSHandler.h\n@@ -0,0 +1,59 @@\n+#pragma once\n+\n+#include <Poco/Net/TCPServerConnection.h>\n+#include <Poco/SharedPtr.h>\n+#include <Common/Exception.h>\n+#include <Server/TCPProtocolStackData.h>\n+\n+#if USE_SSL\n+#   include <Poco/Net/Context.h>\n+#   include <Poco/Net/SecureStreamSocket.h>\n+#   include <Poco/Net/SSLManager.h>\n+#endif\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int SUPPORT_IS_DISABLED;\n+}\n+\n+class TLSHandler : public Poco::Net::TCPServerConnection\n+{\n+#if USE_SSL\n+    using SecureStreamSocket = Poco::Net::SecureStreamSocket;\n+    using SSLManager = Poco::Net::SSLManager;\n+    using Context = Poco::Net::Context;\n+#endif\n+    using StreamSocket = Poco::Net::StreamSocket;\n+public:\n+    explicit TLSHandler(const StreamSocket & socket, const std::string & key_, const std::string & certificate_, TCPProtocolStackData & stack_data_)\n+        : Poco::Net::TCPServerConnection(socket)\n+        , key(key_)\n+        , certificate(certificate_)\n+        , stack_data(stack_data_)\n+    {}\n+\n+    void run() override\n+    {\n+#if USE_SSL\n+        auto ctx = SSLManager::instance().defaultServerContext();\n+        if (!key.empty() && !certificate.empty())\n+            ctx = new Context(Context::Usage::SERVER_USE, key, certificate, ctx->getCAPaths().caLocation);\n+        socket() = SecureStreamSocket::attach(socket(), ctx);\n+        stack_data.socket = socket();\n+        stack_data.certificate = certificate;\n+#else\n+        throw Exception{\"SSL support for TCP protocol is disabled because Poco library was built without NetSSL support.\",\n+                        ErrorCodes::SUPPORT_IS_DISABLED};\n+#endif\n+    }\n+private:\n+    std::string key [[maybe_unused]];\n+    std::string certificate [[maybe_unused]];\n+    TCPProtocolStackData & stack_data [[maybe_unused]];\n+};\n+\n+\n+}\ndiff --git a/src/Server/TLSHandlerFactory.h b/src/Server/TLSHandlerFactory.h\nnew file mode 100644\nindex 000000000000..9e3002d29719\n--- /dev/null\n+++ b/src/Server/TLSHandlerFactory.h\n@@ -0,0 +1,64 @@\n+#pragma once\n+\n+#include <Poco/Logger.h>\n+#include <Poco/Net/TCPServerConnection.h>\n+#include <Poco/Net/NetException.h>\n+#include <Poco/Util/LayeredConfiguration.h>\n+#include <Server/TLSHandler.h>\n+#include <Server/IServer.h>\n+#include <Server/TCPServer.h>\n+#include <Server/TCPProtocolStackData.h>\n+#include <Common/logger_useful.h>\n+\n+\n+namespace DB\n+{\n+\n+\n+class TLSHandlerFactory : public TCPServerConnectionFactory\n+{\n+private:\n+    IServer & server;\n+    Poco::Logger * log;\n+    std::string conf_name;\n+\n+    class DummyTCPHandler : public Poco::Net::TCPServerConnection\n+    {\n+    public:\n+        using Poco::Net::TCPServerConnection::TCPServerConnection;\n+        void run() override {}\n+    };\n+\n+public:\n+    explicit TLSHandlerFactory(IServer & server_, const std::string & conf_name_)\n+        : server(server_), log(&Poco::Logger::get(\"TLSHandlerFactory\")), conf_name(conf_name_)\n+    {\n+    }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) override\n+    {\n+        TCPProtocolStackData stack_data;\n+        return createConnection(socket, tcp_server, stack_data);\n+    }\n+\n+    Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer &/* tcp_server*/, TCPProtocolStackData & stack_data) override\n+    {\n+        try\n+        {\n+            LOG_TRACE(log, \"TCP Request. Address: {}\", socket.peerAddress().toString());\n+            return new TLSHandler(\n+                socket,\n+                server.config().getString(conf_name + \".privateKeyFile\", \"\"),\n+                server.config().getString(conf_name + \".certificateFile\", \"\"),\n+                stack_data);\n+        }\n+        catch (const Poco::Net::NetException &)\n+        {\n+            LOG_TRACE(log, \"TCP Request. Client is not connected (most likely RST packet was sent).\");\n+            return new DummyTCPHandler(socket);\n+        }\n+    }\n+};\n+\n+\n+}\n",
  "test_patch": "diff --git a/tests/integration/helpers/client.py b/tests/integration/helpers/client.py\nindex a4407d5b442a..ab1cc65e9a9f 100644\n--- a/tests/integration/helpers/client.py\n+++ b/tests/integration/helpers/client.py\n@@ -8,7 +8,14 @@\n \n \n class Client:\n-    def __init__(self, host, port=9000, command=\"/usr/bin/clickhouse-client\"):\n+    def __init__(\n+        self,\n+        host,\n+        port=9000,\n+        command=\"/usr/bin/clickhouse-client\",\n+        secure=False,\n+        config=None,\n+    ):\n         self.host = host\n         self.port = port\n         self.command = [command]\n@@ -16,6 +23,11 @@ def __init__(self, host, port=9000, command=\"/usr/bin/clickhouse-client\"):\n         if os.path.basename(command) == \"clickhouse\":\n             self.command.append(\"client\")\n \n+        if secure:\n+            self.command.append(\"--secure\")\n+        if config is not None:\n+            self.command += [\"--config-file\", config]\n+\n         self.command += [\"--host\", self.host, \"--port\", str(self.port), \"--stacktrace\"]\n \n     def stacktraces_on_timeout_decorator(func):\ndiff --git a/tests/integration/test_composable_protocols/__init__.py b/tests/integration/test_composable_protocols/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_composable_protocols/configs/client.xml b/tests/integration/test_composable_protocols/configs/client.xml\nnew file mode 100644\nindex 000000000000..15d83a7b1ab4\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/configs/client.xml\n@@ -0,0 +1,10 @@\n+<clickhouse>\n+    <openSSL>\n+        <client>\n+            <verificationMode>none</verificationMode>\n+            <invalidCertificateHandler>\n+                <name>AcceptCertificateHandler</name>\n+            </invalidCertificateHandler>\n+        </client>\n+    </openSSL>\n+</clickhouse>\ndiff --git a/tests/integration/test_composable_protocols/configs/config.xml b/tests/integration/test_composable_protocols/configs/config.xml\nnew file mode 100644\nindex 000000000000..35673c3e7e59\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/configs/config.xml\n@@ -0,0 +1,63 @@\n+<clickhouse>\n+    <!-- Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/ClickHouse-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71 -->\n+    <openSSL>\n+        <server> <!-- Used for https server AND secure tcp port -->\n+            <!-- openssl req -subj \"/CN=localhost\" -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt -->\n+            <certificateFile>/etc/clickhouse-server/config.d/server.crt</certificateFile>\n+            <privateKeyFile>/etc/clickhouse-server/config.d/server.key</privateKeyFile>\n+            <verificationMode>none</verificationMode>\n+            <loadDefaultCAFile>true</loadDefaultCAFile>\n+            <cacheSessions>true</cacheSessions>\n+            <disableProtocols>sslv2,sslv3</disableProtocols>\n+            <preferServerCiphers>true</preferServerCiphers>\n+        </server>\n+    </openSSL>\n+\n+    <listen_host>0.0.0.0</listen_host>\n+\n+    <protocols>\n+        <tcp>\n+            <type>tcp</type>\n+            <host>0.0.0.0</host>\n+            <port>9000</port>\n+            <description>native protocol (tcp)</description>\n+        </tcp>\n+        <tcp_secure>\n+            <type>tls</type>\n+            <impl>tcp</impl>\n+            <port>9440</port>\n+            <description>secure native protocol (tcp_secure)</description>\n+        </tcp_secure>\n+        <tcp_endpoint>\n+            <impl>tcp</impl>\n+            <host>0.0.0.0</host>\n+            <port>9001</port>\n+            <description>native protocol endpoint (tcp)</description>\n+        </tcp_endpoint>\n+        <tcp_proxy>\n+            <type>proxy1</type>\n+            <impl>tcp</impl>\n+            <port>9100</port>\n+            <description>native protocol with PROXYv1 (tcp_proxy)</description>\n+        </tcp_proxy>\n+        <http>\n+            <type>http</type>\n+            <port>8123</port>\n+            <description>http protocol</description>\n+        </http>\n+        <https>\n+            <type>tls</type>\n+            <impl>http</impl>\n+            <host>0.0.0.0</host>\n+            <port>8443</port>\n+            <description>https protocol</description>\n+        </https>\n+        <https_endpoint>\n+            <impl>https</impl>\n+            <port>8444</port>\n+            <description>https protocol endpoint</description>\n+        </https_endpoint>\n+    </protocols>\n+\n+    <!--tcp_port>9010</tcp_port--> \n+</clickhouse>\ndiff --git a/tests/integration/test_composable_protocols/configs/server.crt b/tests/integration/test_composable_protocols/configs/server.crt\nnew file mode 100644\nindex 000000000000..6f4deca038fb\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/configs/server.crt\n@@ -0,0 +1,18 @@\n+-----BEGIN CERTIFICATE-----\n+MIIC+zCCAeOgAwIBAgIJAIhI9ozZJ+TWMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\n+BAMMCWxvY2FsaG9zdDAeFw0xOTA0MjIwNDMyNTJaFw0yMDA0MjEwNDMyNTJaMBQx\n+EjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n+ggEBAK+wVUEdqF2uXvN0MJBgnAHyXi6JTi4p/F6igsrCjSNjJWzHH0vQmK8ujfcF\n+CkifW88i+W5eHctuEtQqNHK+t9x9YiZtXrj6m/XkOXs20mYgENSmbbbHbriTPnZB\n+zZrq6UqMlwIHNNAa+I3NMORQxVRaI0ybXnGVO5elr70xHpk03xL0JWKHpEqYp4db\n+2aBQgF6y3Ww4khxjIYqpUYXWXGFnVIRU7FKVEAM1xyKqvQzXjQ5sVM/wyHknveEF\n+3b/X4ggN+KNl5KOc0cWDh1/XaatJAPaUUPqZcq76tynLbP64Xm3dxHcj+gtRkO67\n+ef6MSg6l63m3XQP6Qb+MIkd06OsCAwEAAaNQME4wHQYDVR0OBBYEFDmODTO8QLDN\n+ykR3x0LIOnjNhrKhMB8GA1UdIwQYMBaAFDmODTO8QLDNykR3x0LIOnjNhrKhMAwG\n+A1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAAwaiJc7uqEpnH3aukbftDwX\n+m8GfEnj1HVdgg+9GGNq+9rvUYBF6gdPmjRCX9dO0cclLFx8jc2org0rTSq9WoOhX\n+E6qL4Eqrmc5SE3Y9jZM0h6GRD4oXK014FmtZ3T6ddZU3dQLj3BS2r1XrvmubTvGN\n+ZuTJNY8nx8Hh6H5XINmsEjUF9E5hog+PwCE03xt2adIdYL+gsbxASeNYyeUFpZv5\n+zcXR3VoakBWnAaOVgCHq2qh96QAnL7ZKzFkGf/MdwV10KU3dmb+ICbQUUdf9Gc17\n+aaDCIRws312F433FdXBkGs2UkB7ZZme9dfn6O1QbeTNvex2VLMqYx/CTkfFbOQA=\n+-----END CERTIFICATE-----\ndiff --git a/tests/integration/test_composable_protocols/configs/server.key b/tests/integration/test_composable_protocols/configs/server.key\nnew file mode 100644\nindex 000000000000..6eddb3295db7\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/configs/server.key\n@@ -0,0 +1,28 @@\n+-----BEGIN PRIVATE KEY-----\n+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCvsFVBHahdrl7z\n+dDCQYJwB8l4uiU4uKfxeooLKwo0jYyVsxx9L0JivLo33BQpIn1vPIvluXh3LbhLU\n+KjRyvrfcfWImbV64+pv15Dl7NtJmIBDUpm22x264kz52Qc2a6ulKjJcCBzTQGviN\n+zTDkUMVUWiNMm15xlTuXpa+9MR6ZNN8S9CVih6RKmKeHW9mgUIBest1sOJIcYyGK\n+qVGF1lxhZ1SEVOxSlRADNcciqr0M140ObFTP8Mh5J73hBd2/1+IIDfijZeSjnNHF\n+g4df12mrSQD2lFD6mXKu+rcpy2z+uF5t3cR3I/oLUZDuu3n+jEoOpet5t10D+kG/\n+jCJHdOjrAgMBAAECggEARF66zrxb6RkSmmt8+rKeA6PuQu3sHsr4C1vyyjUr97l9\n+tvdGlpp20LWtSZQMjHZ3pARYTTsTHTeY3DgQcRcHNicVKx8k3ZepWeeW9vw+pL+V\n+zSt3RsoVrH6gsCSrfr4sS3aqzX9AbjwQvh48CJ3mLQ1m70kHV+xbZIh1+4pB/hyP\n+1wKyUE18ZkOptXvO/TtoHzLQCecpkXtWzmry1Eh2isvXA+NMrAtLibGsyM1mtm7i\n+5ozevzHabvvCDBEe+KgZdONgVhhhvm2eOd+/s4w3rw4ETud4fI/ZAJyWXhiIKFnA\n+VJbElWruSAoVBW7p2bsF5PbmVzvo8vXL+VylxYD+AQKBgQDhLoRKTVhNkn/QjKxq\n+sdOh+QZra0LzjVpAmkQzu7wZMSHEz9qePQciDQQrYKrmRF1vNcIRCVUTqWYheJ/1\n+lKRrCGa0ab6k96zkWMqLHD5u+UeJV7r1dJIx08ME9kNJ+x/XtB8klRIji16NiQUS\n+qc6p8z0M2AnbJzsRfWZRH8FeYwKBgQDHu8dzdtVGI7MtxfPOE/bfajiopDg8BdTC\n+pdug2T8XofRHRq7Q+0vYjTAZFT/slib91Pk6VvvPdo9VBZiL4omv4dAq6mOOdX/c\n+U14mJe1X5GCrr8ExZ8BfNJ3t/6sV1fcxyJwAw7iBguqxA2JqdM/wFk10K8XqvzVn\n+CD6O9yGt2QKBgFX1BMi8N538809vs41S7l9hCQNOQZNo/O+2M5yv6ECRkbtoQKKw\n+1x03bMUGNJaLuELweXE5Z8GGo5bZTe5X3F+DKHlr+DtO1C+ieUaa9HY2MAmMdLCn\n+2/qrREGLo+oEs4YKmuzC/taUp/ZNPKOAMISNdluFyFVg51pozPrgrVbTAoGBAKkE\n+LBl3O67o0t0vH8sJdeVFG8EJhlS0koBMnfgVHqC++dm+5HwPyvTrNQJkyv1HaqNt\n+r6FArkG3ED9gRuBIyT6+lctbIPgSUip9mbQqcBfqOCvQxGksZMur2ODncz09HLtS\n+CUFUXjOqNzOnq4ZuZu/Bz7U4vXiSaXxQq6+LTUKxAoGAFZU/qrI06XxnrE9A1X0W\n+l7DSkpZaDcu11NrZ473yONih/xOZNh4SSBpX8a7F6Pmh9BdtGqphML8NFPvQKcfP\n+b9H2iid2tc292uyrUEb5uTMmv61zoTwtitqLzO0+tS6PT3fXobX+eyeEWKzPBljL\n+HFtxG5CCXpkdnWRmaJnhTzA=\n+-----END PRIVATE KEY-----\ndiff --git a/tests/integration/test_composable_protocols/configs/users.xml b/tests/integration/test_composable_protocols/configs/users.xml\nnew file mode 100644\nindex 000000000000..da8425b3695b\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/configs/users.xml\n@@ -0,0 +1,16 @@\n+<clickhouse>\n+    <profiles>\n+        <default>\n+        </default>\n+    </profiles>\n+\n+    <users>\n+        <default>\n+            <password></password>\n+            <networks replace=\"replace\">\n+                <ip>::/0</ip>\n+            </networks>\n+            <profile>default</profile>\n+        </default>\n+    </users>\n+</clickhouse>\ndiff --git a/tests/integration/test_composable_protocols/test.py b/tests/integration/test_composable_protocols/test.py\nnew file mode 100644\nindex 000000000000..d861af929c3e\n--- /dev/null\n+++ b/tests/integration/test_composable_protocols/test.py\n@@ -0,0 +1,94 @@\n+import ssl\n+import pytest\n+import os.path as p\n+import os\n+from helpers.cluster import ClickHouseCluster\n+from helpers.client import Client\n+import urllib.request, urllib.parse\n+import subprocess\n+import socket\n+\n+SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\n+\n+cluster = ClickHouseCluster(__file__)\n+server = cluster.add_instance(\n+    \"server\",\n+    base_config_dir=\"configs\",\n+    main_configs=[\"configs/server.crt\", \"configs/server.key\"],\n+)\n+\n+\n+@pytest.fixture(scope=\"module\", autouse=True)\n+def setup_nodes():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def execute_query_https(host, port, query):\n+    url = f\"https://{host}:{port}/?query={urllib.parse.quote(query)}\"\n+\n+    ctx = ssl.create_default_context()\n+    ctx.check_hostname = False\n+    ctx.verify_mode = ssl.CERT_NONE\n+\n+    request = urllib.request.Request(url)\n+    response = urllib.request.urlopen(request, context=ctx).read()\n+    return response.decode(\"utf-8\")\n+\n+\n+def execute_query_http(host, port, query):\n+    url = f\"http://{host}:{port}/?query={urllib.parse.quote(query)}\"\n+\n+    request = urllib.request.Request(url)\n+    response = urllib.request.urlopen(request).read()\n+    return response.decode(\"utf-8\")\n+\n+\n+def netcat(hostname, port, content):\n+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+    s.connect((hostname, port))\n+    s.sendall(content)\n+    s.shutdown(socket.SHUT_WR)\n+    data = []\n+    while 1:\n+        d = s.recv(1024)\n+        if len(d) == 0:\n+            break\n+        data.append(d)\n+    s.close()\n+    return b\"\".join(data)\n+\n+\n+def test_connections():\n+\n+    client = Client(server.ip_address, 9000, command=cluster.client_bin_path)\n+    assert client.query(\"SELECT 1\") == \"1\\n\"\n+\n+    client = Client(\n+        server.ip_address,\n+        9440,\n+        command=cluster.client_bin_path,\n+        secure=True,\n+        config=f\"{SCRIPT_DIR}/configs/client.xml\",\n+    )\n+    assert client.query(\"SELECT 1\") == \"1\\n\"\n+\n+    client = Client(server.ip_address, 9001, command=cluster.client_bin_path)\n+    assert client.query(\"SELECT 1\") == \"1\\n\"\n+\n+    assert execute_query_http(server.ip_address, 8123, \"SELECT 1\") == \"1\\n\"\n+\n+    assert execute_query_https(server.ip_address, 8443, \"SELECT 1\") == \"1\\n\"\n+\n+    assert execute_query_https(server.ip_address, 8444, \"SELECT 1\") == \"1\\n\"\n+\n+    data = \"PROXY TCP4 255.255.255.255 255.255.255.255 65535 65535\\r\\n\\0\\021ClickHouse client\\024\\r\\253\\251\\003\\0\\007default\\0\\004\\001\\0\\001\\0\\0\\t0.0.0.0:0\\001\\tmilovidov\\021milovidov-desktop\\vClickHouse \\024\\r\\253\\251\\003\\0\\001\\0\\0\\0\\002\\001\\025SELECT 'Hello, world'\\002\\0\\247\\203\\254l\\325\\\\z|\\265\\254F\\275\\333\\206\\342\\024\\202\\024\\0\\0\\0\\n\\0\\0\\0\\240\\01\\0\\02\\377\\377\\377\\377\\0\\0\\0\"\n+    assert (\n+        netcat(server.ip_address, 9100, bytearray(data, \"latin-1\")).find(\n+            bytearray(\"Hello, world\", \"latin-1\")\n+        )\n+        >= 0\n+    )\n",
  "problem_statement": "Composable protocols configuration of the server.\nThe idea is to make the configuration of the protocols (TCP, HTTP, HTTPS, MySQL, etc) and the ports to listen more flexible.\r\n\r\n1. It should be possible to specify a custom list of listen_host and listen_port for every protocol.\r\n2. A protocol can be listed multiple times in the config (with different settings).\r\n3. Default user and database can be overridden in every protocol entry.\r\n4. It should be possible to configure different TLS certificates for different protocols.\r\n5. It should be possible to configure TLS and PROXYv1 as wrappers on top of other protocols, e.g. enable PROXYv1 on top of TLS on top of HTTP.\r\n6. Allow configuring IP filtering for every protocol.\r\n\r\n\r\n**Use case**\r\n\r\nExamples:\r\n- allow TCP protocol without TLS on localhost with the default user named \"root\" and allow TCP with TLS for internet with the default user named \"default\";\r\n- bind server to multiple network interfaces, but also on different ports;\r\n- wrap HTTP protocol under PROXYv1 protocol;\r\n- use different ports for user queries and internal communication for distributed queries.\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nA hierarchical configuration where one protocol can be built on top of the parameters of another protocol.\r\nExample:\r\n\r\n```\r\n<protocols>\r\n    <http>\r\n        <type>http</type>\r\n        <listen>\r\n            <host>::</host>\r\n            <port>8081</port>\r\n        </listen>\r\n    </http>\r\n    <http_proxy>\r\n        <type>proxy_v1</type>\r\n        <impl>\r\n            <type>http</type>\r\n        </impl>\r\n        <listen>\r\n            <host>::</host>\r\n            <port>8081</port>\r\n        </listen>\r\n        <default_database>test</default_database>\r\n    </http_proxy>\r\n...\r\n```\r\n\r\n**Details**\r\n\r\nOld-style configuration should remain to be available.\r\nThe global listen_host and listen_port configuration should be used as a default for the new configuration.\r\nThe types `https`, `tcp_secure` and similar should be available as shortcuts of more explicit configuration (tls on top of http).\r\nThe protocols for embedded Keeper can be specified inside its configuration but with the same style.\r\n\r\n**Notes**\r\n\r\nMySQL and PostgreSQL protocols are using a different approach for TLS. Instead of transparent wrapping of the protocol in TLS after connection, they are doing TLS handshake after negotiating the protocol. It means, they cannot be presented as TLS over an unencrypted protocol.\n",
  "hints_text": "PR (not finished, but code should work) https://github.com/ClickHouse/ClickHouse/pull/27442\nI think there is no point to complicate things with `<impl>` section - we don't need multiple encapsulations since we already have TLS versions for native TCP (tcp_port_secure) and HTTP (https_port) - so the only one encapsulation makes sense - PROXY. So I would propose next structure:\r\n```\r\n<protocols>\r\n    <endpoint_name> # just a name\r\n        <type>http|https|tcp|tcp_secure</type> # protocol type\r\n        <proxy>v1</proxy> # proxy encapsulation, optional, in future can be extended with v2\r\n        <listen> # IP address to listen, can be extended with interface (currently I don't see we support it)\r\n            <host>::</host>\r\n            <port>8081</port>\r\n        </listen>\r\n        <certificate>certificate.crt</certificate> # dedicated certificate for https/tcp_secure, optional\r\n        <private_key>private_key.key</private_key> # private key\r\n        <default_user>root</default_user> # optional\r\n        <default_database>test</default_database> # optional\r\n    </endpoint_name>\r\n    ...\r\n</protocols>\r\n```\nI imagine that the proxy encapsulation can be before or after TLS encapsulation for TCP.\r\nI want to make encapsulations \"first class\" to allow these options, rather than treating \"proxy\" as some special kind of encapsulations.\r\nIt will be not surprising if we will need more types of encapsulations.\nBut what the purpose of PROXY inside of TLS? PROXY meant to relay not only client address to the server but also provide proxy with destination address -how else proxy will know destination address? and TLS is point-to-point encryption - i.e. intermediate proxy server should have access to PROXY record in order to resend package to the destination - if PROXY record is inside TLS then proxy server just can't access it... am I missing something here?\n...unless we want to establish a secure connection between client and proxy... but why?\nProxy just adding this field to let the upstream server know the real address of the client.\r\nI also don't know a use case of TLS on top of Proxy on top of TCP. But if we will make it really composable, it will be better.\nI only have some vague vision of what other protocol encapsulations we may need.\r\nHere is one more or less practical example: https://github.com/ClickHouse/ClickHouse/issues/29378#issuecomment-943688907\r\n\nbut it's not only to let the upstream server know client's address - consider next:\r\n```\r\nclient ---> proxy ---> server\r\n```\r\n1. client is sending packet to proxy - which means destination address in IP header is proxy's - and in order to relay information to proxy to which destination this packet should be delivered, DATA  section of this packet contains PROXY record with destination address\r\n2. proxy receives packet from client, extracts destination address from PROXY record and resend this packet to the server - this time destination address in IP header is server's\r\n3. server receives packet from proxy - which means source address in IP header is proxy's - in order to restore client's address server extract it from PROXY record\r\n\r\nit's how I understand it works - am I mistaken somehow?\nReport on issue investigation.\r\nFirst of all let me state results of our discussion. It was clarified that there can be cases of any kind of PROXY-TLS encapsulations - it can be TLS wrapper over PROXY as well as PROXY over TLS. So it makes sense to have configuration flexible enough to implement this.\r\n\r\nNow about possible implementation.\r\nCurrently we are using Poco library for network communication with underlying BoringSSL for security layer. Poco implements TLS layer through subclassing StreamSocket to SecureStreamSocket - such architecture does not allow encapsulation of data streams - i.e. it's impossible to make TLS over TLS - i.e. TLS either enabled on the stream or disabled. So, with current architecture initially proposed configuration structure (which implies free encapsulation of protocols - including TLS over TLS) is impossible to achieve. However there is another avenue I think we can pursue if we decide to invest efforts for implementation - Poco provides SocketStream class which is an extension of standard IO stream on top of StreamSocket - which means that TLS can be implemented as an IO filter and therefore chained with any other filters including itself. Currently I'm not sure how hard it is to implement - it will involve dealing with OpenSSL API (which BoringSSL is fork of) - which is quite cumbersome to use...\r\n\r\n@alexey-milovidov what do you think? should we restrict encapsulation? or let's try to implement streaming on top of socket?\nNo need to try making TLS over TLS work (no practical sense), but it still makes sense to make our configuration look like it is just a wrapper.",
  "created_at": "2022-09-11T22:09:19Z",
  "modified_files": [
    "programs/server/Server.cpp",
    "programs/server/Server.h",
    "src/Functions/FunctionShowCertificate.h",
    "src/Interpreters/ClientInfo.h",
    "src/Interpreters/Session.cpp",
    "src/Interpreters/Session.h",
    "b/src/Server/ProxyV1Handler.cpp",
    "b/src/Server/ProxyV1Handler.h",
    "b/src/Server/ProxyV1HandlerFactory.h",
    "src/Server/TCPHandler.cpp",
    "src/Server/TCPHandler.h",
    "src/Server/TCPHandlerFactory.h",
    "b/src/Server/TCPProtocolStackData.h",
    "b/src/Server/TCPProtocolStackFactory.h",
    "b/src/Server/TCPProtocolStackHandler.h",
    "src/Server/TCPServerConnectionFactory.h",
    "b/src/Server/TLSHandler.h",
    "b/src/Server/TLSHandlerFactory.h"
  ],
  "modified_test_files": [
    "tests/integration/helpers/client.py",
    "b/tests/integration/test_composable_protocols/configs/client.xml",
    "b/tests/integration/test_composable_protocols/configs/config.xml",
    "b/tests/integration/test_composable_protocols/configs/server.crt",
    "b/tests/integration/test_composable_protocols/configs/server.key",
    "b/tests/integration/test_composable_protocols/configs/users.xml",
    "b/tests/integration/test_composable_protocols/test.py"
  ]
}