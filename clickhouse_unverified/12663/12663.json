{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12663,
  "instance_id": "ClickHouse__ClickHouse-12663",
  "issue_numbers": [
    "12293"
  ],
  "base_commit": "b86248a57a56247d091871061ba9139cd8c08647",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 3cd72b7825da..88758dc50fdf 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -323,7 +323,8 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingLogsLevel, send_logs_level, LogsLevel::fatal, \"Send server text logs with specified minimum level to client. Valid values: 'trace', 'debug', 'information', 'warning', 'error', 'fatal', 'none'\", 0) \\\n     M(SettingBool, enable_optimize_predicate_expression, 1, \"If it is set to true, optimize predicates to subqueries.\", 0) \\\n     M(SettingBool, enable_optimize_predicate_expression_to_final_subquery, 1, \"Allow push predicate to final subquery.\", 0) \\\n-    \\\n+    M(SettingBool, allow_push_predicate_when_subquery_contains_with, 1, \"Allows push predicate when subquery contains WITH clause\", 0) \\\n+\\\n     M(SettingUInt64, low_cardinality_max_dictionary_size, 8192, \"Maximum size (in rows) of shared global dictionary for LowCardinality type.\", 0) \\\n     M(SettingBool, low_cardinality_use_single_dictionary_for_part, false, \"LowCardinality type serialization setting. If is true, than will use additional keys when global dictionary overflows. Otherwise, will create several shared dictionaries.\", 0) \\\n     M(SettingBool, decimal_check_overflow, true, \"Check overflow of decimal arithmetic/comparison operations\", 0) \\\ndiff --git a/src/Interpreters/PredicateExpressionsOptimizer.cpp b/src/Interpreters/PredicateExpressionsOptimizer.cpp\nindex fea0228e3fe3..3915a0f7f430 100644\n--- a/src/Interpreters/PredicateExpressionsOptimizer.cpp\n+++ b/src/Interpreters/PredicateExpressionsOptimizer.cpp\n@@ -21,6 +21,7 @@ PredicateExpressionsOptimizer::PredicateExpressionsOptimizer(\n     const Context & context_, const TablesWithColumns & tables_with_columns_, const Settings & settings)\n     : enable_optimize_predicate_expression(settings.enable_optimize_predicate_expression)\n     , enable_optimize_predicate_expression_to_final_subquery(settings.enable_optimize_predicate_expression_to_final_subquery)\n+    , allow_push_predicate_when_subquery_contains_with(settings.allow_push_predicate_when_subquery_contains_with)\n     , context(context_)\n     , tables_with_columns(tables_with_columns_)\n {\n@@ -151,7 +152,8 @@ bool PredicateExpressionsOptimizer::tryRewritePredicatesToTable(ASTPtr & table_e\n     if (!table_predicates.empty())\n     {\n         auto optimize_final = enable_optimize_predicate_expression_to_final_subquery;\n-        PredicateRewriteVisitor::Data data(context, table_predicates, std::move(table_columns), optimize_final);\n+        auto optimize_with = allow_push_predicate_when_subquery_contains_with;\n+        PredicateRewriteVisitor::Data data(context, table_predicates, std::move(table_columns), optimize_final, optimize_with);\n \n         PredicateRewriteVisitor(data).visit(table_element);\n         return data.is_rewrite;\ndiff --git a/src/Interpreters/PredicateExpressionsOptimizer.h b/src/Interpreters/PredicateExpressionsOptimizer.h\nindex f555c68020e8..8cceda931641 100644\n--- a/src/Interpreters/PredicateExpressionsOptimizer.h\n+++ b/src/Interpreters/PredicateExpressionsOptimizer.h\n@@ -25,6 +25,7 @@ class PredicateExpressionsOptimizer\n private:\n     const bool enable_optimize_predicate_expression;\n     const bool enable_optimize_predicate_expression_to_final_subquery;\n+    const bool allow_push_predicate_when_subquery_contains_with;\n     const Context & context;\n     const TablesWithColumns & tables_with_columns;\n \ndiff --git a/src/Interpreters/PredicateRewriteVisitor.cpp b/src/Interpreters/PredicateRewriteVisitor.cpp\nindex 2a4bd4c1fd29..9795675bcc8a 100644\n--- a/src/Interpreters/PredicateRewriteVisitor.cpp\n+++ b/src/Interpreters/PredicateRewriteVisitor.cpp\n@@ -17,8 +17,8 @@ namespace DB\n {\n \n PredicateRewriteVisitorData::PredicateRewriteVisitorData(\n-    const Context & context_, const ASTs & predicates_, Names && column_names_, bool optimize_final_)\n-    : context(context_), predicates(predicates_), column_names(column_names_), optimize_final(optimize_final_)\n+    const Context & context_, const ASTs & predicates_, Names && column_names_, bool optimize_final_, bool optimize_with_)\n+    : context(context_), predicates(predicates_), column_names(column_names_), optimize_final(optimize_final_), optimize_with(optimize_with_)\n {\n }\n \n@@ -85,7 +85,8 @@ static void cleanAliasAndCollectIdentifiers(ASTPtr & predicate, std::vector<ASTI\n bool PredicateRewriteVisitorData::rewriteSubquery(ASTSelectQuery & subquery, const Names & outer_columns, const Names & inner_columns)\n {\n     if ((!optimize_final && subquery.final())\n-        || subquery.with() || subquery.withFill()\n+        || (!optimize_with && subquery.with())\n+        || subquery.withFill()\n         || subquery.limitBy() || subquery.limitLength()\n         || hasStatefulFunction(subquery.select(), context))\n         return false;\ndiff --git a/src/Interpreters/PredicateRewriteVisitor.h b/src/Interpreters/PredicateRewriteVisitor.h\nindex fa25381f4b95..02c8b9ca422c 100644\n--- a/src/Interpreters/PredicateRewriteVisitor.h\n+++ b/src/Interpreters/PredicateRewriteVisitor.h\n@@ -24,13 +24,14 @@ class PredicateRewriteVisitorData\n         return true;\n     }\n \n-    PredicateRewriteVisitorData(const Context & context_, const ASTs & predicates_, Names && column_names_, bool optimize_final_);\n+    PredicateRewriteVisitorData(const Context & context_, const ASTs & predicates_, Names && column_names_, bool optimize_final_, bool optimize_with_);\n \n private:\n     const Context & context;\n     const ASTs & predicates;\n     const Names column_names;\n     bool optimize_final;\n+    bool optimize_with;\n \n     void visitFirstInternalSelect(ASTSelectQuery & select_query, ASTPtr &);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.reference b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.reference\nnew file mode 100644\nindex 000000000000..a2ee0336191b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.reference\n@@ -0,0 +1,15 @@\n+999\t1998\n+999\t1998\n+SELECT \n+    number,\n+    square_number\n+FROM \n+(\n+    WITH number * 2 AS square_number\n+    SELECT \n+        number,\n+        square_number\n+    FROM numbers_indexed\n+    WHERE number = 999\n+) AS squares\n+WHERE number = 999\ndiff --git a/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.sql b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.sql\nnew file mode 100644\nindex 000000000000..cf3307205e0c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.sql\n@@ -0,0 +1,17 @@\n+DROP TABLE IF EXISTS numbers_indexed;\n+DROP TABLE IF EXISTS squares;\n+\n+CREATE TABLE numbers_indexed Engine=MergeTree ORDER BY number PARTITION BY bitShiftRight(number,8) SETTINGS index_granularity=8 AS SELECT * FROM numbers(16384);\n+\n+CREATE VIEW squares AS WITH number*2 AS square_number SELECT number, square_number FROM numbers_indexed;\n+\n+SET max_rows_to_read=8, read_overflow_mode='throw';\n+\n+WITH number * 2 AS square_number SELECT number, square_number FROM numbers_indexed WHERE number = 999;\n+\n+SELECT * FROM squares WHERE number = 999;\n+\n+EXPLAIN SYNTAX SELECT number, square_number FROM ( WITH number * 2 AS square_number SELECT number, square_number FROM numbers_indexed) AS squares WHERE number = 999;\n+\n+DROP TABLE IF EXISTS squares;\n+DROP TABLE IF EXISTS numbers_indexed;\n",
  "problem_statement": "Predicate push down for views containing WITH clause.\n```\r\ndrop table IF EXISTS numbers_indexed;\r\ndrop table IF EXISTS squares;\r\n\r\ncreate table numbers_indexed Engine=MergeTree ORDER BY number PARTITION BY bitShiftRight(number,8) SETTINGS index_granularity=8 AS SELECT * FROM numbers(16384); \r\n\r\nCREATE VIEW squares AS WITH number*2 AS square_number SELECT number, square_number FROM numbers_indexed;\r\n\r\nSET max_rows_to_read=8, read_overflow_mode='throw';\r\n\r\n-- ok\r\nWITH number*2 AS square_number SELECT number, square_number FROM numbers_indexed WHERE number = 999;\r\n\r\n-- fail\r\nSELECT * FROM squares WHERE number = 999;\r\n```\n",
  "hints_text": "CC @zhang2014 \nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Interpreters/PredicateRewriteVisitor.cpp#L88\r\n\r\nIs expected, but i thought maybe we could remove it.\nI though about it and didnt find any obvious use cases when it can lead to problems. Do you know some? \nAlso may be we should have a possibility to push down predicates somehow in other cases which are currently forbidden (final, limit etc).\r\n\r\nEither by special setting (push the responsibility to the user) either by implementing smth like prewhere for views, either by distinguishing which column are real and not affected by any limit / final etc. (last one sounds complicated) \nWe could have troubles with `prefer_alias_to_column_name` logic if we enable it. Probably we need some investigation here.",
  "created_at": "2020-07-22T11:58:37Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Interpreters/PredicateExpressionsOptimizer.cpp",
    "src/Interpreters/PredicateExpressionsOptimizer.h",
    "src/Interpreters/PredicateRewriteVisitor.cpp",
    "src/Interpreters/PredicateRewriteVisitor.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.reference",
    "b/tests/queries/0_stateless/01414_push_predicate_when_contains_with_clause.sql"
  ]
}