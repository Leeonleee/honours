{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71537,
  "instance_id": "ClickHouse__ClickHouse-71537",
  "issue_numbers": [
    "70802"
  ],
  "base_commit": "787cf7db896201bbecb3b5ae2e5d7b96082e925a",
  "patch": "diff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\nindex e147ad68e406..0ddea7e4eeaa 100644\n--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n@@ -1,18 +1,16 @@\n #include <Analyzer/Passes/LogicalExpressionOptimizerPass.h>\n \n-#include <Functions/FunctionFactory.h>\n-\n-#include <Analyzer/InDepthQueryTreeVisitor.h>\n-#include <Analyzer/FunctionNode.h>\n #include <Analyzer/ConstantNode.h>\n-#include <Analyzer/JoinNode.h>\n+#include <Analyzer/FunctionNode.h>\n #include <Analyzer/HashUtils.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/JoinNode.h>\n #include <Analyzer/Utils.h>\n #include <Core/Settings.h>\n-\n #include <DataTypes/DataTypeLowCardinality.h>\n-#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n \n namespace DB\n {\n@@ -20,6 +18,7 @@ namespace Setting\n {\n     extern const SettingsUInt64 optimize_min_equality_disjunction_chain_length;\n     extern const SettingsUInt64 optimize_min_inequality_conjunction_chain_length;\n+    extern const SettingsBool optimize_extract_common_expressions;\n }\n \n namespace ErrorCodes\n@@ -173,13 +172,303 @@ bool isTwoArgumentsFromDifferentSides(const FunctionNode & node_function, const\n            (first_src->isEqual(rhs_join) && second_src->isEqual(lhs_join));\n }\n \n+void insertIfNotPresentInSet(QueryTreeNodePtrWithHashSet& set, QueryTreeNodes &nodes, QueryTreeNodePtr node)\n+{\n+    const auto [_, inserted] = set.emplace(node);\n+    if (inserted)\n+        nodes.push_back(std::move(node));\n+}\n+\n+// Returns the flattened AND/OR node if the passed-in node can be flattened. Doesn't modify the passed-in node.\n+std::shared_ptr<FunctionNode> getFlattenedLogicalExpression(const FunctionNode & node, const ContextPtr & context)\n+{\n+    const auto & function_name = node.getFunctionName();\n+    if (function_name != \"or\" && function_name != \"and\")\n+        return nullptr;\n+\n+    const auto & arguments = node.getArguments().getNodes();\n+    QueryTreeNodes new_arguments;\n+\n+    bool flattened_anything = false;\n+\n+    for (const auto & argument : arguments)\n+    {\n+        auto * maybe_function = argument->as<FunctionNode>();\n+        // If the nested function is not the same, just use it as is\n+        if (!maybe_function || maybe_function->getFunctionName() != function_name)\n+        {\n+            new_arguments.push_back(argument);\n+            continue;\n+        }\n+\n+        flattened_anything = true;\n+\n+        // If the nested function is the same, just lift the its or its flattened form's arguments\n+        auto maybe_flattened = getFlattenedLogicalExpression(*maybe_function, context);\n+        if (maybe_flattened)\n+        {\n+            auto & flattened_arguments = maybe_flattened->getArguments().getNodes();\n+            std::move(flattened_arguments.begin(), flattened_arguments.end(), std::back_inserter(new_arguments));\n+        }\n+        else\n+        {\n+            const auto & nested_arguments = maybe_function->getArguments().getNodes();\n+            std::copy(nested_arguments.begin(), nested_arguments.end(), std::back_inserter(new_arguments));\n+        }\n+    }\n+\n+    // Nothing has changed, let's no create a flattened node\n+    if (!flattened_anything && new_arguments.size() == arguments.size())\n+        return {};\n+\n+    auto flattened = std::make_shared<FunctionNode>(function_name);\n+\n+    flattened->getArguments().getNodes() = std::move(new_arguments);\n+\n+    resolveOrdinaryFunctionNodeByName(*flattened, function_name, context);\n+\n+    return flattened;\n+}\n+\n+struct CommonExpressionExtractionResult\n+{\n+    // new_node: if the new node is not empty, then it contains the new node, otherwise nullptr\n+    // common_expressions: the extracted common expressions. The new expressions can be created\n+    // as the conjunction of new_node and the nodes in common_expressions. It is guaranteed that\n+    // the common expressions are deduplicated.\n+    // Examples:\n+    //   Input: (A & B & C) | (A & D & E)\n+    //   Result: new_node = (B & C) | (D & E), common_expressions = {A}\n+    //\n+    //   Input: (A & B) | (A & B)\n+    //   Result: new_node = nullptr, common_expressions = {A, B}\n+    //\n+    //   This is a special case: A & B & C is a subset of A & B, thus the conjunction of extracted\n+    //   expressions is equivalent with the passed-in expression, we have to discard C. With C the\n+    //   new expression would be more restrictive.\n+    //   Input: (A & B) | (A & B & C)\n+    //   Result: new_node = nullptr, common_expressions = {A, B}\n+    QueryTreeNodePtr new_node;\n+    QueryTreeNodes common_expressions;\n+};\n+\n+std::optional<CommonExpressionExtractionResult> tryExtractCommonExpressions(const QueryTreeNodePtr & node, const ContextPtr & context)\n+{\n+    auto * or_node = node->as<FunctionNode>();\n+    if (!or_node || or_node->getFunctionName() != \"or\")\n+        return {}; // the optimization can only be done on or nodes\n+\n+    auto flattened_or_node = getFlattenedLogicalExpression(*or_node, context);\n+    if (flattened_or_node)\n+        or_node = flattened_or_node.get();\n+\n+    auto & or_argument_nodes = or_node->getArguments().getNodes();\n+\n+    chassert(or_argument_nodes.size() > 1);\n+\n+    bool first_argument = true;\n+    QueryTreeNodePtrWithHashSet common_exprs_set;\n+    QueryTreeNodes common_exprs;\n+    QueryTreeNodePtrWithHashMap<QueryTreeNodePtr> flattened_ands;\n+\n+    for (auto & maybe_and_node : or_argument_nodes)\n+    {\n+        auto * and_node = maybe_and_node->as<FunctionNode>();\n+        if (!and_node || and_node->getFunctionName() != \"and\")\n+            return {}; // one of the nodes is not an \"AND\", thus there is no common expression to extract\n+\n+        auto flattened_and_node = getFlattenedLogicalExpression(*and_node, context);\n+        if (flattened_and_node)\n+        {\n+            flattened_ands.emplace(maybe_and_node, flattened_and_node);\n+            and_node = flattened_and_node.get();\n+        }\n+\n+        if (first_argument)\n+        {\n+            auto & current_arguments = and_node->getArguments().getNodes();\n+            common_exprs.reserve(current_arguments.size());\n+\n+            for (auto & and_argument : current_arguments)\n+                insertIfNotPresentInSet(common_exprs_set, common_exprs, and_argument);\n+\n+            first_argument = false;\n+        }\n+        else\n+        {\n+            QueryTreeNodePtrWithHashSet new_common_exprs_set;\n+            QueryTreeNodes new_common_exprs;\n+\n+            for (auto & and_argument : and_node->getArguments())\n+            {\n+                if (common_exprs_set.contains(and_argument))\n+                    insertIfNotPresentInSet(new_common_exprs_set, new_common_exprs, and_argument);\n+            }\n+\n+            common_exprs_set = std::move(new_common_exprs_set);\n+            common_exprs = std::move(new_common_exprs);\n+\n+            if (common_exprs.empty())\n+                return {}; // There are no common expressions\n+        }\n+    }\n+\n+    chassert(!common_exprs.empty());\n+\n+    QueryTreeNodePtrWithHashSet new_or_arguments_set;\n+    QueryTreeNodes new_or_arguments;\n+    bool has_completely_extracted_and_expression = false;\n+\n+    for (auto & or_argument : or_argument_nodes)\n+    {\n+        if (auto it = flattened_ands.find(or_argument); it != flattened_ands.end())\n+            or_argument = it->second;\n+\n+        // Avoid changing the original tree, it might be used later\n+        const auto & and_node = or_argument->as<FunctionNode &>();\n+        const auto & and_arguments = and_node.getArguments().getNodes();\n+\n+        QueryTreeNodes filtered_and_arguments;\n+        filtered_and_arguments.reserve(and_arguments.size());\n+        std::copy_if(\n+            and_arguments.begin(),\n+            and_arguments.end(),\n+            std::back_inserter(filtered_and_arguments),\n+            [&common_exprs_set](const QueryTreeNodePtr & ptr) { return !common_exprs_set.contains(ptr); });\n+\n+        if (filtered_and_arguments.empty())\n+        {\n+            has_completely_extracted_and_expression = true;\n+            // As we will discard new_or_arguments, no need for further processing\n+            break;\n+        }\n+        else if (filtered_and_arguments.size() == 1)\n+        {\n+            insertIfNotPresentInSet(new_or_arguments_set, new_or_arguments, std::move(filtered_and_arguments.front()));\n+        }\n+        else\n+        {\n+            auto new_and_node = std::make_shared<FunctionNode>(\"and\");\n+            new_and_node->getArguments().getNodes() = std::move(filtered_and_arguments);\n+            resolveOrdinaryFunctionNodeByName(*new_and_node, \"and\", context);\n+\n+            insertIfNotPresentInSet(new_or_arguments_set, new_or_arguments, std::move(new_and_node));\n+        }\n+    }\n+\n+    // If all the arguments of the OR expression is eliminated or one argument is completely eliminated, there is no need for new node.\n+    if (new_or_arguments.empty() || has_completely_extracted_and_expression)\n+        return CommonExpressionExtractionResult{nullptr, std::move(common_exprs)};\n+\n+    // There are at least two arguments in the passed-in OR expression, thus we either completely eliminated at least one arguments, or there should be at least 2 remaining arguments.\n+    // The complete elimination is handled above, so at this point we can be sure there are at least 2 arguments.\n+    chassert(new_or_arguments.size() >= 2);\n+\n+    auto new_or_node = std::make_shared<FunctionNode>(\"or\");\n+    new_or_node->getArguments().getNodes() = std::move(new_or_arguments);\n+\n+    resolveOrdinaryFunctionNodeByName(*new_or_node, \"or\", context);\n+\n+    return CommonExpressionExtractionResult{new_or_node, common_exprs};\n+}\n+\n+void tryOptimizeCommonExpressionsInOr(QueryTreeNodePtr & node, const ContextPtr & context)\n+{\n+    auto * root_node = node->as<FunctionNode>();\n+    chassert(root_node && root_node->getFunctionName() == \"or\");\n+\n+    QueryTreeNodePtr new_root_node{};\n+\n+    if (auto maybe_result = tryExtractCommonExpressions(node, context); maybe_result.has_value())\n+    {\n+        auto & result = *maybe_result;\n+        QueryTreeNodes new_root_arguments = std::move(result.common_expressions);\n+        if (result.new_node != nullptr)\n+            new_root_arguments.push_back(std::move(result.new_node));\n+\n+        if (new_root_arguments.size() == 1)\n+        {\n+            new_root_node = std::move(new_root_arguments.front());\n+        }\n+        else\n+        {\n+            // The OR expression must be replaced by and AND expression that will contain the common expressions\n+            // and the new_node, if it is not nullptr.\n+            auto new_function_node = std::make_shared<FunctionNode>(\"and\");\n+            new_function_node->getArguments().getNodes() = std::move(new_root_arguments);\n+            auto and_function_resolver = FunctionFactory::instance().get(\"and\", context);\n+            new_function_node->resolveAsFunction(and_function_resolver);\n+            new_root_node = std::move(new_function_node);\n+        }\n+\n+        if (!new_root_node->getResultType()->equals(*node->getResultType()))\n+            new_root_node = buildCastFunction(new_root_node, node->getResultType(), context);\n+        node = std::move(new_root_node);\n+    }\n+}\n+\n+void tryOptimizeCommonExpressionsInAnd(QueryTreeNodePtr & node, const ContextPtr & context)\n+{\n+    auto * root_node = node->as<FunctionNode>();\n+    chassert(root_node && root_node->getFunctionName() == \"and\");\n+\n+    QueryTreeNodePtrWithHashSet new_top_level_arguments_set;\n+    QueryTreeNodes new_top_level_arguments;\n+\n+    auto insert_possible_new_top_level_arg = [&new_top_level_arguments_set, &new_top_level_arguments](QueryTreeNodePtr node_to_insert)\n+    {\n+        insertIfNotPresentInSet(new_top_level_arguments_set, new_top_level_arguments, std::move(node_to_insert));\n+    };\n+    auto extracted_something = false;\n+\n+    for (const auto & argument : root_node->getArguments())\n+    {\n+        if (auto maybe_result = tryExtractCommonExpressions(argument, context))\n+        {\n+            extracted_something = true;\n+            auto & result = *maybe_result;\n+            if (result.new_node != nullptr)\n+                insert_possible_new_top_level_arg(std::move(result.new_node));\n+            for (auto& common_expr: result.common_expressions)\n+                insert_possible_new_top_level_arg(std::move(common_expr));\n+        }\n+        else\n+        {\n+            insert_possible_new_top_level_arg(argument);\n+        }\n+    }\n+\n+    if (!extracted_something)\n+        return;\n+\n+    auto and_function_node = std::make_shared<FunctionNode>(\"and\");\n+    and_function_node->getArguments().getNodes() = std::move(new_top_level_arguments);\n+    auto and_function_resolver = FunctionFactory::instance().get(\"and\", context);\n+    and_function_node->resolveAsFunction(and_function_resolver);\n+    QueryTreeNodePtr new_root_node = and_function_node;\n+\n+    if (!new_root_node->getResultType()->equals(*node->getResultType()))\n+        new_root_node = buildCastFunction(new_root_node, node->getResultType(), context);\n+    node = std::move(new_root_node);\n+}\n+\n+void tryOptimizeCommonExpressions(QueryTreeNodePtr & node, FunctionNode& function_node, const ContextPtr & context)\n+{\n+    chassert(node.get() == &function_node);\n+    if (function_node.getFunctionName() == \"or\")\n+        tryOptimizeCommonExpressionsInOr(node, context);\n+    else if (function_node.getFunctionName() == \"and\")\n+        tryOptimizeCommonExpressionsInAnd(node, context);\n+}\n+\n+\n /// Visitor that optimizes logical expressions _only_ in JOIN ON section\n class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithContext<JoinOnLogicalExpressionOptimizerVisitor>\n {\n public:\n     using Base = InDepthQueryTreeVisitorWithContext<JoinOnLogicalExpressionOptimizerVisitor>;\n \n-    explicit JoinOnLogicalExpressionOptimizerVisitor(const JoinNode * join_node_, ContextPtr context)\n+    explicit JoinOnLogicalExpressionOptimizerVisitor(const JoinNode & join_node_, ContextPtr context)\n         : Base(std::move(context))\n         , join_node(join_node_)\n     {}\n@@ -223,15 +512,23 @@ class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWi\n \n     void leaveImpl(QueryTreeNodePtr & node)\n     {\n-        if (!need_rerun_resolve)\n+        auto * function_node = node->as<FunctionNode>();\n+\n+        if (!function_node)\n             return;\n \n-        if (auto * function_node = node->as<FunctionNode>())\n+        if (need_rerun_resolve)\n             rerunFunctionResolve(function_node, getContext());\n+\n+        // The optimization only makes sense on the top level\n+        if (node != join_node.getJoinExpression() || !getSettings()[Setting::optimize_extract_common_expressions])\n+            return;\n+\n+        tryOptimizeCommonExpressions(node, *function_node, getContext());\n     }\n \n private:\n-    const JoinNode * join_node;\n+    const JoinNode & join_node;\n     bool need_rerun_resolve = false;\n \n     /// Returns optimized node or nullptr if nothing have been changed\n@@ -274,7 +571,7 @@ class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWi\n             const auto & func_name = argument_function->getFunctionName();\n             if (func_name == \"equals\" || func_name == \"isNotDistinctFrom\")\n             {\n-                if (isTwoArgumentsFromDifferentSides(*argument_function, *join_node))\n+                if (isTwoArgumentsFromDifferentSides(*argument_function, join_node))\n                     equals_functions_indices.push_back(or_operands.size() - 1);\n             }\n             else if (func_name == \"and\")\n@@ -319,7 +616,7 @@ class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWi\n                         is_anything_changed = true;\n                         or_operands.pop_back();\n                         or_operands.push_back(equals_function);\n-                        if (isTwoArgumentsFromDifferentSides(equals_function->as<FunctionNode &>(), *join_node))\n+                        if (isTwoArgumentsFromDifferentSides(equals_function->as<FunctionNode &>(), join_node))\n                             equals_functions_indices.push_back(or_operands.size() - 1);\n                     }\n                 }\n@@ -385,7 +682,7 @@ class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWi\n                     }\n                     else if (and_arguments.size() == 1)\n                     {\n-                        /// Replace AND with a single argument with the argument itself\n+                        /// Replace AND with a single argument by the argument itself\n                         new_or_operands.emplace_back(and_arguments[0]);\n                     }\n                 }\n@@ -405,10 +702,9 @@ class JoinOnLogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWi\n             return new_or_operands[0];\n \n         /// Rebuild OR function\n-        auto or_function_resolver = FunctionFactory::instance().get(\"or\", context);\n         auto function_node = std::make_shared<FunctionNode>(\"or\");\n         function_node->getArguments().getNodes() = std::move(new_or_operands);\n-        function_node->resolveAsFunction(or_function_resolver);\n+        resolveOrdinaryFunctionNodeByName(*function_node, \"or\", context);\n         return function_node;\n     }\n };\n@@ -429,7 +725,7 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n             /// Operator <=> is not supported outside of JOIN ON section\n             if (join_node->hasJoinExpression())\n             {\n-                JoinOnLogicalExpressionOptimizerVisitor join_on_visitor(join_node, getContext());\n+                JoinOnLogicalExpressionOptimizerVisitor join_on_visitor(*join_node, getContext());\n                 join_on_visitor.visit(join_node->getJoinExpression());\n             }\n             return;\n@@ -459,6 +755,31 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n         }\n     }\n \n+    void leaveImpl(QueryTreeNodePtr & node)\n+    {\n+        if (!getSettings()[Setting::optimize_extract_common_expressions])\n+            return;\n+\n+        auto * query_node = node->as<QueryNode>();\n+        if (!query_node)\n+            return;\n+\n+        const auto try_optimize_if_function = [this](QueryTreeNodePtr & maybe_node)\n+        {\n+            if (!maybe_node)\n+                return;\n+            auto * function_node = maybe_node->as<FunctionNode>();\n+            if (!function_node)\n+                return;\n+            tryOptimizeCommonExpressions(maybe_node, *function_node, getContext());\n+        };\n+\n+        try_optimize_if_function(query_node->getWhere());\n+        try_optimize_if_function(query_node->getPrewhere());\n+        try_optimize_if_function(query_node->getHaving());\n+        try_optimize_if_function(query_node->getQualify());\n+    }\n+\n private:\n     void tryOptimizeAndEqualsNotEqualsChain(QueryTreeNodePtr & node)\n     {\ndiff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\nindex 5f109993f3f1..76bb5e6b4326 100644\n--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\n+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\n@@ -98,7 +98,7 @@ namespace DB\n  * -------------------------------\n  *\n  * 7. Remove redundant equality checks on boolean functions.\n- *  - these requndant checks cause the primary index to not be used when if the query involves any primary key columns\n+ *  - these redundant checks cause the primary index to not be used when if the query involves any primary key columns\n  * -------------------------------\n  * SELECT * FROM t1 WHERE a IN (n) = 1\n  * SELECT * FROM t1 WHERE a IN (n) = 0\n@@ -108,6 +108,22 @@ namespace DB\n  * SELECT * FROM t1 WHERE a IN (n)\n  * SELECT * FROM t1 WHERE NOT a IN (n)\n  * -------------------------------\n+ *\n+ * 8. Extract common subexpressions from AND expressions of a single OR expression only in WHERE and ON expressions.\n+ * If possible, AND and OR expressions will be flattened during performing this.\n+ * This might break some lazily evaluated expressions, but this optimization can be turned off by optimize_extract_common_expressions = 0.\n+ * -------------------------------\n+ * SELECT * FROM t1 WHERE a AND ((b AND c) OR (b AND d) OR (b AND e))\n+ * SELECT * FROM t1 WHERE a AND ((b AND c) OR ((b AND d) OR (b AND e))) -- needs flattening\n+ * SELECT * FROM t1 WHERE (a AND b AND c) OR (a AND b AND d)\n+ * SELECT * FROM t1 WHERE (a AND b) OR (a AND b AND c)\n+ *\n+ * will be transformed into\n+ *\n+ * SELECT * FROM t1 WHERE a AND b AND (c OR d AND e)\n+ * SELECT * FROM t1 WHERE a AND b AND (c OR d AND e)\n+ * SELECT * FROM t1 WHERE a AND b AND (c OR d)\n+ * SELECT * FROM t1 WHERE a AND b\n  */\n \n class LogicalExpressionOptimizerPass final : public IQueryTreePass\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex 5392a7e7aa1d..a9887aa92af5 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5760,6 +5760,11 @@ If enabled, MongoDB tables will return an error when a MongoDB query cannot be b\n Allow writing simple SELECT queries without the leading SELECT keyword, which makes it simple for calculator-style usage, e.g. `1 + 2` becomes a valid query.\n \n In `clickhouse-local` it is enabled by default and can be explicitly disabled.\n+)\", 0) \\\n+    DECLARE(Bool, optimize_extract_common_expressions, false, R\"(\n+Allow extracting common expressions from disjunctions in WHERE, PREWHERE, ON, HAVING and QUALIFY expressions. A logical expression like `(A AND B) OR (A AND C)` can be rewritten to `A AND (B OR C)`, which might help to utilize:\n+- indices in simple filtering expressions\n+- cross to inner join optimization\n )\", 0) \\\n     DECLARE(Bool, push_external_roles_in_interserver_queries, true, R\"(\n Enable pushing user roles from originator to other nodes while performing a query.\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 97353d03c347..dde7ba68228e 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -64,6 +64,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n             {\"max_size_to_preallocate_for_aggregation\", 100'000'000, 1'000'000'000'000, \"Enable optimisation for bigger tables.\"},\n             {\"max_size_to_preallocate_for_joins\", 100'000'000, 1'000'000'000'000, \"Enable optimisation for bigger tables.\"},\n             {\"max_bytes_ratio_before_external_group_by\", 0., 0., \"New setting.\"},\n+            {\"optimize_extract_common_expressions\", false, false, \"Introduce setting to optimize WHERE, PREWHERE, ON, HAVING and QUALIFY expressions by extracting common expressions out from disjunction of conjunctions.\"},\n             {\"object_storage_remove_recursive_file_limit\", 0, 1000, \"Added new setting to limit number of files stored in memory while removing from object storage. Zero value means unlimited.\"},\n             {\"max_bytes_ratio_before_external_sort\", 0., 0., \"New setting.\"},\n             {\"use_async_executor_for_materialized_views\", false, false, \"New setting.\"},\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03262_common_expression_optimization.reference b/tests/queries/0_stateless/03262_common_expression_optimization.reference\nnew file mode 100644\nindex 000000000000..70da99ae4133\n--- /dev/null\n+++ b/tests/queries/0_stateless/03262_common_expression_optimization.reference\n@@ -0,0 +1,1193 @@\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: or, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: A, result_type: UInt8, source_id: 3\n+                COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 10, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 11, nodes: 2\n+                COLUMN id: 8, column_name: A, result_type: UInt8, source_id: 3\n+                COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+  SETTINGS optimize_extract_common_expressions=0\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE (__table1.A AND __table1.B) OR (__table1.A AND __table1.C)\n+SETTINGS optimize_extract_common_expressions = 0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: C, result_type: UInt8, source_id: 3\n+  SETTINGS optimize_extract_common_expressions=1\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND (__table1.B OR __table1.C)\n+SETTINGS optimize_extract_common_expressions = 1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          COLUMN id: 7, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 8, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND __table1.B AND __table1.C\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-8476148063717219538\t1\t1\t1\t1\t1\t1\n+-8387418414841552371\t1\t1\t1\t1\t0\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-8476148063717219538\t1\t1\t1\t1\t1\t1\n+-8387418414841552371\t1\t1\t1\t1\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 4\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: E, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: F, result_type: UInt8, source_id: 3\n+          COLUMN id: 11, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND (__table1.E OR __table1.F) AND __table1.B AND __table1.C\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-8476148063717219538\t1\t1\t1\t1\t1\t1\n+-8387418414841552371\t1\t1\t1\t1\t0\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-8476148063717219538\t1\t1\t1\t1\t1\t1\n+-8387418414841552371\t1\t1\t1\t1\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 4\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: E, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: F, result_type: UInt8, source_id: 3\n+          COLUMN id: 11, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND (__table1.E OR __table1.F) AND __table1.B AND __table1.C\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8757579268243194545\t1\t1\t0\t1\t0\t0\n+-8753962234239378281\t1\t1\t0\t1\t0\t0\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8757579268243194545\t1\t1\t0\t1\t0\t0\n+-8753962234239378281\t1\t1\t0\t1\t0\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 3\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: D, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: E, result_type: UInt8, source_id: 3\n+          COLUMN id: 12, column_name: B, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND (__table1.C OR __table1.D OR __table1.E) AND __table1.B\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8757579268243194545\t1\t1\t0\t1\t0\t0\n+-8753962234239378281\t1\t1\t0\t1\t0\t0\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8757579268243194545\t1\t1\t0\t1\t0\t0\n+-8753962234239378281\t1\t1\t0\t1\t0\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 3\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: D, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: E, result_type: UInt8, source_id: 3\n+          COLUMN id: 12, column_name: B, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND (__table1.C OR __table1.D OR __table1.E) AND __table1.B\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 7, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND __table1.C\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8884339606857089357\t0\t1\t1\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8884339606857089357\t0\t1\t1\t0\t1\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 7, column_name: C, result_type: UInt8, source_id: 3\n+          FUNCTION id: 8, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 9, nodes: 2\n+                COLUMN id: 10, column_name: E, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND __table1.C AND (__table1.E OR __table1.F)\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8884339606857089357\t0\t1\t1\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9027896542766292056\t0\t1\t1\t1\t0\t1\n+-9016286694578688546\t0\t1\t1\t1\t0\t1\n+-9007101892394668722\t0\t1\t1\t0\t0\t1\n+-8971956622356473539\t0\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8884339606857089357\t0\t1\t1\t0\t1\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          COLUMN id: 7, column_name: C, result_type: UInt8, source_id: 3\n+          FUNCTION id: 8, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 9, nodes: 2\n+                COLUMN id: 10, column_name: E, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND __table1.C AND (__table1.E OR __table1.F)\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9034436041280906643\t0\t1\t0\t1\t0\t0\n+-9032227688076112856\t0\t1\t0\t1\t0\t0\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9034436041280906643\t0\t1\t0\t1\t0\t0\n+-9032227688076112856\t0\t1\t0\t1\t0\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 3\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: D, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: E, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND (__table1.C OR __table1.D OR __table1.E)\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9034436041280906643\t0\t1\t0\t1\t0\t0\n+-9032227688076112856\t0\t1\t0\t1\t0\t0\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9034436041280906643\t0\t1\t0\t1\t0\t0\n+-9032227688076112856\t0\t1\t0\t1\t0\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 3\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+                COLUMN id: 10, column_name: D, result_type: UInt8, source_id: 3\n+                COLUMN id: 11, column_name: E, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND (__table1.C OR __table1.D OR __table1.E)\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9154240572955605594\t1\t0\t0\t0\t0\t1\n+-9136706315507142110\t1\t0\t0\t0\t1\t0\n+-9136188450553078231\t0\t1\t0\t0\t0\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9054835338197246193\t1\t0\t0\t0\t1\t0\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9154240572955605594\t1\t0\t0\t0\t0\t1\n+-9136706315507142110\t1\t0\t0\t0\t1\t0\n+-9136188450553078231\t0\t1\t0\t0\t0\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9092546166635132947\t0\t1\t1\t1\t1\t0\n+-9054835338197246193\t1\t0\t0\t0\t1\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: equals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                FUNCTION id: 8, function_name: sipHash64, function_type: ordinary, result_type: UInt64\n+                  ARGUMENTS\n+                    LIST id: 9, nodes: 1\n+                      COLUMN id: 10, column_name: C, result_type: UInt8, source_id: 3\n+                FUNCTION id: 11, function_name: sipHash64, function_type: ordinary, result_type: UInt64\n+                  ARGUMENTS\n+                    LIST id: 12, nodes: 1\n+                      COLUMN id: 13, column_name: D, result_type: UInt8, source_id: 3\n+          FUNCTION id: 14, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 15, nodes: 2\n+                COLUMN id: 16, column_name: A, result_type: UInt8, source_id: 3\n+                COLUMN id: 17, column_name: B, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE (sipHash64(__table1.C) = sipHash64(__table1.D)) AND (__table1.A OR __table1.B)\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9146648809962620241\t0\t0\t1\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+-9118603327247981370\t0\t0\t1\t1\t0\t1\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9146648809962620241\t0\t0\t1\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+-9118603327247981370\t0\t0\t1\t1\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: or, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: A, result_type: UInt8, source_id: 3\n+                COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 10, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 11, nodes: 2\n+                FUNCTION id: 12, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 13, nodes: 2\n+                      COLUMN id: 14, column_name: C, result_type: UInt8, source_id: 3\n+                      COLUMN id: 15, column_name: D, result_type: UInt8, source_id: 3\n+                FUNCTION id: 16, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 17, nodes: 2\n+                      COLUMN id: 18, column_name: E, result_type: UInt8, source_id: 3\n+                      COLUMN id: 19, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE (__table1.A AND __table1.B) OR ((__table1.C AND __table1.D) OR (__table1.E AND __table1.F))\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9146648809962620241\t0\t0\t1\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+-9220160771238933596\t1\t0\t0\t0\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9146648809962620241\t0\t0\t1\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9128210600225023826\t0\t1\t1\t0\t1\t1\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9120901636510510987\t0\t1\t0\t1\t0\t0\n+-9119049435533988608\t1\t0\t0\t0\t1\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: or, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: A, result_type: UInt8, source_id: 3\n+                COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 10, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 11, nodes: 2\n+                FUNCTION id: 12, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 13, nodes: 2\n+                      COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+                      COLUMN id: 14, column_name: D, result_type: UInt8, source_id: 3\n+                FUNCTION id: 15, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 16, nodes: 2\n+                      COLUMN id: 17, column_name: E, result_type: UInt8, source_id: 3\n+                      COLUMN id: 18, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE (__table1.A AND __table1.B) OR ((__table1.B AND __table1.D) OR (__table1.E AND __table1.F))\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-9137658153367139416\t1\t1\t1\t0\t0\t0\n+-9137309194079040284\t1\t1\t1\t0\t0\t0\n+-9121738304623869295\t1\t1\t0\t0\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-9001504240784412840\t1\t1\t0\t0\t1\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 3\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          COLUMN id: 7, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 8, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 9, nodes: 3\n+                COLUMN id: 10, column_name: C, result_type: UInt8, source_id: 3\n+                FUNCTION id: 11, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 12, nodes: 2\n+                      COLUMN id: 13, column_name: E, result_type: UInt8, source_id: 3\n+                      COLUMN id: 13, column_name: E, result_type: UInt8, source_id: 3\n+                FUNCTION id: 14, function_name: and, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 15, nodes: 2\n+                      COLUMN id: 16, column_name: F, result_type: UInt8, source_id: 3\n+                      COLUMN id: 16, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A AND __table1.B AND (__table1.C OR (__table1.E AND __table1.E) OR (__table1.F AND __table1.F))\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8569013057605390975\t1\t1\t0\t1\t0\t1\n+-8548886235737406452\t1\t1\t0\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+-9114056182077943575\t1\t1\t1\t1\t0\t1\n+-8941493636296671386\t1\t1\t1\t1\t1\t1\n+-8816638533025328863\t1\t1\t1\t0\t1\t1\n+-8778069835572290074\t1\t1\t1\t1\t1\t1\n+-8751975391509985483\t1\t1\t1\t0\t1\t1\n+-8699036683208290351\t1\t1\t1\t0\t0\t1\n+-8647725213825146240\t1\t1\t1\t1\t0\t1\n+-8569013057605390975\t1\t1\t0\t1\t0\t1\n+-8548886235737406452\t1\t1\t0\t1\t0\t1\n+-8525570993468372516\t1\t1\t1\t1\t1\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 4\n+          FUNCTION id: 6, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: C, result_type: UInt8, source_id: 3\n+                COLUMN id: 9, column_name: D, result_type: UInt8, source_id: 3\n+          COLUMN id: 10, column_name: A, result_type: UInt8, source_id: 3\n+          COLUMN id: 11, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 12, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 13, nodes: 2\n+                COLUMN id: 14, column_name: E, result_type: UInt8, source_id: 3\n+                COLUMN id: 15, column_name: F, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE (__table1.C OR __table1.D) AND __table1.A AND __table1.B AND (__table1.E OR __table1.F)\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: _CAST, function_type: ordinary, result_type: Nullable(UInt8)\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: B, result_type: UInt8, source_id: 3\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+          CONSTANT id: 10, constant_value: \\'Nullable(UInt8)\\', constant_value_type: String\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE _CAST(__table1.B AND __table1.C, \\'Nullable(UInt8)\\')\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: _CAST, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: x, result_type: Int64, source_id: 3\n+          CONSTANT id: 7, constant_value: \\'UInt8\\', constant_value_type: String\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE _CAST(__table1.x, \\'UInt8\\')\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: Nullable(UInt8)\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: B, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: toNullable, function_type: ordinary, result_type: Nullable(UInt8)\n+            ARGUMENTS\n+              LIST id: 8, nodes: 1\n+                COLUMN id: 9, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.B AND toNullable(__table1.C)\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 4, function_name: or, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 7, function_name: and, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+                FUNCTION id: 10, function_name: or, function_type: ordinary, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 11, nodes: 2\n+                      FUNCTION id: 12, function_name: and, function_type: ordinary, result_type: UInt8\n+                        ARGUMENTS\n+                          LIST id: 13, nodes: 2\n+                            COLUMN id: 14, column_name: C, result_type: UInt8, source_id: 3\n+                            COLUMN id: 15, column_name: D, result_type: UInt8, source_id: 3\n+                      FUNCTION id: 16, function_name: and, function_type: ordinary, result_type: UInt8\n+                        ARGUMENTS\n+                          LIST id: 17, nodes: 2\n+                            COLUMN id: 14, column_name: C, result_type: UInt8, source_id: 3\n+                            COLUMN id: 18, column_name: E, result_type: UInt8, source_id: 3\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+WHERE __table1.A OR (__table1.B AND ((__table1.C AND __table1.D) OR (__table1.C AND __table1.E)))\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9212191261079457524\t0\t0\t1\t0\t1\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9210944775923669427\t0\t1\t1\t1\t0\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9202601338732071287\t0\t1\t1\t1\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9185234005543064629\t0\t1\t1\t0\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9181371158682533758\t0\t1\t1\t1\t0\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9173688614647112626\t0\t0\t1\t0\t0\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9130964659455442087\t0\t1\t1\t1\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9109186410997511387\t0\t1\t1\t0\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9071619989214493680\t0\t1\t1\t0\t1\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9071253360041153133\t0\t1\t1\t1\t0\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9212191261079457524\t0\t0\t1\t0\t1\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9210944775923669427\t0\t1\t1\t1\t0\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9202601338732071287\t0\t1\t1\t1\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9185234005543064629\t0\t1\t1\t0\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9181371158682533758\t0\t1\t1\t1\t0\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9173688614647112626\t0\t0\t1\t0\t0\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9130964659455442087\t0\t1\t1\t1\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9109186410997511387\t0\t1\t1\t0\t1\t1\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9071619989214493680\t0\t1\t1\t0\t1\t0\n+-9222995085389227671\t0\t0\t0\t0\t0\t1\t-9071253360041153133\t0\t1\t1\t1\t0\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    JOIN id: 3, strictness: ALL, kind: INNER\n+      LEFT TABLE EXPRESSION\n+        TABLE id: 4, alias: __table1, table_name: default.x\n+      RIGHT TABLE EXPRESSION\n+        TABLE id: 5, alias: __table2, table_name: default.y\n+      JOIN EXPRESSION\n+        FUNCTION id: 6, function_name: and, function_type: ordinary, result_type: UInt8\n+          ARGUMENTS\n+            LIST id: 7, nodes: 2\n+              FUNCTION id: 8, function_name: equals, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 9, nodes: 2\n+                    COLUMN id: 10, column_name: A, result_type: UInt8, source_id: 4\n+                    COLUMN id: 11, column_name: A, result_type: UInt8, source_id: 5\n+              FUNCTION id: 12, function_name: or, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 13, nodes: 2\n+                    FUNCTION id: 14, function_name: equals, function_type: ordinary, result_type: UInt8\n+                      ARGUMENTS\n+                        LIST id: 15, nodes: 2\n+                          COLUMN id: 16, column_name: B, result_type: UInt8, source_id: 4\n+                          CONSTANT id: 17, constant_value: UInt64_1, constant_value_type: UInt8\n+                    FUNCTION id: 18, function_name: equals, function_type: ordinary, result_type: UInt8\n+                      ARGUMENTS\n+                        LIST id: 19, nodes: 2\n+                          COLUMN id: 20, column_name: C, result_type: UInt8, source_id: 5\n+                          CONSTANT id: 21, constant_value: UInt64_1, constant_value_type: UInt8\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+ALL INNER JOIN default.y AS __table2 ON (__table1.A = __table2.A) AND ((__table1.B = 1) OR (__table2.C = 1))\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count() UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+  JOIN TREE\n+    JOIN id: 3, strictness: ALL, kind: INNER\n+      LEFT TABLE EXPRESSION\n+        TABLE id: 4, alias: __table1, table_name: default.x\n+      RIGHT TABLE EXPRESSION\n+        TABLE id: 5, alias: __table2, table_name: default.y\n+      JOIN EXPRESSION\n+        FUNCTION id: 6, function_name: or, function_type: ordinary, result_type: UInt8\n+          ARGUMENTS\n+            LIST id: 7, nodes: 2\n+              FUNCTION id: 8, function_name: equals, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 9, nodes: 2\n+                    COLUMN id: 10, column_name: A, result_type: UInt8, source_id: 4\n+                    COLUMN id: 11, column_name: A, result_type: UInt8, source_id: 5\n+              FUNCTION id: 12, function_name: and, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 13, nodes: 2\n+                    FUNCTION id: 14, function_name: equals, function_type: ordinary, result_type: UInt8\n+                      ARGUMENTS\n+                        LIST id: 15, nodes: 2\n+                          COLUMN id: 16, column_name: B, result_type: UInt8, source_id: 4\n+                          COLUMN id: 17, column_name: B, result_type: UInt8, source_id: 5\n+                    FUNCTION id: 18, function_name: or, function_type: ordinary, result_type: UInt8\n+                      ARGUMENTS\n+                        LIST id: 19, nodes: 2\n+                          FUNCTION id: 20, function_name: and, function_type: ordinary, result_type: UInt8\n+                            ARGUMENTS\n+                              LIST id: 21, nodes: 2\n+                                FUNCTION id: 22, function_name: equals, function_type: ordinary, result_type: UInt8\n+                                  ARGUMENTS\n+                                    LIST id: 23, nodes: 2\n+                                      COLUMN id: 24, column_name: C, result_type: UInt8, source_id: 4\n+                                      COLUMN id: 25, column_name: C, result_type: UInt8, source_id: 5\n+                                FUNCTION id: 26, function_name: equals, function_type: ordinary, result_type: UInt8\n+                                  ARGUMENTS\n+                                    LIST id: 27, nodes: 2\n+                                      COLUMN id: 28, column_name: D, result_type: UInt8, source_id: 4\n+                                      COLUMN id: 29, column_name: D, result_type: UInt8, source_id: 5\n+                          FUNCTION id: 30, function_name: and, function_type: ordinary, result_type: UInt8\n+                            ARGUMENTS\n+                              LIST id: 31, nodes: 2\n+                                FUNCTION id: 32, function_name: equals, function_type: ordinary, result_type: UInt8\n+                                  ARGUMENTS\n+                                    LIST id: 33, nodes: 2\n+                                      COLUMN id: 34, column_name: C, result_type: UInt8, source_id: 4\n+                                      COLUMN id: 35, column_name: C, result_type: UInt8, source_id: 5\n+                                FUNCTION id: 36, function_name: equals, function_type: ordinary, result_type: UInt8\n+                                  ARGUMENTS\n+                                    LIST id: 37, nodes: 2\n+                                      COLUMN id: 38, column_name: E, result_type: UInt8, source_id: 4\n+                                      COLUMN id: 39, column_name: E, result_type: UInt8, source_id: 5\n+\n+SELECT count() AS `count()`\n+FROM default.x AS __table1\n+ALL INNER JOIN default.y AS __table2 ON (__table1.A = __table2.A) OR ((__table1.B = __table2.B) AND (((__table1.C = __table2.C) AND (__table1.D = __table2.D)) OR ((__table1.C = __table2.C) AND (__table1.E = __table2.E))))\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9194298748734675155\t0\t0\t0\t1\t0\t0\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+-9217261049539683905\t0\t1\t1\t0\t1\t1\n+-9194298748734675155\t0\t0\t0\t1\t0\t0\n+-9154303869107404275\t1\t0\t1\t1\t1\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    x Int64\n+    A UInt8\n+    B UInt8\n+    C UInt8\n+    D UInt8\n+    E UInt8\n+    F UInt8\n+  PROJECTION\n+    LIST id: 1, nodes: 7\n+      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+      COLUMN id: 4, column_name: A, result_type: UInt8, source_id: 3\n+      COLUMN id: 5, column_name: B, result_type: UInt8, source_id: 3\n+      COLUMN id: 6, column_name: C, result_type: UInt8, source_id: 3\n+      COLUMN id: 7, column_name: D, result_type: UInt8, source_id: 3\n+      COLUMN id: 8, column_name: E, result_type: UInt8, source_id: 3\n+      COLUMN id: 9, column_name: F, result_type: UInt8, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  WHERE\n+    FUNCTION id: 10, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 11, nodes: 2\n+          COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+          COLUMN id: 13, column_name: E, result_type: UInt8, source_id: 3\n+\n+SELECT\n+    __table1.x AS x,\n+    __table1.A AS A,\n+    __table1.B AS B,\n+    __table1.C AS C,\n+    __table1.D AS D,\n+    __table1.E AS E,\n+    __table1.F AS F\n+FROM default.x AS __table1\n+WHERE __table1.C AND __table1.E\n+-9154303869107404275\t1\t0\t1\n+-9137658153367139416\t1\t1\t1\n+-9137309194079040284\t1\t1\t1\n+-9121738304623869295\t1\t1\t0\n+-9114056182077943575\t1\t1\t1\n+-9097647291775228882\t1\t0\t1\n+-9038891087920847933\t1\t0\t1\n+-9031027738484209035\t1\t0\t1\n+-9012321986923892113\t1\t1\t0\n+-9001504240784412840\t1\t1\t0\n+-9154303869107404275\t1\t0\t1\n+-9137658153367139416\t1\t1\t1\n+-9137309194079040284\t1\t1\t1\n+-9121738304623869295\t1\t1\t0\n+-9114056182077943575\t1\t1\t1\n+-9097647291775228882\t1\t0\t1\n+-9038891087920847933\t1\t0\t1\n+-9031027738484209035\t1\t0\t1\n+-9012321986923892113\t1\t1\t0\n+-9001504240784412840\t1\t1\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    x Int64\n+    mA UInt8\n+    mB UInt8\n+    mC UInt8\n+  PROJECTION\n+    LIST id: 1, nodes: 4\n+      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+      FUNCTION id: 4, function_name: max, function_type: aggregate, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 5, nodes: 1\n+            COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+      FUNCTION id: 7, function_name: max, function_type: aggregate, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 8, nodes: 1\n+            COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+      FUNCTION id: 10, function_name: max, function_type: aggregate, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 11, nodes: 1\n+            COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  GROUP BY\n+    LIST id: 13, nodes: 1\n+      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+  HAVING\n+    FUNCTION id: 14, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 15, nodes: 2\n+          FUNCTION id: 4, function_name: max, function_type: aggregate, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 5, nodes: 1\n+                COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+          FUNCTION id: 16, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 17, nodes: 2\n+                FUNCTION id: 7, function_name: max, function_type: aggregate, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 8, nodes: 1\n+                      COLUMN id: 9, column_name: B, result_type: UInt8, source_id: 3\n+                FUNCTION id: 10, function_name: max, function_type: aggregate, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 11, nodes: 1\n+                      COLUMN id: 12, column_name: C, result_type: UInt8, source_id: 3\n+\n+SELECT\n+    __table1.x AS x,\n+    max(__table1.A) AS mA,\n+    max(__table1.B) AS mB,\n+    max(__table1.C) AS mC\n+FROM default.x AS __table1\n+GROUP BY __table1.x\n+HAVING max(__table1.A) AND (max(__table1.B) OR max(__table1.C))\n+-9220160771238933596\t1\t1\t1\n+-9154303869107404275\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\n+-9137309194079040284\t1\t1\t1\n+-9136706315507142110\t1\t1\t1\n+-9136188450553078231\t1\t1\t1\n+-9121738304623869295\t1\t1\t0\n+-9119049435533988608\t1\t0\t1\n+-9114056182077943575\t1\t1\t1\n+-9097647291775228882\t1\t1\t1\n+-9220160771238933596\t1\t1\t1\n+-9154303869107404275\t1\t1\t1\n+-9137658153367139416\t1\t1\t1\n+-9137309194079040284\t1\t1\t1\n+-9136706315507142110\t1\t1\t1\n+-9136188450553078231\t1\t1\t1\n+-9121738304623869295\t1\t1\t0\n+-9119049435533988608\t1\t0\t1\n+-9114056182077943575\t1\t1\t1\n+-9097647291775228882\t1\t1\t1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    x Int64\n+    mA UInt8\n+    mB UInt8\n+    mC UInt8\n+  PROJECTION\n+    LIST id: 1, nodes: 4\n+      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+      FUNCTION id: 4, function_name: max, function_type: window, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 5, nodes: 1\n+            COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+        WINDOW\n+          WINDOW id: 7, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+            PARTITION BY\n+              LIST id: 8, nodes: 1\n+                FUNCTION id: 9, function_name: modulo, function_type: ordinary, result_type: Int32\n+                  ARGUMENTS\n+                    LIST id: 10, nodes: 2\n+                      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                      CONSTANT id: 11, constant_value: UInt64_1000, constant_value_type: UInt16\n+      FUNCTION id: 12, function_name: max, function_type: window, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 13, nodes: 1\n+            COLUMN id: 14, column_name: B, result_type: UInt8, source_id: 3\n+        WINDOW\n+          WINDOW id: 15, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+            PARTITION BY\n+              LIST id: 16, nodes: 1\n+                FUNCTION id: 17, function_name: modulo, function_type: ordinary, result_type: Int32\n+                  ARGUMENTS\n+                    LIST id: 18, nodes: 2\n+                      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                      CONSTANT id: 19, constant_value: UInt64_1000, constant_value_type: UInt16\n+      FUNCTION id: 20, function_name: max, function_type: window, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 21, nodes: 1\n+            COLUMN id: 22, column_name: C, result_type: UInt8, source_id: 3\n+        WINDOW\n+          WINDOW id: 23, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+            PARTITION BY\n+              LIST id: 24, nodes: 1\n+                FUNCTION id: 25, function_name: modulo, function_type: ordinary, result_type: Int32\n+                  ARGUMENTS\n+                    LIST id: 26, nodes: 2\n+                      COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                      CONSTANT id: 27, constant_value: UInt64_1000, constant_value_type: UInt16\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.x\n+  QUALIFY\n+    FUNCTION id: 28, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 29, nodes: 2\n+          FUNCTION id: 4, function_name: max, function_type: window, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 5, nodes: 1\n+                COLUMN id: 6, column_name: A, result_type: UInt8, source_id: 3\n+            WINDOW\n+              WINDOW id: 7, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+                PARTITION BY\n+                  LIST id: 8, nodes: 1\n+                    FUNCTION id: 9, function_name: modulo, function_type: ordinary, result_type: Int32\n+                      ARGUMENTS\n+                        LIST id: 10, nodes: 2\n+                          COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                          CONSTANT id: 11, constant_value: UInt64_1000, constant_value_type: UInt16\n+          FUNCTION id: 30, function_name: or, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 31, nodes: 2\n+                FUNCTION id: 12, function_name: max, function_type: window, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 13, nodes: 1\n+                      COLUMN id: 14, column_name: B, result_type: UInt8, source_id: 3\n+                  WINDOW\n+                    WINDOW id: 15, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+                      PARTITION BY\n+                        LIST id: 16, nodes: 1\n+                          FUNCTION id: 17, function_name: modulo, function_type: ordinary, result_type: Int32\n+                            ARGUMENTS\n+                              LIST id: 18, nodes: 2\n+                                COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                                CONSTANT id: 19, constant_value: UInt64_1000, constant_value_type: UInt16\n+                FUNCTION id: 20, function_name: max, function_type: window, result_type: UInt8\n+                  ARGUMENTS\n+                    LIST id: 21, nodes: 1\n+                      COLUMN id: 22, column_name: C, result_type: UInt8, source_id: 3\n+                  WINDOW\n+                    WINDOW id: 23, frame_type: RANGE, frame_begin_type: unbounded preceding, frame_end_type: current\n+                      PARTITION BY\n+                        LIST id: 24, nodes: 1\n+                          FUNCTION id: 25, function_name: modulo, function_type: ordinary, result_type: Int32\n+                            ARGUMENTS\n+                              LIST id: 26, nodes: 2\n+                                COLUMN id: 2, column_name: x, result_type: Int64, source_id: 3\n+                                CONSTANT id: 27, constant_value: UInt64_1000, constant_value_type: UInt16\n+\n+SELECT\n+    __table1.x AS x,\n+    max(__table1.A) OVER (PARTITION BY __table1.x % 1000) AS mA,\n+    max(__table1.B) OVER (PARTITION BY __table1.x % 1000) AS mB,\n+    max(__table1.C) OVER (PARTITION BY __table1.x % 1000) AS mC\n+FROM default.x AS __table1\n+QUALIFY max(__table1.A) OVER (PARTITION BY (__table1.x % 1000)) AND (max(__table1.B) OVER (PARTITION BY (__table1.x % 1000)) OR max(__table1.C) OVER (PARTITION BY (__table1.x % 1000)))\ndiff --git a/tests/queries/0_stateless/03262_common_expression_optimization.sql b/tests/queries/0_stateless/03262_common_expression_optimization.sql\nnew file mode 100644\nindex 000000000000..80d8d1718b25\n--- /dev/null\n+++ b/tests/queries/0_stateless/03262_common_expression_optimization.sql\n@@ -0,0 +1,158 @@\n+SET enable_analyzer = 1;\n+SET optimize_extract_common_expressions = 1;\n+\n+DROP TABLE IF EXISTS x;\n+CREATE TABLE x (x Int64, A UInt8, B UInt8, C UInt8, D UInt8, E UInt8, F UInt8) ENGINE = MergeTree ORDER BY x;\n+INSERT INTO x\n+    SELECT\n+        cityHash64(number) AS x,\n+        cityHash64(number + 1) % 2 AS A,\n+        cityHash64(number + 2) % 2 AS B,\n+        cityHash64(number + 3) % 2 AS C,\n+        cityHash64(number + 4) % 2 AS D,\n+        cityHash64(number + 5) % 2 AS E,\n+        cityHash64(number + 6) % 2 AS F\n+    FROM numbers(2000);\n+\n+-- Verify that optimization optimization setting works as expected\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE (A AND B) OR (A AND C) SETTINGS optimize_extract_common_expressions = 0;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE (A AND B) OR (A AND C) SETTINGS optimize_extract_common_expressions = 1;\n+\n+-- Test multiple cases\n+SELECT * FROM x WHERE A AND ((B AND C) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE A AND ((B AND C) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A AND ((B AND C) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE A AND ((B AND C AND E) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE A AND ((B AND C AND E) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A AND ((B AND C AND E) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE A AND ((B AND (C AND E)) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE A AND ((B AND (C AND E)) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A AND ((B AND (C AND E)) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE A AND ((B AND C) OR (B AND D) OR (B AND E)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE A AND ((B AND C) OR (B AND D) OR (B AND E)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A AND ((B AND C) OR (B AND D) OR (B AND E));\n+\n+SELECT * FROM x WHERE A AND ((B AND C) OR ((B AND D) OR (B AND E))) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE A AND ((B AND C) OR ((B AND D) OR (B AND E))) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A AND ((B AND C) OR ((B AND D) OR (B AND E)));\n+\n+-- Without AND as a root\n+SELECT * FROM x WHERE ((B AND C) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((B AND C) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND C) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE ((B AND C AND E) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((B AND C AND E) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND C AND E) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE ((B AND (C AND E)) OR (B AND C AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((B AND (C AND E)) OR (B AND C AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND (C AND E)) OR (B AND C AND F));\n+\n+SELECT * FROM x WHERE ((B AND C) OR (B AND D) OR (B AND E)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((B AND C) OR (B AND D) OR (B AND E)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND C) OR (B AND D) OR (B AND E));\n+\n+SELECT * FROM x WHERE ((B AND C) OR ((B AND D) OR (B AND E))) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((B AND C) OR ((B AND D) OR (B AND E))) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND C) OR ((B AND D) OR (B AND E)));\n+\n+-- Complex expression\n+SELECT * FROM x WHERE (A AND (sipHash64(C) = sipHash64(D))) OR (B AND (sipHash64(C) = sipHash64(D))) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE (A AND (sipHash64(C) = sipHash64(D))) OR (B AND (sipHash64(C) = sipHash64(D))) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE (A AND (sipHash64(C) = sipHash64(D))) OR (B AND (sipHash64(C) = sipHash64(D)));\n+\n+-- Flattening is only happening if something can be extracted\n+SELECT * FROM x WHERE ((A AND B) OR ((C AND D) OR (E AND F))) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((A AND B) OR ((C AND D) OR (E AND F))) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((A AND B) OR ((C AND D) OR (E AND F)));\n+\n+SELECT * FROM x WHERE ((A AND B) OR ((B AND D) OR (E AND F))) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((A AND B) OR ((B AND D) OR (E AND F))) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((A AND B) OR ((B AND D) OR (E AND F)));\n+\n+-- Duplicates\n+SELECT * FROM x WHERE (A AND B AND C) OR ((A AND A AND A AND B AND B AND E AND E) OR (A AND B AND B AND F AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE (A AND B AND C) OR ((A AND A AND A AND B AND B AND E AND E) OR (A AND B AND B AND F AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE (A AND B AND C) OR ((A AND A AND A AND B AND B AND E AND E) OR (A AND B AND B AND F AND F));\n+\n+SELECT * FROM x WHERE ((A AND B AND C) OR (A AND B AND D)) AND ((B AND A AND E) OR (B AND A AND F)) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE ((A AND B AND C) OR (A AND B AND D)) AND ((B AND A AND E) OR (B AND A AND F)) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((A AND B AND C) OR (A AND B AND D)) AND ((B AND A AND E) OR (B AND A AND F));\n+\n+\n+-- _CAST function has to be used to maintain the same result type\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND C) OR (B AND C AND toNullable(F)));\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE (x AND x) OR (x AND x);\n+-- Here the result type stays nullable because of `toNullable(C)`, so no cast is needed\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE ((B AND toNullable(C)) OR (B AND toNullable(C) AND toNullable(F)));\n+\n+-- Check that optimization only happen on top level, (C AND D) OR (C AND E) shouldn't be optimized\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x WHERE A OR (B AND ((C AND D) OR (C AND E)));\n+\n+\n+DROP TABLE IF EXISTS y;\n+CREATE TABLE y (x Int64, A UInt8, B UInt8, C UInt8, D UInt8, E UInt8, F UInt8) ENGINE = MergeTree ORDER BY x;\n+INSERT INTO y\n+    SELECT\n+        murmurHash3_64(number) AS x,\n+        murmurHash3_64(number + 1) % 2 AS A,\n+        murmurHash3_64(number + 2) % 2 AS B,\n+        murmurHash3_64(number + 3) % 2 AS C,\n+        murmurHash3_64(number + 4) % 2 AS D,\n+        murmurHash3_64(number + 5) % 2 AS E,\n+        murmurHash3_64(number + 6) % 2 AS F\n+    FROM numbers(2000);\n+\n+-- JOIN expressions\n+-- As the optimization code is shared between ON and WHERE, it is enough to test that the optimization is done also in ON\n+SELECT * FROM x INNER JOIN y ON ((x.A = y.A ) AND x.B = 1) OR ((x.A = y.A) AND y.C = 1) ORDER BY ALL LIMIT 10 SETTINGS allow_experimental_join_condition = 1, optimize_extract_common_expressions = 0;\n+SELECT * FROM x INNER JOIN y ON ((x.A = y.A ) AND x.B = 1) OR ((x.A = y.A) AND y.C = 1) ORDER BY ALL LIMIT 10 SETTINGS allow_experimental_join_condition = 1;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x INNER JOIN y ON ((x.A = y.A ) AND x.B = 1) OR ((x.A = y.A) AND y.C = 1);\n+\n+-- Check that optimization only happen on top level, (x.C = y.C AND x.D = y.D) OR (x.C = y.C AND x.E = y.E) shouldn't be optimized\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT count() FROM x INNER JOIN y ON (x.A = y.A) OR ((x.B = y.B) AND ((x.C = y.C AND x.D = y.D) OR (x.C = y.C AND x.E = y.E)));\n+\n+-- Duplicated subexpressions, found by fuzzer\n+SELECT * FROM x WHERE (D AND 5) OR ((C AND E) AND (C AND E)) ORDER BY ALL LIMIT 3 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT * FROM x WHERE (D AND 5) OR ((C AND E) AND (C AND E)) ORDER BY ALL LIMIT 3;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT * FROM x WHERE (C AND E) OR ((C AND E) AND (C AND E));\n+\n+-- HAVING\n+SELECT x, max(A) AS mA, max(B) AS mB, max(C) AS mC FROM x GROUP BY x HAVING (mA AND mB) OR (mA AND mC) ORDER BY x LIMIT 10 SETTINGS optimize_extract_common_expressions = 0;\n+SELECT x, max(A) AS mA, max(B) AS mB, max(C) AS mC FROM x GROUP BY x HAVING (mA AND mB) OR (mA AND mC) ORDER BY x LIMIT 10;\n+EXPLAIN QUERY TREE dump_ast = 1 SELECT x, max(A) AS mA, max(B) AS mB, max(C) AS mC FROM x GROUP BY x HAVING (mA AND mB) OR (mA AND mC);\n+\n+-- QUALIFY\n+SELECT\n+    x,\n+    max(A) OVER (PARTITION BY x % 1000) AS mA,\n+    max(B) OVER (PARTITION BY x % 1000) AS mB,\n+    max(C) OVER (PARTITION BY x % 1000) AS mC\n+FROM x\n+QUALIFY (mA AND mB) OR (mA AND mC)\n+ORDER BY x\n+LIMIT 10\n+SETTINGS optimize_extract_common_expressions = 0;\n+\n+SELECT\n+    x,\n+    max(A) OVER (PARTITION BY x % 1000) AS mA,\n+    max(B) OVER (PARTITION BY x % 1000) AS mB,\n+    max(C) OVER (PARTITION BY x % 1000) AS mC\n+FROM x\n+QUALIFY (mA AND mB) OR (mA AND mC)\n+ORDER BY x\n+LIMIT 10;\n+\n+EXPLAIN QUERY TREE dump_ast = 1\n+SELECT\n+    x,\n+    max(A) OVER (PARTITION BY x % 1000) AS mA,\n+    max(B) OVER (PARTITION BY x % 1000) AS mB,\n+    max(C) OVER (PARTITION BY x % 1000) AS mC\n+FROM x\n+QUALIFY (mA AND mB) OR (mA AND mC);\n",
  "problem_statement": "Improve performance by extracting common expressions from `OR` expressions of `WHERE` and `ON` expressions\nThe goal is rewrite `WHERE`/`ON` expressions with multiple `OR` expressions when there is common conditions on those `OR` expressions. For example `A AND ((B AND C) OR (B AND D) OR (B AND E))` should be rewritten to `A AND B AND (C OR D OR E)`.\r\n\r\nIn case of `WHERE` expressions this might help to skip some rows based on primary key and/or other indices. We would like to always rewrite the `WHERE` expressions.\r\n\r\nIn case of joins this should help to convert more cross joins to inner joins. If the join cannot be converted to inner join after rewriting the `ON` expression, the expression shouldn't be changed.\r\n\r\nThe steps for both `WHERE` and `ON` conditions:\r\n1. Flatten the `OR` and `AND` expressions (e.g.: `A OR (B OR C) => A OR B OR C`)\r\n2. Move the common expressions out from `OR` expressions\r\n3. If nothing can be moved out, discard the flattening\r\n\r\nMoving out expressions that only depend on one table (e.g.: `ON (t1.a = t2.a AND t1.x > 1) OR (t1.b = t2.b AND t1.x > 1)`) might break some queries, so [planning](https://github.com/ClickHouse/ClickHouse/blob/20bf1d7b721f26abc99bfd7ea572150d23a89666/src/Planner/PlannerJoins.cpp#L454-L472) has to be improved to not to break such queries.\r\n\r\nA good example if the query 19 from TCP-H:\r\n\r\n```sql\r\nSELECT\r\n     SUM(l_extendedprice* (1 - l_discount)) AS revenue\r\nFROM\r\n     lineitem,\r\n     part\r\nWHERE\r\n     (\r\n\t\tp_partkey = l_partkey\r\n\t\tAND p_brand = 'Brand#12'\r\n\t\tAND p_container IN ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')\r\n\t\tAND l_quantity >= 1 AND l_quantity <= 1 + 10\r\n\t\tAND p_size BETWEEN 1 AND 5\r\n\t\tAND l_shipmode IN ('AIR', 'AIR REG')\r\n\t\tAND l_shipinstruct = 'DELIVER IN PERSON'\r\n     )\r\n     OR\r\n     (\r\n\t\tp_partkey = l_partkey\r\n\t\tAND p_brand = 'Brand#23'\r\n\t\tAND p_container IN ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')\r\n\t\tAND l_quantity >= 10 AND l_quantity <= 10 + 10\r\n\t\tAND p_size BETWEEN 1 AND 10\r\n\t\tAND l_shipmode IN ('AIR', 'AIR REG')\r\n\t\tAND l_shipinstruct = 'DELIVER IN PERSON'\r\n     )\r\n     OR\r\n     (\r\n\t\tp_partkey = l_partkey\r\n\t\tAND p_brand = 'Brand#34'\r\n\t\tAND p_container IN ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')\r\n\t\tAND l_quantity >= 20 AND l_quantity <= 20 + 10\r\n\t\tAND p_size BETWEEN 1 AND 15\r\n\t\tAND l_shipmode IN ('AIR', 'AIR REG')\r\n\t\tAND l_shipinstruct = 'DELIVER IN PERSON'\r\n     )\r\n```\r\n\r\nshould become:\r\n\r\n```sql\r\nSELECT\r\n     SUM(l_extendedprice* (1 - l_discount)) AS revenue\r\nFROM\r\n     lineitem,\r\n     part\r\nWHERE\r\n\t\tp_partkey = l_partkey\r\n\t\tAND l_shipinstruct = 'DELIVER IN PERSON'\r\n\t\tAND l_shipmode IN ('AIR', 'AIR REG')\r\n\t\tAND \r\n\t\t\t(\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#12'\r\n\t\t\t\t\tAND p_container IN ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')\r\n\t\t\t\t\tAND l_quantity >= 1 AND l_quantity <= 1 + 10\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 5\r\n\t\t\t\t)\r\n\t\t\t\tOR\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#23'\r\n\t\t\t\t\tAND p_container IN ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')\r\n\t\t\t\t\tAND l_quantity >= 10 AND l_quantity <= 10 + 10\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 10\r\n\t\t\t\t)\r\n\t\t\t\tOR\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#34'\r\n\t\t\t\t\tAND p_container IN ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')\r\n\t\t\t\t\tAND l_quantity >= 20 AND l_quantity <= 20 + 10\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 15\r\n\t\t\t\t)\r\n\t\t\t)\r\n```\r\n\r\n**Future ideas**:\r\n- Detect when some conditions can be combined in the `OR` expressions to make filtering better, e.g.: `l_quantity >= 1 AND l_quantity <= 20 + 10` could be added to the root `AND` expression to prefilter the results\r\n- Implement `Join Dependent Predicate Duplication` from [here](https://www.vldb.org/pvldb/vol13/p1206-dreseler.pdf), section 4.4. Basically extract and copy the part of `ON` expressions which can be used to prune the input data. It is a more generic version of the first point.\n",
  "hints_text": "Just for reference, a next step after pulling out fully equal predicates (equal variable + equal value), is pulling out predicates against the same variable but with different values\r\n\r\nIn Q19 and the table `lineitem`, this is `l_quantity`. With rewriting we'll get\r\n\r\n```sql\r\nSELECT\r\n     SUM(l_extendedprice* (1 - l_discount)) AS revenue\r\nFROM\r\n     lineitem,\r\n     part\r\nWHERE\r\n\t\tp_partkey = l_partkey\r\n\t\tAND l_shipinstruct = 'DELIVER IN PERSON'\r\n\t\tAND l_shipmode IN ('AIR', 'AIR REG')\r\n        AND ((l_quantity >= 1 AND l_quantity <= 1 + 10)\r\n            OR (l_quantity >= 10 AND l_quantity <= 10 + 10)\r\n            OR (l_quantity >= 20 AND l_quantity <= 20 + 10))\r\n\t\tAND \r\n\t\t\t(\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#12'\r\n\t\t\t\t\tAND p_container IN ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 5\r\n\t\t\t\t)\r\n\t\t\t\tOR\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#23'\r\n\t\t\t\t\tAND p_container IN ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 10\r\n\t\t\t\t)\r\n\t\t\t\tOR\r\n\t\t\t\t(\r\n\t\t\t\t    p_brand = 'Brand#34'\r\n\t\t\t\t\tAND p_container IN ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')\r\n\t\t\t\t\tAND p_size BETWEEN 1 AND 15\r\n\t\t\t\t)\r\n\t\t\t)\r\n```\r\n\r\n(see Sec. 4.4. in https://www.vldb.org/pvldb/vol13/p1206-dreseler.pdf)",
  "created_at": "2024-11-06T16:50:49Z"
}