{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 20067,
  "instance_id": "ClickHouse__ClickHouse-20067",
  "issue_numbers": [
    "20052"
  ],
  "base_commit": "02ca7386b157aa1b564179a4fe9a2a0e4287f508",
  "patch": "diff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h\nindex 3aa00c682749..c3b0d956ef5a 100644\n--- a/src/DataTypes/NumberTraits.h\n+++ b/src/DataTypes/NumberTraits.h\n@@ -104,11 +104,16 @@ template <typename A, typename B> struct ResultOfIntegerDivision\n         sizeof(A)>::Type;\n };\n \n-/** Division with remainder you get a number with the same number of bits as in divisor.\n-    */\n+/** Division with remainder you get a number with the same number of bits as in divisor,\n+  * or larger in case of signed type.\n+  */\n template <typename A, typename B> struct ResultOfModulo\n {\n-    using Type0 = typename Construct<is_signed_v<A> || is_signed_v<B>, false, sizeof(B)>::Type;\n+    static constexpr bool result_is_signed = is_signed_v<A>;\n+    /// If modulo of division can yield negative number, we need larger type to accommodate it.\n+    /// Example: toInt32(-199) % toUInt8(200) will return -199 that does not fit in Int8, only in Int16.\n+    static constexpr size_t size_of_result = result_is_signed ? nextSize(sizeof(B)) : sizeof(B);\n+    using Type0 = typename Construct<result_is_signed, false, size_of_result>::Type;\n     using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>, Float64, Type0>;\n };\n \n",
  "test_patch": "diff --git a/src/Functions/tests/gtest_number_traits.cpp b/src/Functions/tests/gtest_number_traits.cpp\nindex 7664b4fcbdc1..7f25c6cbeb74 100644\n--- a/src/Functions/tests/gtest_number_traits.cpp\n+++ b/src/Functions/tests/gtest_number_traits.cpp\n@@ -258,7 +258,7 @@ TEST(NumberTraits, Others)\n     ASSERT_EQ(getTypeString(DB::NumberTraits::ResultOfFloatingPointDivision<DB::UInt16, DB::Int16>::Type()), \"Float64\");\n     ASSERT_EQ(getTypeString(DB::NumberTraits::ResultOfFloatingPointDivision<DB::UInt32, DB::Int16>::Type()), \"Float64\");\n     ASSERT_EQ(getTypeString(DB::NumberTraits::ResultOfIntegerDivision<DB::UInt8, DB::Int16>::Type()), \"Int8\");\n-    ASSERT_EQ(getTypeString(DB::NumberTraits::ResultOfModulo<DB::UInt32, DB::Int8>::Type()), \"Int8\");\n+    ASSERT_EQ(getTypeString(DB::NumberTraits::ResultOfModulo<DB::UInt32, DB::Int8>::Type()), \"UInt8\");\n }\n \n \ndiff --git a/tests/queries/0_stateless/01700_mod_negative_type_promotion.reference b/tests/queries/0_stateless/01700_mod_negative_type_promotion.reference\nnew file mode 100644\nindex 000000000000..b8d2624b7fe2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01700_mod_negative_type_promotion.reference\n@@ -0,0 +1,1 @@\n+-199\ndiff --git a/tests/queries/0_stateless/01700_mod_negative_type_promotion.sql b/tests/queries/0_stateless/01700_mod_negative_type_promotion.sql\nnew file mode 100644\nindex 000000000000..db850ba5c80d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01700_mod_negative_type_promotion.sql\n@@ -0,0 +1,1 @@\n+SELECT toInt32(-199) % 200;\n",
  "problem_statement": "Incorrect modulo(a, b), a % b behavior for Int fields\nClickHouse server version 20.8.9 revision 54438\r\n\r\nLet's imagine some simple table structure:\r\n\r\n```\r\nCREATE TABLE users (\r\n    `user_id` Int32\r\n)\r\n```\r\n\r\nModulo operator on **Int32** field with **150** argument returns negative result. This could have happened due to wrong type casting - result should be casted to **Int16** or **UInt8** instead of **Int8**.\r\n\r\n```\r\nSELECT \r\n    user_id % 150, \r\n    441746 % 150,\r\n    toTypeName(user_id % 150),\r\n    toTypeName(441746 % 150)\r\nFROM users \r\nWHERE user_id = 441746\r\nLIMIT 1\r\n```\r\n\r\n```\r\n\u250c\u2500modulo(user_id, 150)\u2500\u252c\u2500modulo(441746, 150)\u2500\u252c\u2500toTypeName(modulo(user_id, 150))\u2500\u252c\u2500toTypeName(modulo(441746, 150))\u2500\u2510\r\n\u2502                -110  \u2502                 146 \u2502 Int8                             \u2502 UInt8                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "```\r\ndell123 :) select toInt32(441746) % 150 as a , toTypeName(a), 441746 % 150 as b, toTypeName(b)\r\n\r\nQuery id: e0111eab-044c-47da-9684-084bf8d07a01\r\n\r\n\u250c\u2500\u2500\u2500\u2500a\u2500\u252c\u2500toTypeName(modulo(toInt32(441746), 150))\u2500\u252c\u2500\u2500\u2500b\u2500\u252c\u2500toTypeName(modulo(441746, 150))\u2500\u2510\r\n\u2502 -110 \u2502 Int8                                     \u2502 146 \u2502 UInt8                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n\r\ndell123 :)\r\n```\r\n\r\nThe type of constant `150`  is UInt8,  and `441746` is UInt32.\r\nwhen Int % UInt8 the result type is Int8.\r\nwhen UInt32 % UInt8 the result type is UInt8.\r\n\r\nSo if you want the same result, maybe you can try:\r\n```\r\nSELECT\r\n    user_id % toUInt32(150),\r\n    441746 % toUInt32(150),\r\n    toTypeName(user_id % toUInt32(150)),\r\n    toTypeName(441746 % toUInt32(150))\r\nFROM users\r\nWHERE user_id = 441746\r\nLIMIT 1\r\n\r\nQuery id: f9e59396-751f-46f2-af1e-40a575bf6c08\r\n\r\n\u250c\u2500modulo(user_id, toUInt32(150))\u2500\u252c\u2500modulo(441746, toUInt32(150))\u2500\u252c\u2500toTypeName(modulo(user_id, toUInt32(150)))\u2500\u252c\u2500toTypeName(modulo(441746, toUInt32(150)))\u2500\u2510\r\n\u2502                            146 \u2502                           146 \u2502 Int32                                      \u2502 UInt32                                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\n\r\nSELECT\r\n    user_id % toInt32(150),\r\n    441746 % toInt32(150),\r\n    toTypeName(user_id % toInt32(150)),\r\n    toTypeName(441746 % toInt32(150))\r\nFROM users\r\nWHERE user_id = 441746\r\nLIMIT 1\r\n\r\nQuery id: d649e691-43ea-41ca-9ee3-46d8cb362a73\r\n\r\n\u250c\u2500modulo(user_id, toInt32(150))\u2500\u252c\u2500modulo(441746, toInt32(150))\u2500\u252c\u2500toTypeName(modulo(user_id, toInt32(150)))\u2500\u252c\u2500toTypeName(modulo(441746, toInt32(150)))\u2500\u2510\r\n\u2502                           146 \u2502                          146 \u2502 Int32                                     \u2502 Int32                                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\nA simple analysis:\r\nThe incorrect result may happen when the type A is signed and type B is usigned, because the result type of modulo is signed B. In this case, type A is signed Int32, type B is unsigned UInt8, hence the result type is Int8. The value of UInt8 from 128 to 255 is considered as negative for type Int8. \r\n\r\n=== code ====\r\nsrc/DataTypes/NumbeTraits.h\r\n/** Division with remainder you get a number with the same number of bits as in divisor.\r\n    */\r\ntemplate <typename A, typename B> struct ResultOfModulo\r\n{\r\n    using Type0 = typename Construct<is_signed_v<A> || is_signed_v<B>, false, sizeof(B)>::Type;  \r\n    using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>, Float64, Type0>;\r\n};\r\n\r\ntemplate <> struct Construct<true, false, 1> { using Type = Int8; };  <<<< Maybe we should use Int16?\nYou are right, we need to use larger signed type to accomodate the result.\nMinimal example: `SELECT toInt32(-199) % 200`.",
  "created_at": "2021-02-04T11:57:42Z"
}