{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39071,
  "instance_id": "ClickHouse__ClickHouse-39071",
  "issue_numbers": [
    "38784"
  ],
  "base_commit": "07210c7b550b2517f7229cd0f5cb7ecd6d5874f1",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 9e6f0effcf95..6b01ee31501f 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -681,6 +681,47 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## parseTimeDelta\n+\n+Parse a sequence of numbers followed by something resembling a time unit.\n+\n+**Syntax**\n+\n+```sql\n+parseTimeDelta(timestr)\n+```\n+\n+**Arguments**\n+\n+-   `timestr` \u2014 A sequence of numbers followed by something resembling a time unit.\n+\n+\n+**Returned value**\n+\n+-   A floating-point number with the number of seconds.\n+\n+**Example**\n+\n+```sql\n+SELECT parseTimeDelta('11s+22min')\n+```\n+\n+```text\n+\u250c\u2500parseTimeDelta('11s+22min')\u2500\u2510\n+\u2502                        1331 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT parseTimeDelta('1yr2mo')\n+```\n+\n+```text\n+\u250c\u2500parseTimeDelta('1yr2mo')\u2500\u2510\n+\u2502                 36806400 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## least(a, b)\n \n Returns the smallest value from a and b.\ndiff --git a/src/Functions/parseTimeDelta.cpp b/src/Functions/parseTimeDelta.cpp\nnew file mode 100644\nindex 000000000000..fb5a7621a53f\n--- /dev/null\n+++ b/src/Functions/parseTimeDelta.cpp\n@@ -0,0 +1,291 @@\n+#include <boost/convert.hpp>\n+#include <boost/convert/strtol.hpp>\n+\n+#include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/IFunction.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+namespace\n+{\n+    const std::unordered_map<std::string_view, Float64> time_unit_to_float = {\n+        {\"years\", 365 * 24 * 3600},\n+        {\"year\", 365 * 24 * 3600},\n+        {\"yr\", 365 * 24 * 3600},\n+        {\"y\", 365 * 24 * 3600},\n+\n+        {\"months\", 30.5 * 24 * 3600},\n+        {\"month\", 30.5 * 24 * 3600},\n+        {\"mo\", 30.5 * 24 * 3600},\n+\n+        {\"weeks\", 7 * 24 * 3600},\n+        {\"week\", 7 * 24 * 3600},\n+        {\"w\", 7 * 24 * 3600},\n+\n+        {\"days\", 24 * 3600},\n+        {\"day\", 24 * 3600},\n+        {\"d\", 24 * 3600},\n+\n+        {\"hours\", 3600},\n+        {\"hour\", 3600},\n+        {\"hr\", 3600},\n+        {\"h\", 3600},\n+\n+        {\"minutes\", 60},\n+        {\"minute\", 60},\n+        {\"min\", 60},\n+        {\"m\", 60},\n+\n+        {\"seconds\", 1},\n+        {\"second\", 1},\n+        {\"sec\", 1},\n+        {\"s\", 1},\n+    };\n+\n+    /** Prints amount of seconds in form of:\n+     * \"1 year 2 months 4 weeks 12 days 3 hours 1 minute 33 seconds\".\n+     * ' ', ';', '-', '+', ',', ':' can be used as separator, eg. \"1yr-2mo\", \"2m:6s\"\n+     *\n+     * valid expressions:\n+     * SELECT parseTimeDelta('1 min 35 sec');\n+     * SELECT parseTimeDelta('0m;11.23s.');\n+     * SELECT parseTimeDelta('11hr 25min 3.1s');\n+     * SELECT parseTimeDelta('0.00123 seconds');\n+     * SELECT parseTimeDelta('1yr2mo');\n+     * SELECT parseTimeDelta('11s+22min');\n+     * SELECT parseTimeDelta('1yr-2mo-4w + 12 days, 3 hours : 1 minute ; 33 seconds');\n+     *\n+     * invalid expressions:\n+     * SELECT parseTimeDelta();\n+     * SELECT parseTimeDelta('1yr', 1);\n+     * SELECT parseTimeDelta(1);\n+     * SELECT parseTimeDelta(' ');\n+     * SELECT parseTimeDelta('-1yr');\n+     * SELECT parseTimeDelta('1yr-');\n+     * SELECT parseTimeDelta('yr2mo');\n+     * SELECT parseTimeDelta('1.yr2mo');\n+     * SELECT parseTimeDelta('1-yr');\n+     * SELECT parseTimeDelta('1 1yr');\n+     * SELECT parseTimeDelta('1yyr');\n+     * SELECT parseTimeDelta('1yr-2mo-4w + 12 days, 3 hours : 1 minute ;. 33 seconds');\n+     *\n+     * The length of years and months (and even days in presence of time adjustments) are rough:\n+     * year is just 365 days, month is 30.5 days, day is 86400 seconds, similarly to what formatReadableTimeDelta is doing.\n+     */\n+    class FunctionParseTimeDelta : public IFunction\n+    {\n+    public:\n+        static constexpr auto name = \"parseTimeDelta\";\n+        static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionParseTimeDelta>(); }\n+\n+        String getName() const override { return name; }\n+\n+        bool isVariadic() const override { return true; }\n+\n+        bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+        size_t getNumberOfArguments() const override { return 0; }\n+\n+        DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+        {\n+            if (arguments.empty())\n+                throw Exception(\n+                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                    \"Number of arguments for function {} doesn't match: passed {}, should be 1.\",\n+                    getName(),\n+                    toString(arguments.size()));\n+\n+            if (arguments.size() > 1)\n+                throw Exception(\n+                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                    \"Number of arguments for function {} doesn't match: passed {}, should be 1.\",\n+                    getName(),\n+                    toString(arguments.size()));\n+\n+            const IDataType & type = *arguments[0];\n+\n+            if (!isString(type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot format {} as time string.\", type.getName());\n+\n+            return std::make_shared<DataTypeFloat64>();\n+        }\n+\n+        bool useDefaultImplementationForConstants() const override { return true; }\n+\n+        ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+        {\n+            auto col_to = ColumnFloat64::create();\n+            auto & res_data = col_to->getData();\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                std::string_view str{arguments[0].column->getDataAt(i)};\n+                Int64 token_tail = 0;\n+                Int64 token_front = 0;\n+                Int64 last_pos = str.length() - 1;\n+                Float64 result = 0;\n+\n+                /// ignore '.' and ' ' at the end of string\n+                while (last_pos >= 0 && (str[last_pos] == ' ' || str[last_pos] == '.'))\n+                    --last_pos;\n+\n+                /// no valid characters\n+                if (last_pos < 0)\n+                {\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"Invalid expression for function {}, don't find valid characters, str: \\\"{}\\\".\",\n+                        getName(),\n+                        String(str));\n+                }\n+\n+                /// last pos character must be character and not be separator or number after ignoring '.' and ' '\n+                if (!isalpha(str[last_pos]))\n+                {\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid expression for function {}, str: \\\"{}\\\".\", getName(), String(str));\n+                }\n+\n+                /// scan spaces at the beginning\n+                scanSpaces(str, token_tail, last_pos);\n+                token_front = token_tail;\n+\n+                while (token_tail <= last_pos)\n+                {\n+                    /// scan unsigned integer\n+                    if (!scanUnsignedInteger(str, token_tail, last_pos))\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::BAD_ARGUMENTS,\n+                            \"Invalid expression for function {}, find number failed, str: \\\"{}\\\".\",\n+                            getName(),\n+                            String(str));\n+                    }\n+\n+                    /// if there is a '.', then scan another integer to get a float number\n+                    if (token_tail <= last_pos && str[token_tail] == '.')\n+                    {\n+                        token_tail++;\n+                        if (!scanUnsignedInteger(str, token_tail, last_pos))\n+                        {\n+                            throw Exception(\n+                                ErrorCodes::BAD_ARGUMENTS,\n+                                \"Invalid expression for function {}, find number after '.' failed, str: \\\"{}\\\".\",\n+                                getName(),\n+                                String(str));\n+                        }\n+                    }\n+\n+                    /// convert float/integer string to float\n+                    Float64 base = 0;\n+                    std::string_view base_str = str.substr(token_front, token_tail - token_front);\n+                    auto value = boost::convert<Float64>(base_str, boost::cnv::strtol());\n+                    if (!value.has_value())\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::BAD_ARGUMENTS,\n+                            \"Invalid expression for function {}, convert string to float64 failed: \\\"{}\\\".\",\n+                            getName(),\n+                            String(base_str));\n+                    }\n+                    base = value.get();\n+\n+                    scanSpaces(str, token_tail, last_pos);\n+                    token_front = token_tail;\n+\n+                    /// scan a unit\n+                    if (!scanUnit(str, token_tail, last_pos))\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::BAD_ARGUMENTS,\n+                            \"Invalid expression for function {}, find unit failed, str: \\\"{}\\\".\",\n+                            getName(),\n+                            String(str));\n+                    }\n+\n+                    /// get unit number\n+                    std::string_view unit = str.substr(token_front, token_tail - token_front);\n+                    auto iter = time_unit_to_float.find(unit);\n+                    if (iter == time_unit_to_float.end()) /// not find unit\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::BAD_ARGUMENTS, \"Invalid expression for function {}, parse unit failed: \\\"{}\\\".\", getName(), unit);\n+                    }\n+                    result += base * iter->second;\n+\n+                    /// scan separator between two tokens\n+                    scanSeparator(str, token_tail, last_pos);\n+                    token_front = token_tail;\n+                }\n+\n+                res_data.emplace_back(result);\n+            }\n+\n+            return col_to;\n+        }\n+\n+        /// scan an unsigned integer number\n+        static bool scanUnsignedInteger(std::string_view & str, Int64 & index, Int64 last_pos)\n+        {\n+            int64_t begin_index = index;\n+            while (index <= last_pos && isdigit(str[index]))\n+            {\n+                index++;\n+            }\n+            return index != begin_index;\n+        }\n+\n+        /// scan a unit\n+        static bool scanUnit(std::string_view & str, Int64 & index, Int64 last_pos)\n+        {\n+            int64_t begin_index = index;\n+            while (index <= last_pos && isalpha(str[index]))\n+            {\n+                index++;\n+            }\n+            return index != begin_index;\n+        }\n+\n+        /// scan spaces\n+        static void scanSpaces(std::string_view & str, Int64 & index, Int64 last_pos)\n+        {\n+            while (index <= last_pos && (str[index] == ' '))\n+            {\n+                index++;\n+            }\n+        }\n+\n+        /// scan for characters to ignore\n+        static void scanSeparator(std::string_view & str, Int64 & index, Int64 last_pos)\n+        {\n+            /// ignore spaces\n+            scanSpaces(str, index, last_pos);\n+\n+            /// ignore separator\n+            if (index <= last_pos\n+                && (str[index] == ';' || str[index] == '-' || str[index] == '+' || str[index] == ',' || str[index] == ':'))\n+            {\n+                index++;\n+            }\n+\n+            scanSpaces(str, index, last_pos);\n+        }\n+    };\n+\n+}\n+\n+void registerFunctionParseTimeDelta(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionParseTimeDelta>();\n+}\n+\n+}\ndiff --git a/src/Functions/registerFunctionsFormatting.cpp b/src/Functions/registerFunctionsFormatting.cpp\nindex e434b0e49f05..02353fac8122 100644\n--- a/src/Functions/registerFunctionsFormatting.cpp\n+++ b/src/Functions/registerFunctionsFormatting.cpp\n@@ -7,6 +7,7 @@ void registerFunctionsBitToArray(FunctionFactory &);\n void registerFunctionFormatReadableSize(FunctionFactory &);\n void registerFunctionFormatReadableQuantity(FunctionFactory &);\n void registerFunctionFormatReadableTimeDelta(FunctionFactory &);\n+void registerFunctionParseTimeDelta(FunctionFactory &);\n \n void registerFunctionsFormatting(FunctionFactory & factory)\n {\n@@ -14,6 +15,7 @@ void registerFunctionsFormatting(FunctionFactory & factory)\n     registerFunctionFormatReadableSize(factory);\n     registerFunctionFormatReadableQuantity(factory);\n     registerFunctionFormatReadableTimeDelta(factory);\n+    registerFunctionParseTimeDelta(factory);\n }\n \n }\n",
  "test_patch": "diff --git a/tests/fuzz/all.dict b/tests/fuzz/all.dict\nindex 356428a0b867..dff62cd68a74 100644\n--- a/tests/fuzz/all.dict\n+++ b/tests/fuzz/all.dict\n@@ -898,6 +898,7 @@\n \"parseDateTimeBestEffortUS\"\n \"parseDateTimeBestEffortUSOrNull\"\n \"parseDateTimeBestEffortUSOrZero\"\n+\"parseTimeDelta\"\n \"PARTITION\"\n \"PARTITION BY\"\n \"partitionId\"\ndiff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex 1bdaed5ee1b5..cbcad3c05da8 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -68,6 +68,7 @@\n \"reinterpretAsUInt8\"\n \"atanh\"\n \"formatReadableTimeDelta\"\n+\"parseTimeDelta\"\n \"geohashEncode\"\n \"atan2\"\n \"acos\"\ndiff --git a/tests/queries/0_stateless/00534_filimonov.data b/tests/queries/0_stateless/00534_filimonov.data\nindex f07d79ed1bf3..911a8e4d1f34 100644\n--- a/tests/queries/0_stateless/00534_filimonov.data\n+++ b/tests/queries/0_stateless/00534_filimonov.data\n@@ -176,6 +176,7 @@ SELECT toInt16OrZero(NULL);\n SELECT formatReadableSize(NULL);\n SELECT formatReadableQuantity(NULL);\n SELECT formatReadableTimeDelta(NULL);\n+SELECT parseTimeDelta(NULL);\n SELECT concatAssumeInjective(NULL);\n SELECT toString(NULL);\n SELECT MACStringToNum(NULL);\ndiff --git a/tests/queries/0_stateless/02354_parse_timedelta.reference b/tests/queries/0_stateless/02354_parse_timedelta.reference\nnew file mode 100644\nindex 000000000000..9bc208ada9d2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_parse_timedelta.reference\n@@ -0,0 +1,7 @@\n+95\n+11.23\n+41103.1\n+0.00123\n+36806400\n+1331\n+40273293\ndiff --git a/tests/queries/0_stateless/02354_parse_timedelta.sql b/tests/queries/0_stateless/02354_parse_timedelta.sql\nnew file mode 100644\nindex 000000000000..3cf282d715a7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_parse_timedelta.sql\n@@ -0,0 +1,21 @@\n+SELECT parseTimeDelta('1 min 35 sec');\n+SELECT parseTimeDelta('0m;11.23s.');\n+SELECT parseTimeDelta('11hr 25min 3.1s');\n+SELECT parseTimeDelta('0.00123 seconds');\n+SELECT parseTimeDelta('1yr2mo');\n+SELECT parseTimeDelta('11s+22min');\n+SELECT parseTimeDelta('1yr-2mo-4w + 12 days, 3 hours : 1 minute ; 33 seconds');\n+\n+-- invalid expressions\n+SELECT parseTimeDelta(); -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+SELECT parseTimeDelta('1yr', 1); -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+SELECT parseTimeDelta(1); -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT parseTimeDelta(' '); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('-1yr'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1yr-'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('yr2mo'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1.yr2mo'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1-yr'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1 1yr'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1yyr'); -- {serverError BAD_ARGUMENTS}\n+SELECT parseTimeDelta('1yr-2mo-4w + 12 days, 3 hours : 1 minute ;. 33 seconds'); -- {serverError BAD_ARGUMENTS}\n",
  "problem_statement": "`parseTimeDelta` function\nOpposite for `formatReadableTimeDelta`.\r\n\r\n**Use case**\r\n\r\nParsing text inputs.\r\n\r\n**Describe the solution you'd like**\r\n\r\nIt should parse a sequence of numbers followed by something resembling a time unit.\r\n\r\nExamples:\r\n```\r\n1 min 35 sec\r\n0m;11.23s.\r\n11hr 25min 3.1s\r\n0.00123 seconds\r\n1yr2mo\r\n11s+22min\r\n```\r\n\r\nShould return a floating-point number with the number of seconds.\r\n(Subsequently, we can extend it by adding an optional argument describing the desired unit of result).\r\n\r\nIt is allowed to treat units like days and months as somewhat arbitrary lengths (the day will be always 86400 seconds regardless of DST and month will be e.g. 30.5 days, similarly to what `formatReadableTimeDelta` is doing).\r\n\r\nThe function will be named `parseTimeDelta`, not `parseReadableTimeDelta`, because it can be extended to parse something unreadable.\n",
  "hints_text": "Can I try this task? @alexey-milovidov \n@jiahui-97 Thank you, this will be amazing!",
  "created_at": "2022-07-10T11:55:39Z"
}