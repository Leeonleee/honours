{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43221,
  "instance_id": "ClickHouse__ClickHouse-43221",
  "issue_numbers": [
    "14567"
  ],
  "base_commit": "8ee589c5c1f8a042ed777b9d3a59f93101499bc4",
  "patch": "diff --git a/base/base/IPv4andIPv6.h b/base/base/IPv4andIPv6.h\nnew file mode 100644\nindex 000000000000..0e97d83b07ed\n--- /dev/null\n+++ b/base/base/IPv4andIPv6.h\n@@ -0,0 +1,53 @@\n+#pragma once\n+\n+#include <base/strong_typedef.h>\n+#include <base/extended_types.h>\n+#include <Common/memcmpSmall.h>\n+\n+namespace DB\n+{\n+\n+    using IPv4 = StrongTypedef<UInt32, struct IPv4Tag>;\n+\n+    struct IPv6 : StrongTypedef<UInt128, struct IPv6Tag>\n+    {\n+        constexpr IPv6() = default;\n+        constexpr explicit IPv6(const UInt128 & x) : StrongTypedef(x) {}\n+        constexpr explicit IPv6(UInt128 && x) : StrongTypedef(std::move(x)) {}\n+\n+        IPv6 & operator=(const UInt128 & rhs) { StrongTypedef::operator=(rhs); return *this; }\n+        IPv6 & operator=(UInt128 && rhs) { StrongTypedef::operator=(std::move(rhs)); return *this; }\n+\n+        bool operator<(const IPv6 & rhs) const\n+        {\n+            return\n+                memcmp16(\n+                    reinterpret_cast<const unsigned char *>(toUnderType().items),\n+                    reinterpret_cast<const unsigned char *>(rhs.toUnderType().items)\n+                ) < 0;\n+        }\n+\n+        bool operator>(const IPv6 & rhs) const\n+        {\n+            return\n+                memcmp16(\n+                    reinterpret_cast<const unsigned char *>(toUnderType().items),\n+                    reinterpret_cast<const unsigned char *>(rhs.toUnderType().items)\n+                ) > 0;\n+        }\n+\n+        bool operator==(const IPv6 & rhs) const\n+        {\n+            return\n+                memcmp16(\n+                    reinterpret_cast<const unsigned char *>(toUnderType().items),\n+                    reinterpret_cast<const unsigned char *>(rhs.toUnderType().items)\n+                ) == 0;\n+        }\n+\n+        bool operator<=(const IPv6 & rhs) const { return !operator>(rhs); }\n+        bool operator>=(const IPv6 & rhs) const { return !operator<(rhs); }\n+        bool operator!=(const IPv6 & rhs) const { return !operator==(rhs); }\n+    };\n+\n+}\ndiff --git a/base/base/TypeName.h b/base/base/TypeName.h\nindex b3ea47fad5d4..9005b5a2bf40 100644\n--- a/base/base/TypeName.h\n+++ b/base/base/TypeName.h\n@@ -2,6 +2,7 @@\n \n #include \"Decimal.h\"\n #include \"UUID.h\"\n+#include \"IPv4andIPv6.h\"\n \n namespace DB\n {\n@@ -35,6 +36,8 @@ TN_MAP(Float32)\n TN_MAP(Float64)\n TN_MAP(String)\n TN_MAP(UUID)\n+TN_MAP(IPv4)\n+TN_MAP(IPv6)\n TN_MAP(Decimal32)\n TN_MAP(Decimal64)\n TN_MAP(Decimal128)\ndiff --git a/docs/en/sql-reference/functions/ext-dict-functions.md b/docs/en/sql-reference/functions/ext-dict-functions.md\nindex d9e811a5703f..b4b7ec5ab214 100644\n--- a/docs/en/sql-reference/functions/ext-dict-functions.md\n+++ b/docs/en/sql-reference/functions/ext-dict-functions.md\n@@ -416,6 +416,7 @@ Functions:\n -   `dictGetDateTime`\n -   `dictGetUUID`\n -   `dictGetString`\n+-   `dictGetIPv4`, `dictGetIPv6`\n \n All these functions have the `OrDefault` modification. For example, `dictGetDateOrDefault`.\n \ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex 27faf4bd2ad3..a295eeb5c842 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -355,6 +355,8 @@ size_t ColumnUnique<ColumnType>::uniqueInsert(const Field & x)\n         void operator() (const Int128 & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n         void operator() (const Int256 & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n         void operator() (const UUID & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n+        void operator() (const IPv4 & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n+        void operator() (const IPv6 & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n         void operator() (const Float64 & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n         void operator() (const DecimalField<Decimal32> & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\n         void operator() (const DecimalField<Decimal64> & x) { res = {reinterpret_cast<const char *>(&x), sizeof(x)}; }\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex 30e7423fde08..a97da8fe9c68 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -942,5 +942,7 @@ template class ColumnVector<Int256>;\n template class ColumnVector<Float32>;\n template class ColumnVector<Float64>;\n template class ColumnVector<UUID>;\n+template class ColumnVector<IPv4>;\n+template class ColumnVector<IPv6>;\n \n }\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex a601dd8b4058..ded664301607 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -557,5 +557,7 @@ extern template class ColumnVector<Int256>;\n extern template class ColumnVector<Float32>;\n extern template class ColumnVector<Float64>;\n extern template class ColumnVector<UUID>;\n+extern template class ColumnVector<IPv4>;\n+extern template class ColumnVector<IPv6>;\n \n }\ndiff --git a/src/Columns/ColumnsNumber.h b/src/Columns/ColumnsNumber.h\nindex 654d0c73254d..ae7eddb0b22b 100644\n--- a/src/Columns/ColumnsNumber.h\n+++ b/src/Columns/ColumnsNumber.h\n@@ -27,5 +27,7 @@ using ColumnFloat32 = ColumnVector<Float32>;\n using ColumnFloat64 = ColumnVector<Float64>;\n \n using ColumnUUID = ColumnVector<UUID>;\n+using ColumnIPv4 = ColumnVector<IPv4>;\n+using ColumnIPv6 = ColumnVector<IPv6>;\n \n }\ndiff --git a/src/Columns/MaskOperations.cpp b/src/Columns/MaskOperations.cpp\nindex e320e1d57a31..24cb81a6528f 100644\n--- a/src/Columns/MaskOperations.cpp\n+++ b/src/Columns/MaskOperations.cpp\n@@ -72,6 +72,8 @@ INSTANTIATE(Decimal256)\n INSTANTIATE(DateTime64)\n INSTANTIATE(char *)\n INSTANTIATE(UUID)\n+INSTANTIATE(IPv4)\n+INSTANTIATE(IPv6)\n \n #undef INSTANTIATE\n \ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 95333eccbcdd..531d7292ae2c 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -643,6 +643,8 @@\n     M(672, INVALID_SCHEDULER_NODE) \\\n     M(673, RESOURCE_ACCESS_DENIED) \\\n     M(674, RESOURCE_NOT_FOUND) \\\n+    M(675, CANNOT_PARSE_IPV4) \\\n+    M(676, CANNOT_PARSE_IPV6) \\\n     \\\n     M(999, KEEPER_EXCEPTION) \\\n     M(1000, POCO_EXCEPTION) \\\ndiff --git a/src/Common/FieldVisitorConvertToNumber.h b/src/Common/FieldVisitorConvertToNumber.h\nindex 466d312406ef..94071e4f3fa2 100644\n--- a/src/Common/FieldVisitorConvertToNumber.h\n+++ b/src/Common/FieldVisitorConvertToNumber.h\n@@ -55,6 +55,8 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n     T operator() (const Int64 & x) const { return T(x); }\n     T operator() (const Int128 & x) const { return T(x); }\n     T operator() (const UUID & x) const { return T(x.toUnderType()); }\n+    T operator() (const IPv4 & x) const { return T(x.toUnderType()); }\n+    T operator() (const IPv6 & x) const { return T(x.toUnderType()); }\n \n     T operator() (const Float64 & x) const\n     {\ndiff --git a/src/Common/FieldVisitorDump.cpp b/src/Common/FieldVisitorDump.cpp\nindex fc3d56c3503c..be4331ca4783 100644\n--- a/src/Common/FieldVisitorDump.cpp\n+++ b/src/Common/FieldVisitorDump.cpp\n@@ -37,6 +37,8 @@ String FieldVisitorDump::operator() (const UInt256 & x) const { return formatQuo\n String FieldVisitorDump::operator() (const Int128 & x) const { return formatQuotedWithPrefix(x, \"Int128_\"); }\n String FieldVisitorDump::operator() (const Int256 & x) const { return formatQuotedWithPrefix(x, \"Int256_\"); }\n String FieldVisitorDump::operator() (const UUID & x) const { return formatQuotedWithPrefix(x, \"UUID_\"); }\n+String FieldVisitorDump::operator() (const IPv4 & x) const { return formatQuotedWithPrefix(x, \"IPv4_\"); }\n+String FieldVisitorDump::operator() (const IPv6 & x) const { return formatQuotedWithPrefix(x, \"IPv6_\"); }\n String FieldVisitorDump::operator() (const bool & x) const { return formatQuotedWithPrefix(x, \"Bool_\"); }\n \n \ndiff --git a/src/Common/FieldVisitorDump.h b/src/Common/FieldVisitorDump.h\nindex dc67ccf7da33..6ffd91bb400e 100644\n--- a/src/Common/FieldVisitorDump.h\n+++ b/src/Common/FieldVisitorDump.h\n@@ -17,6 +17,8 @@ class FieldVisitorDump : public StaticVisitor<String>\n     String operator() (const Int128 & x) const;\n     String operator() (const Int256 & x) const;\n     String operator() (const UUID & x) const;\n+    String operator() (const IPv4 & x) const;\n+    String operator() (const IPv6 & x) const;\n     String operator() (const Float64 & x) const;\n     String operator() (const String & x) const;\n     String operator() (const Array & x) const;\ndiff --git a/src/Common/FieldVisitorHash.cpp b/src/Common/FieldVisitorHash.cpp\nindex b6750fdcd03a..d759635c65bf 100644\n--- a/src/Common/FieldVisitorHash.cpp\n+++ b/src/Common/FieldVisitorHash.cpp\n@@ -49,6 +49,20 @@ void FieldVisitorHash::operator() (const UUID & x) const\n     hash.update(x);\n }\n \n+void FieldVisitorHash::operator() (const IPv4 & x) const\n+{\n+    UInt8 type = Field::Types::IPv4;\n+    hash.update(type);\n+    hash.update(x);\n+}\n+\n+void FieldVisitorHash::operator() (const IPv6 & x) const\n+{\n+    UInt8 type = Field::Types::IPv6;\n+    hash.update(type);\n+    hash.update(x);\n+}\n+\n void FieldVisitorHash::operator() (const Float64 & x) const\n {\n     UInt8 type = Field::Types::Float64;\ndiff --git a/src/Common/FieldVisitorHash.h b/src/Common/FieldVisitorHash.h\nindex e574b0456eba..1350956146b0 100644\n--- a/src/Common/FieldVisitorHash.h\n+++ b/src/Common/FieldVisitorHash.h\n@@ -23,6 +23,8 @@ class FieldVisitorHash : public StaticVisitor<>\n     void operator() (const Int128 & x) const;\n     void operator() (const Int256 & x) const;\n     void operator() (const UUID & x) const;\n+    void operator() (const IPv4 & x) const;\n+    void operator() (const IPv6 & x) const;\n     void operator() (const Float64 & x) const;\n     void operator() (const String & x) const;\n     void operator() (const Array & x) const;\ndiff --git a/src/Common/FieldVisitorSum.cpp b/src/Common/FieldVisitorSum.cpp\nindex db7b4850204a..ed4dd3730491 100644\n--- a/src/Common/FieldVisitorSum.cpp\n+++ b/src/Common/FieldVisitorSum.cpp\n@@ -33,6 +33,8 @@ bool FieldVisitorSum::operator() (Tuple &) const { throw Exception(\"Cannot sum T\n bool FieldVisitorSum::operator() (Map &) const { throw Exception(\"Cannot sum Maps\", ErrorCodes::LOGICAL_ERROR); }\n bool FieldVisitorSum::operator() (Object &) const { throw Exception(\"Cannot sum Objects\", ErrorCodes::LOGICAL_ERROR); }\n bool FieldVisitorSum::operator() (UUID &) const { throw Exception(\"Cannot sum UUIDs\", ErrorCodes::LOGICAL_ERROR); }\n+bool FieldVisitorSum::operator() (IPv4 &) const { throw Exception(\"Cannot sum IPv4s\", ErrorCodes::LOGICAL_ERROR); }\n+bool FieldVisitorSum::operator() (IPv6 &) const { throw Exception(\"Cannot sum IPv6s\", ErrorCodes::LOGICAL_ERROR); }\n \n bool FieldVisitorSum::operator() (AggregateFunctionStateData &) const\n {\ndiff --git a/src/Common/FieldVisitorSum.h b/src/Common/FieldVisitorSum.h\nindex c28e2058b054..5b9c83d1dd14 100644\n--- a/src/Common/FieldVisitorSum.h\n+++ b/src/Common/FieldVisitorSum.h\n@@ -28,6 +28,8 @@ class FieldVisitorSum : public StaticVisitor<bool>\n     bool operator() (Map &) const;\n     bool operator() (Object &) const;\n     bool operator() (UUID &) const;\n+    bool operator() (IPv4 &) const;\n+    bool operator() (IPv6 &) const;\n     bool operator() (AggregateFunctionStateData &) const;\n     bool operator() (bool &) const;\n \ndiff --git a/src/Common/FieldVisitorToString.cpp b/src/Common/FieldVisitorToString.cpp\nindex e0e138d744ca..d7113b8c7242 100644\n--- a/src/Common/FieldVisitorToString.cpp\n+++ b/src/Common/FieldVisitorToString.cpp\n@@ -65,6 +65,8 @@ String FieldVisitorToString::operator() (const UInt128 & x) const { return forma\n String FieldVisitorToString::operator() (const UInt256 & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const Int256 & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const UUID & x) const { return formatQuoted(x); }\n+String FieldVisitorToString::operator() (const IPv4 & x) const { return formatQuoted(x); }\n+String FieldVisitorToString::operator() (const IPv6 & x) const { return formatQuoted(x); }\n String FieldVisitorToString::operator() (const AggregateFunctionStateData & x) const { return formatQuoted(x.data); }\n String FieldVisitorToString::operator() (const bool & x) const { return x ? \"true\" : \"false\"; }\n \ndiff --git a/src/Common/FieldVisitorToString.h b/src/Common/FieldVisitorToString.h\nindex cca29a8f7e0a..6a10de12ff93 100644\n--- a/src/Common/FieldVisitorToString.h\n+++ b/src/Common/FieldVisitorToString.h\n@@ -17,6 +17,8 @@ class FieldVisitorToString : public StaticVisitor<String>\n     String operator() (const Int128 & x) const;\n     String operator() (const Int256 & x) const;\n     String operator() (const UUID & x) const;\n+    String operator() (const IPv4 & x) const;\n+    String operator() (const IPv6 & x) const;\n     String operator() (const Float64 & x) const;\n     String operator() (const String & x) const;\n     String operator() (const Array & x) const;\ndiff --git a/src/Common/FieldVisitorWriteBinary.cpp b/src/Common/FieldVisitorWriteBinary.cpp\nindex 85c32cee3c01..c9b0cf164141 100644\n--- a/src/Common/FieldVisitorWriteBinary.cpp\n+++ b/src/Common/FieldVisitorWriteBinary.cpp\n@@ -16,6 +16,8 @@ void FieldVisitorWriteBinary::operator() (const Int128 & x, WriteBuffer & buf) c\n void FieldVisitorWriteBinary::operator() (const UInt256 & x, WriteBuffer & buf) const { writeBinary(x, buf); }\n void FieldVisitorWriteBinary::operator() (const Int256 & x, WriteBuffer & buf) const { writeBinary(x, buf); }\n void FieldVisitorWriteBinary::operator() (const UUID & x, WriteBuffer & buf) const { writeBinary(x, buf); }\n+void FieldVisitorWriteBinary::operator() (const IPv4 & x, WriteBuffer & buf) const { writeBinary(x, buf); }\n+void FieldVisitorWriteBinary::operator() (const IPv6 & x, WriteBuffer & buf) const { writeBinary(x, buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal32> & x, WriteBuffer & buf) const { writeBinary(x.getValue(), buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal64> & x, WriteBuffer & buf) const { writeBinary(x.getValue(), buf); }\n void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal128> & x, WriteBuffer & buf) const { writeBinary(x.getValue(), buf); }\ndiff --git a/src/Common/FieldVisitorWriteBinary.h b/src/Common/FieldVisitorWriteBinary.h\nindex ff2740383f7e..bc75150bed2b 100644\n--- a/src/Common/FieldVisitorWriteBinary.h\n+++ b/src/Common/FieldVisitorWriteBinary.h\n@@ -16,6 +16,8 @@ class FieldVisitorWriteBinary\n     void operator() (const Int128 & x, WriteBuffer & buf) const;\n     void operator() (const Int256 & x, WriteBuffer & buf) const;\n     void operator() (const UUID & x, WriteBuffer & buf) const;\n+    void operator() (const IPv4 & x, WriteBuffer & buf) const;\n+    void operator() (const IPv6 & x, WriteBuffer & buf) const;\n     void operator() (const Float64 & x, WriteBuffer & buf) const;\n     void operator() (const String & x, WriteBuffer & buf) const;\n     void operator() (const Array & x, WriteBuffer & buf) const;\ndiff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h\nindex 550eea66a0f3..993c108cf0fa 100644\n--- a/src/Common/HashTable/Hash.h\n+++ b/src/Common/HashTable/Hash.h\n@@ -197,7 +197,7 @@ inline size_t DefaultHash64(T key)\n             static_cast<UInt64>(key) ^\n             static_cast<UInt64>(key >> 64));\n     }\n-    else if constexpr (std::is_same_v<T, DB::UUID>)\n+    else if constexpr (std::is_same_v<T, DB::UUID> || std::is_same_v<T, DB::IPv6>)\n     {\n         return intHash64(\n             static_cast<UInt64>(key.toUnderType()) ^\ndiff --git a/src/Common/formatIPv6.cpp b/src/Common/formatIPv6.cpp\nindex 9c71debaa1e3..cfa93bf49209 100644\n--- a/src/Common/formatIPv6.cpp\n+++ b/src/Common/formatIPv6.cpp\n@@ -9,36 +9,55 @@\n namespace DB\n {\n \n-// To be used in formatIPv4, maps a byte to it's string form prefixed with length (so save strlen call).\n-extern const char one_byte_to_string_lookup_table[256][4] =\n+/** Further we want to generate constexpr array of strings with sizes from sequence of unsigned ints [0..N)\n+ *  in order to use this arrey for fast conversion of unsigned integers to strings\n+ */\n+namespace detail\n {\n-    {1, '0'}, {1, '1'}, {1, '2'}, {1, '3'}, {1, '4'}, {1, '5'}, {1, '6'}, {1, '7'}, {1, '8'}, {1, '9'},\n-    {2, '1', '0'}, {2, '1', '1'}, {2, '1', '2'}, {2, '1', '3'}, {2, '1', '4'}, {2, '1', '5'}, {2, '1', '6'}, {2, '1', '7'}, {2, '1', '8'}, {2, '1', '9'},\n-    {2, '2', '0'}, {2, '2', '1'}, {2, '2', '2'}, {2, '2', '3'}, {2, '2', '4'}, {2, '2', '5'}, {2, '2', '6'}, {2, '2', '7'}, {2, '2', '8'}, {2, '2', '9'},\n-    {2, '3', '0'}, {2, '3', '1'}, {2, '3', '2'}, {2, '3', '3'}, {2, '3', '4'}, {2, '3', '5'}, {2, '3', '6'}, {2, '3', '7'}, {2, '3', '8'}, {2, '3', '9'},\n-    {2, '4', '0'}, {2, '4', '1'}, {2, '4', '2'}, {2, '4', '3'}, {2, '4', '4'}, {2, '4', '5'}, {2, '4', '6'}, {2, '4', '7'}, {2, '4', '8'}, {2, '4', '9'},\n-    {2, '5', '0'}, {2, '5', '1'}, {2, '5', '2'}, {2, '5', '3'}, {2, '5', '4'}, {2, '5', '5'}, {2, '5', '6'}, {2, '5', '7'}, {2, '5', '8'}, {2, '5', '9'},\n-    {2, '6', '0'}, {2, '6', '1'}, {2, '6', '2'}, {2, '6', '3'}, {2, '6', '4'}, {2, '6', '5'}, {2, '6', '6'}, {2, '6', '7'}, {2, '6', '8'}, {2, '6', '9'},\n-    {2, '7', '0'}, {2, '7', '1'}, {2, '7', '2'}, {2, '7', '3'}, {2, '7', '4'}, {2, '7', '5'}, {2, '7', '6'}, {2, '7', '7'}, {2, '7', '8'}, {2, '7', '9'},\n-    {2, '8', '0'}, {2, '8', '1'}, {2, '8', '2'}, {2, '8', '3'}, {2, '8', '4'}, {2, '8', '5'}, {2, '8', '6'}, {2, '8', '7'}, {2, '8', '8'}, {2, '8', '9'},\n-    {2, '9', '0'}, {2, '9', '1'}, {2, '9', '2'}, {2, '9', '3'}, {2, '9', '4'}, {2, '9', '5'}, {2, '9', '6'}, {2, '9', '7'}, {2, '9', '8'}, {2, '9', '9'},\n-    {3, '1', '0', '0'}, {3, '1', '0', '1'}, {3, '1', '0', '2'}, {3, '1', '0', '3'}, {3, '1', '0', '4'}, {3, '1', '0', '5'}, {3, '1', '0', '6'}, {3, '1', '0', '7'}, {3, '1', '0', '8'}, {3, '1', '0', '9'},\n-    {3, '1', '1', '0'}, {3, '1', '1', '1'}, {3, '1', '1', '2'}, {3, '1', '1', '3'}, {3, '1', '1', '4'}, {3, '1', '1', '5'}, {3, '1', '1', '6'}, {3, '1', '1', '7'}, {3, '1', '1', '8'}, {3, '1', '1', '9'},\n-    {3, '1', '2', '0'}, {3, '1', '2', '1'}, {3, '1', '2', '2'}, {3, '1', '2', '3'}, {3, '1', '2', '4'}, {3, '1', '2', '5'}, {3, '1', '2', '6'}, {3, '1', '2', '7'}, {3, '1', '2', '8'}, {3, '1', '2', '9'},\n-    {3, '1', '3', '0'}, {3, '1', '3', '1'}, {3, '1', '3', '2'}, {3, '1', '3', '3'}, {3, '1', '3', '4'}, {3, '1', '3', '5'}, {3, '1', '3', '6'}, {3, '1', '3', '7'}, {3, '1', '3', '8'}, {3, '1', '3', '9'},\n-    {3, '1', '4', '0'}, {3, '1', '4', '1'}, {3, '1', '4', '2'}, {3, '1', '4', '3'}, {3, '1', '4', '4'}, {3, '1', '4', '5'}, {3, '1', '4', '6'}, {3, '1', '4', '7'}, {3, '1', '4', '8'}, {3, '1', '4', '9'},\n-    {3, '1', '5', '0'}, {3, '1', '5', '1'}, {3, '1', '5', '2'}, {3, '1', '5', '3'}, {3, '1', '5', '4'}, {3, '1', '5', '5'}, {3, '1', '5', '6'}, {3, '1', '5', '7'}, {3, '1', '5', '8'}, {3, '1', '5', '9'},\n-    {3, '1', '6', '0'}, {3, '1', '6', '1'}, {3, '1', '6', '2'}, {3, '1', '6', '3'}, {3, '1', '6', '4'}, {3, '1', '6', '5'}, {3, '1', '6', '6'}, {3, '1', '6', '7'}, {3, '1', '6', '8'}, {3, '1', '6', '9'},\n-    {3, '1', '7', '0'}, {3, '1', '7', '1'}, {3, '1', '7', '2'}, {3, '1', '7', '3'}, {3, '1', '7', '4'}, {3, '1', '7', '5'}, {3, '1', '7', '6'}, {3, '1', '7', '7'}, {3, '1', '7', '8'}, {3, '1', '7', '9'},\n-    {3, '1', '8', '0'}, {3, '1', '8', '1'}, {3, '1', '8', '2'}, {3, '1', '8', '3'}, {3, '1', '8', '4'}, {3, '1', '8', '5'}, {3, '1', '8', '6'}, {3, '1', '8', '7'}, {3, '1', '8', '8'}, {3, '1', '8', '9'},\n-    {3, '1', '9', '0'}, {3, '1', '9', '1'}, {3, '1', '9', '2'}, {3, '1', '9', '3'}, {3, '1', '9', '4'}, {3, '1', '9', '5'}, {3, '1', '9', '6'}, {3, '1', '9', '7'}, {3, '1', '9', '8'}, {3, '1', '9', '9'},\n-    {3, '2', '0', '0'}, {3, '2', '0', '1'}, {3, '2', '0', '2'}, {3, '2', '0', '3'}, {3, '2', '0', '4'}, {3, '2', '0', '5'}, {3, '2', '0', '6'}, {3, '2', '0', '7'}, {3, '2', '0', '8'}, {3, '2', '0', '9'},\n-    {3, '2', '1', '0'}, {3, '2', '1', '1'}, {3, '2', '1', '2'}, {3, '2', '1', '3'}, {3, '2', '1', '4'}, {3, '2', '1', '5'}, {3, '2', '1', '6'}, {3, '2', '1', '7'}, {3, '2', '1', '8'}, {3, '2', '1', '9'},\n-    {3, '2', '2', '0'}, {3, '2', '2', '1'}, {3, '2', '2', '2'}, {3, '2', '2', '3'}, {3, '2', '2', '4'}, {3, '2', '2', '5'}, {3, '2', '2', '6'}, {3, '2', '2', '7'}, {3, '2', '2', '8'}, {3, '2', '2', '9'},\n-    {3, '2', '3', '0'}, {3, '2', '3', '1'}, {3, '2', '3', '2'}, {3, '2', '3', '3'}, {3, '2', '3', '4'}, {3, '2', '3', '5'}, {3, '2', '3', '6'}, {3, '2', '3', '7'}, {3, '2', '3', '8'}, {3, '2', '3', '9'},\n-    {3, '2', '4', '0'}, {3, '2', '4', '1'}, {3, '2', '4', '2'}, {3, '2', '4', '3'}, {3, '2', '4', '4'}, {3, '2', '4', '5'}, {3, '2', '4', '6'}, {3, '2', '4', '7'}, {3, '2', '4', '8'}, {3, '2', '4', '9'},\n-    {3, '2', '5', '0'}, {3, '2', '5', '1'}, {3, '2', '5', '2'}, {3, '2', '5', '3'}, {3, '2', '5', '4'}, {3, '2', '5', '5'},\n-};\n+    template <unsigned... digits>\n+    struct ToChars\n+    {\n+        static const char value[];\n+        static const size_t size;\n+     };\n+\n+    template <unsigned... digits>\n+    constexpr char ToChars<digits...>::value[] = {('0' + digits)..., 0};\n+\n+    template <unsigned... digits>\n+    constexpr size_t ToChars<digits...>::size = sizeof...(digits);\n+\n+    template <unsigned rem, unsigned... digits>\n+    struct Decompose : Decompose<rem / 10, rem % 10, digits...> {};\n+\n+    template <unsigned... digits>\n+    struct Decompose<0, digits...> : ToChars<digits...> {};\n+\n+    template <>\n+    struct Decompose<0> : ToChars<0> {};\n+\n+    template <unsigned num>\n+    struct NumToString : Decompose<num> {};\n+\n+    template <class T, T... ints>\n+    consteval std::array<std::pair<const char *, size_t>, sizeof...(ints)> str_make_array_impl(std::integer_sequence<T, ints...>)\n+    {\n+        return std::array<std::pair<const char *, size_t>, sizeof...(ints)> { std::pair<const char *, size_t> {NumToString<ints>::value, NumToString<ints>::size}... };\n+    }\n+}\n+\n+/** str_make_array<N>() - generates static array of std::pair<const char *, size_t> for numbers [0..N), where:\n+ *      first - null-terminated string representing number\n+ *      second - size of the string as would returned by strlen()\n+ */\n+template <size_t N>\n+consteval std::array<std::pair<const char *, size_t>, N> str_make_array()\n+{\n+    return detail::str_make_array_impl(std::make_integer_sequence<int, N>{});\n+}\n+\n+/// This will generate static array of pair<const char *, size_t> for [0..255] at compile time\n+extern constexpr auto one_byte_to_string_lookup_table = str_make_array<256>();\n \n /// integer logarithm, return ceil(log(value, base)) (the smallest integer greater or equal than log(value, base)\n static constexpr UInt32 intLog(const UInt32 value, const UInt32 base, const bool carry)\ndiff --git a/src/Common/formatIPv6.h b/src/Common/formatIPv6.h\nindex 14093594cffb..69963336cefb 100644\n--- a/src/Common/formatIPv6.h\n+++ b/src/Common/formatIPv6.h\n@@ -3,6 +3,7 @@\n #include <base/types.h>\n #include <cstring>\n #include <algorithm>\n+#include <type_traits>\n #include <utility>\n #include <base/range.h>\n #include <base/unaligned.h>\n@@ -17,6 +18,7 @@ constexpr size_t IPV6_MAX_TEXT_LENGTH = 45;     /// Does not count tail zero byt\n namespace DB\n {\n \n+extern const std::array<std::pair<const char *, size_t>, 256> one_byte_to_string_lookup_table;\n \n /** Rewritten inet_ntop6 from http://svn.apache.org/repos/asf/apr/apr/trunk/network_io/unix/inet_pton.c\n   *  performs significantly faster than the reference implementation due to the absence of sprintf calls,\n@@ -30,17 +32,38 @@ void formatIPv6(const unsigned char * src, char *& dst, uint8_t zeroed_tail_byte\n  * which should be long enough.\n  * That is \"127.0.0.1\" becomes 0x7f000001.\n  *\n- * In case of failure returns false and doesn't modify buffer pointed by `dst`.\n+ * In case of failure doesn't modify buffer pointed by `dst`.\n  *\n- * @param src - input string, expected to be non-null and null-terminated right after the IPv4 string value.\n- * @param dst - where to put output bytes, expected to be non-null and at IPV4_BINARY_LENGTH-long.\n- * @return false if parsing failed, true otherwise.\n+ * WARNING - this function is adapted to work with ReadBuffer, where src is the position reference (ReadBuffer::position())\n+ *           and eof is the ReadBuffer::eof() - therefore algorithm below does not rely on buffer's continuity.\n+ *           To parse strings use overloads below.\n+ *\n+ * @param src         - iterator (reference to pointer) over input string - warning - continuity is not guaranteed.\n+ * @param eof         - function returning true if iterator riched the end - warning - can break iterator's continuity.\n+ * @param dst         - where to put output bytes, expected to be non-null and at IPV4_BINARY_LENGTH-long.\n+ * @param first_octet - preparsed first octet\n+ * @return            - true if parsed successfully, false otherwise.\n  */\n-inline bool parseIPv4(const char * src, unsigned char * dst)\n+template <typename T, typename EOFfunction>\n+requires (std::is_same<typename std::remove_cv<T>::type, char>::value)\n+inline bool parseIPv4(T * &src, EOFfunction eof, unsigned char * dst, int32_t first_octet = -1)\n {\n+    if (src == nullptr || first_octet > 255)\n+        return false;\n+\n     UInt32 result = 0;\n-    for (int offset = 24; offset >= 0; offset -= 8)\n+    int offset = 24;\n+    if (first_octet >= 0)\n+    {\n+        result |= first_octet << offset;\n+        offset -= 8;\n+    }\n+\n+    for (; true; offset -= 8, ++src)\n     {\n+        if (eof())\n+            return false;\n+\n         UInt32 value = 0;\n         size_t len = 0;\n         while (isNumericASCII(*src) && len <= 3)\n@@ -48,135 +71,331 @@ inline bool parseIPv4(const char * src, unsigned char * dst)\n             value = value * 10 + (*src - '0');\n             ++len;\n             ++src;\n+            if (eof())\n+                break;\n         }\n-        if (len == 0 || value > 255 || (offset > 0 && *src != '.'))\n+        if (len == 0 || value > 255 || (offset > 0 && (eof() || *src != '.')))\n             return false;\n         result |= value << offset;\n-        ++src;\n+\n+        if (offset == 0)\n+            break;\n     }\n-    if (*(src - 1) != '\\0')\n-        return false;\n \n-    memcpy(dst, &result, sizeof(result));\n+    if constexpr (std::endian::native == std::endian::little)\n+        memcpy(dst, &result, sizeof(result));\n+    else\n+        reverseMemcpy(dst, &result, sizeof(result));\n+\n     return true;\n }\n \n+/// returns pointer to the right after parsed sequence or null on failed parsing\n+inline const char * parseIPv4(const char * src, const char * end, unsigned char * dst)\n+{\n+    if (parseIPv4(src, [&src, end](){ return src == end; }, dst))\n+        return src;\n+    return nullptr;\n+}\n+\n+/// returns true if whole buffer was parsed successfully\n+inline bool parseIPv4whole(const char * src, const char * end, unsigned char * dst)\n+{\n+    return parseIPv4(src, end, dst) == end;\n+}\n+\n+/// returns pointer to the right after parsed sequence or null on failed parsing\n+inline const char * parseIPv4(const char * src, unsigned char * dst)\n+{\n+    if (parseIPv4(src, [](){ return false; }, dst))\n+        return src;\n+    return nullptr;\n+}\n+\n+/// returns true if whole null-terminated string was parsed successfully\n+inline bool parseIPv4whole(const char * src, unsigned char * dst)\n+{\n+    const char * end = parseIPv4(src, dst);\n+    return end != nullptr && *end == '\\0';\n+}\n+\n /** Unsafe (no bounds-checking for src nor dst), optimized version of parsing IPv6 string.\n *\n-* Slightly altered implementation from http://svn.apache.org/repos/asf/apr/apr/trunk/network_io/unix/inet_pton.c\n * Parses the input string `src` and stores binary big-endian value into buffer pointed by `dst`,\n-* which should be long enough. In case of failure zeroes\n-* IPV6_BINARY_LENGTH bytes of buffer pointed by `dst`.\n+* which should be long enough. In case of failure zeroes IPV6_BINARY_LENGTH bytes of buffer pointed by `dst`.\n *\n-* @param src - input string, expected to be non-null and null-terminated right after the IPv6 string value.\n-* @param dst - where to put output bytes, expected to be non-null and at IPV6_BINARY_LENGTH-long.\n-* @return false if parsing failed, true otherwise.\n+* WARNING - this function is adapted to work with ReadBuffer, where src is the position reference (ReadBuffer::position())\n+*           and eof is the ReadBuffer::eof() - therefore algorithm below does not rely on buffer's continuity.\n+*           To parse strings use overloads below.\n+*\n+* @param src         - iterator (reference to pointer) over input string - warning - continuity is not guaranteed.\n+* @param eof         - function returning true if iterator riched the end - warning - can break iterator's continuity.\n+* @param dst         - where to put output bytes, expected to be non-null and at IPV6_BINARY_LENGTH-long.\n+* @param first_block - preparsed first block\n+* @return            - true if parsed successfully, false otherwise.\n */\n-inline bool parseIPv6(const char * src, unsigned char * dst)\n+template <typename T, typename EOFfunction>\n+requires (std::is_same<typename std::remove_cv<T>::type, char>::value)\n+inline bool parseIPv6(T * &src, EOFfunction eof, unsigned char * dst, int32_t first_block = -1)\n {\n     const auto clear_dst = [dst]()\n     {\n-        memset(dst, '\\0', IPV6_BINARY_LENGTH);\n+        std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n         return false;\n     };\n \n-    /// Leading :: requires some special handling.\n-    if (*src == ':')\n-        if (*++src != ':')\n-            return clear_dst();\n+    if (src == nullptr || eof())\n+        return clear_dst();\n \n-    unsigned char tmp[IPV6_BINARY_LENGTH]{};\n-    unsigned char * tp = tmp;\n-    unsigned char * endp = tp + IPV6_BINARY_LENGTH;\n-    const char * curtok = src;\n-    bool saw_xdigit = false;\n-    UInt32 val{};\n-    unsigned char * colonp = nullptr;\n+    int groups = 0;                 /// number of parsed groups\n+    unsigned char * iter = dst;     /// iterator over dst buffer\n+    unsigned char * zptr = nullptr; /// pointer into dst buffer array where all-zeroes block (\"::\") is started\n \n-    /// Assuming zero-terminated string.\n-    while (char ch = *src++)\n+    std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n+\n+    if (first_block >= 0)\n     {\n-        UInt8 num = unhex(ch);\n+        *iter++ = static_cast<unsigned char>((first_block >> 8) & 0xffu);\n+        *iter++ = static_cast<unsigned char>(first_block & 0xffu);\n+        if (*src == ':')\n+        {\n+            zptr = iter;\n+            ++src;\n+        }\n+        ++groups;\n+    }\n+\n+    bool group_start = true;\n \n-        if (num != 0xFF)\n+    while (!eof() && groups < 8)\n+    {\n+        if (*src == ':')\n         {\n-            val <<= 4;\n-            val |= num;\n-            if (val > 0xffffu)\n+            ++src;\n+            if (eof()) /// trailing colon is not allowed\n                 return clear_dst();\n \n-            saw_xdigit = true;\n-            continue;\n-        }\n+            group_start = true;\n \n-        if (ch == ':')\n-        {\n-            curtok = src;\n-            if (!saw_xdigit)\n+            if (*src == ':')\n             {\n-                if (colonp)\n+                if (zptr != nullptr) /// multiple all-zeroes blocks are not allowed\n                     return clear_dst();\n-\n-                colonp = tp;\n+                zptr = iter;\n+                ++src;\n                 continue;\n             }\n-\n-            if (tp + sizeof(UInt16) > endp)\n+            if (groups == 0) /// leading colon is not allowed\n                 return clear_dst();\n-\n-            *tp++ = static_cast<unsigned char>((val >> 8) & 0xffu);\n-            *tp++ = static_cast<unsigned char>(val & 0xffu);\n-            saw_xdigit = false;\n-            val = 0;\n-            continue;\n         }\n \n-        if (ch == '.' && (tp + IPV4_BINARY_LENGTH) <= endp)\n+        if (*src == '.') /// mixed IPv4 parsing\n         {\n-            if (!parseIPv4(curtok, tp))\n+            if (groups <= 1 && zptr == nullptr) /// IPv4 block can't be the first\n+                return clear_dst();\n+\n+            ++src;\n+            if (eof())\n+                return clear_dst();\n+\n+            /// last parsed group should be reinterpreted as a decimal value - it's the first octet of IPv4\n+            --groups;\n+            iter -= 2;\n+\n+            UInt16 num = 0;\n+            for (int i = 0; i < 2; ++i)\n+            {\n+                unsigned char first = (iter[i] >> 4) & 0x0fu;\n+                unsigned char second = iter[i] & 0x0fu;\n+                if (first > 9 || second > 9)\n+                    return clear_dst();\n+                (num *= 100) += first * 10 + second;\n+            }\n+            if (num > 255)\n+                return clear_dst();\n+\n+            /// parse IPv4 with known first octet\n+            if (!parseIPv4(src, eof, iter, num))\n                 return clear_dst();\n \n             if constexpr (std::endian::native == std::endian::little)\n-                std::reverse(tp, tp + IPV4_BINARY_LENGTH);\n+                std::reverse(iter, iter + IPV4_BINARY_LENGTH);\n+\n+            iter += 4;\n+            groups += 2;\n+            break; /// IPv4 block is the last - end of parsing\n+        }\n+\n+        if (!group_start) /// end of parsing\n+            break;\n+        group_start = false;\n+\n+        UInt16 val = 0;   /// current decoded group\n+        int xdigits = 0;  /// number of decoded hex digits in current group\n \n-            tp += IPV4_BINARY_LENGTH;\n-            saw_xdigit = false;\n-            break;    /* '\\0' was seen by ipv4_scan(). */\n+        for (; !eof() && xdigits < 4; ++src, ++xdigits)\n+        {\n+            UInt8 num = unhex(*src);\n+            if (num == 0xFF)\n+                break;\n+            (val <<= 4) |= num;\n         }\n \n+        if (xdigits == 0) /// end of parsing\n+            break;\n+\n+        *iter++ = static_cast<unsigned char>((val >> 8) & 0xffu);\n+        *iter++ = static_cast<unsigned char>(val & 0xffu);\n+        ++groups;\n+    }\n+\n+    /// either all 8 groups or all-zeroes block should be present\n+    if (groups < 8 && zptr == nullptr)\n         return clear_dst();\n+\n+    if (zptr != nullptr) /// process all-zeroes block\n+    {\n+        size_t msize = iter - zptr;\n+        std::memmove(dst + IPV6_BINARY_LENGTH - msize, zptr, msize);\n+        std::memset(zptr, '\\0', IPV6_BINARY_LENGTH - (iter - dst));\n     }\n \n-    if (saw_xdigit)\n+    return true;\n+}\n+\n+/// returns pointer to the right after parsed sequence or null on failed parsing\n+inline const char * parseIPv6(const char * src, const char * end, unsigned char * dst)\n+{\n+    if (parseIPv6(src, [&src, end](){ return src == end; }, dst))\n+        return src;\n+    return nullptr;\n+}\n+\n+/// returns true if whole buffer was parsed successfully\n+inline bool parseIPv6whole(const char * src, const char * end, unsigned char * dst)\n+{\n+    return parseIPv6(src, end, dst) == end;\n+}\n+\n+/// returns pointer to the right after parsed sequence or null on failed parsing\n+inline const char * parseIPv6(const char * src, unsigned char * dst)\n+{\n+    if (parseIPv6(src, [](){ return false; }, dst))\n+        return src;\n+    return nullptr;\n+}\n+\n+/// returns true if whole null-terminated string was parsed successfully\n+inline bool parseIPv6whole(const char * src, unsigned char * dst)\n+{\n+    const char * end = parseIPv6(src, dst);\n+    return end != nullptr && *end == '\\0';\n+}\n+\n+/** Unsafe (no bounds-checking for src nor dst), optimized version of parsing IPv6 string.\n+*\n+* Parses the input string `src` IPv6 or possible IPv4 into IPv6 and stores binary big-endian value into buffer pointed by `dst`,\n+* which should be long enough. In case of failure zeroes IPV6_BINARY_LENGTH bytes of buffer pointed by `dst`.\n+*\n+* WARNING - this function is adapted to work with ReadBuffer, where src is the position reference (ReadBuffer::position())\n+*           and eof is the ReadBuffer::eof() - therefore algorithm below does not rely on buffer's continuity.\n+*\n+* @param src - iterator (reference to pointer) over input string - warning - continuity is not guaranteed.\n+* @param eof - function returning true if iterator riched the end - warning - can break iterator's continuity.\n+* @param dst - where to put output bytes, expected to be non-null and at IPV6_BINARY_LENGTH-long.\n+* @return    - true if parsed successfully, false otherwise.\n+*/\n+template <typename T, typename EOFfunction>\n+requires (std::is_same<typename std::remove_cv<T>::type, char>::value)\n+inline bool parseIPv6orIPv4(T * &src, EOFfunction eof, unsigned char * dst)\n+{\n+    const auto clear_dst = [dst]()\n+    {\n+        std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n+        return false;\n+    };\n+\n+    if (src == nullptr)\n+        return clear_dst();\n+\n+    bool leading_zero = false;\n+    uint16_t val = 0;\n+    int digits = 0;\n+    /// parse up to 4 first digits as hexadecimal\n+    for (; !eof() && digits < 4; ++src, ++digits)\n     {\n-        if (tp + sizeof(UInt16) > endp)\n+        if (*src == ':' || *src == '.')\n+            break;\n+\n+        if (digits == 0 && *src == '0')\n+            leading_zero = true;\n+\n+        UInt8 num = unhex(*src);\n+        if (num == 0xFF)\n             return clear_dst();\n+        (val <<= 4) |= num;\n+    }\n+\n+    if (eof())\n+        return clear_dst();\n \n-        *tp++ = static_cast<unsigned char>((val >> 8) & 0xffu);\n-        *tp++ = static_cast<unsigned char>(val & 0xffu);\n+    if (*src == ':') /// IPv6\n+    {\n+        if (digits == 0) /// leading colon - no preparsed group\n+            return parseIPv6(src, eof, dst);\n+        ++src;\n+        return parseIPv6(src, eof, dst, val); /// parse with first preparsed group\n     }\n \n-    if (colonp)\n+    if (*src == '.') /// IPv4\n     {\n-        /*\n-         * Since some memmove()'s erroneously fail to handle\n-         * overlapping regions, we'll do the shift by hand.\n-         */\n-        const auto n = tp - colonp;\n+        /// should has some digits\n+        if (digits == 0)\n+            return clear_dst();\n+        /// should not has leading zeroes, should has no more than 3 digits\n+        if ((leading_zero && digits > 1) || digits > 3)\n+            return clear_dst();\n \n-        for (int i = 1; i <= n; ++i)\n+        /// recode first group as decimal\n+        UInt16 num = 0;\n+        for (int exp = 1; exp < 1000; exp *= 10)\n         {\n-            endp[- i] = colonp[n - i];\n-            colonp[n - i] = 0;\n+            int n = val & 0x0fu;\n+            if (n > 9)\n+                return clear_dst();\n+            num += n * exp;\n+            val >>= 4;\n         }\n-        tp = endp;\n-    }\n+        if (num > 255)\n+            return clear_dst();\n \n-    if (tp != endp)\n-        return clear_dst();\n+        ++src;\n+        if (!parseIPv4(src, eof, dst, num)) /// try to parse as IPv4 with preparsed first octet\n+            return clear_dst();\n \n-    memcpy(dst, tmp, sizeof(tmp));\n-    return true;\n+        /// convert into IPv6\n+        if constexpr (std::endian::native == std::endian::little)\n+        {\n+            dst[15] = dst[0]; dst[0] = 0;\n+            dst[14] = dst[1]; dst[1] = 0;\n+            dst[13] = dst[2]; dst[2] = 0;\n+            dst[12] = dst[3]; dst[3] = 0;\n+        }\n+        else\n+        {\n+            dst[15] = dst[3]; dst[3] = 0;\n+            dst[14] = dst[2]; dst[2] = 0;\n+            dst[13] = dst[1]; dst[1] = 0;\n+            dst[12] = dst[0]; dst[0] = 0;\n+        }\n+\n+        dst[11] = 0xff;\n+        dst[10] = 0xff;\n+\n+        return true;\n+    }\n+\n+    return clear_dst();\n }\n \n /** Format 4-byte binary sequesnce as IPv4 text: 'aaa.bbb.ccc.ddd',\n@@ -198,22 +417,27 @@ inline bool parseIPv6(const char * src, unsigned char * dst)\n   *     formatIPv4(&0x7f000001, dst, mask_tail_octets = 1, \"0\");\n   *         > dst == \"127.0.0.0\"\n   */\n-inline void formatIPv4(const unsigned char * src, char *& dst, uint8_t mask_tail_octets = 0, const char * mask_string = \"xxx\")\n+inline void formatIPv4(const unsigned char * src, size_t src_size, char *& dst, uint8_t mask_tail_octets = 0, const char * mask_string = \"xxx\")\n {\n-    extern const char one_byte_to_string_lookup_table[256][4];\n-\n     const size_t mask_length = mask_string ? strlen(mask_string) : 0;\n     const size_t limit = std::min(IPV4_BINARY_LENGTH, IPV4_BINARY_LENGTH - mask_tail_octets);\n-    for (size_t octet = 0; octet < limit; ++octet)\n+    const size_t padding = std::min(4 - src_size, limit);\n+\n+    for (size_t octet = 0; octet < padding; ++octet)\n+    {\n+        *dst++ = '0';\n+        *dst++ = '.';\n+    }\n+\n+    for (size_t octet = 4 - src_size; octet < limit; ++octet)\n     {\n         uint8_t value = 0;\n         if constexpr (std::endian::native == std::endian::little)\n             value = static_cast<uint8_t>(src[IPV4_BINARY_LENGTH - octet - 1]);\n         else\n             value = static_cast<uint8_t>(src[octet]);\n-        const auto * rep = one_byte_to_string_lookup_table[value];\n-        const uint8_t len = rep[0];\n-        const char* str = rep + 1;\n+        const uint8_t len = one_byte_to_string_lookup_table[value].second;\n+        const char* str = one_byte_to_string_lookup_table[value].first;\n \n         memcpy(dst, str, len);\n         dst += len;\n@@ -231,4 +455,9 @@ inline void formatIPv4(const unsigned char * src, char *& dst, uint8_t mask_tail\n     dst[-1] = '\\0';\n }\n \n+inline void formatIPv4(const unsigned char * src, char *& dst, uint8_t mask_tail_octets = 0, const char * mask_string = \"xxx\")\n+{\n+    formatIPv4(src, 4, dst, mask_tail_octets, mask_string);\n+}\n+\n }\ndiff --git a/src/Common/typeid_cast.h b/src/Common/typeid_cast.h\nindex 3c3f236f7408..75bc9eb22b16 100644\n--- a/src/Common/typeid_cast.h\n+++ b/src/Common/typeid_cast.h\n@@ -18,6 +18,9 @@ namespace DB\n     }\n }\n \n+template<typename T, typename ... U>\n+concept is_any_of = (std::same_as<T, U> || ...);\n+\n \n /** Checks type by comparing typeid.\n   * The exact match of the type is checked. That is, cast to the ancestor will be unsuccessful.\ndiff --git a/src/Core/Field.cpp b/src/Core/Field.cpp\nindex 71a6d27e5b48..c1842d7e4938 100644\n--- a/src/Core/Field.cpp\n+++ b/src/Core/Field.cpp\n@@ -51,6 +51,18 @@ inline Field getBinaryValue(UInt8 type, ReadBuffer & buf)\n             readBinary(value, buf);\n             return value;\n         }\n+        case Field::Types::IPv4:\n+        {\n+            IPv4 value;\n+            readBinary(value, buf);\n+            return value;\n+        }\n+        case Field::Types::IPv6:\n+        {\n+            IPv6 value;\n+            readBinary(value.toUnderType(), buf);\n+            return value;\n+        }\n         case Field::Types::Int64:\n         {\n             Int64 value;\n@@ -583,6 +595,8 @@ String fieldTypeToString(Field::Types::Which type)\n         case Field::Types::Which::UInt128: return \"UInt128\";\n         case Field::Types::Which::UInt256: return \"UInt256\";\n         case Field::Types::Which::UUID: return \"UUID\";\n+        case Field::Types::Which::IPv4: return \"IPv4\";\n+        case Field::Types::Which::IPv6: return \"IPv6\";\n     }\n }\n \ndiff --git a/src/Core/Field.h b/src/Core/Field.h\nindex c3516b705a64..3c787389ef64 100644\n--- a/src/Core/Field.h\n+++ b/src/Core/Field.h\n@@ -13,6 +13,7 @@\n #include <Core/Defines.h>\n #include <Core/DecimalFunctions.h>\n #include <Core/UUID.h>\n+#include <base/IPv4andIPv6.h>\n #include <base/DayNum.h>\n #include <base/strong_typedef.h>\n #include <base/EnumReflection.h>\n@@ -192,6 +193,8 @@ template <> struct NearestFieldTypeImpl<UInt32> { using Type = UInt64; };\n \n template <> struct NearestFieldTypeImpl<DayNum> { using Type = UInt64; };\n template <> struct NearestFieldTypeImpl<UUID> { using Type = UUID; };\n+template <> struct NearestFieldTypeImpl<IPv4> { using Type = IPv4; };\n+template <> struct NearestFieldTypeImpl<IPv6> { using Type = IPv6; };\n template <> struct NearestFieldTypeImpl<Int16> { using Type = Int64; };\n template <> struct NearestFieldTypeImpl<Int32> { using Type = Int64; };\n \n@@ -292,6 +295,8 @@ class Field\n             UUID = 27,\n             Bool = 28,\n             Object = 29,\n+            IPv4 = 30,\n+            IPv6 = 31,\n         };\n     };\n \n@@ -468,6 +473,8 @@ class Field\n             case Types::Int128:  return get<Int128>()  < rhs.get<Int128>();\n             case Types::Int256:  return get<Int256>()  < rhs.get<Int256>();\n             case Types::UUID:    return get<UUID>()    < rhs.get<UUID>();\n+            case Types::IPv4:    return get<IPv4>()    < rhs.get<IPv4>();\n+            case Types::IPv6:    return get<IPv6>()    < rhs.get<IPv6>();\n             case Types::Float64: return get<Float64>() < rhs.get<Float64>();\n             case Types::String:  return get<String>()  < rhs.get<String>();\n             case Types::Array:   return get<Array>()   < rhs.get<Array>();\n@@ -507,6 +514,8 @@ class Field\n             case Types::Int128:  return get<Int128>()  <= rhs.get<Int128>();\n             case Types::Int256:  return get<Int256>()  <= rhs.get<Int256>();\n             case Types::UUID:    return get<UUID>().toUnderType() <= rhs.get<UUID>().toUnderType();\n+            case Types::IPv4:    return get<IPv4>()    <= rhs.get<IPv4>();\n+            case Types::IPv6:    return get<IPv6>()    <= rhs.get<IPv6>();\n             case Types::Float64: return get<Float64>() <= rhs.get<Float64>();\n             case Types::String:  return get<String>()  <= rhs.get<String>();\n             case Types::Array:   return get<Array>()   <= rhs.get<Array>();\n@@ -547,6 +556,8 @@ class Field\n                 return std::bit_cast<UInt64>(get<Float64>()) == std::bit_cast<UInt64>(rhs.get<Float64>());\n             }\n             case Types::UUID:    return get<UUID>()    == rhs.get<UUID>();\n+            case Types::IPv4:    return get<IPv4>()    == rhs.get<IPv4>();\n+            case Types::IPv6:    return get<IPv6>()    == rhs.get<IPv6>();\n             case Types::String:  return get<String>()  == rhs.get<String>();\n             case Types::Array:   return get<Array>()   == rhs.get<Array>();\n             case Types::Tuple:   return get<Tuple>()   == rhs.get<Tuple>();\n@@ -586,6 +597,8 @@ class Field\n             case Types::Int128:  return f(field.template get<Int128>());\n             case Types::Int256:  return f(field.template get<Int256>());\n             case Types::UUID:    return f(field.template get<UUID>());\n+            case Types::IPv4:    return f(field.template get<IPv4>());\n+            case Types::IPv6:    return f(field.template get<IPv6>());\n             case Types::Float64: return f(field.template get<Float64>());\n             case Types::String:  return f(field.template get<String>());\n             case Types::Array:   return f(field.template get<Array>());\n@@ -612,7 +625,7 @@ class Field\n \n private:\n     std::aligned_union_t<DBMS_MIN_FIELD_SIZE - sizeof(Types::Which),\n-        Null, UInt64, UInt128, UInt256, Int64, Int128, Int256, UUID, Float64, String, Array, Tuple, Map,\n+        Null, UInt64, UInt128, UInt256, Int64, Int128, Int256, UUID, IPv4, IPv6, Float64, String, Array, Tuple, Map,\n         DecimalField<Decimal32>, DecimalField<Decimal64>, DecimalField<Decimal128>, DecimalField<Decimal256>,\n         AggregateFunctionStateData\n         > storage;\n@@ -747,6 +760,8 @@ template <> struct Field::TypeToEnum<Int64>   { static constexpr Types::Which va\n template <> struct Field::TypeToEnum<Int128>  { static constexpr Types::Which value = Types::Int128; };\n template <> struct Field::TypeToEnum<Int256>  { static constexpr Types::Which value = Types::Int256; };\n template <> struct Field::TypeToEnum<UUID>    { static constexpr Types::Which value = Types::UUID; };\n+template <> struct Field::TypeToEnum<IPv4>    { static constexpr Types::Which value = Types::IPv4; };\n+template <> struct Field::TypeToEnum<IPv6>    { static constexpr Types::Which value = Types::IPv6; };\n template <> struct Field::TypeToEnum<Float64> { static constexpr Types::Which value = Types::Float64; };\n template <> struct Field::TypeToEnum<String>  { static constexpr Types::Which value = Types::String; };\n template <> struct Field::TypeToEnum<Array>   { static constexpr Types::Which value = Types::Array; };\n@@ -769,6 +784,8 @@ template <> struct Field::EnumToType<Field::Types::Int64>   { using Type = Int64\n template <> struct Field::EnumToType<Field::Types::Int128>  { using Type = Int128; };\n template <> struct Field::EnumToType<Field::Types::Int256>  { using Type = Int256; };\n template <> struct Field::EnumToType<Field::Types::UUID>    { using Type = UUID; };\n+template <> struct Field::EnumToType<Field::Types::IPv4>    { using Type = IPv4; };\n+template <> struct Field::EnumToType<Field::Types::IPv6>    { using Type = IPv6; };\n template <> struct Field::EnumToType<Field::Types::Float64> { using Type = Float64; };\n template <> struct Field::EnumToType<Field::Types::String>  { using Type = String; };\n template <> struct Field::EnumToType<Field::Types::Array>   { using Type = Array; };\ndiff --git a/src/Core/SortCursor.h b/src/Core/SortCursor.h\nindex abd3e3c85f82..3c412fa1f17d 100644\n--- a/src/Core/SortCursor.h\n+++ b/src/Core/SortCursor.h\n@@ -20,6 +20,7 @@\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <Columns/IColumn.h>\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnString.h>\n@@ -696,6 +697,8 @@ class SortQueueVariants\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnDecimal<DateTime64>>, strategy>,\n \n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<UUID>>, strategy>,\n+        SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<IPv4>>, strategy>,\n+        SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<IPv6>>, strategy>,\n \n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnString>, strategy>,\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnFixedString>, strategy>,\ndiff --git a/src/Core/TypeId.h b/src/Core/TypeId.h\nindex 390587731842..d2ae56b42809 100644\n--- a/src/Core/TypeId.h\n+++ b/src/Core/TypeId.h\n@@ -47,6 +47,8 @@ TYPEID_MAP(Int256)\n TYPEID_MAP(Float32)\n TYPEID_MAP(Float64)\n TYPEID_MAP(UUID)\n+TYPEID_MAP(IPv4)\n+TYPEID_MAP(IPv6)\n \n TYPEID_MAP(Decimal32)\n TYPEID_MAP(Decimal64)\ndiff --git a/src/Core/Types.h b/src/Core/Types.h\nindex 1eddd431c862..cd559661a965 100644\n--- a/src/Core/Types.h\n+++ b/src/Core/Types.h\n@@ -8,6 +8,7 @@\n #include <base/Decimal.h>\n #include <base/defines.h>\n #include <base/UUID.h>\n+#include <base/IPv4andIPv6.h>\n \n \n namespace DB\n@@ -84,6 +85,8 @@ enum class TypeIndex\n     LowCardinality,\n     Map,\n     Object,\n+    IPv4,\n+    IPv6,\n };\n \n \ndiff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex 2634578f3252..d01f8907a5c8 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -160,6 +160,9 @@ class DataTypeDate32;\n class DataTypeString;\n class DataTypeFixedString;\n class DataTypeUUID;\n+template <typename IPv> class DataTypeIP;\n+using DataTypeIPv4 = DataTypeIP<IPv4>;\n+using DataTypeIPv6 = DataTypeIP<IPv6>;\n class DataTypeDateTime;\n class DataTypeDateTime64;\n template <typename T> class DataTypeEnum;\n@@ -206,6 +209,8 @@ bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)\n         case TypeIndex::Enum16:         return f(TypePair<DataTypeEnum<Int16>, T>(), std::forward<ExtraArgs>(args)...);\n \n         case TypeIndex::UUID:           return f(TypePair<DataTypeUUID, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::IPv4:           return f(TypePair<DataTypeIPv4, T>(), std::forward<ExtraArgs>(args)...);\n+        case TypeIndex::IPv6:           return f(TypePair<DataTypeIPv6, T>(), std::forward<ExtraArgs>(args)...);\n \n         default:\n             break;\ndiff --git a/src/DataTypes/DataTypeCustomIPv4AndIPv6.cpp b/src/DataTypes/DataTypeCustomIPv4AndIPv6.cpp\ndeleted file mode 100644\nindex 808aa43528ef..000000000000\n--- a/src/DataTypes/DataTypeCustomIPv4AndIPv6.cpp\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-#include <DataTypes/Serializations/SerializationIP.h>\n-#include <DataTypes/DataTypeFactory.h>\n-#include <DataTypes/DataTypeCustom.h>\n-\n-namespace DB\n-{\n-\n-void registerDataTypeDomainIPv4AndIPv6(DataTypeFactory & factory)\n-{\n-    factory.registerSimpleDataTypeCustom(\"IPv4\", []\n-    {\n-        auto type = DataTypeFactory::instance().get(\"UInt32\");\n-        return std::make_pair(type, std::make_unique<DataTypeCustomDesc>(\n-            std::make_unique<DataTypeCustomFixedName>(\"IPv4\"), std::make_unique<SerializationIPv4>(type->getDefaultSerialization())));\n-    });\n-\n-    factory.registerSimpleDataTypeCustom(\"IPv6\", []\n-    {\n-        auto type = DataTypeFactory::instance().get(\"FixedString(16)\");\n-        return std::make_pair(type, std::make_unique<DataTypeCustomDesc>(\n-            std::make_unique<DataTypeCustomFixedName>(\"IPv6\"), std::make_unique<SerializationIPv6>(type->getDefaultSerialization())));\n-    });\n-\n-    /// MySQL, MariaDB\n-    factory.registerAlias(\"INET4\", \"IPv4\", DataTypeFactory::CaseInsensitive);\n-    factory.registerAlias(\"INET6\", \"IPv6\", DataTypeFactory::CaseInsensitive);\n-}\n-\n-}\ndiff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp\nindex 9f60210f8d67..2042e571bebc 100644\n--- a/src/DataTypes/DataTypeFactory.cpp\n+++ b/src/DataTypes/DataTypeFactory.cpp\n@@ -208,11 +208,11 @@ DataTypeFactory::DataTypeFactory()\n     registerDataTypeNullable(*this);\n     registerDataTypeNothing(*this);\n     registerDataTypeUUID(*this);\n+    registerDataTypeIPv4andIPv6(*this);\n     registerDataTypeAggregateFunction(*this);\n     registerDataTypeNested(*this);\n     registerDataTypeInterval(*this);\n     registerDataTypeLowCardinality(*this);\n-    registerDataTypeDomainIPv4AndIPv6(*this);\n     registerDataTypeDomainBool(*this);\n     registerDataTypeDomainSimpleAggregateFunction(*this);\n     registerDataTypeDomainGeo(*this);\ndiff --git a/src/DataTypes/DataTypeFactory.h b/src/DataTypes/DataTypeFactory.h\nindex f452f6167c7e..af5c0cc99c64 100644\n--- a/src/DataTypes/DataTypeFactory.h\n+++ b/src/DataTypes/DataTypeFactory.h\n@@ -79,11 +79,11 @@ void registerDataTypeMap(DataTypeFactory & factory);\n void registerDataTypeNullable(DataTypeFactory & factory);\n void registerDataTypeNothing(DataTypeFactory & factory);\n void registerDataTypeUUID(DataTypeFactory & factory);\n+void registerDataTypeIPv4andIPv6(DataTypeFactory & factory);\n void registerDataTypeAggregateFunction(DataTypeFactory & factory);\n void registerDataTypeNested(DataTypeFactory & factory);\n void registerDataTypeInterval(DataTypeFactory & factory);\n void registerDataTypeLowCardinality(DataTypeFactory & factory);\n-void registerDataTypeDomainIPv4AndIPv6(DataTypeFactory & factory);\n void registerDataTypeDomainBool(DataTypeFactory & factory);\n void registerDataTypeDomainSimpleAggregateFunction(DataTypeFactory & factory);\n void registerDataTypeDomainGeo(DataTypeFactory & factory);\ndiff --git a/src/DataTypes/DataTypeIPv4andIPv6.cpp b/src/DataTypes/DataTypeIPv4andIPv6.cpp\nnew file mode 100644\nindex 000000000000..4c0b45f472aa\n--- /dev/null\n+++ b/src/DataTypes/DataTypeIPv4andIPv6.cpp\n@@ -0,0 +1,17 @@\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n+#include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/Serializations/SerializationIPv4andIPv6.h>\n+\n+\n+namespace DB\n+{\n+\n+void registerDataTypeIPv4andIPv6(DataTypeFactory & factory)\n+{\n+    factory.registerSimpleDataType(\"IPv4\", [] { return DataTypePtr(std::make_shared<DataTypeIPv4>()); });\n+    factory.registerAlias(\"INET4\", \"IPv4\", DataTypeFactory::CaseInsensitive);\n+    factory.registerSimpleDataType(\"IPv6\", [] { return DataTypePtr(std::make_shared<DataTypeIPv6>()); });\n+    factory.registerAlias(\"INET6\", \"IPv6\", DataTypeFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/src/DataTypes/DataTypeIPv4andIPv6.h b/src/DataTypes/DataTypeIPv4andIPv6.h\nnew file mode 100644\nindex 000000000000..b8eacc3ee805\n--- /dev/null\n+++ b/src/DataTypes/DataTypeIPv4andIPv6.h\n@@ -0,0 +1,53 @@\n+#pragma once\n+\n+#include <DataTypes/IDataType.h>\n+#include <Columns/ColumnVector.h>\n+#include <base/IPv4andIPv6.h>\n+#include <DataTypes/Serializations/SerializationIPv4andIPv6.h>\n+\n+\n+namespace DB\n+{\n+\n+template <typename IPv>\n+class DataTypeIP : public IDataType\n+{\n+public:\n+    static constexpr bool is_parametric = false;\n+\n+    using FieldType = IPv;\n+    using ColumnType = ColumnVector<IPv>;\n+    static constexpr auto type_id = TypeToTypeIndex<IPv>;\n+\n+    const char * getFamilyName() const override { return TypeName<IPv>.data(); }\n+    TypeIndex getTypeId() const override { return type_id; }\n+\n+    Field getDefault() const override { return IPv{}; }\n+\n+    MutableColumnPtr createColumn() const override {return ColumnVector<IPv>::create();}\n+\n+    bool isParametric() const override { return false; }\n+    bool haveSubtypes() const override { return false; }\n+\n+    bool equals(const IDataType & rhs) const override { return typeid(rhs) == typeid(*this); }\n+\n+    bool canBeUsedInBitOperations() const override { return true; }\n+    bool canBeInsideNullable() const override { return true; }\n+    bool canBePromoted() const override { return false; }\n+    bool shouldAlignRightInPrettyFormats() const override { return false; }\n+    bool textCanContainOnlyValidUTF8() const override { return true; }\n+    bool isComparable() const override { return true; }\n+    bool isValueUnambiguouslyRepresentedInContiguousMemoryRegion() const override { return true; }\n+    bool isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion() const override { return true; }\n+    bool haveMaximumSizeOfValue() const override { return true; }\n+    size_t getSizeOfValueInMemory() const override { return sizeof(IPv); }\n+    bool isCategorial() const override { return true; }\n+    bool canBeInsideLowCardinality() const override { return true; }\n+\n+    SerializationPtr doGetDefaultSerialization() const override { return std::make_shared<SerializationIP<IPv>>(); }\n+};\n+\n+using DataTypeIPv4 = DataTypeIP<IPv4>;\n+using DataTypeIPv6 = DataTypeIP<IPv6>;\n+\n+}\ndiff --git a/src/DataTypes/DataTypeLowCardinality.cpp b/src/DataTypes/DataTypeLowCardinality.cpp\nindex a618bfe3ed46..bd65196580bd 100644\n--- a/src/DataTypes/DataTypeLowCardinality.cpp\n+++ b/src/DataTypes/DataTypeLowCardinality.cpp\n@@ -84,6 +84,10 @@ MutableColumnUniquePtr DataTypeLowCardinality::createColumnUniqueImpl(const IDat\n         return creator(static_cast<ColumnVector<UInt32> *>(nullptr));\n     else if (which.isUUID())\n         return creator(static_cast<ColumnVector<UUID> *>(nullptr));\n+    else if (which.isIPv4())\n+        return creator(static_cast<ColumnVector<IPv4> *>(nullptr));\n+    else if (which.isIPv6())\n+        return creator(static_cast<ColumnVector<IPv6> *>(nullptr));\n     else if (which.isInterval())\n         return creator(static_cast<DataTypeInterval::ColumnType *>(nullptr));\n     else if (which.isInt() || which.isUInt() || which.isFloat())\ndiff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp\nindex 49ece27cc1f5..a5ea920a45fc 100644\n--- a/src/DataTypes/FieldToDataType.cpp\n+++ b/src/DataTypes/FieldToDataType.cpp\n@@ -9,6 +9,7 @@\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeNothing.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <Common/Exception.h>\n@@ -82,6 +83,18 @@ DataTypePtr FieldToDataType<on_error>::operator() (const UUID &) const\n     return std::make_shared<DataTypeUUID>();\n }\n \n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const IPv4 &) const\n+{\n+    return std::make_shared<DataTypeIPv4>();\n+}\n+\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const IPv6 &) const\n+{\n+    return std::make_shared<DataTypeIPv6>();\n+}\n+\n template <LeastSupertypeOnError on_error>\n DataTypePtr FieldToDataType<on_error>::operator() (const String &) const\n {\ndiff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h\nindex 5e66fe420ad4..bd7d5b1af853 100644\n--- a/src/DataTypes/FieldToDataType.h\n+++ b/src/DataTypes/FieldToDataType.h\n@@ -28,6 +28,8 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>\n     DataTypePtr operator() (const Int64 & x) const;\n     DataTypePtr operator() (const Int128 & x) const;\n     DataTypePtr operator() (const UUID & x) const;\n+    DataTypePtr operator() (const IPv4 & x) const;\n+    DataTypePtr operator() (const IPv6 & x) const;\n     DataTypePtr operator() (const Float64 & x) const;\n     DataTypePtr operator() (const String & x) const;\n     DataTypePtr operator() (const Array & x) const;\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 7440896b4c96..bafe03dbc3a9 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -377,6 +377,8 @@ struct WhichDataType\n     constexpr bool isStringOrFixedString() const { return isString() || isFixedString(); }\n \n     constexpr bool isUUID() const { return idx == TypeIndex::UUID; }\n+    constexpr bool isIPv4() const { return idx == TypeIndex::IPv4; }\n+    constexpr bool isIPv6() const { return idx == TypeIndex::IPv6; }\n     constexpr bool isArray() const { return idx == TypeIndex::Array; }\n     constexpr bool isTuple() const { return idx == TypeIndex::Tuple; }\n     constexpr bool isMap() const {return idx == TypeIndex::Map; }\n@@ -414,6 +416,8 @@ inline bool isMap(const DataTypePtr & data_type) {return WhichDataType(data_type\n inline bool isInterval(const DataTypePtr & data_type) {return WhichDataType(data_type).isInterval(); }\n inline bool isNothing(const DataTypePtr & data_type) { return WhichDataType(data_type).isNothing(); }\n inline bool isUUID(const DataTypePtr & data_type) { return WhichDataType(data_type).isUUID(); }\n+inline bool isIPv4(const DataTypePtr & data_type) { return WhichDataType(data_type).isIPv4(); }\n+inline bool isIPv6(const DataTypePtr & data_type) { return WhichDataType(data_type).isIPv6(); }\n \n template <typename T>\n inline bool isObject(const T & data_type)\n@@ -479,7 +483,7 @@ template <typename T>\n inline bool isColumnedAsNumber(const T & data_type)\n {\n     WhichDataType which(data_type);\n-    return which.isInt() || which.isUInt() || which.isFloat() || which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isUUID();\n+    return which.isInt() || which.isUInt() || which.isFloat() || which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isUUID() || which.isIPv4() || which.isIPv6();\n }\n \n template <typename T>\ndiff --git a/src/DataTypes/Serializations/SerializationIP.cpp b/src/DataTypes/Serializations/SerializationIP.cpp\ndeleted file mode 100644\nindex c89c2d7c8acf..000000000000\n--- a/src/DataTypes/Serializations/SerializationIP.cpp\n+++ /dev/null\n@@ -1,109 +0,0 @@\n-#include <DataTypes/Serializations/SerializationIP.h>\n-\n-#include <Columns/ColumnsNumber.h>\n-#include <Columns/ColumnFixedString.h>\n-#include <Common/Exception.h>\n-#include <Common/formatIPv6.h>\n-#include <IO/WriteBuffer.h>\n-#include <IO/ReadBuffer.h>\n-#include <Formats/FormatSettings.h>\n-\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n-    extern const int ILLEGAL_COLUMN;\n-}\n-\n-SerializationIPv4::SerializationIPv4(const SerializationPtr & nested_)\n-    : SerializationCustomSimpleText(nested_)\n-{\n-}\n-\n-void SerializationIPv4::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const\n-{\n-    const auto * col = checkAndGetColumn<ColumnUInt32>(&column);\n-    if (!col)\n-    {\n-        throw Exception(\"IPv4 type can only serialize columns of type UInt32.\" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);\n-    }\n-\n-    char buffer[IPV4_MAX_TEXT_LENGTH + 1] = {'\\0'};\n-    char * ptr = buffer;\n-    formatIPv4(reinterpret_cast<const unsigned char *>(&col->getData()[row_num]), ptr);\n-\n-    ostr.write(buffer, strlen(buffer));\n-}\n-\n-void SerializationIPv4::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, bool whole) const\n-{\n-    ColumnUInt32 * col = typeid_cast<ColumnUInt32 *>(&column);\n-    if (!col)\n-    {\n-        throw Exception(\"IPv4 type can only deserialize columns of type UInt32.\" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);\n-    }\n-\n-    char buffer[IPV4_MAX_TEXT_LENGTH + 1] = {'\\0'};\n-    [[maybe_unused]] size_t read_bytes = istr.read(buffer, sizeof(buffer) - 1);\n-    UInt32 ipv4_value = 0;\n-\n-    bool parse_result = parseIPv4(buffer, reinterpret_cast<unsigned char *>(&ipv4_value));\n-    if (!parse_result && !settings.input_format_ipv4_default_on_conversion_error)\n-    {\n-        throw Exception(\"Invalid IPv4 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n-    }\n-\n-    col->insert(ipv4_value);\n-\n-    if (whole && !istr.eof())\n-        throwUnexpectedDataAfterParsedValue(column, istr, settings, \"IPv4\");\n-}\n-\n-SerializationIPv6::SerializationIPv6(const SerializationPtr & nested_)\n-    : SerializationCustomSimpleText(nested_)\n-{\n-}\n-void SerializationIPv6::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const\n-{\n-    const auto * col = checkAndGetColumn<ColumnFixedString>(&column);\n-    if (!col)\n-    {\n-        throw Exception(\"IPv6 type domain can only serialize columns of type FixedString(16).\" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);\n-    }\n-\n-    char buffer[IPV6_MAX_TEXT_LENGTH + 1] = {'\\0'};\n-    char * ptr = buffer;\n-    formatIPv6(reinterpret_cast<const unsigned char *>(col->getDataAt(row_num).data), ptr);\n-\n-    ostr.write(buffer, strlen(buffer));\n-}\n-\n-void SerializationIPv6::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, bool whole) const\n-{\n-    ColumnFixedString * col = typeid_cast<ColumnFixedString *>(&column);\n-    if (!col)\n-    {\n-        throw Exception(\"IPv6 type domain can only deserialize columns of type FixedString(16).\" + column.getName(), ErrorCodes::ILLEGAL_COLUMN);\n-    }\n-\n-    char buffer[IPV6_MAX_TEXT_LENGTH + 1] = {'\\0'};\n-    [[maybe_unused]] size_t read_bytes = istr.read(buffer, sizeof(buffer) - 1);\n-\n-    std::string ipv6_value(IPV6_BINARY_LENGTH, '\\0');\n-\n-    bool parse_result = parseIPv6(buffer, reinterpret_cast<unsigned char *>(ipv6_value.data()));\n-    if (!parse_result && !settings.input_format_ipv6_default_on_conversion_error)\n-    {\n-        throw Exception(\"Invalid IPv6 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n-    }\n-\n-    col->insertString(ipv6_value);\n-\n-    if (whole && !istr.eof())\n-        throwUnexpectedDataAfterParsedValue(column, istr, settings, \"IPv6\");\n-}\n-\n-}\ndiff --git a/src/DataTypes/Serializations/SerializationIP.h b/src/DataTypes/Serializations/SerializationIP.h\ndeleted file mode 100644\nindex 282105b6b1e9..000000000000\n--- a/src/DataTypes/Serializations/SerializationIP.h\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-#pragma once\n-\n-#include <DataTypes/Serializations/SerializationCustomSimpleText.h>\n-\n-namespace DB\n-{\n-\n-class SerializationIPv4 final : public SerializationCustomSimpleText\n-{\n-public:\n-    explicit SerializationIPv4(const SerializationPtr & nested_);\n-\n-    void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n-    void deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, bool whole) const override;\n-};\n-\n-class SerializationIPv6 : public SerializationCustomSimpleText\n-{\n-public:\n-    explicit SerializationIPv6(const SerializationPtr & nested_);\n-\n-    void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n-    void deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, bool whole) const override;\n-};\n-\n-}\ndiff --git a/src/DataTypes/Serializations/SerializationIPv4andIPv6.h b/src/DataTypes/Serializations/SerializationIPv4andIPv6.h\nnew file mode 100644\nindex 000000000000..2c0df0f76edf\n--- /dev/null\n+++ b/src/DataTypes/Serializations/SerializationIPv4andIPv6.h\n@@ -0,0 +1,134 @@\n+#pragma once\n+\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <base/TypeName.h>\n+\n+namespace DB\n+{\n+\n+template <typename IPv>\n+class SerializationIP : public SimpleTextSerialization\n+{\n+public:\n+    void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override\n+    {\n+        writeText(assert_cast<const ColumnVector<IPv> &>(column).getData()[row_num], ostr);\n+    }\n+    void deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings, bool whole) const override\n+    {\n+        IPv x;\n+        readText(x, istr);\n+\n+        if (whole && !istr.eof())\n+            throwUnexpectedDataAfterParsedValue(column, istr, settings, TypeName<IPv>.data());\n+\n+        assert_cast<ColumnVector<IPv> &>(column).getData().push_back(x);\n+    }\n+    void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const override\n+    {\n+        serializeText(column, row_num, ostr, settings);\n+    }\n+    void deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override\n+    {\n+        deserializeText(column, istr, settings, true);\n+    }\n+    void serializeTextQuoted(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const override\n+    {\n+        writeChar('\\'', ostr);\n+        serializeText(column, row_num, ostr, settings);\n+        writeChar('\\'', ostr);\n+    }\n+    void deserializeTextQuoted(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override\n+    {\n+        IPv x;\n+        assertChar('\\'', istr);\n+        readText(x, istr);\n+        assertChar('\\'', istr);\n+        assert_cast<ColumnVector<IPv> &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.\n+    }\n+    void serializeTextJSON(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const override\n+    {\n+        writeChar('\"', ostr);\n+        serializeText(column, row_num, ostr, settings);\n+        writeChar('\"', ostr);\n+    }\n+    void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override\n+    {\n+        IPv x;\n+        assertChar('\"', istr);\n+        readText(x, istr);\n+        /// this code looks weird, but we want to throw specific exception to match original behavior...\n+        if (istr.eof())\n+            assertChar('\"', istr);\n+        if (*istr.position() != '\"')\n+            throwUnexpectedDataAfterParsedValue(column, istr, settings, TypeName<IPv>.data());\n+        istr.ignore();\n+\n+        assert_cast<ColumnVector<IPv> &>(column).getData().push_back(x);\n+    }\n+    void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const override\n+    {\n+        writeChar('\"', ostr);\n+        serializeText(column, row_num, ostr, settings);\n+        writeChar('\"', ostr);\n+    }\n+    void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override\n+    {\n+        IPv value;\n+        readCSV(value, istr);\n+\n+        if (!istr.eof())\n+            throwUnexpectedDataAfterParsedValue(column, istr, settings, TypeName<IPv>.data());\n+\n+        assert_cast<ColumnVector<IPv> &>(column).getData().push_back(value);\n+    }\n+\n+    void serializeBinary(const Field & field, WriteBuffer & ostr, const FormatSettings &) const override\n+    {\n+        IPv x = field.get<IPv>();\n+        writeBinary(x, ostr);\n+    }\n+    void deserializeBinary(Field & field, ReadBuffer & istr, const FormatSettings &) const override\n+    {\n+        IPv x;\n+        readBinary(x.toUnderType(), istr);\n+        field = NearestFieldType<IPv>(x);\n+    }\n+    void serializeBinary(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override\n+    {\n+        writeBinary(assert_cast<const ColumnVector<IPv> &>(column).getData()[row_num], ostr);\n+    }\n+    void deserializeBinary(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override\n+    {\n+        IPv x;\n+        readBinary(x.toUnderType(), istr);\n+        assert_cast<ColumnVector<IPv> &>(column).getData().push_back(x);\n+    }\n+    void serializeBinaryBulk(const IColumn & column, WriteBuffer & ostr, size_t offset, size_t limit) const override\n+    {\n+        const typename ColumnVector<IPv>::Container & x = typeid_cast<const ColumnVector<IPv> &>(column).getData();\n+\n+        size_t size = x.size();\n+\n+        if (limit == 0 || offset + limit > size)\n+            limit = size - offset;\n+\n+        if (limit)\n+            ostr.write(reinterpret_cast<const char *>(&x[offset]), sizeof(IPv) * limit);\n+    }\n+    void deserializeBinaryBulk(IColumn & column, ReadBuffer & istr, size_t limit, double /*avg_value_size_hint*/) const override\n+    {\n+        typename ColumnVector<IPv>::Container & x = typeid_cast<ColumnVector<IPv> &>(column).getData();\n+        size_t initial_size = x.size();\n+        x.resize(initial_size + limit);\n+        size_t size = istr.readBig(reinterpret_cast<char*>(&x[initial_size]), sizeof(IPv) * limit);\n+        x.resize(initial_size + size / sizeof(IPv));\n+    }\n+};\n+\n+using SerializationIPv4 = SerializationIP<IPv4>;\n+using SerializationIPv6 = SerializationIP<IPv6>;\n+\n+}\ndiff --git a/src/Dictionaries/CacheDictionaryStorage.h b/src/Dictionaries/CacheDictionaryStorage.h\nindex 684b4a1311f6..5b52fbde00d6 100644\n--- a/src/Dictionaries/CacheDictionaryStorage.h\n+++ b/src/Dictionaries/CacheDictionaryStorage.h\n@@ -557,6 +557,8 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n             ContainerType<UUID>,\n+            ContainerType<IPv4>,\n+            ContainerType<IPv6>,\n             ContainerType<StringRef>,\n             ContainerType<Array>,\n             ContainerType<Field>> attribute_container;\ndiff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex 0046b2aaf5aa..6e206cafb4a9 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -267,6 +267,14 @@ class DictionaryAttributeColumnProvider\n         {\n             return ColumnType::create(size);\n         }\n+        else if constexpr (std::is_same_v<DictionaryAttributeType, IPv4>)\n+        {\n+            return ColumnType::create(size);\n+        }\n+        else if constexpr (std::is_same_v<DictionaryAttributeType, IPv6>)\n+        {\n+            return ColumnType::create(size);\n+        }\n         else if constexpr (is_decimal<DictionaryAttributeType>)\n         {\n             auto nested_type = removeNullable(dictionary_attribute.type);\ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex 9ae3e9a2e711..d09b2c01b8ef 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -136,6 +136,8 @@ class FlatDictionary final : public IDictionary\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n             ContainerType<UUID>,\n+            ContainerType<IPv4>,\n+            ContainerType<IPv6>,\n             ContainerType<StringRef>,\n             ContainerType<Array>>\n             container;\ndiff --git a/src/Dictionaries/HashedArrayDictionary.h b/src/Dictionaries/HashedArrayDictionary.h\nindex 8df9ce4c1f79..bcb3f85ef06e 100644\n--- a/src/Dictionaries/HashedArrayDictionary.h\n+++ b/src/Dictionaries/HashedArrayDictionary.h\n@@ -156,6 +156,8 @@ class HashedArrayDictionary final : public IDictionary\n             AttributeContainerType<Float32>,\n             AttributeContainerType<Float64>,\n             AttributeContainerType<UUID>,\n+            AttributeContainerType<IPv4>,\n+            AttributeContainerType<IPv6>,\n             AttributeContainerType<StringRef>,\n             AttributeContainerType<Array>>\n             container;\ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex ba5d284466a8..1fb38e8f9a6d 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -186,6 +186,8 @@ class HashedDictionary final : public IDictionary\n             CollectionType<Float32>,\n             CollectionType<Float64>,\n             CollectionType<UUID>,\n+            CollectionType<IPv4>,\n+            CollectionType<IPv6>,\n             CollectionType<StringRef>,\n             CollectionType<Array>>\n             container;\ndiff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp\nindex be9a5a88ecd8..31ae34f8c4bd 100644\n--- a/src/Dictionaries/IPAddressDictionary.cpp\n+++ b/src/Dictionaries/IPAddressDictionary.cpp\n@@ -8,6 +8,7 @@\n #include <DataTypes/DataTypeFixedString.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <Poco/ByteOrder.h>\n #include <Common/formatIPv6.h>\n #include <base/itoa.h>\n@@ -27,7 +28,6 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n     extern const int CANNOT_PARSE_NUMBER;\n     extern const int DICTIONARY_IS_EMPTY;\n-    extern const int LOGICAL_ERROR;\n     extern const int TYPE_MISMATCH;\n     extern const int UNSUPPORTED_METHOD;\n }\n@@ -129,12 +129,12 @@ static void validateKeyTypes(const DataTypes & key_types)\n     if (key_types.empty() || key_types.size() > 2)\n         throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected a single IP address or IP with mask\");\n \n-    const auto * key_ipv4type = typeid_cast<const DataTypeUInt32 *>(key_types[0].get());\n-    const auto * key_ipv6type = typeid_cast<const DataTypeFixedString *>(key_types[0].get());\n+    TypeIndex type_id = key_types[0]->getTypeId();\n+    const auto * key_string = typeid_cast<const DataTypeFixedString *>(key_types[0].get());\n \n-    if (key_ipv4type == nullptr && (key_ipv6type == nullptr || key_ipv6type->getN() != 16))\n+    if (type_id != TypeIndex::IPv4 && type_id != TypeIndex::UInt32 && type_id != TypeIndex::IPv6 && !(key_string && key_string->getN() == IPV6_BINARY_LENGTH))\n         throw Exception(ErrorCodes::TYPE_MISMATCH,\n-            \"Key does not match, expected either `IPv4` (`UInt32`) or `IPv6` (`FixedString(16)`)\");\n+            \"Key does not match, expected either IPv4 (or UInt32) or IPv6 (or FixedString(16))\");\n \n     if (key_types.size() > 1)\n     {\n@@ -296,30 +296,33 @@ ColumnUInt8::Ptr IPAddressDictionary::hasKeys(const Columns & key_columns, const\n \n     size_t keys_found = 0;\n \n-    if (first_column->isNumeric())\n+    TypeIndex type_id = first_column->getDataType();\n+\n+    if (type_id == TypeIndex::IPv4 || type_id == TypeIndex::UInt32)\n     {\n         uint8_t addrv6_buf[IPV6_BINARY_LENGTH];\n         for (const auto i : collections::range(0, rows))\n         {\n-            auto addrv4 = static_cast<UInt32>(first_column->get64(i));\n+            auto addrv4 = *reinterpret_cast<const UInt32 *>(first_column->getDataAt(i).data);\n             auto found = tryLookupIPv4(addrv4, addrv6_buf);\n             out[i] = (found != ipNotFound());\n             keys_found += out[i];\n         }\n     }\n-    else\n+    else if (type_id == TypeIndex::IPv6 || type_id == TypeIndex::FixedString)\n     {\n         for (const auto i : collections::range(0, rows))\n         {\n             auto addr = first_column->getDataAt(i);\n-            if (unlikely(addr.size != IPV6_BINARY_LENGTH))\n-                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected key to be FixedString(16)\");\n-\n+            if (addr.size != IPV6_BINARY_LENGTH)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected key FixedString(16)\");\n             auto found = tryLookupIPv6(reinterpret_cast<const uint8_t *>(addr.data));\n             out[i] = (found != ipNotFound());\n             keys_found += out[i];\n         }\n     }\n+    else\n+        throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected key to be IPv4 (or UInt32) or IPv6 (or FixedString(16))\");\n \n     query_count.fetch_add(rows, std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -709,13 +712,15 @@ void IPAddressDictionary::getItemsImpl(\n \n     size_t keys_found = 0;\n \n-    if (first_column->isNumeric())\n+    TypeIndex type_id = first_column->getDataType();\n+\n+    if (type_id == TypeIndex::IPv4 || type_id == TypeIndex::UInt32)\n     {\n         uint8_t addrv6_buf[IPV6_BINARY_LENGTH];\n         for (const auto i : collections::range(0, rows))\n         {\n             // addrv4 has native endianness\n-            auto addrv4 = static_cast<UInt32>(first_column->get64(i));\n+            auto addrv4 = *reinterpret_cast<const UInt32 *>(first_column->getDataAt(i).data);\n             auto found = tryLookupIPv4(addrv4, addrv6_buf);\n             if (found != ipNotFound())\n             {\n@@ -726,14 +731,13 @@ void IPAddressDictionary::getItemsImpl(\n                 set_value(i, default_value_extractor[i]);\n         }\n     }\n-    else\n+    else if (type_id == TypeIndex::IPv6 || type_id == TypeIndex::FixedString)\n     {\n         for (const auto i : collections::range(0, rows))\n         {\n             auto addr = first_column->getDataAt(i);\n             if (addr.size != IPV6_BINARY_LENGTH)\n-                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected key to be FixedString(16)\");\n-\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected key to be FixedString(16)\");\n             auto found = tryLookupIPv6(reinterpret_cast<const uint8_t *>(addr.data));\n             if (found != ipNotFound())\n             {\n@@ -744,6 +748,8 @@ void IPAddressDictionary::getItemsImpl(\n                 set_value(i, default_value_extractor[i]);\n         }\n     }\n+    else\n+        throw Exception(ErrorCodes::TYPE_MISMATCH, \"Expected key to be IPv4 (or UInt32) or IPv6 (or FixedString(16))\");\n \n     query_count.fetch_add(rows, std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex cd6e64f18006..e1fabb89a7e5 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -118,6 +118,8 @@ class IPAddressDictionary final : public IDictionary\n             Float32,\n             Float64,\n             UUID,\n+            IPv4,\n+            IPv6,\n             String,\n             Array>\n             null_values;\n@@ -142,6 +144,8 @@ class IPAddressDictionary final : public IDictionary\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n             ContainerType<UUID>,\n+            ContainerType<IPv4>,\n+            ContainerType<IPv6>,\n             ContainerType<StringRef>,\n             ContainerType<Array>>\n             maps;\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 257bfcd528cb..abff492471e5 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -150,6 +150,8 @@ class RangeHashedDictionary final : public IDictionary\n             AttributeContainerType<Float32>,\n             AttributeContainerType<Float64>,\n             AttributeContainerType<UUID>,\n+            AttributeContainerType<IPv4>,\n+            AttributeContainerType<IPv6>,\n             AttributeContainerType<StringRef>,\n             AttributeContainerType<Array>>\n             container;\n@@ -189,7 +191,9 @@ class RangeHashedDictionary final : public IDictionary\n         ContainerType<DateTime64>,\n         ContainerType<Float32>,\n         ContainerType<Float64>,\n-        ContainerType<UUID>>;\n+        ContainerType<UUID>,\n+        ContainerType<IPv4>,\n+        ContainerType<IPv6>>;\n \n     struct KeyAttribute final\n     {\ndiff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp\nindex 97dac4b10fc6..218f23d53b88 100644\n--- a/src/Formats/ProtobufSerializer.cpp\n+++ b/src/Formats/ProtobufSerializer.cpp\n@@ -1648,6 +1648,83 @@ namespace\n         String text_buffer;\n     };\n \n+    /// Serializes a ColumnVector<IPv6> containing IPv6s to a field of type TYPE_STRING or TYPE_BYTES.\n+    class ProtobufSerializerIPv6 : public ProtobufSerializerSingleValue\n+    {\n+    public:\n+        ProtobufSerializerIPv6(\n+            std::string_view column_name_,\n+            const google::protobuf::FieldDescriptor & field_descriptor_,\n+            const ProtobufReaderOrWriter & reader_or_writer_)\n+            : ProtobufSerializerSingleValue(column_name_, field_descriptor_, reader_or_writer_)\n+        {\n+            setFunctions();\n+        }\n+\n+        void writeRow(size_t row_num) override\n+        {\n+            const auto & column_vector = assert_cast<const ColumnVector<IPv6> &>(*column);\n+            write_function(column_vector.getElement(row_num));\n+        }\n+\n+        void readRow(size_t row_num) override\n+        {\n+            IPv6 value = read_function();\n+            auto & column_vector = assert_cast<ColumnVector<IPv6> &>(column->assumeMutableRef());\n+            if (row_num < column_vector.size())\n+                column_vector.getElement(row_num) = value;\n+            else\n+                column_vector.insertValue(value);\n+        }\n+\n+        void insertDefaults(size_t row_num) override\n+        {\n+            auto & column_vector = assert_cast<ColumnVector<IPv6> &>(column->assumeMutableRef());\n+            if (row_num < column_vector.size())\n+                return;\n+            column_vector.insertDefault();\n+        }\n+\n+        void describeTree(WriteBuffer & out, size_t indent) const override\n+        {\n+            writeIndent(out, indent) << \"ProtobufSerializer\" << TypeName<IPv6> << \": column \" << quoteString(column_name) << \" -> field \"\n+                                     << quoteString(field_descriptor.full_name()) << \" (\" << field_descriptor.type_name() << \")\\n\";\n+        }\n+\n+    private:\n+        void setFunctions()\n+        {\n+            if ((field_typeid != FieldTypeId::TYPE_STRING) && (field_typeid != FieldTypeId::TYPE_BYTES))\n+                incompatibleColumnType(TypeName<IPv6>);\n+\n+            write_function = [this](IPv6 value)\n+            {\n+                ipToString(value, text_buffer);\n+                writeStr(text_buffer);\n+            };\n+\n+            read_function = [this]() -> IPv6\n+            {\n+                readStr(text_buffer);\n+                return parse<IPv6>(text_buffer);\n+            };\n+\n+            default_function = [this]() -> IPv6 { return parse<IPv6>(field_descriptor.default_value_string()); };\n+        }\n+\n+        static void ipToString(const IPv6 & ip, String & str)\n+        {\n+            WriteBufferFromString buf{str};\n+            writeText(ip, buf);\n+        }\n+\n+        std::function<void(IPv6)> write_function;\n+        std::function<IPv6()> read_function;\n+        std::function<IPv6()> default_function;\n+        String text_buffer;\n+    };\n+\n+    using ProtobufSerializerIPv4 = ProtobufSerializerNumber<UInt32>;\n \n     using ProtobufSerializerInterval = ProtobufSerializerNumber<Int64>;\n \n@@ -3286,6 +3363,8 @@ namespace\n                 case TypeIndex::Decimal128: return std::make_unique<ProtobufSerializerDecimal<Decimal128>>(column_name, assert_cast<const DataTypeDecimal<Decimal128> &>(*data_type), field_descriptor, reader_or_writer);\n                 case TypeIndex::Decimal256: return std::make_unique<ProtobufSerializerDecimal<Decimal256>>(column_name, assert_cast<const DataTypeDecimal<Decimal256> &>(*data_type), field_descriptor, reader_or_writer);\n                 case TypeIndex::UUID: return std::make_unique<ProtobufSerializerUUID>(column_name, field_descriptor, reader_or_writer);\n+                case TypeIndex::IPv4: return std::make_unique<ProtobufSerializerIPv4>(column_name, field_descriptor, reader_or_writer);\n+                case TypeIndex::IPv6: return std::make_unique<ProtobufSerializerIPv6>(column_name, field_descriptor, reader_or_writer);\n                 case TypeIndex::Interval: return std::make_unique<ProtobufSerializerInterval>(column_name, field_descriptor, reader_or_writer);\n                 case TypeIndex::AggregateFunction: return std::make_unique<ProtobufSerializerAggregateFunction>(column_name, typeid_cast<std::shared_ptr<const DataTypeAggregateFunction>>(data_type), field_descriptor, reader_or_writer);\n \ndiff --git a/src/Functions/CastOverloadResolver.h b/src/Functions/CastOverloadResolver.h\nindex 0bd0bad0d148..29394c2af1c8 100644\n--- a/src/Functions/CastOverloadResolver.h\n+++ b/src/Functions/CastOverloadResolver.h\n@@ -33,10 +33,10 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n \n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n-    explicit CastOverloadResolverImpl(std::optional<Diagnostic> diagnostic_, bool keep_nullable_, bool cast_ipv4_ipv6_default_on_conversion_error_, const DataTypeValidationSettings & data_type_validation_settings_)\n-        : diagnostic(std::move(diagnostic_))\n+    explicit CastOverloadResolverImpl(ContextPtr context_, std::optional<Diagnostic> diagnostic_, bool keep_nullable_, const DataTypeValidationSettings & data_type_validation_settings_)\n+        : context(context_)\n+        , diagnostic(std::move(diagnostic_))\n         , keep_nullable(keep_nullable_)\n-        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)\n         , data_type_validation_settings(data_type_validation_settings_)\n     {\n     }\n@@ -46,15 +46,21 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n         const auto & settings_ref = context->getSettingsRef();\n \n         if constexpr (internal)\n-            return createImpl({}, false /*keep_nullable*/, settings_ref.cast_ipv4_ipv6_default_on_conversion_error);\n+            return createImpl(context, {}, false /*keep_nullable*/);\n \n-        return createImpl({}, settings_ref.cast_keep_nullable, settings_ref.cast_ipv4_ipv6_default_on_conversion_error, DataTypeValidationSettings(settings_ref));\n+        return createImpl(context, {}, settings_ref.cast_keep_nullable, DataTypeValidationSettings(settings_ref));\n     }\n \n-    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false, bool cast_ipv4_ipv6_default_on_conversion_error = false, const DataTypeValidationSettings & data_type_validation_settings = {})\n+    static FunctionOverloadResolverPtr createImpl(ContextPtr context, std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false, const DataTypeValidationSettings & data_type_validation_settings = {})\n     {\n         assert(!internal || !keep_nullable);\n-        return std::make_unique<CastOverloadResolverImpl>(std::move(diagnostic), keep_nullable, cast_ipv4_ipv6_default_on_conversion_error, data_type_validation_settings);\n+        return std::make_unique<CastOverloadResolverImpl>(context, std::move(diagnostic), keep_nullable, data_type_validation_settings);\n+    }\n+\n+    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false, const DataTypeValidationSettings & data_type_validation_settings = {})\n+    {\n+        assert(!internal || !keep_nullable);\n+        return std::make_unique<CastOverloadResolverImpl>(ContextPtr(), std::move(diagnostic), keep_nullable, data_type_validation_settings);\n     }\n \n protected:\n@@ -67,7 +73,7 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n             data_types[i] = arguments[i].type;\n \n         auto monotonicity = MonotonicityHelper::getMonotonicityInformation(arguments.front().type, return_type.get());\n-        return std::make_unique<FunctionCast<FunctionName>>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type, cast_ipv4_ipv6_default_on_conversion_error);\n+        return std::make_unique<FunctionCast<FunctionName>>(context, name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n     }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n@@ -104,9 +110,9 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n     bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n \n private:\n+    ContextPtr context;\n     std::optional<Diagnostic> diagnostic;\n     bool keep_nullable;\n-    bool cast_ipv4_ipv6_default_on_conversion_error;\n     DataTypeValidationSettings data_type_validation_settings;\n };\n \ndiff --git a/src/Functions/FunctionsBinaryRepresentation.cpp b/src/Functions/FunctionsBinaryRepresentation.cpp\nindex b0bdbc2130c6..a93f7c27ff4b 100644\n--- a/src/Functions/FunctionsBinaryRepresentation.cpp\n+++ b/src/Functions/FunctionsBinaryRepresentation.cpp\n@@ -257,6 +257,8 @@ class EncodeToBinaryRepresentation : public IFunction\n             !which.isFloat() &&\n             !which.isDecimal() &&\n             !which.isUUID() &&\n+            !which.isIPv4() &&\n+            !which.isIPv6() &&\n             !which.isAggregateFunction())\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n                             ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n@@ -297,7 +299,9 @@ class EncodeToBinaryRepresentation : public IFunction\n             tryExecuteDecimal<Decimal32>(column, res_column) ||\n             tryExecuteDecimal<Decimal64>(column, res_column) ||\n             tryExecuteDecimal<Decimal128>(column, res_column) ||\n-            tryExecuteUUID(column, res_column))\n+            tryExecuteUUID(column, res_column) ||\n+            tryExecuteIPv4(column, res_column) ||\n+            tryExecuteIPv6(column, res_column))\n             return res_column;\n \n         throw Exception(\"Illegal column \" + arguments[0].column->getName()\n@@ -519,6 +523,88 @@ class EncodeToBinaryRepresentation : public IFunction\n             return false;\n         }\n     }\n+\n+    bool tryExecuteIPv6(const IColumn * col, ColumnPtr & col_res) const\n+    {\n+        const ColumnIPv6 * col_vec = checkAndGetColumn<ColumnIPv6>(col);\n+\n+        static constexpr size_t MAX_LENGTH = sizeof(IPv6) * word_size + 1;    /// Including trailing zero byte.\n+\n+        if (!col_vec)\n+            return false;\n+\n+        auto col_str = ColumnString::create();\n+        ColumnString::Chars & out_vec = col_str->getChars();\n+        ColumnString::Offsets & out_offsets = col_str->getOffsets();\n+\n+        const typename ColumnIPv6::Container & in_vec = col_vec->getData();\n+        const IPv6* ip = in_vec.data();\n+\n+        size_t size = in_vec.size();\n+        out_offsets.resize(size);\n+        out_vec.resize(size * (word_size+1) + MAX_LENGTH); /// word_size+1 is length of one byte in hex/bin plus zero byte.\n+\n+        size_t pos = 0;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            /// Manual exponential growth, so as not to rely on the linear amortized work time of `resize` (no one guarantees it).\n+            if (pos + MAX_LENGTH > out_vec.size())\n+                out_vec.resize(out_vec.size() * word_size + MAX_LENGTH);\n+\n+            char * begin = reinterpret_cast<char *>(&out_vec[pos]);\n+            char * end = begin;\n+\n+            Impl::executeOneString(reinterpret_cast<const UInt8 *>(&ip[i].toUnderType().items[0]), reinterpret_cast<const UInt8 *>(&ip[i].toUnderType().items[2]), end);\n+\n+            pos += end - begin;\n+            out_offsets[i] = pos;\n+        }\n+        out_vec.resize(pos);\n+\n+        col_res = std::move(col_str);\n+        return true;\n+    }\n+\n+    bool tryExecuteIPv4(const IColumn * col, ColumnPtr & col_res) const\n+    {\n+        const ColumnIPv4 * col_vec = checkAndGetColumn<ColumnIPv4>(col);\n+\n+        static constexpr size_t MAX_LENGTH = sizeof(IPv4) * word_size + 1;    /// Including trailing zero byte.\n+\n+        if (!col_vec)\n+            return false;\n+\n+        auto col_str = ColumnString::create();\n+        ColumnString::Chars & out_vec = col_str->getChars();\n+        ColumnString::Offsets & out_offsets = col_str->getOffsets();\n+\n+        const typename ColumnIPv4::Container & in_vec = col_vec->getData();\n+        const IPv4* ip = in_vec.data();\n+\n+        size_t size = in_vec.size();\n+        out_offsets.resize(size);\n+        out_vec.resize(size * (word_size+1) + MAX_LENGTH); /// word_size+1 is length of one byte in hex/bin plus zero byte.\n+\n+        size_t pos = 0;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            /// Manual exponential growth, so as not to rely on the linear amortized work time of `resize` (no one guarantees it).\n+            if (pos + MAX_LENGTH > out_vec.size())\n+                out_vec.resize(out_vec.size() * word_size + MAX_LENGTH);\n+\n+            char * begin = reinterpret_cast<char *>(&out_vec[pos]);\n+            char * end = begin;\n+\n+            Impl::executeOneUIntOrInt(ip[i].toUnderType(), end);\n+\n+            pos += end - begin;\n+            out_offsets[i] = pos;\n+        }\n+        out_vec.resize(pos);\n+\n+        col_res = std::move(col_str);\n+        return true;\n+    }\n };\n \n /// Decode number or string from string with binary or hexadecimal representation\ndiff --git a/src/Functions/FunctionsCodingIP.cpp b/src/Functions/FunctionsCodingIP.cpp\nindex 3fea5e9d898e..75b3d76745f6 100644\n--- a/src/Functions/FunctionsCodingIP.cpp\n+++ b/src/Functions/FunctionsCodingIP.cpp\n@@ -1,3 +1,4 @@\n+#include <functional>\n #ifdef HAS_RESERVED_IDENTIFIER\n #pragma clang diagnostic ignored \"-Wreserved-identifier\"\n #endif\n@@ -17,6 +18,7 @@\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n@@ -44,8 +46,8 @@ namespace ErrorCodes\n \n /** Encoding functions for network addresses:\n   *\n-  * IPv4NumToString (num) - See below.\n-  * IPv4StringToNum(string) - Convert, for example, '192.168.0.1' to 3232235521 and vice versa.\n+  * IPv6NumToString (num) - See below.\n+  * IPv6StringToNum(string) - Convert, for example, '::1' to 1 and vice versa.\n   */\n class FunctionIPv6NumToString : public IFunction\n {\n@@ -61,59 +63,64 @@ class FunctionIPv6NumToString : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        const auto * ptr = checkAndGetDataType<DataTypeFixedString>(arguments[0].get());\n-        if (!ptr || ptr->getN() != IPV6_BINARY_LENGTH)\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() +\n-                            \" of argument of function \" + getName() +\n-                            \", expected FixedString(\" + toString(IPV6_BINARY_LENGTH) + \")\",\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        const auto * arg_string = checkAndGetDataType<DataTypeFixedString>(arguments[0].get());\n+        const auto * arg_ipv6 = checkAndGetDataType<DataTypeIPv6>(arguments[0].get());\n+        if (!arg_ipv6 && !(arg_string && arg_string->getN() == IPV6_BINARY_LENGTH))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of argument of function {}, expected IPv6 or FixedString({})\",\n+                arguments[0]->getName(), getName(), IPV6_BINARY_LENGTH\n+            );\n \n         return std::make_shared<DataTypeString>();\n     }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        const auto & col_type_name = arguments[0];\n-        const ColumnPtr & column = col_type_name.column;\n-\n-        if (const auto * col_in = checkAndGetColumn<ColumnFixedString>(column.get()))\n-        {\n-            if (col_in->getN() != IPV6_BINARY_LENGTH)\n-                throw Exception(\"Illegal type \" + col_type_name.type->getName() +\n-                                \" of column \" + col_in->getName() +\n-                                \" argument of function \" + getName() +\n-                                \", expected FixedString(\" + toString(IPV6_BINARY_LENGTH) + \")\",\n-                                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        const ColumnPtr & column = arguments[0].column;\n+        const auto * col_ipv6 = checkAndGetColumn<ColumnIPv6>(column.get());\n+        const auto * col_string = checkAndGetColumn<ColumnFixedString>(column.get());\n+        if (!col_ipv6 && !(col_string && col_string->getN() == IPV6_BINARY_LENGTH))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal column {} of argument of function {}, expected IPv6 or FixedString({})\",\n+                arguments[0].name, getName(), IPV6_BINARY_LENGTH\n+            );\n \n-            const auto size = col_in->size();\n-            const auto & vec_in = col_in->getChars();\n+        auto col_res = ColumnString::create();\n+        ColumnString::Chars & vec_res = col_res->getChars();\n+        ColumnString::Offsets & offsets_res = col_res->getOffsets();\n+        vec_res.resize(input_rows_count * (IPV6_MAX_TEXT_LENGTH + 1));\n+        offsets_res.resize(input_rows_count);\n \n-            auto col_res = ColumnString::create();\n+        auto * begin = reinterpret_cast<char *>(vec_res.data());\n+        auto * pos = begin;\n \n-            ColumnString::Chars & vec_res = col_res->getChars();\n-            ColumnString::Offsets & offsets_res = col_res->getOffsets();\n-            vec_res.resize(size * (IPV6_MAX_TEXT_LENGTH + 1));\n-            offsets_res.resize(size);\n-\n-            auto * begin = reinterpret_cast<char *>(vec_res.data());\n-            auto * pos = begin;\n+        if (col_ipv6)\n+        {\n+            const auto & vec_in = col_ipv6->getData();\n \n-            for (size_t offset = 0, i = 0; offset < vec_in.size(); offset += IPV6_BINARY_LENGTH, ++i)\n+            for (size_t i = 0; i < input_rows_count; ++i)\n             {\n-                formatIPv6(reinterpret_cast<const unsigned char *>(&vec_in[offset]), pos);\n+                formatIPv6(reinterpret_cast<const unsigned char *>(&vec_in[i]), pos);\n                 offsets_res[i] = pos - begin;\n             }\n-\n-            vec_res.resize(pos - begin);\n-\n-            return col_res;\n         }\n         else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+        {\n+            const auto & vec_in = col_string->getChars();\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                formatIPv6(reinterpret_cast<const unsigned char *>(&vec_in[i * IPV6_BINARY_LENGTH]), pos);\n+                offsets_res[i] = pos - begin;\n+            }\n+        }\n+\n+        vec_res.resize(pos - begin);\n+        return col_res;\n     }\n };\n \n@@ -302,14 +309,14 @@ class FunctionIPv6StringToNum : public IFunction\n         {\n             if (cast_ipv4_ipv6_default_on_conversion_error)\n             {\n-                auto result = convertToIPv6<IPStringToNumExceptionMode::Default>(column, null_map);\n+                auto result = convertToIPv6<IPStringToNumExceptionMode::Default, ColumnFixedString>(column, null_map);\n                 if (null_map && !result->isNullable())\n                     return ColumnNullable::create(result, null_map_column);\n                 return result;\n             }\n         }\n \n-        auto result = convertToIPv6<exception_mode>(column, null_map);\n+        auto result = convertToIPv6<exception_mode, ColumnFixedString>(column, null_map);\n         if (null_map && !result->isNullable())\n             return ColumnNullable::create(IColumn::mutate(result), IColumn::mutate(null_map_column));\n         return result;\n@@ -325,37 +332,17 @@ class FunctionIPv6StringToNum : public IFunction\n template <size_t mask_tail_octets, typename Name>\n class FunctionIPv4NumToString : public IFunction\n {\n-public:\n-    static constexpr auto name = Name::name;\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4NumToString<mask_tail_octets, Name>>(); }\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    size_t getNumberOfArguments() const override { return 1; }\n-    bool isInjective(const ColumnsWithTypeAndName &) const override { return mask_tail_octets == 0; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+private:\n+    template <typename ArgType>\n+    ColumnPtr executeTyped(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const\n     {\n-        if (!WhichDataType(arguments[0]).isUInt32())\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName() + \", expected UInt32\",\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n+        using ColumnType = ColumnVector<ArgType>;\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n-    {\n         const ColumnPtr & column = arguments[0].column;\n \n-        if (const ColumnUInt32 * col = typeid_cast<const ColumnUInt32 *>(column.get()))\n+        if (const ColumnType * col = typeid_cast<const ColumnType *>(column.get()))\n         {\n-            const ColumnUInt32::Container & vec_in = col->getData();\n+            const typename ColumnType::Container & vec_in = col->getData();\n \n             auto col_res = ColumnString::create();\n \n@@ -369,7 +356,7 @@ class FunctionIPv4NumToString : public IFunction\n \n             for (size_t i = 0; i < vec_in.size(); ++i)\n             {\n-                DB::formatIPv4(reinterpret_cast<const unsigned char*>(&vec_in[i]), pos, mask_tail_octets, \"xxx\");\n+                DB::formatIPv4(reinterpret_cast<const unsigned char*>(&vec_in[i]), sizeof(ArgType), pos, mask_tail_octets, \"xxx\");\n                 offsets_res[i] = pos - begin;\n             }\n \n@@ -382,6 +369,52 @@ class FunctionIPv4NumToString : public IFunction\n                             + \" of argument of function \" + getName(),\n                             ErrorCodes::ILLEGAL_COLUMN);\n     }\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4NumToString<mask_tail_octets, Name>>(); }\n+\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isInjective(const ColumnsWithTypeAndName &) const override { return mask_tail_octets == 0; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        WhichDataType arg_type(arguments[0]);\n+        if (!(arg_type.isIPv4() || arg_type.isUInt8() || arg_type.isUInt16() || arg_type.isUInt32()))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of first argument of function {}, expected IPv4 or UInt8 or UInt16 or UInt32\",\n+                arguments[0]->getName(), getName()\n+            );\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & ret_type, size_t input_rows_count) const override\n+    {\n+\n+        switch (arguments[0].type->getTypeId())\n+        {\n+            case TypeIndex::IPv4: return executeTyped<IPv4>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt8: return executeTyped<UInt8>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt16: return executeTyped<UInt16>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt32: return executeTyped<UInt32>(arguments, ret_type, input_rows_count);\n+            default: break;\n+        }\n+\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN,\n+            \"Illegal column {} of argument of function {}, expected IPv4 or UInt8 or UInt16 or UInt32\",\n+            arguments[0].column->getName(), getName()\n+        );\n+    }\n };\n \n template <IPStringToNumExceptionMode exception_mode>\n@@ -444,14 +477,14 @@ class FunctionIPv4StringToNum : public IFunction\n         {\n             if (cast_ipv4_ipv6_default_on_conversion_error)\n             {\n-                auto result = convertToIPv4<IPStringToNumExceptionMode::Default>(column, null_map);\n+                auto result = convertToIPv4<IPStringToNumExceptionMode::Default, ColumnUInt32>(column, null_map);\n                 if (null_map && !result->isNullable())\n                     return ColumnNullable::create(result, null_map_column);\n                 return result;\n             }\n         }\n \n-        auto result = convertToIPv4<exception_mode>(column, null_map);\n+        auto result = convertToIPv4<exception_mode, ColumnUInt32>(column, null_map);\n         if (null_map && !result->isNullable())\n             return ColumnNullable::create(IColumn::mutate(result), IColumn::mutate(null_map_column));\n         return result;\n@@ -474,13 +507,21 @@ class FunctionIPv4ToIPv6 : public IFunction\n     bool isInjective(const ColumnsWithTypeAndName &) const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n+    /// for backward compatibility IPv4ToIPv6 is overloaded, and result type depends on type of argument -\n+    ///   if it is UInt32 (presenting IPv4) then result is FixedString(16), if IPv4 - result is IPv6\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        if (!checkAndGetDataType<DataTypeUInt32>(arguments[0].get()))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() +\n-                            \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        const auto * dt_uint32 = checkAndGetDataType<DataTypeUInt32>(arguments[0].get());\n+        const auto * dt_ipv4 = checkAndGetDataType<DataTypeIPv4>(arguments[0].get());\n+        if (!dt_uint32 && !dt_ipv4)\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName()\n+            );\n \n-        return std::make_shared<DataTypeFixedString>(16);\n+        if (dt_uint32)\n+            return std::make_shared<DataTypeFixedString>(16);\n+        return std::make_shared<DataTypeIPv6>();\n     }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n@@ -490,7 +531,22 @@ class FunctionIPv4ToIPv6 : public IFunction\n         const auto & col_type_name = arguments[0];\n         const ColumnPtr & column = col_type_name.column;\n \n-        if (const auto * col_in = typeid_cast<const ColumnUInt32 *>(column.get()))\n+        if (const auto * col_in = checkAndGetColumn<ColumnIPv4>(*column))\n+        {\n+            auto col_res = ColumnIPv6::create();\n+\n+            auto & vec_res = col_res->getData();\n+            vec_res.resize(col_in->size());\n+\n+            const auto & vec_in = col_in->getData();\n+\n+            for (size_t i = 0; i < vec_res.size(); ++i)\n+                mapIPv4ToIPv6(vec_in[i], reinterpret_cast<UInt8 *>(&vec_res[i].toUnderType()));\n+\n+            return col_res;\n+        }\n+\n+        if (const auto * col_in = checkAndGetColumn<ColumnUInt32>(*column))\n         {\n             auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n \n@@ -504,10 +560,11 @@ class FunctionIPv4ToIPv6 : public IFunction\n \n             return col_res;\n         }\n-        else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN,\n+            \"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName()\n+        );\n     }\n \n private:\n@@ -522,82 +579,6 @@ class FunctionIPv4ToIPv6 : public IFunction\n     }\n };\n \n-template <IPStringToNumExceptionMode exception_mode>\n-class FunctionToIPv4 : public FunctionIPv4StringToNum<exception_mode>\n-{\n-public:\n-    using Base = FunctionIPv4StringToNum<exception_mode>;\n-\n-    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n-        ? \"toIPv4\"\n-        : (exception_mode == IPStringToNumExceptionMode::Default ? \"toIPv4OrDefault\" : \"toIPv4OrNull\");\n-\n-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv4>(context); }\n-\n-    explicit FunctionToIPv4(ContextPtr context) : Base(context) { }\n-\n-    String getName() const override { return name; }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    size_t getNumberOfArguments() const override { return 1; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        if (!isString(removeNullable(arguments[0])))\n-        {\n-            throw Exception(\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n-        }\n-\n-        auto result_type = DataTypeFactory::instance().get(\"IPv4\");\n-\n-        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n-        {\n-            return makeNullable(result_type);\n-        }\n-\n-        return arguments[0]->isNullable() ? makeNullable(result_type) : result_type;\n-    }\n-};\n-\n-template <IPStringToNumExceptionMode exception_mode>\n-class FunctionToIPv6 : public FunctionIPv6StringToNum<exception_mode>\n-{\n-public:\n-    using Base = FunctionIPv6StringToNum<exception_mode>;\n-\n-    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n-        ? \"toIPv6\"\n-        : (exception_mode == IPStringToNumExceptionMode::Default ? \"toIPv6OrDefault\" : \"toIPv6OrNull\");\n-\n-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv6>(context); }\n-\n-    explicit FunctionToIPv6(ContextPtr context) : Base(context) { }\n-\n-    String getName() const override { return name; }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        if (!isStringOrFixedString(removeNullable(arguments[0])))\n-        {\n-            throw Exception(\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n-        }\n-\n-        auto result_type = DataTypeFactory::instance().get(\"IPv6\");\n-\n-        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n-        {\n-            return makeNullable(result_type);\n-        }\n-\n-        return arguments[0]->isNullable() ? makeNullable(result_type) : result_type;\n-    }\n-};\n-\n class FunctionMACNumToString : public IFunction\n {\n public:\n@@ -800,7 +781,7 @@ class FunctionIPv6CIDRToRange : public IFunction\n \n #include <emmintrin.h>\n \n-    static inline void applyCIDRMask(const UInt8 * __restrict src, UInt8 * __restrict dst_lower, UInt8 * __restrict dst_upper, UInt8 bits_to_keep)\n+    static inline void applyCIDRMask(const char * __restrict src, char * __restrict dst_lower, char * __restrict dst_upper, UInt8 bits_to_keep)\n     {\n         __m128i mask = _mm_loadu_si128(reinterpret_cast<const __m128i *>(getCIDRMaskIPv6(bits_to_keep).data()));\n         __m128i lower = _mm_and_si128(_mm_loadu_si128(reinterpret_cast<const __m128i *>(src)), mask);\n@@ -814,7 +795,7 @@ class FunctionIPv6CIDRToRange : public IFunction\n #else\n \n     /// NOTE IPv6 is stored in memory in big endian format that makes some difficulties.\n-    static void applyCIDRMask(const UInt8 * __restrict src, UInt8 * __restrict dst_lower, UInt8 * __restrict dst_upper, UInt8 bits_to_keep)\n+    static void applyCIDRMask(const char * __restrict src, char * __restrict dst_lower, char * __restrict dst_upper, UInt8 bits_to_keep)\n     {\n         const auto & mask = getCIDRMaskIPv6(bits_to_keep);\n \n@@ -837,20 +818,24 @@ class FunctionIPv6CIDRToRange : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        const auto * first_argument = checkAndGetDataType<DataTypeFixedString>(arguments[0].get());\n-        if (!first_argument || first_argument->getN() != IPV6_BINARY_LENGTH)\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() +\n-                            \" of first argument of function \" + getName() +\n-                            \", expected FixedString(\" + toString(IPV6_BINARY_LENGTH) + \")\",\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        const auto * ipv6 = checkAndGetDataType<DataTypeIPv6>(arguments[0].get());\n+        const auto * str = checkAndGetDataType<DataTypeFixedString>(arguments[0].get());\n+        if (!ipv6 && !(str && str->getN() == IPV6_BINARY_LENGTH))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of first argument of function {}, expected IPv6 or FixedString({})\",\n+                arguments[0]->getName(), getName(), IPV6_BINARY_LENGTH\n+            );\n \n         const DataTypePtr & second_argument = arguments[1];\n         if (!isUInt8(second_argument))\n-            throw Exception{\"Illegal type \" + second_argument->getName()\n-                            + \" of second argument of function \" + getName()\n-                            + \", expected UInt8\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of second argument of function {}, expected UInt8\",\n+                second_argument->getName(), getName()\n+            );\n \n-        DataTypePtr element = DataTypeFactory::instance().get(\"IPv6\");\n+        DataTypePtr element = std::make_shared<DataTypeIPv6>();\n         return std::make_shared<DataTypeTuple>(DataTypes{element, element});\n     }\n \n@@ -859,25 +844,6 @@ class FunctionIPv6CIDRToRange : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        const auto & col_type_name_ip = arguments[0];\n-        const ColumnPtr & column_ip = col_type_name_ip.column;\n-\n-        const auto * col_const_ip_in = checkAndGetColumnConst<ColumnFixedString>(column_ip.get());\n-        const auto * col_ip_in = checkAndGetColumn<ColumnFixedString>(column_ip.get());\n-\n-        if (!col_ip_in && !col_const_ip_in)\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n-\n-        if ((col_const_ip_in && col_const_ip_in->getValue<String>().size() != IPV6_BINARY_LENGTH) ||\n-            (col_ip_in && col_ip_in->getN() != IPV6_BINARY_LENGTH))\n-            throw Exception(\"Illegal type \" + col_type_name_ip.type->getName() +\n-                            \" of column \" + column_ip->getName() +\n-                            \" argument of function \" + getName() +\n-                            \", expected FixedString(\" + toString(IPV6_BINARY_LENGTH) + \")\",\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n         const auto & col_type_name_cidr = arguments[1];\n         const ColumnPtr & column_cidr = col_type_name_cidr.column;\n \n@@ -885,39 +851,57 @@ class FunctionIPv6CIDRToRange : public IFunction\n         const auto * col_cidr_in = checkAndGetColumn<ColumnUInt8>(column_cidr.get());\n \n         if (!col_const_cidr_in && !col_cidr_in)\n-            throw Exception(\"Illegal column \" + arguments[1].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n-\n-        auto col_res_lower_range = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n-        auto col_res_upper_range = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of argument of function {}\",\n+                arguments[1].column->getName(), getName()\n+            );\n \n-        ColumnString::Chars & vec_res_lower_range = col_res_lower_range->getChars();\n-        vec_res_lower_range.resize(input_rows_count * IPV6_BINARY_LENGTH);\n+        const auto & col_type_name_ip = arguments[0];\n+        const ColumnPtr & column_ip = col_type_name_ip.column;\n \n-        ColumnString::Chars & vec_res_upper_range = col_res_upper_range->getChars();\n-        vec_res_upper_range.resize(input_rows_count * IPV6_BINARY_LENGTH);\n+        const auto * col_const_ip_in = checkAndGetColumnConst<ColumnIPv6>(column_ip.get());\n+        const auto * col_ip_in = checkAndGetColumn<ColumnIPv6>(column_ip.get());\n+\n+        const auto * col_const_str_in = checkAndGetColumnConst<ColumnFixedString>(column_ip.get());\n+        const auto * col_str_in = checkAndGetColumn<ColumnFixedString>(column_ip.get());\n+\n+        std::function<const char *(size_t)> get_ip_data;\n+        if (col_const_ip_in)\n+            get_ip_data = [col_const_ip_in](size_t) { return col_const_ip_in->getDataAt(0).data; };\n+        else if (col_const_str_in)\n+            get_ip_data = [col_const_str_in](size_t) { return col_const_str_in->getDataAt(0).data; };\n+        else if (col_ip_in)\n+            get_ip_data = [col_ip_in](size_t i) { return reinterpret_cast<const char *>(&col_ip_in->getData()[i]); };\n+        else if (col_str_in)\n+            get_ip_data = [col_str_in](size_t i) { return reinterpret_cast<const char *>(&col_str_in->getChars().data()[i * IPV6_BINARY_LENGTH]); };\n+        else\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of argument of function {}\",\n+                arguments[0].column->getName(), getName()\n+            );\n \n-        static constexpr UInt8 max_cidr_mask = IPV6_BINARY_LENGTH * 8;\n+        auto col_res_lower_range = ColumnIPv6::create();\n+        auto col_res_upper_range = ColumnIPv6::create();\n \n-        const String col_const_ip_str = col_const_ip_in ? col_const_ip_in->getValue<String>() : \"\";\n-        const UInt8 * col_const_ip_value = col_const_ip_in ? reinterpret_cast<const UInt8 *>(col_const_ip_str.c_str()) : nullptr;\n+        auto & vec_res_lower_range = col_res_lower_range->getData();\n+        vec_res_lower_range.resize(input_rows_count);\n \n-        for (size_t offset = 0; offset < input_rows_count; ++offset)\n-        {\n-            const size_t offset_ipv6 = offset * IPV6_BINARY_LENGTH;\n+        auto & vec_res_upper_range = col_res_upper_range->getData();\n+        vec_res_upper_range.resize(input_rows_count);\n \n-            const UInt8 * ip = col_const_ip_in\n-                               ? col_const_ip_value\n-                               : &col_ip_in->getChars()[offset_ipv6];\n+        static constexpr UInt8 max_cidr_mask = IPV6_BINARY_LENGTH * 8;\n \n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n             UInt8 cidr = col_const_cidr_in\n-                         ? col_const_cidr_in->getValue<UInt8>()\n-                         : col_cidr_in->getData()[offset];\n+                        ? col_const_cidr_in->getValue<UInt8>()\n+                        : col_cidr_in->getData()[i];\n \n             cidr = std::min(cidr, max_cidr_mask);\n \n-            applyCIDRMask(ip, &vec_res_lower_range[offset_ipv6], &vec_res_upper_range[offset_ipv6], cidr);\n+            applyCIDRMask(get_ip_data(i), reinterpret_cast<char *>(&vec_res_lower_range[i]), reinterpret_cast<char *>(&vec_res_upper_range[i]), cidr);\n         }\n \n         return ColumnTuple::create(Columns{std::move(col_res_lower_range), std::move(col_res_upper_range)});\n@@ -942,47 +926,15 @@ class FunctionIPv4CIDRToRange : public IFunction\n         return { lower, upper };\n     }\n \n-public:\n-    static constexpr auto name = \"IPv4CIDRToRange\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4CIDRToRange>(); }\n-\n-    String getName() const override { return name; }\n-    size_t getNumberOfArguments() const override { return 2; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        if (!WhichDataType(arguments[0]).isUInt32())\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() +\n-                            \" of first argument of function \" + getName() +\n-                            \", expected UInt32\",\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-\n-        const DataTypePtr & second_argument = arguments[1];\n-        if (!isUInt8(second_argument))\n-            throw Exception{\"Illegal type \" + second_argument->getName()\n-                            + \" of second argument of function \" + getName()\n-                            + \", expected UInt8\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-\n-        DataTypePtr element = DataTypeFactory::instance().get(\"IPv4\");\n-        return std::make_shared<DataTypeTuple>(DataTypes{element, element});\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    template <typename ArgType>\n+    ColumnPtr executeTyped(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const\n     {\n+        using ColumnType = ColumnVector<ArgType>;\n         const auto & col_type_name_ip = arguments[0];\n         const ColumnPtr & column_ip = col_type_name_ip.column;\n \n-        const auto * col_const_ip_in = checkAndGetColumnConst<ColumnUInt32>(column_ip.get());\n-        const auto * col_ip_in = checkAndGetColumn<ColumnUInt32>(column_ip.get());\n-        if (!col_const_ip_in && !col_ip_in)\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+        const auto * col_const_ip_in = checkAndGetColumnConst<ColumnType>(column_ip.get());\n+        const auto * col_ip_in = checkAndGetColumn<ColumnType>(column_ip.get());\n \n         const auto & col_type_name_cidr = arguments[1];\n         const ColumnPtr & column_cidr = col_type_name_cidr.column;\n@@ -990,13 +942,8 @@ class FunctionIPv4CIDRToRange : public IFunction\n         const auto * col_const_cidr_in = checkAndGetColumnConst<ColumnUInt8>(column_cidr.get());\n         const auto * col_cidr_in = checkAndGetColumn<ColumnUInt8>(column_cidr.get());\n \n-        if (!col_const_cidr_in && !col_cidr_in)\n-            throw Exception(\"Illegal column \" + arguments[1].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n-\n-        auto col_res_lower_range = ColumnUInt32::create();\n-        auto col_res_upper_range = ColumnUInt32::create();\n+        auto col_res_lower_range = ColumnIPv4::create();\n+        auto col_res_upper_range = ColumnIPv4::create();\n \n         auto & vec_res_lower_range = col_res_lower_range->getData();\n         vec_res_lower_range.resize(input_rows_count);\n@@ -1006,8 +953,8 @@ class FunctionIPv4CIDRToRange : public IFunction\n \n         for (size_t i = 0; i < input_rows_count; ++i)\n         {\n-            UInt32 ip = col_const_ip_in\n-                        ? col_const_ip_in->getValue<UInt32>()\n+            ArgType ip = col_const_ip_in\n+                        ? col_const_ip_in->template getValue<ArgType>()\n                         : col_ip_in->getData()[i];\n \n             UInt8 cidr = col_const_cidr_in\n@@ -1019,6 +966,64 @@ class FunctionIPv4CIDRToRange : public IFunction\n \n         return ColumnTuple::create(Columns{std::move(col_res_lower_range), std::move(col_res_upper_range)});\n     }\n+\n+public:\n+    static constexpr auto name = \"IPv4CIDRToRange\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4CIDRToRange>(); }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 2; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        WhichDataType arg_type(arguments[0]);\n+        if (!(arg_type.isIPv4() || arg_type.isUInt8() || arg_type.isUInt16() || arg_type.isUInt32()))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of first argument of function {}, expected IPv4 or UInt8 or UInt16 or UInt32\",\n+                arguments[0]->getName(), getName()\n+            );\n+\n+\n+        const DataTypePtr & second_argument = arguments[1];\n+        if (!isUInt8(second_argument))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of second argument of function {}, expected UInt8\",\n+                second_argument->getName(), getName()\n+            );\n+\n+        DataTypePtr element = DataTypeFactory::instance().get(\"IPv4\");\n+        return std::make_shared<DataTypeTuple>(DataTypes{element, element});\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & ret_type, size_t input_rows_count) const override\n+    {\n+        if (arguments[1].type->getTypeId() != TypeIndex::UInt8)\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of second argument of function {}, expected UInt8\", arguments[1].type->getName(), getName()\n+            );\n+\n+        switch (arguments[0].type->getTypeId())\n+        {\n+            case TypeIndex::IPv4: return executeTyped<IPv4>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt8: return executeTyped<UInt8>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt16: return executeTyped<UInt16>(arguments, ret_type, input_rows_count);\n+            case TypeIndex::UInt32: return executeTyped<UInt32>(arguments, ret_type, input_rows_count);\n+            default: break;\n+        }\n+\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN,\n+            \"Illegal column {} of argument of function {}, expected IPv4 or UInt8 or UInt16 or UInt32\",\n+            arguments[0].column->getName(), getName()\n+        );\n+    }\n };\n \n class FunctionIsIPv4String : public IFunction\n@@ -1066,7 +1071,7 @@ class FunctionIsIPv4String : public IFunction\n \n         for (size_t i = 0; i < vec_res.size(); ++i)\n         {\n-            vec_res[i] = DB::parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(&result));\n+            vec_res[i] = DB::parseIPv4whole(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(&result));\n             prev_offset = offsets_src[i];\n         }\n \n@@ -1121,7 +1126,7 @@ class FunctionIsIPv6String : public IFunction\n \n         for (size_t i = 0; i < vec_res.size(); ++i)\n         {\n-            vec_res[i] = DB::parseIPv6(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(buffer));\n+            vec_res[i] = DB::parseIPv6whole(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(buffer));\n             prev_offset = offsets_src[i];\n         }\n \n@@ -1150,18 +1155,11 @@ REGISTER_FUNCTION(Coding)\n     factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>>();\n     factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Default>>();\n     factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Null>>();\n-    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Throw>>();\n-    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Default>>();\n-    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Null>>();\n \n     factory.registerFunction<FunctionIPv6NumToString>();\n     factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Throw>>();\n     factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Default>>();\n     factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Null>>();\n-    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Throw>>();\n-    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Default>>();\n-    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Null>>();\n-\n \n     /// MySQL compatibility aliases:\n     factory.registerAlias(\"INET_ATON\", FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>::name, FunctionFactory::CaseInsensitive);\ndiff --git a/src/Functions/FunctionsCodingIP.h b/src/Functions/FunctionsCodingIP.h\nindex f25b25b12f0d..39ee734e6bcd 100644\n--- a/src/Functions/FunctionsCodingIP.h\n+++ b/src/Functions/FunctionsCodingIP.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <type_traits>\n #include <Common/formatIPv6.h>\n \n #include <Columns/ColumnFixedString.h>\n@@ -12,7 +13,8 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n+    extern const int CANNOT_PARSE_IPV4;\n+    extern const int CANNOT_PARSE_IPV6;\n     extern const int ILLEGAL_COLUMN;\n }\n \n@@ -25,14 +27,18 @@ enum class IPStringToNumExceptionMode : uint8_t\n \n static inline bool tryParseIPv4(const char * pos, UInt32 & result_value)\n {\n-    return parseIPv4(pos, reinterpret_cast<unsigned char *>(&result_value));\n+    return parseIPv4whole(pos, reinterpret_cast<unsigned char *>(&result_value));\n }\n \n namespace detail\n {\n-    template <IPStringToNumExceptionMode exception_mode, typename StringColumnType>\n+    template <IPStringToNumExceptionMode exception_mode, typename ToColumn = ColumnIPv6, typename StringColumnType>\n     ColumnPtr convertToIPv6(const StringColumnType & string_column, const PaddedPODArray<UInt8> * null_map = nullptr)\n     {\n+        if constexpr (!std::is_same_v<ToColumn, ColumnFixedString> && !std::is_same_v<ToColumn, ColumnIPv6>)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal return column type {}. Expected IPv6 or FixedString\", TypeName<typename ToColumn::ValueType>);\n+\n+\n         size_t column_size = string_column.size();\n \n         ColumnUInt8::MutablePtr col_null_map_to;\n@@ -44,10 +50,73 @@ namespace detail\n             vec_null_map_to = &col_null_map_to->getData();\n         }\n \n-        auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n+        /// This is a special treatment for source column of type FixedString(16)\n+        /// to preserve previous behavior when IPv6 was a domain type of FixedString(16)\n+        if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)\n+        {\n+            if (string_column.getN() == IPV6_BINARY_LENGTH)\n+            {\n+                if constexpr (std::is_same_v<ToColumn, ColumnFixedString>)\n+                {\n+                    auto col_res = ColumnFixedString::create(string_column);\n+\n+                    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+                    {\n+                        col_null_map_to = ColumnUInt8::create(column_size, false);\n+                        if (null_map)\n+                            memcpy(col_null_map_to->getData().data(), null_map->data(), column_size);\n+                        return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));\n+                    }\n+\n+                    return col_res;\n+                }\n+                else\n+                {\n+                    auto col_res = ColumnIPv6::create();\n+                    auto & vec_res = col_res->getData();\n+\n+                    vec_res.resize(column_size);\n+                    memcpy(vec_res.data(), string_column.getChars().data(), column_size * IPV6_BINARY_LENGTH);\n+\n+                    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+                    {\n+                        col_null_map_to = ColumnUInt8::create(column_size, false);\n+                        if (null_map)\n+                            memcpy(col_null_map_to->getData().data(), null_map->data(), column_size);\n+                        return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));\n+                    }\n+\n+                    return col_res;\n+                }\n+            }\n+        }\n \n-        auto & vec_res = col_res->getChars();\n-        vec_res.resize(column_size * IPV6_BINARY_LENGTH);\n+        auto column_create = []() -> typename ToColumn::MutablePtr\n+        {\n+            if constexpr (std::is_same_v<ToColumn, ColumnFixedString>)\n+                return ColumnFixedString::create(IPV6_BINARY_LENGTH);\n+            else\n+                return ColumnIPv6::create();\n+        };\n+\n+        auto get_vector = [](auto & col_res, size_t col_size) -> decltype(auto)\n+        {\n+            if constexpr (std::is_same_v<ToColumn, ColumnFixedString>)\n+            {\n+                auto & vec_res = col_res->getChars();\n+                vec_res.resize(col_size * IPV6_BINARY_LENGTH);\n+                return (vec_res);\n+            }\n+            else\n+            {\n+                auto & vec_res = col_res->getData();\n+                vec_res.resize(col_size);\n+                return (vec_res);\n+            }\n+        };\n+\n+        auto col_res = column_create();\n+        auto & vec_res = get_vector(col_res, column_size);\n \n         using Chars = typename StringColumnType::Chars;\n         const Chars & vec_src = string_column.getChars();\n@@ -56,6 +125,7 @@ namespace detail\n         char src_ipv4_buf[sizeof(\"::ffff:\") + IPV4_MAX_TEXT_LENGTH + 1] = \"::ffff:\";\n \n         /// ColumnFixedString contains not null terminated strings. But functions parseIPv6, parseIPv4 expect null terminated string.\n+        /// TODO fix this - now parseIPv6/parseIPv4 accept end iterator, so can be parsed in-place\n         std::string fixed_string_buffer;\n \n         if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)\n@@ -63,7 +133,11 @@ namespace detail\n             fixed_string_buffer.resize(string_column.getN());\n         }\n \n-        for (size_t out_offset = 0, i = 0; out_offset < vec_res.size(); out_offset += IPV6_BINARY_LENGTH, ++i)\n+        int offset_inc = 1;\n+        if constexpr (std::is_same_v<ToColumn, ColumnFixedString>)\n+            offset_inc = IPV6_BINARY_LENGTH;\n+\n+        for (size_t out_offset = 0, i = 0; i < column_size; out_offset += offset_inc, ++i)\n         {\n             size_t src_next_offset = src_offset;\n \n@@ -87,7 +161,7 @@ namespace detail\n \n             if (null_map && (*null_map)[i])\n             {\n-                std::fill_n(&vec_res[i], IPV6_BINARY_LENGTH, 0);\n+                std::fill_n(&vec_res[out_offset], offset_inc, 0);\n                 src_offset = src_next_offset;\n                 if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n                     (*vec_null_map_to)[i] = true;\n@@ -107,17 +181,17 @@ namespace detail\n                     src_ipv4_buf + std::strlen(\"::ffff:\"),\n                     src_value,\n                     std::min<UInt64>(src_next_offset - src_offset, IPV4_MAX_TEXT_LENGTH + 1));\n-                parse_result = parseIPv6(src_ipv4_buf, res_value);\n+                parse_result = parseIPv6whole(src_ipv4_buf, res_value);\n             }\n             else\n             {\n-                parse_result = parseIPv6(src_value, res_value);\n+                parse_result = parseIPv6whole(src_value, res_value);\n             }\n \n             if (!parse_result)\n             {\n                 if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n-                    throw Exception(\"Invalid IPv6 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n+                    throw Exception(\"Invalid IPv6 value\", ErrorCodes::CANNOT_PARSE_IPV6);\n                 else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)\n                     vec_res[i] = 0;\n                 else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n@@ -134,23 +208,16 @@ namespace detail\n     }\n }\n \n-template <IPStringToNumExceptionMode exception_mode>\n+template <IPStringToNumExceptionMode exception_mode, typename ToColumn = ColumnIPv6>\n ColumnPtr convertToIPv6(ColumnPtr column, const PaddedPODArray<UInt8> * null_map = nullptr)\n {\n-    size_t column_size = column->size();\n-\n-    auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n-\n-    auto & vec_res = col_res->getChars();\n-    vec_res.resize(column_size * IPV6_BINARY_LENGTH);\n-\n     if (const auto * column_input_string = checkAndGetColumn<ColumnString>(column.get()))\n     {\n-        return detail::convertToIPv6<exception_mode>(*column_input_string, null_map);\n+        return detail::convertToIPv6<exception_mode, ToColumn>(*column_input_string, null_map);\n     }\n     else if (const auto * column_input_fixed_string = checkAndGetColumn<ColumnFixedString>(column.get()))\n     {\n-        return detail::convertToIPv6<exception_mode>(*column_input_fixed_string, null_map);\n+        return detail::convertToIPv6<exception_mode, ToColumn>(*column_input_fixed_string, null_map);\n     }\n     else\n     {\n@@ -158,7 +225,7 @@ ColumnPtr convertToIPv6(ColumnPtr column, const PaddedPODArray<UInt8> * null_map\n     }\n }\n \n-template <IPStringToNumExceptionMode exception_mode>\n+template <IPStringToNumExceptionMode exception_mode, typename ToColumn = ColumnIPv4>\n ColumnPtr convertToIPv4(ColumnPtr column, const PaddedPODArray<UInt8> * null_map = nullptr)\n {\n     const ColumnString * column_string = checkAndGetColumn<ColumnString>(column.get());\n@@ -179,9 +246,9 @@ ColumnPtr convertToIPv4(ColumnPtr column, const PaddedPODArray<UInt8> * null_map\n         vec_null_map_to = &col_null_map_to->getData();\n     }\n \n-    auto col_res = ColumnUInt32::create();\n+    auto col_res = ToColumn::create();\n \n-    ColumnUInt32::Container & vec_res = col_res->getData();\n+    auto & vec_res = col_res->getData();\n     vec_res.resize(column_size);\n \n     const ColumnString::Chars & vec_src = column_string->getChars();\n@@ -205,7 +272,7 @@ ColumnPtr convertToIPv4(ColumnPtr column, const PaddedPODArray<UInt8> * null_map\n         {\n             if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n             {\n-                throw Exception(\"Invalid IPv4 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n+                throw Exception(\"Invalid IPv4 value\", ErrorCodes::CANNOT_PARSE_IPV4);\n             }\n             else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)\n             {\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 2129201f2eb2..208b31b65f75 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1154,6 +1154,8 @@ class FunctionComparison : public IFunction\n             /// You can compare the date, datetime, or datatime64 and an enumeration with a constant string.\n             || ((left.isDate() || left.isDate32() || left.isDateTime() || left.isDateTime64()) && (right.isDate() || right.isDate32() || right.isDateTime() || right.isDateTime64()) && left.idx == right.idx) /// only date vs date, or datetime vs datetime\n             || (left.isUUID() && right.isUUID())\n+            || (left.isIPv4() && right.isIPv4())\n+            || (left.isIPv6() && right.isIPv6())\n             || (left.isEnum() && right.isEnum() && arguments[0]->getName() == arguments[1]->getName()) /// only equivalent enum type values can be compared against\n             || (left_tuple && right_tuple && left_tuple->getElements().size() == right_tuple->getElements().size())\n             || (arguments[0]->equals(*arguments[1]))))\n@@ -1245,6 +1247,15 @@ class FunctionComparison : public IFunction\n         const bool left_is_float = which_left.isFloat();\n         const bool right_is_float = which_right.isFloat();\n \n+        const bool left_is_ipv6 = which_left.isIPv6();\n+        const bool right_is_ipv6 = which_right.isIPv6();\n+        const bool left_is_fixed_string = which_left.isFixedString();\n+        const bool right_is_fixed_string = which_right.isFixedString();\n+        size_t fixed_string_size =\n+            left_is_fixed_string ?\n+                assert_cast<const DataTypeFixedString &>(*left_type).getN() :\n+                (right_is_fixed_string ? assert_cast<const DataTypeFixedString &>(*right_type).getN() : 0);\n+\n         bool date_and_datetime = (which_left.idx != which_right.idx) && (which_left.isDate() || which_left.isDate32() || which_left.isDateTime() || which_left.isDateTime64())\n             && (which_right.isDate() || which_right.isDate32() || which_right.isDateTime() || which_right.isDateTime64());\n \n@@ -1287,6 +1298,17 @@ class FunctionComparison : public IFunction\n         {\n             return res;\n         }\n+        else if (((left_is_ipv6 && right_is_fixed_string) || (right_is_ipv6 && left_is_fixed_string)) && fixed_string_size == IPV6_BINARY_LENGTH)\n+        {\n+            /// Special treatment for FixedString(16) as a binary representation of IPv6 -\n+            /// CAST is customized for this case\n+            ColumnPtr left_column = left_is_ipv6 ?\n+                col_with_type_and_name_left.column : castColumn(col_with_type_and_name_left, right_type);\n+            ColumnPtr right_column = right_is_ipv6 ?\n+                col_with_type_and_name_right.column : castColumn(col_with_type_and_name_right, left_type);\n+\n+            return executeGenericIdenticalTypes(left_column.get(), right_column.get());\n+        }\n         else if ((isColumnedAsDecimal(left_type) || isColumnedAsDecimal(right_type)))\n         {\n             // Comparing Date/Date32 and DateTime64 requires implicit conversion,\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex d607af54fcd0..01e057e19a1e 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -39,6 +39,8 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToDateTime32>();\n     factory.registerFunction<FunctionToDateTime64>();\n     factory.registerFunction<FunctionToUUID>();\n+    factory.registerFunction<FunctionToIPv4>();\n+    factory.registerFunction<FunctionToIPv6>();\n     factory.registerFunction<FunctionToString>();\n \n     factory.registerFunction<FunctionToUnixTimestamp>();\n@@ -68,6 +70,8 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToDecimal256OrZero>();\n \n     factory.registerFunction<FunctionToUUIDOrZero>();\n+    factory.registerFunction<FunctionToIPv4OrZero>();\n+    factory.registerFunction<FunctionToIPv6OrZero>();\n \n     factory.registerFunction<FunctionToUInt8OrNull>();\n     factory.registerFunction<FunctionToUInt16OrNull>();\n@@ -94,6 +98,8 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToDecimal256OrNull>();\n \n     factory.registerFunction<FunctionToUUIDOrNull>();\n+    factory.registerFunction<FunctionToIPv4OrNull>();\n+    factory.registerFunction<FunctionToIPv6OrNull>();\n \n     factory.registerFunction<FunctionParseDateTimeBestEffort>();\n     factory.registerFunction<FunctionParseDateTimeBestEffortOrZero>();\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 8847621661d0..f846005d7a78 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -55,6 +55,7 @@\n #include <Columns/ColumnLowCardinality.h>\n #include <Interpreters/Context.h>\n #include <Common/HashTable/HashMap.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <Core/Types.h>\n \n \n@@ -73,6 +74,8 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_DATETIME;\n     extern const int CANNOT_PARSE_TEXT;\n     extern const int CANNOT_PARSE_UUID;\n+    extern const int CANNOT_PARSE_IPV4;\n+    extern const int CANNOT_PARSE_IPV6;\n     extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;\n     extern const int LOGICAL_ERROR;\n     extern const int TYPE_MISMATCH;\n@@ -120,6 +123,7 @@ struct AccurateOrNullConvertStrategyAdditions\n \n struct ConvertDefaultBehaviorTag {};\n struct ConvertReturnNullOnErrorTag {};\n+struct ConvertReturnZeroOnErrorTag {};\n \n /** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n   *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n@@ -208,6 +212,17 @@ struct ConvertImpl\n                 {\n                     throw Exception(\"Conversion between numeric types and UUID is not supported. Probably the passed UUID is unquoted\", ErrorCodes::NOT_IMPLEMENTED);\n                 }\n+                else if constexpr (\n+                    (std::is_same_v<FromDataType, DataTypeIPv4> != std::is_same_v<ToDataType, DataTypeIPv4>)\n+                    && !(is_any_of<FromDataType, DataTypeUInt8, DataTypeUInt16, DataTypeUInt32> || is_any_of<ToDataType, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256>)\n+                )\n+                {\n+                    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from {} to {} is not supported\", TypeName<typename FromDataType::FieldType>, TypeName<typename ToDataType::FieldType>);\n+                }\n+                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> != std::is_same_v<ToDataType, DataTypeIPv6>)\n+                {\n+                    throw Exception(\"Conversion between numeric types and IPv6 is not supported. Probably the passed IPv6 is unquoted\", ErrorCodes::NOT_IMPLEMENTED);\n+                }\n                 else\n                 {\n                     if constexpr (IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n@@ -993,6 +1008,22 @@ inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb\n     x = tmp.toUnderType();\n }\n \n+template <>\n+inline void parseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+{\n+    IPv4 tmp;\n+    readIPv4Text(tmp, rb);\n+    x = tmp.toUnderType();\n+}\n+\n+template <>\n+inline void parseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+{\n+    IPv6 tmp;\n+    readIPv6Text(tmp, rb);\n+    x = tmp;\n+}\n+\n template <typename DataType>\n bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n {\n@@ -1043,6 +1074,28 @@ inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer &\n     return true;\n }\n \n+template <>\n+inline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+{\n+    IPv4 tmp;\n+    if (!tryReadIPv4Text(tmp, rb))\n+        return false;\n+\n+    x = tmp.toUnderType();\n+    return true;\n+}\n+\n+template <>\n+inline bool tryParseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+{\n+    IPv6 tmp;\n+    if (!tryReadIPv6Text(tmp, rb))\n+        return false;\n+\n+    x = tmp;\n+    return true;\n+}\n+\n \n /** Throw exception with verbose message when string value is not parsed completely.\n   */\n@@ -1262,7 +1315,20 @@ struct ConvertThroughParsing\n                     }\n                     else\n                     {\n-                        parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                        /// we want to utilize constexpr condition here, which is not mixable with value comparison\n+                        do\n+                        {\n+                            if constexpr (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>)\n+                            {\n+                                if (fixed_string_size == IPV6_BINARY_LENGTH)\n+                                {\n+                                    readBinary(vec_to[i], read_buffer);\n+                                    break;\n+                                }\n+                            }\n+\n+                            parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                        } while (false);\n                     }\n                 }\n \n@@ -1317,7 +1383,23 @@ struct ConvertThroughParsing\n                             vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n                     }\n                     else\n-                        parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                    {\n+                        /// we want to utilize constexpr condition here, which is not mixable with value comparison\n+                        do\n+                        {\n+                            if constexpr (std::is_same_v<FromDataType, DataTypeFixedString> && std::is_same_v<ToDataType, DataTypeIPv6>)\n+                            {\n+                                if (fixed_string_size == IPV6_BINARY_LENGTH)\n+                                {\n+                                    readBinary(vec_to[i], read_buffer);\n+                                    parsed = true;\n+                                    break;\n+                                }\n+                            }\n+\n+                            parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                        } while (false);\n+                    }\n                 }\n \n                 if (!isAllRead(read_buffer))\n@@ -1370,6 +1452,11 @@ requires (!std::is_same_v<ToDataType, DataTypeFixedString>)\n struct ConvertImpl<DataTypeFixedString, ToDataType, Name, ConvertReturnNullOnErrorTag>\n     : ConvertThroughParsing<DataTypeFixedString, ToDataType, Name, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::Normal> {};\n \n+template <typename FromDataType, typename ToDataType, typename Name>\n+requires (is_any_of<FromDataType, DataTypeString, DataTypeFixedString> && is_any_of<ToDataType, DataTypeIPv4, DataTypeIPv6>)\n+struct ConvertImpl<FromDataType, ToDataType, Name, ConvertReturnZeroOnErrorTag>\n+    : ConvertThroughParsing<FromDataType, ToDataType, Name, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::Normal> {};\n+\n /// Generic conversion of any type from String. Used for complex types: Array and Tuple or types with custom serialization.\n template <typename StringColumnType>\n struct ConvertImplGenericFromString\n@@ -1597,9 +1684,12 @@ class FunctionConvert : public IFunction\n                                                 std::is_same_v<ToDataType, DataTypeDate32> ||\n                                                 std::is_same_v<ToDataType, DataTypeDateTime>;\n \n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionConvert>(); }\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionConvert>(context); }\n     static FunctionPtr create() { return std::make_shared<FunctionConvert>(); }\n \n+    FunctionConvert() = default;\n+    explicit FunctionConvert(ContextPtr context_) : context(context_) {}\n+\n     String getName() const override\n     {\n         return name;\n@@ -1763,7 +1853,9 @@ class FunctionConvert : public IFunction\n                 || e.code() == ErrorCodes::CANNOT_PARSE_ESCAPE_SEQUENCE\n                 || e.code() == ErrorCodes::CANNOT_PARSE_DATE\n                 || e.code() == ErrorCodes::CANNOT_PARSE_DATETIME\n-                || e.code() == ErrorCodes::CANNOT_PARSE_UUID)\n+                || e.code() == ErrorCodes::CANNOT_PARSE_UUID\n+                || e.code() == ErrorCodes::CANNOT_PARSE_IPV4\n+                || e.code() == ErrorCodes::CANNOT_PARSE_IPV6)\n             {\n                 e.addMessage(\"Cannot parse \"\n                     + result_type->getName() + \" from \"\n@@ -1785,6 +1877,7 @@ class FunctionConvert : public IFunction\n     }\n \n private:\n+    ContextPtr context;\n     mutable bool checked_return_type = false;\n     mutable bool to_nullable = false;\n \n@@ -1884,19 +1977,27 @@ class FunctionConvert : public IFunction\n                 return ConvertImplGenericToString<ColumnString>::execute(arguments, result_type, input_rows_count);\n         }\n \n-        bool done;\n+        bool done = false;\n         if constexpr (to_string_or_fixed_string)\n         {\n             done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{});\n         }\n         else\n         {\n-            /// We should use ConvertFromStringExceptionMode::Null mode when converting from String (or FixedString)\n-            /// to Nullable type, to avoid 'value is too short' error on attempt to parse empty string from NULL values.\n-            if (to_nullable && WhichDataType(from_type).isStringOrFixedString())\n-                done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertReturnNullOnErrorTag{});\n-            else\n-                done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{});\n+            bool cast_ipv4_ipv6_default_on_conversion_error = false;\n+            if constexpr (is_any_of<ToDataType, DataTypeIPv4, DataTypeIPv6>)\n+                if (context && (cast_ipv4_ipv6_default_on_conversion_error = context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error))\n+                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertReturnZeroOnErrorTag{});\n+\n+            if (!cast_ipv4_ipv6_default_on_conversion_error)\n+            {\n+                /// We should use ConvertFromStringExceptionMode::Null mode when converting from String (or FixedString)\n+                /// to Nullable type, to avoid 'value is too short' error on attempt to parse empty string from NULL values.\n+                if (to_nullable && WhichDataType(from_type).isStringOrFixedString())\n+                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertReturnNullOnErrorTag{});\n+                else\n+                    done = callOnIndexAndDataType<ToDataType>(from_type->getTypeId(), call, ConvertDefaultBehaviorTag{});\n+            }\n         }\n \n         if (!done)\n@@ -2357,6 +2458,8 @@ struct NameToInt256 { static constexpr auto name = \"toInt256\"; };\n struct NameToFloat32 { static constexpr auto name = \"toFloat32\"; };\n struct NameToFloat64 { static constexpr auto name = \"toFloat64\"; };\n struct NameToUUID { static constexpr auto name = \"toUUID\"; };\n+struct NameToIPv4 { static constexpr auto name = \"toIPv4\"; };\n+struct NameToIPv6 { static constexpr auto name = \"toIPv6\"; };\n \n using FunctionToUInt8 = FunctionConvert<DataTypeUInt8, NameToUInt8, ToNumberMonotonicity<UInt8>>;\n using FunctionToUInt16 = FunctionConvert<DataTypeUInt16, NameToUInt16, ToNumberMonotonicity<UInt16>>;\n@@ -2378,6 +2481,8 @@ using FunctionToDateTime = FunctionConvert<DataTypeDateTime, NameToDateTime, ToD\n using FunctionToDateTime32 = FunctionConvert<DataTypeDateTime, NameToDateTime32, ToDateTimeMonotonicity>;\n using FunctionToDateTime64 = FunctionConvert<DataTypeDateTime64, NameToDateTime64, ToDateTimeMonotonicity>;\n using FunctionToUUID = FunctionConvert<DataTypeUUID, NameToUUID, ToNumberMonotonicity<UInt128>>;\n+using FunctionToIPv4 = FunctionConvert<DataTypeIPv4, NameToIPv4, ToNumberMonotonicity<UInt32>>;\n+using FunctionToIPv6 = FunctionConvert<DataTypeIPv6, NameToIPv6, ToNumberMonotonicity<UInt128>>;\n using FunctionToString = FunctionConvert<DataTypeString, NameToString, ToStringMonotonicity>;\n using FunctionToUnixTimestamp = FunctionConvert<DataTypeUInt32, NameToUnixTimestamp, ToNumberMonotonicity<UInt32>>;\n using FunctionToDecimal32 = FunctionConvert<DataTypeDecimal<Decimal32>, NameToDecimal32, UnknownMonotonicity>;\n@@ -2407,6 +2512,8 @@ template <> struct FunctionTo<DataTypeDate32> { using Type = FunctionToDate32; }\n template <> struct FunctionTo<DataTypeDateTime> { using Type = FunctionToDateTime; };\n template <> struct FunctionTo<DataTypeDateTime64> { using Type = FunctionToDateTime64; };\n template <> struct FunctionTo<DataTypeUUID> { using Type = FunctionToUUID; };\n+template <> struct FunctionTo<DataTypeIPv4> { using Type = FunctionToIPv4; };\n+template <> struct FunctionTo<DataTypeIPv6> { using Type = FunctionToIPv6; };\n template <> struct FunctionTo<DataTypeString> { using Type = FunctionToString; };\n template <> struct FunctionTo<DataTypeFixedString> { using Type = FunctionToFixedString; };\n template <> struct FunctionTo<DataTypeDecimal<Decimal32>> { using Type = FunctionToDecimal32; };\n@@ -2442,6 +2549,8 @@ struct NameToDecimal64OrZero { static constexpr auto name = \"toDecimal64OrZero\";\n struct NameToDecimal128OrZero { static constexpr auto name = \"toDecimal128OrZero\"; };\n struct NameToDecimal256OrZero { static constexpr auto name = \"toDecimal256OrZero\"; };\n struct NameToUUIDOrZero { static constexpr auto name = \"toUUIDOrZero\"; };\n+struct NameToIPv4OrZero { static constexpr auto name = \"toIPv4OrZero\"; };\n+struct NameToIPv6OrZero { static constexpr auto name = \"toIPv6OrZero\"; };\n \n using FunctionToUInt8OrZero = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToUInt16OrZero = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrZero, ConvertFromStringExceptionMode::Zero>;\n@@ -2466,6 +2575,8 @@ using FunctionToDecimal64OrZero = FunctionConvertFromString<DataTypeDecimal<Deci\n using FunctionToDecimal128OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToDecimal256OrZero = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToUUIDOrZero = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrZero, ConvertFromStringExceptionMode::Zero>;\n+using FunctionToIPv4OrZero = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrZero, ConvertFromStringExceptionMode::Zero>;\n+using FunctionToIPv6OrZero = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrZero, ConvertFromStringExceptionMode::Zero>;\n \n struct NameToUInt8OrNull { static constexpr auto name = \"toUInt8OrNull\"; };\n struct NameToUInt16OrNull { static constexpr auto name = \"toUInt16OrNull\"; };\n@@ -2490,6 +2601,8 @@ struct NameToDecimal64OrNull { static constexpr auto name = \"toDecimal64OrNull\";\n struct NameToDecimal128OrNull { static constexpr auto name = \"toDecimal128OrNull\"; };\n struct NameToDecimal256OrNull { static constexpr auto name = \"toDecimal256OrNull\"; };\n struct NameToUUIDOrNull { static constexpr auto name = \"toUUIDOrNull\"; };\n+struct NameToIPv4OrNull { static constexpr auto name = \"toIPv4OrNull\"; };\n+struct NameToIPv6OrNull { static constexpr auto name = \"toIPv6OrNull\"; };\n \n using FunctionToUInt8OrNull = FunctionConvertFromString<DataTypeUInt8, NameToUInt8OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToUInt16OrNull = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrNull, ConvertFromStringExceptionMode::Null>;\n@@ -2514,6 +2627,8 @@ using FunctionToDecimal64OrNull = FunctionConvertFromString<DataTypeDecimal<Deci\n using FunctionToDecimal128OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal128>, NameToDecimal128OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToDecimal256OrNull = FunctionConvertFromString<DataTypeDecimal<Decimal256>, NameToDecimal256OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToUUIDOrNull = FunctionConvertFromString<DataTypeUUID, NameToUUIDOrNull, ConvertFromStringExceptionMode::Null>;\n+using FunctionToIPv4OrNull = FunctionConvertFromString<DataTypeIPv4, NameToIPv4OrNull, ConvertFromStringExceptionMode::Null>;\n+using FunctionToIPv6OrNull = FunctionConvertFromString<DataTypeIPv6, NameToIPv6OrNull, ConvertFromStringExceptionMode::Null>;\n \n struct NameParseDateTimeBestEffort { static constexpr auto name = \"parseDateTimeBestEffort\"; };\n struct NameParseDateTimeBestEffortOrZero { static constexpr auto name = \"parseDateTimeBestEffortOrZero\"; };\n@@ -2642,17 +2757,17 @@ class FunctionCast final : public FunctionCastBase\n public:\n     using WrapperType = std::function<ColumnPtr(ColumnsWithTypeAndName &, const DataTypePtr &, const ColumnNullable *, size_t)>;\n \n-    FunctionCast(const char * cast_name_\n+    FunctionCast(ContextPtr context_\n+            , const char * cast_name_\n             , MonotonicityForRange && monotonicity_for_range_\n             , const DataTypes & argument_types_\n             , const DataTypePtr & return_type_\n             , std::optional<Diagnostic> diagnostic_\n-            , CastType cast_type_\n-            , bool cast_ipv4_ipv6_default_on_conversion_error_)\n+            , CastType cast_type_)\n         : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n         , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n         , cast_type(cast_type_)\n-        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)\n+        , context(context_)\n     {\n     }\n \n@@ -2699,7 +2814,7 @@ class FunctionCast final : public FunctionCastBase\n \n     std::optional<Diagnostic> diagnostic;\n     CastType cast_type;\n-    bool cast_ipv4_ipv6_default_on_conversion_error;\n+    ContextPtr context;\n \n     static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)\n     {\n@@ -2740,7 +2855,7 @@ class FunctionCast final : public FunctionCastBase\n         }\n         else if (!can_apply_accurate_cast)\n         {\n-            FunctionPtr function = FunctionTo<ToDataType>::Type::create();\n+            FunctionPtr function = FunctionTo<ToDataType>::Type::create(context);\n             return createFunctionAdaptor(function, from_type);\n         }\n \n@@ -3767,7 +3882,9 @@ class FunctionCast final : public FunctionCastBase\n                 std::is_same_v<ToDataType, DataTypeDate> ||\n                 std::is_same_v<ToDataType, DataTypeDate32> ||\n                 std::is_same_v<ToDataType, DataTypeDateTime> ||\n-                std::is_same_v<ToDataType, DataTypeUUID>)\n+                std::is_same_v<ToDataType, DataTypeUUID> ||\n+                std::is_same_v<ToDataType, DataTypeIPv4> ||\n+                std::is_same_v<ToDataType, DataTypeIPv6>)\n             {\n                 ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                 return true;\n@@ -3801,9 +3918,11 @@ class FunctionCast final : public FunctionCastBase\n             return false;\n         };\n \n-        bool cast_ipv4_ipv6_default_on_conversion_error_value = cast_ipv4_ipv6_default_on_conversion_error;\n+        bool cast_ipv4_ipv6_default_on_conversion_error_value = context && context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error;\n+        bool input_format_ipv4_default_on_conversion_error_value = context && context->getSettingsRef().input_format_ipv4_default_on_conversion_error;\n+        bool input_format_ipv6_default_on_conversion_error_value = context && context->getSettingsRef().input_format_ipv6_default_on_conversion_error;\n \n-        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value](const auto & types) -> bool\n+        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value](const auto & types) -> bool\n         {\n             using Types = std::decay_t<decltype(types)>;\n             using ToDataType = typename Types::RightType;\n@@ -3811,47 +3930,47 @@ class FunctionCast final : public FunctionCastBase\n \n             if constexpr (WhichDataType(FromDataType::type_id).isStringOrFixedString())\n             {\n-                if (to_type->getCustomSerialization() && to_type->getCustomName())\n+                if constexpr (std::is_same_v<ToDataType, DataTypeIPv4>)\n                 {\n-                    if (to_type->getCustomName()->getName() == \"IPv4\")\n-                    {\n-                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, requested_result_is_nullable](\n                                   ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n                             -> ColumnPtr\n-                        {\n-                            if (!WhichDataType(result_type).isUInt32())\n-                                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected UInt32\", result_type->getName());\n+                    {\n+                        if (!WhichDataType(result_type).isIPv4())\n+                            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n \n-                            const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                            if (cast_ipv4_ipv6_default_on_conversion_error_value)\n-                                return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n-                            else\n-                                return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n-                        };\n+                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n+                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value || requested_result_is_nullable)\n+                            return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n+                        else\n+                            return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n+                    };\n \n-                        return true;\n-                    }\n+                    return true;\n+                }\n \n-                    if (to_type->getCustomName()->getName() == \"IPv6\")\n-                    {\n-                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](\n+                if constexpr (std::is_same_v<ToDataType, DataTypeIPv6>)\n+                {\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n                                   ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n                             -> ColumnPtr\n-                        {\n-                            if (!WhichDataType(result_type).isFixedString())\n-                                throw Exception(\n-                                    ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected FixedString\", result_type->getName());\n+                    {\n+                        if (!WhichDataType(result_type).isIPv6())\n+                            throw Exception(\n+                                ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv6\", result_type->getName());\n \n-                            const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                            if (cast_ipv4_ipv6_default_on_conversion_error_value)\n-                                return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n-                            else\n-                                return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n-                        };\n+                        const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n+                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                            return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n+                        else\n+                            return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n+                    };\n \n-                        return true;\n-                    }\n+                    return true;\n+                }\n \n+                if (to_type->getCustomSerialization() && to_type->getCustomName())\n+                {\n                     ret = &ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute;\n                     return true;\n                 }\ndiff --git a/src/Functions/FunctionsExternalDictionaries.cpp b/src/Functions/FunctionsExternalDictionaries.cpp\nindex 371b838635b9..cdc229de99b2 100644\n--- a/src/Functions/FunctionsExternalDictionaries.cpp\n+++ b/src/Functions/FunctionsExternalDictionaries.cpp\n@@ -7,42 +7,113 @@ namespace DB\n \n REGISTER_FUNCTION(ExternalDictionaries)\n {\n-    factory.registerFunction<FunctionDictHas>();\n-    factory.registerFunction<FunctionDictGetUInt8>();\n-    factory.registerFunction<FunctionDictGetUInt16>();\n-    factory.registerFunction<FunctionDictGetUInt32>();\n-    factory.registerFunction<FunctionDictGetUInt64>();\n-    factory.registerFunction<FunctionDictGetInt8>();\n-    factory.registerFunction<FunctionDictGetInt16>();\n-    factory.registerFunction<FunctionDictGetInt32>();\n-    factory.registerFunction<FunctionDictGetInt64>();\n-    factory.registerFunction<FunctionDictGetFloat32>();\n-    factory.registerFunction<FunctionDictGetFloat64>();\n-    factory.registerFunction<FunctionDictGetDate>();\n-    factory.registerFunction<FunctionDictGetDateTime>();\n-    factory.registerFunction<FunctionDictGetUUID>();\n-    factory.registerFunction<FunctionDictGetString>();\n-    factory.registerFunction<FunctionDictGetHierarchy>();\n-    factory.registerFunction<FunctionDictIsIn>();\n-    factory.registerFunction<FunctionDictGetChildrenOverloadResolver>();\n-    factory.registerFunction<FunctionDictGetDescendantsOverloadResolver>();\n-    factory.registerFunction<FunctionDictGetUInt8OrDefault>();\n-    factory.registerFunction<FunctionDictGetUInt16OrDefault>();\n-    factory.registerFunction<FunctionDictGetUInt32OrDefault>();\n-    factory.registerFunction<FunctionDictGetUInt64OrDefault>();\n-    factory.registerFunction<FunctionDictGetInt8OrDefault>();\n-    factory.registerFunction<FunctionDictGetInt16OrDefault>();\n-    factory.registerFunction<FunctionDictGetInt32OrDefault>();\n-    factory.registerFunction<FunctionDictGetInt64OrDefault>();\n-    factory.registerFunction<FunctionDictGetFloat32OrDefault>();\n-    factory.registerFunction<FunctionDictGetFloat64OrDefault>();\n-    factory.registerFunction<FunctionDictGetDateOrDefault>();\n-    factory.registerFunction<FunctionDictGetDateTimeOrDefault>();\n-    factory.registerFunction<FunctionDictGetUUIDOrDefault>();\n-    factory.registerFunction<FunctionDictGetStringOrDefault>();\n-    factory.registerFunction<FunctionDictGetNoType<DictionaryGetFunctionType::get>>();\n-    factory.registerFunction<FunctionDictGetNoType<DictionaryGetFunctionType::getOrDefault>>();\n-    factory.registerFunction<FunctionDictGetOrNull>();\n+    const std::string dict_get_description { R\"(\n+Retrieves values from a dictionary.\n+\n+Accepts 3 parameters:\n+-- name of the dictionary;\n+-- name of the column of the dictionary or tuple of column names;\n+-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n+\n+Returned value: value of the dictionary attribute parsed in the {} if key is found, otherwise <null_value> element specified in the dictionary configuration.\n+\n+Throws an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n+)\" };\n+\n+    const std::string dict_get_or_default_description { R\"(\n+Retrieves values from a dictionary.\n+\n+Accepts 4 parameters:\n+-- name of the dictionary;\n+-- name of the column of the dictionary or tuple of column names;\n+-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n+-- default values returned if the dictionary does not contain a row with the key value;\n+\n+Returned value: value of the dictionary attribute parsed in the {} if key is found, otherwise default value.\n+\n+Throws an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n+)\" };\n+\n+    const std::string dict_get_or_null_description { R\"(\n+Retrieves values from a dictionary.\n+\n+Accepts 3 parameters:\n+-- name of the dictionary;\n+-- name of the column of the dictionary or tuple of column names;\n+-- key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration;\n+\n+Returned value: value of the dictionary attribute parsed in the attribute\u2019s data type if key is found, otherwise NULL.\n+\n+Throws an exception if cannot parse the value of the attribute or the value does not match the attribute data type.\n+)\" };\n+\n+    factory.registerFunction<FunctionDictGetNoType<DictionaryGetFunctionType::get>>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"attribute\u2019s data type\") });\n+    factory.registerFunction<FunctionDictGetNoType<DictionaryGetFunctionType::getOrDefault>>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"attribute\u2019s data type\") });\n+    factory.registerFunction<FunctionDictGetOrNull>(Documentation{ dict_get_or_null_description });\n+\n+    factory.registerFunction<FunctionDictGetUInt8>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"UInt8\") });\n+    factory.registerFunction<FunctionDictGetUInt16>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"UInt16\") });\n+    factory.registerFunction<FunctionDictGetUInt32>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"UInt32\") });\n+    factory.registerFunction<FunctionDictGetUInt64>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"UInt64\") });\n+    factory.registerFunction<FunctionDictGetInt8>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Int8\") });\n+    factory.registerFunction<FunctionDictGetInt16>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Int16\") });\n+    factory.registerFunction<FunctionDictGetInt32>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Int32\") });\n+    factory.registerFunction<FunctionDictGetInt64>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Int64\") });\n+    factory.registerFunction<FunctionDictGetFloat32>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Float32\") });\n+    factory.registerFunction<FunctionDictGetFloat64>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Float64\") });\n+    factory.registerFunction<FunctionDictGetDate>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"Date\") });\n+    factory.registerFunction<FunctionDictGetDateTime>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"DateTime\") });\n+    factory.registerFunction<FunctionDictGetUUID>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"UUID\") });\n+    factory.registerFunction<FunctionDictGetIPv4>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"IPv4\") });\n+    factory.registerFunction<FunctionDictGetIPv6>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"IPv6\") });\n+    factory.registerFunction<FunctionDictGetString>(Documentation{ fmt::format(fmt::runtime(dict_get_description), \"String\") });\n+\n+    factory.registerFunction<FunctionDictGetUInt8OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"UInt8\") });\n+    factory.registerFunction<FunctionDictGetUInt16OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"UInt16\") });\n+    factory.registerFunction<FunctionDictGetUInt32OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"UInt32\") });\n+    factory.registerFunction<FunctionDictGetUInt64OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"UInt64\") });\n+    factory.registerFunction<FunctionDictGetInt8OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Int8\") });\n+    factory.registerFunction<FunctionDictGetInt16OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Int16\") });\n+    factory.registerFunction<FunctionDictGetInt32OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Int32\") });\n+    factory.registerFunction<FunctionDictGetInt64OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Int64\") });\n+    factory.registerFunction<FunctionDictGetFloat32OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Float32\") });\n+    factory.registerFunction<FunctionDictGetFloat64OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Float64\") });\n+    factory.registerFunction<FunctionDictGetDateOrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"Date\") });\n+    factory.registerFunction<FunctionDictGetDateTimeOrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"DateTime\") });\n+    factory.registerFunction<FunctionDictGetUUIDOrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"UUID\") });\n+    factory.registerFunction<FunctionDictGetIPv4OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"IPv4\") });\n+    factory.registerFunction<FunctionDictGetIPv6OrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"IPv6\") });\n+    factory.registerFunction<FunctionDictGetStringOrDefault>(Documentation{ fmt::format(fmt::runtime(dict_get_or_default_description), \"String\") });\n+\n+    factory.registerFunction<FunctionDictHas>(Documentation{ R\"(\n+Checks whether a key is present in a dictionary.\n+Accepts 2 parameters: name of the dictionary, key value - expression returning dictionary key-type value or tuple-type value - depending on the dictionary configuration.\n+Returned value: 0 if there is no key, 1 if there is a key, type of UInt8\n+)\"});\n+\n+    factory.registerFunction<FunctionDictGetHierarchy>(Documentation{ R\"(\n+Creates an array, containing all the parents of a key in the hierarchical dictionary.\n+Accepts 2 parameters: name of the dictionary, key value - expression returning a UInt64-type value.\n+Returned value: parents for the key, type of Array(UInt64)\n+)\"});\n+\n+    factory.registerFunction<FunctionDictIsIn>(Documentation{ R\"(\n+Checks the ancestor of a key through the whole hierarchical chain in the dictionary.\n+Accepts 3 parameters: name of the dictionary, key to be checked - expression returning a UInt64-type value, alleged ancestor of the key - expression returning a UInt64-type.\n+Returned value: 0 if key is not a child of the ancestor, 1 if key is a child of the ancestor or if key is the ancestor, type of UInt8\n+)\"});\n+\n+    factory.registerFunction<FunctionDictGetChildrenOverloadResolver>(Documentation{ R\"(\n+Returns first-level children as an array of indexes. It is the inverse transformation for dictGetHierarchy.\n+Accepts 2 parameters: name of the dictionary, key value - expression returning a UInt64-type value.\n+Returned value: first-level descendants for the key, type of Array(UInt64)\n+)\"});\n+\n+    factory.registerFunction<FunctionDictGetDescendantsOverloadResolver>(Documentation{ R\"(\n+Returns all descendants as if dictGetChildren function was applied level times recursively.\n+Accepts 3 parameters: name of the dictionary, key value - expression returning a UInt64-type value, level \u2014 hierarchy level - If level = 0 returns all descendants to the end - UInt8\n+Returned value: descendants for the key, type of Array(UInt64)\n+)\"});\n }\n \n }\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 4bc7a17cf4c3..4a2fd50553ba 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -8,6 +8,7 @@\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n \n@@ -716,6 +717,8 @@ struct NameDictGetFloat64 { static constexpr auto name = \"dictGetFloat64\"; };\n struct NameDictGetDate { static constexpr auto name = \"dictGetDate\"; };\n struct NameDictGetDateTime { static constexpr auto name = \"dictGetDateTime\"; };\n struct NameDictGetUUID { static constexpr auto name = \"dictGetUUID\"; };\n+struct NameDictGetIPv4 { static constexpr auto name = \"dictGetIPv4\"; };\n+struct NameDictGetIPv6 { static constexpr auto name = \"dictGetIPv6\"; };\n struct NameDictGetDecimal32 { static constexpr auto name = \"dictGetDecimal32\"; };\n struct NameDictGetDecimal64 { static constexpr auto name = \"dictGetDecimal64\"; };\n struct NameDictGetDecimal128 { static constexpr auto name = \"dictGetDecimal128\"; };\n@@ -734,6 +737,8 @@ using FunctionDictGetFloat64 = FunctionDictGet<DataTypeFloat64, NameDictGetFloat\n using FunctionDictGetDate = FunctionDictGet<DataTypeDate, NameDictGetDate>;\n using FunctionDictGetDateTime = FunctionDictGet<DataTypeDateTime, NameDictGetDateTime>;\n using FunctionDictGetUUID = FunctionDictGet<DataTypeUUID, NameDictGetUUID>;\n+using FunctionDictGetIPv4 = FunctionDictGet<DataTypeIPv4, NameDictGetIPv4>;\n+using FunctionDictGetIPv6 = FunctionDictGet<DataTypeIPv6, NameDictGetIPv6>;\n using FunctionDictGetDecimal32 = FunctionDictGet<DataTypeDecimal<Decimal32>, NameDictGetDecimal32>;\n using FunctionDictGetDecimal64 = FunctionDictGet<DataTypeDecimal<Decimal64>, NameDictGetDecimal64>;\n using FunctionDictGetDecimal128 = FunctionDictGet<DataTypeDecimal<Decimal128>, NameDictGetDecimal128>;\n@@ -755,6 +760,8 @@ struct NameDictGetFloat64OrDefault { static constexpr auto name = \"dictGetFloat6\n struct NameDictGetDateOrDefault { static constexpr auto name = \"dictGetDateOrDefault\"; };\n struct NameDictGetDateTimeOrDefault { static constexpr auto name = \"dictGetDateTimeOrDefault\"; };\n struct NameDictGetUUIDOrDefault { static constexpr auto name = \"dictGetUUIDOrDefault\"; };\n+struct NameDictGetIPv4OrDefault { static constexpr auto name = \"dictGetIPv4OrDefault\"; };\n+struct NameDictGetIPv6OrDefault { static constexpr auto name = \"dictGetIPv6OrDefault\"; };\n struct NameDictGetDecimal32OrDefault { static constexpr auto name = \"dictGetDecimal32OrDefault\"; };\n struct NameDictGetDecimal64OrDefault { static constexpr auto name = \"dictGetDecimal64OrDefault\"; };\n struct NameDictGetDecimal128OrDefault { static constexpr auto name = \"dictGetDecimal128OrDefault\"; };\n@@ -773,6 +780,8 @@ using FunctionDictGetFloat64OrDefault = FunctionDictGetOrDefault<DataTypeFloat64\n using FunctionDictGetDateOrDefault = FunctionDictGetOrDefault<DataTypeDate, NameDictGetDateOrDefault>;\n using FunctionDictGetDateTimeOrDefault = FunctionDictGetOrDefault<DataTypeDateTime, NameDictGetDateTimeOrDefault>;\n using FunctionDictGetUUIDOrDefault = FunctionDictGetOrDefault<DataTypeUUID, NameDictGetUUIDOrDefault>;\n+using FunctionDictGetIPv4OrDefault = FunctionDictGetOrDefault<DataTypeIPv4, NameDictGetIPv4OrDefault>;\n+using FunctionDictGetIPv6OrDefault = FunctionDictGetOrDefault<DataTypeIPv6, NameDictGetIPv6OrDefault>;\n using FunctionDictGetDecimal32OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal32>, NameDictGetDecimal32OrDefault>;\n using FunctionDictGetDecimal64OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal64>, NameDictGetDecimal64OrDefault>;\n using FunctionDictGetDecimal128OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal128>, NameDictGetDecimal128OrDefault>;\ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex 2d1f0ea0c39c..cadff1780983 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -1136,6 +1136,8 @@ class FunctionAnyHash : public IFunction\n         else if (which.isInt128()) executeBigIntType<Int128, first>(icolumn, vec_to);\n         else if (which.isInt256()) executeBigIntType<Int256, first>(icolumn, vec_to);\n         else if (which.isUUID()) executeBigIntType<UUID, first>(icolumn, vec_to);\n+        else if (which.isIPv4()) executeBigIntType<IPv4, first>(icolumn, vec_to);\n+        else if (which.isIPv6()) executeBigIntType<IPv6, first>(icolumn, vec_to);\n         else if (which.isEnum8()) executeIntType<Int8, first>(icolumn, vec_to);\n         else if (which.isEnum16()) executeIntType<Int16, first>(icolumn, vec_to);\n         else if (which.isDate()) executeIntType<UInt16, first>(icolumn, vec_to);\ndiff --git a/src/Functions/array/arrayElement.cpp b/src/Functions/array/arrayElement.cpp\nindex 59224096d3c1..3e43d8d34ee5 100644\n--- a/src/Functions/array/arrayElement.cpp\n+++ b/src/Functions/array/arrayElement.cpp\n@@ -927,7 +927,9 @@ static bool castColumnNumeric(const IColumn * column, F && f)\n         ColumnVector<Int64>,\n         ColumnVector<Int128>,\n         ColumnVector<Int256>,\n-        ColumnVector<UUID>\n+        ColumnVector<UUID>,\n+        ColumnVector<IPv4>,\n+        ColumnVector<IPv6>\n     >(column, std::forward<F>(f));\n }\n \ndiff --git a/src/Functions/castOrDefault.cpp b/src/Functions/castOrDefault.cpp\nindex 1f527b7ec232..f71675dcbad4 100644\n--- a/src/Functions/castOrDefault.cpp\n+++ b/src/Functions/castOrDefault.cpp\n@@ -8,6 +8,7 @@\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnNullable.h>\n@@ -334,6 +335,8 @@ struct NameToDecimal64OrDefault { static constexpr auto name = \"toDecimal64OrDef\n struct NameToDecimal128OrDefault { static constexpr auto name = \"toDecimal128OrDefault\"; };\n struct NameToDecimal256OrDefault { static constexpr auto name = \"toDecimal256OrDefault\"; };\n struct NameToUUIDOrDefault { static constexpr auto name = \"toUUIDOrDefault\"; };\n+struct NameToIPv4OrDefault { static constexpr auto name = \"toIPv4OrDefault\"; };\n+struct NameToIPv6OrDefault { static constexpr auto name = \"toIPv6OrDefault\"; };\n \n using FunctionToUInt8OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt8, NameToUInt8OrDefault>;\n using FunctionToUInt16OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt16, NameToUInt16OrDefault>;\n@@ -362,6 +365,8 @@ using FunctionToDecimal128OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal\n using FunctionToDecimal256OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal<Decimal256>, NameToDecimal256OrDefault>;\n \n using FunctionToUUIDOrDefault = FunctionCastOrDefaultTyped<DataTypeUUID, NameToUUIDOrDefault>;\n+using FunctionToIPv4OrDefault = FunctionCastOrDefaultTyped<DataTypeIPv4, NameToIPv4OrDefault>;\n+using FunctionToIPv6OrDefault = FunctionCastOrDefaultTyped<DataTypeIPv6, NameToIPv6OrDefault>;\n \n REGISTER_FUNCTION(CastOrDefault)\n {\n@@ -394,6 +399,8 @@ REGISTER_FUNCTION(CastOrDefault)\n     factory.registerFunction<FunctionToDecimal256OrDefault>();\n \n     factory.registerFunction<FunctionToUUIDOrDefault>();\n+    factory.registerFunction<FunctionToIPv4OrDefault>();\n+    factory.registerFunction<FunctionToIPv6OrDefault>();\n }\n \n }\ndiff --git a/src/Functions/isIPAddressContainedIn.cpp b/src/Functions/isIPAddressContainedIn.cpp\nindex 15dcdc584d80..23cac4dbef03 100644\n--- a/src/Functions/isIPAddressContainedIn.cpp\n+++ b/src/Functions/isIPAddressContainedIn.cpp\n@@ -29,22 +29,17 @@ class IPAddressVariant\n \n     explicit IPAddressVariant(std::string_view address_str)\n     {\n-        /// IP address parser functions require that the input is\n-        /// NULL-terminated so we need to copy it.\n-        const auto address_str_copy = std::string(address_str);\n-\n         UInt32 v4;\n-        if (DB::parseIPv4(address_str_copy.c_str(), reinterpret_cast<unsigned char *>(&v4)))\n+        if (DB::parseIPv4whole(address_str.begin(), address_str.end(), reinterpret_cast<unsigned char *>(&v4)))\n         {\n             addr = v4;\n         }\n         else\n         {\n             addr = IPv6AddrType();\n-            bool success = DB::parseIPv6(address_str_copy.c_str(), std::get<IPv6AddrType>(addr).data());\n+            bool success = DB::parseIPv6whole(address_str.begin(), address_str.end(), std::get<IPv6AddrType>(addr).data());\n             if (!success)\n-                throw DB::Exception(\"Neither IPv4 nor IPv6 address: '\" + address_str_copy + \"'\",\n-                                    DB::ErrorCodes::CANNOT_PARSE_TEXT);\n+                throw DB::Exception(DB::ErrorCodes::CANNOT_PARSE_TEXT, \"Neither IPv4 nor IPv6 address: '{}'\", address_str);\n         }\n     }\n \ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 5b13f52e2773..f69e3d5c7b3b 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -11,6 +11,7 @@\n \n #include <type_traits>\n \n+#include <Common/formatIPv6.h>\n #include <Common/DateLUT.h>\n #include <Common/LocalDate.h>\n #include <Common/LocalDateTime.h>\n@@ -21,6 +22,7 @@\n #include <Core/Types.h>\n #include <Core/DecimalFunctions.h>\n #include <Core/UUID.h>\n+#include <base/IPv4andIPv6.h>\n \n #include <Common/Allocator.h>\n #include <Common/Exception.h>\n@@ -54,6 +56,8 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_BOOL;\n     extern const int CANNOT_PARSE_DATETIME;\n     extern const int CANNOT_PARSE_UUID;\n+    extern const int CANNOT_PARSE_IPV4;\n+    extern const int CANNOT_PARSE_IPV6;\n     extern const int CANNOT_READ_ARRAY_FROM_TEXT;\n     extern const int CANNOT_PARSE_NUMBER;\n     extern const int INCORRECT_DATA;\n@@ -844,6 +848,49 @@ inline bool tryReadUUIDText(UUID & uuid, ReadBuffer & buf)\n     return readUUIDTextImpl<bool>(uuid, buf);\n }\n \n+template <typename ReturnType = void>\n+inline ReturnType readIPv4TextImpl(IPv4 & ip, ReadBuffer & buf)\n+{\n+    if (parseIPv4(buf.position(), [&buf](){ return buf.eof(); }, reinterpret_cast<unsigned char *>(&ip.toUnderType())))\n+        return ReturnType(true);\n+\n+    if constexpr (std::is_same_v<ReturnType, void>)\n+        throw ParsingException(std::string(\"Cannot parse IPv4 \").append(buf.position(), buf.available()), ErrorCodes::CANNOT_PARSE_IPV4);\n+    else\n+        return ReturnType(false);\n+}\n+\n+inline void readIPv4Text(IPv4 & ip, ReadBuffer & buf)\n+{\n+    return readIPv4TextImpl<void>(ip, buf);\n+}\n+\n+inline bool tryReadIPv4Text(IPv4 & ip, ReadBuffer & buf)\n+{\n+    return readIPv4TextImpl<bool>(ip, buf);\n+}\n+\n+template <typename ReturnType = void>\n+inline ReturnType readIPv6TextImpl(IPv6 & ip, ReadBuffer & buf)\n+{\n+    if (parseIPv6orIPv4(buf.position(), [&buf](){ return buf.eof(); }, reinterpret_cast<unsigned char *>(ip.toUnderType().items)))\n+        return ReturnType(true);\n+\n+    if constexpr (std::is_same_v<ReturnType, void>)\n+        throw ParsingException(std::string(\"Cannot parse IPv6 \").append(buf.position(), buf.available()), ErrorCodes::CANNOT_PARSE_IPV6);\n+    else\n+        return ReturnType(false);\n+}\n+\n+inline void readIPv6Text(IPv6 & ip, ReadBuffer & buf)\n+{\n+    return readIPv6TextImpl<void>(ip, buf);\n+}\n+\n+inline bool tryReadIPv6Text(IPv6 & ip, ReadBuffer & buf)\n+{\n+    return readIPv6TextImpl<bool>(ip, buf);\n+}\n \n template <typename T>\n inline T parse(const char * data, size_t size);\n@@ -1054,8 +1101,10 @@ inline void readBinary(bool & x, ReadBuffer & buf)\n }\n \n inline void readBinary(String & x, ReadBuffer & buf) { readStringBinary(x, buf); }\n+inline void readBinary(Int32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Int128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n+inline void readBinary(UInt32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(UInt128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n inline void readBinary(Decimal32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }\n@@ -1111,6 +1160,8 @@ inline bool tryReadText(is_integer auto & x, ReadBuffer & buf)\n }\n \n inline bool tryReadText(UUID & x, ReadBuffer & buf) { return tryReadUUIDText(x, buf); }\n+inline bool tryReadText(IPv4 & x, ReadBuffer & buf) { return tryReadIPv4Text(x, buf); }\n+inline bool tryReadText(IPv6 & x, ReadBuffer & buf) { return tryReadIPv6Text(x, buf); }\n \n inline void readText(is_floating_point auto & x, ReadBuffer & buf) { readFloatText(x, buf); }\n \n@@ -1119,6 +1170,8 @@ inline void readText(LocalDate & x, ReadBuffer & buf) { readDateText(x, buf); }\n inline void readText(DayNum & x, ReadBuffer & buf) { readDateText(x, buf); }\n inline void readText(LocalDateTime & x, ReadBuffer & buf) { readDateTimeText(x, buf); }\n inline void readText(UUID & x, ReadBuffer & buf) { readUUIDText(x, buf); }\n+inline void readText(IPv4 & x, ReadBuffer & buf) { readIPv4Text(x, buf); }\n+inline void readText(IPv6 & x, ReadBuffer & buf) { readIPv6Text(x, buf); }\n \n /// Generic methods to read value in text format,\n ///  possibly in single quotes (only for data types that use quotes in VALUES format of INSERT statement in SQL).\n@@ -1149,6 +1202,19 @@ inline void readQuoted(UUID & x, ReadBuffer & buf)\n     assertChar('\\'', buf);\n }\n \n+inline void readQuoted(IPv4 & x, ReadBuffer & buf)\n+{\n+    assertChar('\\'', buf);\n+    readIPv4Text(x, buf);\n+    assertChar('\\'', buf);\n+}\n+\n+inline void readQuoted(IPv6 & x, ReadBuffer & buf)\n+{\n+    assertChar('\\'', buf);\n+    readIPv6Text(x, buf);\n+    assertChar('\\'', buf);\n+}\n \n /// Same as above, but in double quotes.\n template <typename T>\n@@ -1201,6 +1267,8 @@ inline void readCSV(LocalDate & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(DayNum & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(LocalDateTime & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UUID & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n+inline void readCSV(IPv4 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n+inline void readCSV(IPv6 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UInt128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(Int128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UInt256 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\ndiff --git a/src/IO/WriteHelpers.cpp b/src/IO/WriteHelpers.cpp\nindex a9788505995a..caeea0a82a34 100644\n--- a/src/IO/WriteHelpers.cpp\n+++ b/src/IO/WriteHelpers.cpp\n@@ -1,5 +1,7 @@\n #include <IO/WriteHelpers.h>\n #include <cinttypes>\n+#include <utility>\n+#include <Common/formatIPv6.h>\n #include <Common/hex.h>\n \n \n@@ -34,6 +36,29 @@ void formatUUID(std::reverse_iterator<const UInt8 *> src16, UInt8 * dst36)\n     formatHex(src16 + 2, &dst36[24], 6);\n }\n \n+void writeIPv4Text(const IPv4 & ip, WriteBuffer & buf)\n+{\n+    size_t idx = (ip >> 24);\n+    buf.write(one_byte_to_string_lookup_table[idx].first, one_byte_to_string_lookup_table[idx].second);\n+    buf.write('.');\n+    idx = (ip >> 16) & 0xFF;\n+    buf.write(one_byte_to_string_lookup_table[idx].first, one_byte_to_string_lookup_table[idx].second);\n+    buf.write('.');\n+    idx = (ip >> 8) & 0xFF;\n+    buf.write(one_byte_to_string_lookup_table[idx].first, one_byte_to_string_lookup_table[idx].second);\n+    buf.write('.');\n+    idx = ip & 0xFF;\n+    buf.write(one_byte_to_string_lookup_table[idx].first, one_byte_to_string_lookup_table[idx].second);\n+}\n+\n+void writeIPv6Text(const IPv6 & ip, WriteBuffer & buf)\n+{\n+    char addr[IPV6_MAX_TEXT_LENGTH + 1] {};\n+    char * paddr = addr;\n+\n+    formatIPv6(reinterpret_cast<const unsigned char *>(&ip), paddr);\n+    buf.write(addr, paddr - addr - 1);\n+}\n \n void writeException(const Exception & e, WriteBuffer & buf, bool with_stack_trace)\n {\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 8dbfe63be7e6..a16381f7fe46 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -21,6 +21,7 @@\n #include <Core/DecimalFunctions.h>\n #include <Core/Types.h>\n #include <Core/UUID.h>\n+#include <base/IPv4andIPv6.h>\n \n #include <Common/Exception.h>\n #include <Common/StringUtils/StringUtils.h>\n@@ -633,6 +634,9 @@ inline void writeUUIDText(const UUID & uuid, WriteBuffer & buf)\n     buf.write(s, sizeof(s));\n }\n \n+void writeIPv4Text(const IPv4 & ip, WriteBuffer & buf);\n+void writeIPv6Text(const IPv6 & ip, WriteBuffer & buf);\n+\n template <typename DecimalType>\n inline void writeDateTime64FractionalText(typename DecimalType::NativeType fractional, UInt32 scale, WriteBuffer & buf)\n {\n@@ -858,6 +862,8 @@ inline void writeBinary(const Decimal256 & x, WriteBuffer & buf) { writePODBinar\n inline void writeBinary(const LocalDate & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const LocalDateTime & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const UUID & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n+inline void writeBinary(const IPv4 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n+inline void writeBinary(const IPv6 & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n \n /// Methods for outputting the value in text form for a tab-separated format.\n \n@@ -881,6 +887,8 @@ inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(Local\n inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }\n inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }\n inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }\n+inline void writeText(const IPv4 & x, WriteBuffer & buf) { writeIPv4Text(x, buf); }\n+inline void writeText(const IPv6 & x, WriteBuffer & buf) { writeIPv6Text(x, buf); }\n \n template <typename T>\n void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)\n@@ -999,6 +1007,19 @@ inline void writeQuoted(const UUID & x, WriteBuffer & buf)\n     writeChar('\\'', buf);\n }\n \n+inline void writeQuoted(const IPv4 & x, WriteBuffer & buf)\n+{\n+    writeChar('\\'', buf);\n+    writeText(x, buf);\n+    writeChar('\\'', buf);\n+}\n+\n+inline void writeQuoted(const IPv6 & x, WriteBuffer & buf)\n+{\n+    writeChar('\\'', buf);\n+    writeText(x, buf);\n+    writeChar('\\'', buf);\n+}\n \n /// String, date, datetime are in double quotes with C-style escaping. Numbers - without.\n template <typename T>\n@@ -1032,6 +1053,19 @@ inline void writeDoubleQuoted(const UUID & x, WriteBuffer & buf)\n     writeChar('\"', buf);\n }\n \n+inline void writeDoubleQuoted(const IPv4 & x, WriteBuffer & buf)\n+{\n+    writeChar('\"', buf);\n+    writeText(x, buf);\n+    writeChar('\"', buf);\n+}\n+\n+inline void writeDoubleQuoted(const IPv6 & x, WriteBuffer & buf)\n+{\n+    writeChar('\"', buf);\n+    writeText(x, buf);\n+    writeChar('\"', buf);\n+}\n \n /// String - in double quotes and with CSV-escaping; date, datetime - in double quotes. Numbers - without.\n template <typename T>\n@@ -1042,6 +1076,8 @@ inline void writeCSV(const String & x, WriteBuffer & buf) { writeCSVString<>(x,\n inline void writeCSV(const LocalDate & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n inline void writeCSV(const LocalDateTime & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n inline void writeCSV(const UUID & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n+inline void writeCSV(const IPv4 & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n+inline void writeCSV(const IPv6 & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }\n \n template <typename T>\n void writeBinary(const std::vector<T> & x, WriteBuffer & buf)\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex e57016d969a0..c67de14a1891 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -249,6 +249,25 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n         /// Already in needed type.\n         return src;\n     }\n+    else if (which_type.isIPv4() && src.getType() == Field::Types::IPv4)\n+    {\n+        /// Already in needed type.\n+        return src;\n+    }\n+    else if (which_type.isIPv6())\n+    {\n+        /// Already in needed type.\n+        if (src.getType() == Field::Types::IPv6)\n+            return src;\n+        /// Treat FixedString(16) as a binary representation of IPv6\n+        if (which_from_type.isFixedString() && assert_cast<const DataTypeFixedString *>(from_type_hint)->getN() == IPV6_BINARY_LENGTH)\n+        {\n+            const auto col = type.createColumn();\n+            ReadBufferFromString in_buffer(src.get<String>());\n+            type.getDefaultSerialization()->deserializeBinary(*col, in_buffer, {});\n+            return (*col)[0];\n+        }\n+    }\n     else if (which_type.isStringOrFixedString())\n     {\n         if (src.getType() == Field::Types::String)\ndiff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex 6f153019df5a..f7374111a304 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -26,6 +26,8 @@ namespace ErrorCodes\n     extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int INCORRECT_DATA;\n     extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n+    extern const int CANNOT_PARSE_IPV4;\n+    extern const int CANNOT_PARSE_IPV6;\n }\n \n \n@@ -44,7 +46,9 @@ bool isParseError(int code)\n         || code == ErrorCodes::TOO_LARGE_STRING_SIZE\n         || code == ErrorCodes::ARGUMENT_OUT_OF_BOUND       /// For Decimals\n         || code == ErrorCodes::INCORRECT_DATA              /// For some ReadHelpers\n-        || code == ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n+        || code == ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING\n+        || code == ErrorCodes::CANNOT_PARSE_IPV4\n+        || code == ErrorCodes::CANNOT_PARSE_IPV6;\n }\n \n IRowInputFormat::IRowInputFormat(Block header, ReadBuffer & in_, Params params_)\ndiff --git a/src/Processors/Transforms/AddingDefaultsTransform.cpp b/src/Processors/Transforms/AddingDefaultsTransform.cpp\nindex f55d4d88ae88..64bdf663d0fc 100644\n--- a/src/Processors/Transforms/AddingDefaultsTransform.cpp\n+++ b/src/Processors/Transforms/AddingDefaultsTransform.cpp\n@@ -19,6 +19,7 @@\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeIPv4andIPv6.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeFixedString.h>\n \ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex 2b63524fb79e..7bf26159f474 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -62,6 +62,9 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_DATE;\n     extern const int CANNOT_PARSE_DATETIME;\n     extern const int CANNOT_PARSE_NUMBER;\n+    extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n+    extern const int CANNOT_PARSE_IPV4;\n+    extern const int CANNOT_PARSE_IPV6;\n     extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n     extern const int CANNOT_OPEN_FILE;\n     extern const int CANNOT_COMPILE_REGEXP;\n@@ -187,6 +190,9 @@ static Poco::Net::HTTPResponse::HTTPStatus exceptionCodeToHTTPStatus(int excepti\n              exception_code == ErrorCodes::CANNOT_PARSE_DATE ||\n              exception_code == ErrorCodes::CANNOT_PARSE_DATETIME ||\n              exception_code == ErrorCodes::CANNOT_PARSE_NUMBER ||\n+             exception_code == ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING ||\n+             exception_code == ErrorCodes::CANNOT_PARSE_IPV4 ||\n+             exception_code == ErrorCodes::CANNOT_PARSE_IPV6 ||\n              exception_code == ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED ||\n              exception_code == ErrorCodes::UNKNOWN_ELEMENT_IN_AST ||\n              exception_code == ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE ||\ndiff --git a/src/Storages/MergeTree/MergeTreePartition.cpp b/src/Storages/MergeTree/MergeTreePartition.cpp\nindex e7fdf1617f05..0fd081a84254 100644\n--- a/src/Storages/MergeTree/MergeTreePartition.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartition.cpp\n@@ -85,6 +85,18 @@ namespace\n         {\n             operator()(x.toUnderType());\n         }\n+        void operator() (const IPv4 & x) const\n+        {\n+            UInt8 type = Field::Types::IPv4;\n+            hash.update(type);\n+            hash.update(x);\n+        }\n+        void operator() (const IPv6 & x) const\n+        {\n+            UInt8 type = Field::Types::IPv6;\n+            hash.update(type);\n+            hash.update(x);\n+        }\n         void operator() (const Float64 & x) const\n         {\n             UInt8 type = Field::Types::Float64;\n",
  "test_patch": "diff --git a/src/Columns/tests/gtest_column_vector.cpp b/src/Columns/tests/gtest_column_vector.cpp\nindex 5017d6877912..14bf36434b65 100644\n--- a/src/Columns/tests/gtest_column_vector.cpp\n+++ b/src/Columns/tests/gtest_column_vector.cpp\n@@ -1,4 +1,5 @@\n #include <limits>\n+#include <type_traits>\n #include <typeinfo>\n #include <vector>\n #include <Columns/ColumnsNumber.h>\n@@ -14,6 +15,12 @@ static constexpr size_t MAX_ROWS = 10000;\n static const std::vector<size_t> filter_ratios = {1, 2, 5, 11, 32, 64, 100, 1000};\n static const size_t K = filter_ratios.size();\n \n+template <typename, typename = void >\n+struct HasUnderlyingType : std::false_type {};\n+\n+template <typename T>\n+struct HasUnderlyingType<T, std::void_t<typename T::UnderlyingType>> : std::true_type {};\n+\n template <typename T>\n static MutableColumnPtr createColumn(size_t n)\n {\n@@ -21,7 +28,10 @@ static MutableColumnPtr createColumn(size_t n)\n     auto & values = column->getData();\n \n     for (size_t i = 0; i < n; ++i)\n-        values.push_back(static_cast<T>(i));\n+        if constexpr (HasUnderlyingType<T>::value)\n+            values.push_back(static_cast<typename T::UnderlyingType>(i));\n+        else\n+            values.push_back(static_cast<T>(i));\n \n     return column;\n }\n@@ -85,6 +95,8 @@ TEST(ColumnVector, Filter)\n     testFilter<Float32>();\n     testFilter<Float64>();\n     testFilter<UUID>();\n+    testFilter<IPv4>();\n+    testFilter<IPv6>();\n }\n \n template <typename T>\ndiff --git a/tests/integration/test_backward_compatibility/test_ip_types_binary_compatibility.py b/tests/integration/test_backward_compatibility/test_ip_types_binary_compatibility.py\nnew file mode 100644\nindex 000000000000..bb40dff27ac8\n--- /dev/null\n+++ b/tests/integration/test_backward_compatibility/test_ip_types_binary_compatibility.py\n@@ -0,0 +1,41 @@\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+# Version 21.6.3.14 has incompatible partition id for tables with UUID in partition key.\n+node_22_6 = cluster.add_instance(\n+    \"node_22_6\",\n+    image=\"clickhouse/clickhouse-server\",\n+    tag=\"22.6\",\n+    stay_alive=True,\n+    with_installed_binary=True,\n+)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_ip_types_binary_compatibility(start_cluster):\n+    node_22_6.query(\n+        \"create table tab (ipv4 IPv4, ipv6 IPv6) engine = MergeTree order by tuple()\"\n+    )\n+    node_22_6.query(\n+        \"insert into tab values ('123.231.213.132', '0123:4567:89ab:cdef:fedc:ba98:7654:3210')\"\n+    )\n+    res_22_6 = node_22_6.query(\"select * from tab\")\n+\n+    node_22_6.restart_with_latest_version()\n+\n+    res_latest = node_22_6.query(\"select * from tab\")\n+\n+    assert res_22_6 == res_latest\n+\n+    node_22_6.query(\"drop table tab\")\ndiff --git a/tests/queries/0_stateless/00937_ipv4_cidr_range.reference b/tests/queries/0_stateless/00937_ipv4_cidr_range.reference\nindex 01f85dc6447b..3824c190627c 100644\n--- a/tests/queries/0_stateless/00937_ipv4_cidr_range.reference\n+++ b/tests/queries/0_stateless/00937_ipv4_cidr_range.reference\n@@ -1,4 +1,3 @@\n-check invalid params\n tests\n 4\n 3\ndiff --git a/tests/queries/0_stateless/00937_ipv4_cidr_range.sql b/tests/queries/0_stateless/00937_ipv4_cidr_range.sql\nindex badefe223833..2cc33eb9f583 100644\n--- a/tests/queries/0_stateless/00937_ipv4_cidr_range.sql\n+++ b/tests/queries/0_stateless/00937_ipv4_cidr_range.sql\n@@ -1,7 +1,3 @@\n-SELECT 'check invalid params';\n-SELECT IPv4CIDRToRange(1, 1); -- { serverError 43 }\n-SELECT IPv4CIDRToRange(toUInt32(1), 512); -- { serverError 43 }\n-\n SELECT 'tests';\n \n DROP TABLE IF EXISTS ipv4_range;\ndiff --git a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\nindex b303d580e727..f392d0125d93 100644\n--- a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\n+++ b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\n@@ -7,7 +7,7 @@ SELECT CAST(toIPv6('2001:0db8:0000:85a3:0000:0000:ac1f:8001') as String) as v, t\n SELECT toIPv4OrDefault('hello') as v, toTypeName(v);\n SELECT toIPv6OrDefault('hello') as v, toTypeName(v);\n \n-SELECT CAST('hello' as IPv4) as v, toTypeName(v); -- { serverError CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING }\n-SELECT CAST('hello' as IPv6) as v, toTypeName(v); -- { serverError CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING }\n+SELECT CAST('hello' as IPv4) as v, toTypeName(v); -- { serverError CANNOT_PARSE_IPV4 }\n+SELECT CAST('hello' as IPv6) as v, toTypeName(v); -- { serverError CANNOT_PARSE_IPV6 }\n \n SELECT CAST('1.1.1.1' as IPv6) as v, toTypeName(v);\ndiff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.reference b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\nindex 3a4c40a07cfd..96aae2a978c9 100644\n--- a/tests/queries/0_stateless/02234_cast_to_ip_address.reference\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\n@@ -41,5 +41,6 @@ IPv6 functions\n ::\n ::\n --\n-::ffff:127.0.0.1\t::ffff:127.0.0.1\t::ffff:127.0.0.1\n ::1\\0\\0\t::1\t::1\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\t::\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\t::\ndiff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.sql b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\nindex d436c93b9db1..436f232e441e 100644\n--- a/tests/queries/0_stateless/02234_cast_to_ip_address.sql\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\n@@ -1,6 +1,6 @@\n SELECT 'IPv4 functions';\n \n-SELECT IPv4StringToNum('test'); --{serverError 441}\n+SELECT IPv4StringToNum('test'); --{serverError CANNOT_PARSE_IPV4}\n SELECT IPv4StringToNumOrDefault('test');\n SELECT IPv4StringToNumOrNull('test');\n \n@@ -10,7 +10,7 @@ SELECT IPv4StringToNumOrNull('127.0.0.1');\n \n SELECT '--';\n \n-SELECT toIPv4('test'); --{serverError 441}\n+SELECT toIPv4('test'); --{serverError CANNOT_PARSE_IPV4}\n SELECT toIPv4OrDefault('test');\n SELECT toIPv4OrNull('test');\n \n@@ -20,7 +20,7 @@ SELECT toIPv4OrNull('127.0.0.1');\n \n SELECT '--';\n \n-SELECT cast('test' , 'IPv4'); --{serverError 441}\n+SELECT cast('test' , 'IPv4'); --{serverError CANNOT_PARSE_IPV4}\n SELECT cast('127.0.0.1' , 'IPv4');\n \n SELECT '--';\n@@ -38,7 +38,7 @@ SET cast_ipv4_ipv6_default_on_conversion_error = 0;\n \n SELECT 'IPv6 functions';\n \n-SELECT IPv6StringToNum('test'); --{serverError 441}\n+SELECT IPv6StringToNum('test'); --{serverError CANNOT_PARSE_IPV6}\n SELECT IPv6StringToNumOrDefault('test');\n SELECT IPv6StringToNumOrNull('test');\n \n@@ -48,7 +48,7 @@ SELECT IPv6StringToNumOrNull('::ffff:127.0.0.1');\n \n SELECT '--';\n \n-SELECT toIPv6('test'); --{serverError 441}\n+SELECT toIPv6('test'); --{serverError CANNOT_PARSE_IPV6}\n SELECT toIPv6OrDefault('test');\n SELECT toIPv6OrNull('test');\n \n@@ -58,7 +58,7 @@ SELECT toIPv6OrNull('::ffff:127.0.0.1');\n \n SELECT '--';\n \n-SELECT cast('test' , 'IPv6'); --{serverError 441}\n+SELECT cast('test' , 'IPv6'); --{serverError CANNOT_PARSE_IPV6}\n SELECT cast('::ffff:127.0.0.1', 'IPv6');\n \n SELECT '--';\n@@ -76,7 +76,6 @@ SELECT '--';\n \n SET cast_ipv4_ipv6_default_on_conversion_error = 0;\n \n-SELECT toFixedString('::ffff:127.0.0.1', 16) as value, cast(value, 'IPv6'), toIPv6(value);\n SELECT toFixedString('::1', 5) as value, cast(value, 'IPv6'), toIPv6(value);\n-SELECT toFixedString('', 16) as value, cast(value, 'IPv6'); --{serverError 441}\n-SELECT toFixedString('', 16) as value, toIPv6(value); --{serverError 441}\n+SELECT toFixedString('', 16) as value, cast(value, 'IPv6');\n+SELECT toFixedString('', 16) as value, toIPv6(value);\ndiff --git a/tests/queries/0_stateless/02244_ip_address_invalid_insert.reference b/tests/queries/0_stateless/02244_ip_address_invalid_insert.reference\nindex 60e6a5da083b..a7b2fcc11b40 100644\n--- a/tests/queries/0_stateless/02244_ip_address_invalid_insert.reference\n+++ b/tests/queries/0_stateless/02244_ip_address_invalid_insert.reference\n@@ -3,7 +3,7 @@\n 1.1.1.1\t1.1.1.1\n \t0.0.0.0\n fe80::9801:43ff:fe1f:7690\tfe80::9801:43ff:fe1f:7690\n-1.1.1.1\t::\n+1.1.1.1\t::ffff:1.1.1.1\n \t::\n fe80::9801:43ff:fe1f:7690\tfe80::9801:43ff:fe1f:7690\n 1.1.1.1\t::ffff:1.1.1.1\ndiff --git a/tests/queries/0_stateless/02244_ip_address_invalid_insert.sql b/tests/queries/0_stateless/02244_ip_address_invalid_insert.sql\nindex 4057b9b2d98d..27e2ab219d4d 100644\n--- a/tests/queries/0_stateless/02244_ip_address_invalid_insert.sql\n+++ b/tests/queries/0_stateless/02244_ip_address_invalid_insert.sql\n@@ -5,7 +5,7 @@ CREATE TABLE test_table_ipv4\n     ipv4 IPv4\n ) ENGINE = TinyLog;\n \n-INSERT INTO test_table_ipv4 VALUES ('1.1.1.1', '1.1.1.1'), ('', ''); --{clientError 441}\n+INSERT INTO test_table_ipv4 VALUES ('1.1.1.1', '1.1.1.1'), ('', ''); --{clientError CANNOT_PARSE_IPV4}\n \n SET input_format_ipv4_default_on_conversion_error = 1;\n \n@@ -23,11 +23,11 @@ CREATE TABLE test_table_ipv4_materialized\n     ipv6 IPv4 MATERIALIZED toIPv4(ip)\n ) ENGINE = TinyLog;\n \n-INSERT INTO test_table_ipv4_materialized(ip) VALUES ('1.1.1.1'), (''); --{serverError 441}\n+INSERT INTO test_table_ipv4_materialized(ip) VALUES ('1.1.1.1'), (''); --{serverError CANNOT_PARSE_IPV4}\n \n SET input_format_ipv4_default_on_conversion_error = 1;\n \n-INSERT INTO test_table_ipv4_materialized(ip) VALUES ('1.1.1.1'), (''); --{serverError 441}\n+INSERT INTO test_table_ipv4_materialized(ip) VALUES ('1.1.1.1'), (''); --{serverError CANNOT_PARSE_IPV4}\n \n SET cast_ipv4_ipv6_default_on_conversion_error = 1;\n \n@@ -46,7 +46,7 @@ CREATE TABLE test_table_ipv6\n     ipv6 IPv6\n ) ENGINE = TinyLog;\n \n-INSERT INTO test_table_ipv6 VALUES ('fe80::9801:43ff:fe1f:7690', 'fe80::9801:43ff:fe1f:7690'), ('1.1.1.1', '1.1.1.1'), ('', ''); --{clientError 441}\n+INSERT INTO test_table_ipv6 VALUES ('fe80::9801:43ff:fe1f:7690', 'fe80::9801:43ff:fe1f:7690'), ('1.1.1.1', '1.1.1.1'), ('', ''); --{clientError CANNOT_PARSE_IPV6}\n \n SET input_format_ipv6_default_on_conversion_error = 1;\n \n@@ -64,11 +64,11 @@ CREATE TABLE test_table_ipv6_materialized\n     ipv6 IPv6 MATERIALIZED toIPv6(ip)\n ) ENGINE = TinyLog;\n \n-INSERT INTO test_table_ipv6_materialized(ip) VALUES ('fe80::9801:43ff:fe1f:7690'), ('1.1.1.1'), (''); --{serverError 441}\n+INSERT INTO test_table_ipv6_materialized(ip) VALUES ('fe80::9801:43ff:fe1f:7690'), ('1.1.1.1'), (''); --{serverError CANNOT_PARSE_IPV6}\n \n SET input_format_ipv6_default_on_conversion_error = 1;\n \n-INSERT INTO test_table_ipv6_materialized(ip) VALUES ('fe80::9801:43ff:fe1f:7690'), ('1.1.1.1'), (''); --{serverError 441}\n+INSERT INTO test_table_ipv6_materialized(ip) VALUES ('fe80::9801:43ff:fe1f:7690'), ('1.1.1.1'), (''); --{serverError CANNOT_PARSE_IPV6}\n \n SET cast_ipv4_ipv6_default_on_conversion_error = 1;\n \ndiff --git a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\nindex 1a0d9a4c830b..1cc5140f3399 100644\n--- a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\n+++ b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\n@@ -12,6 +12,7 @@ select CAST(number % 2 ? 'true' : NULL, 'Nullable(Bool)') from numbers(2);\n select CAST(number % 2 ? '0.0.0.0' : NULL, 'Nullable(IPv4)') from numbers(2);\n select CAST(number % 2 ? '0000:0000:0000:0000:0000:0000:0000:0000' : NULL, 'Nullable(IPv6)') from numbers(2);\n \n+set cast_keep_nullable = 1;\n select toBool(number % 2 ? 'true' : NULL) from numbers(2);\n select toIPv4(number % 2 ? '0.0.0.0' : NULL) from numbers(2);\n select toIPv4OrDefault(number % 2 ? '' : NULL) from numbers(2);\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 0996ad37e6ef..9d747f9c5723 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -240,42 +240,6 @@ detectCharset\n detectLanguageUnknown\n detectProgrammingLanguage\n detectTonality\n-dictGet\n-dictGetChildren\n-dictGetDate\n-dictGetDateOrDefault\n-dictGetDateTime\n-dictGetDateTimeOrDefault\n-dictGetDescendants\n-dictGetFloat32\n-dictGetFloat32OrDefault\n-dictGetFloat64\n-dictGetFloat64OrDefault\n-dictGetHierarchy\n-dictGetInt16\n-dictGetInt16OrDefault\n-dictGetInt32\n-dictGetInt32OrDefault\n-dictGetInt64\n-dictGetInt64OrDefault\n-dictGetInt8\n-dictGetInt8OrDefault\n-dictGetOrDefault\n-dictGetOrNull\n-dictGetString\n-dictGetStringOrDefault\n-dictGetUInt16\n-dictGetUInt16OrDefault\n-dictGetUInt32\n-dictGetUInt32OrDefault\n-dictGetUInt64\n-dictGetUInt64OrDefault\n-dictGetUInt8\n-dictGetUInt8OrDefault\n-dictGetUUID\n-dictGetUUIDOrDefault\n-dictHas\n-dictIsIn\n divide\n dotProduct\n dumpColumnStructure\n@@ -773,9 +737,11 @@ toHour\n toIPv4\n toIPv4OrDefault\n toIPv4OrNull\n+toIPv4OrZero\n toIPv6\n toIPv6OrDefault\n toIPv6OrNull\n+toIPv6OrZero\n toISOWeek\n toISOYear\n toInt128\n",
  "problem_statement": "Bad comparison of IPv6 to String: toIPv6('::1') != '::1'\n```\r\n:) select toIPv6('::1') = '::1'\r\n\r\n\u250c\u2500equals(toIPv6('::1'), '::1')\u2500\u2510\r\n\u2502                            0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNot sure what's going on. It does some implicit cast, but somehow casts to a wrong type? I would expect an error about implicit cast since we don't do them often, or at least that they compare as equal.\n",
  "hints_text": "It's because `IPv6` data type implemented as `FixedString(16)` with custom serialization ([link](https://github.com/ClickHouse/ClickHouse/blob/a6f787faeac4ecb1cb2eafa63ea38f0b3734ce0e/src/DataTypes/DataTypeCustomIPv4AndIPv6.cpp#L101)), so `equals` function compares binary representation of `toIPv6('::1')` as `FixedString(16)` with `::1` as `String`. Maybe we should take custom serialization into account when resolving a function overload.\r\n\r\nAnother funny example:\r\n```\r\n:) select toIPv4('127.0.0.1') = 2.130706433e9 as e\r\n\r\n\u250c\u2500e\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n```\nStill reproducing.\r\n``` sql\r\nSELECT toTypeName(toIPv6('::1'))\r\n\r\nQuery id: 0eb293f1-cc3d-4643-abc1-e4924e32f45d\r\n\r\n\u250c\u2500toTypeName(toIPv6('::1'))\u2500\u2510\r\n\u2502 IPv6                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.030 sec.\r\n```\r\n\r\n`EXPLAIN` shows nothing interesting in this case. We can show whether `'::1'` casts to `IPv6` or otherwise `IPv6('::1)'` casted to String.\nI think we need to get rid of \"data type domains\". See:\r\n\r\n```\r\n    /// This is mutable to allow setting custom name and serialization on `const IDataType` post construction.\r\n    mutable DataTypeCustomNamePtr custom_name;\r\n    mutable DataTypeCustomTextSerializationPtr custom_text_serialization;\r\n    mutable DataTypeCustomStreamsPtr custom_streams;\r\n```\r\n\r\nThis was an ugly hack that should not exist.\r\nIt also affects performance in a range of 10% for serialization / deserialization. \r\n\r\nWe can rewrite IPv4, IPv6 to real data types.\nThis is a tech debt after introducing \"data type domains\".\r\nI will assign to @Enmk, maybe he can find a workaround without removing \"data type domains\",\r\nthough I think that they have to be removed.\n> I think we need to get rid of \"data type domains\". See:\r\n> \r\n> ```\r\n>     /// This is mutable to allow setting custom name and serialization on `const IDataType` post construction.\r\n>     mutable DataTypeCustomNamePtr custom_name;\r\n>     mutable DataTypeCustomTextSerializationPtr custom_text_serialization;\r\n>     mutable DataTypeCustomStreamsPtr custom_streams;\r\n> ```\r\n> \r\n> This was an ugly hack that should not exist. It also affects performance in a range of 10% for serialization / deserialization.\r\n> \r\n> We can rewrite IPv4, IPv6 to real data types.\r\n\r\nDo we have any benchmark that can be used to investigate the performance issue? And, as far as I know, serialization code was refactored at least once since the initial implementation of \"domains\", is the issue still present?\n@Enmk yes, it is still present. Two virtual calls instead of one.\r\nAlso, the code is poisoned by these \"data type domains\", and it is a constant source of bugs like this.\r\nAsk @kitaisreal if you are not convinced.\nNo reaction from @Enmk \nThis task requires the removal of \"data type domains\", erroneously introduced a long time ago.\nWe still need to remove the \"data type domains\" to solve this task.\n@yakov-olkhovskiy \r\n\r\nData type domains (or customizations) are represented by the same objects that the existing data types do.\r\nFor example, IPv4 is represented by DataTypeUInt32.\r\n\r\nThey just inject a few hacks inside the existing data type:\r\n- different name;\r\n- different text serialization and deserialization.\r\n\r\nIt was maybe a good or a bad idea.\r\n\r\nThe advantages are:\r\n- it was a low-effort change of the code;\r\n- developers adding new \"data type domains\" easily, such as geographical types, SimpleAggregateFunction, Bool;\r\n- all function overloads for customized data types continue to work as for the based data type;\r\n\r\nThe disadvantages are:\r\n- it is a too ad-hoc change in code, increasing the number of fragile concepts we did not plan to have;\r\n- all function overloads for customized data types continue to work as for the based data type, but not always supposed to work this way, as shown in this task;\r\n\r\nIf we will not find a simpler solution, the proposal is to make IPv4 and IPv6 full-featured types instead of \"data type domains\".\r\nIt wouldn't be easy to remove the data type domains completely, as they work almost alright for Geo and Bool types.\r\n\n> all function overloads for customized data types continue to work as for the based data type, but not always supposed to work this way, as shown in this task\r\n\r\nCan't we forbid it by default and allow only specified ones?\r\n\r\nE.g. in Haskell we can use `type` and `newtype` for introducing type aliases, but `type` is interchangeable with the underlying type, but `newtype` hides it. https://wiki.haskell.org/Type (see `Type and newtype` section)\r\n\r\nMay we follow `newtype` semantic?",
  "created_at": "2022-11-14T14:20:12Z"
}