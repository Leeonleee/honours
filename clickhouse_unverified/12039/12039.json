{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12039,
  "instance_id": "ClickHouse__ClickHouse-12039",
  "issue_numbers": [
    "11985"
  ],
  "base_commit": "eeb9998d51fc4d3376e64b2929b9c222eebe1bee",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 1d4fb00cc605..577ea19fe8a0 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -12,6 +12,7 @@\n #include <Columns/ColumnArray.h>\n \n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeDate.h>\n@@ -931,6 +932,8 @@ class FunctionComparison : public IFunction\n         if (0 == tuple_size)\n             throw Exception(\"Comparison of zero-sized tuples is not implemented.\", ErrorCodes::NOT_IMPLEMENTED);\n \n+        ColumnsWithTypeAndName convolution_types(tuple_size);\n+\n         Block tmp_block;\n         for (size_t i = 0; i < tuple_size; ++i)\n         {\n@@ -938,9 +941,10 @@ class FunctionComparison : public IFunction\n             tmp_block.insert(y[i]);\n \n             auto impl = func_compare->build({x[i], y[i]});\n+            convolution_types[i].type = impl->getReturnType();\n \n             /// Comparison of the elements.\n-            tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n+            tmp_block.insert({ nullptr, impl->getReturnType(), \"\" });\n             impl->execute(tmp_block, {i * 3, i * 3 + 1}, i * 3 + 2, input_rows_count);\n         }\n \n@@ -952,14 +956,13 @@ class FunctionComparison : public IFunction\n         }\n \n         /// Logical convolution.\n-        tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n \n         ColumnNumbers convolution_args(tuple_size);\n         for (size_t i = 0; i < tuple_size; ++i)\n             convolution_args[i] = i * 3 + 2;\n \n-        ColumnsWithTypeAndName convolution_types(convolution_args.size(), { nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n         auto impl = func_convolution->build(convolution_types);\n+        tmp_block.insert({ nullptr, impl->getReturnType(), \"\" });\n \n         impl->execute(tmp_block, convolution_args, tuple_size * 3, input_rows_count);\n         block.getByPosition(result).column = tmp_block.getByPosition(tuple_size * 3).column;\n@@ -978,49 +981,71 @@ class FunctionComparison : public IFunction\n         size_t tuple_size,\n         size_t input_rows_count)\n     {\n-        ColumnsWithTypeAndName bin_args = {{ nullptr, std::make_shared<DataTypeUInt8>(), \"\" },\n-                                           { nullptr, std::make_shared<DataTypeUInt8>(), \"\" }};\n-\n-        auto func_and_adaptor = func_and->build(bin_args);\n-        auto func_or_adaptor = func_or->build(bin_args);\n-\n         Block tmp_block;\n \n         /// Pairwise comparison of the inequality of all elements; on the equality of all elements except the last.\n+        /// (x[i], y[i], x[i] < y[i], x[i] == y[i])\n         for (size_t i = 0; i < tuple_size; ++i)\n         {\n             tmp_block.insert(x[i]);\n             tmp_block.insert(y[i]);\n \n-            tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n+            tmp_block.insert(ColumnWithTypeAndName()); // pos == i * 4 + 2\n \n             if (i + 1 != tuple_size)\n             {\n                 auto impl_head = func_compare_head->build({x[i], y[i]});\n+                tmp_block.getByPosition(i * 4 + 2).type = impl_head->getReturnType();\n                 impl_head->execute(tmp_block, {i * 4, i * 4 + 1}, i * 4 + 2, input_rows_count);\n \n-                tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n+                tmp_block.insert(ColumnWithTypeAndName()); // i * 4 + 3\n \n                 auto impl_equals = func_equals->build({x[i], y[i]});\n+                tmp_block.getByPosition(i * 4 + 3).type = impl_equals->getReturnType();\n                 impl_equals->execute(tmp_block, {i * 4, i * 4 + 1}, i * 4 + 3, input_rows_count);\n \n             }\n             else\n             {\n                 auto impl_tail = func_compare_tail->build({x[i], y[i]});\n+                tmp_block.getByPosition(i * 4 + 2).type = impl_tail->getReturnType();\n                 impl_tail->execute(tmp_block, {i * 4, i * 4 + 1}, i * 4 + 2, input_rows_count);\n             }\n         }\n \n         /// Combination. Complex code - make a drawing. It can be replaced by a recursive comparison of tuples.\n+        /// Last column contains intermediate result.\n+        /// Code is generally equivalent to:\n+        ///   res = `x < y`[tuple_size - 1];\n+        ///   for (int i = tuple_size - 2; i >= 0; --i)\n+        ///       res = (res && `x == y`[i]) || `x < y`[i];\n         size_t i = tuple_size - 1;\n         while (i > 0)\n         {\n-            tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n-            func_and_adaptor->execute(tmp_block, {tmp_block.columns() - 2, (i - 1) * 4 + 3}, tmp_block.columns() - 1, input_rows_count);\n-            tmp_block.insert({ nullptr, std::make_shared<DataTypeUInt8>(), \"\" });\n-            func_or_adaptor->execute(tmp_block, {tmp_block.columns() - 2, (i - 1) * 4 + 2}, tmp_block.columns() - 1, input_rows_count);\n             --i;\n+\n+            size_t and_lhs_pos = tmp_block.columns() - 1; // res\n+            size_t and_rhs_pos = i * 4 + 3; // `x == y`[i]\n+            tmp_block.insert(ColumnWithTypeAndName());\n+\n+            ColumnsWithTypeAndName and_args = {{ nullptr, tmp_block.getByPosition(and_lhs_pos).type, \"\" },\n+                                               { nullptr, tmp_block.getByPosition(and_rhs_pos).type, \"\" }};\n+\n+            auto func_and_adaptor = func_and->build(and_args);\n+            tmp_block.getByPosition(tmp_block.columns() - 1).type = func_and_adaptor->getReturnType();\n+            func_and_adaptor->execute(tmp_block, {and_lhs_pos, and_rhs_pos}, tmp_block.columns() - 1, input_rows_count);\n+\n+            size_t or_lhs_pos = tmp_block.columns() - 1; // (res && `x == y`[i])\n+            size_t or_rhs_pos = i * 4 + 2; // `x < y`[i]\n+            tmp_block.insert(ColumnWithTypeAndName());\n+\n+            ColumnsWithTypeAndName or_args = {{ nullptr, tmp_block.getByPosition(or_lhs_pos).type, \"\" },\n+                                              { nullptr, tmp_block.getByPosition(or_rhs_pos).type, \"\" }};\n+\n+            auto func_or_adaptor = func_or->build(or_args);\n+            tmp_block.getByPosition(tmp_block.columns() - 1).type = func_or_adaptor->getReturnType();\n+            func_or_adaptor->execute(tmp_block, {or_lhs_pos, or_rhs_pos}, tmp_block.columns() - 1, input_rows_count);\n+\n         }\n \n         block.getByPosition(result).column = tmp_block.getByPosition(tmp_block.columns() - 1).column;\n@@ -1109,13 +1134,20 @@ class FunctionComparison : public IFunction\n             auto adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(\n                 FunctionComparison<Op, Name>::create(context)));\n \n+            bool has_nullable = false;\n+\n             size_t size = left_tuple->getElements().size();\n             for (size_t i = 0; i < size; ++i)\n             {\n                 ColumnsWithTypeAndName args = {{nullptr, left_tuple->getElements()[i], \"\"},\n                                                {nullptr, right_tuple->getElements()[i], \"\"}};\n-                adaptor.build(args);\n+                has_nullable = has_nullable || adaptor.build(args)->getReturnType()->isNullable();\n             }\n+\n+            /// If any element comparison is nullable, return type will also be nullable.\n+            /// We useDefaultImplementationForNulls, but it doesn't work for tuples.\n+            if (has_nullable)\n+                return std::make_shared<DataTypeNullable>(std::make_shared<DataTypeUInt8>());\n         }\n \n         return std::make_shared<DataTypeUInt8>();\n@@ -1135,7 +1167,7 @@ class FunctionComparison : public IFunction\n         /// NOTE: Nullable types are special case.\n         /// (BTW, this function use default implementation for Nullable, so Nullable types cannot be here. Check just in case.)\n         /// NOTE: We consider NaN comparison to be implementation specific (and in our implementation NaNs are sometimes equal sometimes not).\n-        if (left_type->equals(*right_type) && !left_type->isNullable() && col_left_untyped == col_right_untyped)\n+        if (left_type->equals(*right_type) && !left_type->isNullable() && !isTuple(left_type) && col_left_untyped == col_right_untyped)\n         {\n             /// Always true: =, <=, >=\n             if constexpr (std::is_same_v<Op<int, int>, EqualsOp<int, int>>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01353_nullable_tuple.reference b/tests/queries/0_stateless/01353_nullable_tuple.reference\nnew file mode 100644\nindex 000000000000..b79391827802\n--- /dev/null\n+++ b/tests/queries/0_stateless/01353_nullable_tuple.reference\n@@ -0,0 +1,92 @@\n+single argument\n+1\n+0\n+1\n+0\n+1\n+0\n+- 1\n+1\n+1\n+1\n+0\n+0\n+0\n+0\n+0\n+0\n+1\n+1\n+1\n+- 2\n+1\n+1\n+1\n+0\n+0\n+0\n+0\n+0\n+1\n+1\n+1\n+1\n+- 3\n+1\n+1\n+1\n+1\n+1\n+1\n+- 4\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+two arguments\n+1\n+1\n+1\n+1\n+1\n+1\n+- 1\n+0\n+0\n+0\n+0\n+0\n+0\n+- 2\n+1\n+1\n+1\n+1\n+1\n+1\n+- 3\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+\\N\n+\\N\n+0\n+many arguments\n+1\n+1\n+0\n+0\n+1\n+0\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/01353_nullable_tuple.sql b/tests/queries/0_stateless/01353_nullable_tuple.sql\nnew file mode 100644\nindex 000000000000..f757e2c42d7f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01353_nullable_tuple.sql\n@@ -0,0 +1,107 @@\n+select 'single argument';\n+select tuple(number) = tuple(number) from numbers(1);\n+select tuple(number) = tuple(number + 1) from numbers(1);\n+select tuple(toNullable(number)) = tuple(number) from numbers(1);\n+select tuple(toNullable(number)) = tuple(number + 1) from numbers(1);\n+select tuple(toNullable(number)) = tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number)) = tuple(toNullable(number + 1)) from numbers(1);\n+select '- 1';\n+select tuple(toNullable(number)) < tuple(number + 1) from numbers(1);\n+select tuple(number) < tuple(toNullable(number + 1)) from numbers(1);\n+select tuple(toNullable(number)) < tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number)) > tuple(number + 1) from numbers(1);\n+select tuple(number) > tuple(toNullable(number + 1)) from numbers(1);\n+select tuple(toNullable(number)) > tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number + 1)) < tuple(number) from numbers(1);\n+select tuple(number + 1) < tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number + 1)) < tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number + 1)) > tuple(number) from numbers(1);\n+select tuple(number + 1) > tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number + 1)) > tuple(toNullable(number)) from numbers(1);\n+\n+select '- 2';\n+select tuple(toNullable(number)) <= tuple(number + 1) from numbers(1);\n+select tuple(number) <= tuple(toNullable(number + 1)) from numbers(1);\n+select tuple(toNullable(number)) <= tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number)) >= tuple(number + 1) from numbers(1);\n+select tuple(number) > tuple(toNullable(number + 1)) from numbers(1);\n+select tuple(toNullable(number)) >= tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number + 1)) <= tuple(number) from numbers(1);\n+select tuple(number + 1) <= tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number + 1)) <= tuple(toNullable(number + 1)) from numbers(1);\n+\n+select tuple(toNullable(number + 1)) >= tuple(number) from numbers(1);\n+select tuple(number + 1) >= tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number + 1)) >= tuple(toNullable(number)) from numbers(1);\n+\n+select '- 3';\n+select tuple(toNullable(number)) <= tuple(number) from numbers(1);\n+select tuple(number) <= tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number)) <= tuple(toNullable(number)) from numbers(1);\n+\n+select tuple(toNullable(number)) >= tuple(number) from numbers(1);\n+select tuple(number) >= tuple(toNullable(number)) from numbers(1);\n+select tuple(toNullable(number)) >= tuple(toNullable(number)) from numbers(1);\n+\n+select '- 4';\n+select tuple(number) = tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+select tuple(materialize(toUInt64OrNull(''))) = tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+select tuple(number) <= tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+select tuple(materialize(toUInt64OrNull(''))) <= tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+select tuple(number) >= tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+select tuple(materialize(toUInt64OrNull(''))) >= tuple(materialize(toUInt64OrNull(''))) from numbers(1);\n+\n+select 'two arguments';\n+select tuple(toNullable(number), number) = tuple(number, number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) = tuple(number, number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) = tuple(toNullable(number), number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) = tuple(toNullable(number), toNullable(number)) from numbers(1);\n+select tuple(number, toNullable(number)) = tuple(toNullable(number), toNullable(number)) from numbers(1);\n+select tuple(number, toNullable(number)) = tuple(toNullable(number), number) from numbers(1);\n+\n+select '- 1';\n+select tuple(toNullable(number), number) < tuple(number, number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(number, number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(toNullable(number), number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(toNullable(number), toNullable(number)) from numbers(1);\n+select tuple(number, toNullable(number)) < tuple(toNullable(number), toNullable(number)) from numbers(1);\n+select tuple(number, toNullable(number)) < tuple(toNullable(number), number) from numbers(1);\n+\n+select '- 2';\n+select tuple(toNullable(number), number) < tuple(number, number + 1) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(number, number + 1) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(toNullable(number + 1), number) from numbers(1);\n+select tuple(toNullable(number), toNullable(number)) < tuple(toNullable(number + 1), toNullable(number)) from numbers(1);\n+select tuple(number, toNullable(number)) < tuple(toNullable(number), toNullable(number + 1)) from numbers(1);\n+select tuple(number, toNullable(number)) < tuple(toNullable(number), number + 1) from numbers(1);\n+\n+select '- 3';\n+select tuple(materialize(toUInt64OrNull('')), number) = tuple(number, number) from numbers(1);\n+select tuple(materialize(toUInt64OrNull('')), number) = tuple(number, toUInt64OrNull('')) from numbers(1);\n+select tuple(materialize(toUInt64OrNull('')), toUInt64OrNull('')) = tuple(toUInt64OrNull(''), toUInt64OrNull('')) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) < tuple(number, number) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) <= tuple(number, number) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) < tuple(number + 1, number) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) > tuple(number, number) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) >= tuple(number, number) from numbers(1);\n+select tuple(number, materialize(toUInt64OrNull(''))) > tuple(number + 1, number) from numbers(1);\n+\n+select 'many arguments';\n+select tuple(toNullable(number), number, number) = tuple(number, number, number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), number) = tuple(number, materialize('a'), number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), number) = tuple(number, materialize('a'), number + 1) from numbers(1);\n+select tuple(toNullable(number), number, number) < tuple(number, number, number) from numbers(1);\n+select tuple(toNullable(number), number, number) <= tuple(number, number, number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), number) < tuple(number, materialize('a'), number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), number) < tuple(number, materialize('a'), number + 1) from numbers(1);\n+select tuple(toNullable(number), number, materialize(toUInt64OrNull(''))) = tuple(number, number, number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), materialize(toUInt64OrNull(''))) = tuple(number, materialize('a'), number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), materialize(toUInt64OrNull(''))) = tuple(number, materialize('a'), number + 1) from numbers(1);\n+select tuple(toNullable(number), number, materialize(toUInt64OrNull(''))) <= tuple(number, number, number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), materialize(toUInt64OrNull(''))) <= tuple(number, materialize('a'), number) from numbers(1);\n+select tuple(toNullable(number), materialize('a'), materialize(toUInt64OrNull(''))) <= tuple(number, materialize('a'), number + 1) from numbers(1);\n",
  "problem_statement": "Comparison of nullables inside tuples\n**Describe the bug**\r\nComparing nullable against non-nullable works fine:\r\n```\r\n$ curl localhost:8123 -d \"select 'b' > 'a'\"\r\n1\r\n$ curl localhost:8123 -d \"select toNullable('b') > 'a'\"\r\n1\r\n$ curl localhost:8123 -d \"select toNullable('b') > toNullable('a')\"\r\n1\r\n$ curl localhost:8123 -d \"select 'b' > toNullable('a')\"\r\n1\r\n```\r\n\r\nBut when we put nullable inside single element tuple, it crashes the server (after each crash I restarted the server):\r\n```\r\n$ curl localhost:8123 -d \"select tuple('b') > tuple('a')\"\r\n1\r\n$ curl localhost:8123 -d \"select tuple(toNullable('b')) > tuple('a')\"\r\ncurl: (52) Empty reply from server\r\n$ curl localhost:8123 -d \"select tuple(toNullable('b')) > tuple(toNullable('a'))\"\r\ncurl: (52) Empty reply from server\r\n$ curl localhost:8123 -d \"select tuple('b') > tuple(toNullable('a'))\"\r\ncurl: (52) Empty reply from server\r\n```\r\nServer stderr looks like the following:\r\n```\r\n2020.06.26 18:57:07.770739 [ 20123 ] {} <Trace> HTTPHandler-factory: HTTP Request for HTTPHandler-factory. Method: POST, Address: [::1]:38144, User-Agent: curl/7.58.0, Length: 42, Content Type: application/x-www-form-urlencoded, Transfer Encoding: identity                                                              \r\n2020.06.26 18:57:07.771115 [ 20123 ] {} <Trace> DynamicQueryHandler: Request URI: /                                                                                                                                                                                                                                           \r\n2020.06.26 18:57:07.771927 [ 20123 ] {6015c322-8e28-49e9-a8b5-126e7c4d2244} <Debug> executeQuery: (from [::1]:38144) select tuple(toNullable('b')) > tuple('a')                                                                                                                                                               \r\n2020.06.26 18:57:07.773392 [ 20123 ] {6015c322-8e28-49e9-a8b5-126e7c4d2244} <Trace> ContextAccess (default): Access granted: SELECT(dummy) ON system.one                                                                                                                                                                      \r\n2020.06.26 18:57:07.773629 [ 20123 ] {6015c322-8e28-49e9-a8b5-126e7c4d2244} <Trace> InterpreterSelectQuery: FetchColumns -> Complete                                                                                                                                                                                          \r\n2020.06.26 18:57:07.774329 [ 20123 ] {6015c322-8e28-49e9-a8b5-126e7c4d2244} <Error> : Logical error: 'Bad cast from type DB::ColumnNullable to DB::ColumnVector<unsigned char>'.                                                                                                                                              \r\nclickhouse-server: /place/db-0/key_0/srvs/worker_3e27dc966f8b8c61e8432d508e3db20f/srvdata/tared_svnc/12f2797-39a58e0c-86c4981b-2a8660d6/clickhouse/src/Common/Exception.cpp:45: DB::Exception::Exception(const std::string &, int): Assertion `false' failed.                                                                 \r\n2020.06.26 18:57:07.774630 [ 20054 ] {} <Trace> BaseDaemon: Received signal 6                                                                                                                                                                                                                                                 \r\n2020.06.26 18:57:07.774978 [ 20303 ] {} <Fatal> BaseDaemon: ########################################                                                                                                                                                                                                                          \r\n```\r\n\r\nWhat surprises me, longer tuples work just fine:\r\n```\r\n$ curl localhost:8123 -d \"select tuple(toNullable('b'), toNullable('b')) > tuple('a', 'a')\"\r\n1\r\n$ curl localhost:8123 -d \"select tuple(toNullable('b'), 'b') > tuple('a', 'a')\"\r\n1\r\n$ curl localhost:8123 -d \"select tuple('b', toNullable('b')) > tuple('a', 'a')\"\r\n1\r\n$ curl localhost:8123 -d \"select tuple('b', toNullable('b')) > tuple(toNullable('a'), 'a')\"\r\n1\r\n$ curl localhost:8123 -d \"select tuple('b', toNullable('b')) > tuple(toNullable('a'), toNullable('a'))\"\r\n1\r\n```\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\n```\r\n$ ./clickhouse-server -V\r\nClickHouse server version 20.6.1.1-arcadia.\r\n```\n",
  "hints_text": "Just to mention: I expect these comparisons to work and not any kind of \"comparing nullables inside tuples is not supported\" error :)\nThe crash happens only in debug build (we translate all exceptions with `LOGICAL_ERROR` to std::terminate, but only in debug build).\r\n",
  "created_at": "2020-06-29T15:36:11Z"
}