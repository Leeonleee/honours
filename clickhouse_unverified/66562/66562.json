{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66562,
  "instance_id": "ClickHouse__ClickHouse-66562",
  "issue_numbers": [
    "66559"
  ],
  "base_commit": "c458d27401ebb5fdc72823800d25658ec90af41a",
  "patch": "diff --git a/.clang-tidy b/.clang-tidy\nindex de19059d09e5..bb63bf2eea65 100644\n--- a/.clang-tidy\n+++ b/.clang-tidy\n@@ -27,6 +27,8 @@ Checks: [\n   '-bugprone-not-null-terminated-result',\n   '-bugprone-reserved-identifier', # useful but too slow, TODO retry when https://reviews.llvm.org/rG1c282052624f9d0bd273bde0b47b30c96699c6c7 is merged\n   '-bugprone-unchecked-optional-access',\n+  '-bugprone-crtp-constructor-accessibility',\n+  '-bugprone-suspicious-stringview-data-usage',\n \n   '-cert-dcl16-c',\n   '-cert-dcl37-c',\n@@ -36,6 +38,7 @@ Checks: [\n   '-cert-msc51-cpp',\n   '-cert-oop54-cpp',\n   '-cert-oop57-cpp',\n+  '-cert-err33-c', # Misreports on clang-19: it warns about all functions containing 'remove' in the name, not only about the standard library.\n \n   '-clang-analyzer-optin.performance.Padding',\n \n@@ -99,6 +102,7 @@ Checks: [\n   '-modernize-use-emplace',\n   '-modernize-use-nodiscard',\n   '-modernize-use-trailing-return-type',\n+  '-modernize-use-designated-initializers',\n \n   '-performance-enum-size',\n   '-performance-inefficient-string-concatenation',\ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex 27717ea3611a..95c54ac95284 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -1184,7 +1184,7 @@ class FunctionAnyHash : public IFunction\n \n         if (icolumn->size() != vec_to.size())\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"Argument column '{}' size {} doesn't match result column size {} of function {}\",\n-                    icolumn->getName(), icolumn->size(), vec_to.size(), getName());\n+                icolumn->getName(), icolumn->size(), vec_to.size(), getName());\n \n         if constexpr (Keyed)\n             if (key_cols.size() != vec_to.size() && key_cols.size() != 1)\n@@ -1223,6 +1223,9 @@ class FunctionAnyHash : public IFunction\n         else executeGeneric<first>(key_cols, icolumn, vec_to);\n     }\n \n+    /// Return a fixed random-looking magic number when input is empty.\n+    static constexpr auto filler = 0xe28dbde7fe22e41c;\n+\n     void executeForArgument(const KeyColumnsType & key_cols, const IDataType * type, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to, bool & is_first) const\n     {\n         /// Flattening of tuples.\n@@ -1231,6 +1234,11 @@ class FunctionAnyHash : public IFunction\n             const auto & tuple_columns = tuple->getColumns();\n             const DataTypes & tuple_types = typeid_cast<const DataTypeTuple &>(*type).getElements();\n             size_t tuple_size = tuple_columns.size();\n+\n+            if (0 == tuple_size && is_first)\n+                for (auto & hash : vec_to)\n+                    hash = static_cast<ToType>(filler);\n+\n             for (size_t i = 0; i < tuple_size; ++i)\n                 executeForArgument(key_cols, tuple_types[i].get(), tuple_columns[i].get(), vec_to, is_first);\n         }\n@@ -1239,6 +1247,11 @@ class FunctionAnyHash : public IFunction\n             const auto & tuple_columns = tuple_const->getColumns();\n             const DataTypes & tuple_types = typeid_cast<const DataTypeTuple &>(*type).getElements();\n             size_t tuple_size = tuple_columns.size();\n+\n+            if (0 == tuple_size && is_first)\n+                for (auto & hash : vec_to)\n+                    hash = static_cast<ToType>(filler);\n+\n             for (size_t i = 0; i < tuple_size; ++i)\n             {\n                 auto tmp = ColumnConst::create(tuple_columns[i], column->size());\n@@ -1300,10 +1313,7 @@ class FunctionAnyHash : public IFunction\n             constexpr size_t first_data_argument = Keyed;\n \n             if (arguments.size() <= first_data_argument)\n-            {\n-                /// Return a fixed random-looking magic number when input is empty\n-                vec_to.assign(input_rows_count, static_cast<ToType>(0xe28dbde7fe22e41c));\n-            }\n+                vec_to.assign(input_rows_count, static_cast<ToType>(filler));\n \n             KeyColumnsType key_cols{};\n             if constexpr (Keyed)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03205_hashing_empty_tuples.reference b/tests/queries/0_stateless/03205_hashing_empty_tuples.reference\nnew file mode 100644\nindex 000000000000..e24b5809aeed\n--- /dev/null\n+++ b/tests/queries/0_stateless/03205_hashing_empty_tuples.reference\n@@ -0,0 +1,22 @@\n+16324913028386710556\n+16324913028386710556\n+5049034479224883533\n+7385293435322750976\n+12248912094175844631\n+5049034479224883533\n+5887129541803688833\n+5887129541803688833\n+13747979201178469747\n+5887129541803688833\n+15520217392480966957\n+16324913028386710556\n+16324913028386710556\n+5049034479224883533\n+7385293435322750976\n+12248912094175844631\n+5049034479224883533\n+5887129541803688833\n+5887129541803688833\n+13747979201178469747\n+5887129541803688833\n+15520217392480966957\ndiff --git a/tests/queries/0_stateless/03205_hashing_empty_tuples.sql b/tests/queries/0_stateless/03205_hashing_empty_tuples.sql\nnew file mode 100644\nindex 000000000000..4a97f30ced31\n--- /dev/null\n+++ b/tests/queries/0_stateless/03205_hashing_empty_tuples.sql\n@@ -0,0 +1,23 @@\n+SELECT sipHash64(());\n+SELECT sipHash64((), ());\n+SELECT sipHash64((), 1);\n+SELECT sipHash64(1, ());\n+SELECT sipHash64(1, (), 1);\n+SELECT sipHash64((), 1, ());\n+SELECT sipHash64((), (1, 2));\n+SELECT sipHash64((), (1, 2));\n+SELECT sipHash64((1, 2), ());\n+SELECT sipHash64((), (1, 2), ());\n+SELECT sipHash64((1, 2), (), (3, 4));\n+\n+SELECT sipHash64(materialize(()));\n+SELECT sipHash64(materialize(()), materialize(()));\n+SELECT sipHash64(materialize(()), 1);\n+SELECT sipHash64(1, materialize(()));\n+SELECT sipHash64(1, materialize(()), 1);\n+SELECT sipHash64((), 1, materialize(()));\n+SELECT sipHash64(materialize(()), (1, 2));\n+SELECT sipHash64(materialize(()), (1, 2));\n+SELECT sipHash64((1, 2), materialize(()));\n+SELECT sipHash64(materialize(()), (1, 2), ());\n+SELECT sipHash64((1, 2), materialize(()), (3, 4));\n",
  "problem_statement": "MSan report when hashing empty tuples\n```\r\nSELECT sipHash64(())\r\n```\n",
  "hints_text": "",
  "created_at": "2024-07-16T03:12:04Z",
  "modified_files": [
    ".clang-tidy",
    "src/Functions/FunctionsHashing.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03205_hashing_empty_tuples.reference",
    "b/tests/queries/0_stateless/03205_hashing_empty_tuples.sql"
  ]
}