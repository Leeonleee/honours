{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47532,
  "instance_id": "ClickHouse__ClickHouse-47532",
  "issue_numbers": [
    "44532"
  ],
  "base_commit": "1556cdd21a3704b33d80b3fa2f8a8eda7830d399",
  "patch": "diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md\nindex bb2573116809..23ab2699cc16 100644\n--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md\n+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md\n@@ -1354,3 +1354,4 @@ In this sample configuration:\n - `_part_uuid` \u2014 Unique part identifier (if enabled MergeTree setting `assign_part_uuids`).\n - `_partition_value` \u2014 Values (a tuple) of a `partition by` expression.\n - `_sample_factor` \u2014 Sample factor (from the query).\n+- `_block_number` \u2014 Block number of the row, it is persisted on merges when `allow_experimental_block_number_column` is set to true.\ndiff --git a/docs/en/operations/settings/merge-tree-settings.md b/docs/en/operations/settings/merge-tree-settings.md\nindex e746719b6290..483dcf2e61cf 100644\n--- a/docs/en/operations/settings/merge-tree-settings.md\n+++ b/docs/en/operations/settings/merge-tree-settings.md\n@@ -854,3 +854,9 @@ Possible values:\n - `Always` or `Never`.\n \n Default value: `Never`\n+\n+## allow_experimental_block_number_column\n+\n+Persists virtual column `_block_number` on merges.\n+\n+Default value: false.\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 1cd34c2a0f68..a0635f182149 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -31,6 +31,7 @@\n #include <Storages/StorageInMemoryMetadata.h>\n #include <Storages/WindowView/StorageWindowView.h>\n #include <Storages/StorageReplicatedMergeTree.h>\n+#include <Storages/BlockNumberColumn.h>\n \n #include <Interpreters/Context.h>\n #include <Interpreters/executeDDLQueryOnCluster.h>\n@@ -833,6 +834,13 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat\n                             \"Cannot create table with column '{}' for *MergeTree engines because it \"\n                             \"is reserved for lightweight delete feature\",\n                             LightweightDeleteDescription::FILTER_COLUMN.name);\n+\n+        auto search_block_number = all_columns.find(BlockNumberColumn::name);\n+        if (search_block_number != all_columns.end())\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                            \"Cannot create table with column '{}' for *MergeTree engines because it \"\n+                            \"is reserved for storing block number\",\n+                            BlockNumberColumn::name);\n     }\n \n     const auto & settings = getContext()->getSettingsRef();\ndiff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex e50f8488cac4..4b0cbec4f9fb 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -7,6 +7,7 @@\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Storages/MergeTree/StorageFromMergeTreeDataPart.h>\n #include <Storages/StorageMergeTree.h>\n+#include <Storages/BlockNumberColumn.h>\n #include <Processors/Transforms/FilterTransform.h>\n #include <Processors/Transforms/ExpressionTransform.h>\n #include <Processors/Transforms/CreatingSetsTransform.h>\n@@ -40,7 +41,6 @@\n #include <Parsers/makeASTForLogicalFunction.h>\n #include <Common/logger_useful.h>\n \n-\n namespace DB\n {\n \n@@ -56,6 +56,7 @@ namespace ErrorCodes\n     extern const int THERE_IS_NO_COLUMN;\n }\n \n+\n namespace\n {\n \n@@ -416,6 +417,12 @@ static void validateUpdateColumns(\n             found = true;\n         }\n \n+        /// Dont allow to override value of block number virtual column\n+        if (!found && column_name == BlockNumberColumn::name)\n+        {\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Update is not supported for virtual column {} \", backQuote(column_name));\n+        }\n+\n         if (!found)\n         {\n             for (const auto & col : metadata_snapshot->getColumns().getMaterialized())\n@@ -511,7 +518,8 @@ void MutationsInterpreter::prepare(bool dry_run)\n \n         for (const auto & [name, _] : command.column_to_update_expression)\n         {\n-            if (!available_columns_set.contains(name) && name != LightweightDeleteDescription::FILTER_COLUMN.name)\n+            if (!available_columns_set.contains(name) && name != LightweightDeleteDescription::FILTER_COLUMN.name\n+                && name != BlockNumberColumn::name)\n                 throw Exception(ErrorCodes::THERE_IS_NO_COLUMN,\n                     \"Column {} is updated but not requested to read\", name);\n \n@@ -613,6 +621,8 @@ void MutationsInterpreter::prepare(bool dry_run)\n                     type = physical_column->type;\n                 else if (column == LightweightDeleteDescription::FILTER_COLUMN.name)\n                     type = LightweightDeleteDescription::FILTER_COLUMN.type;\n+                else if (column == BlockNumberColumn::name)\n+                    type = BlockNumberColumn::type;\n                 else\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown column {}\", column);\n \n@@ -1087,6 +1097,18 @@ struct VirtualColumns\n \n                 virtuals.emplace_back(ColumnAndPosition{.column = std::move(column), .position = i});\n             }\n+            else if (columns_to_read[i] == BlockNumberColumn::name)\n+            {\n+                if (!part->getColumns().contains(BlockNumberColumn::name))\n+                {\n+                    ColumnWithTypeAndName block_number_column;\n+                    block_number_column.type = BlockNumberColumn::type;\n+                    block_number_column.column = block_number_column.type->createColumnConst(0, part->info.min_block);\n+                    block_number_column.name = std::move(columns_to_read[i]);\n+\n+                    virtuals.emplace_back(ColumnAndPosition{.column = std::move(block_number_column), .position = i});\n+                }\n+            }\n         }\n \n         if (!virtuals.empty())\ndiff --git a/src/Interpreters/inplaceBlockConversions.cpp b/src/Interpreters/inplaceBlockConversions.cpp\nindex 4cac2f0e20c8..b7ef5dbdbbcb 100644\n--- a/src/Interpreters/inplaceBlockConversions.cpp\n+++ b/src/Interpreters/inplaceBlockConversions.cpp\n@@ -20,6 +20,7 @@\n #include <Columns/ColumnArray.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Storages/StorageInMemoryMetadata.h>\n+#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n@@ -260,7 +261,7 @@ void fillMissingColumns(\n     const NamesAndTypesList & requested_columns,\n     const NamesAndTypesList & available_columns,\n     const NameSet & partially_read_columns,\n-    StorageMetadataPtr metadata_snapshot)\n+    StorageMetadataPtr metadata_snapshot, size_t block_number)\n {\n     size_t num_columns = requested_columns.size();\n     if (num_columns != res_columns.size())\n@@ -339,9 +340,14 @@ void fillMissingColumns(\n         }\n         else\n         {\n-            /// We must turn a constant column into a full column because the interpreter could infer\n-            /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n-            res_columns[i] = type->createColumnConstWithDefaultValue(num_rows)->convertToFullColumnIfConst();\n+            if (requested_column->name == BlockNumberColumn::name)\n+                res_columns[i] = type->createColumnConst(num_rows, block_number)->convertToFullColumnIfConst();\n+            else\n+                /// We must turn a constant column into a full column because the interpreter could infer\n+                /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n+                res_columns[i] = type->createColumnConstWithDefaultValue(num_rows)->convertToFullColumnIfConst();\n+\n+\n         }\n     }\n }\ndiff --git a/src/Interpreters/inplaceBlockConversions.h b/src/Interpreters/inplaceBlockConversions.h\nindex bea44bf6db94..7a13a75ec8b8 100644\n--- a/src/Interpreters/inplaceBlockConversions.h\n+++ b/src/Interpreters/inplaceBlockConversions.h\n@@ -46,6 +46,6 @@ void fillMissingColumns(\n     const NamesAndTypesList & requested_columns,\n     const NamesAndTypesList & available_columns,\n     const NameSet & partially_read_columns,\n-    StorageMetadataPtr metadata_snapshot);\n+    StorageMetadataPtr metadata_snapshot, size_t block_number = 0);\n \n }\ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 7dac5715f956..f468e112d8ff 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -12,6 +12,7 @@\n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <IO/WriteHelpers.h>\n+#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n@@ -222,6 +223,12 @@ static SummingSortedAlgorithm::ColumnsDefinition defineColumns(\n         const ColumnWithTypeAndName & column = header.safeGetByPosition(i);\n \n         const auto * simple = dynamic_cast<const DataTypeCustomSimpleAggregateFunction *>(column.type->getCustomName());\n+        if (column.name == BlockNumberColumn::name)\n+        {\n+            def.column_numbers_not_to_aggregate.push_back(i);\n+            continue;\n+        }\n+\n         /// Discover nested Maps and find columns for summation\n         if (typeid_cast<const DataTypeArray *>(column.type.get()) && !simple)\n         {\ndiff --git a/src/Processors/Transforms/TTLTransform.cpp b/src/Processors/Transforms/TTLTransform.cpp\nindex 3250d012d5cf..7cde86098c7a 100644\n--- a/src/Processors/Transforms/TTLTransform.cpp\n+++ b/src/Processors/Transforms/TTLTransform.cpp\n@@ -49,7 +49,8 @@ TTLTransform::TTLTransform(\n \n     for (const auto & group_by_ttl : metadata_snapshot_->getGroupByTTLs())\n         algorithms.emplace_back(std::make_unique<TTLAggregationAlgorithm>(\n-            group_by_ttl, old_ttl_infos.group_by_ttl[group_by_ttl.result_column], current_time_, force_, getInputPort().getHeader(), storage_));\n+                group_by_ttl, old_ttl_infos.group_by_ttl[group_by_ttl.result_column], current_time_, force_,\n+                getInputPort().getHeader(), storage_));\n \n     if (metadata_snapshot_->hasAnyColumnTTL())\n     {\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex f38fc1f37349..da46cb4d7fea 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -27,6 +27,7 @@\n #include <Storages/AlterCommands.h>\n #include <Storages/IStorage.h>\n #include <Storages/LightweightDeleteDescription.h>\n+#include <Storages/BlockNumberColumn.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Common/typeid_cast.h>\n #include <Common/randomSeed.h>\n@@ -782,7 +783,7 @@ bool AlterCommand::isRequireMutationStage(const StorageInMemoryMetadata & metada\n     /// Drop alias is metadata alter, in other case mutation is required.\n     if (type == DROP_COLUMN)\n         return metadata.columns.hasColumnOrNested(GetColumnsOptions::AllPhysical, column_name) ||\n-            column_name == LightweightDeleteDescription::FILTER_COLUMN.name;\n+            column_name == LightweightDeleteDescription::FILTER_COLUMN.name || column_name == BlockNumberColumn::name;\n \n     if (type != MODIFY_COLUMN || data_type == nullptr)\n         return false;\n@@ -1066,6 +1067,10 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n                 throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot add column {}: \"\n                                 \"this column name is reserved for lightweight delete feature\", backQuote(column_name));\n \n+            if (column_name == BlockNumberColumn::name && std::dynamic_pointer_cast<MergeTreeData>(table))\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot add column {}: \"\n+                                                            \"this column name is reserved for _block_number persisting feature\", backQuote(column_name));\n+\n             if (command.codec)\n                 CompressionCodecFactory::instance().validateCodecAndGetPreprocessedAST(command.codec, command.data_type, !context->getSettingsRef().allow_suspicious_codecs, context->getSettingsRef().allow_experimental_codecs, context->getSettingsRef().enable_deflate_qpl_codec);\n \n@@ -1270,6 +1275,10 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n                 throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot rename to {}: \"\n                                 \"this column name is reserved for lightweight delete feature\", backQuote(command.rename_to));\n \n+            if (command.rename_to == BlockNumberColumn::name && std::dynamic_pointer_cast<MergeTreeData>(table))\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot rename to {}: \"\n+                                                            \"this column name is reserved for _block_number persisting feature\", backQuote(command.rename_to));\n+\n             if (modified_columns.contains(column_name))\n                 throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot rename and modify the same column {} \"\n                                                              \"in a single ALTER query\", backQuote(column_name));\ndiff --git a/src/Storages/BlockNumberColumn.cpp b/src/Storages/BlockNumberColumn.cpp\nnew file mode 100644\nindex 000000000000..8c9e1fd902af\n--- /dev/null\n+++ b/src/Storages/BlockNumberColumn.cpp\n@@ -0,0 +1,23 @@\n+#include <Storages/BlockNumberColumn.h>\n+#include <Compression/CompressionCodecMultiple.h>\n+\n+namespace DB\n+{\n+\n+CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n+\n+CompressionCodecPtr getCompressionCodecForBlockNumberColumn()\n+{\n+    std::vector <CompressionCodecPtr> codecs;\n+    codecs.reserve(2);\n+    auto data_bytes_size = BlockNumberColumn::type->getSizeOfValueInMemory();\n+    codecs.emplace_back(getCompressionCodecDelta(data_bytes_size));\n+    codecs.emplace_back(CompressionCodecFactory::instance().get(\"LZ4\", {}));\n+    return std::make_shared<CompressionCodecMultiple>(codecs);\n+}\n+\n+const String BlockNumberColumn::name = \"_block_number\";\n+const DataTypePtr BlockNumberColumn::type = std::make_shared<DataTypeUInt64>();\n+const CompressionCodecPtr BlockNumberColumn::compression_codec = getCompressionCodecForBlockNumberColumn();\n+\n+}\ndiff --git a/src/Storages/BlockNumberColumn.h b/src/Storages/BlockNumberColumn.h\nnew file mode 100644\nindex 000000000000..fffa68bfd499\n--- /dev/null\n+++ b/src/Storages/BlockNumberColumn.h\n@@ -0,0 +1,16 @@\n+#pragma once\n+#include <Core/NamesAndTypes.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Compression/CompressionFactory.h>\n+\n+namespace DB\n+{\n+\n+struct BlockNumberColumn\n+{\n+    static const String name;\n+    static const DataTypePtr type;\n+    static const CompressionCodecPtr compression_codec;\n+};\n+\n+}\ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 0c918bda5fdd..9fa79387d5cc 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -30,11 +30,15 @@\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n+#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n {\n \n+CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n+\n+\n namespace ErrorCodes\n {\n     extern const int NO_SUCH_COLUMN_IN_TABLE;\n@@ -721,11 +725,13 @@ CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_\n \n CompressionCodecPtr ColumnsDescription::getCodecOrDefault(const String & column_name) const\n {\n+    assert (column_name != BlockNumberColumn::name);\n     return getCodecOrDefault(column_name, CompressionCodecFactory::instance().getDefaultCodec());\n }\n \n ASTPtr ColumnsDescription::getCodecDescOrDefault(const String & column_name, CompressionCodecPtr default_codec) const\n {\n+    assert (column_name != BlockNumberColumn::name);\n     const auto it = columns.get<1>().find(column_name);\n \n     if (it == columns.get<1>().end() || !it->codec)\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 97c9b81ce87a..02c838458f93 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -477,10 +477,6 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n     /// Moar hardening: this method is supposed to be used for debug assertions\n     bool assertHasValidVersionMetadata() const;\n \n-    /// Return hardlink count for part.\n-    /// Required for keep data on remote FS when part has shadow copies.\n-    UInt32 getNumberOfRefereneces() const;\n-\n     /// True if the part supports lightweight delete mutate.\n     bool supportLightweightDeleteMutate() const;\n \ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.cpp b/src/Storages/MergeTree/IMergeTreeReader.cpp\nindex 4bb8c4006910..120edd81e302 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeReader.cpp\n@@ -62,7 +62,7 @@ const IMergeTreeReader::ValueSizeMap & IMergeTreeReader::getAvgValueSizeHints()\n     return avg_value_size_hints;\n }\n \n-void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows) const\n+void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows, size_t block_number) const\n {\n     try\n     {\n@@ -71,7 +71,7 @@ void IMergeTreeReader::fillMissingColumns(Columns & res_columns, bool & should_e\n             res_columns, num_rows,\n             Nested::convertToSubcolumns(requested_columns),\n             Nested::convertToSubcolumns(available_columns),\n-            partially_read_columns, storage_snapshot->metadata);\n+            partially_read_columns, storage_snapshot->metadata, block_number);\n \n         should_evaluate_missing_defaults = std::any_of(\n             res_columns.begin(), res_columns.end(), [](const auto & column) { return column == nullptr; });\ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.h b/src/Storages/MergeTree/IMergeTreeReader.h\nindex a7e602542172..02faebf4b410 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.h\n+++ b/src/Storages/MergeTree/IMergeTreeReader.h\n@@ -45,7 +45,7 @@ class IMergeTreeReader : private boost::noncopyable\n     /// Add columns from ordered_names that are not present in the block.\n     /// Missing columns are added in the order specified by ordered_names.\n     /// num_rows is needed in case if all res_columns are nullptr.\n-    void fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows) const;\n+    void fillMissingColumns(Columns & res_columns, bool & should_evaluate_missing_defaults, size_t num_rows, size_t block_number = 0) const;\n     /// Evaluate defaulted columns if necessary.\n     void evaluateMissingDefaults(Block additional_columns, Columns & res_columns) const;\n \ndiff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp\nindex df607d364026..adb1ca72e464 100644\n--- a/src/Storages/MergeTree/MergeTask.cpp\n+++ b/src/Storages/MergeTree/MergeTask.cpp\n@@ -218,6 +218,14 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()\n     ctx->need_remove_expired_values = false;\n     ctx->force_ttl = false;\n \n+    if (supportsBlockNumberColumn(global_ctx) && !global_ctx->storage_columns.contains(BlockNumberColumn::name))\n+    {\n+        global_ctx->storage_columns.emplace_back(NameAndTypePair{BlockNumberColumn::name,BlockNumberColumn::type});\n+        global_ctx->all_column_names.emplace_back(BlockNumberColumn::name);\n+        global_ctx->gathering_columns.emplace_back(NameAndTypePair{BlockNumberColumn::name,BlockNumberColumn::type});\n+        global_ctx->gathering_column_names.emplace_back(BlockNumberColumn::name);\n+    }\n+\n     SerializationInfo::Settings info_settings =\n     {\n         .ratio_of_defaults_for_sparse = global_ctx->data->getSettings()->ratio_of_defaults_for_sparse_serialization,\n@@ -251,12 +259,12 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()\n         }\n     }\n \n-    global_ctx->new_data_part->setColumns(global_ctx->storage_columns, infos, global_ctx->metadata_snapshot->getMetadataVersion());\n-\n     const auto & local_part_min_ttl = global_ctx->new_data_part->ttl_infos.part_min_ttl;\n     if (local_part_min_ttl && local_part_min_ttl <= global_ctx->time_of_merge)\n         ctx->need_remove_expired_values = true;\n \n+    global_ctx->new_data_part->setColumns(global_ctx->storage_columns, infos, global_ctx->metadata_snapshot->getMetadataVersion());\n+\n     if (ctx->need_remove_expired_values && global_ctx->ttl_merges_blocker->isCancelled())\n     {\n         LOG_INFO(ctx->log, \"Part {} has values with expired TTL, but merges with TTL are cancelled.\", global_ctx->new_data_part->name);\n@@ -998,6 +1006,17 @@ void MergeTask::ExecuteAndFinalizeHorizontalPart::createMergedStream()\n \n     if (global_ctx->deduplicate)\n     {\n+        /// We don't want to deduplicate by block number column\n+        /// so if deduplicate_by_columns is empty, add all columns except _block_number\n+        if (supportsBlockNumberColumn(global_ctx) && global_ctx->deduplicate_by_columns.empty())\n+        {\n+            for (const auto & col : global_ctx->merging_column_names)\n+            {\n+                if (col != BlockNumberColumn::name)\n+                    global_ctx->deduplicate_by_columns.emplace_back(col);\n+            }\n+        }\n+\n         if (DistinctSortedTransform::isApplicable(header, sort_description, global_ctx->deduplicate_by_columns))\n             res_pipe.addTransform(std::make_shared<DistinctSortedTransform>(\n                 res_pipe.getHeader(), sort_description, SizeLimits(), 0 /*limit_hint*/, global_ctx->deduplicate_by_columns));\ndiff --git a/src/Storages/MergeTree/MergeTask.h b/src/Storages/MergeTree/MergeTask.h\nindex 402d3c26e492..2122484bb24d 100644\n--- a/src/Storages/MergeTree/MergeTask.h\n+++ b/src/Storages/MergeTree/MergeTask.h\n@@ -13,6 +13,7 @@\n #include <QueryPipeline/QueryPipeline.h>\n #include <Compression/CompressedReadBufferFromFile.h>\n #include <Common/filesystemHelpers.h>\n+#include <Storages/BlockNumberColumn.h>\n \n #include <memory>\n #include <list>\n@@ -388,6 +389,12 @@ class MergeTask\n \n     Stages::iterator stages_iterator = stages.begin();\n \n+    /// Check for persisting block number column\n+    static bool supportsBlockNumberColumn(GlobalRuntimeContextPtr global_ctx)\n+    {\n+        return global_ctx->data->getSettings()->allow_experimental_block_number_column && global_ctx->metadata_snapshot->getGroupByTTLs().empty();\n+    }\n+\n };\n \n /// FIXME\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 4b6d2ea41ed4..14c9961f6c36 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -78,6 +78,7 @@\n #include <Storages/VirtualColumnUtils.h>\n #include <Storages/MergeTree/MergeTreeDataPartBuilder.h>\n #include <Storages/MutationCommands.h>\n+#include <Storages/BlockNumberColumn.h>\n \n #include <boost/range/algorithm_ext/erase.hpp>\n #include <boost/algorithm/string/join.hpp>\n@@ -3730,7 +3731,7 @@ void MergeTreeData::checkPartDynamicColumns(MutableDataPartPtr & part, DataParts\n     const auto & part_columns = part->getColumns();\n     for (const auto & part_column : part_columns)\n     {\n-        if (part_column.name == LightweightDeleteDescription::FILTER_COLUMN.name)\n+        if (part_column.name == LightweightDeleteDescription::FILTER_COLUMN.name || part_column.name == BlockNumberColumn::name)\n             continue;\n \n         auto storage_column = columns.getPhysical(part_column.name);\n@@ -8269,6 +8270,7 @@ NamesAndTypesList MergeTreeData::getVirtuals() const\n         NameAndTypePair(\"_sample_factor\", std::make_shared<DataTypeFloat64>()),\n         NameAndTypePair(\"_part_offset\", std::make_shared<DataTypeUInt64>()),\n         LightweightDeleteDescription::FILTER_COLUMN,\n+        NameAndTypePair(BlockNumberColumn::name, BlockNumberColumn::type),\n     };\n }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\nindex c6d059498ff5..209a5061f33a 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartCompact.cpp\n@@ -5,6 +5,7 @@\n #include <Interpreters/Context.h>\n #include <Storages/MergeTree/LoadedMergeTreeDataPartInfoForReader.h>\n #include <Compression/CompressedReadBufferFromFile.h>\n+#include <Storages/BlockNumberColumn.h>\n \n \n namespace DB\n@@ -64,6 +65,12 @@ IMergeTreeDataPart::MergeTreeWriterPtr MergeTreeDataPartCompact::getWriter(\n     ordered_columns_list.sort([this](const auto & lhs, const auto & rhs)\n         { return *getColumnPosition(lhs.name) < *getColumnPosition(rhs.name); });\n \n+    /// _block_number column is not added by user, but is persisted in a part after merge\n+    /// If _block_number is not present in the parts to be merged, then it won't have a position\n+    /// So check if its not present and add it at the end\n+    if (columns_list.contains(BlockNumberColumn::name) && !ordered_columns_list.contains(BlockNumberColumn::name))\n+        ordered_columns_list.emplace_back(NameAndTypePair{BlockNumberColumn::name, BlockNumberColumn::type});\n+\n     return std::make_unique<MergeTreeDataPartWriterCompact>(\n         shared_from_this(), ordered_columns_list, metadata_snapshot,\n         indices_to_recalc, getMarksFileExtension(),\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\nindex 3475130bf241..d2a9632d4e58 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp\n@@ -1,9 +1,12 @@\n #include <Storages/MergeTree/MergeTreeDataPartWriterCompact.h>\n #include <Storages/MergeTree/MergeTreeDataPartCompact.h>\n+#include <Storages/BlockNumberColumn.h>\n \n namespace DB\n {\n \n+    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n+\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n@@ -53,7 +56,14 @@ MergeTreeDataPartWriterCompact::MergeTreeDataPartWriterCompact(\n \n     const auto & storage_columns = metadata_snapshot->getColumns();\n     for (const auto & column : columns_list)\n-        addStreams(column, storage_columns.getCodecDescOrDefault(column.name, default_codec));\n+    {\n+        ASTPtr compression;\n+        if (column.name == BlockNumberColumn::name)\n+            compression = BlockNumberColumn::compression_codec->getFullCodecDesc();\n+        else\n+            compression = storage_columns.getCodecDescOrDefault(column.name, default_codec);\n+        addStreams(column, compression);\n+    }\n }\n \n void MergeTreeDataPartWriterCompact::addStreams(const NameAndTypePair & column, const ASTPtr & effective_codec_desc)\ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\nindex bcf340e0f551..f3e60e224aa7 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n@@ -6,9 +6,12 @@\n #include <Common/escapeForFileName.h>\n #include <Columns/ColumnSparse.h>\n #include <Common/logger_useful.h>\n+#include <Storages/BlockNumberColumn.h>\n \n namespace DB\n {\n+    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n+\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n@@ -87,7 +90,14 @@ MergeTreeDataPartWriterWide::MergeTreeDataPartWriterWide(\n {\n     const auto & columns = metadata_snapshot->getColumns();\n     for (const auto & it : columns_list)\n-        addStreams(it, columns.getCodecDescOrDefault(it.name, default_codec));\n+    {\n+        ASTPtr compression;\n+        if (it.name == BlockNumberColumn::name)\n+            compression = BlockNumberColumn::compression_codec->getFullCodecDesc();\n+        else\n+            compression = columns.getCodecDescOrDefault(it.name, default_codec);\n+        addStreams(it, compression);\n+    }\n }\n \n void MergeTreeDataPartWriterWide::addStreams(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 3c2b09b6f3b7..d8ebfb95d74f 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -46,7 +46,7 @@\n #include <Functions/IFunction.h>\n \n #include <IO/WriteBufferFromOStream.h>\n-\n+#include <Storages/BlockNumberColumn.h>\n #include <Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h>\n \n namespace CurrentMetrics\n@@ -1232,6 +1232,10 @@ static void selectColumnNames(\n         {\n             virt_column_names.push_back(name);\n         }\n+        else if (name == BlockNumberColumn::name)\n+        {\n+            virt_column_names.push_back(name);\n+        }\n         else if (name == \"_part_uuid\")\n         {\n             virt_column_names.push_back(name);\ndiff --git a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\nindex 95fcde23f8e4..9b480ac27a01 100644\n--- a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n@@ -9,6 +9,7 @@\n #include <DataTypes/DataTypeUUID.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Processors/Transforms/AggregatingTransform.h>\n+#include <Storages/BlockNumberColumn.h>\n #include <city.h>\n \n namespace DB\n@@ -24,7 +25,8 @@ namespace ErrorCodes\n static void injectNonConstVirtualColumns(\n     size_t rows,\n     Block & block,\n-    const Names & virtual_columns);\n+    const Names & virtual_columns,\n+    MergeTreeReadTask * task = nullptr);\n \n static void injectPartConstVirtualColumns(\n     size_t rows,\n@@ -247,7 +249,8 @@ namespace\n static void injectNonConstVirtualColumns(\n     size_t rows,\n     Block & block,\n-    const Names & virtual_columns)\n+    const Names & virtual_columns,\n+    MergeTreeReadTask * task)\n {\n     VirtualColumnsInserter inserter(block);\n     for (const auto & virtual_column_name : virtual_columns)\n@@ -278,6 +281,24 @@ static void injectNonConstVirtualColumns(\n \n                 inserter.insertUInt8Column(column, virtual_column_name);\n         }\n+\n+        if (virtual_column_name == BlockNumberColumn::name)\n+        {\n+            ColumnPtr column;\n+            if (rows)\n+            {\n+                size_t value = 0;\n+                if (task)\n+                {\n+                    value = task->getInfo().data_part ? task->getInfo().data_part->info.min_block : 0;\n+                }\n+                column = BlockNumberColumn::type->createColumnConst(rows, value)->convertToFullColumnIfConst();\n+            }\n+            else\n+                column = BlockNumberColumn::type->createColumn();\n+\n+            inserter.insertUInt64Column(column, virtual_column_name);\n+        }\n     }\n }\n \n@@ -368,7 +389,7 @@ void MergeTreeSelectProcessor::injectVirtualColumns(\n {\n     /// First add non-const columns that are filled by the range reader and then const columns that we will fill ourselves.\n     /// Note that the order is important: virtual columns filled by the range reader must go first\n-    injectNonConstVirtualColumns(row_count, block, virtual_columns);\n+    injectNonConstVirtualColumns(row_count, block, virtual_columns,task);\n     injectPartConstVirtualColumns(row_count, block, task, partition_value_type, virtual_columns);\n }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex 8a9faa5cee49..6ba0d4dcfad3 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -176,7 +176,7 @@ try\n             current_mark += (rows_to_read == rows_read);\n \n             bool should_evaluate_missing_defaults = false;\n-            reader->fillMissingColumns(columns, should_evaluate_missing_defaults, rows_read);\n+            reader->fillMissingColumns(columns, should_evaluate_missing_defaults, rows_read, data_part->info.min_block);\n \n             if (should_evaluate_missing_defaults)\n             {\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex 4f36da048c29..52c3f3efc6d6 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -171,7 +171,8 @@ struct Settings;\n     M(UInt64, part_moves_between_shards_delay_seconds, 30, \"Time to wait before/after moving parts between shards.\", 0) \\\n     M(Bool, allow_remote_fs_zero_copy_replication, false, \"Don't use this setting in production, because it is not ready.\", 0) \\\n     M(String, remote_fs_zero_copy_zookeeper_path, \"/clickhouse/zero_copy\", \"ZooKeeper path for zero-copy table-independent info.\", 0) \\\n-    M(Bool, remote_fs_zero_copy_path_compatible_mode, false, \"Run zero-copy in compatible mode during conversion process.\", 0) \\\n+    M(Bool, remote_fs_zero_copy_path_compatible_mode, false, \"Run zero-copy in compatible mode during conversion process.\", 0)                                                                                                                                       \\\n+    M(Bool, allow_experimental_block_number_column, false, \"Enable persisting column _block_number for each row.\", 0) \\\n     \\\n     /** Compress marks and primary key. */ \\\n     M(Bool, compress_marks, true, \"Marks support compression, reduce mark file size and speed up network transmission.\", 0) \\\ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex f869a1158ef2..4baa43311d43 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -102,6 +102,8 @@\n #include <IO/Operators.h>\n #include <IO/ConnectionTimeouts.h>\n \n+#include <Storages/BlockNumberColumn.h>\n+\n #include <memory>\n #include <filesystem>\n #include <optional>\n@@ -298,6 +300,7 @@ NamesAndTypesList StorageDistributed::getVirtuals() const\n         NameAndTypePair(\"_sample_factor\", std::make_shared<DataTypeFloat64>()),\n         NameAndTypePair(\"_part_offset\", std::make_shared<DataTypeUInt64>()),\n         NameAndTypePair(\"_row_exists\", std::make_shared<DataTypeUInt8>()),\n+        NameAndTypePair(BlockNumberColumn::name, BlockNumberColumn::type),\n         NameAndTypePair(\"_shard_num\", std::make_shared<DataTypeUInt32>()), /// deprecated\n     };\n }\ndiff --git a/src/Storages/StorageLog.cpp b/src/Storages/StorageLog.cpp\nindex ab795a2d04c3..cf76f7a16baf 100644\n--- a/src/Storages/StorageLog.cpp\n+++ b/src/Storages/StorageLog.cpp\n@@ -33,6 +33,7 @@\n #include <Backups/IBackup.h>\n #include <Backups/RestorerFromBackup.h>\n #include <Disks/TemporaryFileOnDisk.h>\n+#include <Storages/BlockNumberColumn.h>\n \n #include <cassert>\n #include <chrono>\n@@ -45,6 +46,8 @@\n namespace DB\n {\n \n+    CompressionCodecPtr getCompressionCodecDelta(UInt8 delta_bytes_size);\n+\n namespace ErrorCodes\n {\n     extern const int TIMEOUT_EXCEEDED;\n@@ -452,10 +455,15 @@ void LogSink::writeData(const NameAndTypePair & name_and_type, const IColumn & c\n             const auto & data_file = *data_file_it->second;\n             const auto & columns = metadata_snapshot->getColumns();\n \n+            CompressionCodecPtr compression;\n+            if (name_and_type.name == BlockNumberColumn::name)\n+                compression = BlockNumberColumn::compression_codec;\n+            else\n+                compression = columns.getCodecOrDefault(name_and_type.name);\n+\n             it = streams.try_emplace(data_file.name, storage.disk, data_file.path,\n                                      storage.file_checker.getFileSize(data_file.path),\n-                                     columns.getCodecOrDefault(name_and_type.name),\n-                                     storage.max_compress_block_size).first;\n+                                     compression, storage.max_compress_block_size).first;\n         }\n \n         auto & stream = it->second;\ndiff --git a/src/Storages/StorageSnapshot.cpp b/src/Storages/StorageSnapshot.cpp\nindex c0e859007943..0c19634f50c2 100644\n--- a/src/Storages/StorageSnapshot.cpp\n+++ b/src/Storages/StorageSnapshot.cpp\n@@ -1,5 +1,6 @@\n #include <Storages/StorageSnapshot.h>\n #include <Storages/LightweightDeleteDescription.h>\n+#include <Storages/BlockNumberColumn.h>\n #include <Storages/IStorage.h>\n #include <DataTypes/ObjectUtils.h>\n #include <DataTypes/NestedUtils.h>\n@@ -24,6 +25,7 @@ void StorageSnapshot::init()\n \n     if (storage.hasLightweightDeletedMask())\n         system_columns[LightweightDeleteDescription::FILTER_COLUMN.name] = LightweightDeleteDescription::FILTER_COLUMN.type;\n+    system_columns[BlockNumberColumn::name] = BlockNumberColumn::type;\n }\n \n NamesAndTypesList StorageSnapshot::getColumns(const GetColumnsOptions & options) const\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02668_column_block_number.reference b/tests/queries/0_stateless/02668_column_block_number.reference\nnew file mode 100644\nindex 000000000000..f08220243ff9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number.reference\n@@ -0,0 +1,41 @@\n+*** BEFORE MUTATION BEFORE MERGE ***\n+1\t1\t1\tall_1_1_0\n+2\t2\t1\tall_1_1_0\n+3\t3\t1\tall_1_1_0\n+4\t4\t2\tall_2_2_0\n+5\t5\t2\tall_2_2_0\n+6\t6\t2\tall_2_2_0\n+*** AFTER MUTATION BEFORE MERGE ***\n+1\t0\t1\tall_1_1_0_3\n+2\t0\t1\tall_1_1_0_3\n+3\t0\t1\tall_1_1_0_3\n+4\t4\t2\tall_2_2_0_3\n+5\t5\t2\tall_2_2_0_3\n+6\t6\t2\tall_2_2_0_3\n+*** AFTER MUTATION AFTER MERGE ***\n+1\t0\t1\tall_1_2_1_3\n+2\t0\t1\tall_1_2_1_3\n+3\t0\t1\tall_1_2_1_3\n+4\t4\t2\tall_1_2_1_3\n+5\t5\t2\tall_1_2_1_3\n+6\t6\t2\tall_1_2_1_3\n+*** AFTER MUTATION AFTER MERGE , NEW BLOCK ***\n+1\t0\t1\tall_1_2_1_3\n+2\t0\t1\tall_1_2_1_3\n+3\t0\t1\tall_1_2_1_3\n+4\t4\t2\tall_1_2_1_3\n+5\t5\t2\tall_1_2_1_3\n+6\t6\t2\tall_1_2_1_3\n+7\t7\t4\tall_4_4_0\n+8\t8\t4\tall_4_4_0\n+9\t9\t4\tall_4_4_0\n+*** AFTER MUTATION AFTER MERGE , NEW BLOCK MERGED ***\n+1\t0\t1\tall_1_4_2_3\n+2\t0\t1\tall_1_4_2_3\n+3\t0\t1\tall_1_4_2_3\n+4\t4\t2\tall_1_4_2_3\n+5\t5\t2\tall_1_4_2_3\n+6\t6\t2\tall_1_4_2_3\n+7\t7\t4\tall_1_4_2_3\n+8\t8\t4\tall_1_4_2_3\n+9\t9\t4\tall_1_4_2_3\ndiff --git a/tests/queries/0_stateless/02668_column_block_number.sql b/tests/queries/0_stateless/02668_column_block_number.sql\nnew file mode 100644\nindex 000000000000..4d4d54bba5fa\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number.sql\n@@ -0,0 +1,32 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (id UInt32, a UInt32) ENGINE = MergeTree ORDER BY id SETTINGS allow_experimental_block_number_column = true;\n+\n+INSERT INTO test(id,a) VALUES (1,1),(2,2),(3,3);\n+INSERT INTO test(id,a) VALUES (4,4),(5,5),(6,6);\n+\n+SELECT '*** BEFORE MUTATION BEFORE MERGE ***';\n+SELECT id,a,_block_number,_part from test ORDER BY id;\n+\n+set mutations_sync=1;\n+ALTER TABLE test UPDATE a=0 WHERE id<4;\n+\n+SELECT '*** AFTER MUTATION BEFORE MERGE ***';\n+SELECT id,a,_block_number,_part from test ORDER BY id;\n+\n+OPTIMIZE TABLE test FINAL;\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+INSERT INTO test(id,a) VALUES (7,7),(8,8),(9,9);\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE , NEW BLOCK ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+OPTIMIZE TABLE test FINAL;\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE , NEW BLOCK MERGED ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+DROP TABLE test;\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02668_column_block_number_vertical_merge.reference b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.reference\nnew file mode 100644\nindex 000000000000..f08220243ff9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.reference\n@@ -0,0 +1,41 @@\n+*** BEFORE MUTATION BEFORE MERGE ***\n+1\t1\t1\tall_1_1_0\n+2\t2\t1\tall_1_1_0\n+3\t3\t1\tall_1_1_0\n+4\t4\t2\tall_2_2_0\n+5\t5\t2\tall_2_2_0\n+6\t6\t2\tall_2_2_0\n+*** AFTER MUTATION BEFORE MERGE ***\n+1\t0\t1\tall_1_1_0_3\n+2\t0\t1\tall_1_1_0_3\n+3\t0\t1\tall_1_1_0_3\n+4\t4\t2\tall_2_2_0_3\n+5\t5\t2\tall_2_2_0_3\n+6\t6\t2\tall_2_2_0_3\n+*** AFTER MUTATION AFTER MERGE ***\n+1\t0\t1\tall_1_2_1_3\n+2\t0\t1\tall_1_2_1_3\n+3\t0\t1\tall_1_2_1_3\n+4\t4\t2\tall_1_2_1_3\n+5\t5\t2\tall_1_2_1_3\n+6\t6\t2\tall_1_2_1_3\n+*** AFTER MUTATION AFTER MERGE , NEW BLOCK ***\n+1\t0\t1\tall_1_2_1_3\n+2\t0\t1\tall_1_2_1_3\n+3\t0\t1\tall_1_2_1_3\n+4\t4\t2\tall_1_2_1_3\n+5\t5\t2\tall_1_2_1_3\n+6\t6\t2\tall_1_2_1_3\n+7\t7\t4\tall_4_4_0\n+8\t8\t4\tall_4_4_0\n+9\t9\t4\tall_4_4_0\n+*** AFTER MUTATION AFTER MERGE , NEW BLOCK MERGED ***\n+1\t0\t1\tall_1_4_2_3\n+2\t0\t1\tall_1_4_2_3\n+3\t0\t1\tall_1_4_2_3\n+4\t4\t2\tall_1_4_2_3\n+5\t5\t2\tall_1_4_2_3\n+6\t6\t2\tall_1_4_2_3\n+7\t7\t4\tall_1_4_2_3\n+8\t8\t4\tall_1_4_2_3\n+9\t9\t4\tall_1_4_2_3\ndiff --git a/tests/queries/0_stateless/02668_column_block_number_vertical_merge.sql b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.sql\nnew file mode 100644\nindex 000000000000..a32060efae1e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.sql\n@@ -0,0 +1,36 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (id UInt32, a UInt32) ENGINE = MergeTree ORDER BY id SETTINGS allow_experimental_block_number_column = true,\n+    vertical_merge_algorithm_min_rows_to_activate = 1,\n+    vertical_merge_algorithm_min_columns_to_activate = 0,\n+    min_rows_for_wide_part = 1,\n+    min_bytes_for_wide_part = 1;\n+\n+INSERT INTO test(id,a) VALUES (1,1),(2,2),(3,3);\n+INSERT INTO test(id,a) VALUES (4,4),(5,5),(6,6);\n+\n+SELECT '*** BEFORE MUTATION BEFORE MERGE ***';\n+SELECT id,a,_block_number,_part from test ORDER BY id;\n+\n+set mutations_sync=1;\n+ALTER TABLE test UPDATE a=0 WHERE id<4;\n+\n+SELECT '*** AFTER MUTATION BEFORE MERGE ***';\n+SELECT id,a,_block_number,_part from test ORDER BY id;\n+\n+OPTIMIZE TABLE test FINAL;\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+INSERT INTO test(id,a) VALUES (7,7),(8,8),(9,9);\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE , NEW BLOCK ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+OPTIMIZE TABLE test FINAL;\n+\n+SELECT '*** AFTER MUTATION AFTER MERGE , NEW BLOCK MERGED ***';\n+SELECT *,_block_number,_part from test ORDER BY id;\n+\n+DROP TABLE test;\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02668_column_block_number_with_projections.reference b/tests/queries/0_stateless/02668_column_block_number_with_projections.reference\nnew file mode 100644\nindex 000000000000..289a21035b57\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number_with_projections.reference\n@@ -0,0 +1,19 @@\n+0\n+1\n+2\n+3\n+*** AFTER FIRST OPTIMIZE ***\n+0\t1\n+1\t2\n+1\t2\n+2\t3\n+3\t3\n+*** AFTER SECOND OPTIMIZE ***\n+0\t1\n+1\t2\n+1\t2\n+2\t3\n+3\t3\n+4\t4\n+5\t4\n+6\t4\ndiff --git a/tests/queries/0_stateless/02668_column_block_number_with_projections.sql b/tests/queries/0_stateless/02668_column_block_number_with_projections.sql\nnew file mode 100644\nindex 000000000000..25ec411967b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02668_column_block_number_with_projections.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t (x UInt8, PROJECTION p (SELECT x GROUP BY x)) ENGINE = MergeTree ORDER BY () SETTINGS allow_experimental_block_number_column=true;\n+INSERT INTO t VALUES (0);\n+INSERT INTO t VALUES (1),(1);\n+INSERT INTO t VALUES (2),(3);\n+\n+SELECT x FROM t GROUP BY x;\n+OPTIMIZE TABLE t FINAL;\n+\n+SELECT '*** AFTER FIRST OPTIMIZE ***';\n+SELECT x,_block_number FROM t;\n+\n+INSERT INTO t VALUES (4), (5), (6);\n+OPTIMIZE TABLE t FINAL;\n+SELECT '*** AFTER SECOND OPTIMIZE ***';\n+SELECT x,_block_number FROM t;\n+\n+DROP TABLE t;\n\\ No newline at end of file\n",
  "problem_statement": "Persistent virtual column `_block_number`\n> (you don't have to strictly follow this form)\r\n\r\nA lot of usecases for debugging and introspection.\r\n\r\n> A clear and concise description of what is the intended usage scenario is.\r\n\r\nThanks to @davenger we have some basic infrastructure for persistent virtual columns. First example is `_row_exists` column. We need to implement `_block_number` column which will be hidden by default, but can be queried any time with explicit name in `SELECT` query. Serialization of the column should be optional (with setting).\n",
  "hints_text": "It will also help for https://github.com/ClickHouse/ClickHouse/issues/42990\nAdditional comments:\r\n1. Code where we write fresh inserts to disk: ordinary StorageMergeTree: https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/MergeTreeSink.cpp#L56, StorageReplicatedMergeTree: https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp#L296.\r\n2. Base class for managing data parts: https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/MergeTreeData.cpp\r\n3. StorageMergeTree + block number allocation https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/StorageMergeTree.cpp#L2010-L2012\r\nBut I got an interesting thought: Maybe we can avoid touching initial writing code (Sinks for INSERT queries), because we always can restore `_block_number` from zero-level parts name, like `202010_5_5_0` or `all_9999_9999_0`.\r\n\r\nFor non-zero-level parts we should persist this column during Merges and Mutations. Corresponding code can be found in:\r\n1. MergerMutator: https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp#L514-L581\r\n2. MergeTask and MutateTask.\r\nSo what we can do:\r\n1. For zero level parts `_block_number` is pure virtual column. It's not stored on disk (serialized) and when user query it -- we calculate it on fly from part name.\r\n2. During merge we materialize `_block_number` unconditionally.\r\n\r\nSo maybe it will be possible to implement `_block_number` support on IMergeTreeDataPart level?\nAlso please consider automatically applying `Delta` codec to that column (so it will compress perfectly)\nWhy we need to persistent it, we can just get it from part_info?",
  "created_at": "2023-03-13T13:15:36Z",
  "modified_files": [
    "docs/en/engines/table-engines/mergetree-family/mergetree.md",
    "docs/en/operations/settings/merge-tree-settings.md",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Interpreters/MutationsInterpreter.cpp",
    "src/Interpreters/inplaceBlockConversions.cpp",
    "src/Interpreters/inplaceBlockConversions.h",
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp",
    "src/Processors/Transforms/TTLTransform.cpp",
    "src/Storages/AlterCommands.cpp",
    "b/src/Storages/BlockNumberColumn.cpp",
    "b/src/Storages/BlockNumberColumn.h",
    "src/Storages/ColumnsDescription.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.h",
    "src/Storages/MergeTree/IMergeTreeReader.cpp",
    "src/Storages/MergeTree/IMergeTreeReader.h",
    "src/Storages/MergeTree/MergeTask.cpp",
    "src/Storages/MergeTree/MergeTask.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartCompact.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp",
    "src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/MergeTree/MergeTreeSelectProcessor.cpp",
    "src/Storages/MergeTree/MergeTreeSequentialSource.cpp",
    "src/Storages/MergeTree/MergeTreeSettings.h",
    "src/Storages/StorageDistributed.cpp",
    "src/Storages/StorageLog.cpp",
    "src/Storages/StorageSnapshot.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02668_column_block_number.reference",
    "b/tests/queries/0_stateless/02668_column_block_number.sql",
    "b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.reference",
    "b/tests/queries/0_stateless/02668_column_block_number_vertical_merge.sql",
    "b/tests/queries/0_stateless/02668_column_block_number_with_projections.reference",
    "b/tests/queries/0_stateless/02668_column_block_number_with_projections.sql"
  ]
}