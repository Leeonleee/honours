{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63487,
  "instance_id": "ClickHouse__ClickHouse-63487",
  "issue_numbers": [
    "58843"
  ],
  "base_commit": "dc7f51594532fd8720901c92797dad8a26cf4252",
  "patch": "diff --git a/docs/en/operations/system-tables/query_log.md b/docs/en/operations/system-tables/query_log.md\nindex d48eb31df000..75b855966a31 100644\n--- a/docs/en/operations/system-tables/query_log.md\n+++ b/docs/en/operations/system-tables/query_log.md\n@@ -108,7 +108,7 @@ Columns:\n - `used_aggregate_function_combinators` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `aggregate functions combinators`, which were used during query execution.\n - `used_database_engines` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `database engines`, which were used during query execution.\n - `used_data_type_families` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `data type families`, which were used during query execution.\n-- `used_dictionaries` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `dictionaries`, which were used during query execution.\n+- `used_dictionaries` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `dictionaries`, which were used during query execution. For dictionaries configured using an XML file this is the name of the dictionary, and for dictionaries created by an SQL statement, the canonical name is the fully qualified object name.\n - `used_formats` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `formats`, which were used during query execution.\n - `used_functions` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `functions`, which were used during query execution.\n - `used_storages` ([Array(String)](../../sql-reference/data-types/array.md)) \u2014 Canonical names of `storages`, which were used during query execution.\ndiff --git a/src/Dictionaries/IDictionary.h b/src/Dictionaries/IDictionary.h\nindex bab80d3cd57c..944e00f14c9f 100644\n--- a/src/Dictionaries/IDictionary.h\n+++ b/src/Dictionaries/IDictionary.h\n@@ -69,6 +69,15 @@ class IDictionary : public IExternalLoadable, public IKeyValueEntity\n         return dictionary_id.getNameForLogs();\n     }\n \n+    /// Returns fully qualified unquoted dictionary name\n+    std::string getQualifiedName() const\n+    {\n+        std::lock_guard lock{mutex};\n+        if (dictionary_id.database_name.empty())\n+            return dictionary_id.table_name;\n+        return dictionary_id.database_name + \".\" + dictionary_id.table_name;\n+    }\n+\n     StorageID getDictionaryID() const\n     {\n         std::lock_guard lock{mutex};\ndiff --git a/src/Interpreters/ExternalDictionariesLoader.cpp b/src/Interpreters/ExternalDictionariesLoader.cpp\nindex f48ee61dab8e..1685c06d3872 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.cpp\n+++ b/src/Interpreters/ExternalDictionariesLoader.cpp\n@@ -77,21 +77,23 @@ void ExternalDictionariesLoader::updateObjectFromConfigWithoutReloading(IExterna\n ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::getDictionary(const std::string & dictionary_name, ContextPtr local_context) const\n {\n     std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, local_context->getCurrentDatabase());\n+    auto dictionary = std::static_pointer_cast<const IDictionary>(load(resolved_dictionary_name));\n \n     if (local_context->hasQueryContext() && local_context->getSettingsRef().log_queries)\n-        local_context->addQueryFactoriesInfo(Context::QueryLogFactories::Dictionary, resolved_dictionary_name);\n+        local_context->getQueryContext()->addQueryFactoriesInfo(Context::QueryLogFactories::Dictionary, dictionary->getQualifiedName());\n \n-    return std::static_pointer_cast<const IDictionary>(load(resolved_dictionary_name));\n+    return dictionary;\n }\n \n ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::tryGetDictionary(const std::string & dictionary_name, ContextPtr local_context) const\n {\n     std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, local_context->getCurrentDatabase());\n+    auto dictionary = std::static_pointer_cast<const IDictionary>(tryLoad(resolved_dictionary_name));\n \n-    if (local_context->hasQueryContext() && local_context->getSettingsRef().log_queries)\n-        local_context->addQueryFactoriesInfo(Context::QueryLogFactories::Dictionary, resolved_dictionary_name);\n+    if (local_context->hasQueryContext() && local_context->getSettingsRef().log_queries && dictionary)\n+        local_context->getQueryContext()->addQueryFactoriesInfo(Context::QueryLogFactories::Dictionary, dictionary->getQualifiedName());\n \n-    return std::static_pointer_cast<const IDictionary>(tryLoad(resolved_dictionary_name));\n+    return dictionary;\n }\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03148_query_log_used_dictionaries.reference b/tests/queries/0_stateless/03148_query_log_used_dictionaries.reference\nnew file mode 100644\nindex 000000000000..4fa3a14e63f7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03148_query_log_used_dictionaries.reference\n@@ -0,0 +1,4 @@\n+simple_with_analyzer\t['default.03148_dictionary']\n+nested_with_analyzer\t['default.03148_dictionary']\n+simple_without_analyzer\t['default.03148_dictionary']\n+nested_without_analyzer\t['default.03148_dictionary']\ndiff --git a/tests/queries/0_stateless/03148_query_log_used_dictionaries.sql b/tests/queries/0_stateless/03148_query_log_used_dictionaries.sql\nnew file mode 100644\nindex 000000000000..1b647a7ee627\n--- /dev/null\n+++ b/tests/queries/0_stateless/03148_query_log_used_dictionaries.sql\n@@ -0,0 +1,84 @@\n+DROP DICTIONARY IF EXISTS 03148_dictionary;\n+\n+CREATE DICTIONARY 03148_dictionary (\n+    id UInt64,\n+    name String\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(\n+    QUERY 'select 0 as id, ''name0'' as name'\n+))\n+LIFETIME(MIN 1 MAX 10)\n+LAYOUT(HASHED);\n+\n+SELECT\n+    dictGet('03148_dictionary', 'name', number) as dict_value\n+FROM numbers(1)\n+SETTINGS\n+    allow_experimental_analyzer = 1,\n+    log_comment = 'simple_with_analyzer'\n+FORMAT Null;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT log_comment, used_dictionaries\n+FROM system.query_log\n+WHERE current_database = currentDatabase()\n+  AND type = 'QueryFinish'\n+  AND log_comment = 'simple_with_analyzer';\n+\n+SELECT *\n+FROM (\n+    SELECT\n+        dictGet('03148_dictionary', 'name', number) as dict_value\n+    FROM numbers(1)\n+) t\n+SETTINGS\n+    allow_experimental_analyzer = 1,\n+    log_comment = 'nested_with_analyzer'\n+FORMAT Null;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT log_comment, used_dictionaries\n+FROM system.query_log\n+WHERE current_database = currentDatabase()\n+  AND type = 'QueryFinish'\n+  AND log_comment = 'nested_with_analyzer';\n+\n+SELECT\n+    dictGet('03148_dictionary', 'name', number) as dict_value\n+FROM numbers(1)\n+SETTINGS\n+    allow_experimental_analyzer = 0,\n+    log_comment = 'simple_without_analyzer'\n+FORMAT Null;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT log_comment, used_dictionaries\n+FROM system.query_log\n+WHERE current_database = currentDatabase()\n+  AND type = 'QueryFinish'\n+  AND log_comment = 'simple_without_analyzer';\n+\n+SELECT *\n+FROM (\n+    SELECT\n+        dictGet('03148_dictionary', 'name', number) as dict_value\n+    FROM numbers(1)\n+) t\n+SETTINGS\n+    allow_experimental_analyzer = 0,\n+    log_comment = 'nested_without_analyzer'\n+FORMAT Null;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT log_comment, used_dictionaries\n+FROM system.query_log\n+WHERE current_database = currentDatabase()\n+  AND type = 'QueryFinish'\n+  AND log_comment = 'nested_without_analyzer';\n+\n+DROP DICTIONARY IF EXISTS 03148_dictionary;\n",
  "problem_statement": "empty array in system.query_log.used_dictionaries \n**Describe what's wrong**\r\n\r\nWhen using the dictGet function in a subquery, the used_dictionaries column in table system.query_log will return an empty array.\r\n\r\n**Does it reproduce on recent release?**\r\nYes\r\n\r\n**How to reproduce**\r\n\r\n```\r\ncreate or replace dictionary test (id UInt64, name String)\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(QUERY 'select number as id, ''#'' || toString(id) as name from numbers(10)'))\r\nLIFETIME(0)\r\nLAYOUT(HASHED);\r\n\r\n\r\nselect number, val\r\n  from(\r\nselect number, dictGet('test', 'name', number) as val\r\n  from numbers(10)) t;\r\n\r\nSYSTEM FLUSH LOGS;\r\n\r\nselect used_dictionaries, used_functions, query, type\r\n  from system.query_log\r\n\r\nused_dictionaries: []\r\nused_functions:    ['dictGet']\r\nquery:             select number, val\r\n  from(\r\nselect number, dictGet('test', 'name', number) as val\r\n  from numbers(10)) t\r\ntype:              QueryFinish\r\n```\r\n* Which ClickHouse server version to use\r\n   23.12.2.59\r\n\r\n**Expected behavior**\r\n    column used_dictionaries returns array of canonical names of dictionaries, which were used during query execution\r\n\r\n\n",
  "hints_text": "Still an issue in master. The dictionary is not reported as accessed in system.query_log",
  "created_at": "2024-05-07T18:16:52Z"
}