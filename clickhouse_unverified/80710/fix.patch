diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md
index 838f960c7ad3..2d7c133f4152 100644
--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md
+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md
@@ -527,7 +527,7 @@ Determines the lifetime of values.
 
 The `TTL` clause can be set for the whole table and for each individual column. Table-level `TTL` can also specify the logic of automatic moving data between disks and volumes, or recompressing parts where all the data has been expired.
 
-Expressions must evaluate to [Date](/sql-reference/data-types/date.md) or [DateTime](/sql-reference/data-types/datetime.md) data type.
+Expressions must evaluate to [Date](/sql-reference/data-types/date.md), [Date32](/sql-reference/data-types/date32.md), [DateTime](/sql-reference/data-types/datetime.md) or [DateTime64](/sql-reference/data-types/datetime64.md) data type.
 
 **Syntax**
 
diff --git a/src/Processors/TTL/ITTLAlgorithm.cpp b/src/Processors/TTL/ITTLAlgorithm.cpp
index 4d0aa6dc1adc..7ef361444a04 100644
--- a/src/Processors/TTL/ITTLAlgorithm.cpp
+++ b/src/Processors/TTL/ITTLAlgorithm.cpp
@@ -4,6 +4,8 @@
 #include <Common/DateLUTImpl.h>
 #include <Interpreters/ExpressionActions.h>
 
+#include <Columns/ColumnsDateTime.h>
+
 namespace DB
 {
 
@@ -48,18 +50,26 @@ ColumnPtr ITTLAlgorithm::executeExpressionAndGetColumn(
     return block_copy.getByName(result_column).column;
 }
 
-UInt32 ITTLAlgorithm::getTimestampByIndex(const IColumn * column, size_t index) const
+Int64 ITTLAlgorithm::getTimestampByIndex(const IColumn * column, size_t index) const
 {
     if (const ColumnUInt16 * column_date = typeid_cast<const ColumnUInt16 *>(column))
-        return static_cast<UInt32>(date_lut.fromDayNum(DayNum(column_date->getData()[index])));
+        return date_lut.fromDayNum(DayNum(column_date->getData()[index]));
     if (const ColumnUInt32 * column_date_time = typeid_cast<const ColumnUInt32 *>(column))
         return column_date_time->getData()[index];
+    if (const ColumnInt32 * column_date_32 = typeid_cast<const ColumnInt32 *>(column))
+        return date_lut.fromDayNum(ExtendedDayNum(column_date_32->getData()[index]));
+    if (const ColumnDateTime64 * column_date_time_64 = typeid_cast<const ColumnDateTime64 *>(column))
+        return column_date_time_64->getData()[index] / intExp10OfSize<Int64>(column_date_time_64->getScale());
     if (const ColumnConst * column_const = typeid_cast<const ColumnConst *>(column))
     {
         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))
-            return static_cast<UInt32>(date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>())));
+            return date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>()));
         if (typeid_cast<const ColumnUInt32 *>(&column_const->getDataColumn()))
             return column_const->getValue<UInt32>();
+        if (typeid_cast<const ColumnInt32 *>(&column_const->getDataColumn()))
+            return date_lut.fromDayNum(ExtendedDayNum(column_const->getValue<Int32>()));
+        if (const ColumnDateTime64 * column_dt64 = typeid_cast<const ColumnDateTime64 *>(&column_const->getDataColumn()))
+            return column_const->getValue<DateTime64>() / intExp10OfSize<Int64>(column_dt64->getScale());
     }
 
     throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected type of result TTL column");
diff --git a/src/Processors/TTL/ITTLAlgorithm.h b/src/Processors/TTL/ITTLAlgorithm.h
index d79aa8a8dfcf..542f93d6ffe6 100644
--- a/src/Processors/TTL/ITTLAlgorithm.h
+++ b/src/Processors/TTL/ITTLAlgorithm.h
@@ -43,7 +43,7 @@ class ITTLAlgorithm
 
 protected:
     bool isTTLExpired(time_t ttl) const;
-    UInt32 getTimestampByIndex(const IColumn * column, size_t index) const;
+    Int64 getTimestampByIndex(const IColumn * column, size_t index) const;
 
     const TTLExpressions ttl_expressions;
     const TTLDescription description;
diff --git a/src/Processors/TTL/TTLAggregationAlgorithm.cpp b/src/Processors/TTL/TTLAggregationAlgorithm.cpp
index 43f0eafc8da5..140d2a28b745 100644
--- a/src/Processors/TTL/TTLAggregationAlgorithm.cpp
+++ b/src/Processors/TTL/TTLAggregationAlgorithm.cpp
@@ -103,7 +103,7 @@ void TTLAggregationAlgorithm::execute(Block & block)
 
         for (size_t i = 0; i < block.rows(); ++i)
         {
-            UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
+            Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
             bool where_filter_passed = !where_column || where_column->getBool(i);
             bool ttl_expired = isTTLExpired(cur_ttl) && where_filter_passed;
 
diff --git a/src/Processors/TTL/TTLColumnAlgorithm.cpp b/src/Processors/TTL/TTLColumnAlgorithm.cpp
index e27050564cee..4b8f6b6f9ba2 100644
--- a/src/Processors/TTL/TTLColumnAlgorithm.cpp
+++ b/src/Processors/TTL/TTLColumnAlgorithm.cpp
@@ -59,7 +59,7 @@ void TTLColumnAlgorithm::execute(Block & block)
 
     for (size_t i = 0; i < block.rows(); ++i)
     {
-        UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
+        Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
         if (isTTLExpired(cur_ttl))
         {
             if (default_column)
diff --git a/src/Processors/TTL/TTLDeleteAlgorithm.cpp b/src/Processors/TTL/TTLDeleteAlgorithm.cpp
index 6f9bc315276f..fde1d7c51d54 100644
--- a/src/Processors/TTL/TTLDeleteAlgorithm.cpp
+++ b/src/Processors/TTL/TTLDeleteAlgorithm.cpp
@@ -34,7 +34,7 @@ void TTLDeleteAlgorithm::execute(Block & block)
 
         for (size_t i = 0; i < block.rows(); ++i)
         {
-            UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
+            Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);
             bool where_filter_passed = !where_column || where_column->getBool(i);
 
             if (!isTTLExpired(cur_ttl) || !where_filter_passed)
diff --git a/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp b/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp
index 13d3030bbb87..e27698e7cb44 100644
--- a/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp
+++ b/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp
@@ -25,7 +25,7 @@ void TTLUpdateInfoAlgorithm::execute(Block & block)
     auto ttl_column = executeExpressionAndGetColumn(ttl_expressions.expression, block, description.result_column);
     for (size_t i = 0; i < block.rows(); ++i)
     {
-        UInt32 cur_ttl = ITTLAlgorithm::getTimestampByIndex(ttl_column.get(), i);
+        Int64 cur_ttl = ITTLAlgorithm::getTimestampByIndex(ttl_column.get(), i);
         new_ttl_info.update(cur_ttl);
     }
 }
diff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
index 9242a8f29e33..76614490b193 100644
--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
@@ -1,5 +1,7 @@
 #include <Columns/ColumnConst.h>
+#include <Columns/ColumnsDateTime.h>
 #include <Common/DateLUTImpl.h>
+#include <Common/intExp.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/ObjectUtils.h>
@@ -184,6 +186,17 @@ void updateTTL(
         for (const auto & val : column_date_time->getData())
             ttl_info.update(val);
     }
+    else if (const ColumnInt32 * column_date_32 = typeid_cast<const ColumnInt32 *>(ttl_column.get()))
+    {
+        const auto & date_lut = DateLUT::serverTimezoneInstance();
+        for (const auto & val : column_date_32->getData())
+            ttl_info.update(date_lut.fromDayNum(ExtendedDayNum(val)));
+    }
+    else if (const ColumnDateTime64 * column_date_time_64 = typeid_cast<const ColumnDateTime64 *>(ttl_column.get()))
+    {
+        for (const auto & val : column_date_time_64->getData())
+            ttl_info.update(val / intExp10OfSize<Int64>(column_date_time_64->getScale()));
+    }
     else if (const ColumnConst * column_const = typeid_cast<const ColumnConst *>(ttl_column.get()))
     {
         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))
@@ -195,6 +208,15 @@ void updateTTL(
         {
             ttl_info.update(column_const->getValue<UInt32>());
         }
+        else if (typeid_cast<const ColumnInt32 *>(&column_const->getDataColumn()))
+        {
+            const auto & date_lut = DateLUT::serverTimezoneInstance();
+            ttl_info.update(date_lut.fromDayNum(ExtendedDayNum(column_const->getValue<Int32>())));
+        }
+        else if (const ColumnDateTime64 * column_dt64 = typeid_cast<const ColumnDateTime64 *>(&column_const->getDataColumn()))
+        {
+            ttl_info.update(column_const->getValue<DateTime64>() / intExp10OfSize<Int64>(column_dt64->getScale()));
+        }
         else
             throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected type of result TTL column");
     }
diff --git a/src/Storages/TTLDescription.cpp b/src/Storages/TTLDescription.cpp
index c279d2ca98c2..d645c527ead9 100644
--- a/src/Storages/TTLDescription.cpp
+++ b/src/Storages/TTLDescription.cpp
@@ -17,7 +17,9 @@
 #include <Interpreters/Context.h>
 
 #include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDate32.h>
 #include <DataTypes/DataTypeDateTime.h>
+#include <DataTypes/DataTypeDateTime64.h>
 #include <Interpreters/FunctionNameNormalizer.h>
 #include <Parsers/ExpressionListParsers.h>
 #include <Parsers/parseQuery.h>
@@ -90,10 +92,12 @@ void checkTTLExpression(const ExpressionActionsPtr & ttl_expression, const Strin
 
     const auto & result_column = ttl_expression->getSampleBlock().getByName(result_column_name);
     if (!typeid_cast<const DataTypeDateTime *>(result_column.type.get())
-        && !typeid_cast<const DataTypeDate *>(result_column.type.get()))
+        && !typeid_cast<const DataTypeDate *>(result_column.type.get())
+        && !typeid_cast<const DataTypeDateTime64 *>(result_column.type.get())
+        && !typeid_cast<const DataTypeDate32 *>(result_column.type.get()))
     {
         throw Exception(ErrorCodes::BAD_TTL_EXPRESSION,
-                        "TTL expression result column should have DateTime or Date type, but has {}",
+                        "TTL expression result column should have Date, Date32, DateTime or DateTime64 type, but has {}",
                         result_column.type->getName());
     }
 }
