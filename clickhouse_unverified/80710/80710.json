{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80710,
  "instance_id": "ClickHouse__ClickHouse-80710",
  "issue_numbers": [
    "80587"
  ],
  "base_commit": "23ab564be4ae819c21970b3727c7bd8ac4d56943",
  "patch": "diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md\nindex 838f960c7ad3..2d7c133f4152 100644\n--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md\n+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md\n@@ -527,7 +527,7 @@ Determines the lifetime of values.\n \n The `TTL` clause can be set for the whole table and for each individual column. Table-level `TTL` can also specify the logic of automatic moving data between disks and volumes, or recompressing parts where all the data has been expired.\n \n-Expressions must evaluate to [Date](/sql-reference/data-types/date.md) or [DateTime](/sql-reference/data-types/datetime.md) data type.\n+Expressions must evaluate to [Date](/sql-reference/data-types/date.md), [Date32](/sql-reference/data-types/date32.md), [DateTime](/sql-reference/data-types/datetime.md) or [DateTime64](/sql-reference/data-types/datetime64.md) data type.\n \n **Syntax**\n \ndiff --git a/src/Processors/TTL/ITTLAlgorithm.cpp b/src/Processors/TTL/ITTLAlgorithm.cpp\nindex 4d0aa6dc1adc..7ef361444a04 100644\n--- a/src/Processors/TTL/ITTLAlgorithm.cpp\n+++ b/src/Processors/TTL/ITTLAlgorithm.cpp\n@@ -4,6 +4,8 @@\n #include <Common/DateLUTImpl.h>\n #include <Interpreters/ExpressionActions.h>\n \n+#include <Columns/ColumnsDateTime.h>\n+\n namespace DB\n {\n \n@@ -48,18 +50,26 @@ ColumnPtr ITTLAlgorithm::executeExpressionAndGetColumn(\n     return block_copy.getByName(result_column).column;\n }\n \n-UInt32 ITTLAlgorithm::getTimestampByIndex(const IColumn * column, size_t index) const\n+Int64 ITTLAlgorithm::getTimestampByIndex(const IColumn * column, size_t index) const\n {\n     if (const ColumnUInt16 * column_date = typeid_cast<const ColumnUInt16 *>(column))\n-        return static_cast<UInt32>(date_lut.fromDayNum(DayNum(column_date->getData()[index])));\n+        return date_lut.fromDayNum(DayNum(column_date->getData()[index]));\n     if (const ColumnUInt32 * column_date_time = typeid_cast<const ColumnUInt32 *>(column))\n         return column_date_time->getData()[index];\n+    if (const ColumnInt32 * column_date_32 = typeid_cast<const ColumnInt32 *>(column))\n+        return date_lut.fromDayNum(ExtendedDayNum(column_date_32->getData()[index]));\n+    if (const ColumnDateTime64 * column_date_time_64 = typeid_cast<const ColumnDateTime64 *>(column))\n+        return column_date_time_64->getData()[index] / intExp10OfSize<Int64>(column_date_time_64->getScale());\n     if (const ColumnConst * column_const = typeid_cast<const ColumnConst *>(column))\n     {\n         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))\n-            return static_cast<UInt32>(date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>())));\n+            return date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>()));\n         if (typeid_cast<const ColumnUInt32 *>(&column_const->getDataColumn()))\n             return column_const->getValue<UInt32>();\n+        if (typeid_cast<const ColumnInt32 *>(&column_const->getDataColumn()))\n+            return date_lut.fromDayNum(ExtendedDayNum(column_const->getValue<Int32>()));\n+        if (const ColumnDateTime64 * column_dt64 = typeid_cast<const ColumnDateTime64 *>(&column_const->getDataColumn()))\n+            return column_const->getValue<DateTime64>() / intExp10OfSize<Int64>(column_dt64->getScale());\n     }\n \n     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected type of result TTL column\");\ndiff --git a/src/Processors/TTL/ITTLAlgorithm.h b/src/Processors/TTL/ITTLAlgorithm.h\nindex d79aa8a8dfcf..542f93d6ffe6 100644\n--- a/src/Processors/TTL/ITTLAlgorithm.h\n+++ b/src/Processors/TTL/ITTLAlgorithm.h\n@@ -43,7 +43,7 @@ class ITTLAlgorithm\n \n protected:\n     bool isTTLExpired(time_t ttl) const;\n-    UInt32 getTimestampByIndex(const IColumn * column, size_t index) const;\n+    Int64 getTimestampByIndex(const IColumn * column, size_t index) const;\n \n     const TTLExpressions ttl_expressions;\n     const TTLDescription description;\ndiff --git a/src/Processors/TTL/TTLAggregationAlgorithm.cpp b/src/Processors/TTL/TTLAggregationAlgorithm.cpp\nindex 43f0eafc8da5..140d2a28b745 100644\n--- a/src/Processors/TTL/TTLAggregationAlgorithm.cpp\n+++ b/src/Processors/TTL/TTLAggregationAlgorithm.cpp\n@@ -103,7 +103,7 @@ void TTLAggregationAlgorithm::execute(Block & block)\n \n         for (size_t i = 0; i < block.rows(); ++i)\n         {\n-            UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n+            Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n             bool where_filter_passed = !where_column || where_column->getBool(i);\n             bool ttl_expired = isTTLExpired(cur_ttl) && where_filter_passed;\n \ndiff --git a/src/Processors/TTL/TTLColumnAlgorithm.cpp b/src/Processors/TTL/TTLColumnAlgorithm.cpp\nindex e27050564cee..4b8f6b6f9ba2 100644\n--- a/src/Processors/TTL/TTLColumnAlgorithm.cpp\n+++ b/src/Processors/TTL/TTLColumnAlgorithm.cpp\n@@ -59,7 +59,7 @@ void TTLColumnAlgorithm::execute(Block & block)\n \n     for (size_t i = 0; i < block.rows(); ++i)\n     {\n-        UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n+        Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n         if (isTTLExpired(cur_ttl))\n         {\n             if (default_column)\ndiff --git a/src/Processors/TTL/TTLDeleteAlgorithm.cpp b/src/Processors/TTL/TTLDeleteAlgorithm.cpp\nindex 6f9bc315276f..fde1d7c51d54 100644\n--- a/src/Processors/TTL/TTLDeleteAlgorithm.cpp\n+++ b/src/Processors/TTL/TTLDeleteAlgorithm.cpp\n@@ -34,7 +34,7 @@ void TTLDeleteAlgorithm::execute(Block & block)\n \n         for (size_t i = 0; i < block.rows(); ++i)\n         {\n-            UInt32 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n+            Int64 cur_ttl = getTimestampByIndex(ttl_column.get(), i);\n             bool where_filter_passed = !where_column || where_column->getBool(i);\n \n             if (!isTTLExpired(cur_ttl) || !where_filter_passed)\ndiff --git a/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp b/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp\nindex 13d3030bbb87..e27698e7cb44 100644\n--- a/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp\n+++ b/src/Processors/TTL/TTLUpdateInfoAlgorithm.cpp\n@@ -25,7 +25,7 @@ void TTLUpdateInfoAlgorithm::execute(Block & block)\n     auto ttl_column = executeExpressionAndGetColumn(ttl_expressions.expression, block, description.result_column);\n     for (size_t i = 0; i < block.rows(); ++i)\n     {\n-        UInt32 cur_ttl = ITTLAlgorithm::getTimestampByIndex(ttl_column.get(), i);\n+        Int64 cur_ttl = ITTLAlgorithm::getTimestampByIndex(ttl_column.get(), i);\n         new_ttl_info.update(cur_ttl);\n     }\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex 9242a8f29e33..76614490b193 100644\n--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -1,5 +1,7 @@\n #include <Columns/ColumnConst.h>\n+#include <Columns/ColumnsDateTime.h>\n #include <Common/DateLUTImpl.h>\n+#include <Common/intExp.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/ObjectUtils.h>\n@@ -184,6 +186,17 @@ void updateTTL(\n         for (const auto & val : column_date_time->getData())\n             ttl_info.update(val);\n     }\n+    else if (const ColumnInt32 * column_date_32 = typeid_cast<const ColumnInt32 *>(ttl_column.get()))\n+    {\n+        const auto & date_lut = DateLUT::serverTimezoneInstance();\n+        for (const auto & val : column_date_32->getData())\n+            ttl_info.update(date_lut.fromDayNum(ExtendedDayNum(val)));\n+    }\n+    else if (const ColumnDateTime64 * column_date_time_64 = typeid_cast<const ColumnDateTime64 *>(ttl_column.get()))\n+    {\n+        for (const auto & val : column_date_time_64->getData())\n+            ttl_info.update(val / intExp10OfSize<Int64>(column_date_time_64->getScale()));\n+    }\n     else if (const ColumnConst * column_const = typeid_cast<const ColumnConst *>(ttl_column.get()))\n     {\n         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))\n@@ -195,6 +208,15 @@ void updateTTL(\n         {\n             ttl_info.update(column_const->getValue<UInt32>());\n         }\n+        else if (typeid_cast<const ColumnInt32 *>(&column_const->getDataColumn()))\n+        {\n+            const auto & date_lut = DateLUT::serverTimezoneInstance();\n+            ttl_info.update(date_lut.fromDayNum(ExtendedDayNum(column_const->getValue<Int32>())));\n+        }\n+        else if (const ColumnDateTime64 * column_dt64 = typeid_cast<const ColumnDateTime64 *>(&column_const->getDataColumn()))\n+        {\n+            ttl_info.update(column_const->getValue<DateTime64>() / intExp10OfSize<Int64>(column_dt64->getScale()));\n+        }\n         else\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected type of result TTL column\");\n     }\ndiff --git a/src/Storages/TTLDescription.cpp b/src/Storages/TTLDescription.cpp\nindex c279d2ca98c2..d645c527ead9 100644\n--- a/src/Storages/TTLDescription.cpp\n+++ b/src/Storages/TTLDescription.cpp\n@@ -17,7 +17,9 @@\n #include <Interpreters/Context.h>\n \n #include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n #include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n@@ -90,10 +92,12 @@ void checkTTLExpression(const ExpressionActionsPtr & ttl_expression, const Strin\n \n     const auto & result_column = ttl_expression->getSampleBlock().getByName(result_column_name);\n     if (!typeid_cast<const DataTypeDateTime *>(result_column.type.get())\n-        && !typeid_cast<const DataTypeDate *>(result_column.type.get()))\n+        && !typeid_cast<const DataTypeDate *>(result_column.type.get())\n+        && !typeid_cast<const DataTypeDateTime64 *>(result_column.type.get())\n+        && !typeid_cast<const DataTypeDate32 *>(result_column.type.get()))\n     {\n         throw Exception(ErrorCodes::BAD_TTL_EXPRESSION,\n-                        \"TTL expression result column should have DateTime or Date type, but has {}\",\n+                        \"TTL expression result column should have Date, Date32, DateTime or DateTime64 type, but has {}\",\n                         result_column.type->getName());\n     }\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03519_ttl_extended_data_types.reference b/tests/queries/0_stateless/03519_ttl_extended_data_types.reference\nnew file mode 100644\nindex 000000000000..d098f930edc6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03519_ttl_extended_data_types.reference\n@@ -0,0 +1,8 @@\n+\"2170-01-01\",2170\n+\"2170-01-01 12:12:12.12345\",2170\n+\"1901-01-01\",\"\"\n+\"2010-01-01\",\"\"\n+\"2170-01-01\",\"uio\"\n+\"1901-01-01 12:12:12.12345\",\"\"\n+\"2010-01-01 12:12:12.00000\",\"\"\n+\"2170-01-01 12:12:12.12345\",\"uio\"\ndiff --git a/tests/queries/0_stateless/03519_ttl_extended_data_types.sql b/tests/queries/0_stateless/03519_ttl_extended_data_types.sql\nnew file mode 100644\nindex 000000000000..e7c7dcebe48b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03519_ttl_extended_data_types.sql\n@@ -0,0 +1,39 @@\n+-- Row TTL with extended data types\n+DROP TABLE IF EXISTS ttl_03519_1 SYNC;\n+CREATE TABLE ttl_03519_1 (date Date32, date_key Int) ENGINE=MergeTree TTL date + INTERVAL 1 MONTH ORDER BY date;\n+INSERT INTO ttl_03519_1 VALUES ('2010-01-01', 2010);\n+INSERT INTO ttl_03519_1 VALUES ('1901-01-01', 1901);\n+INSERT INTO ttl_03519_1 VALUES ('2170-01-01', 2170);\n+OPTIMIZE TABLE ttl_03519_1 FINAL;\n+SELECT * FROM ttl_03519_1 ORDER BY date FORMAT CSV;\n+DROP TABLE ttl_03519_1 SYNC;\n+\n+DROP TABLE IF EXISTS ttl_03519_2 SYNC;\n+CREATE TABLE ttl_03519_2 (date DateTime64(5, 'UTC'), date_key Int) ENGINE=MergeTree TTL date + INTERVAL 1 MONTH ORDER BY date;\n+INSERT INTO ttl_03519_2 VALUES ('2010-01-01 12:12:12.12345', 2010);\n+INSERT INTO ttl_03519_2 VALUES ('1901-01-01 12:12:12.12345', 1901);\n+INSERT INTO ttl_03519_2 VALUES ('2170-01-01 12:12:12.12345', 2170);\n+OPTIMIZE TABLE ttl_03519_2 FINAL;\n+SELECT * FROM ttl_03519_2 ORDER BY date FORMAT CSV;\n+DROP TABLE ttl_03519_2 SYNC;\n+\n+-- Column TTL with extended data types\n+\n+DROP TABLE IF EXISTS ttl_03519_3 SYNC;\n+CREATE TABLE ttl_03519_3 (date Date32, str String TTL date + INTERVAL 1 MONTH) ENGINE=MergeTree ORDER BY date;\n+INSERT INTO ttl_03519_3 VALUES ('2010-01-01', 'qwe');\n+INSERT INTO ttl_03519_3 VALUES ('1901-01-01', 'rty');\n+INSERT INTO ttl_03519_3 VALUES ('2170-01-01', 'uio');\n+OPTIMIZE TABLE ttl_03519_3 FINAL;\n+SELECT * FROM ttl_03519_3 ORDER BY date FORMAT CSV;\n+DROP TABLE ttl_03519_3 SYNC;\n+\n+DROP TABLE IF EXISTS ttl_03519_4 SYNC;\n+CREATE TABLE ttl_03519_4 (date DateTime64(5, 'UTC'), str String TTL date + INTERVAL 1 MONTH) ENGINE=MergeTree ORDER BY date;\n+INSERT INTO ttl_03519_4 VALUES ('2010-01-01 12:12:12', 'qwe');\n+INSERT INTO ttl_03519_4 VALUES ('1901-01-01 12:12:12.12345', 'rty');\n+INSERT INTO ttl_03519_4 VALUES ('2170-01-01 12:12:12.12345', 'uio');\n+OPTIMIZE TABLE ttl_03519_4 FINAL;\n+SELECT * FROM ttl_03519_4 ORDER BY date FORMAT CSV;\n+DROP TABLE ttl_03519_4 SYNC;\n+\n",
  "problem_statement": "Add support for Date32 in TTL\n### Describe the unexpected behaviour\n\nCurrently, only Date and DateTime can be used. It makes sense to also add support for Date32 and DateTime64\n\n### How to reproduce\n\nhttps://fiddle.clickhouse.com/c1b39b5e-36f9-4550-9207-b7e30d587b27\n\n",
  "hints_text": "Per the doc, it's by design:\n\n> Expressions must evaluate to [Date](https://clickhouse.com/docs/sql-reference/data-types/date) or [DateTime](https://clickhouse.com/docs/sql-reference/data-types/datetime) data type.\n@melvynator thanks, yes this is a feature request.\nThe workaround is to cast the data types using to Date.\nI will implement it",
  "created_at": "2025-05-22T16:42:27Z"
}