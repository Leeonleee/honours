{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16724,
  "instance_id": "ClickHouse__ClickHouse-16724",
  "issue_numbers": [
    "10290",
    "10266"
  ],
  "base_commit": "5f424f7c5cc8384cbbf87aabcc54018513d73b31",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex f8458b27a225..6237cd6a9764 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -430,6 +430,63 @@ SELECT toTypeName(CAST(x, 'Nullable(UInt16)')) FROM t_null\n \n -   [cast_keep_nullable](../../operations/settings/settings.md#cast_keep_nullable) setting\n \n+## accurateCast(x, T) {#type_conversion_function-accurate-cast}\n+\n+Converts \u2018x\u2019 to the \u2018t\u2019 data type. The differente from cast(x, T) is that accurateCast\n+does not allow overflow of numeric types during cast if type value x does not fit\n+bounds of type T.\n+\n+Example\n+``` sql\n+SELECT cast(-1, 'UInt8') as uint8; \n+```\n+\n+\n+``` text\n+\u250c\u2500uint8\u2500\u2510\n+\u2502   255 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT accurateCast(-1, 'UInt8') as uint8;\n+```\n+\n+``` text\n+Code: 70. DB::Exception: Received from localhost:9000. DB::Exception: Value in column Int8 cannot be safely converted into type UInt8: While processing accurateCast(-1, 'UInt8') AS uint8.\n+\n+```\n+\n+## accurateCastOrNull(x, T) {#type_conversion_function-accurate-cast_or_null}\n+\n+Converts \u2018x\u2019 to the \u2018t\u2019 data type. Always returns nullable type and returns NULL \n+if the casted value is not representable in the target type.\n+\n+Example:\n+\n+``` sql\n+SELECT\n+    accurateCastOrNull(-1, 'UInt8') as uint8,\n+    accurateCastOrNull(128, 'Int8') as int8,\n+    accurateCastOrNull('Test', 'FixedString(2)') as fixed_string\n+```\n+\n+``` text\n+\u250c\u2500uint8\u2500\u252c\u2500int8\u2500\u252c\u2500fixed_string\u2500\u2510\n+\u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 \u1d3a\u1d41\u1d38\u1d38         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2518\n+```\n+\n+``` sql\n+SELECT toTypeName(accurateCastOrNull(5, 'UInt8'))\n+```\n+\n+``` text\n+\u250c\u2500toTypeName(accurateCastOrNull(5, 'UInt8'))\u2500\u2510\n+\u2502 Nullable(UInt8)                            \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## toInterval(Year\\|Quarter\\|Month\\|Week\\|Day\\|Hour\\|Minute\\|Second) {#function-tointerval}\n \n Converts a Number type argument to an [Interval](../../sql-reference/data-types/special-data-types/interval.md) data type.\ndiff --git a/src/Common/UInt128.h b/src/Common/UInt128.h\nindex baa335780899..06fddee8dc9c 100644\n--- a/src/Common/UInt128.h\n+++ b/src/Common/UInt128.h\n@@ -28,23 +28,28 @@ struct UInt128\n     UInt64 low;\n     UInt64 high;\n \n+    /// TODO: Make this constexpr. Currently it is used in unions\n+    /// and union cannot contain member with non trivial constructor\n+    /// constructor must be non user provided but compiler cannot constexpr constructor\n+    /// if members low and high are not initialized, if we default member initialize them\n+    /// constructor becomes non trivial.\n     UInt128() = default;\n-    explicit UInt128(const UInt64 low_, const UInt64 high_) : low(low_), high(high_) {}\n+    explicit constexpr UInt128(const UInt64 low_, const UInt64 high_) : low(low_), high(high_) { }\n \n     /// We need Int128 to UInt128 conversion or AccurateComparison will call greaterOp<Int128, UInt64> instead of greaterOp<Int128, UInt128>\n-    explicit UInt128(const Int128 rhs) : low(rhs), high(rhs >> 64) {}\n-    explicit UInt128(const Int64 rhs) : low(rhs), high() {}\n-    explicit UInt128(const Int32 rhs) : low(rhs), high() {}\n-    explicit UInt128(const Int16 rhs) : low(rhs), high() {}\n-    explicit UInt128(const Int8 rhs) : low(rhs), high() {}\n-    explicit UInt128(const UInt8 rhs) : low(rhs), high() {}\n-    explicit UInt128(const UInt16 rhs) : low(rhs), high() {}\n-    explicit UInt128(const UInt32 rhs) : low(rhs), high() {}\n-    explicit UInt128(const UInt64 rhs) : low(rhs), high() {}\n-    explicit UInt128(const Float32 rhs) : low(rhs), high() {}\n-    explicit UInt128(const Float64 rhs) : low(rhs), high() {}\n-\n-    auto tuple() const { return std::tie(high, low); }\n+    explicit constexpr UInt128(const Int128 rhs) : low(rhs), high(rhs >> 64) {}\n+    explicit constexpr UInt128(const Int64 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const Int32 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const Int16 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const Int8 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const UInt8 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const UInt16 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const UInt32 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const UInt64 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const Float32 rhs) : low(rhs), high() {}\n+    explicit constexpr UInt128(const Float64 rhs) : low(rhs), high() {}\n+\n+    constexpr auto tuple() const { return std::tie(high, low); }\n \n     String toHexString() const\n     {\n@@ -53,31 +58,31 @@ struct UInt128\n         return res;\n     }\n \n-    bool inline operator== (const UInt128 rhs) const { return tuple() == rhs.tuple(); }\n-    bool inline operator!= (const UInt128 rhs) const { return tuple() != rhs.tuple(); }\n-    bool inline operator<  (const UInt128 rhs) const { return tuple() < rhs.tuple(); }\n-    bool inline operator<= (const UInt128 rhs) const { return tuple() <= rhs.tuple(); }\n-    bool inline operator>  (const UInt128 rhs) const { return tuple() > rhs.tuple(); }\n-    bool inline operator>= (const UInt128 rhs) const { return tuple() >= rhs.tuple(); }\n-\n-    bool inline operator == (const Int128 rhs) const { return *this == UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-    bool inline operator != (const Int128 rhs) const { return *this != UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    bool inline operator >= (const Int128 rhs) const { return *this >= UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    bool inline operator >  (const Int128 rhs) const { return *this >  UInt128(rhs, rhs >> 64) || rhs < 0; }\n-    bool inline operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-    bool inline operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }\n-\n-    bool inline operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }\n-    bool inline operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }\n-    bool inline operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }\n-    bool inline operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }\n-\n-    template <typename T> bool inline operator== (const T rhs) const { return *this == UInt128(rhs); }\n-    template <typename T> bool inline operator!= (const T rhs) const { return *this != UInt128(rhs); }\n-    template <typename T> bool inline operator>= (const T rhs) const { return *this >= UInt128(rhs); }\n-    template <typename T> bool inline operator>  (const T rhs) const { return *this >  UInt128(rhs); }\n-    template <typename T> bool inline operator<= (const T rhs) const { return *this <= UInt128(rhs); }\n-    template <typename T> bool inline operator<  (const T rhs) const { return *this <  UInt128(rhs); }\n+    constexpr bool operator== (const UInt128 rhs) const { return tuple() == rhs.tuple(); }\n+    constexpr bool operator!= (const UInt128 rhs) const { return tuple() != rhs.tuple(); }\n+    constexpr bool operator<  (const UInt128 rhs) const { return tuple() < rhs.tuple(); }\n+    constexpr bool operator<= (const UInt128 rhs) const { return tuple() <= rhs.tuple(); }\n+    constexpr bool operator>  (const UInt128 rhs) const { return tuple() > rhs.tuple(); }\n+    constexpr bool operator>= (const UInt128 rhs) const { return tuple() >= rhs.tuple(); }\n+\n+    constexpr bool operator == (const Int128 rhs) const { return *this == UInt128(rhs, rhs >> 64) && rhs >= 0; }\n+    constexpr bool operator != (const Int128 rhs) const { return *this != UInt128(rhs, rhs >> 64) || rhs < 0; }\n+    constexpr bool operator >= (const Int128 rhs) const { return *this >= UInt128(rhs, rhs >> 64) || rhs < 0; }\n+    constexpr bool operator >  (const Int128 rhs) const { return *this >  UInt128(rhs, rhs >> 64) || rhs < 0; }\n+    constexpr bool operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }\n+    constexpr bool operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }\n+\n+    constexpr bool operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }\n+    constexpr bool operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }\n+    constexpr bool operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }\n+    constexpr bool operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }\n+\n+    template <typename T> constexpr bool operator== (const T rhs) const { return *this == UInt128(rhs); }\n+    template <typename T> constexpr bool operator!= (const T rhs) const { return *this != UInt128(rhs); }\n+    template <typename T> constexpr bool operator>= (const T rhs) const { return *this >= UInt128(rhs); }\n+    template <typename T> constexpr bool operator>  (const T rhs) const { return *this >  UInt128(rhs); }\n+    template <typename T> constexpr bool operator<= (const T rhs) const { return *this <= UInt128(rhs); }\n+    template <typename T> constexpr bool operator<  (const T rhs) const { return *this <  UInt128(rhs); }\n \n     template <typename T> explicit operator T() const\n     {\n@@ -91,15 +96,15 @@ struct UInt128\n #pragma GCC diagnostic pop\n #endif\n \n-    UInt128 & operator= (const UInt64 rhs) { low = rhs; high = 0; return *this; }\n+    constexpr UInt128 & operator= (const UInt64 rhs) { low = rhs; high = 0; return *this; }\n };\n \n-template <typename T> bool inline operator == (T a, const UInt128 b) { return b.operator==(a); }\n-template <typename T> bool inline operator != (T a, const UInt128 b) { return b.operator!=(a); }\n-template <typename T> bool inline operator >= (T a, const UInt128 b) { return b <= a; }\n-template <typename T> bool inline operator >  (T a, const UInt128 b) { return b < a; }\n-template <typename T> bool inline operator <= (T a, const UInt128 b) { return b >= a; }\n-template <typename T> bool inline operator <  (T a, const UInt128 b) { return b > a; }\n+template <typename T> constexpr bool operator == (T a, const UInt128 b) { return b.operator==(a); }\n+template <typename T> constexpr bool operator != (T a, const UInt128 b) { return b.operator!=(a); }\n+template <typename T> constexpr bool operator >= (T a, const UInt128 b) { return b <= a; }\n+template <typename T> constexpr bool operator >  (T a, const UInt128 b) { return b < a; }\n+template <typename T> constexpr bool operator <= (T a, const UInt128 b) { return b >= a; }\n+template <typename T> constexpr bool operator <  (T a, const UInt128 b) { return b > a; }\n \n template <> inline constexpr bool IsNumber<UInt128> = true;\n template <> struct TypeName<UInt128> { static constexpr const char * get() { return \"UInt128\"; } };\n@@ -246,4 +251,42 @@ template <> struct hash<DB::UInt128>\n     }\n };\n \n+template<>\n+class numeric_limits<DB::UInt128>\n+{\n+public:\n+    static constexpr bool is_specialized = true;\n+    static constexpr bool is_signed = ::is_signed<DB::UInt128>::value;\n+    static constexpr bool is_integer = ::is_integer<DB::UInt128>::value;\n+    static constexpr bool is_exact = true;\n+    static constexpr bool has_infinity = false;\n+    static constexpr bool has_quiet_NaN = false;\n+    static constexpr bool has_signaling_NaN = false;\n+    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;\n+    static constexpr bool has_denorm_loss = false;\n+    static constexpr std::float_round_style round_style = std::round_toward_zero;\n+    static constexpr bool is_iec559 = false;\n+    static constexpr bool is_bounded = true;\n+    static constexpr bool is_modulo = true;\n+    static constexpr int digits = std::numeric_limits<UInt64>::digits * 2;\n+    static constexpr int digits10 = digits * 0.30103 /*std::log10(2)*/;\n+    static constexpr int max_digits10 = 0;\n+    static constexpr int radix = 2;\n+    static constexpr int min_exponent = 0;\n+    static constexpr int min_exponent10 = 0;\n+    static constexpr int max_exponent = 0;\n+    static constexpr int max_exponent10 = 0;\n+    static constexpr bool traps = true;\n+    static constexpr bool tinyness_before = false;\n+\n+    static constexpr DB::UInt128 min() noexcept { return DB::UInt128(0, 0); }\n+\n+    static constexpr DB::UInt128 max() noexcept\n+    {\n+        return DB::UInt128(std::numeric_limits<UInt64>::max(), std::numeric_limits<UInt64>::max());\n+    }\n+\n+    static constexpr DB::UInt128 lowest() noexcept { return min(); }\n+};\n+\n }\ndiff --git a/src/Core/AccurateComparison.h b/src/Core/AccurateComparison.h\nindex 500346872db5..c533cf0c7fbc 100644\n--- a/src/Core/AccurateComparison.h\n+++ b/src/Core/AccurateComparison.h\n@@ -515,11 +515,32 @@ inline bool NO_SANITIZE_UNDEFINED convertNumeric(From value, To & result)\n         return true;\n     }\n \n-    /// Note that NaNs doesn't compare equal to anything, but they are still in range of any Float type.\n-    if (isNaN(value) && std::is_floating_point_v<To>)\n+    if constexpr (std::is_floating_point_v<From> && std::is_floating_point_v<To>)\n     {\n-        result = value;\n-        return true;\n+        /// Note that NaNs doesn't compare equal to anything, but they are still in range of any Float type.\n+        if (isNaN(value))\n+        {\n+            result = value;\n+            return true;\n+        }\n+\n+        if (value == std::numeric_limits<From>::infinity())\n+        {\n+            result = std::numeric_limits<To>::infinity();\n+            return true;\n+        }\n+\n+        if (value == -std::numeric_limits<From>::infinity())\n+        {\n+            result = -std::numeric_limits<To>::infinity();\n+            return true;\n+        }\n+    }\n+\n+    if (accurate::greaterOp(value, std::numeric_limits<To>::max())\n+        || accurate::greaterOp(std::numeric_limits<To>::lowest(), value))\n+    {\n+        return false;\n     }\n \n     result = static_cast<To>(value);\ndiff --git a/src/Core/DecimalFunctions.h b/src/Core/DecimalFunctions.h\nindex b82cfd88e981..bd30568bb313 100644\n--- a/src/Core/DecimalFunctions.h\n+++ b/src/Core/DecimalFunctions.h\n@@ -206,23 +206,32 @@ inline typename DecimalType::NativeType getFractionalPart(const DecimalType & de\n }\n \n /// Decimal to integer/float conversion\n-template <typename To, typename DecimalType>\n-To convertTo(const DecimalType & decimal, size_t scale)\n+template <typename To, typename DecimalType, typename ReturnType>\n+ReturnType convertToImpl(const DecimalType & decimal, size_t scale, To & result)\n {\n     using NativeT = typename DecimalType::NativeType;\n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n     if constexpr (std::is_floating_point_v<To>)\n     {\n-        return static_cast<To>(decimal.value) / static_cast<To>(scaleMultiplier<NativeT>(scale));\n+        result = static_cast<To>(decimal.value) / static_cast<To>(scaleMultiplier<NativeT>(scale));\n     }\n     else if constexpr (is_integer_v<To> && (sizeof(To) >= sizeof(NativeT)))\n     {\n         NativeT whole = getWholePart(decimal, scale);\n \n         if constexpr (is_unsigned_v<To>)\n+        {\n             if (whole < 0)\n-                throw Exception(\"Convert overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n-        return static_cast<To>(whole);\n+            {\n+                if constexpr (throw_exception)\n+                    throw Exception(\"Convert overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n+                else\n+                    return ReturnType(true);\n+            }\n+        }\n+\n+        result = static_cast<To>(whole);\n     }\n     else if constexpr (is_integer_v<To>)\n     {\n@@ -235,9 +244,34 @@ To convertTo(const DecimalType & decimal, size_t scale)\n         static const constexpr CastTo max_to = std::numeric_limits<ToNativeT>::max();\n \n         if (whole < min_to || whole > max_to)\n-            throw Exception(\"Convert overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n-        return static_cast<CastTo>(whole);\n+        {\n+            if constexpr (throw_exception)\n+                throw Exception(\"Convert overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n+            else\n+                return ReturnType(true);\n+        }\n+\n+        result = static_cast<CastTo>(whole);\n     }\n+\n+    return ReturnType(true);\n+}\n+\n+\n+template <typename To, typename DecimalType>\n+To convertTo(const DecimalType & decimal, size_t scale)\n+{\n+    To result;\n+\n+    convertToImpl<To, DecimalType, void>(decimal, scale, result);\n+\n+    return result;\n+}\n+\n+template <typename To, typename DecimalType>\n+bool tryConvertTo(const DecimalType & decimal, size_t scale, To & result)\n+{\n+    return convertToImpl<To, DecimalType, bool>(decimal, scale, result);\n }\n \n template <bool is_multiply, bool is_division, typename T, typename U, template <typename> typename DecimalType>\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex 4e59293c88d1..2a8dd2acdc0c 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -16,10 +16,8 @@ namespace ErrorCodes\n     extern const int UNKNOWN_ELEMENT_IN_CONFIG;\n }\n \n-\n IMPLEMENT_SETTINGS_TRAITS(SettingsTraits, LIST_OF_SETTINGS)\n \n-\n /** Set the settings from the profile (in the server configuration, many settings can be listed in one profile).\n     * The profile can also be set using the `set` functions, like the `profile` setting.\n     */\ndiff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex 079812c2e748..3f7b4e2ac63b 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -96,22 +96,29 @@ inline UInt32 getDecimalScale(const DataTypeDecimal<T> & data_type)\n     return data_type.getScale();\n }\n \n-template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n-convertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_from, UInt32 scale_to)\n+template <typename FromDataType, typename ToDataType, typename ReturnType = void>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>, ReturnType>\n+convertDecimalsImpl(const typename FromDataType::FieldType & value, UInt32 scale_from, UInt32 scale_to, typename ToDataType::FieldType& result)\n {\n     using FromFieldType = typename FromDataType::FieldType;\n     using ToFieldType = typename ToDataType::FieldType;\n     using MaxFieldType = std::conditional_t<(sizeof(FromFieldType) > sizeof(ToFieldType)), FromFieldType, ToFieldType>;\n     using MaxNativeType = typename MaxFieldType::NativeType;\n \n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+\n     MaxNativeType converted_value;\n     if (scale_to > scale_from)\n     {\n         converted_value = DecimalUtils::scaleMultiplier<MaxNativeType>(scale_to - scale_from);\n         if (common::mulOverflow(static_cast<MaxNativeType>(value.value), converted_value, converted_value))\n-            throw Exception(std::string(ToDataType::family_name) + \" convert overflow\",\n-                            ErrorCodes::DECIMAL_OVERFLOW);\n+        {\n+            if constexpr (throw_exception)\n+                throw Exception(std::string(ToDataType::family_name) + \" convert overflow\",\n+                                ErrorCodes::DECIMAL_OVERFLOW);\n+            else\n+                return ReturnType(false);\n+        }\n     }\n     else\n         converted_value = value.value / DecimalUtils::scaleMultiplier<MaxNativeType>(scale_from - scale_to);\n@@ -120,35 +127,87 @@ convertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_fro\n     {\n         if (converted_value < std::numeric_limits<typename ToFieldType::NativeType>::min() ||\n             converted_value > std::numeric_limits<typename ToFieldType::NativeType>::max())\n-            throw Exception(std::string(ToDataType::family_name) + \" convert overflow\",\n-                            ErrorCodes::DECIMAL_OVERFLOW);\n+        {\n+            if constexpr (throw_exception)\n+                throw Exception(std::string(ToDataType::family_name) + \" convert overflow\",\n+                                ErrorCodes::DECIMAL_OVERFLOW);\n+            else\n+                return ReturnType(false);\n+        }\n     }\n \n-    return static_cast<typename ToFieldType::NativeType>(converted_value);\n+    result = static_cast<typename ToFieldType::NativeType>(converted_value);\n+\n+    return ReturnType(true);\n+}\n+\n+template <typename FromDataType, typename ToDataType>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n+convertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_from, UInt32 scale_to)\n+{\n+    using ToFieldType = typename ToDataType::FieldType;\n+    ToFieldType result;\n+\n+    convertDecimalsImpl<FromDataType, ToDataType, void>(value, scale_from, scale_to, result);\n+\n+    return result;\n+}\n+\n+template <typename FromDataType, typename ToDataType>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>, bool>\n+tryConvertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_from, UInt32 scale_to, typename ToDataType::FieldType& result)\n+{\n+    return convertDecimalsImpl<FromDataType, ToDataType, bool>(value, scale_from, scale_to, result);\n+}\n+\n+template <typename FromDataType, typename ToDataType, typename ReturnType>\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, ReturnType>\n+convertFromDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n+{\n+    using FromFieldType = typename FromDataType::FieldType;\n+    using ToFieldType = typename ToDataType::FieldType;\n+\n+    return DecimalUtils::convertToImpl<ToFieldType, FromFieldType, ReturnType>(value, scale, result);\n }\n \n template <typename FromDataType, typename ToDataType>\n inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, typename ToDataType::FieldType>\n convertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n {\n-    using ToFieldType = typename ToDataType::FieldType;\n+    typename ToDataType::FieldType result;\n \n-    return DecimalUtils::convertTo<ToFieldType>(value, scale);\n+    convertFromDecimalImpl<FromDataType, ToDataType, void>(value, scale, result);\n+\n+    return result;\n }\n \n template <typename FromDataType, typename ToDataType>\n-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n-convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, bool>\n+tryConvertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n+{\n+    return convertFromDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);\n+}\n+\n+template <typename FromDataType, typename ToDataType, typename ReturnType>\n+inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, ReturnType>\n+convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n {\n     using FromFieldType = typename FromDataType::FieldType;\n     using ToFieldType = typename ToDataType::FieldType;\n     using ToNativeType = typename ToFieldType::NativeType;\n \n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+\n     if constexpr (std::is_floating_point_v<FromFieldType>)\n     {\n         if (!std::isfinite(value))\n-            throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Cannot convert infinity or NaN to decimal\",\n-                            ErrorCodes::DECIMAL_OVERFLOW);\n+        {\n+            if constexpr (throw_exception)\n+                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Cannot convert infinity or NaN to decimal\",\n+                                ErrorCodes::DECIMAL_OVERFLOW);\n+            else\n+                return false;\n+        }\n \n         auto out = value * static_cast<FromFieldType>(DecimalUtils::scaleMultiplier<ToNativeType>(scale));\n         if constexpr (std::is_same_v<ToNativeType, Int128>)\n@@ -157,29 +216,60 @@ convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n             static constexpr Int128 max_int128 = maxInt128();\n \n             if (out <= static_cast<ToNativeType>(min_int128) || out >= static_cast<ToNativeType>(max_int128))\n-                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n-                                ErrorCodes::DECIMAL_OVERFLOW);\n+            {\n+                if constexpr (throw_exception)\n+                    throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n+                                    ErrorCodes::DECIMAL_OVERFLOW);\n+                else\n+                    return ReturnType(false);\n+            }\n         }\n         else\n         {\n             if (out <= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::min()) ||\n                 out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))\n-                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n-                                ErrorCodes::DECIMAL_OVERFLOW);\n+            {\n+                if constexpr (throw_exception)\n+                    throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n+                                    ErrorCodes::DECIMAL_OVERFLOW);\n+                else\n+                    return ReturnType(false);\n+            }\n         }\n-        return static_cast<ToNativeType>(out);\n+\n+        result = static_cast<ToNativeType>(out);\n+\n+        return ReturnType(true);\n     }\n     else\n     {\n         if constexpr (is_big_int_v<FromFieldType>)\n-            return convertDecimals<DataTypeDecimal<Decimal256>, ToDataType>(static_cast<Int256>(value), 0, scale);\n+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal256>, ToDataType, ReturnType>(static_cast<Int256>(value), 0, scale, result));\n         else if constexpr (std::is_same_v<FromFieldType, UInt64>)\n-            return convertDecimals<DataTypeDecimal<Decimal128>, ToDataType>(value, 0, scale);\n+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal128>, ToDataType, ReturnType>(value, 0, scale, result));\n         else\n-            return convertDecimals<DataTypeDecimal<Decimal64>, ToDataType>(value, 0, scale);\n+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal64>, ToDataType, ReturnType>(value, 0, scale, result));\n     }\n }\n \n+template <typename FromDataType, typename ToDataType>\n+inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>\n+convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale)\n+{\n+    typename ToDataType::FieldType result;\n+\n+    convertToDecimalImpl<FromDataType, ToDataType, void>(value, scale, result);\n+\n+    return result;\n+}\n+\n+template <typename FromDataType, typename ToDataType>\n+inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, bool>\n+tryConvertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)\n+{\n+    return convertToDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);\n+}\n+\n template <typename T>\n inline DataTypePtr createDecimalMaxPrecision(UInt64 scale)\n {\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex df9628003857..257b852ecd8a 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -1,16 +1,10 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsConversion.h>\n-#include <Interpreters/Context.h>\n \n \n namespace DB\n {\n \n-FunctionOverloadResolverImplPtr CastOverloadResolver::create(const Context & context)\n-{\n-    return createImpl(context.getSettingsRef().cast_keep_nullable);\n-}\n-\n void registerFunctionFixedString(FunctionFactory & factory);\n \n void registerFunctionsConversion(FunctionFactory & factory)\n@@ -44,7 +38,10 @@ void registerFunctionsConversion(FunctionFactory & factory)\n     registerFunctionFixedString(factory);\n \n     factory.registerFunction<FunctionToUnixTimestamp>();\n-    factory.registerFunction<CastOverloadResolver>(FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<CastOverloadResolver<CastType::nonAccurate>>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<CastOverloadResolver<CastType::accurate>>();\n+    factory.registerFunction<CastOverloadResolver<CastType::accurateOrNull>>();\n \n     factory.registerFunction<FunctionToUInt8OrZero>();\n     factory.registerFunction<FunctionToUInt16OrZero>();\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 1e4bd5c26d68..6d6d8fd23bb8 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -36,13 +36,15 @@\n #include <Common/FieldVisitors.h>\n #include <Common/assert_cast.h>\n #include <Common/quoteString.h>\n+#include <Core/AccurateComparison.h>\n #include <Functions/IFunctionAdaptors.h>\n #include <Functions/FunctionsMiscellaneous.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/DateTimeTransforms.h>\n+#include <Functions/toFixedString.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <Columns/ColumnLowCardinality.h>\n-#include <Functions/toFixedString.h>\n+#include <Interpreters/Context.h>\n \n \n namespace DB\n@@ -94,6 +96,15 @@ inline UInt32 extractToDecimalScale(const ColumnWithTypeAndName & named_column)\n /// Function toUnixTimestamp has exactly the same implementation as toDateTime of String type.\n struct NameToUnixTimestamp { static constexpr auto name = \"toUnixTimestamp\"; };\n \n+struct AccurateConvertStrategyAdditions\n+{\n+    UInt32 scale { 0 };\n+};\n+\n+struct AccurateOrNullConvertStrategyAdditions\n+{\n+    UInt32 scale { 0 };\n+};\n \n /** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n   *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n@@ -106,7 +117,7 @@ struct ConvertImpl\n \n     template <typename Additions = void *>\n     static ColumnPtr NO_SANITIZE_UNDEFINED execute(\n-        const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t /*input_rows_count*/,\n+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t /*input_rows_count*/,\n         Additions additions [[maybe_unused]] = Additions())\n     {\n         const ColumnWithTypeAndName & named_from = arguments[0];\n@@ -136,7 +147,17 @@ struct ConvertImpl\n             typename ColVecTo::MutablePtr col_to = nullptr;\n             if constexpr (IsDataTypeDecimal<ToDataType>)\n             {\n-                UInt32 scale = additions;\n+                UInt32 scale;\n+                if constexpr (std::is_same_v<Additions, AccurateConvertStrategyAdditions>\n+                    || std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                {\n+                    scale = additions.scale;\n+                }\n+                else\n+                {\n+                    scale = additions;\n+                }\n+\n                 col_to = ColVecTo::create(0, scale);\n             }\n             else\n@@ -147,36 +168,106 @@ struct ConvertImpl\n             size_t size = vec_from.size();\n             vec_to.resize(size);\n \n+            ColumnUInt8::MutablePtr col_null_map_to;\n+            ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n+            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+            {\n+                col_null_map_to = ColumnUInt8::create(size, false);\n+                vec_null_map_to = &col_null_map_to->getData();\n+            }\n+\n             for (size_t i = 0; i < size; ++i)\n             {\n-                if constexpr (IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n+                if constexpr ((is_big_int_v<FromFieldType> || is_big_int_v<ToFieldType>) &&\n+                    (std::is_same_v<FromFieldType, UInt128> || std::is_same_v<ToFieldType, UInt128>))\n                 {\n-                    if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n-                        vec_to[i] = convertDecimals<FromDataType, ToDataType>(vec_from[i], vec_from.getScale(), vec_to.getScale());\n-                    else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n-                        vec_to[i] = convertFromDecimal<FromDataType, ToDataType>(vec_from[i], vec_from.getScale());\n-                    else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n-                        vec_to[i] = convertToDecimal<FromDataType, ToDataType>(vec_from[i], vec_to.getScale());\n+                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                        (*vec_null_map_to)[i] = true;\n                     else\n-                        throw Exception(\"Unsupported data type in conversion function\", ErrorCodes::CANNOT_CONVERT_TYPE);\n+                        throw Exception(\"Unexpected UInt128 to big int conversion\", ErrorCodes::NOT_IMPLEMENTED);\n                 }\n-                else if constexpr (is_big_int_v<FromFieldType> || is_big_int_v<ToFieldType>)\n+                else\n                 {\n-                    if constexpr (std::is_same_v<FromFieldType, UInt128> || std::is_same_v<ToFieldType, UInt128>)\n-                        throw Exception(\"Unexpected UInt128 to big int conversion\", ErrorCodes::NOT_IMPLEMENTED);\n-                    /// If From Data is Nan or Inf, throw exception\n-                    else if (!isFinite(vec_from[i]))\n-                        throw Exception(\"Unexpected inf or nan to big int conversion\", ErrorCodes::NOT_IMPLEMENTED);\n+                    if constexpr (IsDataTypeDecimal<FromDataType> || IsDataTypeDecimal<ToDataType>)\n+                    {\n+                        if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                        {\n+                            ToFieldType result;\n+                            bool convert_result = false;\n+\n+                            if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n+                                convert_result = tryConvertDecimals<FromDataType, ToDataType>(vec_from[i], vec_from.getScale(), vec_to.getScale(), result);\n+                            else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n+                                convert_result = tryConvertFromDecimal<FromDataType, ToDataType>(vec_from[i], vec_from.getScale(), result);\n+                            else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n+                                convert_result = tryConvertToDecimal<FromDataType, ToDataType>(vec_from[i], vec_to.getScale(), result);\n+\n+                            if (convert_result)\n+                                vec_to[i] = result;\n+                            else\n+                                (*vec_null_map_to)[i] = true;\n+                        }\n+                        else\n+                        {\n+                            if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeDecimal<ToDataType>)\n+                                vec_to[i] = convertDecimals<FromDataType, ToDataType>(vec_from[i], vec_from.getScale(), vec_to.getScale());\n+                            else if constexpr (IsDataTypeDecimal<FromDataType> && IsDataTypeNumber<ToDataType>)\n+                                vec_to[i] = convertFromDecimal<FromDataType, ToDataType>(vec_from[i], vec_from.getScale());\n+                            else if constexpr (IsDataTypeNumber<FromDataType> && IsDataTypeDecimal<ToDataType>)\n+                                vec_to[i] = convertToDecimal<FromDataType, ToDataType>(vec_from[i], vec_to.getScale());\n+                            else\n+                                throw Exception(\"Unsupported data type in conversion function\", ErrorCodes::CANNOT_CONVERT_TYPE);\n+                        }\n+                    }\n                     else\n-                        vec_to[i] = bigint_cast<ToFieldType>(vec_from[i]);\n+                    {\n+                        /// If From Data is Nan or Inf and we convert to integer type, throw exception\n+                        if constexpr (std::is_floating_point_v<FromFieldType> && !std::is_floating_point_v<ToFieldType>)\n+                        {\n+                            if (!isFinite(vec_from[i]))\n+                            {\n+                                if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                                {\n+                                    (*vec_null_map_to)[i] = true;\n+                                    continue;\n+                                }\n+                                else\n+                                    throw Exception(\"Unexpected inf or nan to integer conversion\", ErrorCodes::CANNOT_CONVERT_TYPE);\n+                            }\n+                        }\n+\n+                        if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>\n+                                || std::is_same_v<Additions, AccurateConvertStrategyAdditions>)\n+                        {\n+                            bool convert_result = accurate::convertNumeric(vec_from[i], vec_to[i]);\n+\n+                            if (!convert_result)\n+                            {\n+                                if (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                                {\n+                                    (*vec_null_map_to)[i] = true;\n+                                }\n+                                else\n+                                {\n+                                    throw Exception(\n+                                        \"Value in column \" + named_from.column->getName() + \" cannot be safely converted into type \"\n+                                            + result_type->getName(),\n+                                        ErrorCodes::CANNOT_CONVERT_TYPE);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            vec_to[i] = static_cast<ToFieldType>(vec_from[i]);\n+                        }\n+                    }\n                 }\n-                else if constexpr (std::is_same_v<ToFieldType, UInt128> && sizeof(FromFieldType) <= sizeof(UInt64))\n-                    vec_to[i] = static_cast<ToFieldType>(static_cast<UInt64>(vec_from[i]));\n-                else\n-                    vec_to[i] = static_cast<ToFieldType>(vec_from[i]);\n             }\n \n-            return col_to;\n+            if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)\n+                return ColumnNullable::create(std::move(col_to), std::move(col_null_map_to));\n+            else\n+                return col_to;\n         }\n         else\n             throw Exception(\"Illegal column \" + named_from.column->getName() + \" of first argument of function \" + Name::name,\n@@ -943,7 +1034,9 @@ struct ConvertImpl<DataTypeString, DataTypeUInt32, NameToUnixTimestamp>\n template <typename T, typename Name>\n struct ConvertImpl<std::enable_if_t<!T::is_parametric, T>, T, Name>\n {\n-    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/)\n+    template <typename Additions = void *>\n+    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/,\n+        Additions additions [[maybe_unused]] = Additions())\n     {\n         return arguments[0].column;\n     }\n@@ -1929,9 +2022,15 @@ class ExecutableFunctionCast : public IExecutableFunctionImpl\n     std::optional<Diagnostic> diagnostic;\n };\n \n-\n struct NameCast { static constexpr auto name = \"CAST\"; };\n \n+enum class CastType\n+{\n+    nonAccurate,\n+    accurate,\n+    accurateOrNull\n+};\n+\n class FunctionCast final : public IFunctionBaseImpl\n {\n public:\n@@ -1940,9 +2039,11 @@ class FunctionCast final : public IFunctionBaseImpl\n     using Diagnostic = ExecutableFunctionCast::Diagnostic;\n \n     FunctionCast(const char * name_, MonotonicityForRange && monotonicity_for_range_\n-        , const DataTypes & argument_types_, const DataTypePtr & return_type_, std::optional<Diagnostic> diagnostic_)\n-        : name(name_), monotonicity_for_range(monotonicity_for_range_)\n+        , const DataTypes & argument_types_, const DataTypePtr & return_type_\n+        , std::optional<Diagnostic> diagnostic_, CastType cast_type_)\n+        : name(name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n         , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n+        , cast_type(cast_type_)\n     {\n     }\n \n@@ -1989,70 +2090,118 @@ class FunctionCast final : public IFunctionBaseImpl\n     DataTypePtr return_type;\n \n     std::optional<Diagnostic> diagnostic;\n+    CastType cast_type;\n \n-    template <typename DataType>\n-    WrapperType createWrapper(const DataTypePtr & from_type, const DataType * const, bool requested_result_is_nullable) const\n+    WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type) const\n     {\n-        FunctionPtr function;\n-\n-        if (requested_result_is_nullable && checkAndGetDataType<DataTypeString>(from_type.get()))\n-        {\n-            /// In case when converting to Nullable type, we apply different parsing rule,\n-            /// that will not throw an exception but return NULL in case of malformed input.\n-            function = FunctionConvertFromString<DataType, NameCast, ConvertFromStringExceptionMode::Null>::create();\n-        }\n-        else\n-            function = FunctionTo<DataType>::Type::create();\n-\n-        auto function_adaptor =\n-                FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(function))\n-                .build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n+        auto function_adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(function))\n+                                    .build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n \n-        return [function_adaptor] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n+        return [function_adaptor]\n+            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n         {\n             return function_adaptor->execute(arguments, result_type, input_rows_count);\n         };\n     }\n \n-    static WrapperType createStringWrapper(const DataTypePtr & from_type)\n+    static WrapperType createToNullableColumnWrapper()\n     {\n-        FunctionPtr function = FunctionToString::create();\n-\n-        auto function_adaptor =\n-                FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(function))\n-                .build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n-\n-        return [function_adaptor] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n+        return [] (ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n         {\n-            return function_adaptor->execute(arguments, result_type, input_rows_count);\n+            ColumnPtr res = result_type->createColumn();\n+            ColumnUInt8::Ptr col_null_map_to = ColumnUInt8::create(input_rows_count, true);\n+            return ColumnNullable::create(res->cloneResized(input_rows_count), std::move(col_null_map_to));\n         };\n     }\n \n-    static WrapperType createFixedStringWrapper(const DataTypePtr & from_type, const size_t N)\n+    template <typename ToDataType>\n+    WrapperType createWrapper(const DataTypePtr & from_type, const ToDataType * const to_type, bool requested_result_is_nullable) const\n     {\n-        if (!isStringOrFixedString(from_type))\n-            throw Exception{\"CAST AS FixedString is only implemented for types String and FixedString\", ErrorCodes::NOT_IMPLEMENTED};\n+        TypeIndex from_type_index = from_type->getTypeId();\n+        WhichDataType which(from_type_index);\n+        bool can_apply_accurate_cast = (cast_type == CastType::accurate || cast_type == CastType::accurateOrNull)\n+            && (which.isInt() || which.isUInt() || which.isFloat());\n+\n+        if (requested_result_is_nullable && checkAndGetDataType<DataTypeString>(from_type.get()))\n+        {\n+            /// In case when converting to Nullable type, we apply different parsing rule,\n+            /// that will not throw an exception but return NULL in case of malformed input.\n+            FunctionPtr function = FunctionConvertFromString<ToDataType, NameCast, ConvertFromStringExceptionMode::Null>::create();\n+            return createFunctionAdaptor(function, from_type);\n+        }\n+        else if (!can_apply_accurate_cast)\n+        {\n+            FunctionPtr function = FunctionTo<ToDataType>::Type::create();\n+            return createFunctionAdaptor(function, from_type);\n+        }\n \n-        return [N] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n+        auto wrapper_cast_type = cast_type;\n+\n+        return [wrapper_cast_type, from_type_index, to_type]\n+            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *column_nullable, size_t input_rows_count)\n         {\n-            return FunctionToFixedString::executeForN(arguments, N);\n+            ColumnPtr result_column;\n+            auto res = callOnIndexAndDataType<ToDataType>(from_type_index, [&](const auto & types) -> bool {\n+                using Types = std::decay_t<decltype(types)>;\n+                using LeftDataType = typename Types::LeftType;\n+                using RightDataType = typename Types::RightType;\n+\n+                if constexpr (IsDataTypeNumber<LeftDataType> && IsDataTypeNumber<RightDataType>)\n+                {\n+                    if (wrapper_cast_type == CastType::accurate)\n+                    {\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, NameCast>::execute(\n+                            arguments, result_type, input_rows_count, AccurateConvertStrategyAdditions());\n+                    }\n+                    else\n+                    {\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, NameCast>::execute(\n+                            arguments, result_type, input_rows_count, AccurateOrNullConvertStrategyAdditions());\n+                    }\n+\n+                    return true;\n+                }\n+\n+                return false;\n+            });\n+\n+            /// Additionally check if callOnIndexAndDataType wasn't called at all.\n+            if (!res)\n+            {\n+                if (wrapper_cast_type == CastType::accurateOrNull)\n+                {\n+                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n+                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n+                }\n+                else\n+                {\n+                    throw Exception{\"Conversion from \" + std::string(getTypeName(from_type_index)) + \" to \" + to_type->getName() + \" is not supported\",\n+                        ErrorCodes::CANNOT_CONVERT_TYPE};\n+                }\n+            }\n+\n+            return result_column;\n         };\n     }\n \n-    static WrapperType createUUIDWrapper(const DataTypePtr & from_type, const DataTypeUUID * const, bool requested_result_is_nullable)\n+    WrapperType createStringWrapper(const DataTypePtr & from_type) const\n     {\n-        if (requested_result_is_nullable)\n-            throw Exception{\"CAST AS Nullable(UUID) is not implemented\", ErrorCodes::NOT_IMPLEMENTED};\n-\n-        FunctionPtr function = FunctionTo<DataTypeUUID>::Type::create();\n+        FunctionPtr function = FunctionToString::create();\n+        return createFunctionAdaptor(function, from_type);\n+    }\n \n-        auto function_adaptor =\n-                FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(function))\n-                .build({ColumnWithTypeAndName{nullptr, from_type, \"\"}});\n+    WrapperType createFixedStringWrapper(const DataTypePtr & from_type, const size_t N) const\n+    {\n+        if (!isStringOrFixedString(from_type))\n+            throw Exception{\"CAST AS FixedString is only implemented for types String and FixedString\", ErrorCodes::NOT_IMPLEMENTED};\n \n-        return [function_adaptor] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n+        bool exception_mode_null = cast_type == CastType::accurateOrNull;\n+        return [exception_mode_null, N] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/)\n         {\n-            return function_adaptor->execute(arguments, result_type, input_rows_count);\n+            if (exception_mode_null)\n+                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Null>(arguments, N);\n+            else\n+                return FunctionToFixedString::executeForN<ConvertToFixedStringExceptionMode::Throw>(arguments, N);\n         };\n     }\n \n@@ -2064,41 +2213,73 @@ class FunctionCast final : public IFunctionBaseImpl\n         UInt32 scale = to_type->getScale();\n \n         WhichDataType which(type_index);\n-        bool ok = which.isNativeInt() ||\n-            which.isNativeUInt() ||\n-            which.isDecimal() ||\n-            which.isFloat() ||\n-            which.isDateOrDateTime() ||\n-            which.isStringOrFixedString();\n+        bool ok = which.isNativeInt() || which.isNativeUInt() || which.isDecimal() || which.isFloat() || which.isDateOrDateTime()\n+            || which.isStringOrFixedString();\n         if (!ok)\n-            throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() + \" is not supported\",\n-                ErrorCodes::CANNOT_CONVERT_TYPE};\n+        {\n+            if (cast_type == CastType::accurateOrNull)\n+                return createToNullableColumnWrapper();\n+            else\n+                throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() + \" is not supported\",\n+                    ErrorCodes::CANNOT_CONVERT_TYPE};\n+        }\n \n-        return [type_index, scale, to_type] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n+        auto wrapper_cast_type = cast_type;\n+\n+        return [wrapper_cast_type, type_index, scale, to_type]\n+            (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *column_nullable, size_t input_rows_count)\n         {\n             ColumnPtr result_column;\n-            auto res = callOnIndexAndDataType<ToDataType>(type_index, [&](const auto & types) -> bool\n-            {\n+            auto res = callOnIndexAndDataType<ToDataType>(type_index, [&](const auto & types) -> bool {\n                 using Types = std::decay_t<decltype(types)>;\n                 using LeftDataType = typename Types::LeftType;\n                 using RightDataType = typename Types::RightType;\n \n+                if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>)\n+                {\n+                    if (wrapper_cast_type == CastType::accurate)\n+                    {\n+                        AccurateConvertStrategyAdditions additions;\n+                        additions.scale = scale;\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, NameCast>::execute(\n+                            arguments, result_type, input_rows_count, additions);\n+\n+                        return true;\n+                    }\n+                    else if (wrapper_cast_type == CastType::accurateOrNull)\n+                    {\n+                        AccurateOrNullConvertStrategyAdditions additions;\n+                        additions.scale = scale;\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, NameCast>::execute(\n+                            arguments, result_type, input_rows_count, additions);\n+\n+                        return true;\n+                    }\n+                }\n+\n                 result_column = ConvertImpl<LeftDataType, RightDataType, NameCast>::execute(arguments, result_type, input_rows_count, scale);\n+\n                 return true;\n             });\n \n             /// Additionally check if callOnIndexAndDataType wasn't called at all.\n             if (!res)\n             {\n-                throw Exception{\"Conversion from \" + std::string(getTypeName(type_index)) + \" to \" + to_type->getName() +\n-                                \" is not supported\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+                if (wrapper_cast_type == CastType::accurateOrNull)\n+                {\n+                    auto nullable_column_wrapper = FunctionCast::createToNullableColumnWrapper();\n+                    return nullable_column_wrapper(arguments, result_type, column_nullable, input_rows_count);\n+                }\n+                else\n+                    throw Exception{\"Conversion from \" + std::string(getTypeName(type_index)) + \" to \" + to_type->getName() + \" is not supported\",\n+                        ErrorCodes::CANNOT_CONVERT_TYPE};\n             }\n \n             return result_column;\n         };\n     }\n \n-    static WrapperType createAggregateFunctionWrapper(const DataTypePtr & from_type_untyped, const DataTypeAggregateFunction * to_type)\n+    WrapperType createAggregateFunctionWrapper(const DataTypePtr & from_type_untyped, const DataTypeAggregateFunction * to_type) const\n     {\n         /// Conversion from String through parsing.\n         if (checkAndGetDataType<DataTypeString>(from_type_untyped.get()))\n@@ -2109,8 +2290,13 @@ class FunctionCast final : public IFunctionBaseImpl\n             };\n         }\n         else\n-            throw Exception{\"Conversion from \" + from_type_untyped->getName() + \" to \" + to_type->getName() +\n-                \" is not supported\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+        {\n+            if (cast_type == CastType::accurateOrNull)\n+                return createToNullableColumnWrapper();\n+            else\n+                throw Exception{\"Conversion from \" + from_type_untyped->getName() + \" to \" + to_type->getName() +\n+                    \" is not supported\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+        }\n     }\n \n     WrapperType createArrayWrapper(const DataTypePtr & from_type_untyped, const DataTypeArray * to_type) const\n@@ -2235,17 +2421,16 @@ class FunctionCast final : public IFunctionBaseImpl\n         else if (isNativeNumber(from_type) || isEnum(from_type))\n         {\n             auto function = Function::create();\n-            auto func_or_adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(function))\n-                    .build(ColumnsWithTypeAndName{{nullptr, from_type, \"\" }});\n-\n-            return [func_or_adaptor] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n-            {\n-                return func_or_adaptor->execute(arguments, result_type, input_rows_count);\n-            };\n+            return createFunctionAdaptor(function, from_type);\n         }\n         else\n-            throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() +\n-                \" is not supported\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+        {\n+            if (cast_type == CastType::accurateOrNull)\n+                return createToNullableColumnWrapper();\n+            else\n+                throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() + \" is not supported\",\n+                    ErrorCodes::CANNOT_CONVERT_TYPE};\n+        }\n     }\n \n     template <typename EnumTypeFrom, typename EnumTypeTo>\n@@ -2346,7 +2531,16 @@ class FunctionCast final : public IFunctionBaseImpl\n         if (from_type->onlyNull())\n         {\n             if (!to_nested->isNullable())\n-                throw Exception{\"Cannot convert NULL to a non-nullable type\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+            {\n+                if (cast_type == CastType::accurateOrNull)\n+                {\n+                    return createToNullableColumnWrapper();\n+                }\n+                else\n+                {\n+                    throw Exception{\"Cannot convert NULL to a non-nullable type\", ErrorCodes::CANNOT_CONVERT_TYPE};\n+                }\n+            }\n \n             return [](ColumnsWithTypeAndName &, const DataTypePtr & result_type, const ColumnNullable *, size_t input_rows_count)\n             {\n@@ -2536,7 +2730,8 @@ class FunctionCast final : public IFunctionBaseImpl\n                 std::is_same_v<ToDataType, DataTypeFloat32> ||\n                 std::is_same_v<ToDataType, DataTypeFloat64> ||\n                 std::is_same_v<ToDataType, DataTypeDate> ||\n-                std::is_same_v<ToDataType, DataTypeDateTime>)\n+                std::is_same_v<ToDataType, DataTypeDateTime> ||\n+                std::is_same_v<ToDataType, DataTypeUUID>)\n             {\n                 ret = createWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n                 return true;\n@@ -2558,14 +2753,6 @@ class FunctionCast final : public IFunctionBaseImpl\n                 ret = createDecimalWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()));\n                 return true;\n             }\n-            if constexpr (std::is_same_v<ToDataType, DataTypeUUID>)\n-            {\n-                if (isStringOrFixedString(from_type))\n-                {\n-                    ret = createUUIDWrapper(from_type, checkAndGetDataType<ToDataType>(to_type.get()), requested_result_is_nullable);\n-                    return true;\n-                }\n-            }\n \n             return false;\n         };\n@@ -2591,20 +2778,91 @@ class FunctionCast final : public IFunctionBaseImpl\n                 break;\n         }\n \n-        throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() + \" is not supported\",\n-            ErrorCodes::CANNOT_CONVERT_TYPE};\n+        if (cast_type == CastType::accurateOrNull)\n+            return createToNullableColumnWrapper();\n+        else\n+            throw Exception{\"Conversion from \" + from_type->getName() + \" to \" + to_type->getName() + \" is not supported\",\n+                ErrorCodes::CANNOT_CONVERT_TYPE};\n     }\n };\n \n+class MonotonicityHelper\n+{\n+public:\n+    using MonotonicityForRange = FunctionCast::MonotonicityForRange;\n+\n+    template <typename DataType>\n+    static auto monotonicityForType(const DataType * const)\n+    {\n+        return FunctionTo<DataType>::Type::Monotonic::get;\n+    }\n+\n+    static MonotonicityForRange getMonotonicityInformation(const DataTypePtr & from_type, const IDataType * to_type)\n+    {\n+        if (const auto type = checkAndGetDataType<DataTypeUInt8>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeUInt16>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeUInt32>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeUInt64>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeUInt256>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt8>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt16>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt32>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt64>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt128>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeInt256>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeFloat32>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeFloat64>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeDate>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeDateTime>(to_type))\n+            return monotonicityForType(type);\n+        if (const auto type = checkAndGetDataType<DataTypeString>(to_type))\n+            return monotonicityForType(type);\n+        if (isEnum(from_type))\n+        {\n+            if (const auto type = checkAndGetDataType<DataTypeEnum8>(to_type))\n+                return monotonicityForType(type);\n+            if (const auto type = checkAndGetDataType<DataTypeEnum16>(to_type))\n+                return monotonicityForType(type);\n+        }\n+        /// other types like Null, FixedString, Array and Tuple have no monotonicity defined\n+        return {};\n+    }\n+};\n+\n+template<CastType cast_type>\n class CastOverloadResolver : public IFunctionOverloadResolverImpl\n {\n public:\n     using MonotonicityForRange = FunctionCast::MonotonicityForRange;\n     using Diagnostic = FunctionCast::Diagnostic;\n \n-    static constexpr auto name = \"CAST\";\n+    static constexpr auto accurate_cast_name = \"accurateCast\";\n+    static constexpr auto accurate_cast_or_null_name = \"accurateCastOrNull\";\n+    static constexpr auto cast_name = \"CAST\";\n+\n+    static constexpr auto name = cast_type == CastType::accurate\n+        ? accurate_cast_name\n+        : (cast_type == CastType::accurateOrNull ? accurate_cast_or_null_name : cast_name);\n+\n+    static FunctionOverloadResolverImplPtr create(const Context & context)\n+    {\n+        return createImpl(context.getSettingsRef().cast_keep_nullable);\n+    }\n \n-    static FunctionOverloadResolverImplPtr create(const Context & context);\n     static FunctionOverloadResolverImplPtr createImpl(bool keep_nullable, std::optional<Diagnostic> diagnostic = {})\n     {\n         return std::make_unique<CastOverloadResolver>(keep_nullable, std::move(diagnostic));\n@@ -2630,8 +2888,8 @@ class CastOverloadResolver : public IFunctionOverloadResolverImpl\n         for (size_t i = 0; i < arguments.size(); ++i)\n             data_types[i] = arguments[i].type;\n \n-        auto monotonicity = getMonotonicityInformation(arguments.front().type, return_type.get());\n-        return std::make_unique<FunctionCast>(name, std::move(monotonicity), data_types, return_type, diagnostic);\n+        auto monotonicity = MonotonicityHelper::getMonotonicityInformation(arguments.front().type, return_type.get());\n+        return std::make_unique<FunctionCast>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n     }\n \n     DataTypePtr getReturnType(const ColumnsWithTypeAndName & arguments) const override\n@@ -2649,9 +2907,17 @@ class CastOverloadResolver : public IFunctionOverloadResolverImpl\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         DataTypePtr type = DataTypeFactory::instance().get(type_col->getValue<String>());\n-        if (keep_nullable && arguments.front().type->isNullable())\n+\n+        if constexpr (cast_type == CastType::accurateOrNull)\n+        {\n             return makeNullable(type);\n-        return type;\n+        }\n+        else\n+        {\n+            if (keep_nullable && arguments.front().type->isNullable())\n+                return makeNullable(type);\n+            return type;\n+        }\n     }\n \n     bool useDefaultImplementationForNulls() const override { return false; }\n@@ -2660,57 +2926,6 @@ class CastOverloadResolver : public IFunctionOverloadResolverImpl\n private:\n     bool keep_nullable;\n     std::optional<Diagnostic> diagnostic;\n-\n-    template <typename DataType>\n-    static auto monotonicityForType(const DataType * const)\n-    {\n-        return FunctionTo<DataType>::Type::Monotonic::get;\n-    }\n-\n-    static MonotonicityForRange getMonotonicityInformation(const DataTypePtr & from_type, const IDataType * to_type)\n-    {\n-        if (const auto * type = checkAndGetDataType<DataTypeUInt8>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeUInt16>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeUInt32>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeUInt64>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeUInt256>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt8>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt16>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt32>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt64>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt128>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeInt256>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeFloat32>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeFloat64>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeDate>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeDateTime>(to_type))\n-            return monotonicityForType(type);\n-        if (const auto * type = checkAndGetDataType<DataTypeString>(to_type))\n-            return monotonicityForType(type);\n-        if (isEnum(from_type))\n-        {\n-            if (const auto * type = checkAndGetDataType<DataTypeEnum8>(to_type))\n-                return monotonicityForType(type);\n-            if (const auto * type = checkAndGetDataType<DataTypeEnum16>(to_type))\n-                return monotonicityForType(type);\n-        }\n-        /// other types like Null, FixedString, Array and Tuple have no monotonicity defined\n-        return {};\n-    }\n };\n \n }\ndiff --git a/src/Functions/toFixedString.h b/src/Functions/toFixedString.h\nindex de1ff7e80842..23c9e92faaf0 100644\n--- a/src/Functions/toFixedString.h\n+++ b/src/Functions/toFixedString.h\n@@ -5,6 +5,8 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnNullable.h>\n #include <IO/WriteHelpers.h>\n \n \n@@ -18,6 +20,11 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n }\n \n+enum class ConvertToFixedStringExceptionMode\n+{\n+    Throw,\n+    Null\n+};\n \n /** Conversion to fixed string is implemented only for strings.\n   */\n@@ -55,13 +62,22 @@ class FunctionToFixedString : public IFunction\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n         const auto n = arguments[1].column->getUInt(0);\n-        return executeForN(arguments, n);\n+        return executeForN<ConvertToFixedStringExceptionMode::Throw>(arguments, n);\n     }\n \n+    template<ConvertToFixedStringExceptionMode exception_mode>\n     static ColumnPtr executeForN(const ColumnsWithTypeAndName & arguments, const size_t n)\n     {\n         const auto & column = arguments[0].column;\n \n+        ColumnUInt8::MutablePtr col_null_map_to;\n+        ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n+        if constexpr (exception_mode == ConvertToFixedStringExceptionMode::Null)\n+        {\n+            col_null_map_to = ColumnUInt8::create(column->size(), false);\n+            vec_null_map_to = &col_null_map_to->getData();\n+        }\n+\n         if (const auto * column_string = checkAndGetColumn<ColumnString>(column.get()))\n         {\n             auto column_fixed = ColumnFixedString::create(n);\n@@ -77,18 +93,42 @@ class FunctionToFixedString : public IFunction\n                 const size_t off = i ? in_offsets[i - 1] : 0;\n                 const size_t len = in_offsets[i] - off - 1;\n                 if (len > n)\n-                    throw Exception(\"String too long for type FixedString(\" + toString(n) + \")\",\n-                        ErrorCodes::TOO_LARGE_STRING_SIZE);\n+                {\n+                    if constexpr (exception_mode == ConvertToFixedStringExceptionMode::Throw)\n+                    {\n+                        throw Exception(\"String too long for type FixedString(\" + toString(n) + \")\",\n+                            ErrorCodes::TOO_LARGE_STRING_SIZE);\n+                    }\n+                    else\n+                    {\n+                        (*vec_null_map_to)[i] = true;\n+                        continue;\n+                    }\n+                }\n                 memcpy(&out_chars[i * n], &in_chars[off], len);\n             }\n \n-            return column_fixed;\n+            if constexpr (exception_mode == ConvertToFixedStringExceptionMode::Null)\n+                return ColumnNullable::create(std::move(column_fixed), std::move(col_null_map_to));\n+            else\n+                return column_fixed;\n         }\n         else if (const auto * column_fixed_string = checkAndGetColumn<ColumnFixedString>(column.get()))\n         {\n             const auto src_n = column_fixed_string->getN();\n             if (src_n > n)\n-                throw Exception{\"String too long for type FixedString(\" + toString(n) + \")\", ErrorCodes::TOO_LARGE_STRING_SIZE};\n+            {\n+                if constexpr (exception_mode == ConvertToFixedStringExceptionMode::Throw)\n+                {\n+                    throw Exception{\"String too long for type FixedString(\" + toString(n) + \")\", ErrorCodes::TOO_LARGE_STRING_SIZE};\n+                }\n+                else\n+                {\n+                    auto column_fixed = ColumnFixedString::create(n);\n+                    std::fill(vec_null_map_to->begin(), vec_null_map_to->end(), true);\n+                    return ColumnNullable::create(column_fixed->cloneResized(column->size()), std::move(col_null_map_to));\n+                }\n+            }\n \n             auto column_fixed = ColumnFixedString::create(n);\n \n@@ -103,7 +143,16 @@ class FunctionToFixedString : public IFunction\n             return column_fixed;\n         }\n         else\n-            throw Exception(\"Unexpected column: \" + column->getName(), ErrorCodes::ILLEGAL_COLUMN);\n+        {\n+            if constexpr (exception_mode == ConvertToFixedStringExceptionMode::Throw)\n+                throw Exception(\"Unexpected column: \" + column->getName(), ErrorCodes::ILLEGAL_COLUMN);\n+            else\n+            {\n+                auto column_fixed = ColumnFixedString::create(n);\n+                std::fill(vec_null_map_to->begin(), vec_null_map_to->end(), true);\n+                return ColumnNullable::create(column_fixed->cloneResized(column->size()), std::move(col_null_map_to));\n+            }\n+        }\n     }\n };\n \ndiff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 75915bdad1a5..62cb60477046 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -662,10 +662,10 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n             auto * right_arg = const_cast<Node *>(&actions_dag->addColumn(std::move(column), true));\n             auto * left_arg = src_node;\n \n-            CastOverloadResolver::Diagnostic diagnostic = {src_node->result_name, res_elem.name};\n+            FunctionCast::Diagnostic diagnostic = {src_node->result_name, res_elem.name};\n             FunctionOverloadResolverPtr func_builder_cast =\n                     std::make_shared<FunctionOverloadResolverAdaptor>(\n-                            CastOverloadResolver::createImpl(false, std::move(diagnostic)));\n+                            CastOverloadResolver<CastType::nonAccurate>::createImpl(false, std::move(diagnostic)));\n \n             Inputs children = { left_arg, right_arg };\n             src_node = &actions_dag->addFunction(func_builder_cast, std::move(children), {}, true);\ndiff --git a/src/Interpreters/Set.cpp b/src/Interpreters/Set.cpp\nindex 08e6107590e7..dcf7b3b3c24a 100644\n--- a/src/Interpreters/Set.cpp\n+++ b/src/Interpreters/Set.cpp\n@@ -23,6 +23,7 @@\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/NullableUtils.h>\n #include <Interpreters/sortBlock.h>\n+#include <Interpreters/castColumn.h>\n #include <Interpreters/Context.h>\n \n #include <Storages/MergeTree/KeyCondition.h>\n@@ -30,7 +31,6 @@\n #include <ext/range.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n \n-\n namespace DB\n {\n \n@@ -251,11 +251,26 @@ ColumnPtr Set::execute(const Block & block, bool negative) const\n \n     /// The constant columns to the left of IN are not supported directly. For this, they first materialize.\n     Columns materialized_columns;\n+    materialized_columns.reserve(num_key_columns);\n \n     for (size_t i = 0; i < num_key_columns; ++i)\n     {\n-        checkTypesEqual(i, block.safeGetByPosition(i).type);\n-        materialized_columns.emplace_back(block.safeGetByPosition(i).column->convertToFullColumnIfConst());\n+        ColumnPtr result;\n+\n+        const auto & column_before_cast = block.safeGetByPosition(i);\n+        ColumnWithTypeAndName column_to_cast\n+            = {column_before_cast.column->convertToFullColumnIfConst(), column_before_cast.type, column_before_cast.name};\n+\n+        if (!transform_null_in && data_types[i]->canBeInsideNullable())\n+        {\n+            result = castColumnAccurateOrNull(column_to_cast, data_types[i]);\n+        }\n+        else\n+        {\n+            result = castColumnAccurate(column_to_cast, data_types[i]);\n+        }\n+\n+        materialized_columns.emplace_back() = result;\n         key_columns.emplace_back() = materialized_columns.back().get();\n     }\n \ndiff --git a/src/Interpreters/castColumn.cpp b/src/Interpreters/castColumn.cpp\nindex 249538ec2e0b..e8f8bd3bed13 100644\n--- a/src/Interpreters/castColumn.cpp\n+++ b/src/Interpreters/castColumn.cpp\n@@ -1,15 +1,12 @@\n-#include <Core/Field.h>\n #include <Interpreters/castColumn.h>\n-#include <Interpreters/ExpressionActions.h>\n-#include <DataTypes/DataTypeString.h>\n-#include <Functions/IFunctionAdaptors.h>\n-#include <Functions/FunctionsConversion.h>\n \n+#include <Functions/FunctionsConversion.h>\n \n namespace DB\n {\n \n-ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n+template <CastType cast_type = CastType::nonAccurate>\n+static ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n {\n     if (arg.type->equals(*type))\n         return arg.column;\n@@ -25,10 +22,33 @@ ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type\n     };\n \n     FunctionOverloadResolverPtr func_builder_cast =\n-        std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver::createImpl(false));\n+        std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver<cast_type>::createImpl(false));\n \n     auto func_cast = func_builder_cast->build(arguments);\n-    return func_cast->execute(arguments, type, arg.column->size());\n+\n+    if constexpr (cast_type == CastType::accurateOrNull)\n+    {\n+        return func_cast->execute(arguments, makeNullable(type), arg.column->size());\n+    }\n+    else\n+    {\n+        return func_cast->execute(arguments, type, arg.column->size());\n+    }\n+}\n+\n+ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n+{\n+    return castColumn<CastType::nonAccurate>(arg, type);\n+}\n+\n+ColumnPtr castColumnAccurate(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n+{\n+    return castColumn<CastType::accurate>(arg, type);\n+}\n+\n+ColumnPtr castColumnAccurateOrNull(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n+{\n+    return castColumn<CastType::accurateOrNull>(arg, type);\n }\n \n }\ndiff --git a/src/Interpreters/castColumn.h b/src/Interpreters/castColumn.h\nindex 44c7f071c267..fcbea0f46465 100644\n--- a/src/Interpreters/castColumn.h\n+++ b/src/Interpreters/castColumn.h\n@@ -2,8 +2,11 @@\n \n #include <Core/ColumnWithTypeAndName.h>\n \n-\n namespace DB\n {\n+\n ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type);\n+ColumnPtr castColumnAccurate(const ColumnWithTypeAndName & arg, const DataTypePtr & type);\n+ColumnPtr castColumnAccurateOrNull(const ColumnWithTypeAndName & arg, const DataTypePtr & type);\n+\n }\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 5903dc89e9bd..ead93a6e1d9d 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -1135,7 +1135,7 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, const Context & cont\n                         ColumnsWithTypeAndName arguments{\n                             {nullptr, key_expr_type, \"\"}, {DataTypeString().createColumnConst(1, common_type->getName()), common_type, \"\"}};\n                         FunctionOverloadResolverPtr func_builder_cast\n-                                = std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver::createImpl(false));\n+                                = std::make_shared<FunctionOverloadResolverAdaptor>(CastOverloadResolver<CastType::nonAccurate>::createImpl(false));\n                         auto func_cast = func_builder_cast->build(arguments);\n \n                         /// If we know the given range only contains one value, then we treat all functions as positive monotonic.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01322_cast_keep_nullable.reference b/tests/queries/0_stateless/01322_cast_keep_nullable.reference\nindex 8ad99a101709..cfe80a7c1b14 100644\n--- a/tests/queries/0_stateless/01322_cast_keep_nullable.reference\n+++ b/tests/queries/0_stateless/01322_cast_keep_nullable.reference\n@@ -4,6 +4,7 @@\n 1\tNullable(Int32)\n 2\tNullable(Float32)\n 2\tNullable(UInt8)\n+00000000-0000-0002-0000-000000000000\tNullable(UUID)\n 3\tNullable(Int32)\n \\N\tNullable(Int32)\n 42\tNullable(Int32)\ndiff --git a/tests/queries/0_stateless/01322_cast_keep_nullable.sql b/tests/queries/0_stateless/01322_cast_keep_nullable.sql\nindex 109187174693..ef5f5747a7df 100644\n--- a/tests/queries/0_stateless/01322_cast_keep_nullable.sql\n+++ b/tests/queries/0_stateless/01322_cast_keep_nullable.sql\n@@ -10,7 +10,7 @@ SELECT CAST(toNullable(toInt8(1)) AS Int32) as x, toTypeName(x);\n \n SELECT CAST(toNullable(toFloat32(2)), 'Float32') as x, toTypeName(x);\n SELECT CAST(toNullable(toFloat32(2)), 'UInt8') as x, toTypeName(x);\n-SELECT CAST(toNullable(toFloat32(2)), 'UUID') as x, toTypeName(x); -- { serverError 70 }\n+SELECT CAST(toNullable(toFloat32(2)), 'UUID') as x, toTypeName(x);\n \n SELECT CAST(if(1 = 1, toNullable(toInt8(3)), NULL) AS Int32) as x, toTypeName(x);\n SELECT CAST(if(1 = 0, toNullable(toInt8(3)), NULL) AS Int32) as x, toTypeName(x);\ndiff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\nnew file mode 100644\nindex 000000000000..4287c755c3f3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n@@ -0,0 +1,30 @@\n+\\N\n+5\n+\\N\n+\\N\n+5\n+\\N\n+\\N\n+5\n+\\N\n+\\N\n+5\n+\\N\n+5\n+\\N\n+5\n+\\N\n+\\N\n+1.000000000\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\nnew file mode 100644\nindex 000000000000..b11ed5939faf\n--- /dev/null\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n@@ -0,0 +1,35 @@\n+SELECT accurateCastOrNull(-1, 'UInt8');\n+SELECT accurateCastOrNull(5, 'UInt8');\n+SELECT accurateCastOrNull(257, 'UInt8');\n+SELECT accurateCastOrNull(-1, 'UInt16');\n+SELECT accurateCastOrNull(5, 'UInt16');\n+SELECT accurateCastOrNull(65536, 'UInt16');\n+SELECT accurateCastOrNull(-1, 'UInt32');\n+SELECT accurateCastOrNull(5, 'UInt32');\n+SELECT accurateCastOrNull(4294967296, 'UInt32');\n+SELECT accurateCastOrNull(-1, 'UInt64');\n+SELECT accurateCastOrNull(5, 'UInt64');\n+SELECT accurateCastOrNull(-1, 'UInt256');\n+SELECT accurateCastOrNull(5, 'UInt256');\n+\n+SELECT accurateCastOrNull(-129, 'Int8');\n+SELECT accurateCastOrNull(5, 'Int8');\n+SELECT accurateCastOrNull(128, 'Int8');\n+\n+SELECT accurateCastOrNull(10, 'Decimal32(9)');\n+SELECT accurateCastOrNull(1, 'Decimal32(9)');\n+SELECT accurateCastOrNull(-10, 'Decimal32(9)');\n+\n+SELECT accurateCastOrNull('123', 'FixedString(2)');\n+\n+SELECT accurateCastOrNull(inf, 'Int64');\n+SELECT accurateCastOrNull(inf, 'Int128');\n+SELECT accurateCastOrNull(inf, 'Int256');\n+SELECT accurateCastOrNull(nan, 'Int64');\n+SELECT accurateCastOrNull(nan, 'Int128');\n+SELECT accurateCastOrNull(nan, 'Int256');\n+\n+SELECT accurateCastOrNull(inf, 'UInt64');\n+SELECT accurateCastOrNull(inf, 'UInt256');\n+SELECT accurateCastOrNull(nan, 'UInt64');\n+SELECT accurateCastOrNull(nan, 'UInt256');\ndiff --git a/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.reference b/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.reference\ndeleted file mode 100644\nindex 37883cc6c47c..000000000000\n--- a/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.reference\n+++ /dev/null\n@@ -1,6 +0,0 @@\n--9223372036854775808\n-170141183460469231731687303715884105727\n--9223372036854775808\n-170141183460469231731687303715884105727\n-0\n-0\ndiff --git a/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.sql b/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.sql\ndeleted file mode 100644\nindex b28fc80774fe..000000000000\n--- a/tests/queries/0_stateless/01581_to_int256_uint256_inf_nan.sql\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-SELECT toInt64(inf);\n-SELECT toInt128(inf);\n-SELECT toInt256(inf); -- { serverError 48 }\n-SELECT toInt64(nan);\n-SELECT toInt128(nan);\n-SELECT toInt256(nan); -- { serverError 48 }\n-SELECT toUInt64(inf);\n-SELECT toUInt256(inf); -- { serverError 48 }\n-SELECT toUInt64(nan);\n-SELECT toUInt256(nan); -- { serverError 48 }\ndiff --git a/tests/queries/0_stateless/01581_to_int_inf_nan.reference b/tests/queries/0_stateless/01581_to_int_inf_nan.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01581_to_int_inf_nan.sql b/tests/queries/0_stateless/01581_to_int_inf_nan.sql\nnew file mode 100644\nindex 000000000000..4959b4d61e96\n--- /dev/null\n+++ b/tests/queries/0_stateless/01581_to_int_inf_nan.sql\n@@ -0,0 +1,10 @@\n+SELECT toInt64(inf); -- { serverError 70 }\n+SELECT toInt128(inf); -- { serverError 70 }\n+SELECT toInt256(inf); -- { serverError 70 }\n+SELECT toInt64(nan); -- { serverError 70 }\n+SELECT toInt128(nan); -- { serverError 70 }\n+SELECT toInt256(nan); -- { serverError 70 }\n+SELECT toUInt64(inf); -- { serverError 70 }\n+SELECT toUInt256(inf); -- { serverError 70 }\n+SELECT toUInt64(nan); -- { serverError 70 }\n+SELECT toUInt256(nan); -- { serverError 70 }\ndiff --git a/tests/queries/0_stateless/01600_select_in_different_types.reference b/tests/queries/0_stateless/01600_select_in_different_types.reference\nnew file mode 100644\nindex 000000000000..626fb1527446\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_select_in_different_types.reference\n@@ -0,0 +1,11 @@\n+1\n+0\n+1\n+1\n+2\n+2\n+1\n+1\n+1\n+0\n+0\ndiff --git a/tests/queries/0_stateless/01600_select_in_different_types.sql b/tests/queries/0_stateless/01600_select_in_different_types.sql\nnew file mode 100644\nindex 000000000000..25d37c122e08\n--- /dev/null\n+++ b/tests/queries/0_stateless/01600_select_in_different_types.sql\n@@ -0,0 +1,35 @@\n+SELECT 1 IN (SELECT 1);\n+SELECT -1 IN (SELECT 1);\n+\n+DROP TABLE IF EXISTS select_in_test;\n+\n+CREATE TABLE select_in_test(value UInt8) ENGINE=TinyLog;\n+INSERT INTO select_in_test VALUES (1), (2), (3);\n+\n+SELECT value FROM select_in_test WHERE value IN (-1);\n+SELECT value FROM select_in_test WHERE value IN (SELECT -1);\n+\n+SELECT value FROM select_in_test WHERE value IN (1);\n+SELECT value FROM select_in_test WHERE value IN (SELECT 1);\n+\n+DROP TABLE select_in_test;\n+\n+CREATE TABLE select_in_test(value Int8) ENGINE=TinyLog;\n+INSERT INTO select_in_test VALUES (-1), (2), (3);\n+\n+SELECT value FROM select_in_test WHERE value IN (1);\n+SELECT value FROM select_in_test WHERE value IN (SELECT 1);\n+\n+SELECT value FROM select_in_test WHERE value IN (2);\n+SELECT value FROM select_in_test WHERE value IN (SELECT 2);\n+\n+DROP TABLE select_in_test;\n+\n+SELECT 1 IN (1);\n+SELECT '1' IN (SELECT 1);\n+\n+SELECT 1 IN (SELECT 1) SETTINGS transform_null_in = 1;\n+SELECT 1 IN (SELECT 'a') SETTINGS transform_null_in = 1;\n+SELECT 'a' IN (SELECT 1) SETTINGS transform_null_in = 1; -- { serverError 6 }\n+SELECT 1 IN (SELECT -1) SETTINGS transform_null_in = 1;\n+SELECT -1 IN (SELECT 1) SETTINGS transform_null_in = 1; -- { serverError 70 }\ndiff --git a/tests/queries/0_stateless/01601_accurate_cast.reference b/tests/queries/0_stateless/01601_accurate_cast.reference\nnew file mode 100644\nindex 000000000000..6ccedbdcfeaf\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_accurate_cast.reference\n@@ -0,0 +1,8 @@\n+5\n+5\n+5\n+5\n+5\n+5\n+1.000000000\n+12\ndiff --git a/tests/queries/0_stateless/01601_accurate_cast.sql b/tests/queries/0_stateless/01601_accurate_cast.sql\nnew file mode 100644\nindex 000000000000..b5fd4fb04a43\n--- /dev/null\n+++ b/tests/queries/0_stateless/01601_accurate_cast.sql\n@@ -0,0 +1,24 @@\n+SELECT accurateCast(-1, 'UInt8'); -- { serverError 70 }\n+SELECT accurateCast(5, 'UInt8');\n+SELECT accurateCast(257, 'UInt8'); -- { serverError 70 }\n+SELECT accurateCast(-1, 'UInt16'); -- { serverError 70 }\n+SELECT accurateCast(5, 'UInt16');\n+SELECT accurateCast(65536, 'UInt16'); -- { serverError 70 }\n+SELECT accurateCast(-1, 'UInt32'); -- { serverError 70 }\n+SELECT accurateCast(5, 'UInt32');\n+SELECT accurateCast(4294967296, 'UInt32'); -- { serverError 70 }\n+SELECT accurateCast(-1, 'UInt64'); -- { serverError 70 }\n+SELECT accurateCast(5, 'UInt64');\n+SELECT accurateCast(-1, 'UInt256'); -- { serverError 70 }\n+SELECT accurateCast(5, 'UInt256');\n+\n+SELECT accurateCast(-129, 'Int8'); -- { serverError 70 }\n+SELECT accurateCast(5, 'Int8');\n+SELECT accurateCast(128, 'Int8'); -- { serverError 70 }\n+\n+SELECT accurateCast(10, 'Decimal32(9)'); -- { serverError 407 }\n+SELECT accurateCast(1, 'Decimal32(9)');\n+SELECT accurateCast(-10, 'Decimal32(9)'); -- { serverError 407 }\n+\n+SELECT accurateCast('123', 'FixedString(2)'); -- { serverError 131 }\n+SELECT accurateCast('12', 'FixedString(2)');\n",
  "problem_statement": "Add function accurateCastOrNull.\n**Use case**\r\nThis function is needed to implement #10266\r\n\r\n**Describe the solution you'd like**\r\nThe function is like `cast` but always returns nullable type and returns NULL if the casted value is not representable in the target type.\r\n\r\nExample:\r\n\r\n```\r\naccurateCastOrNull(-1, 'UInt8')\r\nNULL\r\n\r\ncast(-1, 'UInt8')\r\n255\r\n```\nAllow different types inside IN subquery.\n**Use case**\r\n`SELECT 1 IN (SELECT -1)`\r\n\r\nThis task it not trivial as it looks.\r\n\r\nWe can apply conversion for left hand side to the type of right hand side.\r\nBut this will lead to strange artifacts: `SELECT 257 IN (SELECT 1)` will return true.\r\n\r\nWe can apply conversion to the lest common type, but we create the set only one time but may use it in different context, e.g:\r\n`SELECT 1 IN (SELECT 18446744073709551615), -1 IN (SELECT 18446744073709551615)`\n",
  "hints_text": "Look at `convertFieldToType` for the pecularities of implementation.\n",
  "created_at": "2020-11-05T19:11:02Z"
}