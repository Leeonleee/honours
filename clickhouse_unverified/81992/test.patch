diff --git a/src/Common/tests/gtest_optimize_re.cpp b/src/Common/tests/gtest_optimize_re.cpp
index b0d66d7486df..dc22a3c6b703 100644
--- a/src/Common/tests/gtest_optimize_re.cpp
+++ b/src/Common/tests/gtest_optimize_re.cpp
@@ -4,59 +4,62 @@
 
 TEST(OptimizeRE, analyze)
 {
-    auto test_f = [](const std::string & regexp, const std::string & required, std::vector<std::string> expect_alternatives = {}, bool trival_expected = false, bool prefix_expected = false)
+    auto test_f = [](const std::string & regexp,
+                     const std::string & required,
+                     std::vector<std::string> expect_alternatives = {},
+                     bool trival_expected = false,
+                     bool has_capture_expected = false,
+                     bool prefix_expected = false)
     {
-        std::string answer;
-        bool is_trivial;
-        bool is_prefix;
-        std::vector<std::string> alternatives;
-        OptimizedRegularExpression::analyze(regexp, answer, is_trivial, is_prefix, alternatives);
+        auto [answer, is_trivial, has_capture, is_prefix, alternatives] = OptimizedRegularExpression::analyze(regexp);
         std::cerr << regexp << std::endl;
         EXPECT_EQ(required, answer);
         EXPECT_EQ(alternatives, expect_alternatives);
         EXPECT_EQ(is_trivial, trival_expected);
+        EXPECT_EQ(has_capture, has_capture_expected);
         EXPECT_EQ(is_prefix, prefix_expected);
     };
-    test_f("abc", "abc", {}, true, true);
-    test_f("c([^k]*)de", "");
+    test_f("abc", "abc", {}, true, false, true);
+    test_f("c([^k]*)de", "", {}, false, true, false);
     test_f("a|XYZ", "", {"a", "XYZ"});
     test_f("XYZ|a", "", {"XYZ", "a"});
     test_f("[Ff]|XYZ", "", {"", "XYZ"});
     test_f("XYZ|[Ff]", "", {"XYZ", ""});
     test_f("XYZ|ABC|[Ff]", "", {"XYZ", "ABC", ""});
-    test_f("(?-s)bob", "bob", {}, false, true);
-    test_f("(?s)bob", "bob", {}, false, true);
+    test_f("(?-s)bob", "bob", {}, false, true, true);
+    test_f("(?s)bob", "bob", {}, false, true, true);
     test_f("(?ssss", "");
-    test_f("abc(de)fg", "abcdefg", {}, false, true);
-    test_f("abc(de|xyz)fg", "abc", {"abcdefg", "abcxyzfg"}, false, true);
-    test_f("abc(de?f|xyz)fg", "abc", {"abcd", "abcxyzfg"}, false, true);
+    test_f("[asdf]ss(?:ss)ss", "ssssss");
+    test_f("abc(de)fg", "abcdefg", {}, false, true, true);
+    test_f("abc(de|xyz)fg", "abc", {"abcdefg", "abcxyzfg"}, false, true, true);
+    test_f("abc(de?f|xyz)fg", "abc", {"abcd", "abcxyzfg"}, false, true, true);
     test_f("abc|fgk|xyz", "", {"abc","fgk", "xyz"});
-    test_f("(abc)", "abc", {}, false, true);
-    test_f("(abc|fgk)", "", {"abc","fgk"});
-    test_f("(abc|fgk)(e|f|zkh|)", "", {"abc","fgk"});
-    test_f("abc(abc|fg)xyzz", "xyzz", {"abcabcxyzz","abcfgxyzz"});
-    test_f("((abc|fg)kkk*)xyzz", "xyzz", {"abckk", "fgkk"});
-    test_f("abc(*(abc|fg)*)xyzz", "xyzz");
+    test_f("(abc)", "abc", {}, false, true, true);
+    test_f("(abc|fgk)", "", {"abc","fgk"}, false, true, false);
+    test_f("(abc|fgk)(e|f|zkh|)", "", {"abc","fgk"}, false, true, false);
+    test_f("abc(abc|fg)xyzz", "xyzz", {"abcabcxyzz","abcfgxyzz"}, false, true, false);
+    test_f("((abc|fg)kkk*)xyzz", "xyzz", {"abckk", "fgkk"}, false, true, false);
+    test_f("abc(*(abc|fg)*)xyzz", "xyzz", {}, false, true, false);
     test_f("abc[k]xyzz", "xyzz");
-    test_f("(abc[k]xyzz)", "xyzz");
-    test_f("abc((de)fg(hi))jk", "abcdefghijk", {}, false, true);
-    test_f("abc((?:de)fg(?:hi))jk", "abcdefghijk", {}, false, true);
-    test_f("abc((de)fghi+zzz)jk", "abcdefghi", {}, false, true);
-    test_f("abc((de)fg(hi))?jk", "abc", {}, false, true);
-    test_f("abc((de)fghi?zzz)jk", "abcdefgh", {}, false, true);
-    test_f("abc(*cd)jk", "cdjk");
-    test_f(R"(abc(de|xyz|(\{xx\}))fg)", "abc", {"abcdefg", "abcxyzfg", "abc{xx}fg"}, false, true);
-    test_f("abc(abc|fg)?xyzz", "xyzz");
-    test_f("abc(abc|fg){0,1}xyzz", "xyzz");
+    test_f("(abc[k]xyzz)", "xyzz", {}, false, true, false);
+    test_f("abc((de)fg(hi))jk", "abcdefghijk", {}, false, true, true);
+    test_f("abc((?:de)fg(?:hi))jk", "abcdefghijk", {}, false, true, true);
+    test_f("abc((de)fghi+zzz)jk", "abcdefghi", {}, false, true, true);
+    test_f("abc((de)fg(hi))?jk", "abc", {}, false, true, true);
+    test_f("abc((de)fghi?zzz)jk", "abcdefgh", {}, false, true, true);
+    test_f("abc(*cd)jk", "cdjk", {}, false, true, false);
+    test_f(R"(abc(de|xyz|(\{xx\}))fg)", "abc", {"abcdefg", "abcxyzfg", "abc{xx}fg"}, false, true, true);
+    test_f("abc(abc|fg)?xyzz", "xyzz", {}, false, true, false);
+    test_f("abc(abc|fg){0,1}xyzz", "xyzz", {}, false, true, false);
     test_f("abc(abc|fg)xyzz|bcdd?k|bc(f|g|h?)z", "", {"abcabcxyzz", "abcfgxyzz", "bcd", "bc"});
-    test_f("abc(abc|fg)xyzz|bc(dd?x|kk?y|(f))k|bc(f|g|h?)z", "", {"abcabcxyzz", "abcfgxyzz", "bcd", "bck", "bcfk", "bc"});
-    test_f("((?:abc|efg|xyz)/[a-zA-Z0-9]{1-50})(/?[^ ]*|)", "", {"abc/", "efg/", "xyz/"});
+    test_f("abc(abc|fg)xyzz|bc(dd?x|kk?y|(f))k|bc(f|g|h?)z", "", {"abcabcxyzz", "abcfgxyzz", "bcd", "bck", "bcfk", "bc"}, false, true, false);
+    test_f("((?:abc|efg|xyz)/[a-zA-Z0-9]{1-50})(/?[^ ]*|)", "", {"abc/", "efg/", "xyz/"}, false, true, false);
     test_f(R"([Bb]ai[Dd]u[Ss]pider(?:-[A-Za-z]{1,30})(?:-[A-Za-z]{1,30}|)|bingbot|\bYeti(?:-[a-z]{1,30}|)|Catchpoint(?: bot|)|[Cc]harlotte|Daumoa(?:-feedfetcher|)|(?:[a-zA-Z]{1,30}-|)Googlebot(?:-[a-zA-Z]{1,30}|))", "", {"pider-", "bingbot", "Yeti-", "Yeti", "Catchpoint bot", "Catchpoint", "harlotte", "Daumoa-feedfetcher", "Daumoa", "-Googlebot", "Googlebot"});
     test_f("abc|(:?xx|yy|zz|x?)def", "", {"abc", "def"});
     test_f("abc|(:?xx|yy|zz|x?){1,2}def", "", {"abc", "def"});
     test_f(R"(\\A(?:(?:[-0-9_a-z]+(?:\\.[-0-9_a-z]+)*)/k8s1)\\z)", "/k8s1");
-    test_f("[a-zA-Z]+(?P<num>\\d+)", "");
-    test_f("[a-zA-Z]+(?<num>\\d+)", "");
-    test_f("[a-zA-Z]+(?'num'\\d+)", "");
-    test_f("[a-zA-Z]+(?x<num>\\d+)", "x<num>");
+    test_f("[a-zA-Z]+(?P<num>\\d+)", "", {}, false, true, false);
+    test_f("[a-zA-Z]+(?<num>\\d+)", "", {}, false, true, false);
+    test_f("[a-zA-Z]+(?'num'\\d+)", "", {}, false, true, false);
+    test_f("[a-zA-Z]+(?x<num>\\d+)", "x<num>", {}, false, true, false);
 }
diff --git a/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference
new file mode 100644
index 000000000000..54c9b5d8fda7
--- /dev/null
+++ b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference
@@ -0,0 +1,152 @@
+-- { echo ON }
+
+SET enable_analyzer = 1;
+SET optimize_rewrite_regexp_functions = 1;
+-- Rule 1: replaceRegexpAll / regexp_replace -> replaceRegexpOne if pattern without alternatives starts with ^ or ends with unescaped $
+
+-- Starts with ^ (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '^abc', '');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc\', \'\') AS `regexp_replace(identity(\'abc123\'), \'^abc\', \'\')`
+FROM system.one AS __table1
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^abc', '');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'^abc\', \'\')`
+FROM system.one AS __table1
+-- Ends with unescaped $ (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '123$', '');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'123$\', \'\') AS `regexp_replace(identity(\'abc123\'), \'123$\', \'\')`
+FROM system.one AS __table1
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$', '');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'123$\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'123$\', \'\')`
+FROM system.one AS __table1
+-- Ends with escaped $ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123$'), '123\$', '');
+SELECT replaceRegexpAll(identity(\'abc123$\'), \'123\\\\$\', \'\') AS `replaceRegexpAll(identity(\'abc123$\'), \'123\\\\\\\\$\', \'\')`
+FROM system.one AS __table1
+-- Starts with escaped ^ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '\^abc', '');
+SELECT replaceRegexpAll(identity(\'abc123\'), \'\\\\^abc\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'\\\\\\\\^abc\', \'\')`
+FROM system.one AS __table1
+-- Pattern with ^ not at start (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), 'a^bc', '');
+SELECT replaceRegexpAll(identity(\'abc123\'), \'a^bc\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'a^bc\', \'\')`
+FROM system.one AS __table1
+-- Pattern with $ not at end (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$abc', '');
+SELECT replaceRegexpAll(identity(\'abc123\'), \'123$abc\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'123$abc\', \'\')`
+FROM system.one AS __table1
+-- Pattern with alternatives (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^123|456$', '');
+SELECT replaceRegexpAll(identity(\'abc123\'), \'^123|456$\', \'\') AS `replaceRegexpAll(identity(\'abc123\'), \'^123|456$\', \'\')`
+FROM system.one AS __table1
+-- Rule 2: If a replaceRegexpOne function has a replacement of nothing other than \1 and some subpatterns in the regexp, or \0 and no subpatterns in the regexp, rewrite it with extract.
+
+-- NOTE: \0 is specially treated as NUL instead of capture group reference. Need to use \\0 instead.
+
+-- Only \0, no capture group (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', '\\0');
+SELECT extract(identity(\'abc123\'), \'^abc123$\') AS `replaceRegexpOne(identity(\'abc123\'), \'^abc123$\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- Only \1, with one capture group (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\1');
+SELECT extract(identity(\'abc123\'), \'^(abc)$\') AS `replaceRegexpOne(identity(\'abc123\'), \'^(abc)$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- Only \1, no capture group (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc$', '\1');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc$\', \'\\\\1\') AS `replaceRegexpOne(identity(\'abc123\'), \'^abc$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc', '\\0');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc\', \'\\\\0\') AS `replaceRegexpOne(identity(\'abc123\'), \'^abc\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc$', '\\0');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'abc$\', \'\\\\0\') AS `replaceRegexpOne(identity(\'abc123\'), \'abc$\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc', '\\0');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'abc\', \'\\\\0\') AS `replaceRegexpOne(identity(\'abc123\'), \'abc\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc\\$', '\\0');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc\\\\$\', \'\\\\0\') AS `replaceRegexpOne(identity(\'abc123\'), \'^abc\\\\\\\\$\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^ab|c$', '\\0');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^ab|c$\', \'\\\\0\') AS `replaceRegexpOne(identity(\'abc123\'), \'^ab|c$\', \'\\\\\\\\0\')`
+FROM system.one AS __table1
+-- \0 with extra characters (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', 'pre\\0post');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^abc123$\', \'pre\\\\0post\') AS `replaceRegexpOne(identity(\'abc123\'), \'^abc123$\', \'pre\\\\\\\\0post\')`
+FROM system.one AS __table1
+-- \1 with two capture groups (should rewrite — only \1 used)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\1');
+SELECT extract(identity(\'abc123\'), \'^(a)(b)$\') AS `replaceRegexpOne(identity(\'abc123\'), \'^(a)(b)$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- \2 used (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\2');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^(a)(b)$\', \'\\\\2\') AS `replaceRegexpOne(identity(\'abc123\'), \'^(a)(b)$\', \'\\\\\\\\2\')`
+FROM system.one AS __table1
+-- Mixed content in replacement (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', 'X\1Y');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^(abc)$\', \'X\\\\1Y\') AS `replaceRegexpOne(identity(\'abc123\'), \'^(abc)$\', \'X\\\\\\\\1Y\')`
+FROM system.one AS __table1
+-- Escaped backslash in replacement (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\\\1');
+SELECT replaceRegexpOne(identity(\'abc123\'), \'^(abc)$\', \'\\\\\\\\1\') AS `replaceRegexpOne(identity(\'abc123\'), \'^(abc)$\', \'\\\\\\\\\\\\\\\\1\')`
+FROM system.one AS __table1
+-- Rule 3: If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an unescaped .*$, remove this prefix and/or suffix.
+
+-- Starts with ^.* (should strip prefix)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(123)');
+SELECT extract(identity(\'abc123\'), \'(123)\') AS `extract(identity(\'abc123\'), \'^.*(123)\')`
+FROM system.one AS __table1
+-- Ends with unescaped .*$ (should strip suffix)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*$');
+SELECT extract(identity(\'abc123\'), \'(abc)\') AS `extract(identity(\'abc123\'), \'(abc).*$\')`
+FROM system.one AS __table1
+-- Starts and ends (should strip both)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(abc).*$');
+SELECT extract(identity(\'abc123\'), \'(abc)\') AS `extract(identity(\'abc123\'), \'^.*(abc).*$\')`
+FROM system.one AS __table1
+-- Starts and ends (should NOT rewrite without capture groups)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*$');
+SELECT extract(identity(\'abc123\'), \'^.*$\') AS `extract(identity(\'abc123\'), \'^.*$\')`
+FROM system.one AS __table1
+-- Escaped dot before * (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)\.*$');
+SELECT extract(identity(\'abc123\'), \'(abc)\\\\.*$\') AS `extract(identity(\'abc123\'), \'(abc)\\\\\\\\.*$\')`
+FROM system.one AS __table1
+-- No prefix or suffix (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)');
+SELECT extract(identity(\'abc123\'), \'(abc)\') AS `extract(identity(\'abc123\'), \'(abc)\')`
+FROM system.one AS __table1
+-- Starts with .* but not ^.* (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '.*(abc)');
+SELECT extract(identity(\'abc123\'), \'.*(abc)\') AS `extract(identity(\'abc123\'), \'.*(abc)\')`
+FROM system.one AS __table1
+-- Starts with ^.*? (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123abc456'), '^.*?(abc.*)');
+SELECT extract(identity(\'abc123abc456\'), \'^.*?(abc.*)\') AS `extract(identity(\'abc123abc456\'), \'^.*?(abc.*)\')`
+FROM system.one AS __table1
+-- Ends with .* but not .*$ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*');
+SELECT extract(identity(\'abc123\'), \'(abc).*\') AS `extract(identity(\'abc123\'), \'(abc).*\')`
+FROM system.one AS __table1
+-- Cascade tests
+
+-- Rule 1 + Rule 2: replaceRegexpAll to replaceRegexpOne to extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^(abc)', '\1');
+SELECT replaceRegexpOne(identity(\'abc\'), \'^(abc)\', \'\\\\1\') AS `replaceRegexpAll(identity(\'abc\'), \'^(abc)\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- Rule 2 + 3: replaceRegexpOne -> extract -> simplified extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc'), '^.*(abc).*$','\1');
+SELECT extract(identity(\'abc\'), \'(abc)\') AS `replaceRegexpOne(identity(\'abc\'), \'^.*(abc).*$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- Rule 1 + 2 + 3: replaceRegexpAll -> replaceRegexpOne -> extract -> simplified extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^.*(abc).*$','\1');
+SELECT extract(identity(\'abc\'), \'(abc)\') AS `replaceRegexpAll(identity(\'abc\'), \'^.*(abc).*$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
+-- ClickBench Q28
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT REGEXP_REPLACE(identity('some referer'), '^https?://(?:www\.)?([^/]+)/.*$', '\1');
+SELECT extract(identity(\'some referer\'), \'^https?://(?:www\\\\.)?([^/]+)/\') AS `REGEXP_REPLACE(identity(\'some referer\'), \'^https?://(?:www\\\\\\\\.)?([^/]+)/.*$\', \'\\\\\\\\1\')`
+FROM system.one AS __table1
diff --git a/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql
new file mode 100644
index 000000000000..e5f37eb54c9e
--- /dev/null
+++ b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql
@@ -0,0 +1,117 @@
+-- { echo ON }
+
+SET enable_analyzer = 1;
+SET optimize_rewrite_regexp_functions = 1;
+
+-- Rule 1: replaceRegexpAll / regexp_replace -> replaceRegexpOne if pattern without alternatives starts with ^ or ends with unescaped $
+
+-- Starts with ^ (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '^abc', '');
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^abc', '');
+
+-- Ends with unescaped $ (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '123$', '');
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$', '');
+
+-- Ends with escaped $ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123$'), '123\$', '');
+
+-- Starts with escaped ^ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '\^abc', '');
+
+-- Pattern with ^ not at start (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), 'a^bc', '');
+
+-- Pattern with $ not at end (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$abc', '');
+
+-- Pattern with alternatives (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^123|456$', '');
+
+-- Rule 2: If a replaceRegexpOne function has a replacement of nothing other than \1 and some subpatterns in the regexp, or \0 and no subpatterns in the regexp, rewrite it with extract.
+
+-- NOTE: \0 is specially treated as NUL instead of capture group reference. Need to use \\0 instead.
+
+-- Only \0, no capture group (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', '\\0');
+
+-- Only \1, with one capture group (should rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\1');
+
+-- Only \1, no capture group (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc$', '\1');
+
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc', '\\0');
+
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc$', '\\0');
+
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc', '\\0');
+
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc\\$', '\\0');
+
+-- Pattern not full (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^ab|c$', '\\0');
+
+-- \0 with extra characters (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', 'pre\\0post');
+
+-- \1 with two capture groups (should rewrite — only \1 used)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\1');
+
+-- \2 used (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\2');
+
+-- Mixed content in replacement (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', 'X\1Y');
+
+-- Escaped backslash in replacement (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\\\1');
+
+
+-- Rule 3: If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an unescaped .*$, remove this prefix and/or suffix.
+
+-- Starts with ^.* (should strip prefix)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(123)');
+
+-- Ends with unescaped .*$ (should strip suffix)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*$');
+
+-- Starts and ends (should strip both)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(abc).*$');
+
+-- Starts and ends (should NOT rewrite without capture groups)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*$');
+
+-- Escaped dot before * (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)\.*$');
+
+-- No prefix or suffix (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)');
+
+-- Starts with .* but not ^.* (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '.*(abc)');
+
+-- Starts with ^.*? (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123abc456'), '^.*?(abc.*)');
+
+-- Ends with .* but not .*$ (should NOT rewrite)
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*');
+
+
+-- Cascade tests
+
+-- Rule 1 + Rule 2: replaceRegexpAll to replaceRegexpOne to extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^(abc)', '\1');
+
+-- Rule 2 + 3: replaceRegexpOne -> extract -> simplified extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc'), '^.*(abc).*$','\1');
+
+-- Rule 1 + 2 + 3: replaceRegexpAll -> replaceRegexpOne -> extract -> simplified extract
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^.*(abc).*$','\1');
+
+-- ClickBench Q28
+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT REGEXP_REPLACE(identity('some referer'), '^https?://(?:www\.)?([^/]+)/.*$', '\1');
