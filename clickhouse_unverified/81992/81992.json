{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 81992,
  "instance_id": "ClickHouse__ClickHouse-81992",
  "issue_numbers": [
    "81981"
  ],
  "base_commit": "ead57ba15efb113eb6f343fc07183c4b07e900d8",
  "patch": "diff --git a/src/Analyzer/Passes/RegexpFunctionRewritePass.cpp b/src/Analyzer/Passes/RegexpFunctionRewritePass.cpp\nnew file mode 100644\nindex 000000000000..860c3fb71d29\n--- /dev/null\n+++ b/src/Analyzer/Passes/RegexpFunctionRewritePass.cpp\n@@ -0,0 +1,220 @@\n+#include <Analyzer/Passes/RegexpFunctionRewritePass.h>\n+\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <Analyzer/ConstantNode.h>\n+#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/Utils.h>\n+#include <Common/OptimizedRegularExpression.h>\n+#include <Core/Settings.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Interpreters/Context.h>\n+\n+namespace DB\n+{\n+\n+namespace Setting\n+{\n+    extern const SettingsBool optimize_rewrite_regexp_functions;\n+}\n+\n+namespace\n+{\n+\n+class RegexpFunctionRewriteVisitor : public InDepthQueryTreeVisitorWithContext<RegexpFunctionRewriteVisitor>\n+{\n+public:\n+    using Base = InDepthQueryTreeVisitorWithContext<RegexpFunctionRewriteVisitor>;\n+    using Base::Base;\n+\n+    void enterImpl(QueryTreeNodePtr & node)\n+    {\n+        if (!getSettings()[Setting::optimize_rewrite_regexp_functions])\n+            return;\n+\n+        auto * function_node = node->as<FunctionNode>();\n+        if (!function_node || !function_node->isOrdinaryFunction() || !isString(function_node->getResultType()))\n+            return;\n+\n+        /// If a regular expression without alternatives starts with ^ or ends with an unescaped $, rewrite\n+        /// replaceRegexpAll with replaceRegexpOne.\n+        if (function_node->getFunctionName() == \"replaceRegexpAll\" || Poco::toLower(function_node->getFunctionName()) == \"regexp_replace\")\n+        {\n+            if (!handleReplaceRegexpAll(*function_node))\n+                return;\n+\n+            /// After optimization, function_node might now be \"replaceRegexpOne\", so continue processing\n+        }\n+\n+        /// If a replaceRegexpOne function has a regexp that matches entire haystack, and a replacement of nothing other\n+        /// than \\1 and some subpatterns in the regexp, or \\0 and no subpatterns in the regexp, rewrite it with extract.\n+        if (function_node->getFunctionName() == \"replaceRegexpOne\")\n+        {\n+            if (!handleReplaceRegexpOne(*function_node))\n+                return;\n+\n+            /// After optimization, function_node might now be \"extract\", so continue processing\n+        }\n+\n+        /// If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an\n+        /// unescaped .*$, remove this prefix and/or suffix.\n+        if (function_node->getFunctionName() == \"extract\")\n+            handleExtract(*function_node);\n+    }\n+\n+private:\n+    /// Returns true if the character at pos is unescaped\n+    bool isUnescaped(const std::string & str, size_t pos)\n+    {\n+        if (pos == 0 || pos >= str.size())\n+            return true;\n+\n+        size_t backslash_count = 0;\n+        for (ssize_t i = static_cast<ssize_t>(pos) - 1; i >= 0 && str[i] == '\\\\'; --i)\n+            ++backslash_count;\n+\n+        return backslash_count % 2 == 0;\n+    }\n+\n+    bool handleReplaceRegexpAll(FunctionNode & function_node)\n+    {\n+        auto & function_node_arguments_nodes = function_node.getArguments().getNodes();\n+        if (function_node_arguments_nodes.size() != 3)\n+            return false;\n+\n+        const auto * constant_node = function_node_arguments_nodes[1]->as<ConstantNode>();\n+        if (!constant_node)\n+            return false;\n+\n+        if (auto constant_type = constant_node->getResultType(); !isString(constant_type))\n+            return false;\n+\n+        String regexp = constant_node->getValue().safeGet<String>();\n+        if (regexp.empty())\n+            return false;\n+\n+        bool starts_with_caret = regexp.front() == '^';\n+        bool ends_with_unescaped_dollar = false;\n+\n+        if (!regexp.empty() && regexp.back() == '$')\n+            ends_with_unescaped_dollar = isUnescaped(regexp, regexp.size() - 1);\n+\n+        if (!starts_with_caret && !ends_with_unescaped_dollar)\n+            return false;\n+\n+        /// Analyze the regular expression to detect presence of alternatives (e.g., 'a|b'). If any alternatives are\n+        /// found, return false to indicate the regexp is not suitable for optimization.\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(regexp);\n+        if (!result.alternatives.empty())\n+            return false;\n+\n+        resolveOrdinaryFunctionNodeByName(function_node, \"replaceRegexpOne\", getContext());\n+        return true;\n+    }\n+\n+    bool handleReplaceRegexpOne(FunctionNode & function_node)\n+    {\n+        auto & function_node_arguments_nodes = function_node.getArguments().getNodes();\n+        if (function_node_arguments_nodes.size() != 3)\n+            return false;\n+\n+        const auto * constant_node = function_node_arguments_nodes[2]->as<ConstantNode>();\n+        if (!constant_node)\n+            return false;\n+\n+        if (auto constant_type = constant_node->getResultType(); !isString(constant_type))\n+            return false;\n+\n+        String replacement = constant_node->getValue().safeGet<String>();\n+        bool replacement_zero = replacement == \"\\\\0\";\n+        bool replacement_one = replacement == \"\\\\1\";\n+        if (!replacement_zero && !replacement_one)\n+            return false;\n+\n+        const auto * regexp_node = function_node_arguments_nodes[1]->as<ConstantNode>();\n+        if (!regexp_node)\n+            return false;\n+\n+        if (auto regexp_type = regexp_node->getResultType(); !isString(regexp_type))\n+            return false;\n+\n+        String regexp = regexp_node->getValue().safeGet<String>();\n+\n+        /// Currently only look for ^...$ patterns without alternatives.\n+        bool starts_with_caret = regexp.front() == '^';\n+        if (!starts_with_caret)\n+            return false;\n+\n+        bool ends_with_unescaped_dollar = false;\n+        if (!regexp.empty() && regexp.back() == '$')\n+            ends_with_unescaped_dollar = isUnescaped(regexp, regexp.size() - 1);\n+\n+        if (!ends_with_unescaped_dollar)\n+            return false;\n+\n+        /// Analyze the regular expression to detect presence of alternatives (e.g., 'a|b'). If any alternatives are\n+        /// found, return false to indicate the regexp is not suitable for optimization.\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(regexp);\n+        if (!result.alternatives.empty())\n+            return false;\n+\n+        if ((replacement_one && result.has_capture) || (replacement_zero && !result.has_capture))\n+        {\n+            function_node_arguments_nodes.resize(2);\n+            resolveOrdinaryFunctionNodeByName(function_node, \"extract\", getContext());\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    void handleExtract(FunctionNode & function_node)\n+    {\n+        auto & function_node_arguments_nodes = function_node.getArguments().getNodes();\n+        if (function_node_arguments_nodes.size() != 2)\n+            return;\n+\n+        const auto * constant_node = function_node_arguments_nodes[1]->as<ConstantNode>();\n+        if (!constant_node)\n+            return;\n+\n+        if (auto constant_type = constant_node->getResultType(); !isString(constant_type))\n+            return;\n+\n+        String regexp = constant_node->getValue().safeGet<String>();\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(regexp);\n+        if (!result.has_capture)\n+            return;\n+\n+        /// For simplicity, this optimization ignores alternations and only considers anchoring at the start or end of the pattern.\n+        bool starts_with_caret_dot_star = regexp.starts_with(\"^.*\") && !regexp.starts_with(\"^.*?\");\n+        bool ends_with_unescaped_dot_star_dollar = false;\n+\n+        if (regexp.size() >= 3 && regexp.ends_with(\".*$\"))\n+        {\n+            size_t dot_pos = regexp.size() - 3;\n+            ends_with_unescaped_dot_star_dollar = isUnescaped(regexp, dot_pos);\n+        }\n+\n+        if (starts_with_caret_dot_star || ends_with_unescaped_dot_star_dollar)\n+        {\n+            if (starts_with_caret_dot_star)\n+                regexp = regexp.substr(3);\n+            if (ends_with_unescaped_dot_star_dollar && regexp.ends_with(\".*$\"))\n+                regexp = regexp.substr(0, regexp.size() - 3);\n+            function_node_arguments_nodes[1] = std::make_shared<ConstantNode>(std::move(regexp));\n+        }\n+    }\n+};\n+\n+}\n+\n+void RegexpFunctionRewritePass::run(QueryTreeNodePtr & query_tree_node, ContextPtr context)\n+{\n+    RegexpFunctionRewriteVisitor visitor(context);\n+    visitor.visit(query_tree_node);\n+}\n+\n+}\ndiff --git a/src/Analyzer/Passes/RegexpFunctionRewritePass.h b/src/Analyzer/Passes/RegexpFunctionRewritePass.h\nnew file mode 100644\nindex 000000000000..c034d82c3165\n--- /dev/null\n+++ b/src/Analyzer/Passes/RegexpFunctionRewritePass.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+\n+#include <Analyzer/IQueryTreePass.h>\n+\n+namespace DB\n+{\n+\n+/// 1. If a regular expression without alternatives starts with ^ or ends with an unescaped $, rewrite replaceRegexpAll\n+/// with replaceRegexpOne.\n+///\n+/// 2. If a replaceRegexpOne function has a regexp that matches entire haystack, and a replacement of nothing other than\n+/// \\1 and some subpatterns in the regexp, or \\0 and no subpatterns in the regexp, rewrite it with extract.\n+///\n+/// 3. If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an\n+/// unescaped .*$, remove this prefix and/or suffix.\n+class RegexpFunctionRewritePass final : public IQueryTreePass\n+{\n+public:\n+    String getName() override { return \"RegexpFunctionRewrite\"; }\n+\n+    String getDescription() override { return \"Rewrite regexp related functions into more efficient forms.\"; }\n+\n+    void run(QueryTreeNodePtr & query_tree_node, ContextPtr context) override;\n+\n+};\n+\n+}\ndiff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp\nindex af01ff69a482..a818ad348020 100644\n--- a/src/Analyzer/QueryTreePassManager.cpp\n+++ b/src/Analyzer/QueryTreePassManager.cpp\n@@ -40,6 +40,7 @@\n #include <Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.h>\n #include <Analyzer/Passes/OrderByTupleEliminationPass.h>\n #include <Analyzer/Passes/QueryAnalysisPass.h>\n+#include <Analyzer/Passes/RegexpFunctionRewritePass.h>\n #include <Analyzer/Passes/RemoveUnusedProjectionColumnsPass.h>\n #include <Analyzer/Passes/RewriteAggregateFunctionWithIfPass.h>\n #include <Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.h>\n@@ -263,6 +264,7 @@ void addQueryTreePasses(QueryTreePassManager & manager, bool only_analyze)\n     manager.addPass(std::make_unique<FunctionToSubcolumnsPass>());\n \n     manager.addPass(std::make_unique<ConvertLogicalExpressionToCNFPass>());\n+    manager.addPass(std::make_unique<RegexpFunctionRewritePass>());\n \n     manager.addPass(std::make_unique<RewriteSumFunctionWithSumAndCountPass>());\n     manager.addPass(std::make_unique<CountDistinctPass>());\ndiff --git a/src/Common/OptimizedRegularExpression.cpp b/src/Common/OptimizedRegularExpression.cpp\nindex dbba8b5c8cf9..3ed95a7e85a7 100644\n--- a/src/Common/OptimizedRegularExpression.cpp\n+++ b/src/Common/OptimizedRegularExpression.cpp\n@@ -68,6 +68,7 @@ const char * analyzeImpl(\n     const char * pos,\n     Literal & required_substring,\n     bool & is_trivial,\n+    bool & has_capture,\n     Literals & global_alternatives)\n {\n     checkStackSize();\n@@ -85,6 +86,7 @@ const char * analyzeImpl(\n     bool is_first_call = begin == regexp.data();\n     int depth = 0;\n     is_trivial = true;\n+    has_capture = false;\n     bool is_prefix = true;\n     required_substring.clear();\n     bool has_alternative_on_depth_0 = false;\n@@ -244,6 +246,8 @@ const char * analyzeImpl(\n                 is_trivial = false;\n                 if (!in_square_braces)\n                 {\n+                    bool is_non_capturing_group = false;\n+\n                     /// it means flag negation\n                     /// there are various possible flags\n                     /// actually only imsU are supported by re2\n@@ -271,6 +275,7 @@ const char * analyzeImpl(\n                         /// if this group only contains flags, we have nothing to do.\n                         if (*pos == ')')\n                         {\n+                            has_capture = true;\n                             ++pos;\n                             break;\n                         }\n@@ -278,20 +283,25 @@ const char * analyzeImpl(\n                     /// (?:regex) means non-capturing parentheses group\n                     else if (pos + 2 < end && pos[1] == '?' && pos[2] == ':')\n                     {\n+                        is_non_capturing_group = true;\n                         pos += 2;\n                     }\n                     else if (pos + 3 < end && pos[1] == '?' && (pos[2] == '<' || pos[2] == '\\'' || (pos[2] == 'P' && pos[3] == '<')))\n                     {\n+                        has_capture = true;\n                         pos = skipNameCapturingGroup(pos, pos[2] == 'P' ? 3: 2, end);\n                     }\n                     Literal group_required_substr;\n                     bool group_is_trival = true;\n+                    bool group_has_capture;\n                     Literals group_alters;\n-                    pos = analyzeImpl(regexp, pos + 1, group_required_substr, group_is_trival, group_alters);\n+                    pos = analyzeImpl(regexp, pos + 1, group_required_substr, group_is_trival, group_has_capture, group_alters);\n                     /// pos should be ')', if not, then it is not a valid regular expression\n                     if (pos == end)\n                         return pos;\n \n+                    has_capture = !is_non_capturing_group;\n+\n                     /// For ()? or ()* or (){0,1}, we can just ignore the whole group.\n                     if ((pos + 1 < end && (pos[1] == '?' || pos[1] == '*')) ||\n                         (pos + 2 < end && pos[1] == '{' && pos[2] == '0'))\n@@ -423,10 +433,14 @@ const char * analyzeImpl(\n         /// compare the quality of required substring and alternatives and choose the better one.\n         if (global_alternatives.empty() || shortest_literal_length(global_alternatives) < required_substring.literal.size())\n             global_alternatives = {required_substring};\n-        Literals next_alternatives;\n         /// this two vals are useless, xxx|xxx cannot be trivial nor prefix.\n+        Literals next_alternatives;\n         bool next_is_trivial = true;\n-        pos = analyzeImpl(regexp, pos, required_substring, next_is_trivial, next_alternatives);\n+        bool next_has_capture;\n+        pos = analyzeImpl(regexp, pos, required_substring, next_is_trivial, next_has_capture, next_alternatives);\n+\n+        /// has_capture is true when all alternatives have captures\n+        has_capture &= next_has_capture;\n         /// For xxx|xxx|xxx, we only combine the alternatives and return a empty required_substring.\n         if (next_alternatives.empty() || shortest_literal_length(next_alternatives) < required_substring.literal.size())\n         {\n@@ -450,41 +464,37 @@ const char * analyzeImpl(\n }\n }\n \n-void OptimizedRegularExpression::analyze(\n-        std::string_view regexp_,\n-        std::string & required_substring,\n-        bool & is_trivial,\n-        bool & required_substring_is_prefix,\n-        std::vector<std::string> & alternatives)\n+RegexpAnalysisResult OptimizedRegularExpression::analyze(std::string_view regexp_)\n try\n {\n+    RegexpAnalysisResult r;\n     Literals alternative_literals;\n     Literal required_literal;\n-    analyzeImpl(regexp_, regexp_.data(), required_literal, is_trivial, alternative_literals); // NOLINT\n-    required_substring = std::move(required_literal.literal);\n-    required_substring_is_prefix = required_literal.prefix;\n+    analyzeImpl(regexp_, regexp_.data(), required_literal, r.is_trivial, r.has_capture, alternative_literals); // NOLINT\n+    r.required_substring = std::move(required_literal.literal);\n+    r.required_substring_is_prefix = required_literal.prefix;\n     for (auto & lit : alternative_literals)\n-        alternatives.push_back(std::move(lit.literal));\n+        r.alternatives.push_back(std::move(lit.literal));\n+    return r;\n }\n catch (...)\n {\n-    required_substring = \"\";\n-    is_trivial = false;\n-    required_substring_is_prefix = false;\n-    alternatives.clear();\n-    LOG_ERROR(getLogger(\"OptimizeRegularExpression\"), \"Analyze RegularExpression failed, got error: {}\", DB::getCurrentExceptionMessage(false));\n+    LOG_ERROR(\n+        getLogger(\"OptimizeRegularExpression\"), \"Analyze RegularExpression failed, got error: {}\", DB::getCurrentExceptionMessage(false));\n+    return {};\n }\n \n OptimizedRegularExpression::OptimizedRegularExpression(const std::string & regexp_, int options)\n {\n-    std::vector<std::string> alternatives_dummy; /// this vector extracts patterns a,b,c from pattern (a|b|c). for now it's not used.\n-    analyze(regexp_, required_substring, is_trivial, required_substring_is_prefix, alternatives_dummy);\n-\n-\n     /// Just three following options are supported\n     if (options & (~(RE_CASELESS | RE_NO_CAPTURE | RE_DOT_NL)))\n         throw DB::Exception(DB::ErrorCodes::CANNOT_COMPILE_REGEXP, \"OptimizedRegularExpression: Unsupported option.\");\n \n+    RegexpAnalysisResult result = analyze(regexp_);\n+    required_substring = result.required_substring;\n+    is_trivial = result.is_trivial;\n+    has_capture = result.has_capture;\n+    required_substring_is_prefix = result.required_substring_is_prefix;\n     is_case_insensitive = options & RE_CASELESS;\n     bool is_no_capture = options & RE_NO_CAPTURE;\n     bool is_dot_nl = options & RE_DOT_NL;\n@@ -543,10 +553,10 @@ OptimizedRegularExpression::OptimizedRegularExpression(const std::string & regex\n }\n \n OptimizedRegularExpression::OptimizedRegularExpression(OptimizedRegularExpression && rhs) noexcept\n-    : is_trivial(rhs.is_trivial)\n+    : required_substring(std::move(rhs.required_substring))\n+    , is_trivial(rhs.is_trivial)\n     , required_substring_is_prefix(rhs.required_substring_is_prefix)\n     , is_case_insensitive(rhs.is_case_insensitive)\n-    , required_substring(std::move(rhs.required_substring))\n     , re2(std::move(rhs.re2))\n     , number_of_subpatterns(rhs.number_of_subpatterns)\n {\ndiff --git a/src/Common/OptimizedRegularExpression.h b/src/Common/OptimizedRegularExpression.h\nindex b3b4b9497b5c..24cbf43003a4 100644\n--- a/src/Common/OptimizedRegularExpression.h\n+++ b/src/Common/OptimizedRegularExpression.h\n@@ -35,6 +35,15 @@ namespace OptimizedRegularExpressionDetails\n     };\n }\n \n+struct RegexpAnalysisResult\n+{\n+    std::string required_substring;\n+    bool is_trivial = false;\n+    bool has_capture = false;\n+    bool required_substring_is_prefix = false;\n+    std::vector<std::string> alternatives;\n+};\n+\n class OptimizedRegularExpression\n {\n public:\n@@ -91,18 +100,14 @@ class OptimizedRegularExpression\n \n     /// analyze function will extract the longest string literal or multiple alternative string literals from regexp for pre-checking if\n     /// a string contains the string literal(s). If not, we can tell this string can never match the regexp.\n-    static void analyze(\n-        std::string_view regexp_,\n-        std::string & required_substring,\n-        bool & is_trivial,\n-        bool & required_substring_is_prefix,\n-        std::vector<std::string> & alternatives);\n+    static RegexpAnalysisResult analyze(std::string_view regexp_);\n \n private:\n+    std::string required_substring;\n     bool is_trivial;\n+    bool has_capture;\n     bool required_substring_is_prefix;\n     bool is_case_insensitive;\n-    std::string required_substring;\n     std::optional<DB::ASCIICaseSensitiveStringSearcher> case_sensitive_substring_searcher;\n     std::optional<DB::ASCIICaseInsensitiveStringSearcher> case_insensitive_substring_searcher;\n     std::unique_ptr<re2::RE2> re2;\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex a52266a8fdd1..eea5ed705897 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5040,6 +5040,9 @@ Supported only with the analyzer (`enable_analyzer = 1`).\n )\", 0) \\\n     DECLARE(Bool, optimize_rewrite_array_exists_to_has, false, R\"(\n Rewrite arrayExists() functions to has() when logically equivalent. For example, arrayExists(x -> x = 1, arr) can be rewritten to has(arr, 1)\n+)\", 0) \\\n+    DECLARE(Bool, optimize_rewrite_regexp_functions, true, R\"(\n+Rewrite regular expression related functions into simpler and more efficient forms\n )\", 0) \\\n     DECLARE(UInt64, insert_shard_id, 0, R\"(\n If not `0`, specifies the shard of [Distributed](/engines/table-engines/special/distributed) table into which the data will be inserted synchronously.\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex cdcc3f7310ff..4343f6927ec6 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -41,6 +41,7 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n         /// Note: please check if the key already exists to prevent duplicate entries.\n         addSettingsChanges(settings_changes_history, \"25.8\",\n         {\n+            {\"optimize_rewrite_regexp_functions\", false, true, \"A new setting\"},\n             {\"max_joined_block_size_bytes\", 0, 4 * 1024 * 1024, \"New setting\"},\n             {\"azure_max_single_part_upload_size\", 100 * 1024 * 1024, 32 * 1024 * 1024, \"Align with S3\"},\n             {\"azure_max_redirects\", 10, 10, \"New setting\"},\ndiff --git a/src/Dictionaries/RegExpTreeDictionary.cpp b/src/Dictionaries/RegExpTreeDictionary.cpp\nindex b59e0a5e3f74..665d9049ccf8 100644\n--- a/src/Dictionaries/RegExpTreeDictionary.cpp\n+++ b/src/Dictionaries/RegExpTreeDictionary.cpp\n@@ -246,30 +246,26 @@ void RegExpTreeDictionary::initRegexNodes(Block & block)\n         regex_nodes.emplace(id, node);\n \n #if USE_VECTORSCAN\n-        String required_substring;\n-        bool is_trivial;\n-        bool required_substring_is_prefix;\n-        std::vector<std::string> alternatives;\n-\n+        RegexpAnalysisResult result;\n         if (use_vectorscan)\n-            OptimizedRegularExpression::analyze(regex, required_substring, is_trivial, required_substring_is_prefix, alternatives);\n+            result = OptimizedRegularExpression::analyze(regex);\n \n-        for (auto & alter : alternatives)\n+        for (auto & alter : result.alternatives)\n         {\n             if (alter.size() < 3)\n             {\n-                alternatives.clear();\n+                result.alternatives.clear();\n                 break;\n             }\n         }\n-        if (!required_substring.empty())\n+        if (!result.required_substring.empty())\n         {\n-            simple_regexps.push_back(required_substring);\n+            simple_regexps.push_back(result.required_substring);\n             regexp_ids.push_back(id);\n         }\n-        else if (!alternatives.empty())\n+        else if (!result.alternatives.empty())\n         {\n-            for (auto & alternative : alternatives)\n+            for (auto & alternative : result.alternatives)\n             {\n                 simple_regexps.push_back(alternative);\n                 regexp_ids.push_back(id);\ndiff --git a/src/Functions/ReplaceRegexpImpl.h b/src/Functions/ReplaceRegexpImpl.h\nindex b5572d2eaa43..03f85da6184e 100644\n--- a/src/Functions/ReplaceRegexpImpl.h\n+++ b/src/Functions/ReplaceRegexpImpl.h\n@@ -110,13 +110,8 @@ struct ReplaceRegexpImpl\n             return false;\n \n         checkSubstitutions(replacement, num_captures);\n-\n-        String required_substring;\n-        bool is_trivial;\n-        bool required_substring_is_prefix;\n-        std::vector<String> alternatives;\n-        OptimizedRegularExpression::analyze(needle, required_substring, is_trivial, required_substring_is_prefix, alternatives);\n-        return is_trivial && required_substring_is_prefix && required_substring == needle;\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(needle);\n+        return result.is_trivial && result.required_substring_is_prefix && result.required_substring == needle;\n     }\n \n     static void processString(\n@@ -227,7 +222,7 @@ struct ReplaceRegexpImpl\n         /// pattern analysis incurs some cost too.\n         if (canFallbackToStringReplacement(needle, replacement, searcher, num_captures))\n         {\n-            auto convertTrait = [](ReplaceRegexpTraits::Replace first_or_all)\n+            auto convert_trait = [](ReplaceRegexpTraits::Replace first_or_all)\n             {\n                 switch (first_or_all)\n                 {\n@@ -235,7 +230,8 @@ struct ReplaceRegexpImpl\n                     case ReplaceRegexpTraits::Replace::All:   return ReplaceStringTraits::Replace::All;\n                 }\n             };\n-            ReplaceStringImpl<Name, convertTrait(replace)>::vectorConstantConstant(haystack_data, haystack_offsets, needle, replacement, res_data, res_offsets, input_rows_count);\n+            ReplaceStringImpl<Name, convert_trait(replace)>::vectorConstantConstant(\n+                haystack_data, haystack_offsets, needle, replacement, res_data, res_offsets, input_rows_count);\n             return;\n         }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\nindex 3d168704ea69..9080553ccda6 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n@@ -637,22 +637,18 @@ bool MergeTreeConditionBloomFilterText::traverseTreeEquals(\n         out.bloom_filter = std::make_unique<BloomFilter>(params);\n \n         auto & value = const_value.safeGet<String>();\n-        String required_substring;\n-        bool dummy_is_trivial;\n-        bool dummy_required_substring_is_prefix;\n-        std::vector<String> alternatives;\n-        OptimizedRegularExpression::analyze(value, required_substring, dummy_is_trivial, dummy_required_substring_is_prefix, alternatives);\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(value);\n \n-        if (required_substring.empty() && alternatives.empty())\n+        if (result.required_substring.empty() && result.alternatives.empty())\n             return false;\n \n         /// out.set_bloom_filters means alternatives exist\n         /// out.bloom_filter means required_substring exists\n-        if (!alternatives.empty())\n+        if (!result.alternatives.empty())\n         {\n             std::vector<std::vector<BloomFilter>> bloom_filters;\n             bloom_filters.emplace_back();\n-            for (const auto & alternative : alternatives)\n+            for (const auto & alternative : result.alternatives)\n             {\n                 bloom_filters.back().emplace_back(params);\n                 token_extractor->substringToBloomFilter(alternative.data(), alternative.size(), bloom_filters.back().back(), false, false);\n@@ -660,7 +656,10 @@ bool MergeTreeConditionBloomFilterText::traverseTreeEquals(\n             out.set_bloom_filters = std::move(bloom_filters);\n         }\n         else\n-            token_extractor->substringToBloomFilter(required_substring.data(), required_substring.size(), *out.bloom_filter, false, false);\n+        {\n+            token_extractor->substringToBloomFilter(\n+                result.required_substring.data(), result.required_substring.size(), *out.bloom_filter, false, false);\n+        }\n \n         return true;\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexGin.cpp b/src/Storages/MergeTree/MergeTreeIndexGin.cpp\nindex 7ac9b348ed57..bc102b43cfa2 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexGin.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexGin.cpp\n@@ -557,22 +557,17 @@ bool MergeTreeIndexConditionGin::traverseASTEquals(\n         out.function = RPNElement::FUNCTION_MATCH;\n \n         const auto & value = const_value.safeGet<String>();\n-        String required_substring;\n-        bool dummy_is_trivial;\n-        bool dummy_required_substring_is_prefix;\n-        std::vector<String> alternatives;\n-        OptimizedRegularExpression::analyze(value, required_substring, dummy_is_trivial, dummy_required_substring_is_prefix, alternatives);\n-\n-        if (required_substring.empty() && alternatives.empty())\n+        RegexpAnalysisResult result = OptimizedRegularExpression::analyze(value);\n+        if (result.required_substring.empty() && result.alternatives.empty())\n             return false;\n \n         /// out.set_gin_filters means alternatives exist\n         /// out.gin_filter means required_substring exists\n-        if (!alternatives.empty())\n+        if (!result.alternatives.empty())\n         {\n             std::vector<GinFilters> gin_filters;\n             gin_filters.emplace_back();\n-            for (const auto & alternative : alternatives)\n+            for (const auto & alternative : result.alternatives)\n             {\n                 gin_filters.back().emplace_back();\n                 token_extractor->substringToGinFilter(alternative.data(), alternative.size(), gin_filters.back().back(), false, false);\n@@ -582,7 +577,7 @@ bool MergeTreeIndexConditionGin::traverseASTEquals(\n         else\n         {\n             out.gin_filter = std::make_unique<GinFilter>();\n-            token_extractor->substringToGinFilter(required_substring.data(), required_substring.size(), *out.gin_filter, false, false);\n+            token_extractor->substringToGinFilter(result.required_substring.data(), result.required_substring.size(), *out.gin_filter, false, false);\n         }\n \n         return true;\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_optimize_re.cpp b/src/Common/tests/gtest_optimize_re.cpp\nindex b0d66d7486df..dc22a3c6b703 100644\n--- a/src/Common/tests/gtest_optimize_re.cpp\n+++ b/src/Common/tests/gtest_optimize_re.cpp\n@@ -4,59 +4,62 @@\n \n TEST(OptimizeRE, analyze)\n {\n-    auto test_f = [](const std::string & regexp, const std::string & required, std::vector<std::string> expect_alternatives = {}, bool trival_expected = false, bool prefix_expected = false)\n+    auto test_f = [](const std::string & regexp,\n+                     const std::string & required,\n+                     std::vector<std::string> expect_alternatives = {},\n+                     bool trival_expected = false,\n+                     bool has_capture_expected = false,\n+                     bool prefix_expected = false)\n     {\n-        std::string answer;\n-        bool is_trivial;\n-        bool is_prefix;\n-        std::vector<std::string> alternatives;\n-        OptimizedRegularExpression::analyze(regexp, answer, is_trivial, is_prefix, alternatives);\n+        auto [answer, is_trivial, has_capture, is_prefix, alternatives] = OptimizedRegularExpression::analyze(regexp);\n         std::cerr << regexp << std::endl;\n         EXPECT_EQ(required, answer);\n         EXPECT_EQ(alternatives, expect_alternatives);\n         EXPECT_EQ(is_trivial, trival_expected);\n+        EXPECT_EQ(has_capture, has_capture_expected);\n         EXPECT_EQ(is_prefix, prefix_expected);\n     };\n-    test_f(\"abc\", \"abc\", {}, true, true);\n-    test_f(\"c([^k]*)de\", \"\");\n+    test_f(\"abc\", \"abc\", {}, true, false, true);\n+    test_f(\"c([^k]*)de\", \"\", {}, false, true, false);\n     test_f(\"a|XYZ\", \"\", {\"a\", \"XYZ\"});\n     test_f(\"XYZ|a\", \"\", {\"XYZ\", \"a\"});\n     test_f(\"[Ff]|XYZ\", \"\", {\"\", \"XYZ\"});\n     test_f(\"XYZ|[Ff]\", \"\", {\"XYZ\", \"\"});\n     test_f(\"XYZ|ABC|[Ff]\", \"\", {\"XYZ\", \"ABC\", \"\"});\n-    test_f(\"(?-s)bob\", \"bob\", {}, false, true);\n-    test_f(\"(?s)bob\", \"bob\", {}, false, true);\n+    test_f(\"(?-s)bob\", \"bob\", {}, false, true, true);\n+    test_f(\"(?s)bob\", \"bob\", {}, false, true, true);\n     test_f(\"(?ssss\", \"\");\n-    test_f(\"abc(de)fg\", \"abcdefg\", {}, false, true);\n-    test_f(\"abc(de|xyz)fg\", \"abc\", {\"abcdefg\", \"abcxyzfg\"}, false, true);\n-    test_f(\"abc(de?f|xyz)fg\", \"abc\", {\"abcd\", \"abcxyzfg\"}, false, true);\n+    test_f(\"[asdf]ss(?:ss)ss\", \"ssssss\");\n+    test_f(\"abc(de)fg\", \"abcdefg\", {}, false, true, true);\n+    test_f(\"abc(de|xyz)fg\", \"abc\", {\"abcdefg\", \"abcxyzfg\"}, false, true, true);\n+    test_f(\"abc(de?f|xyz)fg\", \"abc\", {\"abcd\", \"abcxyzfg\"}, false, true, true);\n     test_f(\"abc|fgk|xyz\", \"\", {\"abc\",\"fgk\", \"xyz\"});\n-    test_f(\"(abc)\", \"abc\", {}, false, true);\n-    test_f(\"(abc|fgk)\", \"\", {\"abc\",\"fgk\"});\n-    test_f(\"(abc|fgk)(e|f|zkh|)\", \"\", {\"abc\",\"fgk\"});\n-    test_f(\"abc(abc|fg)xyzz\", \"xyzz\", {\"abcabcxyzz\",\"abcfgxyzz\"});\n-    test_f(\"((abc|fg)kkk*)xyzz\", \"xyzz\", {\"abckk\", \"fgkk\"});\n-    test_f(\"abc(*(abc|fg)*)xyzz\", \"xyzz\");\n+    test_f(\"(abc)\", \"abc\", {}, false, true, true);\n+    test_f(\"(abc|fgk)\", \"\", {\"abc\",\"fgk\"}, false, true, false);\n+    test_f(\"(abc|fgk)(e|f|zkh|)\", \"\", {\"abc\",\"fgk\"}, false, true, false);\n+    test_f(\"abc(abc|fg)xyzz\", \"xyzz\", {\"abcabcxyzz\",\"abcfgxyzz\"}, false, true, false);\n+    test_f(\"((abc|fg)kkk*)xyzz\", \"xyzz\", {\"abckk\", \"fgkk\"}, false, true, false);\n+    test_f(\"abc(*(abc|fg)*)xyzz\", \"xyzz\", {}, false, true, false);\n     test_f(\"abc[k]xyzz\", \"xyzz\");\n-    test_f(\"(abc[k]xyzz)\", \"xyzz\");\n-    test_f(\"abc((de)fg(hi))jk\", \"abcdefghijk\", {}, false, true);\n-    test_f(\"abc((?:de)fg(?:hi))jk\", \"abcdefghijk\", {}, false, true);\n-    test_f(\"abc((de)fghi+zzz)jk\", \"abcdefghi\", {}, false, true);\n-    test_f(\"abc((de)fg(hi))?jk\", \"abc\", {}, false, true);\n-    test_f(\"abc((de)fghi?zzz)jk\", \"abcdefgh\", {}, false, true);\n-    test_f(\"abc(*cd)jk\", \"cdjk\");\n-    test_f(R\"(abc(de|xyz|(\\{xx\\}))fg)\", \"abc\", {\"abcdefg\", \"abcxyzfg\", \"abc{xx}fg\"}, false, true);\n-    test_f(\"abc(abc|fg)?xyzz\", \"xyzz\");\n-    test_f(\"abc(abc|fg){0,1}xyzz\", \"xyzz\");\n+    test_f(\"(abc[k]xyzz)\", \"xyzz\", {}, false, true, false);\n+    test_f(\"abc((de)fg(hi))jk\", \"abcdefghijk\", {}, false, true, true);\n+    test_f(\"abc((?:de)fg(?:hi))jk\", \"abcdefghijk\", {}, false, true, true);\n+    test_f(\"abc((de)fghi+zzz)jk\", \"abcdefghi\", {}, false, true, true);\n+    test_f(\"abc((de)fg(hi))?jk\", \"abc\", {}, false, true, true);\n+    test_f(\"abc((de)fghi?zzz)jk\", \"abcdefgh\", {}, false, true, true);\n+    test_f(\"abc(*cd)jk\", \"cdjk\", {}, false, true, false);\n+    test_f(R\"(abc(de|xyz|(\\{xx\\}))fg)\", \"abc\", {\"abcdefg\", \"abcxyzfg\", \"abc{xx}fg\"}, false, true, true);\n+    test_f(\"abc(abc|fg)?xyzz\", \"xyzz\", {}, false, true, false);\n+    test_f(\"abc(abc|fg){0,1}xyzz\", \"xyzz\", {}, false, true, false);\n     test_f(\"abc(abc|fg)xyzz|bcdd?k|bc(f|g|h?)z\", \"\", {\"abcabcxyzz\", \"abcfgxyzz\", \"bcd\", \"bc\"});\n-    test_f(\"abc(abc|fg)xyzz|bc(dd?x|kk?y|(f))k|bc(f|g|h?)z\", \"\", {\"abcabcxyzz\", \"abcfgxyzz\", \"bcd\", \"bck\", \"bcfk\", \"bc\"});\n-    test_f(\"((?:abc|efg|xyz)/[a-zA-Z0-9]{1-50})(/?[^ ]*|)\", \"\", {\"abc/\", \"efg/\", \"xyz/\"});\n+    test_f(\"abc(abc|fg)xyzz|bc(dd?x|kk?y|(f))k|bc(f|g|h?)z\", \"\", {\"abcabcxyzz\", \"abcfgxyzz\", \"bcd\", \"bck\", \"bcfk\", \"bc\"}, false, true, false);\n+    test_f(\"((?:abc|efg|xyz)/[a-zA-Z0-9]{1-50})(/?[^ ]*|)\", \"\", {\"abc/\", \"efg/\", \"xyz/\"}, false, true, false);\n     test_f(R\"([Bb]ai[Dd]u[Ss]pider(?:-[A-Za-z]{1,30})(?:-[A-Za-z]{1,30}|)|bingbot|\\bYeti(?:-[a-z]{1,30}|)|Catchpoint(?: bot|)|[Cc]harlotte|Daumoa(?:-feedfetcher|)|(?:[a-zA-Z]{1,30}-|)Googlebot(?:-[a-zA-Z]{1,30}|))\", \"\", {\"pider-\", \"bingbot\", \"Yeti-\", \"Yeti\", \"Catchpoint bot\", \"Catchpoint\", \"harlotte\", \"Daumoa-feedfetcher\", \"Daumoa\", \"-Googlebot\", \"Googlebot\"});\n     test_f(\"abc|(:?xx|yy|zz|x?)def\", \"\", {\"abc\", \"def\"});\n     test_f(\"abc|(:?xx|yy|zz|x?){1,2}def\", \"\", {\"abc\", \"def\"});\n     test_f(R\"(\\\\A(?:(?:[-0-9_a-z]+(?:\\\\.[-0-9_a-z]+)*)/k8s1)\\\\z)\", \"/k8s1\");\n-    test_f(\"[a-zA-Z]+(?P<num>\\\\d+)\", \"\");\n-    test_f(\"[a-zA-Z]+(?<num>\\\\d+)\", \"\");\n-    test_f(\"[a-zA-Z]+(?'num'\\\\d+)\", \"\");\n-    test_f(\"[a-zA-Z]+(?x<num>\\\\d+)\", \"x<num>\");\n+    test_f(\"[a-zA-Z]+(?P<num>\\\\d+)\", \"\", {}, false, true, false);\n+    test_f(\"[a-zA-Z]+(?<num>\\\\d+)\", \"\", {}, false, true, false);\n+    test_f(\"[a-zA-Z]+(?'num'\\\\d+)\", \"\", {}, false, true, false);\n+    test_f(\"[a-zA-Z]+(?x<num>\\\\d+)\", \"x<num>\", {}, false, true, false);\n }\ndiff --git a/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference\nnew file mode 100644\nindex 000000000000..54c9b5d8fda7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.reference\n@@ -0,0 +1,152 @@\n+-- { echo ON }\n+\n+SET enable_analyzer = 1;\n+SET optimize_rewrite_regexp_functions = 1;\n+-- Rule 1: replaceRegexpAll / regexp_replace -> replaceRegexpOne if pattern without alternatives starts with ^ or ends with unescaped $\n+\n+-- Starts with ^ (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '^abc', '');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\', \\'\\') AS `regexp_replace(identity(\\'abc123\\'), \\'^abc\\', \\'\\')`\n+FROM system.one AS __table1\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^abc', '');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'^abc\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Ends with unescaped $ (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '123$', '');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'123$\\', \\'\\') AS `regexp_replace(identity(\\'abc123\\'), \\'123$\\', \\'\\')`\n+FROM system.one AS __table1\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$', '');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'123$\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'123$\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Ends with escaped $ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123$'), '123\\$', '');\n+SELECT replaceRegexpAll(identity(\\'abc123$\\'), \\'123\\\\\\\\$\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123$\\'), \\'123\\\\\\\\\\\\\\\\$\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Starts with escaped ^ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '\\^abc', '');\n+SELECT replaceRegexpAll(identity(\\'abc123\\'), \\'\\\\\\\\^abc\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'\\\\\\\\\\\\\\\\^abc\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Pattern with ^ not at start (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), 'a^bc', '');\n+SELECT replaceRegexpAll(identity(\\'abc123\\'), \\'a^bc\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'a^bc\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Pattern with $ not at end (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$abc', '');\n+SELECT replaceRegexpAll(identity(\\'abc123\\'), \\'123$abc\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'123$abc\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Pattern with alternatives (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^123|456$', '');\n+SELECT replaceRegexpAll(identity(\\'abc123\\'), \\'^123|456$\\', \\'\\') AS `replaceRegexpAll(identity(\\'abc123\\'), \\'^123|456$\\', \\'\\')`\n+FROM system.one AS __table1\n+-- Rule 2: If a replaceRegexpOne function has a replacement of nothing other than \\1 and some subpatterns in the regexp, or \\0 and no subpatterns in the regexp, rewrite it with extract.\n+\n+-- NOTE: \\0 is specially treated as NUL instead of capture group reference. Need to use \\\\0 instead.\n+\n+-- Only \\0, no capture group (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', '\\\\0');\n+SELECT extract(identity(\\'abc123\\'), \\'^abc123$\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^abc123$\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- Only \\1, with one capture group (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\1');\n+SELECT extract(identity(\\'abc123\\'), \\'^(abc)$\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^(abc)$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- Only \\1, no capture group (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc$', '\\1');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc$\\', \\'\\\\\\\\1\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^abc$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc', '\\\\0');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\', \\'\\\\\\\\0\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc$', '\\\\0');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'abc$\\', \\'\\\\\\\\0\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'abc$\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc', '\\\\0');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'abc\\', \\'\\\\\\\\0\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'abc\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc\\\\$', '\\\\0');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\\\\\\\$\\', \\'\\\\\\\\0\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^abc\\\\\\\\\\\\\\\\$\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^ab|c$', '\\\\0');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^ab|c$\\', \\'\\\\\\\\0\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^ab|c$\\', \\'\\\\\\\\\\\\\\\\0\\')`\n+FROM system.one AS __table1\n+-- \\0 with extra characters (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', 'pre\\\\0post');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^abc123$\\', \\'pre\\\\\\\\0post\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^abc123$\\', \\'pre\\\\\\\\\\\\\\\\0post\\')`\n+FROM system.one AS __table1\n+-- \\1 with two capture groups (should rewrite \u2014 only \\1 used)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\\1');\n+SELECT extract(identity(\\'abc123\\'), \\'^(a)(b)$\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^(a)(b)$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- \\2 used (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\\2');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^(a)(b)$\\', \\'\\\\\\\\2\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^(a)(b)$\\', \\'\\\\\\\\\\\\\\\\2\\')`\n+FROM system.one AS __table1\n+-- Mixed content in replacement (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', 'X\\1Y');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^(abc)$\\', \\'X\\\\\\\\1Y\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^(abc)$\\', \\'X\\\\\\\\\\\\\\\\1Y\\')`\n+FROM system.one AS __table1\n+-- Escaped backslash in replacement (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\\\\\\\1');\n+SELECT replaceRegexpOne(identity(\\'abc123\\'), \\'^(abc)$\\', \\'\\\\\\\\\\\\\\\\1\\') AS `replaceRegexpOne(identity(\\'abc123\\'), \\'^(abc)$\\', \\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- Rule 3: If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an unescaped .*$, remove this prefix and/or suffix.\n+\n+-- Starts with ^.* (should strip prefix)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(123)');\n+SELECT extract(identity(\\'abc123\\'), \\'(123)\\') AS `extract(identity(\\'abc123\\'), \\'^.*(123)\\')`\n+FROM system.one AS __table1\n+-- Ends with unescaped .*$ (should strip suffix)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*$');\n+SELECT extract(identity(\\'abc123\\'), \\'(abc)\\') AS `extract(identity(\\'abc123\\'), \\'(abc).*$\\')`\n+FROM system.one AS __table1\n+-- Starts and ends (should strip both)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(abc).*$');\n+SELECT extract(identity(\\'abc123\\'), \\'(abc)\\') AS `extract(identity(\\'abc123\\'), \\'^.*(abc).*$\\')`\n+FROM system.one AS __table1\n+-- Starts and ends (should NOT rewrite without capture groups)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*$');\n+SELECT extract(identity(\\'abc123\\'), \\'^.*$\\') AS `extract(identity(\\'abc123\\'), \\'^.*$\\')`\n+FROM system.one AS __table1\n+-- Escaped dot before * (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)\\.*$');\n+SELECT extract(identity(\\'abc123\\'), \\'(abc)\\\\\\\\.*$\\') AS `extract(identity(\\'abc123\\'), \\'(abc)\\\\\\\\\\\\\\\\.*$\\')`\n+FROM system.one AS __table1\n+-- No prefix or suffix (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)');\n+SELECT extract(identity(\\'abc123\\'), \\'(abc)\\') AS `extract(identity(\\'abc123\\'), \\'(abc)\\')`\n+FROM system.one AS __table1\n+-- Starts with .* but not ^.* (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '.*(abc)');\n+SELECT extract(identity(\\'abc123\\'), \\'.*(abc)\\') AS `extract(identity(\\'abc123\\'), \\'.*(abc)\\')`\n+FROM system.one AS __table1\n+-- Starts with ^.*? (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123abc456'), '^.*?(abc.*)');\n+SELECT extract(identity(\\'abc123abc456\\'), \\'^.*?(abc.*)\\') AS `extract(identity(\\'abc123abc456\\'), \\'^.*?(abc.*)\\')`\n+FROM system.one AS __table1\n+-- Ends with .* but not .*$ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*');\n+SELECT extract(identity(\\'abc123\\'), \\'(abc).*\\') AS `extract(identity(\\'abc123\\'), \\'(abc).*\\')`\n+FROM system.one AS __table1\n+-- Cascade tests\n+\n+-- Rule 1 + Rule 2: replaceRegexpAll to replaceRegexpOne to extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^(abc)', '\\1');\n+SELECT replaceRegexpOne(identity(\\'abc\\'), \\'^(abc)\\', \\'\\\\\\\\1\\') AS `replaceRegexpAll(identity(\\'abc\\'), \\'^(abc)\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- Rule 2 + 3: replaceRegexpOne -> extract -> simplified extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc'), '^.*(abc).*$','\\1');\n+SELECT extract(identity(\\'abc\\'), \\'(abc)\\') AS `replaceRegexpOne(identity(\\'abc\\'), \\'^.*(abc).*$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- Rule 1 + 2 + 3: replaceRegexpAll -> replaceRegexpOne -> extract -> simplified extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^.*(abc).*$','\\1');\n+SELECT extract(identity(\\'abc\\'), \\'(abc)\\') AS `replaceRegexpAll(identity(\\'abc\\'), \\'^.*(abc).*$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\n+-- ClickBench Q28\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT REGEXP_REPLACE(identity('some referer'), '^https?://(?:www\\.)?([^/]+)/.*$', '\\1');\n+SELECT extract(identity(\\'some referer\\'), \\'^https?://(?:www\\\\\\\\.)?([^/]+)/\\') AS `REGEXP_REPLACE(identity(\\'some referer\\'), \\'^https?://(?:www\\\\\\\\\\\\\\\\.)?([^/]+)/.*$\\', \\'\\\\\\\\\\\\\\\\1\\')`\n+FROM system.one AS __table1\ndiff --git a/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql\nnew file mode 100644\nindex 000000000000..e5f37eb54c9e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03538_optimize_rewrite_regexp_functions.sql\n@@ -0,0 +1,117 @@\n+-- { echo ON }\n+\n+SET enable_analyzer = 1;\n+SET optimize_rewrite_regexp_functions = 1;\n+\n+-- Rule 1: replaceRegexpAll / regexp_replace -> replaceRegexpOne if pattern without alternatives starts with ^ or ends with unescaped $\n+\n+-- Starts with ^ (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '^abc', '');\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^abc', '');\n+\n+-- Ends with unescaped $ (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT regexp_replace(identity('abc123'), '123$', '');\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$', '');\n+\n+-- Ends with escaped $ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123$'), '123\\$', '');\n+\n+-- Starts with escaped ^ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '\\^abc', '');\n+\n+-- Pattern with ^ not at start (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), 'a^bc', '');\n+\n+-- Pattern with $ not at end (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '123$abc', '');\n+\n+-- Pattern with alternatives (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc123'), '^123|456$', '');\n+\n+-- Rule 2: If a replaceRegexpOne function has a replacement of nothing other than \\1 and some subpatterns in the regexp, or \\0 and no subpatterns in the regexp, rewrite it with extract.\n+\n+-- NOTE: \\0 is specially treated as NUL instead of capture group reference. Need to use \\\\0 instead.\n+\n+-- Only \\0, no capture group (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', '\\\\0');\n+\n+-- Only \\1, with one capture group (should rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\1');\n+\n+-- Only \\1, no capture group (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc$', '\\1');\n+\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc', '\\\\0');\n+\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc$', '\\\\0');\n+\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), 'abc', '\\\\0');\n+\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc\\\\$', '\\\\0');\n+\n+-- Pattern not full (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^ab|c$', '\\\\0');\n+\n+-- \\0 with extra characters (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^abc123$', 'pre\\\\0post');\n+\n+-- \\1 with two capture groups (should rewrite \u2014 only \\1 used)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\\1');\n+\n+-- \\2 used (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(a)(b)$', '\\2');\n+\n+-- Mixed content in replacement (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', 'X\\1Y');\n+\n+-- Escaped backslash in replacement (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc123'), '^(abc)$', '\\\\\\\\1');\n+\n+\n+-- Rule 3: If an extract function has a regexp with some subpatterns and the regexp starts with ^.* or ending with an unescaped .*$, remove this prefix and/or suffix.\n+\n+-- Starts with ^.* (should strip prefix)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(123)');\n+\n+-- Ends with unescaped .*$ (should strip suffix)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*$');\n+\n+-- Starts and ends (should strip both)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*(abc).*$');\n+\n+-- Starts and ends (should NOT rewrite without capture groups)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '^.*$');\n+\n+-- Escaped dot before * (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)\\.*$');\n+\n+-- No prefix or suffix (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc)');\n+\n+-- Starts with .* but not ^.* (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '.*(abc)');\n+\n+-- Starts with ^.*? (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123abc456'), '^.*?(abc.*)');\n+\n+-- Ends with .* but not .*$ (should NOT rewrite)\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT extract(identity('abc123'), '(abc).*');\n+\n+\n+-- Cascade tests\n+\n+-- Rule 1 + Rule 2: replaceRegexpAll to replaceRegexpOne to extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^(abc)', '\\1');\n+\n+-- Rule 2 + 3: replaceRegexpOne -> extract -> simplified extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpOne(identity('abc'), '^.*(abc).*$','\\1');\n+\n+-- Rule 1 + 2 + 3: replaceRegexpAll -> replaceRegexpOne -> extract -> simplified extract\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT replaceRegexpAll(identity('abc'), '^.*(abc).*$','\\1');\n+\n+-- ClickBench Q28\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT REGEXP_REPLACE(identity('some referer'), '^https?://(?:www\\.)?([^/]+)/.*$', '\\1');\n",
  "problem_statement": "A few rewrite rules for regexp functions\n### Company or project name\n\nClickHouse\n\n### Describe the situation\n\nREGEXP_REPLACE can be optimized\n\n1. If a regular expression starts with `^` or ends with an unescaped `$`, rewrite `replaceRegexpAll` with `replaceRegexpOne`.\n2. If a `replaceRegexpOne` function has a replacement of nothing other than `\\1`, or `\\0` and no subpatterns in the regexp, rewrite it with `extract`.\n3. If an `extract` function has a regexp starting with `^.*` or ending with an unescaped `.*$`, remove this prefix and/or suffix.\n\n### How to reproduce\n\n.\n\n### Expected performance\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-06-17T05:09:57Z"
}