diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md
index 6237cd6a9764..3ca36f41c78a 100644
--- a/docs/en/sql-reference/functions/type-conversion-functions.md
+++ b/docs/en/sql-reference/functions/type-conversion-functions.md
@@ -303,81 +303,44 @@ SELECT toFixedString('foo\0bar', 8) AS s, toStringCutToZero(s) AS s_cut
 └────────────┴───────┘
 ```
 
-## reinterpretAsUInt(8\|16\|32\|64) {#reinterpretasuint8163264}
+## reinterpretAs(x, T) {#type_conversion_function-cast}
 
-## reinterpretAsInt(8\|16\|32\|64) {#reinterpretasint8163264}
+Performs byte reinterpretation of ‘x’ as ‘t’ data type.
 
-## reinterpretAsFloat(32\|64) {#reinterpretasfloat3264}
-
-## reinterpretAsDate {#reinterpretasdate}
-
-## reinterpretAsDateTime {#reinterpretasdatetime}
-
-These functions accept a string and interpret the bytes placed at the beginning of the string as a number in host order (little endian). If the string isn’t long enough, the functions work as if the string is padded with the necessary number of null bytes. If the string is longer than needed, the extra bytes are ignored. A date is interpreted as the number of days since the beginning of the Unix Epoch, and a date with time is interpreted as the number of seconds since the beginning of the Unix Epoch.
-
-## reinterpretAsString {#type_conversion_functions-reinterpretAsString}
-
-This function accepts a number or date or date with time, and returns a string containing bytes representing the corresponding value in host order (little endian). Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a string that is one byte long.
-
-## reinterpretAsFixedString {#reinterpretasfixedstring}
-
-This function accepts a number or date or date with time, and returns a FixedString containing bytes representing the corresponding value in host order (little endian). Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a FixedString that is one byte long.
-
-## reinterpretAsUUID {#reinterpretasuuid}
-
-This function accepts 16 bytes string, and returns UUID containing bytes representing the corresponding value in network byte order (big-endian). If the string isn't long enough, the functions work as if the string is padded with the necessary number of null bytes to the end. If the string longer than 16 bytes, the extra bytes at the end are ignored. 
-
-**Syntax**
+Following reinterpretations are allowed:
+1. Any type that has fixed size and value of that type can be represented continuously into FixedString.
+2. Any type that if value of that type can be represented continuously into String. Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a string that is one byte long.
+3. FixedString, String, types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into FixedString,
 
 ``` sql
-reinterpretAsUUID(fixed_string)
+SELECT reinterpretAs(toInt8(-1), 'UInt8') as int_to_uint,
+    reinterpretAs(toInt8(1), 'Float32') as int_to_float,
+    reinterpretAs('1', 'UInt32') as string_to_int;
 ```
 
-**Parameters**
-
--   `fixed_string` — Big-endian byte string. [FixedString](../../sql-reference/data-types/fixedstring.md#fixedstring).
-
-**Returned value**
-
--   The UUID type value. [UUID](../../sql-reference/data-types/uuid.md#uuid-data-type).
-
-**Examples**
-
-String to UUID.
+``` text
+┌─int_to_uint─┬─int_to_float─┬─string_to_int─┐
+│         255 │        1e-45 │            49 │
+└─────────────┴──────────────┴───────────────┘
+```
 
-Query:
+## reinterpretAsUInt(8\|16\|32\|64\|256) {#reinterpretasuint8163264256}
 
-``` sql
-SELECT reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')))
-```
+## reinterpretAsInt(8\|16\|32\|64\|128\|256) {#reinterpretasint8163264128256}
 
-Result:
+## reinterpretAsFloat(32\|64) {#reinterpretasfloat3264}
 
-``` text
-┌─reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')))─┐
-│                                  08090a0b-0c0d-0e0f-0001-020304050607 │
-└───────────────────────────────────────────────────────────────────────┘
-```
+## reinterpretAsDate {#reinterpretasdate}
 
-Going back and forth from String to UUID.
+## reinterpretAsDateTime {#reinterpretasdatetime}
 
-Query:
+## reinterpretAsString {#type_conversion_functions-reinterpretAsString}
 
-``` sql
-WITH
-    generateUUIDv4() AS uuid,
-    identity(lower(hex(reverse(reinterpretAsString(uuid))))) AS str,
-    reinterpretAsUUID(reverse(unhex(str))) AS uuid2
-SELECT uuid = uuid2;
-```
+## reinterpretAsFixedString {#reinterpretasfixedstring}
 
-Result:
+## reinterpretAsUUID {#reinterpretasuuid}
 
-``` text
-┌─equals(uuid, uuid2)─┐
-│                   1 │
-└─────────────────────┘
-```
+These functions are aliases for `reinterpretAs`function.
 
 ## CAST(x, T) {#type_conversion_function-cast}
 
diff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h
index ccbccd7105ae..2d6134ab9fc8 100644
--- a/src/Core/callOnTypeIndex.h
+++ b/src/Core/callOnTypeIndex.h
@@ -207,4 +207,22 @@ bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)
     return false;
 }
 
+template <typename F>
+static bool callOnTwoTypeIndexes(TypeIndex left_type, TypeIndex right_type, F && func)
+{
+    return callOnIndexAndDataType<void>(left_type, [&](const auto & left_types) -> bool
+    {
+        using LeftTypes = std::decay_t<decltype(left_types)>;
+        using LeftType = typename LeftTypes::LeftType;
+
+        return callOnIndexAndDataType<void>(right_type, [&](const auto & right_types) -> bool
+        {
+            using RightTypes = std::decay_t<decltype(right_types)>;
+            using RightType = typename RightTypes::LeftType;
+
+            return std::forward<F>(func)(TypePair<LeftType, RightType>());
+        });
+    });
+}
+
 }
diff --git a/src/Functions/registerFunctionsReinterpret.cpp b/src/Functions/registerFunctionsReinterpret.cpp
index d82274ce9ed4..e6fa0402071d 100644
--- a/src/Functions/registerFunctionsReinterpret.cpp
+++ b/src/Functions/registerFunctionsReinterpret.cpp
@@ -4,14 +4,10 @@ namespace DB
 class FunctionFactory;
 
 void registerFunctionsReinterpretAs(FunctionFactory & factory);
-void registerFunctionReinterpretAsString(FunctionFactory & factory);
-void registerFunctionReinterpretAsFixedString(FunctionFactory & factory);
 
 void registerFunctionsReinterpret(FunctionFactory & factory)
 {
     registerFunctionsReinterpretAs(factory);
-    registerFunctionReinterpretAsString(factory);
-    registerFunctionReinterpretAsFixedString(factory);
 }
 
 }
diff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp
index 64facaf0840a..363455cb38fa 100644
--- a/src/Functions/reinterpretAs.cpp
+++ b/src/Functions/reinterpretAs.cpp
@@ -1,5 +1,8 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/castTypeToEither.h>
+#include <Functions/FunctionHelpers.h>
+
+#include <Core/callOnTypeIndex.h>
 
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeString.h>
@@ -7,6 +10,7 @@
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeUUID.h>
+#include <DataTypes/DataTypeFactory.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnConst.h>
@@ -21,178 +25,389 @@ namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int ILLEGAL_COLUMN;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
 namespace
 {
-template <typename ToDataType, typename Name, bool support_between_float_integer>
+
+/** Performs byte reinterpretation similar to reinterpret_cast.
+ *
+ * Following reinterpretations are allowed:
+ * 1. Any type that isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion into FixedString.
+ * 2. Any type that isValueUnambiguouslyRepresentedInContiguousMemoryRegion into String.
+ * 3. Types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into FixedString,
+ * String, and types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID).
+ */
 class FunctionReinterpretAs : public IFunction
 {
-    template <typename F>
-    static bool castType(const IDataType * type, F && f)
-    {
-        return castTypeToEither<DataTypeUInt32, DataTypeInt32, DataTypeUInt64, DataTypeInt64, DataTypeFloat32, DataTypeFloat64>(
-            type, std::forward<F>(f));
-    }
-
-    template <typename From, typename To>
-    static void reinterpretImpl(const PaddedPODArray<From> & from, PaddedPODArray<To> & to)
-    {
-        size_t size = from.size();
-        to.resize(size);
-        for (size_t i = 0; i < size; ++i)
-        {
-            to[i] = unalignedLoad<To>(&(from.data()[i]));
-        }
-    }
-
 public:
-    static constexpr auto name = Name::name;
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAs>(); }
+    static constexpr auto name = "reinterpretAs";
 
-    using ToFieldType = typename ToDataType::FieldType;
-    using ColumnType = typename ToDataType::ColumnType;
+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAs>(); }
 
     String getName() const override { return name; }
 
-    size_t getNumberOfArguments() const override { return 1; }
+    size_t getNumberOfArguments() const override { return 2; }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        const IDataType & type = *arguments[0];
-        if constexpr (support_between_float_integer)
-        {
-            if (!isStringOrFixedString(type) && !isNumber(type))
-                throw Exception(
-                    "Cannot reinterpret " + type.getName() + " as " + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        const auto & column = arguments.back().column;
 
-            if (isNumber(type))
-            {
-                if (type.getSizeOfValueInMemory() != ToDataType{}.getSizeOfValueInMemory())
-                    throw Exception(
-                        "Cannot reinterpret " + type.getName() + " as " + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            }
+        DataTypePtr from_type = arguments[0].type;
+
+        const auto * type_col = checkAndGetColumnConst<ColumnString>(column.get());
+        if (!type_col)
+            throw Exception("Second argument to " + getName() + " must be a constant string describing type."
+                " Instead there is non-constant column of type " + arguments.back().type->getName(),
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        DataTypePtr to_type = DataTypeFactory::instance().get(type_col->getValue<String>());
+
+        WhichDataType result_reinterpret_type(to_type);
+
+        if (result_reinterpret_type.isFixedString())
+        {
+            if (!from_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())
+                throw Exception("Cannot reinterpret " + from_type->getName() +
+                    " as FixedString because it is not fixed size and contiguous in memory",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
         }
-        else
+        else if (result_reinterpret_type.isString())
         {
-            if (!isStringOrFixedString(type))
-                throw Exception(
-                    "Cannot reinterpret " + type.getName() + " as " + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if (!from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
+                throw Exception("Cannot reinterpret " + from_type->getName() +
+                    " as String because it is not contiguous in memory",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
         }
-        return std::make_shared<ToDataType>();
-    }
+        else if (canBeReinterpretedAsNumeric(result_reinterpret_type))
+        {
+            WhichDataType from_data_type(from_type);
 
-    bool useDefaultImplementationForConstants() const override { return true; }
+            if (!canBeReinterpretedAsNumeric(from_data_type) && !from_data_type.isStringOrFixedString())
+                throw Exception("Cannot reinterpret " + from_type->getName() + " as " + to_type->getName()
+                    + " because only Numeric, String or FixedString can be reinterpreted in Numeric",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+
+        return to_type;
+    }
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override
     {
-        if (const ColumnString * col_from = typeid_cast<const ColumnString *>(arguments[0].column.get()))
+        auto from_type = arguments[0].type;
+
+        ColumnPtr result;
+
+        if (!callOnTwoTypeIndexes(from_type->getTypeId(), result_type->getTypeId(), [&](const auto & types)
         {
-            auto col_res = ColumnType::create();
+            using Types = std::decay_t<decltype(types)>;
+            using FromType = typename Types::LeftType;
+            using ToType = typename Types::RightType;
+
+            /// Place this check before std::is_same_v<FromType, ToType> because same FixedString
+            /// types does not necessary have the same byte size fixed value.
+            if constexpr (std::is_same_v<ToType, DataTypeFixedString>)
+            {
+                const IColumn & src = *arguments[0].column;
+                MutableColumnPtr dst = result_type->createColumn();
 
-            const ColumnString::Chars & data_from = col_from->getChars();
-            const ColumnString::Offsets & offsets_from = col_from->getOffsets();
-            size_t size = offsets_from.size();
-            typename ColumnType::Container & vec_res = col_res->getData();
-            vec_res.resize(size);
+                ColumnFixedString * dst_concrete = assert_cast<ColumnFixedString *>(dst.get());
 
-            size_t offset = 0;
-            for (size_t i = 0; i < size; ++i)
+                if (src.isFixedAndContiguous() && src.sizeOfValueIfFixed() == dst_concrete->getN())
+                    executeContiguousToFixedString(src, *dst_concrete, dst_concrete->getN());
+                else
+                    executeToFixedString(src, *dst_concrete, dst_concrete->getN());
+
+                result = std::move(dst);
+
+                return true;
+            }
+            else if constexpr (std::is_same_v<FromType, ToType>)
             {
-                ToFieldType value{};
-                memcpy(&value, &data_from[offset], std::min(static_cast<UInt64>(sizeof(ToFieldType)), offsets_from[i] - offset - 1));
-                vec_res[i] = value;
-                offset = offsets_from[i];
+                result = arguments[0].column;
+
+                return true;
             }
+            else if constexpr (std::is_same_v<ToType, DataTypeString>)
+            {
+                const IColumn & src = *arguments[0].column;
+                MutableColumnPtr dst = result_type->createColumn();
 
-            return col_res;
-        }
-        else if (const ColumnFixedString * col_from_fixed = typeid_cast<const ColumnFixedString *>(arguments[0].column.get()))
-        {
-            auto col_res = ColumnVector<ToFieldType>::create();
+                ColumnString * dst_concrete = assert_cast<ColumnString *>(dst.get());
+                executeToString(src, *dst_concrete);
 
-            const ColumnString::Chars & data_from = col_from_fixed->getChars();
-            size_t step = col_from_fixed->getN();
-            size_t size = data_from.size() / step;
-            typename ColumnVector<ToFieldType>::Container & vec_res = col_res->getData();
-            vec_res.resize(size);
+                result = std::move(dst);
 
-            size_t offset = 0;
-            size_t copy_size = std::min(step, sizeof(ToFieldType));
-            for (size_t i = 0; i < size; ++i)
-            {
-                ToFieldType value{};
-                memcpy(&value, &data_from[offset], copy_size);
-                vec_res[i] = value;
-                offset += step;
+                return true;
             }
+            else if constexpr (CanBeReinterpretedAsNumeric<ToType>)
+            {
+                using ToColumnType = typename ToType::ColumnType;
+                using ToFieldType = typename ToType::FieldType;
 
-            return col_res;
-        }
-        else if constexpr (support_between_float_integer)
-        {
-            ColumnPtr res;
-            if (castType(arguments[0].type.get(), [&](const auto & type)
+                if constexpr (std::is_same_v<FromType, DataTypeString>)
                 {
-                    using DataType = std::decay_t<decltype(type)>;
-                    using T = typename DataType::FieldType;
+                    const auto * col_from = assert_cast<const ColumnString *>(arguments[0].column.get());
+
+                    auto col_res = ToColumnType::create();
+
+                    const ColumnString::Chars & data_from = col_from->getChars();
+                    const ColumnString::Offsets & offsets_from = col_from->getOffsets();
+                    size_t size = offsets_from.size();
+                    typename ToColumnType::Container & vec_res = col_res->getData();
+                    vec_res.resize(size);
 
-                    const ColumnVector<T> * col = checkAndGetColumn<ColumnVector<T>>(arguments[0].column.get());
-                    auto col_res = ColumnType::create();
+                    size_t offset = 0;
+                    for (size_t i = 0; i < size; ++i)
+                    {
+                        ToFieldType value{};
+                        memcpy(&value,
+                            &data_from[offset],
+                            std::min(static_cast<UInt64>(sizeof(ToFieldType)), offsets_from[i] - offset - 1));
+                        vec_res[i] = value;
+                        offset = offsets_from[i];
+                    }
+
+                    result = std::move(col_res);
+
+                    return true;
+                }
+                else if constexpr (std::is_same_v<FromType, DataTypeFixedString>)
+                {
+                    const auto * col_from_fixed = assert_cast<const ColumnFixedString *>(arguments[0].column.get());
+
+                    auto col_res = ToColumnType::create();
+
+                    const ColumnString::Chars & data_from = col_from_fixed->getChars();
+                    size_t step = col_from_fixed->getN();
+                    size_t size = data_from.size() / step;
+                    typename ToColumnType::Container & vec_res = col_res->getData();
+                    vec_res.resize(size);
+
+                    size_t offset = 0;
+                    size_t copy_size = std::min(step, sizeof(ToFieldType));
+                    for (size_t i = 0; i < size; ++i)
+                    {
+                        ToFieldType value{};
+                        memcpy(&value, &data_from[offset], copy_size);
+                        vec_res[i] = value;
+                        offset += step;
+                    }
+
+                    result = std::move(col_res);
+
+                    return true;
+                }
+                else if constexpr (CanBeReinterpretedAsNumeric<FromType>)
+                {
+                    using FromTypeFieldType = typename FromType::FieldType;
+                    const auto * col = assert_cast<const ColumnVector<FromTypeFieldType>*>(arguments[0].column.get());
+
+                    auto col_res = ToColumnType::create();
                     reinterpretImpl(col->getData(), col_res->getData());
-                    res = std::move(col_res);
+                    result = std::move(col_res);
 
                     return true;
-                }))
-            {
-                return res;
-            }
-            else
-            {
-                throw Exception(
-                    "Illegal column " + arguments[0].column->getName() + " of argument of function " + getName(),
-                    ErrorCodes::ILLEGAL_COLUMN);
+                }
             }
+
+            return false;
+        }))
+        {
+            throw Exception("Cannot reinterpret " + from_type->getName() + " as " + result_type->getName(),
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
         }
-        else
+
+        return result;
+    }
+private:
+    template <typename T>
+    static constexpr auto CanBeReinterpretedAsNumeric =
+        IsDataTypeNumber<T> ||
+        std::is_same_v<T, DataTypeDate> ||
+        std::is_same_v<T, DataTypeDateTime> ||
+        std::is_same_v<T, DataTypeUUID>;
+
+    static bool canBeReinterpretedAsNumeric(const WhichDataType & type)
+    {
+        return type.isUInt() ||
+            type.isInt() ||
+            type.isDateOrDateTime() ||
+            type.isFloat() ||
+            type.isUUID();
+    }
+
+    static void NO_INLINE executeToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)
+    {
+        size_t rows = src.size();
+        ColumnFixedString::Chars & data_to = dst.getChars();
+        data_to.resize_fill(n * rows);
+
+        ColumnFixedString::Offset offset = 0;
+        for (size_t i = 0; i < rows; ++i)
         {
-            throw Exception(
-                "Illegal column " + arguments[0].column->getName() + " of argument of function " + getName(),
-                ErrorCodes::ILLEGAL_COLUMN);
+            StringRef data = src.getDataAt(i);
+
+            std::memcpy(&data_to[offset], data.data, std::min(n, data.size));
+            offset += n;
+        }
+    }
+
+    static void NO_INLINE executeContiguousToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)
+    {
+        size_t rows = src.size();
+        ColumnFixedString::Chars & data_to = dst.getChars();
+        data_to.resize(n * rows);
+
+        memcpy(data_to.data(), src.getRawData().data, data_to.size());
+    }
+
+    static void NO_INLINE executeToString(const IColumn & src, ColumnString & dst)
+    {
+        size_t rows = src.size();
+        ColumnString::Chars & data_to = dst.getChars();
+        ColumnString::Offsets & offsets_to = dst.getOffsets();
+        offsets_to.resize(rows);
+
+        ColumnString::Offset offset = 0;
+        for (size_t i = 0; i < rows; ++i)
+        {
+            StringRef data = src.getDataAt(i);
+
+            /// Cut trailing zero bytes.
+            while (data.size && data.data[data.size - 1] == 0)
+                --data.size;
+
+            data_to.resize(offset + data.size + 1);
+            memcpy(&data_to[offset], data.data, data.size);
+            offset += data.size;
+            data_to[offset] = 0;
+            ++offset;
+            offsets_to[i] = offset;
+        }
+    }
+
+    template <typename From, typename To>
+    static void reinterpretImpl(const PaddedPODArray<From> & from, PaddedPODArray<To> & to)
+    {
+        size_t size = from.size();
+        to.resize_fill(size);
+
+        for (size_t i = 0; i < size; ++i)
+        {
+            memcpy(static_cast<void*>(&to[i]),
+                static_cast<const void*>(&from[i]),
+                std::min(sizeof(From), sizeof(To)));
         }
     }
 };
 
+template <typename ToDataType, typename Name>
+class FunctionReinterpretAsTyped : public IFunction
+{
+public:
+    static constexpr auto name = Name::name;
+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsTyped>(); }
+
+    String getName() const override { return name; }
+
+    size_t getNumberOfArguments() const override { return 1; }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    static ColumnsWithTypeAndName addTypeColumnToArguments(const ColumnsWithTypeAndName & arguments)
+    {
+        const auto & argument = arguments[0];
+
+        DataTypePtr data_type;
+
+        if constexpr (std::is_same_v<ToDataType, DataTypeFixedString>)
+        {
+            const auto & type = argument.type;
+
+            if (!type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())
+                throw Exception("Cannot reinterpret " + type->getName() +
+                    " as FixedString because it is not fixed size and contiguous in memory",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+            size_t type_value_size_in_memory = type->getSizeOfValueInMemory();
+            data_type = std::make_shared<DataTypeFixedString>(type_value_size_in_memory);
+        }
+        else
+            data_type = std::make_shared<ToDataType>();
+
+        auto type_name_column = DataTypeString().createColumnConst(1, data_type->getName());
+        ColumnWithTypeAndName type_column(type_name_column, std::make_shared<DataTypeString>(), "");
+
+        ColumnsWithTypeAndName arguments_with_type
+        {
+            argument,
+            type_column
+        };
+
+        return arguments_with_type;
+    }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        auto arguments_with_type = addTypeColumnToArguments(arguments);
+        return impl.getReturnTypeImpl(arguments_with_type);
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type, size_t input_rows_count) const override
+    {
+        auto arguments_with_type = addTypeColumnToArguments(arguments);
+        return impl.executeImpl(arguments_with_type, return_type, input_rows_count);
+    }
+
+    FunctionReinterpretAs impl;
+};
 
 struct NameReinterpretAsUInt8       { static constexpr auto name = "reinterpretAsUInt8"; };
 struct NameReinterpretAsUInt16      { static constexpr auto name = "reinterpretAsUInt16"; };
 struct NameReinterpretAsUInt32      { static constexpr auto name = "reinterpretAsUInt32"; };
 struct NameReinterpretAsUInt64      { static constexpr auto name = "reinterpretAsUInt64"; };
+struct NameReinterpretAsUInt256     { static constexpr auto name = "reinterpretAsUInt256"; };
 struct NameReinterpretAsInt8        { static constexpr auto name = "reinterpretAsInt8"; };
 struct NameReinterpretAsInt16       { static constexpr auto name = "reinterpretAsInt16"; };
 struct NameReinterpretAsInt32       { static constexpr auto name = "reinterpretAsInt32"; };
 struct NameReinterpretAsInt64       { static constexpr auto name = "reinterpretAsInt64"; };
+struct NameReinterpretAsInt128      { static constexpr auto name = "reinterpretAsInt128"; };
+struct NameReinterpretAsInt256      { static constexpr auto name = "reinterpretAsInt256"; };
 struct NameReinterpretAsFloat32     { static constexpr auto name = "reinterpretAsFloat32"; };
 struct NameReinterpretAsFloat64     { static constexpr auto name = "reinterpretAsFloat64"; };
 struct NameReinterpretAsDate        { static constexpr auto name = "reinterpretAsDate"; };
 struct NameReinterpretAsDateTime    { static constexpr auto name = "reinterpretAsDateTime"; };
 struct NameReinterpretAsUUID        { static constexpr auto name = "reinterpretAsUUID"; };
+struct NameReinterpretAsString      { static constexpr auto name = "reinterpretAsString"; };
+struct NameReinterpretAsFixedString { static constexpr auto name = "reinterpretAsFixedString"; };
+
+using FunctionReinterpretAsUInt8 = FunctionReinterpretAsTyped<DataTypeUInt8, NameReinterpretAsUInt8>;
+using FunctionReinterpretAsUInt16 = FunctionReinterpretAsTyped<DataTypeUInt16, NameReinterpretAsUInt16>;
+using FunctionReinterpretAsUInt32 = FunctionReinterpretAsTyped<DataTypeUInt32, NameReinterpretAsUInt32>;
+using FunctionReinterpretAsUInt64 = FunctionReinterpretAsTyped<DataTypeUInt64, NameReinterpretAsUInt64>;
+using FunctionReinterpretAsUInt256 = FunctionReinterpretAsTyped<DataTypeUInt256, NameReinterpretAsUInt256>;
+using FunctionReinterpretAsInt8 = FunctionReinterpretAsTyped<DataTypeInt8, NameReinterpretAsInt8>;
+using FunctionReinterpretAsInt16 = FunctionReinterpretAsTyped<DataTypeInt16, NameReinterpretAsInt16>;
+using FunctionReinterpretAsInt32 = FunctionReinterpretAsTyped<DataTypeInt32, NameReinterpretAsInt32>;
+using FunctionReinterpretAsInt64 = FunctionReinterpretAsTyped<DataTypeInt64, NameReinterpretAsInt64>;
+using FunctionReinterpretAsInt128 = FunctionReinterpretAsTyped<DataTypeInt128, NameReinterpretAsInt128>;
+using FunctionReinterpretAsInt256 = FunctionReinterpretAsTyped<DataTypeInt256, NameReinterpretAsInt256>;
+using FunctionReinterpretAsFloat32 = FunctionReinterpretAsTyped<DataTypeFloat32, NameReinterpretAsFloat32>;
+using FunctionReinterpretAsFloat64 = FunctionReinterpretAsTyped<DataTypeFloat64, NameReinterpretAsFloat64>;
+using FunctionReinterpretAsDate = FunctionReinterpretAsTyped<DataTypeDate, NameReinterpretAsDate>;
+using FunctionReinterpretAsDateTime = FunctionReinterpretAsTyped<DataTypeDateTime, NameReinterpretAsDateTime>;
+using FunctionReinterpretAsUUID = FunctionReinterpretAsTyped<DataTypeUUID, NameReinterpretAsUUID>;
+
+using FunctionReinterpretAsString = FunctionReinterpretAsTyped<DataTypeString, NameReinterpretAsString>;
+
+using FunctionReinterpretAsFixedString = FunctionReinterpretAsTyped<DataTypeFixedString, NameReinterpretAsFixedString>;
 
-using FunctionReinterpretAsUInt8 = FunctionReinterpretAs<DataTypeUInt8, NameReinterpretAsUInt8, false>;
-using FunctionReinterpretAsUInt16 = FunctionReinterpretAs<DataTypeUInt16, NameReinterpretAsUInt16, false>;
-using FunctionReinterpretAsUInt32 = FunctionReinterpretAs<DataTypeUInt32, NameReinterpretAsUInt32, true>;
-using FunctionReinterpretAsUInt64 = FunctionReinterpretAs<DataTypeUInt64, NameReinterpretAsUInt64, true>;
-using FunctionReinterpretAsInt8 = FunctionReinterpretAs<DataTypeInt8, NameReinterpretAsInt8, false>;
-using FunctionReinterpretAsInt16 = FunctionReinterpretAs<DataTypeInt16, NameReinterpretAsInt16, false>;
-using FunctionReinterpretAsInt32 = FunctionReinterpretAs<DataTypeInt32, NameReinterpretAsInt32, true>;
-using FunctionReinterpretAsInt64 = FunctionReinterpretAs<DataTypeInt64, NameReinterpretAsInt64, true>;
-using FunctionReinterpretAsFloat32 = FunctionReinterpretAs<DataTypeFloat32, NameReinterpretAsFloat32, true>;
-using FunctionReinterpretAsFloat64 = FunctionReinterpretAs<DataTypeFloat64, NameReinterpretAsFloat64, true>;
-using FunctionReinterpretAsDate = FunctionReinterpretAs<DataTypeDate, NameReinterpretAsDate, false>;
-using FunctionReinterpretAsDateTime = FunctionReinterpretAs<DataTypeDateTime, NameReinterpretAsDateTime, false>;
-using FunctionReinterpretAsUUID = FunctionReinterpretAs<DataTypeUUID, NameReinterpretAsUUID, false>;
 }
 
 void registerFunctionsReinterpretAs(FunctionFactory & factory)
@@ -201,15 +416,24 @@ void registerFunctionsReinterpretAs(FunctionFactory & factory)
     factory.registerFunction<FunctionReinterpretAsUInt16>();
     factory.registerFunction<FunctionReinterpretAsUInt32>();
     factory.registerFunction<FunctionReinterpretAsUInt64>();
+    factory.registerFunction<FunctionReinterpretAsUInt256>();
     factory.registerFunction<FunctionReinterpretAsInt8>();
     factory.registerFunction<FunctionReinterpretAsInt16>();
     factory.registerFunction<FunctionReinterpretAsInt32>();
     factory.registerFunction<FunctionReinterpretAsInt64>();
+    factory.registerFunction<FunctionReinterpretAsInt128>();
+    factory.registerFunction<FunctionReinterpretAsInt256>();
     factory.registerFunction<FunctionReinterpretAsFloat32>();
     factory.registerFunction<FunctionReinterpretAsFloat64>();
     factory.registerFunction<FunctionReinterpretAsDate>();
     factory.registerFunction<FunctionReinterpretAsDateTime>();
     factory.registerFunction<FunctionReinterpretAsUUID>();
+
+    factory.registerFunction<FunctionReinterpretAsString>();
+
+    factory.registerFunction<FunctionReinterpretAsFixedString>();
+
+    factory.registerFunction<FunctionReinterpretAs>();
 }
 
 }
diff --git a/src/Functions/reinterpretAsFixedString.cpp b/src/Functions/reinterpretAsFixedString.cpp
deleted file mode 100644
index 465e7dffc6ac..000000000000
--- a/src/Functions/reinterpretAsFixedString.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-#include <Functions/FunctionFactory.h>
-
-#include <DataTypes/DataTypeFixedString.h>
-#include <Columns/ColumnFixedString.h>
-#include <Common/typeid_cast.h>
-#include <Common/memcpySmall.h>
-
-
-namespace DB
-{
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int ILLEGAL_COLUMN;
-}
-
-namespace
-{
-
-class FunctionReinterpretAsFixedString : public IFunction
-{
-public:
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsFixedString>(); }
-
-    static constexpr auto name = "reinterpretAsFixedString";
-
-    String getName() const override
-    {
-        return name;
-    }
-
-    size_t getNumberOfArguments() const override { return 1; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        const IDataType & type = *arguments[0];
-
-        if (type.isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())
-            return std::make_shared<DataTypeFixedString>(type.getSizeOfValueInMemory());
-        throw Exception("Cannot reinterpret " + type.getName() + " as FixedString because it is not fixed size and contiguous in memory", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-    }
-
-    static void NO_INLINE executeToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)
-    {
-        size_t rows = src.size();
-        ColumnFixedString::Chars & data_to = dst.getChars();
-        data_to.resize(n * rows);
-
-        ColumnFixedString::Offset offset = 0;
-        for (size_t i = 0; i < rows; ++i)
-        {
-            StringRef data = src.getDataAt(i);
-            memcpySmallAllowReadWriteOverflow15(&data_to[offset], data.data, n);
-            offset += n;
-        }
-    }
-
-    static void NO_INLINE executeContiguousToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)
-    {
-        size_t rows = src.size();
-        ColumnFixedString::Chars & data_to = dst.getChars();
-        data_to.resize(n * rows);
-
-        memcpy(data_to.data(), src.getRawData().data, data_to.size());
-    }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override
-    {
-        const IColumn & src = *arguments[0].column;
-        MutableColumnPtr dst = result_type->createColumn();
-
-        if (ColumnFixedString * dst_concrete = typeid_cast<ColumnFixedString *>(dst.get()))
-        {
-            if (src.isFixedAndContiguous() && src.sizeOfValueIfFixed() == dst_concrete->getN())
-                executeContiguousToFixedString(src, *dst_concrete, dst_concrete->getN());
-            else
-                executeToFixedString(src, *dst_concrete, dst_concrete->getN());
-        }
-        else
-            throw Exception("Illegal column " + src.getName() + " of argument of function " + getName(), ErrorCodes::ILLEGAL_COLUMN);
-
-        return dst;
-    }
-};
-
-}
-
-void registerFunctionReinterpretAsFixedString(FunctionFactory & factory)
-{
-    factory.registerFunction<FunctionReinterpretAsFixedString>();
-}
-
-}
-
diff --git a/src/Functions/reinterpretAsString.cpp b/src/Functions/reinterpretAsString.cpp
deleted file mode 100644
index 70db8f315bd3..000000000000
--- a/src/Functions/reinterpretAsString.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-#include <Functions/FunctionFactory.h>
-
-#include <DataTypes/DataTypeString.h>
-#include <Columns/ColumnString.h>
-#include <Common/typeid_cast.h>
-#include <Common/memcpySmall.h>
-
-
-namespace DB
-{
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_COLUMN;
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-}
-
-namespace
-{
-
-/** Function for transforming numbers and dates to strings that contain the same set of bytes in the machine representation. */
-class FunctionReinterpretAsString : public IFunction
-{
-public:
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsString>(); }
-
-    static constexpr auto name = "reinterpretAsString";
-
-    String getName() const override
-    {
-        return name;
-    }
-
-    size_t getNumberOfArguments() const override { return 1; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        const IDataType & type = *arguments[0];
-
-        if (type.isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
-            return std::make_shared<DataTypeString>();
-        throw Exception("Cannot reinterpret " + type.getName() + " as String because it is not contiguous in memory", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-    }
-
-    static void executeToString(const IColumn & src, ColumnString & dst)
-    {
-        size_t rows = src.size();
-        ColumnString::Chars & data_to = dst.getChars();
-        ColumnString::Offsets & offsets_to = dst.getOffsets();
-        offsets_to.resize(rows);
-
-        ColumnString::Offset offset = 0;
-        for (size_t i = 0; i < rows; ++i)
-        {
-            StringRef data = src.getDataAt(i);
-
-            /// Cut trailing zero bytes.
-            while (data.size && data.data[data.size - 1] == 0)
-                --data.size;
-
-            data_to.resize(offset + data.size + 1);
-            memcpySmallAllowReadWriteOverflow15(&data_to[offset], data.data, data.size);
-            offset += data.size;
-            data_to[offset] = 0;
-            ++offset;
-            offsets_to[i] = offset;
-        }
-    }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override
-    {
-        const IColumn & src = *arguments[0].column;
-        MutableColumnPtr dst = result_type->createColumn();
-
-        if (ColumnString * dst_concrete = typeid_cast<ColumnString *>(dst.get()))
-            executeToString(src, *dst_concrete);
-        else
-            throw Exception("Illegal column " + src.getName() + " of argument of function " + getName(), ErrorCodes::ILLEGAL_COLUMN);
-
-        return dst;
-    }
-};
-
-}
-
-void registerFunctionReinterpretAsString(FunctionFactory & factory)
-{
-    factory.registerFunction<FunctionReinterpretAsString>();
-}
-
-}
diff --git a/src/Functions/ya.make b/src/Functions/ya.make
index 9488c9d7d4e5..9032a80dfd69 100644
--- a/src/Functions/ya.make
+++ b/src/Functions/ya.make
@@ -409,8 +409,6 @@ SRCS(
     registerFunctionsUnixTimestamp64.cpp
     registerFunctionsVisitParam.cpp
     reinterpretAs.cpp
-    reinterpretAsFixedString.cpp
-    reinterpretAsString.cpp
     repeat.cpp
     replaceAll.cpp
     replaceOne.cpp
