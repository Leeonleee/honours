{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62085,
  "instance_id": "ClickHouse__ClickHouse-62085",
  "issue_numbers": [
    "58227"
  ],
  "base_commit": "64a97632b3bb0f2c0d7032888d887d93bf97ba75",
  "patch": "diff --git a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\nindex 79dd6e1d35ba..19547317db86 100644\n--- a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\n@@ -634,6 +634,8 @@ static void buildORCSearchArgumentImpl(\n         }\n         /// There is no optimization with space-filling curves for ORC.\n         case KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE:\n+        /// There is no optimization with pointInPolygon for ORC.\n+        case KeyCondition::RPNElement::FUNCTION_POINT_IN_POLYGON:\n         case KeyCondition::RPNElement::FUNCTION_UNKNOWN:\n         {\n             builder.literal(orc::TruthValue::YES_NO_NULL);\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 307dd81ecd46..da05cdb2206b 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -1,10 +1,10 @@\n #include <Storages/MergeTree/KeyCondition.h>\n #include <Storages/MergeTree/BoolMask.h>\n+#include <Core/PlainRanges.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeNothing.h>\n-#include <DataTypes/DataTypeString.h>\n #include <DataTypes/FieldToDataType.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <DataTypes/Utils.h>\n@@ -17,8 +17,10 @@\n #include <Functions/indexHint.h>\n #include <Functions/CastOverloadResolver.h>\n #include <Functions/IFunction.h>\n+#include <Functions/geometryConverters.h>\n #include <Common/FieldVisitorToString.h>\n #include <Common/HilbertUtils.h>\n+#include <Common/FieldVisitorConvertToNumber.h>\n #include <Common/MortonUtils.h>\n #include <Common/typeid_cast.h>\n #include <DataTypes/DataTypeTuple.h>\n@@ -28,18 +30,20 @@\n #include <Interpreters/convertFieldToType.h>\n #include <Interpreters/Set.h>\n #include <Parsers/queryToString.h>\n-#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <IO/WriteBufferFromString.h>\n #include <IO/Operators.h>\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n \n #include <algorithm>\n #include <cassert>\n #include <stack>\n #include <limits>\n \n+#include <boost/geometry.hpp>\n+#include <boost/geometry/geometries/polygon.hpp>\n+#include <boost/geometry/geometries/multi_polygon.hpp>\n+\n \n namespace DB\n {\n@@ -459,12 +463,20 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n             out.range = Range::createWholeUniverseWithoutNull();\n             return true;\n         }\n+    },\n+    {\n+        \"pointInPolygon\",\n+        [] (RPNElement & out, const Field &)\n+        {\n+            out.function = RPNElement::FUNCTION_POINT_IN_POLYGON;\n+            return true;\n+        }\n     }\n };\n \n static const std::set<std::string_view> always_relaxed_atom_functions = {\"match\"};\n static const std::set<KeyCondition::RPNElement::Function> always_relaxed_atom_elements\n-    = {KeyCondition::RPNElement::FUNCTION_UNKNOWN, KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE};\n+    = {KeyCondition::RPNElement::FUNCTION_UNKNOWN, KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE, KeyCondition::RPNElement::FUNCTION_POINT_IN_POLYGON};\n \n /// Functions with range inversion cannot be relaxed. It will become stricter instead.\n /// For example:\n@@ -1850,6 +1862,54 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n         if (atom_map.find(func_name) == std::end(atom_map))\n             return false;\n \n+        auto analyze_point_in_polygon = [&, this]() -> bool\n+        {\n+            /// pointInPolygon((x, y), [(0, 0), (8, 4), (5, 8), (0, 2)])\n+            if (func.getArgumentAt(0).tryGetConstant(const_value, const_type))\n+                return false;\n+            if (!func.getArgumentAt(1).tryGetConstant(const_value, const_type))\n+                return false;\n+\n+            const auto atom_it = atom_map.find(func_name);\n+\n+            /// Analyze (x, y)\n+            RPNElement::MultiColumnsFunctionDescription column_desc;\n+            column_desc.function_name = func_name;\n+            auto first_argument = func.getArgumentAt(0).toFunctionNode();\n+\n+            if (first_argument.getArgumentsSize() != 2 || first_argument.getFunctionName() != \"tuple\")\n+                return false;\n+\n+            for (size_t i = 0; i < 2; ++i)\n+            {\n+                auto name = first_argument.getArgumentAt(i).getColumnName();\n+                auto it = key_columns.find(name);\n+                if (it == key_columns.end())\n+                    return false;\n+                column_desc.key_columns.push_back(name);\n+                column_desc.key_column_positions.push_back(key_columns[name]);\n+            }\n+            out.point_in_polygon_column_description = column_desc;\n+\n+            /// Analyze [(0, 0), (8, 4), (5, 8), (0, 2)]\n+            chassert(WhichDataType(const_type).isArray());\n+            for (const auto & elem : const_value.safeGet<Array>())\n+            {\n+                if (elem.getType() != Field::Types::Tuple)\n+                    return false;\n+\n+                const auto & elem_tuple = elem.safeGet<Tuple>();\n+                if (elem_tuple.size() != 2)\n+                    return false;\n+\n+                auto x = applyVisitor(FieldVisitorConvertToNumber<Float64>(), elem_tuple[0]);\n+                auto y = applyVisitor(FieldVisitorConvertToNumber<Float64>(), elem_tuple[1]);\n+                out.polygon.outer().push_back({x, y});\n+            }\n+            boost::geometry::correct(out.polygon);\n+            return atom_it->second(out, const_value);\n+        };\n+\n         if (always_relaxed_atom_functions.contains(func_name))\n             relaxed = true;\n \n@@ -1879,6 +1939,11 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n                 else\n                     return false;\n             }\n+            else if (func_name == \"pointInPolygon\")\n+            {\n+                /// Case1 no holes in polygon\n+                return analyze_point_in_polygon();\n+            }\n             else if (func.getArgumentAt(1).tryGetConstant(const_value, const_type))\n             {\n                 /// If the const operand is null, the atom will be always false\n@@ -2047,7 +2112,15 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n \n         }\n         else\n-            return false;\n+        {\n+            if (func_name == \"pointInPolygon\")\n+            {\n+                /// Case2 has holes in polygon, when checking skip index, the hole will be ignored.\n+                return analyze_point_in_polygon();\n+            }\n+            else\n+                return false;\n+        }\n \n         const auto atom_it = atom_map.find(func_name);\n \n@@ -3059,6 +3132,46 @@ BoolMask KeyCondition::checkInHyperrectangle(\n               * represented by a set of hyperrectangles.\n               */\n         }\n+        else if (element.function == RPNElement::FUNCTION_POINT_IN_POLYGON)\n+        {\n+            /** There are 2 kinds of polygons:\n+              *   1. Polygon by minmax index\n+              *   2. Polygons which is provided by user\n+              *\n+              * Polygon by minmax index:\n+              *   For hyperactangle [1, 2] \u00d7 [3, 4] we can create a polygon with 4 points: (1, 3), (1, 4), (2, 4), (2, 3)\n+              *\n+              * Algorithm:\n+              *   Check whether there is any intersection of the 2 polygons. If true return {true, true}, else return {false, true}.\n+              */\n+            const auto & key_column_positions = element.point_in_polygon_column_description->key_column_positions;\n+\n+            Float64 x_min = applyVisitor(FieldVisitorConvertToNumber<Float64>(), hyperrectangle[key_column_positions[0]].left);\n+            Float64 x_max = applyVisitor(FieldVisitorConvertToNumber<Float64>(), hyperrectangle[key_column_positions[0]].right);\n+            Float64 y_min = applyVisitor(FieldVisitorConvertToNumber<Float64>(), hyperrectangle[key_column_positions[1]].left);\n+            Float64 y_max = applyVisitor(FieldVisitorConvertToNumber<Float64>(), hyperrectangle[key_column_positions[1]].right);\n+\n+            if (unlikely(isNaN(x_min) || isNaN(x_max) || isNaN(y_min) || isNaN(y_max)))\n+            {\n+                rpn_stack.emplace_back(true, true);\n+                continue;\n+            }\n+\n+            using Point = boost::geometry::model::d2::point_xy<Float64>;\n+            using Polygon = boost::geometry::model::polygon<Point>;\n+            Polygon  polygon_by_minmax_index;\n+            polygon_by_minmax_index.outer().emplace_back(x_min, y_min);\n+            polygon_by_minmax_index.outer().emplace_back(x_min, y_max);\n+            polygon_by_minmax_index.outer().emplace_back(x_max, y_max);\n+            polygon_by_minmax_index.outer().emplace_back(x_max, y_min);\n+\n+            /// Close ring\n+            boost::geometry::correct(polygon_by_minmax_index);\n+\n+            /// Because the polygon may have a hole so the \"can_be_false\" should always be true.\n+            rpn_stack.emplace_back(\n+                boost::geometry::intersects(polygon_by_minmax_index, element.polygon), true);\n+        }\n         else if (\n             element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL)\n@@ -3138,7 +3251,16 @@ bool KeyCondition::mayBeTrueInRange(\n String KeyCondition::RPNElement::toString() const\n {\n     if (argument_num_of_space_filling_curve)\n-        return toString(fmt::format(\"argument {} of column {}\", *argument_num_of_space_filling_curve, key_column), true);\n+        return toString(fmt::format(\"argument {} of column {}\", *argument_num_of_space_filling_curve, key_column), false);\n+    else if (point_in_polygon_column_description)\n+    {\n+        return toString(\n+            fmt::format(\n+                \"column ({}, {})\",\n+                point_in_polygon_column_description->key_columns[0],\n+                point_in_polygon_column_description->key_columns[1]),\n+            false);\n+    }\n     else\n         return toString(fmt::format(\"column {}\", key_column), true);\n }\n@@ -3218,6 +3340,23 @@ String KeyCondition::RPNElement::toString(std::string_view column_name, bool pri\n             buf << \")\";\n             return buf.str();\n         }\n+        case FUNCTION_POINT_IN_POLYGON:\n+        {\n+            auto points_in_polygon = polygon.outer();\n+            buf << \"(\";\n+            print_wrapped_column(buf);\n+            buf << \" in \";\n+            buf << \"[\";\n+            for (size_t i = 0; i < points_in_polygon.size(); ++i)\n+            {\n+                if (i != 0)\n+                    buf << \", \";\n+                buf << \"(\" << points_in_polygon[i].x() << \", \" << points_in_polygon[i].y() << \")\";\n+            }\n+            buf << \"]\";\n+            buf << \")\";\n+            return buf.str();\n+        }\n         case FUNCTION_IS_NULL:\n         case FUNCTION_IS_NOT_NULL:\n         {\n@@ -3269,6 +3408,7 @@ bool KeyCondition::unknownOrAlwaysTrue(bool unknown_any) const\n             || element.function == RPNElement::FUNCTION_IN_SET\n             || element.function == RPNElement::FUNCTION_NOT_IN_SET\n             || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE\n+            || element.function == RPNElement::FUNCTION_POINT_IN_POLYGON\n             || element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL\n             || element.function == RPNElement::ALWAYS_FALSE)\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex 8bbb86aba435..8c946bd3bbd7 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -2,14 +2,13 @@\n \n #include <optional>\n \n+#include <boost/geometry.hpp>\n+\n #include <Core/SortDescription.h>\n #include <Core/Range.h>\n-#include <Core/PlainRanges.h>\n \n #include <DataTypes/Serializations/ISerialization.h>\n \n-#include <Parsers/ASTExpressionList.h>\n-\n #include <Interpreters/Set.h>\n #include <Interpreters/ActionsDAG.h>\n #include <Interpreters/TreeRewriter.h>\n@@ -168,6 +167,9 @@ class KeyCondition\n             /// this expression will be analyzed and then represented by following:\n             ///   args in hyperrectangle [10, 20] \u00d7 [20, 30].\n             FUNCTION_ARGS_IN_HYPERRECTANGLE,\n+            /// Special for pointInPolygon to utilize minmax indices.\n+            /// For example: pointInPolygon((x, y), [(0, 0), (0, 2), (2, 2), (2, 0)])\n+            FUNCTION_POINT_IN_POLYGON,\n             /// Can take any value.\n             FUNCTION_UNKNOWN,\n             /// Operators of the logical expression.\n@@ -206,6 +208,21 @@ class KeyCondition\n         /// For FUNCTION_ARGS_IN_HYPERRECTANGLE\n         Hyperrectangle space_filling_curve_args_hyperrectangle;\n \n+        /// For FUNCTION_POINT_IN_POLYGON.\n+        /// Function like 'pointInPolygon' has multiple columns.\n+        /// This struct description column part of the function, such as (x, y) in 'pointInPolygon'.\n+        struct MultiColumnsFunctionDescription\n+        {\n+            String function_name;\n+            std::vector<size_t> key_column_positions;\n+            std::vector<String> key_columns;\n+        };\n+        std::optional<MultiColumnsFunctionDescription> point_in_polygon_column_description;\n+\n+        using Point = boost::geometry::model::d2::point_xy<Float64>;\n+        using Polygon = boost::geometry::model::polygon<Point>;\n+        Polygon polygon;\n+\n         MonotonicFunctionsChain monotonic_functions_chain;\n     };\n \n",
  "test_patch": "diff --git a/tests/performance/point_in_polygon_index.xml b/tests/performance/point_in_polygon_index.xml\nnew file mode 100644\nindex 000000000000..8706d6433452\n--- /dev/null\n+++ b/tests/performance/point_in_polygon_index.xml\n@@ -0,0 +1,21 @@\n+<test>\n+    <settings>\n+        <!--\n+            Not sure why it's needed. Maybe it has something to do with the\n+            resulting block size of Memory table.\n+         -->\n+        <optimize_trivial_insert_select>0</optimize_trivial_insert_select>\n+    </settings>\n+\n+    <create_query>CREATE TABLE polygons(`x` Float64, `y` Float64, INDEX mm_x_y (x, y) TYPE minmax GRANULARITY 1) ENGINE = MergeTree ORDER BY x</create_query>\n+    <create_query>\n+        INSERT INTO polygons\n+        SELECT toFloat64(1000000) / ((number % 100000) + 1), toFloat64(1000000) / ((number % 100000) + 1) from system.numbers LIMIT 10000000\n+        SETTINGS max_insert_threads = 2, max_memory_usage = 30000000000;\n+    </create_query>\n+\n+    <query>SELECT count(*) FROM polygons\n+        WHERE pointInPolygon((x, y), [(1,0),(0.9993908270190958,0.03489949670250097),(0.9975640502598242,0.0697564737441253),(0.9945218953682733,0.10452846326765346),(0.9902680687415704,0.13917310096006544),(0.984807753012208,0.17364817766693033),(0.9781476007338057,0.20791169081775931),(0.9702957262759965,0.24192189559966773),(0.9612616959383189,0.27563735581699916),(0.9510565162951535,0.3090169943749474),(0.9396926207859084,0.3420201433256687),(0.9271838545667874,0.374606593415912),(0.9135454576426009,0.40673664307580015),(0.898794046299167,0.4383711467890774),(0.882947592858927,0.4694715627858908),(0.8660254037844387,0.49999999999999994),(0.848048096156426,0.5299192642332049),(0.8290375725550417,0.5591929034707468),(0.8090169943749475,0.5877852522924731),(0.7880107536067219,0.6156614753256583),(0.766044443118978,0.6427876096865393),(0.7431448254773942,0.6691306063588582),(0.7193398003386512,0.6946583704589973),(0.6946583704589974,0.7193398003386511),(0.6691306063588582,0.7431448254773941),(0.6427876096865394,0.766044443118978),(0.6156614753256583,0.7880107536067219),(0.5877852522924731,0.8090169943749475),(0.5591929034707468,0.8290375725550417),(0.5299192642332049,0.848048096156426),(0.5000000000000001,0.8660254037844386),(0.46947156278589086,0.8829475928589269),(0.43837114678907746,0.898794046299167),(0.4067366430758004,0.9135454576426009),(0.3746065934159122,0.9271838545667873),(0.3420201433256688,0.9396926207859083),(0.30901699437494745,0.9510565162951535),(0.27563735581699916,0.9612616959383189),(0.24192189559966767,0.9702957262759965),(0.20791169081775923,0.9781476007338057),(0.17364817766693041,0.984807753012208),(0.13917310096006547,0.9902680687415704),(0.10452846326765346,0.9945218953682733),(0.06975647374412523,0.9975640502598242),(0.03489949670250108,0.9993908270190958),(6.123233995736766e-17,1),(-0.03489949670250073,0.9993908270190958),(-0.06975647374412533,0.9975640502598242),(-0.10452846326765333,0.9945218953682734),(-0.13917310096006513,0.9902680687415704),(-0.1736481776669303,0.984807753012208),(-0.20791169081775912,0.9781476007338057),(-0.24192189559966756,0.9702957262759965),(-0.27563735581699905,0.9612616959383189),(-0.30901699437494734,0.9510565162951536),(-0.3420201433256687,0.9396926207859084),(-0.37460659341591207,0.9271838545667874),(-0.40673664307580004,0.913545457642601),(-0.4383711467890775,0.8987940462991669),(-0.46947156278589053,0.8829475928589271),(-0.4999999999999998,0.8660254037844387),(-0.5299192642332048,0.8480480961564261),(-0.5591929034707467,0.8290375725550417),(-0.587785252292473,0.8090169943749475),(-0.6156614753256583,0.788010753606722),(-0.6427876096865394,0.766044443118978),(-0.6691306063588579,0.7431448254773945),(-0.6946583704589974,0.7193398003386511),(-0.719339800338651,0.6946583704589975),(-0.7431448254773944,0.669130606358858),(-0.7660444431189779,0.6427876096865395),(-0.7880107536067219,0.6156614753256584),(-0.8090169943749473,0.5877852522924732),(-0.8290375725550416,0.5591929034707469),(-0.848048096156426,0.5299192642332049),(-0.8660254037844387,0.49999999999999994),(-0.882947592858927,0.4694715627858907),(-0.8987940462991668,0.4383711467890777),(-0.913545457642601,0.40673664307580004),(-0.9271838545667873,0.37460659341591224),(-0.9396926207859083,0.3420201433256689),(-0.9510565162951535,0.3090169943749475),(-0.9612616959383189,0.2756373558169992),(-0.9702957262759965,0.24192189559966773),(-0.9781476007338057,0.20791169081775931),(-0.984807753012208,0.1736481776669307),(-0.9902680687415704,0.13917310096006533),(-0.9945218953682733,0.10452846326765373),(-0.9975640502598242,0.06975647374412552),(-0.9993908270190958,0.03489949670250114),(-1,1.2246467991473532e-16),(-0.9993908270190958,-0.0348994967025009),(-0.9975640502598243,-0.06975647374412483),(-0.9945218953682733,-0.1045284632676535),(-0.9902680687415703,-0.13917310096006552),(-0.984807753012208,-0.17364817766693047),(-0.9781476007338057,-0.20791169081775907),(-0.9702957262759965,-0.2419218955996675),(-0.961261695938319,-0.2756373558169986),(-0.9510565162951535,-0.30901699437494773),(-0.9396926207859084,-0.34202014332566866),(-0.9271838545667874,-0.374606593415912),(-0.9135454576426011,-0.4067366430757998),(-0.8987940462991671,-0.43837114678907707),(-0.8829475928589271,-0.4694715627858905),(-0.8660254037844386,-0.5000000000000001),(-0.8480480961564261,-0.5299192642332048),(-0.8290375725550418,-0.5591929034707467),(-0.8090169943749476,-0.587785252292473),(-0.7880107536067222,-0.6156614753256578),(-0.766044443118978,-0.6427876096865393),(-0.7431448254773942,-0.6691306063588582),(-0.7193398003386511,-0.6946583704589974),(-0.6946583704589976,-0.7193398003386509),(-0.6691306063588585,-0.743144825477394),(-0.6427876096865395,-0.7660444431189779),(-0.6156614753256581,-0.7880107536067221),(-0.5877852522924732,-0.8090169943749473),(-0.5591929034707472,-0.8290375725550414),(-0.529919264233205,-0.848048096156426),(-0.5000000000000004,-0.8660254037844384),(-0.46947156278589075,-0.882947592858927),(-0.43837114678907774,-0.8987940462991668),(-0.4067366430758001,-0.913545457642601),(-0.3746065934159123,-0.9271838545667873),(-0.3420201433256694,-0.9396926207859082),(-0.30901699437494756,-0.9510565162951535),(-0.2756373558169989,-0.961261695938319),(-0.24192189559966779,-0.9702957262759965),(-0.2079116908177598,-0.9781476007338056),(-0.17364817766693033,-0.984807753012208),(-0.13917310096006583,-0.9902680687415703),(-0.10452846326765423,-0.9945218953682733),(-0.06975647374412558,-0.9975640502598242),(-0.03489949670250076,-0.9993908270190958),(-1.8369701987210297e-16,-1),(0.03489949670250039,-0.9993908270190958),(0.06975647374412522,-0.9975640502598243),(0.10452846326765387,-0.9945218953682733),(0.13917310096006547,-0.9902680687415704),(0.17364817766692997,-0.9848077530122081),(0.20791169081775943,-0.9781476007338056),(0.24192189559966745,-0.9702957262759966),(0.2756373558169985,-0.961261695938319),(0.30901699437494723,-0.9510565162951536),(0.342020143325669,-0.9396926207859083),(0.37460659341591196,-0.9271838545667874),(0.40673664307579976,-0.9135454576426011),(0.4383711467890774,-0.898794046299167),(0.4694715627858904,-0.8829475928589271),(0.5000000000000001,-0.8660254037844386),(0.5299192642332047,-0.8480480961564262),(0.559192903470747,-0.8290375725550416),(0.5877852522924729,-0.8090169943749476),(0.6156614753256578,-0.7880107536067223),(0.6427876096865393,-0.7660444431189781),(0.6691306063588585,-0.743144825477394),(0.6946583704589973,-0.7193398003386512),(0.7193398003386509,-0.6946583704589976),(0.7431448254773937,-0.6691306063588588),(0.7660444431189778,-0.6427876096865396),(0.788010753606722,-0.6156614753256582),(0.8090169943749473,-0.5877852522924734),(0.8290375725550414,-0.5591929034707473),(0.848048096156426,-0.529919264233205),(0.8660254037844384,-0.5000000000000004),(0.8829475928589269,-0.4694715627858908),(0.8987940462991668,-0.4383711467890778),(0.913545457642601,-0.40673664307580015),(0.9271838545667873,-0.37460659341591235),(0.9396926207859081,-0.34202014332566943),(0.9510565162951535,-0.3090169943749476),(0.9612616959383189,-0.27563735581699894),(0.9702957262759965,-0.24192189559966787),(0.9781476007338056,-0.20791169081775987),(0.984807753012208,-0.1736481776669304),(0.9902680687415703,-0.13917310096006588),(0.9945218953682733,-0.1045284632676543),(0.9975640502598242,-0.06975647374412564),(0.9993908270190958,-0.034899496702500823)]) FORMAT Null</query>\n+\n+    <drop_query>DROP TABLE IF EXISTS polygons</drop_query>\n+</test>\ndiff --git a/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.reference b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.reference\nnew file mode 100644\nindex 000000000000..f1c34569326f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.reference\n@@ -0,0 +1,8 @@\n+4\t4\n+6\t6\n+8\t8\n+\t\t\"rows_read\": 3,\n+12\t12\n+14\t14\n+\t\t\"rows_read\": 3,\n+\t\t\"rows_read\": 0,\ndiff --git a/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.sh b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.sh\nnew file mode 100755\nindex 000000000000..1502be848c23\n--- /dev/null\n+++ b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.sh\n@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT -q \"drop table if exists minmax_index_point_in_polygon\"\n+$CLICKHOUSE_CLIENT -q \"\n+CREATE TABLE minmax_index_point_in_polygon\n+(\n+  x UInt32,\n+  y UInt32,\n+  INDEX mm_x_y (x, y) TYPE minmax GRANULARITY 1\n+) \n+ENGINE = MergeTree()\n+ORDER BY x \n+SETTINGS index_granularity = 3\"\n+\n+$CLICKHOUSE_CLIENT -q \"Insert into minmax_index_point_in_polygon values\n+  (4, 4),\n+  (6 ,6),\n+  (8, 8),\n+  (12, 12),\n+  (14, 14),\n+  (16, 16)\"\n+\n+function query_and_check()\n+{\n+    query=\"$1\"\n+    $CLICKHOUSE_CLIENT -q \"$query\"\n+    $CLICKHOUSE_CLIENT -q \"$query FORMAT JSON\" | grep \"rows_read\"\n+}\n+\n+# 1/2 marks filtered by minmax index, read_rows should be 3\n+query_and_check \"select * from minmax_index_point_in_polygon where pointInPolygon((x, y), [(4., 4.), (8., 4.), (8., 8.), (4., 8.)])\"\n+query_and_check \"select * from minmax_index_point_in_polygon where pointInPolygon((x, y), [(10., 13.), (14., 14.), (14, 10)])\"\n+\n+\n+# 2/2 marks filtered by minmax index, read_rows should be 0\n+query_and_check \"select * from minmax_index_point_in_polygon where pointInPolygon((x, y), [(0., 0.), (2., 2.), (2., 0.)])\"\n+\n+$CLICKHOUSE_CLIENT -q \"drop table if exists minmax_index_point_in_polygon\"\n",
  "problem_statement": "KeyCondition should analyze `pointInPolygon` function to utilize minmax indices.\n**Use case**\r\n\r\nThere is minmax index on latitude and longitude and a condition on `pointInPolygon` in a query.\n",
  "hints_text": "",
  "created_at": "2024-03-29T07:05:33Z",
  "modified_files": [
    "src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp",
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/KeyCondition.h"
  ],
  "modified_test_files": [
    "b/tests/performance/point_in_polygon_index.xml",
    "b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.reference",
    "b/tests/queries/0_stateless/03031_minmax_index_for_pointinpolygon.sh"
  ]
}