{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23997,
  "instance_id": "ClickHouse__ClickHouse-23997",
  "issue_numbers": [
    "23296"
  ],
  "base_commit": "e0b3b7d661c7cca788f2290f31cb8660a80cae03",
  "patch": "diff --git a/src/Storages/MergeTree/ActiveDataPartSet.cpp b/src/Storages/MergeTree/ActiveDataPartSet.cpp\nindex e4d7465b3602..bbf05afa42c3 100644\n--- a/src/Storages/MergeTree/ActiveDataPartSet.cpp\n+++ b/src/Storages/MergeTree/ActiveDataPartSet.cpp\n@@ -1,10 +1,16 @@\n #include <Storages/MergeTree/ActiveDataPartSet.h>\n+#include <Common/Exception.h>\n #include <algorithm>\n \n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n ActiveDataPartSet::ActiveDataPartSet(MergeTreeDataFormatVersion format_version_, const Strings & names)\n     : format_version(format_version_)\n {\n@@ -15,6 +21,7 @@ ActiveDataPartSet::ActiveDataPartSet(MergeTreeDataFormatVersion format_version_,\n \n bool ActiveDataPartSet::add(const String & name, Strings * out_replaced_parts)\n {\n+    /// TODO make it exception safe (out_replaced_parts->push_back(...) may throw)\n     auto part_info = MergeTreePartInfo::fromPartName(name, format_version);\n \n     if (getContainingPartImpl(part_info) != part_info_to_name.end())\n@@ -32,6 +39,8 @@ bool ActiveDataPartSet::add(const String & name, Strings * out_replaced_parts)\n         --it;\n         if (!part_info.contains(it->first))\n         {\n+            if (!part_info.isDisjoint(it->first))\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part {} intersects previous part {}. It is a bug.\", name, it->first.getPartName());\n             ++it;\n             break;\n         }\n@@ -47,11 +56,16 @@ bool ActiveDataPartSet::add(const String & name, Strings * out_replaced_parts)\n     /// Let's go to the right.\n     while (it != part_info_to_name.end() && part_info.contains(it->first))\n     {\n+        if (part_info == it->first)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected duplicate part {}. It is a bug.\", name);\n         if (out_replaced_parts)\n             out_replaced_parts->push_back(it->second);\n         part_info_to_name.erase(it++);\n     }\n \n+    if (it != part_info_to_name.end() && !part_info.isDisjoint(it->first))\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part {} intersects next part {}. It is a bug.\", name, it->first.getPartName());\n+\n     part_info_to_name.emplace(part_info, name);\n     return true;\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 22fe540222ed..958db83cc6e0 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -2089,8 +2089,8 @@ MergeTreeData::DataPartsVector MergeTreeData::getActivePartsToReplace(\n             }\n \n             if (!new_part_info.isDisjoint((*prev)->info))\n-                throw Exception(\"Part \" + new_part_name + \" intersects previous part \" + (*prev)->getNameWithState() +\n-                    \". It is a bug.\", ErrorCodes::LOGICAL_ERROR);\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part {} intersects previous part {}. It is a bug.\",\n+                                new_part_name, (*prev)->getNameWithState());\n \n             break;\n         }\n@@ -2103,7 +2103,7 @@ MergeTreeData::DataPartsVector MergeTreeData::getActivePartsToReplace(\n     while (end != committed_parts_range.end())\n     {\n         if ((*end)->info == new_part_info)\n-            throw Exception(\"Unexpected duplicate part \" + (*end)->getNameWithState() + \". It is a bug.\", ErrorCodes::LOGICAL_ERROR);\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected duplicate part {}. It is a bug.\", (*end)->getNameWithState());\n \n         if (!new_part_info.contains((*end)->info))\n         {\n@@ -2114,8 +2114,8 @@ MergeTreeData::DataPartsVector MergeTreeData::getActivePartsToReplace(\n             }\n \n             if (!new_part_info.isDisjoint((*end)->info))\n-                throw Exception(\"Part \" + new_part_name + \" intersects next part \" + (*end)->getNameWithState() +\n-                    \". It is a bug.\", ErrorCodes::LOGICAL_ERROR);\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part {} intersects next part {}. It is a bug.\",\n+                                new_part_name, (*end)->getNameWithState());\n \n             break;\n         }\n@@ -2345,7 +2345,7 @@ void MergeTreeData::removePartsFromWorkingSet(const DataPartsVector & remove, bo\n }\n \n MergeTreeData::DataPartsVector MergeTreeData::removePartsInRangeFromWorkingSet(const MergeTreePartInfo & drop_range, bool clear_without_timeout,\n-                                                                               bool skip_intersecting_parts, DataPartsLock & lock)\n+                                                                               DataPartsLock & lock)\n {\n     DataPartsVector parts_to_remove;\n \n@@ -2359,16 +2359,13 @@ MergeTreeData::DataPartsVector MergeTreeData::removePartsInRangeFromWorkingSet(c\n         if (part->info.partition_id != drop_range.partition_id)\n             throw Exception(\"Unexpected partition_id of part \" + part->name + \". This is a bug.\", ErrorCodes::LOGICAL_ERROR);\n \n-        if (part->info.min_block < drop_range.min_block)\n+        if (part->info.min_block < drop_range.min_block)    /// NOTE Always false, because drop_range.min_block == 0\n         {\n             if (drop_range.min_block <= part->info.max_block)\n             {\n                 /// Intersect left border\n-                String error = \"Unexpected merged part \" + part->name + \" intersecting drop range \" + drop_range.getPartName();\n-                if (!skip_intersecting_parts)\n-                    throw Exception(error, ErrorCodes::LOGICAL_ERROR);\n-\n-                LOG_WARNING(log, error);\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected merged part {} intersecting drop range {}\",\n+                                part->name, drop_range.getPartName());\n             }\n \n             continue;\n@@ -2381,12 +2378,8 @@ MergeTreeData::DataPartsVector MergeTreeData::removePartsInRangeFromWorkingSet(c\n         if (part->info.min_block <= drop_range.max_block && drop_range.max_block < part->info.max_block)\n         {\n             /// Intersect right border\n-            String error = \"Unexpected merged part \" + part->name + \" intersecting drop range \" + drop_range.getPartName();\n-            if (!skip_intersecting_parts)\n-                throw Exception(error, ErrorCodes::LOGICAL_ERROR);\n-\n-            LOG_WARNING(log, error);\n-            continue;\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected merged part {} intersecting drop range {}\",\n+                            part->name, drop_range.getPartName());\n         }\n \n         if (part->getState() != DataPartState::Deleting)\n@@ -3222,7 +3215,7 @@ MergeTreeData::DataPartsVector MergeTreeData::getDataPartsVector(\n             {\n                 std::swap(buf, res);\n                 res.clear();\n-                std::merge(range.begin(), range.end(), buf.begin(), buf.end(), std::back_inserter(res), LessDataPart());\n+                std::merge(range.begin(), range.end(), buf.begin(), buf.end(), std::back_inserter(res), LessDataPart()); //-V783\n             }\n         }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 7f2c94b96a46..f2bb63f3f4af 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -490,10 +490,9 @@ class MergeTreeData : public IStorage, public WithContext\n \n     /// Removes all parts from the working set parts\n     ///  for which (partition_id = drop_range.partition_id && min_block >= drop_range.min_block && max_block <= drop_range.max_block).\n-    /// If a part intersecting drop_range.max_block is found, an exception will be thrown.\n     /// Used in REPLACE PARTITION command;\n     DataPartsVector removePartsInRangeFromWorkingSet(const MergeTreePartInfo & drop_range, bool clear_without_timeout,\n-                                                     bool skip_intersecting_parts, DataPartsLock & lock);\n+                                                     DataPartsLock & lock);\n \n     /// Renames the part to detached/<prefix>_<part> and removes it from data_parts,\n     //// so it will not be deleted in clearOldParts.\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex 45a4b134fe54..8e67931754b9 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -248,12 +248,13 @@ SelectPartsDecision MergeTreeDataMergerMutator::selectPartsToMerge(\n         {\n             if (parts_ranges.empty() || !parts_ranges.back().empty())\n                 parts_ranges.emplace_back();\n+\n             /// New partition frame.\n             prev_partition_id = &partition_id;\n             prev_part = nullptr;\n         }\n \n-        /// Check predicate only for first part in each partition.\n+        /// Check predicate only for the first part in each range.\n         if (!prev_part)\n         {\n             /* Parts can be merged with themselves for TTL needs for example.\n@@ -262,6 +263,7 @@ SelectPartsDecision MergeTreeDataMergerMutator::selectPartsToMerge(\n             * of each partition because it will be automatically checked for a pair of parts. */\n             if (!can_merge_callback(nullptr, part, nullptr))\n                 continue;\n+\n         }\n         else\n         {\n@@ -270,8 +272,8 @@ SelectPartsDecision MergeTreeDataMergerMutator::selectPartsToMerge(\n             if (!can_merge_callback(*prev_part, part, nullptr))\n             {\n                 /// Starting new interval in the same partition\n-                if (!parts_ranges.back().empty())\n-                    parts_ranges.emplace_back();\n+                assert(!parts_ranges.back().empty());\n+                parts_ranges.emplace_back();\n \n                 /// Now we have no previous part, but it affects only logging\n                 prev_part = nullptr;\n@@ -295,7 +297,7 @@ SelectPartsDecision MergeTreeDataMergerMutator::selectPartsToMerge(\n         if (prev_part && part->info.partition_id == (*prev_part)->info.partition_id\n             && part->info.min_block <= (*prev_part)->info.max_block)\n         {\n-            LOG_ERROR(log, \"Part {} intersects previous part {}\", part->name, (*prev_part)->name);\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part {} intersects previous part {}\", part->name, (*prev_part)->name);\n         }\n \n         prev_part = &part;\ndiff --git a/src/Storages/MergeTree/MergeTreePartInfo.cpp b/src/Storages/MergeTree/MergeTreePartInfo.cpp\nindex d30f6470bb13..94430de422e2 100644\n--- a/src/Storages/MergeTree/MergeTreePartInfo.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartInfo.cpp\n@@ -93,6 +93,15 @@ bool MergeTreePartInfo::tryParsePartName(const String & part_name, MergeTreePart\n         part_info->partition_id = std::move(partition_id);\n         part_info->min_block = min_block_num;\n         part_info->max_block = max_block_num;\n+        if (level == LEGACY_MAX_LEVEL)\n+        {\n+            /// We (accidentally) had two different max levels until 21.6 and it might cause logical errors like\n+            /// \"Part 20170601_20170630_0_2_999999999 intersects 201706_0_1_4294967295\".\n+            /// So we replace unexpected max level to make contains(...) method and comparison operators work\n+            /// correctly with such virtual parts. On part name serialization we will use legacy max level to keep the name unchanged.\n+            part_info->use_leagcy_max_level = true;\n+            level = MAX_LEVEL;\n+        }\n         part_info->level = level;\n         part_info->mutation = mutation;\n     }\n@@ -146,7 +155,15 @@ String MergeTreePartInfo::getPartName() const\n     writeChar('_', wb);\n     writeIntText(max_block, wb);\n     writeChar('_', wb);\n-    writeIntText(level, wb);\n+    if (use_leagcy_max_level)\n+    {\n+        assert(level == MAX_LEVEL);\n+        writeIntText(LEGACY_MAX_LEVEL, wb);\n+    }\n+    else\n+    {\n+        writeIntText(level, wb);\n+    }\n \n     if (mutation)\n     {\n@@ -177,7 +194,15 @@ String MergeTreePartInfo::getPartNameV0(DayNum left_date, DayNum right_date) con\n     writeChar('_', wb);\n     writeIntText(max_block, wb);\n     writeChar('_', wb);\n-    writeIntText(level, wb);\n+    if (use_leagcy_max_level)\n+    {\n+        assert(level == MAX_LEVEL);\n+        writeIntText(LEGACY_MAX_LEVEL, wb);\n+    }\n+    else\n+    {\n+        writeIntText(level, wb);\n+    }\n \n     if (mutation)\n     {\ndiff --git a/src/Storages/MergeTree/MergeTreePartInfo.h b/src/Storages/MergeTree/MergeTreePartInfo.h\nindex 416308861b74..e81143de8c2e 100644\n--- a/src/Storages/MergeTree/MergeTreePartInfo.h\n+++ b/src/Storages/MergeTree/MergeTreePartInfo.h\n@@ -19,6 +19,8 @@ struct MergeTreePartInfo\n     UInt32 level = 0;\n     Int64 mutation = 0;   /// If the part has been mutated or contains mutated parts, is equal to mutation version number.\n \n+    bool use_leagcy_max_level = false;  /// For compatibility. TODO remove it\n+\n     MergeTreePartInfo() = default;\n \n     MergeTreePartInfo(String partition_id_, Int64 min_block_, Int64 max_block_, UInt32 level_)\n@@ -86,6 +88,8 @@ struct MergeTreePartInfo\n \n     static constexpr UInt32 MAX_LEVEL = 999999999;\n     static constexpr UInt32 MAX_BLOCK_NUMBER = 999999999;\n+\n+    static constexpr UInt32 LEGACY_MAX_LEVEL = std::numeric_limits<decltype(level)>::max();\n };\n \n /// Information about detached part, which includes its prefix in\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\nindex 7d8ba0e4a308..6d0287257203 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\n@@ -3,6 +3,7 @@\n \n #include <Storages/MergeTree/ReplicatedMergeTreeLogEntry.h>\n #include <Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h>\n+#include <Storages/MergeTree/MergeTreePartInfo.h>\n #include <IO/Operators.h>\n #include <IO/ReadBufferFromString.h>\n #include <IO/WriteBufferFromString.h>\n@@ -366,6 +367,12 @@ void ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry::readText(ReadBuffer & i\n     in >> \"columns_version: \" >> columns_version;\n }\n \n+bool ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry::isMovePartitionOrAttachFrom(const MergeTreePartInfo & drop_range_info)\n+{\n+    assert(drop_range_info.getBlocksCount() != 0);\n+    return drop_range_info.getBlocksCount() == 1;\n+}\n+\n String ReplicatedMergeTreeLogEntryData::toString() const\n {\n     WriteBufferFromOwnString out;\n@@ -386,4 +393,33 @@ ReplicatedMergeTreeLogEntry::Ptr ReplicatedMergeTreeLogEntry::parse(const String\n     return res;\n }\n \n+Strings ReplicatedMergeTreeLogEntryData::getVirtualPartNames(MergeTreeDataFormatVersion format_version) const\n+{\n+    /// Doesn't produce any part\n+    if (type == ALTER_METADATA)\n+        return {};\n+\n+    /// DROP_RANGE does not add a real part, but we must disable merges in that range\n+    if (type == DROP_RANGE)\n+        return {new_part_name};\n+\n+    /// CLEAR_COLUMN and CLEAR_INDEX are deprecated since 20.3\n+    if (type == CLEAR_COLUMN || type == CLEAR_INDEX)\n+        return {};\n+\n+    if (type == REPLACE_RANGE)\n+    {\n+        Strings res = replace_range_entry->new_part_names;\n+        auto drop_range_info = MergeTreePartInfo::fromPartName(replace_range_entry->drop_range_part_name, format_version);\n+        if (!ReplaceRangeEntry::isMovePartitionOrAttachFrom(drop_range_info))\n+        {\n+            /// It's REPLACE, not MOVE or ATTACH, so drop range is real\n+            res.emplace_back(replace_range_entry->drop_range_part_name);\n+        }\n+        return res;\n+    }\n+\n+    return {new_part_name};\n+}\n+\n }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\nindex 16bfe2b90364..c6ed0681f00f 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\n@@ -6,6 +6,7 @@\n #include <IO/WriteHelpers.h>\n #include <Storages/MergeTree/MergeTreeDataPartType.h>\n #include <Storages/MergeTree/MergeType.h>\n+#include <Storages/MergeTree/MergeTreeDataFormatVersion.h>\n #include <Disks/IDisk.h>\n \n #include <mutex>\n@@ -18,6 +19,7 @@ namespace DB\n class ReadBuffer;\n class WriteBuffer;\n class ReplicatedMergeTreeQueue;\n+struct MergeTreePartInfo;\n \n namespace ErrorCodes\n {\n@@ -109,6 +111,8 @@ struct ReplicatedMergeTreeLogEntryData\n \n         void writeText(WriteBuffer & out) const;\n         void readText(ReadBuffer & in);\n+\n+        static bool isMovePartitionOrAttachFrom(const MergeTreePartInfo & drop_range_info);\n     };\n \n     std::shared_ptr<ReplaceRangeEntry> replace_range_entry;\n@@ -129,36 +133,13 @@ struct ReplicatedMergeTreeLogEntryData\n \n     /// Returns a set of parts that will appear after executing the entry + parts to block\n     /// selection of merges. These parts are added to queue.virtual_parts.\n-    Strings getVirtualPartNames() const\n-    {\n-        /// Doesn't produce any part\n-        if (type == ALTER_METADATA)\n-            return {};\n-\n-        /// DROP_RANGE does not add a real part, but we must disable merges in that range\n-        if (type == DROP_RANGE)\n-            return {new_part_name};\n-\n-        /// Return {} because selection of merges in the partition where the column is cleared\n-        /// should not be blocked (only execution of merges should be blocked).\n-        if (type == CLEAR_COLUMN || type == CLEAR_INDEX)\n-            return {};\n-\n-        if (type == REPLACE_RANGE)\n-        {\n-            Strings res = replace_range_entry->new_part_names;\n-            res.emplace_back(replace_range_entry->drop_range_part_name);\n-            return res;\n-        }\n-\n-        return {new_part_name};\n-    }\n+    Strings getVirtualPartNames(MergeTreeDataFormatVersion format_version) const;\n \n     /// Returns set of parts that denote the block number ranges that should be blocked during the entry execution.\n     /// These parts are added to future_parts.\n-    Strings getBlockingPartNames() const\n+    Strings getBlockingPartNames(MergeTreeDataFormatVersion format_version) const\n     {\n-        Strings res = getVirtualPartNames();\n+        Strings res = getVirtualPartNames(format_version);\n \n         if (type == CLEAR_COLUMN)\n             res.emplace_back(new_part_name);\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex 422139c21ea2..b81b57125940 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -16,7 +16,6 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int UNEXPECTED_NODE_IN_ZOOKEEPER;\n-    extern const int UNFINISHED;\n     extern const int ABORTED;\n }\n \n@@ -133,7 +132,7 @@ void ReplicatedMergeTreeQueue::insertUnlocked(\n     const LogEntryPtr & entry, std::optional<time_t> & min_unprocessed_insert_time_changed,\n     std::lock_guard<std::mutex> & state_lock)\n {\n-    for (const String & virtual_part_name : entry->getVirtualPartNames())\n+    for (const String & virtual_part_name : entry->getVirtualPartNames(format_version))\n     {\n         virtual_parts.add(virtual_part_name);\n         addPartToMutations(virtual_part_name);\n@@ -220,7 +219,7 @@ void ReplicatedMergeTreeQueue::updateStateOnQueueEntryRemoval(\n             removeCoveredPartsFromMutations(entry->actual_new_part_name, /*remove_part = */ false, /*remove_covered_parts = */ true);\n         }\n \n-        for (const String & virtual_part_name : entry->getVirtualPartNames())\n+        for (const String & virtual_part_name : entry->getVirtualPartNames(format_version))\n         {\n             current_parts.add(virtual_part_name);\n \n@@ -249,7 +248,7 @@ void ReplicatedMergeTreeQueue::updateStateOnQueueEntryRemoval(\n     }\n     else\n     {\n-        for (const String & virtual_part_name : entry->getVirtualPartNames())\n+        for (const String & virtual_part_name : entry->getVirtualPartNames(format_version))\n         {\n             /// Because execution of the entry is unsuccessful,\n             /// `virtual_part_name` will never appear so we won't need to mutate\n@@ -752,7 +751,7 @@ void ReplicatedMergeTreeQueue::updateMutations(zkutil::ZooKeeperPtr zookeeper, C\n                 /// mutation block number that would appear as a result of executing the queue.\n                 for (const auto & queue_entry : queue)\n                 {\n-                    for (const String & produced_part_name : queue_entry->getVirtualPartNames())\n+                    for (const String & produced_part_name : queue_entry->getVirtualPartNames(format_version))\n                     {\n                         auto part_info = MergeTreePartInfo::fromPartName(produced_part_name, format_version);\n \n@@ -926,12 +925,12 @@ void ReplicatedMergeTreeQueue::removePartProducingOpsInRange(\n     {\n         auto type = (*it)->type;\n \n-        if (((type == LogEntry::GET_PART ||\n-              type == LogEntry::ATTACH_PART ||\n-              type == LogEntry::MERGE_PARTS ||\n-              type == LogEntry::MUTATE_PART)\n-             && part_info.contains(MergeTreePartInfo::fromPartName((*it)->new_part_name, format_version)))\n-            || checkReplaceRangeCanBeRemoved(part_info, *it, current))\n+        bool is_simple_producing_op = type == LogEntry::GET_PART ||\n+                                      type == LogEntry::ATTACH_PART ||\n+                                      type == LogEntry::MERGE_PARTS ||\n+                                      type == LogEntry::MUTATE_PART;\n+        bool simple_op_covered = is_simple_producing_op && part_info.contains(MergeTreePartInfo::fromPartName((*it)->new_part_name, format_version));\n+        if (simple_op_covered || checkReplaceRangeCanBeRemoved(part_info, *it, current))\n         {\n             if ((*it)->currently_executing)\n                 to_wait.push_back(*it);\n@@ -964,50 +963,6 @@ void ReplicatedMergeTreeQueue::removePartProducingOpsInRange(\n }\n \n \n-size_t ReplicatedMergeTreeQueue::getConflictsCountForRange(\n-    const MergeTreePartInfo & range, const LogEntry & entry,\n-    String * out_description, std::lock_guard<std::mutex> & /* queue_lock */) const\n-{\n-    std::vector<std::pair<String, LogEntryPtr>> conflicts;\n-\n-    for (const auto & future_part_elem : future_parts)\n-    {\n-        /// Do not check itself log entry\n-        if (future_part_elem.second->znode_name == entry.znode_name)\n-            continue;\n-\n-        if (!range.isDisjoint(MergeTreePartInfo::fromPartName(future_part_elem.first, format_version)))\n-        {\n-            conflicts.emplace_back(future_part_elem.first, future_part_elem.second);\n-            continue;\n-        }\n-    }\n-\n-    if (out_description)\n-    {\n-        WriteBufferFromOwnString ss;\n-        ss << \"Can't execute command for range \" << range.getPartName() << \" (entry \" << entry.znode_name << \"). \";\n-        ss << \"There are \" << conflicts.size() << \" currently executing entries blocking it: \";\n-        for (const auto & conflict : conflicts)\n-            ss << conflict.second->typeToString() << \" part \" << conflict.first << \", \";\n-\n-        *out_description = ss.str();\n-    }\n-\n-    return conflicts.size();\n-}\n-\n-\n-void ReplicatedMergeTreeQueue::checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const LogEntry & entry)\n-{\n-    String conflicts_description;\n-    std::lock_guard lock(state_mutex);\n-\n-    if (0 != getConflictsCountForRange(range, entry, &conflicts_description, lock))\n-        throw Exception(conflicts_description, ErrorCodes::UNFINISHED);\n-}\n-\n-\n bool ReplicatedMergeTreeQueue::isNotCoveredByFuturePartsImpl(const String & log_entry_name, const String & new_part_name,\n                                                              String & out_reason, std::lock_guard<std::mutex> & /* queue_lock */) const\n {\n@@ -1077,7 +1032,7 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(\n         || entry.type == LogEntry::ATTACH_PART\n         || entry.type == LogEntry::MUTATE_PART)\n     {\n-        for (const String & new_part_name : entry.getBlockingPartNames())\n+        for (const String & new_part_name : entry.getBlockingPartNames(format_version))\n         {\n             if (!isNotCoveredByFuturePartsImpl(entry.znode_name, new_part_name, out_postpone_reason, state_lock))\n                 return false;\n@@ -1295,7 +1250,7 @@ ReplicatedMergeTreeQueue::CurrentlyExecuting::CurrentlyExecuting(const Replicate\n     ++entry->num_tries;\n     entry->last_attempt_time = time(nullptr);\n \n-    for (const String & new_part_name : entry->getBlockingPartNames())\n+    for (const String & new_part_name : entry->getBlockingPartNames(queue.format_version))\n     {\n         if (!queue.future_parts.emplace(new_part_name, entry).second)\n             throw Exception(\"Tagging already tagged future part \" + new_part_name + \". This is a bug.\", ErrorCodes::LOGICAL_ERROR);\n@@ -1332,7 +1287,7 @@ ReplicatedMergeTreeQueue::CurrentlyExecuting::~CurrentlyExecuting()\n     entry->currently_executing = false;\n     entry->execution_complete.notify_all();\n \n-    for (const String & new_part_name : entry->getBlockingPartNames())\n+    for (const String & new_part_name : entry->getBlockingPartNames(queue.format_version))\n     {\n         if (!queue.future_parts.erase(new_part_name))\n             LOG_ERROR(queue.log, \"Untagging already untagged future part {}. This is a bug.\", new_part_name);\n@@ -1623,13 +1578,6 @@ bool ReplicatedMergeTreeQueue::tryFinalizeMutations(zkutil::ZooKeeperPtr zookeep\n }\n \n \n-void ReplicatedMergeTreeQueue::disableMergesInBlockRange(const String & part_name)\n-{\n-    std::lock_guard lock(state_mutex);\n-    virtual_parts.add(part_name);\n-}\n-\n-\n ReplicatedMergeTreeQueue::Status ReplicatedMergeTreeQueue::getStatus() const\n {\n     std::lock_guard lock(state_mutex);\n@@ -1912,9 +1860,7 @@ bool ReplicatedMergeTreeMergePredicate::canMergeTwoParts(\n \n     if (left->info.partition_id != right->info.partition_id)\n     {\n-        if (out_reason)\n-            *out_reason = \"Parts \" + left->name + \" and \" + right->name + \" belong to different partitions\";\n-        return false;\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Parts {} and {} belong to different partitions\", left->name, right->name);\n     }\n \n     for (const MergeTreeData::DataPartPtr & part : {left, right})\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\nindex 00ef3ee72929..8b1028623b26 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n@@ -237,11 +237,6 @@ class ReplicatedMergeTreeQueue\n         std::optional<time_t> min_unprocessed_insert_time_changed,\n         std::optional<time_t> max_processed_insert_time_changed) const;\n \n-    /// Returns list of currently executing parts blocking execution a command modifying specified range\n-    size_t getConflictsCountForRange(\n-        const MergeTreePartInfo & range, const LogEntry & entry, String * out_description,\n-        std::lock_guard<std::mutex> & state_lock) const;\n-\n     /// Marks the element of the queue as running.\n     class CurrentlyExecuting\n     {\n@@ -322,10 +317,6 @@ class ReplicatedMergeTreeQueue\n       */\n     void removePartProducingOpsInRange(zkutil::ZooKeeperPtr zookeeper, const MergeTreePartInfo & part_info, const ReplicatedMergeTreeLogEntryData & current);\n \n-    /** Throws and exception if there are currently executing entries in the range .\n-     */\n-    void checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const LogEntry & entry);\n-\n     /** In the case where there are not enough parts to perform the merge in part_name\n       * - move actions with merged parts to the end of the queue\n       * (in order to download a already merged part from another replica).\n@@ -386,12 +377,6 @@ class ReplicatedMergeTreeQueue\n     /// (because some mutations are probably done but we are not sure yet), returns true.\n     bool tryFinalizeMutations(zkutil::ZooKeeperPtr zookeeper);\n \n-    /// Prohibit merges in the specified blocks range.\n-    /// Add part to virtual_parts, which means that part must exist\n-    /// after processing replication log up to log_pointer.\n-    /// Part maybe fake (look at ReplicatedMergeTreeMergePredicate).\n-    void disableMergesInBlockRange(const String & part_name);\n-\n     /// Checks that part is already in virtual parts\n     bool isVirtualPart(const MergeTreeData::DataPartPtr & data_part) const;\n \n@@ -477,7 +462,7 @@ class ReplicatedMergeTreeMergePredicate\n \n     /// Can we assign a merge this part and some other part?\n     /// For example a merge of a part and itself is needed for TTL.\n-    /// This predicate is checked for the first part of each partitition.\n+    /// This predicate is checked for the first part of each range.\n     bool canMergeSinglePart(const MergeTreeData::DataPartPtr & part, String * out_reason) const;\n \n     /// Return nonempty optional of desired mutation version and alter version.\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 4a9cb47df93e..1380512a90e8 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -692,7 +692,7 @@ std::shared_ptr<StorageMergeTree::MergeMutateSelectedEntry> StorageMergeTree::se\n \n     auto can_merge = [this, &lock](const DataPartPtr & left, const DataPartPtr & right, String *) -> bool\n     {\n-        /// This predicate is checked for the first part of each partition.\n+        /// This predicate is checked for the first part of each range.\n         /// (left = nullptr, right = \"first part of partition\")\n         if (!left)\n             return !currently_merging_mutating_parts.count(right);\n@@ -1373,7 +1373,7 @@ void StorageMergeTree::replacePartitionFrom(const StoragePtr & source_table, con\n \n             /// If it is REPLACE (not ATTACH), remove all parts which max_block_number less then min_block_number of the first new block\n             if (replace)\n-                removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);\n+                removePartsInRangeFromWorkingSet(drop_range, true, data_parts_lock);\n         }\n \n         PartLog::addNewParts(getContext(), dst_parts, watch.elapsed());\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 973fc291064c..c0ae46552ec5 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -224,6 +224,26 @@ static String extractZooKeeperPath(const String & path)\n     return normalizeZooKeeperPath(path);\n }\n \n+static MergeTreePartInfo makeDummyDropRangeForMovePartitionOrAttachPartitionFrom(const String & partition_id)\n+{\n+    /// NOTE We don't have special log entry type for MOVE PARTITION/ATTACH PARTITION FROM,\n+    /// so we use REPLACE_RANGE with dummy range of one block, which means \"attach, not replace\".\n+    /// It's safe to fill drop range for MOVE PARTITION/ATTACH PARTITION FROM with zeros,\n+    /// because drop range for REPLACE PARTITION must contain at least 2 blocks,\n+    /// so we can distinguish dummy drop range from any real or virtual part.\n+    /// But we should never construct such part name, even for virtual part,\n+    /// because it can be confused with real part <partition>_0_0_0.\n+    /// TODO get rid of this.\n+\n+    MergeTreePartInfo drop_range;\n+    drop_range.partition_id = partition_id;\n+    drop_range.min_block = 0;\n+    drop_range.max_block = 0;\n+    drop_range.level = 0;\n+    drop_range.mutation = 0;\n+    return drop_range;\n+}\n+\n StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n     const String & zookeeper_path_,\n     const String & replica_name_,\n@@ -2132,7 +2152,7 @@ void StorageReplicatedMergeTree::executeDropRange(const LogEntry & entry)\n     DataPartsVector parts_to_remove;\n     {\n         auto data_parts_lock = lockParts();\n-        parts_to_remove = removePartsInRangeFromWorkingSet(drop_range_info, true, true, data_parts_lock);\n+        parts_to_remove = removePartsInRangeFromWorkingSet(drop_range_info, true, data_parts_lock);\n     }\n \n     if (entry.detach)\n@@ -2164,13 +2184,19 @@ bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n {\n     Stopwatch watch;\n     auto & entry_replace = *entry.replace_range_entry;\n+    LOG_DEBUG(log, \"Executing log entry {} to replace parts range {} with {} parts from {}.{}\",\n+              entry.znode_name, entry_replace.drop_range_part_name, entry_replace.new_part_names.size(),\n+              entry_replace.from_database, entry_replace.from_table);\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n \n     MergeTreePartInfo drop_range = MergeTreePartInfo::fromPartName(entry_replace.drop_range_part_name, format_version);\n-    /// Range with only one block has special meaning ATTACH PARTITION\n-    bool replace = drop_range.getBlocksCount() > 1;\n+    /// Range with only one block has special meaning: it's ATTACH PARTITION or MOVE PARTITION, so there is no drop range\n+    bool replace = !LogEntry::ReplaceRangeEntry::isMovePartitionOrAttachFrom(drop_range);\n \n-    queue.removePartProducingOpsInRange(getZooKeeper(), drop_range, entry);\n+    if (replace)\n+        queue.removePartProducingOpsInRange(getZooKeeper(), drop_range, entry);\n+    else\n+        drop_range = {};\n \n     struct PartDescription\n     {\n@@ -2241,7 +2267,16 @@ bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n         }\n \n         if (parts_to_add.empty() && replace)\n-            parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);\n+        {\n+            parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, data_parts_lock);\n+            String parts_to_remove_str;\n+            for (const auto & part : parts_to_remove)\n+            {\n+                parts_to_remove_str += part->name;\n+                parts_to_remove_str += \" \";\n+            }\n+            LOG_TRACE(log, \"Replacing {} parts {}with empty set\", parts_to_remove.size(), parts_to_remove_str);\n+        }\n     }\n \n     if (parts_to_add.empty())\n@@ -2376,8 +2411,9 @@ bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n \n     /// Filter covered parts\n     PartDescriptions final_parts;\n+    Strings final_part_names;\n     {\n-        Strings final_part_names = adding_parts_active_set.getParts();\n+        final_part_names = adding_parts_active_set.getParts();\n \n         for (const String & final_part_name : final_part_names)\n         {\n@@ -2395,7 +2431,7 @@ bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n                 if (!prev.found_new_part_info.isDisjoint(curr.found_new_part_info))\n                 {\n                     throw Exception(\"Intersected final parts detected: \" + prev.found_new_part_name\n-                        + \" and \" + curr.found_new_part_name + \". It should be investigated.\", ErrorCodes::INCORRECT_DATA);\n+                        + \" and \" + curr.found_new_part_name + \". It should be investigated.\", ErrorCodes::LOGICAL_ERROR);\n                 }\n             }\n         }\n@@ -2474,7 +2510,17 @@ bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n \n             transaction.commit(&data_parts_lock);\n             if (replace)\n-                parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);\n+            {\n+                parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, data_parts_lock);\n+                String parts_to_remove_str;\n+                for (const auto & part : parts_to_remove)\n+                {\n+                    parts_to_remove_str += part->name;\n+                    parts_to_remove_str += \" \";\n+                }\n+                LOG_TRACE(log, \"Replacing {} parts {}with {} parts {}\", parts_to_remove.size(), parts_to_remove_str,\n+                          final_parts.size(), boost::algorithm::join(final_part_names, \", \"));\n+            }\n         }\n \n         PartLog::addNewParts(getContext(), res_parts, watch.elapsed());\n@@ -4836,7 +4882,8 @@ static String getPartNamePossiblyFake(MergeTreeDataFormatVersion format_version,\n     return part_info.getPartName();\n }\n \n-bool StorageReplicatedMergeTree::getFakePartCoveringAllPartsInPartition(const String & partition_id, MergeTreePartInfo & part_info, bool for_replace_partition)\n+bool StorageReplicatedMergeTree::getFakePartCoveringAllPartsInPartition(const String & partition_id, MergeTreePartInfo & part_info,\n+                                                                        std::optional<EphemeralLockInZooKeeper> & delimiting_block_lock, bool for_replace_range)\n {\n     /// Even if there is no data in the partition, you still need to mark the range for deletion.\n     /// - Because before executing DETACH, tasks for downloading parts to this partition can be executed.\n@@ -4853,27 +4900,30 @@ bool StorageReplicatedMergeTree::getFakePartCoveringAllPartsInPartition(const St\n \n     {\n         auto zookeeper = getZooKeeper();\n-        auto block_number_lock = allocateBlockNumber(partition_id, zookeeper);\n-        right = block_number_lock->getNumber();\n-        block_number_lock->unlock();\n+        delimiting_block_lock = allocateBlockNumber(partition_id, zookeeper);\n+        right = delimiting_block_lock->getNumber();\n         mutation_version = queue.getCurrentMutationVersion(partition_id, right);\n     }\n \n-    /// REPLACE PARTITION uses different max level and does not decrement max_block of DROP_RANGE for unknown (probably historical) reason.\n-    auto max_level = std::numeric_limits<decltype(part_info.level)>::max();\n-    if (!for_replace_partition)\n+    if (for_replace_range)\n     {\n-        max_level = MergeTreePartInfo::MAX_LEVEL;\n+        /// NOTE Do not decrement max block number for REPLACE_RANGE, because there are invariants:\n+        /// - drop range for REPLACE PARTITION must contain at least 2 blocks (1 skipped block and at least 1 real block)\n+        /// - drop range for MOVE PARTITION/ATTACH PARTITION FROM always contains 1 block\n \n-        /// Empty partition.\n-        if (right == 0)\n-            return false;\n-\n-        --right;\n+        /// NOTE UINT_MAX was previously used as max level for REPLACE/MOVE PARTITION (it was incorrect)\n+        part_info = MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version);\n+        return right != 0;\n     }\n \n+    /// Empty partition.\n+    if (right == 0)\n+        return false;\n+\n+    --right;\n+\n     /// Artificial high level is chosen, to make this part \"covering\" all parts inside.\n-    part_info = MergeTreePartInfo(partition_id, left, right, max_level, mutation_version);\n+    part_info = MergeTreePartInfo(partition_id, left, right, MergeTreePartInfo::MAX_LEVEL, mutation_version);\n     return true;\n }\n \n@@ -6169,27 +6219,25 @@ void StorageReplicatedMergeTree::replacePartitionFrom(\n     /// So, such case has special meaning, if drop_range contains only one block it means that nothing to drop.\n     /// TODO why not to add normal DROP_RANGE entry to replication queue if `replace` is true?\n     MergeTreePartInfo drop_range;\n-    getFakePartCoveringAllPartsInPartition(partition_id, drop_range, true);\n-    if (!replace)\n-        drop_range.min_block = drop_range.max_block;\n-\n-    String drop_range_fake_part_name = getPartNamePossiblyFake(format_version, drop_range);\n-\n-    if (drop_range.getBlocksCount() > 1)\n+    std::optional<EphemeralLockInZooKeeper> delimiting_block_lock;\n+    bool partition_was_empty = !getFakePartCoveringAllPartsInPartition(partition_id, drop_range, delimiting_block_lock, true);\n+    if (replace && partition_was_empty)\n     {\n-        /// We have to prohibit merges in drop_range, since new merge log entry appeared after this REPLACE FROM entry\n-        ///  could produce new merged part instead in place of just deleted parts.\n-        /// It is better to prohibit them on leader replica (like DROP PARTITION makes),\n-        ///  but it is inconvenient for a user since he could actually use source table from this replica.\n-        /// Therefore prohibit merges on the initializer server now and on the remaining servers when log entry will be executed.\n-        /// It does not provides strong guarantees, but is suitable for intended use case (assume merges are quite rare).\n+        /// Nothing to drop, will just attach new parts\n+        LOG_INFO(log, \"Partition {} was empty, REPLACE PARTITION will work as ATTACH PARTITION FROM\", drop_range.partition_id);\n+        replace = false;\n+    }\n \n-        {\n-            std::lock_guard merge_selecting_lock(merge_selecting_mutex);\n-            queue.disableMergesInBlockRange(drop_range_fake_part_name);\n-        }\n+    if (!replace)\n+    {\n+        /// It's ATTACH PARTITION FROM, not REPLACE PARTITION. We have to reset drop range\n+        drop_range = makeDummyDropRangeForMovePartitionOrAttachPartitionFrom(partition_id);\n     }\n \n+    assert(replace == !LogEntry::ReplaceRangeEntry::isMovePartitionOrAttachFrom(drop_range));\n+\n+    String drop_range_fake_part_name = getPartNamePossiblyFake(format_version, drop_range);\n+\n     for (const auto & src_part : src_all_parts)\n     {\n         /// We also make some kind of deduplication to avoid duplicated parts in case of ATTACH PARTITION\n@@ -6279,7 +6327,9 @@ void StorageReplicatedMergeTree::replacePartitionFrom(\n         if (auto txn = query_context->getZooKeeperMetadataTransaction())\n             txn->moveOpsTo(ops);\n \n-        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));  /// Just update version\n+        delimiting_block_lock->getUnlockOps(ops);\n+        /// Just update version, because merges assignment relies on it\n+        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));\n         ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential));\n \n         Transaction transaction(*this);\n@@ -6291,13 +6341,14 @@ void StorageReplicatedMergeTree::replacePartitionFrom(\n         }\n \n         op_results = zookeeper->multi(ops);\n+        delimiting_block_lock->assumeUnlocked();\n \n         {\n             auto data_parts_lock = lockParts();\n \n             transaction.commit(&data_parts_lock);\n             if (replace)\n-                parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, false, data_parts_lock);\n+                parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, data_parts_lock);\n         }\n \n         PartLog::addNewParts(getContext(), dst_parts, watch.elapsed());\n@@ -6368,15 +6419,10 @@ void StorageReplicatedMergeTree::movePartitionToTable(const StoragePtr & dest_ta\n     /// A range for log entry to remove parts from the source table (myself).\n \n     MergeTreePartInfo drop_range;\n-    getFakePartCoveringAllPartsInPartition(partition_id, drop_range, true);\n+    std::optional<EphemeralLockInZooKeeper> delimiting_block_lock;\n+    getFakePartCoveringAllPartsInPartition(partition_id, drop_range, delimiting_block_lock, true);\n     String drop_range_fake_part_name = getPartNamePossiblyFake(format_version, drop_range);\n \n-    if (drop_range.getBlocksCount() > 1)\n-    {\n-        std::lock_guard merge_selecting_lock(merge_selecting_mutex);\n-        queue.disableMergesInBlockRange(drop_range_fake_part_name);\n-    }\n-\n     /// Clone parts into destination table.\n \n     for (const auto & src_part : src_all_parts)\n@@ -6418,12 +6464,7 @@ void StorageReplicatedMergeTree::movePartitionToTable(const StoragePtr & dest_ta\n \n     ReplicatedMergeTreeLogEntryData entry;\n     {\n-        MergeTreePartInfo drop_range_dest;\n-        drop_range_dest.partition_id = drop_range.partition_id;\n-        drop_range_dest.max_block = drop_range.max_block;\n-        drop_range_dest.min_block = drop_range.max_block;\n-        drop_range_dest.level = drop_range.level;\n-        drop_range_dest.mutation = drop_range.mutation;\n+        MergeTreePartInfo drop_range_dest = makeDummyDropRangeForMovePartitionOrAttachPartitionFrom(partition_id);\n \n         entry.type = ReplicatedMergeTreeLogEntryData::REPLACE_RANGE;\n         entry.source_replica = dest_table_storage->replica_name;\n@@ -6482,7 +6523,7 @@ void StorageReplicatedMergeTree::movePartitionToTable(const StoragePtr & dest_ta\n \n             op_results = zookeeper->multi(ops);\n \n-            parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, false, lock);\n+            parts_to_remove = removePartsInRangeFromWorkingSet(drop_range, true, lock);\n             transaction.commit(&lock);\n         }\n \n@@ -6511,13 +6552,16 @@ void StorageReplicatedMergeTree::movePartitionToTable(const StoragePtr & dest_ta\n         dest_table_storage->waitForAllReplicasToProcessLogEntry(entry);\n     }\n \n-    Coordination::Requests ops_dest;\n+    Coordination::Requests ops_src;\n \n-    ops_dest.emplace_back(zkutil::makeCreateRequest(\n+    ops_src.emplace_back(zkutil::makeCreateRequest(\n         zookeeper_path + \"/log/log-\", entry_delete.toString(), zkutil::CreateMode::PersistentSequential));\n-    ops_dest.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));  /// Just update version\n+    /// Just update version, because merges assignment relies on it\n+    ops_src.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));\n+    delimiting_block_lock->getUnlockOps(ops_src);\n \n-    op_results = zookeeper->multi(ops_dest);\n+    op_results = zookeeper->multi(ops_src);\n+    delimiting_block_lock->assumeUnlocked();\n \n     log_znode_path = dynamic_cast<const Coordination::CreateResponse &>(*op_results.front()).path_created;\n     entry_delete.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);\n@@ -6722,7 +6766,8 @@ bool StorageReplicatedMergeTree::dropPart(\n \n         ops.emplace_back(zkutil::makeCheckRequest(zookeeper_path + \"/log\", merge_pred.getVersion())); /// Make sure no new events were added to the log.\n         ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential));\n-        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));  /// Just update version.\n+        /// Just update version, because merges assignment relies on it\n+        ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));\n         Coordination::Responses responses;\n         Coordination::Error rc = zookeeper->tryMulti(ops, responses);\n \n@@ -6750,7 +6795,9 @@ bool StorageReplicatedMergeTree::dropAllPartsInPartition(\n     zkutil::ZooKeeper & zookeeper, String & partition_id, LogEntry & entry, ContextPtr query_context, bool detach)\n {\n     MergeTreePartInfo drop_range_info;\n-    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info))\n+    /// It prevent other replicas from assigning merges which intersect locked block number.\n+    std::optional<EphemeralLockInZooKeeper> delimiting_block_lock;\n+    if (!getFakePartCoveringAllPartsInPartition(partition_id, drop_range_info, delimiting_block_lock))\n     {\n         LOG_INFO(log, \"Will not drop partition {}, it is empty.\", partition_id);\n         return false;\n@@ -6758,14 +6805,7 @@ bool StorageReplicatedMergeTree::dropAllPartsInPartition(\n \n     clearBlocksInPartition(zookeeper, partition_id, drop_range_info.min_block, drop_range_info.max_block);\n \n-    /** Forbid to choose the parts to be deleted for merging.\n-      * Invariant: after the `DROP_RANGE` entry appears in the log, merge of deleted parts will not appear in the log.\n-      */\n     String drop_range_fake_part_name = getPartNamePossiblyFake(format_version, drop_range_info);\n-    {\n-        std::lock_guard merge_selecting_lock(merge_selecting_mutex);\n-        queue.disableMergesInBlockRange(drop_range_fake_part_name);\n-    }\n \n     LOG_DEBUG(log, \"Disabled merges covered by range {}\", drop_range_fake_part_name);\n \n@@ -6778,10 +6818,13 @@ bool StorageReplicatedMergeTree::dropAllPartsInPartition(\n \n     Coordination::Requests ops;\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/log/log-\", entry.toString(), zkutil::CreateMode::PersistentSequential));\n-    ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));  /// Just update version.\n+    /// Just update version, because merges assignment relies on it\n+    ops.emplace_back(zkutil::makeSetRequest(zookeeper_path + \"/log\", \"\", -1));\n+    delimiting_block_lock->getUnlockOps(ops);\n     if (auto txn = query_context->getZooKeeperMetadataTransaction())\n         txn->moveOpsTo(ops);\n     Coordination::Responses responses = zookeeper.multi(ops);\n+    delimiting_block_lock->assumeUnlocked();\n \n     String log_znode_path = dynamic_cast<const Coordination::CreateResponse &>(*responses.front()).path_created;\n     entry.znode_name = log_znode_path.substr(log_znode_path.find_last_of('/') + 1);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex 24d6b943ec2b..efb013ed491e 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -612,7 +612,10 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     /// Produce an imaginary part info covering all parts in the specified partition (at the call moment).\n     /// Returns false if the partition doesn't exist yet.\n-    bool getFakePartCoveringAllPartsInPartition(const String & partition_id, MergeTreePartInfo & part_info, bool for_replace_partition = false);\n+    /// Caller must hold delimiting_block_lock until creation of drop/replace entry in log.\n+    /// Otherwise some replica may assign merge which intersects part_info.\n+    bool getFakePartCoveringAllPartsInPartition(const String & partition_id, MergeTreePartInfo & part_info,\n+                                                std::optional<EphemeralLockInZooKeeper> & delimiting_block_lock, bool for_replace_range = false);\n \n     /// Check for a node in ZK. If it is, remember this information, and then immediately answer true.\n     mutable std::unordered_set<std::string> existing_nodes_cache;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01154_move_partition_long.reference b/tests/queries/0_stateless/01154_move_partition_long.reference\nnew file mode 100644\nindex 000000000000..c6d9204ed020\n--- /dev/null\n+++ b/tests/queries/0_stateless/01154_move_partition_long.reference\n@@ -0,0 +1,1 @@\n+Replication did not hang\ndiff --git a/tests/queries/0_stateless/01154_move_partition_long.sh b/tests/queries/0_stateless/01154_move_partition_long.sh\nnew file mode 100755\nindex 000000000000..f666cc929ccb\n--- /dev/null\n+++ b/tests/queries/0_stateless/01154_move_partition_long.sh\n@@ -0,0 +1,118 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+declare -A engines\n+engines[0]=\"MergeTree\"\n+engines[1]=\"ReplicatedMergeTree('/test/$CLICKHOUSE_TEST_ZOOKEEPER_PREFIX/src', toString(randConstant()))\"\n+engines[2]=\"ReplicatedMergeTree('/test/$CLICKHOUSE_TEST_ZOOKEEPER_PREFIX/src_' || toString(randConstant()), 'single_replica')\"\n+\n+for ((i=0; i<16; i++)) do\n+    $CLICKHOUSE_CLIENT -q \"CREATE TABLE dst_$i (p UInt64, k UInt64, v UInt64)\n+          ENGINE=ReplicatedMergeTree('/test/$CLICKHOUSE_TEST_ZOOKEEPER_PREFIX/dst', '$i')\n+          PARTITION BY p % 10 ORDER BY k\" 2>&1| grep -Pv \"Retrying createReplica|created by another server at the same moment, will retry\" &\n+    engine=${engines[$((i % ${#engines[@]}))]}\n+    $CLICKHOUSE_CLIENT -q \"CREATE TABLE src_$i (p UInt64, k UInt64, v UInt64) ENGINE=$engine\n+          PARTITION BY p % 10 ORDER BY k\" 2>&1| grep -Pv \"Retrying createReplica|created by another server at the same moment, will retry\" &\n+done\n+wait\n+\n+#function create_drop_thread()\n+#{\n+#    while true; do\n+#        REPLICA=$(($RANDOM % 16))\n+#        $CLICKHOUSE_CLIENT -q \"DROP TABLE src_$REPLICA;\"\n+#        arr=(\"$@\")\n+#        engine=${arr[$RANDOM % ${#arr[@]}]}\n+#        $CLICKHOUSE_CLIENT -q \"CREATE TABLE src_$REPLICA (p UInt64, k UInt64, v UInt64) ENGINE=$engine PARTITION BY p % 10 ORDER BY k\"\n+#        sleep 0.$RANDOM;\n+#    done\n+#}\n+\n+function insert_thread()\n+{\n+    while true; do\n+        REPLICA=$(($RANDOM % 16))\n+        LIMIT=$(($RANDOM % 100))\n+        $CLICKHOUSE_CLIENT -q \"INSERT INTO $1_$REPLICA SELECT * FROM generateRandom('p UInt64, k UInt64, v UInt64') LIMIT $LIMIT\" 2>/dev/null\n+    done\n+}\n+\n+function move_partition_src_dst_thread()\n+{\n+    while true; do\n+        FROM_REPLICA=$(($RANDOM % 16))\n+        TO_REPLICA=$(($RANDOM % 16))\n+        PARTITION=$(($RANDOM % 10))\n+        $CLICKHOUSE_CLIENT -q \"ALTER TABLE src_$FROM_REPLICA MOVE PARTITION $PARTITION TO TABLE dst_$TO_REPLICA\" 2>/dev/null\n+        sleep 0.$RANDOM;\n+    done\n+}\n+\n+function replace_partition_src_src_thread()\n+{\n+    while true; do\n+        FROM_REPLICA=$(($RANDOM % 16))\n+        TO_REPLICA=$(($RANDOM % 16))\n+        PARTITION=$(($RANDOM % 10))\n+        $CLICKHOUSE_CLIENT -q \"ALTER TABLE src_$TO_REPLICA REPLACE PARTITION $PARTITION FROM src_$FROM_REPLICA\" 2>/dev/null\n+        sleep 0.$RANDOM;\n+    done\n+}\n+\n+function drop_partition_thread()\n+{\n+    while true; do\n+        REPLICA=$(($RANDOM % 16))\n+        PARTITION=$(($RANDOM % 10))\n+        $CLICKHOUSE_CLIENT -q \"ALTER TABLE dst_$REPLICA DROP PARTITION $PARTITION\" 2>/dev/null\n+        sleep 0.$RANDOM;\n+    done\n+}\n+\n+function optimize_thread()\n+{\n+  while true; do\n+        REPLICA=$(($RANDOM % 16))\n+        TABLE=\"src\"\n+        if (( RANDOM % 2 )); then\n+            TABLE=\"dst\"\n+        fi\n+        $CLICKHOUSE_CLIENT -q \"OPTIMIZE TABLE ${TABLE}_$REPLICA\" 2>/dev/null\n+        sleep 0.$RANDOM;\n+    done\n+}\n+\n+#export -f create_drop_thread;\n+export -f insert_thread;\n+export -f move_partition_src_dst_thread;\n+export -f replace_partition_src_src_thread;\n+export -f drop_partition_thread;\n+export -f optimize_thread;\n+\n+TIMEOUT=60\n+\n+#timeout $TIMEOUT bash -c \"create_drop_thread ${engines[@]}\" &\n+timeout $TIMEOUT bash -c 'insert_thread src' &\n+timeout $TIMEOUT bash -c 'insert_thread src' &\n+timeout $TIMEOUT bash -c 'insert_thread dst' &\n+timeout $TIMEOUT bash -c move_partition_src_dst_thread &\n+timeout $TIMEOUT bash -c replace_partition_src_src_thread &\n+timeout $TIMEOUT bash -c drop_partition_thread &\n+timeout $TIMEOUT bash -c optimize_thread &\n+wait\n+\n+for ((i=0; i<16; i++)) do\n+    $CLICKHOUSE_CLIENT -q \"SYSTEM SYNC REPLICA dst_$i\" &\n+    $CLICKHOUSE_CLIENT -q \"SYSTEM SYNC REPLICA src_$i\" 2>/dev/null &\n+done\n+wait\n+echo \"Replication did not hang\"\n+\n+for ((i=0; i<16; i++)) do\n+    $CLICKHOUSE_CLIENT -q \"DROP TABLE dst_$i\" &\n+    $CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS src_$i\" &\n+done\n+wait\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex bc12fed0c926..5e2d15a10aa3 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -571,6 +571,7 @@\n         \"01150_ddl_guard_rwr\",\n         \"01153_attach_mv_uuid\",\n         \"01152_cross_replication\",\n+        \"01154_move_partition_long\",\n         \"01185_create_or_replace_table\",\n         \"01190_full_attach_syntax\",\n         \"01191_rename_dictionary\",\n",
  "problem_statement": "Part X intersects next part Y. It is a bug.\n**Describe the bug**\r\nAt some point of time next error appears at log. (After that this error spams the log endlessly..)\r\n\r\n`\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 2021.04.17 17:45:30.287957 [ 780 ] {} <Error> db.table(d577b766-e1b9-4a33-be19-6ac5f968ad41): auto DB::StorageReplicatedMergeTree::processQueueEntry(ReplicatedMergeTreeQueue::SelectedEntryPtr)::(anonymous class)::operator()(DB::StorageReplicatedMergeTree::LogEntryPtr &) const: Code: 49, e.displayText() = DB::Exception: Part d23fba2922c1a8f3adafceb40a86c34c_45540_46193_7_46162 intersects next part d23fba2922c1a8f3adafceb40a86c34c_46190_46194_1 (state Committed). It is a bug.,\r\n`\r\nTable with ReplicatedMergeTree engine.\r\n\r\n**Does it reproduce on recent release?**\r\nReproduces at version 21.3.5.42 \r\n\r\n**How to reproduce**\r\nI didn't find any specific requests around this time: only inserts and several alter deletes ( in 1-hour time range around 17:45)\r\n\r\n\r\n**Error message and/or stacktrace**\r\n`\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 2021.04.17 17:45:30.287957 [ 780 ] {} <Error> db.table (d577b766-e1b9-4a33-be19-6ac5f968ad41): auto DB::StorageReplicatedMergeTree::processQueueEntry(ReplicatedMergeTreeQueue::SelectedEntryPtr)::(anonymous class)::operator()(DB::StorageReplicatedMergeTree::LogEntryPtr &) const: Code: 49, e.displayText() = DB::Exception: Part d23fba2922c1a8f3adafceb40a86c34c_45540_46193_7_46162 intersects next part d23fba2922c1a8f3adafceb40a86c34c_46190_46194_1 (state Committed). It is a bug., Stack trace (when copying this message, always include the lines below):\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 0. DB::MergeTreeData::getActivePartsToReplace(DB::MergeTreePartInfo const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::IMergeTreeDataPart const>&, std::__1::unique_lock<std::__1::mutex>&) const @ 0xf5e6ed0 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 1. DB::MergeTreeData::renameTempPartAndReplace(std::__1::shared_ptr<DB::IMergeTreeDataPart>&, SimpleIncrement*, DB::MergeTreeData::Transaction*, std::__1::unique_lock<std::__1::mutex>&, std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > >*) @ 0xf5e8484 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 2. DB::MergeTreeData::renameTempPartAndReplace(std::__1::shared_ptr<DB::IMergeTreeDataPart>&, SimpleIncrement*, DB::MergeTreeData::Transaction*) @ 0xf5eaabd in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 3. DB::MergeTreeDataMergerMutator::renameMergedTemporaryPart(std::__1::shared_ptr<DB::IMergeTreeDataPart>&, std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > > const&, DB::MergeTreeData::Transaction*) @ 0xf6389f2 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 4. DB::StorageReplicatedMergeTree::tryExecuteMerge(DB::ReplicatedMergeTreeLogEntry const&) @ 0xf3eb027 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 5. DB::StorageReplicatedMergeTree::executeLogEntry(DB::ReplicatedMergeTreeLogEntry&) @ 0xf3dfef2 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 6. ? @ 0xf451b7f in /usr/bin/clickhouse   Apr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 7. DB::ReplicatedMergeTreeQueue::processEntry(std::__1::function<std::__1::shared_ptr<zkutil::ZooKeeper> ()>, std::__1::shared_ptr<DB::ReplicatedMergeTreeLogEntry>&, std::__1::function<bool (std::__1::shared_ptr<DB::ReplicatedMergeTreeLogEntry>&)>) @ 0xf787d98 in /usr/bin/clickhouse                                                                                                                       Apr 17 17:45:30click-inst-1.com clickhouse-server[43]: 8. DB::StorageReplicatedMergeTree::processQueueEntry(std::__1::shared_ptr<DB::ReplicatedMergeTreeQueue::SelectedEntry>) @ 0xf409f3d in /usr/bin/clickhouse        Apr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 9. ? @ 0xf5789a7 in /usr/bin/clickhouse   Apr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 10. ThreadPoolImpl<ThreadFromGlobalPool>::worker(std::__1::__list_iterator<ThreadFromGlobalPool, void*>) @ 0x86502c8 in /usr/bin/clickhouse                       Apr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 11. ThreadFromGlobalPool::ThreadFromGlobalPool<void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()>(void&&, void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()&&...)::'lambda'()::operator()() @ 0x865227f in /usr/bin/clickhouse                                                                                                                Apr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 12. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x864d89f in /usr/bin/clickhouse                               Apr 17 17:45:30 click-inst-1.comu clickhouse-server[43]: 13. ? @ 0x8651333 in /usr/bin/clickhouse\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 14. start_thread @ 0x7dd5 in /usr/lib64/libpthread-2.17.so\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: 15. clone @ 0xfdead in /usr/lib64/libc-2.17.so\r\nApr 17 17:45:30 click-inst-1.com clickhouse-server[43]: (version 21.3.5.42 (official build)) `\r\n\r\n\n",
  "hints_text": "Could you please share output of the following query?\r\n```\r\nWITH\r\n    'd23fba2922c1a8f3adafceb40a86c34c_45540_46193_7_46162' AS p1,\r\n    'd23fba2922c1a8f3adafceb40a86c34c_46190_46194_1' AS p2\r\nSELECT\r\n    materialize(hostName()) AS host,\r\n    *\r\nFROM remote('replica1,replica2,replica3', 'system.part_log')\r\nWHERE (database = 'db') AND (table = 'table') AND ((part_name IN (p1, p2)) OR has(merged_from, p1) OR has(merged_from, p2))\r\nFORMAT Vertical\r\n```\r\n`'replica1,replica2,replica3'` is a comma-separated list of hostnames (or ip addresses) of all replicas\r\n\r\n@gj-zhang, could you please do the same?\r\n```\r\nWITH\r\n    '20210320_89_102_2' AS p1,\r\n    '20210320_98_169_4' AS p2\r\nSELECT\r\n    materialize(hostName()) AS host,\r\n    *\r\nFROM remote('replica1,replica2,replica3', 'system.part_log')\r\nWHERE (database = 'mydatabase') AND (table LIKE 'mytable%') AND ((part_name IN (p1, p2)) OR has(merged_from, p1) OR has(merged_from, p2))\r\nFORMAT Vertical\r\n```\r\n\nI have no system.part_log turned on..\r\nAlso this problem was gone after I deattached/attached part\nHm, similar issue was reported for 20.8.2.3 (#18559) and 1.1.54394.3 ( #4833). Seems like the bug has always existed.\nWe meet this problem almost every day( Currently fix it by detach/attach.\r\nWe have cluster with 4 shards, 2 mirrors in each shard. All CH version 20.8.14.4.\r\nHowever table on which we meet this problems is bit different: it is ReplicatedMergeTree table which is mirrored on each instance(so 8 mirrors, `{shard}` in zk path is same for all insances).\r\nEvery day our ETL system starts to insert lots of data by lots of threads on 4 of 8 CH nodes(insert select into temp table, then move partition to main Replicated table, each thread - different temp table). After some time replication_queue ends with such errors on each node(however parts with problems are different on each node).\r\n\r\nBy the lifetime of our cluster we've met such problems in other tables too, but very rare(maybe 3-4 times in a year), but every day in this table.\r\nAttached here replication queue from one server. \r\nAlso I can upload logs from all servers to some place for CH team(sorry, can't make it public, sensitive data might be) for CH team to analyze.\r\n\r\n[clickhouse-server-db-3_rq.log](https://github.com/ClickHouse/ClickHouse/files/6404653/clickhouse-server-db-3_rq.log)\r\n\nAttached output of query:\r\n```\r\nWITH\r\n    '202103_37087_37167_7' AS p1,\r\n    '202103_37167_37350_11' AS p2\r\nSELECT materialize(hostName()) AS host,\r\n       *\r\nFROM remote(\r\n        <all_hosts>,\r\n        'system.part_log')\r\nWHERE (database = 'db')\r\n  AND (table = 'table')\r\n  AND ((part_name IN (p1, p2)) OR has(merged_from, p1) OR has(merged_from, p2))\r\n```\r\n(Problem parts from previous log)\r\n[out.tar.gz](https://github.com/ClickHouse/ClickHouse/files/6404808/out.tar.gz)\r\n\r\nand with `and event_type!='DownloadPart'` - merges only\r\n[Result_5.csv](https://github.com/ClickHouse/ClickHouse/files/6404813/Result_5.csv)\r\n",
  "created_at": "2021-05-10T18:06:09Z"
}