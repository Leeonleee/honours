{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42003,
  "instance_id": "ClickHouse__ClickHouse-42003",
  "issue_numbers": [
    "32238"
  ],
  "base_commit": "ebf330ca1ad338d77b30b69d1affeda8617bd540",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex e616cb8cf725..2bd873ff230a 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -1088,7 +1088,8 @@ void Client::processConfig()\n     }\n     else\n     {\n-        need_render_progress = config().getBool(\"progress\", false);\n+        std::string progress = config().getString(\"progress\", \"tty\");\n+        need_render_progress = (Poco::icompare(progress, \"off\") && Poco::icompare(progress, \"no\") && Poco::icompare(progress, \"false\") && Poco::icompare(progress, \"0\"));\n         echo_queries = config().getBool(\"echo\", false);\n         ignore_error = config().getBool(\"ignore-error\", false);\n \ndiff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex e7bc019f5976..f9107cfeef60 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -488,7 +488,8 @@ void LocalServer::processConfig()\n     }\n     else\n     {\n-        need_render_progress = config().getBool(\"progress\", false);\n+        std::string progress = config().getString(\"progress\", \"tty\");\n+        need_render_progress = (Poco::icompare(progress, \"off\") && Poco::icompare(progress, \"no\") && Poco::icompare(progress, \"false\") && Poco::icompare(progress, \"0\"));\n         echo_queries = config().hasOption(\"echo\") || config().hasOption(\"verbose\");\n         ignore_error = config().getBool(\"ignore-error\", false);\n         is_multiquery = true;\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 0db7a9533dba..c049667d3651 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -65,10 +65,12 @@\n #include <Interpreters/ReplaceQueryParameterVisitor.h>\n #include <Interpreters/ProfileEventsExt.h>\n #include <IO/WriteBufferFromOStream.h>\n+#include <IO/WriteBufferFromFileDescriptor.h>\n #include <IO/CompressionMethod.h>\n #include <Client/InternalTextLogs.h>\n #include <IO/ForkWriteBuffer.h>\n #include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <boost/algorithm/string/case_conv.hpp>\n \n \n namespace fs = std::filesystem;\n@@ -103,6 +105,7 @@ namespace ErrorCodes\n     extern const int CANNOT_SET_SIGNAL_HANDLER;\n     extern const int UNRECOGNIZED_ARGUMENTS;\n     extern const int LOGICAL_ERROR;\n+    extern const int CANNOT_OPEN_FILE;\n }\n \n }\n@@ -116,6 +119,25 @@ namespace ProfileEvents\n namespace DB\n {\n \n+std::istream& operator>> (std::istream & in, ProgressOption & progress)\n+{\n+    std::string token;\n+    in >> token;\n+\n+    boost::to_upper(token);\n+\n+    if (token == \"OFF\" || token == \"FALSE\" || token == \"0\" || token == \"NO\")\n+        progress = ProgressOption::OFF;\n+    else if (token == \"TTY\" || token == \"ON\" || token == \"TRUE\" || token == \"1\" || token == \"YES\")\n+        progress = ProgressOption::TTY;\n+    else if (token == \"ERR\")\n+        progress = ProgressOption::ERR;\n+    else\n+        throw boost::program_options::validation_error(boost::program_options::validation_error::invalid_option_value);\n+\n+    return in;\n+}\n+\n static ClientInfo::QueryKind parseQueryKind(const String & query_kind)\n {\n     if (query_kind == \"initial_query\")\n@@ -413,8 +435,8 @@ void ClientBase::onData(Block & block, ASTPtr parsed_query)\n         return;\n \n     /// If results are written INTO OUTFILE, we can avoid clearing progress to avoid flicker.\n-    if (need_render_progress && (stdout_is_a_tty || is_interactive) && (!select_into_file || select_into_file_and_stdout))\n-        progress_indication.clearProgressOutput();\n+    if (need_render_progress && tty_buf && (!select_into_file || select_into_file_and_stdout))\n+        progress_indication.clearProgressOutput(*tty_buf);\n \n     try\n     {\n@@ -431,11 +453,11 @@ void ClientBase::onData(Block & block, ASTPtr parsed_query)\n     output_format->flush();\n \n     /// Restore progress bar after data block.\n-    if (need_render_progress && (stdout_is_a_tty || is_interactive))\n+    if (need_render_progress && tty_buf)\n     {\n         if (select_into_file && !select_into_file_and_stdout)\n             std::cerr << \"\\r\";\n-        progress_indication.writeProgress();\n+        progress_indication.writeProgress(*tty_buf);\n     }\n }\n \n@@ -443,7 +465,8 @@ void ClientBase::onData(Block & block, ASTPtr parsed_query)\n void ClientBase::onLogData(Block & block)\n {\n     initLogsOutputStream();\n-    progress_indication.clearProgressOutput();\n+    if (need_render_progress && tty_buf)\n+        progress_indication.clearProgressOutput(*tty_buf);\n     logs_out_stream->writeLogs(block);\n     logs_out_stream->flush();\n }\n@@ -639,6 +662,58 @@ void ClientBase::initLogsOutputStream()\n     }\n }\n \n+void ClientBase::initTtyBuffer(bool to_err)\n+{\n+    if (!tty_buf)\n+    {\n+        static constexpr auto tty_file_name = \"/dev/tty\";\n+\n+        /// Output all progress bar commands to terminal at once to avoid flicker.\n+        /// This size is usually greater than the window size.\n+        static constexpr size_t buf_size = 1024;\n+\n+        if (!to_err)\n+        {\n+            std::error_code ec;\n+            std::filesystem::file_status tty = std::filesystem::status(tty_file_name, ec);\n+\n+            if (!ec && exists(tty) && is_character_file(tty)\n+                && (tty.permissions() & std::filesystem::perms::others_write) != std::filesystem::perms::none)\n+            {\n+                try\n+                {\n+                    tty_buf = std::make_unique<WriteBufferFromFile>(tty_file_name, buf_size);\n+\n+                    /// It is possible that the terminal file has writeable permissions\n+                    /// but we cannot write anything there. Check it with invisible character.\n+                    tty_buf->write('\\0');\n+                    tty_buf->next();\n+\n+                    return;\n+                }\n+                catch (const Exception & e)\n+                {\n+                    if (tty_buf)\n+                        tty_buf.reset();\n+\n+                    if (e.code() != ErrorCodes::CANNOT_OPEN_FILE)\n+                        throw;\n+\n+                    /// It is normal if file exists, indicated as writeable but still cannot be opened.\n+                    /// Fallback to other options.\n+                }\n+            }\n+        }\n+\n+        if (stderr_is_a_tty)\n+        {\n+            tty_buf = std::make_unique<WriteBufferFromFileDescriptor>(STDERR_FILENO, buf_size);\n+        }\n+        else\n+            need_render_progress = false;\n+    }\n+}\n+\n void ClientBase::updateSuggest(const ASTPtr & ast)\n {\n     std::vector<std::string> new_words;\n@@ -937,14 +1012,15 @@ void ClientBase::onProgress(const Progress & value)\n     if (output_format)\n         output_format->onProgress(value);\n \n-    if (need_render_progress)\n-        progress_indication.writeProgress();\n+    if (need_render_progress && tty_buf)\n+        progress_indication.writeProgress(*tty_buf);\n }\n \n \n void ClientBase::onEndOfStream()\n {\n-    progress_indication.clearProgressOutput();\n+    if (need_render_progress && tty_buf)\n+        progress_indication.clearProgressOutput(*tty_buf);\n \n     if (output_format)\n         output_format->finalize();\n@@ -952,10 +1028,7 @@ void ClientBase::onEndOfStream()\n     resetOutput();\n \n     if (is_interactive && !written_first_block)\n-    {\n-        progress_indication.clearProgressOutput();\n         std::cout << \"Ok.\" << std::endl;\n-    }\n }\n \n \n@@ -998,15 +1071,16 @@ void ClientBase::onProfileEvents(Block & block)\n         }\n         progress_indication.updateThreadEventData(thread_times);\n \n-        if (need_render_progress)\n-            progress_indication.writeProgress();\n+        if (need_render_progress && tty_buf)\n+            progress_indication.writeProgress(*tty_buf);\n \n         if (profile_events.print)\n         {\n             if (profile_events.watch.elapsedMilliseconds() >= profile_events.delay_ms)\n             {\n                 initLogsOutputStream();\n-                progress_indication.clearProgressOutput();\n+                if (need_render_progress && tty_buf)\n+                    progress_indication.clearProgressOutput(*tty_buf);\n                 logs_out_stream->writeProfileEvents(block);\n                 logs_out_stream->flush();\n \n@@ -1180,7 +1254,8 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des\n         progress_indication.updateProgress(Progress(file_progress));\n \n         /// Set callback to be called on file progress.\n-        progress_indication.setFileProgressCallback(global_context, true);\n+        if (tty_buf)\n+            progress_indication.setFileProgressCallback(global_context, *tty_buf);\n     }\n \n     /// If data fetched from file (maybe compressed file)\n@@ -1432,12 +1507,12 @@ bool ClientBase::receiveEndOfQuery()\n void ClientBase::cancelQuery()\n {\n     connection->sendCancel();\n+    if (need_render_progress && tty_buf)\n+        progress_indication.clearProgressOutput(*tty_buf);\n+\n     if (is_interactive)\n-    {\n-        progress_indication.clearProgressOutput();\n         std::cout << \"Cancelling query.\" << std::endl;\n \n-    }\n     cancelled = true;\n }\n \n@@ -1557,7 +1632,8 @@ void ClientBase::processParsedSingleQuery(const String & full_query, const Strin\n     if (profile_events.last_block)\n     {\n         initLogsOutputStream();\n-        progress_indication.clearProgressOutput();\n+        if (need_render_progress && tty_buf)\n+            progress_indication.clearProgressOutput(*tty_buf);\n         logs_out_stream->writeProfileEvents(profile_events.last_block);\n         logs_out_stream->flush();\n \n@@ -2244,7 +2320,7 @@ void ClientBase::init(int argc, char ** argv)\n         (\"stage\", po::value<std::string>()->default_value(\"complete\"), \"Request query processing up to specified stage: complete,fetch_columns,with_mergeable_state,with_mergeable_state_after_aggregation,with_mergeable_state_after_aggregation_and_limit\")\n         (\"query_kind\", po::value<std::string>()->default_value(\"initial_query\"), \"One of initial_query/secondary_query/no_query\")\n         (\"query_id\", po::value<std::string>(), \"query_id\")\n-        (\"progress\", \"print progress of queries execution\")\n+        (\"progress\", po::value<ProgressOption>()->implicit_value(ProgressOption::TTY, \"tty\")->default_value(ProgressOption::TTY, \"tty\"), \"Print progress of queries execution - to TTY (default): tty|on|1|true|yes; to STDERR: err; OFF: off|0|false|no\")\n \n         (\"disable_suggestion,A\", \"Disable loading suggestion data. Note that suggestion data is loaded asynchronously through a second connection to ClickHouse server. Also it is reasonable to disable suggestion if you want to paste a query with TAB characters. Shorthand option -A is for those who get used to mysql client.\")\n         (\"time,t\", \"print query execution time to stderr in non-interactive mode (for benchmarks)\")\n@@ -2299,6 +2375,11 @@ void ClientBase::init(int argc, char ** argv)\n     parseAndCheckOptions(options_description, options, common_arguments);\n     po::notify(options);\n \n+    if (options[\"progress\"].as<ProgressOption>() == ProgressOption::OFF)\n+        need_render_progress = false;\n+    else\n+        initTtyBuffer(options[\"progress\"].as<ProgressOption>() == ProgressOption::ERR);\n+\n     if (options.count(\"version\") || options.count(\"V\"))\n     {\n         showClientVersion();\n@@ -2349,7 +2430,20 @@ void ClientBase::init(int argc, char ** argv)\n     if (options.count(\"profile-events-delay-ms\"))\n         config().setInt(\"profile-events-delay-ms\", options[\"profile-events-delay-ms\"].as<UInt64>());\n     if (options.count(\"progress\"))\n-        config().setBool(\"progress\", true);\n+    {\n+        switch (options[\"progress\"].as<ProgressOption>())\n+        {\n+            case OFF:\n+                config().setString(\"progress\", \"off\");\n+                break;\n+            case TTY:\n+                config().setString(\"progress\", \"tty\");\n+                break;\n+            case ERR:\n+                config().setString(\"progress\", \"err\");\n+                break;\n+        }\n+    }\n     if (options.count(\"echo\"))\n         config().setBool(\"echo\", true);\n     if (options.count(\"disable_suggestion\"))\ndiff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h\nindex 01edb65e1353..e40f87f9d1e1 100644\n--- a/src/Client/ClientBase.h\n+++ b/src/Client/ClientBase.h\n@@ -15,6 +15,7 @@\n #include <Storages/StorageFile.h>\n #include <Storages/SelectQueryInfo.h>\n \n+\n namespace po = boost::program_options;\n \n \n@@ -35,9 +36,18 @@ enum MultiQueryProcessingStage\n     PARSING_FAILED,\n };\n \n+enum ProgressOption\n+{\n+    OFF,\n+    TTY,\n+    ERR,\n+};\n+std::istream& operator>> (std::istream & in, ProgressOption & progress);\n+\n void interruptSignalHandler(int signum);\n \n class InternalTextLogs;\n+class WriteBufferFromFileDescriptor;\n \n class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n {\n@@ -143,6 +153,7 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n \n     void initOutputFormat(const Block & block, ASTPtr parsed_query);\n     void initLogsOutputStream();\n+    void initTtyBuffer(bool to_err = false);\n \n     String prompt() const;\n \n@@ -218,6 +229,10 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n     String server_logs_file;\n     std::unique_ptr<InternalTextLogs> logs_out_stream;\n \n+    /// /dev/tty if accessible or std::cerr - for progress bar.\n+    /// We prefer to output progress bar directly to tty to allow user to redirect stdout and stderr and still get the progress indication.\n+    std::unique_ptr<WriteBufferFromFileDescriptor> tty_buf;\n+\n     String home_path;\n     String history_file; /// Path to a file containing command history.\n \ndiff --git a/src/Common/ProgressIndication.cpp b/src/Common/ProgressIndication.cpp\nindex 166e98f3d3c4..b049edcdcf72 100644\n--- a/src/Common/ProgressIndication.cpp\n+++ b/src/Common/ProgressIndication.cpp\n@@ -2,6 +2,7 @@\n #include <algorithm>\n #include <cstddef>\n #include <numeric>\n+#include <filesystem>\n #include <cmath>\n #include <IO/WriteBufferFromFileDescriptor.h>\n #include <base/types.h>\n@@ -11,6 +12,9 @@\n #include \"IO/WriteBufferFromString.h\"\n #include <Databases/DatabaseMemory.h>\n \n+/// http://en.wikipedia.org/wiki/ANSI_escape_code\n+#define CLEAR_TO_END_OF_LINE \"\\033[K\"\n+\n \n namespace\n {\n@@ -44,15 +48,6 @@ bool ProgressIndication::updateProgress(const Progress & value)\n     return progress.incrementPiecewiseAtomically(value);\n }\n \n-void ProgressIndication::clearProgressOutput()\n-{\n-    if (written_progress_chars)\n-    {\n-        written_progress_chars = 0;\n-        std::cerr << \"\\r\" CLEAR_TO_END_OF_LINE;\n-    }\n-}\n-\n void ProgressIndication::resetProgress()\n {\n     watch.restart();\n@@ -67,15 +62,12 @@ void ProgressIndication::resetProgress()\n     }\n }\n \n-void ProgressIndication::setFileProgressCallback(ContextMutablePtr context, bool write_progress_on_update_)\n+void ProgressIndication::setFileProgressCallback(ContextMutablePtr context, WriteBufferFromFileDescriptor & message)\n {\n-    write_progress_on_update = write_progress_on_update_;\n     context->setFileProgressCallback([&](const FileProgress & file_progress)\n     {\n         progress.incrementPiecewiseAtomically(Progress(file_progress));\n-\n-        if (write_progress_on_update)\n-            writeProgress();\n+        writeProgress(message);\n     });\n }\n \n@@ -142,13 +134,10 @@ void ProgressIndication::writeFinalProgress()\n         std::cout << \". \";\n }\n \n-void ProgressIndication::writeProgress()\n+void ProgressIndication::writeProgress(WriteBufferFromFileDescriptor & message)\n {\n     std::lock_guard lock(progress_mutex);\n \n-    /// Output all progress bar commands to stderr at once to avoid flicker.\n-    WriteBufferFromFileDescriptor message(STDERR_FILENO, 1024);\n-\n     static size_t increment = 0;\n     static const char * indicators[8] = {\n         \"\\033[1;30m\u2192\\033[0m\",\n@@ -307,4 +296,14 @@ void ProgressIndication::writeProgress()\n     message.next();\n }\n \n+void ProgressIndication::clearProgressOutput(WriteBufferFromFileDescriptor & message)\n+{\n+    if (written_progress_chars)\n+    {\n+        written_progress_chars = 0;\n+        message << \"\\r\" CLEAR_TO_END_OF_LINE;\n+        message.next();\n+    }\n+}\n+\n }\ndiff --git a/src/Common/ProgressIndication.h b/src/Common/ProgressIndication.h\nindex cdbe0b1e0d4d..294b7c9a493e 100644\n--- a/src/Common/ProgressIndication.h\n+++ b/src/Common/ProgressIndication.h\n@@ -9,12 +9,12 @@\n #include <Common/Stopwatch.h>\n #include <Common/EventRateMeter.h>\n \n-/// http://en.wikipedia.org/wiki/ANSI_escape_code\n-#define CLEAR_TO_END_OF_LINE \"\\033[K\"\n \n namespace DB\n {\n \n+class WriteBufferFromFileDescriptor;\n+\n struct ThreadEventData\n {\n     UInt64 time() const noexcept { return user_ms + system_ms; }\n@@ -30,14 +30,13 @@ using HostToThreadTimesMap = std::unordered_map<String, ThreadIdToTimeMap>;\n class ProgressIndication\n {\n public:\n-    /// Write progress to stderr.\n-    void writeProgress();\n+    /// Write progress bar.\n+    void writeProgress(WriteBufferFromFileDescriptor & message);\n+    void clearProgressOutput(WriteBufferFromFileDescriptor & message);\n \n+    /// Write summary.\n     void writeFinalProgress();\n \n-    /// Clear stderr output.\n-    void clearProgressOutput();\n-\n     /// Reset progress values.\n     void resetProgress();\n \n@@ -52,7 +51,7 @@ class ProgressIndication\n     /// In some cases there is a need to update progress value, when there is no access to progress_inidcation object.\n     /// In this case it is added via context.\n     /// `write_progress_on_update` is needed to write progress for loading files data via pipe in non-interactive mode.\n-    void setFileProgressCallback(ContextMutablePtr context, bool write_progress_on_update = false);\n+    void setFileProgressCallback(ContextMutablePtr context, WriteBufferFromFileDescriptor & message);\n \n     /// How much seconds passed since query execution start.\n     double elapsedSeconds() const { return getElapsedNanoseconds() / 1e9; }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.expect b/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.expect\nnew file mode 100755\nindex 000000000000..20333ae79609\n--- /dev/null\n+++ b/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.expect\n@@ -0,0 +1,32 @@\n+#!/usr/bin/expect -f\n+# Tags: long\n+\n+# This is the regression for the concurrent access in ProgressIndication,\n+# so it is important to read enough rows here (10e6).\n+#\n+# Initially there was 100e6, but under thread fuzzer 10min may be not enough sometimes,\n+# but I believe that CI will catch possible issues even with less rows anyway.\n+\n+set basedir [file dirname $argv0]\n+set basename [file tail $argv0]\n+exp_internal -f $env(CLICKHOUSE_TMP)/$basename.debuglog 0\n+\n+log_user 0\n+set timeout 60\n+match_max 100000\n+set stty_init \"rows 25 cols 120\"\n+\n+expect_after {\n+    eof { exp_continue }\n+    timeout { exit 1 }\n+}\n+\n+spawn bash\n+send \"source $basedir/../shell_config.sh\\r\"\n+\n+send \"yes | head -n10000000 | \\$CLICKHOUSE_CLIENT --query \\\"insert into function null('foo String') format TSV\\\" >/dev/null\\r\"\n+expect \"Progress: \"\n+send \"\\3\"\n+\n+send \"exit\\r\"\n+expect eof\ndiff --git a/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.reference b/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.reference\nindex 64ab61e67658..e69de29bb2d1 100644\n--- a/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.reference\n+++ b/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.reference\n@@ -1,2 +0,0 @@\n-0\n---progress produce some rows\ndiff --git a/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.sh b/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.sh\ndeleted file mode 100755\nindex 6c37d870652a..000000000000\n--- a/tests/queries/0_stateless/02310_clickhouse_client_INSERT_progress_profile_events.sh\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-#!/usr/bin/env bash\n-# Tags: long\n-\n-# This is the regression for the concurrent access in ProgressIndication,\n-# so it is important to read enough rows here (10e6).\n-#\n-# Initially there was 100e6, but under thread fuzzer 10min may be not enough sometimes,\n-# but I believe that CI will catch possible issues even with less rows anyway.\n-\n-CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n-# shellcheck source=../shell_config.sh\n-. \"$CUR_DIR\"/../shell_config.sh\n-\n-tmp_file_progress=\"$(mktemp \"$CUR_DIR/$CLICKHOUSE_TEST_UNIQUE_NAME.XXXXXX.progress\")\"\n-trap 'rm $tmp_file_progress' EXIT\n-\n-yes | head -n10000000 | $CLICKHOUSE_CLIENT -q \"insert into function null('foo String') format TSV\" --progress 2> \"$tmp_file_progress\"\n-echo $?\n-test -s \"$tmp_file_progress\" && echo \"--progress produce some rows\" || echo \"FAIL: no rows with --progress\"\ndiff --git a/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.expect b/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.expect\nnew file mode 100755\nindex 000000000000..5c95e17aefd8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.expect\n@@ -0,0 +1,32 @@\n+#!/usr/bin/expect -f\n+# Tags: long\n+\n+# This is the regression for the concurrent access in ProgressIndication,\n+# so it is important to read enough rows here (10e6).\n+#\n+# Initially there was 100e6, but under thread fuzzer 10min may be not enough sometimes,\n+# but I believe that CI will catch possible issues even with less rows anyway.\n+\n+set basedir [file dirname $argv0]\n+set basename [file tail $argv0]\n+exp_internal -f $env(CLICKHOUSE_TMP)/$basename.debuglog 0\n+\n+log_user 0\n+set timeout 60\n+match_max 100000\n+set stty_init \"rows 25 cols 120\"\n+\n+expect_after {\n+    eof { exp_continue }\n+    timeout { exit 1 }\n+}\n+\n+spawn bash\n+send \"source $basedir/../shell_config.sh\\r\"\n+\n+send \"yes | head -n10000000 | \\$CLICKHOUSE_LOCAL --query \\\"insert into function null('foo String') format TSV\\\" >/dev/null\\r\"\n+expect \"Progress: \"\n+send \"\\3\"\n+\n+send \"exit\\r\"\n+expect eof\ndiff --git a/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.reference b/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.reference\nindex 64ab61e67658..e69de29bb2d1 100644\n--- a/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.reference\n+++ b/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.reference\n@@ -1,2 +0,0 @@\n-0\n---progress produce some rows\ndiff --git a/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.sh b/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.sh\ndeleted file mode 100755\nindex 00a8b7a2a905..000000000000\n--- a/tests/queries/0_stateless/02310_clickhouse_local_INSERT_progress_profile_events.sh\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-#!/usr/bin/env bash\n-# Tags: long\n-\n-# This is the regression for the concurrent access in ProgressIndication,\n-# so it is important to read enough rows here (10e6).\n-#\n-# Initially there was 100e6, but under thread fuzzer 10min may be not enough sometimes,\n-# but I believe that CI will catch possible issues even with less rows anyway.\n-\n-CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n-# shellcheck source=../shell_config.sh\n-. \"$CUR_DIR\"/../shell_config.sh\n-\n-tmp_file_progress=\"$(mktemp \"$CUR_DIR/$CLICKHOUSE_TEST_UNIQUE_NAME.XXXXXX.progress\")\"\n-trap 'rm $tmp_file_progress' EXIT\n-\n-yes | head -n10000000 | $CLICKHOUSE_LOCAL -q \"insert into function null('foo String') format TSV\" --progress 2> \"$tmp_file_progress\"\n-echo $?\n-test -s \"$tmp_file_progress\" && echo \"--progress produce some rows\" || echo \"FAIL: no rows with --progress\"\ndiff --git a/tests/queries/0_stateless/02456_progress_tty.expect b/tests/queries/0_stateless/02456_progress_tty.expect\nnew file mode 100755\nindex 000000000000..9daa6caa3fa5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02456_progress_tty.expect\n@@ -0,0 +1,55 @@\n+#!/usr/bin/expect -f\n+\n+set basedir [file dirname $argv0]\n+set basename [file tail $argv0]\n+exp_internal -f $env(CLICKHOUSE_TMP)/$basename.debuglog 0\n+\n+log_user 0\n+set timeout 60\n+match_max 100000\n+set stty_init \"rows 25 cols 120\"\n+\n+expect_after {\n+    eof { exp_continue }\n+    timeout { exit 1 }\n+}\n+\n+spawn bash\n+send \"source $basedir/../shell_config.sh\\r\"\n+\n+# Progress is displayed by default\n+send \"\\$CLICKHOUSE_LOCAL --query 'SELECT sum(sleep(1) = 0) FROM numbers(3) SETTINGS max_block_size = 1' >/dev/null\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+\n+# It is true even if we redirect both stdout and stderr to /dev/null\n+send \"\\$CLICKHOUSE_LOCAL --query 'SELECT sum(sleep(1) = 0) FROM numbers(3) SETTINGS max_block_size = 1' >/dev/null 2>&1\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+\n+# The option --progress has implicit value of true\n+send \"\\$CLICKHOUSE_LOCAL --progress --query 'SELECT sum(sleep(1) = 0) FROM numbers(3) SETTINGS max_block_size = 1' >/dev/null 2>&1\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+\n+# But we can set it to false\n+send \"\\$CLICKHOUSE_LOCAL --progress false --query 'SELECT sleep(1), \\$\\$Hello\\$\\$ FROM numbers(3) SETTINGS max_block_size = 1' 2>/dev/null\\r\"\n+expect -exact \"0\\tHello\\r\\n\"\n+send \"\\3\"\n+\n+# As well as to 0 for the same effect\n+send \"\\$CLICKHOUSE_LOCAL --progress 0 --query 'SELECT sleep(1), \\$\\$Hello\\$\\$ FROM numbers(3) SETTINGS max_block_size = 1' 2>/dev/null\\r\"\n+expect -exact \"0\\tHello\\r\\n\"\n+send \"\\3\"\n+\n+# If we set it to 1, the progress will be displayed as well\n+send \"\\$CLICKHOUSE_LOCAL --progress 1 --query 'SELECT sum(sleep(1) = 0) FROM numbers(3) SETTINGS max_block_size = 1' >/dev/null 2>&1\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+\n+send \"exit\\r\"\n+expect eof\ndiff --git a/tests/queries/0_stateless/02456_progress_tty.reference b/tests/queries/0_stateless/02456_progress_tty.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\n",
  "problem_statement": "Show progress by default in non-interactive mode if stderr is a terminal.\nMotivation: I want all the beauty by default.\r\n\r\nAlso change the behaviour of `--progress` option.\r\n`--progress 0` will turn off the progress indication.\r\n\r\nDownsides: if you run a shell script with multiple invocations of clickhouse-client, you will also see the progress of every invocation while the script is being run. Actually this can be considered as improvement.\r\n\r\nAlternatively we can write progress to `/dev/tty` instead of stderr. It will allow to show progress even if stderr is redirected.\r\nBut it may look too surprising for user.\n",
  "hints_text": "Only if a terminal exists, without breaking bash/cron scripts",
  "created_at": "2022-10-01T21:22:35Z"
}