diff --git a/base/base/bit_cast.h b/base/base/bit_cast.h
index 5373ead36e80..4783a84586b0 100644
--- a/base/base/bit_cast.h
+++ b/base/base/bit_cast.h
@@ -7,7 +7,13 @@
 
 /** Returns value `from` converted to type `To` while retaining bit representation.
   * `To` and `From` must satisfy `CopyConstructible`.
+  *
   * In contrast to std::bit_cast can cast types of different width.
+  *
+  * Note: for signed types of narrower size, the casted result is zero-extended
+  * instead of sign-extended as with regular static_cast.
+  * For example, -1 Int8 (represented as 0xFF) bit_casted to UInt64
+  * gives 255 (represented as 0x00000000000000FF) instead of 0xFFFFFFFFFFFFFFFF
   */
 template <typename To, typename From>
 std::decay_t<To> bit_cast(const From & from)
diff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp
index 9970012ef4a7..8d6e53c491e4 100644
--- a/src/Functions/transform.cpp
+++ b/src/Functions/transform.cpp
@@ -5,6 +5,7 @@
 #include <Columns/ColumnConst.h>
 #include <Columns/ColumnDecimal.h>
 #include <Columns/ColumnString.h>
+#include <Columns/ColumnNullable.h>
 #include <Core/DecimalFunctions.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/getLeastSupertype.h>
@@ -13,9 +14,10 @@
 #include <Functions/IFunction.h>
 #include <Interpreters/castColumn.h>
 #include <Interpreters/convertFieldToType.h>
-#include <Common/Arena.h>
 #include <Common/HashTable/HashMap.h>
 #include <Common/typeid_cast.h>
+#include <Common/FieldVisitorsAccurateComparison.h>
+
 
 namespace DB
 {
@@ -25,32 +27,31 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_COLUMN;
+    extern const int LOGICAL_ERROR;
 }
 
 namespace
 {
-    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.
-  */
     /** transform(x, [from...], [to...], default)
-  * - converts the values according to the explicitly specified mapping.
-  *
-  * x - what to transform.
-  * from - a constant array of values for the transformation.
-  * to - a constant array of values into which values from `from` must be transformed.
-  * default - what value to use if x is not equal to any of the values in `from`.
-  * `from` and `to` - arrays of the same size.
-  *
-  * Types:
-  * transform(T, Array(T), Array(U), U) -> U
-  *
-  * transform(x, [from...], [to...])
-  * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.
-  *
-  * Types:
-  * transform(T, Array(T), Array(T)) -> T
-  *
-  * Note: the implementation is rather cumbersome.
-  */
+      * - converts the values according to the explicitly specified mapping.
+      *
+      * x - what to transform.
+      * from - a constant array of values for the transformation.
+      * to - a constant array of values into which values from `from` must be transformed.
+      * default - what value to use if x is not equal to any of the values in `from`.
+      * `from` and `to` - arrays of the same size.
+      *
+      * Types:
+      * transform(T, Array(T), Array(U), U) -> U
+      *
+      * transform(x, [from...], [to...])
+      * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.
+      *
+      * Types:
+      * transform(T, Array(T), Array(T)) -> T
+      *
+      * Note: the implementation is rather cumbersome.
+      */
     class FunctionTransform : public IFunction
     {
     public:
@@ -79,15 +80,6 @@ namespace
                     args_size);
 
             const DataTypePtr & type_x = arguments[0];
-            const auto & type_x_nn = removeNullable(type_x);
-
-            if (!type_x_nn->isValueRepresentedByNumber() && !isString(type_x_nn) && !isNothing(type_x_nn))
-                throw Exception(
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Unsupported type {} of first argument "
-                    "of function {}, must be numeric type or Date/DateTime or String",
-                    type_x->getName(),
-                    getName());
 
             const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());
 
@@ -99,14 +91,16 @@ namespace
 
             const auto type_arr_from_nested = type_arr_from->getNestedType();
 
-            if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())
-                || (isString(type_x) != isString(type_arr_from_nested)))
+            auto src = tryGetLeastSupertype(DataTypes{type_x, type_arr_from_nested});
+            if (!src
+                /// Compatibility with previous versions, that allowed even UInt64 with Int64,
+                /// regardless of ambiguous conversions.
+                && !isNativeNumber(type_x) && !isNativeNumber(type_arr_from_nested))
             {
                 throw Exception(
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "First argument and elements of array "
-                    "of second argument of function {} must have compatible types: "
-                    "both numeric or both strings.",
+                    "of the second argument of function {} must have compatible types",
                     getName());
             }
 
@@ -157,8 +151,8 @@ namespace
             }
         }
 
-        ColumnPtr
-        executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+        ColumnPtr executeImpl(
+            const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
         {
             initialize(arguments, result_type);
 
@@ -172,22 +166,42 @@ namespace
                 default_non_const = castColumn(arguments[3], result_type);
 
             auto column_result = result_type->createColumn();
-            if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)
-                && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const)
-                && !executeString(in, *column_result, default_non_const))
+            if (cache.is_empty)
             {
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
+                return default_non_const
+                    ? default_non_const
+                    : castColumn(arguments[0], result_type);
             }
+            else if (cache.table_num_to_idx)
+            {
+                if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)
+                    && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const))
+                {
+                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
+                }
+            }
+            else if (cache.table_string_to_idx)
+            {
+                if (!executeString(in, *column_result, default_non_const))
+                    executeContiguous(in, *column_result, default_non_const);
+            }
+            else if (cache.table_anything_to_idx)
+            {
+                executeAnything(in, *column_result, default_non_const);
+            }
+            else
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "State of the function `transform` is not initialized");
+
             return column_result;
         }
 
@@ -204,6 +218,47 @@ namespace
             return impl->execute(args, result_type, input_rows_count);
         }
 
+        void executeAnything(const IColumn * in, IColumn & column_result, const ColumnPtr default_non_const) const
+        {
+            const size_t size = in->size();
+            const auto & table = *cache.table_anything_to_idx;
+            column_result.reserve(size);
+            for (size_t i = 0; i < size; ++i)
+            {
+                SipHash hash;
+                in->updateHashWithValue(i, hash);
+
+                const auto * it = table.find(hash.get128());
+                if (it)
+                    column_result.insertFrom(*cache.to_column, it->getMapped());
+                else if (cache.default_column)
+                    column_result.insertFrom(*cache.default_column, 0);
+                else if (default_non_const)
+                    column_result.insertFrom(*default_non_const, i);
+                else
+                    column_result.insertFrom(*in, i);
+            }
+        }
+
+        void executeContiguous(const IColumn * in, IColumn & column_result, const ColumnPtr default_non_const) const
+        {
+            const size_t size = in->size();
+            const auto & table = *cache.table_string_to_idx;
+            column_result.reserve(size);
+            for (size_t i = 0; i < size; ++i)
+            {
+                const auto * it = table.find(in->getDataAt(i));
+                if (it)
+                    column_result.insertFrom(*cache.to_column, it->getMapped());
+                else if (cache.default_column)
+                    column_result.insertFrom(*cache.default_column, 0);
+                else if (default_non_const)
+                    column_result.insertFrom(*default_non_const, i);
+                else
+                    column_result.insertFrom(*in, i);
+            }
+        }
+
         template <typename T>
         bool executeNum(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const
         {
@@ -236,7 +291,7 @@ namespace
                 {
                     const auto * it = table.find(bit_cast<UInt64>(pod[i]));
                     if (it)
-                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                        column_result.insertFrom(*cache.to_column, it->getMapped());
                     else if (cache.default_column)
                         column_result.insertFrom(*cache.default_column, 0);
                     else if (default_non_const)
@@ -259,14 +314,14 @@ namespace
             out_offs.resize(size);
             auto & out_chars = out->getChars();
 
-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());
             const auto & to_chars = to_col->getChars();
             const auto & to_offs = to_col->getOffsets();
             const auto & table = *cache.table_num_to_idx;
 
             if (cache.default_column)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 const auto * def_data = def_chars.data();
@@ -275,7 +330,7 @@ namespace
             }
             else
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
@@ -340,16 +395,16 @@ namespace
             if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)
                 out_scale = out->getScale();
 
-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();
             const auto & table = *cache.table_num_to_idx;
             if (cache.default_column)
             {
-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];
                 executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);
             }
             else if (default_non_const)
             {
-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();
                 executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);
             }
             else
@@ -423,11 +478,11 @@ namespace
                 ColumnString::Offset current_offset = 0;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                     current_offset = offsets[i];
                     const auto * it = table.find(ref);
                     if (it)
-                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                        column_result.insertFrom(*cache.to_column, it->getMapped());
                     else if (cache.default_column)
                         column_result.insertFrom(*cache.default_column, 0);
                     else if (default_non_const)
@@ -453,14 +508,14 @@ namespace
             out_offs.resize(size);
             auto & out_chars = out->getChars();
 
-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());
             const auto & to_chars = to_col->getChars();
             const auto & to_offs = to_col->getOffsets();
 
             const auto & table = *cache.table_string_to_idx;
             if (cache.default_column)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 const auto * def_data = def_chars.data();
@@ -469,7 +524,7 @@ namespace
             }
             else if (default_non_const)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
@@ -500,7 +555,7 @@ namespace
             {
                 const char8_t * to = nullptr;
                 size_t to_size = 0;
-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                 current_offset = offsets[i];
                 const auto * it = table.find(ref);
                 if (it)
@@ -542,16 +597,16 @@ namespace
             const size_t size = offsets.size();
             out_pod.resize(size);
 
-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();
             const auto & table = *cache.table_string_to_idx;
             if (cache.default_column)
             {
-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];
                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);
             }
             else
             {
-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();
                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);
             }
             return true;
@@ -570,7 +625,7 @@ namespace
             ColumnString::Offset current_offset = 0;
             for (size_t i = 0; i < size; ++i)
             {
-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                 current_offset = offsets[i];
                 const auto * it = table.find(ref);
                 if (it)
@@ -593,14 +648,17 @@ namespace
         {
             using NumToIdx = HashMap<UInt64, size_t, HashCRC32<UInt64>>;
             using StringToIdx = HashMap<StringRef, size_t, StringRefHash>;
+            using AnythingToIdx = HashMap<UInt128, size_t>;
 
             std::unique_ptr<NumToIdx> table_num_to_idx;
             std::unique_ptr<StringToIdx> table_string_to_idx;
+            std::unique_ptr<AnythingToIdx> table_anything_to_idx;
 
-            ColumnPtr to_columns;
-            ColumnPtr default_column;
+            bool is_empty = false;
 
-            Arena string_pool;
+            ColumnPtr from_column;
+            ColumnPtr to_column;
+            ColumnPtr default_column;
 
             std::atomic<bool> initialized{false};
             std::mutex mutex;
@@ -609,27 +667,6 @@ namespace
         mutable Cache cache;
 
 
-        static UInt64 bitCastToUInt64(const Field & x)
-        {
-            switch (x.getType())
-            {
-                case Field::Types::UInt64:
-                    return x.get<UInt64>();
-                case Field::Types::Int64:
-                    return x.get<Int64>();
-                case Field::Types::Float64:
-                    return std::bit_cast<UInt64>(x.get<Float64>());
-                case Field::Types::Bool:
-                    return x.get<bool>();
-                case Field::Types::Decimal32:
-                    return x.get<DecimalField<Decimal32>>().getValue();
-                case Field::Types::Decimal64:
-                    return x.get<DecimalField<Decimal64>>().getValue();
-                default:
-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected type in function 'transform'");
-            }
-        }
-
         static void checkAllowedType(const DataTypePtr & type)
         {
             if (type->isNullable())
@@ -656,33 +693,56 @@ namespace
         /// Can be called from different threads. It works only on the first call.
         void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const
         {
-            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());
-            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());
+            if (cache.initialized)
+                return;
+
+            const DataTypePtr & from_type = arguments[0].type;
+
+            if (from_type->onlyNull())
+            {
+                cache.is_empty = true;
+                return;
+            }
+
+            const ColumnArray * array_from = checkAndGetColumnConstData<ColumnArray>(arguments[1].column.get());
+            const ColumnArray * array_to = checkAndGetColumnConstData<ColumnArray>(arguments[2].column.get());
 
             if (!array_from || !array_to)
                 throw Exception(
                     ErrorCodes::ILLEGAL_COLUMN, "Second and third arguments of function {} must be constant arrays.", getName());
 
-            if (cache.initialized)
-                return;
+            std::lock_guard lock(cache.mutex);
 
-            const auto & from = array_from->getValue<Array>();
-            const size_t size = from.size();
-            if (0 == size)
-                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty arrays are illegal in function {}", getName());
+            const ColumnPtr & from_column_uncasted = array_from->getDataPtr();
 
-            std::lock_guard lock(cache.mutex);
+            cache.from_column = castColumn(
+                {
+                    from_column_uncasted,
+                    typeid_cast<const DataTypeArray &>(*arguments[1].type).getNestedType(),
+                    arguments[1].name
+                },
+                from_type);
 
-            if (cache.initialized)
+            cache.to_column = castColumn(
+                {
+                    array_to->getDataPtr(),
+                    typeid_cast<const DataTypeArray &>(*arguments[2].type).getNestedType(),
+                    arguments[2].name
+                },
+                result_type);
+
+            const size_t size = cache.from_column->size();
+            if (0 == size)
+            {
+                cache.is_empty = true;
                 return;
+            }
 
-            const auto & to = array_to->getValue<Array>();
-            if (size != to.size())
+            if (cache.to_column->size() != size)
                 throw Exception(
                     ErrorCodes::BAD_ARGUMENTS, "Second and third arguments of function {} must be arrays of same size", getName());
 
             /// Whether the default value is set.
-
             if (arguments.size() == 4)
             {
                 const IColumn * default_col = arguments[3].column.get();
@@ -702,45 +762,54 @@ namespace
 
             /// Note: Doesn't check the duplicates in the `from` array.
 
-            const IDataType & from_type = *arguments[0].type;
-
-            if (from[0].getType() != Field::Types::String)
+            WhichDataType which(from_type);
+            if (isNativeNumber(which) || which.isDecimal32() || which.isDecimal64())
             {
                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();
                 auto & table = *cache.table_num_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    Field key = convertFieldToType(from[i], from_type);
-                    if (key.isNull())
-                        continue;
-
-                    /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
-                    table[bitCastToUInt64(key)] = i;
+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))
+                    {
+                        /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
+                        StringRef ref = cache.from_column->getDataAt(i);
+                        UInt64 key = 0;
+                        memcpy(&key, ref.data, ref.size);
+                        table[key] = i;
+                    }
                 }
             }
-            else
+            else if (from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
             {
                 cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();
                 auto & table = *cache.table_string_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    const String & str_from = from[i].get<const String &>();
-                    StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};
-                    table[ref] = i;
+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))
+                    {
+                        StringRef ref = cache.from_column->getDataAt(i);
+                        table[ref] = i;
+                    }
                 }
             }
-
-            auto to_columns = result_type->createColumn();
-            for (size_t i = 0; i < size; ++i)
+            else
             {
-                Field to_value = convertFieldToType(to[i], *result_type);
-                to_columns->insert(to_value);
+                cache.table_anything_to_idx = std::make_unique<Cache::AnythingToIdx>();
+                auto & table = *cache.table_anything_to_idx;
+                for (size_t i = 0; i < size; ++i)
+                {
+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))
+                    {
+                        SipHash hash;
+                        cache.from_column->updateHashWithValue(i, hash);
+                        table[hash.get128()] = i;
+                    }
+                }
             }
-            cache.to_columns = std::move(to_columns);
 
             cache.initialized = true;
         }
-};
+    };
 
 }
 
