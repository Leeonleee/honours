{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51351,
  "instance_id": "ClickHouse__ClickHouse-51351",
  "issue_numbers": [
    "31336",
    "50827",
    "32387",
    "40493",
    "29730"
  ],
  "base_commit": "50f0cd48c6c07aa0bbc0134e116c2dc2baf3b9ef",
  "patch": "diff --git a/base/base/bit_cast.h b/base/base/bit_cast.h\nindex 5373ead36e80..4783a84586b0 100644\n--- a/base/base/bit_cast.h\n+++ b/base/base/bit_cast.h\n@@ -7,7 +7,13 @@\n \n /** Returns value `from` converted to type `To` while retaining bit representation.\n   * `To` and `From` must satisfy `CopyConstructible`.\n+  *\n   * In contrast to std::bit_cast can cast types of different width.\n+  *\n+  * Note: for signed types of narrower size, the casted result is zero-extended\n+  * instead of sign-extended as with regular static_cast.\n+  * For example, -1 Int8 (represented as 0xFF) bit_casted to UInt64\n+  * gives 255 (represented as 0x00000000000000FF) instead of 0xFFFFFFFFFFFFFFFF\n   */\n template <typename To, typename From>\n std::decay_t<To> bit_cast(const From & from)\ndiff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp\nindex 9970012ef4a7..8d6e53c491e4 100644\n--- a/src/Functions/transform.cpp\n+++ b/src/Functions/transform.cpp\n@@ -5,6 +5,7 @@\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnNullable.h>\n #include <Core/DecimalFunctions.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/getLeastSupertype.h>\n@@ -13,9 +14,10 @@\n #include <Functions/IFunction.h>\n #include <Interpreters/castColumn.h>\n #include <Interpreters/convertFieldToType.h>\n-#include <Common/Arena.h>\n #include <Common/HashTable/HashMap.h>\n #include <Common/typeid_cast.h>\n+#include <Common/FieldVisitorsAccurateComparison.h>\n+\n \n namespace DB\n {\n@@ -25,32 +27,31 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int LOGICAL_ERROR;\n }\n \n namespace\n {\n-    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.\n-  */\n     /** transform(x, [from...], [to...], default)\n-  * - converts the values according to the explicitly specified mapping.\n-  *\n-  * x - what to transform.\n-  * from - a constant array of values for the transformation.\n-  * to - a constant array of values into which values from `from` must be transformed.\n-  * default - what value to use if x is not equal to any of the values in `from`.\n-  * `from` and `to` - arrays of the same size.\n-  *\n-  * Types:\n-  * transform(T, Array(T), Array(U), U) -> U\n-  *\n-  * transform(x, [from...], [to...])\n-  * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.\n-  *\n-  * Types:\n-  * transform(T, Array(T), Array(T)) -> T\n-  *\n-  * Note: the implementation is rather cumbersome.\n-  */\n+      * - converts the values according to the explicitly specified mapping.\n+      *\n+      * x - what to transform.\n+      * from - a constant array of values for the transformation.\n+      * to - a constant array of values into which values from `from` must be transformed.\n+      * default - what value to use if x is not equal to any of the values in `from`.\n+      * `from` and `to` - arrays of the same size.\n+      *\n+      * Types:\n+      * transform(T, Array(T), Array(U), U) -> U\n+      *\n+      * transform(x, [from...], [to...])\n+      * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.\n+      *\n+      * Types:\n+      * transform(T, Array(T), Array(T)) -> T\n+      *\n+      * Note: the implementation is rather cumbersome.\n+      */\n     class FunctionTransform : public IFunction\n     {\n     public:\n@@ -79,15 +80,6 @@ namespace\n                     args_size);\n \n             const DataTypePtr & type_x = arguments[0];\n-            const auto & type_x_nn = removeNullable(type_x);\n-\n-            if (!type_x_nn->isValueRepresentedByNumber() && !isString(type_x_nn) && !isNothing(type_x_nn))\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Unsupported type {} of first argument \"\n-                    \"of function {}, must be numeric type or Date/DateTime or String\",\n-                    type_x->getName(),\n-                    getName());\n \n             const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n \n@@ -99,14 +91,16 @@ namespace\n \n             const auto type_arr_from_nested = type_arr_from->getNestedType();\n \n-            if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())\n-                || (isString(type_x) != isString(type_arr_from_nested)))\n+            auto src = tryGetLeastSupertype(DataTypes{type_x, type_arr_from_nested});\n+            if (!src\n+                /// Compatibility with previous versions, that allowed even UInt64 with Int64,\n+                /// regardless of ambiguous conversions.\n+                && !isNativeNumber(type_x) && !isNativeNumber(type_arr_from_nested))\n             {\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"First argument and elements of array \"\n-                    \"of second argument of function {} must have compatible types: \"\n-                    \"both numeric or both strings.\",\n+                    \"of the second argument of function {} must have compatible types\",\n                     getName());\n             }\n \n@@ -157,8 +151,8 @@ namespace\n             }\n         }\n \n-        ColumnPtr\n-        executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+        ColumnPtr executeImpl(\n+            const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n         {\n             initialize(arguments, result_type);\n \n@@ -172,22 +166,42 @@ namespace\n                 default_non_const = castColumn(arguments[3], result_type);\n \n             auto column_result = result_type->createColumn();\n-            if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)\n-                && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const)\n-                && !executeString(in, *column_result, default_non_const))\n+            if (cache.is_empty)\n             {\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n+                return default_non_const\n+                    ? default_non_const\n+                    : castColumn(arguments[0], result_type);\n             }\n+            else if (cache.table_num_to_idx)\n+            {\n+                if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)\n+                    && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const))\n+                {\n+                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n+                }\n+            }\n+            else if (cache.table_string_to_idx)\n+            {\n+                if (!executeString(in, *column_result, default_non_const))\n+                    executeContiguous(in, *column_result, default_non_const);\n+            }\n+            else if (cache.table_anything_to_idx)\n+            {\n+                executeAnything(in, *column_result, default_non_const);\n+            }\n+            else\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"State of the function `transform` is not initialized\");\n+\n             return column_result;\n         }\n \n@@ -204,6 +218,47 @@ namespace\n             return impl->execute(args, result_type, input_rows_count);\n         }\n \n+        void executeAnything(const IColumn * in, IColumn & column_result, const ColumnPtr default_non_const) const\n+        {\n+            const size_t size = in->size();\n+            const auto & table = *cache.table_anything_to_idx;\n+            column_result.reserve(size);\n+            for (size_t i = 0; i < size; ++i)\n+            {\n+                SipHash hash;\n+                in->updateHashWithValue(i, hash);\n+\n+                const auto * it = table.find(hash.get128());\n+                if (it)\n+                    column_result.insertFrom(*cache.to_column, it->getMapped());\n+                else if (cache.default_column)\n+                    column_result.insertFrom(*cache.default_column, 0);\n+                else if (default_non_const)\n+                    column_result.insertFrom(*default_non_const, i);\n+                else\n+                    column_result.insertFrom(*in, i);\n+            }\n+        }\n+\n+        void executeContiguous(const IColumn * in, IColumn & column_result, const ColumnPtr default_non_const) const\n+        {\n+            const size_t size = in->size();\n+            const auto & table = *cache.table_string_to_idx;\n+            column_result.reserve(size);\n+            for (size_t i = 0; i < size; ++i)\n+            {\n+                const auto * it = table.find(in->getDataAt(i));\n+                if (it)\n+                    column_result.insertFrom(*cache.to_column, it->getMapped());\n+                else if (cache.default_column)\n+                    column_result.insertFrom(*cache.default_column, 0);\n+                else if (default_non_const)\n+                    column_result.insertFrom(*default_non_const, i);\n+                else\n+                    column_result.insertFrom(*in, i);\n+            }\n+        }\n+\n         template <typename T>\n         bool executeNum(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const\n         {\n@@ -236,7 +291,7 @@ namespace\n                 {\n                     const auto * it = table.find(bit_cast<UInt64>(pod[i]));\n                     if (it)\n-                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                        column_result.insertFrom(*cache.to_column, it->getMapped());\n                     else if (cache.default_column)\n                         column_result.insertFrom(*cache.default_column, 0);\n                     else if (default_non_const)\n@@ -259,14 +314,14 @@ namespace\n             out_offs.resize(size);\n             auto & out_chars = out->getChars();\n \n-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());\n             const auto & to_chars = to_col->getChars();\n             const auto & to_offs = to_col->getOffsets();\n             const auto & table = *cache.table_num_to_idx;\n \n             if (cache.default_column)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 const auto * def_data = def_chars.data();\n@@ -275,7 +330,7 @@ namespace\n             }\n             else\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n@@ -340,16 +395,16 @@ namespace\n             if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)\n                 out_scale = out->getScale();\n \n-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();\n             const auto & table = *cache.table_num_to_idx;\n             if (cache.default_column)\n             {\n-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];\n                 executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);\n             }\n             else if (default_non_const)\n             {\n-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();\n                 executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);\n             }\n             else\n@@ -423,11 +478,11 @@ namespace\n                 ColumnString::Offset current_offset = 0;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                     current_offset = offsets[i];\n                     const auto * it = table.find(ref);\n                     if (it)\n-                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                        column_result.insertFrom(*cache.to_column, it->getMapped());\n                     else if (cache.default_column)\n                         column_result.insertFrom(*cache.default_column, 0);\n                     else if (default_non_const)\n@@ -453,14 +508,14 @@ namespace\n             out_offs.resize(size);\n             auto & out_chars = out->getChars();\n \n-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());\n             const auto & to_chars = to_col->getChars();\n             const auto & to_offs = to_col->getOffsets();\n \n             const auto & table = *cache.table_string_to_idx;\n             if (cache.default_column)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 const auto * def_data = def_chars.data();\n@@ -469,7 +524,7 @@ namespace\n             }\n             else if (default_non_const)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n@@ -500,7 +555,7 @@ namespace\n             {\n                 const char8_t * to = nullptr;\n                 size_t to_size = 0;\n-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                 current_offset = offsets[i];\n                 const auto * it = table.find(ref);\n                 if (it)\n@@ -542,16 +597,16 @@ namespace\n             const size_t size = offsets.size();\n             out_pod.resize(size);\n \n-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();\n             const auto & table = *cache.table_string_to_idx;\n             if (cache.default_column)\n             {\n-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];\n                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);\n             }\n             else\n             {\n-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();\n                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);\n             }\n             return true;\n@@ -570,7 +625,7 @@ namespace\n             ColumnString::Offset current_offset = 0;\n             for (size_t i = 0; i < size; ++i)\n             {\n-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                 current_offset = offsets[i];\n                 const auto * it = table.find(ref);\n                 if (it)\n@@ -593,14 +648,17 @@ namespace\n         {\n             using NumToIdx = HashMap<UInt64, size_t, HashCRC32<UInt64>>;\n             using StringToIdx = HashMap<StringRef, size_t, StringRefHash>;\n+            using AnythingToIdx = HashMap<UInt128, size_t>;\n \n             std::unique_ptr<NumToIdx> table_num_to_idx;\n             std::unique_ptr<StringToIdx> table_string_to_idx;\n+            std::unique_ptr<AnythingToIdx> table_anything_to_idx;\n \n-            ColumnPtr to_columns;\n-            ColumnPtr default_column;\n+            bool is_empty = false;\n \n-            Arena string_pool;\n+            ColumnPtr from_column;\n+            ColumnPtr to_column;\n+            ColumnPtr default_column;\n \n             std::atomic<bool> initialized{false};\n             std::mutex mutex;\n@@ -609,27 +667,6 @@ namespace\n         mutable Cache cache;\n \n \n-        static UInt64 bitCastToUInt64(const Field & x)\n-        {\n-            switch (x.getType())\n-            {\n-                case Field::Types::UInt64:\n-                    return x.get<UInt64>();\n-                case Field::Types::Int64:\n-                    return x.get<Int64>();\n-                case Field::Types::Float64:\n-                    return std::bit_cast<UInt64>(x.get<Float64>());\n-                case Field::Types::Bool:\n-                    return x.get<bool>();\n-                case Field::Types::Decimal32:\n-                    return x.get<DecimalField<Decimal32>>().getValue();\n-                case Field::Types::Decimal64:\n-                    return x.get<DecimalField<Decimal64>>().getValue();\n-                default:\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected type in function 'transform'\");\n-            }\n-        }\n-\n         static void checkAllowedType(const DataTypePtr & type)\n         {\n             if (type->isNullable())\n@@ -656,33 +693,56 @@ namespace\n         /// Can be called from different threads. It works only on the first call.\n         void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n         {\n-            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());\n-            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());\n+            if (cache.initialized)\n+                return;\n+\n+            const DataTypePtr & from_type = arguments[0].type;\n+\n+            if (from_type->onlyNull())\n+            {\n+                cache.is_empty = true;\n+                return;\n+            }\n+\n+            const ColumnArray * array_from = checkAndGetColumnConstData<ColumnArray>(arguments[1].column.get());\n+            const ColumnArray * array_to = checkAndGetColumnConstData<ColumnArray>(arguments[2].column.get());\n \n             if (!array_from || !array_to)\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_COLUMN, \"Second and third arguments of function {} must be constant arrays.\", getName());\n \n-            if (cache.initialized)\n-                return;\n+            std::lock_guard lock(cache.mutex);\n \n-            const auto & from = array_from->getValue<Array>();\n-            const size_t size = from.size();\n-            if (0 == size)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty arrays are illegal in function {}\", getName());\n+            const ColumnPtr & from_column_uncasted = array_from->getDataPtr();\n \n-            std::lock_guard lock(cache.mutex);\n+            cache.from_column = castColumn(\n+                {\n+                    from_column_uncasted,\n+                    typeid_cast<const DataTypeArray &>(*arguments[1].type).getNestedType(),\n+                    arguments[1].name\n+                },\n+                from_type);\n \n-            if (cache.initialized)\n+            cache.to_column = castColumn(\n+                {\n+                    array_to->getDataPtr(),\n+                    typeid_cast<const DataTypeArray &>(*arguments[2].type).getNestedType(),\n+                    arguments[2].name\n+                },\n+                result_type);\n+\n+            const size_t size = cache.from_column->size();\n+            if (0 == size)\n+            {\n+                cache.is_empty = true;\n                 return;\n+            }\n \n-            const auto & to = array_to->getValue<Array>();\n-            if (size != to.size())\n+            if (cache.to_column->size() != size)\n                 throw Exception(\n                     ErrorCodes::BAD_ARGUMENTS, \"Second and third arguments of function {} must be arrays of same size\", getName());\n \n             /// Whether the default value is set.\n-\n             if (arguments.size() == 4)\n             {\n                 const IColumn * default_col = arguments[3].column.get();\n@@ -702,45 +762,54 @@ namespace\n \n             /// Note: Doesn't check the duplicates in the `from` array.\n \n-            const IDataType & from_type = *arguments[0].type;\n-\n-            if (from[0].getType() != Field::Types::String)\n+            WhichDataType which(from_type);\n+            if (isNativeNumber(which) || which.isDecimal32() || which.isDecimal64())\n             {\n                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();\n                 auto & table = *cache.table_num_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    Field key = convertFieldToType(from[i], from_type);\n-                    if (key.isNull())\n-                        continue;\n-\n-                    /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n-                    table[bitCastToUInt64(key)] = i;\n+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))\n+                    {\n+                        /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n+                        StringRef ref = cache.from_column->getDataAt(i);\n+                        UInt64 key = 0;\n+                        memcpy(&key, ref.data, ref.size);\n+                        table[key] = i;\n+                    }\n                 }\n             }\n-            else\n+            else if (from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n             {\n                 cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();\n                 auto & table = *cache.table_string_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    const String & str_from = from[i].get<const String &>();\n-                    StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};\n-                    table[ref] = i;\n+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))\n+                    {\n+                        StringRef ref = cache.from_column->getDataAt(i);\n+                        table[ref] = i;\n+                    }\n                 }\n             }\n-\n-            auto to_columns = result_type->createColumn();\n-            for (size_t i = 0; i < size; ++i)\n+            else\n             {\n-                Field to_value = convertFieldToType(to[i], *result_type);\n-                to_columns->insert(to_value);\n+                cache.table_anything_to_idx = std::make_unique<Cache::AnythingToIdx>();\n+                auto & table = *cache.table_anything_to_idx;\n+                for (size_t i = 0; i < size; ++i)\n+                {\n+                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))\n+                    {\n+                        SipHash hash;\n+                        cache.from_column->updateHashWithValue(i, hash);\n+                        table[hash.get128()] = i;\n+                    }\n+                }\n             }\n-            cache.to_columns = std::move(to_columns);\n \n             cache.initialized = true;\n         }\n-};\n+    };\n \n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00809_add_days_segfault.sql b/tests/queries/0_stateless/00809_add_days_segfault.sql\nindex 6791439708ab..d2d91dd2711b 100644\n--- a/tests/queries/0_stateless/00809_add_days_segfault.sql\n+++ b/tests/queries/0_stateless/00809_add_days_segfault.sql\n@@ -9,4 +9,4 @@ SET send_logs_level = 'fatal';\n SELECT ignore(addDays((CAST((96.338) AS DateTime)), -3));\n SELECT ignore(subtractDays((CAST((-5263074.47) AS DateTime)), -737895));\n SELECT quantileDeterministic([], identity(( SELECT subtractDays((CAST((566450.398706) AS DateTime)), 54) ) )), '\\0', []; -- { serverError 43 }\n-SELECT sequenceCount((CAST((( SELECT NULL ) AS rg, ( SELECT ( SELECT [], '<e', caseWithExpr([NULL], -588755.149, []), retention(addWeeks((CAST((-7644612.39732) AS DateTime)), -23578040.02833), (CAST(([]) AS DateTime)), (CAST(([010977.08]) AS String))), emptyArrayToSingle('') ) , '\\0', toUInt64([], 't3hw@'), '\\0', toStartOfQuarter(-4230.1872, []) ) ) AS Date))); -- { serverError 43 }\n+SELECT sequenceCount((CAST((( SELECT NULL ) AS rg, ( SELECT ( SELECT [], '<e', caseWithExpr([NULL], -588755.149, []), retention(addWeeks((CAST((-7644612.39732) AS DateTime)), -23578040.02833), (CAST(([]) AS DateTime)), (CAST(([010977.08]) AS String))), emptyArrayToSingle('') ) , '\\0', toUInt64([], 't3hw@'), '\\0', toStartOfQuarter(-4230.1872, []) ) ) AS Date))); -- { serverError 43, 36 }\ndiff --git a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\nindex a1a653361ee2..88f23334d316 100644\n--- a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\n+++ b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\n@@ -405,6 +405,16 @@ QUERY id: 0\n     TABLE id: 7, table_name: system.numbers\n   LIMIT\n     CONSTANT id: 17, constant_value: UInt64_10, constant_value_type: UInt64\n+other\n+other\n+other\n+other\n+other\n+other\n+other\n+other\n+other\n+other\n SELECT transform(number, [NULL], _CAST([\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'Array(Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4))\\'), _CAST(\\'other\\', \\'Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4)\\'))\n FROM\n (\ndiff --git a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\nindex 492d42cb6bc2..c3db61d1fb27 100644\n--- a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\n+++ b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\n@@ -33,7 +33,7 @@ SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other')\n EXPLAIN SYNTAX SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other') as value, value FROM system.numbers LIMIT 10;\n EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other') as value, value FROM system.numbers LIMIT 10;\n \n-SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10); -- { serverError 36 }\n+SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n EXPLAIN SYNTAX SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n \ndiff --git a/tests/queries/0_stateless/02797_transform_narrow_types.reference b/tests/queries/0_stateless/02797_transform_narrow_types.reference\nnew file mode 100644\nindex 000000000000..5a2bd60ca833\n--- /dev/null\n+++ b/tests/queries/0_stateless/02797_transform_narrow_types.reference\n@@ -0,0 +1,6 @@\n+f\n+s\n+11\n+11\n+33\n+3\ndiff --git a/tests/queries/0_stateless/02797_transform_narrow_types.sql b/tests/queries/0_stateless/02797_transform_narrow_types.sql\nnew file mode 100644\nindex 000000000000..56a02fb8af7a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02797_transform_narrow_types.sql\n@@ -0,0 +1,6 @@\n+SELECT transform(-1, [-1, 2], ['f', 's'], 'g');\n+SELECT transform(2, [-1, 2], ['f', 's'], 'g');\n+SELECT transform(-1, [-1, 2], [11, 22], 33);\n+SELECT transform(-1, [-1, 2], [11, 22]);\n+SELECT transform(3, [-1, 2], [11, 22], 33);\n+SELECT transform(3, [-1, 2], [11, 22]);\ndiff --git a/tests/queries/0_stateless/02798_generic_transform.reference b/tests/queries/0_stateless/02798_generic_transform.reference\nnew file mode 100644\nindex 000000000000..2140c3218b37\n--- /dev/null\n+++ b/tests/queries/0_stateless/02798_generic_transform.reference\n@@ -0,0 +1,38 @@\n+def\n+def\n+def\n+hello\n+def\n+world\n+def\n+abc!\n+def\n+def\n+\n+\n+\n+hello\n+\n+world\n+\n+abc\n+\n+\n+\n+\n+\n+hello\n+\n+world\n+\n+abc\n+\n+\n+123\n+2023-03-03 00:00:00.000\n+2023-02-02 00:00:00.000\n+2023-01-01 00:00:00.000\n+1\t1\n+42\t42\n+42\n+42\ndiff --git a/tests/queries/0_stateless/02798_generic_transform.sql b/tests/queries/0_stateless/02798_generic_transform.sql\nnew file mode 100644\nindex 000000000000..6317d83fb297\n--- /dev/null\n+++ b/tests/queries/0_stateless/02798_generic_transform.sql\n@@ -0,0 +1,12 @@\n+SELECT transform((number, toString(number)), [(3, '3'), (5, '5'), (7, '7')], ['hello', 'world', 'abc!'], 'def') FROM system.numbers LIMIT 10;\n+SELECT transform(toNullable(toInt256(number)), [3, 5, 7], ['hello', 'world', 'abc'], '') FROM system.numbers LIMIT 10;\n+SELECT transform(toUInt256(number), [3, 5, 7], ['hello', 'world', 'abc'], '') FROM system.numbers LIMIT 10;\n+\n+select case 1::Nullable(Int32) when 1 then 123 else 0 end;\n+\n+SELECT transform(arrayJoin(['c', 'b', 'a']), ['a', 'b'], [toDateTime64('2023-01-01', 3), toDateTime64('2023-02-02', 3)], toDateTime64('2023-03-03', 3));\n+\n+SELECT transform(1, [1], [toDecimal32(1, 2)]), toDecimal32(1, 2);\n+select transform(1, [1], [toDecimal32(42, 2)]), toDecimal32(42, 2);\n+SELECT transform(1, [1], [toDecimal32(42, 2)], 0);\n+SELECT transform(1, [1], [toDecimal32(42, 2)], toDecimal32(0, 2));\ndiff --git a/tests/queries/0_stateless/02799_transform_empty_arrays.reference b/tests/queries/0_stateless/02799_transform_empty_arrays.reference\nnew file mode 100644\nindex 000000000000..fd44083947ed\n--- /dev/null\n+++ b/tests/queries/0_stateless/02799_transform_empty_arrays.reference\n@@ -0,0 +1,30 @@\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello\n+Hello 0\n+Hello 1\n+Hello 2\n+Hello 3\n+Hello 4\n+Hello 5\n+Hello 6\n+Hello 7\n+Hello 8\n+Hello 9\ndiff --git a/tests/queries/0_stateless/02799_transform_empty_arrays.sql b/tests/queries/0_stateless/02799_transform_empty_arrays.sql\nnew file mode 100644\nindex 000000000000..84e3e9d29306\n--- /dev/null\n+++ b/tests/queries/0_stateless/02799_transform_empty_arrays.sql\n@@ -0,0 +1,3 @@\n+SELECT transform(number, [], [1]) FROM numbers(10);\n+SELECT transform(number, [], [], 'Hello') FROM numbers(10);\n+SELECT transform(number, [], [], 'Hello ' || number::String) FROM numbers(10);\ndiff --git a/tests/queries/0_stateless/02800_transform_alter.reference b/tests/queries/0_stateless/02800_transform_alter.reference\nnew file mode 100644\nindex 000000000000..cae8aeba20f8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02800_transform_alter.reference\n@@ -0,0 +1,6 @@\n+1\ta1\ta1\n+2\ta2\tb2\n+3\ta3\tb3\n+1\ta1\n+2\tb2\n+3\tb3\ndiff --git a/tests/queries/0_stateless/02800_transform_alter.sql b/tests/queries/0_stateless/02800_transform_alter.sql\nnew file mode 100644\nindex 000000000000..7458f51c5a40\n--- /dev/null\n+++ b/tests/queries/0_stateless/02800_transform_alter.sql\n@@ -0,0 +1,43 @@\n+DROP TABLE IF EXISTS test_xy;\n+DROP TABLE IF EXISTS updates;\n+\n+CREATE TABLE test_xy\n+(\n+    `x` Int32,\n+    `y` String\n+)\n+ENGINE = MergeTree\n+ORDER BY x;\n+\n+CREATE TABLE updates\n+(\n+    `x` Int32,\n+    `y` String\n+)\n+ENGINE = MergeTree\n+ORDER BY x;\n+\n+INSERT INTO test_xy(x, y) VALUES (1, 'a1'), (2, 'a2'), (3, 'a3');\n+INSERT INTO updates(x, y) VALUES  (2, 'b2'), (3, 'b3');\n+\n+SELECT x, y,\n+    transform(x,\n+        (select groupArray(x) from (select x, y from updates order by x) t1),\n+        (select groupArray(y) from (select x, y from updates order by x) t2),\n+        y)\n+FROM test_xy\n+WHERE 1 ORDER BY x, y;\n+\n+SET mutations_sync = 1;\n+ALTER table test_xy\n+    UPDATE\n+    y =  transform(x,\n+        (select groupArray(x) from (select x, y from updates order by x) t1),\n+        (select groupArray(y) from (select x, y from updates order by x) t2),\n+        y)\n+    WHERE 1;\n+\n+SELECT * FROM test_xy ORDER BY x, y;\n+\n+DROP TABLE test_xy;\n+DROP TABLE updates;\ndiff --git a/tests/queries/0_stateless/02801_transform_nullable.reference b/tests/queries/0_stateless/02801_transform_nullable.reference\nnew file mode 100644\nindex 000000000000..48d529e7d907\n--- /dev/null\n+++ b/tests/queries/0_stateless/02801_transform_nullable.reference\n@@ -0,0 +1,75 @@\n+1970-01-01 00:00:01.000\n+1970-01-01 00:00:02.000\n+1970-01-01 00:00:00.000\n+\\N\n+\\N\n+\\N\n+hello\n+\\N\n+world\n+\\N\n+abc\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+-1\n+-1\n+-1\n+111\n+-1\n+222\n+-1\n+\\N\n+-1\n+-1\n+-1.1\n+-1.1\n+-1.1\n+\\N\n+-1.1\n+222\n+-1.1\n+333\n+-1.1\n+-1.1\n+1\n+1\n+1\n+\\N\n+1\n+\\N\n+1\n+\\N\n+1\n+1\n+\u041e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435\n+\\N\n+-\n+xyz\n+Hello\n+-\n+xyz\n+World\n+-\n+xyz\n+-\n+-\ndiff --git a/tests/queries/0_stateless/02801_transform_nullable.sql b/tests/queries/0_stateless/02801_transform_nullable.sql\nnew file mode 100644\nindex 000000000000..95f3c16600a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02801_transform_nullable.sql\n@@ -0,0 +1,14 @@\n+select transform('a', ['a', 'b'], [toDateTime64(1, 3, 'UTC'), toDateTime64(2, 3, 'UTC')], toDateTime64(0, 3, 'UTC'));\n+select transform(2, [1, 2], [toDateTime64(1, 3, 'UTC'), toDateTime64(2, 3, 'UTC')], toDateTime64(0, 3, 'UTC'));\n+select transform(null, [1, 2], [toDateTime64(1, 3, 'UTC'), toDateTime64(2, 3, 'UTC')], toDateTime64(0, 3, 'UTC'));\n+\n+SELECT transform(number, [3, 5, 7], ['hello', 'world', 'abc'], null) FROM system.numbers LIMIT 10;\n+SELECT transform(null, ['3', '5', '7'], ['hello', 'world', 'abc'], null) FROM system.numbers LIMIT 10;\n+SELECT transform(null, [null, null, null], [null, null, null], null) FROM system.numbers LIMIT 10;\n+SELECT transform(toString(number), ['3', '5', '7'], [111, 222, null], -1) FROM system.numbers LIMIT 10;\n+SELECT transform(toString(number), ['3', '5', '7'], [null, 222, 333], materialize(-1.1)) FROM system.numbers LIMIT 10;\n+SELECT transform(toString(number), ['3', '5', '7'], [null, null, null], materialize(1)) FROM system.numbers LIMIT 10;\n+SELECT transform(1, [2, 3], ['Meta.ua', null], materialize('\u041e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435')) AS title;\n+SELECT transform(2, [2, 3], [null, 'Google'], materialize('\u041e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435')) AS title;\n+\n+SELECT transform(number % 3 = 1 ? NULL : number, [2, 5, NULL], ['Hello', 'World', 'xyz'], '-') FROM numbers(10);\n",
  "problem_statement": "ALTER TABLE UPDATE with transform and subquery produce 'Empty arrays are illegal in function transform'\nLooks as produced in recent version ClickHouse,\r\n\r\n```\r\nClickHouse client version 21.11.3.6 (official build).\r\nConnected to ClickHouse server version 21.11.3 revision 54450.\r\n```\r\n\r\nQueries:\r\n```\r\nDROP TABLE IF EXISTS test_xy;\r\nDROP TABLE IF EXISTS updates;\r\nCREATE TABLE test_xy\r\n(\r\n    `x` Int32,\r\n    `y` String\r\n)\r\nENGINE = MergeTree\r\nORDER BY x;\r\n\r\nCREATE TABLE updates\r\n(\r\n    `x` Int32,\r\n    `y` String\r\n)\r\nENGINE = MergeTree\r\nORDER BY x;\r\n\r\nINSERT INTO test_xy(x, y) VALUES (1, 'a1'), (2, 'a2'), (3, 'a3');\r\nINSERT INTO updates(x, y) VALUES  (2, 'b2'), (3, 'b3');\r\n\r\nSELECT x, y,\r\n    transform(x,\r\n        (select groupArray(x) from (select x, y from updates order by x) t1),\r\n        (select groupArray(y) from (select x, y from updates order by x) t2),\r\n        y)\r\nFROM test_xy\r\nWHERE 1;\r\n\r\nALTER table test_xy\r\n    UPDATE\r\n    y =  transform(x,\r\n        (select groupArray(x) from (select x, y from updates order by x) t1),\r\n        (select groupArray(y) from (select x, y from updates order by x) t2),\r\n        y)\r\n    WHERE 1;\r\n```\r\n\r\nResult:\r\n\r\n```\r\nReceived exception from server (version 21.11.3):\r\nCode: 36. DB::Exception: Received from 127.1:9000. DB::Exception: Empty arrays are illegal in function transform. (BAD_ARGUMENTS)\r\n(query: ALTER table test_xy\r\n    UPDATE \r\n    y =  transform(x,\r\n        (select groupArray(x) from (select x, y from updates order by x) t1),\r\n        (select groupArray(y) from (select x, y from updates order by x) t2),\r\n        y)\r\n    WHERE 1;)\r\n```\r\n\r\nUnexpected to see here error message.\r\n\r\nContext:\r\nOn older ClickHouse\r\n(Connected to ClickHouse server version 21.10.2 revision 54449)\r\n\r\nthis query simply hangs, maybe because some errors in configuration at /etc/clickhouse-server/users.d/default-password.xml ...\r\n\r\n```\r\n---  ClickHouse server version 21.10.2 revision 54449\r\n--- passed 10 minutes after query run\r\nselect is_done, table, count(), min(create_time), max(create_time), now() from system.mutations where 1 group by table, is_done;\r\n```\r\n```\r\n\u250c\u2500is_done\u2500\u252c\u2500table\u2500\u2500\u2500\u252c\u2500count()\u2500\u252c\u2500\u2500\u2500\u2500min(create_time)\u2500\u252c\u2500\u2500\u2500\u2500max(create_time)\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now()\u2500\u2510\r\n\u2502       0 \u2502 test_xy \u2502       1 \u2502 2021-11-12 13:37:32 \u2502 2021-11-12 13:37:32 \u2502 2021-11-12 13:47:44 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nCASE expression with nullable type doesn't work\n> You have to provide the following information whenever possible.\r\n\r\nThe following SQL fails:\r\n\r\n```\r\n:) select case 1::Nullable(Int32) when 1 then 1 else 0 end;\r\n```\r\n\r\nError:\r\n\r\n```\r\nReceived exception from server (version 23.5.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: First argument and elements of array of second argument of function transform must have compatible types: both numeric or both strings.: While processing caseWithExpression(CAST('1', 'Nullable(Int32)'), 1, 1, 0). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\n> A clear and concise description of what works not as it is supposed to.\r\n\r\nI would expect this to return `1`\r\n\r\n> A link to reproducer in [https://fiddle.clickhouse.com/](https://fiddle.clickhouse.com/).\r\n\r\nhttps://fiddle.clickhouse.com/2091d88d-162a-41a6-9e7c-a67091a4b3a7\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nIt does. Here's the information from `clickhouse client` startup:\r\n\r\n```\r\nClickHouse client version 23.3.2.1.\r\nConnecting to database ibis_testing at localhost:9000 as user default.\r\nConnected to ClickHouse server version 23.5.1 revision 54462.\r\n```\ntransform does not work with DateTime64\n```\r\nselect transform('a', ['a', 'b'], [toDateTime64(1,3), toDateTime64(2,3)], toDateTime64(0,3));\r\n\r\nReceived exception from server (version 21.11.5):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Illegal column String of elements of array of second argument of function transform: While processing transform('a', ['a', 'b'], [toDateTime64(1, 3), toDateTime64(2, 3)], toDateTime64(0, 3)). (ILLEGAL_COLUMN)\r\n```\r\n\r\n```\r\nselect transform('a', ['a', 'b'], [toDateTime(1), toDateTime(2)], toDateTime(0));\r\n\r\n\u250c\u2500transform('a', ['a', 'b'], array(toDateTime(1), toDateTime(2)), toDateTime(0))\u2500\u2510\r\n\u2502                                                            1970-01-01 00:00:01 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI expect it returns `toDateTime64(1,3)` like for DateTime but it fails.\r\n\r\nClickhouse version is 21.11.5.33.\r\n\nSupport NULL in function transform.\n<!---\r\nA technical comment, you are free to remove or leave it as it is when PR is created\r\nThe following categories are used in the next scripts, update them accordingly\r\nutils/changelog/changelog.py\r\ntests/ci/run_check.py\r\n-->\r\n### Changelog category (leave one):\r\n- Improvement\r\n\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nSupport NULL in function transform. This fixes https://github.com/ClickHouse/ClickHouse/issues/2655 , https://github.com/ClickHouse/ClickHouse/issues/9596 ,  https://github.com/ClickHouse/ClickHouse/issues/38666 \r\n\r\nThis helps evaluate TPC-DS query 39 correctly.\r\n\r\nThis PR also removes most boilerplate code introduced in https://github.com/ClickHouse/ClickHouse/pull/31839 .\r\n\r\n~Current implementation is not ideal w.r.t performance since nullable checks are added even in not null branches. It's to avoid code bloating.~\r\n\r\nThere is also a proposal to implement a general version of transform https://github.com/ClickHouse/ClickHouse/pull/37654 . However there isn't a clear evidence that it will outperform current implementation.\r\n\r\n> Information about CI checks: https://clickhouse.com/docs/en/development/continuous-integration/\r\n\nFunction transform with decimal type not working or produce incorrect result\nCurrent stable release and some recent release\r\nClickHouse client version 21.9.4.35\r\nConnected to ClickHouse server version 21.9.4 revision 54449\r\nConnected to ClickHouse server version 21.5.9 revision 54448\r\n\r\nSQL:\r\n```\r\nSELECT  transform(1, [1], [toDecimal32(1, 2)]),    toDecimal32(1, 2)\r\n```\r\nProduces:\r\n```\r\n100 \u2502                 1\r\n```\r\n\r\nExpected 1 == 1\r\n\r\n```\r\nselect transform(1, [1], [toDecimal32(42, 2)]), toDecimal32(42, 2);\r\n```\r\nProduces:\r\n```\r\n 104 \u2502                 42\r\n```\r\n\r\nExpected 42 == 42\r\n\r\nLooks as garbage ...\r\n\r\nSecond case of transform function\r\n```\r\nSELECT transform(1, [1], [toDecimal32(42, 2)], 0)\r\n\r\n-- OR --\r\n\r\nSELECT transform(1, [1], [toDecimal32(42, 2)], toDecimal32(0, 2))\r\n```\r\nProduce error message\r\n```\r\nReceived exception from server (version 21.9.4):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Illegal column UInt8 of elements of array of second argument of function transform: While processing transform(1, [1], [toDecimal32(42, 2)], 0). (ILLEGAL_COLUMN)\r\n```\r\n\n",
  "hints_text": "\nWill be addressed by this pull request: https://github.com/ClickHouse/ClickHouse/pull/40493\nIt worked in 23.4 https://fiddle.clickhouse.com/0fd07687-9dfa-4887-8cf7-efdd0056a502\nmaybe #48300 is related?\nNeed to support this type like in https://github.com/ClickHouse/ClickHouse/pull/31839\nAlso support DateTime64 in transform. This fixes https://github.com/ClickHouse/ClickHouse/issues/32387\nStress test (thread) \u2014 Sanitizer assert (in stderr.log)\r\n\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/40493/3a0096a384bc42bae2d423e60260cc267a4aa982/stress_test__thread_/stderr.log\r\n\r\n==672==WARNING: invalid path to external symbolizer!\r\n==672==WARNING: Failed to use and restart external symbolizer!\r\n\r\nIt's somehow related to MergeMutate.\r\n\r\n\r\nStress test (debug) \u2014 OOM killer (or signal 9) in clickhouse-server.log\r\n\r\nDoesn't seem related\r\n\n> Stress test (thread) \u2014 Sanitizer assert (in stderr.log)\r\n> \r\n> https://s3.amazonaws.com/clickhouse-test-reports/40493/3a0096a384bc42bae2d423e60260cc267a4aa982/stress_test__thread_/stderr.log\r\n> \r\n> ==672==WARNING: invalid path to external symbolizer! ==672==WARNING: Failed to use and restart external symbolizer!\r\n> \r\n> It's somehow related to MergeMutate.\r\n\r\nI guess, the main issue is \"WARNING: ThreadSanitizer: data race (pid=672)\"\nlooks like we have almost zero perf tests for `transform`. let's add some.\n> looks like we have almost zero perf tests for transform. let's add some.\r\n\r\nDone.\r\n\r\n> I guess, the main issue is \"WARNING: ThreadSanitizer: data race (pid=672)\"\r\n\r\nI don't know why llvm-symbolizer is broken and there is no evidence what's going wrong.\n> Performance Comparison [4/4] \u2014 2 errors, 2 faster, 12 slower, 3 unstable\r\n\r\nmost significant difference is : +1.301x\t. Maybe it worth adding nullable specializations (doubling the code size to avoid performance degradation for not-null cases)\n> I don't know why llvm-symbolizer is broken and there is no evidence what's going wrong.\r\n\r\nfix is on the way afaiu #40608\r\n\r\n> most significant difference is : +1.301x . Maybe it worth adding nullable specializations (doubling the code size to avoid performance degradation for not-null cases)\r\n\r\nwe need to fix only the hot loops. maybe it is possible to put null-related code under `if constexpr(nullable)`?\r\n\n> we need to fix only the hot loops. maybe it is possible to put null-related code under if constexpr(nullable)?\r\n\r\nThat's what I mean by \"double the code size\". The hot code is a bloated template. Adding if constexpr will make it generating x2 more code\n> > we need to fix only the hot loops. maybe it is possible to put null-related code under if constexpr(nullable)?\r\n> \r\n> That's what I mean by \"double the code size\". The hot code is a bloated template. Adding if constexpr will make it generating x2 more code\r\n\r\nI don't see a big issue here, since they will appear only in the single translation unit. for me the bigger concern is the source code complexity\n> Integration tests (asan) [1/3] \u2014 fail: 1, passed: 654, flaky: 0\r\n\r\n```\r\n=================================== FAILURES ===================================\r\n_____________________________ test_default_column ______________________________\r\n[gw4] linux -- Python 3.8.10 /usr/bin/python3\r\n\r\n    def test_default_column():\r\n        node1.query(\r\n            \"CREATE TABLE dist ON CLUSTER 'test_cluster' (x Int32, y Int32 DEFAULT x + 100, z Int32 DEFAULT x + y) ENGINE = Distributed('test_cluster', currentDatabase(), local, y)\"\r\n        )\r\n        node1.query(\r\n            \"CREATE TABLE local ON CLUSTER 'test_cluster' (x Int32, y Int32 DEFAULT x + 200, z Int32 DEFAULT x - y) ENGINE = MergeTree() ORDER BY y\"\r\n        )\r\n    \r\n        for insert_sync in [0, 1]:\r\n            settings = {\"insert_distributed_sync\": insert_sync}\r\n    \r\n            # INSERT INTO TABLE dist (x)\r\n            node1.query(\"TRUNCATE TABLE local ON CLUSTER 'test_cluster'\")\r\n            node1.query(\r\n                \"INSERT INTO TABLE dist (x) VALUES (1), (2), (3), (4)\", settings=settings\r\n            )\r\n            node1.query(\"SYSTEM FLUSH DISTRIBUTED dist\")\r\n            assert node1.query(\"SELECT x, y, z FROM local\") == TSV(\r\n                [[2, 102, 104], [4, 104, 108]]\r\n            )\r\n            assert node2.query(\"SELECT x, y, z FROM local\") == TSV(\r\n                [[1, 101, 102], [3, 103, 106]]\r\n            )\r\n>           assert node1.query(\"SELECT x, y, z FROM dist\") == TSV(\r\n                [[2, 102, 104], [4, 104, 108], [1, 101, 102], [3, 103, 106]]\r\n            )\r\nE           AssertionError: assert '1\\t101\\t102\\n3\\t103\\t106\\n2\\t102\\t104\\n4\\t104\\t108\\n' == 2\t102\t104\\n4\t104\t108\\n1\t101\t102\\n3\t103\t106\r\nE            +  where '1\\t101\\t102\\n3\\t103\\t106\\n2\\t102\\t104\\n4\\t104\\t108\\n' = <bound method ClickHouseInstance.query of <helpers.cluster.ClickHouseInstance object at 0x7f5e0067f040>>('SELECT x, y, z FROM dist')\r\nE            +    where <bound method ClickHouseInstance.query of <helpers.cluster.ClickHouseInstance object at 0x7f5e0067f040>> = <helpers.cluster.ClickHouseInstance object at 0x7f5e0067f040>.query\r\nE            +  and   2\t102\t104\\n4\t104\t108\\n1\t101\t102\\n3\t103\t106 = TSV([[2, 102, 104], [4, 104, 108], [1, 101, 102], [3, 103, 106]])\r\n```\r\n\r\nDoesn't seem related.\r\n\r\n> ClickHouse build check \u2014 19/21 artifact groups are OK\r\n\r\nDon't know what's going wrong.\r\n\r\n> Stress test (thread) \u2014 Sanitizer assert (in stderr.log)\r\n\r\nSame error as before.\r\n\r\n> Stateless tests (debug) [1/3] \u2014 Tests are not finished, fail: 1, passed: 22, skipped: 2\r\n\r\n```\r\n2022.08.26 00:38:48.424169 [ 632 ] {} <Trace> BaseDaemon: Received signal 15\r\n2022.08.26 00:38:48.424290 [ 632 ] {} <Information> Application: Received termination signal (Terminated)\r\n2022.08.26 00:38:48.424396 [ 629 ] {} <Debug> Application: Received termination signal.\r\n```\r\nDon't know why.\r\n\nhttps://s3.amazonaws.com/clickhouse-builds/40493/f0b72229cd2e658f3f9db98d1236fbe939873cfe/package_ubsan/build_log.log\r\n\r\nThis build error looks like an OOM issue.\n@nickitat Friendly ping.\nlet's fix the build and make sure there is no issues with correctness and perf\n> transform.query6.prewarm0: DB::Exception: First argument and elements of array of second argument of function transform must have compatible types: both numeric or both strings.: While processing transform(rand(10), [2, 4, NULL], [20, 40, 60]). Stack trace:\r\n\r\nIt's because without this PR the query won't work.\r\n\r\n> SELECT transform(rand(10), [2, 4, 6], [20, null, 60], null) FROM numbers(10000000) FORMAT Null\r\n\r\nIt's much slower because without this PR the query result is incorrect.\r\n\r\n> SELECT transform(rand(10), [2, 4, 6], [20, 40, 60]) FROM numbers(10000000) FORMAT Null\r\n\r\nIt's slightly slower and I think it's unrelated, because I did some local verification:\r\n\r\nBefore:\r\n\r\nlocalhost:7000, queries 1079, QPS: 12.609, RPS: 126184662.472, MiB/s: 962.713, result RPS: 0.000, result MiB/s: 0.000.\r\n\r\n0.000%          0.031 sec.\r\n10.000%         0.032 sec.\r\n20.000%         0.032 sec.\r\n30.000%         0.032 sec.\r\n40.000%         0.033 sec.\r\n50.000%         0.033 sec.\r\n60.000%         0.034 sec.\r\n70.000%         0.058 sec.\r\n80.000%         0.116 sec.\r\n90.000%         0.162 sec.\r\n95.000%         0.263 sec.\r\n99.000%         0.524 sec.\r\n99.900%         1.486 sec.\r\n99.990%         1.595 sec.\r\n\r\nAfter:\r\n\r\nlocalhost:7000, queries 1550, QPS: 15.328, RPS: 153392659.079, MiB/s: 1170.293, result RPS: 0.000, result MiB/s: 0.000.\r\n\r\n0.000%          0.031 sec.\r\n10.000%         0.031 sec.\r\n20.000%         0.031 sec.\r\n30.000%         0.032 sec.\r\n40.000%         0.032 sec.\r\n50.000%         0.032 sec.\r\n60.000%         0.033 sec.\r\n70.000%         0.047 sec.\r\n80.000%         0.089 sec.\r\n90.000%         0.145 sec.\r\n95.000%         0.203 sec.\r\n99.000%         0.365 sec.\r\n99.900%         0.463 sec.\r\n99.990%         0.522 sec.\r\n\nThe clang-15 ubsan build failed. I guess it's because the translation unit now becomes too large. Except that everything looks good. @nickitat Could you take another look? I don't know what's the proper way of resolving this build error and there is no error logs.\n> The clang-15 ubsan build failed. I guess it's because the translation unit now becomes too large. Except that everything looks good. @nickitat Could you take another look? I don't know what's the proper way of resolving this build error and there is no error logs.\r\n\r\nI'm also ok with this pr as soon as CI became happy. let's be optimistic and hope that retry of the ubsan build will succeed (let's just wait). \nunfortunately looks like that only complete rerun could help\n> unfortunately looks like that only complete rerun could help\r\n\r\nMaybe we can add some compiler flags for `transform.cpp`?\nyes, I think we could. but I would like to see the errors first. maybe you could try to build locally with ubsan and see what will happen?\n> maybe you could try to build locally with ubsan and see what will happen?\r\n\r\nWhen compiling this TU, clang++ exits without any log messages after running for 15 minutes. I guess there is nothing we can do.\nmaybe splitting into multiple cpp files will help. ideally would be to simplify the code somehow.\n@amosbird we still need it.\nI will try if clang 16 works\nI'm working to solve this problem\nOfficial website introduction:\r\nhttps://clickhouse.com/docs/en/sql-reference/functions/other-functions/#transformx-array-from-array-to\r\ntransform(T, Array(T), Array(T)) -> T\r\nbut \r\ntransform(1, [1], [toDecimal32(42, 2)] is same like transform(UInt8, UInt8, Decimal32) -> UInt8.\r\n\r\ntransform(T, Array(T), Array(U), U) -> U\r\nbut\r\nSELECT transform(1, [1], [toDecimal32(42, 2)], 0) => transform(UInt8, UInt8, Decimal32, UInt8) -> UInt8\r\n\r\nMaybe it should produce error message instead gaven a wrong answer\r\n\r\nso, could u tell me how to fix it\r\n\r\n@alexey-milovidov\r\n",
  "created_at": "2023-06-24T04:56:38Z"
}