diff --git a/dbms/src/Columns/getLeastSuperColumn.cpp b/dbms/src/Columns/getLeastSuperColumn.cpp
index 11c5b1b58fde..663337b6f879 100644
--- a/dbms/src/Columns/getLeastSuperColumn.cpp
+++ b/dbms/src/Columns/getLeastSuperColumn.cpp
@@ -18,7 +18,7 @@ static bool sameConstants(const IColumn & a, const IColumn & b)
     return assert_cast<const ColumnConst &>(a).getField() == assert_cast<const ColumnConst &>(b).getField();
 }
 
-ColumnWithTypeAndName getLeastSuperColumn(std::vector<const ColumnWithTypeAndName *> columns)
+ColumnWithTypeAndName getLeastSuperColumn(const std::vector<const ColumnWithTypeAndName *> & columns)
 {
     if (columns.empty())
         throw Exception("Logical error: no src columns for supercolumn", ErrorCodes::LOGICAL_ERROR);
diff --git a/dbms/src/Columns/getLeastSuperColumn.h b/dbms/src/Columns/getLeastSuperColumn.h
index d761de29a93e..cd8dc53a895b 100644
--- a/dbms/src/Columns/getLeastSuperColumn.h
+++ b/dbms/src/Columns/getLeastSuperColumn.h
@@ -7,6 +7,6 @@ namespace DB
 {
 
 /// getLeastSupertype + related column changes
-ColumnWithTypeAndName getLeastSuperColumn(std::vector<const ColumnWithTypeAndName *> columns);
+ColumnWithTypeAndName getLeastSuperColumn(const std::vector<const ColumnWithTypeAndName *> & columns);
 
 }
diff --git a/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
index a876633609a6..2d7fde72875e 100644
--- a/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
@@ -124,17 +124,17 @@ Block InterpreterSelectWithUnionQuery::getCommonHeaderForUnion(const Blocks & he
                             + "
and
"
                             + headers[query_num].dumpNames() + "
",
                             ErrorCodes::UNION_ALL_RESULT_STRUCTURES_MISMATCH);
+    }
 
-        for (size_t column_num = 0; column_num < num_columns; ++column_num)
-        {
-            std::vector<const ColumnWithTypeAndName *> columns;
-            columns.reserve(num_selects);
-            for (size_t i = 0; i < num_selects; ++i)
-                columns.push_back(&headers[i].getByPosition(column_num));
+    std::vector<const ColumnWithTypeAndName *> columns(num_selects);
 
-            ColumnWithTypeAndName & result_elem = common_header.getByPosition(column_num);
-            result_elem = getLeastSuperColumn(columns);
-        }
+    for (size_t column_num = 0; column_num < num_columns; ++column_num)
+    {
+        for (size_t i = 0; i < num_selects; ++i)
+            columns[i] = &headers[i].getByPosition(column_num);
+
+        ColumnWithTypeAndName & result_elem = common_header.getByPosition(column_num);
+        result_elem = getLeastSuperColumn(columns);
     }
 
     return common_header;
