{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7929,
  "instance_id": "ClickHouse__ClickHouse-7929",
  "issue_numbers": [
    "7279"
  ],
  "base_commit": "7bcb4f3e62e5f54fab52e0708db4b1ed5a3b5b43",
  "patch": "diff --git a/dbms/src/Columns/getLeastSuperColumn.cpp b/dbms/src/Columns/getLeastSuperColumn.cpp\nindex 11c5b1b58fde..663337b6f879 100644\n--- a/dbms/src/Columns/getLeastSuperColumn.cpp\n+++ b/dbms/src/Columns/getLeastSuperColumn.cpp\n@@ -18,7 +18,7 @@ static bool sameConstants(const IColumn & a, const IColumn & b)\n     return assert_cast<const ColumnConst &>(a).getField() == assert_cast<const ColumnConst &>(b).getField();\n }\n \n-ColumnWithTypeAndName getLeastSuperColumn(std::vector<const ColumnWithTypeAndName *> columns)\n+ColumnWithTypeAndName getLeastSuperColumn(const std::vector<const ColumnWithTypeAndName *> & columns)\n {\n     if (columns.empty())\n         throw Exception(\"Logical error: no src columns for supercolumn\", ErrorCodes::LOGICAL_ERROR);\ndiff --git a/dbms/src/Columns/getLeastSuperColumn.h b/dbms/src/Columns/getLeastSuperColumn.h\nindex d761de29a93e..cd8dc53a895b 100644\n--- a/dbms/src/Columns/getLeastSuperColumn.h\n+++ b/dbms/src/Columns/getLeastSuperColumn.h\n@@ -7,6 +7,6 @@ namespace DB\n {\n \n /// getLeastSupertype + related column changes\n-ColumnWithTypeAndName getLeastSuperColumn(std::vector<const ColumnWithTypeAndName *> columns);\n+ColumnWithTypeAndName getLeastSuperColumn(const std::vector<const ColumnWithTypeAndName *> & columns);\n \n }\ndiff --git a/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\nindex a876633609a6..2d7fde72875e 100644\n--- a/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n@@ -124,17 +124,17 @@ Block InterpreterSelectWithUnionQuery::getCommonHeaderForUnion(const Blocks & he\n                             + \"\\nand\\n\"\n                             + headers[query_num].dumpNames() + \"\\n\",\n                             ErrorCodes::UNION_ALL_RESULT_STRUCTURES_MISMATCH);\n+    }\n \n-        for (size_t column_num = 0; column_num < num_columns; ++column_num)\n-        {\n-            std::vector<const ColumnWithTypeAndName *> columns;\n-            columns.reserve(num_selects);\n-            for (size_t i = 0; i < num_selects; ++i)\n-                columns.push_back(&headers[i].getByPosition(column_num));\n+    std::vector<const ColumnWithTypeAndName *> columns(num_selects);\n \n-            ColumnWithTypeAndName & result_elem = common_header.getByPosition(column_num);\n-            result_elem = getLeastSuperColumn(columns);\n-        }\n+    for (size_t column_num = 0; column_num < num_columns; ++column_num)\n+    {\n+        for (size_t i = 0; i < num_selects; ++i)\n+            columns[i] = &headers[i].getByPosition(column_num);\n+\n+        ColumnWithTypeAndName & result_elem = common_header.getByPosition(column_num);\n+        result_elem = getLeastSuperColumn(columns);\n     }\n \n     return common_header;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01036_union_different_columns.reference b/dbms/tests/queries/0_stateless/01036_union_different_columns.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/queries/0_stateless/01036_union_different_columns.sql b/dbms/tests/queries/0_stateless/01036_union_different_columns.sql\nnew file mode 100644\nindex 000000000000..f4936b948cb6\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01036_union_different_columns.sql\n@@ -0,0 +1,1 @@\n+select 1 as c1, 2 as c2, 3 as c3 union all (select 1 as c1, 2 as c2, 3 as c3 union all select 1 as c1, 2 as c2) -- { serverError 258 }\n",
  "problem_statement": "UNION ALL causes segmentation fault with version 19.13.3.26\nthe following query will cause segmentation fault:\r\n```\r\nselect\r\n\t1 as c1,\r\n\t2 as c2,\r\n\t3 as c3\r\nunion all\r\n(\r\n\tselect \r\n\t\t1 as c1,\r\n\t\t2 as c2,\r\n\t\t3 as c3\r\n\tunion all\r\n\tselect\r\n\t\t1 as c1,\r\n\t\t2 as c2\r\n)\r\n```\r\n\r\n```\r\n2019.10.11 16:53:45.963659 [ 6315 ] {} <Error> BaseDaemon: ########################################\r\n2019.10.11 16:53:45.963729 [ 6315 ] {} <Error> BaseDaemon: (version 19.13.3.26) (from thread 624) Received signal Segmentation fault (11).\r\n2019.10.11 16:53:45.963748 [ 6315 ] {} <Error> BaseDaemon: Address: 0xfffffffffffffff8 Access: read. Address not mapped to object.\r\n2019.10.11 16:53:46.020583 [ 6315 ] {} <Error> BaseDaemon: 0. clickhouse-server(StackTrace::StackTrace(ucontext const&)+0x30) [0x6f29000]\r\n1. clickhouse-server() [0x327ebf5]\r\n2. /lib64/libpthread.so.0(+0xf6d0) [0x7fbc6a2b76d0]\r\n3. clickhouse-server(DB::isColumnConst(DB::IColumn const&)+0xa) [0x5f61a4a]\r\n4. clickhouse-server(DB::getLeastSuperColumn(std::vector<DB::ColumnWithTypeAndName const*, std::allocator<DB::ColumnWithTypeAndName const*> >)+0x1bd) [0x5f62fcd]\r\n5. clickhouse-server(DB::InterpreterSelectWithUnionQuery::getCommonHeaderForUnion(std::vector<DB::Block, std::allocator<DB::Block> > const&)+0x2ab) [0x5dc626b]\r\n6. clickhouse-server(DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::vector<std::string, std::allocator<std::string> > const&)+0xa09) [0x5dc8799]\r\n7. clickhouse-server(DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, DB::Context&, DB::QueryProcessingStage::Enum)+0x120) [0x5d92d10]\r\n8. clickhouse-server() [0x5ebbdb1]\r\n9. clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::string const&)>, std::function<void (std::string const&)>)+0x1ef) [0x5ebe74f]\r\n10. clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x16dc) [0x31b1c7c]\r\n11. clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x443) [0x31b4e33]\r\n12. clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x2af) [0x6a778ef]\r\n13. clickhouse-server(Poco::Net::TCPServerConnection::start()+0xf) [0x6a6e63f]\r\n14. clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0x166) [0x6a6ea06]\r\n15. clickhouse-server(Poco::PooledThread::run()+0x77) [0x70fdee7]\r\n16. clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x38) [0x70fa0a8]\r\n17. clickhouse-server() [0x76cc0ff]\r\n18. /lib64/libpthread.so.0(+0x7e25) [0x7fbc6a2afe25]\r\n19. /lib64/libc.so.6(clone+0x6d) [0x7fbc69cd7bad]\r\n```\r\n\r\nit seems that there is  a bug when checking the number of columns in UNION ALL elements in  InterpreterSelectWithUnionQuery.\r\n\r\nAfter the following changes were made in sql, the check of columns was successful.\r\n\r\n```\r\nselect\r\n\t1 as c1,\r\n\t2 as c2,\r\n\t3 as c3\r\nunion all\r\n(\r\n\tselect \r\n\t\t1 as c1,\r\n\t\t2 as c2\r\n\tunion all\r\n\tselect\r\n\t\t1 as c1,\r\n\t\t2 as c2,\r\n\t\t3 as c3\r\n\r\n)\r\n\r\n```\r\n\n",
  "hints_text": "Reproduces on current master :(",
  "created_at": "2019-11-26T12:09:42Z"
}