{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57867,
  "instance_id": "ClickHouse__ClickHouse-57867",
  "issue_numbers": [
    "57817"
  ],
  "base_commit": "7a5b40563ab6625e2e2722cd8ba3fa282e82037c",
  "patch": "diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 7958cdf9f507..ff34d2b175e5 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -1153,6 +1153,40 @@ std::tuple<bool /* is_regexp */, ASTPtr> StorageMerge::evaluateDatabaseName(cons\n     return {false, ast};\n }\n \n+bool StorageMerge::supportsTrivialCountOptimization() const\n+{\n+    bool supported = true;\n+    forEachTable([&](const auto & table)\n+    {\n+        supported &= table->supportsTrivialCountOptimization();\n+    });\n+    return supported;\n+}\n+\n+std::optional<UInt64> StorageMerge::totalRows(const Settings & settings) const\n+{\n+    UInt64 total_rows = 0;\n+    forEachTable([&](const auto & table)\n+    {\n+        std::optional<UInt64> rows = table->totalRows(settings);\n+        if (rows)\n+            total_rows += *rows;\n+    });\n+    return {total_rows};\n+}\n+\n+std::optional<UInt64> StorageMerge::totalBytes(const Settings & settings) const\n+{\n+    UInt64 total_bytes = 0;\n+    forEachTable([&](const auto & table)\n+    {\n+        std::optional<UInt64> bytes = table->totalBytes(settings);\n+        if (bytes)\n+            total_bytes += *bytes;\n+    });\n+    return {total_bytes};\n+}\n+\n \n void registerStorageMerge(StorageFactory & factory)\n {\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 80a5fa335f72..8b6d15910dbe 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -77,6 +77,11 @@ class StorageMerge final : public IStorage, WithContext\n     /// Evaluate database name or regexp for StorageMerge and TableFunction merge\n     static std::tuple<bool /* is_regexp */, ASTPtr> evaluateDatabaseName(const ASTPtr & node, ContextPtr context);\n \n+    bool supportsTrivialCountOptimization() const override;\n+\n+    std::optional<UInt64> totalRows(const Settings &) const override;\n+    std::optional<UInt64> totalBytes(const Settings &) const override;\n+\n private:\n     std::optional<OptimizedRegularExpression> source_database_regexp;\n     std::optional<OptimizedRegularExpression> source_table_regexp;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.reference b/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.reference\nnew file mode 100644\nindex 000000000000..3f5700b6d636\n--- /dev/null\n+++ b/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.reference\n@@ -0,0 +1,9 @@\n+2\n+Expression ((Projection + Before ORDER BY))\n+  MergingAggregated\n+    ReadFromPreparedSource (Optimized trivial count)\n+3\n+Expression ((Projection + Before ORDER BY))\n+  Aggregating\n+    Expression (Before GROUP BY)\n+      ReadFromMerge\ndiff --git a/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.sql b/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.sql\nnew file mode 100644\nindex 000000000000..9feb2aa2ad65\n--- /dev/null\n+++ b/tests/queries/0_stateless/02918_optimize_count_for_merge_tables.sql\n@@ -0,0 +1,32 @@\n+-- Tests that Merge-engine (not: MergeTree!) tables support the trivial count\n+-- optimization if all underlying tables support it\n+\n+DROP TABLE IF EXISTS mt1;\n+DROP TABLE IF EXISTS mt2;\n+DROP TABLE IF EXISTS merge;\n+\n+CREATE TABLE mt1 (id UInt64) ENGINE = MergeTree ORDER BY id;\n+CREATE TABLE mt2 (id UInt64) ENGINE = MergeTree ORDER BY id;\n+CREATE TABLE merge (id UInt64) ENGINE = Merge(currentDatabase(), '^mt[0-9]+$');\n+\n+INSERT INTO mt1 VALUES (1);\n+INSERT INTO mt2 VALUES (1);\n+\n+SELECT count() FROM merge;\n+\n+-- can use the trivial count optimization\n+EXPLAIN SELECT count() FROM merge settings allow_experimental_analyzer=0;\n+\n+CREATE TABLE mt3 (id UInt64) ENGINE = TinyLog;\n+\n+INSERT INTO mt2 VALUES (2);\n+\n+SELECT count() FROM merge;\n+\n+-- can't use the trivial count optimization as TinyLog doesn't support it\n+EXPLAIN SELECT count() FROM merge settings allow_experimental_analyzer=0;\n+\n+DROP TABLE IF EXISTS mt1;\n+DROP TABLE IF EXISTS mt2;\n+DROP TABLE IF EXISTS mt3;\n+DROP TABLE IF EXISTS merge;\n",
  "problem_statement": "Support trivial count optimization for `Merge` tables\n```sql\r\n\r\nDROP TABLE IF EXISTS mt1;\r\nDROP TABLE IF EXISTS mt2;\r\nDROP TABLE IF EXISTS merge;\r\n\r\nCREATE TABLE mt1 (id UInt64) ENGINE = MergeTree ORDER BY id;\r\n\r\nCREATE TABLE mt2 (id UInt64) ENGINE = MergeTree ORDER BY id;\r\n\r\nCREATE TABLE merge (id UInt64) ENGINE = Merge(currentDatabase(), '^mt[0-9]+$');\r\n\r\nINSERT INTO mt1 VALUES (1);\r\nINSERT INTO mt2 VALUES (1);\r\n```\r\n\r\n```sql\r\nEXPLAIN SELECT count() FROM mt1;\r\n```\r\n\r\n```\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Expression ((Projection + Before ORDER BY))          \u2502\r\n\u2502   MergingAggregated                                  \u2502\r\n\u2502     ReadFromPreparedSource (Optimized trivial count) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n```sql\r\nEXPLAIN SELECT count() FROM merge;\r\n```\r\n\r\n```\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Expression ((Projection + Before ORDER BY)) \u2502\r\n\u2502   Aggregating                               \u2502\r\n\u2502     Expression (Before GROUP BY)            \u2502\r\n\u2502       ReadFromMerge                         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nSupport trivial count optimization (setting `optimize_trivial_count_query`) in tables with `Merge` engine if all their underlying tables supports such optimization.\r\n\r\n\r\n\r\n**Additional context**\r\n\r\nSee methods `IStorage::supportsTrivialCountOptimization` and `IStorage::totalRows`.\n",
  "hints_text": "Hi @CurtizJ I would like to give it a try, can you assign it to me?\n@skyoct, yes, this will be very appreciated!",
  "created_at": "2023-12-14T14:10:52Z"
}