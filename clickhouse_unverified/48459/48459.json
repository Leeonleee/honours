{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48459,
  "instance_id": "ClickHouse__ClickHouse-48459",
  "issue_numbers": [
    "47291"
  ],
  "base_commit": "85f5600ab142d4c87584963b0490c2c1954780d7",
  "patch": "diff --git a/src/Common/Concepts.h b/src/Common/Concepts.h\nindex b1bf591024d1..927f42aa4bea 100644\n--- a/src/Common/Concepts.h\n+++ b/src/Common/Concepts.h\n@@ -5,6 +5,10 @@\n namespace DB\n {\n \n+template<typename T, typename ... U>\n+concept is_any_of = (std::same_as<T, U> || ...);\n+\n+\n template <typename... T>\n concept OptionalArgument = requires(T &&...)\n {\ndiff --git a/src/Common/typeid_cast.h b/src/Common/typeid_cast.h\nindex 1568d3809389..baee3aaf6327 100644\n--- a/src/Common/typeid_cast.h\n+++ b/src/Common/typeid_cast.h\n@@ -18,9 +18,6 @@ namespace DB\n     }\n }\n \n-template<typename T, typename ... U>\n-concept is_any_of = (std::same_as<T, U> || ...);\n-\n \n /** Checks type by comparing typeid.\n   * The exact match of the type is checked. That is, cast to the ancestor will be unsuccessful.\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex f832bf404a8b..28002d34acc4 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -41,6 +41,7 @@\n #include <Columns/ColumnsCommon.h>\n #include <Columns/ColumnStringHelpers.h>\n #include <Common/assert_cast.h>\n+#include <Common/Concepts.h>\n #include <Common/quoteString.h>\n #include <Common/Exception.h>\n #include <Core/AccurateComparison.h>\ndiff --git a/src/Functions/formatDateTime.cpp b/src/Functions/formatDateTime.cpp\nindex bbb4c3ba5b01..5ec0212c56d5 100644\n--- a/src/Functions/formatDateTime.cpp\n+++ b/src/Functions/formatDateTime.cpp\n@@ -17,6 +17,7 @@\n \n #include <IO/WriteHelpers.h>\n \n+#include <Common/Concepts.h>\n #include <Common/DateLUTImpl.h>\n #include <base/find_symbols.h>\n #include <Core/DecimalFunctions.h>\n@@ -38,22 +39,19 @@ namespace ErrorCodes\n \n namespace\n {\n+using Pos = const char *;\n \n-struct FormatDateTimeTraits\n+enum class SupportInteger\n {\n-    enum class SupportInteger\n-    {\n-        Yes,\n-        No\n-    };\n-\n-    enum class FormatSyntax\n-    {\n-        MySQL,\n-        Joda\n-    };\n+    Yes,\n+    No\n };\n \n+enum class FormatSyntax\n+{\n+    MySQL,\n+    Joda\n+};\n \n template <typename DataType> struct InstructionValueTypeMap {};\n template <> struct InstructionValueTypeMap<DataTypeInt8>       { using InstructionValueType = UInt32; };\n@@ -85,11 +83,9 @@ constexpr std::string_view weekdaysFull[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wed\n \n constexpr std::string_view weekdaysShort[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\n \n-constexpr std::string_view monthsFull[]\n-    = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n+constexpr std::string_view monthsFull[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n \n-constexpr std::string_view monthsShort[]\n-    = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n+constexpr std::string_view monthsShort[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n \n /** formatDateTime(time, 'format')\n   * Performs formatting of time, according to provided format.\n@@ -115,13 +111,13 @@ constexpr std::string_view monthsShort[]\n   *\n   * Performance on Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz:\n   *\n-  * WITH formatDateTime(now() + number, '%H:%M:%S') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x);\n+  * WITH formatDateTime(now() + number, '%H:%i:%S') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x);\n   * - 97 million rows per second per core;\n   *\n   * WITH formatDateTime(toDateTime('2018-01-01 00:00:00') + number, '%F %T') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x)\n   * - 71 million rows per second per core;\n   *\n-  * select count() from (select formatDateTime(t, '%m/%d/%Y %H:%M:%S') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));\n+  * select count() from (select formatDateTime(t, '%m/%d/%Y %H:%i:%S') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));\n   * - 53 million rows per second per core;\n   *\n   * select count() from (select formatDateTime(t, 'Hello %Y World') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));\n@@ -129,7 +125,7 @@ constexpr std::string_view monthsShort[]\n   *\n   * PS. We can make this function to return FixedString. Currently it returns String.\n   */\n-template <typename Name, FormatDateTimeTraits::SupportInteger support_integer, FormatDateTimeTraits::FormatSyntax format_syntax>\n+template <typename Name, SupportInteger support_integer, FormatSyntax format_syntax>\n class FunctionFormatDateTimeImpl : public IFunction\n {\n private:\n@@ -152,26 +148,34 @@ class FunctionFormatDateTimeImpl : public IFunction\n     class Instruction\n     {\n     public:\n-        /// Using std::function will cause performance degradation in MySQL format by 0.45x.\n-        /// But std::function is required for Joda format to capture extra variables.\n-        /// This is the reason why we use raw function pointer in MySQL format and std::function\n-        /// in Joda format.\n-        using Func = std::conditional_t<\n-            format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL,\n-            size_t (*)(char *, Time, UInt64, UInt32, const DateLUTImpl &),\n-            std::function<size_t(char *, Time, UInt64, UInt32, const DateLUTImpl &)>>;\n+        /// Joda format generally requires capturing extra variables (i.e. holding state) which is more convenient with\n+        /// std::function and std::bind. Unfortunately, std::function causes a performance degradation by 0.45x compared to raw function\n+        /// pointers. For MySQL format, we generally prefer raw function pointers. Because of the special case that not all formatters are\n+        /// fixed-width formatters (see mysqlLiteral instruction), we still need to be able to store state. For that reason, we use member\n+        /// function pointers instead of static function pointers.\n+        using FuncMysql = size_t (Instruction<Time>::*)(char *, Time, UInt64, UInt32, const DateLUTImpl &);\n+        FuncMysql func_mysql = nullptr;\n \n-        Func func;\n+        using FuncJoda = std::function<size_t(char *, Time, UInt64, UInt32, const DateLUTImpl &)>;\n+        FuncJoda func_joda = nullptr;\n \n         /// extra_shift is only used in MySQL format syntax. It is always 0 in Joda format syntax.\n         size_t extra_shift = 0;\n \n-        /// Instruction for appending date/time related number in specified format.\n-        explicit Instruction(Func && func_) : func(std::move(func_)) {}\n+        // Holds literal characters that will be copied into the output. Used by the mysqlLiteral instruction.\n+        String literal;\n+\n+        Instruction() = default;\n+\n+        void setMysqlFunc(FuncMysql && func) { func_mysql = std::move(func); }\n+        void setJodaFunc(FuncJoda && func) { func_joda = std::move(func); }\n+        void setLiteral(std::string_view literal_) { literal = literal_; }\n \n         void perform(char *& dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n-            auto shift = func(dest, source, fractional_second, scale, timezone);\n+            size_t shift = func_mysql\n+                           ? std::invoke(func_mysql, this, dest, source, fractional_second, scale, timezone)\n+                           : std::invoke(func_joda, dest, source, fractional_second, scale, timezone);\n             dest += shift + extra_shift;\n         }\n \n@@ -257,21 +261,30 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return pos;\n         }\n     public:\n-        static size_t mysqlNoop(char *, Time, UInt64, UInt32, const DateLUTImpl &) { return 0; }\n+        size_t mysqlNoop(char *, Time, UInt64, UInt32, const DateLUTImpl &)\n+        {\n+            return 0;\n+        }\n \n-        static size_t mysqlCentury(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlLiteral(char * dest, Time, UInt64, UInt32, const DateLUTImpl &)\n+        {\n+            memcpy(dest, literal.data(), literal.size());\n+            return literal.size();\n+        }\n+\n+        size_t mysqlCentury(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto year = ToYearImpl::execute(source, timezone);\n             auto century = year / 100;\n             return writeNumber2(dest, century);\n         }\n \n-        static size_t mysqlDayOfMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToDayOfMonthImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlAmericanDate(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlAmericanDate(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             writeNumber2(dest, ToMonthImpl::execute(source, timezone));\n             writeNumber2(dest + 3, ToDayOfMonthImpl::execute(source, timezone));\n@@ -279,7 +292,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 8;\n         }\n \n-        static size_t mysqlDayOfMonthSpacePadded(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfMonthSpacePadded(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto day = ToDayOfMonthImpl::execute(source, timezone);\n             if (day < 10)\n@@ -289,7 +302,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 2;\n         }\n \n-        static size_t mysqlISO8601Date(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        size_t mysqlISO8601Date(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             writeNumber4(dest, ToYearImpl::execute(source, timezone));\n             writeNumber2(dest + 5, ToMonthImpl::execute(source, timezone));\n@@ -297,12 +310,12 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 10;\n         }\n \n-        static size_t mysqlDayOfYear(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfYear(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber3(dest, ToDayOfYearImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToMonthImpl::execute(source, timezone));\n         }\n@@ -315,17 +328,17 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return str_view.size();\n         }\n \n-        static size_t mysqlMonthOfYearTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n+        size_t mysqlMonthOfYearTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n             return monthOfYearText(dest, source, true, fractional_second, scale, timezone);\n         }\n \n-        static size_t mysqlMonthOfYearTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n+        size_t mysqlMonthOfYearTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n             return monthOfYearText(dest, source, false, fractional_second, scale, timezone);\n         }\n \n-        static size_t mysqlDayOfWeek(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfWeek(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             *dest = '0' + ToDayOfWeekImpl::execute(source, 0, timezone);\n             return 1;\n@@ -342,65 +355,65 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return str_view.size();\n         }\n \n-        static size_t mysqlDayOfWeekTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfWeekTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n             return dayOfWeekText(dest, source, true, fractional_second, scale, timezone);\n         }\n \n-        static size_t mysqlDayOfWeekTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfWeekTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n             return dayOfWeekText(dest, source, false, fractional_second, scale, timezone);\n         }\n \n-        static size_t mysqlDayOfWeek0To6(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlDayOfWeek0To6(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto day = ToDayOfWeekImpl::execute(source, 0, timezone);\n             *dest = '0' + (day == 7 ? 0 : day);\n             return 1;\n         }\n \n-        static size_t mysqlISO8601Week(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        size_t mysqlISO8601Week(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToISOWeekImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlISO8601Year2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        size_t mysqlISO8601Year2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToISOYearImpl::execute(source, timezone) % 100);\n         }\n \n-        static size_t mysqlISO8601Year4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        size_t mysqlISO8601Year4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber4(dest, ToISOYearImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlYear2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlYear2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToYearImpl::execute(source, timezone) % 100);\n         }\n \n-        static size_t mysqlYear4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlYear4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber4(dest, ToYearImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlHour24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlHour24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToHourImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlHour12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlHour12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto x = ToHourImpl::execute(source, timezone);\n             return writeNumber2(dest, x == 0 ? 12 : (x > 12 ? x - 12 : x));\n         }\n \n-        static size_t mysqlMinute(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlMinute(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToMinuteImpl::execute(source, timezone));\n         }\n \n-        static size_t mysqlAMPM(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        static size_t AMPM(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n         {\n             auto hour = ToHourImpl::execute(source, timezone);\n             dest[0] = hour >= 12 ? 'P' : 'A';\n@@ -408,14 +421,19 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 2;\n         }\n \n-        static size_t mysqlHHMM24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlAMPM(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n+        {\n+            return AMPM(dest, source, fractional_second, scale, timezone);\n+        }\n+\n+        size_t mysqlHHMM24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             writeNumber2(dest, ToHourImpl::execute(source, timezone));\n             writeNumber2(dest + 3, ToMinuteImpl::execute(source, timezone));\n             return 5;\n         }\n \n-        static size_t mysqlHHMM12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlHHMM12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto hour = ToHourImpl::execute(source, timezone);\n             writeNumber2(dest, hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour));\n@@ -425,13 +443,12 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 8;\n         }\n \n-        static size_t mysqlSecond(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlSecond(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             return writeNumber2(dest, ToSecondImpl::execute(source, timezone));\n         }\n \n-        static size_t\n-        mysqlFractionalSecond(char * dest, Time /*source*/, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & /*timezone*/)\n+        size_t mysqlFractionalSecond(char * dest, Time /*source*/, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & /*timezone*/)\n         {\n             if (scale == 0)\n                 scale = 1;\n@@ -444,7 +461,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return scale;\n         }\n \n-        static size_t mysqlISO8601Time(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n+        size_t mysqlISO8601Time(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT\n         {\n             writeNumber2(dest, ToHourImpl::execute(source, timezone));\n             writeNumber2(dest + 3, ToMinuteImpl::execute(source, timezone));\n@@ -452,7 +469,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 8;\n         }\n \n-        static size_t mysqlTimezoneOffset(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlTimezoneOffset(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             auto offset = TimezoneOffsetImpl::execute(source, timezone);\n             if (offset < 0)\n@@ -466,7 +483,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             return 5;\n         }\n \n-        static size_t mysqlQuarter(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n+        size_t mysqlQuarter(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n             *dest = '0' + ToQuarterImpl::execute(source, timezone);\n             return 1;\n@@ -575,7 +592,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n         static size_t jodaHalfDayOfDay(\n             size_t /*min_represent_digits*/, char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)\n         {\n-            return mysqlAMPM(dest, source, fractional_second, scale, timezone);\n+            return AMPM(dest, source, fractional_second, scale, timezone);\n         }\n \n         static size_t jodaHourOfHalfDay(size_t min_represent_digits, char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n@@ -651,6 +668,36 @@ class FunctionFormatDateTimeImpl : public IFunction\n         }\n     };\n \n+    [[noreturn]] static void throwLastCharacterIsPercentException()\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"'%' must not be the last character in the format string, use '%%' instead\");\n+    }\n+\n+    static bool containsOnlyFixedWidthMySQLFormatters(std::string_view format)\n+    {\n+        static constexpr std::array variable_width_formatter = {'W'};\n+\n+        for (size_t i = 0; i < format.size(); ++i)\n+        {\n+            switch (format[i])\n+            {\n+                case '%':\n+                    if (i + 1 >= format.size())\n+                        throwLastCharacterIsPercentException();\n+                    if (std::any_of(\n+                            variable_width_formatter.begin(), variable_width_formatter.end(),\n+                            [&](char c){ return c == format[i + 1]; }))\n+                        return false;\n+                    i += 1;\n+                    continue;\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n public:\n     static constexpr auto name = Name::name;\n \n@@ -672,7 +719,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if constexpr (support_integer == FormatDateTimeTraits::SupportInteger::Yes)\n+        if constexpr (support_integer == SupportInteger::Yes)\n         {\n             if (arguments.size() != 1 && arguments.size() != 2 && arguments.size() != 3)\n                 throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n@@ -718,7 +765,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, [[maybe_unused]] size_t input_rows_count) const override\n     {\n         ColumnPtr res;\n-        if constexpr (support_integer == FormatDateTimeTraits::SupportInteger::Yes)\n+        if constexpr (support_integer == SupportInteger::Yes)\n         {\n             if (arguments.size() == 1)\n             {\n@@ -790,10 +837,27 @@ class FunctionFormatDateTimeImpl : public IFunction\n         if constexpr (std::is_same_v<DataType, DataTypeDateTime64>)\n             scale = times->getScale();\n \n+        /// For MySQL, we support two modes of execution:\n+        ///\n+        /// - All formatters in the format string are fixed-width. As a result, all output rows will have the same width and structure. We\n+        ///   take advantage of this and\n+        ///     1. create a \"template\" with placeholders from the format string,\n+        ///     2. allocate a result column large enough to store the template on each row,\n+        ///     3. copy the template into each result row,\n+        ///     4. run instructions which replace the formatter placeholders. All other parts of the template (e.g. whitespaces) are already\n+        ///        as desired and instructions skip over them (see 'extra_shift' in the formatters).\n+        ///\n+        /// - The format string contains at least one variable-width formatter. Output rows will potentially be of different size.\n+        ///   Steps 1. and 2. are performed as above (the result column is allocated based on a worst-case size estimation). The result\n+        ///   column rows are NOT populated with the template and left uninitialized. We run the normal instructions for formatters AND\n+        ///   instructions that copy literal characters before/between/after formatters. As a result, each byte of each result row is\n+        ///   written which is obviously slow.\n+        bool mysql_with_only_fixed_length_formatters = (format_syntax == FormatSyntax::MySQL) ? containsOnlyFixedWidthMySQLFormatters(format) : false;\n+\n         using T = typename InstructionValueTypeMap<DataType>::InstructionValueType;\n         std::vector<Instruction<T>> instructions;\n         String out_template;\n-        auto result_size = parseFormat(format, instructions, scale, out_template);\n+        size_t out_template_size = parseFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);\n \n         const DateLUTImpl * time_zone_tmp = nullptr;\n         if (castType(arguments[0].type.get(), [&]([[maybe_unused]] const auto & type) { return true; }))\n@@ -807,36 +871,39 @@ class FunctionFormatDateTimeImpl : public IFunction\n         const auto & vec = times->getData();\n \n         auto col_res = ColumnString::create();\n-        auto & dst_data = col_res->getChars();\n-        auto & dst_offsets = col_res->getOffsets();\n-        dst_data.resize(vec.size() * (result_size + 1));\n-        dst_offsets.resize(vec.size());\n+        auto & res_data = col_res->getChars();\n+        auto & res_offsets = col_res->getOffsets();\n+        res_data.resize(vec.size() * (out_template_size + 1));\n+        res_offsets.resize(vec.size());\n \n-        if constexpr (format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL)\n+        if constexpr (format_syntax == FormatSyntax::MySQL)\n         {\n-            /// Fill result with literals.\n+            if (mysql_with_only_fixed_length_formatters)\n             {\n-                UInt8 * begin = dst_data.data();\n-                UInt8 * end = begin + dst_data.size();\n-                UInt8 * pos = begin;\n-\n-                if (pos < end)\n+                /// Fill result with template.\n                 {\n-                    memcpy(pos, out_template.data(), result_size + 1); /// With zero terminator.\n-                    pos += result_size + 1;\n-                }\n+                    const UInt8 * const begin = res_data.data();\n+                    const UInt8 * const end = res_data.data() + res_data.size();\n+                    UInt8 * pos = res_data.data();\n \n-                /// Fill by copying exponential growing ranges.\n-                while (pos < end)\n-                {\n-                    size_t bytes_to_copy = std::min(pos - begin, end - pos);\n-                    memcpy(pos, begin, bytes_to_copy);\n-                    pos += bytes_to_copy;\n+                    if (pos < end)\n+                    {\n+                        memcpy(pos, out_template.data(), out_template_size + 1); /// With zero terminator. mystring[mystring.size()] = '\\0' is guaranteed since C++11.\n+                        pos += out_template_size + 1;\n+                    }\n+\n+                    /// Copy exponentially growing ranges.\n+                    while (pos < end)\n+                    {\n+                        size_t bytes_to_copy = std::min(pos - begin, end - pos);\n+                        memcpy(pos, begin, bytes_to_copy);\n+                        pos += bytes_to_copy;\n+                    }\n                 }\n             }\n         }\n \n-        auto * begin = reinterpret_cast<char *>(dst_data.data());\n+        auto * begin = reinterpret_cast<char *>(res_data.data());\n         auto * pos = begin;\n         for (size_t i = 0; i < vec.size(); ++i)\n         {\n@@ -844,9 +911,7 @@ class FunctionFormatDateTimeImpl : public IFunction\n             {\n                 const auto c = DecimalUtils::split(vec[i], scale);\n                 for (auto & instruction : instructions)\n-                {\n                     instruction.perform(pos, static_cast<Int64>(c.whole), c.fractional, scale, time_zone);\n-                }\n             }\n             else\n             {\n@@ -855,289 +920,444 @@ class FunctionFormatDateTimeImpl : public IFunction\n             }\n             *pos++ = '\\0';\n \n-            dst_offsets[i] = pos - begin;\n+            res_offsets[i] = pos - begin;\n         }\n \n-        dst_data.resize(pos - begin);\n+        res_data.resize(pos - begin);\n         return col_res;\n     }\n \n     template <typename T>\n-    size_t parseFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, String & out_template) const\n+    size_t parseFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, bool mysql_with_only_fixed_length_formatters, String & out_template) const\n     {\n-        static_assert(\n-            format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL || format_syntax == FormatDateTimeTraits::FormatSyntax::Joda,\n-            \"format syntax must be one of MySQL or Joda\");\n+        static_assert(format_syntax == FormatSyntax::MySQL || format_syntax == FormatSyntax::Joda);\n \n-        if constexpr (format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL)\n-            return parseMySQLFormat(format, instructions, scale, out_template);\n+        if constexpr (format_syntax == FormatSyntax::MySQL)\n+            return parseMySQLFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);\n         else\n-            return parseJodaFormat(format, instructions, scale, out_template);\n+            return parseJodaFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);\n     }\n \n     template <typename T>\n-    size_t parseMySQLFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, String & out_template) const\n+    size_t parseMySQLFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, bool mysql_with_only_fixed_length_formatters, String & out_template) const\n     {\n         auto add_extra_shift = [&](size_t amount)\n         {\n             if (instructions.empty())\n-                instructions.emplace_back(&Instruction<T>::mysqlNoop);\n+            {\n+                Instruction<T> instruction;\n+                instruction.setMysqlFunc(&Instruction<T>::mysqlNoop);\n+                instructions.push_back(std::move(instruction));\n+            }\n             instructions.back().extra_shift += amount;\n         };\n \n-        auto add_instruction_or_extra_shift = [&](auto * func [[maybe_unused]], size_t amount [[maybe_unused]])\n+        auto add_literal_instruction = [&](std::string_view literal)\n         {\n-            if constexpr (std::is_same_v<T, UInt32> || std::is_same_v<T, Int64>)\n-                instructions.emplace_back(std::move(func));\n-            else\n+            Instruction<T> instruction;\n+            instruction.setMysqlFunc(&Instruction<T>::mysqlLiteral);\n+            instruction.setLiteral(literal);\n+            instructions.push_back(std::move(instruction));\n+        };\n+\n+        auto add_extra_shift_or_literal_instruction = [&](size_t amount, std::string_view literal)\n+        {\n+            if (mysql_with_only_fixed_length_formatters)\n                 add_extra_shift(amount);\n+            else\n+                add_literal_instruction(literal);\n         };\n \n-        const char * pos = format.data();\n-        const char * const end = format.data() + format.size();\n+        auto add_time_instruction = [&]([[maybe_unused]] typename Instruction<T>::FuncMysql && func, [[maybe_unused]] size_t amount, [[maybe_unused]] std::string_view literal)\n+        {\n+            /// DateTime/DateTime64 --> insert instruction\n+            /// Other types cannot provide the requested data --> write out template\n+            if constexpr (is_any_of<T, UInt32, Int64>)\n+            {\n+                Instruction<T> instruction;\n+                instruction.setMysqlFunc(std::move(func));\n+                instructions.push_back(std::move(instruction));\n+            }\n+            else\n+                add_extra_shift_or_literal_instruction(amount, literal);\n+        };\n+\n+        Pos pos = format.data();\n+        Pos const end = format.data() + format.size();\n \n         while (true)\n         {\n-            const char * percent_pos = find_first_symbols<'%'>(pos, end);\n+            Pos const percent_pos = find_first_symbols<'%'>(pos, end);\n \n             if (percent_pos < end)\n             {\n                 if (pos < percent_pos)\n                 {\n-                    add_extra_shift(percent_pos - pos);\n+                    /// Handle characters before next %\n+                    add_extra_shift_or_literal_instruction(percent_pos - pos, std::string_view(pos, percent_pos - pos));\n                     out_template += String(pos, percent_pos - pos);\n                 }\n \n                 pos = percent_pos + 1;\n                 if (pos >= end)\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Sign '%' is the last in format, if you need it, use '%%'\");\n+                    throwLastCharacterIsPercentException();\n \n                 switch (*pos)\n                 {\n-                    // Abbreviated weekday [Mon...Sun]\n+                    // Abbreviated weekday [Mon-Sun]\n                     case 'a':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeekTextShort);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeekTextShort);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"Mon\";\n                         break;\n+                    }\n \n-                    // Abbreviated month [Jan...Dec]\n+                    // Abbreviated month [Jan-Dec]\n                     case 'b':\n-                        instructions.emplace_back(&Instruction<T>::mysqlMonthOfYearTextShort);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonthOfYearTextShort);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"Jan\";\n                         break;\n+                    }\n \n                     // Month as a integer number (01-12)\n                     case 'c':\n-                        instructions.emplace_back(&Instruction<T>::mysqlMonth);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonth);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // Year, divided by 100, zero-padded\n                     case 'C':\n-                        instructions.emplace_back(&Instruction<T>::mysqlCentury);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlCentury);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // Day of month, zero-padded (01-31)\n                     case 'd':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfMonth);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfMonth);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // Short MM/DD/YY date, equivalent to %m/%d/%y\n                     case 'D':\n-                        instructions.emplace_back(&Instruction<T>::mysqlAmericanDate);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlAmericanDate);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00/00/00\";\n                         break;\n+                    }\n \n                     // Day of month, space-padded ( 1-31)  23\n                     case 'e':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfMonthSpacePadded);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfMonthSpacePadded);\n+                        instructions.push_back(std::move(std::move(instruction)));\n                         out_template += \" 0\";\n                         break;\n+                    }\n \n                     // Fractional seconds\n                     case 'f':\n                     {\n                         /// If the time data type has no fractional part, then we print '0' as the fractional part.\n-                        instructions.emplace_back(&Instruction<T>::mysqlFractionalSecond);\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlFractionalSecond);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += String(std::max<UInt32>(1, scale), '0');\n                         break;\n                     }\n \n                     // Short YYYY-MM-DD date, equivalent to %Y-%m-%d   2001-08-23\n                     case 'F':\n-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Date);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Date);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0000-00-00\";\n                         break;\n+                    }\n \n                     // Last two digits of year of ISO 8601 week number (see %G)\n                     case 'g':\n-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Year2);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Year2);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // Year of ISO 8601 week number (see %V)\n                     case 'G':\n-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Year4);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Year4);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0000\";\n                         break;\n+                    }\n \n                     // Day of the year (001-366)   235\n                     case 'j':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfYear);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfYear);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"000\";\n                         break;\n+                    }\n \n                     // Month as a integer number (01-12)\n                     case 'm':\n-                        instructions.emplace_back(&Instruction<T>::mysqlMonth);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonth);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // ISO 8601 weekday as number with Monday as 1 (1-7)\n                     case 'u':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeek);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeek);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0\";\n                         break;\n+                    }\n \n                     // ISO 8601 week number (01-53)\n                     case 'V':\n-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Week);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Week);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n-                    // Weekday as a integer number with Sunday as 0 (0-6)  4\n+                    // Weekday as a decimal number with Sunday as 0 (0-6)  4\n                     case 'w':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeek0To6);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeek0To6);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0\";\n                         break;\n+                    }\n \n-                    // Full weekday [Monday...Sunday]\n+                    // Full weekday [Monday-Sunday]\n                     case 'W':\n-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeekTextLong);\n-                        out_template += \"Monday\";\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeekTextLong);\n+                        instructions.push_back(std::move(instruction));\n+                        out_template += \"Wednesday\"; /// longest possible weekday name\n                         break;\n+                    }\n \n                     // Two digits year\n                     case 'y':\n-                        instructions.emplace_back(&Instruction<T>::mysqlYear2);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlYear2);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"00\";\n                         break;\n+                    }\n \n                     // Four digits year\n                     case 'Y':\n-                        instructions.emplace_back(&Instruction<T>::mysqlYear4);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlYear4);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0000\";\n                         break;\n+                    }\n \n                     // Quarter (1-4)\n                     case 'Q':\n-                        instructions.template emplace_back(&Instruction<T>::mysqlQuarter);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlQuarter);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"0\";\n                         break;\n+                    }\n \n                     // Offset from UTC timezone as +hhmm or -hhmm\n                     case 'z':\n-                        instructions.emplace_back(&Instruction<T>::mysqlTimezoneOffset);\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setMysqlFunc(&Instruction<T>::mysqlTimezoneOffset);\n+                        instructions.push_back(std::move(instruction));\n                         out_template += \"+0000\";\n                         break;\n+                    }\n \n                     /// Time components. If the argument is Date, not a DateTime, then this components will have default value.\n \n                     // Minute (00-59)\n                     case 'M':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlMinute, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlMinute, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // AM or PM\n                     case 'p':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlAMPM, 2);\n-                        out_template += \"AM\";\n+                    {\n+                        static constexpr std::string_view val = \"AM\";\n+                        add_time_instruction(&Instruction<T>::mysqlAMPM, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // 12-hour HH:MM time, equivalent to %h:%i %p 2:55 PM\n                     case 'r':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHHMM12, 8);\n-                        out_template += \"12:00 AM\";\n+                    {\n+                        static constexpr std::string_view val = \"12:00 AM\";\n+                        add_time_instruction(&Instruction<T>::mysqlHHMM12, 8, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // 24-hour HH:MM time, equivalent to %H:%i 14:55\n                     case 'R':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHHMM24, 5);\n-                        out_template += \"00:00\";\n+                    {\n+                        static constexpr std::string_view val = \"00:00\";\n+                        add_time_instruction(&Instruction<T>::mysqlHHMM24, 5, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Seconds\n                     case 's':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlSecond, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlSecond, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Seconds\n                     case 'S':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlSecond, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlSecond, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // ISO 8601 time format (HH:MM:SS), equivalent to %H:%i:%S 14:55:02\n                     case 'T':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlISO8601Time, 8);\n-                        out_template += \"00:00:00\";\n+                    {\n+                        static constexpr std::string_view val = \"00:00:00\";\n+                        add_time_instruction(&Instruction<T>::mysqlISO8601Time, 8, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Hour in 12h format (01-12)\n                     case 'h':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);\n-                        out_template += \"12\";\n+                    {\n+                        static constexpr std::string_view val = \"12\";\n+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Hour in 24h format (00-23)\n                     case 'H':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour24, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlHour24, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Minute of hour range [0, 59]\n                     case 'i':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlMinute, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlMinute, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Hour in 12h format (01-12)\n                     case 'I':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);\n-                        out_template += \"12\";\n+                    {\n+                        static constexpr std::string_view val = \"12\";\n+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Hour in 24h format (00-23)\n                     case 'k':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour24, 2);\n-                        out_template += \"00\";\n+                    {\n+                        static constexpr std::string_view val = \"00\";\n+                        add_time_instruction(&Instruction<T>::mysqlHour24, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Hour in 12h format (01-12)\n                     case 'l':\n-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);\n-                        out_template += \"12\";\n+                    {\n+                        static constexpr std::string_view val = \"12\";\n+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     case 't':\n-                        add_extra_shift(1);\n-                        out_template += \"\\t\";\n+                    {\n+                        static constexpr std::string_view val = \"\\t\";\n+                        add_extra_shift_or_literal_instruction(1, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     case 'n':\n-                        add_extra_shift(1);\n-                        out_template += \"\\n\";\n+                    {\n+                        static constexpr std::string_view val = \"\\n\";\n+                        add_extra_shift_or_literal_instruction(1, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Escaped literal characters.\n                     case '%':\n-                        add_extra_shift(1);\n-                        out_template += \"%\";\n+                    {\n+                        static constexpr std::string_view val = \"%\";\n+                        add_extra_shift_or_literal_instruction(1, val);\n+                        out_template += val;\n                         break;\n+                    }\n \n                     // Unimplemented\n                     case 'U':\n@@ -1148,7 +1368,6 @@ class FunctionFormatDateTimeImpl : public IFunction\n                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"format is not supported for YEAR for week (Mon-Sun)\");\n                     case 'X':\n                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"format is not supported for YEAR for week (Sun-Sat)\");\n-\n                     default:\n                         throw Exception(\n                             ErrorCodes::BAD_ARGUMENTS,\n@@ -1157,12 +1376,12 @@ class FunctionFormatDateTimeImpl : public IFunction\n                             *pos,\n                             getName());\n                 }\n-\n                 ++pos;\n             }\n             else\n             {\n-                add_extra_shift(end - pos);\n+                /// Handle characters after last %\n+                add_extra_shift_or_literal_instruction(end - pos, std::string_view(pos, end - pos));\n                 out_template += String(pos, end - pos);\n                 break;\n             }\n@@ -1172,32 +1391,41 @@ class FunctionFormatDateTimeImpl : public IFunction\n     }\n \n     template <typename T>\n-    size_t parseJodaFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32, String &) const\n+    size_t parseJodaFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32, bool, String &) const\n     {\n         /// If the argument was DateTime, add instruction for printing. If it was date, just append default literal\n-        auto add_instruction = [&](auto && func [[maybe_unused]], const String & default_literal [[maybe_unused]])\n+        auto add_instruction = [&]([[maybe_unused]] typename Instruction<T>::FuncJoda && func, [[maybe_unused]] const String & default_literal)\n         {\n-            if constexpr (std::is_same_v<T, UInt32> || std::is_same_v<T, Int64>)\n-                instructions.emplace_back(func);\n+            if constexpr (is_any_of<T, UInt32, Int64>)\n+            {\n+                Instruction<T> instruction;\n+                instruction.setJodaFunc(std::move(func));\n+                instructions.push_back(std::move(instruction));\n+            }\n             else\n-                instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<String>, default_literal));\n+            {\n+                Instruction<T> instruction;\n+                instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<String>, default_literal));\n+                instructions.push_back(std::move(instruction));\n+            }\n         };\n \n         size_t reserve_size = 0;\n-        const char * pos = format.data();\n-        const char * end = format.data() + format.size();\n+        Pos pos = format.data();\n+        Pos end = format.data() + format.size();\n         while (pos < end)\n         {\n-            const char * cur_token = pos;\n-\n+            Pos cur_token = pos;\n             // Literal case\n             if (*cur_token == '\\'')\n             {\n                 // Case 1: 2 consecutive single quote\n                 if (pos + 1 < end && *(pos + 1) == '\\'')\n                 {\n+                    Instruction<T> instruction;\n                     std::string_view literal(cur_token, 1);\n-                    instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                    instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                    instructions.push_back(std::move(instruction));\n                     ++reserve_size;\n                     pos += 2;\n                 }\n@@ -1211,9 +1439,10 @@ class FunctionFormatDateTimeImpl : public IFunction\n                     {\n                         for (Int64 i = 1; i <= count; i++)\n                         {\n+                            Instruction<T> instruction;\n                             std::string_view literal(cur_token + i, 1);\n-                            instructions.emplace_back(\n-                                std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                            instructions.push_back(std::move(instruction));\n                             ++reserve_size;\n                             if (*(cur_token + i) == '\\'')\n                                 i += 1;\n@@ -1234,68 +1463,114 @@ class FunctionFormatDateTimeImpl : public IFunction\n                 switch (*cur_token)\n                 {\n                     case 'G':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaEra, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaEra, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         reserve_size += repetitions <= 3 ? 2 : 13;\n                         break;\n+                    }\n                     case 'C':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaCenturyOfEra, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaCenturyOfEra, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Year range [1900, 2299]\n                         reserve_size += std::max(repetitions, 2);\n                         break;\n+                    }\n                     case 'Y':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaYearOfEra, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaYearOfEra, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Year range [1900, 2299]\n                         reserve_size += repetitions == 2 ? 2 : std::max(repetitions, 4);\n                         break;\n+                    }\n                     case 'x':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaWeekYear, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaWeekYear, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// weekyear range [1900, 2299]\n                         reserve_size += std::max(repetitions, 4);\n                         break;\n+                    }\n                     case 'w':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaWeekOfWeekYear, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaWeekOfWeekYear, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Week of weekyear range [1, 52]\n                         reserve_size += std::max(repetitions, 2);\n                         break;\n+                    }\n                     case 'e':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfWeek1Based, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfWeek1Based, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Day of week range [1, 7]\n                         reserve_size += std::max(repetitions, 1);\n                         break;\n+                    }\n                     case 'E':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfWeekText, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfWeekText, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Maximum length of short name is 3, maximum length of full name is 9.\n                         reserve_size += repetitions <= 3 ? 3 : 9;\n                         break;\n+                    }\n                     case 'y':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaYear, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaYear, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Year range [1900, 2299]\n                         reserve_size += repetitions == 2 ? 2 : std::max(repetitions, 4);\n                         break;\n+                    }\n                     case 'D':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfYear, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfYear, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Day of year range [1, 366]\n                         reserve_size += std::max(repetitions, 3);\n                         break;\n+                    }\n                     case 'M':\n+                    {\n                         if (repetitions <= 2)\n                         {\n-                            instructions.emplace_back(std::bind_front(&Instruction<T>::jodaMonthOfYear, repetitions));\n+                            Instruction<T> instruction;\n+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaMonthOfYear, repetitions));\n+                            instructions.push_back(std::move(instruction));\n                             /// Month of year range [1, 12]\n                             reserve_size += 2;\n                         }\n                         else\n                         {\n-                            instructions.emplace_back(std::bind_front(&Instruction<T>::jodaMonthOfYearText, repetitions));\n+                            Instruction<T> instruction;\n+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaMonthOfYearText, repetitions));\n+                            instructions.push_back(std::move(instruction));\n                             /// Maximum length of short name is 3, maximum length of full name is 9.\n                             reserve_size += repetitions <= 3 ? 3 : 9;\n                         }\n                         break;\n+                    }\n                     case 'd':\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfMonth, repetitions));\n+                    {\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfMonth, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Day of month range [1, 3]\n                         reserve_size += std::max(repetitions, 3);\n                         break;\n+                    }\n                     case 'a':\n                         /// Default half day of day is \"AM\"\n                         add_instruction(std::bind_front(&Instruction<T>::jodaHalfDayOfDay, repetitions), \"AM\");\n@@ -1341,29 +1616,41 @@ class FunctionFormatDateTimeImpl : public IFunction\n                         reserve_size += std::max(repetitions, 2);\n                         break;\n                     case 'S':\n+                    {\n                         /// Default fraction of second is 0\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaFractionOfSecond, repetitions));\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaFractionOfSecond, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// 'S' repetitions range [0, 9]\n                         reserve_size += repetitions <= 9 ? repetitions : 9;\n                         break;\n+                    }\n                     case 'z':\n+                    {\n                         if (repetitions <= 3)\n                             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Short name time zone is not yet supported\");\n \n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaTimezone, repetitions));\n+                        Instruction<T> instruction;\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaTimezone, repetitions));\n+                        instructions.push_back(std::move(instruction));\n                         /// Longest length of full name of time zone is 32.\n                         reserve_size += 32;\n                         break;\n+                    }\n                     case 'Z':\n                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"format is not supported for TIMEZONE_OFFSET_ID\");\n                     default:\n+                    {\n                         if (isalpha(*cur_token))\n                             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"format is not supported for {}\", String(cur_token, repetitions));\n \n+                        Instruction<T> instruction;\n                         std::string_view literal(cur_token, pos - cur_token);\n-                        instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));\n+                        instructions.push_back(std::move(instruction));\n                         reserve_size += pos - cur_token;\n                         break;\n+                    }\n                 }\n             }\n         }\n@@ -1392,10 +1679,10 @@ struct NameFromUnixTimeInJodaSyntax\n };\n \n \n-using FunctionFormatDateTime = FunctionFormatDateTimeImpl<NameFormatDateTime, FormatDateTimeTraits::SupportInteger::No, FormatDateTimeTraits::FormatSyntax::MySQL>;\n-using FunctionFromUnixTimestamp = FunctionFormatDateTimeImpl<NameFromUnixTime, FormatDateTimeTraits::SupportInteger::Yes, FormatDateTimeTraits::FormatSyntax::MySQL>;\n-using FunctionFormatDateTimeInJodaSyntax = FunctionFormatDateTimeImpl<NameFormatDateTimeInJodaSyntax, FormatDateTimeTraits::SupportInteger::No, FormatDateTimeTraits::FormatSyntax::Joda>;\n-using FunctionFromUnixTimestampInJodaSyntax = FunctionFormatDateTimeImpl<NameFromUnixTimeInJodaSyntax, FormatDateTimeTraits::SupportInteger::Yes, FormatDateTimeTraits::FormatSyntax::Joda>;\n+using FunctionFormatDateTime = FunctionFormatDateTimeImpl<NameFormatDateTime, SupportInteger::No, FormatSyntax::MySQL>;\n+using FunctionFromUnixTimestamp = FunctionFormatDateTimeImpl<NameFromUnixTime, SupportInteger::Yes, FormatSyntax::MySQL>;\n+using FunctionFormatDateTimeInJodaSyntax = FunctionFormatDateTimeImpl<NameFormatDateTimeInJodaSyntax, SupportInteger::No, FormatSyntax::Joda>;\n+using FunctionFromUnixTimestampInJodaSyntax = FunctionFormatDateTimeImpl<NameFromUnixTimeInJodaSyntax, SupportInteger::Yes, FormatSyntax::Joda>;\n \n }\n \ndiff --git a/src/Functions/parseDateTime.cpp b/src/Functions/parseDateTime.cpp\nindex 553e993a806a..ef95c5929578 100644\n--- a/src/Functions/parseDateTime.cpp\n+++ b/src/Functions/parseDateTime.cpp\n@@ -50,7 +50,7 @@ namespace\n     const std::unordered_map<String, std::pair<String, Int32>> monthMap{\n         {\"jan\", {\"uary\", 1}},\n         {\"feb\", {\"ruary\", 2}},\n-        {\"mar\", {\"rch\", 3}},\n+        {\"mar\", {\"ch\", 3}},\n         {\"apr\", {\"il\", 4}},\n         {\"may\", {\"\", 5}},\n         {\"jun\", {\"e\", 6}},\n@@ -103,16 +103,16 @@ namespace\n         bool is_year_of_era = false; /// If true, year is calculated from era and year of era, the latter cannot be zero or negative.\n         bool has_year = false; /// Whether year was explicitly specified.\n \n-        /// If is_clock_hour = true, is_hour_of_half_day = true, hour's range is [1, 12]\n-        /// If is_clock_hour = true, is_hour_of_half_day = false, hour's range is [1, 24]\n-        /// If is_clock_hour = false, is_hour_of_half_day = true, hour's range is [0, 11]\n-        /// If is_clock_hour = false, is_hour_of_half_day = false, hour's range is [0, 23]\n+        /// If hour_starts_at_1 = true, is_hour_of_half_day = true, hour's range is [1, 12]\n+        /// If hour_starts_at_1 = true, is_hour_of_half_day = false, hour's range is [1, 24]\n+        /// If hour_starts_at_1 = false, is_hour_of_half_day = true, hour's range is [0, 11]\n+        /// If hour_starts_at_1 = false, is_hour_of_half_day = false, hour's range is [0, 23]\n         Int32 hour = 0;\n         Int32 minute = 0; /// range [0, 59]\n         Int32 second = 0; /// range [0, 59]\n \n         bool is_am = true; /// If is_hour_of_half_day = true and is_am = false (i.e. pm) then add 12 hours to the result DateTime\n-        bool is_clock_hour = false; /// Whether the hour is clockhour\n+        bool hour_starts_at_1 = false; /// Whether the hour is clockhour\n         bool is_hour_of_half_day = false; /// Whether the hour is of half day\n \n         bool has_time_zone_offset = false; /// If true, time zone offset is explicitly specified.\n@@ -139,7 +139,7 @@ namespace\n             second = 0;\n \n             is_am = true;\n-            is_clock_hour = false;\n+            hour_starts_at_1 = false;\n             is_hour_of_half_day = false;\n \n             has_time_zone_offset = false;\n@@ -277,23 +277,23 @@ namespace\n                 throw Exception(ErrorCodes::CANNOT_PARSE_DATETIME, \"Unknown half day of day: {}\", text);\n         }\n \n-        void setHour(Int32 hour_, bool is_hour_of_half_day_ = false, bool is_clock_hour_ = false)\n+        void setHour(Int32 hour_, bool is_hour_of_half_day_ = false, bool hour_starts_at_1_ = false)\n         {\n             Int32 max_hour;\n             Int32 min_hour;\n             Int32 new_hour = hour_;\n-            if (!is_hour_of_half_day_ && !is_clock_hour_)\n+            if (!is_hour_of_half_day_ && !hour_starts_at_1_)\n             {\n                 max_hour = 23;\n                 min_hour = 0;\n             }\n-            else if (!is_hour_of_half_day_ && is_clock_hour_)\n+            else if (!is_hour_of_half_day_ && hour_starts_at_1_)\n             {\n                 max_hour = 24;\n                 min_hour = 1;\n                 new_hour = hour_ % 24;\n             }\n-            else if (is_hour_of_half_day_ && !is_clock_hour_)\n+            else if (is_hour_of_half_day_ && !hour_starts_at_1_)\n             {\n                 max_hour = 11;\n                 min_hour = 0;\n@@ -308,16 +308,16 @@ namespace\n             if (hour_ < min_hour || hour_ > max_hour)\n                 throw Exception(\n                     ErrorCodes::CANNOT_PARSE_DATETIME,\n-                    \"Value {} for hour must be in the range [{}, {}] if_hour_of_half_day={} and is_clock_hour={}\",\n+                    \"Value {} for hour must be in the range [{}, {}] if_hour_of_half_day={} and hour_starts_at_1={}\",\n                     hour,\n                     max_hour,\n                     min_hour,\n                     is_hour_of_half_day_,\n-                    is_clock_hour_);\n+                    hour_starts_at_1_);\n \n             hour = new_hour;\n             is_hour_of_half_day = is_hour_of_half_day_;\n-            is_clock_hour = is_clock_hour_;\n+            hour_starts_at_1 = hour_starts_at_1_;\n         }\n \n         void setMinute(Int32 minute_)\n@@ -920,7 +920,7 @@ namespace\n \n             static Pos mysqlDayOfWeekTextLong(Pos cur, Pos end, const String & fragment, DateTime & date)\n             {\n-                checkSpace(cur, end, 6, \"jodaDayOfWeekText requires size >= 6\", fragment);\n+                checkSpace(cur, end, 6, \"mysqlDayOfWeekTextLong requires size >= 6\", fragment);\n                 String text1(cur, 3);\n                 boost::to_lower(text1);\n                 auto it = dayOfWeekMap.find(text1);\n@@ -934,7 +934,7 @@ namespace\n                 cur += 3;\n \n                 size_t expected_remaining_size = it->second.first.size();\n-                checkSpace(cur, end, expected_remaining_size, \"jodaDayOfWeekText requires the second parg size >= \" + std::to_string(expected_remaining_size), fragment);\n+                checkSpace(cur, end, expected_remaining_size, \"mysqlDayOfWeekTextLong requires the second parg size >= \" + std::to_string(expected_remaining_size), fragment);\n                 String text2(cur, expected_remaining_size);\n                 boost::to_lower(text2);\n                 if (text2 != it->second.first)\ndiff --git a/src/Functions/widthBucket.cpp b/src/Functions/widthBucket.cpp\nindex a32fa159c2c2..e14ef90223d8 100644\n--- a/src/Functions/widthBucket.cpp\n+++ b/src/Functions/widthBucket.cpp\n@@ -11,6 +11,7 @@\n #include <Functions/IFunction.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/castColumn.h>\n+#include <Common/Concepts.h>\n #include <Common/Exception.h>\n #include <Common/NaNUtils.h>\n #include <Common/register_objects.h>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.python b/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\nindex 2706c0f5b122..3db80aef845f 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\n@@ -83,7 +83,7 @@ CAST(N as DateTime64(9, 'Europe/Minsk'))\n # CAST(N as DateTime64(12, 'Asia/Istanbul'))\n # DateTime64(18) will always fail due to zero precision, but it is Ok to test here:\n # CAST(N as DateTime64(18, 'Asia/Istanbul'))\n-formatDateTime(N, '%C %d %D %e %F %H %I %j %m %M %p %R %S %T %u %V %w %y %Y %%', 'Asia/Istanbul')\n+formatDateTime(N, '%C %d %D %e %F %H %I %j %m %i %p %R %S %T %u %V %w %y %Y %%', 'Asia/Istanbul')\n \"\"\".splitlines()\n \n # Expanded later to cartesian product of all arguments, using format string.\ndiff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\nindex 8a168ed0e9e9..62de3a149a75 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n@@ -353,7 +353,7 @@ SELECT CAST(N as DateTime64(9, \\'Europe/Minsk\\'))\n \"DateTime64(9, 'Europe/Minsk')\",\"2019-09-16 19:20:11.000000000\"\n \"DateTime64(9, 'Europe/Minsk')\",\"2019-09-16 19:20:11.234000000\"\n ------------------------------------------\n-SELECT formatDateTime(N, \\'%C %d %D %e %F %H %I %j %m %M %p %R %S %T %u %V %w %y %Y %%\\', \\'Asia/Istanbul\\')\n+SELECT formatDateTime(N, \\'%C %d %D %e %F %H %I %j %m %i %p %R %S %T %u %V %w %y %Y %%\\', \\'Asia/Istanbul\\')\n \"String\",\"20 16 09/16/19 16 2019-09-16 00 12 259 09 00 AM 00:00 00 00:00:00 1 38 1 19 2019 %\"\n \"String\",\"20 16 09/16/19 16 2019-09-16 19 07 259 09 20 PM 19:20 11 19:20:11 1 38 1 19 2019 %\"\n \"String\",\"20 16 09/16/19 16 2019-09-16 19 07 259 09 20 PM 19:20 11 19:20:11 1 38 1 19 2019 %\"\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime.reference b/tests/queries/0_stateless/02668_parse_datetime.reference\nindex afa3d0eb9627..85c85cd2001c 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime.reference\n+++ b/tests/queries/0_stateless/02668_parse_datetime.reference\n@@ -26,6 +26,15 @@ select parseDateTime('jun', '%b', 'UTC') = toDateTime('2000-06-01', 'UTC');\n select parseDateTime('JUN', '%b', 'UTC') = toDateTime('2000-06-01', 'UTC');\n 1\n select parseDateTime('abc', '%b'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('08', '%M', 'UTC') = toDateTime('1970-01-01 00:08:00', 'UTC');\n+1\n+select parseDateTime('59', '%M', 'UTC') = toDateTime('1970-01-01 00:59:00', 'UTC');\n+1\n+select parseDateTime('00/', '%M/', 'UTC') = toDateTime('1970-01-01 00:00:00', 'UTC');\n+1\n+select parseDateTime('60', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('-1', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('123456789', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n -- day of month\n select parseDateTime('07', '%d', 'UTC') = toDateTime('2000-01-07', 'UTC');\n 1\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime.sql b/tests/queries/0_stateless/02668_parse_datetime.sql\nindex 51c2fda8428d..848bf104fdb5 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime.sql\n+++ b/tests/queries/0_stateless/02668_parse_datetime.sql\n@@ -18,6 +18,12 @@ select parseDateTime('12345', '%c'); -- { serverError CANNOT_PARSE_DATETIME }\n select parseDateTime('jun', '%b', 'UTC') = toDateTime('2000-06-01', 'UTC');\n select parseDateTime('JUN', '%b', 'UTC') = toDateTime('2000-06-01', 'UTC');\n select parseDateTime('abc', '%b'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('08', '%M', 'UTC') = toDateTime('1970-01-01 00:08:00', 'UTC');\n+select parseDateTime('59', '%M', 'UTC') = toDateTime('1970-01-01 00:59:00', 'UTC');\n+select parseDateTime('00/', '%M/', 'UTC') = toDateTime('1970-01-01 00:00:00', 'UTC');\n+select parseDateTime('60', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('-1', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n+select parseDateTime('123456789', '%M', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n \n -- day of month\n select parseDateTime('07', '%d', 'UTC') = toDateTime('2000-01-07', 'UTC');\n",
  "problem_statement": "MSAN: use-of-uninitialized-value with formatDateTime\n**Describe the bug**\r\n\r\n[A link to the report](https://s3.amazonaws.com/clickhouse-test-reports/47196/8664a20a9e1bcca40616aba9fc7aff3d938a585c/fuzzer_astfuzzermsan/report.html)\r\n\r\n**How to reproduce**\r\n\r\nReproduced with MSAN build in master (3503b3aa10096697146ad6559278124ae0194fd9).\r\n\r\nOriginal reproducer:\r\n```\r\nSELECT formatDateTime(toDateTime('2018-01-02 22:33:44'), '%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W%W%W\\0W%W%W%W%W%W')\r\n```\r\n\r\nSimplified reproducer:\r\n```sql\r\nSELECT formatDateTime(toDateTime('2018-01-02 22:33:44'), '%W%W\\0')\r\n```\r\n\r\n**Error message and/or stacktrace**\r\nYou can find additional information in server logs.\r\n\r\n```\r\nUninitialized bytes in __interceptor_send at offset 1077 inside [0x7fb43873e000, 1165)\r\n==83966==WARNING: MemorySanitizer: use-of-uninitialized-value\r\n    #0 0x5a90b582 in Poco::Net::SocketImpl::sendBytes(void const*, int, int) build_msan/./base/poco/Net/src/SocketImpl.cpp:290:8\r\n    #1 0x5a9224e7 in Poco::Net::StreamSocketImpl::sendBytes(void const*, int, int) build_msan/./base/poco/Net/src/StreamSocketImpl.cpp:63:23\r\n    #2 0x4843c3cd in DB::WriteBufferFromPocoSocket::nextImpl() build_msan/./src/IO/WriteBufferFromPocoSocket.cpp:63:34\r\n    #3 0x4dbd74df in DB::WriteBuffer::next() build_msan/./src/IO/WriteBuffer.h:49:13\r\n    #4 0x4dbd74df in DB::TCPHandler::sendData(DB::Block const&) build_msan/./src/Server/TCPHandler.cpp:1876:37\r\n    #5 0x4dbcf2e8 in DB::TCPHandler::processOrdinaryQueryWithProcessors() build_msan/./src/Server/TCPHandler.cpp:842:21\r\n    #6 0x4dbae739 in DB::TCPHandler::runImpl() build_msan/./src/Server/TCPHandler.cpp:435:17\r\n    #7 0x4dbf6fae in DB::TCPHandler::run() build_msan/./src/Server/TCPHandler.cpp:1999:9\r\n    #8 0x5a92611d in Poco::Net::TCPServerConnection::start() build_msan/./base/poco/Net/src/TCPServerConnection.cpp:43:3\r\n    #9 0x5a9274cf in Poco::Net::TCPServerDispatcher::run() build_msan/./base/poco/Net/src/TCPServerDispatcher.cpp:115:20\r\n    #10 0x5b0bb912 in Poco::PooledThread::run() build_msan/./base/poco/Foundation/src/ThreadPool.cpp:188:14\r\n    #11 0x5b0b6d41 in Poco::(anonymous namespace)::RunnableHolder::run() build_msan/./base/poco/Foundation/src/Thread.cpp:45:11\r\n    #12 0x5b0b2928 in Poco::ThreadImpl::runnableEntry(void*) build_msan/./base/poco/Foundation/src/Thread_POSIX.cpp:335:27\r\n    #13 0x7fb6c70ebbb4 in start_thread /usr/src/debug/glibc/glibc/nptl/pthread_create.c:444:8\r\n    #14 0x7fb6c716dd8f in clone3 /usr/src/debug/glibc/glibc/misc/../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\r\n\r\n  Uninitialized value was created by a heap allocation\r\n    #0 0xce6cade in malloc (/mnt/ch/ClickHouse/build_msan/programs/clickhouse+0xce6cade) (BuildId: 19ce245338f9a39888754ad6e49bb9df85146cfc)\r\n    #1 0x2a4fd167 in Allocator<false, false>::allocNoTrack(unsigned long, unsigned long) build_msan/./src/Common/Allocator.h:237:27\r\n    #2 0x2a4fcb35 in Allocator<false, false>::alloc(unsigned long, unsigned long) build_msan/./src/Common/Allocator.h:103:16\r\n    #3 0x2a732ce6 in DB::Memory<Allocator<false, false>>::alloc(unsigned long) build_msan/./src/IO/BufferWithOwnMemory.h:130:49\r\n    #4 0x4843dcec in DB::Memory<Allocator<false, false>>::Memory(unsigned long, unsigned long) build_msan/./src/IO/BufferWithOwnMemory.h:49:9\r\n    #5 0x4843dcec in DB::BufferWithOwnMemory<DB::WriteBuffer>::BufferWithOwnMemory(unsigned long, char*, unsigned long) build_msan/./src/IO/BufferWithOwnMemory.h:157:29\r\n    #6 0x4843dcec in DB::WriteBufferFromPocoSocket::WriteBufferFromPocoSocket(Poco::Net::Socket&, unsigned long) build_msan/./src/IO/WriteBufferFromPocoSocket.cpp:91:7\r\n    #7 0x483d6d13 in DB::WriteBufferFromPocoSocket* std::__1::construct_at[abi:v15000]<DB::WriteBufferFromPocoSocket, Poco::Net::StreamSocket&, DB::WriteBufferFromPocoSocket*>(DB::WriteBufferFromPocoSocket*, Poco::Net::StreamSocket&) build_msan/./contrib/llvm-project/libcxx/include/__memory/construct_at.h:35:48\r\n    #8 0x483d6d13 in void std::__1::allocator_traits<std::__1::allocator<DB::WriteBufferFromPocoSocket>>::construct[abi:v15000]<DB::WriteBufferFromPocoSocket, Poco::Net::StreamSocket&, void, void>(std::__1::allocator<DB::WriteBufferFromPocoSocket>&, DB::WriteBufferFromPocoSocket*, Poco::Net::StreamSocket&) build_msan/./contrib/llvm-project/libcxx/include/__memory/allocator_traits.h:298:9\r\n    #9 0x483d6d13 in std::__1::__shared_ptr_emplace<DB::WriteBufferFromPocoSocket, std::__1::allocator<DB::WriteBufferFromPocoSocket>>::__shared_ptr_emplace[abi:v15000]<Poco::Net::StreamSocket&>(std::__1::allocator<DB::WriteBufferFromPocoSocket>, Poco::Net::StreamSocket&) build_msan/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:292:9\r\n    #10 0x483d6d13 in std::__1::shared_ptr<DB::WriteBufferFromPocoSocket> std::__1::allocate_shared[abi:v15000]<DB::WriteBufferFromPocoSocket, std::__1::allocator<DB::WriteBufferFromPocoSocket>, Poco::Net::StreamSocket&, void>(std::__1::allocator<DB::WriteBufferFromPocoSocket> const&, Poco::Net::StreamSocket&) build_msan/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:953:55\r\n    #11 0x483d6d13 in std::__1::shared_ptr<DB::WriteBufferFromPocoSocket> std::__1::make_shared[abi:v15000]<DB::WriteBufferFromPocoSocket, Poco::Net::StreamSocket&, void>(Poco::Net::StreamSocket&) build_msan/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:962:12\r\n    #12 0x4dbaa65a in DB::TCPHandler::runImpl() build_msan/./src/Server/TCPHandler.cpp:165:11\r\n    #13 0x4dbf6fae in DB::TCPHandler::run() build_msan/./src/Server/TCPHandler.cpp:1999:9\r\n    #14 0x5a92611d in Poco::Net::TCPServerConnection::start() build_msan/./base/poco/Net/src/TCPServerConnection.cpp:43:3\r\n    #15 0x5a9274cf in Poco::Net::TCPServerDispatcher::run() build_msan/./base/poco/Net/src/TCPServerDispatcher.cpp:115:20\r\n    #16 0x5b0bb912 in Poco::PooledThread::run() build_msan/./base/poco/Foundation/src/ThreadPool.cpp:188:14\r\n    #17 0x5b0b6d41 in Poco::(anonymous namespace)::RunnableHolder::run() build_msan/./base/poco/Foundation/src/Thread.cpp:45:11\r\n    #18 0x5b0b2928 in Poco::ThreadImpl::runnableEntry(void*) build_msan/./base/poco/Foundation/src/Thread_POSIX.cpp:335:27\r\n    #19 0x7fb6c70ebbb4 in start_thread /usr/src/debug/glibc/glibc/nptl/pthread_create.c:444:8\r\n\r\nSUMMARY: MemorySanitizer: use-of-uninitialized-value build_msan/./base/poco/Net/src/SocketImpl.cpp:290:8 in Poco::Net::SocketImpl::sendBytes(void const*, int, int)\r\nExiting\r\n```\r\n\r\nSeems like the problem might be introduced with the '\\0'.\n",
  "hints_text": "`formatDateTime()` with variable-length formatter like `%W` (Monday - Sunday) are currently broken (memory corruption). Fixing this requires some bigger infrastructure changes in `formatDateTime()`. These are introduced with #47246 which will fix this issue as a side effect.\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/1d63945604aa91cdf781937aa191bdc6deb74e62/fuzzer_astfuzzermsan/report.html\nDuplicate\n> Duplicate\r\n\r\nDuplicate of what? https://github.com/ClickHouse/ClickHouse/issues/48343 was closed as duplicate of this issue",
  "created_at": "2023-04-06T08:05:03Z"
}