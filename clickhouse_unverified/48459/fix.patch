diff --git a/src/Common/Concepts.h b/src/Common/Concepts.h
index b1bf591024d1..927f42aa4bea 100644
--- a/src/Common/Concepts.h
+++ b/src/Common/Concepts.h
@@ -5,6 +5,10 @@
 namespace DB
 {
 
+template<typename T, typename ... U>
+concept is_any_of = (std::same_as<T, U> || ...);
+
+
 template <typename... T>
 concept OptionalArgument = requires(T &&...)
 {
diff --git a/src/Common/typeid_cast.h b/src/Common/typeid_cast.h
index 1568d3809389..baee3aaf6327 100644
--- a/src/Common/typeid_cast.h
+++ b/src/Common/typeid_cast.h
@@ -18,9 +18,6 @@ namespace DB
     }
 }
 
-template<typename T, typename ... U>
-concept is_any_of = (std::same_as<T, U> || ...);
-
 
 /** Checks type by comparing typeid.
   * The exact match of the type is checked. That is, cast to the ancestor will be unsuccessful.
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index f832bf404a8b..28002d34acc4 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -41,6 +41,7 @@
 #include <Columns/ColumnsCommon.h>
 #include <Columns/ColumnStringHelpers.h>
 #include <Common/assert_cast.h>
+#include <Common/Concepts.h>
 #include <Common/quoteString.h>
 #include <Common/Exception.h>
 #include <Core/AccurateComparison.h>
diff --git a/src/Functions/formatDateTime.cpp b/src/Functions/formatDateTime.cpp
index bbb4c3ba5b01..5ec0212c56d5 100644
--- a/src/Functions/formatDateTime.cpp
+++ b/src/Functions/formatDateTime.cpp
@@ -17,6 +17,7 @@
 
 #include <IO/WriteHelpers.h>
 
+#include <Common/Concepts.h>
 #include <Common/DateLUTImpl.h>
 #include <base/find_symbols.h>
 #include <Core/DecimalFunctions.h>
@@ -38,22 +39,19 @@ namespace ErrorCodes
 
 namespace
 {
+using Pos = const char *;
 
-struct FormatDateTimeTraits
+enum class SupportInteger
 {
-    enum class SupportInteger
-    {
-        Yes,
-        No
-    };
-
-    enum class FormatSyntax
-    {
-        MySQL,
-        Joda
-    };
+    Yes,
+    No
 };
 
+enum class FormatSyntax
+{
+    MySQL,
+    Joda
+};
 
 template <typename DataType> struct InstructionValueTypeMap {};
 template <> struct InstructionValueTypeMap<DataTypeInt8>       { using InstructionValueType = UInt32; };
@@ -85,11 +83,9 @@ constexpr std::string_view weekdaysFull[] = {"Sunday", "Monday", "Tuesday", "Wed
 
 constexpr std::string_view weekdaysShort[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
 
-constexpr std::string_view monthsFull[]
-    = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
+constexpr std::string_view monthsFull[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
 
-constexpr std::string_view monthsShort[]
-    = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+constexpr std::string_view monthsShort[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
 /** formatDateTime(time, 'format')
   * Performs formatting of time, according to provided format.
@@ -115,13 +111,13 @@ constexpr std::string_view monthsShort[]
   *
   * Performance on Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz:
   *
-  * WITH formatDateTime(now() + number, '%H:%M:%S') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x);
+  * WITH formatDateTime(now() + number, '%H:%i:%S') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x);
   * - 97 million rows per second per core;
   *
   * WITH formatDateTime(toDateTime('2018-01-01 00:00:00') + number, '%F %T') AS x SELECT count() FROM system.numbers WHERE NOT ignore(x)
   * - 71 million rows per second per core;
   *
-  * select count() from (select formatDateTime(t, '%m/%d/%Y %H:%M:%S') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));
+  * select count() from (select formatDateTime(t, '%m/%d/%Y %H:%i:%S') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));
   * - 53 million rows per second per core;
   *
   * select count() from (select formatDateTime(t, 'Hello %Y World') from (select toDateTime('2018-01-01 00:00:00')+number as t from numbers(100000000)));
@@ -129,7 +125,7 @@ constexpr std::string_view monthsShort[]
   *
   * PS. We can make this function to return FixedString. Currently it returns String.
   */
-template <typename Name, FormatDateTimeTraits::SupportInteger support_integer, FormatDateTimeTraits::FormatSyntax format_syntax>
+template <typename Name, SupportInteger support_integer, FormatSyntax format_syntax>
 class FunctionFormatDateTimeImpl : public IFunction
 {
 private:
@@ -152,26 +148,34 @@ class FunctionFormatDateTimeImpl : public IFunction
     class Instruction
     {
     public:
-        /// Using std::function will cause performance degradation in MySQL format by 0.45x.
-        /// But std::function is required for Joda format to capture extra variables.
-        /// This is the reason why we use raw function pointer in MySQL format and std::function
-        /// in Joda format.
-        using Func = std::conditional_t<
-            format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL,
-            size_t (*)(char *, Time, UInt64, UInt32, const DateLUTImpl &),
-            std::function<size_t(char *, Time, UInt64, UInt32, const DateLUTImpl &)>>;
+        /// Joda format generally requires capturing extra variables (i.e. holding state) which is more convenient with
+        /// std::function and std::bind. Unfortunately, std::function causes a performance degradation by 0.45x compared to raw function
+        /// pointers. For MySQL format, we generally prefer raw function pointers. Because of the special case that not all formatters are
+        /// fixed-width formatters (see mysqlLiteral instruction), we still need to be able to store state. For that reason, we use member
+        /// function pointers instead of static function pointers.
+        using FuncMysql = size_t (Instruction<Time>::*)(char *, Time, UInt64, UInt32, const DateLUTImpl &);
+        FuncMysql func_mysql = nullptr;
 
-        Func func;
+        using FuncJoda = std::function<size_t(char *, Time, UInt64, UInt32, const DateLUTImpl &)>;
+        FuncJoda func_joda = nullptr;
 
         /// extra_shift is only used in MySQL format syntax. It is always 0 in Joda format syntax.
         size_t extra_shift = 0;
 
-        /// Instruction for appending date/time related number in specified format.
-        explicit Instruction(Func && func_) : func(std::move(func_)) {}
+        // Holds literal characters that will be copied into the output. Used by the mysqlLiteral instruction.
+        String literal;
+
+        Instruction() = default;
+
+        void setMysqlFunc(FuncMysql && func) { func_mysql = std::move(func); }
+        void setJodaFunc(FuncJoda && func) { func_joda = std::move(func); }
+        void setLiteral(std::string_view literal_) { literal = literal_; }
 
         void perform(char *& dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
-            auto shift = func(dest, source, fractional_second, scale, timezone);
+            size_t shift = func_mysql
+                           ? std::invoke(func_mysql, this, dest, source, fractional_second, scale, timezone)
+                           : std::invoke(func_joda, dest, source, fractional_second, scale, timezone);
             dest += shift + extra_shift;
         }
 
@@ -257,21 +261,30 @@ class FunctionFormatDateTimeImpl : public IFunction
             return pos;
         }
     public:
-        static size_t mysqlNoop(char *, Time, UInt64, UInt32, const DateLUTImpl &) { return 0; }
+        size_t mysqlNoop(char *, Time, UInt64, UInt32, const DateLUTImpl &)
+        {
+            return 0;
+        }
 
-        static size_t mysqlCentury(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlLiteral(char * dest, Time, UInt64, UInt32, const DateLUTImpl &)
+        {
+            memcpy(dest, literal.data(), literal.size());
+            return literal.size();
+        }
+
+        size_t mysqlCentury(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto year = ToYearImpl::execute(source, timezone);
             auto century = year / 100;
             return writeNumber2(dest, century);
         }
 
-        static size_t mysqlDayOfMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlDayOfMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToDayOfMonthImpl::execute(source, timezone));
         }
 
-        static size_t mysqlAmericanDate(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlAmericanDate(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             writeNumber2(dest, ToMonthImpl::execute(source, timezone));
             writeNumber2(dest + 3, ToDayOfMonthImpl::execute(source, timezone));
@@ -279,7 +292,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 8;
         }
 
-        static size_t mysqlDayOfMonthSpacePadded(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlDayOfMonthSpacePadded(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto day = ToDayOfMonthImpl::execute(source, timezone);
             if (day < 10)
@@ -289,7 +302,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 2;
         }
 
-        static size_t mysqlISO8601Date(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        size_t mysqlISO8601Date(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             writeNumber4(dest, ToYearImpl::execute(source, timezone));
             writeNumber2(dest + 5, ToMonthImpl::execute(source, timezone));
@@ -297,12 +310,12 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 10;
         }
 
-        static size_t mysqlDayOfYear(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlDayOfYear(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber3(dest, ToDayOfYearImpl::execute(source, timezone));
         }
 
-        static size_t mysqlMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlMonth(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToMonthImpl::execute(source, timezone));
         }
@@ -315,17 +328,17 @@ class FunctionFormatDateTimeImpl : public IFunction
             return str_view.size();
         }
 
-        static size_t mysqlMonthOfYearTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
+        size_t mysqlMonthOfYearTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
             return monthOfYearText(dest, source, true, fractional_second, scale, timezone);
         }
 
-        static size_t mysqlMonthOfYearTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
+        size_t mysqlMonthOfYearTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
             return monthOfYearText(dest, source, false, fractional_second, scale, timezone);
         }
 
-        static size_t mysqlDayOfWeek(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlDayOfWeek(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             *dest = '0' + ToDayOfWeekImpl::execute(source, 0, timezone);
             return 1;
@@ -342,65 +355,65 @@ class FunctionFormatDateTimeImpl : public IFunction
             return str_view.size();
         }
 
-        static size_t mysqlDayOfWeekTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
+        size_t mysqlDayOfWeekTextShort(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
             return dayOfWeekText(dest, source, true, fractional_second, scale, timezone);
         }
 
-        static size_t mysqlDayOfWeekTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
+        size_t mysqlDayOfWeekTextLong(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
             return dayOfWeekText(dest, source, false, fractional_second, scale, timezone);
         }
 
-        static size_t mysqlDayOfWeek0To6(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlDayOfWeek0To6(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto day = ToDayOfWeekImpl::execute(source, 0, timezone);
             *dest = '0' + (day == 7 ? 0 : day);
             return 1;
         }
 
-        static size_t mysqlISO8601Week(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        size_t mysqlISO8601Week(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToISOWeekImpl::execute(source, timezone));
         }
 
-        static size_t mysqlISO8601Year2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        size_t mysqlISO8601Year2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToISOYearImpl::execute(source, timezone) % 100);
         }
 
-        static size_t mysqlISO8601Year4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        size_t mysqlISO8601Year4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber4(dest, ToISOYearImpl::execute(source, timezone));
         }
 
-        static size_t mysqlYear2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlYear2(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToYearImpl::execute(source, timezone) % 100);
         }
 
-        static size_t mysqlYear4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlYear4(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber4(dest, ToYearImpl::execute(source, timezone));
         }
 
-        static size_t mysqlHour24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlHour24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToHourImpl::execute(source, timezone));
         }
 
-        static size_t mysqlHour12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlHour12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto x = ToHourImpl::execute(source, timezone);
             return writeNumber2(dest, x == 0 ? 12 : (x > 12 ? x - 12 : x));
         }
 
-        static size_t mysqlMinute(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlMinute(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToMinuteImpl::execute(source, timezone));
         }
 
-        static size_t mysqlAMPM(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        static size_t AMPM(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
         {
             auto hour = ToHourImpl::execute(source, timezone);
             dest[0] = hour >= 12 ? 'P' : 'A';
@@ -408,14 +421,19 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 2;
         }
 
-        static size_t mysqlHHMM24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlAMPM(char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
+        {
+            return AMPM(dest, source, fractional_second, scale, timezone);
+        }
+
+        size_t mysqlHHMM24(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             writeNumber2(dest, ToHourImpl::execute(source, timezone));
             writeNumber2(dest + 3, ToMinuteImpl::execute(source, timezone));
             return 5;
         }
 
-        static size_t mysqlHHMM12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlHHMM12(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto hour = ToHourImpl::execute(source, timezone);
             writeNumber2(dest, hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour));
@@ -425,13 +443,12 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 8;
         }
 
-        static size_t mysqlSecond(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlSecond(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             return writeNumber2(dest, ToSecondImpl::execute(source, timezone));
         }
 
-        static size_t
-        mysqlFractionalSecond(char * dest, Time /*source*/, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & /*timezone*/)
+        size_t mysqlFractionalSecond(char * dest, Time /*source*/, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & /*timezone*/)
         {
             if (scale == 0)
                 scale = 1;
@@ -444,7 +461,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             return scale;
         }
 
-        static size_t mysqlISO8601Time(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
+        size_t mysqlISO8601Time(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone) // NOLINT
         {
             writeNumber2(dest, ToHourImpl::execute(source, timezone));
             writeNumber2(dest + 3, ToMinuteImpl::execute(source, timezone));
@@ -452,7 +469,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 8;
         }
 
-        static size_t mysqlTimezoneOffset(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlTimezoneOffset(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             auto offset = TimezoneOffsetImpl::execute(source, timezone);
             if (offset < 0)
@@ -466,7 +483,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             return 5;
         }
 
-        static size_t mysqlQuarter(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
+        size_t mysqlQuarter(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
         {
             *dest = '0' + ToQuarterImpl::execute(source, timezone);
             return 1;
@@ -575,7 +592,7 @@ class FunctionFormatDateTimeImpl : public IFunction
         static size_t jodaHalfDayOfDay(
             size_t /*min_represent_digits*/, char * dest, Time source, UInt64 fractional_second, UInt32 scale, const DateLUTImpl & timezone)
         {
-            return mysqlAMPM(dest, source, fractional_second, scale, timezone);
+            return AMPM(dest, source, fractional_second, scale, timezone);
         }
 
         static size_t jodaHourOfHalfDay(size_t min_represent_digits, char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)
@@ -651,6 +668,36 @@ class FunctionFormatDateTimeImpl : public IFunction
         }
     };
 
+    [[noreturn]] static void throwLastCharacterIsPercentException()
+    {
+        throw Exception(ErrorCodes::BAD_ARGUMENTS, "'%' must not be the last character in the format string, use '%%' instead");
+    }
+
+    static bool containsOnlyFixedWidthMySQLFormatters(std::string_view format)
+    {
+        static constexpr std::array variable_width_formatter = {'W'};
+
+        for (size_t i = 0; i < format.size(); ++i)
+        {
+            switch (format[i])
+            {
+                case '%':
+                    if (i + 1 >= format.size())
+                        throwLastCharacterIsPercentException();
+                    if (std::any_of(
+                            variable_width_formatter.begin(), variable_width_formatter.end(),
+                            [&](char c){ return c == format[i + 1]; }))
+                        return false;
+                    i += 1;
+                    continue;
+                default:
+                    break;
+            }
+        }
+
+        return true;
+    }
+
 public:
     static constexpr auto name = Name::name;
 
@@ -672,7 +719,7 @@ class FunctionFormatDateTimeImpl : public IFunction
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if constexpr (support_integer == FormatDateTimeTraits::SupportInteger::Yes)
+        if constexpr (support_integer == SupportInteger::Yes)
         {
             if (arguments.size() != 1 && arguments.size() != 2 && arguments.size() != 3)
                 throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
@@ -718,7 +765,7 @@ class FunctionFormatDateTimeImpl : public IFunction
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, [[maybe_unused]] size_t input_rows_count) const override
     {
         ColumnPtr res;
-        if constexpr (support_integer == FormatDateTimeTraits::SupportInteger::Yes)
+        if constexpr (support_integer == SupportInteger::Yes)
         {
             if (arguments.size() == 1)
             {
@@ -790,10 +837,27 @@ class FunctionFormatDateTimeImpl : public IFunction
         if constexpr (std::is_same_v<DataType, DataTypeDateTime64>)
             scale = times->getScale();
 
+        /// For MySQL, we support two modes of execution:
+        ///
+        /// - All formatters in the format string are fixed-width. As a result, all output rows will have the same width and structure. We
+        ///   take advantage of this and
+        ///     1. create a "template" with placeholders from the format string,
+        ///     2. allocate a result column large enough to store the template on each row,
+        ///     3. copy the template into each result row,
+        ///     4. run instructions which replace the formatter placeholders. All other parts of the template (e.g. whitespaces) are already
+        ///        as desired and instructions skip over them (see 'extra_shift' in the formatters).
+        ///
+        /// - The format string contains at least one variable-width formatter. Output rows will potentially be of different size.
+        ///   Steps 1. and 2. are performed as above (the result column is allocated based on a worst-case size estimation). The result
+        ///   column rows are NOT populated with the template and left uninitialized. We run the normal instructions for formatters AND
+        ///   instructions that copy literal characters before/between/after formatters. As a result, each byte of each result row is
+        ///   written which is obviously slow.
+        bool mysql_with_only_fixed_length_formatters = (format_syntax == FormatSyntax::MySQL) ? containsOnlyFixedWidthMySQLFormatters(format) : false;
+
         using T = typename InstructionValueTypeMap<DataType>::InstructionValueType;
         std::vector<Instruction<T>> instructions;
         String out_template;
-        auto result_size = parseFormat(format, instructions, scale, out_template);
+        size_t out_template_size = parseFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);
 
         const DateLUTImpl * time_zone_tmp = nullptr;
         if (castType(arguments[0].type.get(), [&]([[maybe_unused]] const auto & type) { return true; }))
@@ -807,36 +871,39 @@ class FunctionFormatDateTimeImpl : public IFunction
         const auto & vec = times->getData();
 
         auto col_res = ColumnString::create();
-        auto & dst_data = col_res->getChars();
-        auto & dst_offsets = col_res->getOffsets();
-        dst_data.resize(vec.size() * (result_size + 1));
-        dst_offsets.resize(vec.size());
+        auto & res_data = col_res->getChars();
+        auto & res_offsets = col_res->getOffsets();
+        res_data.resize(vec.size() * (out_template_size + 1));
+        res_offsets.resize(vec.size());
 
-        if constexpr (format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL)
+        if constexpr (format_syntax == FormatSyntax::MySQL)
         {
-            /// Fill result with literals.
+            if (mysql_with_only_fixed_length_formatters)
             {
-                UInt8 * begin = dst_data.data();
-                UInt8 * end = begin + dst_data.size();
-                UInt8 * pos = begin;
-
-                if (pos < end)
+                /// Fill result with template.
                 {
-                    memcpy(pos, out_template.data(), result_size + 1); /// With zero terminator.
-                    pos += result_size + 1;
-                }
+                    const UInt8 * const begin = res_data.data();
+                    const UInt8 * const end = res_data.data() + res_data.size();
+                    UInt8 * pos = res_data.data();
 
-                /// Fill by copying exponential growing ranges.
-                while (pos < end)
-                {
-                    size_t bytes_to_copy = std::min(pos - begin, end - pos);
-                    memcpy(pos, begin, bytes_to_copy);
-                    pos += bytes_to_copy;
+                    if (pos < end)
+                    {
+                        memcpy(pos, out_template.data(), out_template_size + 1); /// With zero terminator. mystring[mystring.size()] = '\0' is guaranteed since C++11.
+                        pos += out_template_size + 1;
+                    }
+
+                    /// Copy exponentially growing ranges.
+                    while (pos < end)
+                    {
+                        size_t bytes_to_copy = std::min(pos - begin, end - pos);
+                        memcpy(pos, begin, bytes_to_copy);
+                        pos += bytes_to_copy;
+                    }
                 }
             }
         }
 
-        auto * begin = reinterpret_cast<char *>(dst_data.data());
+        auto * begin = reinterpret_cast<char *>(res_data.data());
         auto * pos = begin;
         for (size_t i = 0; i < vec.size(); ++i)
         {
@@ -844,9 +911,7 @@ class FunctionFormatDateTimeImpl : public IFunction
             {
                 const auto c = DecimalUtils::split(vec[i], scale);
                 for (auto & instruction : instructions)
-                {
                     instruction.perform(pos, static_cast<Int64>(c.whole), c.fractional, scale, time_zone);
-                }
             }
             else
             {
@@ -855,289 +920,444 @@ class FunctionFormatDateTimeImpl : public IFunction
             }
             *pos++ = '\0';
 
-            dst_offsets[i] = pos - begin;
+            res_offsets[i] = pos - begin;
         }
 
-        dst_data.resize(pos - begin);
+        res_data.resize(pos - begin);
         return col_res;
     }
 
     template <typename T>
-    size_t parseFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, String & out_template) const
+    size_t parseFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, bool mysql_with_only_fixed_length_formatters, String & out_template) const
     {
-        static_assert(
-            format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL || format_syntax == FormatDateTimeTraits::FormatSyntax::Joda,
-            "format syntax must be one of MySQL or Joda");
+        static_assert(format_syntax == FormatSyntax::MySQL || format_syntax == FormatSyntax::Joda);
 
-        if constexpr (format_syntax == FormatDateTimeTraits::FormatSyntax::MySQL)
-            return parseMySQLFormat(format, instructions, scale, out_template);
+        if constexpr (format_syntax == FormatSyntax::MySQL)
+            return parseMySQLFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);
         else
-            return parseJodaFormat(format, instructions, scale, out_template);
+            return parseJodaFormat(format, instructions, scale, mysql_with_only_fixed_length_formatters, out_template);
     }
 
     template <typename T>
-    size_t parseMySQLFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, String & out_template) const
+    size_t parseMySQLFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32 scale, bool mysql_with_only_fixed_length_formatters, String & out_template) const
     {
         auto add_extra_shift = [&](size_t amount)
         {
             if (instructions.empty())
-                instructions.emplace_back(&Instruction<T>::mysqlNoop);
+            {
+                Instruction<T> instruction;
+                instruction.setMysqlFunc(&Instruction<T>::mysqlNoop);
+                instructions.push_back(std::move(instruction));
+            }
             instructions.back().extra_shift += amount;
         };
 
-        auto add_instruction_or_extra_shift = [&](auto * func [[maybe_unused]], size_t amount [[maybe_unused]])
+        auto add_literal_instruction = [&](std::string_view literal)
         {
-            if constexpr (std::is_same_v<T, UInt32> || std::is_same_v<T, Int64>)
-                instructions.emplace_back(std::move(func));
-            else
+            Instruction<T> instruction;
+            instruction.setMysqlFunc(&Instruction<T>::mysqlLiteral);
+            instruction.setLiteral(literal);
+            instructions.push_back(std::move(instruction));
+        };
+
+        auto add_extra_shift_or_literal_instruction = [&](size_t amount, std::string_view literal)
+        {
+            if (mysql_with_only_fixed_length_formatters)
                 add_extra_shift(amount);
+            else
+                add_literal_instruction(literal);
         };
 
-        const char * pos = format.data();
-        const char * const end = format.data() + format.size();
+        auto add_time_instruction = [&]([[maybe_unused]] typename Instruction<T>::FuncMysql && func, [[maybe_unused]] size_t amount, [[maybe_unused]] std::string_view literal)
+        {
+            /// DateTime/DateTime64 --> insert instruction
+            /// Other types cannot provide the requested data --> write out template
+            if constexpr (is_any_of<T, UInt32, Int64>)
+            {
+                Instruction<T> instruction;
+                instruction.setMysqlFunc(std::move(func));
+                instructions.push_back(std::move(instruction));
+            }
+            else
+                add_extra_shift_or_literal_instruction(amount, literal);
+        };
+
+        Pos pos = format.data();
+        Pos const end = format.data() + format.size();
 
         while (true)
         {
-            const char * percent_pos = find_first_symbols<'%'>(pos, end);
+            Pos const percent_pos = find_first_symbols<'%'>(pos, end);
 
             if (percent_pos < end)
             {
                 if (pos < percent_pos)
                 {
-                    add_extra_shift(percent_pos - pos);
+                    /// Handle characters before next %
+                    add_extra_shift_or_literal_instruction(percent_pos - pos, std::string_view(pos, percent_pos - pos));
                     out_template += String(pos, percent_pos - pos);
                 }
 
                 pos = percent_pos + 1;
                 if (pos >= end)
-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Sign '%' is the last in format, if you need it, use '%%'");
+                    throwLastCharacterIsPercentException();
 
                 switch (*pos)
                 {
-                    // Abbreviated weekday [Mon...Sun]
+                    // Abbreviated weekday [Mon-Sun]
                     case 'a':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeekTextShort);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeekTextShort);
+                        instructions.push_back(std::move(instruction));
                         out_template += "Mon";
                         break;
+                    }
 
-                    // Abbreviated month [Jan...Dec]
+                    // Abbreviated month [Jan-Dec]
                     case 'b':
-                        instructions.emplace_back(&Instruction<T>::mysqlMonthOfYearTextShort);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonthOfYearTextShort);
+                        instructions.push_back(std::move(instruction));
                         out_template += "Jan";
                         break;
+                    }
 
                     // Month as a integer number (01-12)
                     case 'c':
-                        instructions.emplace_back(&Instruction<T>::mysqlMonth);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonth);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // Year, divided by 100, zero-padded
                     case 'C':
-                        instructions.emplace_back(&Instruction<T>::mysqlCentury);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlCentury);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // Day of month, zero-padded (01-31)
                     case 'd':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfMonth);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfMonth);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // Short MM/DD/YY date, equivalent to %m/%d/%y
                     case 'D':
-                        instructions.emplace_back(&Instruction<T>::mysqlAmericanDate);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlAmericanDate);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00/00/00";
                         break;
+                    }
 
                     // Day of month, space-padded ( 1-31)  23
                     case 'e':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfMonthSpacePadded);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfMonthSpacePadded);
+                        instructions.push_back(std::move(std::move(instruction)));
                         out_template += " 0";
                         break;
+                    }
 
                     // Fractional seconds
                     case 'f':
                     {
                         /// If the time data type has no fractional part, then we print '0' as the fractional part.
-                        instructions.emplace_back(&Instruction<T>::mysqlFractionalSecond);
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlFractionalSecond);
+                        instructions.push_back(std::move(instruction));
                         out_template += String(std::max<UInt32>(1, scale), '0');
                         break;
                     }
 
                     // Short YYYY-MM-DD date, equivalent to %Y-%m-%d   2001-08-23
                     case 'F':
-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Date);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Date);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0000-00-00";
                         break;
+                    }
 
                     // Last two digits of year of ISO 8601 week number (see %G)
                     case 'g':
-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Year2);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Year2);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // Year of ISO 8601 week number (see %V)
                     case 'G':
-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Year4);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Year4);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0000";
                         break;
+                    }
 
                     // Day of the year (001-366)   235
                     case 'j':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfYear);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfYear);
+                        instructions.push_back(std::move(instruction));
                         out_template += "000";
                         break;
+                    }
 
                     // Month as a integer number (01-12)
                     case 'm':
-                        instructions.emplace_back(&Instruction<T>::mysqlMonth);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlMonth);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // ISO 8601 weekday as number with Monday as 1 (1-7)
                     case 'u':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeek);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeek);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0";
                         break;
+                    }
 
                     // ISO 8601 week number (01-53)
                     case 'V':
-                        instructions.emplace_back(&Instruction<T>::mysqlISO8601Week);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlISO8601Week);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
-                    // Weekday as a integer number with Sunday as 0 (0-6)  4
+                    // Weekday as a decimal number with Sunday as 0 (0-6)  4
                     case 'w':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeek0To6);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeek0To6);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0";
                         break;
+                    }
 
-                    // Full weekday [Monday...Sunday]
+                    // Full weekday [Monday-Sunday]
                     case 'W':
-                        instructions.emplace_back(&Instruction<T>::mysqlDayOfWeekTextLong);
-                        out_template += "Monday";
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlDayOfWeekTextLong);
+                        instructions.push_back(std::move(instruction));
+                        out_template += "Wednesday"; /// longest possible weekday name
                         break;
+                    }
 
                     // Two digits year
                     case 'y':
-                        instructions.emplace_back(&Instruction<T>::mysqlYear2);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlYear2);
+                        instructions.push_back(std::move(instruction));
                         out_template += "00";
                         break;
+                    }
 
                     // Four digits year
                     case 'Y':
-                        instructions.emplace_back(&Instruction<T>::mysqlYear4);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlYear4);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0000";
                         break;
+                    }
 
                     // Quarter (1-4)
                     case 'Q':
-                        instructions.template emplace_back(&Instruction<T>::mysqlQuarter);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlQuarter);
+                        instructions.push_back(std::move(instruction));
                         out_template += "0";
                         break;
+                    }
 
                     // Offset from UTC timezone as +hhmm or -hhmm
                     case 'z':
-                        instructions.emplace_back(&Instruction<T>::mysqlTimezoneOffset);
+                    {
+                        Instruction<T> instruction;
+                        instruction.setMysqlFunc(&Instruction<T>::mysqlTimezoneOffset);
+                        instructions.push_back(std::move(instruction));
                         out_template += "+0000";
                         break;
+                    }
 
                     /// Time components. If the argument is Date, not a DateTime, then this components will have default value.
 
                     // Minute (00-59)
                     case 'M':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlMinute, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlMinute, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // AM or PM
                     case 'p':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlAMPM, 2);
-                        out_template += "AM";
+                    {
+                        static constexpr std::string_view val = "AM";
+                        add_time_instruction(&Instruction<T>::mysqlAMPM, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // 12-hour HH:MM time, equivalent to %h:%i %p 2:55 PM
                     case 'r':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHHMM12, 8);
-                        out_template += "12:00 AM";
+                    {
+                        static constexpr std::string_view val = "12:00 AM";
+                        add_time_instruction(&Instruction<T>::mysqlHHMM12, 8, val);
+                        out_template += val;
                         break;
+                    }
 
                     // 24-hour HH:MM time, equivalent to %H:%i 14:55
                     case 'R':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHHMM24, 5);
-                        out_template += "00:00";
+                    {
+                        static constexpr std::string_view val = "00:00";
+                        add_time_instruction(&Instruction<T>::mysqlHHMM24, 5, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Seconds
                     case 's':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlSecond, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlSecond, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Seconds
                     case 'S':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlSecond, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlSecond, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // ISO 8601 time format (HH:MM:SS), equivalent to %H:%i:%S 14:55:02
                     case 'T':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlISO8601Time, 8);
-                        out_template += "00:00:00";
+                    {
+                        static constexpr std::string_view val = "00:00:00";
+                        add_time_instruction(&Instruction<T>::mysqlISO8601Time, 8, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Hour in 12h format (01-12)
                     case 'h':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);
-                        out_template += "12";
+                    {
+                        static constexpr std::string_view val = "12";
+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Hour in 24h format (00-23)
                     case 'H':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour24, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlHour24, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Minute of hour range [0, 59]
                     case 'i':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlMinute, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlMinute, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Hour in 12h format (01-12)
                     case 'I':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);
-                        out_template += "12";
+                    {
+                        static constexpr std::string_view val = "12";
+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Hour in 24h format (00-23)
                     case 'k':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour24, 2);
-                        out_template += "00";
+                    {
+                        static constexpr std::string_view val = "00";
+                        add_time_instruction(&Instruction<T>::mysqlHour24, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Hour in 12h format (01-12)
                     case 'l':
-                        add_instruction_or_extra_shift(&Instruction<T>::mysqlHour12, 2);
-                        out_template += "12";
+                    {
+                        static constexpr std::string_view val = "12";
+                        add_time_instruction(&Instruction<T>::mysqlHour12, 2, val);
+                        out_template += val;
                         break;
+                    }
 
                     case 't':
-                        add_extra_shift(1);
-                        out_template += "\t";
+                    {
+                        static constexpr std::string_view val = "\t";
+                        add_extra_shift_or_literal_instruction(1, val);
+                        out_template += val;
                         break;
+                    }
 
                     case 'n':
-                        add_extra_shift(1);
-                        out_template += "
";
+                    {
+                        static constexpr std::string_view val = "
";
+                        add_extra_shift_or_literal_instruction(1, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Escaped literal characters.
                     case '%':
-                        add_extra_shift(1);
-                        out_template += "%";
+                    {
+                        static constexpr std::string_view val = "%";
+                        add_extra_shift_or_literal_instruction(1, val);
+                        out_template += val;
                         break;
+                    }
 
                     // Unimplemented
                     case 'U':
@@ -1148,7 +1368,6 @@ class FunctionFormatDateTimeImpl : public IFunction
                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "format is not supported for YEAR for week (Mon-Sun)");
                     case 'X':
                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "format is not supported for YEAR for week (Sun-Sat)");
-
                     default:
                         throw Exception(
                             ErrorCodes::BAD_ARGUMENTS,
@@ -1157,12 +1376,12 @@ class FunctionFormatDateTimeImpl : public IFunction
                             *pos,
                             getName());
                 }
-
                 ++pos;
             }
             else
             {
-                add_extra_shift(end - pos);
+                /// Handle characters after last %
+                add_extra_shift_or_literal_instruction(end - pos, std::string_view(pos, end - pos));
                 out_template += String(pos, end - pos);
                 break;
             }
@@ -1172,32 +1391,41 @@ class FunctionFormatDateTimeImpl : public IFunction
     }
 
     template <typename T>
-    size_t parseJodaFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32, String &) const
+    size_t parseJodaFormat(const String & format, std::vector<Instruction<T>> & instructions, UInt32, bool, String &) const
     {
         /// If the argument was DateTime, add instruction for printing. If it was date, just append default literal
-        auto add_instruction = [&](auto && func [[maybe_unused]], const String & default_literal [[maybe_unused]])
+        auto add_instruction = [&]([[maybe_unused]] typename Instruction<T>::FuncJoda && func, [[maybe_unused]] const String & default_literal)
         {
-            if constexpr (std::is_same_v<T, UInt32> || std::is_same_v<T, Int64>)
-                instructions.emplace_back(func);
+            if constexpr (is_any_of<T, UInt32, Int64>)
+            {
+                Instruction<T> instruction;
+                instruction.setJodaFunc(std::move(func));
+                instructions.push_back(std::move(instruction));
+            }
             else
-                instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<String>, default_literal));
+            {
+                Instruction<T> instruction;
+                instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<String>, default_literal));
+                instructions.push_back(std::move(instruction));
+            }
         };
 
         size_t reserve_size = 0;
-        const char * pos = format.data();
-        const char * end = format.data() + format.size();
+        Pos pos = format.data();
+        Pos end = format.data() + format.size();
         while (pos < end)
         {
-            const char * cur_token = pos;
-
+            Pos cur_token = pos;
             // Literal case
             if (*cur_token == '\'')
             {
                 // Case 1: 2 consecutive single quote
                 if (pos + 1 < end && *(pos + 1) == '\'')
                 {
+                    Instruction<T> instruction;
                     std::string_view literal(cur_token, 1);
-                    instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                    instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                    instructions.push_back(std::move(instruction));
                     ++reserve_size;
                     pos += 2;
                 }
@@ -1211,9 +1439,10 @@ class FunctionFormatDateTimeImpl : public IFunction
                     {
                         for (Int64 i = 1; i <= count; i++)
                         {
+                            Instruction<T> instruction;
                             std::string_view literal(cur_token + i, 1);
-                            instructions.emplace_back(
-                                std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                            instructions.push_back(std::move(instruction));
                             ++reserve_size;
                             if (*(cur_token + i) == '\'')
                                 i += 1;
@@ -1234,68 +1463,114 @@ class FunctionFormatDateTimeImpl : public IFunction
                 switch (*cur_token)
                 {
                     case 'G':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaEra, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaEra, repetitions));
+                        instructions.push_back(std::move(instruction));
                         reserve_size += repetitions <= 3 ? 2 : 13;
                         break;
+                    }
                     case 'C':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaCenturyOfEra, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaCenturyOfEra, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Year range [1900, 2299]
                         reserve_size += std::max(repetitions, 2);
                         break;
+                    }
                     case 'Y':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaYearOfEra, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaYearOfEra, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Year range [1900, 2299]
                         reserve_size += repetitions == 2 ? 2 : std::max(repetitions, 4);
                         break;
+                    }
                     case 'x':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaWeekYear, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaWeekYear, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// weekyear range [1900, 2299]
                         reserve_size += std::max(repetitions, 4);
                         break;
+                    }
                     case 'w':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaWeekOfWeekYear, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaWeekOfWeekYear, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Week of weekyear range [1, 52]
                         reserve_size += std::max(repetitions, 2);
                         break;
+                    }
                     case 'e':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfWeek1Based, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfWeek1Based, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Day of week range [1, 7]
                         reserve_size += std::max(repetitions, 1);
                         break;
+                    }
                     case 'E':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfWeekText, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfWeekText, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Maximum length of short name is 3, maximum length of full name is 9.
                         reserve_size += repetitions <= 3 ? 3 : 9;
                         break;
+                    }
                     case 'y':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaYear, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaYear, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Year range [1900, 2299]
                         reserve_size += repetitions == 2 ? 2 : std::max(repetitions, 4);
                         break;
+                    }
                     case 'D':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfYear, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfYear, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Day of year range [1, 366]
                         reserve_size += std::max(repetitions, 3);
                         break;
+                    }
                     case 'M':
+                    {
                         if (repetitions <= 2)
                         {
-                            instructions.emplace_back(std::bind_front(&Instruction<T>::jodaMonthOfYear, repetitions));
+                            Instruction<T> instruction;
+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaMonthOfYear, repetitions));
+                            instructions.push_back(std::move(instruction));
                             /// Month of year range [1, 12]
                             reserve_size += 2;
                         }
                         else
                         {
-                            instructions.emplace_back(std::bind_front(&Instruction<T>::jodaMonthOfYearText, repetitions));
+                            Instruction<T> instruction;
+                            instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaMonthOfYearText, repetitions));
+                            instructions.push_back(std::move(instruction));
                             /// Maximum length of short name is 3, maximum length of full name is 9.
                             reserve_size += repetitions <= 3 ? 3 : 9;
                         }
                         break;
+                    }
                     case 'd':
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaDayOfMonth, repetitions));
+                    {
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaDayOfMonth, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Day of month range [1, 3]
                         reserve_size += std::max(repetitions, 3);
                         break;
+                    }
                     case 'a':
                         /// Default half day of day is "AM"
                         add_instruction(std::bind_front(&Instruction<T>::jodaHalfDayOfDay, repetitions), "AM");
@@ -1341,29 +1616,41 @@ class FunctionFormatDateTimeImpl : public IFunction
                         reserve_size += std::max(repetitions, 2);
                         break;
                     case 'S':
+                    {
                         /// Default fraction of second is 0
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaFractionOfSecond, repetitions));
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaFractionOfSecond, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// 'S' repetitions range [0, 9]
                         reserve_size += repetitions <= 9 ? repetitions : 9;
                         break;
+                    }
                     case 'z':
+                    {
                         if (repetitions <= 3)
                             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Short name time zone is not yet supported");
 
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::jodaTimezone, repetitions));
+                        Instruction<T> instruction;
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::jodaTimezone, repetitions));
+                        instructions.push_back(std::move(instruction));
                         /// Longest length of full name of time zone is 32.
                         reserve_size += 32;
                         break;
+                    }
                     case 'Z':
                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "format is not supported for TIMEZONE_OFFSET_ID");
                     default:
+                    {
                         if (isalpha(*cur_token))
                             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "format is not supported for {}", String(cur_token, repetitions));
 
+                        Instruction<T> instruction;
                         std::string_view literal(cur_token, pos - cur_token);
-                        instructions.emplace_back(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                        instruction.setJodaFunc(std::bind_front(&Instruction<T>::template jodaLiteral<decltype(literal)>, literal));
+                        instructions.push_back(std::move(instruction));
                         reserve_size += pos - cur_token;
                         break;
+                    }
                 }
             }
         }
@@ -1392,10 +1679,10 @@ struct NameFromUnixTimeInJodaSyntax
 };
 
 
-using FunctionFormatDateTime = FunctionFormatDateTimeImpl<NameFormatDateTime, FormatDateTimeTraits::SupportInteger::No, FormatDateTimeTraits::FormatSyntax::MySQL>;
-using FunctionFromUnixTimestamp = FunctionFormatDateTimeImpl<NameFromUnixTime, FormatDateTimeTraits::SupportInteger::Yes, FormatDateTimeTraits::FormatSyntax::MySQL>;
-using FunctionFormatDateTimeInJodaSyntax = FunctionFormatDateTimeImpl<NameFormatDateTimeInJodaSyntax, FormatDateTimeTraits::SupportInteger::No, FormatDateTimeTraits::FormatSyntax::Joda>;
-using FunctionFromUnixTimestampInJodaSyntax = FunctionFormatDateTimeImpl<NameFromUnixTimeInJodaSyntax, FormatDateTimeTraits::SupportInteger::Yes, FormatDateTimeTraits::FormatSyntax::Joda>;
+using FunctionFormatDateTime = FunctionFormatDateTimeImpl<NameFormatDateTime, SupportInteger::No, FormatSyntax::MySQL>;
+using FunctionFromUnixTimestamp = FunctionFormatDateTimeImpl<NameFromUnixTime, SupportInteger::Yes, FormatSyntax::MySQL>;
+using FunctionFormatDateTimeInJodaSyntax = FunctionFormatDateTimeImpl<NameFormatDateTimeInJodaSyntax, SupportInteger::No, FormatSyntax::Joda>;
+using FunctionFromUnixTimestampInJodaSyntax = FunctionFormatDateTimeImpl<NameFromUnixTimeInJodaSyntax, SupportInteger::Yes, FormatSyntax::Joda>;
 
 }
 
diff --git a/src/Functions/parseDateTime.cpp b/src/Functions/parseDateTime.cpp
index 553e993a806a..ef95c5929578 100644
--- a/src/Functions/parseDateTime.cpp
+++ b/src/Functions/parseDateTime.cpp
@@ -50,7 +50,7 @@ namespace
     const std::unordered_map<String, std::pair<String, Int32>> monthMap{
         {"jan", {"uary", 1}},
         {"feb", {"ruary", 2}},
-        {"mar", {"rch", 3}},
+        {"mar", {"ch", 3}},
         {"apr", {"il", 4}},
         {"may", {"", 5}},
         {"jun", {"e", 6}},
@@ -103,16 +103,16 @@ namespace
         bool is_year_of_era = false; /// If true, year is calculated from era and year of era, the latter cannot be zero or negative.
         bool has_year = false; /// Whether year was explicitly specified.
 
-        /// If is_clock_hour = true, is_hour_of_half_day = true, hour's range is [1, 12]
-        /// If is_clock_hour = true, is_hour_of_half_day = false, hour's range is [1, 24]
-        /// If is_clock_hour = false, is_hour_of_half_day = true, hour's range is [0, 11]
-        /// If is_clock_hour = false, is_hour_of_half_day = false, hour's range is [0, 23]
+        /// If hour_starts_at_1 = true, is_hour_of_half_day = true, hour's range is [1, 12]
+        /// If hour_starts_at_1 = true, is_hour_of_half_day = false, hour's range is [1, 24]
+        /// If hour_starts_at_1 = false, is_hour_of_half_day = true, hour's range is [0, 11]
+        /// If hour_starts_at_1 = false, is_hour_of_half_day = false, hour's range is [0, 23]
         Int32 hour = 0;
         Int32 minute = 0; /// range [0, 59]
         Int32 second = 0; /// range [0, 59]
 
         bool is_am = true; /// If is_hour_of_half_day = true and is_am = false (i.e. pm) then add 12 hours to the result DateTime
-        bool is_clock_hour = false; /// Whether the hour is clockhour
+        bool hour_starts_at_1 = false; /// Whether the hour is clockhour
         bool is_hour_of_half_day = false; /// Whether the hour is of half day
 
         bool has_time_zone_offset = false; /// If true, time zone offset is explicitly specified.
@@ -139,7 +139,7 @@ namespace
             second = 0;
 
             is_am = true;
-            is_clock_hour = false;
+            hour_starts_at_1 = false;
             is_hour_of_half_day = false;
 
             has_time_zone_offset = false;
@@ -277,23 +277,23 @@ namespace
                 throw Exception(ErrorCodes::CANNOT_PARSE_DATETIME, "Unknown half day of day: {}", text);
         }
 
-        void setHour(Int32 hour_, bool is_hour_of_half_day_ = false, bool is_clock_hour_ = false)
+        void setHour(Int32 hour_, bool is_hour_of_half_day_ = false, bool hour_starts_at_1_ = false)
         {
             Int32 max_hour;
             Int32 min_hour;
             Int32 new_hour = hour_;
-            if (!is_hour_of_half_day_ && !is_clock_hour_)
+            if (!is_hour_of_half_day_ && !hour_starts_at_1_)
             {
                 max_hour = 23;
                 min_hour = 0;
             }
-            else if (!is_hour_of_half_day_ && is_clock_hour_)
+            else if (!is_hour_of_half_day_ && hour_starts_at_1_)
             {
                 max_hour = 24;
                 min_hour = 1;
                 new_hour = hour_ % 24;
             }
-            else if (is_hour_of_half_day_ && !is_clock_hour_)
+            else if (is_hour_of_half_day_ && !hour_starts_at_1_)
             {
                 max_hour = 11;
                 min_hour = 0;
@@ -308,16 +308,16 @@ namespace
             if (hour_ < min_hour || hour_ > max_hour)
                 throw Exception(
                     ErrorCodes::CANNOT_PARSE_DATETIME,
-                    "Value {} for hour must be in the range [{}, {}] if_hour_of_half_day={} and is_clock_hour={}",
+                    "Value {} for hour must be in the range [{}, {}] if_hour_of_half_day={} and hour_starts_at_1={}",
                     hour,
                     max_hour,
                     min_hour,
                     is_hour_of_half_day_,
-                    is_clock_hour_);
+                    hour_starts_at_1_);
 
             hour = new_hour;
             is_hour_of_half_day = is_hour_of_half_day_;
-            is_clock_hour = is_clock_hour_;
+            hour_starts_at_1 = hour_starts_at_1_;
         }
 
         void setMinute(Int32 minute_)
@@ -920,7 +920,7 @@ namespace
 
             static Pos mysqlDayOfWeekTextLong(Pos cur, Pos end, const String & fragment, DateTime & date)
             {
-                checkSpace(cur, end, 6, "jodaDayOfWeekText requires size >= 6", fragment);
+                checkSpace(cur, end, 6, "mysqlDayOfWeekTextLong requires size >= 6", fragment);
                 String text1(cur, 3);
                 boost::to_lower(text1);
                 auto it = dayOfWeekMap.find(text1);
@@ -934,7 +934,7 @@ namespace
                 cur += 3;
 
                 size_t expected_remaining_size = it->second.first.size();
-                checkSpace(cur, end, expected_remaining_size, "jodaDayOfWeekText requires the second parg size >= " + std::to_string(expected_remaining_size), fragment);
+                checkSpace(cur, end, expected_remaining_size, "mysqlDayOfWeekTextLong requires the second parg size >= " + std::to_string(expected_remaining_size), fragment);
                 String text2(cur, expected_remaining_size);
                 boost::to_lower(text2);
                 if (text2 != it->second.first)
diff --git a/src/Functions/widthBucket.cpp b/src/Functions/widthBucket.cpp
index a32fa159c2c2..e14ef90223d8 100644
--- a/src/Functions/widthBucket.cpp
+++ b/src/Functions/widthBucket.cpp
@@ -11,6 +11,7 @@
 #include <Functions/IFunction.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/castColumn.h>
+#include <Common/Concepts.h>
 #include <Common/Exception.h>
 #include <Common/NaNUtils.h>
 #include <Common/register_objects.h>
