diff --git a/docker/test/install/deb/Dockerfile b/docker/test/install/deb/Dockerfile
new file mode 100644
index 000000000000..9614473c69b4
--- /dev/null
+++ b/docker/test/install/deb/Dockerfile
@@ -0,0 +1,64 @@
+FROM ubuntu:22.04
+
+# The Dockerfile is nicely borrowed from
+# https://github.com/lionelnicolas/docker-ubuntu-systemd/blob/83aa3249146f5df264fe45353f79fc76eb1e42d7/Dockerfile
+
+ENV \
+  DEBIAN_FRONTEND=noninteractive \
+  LANG=C.UTF-8 \
+  container=docker \
+  init=/lib/systemd/systemd
+
+# install systemd packages
+RUN apt-get update && \
+  apt-get install -y --no-install-recommends \
+    systemd \
+    && \
+  apt-get clean && \
+  rm -rf /var/lib/apt/lists
+
+# configure systemd
+# remove systemd 'wants' triggers
+# remove everything except tmpfiles setup in sysinit target
+# remove UTMP updater service
+# disable /tmp mount
+# fix missing BPF firewall support warning
+# just for cosmetics, fix "not-found" entries while using "systemctl --all"
+RUN \
+  find \
+    /etc/systemd/system/*.wants/* \
+    /lib/systemd/system/multi-user.target.wants/* \
+    /lib/systemd/system/sockets.target.wants/*initctl* \
+    ! -type d \
+    -delete && \
+  find \
+    /lib/systemd/system/sysinit.target.wants \
+    ! -type d \
+    ! -name '*systemd-tmpfiles-setup*' \
+    -delete && \
+  find \
+    /lib/systemd \
+    -name systemd-update-utmp-runlevel.service \
+    -delete && \
+  rm -vf /usr/share/systemd/tmp.mount && \
+  sed -ri '/^IPAddressDeny/d' /lib/systemd/system/systemd-journald.service && \
+  for MATCH in \
+    plymouth-start.service \
+    plymouth-quit-wait.service \
+    syslog.socket \
+    syslog.service \
+    display-manager.service \
+    systemd-sysusers.service \
+    tmp.mount \
+    systemd-udevd.service \
+    ; do \
+      grep -rn --binary-files=without-match  ${MATCH} /lib/systemd/ | cut -d: -f1 | xargs sed -ri 's/(.*=.*)'${MATCH}'(.*)/\1\2/'; \
+  done && \
+  systemctl disable ondemand.service && \
+  systemctl set-default multi-user.target
+
+VOLUME ["/run", "/run/lock"]
+
+STOPSIGNAL SIGRTMIN+3
+
+ENTRYPOINT ["/lib/systemd/systemd"]
diff --git a/docker/test/install/rpm/Dockerfile b/docker/test/install/rpm/Dockerfile
new file mode 100644
index 000000000000..c55e0fe25072
--- /dev/null
+++ b/docker/test/install/rpm/Dockerfile
@@ -0,0 +1,55 @@
+FROM centos:8
+
+# The Dockerfile is nicely borrowed from
+# https://github.com/lionelnicolas/docker-ubuntu-systemd/blob/83aa3249146f5df264fe45353f79fc76eb1e42d7/Dockerfile
+
+ENV \
+  LANG=C.UTF-8 \
+  container=docker \
+  init=/lib/systemd/systemd
+
+# configure systemd
+# remove systemd 'wants' triggers
+# remove everything except tmpfiles setup in sysinit target
+# remove UTMP updater service
+# disable /tmp mount
+# fix missing BPF firewall support warning
+# just for cosmetics, fix "not-found" entries while using "systemctl --all"
+RUN \
+  find \
+    /etc/systemd/system/*.wants/ \
+    /lib/systemd/system/multi-user.target.wants/ \
+    /lib/systemd/system/local-fs.target.wants/ \
+    /lib/systemd/system/sockets.target.wants/*initctl* \
+    ! -type d \
+    -delete && \
+  find \
+    /lib/systemd/system/sysinit.target.wants \
+    ! -type d \
+    ! -name '*systemd-tmpfiles-setup*' \
+    -delete && \
+  find \
+    /lib/systemd \
+    -name systemd-update-utmp-runlevel.service \
+    -delete && \
+  rm -vf /usr/share/systemd/tmp.mount && \
+  sed -ri '/^IPAddressDeny/d' /lib/systemd/system/systemd-journald.service && \
+  for MATCH in \
+    plymouth-start.service \
+    plymouth-quit-wait.service \
+    syslog.socket \
+    syslog.service \
+    display-manager.service \
+    systemd-sysusers.service \
+    tmp.mount \
+    systemd-udevd.service \
+    ; do \
+      grep -rn --binary-files=without-match  ${MATCH} /lib/systemd/ | cut -d: -f1 | xargs sed -ri 's/(.*=.*)'${MATCH}'(.*)/\1\2/'; \
+  done && \
+  systemctl set-default multi-user.target
+
+VOLUME ["/run", "/run/lock"]
+
+STOPSIGNAL SIGRTMIN+3
+
+ENTRYPOINT ["/lib/systemd/systemd"]
diff --git a/tests/ci/build_download_helper.py b/tests/ci/build_download_helper.py
index bd96ea04c4c8..c61360153160 100644
--- a/tests/ci/build_download_helper.py
+++ b/tests/ci/build_download_helper.py
@@ -5,7 +5,8 @@
 import os
 import sys
 import time
-from typing import Any, List, Optional
+from pathlib import Path
+from typing import Any, Callable, List, Optional
 
 import requests  # type: ignore
 
@@ -56,21 +57,29 @@ def read_build_urls(build_name: str, reports_path: str) -> List[str]:
     return []
 
 
-def download_build_with_progress(url, path):
+def download_build_with_progress(url: str, path: Path) -> None:
     logging.info("Downloading from %s to temp path %s", url, path)
     for i in range(DOWNLOAD_RETRIES_COUNT):
         try:
+            response = get_with_retries(url, retries=1, stream=True)
+            total_length = int(response.headers.get("content-length", 0))
+            if path.is_file() and total_length and path.stat().st_size == total_length:
+                logging.info(
+                    "The file %s already exists and have a proper size %s",
+                    path,
+                    total_length,
+                )
+                return
+
             with open(path, "wb") as f:
-                response = get_with_retries(url, retries=1, stream=True)
-                total_length = response.headers.get("content-length")
-                if total_length is None or int(total_length) == 0:
+                if total_length == 0:
                     logging.info(
                         "No content-length, will download file without progress"
                     )
                     f.write(response.content)
                 else:
                     dl = 0
-                    total_length = int(total_length)
+
                     logging.info("Content length is %ld bytes", total_length)
                     for data in response.iter_content(chunk_size=4096):
                         dl += len(data)
@@ -99,12 +108,14 @@ def download_build_with_progress(url, path):
     logging.info("Downloading finished")
 
 
-def download_builds(result_path, build_urls, filter_fn):
+def download_builds(
+    result_path: str, build_urls: List[str], filter_fn: Callable[[str], bool]
+) -> None:
     for url in build_urls:
         if filter_fn(url):
             fname = os.path.basename(url.replace("%2B", "+").replace("%20", " "))
             logging.info("Will download %s to %s", fname, result_path)
-            download_build_with_progress(url, os.path.join(result_path, fname))
+            download_build_with_progress(url, Path(result_path) / fname)
 
 
 def download_builds_filter(
diff --git a/tests/ci/ci_config.py b/tests/ci/ci_config.py
index c77acfb679f4..6aa29465c17c 100644
--- a/tests/ci/ci_config.py
+++ b/tests/ci/ci_config.py
@@ -182,6 +182,12 @@
     "tests_config": {
         # required_build - build name for artifacts
         # force_tests - force success status for tests
+        "Install packages (amd64)": {
+            "required_build": "package_release",
+        },
+        "Install packages (arm64)": {
+            "required_build": "package_aarch64",
+        },
         "Stateful tests (asan)": {
             "required_build": "package_asan",
         },
diff --git a/tests/ci/download_binary.py b/tests/ci/download_binary.py
index b95c86aa0bd7..c57780daa369 100755
--- a/tests/ci/download_binary.py
+++ b/tests/ci/download_binary.py
@@ -6,6 +6,7 @@
 import argparse
 import logging
 import os
+from pathlib import Path
 
 from build_download_helper import download_build_with_progress
 from ci_config import CI_CONFIG, BuildConfig
@@ -57,14 +58,15 @@ def parse_args() -> argparse.Namespace:
 def main():
     logging.basicConfig(level=logging.INFO, format="%(asctime)s %(message)s")
     args = parse_args()
-    os.makedirs(TEMP_PATH, exist_ok=True)
+    temp_path = Path(TEMP_PATH)
+    temp_path.mkdir(parents=True, exist_ok=True)
     for build in args.build_names:
         # check if it's in CI_CONFIG
         config = CI_CONFIG["build_config"][build]  # type: BuildConfig
         if args.rename:
-            path = os.path.join(TEMP_PATH, f"clickhouse-{config['static_binary_name']}")
+            path = temp_path / f"clickhouse-{config['static_binary_name']}"
         else:
-            path = os.path.join(TEMP_PATH, "clickhouse")
+            path = temp_path / "clickhouse"
 
         url = S3_ARTIFACT_DOWNLOAD_TEMPLATE.format(
             pr_or_release=f"{args.version.major}.{args.version.minor}",
diff --git a/tests/ci/install_check.py b/tests/ci/install_check.py
new file mode 100644
index 000000000000..1444759cea0f
--- /dev/null
+++ b/tests/ci/install_check.py
@@ -0,0 +1,315 @@
+#!/usr/bin/env python3
+
+import argparse
+
+import atexit
+import logging
+import sys
+import subprocess
+from pathlib import Path
+
+from typing import Dict
+
+from github import Github
+
+from build_download_helper import download_builds_filter
+from clickhouse_helper import (
+    ClickHouseHelper,
+    mark_flaky_tests,
+    prepare_tests_results_for_clickhouse,
+)
+from commit_status_helper import post_commit_status, update_mergeable_check
+from docker_pull_helper import get_image_with_version, DockerImage
+from env_helper import CI, TEMP_PATH as TEMP, REPORTS_PATH
+from get_robot_token import get_best_robot_token
+from pr_info import PRInfo
+from report import TestResults, TestResult
+from rerun_helper import RerunHelper
+from s3_helper import S3Helper
+from stopwatch import Stopwatch
+from tee_popen import TeePopen
+from upload_result_helper import upload_results
+
+
+RPM_IMAGE = "clickhouse/install-rpm-test"
+DEB_IMAGE = "clickhouse/install-deb-test"
+TEMP_PATH = Path(TEMP)
+SUCCESS = "success"
+FAILURE = "failure"
+
+
+def prepare_test_scripts():
+    server_test = r"""#!/bin/bash
+systemctl start clickhouse-server
+clickhouse-client -q 'SELECT version()'"""
+    keeper_test = r"""#!/bin/bash
+systemctl start clickhouse-keeper
+for i in {1..20}; do
+    echo wait for clickhouse-keeper to being up
+    > /dev/tcp/127.0.0.1/9181 2>/dev/null && break || sleep 1
+done
+for i in {1..5}; do
+    echo wait for clickhouse-keeper to answer on mntr request
+    exec 13<>/dev/tcp/127.0.0.1/9181
+    echo mntr >&13
+    cat <&13 | grep zk_version && break || sleep 1
+    exec 13>&-
+done
+exec 13>&-"""
+    binary_test = r"""#!/bin/bash
+chmod +x /packages/clickhouse
+/packages/clickhouse install
+clickhouse-server start --daemon
+for i in {1..5}; do
+    clickhouse-client -q 'SELECT version()' && break || sleep 1
+done
+clickhouse-keeper start --daemon
+for i in {1..20}; do
+    echo wait for clickhouse-keeper to being up
+    > /dev/tcp/127.0.0.1/9181 2>/dev/null && break || sleep 1
+done
+for i in {1..5}; do
+    echo wait for clickhouse-keeper to answer on mntr request
+    exec 13<>/dev/tcp/127.0.0.1/9181
+    echo mntr >&13
+    cat <&13 | grep zk_version && break || sleep 1
+    exec 13>&-
+done
+exec 13>&-"""
+    (TEMP_PATH / "server_test.sh").write_text(server_test, encoding="utf-8")
+    (TEMP_PATH / "keeper_test.sh").write_text(keeper_test, encoding="utf-8")
+    (TEMP_PATH / "binary_test.sh").write_text(binary_test, encoding="utf-8")
+
+
+def test_install_deb(image: DockerImage) -> TestResults:
+    tests = {
+        "Install server deb": r"""#!/bin/bash -ex
+apt-get install /packages/clickhouse-{server,client,common}*deb
+bash -ex /packages/server_test.sh""",
+        "Install keeper deb": r"""#!/bin/bash -ex
+apt-get install /packages/clickhouse-keeper*deb
+bash -ex /packages/keeper_test.sh""",
+        "Install clickhouse binary in deb": r"bash -ex /packages/binary_test.sh",
+    }
+    return test_install(image, tests)
+
+
+def test_install_rpm(image: DockerImage) -> TestResults:
+    # FIXME: I couldn't find why Type=notify is broken in centos:8
+    # systemd just ignores the watchdog completely
+    tests = {
+        "Install server rpm": r"""#!/bin/bash -ex
+yum localinstall --disablerepo=* -y /packages/clickhouse-{server,client,common}*rpm
+echo CLICKHOUSE_WATCHDOG_ENABLE=0 > /etc/default/clickhouse-server
+bash -ex /packages/server_test.sh""",
+        "Install keeper rpm": r"""#!/bin/bash -ex
+yum localinstall --disablerepo=* -y /packages/clickhouse-keeper*rpm
+bash -ex /packages/keeper_test.sh""",
+        "Install clickhouse binary in rpm": r"bash -ex /packages/binary_test.sh",
+    }
+    return test_install(image, tests)
+
+
+def test_install_tgz(image: DockerImage) -> TestResults:
+    # FIXME: I couldn't find why Type=notify is broken in centos:8
+    # systemd just ignores the watchdog completely
+    tests = {
+        f"Install server tgz in {image.name}": r"""#!/bin/bash -ex
+[ -f /etc/debian_version ] && CONFIGURE=configure || CONFIGURE=
+for pkg in /packages/clickhouse-{common,client,server}*tgz; do
+    package=${pkg%-*}
+    package=${package##*/}
+    tar xf "$pkg"
+    "/$package/install/doinst.sh" $CONFIGURE
+done
+[ -f /etc/yum.conf ] && echo CLICKHOUSE_WATCHDOG_ENABLE=0 > /etc/default/clickhouse-server
+bash -ex /packages/server_test.sh""",
+        f"Install keeper tgz in {image.name}": r"""#!/bin/bash -ex
+[ -f /etc/debian_version ] && CONFIGURE=configure || CONFIGURE=
+for pkg in /packages/clickhouse-keeper*tgz; do
+    package=${pkg%-*}
+    package=${package##*/}
+    tar xf "$pkg"
+    "/$package/install/doinst.sh" $CONFIGURE
+done
+bash -ex /packages/keeper_test.sh""",
+    }
+    return test_install(image, tests)
+
+
+def test_install(image: DockerImage, tests: Dict[str, str]) -> TestResults:
+    test_results = []  # type: TestResults
+    for name, command in tests.items():
+        stopwatch = Stopwatch()
+        container_name = name.lower().replace(" ", "_").replace("/", "_")
+        log_file = TEMP_PATH / f"{container_name}.log"
+        run_command = (
+            f"docker run --rm --privileged --detach --cap-add=SYS_PTRACE "
+            f"--volume={TEMP_PATH}:/packages {image}"
+        )
+        logging.info("Running docker container: `%s`", run_command)
+        container_id = subprocess.check_output(
+            run_command, shell=True, encoding="utf-8"
+        ).strip()
+        (TEMP_PATH / "install.sh").write_text(command)
+        install_command = f"docker exec {container_id} bash -ex /packages/install.sh"
+        with TeePopen(install_command, log_file) as process:
+            retcode = process.wait()
+            if retcode == 0:
+                status = SUCCESS
+            else:
+                status = FAILURE
+
+        subprocess.check_call(f"docker kill -s 9 {container_id}", shell=True)
+        test_results.append(
+            TestResult(name, status, stopwatch.duration_seconds, [log_file])
+        )
+
+    return test_results
+
+
+def parse_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(
+        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
+        description="The script to check if the packages are able to install",
+    )
+
+    parser.add_argument(
+        "check_name",
+        help="check name, used to download the packages",
+    )
+    parser.add_argument("--download", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-download",
+        dest="download",
+        action="store_false",
+        default=argparse.SUPPRESS,
+        help="if set, the packages won't be downloaded, useful for debug",
+    )
+    parser.add_argument("--deb", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-deb",
+        dest="deb",
+        action="store_false",
+        default=argparse.SUPPRESS,
+        help="if set, the deb packages won't be checked",
+    )
+    parser.add_argument("--rpm", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-rpm",
+        dest="rpm",
+        action="store_false",
+        default=argparse.SUPPRESS,
+        help="if set, the rpm packages won't be checked",
+    )
+    parser.add_argument("--tgz", default=True, help=argparse.SUPPRESS)
+    parser.add_argument(
+        "--no-tgz",
+        dest="tgz",
+        action="store_false",
+        default=argparse.SUPPRESS,
+        help="if set, the tgz packages won't be checked",
+    )
+
+    return parser.parse_args()
+
+
+def main():
+    logging.basicConfig(level=logging.INFO)
+
+    stopwatch = Stopwatch()
+
+    args = parse_args()
+
+    TEMP_PATH.mkdir(parents=True, exist_ok=True)
+
+    pr_info = PRInfo()
+
+    if CI:
+        gh = Github(get_best_robot_token(), per_page=100)
+        atexit.register(update_mergeable_check, gh, pr_info, args.check_name)
+
+        rerun_helper = RerunHelper(gh, pr_info, args.check_name)
+        if rerun_helper.is_already_finished_by_status():
+            logging.info(
+                "Check is already finished according to github status, exiting"
+            )
+            sys.exit(0)
+
+    docker_images = {
+        name: get_image_with_version(REPORTS_PATH, name)
+        for name in (RPM_IMAGE, DEB_IMAGE)
+    }
+    prepare_test_scripts()
+
+    if args.download:
+
+        def filter_artifacts(path: str) -> bool:
+            return (
+                path.endswith(".deb")
+                or path.endswith(".rpm")
+                or path.endswith(".tgz")
+                or path.endswith("/clickhouse")
+            )
+
+        download_builds_filter(
+            args.check_name, REPORTS_PATH, TEMP_PATH, filter_artifacts
+        )
+
+    test_results = []  # type: TestResults
+    if args.deb:
+        test_results.extend(test_install_deb(docker_images[DEB_IMAGE]))
+    if args.rpm:
+        test_results.extend(test_install_rpm(docker_images[RPM_IMAGE]))
+    if args.tgz:
+        test_results.extend(test_install_tgz(docker_images[DEB_IMAGE]))
+        test_results.extend(test_install_tgz(docker_images[RPM_IMAGE]))
+
+    state = SUCCESS
+    description = "Packages installed successfully"
+    if FAILURE in (result.status for result in test_results):
+        state = FAILURE
+        description = "Failed to install packages: " + ", ".join(
+            result.name for result in test_results
+        )
+
+    s3_helper = S3Helper()
+
+    report_url = upload_results(
+        s3_helper,
+        pr_info.number,
+        pr_info.sha,
+        test_results,
+        [],
+        args.check_name,
+    )
+    print(f"::notice ::Report url: {report_url}")
+    if not CI:
+        return
+
+    ch_helper = ClickHouseHelper()
+    mark_flaky_tests(ch_helper, args.check_name, test_results)
+
+    if len(description) >= 140:
+        description = description[:136] + "..."
+
+    post_commit_status(gh, pr_info.sha, args.check_name, description, state, report_url)
+
+    prepared_events = prepare_tests_results_for_clickhouse(
+        pr_info,
+        test_results,
+        state,
+        stopwatch.duration_seconds,
+        stopwatch.start_time_str,
+        report_url,
+        args.check_name,
+    )
+
+    ch_helper.insert_events_into(db="default", table="checks", events=prepared_events)
+
+    if state == FAILURE:
+        sys.exit(1)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/ci/unit_tests_check.py b/tests/ci/unit_tests_check.py
index 915a77f3d48e..edc096908f41 100644
--- a/tests/ci/unit_tests_check.py
+++ b/tests/ci/unit_tests_check.py
@@ -108,13 +108,10 @@ def main():
 
     stopwatch = Stopwatch()
 
-    temp_path = TEMP_PATH
-    reports_path = REPORTS_PATH
-
     check_name = sys.argv[1]
 
-    if not os.path.exists(temp_path):
-        os.makedirs(temp_path)
+    if not os.path.exists(TEMP_PATH):
+        os.makedirs(TEMP_PATH)
 
     pr_info = PRInfo()
 
@@ -127,14 +124,14 @@ def main():
         logging.info("Check is already finished according to github status, exiting")
         sys.exit(0)
 
-    docker_image = get_image_with_version(reports_path, IMAGE_NAME)
+    docker_image = get_image_with_version(REPORTS_PATH, IMAGE_NAME)
 
-    download_unit_tests(check_name, reports_path, temp_path)
+    download_unit_tests(check_name, REPORTS_PATH, TEMP_PATH)
 
-    tests_binary_path = os.path.join(temp_path, "unit_tests_dbms")
+    tests_binary_path = os.path.join(TEMP_PATH, "unit_tests_dbms")
     os.chmod(tests_binary_path, 0o777)
 
-    test_output = os.path.join(temp_path, "test_output")
+    test_output = os.path.join(TEMP_PATH, "test_output")
     if not os.path.exists(test_output):
         os.makedirs(test_output)
 
@@ -151,7 +148,7 @@ def main():
         else:
             logging.info("Run failed")
 
-    subprocess.check_call(f"sudo chown -R ubuntu:ubuntu {temp_path}", shell=True)
+    subprocess.check_call(f"sudo chown -R ubuntu:ubuntu {TEMP_PATH}", shell=True)
 
     s3_helper = S3Helper()
     state, description, test_results, additional_logs = process_results(test_output)
