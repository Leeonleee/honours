diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index 9d7a4275dc1d..313523d19dc6 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -1159,7 +1159,7 @@ int Server::main(const std::vector<std::string> & /*args*/)
     {
         /// This object will periodically calculate some metrics.
         AsynchronousMetrics async_metrics(
-            global_context, config().getUInt("asynchronous_metrics_update_period_s", 60), servers_to_start_before_tables, servers);
+            global_context, config().getUInt("asynchronous_metrics_update_period_s", 1), servers_to_start_before_tables, servers);
         attachSystemTablesAsync(*DatabaseCatalog::instance().getSystemDatabase(), async_metrics);
 
         for (const auto & listen_host : listen_hosts)
diff --git a/programs/server/config.xml b/programs/server/config.xml
index dd50a6934036..6f0b228dda76 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -583,7 +583,7 @@
         <port>9019</port>
     </jdbc_bridge>
     -->
-  
+
     <!-- Configuration of clusters that could be used in Distributed tables.
          https://clickhouse.tech/docs/en/operations/table_engines/distributed/
       -->
@@ -917,7 +917,7 @@
             Asynchronous metrics are updated once a minute, so there is
             no need to flush more often.
         -->
-        <flush_interval_milliseconds>60000</flush_interval_milliseconds>
+        <flush_interval_milliseconds>7000</flush_interval_milliseconds>
     </asynchronous_metric_log>
 
     <!--
diff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp
index f4ceef2896a8..8301ea656bf1 100644
--- a/src/Common/ErrorCodes.cpp
+++ b/src/Common/ErrorCodes.cpp
@@ -557,6 +557,7 @@
     M(587, CONCURRENT_ACCESS_NOT_SUPPORTED) \
     M(588, DISTRIBUTED_BROKEN_BATCH_INFO) \
     M(589, DISTRIBUTED_BROKEN_BATCH_FILES) \
+    M(590, CANNOT_SYSCONF) \
     \
     M(998, POSTGRESQL_CONNECTION_FAILURE) \
     M(999, KEEPER_EXCEPTION) \
diff --git a/src/IO/ReadBufferFromFileDescriptor.cpp b/src/IO/ReadBufferFromFileDescriptor.cpp
index babdc953514d..893c2bcb5d8c 100644
--- a/src/IO/ReadBufferFromFileDescriptor.cpp
+++ b/src/IO/ReadBufferFromFileDescriptor.cpp
@@ -149,7 +149,7 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)
         off_t res = ::lseek(fd, new_pos, SEEK_SET);
         if (-1 == res)
             throwFromErrnoWithPath("Cannot seek through file " + getFileName(), getFileName(),
-                                   ErrorCodes::CANNOT_SEEK_THROUGH_FILE);
+                ErrorCodes::CANNOT_SEEK_THROUGH_FILE);
         file_offset_of_buffer_end = new_pos;
 
         watch.stop();
@@ -160,6 +160,20 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)
 }
 
 
+void ReadBufferFromFileDescriptor::rewind()
+{
+    ProfileEvents::increment(ProfileEvents::Seek);
+    off_t res = ::lseek(fd, 0, SEEK_SET);
+    if (-1 == res)
+        throwFromErrnoWithPath("Cannot seek through file " + getFileName(), getFileName(),
+            ErrorCodes::CANNOT_SEEK_THROUGH_FILE);
+
+    /// Clearing the buffer with existing data. New data will be read on subsequent call to 'next'.
+    working_buffer.resize(0);
+    pos = working_buffer.begin();
+}
+
+
 /// Assuming file descriptor supports 'select', check that we have data to read or wait until timeout.
 bool ReadBufferFromFileDescriptor::poll(size_t timeout_microseconds)
 {
diff --git a/src/IO/ReadBufferFromFileDescriptor.h b/src/IO/ReadBufferFromFileDescriptor.h
index bf22bb3d4a3c..1883c6802bc7 100644
--- a/src/IO/ReadBufferFromFileDescriptor.h
+++ b/src/IO/ReadBufferFromFileDescriptor.h
@@ -39,6 +39,9 @@ class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase
     /// If 'offset' is small enough to stay in buffer after seek, then true seek in file does not happen.
     off_t seek(off_t off, int whence) override;
 
+    /// Seek to the beginning, discarding already read data if any. Useful to reread file that changes on every read.
+    void rewind();
+
     off_t size();
 
     void setProgressCallback(ContextPtr context);
diff --git a/src/Interpreters/AsynchronousMetricLog.cpp b/src/Interpreters/AsynchronousMetricLog.cpp
index 79e2d513d5cc..c7003cff1695 100644
--- a/src/Interpreters/AsynchronousMetricLog.cpp
+++ b/src/Interpreters/AsynchronousMetricLog.cpp
@@ -18,7 +18,7 @@ NamesAndTypesList AsynchronousMetricLogElement::getNamesAndTypes()
         {"event_date", std::make_shared<DataTypeDate>()},
         {"event_time", std::make_shared<DataTypeDateTime>()},
         {"event_time_microseconds", std::make_shared<DataTypeDateTime64>(6)},
-        {"name", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},
+        {"metric", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},
         {"value", std::make_shared<DataTypeFloat64>(),}
     };
 }
diff --git a/src/Interpreters/AsynchronousMetrics.cpp b/src/Interpreters/AsynchronousMetrics.cpp
index 9803a2d8e9bd..11ecf5477145 100644
--- a/src/Interpreters/AsynchronousMetrics.cpp
+++ b/src/Interpreters/AsynchronousMetrics.cpp
@@ -7,12 +7,14 @@
 #include <Common/setThreadName.h>
 #include <Common/CurrentMetrics.h>
 #include <Common/typeid_cast.h>
+#include <Common/filesystemHelpers.h>
 #include <Server/ProtocolServerAdapter.h>
 #include <Storages/MarkCache.h>
 #include <Storages/StorageMergeTree.h>
 #include <Storages/StorageReplicatedMergeTree.h>
 #include <IO/UncompressedCache.h>
 #include <IO/MMappedFileCache.h>
+#include <IO/ReadHelpers.h>
 #include <Databases/IDatabase.h>
 #include <chrono>
 
@@ -35,6 +37,171 @@ namespace CurrentMetrics
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int CORRUPTED_DATA;
+    extern const int CANNOT_SYSCONF;
+}
+
+
+#if defined(OS_LINUX)
+
+static constexpr size_t small_buffer_size = 4096;
+
+static void openFileIfExists(const char * filename, std::optional<ReadBufferFromFile> & out)
+{
+    /// Ignoring time of check is not time of use cases, as procfs/sysfs files are fairly persistent.
+
+    std::error_code ec;
+    if (std::filesystem::is_regular_file(filename, ec))
+        out.emplace(filename, small_buffer_size);
+}
+
+static std::unique_ptr<ReadBufferFromFile> openFileIfExists(const std::string & filename)
+{
+    std::error_code ec;
+    if (std::filesystem::is_regular_file(filename, ec))
+        return std::make_unique<ReadBufferFromFile>(filename, small_buffer_size);
+    return {};
+}
+
+#endif
+
+
+AsynchronousMetrics::AsynchronousMetrics(
+    ContextPtr global_context_,
+    int update_period_seconds,
+    std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables_,
+    std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_)
+    : WithContext(global_context_)
+    , update_period(update_period_seconds)
+    , servers_to_start_before_tables(servers_to_start_before_tables_)
+    , servers(servers_)
+{
+#if defined(OS_LINUX)
+    openFileIfExists("/proc/meminfo", meminfo);
+    openFileIfExists("/proc/loadavg", loadavg);
+    openFileIfExists("/proc/stat", proc_stat);
+    openFileIfExists("/proc/cpuinfo", cpuinfo);
+    openFileIfExists("/proc/sys/fs/file-nr", file_nr);
+    openFileIfExists("/proc/uptime", uptime);
+    openFileIfExists("/proc/net/dev", net_dev);
+
+    for (size_t thermal_device_index = 0;; ++thermal_device_index)
+    {
+        std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(fmt::format("/sys/class/thermal/thermal_zone{}/temp", thermal_device_index));
+        if (!file)
+        {
+            /// Sometimes indices are from zero sometimes from one.
+            if (thermal_device_index == 0)
+                continue;
+            else
+                break;
+        }
+        thermal.emplace_back(std::move(file));
+    }
+
+    for (size_t hwmon_index = 0;; ++hwmon_index)
+    {
+        String hwmon_name_file = fmt::format("/sys/class/hwmon/hwmon{}/name", hwmon_index);
+        if (!std::filesystem::exists(hwmon_name_file))
+        {
+            if (hwmon_index == 0)
+                continue;
+            else
+                break;
+        }
+
+        String hwmon_name;
+        ReadBufferFromFile hwmon_name_in(hwmon_name_file, small_buffer_size);
+        readText(hwmon_name, hwmon_name_in);
+        std::replace(hwmon_name.begin(), hwmon_name.end(), ' ', '_');
+
+        for (size_t sensor_index = 0;; ++sensor_index)
+        {
+            String sensor_name_file = fmt::format("/sys/class/hwmon/hwmon{}/temp{}_label", hwmon_index, sensor_index);
+            String sensor_value_file = fmt::format("/sys/class/hwmon/hwmon{}/temp{}_input", hwmon_index, sensor_index);
+
+            bool sensor_name_file_exists = std::filesystem::exists(sensor_name_file);
+            bool sensor_value_file_exists = std::filesystem::exists(sensor_value_file);
+
+            /// Sometimes there are labels but there is no files with data or vice versa.
+            if (!sensor_name_file_exists && !sensor_value_file_exists)
+            {
+                if (sensor_index == 0)
+                    continue;
+                else
+                    break;
+            }
+
+            std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(sensor_value_file);
+            if (!file)
+                continue;
+
+            String sensor_name;
+            if (sensor_name_file_exists)
+            {
+                ReadBufferFromFile sensor_name_in(sensor_name_file, small_buffer_size);
+                readText(sensor_name, sensor_name_in);
+                std::replace(sensor_name.begin(), sensor_name.end(), ' ', '_');
+            }
+
+            hwmon_devices[hwmon_name][sensor_name] = std::move(file);
+        }
+    }
+
+    for (size_t edac_index = 0;; ++edac_index)
+    {
+        String edac_correctable_file = fmt::format("/sys/devices/system/edac/mc/mc{}/ce_count", edac_index);
+        String edac_uncorrectable_file = fmt::format("/sys/devices/system/edac/mc/mc{}/ue_count", edac_index);
+
+        bool edac_correctable_file_exists = std::filesystem::exists(edac_correctable_file);
+        bool edac_uncorrectable_file_exists = std::filesystem::exists(edac_uncorrectable_file);
+
+        if (!edac_correctable_file_exists && !edac_uncorrectable_file_exists)
+        {
+            if (edac_index == 0)
+                continue;
+            else
+                break;
+        }
+
+        edac.emplace_back();
+
+        if (edac_correctable_file_exists)
+            edac.back().first = openFileIfExists(edac_correctable_file);
+        if (edac_uncorrectable_file_exists)
+            edac.back().second = openFileIfExists(edac_uncorrectable_file);
+    }
+
+    if (std::filesystem::exists("/sys/block"))
+    {
+        for (const auto & device_dir : std::filesystem::directory_iterator("/sys/block"))
+        {
+            String device_name = device_dir.path().filename();
+
+            /// We are not interested in loopback devices.
+            if (device_name.starts_with("loop"))
+                continue;
+
+            std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(device_dir.path() / "stat");
+            if (!file)
+                continue;
+
+            block_devs[device_name] = std::move(file);
+        }
+    }
+#endif
+}
+
+void AsynchronousMetrics::start()
+{
+    /// Update once right now, to make metrics available just after server start
+    /// (without waiting for asynchronous_metrics_update_period_s).
+    update(std::chrono::system_clock::now());
+    thread = std::make_unique<ThreadFromGlobalPool>([this] { run(); });
+}
+
 AsynchronousMetrics::~AsynchronousMetrics()
 {
     try
@@ -91,10 +258,12 @@ void AsynchronousMetrics::run()
 
     while (true)
     {
+        auto next_update_time = get_next_update_time(update_period);
+
         {
             // Wait first, so that the first metric collection is also on even time.
             std::unique_lock lock{mutex};
-            if (wait_cond.wait_until(lock, get_next_update_time(update_period),
+            if (wait_cond.wait_until(lock, next_update_time,
                 [this] { return quit; }))
             {
                 break;
@@ -103,7 +272,7 @@ void AsynchronousMetrics::run()
 
         try
         {
-            update();
+            update(next_update_time);
         }
         catch (...)
         {
@@ -167,10 +336,162 @@ static void saveAllArenasMetric(AsynchronousMetricValues & values,
 }
 #endif
 
-void AsynchronousMetrics::update()
+
+#if defined(OS_LINUX)
+
+void AsynchronousMetrics::ProcStatValuesCPU::read(ReadBuffer & in)
+{
+    readText(user, in);
+    skipWhitespaceIfAny(in, true);
+    readText(nice, in);
+    skipWhitespaceIfAny(in, true);
+    readText(system, in);
+    skipWhitespaceIfAny(in, true);
+    readText(idle, in);
+    skipWhitespaceIfAny(in, true);
+    readText(iowait, in);
+    skipWhitespaceIfAny(in, true);
+    readText(irq, in);
+    skipWhitespaceIfAny(in, true);
+    readText(softirq, in);
+
+    /// Just in case for old Linux kernels, we check if these values present.
+
+    if (!checkChar('
', in))
+    {
+        skipWhitespaceIfAny(in, true);
+        readText(steal, in);
+    }
+
+    if (!checkChar('
', in))
+    {
+        skipWhitespaceIfAny(in, true);
+        readText(guest, in);
+    }
+
+    if (!checkChar('
', in))
+    {
+        skipWhitespaceIfAny(in, true);
+        readText(guest_nice, in);
+    }
+
+    skipToNextLineOrEOF(in);
+}
+
+AsynchronousMetrics::ProcStatValuesCPU
+AsynchronousMetrics::ProcStatValuesCPU::operator-(const AsynchronousMetrics::ProcStatValuesCPU & other) const
+{
+    ProcStatValuesCPU res{};
+    res.user = user - other.user;
+    res.nice = nice - other.nice;
+    res.system = system - other.system;
+    res.idle = idle - other.idle;
+    res.iowait = iowait - other.iowait;
+    res.irq = irq - other.irq;
+    res.softirq = softirq - other.softirq;
+    res.steal = steal - other.steal;
+    res.guest = guest - other.guest;
+    res.guest_nice = guest_nice - other.guest_nice;
+    return res;
+}
+
+AsynchronousMetrics::ProcStatValuesOther
+AsynchronousMetrics::ProcStatValuesOther::operator-(const AsynchronousMetrics::ProcStatValuesOther & other) const
+{
+    ProcStatValuesOther res{};
+    res.interrupts = interrupts - other.interrupts;
+    res.context_switches = context_switches - other.context_switches;
+    res.processes_created = processes_created - other.processes_created;
+    return res;
+}
+
+void AsynchronousMetrics::BlockDeviceStatValues::read(ReadBuffer & in)
+{
+    skipWhitespaceIfAny(in, true);
+    readText(read_ios, in);
+    skipWhitespaceIfAny(in, true);
+    readText(read_merges, in);
+    skipWhitespaceIfAny(in, true);
+    readText(read_sectors, in);
+    skipWhitespaceIfAny(in, true);
+    readText(read_ticks, in);
+    skipWhitespaceIfAny(in, true);
+    readText(write_ios, in);
+    skipWhitespaceIfAny(in, true);
+    readText(write_merges, in);
+    skipWhitespaceIfAny(in, true);
+    readText(write_sectors, in);
+    skipWhitespaceIfAny(in, true);
+    readText(write_ticks, in);
+    skipWhitespaceIfAny(in, true);
+    readText(in_flight_ios, in);
+    skipWhitespaceIfAny(in, true);
+    readText(io_ticks, in);
+    skipWhitespaceIfAny(in, true);
+    readText(time_in_queue, in);
+    skipWhitespaceIfAny(in, true);
+    readText(discard_ops, in);
+    skipWhitespaceIfAny(in, true);
+    readText(discard_merges, in);
+    skipWhitespaceIfAny(in, true);
+    readText(discard_sectors, in);
+    skipWhitespaceIfAny(in, true);
+    readText(discard_ticks, in);
+}
+
+AsynchronousMetrics::BlockDeviceStatValues
+AsynchronousMetrics::BlockDeviceStatValues::operator-(const AsynchronousMetrics::BlockDeviceStatValues & other) const
+{
+    BlockDeviceStatValues res{};
+    res.read_ios = read_ios - other.read_ios;
+    res.read_merges = read_merges - other.read_merges;
+    res.read_sectors = read_sectors - other.read_sectors;
+    res.read_ticks = read_ticks - other.read_ticks;
+    res.write_ios = write_ios - other.write_ios;
+    res.write_merges = write_merges - other.write_merges;
+    res.write_sectors = write_sectors - other.write_sectors;
+    res.write_ticks = write_ticks - other.write_ticks;
+    res.in_flight_ios = in_flight_ios; /// This is current value, not total.
+    res.io_ticks = io_ticks - other.io_ticks;
+    res.time_in_queue = time_in_queue - other.time_in_queue;
+    res.discard_ops = discard_ops - other.discard_ops;
+    res.discard_merges = discard_merges - other.discard_merges;
+    res.discard_sectors = discard_sectors - other.discard_sectors;
+    res.discard_ticks = discard_ticks - other.discard_ticks;
+    return res;
+}
+
+AsynchronousMetrics::NetworkInterfaceStatValues
+AsynchronousMetrics::NetworkInterfaceStatValues::operator-(const AsynchronousMetrics::NetworkInterfaceStatValues & other) const
+{
+    NetworkInterfaceStatValues res{};
+    res.recv_bytes = recv_bytes - other.recv_bytes;
+    res.recv_packets = recv_packets - other.recv_packets;
+    res.recv_errors = recv_errors - other.recv_errors;
+    res.recv_drop = recv_drop - other.recv_drop;
+    res.send_bytes = send_bytes - other.send_bytes;
+    res.send_packets = send_packets - other.send_packets;
+    res.send_errors = send_errors - other.send_errors;
+    res.send_drop = send_drop - other.send_drop;
+    return res;
+}
+
+#endif
+
+
+void AsynchronousMetrics::update(std::chrono::system_clock::time_point update_time)
 {
+    Stopwatch watch;
+
     AsynchronousMetricValues new_values;
 
+    auto current_time = std::chrono::system_clock::now();
+    auto time_after_previous_update [[maybe_unused]] = current_time - previous_update_time;
+    previous_update_time = update_time;
+
+    /// This is also a good indicator of system responsiveness.
+    new_values["Jitter"] = std::chrono::duration_cast<std::chrono::nanoseconds>(current_time - update_time).count() / 1e9;
+
     {
         if (auto mark_cache = getContext()->getMarkCache())
         {
@@ -206,7 +527,7 @@ void AsynchronousMetrics::update()
 
     new_values["Uptime"] = getContext()->getUptimeSeconds();
 
-    /// Process memory usage according to OS
+    /// Process process memory usage according to OS
 #if defined(OS_LINUX)
     {
         MemoryStatisticsOS::Data data = memory_stat.get();
@@ -237,8 +558,581 @@ void AsynchronousMetrics::update()
             CurrentMetrics::set(CurrentMetrics::MemoryTracking, new_amount);
         }
     }
+
+    if (loadavg)
+    {
+        try
+        {
+            loadavg->rewind();
+
+            Float64 loadavg1 = 0;
+            Float64 loadavg5 = 0;
+            Float64 loadavg15 = 0;
+            UInt64 threads_runnable = 0;
+            UInt64 threads_total = 0;
+
+            readText(loadavg1, *loadavg);
+            skipWhitespaceIfAny(*loadavg);
+            readText(loadavg5, *loadavg);
+            skipWhitespaceIfAny(*loadavg);
+            readText(loadavg15, *loadavg);
+            skipWhitespaceIfAny(*loadavg);
+            readText(threads_runnable, *loadavg);
+            assertChar('/', *loadavg);
+            readText(threads_total, *loadavg);
+
+            new_values["LoadAverage1"] = loadavg1;
+            new_values["LoadAverage5"] = loadavg5;
+            new_values["LoadAverage15"] = loadavg15;
+            new_values["OSThreadsRunnable"] = threads_runnable;
+            new_values["OSThreadsTotal"] = threads_total;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    if (uptime)
+    {
+        try
+        {
+            uptime->rewind();
+
+            Float64 uptime_seconds = 0;
+            readText(uptime_seconds, *uptime);
+
+            new_values["OSUptime"] = uptime_seconds;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    if (proc_stat)
+    {
+        try
+        {
+            proc_stat->rewind();
+
+            int64_t hz = sysconf(_SC_CLK_TCK);
+            if (-1 == hz)
+                throwFromErrno("Cannot call 'sysconf' to obtain system HZ", ErrorCodes::CANNOT_SYSCONF);
+
+            double multiplier = 1.0 / hz / (std::chrono::duration_cast<std::chrono::nanoseconds>(time_after_previous_update).count() / 1e9);
+            size_t num_cpus = 0;
+
+            ProcStatValuesOther current_other_values{};
+            ProcStatValuesCPU delta_values_all_cpus{};
+
+            while (!proc_stat->eof())
+            {
+                String name;
+                readStringUntilWhitespace(name, *proc_stat);
+                skipWhitespaceIfAny(*proc_stat);
+
+                if (name.starts_with("cpu"))
+                {
+                    String cpu_num_str = name.substr(strlen("cpu"));
+                    UInt64 cpu_num = 0;
+                    if (!cpu_num_str.empty())
+                    {
+                        cpu_num = parse<UInt64>(cpu_num_str);
+
+                        if (cpu_num > 1000000) /// Safety check, arbitrary large number, suitable for supercomputing applications.
+                            throw Exception(ErrorCodes::CORRUPTED_DATA, "Too many CPUs (at least {}) in '/proc/stat' file", cpu_num);
+
+                        if (proc_stat_values_per_cpu.size() <= cpu_num)
+                            proc_stat_values_per_cpu.resize(cpu_num + 1);
+                    }
+
+                    ProcStatValuesCPU current_values{};
+                    current_values.read(*proc_stat);
+
+                    ProcStatValuesCPU & prev_values = !cpu_num_str.empty() ? proc_stat_values_per_cpu[cpu_num] : proc_stat_values_all_cpus;
+
+                    if (!first_run)
+                    {
+                        ProcStatValuesCPU delta_values = current_values - prev_values;
+
+                        String cpu_suffix;
+                        if (!cpu_num_str.empty())
+                        {
+                            cpu_suffix = "CPU" + cpu_num_str;
+                            ++num_cpus;
+                        }
+                        else
+                            delta_values_all_cpus = delta_values;
+
+                        new_values["OSUserTime" + cpu_suffix] = delta_values.user * multiplier;
+                        new_values["OSNiceTime" + cpu_suffix] = delta_values.nice * multiplier;
+                        new_values["OSSystemTime" + cpu_suffix] = delta_values.system * multiplier;
+                        new_values["OSIdleTime" + cpu_suffix] = delta_values.idle * multiplier;
+                        new_values["OSIOWaitTime" + cpu_suffix] = delta_values.iowait * multiplier;
+                        new_values["OSIrqTime" + cpu_suffix] = delta_values.irq * multiplier;
+                        new_values["OSSoftIrqTime" + cpu_suffix] = delta_values.softirq * multiplier;
+                        new_values["OSStealTime" + cpu_suffix] = delta_values.steal * multiplier;
+                        new_values["OSGuestTime" + cpu_suffix] = delta_values.guest * multiplier;
+                        new_values["OSGuestNiceTime" + cpu_suffix] = delta_values.guest_nice * multiplier;
+                    }
+
+                    prev_values = current_values;
+                }
+                else if (name == "intr")
+                {
+                    readText(current_other_values.interrupts, *proc_stat);
+                    skipToNextLineOrEOF(*proc_stat);
+                }
+                else if (name == "ctxt")
+                {
+                    readText(current_other_values.context_switches, *proc_stat);
+                    skipToNextLineOrEOF(*proc_stat);
+                }
+                else if (name == "processes")
+                {
+                    readText(current_other_values.processes_created, *proc_stat);
+                    skipToNextLineOrEOF(*proc_stat);
+                }
+                else if (name == "procs_running")
+                {
+                    UInt64 processes_running = 0;
+                    readText(processes_running, *proc_stat);
+                    skipToNextLineOrEOF(*proc_stat);
+                    new_values["OSProcessesRunning"] = processes_running;
+                }
+                else if (name == "procs_blocked")
+                {
+                    UInt64 processes_blocked = 0;
+                    readText(processes_blocked, *proc_stat);
+                    skipToNextLineOrEOF(*proc_stat);
+                    new_values["OSProcessesBlocked"] = processes_blocked;
+                }
+                else
+                    skipToNextLineOrEOF(*proc_stat);
+            }
+
+            if (!first_run)
+            {
+                ProcStatValuesOther delta_values = current_other_values - proc_stat_values_other;
+
+                new_values["OSInterrupts"] = delta_values.interrupts * multiplier;
+                new_values["OSContextSwitches"] = delta_values.context_switches * multiplier;
+                new_values["OSProcessesCreated"] = delta_values.processes_created * multiplier;
+
+                /// Also write values normalized to 0..1 by diving to the number of CPUs.
+                /// These values are good to be averaged across the cluster of non-uniform servers.
+
+                if (num_cpus)
+                {
+                    new_values["OSUserTimeNormalized"] = delta_values_all_cpus.user * multiplier / num_cpus;
+                    new_values["OSNiceTimeNormalized"] = delta_values_all_cpus.nice * multiplier / num_cpus;
+                    new_values["OSSystemTimeNormalized"] = delta_values_all_cpus.system * multiplier / num_cpus;
+                    new_values["OSIdleTimeNormalized"] = delta_values_all_cpus.idle * multiplier / num_cpus;
+                    new_values["OSIOWaitTimeNormalized"] = delta_values_all_cpus.iowait * multiplier / num_cpus;
+                    new_values["OSIrqTimeNormalized"] = delta_values_all_cpus.irq * multiplier / num_cpus;
+                    new_values["OSSoftIrqTimeNormalized"] = delta_values_all_cpus.softirq * multiplier / num_cpus;
+                    new_values["OSStealTimeNormalized"] = delta_values_all_cpus.steal * multiplier / num_cpus;
+                    new_values["OSGuestTimeNormalized"] = delta_values_all_cpus.guest * multiplier / num_cpus;
+                    new_values["OSGuestNiceTimeNormalized"] = delta_values_all_cpus.guest_nice * multiplier / num_cpus;
+                }
+            }
+
+            proc_stat_values_other = current_other_values;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    if (meminfo)
+    {
+        try
+        {
+            meminfo->rewind();
+
+            uint64_t free_plus_cached_bytes = 0;
+
+            while (!meminfo->eof())
+            {
+                String name;
+                readStringUntilWhitespace(name, *meminfo);
+                skipWhitespaceIfAny(*meminfo, true);
+
+                uint64_t kb = 0;
+                readText(kb, *meminfo);
+                if (kb)
+                {
+                    skipWhitespaceIfAny(*meminfo, true);
+                    assertString("kB", *meminfo);
+
+                    uint64_t bytes = kb * 1024;
+
+                    if (name == "MemTotal:")
+                    {
+                        new_values["OSMemoryTotal"] = bytes;
+                    }
+                    else if (name == "MemFree:")
+                    {
+                        /// We cannot simply name this metric "Free", because it confuses users.
+                        /// See https://www.linuxatemyram.com/
+                        /// For convenience we also provide OSMemoryFreePlusCached, that should be somewhat similar to OSMemoryAvailable.
+
+                        free_plus_cached_bytes += bytes;
+                        new_values["OSMemoryFreeWithoutCached"] = bytes;
+                    }
+                    else if (name == "MemAvailable:")
+                    {
+                        new_values["OSMemoryAvailable"] = bytes;
+                    }
+                    else if (name == "Buffers:")
+                    {
+                        new_values["OSMemoryBuffers"] = bytes;
+                    }
+                    else if (name == "Cached:")
+                    {
+                        free_plus_cached_bytes += bytes;
+                        new_values["OSMemoryCached"] = bytes;
+                    }
+                    else if (name == "SwapCached:")
+                    {
+                        new_values["OSMemorySwapCached"] = bytes;
+                    }
+                }
+
+                skipToNextLineOrEOF(*meminfo);
+            }
+
+            new_values["OSMemoryFreePlusCached"] = free_plus_cached_bytes;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    // Try to add processor frequencies, ignoring errors.
+    if (cpuinfo)
+    {
+        try
+        {
+            cpuinfo->rewind();
+
+            // We need the following lines:
+            // processor : 4
+            // cpu MHz : 4052.941
+            // They contain tabs and are interspersed with other info.
+
+            int core_id = 0;
+            while (!cpuinfo->eof())
+            {
+                std::string s;
+                // We don't have any backslash escape sequences in /proc/cpuinfo, so
+                // this function will read the line until EOL, which is exactly what
+                // we need.
+                readEscapedStringUntilEOL(s, *cpuinfo);
+                // It doesn't read the EOL itself.
+                ++cpuinfo->position();
+
+                if (s.rfind("processor", 0) == 0)
+                {
+                    if (auto colon = s.find_first_of(':'))
+                    {
+                        core_id = std::stoi(s.substr(colon + 2));
+                    }
+                }
+                else if (s.rfind("cpu MHz", 0) == 0)
+                {
+                    if (auto colon = s.find_first_of(':'))
+                    {
+                        auto mhz = std::stod(s.substr(colon + 2));
+                        new_values[fmt::format("CPUFrequencyMHz_{}", core_id)] = mhz;
+                    }
+                }
+            }
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    if (file_nr)
+    {
+        try
+        {
+            file_nr->rewind();
+
+            uint64_t open_files = 0;
+            readText(open_files, *file_nr);
+            new_values["OSOpenFiles"] = open_files;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    for (auto & [name, device] : block_devs)
+    {
+        try
+        {
+            device->rewind();
+
+            BlockDeviceStatValues current_values{};
+            BlockDeviceStatValues & prev_values = block_device_stats[name];
+            current_values.read(*device);
+
+            BlockDeviceStatValues delta_values = current_values - prev_values;
+            prev_values = current_values;
+
+            if (first_run)
+                continue;
+
+            /// Always 512 according to the docs.
+            static constexpr size_t sector_size = 512;
+
+            /// Always in milliseconds according to the docs.
+            static constexpr double time_multiplier = 1e-6;
+
+            new_values["BlockReadOps_" + name] = delta_values.read_ios;
+            new_values["BlockWriteOps_" + name] = delta_values.write_ios;
+            new_values["BlockDiscardOps_" + name] = delta_values.discard_ops;
+
+            new_values["BlockReadMerges_" + name] = delta_values.read_merges;
+            new_values["BlockWriteMerges_" + name] = delta_values.write_merges;
+            new_values["BlockDiscardMerges_" + name] = delta_values.discard_merges;
+
+            new_values["BlockReadBytes_" + name] = delta_values.read_sectors * sector_size;
+            new_values["BlockWriteBytes_" + name] = delta_values.write_sectors * sector_size;
+            new_values["BlockDiscardBytes_" + name] = delta_values.discard_sectors * sector_size;
+
+            new_values["BlockReadTime_" + name] = delta_values.read_ticks * time_multiplier;
+            new_values["BlockWriteTime_" + name] = delta_values.write_ticks * time_multiplier;
+            new_values["BlockDiscardTime_" + name] = delta_values.discard_ticks * time_multiplier;
+
+            new_values["BlockInFlightOps_" + name] = delta_values.in_flight_ios;
+
+            new_values["BlockActiveTime_" + name] = delta_values.io_ticks * time_multiplier;
+            new_values["BlockQueueTime_" + name] = delta_values.time_in_queue * time_multiplier;
+
+            if (delta_values.in_flight_ios)
+            {
+                /// TODO Check if these values are meaningful.
+
+                new_values["BlockActiveTimePerOp_" + name] = delta_values.io_ticks * time_multiplier / delta_values.in_flight_ios;
+                new_values["BlockQueueTimePerOp_" + name] = delta_values.time_in_queue * time_multiplier / delta_values.in_flight_ios;
+            }
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    if (net_dev)
+    {
+        try
+        {
+            net_dev->rewind();
+
+            /// Skip first two lines:
+            /// Inter-|   Receive                                                |  Transmit
+            ///  face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
+
+            skipToNextLineOrEOF(*net_dev);
+            skipToNextLineOrEOF(*net_dev);
+
+            while (!net_dev->eof())
+            {
+                skipWhitespaceIfAny(*net_dev, true);
+                String interface_name;
+                readStringUntilWhitespace(interface_name, *net_dev);
+
+                /// We are not interested in loopback devices.
+                if (!interface_name.ends_with(':') || interface_name == "lo:" || interface_name.size() <= 1)
+                {
+                    skipToNextLineOrEOF(*net_dev);
+                    continue;
+                }
+
+                interface_name.pop_back();
+
+                NetworkInterfaceStatValues current_values{};
+                uint64_t unused;
+
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.recv_bytes, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.recv_packets, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.recv_errors, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.recv_drop, *net_dev);
+
+                /// NOTE We should pay more attention to the number of fields.
+
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(unused, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(unused, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(unused, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(unused, *net_dev);
+
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.send_bytes, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.send_packets, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.send_errors, *net_dev);
+                skipWhitespaceIfAny(*net_dev, true);
+                readText(current_values.send_drop, *net_dev);
+
+                skipToNextLineOrEOF(*net_dev);
+
+                NetworkInterfaceStatValues & prev_values = network_interface_stats[interface_name];
+                NetworkInterfaceStatValues delta_values = current_values - prev_values;
+                prev_values = current_values;
+
+                if (!first_run)
+                {
+                    new_values["NetworkReceiveBytes_" + interface_name] = delta_values.recv_bytes;
+                    new_values["NetworkReceivePackets_" + interface_name] = delta_values.recv_packets;
+                    new_values["NetworkReceiveErrors_" + interface_name] = delta_values.recv_errors;
+                    new_values["NetworkReceiveDrop_" + interface_name] = delta_values.recv_drop;
+
+                    new_values["NetworkSendBytes_" + interface_name] = delta_values.send_bytes;
+                    new_values["NetworkSendPackets_" + interface_name] = delta_values.send_packets;
+                    new_values["NetworkSendErrors_" + interface_name] = delta_values.send_errors;
+                    new_values["NetworkSendDrop_" + interface_name] = delta_values.send_drop;
+                }
+            }
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    for (size_t i = 0, size = thermal.size(); i < size; ++i)
+    {
+        try
+        {
+            ReadBufferFromFile & in = *thermal[i];
+
+            in.rewind();
+            uint64_t temperature = 0;
+            readText(temperature, in);
+            new_values[fmt::format("Temperature{}", i)] = temperature * 0.001;
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    for (const auto & [hwmon_name, sensors] : hwmon_devices)
+    {
+        try
+        {
+            for (const auto & [sensor_name, sensor_file] : sensors)
+            {
+                sensor_file->rewind();
+                uint64_t temperature = 0;
+                readText(temperature, *sensor_file);
+
+                if (sensor_name.empty())
+                    new_values[fmt::format("Temperature_{}", hwmon_name)] = temperature * 0.001;
+                else
+                    new_values[fmt::format("Temperature_{}_{}", hwmon_name, sensor_name)] = temperature * 0.001;
+            }
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
+
+    for (size_t i = 0, size = edac.size(); i < size; ++i)
+    {
+        /// NOTE maybe we need to take difference with previous values.
+        /// But these metrics should be exceptionally rare, so it's ok to keep them accumulated.
+
+        try
+        {
+            if (edac[i].first)
+            {
+                ReadBufferFromFile & in = *edac[i].first;
+                in.rewind();
+                uint64_t errors = 0;
+                readText(errors, in);
+                new_values[fmt::format("EDAC{}_Correctable", i)] = errors;
+            }
+
+            if (edac[i].second)
+            {
+                ReadBufferFromFile & in = *edac[i].second;
+                in.rewind();
+                uint64_t errors = 0;
+                readText(errors, in);
+                new_values[fmt::format("EDAC{}_Uncorrectable", i)] = errors;
+            }
+        }
+        catch (...)
+        {
+            tryLogCurrentException(__PRETTY_FUNCTION__);
+        }
+    }
 #endif
 
+    /// Free space in filesystems at data path and logs path.
+    {
+        auto stat = getStatVFS(getContext()->getPath());
+
+        new_values["FilesystemMainPathTotalBytes"] = stat.f_blocks * stat.f_bsize;
+        new_values["FilesystemMainPathAvailableBytes"] = stat.f_bavail * stat.f_bsize;
+        new_values["FilesystemMainPathUsedBytes"] = (stat.f_blocks - stat.f_bavail) * stat.f_bsize;
+        new_values["FilesystemMainPathTotalINodes"] = stat.f_files;
+        new_values["FilesystemMainPathAvailableINodes"] = stat.f_favail;
+        new_values["FilesystemMainPathUsedINodes"] = stat.f_files - stat.f_favail;
+    }
+
+    {
+        /// Current working directory of the server is the directory with logs.
+        auto stat = getStatVFS(".");
+
+        new_values["FilesystemLogsPathTotalBytes"] = stat.f_blocks * stat.f_bsize;
+        new_values["FilesystemLogsPathAvailableBytes"] = stat.f_bavail * stat.f_bsize;
+        new_values["FilesystemLogsPathUsedBytes"] = (stat.f_blocks - stat.f_bavail) * stat.f_bsize;
+        new_values["FilesystemLogsPathTotalINodes"] = stat.f_files;
+        new_values["FilesystemLogsPathAvailableINodes"] = stat.f_favail;
+        new_values["FilesystemLogsPathUsedINodes"] = stat.f_files - stat.f_favail;
+    }
+
+    /// Free and total space on every configured disk.
+    {
+        DisksMap disks_map = getContext()->getDisksMap();
+        for (const auto & [name, disk] : disks_map)
+        {
+            auto total = disk->getTotalSpace();
+
+            /// Some disks don't support information about the space.
+            if (!total)
+                continue;
+
+            auto available = disk->getAvailableSpace();
+            auto unreserved = disk->getUnreservedSpace();
+
+            new_values[fmt::format("DiskTotal_{}", name)] = total;
+            new_values[fmt::format("DiskUsed_{}", name)] = total - available;
+            new_values[fmt::format("DiskAvailable_{}", name)] = available;
+            new_values[fmt::format("DiskUnreserved_{}", name)] = unreserved;
+        }
+    }
+
     {
         auto databases = DatabaseCatalog::instance().getDatabases();
 
@@ -267,6 +1161,7 @@ void AsynchronousMetrics::update()
             /// Check if database can contain MergeTree tables
             if (!db.second->canContainMergeTreeTables())
                 continue;
+
             for (auto iterator = db.second->getTablesIterator(getContext()); iterator->isValid(); iterator->next())
             {
                 ++total_number_of_tables;
@@ -274,10 +1169,17 @@ void AsynchronousMetrics::update()
                 if (!table)
                     continue;
 
-                StorageMergeTree * table_merge_tree = dynamic_cast<StorageMergeTree *>(table.get());
-                StorageReplicatedMergeTree * table_replicated_merge_tree = dynamic_cast<StorageReplicatedMergeTree *>(table.get());
+                if (MergeTreeData * table_merge_tree = dynamic_cast<MergeTreeData *>(table.get()))
+                {
+                    const auto & settings = getContext()->getSettingsRef();
 
-                if (table_replicated_merge_tree)
+                    calculateMax(max_part_count_for_partition, table_merge_tree->getMaxPartsCountForPartition());
+                    total_number_of_bytes += table_merge_tree->totalBytes(settings).value();
+                    total_number_of_rows += table_merge_tree->totalRows(settings).value();
+                    total_number_of_parts += table_merge_tree->getPartsCount();
+                }
+
+                if (StorageReplicatedMergeTree * table_replicated_merge_tree = dynamic_cast<StorageReplicatedMergeTree *>(table.get()))
                 {
                     StorageReplicatedMergeTree::Status status;
                     table_replicated_merge_tree->getStatus(status, false);
@@ -303,24 +1205,6 @@ void AsynchronousMetrics::update()
                                 "Cannot get replica delay for table: " + backQuoteIfNeed(db.first) + "." + backQuoteIfNeed(iterator->name()));
                         }
                     }
-
-                    calculateMax(max_part_count_for_partition, table_replicated_merge_tree->getMaxPartsCountForPartition());
-                }
-
-                if (table_merge_tree)
-                {
-                    calculateMax(max_part_count_for_partition, table_merge_tree->getMaxPartsCountForPartition());
-                    const auto & settings = getContext()->getSettingsRef();
-                    total_number_of_bytes += table_merge_tree->totalBytes(settings).value();
-                    total_number_of_rows += table_merge_tree->totalRows(settings).value();
-                    total_number_of_parts += table_merge_tree->getPartsCount();
-                }
-                if (table_replicated_merge_tree)
-                {
-                    const auto & settings = getContext()->getSettingsRef();
-                    total_number_of_bytes += table_replicated_merge_tree->totalBytes(settings).value();
-                    total_number_of_rows += table_replicated_merge_tree->totalRows(settings).value();
-                    total_number_of_parts += table_replicated_merge_tree->getPartsCount();
                 }
             }
         }
@@ -347,7 +1231,8 @@ void AsynchronousMetrics::update()
 
         auto get_metric_name = [](const String & name) -> const char *
         {
-            static std::map<String, const char *> metric_map = {
+            static std::map<String, const char *> metric_map =
+            {
                 {"tcp_port", "TCPThreads"},
                 {"tcp_port_secure", "TCPSecureThreads"},
                 {"http_port", "HTTPThreads"},
@@ -410,58 +1295,18 @@ void AsynchronousMetrics::update()
     saveAllArenasMetric<size_t>(new_values, "muzzy_purged");
 #endif
 
-#if defined(OS_LINUX)
-    // Try to add processor frequencies, ignoring errors.
-    try
-    {
-        ReadBufferFromFile buf("/proc/cpuinfo", 32768 /* buf_size */);
-
-        // We need the following lines:
-        // processor : 4
-        // cpu MHz : 4052.941
-        // They contain tabs and are interspersed with other info.
-        int core_id = 0;
-        while (!buf.eof())
-        {
-            std::string s;
-            // We don't have any backslash escape sequences in /proc/cpuinfo, so
-            // this function will read the line until EOL, which is exactly what
-            // we need.
-            readEscapedStringUntilEOL(s, buf);
-            // It doesn't read the EOL itself.
-            ++buf.position();
-
-            if (s.rfind("processor", 0) == 0)
-            {
-                if (auto colon = s.find_first_of(':'))
-                {
-                    core_id = std::stoi(s.substr(colon + 2));
-                }
-            }
-            else if (s.rfind("cpu MHz", 0) == 0)
-            {
-                if (auto colon = s.find_first_of(':'))
-                {
-                    auto mhz = std::stod(s.substr(colon + 2));
-                    new_values[fmt::format("CPUFrequencyMHz_{}", core_id)] = mhz;
-                }
-            }
-        }
-    }
-    catch (...)
-    {
-        tryLogCurrentException(__PRETTY_FUNCTION__);
-    }
-#endif
-
     /// Add more metrics as you wish.
 
-    // Log the new metrics.
+    new_values["AsynchronousMetricsCalculationTimeSpent"] = watch.elapsedSeconds();
+
+    /// Log the new metrics.
     if (auto log = getContext()->getAsynchronousMetricLog())
     {
         log->addValues(new_values);
     }
 
+    first_run = false;
+
     // Finally, update the current metrics.
     std::lock_guard lock(mutex);
     values = new_values;
diff --git a/src/Interpreters/AsynchronousMetrics.h b/src/Interpreters/AsynchronousMetrics.h
index 38875c21edd5..606d117e6059 100644
--- a/src/Interpreters/AsynchronousMetrics.h
+++ b/src/Interpreters/AsynchronousMetrics.h
@@ -3,11 +3,15 @@
 #include <Interpreters/Context_fwd.h>
 #include <Common/MemoryStatisticsOS.h>
 #include <Common/ThreadPool.h>
+#include <IO/ReadBufferFromFile.h>
 
 #include <condition_variable>
+#include <map>
 #include <mutex>
 #include <string>
 #include <thread>
+#include <vector>
+#include <optional>
 #include <unordered_map>
 
 
@@ -15,6 +19,7 @@ namespace DB
 {
 
 class ProtocolServerAdapter;
+class ReadBuffer;
 
 using AsynchronousMetricValue = double;
 using AsynchronousMetricValues = std::unordered_map<std::string, AsynchronousMetricValue>;
@@ -23,22 +28,13 @@ using AsynchronousMetricValues = std::unordered_map<std::string, AsynchronousMet
 /** Periodically (by default, each minute, starting at 30 seconds offset)
   *  calculates and updates some metrics,
   *  that are not updated automatically (so, need to be asynchronously calculated).
+  *
+  * This includes both ClickHouse-related metrics (like memory usage of ClickHouse process)
+  *  and common OS-related metrics (like total memory usage on the server).
   */
 class AsynchronousMetrics : WithContext
 {
 public:
-#if defined(ARCADIA_BUILD)
-    /// This constructor needs only to provide backward compatibility with some other projects (hello, Arcadia).
-    /// Never use this in the ClickHouse codebase.
-    AsynchronousMetrics(
-        ContextPtr global_context_,
-        int update_period_seconds = 60)
-        : WithContext(global_context_)
-        , update_period(update_period_seconds)
-    {
-    }
-#endif
-
     /// The default value of update_period_seconds is for ClickHouse-over-YT
     /// in Arcadia -- it uses its own server implementation that also uses these
     /// metrics.
@@ -46,28 +42,28 @@ class AsynchronousMetrics : WithContext
         ContextPtr global_context_,
         int update_period_seconds,
         std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables_,
-        std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_)
-        : WithContext(global_context_)
-        , update_period(update_period_seconds)
-        , servers_to_start_before_tables(servers_to_start_before_tables_)
-        , servers(servers_)
-    {
-    }
+        std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_);
 
     ~AsynchronousMetrics();
 
     /// Separate method allows to initialize the `servers` variable beforehand.
-    void start()
-    {
-        /// Update once right now, to make metrics available just after server start
-        /// (without waiting for asynchronous_metrics_update_period_s).
-        update();
-        thread = std::make_unique<ThreadFromGlobalPool>([this] { run(); });
-    }
+    void start();
 
     /// Returns copy of all values.
     AsynchronousMetricValues getValues() const;
 
+#if defined(ARCADIA_BUILD)
+    /// This constructor needs only to provide backward compatibility with some other projects (hello, Arcadia).
+    /// Never use this in the ClickHouse codebase.
+    AsynchronousMetrics(
+        ContextPtr global_context_,
+        int update_period_seconds = 60)
+        : WithContext(global_context_)
+        , update_period(update_period_seconds)
+    {
+    }
+#endif
+
 private:
     const std::chrono::seconds update_period;
     std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables{nullptr};
@@ -78,14 +74,113 @@ class AsynchronousMetrics : WithContext
     bool quit {false};
     AsynchronousMetricValues values;
 
+    /// Some values are incremental and we have to calculate the difference.
+    /// On first run we will only collect the values to subtract later.
+    bool first_run = true;
+    std::chrono::system_clock::time_point previous_update_time;
+
 #if defined(OS_LINUX)
     MemoryStatisticsOS memory_stat;
+
+    std::optional<ReadBufferFromFile> meminfo;
+    std::optional<ReadBufferFromFile> loadavg;
+    std::optional<ReadBufferFromFile> proc_stat;
+    std::optional<ReadBufferFromFile> cpuinfo;
+    std::optional<ReadBufferFromFile> file_nr;
+    std::optional<ReadBufferFromFile> uptime;
+    std::optional<ReadBufferFromFile> net_dev;
+
+    std::vector<std::unique_ptr<ReadBufferFromFile>> thermal;
+
+    std::unordered_map<String /* device name */,
+        std::unordered_map<String /* label name */,
+            std::unique_ptr<ReadBufferFromFile>>> hwmon_devices;
+
+    std::vector<std::pair<
+        std::unique_ptr<ReadBufferFromFile> /* correctable errors */,
+        std::unique_ptr<ReadBufferFromFile> /* uncorrectable errors */>> edac;
+
+    std::unordered_map<String /* device name */, std::unique_ptr<ReadBufferFromFile>> block_devs;
+
+    /// TODO: socket statistics.
+
+    struct ProcStatValuesCPU
+    {
+        uint64_t user;
+        uint64_t nice;
+        uint64_t system;
+        uint64_t idle;
+        uint64_t iowait;
+        uint64_t irq;
+        uint64_t softirq;
+        uint64_t steal;
+        uint64_t guest;
+        uint64_t guest_nice;
+
+        void read(ReadBuffer & in);
+        ProcStatValuesCPU operator-(const ProcStatValuesCPU & other) const;
+    };
+
+    struct ProcStatValuesOther
+    {
+        uint64_t interrupts;
+        uint64_t context_switches;
+        uint64_t processes_created;
+
+        ProcStatValuesOther operator-(const ProcStatValuesOther & other) const;
+    };
+
+    ProcStatValuesCPU proc_stat_values_all_cpus{};
+    ProcStatValuesOther proc_stat_values_other{};
+    std::vector<ProcStatValuesCPU> proc_stat_values_per_cpu;
+
+    /// https://www.kernel.org/doc/Documentation/block/stat.txt
+    struct BlockDeviceStatValues
+    {
+        uint64_t read_ios;
+        uint64_t read_merges;
+        uint64_t read_sectors;
+        uint64_t read_ticks;
+        uint64_t write_ios;
+        uint64_t write_merges;
+        uint64_t write_sectors;
+        uint64_t write_ticks;
+        uint64_t in_flight_ios;
+        uint64_t io_ticks;
+        uint64_t time_in_queue;
+        uint64_t discard_ops;
+        uint64_t discard_merges;
+        uint64_t discard_sectors;
+        uint64_t discard_ticks;
+
+        void read(ReadBuffer & in);
+        BlockDeviceStatValues operator-(const BlockDeviceStatValues & other) const;
+    };
+
+    std::unordered_map<String /* device name */, BlockDeviceStatValues> block_device_stats;
+
+    struct NetworkInterfaceStatValues
+    {
+        uint64_t recv_bytes;
+        uint64_t recv_packets;
+        uint64_t recv_errors;
+        uint64_t recv_drop;
+        uint64_t send_bytes;
+        uint64_t send_packets;
+        uint64_t send_errors;
+        uint64_t send_drop;
+
+        NetworkInterfaceStatValues operator-(const NetworkInterfaceStatValues & other) const;
+    };
+
+    std::unordered_map<String /* device name */, NetworkInterfaceStatValues> network_interface_stats;
+
 #endif
 
     std::unique_ptr<ThreadFromGlobalPool> thread;
 
     void run();
-    void update();
+    void update(std::chrono::system_clock::time_point update_time);
 };
 
 }
