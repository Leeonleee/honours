{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 24416,
  "instance_id": "ClickHouse__ClickHouse-24416",
  "issue_numbers": [
    "9430"
  ],
  "base_commit": "f3d74c84fe75f8d9f118fffa7a39c4e6b1100973",
  "patch": "diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 9d7a4275dc1d..313523d19dc6 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -1159,7 +1159,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n     {\n         /// This object will periodically calculate some metrics.\n         AsynchronousMetrics async_metrics(\n-            global_context, config().getUInt(\"asynchronous_metrics_update_period_s\", 60), servers_to_start_before_tables, servers);\n+            global_context, config().getUInt(\"asynchronous_metrics_update_period_s\", 1), servers_to_start_before_tables, servers);\n         attachSystemTablesAsync(*DatabaseCatalog::instance().getSystemDatabase(), async_metrics);\n \n         for (const auto & listen_host : listen_hosts)\ndiff --git a/programs/server/config.xml b/programs/server/config.xml\nindex dd50a6934036..6f0b228dda76 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -583,7 +583,7 @@\n         <port>9019</port>\n     </jdbc_bridge>\n     -->\n-  \n+\n     <!-- Configuration of clusters that could be used in Distributed tables.\n          https://clickhouse.tech/docs/en/operations/table_engines/distributed/\n       -->\n@@ -917,7 +917,7 @@\n             Asynchronous metrics are updated once a minute, so there is\n             no need to flush more often.\n         -->\n-        <flush_interval_milliseconds>60000</flush_interval_milliseconds>\n+        <flush_interval_milliseconds>7000</flush_interval_milliseconds>\n     </asynchronous_metric_log>\n \n     <!--\ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex f4ceef2896a8..8301ea656bf1 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -557,6 +557,7 @@\n     M(587, CONCURRENT_ACCESS_NOT_SUPPORTED) \\\n     M(588, DISTRIBUTED_BROKEN_BATCH_INFO) \\\n     M(589, DISTRIBUTED_BROKEN_BATCH_FILES) \\\n+    M(590, CANNOT_SYSCONF) \\\n     \\\n     M(998, POSTGRESQL_CONNECTION_FAILURE) \\\n     M(999, KEEPER_EXCEPTION) \\\ndiff --git a/src/IO/ReadBufferFromFileDescriptor.cpp b/src/IO/ReadBufferFromFileDescriptor.cpp\nindex babdc953514d..893c2bcb5d8c 100644\n--- a/src/IO/ReadBufferFromFileDescriptor.cpp\n+++ b/src/IO/ReadBufferFromFileDescriptor.cpp\n@@ -149,7 +149,7 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)\n         off_t res = ::lseek(fd, new_pos, SEEK_SET);\n         if (-1 == res)\n             throwFromErrnoWithPath(\"Cannot seek through file \" + getFileName(), getFileName(),\n-                                   ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n+                ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n         file_offset_of_buffer_end = new_pos;\n \n         watch.stop();\n@@ -160,6 +160,20 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)\n }\n \n \n+void ReadBufferFromFileDescriptor::rewind()\n+{\n+    ProfileEvents::increment(ProfileEvents::Seek);\n+    off_t res = ::lseek(fd, 0, SEEK_SET);\n+    if (-1 == res)\n+        throwFromErrnoWithPath(\"Cannot seek through file \" + getFileName(), getFileName(),\n+            ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n+\n+    /// Clearing the buffer with existing data. New data will be read on subsequent call to 'next'.\n+    working_buffer.resize(0);\n+    pos = working_buffer.begin();\n+}\n+\n+\n /// Assuming file descriptor supports 'select', check that we have data to read or wait until timeout.\n bool ReadBufferFromFileDescriptor::poll(size_t timeout_microseconds)\n {\ndiff --git a/src/IO/ReadBufferFromFileDescriptor.h b/src/IO/ReadBufferFromFileDescriptor.h\nindex bf22bb3d4a3c..1883c6802bc7 100644\n--- a/src/IO/ReadBufferFromFileDescriptor.h\n+++ b/src/IO/ReadBufferFromFileDescriptor.h\n@@ -39,6 +39,9 @@ class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase\n     /// If 'offset' is small enough to stay in buffer after seek, then true seek in file does not happen.\n     off_t seek(off_t off, int whence) override;\n \n+    /// Seek to the beginning, discarding already read data if any. Useful to reread file that changes on every read.\n+    void rewind();\n+\n     off_t size();\n \n     void setProgressCallback(ContextPtr context);\ndiff --git a/src/Interpreters/AsynchronousMetricLog.cpp b/src/Interpreters/AsynchronousMetricLog.cpp\nindex 79e2d513d5cc..c7003cff1695 100644\n--- a/src/Interpreters/AsynchronousMetricLog.cpp\n+++ b/src/Interpreters/AsynchronousMetricLog.cpp\n@@ -18,7 +18,7 @@ NamesAndTypesList AsynchronousMetricLogElement::getNamesAndTypes()\n         {\"event_date\", std::make_shared<DataTypeDate>()},\n         {\"event_time\", std::make_shared<DataTypeDateTime>()},\n         {\"event_time_microseconds\", std::make_shared<DataTypeDateTime64>(6)},\n-        {\"name\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n+        {\"metric\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n         {\"value\", std::make_shared<DataTypeFloat64>(),}\n     };\n }\ndiff --git a/src/Interpreters/AsynchronousMetrics.cpp b/src/Interpreters/AsynchronousMetrics.cpp\nindex 9803a2d8e9bd..11ecf5477145 100644\n--- a/src/Interpreters/AsynchronousMetrics.cpp\n+++ b/src/Interpreters/AsynchronousMetrics.cpp\n@@ -7,12 +7,14 @@\n #include <Common/setThreadName.h>\n #include <Common/CurrentMetrics.h>\n #include <Common/typeid_cast.h>\n+#include <Common/filesystemHelpers.h>\n #include <Server/ProtocolServerAdapter.h>\n #include <Storages/MarkCache.h>\n #include <Storages/StorageMergeTree.h>\n #include <Storages/StorageReplicatedMergeTree.h>\n #include <IO/UncompressedCache.h>\n #include <IO/MMappedFileCache.h>\n+#include <IO/ReadHelpers.h>\n #include <Databases/IDatabase.h>\n #include <chrono>\n \n@@ -35,6 +37,171 @@ namespace CurrentMetrics\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int CORRUPTED_DATA;\n+    extern const int CANNOT_SYSCONF;\n+}\n+\n+\n+#if defined(OS_LINUX)\n+\n+static constexpr size_t small_buffer_size = 4096;\n+\n+static void openFileIfExists(const char * filename, std::optional<ReadBufferFromFile> & out)\n+{\n+    /// Ignoring time of check is not time of use cases, as procfs/sysfs files are fairly persistent.\n+\n+    std::error_code ec;\n+    if (std::filesystem::is_regular_file(filename, ec))\n+        out.emplace(filename, small_buffer_size);\n+}\n+\n+static std::unique_ptr<ReadBufferFromFile> openFileIfExists(const std::string & filename)\n+{\n+    std::error_code ec;\n+    if (std::filesystem::is_regular_file(filename, ec))\n+        return std::make_unique<ReadBufferFromFile>(filename, small_buffer_size);\n+    return {};\n+}\n+\n+#endif\n+\n+\n+AsynchronousMetrics::AsynchronousMetrics(\n+    ContextPtr global_context_,\n+    int update_period_seconds,\n+    std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables_,\n+    std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_)\n+    : WithContext(global_context_)\n+    , update_period(update_period_seconds)\n+    , servers_to_start_before_tables(servers_to_start_before_tables_)\n+    , servers(servers_)\n+{\n+#if defined(OS_LINUX)\n+    openFileIfExists(\"/proc/meminfo\", meminfo);\n+    openFileIfExists(\"/proc/loadavg\", loadavg);\n+    openFileIfExists(\"/proc/stat\", proc_stat);\n+    openFileIfExists(\"/proc/cpuinfo\", cpuinfo);\n+    openFileIfExists(\"/proc/sys/fs/file-nr\", file_nr);\n+    openFileIfExists(\"/proc/uptime\", uptime);\n+    openFileIfExists(\"/proc/net/dev\", net_dev);\n+\n+    for (size_t thermal_device_index = 0;; ++thermal_device_index)\n+    {\n+        std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(fmt::format(\"/sys/class/thermal/thermal_zone{}/temp\", thermal_device_index));\n+        if (!file)\n+        {\n+            /// Sometimes indices are from zero sometimes from one.\n+            if (thermal_device_index == 0)\n+                continue;\n+            else\n+                break;\n+        }\n+        thermal.emplace_back(std::move(file));\n+    }\n+\n+    for (size_t hwmon_index = 0;; ++hwmon_index)\n+    {\n+        String hwmon_name_file = fmt::format(\"/sys/class/hwmon/hwmon{}/name\", hwmon_index);\n+        if (!std::filesystem::exists(hwmon_name_file))\n+        {\n+            if (hwmon_index == 0)\n+                continue;\n+            else\n+                break;\n+        }\n+\n+        String hwmon_name;\n+        ReadBufferFromFile hwmon_name_in(hwmon_name_file, small_buffer_size);\n+        readText(hwmon_name, hwmon_name_in);\n+        std::replace(hwmon_name.begin(), hwmon_name.end(), ' ', '_');\n+\n+        for (size_t sensor_index = 0;; ++sensor_index)\n+        {\n+            String sensor_name_file = fmt::format(\"/sys/class/hwmon/hwmon{}/temp{}_label\", hwmon_index, sensor_index);\n+            String sensor_value_file = fmt::format(\"/sys/class/hwmon/hwmon{}/temp{}_input\", hwmon_index, sensor_index);\n+\n+            bool sensor_name_file_exists = std::filesystem::exists(sensor_name_file);\n+            bool sensor_value_file_exists = std::filesystem::exists(sensor_value_file);\n+\n+            /// Sometimes there are labels but there is no files with data or vice versa.\n+            if (!sensor_name_file_exists && !sensor_value_file_exists)\n+            {\n+                if (sensor_index == 0)\n+                    continue;\n+                else\n+                    break;\n+            }\n+\n+            std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(sensor_value_file);\n+            if (!file)\n+                continue;\n+\n+            String sensor_name;\n+            if (sensor_name_file_exists)\n+            {\n+                ReadBufferFromFile sensor_name_in(sensor_name_file, small_buffer_size);\n+                readText(sensor_name, sensor_name_in);\n+                std::replace(sensor_name.begin(), sensor_name.end(), ' ', '_');\n+            }\n+\n+            hwmon_devices[hwmon_name][sensor_name] = std::move(file);\n+        }\n+    }\n+\n+    for (size_t edac_index = 0;; ++edac_index)\n+    {\n+        String edac_correctable_file = fmt::format(\"/sys/devices/system/edac/mc/mc{}/ce_count\", edac_index);\n+        String edac_uncorrectable_file = fmt::format(\"/sys/devices/system/edac/mc/mc{}/ue_count\", edac_index);\n+\n+        bool edac_correctable_file_exists = std::filesystem::exists(edac_correctable_file);\n+        bool edac_uncorrectable_file_exists = std::filesystem::exists(edac_uncorrectable_file);\n+\n+        if (!edac_correctable_file_exists && !edac_uncorrectable_file_exists)\n+        {\n+            if (edac_index == 0)\n+                continue;\n+            else\n+                break;\n+        }\n+\n+        edac.emplace_back();\n+\n+        if (edac_correctable_file_exists)\n+            edac.back().first = openFileIfExists(edac_correctable_file);\n+        if (edac_uncorrectable_file_exists)\n+            edac.back().second = openFileIfExists(edac_uncorrectable_file);\n+    }\n+\n+    if (std::filesystem::exists(\"/sys/block\"))\n+    {\n+        for (const auto & device_dir : std::filesystem::directory_iterator(\"/sys/block\"))\n+        {\n+            String device_name = device_dir.path().filename();\n+\n+            /// We are not interested in loopback devices.\n+            if (device_name.starts_with(\"loop\"))\n+                continue;\n+\n+            std::unique_ptr<ReadBufferFromFile> file = openFileIfExists(device_dir.path() / \"stat\");\n+            if (!file)\n+                continue;\n+\n+            block_devs[device_name] = std::move(file);\n+        }\n+    }\n+#endif\n+}\n+\n+void AsynchronousMetrics::start()\n+{\n+    /// Update once right now, to make metrics available just after server start\n+    /// (without waiting for asynchronous_metrics_update_period_s).\n+    update(std::chrono::system_clock::now());\n+    thread = std::make_unique<ThreadFromGlobalPool>([this] { run(); });\n+}\n+\n AsynchronousMetrics::~AsynchronousMetrics()\n {\n     try\n@@ -91,10 +258,12 @@ void AsynchronousMetrics::run()\n \n     while (true)\n     {\n+        auto next_update_time = get_next_update_time(update_period);\n+\n         {\n             // Wait first, so that the first metric collection is also on even time.\n             std::unique_lock lock{mutex};\n-            if (wait_cond.wait_until(lock, get_next_update_time(update_period),\n+            if (wait_cond.wait_until(lock, next_update_time,\n                 [this] { return quit; }))\n             {\n                 break;\n@@ -103,7 +272,7 @@ void AsynchronousMetrics::run()\n \n         try\n         {\n-            update();\n+            update(next_update_time);\n         }\n         catch (...)\n         {\n@@ -167,10 +336,162 @@ static void saveAllArenasMetric(AsynchronousMetricValues & values,\n }\n #endif\n \n-void AsynchronousMetrics::update()\n+\n+#if defined(OS_LINUX)\n+\n+void AsynchronousMetrics::ProcStatValuesCPU::read(ReadBuffer & in)\n+{\n+    readText(user, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(nice, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(system, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(idle, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(iowait, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(irq, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(softirq, in);\n+\n+    /// Just in case for old Linux kernels, we check if these values present.\n+\n+    if (!checkChar('\\n', in))\n+    {\n+        skipWhitespaceIfAny(in, true);\n+        readText(steal, in);\n+    }\n+\n+    if (!checkChar('\\n', in))\n+    {\n+        skipWhitespaceIfAny(in, true);\n+        readText(guest, in);\n+    }\n+\n+    if (!checkChar('\\n', in))\n+    {\n+        skipWhitespaceIfAny(in, true);\n+        readText(guest_nice, in);\n+    }\n+\n+    skipToNextLineOrEOF(in);\n+}\n+\n+AsynchronousMetrics::ProcStatValuesCPU\n+AsynchronousMetrics::ProcStatValuesCPU::operator-(const AsynchronousMetrics::ProcStatValuesCPU & other) const\n+{\n+    ProcStatValuesCPU res{};\n+    res.user = user - other.user;\n+    res.nice = nice - other.nice;\n+    res.system = system - other.system;\n+    res.idle = idle - other.idle;\n+    res.iowait = iowait - other.iowait;\n+    res.irq = irq - other.irq;\n+    res.softirq = softirq - other.softirq;\n+    res.steal = steal - other.steal;\n+    res.guest = guest - other.guest;\n+    res.guest_nice = guest_nice - other.guest_nice;\n+    return res;\n+}\n+\n+AsynchronousMetrics::ProcStatValuesOther\n+AsynchronousMetrics::ProcStatValuesOther::operator-(const AsynchronousMetrics::ProcStatValuesOther & other) const\n+{\n+    ProcStatValuesOther res{};\n+    res.interrupts = interrupts - other.interrupts;\n+    res.context_switches = context_switches - other.context_switches;\n+    res.processes_created = processes_created - other.processes_created;\n+    return res;\n+}\n+\n+void AsynchronousMetrics::BlockDeviceStatValues::read(ReadBuffer & in)\n+{\n+    skipWhitespaceIfAny(in, true);\n+    readText(read_ios, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(read_merges, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(read_sectors, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(read_ticks, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(write_ios, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(write_merges, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(write_sectors, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(write_ticks, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(in_flight_ios, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(io_ticks, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(time_in_queue, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(discard_ops, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(discard_merges, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(discard_sectors, in);\n+    skipWhitespaceIfAny(in, true);\n+    readText(discard_ticks, in);\n+}\n+\n+AsynchronousMetrics::BlockDeviceStatValues\n+AsynchronousMetrics::BlockDeviceStatValues::operator-(const AsynchronousMetrics::BlockDeviceStatValues & other) const\n+{\n+    BlockDeviceStatValues res{};\n+    res.read_ios = read_ios - other.read_ios;\n+    res.read_merges = read_merges - other.read_merges;\n+    res.read_sectors = read_sectors - other.read_sectors;\n+    res.read_ticks = read_ticks - other.read_ticks;\n+    res.write_ios = write_ios - other.write_ios;\n+    res.write_merges = write_merges - other.write_merges;\n+    res.write_sectors = write_sectors - other.write_sectors;\n+    res.write_ticks = write_ticks - other.write_ticks;\n+    res.in_flight_ios = in_flight_ios; /// This is current value, not total.\n+    res.io_ticks = io_ticks - other.io_ticks;\n+    res.time_in_queue = time_in_queue - other.time_in_queue;\n+    res.discard_ops = discard_ops - other.discard_ops;\n+    res.discard_merges = discard_merges - other.discard_merges;\n+    res.discard_sectors = discard_sectors - other.discard_sectors;\n+    res.discard_ticks = discard_ticks - other.discard_ticks;\n+    return res;\n+}\n+\n+AsynchronousMetrics::NetworkInterfaceStatValues\n+AsynchronousMetrics::NetworkInterfaceStatValues::operator-(const AsynchronousMetrics::NetworkInterfaceStatValues & other) const\n+{\n+    NetworkInterfaceStatValues res{};\n+    res.recv_bytes = recv_bytes - other.recv_bytes;\n+    res.recv_packets = recv_packets - other.recv_packets;\n+    res.recv_errors = recv_errors - other.recv_errors;\n+    res.recv_drop = recv_drop - other.recv_drop;\n+    res.send_bytes = send_bytes - other.send_bytes;\n+    res.send_packets = send_packets - other.send_packets;\n+    res.send_errors = send_errors - other.send_errors;\n+    res.send_drop = send_drop - other.send_drop;\n+    return res;\n+}\n+\n+#endif\n+\n+\n+void AsynchronousMetrics::update(std::chrono::system_clock::time_point update_time)\n {\n+    Stopwatch watch;\n+\n     AsynchronousMetricValues new_values;\n \n+    auto current_time = std::chrono::system_clock::now();\n+    auto time_after_previous_update [[maybe_unused]] = current_time - previous_update_time;\n+    previous_update_time = update_time;\n+\n+    /// This is also a good indicator of system responsiveness.\n+    new_values[\"Jitter\"] = std::chrono::duration_cast<std::chrono::nanoseconds>(current_time - update_time).count() / 1e9;\n+\n     {\n         if (auto mark_cache = getContext()->getMarkCache())\n         {\n@@ -206,7 +527,7 @@ void AsynchronousMetrics::update()\n \n     new_values[\"Uptime\"] = getContext()->getUptimeSeconds();\n \n-    /// Process memory usage according to OS\n+    /// Process process memory usage according to OS\n #if defined(OS_LINUX)\n     {\n         MemoryStatisticsOS::Data data = memory_stat.get();\n@@ -237,8 +558,581 @@ void AsynchronousMetrics::update()\n             CurrentMetrics::set(CurrentMetrics::MemoryTracking, new_amount);\n         }\n     }\n+\n+    if (loadavg)\n+    {\n+        try\n+        {\n+            loadavg->rewind();\n+\n+            Float64 loadavg1 = 0;\n+            Float64 loadavg5 = 0;\n+            Float64 loadavg15 = 0;\n+            UInt64 threads_runnable = 0;\n+            UInt64 threads_total = 0;\n+\n+            readText(loadavg1, *loadavg);\n+            skipWhitespaceIfAny(*loadavg);\n+            readText(loadavg5, *loadavg);\n+            skipWhitespaceIfAny(*loadavg);\n+            readText(loadavg15, *loadavg);\n+            skipWhitespaceIfAny(*loadavg);\n+            readText(threads_runnable, *loadavg);\n+            assertChar('/', *loadavg);\n+            readText(threads_total, *loadavg);\n+\n+            new_values[\"LoadAverage1\"] = loadavg1;\n+            new_values[\"LoadAverage5\"] = loadavg5;\n+            new_values[\"LoadAverage15\"] = loadavg15;\n+            new_values[\"OSThreadsRunnable\"] = threads_runnable;\n+            new_values[\"OSThreadsTotal\"] = threads_total;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    if (uptime)\n+    {\n+        try\n+        {\n+            uptime->rewind();\n+\n+            Float64 uptime_seconds = 0;\n+            readText(uptime_seconds, *uptime);\n+\n+            new_values[\"OSUptime\"] = uptime_seconds;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    if (proc_stat)\n+    {\n+        try\n+        {\n+            proc_stat->rewind();\n+\n+            int64_t hz = sysconf(_SC_CLK_TCK);\n+            if (-1 == hz)\n+                throwFromErrno(\"Cannot call 'sysconf' to obtain system HZ\", ErrorCodes::CANNOT_SYSCONF);\n+\n+            double multiplier = 1.0 / hz / (std::chrono::duration_cast<std::chrono::nanoseconds>(time_after_previous_update).count() / 1e9);\n+            size_t num_cpus = 0;\n+\n+            ProcStatValuesOther current_other_values{};\n+            ProcStatValuesCPU delta_values_all_cpus{};\n+\n+            while (!proc_stat->eof())\n+            {\n+                String name;\n+                readStringUntilWhitespace(name, *proc_stat);\n+                skipWhitespaceIfAny(*proc_stat);\n+\n+                if (name.starts_with(\"cpu\"))\n+                {\n+                    String cpu_num_str = name.substr(strlen(\"cpu\"));\n+                    UInt64 cpu_num = 0;\n+                    if (!cpu_num_str.empty())\n+                    {\n+                        cpu_num = parse<UInt64>(cpu_num_str);\n+\n+                        if (cpu_num > 1000000) /// Safety check, arbitrary large number, suitable for supercomputing applications.\n+                            throw Exception(ErrorCodes::CORRUPTED_DATA, \"Too many CPUs (at least {}) in '/proc/stat' file\", cpu_num);\n+\n+                        if (proc_stat_values_per_cpu.size() <= cpu_num)\n+                            proc_stat_values_per_cpu.resize(cpu_num + 1);\n+                    }\n+\n+                    ProcStatValuesCPU current_values{};\n+                    current_values.read(*proc_stat);\n+\n+                    ProcStatValuesCPU & prev_values = !cpu_num_str.empty() ? proc_stat_values_per_cpu[cpu_num] : proc_stat_values_all_cpus;\n+\n+                    if (!first_run)\n+                    {\n+                        ProcStatValuesCPU delta_values = current_values - prev_values;\n+\n+                        String cpu_suffix;\n+                        if (!cpu_num_str.empty())\n+                        {\n+                            cpu_suffix = \"CPU\" + cpu_num_str;\n+                            ++num_cpus;\n+                        }\n+                        else\n+                            delta_values_all_cpus = delta_values;\n+\n+                        new_values[\"OSUserTime\" + cpu_suffix] = delta_values.user * multiplier;\n+                        new_values[\"OSNiceTime\" + cpu_suffix] = delta_values.nice * multiplier;\n+                        new_values[\"OSSystemTime\" + cpu_suffix] = delta_values.system * multiplier;\n+                        new_values[\"OSIdleTime\" + cpu_suffix] = delta_values.idle * multiplier;\n+                        new_values[\"OSIOWaitTime\" + cpu_suffix] = delta_values.iowait * multiplier;\n+                        new_values[\"OSIrqTime\" + cpu_suffix] = delta_values.irq * multiplier;\n+                        new_values[\"OSSoftIrqTime\" + cpu_suffix] = delta_values.softirq * multiplier;\n+                        new_values[\"OSStealTime\" + cpu_suffix] = delta_values.steal * multiplier;\n+                        new_values[\"OSGuestTime\" + cpu_suffix] = delta_values.guest * multiplier;\n+                        new_values[\"OSGuestNiceTime\" + cpu_suffix] = delta_values.guest_nice * multiplier;\n+                    }\n+\n+                    prev_values = current_values;\n+                }\n+                else if (name == \"intr\")\n+                {\n+                    readText(current_other_values.interrupts, *proc_stat);\n+                    skipToNextLineOrEOF(*proc_stat);\n+                }\n+                else if (name == \"ctxt\")\n+                {\n+                    readText(current_other_values.context_switches, *proc_stat);\n+                    skipToNextLineOrEOF(*proc_stat);\n+                }\n+                else if (name == \"processes\")\n+                {\n+                    readText(current_other_values.processes_created, *proc_stat);\n+                    skipToNextLineOrEOF(*proc_stat);\n+                }\n+                else if (name == \"procs_running\")\n+                {\n+                    UInt64 processes_running = 0;\n+                    readText(processes_running, *proc_stat);\n+                    skipToNextLineOrEOF(*proc_stat);\n+                    new_values[\"OSProcessesRunning\"] = processes_running;\n+                }\n+                else if (name == \"procs_blocked\")\n+                {\n+                    UInt64 processes_blocked = 0;\n+                    readText(processes_blocked, *proc_stat);\n+                    skipToNextLineOrEOF(*proc_stat);\n+                    new_values[\"OSProcessesBlocked\"] = processes_blocked;\n+                }\n+                else\n+                    skipToNextLineOrEOF(*proc_stat);\n+            }\n+\n+            if (!first_run)\n+            {\n+                ProcStatValuesOther delta_values = current_other_values - proc_stat_values_other;\n+\n+                new_values[\"OSInterrupts\"] = delta_values.interrupts * multiplier;\n+                new_values[\"OSContextSwitches\"] = delta_values.context_switches * multiplier;\n+                new_values[\"OSProcessesCreated\"] = delta_values.processes_created * multiplier;\n+\n+                /// Also write values normalized to 0..1 by diving to the number of CPUs.\n+                /// These values are good to be averaged across the cluster of non-uniform servers.\n+\n+                if (num_cpus)\n+                {\n+                    new_values[\"OSUserTimeNormalized\"] = delta_values_all_cpus.user * multiplier / num_cpus;\n+                    new_values[\"OSNiceTimeNormalized\"] = delta_values_all_cpus.nice * multiplier / num_cpus;\n+                    new_values[\"OSSystemTimeNormalized\"] = delta_values_all_cpus.system * multiplier / num_cpus;\n+                    new_values[\"OSIdleTimeNormalized\"] = delta_values_all_cpus.idle * multiplier / num_cpus;\n+                    new_values[\"OSIOWaitTimeNormalized\"] = delta_values_all_cpus.iowait * multiplier / num_cpus;\n+                    new_values[\"OSIrqTimeNormalized\"] = delta_values_all_cpus.irq * multiplier / num_cpus;\n+                    new_values[\"OSSoftIrqTimeNormalized\"] = delta_values_all_cpus.softirq * multiplier / num_cpus;\n+                    new_values[\"OSStealTimeNormalized\"] = delta_values_all_cpus.steal * multiplier / num_cpus;\n+                    new_values[\"OSGuestTimeNormalized\"] = delta_values_all_cpus.guest * multiplier / num_cpus;\n+                    new_values[\"OSGuestNiceTimeNormalized\"] = delta_values_all_cpus.guest_nice * multiplier / num_cpus;\n+                }\n+            }\n+\n+            proc_stat_values_other = current_other_values;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    if (meminfo)\n+    {\n+        try\n+        {\n+            meminfo->rewind();\n+\n+            uint64_t free_plus_cached_bytes = 0;\n+\n+            while (!meminfo->eof())\n+            {\n+                String name;\n+                readStringUntilWhitespace(name, *meminfo);\n+                skipWhitespaceIfAny(*meminfo, true);\n+\n+                uint64_t kb = 0;\n+                readText(kb, *meminfo);\n+                if (kb)\n+                {\n+                    skipWhitespaceIfAny(*meminfo, true);\n+                    assertString(\"kB\", *meminfo);\n+\n+                    uint64_t bytes = kb * 1024;\n+\n+                    if (name == \"MemTotal:\")\n+                    {\n+                        new_values[\"OSMemoryTotal\"] = bytes;\n+                    }\n+                    else if (name == \"MemFree:\")\n+                    {\n+                        /// We cannot simply name this metric \"Free\", because it confuses users.\n+                        /// See https://www.linuxatemyram.com/\n+                        /// For convenience we also provide OSMemoryFreePlusCached, that should be somewhat similar to OSMemoryAvailable.\n+\n+                        free_plus_cached_bytes += bytes;\n+                        new_values[\"OSMemoryFreeWithoutCached\"] = bytes;\n+                    }\n+                    else if (name == \"MemAvailable:\")\n+                    {\n+                        new_values[\"OSMemoryAvailable\"] = bytes;\n+                    }\n+                    else if (name == \"Buffers:\")\n+                    {\n+                        new_values[\"OSMemoryBuffers\"] = bytes;\n+                    }\n+                    else if (name == \"Cached:\")\n+                    {\n+                        free_plus_cached_bytes += bytes;\n+                        new_values[\"OSMemoryCached\"] = bytes;\n+                    }\n+                    else if (name == \"SwapCached:\")\n+                    {\n+                        new_values[\"OSMemorySwapCached\"] = bytes;\n+                    }\n+                }\n+\n+                skipToNextLineOrEOF(*meminfo);\n+            }\n+\n+            new_values[\"OSMemoryFreePlusCached\"] = free_plus_cached_bytes;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    // Try to add processor frequencies, ignoring errors.\n+    if (cpuinfo)\n+    {\n+        try\n+        {\n+            cpuinfo->rewind();\n+\n+            // We need the following lines:\n+            // processor : 4\n+            // cpu MHz : 4052.941\n+            // They contain tabs and are interspersed with other info.\n+\n+            int core_id = 0;\n+            while (!cpuinfo->eof())\n+            {\n+                std::string s;\n+                // We don't have any backslash escape sequences in /proc/cpuinfo, so\n+                // this function will read the line until EOL, which is exactly what\n+                // we need.\n+                readEscapedStringUntilEOL(s, *cpuinfo);\n+                // It doesn't read the EOL itself.\n+                ++cpuinfo->position();\n+\n+                if (s.rfind(\"processor\", 0) == 0)\n+                {\n+                    if (auto colon = s.find_first_of(':'))\n+                    {\n+                        core_id = std::stoi(s.substr(colon + 2));\n+                    }\n+                }\n+                else if (s.rfind(\"cpu MHz\", 0) == 0)\n+                {\n+                    if (auto colon = s.find_first_of(':'))\n+                    {\n+                        auto mhz = std::stod(s.substr(colon + 2));\n+                        new_values[fmt::format(\"CPUFrequencyMHz_{}\", core_id)] = mhz;\n+                    }\n+                }\n+            }\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    if (file_nr)\n+    {\n+        try\n+        {\n+            file_nr->rewind();\n+\n+            uint64_t open_files = 0;\n+            readText(open_files, *file_nr);\n+            new_values[\"OSOpenFiles\"] = open_files;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    for (auto & [name, device] : block_devs)\n+    {\n+        try\n+        {\n+            device->rewind();\n+\n+            BlockDeviceStatValues current_values{};\n+            BlockDeviceStatValues & prev_values = block_device_stats[name];\n+            current_values.read(*device);\n+\n+            BlockDeviceStatValues delta_values = current_values - prev_values;\n+            prev_values = current_values;\n+\n+            if (first_run)\n+                continue;\n+\n+            /// Always 512 according to the docs.\n+            static constexpr size_t sector_size = 512;\n+\n+            /// Always in milliseconds according to the docs.\n+            static constexpr double time_multiplier = 1e-6;\n+\n+            new_values[\"BlockReadOps_\" + name] = delta_values.read_ios;\n+            new_values[\"BlockWriteOps_\" + name] = delta_values.write_ios;\n+            new_values[\"BlockDiscardOps_\" + name] = delta_values.discard_ops;\n+\n+            new_values[\"BlockReadMerges_\" + name] = delta_values.read_merges;\n+            new_values[\"BlockWriteMerges_\" + name] = delta_values.write_merges;\n+            new_values[\"BlockDiscardMerges_\" + name] = delta_values.discard_merges;\n+\n+            new_values[\"BlockReadBytes_\" + name] = delta_values.read_sectors * sector_size;\n+            new_values[\"BlockWriteBytes_\" + name] = delta_values.write_sectors * sector_size;\n+            new_values[\"BlockDiscardBytes_\" + name] = delta_values.discard_sectors * sector_size;\n+\n+            new_values[\"BlockReadTime_\" + name] = delta_values.read_ticks * time_multiplier;\n+            new_values[\"BlockWriteTime_\" + name] = delta_values.write_ticks * time_multiplier;\n+            new_values[\"BlockDiscardTime_\" + name] = delta_values.discard_ticks * time_multiplier;\n+\n+            new_values[\"BlockInFlightOps_\" + name] = delta_values.in_flight_ios;\n+\n+            new_values[\"BlockActiveTime_\" + name] = delta_values.io_ticks * time_multiplier;\n+            new_values[\"BlockQueueTime_\" + name] = delta_values.time_in_queue * time_multiplier;\n+\n+            if (delta_values.in_flight_ios)\n+            {\n+                /// TODO Check if these values are meaningful.\n+\n+                new_values[\"BlockActiveTimePerOp_\" + name] = delta_values.io_ticks * time_multiplier / delta_values.in_flight_ios;\n+                new_values[\"BlockQueueTimePerOp_\" + name] = delta_values.time_in_queue * time_multiplier / delta_values.in_flight_ios;\n+            }\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    if (net_dev)\n+    {\n+        try\n+        {\n+            net_dev->rewind();\n+\n+            /// Skip first two lines:\n+            /// Inter-|   Receive                                                |  Transmit\n+            ///  face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n+\n+            skipToNextLineOrEOF(*net_dev);\n+            skipToNextLineOrEOF(*net_dev);\n+\n+            while (!net_dev->eof())\n+            {\n+                skipWhitespaceIfAny(*net_dev, true);\n+                String interface_name;\n+                readStringUntilWhitespace(interface_name, *net_dev);\n+\n+                /// We are not interested in loopback devices.\n+                if (!interface_name.ends_with(':') || interface_name == \"lo:\" || interface_name.size() <= 1)\n+                {\n+                    skipToNextLineOrEOF(*net_dev);\n+                    continue;\n+                }\n+\n+                interface_name.pop_back();\n+\n+                NetworkInterfaceStatValues current_values{};\n+                uint64_t unused;\n+\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.recv_bytes, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.recv_packets, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.recv_errors, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.recv_drop, *net_dev);\n+\n+                /// NOTE We should pay more attention to the number of fields.\n+\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(unused, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(unused, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(unused, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(unused, *net_dev);\n+\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.send_bytes, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.send_packets, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.send_errors, *net_dev);\n+                skipWhitespaceIfAny(*net_dev, true);\n+                readText(current_values.send_drop, *net_dev);\n+\n+                skipToNextLineOrEOF(*net_dev);\n+\n+                NetworkInterfaceStatValues & prev_values = network_interface_stats[interface_name];\n+                NetworkInterfaceStatValues delta_values = current_values - prev_values;\n+                prev_values = current_values;\n+\n+                if (!first_run)\n+                {\n+                    new_values[\"NetworkReceiveBytes_\" + interface_name] = delta_values.recv_bytes;\n+                    new_values[\"NetworkReceivePackets_\" + interface_name] = delta_values.recv_packets;\n+                    new_values[\"NetworkReceiveErrors_\" + interface_name] = delta_values.recv_errors;\n+                    new_values[\"NetworkReceiveDrop_\" + interface_name] = delta_values.recv_drop;\n+\n+                    new_values[\"NetworkSendBytes_\" + interface_name] = delta_values.send_bytes;\n+                    new_values[\"NetworkSendPackets_\" + interface_name] = delta_values.send_packets;\n+                    new_values[\"NetworkSendErrors_\" + interface_name] = delta_values.send_errors;\n+                    new_values[\"NetworkSendDrop_\" + interface_name] = delta_values.send_drop;\n+                }\n+            }\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    for (size_t i = 0, size = thermal.size(); i < size; ++i)\n+    {\n+        try\n+        {\n+            ReadBufferFromFile & in = *thermal[i];\n+\n+            in.rewind();\n+            uint64_t temperature = 0;\n+            readText(temperature, in);\n+            new_values[fmt::format(\"Temperature{}\", i)] = temperature * 0.001;\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    for (const auto & [hwmon_name, sensors] : hwmon_devices)\n+    {\n+        try\n+        {\n+            for (const auto & [sensor_name, sensor_file] : sensors)\n+            {\n+                sensor_file->rewind();\n+                uint64_t temperature = 0;\n+                readText(temperature, *sensor_file);\n+\n+                if (sensor_name.empty())\n+                    new_values[fmt::format(\"Temperature_{}\", hwmon_name)] = temperature * 0.001;\n+                else\n+                    new_values[fmt::format(\"Temperature_{}_{}\", hwmon_name, sensor_name)] = temperature * 0.001;\n+            }\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n+\n+    for (size_t i = 0, size = edac.size(); i < size; ++i)\n+    {\n+        /// NOTE maybe we need to take difference with previous values.\n+        /// But these metrics should be exceptionally rare, so it's ok to keep them accumulated.\n+\n+        try\n+        {\n+            if (edac[i].first)\n+            {\n+                ReadBufferFromFile & in = *edac[i].first;\n+                in.rewind();\n+                uint64_t errors = 0;\n+                readText(errors, in);\n+                new_values[fmt::format(\"EDAC{}_Correctable\", i)] = errors;\n+            }\n+\n+            if (edac[i].second)\n+            {\n+                ReadBufferFromFile & in = *edac[i].second;\n+                in.rewind();\n+                uint64_t errors = 0;\n+                readText(errors, in);\n+                new_values[fmt::format(\"EDAC{}_Uncorrectable\", i)] = errors;\n+            }\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(__PRETTY_FUNCTION__);\n+        }\n+    }\n #endif\n \n+    /// Free space in filesystems at data path and logs path.\n+    {\n+        auto stat = getStatVFS(getContext()->getPath());\n+\n+        new_values[\"FilesystemMainPathTotalBytes\"] = stat.f_blocks * stat.f_bsize;\n+        new_values[\"FilesystemMainPathAvailableBytes\"] = stat.f_bavail * stat.f_bsize;\n+        new_values[\"FilesystemMainPathUsedBytes\"] = (stat.f_blocks - stat.f_bavail) * stat.f_bsize;\n+        new_values[\"FilesystemMainPathTotalINodes\"] = stat.f_files;\n+        new_values[\"FilesystemMainPathAvailableINodes\"] = stat.f_favail;\n+        new_values[\"FilesystemMainPathUsedINodes\"] = stat.f_files - stat.f_favail;\n+    }\n+\n+    {\n+        /// Current working directory of the server is the directory with logs.\n+        auto stat = getStatVFS(\".\");\n+\n+        new_values[\"FilesystemLogsPathTotalBytes\"] = stat.f_blocks * stat.f_bsize;\n+        new_values[\"FilesystemLogsPathAvailableBytes\"] = stat.f_bavail * stat.f_bsize;\n+        new_values[\"FilesystemLogsPathUsedBytes\"] = (stat.f_blocks - stat.f_bavail) * stat.f_bsize;\n+        new_values[\"FilesystemLogsPathTotalINodes\"] = stat.f_files;\n+        new_values[\"FilesystemLogsPathAvailableINodes\"] = stat.f_favail;\n+        new_values[\"FilesystemLogsPathUsedINodes\"] = stat.f_files - stat.f_favail;\n+    }\n+\n+    /// Free and total space on every configured disk.\n+    {\n+        DisksMap disks_map = getContext()->getDisksMap();\n+        for (const auto & [name, disk] : disks_map)\n+        {\n+            auto total = disk->getTotalSpace();\n+\n+            /// Some disks don't support information about the space.\n+            if (!total)\n+                continue;\n+\n+            auto available = disk->getAvailableSpace();\n+            auto unreserved = disk->getUnreservedSpace();\n+\n+            new_values[fmt::format(\"DiskTotal_{}\", name)] = total;\n+            new_values[fmt::format(\"DiskUsed_{}\", name)] = total - available;\n+            new_values[fmt::format(\"DiskAvailable_{}\", name)] = available;\n+            new_values[fmt::format(\"DiskUnreserved_{}\", name)] = unreserved;\n+        }\n+    }\n+\n     {\n         auto databases = DatabaseCatalog::instance().getDatabases();\n \n@@ -267,6 +1161,7 @@ void AsynchronousMetrics::update()\n             /// Check if database can contain MergeTree tables\n             if (!db.second->canContainMergeTreeTables())\n                 continue;\n+\n             for (auto iterator = db.second->getTablesIterator(getContext()); iterator->isValid(); iterator->next())\n             {\n                 ++total_number_of_tables;\n@@ -274,10 +1169,17 @@ void AsynchronousMetrics::update()\n                 if (!table)\n                     continue;\n \n-                StorageMergeTree * table_merge_tree = dynamic_cast<StorageMergeTree *>(table.get());\n-                StorageReplicatedMergeTree * table_replicated_merge_tree = dynamic_cast<StorageReplicatedMergeTree *>(table.get());\n+                if (MergeTreeData * table_merge_tree = dynamic_cast<MergeTreeData *>(table.get()))\n+                {\n+                    const auto & settings = getContext()->getSettingsRef();\n \n-                if (table_replicated_merge_tree)\n+                    calculateMax(max_part_count_for_partition, table_merge_tree->getMaxPartsCountForPartition());\n+                    total_number_of_bytes += table_merge_tree->totalBytes(settings).value();\n+                    total_number_of_rows += table_merge_tree->totalRows(settings).value();\n+                    total_number_of_parts += table_merge_tree->getPartsCount();\n+                }\n+\n+                if (StorageReplicatedMergeTree * table_replicated_merge_tree = dynamic_cast<StorageReplicatedMergeTree *>(table.get()))\n                 {\n                     StorageReplicatedMergeTree::Status status;\n                     table_replicated_merge_tree->getStatus(status, false);\n@@ -303,24 +1205,6 @@ void AsynchronousMetrics::update()\n                                 \"Cannot get replica delay for table: \" + backQuoteIfNeed(db.first) + \".\" + backQuoteIfNeed(iterator->name()));\n                         }\n                     }\n-\n-                    calculateMax(max_part_count_for_partition, table_replicated_merge_tree->getMaxPartsCountForPartition());\n-                }\n-\n-                if (table_merge_tree)\n-                {\n-                    calculateMax(max_part_count_for_partition, table_merge_tree->getMaxPartsCountForPartition());\n-                    const auto & settings = getContext()->getSettingsRef();\n-                    total_number_of_bytes += table_merge_tree->totalBytes(settings).value();\n-                    total_number_of_rows += table_merge_tree->totalRows(settings).value();\n-                    total_number_of_parts += table_merge_tree->getPartsCount();\n-                }\n-                if (table_replicated_merge_tree)\n-                {\n-                    const auto & settings = getContext()->getSettingsRef();\n-                    total_number_of_bytes += table_replicated_merge_tree->totalBytes(settings).value();\n-                    total_number_of_rows += table_replicated_merge_tree->totalRows(settings).value();\n-                    total_number_of_parts += table_replicated_merge_tree->getPartsCount();\n                 }\n             }\n         }\n@@ -347,7 +1231,8 @@ void AsynchronousMetrics::update()\n \n         auto get_metric_name = [](const String & name) -> const char *\n         {\n-            static std::map<String, const char *> metric_map = {\n+            static std::map<String, const char *> metric_map =\n+            {\n                 {\"tcp_port\", \"TCPThreads\"},\n                 {\"tcp_port_secure\", \"TCPSecureThreads\"},\n                 {\"http_port\", \"HTTPThreads\"},\n@@ -410,58 +1295,18 @@ void AsynchronousMetrics::update()\n     saveAllArenasMetric<size_t>(new_values, \"muzzy_purged\");\n #endif\n \n-#if defined(OS_LINUX)\n-    // Try to add processor frequencies, ignoring errors.\n-    try\n-    {\n-        ReadBufferFromFile buf(\"/proc/cpuinfo\", 32768 /* buf_size */);\n-\n-        // We need the following lines:\n-        // processor : 4\n-        // cpu MHz : 4052.941\n-        // They contain tabs and are interspersed with other info.\n-        int core_id = 0;\n-        while (!buf.eof())\n-        {\n-            std::string s;\n-            // We don't have any backslash escape sequences in /proc/cpuinfo, so\n-            // this function will read the line until EOL, which is exactly what\n-            // we need.\n-            readEscapedStringUntilEOL(s, buf);\n-            // It doesn't read the EOL itself.\n-            ++buf.position();\n-\n-            if (s.rfind(\"processor\", 0) == 0)\n-            {\n-                if (auto colon = s.find_first_of(':'))\n-                {\n-                    core_id = std::stoi(s.substr(colon + 2));\n-                }\n-            }\n-            else if (s.rfind(\"cpu MHz\", 0) == 0)\n-            {\n-                if (auto colon = s.find_first_of(':'))\n-                {\n-                    auto mhz = std::stod(s.substr(colon + 2));\n-                    new_values[fmt::format(\"CPUFrequencyMHz_{}\", core_id)] = mhz;\n-                }\n-            }\n-        }\n-    }\n-    catch (...)\n-    {\n-        tryLogCurrentException(__PRETTY_FUNCTION__);\n-    }\n-#endif\n-\n     /// Add more metrics as you wish.\n \n-    // Log the new metrics.\n+    new_values[\"AsynchronousMetricsCalculationTimeSpent\"] = watch.elapsedSeconds();\n+\n+    /// Log the new metrics.\n     if (auto log = getContext()->getAsynchronousMetricLog())\n     {\n         log->addValues(new_values);\n     }\n \n+    first_run = false;\n+\n     // Finally, update the current metrics.\n     std::lock_guard lock(mutex);\n     values = new_values;\ndiff --git a/src/Interpreters/AsynchronousMetrics.h b/src/Interpreters/AsynchronousMetrics.h\nindex 38875c21edd5..606d117e6059 100644\n--- a/src/Interpreters/AsynchronousMetrics.h\n+++ b/src/Interpreters/AsynchronousMetrics.h\n@@ -3,11 +3,15 @@\n #include <Interpreters/Context_fwd.h>\n #include <Common/MemoryStatisticsOS.h>\n #include <Common/ThreadPool.h>\n+#include <IO/ReadBufferFromFile.h>\n \n #include <condition_variable>\n+#include <map>\n #include <mutex>\n #include <string>\n #include <thread>\n+#include <vector>\n+#include <optional>\n #include <unordered_map>\n \n \n@@ -15,6 +19,7 @@ namespace DB\n {\n \n class ProtocolServerAdapter;\n+class ReadBuffer;\n \n using AsynchronousMetricValue = double;\n using AsynchronousMetricValues = std::unordered_map<std::string, AsynchronousMetricValue>;\n@@ -23,22 +28,13 @@ using AsynchronousMetricValues = std::unordered_map<std::string, AsynchronousMet\n /** Periodically (by default, each minute, starting at 30 seconds offset)\n   *  calculates and updates some metrics,\n   *  that are not updated automatically (so, need to be asynchronously calculated).\n+  *\n+  * This includes both ClickHouse-related metrics (like memory usage of ClickHouse process)\n+  *  and common OS-related metrics (like total memory usage on the server).\n   */\n class AsynchronousMetrics : WithContext\n {\n public:\n-#if defined(ARCADIA_BUILD)\n-    /// This constructor needs only to provide backward compatibility with some other projects (hello, Arcadia).\n-    /// Never use this in the ClickHouse codebase.\n-    AsynchronousMetrics(\n-        ContextPtr global_context_,\n-        int update_period_seconds = 60)\n-        : WithContext(global_context_)\n-        , update_period(update_period_seconds)\n-    {\n-    }\n-#endif\n-\n     /// The default value of update_period_seconds is for ClickHouse-over-YT\n     /// in Arcadia -- it uses its own server implementation that also uses these\n     /// metrics.\n@@ -46,28 +42,28 @@ class AsynchronousMetrics : WithContext\n         ContextPtr global_context_,\n         int update_period_seconds,\n         std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables_,\n-        std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_)\n-        : WithContext(global_context_)\n-        , update_period(update_period_seconds)\n-        , servers_to_start_before_tables(servers_to_start_before_tables_)\n-        , servers(servers_)\n-    {\n-    }\n+        std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_);\n \n     ~AsynchronousMetrics();\n \n     /// Separate method allows to initialize the `servers` variable beforehand.\n-    void start()\n-    {\n-        /// Update once right now, to make metrics available just after server start\n-        /// (without waiting for asynchronous_metrics_update_period_s).\n-        update();\n-        thread = std::make_unique<ThreadFromGlobalPool>([this] { run(); });\n-    }\n+    void start();\n \n     /// Returns copy of all values.\n     AsynchronousMetricValues getValues() const;\n \n+#if defined(ARCADIA_BUILD)\n+    /// This constructor needs only to provide backward compatibility with some other projects (hello, Arcadia).\n+    /// Never use this in the ClickHouse codebase.\n+    AsynchronousMetrics(\n+        ContextPtr global_context_,\n+        int update_period_seconds = 60)\n+        : WithContext(global_context_)\n+        , update_period(update_period_seconds)\n+    {\n+    }\n+#endif\n+\n private:\n     const std::chrono::seconds update_period;\n     std::shared_ptr<std::vector<ProtocolServerAdapter>> servers_to_start_before_tables{nullptr};\n@@ -78,14 +74,113 @@ class AsynchronousMetrics : WithContext\n     bool quit {false};\n     AsynchronousMetricValues values;\n \n+    /// Some values are incremental and we have to calculate the difference.\n+    /// On first run we will only collect the values to subtract later.\n+    bool first_run = true;\n+    std::chrono::system_clock::time_point previous_update_time;\n+\n #if defined(OS_LINUX)\n     MemoryStatisticsOS memory_stat;\n+\n+    std::optional<ReadBufferFromFile> meminfo;\n+    std::optional<ReadBufferFromFile> loadavg;\n+    std::optional<ReadBufferFromFile> proc_stat;\n+    std::optional<ReadBufferFromFile> cpuinfo;\n+    std::optional<ReadBufferFromFile> file_nr;\n+    std::optional<ReadBufferFromFile> uptime;\n+    std::optional<ReadBufferFromFile> net_dev;\n+\n+    std::vector<std::unique_ptr<ReadBufferFromFile>> thermal;\n+\n+    std::unordered_map<String /* device name */,\n+        std::unordered_map<String /* label name */,\n+            std::unique_ptr<ReadBufferFromFile>>> hwmon_devices;\n+\n+    std::vector<std::pair<\n+        std::unique_ptr<ReadBufferFromFile> /* correctable errors */,\n+        std::unique_ptr<ReadBufferFromFile> /* uncorrectable errors */>> edac;\n+\n+    std::unordered_map<String /* device name */, std::unique_ptr<ReadBufferFromFile>> block_devs;\n+\n+    /// TODO: socket statistics.\n+\n+    struct ProcStatValuesCPU\n+    {\n+        uint64_t user;\n+        uint64_t nice;\n+        uint64_t system;\n+        uint64_t idle;\n+        uint64_t iowait;\n+        uint64_t irq;\n+        uint64_t softirq;\n+        uint64_t steal;\n+        uint64_t guest;\n+        uint64_t guest_nice;\n+\n+        void read(ReadBuffer & in);\n+        ProcStatValuesCPU operator-(const ProcStatValuesCPU & other) const;\n+    };\n+\n+    struct ProcStatValuesOther\n+    {\n+        uint64_t interrupts;\n+        uint64_t context_switches;\n+        uint64_t processes_created;\n+\n+        ProcStatValuesOther operator-(const ProcStatValuesOther & other) const;\n+    };\n+\n+    ProcStatValuesCPU proc_stat_values_all_cpus{};\n+    ProcStatValuesOther proc_stat_values_other{};\n+    std::vector<ProcStatValuesCPU> proc_stat_values_per_cpu;\n+\n+    /// https://www.kernel.org/doc/Documentation/block/stat.txt\n+    struct BlockDeviceStatValues\n+    {\n+        uint64_t read_ios;\n+        uint64_t read_merges;\n+        uint64_t read_sectors;\n+        uint64_t read_ticks;\n+        uint64_t write_ios;\n+        uint64_t write_merges;\n+        uint64_t write_sectors;\n+        uint64_t write_ticks;\n+        uint64_t in_flight_ios;\n+        uint64_t io_ticks;\n+        uint64_t time_in_queue;\n+        uint64_t discard_ops;\n+        uint64_t discard_merges;\n+        uint64_t discard_sectors;\n+        uint64_t discard_ticks;\n+\n+        void read(ReadBuffer & in);\n+        BlockDeviceStatValues operator-(const BlockDeviceStatValues & other) const;\n+    };\n+\n+    std::unordered_map<String /* device name */, BlockDeviceStatValues> block_device_stats;\n+\n+    struct NetworkInterfaceStatValues\n+    {\n+        uint64_t recv_bytes;\n+        uint64_t recv_packets;\n+        uint64_t recv_errors;\n+        uint64_t recv_drop;\n+        uint64_t send_bytes;\n+        uint64_t send_packets;\n+        uint64_t send_errors;\n+        uint64_t send_drop;\n+\n+        NetworkInterfaceStatValues operator-(const NetworkInterfaceStatValues & other) const;\n+    };\n+\n+    std::unordered_map<String /* device name */, NetworkInterfaceStatValues> network_interface_stats;\n+\n #endif\n \n     std::unique_ptr<ThreadFromGlobalPool> thread;\n \n     void run();\n-    void update();\n+    void update(std::chrono::system_clock::time_point update_time);\n };\n \n }\n",
  "test_patch": "diff --git a/docker/test/performance-comparison/compare.sh b/docker/test/performance-comparison/compare.sh\nindex c3447c17d35e..9a8ffff7cd9a 100755\n--- a/docker/test/performance-comparison/compare.sh\n+++ b/docker/test/performance-comparison/compare.sh\n@@ -1178,11 +1178,11 @@ create view right_async_metric_log as\n -- Use the right log as time reference because it may have higher precision.\n create table metrics engine File(TSV, 'metrics/metrics.tsv') as\n     with (select min(event_time) from right_async_metric_log) as min_time\n-    select name metric, r.event_time - min_time event_time, l.value as left, r.value as right\n+    select metric, r.event_time - min_time event_time, l.value as left, r.value as right\n     from right_async_metric_log r\n     asof join file('left-async-metric-log.tsv', TSVWithNamesAndTypes,\n         '$(cat left-async-metric-log.tsv.columns)') l\n-    on l.name = r.name and r.event_time <= l.event_time\n+    on l.metric = r.metric and r.event_time <= l.event_time\n     order by metric, event_time\n     ;\n \n",
  "problem_statement": "Collect global system metrics inside ClickHouse.\nCollect common system metrics like load average, CPU load in userspace and kernel, IO wait, etc... inside ClickHouse.\r\n\r\n**Use case**\r\nMany users don't have any monitoring tools set up. Some cloud providers have basic monitoring capabilities by default but they are often not enough. Collecting and storing system metrics inside ClickHouse will be essentially free.\r\n\r\nAnother imaginary use case - is to run empty ClickHouse server just to collect system metrics.\r\n\r\n**Describe the solution you'd like**\r\nCalculate the required values in `AsynchronousMetrics`.\r\n\r\nThere are multiple tools and libraries that have relevant code: NetData, PCP. \r\n\r\nUnfortunately, most of them are under GPL or LGPL. We can use LGPL inside ClickHouse if the code will be represented as a separate library (not as just a chunks of reused code).\n",
  "hints_text": "The essential metrics are:\r\n\r\n- load average and the number of processes;\r\n- time spent (\"cpu usage\" in userspace, kernel, io wait...);\r\n- memory usage (total, cached, buffers, swap, free + cached...);\r\n- disk (filesystem) usage (total, used - across all mounted filesystems);\r\n- network traffic (received, transferred, bytes/packets, TCP retransmits across all network interfaces);\r\n- IO operations (IO operations/second, disk traffic, queue size, utilization);\r\n- scheduler statistics (context switches);\r\n- CPU info (current frequency - max/min/avg across all cores);\r\n- the number of opened file descriptors;\r\n- network connections (in, out, TCP, UDP, the number of distinct hosts);\r\n",
  "created_at": "2021-05-22T10:26:03Z"
}