{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54119,
  "instance_id": "ClickHouse__ClickHouse-54119",
  "issue_numbers": [
    "45790",
    "31643",
    "41957"
  ],
  "base_commit": "587013d994b12ab0f9f6664750bf3be9a75cd3bf",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex 4ebccaec4e93..caed96b03208 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -40,9 +40,6 @@\n [submodule \"contrib/boost\"]\n \tpath = contrib/boost\n \turl = https://github.com/ClickHouse/boost\n-[submodule \"contrib/base64\"]\n-\tpath = contrib/base64\n-\turl = https://github.com/ClickHouse/Turbo-Base64\n [submodule \"contrib/arrow\"]\n \tpath = contrib/arrow\n \turl = https://github.com/ClickHouse/arrow\n@@ -348,3 +345,6 @@\n [submodule \"contrib/robin-map\"]\n \tpath = contrib/robin-map\n \turl = https://github.com/Tessil/robin-map.git\n+[submodule \"contrib/aklomp-base64\"]\n+\tpath = contrib/aklomp-base64\n+\turl = https://github.com/aklomp/base64.git\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 7b98cf43b09a..f9c3fddff40c 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -135,7 +135,7 @@ add_contrib (aws-cmake\n     aws-cmake\n )\n \n-add_contrib (base64-cmake base64)\n+add_contrib (aklomp-base64-cmake aklomp-base64)\n add_contrib (simdjson-cmake simdjson)\n add_contrib (rapidjson-cmake rapidjson)\n add_contrib (fastops-cmake fastops)\ndiff --git a/contrib/aklomp-base64 b/contrib/aklomp-base64\nnew file mode 160000\nindex 000000000000..e77bd70bdd86\n--- /dev/null\n+++ b/contrib/aklomp-base64\n@@ -0,0 +1,1 @@\n+Subproject commit e77bd70bdd860c52c561568cffb251d88bba064c\ndiff --git a/contrib/aklomp-base64-cmake/.gitignore b/contrib/aklomp-base64-cmake/.gitignore\nnew file mode 100644\nindex 000000000000..0e56cf2f8c1e\n--- /dev/null\n+++ b/contrib/aklomp-base64-cmake/.gitignore\n@@ -0,0 +1,1 @@\n+config.h\ndiff --git a/contrib/aklomp-base64-cmake/CMakeLists.txt b/contrib/aklomp-base64-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..4b988fad8609\n--- /dev/null\n+++ b/contrib/aklomp-base64-cmake/CMakeLists.txt\n@@ -0,0 +1,68 @@\n+option (ENABLE_BASE64 \"Enable base64\" ${ENABLE_LIBRARIES})\n+\n+if (NOT ENABLE_BASE64)\n+    message(STATUS \"Not using base64\")\n+    return()\n+endif()\n+\n+SET(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/aklomp-base64\")\n+\n+if (ARCH_AMD64)\n+    # These defines enable/disable SIMD codecs in base64's runtime codec dispatch.\n+    # We don't want to limit ourselves --> enable all.\n+    set(HAVE_SSSE3 1)\n+    set(HAVE_SSE41 1)\n+    set(HAVE_SSE42 1)\n+    set(HAVE_AVX 1)\n+    set(HAVE_AVX2 1)\n+    set(HAVE_AVX512 1)\n+endif ()\n+\n+if (ARCH_AARCH64)\n+    # The choice of HAVE_NEON* depends on the target machine because base64 provides\n+    # no runtime dispatch on ARM. NEON is only mandatory with the normal build profile.\n+    if(NOT NO_ARMV81_OR_HIGHER)\n+        set(HAVE_NEON64 1)\n+        set(HAVE_NEON32 0)\n+    endif ()\n+endif ()\n+\n+configure_file(config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)\n+\n+add_library(_base64\n+    \"${LIBRARY_DIR}/lib/lib.c\"\n+    \"${LIBRARY_DIR}/lib/codec_choose.c\"\n+\n+    \"${LIBRARY_DIR}/lib/tables/tables.c\"\n+    \"${LIBRARY_DIR}/lib/tables/table_dec_32bit.h\"\n+    \"${LIBRARY_DIR}/lib/tables/table_enc_12bit.h\"\n+\n+    \"${LIBRARY_DIR}/lib/codecs.h\"\n+\n+    \"${CMAKE_CURRENT_BINARY_DIR}/config.h\"\n+\n+    \"${LIBRARY_DIR}/lib/arch/generic/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/ssse3/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/sse41/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/sse42/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/avx/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/avx2/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/avx512/codec.c\"\n+\n+    \"${LIBRARY_DIR}/lib/arch/neon32/codec.c\"\n+    \"${LIBRARY_DIR}/lib/arch/neon64/codec.c\"\n+)\n+\n+if (ARCH_AMD64)\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/ssse3/codec.c PROPERTIES COMPILE_FLAGS \"-mssse3\")\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/sse41/codec.c PROPERTIES COMPILE_FLAGS \"-msse4.1\")\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/sse42/codec.c PROPERTIES COMPILE_FLAGS \"-msse4.2\")\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/avx/codec.c PROPERTIES COMPILE_FLAGS \"-mavx\")\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/avx2/codec.c PROPERTIES COMPILE_FLAGS \"-mavx2\")\n+    set_source_files_properties(${LIBRARY_DIR}/lib/arch/avx512/codec.c PROPERTIES COMPILE_FLAGS \"-mavx512vl -mavx512vbmi\")\n+endif()\n+\n+target_include_directories(_base64 SYSTEM PUBLIC ${LIBRARY_DIR}/include)\n+target_include_directories(_base64 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})\n+\n+add_library(ch_contrib::base64 ALIAS _base64)\ndiff --git a/contrib/aklomp-base64-cmake/config.h.in b/contrib/aklomp-base64-cmake/config.h.in\nnew file mode 100644\nindex 000000000000..4dc84632b30b\n--- /dev/null\n+++ b/contrib/aklomp-base64-cmake/config.h.in\n@@ -0,0 +1,9 @@\n+#cmakedefine01 HAVE_SSSE3\n+#cmakedefine01 HAVE_SSE41\n+#cmakedefine01 HAVE_SSE42\n+#cmakedefine01 HAVE_AVX\n+#cmakedefine01 HAVE_AVX2\n+#cmakedefine01 HAVE_AVX512\n+\n+#cmakedefine01 HAVE_NEON32\n+#cmakedefine01 HAVE_NEON64\ndiff --git a/contrib/base64 b/contrib/base64\ndeleted file mode 160000\nindex 8628e258090f..000000000000\n--- a/contrib/base64\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-Subproject commit 8628e258090f9eb76d90ac3c91e1ab4690e9aa11\ndiff --git a/contrib/base64-cmake/CMakeLists.txt b/contrib/base64-cmake/CMakeLists.txt\ndeleted file mode 100644\nindex 333e0a96a0ba..000000000000\n--- a/contrib/base64-cmake/CMakeLists.txt\n+++ /dev/null\n@@ -1,60 +0,0 @@\n-if(ARCH_AMD64 OR ARCH_AARCH64 OR ARCH_PPC64LE OR ARCH_S390X)\n-    option (ENABLE_BASE64 \"Enable base64\" ${ENABLE_LIBRARIES})\n-elseif(ENABLE_BASE64)\n-    message (${RECONFIGURE_MESSAGE_LEVEL} \"base64 library is only supported on x86_64 and aarch64\")\n-endif()\n-\n-if (NOT ENABLE_BASE64)\n-    message(STATUS \"Not using base64\")\n-    return()\n-endif()\n-\n-SET(LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/base64\")\n-\n-add_library(_base64_scalar OBJECT \"${LIBRARY_DIR}/turbob64c.c\" \"${LIBRARY_DIR}/turbob64d.c\")\n-add_library(_base64_ssse3 OBJECT \"${LIBRARY_DIR}/turbob64sse.c\") # This file also contains code for ARM NEON\n-\n-if (ARCH_AMD64)\n-    add_library(_base64_avx OBJECT \"${LIBRARY_DIR}/turbob64sse.c\") # This is not a mistake. One file is compiled twice.\n-    add_library(_base64_avx2 OBJECT \"${LIBRARY_DIR}/turbob64avx2.c\")\n-endif ()\n-\n-target_compile_options(_base64_scalar PRIVATE -falign-loops)\n-\n-if (ARCH_AMD64)\n-    target_compile_options(_base64_ssse3 PRIVATE -mno-avx -mno-avx2 -mssse3 -falign-loops)\n-    target_compile_options(_base64_avx PRIVATE -falign-loops -mavx)\n-    target_compile_options(_base64_avx2 PRIVATE -falign-loops -mavx2)\n-else ()\n-    if (ARCH_PPC64LE)\n-        target_compile_options(_base64_ssse3 PRIVATE -D__SSSE3__ -falign-loops)\n-    else()\n-        target_compile_options(_base64_ssse3 PRIVATE -falign-loops)\n-    endif()\n-endif ()\n-\n-if (ARCH_AMD64)\n-    add_library(_base64\n-        $<TARGET_OBJECTS:_base64_scalar>\n-        $<TARGET_OBJECTS:_base64_ssse3>\n-        $<TARGET_OBJECTS:_base64_avx>\n-        $<TARGET_OBJECTS:_base64_avx2>)\n-else ()\n-    add_library(_base64\n-        $<TARGET_OBJECTS:_base64_scalar>\n-        $<TARGET_OBJECTS:_base64_ssse3>)\n-endif ()\n-\n-target_include_directories(_base64 SYSTEM PUBLIC ${LIBRARY_DIR})\n-\n-if (XCODE OR XCODE_VERSION)\n-    # https://gitlab.kitware.com/cmake/cmake/issues/17457\n-    #     Some native build systems may not like targets that have only object files, so consider adding at least one real source file\n-    # This applies to Xcode.\n-    if (NOT EXISTS \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\")\n-        file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\" \"\")\n-    endif ()\n-    target_sources(_base64 PRIVATE \"${CMAKE_CURRENT_BINARY_DIR}/dummy.c\")\n-endif ()\n-\n-add_library(ch_contrib::base64 ALIAS _base64)\ndiff --git a/docs/en/operations/system-tables/licenses.md b/docs/en/operations/system-tables/licenses.md\nindex 0f09d559d8be..c436c0ade3b9 100644\n--- a/docs/en/operations/system-tables/licenses.md\n+++ b/docs/en/operations/system-tables/licenses.md\n@@ -1,7 +1,7 @@\n ---\n slug: /en/operations/system-tables/licenses\n ---\n-# licenses \n+# licenses\n \n Contains licenses of third-party libraries that are located in the [contrib](https://github.com/ClickHouse/ClickHouse/tree/master/contrib) directory of ClickHouse sources.\n \n@@ -20,21 +20,10 @@ SELECT library_name, license_type, license_path FROM system.licenses LIMIT 15\n \n ``` text\n \u250c\u2500library_name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500license_type\u2500\u252c\u2500license_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n-\u2502 FastMemcpy         \u2502 MIT          \u2502 /contrib/FastMemcpy/LICENSE         \u2502\n-\u2502 arrow              \u2502 Apache       \u2502 /contrib/arrow/LICENSE.txt          \u2502\n-\u2502 avro               \u2502 Apache       \u2502 /contrib/avro/LICENSE.txt           \u2502\n \u2502 aws-c-common       \u2502 Apache       \u2502 /contrib/aws-c-common/LICENSE       \u2502\n-\u2502 aws-c-event-stream \u2502 Apache       \u2502 /contrib/aws-c-event-stream/LICENSE \u2502\n-\u2502 aws-checksums      \u2502 Apache       \u2502 /contrib/aws-checksums/LICENSE      \u2502\n-\u2502 aws                \u2502 Apache       \u2502 /contrib/aws/LICENSE.txt            \u2502\n-\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/base64/LICENSE             \u2502\n-\u2502 boost              \u2502 Boost        \u2502 /contrib/boost/LICENSE_1_0.txt      \u2502\n+\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/aklomp-base64/LICENSE      \u2502\n \u2502 brotli             \u2502 MIT          \u2502 /contrib/brotli/LICENSE             \u2502\n-\u2502 capnproto          \u2502 MIT          \u2502 /contrib/capnproto/LICENSE          \u2502\n-\u2502 cassandra          \u2502 Apache       \u2502 /contrib/cassandra/LICENSE.txt      \u2502\n-\u2502 cctz               \u2502 Apache       \u2502 /contrib/cctz/LICENSE.txt           \u2502\n-\u2502 cityhash102        \u2502 MIT          \u2502 /contrib/cityhash102/COPYING        \u2502\n-\u2502 cppkafka           \u2502 BSD 2-clause \u2502 /contrib/cppkafka/LICENSE           \u2502\n+\u2502 [...]              \u2502 [...]        \u2502 [...]                               \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \n ```\ndiff --git a/docs/ru/operations/system-tables/licenses.md b/docs/ru/operations/system-tables/licenses.md\nindex 13407a27c94c..e35b5d5e3be2 100644\n--- a/docs/ru/operations/system-tables/licenses.md\n+++ b/docs/ru/operations/system-tables/licenses.md\n@@ -20,21 +20,10 @@ SELECT library_name, license_type, license_path FROM system.licenses LIMIT 15\n \n ``` text\n \u250c\u2500library_name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500license_type\u2500\u252c\u2500license_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n-\u2502 FastMemcpy         \u2502 MIT          \u2502 /contrib/FastMemcpy/LICENSE         \u2502\n-\u2502 arrow              \u2502 Apache       \u2502 /contrib/arrow/LICENSE.txt          \u2502\n-\u2502 avro               \u2502 Apache       \u2502 /contrib/avro/LICENSE.txt           \u2502\n \u2502 aws-c-common       \u2502 Apache       \u2502 /contrib/aws-c-common/LICENSE       \u2502\n-\u2502 aws-c-event-stream \u2502 Apache       \u2502 /contrib/aws-c-event-stream/LICENSE \u2502\n-\u2502 aws-checksums      \u2502 Apache       \u2502 /contrib/aws-checksums/LICENSE      \u2502\n-\u2502 aws                \u2502 Apache       \u2502 /contrib/aws/LICENSE.txt            \u2502\n-\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/base64/LICENSE             \u2502\n-\u2502 boost              \u2502 Boost        \u2502 /contrib/boost/LICENSE_1_0.txt      \u2502\n+\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/aklomp-base64/LICENSE      \u2502\n \u2502 brotli             \u2502 MIT          \u2502 /contrib/brotli/LICENSE             \u2502\n-\u2502 capnproto          \u2502 MIT          \u2502 /contrib/capnproto/LICENSE          \u2502\n-\u2502 cassandra          \u2502 Apache       \u2502 /contrib/cassandra/LICENSE.txt      \u2502\n-\u2502 cctz               \u2502 Apache       \u2502 /contrib/cctz/LICENSE.txt           \u2502\n-\u2502 cityhash102        \u2502 MIT          \u2502 /contrib/cityhash102/COPYING        \u2502\n-\u2502 cppkafka           \u2502 BSD 2-clause \u2502 /contrib/cppkafka/LICENSE           \u2502\n+\u2502 [...]              \u2502 [...]        \u2502 [...]                               \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \n ```\ndiff --git a/docs/zh/operations/system-tables/licenses.md b/docs/zh/operations/system-tables/licenses.md\nindex dc09e65264d2..38260491dc07 100644\n--- a/docs/zh/operations/system-tables/licenses.md\n+++ b/docs/zh/operations/system-tables/licenses.md\n@@ -20,21 +20,9 @@ SELECT library_name, license_type, license_path FROM system.licenses LIMIT 15\n \n ``` text\n \u250c\u2500library_name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500license_type\u2500\u252c\u2500license_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n-\u2502 FastMemcpy         \u2502 MIT          \u2502 /contrib/FastMemcpy/LICENSE         \u2502\n-\u2502 arrow              \u2502 Apache       \u2502 /contrib/arrow/LICENSE.txt          \u2502\n-\u2502 avro               \u2502 Apache       \u2502 /contrib/avro/LICENSE.txt           \u2502\n \u2502 aws-c-common       \u2502 Apache       \u2502 /contrib/aws-c-common/LICENSE       \u2502\n-\u2502 aws-c-event-stream \u2502 Apache       \u2502 /contrib/aws-c-event-stream/LICENSE \u2502\n-\u2502 aws-checksums      \u2502 Apache       \u2502 /contrib/aws-checksums/LICENSE      \u2502\n-\u2502 aws                \u2502 Apache       \u2502 /contrib/aws/LICENSE.txt            \u2502\n-\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/base64/LICENSE             \u2502\n-\u2502 boost              \u2502 Boost        \u2502 /contrib/boost/LICENSE_1_0.txt      \u2502\n+\u2502 base64             \u2502 BSD 2-clause \u2502 /contrib/aklomp-base64/LICENSE      \u2502\n \u2502 brotli             \u2502 MIT          \u2502 /contrib/brotli/LICENSE             \u2502\n-\u2502 capnproto          \u2502 MIT          \u2502 /contrib/capnproto/LICENSE          \u2502\n-\u2502 cassandra          \u2502 Apache       \u2502 /contrib/cassandra/LICENSE.txt      \u2502\n-\u2502 cctz               \u2502 Apache       \u2502 /contrib/cctz/LICENSE.txt           \u2502\n-\u2502 cityhash102        \u2502 MIT          \u2502 /contrib/cityhash102/COPYING        \u2502\n-\u2502 cppkafka           \u2502 BSD 2-clause \u2502 /contrib/cppkafka/LICENSE           \u2502\n+\u2502 [...]              \u2502 [...]        \u2502 [...]                               \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-\n ```\ndiff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h\nindex ef340a331494..f52dec0eaf76 100644\n--- a/src/Functions/FunctionBase64Conversion.h\n+++ b/src/Functions/FunctionBase64Conversion.h\n@@ -8,53 +8,34 @@\n #    include <Functions/FunctionHelpers.h>\n #    include <Functions/IFunction.h>\n #    include <Interpreters/Context_fwd.h>\n-#    include <turbob64.h>\n+#    include <libbase64.h>\n #    include <Common/MemorySanitizer.h>\n \n+#    include <cstddef>\n #    include <span>\n \n namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int BAD_ARGUMENTS;\n     extern const int ILLEGAL_COLUMN;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int INCORRECT_DATA;\n }\n \n-namespace Detail\n-{\n-    inline size_t base64Decode(const std::span<const UInt8> src, UInt8 * dst)\n-    {\n-#    if defined(__aarch64__)\n-        return tb64sdec(reinterpret_cast<const uint8_t *>(src.data()), src.size(), reinterpret_cast<uint8_t *>(dst));\n-#    else\n-        return _tb64d(reinterpret_cast<const uint8_t *>(src.data()), src.size(), reinterpret_cast<uint8_t *>(dst));\n-#    endif\n-    }\n-}\n-\n struct Base64Encode\n {\n     static constexpr auto name = \"base64Encode\";\n \n-    static size_t getBufferSize(const size_t string_length, const size_t string_count)\n+    static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n         return ((string_length - string_count) / 3 + string_count) * 4 + string_count;\n     }\n \n-    static size_t performCoding(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n     {\n-        /*\n-        * Some bug in sse arm64 implementation?\n-        * `base64Encode(repeat('a', 46))` returns wrong padding character\n-        */\n-#    if defined(__aarch64__)\n-        return tb64senc(reinterpret_cast<const uint8_t *>(src.data()), src.size(), reinterpret_cast<uint8_t *>(dst));\n-#    else\n-        return _tb64e(reinterpret_cast<const uint8_t *>(src.data()), src.size(), reinterpret_cast<uint8_t *>(dst));\n-#    endif\n+        size_t outlen = 0;\n+        base64_encode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        return outlen;\n     }\n };\n \n@@ -62,15 +43,17 @@ struct Base64Decode\n {\n     static constexpr auto name = \"base64Decode\";\n \n-    static size_t getBufferSize(const size_t string_length, const size_t string_count)\n+    static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n         return ((string_length - string_count) / 4 + string_count) * 3 + string_count;\n     }\n \n-    static size_t performCoding(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n     {\n-        const auto outlen = Detail::base64Decode(src, dst);\n-        if (src.size() > 0 && !outlen)\n+        size_t outlen = 0;\n+        int rc = base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+\n+        if (rc != 1)\n             throw Exception(\n                 ErrorCodes::INCORRECT_DATA,\n                 \"Failed to {} input '{}'\",\n@@ -85,17 +68,16 @@ struct TryBase64Decode\n {\n     static constexpr auto name = \"tryBase64Decode\";\n \n-    static size_t getBufferSize(const size_t string_length, const size_t string_count)\n+    static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n         return Base64Decode::getBufferSize(string_length, string_count);\n     }\n \n-    static size_t performCoding(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n     {\n-        if (src.empty())\n-            return 0;\n+        size_t outlen = 0;\n+        base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n \n-        const auto outlen = Detail::base64Decode(src, dst);\n         // during decoding character array can be partially polluted\n         // if fail, revert back and clean\n         if (!outlen)\n@@ -119,20 +101,16 @@ class FunctionBase64Conversion : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.size() != 1)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Wrong number of arguments for function {}: 1 expected.\", getName());\n+        FunctionArgumentDescriptors mandatory_arguments{\n+            {\"value\", &isStringOrFixedString<IDataType>, nullptr, \"String or FixedString\"}\n+        };\n \n-        if (!WhichDataType(arguments[0].type).isStringOrFixedString())\n-            throw Exception(\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type {} of 1st argument of function {}. Must be FixedString or String.\",\n-                arguments[0].type->getName(),\n-                getName());\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_arguments);\n \n         return std::make_shared<DataTypeString>();\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, const size_t input_rows_count) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n         const auto & input_column = arguments[0].column;\n         if (const auto * src_column_as_fixed_string = checkAndGetColumn<ColumnFixedString>(*input_column))\n@@ -148,7 +126,7 @@ class FunctionBase64Conversion : public IFunction\n     }\n \n private:\n-    static ColumnPtr execute(const ColumnString & src_column, const size_t src_row_count)\n+    static ColumnPtr execute(const ColumnString & src_column, size_t src_row_count)\n     {\n         auto dst_column = ColumnString::create();\n         auto & dst_chars = dst_column->getChars();\n@@ -169,7 +147,7 @@ class FunctionBase64Conversion : public IFunction\n         for (size_t row = 0; row < src_row_count; ++row)\n         {\n             const size_t src_length = src_offsets[row] - src_offset_prev - 1;\n-            const auto outlen = Func::performCoding({src, src_length}, dst_pos);\n+            const auto outlen = Func::perform({src, src_length}, dst_pos);\n \n             /// Base64 library is using AVX-512 with some shuffle operations.\n             /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.\n@@ -188,7 +166,7 @@ class FunctionBase64Conversion : public IFunction\n         return dst_column;\n     }\n \n-    static ColumnPtr execute(const ColumnFixedString & src_column, const size_t src_row_count)\n+    static ColumnPtr execute(const ColumnFixedString & src_column, size_t src_row_count)\n     {\n         auto dst_column = ColumnString::create();\n         auto & dst_chars = dst_column->getChars();\n@@ -207,7 +185,7 @@ class FunctionBase64Conversion : public IFunction\n \n         for (size_t row = 0; row < src_row_count; ++row)\n         {\n-            const auto outlen = Func::performCoding({src, src_n}, dst_pos);\n+            const auto outlen = Func::perform({src, src_n}, dst_pos);\n \n             /// Base64 library is using AVX-512 with some shuffle operations.\n             /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.\n@@ -225,6 +203,7 @@ class FunctionBase64Conversion : public IFunction\n         return dst_column;\n     }\n };\n+\n }\n \n #endif\ndiff --git a/src/Functions/base64Decode.cpp b/src/Functions/base64Decode.cpp\nindex 4060aafe1a3b..842ceeb3a878 100644\n--- a/src/Functions/base64Decode.cpp\n+++ b/src/Functions/base64Decode.cpp\n@@ -7,7 +7,6 @@ namespace DB\n {\n REGISTER_FUNCTION(Base64Decode)\n {\n-    tb64ini(0, 0);\n     factory.registerFunction<FunctionBase64Conversion<Base64Decode>>();\n \n     /// MysQL compatibility alias.\ndiff --git a/src/Functions/base64Encode.cpp b/src/Functions/base64Encode.cpp\nindex 773db7e09d98..38b45790a3a0 100644\n--- a/src/Functions/base64Encode.cpp\n+++ b/src/Functions/base64Encode.cpp\n@@ -7,7 +7,6 @@ namespace DB\n {\n REGISTER_FUNCTION(Base64Encode)\n {\n-    tb64ini(0, 0);\n     factory.registerFunction<FunctionBase64Conversion<Base64Encode>>();\n \n     /// MysQL compatibility alias.\ndiff --git a/utils/check-style/check-include b/utils/check-style/check-include\nindex 3c0c6103958f..efa5121157d4 100755\n--- a/utils/check-style/check-include\n+++ b/utils/check-style/check-include\n@@ -51,7 +51,7 @@ inc=\"-I. \\\n -I./base/daemon \\\n -I./base/consistent-hashing \\\n -I./contrib/libhdfs3/include \\\n--I./contrib/base64/include \\\n+-I./contrib/aklomp-base64/include \\\n -I./contrib/protobuf/src \\\n -I./contrib/cppkafka/include \\\n -I./contrib/librdkafka-cmake/include \\\n",
  "test_patch": "diff --git a/docker/test/fasttest/run.sh b/docker/test/fasttest/run.sh\nindex 477bbdb6919e..296a132d3e3d 100755\n--- a/docker/test/fasttest/run.sh\n+++ b/docker/test/fasttest/run.sh\n@@ -120,7 +120,7 @@ function clone_submodules\n             contrib/libxml2\n             contrib/libunwind\n             contrib/fmtlib\n-            contrib/base64\n+            contrib/aklomp-base64\n             contrib/cctz\n             contrib/libcpuid\n             contrib/libdivide\ndiff --git a/tests/integration/test_backward_compatibility/test_functions.py b/tests/integration/test_backward_compatibility/test_functions.py\nindex c86c3ba0ab29..607ac74d7258 100644\n--- a/tests/integration/test_backward_compatibility/test_functions.py\n+++ b/tests/integration/test_backward_compatibility/test_functions.py\n@@ -148,6 +148,11 @@ def test_string_functions(start_cluster):\n         # 22.8 Backward Incompatible Change: Extended range of Date32\n         \"toDate32OrZero\",\n         \"toDate32OrDefault\",\n+        # 23.9 changed the base64-handling library from Turbo base64 to aklomp-base64. They differ in the way they deal with base64 values\n+        # that are not properly padded by '=', for example below test value v='foo'. (Depending on the specification/context, padding is\n+        # mandatory or optional). The former lib produces a value based on implicit padding, the latter lib throws an error.\n+        \"FROM_BASE64\",\n+        \"base64Decode\",\n     ]\n     functions = filter(lambda x: x not in excludes, functions)\n \ndiff --git a/tests/queries/0_stateless/00732_base64_functions.reference b/tests/queries/0_stateless/00732_base64_functions.reference\nindex 5dc1ba03b895..f97c19427e7b 100644\n--- a/tests/queries/0_stateless/00732_base64_functions.reference\n+++ b/tests/queries/0_stateless/00732_base64_functions.reference\n@@ -12,7 +12,18 @@ foo\n foob\n fooba\n foobar\n-1\t1\n \n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+1\t1\n+1\t1\n+fooba\n+~\ufffd\n Zm9v\n foo\n+foo\n+TEcgT3B0aW11cw==\ndiff --git a/tests/queries/0_stateless/00732_base64_functions.sql b/tests/queries/0_stateless/00732_base64_functions.sql\nindex adba0cdebbd7..99268004003d 100644\n--- a/tests/queries/0_stateless/00732_base64_functions.sql\n+++ b/tests/queries/0_stateless/00732_base64_functions.sql\n@@ -5,15 +5,24 @@ SET send_logs_level = 'fatal';\n SELECT base64Encode(val) FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar']) val);\n \n SELECT base64Decode(val) FROM (select arrayJoin(['', 'Zg==', 'Zm8=', 'Zm9v', 'Zm9vYg==', 'Zm9vYmE=', 'Zm9vYmFy']) val);\n+SELECT tryBase64Decode(val) FROM (select arrayJoin(['', 'Zg==', 'Zm8=', 'Zm9v', 'Zm9vYg==', 'Zm9vYmE=', 'Zm9vYmFy']) val);\n+\n SELECT base64Decode(base64Encode('foo')) = 'foo', base64Encode(base64Decode('Zm9v')) == 'Zm9v';\n+SELECT tryBase64Decode(base64Encode('foo')) = 'foo', base64Encode(tryBase64Decode('Zm9v')) == 'Zm9v';\n \n-SELECT tryBase64Decode('Zm9vYmF=Zm9v');\n+SELECT base64Encode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT base64Decode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT tryBase64Decode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n \n-SELECT base64Encode(val, 'excess argument') FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar']) val); -- { serverError 42 }\n-SELECT base64Decode(val, 'excess argument') FROM (select arrayJoin(['', 'Zg==', 'Zm8=', 'Zm9v', 'Zm9vYg==', 'Zm9vYmE=', 'Zm9vYmFy']) val); -- { serverError 42 }\n-SELECT tryBase64Decode('Zm9vYmF=Zm9v', 'excess argument'); -- { serverError 42 }\n+SELECT base64Decode('Zm9vYmF=Zm9v'); -- { serverError INCORRECT_DATA }\n+SELECT tryBase64Decode('Zm9vYmF=Zm9v');\n \n-SELECT base64Decode('Zm9vYmF=Zm9v'); -- { serverError 117 }\n+SELECT base64Decode('foo'); -- { serverError INCORRECT_DATA }\n+SELECT tryBase64Decode('foo');\n \n select base64Encode(toFixedString('foo', 3));\n select base64Decode(toFixedString('Zm9v', 4));\n+select tryBase64Decode(toFixedString('Zm9v', 4));\n+\n+-- This query reproduces a bug in TurboBase64 library (which we no longer use)\n+select distinct base64Encode(materialize('LG Optimus')) from numbers(100);\ndiff --git a/tests/queries/0_stateless/01092_base64.reference b/tests/queries/0_stateless/01092_base64.reference\ndeleted file mode 100644\nindex 4c41ac319467..000000000000\n--- a/tests/queries/0_stateless/01092_base64.reference\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-TEcgT3B0aW11cw==\ndiff --git a/tests/queries/0_stateless/01092_base64.sql b/tests/queries/0_stateless/01092_base64.sql\ndeleted file mode 100644\nindex f50cf49d270e..000000000000\n--- a/tests/queries/0_stateless/01092_base64.sql\n+++ /dev/null\n@@ -1,4 +0,0 @@\n--- Tags: no-fasttest\n-\n--- This query reproduces a bug in TurboBase64 library.\n-select distinct base64Encode(materialize('LG Optimus')) from numbers(100);\n",
  "problem_statement": "Error in base64Decode function running clickhouse-server in Mac M1 (Arm)\n> You have to provide the following information whenever possible.\r\n\r\nThis command bellow return error when running clickhouse-server docker instance in a Mac M1 (Arch64) machines. \r\n\r\n`select  base64Decode('AGy1cKzasOC/yOPct7tO3w')`\r\n\r\n<img width=\"990\" alt=\"image\" src=\"https://user-images.githubusercontent.com/8150579/215519299-143efde0-0e5b-46b6-8ec9-74ac415c9b63.png\">\r\n\r\nThe command runs with no error in x86_64 machines. \r\n\r\n<img width=\"1026\" alt=\"image\" src=\"https://user-images.githubusercontent.com/8150579/215519559-7d290f2c-d186-49e7-8ff4-026457397c48.png\">\r\n\r\n\r\n> A clear and concise description of what works not as it is supposed to.\r\n\r\n> A link to reproducer in [https://fiddle.clickhouse.com/](https://fiddle.clickhouse.com/).\r\n\r\nI'm running the latest version if the docker image. \"clickhouse/clickhouse-server:23.1.2.9\"\r\n\r\n[The list of releases](https://github.com/ClickHouse/ClickHouse/blob/master/utils/list-versions/version_date.tsv)\r\n\r\n`2023.01.30 15:28:47.617942 [ 269 ] {509dae28-20d7-43df-8a36-557d7f7edea6} <Error> DynamicQueryHandler: Code: 117. DB::Exception: Failed to base64Decode input 'AGy1cKzasOC/yOPct7tO3w': While processing base64Decode('AGy1cKzasOC/yOPct7tO3w'). (INCORRECT_DATA), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xbb157c4 in /usr/bin/clickhouse\r\n1. ? @ 0x84672b8 in /usr/bin/clickhouse\r\n2. ? @ 0x84671cc in /usr/bin/clickhouse\r\n3. ? @ 0x8466b4c in /usr/bin/clickhouse\r\n4. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xf53b454 in /usr/bin/clickhouse\r\n5. DB::IExecutableFunction::defaultImplementationForConstantArguments(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xf53b018 in /usr/bin/clickhouse\r\n6. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xf53b400 in /usr/bin/clickhouse\r\n7. DB::IExecutableFunction::executeWithoutSparseColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xf53be28 in /usr/bin/clickhouse\r\n8. DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xf53d2b0 in /usr/bin/clickhouse\r\n9. DB::ActionsDAG::addFunctionImpl(std::__1::shared_ptr<DB::IFunctionBase const> const&, std::__1::vector<DB::ActionsDAG::Node const*, std::__1::allocator<DB::ActionsDAG::Node const*>>, std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, bool) @ 0xfb7b6d8 in /usr/bin/clickhouse\r\n10. DB::ActionsDAG::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<DB::ActionsDAG::Node const*, std::__1::allocator<DB::ActionsDAG::Node const*>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) @ 0xfb7ae14 in /usr/bin/clickhouse\r\n11. DB::ScopeStack::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) @ 0xfd5d4f0 in /usr/bin/clickhouse\r\n12. ? @ 0xfd66434 in /usr/bin/clickhouse\r\n13. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0xfd61f9c in /usr/bin/clickhouse\r\n14. DB::ActionsMatcher::visit(DB::ASTExpressionList&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0xfd64cb8 in /usr/bin/clickhouse\r\n15. ? @ 0xfd56480 in /usr/bin/clickhouse\r\n16. DB::ExpressionAnalyzer::getRootActions(std::__1::shared_ptr<DB::IAST> const&, bool, std::__1::shared_ptr<DB::ActionsDAG>&, bool) @ 0xfd38128 in /usr/bin/clickhouse\r\n17. DB::SelectQueryExpressionAnalyzer::appendSelect(DB::ExpressionActionsChain&, bool) @ 0xfd4651c in /usr/bin/clickhouse\r\n18. DB::ExpressionAnalysisResult::ExpressionAnalysisResult(DB::SelectQueryExpressionAnalyzer&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, bool, bool, bool, std::__1::shared_ptr<DB::FilterDAGInfo> const&, std::__1::shared_ptr<DB::FilterDAGInfo> const&, DB::Block const&) @ 0xfd4b9a4 in /usr/bin/clickhouse\r\n19. DB::InterpreterSelectQuery::getSampleBlockImpl() @ 0x104242f4 in /usr/bin/clickhouse\r\n20. ? @ 0x1041e724 in /usr/bin/clickhouse\r\n21. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::__1::shared_ptr<DB::PreparedSets>) @ 0x10419ec4 in /usr/bin/clickhouse\r\n22. DB::InterpreterSelectWithUnionQuery::buildCurrentChildInterpreter(std::__1::shared_ptr<DB::IAST> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&) @ 0x1049488c in /usr/bin/clickhouse\r\n23. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&) @ 0x1049294c in /usr/bin/clickhouse\r\n24. DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x103db348 in /usr/bin/clickhouse\r\n25. ? @ 0x1074e18c in /usr/bin/clickhouse\r\n26. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x1075252c in /usr/bin/clickhouse\r\n27. DB::HTTPHandler::processQuery(DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__1::optional<DB::CurrentThread::QueryScope>&) @ 0x11343a9c in /usr/bin/clickhouse\r\n28. DB::HTTPHandler::handleRequest(DB::HTTPServerRequest&, DB::HTTPServerResponse&) @ 0x11346994 in /usr/bin/clickhouse\r\n29. DB::HTTPServerConnection::run() @ 0x113b1da8 in /usr/bin/clickhouse\r\n30. Poco::Net::TCPServerConnection::start() @ 0x1201a5cc in /usr/bin/clickhouse\r\n31. Poco::Net::TCPServerDispatcher::run() @ 0x1201c160 in /usr/bin/clickhouse\r\n (version 23.1.2.9 (official build))`\r\n\r\n\nReplace \"Turbo-Base64\" to \"lemire/fastbase64\"\nhttps://github.com/lemire/fastbase64\nAVX512VBMI implementation of base64Encode / base64Decode\nI just got to know this library yesterday https://github.com/WojciechMula/base64-avx512. Make some efforts to use it in base64Encode / base64Decode, and the performance on my local test (enable AVX512 and AVX512VBMI) is quite impressive compared to current approach (Turbo)\r\n\r\n- Turbo - single thread:\r\n\r\n![ZMn1hglDTR](https://user-images.githubusercontent.com/22796953/193181389-390f8253-c23d-4461-99c5-b0fb7dfac910.jpg)\r\n\r\n- Mula - single thread:\r\n\r\n![i01oe4QAYR](https://user-images.githubusercontent.com/22796953/193181521-b1fb5266-344c-4350-9224-76cb1355137f.jpg)\r\n\r\n- Turbo - multi thread:\r\n\r\n![zwcBhCEJUf](https://user-images.githubusercontent.com/22796953/193181471-c851620a-f69e-4532-a8b6-c9f89fe604d7.jpg)\r\n\r\n- Mula - multi thread:\r\n\r\n![gIInamy6ca](https://user-images.githubusercontent.com/22796953/193181561-03609e87-1891-4a13-9988-fb304acb7a94.jpg)\r\n\r\nHave you look at this lib before? One of my concern is it's not actively maintained, and the code quality is actually quite bad.\r\nIf you think it's good, then I can make a PR with this library.\r\nThanks.\r\n@rschu1ze \r\n\n",
  "hints_text": "it's a tricky question\r\n\r\n```\r\n select  base64Encode(base64Decode('AGy1cKzasOC/yOPct7tO3w'));\r\n\u250c\u2500base64Encode(base64Decode('AGy1cKzasOC/yOPct7tO3w'))\u2500\u2510\r\n\u2502 AGy1cKzasOC/yOPct7tO3w==                             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n```\r\necho 'AGy1cKzasOC/yOPct7tO3w'|base64 -d\r\nl\ufffdp\ufffd\u06b0\ufffd\ufffd\ufffd\u0737\ufffdN\ufffdbase64: invalid input\r\n\r\necho 'AGy1cKzasOC/yOPct7tO3w=='|base64 -d\r\nl\ufffdp\ufffd\u06b0\ufffd\ufffd\ufffd\u0737\ufffdN\ufffd\r\n\r\n\r\nselect  base64Decode('AGy1cKzasOC/yOPct7tO3w');\r\n---\r\nFailed to base64Decode input (INCORRECT_DATA)\r\n\r\nselect  base64Decode('AGy1cKzasOC/yOPct7tO3w==');\r\n\u250c\u2500base64Decode('AGy1cKzasOC/yOPct7tO3w==')\u2500\u2510\r\n\u2502 l\ufffdp\ufffd\u06b0\ufffd\ufffd\ufffd\u0737\ufffdN\ufffd                                     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n'AGy1cKzasOC/yOPct7tO3w'  -- is invalid base64 string, but amd64 build is able to process it.\nThe fastbase64 library seems to be a good option for avx2 (and avx2-512) SIMD support. It does not seem to have native support for Neon (AMD) or AltiVec (PowerPC), so if nothing else, there would be a fallback to the slower chromium base64 for those.\r\n\r\nI saw that the aklomp library was attempted previously and unfortunately seems to have some issues as well.\nLooks abandoned.\nDo you still want it to be done? I'd like to work on this.\n@mkmkme, Yes, it makes sense (although with low priority). It will be very appreciated!\nIt seems that so far this library is x86-only. I pinged the author to see if they have any plans on supporting ARM as well.\nI've got the reply from them to use https://github.com/aklomp/base64\r\nI integrated it, but so far the performance is about twice as bad as it was before my changes. I'll check if I can speed it up.\nSo, here's the summary of my research.\r\n\r\n[lemire/fastbase64](https://github.com/lemire/fastbase64) is not a proper library that was pointed by the author, but rather a PoC (for instance, it is x86-only). The author recommended using [aklomp/base64](https://github.com/aklomp/base64), as that one inherited many of his algorithms as well.\r\n\r\n[WojciechMula/base64-avx512](https://github.com/WojciechMula/base64-avx512) mentioned in issue https://github.com/ClickHouse/ClickHouse/issues/41957 is also x86-only. It has a reference to a different repository by the same author, [WojciechMula/base64simd](https://github.com/WojciechMula/base64simd), that is mentioned by the author to be problematic, and they recommend using `aklomp/base64` as well.\r\n\r\nWhile trying to integrate `aklomp/base64` to CH I noticed that before Turbo-Base64 CH actually did use exactly that library ([here's the PR that replaces it to TB64](https://github.com/ClickHouse/ClickHouse/pull/8444/files)). \r\n\r\nAnd the result is quite underwhelming. On ARM (M1 Max with macOS), `aklomp/base64` is about 2 times slower.\r\n\r\nHere's  version with Turbo-Base64:\r\n![image](https://github.com/ClickHouse/ClickHouse/assets/4062234/40b0147c-63f9-4a16-b6b1-a9477eeead73)\r\n\r\nAnd here's with `aklomp/base64`:\r\n![image](https://github.com/ClickHouse/ClickHouse/assets/4062234/95cc02b7-51fd-4a71-98c3-f37d83df6689)\r\n\r\nI tried to poke to compile flags, but the result didn't get any better. I thought the reason might be ARM or macOS specific.\r\nDouble-checked on i7 with Fedora Linux installed, and result there is also about 1.5-2 times worse than with TB64: ~500MB/s with TB64 vs ~280MB/s with `aklomp/base64`.\r\n\r\nMy changes can be found [here](https://github.com/ClickHouse/ClickHouse/compare/master...mkmkme:ClickHouse:mkmkme/aklomp-base64). Sorry I didn't make it into a pull request. I think it's not worth even a WIP pull request, because the results are not satisfactory so far.\r\n\r\nI'd like to ping @alexey-milovidov and @rschu1ze. Maybe I'm missing something obvious? Or maybe it's not yet time to replace TB64 with something different?\nBTW, the behaviour of ARM and AMD builds is [different](https://github.com/ClickHouse/ClickHouse/issues/45790) .\r\nIt looks like they use different code.\r\n\nHey @den-crane!\r\n\r\nAre you still able to reproduce the issue? There was a merged PR (https://github.com/ClickHouse/ClickHouse/pull/33779) since the version in question was released.\r\n\r\nI just tested on my Macbook, and the command seems to work just fine:\r\n![image](https://github.com/ClickHouse/ClickHouse/assets/4062234/603ffb3a-88da-4a90-ae70-ad5260c2832e)\r\n\r\nIt's not inside the docker, but I doubt that would change the behaviour.\n@mkmkme \r\n\r\n\r\nAmpere A1\r\n\r\n```sql\r\nClickHouse client version 23.6.2.18 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 23.6.2 revision 54464.\r\n\r\nclickhouse :) select  base64Decode('AGy1cKzasOC/yOPct7tO3w');\r\n\r\nSELECT base64Decode('AGy1cKzasOC/yOPct7tO3w')\r\n\r\nQuery id: cacb7607-1a58-4066-94b1-434d72ef9209\r\n\r\n\r\n0 rows in set. Elapsed: 0.021 sec.\r\n\r\nReceived exception from server (version 23.6.2):\r\nCode: 117. DB::Exception: Received from localhost:9000. \r\nDB::Exception: Failed to base64Decode input 'AGy1cKzasOC/yOPct7tO3w':\r\n While processing base64Decode('AGy1cKzasOC/yOPct7tO3w'). (INCORRECT_DATA)\r\n\r\n\r\n\r\nLinux clickhouse 5.15.0-1021-oracle #27~20.04.1-Ubuntu SMP Mon Oct 17 01:56:24 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux\r\n```\r\n\r\n\r\n----------\r\n\r\nMac M1\r\n\r\n```sql\r\ncurl https://clickhouse.com/ | sh\r\n\r\n./clickhouse local\r\nClickHouse local version 23.7.1.2417 (official build).\r\n\r\nm1.local :) select  base64Decode('AGy1cKzasOC/yOPct7tO3w');\r\n\r\nSELECT base64Decode('AGy1cKzasOC/yOPct7tO3w')\r\n\r\nQuery id: 813728fb-c65d-4cb6-a3b7-5a9f2d6bced7\r\n\r\n\r\n0 rows in set. Elapsed: 0.399 sec.\r\n\r\nReceived exception:\r\nCode: 117. \r\nDB::Exception: Failed to base64Decode input 'AGy1cKzasOC/yOPct7tO3w':\r\n While processing base64Decode('AGy1cKzasOC/yOPct7tO3w'). (INCORRECT_DATA)\r\n```\r\n\r\n-----\r\n\r\n```sql\r\narm\r\n\r\nSELECT base64Decode('SGVsbG8gd29ybGQ');\r\nDB::Exception: Failed to base64Decode input 'SGVsbG8gd29ybGQ': While processing base64Decode('SGVsbG8gd29ybGQ'). (INCORRECT_DATA)\r\n\r\namd\r\n\r\nSELECT base64Decode('SGVsbG8gd29ybGQ');\r\n\u250c\u2500base64Decode('SGVsbG8gd29ybGQ')\u2500\u2510\r\n\u2502 Hello world                     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nHuh, that's interesting! I've downloaded CH via curl and got the same result as you.\r\n\r\nHowever, the binary built on my machine works just fine! So there's a chance something is going on with official build.\r\n\r\nSorry, I'm also quite new to this project, so I'd like to raise two newbie questions:\r\n\r\n1. Version downloaded from `clickhouse.com` is 23.7.1.2417. However, there's no such tag (and 23.7 release webinar is only tomorrow IIRC). What's that build? Is it nightly? How can I match it with the git revision?\r\n2. Are the scripts for building official binaries stored in this repo as well? I'd like to try the build flags used during compilation of that binary to see whether I'll be able to reproduce the issue then\n>1 Is it nightly\r\n\r\nyes. \r\n`select * from system.build_options;`\r\n\r\n> 2 Are the scripts for building official binaries stored in this repo as well?\r\n\r\nyes. \r\n\r\n>build flags\r\n\r\nI think they should be available in `system.build_options`\nHmm, I stand corrected. Yesterday I think I mistakenly ran the version with `aklomp/base64` thinking it was the version without any changes.\r\n\r\nI double-checked now, and yes, the version with Turbo-Base64 does fail with your example.\n@mkmkme `SYSTEM.BUILD_OPTIONS` can be a bit overwhelming. For (performance) testing, it is sufficient to pass these flags to CMake: `-DENABLE_LIBRARIES=0 -DCMAKE_BUILD_TYPE=RelWithDebInfo`.\r\n\r\nAbout https://github.com/ClickHouse/ClickHouse/issues/31643#issuecomment-1652273797: Yes, different code gets called for x86 and ARM but I am sure that @mkmkme noticed that already: https://github.com/ClickHouse/ClickHouse/blob/14141c9071bd75a118fe0fac89a78459788602ff/src/Functions/FunctionBase64Conversion.h#L30\r\n\r\n(btw., this discussion really belongs into #45790)\r\n\r\n> I'd like to ping @alexey-milovidov and @rschu1ze. Maybe I'm missing something obvious? Or maybe it's not yet time to replace TB64 with something different?\r\n\r\nLooking at [your draft](https://github.com/ClickHouse/ClickHouse/compare/master...mkmkme:ClickHouse:mkmkme/aklomp-base64), I notice that it calls `set_source_files_properties` based on `HAVE_*` flags, e.g. `HAVE_AVX`. The default ClickHouse build includes only up to SSE4.2 not AVX1/2/512, see cmake/cpu_features.cmake. I assume that `aklomp/base64` ran only with SSE4.2 (unless you passed ENABLE_AVX, ENABLE_AVX2 etc. to CMake). This is different from Turbo64 (the current base64 lib) which configures the encode/decode routine using a runtime dispatch (`cpuid()`) to the fastest available SIMD option, see `tb64ini()` in turbob64sse.c. I assume the comparison was unfair because of this.\nHey @rschu1ze !\r\nThanks a lot for your input. You're right, my draft was unfair to `aklomp/base64`.  I have now added the commit to my branch that enables all the flags for all the files in `aklomp/base64` (so that all codecs will be compiled into the library). The link is the same. I checked that for x86 it [also uses cpuid](https://github.com/aklomp/base64/blob/master/lib/codec_choose.c#L192). Also, I added a call for a dummy `base64_encode` during initialisation in order to initialise the codec.  For arm64, the library doesn't use any runtime check as it says there is none. So the fact that on M1 Mac the result didn't change is not surprising. But it didn't change for x86, either. Turbo-Base64 version got 529MB/s on my Fedora laptop whilst `aklomp/base64` loops at 293MB/s.\nOkay, that is unfortunate from a performance POV (assuming your measurements compared AVX2 vs. AVX2, AVX512 vs. AVX512, i.e. in a fair way). On the other hand, the motivation to go for `aklomp/base64` given in https://github.com/ClickHouse/ClickHouse/issues/41957#issuecomment-1264041565 is still true (and with more GitHub stars, `aklomp/base64` also seems more future-proof). I personally doubt that there exists a ClickHouse use case which bottlenecks on base64 encoding/decoding speed \\+ note that most functions in ClickHouse are not SIMD-accelerated at all; so I would support the move to `aklomp/base64` regardless. (Maybe we can build a small repro (e.g. a standalone binary) and provide it to the maintainers of `aklomp/base64` to check why performance is worse than with Turbo64?)\nI'll try to build some small reproduction for that case.\nAccepting performance degradation is possible but not good.\r\nMaybe a good way is to address all the concerns that still remain in the Turbo-Base64.\nRight now I'm working on a minimal benchmark to properly compare these two libraries.\r\nI think all my checks indeed were a bit unfair for `aklomp/base64`, because the internal benchmarks of both libraries show that `aklomp/base64` is about 10% faster than Turbo-Base64:\r\n\r\n**Turbo-Base64**\r\n```\r\n$ ./tb64app\r\ndetected simd (id=38->'arm_neon')\r\n\r\n  E MB/s    size     ratio%   D MB/s   function\r\nsize=1Kb (Kb=1.000)\r\n  4324.11       1336 133.60%  5464.65 tb64s        1000\r\n  7480.79       1336 133.60%  6859.91 tb64x        1000\r\n 15298.66       1336 133.60% 13961.35 tb64sse        1000\r\n 15228.53       1336 133.60% 13931.00 tb64auto        1000\r\n 68730.45       1000 100.00% 70625.61 memcpy        1000\r\nsize=10Kb (Kb=1.000)\r\n  4320.59      13336 133.36%  5477.52 tb64s       10000\r\n  7525.90      13336 133.36%  6798.98 tb64x       10000\r\n 16652.86      13336 133.36% 15139.39 tb64sse       10000\r\n 16496.37      13336 133.36% 15003.66 tb64auto       10000\r\n 75722.63      10000 100.00% 75631.53 memcpy       10000\r\nsize=100Kb (Kb=1.000)\r\n  4151.13     133336 133.34%  5367.85 tb64s      100000\r\n  6856.95     133336 133.34%  6453.72 tb64x      100000\r\n 16791.77     133336 133.34% 15163.17 tb64sse      100000\r\n 16988.01     133336 133.34% 15283.64 tb64auto      100000\r\n 33875.84     100000 100.00% 30186.64 memcpy      100000\r\nsize=1Mb (Mb=1.000.000)\r\n  4174.09    1333336 133.33%  5463.83 tb64s     1000000\r\n  6970.32    1333336 133.33%  6577.28 tb64x     1000000\r\n 16950.05    1333336 133.33% 15245.75 tb64sse     1000000\r\n 16961.66    1333336 133.33% 15332.50 tb64auto     1000000\r\n 59295.98    1000000 100.00% 54144.61 memcpy     1000000\r\nsize=10Mb (Mb=1.000.000)\r\n  4146.94   13333336 133.33%  5400.67 tb64s    10000000\r\n  6949.33   13333336 133.33%  6509.04 tb64x    10000000\r\n 16546.09   13333336 133.33% 14872.77 tb64sse    10000000\r\n 16513.51   13333336 133.33% 14936.76 tb64auto    10000000\r\n 50999.64   10000000 100.00% 51289.61 memcpy    10000000\r\nsize=20Mb (Mb=1.000.000)\r\n  4137.58   26666668 133.33%  5356.94 tb64s    20000000\r\n  6927.29   26666668 133.33%  6461.46 tb64x    20000000\r\n 16698.04   26666668 133.33% 15101.11 tb64sse    20000000\r\n 16767.57   26666668 133.33% 15073.72 tb64auto    20000000\r\n 48018.36   20000000 100.00% 48046.36 memcpy    20000000\r\n```\r\n\r\n**aklomp/base64** (note that it's upside down in comparison to TB64)\r\n```\r\n$ ./build-macos/bin/benchmark\r\nFilling buffer with 10.0 MB of random data...\r\nTesting with buffer size 10 MB, fastest of 10 * 1\r\nNEON64\tencode\t12673.61 MB/sec\r\nNEON64\tdecode\t8569.90 MB/sec\r\nplain\tencode\t4694.65 MB/sec\r\nplain\tdecode\t4008.02 MB/sec\r\nTesting with buffer size 1 MB, fastest of 10 * 10\r\nNEON64\tencode\t18598.91 MB/sec\r\nNEON64\tdecode\t12437.81 MB/sec\r\nplain\tencode\t5655.98 MB/sec\r\nplain\tdecode\t4230.86 MB/sec\r\nTesting with buffer size 100 KB, fastest of 10 * 100\r\nNEON64\tencode\t18235.06 MB/sec\r\nNEON64\tdecode\t12525.40 MB/sec\r\nplain\tencode\t5660.82 MB/sec\r\nplain\tdecode\t4148.30 MB/sec\r\nTesting with buffer size 10 KB, fastest of 100 * 100\r\nNEON64\tencode\t18571.83 MB/sec\r\nNEON64\tdecode\t12587.33 MB/sec\r\nplain\tencode\t6133.88 MB/sec\r\nplain\tdecode\t4428.03 MB/sec\r\nTesting with buffer size 1 KB, fastest of 100 * 1000\r\nNEON64\tencode\t16344.14 MB/sec\r\nNEON64\tdecode\t12087.52 MB/sec\r\nplain\tencode\t5966.80 MB/sec\r\nplain\tdecode\t4366.96 MB/sec\r\n```\n@rschu1ze @alexey-milovidov I've pushed a somewhat minimalistic benchmark to compare those libraries.\r\nThe code and the results can be found here: https://github.com/mkmkme/base64-benchmark\r\n\r\nIn that repo, I tried to build Turbo-Base64 exactly as it is built in CH. For `aklomp/base64`, I tried to reuse the building scripts from the upstream repo.\r\n\r\nSurprisingly, this time I got `aklomp/base64` significantly faster on M1 Max, but sometimes even slower on Core i7.\r\n\r\nPlease take a look. Test on your machine, if needed. And please tell me if this benchmark makes sense.\nhttps://github.com/mkmkme/base64-benchmark/blob/main/main.cpp#L55\r\n\r\nThis isn't the best benchmark - unrealistic data.\r\n\r\nIf the number 10000 means bytes, it is too much. Typical strings in a database are in order of 100 bytes.\r\nString lengths should be randomly distributed.\r\n\r\nThe best benchmark will be on URL, Title, SearchPhrase columns from ClickBench.\n@alexey-milovidov noted. I updated the benchmark to use the data taken from ClickBench.\r\n\r\nI used URL, Title and SearchPhrase from the dataset, where `lengthUTF = 50, 100, 200, 500`. I also included the longest URL, Title and SearchPhrase from the table. The queries are included in the README.\r\n\r\nThe new results are also there. And so far those are exactly the same as before: `aklomp/base64` is faster on M1 Max but slower on i7-8650U. I do hope I got all the compilation flags correctly.\r\n\r\nPlease take a look at https://github.com/mkmkme/base64-benchmark/blob/main/README.md\nHi,\r\nAccording to my benchmarks (see README) on several intel/amd cpu's Turbo-Base64 avx2 is nearly 2 times faster than aklomp/base64. There is also the avx512 in the latest GPL version which sets new records in base64 speed.\r\nThe short strings developed initially for Clickhouse are 3,5-4 times faster ( call tb64init(0,1) to enable this on avx2 or call directly _tb64v256enc/_tb64v256dec).\r\nThe results are slightly varying depending on the cpu used, but there are no doubts about the difference in speed.\r\n\r\nI've actually no arm64 benchmarks on M1. In your benchmark you're wrongly calling the scalar functions tb64senc/tb64sdec while the correct functions for all architectures are tb64enc/tb64dec (or the direct SIMD/NEON calls tb64v128enc/tb64v128dec)\r\n\r\nIn general you can always call the auto functions: tb64enc/tb64dec (no need to initialize anything).\r\n\r\n\nHey @powturbo,\r\n\r\nThanks for your input! You're right I was using scalar functions in case of Turbo-Base64 functions on `__aarch64__`. I did this because it is like that currently in ClickHouse codebase. There seems to have been some bug on that architecture: https://github.com/ClickHouse/ClickHouse/blob/357fee99ff9bcdf76dd044ee11ae2d3c6f5f5a43/src/Functions/FunctionBase64Conversion.h#L49-L57\r\n\nI've now the results for apple M1. The benchmark was done by a third party. All libs with the latest versions.\r\nTurbo-base64 encodes/decodes ~25% faster than base64 on ARM Neon\r\nwhile the scalar functions are 64% faster than the base64 plain.\r\n\r\nNote that base64 is using inline assembly.\r\n\r\n|E MB/s|size|ratio| D MB/s| 50,000 bytes (2023.08) |\r\n|--------|-----------:|------:|----------:|-----------------------------|\r\n|24012.43|66668|133.34%|15352.09|tb64v128 (turbo-base64)|\r\n|19087.55|66668|133.34%|12515.17|b64neon64 (aklomp/base64)|\r\n|5611.48|66668|133.34%|5092.64|tb64s (scalar)|\r\n|9782.45|66668|133.34%|3919.52|tb64x (scalar)|\r\n|6181.37|66668|133.34%|3108.54|b64plain |\r\n|45566.16|50000|100.00%|45484.13|memcpy|\r\n\n@alexey-milovidov @rschu1ze what'd you say? Given the new information, do you still want to move to the other library?\n(sorry for the delay, just returned from vacation)\r\n\r\nThe Turbo-Base64 version used by ClickHouse and in the [benchmark](https://github.com/mkmkme/base64-benchmark) is the last non-GPL version and ca. 3 years old. While the performance improvements since then (https://github.com/ClickHouse/ClickHouse/issues/31643#issuecomment-1664182873) are appreciated, they are not usable for ClickHouse due to licensing issues. The performance trade-off (slower x86, faster ARM) seems reasonable given that 1. base64-decoding is IMHO not exactly a bottleneck and 2. the version of aklomp/base64 used in the benchmark is also slightly outdated and there were more upstream optimizations for x86 since then. Overall, I think it's worth to move to aklomp/base64.\nThe bug on AArch64\r\n> base64Encode(repeat('a', 46))` returns wrong padding character\r\n\r\nis a blocker for using this library.\nI'll double-check if I can still reproduce it\n> The bug on AArch64\r\n> \r\n>> base64Encode(repeat('a', 46))` returns wrong padding character\r\n> \r\n> is a blocker for using this library.\r\n\r\nCouldn't reproduce this on my AArch64 VM.\r\nWill publish the PR for replacing the library today.\n@canhld94 Thanks for the interesting hint.\r\n\r\nI don't know the historical reason why ClickHouse went for [Turbo Base64](https://github.com/powturbo/Turbo-Base64), but there are seemingly a few advantages of Turbo Base64: a) performance is quite good (looking at the benchmarks on their GitHub page) b) they can deal with erroneous inputs (important for untrusted data) c) they provide a runtime dispatch based on CPU capabilities to the fastest SIMD implementation (this removes the need to dispatch manually in ClickHouse) d) in general, the library is intended for real-world usage and not a mere research prototype.\r\n\r\nMula's AVX-512 decoder has impressive performance (ca. twice as fast in above multi-threaded benchmark) but as far as I see, it lacks the automatic CPU dispatch and since it is the byproduct of a research paper, I don't have much hope that this is added in future (there has not been any update in 3 years). So I guess an implementation into ClickHouse would be hacky.\r\n\r\nAnd there is another consideration: I remember bugs in the AVX-512 code of 3rd party libraries (IIRC: json parsing) which could not be found in CI because not all of ClickHouse's CI machines have AVX-512. So in case of a bug in the super-fast AVX-512 path, we'd have a problem. I think that CI machines will be gradually upgraded along ClickHouse's SIMD requirements as we raise them (c.f. #40459).\r\n\r\nOverall, I think integrating the [avx-512 base64 library](https://github.com/WojciechMula/base64-avx512) would not be very beneficial at this point. But what I would love to see is that the new algorithms and techniques are integrated into a more established library, e.g. Turbo Base64 \ud83d\ude09\r\n\r\nEDIT: Seems there is already [some effort ](https://github.com/aklomp/base64/pull/102)to bring Mula's AVX-512 code into an established base64 library, unfortunately, it is not the one we use.\n> Mula's AVX-512 decoder has impressive performance (ca. twice as fast in above multi-threaded benchmark) but as far as I see, it lacks the automatic CPU dispatch and since it is the byproduct of a research paper, I don't have much hope that this is added in future (there has not been any update in 3 years). So I guess an implementation into ClickHouse would be hacky.\r\nAnd there is another consideration: I remember bugs in the AVX-512 code of 3rd party libraries (IIRC: json parsing) which could not be found in CI because not all of ClickHouse's CI machines have AVX-512. So in case of a bug in the super-fast AVX-512 path, we'd have a problem.\r\n\r\n@rschu1ze Yes, I also has same concerns, so I opened this issue for discussions. In addition, I didn't mean to replace the current Turbo Base64 with Mula's library, but rather to provide customized base64 encode/decode functions in ClickHouse based on Mula's code (like many other PRs have done #37588,  #37870, #39586 ...). Of course, this required us to extensively test the correctness and performance of the customized functions.\r\n\r\n> But what I would love to see is that the new algorithms and techniques are integrated into a more established library, e.g. Turbo Base64\r\n\r\nThis will be the best solution. May be @qoega can provide more insights :).\r\n\nI'm strongly supporting replacing Turbo-Base64 with the library from Wojciech Mula (or another library from Daniel Lemire).\r\n\r\nWe are disappointed with Turbo-Base64 for several reasons:\r\n1. It does not look like a library, more like a bunch of unfinished pieces of code.\r\n2. Some code paths in the library have bugs and were disabled.\r\n3. The author initially changed the license to be ClickHouse compatible, but then [changed it back](https://github.com/powturbo/Turbo-Base64/commit/203ff3aa057e4ee73b3d008abdd36622be74729e) in next revisions.\nDuplicate of #31643.\nGood to know, thanks.\r\n\r\n@canhld94 If you would like to contribute - replacing [Turbo-Base64](https://github.com/powturbo/Turbo-Base64) with Lemire's [fastbase64](https://github.com/lemire/fastbase64) (not: Mula's [original code](https://github.com/WojciechMula/base64-avx512) which looks abandoned) would be appreciated. I would be pretty curious how both compare against each other ... at least the measurements at the GitHub page of Turbo make fastbase64 look bad.\r\n\r\nLet me close this as dup of https://github.com/ClickHouse/ClickHouse/issues/31643.\n> Good to know, thanks.\r\n> \r\n> @canhld94 If you would like to contribute - replacing [Turbo-Base64](https://github.com/powturbo/Turbo-Base64) with Lemire's [fastbase64](https://github.com/lemire/fastbase64) (not: Mula's [original code](https://github.com/WojciechMula/base64-avx512) which looks abandoned) would be appreciated. I would be pretty curious how both compare against each other ... at least the measurements at the GitHub page of Turbo make fastbase64 look bad.\r\n> \r\n> Let me close this as dup of #31643.\r\n\r\n@rschu1ze \r\n[fastbase64](https://github.com/lemire/fastbase64) also looks an abandon project.\r\nIn addition, as Alex mentioned above, [Turbo-Base64](https://github.com/powturbo/Turbo-Base64) is now under GPLv3 license, so CH cannot use its newest code anymore.\r\nOther promising one is [base64](https://github.com/aklomp/base64): BSD-2 license, having support for AVX2, SSSE3, SSE4.1, SSE4.2, AVX (there's an ongoing PR for AVX512). But seem that CH used base64 before but changed to Turbo-Base64 for performance reason (#8444).\r\nIMO, I think [base64](https://github.com/aklomp/base64) is a good candidate. It's used by node.js, and looks actively developing.\nAnd we can edit the libraries and even create a chimera-library if needed...",
  "created_at": "2023-08-31T12:34:24Z"
}