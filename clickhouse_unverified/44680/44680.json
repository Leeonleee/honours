{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44680,
  "instance_id": "ClickHouse__ClickHouse-44680",
  "issue_numbers": [
    "44587"
  ],
  "base_commit": "7f0800fbd1cfaed200db7213f613d52fe5fbc7b5",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionVarianceMatrix.cpp b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.cpp\nnew file mode 100644\nindex 000000000000..ffb93b5d3b24\n--- /dev/null\n+++ b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.cpp\n@@ -0,0 +1,40 @@\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <AggregateFunctions/Helpers.h>\n+#include <AggregateFunctions/FactoryHelpers.h>\n+#include <AggregateFunctions/AggregateFunctionVarianceMatrix.h>\n+\n+\n+namespace DB\n+{\n+struct Settings;\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+namespace\n+{\n+\n+template <typename FunctionTemplate>\n+AggregateFunctionPtr createAggregateFunctionVarianceMatrix(\n+    const std::string & name, const DataTypes & argument_types, const Array & parameters, const Settings *)\n+{\n+    assertNoParameters(name, parameters);\n+    for (const auto & argument_type : argument_types)\n+        if (!isNativeNumber(argument_type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Aggregate function {} only supports numerical types\", name);\n+\n+    return std::make_shared<FunctionTemplate>(argument_types);\n+}\n+\n+}\n+\n+void registerAggregateFunctionsVarianceMatrix(AggregateFunctionFactory & factory)\n+{\n+    factory.registerFunction(\"covarSampMatrix\", createAggregateFunctionVarianceMatrix<AggregateFunctionCovarSampMatrix>);\n+    factory.registerFunction(\"covarPopMatrix\", createAggregateFunctionVarianceMatrix<AggregateFunctionCovarPopMatrix>);\n+    factory.registerFunction(\"corrMatrix\", createAggregateFunctionVarianceMatrix<AggregateFunctionCorrMatrix>);\n+}\n+\n+}\ndiff --git a/src/AggregateFunctions/AggregateFunctionVarianceMatrix.h b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.h\nnew file mode 100644\nindex 000000000000..6d05c3edf459\n--- /dev/null\n+++ b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.h\n@@ -0,0 +1,159 @@\n+#pragma once\n+\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Common/PODArray.h>\n+#include <Common/PODArray_fwd.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/Moments.h>\n+#include <DataTypes/DataTypesNumber.h>\n+\n+namespace DB\n+{\n+struct Settings;\n+\n+enum class StatisticsMatrixFunctionKind\n+{\n+    covarPopMatrix,\n+    covarSampMatrix,\n+    corrMatrix\n+};\n+\n+template <StatisticsMatrixFunctionKind _kind>\n+struct AggregateFunctionVarianceMatrixData\n+{\n+    using DataType = std::conditional_t<_kind == StatisticsMatrixFunctionKind::corrMatrix, CorrMoments<Float64>, CovarMoments<Float64>>;\n+\n+    AggregateFunctionVarianceMatrixData() = default;\n+\n+    explicit AggregateFunctionVarianceMatrixData(const size_t _num_args)\n+        : num_args(_num_args)\n+    {\n+        data_matrix.resize_fill(num_args * (num_args + 1) / 2, DataType());\n+    }\n+\n+    void add(const IColumn ** column, const size_t row_num)\n+    {\n+        for (size_t i = 0; i < num_args; ++i)\n+            for (size_t j = 0; j <= i; ++j)\n+                 data_matrix[i * (i + 1) / 2 + j].add(column[i]->getFloat64(row_num), column[j]->getFloat64(row_num));\n+    }\n+\n+    void merge(const AggregateFunctionVarianceMatrixData & other)\n+    {\n+        for (size_t i = 0; i < num_args; ++i)\n+            for (size_t j = 0; j <= i; ++j)\n+                data_matrix[i * (i + 1) / 2 + j].merge(other.data_matrix[i * (i + 1) / 2 + j]);\n+    }\n+\n+    void serialize(WriteBuffer & buf) const\n+    {\n+        for (size_t i = 0; i < num_args; ++i)\n+            for (size_t j = 0; j <= i; ++j)\n+                data_matrix[i * (i + 1) / 2 + j].write(buf);\n+    }\n+\n+    void deserialize(ReadBuffer & buf)\n+    {\n+        for (size_t i = 0; i < num_args; ++i)\n+            for (size_t j = 0; j <= i; ++j)\n+                data_matrix[i * (i + 1) / 2 + j].read(buf);\n+    }\n+\n+    void insertResultInto(IColumn & to) const\n+    {\n+        auto & data_to = assert_cast<ColumnFloat64 &>(assert_cast<ColumnArray &>(assert_cast<ColumnArray &>(to).getData()).getData()).getData();\n+        auto & root_offsets_to = assert_cast<ColumnArray &>(to).getOffsets();\n+        auto & nested_offsets_to = assert_cast<ColumnArray &>(assert_cast<ColumnArray &>(to).getData()).getOffsets();\n+        for (size_t i = 0; i < num_args; ++i)\n+        {\n+            for (size_t j = 0; j < num_args; ++j)\n+            {\n+                auto & data = i < j ? data_matrix[j * (j + 1) / 2 + i] : data_matrix[i * (i + 1) / 2 + j];\n+                if constexpr (kind == StatisticsMatrixFunctionKind::covarPopMatrix)\n+                    data_to.push_back(data.getPopulation());\n+                if constexpr (kind == StatisticsMatrixFunctionKind::covarSampMatrix)\n+                    data_to.push_back(data.getSample());\n+                if constexpr (kind == StatisticsMatrixFunctionKind::corrMatrix)\n+                    data_to.push_back(data.get());\n+            }\n+            nested_offsets_to.push_back(nested_offsets_to.back() + num_args);\n+        }\n+        root_offsets_to.push_back(root_offsets_to.back() + num_args);\n+    }\n+\n+    static constexpr StatisticsMatrixFunctionKind kind = _kind;\n+    PaddedPODArray<DataType> data_matrix;\n+    size_t num_args;\n+};\n+\n+template <typename Data>\n+class AggregateFunctionVarianceMatrix final\n+    : public IAggregateFunctionDataHelper<Data, AggregateFunctionVarianceMatrix<Data>>\n+{\n+public:\n+\n+    explicit AggregateFunctionVarianceMatrix(const DataTypes & argument_types_)\n+        : IAggregateFunctionDataHelper<Data, AggregateFunctionVarianceMatrix<Data>>(argument_types_, {}, createResultType())\n+    {}\n+\n+    AggregateFunctionVarianceMatrix(const IDataType &, const DataTypes & argument_types_)\n+        : IAggregateFunctionDataHelper<Data, AggregateFunctionVarianceMatrix<Data>>(argument_types_, {}, createResultType())\n+    {}\n+\n+    String getName() const override\n+    {\n+        if constexpr (Data::kind == StatisticsMatrixFunctionKind::covarPopMatrix)\n+            return \"covarPopMatrix\";\n+        if constexpr (Data::kind == StatisticsMatrixFunctionKind::covarSampMatrix)\n+            return \"covarSampMatrix\";\n+        if constexpr (Data::kind == StatisticsMatrixFunctionKind::corrMatrix)\n+            return \"corrMatrix\";\n+        UNREACHABLE();\n+    }\n+\n+    void create(AggregateDataPtr __restrict place) const override\n+    {\n+        new (place) Data(this->argument_types.size());\n+    }\n+\n+    static DataTypePtr createResultType()\n+    {\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(std::make_shared<DataTypeFloat64>()));\n+    }\n+\n+    bool allocatesMemoryInArena() const override { return false; }\n+\n+    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n+    {\n+        this->data(place).add(columns, row_num);\n+    }\n+\n+    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n+    {\n+        this->data(place).merge(this->data(rhs));\n+    }\n+\n+    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override\n+    {\n+        this->data(place).serialize(buf);\n+    }\n+\n+    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version */, Arena *) const override\n+    {\n+        this->data(place).deserialize(buf);\n+    }\n+\n+    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override\n+    {\n+        this->data(place).insertResultInto(to);\n+    }\n+};\n+\n+using AggregateFunctionCovarPopMatrix = AggregateFunctionVarianceMatrix<AggregateFunctionVarianceMatrixData<StatisticsMatrixFunctionKind::covarPopMatrix>>;\n+using AggregateFunctionCovarSampMatrix = AggregateFunctionVarianceMatrix<AggregateFunctionVarianceMatrixData<StatisticsMatrixFunctionKind::covarSampMatrix>>;\n+using AggregateFunctionCorrMatrix = AggregateFunctionVarianceMatrix<AggregateFunctionVarianceMatrixData<StatisticsMatrixFunctionKind::corrMatrix>>;\n+\n+}\n+\ndiff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp\nindex ecf6ab513677..5202d8b48f84 100644\n--- a/src/AggregateFunctions/registerAggregateFunctions.cpp\n+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp\n@@ -39,6 +39,7 @@ void registerAggregateFunctionsMax(AggregateFunctionFactory &);\n void registerAggregateFunctionsAny(AggregateFunctionFactory &);\n void registerAggregateFunctionsStatisticsStable(AggregateFunctionFactory &);\n void registerAggregateFunctionsStatisticsSimple(AggregateFunctionFactory &);\n+void registerAggregateFunctionsVarianceMatrix(AggregateFunctionFactory &);\n void registerAggregateFunctionSum(AggregateFunctionFactory &);\n void registerAggregateFunctionSumCount(AggregateFunctionFactory &);\n void registerAggregateFunctionSumMap(AggregateFunctionFactory &);\n@@ -124,6 +125,7 @@ void registerAggregateFunctions()\n         registerAggregateFunctionsAny(factory);\n         registerAggregateFunctionsStatisticsStable(factory);\n         registerAggregateFunctionsStatisticsSimple(factory);\n+        registerAggregateFunctionsVarianceMatrix(factory);\n         registerAggregateFunctionSum(factory);\n         registerAggregateFunctionSumCount(factory);\n         registerAggregateFunctionSumMap(factory);\n",
  "test_patch": "diff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex e2668d7d0933..31a87bff5fc1 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -951,6 +951,7 @@\n \"topKWeighted\"\n \"stochasticLinearRegression\"\n \"corr\"\n+\"corrMatrix\"\n \"uniqCombined64\"\n \"intervalLengthSum\"\n \"uniqCombined\"\n@@ -965,6 +966,7 @@\n \"quantiles\"\n \"sum\"\n \"covarPop\"\n+\"covarPopMatrix\"\n \"row_number\"\n \"kurtPop\"\n \"kurtSamp\"\n@@ -1019,6 +1021,7 @@\n \"quantilesTiming\"\n \"welchTTest\"\n \"covarSamp\"\n+\"covarSampMatrix\"\n \"varPopStable\"\n \"quantileTiming\"\n \"quantileExactInclusive\"\ndiff --git a/tests/queries/0_stateless/02515_aggregate_functions_statistics.reference b/tests/queries/0_stateless/02515_aggregate_functions_statistics.reference\nnew file mode 100644\nindex 000000000000..ecb6a756446a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02515_aggregate_functions_statistics.reference\n@@ -0,0 +1,18 @@\n+[[nan]]\n+[[nan]]\n+[[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan]]\n+[[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan]]\n+[[1,-0.09561,0.24287,0.74554],[-0.09561,1,0.17303,0.10558],[0.24287,0.17303,1,0.25797],[0.74554,0.10558,0.25797,1]]\n+0\t0\t0\n+[[nan]]\n+[[nan]]\n+[[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan]]\n+[[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan]]\n+[[9.16667,-1.95556,4.5335,7.49776],[-1.95556,45.63378,7.20628,2.36899],[4.5335,7.20628,38.01103,5.28296],[7.49776,2.36899,5.28296,11.03352]]\n+0\t0\t0\n+[[nan]]\n+[[0]]\n+[[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan],[nan,nan,nan,nan]]\n+[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n+[[8.25,-1.76,4.08015,6.74799],[-1.76,41.0704,6.48565,2.13209],[4.08015,6.48565,34.20993,4.75467],[6.74799,2.13209,4.75467,9.93017]]\n+0\t0\t0\ndiff --git a/tests/queries/0_stateless/02515_aggregate_functions_statistics.sql b/tests/queries/0_stateless/02515_aggregate_functions_statistics.sql\nnew file mode 100644\nindex 000000000000..df6e0cb066ce\n--- /dev/null\n+++ b/tests/queries/0_stateless/02515_aggregate_functions_statistics.sql\n@@ -0,0 +1,41 @@\n+DROP TABLE IF EXISTS fh;\n+\n+CREATE TABLE fh(a_value UInt32, b_value Float64, c_value Float64, d_value Float64) ENGINE = Memory;\n+\n+INSERT INTO fh(a_value, b_value, c_value, d_value) VALUES (1, 5.6,-4.4, 2.6),(2, -9.6, 3, 3.3),(3, -1.3,-4, 1.2),(4, 5.3,9.7,2.3),(5, 4.4,0.037,1.222),(6, -8.6,-7.8,2.1233),(7, 5.1,9.3,8.1222),(8, 7.9,-3.6,9.837),(9, -8.2,0.62,8.43555),(10, -3,7.3,6.762);\n+\n+SELECT corrMatrix(a_value) FROM (select a_value from fh limit 0);\n+\n+SELECT corrMatrix(a_value) FROM (select a_value from fh limit 1);\n+\n+SELECT corrMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 0);\n+\n+SELECT corrMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 1);\n+\n+SELECT arrayMap(x -> arrayMap(y -> round(y, 5), x), corrMatrix(a_value, b_value, c_value, d_value))  FROM fh;\n+\n+SELECT round(abs(corr(x1,x2) - corrMatrix(x1,x2)[1][2]), 5), round(abs(corr(x1,x1) - corrMatrix(x1,x2)[1][1]), 5), round(abs(corr(x2,x2) - corrMatrix(x1,x2)[2][2]), 5) from (select randNormal(100, 1) as x1, randNormal(100,5) as x2 from numbers(100000));\n+\n+SELECT covarSampMatrix(a_value) FROM (select a_value from fh limit 0);\n+\n+SELECT covarSampMatrix(a_value) FROM (select a_value from fh limit 1);\n+\n+SELECT covarSampMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 0);\n+\n+SELECT covarSampMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 1);\n+\n+SELECT arrayMap(x -> arrayMap(y -> round(y, 5), x), covarSampMatrix(a_value, b_value, c_value, d_value))  FROM fh;\n+\n+SELECT round(abs(covarSamp(x1,x2) - covarSampMatrix(x1,x2)[1][2]), 5), round(abs(covarSamp(x1,x1) - covarSampMatrix(x1,x2)[1][1]), 5), round(abs(covarSamp(x2,x2) - covarSampMatrix(x1,x2)[2][2]), 5) from (select randNormal(100, 1) as x1, randNormal(100,5) as x2 from numbers(100000));\n+\n+SELECT covarPopMatrix(a_value) FROM (select a_value from fh limit 0);\n+\n+SELECT covarPopMatrix(a_value) FROM (select a_value from fh limit 1);\n+\n+SELECT covarPopMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 0);\n+\n+SELECT covarPopMatrix(a_value, b_value, c_value, d_value) FROM (select a_value, b_value, c_value, d_value from fh limit 1);\n+\n+SELECT arrayMap(x -> arrayMap(y -> round(y, 5), x), covarPopMatrix(a_value, b_value, c_value, d_value))  FROM fh;\n+\n+SELECT round(abs(covarPop(x1,x2) - covarPopMatrix(x1,x2)[1][2]), 5), round(abs(covarPop(x1,x1) - covarPopMatrix(x1,x2)[1][1]), 5), round(abs(covarPop(x2,x2) - covarPopMatrix(x1,x2)[2][2]), 5) from (select randNormal(100, 1) as x1, randNormal(100,5) as x2 from numbers(100000));\n",
  "problem_statement": "A function `corrMatrix` to calculate correlation across all the pairs of arguments.\n**Use case**\r\n\r\nSee https://github.com/ClickHouse/ClickHouse/issues/35979\r\n\r\n**Describe the solution you'd like**\r\n\r\nLet's add a function `corrMatrix`, taking an arbitrary number of arguments and returning a 2d array.\r\nNote: this matrix will be somewhat redundant - symmetric with 1 on the diagonal, but let's return it as a whole for simplicity.\n",
  "hints_text": "I'd like to try this :)\n@FFFFFFFHHHHHHH Thank you! Let's try.\r\nAre you familiar with the ClickHouse codebase around aggregate functions (`IAggregateFunction`, `AggregateFunctionCovariance`)?\n> @FFFFFFFHHHHHHH Thank you! Let's try. Are you familiar with the ClickHouse codebase around aggregate functions (`IAggregateFunction`, `AggregateFunctionCovariance`)?\r\n\r\nHe should familiar with it, he is my colleague, and recently he is focusing on developing some statistics related UDAF.",
  "created_at": "2022-12-28T15:59:28Z",
  "modified_files": [
    "b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.cpp",
    "b/src/AggregateFunctions/AggregateFunctionVarianceMatrix.h",
    "src/AggregateFunctions/registerAggregateFunctions.cpp"
  ],
  "modified_test_files": [
    "tests/fuzz/dictionaries/functions.dict",
    "b/tests/queries/0_stateless/02515_aggregate_functions_statistics.reference",
    "b/tests/queries/0_stateless/02515_aggregate_functions_statistics.sql"
  ]
}