{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37148,
  "instance_id": "ClickHouse__ClickHouse-37148",
  "issue_numbers": [
    "32481"
  ],
  "base_commit": "bf0da38d6f57ffef8f3fd84699b7251836a4f403",
  "patch": "diff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex 012750bde60f..5624f9595d7b 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -252,7 +252,7 @@ Strings DictionaryStructure::getKeysNames() const\n static void checkAttributeKeys(const Poco::Util::AbstractConfiguration::Keys & keys)\n {\n     static const std::unordered_set<std::string_view> valid_keys\n-        = {\"name\", \"type\", \"expression\", \"null_value\", \"hierarchical\", \"injective\", \"is_object_id\"};\n+        = {\"name\", \"type\", \"expression\", \"null_value\", \"hierarchical\", \"bidirectional\", \"injective\", \"is_object_id\"};\n \n     for (const auto & key : keys)\n     {\n@@ -350,6 +350,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n         }\n \n         const auto hierarchical = config.getBool(prefix + \"hierarchical\", false);\n+        const auto bidirectional = config.getBool(prefix + \"bidirectional\", false);\n         const auto injective = config.getBool(prefix + \"injective\", false);\n         const auto is_object_id = config.getBool(prefix + \"is_object_id\", false);\n \n@@ -362,6 +363,9 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n         if (has_hierarchy && hierarchical)\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Only one hierarchical attribute supported\");\n \n+        if (bidirectional && !hierarchical)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Bidirectional can only be applied to hierarchical attributes\");\n+\n         has_hierarchy = has_hierarchy || hierarchical;\n \n         res_attributes.emplace_back(DictionaryAttribute{\n@@ -372,6 +376,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n             expression,\n             null_value,\n             hierarchical,\n+            bidirectional,\n             injective,\n             is_object_id,\n             is_nullable});\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 50cfba01894c..bb4c306affac 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -67,6 +67,7 @@ struct DictionaryAttribute final\n     const std::string expression;\n     const Field null_value;\n     const bool hierarchical;\n+    const bool bidirectional;\n     const bool injective;\n     const bool is_object_id;\n     const bool is_nullable;\ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex 2fe9f09741b8..d0d9fba763cc 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -43,6 +43,7 @@ FlatDictionary::FlatDictionary(\n {\n     createAttributes();\n     loadData();\n+    buildHierarchyParentToChildIndexIfNeeded();\n     calculateBytesAllocated();\n }\n \n@@ -244,30 +245,43 @@ ColumnUInt8::Ptr FlatDictionary::isInHierarchy(\n     return result;\n }\n \n-ColumnPtr FlatDictionary::getDescendants(\n-    ColumnPtr key_column,\n-    const DataTypePtr &,\n-    size_t level) const\n+DictionaryHierarchyParentToChildIndexPtr FlatDictionary::getHierarchicalIndex() const\n {\n-    PaddedPODArray<UInt64> keys_backup;\n-    const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+    if (hierarhical_index)\n+        return hierarhical_index;\n \n     size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n     const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n     const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.container);\n \n     HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+    parent_to_child.reserve(element_count);\n+\n+    UInt64 child_keys_size = static_cast<UInt64>(parent_keys.size());\n \n-    for (size_t i = 0; i < parent_keys.size(); ++i)\n+    for (UInt64 child_key = 0; child_key < child_keys_size; ++child_key)\n     {\n-        auto parent_key = parent_keys[i];\n+        if (!loaded_keys[child_key])\n+            continue;\n \n-        if (loaded_keys[i])\n-            parent_to_child[parent_key].emplace_back(static_cast<UInt64>(i));\n+        auto parent_key = parent_keys[child_key];\n+        parent_to_child[parent_key].emplace_back(child_key);\n     }\n \n+    return std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n+}\n+\n+ColumnPtr FlatDictionary::getDescendants(\n+    ColumnPtr key_column,\n+    const DataTypePtr &,\n+    size_t level,\n+    DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index) const\n+{\n+    PaddedPODArray<UInt64> keys_backup;\n+    const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n     size_t keys_found;\n-    auto result = getKeysDescendantsArray(keys, parent_to_child, level, keys_found);\n+    auto result = getKeysDescendantsArray(keys, *parent_to_child_index, level, keys_found);\n \n     query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -400,6 +414,15 @@ void FlatDictionary::loadData()\n         throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY, \"{}: dictionary source is empty and 'require_nonempty' property is set.\", getFullName());\n }\n \n+void FlatDictionary::buildHierarchyParentToChildIndexIfNeeded()\n+{\n+    if (!dict_struct.hierarchical_attribute_index)\n+        return;\n+\n+    if (dict_struct.attributes[*dict_struct.hierarchical_attribute_index].bidirectional)\n+        hierarhical_index = getHierarchicalIndex();\n+}\n+\n void FlatDictionary::calculateBytesAllocated()\n {\n     bytes_allocated += attributes.size() * sizeof(attributes.front());\n@@ -439,6 +462,12 @@ void FlatDictionary::calculateBytesAllocated()\n     if (update_field_loaded_block)\n         bytes_allocated += update_field_loaded_block->allocatedBytes();\n \n+    if (hierarhical_index)\n+    {\n+        hierarchical_index_bytes_allocated = hierarhical_index->getSizeInBytes();\n+        bytes_allocated += hierarchical_index_bytes_allocated;\n+    }\n+\n     bytes_allocated += string_arena.size();\n }\n \ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex f342c38802db..9ae3e9a2e711 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -92,10 +92,15 @@ class FlatDictionary final : public IDictionary\n         ColumnPtr in_key_column,\n         const DataTypePtr & key_type) const override;\n \n+    DictionaryHierarchicalParentToChildIndexPtr getHierarchicalIndex() const override;\n+\n+    size_t getHierarchicalIndexBytesAllocated() const override { return hierarchical_index_bytes_allocated; }\n+\n     ColumnPtr getDescendants(\n         ColumnPtr key_column,\n         const DataTypePtr & key_type,\n-        size_t level) const override;\n+        size_t level,\n+        DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index) const override;\n \n     Pipe read(const Names & column_names, size_t max_block_size, size_t num_streams) const override;\n \n@@ -137,10 +142,15 @@ class FlatDictionary final : public IDictionary\n     };\n \n     void createAttributes();\n+\n     void blockToAttributes(const Block & block);\n+\n     void updateData();\n+\n     void loadData();\n \n+    void buildHierarchyParentToChildIndexIfNeeded();\n+\n     void calculateBytesAllocated();\n \n     Attribute createAttribute(const DictionaryAttribute & attribute);\n@@ -165,6 +175,7 @@ class FlatDictionary final : public IDictionary\n     std::vector<bool> loaded_keys;\n \n     size_t bytes_allocated = 0;\n+    size_t hierarchical_index_bytes_allocated = 0;\n     size_t element_count = 0;\n     size_t bucket_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n@@ -172,6 +183,7 @@ class FlatDictionary final : public IDictionary\n \n     BlockPtr update_field_loaded_block;\n     Arena string_arena;\n+    DictionaryHierarchicalParentToChildIndexPtr hierarhical_index;\n };\n \n }\ndiff --git a/src/Dictionaries/HashedArrayDictionary.cpp b/src/Dictionaries/HashedArrayDictionary.cpp\nindex 5a2586147b8b..66c63b7330d2 100644\n--- a/src/Dictionaries/HashedArrayDictionary.cpp\n+++ b/src/Dictionaries/HashedArrayDictionary.cpp\n@@ -37,6 +37,7 @@ HashedArrayDictionary<dictionary_key_type>::HashedArrayDictionary(\n {\n     createAttributes();\n     loadData();\n+    buildHierarchyParentToChildIndexIfNeeded();\n     calculateBytesAllocated();\n }\n \n@@ -282,18 +283,14 @@ ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::isInHierarchy(\n }\n \n template <DictionaryKeyType dictionary_key_type>\n-ColumnPtr HashedArrayDictionary<dictionary_key_type>::getDescendants(\n-    ColumnPtr key_column [[maybe_unused]],\n-    const DataTypePtr &,\n-    size_t level [[maybe_unused]]) const\n+DictionaryHierarchicalParentToChildIndexPtr HashedArrayDictionary<dictionary_key_type>::getHierarchicalIndex() const\n {\n     if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n     {\n-        PaddedPODArray<UInt64> keys_backup;\n-        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+        if (hierarchical_index)\n+            return hierarchical_index;\n \n         size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n-\n         const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n         const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n \n@@ -306,6 +303,7 @@ ColumnPtr HashedArrayDictionary<dictionary_key_type>::getDescendants(\n             index_to_key[value] = key;\n \n         HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+        parent_to_child.reserve(index_to_key.size());\n \n         for (size_t i = 0; i < parent_keys_container.size(); ++i)\n         {\n@@ -313,13 +311,33 @@ ColumnPtr HashedArrayDictionary<dictionary_key_type>::getDescendants(\n             if (it == index_to_key.end())\n                 continue;\n \n-            auto parent_key = it->getMapped();\n-            auto child_key = parent_keys_container[i];\n+            auto child_key = it->getMapped();\n+            auto parent_key = parent_keys_container[i];\n             parent_to_child[parent_key].emplace_back(child_key);\n         }\n \n+        return std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n+    }\n+    else\n+    {\n+        return nullptr;\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr HashedArrayDictionary<dictionary_key_type>::getDescendants(\n+    ColumnPtr key_column [[maybe_unused]],\n+    const DataTypePtr &,\n+    size_t level [[maybe_unused]],\n+    DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index [[maybe_unused]]) const\n+{\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n         size_t keys_found = 0;\n-        auto result = getKeysDescendantsArray(keys, parent_to_child, level, keys_found);\n+        auto result = getKeysDescendantsArray(keys, *parent_to_child_index, level, keys_found);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -693,6 +711,16 @@ void HashedArrayDictionary<dictionary_key_type>::loadData()\n             getFullName());\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::buildHierarchyParentToChildIndexIfNeeded()\n+{\n+    if (!dict_struct.hierarchical_attribute_index)\n+        return;\n+\n+    if (dict_struct.attributes[*dict_struct.hierarchical_attribute_index].bidirectional)\n+        hierarchical_index = getHierarchicalIndex();\n+}\n+\n template <DictionaryKeyType dictionary_key_type>\n void HashedArrayDictionary<dictionary_key_type>::calculateBytesAllocated()\n {\n@@ -730,10 +758,16 @@ void HashedArrayDictionary<dictionary_key_type>::calculateBytesAllocated()\n             bytes_allocated += (*attribute.is_index_null).size();\n     }\n \n-    bytes_allocated += string_arena.size();\n-\n     if (update_field_loaded_block)\n         bytes_allocated += update_field_loaded_block->allocatedBytes();\n+\n+    if (hierarchical_index)\n+    {\n+        hierarchical_index_bytes_allocated = hierarchical_index->getSizeInBytes();\n+        bytes_allocated += hierarchical_index_bytes_allocated;\n+    }\n+\n+    bytes_allocated += string_arena.size();\n }\n \n template <DictionaryKeyType dictionary_key_type>\ndiff --git a/src/Dictionaries/HashedArrayDictionary.h b/src/Dictionaries/HashedArrayDictionary.h\nindex a649fddcc39f..8df9ce4c1f79 100644\n--- a/src/Dictionaries/HashedArrayDictionary.h\n+++ b/src/Dictionaries/HashedArrayDictionary.h\n@@ -109,10 +109,15 @@ class HashedArrayDictionary final : public IDictionary\n         ColumnPtr in_key_column,\n         const DataTypePtr & key_type) const override;\n \n+    DictionaryHierarchicalParentToChildIndexPtr getHierarchicalIndex() const override;\n+\n+    size_t getHierarchicalIndexBytesAllocated() const override { return hierarchical_index_bytes_allocated; }\n+\n     ColumnPtr getDescendants(\n         ColumnPtr key_column,\n         const DataTypePtr & key_type,\n-        size_t level) const override;\n+        size_t level,\n+        DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index) const override;\n \n     Pipe read(const Names & column_names, size_t max_block_size, size_t num_streams) const override;\n \n@@ -173,6 +178,8 @@ class HashedArrayDictionary final : public IDictionary\n \n     void loadData();\n \n+    void buildHierarchyParentToChildIndexIfNeeded();\n+\n     void calculateBytesAllocated();\n \n     template <typename KeysProvider>\n@@ -214,6 +221,7 @@ class HashedArrayDictionary final : public IDictionary\n     KeyAttribute key_attribute;\n \n     size_t bytes_allocated = 0;\n+    size_t hierarchical_index_bytes_allocated = 0;\n     size_t element_count = 0;\n     size_t bucket_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n@@ -221,6 +229,7 @@ class HashedArrayDictionary final : public IDictionary\n \n     BlockPtr update_field_loaded_block;\n     Arena string_arena;\n+    DictionaryHierarchicalParentToChildIndexPtr hierarchical_index;\n };\n \n extern template class HashedArrayDictionary<DictionaryKeyType::Simple>;\ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex 7025922da12c..81d3d42617b2 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -54,6 +54,7 @@ HashedDictionary<dictionary_key_type, sparse>::HashedDictionary(\n {\n     createAttributes();\n     loadData();\n+    buildHierarchyParentToChildIndexIfNeeded();\n     calculateBytesAllocated();\n }\n \n@@ -318,28 +319,45 @@ ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::isInHierarchy(\n }\n \n template <DictionaryKeyType dictionary_key_type, bool sparse>\n-ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getDescendants(\n-    ColumnPtr key_column [[maybe_unused]],\n-    const DataTypePtr &,\n-    size_t level [[maybe_unused]]) const\n+DictionaryHierarchyParentToChildIndexPtr HashedDictionary<dictionary_key_type, sparse>::getHierarchicalIndex() const\n {\n     if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n     {\n-        PaddedPODArray<UInt64> keys_backup;\n-        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+        if (hierarchical_index)\n+            return hierarchical_index;\n \n         size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n-\n         const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n         const CollectionType<UInt64> & parent_keys = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n \n         HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+        parent_to_child.reserve(parent_keys.size());\n \n         for (const auto & [key, value] : parent_keys)\n             parent_to_child[value].emplace_back(key);\n \n+        return std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n+    }\n+    else\n+    {\n+        return nullptr;\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getDescendants(\n+    ColumnPtr key_column [[maybe_unused]],\n+    const DataTypePtr &,\n+    size_t level [[maybe_unused]],\n+    DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index [[maybe_unused]]) const\n+{\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n         size_t keys_found;\n-        auto result = getKeysDescendantsArray(keys, parent_to_child, level, keys_found);\n+        auto result = getKeysDescendantsArray(keys, *parent_to_child_index, level, keys_found);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -347,7 +365,9 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getDescendants(\n         return result;\n     }\n     else\n+    {\n         return nullptr;\n+    }\n }\n \n template <DictionaryKeyType dictionary_key_type, bool sparse>\n@@ -631,6 +651,16 @@ void HashedDictionary<dictionary_key_type, sparse>::loadData()\n             getFullName());\n }\n \n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::buildHierarchyParentToChildIndexIfNeeded()\n+{\n+    if (!dict_struct.hierarchical_attribute_index)\n+        return;\n+\n+    if (dict_struct.attributes[*dict_struct.hierarchical_attribute_index].bidirectional)\n+        hierarchical_index = getHierarchicalIndex();\n+}\n+\n template <DictionaryKeyType dictionary_key_type, bool sparse>\n void HashedDictionary<dictionary_key_type, sparse>::calculateBytesAllocated()\n {\n@@ -684,10 +714,16 @@ void HashedDictionary<dictionary_key_type, sparse>::calculateBytesAllocated()\n         }\n     }\n \n-    bytes_allocated += string_arena.size();\n-\n     if (update_field_loaded_block)\n         bytes_allocated += update_field_loaded_block->allocatedBytes();\n+\n+    if (hierarchical_index)\n+    {\n+        hierarchical_index_bytes_allocated = hierarchical_index->getSizeInBytes();\n+        bytes_allocated += hierarchical_index_bytes_allocated;\n+    }\n+\n+    bytes_allocated += string_arena.size();\n }\n \n template <DictionaryKeyType dictionary_key_type, bool sparse>\ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex 1ef1c58b67c3..ba5d284466a8 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -110,10 +110,15 @@ class HashedDictionary final : public IDictionary\n         ColumnPtr in_key_column,\n         const DataTypePtr & key_type) const override;\n \n+    DictionaryHierarchicalParentToChildIndexPtr getHierarchicalIndex() const override;\n+\n+    size_t getHierarchicalIndexBytesAllocated() const override { return hierarchical_index_bytes_allocated; }\n+\n     ColumnPtr getDescendants(\n         ColumnPtr key_column,\n         const DataTypePtr & key_type,\n-        size_t level) const override;\n+        size_t level,\n+        DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index) const override;\n \n     Pipe read(const Names & column_names, size_t max_block_size, size_t num_streams) const override;\n \n@@ -194,6 +199,8 @@ class HashedDictionary final : public IDictionary\n \n     void loadData();\n \n+    void buildHierarchyParentToChildIndexIfNeeded();\n+\n     void calculateBytesAllocated();\n \n     template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n@@ -218,6 +225,7 @@ class HashedDictionary final : public IDictionary\n     std::vector<Attribute> attributes;\n \n     size_t bytes_allocated = 0;\n+    size_t hierarchical_index_bytes_allocated = 0;\n     size_t element_count = 0;\n     size_t bucket_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n@@ -226,6 +234,7 @@ class HashedDictionary final : public IDictionary\n     BlockPtr update_field_loaded_block;\n     Arena string_arena;\n     NoAttributesCollectionType no_attributes_container;\n+    DictionaryHierarchicalParentToChildIndexPtr hierarchical_index;\n };\n \n extern template class HashedDictionary<DictionaryKeyType::Simple, false>;\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.cpp b/src/Dictionaries/HierarchyDictionariesUtils.cpp\nindex dd729fe636c7..0b5f8478f7a8 100644\n--- a/src/Dictionaries/HierarchyDictionariesUtils.cpp\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.cpp\n@@ -8,6 +8,22 @@ namespace ErrorCodes\n     extern const int UNSUPPORTED_METHOD;\n }\n \n+namespace detail\n+{\n+    ColumnPtr convertElementsAndOffsetsIntoArray(ElementsAndOffsets && elements_and_offsets)\n+    {\n+        auto elements_column = ColumnVector<UInt64>::create();\n+        elements_column->getData() = std::move(elements_and_offsets.elements);\n+\n+        auto offsets_column = ColumnVector<IColumn::Offset>::create();\n+        offsets_column->getData() = std::move(elements_and_offsets.offsets);\n+\n+        auto column_array = ColumnArray::create(std::move(elements_column), std::move(offsets_column));\n+\n+        return column_array;\n+    }\n+}\n+\n namespace\n {\n     /** In case of cache or direct dictionary we does not have structure with child to parent representation.\n@@ -84,6 +100,26 @@ namespace\n     }\n }\n \n+ColumnPtr getKeysDescendantsArray(\n+    const PaddedPODArray<UInt64> & requested_keys,\n+    const DictionaryHierarchicalParentToChildIndex & parent_to_child_index,\n+    size_t level,\n+    size_t & valid_keys)\n+{\n+    if (level == 0)\n+    {\n+        detail::GetAllDescendantsStrategy strategy { .level = level };\n+        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child_index, strategy, valid_keys);\n+        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n+    }\n+    else\n+    {\n+        detail::GetDescendantsAtSpecificLevelStrategy strategy { .level = level };\n+        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child_index, strategy, valid_keys);\n+        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n+    }\n+}\n+\n ColumnPtr getKeysHierarchyDefaultImplementation(\n     const IDictionary * dictionary,\n     ColumnPtr key_column,\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.h b/src/Dictionaries/HierarchyDictionariesUtils.h\nindex f0c6b4b1a0f7..6a59a37b5e7a 100644\n--- a/src/Dictionaries/HierarchyDictionariesUtils.h\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.h\n@@ -14,25 +14,65 @@\n namespace DB\n {\n \n+class DictionaryHierarchicalParentToChildIndex;\n+using DictionaryHierarchyParentToChildIndexPtr = std::shared_ptr<DictionaryHierarchicalParentToChildIndex>;\n+\n+class DictionaryHierarchicalParentToChildIndex\n+{\n+public:\n+    struct KeysRange\n+    {\n+        UInt32 start_index;\n+        UInt32 end_index;\n+    };\n+\n+    explicit DictionaryHierarchicalParentToChildIndex(const HashMap<UInt64, PaddedPODArray<UInt64>> & parent_to_children_map_)\n+    {\n+        size_t parent_to_children_map_size = parent_to_children_map_.size();\n+\n+        keys.reserve(parent_to_children_map_size);\n+        parent_to_children_keys_range.reserve(parent_to_children_map_size);\n+\n+        for (auto & [parent, children] : parent_to_children_map_)\n+        {\n+            size_t keys_size = keys.size();\n+            UInt32 start_index = static_cast<UInt32>(keys_size);\n+            UInt32 end_index = start_index + static_cast<UInt32>(children.size());\n+\n+            keys.insert(children.begin(), children.end());\n+\n+            parent_to_children_keys_range[parent] = KeysRange{start_index, end_index};\n+        }\n+    }\n+\n+    size_t getSizeInBytes() const\n+    {\n+        return parent_to_children_keys_range.getBufferSizeInBytes() + (keys.size() * sizeof(UInt64));\n+    }\n+\n+    /// Map parent key to range of children from keys array\n+    HashMap<UInt64, KeysRange> parent_to_children_keys_range;\n+\n+    /// Array of keys in hierarchy\n+    PaddedPODArray<UInt64> keys;\n+};\n+\n namespace detail\n {\n-    template <typename KeyType>\n     struct ElementsAndOffsets\n     {\n-        PaddedPODArray<KeyType> elements;\n+        PaddedPODArray<UInt64> elements;\n         PaddedPODArray<IColumn::Offset> offsets;\n     };\n \n-    template <typename T>\n     struct IsKeyValidFuncInterface\n     {\n-        bool operator()(T key [[maybe_unused]]) { return false; }\n+        bool operator()(UInt64 key [[maybe_unused]]) { return false; }\n     };\n \n-    template <typename T>\n     struct GetParentKeyFuncInterface\n     {\n-        std::optional<T> operator()(T key [[maybe_unused]]) { return {}; }\n+        std::optional<UInt64> operator()(UInt64 key [[maybe_unused]]) { return {}; }\n     };\n \n     /** Calculate hierarchy for keys iterating the hierarchy from child to parent using get_parent_key_func provided by client.\n@@ -54,16 +94,16 @@ namespace detail\n       * Elements: [1, 2, 1, 3, 1, 4, 2, 1]\n       * Offsets: [1, 3, 5, 8, 8]\n       */\n-    template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n-    ElementsAndOffsets<KeyType> getHierarchy(\n-        const PaddedPODArray<KeyType> & keys,\n-        const KeyType & hierarchy_null_value,\n+    template <typename IsKeyValidFunc, typename GetParentKeyFunc>\n+    ElementsAndOffsets getHierarchy(\n+        const PaddedPODArray<UInt64> & keys,\n+        const UInt64 & hierarchy_null_value,\n         IsKeyValidFunc && is_key_valid_func,\n         GetParentKeyFunc && get_parent_key_func)\n     {\n         size_t hierarchy_keys_size = keys.size();\n \n-        PaddedPODArray<KeyType> elements;\n+        PaddedPODArray<UInt64> elements;\n         elements.reserve(hierarchy_keys_size);\n \n         PaddedPODArray<IColumn::Offset> offsets;\n@@ -75,7 +115,7 @@ namespace detail\n             size_t array_element_offset;\n         };\n \n-        HashMap<KeyType, OffsetInArray> already_processes_keys_to_offset;\n+        HashMap<UInt64, OffsetInArray> already_processes_keys_to_offset;\n         already_processes_keys_to_offset.reserve(hierarchy_keys_size);\n \n         for (size_t i = 0; i < hierarchy_keys_size; ++i)\n@@ -123,7 +163,7 @@ namespace detail\n                 elements.emplace_back(hierarchy_key);\n                 ++current_hierarchy_depth;\n \n-                std::optional<KeyType> parent_key = std::forward<GetParentKeyFunc>(get_parent_key_func)(hierarchy_key);\n+                std::optional<UInt64> parent_key = std::forward<GetParentKeyFunc>(get_parent_key_func)(hierarchy_key);\n \n                 if (!parent_key.has_value())\n                     break;\n@@ -134,7 +174,7 @@ namespace detail\n             offsets.emplace_back(elements.size());\n         }\n \n-        ElementsAndOffsets<KeyType> result = {std::move(elements), std::move(offsets)};\n+        ElementsAndOffsets result = {std::move(elements), std::move(offsets)};\n \n         return result;\n     }\n@@ -146,11 +186,11 @@ namespace detail\n       *\n       * Not: keys size must be equal to in_keys_size.\n       */\n-    template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n+    template <typename IsKeyValidFunc, typename GetParentKeyFunc>\n     PaddedPODArray<UInt8> getIsInHierarchy(\n-        const PaddedPODArray<KeyType> & keys,\n-        const PaddedPODArray<KeyType> & in_keys,\n-        const KeyType & hierarchy_null_value,\n+        const PaddedPODArray<UInt64> & keys,\n+        const PaddedPODArray<UInt64> & in_keys,\n+        const UInt64 & hierarchy_null_value,\n         IsKeyValidFunc && is_key_valid_func,\n         GetParentKeyFunc && get_parent_func)\n     {\n@@ -159,7 +199,7 @@ namespace detail\n         PaddedPODArray<UInt8> result;\n         result.resize_fill(keys.size());\n \n-        detail::ElementsAndOffsets<KeyType> hierarchy = detail::getHierarchy(\n+        detail::ElementsAndOffsets hierarchy = detail::getHierarchy(\n             keys,\n             hierarchy_null_value,\n             std::forward<IsKeyValidFunc>(is_key_valid_func),\n@@ -216,19 +256,22 @@ namespace detail\n       * Result: [1], [2, 3], [4], [], [];\n       * Offsets: [1, 3, 4, 4, 4];\n       */\n-    template <typename KeyType, typename Strategy>\n-    ElementsAndOffsets<KeyType> getDescendants(\n-        const PaddedPODArray<KeyType> & keys,\n-        const HashMap<KeyType, PaddedPODArray<KeyType>> & parent_to_child,\n+    template <typename Strategy>\n+    ElementsAndOffsets getDescendants(\n+        const PaddedPODArray<UInt64> & keys,\n+        const DictionaryHierarchicalParentToChildIndex & parent_to_child_index,\n         Strategy strategy,\n         size_t & valid_keys)\n     {\n+        auto & parent_to_children_keys_range = parent_to_child_index.parent_to_children_keys_range;\n+        auto & children_keys = parent_to_child_index.keys;\n+\n         /// If strategy is GetAllDescendantsStrategy we try to cache and later reuse previously calculated descendants.\n         /// If strategy is GetDescendantsAtSpecificLevelStrategy we does not use cache strategy.\n         size_t keys_size = keys.size();\n         valid_keys = 0;\n \n-        PaddedPODArray<KeyType> descendants;\n+        PaddedPODArray<UInt64> descendants;\n         descendants.reserve(keys_size);\n \n         PaddedPODArray<IColumn::Offset> descendants_offsets;\n@@ -241,18 +284,18 @@ namespace detail\n         };\n \n         static constexpr Int64 key_range_requires_update = -1;\n-        HashMap<KeyType, Range> already_processed_keys_to_range [[maybe_unused]];\n+        HashMap<UInt64, Range> already_processed_keys_to_range [[maybe_unused]];\n \n         if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n             already_processed_keys_to_range.reserve(keys_size);\n \n         struct KeyAndDepth\n         {\n-            KeyType key;\n+            UInt64 key;\n             Int64 depth;\n         };\n \n-        HashSet<KeyType> already_processed_keys_during_loop;\n+        HashSet<UInt64> already_processed_keys_during_loop;\n         already_processed_keys_during_loop.reserve(keys_size);\n \n         PaddedPODArray<KeyAndDepth> next_keys_to_process_stack;\n@@ -262,9 +305,9 @@ namespace detail\n \n         for (size_t i = 0; i < keys_size; ++i)\n         {\n-            const KeyType & requested_key = keys[i];\n+            const UInt64 & requested_key = keys[i];\n \n-            if (parent_to_child.find(requested_key) == nullptr)\n+            if (parent_to_children_keys_range.find(requested_key) == nullptr)\n             {\n                 descendants_offsets.emplace_back(descendants.size());\n                 continue;\n@@ -282,7 +325,7 @@ namespace detail\n             {\n                 KeyAndDepth key_to_process = next_keys_to_process_stack.back();\n \n-                KeyType key = key_to_process.key;\n+                UInt64 key = key_to_process.key;\n                 Int64 depth = key_to_process.depth;\n                 next_keys_to_process_stack.pop_back();\n \n@@ -329,7 +372,7 @@ namespace detail\n                     }\n                 }\n \n-                const auto * it = parent_to_child.find(key);\n+                const auto * it = parent_to_children_keys_range.find(key);\n \n                 if (!it || depth >= DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH)\n                     continue;\n@@ -352,15 +395,26 @@ namespace detail\n \n                 ++depth;\n \n-                const auto & children = it->getMapped();\n+                DictionaryHierarchicalParentToChildIndex::KeysRange children_range = it->getMapped();\n \n-                for (auto child_key : children)\n+                for (; children_range.start_index < children_range.end_index; ++children_range.start_index)\n                 {\n+                    auto child_key = children_keys[children_range.start_index];\n+\n                     /// In case of GetAllDescendantsStrategy we add any descendant to result array\n                     /// If strategy is GetDescendantsAtSpecificLevelStrategy we require depth == level\n-                    if (std::is_same_v<Strategy, GetAllDescendantsStrategy> || depth == level)\n+                    if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n                         descendants.emplace_back(child_key);\n \n+                    if constexpr (std::is_same_v<Strategy, GetDescendantsAtSpecificLevelStrategy>)\n+                    {\n+                        if (depth == level)\n+                        {\n+                            descendants.emplace_back(child_key);\n+                            continue;\n+                        }\n+                    }\n+\n                     next_keys_to_process_stack.emplace_back(KeyAndDepth{child_key, depth});\n                 }\n             }\n@@ -370,24 +424,12 @@ namespace detail\n             descendants_offsets.emplace_back(descendants.size());\n         }\n \n-        ElementsAndOffsets<KeyType> result = {std::move(descendants), std::move(descendants_offsets)};\n+        ElementsAndOffsets result = {std::move(descendants), std::move(descendants_offsets)};\n         return result;\n     }\n \n     /// Converts ElementAndOffsets structure into ArrayColumn\n-    template<typename KeyType>\n-    ColumnPtr convertElementsAndOffsetsIntoArray(ElementsAndOffsets<KeyType> && elements_and_offsets)\n-    {\n-        auto elements_column = ColumnVector<KeyType>::create();\n-        elements_column->getData() = std::move(elements_and_offsets.elements);\n-\n-        auto offsets_column = ColumnVector<IColumn::Offset>::create();\n-        offsets_column->getData() = std::move(elements_and_offsets.offsets);\n-\n-        auto column_array = ColumnArray::create(std::move(elements_column), std::move(offsets_column));\n-\n-        return column_array;\n-    }\n+    ColumnPtr convertElementsAndOffsetsIntoArray(ElementsAndOffsets && elements_and_offsets);\n }\n \n /// Returns hierarchy array column for keys\n@@ -432,26 +474,11 @@ ColumnUInt8::Ptr getKeysIsInHierarchyColumn(\n /// Returns descendants array column for keys\n ///\n /// @param valid_keys - number of keys that are valid in parent_to_child map\n-template <typename KeyType>\n ColumnPtr getKeysDescendantsArray(\n-    const PaddedPODArray<KeyType> & requested_keys,\n-    const HashMap<KeyType, PaddedPODArray<KeyType>> & parent_to_child,\n+    const PaddedPODArray<UInt64> & requested_keys,\n+    const DictionaryHierarchicalParentToChildIndex & parent_to_child_index,\n     size_t level,\n-    size_t & valid_keys)\n-{\n-    if (level == 0)\n-    {\n-        detail::GetAllDescendantsStrategy strategy { .level = level };\n-        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child, strategy, valid_keys);\n-        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n-    }\n-    else\n-    {\n-        detail::GetDescendantsAtSpecificLevelStrategy strategy { .level = level };\n-        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child, strategy, valid_keys);\n-        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n-    }\n-}\n+    size_t & valid_keys);\n \n /** Default getHierarchy implementation for dictionaries that does not have structure with child to parent representation.\n   * Implementation will build such structure with getColumn calls, and then getHierarchy for such structure.\ndiff --git a/src/Dictionaries/IDictionary.h b/src/Dictionaries/IDictionary.h\nindex c18dbcfbea70..32c81beee6f2 100644\n--- a/src/Dictionaries/IDictionary.h\n+++ b/src/Dictionaries/IDictionary.h\n@@ -24,6 +24,9 @@ namespace ErrorCodes\n class IDictionary;\n using DictionaryPtr = std::unique_ptr<IDictionary>;\n \n+class DictionaryHierarchicalParentToChildIndex;\n+using DictionaryHierarchicalParentToChildIndexPtr = std::shared_ptr<DictionaryHierarchicalParentToChildIndex>;\n+\n /** DictionaryKeyType provides IDictionary client information about\n   * which key type is supported by dictionary.\n   *\n@@ -228,10 +231,23 @@ class IDictionary : public IExternalLoadable\n                         getDictionaryID().getNameForLogs());\n     }\n \n+    virtual DictionaryHierarchicalParentToChildIndexPtr getHierarchicalIndex() const\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Method getHierarchicalIndex is not supported for {} dictionary.\",\n+                        getDictionaryID().getNameForLogs());\n+    }\n+\n+    virtual size_t getHierarchicalIndexBytesAllocated() const\n+    {\n+        return 0;\n+    }\n+\n     virtual ColumnPtr getDescendants(\n         ColumnPtr key_column [[maybe_unused]],\n         const DataTypePtr & key_type [[maybe_unused]],\n-        size_t level [[maybe_unused]]) const\n+        size_t level [[maybe_unused]],\n+        DictionaryHierarchicalParentToChildIndexPtr parent_to_child_index [[maybe_unused]]) const\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                         \"Method getDescendants is not supported for {} dictionary.\",\ndiff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\nindex 28a842ccd8c4..edc3c34fe816 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n@@ -290,6 +290,14 @@ void buildSingleAttribute(\n         attribute_element->appendChild(hierarchical_element);\n     }\n \n+    if (dict_attr->bidirectional)\n+    {\n+        AutoPtr<Element> bidirectional_element(doc->createElement(\"bidirectional\"));\n+        AutoPtr<Text> bidirectional(doc->createTextNode(\"true\"));\n+        bidirectional_element->appendChild(bidirectional);\n+        attribute_element->appendChild(bidirectional_element);\n+    }\n+\n     if (dict_attr->injective)\n     {\n         AutoPtr<Element> injective_element(doc->createElement(\"injective\"));\ndiff --git a/src/Functions/FunctionsExternalDictionaries.cpp b/src/Functions/FunctionsExternalDictionaries.cpp\nindex 6b83f7610864..0cd56f87df4c 100644\n--- a/src/Functions/FunctionsExternalDictionaries.cpp\n+++ b/src/Functions/FunctionsExternalDictionaries.cpp\n@@ -24,8 +24,8 @@ void registerFunctionsExternalDictionaries(FunctionFactory & factory)\n     factory.registerFunction<FunctionDictGetString>();\n     factory.registerFunction<FunctionDictGetHierarchy>();\n     factory.registerFunction<FunctionDictIsIn>();\n-    factory.registerFunction<FunctionDictGetChildren>();\n-    factory.registerFunction<FunctionDictGetDescendants>();\n+    factory.registerFunction<FunctionDictGetChildrenOverloadResolver>();\n+    factory.registerFunction<FunctionDictGetDescendantsOverloadResolver>();\n     factory.registerFunction<FunctionDictGetUInt8OrDefault>();\n     factory.registerFunction<FunctionDictGetUInt16OrDefault>();\n     factory.registerFunction<FunctionDictGetUInt32OrDefault>();\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 189ec7321c1a..03833f9a2b29 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -1053,85 +1053,158 @@ class FunctionDictIsIn final : public IFunction\n     mutable FunctionDictHelper helper;\n };\n \n-class FunctionDictGetChildren final : public IFunction\n+class FunctionDictGetDescendantsExecutable final : public IExecutableFunction\n {\n public:\n-    static constexpr auto name = \"dictGetChildren\";\n-\n-    static FunctionPtr create(ContextPtr context)\n-    {\n-        return std::make_shared<FunctionDictGetChildren>(context);\n-    }\n-\n-    explicit FunctionDictGetChildren(ContextPtr context_)\n-        : helper(context_) {}\n+    FunctionDictGetDescendantsExecutable(\n+        String name_,\n+        size_t level_,\n+        DictionaryHierarchicalParentToChildIndexPtr hierarchical_parent_to_child_index,\n+        std::shared_ptr<FunctionDictHelper> dictionary_helper_)\n+        : name(std::move(name_))\n+        , level(level_)\n+        , hierarchical_parent_to_child_index(std::move(hierarchical_parent_to_child_index))\n+        , dictionary_helper(std::move(dictionary_helper_))\n+    {}\n \n     String getName() const override { return name; }\n \n-private:\n-    size_t getNumberOfArguments() const override { return 2; }\n-\n-    bool useDefaultImplementationForConstants() const final { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n-    bool isDeterministic() const override { return false; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        if (!isString(arguments[0].type))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of first argument of function {}. Expected String. Actual type {}\",\n-                getName(),\n-                arguments[0].type->getName());\n-\n-        auto dictionary = helper.getDictionary(arguments[0].column);\n-        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n+    bool useDefaultImplementationForConstants() const override { return true; }\n \n-        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n-    }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0, 2}; }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n-        auto dictionary = helper.getDictionary(arguments[0].column);\n-        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n+        auto dictionary = dictionary_helper->getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = dictionary_helper->getDictionaryHierarchicalAttribute(dictionary);\n \n         auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n         auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n \n-        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, 1);\n-\n+        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, level, hierarchical_parent_to_child_index);\n         return result;\n     }\n \n-    mutable FunctionDictHelper helper;\n+    String name;\n+    size_t level;\n+    DictionaryHierarchicalParentToChildIndexPtr hierarchical_parent_to_child_index;\n+    std::shared_ptr<FunctionDictHelper> dictionary_helper;\n };\n \n-class FunctionDictGetDescendants final : public IFunction\n+class FunctionDictGetDescendantsBase final : public IFunctionBase\n {\n public:\n-    static constexpr auto name = \"dictGetDescendants\";\n+    FunctionDictGetDescendantsBase(\n+        String name_,\n+        const DataTypes & argument_types_,\n+        const DataTypePtr & result_type_,\n+        size_t level_,\n+        DictionaryHierarchicalParentToChildIndexPtr hierarchical_parent_to_child_index,\n+        std::shared_ptr<FunctionDictHelper> helper_)\n+        : name(std::move(name_))\n+        , argument_types(argument_types_)\n+        , result_type(result_type_)\n+        , level(level_)\n+        , hierarchical_parent_to_child_index(std::move(hierarchical_parent_to_child_index))\n+        , helper(std::move(helper_))\n+    {}\n \n-    static FunctionPtr create(ContextPtr context)\n+    String getName() const override { return name; }\n+\n+    const DataTypes & getArgumentTypes() const override { return argument_types; }\n+\n+    const DataTypePtr & getResultType() const override { return result_type; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    ExecutableFunctionPtr prepare(const ColumnsWithTypeAndName &) const override\n     {\n-        return std::make_shared<FunctionDictGetDescendants>(context);\n+        return std::make_shared<FunctionDictGetDescendantsExecutable>(name, level, hierarchical_parent_to_child_index, helper);\n     }\n \n-    explicit FunctionDictGetDescendants(ContextPtr context_)\n-        : helper(context_) {}\n+    String name;\n+    DataTypes argument_types;\n+    DataTypePtr result_type;\n+    size_t level;\n+    DictionaryHierarchicalParentToChildIndexPtr hierarchical_parent_to_child_index;\n+    std::shared_ptr<FunctionDictHelper> helper;\n+};\n+\n+struct FunctionDictGetDescendantsStrategy\n+{\n+    static constexpr auto name = \"dictGetDescendants\";\n+    static constexpr size_t default_level = 0;\n+    static constexpr size_t number_of_arguments = 0;\n+    static constexpr bool is_variadic = true;\n+};\n+\n+struct FunctionDictGetChildrenStrategy\n+{\n+    static constexpr auto name = \"dictGetChildren\";\n+    static constexpr size_t default_level = 1;\n+    static constexpr size_t number_of_arguments = 2;\n+    static constexpr bool is_variadic = false;\n+};\n+\n+template <typename Strategy>\n+class FunctionDictGetDescendantsOverloadResolverImpl final : public IFunctionOverloadResolver\n+{\n+public:\n+    static constexpr auto name = Strategy::name;\n \n     String getName() const override { return name; }\n \n-private:\n-    size_t getNumberOfArguments() const override { return 0; }\n-    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return Strategy::number_of_arguments; }\n+\n+    bool isVariadic() const override { return Strategy::is_variadic; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0, 2}; }\n \n-    bool useDefaultImplementationForConstants() const final { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0, 2}; }\n     bool isDeterministic() const override { return false; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    explicit FunctionDictGetDescendantsOverloadResolverImpl(ContextPtr context)\n+        : dictionary_helper(std::make_shared<FunctionDictHelper>(std::move(context)))\n+    {}\n+\n+    static FunctionOverloadResolverPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionDictGetDescendantsOverloadResolverImpl>(std::move(context));\n+    }\n+\n+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const override\n+    {\n+        auto dictionary = dictionary_helper->getDictionary(arguments[0].column);\n+        auto hierarchical_parent_to_child_index = dictionary->getHierarchicalIndex();\n+\n+        size_t level = Strategy::default_level;\n+\n+        if (arguments.size() == 3)\n+        {\n+            if (!arguments[2].column || !isColumnConst(*arguments[2].column))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n+                    getName());\n+\n+            auto value = static_cast<Int64>(arguments[2].column->getInt(0));\n+            if (value < 0)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n+                    getName());\n+\n+            level = static_cast<size_t>(value);\n+        }\n+\n+        DataTypes argument_types;\n+        argument_types.reserve(arguments.size());\n+\n+        for (const auto & argument : arguments)\n+            argument_types.emplace_back(argument.type);\n+\n+        return std::make_shared<FunctionDictGetDescendantsBase>(name, argument_types, result_type, level, hierarchical_parent_to_child_index, dictionary_helper);\n+    }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n@@ -1158,47 +1231,16 @@ class FunctionDictGetDescendants final : public IFunction\n                 arguments[2].type->getName());\n         }\n \n-        auto dictionary = helper.getDictionary(arguments[0].column);\n-        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n+        auto dictionary = dictionary_helper->getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = dictionary_helper->getDictionaryHierarchicalAttribute(dictionary);\n \n         return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n-    {\n-        if (input_rows_count == 0)\n-            return result_type->createColumn();\n-\n-        auto dictionary = helper.getDictionary(arguments[0].column);\n-        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n-\n-        size_t level = 0;\n-\n-        if (arguments.size() == 3)\n-        {\n-            if (!isColumnConst(*arguments[2].column))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n-                    getName());\n-\n-            auto value = static_cast<Int64>(arguments[2].column->getInt(0));\n-            if (value < 0)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n-                    getName());\n-\n-            level = static_cast<size_t>(value);\n-        }\n-\n-        auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n-        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n-\n-        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, level);\n-\n-        return result;\n-    }\n-\n-    mutable FunctionDictHelper helper;\n+    std::shared_ptr<FunctionDictHelper> dictionary_helper;\n };\n \n+using FunctionDictGetDescendantsOverloadResolver = FunctionDictGetDescendantsOverloadResolverImpl<FunctionDictGetDescendantsStrategy>;\n+using FunctionDictGetChildrenOverloadResolver = FunctionDictGetDescendantsOverloadResolverImpl<FunctionDictGetChildrenStrategy>;\n+\n }\ndiff --git a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\nindex e9c50839a987..760b96b09271 100644\n--- a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n@@ -58,6 +58,9 @@ void ASTDictionaryAttributeDeclaration::formatImpl(const FormatSettings & settin\n     if (hierarchical)\n         settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"HIERARCHICAL\";\n \n+    if (bidirectional)\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"BIDIRECTIONAL\";\n+\n     if (injective)\n         settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"INJECTIVE\";\n \ndiff --git a/src/Parsers/ASTDictionaryAttributeDeclaration.h b/src/Parsers/ASTDictionaryAttributeDeclaration.h\nindex b34ebc539ec4..b6572e89d16a 100644\n--- a/src/Parsers/ASTDictionaryAttributeDeclaration.h\n+++ b/src/Parsers/ASTDictionaryAttributeDeclaration.h\n@@ -20,6 +20,8 @@ class ASTDictionaryAttributeDeclaration : public IAST\n     ASTPtr expression;\n     /// Is attribute mirrored to the parent identifier\n     bool hierarchical;\n+    /// Is hierarchical attribute bidirectional\n+    bool bidirectional;\n     /// Flag that shows whether the id->attribute image is injective\n     bool injective;\n     /// MongoDB object ID\ndiff --git a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\nindex a248c9def071..44bb7fb60577 100644\n--- a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n@@ -15,6 +15,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_default{\"DEFAULT\"};\n     ParserKeyword s_expression{\"EXPRESSION\"};\n     ParserKeyword s_hierarchical{\"HIERARCHICAL\"};\n+    ParserKeyword s_bidirectional{\"BIDIRECTIONAL\"};\n     ParserKeyword s_injective{\"INJECTIVE\"};\n     ParserKeyword s_is_object_id{\"IS_OBJECT_ID\"};\n     ParserLiteral default_parser;\n@@ -30,6 +31,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     ASTPtr default_value;\n     ASTPtr expression;\n     bool hierarchical = false;\n+    bool bidirectional = false;\n     bool injective = false;\n     bool is_object_id = false;\n \n@@ -63,6 +65,12 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n             continue;\n         }\n \n+        if (!bidirectional && s_bidirectional.ignore(pos, expected))\n+        {\n+            bidirectional = true;\n+            continue;\n+        }\n+\n         if (!injective && s_injective.ignore(pos, expected))\n         {\n             injective = true;\n@@ -101,6 +109,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     }\n \n     attribute_declaration->hierarchical = hierarchical;\n+    attribute_declaration->bidirectional = bidirectional;\n     attribute_declaration->injective = injective;\n     attribute_declaration->is_object_id = is_object_id;\n \ndiff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp\nindex c0d7d8cc4edb..5d6f288ab11d 100644\n--- a/src/Storages/System/StorageSystemDictionaries.cpp\n+++ b/src/Storages/System/StorageSystemDictionaries.cpp\n@@ -35,6 +35,7 @@ NamesAndTypesList StorageSystemDictionaries::getNamesAndTypes()\n         {\"attribute.names\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())},\n         {\"attribute.types\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())},\n         {\"bytes_allocated\", std::make_shared<DataTypeUInt64>()},\n+        {\"hierarchical_index_bytes_allocated\", std::make_shared<DataTypeUInt64>()},\n         {\"query_count\", std::make_shared<DataTypeUInt64>()},\n         {\"hit_rate\", std::make_shared<DataTypeFloat64>()},\n         {\"found_rate\", std::make_shared<DataTypeFloat64>()},\n@@ -113,6 +114,7 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, ContextPt\n         if (dict_ptr)\n         {\n             res_columns[i++]->insert(dict_ptr->getBytesAllocated());\n+            res_columns[i++]->insert(dict_ptr->getHierarchicalIndexBytesAllocated());\n             res_columns[i++]->insert(dict_ptr->getQueryCount());\n             res_columns[i++]->insert(dict_ptr->getHitRate());\n             res_columns[i++]->insert(dict_ptr->getFoundRate());\n@@ -128,7 +130,7 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, ContextPt\n         }\n         else\n         {\n-            for (size_t j = 0; j != 9; ++j) // Number of empty fields if dict_ptr is null\n+            for (size_t j = 0; j != 10; ++j) // Number of empty fields if dict_ptr is null\n                 res_columns[i++]->insertDefault();\n         }\n \n",
  "test_patch": "diff --git a/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\nindex f4854b7c77e5..a68f23a978fd 100644\n--- a/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\n+++ b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\n@@ -151,13 +151,15 @@ TEST(HierarchyDictionariesUtils, getDescendants)\n         parent_to_child[1].emplace_back(3);\n         parent_to_child[2].emplace_back(4);\n \n+        auto parent_to_child_index = std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n+\n         PaddedPODArray<UInt64> keys = {0, 1, 2, 3, 4};\n \n         {\n             size_t keys_found;\n             auto result = DB::detail::getDescendants(\n                 keys,\n-                parent_to_child,\n+                *parent_to_child_index,\n                 DB::detail::GetAllDescendantsStrategy(),\n                 keys_found);\n \n@@ -175,7 +177,7 @@ TEST(HierarchyDictionariesUtils, getDescendants)\n             size_t keys_found;\n             auto result = DB::detail::getDescendants(\n                 keys,\n-                parent_to_child,\n+                *parent_to_child_index,\n                 DB::detail::GetDescendantsAtSpecificLevelStrategy{1},\n                 keys_found);\n \n@@ -195,13 +197,15 @@ TEST(HierarchyDictionariesUtils, getDescendants)\n         parent_to_child[1].emplace_back(2);\n         parent_to_child[2].emplace_back(1);\n \n+        auto parent_to_child_index = std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n+\n         PaddedPODArray<UInt64> keys = {1, 2, 3};\n \n         {\n             size_t keys_found;\n             auto result = DB::detail::getDescendants(\n                 keys,\n-                parent_to_child,\n+                *parent_to_child_index,\n                 DB::detail::GetAllDescendantsStrategy(),\n                 keys_found);\n \n@@ -219,7 +223,7 @@ TEST(HierarchyDictionariesUtils, getDescendants)\n             size_t keys_found;\n             auto result = DB::detail::getDescendants(\n                 keys,\n-                parent_to_child,\n+                *parent_to_child_index,\n                 DB::detail::GetDescendantsAtSpecificLevelStrategy{1},\n                 keys_found);\n \ndiff --git a/tests/performance/hierarchical_dictionaries.xml b/tests/performance/hierarchical_dictionaries.xml\nnew file mode 100644\nindex 000000000000..e6030886a1c1\n--- /dev/null\n+++ b/tests/performance/hierarchical_dictionaries.xml\n@@ -0,0 +1,55 @@\n+<test>\n+    <substitutions>\n+        <substitution>\n+            <name>dictionary_layout</name>\n+            <values>\n+                <value>flat</value>\n+                <value>hashed</value>\n+                <value>hashed_array</value>\n+            </values>\n+        </substitution>\n+\n+        <substitution>\n+            <name>func</name>\n+            <values>\n+                <value>dictGetHierarchy</value>\n+                <value>dictGetDescendants</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <create_query>\n+        CREATE TABLE hierarchical_dictionary_source_table\n+        (\n+            id UInt64,\n+            parent_id UInt64\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY hierarchical_{dictionary_layout}_dictionary\n+        (\n+            id UInt64,\n+            parent_id UInt64 HIERARCHICAL\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'hierarchical_dictionary_source_table'))\n+        LAYOUT({dictionary_layout}())\n+        LIFETIME(0);\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO hierarchical_dictionary_source_table\n+        SELECT number, rand64() % 250000\n+        FROM system.numbers\n+        LIMIT 500000;\n+    </fill_query>\n+\n+    <query>\n+        SELECT {func}('hierarchical_{dictionary_layout}_dictionary', id) FROM hierarchical_{dictionary_layout}_dictionary FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS hierarchical_dictionary_source_table;</drop_query>\n+    <drop_query>DROP DICTIONARY IF EXISTS hierarchical_{dictionary_layout}_dictionary;</drop_query>\n+\n+</test>\ndiff --git a/tests/queries/0_stateless/02117_show_create_table_system.reference b/tests/queries/0_stateless/02117_show_create_table_system.reference\nindex ad18e38adcca..37746ef0ced1 100644\n--- a/tests/queries/0_stateless/02117_show_create_table_system.reference\n+++ b/tests/queries/0_stateless/02117_show_create_table_system.reference\n@@ -161,6 +161,7 @@ CREATE TABLE system.dictionaries\n     `attribute.names` Array(String),\n     `attribute.types` Array(String),\n     `bytes_allocated` UInt64,\n+    `hierarchical_index_bytes_allocated` UInt64,\n     `query_count` UInt64,\n     `hit_rate` Float64,\n     `found_rate` Float64,\ndiff --git a/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.reference b/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.reference\nnew file mode 100644\nindex 000000000000..8f421ba45247\n--- /dev/null\n+++ b/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.reference\n@@ -0,0 +1,6 @@\n+1\t0\n+1\n+1\t0\n+1\n+1\t0\n+0\ndiff --git a/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.sql b/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.sql\nnew file mode 100644\nindex 000000000000..bc2a1020ab8c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02294_dictionaries_hierarchical_index.sql\n@@ -0,0 +1,67 @@\n+DROP TABLE IF EXISTS test_hierarchy_source_table;\n+CREATE TABLE test_hierarchy_source_table\n+(\n+    id UInt64,\n+    parent_id UInt64\n+) ENGINE=MergeTree ORDER BY id;\n+\n+INSERT INTO test_hierarchy_source_table VALUES (1, 0);\n+\n+DROP DICTIONARY IF EXISTS hierarchy_flat_dictionary_index;\n+CREATE DICTIONARY hierarchy_flat_dictionary_index\n+(\n+    id UInt64,\n+    parent_id UInt64 BIDIRECTIONAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarchy_source_table'))\n+LAYOUT(FLAT())\n+LIFETIME(0); -- {serverError 36 }\n+\n+DROP DICTIONARY IF EXISTS hierarchy_flat_dictionary_index;\n+CREATE DICTIONARY hierarchy_flat_dictionary_index\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL BIDIRECTIONAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarchy_source_table'))\n+LAYOUT(FLAT())\n+LIFETIME(0);\n+\n+SELECT * FROM hierarchy_flat_dictionary_index;\n+SELECT hierarchical_index_bytes_allocated > 0 FROM system.dictionaries WHERE name = 'hierarchy_flat_dictionary_index' AND database = currentDatabase();\n+\n+DROP DICTIONARY hierarchy_flat_dictionary_index;\n+\n+DROP DICTIONARY IF EXISTS hierarchy_hashed_dictionary_index;\n+CREATE DICTIONARY hierarchy_hashed_dictionary_index\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL BIDIRECTIONAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarchy_source_table'))\n+LAYOUT(FLAT())\n+LIFETIME(0);\n+\n+SELECT * FROM hierarchy_hashed_dictionary_index;\n+SELECT hierarchical_index_bytes_allocated > 0 FROM system.dictionaries WHERE name = 'hierarchy_hashed_dictionary_index' AND database = currentDatabase();\n+DROP DICTIONARY hierarchy_hashed_dictionary_index;\n+\n+DROP DICTIONARY IF EXISTS hierarchy_hashed_array_dictionary_index;\n+CREATE DICTIONARY hierarchy_hashed_array_dictionary_index\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarchy_source_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(0);\n+\n+SELECT * FROM hierarchy_hashed_array_dictionary_index;\n+SELECT hierarchical_index_bytes_allocated > 0 FROM system.dictionaries WHERE name = 'hierarchy_hashed_array_dictionary_index' AND database = currentDatabase();\n+\n+DROP DICTIONARY hierarchy_hashed_array_dictionary_index;\n+DROP TABLE test_hierarchy_source_table;\ndiff --git a/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.reference b/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.reference\nnew file mode 100644\nindex 000000000000..7f4ba0901b63\n--- /dev/null\n+++ b/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.reference\n@@ -0,0 +1,35 @@\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+0\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,3,4]\n+[2,3,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\ndiff --git a/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.sql b/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.sql\nnew file mode 100644\nindex 000000000000..a775f0e5cbf4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02311_hashed_array_dictionary_hierarchical_functions.sql\n@@ -0,0 +1,34 @@\n+DROP TABLE IF EXISTS hierarchy_source_table;\n+CREATE TABLE hierarchy_source_table\n+(\n+    id UInt64,\n+    parent_id UInt64\n+) ENGINE = TinyLog;\n+\n+INSERT INTO hierarchy_source_table VALUES (1, 0), (2, 1), (3, 1), (4, 2);\n+\n+DROP DICTIONARY IF EXISTS hierarchy_hashed_array_dictionary;\n+CREATE DICTIONARY hierarchy_hashed_array_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'hierarchy_source_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierarchy_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierarchy_hashed_array_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('hierarchy_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('hierarchy_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('hierarchy_hashed_array_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY hierarchy_hashed_array_dictionary;\n+\n+DROP TABLE hierarchy_source_table;\n",
  "problem_statement": "dictGetChildren / dictGetDescendants are very slow and consume high amount of memory\n**Describe what's wrong**\r\n\r\ndictGetChildren / dictGetDescendants functions implemented in #22096 operates extremely slow in most of dictionaries of relatively large size (>100k), and consume high amount of memory. \r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes. 21.11.5.33\r\n\r\n**How to reproduce**\r\n\r\nDictionary creation\r\n```\r\n\r\ndrop table if exists default.hierdictsrc;\r\n\r\ncreate table default.hierdictsrc (parent UInt64, child UInt64) Engine=MergeTree ORDER BY tuple();\r\n\r\ninsert into default.hierdictsrc \r\nwith 80 as breadth\r\nselect parent, arrayJoin(child)+parent*breadth as child from (\r\n\t\tselect arrayJoin(range(0,breadth)) as parent, range(0,breadth) as child\r\n)\r\nUNION ALL\r\nwith 80 as breadth\r\nselect parent, arrayJoin(child)+parent*breadth as child from (\r\n\t\tselect arrayJoin(range(breadth,breadth*breadth)) as parent, range(0,breadth) as child\r\n)\r\nUNION ALL\r\nwith 80 as breadth\r\nselect parent, arrayJoin(child)+parent*breadth as child from (\r\n\t\tselect arrayJoin(range(breadth*breadth,breadth*breadth*breadth)) as parent, range(0,breadth) as child\r\n)\r\n;\r\n\r\nselect count(*) from default.hierdictsrc ;\r\ndrop dictionary if exists default.hierdict;\r\n\r\nCREATE DICTIONARY default.hierdict\r\n(\r\n    `child` UInt64,\r\n    `parent` UInt64 HIERARCHICAL\r\n)\r\nPRIMARY KEY child\r\nSOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' DB 'default' TABLE 'hierdictsrc'))\r\nLIFETIME(MIN 300 MAX 86400)\r\nLAYOUT(HASHED());\r\n\r\nsystem reload dictionary default.hierdict;\r\nselect * from system.dictionaries d where database='default';\r\n\r\n```\r\n\r\nQueries to check.\r\nSimple query to get direct children of a single element consumes 2GB RAM and 10 sec. \r\n \r\n```\r\nSELECT dictGetDescendants('default.hierdict', toUInt64(1))\r\nFORMAT `Null`\r\n\r\nQuery id: 6e982f9a-9665-4caf-8f6e-0576d9a752d9\r\n\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:34.764536 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Debug> executeQuery: (from [::1]:59362) SELECT dictGetDescendants('default.hierdict', toUInt64(1)) FORMAT `Null`;\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:34.764837 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Trace> ContextAccess (default): Access granted: dictGet ON default.hierdict\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:35.588383 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Debug> MemoryTracker: Current memory usage (for query): 1.00 GiB.\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:44.312905 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Trace> ContextAccess (default): Access granted: SELECT(dummy) ON system.one\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:44.326528 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:44.651035 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Information> executeQuery: Read 1 rows, 1.00 B in 9.886447463 sec., 0 rows/sec., 0.10 B/sec.\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:29:44.651093 [ 11723 ] {6e982f9a-9665-4caf-8f6e-0576d9a752d9} <Debug> MemoryTracker: Peak memory usage (for query): 1.99 GiB.\r\nOk.\r\n\r\n0 rows in set. Elapsed: 9.887 sec.\r\n\r\n```\r\n\r\nIt gets much worse if there are more levels in the array. It goes out of memory, moreover this query is not possible to cancel. \r\nSimilar issue with dictGetChildren. \r\n\r\n\r\nFor comparison - Reverse query using complex transforms but using dictGetHierarchy uses 140MB and 2.5 sec: \r\n```\r\nSELECT DISTINCT arrayJoin(hier) AS descendants\r\nFROM\r\n(\r\n    SELECT dictGetHierarchy('default.hierdict', toUInt64(child)) AS hier\r\n    FROM default.hierdictsrc\r\n    WHERE (lvl = 3) AND has(hier, 1)\r\n)\r\nWHERE descendants != 1\r\nFORMAT `Null`\r\n\r\nQuery id: 2b787507-11b6-4066-82eb-6ea6e984c842\r\n\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.007316 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> executeQuery: (from [::1]:59362) select distinct arrayJoin(hier) descendants from ( select dictGetHierarchy('default.hierdict',toUInt64(child)) hier from default.hierdictsrc where lvl=3 and has(hier,1) ) where descendants!=1 Format Null;\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.007838 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> InterpreterSelectQuery: MergeTreeWhereOptimizer: condition \"lvl = 3\" moved to PREWHERE\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008073 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Trace> ContextAccess (default): Access granted: SELECT(child, lvl) ON default.hierdictsrc\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008312 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> InterpreterSelectQuery: MergeTreeWhereOptimizer: condition \"lvl = 3\" moved to PREWHERE\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008478 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Trace> ContextAccess (default): Access granted: SELECT(child, lvl) ON default.hierdictsrc\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008648 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008691 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.008950 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> default.hierdictsrc (SelectExecutor): Key condition: unknown, unknown, and, unknown, and\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.009189 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> default.hierdictsrc (SelectExecutor): Selected 2/2 parts by partition key, 2 parts by primary key, 5001/5001 marks by primary key, 5001 marks to read from 2 ranges\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.009267 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> default.hierdictsrc (SelectExecutor): Reading approx. 40960000 rows with 8 streams\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:38.011944 [ 11877 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Trace> ContextAccess (default): Access granted: dictGet ON default.hierdict\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:40.179778 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Information> executeQuery: Read 40960000 rows, 347.66 MiB in 2.172412619 sec., 18854613 rows/sec., 160.03 MiB/sec.\r\n[V30LC-INCLKHSE5.pw.local] 2021.12.09 20:27:40.179832 [ 11723 ] {2b787507-11b6-4066-82eb-6ea6e984c842} <Debug> MemoryTracker: Peak memory usage (for query): 127.83 MiB.\r\nOk.\r\n\r\n0 rows in set. Elapsed: 2.173 sec. Processed 40.96 million rows, 364.54 MB (18.85 million rows/s., 167.73 MB/s.)\r\n```\r\n\r\n\r\n**Expected behavior**\r\n\r\nPerformance was expected not to be degrading as it grows. \r\n\r\n\r\n\r\n**Additional context**\r\n\r\nThere is a also a regression about sparse hashed layout with hierarchical dictionary that may be related to this implementation. Separate ticket was opened: #32480 \r\n\n",
  "hints_text": "We discussed this issue with @kitaisreal and found out that the performance numbers are expected with respect to the current implementation and more advanced implementations will cost extra memory.\n> We discussed this issue with @kitaisreal and found out that the performance numbers are expected with respect to the current implementation and more advanced implementations will cost extra memory.\r\n\r\nThank you, however, if you check queries, you can see that problem is not just slowness, it also has quite high memory overhead. \r\nWould it be feasible to define FR for allowing bidirectional hierarchical dictionaries (separate layout or adding HIERARCHICHAL BIDIRECTIONAL keyword)? We see plenty of possible use cases that need topology operations for such dictionaries (DAGs for crypto/other uses, log analytics for distributed tracing, filesystems, website crawlers, transaction dependencies).\nYes, it's valid use case.\r\n\r\nBy the way, you can preprocess the data and create this reverse dictionary on your own: with Array of descendants as value type.",
  "created_at": "2022-05-12T10:45:40Z"
}