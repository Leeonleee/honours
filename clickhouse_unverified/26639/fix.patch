diff --git a/src/AggregateFunctions/UniqVariadicHash.h b/src/AggregateFunctions/UniqVariadicHash.h
index b3607a632852..94f54a7a0590 100644
--- a/src/AggregateFunctions/UniqVariadicHash.h
+++ b/src/AggregateFunctions/UniqVariadicHash.h
@@ -5,6 +5,7 @@
 #include <Common/SipHash.h>
 #include <Common/assert_cast.h>
 #include <Columns/ColumnTuple.h>
+#include <DataTypes/IDataType.h>
 
 
 namespace DB
diff --git a/src/Columns/ColumnTuple.h b/src/Columns/ColumnTuple.h
index 3f5422c77195..177ff6c412a9 100644
--- a/src/Columns/ColumnTuple.h
+++ b/src/Columns/ColumnTuple.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include <Core/Block.h>
+#include <Columns/IColumn.h>
 
 
 namespace DB
diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp
index 96667862e417..ddfd62c2efbe 100644
--- a/src/Core/Block.cpp
+++ b/src/Core/Block.cpp
@@ -22,6 +22,85 @@ namespace ErrorCodes
     extern const int POSITION_OUT_OF_BOUND;
     extern const int NOT_FOUND_COLUMN_IN_BLOCK;
     extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;
+    extern const int AMBIGUOUS_COLUMN_NAME;
+}
+
+template <typename ReturnType>
+static ReturnType onError(const std::string & message [[maybe_unused]], int code [[maybe_unused]])
+{
+    if constexpr (std::is_same_v<ReturnType, void>)
+        throw Exception(message, code);
+    else
+        return false;
+};
+
+
+template <typename ReturnType>
+static ReturnType checkColumnStructure(const ColumnWithTypeAndName & actual, const ColumnWithTypeAndName & expected,
+    const std::string & context_description, bool allow_remove_constants, int code)
+{
+    if (actual.name != expected.name)
+        return onError<ReturnType>("Block structure mismatch in " + context_description + " stream: different names of columns:
"
+            + actual.dumpStructure() + "
" + expected.dumpStructure(), code);
+
+    if (!actual.type->equals(*expected.type))
+        return onError<ReturnType>("Block structure mismatch in " + context_description + " stream: different types:
"
+            + actual.dumpStructure() + "
" + expected.dumpStructure(), code);
+
+    if (!actual.column || !expected.column)
+        return ReturnType(true);
+
+    const IColumn * actual_column = actual.column.get();
+
+    /// If we allow to remove constants, and expected column is not const, then unwrap actual constant column.
+    if (allow_remove_constants && !isColumnConst(*expected.column))
+    {
+        if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))
+            actual_column = &column_const->getDataColumn();
+    }
+
+    if (actual_column->getName() != expected.column->getName())
+        return onError<ReturnType>("Block structure mismatch in " + context_description + " stream: different columns:
"
+            + actual.dumpStructure() + "
" + expected.dumpStructure(), code);
+
+    if (isColumnConst(*actual.column) && isColumnConst(*expected.column))
+    {
+        Field actual_value = assert_cast<const ColumnConst &>(*actual.column).getField();
+        Field expected_value = assert_cast<const ColumnConst &>(*expected.column).getField();
+
+        if (actual_value != expected_value)
+            return onError<ReturnType>("Block structure mismatch in " + context_description + " stream: different values of constants, actual: "
+                + applyVisitor(FieldVisitorToString(), actual_value) + ", expected: " + applyVisitor(FieldVisitorToString(), expected_value),
+                code);
+    }
+
+    return ReturnType(true);
+}
+
+
+template <typename ReturnType>
+static ReturnType checkBlockStructure(const Block & lhs, const Block & rhs, const std::string & context_description, bool allow_remove_constants)
+{
+    size_t columns = rhs.columns();
+    if (lhs.columns() != columns)
+        return onError<ReturnType>("Block structure mismatch in " + context_description + " stream: different number of columns:
"
+            + lhs.dumpStructure() + "
" + rhs.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
+
+    for (size_t i = 0; i < columns; ++i)
+    {
+        const auto & actual = lhs.getByPosition(i);
+        const auto & expected = rhs.getByPosition(i);
+
+        if constexpr (std::is_same_v<ReturnType, bool>)
+        {
+            if (!checkColumnStructure<ReturnType>(actual, expected, context_description, allow_remove_constants, ErrorCodes::LOGICAL_ERROR))
+                return false;
+        }
+        else
+            checkColumnStructure<ReturnType>(actual, expected, context_description, allow_remove_constants, ErrorCodes::LOGICAL_ERROR);
+    }
+
+    return ReturnType(true);
 }
 
 
@@ -57,24 +136,41 @@ void Block::insert(size_t position, ColumnWithTypeAndName elem)
         throw Exception("Position out of bound in Block::insert(), max position = "
         + toString(data.size()), ErrorCodes::POSITION_OUT_OF_BOUND);
 
+    if (elem.name.empty())
+        throw Exception("Column name in Block cannot be empty", ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+
     for (auto & name_pos : index_by_name)
         if (name_pos.second >= position)
             ++name_pos.second;
 
-    index_by_name.emplace(elem.name, position);
+    auto [it, inserted] = index_by_name.emplace(elem.name, position);
+    if (!inserted)
+        checkColumnStructure<void>(data[it->second], elem,
+            "(columns with identical name must have identical structure)", true, ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+
     data.emplace(data.begin() + position, std::move(elem));
 }
 
 
 void Block::insert(ColumnWithTypeAndName elem)
 {
-    index_by_name.emplace(elem.name, data.size());
+    if (elem.name.empty())
+        throw Exception("Column name in Block cannot be empty", ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+
+    auto [it, inserted] = index_by_name.emplace(elem.name, data.size());
+    if (!inserted)
+        checkColumnStructure<void>(data[it->second], elem,
+            "(columns with identical name must have identical structure)", true, ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+
     data.emplace_back(std::move(elem));
 }
 
 
 void Block::insertUnique(ColumnWithTypeAndName elem)
 {
+    if (elem.name.empty())
+        throw Exception("Column name in Block cannot be empty", ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+
     if (index_by_name.end() == index_by_name.find(elem.name))
         insert(std::move(elem));
 }
@@ -487,67 +583,6 @@ DataTypes Block::getDataTypes() const
 }
 
 
-template <typename ReturnType>
-static ReturnType checkBlockStructure(const Block & lhs, const Block & rhs, const std::string & context_description, bool allow_remove_constants)
-{
-    auto on_error = [](const std::string & message [[maybe_unused]], int code [[maybe_unused]])
-    {
-        if constexpr (std::is_same_v<ReturnType, void>)
-            throw Exception(message, code);
-        else
-            return false;
-    };
-
-    size_t columns = rhs.columns();
-    if (lhs.columns() != columns)
-        return on_error("Block structure mismatch in " + context_description + " stream: different number of columns:
"
-            + lhs.dumpStructure() + "
" + rhs.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
-
-    for (size_t i = 0; i < columns; ++i)
-    {
-        const auto & expected = rhs.getByPosition(i);
-        const auto & actual = lhs.getByPosition(i);
-
-        if (actual.name != expected.name)
-            return on_error("Block structure mismatch in " + context_description + " stream: different names of columns:
"
-                + lhs.dumpStructure() + "
" + rhs.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
-
-        if (!actual.type->equals(*expected.type))
-            return on_error("Block structure mismatch in " + context_description + " stream: different types:
"
-                + lhs.dumpStructure() + "
" + rhs.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
-
-        if (!actual.column || !expected.column)
-            continue;
-
-        const IColumn * actual_column = actual.column.get();
-
-        /// If we allow to remove constants, and expected column is not const, then unwrap actual constant column.
-        if (allow_remove_constants && !isColumnConst(*expected.column))
-        {
-            if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))
-                actual_column = &column_const->getDataColumn();
-        }
-
-        if (actual_column->getName() != expected.column->getName())
-            return on_error("Block structure mismatch in " + context_description + " stream: different columns:
"
-                + lhs.dumpStructure() + "
" + rhs.dumpStructure(), ErrorCodes::LOGICAL_ERROR);
-
-        if (isColumnConst(*actual.column) && isColumnConst(*expected.column))
-        {
-            Field actual_value = assert_cast<const ColumnConst &>(*actual.column).getField();
-            Field expected_value = assert_cast<const ColumnConst &>(*expected.column).getField();
-
-            if (actual_value != expected_value)
-                return on_error("Block structure mismatch in " + context_description + " stream: different values of constants, actual: "
-                    + applyVisitor(FieldVisitorToString(), actual_value) + ", expected: " + applyVisitor(FieldVisitorToString(), expected_value),
-                    ErrorCodes::LOGICAL_ERROR);
-        }
-    }
-
-    return ReturnType(true);
-}
-
-
 bool blocksHaveEqualStructure(const Block & lhs, const Block & rhs)
 {
     return checkBlockStructure<bool>(lhs, rhs, {}, false);
diff --git a/src/Functions/in.cpp b/src/Functions/in.cpp
index 7cd9f64004dd..db4194308fc8 100644
--- a/src/Functions/in.cpp
+++ b/src/Functions/in.cpp
@@ -102,7 +102,7 @@ class FunctionIn : public IFunction
             throw Exception("Second argument for function '" + getName() + "' must be Set; found " + column_set_ptr->getName(),
                 ErrorCodes::ILLEGAL_COLUMN);
 
-        DB::Block columns_of_key_columns;
+        ColumnsWithTypeAndName columns_of_key_columns;
 
         /// First argument may be a tuple or a single column.
         const ColumnWithTypeAndName & left_arg = arguments[0];
@@ -125,16 +125,16 @@ class FunctionIn : public IFunction
             const DataTypes & tuple_types = type_tuple->getElements();
             size_t tuple_size = tuple_columns.size();
             for (size_t i = 0; i < tuple_size; ++i)
-                columns_of_key_columns.insert({ tuple_columns[i], tuple_types[i], "" });
+                columns_of_key_columns.emplace_back(tuple_columns[i], tuple_types[i], "_" + toString(i));
         }
         else
-            columns_of_key_columns.insert(left_arg);
+            columns_of_key_columns.emplace_back(left_arg);
 
         /// Replace single LowCardinality column to it's dictionary if possible.
         ColumnPtr lc_indexes = nullptr;
-        if (columns_of_key_columns.columns() == 1)
+        if (columns_of_key_columns.size() == 1)
         {
-            auto & arg = columns_of_key_columns.safeGetByPosition(0);
+            auto & arg = columns_of_key_columns.at(0);
             const auto * col = arg.column.get();
             if (const auto * const_col = typeid_cast<const ColumnConst *>(col))
                 col = &const_col->getDataColumn();
diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index 61e484ff6f19..9a27043160f6 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -374,8 +374,8 @@ SetPtr makeExplicitSet(
 
     SetPtr set
         = std::make_shared<Set>(size_limits, create_ordered_set, context->getSettingsRef().transform_null_in);
-    set->setHeader(block.cloneEmpty());
-    set->insertFromBlock(block);
+    set->setHeader(block.cloneEmpty().getColumnsWithTypeAndName());
+    set->insertFromBlock(block.getColumnsWithTypeAndName());
     set->finishInsert();
 
     prepared_sets[set_key] = set;
diff --git a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
index f46cbdd24652..2b858512b988 100644
--- a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
+++ b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
@@ -80,9 +80,13 @@ void ExecuteScalarSubqueriesMatcher::visit(const ASTSubquery & subquery, ASTPtr
 
     Block scalar;
     if (data.getContext()->hasQueryContext() && data.getContext()->getQueryContext()->hasScalar(scalar_query_hash_str))
+    {
         scalar = data.getContext()->getQueryContext()->getScalar(scalar_query_hash_str);
+    }
     else if (data.scalars.count(scalar_query_hash_str))
+    {
         scalar = data.scalars[scalar_query_hash_str];
+    }
     else
     {
         auto subquery_context = Context::createCopy(data.getContext());
@@ -149,7 +153,8 @@ void ExecuteScalarSubqueriesMatcher::visit(const ASTSubquery & subquery, ASTPtr
                 throw Exception("Scalar subquery returned more than one row", ErrorCodes::INCORRECT_RESULT_OF_SCALAR_SUBQUERY);
 
             Block tmp_block;
-            while (tmp_block.rows() == 0 && executor.pull(tmp_block));
+            while (tmp_block.rows() == 0 && executor.pull(tmp_block))
+                ;
 
             if (tmp_block.rows() != 0)
                 throw Exception("Scalar subquery returned more than one row", ErrorCodes::INCORRECT_RESULT_OF_SCALAR_SUBQUERY);
@@ -173,10 +178,10 @@ void ExecuteScalarSubqueriesMatcher::visit(const ASTSubquery & subquery, ASTPtr
         }
         else
         {
-            ColumnWithTypeAndName ctn;
-            ctn.type = std::make_shared<DataTypeTuple>(block.getDataTypes());
-            ctn.column = ColumnTuple::create(block.getColumns());
-            scalar.insert(ctn);
+            scalar.insert({
+                ColumnTuple::create(block.getColumns()),
+                std::make_shared<DataTypeTuple>(block.getDataTypes()),
+                "tuple"});
         }
     }
 
diff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp
index ef5c1f8e48f8..1dd4f7628f8b 100644
--- a/src/Interpreters/ExpressionActions.cpp
+++ b/src/Interpreters/ExpressionActions.cpp
@@ -800,12 +800,15 @@ ExpressionActionsChain::JoinStep::JoinStep(
     : Step({})
     , analyzed_join(std::move(analyzed_join_))
     , join(std::move(join_))
-    , result_columns(std::move(required_columns_))
 {
-    for (const auto & column : result_columns)
+    for (const auto & column : required_columns_)
         required_columns.emplace_back(column.name, column.type);
 
-    analyzed_join->addJoinedColumnsAndCorrectTypes(result_columns);
+    NamesAndTypesList result_names_and_types = required_columns;
+    analyzed_join->addJoinedColumnsAndCorrectTypes(result_names_and_types);
+    for (const auto & [name, type] : result_names_and_types)
+        /// `column` is `nullptr` because we don't care on constness here, it may be changed in join
+        result_columns.emplace_back(nullptr, type, name);
 }
 
 void ExpressionActionsChain::JoinStep::finalize(const NameSet & required_output_)
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 77598e69c00a..c8a5ed6c56af 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -216,7 +216,7 @@ void ExpressionAnalyzer::analyzeAggregation()
         if (join)
         {
             getRootActionsNoMakeSet(analyzedJoin().leftKeysList(), true, temp_actions, false);
-            auto sample_columns = temp_actions->getResultColumns();
+            auto sample_columns = temp_actions->getNamesAndTypesList();
             analyzedJoin().addJoinedColumnsAndCorrectTypes(sample_columns);
             temp_actions = std::make_shared<ActionsDAG>(sample_columns);
         }
@@ -337,7 +337,7 @@ void ExpressionAnalyzer::tryMakeSetForIndexFromSubquery(const ASTPtr & subquery_
     PullingAsyncPipelineExecutor executor(io.pipeline);
 
     SetPtr set = std::make_shared<Set>(settings.size_limits_for_set, true, getContext()->getSettingsRef().transform_null_in);
-    set->setHeader(executor.getHeader());
+    set->setHeader(executor.getHeader().getColumnsWithTypeAndName());
 
     Block block;
     while (executor.pull(block))
@@ -346,7 +346,7 @@ void ExpressionAnalyzer::tryMakeSetForIndexFromSubquery(const ASTPtr & subquery_
             continue;
 
         /// If the limits have been exceeded, give up and let the default subquery processing actions take place.
-        if (!set->insertFromBlock(block))
+        if (!set->insertFromBlock(block.getColumnsWithTypeAndName()))
             return;
     }
 
@@ -1206,7 +1206,7 @@ void SelectQueryExpressionAnalyzer::appendSelect(ExpressionActionsChain & chain,
 }
 
 ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChain & chain, bool only_types, bool optimize_read_in_order,
-                                                  ManyExpressionActions & order_by_elements_actions)
+                                                           ManyExpressionActions & order_by_elements_actions)
 {
     const auto * select_query = getSelectQuery();
 
diff --git a/src/Interpreters/Set.cpp b/src/Interpreters/Set.cpp
index ff502b499cd7..5ab59ba3f079 100644
--- a/src/Interpreters/Set.cpp
+++ b/src/Interpreters/Set.cpp
@@ -99,14 +99,14 @@ void NO_INLINE Set::insertFromBlockImplCase(
 }
 
 
-void Set::setHeader(const Block & header)
+void Set::setHeader(const ColumnsWithTypeAndName & header)
 {
     std::unique_lock lock(rwlock);
 
     if (!data.empty())
         return;
 
-    keys_size = header.columns();
+    keys_size = header.size();
     ColumnRawPtrs key_columns;
     key_columns.reserve(keys_size);
     data_types.reserve(keys_size);
@@ -118,10 +118,10 @@ void Set::setHeader(const Block & header)
     /// Remember the columns we will work with
     for (size_t i = 0; i < keys_size; ++i)
     {
-        materialized_columns.emplace_back(header.safeGetByPosition(i).column->convertToFullColumnIfConst());
+        materialized_columns.emplace_back(header.at(i).column->convertToFullColumnIfConst());
         key_columns.emplace_back(materialized_columns.back().get());
-        data_types.emplace_back(header.safeGetByPosition(i).type);
-        set_elements_types.emplace_back(header.safeGetByPosition(i).type);
+        data_types.emplace_back(header.at(i).type);
+        set_elements_types.emplace_back(header.at(i).type);
 
         /// Convert low cardinality column to full.
         if (const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(data_types.back().get()))
@@ -161,7 +161,7 @@ void Set::setHeader(const Block & header)
 }
 
 
-bool Set::insertFromBlock(const Block & block)
+bool Set::insertFromBlock(const ColumnsWithTypeAndName & columns)
 {
     std::unique_lock lock(rwlock);
 
@@ -177,11 +177,11 @@ bool Set::insertFromBlock(const Block & block)
     /// Remember the columns we will work with
     for (size_t i = 0; i < keys_size; ++i)
     {
-        materialized_columns.emplace_back(block.safeGetByPosition(i).column->convertToFullColumnIfConst()->convertToFullColumnIfLowCardinality());
+        materialized_columns.emplace_back(columns.at(i).column->convertToFullColumnIfConst()->convertToFullColumnIfLowCardinality());
         key_columns.emplace_back(materialized_columns.back().get());
     }
 
-    size_t rows = block.rows();
+    size_t rows = columns.at(0).column->size();
 
     /// We will insert to the Set only keys, where all components are not NULL.
     ConstNullMapPtr null_map{};
@@ -192,7 +192,7 @@ bool Set::insertFromBlock(const Block & block)
     /// Filter to extract distinct values from the block.
     ColumnUInt8::MutablePtr filter;
     if (fill_set_elements)
-        filter = ColumnUInt8::create(block.rows());
+        filter = ColumnUInt8::create(rows);
 
     switch (data.type)
     {
@@ -224,16 +224,16 @@ bool Set::insertFromBlock(const Block & block)
 }
 
 
-ColumnPtr Set::execute(const Block & block, bool negative) const
+ColumnPtr Set::execute(const ColumnsWithTypeAndName & columns, bool negative) const
 {
-    size_t num_key_columns = block.columns();
+    size_t num_key_columns = columns.size();
 
     if (0 == num_key_columns)
         throw Exception("Logical error: no columns passed to Set::execute method.", ErrorCodes::LOGICAL_ERROR);
 
     auto res = ColumnUInt8::create();
     ColumnUInt8::Container & vec_res = res->getData();
-    vec_res.resize(block.safeGetByPosition(0).column->size());
+    vec_res.resize(columns.at(0).column->size());
 
     if (vec_res.empty())
         return res;
@@ -264,7 +264,7 @@ ColumnPtr Set::execute(const Block & block, bool negative) const
     {
         ColumnPtr result;
 
-        const auto & column_before_cast = block.safeGetByPosition(i);
+        const auto & column_before_cast = columns.at(i);
         ColumnWithTypeAndName column_to_cast
             = {column_before_cast.column->convertToFullColumnIfConst(), column_before_cast.type, column_before_cast.name};
 
@@ -428,7 +428,7 @@ MergeTreeSetIndex::MergeTreeSetIndex(const Columns & set_elements, std::vector<K
     SortDescription sort_description;
     for (size_t i = 0; i < tuple_size; ++i)
     {
-        block_to_sort.insert({ ordered_set[i], nullptr, "" });
+        block_to_sort.insert({ ordered_set[i], nullptr, "_" + toString(i) });
         sort_description.emplace_back(i, 1, 1);
     }
 
diff --git a/src/Interpreters/Set.h b/src/Interpreters/Set.h
index 9bf6630b8448..727a2c144a19 100644
--- a/src/Interpreters/Set.h
+++ b/src/Interpreters/Set.h
@@ -42,10 +42,10 @@ class Set
     /** Create a Set from stream.
       * Call setHeader, then call insertFromBlock for each block.
       */
-    void setHeader(const Block & header);
+    void setHeader(const ColumnsWithTypeAndName & header);
 
     /// Returns false, if some limit was exceeded and no need to insert more data.
-    bool insertFromBlock(const Block & block);
+    bool insertFromBlock(const ColumnsWithTypeAndName & columns);
     /// Call after all blocks were inserted. To get the information that set is already created.
     void finishInsert() { is_created = true; }
 
@@ -54,7 +54,7 @@ class Set
     /** For columns of 'block', check belonging of corresponding rows to the set.
       * Return UInt8 column with the result.
       */
-    ColumnPtr execute(const Block & block, bool negative) const;
+    ColumnPtr execute(const ColumnsWithTypeAndName & columns, bool negative) const;
 
     bool empty() const;
     size_t getTotalRowCount() const;
diff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp
index 20e8f6b18b4a..86c84d9c8c9c 100644
--- a/src/Interpreters/TableJoin.cpp
+++ b/src/Interpreters/TableJoin.cpp
@@ -231,20 +231,7 @@ void TableJoin::addJoinedColumn(const NameAndTypePair & joined_column)
 
 void TableJoin::addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability) const
 {
-    ColumnsWithTypeAndName columns;
-    for (auto & pair : names_and_types)
-        columns.emplace_back(nullptr, std::move(pair.type), std::move(pair.name));
-    names_and_types.clear();
-
-    addJoinedColumnsAndCorrectTypes(columns, correct_nullability);
-
-    for (auto & col : columns)
-        names_and_types.emplace_back(std::move(col.name), std::move(col.type));
-}
-
-void TableJoin::addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability) const
-{
-    for (auto & col : columns)
+    for (auto & col : names_and_types)
     {
         if (hasUsing())
         {
@@ -252,17 +239,12 @@ void TableJoin::addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns
                 col.type = it->second;
         }
         if (correct_nullability && leftBecomeNullable(col.type))
-        {
-            /// No need to nullify constants
-            bool is_column_const = col.column && isColumnConst(*col.column);
-            if (!is_column_const)
-                col.type = JoinCommon::convertTypeToNullable(col.type);
-        }
+            col.type = JoinCommon::convertTypeToNullable(col.type);
     }
 
     /// Types in columns_added_by_join already converted and set nullable if needed
     for (const auto & col : columns_added_by_join)
-        columns.emplace_back(nullptr, col.type, col.name);
+        names_and_types.emplace_back(col.name, col.type);
 }
 
 bool TableJoin::sameStrictnessAndKind(ASTTableJoin::Strictness strictness_, ASTTableJoin::Kind kind_) const
diff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h
index 4c8c16028f59..4fe9565666fd 100644
--- a/src/Interpreters/TableJoin.h
+++ b/src/Interpreters/TableJoin.h
@@ -191,7 +191,6 @@ class TableJoin
     void addJoinedColumn(const NameAndTypePair & joined_column);
 
     void addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability = true) const;
-    void addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability = true) const;
 
     /// Calculates common supertypes for corresponding join key columns.
     bool inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right);
diff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp
index e46f644e8364..c05118b7c6a3 100644
--- a/src/Interpreters/evaluateConstantExpression.cpp
+++ b/src/Interpreters/evaluateConstantExpression.cpp
@@ -18,6 +18,7 @@
 #include <Interpreters/FunctionNameNormalizer.h>
 #include <Interpreters/ReplaceQueryParameterVisitor.h>
 #include <Poco/Util/AbstractConfiguration.h>
+#include <unordered_map>
 
 namespace DB
 {
@@ -121,6 +122,7 @@ std::tuple<bool, ASTPtr> evaluateDatabaseNameForMergeEngine(const ASTPtr & node,
     return std::tuple{false, ast};
 }
 
+
 namespace
 {
     using Conjunction = ColumnsWithTypeAndName;
@@ -213,7 +215,7 @@ namespace
 
             Disjunction result;
 
-            auto add_dnf = [&](const auto &dnf)
+            auto add_dnf = [&](const auto & dnf)
             {
                 if (dnf.size() > limit)
                 {
@@ -338,6 +340,7 @@ std::optional<Blocks> evaluateExpressionOverConstantCondition(const ASTPtr & nod
 
     if (const auto * fn = node->as<ASTFunction>())
     {
+        std::unordered_map<std::string, bool> always_false_map;
         const auto dnf = analyzeFunction(fn, target_expr, limit);
 
         if (dnf.empty() || !limit)
@@ -368,7 +371,41 @@ std::optional<Blocks> evaluateExpressionOverConstantCondition(const ASTPtr & nod
 
         for (const auto & conjunct : dnf)
         {
-            Block block(conjunct);
+            Block block;
+
+            for (const auto & elem : conjunct)
+            {
+                if (!block.has(elem.name))
+                {
+                    block.insert(elem);
+                }
+                else
+                {
+                    /// Conjunction of condition on column equality to distinct values can never be satisfied.
+
+                    const ColumnWithTypeAndName & prev = block.getByName(elem.name);
+
+                    if (isColumnConst(*prev.column) && isColumnConst(*elem.column))
+                    {
+                        Field prev_value = assert_cast<const ColumnConst &>(*prev.column).getField();
+                        Field curr_value = assert_cast<const ColumnConst &>(*elem.column).getField();
+
+                        if (!always_false_map.count(elem.name))
+                        {
+                            always_false_map[elem.name] = prev_value != curr_value;
+                        }
+                        else
+                        {
+                            auto & always_false = always_false_map[elem.name];
+                            /// If at least one of conjunct is not always false, we should preserve this.
+                            if (always_false)
+                            {
+                                always_false = prev_value != curr_value;
+                            }
+                        }
+                    }
+                }
+            }
 
             // Block should contain all required columns from `target_expr`
             if (!has_required_columns(block))
@@ -393,6 +430,11 @@ std::optional<Blocks> evaluateExpressionOverConstantCondition(const ASTPtr & nod
                 return {};
             }
         }
+
+        bool any_always_false = std::any_of(always_false_map.begin(), always_false_map.end(), [](const auto & v) { return v.second; });
+        if (any_always_false)
+            return Blocks{};
+
     }
     else if (const auto * literal = node->as<ASTLiteral>())
     {
diff --git a/src/Processors/Transforms/CreatingSetsTransform.cpp b/src/Processors/Transforms/CreatingSetsTransform.cpp
index 6f69765ee238..d9b383030d31 100644
--- a/src/Processors/Transforms/CreatingSetsTransform.cpp
+++ b/src/Processors/Transforms/CreatingSetsTransform.cpp
@@ -84,7 +84,7 @@ void CreatingSetsTransform::init()
     is_initialized = true;
 
     if (subquery.set)
-        subquery.set->setHeader(getInputPort().getHeader());
+        subquery.set->setHeader(getInputPort().getHeader().getColumnsWithTypeAndName());
 
     watch.restart();
     startSubquery();
@@ -97,7 +97,7 @@ void CreatingSetsTransform::consume(Chunk chunk)
 
     if (!done_with_set)
     {
-        if (!subquery.set->insertFromBlock(block))
+        if (!subquery.set->insertFromBlock(block.getColumnsWithTypeAndName()))
             done_with_set = true;
     }
 
diff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h
index f8b16dec7be3..b6a26467a3fd 100644
--- a/src/Storages/StorageDistributed.h
+++ b/src/Storages/StorageDistributed.h
@@ -174,8 +174,9 @@ class StorageDistributed final : public shared_ptr_helper<StorageDistributed>, p
     /// - optimize_skip_unused_shards
     /// - force_optimize_skip_unused_shards
     ClusterPtr getOptimizedCluster(ContextPtr, const StorageMetadataPtr & metadata_snapshot, const ASTPtr & query_ptr) const;
-    ClusterPtr
-    skipUnusedShards(ClusterPtr cluster, const ASTPtr & query_ptr, const StorageMetadataPtr & metadata_snapshot, ContextPtr context) const;
+
+    ClusterPtr skipUnusedShards(
+        ClusterPtr cluster, const ASTPtr & query_ptr, const StorageMetadataPtr & metadata_snapshot, ContextPtr context) const;
 
     /// This method returns optimal query processing stage.
     ///
diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 243294351f33..ed203db1a354 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -435,11 +435,17 @@ Pipe StorageMerge::createSources(
     if (!pipe.empty())
     {
         if (concat_streams && pipe.numOutputPorts() > 1)
+        {
             // It's possible to have many tables read from merge, resize(1) might open too many files at the same time.
             // Using concat instead.
             pipe.addTransform(std::make_shared<ConcatProcessor>(pipe.getHeader(), pipe.numOutputPorts()));
+        }
+
+        /// Add virtual columns if we don't already have them.
+
+        Block pipe_header = pipe.getHeader();
 
-        if (has_database_virtual_column)
+        if (has_database_virtual_column && !pipe_header.has("_database"))
         {
             ColumnWithTypeAndName column;
             column.name = "_database";
@@ -457,7 +463,7 @@ Pipe StorageMerge::createSources(
             });
         }
 
-        if (has_table_virtual_column)
+        if (has_table_virtual_column && !pipe_header.has("_table"))
         {
             ColumnWithTypeAndName column;
             column.name = "_table";
diff --git a/src/Storages/StorageSet.cpp b/src/Storages/StorageSet.cpp
index 67fd89f5098d..c16b60af45fb 100644
--- a/src/Storages/StorageSet.cpp
+++ b/src/Storages/StorageSet.cpp
@@ -146,13 +146,13 @@ StorageSet::StorageSet(
 
     Block header = getInMemoryMetadataPtr()->getSampleBlock();
     header = header.sortColumns();
-    set->setHeader(header);
+    set->setHeader(header.getColumnsWithTypeAndName());
 
     restore();
 }
 
 
-void StorageSet::insertBlock(const Block & block) { set->insertFromBlock(block); }
+void StorageSet::insertBlock(const Block & block) { set->insertFromBlock(block.getColumnsWithTypeAndName()); }
 void StorageSet::finishInsert() { set->finishInsert(); }
 
 size_t StorageSet::getSize() const { return set->getTotalRowCount(); }
@@ -170,7 +170,7 @@ void StorageSet::truncate(const ASTPtr &, const StorageMetadataPtr & metadata_sn
 
     increment = 0;
     set = std::make_shared<Set>(SizeLimits(), false, true);
-    set->setHeader(header);
+    set->setHeader(header.getColumnsWithTypeAndName());
 }
 
 
diff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp
index d19aef47616a..cba10548852b 100644
--- a/src/Storages/System/StorageSystemZooKeeper.cpp
+++ b/src/Storages/System/StorageSystemZooKeeper.cpp
@@ -97,12 +97,12 @@ static bool extractPathImpl(const IAST & elem, Paths & res, ContextPtr context)
             auto stream = interpreter_subquery->execute().getInputStream();
             SizeLimits limites(context->getSettingsRef().max_rows_in_set, context->getSettingsRef().max_bytes_in_set, OverflowMode::THROW);
             Set set(limites, true, context->getSettingsRef().transform_null_in);
-            set.setHeader(stream->getHeader());
+            set.setHeader(stream->getHeader().getColumnsWithTypeAndName());
 
             stream->readPrefix();
             while (Block block = stream->read())
             {
-                set.insertFromBlock(block);
+                set.insertFromBlock(block.getColumnsWithTypeAndName());
             }
             set.finishInsert();
             stream->readSuffix();
