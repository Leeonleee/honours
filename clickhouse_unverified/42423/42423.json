{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42423,
  "instance_id": "ClickHouse__ClickHouse-42423",
  "issue_numbers": [
    "35836"
  ],
  "base_commit": "45dadd7c5be13f0253327a5078c82ada0723b971",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex 1a5c94a2e268..b0ef15226854 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -333,6 +333,7 @@ SelectPartsDecision MergeTreeDataMergerMutator::selectPartsToMerge(\n         SimpleMergeSelector::Settings merge_settings;\n         /// Override value from table settings\n         merge_settings.max_parts_to_merge_at_once = data_settings->max_parts_to_merge_at_once;\n+        merge_settings.min_age_to_force_merge = data_settings->min_age_to_force_merge_seconds;\n \n         if (aggressive)\n             merge_settings.base = 1;\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex a0db39a97f14..3fecb85f4846 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -62,6 +62,7 @@ struct Settings;\n     M(UInt64, merge_tree_clear_old_temporary_directories_interval_seconds, 60, \"The period of executing the clear old temporary directories operation in background.\", 0) \\\n     M(UInt64, merge_tree_clear_old_parts_interval_seconds, 1, \"The period of executing the clear old parts operation in background.\", 0) \\\n     M(UInt64, merge_tree_clear_old_broken_detached_parts_ttl_timeout_seconds, 1ULL * 3600 * 24 * 30, \"Remove old broken detached parts in the background if they remained intouched for a specified by this setting period of time.\", 0) \\\n+    M(UInt64, min_age_to_force_merge_seconds, 0, \"If all parts in a certain range are older than this value, range will be always eligible for merging. Set to 0 to disable.\", 0) \\\n     M(UInt64, merge_tree_enable_clear_old_broken_detached, false, \"Enable clearing old broken detached parts operation in background.\", 0) \\\n     M(Bool, remove_rolled_back_parts_immediately, 1, \"Setting for an incomplete experimental feature.\", 0) \\\n     \\\ndiff --git a/src/Storages/MergeTree/SimpleMergeSelector.cpp b/src/Storages/MergeTree/SimpleMergeSelector.cpp\nindex 3b71e2720c88..f9ed6aedc604 100644\n--- a/src/Storages/MergeTree/SimpleMergeSelector.cpp\n+++ b/src/Storages/MergeTree/SimpleMergeSelector.cpp\n@@ -102,6 +102,9 @@ bool allow(\n     double max_size_to_lower_base_log,\n     const SimpleMergeSelector::Settings & settings)\n {\n+    if (settings.min_age_to_force_merge && min_age >= settings.min_age_to_force_merge)\n+        return true;\n+\n //    std::cerr << \"sum_size: \" << sum_size << \"\\n\";\n \n     /// Map size to 0..1 using logarithmic scale\ndiff --git a/src/Storages/MergeTree/SimpleMergeSelector.h b/src/Storages/MergeTree/SimpleMergeSelector.h\nindex 11ffe8b672a3..c20eaa6e8de6 100644\n--- a/src/Storages/MergeTree/SimpleMergeSelector.h\n+++ b/src/Storages/MergeTree/SimpleMergeSelector.h\n@@ -141,6 +141,11 @@ class SimpleMergeSelector final : public IMergeSelector\n         double heuristic_to_align_parts_max_absolute_difference_in_powers_of_two = 0.5;\n         double heuristic_to_align_parts_max_score_adjustment = 0.75;\n \n+        /** If it's not 0, all part ranges that have min_age larger than min_age_to_force_merge\n+          * will be considered for merging\n+          */\n+        size_t min_age_to_force_merge = 0;\n+\n         /** Heuristic:\n           * From right side of range, remove all parts, that size is less than specified ratio of sum_size.\n           */\n",
  "test_patch": "diff --git a/tests/integration/test_merge_tree_optimize_old_parts/__init__.py b/tests/integration/test_merge_tree_optimize_old_parts/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_merge_tree_optimize_old_parts/configs/zookeeper_config.xml b/tests/integration/test_merge_tree_optimize_old_parts/configs/zookeeper_config.xml\nnew file mode 100644\nindex 000000000000..18412349228f\n--- /dev/null\n+++ b/tests/integration/test_merge_tree_optimize_old_parts/configs/zookeeper_config.xml\n@@ -0,0 +1,8 @@\n+<clickhouse>\n+    <zookeeper>\n+        <node index=\"1\">\n+            <host>zoo1</host>\n+            <port>2181</port>\n+        </node>\n+    </zookeeper>\n+</clickhouse>\ndiff --git a/tests/integration/test_merge_tree_optimize_old_parts/test.py b/tests/integration/test_merge_tree_optimize_old_parts/test.py\nnew file mode 100644\nindex 000000000000..7b386eba2c4e\n--- /dev/null\n+++ b/tests/integration/test_merge_tree_optimize_old_parts/test.py\n@@ -0,0 +1,88 @@\n+import pytest\n+import time\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster\n+from helpers.test_tools import TSV\n+\n+cluster = ClickHouseCluster(__file__)\n+node = cluster.add_instance(\n+    \"node\",\n+    main_configs=[\"configs/zookeeper_config.xml\"],\n+    with_zookeeper=True,\n+)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def get_part_number(table_name):\n+    return TSV(\n+        node.query(\n+            f\"SELECT count(*) FROM system.parts where table='{table_name}' and active=1\"\n+        )\n+    )\n+\n+\n+def check_expected_part_number(seconds, table_name, expected):\n+    ok = False\n+    for i in range(int(seconds) * 2):\n+        result = get_part_number(table_name)\n+        if result == expected:\n+            ok = True\n+            break\n+        else:\n+            time.sleep(1)\n+    assert ok\n+\n+\n+def test_without_force_merge_old_parts(start_cluster):\n+    node.query(\n+        \"CREATE TABLE test_without_merge (i Int64) ENGINE = MergeTree ORDER BY i;\"\n+    )\n+    node.query(\"INSERT INTO test_without_merge SELECT 1\")\n+    node.query(\"INSERT INTO test_without_merge SELECT 2\")\n+    node.query(\"INSERT INTO test_without_merge SELECT 3\")\n+\n+    expected = TSV(\"\"\"3\\n\"\"\")\n+    # verify that the parts don't get merged\n+    for i in range(10):\n+        if get_part_number(\"test_without_merge\") != expected:\n+            assert False\n+        time.sleep(1)\n+\n+    node.query(\"DROP TABLE test_without_merge;\")\n+\n+\n+def test_force_merge_old_parts(start_cluster):\n+    node.query(\n+        \"CREATE TABLE test_with_merge (i Int64) ENGINE = MergeTree ORDER BY i SETTINGS min_age_to_force_merge_seconds=5;\"\n+    )\n+    node.query(\"INSERT INTO test_with_merge SELECT 1\")\n+    node.query(\"INSERT INTO test_with_merge SELECT 2\")\n+    node.query(\"INSERT INTO test_with_merge SELECT 3\")\n+\n+    expected = TSV(\"\"\"1\\n\"\"\")\n+    check_expected_part_number(10, \"test_with_merge\", expected)\n+\n+    node.query(\"DROP TABLE test_with_merge;\")\n+\n+\n+def test_force_merge_old_parts_replicated_merge_tree(start_cluster):\n+    node.query(\n+        \"CREATE TABLE test_replicated (i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/testing/test', 'node') ORDER BY i SETTINGS min_age_to_force_merge_seconds=5;\"\n+    )\n+    node.query(\"INSERT INTO test_replicated SELECT 1\")\n+    node.query(\"INSERT INTO test_replicated SELECT 2\")\n+    node.query(\"INSERT INTO test_replicated SELECT 3\")\n+\n+    expected = TSV(\"\"\"1\\n\"\"\")\n+    check_expected_part_number(10, \"test_replicated\", expected)\n+\n+    node.query(\"DROP TABLE test_replicated;\")\n",
  "problem_statement": "Automatically optimize on special conditions \nClickhouse has special options \"do_not_merge_across_partitions_select_final\" for ReplaceMergeTree Engine, which allows make fast select on the \"optimized\" partitions. Unfortunate you have to run manually (crontab)  \"OPTIMIZE TABLE ... PARTITION ... FINAL\" . \r\n\r\nIt will be great to have some options which will tell Clickhouse to compact older partitions on some conditions:\r\n\r\ni.e.\r\n```\r\nCREATE TABLE select_final (t DateTime, x Int32, string String) ENGINE = ReplacingMergeTree() PARTITION BY toYYYYMMDD(t) ORDER BY (x, t)  SETTINGS optimize_partition_after = 3600\r\n```\r\nClickhouse will check if a partition is older than 3600 seconds and has multiple parts and in such condition will do automatically optimization (compaction) \r\n\r\nP.S. we just discussed with @alexey-milovidov about this options :-) \r\n\r\n\r\n\r\n\n",
  "hints_text": "The logic we use for this prioritizes:\r\n\r\n1. bytes of mergeable data (aggregating, collapsing tree)\r\n2. max modified time for the partition\r\n\r\nIf we wouldn't need to manage this, it would be great.",
  "created_at": "2022-10-18T09:33:38Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp",
    "src/Storages/MergeTree/MergeTreeSettings.h",
    "src/Storages/MergeTree/SimpleMergeSelector.cpp",
    "src/Storages/MergeTree/SimpleMergeSelector.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_merge_tree_optimize_old_parts/configs/zookeeper_config.xml",
    "b/tests/integration/test_merge_tree_optimize_old_parts/test.py"
  ]
}