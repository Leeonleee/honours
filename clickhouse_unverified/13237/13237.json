{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13237,
  "instance_id": "ClickHouse__ClickHouse-13237",
  "issue_numbers": [
    "3776"
  ],
  "base_commit": "d4266d9619a346487db55d67a07368996c80259b",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md\nindex 067644c30b2c..a625af145052 100644\n--- a/docs/en/sql-reference/functions/string-search-functions.md\n+++ b/docs/en/sql-reference/functions/string-search-functions.md\n@@ -21,15 +21,16 @@ For a case-insensitive search, use the function [positionCaseInsensitive](#posit\n **Syntax**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-Alias: `locate(haystack, needle)`.\n+Alias: `locate(haystack, needle[, start_pos])`.\n \n **Parameters**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Returned values**\n \n@@ -56,6 +57,18 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+``` sql\n+SELECT\n+    position('Hello, world!', 'o', 1),\n+    position('Hello, world!', 'o', 7)\n+```\n+\n+``` text\n+\u250c\u2500position('Hello, world!', 'o', 1)\u2500\u252c\u2500position('Hello, world!', 'o', 7)\u2500\u2510\n+\u2502                                 5 \u2502                                 9 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n The same phrase in Russian contains characters which can\u2019t be represented using a single byte. The function returns some unexpected result (use [positionUTF8](#positionutf8) function for multi-byte encoded text):\n \n Query:\n@@ -81,13 +94,14 @@ Works under the assumption that the string contains a set of bytes representing\n **Syntax**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **Parameters**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Returned values**\n \n@@ -123,13 +137,14 @@ For a case-insensitive search, use the function [positionCaseInsensitiveUTF8](#p\n **Syntax**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **Parameters**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Returned values**\n \n@@ -195,13 +210,14 @@ Works under the assumption that the string contains a set of bytes representing\n **Syntax**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **Parameters**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [String](../../sql-reference/syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Returned value**\n \ndiff --git a/docs/es/sql-reference/functions/string-search-functions.md b/docs/es/sql-reference/functions/string-search-functions.md\nindex 3236745b22cf..c448872a186f 100644\n--- a/docs/es/sql-reference/functions/string-search-functions.md\n+++ b/docs/es/sql-reference/functions/string-search-functions.md\n@@ -20,15 +20,16 @@ Para una b\u00fasqueda sin distinci\u00f3n de may\u00fasculas y min\u00fasculas, utilice la func\n **Sintaxis**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-Apodo: `locate(haystack, needle)`.\n+Apodo: `locate(haystack, needle[, start_pos])`.\n \n **Par\u00e1metros**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Cadena](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Cadena](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Valores devueltos**\n \n@@ -80,13 +81,14 @@ Funciona bajo el supuesto de que la cadena contiene un conjunto de bytes que rep\n **Sintaxis**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **Par\u00e1metros**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Cadena](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Cadena](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Valores devueltos**\n \n@@ -122,13 +124,14 @@ Para una b\u00fasqueda sin distinci\u00f3n de may\u00fasculas y min\u00fasculas, utilice la func\n **Sintaxis**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **Par\u00e1metros**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Cadena](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Cadena](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Valores devueltos**\n \n@@ -194,13 +197,14 @@ Funciona bajo el supuesto de que la cadena contiene un conjunto de bytes que rep\n **Sintaxis**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **Par\u00e1metros**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Cadena](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Cadena](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **Valor devuelto**\n \ndiff --git a/docs/fa/sql-reference/functions/string-search-functions.md b/docs/fa/sql-reference/functions/string-search-functions.md\nindex af68dee0afad..cce6f8f5a4e7 100644\n--- a/docs/fa/sql-reference/functions/string-search-functions.md\n+++ b/docs/fa/sql-reference/functions/string-search-functions.md\n@@ -21,15 +21,16 @@ toc_title: \"\\u0628\\u0631\\u0627\\u06CC \\u062C\\u0633\\u062A\\u062C\\u0648\\u06CC \\u0631\n **\u0646\u062d\u0648**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-\u0646\u0627\u0645 \u0645\u0633\u062a\u0639\u0627\u0631: `locate(haystack, needle)`.\n+\u0646\u0627\u0645 \u0645\u0633\u062a\u0639\u0627\u0631: `locate(haystack, needle[, start_pos])`.\n \n **\u067e\u0627\u0631\u0627\u0645\u062a\u0631\u0647\u0627**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0645\u0642\u0627\u062f\u06cc\u0631 \u0628\u0627\u0632\u06af\u0634\u062a\u06cc**\n \n@@ -81,13 +82,14 @@ SELECT position('\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!', '!')\n **\u0646\u062d\u0648**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **\u067e\u0627\u0631\u0627\u0645\u062a\u0631\u0647\u0627**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0645\u0642\u0627\u062f\u06cc\u0631 \u0628\u0627\u0632\u06af\u0634\u062a\u06cc**\n \n@@ -123,13 +125,14 @@ SELECT positionCaseInsensitive('Hello, world!', 'hello')\n **\u0646\u062d\u0648**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **\u067e\u0627\u0631\u0627\u0645\u062a\u0631\u0647\u0627**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0645\u0642\u0627\u062f\u06cc\u0631 \u0628\u0627\u0632\u06af\u0634\u062a\u06cc**\n \n@@ -195,13 +198,14 @@ SELECT positionUTF8('Salut, e\u0301tudiante!', '!')\n **\u0646\u062d\u0648**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **\u067e\u0627\u0631\u0627\u0645\u062a\u0631\u0647\u0627**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u0631\u0634\u062a\u0647](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0645\u0642\u062f\u0627\u0631 \u0628\u0627\u0632\u06af\u0634\u062a\u06cc**\n \ndiff --git a/docs/ja/sql-reference/functions/string-search-functions.md b/docs/ja/sql-reference/functions/string-search-functions.md\nindex 00f68c061dd5..e5858ba49418 100644\n--- a/docs/ja/sql-reference/functions/string-search-functions.md\n+++ b/docs/ja/sql-reference/functions/string-search-functions.md\n@@ -20,15 +20,16 @@ toc_title: \"\\u6587\\u5B57\\u5217\\u3092\\u691C\\u7D22\\u3059\\u308B\\u5834\\u5408\"\n **\u69cb\u6587**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-\u5225\u540d: `locate(haystack, needle)`.\n+\u5225\u540d: `locate(haystack, needle[, start_pos])`.\n \n **\u30d1\u30e9\u30e1\u30fc\u30bf**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u623b\u308a\u5024**\n \n@@ -80,13 +81,14 @@ SELECT position('\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!', '!')\n **\u69cb\u6587**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **\u30d1\u30e9\u30e1\u30fc\u30bf**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u623b\u308a\u5024**\n \n@@ -122,13 +124,14 @@ SELECT positionCaseInsensitive('Hello, world!', 'hello')\n **\u69cb\u6587**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **\u30d1\u30e9\u30e1\u30fc\u30bf**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u623b\u308a\u5024**\n \n@@ -194,13 +197,14 @@ SELECT positionUTF8('Salut, e\u0301tudiante!', '!')\n **\u69cb\u6587**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **\u30d1\u30e9\u30e1\u30fc\u30bf**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [\u6587\u5b57\u5217](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u623b\u308a\u5024**\n \ndiff --git a/docs/ru/sql-reference/functions/string-search-functions.md b/docs/ru/sql-reference/functions/string-search-functions.md\nindex b363211d6d01..de713031046b 100644\n--- a/docs/ru/sql-reference/functions/string-search-functions.md\n+++ b/docs/ru/sql-reference/functions/string-search-functions.md\n@@ -15,15 +15,16 @@\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-\u0410\u043b\u0438\u0430\u0441: `locate(haystack, needle)`.\n+\u0410\u043b\u0438\u0430\u0441: `locate(haystack, needle[, start_pos])`.\n \n **\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n \n -   `haystack` \u2014 \u0441\u0442\u0440\u043e\u043a\u0430, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0439\u0442\u0438. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n \n@@ -75,13 +76,14 @@ SELECT position('\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!', '!')\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n \n -   `haystack` \u2014 \u0441\u0442\u0440\u043e\u043a\u0430, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0439\u0442\u0438. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n \n@@ -117,13 +119,14 @@ SELECT positionCaseInsensitive('Hello, world!', 'hello')\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n \n -   `haystack` \u2014 \u0441\u0442\u0440\u043e\u043a\u0430, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0439\u0442\u0438. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n \n@@ -189,13 +192,14 @@ SELECT positionUTF8('Salut, e\u0301tudiante!', '!')\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n \n -   `haystack` \u2014 \u0441\u0442\u0440\u043e\u043a\u0430, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043d\u0430\u0439\u0442\u0438. [\u0421\u0442\u0440\u043e\u043a\u0430](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435, \u0441 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n \ndiff --git a/docs/tr/sql-reference/functions/string-search-functions.md b/docs/tr/sql-reference/functions/string-search-functions.md\nindex be30510ef2aa..b80df910972b 100644\n--- a/docs/tr/sql-reference/functions/string-search-functions.md\n+++ b/docs/tr/sql-reference/functions/string-search-functions.md\n@@ -20,15 +20,16 @@ B\u00fcy\u00fck / k\u00fc\u00e7\u00fck harf duyars\u0131z arama i\u00e7in i\u015flevi kullan\u0131n [positionCase\u0130n\n **S\u00f6zdizimi**\n \n ``` sql\n-position(haystack, needle)\n+position(haystack, needle[, start_pos])\n ```\n \n-Takma ad: `locate(haystack, needle)`.\n+Takma ad: `locate(haystack, needle[, start_pos])`.\n \n **Parametre**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Dize](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Dize](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **D\u00f6nd\u00fcr\u00fclen de\u011ferler**\n \n@@ -80,13 +81,14 @@ Dize, tek baytl\u0131k kodlanm\u0131\u015f bir metni temsil eden bir bayt k\u00fcmesi i\u00e7erdi\u011fi\n **S\u00f6zdizimi**\n \n ``` sql\n-positionCaseInsensitive(haystack, needle)\n+positionCaseInsensitive(haystack, needle[, start_pos])\n ```\n \n **Parametre**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Dize](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Dize](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **D\u00f6nd\u00fcr\u00fclen de\u011ferler**\n \n@@ -122,13 +124,14 @@ B\u00fcy\u00fck / k\u00fc\u00e7\u00fck harf duyars\u0131z arama i\u00e7in i\u015flevi kullan\u0131n [positionCase\u0130n\n **S\u00f6zdizimi**\n \n ``` sql\n-positionUTF8(haystack, needle)\n+positionUTF8(haystack, needle[, start_pos])\n ```\n \n **Parametre**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Dize](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Dize](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **D\u00f6nd\u00fcr\u00fclen de\u011ferler**\n \n@@ -194,13 +197,14 @@ Dizenin UTF-8 kodlanm\u0131\u015f bir metni temsil eden bir bayt k\u00fcmesi i\u00e7erdi\u011fi vars\n **S\u00f6zdizimi**\n \n ``` sql\n-positionCaseInsensitiveUTF8(haystack, needle)\n+positionCaseInsensitiveUTF8(haystack, needle[, start_pos])\n ```\n \n **Parametre**\n \n -   `haystack` \u2014 string, in which substring will to be searched. [Dize](../syntax.md#syntax-string-literal).\n -   `needle` \u2014 substring to be searched. [Dize](../syntax.md#syntax-string-literal).\n+-   `start_pos` \u2013 Optional parameter, position of the first character in the string to start search. [UInt](../../sql-reference/data-types/int-uint.md)\n \n **D\u00f6nd\u00fcr\u00fclen de\u011fer**\n \ndiff --git a/src/Functions/FunctionsStringSearch.h b/src/Functions/FunctionsStringSearch.h\nindex b3f016a55b13..b890c9e428de 100644\n--- a/src/Functions/FunctionsStringSearch.h\n+++ b/src/Functions/FunctionsStringSearch.h\n@@ -10,7 +10,7 @@\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunctionImpl.h>\n #include <Interpreters/Context.h>\n-\n+#include <IO/WriteHelpers.h>\n \n namespace DB\n {\n@@ -38,8 +38,9 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n template <typename Impl, typename Name>\n@@ -51,19 +52,33 @@ class FunctionsStringSearch : public IFunction\n \n     String getName() const override { return name; }\n \n-    size_t getNumberOfArguments() const override { return 2; }\n+    bool isVariadic() const override { return Impl::supports_start_pos; }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        if (Impl::supports_start_pos)\n+            return 0;\n+        return 2;\n+    }\n \n     bool useDefaultImplementationForConstants() const override { return Impl::use_default_implementation_for_constants; }\n \n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n     {\n-        return Impl::use_default_implementation_for_constants\n-            ? ColumnNumbers{1, 2}\n-            : ColumnNumbers{};\n+        if (!Impl::use_default_implementation_for_constants)\n+            return ColumnNumbers{};\n+        if (!Impl::supports_start_pos)\n+            return ColumnNumbers{1, 2};\n+        return ColumnNumbers{1, 2, 3};\n     }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n+        if (arguments.size() < 2 || 3 < arguments.size())\n+            throw Exception(\"Number of arguments for function \" + String(Name::name) + \" doesn't match: passed \"\n+                + toString(arguments.size()) + \", should be 2 or 3.\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n         if (!isStringOrFixedString(arguments[0]))\n             throw Exception(\n                 \"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n@@ -72,6 +87,13 @@ class FunctionsStringSearch : public IFunction\n             throw Exception(\n                 \"Illegal type \" + arguments[1]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n+        if (arguments.size() >= 3)\n+        {\n+            if (!isUnsignedInteger(arguments[2]))\n+                throw Exception(\n+                    \"Illegal type \" + arguments[2]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+\n         return std::make_shared<DataTypeNumber<typename Impl::ResultType>>();\n     }\n \n@@ -82,17 +104,34 @@ class FunctionsStringSearch : public IFunction\n         const ColumnPtr & column_haystack = block.getByPosition(arguments[0]).column;\n         const ColumnPtr & column_needle = block.getByPosition(arguments[1]).column;\n \n+        ColumnPtr column_start_pos = nullptr;\n+        if (arguments.size() >= 3)\n+            column_start_pos = block.getByPosition(arguments[2]).column;\n+\n         const ColumnConst * col_haystack_const = typeid_cast<const ColumnConst *>(&*column_haystack);\n         const ColumnConst * col_needle_const = typeid_cast<const ColumnConst *>(&*column_needle);\n \n         if constexpr (!Impl::use_default_implementation_for_constants)\n         {\n+            bool is_col_start_pos_const = column_start_pos == nullptr || isColumnConst(*column_start_pos);\n             if (col_haystack_const && col_needle_const)\n             {\n-                ResultType res{};\n-                Impl::constantConstant(col_haystack_const->getValue<String>(), col_needle_const->getValue<String>(), res);\n-                block.getByPosition(result).column\n-                    = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(res));\n+                auto col_res = ColumnVector<ResultType>::create();\n+                typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();\n+                vec_res.resize(is_col_start_pos_const ? 1 : column_start_pos->size());\n+\n+                Impl::constantConstant(\n+                    col_haystack_const->getValue<String>(),\n+                    col_needle_const->getValue<String>(),\n+                    column_start_pos,\n+                    vec_res);\n+\n+                if (is_col_start_pos_const)\n+                    block.getByPosition(result).column\n+                        = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(vec_res[0]));\n+                else\n+                    block.getByPosition(result).column = std::move(col_res);\n+\n                 return;\n             }\n         }\n@@ -112,16 +151,28 @@ class FunctionsStringSearch : public IFunction\n                 col_haystack_vector->getOffsets(),\n                 col_needle_vector->getChars(),\n                 col_needle_vector->getOffsets(),\n+                column_start_pos,\n                 vec_res);\n         else if (col_haystack_vector && col_needle_const)\n             Impl::vectorConstant(\n-                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(), col_needle_const->getValue<String>(), vec_res);\n+                col_haystack_vector->getChars(),\n+                col_haystack_vector->getOffsets(),\n+                col_needle_const->getValue<String>(),\n+                column_start_pos,\n+                vec_res);\n         else if (col_haystack_vector_fixed && col_needle_const)\n             Impl::vectorFixedConstant(\n-                col_haystack_vector_fixed->getChars(), col_haystack_vector_fixed->getN(), col_needle_const->getValue<String>(), vec_res);\n+                col_haystack_vector_fixed->getChars(),\n+                col_haystack_vector_fixed->getN(),\n+                col_needle_const->getValue<String>(),\n+                vec_res);\n         else if (col_haystack_const && col_needle_vector)\n             Impl::constantVector(\n-                col_haystack_const->getValue<String>(), col_needle_vector->getChars(), col_needle_vector->getOffsets(), vec_res);\n+                col_haystack_const->getValue<String>(),\n+                col_needle_vector->getChars(),\n+                col_needle_vector->getOffsets(),\n+                column_start_pos,\n+                vec_res);\n         else\n             throw Exception(\n                 \"Illegal columns \" + block.getByPosition(arguments[0]).column->getName() + \" and \"\ndiff --git a/src/Functions/FunctionsVisitParam.h b/src/Functions/FunctionsVisitParam.h\nindex 02e55df6691b..8ba7d4238994 100644\n--- a/src/Functions/FunctionsVisitParam.h\n+++ b/src/Functions/FunctionsVisitParam.h\n@@ -36,6 +36,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n \n@@ -79,12 +80,19 @@ struct ExtractParamImpl\n     using ResultType = typename ParamExtractor::ResultType;\n \n     static constexpr bool use_default_implementation_for_constants = true;\n+    static constexpr bool supports_start_pos = false;\n \n     /// It is assumed that `res` is the correct size and initialized with zeros.\n-    static void vectorConstant(const ColumnString::Chars & data, const ColumnString::Offsets & offsets,\n+    static void vectorConstant(\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n         std::string needle,\n+        const ColumnPtr & start_pos,\n         PaddedPODArray<ResultType> & res)\n     {\n+        if (start_pos != nullptr)\n+            throw Exception(\"Functions 'visitParamHas' and 'visitParamExtract*' doesn't support start_pos argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n         /// We are looking for a parameter simply as a substring of the form \"name\"\n         needle = \"\\\"\" + needle + \"\\\":\";\n \ndiff --git a/src/Functions/HasTokenImpl.h b/src/Functions/HasTokenImpl.h\nindex b8f250be69f7..044c50b67429 100644\n--- a/src/Functions/HasTokenImpl.h\n+++ b/src/Functions/HasTokenImpl.h\n@@ -9,6 +9,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n /** Token search the string, means that needle must be surrounded by some separator chars, like whitespace or puctuation.\n@@ -19,10 +20,18 @@ struct HasTokenImpl\n     using ResultType = UInt8;\n \n     static constexpr bool use_default_implementation_for_constants = true;\n+    static constexpr bool supports_start_pos = false;\n \n     static void vectorConstant(\n-        const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & pattern, PaddedPODArray<UInt8> & res)\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        const std::string & pattern,\n+        const ColumnPtr & start_pos,\n+        PaddedPODArray<UInt8> & res)\n     {\n+        if (start_pos != nullptr)\n+            throw Exception(\"Function 'hasToken' does not support start_pos argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n         if (offsets.empty())\n             return;\n \ndiff --git a/src/Functions/MatchImpl.h b/src/Functions/MatchImpl.h\nindex 70c8419fcc9e..54ceb05645d2 100644\n--- a/src/Functions/MatchImpl.h\n+++ b/src/Functions/MatchImpl.h\n@@ -25,6 +25,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n \n@@ -76,6 +77,7 @@ template <bool like, bool revert = false, bool case_insensitive = false>\n struct MatchImpl\n {\n     static constexpr bool use_default_implementation_for_constants = true;\n+    static constexpr bool supports_start_pos = false;\n \n     using ResultType = UInt8;\n \n@@ -84,8 +86,15 @@ struct MatchImpl\n           VolnitskyUTF8>;\n \n     static void vectorConstant(\n-        const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & pattern, PaddedPODArray<UInt8> & res)\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        const std::string & pattern,\n+        const ColumnPtr & start_pos,\n+        PaddedPODArray<UInt8> & res)\n     {\n+        if (start_pos != nullptr)\n+            throw Exception(\"Functions 'like' and 'match' don't support start_pos argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n         if (offsets.empty())\n             return;\n \n@@ -238,7 +247,8 @@ struct MatchImpl\n \n     /// Very carefully crafted copy-paste.\n     static void vectorFixedConstant(\n-        const ColumnString::Chars & data, size_t n, const std::string & pattern, PaddedPODArray<UInt8> & res)\n+        const ColumnString::Chars & data, size_t n, const std::string & pattern,\n+        PaddedPODArray<UInt8> & res)\n     {\n         if (data.empty())\n             return;\ndiff --git a/src/Functions/MultiMatchAnyImpl.h b/src/Functions/MultiMatchAnyImpl.h\nindex 78c314fed693..c8d0ea6c87f9 100644\n--- a/src/Functions/MultiMatchAnyImpl.h\n+++ b/src/Functions/MultiMatchAnyImpl.h\n@@ -120,7 +120,7 @@ struct MultiMatchAnyImpl\n         memset(accum.data(), 0, accum.size());\n         for (size_t j = 0; j < needles.size(); ++j)\n         {\n-            MatchImpl<false, false>::vectorConstant(haystack_data, haystack_offsets, needles[j].toString(), accum);\n+            MatchImpl<false, false>::vectorConstant(haystack_data, haystack_offsets, needles[j].toString(), nullptr, accum);\n             for (size_t i = 0; i < res.size(); ++i)\n             {\n                 if constexpr (FindAny)\ndiff --git a/src/Functions/PositionImpl.h b/src/Functions/PositionImpl.h\nindex bc0b2c7bcfbd..f5d8bd84c3f4 100644\n--- a/src/Functions/PositionImpl.h\n+++ b/src/Functions/PositionImpl.h\n@@ -1,11 +1,11 @@\n #include \"FunctionsStringSearch.h\"\n \n+#include <algorithm>\n #include <string>\n #include <vector>\n #include <Poco/UTF8String.h>\n #include <Common/Volnitsky.h>\n \n-\n namespace DB\n {\n \n@@ -42,6 +42,11 @@ struct PositionCaseSensitiveASCII\n         return MultiSearcherInBigHaystack(needles);\n     }\n \n+    static const char * advancePos(const char * pos, const char * end, size_t n)\n+    {\n+        return std::min(pos + n, end);\n+    }\n+\n     /// Number of code points between 'begin' and 'end' (this has different behaviour for ASCII and UTF-8).\n     static size_t countChars(const char * begin, const char * end) { return end - begin; }\n \n@@ -73,6 +78,11 @@ struct PositionCaseInsensitiveASCII\n         return MultiSearcherInBigHaystack(needles);\n     }\n \n+    static const char * advancePos(const char * pos, const char * end, size_t n)\n+    {\n+        return std::min(pos + n, end);\n+    }\n+\n     static size_t countChars(const char * begin, const char * end) { return end - begin; }\n \n     static void toLowerIfNeed(std::string & s) { std::transform(std::begin(s), std::end(s), std::begin(s), tolower); }\n@@ -100,6 +110,20 @@ struct PositionCaseSensitiveUTF8\n         return MultiSearcherInBigHaystack(needles);\n     }\n \n+    static const char * advancePos(const char * pos, const char * end, size_t n)\n+    {\n+        for (auto it = pos; it != end; ++it)\n+        {\n+            if (!UTF8::isContinuationOctet(static_cast<UInt8>(*it)))\n+            {\n+                if (n == 0)\n+                    return it;\n+                n--;\n+            }\n+        }\n+        return end;\n+    }\n+\n     static size_t countChars(const char * begin, const char * end)\n     {\n         size_t res = 0;\n@@ -134,13 +158,16 @@ struct PositionCaseInsensitiveUTF8\n         return MultiSearcherInBigHaystack(needles);\n     }\n \n+    static const char * advancePos(const char * pos, const char * end, size_t n)\n+    {\n+        // reuse implementation that doesn't depend on case\n+        return PositionCaseSensitiveUTF8::advancePos(pos, end, n);\n+    }\n+\n     static size_t countChars(const char * begin, const char * end)\n     {\n-        size_t res = 0;\n-        for (auto it = begin; it != end; ++it)\n-            if (!UTF8::isContinuationOctet(static_cast<UInt8>(*it)))\n-                ++res;\n-        return res;\n+        // reuse implementation that doesn't depend on case\n+        return PositionCaseSensitiveUTF8::countChars(begin, end);\n     }\n \n     static void toLowerIfNeed(std::string & s) { Poco::UTF8::toLowerInPlace(s); }\n@@ -151,12 +178,17 @@ template <typename Impl>\n struct PositionImpl\n {\n     static constexpr bool use_default_implementation_for_constants = false;\n+    static constexpr bool supports_start_pos = true;\n \n     using ResultType = UInt64;\n \n     /// Find one substring in many strings.\n     static void vectorConstant(\n-        const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & needle, PaddedPODArray<UInt64> & res)\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        const std::string & needle,\n+        const ColumnPtr & start_pos,\n+        PaddedPODArray<UInt64> & res)\n     {\n         const UInt8 * begin = data.data();\n         const UInt8 * pos = begin;\n@@ -176,13 +208,26 @@ struct PositionImpl\n                 res[i] = 0;\n                 ++i;\n             }\n+            auto start = start_pos != nullptr ? start_pos->getUInt(i) : 0;\n \n             /// We check that the entry does not pass through the boundaries of strings.\n             if (pos + needle.size() < begin + offsets[i])\n-                res[i] = 1 + Impl::countChars(reinterpret_cast<const char *>(begin + offsets[i - 1]), reinterpret_cast<const char *>(pos));\n+            {\n+                auto res_pos = 1 + Impl::countChars(reinterpret_cast<const char *>(begin + offsets[i - 1]), reinterpret_cast<const char *>(pos));\n+                if (res_pos < start)\n+                {\n+                    pos = reinterpret_cast<const UInt8 *>(Impl::advancePos(\n+                        reinterpret_cast<const char *>(pos),\n+                        reinterpret_cast<const char *>(begin + offsets[i]),\n+                        start - res_pos));\n+                    continue;\n+                }\n+                res[i] = res_pos;\n+            }\n             else\n+            {\n                 res[i] = 0;\n-\n+            }\n             pos = begin + offsets[i];\n             ++i;\n         }\n@@ -192,24 +237,68 @@ struct PositionImpl\n     }\n \n     /// Search for substring in string.\n-    static void constantConstant(std::string data, std::string needle, UInt64 & res)\n+    static void constantConstantScalar(\n+        std::string data,\n+        std::string needle,\n+        UInt64 start_pos,\n+        UInt64 & res)\n     {\n-        Impl::toLowerIfNeed(data);\n-        Impl::toLowerIfNeed(needle);\n+        auto start = std::max(start_pos, UInt64(1));\n+\n+        if (needle.size() == 0)\n+        {\n+            size_t haystack_size = Impl::countChars(data.data(), data.data() + data.size());\n+            res = start <= haystack_size + 1 ? start : 0;\n+            return;\n+        }\n \n-        res = data.find(needle);\n+        size_t start_byte = Impl::advancePos(data.data(), data.data() + data.size(), start - 1) - data.data();\n+        res = data.find(needle, start_byte);\n         if (res == std::string::npos)\n             res = 0;\n         else\n             res = 1 + Impl::countChars(data.data(), data.data() + res);\n     }\n \n+    /// Search for substring in string starting from different positions.\n+    static void constantConstant(\n+        std::string data,\n+        std::string needle,\n+        const ColumnPtr & start_pos,\n+        PaddedPODArray<UInt64> & res)\n+    {\n+        Impl::toLowerIfNeed(data);\n+        Impl::toLowerIfNeed(needle);\n+\n+        if (start_pos == nullptr)\n+        {\n+            constantConstantScalar(data, needle, 0, res[0]);\n+            return;\n+        }\n+\n+        size_t haystack_size = Impl::countChars(data.data(), data.data() + data.size());\n+\n+        size_t size = start_pos != nullptr ? start_pos->size() : 0;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            auto start = start_pos->getUInt(i);\n+\n+            if (start > haystack_size + 1)\n+            {\n+                res[i] = 0;\n+                continue;\n+            }\n+            constantConstantScalar(data, needle, start, res[i]);\n+        }\n+    }\n+\n     /// Search each time for a different single substring inside each time different string.\n     static void vectorVector(\n         const ColumnString::Chars & haystack_data,\n         const ColumnString::Offsets & haystack_offsets,\n         const ColumnString::Chars & needle_data,\n         const ColumnString::Offsets & needle_offsets,\n+        const ColumnPtr & start_pos,\n         PaddedPODArray<UInt64> & res)\n     {\n         ColumnString::Offset prev_haystack_offset = 0;\n@@ -222,10 +311,16 @@ struct PositionImpl\n             size_t needle_size = needle_offsets[i] - prev_needle_offset - 1;\n             size_t haystack_size = haystack_offsets[i] - prev_haystack_offset - 1;\n \n-            if (0 == needle_size)\n+            auto start = start_pos != nullptr ? std::max(start_pos->getUInt(i), UInt64(1)) : UInt64(1);\n+\n+            if (start > haystack_size + 1)\n             {\n-                /// An empty string is always at the very beginning of `haystack`.\n-                res[i] = 1;\n+                res[i] = 0;\n+            }\n+            else if (0 == needle_size)\n+            {\n+                /// An empty string is always at any position in `haystack`.\n+                res[i] = start;\n             }\n             else\n             {\n@@ -234,8 +329,12 @@ struct PositionImpl\n                     reinterpret_cast<const char *>(&needle_data[prev_needle_offset]),\n                     needle_offsets[i] - prev_needle_offset - 1); /// zero byte at the end\n \n+                const char * beg = Impl::advancePos(\n+                    reinterpret_cast<const char *>(&haystack_data[prev_haystack_offset]),\n+                    reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i] - 1]),\n+                    start - 1);\n                 /// searcher returns a pointer to the found substring or to the end of `haystack`.\n-                size_t pos = searcher.search(&haystack_data[prev_haystack_offset], &haystack_data[haystack_offsets[i] - 1])\n+                size_t pos = searcher.search(reinterpret_cast<const UInt8 *>(beg), &haystack_data[haystack_offsets[i] - 1])\n                     - &haystack_data[prev_haystack_offset];\n \n                 if (pos != haystack_size)\n@@ -259,9 +358,10 @@ struct PositionImpl\n         const String & haystack,\n         const ColumnString::Chars & needle_data,\n         const ColumnString::Offsets & needle_offsets,\n+        const ColumnPtr & start_pos,\n         PaddedPODArray<UInt64> & res)\n     {\n-        // NOTE You could use haystack indexing. But this is a rare case.\n+        /// NOTE You could use haystack indexing. But this is a rare case.\n \n         ColumnString::Offset prev_needle_offset = 0;\n \n@@ -271,17 +371,24 @@ struct PositionImpl\n         {\n             size_t needle_size = needle_offsets[i] - prev_needle_offset - 1;\n \n-            if (0 == needle_size)\n+            auto start = start_pos != nullptr ? std::max(start_pos->getUInt(i), UInt64(1)) : UInt64(1);\n+\n+            if (start > haystack.size() + 1)\n+            {\n+                res[i] = 0;\n+            }\n+            else if (0 == needle_size)\n             {\n-                res[i] = 1;\n+                res[i] = start;\n             }\n             else\n             {\n                 typename Impl::SearcherInSmallHaystack searcher = Impl::createSearcherInSmallHaystack(\n                     reinterpret_cast<const char *>(&needle_data[prev_needle_offset]), needle_offsets[i] - prev_needle_offset - 1);\n \n+                const char * beg = Impl::advancePos(haystack.data(), haystack.data() + haystack.size(), start - 1);\n                 size_t pos = searcher.search(\n-                                 reinterpret_cast<const UInt8 *>(haystack.data()),\n+                                reinterpret_cast<const UInt8 *>(beg),\n                                  reinterpret_cast<const UInt8 *>(haystack.data()) + haystack.size())\n                     - reinterpret_cast<const UInt8 *>(haystack.data());\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00233_position_function_family.reference b/tests/queries/0_stateless/00233_position_function_family.reference\nindex 85cc0a8ff2ba..1523094261f9 100644\n--- a/tests/queries/0_stateless/00233_position_function_family.reference\n+++ b/tests/queries/0_stateless/00233_position_function_family.reference\n@@ -23441,3 +23441,358 @@\n 1\n 1\n 1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/00233_position_function_family.sql b/tests/queries/0_stateless/00233_position_function_family.sql\nindex 1bfd17310e1c..8e443f5cd101 100644\n--- a/tests/queries/0_stateless/00233_position_function_family.sql\n+++ b/tests/queries/0_stateless/00233_position_function_family.sql\n@@ -6,6 +6,23 @@ select 1 = position('abc', 'abc');\n select 2 = position('abc', 'bc');\n select 3 = position('abc', 'c');\n \n+select 1 = position('', '', 0);\n+select 1 = position('', '', 1);\n+select 0 = position('', '', 2);\n+select 1 = position('a', '', 1);\n+select 2 = position('a', '', 2);\n+select 0 = position('a', '', 3);\n+\n+select [1, 1, 2, 3, 4, 5, 0, 0, 0, 0] = groupArray(position('aaaa', '', number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 5, 0, 0, 0, 0] = groupArray(position(materialize('aaaa'), '', number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 5, 0, 0, 0, 0] = groupArray(position('aaaa', materialize(''), number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 5, 0, 0, 0, 0] = groupArray(position(materialize('aaaa'), materialize(''), number)) from numbers(10);\n+\n+select [1, 1, 2, 3, 4, 0, 0, 0, 0, 0] = groupArray(position('aaaa', 'a', number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 0, 0, 0, 0, 0] = groupArray(position(materialize('aaaa'), 'a', number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 0, 0, 0, 0, 0] = groupArray(position('aaaa', materialize('a'), number)) from numbers(10);\n+select [1, 1, 2, 3, 4, 0, 0, 0, 0, 0] = groupArray(position(materialize('aaaa'), materialize('a'), number)) from numbers(10);\n+\n select 1 = position(materialize(''), '');\n select 1 = position(materialize('abc'), '');\n select 0 = position(materialize(''), 'abc');\n@@ -27,6 +44,16 @@ select 1 = position('\u0430\u0431\u0432', '\u0430\u0431\u0432');\n select 3 = position('\u0430\u0431\u0432', '\u0431\u0432');\n select 5 = position('\u0430\u0431\u0432', '\u0432');\n \n+select 2 = position('abcabc', 'b', 0);\n+select 2 = position('abcabc', 'b', 1);\n+select 2 = position('abcabc', 'b', 2);\n+select 5 = position('abcabc', 'b', 3);\n+select 5 = position('abcabc', 'b', 4);\n+select 5 = position('abcabc', 'b', 5);\n+select 0 = position('abcabc', 'b', 6);\n+select 2 = position('abcabc', 'bca', 0);\n+select 0 = position('abcabc', 'bca', 3);\n+\n select 1 = position(materialize(''), '');\n select 1 = position(materialize('\u0430\u0431\u0432'), '');\n select 0 = position(materialize(''), '\u0430\u0431\u0432');\n@@ -48,6 +75,14 @@ select 1 = positionUTF8('\u0430\u0431\u0432', '\u0430\u0431\u0432');\n select 2 = positionUTF8('\u0430\u0431\u0432', '\u0431\u0432');\n select 3 = positionUTF8('\u0430\u0431\u0432', '\u0432');\n \n+select 3 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 2);\n+select 3 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 3);\n+select 3 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431\u0432\u0430', 2);\n+select 9 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 4);\n+select 0 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431\u0432\u0430', 4);\n+select 5 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0432', 0);\n+select 11 = position('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0432', 6);\n+\n select 1 = positionUTF8(materialize(''), '');\n select 1 = positionUTF8(materialize('\u0430\u0431\u0432'), '');\n select 0 = positionUTF8(materialize(''), '\u0430\u0431\u0432');\n@@ -62,6 +97,51 @@ select 1 = positionUTF8(materialize('\u0430\u0431\u0432'), '\u0430\u0431\u0432') from system.numbers lim\n select 2 = positionUTF8(materialize('\u0430\u0431\u0432'), '\u0431\u0432') from system.numbers limit 10;\n select 3 = positionUTF8(materialize('\u0430\u0431\u0432'), '\u0432') from system.numbers limit 10;\n \n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 0);\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 1);\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 2);\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 3);\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 4);\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 5);\n+select 0 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', 6);\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431\u0432\u0430', 0);\n+select 0 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431\u0432\u0430', 3);\n+\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 0) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 1) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 2) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 3) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 4) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 5) from system.numbers limit 10;\n+select 0 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', 6) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431\u0432\u0430', 0) from system.numbers limit 10;\n+select 0 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431\u0432\u0430', 3) from system.numbers limit 10;\n+\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 0) from system.numbers limit 10;\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 1) from system.numbers limit 10;\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 2) from system.numbers limit 10;\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 3) from system.numbers limit 10;\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 4) from system.numbers limit 10;\n+select 5 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 5) from system.numbers limit 10;\n+select 0 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), 6) from system.numbers limit 10;\n+select 2 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431\u0432\u0430'), 0) from system.numbers limit 10;\n+select 0 = positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431\u0432\u0430'), 3) from system.numbers limit 10;\n+\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 0) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 1) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 2) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 3) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 4) from system.numbers limit 10;\n+select 5 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 5) from system.numbers limit 10;\n+select 0 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), 6) from system.numbers limit 10;\n+select 2 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431\u0432\u0430'), 0) from system.numbers limit 10;\n+select 0 = positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431\u0432\u0430'), 3) from system.numbers limit 10;\n+\n+select [2, 2, 2, 5, 5, 5, 0, 0, 0, 0] = groupArray(positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), materialize('\u0431'), number)) from numbers(10);\n+select [2, 2, 2, 5, 5, 5, 0, 0, 0, 0] = groupArray(positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', materialize('\u0431'), number)) from numbers(10);\n+select [2, 2, 2, 5, 5, 5, 0, 0, 0, 0] = groupArray(positionUTF8('\u0430\u0431\u0432\u0430\u0431\u0432', '\u0431', number)) from numbers(10);\n+select [2, 2, 2, 5, 5, 5, 0, 0, 0, 0] = groupArray(positionUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0431', number)) from numbers(10);\n+\n select 1 = positionCaseInsensitive('', '');\n select 1 = positionCaseInsensitive('abc', '');\n select 0 = positionCaseInsensitive('', 'aBc');\n@@ -83,6 +163,10 @@ select 1 = positionCaseInsensitive(materialize('abc'), 'aBc') from system.number\n select 2 = positionCaseInsensitive(materialize('abc'), 'Bc') from system.numbers limit 10;\n select 3 = positionCaseInsensitive(materialize('abc'), 'C') from system.numbers limit 10;\n \n+select 6 = positionCaseInsensitive(materialize('abcabc'), 'C', 4);\n+select 6 = positionCaseInsensitive(materialize('abcabc'), 'C', 4) from system.numbers limit 10;\n+select 6 = positionCaseInsensitive(materialize('abcabc'), 'C', materialize(4)) from system.numbers limit 10;\n+\n select 1 = positionCaseInsensitive('', '');\n select 1 = positionCaseInsensitive('\u0430\u0431\u0432', '');\n select 0 = positionCaseInsensitive('', '\u0430\u0411\u0432');\n@@ -125,6 +209,10 @@ select 1 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432'), '\u0430\u0411\u0432') from sys\n select 2 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432'), '\u0411\u0432') from system.numbers limit 10;\n select 3 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432'), '\u0412') from system.numbers limit 10;\n \n+select 6 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0412', 4);\n+select 6 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0412', 4) from system.numbers limit 10;\n+select 6 = positionCaseInsensitiveUTF8(materialize('\u0430\u0431\u0432\u0430\u0431\u0432'), '\u0412', materialize(4)) from system.numbers limit 10;\n+\n select position('' as h, '' as n) = positionCaseInsensitive(h, n);\n select position('abc' as h, '' as n) = positionCaseInsensitive(n, n);\n select 0 = positionCaseInsensitive('', 'aBc');\n",
  "problem_statement": "startPos optional arg in position/locate functions\n#3711 \n",
  "hints_text": "Is it still relevant? I think I can try to implement this feature.\r\nCc @alexey-milovidov \nYes, it is still relevant.\r\n\r\n> I think I can try to implement this feature.\r\n\r\nThat will be very appreciated!\nI have not enough time to work on this issue. But now I returned to this and main problem that I cannot figure out \u2013 how to pass one more argument to `PositionImpl`. It already contains four functions for constant/vector needle and constant/vector haystack. If I decide to add parameter it shouldn't be concrete constant or vector, because it produces a lot of variants. It should be abstract and function may handles both(constant/vector) cases. But I cannot decide what concrete thing to pass. Also this parameter would be added to all `*Impl` used in searchers. Maybe issue requires slightly deeper refactor to perserve other implementation clean and handle startPos in `PositionImpl`.\r\nCan you give some hint how better implement this feature?\r\n\nYou can pass it as abstract (IColumn) argument and extract the position with `IColumn::getUInt64` virtual function.\r\n(no need to dispatch over column types manually)",
  "created_at": "2020-08-02T13:33:01Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-search-functions.md",
    "docs/es/sql-reference/functions/string-search-functions.md",
    "docs/fa/sql-reference/functions/string-search-functions.md",
    "docs/ja/sql-reference/functions/string-search-functions.md",
    "docs/ru/sql-reference/functions/string-search-functions.md",
    "docs/tr/sql-reference/functions/string-search-functions.md",
    "src/Functions/FunctionsStringSearch.h",
    "src/Functions/FunctionsVisitParam.h",
    "src/Functions/HasTokenImpl.h",
    "src/Functions/MatchImpl.h",
    "src/Functions/MultiMatchAnyImpl.h",
    "src/Functions/PositionImpl.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00233_position_function_family.reference",
    "tests/queries/0_stateless/00233_position_function_family.sql"
  ]
}