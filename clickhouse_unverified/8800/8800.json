{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8800,
  "instance_id": "ClickHouse__ClickHouse-8800",
  "issue_numbers": [
    "8779"
  ],
  "base_commit": "3b896d21bd5e984a2377780a550d5c6219c25304",
  "patch": "diff --git a/dbms/src/DataStreams/TTLBlockInputStream.cpp b/dbms/src/DataStreams/TTLBlockInputStream.cpp\nindex 339f81321e4b..c08abba3bdf3 100644\n--- a/dbms/src/DataStreams/TTLBlockInputStream.cpp\n+++ b/dbms/src/DataStreams/TTLBlockInputStream.cpp\n@@ -70,7 +70,7 @@ bool TTLBlockInputStream::isTTLExpired(time_t ttl)\n Block TTLBlockInputStream::readImpl()\n {\n     /// Skip all data if table ttl is expired for part\n-    if (storage.hasTableTTL() && isTTLExpired(old_ttl_infos.table_ttl.max))\n+    if (storage.hasRowsTTL() && isTTLExpired(old_ttl_infos.table_ttl.max))\n     {\n         rows_removed = data_part->rows_count;\n         return {};\n@@ -80,7 +80,7 @@ Block TTLBlockInputStream::readImpl()\n     if (!block)\n         return block;\n \n-    if (storage.hasTableTTL() && (force || isTTLExpired(old_ttl_infos.table_ttl.min)))\n+    if (storage.hasRowsTTL() && (force || isTTLExpired(old_ttl_infos.table_ttl.min)))\n         removeRowsWithExpiredTableTTL(block);\n \n     removeValuesWithExpiredColumnTTL(block);\n@@ -106,10 +106,10 @@ void TTLBlockInputStream::readSuffixImpl()\n \n void TTLBlockInputStream::removeRowsWithExpiredTableTTL(Block & block)\n {\n-    storage.ttl_table_entry.expression->execute(block);\n+    storage.rows_ttl_entry.expression->execute(block);\n \n     const IColumn * ttl_column =\n-        block.getByName(storage.ttl_table_entry.result_column).column.get();\n+        block.getByName(storage.rows_ttl_entry.result_column).column.get();\n \n     const auto & column_names = header.getNames();\n     MutableColumns result_columns;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeData.cpp b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\nindex 210d412d86f9..d1c9e274e381 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -101,6 +101,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_SETTING;\n     extern const int READONLY_SETTING;\n     extern const int ABORTED;\n+    extern const int UNEXPECTED_AST_STRUCTURE;\n }\n \n \n@@ -626,7 +627,7 @@ void MergeTreeData::setTTLExpressions(const ColumnsDescription::ColumnTTLs & new\n             {\n                 auto new_ttl_entry = create_ttl_entry(ast);\n                 if (!only_check)\n-                    column_ttl_entries_by_name.emplace(name, new_ttl_entry);\n+                    column_ttl_entries_by_name[name] = new_ttl_entry;\n             }\n         }\n     }\n@@ -634,36 +635,35 @@ void MergeTreeData::setTTLExpressions(const ColumnsDescription::ColumnTTLs & new\n     if (new_ttl_table_ast)\n     {\n         std::vector<TTLEntry> update_move_ttl_entries;\n-        ASTPtr update_ttl_table_ast = nullptr;\n-        TTLEntry update_ttl_table_entry;\n+        TTLEntry update_rows_ttl_entry;\n \n         bool seen_delete_ttl = false;\n         for (auto ttl_element_ptr : new_ttl_table_ast->children)\n         {\n-            ASTTTLElement & ttl_element = static_cast<ASTTTLElement &>(*ttl_element_ptr);\n-            if (ttl_element.destination_type == PartDestinationType::DELETE)\n+            const auto * ttl_element = ttl_element_ptr->as<ASTTTLElement>();\n+            if (!ttl_element)\n+                throw Exception(\"Unexpected AST element in TTL expression\", ErrorCodes::UNEXPECTED_AST_STRUCTURE);\n+\n+            if (ttl_element->destination_type == PartDestinationType::DELETE)\n             {\n                 if (seen_delete_ttl)\n                 {\n                     throw Exception(\"More than one DELETE TTL expression is not allowed\", ErrorCodes::BAD_TTL_EXPRESSION);\n                 }\n \n-                auto new_ttl_table_entry = create_ttl_entry(ttl_element.children[0]);\n+                auto new_rows_ttl_entry = create_ttl_entry(ttl_element->children[0]);\n                 if (!only_check)\n-                {\n-                    update_ttl_table_ast = ttl_element.children[0];\n-                    update_ttl_table_entry = new_ttl_table_entry;\n-                }\n+                    update_rows_ttl_entry = new_rows_ttl_entry;\n \n                 seen_delete_ttl = true;\n             }\n             else\n             {\n-                auto new_ttl_entry = create_ttl_entry(ttl_element.children[0]);\n+                auto new_ttl_entry = create_ttl_entry(ttl_element->children[0]);\n \n                 new_ttl_entry.entry_ast = ttl_element_ptr;\n-                new_ttl_entry.destination_type = ttl_element.destination_type;\n-                new_ttl_entry.destination_name = ttl_element.destination_name;\n+                new_ttl_entry.destination_type = ttl_element->destination_type;\n+                new_ttl_entry.destination_name = ttl_element->destination_name;\n                 if (!new_ttl_entry.getDestination(getStoragePolicy()))\n                 {\n                     String message;\n@@ -681,8 +681,8 @@ void MergeTreeData::setTTLExpressions(const ColumnsDescription::ColumnTTLs & new\n \n         if (!only_check)\n         {\n-            ttl_table_entry = update_ttl_table_entry;\n-            ttl_table_ast = update_ttl_table_ast;\n+            rows_ttl_entry = update_rows_ttl_entry;\n+            ttl_table_ast = new_ttl_table_ast;\n \n             auto move_ttl_entries_lock = std::lock_guard<std::mutex>(move_ttl_entries_mutex);\n             move_ttl_entries = update_move_ttl_entries;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeData.h b/dbms/src/Storages/MergeTree/MergeTreeData.h\nindex 3c051829a61b..ba2af73a421f 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.h\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.h\n@@ -576,8 +576,10 @@ class MergeTreeData : public IStorage\n     bool hasSortingKey() const { return !sorting_key_columns.empty(); }\n     bool hasPrimaryKey() const { return !primary_key_columns.empty(); }\n     bool hasSkipIndices() const { return !skip_indices.empty(); }\n-    bool hasTableTTL() const { return ttl_table_ast != nullptr; }\n+\n     bool hasAnyColumnTTL() const { return !column_ttl_entries_by_name.empty(); }\n+    bool hasAnyMoveTTL() const { return !move_ttl_entries.empty(); }\n+    bool hasRowsTTL() const { return rows_ttl_entry.isEmpty(); }\n \n     /// Check that the part is not broken and calculate the checksums for it if they are not present.\n     MutableDataPartPtr loadPartAndFixMetadata(const DiskPtr & disk, const String & relative_path);\n@@ -735,6 +737,8 @@ class MergeTreeData : public IStorage\n \n         /// Checks if given part already belongs destination disk or volume for this rule.\n         bool isPartInDestination(const StoragePolicyPtr & policy, const MergeTreeDataPart & part) const;\n+\n+        bool isEmpty() const { return expression != nullptr; }\n     };\n \n     std::optional<TTLEntry> selectTTLEntryForTTLInfos(const MergeTreeDataPart::TTLInfos & ttl_infos, time_t time_of_move) const;\n@@ -742,7 +746,7 @@ class MergeTreeData : public IStorage\n     using TTLEntriesByName = std::unordered_map<String, TTLEntry>;\n     TTLEntriesByName column_ttl_entries_by_name;\n \n-    TTLEntry ttl_table_entry;\n+    TTLEntry rows_ttl_entry;\n \n     /// This mutex is required for background move operations which do not obtain global locks.\n     mutable std::mutex move_ttl_entries_mutex;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex 1c8e2e5621ab..549345de8d1e 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -278,8 +278,8 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataWriter::writeTempPart(BlockWithPa\n             ProfileEvents::increment(ProfileEvents::MergeTreeDataWriterBlocksAlreadySorted);\n     }\n \n-    if (data.hasTableTTL())\n-        updateTTL(data.ttl_table_entry, new_data_part->ttl_infos, new_data_part->ttl_infos.table_ttl, block, true);\n+    if (data.hasRowsTTL())\n+        updateTTL(data.rows_ttl_entry, new_data_part->ttl_infos, new_data_part->ttl_infos.table_ttl, block, true);\n \n     for (const auto & [name, ttl_entry] : data.column_ttl_entries_by_name)\n         updateTTL(ttl_entry, new_data_part->ttl_infos, new_data_part->ttl_infos.columns_ttl[name], block, true);\ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\nindex 703659bb4eae..4ebb51f0b41c 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n@@ -55,15 +55,6 @@ ReplicatedMergeTreeTableMetadata::ReplicatedMergeTreeTableMetadata(const MergeTr\n \n     ttl_table = formattedAST(data.ttl_table_ast);\n \n-    std::ostringstream ttl_move_stream;\n-    for (const auto & ttl_entry : data.move_ttl_entries)\n-    {\n-        if (ttl_move_stream.tellp() > 0)\n-            ttl_move_stream << \", \";\n-        ttl_move_stream << formattedAST(ttl_entry.entry_ast);\n-    }\n-    ttl_move = ttl_move_stream.str();\n-\n     skip_indices = data.getIndices().toString();\n     if (data.canUseAdaptiveGranularity())\n         index_granularity_bytes = data_settings->index_granularity_bytes;\n@@ -95,9 +86,6 @@ void ReplicatedMergeTreeTableMetadata::write(WriteBuffer & out) const\n     if (!ttl_table.empty())\n         out << \"ttl: \" << ttl_table << \"\\n\";\n \n-    if (!ttl_move.empty())\n-        out << \"move ttl: \" << ttl_move << \"\\n\";\n-\n     if (!skip_indices.empty())\n         out << \"indices: \" << skip_indices << \"\\n\";\n \n@@ -139,9 +127,6 @@ void ReplicatedMergeTreeTableMetadata::read(ReadBuffer & in)\n     if (checkString(\"ttl: \", in))\n         in >> ttl_table >> \"\\n\";\n \n-    if (checkString(\"move ttl: \", in))\n-        in >> ttl_move >> \"\\n\";\n-\n     if (checkString(\"indices: \", in))\n         in >> skip_indices >> \"\\n\";\n \n@@ -252,21 +237,6 @@ ReplicatedMergeTreeTableMetadata::checkAndFindDiff(const ReplicatedMergeTreeTabl\n                     ErrorCodes::METADATA_MISMATCH);\n     }\n \n-    if (ttl_move != from_zk.ttl_move)\n-    {\n-        if (allow_alter)\n-        {\n-            diff.ttl_move_changed = true;\n-            diff.new_ttl_move = from_zk.ttl_move;\n-        }\n-        else\n-            throw Exception(\n-                    \"Existing table metadata in ZooKeeper differs in move TTL.\"\n-                    \" Stored in ZooKeeper: \" + from_zk.ttl_move +\n-                    \", local: \" + ttl_move,\n-                    ErrorCodes::METADATA_MISMATCH);\n-    }\n-\n     if (skip_indices != from_zk.skip_indices)\n     {\n         if (allow_alter)\ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h\nindex 23fc4f6a0246..d8af3c2087af 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h\n@@ -28,7 +28,6 @@ struct ReplicatedMergeTreeTableMetadata\n     String skip_indices;\n     String constraints;\n     String ttl_table;\n-    String ttl_move;\n     UInt64 index_granularity_bytes;\n \n     ReplicatedMergeTreeTableMetadata() = default;\n@@ -54,12 +53,9 @@ struct ReplicatedMergeTreeTableMetadata\n         bool ttl_table_changed = false;\n         String new_ttl_table;\n \n-        bool ttl_move_changed = false;\n-        String new_ttl_move;\n-\n         bool empty() const\n         {\n-            return !sorting_key_changed && !skip_indices_changed && !ttl_table_changed && !constraints_changed && !ttl_move_changed;\n+            return !sorting_key_changed && !skip_indices_changed && !ttl_table_changed && !constraints_changed;\n         }\n     };\n \ndiff --git a/dbms/src/Storages/StorageMergeTree.cpp b/dbms/src/Storages/StorageMergeTree.cpp\nindex f5279ebef923..d8b25627a7e7 100644\n--- a/dbms/src/Storages/StorageMergeTree.cpp\n+++ b/dbms/src/Storages/StorageMergeTree.cpp\n@@ -652,7 +652,7 @@ bool StorageMergeTree::merge(\n     {\n         /// Force filter by TTL in 'OPTIMIZE ... FINAL' query to remove expired values from old parts\n         ///  without TTL infos or with outdated TTL infos, e.g. after 'ALTER ... MODIFY TTL' query.\n-        bool force_ttl = (final && (hasTableTTL() || hasAnyColumnTTL()));\n+        bool force_ttl = (final && (hasRowsTTL() || hasAnyColumnTTL()));\n \n         new_part = merger_mutator.mergePartsToTemporaryPart(\n             future_part, *merge_entry, table_lock_holder, time(nullptr),\ndiff --git a/dbms/src/Storages/StorageReplicatedMergeTree.cpp b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\nindex 2fdd7daa6844..db113624f68b 100644\n--- a/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -3132,7 +3132,7 @@ bool StorageReplicatedMergeTree::optimize(const ASTPtr & query, const ASTPtr & p\n             return false;\n         };\n \n-        bool force_ttl = (final && (hasTableTTL() || hasAnyColumnTTL()));\n+        bool force_ttl = (final && (hasRowsTTL() || hasAnyColumnTTL()));\n         const auto storage_settings_ptr = getSettings();\n \n         if (!partition && final)\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01070_alter_with_ttl.reference b/dbms/tests/queries/0_stateless/01070_alter_with_ttl.reference\nnew file mode 100644\nindex 000000000000..308d004ebf70\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01070_alter_with_ttl.reference\n@@ -0,0 +1,2 @@\n+CREATE TABLE default.alter_ttl (`i` Int, `s` String TTL toDate(\\'2020-01-01\\')) ENGINE = MergeTree ORDER BY i TTL toDate(\\'2020-05-05\\') SETTINGS index_granularity = 8192\n+CREATE TABLE default.alter_ttl (`d` Date, `s` String TTL d + toIntervalDay(1)) ENGINE = MergeTree ORDER BY d TTL d + toIntervalMonth(1) SETTINGS index_granularity = 8192\ndiff --git a/dbms/tests/queries/0_stateless/01070_alter_with_ttl.sql b/dbms/tests/queries/0_stateless/01070_alter_with_ttl.sql\nnew file mode 100644\nindex 000000000000..3adc3ccd6ae9\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01070_alter_with_ttl.sql\n@@ -0,0 +1,12 @@\n+drop table if exists alter_ttl;\n+\n+create table alter_ttl(i Int) engine = MergeTree order by i ttl toDate('2020-05-05');\n+alter table alter_ttl add column s String;\n+alter table alter_ttl modify column s String ttl toDate('2020-01-01');\n+show create table alter_ttl;\n+drop table alter_ttl;\n+\n+create table alter_ttl(d Date, s String) engine = MergeTree order by d ttl d + interval 1 month;\n+alter table alter_ttl modify column s String ttl d + interval 1 day;\n+show create table alter_ttl;\n+drop table alter_ttl;\n",
  "problem_statement": "Can't alter if table TTL is set\nBroken since introducing move TTLs.\r\n\r\n**How to reproduce**\r\n```\r\nap11-nix :) create table t (d Date, s String) engine = MergeTree order by d ttl d + interval 1 month\r\n\r\nap11-nix :) alter table t modify column s String ttl d + interval 1 day\r\n\r\nReceived exception from server (version 20.1.2):\r\nCode: 450. DB::Exception: Received from localhost:9000. DB::Exception: No such volume `P\ufffd\\f\\0\\0\\0\\0\u0001\\0\\0\\0\\0\\0\\0\\0\u0001\\0\\0\\0\\0\\0\\0\\0('y\\r\\0\\0\\0\\0x\ufffd \ufffd<\\0\\0\\`\ufffd \ufffd<\\0\\0\\`g!\ufffd<\\0\\0pg!\ufffd<\\0\\0pg!\ufffd<\\0\\0,\\0\\0\\0\\0` for given storage policy.. \r\n\r\n0 rows in set. Elapsed: 0.107 sec.\r\n```\n",
  "hints_text": "",
  "created_at": "2020-01-23T13:08:06Z"
}