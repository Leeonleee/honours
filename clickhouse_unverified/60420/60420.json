{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60420,
  "instance_id": "ClickHouse__ClickHouse-60420",
  "issue_numbers": [
    "59526"
  ],
  "base_commit": "048f7ec3e9e90eebee22a8e07a0767e66ce3dae9",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex 285737312bd7..a76bb01ce9e0 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -7,6 +7,7 @@ title: Formats for Input and Output Data\n \n ClickHouse can accept and return data in various formats. A format supported for input can be used to parse the data provided to `INSERT`s, to perform `SELECT`s from a file-backed table such as File, URL or HDFS, or to read a dictionary. A format supported for output can be used to arrange the\n results of a `SELECT`, and to perform `INSERT`s into a file-backed table.\n+All format names are case insensitive.\n \n The supported formats are:\n \ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 0654dd01e491..3303a0a4b660 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -31,14 +31,31 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+bool FormatFactory::exists(const String & name) const\n+{\n+    return dict.find(boost::to_lower_copy(name)) != dict.end();\n+}\n+\n const FormatFactory::Creators & FormatFactory::getCreators(const String & name) const\n {\n-    auto it = dict.find(name);\n+    auto it = dict.find(boost::to_lower_copy(name));\n     if (dict.end() != it)\n         return it->second;\n     throw Exception(ErrorCodes::UNKNOWN_FORMAT, \"Unknown format {}\", name);\n }\n \n+FormatFactory::Creators & FormatFactory::getOrCreateCreators(const String & name)\n+{\n+    String lower_case = boost::to_lower_copy(name);\n+    auto it = dict.find(lower_case);\n+    if (dict.end() != it)\n+        return it->second;\n+\n+    auto & creators = dict[lower_case];\n+    creators.name = name;\n+    return creators;\n+}\n+\n FormatSettings getFormatSettings(const ContextPtr & context)\n {\n     const auto & settings = context->getSettingsRef();\n@@ -542,7 +559,7 @@ SchemaReaderPtr FormatFactory::getSchemaReader(\n     const ContextPtr & context,\n     const std::optional<FormatSettings> & _format_settings) const\n {\n-    const auto & schema_reader_creator = dict.at(name).schema_reader_creator;\n+    const auto & schema_reader_creator = getCreators(name).schema_reader_creator;\n     if (!schema_reader_creator)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Format {} doesn't support schema inference.\", name);\n \n@@ -558,7 +575,7 @@ ExternalSchemaReaderPtr FormatFactory::getExternalSchemaReader(\n     const ContextPtr & context,\n     const std::optional<FormatSettings> & _format_settings) const\n {\n-    const auto & external_schema_reader_creator = dict.at(name).external_schema_reader_creator;\n+    const auto & external_schema_reader_creator = getCreators(name).external_schema_reader_creator;\n     if (!external_schema_reader_creator)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Format {} doesn't support schema inference.\", name);\n \n@@ -569,28 +586,28 @@ ExternalSchemaReaderPtr FormatFactory::getExternalSchemaReader(\n void FormatFactory::registerInputFormat(const String & name, InputCreator input_creator)\n {\n     chassert(input_creator);\n-    auto & creators = dict[name];\n+    auto & creators = getOrCreateCreators(name);\n     if (creators.input_creator || creators.random_access_input_creator)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Input format {} is already registered\", name);\n     creators.input_creator = std::move(input_creator);\n     registerFileExtension(name, name);\n-    KnownFormatNames::instance().add(name);\n+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);\n }\n \n void FormatFactory::registerRandomAccessInputFormat(const String & name, RandomAccessInputCreator input_creator)\n {\n     chassert(input_creator);\n-    auto & creators = dict[name];\n+    auto & creators = getOrCreateCreators(name);\n     if (creators.input_creator || creators.random_access_input_creator)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Input format {} is already registered\", name);\n     creators.random_access_input_creator = std::move(input_creator);\n     registerFileExtension(name, name);\n-    KnownFormatNames::instance().add(name);\n+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);\n }\n \n void FormatFactory::registerNonTrivialPrefixAndSuffixChecker(const String & name, NonTrivialPrefixAndSuffixChecker non_trivial_prefix_and_suffix_checker)\n {\n-    auto & target = dict[name].non_trivial_prefix_and_suffix_checker;\n+    auto & target = getOrCreateCreators(name).non_trivial_prefix_and_suffix_checker;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Non trivial prefix and suffix checker {} is already registered\", name);\n     target = std::move(non_trivial_prefix_and_suffix_checker);\n@@ -598,7 +615,7 @@ void FormatFactory::registerNonTrivialPrefixAndSuffixChecker(const String & name\n \n void FormatFactory::registerAppendSupportChecker(const String & name, AppendSupportChecker append_support_checker)\n {\n-    auto & target = dict[name].append_support_checker;\n+    auto & target = getOrCreateCreators(name).append_support_checker;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Suffix checker {} is already registered\", name);\n     target = std::move(append_support_checker);\n@@ -612,19 +629,19 @@ void FormatFactory::markFormatHasNoAppendSupport(const String & name)\n bool FormatFactory::checkIfFormatSupportAppend(const String & name, const ContextPtr & context, const std::optional<FormatSettings> & format_settings_)\n {\n     auto format_settings = format_settings_ ? *format_settings_ : getFormatSettings(context);\n-    auto & append_support_checker = dict[name].append_support_checker;\n+    const auto & append_support_checker = getCreators(name).append_support_checker;\n     /// By default we consider that format supports append\n     return !append_support_checker || append_support_checker(format_settings);\n }\n \n void FormatFactory::registerOutputFormat(const String & name, OutputCreator output_creator)\n {\n-    auto & target = dict[name].output_creator;\n+    auto & target = getOrCreateCreators(name).output_creator;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Output format {} is already registered\", name);\n     target = std::move(output_creator);\n     registerFileExtension(name, name);\n-    KnownFormatNames::instance().add(name);\n+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);\n }\n \n void FormatFactory::registerFileExtension(const String & extension, const String & format_name)\n@@ -696,7 +713,7 @@ String FormatFactory::getFormatFromFileDescriptor(int fd)\n \n void FormatFactory::registerFileSegmentationEngine(const String & name, FileSegmentationEngine file_segmentation_engine)\n {\n-    auto & target = dict[name].file_segmentation_engine_creator;\n+    auto & target = getOrCreateCreators(name).file_segmentation_engine_creator;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: File segmentation engine {} is already registered\", name);\n     auto creator = [file_segmentation_engine](const FormatSettings &)\n@@ -708,7 +725,7 @@ void FormatFactory::registerFileSegmentationEngine(const String & name, FileSegm\n \n void FormatFactory::registerFileSegmentationEngineCreator(const String & name, FileSegmentationEngineCreator file_segmentation_engine_creator)\n {\n-    auto & target = dict[name].file_segmentation_engine_creator;\n+    auto & target = getOrCreateCreators(name).file_segmentation_engine_creator;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: File segmentation engine creator {} is already registered\", name);\n     target = std::move(file_segmentation_engine_creator);\n@@ -716,7 +733,7 @@ void FormatFactory::registerFileSegmentationEngineCreator(const String & name, F\n \n void FormatFactory::registerSchemaReader(const String & name, SchemaReaderCreator schema_reader_creator)\n {\n-    auto & target = dict[name].schema_reader_creator;\n+    auto & target = getOrCreateCreators(name).schema_reader_creator;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Schema reader {} is already registered\", name);\n     target = std::move(schema_reader_creator);\n@@ -724,7 +741,7 @@ void FormatFactory::registerSchemaReader(const String & name, SchemaReaderCreato\n \n void FormatFactory::registerExternalSchemaReader(const String & name, ExternalSchemaReaderCreator external_schema_reader_creator)\n {\n-    auto & target = dict[name].external_schema_reader_creator;\n+    auto & target = getOrCreateCreators(name).external_schema_reader_creator;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Schema reader {} is already registered\", name);\n     target = std::move(external_schema_reader_creator);\n@@ -732,7 +749,7 @@ void FormatFactory::registerExternalSchemaReader(const String & name, ExternalSc\n \n void FormatFactory::markOutputFormatSupportsParallelFormatting(const String & name)\n {\n-    auto & target = dict[name].supports_parallel_formatting;\n+    auto & target = getOrCreateCreators(name).supports_parallel_formatting;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Output format {} is already marked as supporting parallel formatting\", name);\n     target = true;\n@@ -741,7 +758,7 @@ void FormatFactory::markOutputFormatSupportsParallelFormatting(const String & na\n \n void FormatFactory::markFormatSupportsSubsetOfColumns(const String & name)\n {\n-    auto & target = dict[name].subset_of_columns_support_checker;\n+    auto & target = getOrCreateCreators(name).subset_of_columns_support_checker;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Format {} is already marked as supporting subset of columns\", name);\n     target = [](const FormatSettings &){ return true; };\n@@ -749,7 +766,7 @@ void FormatFactory::markFormatSupportsSubsetOfColumns(const String & name)\n \n void FormatFactory::registerSubsetOfColumnsSupportChecker(const String & name, SubsetOfColumnsSupportChecker subset_of_columns_support_checker)\n {\n-    auto & target = dict[name].subset_of_columns_support_checker;\n+    auto & target = getOrCreateCreators(name).subset_of_columns_support_checker;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Format {} is already marked as supporting subset of columns\", name);\n     target = std::move(subset_of_columns_support_checker);\n@@ -757,7 +774,7 @@ void FormatFactory::registerSubsetOfColumnsSupportChecker(const String & name, S\n \n void FormatFactory::markOutputFormatPrefersLargeBlocks(const String & name)\n {\n-    auto & target = dict[name].prefers_large_blocks;\n+    auto & target = getOrCreateCreators(name).prefers_large_blocks;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: Format {} is already marked as preferring large blocks\", name);\n     target = true;\n@@ -773,7 +790,7 @@ bool FormatFactory::checkIfFormatSupportsSubsetOfColumns(const String & name, co\n void FormatFactory::registerAdditionalInfoForSchemaCacheGetter(\n     const String & name, AdditionalInfoForSchemaCacheGetter additional_info_for_schema_cache_getter)\n {\n-    auto & target = dict[name].additional_info_for_schema_cache_getter;\n+    auto & target = getOrCreateCreators(name).additional_info_for_schema_cache_getter;\n     if (target)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"FormatFactory: additional info for schema cache getter {} is already registered\", name);\n     target = std::move(additional_info_for_schema_cache_getter);\n@@ -791,13 +808,13 @@ String FormatFactory::getAdditionalInfoForSchemaCache(const String & name, const\n \n bool FormatFactory::isInputFormat(const String & name) const\n {\n-    auto it = dict.find(name);\n+    auto it = dict.find(boost::to_lower_copy(name));\n     return it != dict.end() && (it->second.input_creator || it->second.random_access_input_creator);\n }\n \n bool FormatFactory::isOutputFormat(const String & name) const\n {\n-    auto it = dict.find(name);\n+    auto it = dict.find(boost::to_lower_copy(name));\n     return it != dict.end() && it->second.output_creator;\n }\n \n@@ -826,7 +843,8 @@ bool FormatFactory::checkIfOutputFormatPrefersLargeBlocks(const String & name) c\n \n bool FormatFactory::checkParallelizeOutputAfterReading(const String & name, const ContextPtr & context) const\n {\n-    if (name == \"Parquet\" && context->getSettingsRef().input_format_parquet_preserve_order)\n+    auto format_name = boost::to_lower_copy(name);\n+    if (format_name == \"parquet\" && context->getSettingsRef().input_format_parquet_preserve_order)\n         return false;\n \n     return true;\n@@ -834,7 +852,7 @@ bool FormatFactory::checkParallelizeOutputAfterReading(const String & name, cons\n \n void FormatFactory::checkFormatName(const String & name) const\n {\n-    auto it = dict.find(name);\n+    auto it = dict.find(boost::to_lower_copy(name));\n     if (it == dict.end())\n         throw Exception(ErrorCodes::UNKNOWN_FORMAT, \"Unknown format {}\", name);\n }\ndiff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h\nindex 165a20f7c4d4..46c1b8ddcdd4 100644\n--- a/src/Formats/FormatFactory.h\n+++ b/src/Formats/FormatFactory.h\n@@ -132,6 +132,7 @@ class FormatFactory final : private boost::noncopyable\n \n     struct Creators\n     {\n+        String name;\n         InputCreator input_creator;\n         RandomAccessInputCreator random_access_input_creator;\n         OutputCreator output_creator;\n@@ -263,12 +264,14 @@ class FormatFactory final : private boost::noncopyable\n \n     /// Check that format with specified name exists and throw an exception otherwise.\n     void checkFormatName(const String & name) const;\n+    bool exists(const String & name) const;\n \n private:\n     FormatsDictionary dict;\n     FileExtensionFormats file_extension_formats;\n \n     const Creators & getCreators(const String & name) const;\n+    Creators & getOrCreateCreators(const String & name);\n \n     // Creates a ReadBuffer to give to an input format. Returns nullptr if we should use `buf` directly.\n     std::unique_ptr<ReadBuffer> wrapReadBufferIfNeeded(\ndiff --git a/src/Functions/formatRow.cpp b/src/Functions/formatRow.cpp\nindex 12a5fc2cc270..1ac6becfb15f 100644\n--- a/src/Functions/formatRow.cpp\n+++ b/src/Functions/formatRow.cpp\n@@ -18,7 +18,6 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int UNKNOWN_FORMAT;\n     extern const int BAD_ARGUMENTS;\n }\n \n@@ -40,8 +39,7 @@ class FunctionFormatRow : public IFunction\n         , arguments_column_names(std::move(arguments_column_names_))\n         , context(std::move(context_))\n     {\n-        if (!FormatFactory::instance().getAllFormats().contains(format_name))\n-            throw Exception(ErrorCodes::UNKNOWN_FORMAT, \"Unknown format {}\", format_name);\n+        FormatFactory::instance().checkFormatName(format_name);\n     }\n \n     String getName() const override { return name; }\ndiff --git a/src/Storages/StorageAzureBlob.cpp b/src/Storages/StorageAzureBlob.cpp\nindex f5fcf01c59ef..d484fefc46ff 100644\n--- a/src/Storages/StorageAzureBlob.cpp\n+++ b/src/Storages/StorageAzureBlob.cpp\n@@ -68,7 +68,6 @@ namespace ErrorCodes\n     extern const int CANNOT_DETECT_FORMAT;\n     extern const int LOGICAL_ERROR;\n     extern const int NOT_IMPLEMENTED;\n-\n }\n \n namespace\n@@ -167,7 +166,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine\n \n     auto is_format_arg = [] (const std::string & s) -> bool\n     {\n-        return s == \"auto\" || FormatFactory::instance().getAllFormats().contains(s);\n+        return s == \"auto\" || FormatFactory::instance().exists(s);\n     };\n \n     if (engine_args.size() == 4)\n@@ -200,7 +199,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine\n     else if (engine_args.size() == 6)\n     {\n         auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"format/account_name\");\n-        if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+        if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n         {\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Format and compression must be last arguments\");\n         }\n@@ -218,7 +217,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine\n     else if (engine_args.size() == 7)\n     {\n         auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"format/account_name\");\n-        if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+        if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n         {\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Format and compression must be last arguments\");\n         }\ndiff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp\nindex 2d8ef3df1c8c..e59a09efb206 100644\n--- a/src/Storages/StorageS3.cpp\n+++ b/src/Storages/StorageS3.cpp\n@@ -1531,7 +1531,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C\n                 no_sign_request = true;\n                 engine_args_to_idx = {{\"format\", 2}};\n             }\n-            else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            else if (second_arg == \"auto\" || FormatFactory::instance().exists(second_arg))\n                 engine_args_to_idx = {{\"format\", 1}, {\"compression_method\", 2}};\n             else\n                 engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}};\n@@ -1552,7 +1552,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C\n             else\n             {\n                 auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"session_token/format\");\n-                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n                 {\n                     engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n                 }\n@@ -1568,7 +1568,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C\n         else if (count == 5)\n         {\n             auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"session_token/format\");\n-            if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+            if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n             {\n                 engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"compression\", 4}};\n             }\ndiff --git a/src/Storages/System/StorageSystemFormats.cpp b/src/Storages/System/StorageSystemFormats.cpp\nindex a360971e1f72..849e4eadf78e 100644\n--- a/src/Storages/System/StorageSystemFormats.cpp\n+++ b/src/Storages/System/StorageSystemFormats.cpp\n@@ -23,7 +23,8 @@ void StorageSystemFormats::fillData(MutableColumns & res_columns, ContextPtr, co\n     const auto & formats = FormatFactory::instance().getAllFormats();\n     for (const auto & pair : formats)\n     {\n-        const auto & [format_name, creators] = pair;\n+        const auto & [name, creators] = pair;\n+        String format_name = creators.name;\n         UInt64 has_input_format(creators.input_creator != nullptr || creators.random_access_input_creator != nullptr);\n         UInt64 has_output_format(creators.output_creator != nullptr);\n         UInt64 supports_parallel_parsing(creators.file_segmentation_engine_creator != nullptr || creators.random_access_input_creator != nullptr);\ndiff --git a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\nindex 066d6338b6ae..8f558adb09b1 100644\n--- a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\n+++ b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp\n@@ -80,7 +80,7 @@ void TableFunctionAzureBlobStorage::parseArgumentsImpl(ASTs & engine_args, const\n         configuration.blob_path = checkAndGetLiteralArgument<String>(engine_args[2], \"blobpath\");\n \n         auto is_format_arg\n-            = [](const std::string & s) -> bool { return s == \"auto\" || FormatFactory::instance().getAllFormats().contains(s); };\n+            = [](const std::string & s) -> bool { return s == \"auto\" || FormatFactory::instance().exists(s); };\n \n         if (engine_args.size() == 4)\n         {\n@@ -207,7 +207,7 @@ void TableFunctionAzureBlobStorage::updateStructureAndFormatArgumentsIfNeeded(AS\n             arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n \n         auto is_format_arg\n-            = [](const std::string & s) -> bool { return s == \"auto\" || FormatFactory::instance().getAllFormats().contains(s); };\n+            = [](const std::string & s) -> bool { return s == \"auto\" || FormatFactory::instance().exists(s); };\n \n         /// (connection_string, container_name, blobpath)\n         if (args.size() == 3)\ndiff --git a/src/TableFunctions/TableFunctionS3.cpp b/src/TableFunctions/TableFunctionS3.cpp\nindex 3fedd38277c5..c00b1e2e3e50 100644\n--- a/src/TableFunctions/TableFunctionS3.cpp\n+++ b/src/TableFunctions/TableFunctionS3.cpp\n@@ -100,7 +100,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n                 no_sign_request = true;\n                 args_to_idx = {{\"format\", 2}};\n             }\n-            else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            else if (second_arg == \"auto\" || FormatFactory::instance().exists(second_arg))\n                 args_to_idx = {{\"format\", 1}, {\"structure\", 2}};\n             else\n                 args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}};\n@@ -119,14 +119,14 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n                 no_sign_request = true;\n                 args_to_idx = {{\"format\", 2}, {\"structure\", 3}};\n             }\n-            else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            else if (second_arg == \"auto\" || FormatFactory::instance().exists(second_arg))\n             {\n                 args_to_idx = {{\"format\", 1}, {\"structure\", 2}, {\"compression_method\", 3}};\n             }\n             else\n             {\n                 auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n-                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n                 {\n                     args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n                 }\n@@ -153,7 +153,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n             else\n             {\n                 auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n-                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n                 {\n                     args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}};\n                 }\n@@ -170,7 +170,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n         else if (count == 6)\n         {\n             auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n-            if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+            if (fourth_arg == \"auto\" || FormatFactory::instance().exists(fourth_arg))\n             {\n                 args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}, {\"compression_method\", 5}};\n             }\n@@ -300,7 +300,7 @@ void TableFunctionS3::updateStructureAndFormatArgumentsIfNeeded(ASTs & args, con\n                 args.push_back(structure_literal);\n             }\n             /// s3(source, format, structure)\n-            else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            else if (second_arg == \"auto\" || FormatFactory::instance().exists(second_arg))\n             {\n                 if (second_arg == \"auto\")\n                     args[1] = format_literal;\n@@ -330,7 +330,7 @@ void TableFunctionS3::updateStructureAndFormatArgumentsIfNeeded(ASTs & args, con\n                     args[3] = structure_literal;\n             }\n             /// s3(source, format, structure, compression_method)\n-            else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            else if (second_arg == \"auto\" || FormatFactory::instance().exists(second_arg))\n             {\n                 if (second_arg == \"auto\")\n                     args[1] = format_literal;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00309_formats_case_insensitive.reference b/tests/queries/0_stateless/00309_formats_case_insensitive.reference\nnew file mode 100644\nindex 000000000000..b74d7002833e\n--- /dev/null\n+++ b/tests/queries/0_stateless/00309_formats_case_insensitive.reference\n@@ -0,0 +1,95 @@\n+-- test FORMAT clause --\n+0\tHello & world\n+1\tHello & world\n+2\tHello & world\n+0,\"Hello & world\"\n+1,\"Hello & world\"\n+2,\"Hello & world\"\n+<?xml version='1.0' encoding='UTF-8' ?>\n+<result>\n+\t<meta>\n+\t\t<columns>\n+\t\t\t<column>\n+\t\t\t\t<name>number</name>\n+\t\t\t\t<type>UInt64</type>\n+\t\t\t</column>\n+\t\t\t<column>\n+\t\t\t\t<name>'Hello &amp; world'</name>\n+\t\t\t\t<type>String</type>\n+\t\t\t</column>\n+\t\t</columns>\n+\t</meta>\n+\t<data>\n+\t\t<row>\n+\t\t\t<number>0</number>\n+\t\t\t<field>Hello &amp; world</field>\n+\t\t</row>\n+\t\t<row>\n+\t\t\t<number>1</number>\n+\t\t\t<field>Hello &amp; world</field>\n+\t\t</row>\n+\t\t<row>\n+\t\t\t<number>2</number>\n+\t\t\t<field>Hello &amp; world</field>\n+\t\t</row>\n+\t</data>\n+\t<rows>3</rows>\n+</result>\n+{\n+\t\"meta\":\n+\t[\n+\t\t{\n+\t\t\t\"name\": \"number\",\n+\t\t\t\"type\": \"UInt64\"\n+\t\t},\n+\t\t{\n+\t\t\t\"name\": \"'Hello & world'\",\n+\t\t\t\"type\": \"String\"\n+\t\t}\n+\t],\n+\n+\t\"data\":\n+\t[\n+\t\t{\n+\t\t\t\"number\": \"0\",\n+\t\t\t\"'Hello & world'\": \"Hello & world\"\n+\t\t},\n+\t\t{\n+\t\t\t\"number\": \"1\",\n+\t\t\t\"'Hello & world'\": \"Hello & world\"\n+\t\t},\n+\t\t{\n+\t\t\t\"number\": \"2\",\n+\t\t\t\"'Hello & world'\": \"Hello & world\"\n+\t\t}\n+\t],\n+\n+\t\"rows\": 3\n+}\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+number:          0\n+'Hello & world': Hello & world\n+\n+Row 2:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+number:          1\n+'Hello & world': Hello & world\n+\n+Row 3:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+number:          2\n+'Hello & world': Hello & world\n+-- test table function --\n+0\tHello & world\n+1\tHello & world\n+2\tHello & world\n+0\tHello & world\n+1\tHello & world\n+2\tHello & world\n+-- test other function --\n+0\tHello & world\n+-- test table engine --\n+0\tHello & world\n+1\tHello & world\n+2\tHello & world\ndiff --git a/tests/queries/0_stateless/00309_formats_case_insensitive.sql b/tests/queries/0_stateless/00309_formats_case_insensitive.sql\nnew file mode 100644\nindex 000000000000..b4037ed98619\n--- /dev/null\n+++ b/tests/queries/0_stateless/00309_formats_case_insensitive.sql\n@@ -0,0 +1,23 @@\n+SELECT '-- test FORMAT clause --';\n+SET output_format_write_statistics = 0;\n+SELECT number, 'Hello & world' FROM numbers(3) FORMAT Tsv;\n+SELECT number, 'Hello & world' FROM numbers(3) FORMAT csv;\n+SELECT number, 'Hello & world' FROM numbers(3) FORMAT xMl;\n+SELECT number, 'Hello & world' FROM numbers(3) FORMAT JsonStrINGs;\n+SELECT number, 'Hello & world' FROM numbers(3) FORMAT VERTICAL;\n+\n+SELECT '-- test table function --';\n+INSERT INTO FUNCTION file('data_00309_formats_case_insensitive', 'Csv') SELECT number, 'Hello & world' FROM numbers(3) SETTINGS engine_file_truncate_on_insert=1;\n+SELECT * FROM file('data_00309_formats_case_insensitive', 'Csv');\n+\n+INSERT INTO FUNCTION file('data_00309_formats_case_insensitive.cSv') SELECT number, 'Hello & world' FROM numbers(3) SETTINGS engine_file_truncate_on_insert=1;\n+SELECT * FROM file('data_00309_formats_case_insensitive.cSv');\n+\n+SELECT '-- test other function --';\n+SELECT * FROM format(cSv, '0,Hello & world');\n+\n+SELECT '-- test table engine --';\n+DROP TABLE IF EXISTS test_00309_formats_case_insensitive;\n+CREATE TABLE test_00309_formats_case_insensitive(a Int64, b String) ENGINE=File(Csv);\n+INSERT INTO test_00309_formats_case_insensitive SELECT number, 'Hello & world' FROM numbers(3);\n+SELECT * FROM test_00309_formats_case_insensitive;\n",
  "problem_statement": "Consider making all format names case insensitive.\n**Use case**\r\n\r\nLet's just give up and accept if a user writes Tsv, or TSV, or tsv, or even rowbinary.\n",
  "hints_text": "@alexey-milovidov I'm interested in this issue. Could it be assigned to me? Thank you!\n@HowePa Sure.\n@alexey-milovidov I tried to add a static keyword map to make all format names case insensitive. Please review these changes",
  "created_at": "2024-02-26T14:48:11Z",
  "modified_files": [
    "docs/en/interfaces/formats.md",
    "src/Formats/FormatFactory.cpp",
    "src/Formats/FormatFactory.h",
    "src/Functions/formatRow.cpp",
    "src/Storages/StorageAzureBlob.cpp",
    "src/Storages/StorageS3.cpp",
    "src/Storages/System/StorageSystemFormats.cpp",
    "src/TableFunctions/TableFunctionAzureBlobStorage.cpp",
    "src/TableFunctions/TableFunctionS3.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/00309_formats_case_insensitive.reference",
    "b/tests/queries/0_stateless/00309_formats_case_insensitive.sql"
  ]
}