{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12306,
  "instance_id": "ClickHouse__ClickHouse-12306",
  "issue_numbers": [
    "12291"
  ],
  "base_commit": "1918d1d4176c0b8abc5ad8bbb26ea5b81a2cdb88",
  "patch": "diff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex e8d56389eacd..292b86a1446f 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -18,11 +18,7 @@ FillingTransform::FillingTransform(\n         , filling_row(sort_description_)\n         , next_row(sort_description_)\n {\n-    std::vector<bool> is_fill_column(header_.columns());\n-    for (const auto & elem : sort_description)\n-        is_fill_column[header_.getPositionByName(elem.column_name)] = true;\n-\n-    auto try_convert_fields = [](FillColumnDescription & descr, const DataTypePtr & type)\n+    auto try_convert_fields = [](auto & descr, const auto & type)\n     {\n         auto max_type = Field::Types::Null;\n         WhichDataType which(type);\n@@ -49,30 +45,32 @@ FillingTransform::FillingTransform(\n         return true;\n     };\n \n-    for (size_t i = 0; i < header_.columns(); ++i)\n+    std::vector<bool> is_fill_column(header_.columns());\n+    for (size_t i = 0; i < sort_description.size(); ++i)\n     {\n-        if (is_fill_column[i])\n-        {\n-            size_t pos = fill_column_positions.size();\n-            auto & descr = filling_row.getFillDescription(pos);\n-            auto type = header_.getByPosition(i).type;\n-            if (!try_convert_fields(descr, type))\n-                throw Exception(\"Incompatible types of WITH FILL expression values with column type \"\n-                    + type->getName(), ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n-\n-            if (type->isValueRepresentedByUnsignedInteger() &&\n-                ((!descr.fill_from.isNull() && less(descr.fill_from, Field{0}, 1)) ||\n-                    (!descr.fill_to.isNull() && less(descr.fill_to, Field{0}, 1))))\n-            {\n-                throw Exception(\"WITH FILL bound values cannot be negative for unsigned type \"\n-                    + type->getName(), ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n-            }\n+        size_t block_position = header_.getPositionByName(sort_description[i].column_name);\n+        is_fill_column[block_position] = true;\n+        fill_column_positions.push_back(block_position);\n \n-            fill_column_positions.push_back(i);\n+        auto & descr = filling_row.getFillDescription(i);\n+        const auto & type = header_.getByPosition(block_position).type;\n+\n+        if (!try_convert_fields(descr, type))\n+            throw Exception(\"Incompatible types of WITH FILL expression values with column type \"\n+                + type->getName(), ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n+\n+        if (type->isValueRepresentedByUnsignedInteger() &&\n+            ((!descr.fill_from.isNull() && less(descr.fill_from, Field{0}, 1)) ||\n+                (!descr.fill_to.isNull() && less(descr.fill_to, Field{0}, 1))))\n+        {\n+            throw Exception(\"WITH FILL bound values cannot be negative for unsigned type \"\n+                + type->getName(), ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n         }\n-        else\n-            other_column_positions.push_back(i);\n     }\n+\n+    for (size_t i = 0; i < header_.columns(); ++i)\n+        if (!is_fill_column[i])\n+            other_column_positions.push_back(i);\n }\n \n IProcessor::Status FillingTransform::prepare()\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01379_with_fill_several_columns.reference b/tests/queries/0_stateless/01379_with_fill_several_columns.reference\nnew file mode 100644\nindex 000000000000..f3362a47aab0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01379_with_fill_several_columns.reference\n@@ -0,0 +1,21 @@\n+1970-01-11\t1970-01-02\toriginal\n+0000-00-00\t1970-01-03\t\n+0000-00-00\t1970-01-04\t\n+1970-02-10\t1970-01-05\toriginal\n+0000-00-00\t1970-01-06\t\n+0000-00-00\t1970-01-07\t\n+1970-03-12\t1970-01-08\toriginal\n+===============\n+1970-01-11\t1970-01-02\toriginal\n+1970-01-16\t0000-00-00\t\n+1970-01-21\t0000-00-00\t\n+1970-01-26\t0000-00-00\t\n+1970-01-31\t0000-00-00\t\n+1970-02-05\t0000-00-00\t\n+1970-02-10\t1970-01-05\toriginal\n+1970-02-15\t0000-00-00\t\n+1970-02-20\t0000-00-00\t\n+1970-02-25\t0000-00-00\t\n+1970-03-02\t0000-00-00\t\n+1970-03-07\t0000-00-00\t\n+1970-03-12\t1970-01-08\toriginal\ndiff --git a/tests/queries/0_stateless/01379_with_fill_several_columns.sql b/tests/queries/0_stateless/01379_with_fill_several_columns.sql\nnew file mode 100644\nindex 000000000000..5d1cb4e68281\n--- /dev/null\n+++ b/tests/queries/0_stateless/01379_with_fill_several_columns.sql\n@@ -0,0 +1,21 @@\n+SELECT \n+    toDate((number * 10) * 86400) AS d1, \n+    toDate(number * 86400) AS d2, \n+    'original' AS source\n+FROM numbers(10)\n+WHERE (number % 3) = 1\n+ORDER BY \n+    d2 WITH FILL, \n+    d1 WITH FILL STEP 5;\n+\n+SELECT '===============';\n+\n+SELECT \n+    toDate((number * 10) * 86400) AS d1, \n+    toDate(number * 86400) AS d2, \n+    'original' AS source\n+FROM numbers(10)\n+WHERE (number % 3) = 1\n+ORDER BY \n+    d1 WITH FILL STEP 5,\n+    d2 WITH FILL;\n\\ No newline at end of file\n",
  "problem_statement": "multiple ORDER BY .. WITH FILL ignored field orders in ORDER BY and use field order from SELECT ...\n`ORDER BY f1 WITH FILL, f2 WITH FILL` always fills data only for one field which first in SELECT order and ignore fields order in `ORDER BY` clasue\r\n\r\n**How to reproduce**\r\n```sql\r\nSELECT toDate(number*10*86400) AS d1, toDate(number*86400) AS d2, 'original' AS source\r\nFROM numbers(10) WHERE number % 3 = 1\r\nORDER BY d2 WITH FILL, d1 WITH FILL;\r\n```\r\nhave same result as \r\n```sql\r\nSELECT toDate(number*10*86400) AS d1, toDate(number*86400) AS d2, 'original' AS source\r\nFROM numbers(10) WHERE number % 3 = 1\r\nORDER BY d1 WITH FILL, d2 WITH FILL,;\r\n```\r\n\r\nExpected behavior:\r\nfilled `by d1` or `by d2` according to ORDER  BY field order\r\n\r\nActual behavior\r\nalways only d1 filled, and d2 always have default valu\r\n\r\n\r\n* Which ClickHouse server version to use:\r\ndocker 20.5.2.7\r\n* Which interface to use, if matters\r\nNative\r\n\n",
  "hints_text": "@CurtizJ could you look at this issue?",
  "created_at": "2020-07-09T00:02:46Z"
}