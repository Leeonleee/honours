{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66374,
  "instance_id": "ClickHouse__ClickHouse-66374",
  "issue_numbers": [
    "66010"
  ],
  "base_commit": "5bc0e1e7f1b3d5912fdfb0b6deeadf0c161ed426",
  "patch": "diff --git a/docs/en/sql-reference/functions/uuid-functions.md b/docs/en/sql-reference/functions/uuid-functions.md\nindex e990023efbc9..0bde207dcc91 100644\n--- a/docs/en/sql-reference/functions/uuid-functions.md\n+++ b/docs/en/sql-reference/functions/uuid-functions.md\n@@ -567,12 +567,13 @@ While no standard or recommendation exists for the epoch of Snowflake IDs, imple\n **Syntax**\n \n ``` sql\n-generateSnowflakeID([expr])\n+generateSnowflakeID([expr, [machine_id]])\n ```\n \n **Arguments**\n \n - `expr` \u2014 An arbitrary [expression](../../sql-reference/syntax.md#syntax-expressions) used to bypass [common subexpression elimination](../../sql-reference/functions/index.md#common-subexpression-elimination) if the function is called multiple times in a query. The value of the expression has no effect on the returned Snowflake ID. Optional.\n+- `machine_id` \u2014 A machine ID, the lowest 10 bits are used. [Int64](../data-types/int-uint.md). Optional.\n \n **Returned value**\n \n@@ -608,6 +609,16 @@ SELECT generateSnowflakeID(1), generateSnowflakeID(2);\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+**Example with expression and a machine ID**\n+\n+```\n+SELECT generateSnowflakeID('expr', 1);\n+\n+\u250c\u2500generateSnowflakeID('expr', 1)\u2500\u2510\n+\u2502            7201148511606784002 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## snowflakeToDateTime\n \n :::warning\ndiff --git a/src/Functions/generateSnowflakeID.cpp b/src/Functions/generateSnowflakeID.cpp\nindex a171b6bf86e0..c95e3edf4ca6 100644\n--- a/src/Functions/generateSnowflakeID.cpp\n+++ b/src/Functions/generateSnowflakeID.cpp\n@@ -4,10 +4,10 @@\n #include <Functions/FunctionHelpers.h>\n #include <Core/ServerUUID.h>\n #include <Common/Logger.h>\n+#include <Common/ErrorCodes.h>\n #include <Common/logger_useful.h>\n #include \"base/types.h\"\n \n-\n namespace DB\n {\n \n@@ -96,10 +96,11 @@ struct SnowflakeIdRange\n /// 1. calculate Snowflake ID by current timestamp (`now`)\n /// 2. `begin = max(available, now)`\n /// 3. Calculate `end = begin + input_rows_count` handling `machine_seq_num` overflow\n-SnowflakeIdRange getRangeOfAvailableIds(const SnowflakeId & available, size_t input_rows_count)\n+SnowflakeIdRange getRangeOfAvailableIds(const SnowflakeId & available, uint64_t machine_id, size_t input_rows_count)\n+\n {\n     /// 1. `now`\n-    SnowflakeId begin = {.timestamp = getTimestamp(), .machine_id = getMachineId(), .machine_seq_num = 0};\n+    SnowflakeId begin = {.timestamp = getTimestamp(), .machine_id = machine_id, .machine_seq_num = 0};\n \n     /// 2. `begin`\n     if (begin.timestamp <= available.timestamp)\n@@ -128,13 +129,13 @@ struct Data\n     /// Guarantee counter monotonicity within one timestamp across all threads generating Snowflake IDs simultaneously.\n     static inline std::atomic<uint64_t> lowest_available_snowflake_id = 0;\n \n-    SnowflakeId reserveRange(size_t input_rows_count)\n+    SnowflakeId reserveRange(uint64_t machine_id, size_t input_rows_count)\n     {\n         uint64_t available_snowflake_id = lowest_available_snowflake_id.load();\n         SnowflakeIdRange range;\n         do\n         {\n-            range = getRangeOfAvailableIds(toSnowflakeId(available_snowflake_id), input_rows_count);\n+            range = getRangeOfAvailableIds(toSnowflakeId(available_snowflake_id), machine_id, input_rows_count);\n         }\n         while (!lowest_available_snowflake_id.compare_exchange_weak(available_snowflake_id, fromSnowflakeId(range.end)));\n         /// CAS failed --> another thread updated `lowest_available_snowflake_id` and we re-try\n@@ -165,24 +166,32 @@ class FunctionGenerateSnowflakeID : public IFunction\n     {\n         FunctionArgumentDescriptors mandatory_args;\n         FunctionArgumentDescriptors optional_args{\n-            {\"expr\", nullptr, nullptr, \"Arbitrary expression\"}\n+            {\"expr\", nullptr, nullptr, \"Arbitrary expression\"},\n+            {\"machine_id\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeUInt), static_cast<FunctionArgumentDescriptor::ColumnValidator>(&isColumnConst), \"const UInt*\"}\n         };\n         validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n \n         return std::make_shared<DataTypeUInt64>();\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & /*arguments*/, const DataTypePtr &, size_t input_rows_count) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n         auto col_res = ColumnVector<UInt64>::create();\n         typename ColumnVector<UInt64>::Container & vec_to = col_res->getData();\n \n-        if (input_rows_count != 0)\n+        if (input_rows_count > 0)\n         {\n             vec_to.resize(input_rows_count);\n \n+            uint64_t machine_id = getMachineId();\n+            if (arguments.size() == 2)\n+            {\n+                machine_id = arguments[1].column->getUInt(0);\n+                machine_id &= (1ull << machine_id_bits_count) - 1;\n+            }\n+\n             Data data;\n-            SnowflakeId snowflake_id = data.reserveRange(input_rows_count); /// returns begin of available snowflake ids range\n+            SnowflakeId snowflake_id = data.reserveRange(machine_id, input_rows_count);\n \n             for (UInt64 & to_row : vec_to)\n             {\n@@ -208,10 +217,13 @@ class FunctionGenerateSnowflakeID : public IFunction\n REGISTER_FUNCTION(GenerateSnowflakeID)\n {\n     FunctionDocumentation::Description description = R\"(Generates a Snowflake ID. The generated Snowflake ID contains the current Unix timestamp in milliseconds (41 + 1 top zero bits), followed by a machine id (10 bits), and a counter (12 bits) to distinguish IDs within a millisecond. For any given timestamp (unix_ts_ms), the counter starts at 0 and is incremented by 1 for each new Snowflake ID until the timestamp changes. In case the counter overflows, the timestamp field is incremented by 1 and the counter is reset to 0. Function generateSnowflakeID guarantees that the counter field within a timestamp increments monotonically across all function invocations in concurrently running threads and queries.)\";\n-    FunctionDocumentation::Syntax syntax = \"generateSnowflakeID([expression])\";\n-    FunctionDocumentation::Arguments arguments = {{\"expression\", \"The expression is used to bypass common subexpression elimination if the function is called multiple times in a query but otherwise ignored. Optional.\"}};\n+    FunctionDocumentation::Syntax syntax = \"generateSnowflakeID([expression, [machine_id]])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"expression\", \"The expression is used to bypass common subexpression elimination if the function is called multiple times in a query but otherwise ignored. Optional.\"},\n+        {\"machine_id\", \"A machine ID, the lowest 10 bits are used. Optional.\"}\n+    };\n     FunctionDocumentation::ReturnedValue returned_value = \"A value of type UInt64\";\n-    FunctionDocumentation::Examples examples = {{\"single\", \"SELECT generateSnowflakeID()\", \"7201148511606784000\"}, {\"multiple\", \"SELECT generateSnowflakeID(1), generateSnowflakeID(2)\", \"\"}};\n+    FunctionDocumentation::Examples examples = {{\"no_arguments\", \"SELECT generateSnowflakeID()\", \"7201148511606784000\"}, {\"with_machine_id\", \"SELECT generateSnowflakeID(1)\", \"7201148511606784001\"}, {\"with_expression_and_machine_id\", \"SELECT generateSnowflakeID('some_expression', 1)\", \"7201148511606784002\"}};\n     FunctionDocumentation::Categories categories = {\"Snowflake ID\"};\n \n     factory.registerFunction<FunctionGenerateSnowflakeID>({description, syntax, arguments, returned_value, examples, categories});\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03130_generateSnowflakeId.reference b/tests/queries/0_stateless/03130_generateSnowflakeId.reference\nindex 39669d21bee0..fd264f00d364 100644\n--- a/tests/queries/0_stateless/03130_generateSnowflakeId.reference\n+++ b/tests/queries/0_stateless/03130_generateSnowflakeId.reference\n@@ -1,5 +1,11 @@\n+Negative tests\n+The first bit must be zero\n 1\n+Test disabling of common subexpression elimination via first parameter\n 0\n 0\n 1\n+Test user-provided machine ID\n+1\n+Generated Snowflake IDs are unique\n 100\ndiff --git a/tests/queries/0_stateless/03130_generateSnowflakeId.sql b/tests/queries/0_stateless/03130_generateSnowflakeId.sql\nindex 0717c81aa0d4..6c0a6cc0f2ca 100644\n--- a/tests/queries/0_stateless/03130_generateSnowflakeId.sql\n+++ b/tests/queries/0_stateless/03130_generateSnowflakeId.sql\n@@ -1,13 +1,22 @@\n -- Test SQL function 'generateSnowflakeID'\n \n-SELECT bitAnd(bitShiftRight(toUInt64(generateSnowflakeID()), 63), 1) = 0; -- check first bit is zero\n+SELECT 'Negative tests';\n+SELECT generateSnowflakeID(1, 2, 3); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT generateSnowflakeID(1, 'not_an_int'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT generateSnowflakeID(1, materialize(2)); -- { serverError ILLEGAL_COLUMN }\n \n+ SELECT 'The first bit must be zero';\n+SELECT bitAnd(bitShiftRight(generateSnowflakeID(), 63), 1) = 0;\n+\n+SELECT 'Test disabling of common subexpression elimination via first parameter';\n SELECT generateSnowflakeID(1) = generateSnowflakeID(2); -- disabled common subexpression elimination --> lhs != rhs\n SELECT generateSnowflakeID() = generateSnowflakeID(1); -- same as ^^\n-SELECT generateSnowflakeID(1) = generateSnowflakeID(1); -- enabled common subexpression elimination\n+SELECT generateSnowflakeID(1) = generateSnowflakeID(1); -- with common subexpression elimination\n \n-SELECT generateSnowflakeID(1, 2); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT 'Test user-provided machine ID';\n+SELECT bitAnd(bitShiftRight(generateSnowflakeID(1, 123), 12), 1024 - 1) = 123; -- the machine id is actually set in the generated snowflake ID (1024 = 2^10)\n \n+SELECT 'Generated Snowflake IDs are unique';\n SELECT count(*)\n FROM\n (\n",
  "problem_statement": "Add ability to set machine_id in `generateSnowflakeID`\n**Use case**\r\n\r\nSnowflake ID (introduced [here](https://github.com/ClickHouse/ClickHouse/pull/63577)) contain bits for the machine ID. These can be used to guarantee uniqueness between nodes, the current implementation simply uses 10 bits of the server UUID as the machine ID. With big clusters, there is a high chance that machine IDs collide. We should introduce a way to set the machine ID explicitly..\r\n\r\n**Describe the solution you'd like**\r\n\r\nThis can be an argument of `generateSnowflakeID()` or server level configuration.\r\n\n",
  "hints_text": "Adding another optional parameter to `generateSnowflakeID` seems like the best approach. Volunteers welcome (adding the easy-task label).\n>With big clusters, there is a high chance that machine IDs collide.\r\n\r\nHow come? \r\nOnly if you copy `/var/lib/clickhouse/uuid` from one server to another, and you should not do it. Because other CH components rely on its uniqueness.\r\n\r\n>Adding another optional parameter to generateSnowflakeID seems like the best approach. \r\n\r\nBut it already has one optional parameter. It will be `generateSnowflakeID('dummy', machine_id )` ?\n@den-crane \r\n\r\nwhy not?\r\nwhy just not add machine_id as secondary optional parameter?\r\n\r\nwhy not extract machine_id from snowflake id `extractMachineIdFromSnowflake`\n> How come?\r\n\r\nWe take only 10 bits from Server UUID, only 1024 unique values. So for 100 servers probability of `machine_id` collision will be around 99%. \n> @den-crane\r\n> \r\n> why not? why just not add machine_id as secondary optional parameter?\r\n\r\nbecause `generateSnowflakeID('dummy', machine_id )` looks inconsistent with other generators.\r\nIt should be another function `generateSnowflakeIDMachineId(machine_id, [dummy])`.\nYet another function `generateSnowflakeIDMachineId` seems overkill, tbh.\r\n\r\nIf it is visually more pleasing, we could have the machine ID as first argument of `generateSnowflakeId`, i.e. `generateSnowflakeID([machine_id[, 'dummy']])`. That would be more or less compatible with existing usage (<-- which I suppose there is little of), while we no longer need another function.\nHi! I could take a look at this issue if it is still open!\n@Zawa-ll yes of course it still open, please make PR + tests\n@Slach Sure, thank you! Some changes is on the way!",
  "created_at": "2024-07-11T04:36:36Z",
  "modified_files": [
    "docs/en/sql-reference/functions/uuid-functions.md",
    "src/Functions/generateSnowflakeID.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/03130_generateSnowflakeId.reference",
    "tests/queries/0_stateless/03130_generateSnowflakeId.sql"
  ]
}