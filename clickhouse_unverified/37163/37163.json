{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37163,
  "instance_id": "ClickHouse__ClickHouse-37163",
  "issue_numbers": [
    "19426"
  ],
  "base_commit": "a53cfa9fcad121830db211a5831c3eafc36fb1ac",
  "patch": "diff --git a/src/Core/ColumnNumbers.h b/src/Core/ColumnNumbers.h\nindex 37507a6d683e..51054435e17d 100644\n--- a/src/Core/ColumnNumbers.h\n+++ b/src/Core/ColumnNumbers.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <unordered_set>\n #include <vector>\n \n \n@@ -7,6 +8,8 @@ namespace DB\n {\n \n using ColumnNumbers = std::vector<size_t>;\n+using ColumnNumbersSet = std::unordered_set<size_t>;\n using ColumnNumbersList = std::vector<ColumnNumbers>;\n+using ColumnNumbersSetList = std::vector<ColumnNumbersSet>;\n \n }\ndiff --git a/src/Core/Names.h b/src/Core/Names.h\nindex 3281daa560e6..003168bde277 100644\n--- a/src/Core/Names.h\n+++ b/src/Core/Names.h\n@@ -16,6 +16,7 @@ using NameOrderedSet = std::set<std::string>;\n using NameToNameMap = std::unordered_map<std::string, std::string>;\n using NameToNameSetMap = std::unordered_map<std::string, NameSet>;\n using NameToNameVector = std::vector<std::pair<std::string, std::string>>;\n+using NameToIndexMap = std::unordered_map<std::string, size_t>;\n \n using NameWithAlias = std::pair<std::string, std::string>;\n using NamesWithAliases = std::vector<NameWithAlias>;\ndiff --git a/src/Core/NamesAndTypes.cpp b/src/Core/NamesAndTypes.cpp\nindex bd24a9e82bdb..72768ce23fb0 100644\n--- a/src/Core/NamesAndTypes.cpp\n+++ b/src/Core/NamesAndTypes.cpp\n@@ -1,3 +1,4 @@\n+#include <cstddef>\n #include <Core/NamesAndTypes.h>\n \n #include <base/sort.h>\n@@ -214,4 +215,17 @@ std::optional<NameAndTypePair> NamesAndTypesList::tryGetByName(const std::string\n     }\n     return {};\n }\n+\n+size_t NamesAndTypesList::getPosByName(const std::string &name) const noexcept\n+{\n+    size_t pos = 0;\n+    for (const NameAndTypePair & column : *this)\n+    {\n+        if (column.name == name)\n+            break;\n+        ++pos;\n+    }\n+    return pos;\n+}\n+\n }\ndiff --git a/src/Core/NamesAndTypes.h b/src/Core/NamesAndTypes.h\nindex 2719017a7269..b9c03aae0caf 100644\n--- a/src/Core/NamesAndTypes.h\n+++ b/src/Core/NamesAndTypes.h\n@@ -105,8 +105,11 @@ class NamesAndTypesList : public std::list<NameAndTypePair>\n     /// Check that column contains in list\n     bool contains(const String & name) const;\n \n-    /// Try to get column by name, return empty optional if column not found\n+    /// Try to get column by name, returns empty optional if column not found\n     std::optional<NameAndTypePair> tryGetByName(const std::string & name) const;\n+\n+    /// Try to get column position by name, returns number of columns if column isn't found\n+    size_t getPosByName(const std::string & name) const noexcept;\n };\n \n using NamesAndTypesLists = std::vector<NamesAndTypesList>;\ndiff --git a/src/Functions/grouping.h b/src/Functions/grouping.h\nnew file mode 100644\nindex 000000000000..a49e946b2cb3\n--- /dev/null\n+++ b/src/Functions/grouping.h\n@@ -0,0 +1,165 @@\n+#pragma once\n+\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Core/ColumnNumbers.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+\n+namespace DB\n+{\n+\n+class FunctionGroupingBase : public IFunction\n+{\n+protected:\n+    static constexpr UInt64 ONE = 1;\n+\n+    const ColumnNumbers arguments_indexes;\n+\n+public:\n+    FunctionGroupingBase(ColumnNumbers arguments_indexes_)\n+        : arguments_indexes(std::move(arguments_indexes_))\n+    {}\n+\n+    bool isVariadic() const override { return true; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+\n+    bool isSuitableForConstantFolding() const override { return false; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    {\n+        return std::make_shared<DataTypeUInt64>();\n+    }\n+\n+    template <typename AggregationKeyChecker>\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, size_t input_rows_count, AggregationKeyChecker checker) const\n+    {\n+        const auto * grouping_set_column = checkAndGetColumn<ColumnUInt64>(arguments[0].column.get());\n+\n+        auto result = ColumnUInt64::create();\n+        auto & result_data = result->getData();\n+        result_data.reserve(input_rows_count);\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            UInt64 set_index = grouping_set_column->getElement(i);\n+\n+            UInt64 value = 0;\n+            for (auto index : arguments_indexes)\n+                value = (value << 1) + (checker(set_index, index) ? 1 : 0);\n+\n+            result_data.push_back(value);\n+        }\n+        return result;\n+    }\n+};\n+\n+class FunctionGroupingOrdinary : public FunctionGroupingBase\n+{\n+public:\n+    explicit FunctionGroupingOrdinary(ColumnNumbers arguments_indexes_)\n+        : FunctionGroupingBase(std::move(arguments_indexes_))\n+    {}\n+\n+    String getName() const override { return \"groupingOrdinary\"; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        UInt64 value = (ONE << arguments_indexes.size()) - 1;\n+        return ColumnUInt64::create(input_rows_count, value);\n+    }\n+};\n+\n+class FunctionGroupingForRollup : public FunctionGroupingBase\n+{\n+    const UInt64 aggregation_keys_number;\n+\n+public:\n+    FunctionGroupingForRollup(ColumnNumbers arguments_indexes_, UInt64 aggregation_keys_number_)\n+        : FunctionGroupingBase(std::move(arguments_indexes_))\n+        , aggregation_keys_number(aggregation_keys_number_)\n+    {}\n+\n+    String getName() const override { return \"groupingForRollup\"; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,\n+            [this](UInt64 set_index, UInt64 arg_index)\n+            {\n+                // For ROLLUP(a, b, c) there will be following grouping set indexes:\n+                // | GROUPING SET | INDEX |\n+                // | (a, b, c)    |   0   |\n+                // | (a, b)       |   1   |\n+                // | (a)          |   2   |\n+                // | ()           |   3   |\n+                return arg_index < aggregation_keys_number - set_index;\n+            }\n+        );\n+    }\n+};\n+\n+class FunctionGroupingForCube : public FunctionGroupingBase\n+{\n+    const UInt64 aggregation_keys_number;\n+\n+public:\n+\n+    FunctionGroupingForCube(ColumnNumbers arguments_indexes_, UInt64 aggregation_keys_number_)\n+        : FunctionGroupingBase(arguments_indexes_)\n+        , aggregation_keys_number(aggregation_keys_number_)\n+    {}\n+\n+    String getName() const override { return \"groupingForCube\"; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,\n+            [this](UInt64 set_index, UInt64 arg_index)\n+            {\n+                // For CUBE(a, b) there will be following grouping set indexes:\n+                // | GROUPING SET | INDEX |\n+                // | (a, b)       |   0   |\n+                // | (a)          |   1   |\n+                // | (b)          |   2   |\n+                // | ()           |   3   |\n+                auto set_mask = (ONE << aggregation_keys_number) - 1 - set_index;\n+                return set_mask & (ONE << (aggregation_keys_number - arg_index - 1));\n+            }\n+        );\n+    }\n+};\n+\n+class FunctionGroupingForGroupingSets : public FunctionGroupingBase\n+{\n+    ColumnNumbersSetList grouping_sets;\n+public:\n+    FunctionGroupingForGroupingSets(ColumnNumbers arguments_indexes_, ColumnNumbersList const & grouping_sets_)\n+        : FunctionGroupingBase(std::move(arguments_indexes_))\n+    {\n+        for (auto const & set : grouping_sets_)\n+            grouping_sets.emplace_back(set.begin(), set.end());\n+    }\n+\n+    String getName() const override { return \"groupingForGroupingSets\"; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,\n+            [this](UInt64 set_index, UInt64 arg_index)\n+            {\n+                return grouping_sets[set_index].contains(arg_index);\n+            }\n+        );\n+    }\n+};\n+\n+}\ndiff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex c57b85951bc9..99d2217cba3e 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -1,6 +1,12 @@\n+#include <memory>\n #include <Common/quoteString.h>\n #include <Common/typeid_cast.h>\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Core/ColumnNumbers.h>\n+#include <Core/ColumnWithTypeAndName.h>\n \n+#include <Functions/grouping.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionsMiscellaneous.h>\n \n@@ -8,10 +14,12 @@\n \n #include <DataTypes/DataTypeSet.h>\n #include <DataTypes/DataTypeFunction.h>\n+#include <DataTypes/DataTypeFixedString.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/FieldToDataType.h>\n \n #include <Columns/ColumnSet.h>\n@@ -56,6 +64,9 @@ namespace ErrorCodes\n     extern const int INCORRECT_ELEMENT_OF_SET;\n     extern const int BAD_ARGUMENTS;\n     extern const int DUPLICATE_COLUMN;\n+    extern const int LOGICAL_ERROR;\n+    extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;\n+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;\n }\n \n static NamesAndTypesList::iterator findColumn(const String & name, NamesAndTypesList & cols)\n@@ -459,10 +470,18 @@ class ScopeStack::Index\n };\n \n ActionsMatcher::Data::Data(\n-    ContextPtr context_, SizeLimits set_size_limit_, size_t subquery_depth_,\n-    const NamesAndTypesList & source_columns_, ActionsDAGPtr actions_dag,\n-    PreparedSets & prepared_sets_, SubqueriesForSets & subqueries_for_sets_,\n-    bool no_subqueries_, bool no_makeset_, bool only_consts_, bool create_source_for_in_)\n+    ContextPtr context_,\n+    SizeLimits set_size_limit_,\n+    size_t subquery_depth_,\n+    std::reference_wrapper<const NamesAndTypesList> source_columns_,\n+    ActionsDAGPtr actions_dag,\n+    PreparedSets & prepared_sets_,\n+    SubqueriesForSets & subqueries_for_sets_,\n+    bool no_subqueries_,\n+    bool no_makeset_,\n+    bool only_consts_,\n+    bool create_source_for_in_,\n+    AggregationKeysInfo aggregation_keys_info_)\n     : WithContext(context_)\n     , set_size_limit(set_size_limit_)\n     , subquery_depth(subquery_depth_)\n@@ -475,6 +494,7 @@ ActionsMatcher::Data::Data(\n     , create_source_for_in(create_source_for_in_)\n     , visit_depth(0)\n     , actions_stack(std::move(actions_dag), context_)\n+    , aggregation_keys_info(aggregation_keys_info_)\n     , next_unique_suffix(actions_stack.getLastActions().getIndex().size() + 1)\n {\n }\n@@ -817,6 +837,52 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         return;\n     }\n \n+    if (node.name == \"grouping\")\n+    {\n+        size_t arguments_size = node.arguments->children.size();\n+        if (arguments_size == 0)\n+            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, \"Function GROUPING expects at least one argument\");\n+        if (arguments_size > 64)\n+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, \"Function GROUPING can have up to 64 arguments, but {} provided\", arguments_size);\n+        auto keys_info = data.aggregation_keys_info;\n+        auto aggregation_keys_number = keys_info.aggregation_keys.size();\n+\n+        ColumnNumbers arguments_indexes;\n+        for (auto const & arg : node.arguments->children)\n+        {\n+            size_t pos = keys_info.aggregation_keys.getPosByName(arg->getColumnName());\n+            if (pos == aggregation_keys_number)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument of GROUPING function {} is not a part of GROUP BY clause\", arg->getColumnName());\n+            arguments_indexes.push_back(pos);\n+        }\n+\n+        switch (keys_info.group_by_kind)\n+        {\n+            case GroupByKind::GROUPING_SETS:\n+            {\n+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForGroupingSets>(std::move(arguments_indexes), keys_info.grouping_set_keys)), { \"__grouping_set\" }, column_name);\n+                break;\n+            }\n+            case GroupByKind::ROLLUP:\n+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForRollup>(std::move(arguments_indexes), aggregation_keys_number)), { \"__grouping_set\" }, column_name);\n+                break;\n+            case GroupByKind::CUBE:\n+            {\n+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForCube>(std::move(arguments_indexes), aggregation_keys_number)), { \"__grouping_set\" }, column_name);\n+                break;\n+            }\n+            case GroupByKind::ORDINARY:\n+            {\n+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingOrdinary>(std::move(arguments_indexes))), {}, column_name);\n+                break;\n+            }\n+            default:\n+                throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Unexpected kind of GROUP BY clause for GROUPING function: {}\", keys_info.group_by_kind);\n+        }\n+        return;\n+    }\n+\n     SetPtr prepared_set;\n     if (checkFunctionIsInOrGlobalInOperator(node))\n     {\ndiff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h\nindex d1558cb961ca..5a74124192c2 100644\n--- a/src/Interpreters/ActionsVisitor.h\n+++ b/src/Interpreters/ActionsVisitor.h\n@@ -1,10 +1,12 @@\n #pragma once\n \n+#include <Core/NamesAndTypes.h>\n #include <Interpreters/Context_fwd.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n #include <Interpreters/PreparedSets.h>\n #include <Interpreters/SubqueryForSet.h>\n #include <Parsers/IAST.h>\n+#include <Core/ColumnNumbers.h>\n \n \n namespace DB\n@@ -76,6 +78,42 @@ class ASTIdentifier;\n class ASTFunction;\n class ASTLiteral;\n \n+enum class GroupByKind\n+{\n+    NONE,\n+    ORDINARY,\n+    ROLLUP,\n+    CUBE,\n+    GROUPING_SETS,\n+};\n+\n+/*\n+ * This class stores information about aggregation keys used in GROUP BY clause.\n+ * It's used for providing information about aggregation to GROUPING function\n+ * implementation.\n+*/\n+struct AggregationKeysInfo\n+{\n+    AggregationKeysInfo(\n+        std::reference_wrapper<const NamesAndTypesList> aggregation_keys_,\n+        std::reference_wrapper<const ColumnNumbersList> grouping_set_keys_,\n+        GroupByKind group_by_kind_)\n+        : aggregation_keys(aggregation_keys_)\n+        , grouping_set_keys(grouping_set_keys_)\n+        , group_by_kind(group_by_kind_)\n+    {}\n+\n+    AggregationKeysInfo(const AggregationKeysInfo &) = default;\n+    AggregationKeysInfo(AggregationKeysInfo &&) = default;\n+\n+    // Names and types of all used keys\n+    const NamesAndTypesList & aggregation_keys;\n+    // Indexes of aggregation keys used in each grouping set (only for GROUP BY GROUPING SETS)\n+    const ColumnNumbersList & grouping_set_keys;\n+\n+    GroupByKind group_by_kind;\n+};\n+\n /// Collect ExpressionAction from AST. Returns PreparedSets and SubqueriesForSets too.\n class ActionsMatcher\n {\n@@ -95,6 +133,7 @@ class ActionsMatcher\n         bool create_source_for_in;\n         size_t visit_depth;\n         ScopeStack actions_stack;\n+        AggregationKeysInfo aggregation_keys_info;\n \n         /*\n          * Remember the last unique column suffix to avoid quadratic behavior\n@@ -107,14 +146,15 @@ class ActionsMatcher\n             ContextPtr context_,\n             SizeLimits set_size_limit_,\n             size_t subquery_depth_,\n-            const NamesAndTypesList & source_columns_,\n+            std::reference_wrapper<const NamesAndTypesList> source_columns_,\n             ActionsDAGPtr actions_dag,\n             PreparedSets & prepared_sets_,\n             SubqueriesForSets & subqueries_for_sets_,\n             bool no_subqueries_,\n             bool no_makeset_,\n             bool only_consts_,\n-            bool create_source_for_in_);\n+            bool create_source_for_in_,\n+            AggregationKeysInfo aggregation_keys_info_);\n \n         /// Does result of the calculation already exists in the block.\n         bool hasColumn(const String & column_name) const;\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 0b1154f6fd14..699f73abd67f 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -43,10 +43,13 @@\n \n #include <Common/typeid_cast.h>\n #include <Common/StringUtils/StringUtils.h>\n+#include <Core/ColumnNumbers.h>\n+#include <Core/Names.h>\n #include <Core/NamesAndTypes.h>\n \n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeFixedString.h>\n \n #include <Interpreters/ActionsVisitor.h>\n #include <Interpreters/GetAggregatesVisitor.h>\n@@ -325,12 +328,21 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n     {\n         if (ASTPtr group_by_ast = select_query->groupBy())\n         {\n-            NameSet unique_keys;\n+            NameToIndexMap unique_keys;\n             ASTs & group_asts = group_by_ast->children;\n \n+            if (select_query->group_by_with_rollup)\n+                group_by_kind = GroupByKind::ROLLUP;\n+            else if (select_query->group_by_with_cube)\n+                group_by_kind = GroupByKind::CUBE;\n+            else if (select_query->group_by_with_grouping_sets && group_asts.size() > 1)\n+                group_by_kind = GroupByKind::GROUPING_SETS;\n+            else\n+                group_by_kind = GroupByKind::ORDINARY;\n+\n             /// For GROUPING SETS with multiple groups we always add virtual __grouping_set column\n             /// With set number, which is used as an additional key at the stage of merging aggregating data.\n-            if (select_query->group_by_with_grouping_sets && group_asts.size() > 1)\n+            if (group_by_kind != GroupByKind::ORDINARY)\n                 aggregated_columns.emplace_back(\"__grouping_set\", std::make_shared<DataTypeUInt64>());\n \n             for (ssize_t i = 0; i < static_cast<ssize_t>(group_asts.size()); ++i)\n@@ -347,6 +359,7 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n                     group_elements_ast = group_ast_element->children;\n \n                     NamesAndTypesList grouping_set_list;\n+                    ColumnNumbers grouping_set_indexes_list;\n \n                     for (ssize_t j = 0; j < ssize_t(group_elements_ast.size()); ++j)\n                     {\n@@ -387,15 +400,21 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n                         /// Aggregation keys are unique.\n                         if (!unique_keys.contains(key.name))\n                         {\n-                            unique_keys.insert(key.name);\n+                            unique_keys[key.name] = aggregation_keys.size();\n+                            grouping_set_indexes_list.push_back(aggregation_keys.size());\n                             aggregation_keys.push_back(key);\n \n                             /// Key is no longer needed, therefore we can save a little by moving it.\n                             aggregated_columns.push_back(std::move(key));\n                         }\n+                        else\n+                        {\n+                            grouping_set_indexes_list.push_back(unique_keys[key.name]);\n+                        }\n                     }\n \n                     aggregation_keys_list.push_back(std::move(grouping_set_list));\n+                    aggregation_keys_indexes_list.push_back(std::move(grouping_set_indexes_list));\n                 }\n                 else\n                 {\n@@ -433,7 +452,7 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n                     /// Aggregation keys are uniqued.\n                     if (!unique_keys.contains(key.name))\n                     {\n-                        unique_keys.insert(key.name);\n+                        unique_keys[key.name] = aggregation_keys.size();\n                         aggregation_keys.push_back(key);\n \n                         /// Key is no longer needed, therefore we can save a little by moving it.\n@@ -442,6 +461,13 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n                 }\n             }\n \n+            if (!select_query->group_by_with_grouping_sets)\n+            {\n+                auto & list = aggregation_keys_indexes_list.emplace_back();\n+                for (size_t i = 0; i < aggregation_keys.size(); ++i)\n+                    list.push_back(i);\n+            }\n+\n             if (group_asts.empty())\n             {\n                 select_query->setExpression(ASTSelectQuery::Expression::GROUP_BY, {});\n@@ -583,7 +609,8 @@ void ExpressionAnalyzer::getRootActions(const ASTPtr & ast, bool no_makeset_for_\n         no_makeset_for_subqueries,\n         false /* no_makeset */,\n         only_consts,\n-        !isRemoteStorage() /* create_source_for_in */);\n+        !isRemoteStorage() /* create_source_for_in */,\n+        getAggregationKeysInfo());\n     ActionsVisitor(visitor_data, log.stream()).visit(ast);\n     actions = visitor_data.getActions();\n }\n@@ -603,7 +630,8 @@ void ExpressionAnalyzer::getRootActionsNoMakeSet(const ASTPtr & ast, ActionsDAGP\n         true /* no_makeset_for_subqueries, no_makeset implies no_makeset_for_subqueries */,\n         true /* no_makeset */,\n         only_consts,\n-        !isRemoteStorage() /* create_source_for_in */);\n+        !isRemoteStorage() /* create_source_for_in */,\n+        getAggregationKeysInfo());\n     ActionsVisitor(visitor_data, log.stream()).visit(ast);\n     actions = visitor_data.getActions();\n }\n@@ -624,7 +652,8 @@ void ExpressionAnalyzer::getRootActionsForHaving(\n         no_makeset_for_subqueries,\n         false /* no_makeset */,\n         only_consts,\n-        true /* create_source_for_in */);\n+        true /* create_source_for_in */,\n+        getAggregationKeysInfo());\n     ActionsVisitor(visitor_data, log.stream()).visit(ast);\n     actions = visitor_data.getActions();\n }\ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 85efb3829d04..971fe7539784 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -1,6 +1,8 @@\n #pragma once\n \n+#include <Core/ColumnNumbers.h>\n #include <Columns/FilterDescription.h>\n+#include <Interpreters/ActionsVisitor.h>\n #include <Interpreters/AggregateDescription.h>\n #include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/SubqueryForSet.h>\n@@ -67,6 +69,7 @@ struct ExpressionAnalyzerData\n     bool has_aggregation = false;\n     NamesAndTypesList aggregation_keys;\n     NamesAndTypesLists aggregation_keys_list;\n+    ColumnNumbersList aggregation_keys_indexes_list;\n     bool has_const_aggregation_keys = false;\n     AggregateDescriptions aggregate_descriptions;\n \n@@ -77,6 +80,8 @@ struct ExpressionAnalyzerData\n \n     /// All new temporary tables obtained by performing the GLOBAL IN/JOIN subqueries.\n     TemporaryTablesMapping external_tables;\n+\n+    GroupByKind group_by_kind = GroupByKind::NONE;\n };\n \n \n@@ -200,6 +205,11 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc\n \n     NamesAndTypesList getColumnsAfterArrayJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);\n     NamesAndTypesList analyzeJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);\n+\n+    AggregationKeysInfo getAggregationKeysInfo() const noexcept\n+    {\n+      return { aggregation_keys, aggregation_keys_indexes_list, group_by_kind };\n+    }\n };\n \n class SelectQueryExpressionAnalyzer;\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 5eaeecb93731..19fdb9a3a570 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1095,6 +1095,9 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P\n     if (query.group_by_with_grouping_sets && query.group_by_with_totals)\n        throw Exception(\"WITH TOTALS and GROUPING SETS are not supported together\", ErrorCodes::NOT_IMPLEMENTED);\n \n+    if (expressions.hasHaving() && query.group_by_with_totals && (query.group_by_with_rollup || query.group_by_with_cube))\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of HAVING\");\n+\n     if (query_info.projection && query_info.projection->desc->type == ProjectionDescription::Type::Aggregate)\n     {\n         query_info.projection->aggregate_overflow_row = aggregate_overflow_row;\n@@ -1387,11 +1390,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P\n                         executeRollupOrCube(query_plan, Modificator::CUBE);\n \n                     if ((query.group_by_with_rollup || query.group_by_with_cube || query.group_by_with_grouping_sets) && expressions.hasHaving())\n-                    {\n-                        if (query.group_by_with_totals)\n-                            throw Exception(\"WITH TOTALS and WITH ROLLUP or CUBE or GROUPING SETS are not supported together in presence of HAVING\", ErrorCodes::NOT_IMPLEMENTED);\n                         executeHaving(query_plan, expressions.before_having, expressions.remove_having_filter);\n-                    }\n                 }\n                 else if (expressions.hasHaving())\n                     executeHaving(query_plan, expressions.before_having, expressions.remove_having_filter);\ndiff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h\nindex 704aeeeea7cc..084627b57a1e 100644\n--- a/src/Parsers/ASTSelectQuery.h\n+++ b/src/Parsers/ASTSelectQuery.h\n@@ -95,22 +95,22 @@ class ASTSelectQuery : public IAST\n     ASTPtr & refWhere()     { return getExpression(Expression::WHERE); }\n     ASTPtr & refHaving()    { return getExpression(Expression::HAVING); }\n \n-    const ASTPtr with()           const { return getExpression(Expression::WITH); }\n-    const ASTPtr select()         const { return getExpression(Expression::SELECT); }\n-    const ASTPtr tables()         const { return getExpression(Expression::TABLES); }\n-    const ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }\n-    const ASTPtr where()          const { return getExpression(Expression::WHERE); }\n-    const ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }\n-    const ASTPtr having()         const { return getExpression(Expression::HAVING); }\n-    const ASTPtr window()         const { return getExpression(Expression::WINDOW); }\n-    const ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }\n-    const ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }\n-    const ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }\n-    const ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }\n-    const ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }\n-    const ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }\n-    const ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }\n-    const ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }\n+    ASTPtr with()           const { return getExpression(Expression::WITH); }\n+    ASTPtr select()         const { return getExpression(Expression::SELECT); }\n+    ASTPtr tables()         const { return getExpression(Expression::TABLES); }\n+    ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }\n+    ASTPtr where()          const { return getExpression(Expression::WHERE); }\n+    ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }\n+    ASTPtr having()         const { return getExpression(Expression::HAVING); }\n+    ASTPtr window()         const { return getExpression(Expression::WINDOW); }\n+    ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }\n+    ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }\n+    ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }\n+    ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }\n+    ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }\n+    ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }\n+    ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }\n+    ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }\n \n     bool hasFiltration() const { return where() || prewhere() || having(); }\n \ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 633b8c2e35a3..822bdf8d72af 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -803,6 +803,20 @@ namespace\n         node = makeASTFunction(\"exists\", subquery);\n         return true;\n     }\n+\n+    bool parseGrouping(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n+    {\n+        ASTPtr expr_list;\n+        if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))\n+            return false;\n+\n+        auto res = std::make_shared<ASTFunction>();\n+        res->name = \"grouping\";\n+        res->arguments = expr_list;\n+        res->children.push_back(res->arguments);\n+        node = std::move(res);\n+        return true;\n+    }\n }\n \n \n@@ -888,6 +902,8 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     else if (function_name_lowercase == \"datediff\" || function_name_lowercase == \"date_diff\"\n         || function_name_lowercase == \"timestampdiff\" || function_name_lowercase == \"timestamp_diff\")\n         parsed_special_function = parseDateDiff(pos, node, expected);\n+    else if (function_name_lowercase == \"grouping\")\n+        parsed_special_function = parseGrouping(pos, node, expected);\n \n     if (parsed_special_function.has_value())\n         return parsed_special_function.value() && ParserToken(TokenType::ClosingRoundBracket).ignore(pos);\ndiff --git a/src/Processors/QueryPlan/AggregatingStep.cpp b/src/Processors/QueryPlan/AggregatingStep.cpp\nindex 50acc0852570..4114eff5c56c 100644\n--- a/src/Processors/QueryPlan/AggregatingStep.cpp\n+++ b/src/Processors/QueryPlan/AggregatingStep.cpp\n@@ -12,7 +12,9 @@\n #include <Processors/Merges/FinishAggregatingInOrderTransform.h>\n #include <Interpreters/Aggregator.h>\n #include <Processors/QueryPlan/IQueryPlanStep.h>\n+#include <Columns/ColumnFixedString.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeFixedString.h>\n \n namespace DB\n {\n@@ -33,6 +35,17 @@ static ITransformingStep::Traits getTraits()\n     };\n }\n \n+Block appendGroupingSetColumn(Block header)\n+{\n+    Block res;\n+    res.insert({std::make_shared<DataTypeUInt64>(), \"__grouping_set\"});\n+\n+    for (auto & col : header)\n+        res.insert(std::move(col));\n+\n+    return res;\n+}\n+\n static Block appendGroupingColumn(Block block, const GroupingSetsParamsList & params)\n {\n     if (params.empty())\ndiff --git a/src/Processors/QueryPlan/AggregatingStep.h b/src/Processors/QueryPlan/AggregatingStep.h\nindex b933daaa474c..4dd3d9563506 100644\n--- a/src/Processors/QueryPlan/AggregatingStep.h\n+++ b/src/Processors/QueryPlan/AggregatingStep.h\n@@ -25,6 +25,8 @@ struct GroupingSetsParams\n \n using GroupingSetsParamsList = std::vector<GroupingSetsParams>;\n \n+Block appendGroupingSetColumn(Block header);\n+\n /// Aggregation. See AggregatingTransform.\n class AggregatingStep : public ITransformingStep\n {\ndiff --git a/src/Processors/QueryPlan/CubeStep.cpp b/src/Processors/QueryPlan/CubeStep.cpp\nindex 23c5115ec680..91c85a08412d 100644\n--- a/src/Processors/QueryPlan/CubeStep.cpp\n+++ b/src/Processors/QueryPlan/CubeStep.cpp\n@@ -1,6 +1,9 @@\n #include <Processors/QueryPlan/CubeStep.h>\n #include <Processors/Transforms/CubeTransform.h>\n+#include <Processors/Transforms/ExpressionTransform.h>\n+#include <Processors/QueryPlan/AggregatingStep.h>\n #include <QueryPipeline/QueryPipelineBuilder.h>\n+#include <DataTypes/DataTypesNumber.h>\n \n namespace DB\n {\n@@ -22,7 +25,8 @@ static ITransformingStep::Traits getTraits()\n }\n \n CubeStep::CubeStep(const DataStream & input_stream_, AggregatingTransformParamsPtr params_)\n-    : ITransformingStep(input_stream_, params_->getHeader(), getTraits())\n+    : ITransformingStep(input_stream_, appendGroupingSetColumn(params_->getHeader()), getTraits())\n+    , keys_size(params_->params.keys_size)\n     , params(std::move(params_))\n {\n     /// Aggregation keys are distinct\n@@ -30,14 +34,30 @@ CubeStep::CubeStep(const DataStream & input_stream_, AggregatingTransformParamsP\n         output_stream->distinct_columns.insert(params->params.src_header.getByPosition(key).name);\n }\n \n-void CubeStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n+ProcessorPtr addGroupingSetForTotals(const Block & header, const BuildQueryPipelineSettings & settings, UInt64 grouping_set_number)\n+{\n+    auto dag = std::make_shared<ActionsDAG>(header.getColumnsWithTypeAndName());\n+\n+    auto grouping_col = ColumnUInt64::create(1, grouping_set_number);\n+    const auto * grouping_node = &dag->addColumn(\n+        {ColumnPtr(std::move(grouping_col)), std::make_shared<DataTypeUInt64>(), \"__grouping_set\"});\n+\n+    grouping_node = &dag->materializeNode(*grouping_node);\n+    auto & index = dag->getIndex();\n+    index.insert(index.begin(), grouping_node);\n+\n+    auto expression = std::make_shared<ExpressionActions>(dag, settings.getActionsSettings());\n+    return std::make_shared<ExpressionTransform>(header, expression);\n+}\n+\n+void CubeStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings)\n {\n     pipeline.resize(1);\n \n     pipeline.addSimpleTransform([&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr\n     {\n         if (stream_type == QueryPipelineBuilder::StreamType::Totals)\n-            return nullptr;\n+            return addGroupingSetForTotals(header, settings, (UInt64(1) << keys_size) - 1);\n \n         return std::make_shared<CubeTransform>(header, std::move(params));\n     });\ndiff --git a/src/Processors/QueryPlan/CubeStep.h b/src/Processors/QueryPlan/CubeStep.h\nindex 1079bed53980..d3e26f9379f2 100644\n--- a/src/Processors/QueryPlan/CubeStep.h\n+++ b/src/Processors/QueryPlan/CubeStep.h\n@@ -21,6 +21,7 @@ class CubeStep : public ITransformingStep\n \n     const Aggregator::Params & getParams() const;\n private:\n+    size_t keys_size;\n     AggregatingTransformParamsPtr params;\n };\n \ndiff --git a/src/Processors/QueryPlan/RollupStep.cpp b/src/Processors/QueryPlan/RollupStep.cpp\nindex acaeb2bc9a74..3b061f9c2460 100644\n--- a/src/Processors/QueryPlan/RollupStep.cpp\n+++ b/src/Processors/QueryPlan/RollupStep.cpp\n@@ -1,6 +1,7 @@\n #include <Processors/QueryPlan/RollupStep.h>\n #include <Processors/Transforms/RollupTransform.h>\n #include <QueryPipeline/QueryPipelineBuilder.h>\n+#include <Processors/QueryPlan/AggregatingStep.h>\n \n namespace DB\n {\n@@ -22,22 +23,25 @@ static ITransformingStep::Traits getTraits()\n }\n \n RollupStep::RollupStep(const DataStream & input_stream_, AggregatingTransformParamsPtr params_)\n-    : ITransformingStep(input_stream_, params_->getHeader(), getTraits())\n+    : ITransformingStep(input_stream_, appendGroupingSetColumn(params_->getHeader()), getTraits())\n     , params(std::move(params_))\n+    , keys_size(params->params.keys_size)\n {\n     /// Aggregation keys are distinct\n     for (auto key : params->params.keys)\n         output_stream->distinct_columns.insert(params->params.src_header.getByPosition(key).name);\n }\n \n-void RollupStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n+ProcessorPtr addGroupingSetForTotals(const Block & header, const BuildQueryPipelineSettings & settings, UInt64 grouping_set_number);\n+\n+void RollupStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings)\n {\n     pipeline.resize(1);\n \n     pipeline.addSimpleTransform([&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr\n     {\n         if (stream_type == QueryPipelineBuilder::StreamType::Totals)\n-            return nullptr;\n+            return addGroupingSetForTotals(header, settings, keys_size);\n \n         return std::make_shared<RollupTransform>(header, std::move(params));\n     });\ndiff --git a/src/Processors/QueryPlan/RollupStep.h b/src/Processors/QueryPlan/RollupStep.h\nindex 7cd71fecdc17..3dce6f74d9f8 100644\n--- a/src/Processors/QueryPlan/RollupStep.h\n+++ b/src/Processors/QueryPlan/RollupStep.h\n@@ -20,6 +20,7 @@ class RollupStep : public ITransformingStep\n \n private:\n     AggregatingTransformParamsPtr params;\n+    size_t keys_size;\n };\n \n }\ndiff --git a/src/Processors/Transforms/CubeTransform.cpp b/src/Processors/Transforms/CubeTransform.cpp\nindex 6b672407cd1e..c699e724ffc6 100644\n--- a/src/Processors/Transforms/CubeTransform.cpp\n+++ b/src/Processors/Transforms/CubeTransform.cpp\n@@ -1,5 +1,6 @@\n #include <Processors/Transforms/CubeTransform.h>\n #include <Processors/Transforms/TotalsHavingTransform.h>\n+#include <Processors/QueryPlan/AggregatingStep.h>\n \n namespace DB\n {\n@@ -9,7 +10,7 @@ namespace ErrorCodes\n }\n \n CubeTransform::CubeTransform(Block header, AggregatingTransformParamsPtr params_)\n-    : IAccumulatingTransform(std::move(header), params_->getHeader())\n+    : IAccumulatingTransform(std::move(header), appendGroupingSetColumn(params_->getHeader()))\n     , params(std::move(params_))\n     , keys(params->params.keys)\n     , aggregates_mask(getAggregatesMask(params->getHeader(), params->params.aggregates))\n@@ -75,6 +76,8 @@ Chunk CubeTransform::generate()\n     }\n \n     finalizeChunk(gen_chunk, aggregates_mask);\n+    if (!gen_chunk.empty())\n+        gen_chunk.addColumn(0, ColumnUInt64::create(gen_chunk.getNumRows(), grouping_set++));\n     return gen_chunk;\n }\n \ndiff --git a/src/Processors/Transforms/CubeTransform.h b/src/Processors/Transforms/CubeTransform.h\nindex a1a1c9271c33..4575a01935d6 100644\n--- a/src/Processors/Transforms/CubeTransform.h\n+++ b/src/Processors/Transforms/CubeTransform.h\n@@ -30,6 +30,7 @@ class CubeTransform : public IAccumulatingTransform\n     Columns current_zero_columns;\n \n     UInt64 mask = 0;\n+    UInt64 grouping_set = 0;\n \n     Chunk merge(Chunks && chunks, bool final);\n };\ndiff --git a/src/Processors/Transforms/RollupTransform.cpp b/src/Processors/Transforms/RollupTransform.cpp\nindex 3150ff99e765..db60b99102d8 100644\n--- a/src/Processors/Transforms/RollupTransform.cpp\n+++ b/src/Processors/Transforms/RollupTransform.cpp\n@@ -1,11 +1,12 @@\n #include <Processors/Transforms/RollupTransform.h>\n #include <Processors/Transforms/TotalsHavingTransform.h>\n+#include <Processors/QueryPlan/AggregatingStep.h>\n \n namespace DB\n {\n \n RollupTransform::RollupTransform(Block header, AggregatingTransformParamsPtr params_)\n-    : IAccumulatingTransform(std::move(header), params_->getHeader())\n+    : IAccumulatingTransform(std::move(header), appendGroupingSetColumn(params_->getHeader()))\n     , params(std::move(params_))\n     , keys(params->params.keys)\n     , aggregates_mask(getAggregatesMask(params->getHeader(), params->params.aggregates))\n@@ -58,6 +59,8 @@ Chunk RollupTransform::generate()\n     }\n \n     finalizeChunk(gen_chunk, aggregates_mask);\n+    if (!gen_chunk.empty())\n+        gen_chunk.addColumn(0, ColumnUInt64::create(gen_chunk.getNumRows(), set_counter++));\n     return gen_chunk;\n }\n \ndiff --git a/src/Processors/Transforms/RollupTransform.h b/src/Processors/Transforms/RollupTransform.h\nindex 74e83b8535dd..8fd27e3e6a2c 100644\n--- a/src/Processors/Transforms/RollupTransform.h\n+++ b/src/Processors/Transforms/RollupTransform.h\n@@ -26,6 +26,7 @@ class RollupTransform : public IAccumulatingTransform\n     Chunks consumed_chunks;\n     Chunk rollup_chunk;\n     size_t last_removed_key = 0;\n+    size_t set_counter = 0;\n \n     Chunk merge(Chunks && chunks, bool final);\n };\ndiff --git a/src/Storages/VirtualColumnUtils.cpp b/src/Storages/VirtualColumnUtils.cpp\nindex d0840778c0f4..40cf650f6900 100644\n--- a/src/Storages/VirtualColumnUtils.cpp\n+++ b/src/Storages/VirtualColumnUtils.cpp\n@@ -156,8 +156,13 @@ bool prepareFilterBlockWithQuery(const ASTPtr & query, ContextPtr context, Block\n         auto actions = std::make_shared<ActionsDAG>(block.getColumnsWithTypeAndName());\n         PreparedSets prepared_sets;\n         SubqueriesForSets subqueries_for_sets;\n+        const NamesAndTypesList source_columns;\n+        const NamesAndTypesList aggregation_keys;\n+        const ColumnNumbersList grouping_set_keys;\n+\n         ActionsVisitor::Data visitor_data(\n-            context, SizeLimits{}, 1, {}, std::move(actions), prepared_sets, subqueries_for_sets, true, true, true, false);\n+            context, SizeLimits{}, 1, source_columns, std::move(actions), prepared_sets, subqueries_for_sets, true, true, true, false,\n+            { aggregation_keys, grouping_set_keys, GroupByKind::NONE });\n         ActionsVisitor(visitor_data).visit(node);\n         actions = visitor_data.getActions();\n         auto expression_actions = std::make_shared<ExpressionActions>(actions);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02293_grouping_function.reference b/tests/queries/0_stateless/02293_grouping_function.reference\nnew file mode 100644\nindex 000000000000..e71d6812ab58\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_grouping_function.reference\n@@ -0,0 +1,176 @@\n+-- { echoOn }\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+0\t1\n+0\t1\n+0\t2\n+1\t2\n+2\t2\n+3\t2\n+4\t2\n+5\t2\n+6\t2\n+7\t2\n+8\t2\n+9\t2\n+SELECT\n+    number,\n+    grouping(number % 2, number) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+0\t1\n+0\t2\n+0\t2\n+1\t1\n+2\t1\n+3\t1\n+4\t1\n+5\t1\n+6\t1\n+7\t1\n+8\t1\n+9\t1\n+SELECT\n+    number,\n+    grouping(number, number % 2) = 1 AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+0\t0\n+0\t1\n+0\t1\n+1\t0\n+2\t0\n+3\t0\n+4\t0\n+5\t0\n+6\t0\n+7\t0\n+8\t0\n+9\t0\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, grouping(number, number % 2) = 1;\n+0\n+0\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+SELECT\n+    number,\n+    count(),\n+    grouping(number, number % 2) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number, number % 2),\n+        ()\n+    )\n+ORDER BY (gr, number);\n+0\t10\t0\n+0\t1\t2\n+1\t1\t2\n+2\t1\t2\n+3\t1\t2\n+4\t1\t2\n+5\t1\t2\n+6\t1\t2\n+7\t1\t2\n+8\t1\t2\n+9\t1\t2\n+0\t1\t3\n+1\t1\t3\n+2\t1\t3\n+3\t1\t3\n+4\t1\t3\n+5\t1\t3\n+6\t1\t3\n+7\t1\t3\n+8\t1\t3\n+9\t1\t3\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+HAVING grouping(number, number % 2) = 2\n+ORDER BY number\n+SETTINGS enable_optimize_predicate_expression = 0;\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+HAVING grouping(number, number % 2) = 1\n+ORDER BY number\n+SETTINGS enable_optimize_predicate_expression = 0;\n+0\n+0\n+SELECT\n+    number,\n+    GROUPING(number, number % 2) = 1 as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    GROUPING SETS (\n+    (number),\n+    (number % 2))\n+ORDER BY number, gr;\n+0\t0\n+0\t1\n+0\t1\n+1\t0\n+2\t0\n+3\t0\n+4\t0\n+5\t0\n+6\t0\n+7\t0\n+8\t0\n+9\t0\ndiff --git a/tests/queries/0_stateless/02293_grouping_function.sql b/tests/queries/0_stateless/02293_grouping_function.sql\nnew file mode 100644\nindex 000000000000..169fc09c3244\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_grouping_function.sql\n@@ -0,0 +1,101 @@\n+SELECT\n+    number,\n+    grouping(number, number % 2, number % 3) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr; -- { serverError BAD_ARGUMENTS }\n+\n+-- { echoOn }\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number % 2, number) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) = 1 AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, gr;\n+\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+ORDER BY number, grouping(number, number % 2) = 1;\n+\n+SELECT\n+    number,\n+    count(),\n+    grouping(number, number % 2) AS gr\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number, number % 2),\n+        ()\n+    )\n+ORDER BY (gr, number);\n+\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+HAVING grouping(number, number % 2) = 2\n+ORDER BY number\n+SETTINGS enable_optimize_predicate_expression = 0;\n+\n+SELECT\n+    number\n+FROM numbers(10)\n+GROUP BY\n+    GROUPING SETS (\n+        (number),\n+        (number % 2)\n+    )\n+HAVING grouping(number, number % 2) = 1\n+ORDER BY number\n+SETTINGS enable_optimize_predicate_expression = 0;\n+\n+SELECT\n+    number,\n+    GROUPING(number, number % 2) = 1 as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    GROUPING SETS (\n+    (number),\n+    (number % 2))\n+ORDER BY number, gr;\ndiff --git a/tests/queries/0_stateless/02293_grouping_function_group_by.reference b/tests/queries/0_stateless/02293_grouping_function_group_by.reference\nnew file mode 100644\nindex 000000000000..7f87aecd4bd1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_grouping_function_group_by.reference\n@@ -0,0 +1,273 @@\n+-- { echoOn }\n+SELECT\n+    number,\n+    grouping(number, number % 2) = 3\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+ORDER BY number;\n+0\t1\n+1\t1\n+2\t1\n+3\t1\n+4\t1\n+5\t1\n+6\t1\n+7\t1\n+8\t1\n+9\t1\n+SELECT\n+    number,\n+    grouping(number),\n+    GROUPING(number % 2)\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+ORDER BY number;\n+0\t1\t1\n+1\t1\t1\n+2\t1\t1\n+3\t1\t1\n+4\t1\t1\n+5\t1\t1\n+6\t1\t1\n+7\t1\t1\n+8\t1\t1\n+9\t1\t1\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+    WITH ROLLUP\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2)\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+    WITH CUBE\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t1\n+0\t1\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2)\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t1\n+0\t1\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+SELECT\n+    number,\n+    grouping(number, number % 2) + 3 as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2)\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr;\n+0\t5\n+0\t6\n+1\t5\n+1\t6\n+2\t5\n+2\t6\n+3\t5\n+3\t6\n+4\t5\n+4\t6\n+5\t5\n+5\t6\n+6\t5\n+6\t6\n+7\t5\n+7\t6\n+8\t5\n+8\t6\n+9\t5\n+9\t6\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2) WITH TOTALS\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr; -- { serverError NOT_IMPLEMENTED }\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2) WITH TOTALS\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t1\n+0\t1\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+\n+0\t0\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2) WITH TOTALS\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr; -- { serverError NOT_IMPLEMENTED }\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2) WITH TOTALS\n+ORDER BY\n+    number, gr;\n+0\t0\n+0\t2\n+0\t3\n+1\t2\n+1\t3\n+2\t2\n+2\t3\n+3\t2\n+3\t3\n+4\t2\n+4\t3\n+5\t2\n+5\t3\n+6\t2\n+6\t3\n+7\t2\n+7\t3\n+8\t2\n+8\t3\n+9\t2\n+9\t3\n+\n+0\t0\ndiff --git a/tests/queries/0_stateless/02293_grouping_function_group_by.sql b/tests/queries/0_stateless/02293_grouping_function_group_by.sql\nnew file mode 100644\nindex 000000000000..9bf9d43478b6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_grouping_function_group_by.sql\n@@ -0,0 +1,116 @@\n+SELECT\n+    number,\n+    grouping(number, number % 2, number % 3) = 6\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+ORDER BY number; -- { serverError BAD_ARGUMENTS }\n+\n+-- { echoOn }\n+SELECT\n+    number,\n+    grouping(number, number % 2) = 3\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+ORDER BY number;\n+\n+SELECT\n+    number,\n+    grouping(number),\n+    GROUPING(number % 2)\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+ORDER BY number;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+    WITH ROLLUP\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2)\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    number,\n+    number % 2\n+    WITH CUBE\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) AS gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2)\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) + 3 as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2)\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2) WITH TOTALS\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr; -- { serverError NOT_IMPLEMENTED }\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    CUBE(number, number % 2) WITH TOTALS\n+ORDER BY\n+    number, gr;\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2) WITH TOTALS\n+HAVING grouping(number) != 0\n+ORDER BY\n+    number, gr; -- { serverError NOT_IMPLEMENTED }\n+\n+SELECT\n+    number,\n+    grouping(number, number % 2) as gr\n+FROM remote('127.0.0.{2,3}', numbers(10))\n+GROUP BY\n+    ROLLUP(number, number % 2) WITH TOTALS\n+ORDER BY\n+    number, gr;\n",
  "problem_statement": "GROUPING aggregate function\n**Use case**\r\nHave ability to distinguish rows being produced by GROUP BY and ROLLUP / CUBE.\r\n\r\n**Describe the solution you'd like**\r\nJust like in oracle or other databases.\r\nhttps://oracle-base.com/articles/misc/rollup-cube-grouping-functions-and-grouping-sets\r\n\r\n**Describe alternatives you've considered**\r\nUsing nulls as suggested in https://github.com/ClickHouse/ClickHouse/issues/8091#issuecomment-563725443, but it's not always applicable.\r\n\r\n**Additional context**\r\nhttps://github.com/ClickHouse/ClickHouse/issues/8091\r\n\n",
  "hints_text": "GROUP BY GROUPING SETS also needed\nIt's being implemented by @MaxTheHuman (just started).\nwip pr https://github.com/ClickHouse/ClickHouse/pull/24172",
  "created_at": "2022-05-12T16:43:05Z"
}