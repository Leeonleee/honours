diff --git a/src/Core/ColumnNumbers.h b/src/Core/ColumnNumbers.h
index 37507a6d683e..51054435e17d 100644
--- a/src/Core/ColumnNumbers.h
+++ b/src/Core/ColumnNumbers.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <unordered_set>
 #include <vector>
 
 
@@ -7,6 +8,8 @@ namespace DB
 {
 
 using ColumnNumbers = std::vector<size_t>;
+using ColumnNumbersSet = std::unordered_set<size_t>;
 using ColumnNumbersList = std::vector<ColumnNumbers>;
+using ColumnNumbersSetList = std::vector<ColumnNumbersSet>;
 
 }
diff --git a/src/Core/Names.h b/src/Core/Names.h
index 3281daa560e6..003168bde277 100644
--- a/src/Core/Names.h
+++ b/src/Core/Names.h
@@ -16,6 +16,7 @@ using NameOrderedSet = std::set<std::string>;
 using NameToNameMap = std::unordered_map<std::string, std::string>;
 using NameToNameSetMap = std::unordered_map<std::string, NameSet>;
 using NameToNameVector = std::vector<std::pair<std::string, std::string>>;
+using NameToIndexMap = std::unordered_map<std::string, size_t>;
 
 using NameWithAlias = std::pair<std::string, std::string>;
 using NamesWithAliases = std::vector<NameWithAlias>;
diff --git a/src/Core/NamesAndTypes.cpp b/src/Core/NamesAndTypes.cpp
index bd24a9e82bdb..72768ce23fb0 100644
--- a/src/Core/NamesAndTypes.cpp
+++ b/src/Core/NamesAndTypes.cpp
@@ -1,3 +1,4 @@
+#include <cstddef>
 #include <Core/NamesAndTypes.h>
 
 #include <base/sort.h>
@@ -214,4 +215,17 @@ std::optional<NameAndTypePair> NamesAndTypesList::tryGetByName(const std::string
     }
     return {};
 }
+
+size_t NamesAndTypesList::getPosByName(const std::string &name) const noexcept
+{
+    size_t pos = 0;
+    for (const NameAndTypePair & column : *this)
+    {
+        if (column.name == name)
+            break;
+        ++pos;
+    }
+    return pos;
+}
+
 }
diff --git a/src/Core/NamesAndTypes.h b/src/Core/NamesAndTypes.h
index 2719017a7269..b9c03aae0caf 100644
--- a/src/Core/NamesAndTypes.h
+++ b/src/Core/NamesAndTypes.h
@@ -105,8 +105,11 @@ class NamesAndTypesList : public std::list<NameAndTypePair>
     /// Check that column contains in list
     bool contains(const String & name) const;
 
-    /// Try to get column by name, return empty optional if column not found
+    /// Try to get column by name, returns empty optional if column not found
     std::optional<NameAndTypePair> tryGetByName(const std::string & name) const;
+
+    /// Try to get column position by name, returns number of columns if column isn't found
+    size_t getPosByName(const std::string & name) const noexcept;
 };
 
 using NamesAndTypesLists = std::vector<NamesAndTypesList>;
diff --git a/src/Functions/grouping.h b/src/Functions/grouping.h
new file mode 100644
index 000000000000..a49e946b2cb3
--- /dev/null
+++ b/src/Functions/grouping.h
@@ -0,0 +1,165 @@
+#pragma once
+
+#include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnArray.h>
+#include <Columns/ColumnConst.h>
+#include <Columns/ColumnFixedString.h>
+#include <Core/ColumnNumbers.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/IFunction.h>
+
+namespace DB
+{
+
+class FunctionGroupingBase : public IFunction
+{
+protected:
+    static constexpr UInt64 ONE = 1;
+
+    const ColumnNumbers arguments_indexes;
+
+public:
+    FunctionGroupingBase(ColumnNumbers arguments_indexes_)
+        : arguments_indexes(std::move(arguments_indexes_))
+    {}
+
+    bool isVariadic() const override { return true; }
+
+    size_t getNumberOfArguments() const override { return 0; }
+
+    bool useDefaultImplementationForNulls() const override { return false; }
+
+    bool isSuitableForConstantFolding() const override { return false; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override
+    {
+        return std::make_shared<DataTypeUInt64>();
+    }
+
+    template <typename AggregationKeyChecker>
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, size_t input_rows_count, AggregationKeyChecker checker) const
+    {
+        const auto * grouping_set_column = checkAndGetColumn<ColumnUInt64>(arguments[0].column.get());
+
+        auto result = ColumnUInt64::create();
+        auto & result_data = result->getData();
+        result_data.reserve(input_rows_count);
+        for (size_t i = 0; i < input_rows_count; ++i)
+        {
+            UInt64 set_index = grouping_set_column->getElement(i);
+
+            UInt64 value = 0;
+            for (auto index : arguments_indexes)
+                value = (value << 1) + (checker(set_index, index) ? 1 : 0);
+
+            result_data.push_back(value);
+        }
+        return result;
+    }
+};
+
+class FunctionGroupingOrdinary : public FunctionGroupingBase
+{
+public:
+    explicit FunctionGroupingOrdinary(ColumnNumbers arguments_indexes_)
+        : FunctionGroupingBase(std::move(arguments_indexes_))
+    {}
+
+    String getName() const override { return "groupingOrdinary"; }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        UInt64 value = (ONE << arguments_indexes.size()) - 1;
+        return ColumnUInt64::create(input_rows_count, value);
+    }
+};
+
+class FunctionGroupingForRollup : public FunctionGroupingBase
+{
+    const UInt64 aggregation_keys_number;
+
+public:
+    FunctionGroupingForRollup(ColumnNumbers arguments_indexes_, UInt64 aggregation_keys_number_)
+        : FunctionGroupingBase(std::move(arguments_indexes_))
+        , aggregation_keys_number(aggregation_keys_number_)
+    {}
+
+    String getName() const override { return "groupingForRollup"; }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,
+            [this](UInt64 set_index, UInt64 arg_index)
+            {
+                // For ROLLUP(a, b, c) there will be following grouping set indexes:
+                // | GROUPING SET | INDEX |
+                // | (a, b, c)    |   0   |
+                // | (a, b)       |   1   |
+                // | (a)          |   2   |
+                // | ()           |   3   |
+                return arg_index < aggregation_keys_number - set_index;
+            }
+        );
+    }
+};
+
+class FunctionGroupingForCube : public FunctionGroupingBase
+{
+    const UInt64 aggregation_keys_number;
+
+public:
+
+    FunctionGroupingForCube(ColumnNumbers arguments_indexes_, UInt64 aggregation_keys_number_)
+        : FunctionGroupingBase(arguments_indexes_)
+        , aggregation_keys_number(aggregation_keys_number_)
+    {}
+
+    String getName() const override { return "groupingForCube"; }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,
+            [this](UInt64 set_index, UInt64 arg_index)
+            {
+                // For CUBE(a, b) there will be following grouping set indexes:
+                // | GROUPING SET | INDEX |
+                // | (a, b)       |   0   |
+                // | (a)          |   1   |
+                // | (b)          |   2   |
+                // | ()           |   3   |
+                auto set_mask = (ONE << aggregation_keys_number) - 1 - set_index;
+                return set_mask & (ONE << (aggregation_keys_number - arg_index - 1));
+            }
+        );
+    }
+};
+
+class FunctionGroupingForGroupingSets : public FunctionGroupingBase
+{
+    ColumnNumbersSetList grouping_sets;
+public:
+    FunctionGroupingForGroupingSets(ColumnNumbers arguments_indexes_, ColumnNumbersList const & grouping_sets_)
+        : FunctionGroupingBase(std::move(arguments_indexes_))
+    {
+        for (auto const & set : grouping_sets_)
+            grouping_sets.emplace_back(set.begin(), set.end());
+    }
+
+    String getName() const override { return "groupingForGroupingSets"; }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        return FunctionGroupingBase::executeImpl(arguments, input_rows_count,
+            [this](UInt64 set_index, UInt64 arg_index)
+            {
+                return grouping_sets[set_index].contains(arg_index);
+            }
+        );
+    }
+};
+
+}
diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index c57b85951bc9..99d2217cba3e 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -1,6 +1,12 @@
+#include <memory>
 #include <Common/quoteString.h>
 #include <Common/typeid_cast.h>
+#include <Columns/ColumnArray.h>
+#include <Columns/ColumnFixedString.h>
+#include <Core/ColumnNumbers.h>
+#include <Core/ColumnWithTypeAndName.h>
 
+#include <Functions/grouping.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionsMiscellaneous.h>
 
@@ -8,10 +14,12 @@
 
 #include <DataTypes/DataTypeSet.h>
 #include <DataTypes/DataTypeFunction.h>
+#include <DataTypes/DataTypeFixedString.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeLowCardinality.h>
+#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/FieldToDataType.h>
 
 #include <Columns/ColumnSet.h>
@@ -56,6 +64,9 @@ namespace ErrorCodes
     extern const int INCORRECT_ELEMENT_OF_SET;
     extern const int BAD_ARGUMENTS;
     extern const int DUPLICATE_COLUMN;
+    extern const int LOGICAL_ERROR;
+    extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;
+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
 }
 
 static NamesAndTypesList::iterator findColumn(const String & name, NamesAndTypesList & cols)
@@ -459,10 +470,18 @@ class ScopeStack::Index
 };
 
 ActionsMatcher::Data::Data(
-    ContextPtr context_, SizeLimits set_size_limit_, size_t subquery_depth_,
-    const NamesAndTypesList & source_columns_, ActionsDAGPtr actions_dag,
-    PreparedSets & prepared_sets_, SubqueriesForSets & subqueries_for_sets_,
-    bool no_subqueries_, bool no_makeset_, bool only_consts_, bool create_source_for_in_)
+    ContextPtr context_,
+    SizeLimits set_size_limit_,
+    size_t subquery_depth_,
+    std::reference_wrapper<const NamesAndTypesList> source_columns_,
+    ActionsDAGPtr actions_dag,
+    PreparedSets & prepared_sets_,
+    SubqueriesForSets & subqueries_for_sets_,
+    bool no_subqueries_,
+    bool no_makeset_,
+    bool only_consts_,
+    bool create_source_for_in_,
+    AggregationKeysInfo aggregation_keys_info_)
     : WithContext(context_)
     , set_size_limit(set_size_limit_)
     , subquery_depth(subquery_depth_)
@@ -475,6 +494,7 @@ ActionsMatcher::Data::Data(
     , create_source_for_in(create_source_for_in_)
     , visit_depth(0)
     , actions_stack(std::move(actions_dag), context_)
+    , aggregation_keys_info(aggregation_keys_info_)
     , next_unique_suffix(actions_stack.getLastActions().getIndex().size() + 1)
 {
 }
@@ -817,6 +837,52 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
         return;
     }
 
+    if (node.name == "grouping")
+    {
+        size_t arguments_size = node.arguments->children.size();
+        if (arguments_size == 0)
+            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION, "Function GROUPING expects at least one argument");
+        if (arguments_size > 64)
+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, "Function GROUPING can have up to 64 arguments, but {} provided", arguments_size);
+        auto keys_info = data.aggregation_keys_info;
+        auto aggregation_keys_number = keys_info.aggregation_keys.size();
+
+        ColumnNumbers arguments_indexes;
+        for (auto const & arg : node.arguments->children)
+        {
+            size_t pos = keys_info.aggregation_keys.getPosByName(arg->getColumnName());
+            if (pos == aggregation_keys_number)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Argument of GROUPING function {} is not a part of GROUP BY clause", arg->getColumnName());
+            arguments_indexes.push_back(pos);
+        }
+
+        switch (keys_info.group_by_kind)
+        {
+            case GroupByKind::GROUPING_SETS:
+            {
+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForGroupingSets>(std::move(arguments_indexes), keys_info.grouping_set_keys)), { "__grouping_set" }, column_name);
+                break;
+            }
+            case GroupByKind::ROLLUP:
+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForRollup>(std::move(arguments_indexes), aggregation_keys_number)), { "__grouping_set" }, column_name);
+                break;
+            case GroupByKind::CUBE:
+            {
+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingForCube>(std::move(arguments_indexes), aggregation_keys_number)), { "__grouping_set" }, column_name);
+                break;
+            }
+            case GroupByKind::ORDINARY:
+            {
+                data.addFunction(std::make_shared<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionGroupingOrdinary>(std::move(arguments_indexes))), {}, column_name);
+                break;
+            }
+            default:
+                throw Exception(ErrorCodes::LOGICAL_ERROR,
+                    "Unexpected kind of GROUP BY clause for GROUPING function: {}", keys_info.group_by_kind);
+        }
+        return;
+    }
+
     SetPtr prepared_set;
     if (checkFunctionIsInOrGlobalInOperator(node))
     {
diff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h
index d1558cb961ca..5a74124192c2 100644
--- a/src/Interpreters/ActionsVisitor.h
+++ b/src/Interpreters/ActionsVisitor.h
@@ -1,10 +1,12 @@
 #pragma once
 
+#include <Core/NamesAndTypes.h>
 #include <Interpreters/Context_fwd.h>
 #include <Interpreters/InDepthNodeVisitor.h>
 #include <Interpreters/PreparedSets.h>
 #include <Interpreters/SubqueryForSet.h>
 #include <Parsers/IAST.h>
+#include <Core/ColumnNumbers.h>
 
 
 namespace DB
@@ -76,6 +78,42 @@ class ASTIdentifier;
 class ASTFunction;
 class ASTLiteral;
 
+enum class GroupByKind
+{
+    NONE,
+    ORDINARY,
+    ROLLUP,
+    CUBE,
+    GROUPING_SETS,
+};
+
+/*
+ * This class stores information about aggregation keys used in GROUP BY clause.
+ * It's used for providing information about aggregation to GROUPING function
+ * implementation.
+*/
+struct AggregationKeysInfo
+{
+    AggregationKeysInfo(
+        std::reference_wrapper<const NamesAndTypesList> aggregation_keys_,
+        std::reference_wrapper<const ColumnNumbersList> grouping_set_keys_,
+        GroupByKind group_by_kind_)
+        : aggregation_keys(aggregation_keys_)
+        , grouping_set_keys(grouping_set_keys_)
+        , group_by_kind(group_by_kind_)
+    {}
+
+    AggregationKeysInfo(const AggregationKeysInfo &) = default;
+    AggregationKeysInfo(AggregationKeysInfo &&) = default;
+
+    // Names and types of all used keys
+    const NamesAndTypesList & aggregation_keys;
+    // Indexes of aggregation keys used in each grouping set (only for GROUP BY GROUPING SETS)
+    const ColumnNumbersList & grouping_set_keys;
+
+    GroupByKind group_by_kind;
+};
+
 /// Collect ExpressionAction from AST. Returns PreparedSets and SubqueriesForSets too.
 class ActionsMatcher
 {
@@ -95,6 +133,7 @@ class ActionsMatcher
         bool create_source_for_in;
         size_t visit_depth;
         ScopeStack actions_stack;
+        AggregationKeysInfo aggregation_keys_info;
 
         /*
          * Remember the last unique column suffix to avoid quadratic behavior
@@ -107,14 +146,15 @@ class ActionsMatcher
             ContextPtr context_,
             SizeLimits set_size_limit_,
             size_t subquery_depth_,
-            const NamesAndTypesList & source_columns_,
+            std::reference_wrapper<const NamesAndTypesList> source_columns_,
             ActionsDAGPtr actions_dag,
             PreparedSets & prepared_sets_,
             SubqueriesForSets & subqueries_for_sets_,
             bool no_subqueries_,
             bool no_makeset_,
             bool only_consts_,
-            bool create_source_for_in_);
+            bool create_source_for_in_,
+            AggregationKeysInfo aggregation_keys_info_);
 
         /// Does result of the calculation already exists in the block.
         bool hasColumn(const String & column_name) const;
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 0b1154f6fd14..699f73abd67f 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -43,10 +43,13 @@
 
 #include <Common/typeid_cast.h>
 #include <Common/StringUtils/StringUtils.h>
+#include <Core/ColumnNumbers.h>
+#include <Core/Names.h>
 #include <Core/NamesAndTypes.h>
 
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeFactory.h>
+#include <DataTypes/DataTypeFixedString.h>
 
 #include <Interpreters/ActionsVisitor.h>
 #include <Interpreters/GetAggregatesVisitor.h>
@@ -325,12 +328,21 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)
     {
         if (ASTPtr group_by_ast = select_query->groupBy())
         {
-            NameSet unique_keys;
+            NameToIndexMap unique_keys;
             ASTs & group_asts = group_by_ast->children;
 
+            if (select_query->group_by_with_rollup)
+                group_by_kind = GroupByKind::ROLLUP;
+            else if (select_query->group_by_with_cube)
+                group_by_kind = GroupByKind::CUBE;
+            else if (select_query->group_by_with_grouping_sets && group_asts.size() > 1)
+                group_by_kind = GroupByKind::GROUPING_SETS;
+            else
+                group_by_kind = GroupByKind::ORDINARY;
+
             /// For GROUPING SETS with multiple groups we always add virtual __grouping_set column
             /// With set number, which is used as an additional key at the stage of merging aggregating data.
-            if (select_query->group_by_with_grouping_sets && group_asts.size() > 1)
+            if (group_by_kind != GroupByKind::ORDINARY)
                 aggregated_columns.emplace_back("__grouping_set", std::make_shared<DataTypeUInt64>());
 
             for (ssize_t i = 0; i < static_cast<ssize_t>(group_asts.size()); ++i)
@@ -347,6 +359,7 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)
                     group_elements_ast = group_ast_element->children;
 
                     NamesAndTypesList grouping_set_list;
+                    ColumnNumbers grouping_set_indexes_list;
 
                     for (ssize_t j = 0; j < ssize_t(group_elements_ast.size()); ++j)
                     {
@@ -387,15 +400,21 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)
                         /// Aggregation keys are unique.
                         if (!unique_keys.contains(key.name))
                         {
-                            unique_keys.insert(key.name);
+                            unique_keys[key.name] = aggregation_keys.size();
+                            grouping_set_indexes_list.push_back(aggregation_keys.size());
                             aggregation_keys.push_back(key);
 
                             /// Key is no longer needed, therefore we can save a little by moving it.
                             aggregated_columns.push_back(std::move(key));
                         }
+                        else
+                        {
+                            grouping_set_indexes_list.push_back(unique_keys[key.name]);
+                        }
                     }
 
                     aggregation_keys_list.push_back(std::move(grouping_set_list));
+                    aggregation_keys_indexes_list.push_back(std::move(grouping_set_indexes_list));
                 }
                 else
                 {
@@ -433,7 +452,7 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)
                     /// Aggregation keys are uniqued.
                     if (!unique_keys.contains(key.name))
                     {
-                        unique_keys.insert(key.name);
+                        unique_keys[key.name] = aggregation_keys.size();
                         aggregation_keys.push_back(key);
 
                         /// Key is no longer needed, therefore we can save a little by moving it.
@@ -442,6 +461,13 @@ void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)
                 }
             }
 
+            if (!select_query->group_by_with_grouping_sets)
+            {
+                auto & list = aggregation_keys_indexes_list.emplace_back();
+                for (size_t i = 0; i < aggregation_keys.size(); ++i)
+                    list.push_back(i);
+            }
+
             if (group_asts.empty())
             {
                 select_query->setExpression(ASTSelectQuery::Expression::GROUP_BY, {});
@@ -583,7 +609,8 @@ void ExpressionAnalyzer::getRootActions(const ASTPtr & ast, bool no_makeset_for_
         no_makeset_for_subqueries,
         false /* no_makeset */,
         only_consts,
-        !isRemoteStorage() /* create_source_for_in */);
+        !isRemoteStorage() /* create_source_for_in */,
+        getAggregationKeysInfo());
     ActionsVisitor(visitor_data, log.stream()).visit(ast);
     actions = visitor_data.getActions();
 }
@@ -603,7 +630,8 @@ void ExpressionAnalyzer::getRootActionsNoMakeSet(const ASTPtr & ast, ActionsDAGP
         true /* no_makeset_for_subqueries, no_makeset implies no_makeset_for_subqueries */,
         true /* no_makeset */,
         only_consts,
-        !isRemoteStorage() /* create_source_for_in */);
+        !isRemoteStorage() /* create_source_for_in */,
+        getAggregationKeysInfo());
     ActionsVisitor(visitor_data, log.stream()).visit(ast);
     actions = visitor_data.getActions();
 }
@@ -624,7 +652,8 @@ void ExpressionAnalyzer::getRootActionsForHaving(
         no_makeset_for_subqueries,
         false /* no_makeset */,
         only_consts,
-        true /* create_source_for_in */);
+        true /* create_source_for_in */,
+        getAggregationKeysInfo());
     ActionsVisitor(visitor_data, log.stream()).visit(ast);
     actions = visitor_data.getActions();
 }
diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h
index 85efb3829d04..971fe7539784 100644
--- a/src/Interpreters/ExpressionAnalyzer.h
+++ b/src/Interpreters/ExpressionAnalyzer.h
@@ -1,6 +1,8 @@
 #pragma once
 
+#include <Core/ColumnNumbers.h>
 #include <Columns/FilterDescription.h>
+#include <Interpreters/ActionsVisitor.h>
 #include <Interpreters/AggregateDescription.h>
 #include <Interpreters/DatabaseCatalog.h>
 #include <Interpreters/SubqueryForSet.h>
@@ -67,6 +69,7 @@ struct ExpressionAnalyzerData
     bool has_aggregation = false;
     NamesAndTypesList aggregation_keys;
     NamesAndTypesLists aggregation_keys_list;
+    ColumnNumbersList aggregation_keys_indexes_list;
     bool has_const_aggregation_keys = false;
     AggregateDescriptions aggregate_descriptions;
 
@@ -77,6 +80,8 @@ struct ExpressionAnalyzerData
 
     /// All new temporary tables obtained by performing the GLOBAL IN/JOIN subqueries.
     TemporaryTablesMapping external_tables;
+
+    GroupByKind group_by_kind = GroupByKind::NONE;
 };
 
 
@@ -200,6 +205,11 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc
 
     NamesAndTypesList getColumnsAfterArrayJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);
     NamesAndTypesList analyzeJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);
+
+    AggregationKeysInfo getAggregationKeysInfo() const noexcept
+    {
+      return { aggregation_keys, aggregation_keys_indexes_list, group_by_kind };
+    }
 };
 
 class SelectQueryExpressionAnalyzer;
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 5eaeecb93731..19fdb9a3a570 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -1095,6 +1095,9 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P
     if (query.group_by_with_grouping_sets && query.group_by_with_totals)
        throw Exception("WITH TOTALS and GROUPING SETS are not supported together", ErrorCodes::NOT_IMPLEMENTED);
 
+    if (expressions.hasHaving() && query.group_by_with_totals && (query.group_by_with_rollup || query.group_by_with_cube))
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of HAVING");
+
     if (query_info.projection && query_info.projection->desc->type == ProjectionDescription::Type::Aggregate)
     {
         query_info.projection->aggregate_overflow_row = aggregate_overflow_row;
@@ -1387,11 +1390,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P
                         executeRollupOrCube(query_plan, Modificator::CUBE);
 
                     if ((query.group_by_with_rollup || query.group_by_with_cube || query.group_by_with_grouping_sets) && expressions.hasHaving())
-                    {
-                        if (query.group_by_with_totals)
-                            throw Exception("WITH TOTALS and WITH ROLLUP or CUBE or GROUPING SETS are not supported together in presence of HAVING", ErrorCodes::NOT_IMPLEMENTED);
                         executeHaving(query_plan, expressions.before_having, expressions.remove_having_filter);
-                    }
                 }
                 else if (expressions.hasHaving())
                     executeHaving(query_plan, expressions.before_having, expressions.remove_having_filter);
diff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h
index 704aeeeea7cc..084627b57a1e 100644
--- a/src/Parsers/ASTSelectQuery.h
+++ b/src/Parsers/ASTSelectQuery.h
@@ -95,22 +95,22 @@ class ASTSelectQuery : public IAST
     ASTPtr & refWhere()     { return getExpression(Expression::WHERE); }
     ASTPtr & refHaving()    { return getExpression(Expression::HAVING); }
 
-    const ASTPtr with()           const { return getExpression(Expression::WITH); }
-    const ASTPtr select()         const { return getExpression(Expression::SELECT); }
-    const ASTPtr tables()         const { return getExpression(Expression::TABLES); }
-    const ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }
-    const ASTPtr where()          const { return getExpression(Expression::WHERE); }
-    const ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }
-    const ASTPtr having()         const { return getExpression(Expression::HAVING); }
-    const ASTPtr window()         const { return getExpression(Expression::WINDOW); }
-    const ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }
-    const ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }
-    const ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }
-    const ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }
-    const ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }
-    const ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }
-    const ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }
-    const ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }
+    ASTPtr with()           const { return getExpression(Expression::WITH); }
+    ASTPtr select()         const { return getExpression(Expression::SELECT); }
+    ASTPtr tables()         const { return getExpression(Expression::TABLES); }
+    ASTPtr prewhere()       const { return getExpression(Expression::PREWHERE); }
+    ASTPtr where()          const { return getExpression(Expression::WHERE); }
+    ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }
+    ASTPtr having()         const { return getExpression(Expression::HAVING); }
+    ASTPtr window()         const { return getExpression(Expression::WINDOW); }
+    ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }
+    ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }
+    ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }
+    ASTPtr limitBy()        const { return getExpression(Expression::LIMIT_BY); }
+    ASTPtr limitOffset()    const { return getExpression(Expression::LIMIT_OFFSET); }
+    ASTPtr limitLength()    const { return getExpression(Expression::LIMIT_LENGTH); }
+    ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }
+    ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }
 
     bool hasFiltration() const { return where() || prewhere() || having(); }
 
diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index 633b8c2e35a3..822bdf8d72af 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -803,6 +803,20 @@ namespace
         node = makeASTFunction("exists", subquery);
         return true;
     }
+
+    bool parseGrouping(IParser::Pos & pos, ASTPtr & node, Expected & expected)
+    {
+        ASTPtr expr_list;
+        if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))
+            return false;
+
+        auto res = std::make_shared<ASTFunction>();
+        res->name = "grouping";
+        res->arguments = expr_list;
+        res->children.push_back(res->arguments);
+        node = std::move(res);
+        return true;
+    }
 }
 
 
@@ -888,6 +902,8 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     else if (function_name_lowercase == "datediff" || function_name_lowercase == "date_diff"
         || function_name_lowercase == "timestampdiff" || function_name_lowercase == "timestamp_diff")
         parsed_special_function = parseDateDiff(pos, node, expected);
+    else if (function_name_lowercase == "grouping")
+        parsed_special_function = parseGrouping(pos, node, expected);
 
     if (parsed_special_function.has_value())
         return parsed_special_function.value() && ParserToken(TokenType::ClosingRoundBracket).ignore(pos);
diff --git a/src/Processors/QueryPlan/AggregatingStep.cpp b/src/Processors/QueryPlan/AggregatingStep.cpp
index 50acc0852570..4114eff5c56c 100644
--- a/src/Processors/QueryPlan/AggregatingStep.cpp
+++ b/src/Processors/QueryPlan/AggregatingStep.cpp
@@ -12,7 +12,9 @@
 #include <Processors/Merges/FinishAggregatingInOrderTransform.h>
 #include <Interpreters/Aggregator.h>
 #include <Processors/QueryPlan/IQueryPlanStep.h>
+#include <Columns/ColumnFixedString.h>
 #include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypeFixedString.h>
 
 namespace DB
 {
@@ -33,6 +35,17 @@ static ITransformingStep::Traits getTraits()
     };
 }
 
+Block appendGroupingSetColumn(Block header)
+{
+    Block res;
+    res.insert({std::make_shared<DataTypeUInt64>(), "__grouping_set"});
+
+    for (auto & col : header)
+        res.insert(std::move(col));
+
+    return res;
+}
+
 static Block appendGroupingColumn(Block block, const GroupingSetsParamsList & params)
 {
     if (params.empty())
diff --git a/src/Processors/QueryPlan/AggregatingStep.h b/src/Processors/QueryPlan/AggregatingStep.h
index b933daaa474c..4dd3d9563506 100644
--- a/src/Processors/QueryPlan/AggregatingStep.h
+++ b/src/Processors/QueryPlan/AggregatingStep.h
@@ -25,6 +25,8 @@ struct GroupingSetsParams
 
 using GroupingSetsParamsList = std::vector<GroupingSetsParams>;
 
+Block appendGroupingSetColumn(Block header);
+
 /// Aggregation. See AggregatingTransform.
 class AggregatingStep : public ITransformingStep
 {
diff --git a/src/Processors/QueryPlan/CubeStep.cpp b/src/Processors/QueryPlan/CubeStep.cpp
index 23c5115ec680..91c85a08412d 100644
--- a/src/Processors/QueryPlan/CubeStep.cpp
+++ b/src/Processors/QueryPlan/CubeStep.cpp
@@ -1,6 +1,9 @@
 #include <Processors/QueryPlan/CubeStep.h>
 #include <Processors/Transforms/CubeTransform.h>
+#include <Processors/Transforms/ExpressionTransform.h>
+#include <Processors/QueryPlan/AggregatingStep.h>
 #include <QueryPipeline/QueryPipelineBuilder.h>
+#include <DataTypes/DataTypesNumber.h>
 
 namespace DB
 {
@@ -22,7 +25,8 @@ static ITransformingStep::Traits getTraits()
 }
 
 CubeStep::CubeStep(const DataStream & input_stream_, AggregatingTransformParamsPtr params_)
-    : ITransformingStep(input_stream_, params_->getHeader(), getTraits())
+    : ITransformingStep(input_stream_, appendGroupingSetColumn(params_->getHeader()), getTraits())
+    , keys_size(params_->params.keys_size)
     , params(std::move(params_))
 {
     /// Aggregation keys are distinct
@@ -30,14 +34,30 @@ CubeStep::CubeStep(const DataStream & input_stream_, AggregatingTransformParamsP
         output_stream->distinct_columns.insert(params->params.src_header.getByPosition(key).name);
 }
 
-void CubeStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)
+ProcessorPtr addGroupingSetForTotals(const Block & header, const BuildQueryPipelineSettings & settings, UInt64 grouping_set_number)
+{
+    auto dag = std::make_shared<ActionsDAG>(header.getColumnsWithTypeAndName());
+
+    auto grouping_col = ColumnUInt64::create(1, grouping_set_number);
+    const auto * grouping_node = &dag->addColumn(
+        {ColumnPtr(std::move(grouping_col)), std::make_shared<DataTypeUInt64>(), "__grouping_set"});
+
+    grouping_node = &dag->materializeNode(*grouping_node);
+    auto & index = dag->getIndex();
+    index.insert(index.begin(), grouping_node);
+
+    auto expression = std::make_shared<ExpressionActions>(dag, settings.getActionsSettings());
+    return std::make_shared<ExpressionTransform>(header, expression);
+}
+
+void CubeStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings)
 {
     pipeline.resize(1);
 
     pipeline.addSimpleTransform([&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr
     {
         if (stream_type == QueryPipelineBuilder::StreamType::Totals)
-            return nullptr;
+            return addGroupingSetForTotals(header, settings, (UInt64(1) << keys_size) - 1);
 
         return std::make_shared<CubeTransform>(header, std::move(params));
     });
diff --git a/src/Processors/QueryPlan/CubeStep.h b/src/Processors/QueryPlan/CubeStep.h
index 1079bed53980..d3e26f9379f2 100644
--- a/src/Processors/QueryPlan/CubeStep.h
+++ b/src/Processors/QueryPlan/CubeStep.h
@@ -21,6 +21,7 @@ class CubeStep : public ITransformingStep
 
     const Aggregator::Params & getParams() const;
 private:
+    size_t keys_size;
     AggregatingTransformParamsPtr params;
 };
 
diff --git a/src/Processors/QueryPlan/RollupStep.cpp b/src/Processors/QueryPlan/RollupStep.cpp
index acaeb2bc9a74..3b061f9c2460 100644
--- a/src/Processors/QueryPlan/RollupStep.cpp
+++ b/src/Processors/QueryPlan/RollupStep.cpp
@@ -1,6 +1,7 @@
 #include <Processors/QueryPlan/RollupStep.h>
 #include <Processors/Transforms/RollupTransform.h>
 #include <QueryPipeline/QueryPipelineBuilder.h>
+#include <Processors/QueryPlan/AggregatingStep.h>
 
 namespace DB
 {
@@ -22,22 +23,25 @@ static ITransformingStep::Traits getTraits()
 }
 
 RollupStep::RollupStep(const DataStream & input_stream_, AggregatingTransformParamsPtr params_)
-    : ITransformingStep(input_stream_, params_->getHeader(), getTraits())
+    : ITransformingStep(input_stream_, appendGroupingSetColumn(params_->getHeader()), getTraits())
     , params(std::move(params_))
+    , keys_size(params->params.keys_size)
 {
     /// Aggregation keys are distinct
     for (auto key : params->params.keys)
         output_stream->distinct_columns.insert(params->params.src_header.getByPosition(key).name);
 }
 
-void RollupStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)
+ProcessorPtr addGroupingSetForTotals(const Block & header, const BuildQueryPipelineSettings & settings, UInt64 grouping_set_number);
+
+void RollupStep::transformPipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings)
 {
     pipeline.resize(1);
 
     pipeline.addSimpleTransform([&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr
     {
         if (stream_type == QueryPipelineBuilder::StreamType::Totals)
-            return nullptr;
+            return addGroupingSetForTotals(header, settings, keys_size);
 
         return std::make_shared<RollupTransform>(header, std::move(params));
     });
diff --git a/src/Processors/QueryPlan/RollupStep.h b/src/Processors/QueryPlan/RollupStep.h
index 7cd71fecdc17..3dce6f74d9f8 100644
--- a/src/Processors/QueryPlan/RollupStep.h
+++ b/src/Processors/QueryPlan/RollupStep.h
@@ -20,6 +20,7 @@ class RollupStep : public ITransformingStep
 
 private:
     AggregatingTransformParamsPtr params;
+    size_t keys_size;
 };
 
 }
diff --git a/src/Processors/Transforms/CubeTransform.cpp b/src/Processors/Transforms/CubeTransform.cpp
index 6b672407cd1e..c699e724ffc6 100644
--- a/src/Processors/Transforms/CubeTransform.cpp
+++ b/src/Processors/Transforms/CubeTransform.cpp
@@ -1,5 +1,6 @@
 #include <Processors/Transforms/CubeTransform.h>
 #include <Processors/Transforms/TotalsHavingTransform.h>
+#include <Processors/QueryPlan/AggregatingStep.h>
 
 namespace DB
 {
@@ -9,7 +10,7 @@ namespace ErrorCodes
 }
 
 CubeTransform::CubeTransform(Block header, AggregatingTransformParamsPtr params_)
-    : IAccumulatingTransform(std::move(header), params_->getHeader())
+    : IAccumulatingTransform(std::move(header), appendGroupingSetColumn(params_->getHeader()))
     , params(std::move(params_))
     , keys(params->params.keys)
     , aggregates_mask(getAggregatesMask(params->getHeader(), params->params.aggregates))
@@ -75,6 +76,8 @@ Chunk CubeTransform::generate()
     }
 
     finalizeChunk(gen_chunk, aggregates_mask);
+    if (!gen_chunk.empty())
+        gen_chunk.addColumn(0, ColumnUInt64::create(gen_chunk.getNumRows(), grouping_set++));
     return gen_chunk;
 }
 
diff --git a/src/Processors/Transforms/CubeTransform.h b/src/Processors/Transforms/CubeTransform.h
index a1a1c9271c33..4575a01935d6 100644
--- a/src/Processors/Transforms/CubeTransform.h
+++ b/src/Processors/Transforms/CubeTransform.h
@@ -30,6 +30,7 @@ class CubeTransform : public IAccumulatingTransform
     Columns current_zero_columns;
 
     UInt64 mask = 0;
+    UInt64 grouping_set = 0;
 
     Chunk merge(Chunks && chunks, bool final);
 };
diff --git a/src/Processors/Transforms/RollupTransform.cpp b/src/Processors/Transforms/RollupTransform.cpp
index 3150ff99e765..db60b99102d8 100644
--- a/src/Processors/Transforms/RollupTransform.cpp
+++ b/src/Processors/Transforms/RollupTransform.cpp
@@ -1,11 +1,12 @@
 #include <Processors/Transforms/RollupTransform.h>
 #include <Processors/Transforms/TotalsHavingTransform.h>
+#include <Processors/QueryPlan/AggregatingStep.h>
 
 namespace DB
 {
 
 RollupTransform::RollupTransform(Block header, AggregatingTransformParamsPtr params_)
-    : IAccumulatingTransform(std::move(header), params_->getHeader())
+    : IAccumulatingTransform(std::move(header), appendGroupingSetColumn(params_->getHeader()))
     , params(std::move(params_))
     , keys(params->params.keys)
     , aggregates_mask(getAggregatesMask(params->getHeader(), params->params.aggregates))
@@ -58,6 +59,8 @@ Chunk RollupTransform::generate()
     }
 
     finalizeChunk(gen_chunk, aggregates_mask);
+    if (!gen_chunk.empty())
+        gen_chunk.addColumn(0, ColumnUInt64::create(gen_chunk.getNumRows(), set_counter++));
     return gen_chunk;
 }
 
diff --git a/src/Processors/Transforms/RollupTransform.h b/src/Processors/Transforms/RollupTransform.h
index 74e83b8535dd..8fd27e3e6a2c 100644
--- a/src/Processors/Transforms/RollupTransform.h
+++ b/src/Processors/Transforms/RollupTransform.h
@@ -26,6 +26,7 @@ class RollupTransform : public IAccumulatingTransform
     Chunks consumed_chunks;
     Chunk rollup_chunk;
     size_t last_removed_key = 0;
+    size_t set_counter = 0;
 
     Chunk merge(Chunks && chunks, bool final);
 };
diff --git a/src/Storages/VirtualColumnUtils.cpp b/src/Storages/VirtualColumnUtils.cpp
index d0840778c0f4..40cf650f6900 100644
--- a/src/Storages/VirtualColumnUtils.cpp
+++ b/src/Storages/VirtualColumnUtils.cpp
@@ -156,8 +156,13 @@ bool prepareFilterBlockWithQuery(const ASTPtr & query, ContextPtr context, Block
         auto actions = std::make_shared<ActionsDAG>(block.getColumnsWithTypeAndName());
         PreparedSets prepared_sets;
         SubqueriesForSets subqueries_for_sets;
+        const NamesAndTypesList source_columns;
+        const NamesAndTypesList aggregation_keys;
+        const ColumnNumbersList grouping_set_keys;
+
         ActionsVisitor::Data visitor_data(
-            context, SizeLimits{}, 1, {}, std::move(actions), prepared_sets, subqueries_for_sets, true, true, true, false);
+            context, SizeLimits{}, 1, source_columns, std::move(actions), prepared_sets, subqueries_for_sets, true, true, true, false,
+            { aggregation_keys, grouping_set_keys, GroupByKind::NONE });
         ActionsVisitor(visitor_data).visit(node);
         actions = visitor_data.getActions();
         auto expression_actions = std::make_shared<ExpressionActions>(actions);
