{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 2405,
  "instance_id": "ClickHouse__ClickHouse-2405",
  "issue_numbers": [
    "2315"
  ],
  "base_commit": "ce219a3d9e2edd65c0d6c83442bfb24ca8c4a4be",
  "patch": "diff --git a/dbms/src/Storages/MergeTree/AbandonableLockInZooKeeper.h b/dbms/src/Storages/MergeTree/AbandonableLockInZooKeeper.h\nindex a277eb220f1d..50383e9fbac6 100644\n--- a/dbms/src/Storages/MergeTree/AbandonableLockInZooKeeper.h\n+++ b/dbms/src/Storages/MergeTree/AbandonableLockInZooKeeper.h\n@@ -161,6 +161,15 @@ class AbandonableLockInZooKeeper : public boost::noncopyable\n \n     static void createAbandonedIfNotExists(const String & path, zkutil::ZooKeeper & zookeeper)\n     {\n+        /// Create partition dir if not exists\n+        size_t index = path.find_last_of('/');\n+        if (index != std::string::npos)\n+        {\n+            String dir = path.substr(0, index);\n+            zookeeper.createIfNotExists(dir, \"\");\n+        }\n+\n+        /// Create the node\n         zookeeper.createIfNotExists(path, \"\");\n     }\n \ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\nindex d14e8b1b7ddc..518e2dc117f1 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.h\n@@ -96,11 +96,16 @@ struct ReplicatedMergeTreeLogEntryData\n \n     std::shared_ptr<ReplaceRangeEntry> replace_range_entry;\n \n-    /// Part names that supposed to be added to virtual_parts and future_parts\n-    Strings getVirtualPartNames() const\n+    /// Returns set of parts that will appear after the entry execution\n+    /// These parts are added to virtual_parts\n+    Strings getNewPartNames() const\n     {\n-        /// TODO: Instead of new_part_name use another field for these commands\n-        if (type == DROP_RANGE || type == CLEAR_COLUMN)\n+        /// Clear column actually does not produce new parts\n+        if (type == CLEAR_COLUMN)\n+            return {};\n+\n+        /// It does not add a real part, it just disables merges in that range\n+        if (type == DROP_RANGE)\n             return {new_part_name};\n \n         if (type == REPLACE_RANGE)\n@@ -113,6 +118,18 @@ struct ReplicatedMergeTreeLogEntryData\n         return {new_part_name};\n     }\n \n+    /// Returns set of parts that should be blocked during the entry execution\n+    /// These parts are added to future_parts\n+    Strings getBlockingPartNames() const\n+    {\n+        Strings res = getNewPartNames();\n+\n+        if (type == CLEAR_COLUMN)\n+            res.emplace_back(new_part_name);\n+\n+        return res;\n+    }\n+\n     /// Access under queue_mutex, see ReplicatedMergeTreeQueue.\n     bool currently_executing = false;    /// Whether the action is executing now.\n     /// These several fields are informational only (for viewing by the user using system tables).\n@@ -132,7 +149,7 @@ struct ReplicatedMergeTreeLogEntryData\n };\n \n \n-struct ReplicatedMergeTreeLogEntry : ReplicatedMergeTreeLogEntryData\n+struct ReplicatedMergeTreeLogEntry : public ReplicatedMergeTreeLogEntryData, std::enable_shared_from_this<ReplicatedMergeTreeLogEntry>\n {\n     using Ptr = std::shared_ptr<ReplicatedMergeTreeLogEntry>;\n \n@@ -141,5 +158,7 @@ struct ReplicatedMergeTreeLogEntry : ReplicatedMergeTreeLogEntryData\n     static Ptr parse(const String & s, const zkutil::Stat & stat);\n };\n \n+using ReplicatedMergeTreeLogEntryPtr = std::shared_ptr<ReplicatedMergeTreeLogEntry>;\n+\n \n }\ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreePartCheckThread.cpp b/dbms/src/Storages/MergeTree/ReplicatedMergeTreePartCheckThread.cpp\nindex 598f9ac8b8b1..5cfc72467273 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreePartCheckThread.cpp\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreePartCheckThread.cpp\n@@ -199,10 +199,8 @@ void ReplicatedMergeTreePartCheckThread::searchForMissingPart(const String & par\n     const String & partition_id = part_info.partition_id;\n     for (auto i = part_info.min_block; i <= part_info.max_block; ++i)\n     {\n-        zookeeper->createIfNotExists(storage.zookeeper_path + \"/nonincrement_block_numbers/\" + partition_id, \"\");\n         AbandonableLockInZooKeeper::createAbandonedIfNotExists(\n-            storage.zookeeper_path + \"/nonincrement_block_numbers/\" + partition_id + \"/block-\" + padIndex(i),\n-            *zookeeper);\n+                storage.zookeeper_path + \"/nonincrement_block_numbers/\" + partition_id + \"/block-\" + padIndex(i), *zookeeper);\n     }\n }\n \ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex e358392ffb6f..a645c76bcd69 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -94,7 +94,7 @@ void ReplicatedMergeTreeQueue::initialize(\n \n void ReplicatedMergeTreeQueue::insertUnlocked(LogEntryPtr & entry, std::optional<time_t> & min_unprocessed_insert_time_changed, std::lock_guard<std::mutex> &)\n {\n-    for (const String & virtual_part_name : entry->getVirtualPartNames())\n+    for (const String & virtual_part_name : entry->getNewPartNames())\n         virtual_parts.add(virtual_part_name);\n \n     /// Put 'DROP PARTITION' entries at the beginning of the queue not to make superfluous fetches of parts that will be eventually deleted\n@@ -499,47 +499,45 @@ void ReplicatedMergeTreeQueue::removeGetsAndMergesInRange(zkutil::ZooKeeperPtr z\n }\n \n \n-size_t ReplicatedMergeTreeQueue::getConflictsCountForRange(const MergeTreePartInfo & range, const String & range_znode,\n-    String * out_conflicts_description, std::lock_guard<std::mutex> &) const\n+size_t ReplicatedMergeTreeQueue::getConflictsCountForRange(const MergeTreePartInfo & range, const LogEntry & entry,\n+                                                           String * out_description, std::lock_guard<std::mutex> &) const\n {\n-    std::vector<std::pair<LogEntryPtr, String>> conflicts;\n+    std::vector<std::pair<String, LogEntryPtr>> conflicts;\n \n-    for (auto & elem : queue)\n+    for (auto & future_part_elem : future_parts)\n     {\n-        if (!elem->currently_executing || elem->znode_name == range_znode)\n+        /// Do not check itself log entry\n+        if (future_part_elem.second->znode_name == entry.znode_name)\n             continue;\n \n-        for (const String & new_part_name : elem->getVirtualPartNames())\n+        if (!range.isDisjoint(MergeTreePartInfo::fromPartName(future_part_elem.first, format_version)))\n         {\n-            if (!range.isDisjoint(MergeTreePartInfo::fromPartName(new_part_name, format_version)))\n-            {\n-                conflicts.emplace_back(elem, new_part_name);\n-                continue;\n-            }\n+            conflicts.emplace_back(future_part_elem.first, future_part_elem.second);\n+            continue;\n         }\n     }\n \n-    if (out_conflicts_description)\n+    if (out_description)\n     {\n         std::stringstream ss;\n-        ss << \"Can't execute command for range \" << range.getPartName() << \" (entry \" << range_znode << \"). \";\n+        ss << \"Can't execute command for range \" << range.getPartName() << \" (entry \" << entry.znode_name << \"). \";\n         ss << \"There are \" << conflicts.size() << \" currently executing entries blocking it: \";\n         for (const auto & conflict : conflicts)\n-            ss << conflict.first->typeToString() << \" part \" << conflict.second << \", \";\n+            ss << conflict.second->typeToString() << \" part \" << conflict.first << \", \";\n \n-        *out_conflicts_description = ss.str();\n+        *out_description = ss.str();\n     }\n \n     return conflicts.size();\n }\n \n \n-void ReplicatedMergeTreeQueue::checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const String & range_znode_name)\n+void ReplicatedMergeTreeQueue::checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const LogEntry & entry)\n {\n     String conflicts_description;\n     std::lock_guard<std::mutex> lock(mutex);\n \n-    if (0 != getConflictsCountForRange(range, range_znode_name, &conflicts_description, lock))\n+    if (0 != getConflictsCountForRange(range, entry, &conflicts_description, lock))\n         throw Exception(conflicts_description, ErrorCodes::UNFINISHED);\n }\n \n@@ -565,14 +563,14 @@ bool ReplicatedMergeTreeQueue::isNotCoveredByFuturePartsImpl(const String & new_\n     auto result_part = MergeTreePartInfo::fromPartName(new_part_name, format_version);\n \n     /// It can slow down when the size of `future_parts` is large. But it can not be large, since `BackgroundProcessingPool` is limited.\n-    for (const auto & future_part_name : future_parts)\n+    for (const auto & future_part_elem : future_parts)\n     {\n-        auto future_part = MergeTreePartInfo::fromPartName(future_part_name, format_version);\n+        auto future_part = MergeTreePartInfo::fromPartName(future_part_elem.first, format_version);\n \n         if (future_part.contains(result_part))\n         {\n             out_reason = \"Not executing log entry for part \" + new_part_name + \" because it is covered by part \"\n-                         + future_part_name + \" that is currently executing\";\n+                         + future_part_elem.first + \" that is currently executing\";\n             return false;\n         }\n     }\n@@ -580,7 +578,7 @@ bool ReplicatedMergeTreeQueue::isNotCoveredByFuturePartsImpl(const String & new_\n     return true;\n }\n \n-bool ReplicatedMergeTreeQueue::addFuturePartIfNotCoveredByThem(const String & part_name, const LogEntry & entry, String & reject_reason)\n+bool ReplicatedMergeTreeQueue::addFuturePartIfNotCoveredByThem(const String & part_name, LogEntry & entry, String & reject_reason)\n {\n     std::lock_guard<std::mutex> lock(mutex);\n \n@@ -603,7 +601,7 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(\n {\n     if (entry.type == LogEntry::MERGE_PARTS || entry.type == LogEntry::GET_PART)\n     {\n-        for (const String & new_part_name : entry.getVirtualPartNames())\n+        for (const String & new_part_name : entry.getBlockingPartNames())\n         {\n             if (!isNotCoveredByFuturePartsImpl(new_part_name, out_postpone_reason, lock))\n             {\n@@ -670,7 +668,7 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(\n         String range_name = (entry.type == LogEntry::REPLACE_RANGE) ? entry.replace_range_entry->drop_range_part_name : entry.new_part_name;\n         auto range = MergeTreePartInfo::fromPartName(range_name, format_version);\n \n-        if (0 != getConflictsCountForRange(range, entry.znode_name, &conflicts_description, lock))\n+        if (0 != getConflictsCountForRange(range, entry, &conflicts_description, lock))\n         {\n             LOG_DEBUG(log, conflicts_description);\n             return false;\n@@ -681,22 +679,22 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(\n }\n \n \n-ReplicatedMergeTreeQueue::CurrentlyExecuting::CurrentlyExecuting(ReplicatedMergeTreeQueue::LogEntryPtr & entry, ReplicatedMergeTreeQueue & queue)\n-    : entry(entry), queue(queue)\n+ReplicatedMergeTreeQueue::CurrentlyExecuting::CurrentlyExecuting(const ReplicatedMergeTreeQueue::LogEntryPtr & entry_, ReplicatedMergeTreeQueue & queue)\n+    : entry(entry_), queue(queue)\n {\n     entry->currently_executing = true;\n     ++entry->num_tries;\n     entry->last_attempt_time = time(nullptr);\n \n-    for (const String & new_part_name : entry->getVirtualPartNames())\n+    for (const String & new_part_name : entry->getBlockingPartNames())\n     {\n-        if (!queue.future_parts.insert(new_part_name).second)\n+        if (!queue.future_parts.emplace(new_part_name, entry).second)\n             throw Exception(\"Tagging already tagged future part \" + new_part_name + \". This is a bug.\", ErrorCodes::LOGICAL_ERROR);\n     }\n }\n \n \n-void ReplicatedMergeTreeQueue::CurrentlyExecuting::setActualPartName(const ReplicatedMergeTreeLogEntry & entry,\n+void ReplicatedMergeTreeQueue::CurrentlyExecuting::setActualPartName(ReplicatedMergeTreeQueue::LogEntry & entry,\n                                                                      const String & actual_part_name, ReplicatedMergeTreeQueue & queue)\n {\n     if (!entry.actual_new_part_name.empty())\n@@ -708,8 +706,8 @@ void ReplicatedMergeTreeQueue::CurrentlyExecuting::setActualPartName(const Repli\n     if (entry.actual_new_part_name == entry.new_part_name)\n         return;\n \n-    if (!queue.future_parts.insert(entry.actual_new_part_name).second)\n-        throw Exception(\"Attaching already exsisting future part \" + entry.actual_new_part_name + \". This is a bug.\", ErrorCodes::LOGICAL_ERROR);\n+    if (!queue.future_parts.emplace(entry.actual_new_part_name, entry.shared_from_this()).second)\n+        throw Exception(\"Attaching already existing future part \" + entry.actual_new_part_name + \". This is a bug.\", ErrorCodes::LOGICAL_ERROR);\n }\n \n \n@@ -720,7 +718,7 @@ ReplicatedMergeTreeQueue::CurrentlyExecuting::~CurrentlyExecuting()\n     entry->currently_executing = false;\n     entry->execution_complete.notify_all();\n \n-    for (const String & new_part_name : entry->getVirtualPartNames())\n+    for (const String & new_part_name : entry->getBlockingPartNames())\n     {\n         if (!queue.future_parts.erase(new_part_name))\n             LOG_ERROR(queue.log, \"Untagging already untagged future part \" + new_part_name + \". This is a bug.\");\ndiff --git a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\nindex 55936d0bd3f3..8f1f72c55aec 100644\n--- a/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n+++ b/dbms/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n@@ -23,13 +23,13 @@ class ReplicatedMergeTreeQueue\n private:\n     friend class CurrentlyExecuting;\n \n-    using StringSet = std::set<String>;\n-\n     using LogEntry = ReplicatedMergeTreeLogEntry;\n     using LogEntryPtr = LogEntry::Ptr;\n \n     using Queue = std::list<LogEntryPtr>;\n \n+    using StringSet = std::set<String>;\n+\n     struct ByTime\n     {\n         bool operator()(const LogEntryPtr & lhs, const LogEntryPtr & rhs) const\n@@ -62,7 +62,8 @@ class ReplicatedMergeTreeQueue\n \n     /// parts that will appear as a result of actions performed right now by background threads (these actions are not in the queue).\n     /// Used to not perform other actions at the same time with these parts.\n-    StringSet future_parts;\n+    using FuturePartsSet = std::map<String, LogEntryPtr>;\n+    FuturePartsSet future_parts;\n \n     /// To access the queue, future_parts, ...\n     mutable std::mutex mutex;\n@@ -139,9 +140,9 @@ class ReplicatedMergeTreeQueue\n         std::optional<time_t> min_unprocessed_insert_time_changed,\n         std::optional<time_t> max_processed_insert_time_changed) const;\n \n-    /// Returns list of currently executing entries blocking execution a command modifying specified range\n-    size_t getConflictsCountForRange(const MergeTreePartInfo & range, const String & range_znode, String * out_conflicts_description,\n-                               std::lock_guard<std::mutex> &) const;\n+    /// Returns count of currently executing parts blocking execution a command modifying specified range\n+    size_t getConflictsCountForRange(const MergeTreePartInfo & range, const LogEntry & entry,\n+                                     String * out_description, std::lock_guard<std::mutex> &) const;\n \n     /// Marks the element of the queue as running.\n     class CurrentlyExecuting\n@@ -153,10 +154,10 @@ class ReplicatedMergeTreeQueue\n         friend class ReplicatedMergeTreeQueue;\n \n         /// Created only in the selectEntryToProcess function. It is called under mutex.\n-        CurrentlyExecuting(ReplicatedMergeTreeQueue::LogEntryPtr & entry, ReplicatedMergeTreeQueue & queue);\n+        CurrentlyExecuting(const ReplicatedMergeTreeQueue::LogEntryPtr & entry_, ReplicatedMergeTreeQueue & queue);\n \n         /// In case of fetch, we determine actual part during the execution, so we need to update entry. It is called under mutex.\n-        static void setActualPartName(const ReplicatedMergeTreeLogEntry & entry, const String & actual_part_name,\n+        static void setActualPartName(ReplicatedMergeTreeQueue::LogEntry & entry, const String & actual_part_name,\n             ReplicatedMergeTreeQueue & queue);\n     public:\n         ~CurrentlyExecuting();\n@@ -198,7 +199,7 @@ class ReplicatedMergeTreeQueue\n \n     /** Throws and exception if there are currently executing entries in the range .\n      */\n-    void checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const String & range_znode_name);\n+    void checkThereAreNoConflictsInRange(const MergeTreePartInfo & range, const LogEntry & entry);\n \n     /** In the case where there are not enough parts to perform the merge in part_name\n       * - move actions with merged parts to the end of the queue\n@@ -229,7 +230,7 @@ class ReplicatedMergeTreeQueue\n     /** Check that part isn't in currently generating parts and isn't covered by them and add it to future_parts.\n       * Locks queue's mutex.\n       */\n-    bool addFuturePartIfNotCoveredByThem(const String & part_name, const LogEntry & entry, String & reject_reason);\n+    bool addFuturePartIfNotCoveredByThem(const String & part_name, LogEntry & entry, String & reject_reason);\n \n     /// Count the number of merges in the queue.\n     size_t countMerges() const;\ndiff --git a/dbms/src/Storages/StorageReplicatedMergeTree.cpp b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\nindex 113fabdb793a..97f37a1eb212 100644\n--- a/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/dbms/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -1054,7 +1054,7 @@ void StorageReplicatedMergeTree::pullLogsToQueue(BackgroundSchedulePool::TaskHan\n }\n \n \n-bool StorageReplicatedMergeTree::executeLogEntry(const LogEntry & entry)\n+bool StorageReplicatedMergeTree::executeLogEntry(LogEntry & entry)\n {\n     if (entry.type == LogEntry::DROP_RANGE)\n     {\n@@ -1126,7 +1126,7 @@ bool StorageReplicatedMergeTree::executeLogEntry(const LogEntry & entry)\n }\n \n \n-void StorageReplicatedMergeTree::tryExecuteMerge(const StorageReplicatedMergeTree::LogEntry & entry, bool & do_fetch)\n+void StorageReplicatedMergeTree::tryExecuteMerge(const LogEntry & entry, bool & do_fetch)\n {\n     /// The caller has already decided to make the fetch\n     if (do_fetch)\n@@ -1319,7 +1319,7 @@ void StorageReplicatedMergeTree::tryExecuteMerge(const StorageReplicatedMergeTre\n }\n \n \n-bool StorageReplicatedMergeTree::executeFetch(const StorageReplicatedMergeTree::LogEntry & entry)\n+bool StorageReplicatedMergeTree::executeFetch(LogEntry & entry)\n {\n     String replica = findReplicaHavingCoveringPart(entry, true);\n \n@@ -1513,7 +1513,7 @@ bool StorageReplicatedMergeTree::executeFetch(const StorageReplicatedMergeTree::\n }\n \n \n-void StorageReplicatedMergeTree::executeDropRange(const StorageReplicatedMergeTree::LogEntry & entry)\n+void StorageReplicatedMergeTree::executeDropRange(const LogEntry & entry)\n {\n     LOG_INFO(log, (entry.detach ? \"Detaching\" : \"Removing\") << \" parts inside \" << entry.new_part_name << \".\");\n \n@@ -1562,10 +1562,6 @@ void StorageReplicatedMergeTree::executeClearColumnInPartition(const LogEntry &\n \n     auto entry_part_info = MergeTreePartInfo::fromPartName(entry.new_part_name, data.format_version);\n \n-    /// Assume optimistic scenario, i.e. conflicts are very rare\n-    /// So, if conflicts are found, throw an exception and will retry execution later\n-    queue.checkThereAreNoConflictsInRange(entry_part_info, entry.znode_name);\n-\n     /// We don't change table structure, only data in some parts\n     /// To disable reading from these parts, we will sequentially acquire write lock for each part inside alterDataPart()\n     /// If we will lock the whole table here, a deadlock can occur. For example, if use use Buffer table (CLICKHOUSE-3238)\n@@ -1583,6 +1579,14 @@ void StorageReplicatedMergeTree::executeClearColumnInPartition(const LogEntry &\n     size_t modified_parts = 0;\n     auto parts = data.getDataParts();\n     auto columns_for_parts = new_columns.getAllPhysical();\n+\n+    /// Check there are no merges in range again\n+    /// TODO: Currently, there are no guarantees that a merge covering entry_part_info will happen during the execution.\n+    /// To solve this problem we could add read/write flags for each part in future_parts\n+    ///  and make more sophisticated checks for merges in shouldExecuteLogEntry().\n+    /// But this feature will be useless when the mutation feature is implemented.\n+    queue.checkThereAreNoConflictsInRange(entry_part_info, entry);\n+\n     for (const auto & part : parts)\n     {\n         if (!entry_part_info.contains(part->info))\n@@ -1614,7 +1618,7 @@ void StorageReplicatedMergeTree::executeClearColumnInPartition(const LogEntry &\n }\n \n \n-bool StorageReplicatedMergeTree::executeReplaceRange(const StorageReplicatedMergeTree::LogEntry & entry)\n+bool StorageReplicatedMergeTree::executeReplaceRange(const LogEntry & entry)\n {\n     Stopwatch watch;\n     auto & entry_replace = *entry.replace_range_entry;\n@@ -2122,7 +2126,7 @@ namespace\n             {\n                 *out_reason = \"Part \" + part_name + \" cannot be merged yet\";\n                 if (!covering_part.empty())\n-                    *out_reason += \", a merge \" + covering_part + \" a covering it has already assigned\";\n+                    *out_reason += \", a merge \" + covering_part + \" covering it has already assigned\";\n                 else\n                     *out_reason += \", it is temporarily disabled\";\n             }\n@@ -2456,7 +2460,7 @@ String StorageReplicatedMergeTree::findReplicaHavingPart(const String & part_nam\n }\n \n \n-String StorageReplicatedMergeTree::findReplicaHavingCoveringPart(const LogEntry & entry, bool active)\n+String StorageReplicatedMergeTree::findReplicaHavingCoveringPart(LogEntry & entry, bool active)\n {\n     auto zookeeper = getZooKeeper();\n     Strings replicas = zookeeper->getChildren(zookeeper_path + \"/replicas\");\n@@ -3165,6 +3169,10 @@ bool StorageReplicatedMergeTree::getFakePartCoveringAllPartsInPartition(const St\n         auto zookeeper = getZooKeeper();\n         auto block_number_lock = allocateBlockNumber(partition_id, zookeeper);\n         right = block_number_lock->getNumber();\n+\n+        /// Create a nonincrement_block_numbers node in order not to block merges\n+        AbandonableLockInZooKeeper::createAbandonedIfNotExists(\n+                zookeeper_path + \"/nonincrement_block_numbers/\" + partition_id + \"/block-\" + padIndex(right), *zookeeper);\n         block_number_lock->unlock();\n     }\n \ndiff --git a/dbms/src/Storages/StorageReplicatedMergeTree.h b/dbms/src/Storages/StorageReplicatedMergeTree.h\nindex b16e1c27f277..1370c75d64fa 100644\n--- a/dbms/src/Storages/StorageReplicatedMergeTree.h\n+++ b/dbms/src/Storages/StorageReplicatedMergeTree.h\n@@ -369,14 +369,14 @@ class StorageReplicatedMergeTree : public ext::shared_ptr_helper<StorageReplicat\n     /** Execute the action from the queue. Throws an exception if something is wrong.\n       * Returns whether or not it succeeds. If it did not work, write it to the end of the queue.\n       */\n-    bool executeLogEntry(const LogEntry & entry);\n+    bool executeLogEntry(LogEntry & entry);\n \n     void executeDropRange(const LogEntry & entry);\n \n     /// Do the merge or recommend to make the fetch instead of the merge\n     void tryExecuteMerge(const LogEntry & entry, bool & do_fetch);\n \n-    bool executeFetch(const LogEntry & entry);\n+    bool executeFetch(LogEntry & entry);\n \n     void executeClearColumnInPartition(const LogEntry & entry);\n \n@@ -425,7 +425,7 @@ class StorageReplicatedMergeTree : public ext::shared_ptr_helper<StorageReplicat\n       * If found, returns replica name and set 'entry->actual_new_part_name' to name of found largest covering part.\n       * If not found, returns empty string.\n       */\n-    String findReplicaHavingCoveringPart(const LogEntry & entry, bool active);\n+    String findReplicaHavingCoveringPart(LogEntry & entry, bool active);\n     String findReplicaHavingCoveringPart(const String & part_name, bool active, String & found_part_name);\n \n     /** Download the specified part from the specified replica.\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_zookeeper.sql b/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_zookeeper.sql\nindex d3bafe3ccdd2..41d83ebe2635 100644\n--- a/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_zookeeper.sql\n+++ b/dbms/tests/queries/0_stateless/00446_clear_column_in_partition_zookeeper.sql\n@@ -19,6 +19,7 @@ DROP TABLE test.clear_column;\n \n SELECT '===Replicated case===';\n \n+SYSTEM STOP MERGES;\n DROP TABLE IF EXISTS test.clear_column1;\n DROP TABLE IF EXISTS test.clear_column2;\n CREATE TABLE test.clear_column1 (d Date, i Int64) ENGINE = ReplicatedMergeTree('/clickhouse/test/tables/clear_column', '1', d, d, 8192);\n@@ -57,6 +58,13 @@ SELECT sum(data_uncompressed_bytes) FROM system.columns WHERE database='test' AN\n ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200001';\n ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200002';\n \n+-- Merges cannot be blocked after all manipulations\n+SET optimize_throw_if_noop = 1;\n+SYSTEM START MERGES;\n+OPTIMIZE TABLE test.clear_column1 PARTITION '200001';\n+OPTIMIZE TABLE test.clear_column1 PARTITION '200002';\n+\n+\n -- clear column in empty partition should be Ok\n ALTER TABLE test.clear_column1 CLEAR COLUMN s IN PARTITION '200012', CLEAR COLUMN i IN PARTITION '200012';\n -- Drop empty partition also Ok\n",
  "problem_statement": "\u041d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u043c\u0435\u0440\u0436\u0438 \u0432 ReplicatedMergeTree \u043f\u043e\u0441\u043b\u0435 CLEAR COLUMN IN PARTITION\n```sql\r\nCREATE TABLE clear_column_and_merges (\r\n    ActionDate Date,\r\n    ActionTime DateTime DEFAULT toDateTime(ActionDate),\r\n    Count Int64\r\n) Engine = ReplicatedSummingMergeTree('/clickhouse/tables/clear_column_and_merges', '{replica}')\r\nPARTITION BY toYYYYMM(ActionDate)\r\nORDER BY (\r\n      ActionDate\r\n    , ActionTime\r\n) SETTINGS index_granularity = 64;\r\n\r\nINSERT INTO clear_column_and_merges VALUES \r\n    ('2018-04-01', '2018-04-01 12:00:00', 1),\r\n    ('2018-04-01', '2018-04-01 13:00:00', 1),\r\n    ('2018-05-01', '2018-05-01 12:00:00', 1),\r\n    ('2018-05-01', '2018-05-01 13:00:00', 1),\r\n    ('2018-04-01', '2018-04-01 12:00:00', 2),\r\n    ('2018-04-01', '2018-04-01 13:00:00', 2),\r\n    ('2018-05-01', '2018-05-01 12:00:00', 2),\r\n    ('2018-05-01', '2018-05-01 13:00:00', 2);\r\n\r\nINSERT INTO clear_column_and_merges VALUES \r\n    ('2018-04-01', '2018-04-01 12:00:00', 1),\r\n    ('2018-04-01', '2018-04-01 13:00:00', 2),\r\n    ('2018-05-01', '2018-05-01 12:00:00', 2),\r\n    ('2018-05-01', '2018-05-01 13:00:00', 2);\r\n```\r\n\r\n```sql\r\nSET optimize_throw_if_noop = 1;\r\n\r\nOPTIMIZE TABLE clear_column_and_merges PARTITION 201804 final;\r\n\r\nSELECT *\r\nFROM clear_column_and_merges \r\n\r\n\u250c\u2500ActionDate\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ActionTime\u2500\u252c\u2500Count\u2500\u2510\r\n\u2502 2018-05-01 \u2502 2018-05-01 12:00:00 \u2502     2 \u2502\r\n\u2502 2018-05-01 \u2502 2018-05-01 13:00:00 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500ActionDate\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ActionTime\u2500\u252c\u2500Count\u2500\u2510\r\n\u2502 2018-05-01 \u2502 2018-05-01 12:00:00 \u2502     1 \u2502\r\n\u2502 2018-05-01 \u2502 2018-05-01 12:00:00 \u2502     2 \u2502\r\n\u2502 2018-05-01 \u2502 2018-05-01 13:00:00 \u2502     1 \u2502\r\n\u2502 2018-05-01 \u2502 2018-05-01 13:00:00 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500ActionDate\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ActionTime\u2500\u252c\u2500Count\u2500\u2510\r\n\u2502 2018-04-01 \u2502 2018-04-01 12:00:00 \u2502     4 \u2502\r\n\u2502 2018-04-01 \u2502 2018-04-01 13:00:00 \u2502     5 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nALTER TABLE clear_column_and_merges CLEAR COLUMN ActionTime IN PARTITION 201804;\r\n\r\n\r\nOPTIMIZE TABLE clear_column_and_merges PARTITION 201804 FINAL\r\n```\r\n\r\n\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443 \r\n```\r\nReceived exception from server (version 1.1.54343):\r\nCode: 388. DB::Exception: Received from localhost:9000, ::1. DB::Exception: Part 201804_0_1_2 cannot be merged yet, a merge has already assigned for it or it is temporarily disabled. \r\n\r\n0 rows in set. Elapsed: 0.148 sec. \r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2018-05-23T14:37:25Z"
}