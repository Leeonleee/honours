diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 5584775ff15d..3e228f529d97 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -829,7 +829,14 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti
         /// We should not copy them for other storages.
         if (create.storage && endsWith(create.storage->engine->name, "MergeTree"))
         {
-            properties.indices = as_storage_metadata->getSecondaryIndices();
+            /// Copy secondary indexes but only the ones which were not implicitly created. These will be re-generated later again and need
+            /// not be copied.
+            const auto & indices = as_storage_metadata->getSecondaryIndices();
+            for (const auto & index : indices)
+                if (!index.isImplicitlyCreated())
+                    properties.indices.push_back(index);
+
+            /// Copy projections.
             properties.projections = as_storage_metadata->getProjections().clone();
 
             /// CREATE TABLE AS should copy PRIMARY KEY, ORDER BY, and similar clauses.
@@ -1312,6 +1319,7 @@ void InterpreterCreateQuery::setEngine(ASTCreateQuery & create) const
         String as_table_name = create.as_table;
 
         ASTPtr as_create_ptr = DatabaseCatalog::instance().getDatabase(as_database_name)->getCreateTableQuery(as_table_name, getContext());
+
         const auto & as_create = as_create_ptr->as<ASTCreateQuery &>();
 
         const String qualified_name = backQuoteIfNeed(as_database_name) + "." + backQuoteIfNeed(as_table_name);
diff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp
index 0b6c9930b012..aa3d6178e4c3 100644
--- a/src/Storages/AlterCommands.cpp
+++ b/src/Storages/AlterCommands.cpp
@@ -551,7 +551,8 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)
                 auto index_type = makeASTFunction("minmax");
                 auto index_ast = std::make_shared<ASTIndexDeclaration>(std::make_shared<ASTIdentifier>(column.name), index_type, IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);
                 index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;
-                metadata.secondary_indices.push_back(IndexDescription::getIndexFromAST(index_ast, metadata.columns, context));
+                auto new_index = IndexDescription::getIndexFromAST(index_ast, metadata.columns, context);
+                metadata.secondary_indices.push_back(new_index);
             }
         }
     }
diff --git a/src/Storages/IndicesDescription.h b/src/Storages/IndicesDescription.h
index 4981eafa9416..d939e588d64a 100644
--- a/src/Storages/IndicesDescription.h
+++ b/src/Storages/IndicesDescription.h
@@ -9,6 +9,8 @@
 #include <Storages/ColumnsDescription.h>
 #include <Common/NamePrompter.h>
 
+constexpr auto IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX = "auto_minmax_index_";
+
 namespace DB
 {
 
@@ -58,6 +60,8 @@ struct IndexDescription
     /// Recalculate index with new columns because index expression may change
     /// if something change in columns.
     void recalculateWithNewColumns(const ColumnsDescription & new_columns, ContextPtr context);
+
+    bool isImplicitlyCreated() const { return name.starts_with(IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX); }
 };
 
 /// All secondary indices in storage
diff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h
index ea26c1c013a3..96572dd90d80 100644
--- a/src/Storages/MergeTree/MergeTreeIndices.h
+++ b/src/Storages/MergeTree/MergeTreeIndices.h
@@ -17,7 +17,6 @@
 #include "config.h"
 
 constexpr auto INDEX_FILE_PREFIX = "skp_idx_";
-constexpr auto IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX = "auto_minmax_index_";
 
 namespace DB
 {
diff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp
index 0a120bc8f71f..c102051b56ca 100644
--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp
+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp
@@ -724,34 +724,35 @@ static StoragePtr create(const StorageFactory::Arguments & args)
                     throw Exception(ErrorCodes::BAD_ARGUMENTS, "Cannot create table because index {} uses a reserved index name", index_name);
                 }
             }
+        }
 
-            /// Try to add "implicit" min-max indexes on all columns
-            for (const auto & column : metadata.columns)
+        /// Try to add "implicit" min-max indexes on all columns
+        for (const auto & column : metadata.columns)
+        {
+            if ((isNumber(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_numeric_columns])
+                || (isString(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_string_columns]))
             {
-                if ((isNumber(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_numeric_columns])
-                    || (isString(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_string_columns]))
-                {
-                    bool minmax_index_exists = false;
+                bool minmax_index_exists = false;
 
-                    for (const auto & index: metadata.secondary_indices)
+                for (const auto & index : metadata.secondary_indices)
+                {
+                    if (index.column_names.front() == column.name && index.type == "minmax")
                     {
-                        if (index.column_names.front() == column.name && index.type == "minmax")
-                        {
-                            minmax_index_exists = true;
-                            break;
-                        }
+                        minmax_index_exists = true;
+                        break;
                     }
+                }
 
-                    if (minmax_index_exists)
-                        continue;
+                if (minmax_index_exists)
+                    continue;
 
-                    auto index_type = makeASTFunction("minmax");
-                    auto index_ast = std::make_shared<ASTIndexDeclaration>(
-                            std::make_shared<ASTIdentifier>(column.name), index_type,
-                            IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);
-                    index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;
-                    metadata.secondary_indices.push_back(IndexDescription::getIndexFromAST(index_ast, columns, context));
-                }
+                auto index_type = makeASTFunction("minmax");
+                auto index_ast = std::make_shared<ASTIndexDeclaration>(
+                        std::make_shared<ASTIdentifier>(column.name), index_type,
+                        IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);
+                index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;
+                auto new_index = IndexDescription::getIndexFromAST(index_ast, columns, context);
+                metadata.secondary_indices.push_back(std::move(new_index));
             }
         }
 
