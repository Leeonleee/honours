{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 75877,
  "instance_id": "ClickHouse__ClickHouse-75877",
  "issue_numbers": [
    "75677"
  ],
  "base_commit": "11991bb3cfaa57042ecb5a1fb428631136cf2d35",
  "patch": "diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 5584775ff15d..3e228f529d97 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -829,7 +829,14 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti\n         /// We should not copy them for other storages.\n         if (create.storage && endsWith(create.storage->engine->name, \"MergeTree\"))\n         {\n-            properties.indices = as_storage_metadata->getSecondaryIndices();\n+            /// Copy secondary indexes but only the ones which were not implicitly created. These will be re-generated later again and need\n+            /// not be copied.\n+            const auto & indices = as_storage_metadata->getSecondaryIndices();\n+            for (const auto & index : indices)\n+                if (!index.isImplicitlyCreated())\n+                    properties.indices.push_back(index);\n+\n+            /// Copy projections.\n             properties.projections = as_storage_metadata->getProjections().clone();\n \n             /// CREATE TABLE AS should copy PRIMARY KEY, ORDER BY, and similar clauses.\n@@ -1312,6 +1319,7 @@ void InterpreterCreateQuery::setEngine(ASTCreateQuery & create) const\n         String as_table_name = create.as_table;\n \n         ASTPtr as_create_ptr = DatabaseCatalog::instance().getDatabase(as_database_name)->getCreateTableQuery(as_table_name, getContext());\n+\n         const auto & as_create = as_create_ptr->as<ASTCreateQuery &>();\n \n         const String qualified_name = backQuoteIfNeed(as_database_name) + \".\" + backQuoteIfNeed(as_table_name);\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 0b6c9930b012..aa3d6178e4c3 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -551,7 +551,8 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)\n                 auto index_type = makeASTFunction(\"minmax\");\n                 auto index_ast = std::make_shared<ASTIndexDeclaration>(std::make_shared<ASTIdentifier>(column.name), index_type, IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);\n                 index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;\n-                metadata.secondary_indices.push_back(IndexDescription::getIndexFromAST(index_ast, metadata.columns, context));\n+                auto new_index = IndexDescription::getIndexFromAST(index_ast, metadata.columns, context);\n+                metadata.secondary_indices.push_back(new_index);\n             }\n         }\n     }\ndiff --git a/src/Storages/IndicesDescription.h b/src/Storages/IndicesDescription.h\nindex 4981eafa9416..d939e588d64a 100644\n--- a/src/Storages/IndicesDescription.h\n+++ b/src/Storages/IndicesDescription.h\n@@ -9,6 +9,8 @@\n #include <Storages/ColumnsDescription.h>\n #include <Common/NamePrompter.h>\n \n+constexpr auto IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX = \"auto_minmax_index_\";\n+\n namespace DB\n {\n \n@@ -58,6 +60,8 @@ struct IndexDescription\n     /// Recalculate index with new columns because index expression may change\n     /// if something change in columns.\n     void recalculateWithNewColumns(const ColumnsDescription & new_columns, ContextPtr context);\n+\n+    bool isImplicitlyCreated() const { return name.starts_with(IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX); }\n };\n \n /// All secondary indices in storage\ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h\nindex ea26c1c013a3..96572dd90d80 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.h\n+++ b/src/Storages/MergeTree/MergeTreeIndices.h\n@@ -17,7 +17,6 @@\n #include \"config.h\"\n \n constexpr auto INDEX_FILE_PREFIX = \"skp_idx_\";\n-constexpr auto IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX = \"auto_minmax_index_\";\n \n namespace DB\n {\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 0a120bc8f71f..c102051b56ca 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -724,34 +724,35 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n                     throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot create table because index {} uses a reserved index name\", index_name);\n                 }\n             }\n+        }\n \n-            /// Try to add \"implicit\" min-max indexes on all columns\n-            for (const auto & column : metadata.columns)\n+        /// Try to add \"implicit\" min-max indexes on all columns\n+        for (const auto & column : metadata.columns)\n+        {\n+            if ((isNumber(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_numeric_columns])\n+                || (isString(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_string_columns]))\n             {\n-                if ((isNumber(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_numeric_columns])\n-                    || (isString(column.type) && (*storage_settings)[MergeTreeSetting::add_minmax_index_for_string_columns]))\n-                {\n-                    bool minmax_index_exists = false;\n+                bool minmax_index_exists = false;\n \n-                    for (const auto & index: metadata.secondary_indices)\n+                for (const auto & index : metadata.secondary_indices)\n+                {\n+                    if (index.column_names.front() == column.name && index.type == \"minmax\")\n                     {\n-                        if (index.column_names.front() == column.name && index.type == \"minmax\")\n-                        {\n-                            minmax_index_exists = true;\n-                            break;\n-                        }\n+                        minmax_index_exists = true;\n+                        break;\n                     }\n+                }\n \n-                    if (minmax_index_exists)\n-                        continue;\n+                if (minmax_index_exists)\n+                    continue;\n \n-                    auto index_type = makeASTFunction(\"minmax\");\n-                    auto index_ast = std::make_shared<ASTIndexDeclaration>(\n-                            std::make_shared<ASTIdentifier>(column.name), index_type,\n-                            IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);\n-                    index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;\n-                    metadata.secondary_indices.push_back(IndexDescription::getIndexFromAST(index_ast, columns, context));\n-                }\n+                auto index_type = makeASTFunction(\"minmax\");\n+                auto index_ast = std::make_shared<ASTIndexDeclaration>(\n+                        std::make_shared<ASTIdentifier>(column.name), index_type,\n+                        IMPLICITLY_ADDED_MINMAX_INDEX_PREFIX + column.name);\n+                index_ast->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;\n+                auto new_index = IndexDescription::getIndexFromAST(index_ast, columns, context);\n+                metadata.secondary_indices.push_back(std::move(new_index));\n             }\n         }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03261_minmax_indices_by_default_table_copy.reference b/tests/queries/0_stateless/03261_minmax_indices_by_default_table_copy.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03261_minmax_indices_by_default_table_copy.sql b/tests/queries/0_stateless/03261_minmax_indices_by_default_table_copy.sql\nnew file mode 100644\nindex 000000000000..41bd81d8ffe8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03261_minmax_indices_by_default_table_copy.sql\n@@ -0,0 +1,18 @@\n+-- Test for issue #75677\n+\n+DROP TABLE IF EXISTS tab1;\n+\n+CREATE TABLE tab1 (\n+    a Int32,\n+    b String,\n+    c Float64)\n+ENGINE MergeTree\n+ORDER BY a\n+SETTINGS\n+    add_minmax_index_for_numeric_columns = 1,\n+    add_minmax_index_for_string_columns = 1;\n+\n+CREATE TABLE tab2 AS tab1;\n+\n+DROP TABLE tab1;\n+DROP TABLE tab2;\n",
  "problem_statement": "\"reserved index name\" error when using auto_minmax_index with \"create table t2 as t1\"\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nIn 25.1.2.3, enabling auto_minmax_index will fail with error on conflicting index names when using the \"create table t2 as t1\" statement.\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n```sql\ncreate database if not exists local_test;\n\ncreate table local_test.auto_index_test (a Int32, b String, c Float64) engine MergeTree order by a\nsettings add_minmax_index_for_numeric_columns=1, add_minmax_index_for_string_columns=1;\n\ncreate table local_test.auto_index_test_clone as local_test.auto_index_test;\n```\n\n\n### Expected behavior\n\n_No response_\n\n### Error message and/or stacktrace\n\n```\nSQL Error [36] [07000]: Code: 36. \nDB::Exception: Cannot create table because index auto_minmax_index_a uses a reserved index name. \n(BAD_ARGUMENTS) (version 25.1.2.3 (official build))\n```\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-02-10T22:31:38Z"
}