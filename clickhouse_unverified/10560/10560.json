{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10560,
  "instance_id": "ClickHouse__ClickHouse-10560",
  "issue_numbers": [
    "9008"
  ],
  "base_commit": "2528e721991430861309ecda5e58fc45cfaf01e9",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 61cba5487047..642995974b5d 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1125,12 +1125,10 @@ class FunctionComparison : public IFunction\n \n         if (!((both_represented_by_number && !has_date)   /// Do not allow compare date and number.\n             || (left.isStringOrFixedString() && right.isStringOrFixedString())\n-            || (left.isDate() && right.isDate())\n-            || (left.isDate() && right.isString())    /// You can compare the date, datetime and an enumeration with a constant string.\n-            || (left.isString() && right.isDate())\n-            || (left.isDateTime() && right.isDateTime())\n-            || (left.isDateTime() && right.isString())\n-            || (left.isString() && right.isDateTime())\n+            /// You can compare the date, datetime, or datatime64 and an enumeration with a constant string.\n+            || (left.isString() && right.isDateOrDateTime())\n+            || (left.isDateOrDateTime() && right.isString())\n+            || (left.isDateOrDateTime() && right.isDateOrDateTime() && left.idx == right.idx) /// only date vs date, or datetime vs datetime\n             || (left.isUUID() && right.isUUID())\n             || (left.isUUID() && right.isString())\n             || (left.isString() && right.isUUID())\n@@ -1228,6 +1226,65 @@ class FunctionComparison : public IFunction\n         {\n             executeTuple(block, result, col_with_type_and_name_left, col_with_type_and_name_right, input_rows_count);\n         }\n+        else if (which_left.idx != which_right.idx\n+                 && (which_left.isDateTime64() || which_right.isDateTime64())\n+                 && (which_left.isStringOrFixedString() || which_right.isStringOrFixedString()))\n+        {\n+            /** Special case of comparing DateTime64 against a string.\n+             *\n+             * Can't be moved to executeDateOrDateTimeOrEnumOrUUIDWithConstString()\n+             * since DateTime64 is basically a Decimal, but we do similar things, except type inference.\n+             * Outline:\n+             * - Extract string content\n+             * - Parse it as a ColumnDateTime64 value (same type as DateTime64, means same precision)\n+             * - Fabricate a column with type and name\n+             * - Compare left and right comlumns as DateTime64 columns.\n+             */\n+\n+            const size_t datetime64_col_index = which_left.isDateTime64() ? 0 : 1;\n+            const size_t string_col_index = which_left.isStringOrFixedString() ? 0 : 1;\n+\n+            const auto & datetime64_col_with_type_and_name = block.getByPosition(arguments[datetime64_col_index]);\n+            const auto & string_col_with_type_and_name = block.getByPosition(arguments[string_col_index]);\n+\n+            if (!isColumnConst(*string_col_with_type_and_name.column))\n+                throw Exception(getName() + \", illegal column type of argument #\" + std::to_string(string_col_index)\n+                        + \" '\" + string_col_with_type_and_name.name + \"'\"\n+                        \" expected const String or const FixedString,\"\n+                        \" got \" + string_col_with_type_and_name.type->getName(),\n+                        ErrorCodes::ILLEGAL_COLUMN);\n+\n+            if (datetime64_col_with_type_and_name.column->size() == 0 || string_col_with_type_and_name.column->size() == 0)\n+            {\n+                // For some reason, when both left and right columns are empty (dry run while building a header block)\n+                // executeDecimal() fills result column with bogus value.\n+                block.getByPosition(result).column = ColumnUInt8::create();\n+                return;\n+            }\n+\n+            auto parsed_tmp_column_holder = datetime64_col_with_type_and_name.type->createColumn();\n+\n+            {\n+                const StringRef string_value = string_col_with_type_and_name.column->getDataAt(0);\n+                ReadBufferFromMemory in(string_value.data, string_value.size);\n+                datetime64_col_with_type_and_name.type->deserializeAsWholeText(*parsed_tmp_column_holder, in, FormatSettings{});\n+\n+                if (!in.eof())\n+                    throw Exception(getName() + \": String is too long for \" + datetime64_col_with_type_and_name.type->getName() + \" : \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n+            }\n+\n+            // It is necessary to wrap tmp column in ColumnConst to avoid overflow when comparing.\n+            // (non-const columns are expected to have same number of rows as every other column in block).\n+            const ColumnWithTypeAndName parsed_tmp_col_with_type_and_name{\n+                    ColumnConst::create(std::move(parsed_tmp_column_holder), 1),\n+                    datetime64_col_with_type_and_name.type,\n+                    string_col_with_type_and_name.name};\n+\n+            executeDecimal(block, result,\n+                which_left.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name,\n+                which_right.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name);\n+\n+        }\n         else if (isColumnedAsDecimal(left_type) || isColumnedAsDecimal(right_type))\n         {\n             // compare\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.reference b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.reference\nnew file mode 100644\nindex 000000000000..d99950477fcf\n--- /dev/null\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.reference\n@@ -0,0 +1,15 @@\n+in SELECT\n+1\n+1\n+1\n+1\n+in WHERE\n+0\n+0\n+0\n+0\n+other operators\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\nnew file mode 100644\nindex 000000000000..c65bf668d717\n--- /dev/null\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n@@ -0,0 +1,35 @@\n+-- Error cases:\n+-- non-const string column\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = materialize(S); -- {serverError 44}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(S) = toDateTime64(S, 3); -- {serverError 44}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 44}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 44}\n+\n+SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 131} -- invalid DateTime64 string\n+SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 131} -- invalid string length\n+\n+SELECT 'in SELECT';\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT S = DT64;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(DT64) = S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT S = materialize(DT64);\n+\n+SELECT 'in WHERE';\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S = DT64;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(DT64) = S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S = materialize(DT64);\n+\n+SELECT 'other operators';\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 <= S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 >= S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S <= DT64;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S >= DT64;\n+\n+-- empty results\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 < S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 > S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 != S;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S < DT64;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S > DT64;\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE S != DT64;\n",
  "problem_statement": "Fields of type DateTime64 cannot be used in WHERE section\n**Describe the bug or unexpected behaviour**\r\n\r\nFields of type `DateTime64` cannot be used in `WHERE` section.\r\n\r\n**How to reproduce**\r\n\r\n**Version:** 20.1.3\r\n\r\n\r\n```\r\nCREATE TABLE t2\r\n(\r\n    `c1` DateTime64(3)\r\n)\r\nENGINE = Memory;\r\n```\r\n\r\n```\r\nINSERT INTO t2 VALUES ('2020-02-05 14:34:12.333'), ('2020-02-05 15:18:32.444') ;\r\n```\r\n\r\n```\r\nSELECT * FROM t2 WHERE c1 = '2020-02-05 14:34:12.333';\r\n```\r\n\r\n**Expected behavior**\r\nQuery conditions are expected to work in the same manner as for `DateTime` data type.\r\n\r\n**Error message and/or stacktrace**\r\n```\r\nReceived exception from server (version 20.1.3):\r\nCode: 43. DB::Exception: Received from 127.0.0.1:9600. DB::Exception: Illegal types of arguments (DateTime64(3), String) of function equals.\r\n```\r\n\n",
  "hints_text": "Work-around:\r\n\r\nUse `toDateTime64`function:\r\n\r\n```\r\nSELECT *\r\nFROM t2\r\nWHERE c1 = toDateTime64('2020-02-05 14:34:12.333', 3)\r\n```\r\n\r\n\ncc @Enmk ",
  "created_at": "2020-04-28T15:38:04Z"
}