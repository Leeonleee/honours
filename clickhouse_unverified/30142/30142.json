{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 30142,
  "instance_id": "ClickHouse__ClickHouse-30142",
  "issue_numbers": [
    "30090"
  ],
  "base_commit": "7ee8c53d444ff7b1f5a1d7fee24df92bd82ea610",
  "patch": "diff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp\nindex 06a705a351e5..7a34a9c2b259 100644\n--- a/src/Dictionaries/PolygonDictionary.cpp\n+++ b/src/Dictionaries/PolygonDictionary.cpp\n@@ -7,7 +7,8 @@\n #include <Columns/ColumnTuple.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Functions/FunctionHelpers.h>\n-#include <DataTypes/DataTypesDecimal.h>\n+#include <Processors/Pipe.h>\n+#include <Processors/Sources/SourceFromSingleChunk.h>\n #include <Dictionaries/DictionaryFactory.h>\n #include <Dictionaries/DictionarySource.h>\n \n@@ -28,14 +29,12 @@ IPolygonDictionary::IPolygonDictionary(\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n-        InputType input_type_,\n-        PointType point_type_)\n+        Configuration configuration_)\n         : IDictionary(dict_id_)\n         , dict_struct(dict_struct_)\n         , source_ptr(std::move(source_ptr_))\n         , dict_lifetime(dict_lifetime_)\n-        , input_type(input_type_)\n-        , point_type(point_type_)\n+        , configuration(configuration_)\n {\n     setup();\n     loadData();\n@@ -55,7 +54,7 @@ ColumnPtr IPolygonDictionary::getColumn(\n     DefaultValueProvider default_value_provider(attribute.null_value, default_values_column);\n \n     size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n-    const auto & attribute_values_column = attributes[attribute_index];\n+    const auto & attribute_values_column = attributes_columns[attribute_index];\n \n     auto result = attribute_values_column->cloneEmpty();\n     result->reserve(requested_key_points.size());\n@@ -119,21 +118,56 @@ ColumnPtr IPolygonDictionary::getColumn(\n     return result;\n }\n \n-Pipe IPolygonDictionary::read(const Names &, size_t) const\n+Pipe IPolygonDictionary::read(const Names & column_names, size_t) const\n {\n-    // TODO: In order for this to work one would first have to support retrieving arrays from dictionaries.\n-    //  I believe this is a separate task done by some other people.\n-    throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Reading the dictionary is not allowed\");\n+    if (!configuration.store_polygon_key_column)\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+            \"Set `store_polygon_key_column` setting in dictionary configuration to true to support reading from PolygonDictionary.\");\n+\n+    const auto & dictionary_structure_keys = *dict_struct.key;\n+    const auto & dictionary_key_attribute = dictionary_structure_keys[0];\n+\n+    ColumnsWithTypeAndName result_columns;\n+    result_columns.reserve(column_names.size());\n+\n+    for (const auto & column_name : column_names)\n+    {\n+        ColumnWithTypeAndName column_with_type;\n+\n+        if (column_name == dictionary_key_attribute.name)\n+        {\n+            column_with_type.column = key_attribute_column;\n+            column_with_type.type = dictionary_key_attribute.type;\n+        }\n+        else\n+        {\n+            const auto & dictionary_attribute = dict_struct.getAttribute(column_name);\n+            size_t attribute_index = dict_struct.attribute_name_to_index.find(dictionary_attribute.name)->second;\n+\n+            column_with_type.column = attributes_columns[attribute_index];\n+            column_with_type.type = dictionary_attribute.type;\n+        }\n+\n+        column_with_type.name = column_name;\n+\n+        result_columns.emplace_back(column_with_type);\n+    }\n+\n+    auto source = std::make_shared<SourceFromSingleChunk>(Block(result_columns));\n+    return Pipe(std::move(source));\n }\n \n void IPolygonDictionary::setup()\n {\n-    attributes.reserve(dict_struct.attributes.size());\n+    const auto & dictionary_structure_keys = *dict_struct.key;\n+    key_attribute_column = dictionary_structure_keys[0].type->createColumn();\n+\n+    attributes_columns.reserve(dict_struct.attributes.size());\n \n     for (const auto & attribute : dict_struct.attributes)\n     {\n         auto column = attribute.type->createColumn();\n-        attributes.emplace_back(std::move(column));\n+        attributes_columns.emplace_back(std::move(column));\n \n         if (attribute.hierarchical)\n             throw Exception(ErrorCodes::TYPE_MISMATCH,\n@@ -147,20 +181,24 @@ void IPolygonDictionary::blockToAttributes(const DB::Block & block)\n     const auto rows = block.rows();\n \n     size_t skip_key_column_offset = 1;\n-    for (size_t i = 0; i < attributes.size(); ++i)\n+    for (size_t i = 0; i < attributes_columns.size(); ++i)\n     {\n         const auto & block_column = block.safeGetByPosition(i + skip_key_column_offset);\n         const auto & column = block_column.column;\n \n-        attributes[i]->assumeMutable()->insertRangeFrom(*column, 0, column->size());\n+        attributes_columns[i]->assumeMutable()->insertRangeFrom(*column, 0, column->size());\n     }\n \n     /** Multi-polygons could cause bigger sizes, but this is better than nothing. */\n     polygons.reserve(polygons.size() + rows);\n     polygon_index_to_attribute_value_index.reserve(polygon_index_to_attribute_value_index.size() + rows);\n \n-    const auto & key = block.safeGetByPosition(0).column;\n-    extractPolygons(key);\n+    const auto & key_column = block.safeGetByPosition(0).column;\n+\n+    if (configuration.store_polygon_key_column)\n+        key_attribute_column->assumeMutable()->insertRangeFrom(*key_column, 0, key_column->size());\n+\n+    extractPolygons(key_column);\n }\n \n void IPolygonDictionary::loadData()\n@@ -210,7 +248,7 @@ void IPolygonDictionary::calculateBytesAllocated()\n {\n     /// Index allocated by subclass not counted because it take a small part in relation to attributes and polygons\n \n-    for (const auto & column : attributes)\n+    for (const auto & column : attributes_columns)\n         bytes_allocated += column->allocatedBytes();\n \n     for (auto & polygon : polygons)\n@@ -487,7 +525,7 @@ void IPolygonDictionary::extractPolygons(const ColumnPtr & column)\n     Offset offset;\n \n     const IColumn * points_collection = nullptr;\n-    switch (input_type)\n+    switch (configuration.input_type)\n     {\n         case InputType::MultiPolygon:\n             points_collection = unrollMultiPolygons(column, offset);\n@@ -504,7 +542,7 @@ void IPolygonDictionary::extractPolygons(const ColumnPtr & column)\n     /** Adding the first empty polygon */\n     data.addPolygon(true);\n \n-    switch (point_type)\n+    switch (configuration.point_type)\n     {\n         case PointType::Array:\n             handlePointsReprByArrays(points_collection, data, offset);\ndiff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h\nindex 9ab82890c495..00a151d546f2 100644\n--- a/src/Dictionaries/PolygonDictionary.h\n+++ b/src/Dictionaries/PolygonDictionary.h\n@@ -50,13 +50,22 @@ class IPolygonDictionary : public IDictionary\n         Tuple,\n     };\n \n+    struct Configuration\n+    {\n+        InputType input_type = InputType::MultiPolygon;\n+\n+        PointType point_type = PointType::Array;\n+\n+        /// Store polygon key column. That will allow to read columns from polygon dictionary.\n+        bool store_polygon_key_column = false;\n+    };\n+\n     IPolygonDictionary(\n             const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n-            InputType input_type_,\n-            PointType point_type_);\n+            Configuration configuration_);\n \n     std::string getTypeName() const override { return \"Polygon\"; }\n \n@@ -74,7 +83,7 @@ class IPolygonDictionary : public IDictionary\n \n     double getHitRate() const override { return 1.0; }\n \n-    size_t getElementCount() const override { return attributes.empty() ? 0 : attributes.front()->size(); }\n+    size_t getElementCount() const override { return attributes_columns.empty() ? 0 : attributes_columns.front()->size(); }\n \n     double getLoadFactor() const override { return 1.0; }\n \n@@ -120,9 +129,7 @@ class IPolygonDictionary : public IDictionary\n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\n-\n-    const InputType input_type;\n-    const PointType point_type;\n+    const Configuration configuration;\n \n private:\n     /** Helper functions for loading the data from the configuration.\n@@ -146,7 +153,9 @@ class IPolygonDictionary : public IDictionary\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    Columns attributes;\n+    ColumnPtr key_attribute_column;\n+\n+    Columns attributes_columns;\n \n     size_t bytes_allocated = 0;\n     mutable std::atomic<size_t> query_count{0};\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.cpp b/src/Dictionaries/PolygonDictionaryImplementations.cpp\nindex bd09e9df0735..4f5155861209 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.cpp\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.cpp\n@@ -22,9 +22,8 @@ PolygonDictionarySimple::PolygonDictionarySimple(\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n-        InputType input_type_,\n-        PointType point_type_):\n-        IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_)\n+        Configuration configuration_)\n+    : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, configuration_)\n {\n }\n \n@@ -35,8 +34,7 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionarySimple::clone() const\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n-            this->input_type,\n-            this->point_type);\n+            this->configuration);\n }\n \n bool PolygonDictionarySimple::find(const Point & point, size_t & polygon_index) const\n@@ -59,11 +57,10 @@ PolygonDictionaryIndexEach::PolygonDictionaryIndexEach(\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n-        InputType input_type_,\n-        PointType point_type_,\n+        Configuration configuration_,\n         int min_intersections_,\n         int max_depth_)\n-        : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n+        : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, configuration_),\n           grid(min_intersections_, max_depth_, polygons),\n           min_intersections(min_intersections_),\n           max_depth(max_depth_)\n@@ -84,8 +81,7 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexEach::clone() con\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n-            this->input_type,\n-            this->point_type,\n+            this->configuration,\n             this->min_intersections,\n             this->max_depth);\n }\n@@ -118,11 +114,10 @@ PolygonDictionaryIndexCell::PolygonDictionaryIndexCell(\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n-    InputType input_type_,\n-    PointType point_type_,\n+    Configuration configuration_,\n     size_t min_intersections_,\n     size_t max_depth_)\n-    : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, input_type_, point_type_),\n+    : IPolygonDictionary(dict_id_, dict_struct_, std::move(source_ptr_), dict_lifetime_, configuration_),\n       index(min_intersections_, max_depth_, polygons),\n       min_intersections(min_intersections_),\n       max_depth(max_depth_)\n@@ -136,8 +131,7 @@ std::shared_ptr<const IExternalLoadable> PolygonDictionaryIndexCell::clone() con\n             this->dict_struct,\n             this->source_ptr->clone(),\n             this->dict_lifetime,\n-            this->input_type,\n-            this->point_type,\n+            this->configuration,\n             this->min_intersections,\n             this->max_depth);\n }\n@@ -179,14 +173,16 @@ DictionaryPtr createLayout(const std::string & ,\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n             \"The 'key' should consist of a single attribute for a polygon dictionary\");\n \n-    IPolygonDictionary::InputType input_type;\n-    IPolygonDictionary::PointType point_type;\n     const auto key_type = (*dict_struct.key)[0].type;\n     const auto f64 = std::make_shared<DataTypeFloat64>();\n     const auto multi_polygon_array = DataTypeArray(std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(f64))));\n     const auto multi_polygon_tuple = DataTypeArray(std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(std::make_shared<DataTypeTuple>(std::vector<DataTypePtr>{f64, f64}))));\n     const auto simple_polygon_array = DataTypeArray(std::make_shared<DataTypeArray>(f64));\n     const auto simple_polygon_tuple = DataTypeArray(std::make_shared<DataTypeTuple>(std::vector<DataTypePtr>{f64, f64}));\n+\n+    IPolygonDictionary::InputType input_type;\n+    IPolygonDictionary::PointType point_type;\n+\n     if (key_type->equals(multi_polygon_array))\n     {\n         input_type = IPolygonDictionary::InputType::MultiPolygon;\n@@ -208,6 +204,7 @@ DictionaryPtr createLayout(const std::string & ,\n         point_type = IPolygonDictionary::PointType::Tuple;\n     }\n     else\n+    {\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n             \"The key type {} is not one of the following allowed types for a polygon dictionary: {} {} {} {} \",\n             key_type->getName(),\n@@ -215,6 +212,19 @@ DictionaryPtr createLayout(const std::string & ,\n             multi_polygon_tuple.getName(),\n             simple_polygon_array.getName(),\n             simple_polygon_tuple.getName());\n+    }\n+\n+    const auto & layout_prefix = config_prefix + \".layout\";\n+    Poco::Util::AbstractConfiguration::Keys keys;\n+    config.keys(layout_prefix, keys);\n+    const auto & dict_prefix = layout_prefix + \".\" + keys.front();\n+\n+    IPolygonDictionary::Configuration configuration\n+    {\n+        .input_type = input_type,\n+        .point_type = point_type,\n+        .store_polygon_key_column = config.getBool(dict_prefix + \".store_polygon_key_column\", false)\n+    };\n \n     if (dict_struct.range_min || dict_struct.range_max)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n@@ -228,16 +238,12 @@ DictionaryPtr createLayout(const std::string & ,\n \n     if constexpr (std::is_same_v<PolygonDictionary, PolygonDictionaryIndexEach> || std::is_same_v<PolygonDictionary, PolygonDictionaryIndexCell>)\n     {\n-        const auto & layout_prefix = config_prefix + \".layout\";\n-        Poco::Util::AbstractConfiguration::Keys keys;\n-        config.keys(layout_prefix, keys);\n-        const auto & dict_prefix = layout_prefix + \".\" + keys.front();\n         size_t max_depth = config.getUInt(dict_prefix + \".max_depth\", PolygonDictionary::kMaxDepthDefault);\n         size_t min_intersections = config.getUInt(dict_prefix + \".min_intersections\", PolygonDictionary::kMinIntersectionsDefault);\n-        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type, min_intersections, max_depth);\n+        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, configuration, min_intersections, max_depth);\n     }\n     else\n-        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, input_type, point_type);\n+        return std::make_unique<PolygonDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, configuration);\n }\n \n void registerDictionaryPolygon(DictionaryFactory & factory)\ndiff --git a/src/Dictionaries/PolygonDictionaryImplementations.h b/src/Dictionaries/PolygonDictionaryImplementations.h\nindex b49bf3f4d6cd..912d501bcdea 100644\n--- a/src/Dictionaries/PolygonDictionaryImplementations.h\n+++ b/src/Dictionaries/PolygonDictionaryImplementations.h\n@@ -21,8 +21,7 @@ class PolygonDictionarySimple : public IPolygonDictionary\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n-            InputType input_type_,\n-            PointType point_type_);\n+            Configuration configuration_);\n \n     std::shared_ptr<const IExternalLoadable> clone() const override;\n \n@@ -44,8 +43,7 @@ class PolygonDictionaryIndexEach : public IPolygonDictionary\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n-            InputType input_type_,\n-            PointType point_type_,\n+            Configuration configuration_,\n             int min_intersections_,\n             int max_depth_);\n \n@@ -73,8 +71,7 @@ class PolygonDictionaryIndexCell : public IPolygonDictionary\n             const DictionaryStructure & dict_struct_,\n             DictionarySourcePtr source_ptr_,\n             DictionaryLifetime dict_lifetime_,\n-            InputType input_type_,\n-            PointType point_type_,\n+            Configuration configuration_,\n             size_t min_intersections_,\n             size_t max_depth_);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02097_polygon_dictionary_store_key.reference b/tests/queries/0_stateless/02097_polygon_dictionary_store_key.reference\nnew file mode 100644\nindex 000000000000..f44a7c2a068a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02097_polygon_dictionary_store_key.reference\n@@ -0,0 +1,1 @@\n+[[[(3,1),(0,1),(0,-1),(3,-1)]]]\tValue\ndiff --git a/tests/queries/0_stateless/02097_polygon_dictionary_store_key.sql b/tests/queries/0_stateless/02097_polygon_dictionary_store_key.sql\nnew file mode 100644\nindex 000000000000..95557da481e9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02097_polygon_dictionary_store_key.sql\n@@ -0,0 +1,38 @@\n+DROP TABLE IF EXISTS polygons_test_table;\n+CREATE TABLE polygons_test_table\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    name String\n+) ENGINE = TinyLog;\n+\n+INSERT INTO polygons_test_table VALUES ([[[(3, 1), (0, 1), (0, -1), (3, -1)]]], 'Value');\n+\n+DROP DICTIONARY IF EXISTS polygons_test_dictionary_no_option;\n+CREATE DICTIONARY polygons_test_dictionary_no_option\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    name String\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(TABLE 'polygons_test_table'))\n+LAYOUT(POLYGON())\n+LIFETIME(0);\n+\n+SELECT * FROM polygons_test_dictionary_no_option; -- {serverError 1}\n+\n+DROP DICTIONARY IF EXISTS polygons_test_dictionary;\n+CREATE DICTIONARY polygons_test_dictionary\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    name String\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(TABLE 'polygons_test_table'))\n+LAYOUT(POLYGON(STORE_POLYGON_KEY_COLUMN 1))\n+LIFETIME(0);\n+\n+SELECT * FROM polygons_test_dictionary;\n+\n+DROP DICTIONARY polygons_test_dictionary_no_option;\n+DROP DICTIONARY polygons_test_dictionary;\n+DROP TABLE polygons_test_table;\n",
  "problem_statement": "It's not possible to read POLYGON dictionaries via SELECT * FROM dict query.\n**Describe the unexpected behaviour**\r\nClickHouse returns exception if you would try to read polygon dictionary via SELECT query.\r\n\r\n**How to reproduce**\r\nClickHouse version 21.10\r\n\r\n\r\n```\r\nCREATE DICTIONARY polygon_dict (\r\n    key Array(Array(Array(Array(Float64)))),\r\n    name String,\r\n    value UInt64\r\n)\r\nPRIMARY KEY key\r\nLAYOUT(POLYGON())\r\nSOURCE(CLICKHOUSE(table 'polygon_dict_src'))\r\nLIFETIME(MIN 300 MAX 360);\r\n\r\nCREATE TABLE polygon_dict_src\r\n(\r\n    `key` Array(Array(Array(Array(Float64)))),\r\n    `name` String,\r\n    `value` UInt64\r\n)\r\nENGINE = Log\r\n\t\r\nINSERT INTO polygon_dict_src SELECT [[[[1.1,2.1],[5,3],[6,4],[1,4]]]], 'some', 10;\r\n\r\n\r\nCREATE DICTIONARY polygon_dict (\r\n    key Array(Array(Array(Array(Float64)))),\r\n    name String,\r\n    value UInt64\r\n)\r\nPRIMARY KEY key\r\nLAYOUT(POLYGON())\r\nSOURCE(CLICKHOUSE(table 'polygon_dict_src'))\r\nLIFETIME(MIN 300 MAX 360);\r\n\r\nSELECT dictGet(polygon_dict, 'name', (2., 3.)) AS x\r\n\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2510\r\n\u2502 some \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT *\r\nFROM polygon_dict\r\n\r\n0 rows in set. Elapsed: 0.008 sec.\r\n\r\nReceived exception from server (version 21.10.1):\r\nCode: 1. DB::Exception: Received from localhost:9000. DB::Exception: Reading the dictionary is not allowed. (UNSUPPORTED_METHOD)\r\n```\r\n\r\n\r\n**Expected behavior**\r\nIt's allowed to read POLYGON dictionaries via SELECT query.\r\n\n",
  "hints_text": "",
  "created_at": "2021-10-13T16:40:42Z"
}