diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 981f133791a5..f9f905624264 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -231,9 +231,14 @@ bool StorageMerge::isRemote() const
     return first_remote_table != nullptr;
 }
 
-bool StorageMerge::tableSupportsPrewhere() const
+bool StorageMerge::supportsPrewhere() const
 {
-    /// NOTE: This check is used during query analysis as condition for applying
+    return getFirstTable([](const auto & table) { return !table->supportsPrewhere(); }) == nullptr;
+}
+
+bool StorageMerge::canMoveConditionsToPrewhere() const
+{
+    /// NOTE: This check and the above check are used during query analysis as condition for applying
     /// "move to PREWHERE" optimization. However, it contains a logical race:
     /// If new table that matches regexp for current storage and doesn't support PREWHERE
     /// will appear after this check and before calling "read" method, the optimized query may fail.
diff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h
index 882744df675f..82f8fb78feca 100644
--- a/src/Storages/StorageMerge.h
+++ b/src/Storages/StorageMerge.h
@@ -50,9 +50,11 @@ class StorageMerge final : public IStorage, WithContext
     bool supportsFinal() const override { return true; }
     bool supportsSubcolumns() const override { return true; }
     bool supportsDynamicSubcolumns() const override { return true; }
-    bool supportsPrewhere() const override { return tableSupportsPrewhere(); }
+    bool supportsPrewhere() const override;
     std::optional<NameSet> supportedPrewhereColumns() const override;
 
+    bool canMoveConditionsToPrewhere() const override;
+
     QueryProcessingStage::Enum
     getQueryProcessingStage(ContextPtr, QueryProcessingStage::Enum, const StorageSnapshotPtr &, SelectQueryInfo &) const override;
 
