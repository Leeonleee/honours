{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79491,
  "instance_id": "ClickHouse__ClickHouse-79491",
  "issue_numbers": [
    "61738"
  ],
  "base_commit": "8e6ec83f2ab71291bf8bc78b719d62ea4b6a6c97",
  "patch": "diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp\nindex b6f4798c184f..ba685a5db583 100644\n--- a/src/Core/Block.cpp\n+++ b/src/Core/Block.cpp\n@@ -61,21 +61,27 @@ static ReturnType checkColumnStructure(const ColumnWithTypeAndName & actual, con\n         return ReturnType(true);\n \n     const IColumn * actual_column = actual.column.get();\n+    const IColumn * expected_column = expected.column.get();\n \n-    /// If we allow to materialize, and expected column is not const or sparse, then unwrap actual column.\n+    /// If we allow to materialize columns, omit Const and Sparse columns.\n     if (allow_materialize)\n     {\n-        if (!isColumnConst(*expected.column))\n-            if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))\n-                actual_column = &column_const->getDataColumn();\n+        if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))\n+            actual_column = &column_const->getDataColumn();\n \n-        if (!expected.column->isSparse())\n-            if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(actual_column))\n-                actual_column = &column_sparse->getValuesColumn();\n+        if (const auto * column_const = typeid_cast<const ColumnConst *>(expected_column))\n+            expected_column = &column_const->getDataColumn();\n+\n+        if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(actual_column))\n+            actual_column = &column_sparse->getValuesColumn();\n+\n+        if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(expected_column))\n+            expected_column = &column_sparse->getValuesColumn();\n     }\n \n     const auto * actual_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(actual_column);\n-    const auto * expected_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(expected.column.get());\n+    const auto * expected_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(expected_column);\n+\n     if (actual_column_maybe_agg && expected_column_maybe_agg)\n     {\n         if (!actual_column_maybe_agg->getAggregateFunction()->haveSameStateRepresentation(*expected_column_maybe_agg->getAggregateFunction()))\n@@ -85,13 +91,16 @@ static ReturnType checkColumnStructure(const ColumnWithTypeAndName & actual, con\n                     actual.dumpStructure(),\n                     expected.dumpStructure());\n     }\n-    else if (actual_column->getName() != expected.column->getName())\n+    else if (actual_column->getName() != expected_column->getName())\n+    {\n         return onError<ReturnType>(code,\n                 \"Block structure mismatch in {} stream: different columns:\\n{}\\n{}\",\n                 context_description,\n                 actual.dumpStructure(),\n                 expected.dumpStructure());\n \n+    }\n+\n     if (isColumnConst(*actual.column) && isColumnConst(*expected.column)\n         && !actual.column->empty() && !expected.column->empty()) /// don't check values in empty columns\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.reference b/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.reference\nindex 01c8b1dc904d..1e53502e4ef2 100644\n--- a/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.reference\n+++ b/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.reference\n@@ -1,2 +1,3 @@\n redefined\n redefined\n+redefined\ndiff --git a/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.sql b/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.sql\nindex 891eb7aac1c7..bbbdde7f4394 100644\n--- a/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.sql\n+++ b/tests/queries/0_stateless/03121_analyzer_filed_redefenition_in_subquery.sql\n@@ -28,7 +28,6 @@ FROM\n );\n \n -- query 3\n--- it works with old analyzer\n SELECT my_field\n FROM\n (\n@@ -36,4 +35,4 @@ FROM\n         *,\n         'redefined' AS my_field\n \tfrom (select * from test_subquery)\n-); -- {serverError AMBIGUOUS_COLUMN_NAME}\n+);\ndiff --git a/tests/queries/0_stateless/03443_projection_sparse.reference b/tests/queries/0_stateless/03443_projection_sparse.reference\nnew file mode 100644\nindex 000000000000..0cfbf08886fc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03443_projection_sparse.reference\n@@ -0,0 +1,1 @@\n+2\ndiff --git a/tests/queries/0_stateless/03443_projection_sparse.sql b/tests/queries/0_stateless/03443_projection_sparse.sql\nnew file mode 100644\nindex 000000000000..50f257a22f12\n--- /dev/null\n+++ b/tests/queries/0_stateless/03443_projection_sparse.sql\n@@ -0,0 +1,28 @@\n+\n+DROP TABLE IF EXISTS t_projection_sparse;\n+CREATE TABLE t_projection_sparse\n+(\n+    `id` String,\n+    `val` AggregateFunction(sum, UInt64),\n+    PROJECTION projection_traces_by_id\n+    (\n+        SELECT\n+          id,\n+          finalizeAggregation(val)\n+        ORDER BY finalizeAggregation(val)\n+    )\n+)\n+ENGINE = AggregatingMergeTree\n+ORDER BY id\n+SETTINGS deduplicate_merge_projection_mode = 'rebuild', index_granularity = 1;\n+\n+INSERT INTO t_projection_sparse VALUES ('aa', initializeAggregation('sumState', 0::UInt64));\n+INSERT INTO t_projection_sparse VALUES ('aa', initializeAggregation('sumState', 0::UInt64));\n+INSERT INTO t_projection_sparse VALUES ('bb', initializeAggregation('sumState', 0::UInt64));\n+\n+OPTIMIZE TABLE t_projection_sparse FINAL;\n+OPTIMIZE TABLE t_projection_sparse FINAL;\n+\n+SELECT count() FROM t_projection_sparse WHERE finalizeAggregation(val) = 0;\n+\n+DROP TABLE t_projection_sparse;\n",
  "problem_statement": "Merges failing due to block structure mismatch from projection on aggregatedmergetree\n**Describe what's wrong**\r\n\r\nversion: 24.1.2.5\r\n\r\nMerges are failing with this aggregated merge tree schema. Also wondering if there is a different way of going about the projection.\r\n\r\nexample table schema:\r\n```sql\r\nCREATE TABLE tracing.otel_traces_aggregated_trace_id_ts_local\r\n(\r\n    `trace_id` String,\r\n    `request_id` AggregateFunction(argMin, String, DateTime64(3)),\r\n    `start` SimpleAggregateFunction(min, DateTime64(3)),\r\n    `end` SimpleAggregateFunction(max, DateTime64(3)),\r\n    PROJECTION projection_traces_by_id\r\n    (\r\n        SELECT\r\n          trace_id,\r\n          finalizeAggregation(request_id) AS _request_id\r\n        ORDER BY finalizeAggregation(request_id)\r\n    )\r\n)\r\nENGINE = AggregatingMergeTree\r\nPARTITION BY toStartOfDay(start)\r\nORDER BY trace_id\r\n```\r\n\r\nmerges fail with:\r\n```\r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different columns:\r\nfinalizeAggregation(request_id) String String(size = 8192)\r\nfinalizeAggregation(request_id) String Sparse(size = 8192, String(size = 1), UInt64(size = 0)). (AMBIGUOUS_COLUMN_NAME), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000c800f1b in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<std::basic_string_view<char, std::char_traits<char>>&, String, String>(int, FormatStringHelperImpl<std::type_identity<std::basic_string_view<char, std::char_traits<char>>&>::type, std::type_identity<String>::type, std::type_identity<String>::type>, std::basic_string_view<char, std::char_traits<char>>&, String&&, String&&) @ 0x0000000010526e8a in /usr/bin/clickhouse\r\n2. void DB::onError<void, std::basic_string_view<char, std::char_traits<char>>&, String, String>(int, FormatStringHelperImpl<std::type_identity<std::basic_string_view<char, std::char_traits<char>>&>::type, std::type_identity<String>::type, std::type_identity<String>::type>, std::basic_string_view<char, std::char_traits<char>>&, String&&, String&&) @ 0x0000000010526d2e in /usr/bin/clickhouse\r\n3. void DB::checkColumnStructure<void>(DB::ColumnWithTypeAndName const&, DB::ColumnWithTypeAndName const&, std::basic_string_view<char, std::char_traits<char>>, bool, int) (.llvm.8893857084970946537) @ 0x0000000010521323 in /usr/bin/clickhouse\r\n4. DB::Block::insert(DB::ColumnWithTypeAndName) @ 0x000000001052173f in /usr/bin/clickhouse\r\n5. DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool) const @ 0x0000000010d3e61e in /usr/bin/clickhouse\r\n6. DB::ExpressionTransform::transform(DB::Chunk&) @ 0x0000000012bff813 in /usr/bin/clickhouse\r\n7. DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x000000000e7ccef0 in /usr/bin/clickhouse\r\n8. DB::ISimpleTransform::work() @ 0x0000000012977af2 in /usr/bin/clickhouse\r\n9. DB::ExecutionThreadContext::executeTask() @ 0x000000001299371a in /usr/bin/clickhouse\r\n10. DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x000000001298a170 in /usr/bin/clickhouse\r\n11. DB::PipelineExecutor::executeStep(std::atomic<bool>*) @ 0x0000000012989928 in /usr/bin/clickhouse\r\n12. DB::PullingPipelineExecutor::pull(DB::Chunk&) @ 0x0000000012998017 in /usr/bin/clickhouse\r\n13. DB::PullingPipelineExecutor::pull(DB::Block&) @ 0x00000000129981d3 in /usr/bin/clickhouse\r\n14. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl() @ 0x000000001233b6f2 in /usr/bin/clickhouse\r\n15. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::execute() @ 0x000000001233b64b in /usr/bin/clickhouse\r\n16. DB::MergeTask::execute() @ 0x0000000012340d99 in /usr/bin/clickhouse\r\n17. bool std::__function::__policy_invoker<bool ()>::__call_impl<std::__function::__default_alloc_func<DB::MergeTask::MergeProjectionsStage::subtasks::'lambda0'(), bool ()>>(std::__function::__policy_storage const*) @ 0x000000001234536d in /usr/bin/clickhouse\r\n18. DB::MergeTask::MergeProjectionsStage::execute() @ 0x00000000123413ab in /usr/bin/clickhouse\r\n19. DB::MergeTask::execute() @ 0x0000000012340d99 in /usr/bin/clickhouse\r\n20. DB::MergePlainMergeTreeTask::executeStep() @ 0x0000000012723517 in /usr/bin/clickhouse\r\n21. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::threadFunction() @ 0x00000000123532c4 in /usr/bin/clickhouse\r\n22. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0x000000000c8eb0c1 in /usr/bin/clickhouse\r\n23. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000c8ee8fa in /usr/bin/clickhouse\r\n24. void* std::__thread_proxy[abi:v15000]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000c8ed6fe in /usr/bin/clickhouse\r\n25. ? @ 0x0000784f86d93609\r\n26. ? @ 0x0000784f86cb8353\r\n27. ```\n",
  "hints_text": "I get a similar error during projection merges even without the aggregations. \r\n\r\nTable:\r\n```\r\nCREATE TABLE default.tt\r\n(\r\n    `id` Int32 CODEC(Delta(4), LZ4),\r\n    `name` String CODEC(LZ4),\r\n    `type` String CODEC(LZ4),\r\n    `id2` Int32 CODEC(Delta(4), LZ4),\r\n    `id3` Int32 CODEC(Delta(4), LZ4),\r\n    PROJECTION name_idx\r\n    (\r\n        SELECT \r\n            lower(name),\r\n            id,\r\n            id2\r\n        ORDER BY \r\n            lower(name),\r\n            id,\r\n            id2\r\n    )\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY (id, id2)\r\nORDER BY (id, id2)\r\nSETTINGS index_granularity = 8192\r\nCOMMENT 'comments'\r\n```\r\n\r\nError message:\r\n```\r\n<Error> virtual bool DB::MutatePlainMergeTreeTask::executeStep(): \r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different columns:\r\nlower(name) String String(size = 8192)\r\nlower(name) String Sparse(size = 8192, String(size = 8193), UInt64(size = 8192)). (AMBIGUOUS_COLUMN_NAME), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000dbbc9bb\r\n1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000007e74dec\r\n2. DB::Exception::Exception<std::basic_string_view<char, std::char_traits<char>>&, String, String>(int, FormatStringHelperImpl<std::type_identity<std::basic_string_view<char, std::char_traits<char>>&>::type, std::type_identity<String>::type, std::type_identity<String>::type>, std::basic_string_view<char, std::char_traits<char>>&, String&&, String&&) @ 0x0000000010ed450b\r\n3. void DB::onError<void, std::basic_string_view<char, std::char_traits<char>>&, String, String>(int, FormatStringHelperImpl<std::type_identity<std::basic_string_view<char, std::char_traits<char>>&>::type, std::type_identity<String>::type, std::type_identity<String>::type>, std::basic_string_view<char, std::char_traits<char>>&, String&&, String&&) @ 0x0000000010ed440e\r\n4. void DB::checkColumnStructure<void>(DB::ColumnWithTypeAndName const&, DB::ColumnWithTypeAndName const&, std::basic_string_view<char, std::char_traits<char>>, bool, int) (.llvm.4524728447565987230) @ 0x0000000010ece0e3\r\n5. DB::Block::insert(DB::ColumnWithTypeAndName) @ 0x0000000010ece4ff\r\n6. DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool, bool) const @ 0x000000001176d92a\r\n7. DB::ExpressionTransform::transform(DB::Chunk&) @ 0x00000000133d4616\r\n8. DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x000000000def7c33\r\n9. DB::ISimpleTransform::work() @ 0x0000000013154ff2\r\n10. DB::ExecutionThreadContext::executeTask() @ 0x00000000131713c7\r\n11. DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000013164e90\r\n12. DB::PipelineExecutor::executeStep(std::atomic<bool>*) @ 0x0000000013164888\r\n13. DB::PullingPipelineExecutor::pull(DB::Chunk&) @ 0x0000000013175737\r\n14. DB::PullingPipelineExecutor::pull(DB::Block&) @ 0x0000000013175959\r\n15. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl() const @ 0x0000000012a71297\r\n16. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::execute() @ 0x0000000012a70aae\r\n17. DB::MergeTask::execute() @ 0x0000000012a79702\r\n18. DB::MergeProjectionPartsTask::executeStep() @ 0x0000000012a90ba8\r\n19. DB::PartMergerWriter::execute() @ 0x0000000012d055f7\r\n20. DB::MutateSomePartColumnsTask::executeStep() @ 0x0000000012d05b00\r\n21. DB::MutateTask::execute() @ 0x0000000012cea245\r\n22. DB::MutatePlainMergeTreeTask::executeStep() @ 0x0000000012e71d5a\r\n23. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::threadFunction() @ 0x0000000012a9917d\r\n24. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false, true>, void*>) @ 0x000000000dc92a18\r\n25. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000dc97b51\r\n26. void* std::__thread_proxy[abi:v15007]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000dc95f7f\r\n27. ? @ 0x00007f996389f7f2\r\n28. ? @ 0x00007f996383f450\r\n```",
  "created_at": "2025-04-23T15:51:25Z"
}