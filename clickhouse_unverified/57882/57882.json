{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57882,
  "instance_id": "ClickHouse__ClickHouse-57882",
  "issue_numbers": [
    "56939"
  ],
  "base_commit": "52058211e7ff227feb9c890f641d2299af9a246c",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\nindex 6c1fff531099..b740f33593c8 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.cpp\n@@ -1,22 +1,23 @@\n #include <Storages/MergeTree/MergeTreeIndexFullText.h>\n \n #include <Columns/ColumnArray.h>\n-#include <DataTypes/DataTypesNumber.h>\n+#include <Common/OptimizedRegularExpression.h>\n+#include <Core/Defines.h>\n #include <DataTypes/DataTypeArray.h>\n-#include <IO/WriteHelpers.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/misc.h>\n-#include <Storages/MergeTree/MergeTreeData.h>\n-#include <Storages/MergeTree/RPNBuilder.h>\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTSelectQuery.h>\n-#include <Core/Defines.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Storages/MergeTree/MergeTreeData.h>\n+#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n+#include <Storages/MergeTree/RPNBuilder.h>\n \n #include <Poco/Logger.h>\n \n@@ -201,6 +202,7 @@ bool MergeTreeConditionFullText::alwaysUnknownOrTrue() const\n              || element.function == RPNElement::FUNCTION_IN\n              || element.function == RPNElement::FUNCTION_NOT_IN\n              || element.function == RPNElement::FUNCTION_MULTI_SEARCH\n+             || element.function == RPNElement::FUNCTION_MATCH\n              || element.function == RPNElement::FUNCTION_HAS_ANY\n              || element.function == RPNElement::ALWAYS_FALSE)\n         {\n@@ -285,8 +287,27 @@ bool MergeTreeConditionFullText::mayBeTrueOnGranule(MergeTreeIndexGranulePtr idx\n             for (size_t row = 0; row < bloom_filters.size(); ++row)\n                 result[row] = result[row] && granule->bloom_filters[element.key_column].contains(bloom_filters[row]);\n \n-            rpn_stack.emplace_back(\n-                    std::find(std::cbegin(result), std::cend(result), true) != std::end(result), true);\n+            rpn_stack.emplace_back(std::find(std::cbegin(result), std::cend(result), true) != std::end(result), true);\n+        }\n+        else if (element.function == RPNElement::FUNCTION_MATCH)\n+        {\n+            if (!element.set_bloom_filters.empty())\n+            {\n+                /// Alternative substrings\n+                std::vector<bool> result(element.set_bloom_filters.back().size(), true);\n+\n+                const auto & bloom_filters = element.set_bloom_filters[0];\n+\n+                for (size_t row = 0; row < bloom_filters.size(); ++row)\n+                    result[row] = result[row] && granule->bloom_filters[element.key_column].contains(bloom_filters[row]);\n+\n+                rpn_stack.emplace_back(std::find(std::cbegin(result), std::cend(result), true) != std::end(result), true);\n+            }\n+            else if (element.bloom_filter)\n+            {\n+                /// Required substrings\n+                rpn_stack.emplace_back(granule->bloom_filters[element.key_column].contains(*element.bloom_filter), true);\n+            }\n         }\n         else if (element.function == RPNElement::FUNCTION_NOT)\n         {\n@@ -392,6 +413,7 @@ bool MergeTreeConditionFullText::extractAtomFromTree(const RPNBuilderTreeNode &\n                  function_name == \"notEquals\" ||\n                  function_name == \"has\" ||\n                  function_name == \"mapContains\" ||\n+                 function_name == \"match\" ||\n                  function_name == \"like\" ||\n                  function_name == \"notLike\" ||\n                  function_name.starts_with(\"hasToken\") ||\n@@ -513,6 +535,7 @@ bool MergeTreeConditionFullText::traverseTreeEquals(\n         token_extractor->stringToBloomFilter(value.data(), value.size(), *out.bloom_filter);\n         return true;\n     }\n+\n     else if (function_name == \"has\")\n     {\n         out.key_column = *key_index;\n@@ -600,6 +623,39 @@ bool MergeTreeConditionFullText::traverseTreeEquals(\n         out.set_bloom_filters = std::move(bloom_filters);\n         return true;\n     }\n+    else if (function_name == \"match\")\n+    {\n+        out.key_column = *key_index;\n+        out.function = RPNElement::FUNCTION_MATCH;\n+        out.bloom_filter = std::make_unique<BloomFilter>(params);\n+\n+        auto & value = const_value.get<String>();\n+        String required_substring;\n+        bool dummy_is_trivial, dummy_required_substring_is_prefix;\n+        std::vector<String> alternatives;\n+        OptimizedRegularExpression::analyze(value, required_substring, dummy_is_trivial, dummy_required_substring_is_prefix, alternatives);\n+\n+        if (required_substring.empty() && alternatives.empty())\n+            return false;\n+\n+        /// out.set_bloom_filters means alternatives exist\n+        /// out.bloom_filter means required_substring exists\n+        if (!alternatives.empty())\n+        {\n+            std::vector<std::vector<BloomFilter>> bloom_filters;\n+            bloom_filters.emplace_back();\n+            for (const auto & alternative : alternatives)\n+            {\n+                bloom_filters.back().emplace_back(params);\n+                token_extractor->stringToBloomFilter(alternative.data(), alternative.size(), bloom_filters.back().back());\n+            }\n+            out.set_bloom_filters = std::move(bloom_filters);\n+        }\n+        else\n+           token_extractor->stringToBloomFilter(required_substring.data(), required_substring.size(), *out.bloom_filter);\n+\n+        return true;\n+    }\n \n     return false;\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexFullText.h b/src/Storages/MergeTree/MergeTreeIndexFullText.h\nindex 22f9215d5630..5b1cf8c1f1d6 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexFullText.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexFullText.h\n@@ -90,6 +90,7 @@ class MergeTreeConditionFullText final : public IMergeTreeIndexCondition\n             FUNCTION_NOT_EQUALS,\n             FUNCTION_HAS,\n             FUNCTION_IN,\n+            FUNCTION_MATCH,\n             FUNCTION_NOT_IN,\n             FUNCTION_MULTI_SEARCH,\n             FUNCTION_HAS_ANY,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.reference b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.reference\nnew file mode 100644\nindex 000000000000..1cf1644fe0ab\n--- /dev/null\n+++ b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.reference\n@@ -0,0 +1,38 @@\n+1\tHello ClickHouse\n+2\tHello World\n+1\tHello ClickHouse\n+2\tHello World\n+          Granules: 6/6\n+          Granules: 2/6\n+            Granules: 6/6\n+            Granules: 2/6\n+          Granules: 6/6\n+          Granules: 2/6\n+            Granules: 6/6\n+            Granules: 2/6\n+---\n+1\tHello ClickHouse\n+2\tHello World\n+6\tWorld Champion\n+1\tHello ClickHouse\n+2\tHello World\n+6\tWorld Champion\n+          Granules: 6/6\n+          Granules: 3/6\n+            Granules: 6/6\n+            Granules: 3/6\n+          Granules: 6/6\n+          Granules: 3/6\n+            Granules: 6/6\n+            Granules: 3/6\n+---\n+5\tOLAP Database\n+5\tOLAP Database\n+          Granules: 6/6\n+          Granules: 1/6\n+            Granules: 6/6\n+            Granules: 1/6\n+          Granules: 6/6\n+          Granules: 1/6\n+            Granules: 6/6\n+            Granules: 1/6\ndiff --git a/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.sql b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.sql\nnew file mode 100644\nindex 000000000000..49d39c601ef6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.sql\n@@ -0,0 +1,185 @@\n+DROP TABLE IF EXISTS tokenbf_tab;\n+DROP TABLE IF EXISTS ngrambf_tab;\n+\n+CREATE TABLE tokenbf_tab\n+(\n+    id UInt32,\n+    str String,\n+    INDEX idx str TYPE tokenbf_v1(256, 2, 0)\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+SETTINGS index_granularity = 1;\n+\n+CREATE TABLE ngrambf_tab\n+(\n+    id UInt32,\n+    str String,\n+    INDEX idx str TYPE ngrambf_v1(3, 256, 2, 0)\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+SETTINGS index_granularity = 1;\n+\n+INSERT INTO tokenbf_tab VALUES (1, 'Hello ClickHouse'), (2, 'Hello World'), (3, 'Good Weather'), (4, 'Say Hello'), (5, 'OLAP Database'), (6, 'World Champion');\n+INSERT INTO ngrambf_tab VALUES (1, 'Hello ClickHouse'), (2, 'Hello World'), (3, 'Good Weather'), (4, 'Say Hello'), (5, 'OLAP Database'), (6, 'World Champion');\n+\n+SELECT * FROM tokenbf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id;\n+SELECT * FROM ngrambf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id;\n+\n+-- Read 2/6 granules\n+-- Required string: 'Hello '\n+-- Alternatives: 'Hello ClickHouse', 'Hello World'\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes=1\n+    SELECT * FROM tokenbf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes=1\n+    SELECT * FROM tokenbf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes=1\n+    SELECT * FROM ngrambf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes=1\n+    SELECT * FROM ngrambf_tab WHERE match(str, 'Hello (ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+\n+SELECT '---';\n+\n+SELECT * FROM tokenbf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id;\n+SELECT * FROM ngrambf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id;\n+\n+-- Read 3/6 granules\n+-- Required string: -\n+-- Alternatives: 'ClickHouse', 'World'\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM tokenbf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM tokenbf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM ngrambf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM ngrambf_tab WHERE match(str, '.*(ClickHouse|World)') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+SELECT '---';\n+\n+SELECT * FROM tokenbf_tab WHERE match(str, 'OLAP.*') ORDER BY id;\n+SELECT * FROM ngrambf_tab WHERE match(str, 'OLAP.*') ORDER BY id;\n+\n+-- Read 1/6 granules\n+-- Required string: 'OLAP'\n+-- Alternatives: -\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM tokenbf_tab WHERE match(str, 'OLAP (.*?)*') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM tokenbf_tab WHERE match(str, 'OLAP (.*?)*') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM ngrambf_tab WHERE match(str, 'OLAP (.*?)*') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 0;\n+\n+SELECT *\n+FROM\n+(\n+    EXPLAIN PLAN indexes = 1\n+    SELECT * FROM ngrambf_tab WHERE match(str, 'OLAP (.*?)*') ORDER BY id\n+)\n+WHERE\n+    explain LIKE '%Granules: %'\n+SETTINGS\n+  allow_experimental_analyzer = 1;\n+\n+DROP TABLE tokenbf_tab;\n+DROP TABLE ngrambf_tab;\n",
  "problem_statement": "Add support for bloom filter based indexes for `match`/`REGEXP`\n- We have bloom-filter-based skip indexes `ngrambf_v1`/`tokenbf_v1`.\r\n- These indexes are supported by many operators/functions, including `like()`/`has()`/`hasToken()`,\r\nsee https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#functions-support\r\n- `match()` function has no optimizations related to bloom-filter-based skip indexes\r\n\r\nUse case: user specifies a complex regexp in a `match()` predicate and it is not obvious that performance can be improved if user will add additional `has` condition before `match`.\r\n\r\nTo implement this: get a list of \"required\" substrings from the regexp, i.e. strings that are present in every matching string (see `OptimizedRegularExpression::analyze()`), then query the skip indexes with these substrings.\r\n\n",
  "hints_text": "I'm interesting in this. Could you let me try this ?\nIf it's urgent, you can assign it to someone else. Because I'm still working on another task.\r\n\nSure, you can.",
  "created_at": "2023-12-15T02:48:33Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeIndexFullText.cpp",
    "src/Storages/MergeTree/MergeTreeIndexFullText.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.reference",
    "b/tests/queries/0_stateless/02943_tokenbf_and_ngrambf_indexes_support_match_function.sql"
  ]
}