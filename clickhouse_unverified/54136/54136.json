{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54136,
  "instance_id": "ClickHouse__ClickHouse-54136",
  "issue_numbers": [
    "38585"
  ],
  "base_commit": "8f6cd157b9f7169793856da73971cb9b2a860427",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 00e2ebcda434..041a44aec268 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -87,6 +87,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NOT_IMPLEMENTED;\n     extern const int CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN;\n+    extern const int CANNOT_PARSE_BOOL;\n }\n \n \n@@ -1597,7 +1598,19 @@ struct ConvertImplGenericFromString\n \n                 const auto & val = col_from_string->getDataAt(i);\n                 ReadBufferFromMemory read_buffer(val.data, val.size);\n-                serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n+                try\n+                {\n+                    serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n+                }\n+                catch (const Exception & e)\n+                {\n+                    if (e.code() == ErrorCodes::CANNOT_PARSE_BOOL && typeid_cast<ColumnNullable *>(&column_to))\n+                    {\n+                        column_to.insertDefault();\n+                        continue;\n+                    }\n+                    throw;\n+                }\n \n                 if (!read_buffer.eof())\n                 {\n@@ -4054,15 +4067,21 @@ class FunctionCast final : public FunctionCastBase\n             {\n                 if constexpr (std::is_same_v<ToDataType, DataTypeIPv4>)\n                 {\n-                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, requested_result_is_nullable](\n-                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n-                            -> ColumnPtr\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n+                           input_format_ipv4_default_on_conversion_error_value,\n+                           requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t) -> ColumnPtr\n                     {\n                         if (!WhichDataType(result_type).isIPv4())\n                             throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n \n                         const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value || requested_result_is_nullable)\n+                        if (requested_result_is_nullable)\n+                            return convertToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value)\n                             return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                         else\n                             return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n@@ -4073,16 +4092,22 @@ class FunctionCast final : public FunctionCastBase\n \n                 if constexpr (std::is_same_v<ToDataType, DataTypeIPv6>)\n                 {\n-                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n-                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n-                            -> ColumnPtr\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n+                           input_format_ipv6_default_on_conversion_error_value,\n+                           requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t) -> ColumnPtr\n                     {\n                         if (!WhichDataType(result_type).isIPv6())\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv6\", result_type->getName());\n \n                         const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                        if (requested_result_is_nullable)\n+                            return convertToIPv6<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value)\n                             return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                         else\n                             return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n@@ -4093,7 +4118,18 @@ class FunctionCast final : public FunctionCastBase\n \n                 if (to_type->getCustomSerialization() && to_type->getCustomName())\n                 {\n-                    ret = &ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute;\n+                    ret = [requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t input_rows_count) -> ColumnPtr\n+                    {\n+                        auto wrapped_result_type = result_type;\n+                        if (requested_result_is_nullable)\n+                            wrapped_result_type = makeNullable(result_type);\n+                        return ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute(\n+                            arguments, wrapped_result_type, column_nullable, input_rows_count);\n+                    };\n                     return true;\n                 }\n             }\n@@ -4108,7 +4144,9 @@ class FunctionCast final : public FunctionCastBase\n                             ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n \n                     const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                    if (cast_ipv4_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                    if (requested_result_is_nullable)\n+                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                    else if (cast_ipv4_ipv6_default_on_conversion_error_value)\n                         return convertIPv6ToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                     else\n                         return convertIPv6ToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\nindex 31a9c37421e8..296b0b553f4d 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n@@ -42,3 +42,8 @@\n 2023-05-30\n 2149-06-06\n 1970-01-20\n+Tests for issue #38585\n+\\N\n+\\N\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\nindex f00f6ef837ff..5d580a8f32fd 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n@@ -49,3 +49,10 @@ SELECT accurateCastOrNull('1xxx', 'Date');\n SELECT accurateCastOrNull('2023-05-30', 'Date');\n SELECT accurateCastOrNull('2180-01-01', 'Date');\n SELECT accurateCastOrNull(19, 'Date');\n+\n+SELECT 'Tests for issue #38585';\n+select accurateCastOrNull('test', 'Bool');\n+select accurateCast('test', 'Nullable(Bool)');\n+\n+select accurateCastOrNull('test', 'IPv4');\n+select accurateCastOrNull('test', 'IPv6');\ndiff --git a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\nindex 159ee805f265..08ade20ed1dc 100644\n--- a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\n+++ b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\n@@ -17,7 +17,7 @@ true\n \\N\n 0.0.0.0\n \\N\n-0.0.0.0\n+\\N\n \\N\n \\N\n \\N\n@@ -25,7 +25,7 @@ true\n \\N\n ::\n \\N\n-::\n+\\N\n \\N\n \\N\n \\N\n",
  "problem_statement": "accurateCastOrNull raises an exception, rather than simply returning null when casting an invalid value to Bool\n**Describe what's wrong**\r\n\r\naccurateCastOrNull raises an exception, rather than simply returning null when casting an invalid value to Bool\r\n\r\n```\r\nCode: 467. DB::Exception: Received from 127.0.0.1:9000. DB::Exception: Cannot parse boolean value here: 'test', should be 'true' or 'false' controlled by setting bool_true_representation and bool_false_representation or one of True/False/T/F/Y/N/Yes/No/On/Off/Enable/Disable/Enabled/Disabled/1/0: While processing accurateCastOrNull('test', 'Bool'). (CANNOT_PARSE_BOOL)\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nClickHouse server version 22.7.1.906 (official build).\r\n\r\n**How to reproduce**\r\n\r\n```\r\nselect accurateCastOrNull('test', 'Bool')\r\n```\r\n\r\n**Expected behavior**\r\n\r\n```\r\nI expect it to behave the same as an invalid cast to something like UInt8\r\n\r\nSELECT accurateCastOrNull('test', 'UInt8')\r\n\r\nQuery id: e7d0473b-6ae0-455d-9eae-fb3827e7c671\r\n\r\n\u250c\u2500accurateCastOrNull('test', 'UInt8')\u2500\u2510\r\n\u2502                                \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "@alexey-milovidov @antonio2368 \r\nI'm also experiencing this, and it's pretty easy to reproduce as well. \r\nThe work around that I found - which is suitable for our use case, doesn't mean it works for every case - is to use `reinterpret` which will return true if there's a value:\r\n\r\n```\r\na60baef7f266 :) select reinterpret('', 'Boolean')\r\n\r\nSELECT reinterpret('', 'Boolean')\r\n\r\nQuery id: b5324ddf-9854-4f16-bdac-c3f95348cb5e\r\n\r\n\u250c\u2500reinterpret('', 'Boolean')\u2500\u2510\r\n\u2502 false                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.005 sec.\r\n\r\na60baef7f266 :) select reinterpret('test', 'Boolean')\r\n\r\nSELECT reinterpret('test', 'Boolean')\r\n\r\nQuery id: 4006fc47-d025-4931-a90c-fccd03f87bac\r\n\r\n\u250c\u2500reinterpret('test', 'Boolean')\u2500\u2510\r\n\u2502 true                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.004 sec.\r\n```\r\n\r\nCan we get some \ud83d\udc40 ?\r\nThanks in advanced!",
  "created_at": "2023-08-31T16:12:05Z"
}