{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80188,
  "instance_id": "ClickHouse__ClickHouse-80188",
  "issue_numbers": [
    "80187"
  ],
  "base_commit": "b2971a5c292df4482318e452fa301b0cad58ba8f",
  "patch": "diff --git a/src/Common/AsynchronousMetrics.cpp b/src/Common/AsynchronousMetrics.cpp\nindex aeed4dea1836..15c1c5f6ac55 100644\n--- a/src/Common/AsynchronousMetrics.cpp\n+++ b/src/Common/AsynchronousMetrics.cpp\n@@ -23,6 +23,10 @@\n #    include <jemalloc/jemalloc.h>\n #endif\n \n+#if defined(OS_LINUX)\n+#    include <netinet/tcp.h>\n+#endif\n+\n \n namespace DB\n {\n@@ -86,6 +90,8 @@ AsynchronousMetrics::AsynchronousMetrics(\n     openFileIfExists(\"/proc/cpuinfo\", cpuinfo);\n     openFileIfExists(\"/proc/sys/fs/file-nr\", file_nr);\n     openFileIfExists(\"/proc/net/dev\", net_dev);\n+    openFileIfExists(\"/proc/net/tcp\", net_tcp);\n+    openFileIfExists(\"/proc/net/tcp6\", net_tcp6);\n \n     /// CGroups v2\n     openCgroupv2MetricFile(\"memory.max\", cgroupmem_limit_in_bytes);\n@@ -1607,6 +1613,132 @@ void AsynchronousMetrics::update(TimePoint update_time, bool force_update)\n         }\n     }\n \n+    if (net_tcp || net_tcp6)\n+    {\n+        UInt64 total_sockets = 0;\n+        UInt64 sockets_by_state[16] = {};\n+        UInt64 transmit_queue_size = 0;\n+        UInt64 receive_queue_size = 0;\n+        UInt64 unrecovered_retransmits = 0;\n+        std::unordered_set<std::string> remote_addresses;\n+\n+        auto process_net = [&](const char * path, auto & file)\n+        {\n+            try\n+            {\n+                file->rewind();\n+                /// Header\n+                skipToNextLineOrEOF(*file);\n+\n+                while (!file->eof())\n+                {\n+                    /// Line number\n+                    skipWhitespaceIfAny(*file, true);\n+                    skipStringUntilWhitespace(*file);\n+                    skipWhitespaceIfAny(*file, true);\n+\n+                    /// Local address and port\n+                    skipStringUntilWhitespace(*file);\n+                    skipWhitespaceIfAny(*file, true);\n+\n+                    /// Remote address and port\n+                    String remote_address_and_port;\n+                    readStringUntilWhitespace(remote_address_and_port, *file);\n+                    skipWhitespaceIfAny(*file, true);\n+                    if (auto pos = remote_address_and_port.find(':'); pos != std::string::npos)\n+                        remote_address_and_port.resize(pos);\n+                    remote_addresses.emplace(remote_address_and_port);\n+\n+                    /// Socket state\n+                    UInt8 state = 0;\n+                    char state_hex[2]{};\n+                    readPODBinary(state_hex, *file);\n+                    skipWhitespaceIfAny(*file, true);\n+                    state = unhex2(state_hex);\n+                    if (state < 16)\n+                        ++sockets_by_state[state];\n+\n+                    /// tx_queue:rx_queue\n+                    String tx_rx_queue;\n+                    readStringUntilWhitespace(tx_rx_queue, *file);\n+                    skipWhitespaceIfAny(*file, true);\n+                    if (auto pos = tx_rx_queue.find(':'); pos != std::string::npos)\n+                    {\n+                        std::string_view tx_queue = std::string_view(tx_rx_queue).substr(0, pos);\n+                        std::string_view rx_queue = std::string_view(tx_rx_queue).substr(pos + 1);\n+\n+                        if (tx_queue.size() == 8 && rx_queue.size() == 8)\n+                        {\n+                            UInt32 tx_queue_size = unhexUInt<UInt32>(tx_queue.data()); // NOLINT\n+                            UInt32 rx_queue_size = unhexUInt<UInt32>(rx_queue.data()); // NOLINT\n+\n+                            transmit_queue_size += tx_queue_size;\n+                            receive_queue_size += rx_queue_size;\n+                        }\n+                    }\n+\n+                    /// tr:when\n+                    skipStringUntilWhitespace(*file);\n+                    skipWhitespaceIfAny(*file, true);\n+\n+                    /// Retransmits\n+                    String retransmits_str;\n+                    readStringUntilWhitespace(retransmits_str, *file);\n+                    if (retransmits_str.size() == 8)\n+                    {\n+                        UInt32 retransmits = unhexUInt<UInt32>(retransmits_str.data());\n+                        unrecovered_retransmits += retransmits;\n+                    }\n+\n+                    skipToNextLineOrEOF(*file);\n+                    ++total_sockets;\n+                }\n+            }\n+            catch (...)\n+            {\n+                tryLogCurrentException(__PRETTY_FUNCTION__);\n+                openFileIfExists(path, file);\n+            }\n+        };\n+\n+        if (net_tcp)\n+            process_net(\"/proc/net/tcp\", net_tcp);\n+\n+        if (net_tcp6)\n+            process_net(\"/proc/net/tcp6\", net_tcp6);\n+\n+        new_values[\"NetworkTCPSockets\"] = { total_sockets,\n+            \"Total number of network sockets used on the server across TCPv4 and TCPv6, in all states.\" };\n+\n+        auto process_socket_state = [&](UInt8 state, const char * description)\n+        {\n+            if (state < 16 && sockets_by_state[state])\n+                new_values[fmt::format(\"NetworkTCPSockets_{}\", description)] = { sockets_by_state[state],\n+                    \"Total number of network sockets in the specific state on the server across TCPv4 and TCPv6.\" };\n+        };\n+\n+        process_socket_state(TCP_ESTABLISHED, \"ESTABLISHED\");\n+        process_socket_state(TCP_SYN_SENT, \"SYN_SENT\");\n+        process_socket_state(TCP_SYN_RECV, \"SYN_RECV\");\n+        process_socket_state(TCP_FIN_WAIT1, \"FIN_WAIT1\");\n+        process_socket_state(TCP_FIN_WAIT2, \"FIN_WAIT2\");\n+        process_socket_state(TCP_TIME_WAIT, \"TIME_WAIT\");\n+        process_socket_state(TCP_CLOSE, \"CLOSE\");\n+        process_socket_state(TCP_CLOSE_WAIT, \"CLOSE_WAIT\");\n+        process_socket_state(TCP_LAST_ACK, \"LAST_ACK\");\n+        process_socket_state(TCP_LISTEN, \"LISTEN\");\n+        process_socket_state(TCP_CLOSING, \"CLOSING\");\n+\n+        new_values[\"NetworkTCPTransmitQueue\"] = { transmit_queue_size,\n+            \"Total size of transmit queues of network sockets used on the server across TCPv4 and TCPv6.\" };\n+        new_values[\"NetworkTCPReceiveQueue\"] = { receive_queue_size,\n+            \"Total size of receive queues of network sockets used on the server across TCPv4 and TCPv6.\" };\n+        new_values[\"NetworkTCPUnrecoveredRetransmits\"] = { unrecovered_retransmits,\n+            \"Total size of current retransmits (unrecovered at this moment) of network sockets used on the server across TCPv4 and TCPv6.\" };\n+        new_values[\"NetworkTCPSocketRemoteAddresses\"] = { remote_addresses.size(),\n+            \"Total number of unique remote addresses of network sockets used on the server across TCPv4 and TCPv6.\" };\n+    }\n+\n     if (vm_max_map_count)\n     {\n         try\ndiff --git a/src/Common/AsynchronousMetrics.h b/src/Common/AsynchronousMetrics.h\nindex 49e5c99559b7..2ee6092dbeb6 100644\n--- a/src/Common/AsynchronousMetrics.h\n+++ b/src/Common/AsynchronousMetrics.h\n@@ -132,6 +132,8 @@ class AsynchronousMetrics\n     std::optional<ReadBufferFromFilePRead> file_nr TSA_GUARDED_BY(data_mutex);\n     std::optional<ReadBufferFromFilePRead> uptime TSA_GUARDED_BY(data_mutex);\n     std::optional<ReadBufferFromFilePRead> net_dev TSA_GUARDED_BY(data_mutex);\n+    std::optional<ReadBufferFromFilePRead> net_tcp TSA_GUARDED_BY(data_mutex);\n+    std::optional<ReadBufferFromFilePRead> net_tcp6 TSA_GUARDED_BY(data_mutex);\n \n     std::optional<ReadBufferFromFilePRead> cgroupmem_limit_in_bytes TSA_GUARDED_BY(data_mutex);\n     std::optional<ReadBufferFromFilePRead> cgroupmem_usage_in_bytes TSA_GUARDED_BY(data_mutex);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03459_socket_asynchronous_metrics.reference b/tests/queries/0_stateless/03459_socket_asynchronous_metrics.reference\nnew file mode 100644\nindex 000000000000..e8183f05f5db\n--- /dev/null\n+++ b/tests/queries/0_stateless/03459_socket_asynchronous_metrics.reference\n@@ -0,0 +1,3 @@\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/03459_socket_asynchronous_metrics.sql b/tests/queries/0_stateless/03459_socket_asynchronous_metrics.sql\nnew file mode 100644\nindex 000000000000..b0bf859d2463\n--- /dev/null\n+++ b/tests/queries/0_stateless/03459_socket_asynchronous_metrics.sql\n@@ -0,0 +1,3 @@\n+SELECT value > 0 FROM system.asynchronous_metrics WHERE name = 'NetworkTCPSockets';\n+SELECT value > 0 FROM system.asynchronous_metrics WHERE name = 'NetworkTCPSockets_LISTEN';\n+SELECT value > 0 FROM system.asynchronous_metrics WHERE name = 'NetworkTCPSocketRemoteAddresses';\n",
  "problem_statement": "Add asynchronous metrics about sockets\n### Company or project name\n\nClickHouse\n\n### Use case\n\nMonitoring\n\n### Describe the solution you'd like\n\nFrom `/proc/self/net/tcp` and `/proc/self/net/tcp6`, derive the following info:\n- total number of sockets;\n- number of sockets in each state (every state represents its own metric);\n- sum of tx_queue;\n- sum of rx_queue;\n- sum of retransmits;\n- the number of unique remote addresses.\n\nThese metrics should be accumulated across IPv4 and IPv6 without distinction.\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-05-14T03:03:44Z"
}