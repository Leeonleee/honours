{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37251,
  "instance_id": "ClickHouse__ClickHouse-37251",
  "issue_numbers": [
    "25271"
  ],
  "base_commit": "3431376d4ef93968c9d9be27723bb3174526c1a6",
  "patch": "diff --git a/src/Common/OptimizedRegularExpression.h b/src/Common/OptimizedRegularExpression.h\nindex 53f3a7d34b1c..a3d38f27c07e 100644\n--- a/src/Common/OptimizedRegularExpression.h\n+++ b/src/Common/OptimizedRegularExpression.h\n@@ -107,3 +107,4 @@ class OptimizedRegularExpressionImpl\n };\n \n using OptimizedRegularExpression = OptimizedRegularExpressionImpl<true>;\n+using OptimizedRegularExpressionSingleThreaded = OptimizedRegularExpressionImpl<false>;\ndiff --git a/src/Functions/CountSubstringsImpl.h b/src/Functions/CountSubstringsImpl.h\nindex fc6e4a0e6719..c8cef81333a7 100644\n--- a/src/Functions/CountSubstringsImpl.h\n+++ b/src/Functions/CountSubstringsImpl.h\n@@ -26,19 +26,21 @@ struct CountSubstringsImpl\n     static constexpr bool supports_start_pos = true;\n     static constexpr auto name = Name::name;\n \n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {};}\n+\n     using ResultType = UInt64;\n \n     /// Count occurrences of one substring in many strings.\n     static void vectorConstant(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n         const std::string & needle,\n         const ColumnPtr & start_pos,\n         PaddedPODArray<UInt64> & res)\n     {\n-        const UInt8 * begin = data.data();\n+        const UInt8 * const begin = haystack_data.data();\n+        const UInt8 * const end = haystack_data.data() + haystack_data.size();\n         const UInt8 * pos = begin;\n-        const UInt8 * end = pos + data.size();\n \n         /// FIXME: suboptimal\n         memset(&res[0], 0, res.size() * sizeof(res[0]));\n@@ -52,15 +54,15 @@ struct CountSubstringsImpl\n         while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n         {\n             /// Determine which index it refers to.\n-            while (begin + offsets[i] <= pos)\n+            while (begin + haystack_offsets[i] <= pos)\n                 ++i;\n \n             auto start = start_pos != nullptr ? start_pos->getUInt(i) : 0;\n \n             /// We check that the entry does not pass through the boundaries of strings.\n-            if (pos + needle.size() < begin + offsets[i])\n+            if (pos + needle.size() < begin + haystack_offsets[i])\n             {\n-                auto res_pos = needle.size() + Impl::countChars(reinterpret_cast<const char *>(begin + offsets[i - 1]), reinterpret_cast<const char *>(pos));\n+                auto res_pos = needle.size() + Impl::countChars(reinterpret_cast<const char *>(begin + haystack_offsets[i - 1]), reinterpret_cast<const char *>(pos));\n                 if (res_pos >= start)\n                 {\n                     ++res[i];\n@@ -69,14 +71,14 @@ struct CountSubstringsImpl\n                 pos += needle.size();\n                 continue;\n             }\n-            pos = begin + offsets[i];\n+            pos = begin + haystack_offsets[i];\n             ++i;\n         }\n     }\n \n     /// Count number of occurrences of substring in string.\n     static void constantConstantScalar(\n-        std::string data,\n+        std::string haystack,\n         std::string needle,\n         UInt64 start_pos,\n         UInt64 & res)\n@@ -87,9 +89,9 @@ struct CountSubstringsImpl\n             return;\n \n         auto start = std::max(start_pos, UInt64(1));\n-        size_t start_byte = Impl::advancePos(data.data(), data.data() + data.size(), start - 1) - data.data();\n+        size_t start_byte = Impl::advancePos(haystack.data(), haystack.data() + haystack.size(), start - 1) - haystack.data();\n         size_t new_start_byte;\n-        while ((new_start_byte = data.find(needle, start_byte)) != std::string::npos)\n+        while ((new_start_byte = haystack.find(needle, start_byte)) != std::string::npos)\n         {\n             ++res;\n             /// Intersecting substrings in haystack accounted only once\n@@ -99,21 +101,21 @@ struct CountSubstringsImpl\n \n     /// Count number of occurrences of substring in string starting from different positions.\n     static void constantConstant(\n-        std::string data,\n+        std::string haystack,\n         std::string needle,\n         const ColumnPtr & start_pos,\n         PaddedPODArray<UInt64> & res)\n     {\n-        Impl::toLowerIfNeed(data);\n+        Impl::toLowerIfNeed(haystack);\n         Impl::toLowerIfNeed(needle);\n \n         if (start_pos == nullptr)\n         {\n-            constantConstantScalar(data, needle, 0, res[0]);\n+            constantConstantScalar(haystack, needle, 0, res[0]);\n             return;\n         }\n \n-        size_t haystack_size = Impl::countChars(data.data(), data.data() + data.size());\n+        size_t haystack_size = Impl::countChars(haystack.data(), haystack.data() + haystack.size());\n \n         size_t size = start_pos != nullptr ? start_pos->size() : 0;\n         for (size_t i = 0; i < size; ++i)\n@@ -125,7 +127,7 @@ struct CountSubstringsImpl\n                 res[i] = 0;\n                 continue;\n             }\n-            constantConstantScalar(data, needle, start, res[i]);\n+            constantConstantScalar(haystack, needle, start, res[i]);\n         }\n     }\n \n@@ -228,6 +230,12 @@ struct CountSubstringsImpl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n     }\n+\n+    template <typename... Args>\n+    static void vectorFixedVector(Args &&...)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n+    }\n };\n \n }\ndiff --git a/src/Functions/FunctionsStringSearch.h b/src/Functions/FunctionsStringSearch.h\nindex 4aa76ceec288..68425ee496e2 100644\n--- a/src/Functions/FunctionsStringSearch.h\n+++ b/src/Functions/FunctionsStringSearch.h\n@@ -15,7 +15,6 @@\n namespace DB\n {\n /** Search and replace functions in strings:\n-  *\n   * position(haystack, needle)     - the normal search for a substring in a string, returns the position (in bytes) of the found substring starting with 1, or 0 if no substring is found.\n   * positionUTF8(haystack, needle) - the same, but the position is calculated at code points, provided that the string is encoded in UTF-8.\n   * positionCaseInsensitive(haystack, needle)\n@@ -24,13 +23,29 @@ namespace DB\n   * like(haystack, pattern)        - search by the regular expression LIKE; Returns 0 or 1. Case-insensitive, but only for Latin.\n   * notLike(haystack, pattern)\n   *\n+  * ilike(haystack, pattern) - like 'like' but case-insensitive\n+  * notIlike(haystack, pattern)\n+  *\n   * match(haystack, pattern)       - search by regular expression re2; Returns 0 or 1.\n-  * multiMatchAny(haystack, [pattern_1, pattern_2, ..., pattern_n]) -- search by re2 regular expressions pattern_i; Returns 0 or 1 if any pattern_i matches.\n-  * multiMatchAnyIndex(haystack, [pattern_1, pattern_2, ..., pattern_n]) -- search by re2 regular expressions pattern_i; Returns index of any match or zero if none;\n-  * multiMatchAllIndices(haystack, [pattern_1, pattern_2, ..., pattern_n]) -- search by re2 regular expressions pattern_i; Returns an array of matched indices in any order;\n   *\n   * countSubstrings(haystack, needle) -- count number of occurrences of needle in haystack.\n   * countSubstringsCaseInsensitive(haystack, needle)\n+  * countSubstringsCaseInsensitiveUTF8(haystack, needle)\n+  *\n+  * hasToken()\n+  * hasTokenCaseInsensitive()\n+  *\n+  * JSON stuff:\n+  * visitParamExtractBool()\n+  * simpleJSONExtractBool()\n+  * visitParamExtractFloat()\n+  * simpleJSONExtractFloat()\n+  * visitParamExtractInt()\n+  * simpleJSONExtractInt()\n+  * visitParamExtractUInt()\n+  * simpleJSONExtractUInt()\n+  * visitParamHas()\n+  * simpleJSONHas()\n   *\n   * Applies regexp re2 and pulls:\n   * - the first subpattern, if the regexp has a subpattern;\n@@ -70,11 +85,7 @@ class FunctionsStringSearch : public IFunction\n \n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n     {\n-        if (!Impl::use_default_implementation_for_constants)\n-            return ColumnNumbers{};\n-        if (!Impl::supports_start_pos)\n-            return ColumnNumbers{1, 2};\n-        return ColumnNumbers{1, 2, 3};\n+        return Impl::getArgumentsThatAreAlwaysConstant();\n     }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n@@ -104,8 +115,6 @@ class FunctionsStringSearch : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n     {\n-        using ResultType = typename Impl::ResultType;\n-\n         const ColumnPtr & column_haystack = arguments[0].column;\n         const ColumnPtr & column_needle = arguments[1].column;\n \n@@ -116,6 +125,8 @@ class FunctionsStringSearch : public IFunction\n         const ColumnConst * col_haystack_const = typeid_cast<const ColumnConst *>(&*column_haystack);\n         const ColumnConst * col_needle_const = typeid_cast<const ColumnConst *>(&*column_needle);\n \n+        using ResultType = typename Impl::ResultType;\n+\n         if constexpr (!Impl::use_default_implementation_for_constants)\n         {\n             bool is_col_start_pos_const = column_start_pos == nullptr || isColumnConst(*column_start_pos);\n@@ -162,6 +173,14 @@ class FunctionsStringSearch : public IFunction\n                 col_needle_const->getValue<String>(),\n                 column_start_pos,\n                 vec_res);\n+        else if (col_haystack_vector_fixed && col_needle_vector)\n+            Impl::vectorFixedVector(\n+                col_haystack_vector_fixed->getChars(),\n+                col_haystack_vector_fixed->getN(),\n+                col_needle_vector->getChars(),\n+                col_needle_vector->getOffsets(),\n+                column_start_pos,\n+                vec_res);\n         else if (col_haystack_vector_fixed && col_needle_const)\n             Impl::vectorFixedConstant(\n                 col_haystack_vector_fixed->getChars(),\ndiff --git a/src/Functions/FunctionsVisitParam.h b/src/Functions/FunctionsVisitParam.h\nindex 09fcf8659ed8..5f86923b0d10 100644\n--- a/src/Functions/FunctionsVisitParam.h\n+++ b/src/Functions/FunctionsVisitParam.h\n@@ -83,10 +83,12 @@ struct ExtractParamImpl\n     static constexpr bool supports_start_pos = false;\n     static constexpr auto name = Name::name;\n \n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {1, 2};}\n+\n     /// It is assumed that `res` is the correct size and initialized with zeros.\n     static void vectorConstant(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n         std::string needle,\n         const ColumnPtr & start_pos,\n         PaddedPODArray<ResultType> & res)\n@@ -97,9 +99,9 @@ struct ExtractParamImpl\n         /// We are looking for a parameter simply as a substring of the form \"name\"\n         needle = \"\\\"\" + needle + \"\\\":\";\n \n-        const UInt8 * begin = data.data();\n+        const UInt8 * const begin = haystack_data.data();\n+        const UInt8 * const end = haystack_data.data() + haystack_data.size();\n         const UInt8 * pos = begin;\n-        const UInt8 * end = pos + data.size();\n \n         /// The current index in the string array.\n         size_t i = 0;\n@@ -110,19 +112,19 @@ struct ExtractParamImpl\n         while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n         {\n             /// Let's determine which index it belongs to.\n-            while (begin + offsets[i] <= pos)\n+            while (begin + haystack_offsets[i] <= pos)\n             {\n                 res[i] = 0;\n                 ++i;\n             }\n \n             /// We check that the entry does not pass through the boundaries of strings.\n-            if (pos + needle.size() < begin + offsets[i])\n-                res[i] = ParamExtractor::extract(pos + needle.size(), begin + offsets[i] - 1);  /// don't include terminating zero\n+            if (pos + needle.size() < begin + haystack_offsets[i])\n+                res[i] = ParamExtractor::extract(pos + needle.size(), begin + haystack_offsets[i] - 1);  /// don't include terminating zero\n             else\n                 res[i] = 0;\n \n-            pos = begin + offsets[i];\n+            pos = begin + haystack_offsets[i];\n             ++i;\n         }\n \n@@ -145,6 +147,12 @@ struct ExtractParamImpl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n     }\n+\n+    template <typename... Args>\n+    static void vectorFixedVector(Args &&...)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n+    }\n };\n \n \n@@ -153,20 +161,20 @@ struct ExtractParamImpl\n template <typename ParamExtractor>\n struct ExtractParamToStringImpl\n {\n-    static void vector(const ColumnString::Chars & data, const ColumnString::Offsets & offsets,\n+    static void vector(const ColumnString::Chars & haystack_data, const ColumnString::Offsets & haystack_offsets,\n                        std::string needle,\n                        ColumnString::Chars & res_data, ColumnString::Offsets & res_offsets)\n     {\n         /// Constant 5 is taken from a function that performs a similar task FunctionsStringSearch.h::ExtractImpl\n-        res_data.reserve(data.size() / 5);\n-        res_offsets.resize(offsets.size());\n+        res_data.reserve(haystack_data.size() / 5);\n+        res_offsets.resize(haystack_offsets.size());\n \n         /// We are looking for a parameter simply as a substring of the form \"name\"\n         needle = \"\\\"\" + needle + \"\\\":\";\n \n-        const UInt8 * begin = data.data();\n+        const UInt8 * const begin = haystack_data.data();\n+        const UInt8 * const end = haystack_data.data() + haystack_data.size();\n         const UInt8 * pos = begin;\n-        const UInt8 * end = pos + data.size();\n \n         /// The current index in the string array.\n         size_t i = 0;\n@@ -177,7 +185,7 @@ struct ExtractParamToStringImpl\n         while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n         {\n             /// Determine which index it belongs to.\n-            while (begin + offsets[i] <= pos)\n+            while (begin + haystack_offsets[i] <= pos)\n             {\n                 res_data.push_back(0);\n                 res_offsets[i] = res_data.size();\n@@ -185,10 +193,10 @@ struct ExtractParamToStringImpl\n             }\n \n             /// We check that the entry does not pass through the boundaries of strings.\n-            if (pos + needle.size() < begin + offsets[i])\n-                ParamExtractor::extract(pos + needle.size(), begin + offsets[i], res_data);\n+            if (pos + needle.size() < begin + haystack_offsets[i])\n+                ParamExtractor::extract(pos + needle.size(), begin + haystack_offsets[i], res_data);\n \n-            pos = begin + offsets[i];\n+            pos = begin + haystack_offsets[i];\n \n             res_data.push_back(0);\n             res_offsets[i] = res_data.size();\ndiff --git a/src/Functions/HasTokenImpl.h b/src/Functions/HasTokenImpl.h\nindex ec33a07fce30..9328bd99139b 100644\n--- a/src/Functions/HasTokenImpl.h\n+++ b/src/Functions/HasTokenImpl.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Columns/ColumnString.h>\n+#include <Core/ColumnNumbers.h>\n \n \n namespace DB\n@@ -14,7 +15,7 @@ namespace ErrorCodes\n \n /** Token search the string, means that needle must be surrounded by some separator chars, like whitespace or puctuation.\n   */\n-template <typename Name, typename TokenSearcher, bool negate_result = false>\n+template <typename Name, typename TokenSearcher, bool negate>\n struct HasTokenImpl\n {\n     using ResultType = UInt8;\n@@ -23,9 +24,11 @@ struct HasTokenImpl\n     static constexpr bool supports_start_pos = false;\n     static constexpr auto name = Name::name;\n \n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {1, 2};}\n+\n     static void vectorConstant(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n         const std::string & pattern,\n         const ColumnPtr & start_pos,\n         PaddedPODArray<UInt8> & res)\n@@ -33,12 +36,12 @@ struct HasTokenImpl\n         if (start_pos != nullptr)\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Function '{}' does not support start_pos argument\", name);\n \n-        if (offsets.empty())\n+        if (haystack_offsets.empty())\n             return;\n \n-        const UInt8 * begin = data.data();\n+        const UInt8 * const begin = haystack_data.data();\n+        const UInt8 * const end = haystack_data.data() + haystack_data.size();\n         const UInt8 * pos = begin;\n-        const UInt8 * end = pos + data.size();\n \n         /// The current index in the array of strings.\n         size_t i = 0;\n@@ -49,25 +52,25 @@ struct HasTokenImpl\n         while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n         {\n             /// Let's determine which index it refers to.\n-            while (begin + offsets[i] <= pos)\n+            while (begin + haystack_offsets[i] <= pos)\n             {\n-                res[i] = negate_result;\n+                res[i] = negate;\n                 ++i;\n             }\n \n             /// We check that the entry does not pass through the boundaries of strings.\n-            if (pos + pattern.size() < begin + offsets[i])\n-                res[i] = !negate_result;\n+            if (pos + pattern.size() < begin + haystack_offsets[i])\n+                res[i] = !negate;\n             else\n-                res[i] = negate_result;\n+                res[i] = negate;\n \n-            pos = begin + offsets[i];\n+            pos = begin + haystack_offsets[i];\n             ++i;\n         }\n \n         /// Tail, in which there can be no substring.\n         if (i < res.size())\n-            memset(&res[i], negate_result, (res.size() - i) * sizeof(res[0]));\n+            memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));\n     }\n \n     template <typename... Args>\n@@ -88,6 +91,12 @@ struct HasTokenImpl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n     }\n+\n+    template <typename... Args>\n+    static void vectorFixedVector(Args &&...)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n+    }\n };\n \n }\ndiff --git a/src/Functions/MatchImpl.h b/src/Functions/MatchImpl.h\nindex 026b38b997bf..54aaa3116fd8 100644\n--- a/src/Functions/MatchImpl.h\n+++ b/src/Functions/MatchImpl.h\n@@ -4,6 +4,7 @@\n #include <base/types.h>\n #include <Common/Volnitsky.h>\n #include <Columns/ColumnString.h>\n+#include <Core/ColumnNumbers.h>\n #include \"Regexps.h\"\n \n #include \"config_functions.h\"\n@@ -17,24 +18,24 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n+    extern const int LOGICAL_ERROR;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n+namespace impl\n+{\n \n /// Is the [I]LIKE expression reduced to finding a substring in a string?\n-static inline bool likePatternIsStrstr(const String & pattern, String & res)\n+inline bool likePatternIsSubstring(std::string_view pattern, String & res)\n {\n     if (pattern.size() < 2 || pattern.front() != '%' || pattern.back() != '%')\n         return false;\n \n-    res = \"\";\n+    res.clear();\n     res.reserve(pattern.size() - 2);\n \n-    const char * pos = pattern.data();\n-    const char * end = pos + pattern.size();\n-\n-    ++pos;\n-    --end;\n+    const char * pos = pattern.data() + 1;\n+    const char * const end = pattern.data() + pattern.size() - 1;\n \n     while (pos < end)\n     {\n@@ -60,17 +61,24 @@ static inline bool likePatternIsStrstr(const String & pattern, String & res)\n     return true;\n }\n \n-/** 'like' - if true, treat pattern as SQL LIKE or ILIKE; if false - treat pattern as re2 regexp.\n+}\n+\n+/** 'like'             - if true, treat pattern as SQL LIKE, otherwise as re2 regexp.\n+ *  'negate'           - if true, negate result\n+ *  'case_insensitive' - if true, match case insensitively\n+ *\n   * NOTE: We want to run regexp search for whole columns by one call (as implemented in function 'position')\n   *  but for that, regexp engine must support \\0 bytes and their interpretation as string boundaries.\n   */\n-template <typename Name, bool like, bool revert = false, bool case_insensitive = false>\n+template <typename Name, bool like, bool negate, bool case_insensitive>\n struct MatchImpl\n {\n     static constexpr bool use_default_implementation_for_constants = true;\n     static constexpr bool supports_start_pos = false;\n     static constexpr auto name = Name::name;\n \n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {2};}\n+\n     using ResultType = UInt8;\n \n     using Searcher = std::conditional_t<case_insensitive,\n@@ -78,25 +86,25 @@ struct MatchImpl\n           VolnitskyUTF8>;\n \n     static void vectorConstant(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n-        const String & pattern,\n-        const ColumnPtr & start_pos,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const String & needle,\n+        const ColumnPtr & start_pos_,\n         PaddedPODArray<UInt8> & res)\n     {\n-        if (start_pos != nullptr)\n+        if (start_pos_ != nullptr)\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Function '{}' doesn't support start_pos argument\", name);\n \n-        if (offsets.empty())\n+        if (haystack_offsets.empty())\n             return;\n \n         /// A simple case where the [I]LIKE expression reduces to finding a substring in a string\n         String strstr_pattern;\n-        if (like && likePatternIsStrstr(pattern, strstr_pattern))\n+        if (like && impl::likePatternIsSubstring(needle, strstr_pattern))\n         {\n-            const UInt8 * const begin = data.data();\n-            const UInt8 * const end = data.data() + data.size();\n+            const UInt8 * const begin = haystack_data.data();\n+            const UInt8 * const end = haystack_data.data() + haystack_data.size();\n             const UInt8 * pos = begin;\n \n             /// The current index in the array of strings.\n@@ -109,31 +117,29 @@ struct MatchImpl\n             while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n             {\n                 /// Let's determine which index it refers to.\n-                while (begin + offsets[i] <= pos)\n+                while (begin + haystack_offsets[i] <= pos)\n                 {\n-                    res[i] = revert;\n+                    res[i] = negate;\n                     ++i;\n                 }\n \n                 /// We check that the entry does not pass through the boundaries of strings.\n-                if (pos + strstr_pattern.size() < begin + offsets[i])\n-                    res[i] = !revert;\n+                if (pos + strstr_pattern.size() < begin + haystack_offsets[i])\n+                    res[i] = !negate;\n                 else\n-                    res[i] = revert;\n+                    res[i] = negate;\n \n-                pos = begin + offsets[i];\n+                pos = begin + haystack_offsets[i];\n                 ++i;\n             }\n \n             /// Tail, in which there can be no substring.\n             if (i < res.size())\n-                memset(&res[i], revert, (res.size() - i) * sizeof(res[0]));\n+                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));\n         }\n         else\n         {\n-            size_t size = offsets.size();\n-\n-            auto regexp = Regexps::get<like, true, case_insensitive>(pattern);\n+            auto regexp = Regexps::get<like, true, case_insensitive>(needle);\n \n             String required_substring;\n             bool is_trivial;\n@@ -141,37 +147,39 @@ struct MatchImpl\n \n             regexp->getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);\n \n+            size_t haystack_size = haystack_offsets.size();\n+\n             if (required_substring.empty())\n             {\n                 if (!regexp->getRE2()) /// An empty regexp. Always matches.\n                 {\n-                    if (size)\n-                        memset(res.data(), 1, size * sizeof(res[0]));\n+                    if (haystack_size)\n+                        memset(res.data(), 1, haystack_size * sizeof(res[0]));\n                 }\n                 else\n                 {\n                     size_t prev_offset = 0;\n-                    for (size_t i = 0; i < size; ++i)\n+                    for (size_t i = 0; i < haystack_size; ++i)\n                     {\n-                        res[i] = revert\n+                        res[i] = negate\n                             ^ regexp->getRE2()->Match(\n-                                  re2_st::StringPiece(reinterpret_cast<const char *>(&data[prev_offset]), offsets[i] - prev_offset - 1),\n+                                  {reinterpret_cast<const char *>(&haystack_data[prev_offset]), haystack_offsets[i] - prev_offset - 1},\n                                   0,\n-                                  offsets[i] - prev_offset - 1,\n+                                  haystack_offsets[i] - prev_offset - 1,\n                                   re2_st::RE2::UNANCHORED,\n                                   nullptr,\n                                   0);\n \n-                        prev_offset = offsets[i];\n+                        prev_offset = haystack_offsets[i];\n                     }\n                 }\n             }\n             else\n             {\n-                /// NOTE This almost matches with the case of LikePatternIsStrstr.\n+                /// NOTE This almost matches with the case of impl::likePatternIsSubstring.\n \n-                const UInt8 * const begin = data.data();\n-                const UInt8 * const end = data.begin() + data.size();\n+                const UInt8 * const begin = haystack_data.data();\n+                const UInt8 * const end = haystack_data.begin() + haystack_data.size();\n                 const UInt8 * pos = begin;\n \n                 /// The current index in the array of strings.\n@@ -183,79 +191,78 @@ struct MatchImpl\n                 while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n                 {\n                     /// Determine which index it refers to.\n-                    while (begin + offsets[i] <= pos)\n+                    while (begin + haystack_offsets[i] <= pos)\n                     {\n-                        res[i] = revert;\n+                        res[i] = negate;\n                         ++i;\n                     }\n \n                     /// We check that the entry does not pass through the boundaries of strings.\n-                    if (pos + required_substring.size() < begin + offsets[i])\n+                    if (pos + required_substring.size() < begin + haystack_offsets[i])\n                     {\n                         /// And if it does not, if necessary, we check the regexp.\n \n                         if (is_trivial)\n-                            res[i] = !revert;\n+                            res[i] = !negate;\n                         else\n                         {\n-                            const char * str_data = reinterpret_cast<const char *>(&data[offsets[i - 1]]);\n-                            size_t str_size = offsets[i] - offsets[i - 1] - 1;\n+                            const char * str_data = reinterpret_cast<const char *>(&haystack_data[haystack_offsets[i - 1]]);\n+                            size_t str_size = haystack_offsets[i] - haystack_offsets[i - 1] - 1;\n \n                             /** Even in the case of `required_substring_is_prefix` use UNANCHORED check for regexp,\n                               *  so that it can match when `required_substring` occurs into the string several times,\n                               *  and at the first occurrence, the regexp is not a match.\n                               */\n-\n-                            if (required_substring_is_prefix)\n-                                res[i] = revert\n-                                    ^ regexp->getRE2()->Match(\n-                                          re2_st::StringPiece(str_data, str_size),\n-                                          reinterpret_cast<const char *>(pos) - str_data,\n-                                          str_size,\n-                                          re2_st::RE2::UNANCHORED,\n-                                          nullptr,\n-                                          0);\n-                            else\n-                                res[i] = revert\n-                                    ^ regexp->getRE2()->Match(\n-                                          re2_st::StringPiece(str_data, str_size), 0, str_size, re2_st::RE2::UNANCHORED, nullptr, 0);\n+                            const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;\n+                            const size_t end_pos = str_size;\n+\n+                            res[i] = negate\n+                                ^ regexp->getRE2()->Match(\n+                                      {str_data, str_size},\n+                                      start_pos,\n+                                      end_pos,\n+                                      re2_st::RE2::UNANCHORED,\n+                                      nullptr,\n+                                      0);\n                         }\n                     }\n                     else\n-                        res[i] = revert;\n+                        res[i] = negate;\n \n-                    pos = begin + offsets[i];\n+                    pos = begin + haystack_offsets[i];\n                     ++i;\n                 }\n \n                 /// Tail, in which there can be no substring.\n                 if (i < res.size())\n-                    memset(&res[i], revert, (res.size() - i) * sizeof(res[0]));\n+                    memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));\n             }\n         }\n     }\n \n     /// Very carefully crafted copy-paste.\n     static void vectorFixedConstant(\n-        const ColumnString::Chars & data, size_t n, const String & pattern,\n+        const ColumnString::Chars & haystack,\n+        size_t N,\n+        const String & needle,\n         PaddedPODArray<UInt8> & res)\n     {\n-        if (data.empty())\n+        if (haystack.empty())\n             return;\n \n         /// A simple case where the LIKE expression reduces to finding a substring in a string\n         String strstr_pattern;\n-        if (like && likePatternIsStrstr(pattern, strstr_pattern))\n+        if (like && impl::likePatternIsSubstring(needle, strstr_pattern))\n         {\n-            const UInt8 * begin = data.data();\n+            const UInt8 * const begin = haystack.data();\n+            const UInt8 * const end = haystack.data() + haystack.size();\n             const UInt8 * pos = begin;\n-            const UInt8 * end = pos + data.size();\n \n             size_t i = 0;\n             const UInt8 * next_pos = begin;\n \n-            /// If pattern is larger than string size - it cannot be found.\n-            if (strstr_pattern.size() <= n)\n+            /// If needle is larger than string size - it cannot be found.\n+            if (strstr_pattern.size() <= N)\n             {\n                 Searcher searcher(strstr_pattern.data(), strstr_pattern.size(), end - pos);\n \n@@ -263,19 +270,19 @@ struct MatchImpl\n                 while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n                 {\n                     /// Let's determine which index it refers to.\n-                    while (next_pos + n <= pos)\n+                    while (next_pos + N <= pos)\n                     {\n-                        res[i] = revert;\n-                        next_pos += n;\n+                        res[i] = negate;\n+                        next_pos += N;\n                         ++i;\n                     }\n-                    next_pos += n;\n+                    next_pos += N;\n \n                     /// We check that the entry does not pass through the boundaries of strings.\n                     if (pos + strstr_pattern.size() <= next_pos)\n-                        res[i] = !revert;\n+                        res[i] = !negate;\n                     else\n-                        res[i] = revert;\n+                        res[i] = negate;\n \n                     pos = next_pos;\n                     ++i;\n@@ -284,13 +291,11 @@ struct MatchImpl\n \n             /// Tail, in which there can be no substring.\n             if (i < res.size())\n-                memset(&res[i], revert, (res.size() - i) * sizeof(res[0]));\n+                memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));\n         }\n         else\n         {\n-            size_t size = data.size() / n;\n-\n-            auto regexp = Regexps::get<like, true, case_insensitive>(pattern);\n+            auto regexp = Regexps::get<like, true, case_insensitive>(needle);\n \n             String required_substring;\n             bool is_trivial;\n@@ -298,44 +303,46 @@ struct MatchImpl\n \n             regexp->getAnalyzeResult(required_substring, is_trivial, required_substring_is_prefix);\n \n+            const size_t haystack_size = haystack.size() / N;\n+\n             if (required_substring.empty())\n             {\n                 if (!regexp->getRE2()) /// An empty regexp. Always matches.\n                 {\n-                    if (size)\n-                        memset(res.data(), 1, size * sizeof(res[0]));\n+                    if (haystack_size)\n+                        memset(res.data(), 1, haystack_size * sizeof(res[0]));\n                 }\n                 else\n                 {\n                     size_t offset = 0;\n-                    for (size_t i = 0; i < size; ++i)\n+                    for (size_t i = 0; i < haystack_size; ++i)\n                     {\n-                        res[i] = revert\n+                        res[i] = negate\n                             ^ regexp->getRE2()->Match(\n-                                  re2_st::StringPiece(reinterpret_cast<const char *>(&data[offset]), n),\n+                                  {reinterpret_cast<const char *>(&haystack[offset]), N},\n                                   0,\n-                                  n,\n+                                  N,\n                                   re2_st::RE2::UNANCHORED,\n                                   nullptr,\n                                   0);\n \n-                        offset += n;\n+                        offset += N;\n                     }\n                 }\n             }\n             else\n             {\n-                /// NOTE This almost matches with the case of LikePatternIsStrstr.\n+                /// NOTE This almost matches with the case of likePatternIsSubstring.\n \n-                const UInt8 * begin = data.data();\n+                const UInt8 * const begin = haystack.data();\n+                const UInt8 * const end = haystack.data() + haystack.size();\n                 const UInt8 * pos = begin;\n-                const UInt8 * end = pos + data.size();\n \n                 size_t i = 0;\n                 const UInt8 * next_pos = begin;\n \n                 /// If required substring is larger than string size - it cannot be found.\n-                if (required_substring.size() <= n)\n+                if (required_substring.size() <= N)\n                 {\n                     Searcher searcher(required_substring.data(), required_substring.size(), end - pos);\n \n@@ -343,46 +350,43 @@ struct MatchImpl\n                     while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n                     {\n                         /// Let's determine which index it refers to.\n-                        while (next_pos + n <= pos)\n+                        while (next_pos + N <= pos)\n                         {\n-                            res[i] = revert;\n-                            next_pos += n;\n+                            res[i] = negate;\n+                            next_pos += N;\n                             ++i;\n                         }\n-                        next_pos += n;\n+                        next_pos += N;\n \n                         if (pos + required_substring.size() <= next_pos)\n                         {\n                             /// And if it does not, if necessary, we check the regexp.\n \n                             if (is_trivial)\n-                                res[i] = !revert;\n+                                res[i] = !negate;\n                             else\n                             {\n-                                const char * str_data = reinterpret_cast<const char *>(next_pos - n);\n+                                const char * str_data = reinterpret_cast<const char *>(next_pos - N);\n \n                                 /** Even in the case of `required_substring_is_prefix` use UNANCHORED check for regexp,\n                                 *  so that it can match when `required_substring` occurs into the string several times,\n                                 *  and at the first occurrence, the regexp is not a match.\n                                 */\n+                                const size_t start_pos = (required_substring_is_prefix) ? (reinterpret_cast<const char *>(pos) - str_data) : 0;\n+                                const size_t end_pos = N;\n \n-                                if (required_substring_is_prefix)\n-                                    res[i] = revert\n-                                        ^ regexp->getRE2()->Match(\n-                                            re2_st::StringPiece(str_data, n),\n-                                            reinterpret_cast<const char *>(pos) - str_data,\n-                                            n,\n-                                            re2_st::RE2::UNANCHORED,\n-                                            nullptr,\n-                                            0);\n-                                else\n-                                    res[i] = revert\n-                                        ^ regexp->getRE2()->Match(\n-                                            re2_st::StringPiece(str_data, n), 0, n, re2_st::RE2::UNANCHORED, nullptr, 0);\n+                                res[i] = negate\n+                                    ^ regexp->getRE2()->Match(\n+                                        {str_data, N},\n+                                        start_pos,\n+                                        end_pos,\n+                                        re2_st::RE2::UNANCHORED,\n+                                        nullptr,\n+                                        0);\n                             }\n                         }\n                         else\n-                            res[i] = revert;\n+                            res[i] = negate;\n \n                         pos = next_pos;\n                         ++i;\n@@ -391,22 +395,248 @@ struct MatchImpl\n \n                 /// Tail, in which there can be no substring.\n                 if (i < res.size())\n-                    memset(&res[i], revert, (res.size() - i) * sizeof(res[0]));\n+                    memset(&res[i], negate, (res.size() - i) * sizeof(res[0]));\n             }\n         }\n     }\n \n-    template <typename... Args>\n-    static void vectorVector(Args &&...)\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const ColumnString::Chars & needle_data,\n+        const ColumnString::Offsets & needle_offset,\n+        const ColumnPtr & start_pos_,\n+        PaddedPODArray<UInt8> & res)\n     {\n-        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support non-constant needle argument\", name);\n+        const size_t haystack_size = haystack_offsets.size();\n+\n+        if (haystack_size != needle_offset.size())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Function '{}' unexpectedly received a different number of haystacks and needles\", name);\n+\n+        if (start_pos_ != nullptr)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Function '{}' doesn't support start_pos argument\", name);\n+\n+        if (haystack_offsets.empty())\n+            return;\n+\n+        String required_substr;\n+        bool is_trivial;\n+        bool required_substring_is_prefix; /// for `anchored` execution of the regexp.\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needle_offset = 0;\n+\n+        for (size_t i = 0; i < haystack_size; ++i)\n+        {\n+            const auto * const cur_haystack_data = &haystack_data[prev_haystack_offset];\n+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            const auto * const cur_needle_data = &needle_data[prev_needle_offset];\n+            const size_t cur_needle_length = needle_offset[i] - prev_needle_offset - 1;\n+\n+            const auto & needle = String(\n+                    reinterpret_cast<const char *>(cur_needle_data),\n+                    cur_needle_length);\n+\n+            if (like && impl::likePatternIsSubstring(needle, required_substr))\n+            {\n+                if (required_substr.size() > cur_haystack_length)\n+                    res[i] = negate;\n+                else\n+                {\n+                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);\n+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);\n+                    res[i] = negate\n+                        ^ (match != cur_haystack_data + cur_haystack_length);\n+                }\n+            }\n+            else\n+            {\n+                // each row is expected to contain a different like/re2 pattern\n+                // --> bypass the regexp cache, instead construct the pattern on-the-fly\n+                const int flags = Regexps::buildRe2Flags<true, case_insensitive>();\n+                const auto & regexp = Regexps::Regexp(Regexps::createRegexp<like>(needle, flags));\n+\n+                regexp.getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);\n+\n+                if (required_substr.empty())\n+                {\n+                    if (!regexp.getRE2()) /// An empty regexp. Always matches.\n+                    {\n+                        res[i] = 1;\n+                    }\n+                    else\n+                    {\n+                        res[i] = negate\n+                            ^ regexp.getRE2()->Match(\n+                                          {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                          0,\n+                                          cur_haystack_length,\n+                                          re2_st::RE2::UNANCHORED,\n+                                          nullptr,\n+                                          0);\n+                    }\n+                }\n+                else\n+                {\n+                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);\n+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);\n+\n+                    if (match == cur_haystack_data + cur_haystack_length)\n+                    {\n+                        res[i] = negate; // no match\n+                    }\n+                    else\n+                    {\n+                        if (is_trivial)\n+                        {\n+                            res[i] = !negate; // no wildcards in pattern\n+                        }\n+                        else\n+                        {\n+                            const size_t start_pos = (required_substring_is_prefix) ? (match - cur_haystack_data) : 0;\n+                            const size_t end_pos = cur_haystack_length;\n+\n+                            res[i] = negate\n+                                ^ regexp.getRE2()->Match(\n+                                              {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                              start_pos,\n+                                              end_pos,\n+                                              re2_st::RE2::UNANCHORED,\n+                                              nullptr,\n+                                              0);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needle_offset = needle_offset[i];\n+        }\n+    }\n+\n+    static void vectorFixedVector(\n+        const ColumnString::Chars & haystack,\n+        size_t N,\n+        const ColumnString::Chars & needle_data,\n+        const ColumnString::Offsets & needle_offset,\n+        const ColumnPtr & start_pos_,\n+        PaddedPODArray<UInt8> & res)\n+    {\n+        const size_t haystack_size = haystack.size()/N;\n+\n+        if (haystack_size != needle_offset.size())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Function '{}' unexpectedly received a different number of haystacks and needles\", name);\n+\n+        if (start_pos_ != nullptr)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Function '{}' doesn't support start_pos argument\", name);\n+\n+        if (haystack.empty())\n+            return;\n+\n+        String required_substr;\n+        bool is_trivial;\n+        bool required_substring_is_prefix; // for `anchored` execution of the regexp.\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needle_offset = 0;\n+\n+        for (size_t i = 0; i < haystack_size; ++i)\n+        {\n+            const auto * const cur_haystack_data = &haystack[prev_haystack_offset];\n+            const size_t cur_haystack_length = N;\n+\n+            const auto * const cur_needle_data = &needle_data[prev_needle_offset];\n+            const size_t cur_needle_length = needle_offset[i] - prev_needle_offset - 1;\n+\n+            const auto & needle = String(\n+                    reinterpret_cast<const char *>(cur_needle_data),\n+                    cur_needle_length);\n+\n+            if (like && impl::likePatternIsSubstring(needle, required_substr))\n+            {\n+                if (required_substr.size() > cur_haystack_length)\n+                    res[i] = negate;\n+                else\n+                {\n+                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);\n+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);\n+                    res[i] = negate\n+                        ^ (match != cur_haystack_data + cur_haystack_length);\n+                }\n+            }\n+            else\n+            {\n+                // each row is expected to contain a different like/re2 pattern\n+                // --> bypass the regexp cache, instead construct the pattern on-the-fly\n+                const int flags = Regexps::buildRe2Flags<true, case_insensitive>();\n+                const auto & regexp = Regexps::Regexp(Regexps::createRegexp<like>(needle, flags));\n+\n+                regexp.getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);\n+\n+                if (required_substr.empty())\n+                {\n+                    if (!regexp.getRE2()) /// An empty regexp. Always matches.\n+                    {\n+                        res[i] = 1;\n+                    }\n+                    else\n+                    {\n+                        res[i] = negate\n+                            ^ regexp.getRE2()->Match(\n+                                            {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                            0,\n+                                            cur_haystack_length,\n+                                            re2_st::RE2::UNANCHORED,\n+                                            nullptr,\n+                                            0);\n+                    }\n+                }\n+                else\n+                {\n+                    Searcher searcher(required_substr.data(), required_substr.size(), cur_haystack_length);\n+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);\n+\n+                    if (match == cur_haystack_data + cur_haystack_length)\n+                    {\n+                        res[i] = negate; // no match\n+                    }\n+                    else\n+                    {\n+                        if (is_trivial)\n+                        {\n+                            res[i] = !negate; // no wildcards in pattern\n+                        }\n+                        else\n+                        {\n+                            const size_t start_pos = (required_substring_is_prefix) ? (match - cur_haystack_data) : 0;\n+                            const size_t end_pos = cur_haystack_length;\n+\n+                            res[i] = negate\n+                                ^ regexp.getRE2()->Match(\n+                                        {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                        start_pos,\n+                                        end_pos,\n+                                        re2_st::RE2::UNANCHORED,\n+                                        nullptr,\n+                                        0);\n+                        }\n+                    }\n+                }\n+            }\n+            prev_haystack_offset += N;\n+            prev_needle_offset = needle_offset[i];\n+        }\n     }\n \n-    /// Search different needles in single haystack.\n     template <typename... Args>\n     static void constantVector(Args &&...)\n     {\n-        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support non-constant needle argument\", name);\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name);\n     }\n };\n \ndiff --git a/src/Functions/MultiMatchAllIndicesImpl.h b/src/Functions/MultiMatchAllIndicesImpl.h\nindex f3e670087073..adf9e9b585f4 100644\n--- a/src/Functions/MultiMatchAllIndicesImpl.h\n+++ b/src/Functions/MultiMatchAllIndicesImpl.h\n@@ -11,8 +11,6 @@\n \n #if USE_HYPERSCAN\n #    include <hs.h>\n-#else\n-#    include \"MatchImpl.h\"\n #endif\n \n \ndiff --git a/src/Functions/MultiMatchAnyImpl.h b/src/Functions/MultiMatchAnyImpl.h\nindex 747c0e5e62c5..595a3c8de5b2 100644\n--- a/src/Functions/MultiMatchAnyImpl.h\n+++ b/src/Functions/MultiMatchAnyImpl.h\n@@ -120,7 +120,7 @@ struct MultiMatchAnyImpl\n         memset(accum.data(), 0, accum.size());\n         for (size_t j = 0; j < needles.size(); ++j)\n         {\n-            MatchImpl<Name, false, false>::vectorConstant(haystack_data, haystack_offsets, needles[j].toString(), nullptr, accum);\n+            MatchImpl<Name, false, false, false>::vectorConstant(haystack_data, haystack_offsets, needles[j].toString(), nullptr, accum);\n             for (size_t i = 0; i < res.size(); ++i)\n             {\n                 if constexpr (FindAny)\ndiff --git a/src/Functions/PositionImpl.h b/src/Functions/PositionImpl.h\nindex d3b6d74c3cde..82e58cdc643c 100644\n--- a/src/Functions/PositionImpl.h\n+++ b/src/Functions/PositionImpl.h\n@@ -182,19 +182,21 @@ struct PositionImpl\n     static constexpr bool supports_start_pos = true;\n     static constexpr auto name = Name::name;\n \n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {};}\n+\n     using ResultType = UInt64;\n \n     /// Find one substring in many strings.\n     static void vectorConstant(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n         const std::string & needle,\n         const ColumnPtr & start_pos,\n         PaddedPODArray<UInt64> & res)\n     {\n-        const UInt8 * begin = data.data();\n+        const UInt8 * const begin = haystack_data.data();\n+        const UInt8 * const end = haystack_data.data() + haystack_data.size();\n         const UInt8 * pos = begin;\n-        const UInt8 * end = pos + data.size();\n \n         /// Current index in the array of strings.\n         size_t i = 0;\n@@ -205,7 +207,7 @@ struct PositionImpl\n         while (pos < end && end != (pos = searcher.search(pos, end - pos)))\n         {\n             /// Determine which index it refers to.\n-            while (begin + offsets[i] <= pos)\n+            while (begin + haystack_offsets[i] <= pos)\n             {\n                 res[i] = 0;\n                 ++i;\n@@ -213,14 +215,14 @@ struct PositionImpl\n             auto start = start_pos != nullptr ? start_pos->getUInt(i) : 0;\n \n             /// We check that the entry does not pass through the boundaries of strings.\n-            if (pos + needle.size() < begin + offsets[i])\n+            if (pos + needle.size() < begin + haystack_offsets[i])\n             {\n-                auto res_pos = 1 + Impl::countChars(reinterpret_cast<const char *>(begin + offsets[i - 1]), reinterpret_cast<const char *>(pos));\n+                auto res_pos = 1 + Impl::countChars(reinterpret_cast<const char *>(begin + haystack_offsets[i - 1]), reinterpret_cast<const char *>(pos));\n                 if (res_pos < start)\n                 {\n                     pos = reinterpret_cast<const UInt8 *>(Impl::advancePos(\n                         reinterpret_cast<const char *>(pos),\n-                        reinterpret_cast<const char *>(begin + offsets[i]),\n+                        reinterpret_cast<const char *>(begin + haystack_offsets[i]),\n                         start - res_pos));\n                     continue;\n                 }\n@@ -230,7 +232,7 @@ struct PositionImpl\n             {\n                 res[i] = 0;\n             }\n-            pos = begin + offsets[i];\n+            pos = begin + haystack_offsets[i];\n             ++i;\n         }\n \n@@ -411,6 +413,12 @@ struct PositionImpl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n     }\n+\n+    template <typename... Args>\n+    static void vectorFixedVector(Args &&...)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support FixedString haystack argument\", name);\n+    }\n };\n \n }\ndiff --git a/src/Functions/Regexps.h b/src/Functions/Regexps.h\nindex 9a1938a3f321..dc94b75211ca 100644\n--- a/src/Functions/Regexps.h\n+++ b/src/Functions/Regexps.h\n@@ -38,7 +38,7 @@ namespace ErrorCodes\n \n namespace Regexps\n {\n-    using Regexp = OptimizedRegularExpressionImpl<false>;\n+    using Regexp = OptimizedRegularExpressionSingleThreaded;\n     using Pool = ObjectPoolMap<Regexp, String>;\n \n     template <bool like>\n@@ -50,6 +50,17 @@ namespace Regexps\n             return {pattern, flags};\n     }\n \n+    template<bool no_capture, bool case_insensitive>\n+    inline int buildRe2Flags()\n+    {\n+        int flags = OptimizedRegularExpression::RE_DOT_NL;\n+        if constexpr (no_capture)\n+            flags |= OptimizedRegularExpression::RE_NO_CAPTURE;\n+        if constexpr (case_insensitive)\n+            flags |= OptimizedRegularExpression::RE_CASELESS;\n+        return flags;\n+    }\n+\n     /** Returns holder of an object from Pool.\n       * You must hold the ownership while using the object.\n       * In destructor, it returns the object back to the Pool for further reuse.\n@@ -62,14 +73,7 @@ namespace Regexps\n \n         return known_regexps.get(pattern, [&pattern]\n         {\n-            int flags = OptimizedRegularExpression::RE_DOT_NL;\n-\n-            if (no_capture)\n-                flags |= OptimizedRegularExpression::RE_NO_CAPTURE;\n-\n-            if (case_insensitive)\n-                flags |= Regexps::Regexp::RE_CASELESS;\n-\n+            const int flags = buildRe2Flags<no_capture, case_insensitive>();\n             ProfileEvents::increment(ProfileEvents::RegexpCreated);\n             return new Regexp{createRegexp<like>(pattern, flags)};\n         });\ndiff --git a/src/Functions/ilike.cpp b/src/Functions/ilike.cpp\nindex 116c945e04f0..1222cc48d075 100644\n--- a/src/Functions/ilike.cpp\n+++ b/src/Functions/ilike.cpp\n@@ -12,7 +12,7 @@ struct NameILike\n     static constexpr auto name = \"ilike\";\n };\n \n-using ILikeImpl = MatchImpl<NameILike, true, false, /*case-insensitive*/true>;\n+using ILikeImpl = MatchImpl<NameILike, true, false, true>;\n using FunctionILike = FunctionsStringSearch<ILikeImpl>;\n \n }\ndiff --git a/src/Functions/like.h b/src/Functions/like.h\nindex a00891ec64cf..edb738d393bf 100644\n--- a/src/Functions/like.h\n+++ b/src/Functions/like.h\n@@ -11,7 +11,7 @@ struct NameLike\n     static constexpr auto name = \"like\";\n };\n \n-using LikeImpl = MatchImpl<NameLike, /*SQL LIKE */ true, /*revert*/false>;\n+using LikeImpl = MatchImpl<NameLike, true, false, false>;\n using FunctionLike = FunctionsStringSearch<LikeImpl>;\n \n }\ndiff --git a/src/Functions/match.cpp b/src/Functions/match.cpp\nindex 69dc1a3d99ae..4c3297014647 100644\n--- a/src/Functions/match.cpp\n+++ b/src/Functions/match.cpp\n@@ -13,7 +13,7 @@ struct NameMatch\n     static constexpr auto name = \"match\";\n };\n \n-using FunctionMatch = FunctionsStringSearch<MatchImpl<NameMatch, false>>;\n+using FunctionMatch = FunctionsStringSearch<MatchImpl<NameMatch, false, false, false>>;\n \n }\n \ndiff --git a/src/Functions/notILike.cpp b/src/Functions/notILike.cpp\nindex be40e2b989ee..b5e06ac55f4c 100644\n--- a/src/Functions/notILike.cpp\n+++ b/src/Functions/notILike.cpp\n@@ -12,7 +12,7 @@ struct NameNotILike\n     static constexpr auto name = \"notILike\";\n };\n \n-using NotILikeImpl = MatchImpl<NameNotILike, true, true, /*case-insensitive*/true>;\n+using NotILikeImpl = MatchImpl<NameNotILike, true, true, true>;\n using FunctionNotILike = FunctionsStringSearch<NotILikeImpl>;\n \n }\ndiff --git a/src/Functions/notLike.cpp b/src/Functions/notLike.cpp\nindex 7c4ea8ab2dcf..7fa1b6f9122a 100644\n--- a/src/Functions/notLike.cpp\n+++ b/src/Functions/notLike.cpp\n@@ -12,7 +12,7 @@ struct NameNotLike\n     static constexpr auto name = \"notLike\";\n };\n \n-using FunctionNotLike = FunctionsStringSearch<MatchImpl<NameNotLike, true, true>>;\n+using FunctionNotLike = FunctionsStringSearch<MatchImpl<NameNotLike, true, true, false>>;\n \n }\n \n",
  "test_patch": "diff --git a/docs/en/development/adding_test_queries.md b/docs/en/development/adding_test_queries.md\nindex 9b993a96ed52..ca47818dad75 100644\n--- a/docs/en/development/adding_test_queries.md\n+++ b/docs/en/development/adding_test_queries.md\n@@ -106,7 +106,7 @@ vim tests/queries/0_stateless/01521_dummy_test.sql\n \n 4) run the test, and put the result of that into the reference file:\n ```\n-clickhouse-client -nmT < tests/queries/0_stateless/01521_dummy_test.sql | tee tests/queries/0_stateless/01521_dummy_test.reference\n+clickhouse-client -nm < tests/queries/0_stateless/01521_dummy_test.sql | tee tests/queries/0_stateless/01521_dummy_test.reference\n ```\n \n 5) ensure everything is correct, if the test output is incorrect (due to some bug for example), adjust the reference file using text editor.\ndiff --git a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference\nnew file mode 100644\nindex 000000000000..7471bcad00cb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference\n@@ -0,0 +1,190 @@\n+LIKE\n+1\tHello\t\t0\n+2\tHello\t%\t1\n+3\tHello\t%%\t1\n+4\tHello\t%%%\t1\n+5\tHello\t%_%\t1\n+6\tHello\t_\t0\n+7\tHello\t_%\t1\n+8\tHello\t%_\t1\n+9\tHello\tH%o\t1\n+10\thello\tH%0\t0\n+11\thello\th%o\t1\n+12\tHello\th%o\t0\n+13\tOHello\t%lhell%\t0\n+14\tOHello\t%hell%\t0\n+15\thEllo\t%HEL%\t0\n+16\tabcdef\t%aBc%def%\t0\n+17\tABCDDEF\t%abc%def%\t0\n+18\tAbc\\nDef\t%abc%def%\t0\n+19\tabc\\ntdef\t%abc%def%\t1\n+20\tabct\\ndef\t%abc%dEf%\t0\n+21\tabc\\n\\ndeF\t%abc%def%\t0\n+22\tabc\\n\\ntdef\t%abc%deF%\t0\n+23\tAbc\\nt\\ndef\t%abc%def%\t0\n+24\tabct\\n\\ndef\t%abc%def%\t1\n+25\tab\\ndef\t%Abc%def%\t0\n+26\taBc\\nef\t%ABC%DEF%\t0\n+27\t\u0451\u0401\u0451\t\u0401%\u0401\t0\n+28\t\u043e\u0449\u0449\u0401\u0451\t\u0429%\u0401\t0\n+29\t\u043e\u0449\u0429\u0401\u0451\t%\u0429%\u0401\t0\n+30\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u043f%\u0435%\t1\n+31\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u041f%\u0435%\t0\n+32\t\u043e\u0449\u0449\u0401\u0451\t%\u0449%\t1\n+33\t\u043e\u0449\u0429\u0401\u0451\t%\u0451%\t1\n+34\tHello\t.*\t0\n+35\tHello\t.*ell.*\t0\n+36\tHello\to$\t0\n+37\tHello\thE.*lO\t0\n+NOT LIKE\n+1\tHello\t\t1\n+2\tHello\t%\t0\n+3\tHello\t%%\t0\n+4\tHello\t%%%\t0\n+5\tHello\t%_%\t0\n+6\tHello\t_\t1\n+7\tHello\t_%\t0\n+8\tHello\t%_\t0\n+9\tHello\tH%o\t0\n+10\thello\tH%0\t1\n+11\thello\th%o\t0\n+12\tHello\th%o\t1\n+13\tOHello\t%lhell%\t1\n+14\tOHello\t%hell%\t1\n+15\thEllo\t%HEL%\t1\n+16\tabcdef\t%aBc%def%\t1\n+17\tABCDDEF\t%abc%def%\t1\n+18\tAbc\\nDef\t%abc%def%\t1\n+19\tabc\\ntdef\t%abc%def%\t0\n+20\tabct\\ndef\t%abc%dEf%\t1\n+21\tabc\\n\\ndeF\t%abc%def%\t1\n+22\tabc\\n\\ntdef\t%abc%deF%\t1\n+23\tAbc\\nt\\ndef\t%abc%def%\t1\n+24\tabct\\n\\ndef\t%abc%def%\t0\n+25\tab\\ndef\t%Abc%def%\t1\n+26\taBc\\nef\t%ABC%DEF%\t1\n+27\t\u0451\u0401\u0451\t\u0401%\u0401\t1\n+28\t\u043e\u0449\u0449\u0401\u0451\t\u0429%\u0401\t1\n+29\t\u043e\u0449\u0429\u0401\u0451\t%\u0429%\u0401\t1\n+30\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u043f%\u0435%\t0\n+31\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u041f%\u0435%\t1\n+32\t\u043e\u0449\u0449\u0401\u0451\t%\u0449%\t0\n+33\t\u043e\u0449\u0429\u0401\u0451\t%\u0451%\t0\n+34\tHello\t.*\t1\n+35\tHello\t.*ell.*\t1\n+36\tHello\to$\t1\n+37\tHello\thE.*lO\t1\n+ILIKE\n+1\tHello\t\t0\n+2\tHello\t%\t1\n+3\tHello\t%%\t1\n+4\tHello\t%%%\t1\n+5\tHello\t%_%\t1\n+6\tHello\t_\t0\n+7\tHello\t_%\t1\n+8\tHello\t%_\t1\n+9\tHello\tH%o\t1\n+10\thello\tH%0\t0\n+11\thello\th%o\t1\n+12\tHello\th%o\t1\n+13\tOHello\t%lhell%\t0\n+14\tOHello\t%hell%\t1\n+15\thEllo\t%HEL%\t1\n+16\tabcdef\t%aBc%def%\t1\n+17\tABCDDEF\t%abc%def%\t1\n+18\tAbc\\nDef\t%abc%def%\t1\n+19\tabc\\ntdef\t%abc%def%\t1\n+20\tabct\\ndef\t%abc%dEf%\t1\n+21\tabc\\n\\ndeF\t%abc%def%\t1\n+22\tabc\\n\\ntdef\t%abc%deF%\t1\n+23\tAbc\\nt\\ndef\t%abc%def%\t1\n+24\tabct\\n\\ndef\t%abc%def%\t1\n+25\tab\\ndef\t%Abc%def%\t0\n+26\taBc\\nef\t%ABC%DEF%\t0\n+27\t\u0451\u0401\u0451\t\u0401%\u0401\t1\n+28\t\u043e\u0449\u0449\u0401\u0451\t\u0429%\u0401\t0\n+29\t\u043e\u0449\u0429\u0401\u0451\t%\u0429%\u0401\t1\n+30\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u043f%\u0435%\t1\n+31\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u041f%\u0435%\t1\n+32\t\u043e\u0449\u0449\u0401\u0451\t%\u0449%\t1\n+33\t\u043e\u0449\u0429\u0401\u0451\t%\u0451%\t1\n+34\tHello\t.*\t0\n+35\tHello\t.*ell.*\t0\n+36\tHello\to$\t0\n+37\tHello\thE.*lO\t0\n+NOT ILIKE\n+1\tHello\t\t1\n+2\tHello\t%\t0\n+3\tHello\t%%\t0\n+4\tHello\t%%%\t0\n+5\tHello\t%_%\t0\n+6\tHello\t_\t1\n+7\tHello\t_%\t0\n+8\tHello\t%_\t0\n+9\tHello\tH%o\t0\n+10\thello\tH%0\t1\n+11\thello\th%o\t0\n+12\tHello\th%o\t0\n+13\tOHello\t%lhell%\t1\n+14\tOHello\t%hell%\t0\n+15\thEllo\t%HEL%\t0\n+16\tabcdef\t%aBc%def%\t0\n+17\tABCDDEF\t%abc%def%\t0\n+18\tAbc\\nDef\t%abc%def%\t0\n+19\tabc\\ntdef\t%abc%def%\t0\n+20\tabct\\ndef\t%abc%dEf%\t0\n+21\tabc\\n\\ndeF\t%abc%def%\t0\n+22\tabc\\n\\ntdef\t%abc%deF%\t0\n+23\tAbc\\nt\\ndef\t%abc%def%\t0\n+24\tabct\\n\\ndef\t%abc%def%\t0\n+25\tab\\ndef\t%Abc%def%\t1\n+26\taBc\\nef\t%ABC%DEF%\t1\n+27\t\u0451\u0401\u0451\t\u0401%\u0401\t0\n+28\t\u043e\u0449\u0449\u0401\u0451\t\u0429%\u0401\t1\n+29\t\u043e\u0449\u0429\u0401\u0451\t%\u0429%\u0401\t0\n+30\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u043f%\u0435%\t0\n+31\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u041f%\u0435%\t0\n+32\t\u043e\u0449\u0449\u0401\u0451\t%\u0449%\t0\n+33\t\u043e\u0449\u0429\u0401\u0451\t%\u0451%\t0\n+34\tHello\t.*\t1\n+35\tHello\t.*ell.*\t1\n+36\tHello\to$\t1\n+37\tHello\thE.*lO\t1\n+MATCH\n+1\tHello\t\t1\n+2\tHello\t%\t0\n+3\tHello\t%%\t0\n+4\tHello\t%%%\t0\n+5\tHello\t%_%\t0\n+6\tHello\t_\t0\n+7\tHello\t_%\t0\n+8\tHello\t%_\t0\n+9\tHello\tH%o\t0\n+10\thello\tH%0\t0\n+11\thello\th%o\t0\n+12\tHello\th%o\t0\n+13\tOHello\t%lhell%\t0\n+14\tOHello\t%hell%\t0\n+15\thEllo\t%HEL%\t0\n+16\tabcdef\t%aBc%def%\t0\n+17\tABCDDEF\t%abc%def%\t0\n+18\tAbc\\nDef\t%abc%def%\t0\n+19\tabc\\ntdef\t%abc%def%\t0\n+20\tabct\\ndef\t%abc%dEf%\t0\n+21\tabc\\n\\ndeF\t%abc%def%\t0\n+22\tabc\\n\\ntdef\t%abc%deF%\t0\n+23\tAbc\\nt\\ndef\t%abc%def%\t0\n+24\tabct\\n\\ndef\t%abc%def%\t0\n+25\tab\\ndef\t%Abc%def%\t0\n+26\taBc\\nef\t%ABC%DEF%\t0\n+27\t\u0451\u0401\u0451\t\u0401%\u0401\t0\n+28\t\u043e\u0449\u0449\u0401\u0451\t\u0429%\u0401\t0\n+29\t\u043e\u0449\u0429\u0401\u0451\t%\u0429%\u0401\t0\n+30\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u043f%\u0435%\t0\n+31\t\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440\t%\u0449\u041f%\u0435%\t0\n+32\t\u043e\u0449\u0449\u0401\u0451\t%\u0449%\t0\n+33\t\u043e\u0449\u0429\u0401\u0451\t%\u0451%\t0\n+34\tHello\t.*\t1\n+35\tHello\t.*ell.*\t1\n+36\tHello\to$\t1\n+37\tHello\thE.*lO\t0\ndiff --git a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql\nnew file mode 100644\nindex 000000000000..3057e3427332\n--- /dev/null\n+++ b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql\n@@ -0,0 +1,36 @@\n+drop table if exists non_const_needle;\n+\n+create table non_const_needle\n+  (id UInt32, haystack String, needle String)\n+  engine = MergeTree()\n+  order by id;\n+\n+-- 1 - 33: LIKE-syntax, 34-37: re2-syntax\n+insert into non_const_needle values (1, 'Hello', '') (2, 'Hello', '%') (3, 'Hello', '%%') (4, 'Hello', '%%%') (5, 'Hello', '%_%') (6, 'Hello', '_') (7, 'Hello', '_%') (8, 'Hello', '%_') (9, 'Hello', 'H%o') (10, 'hello', 'H%0') (11, 'hello', 'h%o') (12, 'Hello', 'h%o') (13, 'OHello', '%lhell%') (14, 'OHello', '%hell%') (15, 'hEllo', '%HEL%') (16, 'abcdef', '%aBc%def%') (17, 'ABCDDEF', '%abc%def%') (18, 'Abc\\nDef', '%abc%def%') (19, 'abc\\ntdef', '%abc%def%') (20, 'abct\\ndef', '%abc%dEf%') (21, 'abc\\n\\ndeF', '%abc%def%') (22, 'abc\\n\\ntdef', '%abc%deF%') (23, 'Abc\\nt\\ndef', '%abc%def%') (24, 'abct\\n\\ndef', '%abc%def%') (25, 'ab\\ndef', '%Abc%def%') (26, 'aBc\\nef', '%ABC%DEF%') (27, '\u0451\u0401\u0451', '\u0401%\u0401') (28, '\u043e\u0449\u0449\u0401\u0451', '\u0429%\u0401') (29, '\u043e\u0449\u0429\u0401\u0451', '%\u0429%\u0401') (30, '\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440', '%\u0449\u043f%\u0435%') (31, '\u0429\u0443\u0449\u043f\u0430\u043d\u0434\u0435\u0440', '%\u0449\u041f%\u0435%') (32, '\u043e\u0449\u0449\u0401\u0451', '%\u0449%') (33, '\u043e\u0449\u0429\u0401\u0451', '%\u0451%') (34, 'Hello', '.*') (35, 'Hello', '.*ell.*') (36, 'Hello', 'o$') (37, 'Hello', 'hE.*lO');\n+\n+select 'LIKE';\n+select id, haystack, needle, like(haystack, needle)\n+  from non_const_needle\n+  order by id;\n+\n+select 'NOT LIKE';\n+select id, haystack, needle, not like(haystack, needle)\n+  from non_const_needle\n+  order by id;\n+\n+select 'ILIKE';\n+select id, haystack, needle, ilike(haystack, needle)\n+  from non_const_needle\n+  order by id;\n+\n+select 'NOT ILIKE';\n+select id, haystack, needle, not ilike(haystack, needle)\n+  from non_const_needle\n+  order by id;\n+\n+select 'MATCH';\n+select id, haystack, needle, match(haystack, needle)\n+  from non_const_needle\n+  order by id;\n+\n+drop table if exists non_const_needle;\n",
  "problem_statement": "Support for non-constant regular expressions and LIKE conditions.\n**Use case**\r\n```\r\nSELECT count()\r\nFROM test.hits\r\nWHERE URL LIKE concat('%', Referer, '%')\r\n\r\n0 rows in set. Elapsed: 0.042 sec. \r\n\r\nReceived exception from server (version 21.7.1):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Argument at index 1 for function like must be constant: while executing 'FUNCTION like(URL : 0, concat('%', Referer, '%') : 3) -> like(URL, concat('%', Referer, '%')) UInt8 : 4'.\r\n```\r\n\r\n**Describe the solution you'd like**\r\nConstruct them dynamically.\r\n\r\n**Additional context**\r\nThe cache for regular expressions is unlimited in memory.\r\nNow we have to make it limited somehow.\r\n\r\nThe most simple solution is to simply drop the cache when its size is at some threshold (e.g. 10 000 items).\r\n(or just reuse LRUCache)\n",
  "hints_text": "Will look into this as a warmup task.",
  "created_at": "2022-05-16T13:42:50Z"
}