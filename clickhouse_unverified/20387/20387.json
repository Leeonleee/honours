{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 20387,
  "instance_id": "ClickHouse__ClickHouse-20387",
  "issue_numbers": [
    "20304"
  ],
  "base_commit": "afa24938bc73bc5ba8ba38d4ae3b726543ed4c8b",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeBlockOutputStream.cpp b/src/Storages/MergeTree/MergeTreeBlockOutputStream.cpp\nindex 904081cc1df3..bb5644567aed 100644\n--- a/src/Storages/MergeTree/MergeTreeBlockOutputStream.cpp\n+++ b/src/Storages/MergeTree/MergeTreeBlockOutputStream.cpp\n@@ -29,6 +29,12 @@ void MergeTreeBlockOutputStream::write(const Block & block)\n         Stopwatch watch;\n \n         MergeTreeData::MutableDataPartPtr part = storage.writer.writeTempPart(current_block, metadata_snapshot, optimize_on_insert);\n+\n+        /// If optimize_on_insert setting is true, current_block could become empty after merge\n+        /// and we didn't create part.\n+        if (!part)\n+            continue;\n+\n         storage.renameTempPartAndAdd(part, &storage.increment);\n \n         PartLog::addNewPart(storage.global_context, part, watch.elapsed());\ndiff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex f478cdba40a3..019cad2e1953 100644\n--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -327,6 +327,11 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataWriter::writeTempPart(BlockWithPa\n     /// Size of part would not be greater than block.bytes() + epsilon\n     size_t expected_size = block.bytes();\n \n+    /// If optimize_on_insert is true, block may become empty after merge.\n+    /// There is no need to create empty part.\n+    if (expected_size == 0)\n+        return nullptr;\n+\n     DB::IMergeTreeDataPart::TTLInfos move_ttl_infos;\n     const auto & move_ttl_entries = metadata_snapshot->getMoveTTLs();\n     for (const auto & ttl_entry : move_ttl_entries)\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeBlockOutputStream.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeBlockOutputStream.cpp\nindex 7046a510f75c..6f90d9f00a91 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeBlockOutputStream.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeBlockOutputStream.cpp\n@@ -144,6 +144,11 @@ void ReplicatedMergeTreeBlockOutputStream::write(const Block & block)\n \n         MergeTreeData::MutableDataPartPtr part = storage.writer.writeTempPart(current_block, metadata_snapshot, optimize_on_insert);\n \n+        /// If optimize_on_insert setting is true, current_block could become empty after merge\n+        /// and we didn't create part.\n+        if (!part)\n+            continue;\n+\n         String block_id;\n \n         if (deduplicate)\n",
  "test_patch": "diff --git a/tests/integration/test_optimize_on_insert/__init__.py b/tests/integration/test_optimize_on_insert/__init__.py\nnew file mode 100644\nindex 000000000000..e5a0d9b4834e\n--- /dev/null\n+++ b/tests/integration/test_optimize_on_insert/__init__.py\n@@ -0,0 +1,1 @@\n+#!/usr/bin/env python3\ndiff --git a/tests/integration/test_optimize_on_insert/test.py b/tests/integration/test_optimize_on_insert/test.py\nnew file mode 100644\nindex 000000000000..da4e20edf0c6\n--- /dev/null\n+++ b/tests/integration/test_optimize_on_insert/test.py\n@@ -0,0 +1,48 @@\n+#!/usr/bin/env python3\n+\n+import pytest\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+node1 = cluster.add_instance('node1', with_zookeeper=True)\n+node2 = cluster.add_instance('node2', with_zookeeper=True)\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def get_data_files_for_table(node, table_name):\n+    raw_output = node.exec_in_container([\"bash\", \"-c\", \"ls /var/lib/clickhouse/data/default/{}\".format(table_name)])\n+    return raw_output.strip().split(\"\\n\")\n+\n+def test_empty_parts_optimize(start_cluster):\n+    for n, node in enumerate([node1, node2]):\n+        node.query(\"\"\"\n+            CREATE TABLE empty (key UInt32, val UInt32, date Datetime)\n+            ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '{}', val)\n+            PARTITION BY date ORDER BY key;\n+        \"\"\".format(n+1))\n+\n+    node1.query(\"INSERT INTO empty VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01')\")\n+\n+    node2.query(\"SYSTEM SYNC REPLICA empty\", timeout=15)\n+\n+    assert node1.query(\"SELECT * FROM empty\") == \"\"\n+    assert node2.query(\"SELECT * FROM empty\") == \"\"\n+\n+    # No other tmp files exists\n+    assert set(get_data_files_for_table(node1, \"empty\")) == {\"detached\", \"format_version.txt\"}\n+    assert set(get_data_files_for_table(node2, \"empty\")) == {\"detached\", \"format_version.txt\"}\n+\n+    node1.query(\"INSERT INTO empty VALUES (1, 1, '2020-02-01'), (1, 1, '2020-02-01'), (1, -2, '2020-02-01')\", settings={\"insert_quorum\": 2})\n+\n+    assert node1.query(\"SELECT * FROM empty\") == \"\"\n+    assert node2.query(\"SELECT * FROM empty\") == \"\"\ndiff --git a/tests/queries/0_stateless/01560_optimize_on_insert.reference b/tests/queries/0_stateless/01560_optimize_on_insert.reference\nindex 7ace2043be05..477f48be7a96 100644\n--- a/tests/queries/0_stateless/01560_optimize_on_insert.reference\n+++ b/tests/queries/0_stateless/01560_optimize_on_insert.reference\n@@ -11,3 +11,4 @@ Summing Merge Tree\n Aggregating Merge Tree\n 1\t5\t2020-01-01 00:00:00\n 2\t5\t2020-01-02 00:00:00\n+Check creating empty parts\ndiff --git a/tests/queries/0_stateless/01560_optimize_on_insert.sql b/tests/queries/0_stateless/01560_optimize_on_insert.sql\nindex 9f6dac686bb2..f64f4c75cfe5 100644\n--- a/tests/queries/0_stateless/01560_optimize_on_insert.sql\n+++ b/tests/queries/0_stateless/01560_optimize_on_insert.sql\n@@ -33,3 +33,10 @@ INSERT INTO aggregating_merge_tree VALUES (1, 1, '2020-01-01'), (2, 1, '2020-01-\n SELECT * FROM aggregating_merge_tree ORDER BY key;\n DROP TABLE aggregating_merge_tree;\n \n+SELECT 'Check creating empty parts';\n+DROP TABLE IF EXISTS empty;\n+CREATE TABLE empty (key UInt32, val UInt32, date Datetime) ENGINE=SummingMergeTree(val) PARTITION BY date ORDER BY key;\n+INSERT INTO empty VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01');\n+SELECT * FROM empty ORDER BY key;\n+SELECT table, partition, active FROM system.parts where table = 'empty' and active = 1;\n+DROP TABLE empty;\ndiff --git a/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference\nnew file mode 100644\nindex 000000000000..e89c6201fb76\n--- /dev/null\n+++ b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference\n@@ -0,0 +1,1 @@\n+Check creating empty parts\ndiff --git a/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql\nnew file mode 100644\nindex 000000000000..a98818b21957\n--- /dev/null\n+++ b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql\n@@ -0,0 +1,36 @@\n+DROP TABLE IF EXISTS empty1;\n+DROP TABLE IF EXISTS empty2;\n+\n+SELECT 'Check creating empty parts';\n+\n+CREATE TABLE empty1 (key UInt32, val UInt32, date Datetime)\n+ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '1', val)\n+PARTITION BY date ORDER BY key;\n+\n+CREATE TABLE empty2 (key UInt32, val UInt32, date Datetime)\n+ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '2', val)\n+PARTITION BY date ORDER BY key;\n+\n+INSERT INTO empty2 VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01');\n+\n+SYSTEM SYNC REPLICA empty1;\n+\n+SELECT * FROM empty1 ORDER BY key;\n+SELECT * FROM empty2 ORDER BY key;\n+\n+SELECT table, partition, active FROM system.parts where table = 'empty1' and database=currentDatabase() and active = 1;\n+SELECT table, partition, active FROM system.parts where table = 'empty2' and database=currentDatabase() and active = 1;\n+\n+DETACH table empty1;\n+DETACH table empty2;\n+ATTACH table empty1;\n+ATTACH table empty2;\n+\n+SELECT * FROM empty1 ORDER BY key;\n+SELECT * FROM empty2 ORDER BY key;\n+\n+SELECT table, partition, active FROM system.parts where table = 'empty1' and database=currentDatabase() and active = 1;\n+SELECT table, partition, active FROM system.parts where table = 'empty2' and database=currentDatabase() and active = 1;\n+\n+DROP TABLE IF EXISTS empty1;\n+DROP TABLE IF EXISTS empty2;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 974ef48ef3c0..90564d354e54 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -111,6 +111,7 @@\n         \"memory_tracking\",\n         \"memory_usage\",\n         \"live_view\",\n+        \"01560_optimize_on_insert_zookeeper\",\n         \"01720_type_map_and_casts\",\n         \"01413_alter_update_supertype\",\n         \"01149_zookeeper_mutation_stuck_after_replace_partition\",\n@@ -736,6 +737,7 @@\n         \"01530_drop_database_atomic_sync\",\n         \"01541_max_memory_usage_for_user_long\",\n         \"01542_dictionary_load_exception_race\",\n+        \"01560_optimize_on_insert_zookeeper\",\n         \"01575_disable_detach_table_of_dictionary\",\n         \"01593_concurrent_alter_mutations_kill\",\n         \"01593_concurrent_alter_mutations_kill_many_replicas\",\n",
  "problem_statement": "optimize_on_insert creates empty parts\nIt would be great if `optimize_on_insert` was smart enough to discard empty blocks\r\n```\r\ncreate table empty (num Int8) engine=Memory;\r\nCREATE MATERIALIZED VIEW empty_mv\r\n(\r\n    `num` Int8\r\n)\r\nENGINE = SummingMergeTree\r\nORDER BY tuple() AS\r\nSELECT num\r\nFROM empty;\r\n\r\n-- First insert\r\n\r\nset optimize_on_insert=1;\r\ninsert into empty values (0);\r\n\r\n-- 20 minutes break\r\n\r\nset optimize_on_insert=0;\r\ninsert into empty values (0);\r\n\r\n-- Created parts\r\n\r\nSELECT\r\n    event_type,\r\n    event_time,\r\n    table,\r\n    part_name,\r\n    rows\r\nFROM system.part_log\r\nPREWHERE (event_date = today()) AND (table LIKE '%empty%')\r\nORDER BY event_time ASC\r\nFORMAT PrettyCompactMonoBlock\r\n\r\n\u250c\u2500event_type\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500event_time\u2500\u252c\u2500table\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500part_name\u2500\u252c\u2500rows\u2500\u2510\r\n\u2502 NewPart    \u2502 2021-02-10 21:27:40 \u2502 .inner.empty_mv \u2502 all_1_1_0 \u2502    0 \u2502\r\n\u2502 RemovePart \u2502 2021-02-10 21:27:42 \u2502 .inner.empty_mv \u2502 all_1_1_0 \u2502    0 \u2502\r\n\u2502 NewPart    \u2502 2021-02-10 21:46:42 \u2502 .inner.empty_mv \u2502 all_2_2_0 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "Yes, it's possible to skip INSERT completely if the block is empty.",
  "created_at": "2021-02-12T14:06:55Z"
}