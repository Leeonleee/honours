diff --git a/tests/integration/test_optimize_on_insert/__init__.py b/tests/integration/test_optimize_on_insert/__init__.py
new file mode 100644
index 000000000000..e5a0d9b4834e
--- /dev/null
+++ b/tests/integration/test_optimize_on_insert/__init__.py
@@ -0,0 +1,1 @@
+#!/usr/bin/env python3
diff --git a/tests/integration/test_optimize_on_insert/test.py b/tests/integration/test_optimize_on_insert/test.py
new file mode 100644
index 000000000000..da4e20edf0c6
--- /dev/null
+++ b/tests/integration/test_optimize_on_insert/test.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python3
+
+import pytest
+from helpers.client import QueryRuntimeException
+from helpers.cluster import ClickHouseCluster
+
+cluster = ClickHouseCluster(__file__)
+node1 = cluster.add_instance('node1', with_zookeeper=True)
+node2 = cluster.add_instance('node2', with_zookeeper=True)
+
+@pytest.fixture(scope="module")
+def start_cluster():
+    try:
+        cluster.start()
+
+        yield cluster
+
+    finally:
+        cluster.shutdown()
+
+
+def get_data_files_for_table(node, table_name):
+    raw_output = node.exec_in_container(["bash", "-c", "ls /var/lib/clickhouse/data/default/{}".format(table_name)])
+    return raw_output.strip().split("
")
+
+def test_empty_parts_optimize(start_cluster):
+    for n, node in enumerate([node1, node2]):
+        node.query("""
+            CREATE TABLE empty (key UInt32, val UInt32, date Datetime)
+            ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '{}', val)
+            PARTITION BY date ORDER BY key;
+        """.format(n+1))
+
+    node1.query("INSERT INTO empty VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01')")
+
+    node2.query("SYSTEM SYNC REPLICA empty", timeout=15)
+
+    assert node1.query("SELECT * FROM empty") == ""
+    assert node2.query("SELECT * FROM empty") == ""
+
+    # No other tmp files exists
+    assert set(get_data_files_for_table(node1, "empty")) == {"detached", "format_version.txt"}
+    assert set(get_data_files_for_table(node2, "empty")) == {"detached", "format_version.txt"}
+
+    node1.query("INSERT INTO empty VALUES (1, 1, '2020-02-01'), (1, 1, '2020-02-01'), (1, -2, '2020-02-01')", settings={"insert_quorum": 2})
+
+    assert node1.query("SELECT * FROM empty") == ""
+    assert node2.query("SELECT * FROM empty") == ""
diff --git a/tests/queries/0_stateless/01560_optimize_on_insert.reference b/tests/queries/0_stateless/01560_optimize_on_insert.reference
index 7ace2043be05..477f48be7a96 100644
--- a/tests/queries/0_stateless/01560_optimize_on_insert.reference
+++ b/tests/queries/0_stateless/01560_optimize_on_insert.reference
@@ -11,3 +11,4 @@ Summing Merge Tree
 Aggregating Merge Tree
 1	5	2020-01-01 00:00:00
 2	5	2020-01-02 00:00:00
+Check creating empty parts
diff --git a/tests/queries/0_stateless/01560_optimize_on_insert.sql b/tests/queries/0_stateless/01560_optimize_on_insert.sql
index 9f6dac686bb2..f64f4c75cfe5 100644
--- a/tests/queries/0_stateless/01560_optimize_on_insert.sql
+++ b/tests/queries/0_stateless/01560_optimize_on_insert.sql
@@ -33,3 +33,10 @@ INSERT INTO aggregating_merge_tree VALUES (1, 1, '2020-01-01'), (2, 1, '2020-01-
 SELECT * FROM aggregating_merge_tree ORDER BY key;
 DROP TABLE aggregating_merge_tree;
 
+SELECT 'Check creating empty parts';
+DROP TABLE IF EXISTS empty;
+CREATE TABLE empty (key UInt32, val UInt32, date Datetime) ENGINE=SummingMergeTree(val) PARTITION BY date ORDER BY key;
+INSERT INTO empty VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01');
+SELECT * FROM empty ORDER BY key;
+SELECT table, partition, active FROM system.parts where table = 'empty' and active = 1;
+DROP TABLE empty;
diff --git a/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference
new file mode 100644
index 000000000000..e89c6201fb76
--- /dev/null
+++ b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.reference
@@ -0,0 +1,1 @@
+Check creating empty parts
diff --git a/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql
new file mode 100644
index 000000000000..a98818b21957
--- /dev/null
+++ b/tests/queries/0_stateless/01560_optimize_on_insert_zookeeper.sql
@@ -0,0 +1,36 @@
+DROP TABLE IF EXISTS empty1;
+DROP TABLE IF EXISTS empty2;
+
+SELECT 'Check creating empty parts';
+
+CREATE TABLE empty1 (key UInt32, val UInt32, date Datetime)
+ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '1', val)
+PARTITION BY date ORDER BY key;
+
+CREATE TABLE empty2 (key UInt32, val UInt32, date Datetime)
+ENGINE=ReplicatedSummingMergeTree('/clickhouse/01560_optimize_on_insert', '2', val)
+PARTITION BY date ORDER BY key;
+
+INSERT INTO empty2 VALUES (1, 1, '2020-01-01'), (1, 1, '2020-01-01'), (1, -2, '2020-01-01');
+
+SYSTEM SYNC REPLICA empty1;
+
+SELECT * FROM empty1 ORDER BY key;
+SELECT * FROM empty2 ORDER BY key;
+
+SELECT table, partition, active FROM system.parts where table = 'empty1' and database=currentDatabase() and active = 1;
+SELECT table, partition, active FROM system.parts where table = 'empty2' and database=currentDatabase() and active = 1;
+
+DETACH table empty1;
+DETACH table empty2;
+ATTACH table empty1;
+ATTACH table empty2;
+
+SELECT * FROM empty1 ORDER BY key;
+SELECT * FROM empty2 ORDER BY key;
+
+SELECT table, partition, active FROM system.parts where table = 'empty1' and database=currentDatabase() and active = 1;
+SELECT table, partition, active FROM system.parts where table = 'empty2' and database=currentDatabase() and active = 1;
+
+DROP TABLE IF EXISTS empty1;
+DROP TABLE IF EXISTS empty2;
diff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json
index 974ef48ef3c0..90564d354e54 100644
--- a/tests/queries/skip_list.json
+++ b/tests/queries/skip_list.json
@@ -111,6 +111,7 @@
         "memory_tracking",
         "memory_usage",
         "live_view",
+        "01560_optimize_on_insert_zookeeper",
         "01720_type_map_and_casts",
         "01413_alter_update_supertype",
         "01149_zookeeper_mutation_stuck_after_replace_partition",
@@ -736,6 +737,7 @@
         "01530_drop_database_atomic_sync",
         "01541_max_memory_usage_for_user_long",
         "01542_dictionary_load_exception_race",
+        "01560_optimize_on_insert_zookeeper",
         "01575_disable_detach_table_of_dictionary",
         "01593_concurrent_alter_mutations_kill",
         "01593_concurrent_alter_mutations_kill_many_replicas",
