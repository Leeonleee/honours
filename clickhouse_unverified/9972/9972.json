{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9972,
  "instance_id": "ClickHouse__ClickHouse-9972",
  "issue_numbers": [
    "9672"
  ],
  "base_commit": "8bee467f4cbed23d423a80b7f219c9ada6323971",
  "patch": "diff --git a/dbms/src/Interpreters/QueryNormalizer.cpp b/dbms/src/Interpreters/QueryNormalizer.cpp\nindex 568b08b8f5af..86fbd108f514 100644\n--- a/dbms/src/Interpreters/QueryNormalizer.cpp\n+++ b/dbms/src/Interpreters/QueryNormalizer.cpp\n@@ -76,20 +76,7 @@ void QueryNormalizer::visit(ASTIdentifier & node, ASTPtr & ast, Data & data)\n     if (it_alias != data.aliases.end() && current_alias != node.name)\n     {\n         if (!IdentifierSemantic::canBeAlias(node))\n-        {\n-            /// This means that column had qualified name, which was translated (so, canBeAlias() returns false).\n-            /// But there is an alias with the same name. So, let's use original name for that column.\n-            /// If alias wasn't set, use original column name as alias.\n-            /// That helps to avoid result set with columns which have same names but different values.\n-            if (node.alias.empty())\n-            {\n-                node.name.swap(node.alias);\n-                node.restoreCompoundName();\n-                node.name.swap(node.alias);\n-            }\n-\n             return;\n-        }\n \n         /// We are alias for other column (node.name), but we are alias by\n         /// ourselves to some other column\ndiff --git a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\nindex a0f411dcc96f..17b1bc004f88 100644\n--- a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n+++ b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n@@ -300,14 +300,45 @@ void TranslateQualifiedNamesMatcher::extractJoinUsingColumns(const ASTPtr ast, D\n     }\n }\n \n-void RestoreQualifiedNamesData::visit(ASTIdentifier & identifier, ASTPtr & ast)\n+\n+void RestoreQualifiedNamesMatcher::Data::changeTable(ASTIdentifier & identifier) const\n+{\n+    auto match = IdentifierSemantic::canReferColumnToTable(identifier, distributed_table);\n+    switch (match)\n+    {\n+        case IdentifierSemantic::ColumnMatch::AliasedTableName:\n+        case IdentifierSemantic::ColumnMatch::TableName:\n+        case IdentifierSemantic::ColumnMatch::DbAndTable:\n+            IdentifierSemantic::setColumnLongName(identifier, remote_table);\n+            break;\n+        default:\n+            break;\n+    }\n+}\n+\n+bool RestoreQualifiedNamesMatcher::needChildVisit(ASTPtr &, const ASTPtr & child)\n+{\n+    /// Do not go into subqueries\n+    if (child->as<ASTSelectWithUnionQuery>())\n+        return false; // NOLINT\n+    return true;\n+}\n+\n+void RestoreQualifiedNamesMatcher::visit(ASTPtr & ast, Data & data)\n+{\n+    if (auto * t = ast->as<ASTIdentifier>())\n+        visit(*t, ast, data);\n+}\n+\n+void RestoreQualifiedNamesMatcher::visit(ASTIdentifier & identifier, ASTPtr &, Data & data)\n {\n     if (IdentifierSemantic::getColumnName(identifier))\n     {\n         if (IdentifierSemantic::getMembership(identifier))\n         {\n-            ast = identifier.clone();\n-            ast->as<ASTIdentifier>()->restoreCompoundName();\n+            identifier.restoreCompoundName();\n+            if (data.rename)\n+                data.changeTable(identifier);\n         }\n     }\n }\ndiff --git a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.h b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.h\nindex 51c6c2c42f0e..e8c320671bfc 100644\n--- a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.h\n+++ b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.h\n@@ -59,15 +59,24 @@ class TranslateQualifiedNamesMatcher\n /// It finds columns and translate their names to the normal form. Expand asterisks and qualified asterisks with column names.\n using TranslateQualifiedNamesVisitor = TranslateQualifiedNamesMatcher::Visitor;\n \n-/// Restore ASTIdentifiers to long form\n-struct RestoreQualifiedNamesData\n+\n+/// Restore ASTIdentifiers to long form, change table name in case of distributed.\n+struct RestoreQualifiedNamesMatcher\n {\n-    using TypeToVisit = ASTIdentifier;\n+    struct Data\n+    {\n+        DatabaseAndTableWithAlias distributed_table;\n+        DatabaseAndTableWithAlias remote_table;\n+        bool rename = false;\n \n-    static void visit(ASTIdentifier & identifier, ASTPtr & ast);\n+        void changeTable(ASTIdentifier & identifier) const;\n+    };\n+\n+    static bool needChildVisit(ASTPtr & node, const ASTPtr & child);\n+    static void visit(ASTPtr & ast, Data & data);\n+    static void visit(ASTIdentifier & identifier, ASTPtr & ast, Data & data);\n };\n \n-using RestoreQualifiedNamesMatcher = OneTypeMatcher<RestoreQualifiedNamesData>;\n using RestoreQualifiedNamesVisitor = InDepthNodeVisitor<RestoreQualifiedNamesMatcher, true>;\n \n }\ndiff --git a/dbms/src/Storages/StorageDistributed.cpp b/dbms/src/Storages/StorageDistributed.cpp\nindex 6f98d282e8ce..b4375dd5b0a5 100644\n--- a/dbms/src/Storages/StorageDistributed.cpp\n+++ b/dbms/src/Storages/StorageDistributed.cpp\n@@ -40,6 +40,7 @@\n #include <Interpreters/createBlockSelector.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/getClusterName.h>\n+#include <Interpreters/getTableExpressions.h>\n \n #include <Core/Field.h>\n \n@@ -89,18 +90,23 @@ ASTPtr rewriteSelectQuery(const ASTPtr & query, const std::string & database, co\n     auto modified_query_ast = query->clone();\n \n     ASTSelectQuery & select_query = modified_query_ast->as<ASTSelectQuery &>();\n+    if (table_function_ptr)\n+        select_query.addTableFunction(table_function_ptr);\n+    else\n+        select_query.replaceDatabaseAndTable(database, table);\n \n-    /// restore long column names in JOIN ON expressions\n-    if (auto tables = select_query.tables())\n+    /// Restore long column names (cause our short names are ambiguous).\n+    /// TODO: aliased table functions & CREATE TABLE AS table function cases\n+    if (!table_function_ptr)\n     {\n         RestoreQualifiedNamesVisitor::Data data;\n-        RestoreQualifiedNamesVisitor(data).visit(tables);\n+        data.distributed_table = DatabaseAndTableWithAlias(*getTableExpression(query->as<ASTSelectQuery &>(), 0));\n+        data.remote_table.database = database;\n+        data.remote_table.table = table;\n+        data.rename = true;\n+        RestoreQualifiedNamesVisitor(data).visit(modified_query_ast);\n     }\n \n-    if (table_function_ptr)\n-        select_query.addTableFunction(table_function_ptr);\n-    else\n-        select_query.replaceDatabaseAndTable(database, table);\n     return modified_query_ast;\n }\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.reference b/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.reference\nindex 7967cf7837ee..c0fe46ee9635 100644\n--- a/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.reference\n+++ b/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.reference\n@@ -1,5 +1,19 @@\n-a\t2018-01-01 00:00:00\t\t\t0000-00-00 00:00:00\n-b\t2018-01-01 00:00:00\tb\tb\t2018-01-01 00:00:00\n-c\t2018-01-01 00:00:00\tc\tc\t2018-01-01 00:00:00\n-b\t2018-01-01 00:00:00\tb\tb\t2018-01-01 00:00:00\n-c\t2018-01-01 00:00:00\tc\tc\t2018-01-01 00:00:00\n+\u250c\u2500\u001b[1ma\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1mb\u001b[0m\u2500\u2510\n+\u2502 a \u2502 2018-01-01 \u2502\n+\u2502 b \u2502 2018-01-01 \u2502\n+\u2502 c \u2502 2018-01-01 \u2502\n+\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500\u001b[1mc\u001b[0m\u2500\u252c\u2500\u001b[1ma\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1md\u001b[0m\u2500\u252c\u2500\u001b[1ma\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1mb\u001b[0m\u2500\u2510\n+\u2502 B \u2502 b \u2502 2018-01-01 \u2502 B \u2502 2018-01-01 \u2502\n+\u2502 C \u2502 c \u2502 2018-01-01 \u2502 C \u2502 2018-01-01 \u2502\n+\u2502 D \u2502 d \u2502 2018-01-01 \u2502 D \u2502 2018-01-01 \u2502\n+\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500\u001b[1ma\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1mb\u001b[0m\u2500\u252c\u2500\u001b[1mc\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1md\u001b[0m\u2500\u2510\n+\u2502 a \u2502 2018-01-01 \u2502   \u2502 0000-00-00 \u2502\n+\u2502 b \u2502 2018-01-01 \u2502 B \u2502 2018-01-01 \u2502\n+\u2502 c \u2502 2018-01-01 \u2502 C \u2502 2018-01-01 \u2502\n+\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500\u001b[1ma\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1mb\u001b[0m\u2500\u252c\u2500\u001b[1mc\u001b[0m\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[1md\u001b[0m\u2500\u2510\n+\u2502 b \u2502 2018-01-01 \u2502 B \u2502 2018-01-01 \u2502\n+\u2502 c \u2502 2018-01-01 \u2502 C \u2502 2018-01-01 \u2502\n+\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.sql b/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.sql\nindex b8bd6d3384cf..2058d2309e43 100644\n--- a/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.sql\n+++ b/dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.sql\n@@ -1,14 +1,16 @@\n-DROP TABLE IF EXISTS using1;\n-DROP TABLE IF EXISTS using2;\n+DROP TABLE IF EXISTS table1;\n+DROP TABLE IF EXISTS table2;\n \n-CREATE TABLE using1(a String, b DateTime) ENGINE=MergeTree order by a;\n-CREATE TABLE using2(c String, a String, d DateTime) ENGINE=MergeTree order by c;\n+CREATE TABLE table1(a String, b Date) ENGINE MergeTree order by a;\n+CREATE TABLE table2(c String, a String, d Date) ENGINE MergeTree order by c;\n \n-INSERT INTO using1 VALUES ('a', '2018-01-01 00:00:00') ('b', '2018-01-01 00:00:00') ('c', '2018-01-01 00:00:00');\n-INSERT INTO using2 VALUES ('d', 'd', '2018-01-01 00:00:00') ('b', 'b', '2018-01-01 00:00:00') ('c', 'c', '2018-01-01 00:00:00');\n+INSERT INTO table1 VALUES ('a', '2018-01-01') ('b', '2018-01-01') ('c', '2018-01-01');\n+INSERT INTO table2 VALUES ('D', 'd', '2018-01-01') ('B', 'b', '2018-01-01') ('C', 'c', '2018-01-01');\n \n-SELECT * FROM using1 t1 ALL LEFT JOIN (SELECT *, c as a, d as b FROM using2) t2 USING (a, b) ORDER BY d;\n-SELECT * FROM using1 t1 ALL INNER JOIN (SELECT *, c as a, d as b FROM using2) t2 USING (a, b) ORDER BY d;\n+SELECT * FROM table1 t1 FORMAT PrettyCompact;\n+SELECT *, c as a, d as b FROM table2 FORMAT PrettyCompact;\n+SELECT * FROM table1 t1 ALL LEFT JOIN (SELECT *, c, d as b FROM table2) t2 USING (a, b) ORDER BY d FORMAT PrettyCompact;\n+SELECT * FROM table1 t1 ALL INNER JOIN (SELECT *, c, d as b FROM table2) t2 USING (a, b) ORDER BY d FORMAT PrettyCompact;\n \n-DROP TABLE using1;\n-DROP TABLE using2;\n+DROP TABLE table1;\n+DROP TABLE table2;\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql\nindex b301c0ac00f6..7f56a4e08fd3 100644\n--- a/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql\n@@ -1,5 +1,5 @@\n DROP TABLE IF EXISTS d_numbers;\n-CREATE TABLE d_numbers (number UInt32) ENGINE = Distributed(test_cluster_two_shards_localhost, system, numbers, rand());\n+CREATE TABLE d_numbers (number UInt32) ENGINE = Distributed(test_cluster_two_shards, system, numbers, rand());\n \n SET experimental_use_processors = 1;\n \ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference b/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference\nindex 929dd64ae90f..efbf8ed025e4 100644\n--- a/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference\n@@ -4,3 +4,4 @@ distributed_0\t2\t1\n local_0\t1\n distributed_0\t1\t1\n distributed_0\t2\t1\n+remote_0\t1\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql b/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql\nindex 92b4a83ebf36..0ae6a180570e 100644\n--- a/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql\n@@ -1,5 +1,5 @@\n DROP TABLE IF EXISTS d_one;\n-CREATE TABLE d_one (dummy UInt8) ENGINE = Distributed(test_cluster_two_shards_localhost, system, one, rand());\n+CREATE TABLE d_one (dummy UInt8) ENGINE = Distributed(test_cluster_two_shards, system, one, rand());\n \n SELECT 'local_0', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 0;\n SELECT 'local_1', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 1;\n@@ -16,3 +16,6 @@ SELECT 'distributed_0', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.\n SELECT 'distributed_1', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.dummy = 1 ORDER BY _shard_num;\n \n DROP TABLE d_one;\n+\n+SELECT 'remote_0', toUInt8(1) AS dummy FROM remote('127.0.0.2', system, one) AS o WHERE o.dummy = 0;\n+SELECT 'remote_1', toUInt8(1) AS dummy FROM remote('127.0.0.2', system, one) AS o WHERE o.dummy = 1;\n",
  "problem_statement": "Exception while aliasing expression to column name on distributed table engine.\n**Describe the bug**\r\nWhen we use alias for expression with same name as table column but different data type, and that column appear in WHERE clause on Distributed table exception happens.\r\n\r\n**How to reproduce**\r\nClickHouse server version 20.1.3,  20.3.1\r\n```\r\nCREATE TABLE d_numbers\r\n(\r\n    number UInt32\r\n)\r\nENGINE = Distributed(cluster, system, numbers, rand())\r\n```\r\n\r\n```\r\nSELECT '100' AS number FROM system.numbers AS n WHERE n.number = 100 FORMAT Null;\r\n\r\n\u2192 Progress: 1.10 billion rows, 8.78 GB (1.37 billion rows/s., 10.94 GB/s.) Cancelling query.\r\nOk.\r\nQuery was cancelled.\r\n```\r\nOn *MergeTree table query works\r\n\r\n```\r\nSELECT '100' AS number FROM d_numbers AS n WHERE n.number = 100 FORMAT Null;\r\n\r\n\u2197 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 20.1.3):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Received from 111.222.222.111.\r\n DB::Exception: Illegal types of arguments (String, UInt8) of function equals.\r\n```\r\nOn Distributed table query falls\r\n\r\n**Expected behavior**\r\nBoth queries works \r\n\r\n**Additional context**\r\nClickHouse server version 19.13.7.57 everything works.\r\n\n",
  "hints_text": "@4ertus2 would you like to investigate this issue? I think you are the most experienced in aliases now.\n```\r\nCREATE TABLE d_one  ( dummy UInt8 ) ENGINE = Distributed(cluster, system, one, rand())\r\n```\r\n\r\n```\r\nselect _shard_num, toUInt8(1) as dummy, o.dummy from d_one as o;\r\n\u250c\u2500_shard_num\u2500\u252c\u2500dummy\u2500\u252c\u2500o.dummy\u2500\u2510\r\n\u2502          4 \u2502     1 \u2502       0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u2198 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 20.1.3):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column dummy in block. There are only columns: _shard_num, toUInt8(1).\r\n\r\n1 rows in set. Elapsed: 0.004 sec.\r\n```\r\nlocalhost shard return row and throw exception at one time?\r\n\r\nselect _shard_num, '2' as dummy from d_one as o WHERE toUInt8(dummy);            \r\nWorks, return all rows\r\n\r\nselect _shard_num, '2' as dummy from d_one as o WHERE toUInt8(o.dummy);         \r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown identifier: dummy.\r\n\r\nselect '2' as dummy from d_one as o WHERE toUInt8(o.dummy);\r\nWorks, return 3 rows (looks like except localhost shard)\r\n\r\nselect  _shard_num, toString('2') as dummy from d_one as o WHERE toUInt8(o.dummy);\r\nWorks, return 3 rows (except localhost shard)\nCannot reproduce on master with #9891\r\nTest added. Take a look at test result. It seems to be OK:\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/9891/files#diff-f8c0f778b2fb25c80f645ac2737f6d78R1\r\n\r\nYou may use some specific configuration. If so you need add more info here.\nClickhouse server version 20.3.4\r\n```\r\nCREATE TABLE d_numbers_local (number UInt32) ENGINE = Distributed(test_cluster_two_shards_localhost, system, numbers, rand());\r\n\r\nCREATE TABLE d_numbers_remote (number UInt32) ENGINE = Distributed(test_cluster_two_shards, system, numbers, rand());\r\nSET experimental_use_processors = 1;\r\n```\r\n\r\n```\r\nSELECT '100' AS number FROM d_numbers_local AS n WHERE n.number = 100 LIMIT 2;\r\n2 rows in set. Elapsed: 0.003 sec. Processed 262.14 thousand rows, 2.10 MB (96.64 million rows/s., 773.16 MB/s.)\r\n```\r\n\r\n```\r\nSELECT '100' AS number FROM d_numbers_remote AS n WHERE n.number = 100 LIMIT 2;\r\n\r\n\u2191 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 20.3.4):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Received from 127.0.0.2:9000. DB::Exception: Illegal types of arguments (String, UInt8) of function equals.\r\n\r\n1 rows in set. Elapsed: 0.102 sec.\r\n```\r\nlooks like that because clickhouse treat local and remote server differently\r\n\nSame error on master version and [#9891]( https://github.com/ClickHouse/ClickHouse/pull/9891) pull request\r\n```\r\nClickHouse client version 20.4.1.2810.\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 20.4.1 revision 54434.\r\n\r\nSELECT '100' AS number\r\nFROM d_numbers_remote AS n\r\nWHERE n.number = 100\r\nLIMIT 2\r\n\r\n\u250c\u2500number\u2500\u2510\r\n\u2502 100    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u2198 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 20.4.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Received from 127.0.0.2:9000. DB::Exception: Illegal types of arguments (String, UInt8) of function equals.\r\n\r\n1 rows in set. Elapsed: 0.136 sec.\r\n```\r\n\r\n",
  "created_at": "2020-03-31T16:41:40Z",
  "modified_files": [
    "dbms/src/Interpreters/QueryNormalizer.cpp",
    "dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp",
    "dbms/src/Interpreters/TranslateQualifiedNamesVisitor.h",
    "dbms/src/Storages/StorageDistributed.cpp"
  ],
  "modified_test_files": [
    "dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.reference",
    "dbms/tests/queries/0_stateless/00818_inner_join_bug_3567.sql",
    "dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql",
    "dbms/tests/queries/0_stateless/01104_distributed_one_test.reference",
    "dbms/tests/queries/0_stateless/01104_distributed_one_test.sql"
  ]
}