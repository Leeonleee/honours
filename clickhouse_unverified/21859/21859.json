{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21859,
  "instance_id": "ClickHouse__ClickHouse-21859",
  "issue_numbers": [
    "21632"
  ],
  "base_commit": "03cb0299a94cf72519784e22aa8ee6b3564858b1",
  "patch": "diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 4177d686f573..d699e244f7cc 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -80,12 +80,29 @@ class FunctionDictHelper\n     std::shared_ptr<const IDictionaryBase> getDictionary(const String & dictionary_name)\n     {\n         String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n+\n+        bool can_load_dictionary = external_loader.hasDictionary(resolved_name);\n+\n+        if (!can_load_dictionary)\n+        {\n+            /// If dictionary not found. And database was not implicitly specified\n+            /// we can qualify dictionary name with current database name.\n+            /// It will help if dictionary is created with DDL and is in current database.\n+            if (dictionary_name.find('.') == std::string::npos)\n+            {\n+                String dictionary_name_with_database = context.getCurrentDatabase() + '.' + dictionary_name;\n+                resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name_with_database);\n+            }\n+        }\n+\n         auto dict = external_loader.getDictionary(resolved_name);\n+\n         if (!access_checked)\n         {\n             context.checkAccess(AccessType::dictGet, dict->getDatabaseOrNoDatabaseTag(), dict->getDictionaryID().getTableName());\n             access_checked = true;\n         }\n+\n         return dict;\n     }\n \n@@ -118,14 +135,29 @@ class FunctionDictHelper\n     DictionaryStructure getDictionaryStructure(const String & dictionary_name) const\n     {\n         String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n+\n         auto load_result = external_loader.getLoadResult(resolved_name);\n+        if (!load_result.config)\n+        {\n+            /// If dictionary not found. And database was not implicitly specified\n+            /// we can qualify dictionary name with current database name.\n+            /// It will help if dictionary is created with DDL and is in current database.\n+            if (dictionary_name.find('.') == std::string::npos)\n+            {\n+                String dictionary_name_with_database = context.getCurrentDatabase() + '.' + dictionary_name;\n+                resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name_with_database);\n+                load_result = external_loader.getLoadResult(resolved_name);\n+            }\n+        }\n+\n         if (!load_result.config)\n             throw Exception(\"Dictionary \" + backQuote(dictionary_name) + \" not found\", ErrorCodes::BAD_ARGUMENTS);\n+\n         return ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);\n     }\n \n-private:\n     const Context & context;\n+private:\n     const ExternalDictionariesLoader & external_loader;\n     /// Access cannot be not granted, since in this case checkAccess() will throw and access_checked will not be updated.\n     std::atomic<bool> access_checked = false;\n@@ -296,10 +328,12 @@ class FunctionDictGetNoType final : public IFunction\n \n         DataTypes types;\n \n+        auto dictionary_structure = helper.getDictionaryStructure(dictionary_name);\n+\n         for (auto & attribute_name : attribute_names)\n         {\n             /// We're extracting the return type from the dictionary's config, without loading the dictionary.\n-            auto attribute = helper.getDictionaryStructure(dictionary_name).getAttribute(attribute_name);\n+            auto attribute = dictionary_structure.getAttribute(attribute_name);\n             types.emplace_back(attribute.type);\n         }\n \ndiff --git a/src/Interpreters/ExternalDictionariesLoader.h b/src/Interpreters/ExternalDictionariesLoader.h\nindex e69046706a39..6e61e9cd62f0 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.h\n+++ b/src/Interpreters/ExternalDictionariesLoader.h\n@@ -16,7 +16,7 @@ class ExternalDictionariesLoader : public ExternalLoader\n     using DictPtr = std::shared_ptr<const IDictionaryBase>;\n \n     /// Dictionaries will be loaded immediately and then will be updated in separate thread, each 'reload_period' seconds.\n-    ExternalDictionariesLoader(Context & context_);\n+    explicit ExternalDictionariesLoader(Context & context_);\n \n     DictPtr getDictionary(const std::string & name) const\n     {\n@@ -28,6 +28,11 @@ class ExternalDictionariesLoader : public ExternalLoader\n         return std::static_pointer_cast<const IDictionaryBase>(tryLoad(name));\n     }\n \n+    bool hasDictionary(const std::string & name) const\n+    {\n+        return has(name);\n+    }\n+\n     static DictionaryStructure getDictionaryStructure(const Poco::Util::AbstractConfiguration & config, const std::string & key_in_config = \"dictionary\");\n     static DictionaryStructure getDictionaryStructure(const ObjectConfig & config);\n \ndiff --git a/src/Interpreters/ExternalLoader.cpp b/src/Interpreters/ExternalLoader.cpp\nindex e1713c7cbbbe..636c01001385 100644\n--- a/src/Interpreters/ExternalLoader.cpp\n+++ b/src/Interpreters/ExternalLoader.cpp\n@@ -625,6 +625,12 @@ class ExternalLoader::LoadingDispatcher : private boost::noncopyable\n         return collectLoadResults<ReturnType>(filter);\n     }\n \n+    bool has(const String & name) const\n+    {\n+        std::lock_guard lock{mutex};\n+        return infos.contains(name);\n+    }\n+\n     /// Starts reloading all the object which update time is earlier than now.\n     /// The function doesn't touch the objects which were never tried to load.\n     void reloadOutdated()\n@@ -1391,6 +1397,11 @@ ReturnType ExternalLoader::reloadAllTriedToLoad() const\n     return loadOrReload<ReturnType>([&names](const String & name) { return names.count(name); });\n }\n \n+bool ExternalLoader::has(const String & name) const\n+{\n+    return loading_dispatcher->has(name);\n+}\n+\n Strings ExternalLoader::getAllTriedToLoadNames() const\n {\n     return loading_dispatcher->getAllTriedToLoadNames();\ndiff --git a/src/Interpreters/ExternalLoader.h b/src/Interpreters/ExternalLoader.h\nindex 09915af24705..d1a39af962f9 100644\n--- a/src/Interpreters/ExternalLoader.h\n+++ b/src/Interpreters/ExternalLoader.h\n@@ -196,6 +196,9 @@ class ExternalLoader\n     template <typename ReturnType = Loadables, typename = std::enable_if_t<is_vector_load_result_type<ReturnType>, void>>\n     ReturnType reloadAllTriedToLoad() const;\n \n+    /// Check if object with name exists in configuration\n+    bool has(const String & name) const;\n+\n     /// Reloads all config repositories.\n     void reloadConfig() const;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.reference b/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.reference\nnew file mode 100644\nindex 000000000000..6594f6baa3d2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.reference\n@@ -0,0 +1,8 @@\n+dictGet\n+0\n+1\n+0\n+dictHas\n+1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.sql b/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.sql\nnew file mode 100644\nindex 000000000000..9c405640930a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01760_ddl_dictionary_use_current_database_name.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS ddl_dictonary_test_source;\n+CREATE TABLE ddl_dictonary_test_source\n+(\n+   id UInt64,\n+   value UInt64\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO ddl_dictonary_test_source VALUES (0, 0);\n+INSERT INTO ddl_dictonary_test_source VALUES (1, 1);\n+\n+DROP DICTIONARY IF EXISTS ddl_dictionary_test;\n+CREATE DICTIONARY ddl_dictionary_test\n+(\n+   id UInt64,\n+   value UInt64 DEFAULT 0\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'ddl_dictonary_test_source'))\n+LAYOUT(DIRECT());\n+\n+SELECT 'dictGet';\n+SELECT dictGet('ddl_dictionary_test', 'value', number) FROM system.numbers LIMIT 3;\n+\n+SELECT 'dictHas';\n+SELECT dictHas('ddl_dictionary_test', number) FROM system.numbers LIMIT 3;\n+\n+DROP TABLE ddl_dictonary_test_source;\n+DROP DICTIONARY ddl_dictionary_test;\n",
  "problem_statement": "dictGet without database for SQL dictionaries.\ndictGet('name', ...) should check for XML dictionary 'name' if XML dict=name does not exists then use SQL dictionary from the currectDatabase()\r\n\n",
  "hints_text": "",
  "created_at": "2021-03-18T11:32:23Z"
}