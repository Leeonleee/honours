{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58440,
  "instance_id": "ClickHouse__ClickHouse-58440",
  "issue_numbers": [
    "41461"
  ],
  "base_commit": "029b1326e02ddd0f697fc9597bb3b1952deb7033",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 988c4f357e09..9516ef720775 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -157,7 +157,7 @@ class IColumn;\n     M(Bool, allow_suspicious_fixed_string_types, false, \"In CREATE TABLE statement allows creating columns of type FixedString(n) with n > 256. FixedString with length >= 256 is suspicious and most likely indicates misusage\", 0) \\\n     M(Bool, allow_suspicious_indices, false, \"Reject primary/secondary indexes and sorting keys with identical expressions\", 0) \\\n     M(Bool, allow_suspicious_ttl_expressions, false, \"Reject TTL expressions that don't depend on any of table's columns. It indicates a user error most of the time.\", 0) \\\n-    M(Bool, compile_expressions, false, \"Compile some scalar functions and operators to native code.\", 0) \\\n+    M(Bool, compile_expressions, true, \"Compile some scalar functions and operators to native code.\", 0) \\\n     M(UInt64, min_count_to_compile_expression, 3, \"The number of identical expressions before they are JIT-compiled\", 0) \\\n     M(Bool, compile_aggregate_expressions, true, \"Compile aggregate functions to native code.\", 0) \\\n     M(UInt64, min_count_to_compile_aggregate_expression, 3, \"The number of identical aggregate expressions before they are JIT-compiled\", 0) \\\ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex cdc4292a79c0..07c52d50e182 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -664,26 +664,26 @@ void Aggregator::compileAggregateFunctionsIfNeeded()\n     for (size_t i = 0; i < aggregate_functions.size(); ++i)\n     {\n         const auto * function = aggregate_functions[i];\n-        size_t offset_of_aggregate_function = offsets_of_aggregate_states[i];\n+        bool function_is_compilable = function->isCompilable();\n+        if (!function_is_compilable)\n+            continue;\n \n-        if (function->isCompilable())\n+        size_t offset_of_aggregate_function = offsets_of_aggregate_states[i];\n+        AggregateFunctionWithOffset function_to_compile\n         {\n-            AggregateFunctionWithOffset function_to_compile\n-            {\n-                .function = function,\n-                .aggregate_data_offset = offset_of_aggregate_function\n-            };\n+            .function = function,\n+            .aggregate_data_offset = offset_of_aggregate_function\n+        };\n \n-            functions_to_compile.emplace_back(std::move(function_to_compile));\n+        functions_to_compile.emplace_back(std::move(function_to_compile));\n \n-            functions_description += function->getDescription();\n-            functions_description += ' ';\n+        functions_description += function->getDescription();\n+        functions_description += ' ';\n \n-            functions_description += std::to_string(offset_of_aggregate_function);\n-            functions_description += ' ';\n-        }\n+        functions_description += std::to_string(offset_of_aggregate_function);\n+        functions_description += ' ';\n \n-        is_aggregate_function_compiled[i] = function->isCompilable();\n+        is_aggregate_function_compiled[i] = true;\n     }\n \n     if (functions_to_compile.empty())\n@@ -1685,14 +1685,13 @@ bool Aggregator::executeOnBlock(Columns columns,\n     /// For the case when there are no keys (all aggregate into one row).\n     if (result.type == AggregatedDataVariants::Type::without_key)\n     {\n-        /// TODO: Enable compilation after investigation\n-// #if USE_EMBEDDED_COMPILER\n-//         if (compiled_aggregate_functions_holder)\n-//         {\n-//             executeWithoutKeyImpl<true>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);\n-//         }\n-//         else\n-// #endif\n+#if USE_EMBEDDED_COMPILER\n+        if (compiled_aggregate_functions_holder && !hasSparseArguments(aggregate_functions_instructions.data()))\n+        {\n+            executeWithoutKeyImpl<true>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);\n+        }\n+        else\n+#endif\n         {\n             executeWithoutKeyImpl<false>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);\n         }\ndiff --git a/src/Interpreters/JIT/compileFunction.cpp b/src/Interpreters/JIT/compileFunction.cpp\nindex f50a122f9a28..1c6b324dad7a 100644\n--- a/src/Interpreters/JIT/compileFunction.cpp\n+++ b/src/Interpreters/JIT/compileFunction.cpp\n@@ -67,7 +67,8 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio\n {\n     const auto & function_argument_types = function.getArgumentTypes();\n \n-    llvm::IRBuilder<> b(module.getContext());\n+    auto & context = module.getContext();\n+    llvm::IRBuilder<> b(context);\n     auto * size_type = b.getIntNTy(sizeof(size_t) * 8);\n     auto * data_type = llvm::StructType::get(b.getInt8PtrTy(), b.getInt8PtrTy());\n     auto * func_type = llvm::FunctionType::get(b.getVoidTy(), { size_type, data_type->getPointerTo() }, /*isVarArg=*/false);\n@@ -75,6 +76,8 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio\n     /// Create function in module\n \n     auto * func = llvm::Function::Create(func_type, llvm::Function::ExternalLinkage, function.getName(), module);\n+    func->setAttributes(llvm::AttributeList::get(context, {{2, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));\n+\n     auto * args = func->args().begin();\n     llvm::Value * rows_count_arg = args++;\n     llvm::Value * columns_arg = args++;\n@@ -196,6 +199,9 @@ static void compileCreateAggregateStatesFunctions(llvm::Module & module, const s\n     auto * create_aggregate_states_function_type = llvm::FunctionType::get(b.getVoidTy(), { aggregate_data_places_type }, false);\n     auto * create_aggregate_states_function = llvm::Function::Create(create_aggregate_states_function_type, llvm::Function::ExternalLinkage, name, module);\n \n+    create_aggregate_states_function->setAttributes(\n+        llvm::AttributeList::get(context, {{1, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));\n+\n     auto * arguments = create_aggregate_states_function->args().begin();\n     llvm::Value * aggregate_data_place_arg = arguments++;\n \n@@ -241,6 +247,11 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n     auto * add_into_aggregate_states_func_declaration = llvm::FunctionType::get(b.getVoidTy(), { size_type, size_type, column_type->getPointerTo(), places_type }, false);\n     auto * add_into_aggregate_states_func = llvm::Function::Create(add_into_aggregate_states_func_declaration, llvm::Function::ExternalLinkage, name, module);\n \n+    add_into_aggregate_states_func->setAttributes(llvm::AttributeList::get(\n+        context,\n+        {{3, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},\n+         {4, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));\n+\n     auto * arguments = add_into_aggregate_states_func->args().begin();\n     llvm::Value * row_start_arg = arguments++;\n     llvm::Value * row_end_arg = arguments++;\n@@ -296,7 +307,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n     llvm::Value * aggregation_place = nullptr;\n \n     if (places_argument_type == AddIntoAggregateStatesPlacesArgumentType::MultiplePlaces)\n-        aggregation_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateGEP(b.getInt8Ty()->getPointerTo(), places_arg, counter_phi));\n+        aggregation_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateInBoundsGEP(b.getInt8Ty()->getPointerTo(), places_arg, counter_phi));\n     else\n         aggregation_place = places_arg;\n \n@@ -313,7 +324,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n             auto & column = columns[previous_columns_size + column_argument_index];\n             const auto & argument_type = arguments_types[column_argument_index];\n \n-            auto * column_data_element = b.CreateLoad(column.data_element_type, b.CreateGEP(column.data_element_type, column.data_ptr, counter_phi));\n+            auto * column_data_element = b.CreateLoad(column.data_element_type, b.CreateInBoundsGEP(column.data_element_type, column.data_ptr, counter_phi));\n \n             if (!argument_type->isNullable())\n             {\n@@ -321,7 +332,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n                 continue;\n             }\n \n-            auto * column_null_data_with_offset = b.CreateGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi);\n+            auto * column_null_data_with_offset = b.CreateInBoundsGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi);\n             auto * is_null = b.CreateICmpNE(b.CreateLoad(b.getInt8Ty(), column_null_data_with_offset), b.getInt8(0));\n             auto * nullable_unitialized = llvm::Constant::getNullValue(toNullableType(b, column.data_element_type));\n             auto * first_insert = b.CreateInsertValue(nullable_unitialized, column_data_element, {0});\n@@ -354,7 +365,8 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n \n static void compileMergeAggregatesStates(llvm::Module & module, const std::vector<AggregateFunctionWithOffset> & functions, const std::string & name)\n {\n-    llvm::IRBuilder<> b(module.getContext());\n+    auto & context = module.getContext();\n+    llvm::IRBuilder<> b(context);\n \n     auto * aggregate_data_place_type = b.getInt8Ty()->getPointerTo();\n     auto * aggregate_data_places_type = aggregate_data_place_type->getPointerTo();\n@@ -365,6 +377,11 @@ static void compileMergeAggregatesStates(llvm::Module & module, const std::vecto\n     auto * merge_aggregates_states_func\n         = llvm::Function::Create(merge_aggregates_states_func_declaration, llvm::Function::ExternalLinkage, name, module);\n \n+    merge_aggregates_states_func->setAttributes(llvm::AttributeList::get(\n+        context,\n+        {{1, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},\n+         {2, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));\n+\n     auto * arguments = merge_aggregates_states_func->args().begin();\n     llvm::Value * aggregate_data_places_dst_arg = arguments++;\n     llvm::Value * aggregate_data_places_src_arg = arguments++;\n@@ -426,6 +443,11 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons\n     auto * insert_aggregates_into_result_func_declaration = llvm::FunctionType::get(b.getVoidTy(), { size_type, size_type, column_type->getPointerTo(), aggregate_data_places_type }, false);\n     auto * insert_aggregates_into_result_func = llvm::Function::Create(insert_aggregates_into_result_func_declaration, llvm::Function::ExternalLinkage, name, module);\n \n+    insert_aggregates_into_result_func->setAttributes(llvm::AttributeList::get(\n+        context,\n+        {{3, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},\n+         {4, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));\n+\n     auto * arguments = insert_aggregates_into_result_func->args().begin();\n     llvm::Value * row_start_arg = arguments++;\n     llvm::Value * row_end_arg = arguments++;\n@@ -460,7 +482,7 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons\n     auto * counter_phi = b.CreatePHI(row_start_arg->getType(), 2);\n     counter_phi->addIncoming(row_start_arg, entry);\n \n-    auto * aggregate_data_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateGEP(b.getInt8Ty()->getPointerTo(), aggregate_data_places_arg, counter_phi));\n+    auto * aggregate_data_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateInBoundsGEP(b.getInt8Ty()->getPointerTo(), aggregate_data_places_arg, counter_phi));\n \n     for (size_t i = 0; i < functions.size(); ++i)\n     {\n@@ -470,11 +492,11 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons\n         const auto * aggregate_function_ptr = functions[i].function;\n         auto * final_value = aggregate_function_ptr->compileGetResult(b, aggregation_place_with_offset);\n \n-        auto * result_column_data_element = b.CreateGEP(columns[i].data_element_type, columns[i].data_ptr, counter_phi);\n+        auto * result_column_data_element = b.CreateInBoundsGEP(columns[i].data_element_type, columns[i].data_ptr, counter_phi);\n         if (columns[i].null_data_ptr)\n         {\n             b.CreateStore(b.CreateExtractValue(final_value, {0}), result_column_data_element);\n-            auto * result_column_is_null_element = b.CreateGEP(b.getInt8Ty(), columns[i].null_data_ptr, counter_phi);\n+            auto * result_column_is_null_element = b.CreateInBoundsGEP(b.getInt8Ty(), columns[i].null_data_ptr, counter_phi);\n             b.CreateStore(b.CreateSelect(b.CreateExtractValue(final_value, {1}), b.getInt8(1), b.getInt8(0)), result_column_is_null_element);\n         }\n         else\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01603_decimal_mult_float.reference b/tests/queries/0_stateless/01603_decimal_mult_float.reference\nindex 4c9d45423ee7..72b10d768f1d 100644\n--- a/tests/queries/0_stateless/01603_decimal_mult_float.reference\n+++ b/tests/queries/0_stateless/01603_decimal_mult_float.reference\n@@ -1,14 +1,14 @@\n 2.4\n 10.165\n-0.00012000000000000002\n-150.16500000000002\n-7.775900000000001\n-56.622689999999984\n-598.8376688440277\n-299.41883695311844\n-0.7485470860550345\n-2.2456412771483882\n-1.641386318314034\n-1.641386318314034\n-1.6413863258732018\n-1.6413863258732018\n+0.00012\n+150.165\n+7.7759\n+56.62269\n+598.837669\n+299.418837\n+0.748547\n+2.245641\n+1.641386\n+1.641386\n+1.641386\n+1.641386\ndiff --git a/tests/queries/0_stateless/01603_decimal_mult_float.sql b/tests/queries/0_stateless/01603_decimal_mult_float.sql\nindex 799ab91d3326..1a4652df23a1 100644\n--- a/tests/queries/0_stateless/01603_decimal_mult_float.sql\n+++ b/tests/queries/0_stateless/01603_decimal_mult_float.sql\n@@ -1,9 +1,9 @@\n SET optimize_arithmetic_operations_in_aggregate_functions = 0;\n \n-SELECT toDecimal32(2, 2) * 1.2;\n-SELECT toDecimal64(0.5, 2) * 20.33;\n-SELECT 0.00001 * toDecimal32(12, 2);\n-SELECT 30.033 * toDecimal32(5, 1);\n+SELECT round(toDecimal32(2, 2) * 1.2, 6);\n+SELECT round(toDecimal64(0.5, 2) * 20.33, 6);\n+SELECT round(0.00001 * toDecimal32(12, 2), 6);\n+SELECT round(30.033 * toDecimal32(5, 1), 6);\n \n CREATE TABLE IF NOT EXISTS test01603 (\n     f64 Float64,\n@@ -13,17 +13,17 @@ CREATE TABLE IF NOT EXISTS test01603 (\n \n INSERT INTO test01603(f64) SELECT 1 / (number + 1) FROM system.numbers LIMIT 1000;\n \n-SELECT sum(d * 1.1) FROM test01603;\n-SELECT sum(8.01 * d) FROM test01603;\n+SELECT round(sum(d * 1.1), 6) FROM test01603;\n+SELECT round(sum(8.01 * d), 6) FROM test01603;\n \n-SELECT sum(f64 * toDecimal64(80, 2)) FROM test01603;\n-SELECT sum(toDecimal64(40, 2) * f32) FROM test01603;\n-SELECT sum(f64 * toDecimal64(0.1, 2)) FROM test01603;\n-SELECT sum(toDecimal64(0.3, 2) * f32) FROM test01603;\n+SELECT round(sum(f64 * toDecimal64(80, 2)), 6) FROM test01603;\n+SELECT round(sum(toDecimal64(40, 2) * f32), 6) FROM test01603;\n+SELECT round(sum(f64 * toDecimal64(0.1, 2)), 6) FROM test01603;\n+SELECT round(sum(toDecimal64(0.3, 2) * f32), 6) FROM test01603;\n \n-SELECT sum(f64 * d) FROM test01603;\n-SELECT sum(d * f64) FROM test01603;\n-SELECT sum(f32 * d) FROM test01603;\n-SELECT sum(d * f32) FROM test01603;\n+SELECT round(sum(f64 * d), 6) FROM test01603;\n+SELECT round(sum(d * f64), 6) FROM test01603;\n+SELECT round(sum(f32 * d), 6) FROM test01603;\n+SELECT round(sum(d * f32), 6) FROM test01603;\n \n DROP TABLE IF EXISTS test01603;\n",
  "problem_statement": "Fix JIT for GROUP BY wtihout keys\nRight now the server will crash, so the code disables it:\r\n- https://github.com/ClickHouse/ClickHouse/blob/76aaecf1aa096d22b7d35f65a4c6cb2e0525e254/src/Interpreters/Aggregator.cpp#L1433-L1440 (added by @kitaisreal in #27574)\r\n- https://github.com/ClickHouse/ClickHouse/blob/76aaecf1aa096d22b7d35f65a4c6cb2e0525e254/src/Interpreters/JIT/compileFunction.cpp#L742-L745 (added by @azat in #41046, for details please see https://github.com/ClickHouse/ClickHouse/pull/41046/commits/ba4174402a47512c298e4f3f7804cc772f2802a6)\n",
  "hints_text": "It is being added in this PR: https://github.com/ClickHouse/ClickHouse/pull/27611\nThe PR is unfinished.",
  "created_at": "2024-01-02T21:03:23Z"
}