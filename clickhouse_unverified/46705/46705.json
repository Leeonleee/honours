{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46705,
  "instance_id": "ClickHouse__ClickHouse-46705",
  "issue_numbers": [
    "46694"
  ],
  "base_commit": "a4434a312521ffaf3889d80161ef9379ced4a0e4",
  "patch": "diff --git a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\nindex df96d83316ce..1476a66c8922 100644\n--- a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\n+++ b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\n@@ -102,19 +102,21 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis\n         if (!left_argument_constant_node && !right_argument_constant_node)\n             return;\n \n-        /** If we extract negative constant, aggregate function name must be updated.\n+        /** Need reverse max <-> min for:\n           *\n-          * Example: SELECT min(-1 * id);\n-          * Result: SELECT -1 * max(id);\n+          * max(-1*value) -> -1*min(value)\n+          * max(value/-2) -> min(value)/-2\n+          * max(1-value) -> 1-min(value)\n           */\n-        std::string aggregate_function_name_if_constant_is_negative;\n-        if (arithmetic_function_name == \"multiply\" || arithmetic_function_name == \"divide\")\n+        auto get_reverse_aggregate_function_name = [](const std::string & aggregate_function_name) -> std::string\n         {\n-            if (lower_aggregate_function_name == \"min\")\n-                aggregate_function_name_if_constant_is_negative = \"max\";\n-            else if (lower_aggregate_function_name == \"max\")\n-                aggregate_function_name_if_constant_is_negative = \"min\";\n-        }\n+            if (aggregate_function_name == \"min\")\n+                return \"max\";\n+            else if (aggregate_function_name == \"max\")\n+                return \"min\";\n+            else\n+                return aggregate_function_name;\n+        };\n \n         size_t arithmetic_function_argument_index = 0;\n \n@@ -126,11 +128,11 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis\n \n             /// Rewrite `aggregate_function(inner_function(constant, argument))` into `inner_function(constant, aggregate_function(argument))`\n             const auto & left_argument_constant_value_literal = left_argument_constant_node->getValue();\n-            if (!aggregate_function_name_if_constant_is_negative.empty() &&\n-                left_argument_constant_value_literal < zeroField(left_argument_constant_value_literal))\n-            {\n-                lower_aggregate_function_name = aggregate_function_name_if_constant_is_negative;\n-            }\n+            bool need_reverse = (arithmetic_function_name == \"multiply\" && left_argument_constant_value_literal < zeroField(left_argument_constant_value_literal))\n+                || (arithmetic_function_name == \"minus\");\n+\n+            if (need_reverse)\n+                lower_aggregate_function_name = get_reverse_aggregate_function_name(lower_aggregate_function_name);\n \n             arithmetic_function_argument_index = 1;\n         }\n@@ -138,11 +140,10 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis\n         {\n             /// Rewrite `aggregate_function(inner_function(argument, constant))` into `inner_function(aggregate_function(argument), constant)`\n             const auto & right_argument_constant_value_literal = right_argument_constant_node->getValue();\n-            if (!aggregate_function_name_if_constant_is_negative.empty() &&\n-                right_argument_constant_value_literal < zeroField(right_argument_constant_value_literal))\n-            {\n-                lower_aggregate_function_name = aggregate_function_name_if_constant_is_negative;\n-            }\n+            bool need_reverse = (arithmetic_function_name == \"multiply\" || arithmetic_function_name == \"divide\") && right_argument_constant_value_literal < zeroField(right_argument_constant_value_literal);\n+\n+            if (need_reverse)\n+                lower_aggregate_function_name = get_reverse_aggregate_function_name(lower_aggregate_function_name);\n \n             arithmetic_function_argument_index = 0;\n         }\ndiff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\nindex 66e0813b977e..ef3e6739f8a7 100644\n--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n@@ -73,24 +73,6 @@ Field zeroField(const Field & value)\n     throw Exception(ErrorCodes::BAD_TYPE_OF_FIELD, \"Unexpected literal type in function\");\n }\n \n-const String & changeNameIfNeeded(const String & func_name, const String & child_name, const ASTLiteral & literal)\n-{\n-    static const std::unordered_map<String, std::unordered_set<String>> matches = {\n-        { \"min\", { \"multiply\", \"divide\" } },\n-        { \"max\", { \"multiply\", \"divide\" } }\n-    };\n-\n-    static const std::unordered_map<String, String> swap_to = {\n-        { \"min\", \"max\" },\n-        { \"max\", \"min\" }\n-    };\n-\n-    if (literal.value < zeroField(literal.value) && matches.contains(func_name) && matches.find(func_name)->second.contains(child_name))\n-        return swap_to.find(func_name)->second;\n-\n-    return func_name;\n-}\n-\n ASTPtr tryExchangeFunctions(const ASTFunction & func)\n {\n     static const std::unordered_map<String, std::unordered_set<String>> supported\n@@ -114,19 +96,42 @@ ASTPtr tryExchangeFunctions(const ASTFunction & func)\n \n     ASTPtr optimized_ast;\n \n+    /** Need reverse max <-> min for:\n+      *\n+      * max(-1*value) -> -1*min(value)\n+      * max(value/-2) -> min(value)/-2\n+      * max(1-value) -> 1-min(value)\n+      */\n+    auto get_reverse_aggregate_function_name = [](const std::string & aggregate_function_name) -> std::string\n+    {\n+        if (aggregate_function_name == \"min\")\n+            return \"max\";\n+        else if (aggregate_function_name == \"max\")\n+            return \"min\";\n+        else\n+            return aggregate_function_name;\n+    };\n+\n     if (first_literal && !second_literal)\n     {\n         /// It's possible to rewrite 'sum(1/n)' with 'sum(1) * div(1/n)' but we lose accuracy. Ignored.\n         if (child_func->name == \"divide\")\n             return {};\n+        bool need_reverse\n+            = (child_func->name == \"multiply\" && first_literal->value < zeroField(first_literal->value)) || child_func->name == \"minus\";\n+        if (need_reverse)\n+            lower_name = get_reverse_aggregate_function_name(lower_name);\n \n-        const String & new_name = changeNameIfNeeded(lower_name, child_func->name, *first_literal);\n-        optimized_ast = exchangeExtractFirstArgument(new_name, *child_func);\n+        optimized_ast = exchangeExtractFirstArgument(lower_name, *child_func);\n     }\n     else if (second_literal) /// second or both are consts\n     {\n-        const String & new_name = changeNameIfNeeded(lower_name, child_func->name, *second_literal);\n-        optimized_ast = exchangeExtractSecondArgument(new_name, *child_func);\n+        bool need_reverse\n+            = (child_func->name == \"multiply\" || child_func->name == \"divide\") && second_literal->value < zeroField(second_literal->value);\n+        if (need_reverse)\n+            lower_name = get_reverse_aggregate_function_name(lower_name);\n+\n+        optimized_ast = exchangeExtractSecondArgument(lower_name, *child_func);\n     }\n \n     if (optimized_ast)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01271_optimize_arithmetic_operations_in_aggr_func_long.reference b/tests/queries/0_stateless/01271_optimize_arithmetic_operations_in_aggr_func_long.reference\nindex b50519b9b3af..ea04f155f245 100644\n--- a/tests/queries/0_stateless/01271_optimize_arithmetic_operations_in_aggr_func_long.reference\n+++ b/tests/queries/0_stateless/01271_optimize_arithmetic_operations_in_aggr_func_long.reference\n@@ -22,7 +22,7 @@ SELECT\n     min(n) + 1,\n     1 + min(n),\n     min(n) - 1,\n-    1 - min(n)\n+    1 - max(n)\n FROM\n (\n     SELECT number AS n\n@@ -42,7 +42,7 @@ SELECT\n     max(n) + 1,\n     1 + max(n),\n     max(n) - 1,\n-    1 - max(n)\n+    1 - min(n)\n FROM\n (\n     SELECT number AS n\n@@ -82,7 +82,7 @@ SELECT\n     min(n) + -1,\n     -1 + min(n),\n     min(n) - -1,\n-    -1 - min(n)\n+    -1 - max(n)\n FROM\n (\n     SELECT number AS n\n@@ -102,7 +102,7 @@ SELECT\n     max(n) + -1,\n     -1 + max(n),\n     max(n) - -1,\n-    -1 - max(n)\n+    -1 - min(n)\n FROM\n (\n     SELECT number AS n\n@@ -142,7 +142,7 @@ SELECT\n     min(abs(2)) + 1,\n     min(abs(2) + n),\n     min(n - abs(2)),\n-    1 - min(abs(2))\n+    1 - max(abs(2))\n FROM\n (\n     SELECT number AS n\n@@ -162,7 +162,7 @@ SELECT\n     max(abs(2)) + 1,\n     max(abs(2) + n),\n     max(n - abs(2)),\n-    1 - max(abs(2))\n+    1 - min(abs(2))\n FROM\n (\n     SELECT number AS n\n@@ -202,7 +202,7 @@ SELECT\n     min(abs(n)) + 1,\n     min(abs(n) + n),\n     min(n - abs(n)),\n-    1 - min(abs(n))\n+    1 - max(abs(n))\n FROM\n (\n     SELECT number AS n\n@@ -222,7 +222,7 @@ SELECT\n     max(abs(n)) + 1,\n     max(abs(n) + n),\n     max(n - abs(n)),\n-    1 - max(abs(n))\n+    1 - min(abs(n))\n FROM\n (\n     SELECT number AS n\n@@ -262,7 +262,7 @@ SELECT\n     min(n * n) + 1,\n     1 + min(n * n),\n     min(n * n) - 1,\n-    1 - min(n * n)\n+    1 - max(n * n)\n FROM\n (\n     SELECT number AS n\n@@ -282,7 +282,7 @@ SELECT\n     max(n * n) + 1,\n     1 + max(n * n),\n     max(n * n) - 1,\n-    1 - max(n * n)\n+    1 - min(n * n)\n FROM\n (\n     SELECT number AS n\n@@ -382,7 +382,7 @@ SELECT\n     (min(n) + -1) + -1,\n     (-1 + min(n)) + -1,\n     (min(n) - -1) + -1,\n-    (-1 - min(n)) + -1\n+    (-1 - max(n)) + -1\n FROM\n (\n     SELECT number AS n\n@@ -402,7 +402,7 @@ SELECT\n     (max(n) + -1) + -1,\n     (-1 + max(n)) + -1,\n     (max(n) - -1) + -1,\n-    (-1 - max(n)) + -1\n+    (-1 - min(n)) + -1\n FROM\n (\n     SELECT number AS n\n@@ -430,7 +430,7 @@ FROM\n     SELECT number AS n\n     FROM numbers(10)\n )\n-SELECT (((min(n) + 1) + (1 + min(n))) + (min(n) - 1)) + (1 - min(n))\n+SELECT (((min(n) + 1) + (1 + min(n))) + (min(n) - 1)) + (1 - max(n))\n FROM\n (\n     SELECT number AS n\n@@ -442,7 +442,7 @@ FROM\n     SELECT number AS n\n     FROM numbers(10)\n )\n-SELECT (((max(n) + 1) + (1 + max(n))) + (max(n) - 1)) + (1 - max(n))\n+SELECT (((max(n) + 1) + (1 + max(n))) + (max(n) - 1)) + (1 - min(n))\n FROM\n (\n     SELECT number AS n\n@@ -456,15 +456,15 @@ FROM\n )\n 55\t55\t35\t-35\n 90\t90\t22.5\tinf\n-1\t1\t-1\t1\n+1\t1\t-1\t-8\n 0\t0\t0\t0.1111111111111111\n-10\t10\t8\t-8\n+10\t10\t8\t1\n 18\t18\t4.5\tinf\n 35\t35\t55\t-55\n -90\t-90\t-22.5\t-inf\n--1\t-1\t1\t-1\n+-1\t-1\t1\t-10\n -18\t-18\t-4.5\t-inf\n-8\t8\t10\t-10\n+8\t8\t10\t-1\n 0\t0\t-0\t-0.1111111111111111\n 30\t65\t25\t-10\n 40\t90\t22.5\t5\n@@ -474,15 +474,15 @@ FROM\n 4\t18\t4.5\t0.5\n 55\t90\t0\t-35\n 90\t285\tnan\tinf\n-1\t0\t0\t1\n+1\t0\t0\t-8\n 0\t0\tnan\t0.1111111111111111\n-10\t18\t0\t-8\n+10\t18\t0\t1\n 18\t81\tnan\tinf\n 295\t295\t275\t-275\n 570\t570\t142.5\tnan\n-1\t1\t-1\t1\n+1\t1\t-1\t-80\n 0\t0\t0\tnan\n-82\t82\t80\t-80\n+82\t82\t80\t1\n 162\t162\t40.5\tnan\n 65\t65\t45\t-25\n 100\t100\t32.5\tinf\n@@ -492,15 +492,15 @@ FROM\n 19\t19\t5.5\tinf\n 25\t25\t45\t-65\n 90\t90\t22.5\tinf\n--2\t-2\t0\t-2\n+-2\t-2\t0\t-11\n 0\t0\t0\t0.1111111111111111\n-7\t7\t9\t-11\n+7\t7\t9\t-2\n 18\t18\t4.5\tinf\n 110\n inf\n-2\n+-7\n 0.1111111111111111\n-20\n+29\n inf\n -15444\n 68.62157087543459\ndiff --git a/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.reference b/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.reference\nindex 4f9430ef608f..43282d09babb 100644\n--- a/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.reference\n+++ b/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.reference\n@@ -1,1 +1,2 @@\n 4\t2\n+100\t99\ndiff --git a/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.sql b/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.sql\nindex e3e508e17be7..5eba14ea528b 100644\n--- a/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.sql\n+++ b/tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.sql\n@@ -12,3 +12,5 @@ INSERT INTO test_table VALUES (1, 1);\n INSERT INTO test_table VALUES (1, 1);\n \n SELECT sum((2 * id) as func), func FROM test_table GROUP BY id;\n+\n+SELECT max(100-number), min(100-number) FROM numbers(2);\n",
  "problem_statement": "optimize_arithmetic_operations_in_aggregate_functions cannot be used with max / min ...\n```sql\r\nselect max(100-c1), min(100-c1) from values ((0),(100)) \r\nsettings optimize_arithmetic_operations_in_aggregate_functions=0;\r\n\u250c\u2500max(minus(100, c1))\u2500\u252c\u2500min(minus(100, c1))\u2500\u2510\r\n\u2502                 100 \u2502                   0 \u2502 OK\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect max(100-c1), min(100-c1) from values ((0),(100)) \r\nsettings optimize_arithmetic_operations_in_aggregate_functions=1;\r\n\u250c\u2500minus(100, max(c1))\u2500\u252c\u2500minus(100, min(c1))\u2500\u2510\r\n\u2502                   0 \u2502                 100 \u2502 Not OK\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "",
  "created_at": "2023-02-22T02:34:49Z",
  "modified_files": [
    "src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp",
    "src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01271_optimize_arithmetic_operations_in_aggr_func_long.reference",
    "tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.reference",
    "tests/queries/0_stateless/02498_analyzer_aggregate_functions_arithmetic_operations_pass_fix.sql"
  ]
}