{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59752,
  "instance_id": "ClickHouse__ClickHouse-59752",
  "issue_numbers": [
    "59749"
  ],
  "base_commit": "b22118a2dd2ffae0d84c9f52640d24fb8253ede9",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md\nindex d5dbca3f2b7d..22f879c62aee 100644\n--- a/docs/en/sql-reference/functions/string-search-functions.md\n+++ b/docs/en/sql-reference/functions/string-search-functions.md\n@@ -590,6 +590,10 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## countMatchesCaseInsensitive\n+\n+Like `countMatches(haystack, pattern)` but matching ignores the case.\n+\n ## regexpExtract\n \n Extracts the first string in haystack that matches the regexp pattern and corresponds to the regex group index.\ndiff --git a/src/Functions/countMatches.h b/src/Functions/countMatches.h\nindex 5e02915de56c..e9880e6e93f4 100644\n--- a/src/Functions/countMatches.h\n+++ b/src/Functions/countMatches.h\n@@ -3,6 +3,7 @@\n #include <Functions/IFunction.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n+#include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <DataTypes/DataTypesNumber.h>\n@@ -15,9 +16,7 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ILLEGAL_COLUMN;\n-    extern const int LOGICAL_ERROR;\n }\n \n using Pos = const char *;\n@@ -35,45 +34,46 @@ class FunctionCountMatches : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (!isStringOrFixedString(arguments[1].type))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type {} of second argument (pattern) of function {}. Must be String/FixedString.\",\n-                arguments[1].type->getName(), getName());\n-        if (!isStringOrFixedString(arguments[0].type))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type {} of first argument (haystack) of function {}. Must be String/FixedString.\",\n-                arguments[0].type->getName(), getName());\n-        const auto * column = arguments[1].column.get();\n-        if (!column || !checkAndGetColumnConstStringOrFixedString(column))\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                \"The second argument of function {} should be a constant string with the pattern\",\n-                getName());\n+        FunctionArgumentDescriptors args{\n+            {\"haystack\", &isStringOrFixedString<IDataType>, nullptr, \"String or FixedString\"},\n+            {\"pattern\", &isString<IDataType>, isColumnConst, \"constant String\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n \n         return std::make_shared<DataTypeUInt64>();\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n-        const ColumnConst * column_pattern = checkAndGetColumnConstStringOrFixedString(arguments[1].column.get());\n-        const OptimizedRegularExpression re = Regexps::createRegexp</*is_like*/ false, /*no_capture*/ true, CountMatchesBase::case_insensitive>(column_pattern->getValue<String>());\n-        OptimizedRegularExpression::MatchVec matches;\n+        const IColumn * col_pattern = arguments[1].column.get();\n+        const ColumnConst * col_pattern_const = checkAndGetColumnConst<ColumnString>(col_pattern);\n+        if (col_pattern_const == nullptr)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Pattern argument is not const\");\n+\n+        const OptimizedRegularExpression re = Regexps::createRegexp</*is_like*/ false, /*no_capture*/ true, CountMatchesBase::case_insensitive>(col_pattern_const->getValue<String>());\n \n-        const IColumn * column_haystack = arguments[0].column.get();\n+        const IColumn * col_haystack = arguments[0].column.get();\n+        OptimizedRegularExpression::MatchVec matches;\n \n-        if (const ColumnString * col_str = checkAndGetColumn<ColumnString>(column_haystack))\n+        if (const ColumnConst * col_haystack_const = checkAndGetColumnConstStringOrFixedString(col_haystack))\n+        {\n+            std::string_view str = col_haystack_const->getDataColumn().getDataAt(0).toView();\n+            uint64_t matches_count = countMatches(str, re, matches);\n+            return result_type->createColumnConst(input_rows_count, matches_count);\n+        }\n+        else if (const ColumnString * col_haystack_string = checkAndGetColumn<ColumnString>(col_haystack))\n         {\n-            auto result_column = ColumnUInt64::create();\n+            auto col_res = ColumnUInt64::create();\n \n-            const ColumnString::Chars & src_chars = col_str->getChars();\n-            const ColumnString::Offsets & src_offsets = col_str->getOffsets();\n+            const ColumnString::Chars & src_chars = col_haystack_string->getChars();\n+            const ColumnString::Offsets & src_offsets = col_haystack_string->getOffsets();\n \n-            ColumnUInt64::Container & vec_res = result_column->getData();\n+            ColumnUInt64::Container & vec_res = col_res->getData();\n             vec_res.resize(input_rows_count);\n \n-            size_t size = src_offsets.size();\n             ColumnString::Offset current_src_offset = 0;\n \n-            for (size_t i = 0; i < size; ++i)\n+            for (size_t i = 0; i < input_rows_count; ++i)\n             {\n                 Pos pos = reinterpret_cast<Pos>(&src_chars[current_src_offset]);\n                 current_src_offset = src_offsets[i];\n@@ -83,16 +83,25 @@ class FunctionCountMatches : public IFunction\n                 vec_res[i] = countMatches(str, re, matches);\n             }\n \n-            return result_column;\n+            return col_res;\n         }\n-        else if (const ColumnConst * col_const_str = checkAndGetColumnConstStringOrFixedString(column_haystack))\n+        else if (const ColumnFixedString * col_haystack_fixedstring = checkAndGetColumn<ColumnFixedString>(col_haystack))\n         {\n-            std::string_view str = col_const_str->getDataColumn().getDataAt(0).toView();\n-            uint64_t matches_count = countMatches(str, re, matches);\n-            return result_type->createColumnConst(input_rows_count, matches_count);\n+            auto col_res = ColumnUInt64::create();\n+\n+            ColumnUInt64::Container & vec_res = col_res->getData();\n+            vec_res.resize(input_rows_count);\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                std::string_view str = col_haystack_fixedstring->getDataAt(i).toView();\n+                vec_res[i] = countMatches(str, re, matches);\n+            }\n+\n+            return col_res;\n         }\n         else\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Error in FunctionCountMatches::getReturnTypeImpl()\");\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Could not cast haystack argument to String or FixedString\");\n     }\n \n     static uint64_t countMatches(std::string_view src, const OptimizedRegularExpression & re, OptimizedRegularExpression::MatchVec & matches)\n@@ -116,7 +125,7 @@ class FunctionCountMatches : public IFunction\n             if (!matches[0].length)\n                 break;\n             pos += matches[0].offset + matches[0].length;\n-            match_count++;\n+            ++match_count;\n         }\n \n         return match_count;\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 51aa8222a89c..0b29b0f0709d 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -190,6 +190,7 @@ CustomSeparatedWithNamesAndTypes\n DBAs\n DBMSs\n DBeaver\n+DD\n DDLWORKER\n DDLWorker\n DDLWorkerThreads\n@@ -215,7 +216,6 @@ DatabaseOrdinaryThreadsActive\n DateTime\n DateTimes\n DbCL\n-DD\n Decrypted\n Deduplicate\n Deduplication\n@@ -840,6 +840,7 @@ Sematext\n SendExternalTables\n SendScalars\n ShareAlike\n+Shortkeys\n SimHash\n Simhash\n SimpleAggregateFunction\n@@ -952,8 +953,8 @@ TotalRowsOfMergeTreeTables\n TotalTemporaryFiles\n Tradeoff\n Transactional\n-TwoColumnList\n Tukey\n+TwoColumnList\n UBSan\n UDFs\n UInt\n@@ -1325,6 +1326,7 @@ cosineDistance\n countDigits\n countEqual\n countMatches\n+countMatchesCaseInsensitive\n countSubstrings\n covarPop\n covarSamp\n@@ -1688,6 +1690,7 @@ hudi\n hyperscan\n hypot\n hyvor\n+iTerm\n icosahedron\n icudata\n idempotency\n@@ -2132,6 +2135,7 @@ py\n qryn\n quantile\n quantileBFloat\n+quantileDD\n quantileDeterministic\n quantileExact\n quantileExactExclusive\n@@ -2146,6 +2150,7 @@ quantileTDigestWeighted\n quantileTiming\n quantileTimingWeighted\n quantilebfloat\n+quantileddsketch\n quantiledeterministic\n quantileexact\n quantileexactweighted\n@@ -2158,8 +2163,6 @@ quantiletdigest\n quantiletdigestweighted\n quantiletiming\n quantiletimingweighted\n-quantileddsketch\n-quantileDD\n quartile\n queryID\n queryString\n@@ -2292,8 +2295,8 @@ seektable\n sequenceCount\n sequenceMatch\n sequenceNextNode\n-seriesOutliersDetectTukey\n seriesDecomposeSTL\n+seriesOutliersDetectTukey\n seriesPeriodDetectFFT\n serverTimeZone\n serverTimezone\n@@ -2307,6 +2310,7 @@ shardNum\n sharded\n sharding\n shortcircuit\n+shortkeys\n shoutout\n simdjson\n simpleLinearRegression\n@@ -2730,6 +2734,3 @@ znode\n znodes\n zookeeperSessionUptime\n zstd\n-iTerm\n-shortkeys\n-Shortkeys\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01595_countMatches.reference b/tests/queries/0_stateless/01595_countMatches.reference\nindex c65279c0b8e3..394c85084301 100644\n--- a/tests/queries/0_stateless/01595_countMatches.reference\n+++ b/tests/queries/0_stateless/01595_countMatches.reference\n@@ -12,6 +12,7 @@ case sensitive\n 2\n 4\n 4\n+2\n case insensitive\n 2\n 1\n@@ -21,4 +22,8 @@ case insensitive\n 2\n 4\n 4\n+2\n errors\n+FixedString\n+2\n+2\ndiff --git a/tests/queries/0_stateless/01595_countMatches.sql b/tests/queries/0_stateless/01595_countMatches.sql\nindex 0b170945d444..0c2982572cda 100644\n--- a/tests/queries/0_stateless/01595_countMatches.sql\n+++ b/tests/queries/0_stateless/01595_countMatches.sql\n@@ -14,6 +14,7 @@ select countMatches(concat(toString(number), 'foofoo'), 'foo') from numbers(2);\n select countMatches('foobarbazfoobarbaz', 'foo(bar)(?:baz|)');\n select countMatches('foo.com bar.com baz.com bam.com', '([^. ]+)\\.([^. ]+)');\n select countMatches('foo.com@foo.com bar.com@foo.com baz.com@foo.com bam.com@foo.com', '([^. ]+)\\.([^. ]+)@([^. ]+)\\.([^. ]+)');\n+select countMatches(materialize('foobarfoo'), 'foo');\n \n select 'case insensitive';\n select countMatchesCaseInsensitive('foobarfoo', 'FOo');\n@@ -23,7 +24,13 @@ select countMatchesCaseInsensitive(concat(toString(number), 'Foofoo'), 'foo') fr\n select countMatchesCaseInsensitive('foOBarBAZfoobarbaz', 'foo(bar)(?:baz|)');\n select countMatchesCaseInsensitive('foo.com BAR.COM baz.com bam.com', '([^. ]+)\\.([^. ]+)');\n select countMatchesCaseInsensitive('foo.com@foo.com bar.com@foo.com BAZ.com@foo.com bam.com@foo.com', '([^. ]+)\\.([^. ]+)@([^. ]+)\\.([^. ]+)');\n+select countMatchesCaseInsensitive(materialize('foobarfoo'), 'FOo');\n \n select 'errors';\n-select countMatches(1, 'foo') from numbers(1); -- { serverError 43 }\n-select countMatches('foobarfoo', toString(number)) from numbers(1); -- { serverError 44 }\n+select countMatches(1, 'foo') from numbers(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+select countMatches('foobarfoo', toString(number)) from numbers(1); -- { serverError ILLEGAL_COLUMN }\n+select countMatches('foo', materialize('foo')); -- { serverError ILLEGAL_COLUMN }\n+\n+select 'FixedString';\n+select countMatches(toFixedString('foobarfoo', 9), 'foo');\n+select countMatches(materialize(toFixedString('foobarfoo', 9)), 'foo');\n",
  "problem_statement": "Logical error in `countMatches` found by AST Fuzzer\nhttps://s3.amazonaws.com/clickhouse-test-reports/59563/a740fc7835ff54bda95c322d9d19e31349144d8e/ast_fuzzer__tsan_.html\r\n\r\n```sql\r\nSELECT  (39.08935546874999, 57.25528054528888), countMatches(toFixedString(materialize('foo'), 3), toFixedString(toFixedString('[f]{0}', 6), 6)) GROUP BY jumpConsistentHash(42, 57)\r\n```\r\n\r\n```\r\n[...]\r\n2024.02.07 18:10:03.407721 [ 1213 ] {} <Fatal> BaseDaemon: 12. DB::FunctionCountMatches<(anonymous namespace)::FunctionCountMatchesCaseSensitive>::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000092fd4d6 in /workspace/clickhouse\r\n2024.02.07 18:10:07.835696 [ 1213 ] {} <Fatal> BaseDaemon: 13. DB::IFunction::executeImplDryRun(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000007453304 in /workspace/clickhouse\r\n2024.02.07 18:10:12.281175 [ 1213 ] {} <Fatal> BaseDaemon: 14. DB::FunctionToExecutableFunctionAdaptor::executeDryRunImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000007452bb1 in /workspace/clickhouse\r\n2024.02.07 18:10:12.324003 [ 1213 ] {} <Fatal> BaseDaemon: 15. ./build_docker/./src/Functions/IFunction.cpp:0: DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000016671fe7 in /workspace/clickhouse\r\n[...]\r\n```\n",
  "hints_text": "",
  "created_at": "2024-02-08T11:55:12Z"
}