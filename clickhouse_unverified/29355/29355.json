{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 29355,
  "instance_id": "ClickHouse__ClickHouse-29355",
  "issue_numbers": [
    "29349"
  ],
  "base_commit": "1c1e2e6b28090fc00bde0c2dcdcf1e4cca1b1657",
  "patch": "diff --git a/src/Interpreters/IdentifierSemantic.cpp b/src/Interpreters/IdentifierSemantic.cpp\nindex 098bf0333991..1112b5c3bda4 100644\n--- a/src/Interpreters/IdentifierSemantic.cpp\n+++ b/src/Interpreters/IdentifierSemantic.cpp\n@@ -162,7 +162,7 @@ IdentifierSemantic::ColumnMatch IdentifierSemantic::canReferColumnToTable(const\n {\n     /// database.table.column\n     if (doesIdentifierBelongTo(identifier, db_and_table.database, db_and_table.table))\n-        return ColumnMatch::DbAndTable;\n+        return ColumnMatch::DBAndTable;\n \n     /// alias.column\n     if (doesIdentifierBelongTo(identifier, db_and_table.alias))\n@@ -199,7 +199,7 @@ void IdentifierSemantic::setColumnShortName(ASTIdentifier & identifier, const Da\n         case ColumnMatch::TableAlias:\n             to_strip = 1;\n             break;\n-        case ColumnMatch::DbAndTable:\n+        case ColumnMatch::DBAndTable:\n             to_strip = 2;\n             break;\n         default:\ndiff --git a/src/Interpreters/IdentifierSemantic.h b/src/Interpreters/IdentifierSemantic.h\nindex b36c1ad00dd1..cabe755027cf 100644\n--- a/src/Interpreters/IdentifierSemantic.h\n+++ b/src/Interpreters/IdentifierSemantic.h\n@@ -31,7 +31,7 @@ struct IdentifierSemantic\n         ColumnName,       /// column qualified with column names list\n         AliasedTableName, /// column qualified with table name (but table has an alias so its priority is lower than TableName)\n         TableName,        /// column qualified with table name\n-        DbAndTable,       /// column qualified with database and table name\n+        DBAndTable,       /// column qualified with database and table name\n         TableAlias,       /// column qualified with table alias\n         Ambiguous,\n     };\ndiff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex 271d73714257..3aae39827582 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -128,7 +128,7 @@ class RenameQualifiedIdentifiersMatcher\n             /// Table has an alias. We do not need to rewrite qualified names with table alias (match == ColumnMatch::TableName).\n             auto match = IdentifierSemantic::canReferColumnToTable(identifier, table);\n             if (match == IdentifierSemantic::ColumnMatch::AliasedTableName ||\n-                match == IdentifierSemantic::ColumnMatch::DbAndTable)\n+                match == IdentifierSemantic::ColumnMatch::DBAndTable)\n             {\n                 if (rewritten)\n                     throw Exception(\"Failed to rewrite distributed table names. Ambiguous column '\" + identifier.name() + \"'\",\ndiff --git a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\nindex bf3bbf22b8c4..2d1b6b3f2394 100644\n--- a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n+++ b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n@@ -334,7 +334,7 @@ void RestoreQualifiedNamesMatcher::Data::changeTable(ASTIdentifier & identifier)\n     {\n         case IdentifierSemantic::ColumnMatch::AliasedTableName:\n         case IdentifierSemantic::ColumnMatch::TableName:\n-        case IdentifierSemantic::ColumnMatch::DbAndTable:\n+        case IdentifierSemantic::ColumnMatch::DBAndTable:\n             IdentifierSemantic::setColumnLongName(identifier, remote_table);\n             break;\n         default:\ndiff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex c05118b7c6a3..ae304906476d 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -104,24 +104,6 @@ ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, ContextPtr\n     return res;\n }\n \n-std::tuple<bool, ASTPtr> evaluateDatabaseNameForMergeEngine(const ASTPtr & node, ContextPtr context)\n-{\n-    if (const auto * func = node->as<ASTFunction>(); func && func->name == \"REGEXP\")\n-    {\n-        if (func->arguments->children.size() != 1)\n-            throw Exception(\"Arguments for REGEXP in Merge ENGINE should be 1\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        auto * literal = func->arguments->children[0]->as<ASTLiteral>();\n-        if (!literal || literal->value.safeGet<String>().empty())\n-            throw Exception(\"Argument for REGEXP in Merge ENGINE should be a non empty String Literal\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        return std::tuple{true, func->arguments->children[0]};\n-    }\n-\n-    auto ast = evaluateConstantExpressionForDatabaseName(node, context);\n-    return std::tuple{false, ast};\n-}\n-\n \n namespace\n {\ndiff --git a/src/Interpreters/evaluateConstantExpression.h b/src/Interpreters/evaluateConstantExpression.h\nindex 3b817080fe0e..b95982f5b996 100644\n--- a/src/Interpreters/evaluateConstantExpression.h\n+++ b/src/Interpreters/evaluateConstantExpression.h\n@@ -53,6 +53,4 @@ ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, ContextPtr\n   */\n std::optional<Blocks> evaluateExpressionOverConstantCondition(const ASTPtr & node, const ExpressionActionsPtr & target_expr, size_t & limit);\n \n-// Evaluate database name or regexp for StorageMerge and TableFunction merge\n-std::tuple<bool, ASTPtr> evaluateDatabaseNameForMergeEngine(const ASTPtr & node, ContextPtr context);\n }\ndiff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\nindex 7c5d36b37ced..0b09a1f94d5d 100644\n--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n@@ -280,7 +280,7 @@ StorageEmbeddedRocksDB::StorageEmbeddedRocksDB(const StorageID & table_id_,\n     {\n         fs::create_directories(rocksdb_dir);\n     }\n-    initDb();\n+    initDB();\n }\n \n void StorageEmbeddedRocksDB::truncate(const ASTPtr &, const StorageMetadataPtr & , ContextPtr, TableExclusiveLockHolder &)\n@@ -291,10 +291,10 @@ void StorageEmbeddedRocksDB::truncate(const ASTPtr &, const StorageMetadataPtr &\n \n     fs::remove_all(rocksdb_dir);\n     fs::create_directories(rocksdb_dir);\n-    initDb();\n+    initDB();\n }\n \n-void StorageEmbeddedRocksDB::initDb()\n+void StorageEmbeddedRocksDB::initDB()\n {\n     rocksdb::Status status;\n     rocksdb::Options base;\ndiff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\nindex 71460a1667ed..b095673a6f59 100644\n--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\n+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.h\n@@ -69,6 +69,6 @@ class StorageEmbeddedRocksDB final : public shared_ptr_helper<StorageEmbeddedRoc\n     mutable std::shared_mutex rocksdb_ptr_mx;\n     String rocksdb_dir;\n \n-    void initDb();\n+    void initDB();\n };\n }\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex c1066329e6fe..aaa375d645e0 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -35,6 +35,7 @@ namespace DB\n \n namespace ErrorCodes\n {\n+    extern const int BAD_ARGUMENTS;\n     extern const int LOGICAL_ERROR;\n     extern const int NOT_IMPLEMENTED;\n     extern const int ILLEGAL_PREWHERE;\n@@ -49,7 +50,7 @@ StorageMerge::StorageMerge(\n     const String & comment,\n     const String & source_database_name_or_regexp_,\n     bool database_is_regexp_,\n-    const DbToTableSetMap & source_databases_and_tables_,\n+    const DBToTableSetMap & source_databases_and_tables_,\n     ContextPtr context_)\n     : IStorage(table_id_)\n     , WithContext(context_->getGlobalContext())\n@@ -573,11 +574,14 @@ DatabaseTablesIteratorPtr StorageMerge::getDatabaseIterator(const String & datab\n {\n     auto database = DatabaseCatalog::instance().getDatabase(database_name);\n \n-    auto table_name_match = [this, &database_name](const String & table_name_) -> bool {\n+    auto table_name_match = [this, database_name](const String & table_name_) -> bool\n+    {\n         if (source_databases_and_tables)\n         {\n-            const auto & source_tables = (*source_databases_and_tables).at(database_name);\n-            return source_tables.count(table_name_);\n+            if (auto it = source_databases_and_tables->find(database_name); it != source_databases_and_tables->end())\n+                return it->second.count(table_name_);\n+            else\n+                return false;\n         }\n         else\n             return source_table_regexp->match(table_name_);\n@@ -742,6 +746,26 @@ IStorage::ColumnSizeByName StorageMerge::getColumnSizes() const\n     return first_materialized_mysql->getColumnSizes();\n }\n \n+\n+std::tuple<bool /* is_regexp */, ASTPtr> StorageMerge::evaluateDatabaseName(const ASTPtr & node, ContextPtr context_)\n+{\n+    if (const auto * func = node->as<ASTFunction>(); func && func->name == \"REGEXP\")\n+    {\n+        if (func->arguments->children.size() != 1)\n+            throw Exception(\"REGEXP in Merge ENGINE takes only one argument\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        auto * literal = func->arguments->children[0]->as<ASTLiteral>();\n+        if (!literal || literal->value.safeGet<String>().empty())\n+            throw Exception(\"Argument for REGEXP in Merge ENGINE should be a non empty String Literal\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        return {true, func->arguments->children[0]};\n+    }\n+\n+    auto ast = evaluateConstantExpressionForDatabaseName(node, context_);\n+    return {false, ast};\n+}\n+\n+\n void registerStorageMerge(StorageFactory & factory)\n {\n     factory.registerStorage(\"Merge\", [](const StorageFactory::Arguments & args)\n@@ -757,10 +781,11 @@ void registerStorageMerge(StorageFactory & factory)\n                 \" - name of source database and regexp for table names.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        auto [is_regexp, database_ast] = evaluateDatabaseNameForMergeEngine(engine_args[0], args.getLocalContext());\n+        auto [is_regexp, database_ast] = StorageMerge::evaluateDatabaseName(engine_args[0], args.getLocalContext());\n \n         if (!is_regexp)\n             engine_args[0] = database_ast;\n+\n         String source_database_name_or_regexp = database_ast->as<ASTLiteral &>().value.safeGet<String>();\n \n         engine_args[1] = evaluateConstantExpressionAsLiteral(engine_args[1], args.getLocalContext());\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 20460e951564..b6001815f853 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -48,12 +48,15 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora\n     bool mayBenefitFromIndexForIn(\n         const ASTPtr & left_in_operand, ContextPtr query_context, const StorageMetadataPtr & metadata_snapshot) const override;\n \n+    /// Evaluate database name or regexp for StorageMerge and TableFunction merge\n+    static std::tuple<bool /* is_regexp */, ASTPtr> evaluateDatabaseName(const ASTPtr & node, ContextPtr context);\n+\n private:\n-    using DbToTableSetMap = std::map<String, std::set<String>>;\n+    using DBToTableSetMap = std::map<String, std::set<String>>;\n \n     std::optional<OptimizedRegularExpression> source_database_regexp;\n     std::optional<OptimizedRegularExpression> source_table_regexp;\n-    std::optional<DbToTableSetMap> source_databases_and_tables;\n+    std::optional<DBToTableSetMap> source_databases_and_tables;\n \n     String source_database_name_or_regexp;\n     bool database_is_regexp = false;\n@@ -86,7 +89,7 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora\n         const String & comment,\n         const String & source_database_name_or_regexp_,\n         bool database_is_regexp_,\n-        const DbToTableSetMap & source_databases_and_tables_,\n+        const DBToTableSetMap & source_databases_and_tables_,\n         ContextPtr context_);\n \n     StorageMerge(\ndiff --git a/src/TableFunctions/TableFunctionMerge.cpp b/src/TableFunctions/TableFunctionMerge.cpp\nindex 81dde4a12a40..f1ef4262d089 100644\n--- a/src/TableFunctions/TableFunctionMerge.cpp\n+++ b/src/TableFunctions/TableFunctionMerge.cpp\n@@ -52,7 +52,7 @@ void TableFunctionMerge::parseArguments(const ASTPtr & ast_function, ContextPtr\n             \" - name of source database and regexp for table names.\",\n             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    auto [is_regexp, database_ast] = evaluateDatabaseNameForMergeEngine(args[0], context);\n+    auto [is_regexp, database_ast] = StorageMerge::evaluateDatabaseName(args[0], context);\n \n     database_is_regexp = is_regexp;\n \n@@ -65,7 +65,7 @@ void TableFunctionMerge::parseArguments(const ASTPtr & ast_function, ContextPtr\n }\n \n \n-const TableFunctionMerge::DbToTableSetMap & TableFunctionMerge::getSourceDatabasesAndTables(ContextPtr context) const\n+const TableFunctionMerge::DBToTableSetMap & TableFunctionMerge::getSourceDatabasesAndTables(ContextPtr context) const\n {\n     if (source_databases_and_tables)\n         return *source_databases_and_tables;\n@@ -88,17 +88,10 @@ const TableFunctionMerge::DbToTableSetMap & TableFunctionMerge::getSourceDatabas\n         auto databases = DatabaseCatalog::instance().getDatabases();\n \n         for (const auto & db : databases)\n-        {\n             if (database_re.match(db.first))\n-            {\n-                auto source_tables = getMatchedTablesWithAccess(db.first, source_table_regexp, context);\n-\n-                if (!source_tables.empty())\n-                    (*source_databases_and_tables)[db.first] = source_tables;\n-            }\n-        }\n+                (*source_databases_and_tables)[db.first] = getMatchedTablesWithAccess(db.first, source_table_regexp, context);\n \n-        if ((*source_databases_and_tables).empty())\n+        if (source_databases_and_tables->empty())\n             throwNoTablesMatchRegexp(source_database_name_or_regexp, source_table_regexp);\n     }\n \ndiff --git a/src/TableFunctions/TableFunctionMerge.h b/src/TableFunctions/TableFunctionMerge.h\nindex 73b61f8eb799..10221c8c72ce 100644\n--- a/src/TableFunctions/TableFunctionMerge.h\n+++ b/src/TableFunctions/TableFunctionMerge.h\n@@ -21,8 +21,8 @@ class TableFunctionMerge : public ITableFunction\n     const char * getStorageTypeName() const override { return \"Merge\"; }\n \n     using TableSet = std::set<String>;\n-    using DbToTableSetMap = std::map<String, TableSet>;\n-    const DbToTableSetMap & getSourceDatabasesAndTables(ContextPtr context) const;\n+    using DBToTableSetMap = std::map<String, TableSet>;\n+    const DBToTableSetMap & getSourceDatabasesAndTables(ContextPtr context) const;\n     ColumnsDescription getActualTableStructure(ContextPtr context) const override;\n     void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;\n     static TableSet getMatchedTablesWithAccess(const String & database_name, const String & table_regexp, const ContextPtr & context);\n@@ -30,7 +30,7 @@ class TableFunctionMerge : public ITableFunction\n     String source_database_name_or_regexp;\n     String source_table_regexp;\n     bool database_is_regexp = false;\n-    mutable std::optional<DbToTableSetMap> source_databases_and_tables;\n+    mutable std::optional<DBToTableSetMap> source_databases_and_tables;\n };\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/2024_merge_regexp_assert.reference b/tests/queries/0_stateless/2024_merge_regexp_assert.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/2024_merge_regexp_assert.sql b/tests/queries/0_stateless/2024_merge_regexp_assert.sql\nnew file mode 100644\nindex 000000000000..8ea4a77bbd89\n--- /dev/null\n+++ b/tests/queries/0_stateless/2024_merge_regexp_assert.sql\n@@ -0,0 +1,7 @@\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t (b UInt8) ENGINE = Memory;\n+SELECT a FROM merge(REGEXP('.'), '^t$'); -- { serverError 47 }\n+SELECT a FROM merge(REGEXP('\\0'), '^t$'); -- { serverError 47 }\n+SELECT a FROM merge(REGEXP('\\0a'), '^t$'); -- { serverError 47 }\n+SELECT a FROM merge(REGEXP('\\0a'), '^$'); -- { serverError 36 }\n+DROP TABLE t;\n",
  "problem_statement": "Failed assertion in `Merge` table engine with REGEXP database matching.\n**Describe the bug**\r\nhttps://clickhouse-test-reports.s3.yandex.net/29341/2b2bec3679df7965af908ce3f1e8e17e39bd12fe/fuzzer_debug/report.html#fail1\r\n\r\n**How to reproduce**\r\n```\r\nSELECT _database, _table, n FROM merge(REGEXP('\\001902_db'), '^t') ORDER BY _database ASC, _table ASC, n ASC\r\n```\r\n\r\n```\r\nstd::exception. Code: 1001, type: std::out_of_range, e.what() = map::at:  key not found \r\n```\r\n\n",
  "hints_text": "Bug was introduced here: #25064\nAlways reproducing:\r\n\r\n```\r\nSELECT * FROM merge(REGEXP('\\0'), 'a')\r\n```\n```\r\nSELECT * FROM merge(REGEXP('.'), 'a')\r\n```\nThe code is also using `DbToTableSetMap` that is out of style.\r\nWe only allow `DBToTableSetMap`.\r\n\r\nNo surprise that it also contains a bug.",
  "created_at": "2021-09-25T02:48:50Z"
}