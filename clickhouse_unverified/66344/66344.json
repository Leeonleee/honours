{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66344,
  "instance_id": "ClickHouse__ClickHouse-66344",
  "issue_numbers": [
    "64487"
  ],
  "base_commit": "860db03d13e8b3a6f76d15ea20dc4a0b8315d07a",
  "patch": "diff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\nindex 698602ca5bcb..bd8b6f9faa1f 100644\n--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n@@ -11,6 +11,7 @@\n \n #include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeTuple.h>\n \n namespace DB\n {\n@@ -615,6 +616,7 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n             bool is_any_nullable = false;\n             Tuple args;\n             args.reserve(equals_functions.size());\n+            DataTypes tuple_element_types;\n             /// first we create tuple from RHS of equals functions\n             for (const auto & equals : equals_functions)\n             {\n@@ -627,16 +629,18 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n                 if (const auto * rhs_literal = equals_arguments[1]->as<ConstantNode>())\n                 {\n                     args.push_back(rhs_literal->getValue());\n+                    tuple_element_types.push_back(rhs_literal->getResultType());\n                 }\n                 else\n                 {\n                     const auto * lhs_literal = equals_arguments[0]->as<ConstantNode>();\n                     assert(lhs_literal);\n                     args.push_back(lhs_literal->getValue());\n+                    tuple_element_types.push_back(lhs_literal->getResultType());\n                 }\n             }\n \n-            auto rhs_node = std::make_shared<ConstantNode>(std::move(args));\n+            auto rhs_node = std::make_shared<ConstantNode>(std::move(args), std::make_shared<DataTypeTuple>(std::move(tuple_element_types)));\n \n             auto in_function = std::make_shared<FunctionNode>(\"in\");\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.reference b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.reference\nnew file mode 100644\nindex 000000000000..353c8f98b03a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.reference\n@@ -0,0 +1,2 @@\n+2020-01-01\n+2020-01-02\ndiff --git a/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.sql b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.sql\nnew file mode 100644\nindex 000000000000..f9ba28bcd600\n--- /dev/null\n+++ b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.sql\n@@ -0,0 +1,12 @@\n+SET allow_experimental_analyzer=1;\n+CREATE TABLE foo (i Date) ENGINE MergeTree ORDER BY i;\n+INSERT INTO foo VALUES ('2020-01-01');\n+INSERT INTO foo VALUES ('2020-01-02');\n+\n+SET optimize_min_equality_disjunction_chain_length = 3;\n+SELECT *\n+FROM foo\n+WHERE (foo.i = parseDateTimeBestEffort('2020-01-01'))\n+   OR (foo.i = parseDateTimeBestEffort('2020-01-02'))\n+   OR (foo.i = parseDateTimeBestEffort('2020-01-03'))\n+ORDER BY foo.i ASC\n",
  "problem_statement": "Incorrect optimization of multiple OR in the WHERE clause when analyzer is enabled\nTested with 24.4 in Docker.\r\n\r\nWith 3 or more variants provided in the WHERE clause with OR, a seemingly correct query returns zero results.\r\n\r\nA minimal repro: \r\n\r\n```sql\r\nSET allow_experimental_analyzer=1;\r\nCREATE OR REPLACE TABLE foo (i Date) ENGINE MergeTree ORDER BY i;\r\nINSERT INTO foo VALUES ('2020-01-01');\r\nINSERT INTO foo VALUES ('2020-01-02');\r\n```\r\n\r\nThis query returns two records, as expected:\r\n\r\n```sql\r\nSELECT *\r\nFROM default.foo\r\nWHERE (default.foo.i = parseDateTimeBestEffort('2020-01-01')) \r\n    OR (default.foo.i = parseDateTimeBestEffort('2020-01-02'))\r\nORDER BY i ASC\r\nLIMIT 1048575\r\n```\r\n\r\n```\r\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500i\u2500\u2510\r\n1. \u2502 2020-01-01 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500i\u2500\u2510\r\n2. \u2502 2020-01-02 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nHowever, if we add a third variant via OR, the query returns an empty result set:\r\n\r\n```sql\r\nSELECT *\r\nFROM default.foo\r\nWHERE (default.foo.i = parseDateTimeBestEffort('2020-01-01'))\r\n   OR (default.foo.i = parseDateTimeBestEffort('2020-01-02'))\r\n   OR (default.foo.i = parseDateTimeBestEffort('2020-01-03'))\r\nORDER BY default.foo.i ASC\r\nLIMIT 1048575\r\n```\r\n\r\nA quote from @vdimir:\r\n\r\n> It's a bug in query tree optimization (if you are interested, check out `EXPLAIN QUERY TREE dump_ast = 1` for 3 conditions they are rewritten to `default.foo.i IN (...)` and seems this particular rewrite is incorrect). Current workaround is to disable this optimization with `SET optimize_min_equality_disjunction_chain_length = 4294967295;`\r\n\r\nFiddle: https://fiddle.clickhouse.com/9dd6a6a5-2496-4343-8b40-aabf57aa8bc1\n",
  "hints_text": "https://fiddle.clickhouse.com/acab3b08-7eee-427c-8cb6-fc0cd8bb6e2d\r\nIt seems that the In operator did not perform the correct type conversion",
  "created_at": "2024-07-10T13:42:26Z",
  "modified_files": [
    "src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.reference",
    "b/tests/queries/0_stateless/03203_optimize_disjunctions_chain_to_in.sql"
  ]
}