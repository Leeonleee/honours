{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46611,
  "instance_id": "ClickHouse__ClickHouse-46611",
  "issue_numbers": [
    "46557"
  ],
  "base_commit": "51e923895000a23fb88f7b80fb9d8b77586b2226",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp\nindex 49458be42325..531f48377a90 100644\n--- a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp\n@@ -170,16 +170,16 @@ ChunkAndProgress IMergeTreeSelectAlgorithm::read()\n             return ChunkAndProgress{\n                 .chunk = Chunk(ordered_columns, res.row_count),\n                 .num_read_rows = res.num_read_rows,\n-                .num_read_bytes = res.num_read_bytes};\n+                .num_read_bytes = res.num_read_bytes,\n+                .is_finished = false};\n         }\n         else\n         {\n-            num_read_rows += res.num_read_rows;\n-            num_read_bytes += res.num_read_bytes;\n+            return {Chunk(), res.num_read_rows, res.num_read_bytes, false};\n         }\n     }\n \n-    return {Chunk(), num_read_rows, num_read_bytes};\n+    return {Chunk(), num_read_rows, num_read_bytes, true};\n }\n \n void IMergeTreeSelectAlgorithm::initializeMergeTreeReadersForCurrentTask(\ndiff --git a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h\nindex c6680676ce93..22c15635529f 100644\n--- a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h\n+++ b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h\n@@ -20,6 +20,9 @@ struct ChunkAndProgress\n     Chunk chunk;\n     size_t num_read_rows = 0;\n     size_t num_read_bytes = 0;\n+    /// Explicitly indicate that we have read all data.\n+    /// This is needed to occasionally return empty chunk to indicate the progress while the rows are filtered out in PREWHERE.\n+    bool is_finished = false;\n };\n \n struct ParallelReadingExtension\ndiff --git a/src/Storages/MergeTree/MergeTreeSource.cpp b/src/Storages/MergeTree/MergeTreeSource.cpp\nindex ae1679cebfd5..a37d1d3ec2cc 100644\n--- a/src/Storages/MergeTree/MergeTreeSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSource.cpp\n@@ -176,15 +176,16 @@ ISource::Status MergeTreeSource::prepare()\n }\n \n \n-std::optional<Chunk> MergeTreeSource::reportProgress(ChunkAndProgress chunk)\n+Chunk MergeTreeSource::processReadResult(ChunkAndProgress chunk)\n {\n     if (chunk.num_read_rows || chunk.num_read_bytes)\n         progress(chunk.num_read_rows, chunk.num_read_bytes);\n \n-    if (chunk.chunk.hasRows())\n-        return std::move(chunk.chunk);\n+    finished = chunk.is_finished;\n \n-    return {};\n+    /// We can return a chunk with no rows even if are not finished.\n+    /// This allows to report progress when all the rows are filtered out inside MergeTreeBaseSelectProcessor by PREWHERE logic.\n+    return std::move(chunk.chunk);\n }\n \n \n@@ -194,7 +195,7 @@ std::optional<Chunk> MergeTreeSource::tryGenerate()\n     if (async_reading_state)\n     {\n         if (async_reading_state->getStage() == AsyncReadingState::Stage::IsFinished)\n-            return reportProgress(async_reading_state->getResult());\n+            return processReadResult(async_reading_state->getResult());\n \n         chassert(async_reading_state->getStage() == AsyncReadingState::Stage::NotStarted);\n \n@@ -220,7 +221,7 @@ std::optional<Chunk> MergeTreeSource::tryGenerate()\n     }\n #endif\n \n-    return reportProgress(algorithm->read());\n+    return processReadResult(algorithm->read());\n }\n \n #if defined(OS_LINUX)\ndiff --git a/src/Storages/MergeTree/MergeTreeSource.h b/src/Storages/MergeTree/MergeTreeSource.h\nindex bba0c0af80e4..463faad0fabe 100644\n--- a/src/Storages/MergeTree/MergeTreeSource.h\n+++ b/src/Storages/MergeTree/MergeTreeSource.h\n@@ -36,7 +36,7 @@ class MergeTreeSource final : public ISource\n     std::unique_ptr<AsyncReadingState> async_reading_state;\n #endif\n \n-    std::optional<Chunk> reportProgress(ChunkAndProgress chunk);\n+    Chunk processReadResult(ChunkAndProgress chunk);\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.reference b/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.sh b/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.sh\nnew file mode 100755\nindex 000000000000..a25d72f357de\n--- /dev/null\n+++ b/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.sh\n@@ -0,0 +1,23 @@\n+#!/usr/bin/expect -f\n+# Tags: no-tsan, no-asan, no-ubsan, no-msan, no-debug, no-fasttest\n+\n+log_user 0\n+set timeout 60\n+match_max 10000000\n+\n+# Run query that filters all rows in PREWHERE\n+spawn clickhouse-local --progress -m -n --query \"CREATE TABLE test_progress(n UInt64) ENGINE=MergeTree ORDER BY tuple() SETTINGS index_granularity=10 AS SELECT number FROM numbers(10000); SELECT count() FROM test_progress PREWHERE sleepEachRow(0.01) OR n > 1000000 SETTINGS max_block_size=10;\"\n+\n+# Expect that progress is updated\n+expect {\n+    \"10.00 rows,\" { exit 0 }\n+    \"20.00 rows,\" { exit 0 }\n+    \"30.00 rows,\" { exit 0 }\n+    \"40.00 rows,\" { exit 0 }\n+    \"50.00 rows,\" { exit 0 }\n+    \"60.00 rows,\" { exit 0 }\n+    \"70.00 rows,\" { exit 0 }\n+    \"80.00 rows,\" { exit 0 }\n+    \"90.00 rows,\" { exit 0 }\n+    timeout { exit 1 }\n+}\n",
  "problem_statement": "Zero CPU usage and no progress displayed when no blocks are returned if optimization of PREWHERE is performed.\n```\r\nSELECT user_screen_name, text FROM twitter WHERE text LIKE '%fg;jkglmsdn874fdskjlsfdghn%'\r\n```\r\n\n",
  "hints_text": "The issue is fixed if I do `SET optimize_move_to_prewhere = 0`.\nThis is wrong:\r\n\r\n![Screenshot_20230219_012612](https://user-images.githubusercontent.com/18581488/219905497-3272365b-2e8a-4ae9-9a8a-d84d9b3457ca.png)\r\n",
  "created_at": "2023-02-20T16:18:13Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp",
    "src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h",
    "src/Storages/MergeTree/MergeTreeSource.cpp",
    "src/Storages/MergeTree/MergeTreeSource.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02666_progress_when_no_rows_from_prewhere.sh"
  ]
}