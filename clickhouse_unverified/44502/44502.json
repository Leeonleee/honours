{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44502,
  "instance_id": "ClickHouse__ClickHouse-44502",
  "issue_numbers": [
    "44240"
  ],
  "base_commit": "25a4361fae7b905dbbd61273306fd17a89ff5891",
  "patch": "diff --git a/src/Dictionaries/NullDictionarySource.cpp b/src/Dictionaries/NullDictionarySource.cpp\nnew file mode 100644\nindex 000000000000..45dcc77f93d0\n--- /dev/null\n+++ b/src/Dictionaries/NullDictionarySource.cpp\n@@ -0,0 +1,48 @@\n+#include \"NullDictionarySource.h\"\n+#include <Interpreters/Context.h>\n+#include <Processors/Sources/NullSource.h>\n+#include <Common/logger_useful.h>\n+#include \"DictionarySourceFactory.h\"\n+#include \"DictionarySourceHelpers.h\"\n+#include \"DictionaryStructure.h\"\n+#include \"registerDictionaries.h\"\n+\n+\n+namespace DB\n+{\n+NullDictionarySource::NullDictionarySource(Block & sample_block_) : sample_block(sample_block_)\n+{\n+}\n+\n+NullDictionarySource::NullDictionarySource(const NullDictionarySource & other) : sample_block(other.sample_block)\n+{\n+}\n+\n+QueryPipeline NullDictionarySource::loadAll()\n+{\n+    LOG_TRACE(&Poco::Logger::get(\"NullDictionarySource\"), \"loadAll {}\", toString());\n+    return QueryPipeline(std::make_shared<NullSource>(sample_block));\n+}\n+\n+\n+std::string NullDictionarySource::toString() const\n+{\n+    return \"Null\";\n+}\n+\n+\n+void registerDictionarySourceNull(DictionarySourceFactory & factory)\n+{\n+    auto create_table_source\n+        = [=](const DictionaryStructure & /* dict_struct */,\n+              const Poco::Util::AbstractConfiguration & /* config */,\n+              const std::string & /* config_prefix */,\n+              Block & sample_block,\n+              ContextPtr /* global_context */,\n+              const std::string & /* default_database */,\n+              bool /* created_from_ddl*/) -> DictionarySourcePtr { return std::make_unique<NullDictionarySource>(sample_block); };\n+\n+    factory.registerSource(\"null\", create_table_source);\n+}\n+\n+}\ndiff --git a/src/Dictionaries/NullDictionarySource.h b/src/Dictionaries/NullDictionarySource.h\nnew file mode 100644\nindex 000000000000..7eb02055e3ab\n--- /dev/null\n+++ b/src/Dictionaries/NullDictionarySource.h\n@@ -0,0 +1,53 @@\n+#pragma once\n+\n+#include <Core/Block.h>\n+#include \"IDictionarySource.h\"\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n+/// Allows creating empty dictionary\n+class NullDictionarySource final : public IDictionarySource\n+{\n+public:\n+    NullDictionarySource(Block & sample_block_);\n+\n+    NullDictionarySource(const NullDictionarySource & other);\n+\n+    QueryPipeline loadAll() override;\n+\n+    QueryPipeline loadUpdatedAll() override\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Method loadUpdatedAll is unsupported for NullDictionarySource\");\n+    }\n+\n+    QueryPipeline loadIds(const std::vector<UInt64> & /*ids*/) override\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Method loadIds is unsupported for NullDictionarySource\");\n+    }\n+\n+    QueryPipeline loadKeys(const Columns & /*key_columns*/, const std::vector<size_t> & /*requested_rows*/) override\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Method loadKeys is unsupported for NullDictionarySource\");\n+    }\n+\n+    bool isModified() const override { return false; }\n+\n+    bool supportsSelectiveLoad() const override { return false; }\n+\n+    ///Not supported for NullDictionarySource\n+    bool hasUpdateField() const override { return false; }\n+\n+    DictionarySourcePtr clone() const override { return std::make_shared<NullDictionarySource>(*this); }\n+\n+    std::string toString() const override;\n+\n+private:\n+    Block sample_block;\n+};\n+\n+}\ndiff --git a/src/Dictionaries/registerDictionaries.cpp b/src/Dictionaries/registerDictionaries.cpp\nindex 4ade5d88bd43..f0526f4ce376 100644\n--- a/src/Dictionaries/registerDictionaries.cpp\n+++ b/src/Dictionaries/registerDictionaries.cpp\n@@ -6,6 +6,7 @@ namespace DB\n \n class DictionarySourceFactory;\n \n+void registerDictionarySourceNull(DictionarySourceFactory & factory);\n void registerDictionarySourceFile(DictionarySourceFactory & source_factory);\n void registerDictionarySourceMysql(DictionarySourceFactory & source_factory);\n void registerDictionarySourceClickHouse(DictionarySourceFactory & source_factory);\n@@ -36,6 +37,7 @@ void registerDictionaries()\n {\n     {\n         auto & source_factory = DictionarySourceFactory::instance();\n+        registerDictionarySourceNull(source_factory);\n         registerDictionarySourceFile(source_factory);\n         registerDictionarySourceMysql(source_factory);\n         registerDictionarySourceClickHouse(source_factory);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02514_null_dictionary_source.reference b/tests/queries/0_stateless/02514_null_dictionary_source.reference\nnew file mode 100644\nindex 000000000000..bb08ece2bcf5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02514_null_dictionary_source.reference\n@@ -0,0 +1,4 @@\n+0\t\\N\t111\t0\t111\n+123\t\\N\t111\t123\t111\n+\\N\t\\N\t111\n+77\ndiff --git a/tests/queries/0_stateless/02514_null_dictionary_source.sql b/tests/queries/0_stateless/02514_null_dictionary_source.sql\nnew file mode 100644\nindex 000000000000..74fb57707ff1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02514_null_dictionary_source.sql\n@@ -0,0 +1,48 @@\n+-- Tags: no-parallel\n+\n+DROP DICTIONARY IF EXISTS null_dict;\n+CREATE DICTIONARY null_dict (\n+    id              UInt64,\n+    val             UInt8,\n+    default_val     UInt8 DEFAULT 123,\n+    nullable_val    Nullable(UInt8)\n+)\n+PRIMARY KEY id\n+SOURCE(NULL())\n+LAYOUT(FLAT())\n+LIFETIME(0);\n+\n+SELECT\n+    dictGet('null_dict', 'val', 1337),\n+    dictGetOrNull('null_dict', 'val', 1337),\n+    dictGetOrDefault('null_dict', 'val', 1337, 111),\n+    dictGetUInt8('null_dict', 'val', 1337),\n+    dictGetUInt8OrDefault('null_dict', 'val', 1337, 111);\n+\n+SELECT\n+    dictGet('null_dict', 'default_val', 1337),\n+    dictGetOrNull('null_dict', 'default_val', 1337),\n+    dictGetOrDefault('null_dict', 'default_val', 1337, 111),\n+    dictGetUInt8('null_dict', 'default_val', 1337),\n+    dictGetUInt8OrDefault('null_dict', 'default_val', 1337, 111);\n+\n+SELECT\n+    dictGet('null_dict', 'nullable_val', 1337),\n+    dictGetOrNull('null_dict', 'nullable_val', 1337),\n+    dictGetOrDefault('null_dict', 'nullable_val', 1337, 111);\n+\n+SELECT val, nullable_val FROM null_dict;\n+\n+DROP DICTIONARY IF EXISTS null_ip_dict;\n+CREATE DICTIONARY null_ip_dict (\n+    network String,\n+    val     UInt8 DEFAULT 77\n+)\n+PRIMARY KEY network\n+SOURCE(NULL())\n+LAYOUT(IP_TRIE())\n+LIFETIME(0);\n+\n+SELECT dictGet('null_ip_dict', 'val', toIPv4('127.0.0.1'));\n+\n+SELECT network, val FROM null_ip_dict;\n",
  "problem_statement": "Empty source for external dictionaries\n**Feature**\r\n\r\nAllow creating empty dictionaries with DDL queries.\r\n\r\n**Use case**\r\n\r\nThis feature will allow building queries and views referencing empty dictionary with `dictGet` or 'as a table', \r\neven if dictionary does not exist yet.\r\n\r\nMaybe, empty dictionaries does not make sense in 'clickhouse as a part of internal infrastructure', this will \r\nfeature may be useful in cases when clickhouse is used as a database for small application that configures\r\nclickhouse automatically, and some dictionaries may be optional or provided by application  user.\r\n\r\n**Describe the solution you'd like**\r\n\r\nProvide mock source `SOURCE(EMPTY())` for dictionaries, such that every `dictGet` call will return `null_value`.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nMake source section optional for dictionaries.\r\n\n",
  "hints_text": "Nice.\r\n\r\nThere is another use-case - if there is a cluster with a dedicated empty gateway server for accepting distributed queries, this server still needs dictionaries to be configured - for query analysis.\r\n\r\nAs we have the `Null` table engine, the dictionary source can also be named Null, if possible.",
  "created_at": "2022-12-21T22:06:22Z"
}